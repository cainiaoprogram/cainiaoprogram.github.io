<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8ea1112df71bd5f235735e8ac0a69da/" rel="bookmark">
			ref 在 setup（）函数里面的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		先来回顾下 Vue2里面如何使用 调用ref 属性 ：： 通过 this . $ref 调用 。 但setup函数无法获取 this 。
所以 ，在setup函数里面 定义一个const headline = ref（null），再return headline， 最后再把 headline 放在 模板的ref属性里 ref = “headline" 。 const headline = ref(null) 做完这两步之后，就可以直接在setup函数里 headline.value 调用 ， = 之前的 this . $headline.
值得注意的是，ref拿到的是 整个标签元素 或 整个组件元素
&lt;script&gt; import { onMounted, ref, } from 'vue'; export default { setup() { const headline = ref(null); // Before the component is mounted, the value // of the ref is `null` which is the default // value we've specified above.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8ea1112df71bd5f235735e8ac0a69da/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7aeda932a949d5f7a432802054535791/" rel="bookmark">
			P73按字寻址和按字节寻址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于唐书P73
存储字=存储单元
存储字长为32位，1个字有4个字节
按字节寻址，需要两条地址线来表示一个字中四个字节的位置（00，01，10，11），故24条地址线使用22条地址线来表示存储单元的个数，即2^22个存储单元。
存储容量=存储单元个数*存储字长
此时存储容量为2^22 *32=2^27=16MB
此时按字寻址的寻址范围为4M
因为存储容量是不变的，故按字节寻址的寻址范围为16M
按字节寻址的寻址范围也可以直接用2^24表示，此时存储字长为为8位，存储容量等于8* 2^24，然后根据存储容量计算字长为32位时的存储单元个数即存储字个数
不知道是不是对的，一起讨论啊！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/49a39511969df90a6af391dd9be38d1c/" rel="bookmark">
			推动小案例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		推动小案例
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
开发工具与关键技术：Axure RP8
撰写时间：2021/8/12
1.拉出文本段落，打上几段文字
2.拉出图片，选择自己喜欢的图片，设置尺寸为610*402
3.再拉出文本段落，打上几段文字
4.拉出文本标签，打上“展开更多”，字体大小为32，点上加粗效果，字体颜色为黑色
5.拉出文本段落，打出几段文字
6.拉出图片，选择自己喜欢的图片，设置大小为356*175
7.把第三个文本段落与小图片编一个组，备注为“隐藏内容”
8.拉出文本标签，打上“收起”，设置大小为32，字体加粗，颜色为黑色
9.把“收起”与“展开更多”并排
10.把“隐藏内容”与“收起”给选中，勾选住隐藏
11.点击“展开更多”，双击鼠标单击时，点击显示，勾选住隐藏内容，动画为向下滑动，更多选项中选择推动元件，动画为线性
12.点击显示，勾选住“收起”
13.点击隐藏，勾选住“展开更多”
14.点击“收起”，双击鼠标单击时，点击隐藏，勾选住隐藏内容，动画选择为向上滑动，，勾选拉动元件，动画为线性
15.点击显示，勾选“展开更多”
16.点击隐藏，勾选“收起”
推动小案例整体效果就完成了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82583e9e0834bce3c5a5faadd796e3d8/" rel="bookmark">
			显示与隐藏
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		显示与隐藏
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
开发工具与关键技术：Axure RP8
撰写时间：2021/7/18
1.拉出一个矩形，设置大小为758*606，颜色为淡紫色
2.拉出文本标签，打上“显示与隐藏”，字体大小为20，加粗效果，字体颜色为白色
3.拉出图片，双击选择自己喜欢的图片，设置大小为174*128，把备注改成xt1
4.接下3张图片是复制xt1，然后选择不同的图片，再把备注分别改为xt2，xt3，xt4
5.然后复制xt1，设置大小为467*382，把备注改成dt1
6.接下的dt2，dt3，dt4都是按照上一步骤完成（备注分别改成dt2，dt3，dt4）
7.选中4张大图，勾选隐藏
8.选中xt1，双击鼠标单击时，点击显示，勾选dt1，动画设置为向右滑动，勾选置于顶层
9.选中xt2，双击鼠标单击时，点击显示，勾选dt2，动画设置为向左翻转，勾选置于顶层
10.选中xt3，双击鼠标单击时，点击显示，勾选dt3，动画设置为向左滑动，勾选置于顶层
11.选中xt4，双击鼠标单击时，点击显示，勾选dt4，动画设置为向上翻转，勾选置于顶层
12.选中dt1，双击鼠标单击时，点击隐藏，勾选dt1，动画设置为向左滑动
13.选中dt2，双击鼠标单击时，点击隐藏，勾选dt2，动画设置为向右翻转
14.选中dt3，双击鼠标单击时，点击隐藏，勾选dt3，动画设置为向右滑动
15.选中dt4，双击鼠标单击时，点击隐藏，勾选dt5，动画设置为向下翻转
显示与隐藏案例就完成了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57b9aa2c4b459bebca3fdb656ab7de05/" rel="bookmark">
			Intellij IDEA创建XML, DTD和XML Schema（xsd）文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Intellij IDEA创建XML, DTD和XML Schema（xsd）文件 文章目录 Intellij IDEA创建XML, DTD和XML Schema（xsd）文件创建XMl文件创建DTD文件创建XML Schema（xsd）文件 创建XMl文件 &lt;?xml version="1.0" encoding="UTF-8" ?&gt; 创建DTD文件 &lt;?xml version="1.0" encoding="UTF-8" ?&gt; 创建XML Schema（xsd）文件 &lt;?xml version="1.0" encoding="UTF-8" ?&gt; &lt;schema xmlns="http://www.w3.org/2001/XMLSchema" targetNamespace="http://www.w3school.com.cn" xmlns="http://www.w3school.com.cn" elementFormDefault="qualified"&gt; &lt;/schema&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d776f844a75d75b953e07e531876efc/" rel="bookmark">
			Spring Boot while scanning for the next tokenfound character ‘@‘ that cannot start any token问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述： Caused by: org.yaml.snakeyaml.scanner.ScannerException: while scanning for the next token
found character '@' that cannot start any token. (Do not use @ for indentation) in 'reader', line 91, column 19: password: @123
问题分析： 1、password参数值以@开头导致报错。
url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8 username: root password: @123 解决办法：
password参数值添加单引号。
url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=true&amp;serverTimezone=GMT%2B8 username: root password: '@123' 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba43ac699a63019afdd5a2739cfd0028/" rel="bookmark">
			【vscode】能够正确生成exe文件但是不会自动运行打开
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决方案 由于新版本的C/C++插件升级到了v1.6.0导致出现此问题，只需要手动安装低版本如1.5.1即可解决此问题
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bb976f738851f44044c58df75ce7eb6/" rel="bookmark">
			436-分支限界算法-0-1背包问题(两种队列实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分支限界算法解决0-1背包问题-FIFO队列 广度优先遍历：一层一层遍历，每层是从左向右遍历。
int w[] = { 16,15,15 };//物品的重量 int v[] = { 45,25,25 };//物品的价值 背包的容量c是30，图解如下：
最优节点是图中叶子节点打√的那个节点
相当于左子树加约束条件了，右子树进行限界了。
我们把根节点描述成nullptr
//分支限界算法 - 01背包问题 FIFO队列 int w[] = { 16,15,15 };//物品的重量 int v[] = { 45, 25, 25 };//物品的价值 int c = 30;//背包的容量 const int n = sizeof(w) / sizeof(w[0]);//物品的个数 int cw = 0;//已选择物品的重量 int cv = 0;//已选择物品的价值 int bestv = 0;//装入背包的物品的最优价值 //描述节点类型 struct Node { Node(int w, int v, int l, Node *p, bool left) { weight = w; value = v; level = l; parent = p; isleft = left; } int weight;//已选择物品的总重量 int value;//已选择物品的总价值 int level;//节点所在的层数 Node *parent;//记录父节点 bool isleft;//节点是否被选择 }; Node *bestnode = nullptr;//记录最优解的叶子节点 queue&lt;Node*&gt; que;//广度遍历需要的FIFO队列 void addLiveNode(int w, int v, int l, Node *parent, bool isleft) { Node *node = new Node(w, v, l, parent, isleft); que.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9bb976f738851f44044c58df75ce7eb6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b32c3dfb15d394196baf49c27591a65/" rel="bookmark">
			接入腾讯云短信服务（史上最详细&#43;该短信服务如何申请成功&#43;发送短信验证码API讲解&#43;相关错误分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2021 / 8 / 17 / 23 : 01 {2021/8/17/23:01} 2021/8/17/23:01
文章目录 前言一、如何成功申请到腾讯云短信服务1、签名申请2、正文模板申请 二、发送短信API开发1、腾讯云在线测试2、使用springboot进行测试 三、常见的错误分析 前言 或许有的人会问我为什么不使用阿里云短信服务，那是因为如今的阿里云短信服务对于大部分人来说很难申请成功，它需要备案或者项目已经上线。而腾讯云短信相对来说比较宽松一些，可以利用个人公众号进行申请成功
提示：以下是本篇文章正文内容
一、如何成功申请到腾讯云短信服务 首先开通短信服务，应该会免费赠送100条短信
1、签名申请 我 已 经 测 试 申 请 过 一 次 {我已经测试申请过一次} 我已经测试申请过一次
点击创建签名
微信公众号平台链接：https://www.baidu.com/link?url=3OqiiGcBpe8Gp5YpnN4wF7CiaFkigOjrPtN3xjuIWLF1EDlRASXa3EDgeaQNn8k6&amp;wd=&amp;eqid=d95710f900018b6500000003611bd16a
2、正文模板申请 点击创建正文模板
等待审核即可
二、发送短信API开发 1、腾讯云在线测试 先进行在线测试，后面再使用代码测试
测试地址：https://console.cloud.tencent.com/api/explorer?Product=sms&amp;Version=2021-01-11&amp;Action=SendSms&amp;SignVersion=
1、SmsSdkAppId：短信 SdkAppId，在 短信控制台 添加应用后生成的实际 SdkAppId
2、TemplateId：模板 ID，必须填写已审核通过的模板 ID。模板 ID 可登录 短信控制台 查看，若向境外手机号发送短信，仅支持使用国际/港澳台短信模板。
3、SignName：短信签名内容，使用 UTF-8 编码，必须填写已审核通过的签名，例如：腾讯云，签名信息可登录 短信控制台 查看。 国内短信为必填参数。
点击发送请求
成功！
2、使用springboot进行测试 1.文档参考准备工作
可以在云端直接进行生成代码
也可以参考API文档
API文档链接地址：https://cloud.tencent.com/document/product/382/43194
2.导入依赖
&lt;dependency&gt; &lt;groupId&gt;com.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b32c3dfb15d394196baf49c27591a65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0b186fe7274b9dd125d0580ef14f6d9/" rel="bookmark">
			Android基础TextView 实现跑马灯效果
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android基础TextView 实现跑马灯效果： 提示：这里可以添加学习目标
例如：一周掌握 Java 入门知识
只需要关注5个属性： 第一个是要单行显示
第二个是单行显示多余部分如何显示,即 ellipsize 属性的设置
第三个是获取焦点
第四个是走马灯重复次数
第五个是强制的获得了焦点,让 View 响应所有的 touch 事件
解决BUG： 只有一个TextView会有走马灯的效果，产生这个问题的原因是第一个TextView抢得了焦点。
布局文件中加一个EditText的话，第一个走马灯就会停止
弹出对话框后，跑马灯效果就停止了
完整的自定义View： import android.content.Context; import android.graphics.Rect; import android.text.TextUtils; import android.util.AttributeSet; import android.widget.TextView; public class MarqueeTextView extends TextView { public MarqueeTextView(Context context) { this(context, null); } public MarqueeTextView(Context context, AttributeSet attrs) { super(context, attrs); //设置单行 setSingleLine(); //设置Ellipsize setEllipsize(TextUtils.TruncateAt.MARQUEE); //获取焦点 setFocusable(true); //走马灯的重复次数，-1代表无限重复 setMarqueeRepeatLimit(-1); //强制获得焦点 setFocusableInTouchMode(true); } /* *这个属性这个View得到焦点,在这里我们设置为true,这个View就永远是有焦点的 */ @Override public boolean isFocused() { return true; } /* * 用于EditText抢注焦点的问题 * */ @Override protected void onFocusChanged(boolean focused, int direction, Rect previouslyFocusedRect) { if (focused) { super.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0b186fe7274b9dd125d0580ef14f6d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78a0de5bbaccaf9e250ba685cbe2e5be/" rel="bookmark">
			负载均衡 - MQTT Broker 集群详解（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MQTT 协议在物联网，小型设备场景，移动应用等方面已经有了广泛的应用，并逐渐成为了物联网通讯的标准。本文重点介绍了组建 MQTT Broker 集群的挑战及负载均衡在 MQTT 集群中所起的作用。
MQTT 协议 与大家熟悉的 HTTP 协议类似，MQTT 协议同样基于 TCP/TLS 之上，属于应用层协议（它也可以基于 HTTP 协议之上工作，本文暂不涉及这部分内容）。
MQTT 标准委员会对 MQTT 协议的释义如下：
MQTT 是用于物联网 (IoT) 的 OASIS 标准消息传递协议。它是一种非常轻量级的消息传输协议，采用了发布/订阅的机制，非常适合连接远程设备，无论是代码占用空间还是网络带宽的占用都很小。如今，MQTT 已被广泛用于汽车、工业制造、电信、石油和天然气等各个行业。
MQTT 客户端和 HTTP 客户端也很相似。它与服务器端建立一个 TCP 连接，通过该连接传输数据。不同的是，HTTP 采用的是请求/响应模型，而 MQTT 采用的是发布/订阅模型。
举个例子：客厅里安装的温度传感器，会间断性的把室内温度数值上传到 MQTT 服务器上。而另一个智能家居设备订阅了这个温度传感器发布消息的频道，就可以获得室内的温度数据，并根据实际室温采取一些智能应对措施，比如当室内温度超过 32°C 时就打开空调。
可拓展性挑战 MQTT 协议听起来似乎离我们很遥远，其实它早已渗透到了我们的日常生活中。一般情况下，单个 MQTT 节点就可以满足单个家庭的智能家居设备连接需求，用户甚至可以在树莓派上运行一个 EMQ X Edge （运行在边缘端的 MQTT 服务器）。而运行在云端的一个 EMQ X 节点可以支撑高达 200 万的连接数，轻松满足普通智能家居场景需求。
但如果是全国的千百万辆汽车要联网，或者是上百万盏路灯要传递数据之类的场景，那么巨大的设备数（MQTT 客户端）和数据吞吐量，就远远超出了单个 MQTT 节点所能承受的压力，需要组建 MQTT 服务器集群。
在组建集群的同时，也面临着一系列的技术挑战：
提供服务地址：如何让客户端知道该连接哪个地址？
不同节点如何接管 MQTT 订阅者的会话，比如当一个客户端从一台服务器断连后，要如何在另一台服务器恢复连接？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/78a0de5bbaccaf9e250ba685cbe2e5be/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/699049493c511daad52ce2c8ce47ee76/" rel="bookmark">
			一文了解推荐系统中的图神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		来源：RUC AI Box 本文约4600字，建议阅读9分钟 本文主要介绍推荐系统中的图神经网络，欢迎交流探讨！ [ 引言 ]近年来，GNN技术由于其在图数据学习方面的出色表现，在许多领域得到了广泛的应用。在推荐系统中，大部分信息本质上具有图结构，而由于GNN对于表示学习具有一定的优势，所以GNN在推荐系统相关领域的应用迅速发展。本文尽可能用通俗的语言代替算法公式来进行讲述，希望可以让读者对推荐系统中的图神经网络有一个基本的了解。
一、什么是图神经网络？
Graph Neural Network（GNN），顾名思义，图上的神经网络，为了理解GNN，需要弄清楚以下两个问题：
1. 首先，什么是图（Graph）？简单来讲，图是定义了节点（node）和连接方式（edge）的一种结构，节点和边都分别具有其性质，比如化学分子（原子/键）、城市地铁（站台/铁路）、社交网络（人/关系）。
2. 其次，怎么把图塞到神经网络里？
直观上想，近朱者赤近墨者黑，一个节点跟他所连接的节点应该有一些相似的关系，那么就可以利用这些特定的关系来帮助我们的模型学到好的节点表示，那么怎么做到这件事呢？
回想一下卷积神经网络（CNN），做卷积的过程中，放一个卷积核，然后相乘相加，做完了之后就可以得到下一层的 feature map，同样的，可以将类似的操作推广到图结构上。
图结构中，每个节点有一个表示，就像CNN中每个点有个值，可以很自然的去想去通过看他的邻居的值来进行特征聚集，比如说下图中3号节点有三个邻居，分别是0/2/4号节点，通过对邻居节点的表示进行计算来得到其下一层的 feature map。
最后，可以利用传播过程所得到的各层表示来进一步完成后续任务（例如节点分类/边预测/节点内积预测匹配度等等）。
以上介绍的是一种比较简单容易理解的结构，希望读者可以以此为基础理解图神经网络的基本思想。而根据结构设计不同，GNN模型可以划分为以下几种，RecGNN、ConvGNN、STGNN和GAE [8]，此处不再详细介绍，感兴趣的读者可以自行查阅相关资料。而在推荐系统中，常见的GNN框架主要有以下几种：GCN [2]，GraphSage [3]，GAT [4]，GCNN [5]等。
二、为什么要在推荐系统中使用图神经网络？
其实最通俗的原因就是GNN表现好，并且推荐系统中的大部分数据（本质上可以看作图结构数据）适合使用GNN。接下来分类进行详细介绍：
首先将推荐系统大致分为两类：一般的推荐（general recommendation）和序列化推荐（sequential recommendation），简单来讲，就是根据需不需要考虑时间顺序来进行划分，前者将用户偏好视为静态的，学习用户和物品的静态表示，后者认为用户偏好随时间动态变化，根据交互序列来预测用户下一个可能喜欢的物品。
推荐系统中用到的数据，主要包括以下几种（见下图）：
对于 general recommendation：交互数据，可以看作二部图（bipartite graph）
对于 sequential recommendation：物品序列，可以抽象成序列图（sequence graph）
其他辅助信息：社会关系（social relationship）和知识图谱（knowledge graph）均可以看作图结构数据
除了数据方面，对于具体的学习过程而言，GNN具有以下优点 [6]：
对于 general recommendation：GNN可以通过节点聚合显式地编码协同信号来增强用户和物品的表示学习能力，相比与其他模型，GNN对多跳信息的建模更加灵活方便。
对于 sequential recommendation：将序列数据转换为序列图可以更灵活地进行项目选择的原始转换，并且，GNN可以通过环的结构捕获隐含在顺序行为中的复杂用户偏好。
简而言之，推荐系统数据结构非常适合转化为图结构，并且GNN在图数据的表示学习上具有非常强大的学习能力。
三、推荐系统中的图神经网络分类
对两类推荐系统 General Recommendation 和 Sequential Recommendation，以下根据其所用数据信息类型进行分类：
1. General Recommendation
目标为建模用户的静态偏好，所利用的基本数据为用户物品交互数据，根据其用到的数据信息将其分为以下三类：
A-仅交互信息（User-item interaction information）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/699049493c511daad52ce2c8ce47ee76/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5f2fb44c08947cec07b0eac8d956db1/" rel="bookmark">
			C语言实现扫雷游戏（一步步教你如何写扫雷）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		扫雷游戏 使用工具 一、基本思路和流程1. 扫雷游戏的游戏规则2. 代码实现思路 二、实现步骤（具体步骤）1. 使用多文件形式2. 代码实现定义各个难度等级的棋盘大小和雷的数量定义全局变量游戏规则界面菜单界面选择实现选择难度界面初始化和打印棋盘棋盘初始化棋盘打印棋盘 存放雷排查放雷 三、整体游戏流程附上所有代码test.c 文件game.h 文件game.c 文件 使用工具 Visual Studio 2019
一、基本思路和流程 1. 扫雷游戏的游戏规则 1. 在已经准备好的棋盘中，找出所有没有设有雷的位置，找出所有位置后，既获得胜利
2. 该游戏设有三种难度等级，分别是简单、中级和困难模式，每种模式的棋盘大小和 雷的数目都不一样
3. 踩到雷即游戏失败
2. 代码实现思路 1. 游戏规则界面，给玩家讲述该游戏的游戏规则
2. 菜单界面: 玩家可选择开始游戏或退出游戏
3. 选择游戏难度界面，玩家可选择游戏难度
4. 初始化棋盘和打印棋盘
5. 玩家开始选择排雷坐标
6. 玩家落下排雷坐标后打印棋盘，并判断玩家是否踩到雷或者是否已经找出所有非雷位置
7. 若玩家所排位置周围的雷的个数为0，则将该位置改为空格，并利用递归对周围八个位置分别进行排雷
8. 游戏结束后，玩家可选择继续游戏或者退出游戏
二、实现步骤（具体步骤） 1. 使用多文件形式 1. test.c 文件（源文件）: 写整个游戏的大致过程
2. game.h 文件（头文件）: 引用所需的头文件以及对各个程序所需函数的声明
3. game.c 文件（源文件）：定义在game.h 中声明的函数
2. 代码实现 定义各个难度等级的棋盘大小和雷的数量 在game.h文件中，使用宏定义
//简单 #define EASY_ROW 9 #define EASY_COL 9 #define EASY_COUNT 15 //中级 #define MID_ROW 15 #define MID_COL 15 #define MID_COUNT 30 //困难 #define DIF_ROW 21 #define DIF_COL 21 #define DIF_COUNT 40 //简单 #define EASY_ROWS EASY_ROW+2 #define EASY_COLS EASY_COL+2 //中级 #define MID_ROWS MID_ROW+2 #define MID_COLS MID_COL+2 //困难 #define DIF_ROWS DIF_ROW+2 #define DIF_COLS DIF_COL+2 定义全局变量 在test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5f2fb44c08947cec07b0eac8d956db1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/03da82f27a042bb21948e80c78809783/" rel="bookmark">
			2021-08-17
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Scale Match for Tiny Person Detection 阅读记录 该论文提出了两大创新： 提出了一个新的数据集（TinyPerson）。提出了一个尺度匹配的方法，使两个数据集之间的特征分布尽可能地一致。 TinyPerson是海上快速救援的背景下，提出的微小目标检测数据集。 神经网络预训练数据集和检测器学习数据集之间的尺度不匹配会影响特征表示和检测器的性能。 因此，作者提出了一种简单而有效的尺度匹配方法来对齐两个数据集之间的对象尺度，以获得良好的微小对象的特征表示。
CityPersons 数据集中的大部分目标距离相机都不够远。 作者还对比了CityPersons、coco、TinyPerson和WIDER Face四个数据集。 前四幅图是各个数据集的展示，后两个图是对各个数据集中各种尺度的目标框数量的统计，从统计图中可以看出TinyPerson在不同的绝对尺寸的目标数量相对均衡，相对于其他的数据集，Tiny Person的小目标更多。
作者对目标尺寸的定义： G i j = ( x i j , y i j , w i j , h i j ) G_{ij} = (x_{ij}, y_{ij}, w_{ij}, h_{ij}) Gij​=(xij​,yij​,wij​,hij​)
A S ( G i j ) = w i j ∗ h i j AS(G_{ij}) = \sqrt{w_{ij} * h_{ij}} AS(Gij​)=wij​∗hij​ ​
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/03da82f27a042bb21948e80c78809783/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e44d34472727f8195acfaef20bb539e1/" rel="bookmark">
			yoloV5 使用——训练速度慢，加速训练
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先大家会按照官方的readme文件进行安装，连接： https://github.com/ultralytics/yolov5 此时有两点需要注意： 1、强烈建议大家使用conda虚拟环境安装，这样不会扰乱其他项目的Python环境，关于conda虚拟环境的使用，建议参考我的另一篇博客： https://blog.csdn.net/u012863603/article/details/115764553 举例如下： conda create --name yolov5 python=3.8 conda activate yolov5 # linux下 2、进入conda环境后，按照官方的程序下载源码和安装依赖
$ git clone https://github.com/ultralytics/yolov5 $ cd yolov5 $ pip install -r requirements.txt 3、需要测试torch是否可用，以及是否是GPU $ Python import torch torch.__version__ # 打印torch版本 torch.cuda.is_available() # 查看GPU是否可用 4、如果GPU不可用，显示如下： 这种情况就是你的cuda版本过低导致的pytorch版本不匹配，原因就是requirements.sh里面关于pytorch的安装版本的描述，会指向几乎最新的版本，而你的cuda版本低就会安装CPU版本。 如何解决： 第一种，升级你的cuda版本，然后重新安装（pip install -r requerments.txt）。这种不太建议，因为，很多情况你和别人共享机器，即使不是共享机器也会影响你的其他conda环境。 第二种，安装支持你cuda版本的YOLOV5支持的版本，比如cuda 10.1 满足YOLOv5的版本为pytorch 1.7.1，这时要注意，使用pip安装，切勿使用conda安装，否则依然找不到。具体操作如下： 1）卸载现有torch pip uninstall torch pip uninstall torchvision 2)查找对应pip 版本： https://pytorch.org/get-started/previous-versions/ ，选择自己的操作系统和cuda对应的pip安装服务，如下： 3）再次测试，应该就可用了。 $ Python import torch torch.__version__ # 打印torch版本 torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e44d34472727f8195acfaef20bb539e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0efc3a07212dc14da168903512edcc18/" rel="bookmark">
			华为ensp单臂路由子接口实现不同vlan互通
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验拓扑：
提前配置好ip地址及端口地址
LSW1配置：
[LSW1]vlan batch 10 20 创建vlan [LSW1]interface GigabitEthernet 0/0/1 进入接口 [LSW1-GigabitEthernet0/0/1]port link-type access 修改链路 [LSW1-GigabitEthernet0/0/1]port default vlan 10 加入vlan [LSW1]interface GigabitEthernet 0/0/2 [LSW1-GigabitEthernet0/0/2]port link-type access [LSW1-GigabitEthernet0/0/2]port default vlan 20 [LSW1]interface GigabitEthernet 0/0/3 进入接口 [LSW1-GigabitEthernet0/0/3]port link-type trunk 修改链路 [LSW1-GigabitEthernet0/0/3]port trunk allow-pass vlan 10 20 加入vlan [LSW1]interface Vlanif 10 进入vlan [LSW1-Vlanif10]ip address 192.168.10.254 24 配置网关地址 [LSW1-Vlanif10]undo shutdown 开启 [LSW1]interface Vlanif 20 [LSW1-Vlanif20]ip address 192.168.20.254 24 [LSW1-Vlanif20]undo shutdown AR1配置：
[AR1]interface GigabitEthernet 0/0/0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0efc3a07212dc14da168903512edcc18/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6418247f106b7cf6dffe746a5fac4df/" rel="bookmark">
			看完左耳朵耗子的116篇文章，我给自己定了个5年技术规划
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		陈皓一直热衷做技术分享，不仅技术牛，文章写的也真的好。上周六小盖在极客时间小盖视频号和他连麦直播聊了两个多小时，耗子叔也分享了他写作的初心：帮助更多迷茫的程序员，让他们明确自己的职业规划和发展路线，这个初心真的挺赞！
大概 4 年前，知名技术专家左耳朵耗子在极客时间上开设了一个全年付费专栏。
到现在，这个专栏已经有 5.7 万人订阅，结束语里有用户这么评价这个专栏：
我以前做了太多重复性工作，自己没有一点提升，一直感到迷茫，没有方向，荒废了很多年时间。看了你的文章，我有了改变，最近几个月我都在坚持看书，也有了比较清晰的目标，有时我想要是早五年看到这个专栏有多好。没有后悔药，这是我必须付出的代价，现在已经30+了，我希望现在努力还不晚。
看到这我又去重新温习了他的专栏，并和负责专栏的总编辑小盖聊了聊，作了一些笔记。希望这些内容能够帮助到你。另外，如果你对更多高人的故事感兴趣，欢迎关注小盖的视频号。
以下是具体内容。
1、程序员用自己的技术变现，其实是一件天经地义的事儿。写程序是一门“手艺活”，作为手艺人，程序员当然可以做到靠自己的手艺和技能养活自己。然而，现在很多手艺人程序员却说自己是“码农”，编码的农民工，在工作上被各种使唤，各种加班，累得像个牲口。在职业发展上各种迷茫和彷徨，完全看不到未来的希望，更别说可以成为一个手艺人用自己的技能变现了。
2、成为一个手艺人，动手能力是很重要的，因为在解决任何一个具体问题的时候，有没有动手能力就成为了关键。这也是我一直在写代码的原因，代码里全是细节，细节是魔鬼，只有了解了细节，你才能提出更好或是更靠谱、可以落地的解决方案，而不是一些笼统和模糊的东西。这太重要了。
3、会挣钱的人一定是会投资的人。我一直认为，最宝贵的财富并不是钱，而是你的时间，时间比钱更宝贵，因为钱你不用还在那里，而时间你不用就浪费掉了。你把你的时间投资在哪些地方，就意味着你未来会走什么样的路。所以，利用好你的时间，投到一些有意义的地方吧。
4、在学习新技术的过程一定要多问自己两个问题。第一，这个技术解决什么问题？为什么别的同类技术做不到？第二，为什么是这样解决的？有没有更好的方式？千万别一上来就陷入细节。
5、只有那些在高速发展的公司，技术人员的价值才能被最大化地体现出来。比较好的成长路径是，先进入大公司学习大公司的技术和成功的经验方法，然后再找到高速成长的公司，这样你就可以实现自己更多的价值。当然，这里并不排除在大公司中找到高速发展的业务。
6、解决一个问题通常有很多种方法。带着开放的心态，不拘泥于一个平台、一种语言，往往能带来更多思考，也能得到更好的结果。而且，能在不同的方法和方案间做比较，比较它们的优缺点，那么你会知道在什么样的场景下用什么样的方案，你就会比一般人能够有更全面和更完整的思路。
7、什么是技术领导力？一句话总结就是遇到问题时，你能够提供有建设性的意见。
8、对于我们每个人来说，作品集会比简历更有参考意义。所以，在自己的简历中应该放上自己的一些项目经历，或是一些开源软件的贡献。
9、如果一个公司或者一个人能够抓住技术红利，那就会比其它公司或个人有更大的影响力。一旦未来行业需求引爆，那么这个公司或这个人的影响力就会形成一个比较大的护城河，并可以快速地从中获取经济利益。
10、Go 语言不会吞食底层到 C 和 C++ 那个级别的，也不会吞食到上层如 Java 业务层的项目。Go 语言能吞食的一定是 PaaS 上的项目，比如一些消息缓存中间件、服务发现、服务代理、控制系统、Agent、日志收集等等，他们没有复杂的业务场景，也到不了特别底层（如操作系统）的软件项目或工具。而 C 和 C++ 会被打到更底层，Java 会被打到更上层的业务层。这是我的一个判断。
11、找到自己的长处，不断地在自己的长处上发展自我。知道自己几斤几两才能清楚自己适合干什么。不然，目标设置得过高自己达不到，反而让自己难受。在职场上，审视自己的最佳方式，就是隔三差五就出去面试一把，看看自己在市场上能够到什么样的级别。如果你超过了身边的大多数人，你不妨选择得激进一些冒险一些，否则，还是按部就班地来吧。
12、30-40 岁，这是人生发展的阶段。因为整个社会一定会把社会的重担交给这群人，30-40 岁的人年富力强，既有经验又有精力，还敢想敢干，所以这群人才是整个社会的中流砥柱。在这个阶段，你需要明确自己奋斗的方向，需要做有挑战的事儿，需要提升自己的技术领导力。
13、加班太严重完全没有时间学习，怎么办？我觉得，可能并不在于加班和工作强度大到没时间，关键看你对学习有多少的渴望程度，对要学的东西有多大的热情。这点是非常重要的，因为学习这事其实挺反人性的。反人性的事基本上都是要付出很多，而且还要坚持很久。所以，如果对学习没有渴望的话，或是不能从学习中找到快乐的话，那么其实是很难坚持的，无论你有没有时间。
14、别人愿意跟随你，愿意和你共事，有一部分原因是你能够给别人带来更多的可能性和机会，别人觉得和你在一起能够成长，能够进步，你能够带着大家到达更远的地方。帮助别人其实就是帮助自己，成就他人其实也是在成就自己，这就像一个好的足球队一样，球队中的人都互相给队友创造机会，整个团队成功了，球队的每个人也就成功了。作为一个好的 Leader，你一定要在团队中创造好这样的文化和风气。
15、我觉得今天大多数的会都开错了。在会上抛出问题，还是开放性的问题，然后公说公有理，婆说婆有理，任大家自由发挥，各种跑题跑偏，最后还没有任何的答案。开会，不是讨论问题，而是讨论方案，开会不是要有议题，而是要有议案。
16、学习是逆人性的事儿，但如果在学习过程中不断地有正反馈，就更利于我们坚持下去。要让自己有正反馈，那就需要把时间花在有价值的地方，比如，解决自己和他人的痛点，这样你会收获别人的赞扬和鼓励。
17、在参加工作的这 20 年时间里，我发现，很多程序员都把时间都浪费在了查错上。究其根本原因就是基础知识不完整，没有好好地把技术相关的用户文档读完就仓促上手做事情了。其实只要把基础打扎实，认真读一下文档，你会省出很多很多的时间。系统地学习一门技术是非常关键的，所以这个时间是值得投资的。
18、一个可以持久的兴趣，或是可以培养出来的兴趣，后面都有一个比较本质的东西，其实就是成就感，他是你坚持或者努力的最直接的正反馈。也就是说，兴趣只是开始，而能让人不断投入时间和精力的则是正反馈，是成就感。
19、与其花时间在 Git 协同工作流上，还不如把时间花在调整软件架构和自动化软件生产和运维流程上来，这才是真正简化协同工作流程的根本。
20、编程范式其实就是程序的指导思想，它也代表了这门语言的设计方向，我们并不能说哪种范式更为超前，只能说各有千秋。比如 C 语言就是过程式的编程语言，像 C 语言这样的过程式编程语言优点是底层灵活而且高效，特别适合开发运行较快且对系统资源利用率要求较高的程序，但我上面抛出的问题它在后来也没有试图去解决，因为编程范式的选择基本已经决定了它的“命运”。
21、亚马逊的 AWS 才会把 Design for Failure 作为其七大 Design Principle 的重点。这告诉我们，不要尝试着去避免故障，而是要把处理故障的代码当成正常的功能做在架构里写在代码里。因为我们要干的事儿就是想尽一切手段来降低 MTTR——故障的修复时间。
22、隔离设计对应的单词是 Bulkheads，中文翻译为隔板。但其实，这个术语是用在造船上的，也就是船舱里防漏水的隔板。一般的船无论大小都会有这个东西，大一点的船都会把船舱隔成若干个空间。这样，如果船舱漏水，只会进到一个小空间里，不会让整个船舱都进水而导致整艘船都沉了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6418247f106b7cf6dffe746a5fac4df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/036dc8f024aa07a511a88814c50f0d3f/" rel="bookmark">
			信号完整性之S参数（八）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们在信号完整性六给大家分享过S参数，就今天在之前的基础上再完善一下，有兴趣的同学可以一起讨论学习。这个是上一篇文章的链接link.，大家可以看一下，下面开始今天的分享：
0.信号完整性问题的简单描述 ■ 信号完整性(SI)：是指信号在传输路径上的质量，可以泛指电压、电流在互连结构传输过程中的信号质量问题。
■ 信号质量包括以下几点（常见的signaling problem）：
1) 过冲（上过冲和下过冲）上过冲是信号高于信号供电电源电压的最高电压，下过冲是信号低于参考地电压的最低电压。过冲可能不会对功能产生影响，但是过冲过大会造成器件损坏，影响器件的可靠性。
2）回冲（上回冲和下回冲）是指信号在达到最高电压或最低电压后回到Vcc之下或Vss之上。回冲会使噪声容限减少。
■ 原因：造成过冲和回冲的原因是信号传输路径的阻抗不连续引起的反射造成的。
3）振铃（Ringing)：是信号跳变之后的振荡，同样会使信号的噪声容限变小，过大会造成逻辑错误，而且会使信号的高频分量增加，增大EMI问题。
■ 原因：造成振铃的原因由于信号传输路径过长并且阻抗不连续所引起的多次反射造成，或是由于信号之间的含绕、信号跳变所引起的电源或地波动造成的。
4）边沿单调性（Monotonicity)：指信号上升或下降沿的回沟。对于边沿判决的时钟信号，波形边沿在翻转门限电平处的非单调性可能造成逻辑判断错误。
■ 原因：造成monotonicit的原因为传输路径过长并且阻抗不连续所引起的反射、多负载的反射或者驱动输出阻抗较大（驱动过小）所导致的接受信号过缓引起的。
■ 以上谈到是信号质量，就是时间信号的波形，那么造成这些的原因包括以上谈到的信号传输路径过长、信号传输路径阻抗不连续（信号参考平面不连续）还有就是信号之间的干扰（串扰）、同步开关噪声、抖动等等。
1.S参数定义 ■ S参数的全称为Scatter参数，即散射参数，表征无源网络的一种特性，在仿真中即用S参数来代表无源网络。
■ Sij代表就是入射波从j端口注入，在其他端口匹配负载时，在i端口测得的传输波或反射波和j端口的入射波的比值。
■ S参数描述了传输通道的频域特性，在进行串行链路SI分析时，获得通道的准确S参数是一个很重要的环节，通过S参数，我们能看到传输通道的几乎全部特性。以下是S参数的二端口网络示意图：分为S11\S12\S21\S22
S11=b1/a1|a2=0、S21=b2/a1|a2=0、S22=b2/a2|a1=0、S21=b1/a2|a1=0
2.S参数相关定义 1）S11：代表1端口的反射系数（反射损耗或回波损耗）
2）S21：代表1端口到2端口的传输系数（传输损耗或插入损耗）
3）S31：代表1端口到3端口的隔离度（反映近端串扰）
4）S41：代表1端口到4端口的隔离度（反映远端串扰）
■ S11这个值越小越好，也就是反射越小，一般建议S1&lt;0.1,即-20dB以下
■ S21这个值越大越好，也就是越小的传输损耗，理想值是1，即0dB，通常在-3dB 以上可以保证信号传输的质量
■ S31和S41也是越小越好，也就是越小的近端和远端串扰，一般建议S31/S41&lt;0.01,即在-40dB以下。
■ 时域是真实世界，频域仅仅是更好的用于做信号分析的一种数学手段。时域数字信号转换得到频域信号如果集合起来，则可以复现原来的时域信号。高频谐波分量主要影响信号的边沿时间，低频的分量影响幅度。
3.S参数分析 简单分析S11：下图显示的就是相应网络的回波损耗（S11），图1是S11的幅值显示，图2是dB值显示，具体换算如下：
S11=0.348357 dB=20log10|0.348357|=-9.1595
换算公式：dB=20log10|magnitude|
■ 一般回波损耗在没有特殊要求下要小于-20dB，由下图可知在112MHz时，损耗就已经大于了-20dB。并且随着频率的变大，信号的损耗也会变大。
简单分析S21：下图显示的是相应网络的插入损耗（S21），通常在没有特俗情况下，保证在-3dB以上可以保证信号正常传输，下图在1G范围以内都是在-3dB以上。
简单分析S31和S41分析：通常在没有特俗情况下，保证在-40dB以下可以保证信号正常传输。下图显示的是相应网络的隔离度（S31和S41），在26MHz时就已经高于-40dB，可能会影响信号传输。
4.S参数特性 ■ S参数的三大特性：无源性（Passivity），互易性（Reciprocal），因果性（Causality）
■ 无源性：对于一个无损网络，S矩阵一个单位矩阵，对于二端口网络存在下面关系式：|S11|²+|S21|²=1，由于没有损耗，所以散射的总量是100%。当S21大的时候，S11就会下一些。对于无源的二端口的网络|S11|²+|S21|²&lt;1,因此一个无源器件的S参数不会大于1（0dB）。
■ 互易性：如果一个器件是可交换方向使用，则Sij=Sji。
■ 因果性：因果性指的是先有激励才有输出。对于无源系统的S参数，由于信号的传输一定会产生相应的延时，因此无源系统的S参数应该符合因果性原理的。但实际测得的S参数往往会由于种种原因产生一定的非因果性，导致不正确的仿真结果。
5.S参数文件 ■ TouchStone文件定义：是一种仿真软件的标准格式文件，仿真软件中调用此文件来代表一个器件或电路。TouchStone文件名都是以.snp为后缀名，n表示端口数。
■ TouchStone文件内容：内容包括端口数量、网络名、频率、parameter格式、幅值类型（RI、代表、MA）、匹配电阻R=50ohm。二端口的网络参数总共有九行包括频率，幅值S11,相位S11，幅值S21，相位S21，幅值S12，相位S12，幅值S22，相位S22的次序排列，这些数据point连接起来就是S参数的频率曲线。
6.S参数提取 S参数的提取是最常用的信号完整性仿真的一个步骤，我们不仅能从S参数的文件中看出信号的质量，也可以把S参数文件导入到相应的仿真软件中，如ADS、ANSYS等，查看信号的时域波形，下面是S参数提取的仿真过程，包括SIWAVE和Cadence Sigrity Power SI，大家可以看一下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/036dc8f024aa07a511a88814c50f0d3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b15855c223f33821879f9bb69a6781bc/" rel="bookmark">
			PyTorch教程（5）激活函数(后记）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		之前的文章已经讲了很多，下面我们来深入讲解激活函数：
放大看一下：
相关激活函数的导数：
激活函数案例 假设你想尝试各种激活函数，来找出哪个激活函数是最好的。会怎么做呢?通常我们执行超参数优化——这可以使用scikit-learn的GridSearchCV函数来完成。但是我们想要比较，所以我们选择一些超参数并保持它们不变，同时改变激活函数。
让我给你们简单介绍一下，我在这里要做的：
使用不同上网激活函数训练相同的神经网络神经模型利用每个激活函数的结果，绘制一个损失和准确性图。 我们从导入我们所需要的一切开始。注意这里使用了4个库;Tensorflow, numpy, matplotlib和keras。
导入相关库 import tensorflow as tf import numpy as np import matplotlib.pyplot as plt from keras.datasets import mnist from keras.utils.np_utils import to_categorical from keras.models import Sequential from keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPooling2D, Activation, LeakyReLU from keras.layers.noise import AlphaDropout from keras.utils.generic_utils import get_custom_objects from keras import backend as K from keras.optimizers import Adam 导入数据 从这里开始，我们想要加载一个数据集来运行这个实验;让我们选择MNIST数据集。我们可以直接从Keras导入。
(x_train,y_train),(x_test,y_test)=mnist.load_data() 数据预处理 这很好，但我们想对数据进行预处理，使其标准化。我们通过使用许多函数来实现这一点，主要是.reshape图像并除以/= 255，即最大RGB值。最后，我们用to_categorical()对数据进行one-hot编码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b15855c223f33821879f9bb69a6781bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3849a3ac317a974762d927c858017b63/" rel="bookmark">
			各厂商防火墙初始登录IP及密码信息
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 天融信 登录地址：https://192.168.1.254 用户名：superman
密码：talent或talent!23
技术支持热线 8008105119
2. 联想网域 需要证书（最好用IE浏览器登录） 登录地址：https://10.1.5.254:8889
用户名：admin 密码：leadsec@7766、
用户名：administrator 密码：bane@7766
技术支持热线：4008107766、010-56632666
3. 深信服 登录地址：https://10.251.251.251
登录地址: https://10.254.254.254 用户名: admin
密码: admin
技术支持热线: 4006306430
4. 启明星辰 登录地址: https://10.1.5.254:8889
登录地址: https://10.50.10.45:8889 用户名: admin、admin
密码: bane@7766、admin@123
技术支持热线: 4006243900
5. H3C 登录地址: https://192.168.0.1
用户名: admin
密码: admin
技术支持热线:4008100504
6. 华为 登录地址: https://192.168.0.1
用户名: admin
密码: Admin@123
技术支持热线: 4008229999
7. 网神 登录地址：https://10.50.10.45
登录地址：https://10.0.0.1
用户名: admin
密码: firewall
技术支持热线: 4006108220
8. 绿盟 登录地址：https://192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3849a3ac317a974762d927c858017b63/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fcaf9150917329a70ecb767732db54bf/" rel="bookmark">
			掌握到胃-奈氏图与伯德图的绘制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【自控笔记】5.4绘制频率特性曲线
一、开环奈奎斯特曲线的绘制 先上步骤：
①确定起点G(j0)和终点G(j∞)。
②中间段由s平面零极点矢量随s=jω变化规律绘制。
③必要时可求出G(jω)与实轴、虚轴的交点。
再看细节：
对于一个系统的传递函数，可以将其分解成N个环节串联的形式，对其进行取模和取相角运算，容易知道，系统开环传递函数的频率特性在同一频率下表现为幅值相乘，相角相加。
于是，由起点处有ω=0，在终点处有ω→∞，有
所以奈奎斯特图的起点一般都在正实轴或无穷远处，而终止于原点。
下面以一个例子说明中间过程的变化，这里说的变化，当然是指模值和相角的变化。开环传函以及极点分布如下图所示：
当v=0时，开环系统只有两个负实根。起点在K∠0°出，终点在原点处。随着ω的逐渐增大，极点的矢量沿虚轴往上移，分母的模值跟着增大，G(jω)的模值在不断减小至零；相角也随着ω的增大趋于-180°。
从中可以看出，模值决定了奈奎斯特曲线上某一点到原点的距离，而相角决定了奈奎斯特曲线的姿态（起点姿态，终点姿态等）。
同理，当v=1时，曲线起于无穷远-90°处，终于原点-270°处。这里要注意的是，当ω刚开始增大是，由极点图可知，相角是小于-90°的，也就是比-90°还负，所以，曲线是从第三象限的出发而不是第四象限。
以此分析v=2和v=3,可以得到不同型别系统的奈奎斯特图，如下所示：
最后一步就是看交点了，一般在使用奈氏图判定系统稳定性时才需要求。求解的往往是曲线与负实轴的交点，可先将系统传函先写成实部+虚部的形式，再令其虚部为0，或者根据相角条件计算，问题不大。
二、开环伯德图的绘制 1、先将开环传递函数写成典型环节的尾1标准形式。其比例环节，就是系统的开环增益K，然后确定系统的型别v。
2、确定各环节的转折频率，把各环节的转折频率由小到大标到频率轴上。各环节的转折频率及斜率变化如下表：
3、确定基准线。即最小转折频率之左的对数幅频特性及其延长线（延长至交于实轴）。这是最关键的一步。
这里简单推导一下：
基准点，斜率，延长线交点必须牢牢记住。
4、叠加作图。每遇到一个转折频率就改变一次斜率，斜率变化量在上文的表格中。系统对数幅频曲线交于实轴的频率为截止频率，该点也十分重要，即（ωc,0）。它满足条件20lg|G(jω)|=0,也就是|G(jω)|=1。可以将它与基准线延长线交点对比异同。
求截止频率常用两种方法：
①近似法，即使用|G(jωc)|=1，并忽略各环节取模运算中实部虚部的较小者，通过代数的方法求出ωc。
②几何法，即利用延长线交点与截止频率点建立“等距等比”的关系进行求解。使用此法求截止频率时，系统开环增益往往是已知条件，相反也可使用此法求解系统开环增益。
刚开始接触伯德图，往往不能很好的理解这个方法，这是很大原因是由不熟悉对数幅频特性的坐标系导致的。此时应该抓住两个关键点，一个是纵坐标的定义 L(ω)=20lg|G(jω)|,弄清G(jω)的具体表达式哪些环节起对模值有贡献，哪些不起没有贡献（根据转折频率大小判别），这是用来求高的。二是横坐标的刻度，虽然是以ω标度，但 计算距离时需要用lgω计算，这是用来求距的，根据对数的计算法则，对数减法可以转换为真数除法，因此就有等距等比了。
几何法十分灵活，在明确高度宽度的计算规则之后，再结合斜率构建三角形的几何关系，通过解三角形的思想可以很好的解决这一类问题。
5、修正。
主要修正一阶二阶环节在转折频率处的幅值衰减或超调。
6、检查。
查L(ω)最右端斜率是否为-20(n-m) dB/dec。
查转折点数。
查相角起始角是否为-90°×v，终值角是否为-90°×(n-m)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/06acf45e9fc096d020a044daab3bb1bc/" rel="bookmark">
			VSCODE常用快捷键
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用 快捷键 编辑器与窗口管理
新建文件: Ctrl+N
文件之间切换: Ctrl+Tab
打开一个新的VS Code编辑器: Ctrl+Shift+N
关闭当前窗口: Ctrl+W
关闭当前的VS Code编辑器: Ctrl+Shift+W
切出一个新的编辑器窗口（最多3个): Ctrl+\
切换左中右3个编辑器窗口的快捷键: Ctrl+1 Ctrl+2 Ctrl+3
代码编辑
代码行向左或向右缩进: Ctrl+[ 、 Ctrl+]
复制或剪切当前行/当前选中内容: Ctrl+C 、 Ctrl+V
代码格式化: Shift+Alt+F
向上或向下移动一行: Alt+Up 或 Alt+Down
向上或向下复制一行: Shift+Alt+Up 或 Shift+Alt+Down
在当前行下方插入一行: Ctrl+Enter
在当前行上方插入一行: Ctrl+Shift+Enter
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08a40f04200f99a64c084b2d5b89189c/" rel="bookmark">
			阿里云突发性能t5实例CPU积分计算详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云突发性能实例t5与其他实例是有却别的，多了基准CPU计算性能和CPU积分，本文分享阿里云突发性能实例t5（以下简称t5）CPU积分查看、累积获取、消耗详解： 在了解t5实例CPU积分之前，我们需要了解下CPU基准计算性能，基准CPU计算性能：每种t5实例规格都有一个基准CPU计算性能，即正常工作负载时，实例每个vCPU核有一个最大使用率。比如ecs.t5-lc1m2.small实例在正常工作负载时，CPU使用率最大为10%。
t5实例CPU积分在哪查看？ 每台t5是创建之初既有30个CPU初始积分，实例开始消耗CPU积分的同时也会累积CPU积分，当CPU实际负载高于默认的基准CPU计算性能时，就会导致CPU积分消耗的速度大于CPU积分累积的速度。CPU积分累积公式和CPU积分消耗公式稍后会介绍，我们先来看看t5实例的CPU积分在哪查看？
t5实例CPU积分查询： 1、登录到阿里云ECS云服务器控制台；
2、找到你的t实例，点击右侧的“管理”如下图所示：
阿里云突发性能t5实例管理
在“实例详情”页面即可查看到该t5实例的CPU累积和CPU消耗情况，如下图所示： 突发性能t5实例CPU积分消耗：
突发性能t5实例CPU积分消耗
突发性能t5实例CPU积分累积：
突发性能t5实例CPU积分累积
t5实例CPU积分累积及计算方法 CPU积分每台t5实例根据基准CPU计算性能以固定速度获取CPU积分。一个CPU积分代表的计算性能与vCPU核数、CPU使用率和工作时间有关：
1个CPU积分 = 一个vCPU核以100%使用率运行1分钟
1个CPU积分 = 一个vCPU核以50%使用率运行2分钟
1个CPU积分 = 2个vCPU核以25%使用率运行2分钟
如果希望一个vCPU核一小时（60分钟）都以100%使用率运行，一个vCPU核每小时需要60个CPU积分。
初始CPU积分一台t5实例在创建成功后会分到30个CPU积分，即初始CPU积分。只有创建实例时才会分配初始CPU积分。当实例开始消耗CPU积分时，优先使用初始CPU积分。
CPU积分分发速度CPU积分分发速度是指单位时间内一台t5实例获取的CPU积分，取决于基准CPU计算性能，以分钟为单位。由基准CPU计算性能和CPU积分可得到CPU积分分发速度的计算公式：
CPU积分分发速度 = (60个CPU积分 * 基准CPU计算性能)/60分钟
举例：以ecs.t5-lc1m2.small为例，基准CPU计算性能为10%，所以，CPU积分分发速度为每分钟0.1个CPU积分（即每小时6个CPU积分）。
t5实例CPU消耗及计算方法 CPU积分过期CPU积分开始累积后只能保存24小时，获得时间超出24小时的CPU积分即失效。
消耗CPU积分实例开启后即消耗累积的积分，并且优先消耗初始CPU积分。每分钟CPU积分的消耗量按以下公式计算：
每分钟消耗的CPU积分 = 1个CPU积分 * 实际CPU计算性能
举例：以ecs.t5-lc1m2.small为例，当它以50% CPU使用率运行1分钟时，会消耗0.5个CPU积分。
累积CPU积分当实例的CPU使用率小于基准CPU计算性能时，因每分钟内CPU积分的消耗量小于分发量，实例CPU累计积分可产生净增加。反之，则产生净消耗。增加速度取决于实际CPU负载与基准性能之间的差值，计算公式如下：
每分钟累计的CPU积分 = 1个CPU积分 * (基准CPU计算性能 - 实际CPU计算性能) - 该分钟过期的积分
当CPU积分分发量大于消耗量时，CPU积分会越来越多；反之，则越来越少。
您可以在ECS管理控制台上查看CPU累积量和消耗量。
当累积的CPU积分消耗完后，t5实例的实际CPU计算性能无法超过基准CPU计算性能。
示例
以一台ecs.t5-lc1m2.small实例为例，说明突发性能实例CPU积分变化：
1. 实例创建后，实例分配到30个CPU积分。实例未启动前，CPU积分总量为30。实例开启后，以0.1个CPU积分/分钟的速度被分配CPU积分，同时消耗积分。
2. 开启后第1分钟内，假设CPU使用率为5%，实例会消耗0.05个初始CPU积分，但是同时又会被分配0.1个CPU积分，此时过期的CPU积分为0，所以，实际上累积了0.05个CPU积分。
3. 开启N分钟后，假设CPU使用率为50%，而且会过期0.1个CPU积分，则这一分钟内实例会消耗0.5个CPU积分，同时又会被分配0.1个CPU积分，即实际上实例使用了0.5个CPU积分，而且没有增加积分。
4. 当累积的CPU积分消耗完后，实例的CPU使用率，最大只能为10%。
聊完这些，那么该选择哪家的云服务器呢？
主流云平台例如阿里云、腾讯云的活动机在安全性、稳定性、易用性及高性价比等方面都占据绝对的优势，是上云的最佳选择。
国内云服务器性能和配置对比参阅：【云服务器推荐】腾讯云、阿里云、华为云服务器价格和配置评测
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08a40f04200f99a64c084b2d5b89189c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaceacd86829931500311e0120b47e73/" rel="bookmark">
			解决Unable to connect to Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		课堂上,老师给的是Oracle VM VirtualBox虚拟机
测试的时候,打开localhost:8080访问redis报错了Unable to connect to Redis,
找了一下原因,原来是配置文件 redis.conf 没改…并且,redis的端口号防火墙未开启。
重新设置一下，就好使了。
确保：主机能够连接redis服务
找到redis的安装地址 按照指定的配置文件启动
cd /usr/local/bin/
./redis-server ~/myredis/redis.conf
因为redis.conf配置了重要的几项，能够让远程连接此服务
#确认远程可访问 且 保护模式打开
bind 0.0.0.0
protected-mode yes
直接关闭防火墙 / 打开防火墙，开放redis的端口号
firewall-cmd --add-service=http --permanent
firewall-cmd --add-port=6379/tcp --permanent
#重启防火墙
firewall-cmd --reload
#查看开放的端口
firewall-cmd --permanent --zone=public --list-ports
Linux 一些命令: 这里
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8529dd026ce9c2dc8eabb8b9135b91aa/" rel="bookmark">
			map、odom、base_link和base_laser坐标系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1、map坐标系2、odom坐标系3、base_link坐标系4、base_laser坐标系5、总结 1、map坐标系 在构建地图时，机器人构建地图的起点位置就是map坐标系的位置。在导航节点，当加载地图时，map坐标系就确定了。 map坐标系一旦固定，就不会再变。
map:地图坐标系，为固定坐标系，理论上应与odom坐标系重合。一般与机器人所在的世界坐标系一致。
2、odom坐标系 由于器件、结构等方面的原因，通过运动反馈获得的里程信息会出现误差累计的问题，为消除累计误差，引入了odom坐标系。
运动反馈一直更新的是odom–&gt;base_link，即base_link在odom坐标系下的坐标。至于误差累计则是通过定位模块amcl纠正，也就是修改map–&gt;odom，odom在map坐标系下的坐标，以此达到消除累计误差。
odom:里程计坐标系，不是固定的坐标系，是可以运动的。odom相当于是根据实际计算得到的坐标和真实坐标之间的变换虚拟出来的一个坐标系。
问题：odom坐标系原点是怎样确定的？随着机器人的运动，odom坐标系会不会发生变化？
odom和map坐标系是不是重合的？
可以很肯定的告诉你，机器人运动开始是重合的。但是，随着时间的推移是不重合的，而出现的偏差就是里程计的累积误差。
机器人开始运动时map与odom重合，但随着时间推移两者的tf不为0。
总结：odom坐标系的原点就是机器人上电时所处的位置，所以在建图时odom坐标系和map坐标系是重合的，后面随着建图的进行，由于误差存在，odom坐标系和map坐标系会慢慢偏离。 而导航时，机器人起始位置一般不会与建图时的起始位置完全相同，而map坐标系是始终不变的，所以在导航开始时，odom坐标系和map坐标系一般都不是重合的。
3、base_link坐标系 base_link坐标系是用于表示机器人本身位姿的坐标系，其始终与机器人本体保持一致。机器人的定位问题最本质的就是求出base_link在map坐标系下的坐标和姿态。
base_link坐标系原点一般为机器人的旋转中心，base_footprint坐标系原点为base_link原点在地面的投影，有些许区别（z值不同）。
4、base_laser坐标系 base_laser:激光雷达的坐标系，与激光雷达的安装点有关，其与base_link的tf为固定的。
5、总结 tf树中只有一种遍历关系–从父节点到子节点，如下图所示。
SLAM中的定位就是为了计算tf: map-&gt;odom。
（1）机器人的定位问题最本质的就是求出base_link在map坐标系下的坐标和姿态。
（2）SLAM中的定位就是为了计算tf: map-&gt;odom。
问题：机器人定位到底是什么？
Karto SLAM中的代码，根据上述的遍历关系，是先计算base_link-&gt;odom，再计算odom-&gt;map再用.inverse()计算map-&gt;odom。如以下代码。
// Compute the map-&gt;odom transform tf::Stamped&lt;tf::Pose&gt; odom_to_map; m_.lock(); tf::Stamped&lt;tf::Pose&gt; odom_pose = odom_pose_;//base_link-&gt;odom m_.unlock(); tf_.transformPose(odom_frame_, tf::Stamped&lt;tf::Pose&gt;(tf::Transform(tf::createQuaternionFromRPY(0, 0, corrected_pose.GetHeading()), tf::Vector3(corrected_pose.GetX(), corrected_pose.GetY(), 0.0)).inverse(), odom_pose.stamp_, base_frame_), odom_to_map); map_to_odom_mutex_.lock(); map_to_odom_ = tf::Transform(tf::Quaternion(odom_to_map.getRotation()), tf::Point(odom_to_map.getOrigin())) .inverse(); map_to_odom_mutex_.unlock(); amcl定位模块：amcl使用粒子算法，通过激光点与地图匹配，首先求出map–&gt;laser，laser在map下的位姿，然后根据已知的base_link–&gt;laser，odom–&gt; base_link，计算出map–&gt;odom。
AMCL就是修正里程计本身存在的误差，是通过补偿（或者是说改变） map-&gt;odom 之间的关系来是实现的。 “AMCL 校正里程计自身的累计误差”
参考链接：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8529dd026ce9c2dc8eabb8b9135b91aa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2245165a2c5521e227423da92f72e52f/" rel="bookmark">
			CentOS7、Docker下搭建CDH6.2.0集群环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CentOS7、Docker下搭建CDH6.2.0集群环境 安装规划环境准备环境安装CM安装集群安装集群的重启常见问题 安装规划 hadoop1hadoop2hadoop3mysqlcmrepocloudera-manager-server√cloudera-manager-agent√√√NameNode√DataNode√√√SecondaryNameNode√ResouceManager√NodeManager√√√MetaStore√HiveServer2√HueServer√ImpalaCatelogServer√ImpalaDaemon√√√ImpalaStateStore√Oozie Server√Zookeeper√√√MySQL√Repo源√ 环境准备 Docker环境准备
docker pull centos:7 docker pull mysql:5.7 安装包准备
环境安装 【宿主机】 创建docker集群的网段
docker network create --subnet 172.20.0.0/16 bigdata
【宿主机】 创建三个centos容器,并指定22端口映射及主机名
docker run -itd --privileged -p 2221:22 --name hadoop1 --hostname hadoop1 --network bigdata centos:7 /usr/sbin/init docker run -itd --privileged -p 2222:22 --name hadoop2 --hostname hadoop2 --network bigdata centos:7 /usr/sbin/init docker run -itd --privileged -p 2223:22 进入三台主机
docker exec -it hadoop1 /bin/bash docker exec -it hadoop2 /bin/bash docker exec -it hadoop3 /bin/bash 【三台dokcer】 安装ssh，配置免密登录
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2245165a2c5521e227423da92f72e52f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daefc07f05dbc10696aa35e9b792df34/" rel="bookmark">
			python的选择语句if语句，Python的输入和输出函数（python基础学习5）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python的选择语句if语句，Python的输入和输出函数 if语句1）第一种2）第二种3）第三种 python键盘输入屏幕输出输入input()函数 输出print（）函数1）非格式化输出2）格式化输出--%3）重中之重格式化输出--format() if语句 if语句一般形式如下：
1）第一种 if &lt;条件&gt;: &lt;语句&gt; 条件：可以是任意表达式，但对于if来看它只管结果是False还是True
语句：可以是一条或是多条，在if语句判断为True时就执行语句False就不执行。
2）第二种 if &lt;条件&gt;: &lt;语句&gt; else: &lt;语句&gt; else后面直接" : "结尾后面不接条件。如果if语句没有执行便直接执行else语句。
举个栗子：
x={'喵1喵2':90,'张三':56,'李四':72} for n,m in x.items(): #将字典x的键和值分别存在n和m中 if m &gt;= 60: #判断是否及格如果 print(n,'及格！') else: print(n,'不及格！') 运行结果：
3）第三种 if &lt;条件1&gt;: &lt;语句1&gt; elif &lt;语句2&gt;: &lt;语句2&gt; elif &lt;语句2&gt;: &lt;语句2&gt; else: &lt;语句&gt; elif是不限制数量的和if一样它只管结果是False还是True正确就执行错误就往下走
上面的栗子咱们只能判断是及格还是不及格，现在咱们添加elif语句再来判断成绩的是优还是良。
x={'喵1喵2':90,'张三':56,'李四':72,'王五':720,'赵六':62,'钱七':-5} for n,m in x.items(): #将字典x的键和值分别存在n和m中 if m&gt;100 or m&lt;0: #判断成绩是否合法 print(n,'你的成绩不在合法范围!') elif m &gt;= 85: print(n,'优秀！') elif m&gt;=70: print(n,'良好！') elif m&gt;=60: print(n,'及格！') else: print(n,'不及格！') 运行结果：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daefc07f05dbc10696aa35e9b792df34/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60cdad281c8d1a7fb2c1d242645f908d/" rel="bookmark">
			一篇就够！selenium教你爬取京东商品。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		人生苦短，我选爬虫！
今天，心血来潮想用selenium来爬取京东商品。
毕竟，这是个大创作（狗头）！
可能有的小伙伴会问，为什么不爬淘宝？
答案：淘宝的反爬太厉害了，一两次就被拦截了，还要过一两天才能爬取到内容。但是，经过反复的测试，京东，相对仁慈多了，拦截了又并不完全拦！
（如果跳出登录界面，正常扫码即可）
原理：
利用selenium打开京东，定位输入框和搜索框，点击搜索按钮
browser = webdriver.Chrome() browser.get('https://www.jd.com/') # 输入框 input = browser.find_element_by_css_selector('#key') input.send_keys(keyword) # 搜索框 btn = browser.find_element_by_css_selector('#search &gt; div &gt; div.form &gt; button') btn.click() 进入商品展示面后，下面三个圈出的地方是关键，关系到让整个浏览器自动运行。
定位总共页数，用于遍历，css选择器路径为：'#J_bottomPage &gt; span.p-skip &gt; em:nth-child(1)'（注：省略这一步也可以！自己输入想得到的页数）定位页数导航框，css选择器路径为："#J_bottomPage &gt; span.p-skip &gt; input"，通过send_keys输入页数，这个方法比较好用。我试过用while true循环不断点击下一页，但需要手动停止代码运行，强迫症的我无法忍受!定位确定按钮，css选择器路径为：'#J_bottomPage &gt; span.p-skip &gt; a' 到此，其原理差不多就这样！虽然梳理起来很简单，但操作起来真的很麻烦，容易犯一些低级错误！我测了几天，最后决定分享给大家，一起加油！
源码：
import re import time import csv, codecs from selenium.common.exceptions import TimeoutException from selenium.webdriver.support import expected_conditions as EC from selenium import webdriver from pyquery import PyQuery as pq from selenium.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60cdad281c8d1a7fb2c1d242645f908d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c69e4e10c29cf5196996af280e4a703e/" rel="bookmark">
			【论文阅读】用于可扩展（通信网络）资源管理的图神经网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文：https://arxiv.org/abs/2007.07632
代码：https://github.com/yshenaw/GNN-Resource-Management
WCGCN：无线信道图卷积网络（Wireless channel graph convolution network）
WMMSE：加权最小均方误差（ weighted minimum mean square error）
CSI：通道状态信息(channel state information)
0.目录 摘要
一、简介
A.贡献
B.符号表示
二、无线网络的图形建模
A. 有向图和置换等方差性
B. 作为图的无线网络
C.K-用户干扰信道的关系图建模
三、资源管理的神经网络架构设计
A. 通过图神经网络优化无线网络
B. MPGNN
C. MPGNN 的关键特性
D. MPGNN 的有效实现
四、基于mpgnn的无线电资源管理的理论分析
A. 简化
B. mpgnn的等效性与分布式优化
C. mpgnn的性能和推广
五、模拟结果
A.平均速率最大化
B.加权求和速率最大化
C. 波束设计
六、结论
《资源管理的可扩展图神经网络：体系结构设计与理论分析》 摘要： 背景，深度学习最近已成为解决资源管理问题的颠覆性技术：
1.现有的神经网络架构的问题：可扩展性差、泛化性差、缺乏可解释性。
2.提高可扩展性和泛化性的方法：将目标任务的结构合并到神经网络架构中。？
本文，应用图神经网络 (GNN) 来解决大规模资源管理问题：
1.证明无线电资源管理问题可以被表述为图优化问题（具有通用置换等方差特性）
2.我们确定了MPGNN（消息传递图神经网络 )。
3.MPGNN满足置换等方差性，可以推广到大规模问题，享有很高的计算效率。
4.证明了 MPGNN 与一系列分布式优化算法之间的等价性
5.分析基于 MPGNN 的方法的性能和泛化。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c69e4e10c29cf5196996af280e4a703e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d906f4f4f8a00bc7cd4a518ab157d4be/" rel="bookmark">
			redis跳表的层数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis跳表在插入一个元素时,先随机出一个该元素的所在的层数
int random_level() { K = 1; while (random(0,1)) K++; return K; } 然后在将该元素加入第K层的链表中.
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ec9a47a3953bd8da19c9c2ec5fda4fea/" rel="bookmark">
			SpringBoot - 获取POST请求参数详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		介绍了 Controller 如何接收通过 GET 方式传递过来的参数，下面接着演示如何接收通过 POST 方式传递过来的参数。
一、接收 Form 表单数据 1，基本的接收方法 （1）下面样例 Controller 接收 form-data 格式的 POST 数据：
package com.example.demo; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.RestController; @RestController public class HelloController { @PostMapping("/hello") public String hello(@RequestParam("name") String name, @RequestParam("age") Integer age) { return "name：" + name + "\nage：" + age; } } 2，参数没有传递的情况 （1）如果没有传递参数 Controller 将会报错，这个同样有如下两种解决办法：
使用 required = false 标注参数是非必须的。使用 defaultValue 给参数指定个默认值。 package com.example.demo; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestParam; import org.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ec9a47a3953bd8da19c9c2ec5fda4fea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ca16ecd77ee9e098162443e87c9a0b2/" rel="bookmark">
			导出DMP文件实现数据库备份、数据迁移流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		数据库导出表、及表结构数据、索引 一、expdp导出命令 连接服务器，输入su - oracle 切换到oracle用户，切记要用Root用户登录服务器
导出文件 导出的用户/密码(dpdata) 文件名称 导出的用户名(dpdata) 版本号（注意源数据库与目标数据库的版本）
数据库版本不一致要加 version=11.2.0.1.0
expdp 导出数据库用户名/导出数据库用户密码 directory=DATA_PUMP_DIR dumpfile=导出文件名.dmp logfile=exp3.log schemas=导出数据库用户名 如果导出时服务器报用户连接失败，那么要指定ip、端口、实例名
expdp 导出数据库用户名/导出数据库用户密码@127.0.0.1:1521/实例名 directory=DATA_PUMP_DIR dumpfile=文件名称.dmp logfile=exp3.log schemas=导出数据库用户名 查询数据库存储文件目录
select * from dba_directories ;
导出的文件在/data/u02/app/oracle/admin/bms/dpdump/这个目录下
二、impdp导入命令 连接服务器，输入su - oracle 切换到oracle用户，切记要用Root用户登录服务器
查询数据库存储文件目录
select * from dba_directories ;
查看导入文件的存储路径，将导出的备份文件.dmp放到。服务器存储路径下。
impdp 导入的数据库用户名/导入的数据库用户密码 directory=DATA_PUMP_DIR dumpfile=备份文件名称.dmp remap_tablespace=USERS:TB_BMS remap_schema=导出的用户名:导入的用户名 schemas=导出的用户名 table_exists_action=replace(替换) 如果导入时服务器报用户连接失败，那么要指定ip、端口、实例名
impdp 导入数据库用户名/导入数据库用户密码@127.0.0.1:1521/实例名 directory=DATA_PUMP_DIR dumpfile=备份文件名称.dmp remap_tablespace=USERS:TB_BMS remap_schema=导出的用户名:导入的用户名 schemas=导出的用户名 table_exists_action=replace(替换) 三、exp导出命令 导出指定表的数据
导出单张表的数据不写路径默认/home/oracle exp 导出数据库用户名/导出数据库用户密码 file=文件名称.dmp tables='表名' 连接失败时使用下方语句
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2ca16ecd77ee9e098162443e87c9a0b2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71def3634e0f4150ad5da6d7197f606c/" rel="bookmark">
			解决Bean with name ‘XX‘ has been injected into other beans 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题 话不多说，先上Error提示： org.springframework.beans.factory.UnsatisfiedDependencyException: Error creating bean with name 'StoreOrderFrontController': Unsatisfied dependency expressed through field 'orderService'; nested exception is org.springframework.beans.factory.BeanCurrentlyInCreationException: Error creating bean with name 'XX: Bean with name 'orderServiceImpl' has been injected into other beans [pinkServiceImpl,combinationServiceImpl] in its raw version as part of a circular reference, but has eventually been wrapped. This means that said other beans do not use the final version of the bean. This is often the result of over-eager type matching - consider using 'getBeanNamesOfType' with the 'allowEagerInit' flag turned off, for example.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71def3634e0f4150ad5da6d7197f606c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f44634ce3cc0b56d501a15e4ceac9804/" rel="bookmark">
			ROS WARNING: disk usage in log directory [/home/***/.ros/log] is over 1GB.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 出现如下问题的主要原因是 ROS 缓存文件大于1GB
WARNING: disk usage in log directory [/home/***/.ros/log] is over 1GB. It's recommended that you use the 'rosclean' command. 二、解决方法 rosclean check # 查看 rosclean purge # 删除 然后就OK了～～
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e6b44a71bf7a0debc37548b47110d66a/" rel="bookmark">
			方向向量转欧拉角
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载原始帖子：https://www.jianshu.com/p/1b4f310fb883
本节就一个功能，加载一个导弹，让其在上一节的基础上，从发射架那里打到地面站那里。
image.png
具体实现 这里我们输入的是一连串的经纬高，组成导弹的路径。然后生成一个animationPath就可以了。第10节 实例-双击跑过去操作器 在这一节也用了animationPath，animationPath最关键的参数是位置、朝向，位置好说，关键点就是位置。关键在朝向。有了位置、朝向、时间直接就可以生成animationPath。
要计算导弹在一个点的朝向确非易事，要先搞明白一件事情：就是导弹在建模时有个方向，这是导弹的局部坐标。将其放在地球上是使用的这样的方法：
osg::MatrixTransform* mt = new osg::MatrixTransform; mt-&gt;addChild(LodAutoMode(fileName, radioSize)); osg::Matrixd mts; _em-&gt;computeLocalToWorldTransformFromLatLongHeight(osg::inDegrees(LLH.y()), osg::inDegrees(LLH.x()), LLH.z(), mts); mt-&gt;setMatrix(mts); 我们要知道mts这个矩阵，将物体从世界坐标系的(0,0,0)给移到地表，除了改变了位置以外，还改变了朝向。这个要想象一下，假如平移则放在地表的角度是不对的。拿坐标轴来比一下，在世界坐标下这个轴是这样的（Y轴正北，Z轴从地心连，X轴正东）：
本例中计算朝向使用了一个函数叫做：void GetFlyPosture(osg::Vec3d First, osg::Vec3d Second, double&amp; PitchAngle, double&amp; yAngleHengGun, double&amp; YawAngle)
给定起点、终点，然后计算出导弹的俯仰角、横滚角、航向角。这里详细的判断了起点和终点的经纬高之间的关系，读者可以看一下理解一下，比如经纬度没有变，只高度变化，则就是顺着地表垂直向上发射
作者：杨石兴
链接：https://www.jianshu.com/p/1b4f310fb883
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
#include &lt;osgViewer/Viewer&gt;
#include &lt;osgEarth/EarthManipulator&gt;
#include &lt;osgDB/ReadFile&gt;
#include &lt;osg/Geode&gt;
#include &lt;osg/MatrixTransform&gt;
#include &lt;osg/LineWidth&gt;
#include &lt;osg/LineStipple&gt;
#include &lt;osg/AutoTransform&gt;
#include &lt;osg/AnimationPath&gt;
#include &lt;osg/ImageSequence&gt;
#include &lt;osg/Depth&gt;
#include &lt;osgParticle/Particle&gt;
#include &lt;osgParticle/ParticleSystem&gt;
#include &lt;osgParticle/ModularEmitter&gt;
#include &lt;osgParticle/RandomRateCounter&gt;
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e6b44a71bf7a0debc37548b47110d66a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/91541b6be85e2f7b060dec9477357685/" rel="bookmark">
			支持向量机——SVM原理阐述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		自己总结的SVM原理阐述。
用word写的转markdown太费力了，直接截图啦。
主要参考了周志华老师的《机器学习》书籍以及吴恩达老师的“机器学习”课程。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcfad9f47d2d564dd41f992383034f5e/" rel="bookmark">
			阅读笔记：《机器学习》西瓜书（10）——降维与度量学习
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		降维与度量学习 k近邻学习（kNN）低维嵌入MDS算法 主成分分析（PCA）核化线性降维KPCA 流形学习等度量映射（Isomap）局部线性嵌入（LLE） 度量学习参考资料 降维是一种常用的数据预处理方法。由于降维事实上是高维空间在低维空间上的投影，一般情况下可以使用线性映射做到这一点。而线性映射又可以用矩阵进行表示，本章也出现了大量的线性代数相关的概念和公式，包括特征值、特征向量、对角化、正交变换、迹等等。理解这些概念的定义和实际意义对本章的学习有很大的好处。这里推荐学习 李宏毅老师线性代数课程的相关章节。 k近邻学习（kNN） k近邻学习（简称kNN）是一种常用的监督学习方法。这种方法在给定测试样本后，利用某种距离度量找出训练集中与其最靠近的k个训练样本，然后基于这k个“邻居”的信息来进行预测；针对分类问题采用“投票法”，回归问题采用“平均法”。
kNN这种方法并没有显式的训练过程。这种学习方法被称为懒惰学习，反之则称为急切学习。
对于1NN（k=1）的情况，假设测试样本为 x \boldsymbol{x} x，其最邻近样本为 z \boldsymbol{z} z，则分类器出错的概率为：
P ( e r r ) = 1 − ∑ c ∈ Y P ( c ∣ x ) P ( c ∣ z ) P(err)=1-\sum_{c\in \mathcal{Y}}{P(c\mid \boldsymbol{x})P(c\mid \boldsymbol{z})} P(err)=1−c∈Y∑​P(c∣x)P(c∣z)
假设样本独立同分布，且对任意 x \boldsymbol{x} x总能在附近任意近的范围内找到训练样本 z \boldsymbol{z} z（样本采样密集）。则有：
其中 c ∗ c^* c∗是贝叶斯最优分类器的结果。可以看到，最近邻分类器虽简单，但它的泛化错误率不超过贝叶斯最优分类器的错误率的两倍。
低维嵌入 在前面的讨论中有一个重要假设；训练样本的采样密度足够大，这样上述推导中的约等于号才能够成立。然而，在属性维数较高，样本空间巨大的情况下，现实任务的采样很难满足密采样的条件。此外，许多学习方法都涉及距离计算，而高维空间会给距离计算带来很大的麻烦。这种在属性维度较高情况下出现的数据样本稀疏、距离计算困难等问题，是所有机器学习方法共同面临的严重障碍， 被称为维数灾难。解决这个问题的一个重要途径便是降维。
为什么能进行降维？在很多时候，观测或收集到的数据样本虽是高维的，但与学习任务密切相关的也许仅是某个低维分布，即高维空间中的一个低维嵌入。
一般来说，欲获得低维子空间，最简单的是对原始高维空间进行线性变换。给定 d d d维空间中的样本 X = ( x 1 , x 2 , … , x m ) ∈ R d × m \boldsymbol{X}=(\boldsymbol{x_1},\boldsymbol{x_2},\dots,\boldsymbol{x_m})\in \mathbb{R}^{d\times m} X=(x1​,x2​,…,xm​)∈Rd×m，通过降维得到 d ′ ≤ d d'\leq d d′≤d维空间中的样本 Z = ( z 1 , z 2 , … , z m ) ∈ R d ′ × m \boldsymbol{Z}=(\boldsymbol{z_1},\boldsymbol{z_2},\dots,\boldsymbol{z_m})\in \mathbb{R}^{d'\times m} Z=(z1​,z2​,…,zm​)∈Rd′×m，有：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcfad9f47d2d564dd41f992383034f5e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/62a8453f8c05a5319ba55461f67f5242/" rel="bookmark">
			【JS从入门到精通】18-定时调用与延时调用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记来源：尚硅谷最新版JavaScript基础全套教程完整版(140集实战教学,JS从入门到精通)_哔哩哔哩_bilibili
文章目录 定时调用与延时调用1、定时调用setInterval()clearInterval()&lt;练习1：定时图片切换&gt;&lt;练习2：div移动优化&gt; 2、延时调用setTimeout()、clearTimeout() 3、定时器的应用（一）&lt;练习：点击按钮div移动&gt;优化1：封装移动方法优化2：智能判断方向优化3：消除多个div影响优化4：支持多属性优化5：添加回调函数优化6：封装JS文件 4、定时器应用（二）&lt;练习：轮播图&gt; 5、类的操作修改class属性添加class属性删除class属性切换class属性&lt;练习：二级菜单&gt; 定时调用与延时调用 1、定时调用 JS 的程序的执行速度是非常非常快的如果希望一段程序，可以每间隔一段时间执行一次，可以使用定时调用
setInterval() 定时调用，可以将一个函数，每隔一段时间执行一次
参数：
回调函数，该函数会每隔一段时间被调用一次每次调用间隔的时间，单位是毫秒 返回值：返回一个Number类型的数据，这个数字用来作为定时器的唯一标识
var num = 1; info = document.getElementById("info"); setInterval(function(){ info.innerHTML = num++; }, 1000); setInterval(function(){ info.innerHTML = num++; }, 100); clearInterval() 可以用来关闭一个定时器，方法中需要一个定时器的标识作为参数，这样将关闭标识对应的定时器
var timer = setInterval(function(){ info.innerHTML = num++; if(num &gt; 100){ clearInterval(timer); } }, 10); &lt;练习1：定时图片切换&gt; HTML 代码
&lt;img src="img/1.jpg" id="img" /&gt;&lt;br&gt; &lt;button type="button" id="btnStart"&gt;开始&lt;/button&gt; &lt;button type="button" id="btnEnd"&gt;结束&lt;/button&gt; JS 代码
var btnStart = document.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/62a8453f8c05a5319ba55461f67f5242/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ab78e81ec2dec1df64863405e365d7b0/" rel="bookmark">
			YOLOv4训练自己的数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		YOLOv4训练自己的数据集保姆级攻略 一、训练前的准备1.如何获取代码2.修改MakeFile文件3.下载权重4.测试初始训练权重效果 二、训练自己的数据集1.数据集文件夹格式2. main文件夹下生成训练集和测试集文件3. 修改voc.name4. 修改 voc.data5. voc_label.py生成训练用的txt文件和标签文件夹6. 修改yolov4.cfg文件7.生成anchors 三、训练计算所有值批量测试 一、训练前的准备 1.如何获取代码 https://github.com/AlexeyAB/darknet
2.修改MakeFile文件 GPU=1 CUDNN=1 CUDNN_HALF=0 OPENCV=1 AVX=0 OPENMP=0 LIBSO=1 ZED_CAMERA=0 ZED_CAMERA_v2_8=0 修改成自己的地址
3.下载权重 yolov4.weights
4.测试初始训练权重效果 在./darknet文件夹下的命令行中输入make clean, make
编译成功后：./darknet detect cfg/yolov4.cfg yolov4.weights data/dog.jp
成功后在主目录下出现predictions.jpg 图片为预测后的图片。
二、训练自己的数据集 1.数据集文件夹格式 VOCdevkit VOC2007 AnnotationsImageSets LayoutMainSegmentation JPEGImages 2. main文件夹下生成训练集和测试集文件 此处是代码
// An highlighted block var foo = 'bar'; 3. 修改voc.name vehicle ship plane 4. 修改 voc.data classes= 3 # voc.name中类的个数 train = .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ab78e81ec2dec1df64863405e365d7b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01de9938fcf1c6fc740da575ff185d9e/" rel="bookmark">
			Kettle中“排序记录”的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 “排序记录”作用很简单，就是对字段进行排序，一般很都是配合“去除重复记录”和“记录集连接”使用的，这里就简单介绍下排序记录的使用。
核心对象-&gt;转换-&gt;排序记录，将“排序记录”拖拽到转换页面
配置参数，选择排序字段(data2)，然后选择排序方式(降序)，如下图所示
库表中数据如图 3-1所示，结果数据如图 3-2所示
图 3-1
图 3-2
从结果可看出原表中的无序数据已经变成降序排序的数据。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6eca383da21cc607fa538abda3b6c335/" rel="bookmark">
			Kettle的“字符串替换”的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“字符串替换”的主要用途就是字面理解，根据正则表达式或者直接将其他字段的值(前提是字符串类型的)替换掉目标字段中的值，在ETL过程中也是经常使用的一个功能算子，不过对正则表达式要有一定了解，下面介绍如何使用此功能算子。
核心对象-&gt;转换-&gt;字符串替换，将“字符串替换”拖拽到转换页面中，如下图所示。
配置参数，配置参数根据具体需求而定，这里举个简单的例子，用‘|’字符替换掉每个字段中的‘-’字符，如下图所示
原始文件中数据如图 3-1所示，结果数据如图 3-2所示
图 3-1
图 3-2
通过数据比对可以发现，已经将每个字段中的‘-’字符全部替换成了‘|’字符。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3d662368e1f6ac657b991ace018766cd/" rel="bookmark">
			`Segmentation fault` is detected by the operating system
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近碰到的问题，在解决
-------------------------------------- C++ Traceback (most recent call last): -------------------------------------- 0 paddle::framework::SignalHandle(char const*, int) 1 paddle::platform::GetCurrentTraceBackString[abi:cxx11]() ---------------------- Error Message Summary: ---------------------- FatalError: `Segmentation fault` is detected by the operating system. [TimeInfo: *** Aborted at ******(unix time) try "date -d @******" if you are using GNU date ***] [SignalInfo: *** SIGSEGV (@0x0) received by PID ****** (TID 0x******) from PID 0 ***] Segmentation fault (core dumped) &gt;&gt;&gt; import os &gt;&gt;&gt; import cv2 &gt;&gt;&gt; from paddleocr import PPStructure,draw_structure_result,save_structure_res &gt;&gt;&gt; &gt;&gt;&gt; table_engine = PPStructure(show_log=True) download https://paddleocr.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3d662368e1f6ac657b991ace018766cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ffe974785a382428c222aa6bba2dddba/" rel="bookmark">
			java stream 实现双重for循环
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给定列表[1, 2, 3]和列表[3, 4]，返回[(1, 3), (1, 4), (2, 3), (2, 4), (3, 3), (3, 4)]。
import java.util.*; import java.util.stream.Collectors; public class Main { public static void main(String[] args) { List&lt;Integer&gt; numbers1 = Arrays.asList(1, 2, 3); List&lt;Integer&gt; numbers2 = Arrays.asList(3, 4); numbers1.stream().flatMap( a -&gt; numbers2.stream().map(b -&gt; new int[]{a, b}) ).collect(Collectors.toList()).forEach(c -&gt; System.out.println(Arrays.toString(c))); } } 输出：
[1, 3] [1, 4] [2, 3] [2, 4] [3, 3] [3, 4] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eea74fabb0fd5b1cde42bef3c284ea9b/" rel="bookmark">
			树莓派连接天猫精灵等蓝牙音箱并播放wav和pcm格式文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		树莓派连接天猫精灵等蓝牙音箱并播放wav和pcm格式文件 我们使用bluealsa来连接蓝牙音箱，并通过aplay实现wav文件播放
一、安装配置bluealsa模块 1. 安装 sudo apt-get install bluealsa
2. 添加用户组 sudo usermode -aG bluetooth pi
3. 重启并检查bluealsa服务状态 sudo reboot
systemctl status bluealsa
如果重启后，bluealsa服务状态为active即安装成功
二、连接蓝牙音箱 1. 进入蓝牙工具 sudo bluetoothctl
2. 扫描蓝牙设备 scan on
scan on 会列出搜索到的蓝牙设备，如果遇到蓝牙被占用的情况，可以通过rfkill命令来解决占用。
rfkill list 查看所有设备情况
rfkill unblock all 启动所有设备
3. 连接设备 connect 10:9E:3A:A3:6E:47
4. 退出蓝牙工具 exit
三、播放音频 播放wav格式文件 sudo aplay -D bluealsa:DEV=10:9E:3A:A3:6E:47 /usr/share/sounds/alsa/Rear_Right.wav
播放pcm格式文件 sudo aplay -t raw -c 1 -f S16_LE -r 16000 -D bluealsa:DEV=10:9E:3A:A3:6E:47 demo.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eea74fabb0fd5b1cde42bef3c284ea9b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f98bf4569a54e80cc682f6ebcdfe271f/" rel="bookmark">
			Mysql事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.何为事务？ 一言蔽之，事务是逻辑上的一组操作，要么都执行，要么都不执行。
2.另外，关系型数据库（例如：MySQL、SQL Server、Oracle 等）事务都有 ACID 特性： 原子性（Atomicity） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
一致性（Consistency）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。
3.数据事务的实现原理呢？ 我们这里以 MySQL 的 InnoDB 引擎为例来简单说一下。
MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性，使用 undo log(回滚日志) 来保证事务的原子性。
MySQL InnoDB 引擎通过 锁机制、MVCC 等手段来保证事务的隔离性（ 默认支持的隔离级别是 REPEATABLE-READ ）。
保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。
4.并发事务带来哪些问题? 在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。
脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。
不可重复读（Unrepeatable read）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f98bf4569a54e80cc682f6ebcdfe271f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18c927459b1fd56284e73049dbcfac82/" rel="bookmark">
			客户端关闭服务器收到消息推送消息,C#TCP通信有关问题。客户端发送的消息只能收到第一条。客户端必须断开重新连接，服务器才能再次收到信息。为何...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C# codeprivate void button1_Click(object sender, EventArgs e)
{
if (btnStart.Text == "开启服务器")
{
IPHostEntry hostEntry = Dns.GetHostEntry(Dns.GetHostName());
this.socketListener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
IPAddress ipAddress = IPAddress.Parse("192.168.1.109");
int port = Int32.Parse(this.txtPoint.Text);
IPEndPoint endPoint = new IPEndPoint(ipAddress, port);
this.socketListener.Bind(endPoint);
this.socketListener.Listen(30);
ThreadPool.QueueUserWorkItem(p =&gt;
{
while (true)
{
Socket socket = this.socketListener.Accept();
this.thread = new Thread(this.ReceiveMessage);
this.thread.Start(socket);
}
});
btnStart.Text = "关闭服务器";
if (!txtClientMessage.InvokeRequired)
{
txtClientMessage.AppendText("服务器已打开\n\r");
}
}
else
{
this.socketListener.Close();
this.thread.Abort();
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18c927459b1fd56284e73049dbcfac82/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ce944f55f3b3cf87d214fd21e79f493/" rel="bookmark">
			安徽省发票认证服务器网站,安徽省增值税发票综合服务平台网址及操作指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安徽省增值税发票综合服务平台网址及操作指南
安徽省增值税发票综合服务平台V4.0.00升级内容说明
本版本功能升级如下：
1、增值税发票选择确认平台更名为增值税发票综合服务平台。
2、增值税发票综合服务平台主要功能模块为：
抵扣勾选
退税勾选
代办退税勾选
进项发票查询
税务事项通知书
成品油消费税管理
发票下载
档案信息维护
3、对于勾选用途为抵扣的发票，企业可根据实际情况调整有效抵扣税额。
4、对于数据来源为扫描认证的发票，企业可根据实际业务需要自行修改用途。
5、抵扣勾选统计确认功能模块增加了确认签名操作，纳税人在申报之前必须对当前属期勾选的发票清册进行确认签名。
安徽省增值税发票综合服务平台特别提示：
1、在纳税申报内，对当期抵扣勾选的发票进行申请统计后，系统将锁定当期的抵扣勾选，如需继续勾选请先撤销统计。
2、在纳税申报内，申请抵扣统计且统计完成后，企业对统计表确认无误需进行确认签名，然后再进行抵扣申报工作。
3、本平台除支持IE8以上浏览器外，还支持火狐、谷歌等浏览器，请下载数字证书客户端控件并按照说明安装使用。
安徽省增值税发票综合服务平台操作指南
责任编辑 : 柳花暗香
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/379f67775eaeba69cc6b0029cb26b401/" rel="bookmark">
			小程序 服务器 路由,微信小程序的路由跳转方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		路由跳转的方法
1.打开新页面
1.wx.navigateTo 或使用组件 保留当前页面，跳转到应用内的某个页面，使用 wx.navigateBack 可以返回到原页面。
属性用法：
url： 类型是String 跳转非 tabBar 的页面的路径 , 路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&amp;分隔；如 'path?key=value&amp;key2=value2'
success： 类型Function 接口调用成功的回调函数
fail： 类型Function 接口调用失败的回调函数
complete： 类型Function 接口调用结束的回调函数(调用成功、失败都会执行)
例 ： wx.navigateTo({
url: 'test?id=1'
})
//test.js
Page({
onLoad: function(option){
console.log(option.query)
}
})
目前页面路径最多只能十层。
2.页面重定向
1.wx.redirectTo 或使用组件 属性用法：
url： 类型是String 跳转非 tabBar 的页面的路径 , 路径后可以带参数。参数与路径之间使用?分隔，参数键与参数值用=相连，不同参数用&amp;分隔；如 'path?key=value&amp;key2=value2'
success： 类型Function 接口调用成功的回调函数
fail： 类型Function 接口调用失败的回调函数
complete： 类型Function 接口调用结束的回调函数(调用成功、失败都会执行)
例 ： wx.redirectTo({
url: 'test?id=1'
})
//test.js
3.页面返回
1. wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/379f67775eaeba69cc6b0029cb26b401/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f50011d089c9f374ceba576c2d1e44ed/" rel="bookmark">
			网页无法访问plsql服务器,plsql访问服务器地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		plsql访问服务器地址 内容精选
换一换
成功访问网站包含以下两个阶段，这两个阶段缺一不可，需要同时成功才能正常访问网站，如图1所示。阶段一：DNS根据访问请求中的域名解析出对应的IP地址。阶段二：访问网站服务器IP获取网站内容。阶段一：DNS根据访问请求中的域名解析出对应的IP地址并返回解析结果。在此阶段，出现如下情况将导致网站无法访问：域名解析不成功无法返回解析结果，可参考解
当出现以下问题时，可以参考本章节排查解决。可以直接访问后端业务，但是无法通过负载均衡访问后端业务。通过私网IP可以访问负载均衡，但是公网IP无法访问负载均衡。后端服务器健康检查异常。客户端通过负载均衡访问服务器示意图如图1。公网客户端的流量经过EIP传送到负载均衡器；私网客户端的流量直接通过私网IP传送到负载均衡器。负载均衡器根据监听器配
plsql访问服务器地址 相关内容
依照配置并导入样例工程中导入和修改样例后，即可在开发环境中，右击“JDBCExample.java”，选择“Run 'JDBCExample.main()'”运行对应的应用程序工程。使用Windows访问MRS集群来操作Impala，有如下两种方式。方法一：申请一台Windows的ECS访问MRS集群操作Impala，在安装开发环境后可直
使用mount命令挂载文件系统到云服务器，云服务器提示access denied，挂载失败。原因1：文件系统已被删除。原因2：执行挂载命令的云服务器和被挂载的文件系统不在同一VPC下。原因3：挂载命令中的挂载地址输入错误。原因4：使用虚拟IP访问弹性文件服务。原因5：访问文件系统使用的DNS错误。原因6：将CIFS类型的文件系统挂载至Li
plsql访问服务器地址 更多内容
访问CloudTable的HBase连接不上，出现如下所示的错误信息：出现该问题的可能原因为：网络访问不通。由于CloudTable的链接地址是内网地址，不是公网地址，不能在公网环境直接连接CloudTable。您可以在客户端主机上ping一下CloudTable的ZK链接地址，如果无法ping通，说明网络不通。由于CloudTable的
云数据库RDS服务提供使用内网、公网和数据管理服务(Data Admin Service，简称DAS)的连接方式。VPC：虚拟私有云(Virtual Private Cloud，简称VPC)。ECS：弹性云服务器(Elastic Cloud Server，简称ECS)。您可以通过数据管理服务(Data Admin Service，简称DA
云数据库RDS服务提供使用内网、公网和数据管理服务(Data Admin Service，简称DAS)的连接方式。VPC：虚拟私有云(Virtual Private Cloud，简称VPC)。ECS：弹性云服务器(Elastic Cloud Server，简称ECS)。您可以通过数据管理服务(Data Admin Service，简称DA
数据库实例是分布式数据库中间件服务的最小管理单元。一个实例代表了一个独立运行的数据库。您可以在一个DDM实例中通过创建多个逻辑库管理多个MySQL实例，并且可以独立访问MySQL实例。使用管理控制台或API可以方便的创建和修改DDM实例。本文中的MySQL实例包括RDS for MySQL实例和GaussDB(for MySQL)实例两种
如果客户端工具的运行环境为Linux环境，您需要准备一台和CloudTable集群在相同虚拟私有云的Linux弹性云服务器作为客户端主机。例如，使用以下客户端工具访问集群，建议使用Linux弹性云服务器：HBase shellGeoMesa命令行工具如果客户端工具的运行环境为Windows环境，您需要准备一台和CloudTable集群在相
内网域名解析是基于VPC网络的域名解析过程，通过华为云内网DNS把域名(如ecs.com)转换成私网IP地址(192.168.1.1)。内网域名解析实现云服务器在VPC内直接通过内网域名互相访问。同时，还支持不经公网，直接通过内网DNS访问云上服务，如OBS、SMN等。云解析服务的内网DNS为华为云服务提供基于VPC网络的域名解析服务，解
依照准备JDBC客户端开发环境中导入和修改样例后，并从集群Manager获取到keytab文件放置到样例工程的conf下(普通模式集群可忽略)，即impala-examples/conf。即可在开发环境中(例如Eclipse中)，右击“JDBCExample.java”，单击“Run as &gt; Java Application”运行对应的
一般情况下，用户会通过OBS提供的桶访问域名(例如https://bucketname.obs.cn-north-4.myhuaweicloud.com)或者绑定的自定义域名来访问OBS。但在某些场景下，用户需要通过固定的IP地址访问OBS，例如：某些企业出于安全考虑，对于可访问的外部地址需要设置黑白名单，而这个时候对于OBS的访问则需要
安全组类似防火墙功能，是一个逻辑上的分组，用于设置网络访问控制。用户可以在安全组中定义各种访问规则，当弹性云服务器加入该安全组后，即受到这些访问规则的保护。入方向：入方向规则放通入方向网络流量，指从外部访问安全组规则下的云服务器。出方向：出方向规则放通出方向网络流量。指安全组规则下的云服务器访问安全组外的实例。默认安全组规则请参见默认安全
安全组是一个逻辑上的分组，为同一个虚拟私有云内具有相同安全保护需求，并相互信任的弹性云服务器和云数据库RDS实例提供访问策略。为了保障数据库的安全性和稳定性，在使用云数据库RDS实例之前，您需要设置安全组，开通需访问数据库的IP地址和端口。通过弹性公网IP连接RDS实例时，需要为RDS所在安全组配置相应的入方向规则。因为安全组的默认规则是
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5aab9fe6c50bf764c8906a8458b5d368/" rel="bookmark">
			如何打开服务器上的数据库文件,如何打开服务器的数据库文件在哪里
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何打开服务器的数据库文件在哪里 内容精选
换一换
华为云帮助中心，为用户提供产品简介、价格说明、购买指南、用户指南、API参考、最佳实践、常见问题、视频帮助等技术文档，帮助您快速上手使用华为云服务。
云服务器新增磁盘，开机自动执行磁盘初始化脚本后，Oralce、MySQL和SQL Server等数据库系统日志Msg 823错误 。磁盘初始化脚本WinVMDataDiskAutoInitialize.ps1执行过程中会调用diskpart启用virtual disk服务，执行完毕后会退出diskpart，停用virtual disk服务
如何打开服务器的数据库文件在哪里 相关内容
PostgreSQL支持逻辑备份。您可使用pg_dump逻辑备份功能，导出备份文件，再通过psql导入到RDS中，实现将PostgreSQL的数据导入到云数据库RDS中。云数据库RDS服务支持开启公网访问功能，通过弹性公网IP进行访问。您也可通过弹性云服务器的内网访问云数据库RDS。准备弹性云服务器或可公网访问云数据库RDS。通过弹性云服
如何打开服务器的数据库文件在哪里 更多内容
本手册基于华为云关系型数据库实践所编写，用于指导您完成相关设置，购买更符合业务的数据库实例。
文档数据库服务支持开启公网访问功能，通过弹性IP进行访问。您也可通过弹性云服务器的内网访问文档数据库。要将已有的MongoDB数据库迁移到文档数据库，需要先使用mongoexport工具对它做转储。再通过弹性云服务器或可访问文档数据库的设备，使用mongoimport工具将转储文件导入到文档数据库服务。建议您尽量选择在业务低峰期迁移数据，
对于mysqlpump工具，由于在并行备份场景有coredump问题，不建议您使用，推荐您使用mysqldump工具迁移。GaussDB(for MySQL)支持开启公网访问功能，通过弹性公网IP进行访问。您也可通过弹性云服务器的内网访问GaussDB(for MySQL)。准备弹性云服务器或可通过公网访问GaussDB(for MySQ
创建sink流将Flink作业数据通过OBS转储方式输出到数据仓库服务(DWS)，即Flink作业数据先输出到OBS，然后再从OBS导入到DWS。如何导入OBS数据到DWS具体可参考《数据仓库服务数据库开发指南》中从OBS并行导入数据到集群章节。数据仓库服务(Data Warehouse Service，简称DWS)是一种基于基础架构和平
创建sink流将Flink作业数据通过OBS转储方式输出到数据仓库服务(DWS)，即Flink作业数据先输出到OBS，然后再从OBS导入到DWS。如何导入OBS数据到DWS具体可参考《数据仓库服务数据库开发指南》中从OBS并行导入数据到集群章节。数据仓库服务(Data Warehouse Service，简称DWS)是一种基于基础架构和平
GaussDB(for MySQL)全兼容MySQL协议，因此，连接GaussDB(for MySQL) 实例有普通连接和SSL连接。其中，SSL连接实现了数据加密功能，具有更高的安全性。登录弹性云服务器。创建并登录弹性云服务器，请参见《弹性云服务器快速入门》中“购买弹性云服务器”和“登录弹性云服务器”。通过弹性云服务器连接GaussDB
华为认证云服务工程师沙箱实验，结合华为认证云服务工程师的学习课程， 适合云技术爱好者希望成为云服务工程师的广大开发者，深入了解及掌握涵盖计算类服务、存储类服务、数据库服务等服务类别的操作原理和使用场景。
来自：其他
云数据库RDS服务支持开启公网访问功能，通过弹性公网IP进行访问。您也可通过弹性云服务器的内网访问云数据库RDS。准备弹性云服务器或可通过公网访问云数据库RDS。通过弹性云服务器连接云数据库RDS实例，需要创建一台弹性云服务器。创建并连接弹性云服务器，请参见如何创建和连接ECS。通过公网地址连接云数据库RDS实例，需具备以下条件。先对云数
如果连接失败，需要检查哪些方面？解答：检查以下几个方面：验证连接属性，检查连接属性输入是否正确。检查服务器和客户端版本是否兼容。检查database\pg_hba.conf文件是否正确配置。更多细节，参加服务器手册。检查Data Studio.ini文件是否正确配置。解答：检查以下几个方面：验证连接属性，检查连接属性输入是否正确。检查服务
GaussDB(DWS) 支持多数据源高效入库，典型的入库方式如下所示。详细指导请参见《数据仓库服务数据库开发指南》中的导入数据。从OBS导入数据数据上传到OBS对象存储服务中，再从OBS中导入，支持CSV，TEXT格式数据。数据上传到OBS对象存储服务中，再从OBS中导入，支持CSV，TEXT格式数据。通过INSERT语句直接插入数据用
华为云提供两种连接方式通过MySQL客户端连接实例：非SSL连接和SSL连接。其中，SSL连接实现了数据加密功能，具有更高的安全性。登录弹性云服务器。创建并登录弹性云服务器，请参见《弹性云服务器快速入门》中“购买弹性云服务器”和“登录弹性云服务器”。通过弹性云服务器连接云数据库RDS实例，需要具备以下条件。该弹性云服务器与目标实例必须处于
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/288/">«</a>
	<span class="pagination__item pagination__item--current">289/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/290/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>