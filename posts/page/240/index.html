<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/96067c00d24fbf696f42590466c891e5/" rel="bookmark">
			设计模式之抽象工厂模式(Abstract Factory)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、抽象工厂模式(Abstract Factory)简介 抽象工厂模式(Abstract Factory)是以一个超级工厂创建其他工厂。它属于创建型模式。抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。
二、抽象工厂模式(Abstract Factory)的优点 抽象工厂模式将具体产品的创建延迟到具体工厂的子类中，这样将对象的创建封装起来，可以减少客户端与具体产品类之间的依赖，从而使系统耦合度低，这样更有利于后期的维护和扩展
三、抽象工厂模式(Abstract Factory)的缺点 抽象工厂模式很难支持新种类产品的变化。这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，这就违背了"开闭原则"。
四、抽象工厂模式(Abstract Factory)适用场景 使用抽象工厂模式的系统应该符合以下几个条件:
①一个系统不要求依赖产品实例如何被创建、组合和表达
②这个系统有多个系列产品，而系统中只消费其中某一系列产品
③系统要求提供一个产品类的库，所有产品以同样的接口出现，客户端不需要依赖具体实现
五、抽象工厂模式(Abstract Factory)举例 举一个生活例子来形象地描述抽象工厂模式。某一个食品企业，在全国均有分店，它的产品有"产品A"和"产品B"，由于北方和南方的口味并不一样，所以产品的生产会有所不同。
六、抽象工厂模式(Abstract Factory)实现 抽象工厂类
using System.Collections; using System.Collections.Generic; using UnityEngine; //定义抽象工厂 public abstract class AbstractFactory { public abstract ProductAAbstract CreateProductAManager(); public abstract ProductBAbstract CreateProductBManager(); } 抽象产品类
using System.Collections; using System.Collections.Generic; using UnityEngine; //定义产品A抽象类 public abstract class ProductAAbstract { public abstract void ProductionLine(string where); } 抽象产品类 using System.Collections; using System.Collections.Generic; using UnityEngine; //定义产品B抽象类 public abstract class ProductBAbstract { public abstract void ProductionLine(string where); } 具体工厂类
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/96067c00d24fbf696f42590466c891e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2c85f1e52ccf83951ff57e7b0df8a009/" rel="bookmark">
			Java发布GeoserverTiff瓦片服务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下载jar包并将其引入idea： 链接：https://pan.baidu.com/s/1CRNhr8qjimcscZANOk2UPA
提取码：964f
代码： geoserver: url: http://localhost:8080/geoserver username: admin password: geoserver @Value("${geoserver.url}") private String geoserverUrl; @Value("${geoserver.username}") private String geoserverUsername; @Value("${geoserver.password}") private String geoserverPassword; String tifPath = "D:/tiff"; public void publishGeoServerTif(String filename){ String workSpace = "caixukun"; // 待创建和发布图层的工作区名称workspace try { // 判断工作区（workspace）是否存在，不存在则创建 URL u = new URL(geoserverUrl); GeoServerRESTManager manager = new GeoServerRESTManager(u, geoserverUsername, geoserverPassword); GeoServerRESTPublisher publisher = manager.getPublisher(); List&lt;String&gt; workspaces = manager.getReader().getWorkspaceNames(); if (!workspaces.contains(workSpace)) { boolean createws = publisher.createWorkspace(workSpace); System.out.println("create ws : "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2c85f1e52ccf83951ff57e7b0df8a009/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/407d34ba3d10e407ea2c88b6e998fdda/" rel="bookmark">
			Python 爬虫：跳转页面时，网页链接(url)不变，XHR中的含有网页信息的文件链接(url)不变，解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转载自https://blog.csdn.net/weixin_44606217/article/details/98629593
解决办法在文末
问题： 第一页和第二页网址相同（不变） XHR中包含网页信息的文件链接地址相同（不变） 分析： 点开上图中的.ashx文件（注意：此文件包含网页信息，别的网站可能为js文件）发现，文件中含有字段：PageCount和pageIndex，分别代表总页数和当前页
单击.ashx文件查看请求头，可以看到 Form Data数据
可点击'view source'改变Form Data展示
解决办法： 用 ? 将Form Data数据拼接到.ashx文件的链接中
改变链接中pageIndex的值即可实现跳转
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c544c25fd88834295f7b32ca727cdbb1/" rel="bookmark">
			Spring个人学习小结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;!--Spring重点配置--&gt; &lt;!-- &lt;bean&gt;标签--&gt; &lt;!-- id属性:在容器中Bean实例的唯一标识， 不允许重复--&gt; &lt;!-- class属性:要实例化的Bean的全限定名--&gt; &lt;!-- scope属性tBean的作用范围，常用是Singleton (默认)和prototype--&gt; &lt;!-- &lt;property&gt;标签:属性注入--&gt; &lt;!-- name属性:属性名称--&gt; &lt;!-- value属性:注入的普通属性值--&gt; &lt;!-- ref属性:注入的对象引用值--&gt; &lt;!-- &lt;list&gt;标签--&gt; &lt;!-- &lt;map&gt;标签--&gt; &lt;!-- &lt;properties&gt;标签--&gt; &lt;!-- &lt;const. ructor-arg&gt;标签--&gt; &lt;!-- &lt;import&gt;标签:导入其他的Spring的分文件--&gt; &lt;!-- Spring相关API--&gt; &lt;!-- applicationContext:接口类型,代表应用上下文,可以通过其实例获得Spring容器中的Bean对象--&gt; &lt;!-- applicationContext实现类--&gt; &lt;!-- 1) ClassPathXmlApplicationContext--&gt; &lt;!-- 它是从类的根路径下加载配置文件推荐使用这种--&gt; &lt;!-- 2) FileSystemXmlApplicationContext--&gt; &lt;!-- 它是从磁盘路径上加载配置文件,配置文件可以在磁盘的任意位置。--&gt; &lt;!-- 3) AnnotationConfigApplicationContext--&gt; &lt;!-- 当使用注解配置容器对象时，需要使用此类来创建spring容器。它用来读取注解。--&gt; &lt;!-- --&gt; &lt;!-- getBean使用--&gt; &lt;!-- 若容器当中某一个类型存在多个，要通过id获取 getBeanFactory().getBean(name)--&gt; &lt;!-- 若容器当中某一个类型存在一个，要通过类型进行获取 getBeanFactory().getBean(requiredType)--&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ad2214bc0e1738ce50344581063be16a/" rel="bookmark">
			Kubernetes 学习总结（27）—— Kubernetes 安装 Redis 集群的两个方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、自定义 yaml 文件安装 背景 在 Kubernetes 中部署 Redis 集群面临挑战，因为每个 Redis 实例都依赖于一个配置文件，该文件可以跟踪其他集群实例及其角色。为此，需要结合使用 Kubernetes StatefulSets 和 PersistentVolumes 实现。Redis 集群架构如下图所示：
创建 StatefulSet yaml 文件 --- apiVersion: v1 kind: ConfigMap metadata: name: redis-cluster data: update.sh: | #!/bin/sh REDIS_NODES="/data/nodes.conf" sed -i -e "/myself/ s/[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}/${POD_IP}/" ${REDIS_NODES} exec "$@" redis.conf: |+ bind 0.0.0.0 cluster-enabled yes cluster-require-full-coverage no cluster-node-timeout 30000 cluster-config-file /data/nodes.conf cluster-migration-barrier 1 appendonly yes protected-mode no --- apiVersion: apps.kruise.io/v1beta1 # apiVersion: apps/v1 kind: StatefulSet metadata: name: redis-cluster spec: serviceName: redis-cluster replicas: 6 selector: matchLabels: app: redis-cluster template: metadata: labels: app: redis-cluster spec: containers: - name: redis image: redis:6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ad2214bc0e1738ce50344581063be16a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d3e28535c74ccee29182aeb3cf837e98/" rel="bookmark">
			Axios
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先下载axios插件 "axios": "^0.27.2"
在src文件夹下创建一个utils文件夹，文件夹下面有个axios文件夹，在里面首先导入下载的axios插件
import axios from "axios";//先导入axios //下面是请求拦截器 axios.interceptors.request.use(function (config) { // Do something before request is sent console.log('config',config.data) // const data = JSON.parse(config.data || "{}") config.data = qs.stringify(config.data || {}) config.headers.token = 'xxxxx' return config; }, function (error) { // Do something with request error return Promise.reject(error); }); // Add a response interceptor //下面是相应拦截器 axios.interceptors.response.use(function (response) { // Any status code that lie within the range of 2xx cause this function to trigger // Do something with response data console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d3e28535c74ccee29182aeb3cf837e98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fe617620f6465efe0b3eedc1561b8cd8/" rel="bookmark">
			OpenCV入门（十）——图像分割技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
0x01 FloodFill分割
0x02 均值漂移MeanShift
0x03 图割Grabcut
0x04 奇异区域检测
0x05 肤色检测
0x01 FloodFill分割 FloodFill泛洪填充算法是在很多图形绘制软件中常用的填充算法，通常来说是自动选中与种子像素相关的区域，利用指定的颜色进行区域颜色替换，可用于标记或分离图形的某些部分。比如windows系统中的图像编辑软件中的油漆桶这一功能，或者是Photoshop的魔术棒选择工具，都是通过FloorFill泛洪填充来改进和延伸的。
（一）原理
从一个点开始遍历附近的像素点，填充成新的颜色，直到封闭区域内的所有像素点都被填充成新颜色为止。
（二）常见方法
4邻域像素填充法、8邻域像素填充法、基于扫描线的像素填充方法等。
（三）OpenCV中的接口
int floodFill( InputOutputArray image,	//1或3通道，8bit或浮点型数据，输入图像将会因为被函数操作而修改，如果想保留原图则使用CV_FLOODFILL_MASK_ONLY Point seedPoint,	//种子点开始位置 Scalar newVal, //新的重新绘制的像素值 CV_OUT Rect* rect = 0,	Scalar loDiff = Scalar(), //当前观察像素值与其部件领域像素或者待加入该部件的种子像素之正差的最大值 Scalar upDiff = Scalar(), //当前观察像素值与其部件领域像素或待加入该部件的种子像素之正差的最大值 int flags = 4 );	//操作选项标志位，低位比特包含连通值，4或8 函数解析：
用指定颜色填充一个连通域。高位比特位可以选择0或下面的开关选项的组合：如果设置CV_FLOODFILL_FIXED_RANGE为当前选项，则考虑当前像素与种子像素的差，否则考虑当前像素与其相邻像素的差。如果设置CV_FLOODFILL_MASK_ONLY为当前选项，函数不填充原始图像，但填充掩模图像（这种情况下MASK必须是非空的）。
怎么用：
FloodFill区域填充适用于对内定义区域的种子进行填充，区域内部所有像素具有统一的颜色或亮度，外部区域外的所有像素值表现出不同的特征。利用FloodFill可将该区域中的全部像素都设置为另外一个新值，并通过特定规则来实现区域内点中的连通域，从而实现对相似区域进行填充，直到找到区域内所有像素或边界轮廓。
那么我们可以通过实现一个点击一个点，判断邻域的特征值进行填充，就像油漆桶的操作：
#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "opencv2/core/core.hpp" #include "opencv2/core/utility.hpp" #include "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fe617620f6465efe0b3eedc1561b8cd8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5093e5b9f8832e8290723e4e9e94dc73/" rel="bookmark">
			MyBatisPuls中注解开发一对多和多对多开发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用MyBatisPlus的时候，相信很多小伙伴也很不喜欢一大堆的配置文件，看起来眼花缭乱的，一点的不舒服，而且巧了，我也是不喜欢配置文件的编程。如果你是学习使用MyBatis，我不建议你使用MyBatisPlus的自动封装的操作，虽然很方便，但是会让人变的懒惰，从而对SQL的陌生成度也会大大增加，彻底的变为工具人。学习，就是在不断的踩坑，然后再不断的填坑，让及非常的抗揍，这才是学习的乐趣与意义。
扯远了，接下来我们看一下注解式开发中一对一的情况：
one=@One(select("namespace"))，这句的意思是一对多或者一对一（MyBatis官方将其称作一对一），它的大概意思就是一个对象中的属性或者JavaBean对应其他多个对象，如下
@NoArgsConstructor @Data @ToString @TableName("t_bolg") public class Bolg implements Serializable { @TableId("id") private Long id;//id private String title;//标题 private String content;//内容 private String firstPicture;//首图 private String classType;//分类 private Integer views;//浏览次数 private String appreciation;//赞赏开启 private String shareInfo;//分享 private String commentable;//评论开启 private String published;//发布或者保存 private String recommend;//是否推荐 private String createDateTime;//发布时间 private String updateDateTime;//更新时间 private String username;//用户名 private String original;//是否原创 private String tTagList;//博客标签 @TableField(exist = false) private List&lt;String&gt; tagList;//获得所有标签 @TableField(exist = false) private List&lt;String&gt; typeList;//获得所有分类 @TableField(exist = false) private Admin admin;//管理员 @TableField(exist = false) private List&lt;Comment&gt; commentList; } 这是一个实体类，对应数据库中的一个表，其中@TableField(exist = false)表示这个属性不是数据库字段，我们看一下具体的操作
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5093e5b9f8832e8290723e4e9e94dc73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/04b321c4a72e87b16cd711299f6a4f53/" rel="bookmark">
			如何缩小png图片大小kb?如何让png图片变小?
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何压缩png图片大小？高清png格式图片比较大，上传时就会受到大小限制。使用图片压缩工具，一键即可在线将png压缩，一起学习下png图片在线压缩的方法吧。
1、上传图片。
2、选择尺寸、宽、高、压缩等级输入参数，压缩等级默认70，如未达到效果，可选择压缩等级调整 。
3、下载图片，即可使用。
通过以上在线图片压缩工具使图片缩小且画质无损，如果需要将生成png图片转换成jpg格式，具体操作步骤请看：如何将png格式的图片转换成jpg格式？
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d1811ed3b5fd09385c5a08e41239d63/" rel="bookmark">
			数据库（mysql）数据的备份与还原
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 （还不会创建数据表的可以看一下我的上一篇链接文章 哦）
1.数据的备份
在已输入字符的数据表内进行：
1.1 返回到mysql安装的bin路径下 输入 ：mysqldump -账号 -密码 数据表名&gt;备份名.sql
举个栗子：mysqldump -rrrr -1111 test&gt;1.sql(注意 1.sql 后没有";"）
在mysql的bin文件夹内可以看到你的 备份 2.sql 表示备份成功
2.数据的还原
2.1 (操作简易）需要进入mysql输入界面创建一个新的数据表即可：
1）创建一个新的数据表: create a1;
2)使用并查看这个数据表: a.use a1 b.show tables;
3）运行 source 备份的文件名 ：source 文件的绝对路径;
我们查看一下还原后结果：
2.2 返回到mysql安装的bin路径下输入：mysql -u用户名 -p密码 已创建的空数据名 &lt; 已备份的.sql格式文件 举个栗子：mysql -uroot -p1234 wahaha &lt; 2.sql（注意：此处还是无分号“；”，感兴趣的小伙伴可以测试一下加分号的显示结果）
1）我们先创建一个空表数据库：wahaha；
2）返回到mysql安装的bin路径进行还原
3）查看是否还原成功
ok，数据表的备份与还原到这就结束了，谢谢观看。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e75fd3ab2430c3dbc6b6e69a78d3183/" rel="bookmark">
			vs点云项目中无法定位程序输入点于动态链接库vtkGUISupportQt-8.2.dll上
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在运行一些vtk和pcl库的qt项目时，vs2022给我报错了，显示的是无法定位程序输入点于动态链接库......vtkGUISupportQt-8.2.dll上。我试了下网上说的各种方法，有的说是依赖库问题，可是环境已经配置完成，属性表和链接库也都配置清楚，能够在vs中生成exe文件，但exe文件还是无法打开。
由于问题已经解决当时没有截图，所以这里借用下别人的图片。
看到其他文章说这类问题大概率都是系统变量的问题，于是将目标转向系统变量path中。
发现这个问题无法定位程序输入点于动态链接库......vtkGUISupportQt-8.2.dll上是因为变量环境中qt的bin路径问题，但我之前已经添加过了这个路径，于是考虑是不是后面其他的变量影响了，于是吧图示路径调到最上面，问题就得到解决了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c9de741b625640bf8651b1ab3bc54ed/" rel="bookmark">
			RK3566 Android11 替换开机logo导致死机问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 问题解法简要分析参考资料 Platform: RK3566 OS: Android 11 U-boot: v2017.09 Kernel: v4.19.219 SDK Version：rk356x_box_11.0_release_v1.0.9_20220309 Module: uboot logo 问题 替换开机logo后出现报错死机的情况，主要报错信息如下：
"Synchronous Abort" handler, esr 0x96000145 Reason: Exception from a Data abort, from current exception level PC = 0000000000a01afc LR = 0000000000a51c08 SP = 00000000eb9f8560 ESR_EL2 = 0000000096000145 Reloc Off = 00000000ed34b000 解法 uboot目录下修改
diff --git a/drivers/video/drm/rockchip_display.c b/drivers/video/drm/rockchip_display.c index 939beb9387..775597841e 100644 --- a/drivers/video/drm/rockchip_display.c +++ b/drivers/video/drm/rockchip_display.c @@ -1331,6 +1331,7 @@ static int load_bmp_logo(struct logo_info *logo, const char *bmp_name) ret = -EINVAL; goto free_header; } + flush_dcache_range((ulong)dst, ALIGN((ulong)dst + dst_size, CONFIG_SYS_CACHELINE_SIZE)); logo-&gt;offset = 0; logo-&gt;ymirror = 0; @@ -1345,7 +1346,7 @@ static int load_bmp_logo(struct logo_info *logo, const char *bmp_name) memcpy(&amp;logo_cache-&gt;logo, logo, sizeof(*logo)); - flush_dcache_range((ulong)dst, ALIGN((ulong)dst + dst_size, CONFIG_SYS_CACHELINE_SIZE)); + //flush_dcache_range((ulong)dst, ALIGN((ulong)dst + dst_size, CONFIG_SYS_CACHELINE_SIZE)); free_header: 简要分析 上述解法据客户说来源于RK姚工，没有做具体的解释，我自己尝试简单分析理解下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9c9de741b625640bf8651b1ab3bc54ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/116df9af0babe344f6892e0ecacd6ba7/" rel="bookmark">
			java.lang.ClassCastException: java.util.ArrayList cannot be cast to java.util.Map的解决和补充
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、问题描述 报错：java.lang.ClassCastException: java.util.ArrayList cannot be cast to java.util.Map
二、解决 导致这个问题是因为，存进去的是list，却直接强转为map。
有这样一段代码：（注：代码已经做了“马赛克”处理）
TestObject t = new TestObject(); List&lt;Map&lt;String, Object&gt;&gt; list1= new ArrayList&lt;&gt;(); Map&lt;String, Object&gt; map1= new HashMap&lt;&gt;(); map1.put("test", test); list1.add(map1); t.put("aaa", list1); 原来取值的时候：
TestObject testObject = (TestObject) object; Map&lt;String, Object&gt; map2 = (Map&lt;String, Object&gt;) testObject .get("aaa"); 然后就报错了java.lang.ClassCastException: java.util.ArrayList cannot be cast to java.util.Map
是因为存进去的是list，却强转为map
所以这里要多加一层转换，先拿到list，再去取map
TestObject testObject = (TestObject) object; List&lt;Map&lt;String, Object&gt;&gt; list2 = (List&lt;Map&lt;String, Object&gt;&gt;) testObject.get("aaa"); if (list2 == null) continue; Map&lt;String, Object&gt; map2 = list2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/116df9af0babe344f6892e0ecacd6ba7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/34a84ae00a037d59be0bc933118148aa/" rel="bookmark">
			kubelet启动报错cannot find network namespace for the terminated container
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.报错：
使用journalctl -xefu kubelet命令查看kubelet日志发现如下报错：
cannot find network namespace for the terminated container
2.解决办法：
# docker system prune
# systemctl restart kubelet
docker system使用说明：
# docker system -h
Flag shorthand -h has been deprecated, please use --help
Usage: docker system COMMAND
Manage Docker
Commands:
df Show docker disk usage
查看docker空间使用情况。
events Get real time events from the server
查看实时事件。
info Display system-wide information
查看系统信息。
prune Remove unused data
docker清理停止的容器，没有容器使用的网络、镜像、缓存。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb3d1a6add1c4d5e74eaf5da16271994/" rel="bookmark">
			java登录权限实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分享一个简单java的登录权限实现过程吧，复制即用 我这里是用拦截器实现的，使用的redis，springboot2。废话不多说，上代码吧
定义验证等级枚举： public enum AuthorityType { //不验证 Nocheck, //只验证登录 CheckLongin, // 登录和权限都验证 CheckLevel0,//用户等级为0权限 CheckLevel1,//用户等级为1权限 CheckLevel2,//用户等级为2权限 } 定义接口： @Documented @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface Authority { // 默认验证 AuthorityType value() default AuthorityType.Nocheck; } 定义拦截器： //登录权限验证拦截器 @Slf4j @Aspect @Component public class AuthorityAnnotationInterceptor extends HandlerInterceptorAdapter { //redis注入 @Autowired private StringRedisTemplate redisTemplate; //用户业务层接口 @Autowired private IWjUserService wjUserService; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { if (handler instanceof HandlerMethod) { HandlerMethod hm = (HandlerMethod) handler; Class&lt;?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb3d1a6add1c4d5e74eaf5da16271994/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/850b4a4273f9e76deb6591e638aea44f/" rel="bookmark">
			SourceForge下载慢的解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		SourceForge下载慢的解决方案
版权归生化环材所有，请勿爬取本文用于商业推广！
前言 SourceForge 是一个托管开源软件发行版的优秀网站。然而，因为服务器在国外，我们从SourceForge下载软件总是遇到下载速度慢的问题。本文分享两个方法加快SourceForge的下载速度。
方法一：使用镜像站 如上所述，SourceForge服务器位于海外，地理位置原因使下载缓慢。但作为开源平台，SourceForge存在分布于地球各个角落的诸多镜像站。我们从距离我国地理位置较近的镜像站下载，速度会明显加快。
在SourceForge的下载界面，点击下载后会进入如下界面。此时点击「Problem Downloanding?」按钮可以进入镜像站列表。
然后选择「Auto-select」，网站会自动选择地理位置较近的镜像站。此时可以看出下载速度明显加快。
方法二：迅雷 众所周知，迅雷使用P2P技术聚合全网带宽资源，使下载速度加快。迅雷尽管因为破坏P2P下载生态而被批评为「吸血雷」，但使用迅雷下载资源的速度毋庸置疑。因此，可以使用迅雷打开下载链接，以较快的速度下载开源软件发行包。
相关文章 使用 FreeCDN 让博客自动切换免费公共 CDN提升访问速度
Windows 服务器安装 WordPress 搭建博客站
前端静态资源加载失败自动重新加载解决方案
安装VSCode并设置使用Anaconda虚拟环境
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d495a0cc6fe1f4857f25e612699908dd/" rel="bookmark">
			mac vue-cli启用80端口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、需要指定port为80
2、需要sudo npm run dev，才可以
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08c5432b353a78a3c17ba434024b184f/" rel="bookmark">
			Linux内核中的互斥锁和自旋锁的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很多人搞不清自旋锁和互斥锁的区别，这两种锁都是最底层的锁实现。是很多高级锁的基础。
为什么需要锁？
共享资源是有限的，且同一时间只能有一方占用。就像我们常见的共享单车，它是多人共用的，但是在某个时刻，只能有一个人使用，当我们扫码的时候，它只属于我们，其他人不能占用。这就是加锁的意义。为了保证系统中的共享资源在一个时刻只能有一个线程访问，避免多线程同时使用导致的数据错乱。
锁是谁加的？
任何操作都是由内核完成，线程向内核申请加锁，是否能锁住是由内核决定的。
互斥锁 假设我们目前有两个进程，进程A和进程B。当A需要枷锁的时候会向内核申请获取锁，获取成功后独占互斥锁，进行自己的任务执行。此时B想要获取锁，但此时锁被A占用，所以获取失败，内核将现成B置为休眠状态。等到进程A执行完毕释放锁之后，内核在核实的时机唤醒进程B，成功获取锁后继续执行。
https://blog.csdn.net/qq_37935909/article/details/108625508
需要注意的是在进程B加锁失败后，会从用户态陷入内核态，让内核切换线程，简化了使用锁的难度，但是对性能存在影响。
当两个线程属于同一个进程，因为内存是共享的，所以在切换时虚拟内存这些资源保持不动，只切换线程的私有数据、寄存器等不共享的数据。
上下文的切换耗时比较短，只有几十纳秒到几微秒。如果加锁部分运行的代码比较短，有可能上下文切换的时间比锁住的代码时间还长，就得不偿失了，所以当确定被锁住的代码部分执行时间比较短，就不适合实用互斥锁，应该选择自旋锁。
自旋锁 自旋锁其核心是使用CPU的CAS，在用户态完成加锁和解锁，不会主动产生线程上下文切换，所以比互斥锁来说，时间上会快很多。同时自旋锁不需要线程休眠，对资源的开销也更小。
使用自旋锁的时候，当发生多线程竞争锁的情况，加锁失败的线程会忙等待，直到拿到锁。忙等待可以通过while循环实现，不过最好是使用CPU提供的PAUSE指令来实现。
自旋锁利用CPU周期一直自旋直到锁可用。由于一个自选的线程永远不会放弃CPU，因此在单核CPU上，需要抢占式的调度器（不断通过时钟中断一个线程，运行其他线程）。
自旋的时间和被锁住的代码执行的时间成正比关系。
所以选择互斥锁还是自旋锁，要根据实际情况来看。一些更高级的锁会选择其中一个来实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e24b9b4651b52369e60900255fe698c7/" rel="bookmark">
			3-1 客户评级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 某电商要对平台上客户进行评级，按客户的月平均消费情况进行评级，规则如下：
输入年度的消费额，根据上表的月平均消费情况输出相应的“*”数。
输入格式: 输入年度消费额。
输出格式: 相应的“*”数
输入样例: 在这里给出一组输入。例如：
25000 输出样例: 在这里给出相应的输出。例如：
** 输入样例: 在这里给出一组输入。例如：
80000 输出样例: 在这里给出相应的输出。例如：
***** xiaofei = int(input()) xiaofei = xiaofei/12 if xiaofei &lt; 2000: #判断消费等级 b = 1 elif xiaofei&lt;3000: b = 2 elif xiaofei&lt;4000: b = 3 elif xiaofei&lt;5000: b = 4 else: b = 5 for i in range(0,b): #循环输出b个* print("*",end="") # end语句可以让下次输出不换行且可以在输出后加上指定字符 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/35089c40ab4c7b1af4805f98e7dd2104/" rel="bookmark">
			Java解析yaml文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java解析yaml文件 1. 什么是yaml ?2. 导入maven依赖3. yaml 案例文件4. 示例代码5. 解析结果 1. 什么是yaml ? 参考下方链接
yaml快速入门
2. 导入maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.yaml&lt;/groupId&gt; &lt;artifactId&gt;snakeyaml&lt;/artifactId&gt; &lt;version&gt;1.26&lt;/version&gt; &lt;/dependency&gt; 3. yaml 案例文件 name: steven phone: 18********5 company: "******" teamMember: - 于** - 徐** - 索** hobbies: foods: - 黄焖鸡米饭 - 黄焖排骨 - 五花肉 - 热干面 sports: - 羽毛球 - 骑车 - 跑步 works: - coding - repairComputer working-skills: - Java - Hadoop - hive - spark - flink - kafka - HBASE 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/35089c40ab4c7b1af4805f98e7dd2104/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/875629c2b86e73358610bc9b4c44f8da/" rel="bookmark">
			2-11 偶数位特殊序列和
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 给定不超过9的正整数a，给定正整数n,n是偶数,4&lt;=n&lt;=18，要求编写程序求aa+aaaa+aaaaaa+⋯+aa⋯a（n个a）之和。
输入格式: 在一行中给出不超过9的正整数a和n。
输出格式: 在一行中输出对应的和。
样例"&gt;输入样例: 在这里给出一组输入。例如：
1 4 输出样例: 在这里给出相应的输出。例如：
1122 a,n=map(int,input().split()) #输入a,n sum=0 for i in range(2,n+2,2): #i从2开始累加，每次循环累加2，累加到n+2 sum=sum+int(str(a)*i) #把a变成字符串型乘i就能实现aa,aaaa,aaaaaa...与sum的累加 print(sum) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c872da366739552933007eae5709ec0b/" rel="bookmark">
			#今日论文推荐# PKU-DAIR实验室：首篇基于图神经网络的推荐系统综述，211篇参考文献
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#今日论文推荐# PKU-DAIR实验室：首篇基于图神经网络的推荐系统综述，211篇参考文献
ACM Computing Surveys (CSUR) 中文全称为美国计算机学会计算概观，是计算机学科最具影响力的期刊之一。作为计算机科学、理论和方法的综述类顶刊，其 2020 影响因子 10.282，该期刊主要发表计算机科学领域较有代表性的综述论文。PKU-DAIR 实验室研究成果 Graph Neural Networks in Recommender Systems: A Survey 已被 ACM Computing Surveys 接收。
近几年，图神经网络（GNN）技术在推荐系统中得到了广泛的应用，因为推荐系统中的大部分信息本质上都具有图结构，而 GNN 在图表示学习方面具有优势。该综述旨在梳理、总结并讨论关于基于 GNN 的推荐系统的研究工作，便于对此领域感兴趣的研究者或者工业界人士快速了解这一领域。具体来说，该综述基于推荐过程中使用的信息类型和推荐任务对现有工作进行分类。此外，我们分析了将 GNN 应用于不同类型数据和推荐任务面临的挑战，总结了现有工作如何应对这些挑战，并讨论了现有工作的优点和局限性。此外，我们阐述了 9 个该领域有待进一步研究的方向。
论文题目：Graph Neural Networks in Recommender Systems: A Survey
详细解读：https://www.aminer.cn/research_report/6278882e7cb68b460fb3726d?download=falsehttps://www.aminer.cn/research_report/6278882e7cb68b460fb3726d?download=false
AMiner链接：https://www.aminer.cn/?f=cs
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c750537a510c7a552d699f40121980b/" rel="bookmark">
			ASCLL码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述： ASCII是American Standard Code for Information Interchange，是美国制定的一个关于用二进制数表示字符的标准，相当于ISO或者GB
特点： ASCII 码使用指定的7 位或8 位二进制数组合来表示128 或256 种可能的字符。标准ASCII 码也叫基础ASCII码，使用7 位二进制数来表示所有的大写和小写字母，数字0 到9、标点符号， 以及在美式英语中使用的特殊控制字符。
ascll:
大小规则：常见ASCLL码的大小规则：0~9 &lt; A~Z &lt; a~z
1）数字要比字母要小。
2）数字0比数字9要小。
3）字母A比字母Z要小。
4）同个字母的大写比小写字母要小32。如“A”&lt;"a" ，及常见字母ascll码的几个值。
"A" 为65 "a" 为97 "0"为48
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3078649e0637475f81c5a8994f33ff80/" rel="bookmark">
			解决Transformers ‘BertTokenizer‘ object is not callable
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因：transformer版本太低，低于3.0.0不能直接使用
# tokenizer = BertTokenizer.from_pretrained(model_path) tokenizer(raw_input, **kwargs) 直接卸载低版本transformers，安装大于3.0.0版本
pip install transformers==3.4.0 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a91bd1aa563b2a4a27f26f3b8d9e2d1a/" rel="bookmark">
			【EFCore】批量自定义列名、表名等等
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考：
https://www.cnblogs.com/myzony/p/9070998.html
部分代码如下 public class AppDbContext:DbContext { public AppDbContext(DbContextOptions&lt;AppDbContext&gt; options) :base(options) { } public DbSet&lt;Student&gt; Student { get; set; } protected override void OnModelCreating(ModelBuilder builder) { base.OnModelCreating(builder); foreach (var entity in builder.Model.GetEntityTypes()) { // 覆写表名 //entity.SetTableName(entity.GetTableName()); // 覆写列名 foreach (var property in entity.GetProperties()) { property.SetColumnName(property.GetColumnName().ToSnakeCase()); } foreach (var key in entity.GetKeys()) { key.SetName(key.GetName().ToSnakeCase()); } foreach (var key in entity.GetForeignKeys()) { key.SetConstraintName(key.GetConstraintName().ToSnakeCase()); } foreach (var index in entity.GetIndexes()) { index.SetDatabaseName(index.GetDatabaseName().ToSnakeCase()); } } } } //统一变成小写，属性className到数据库变成字段class_name，按需求调整代码 public static class StringExtensions { public static string ToSnakeCase(this string input) { if (string.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a91bd1aa563b2a4a27f26f3b8d9e2d1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d2df9cb6a3fb385e01cf42a41e8e7fb9/" rel="bookmark">
			扫雷游戏（实现了网页版的扫雷游戏的所有逻辑）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 扫雷游戏的逻辑game.htest.c游戏菜单游戏逻辑主函数 game.c初始化棋盘打印棋盘设置雷计算该坐标周围有几个雷排雷简易版 进阶版1.实现标记功能2.实现游戏刚开始炸一片功能和输入坐标周围没有雷也炸一下炸一片功能的实现 扫雷游戏的逻辑 今天我们要实现的是扫雷游戏，实现9X9的棋盘，
但是值得注意的一点是，当排雷坐标在1 1 的时候该如何知道这个坐标旁边有几个雷呢？（当选择这个坐标时，看其周围8给坐标是否有雷——&gt;（排雷））
为了使在边缘的坐标也可以检测周围8个坐标是否有雷的时候，所以我们的棋盘需要是11X11的
game.h 这里放的是我们的头文件
#include&lt;stdio.h&gt; #include&lt;time.h&gt; #include&lt;stdlib.h&gt; #define ROW 9 #define COL 9 #define ROWS ROW+2 #define COLS COL+2 //这里定义的是我的10个雷 #define Easy_count 10 //初始化棋盘 void Initboard(char board[ROWS][COLS], int row, int col,char set); //打印棋盘 void Displayboard(char board[ROWS][COLS], int row, int col); //设置雷 void Setmine(char board[ROWS][COLS], int row, int col); //排雷 void Changemine(char mine[ROWS][COLS],char show[ROWS][COLS], int row, int col); test.c 游戏菜单 void meum() { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d2df9cb6a3fb385e01cf42a41e8e7fb9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cee750f4af2f4019d7b7e68046a50219/" rel="bookmark">
			js中的闭包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是闭包：
闭包是javascript中的一个重要知识点，面试经常问到，需要我们熟练掌握。根据javascript高级程序设计中解释：闭包是指有权访问一个函数作用域中局部变量的函数。
要认知闭包，就要知道js中有两种作用域：全局作用域，局部作用域，与之对应的是全局变量和局部变量。我们都知道在函数内部中可以访问到全局作用域中的全局变量，但是在全局作用域中一般却无法访问某个函数的局部变量。为了解决这个问题，我们必须知道闭包。
2.闭包展示：
先来个简单的吧
&lt;script&gt; function fn () { var name = 'zs' function fon () { console.log(name); } fon() } fn() // zs &lt;/script&gt; 上述代码就用到了闭包，且听我慢慢道来：首先定义了fn函数，在函数内部声明name变量和定义了fon函数。当执行fn（）时，fon函数中的name会读取fn函数中的name，最后打印zs。即在fon函数中可以访问fn这个局部作用域中的局部变量name。这就是闭包的优势，但凡事都有两面性，有优必有缺（会导致内存泄漏）。
再来
&lt;script&gt; function fn () { var name = 'zs' function fon () { console.log(name); } return fon; } var f = fn() f(); // zs &lt;/script&gt; 上述代码同样用到了闭包。执行f()打印zs，该过程是在外部就访问到了函数内部的变量。不难看出，闭包的作用之一是延长了局部变量的作用域范围。
再如：
&lt;script&gt; // 闭包 function fn() { var arr = []; for(var i=0;i&lt;5;i++) { arr[i] = function() { return i; } } return arr } var list = fn() for(var i =0;i&lt;list.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cee750f4af2f4019d7b7e68046a50219/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9284d3c9a131b633c6b285e1baa4dbff/" rel="bookmark">
			找不到 raw.githubusercontent.com 的服务器 IP 地址-有效解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题描述 打开网站提示：找不到 raw.githubusercontent.com 的服务器 IP 地址。
解决办法 一些论坛、博客说是ping raw.githubusercontent.com ,获得IP地址后，添加到hosts文件，但是DNS都找不到对应的IP，所有一般你也ping不通，原因就是你当地DNS服务器没有更新到这条记录。
第一步：查找githubusercontent.com注册的DNS服务器地址 百度搜索域名Whois查询，这里用阿里云平台进行域名查询：https://whois.aliyun.com/
结果如下：
发现githubusercontent.com域名注册在黄框中的DNS服务器上，这里以DNS7为例，尝试ping DNS7服务器：
第二部：修改本地网络DNS服务器地址 将获取到的DNS7 服务器地址：205.251.199.75 固定到本地网络：
使用命令：ipconfig /flushdns 刷新本地DNS缓存；
再次尝试ping raw.githubusercontent.com ,发现可以获取到IP地址，并ping通;（因为服务器在国外，因此网络不稳定，有丢包现象）
验证问题是否解决 重新刷新报错页面，发现已经可以正常访问网站内容；
因为我是直接访问的raw.githubusercontent.com上的文件，通过迅雷下载网站上的文件，发现也是可以正常下载的；
END! 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1360c873412600c511cc87b235d5ced3/" rel="bookmark">
			连锁门店收银系统源码之要货管理--进销存功能逻辑解析03
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		连锁多门店收银系统源码之要货管理--进销存逻辑解析03
一，连锁多门店收银系统源码的要货管理综述
1，下级连锁门店（直营店或加盟店）在需要进货时，向总部操作“要货申请”
2，连锁总部负责处理下级门店的要货申请
二，连锁商户（总部），要货管理列表页面预览
三，下级连锁门店，申请要货的列表页面预览
四，下级连锁门店操作要货申请
1，第一步，点击“要货申请”后，进入要货申请单的填写页
（1）确认要货单的基础信息
（2）填写要货商品清单及要货数量，同时确认门店的可用库存及本次要货商品的“要货单位”
（3）要货申请须知：
只能选择总部端所有已上架的商品
总部审核通过并成功出库后，门店在“要货申请”列表下，操作“要货入库”
要货入库时，可将与总部不同步的商品的spu/sku资料，一键同步至门店商品列表
（4）选择要货商品的弹窗交互样式
2，第二步，提交要货申请单后，可在要货申请列表或要货单详情，查看要货单的详情记录
要货单详情中，将展示要货单的实时状态，以及要货商品的详情。
3，要货单的作废
针对本门已向总部提交的要货单，如要货单状态为“申请中”时，如果发现单据有误或计划有变，可在要货单列表，或要货单详情，操作“作废”。单据作废后可重新向总部发起要货申请。
4，门店操作“要货入库”
门店操作要货申请后，等待总部审核通过并成功出库，总部要货出库后，门店在收到总部发的货品后，可在要货申请单列表或要货申请单详情，操作“要货入库”
在要货申请单详情，可确认本次实际入库数量，如实际收货数量和单据中单实际入库量无误，可操作“确认入库”。
5，确认入库后，本次申请的商品库存将实时增加至门店库存。门店可至“库存查询”或“库存明细”列表查看本次入库明细。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80280110f83ad317cc92491ec39a54e6/" rel="bookmark">
			Jupyter notebook添加torch环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用jupyter notebook的时候突然发现我没有给它配置torch的环境，于是查了一下怎么配置，这里记录一下
**第一步：**打开anaconda，选择你需要的环境
**第二步：**找到jupyter notebook，如果没有安装的话需要install一下，就是下面这个图，安装好之后，如图三，表示已经安装好了
第三步：打开win键，点击之后就可以在浏览器上看到了
第四步：测试环境是否配置好了
好啦，成功。
看的这个博主的文章进行配置的：https://blog.csdn.net/qq_37388085/article/details/107995147
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0030ef53f61a7685d2d3fbbe6df65f6f/" rel="bookmark">
			PFPL概念归纳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		总结形式化语言的相关概念。源自于教材Practical Foundations for Programming Languages。这个总结作为辅助阅读资料，无法代替教材本身。
Chapter1: Abstract Syntax 抽象语法。用树状结构表达。书中的内容不关注具体的语法，仅仅关注语法片段（句法）对应的树，以及树中的标识符（类似于变量）的绑定关系（类似于变量的赋值）。这本书主要关注语法的结构化信息，对于语法最后是如何用字符串表达的并不关心。
abstract syntax tree。 抽象语法树，经常用 a a a表示。叶子被称作variables，非叶节点（内部节点）被称作operators。
sort。语法树的类型。不同类型的语法树对应不同形式的语法。比如SQL语句和一般的C++编程是用的不同的语法。经常用 s s s表示。经常用 S S S表示sort的集合。
variable。未指定的或者通用的语法片段。一个未知的占位符，其具体的含义与其替代者有关。经常用 x x x表示。用 χ \chi χ表示集合。用 χ s \chi_s χs​表示对应类型的所有变量的集合。我们可以使用 A [ χ ] = { A [ χ ] s ∈ S } A[\chi]=\{A[\chi]_{s \in S}\} A[χ]={A[χ]s∈S​}来代表类型为 s s s的语法树，这个语法树中的变量是类型 s s s的、以及所有operator在连接不同子树之后也是类型 s s s的。当然，也可以使用 A [ χ 1 , χ 2 ] A[\chi_{1}, \chi_{2}] A[χ1​,χ2​]来并联多个集合。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0030ef53f61a7685d2d3fbbe6df65f6f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/98f4121cef4d216bc132c2631f279ce1/" rel="bookmark">
			Bean实例化的三种方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.无参构造实例化
在配置文件中配置
&lt;bean id="userDao" class="Wss.dao.impl.UserDaoImpl" scope="singleton" init-method="init" destroy-method="destory"&gt;&lt;/bean&gt; 测试代码：
public class SpringTest { public static void test1(){ // ApplicationContext app =new ClassPathXmlApplicationContext("applicationContext.xml"); ClassPathXmlApplicationContext app =new ClassPathXmlApplicationContext("applicationContext.xml"); UserDao userDao1 = (UserDao) app.getBean("userDao"); // UserDao userDao2 = (UserDao) app.getBean("userDao"); System.out.println(userDao1); // System.out.println(userDao2); // app.close(); } 运行结果：
2.工厂静态方法实例化
同1：
&lt;bean id="userDao" class="Wss.factory.StaticFactory" factory-method="getUserDao"&gt; &lt;/bean&gt; package Wss.factory; import Wss.dao.UserDao; import Wss.dao.impl.UserDaoImpl; public class StaticFactory { public static UserDao getUserDao(){ return new UserDaoImpl(); } 测试与结果同1
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/98f4121cef4d216bc132c2631f279ce1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcda14d588b27a4dfa0ee916112bf3e4/" rel="bookmark">
			SOP论文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Striving for Simplicity and Performance in Off-Policy DRL: Output Normalization and Non-Uniform Sampling
复现代码
1原理 Streamlined Off Policy (SOP)， 使用简单的方法实现了新的SOTA，性能超越SAC。并比SAC更加简单实现。
简单的两个tricks是
Policy的原始输出 u k u_k uk​经过Normalization后再过Squashing t a n h ( u k ) tanh(u_k) tanh(uk​)，在TD3中，policy model output是超过 a t a_t at​的范围之外，经过tanh的挤压在有限的动作区间后 a t a_t at​值在最大的边界附近，添加explore noise也难以改变边界的输出。而SAC的最大熵policy可以缓解这一问题。作者简单使用Normalization实现了同样的性能。 G = ∑ k ∣ u k ∣ / K k = 1 , 2 , . . . , K u k ⟵ u k / G i f G &gt; 1 G=\sum _k\left | u_k \right |/ K \quad k=1,2,.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcda14d588b27a4dfa0ee916112bf3e4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/982269d5fb76be9367bff59703310b04/" rel="bookmark">
			Paying More Attetion to Attention:Improving the Performance of Convolutional Neural Networks via AT
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Paying More Attetion to Attention:Improving the Performance of Convolutional Neural Networks via Attention Transfer 论文阅读
Sergey Zagoruyko, Nikos Komodakis 2017 ICLR
摘要 （1）正确定义CNN的注意力，然后使用这种类型信息去迫使学生网络模仿强大的教师网络，从而极大改进学生网路性能。
（2）通过改进各种数据集和CNN网络架构，提出几种新颖的转移注意力的方法。
引言 人类为了充分认知环境需要注意，注意力是视觉经验和与感知密切相关的关键方面。人工注意力让系统更“关注”一个对象，从而获得更多细节。注意力就像心理学中的注意力，已成为理解CNN背后机制的研究工具。
非注意力和注意力感知过程的假设：
（1）非注意过程 有助于观察一般场景并获得高层信息，与其他思维方式相关联，可帮助我们控制注意力过程并定位到场景的某个部分，这表示具有不同知识、不同目标、不同策略的不同观察者能从字面上以不同方式看同一场景。引出本文主题：人工视觉系统的注意力有何不同，我们能用注意力信息改进网路性能么？总而言之，教师网路能否通过向学生网络提供其外观信息来提高学生网络性能？
本文将注意力视为一组空间图，通过编码网络最关注的空间区域来决定其输出（e.g.图像分类）这些图跟网络各个层有关，所以可以捕捉低、中、高层表示信息。本文定义两种空间注意图：activation-based 和 gradient-based
本文工作
1.提出一种将注意力作为知识从一个网络转移到另一个
2.提出使用activation-based 和 gradient-based的空间注意力图
3.在多个数据集和深度网络结构（残差或非残差）验证了本文方法的性能提升
activation-based注意力转移比full-activationtransfer更好，并且能与知识蒸馏(KD)结合
相关工作 早期工作 Larochelle &amp; Hinton (2010), Denil et al. (2012)受人类注意力机制理论 Rensink (2000) 启发，并通过受限波兹曼机（Restricted Bolz-mann Machines）完成。使用RNN在神经机器翻译与其他NLP任务相当 e.g. Bahdanau et al. (2014)。计算机视觉相关任务也进行了探索如image captioning Xu et al. (2015), visual question answering Y ang et al.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/982269d5fb76be9367bff59703310b04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14ffc8173b1e1813df61a5af78960bae/" rel="bookmark">
			HighLight组件封装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.思路： 自己在写HighLight组件的时候，是这样的思想：比如说有这么一段字：’王宝强好帅’，高亮词是[‘宝强’,’帅’]，那么我就去遍历这个数组，将数组的元素去匹配文本，将’宝强’和’帅’替换为&lt;span&gt;宝强&lt;/span&gt;和&lt;span&gt;帅&lt;/span&gt;，最后的结果就是得到这样一个字符串’王&lt;span&gt;宝强&lt;/span&gt;好 &lt;span&gt;帅&lt;/span&gt;’，再用div包裹一下，最后再通过div的dangerouslySetInnerHTML属性就可以将一个被div字符串包裹的文本变为一个react.element类型的数据了，我们就可以对span标签的样式进行修改了。代码如下：
import React from 'react'; type HighLightProps = { content: string; highLightWords: string[]; color: string; }; const HighLight: React.FC&lt;HighLightProps&gt; = ({ content, highLightWords, color, }) =&gt; { function spliceContent() { // 对数组进行排序，eg：['宝强','王宝强']转为['王宝强','宝强']。因为['宝强','王宝强']在进行高亮的时候【王宝强】三个字只有宝强二字才能够高亮 const highLightWordsSort = highLightWords.sort( (x: string, y: string) =&gt; y.length - x.length, ); if (highLightWordsSort.length === 0) { return &lt;div&gt;{content}&lt;/div&gt;; } else { let contentCopy = content; for (const ele of highLightWordsSort) { const reg = new RegExp(ele); contentCopy = contentCopy?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14ffc8173b1e1813df61a5af78960bae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ca8b792e7d015ff77ebe93f4fff68ed/" rel="bookmark">
			pytorch accuracy和Loss 的计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近学习代码时发现当自己去实现代码的时候对于样本的Loss和accuracy的计算很不理解，看别人的代码也是靠猜测，所以自己去官方文档学习加上自己做了个小实验以及搜索了别人的博客，总是算明白了怎么回事，所以打算写下来记录（纯粹记录，无参考意义）
accuracy 计算 关于accuracy的计算：acc=正确个数 / 样本总数我们知道，经过模型的输出的最后的一个结果是通过一个softmax算法的出来的，也就是说，输出的给过给出了这个模型对于每个类别的概率预测（且所有概率相加等于1），概率最大的类别也就是模型预测出的类别（插一句：那么我们可能遇到这样的情况，有几个类别预测的概率相差不大，最终结果是那一个比其他类大一点的结果，那其实这个时候表示模型的泛化性能很不好，所以对于网络的评价Loss是最好用的）；那么首先我们要做的是要将预测结果最大概率的标签（类别）提取出来，这里我给出一个例子：
a = torch.tensor([[0.03,0.12,0.85], [0.01,0.9,0.09], [0.95,0.01,0.04], [0.09, 0.9, 0.01]]) print(a) print(a.dtype) 我假设有一个经过模型输出的结果，现在我们需要提出最大概率的结果
我们用torch.max()函数打印了结果，可以看到，输出的是最大类别的概率以及对应索引（即类别），但是我们只要索引，所以取第二个元素predicted=torch.max(output.data, 1)[1]，解释代码：这里第一个1表示求行的最大值因为每一行代表了一个样本的输出结果，第二个1代表了我们只要索引，还有另一种方法：predicted=torch.argmax(output, 1)，torch.argmax()函数：求最大数值的索引
接下来我们需要计算预测正确的个数：correct += (output == labels).sum().item()，首先，“outpuut == labels” 的语法求出正确的类，类似于[1, 0, 1, 0]，1表示预测正确，0表示错误，然后 .sum()将所有正确的预测加起来，得到预测正确的个数，torch.item()，这时候输出的是一个tensor类，比如有两个预测正确：tensor(2)，.item() 语法将tensor转化为普通的float或者int，
最后total += label.size(0)，求出样本总数：那么acc = correct / total，得出精度
Loss的计算 现在的框架大多是采用的是Minibatch梯度下降法，一般在进行Loss的计算我们都是用的交叉熵损失函数计算损失比如 CrossEntropyLoss()，其实，这个函数求出的是每次minibatch的平均损失，那么当我们将每次Minibatch损失加起来后需要除以的是step（即步长），数据的分批次计算采用的是torch.utils.data.DataLoader()函数，那么就需要步长就是len(Loadr)，用最终的总Loss除以len(Loader)，这就是Loss计算
下面会给出个人的代码全部（口说无凭，且不太好理解）
from torchvision import transforms from torchvision.datasets import ImageFolder import torchvision import torch.nn as nn import torch from tqdm import tqdm import sys def train(lr, weight_decay, num_epochs): device = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ca8b792e7d015ff77ebe93f4fff68ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e869125b1ca762e25300e5cff495c6a/" rel="bookmark">
			OpenCV入门（九）——图像分割技术之分水岭分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
0x01 分水岭分割
0x02 分水岭分割合并
图像分割是利用图像特征灰度、颜色、纹理和形状等将图像中特定的具有独特性质的区域进行划分，进而实现感兴趣的目标的提取。根据分割成因可以分为连续分割和非连续分割。连续分割是指将具有同一灰度级或相同特征的像素划分为不同区域，常见的分割方法有区域生成、阈值分割及聚类分割等。非连续分割是利用像素值突变特性来呈现不同边界区域以实现图像分割，常见的分割方法有点线检测、边缘及能量等。
0x01 分水岭分割 （一）分水岭分割
分水岭分割是基于自然的启发算法来模拟水流通过地形起伏的现象从而研究总结出来的一种分割方法，其基本原理是将图像特征看作地理上的地貌特征，利用像素的**灰度值分布**特征，对每个符合特征的区域进行划分，形成边界以构成**分水岭**。分水岭分割的图像被认为是地形起伏，其中所述梯度大小被解释为**高度**相关信息。对于分水岭算法中的图像像素点，一般需要关注下面三种特征点：
（1）局部最值点：这类点反映的是图像中的局部最小值点或局部最大值点。
（2）交汇边缘点：这类的产生是由于灰度不均匀变化，对应于分水岭中不同地域形成的交接点。
（3）连接区域点：通过局部最小值的像素点向外慢慢扩展，集水区间内的像素点会承担连接作用，同时水域流向会通过连接区域点留到局部最小值的点。
分水岭算法是一种很好的分割相互接触的物体图像的方式，但在边缘分割时精度却存在一定问题，比如在实际应用过程中会出现由于噪点过多，或者其他信息的干扰，会导致局部极值点过多，那么图像分割就难以实现。对于图像某些小区域的背景与前景分割将意味着会有更少的交汇边缘点，这样容易造成过分隔现象，常用的解决方法是合并视觉上的小区域部分，将其视为独立部分进行分割操作。
（二）实现分水岭分割
在计算机视觉中我们常常关注的目标特征是**颜色**和**灰度**，其实也有很多其他的方法比如形状描述子、颜色特征、距离特征等。对于某种场景下的应用，具有独特的纹理对象可以使用一个很好的纹理描述符。针对颜色不同的区域中的单个对象相同的扩展，我们可以使用颜色特征来测量对象的不同部分的相似性。
实现使用图像距离变换来实现分水岭分割算法：对源图像进行灰度化，使用OTSU进行二值化操作。对二值化图像进行形态学开操作。利用distanceTransform完成图像距离变换操作。归一化距离变换的统计图像，并计算相应连通域分割块。 代码如下：
#include &lt;iostream&gt; #include &lt;string&gt; #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "opencv2/core/core.hpp" #include "opencv2/core/utility.hpp" #include "opencv2/imgproc/imgproc.hpp" #include "opencv2/imgcodecs.hpp" #include "opencv2/highgui/highgui.hpp" #include &lt;opencv2/imgproc/imgproc_c.h&gt; #include &lt;opencv2/opencv.hpp&gt; using namespace cv; using namespace std; cv::Mat displaySegResult(cv::Mat&amp; segments, int numOfSegments) //, cv::Mat&amp; image { cv::Mat wshed(segments.size(), CV_8UC3); // 创建对于颜色分量 vector&lt;Vec3b&gt; colorTab; for (int i = 0; i &lt; numOfSegments; i++) { int b = theRNG().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e869125b1ca762e25300e5cff495c6a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b6b04744dbaf6ea456213c1c632c94af/" rel="bookmark">
			【Azkaban报错解决】FAILED: SemanticException Failed to get a spark session
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		问题描述： ods_to_dwd_log报以下错误
ods_to_dim_db报一下错误
可以看出都是相同报错，无法创建spark事务
Logging initialized using configuration in jar:file:/opt/module/hive/lib/hive-common-3.1.2.jar!/hive-log4j2.properties Async: true 05-05-2022 14:31:02 CST ods_to_dim_db INFO - Hive Session ID = 77b1dd10-3b70-44b7-8c41-96571c4a00c2 05-05-2022 14:31:04 CST ods_to_dim_db INFO - No Stats for gmall@ods_user_info, Columns: birthday, login_name, gender, create_time, nick_name, name, user_level, phone_num, id, email, operate_time 05-05-2022 14:32:36 CST ods_to_dim_db INFO - FAILED: SemanticException Failed to get a spark session: org.apache.hadoop.hive.ql.metadata.HiveException: Failed to create Spark client for Spark session 6115db31-a456-4b8a-bd68-2b9defe20b95 05-05-2022 14:32:37 CST ods_to_dim_db INFO - Process with id 32405 completed unsuccessfully in 102 seconds.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b6b04744dbaf6ea456213c1c632c94af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd6472b21daabdb6617d2b6391ff87bc/" rel="bookmark">
			hiveservice2安装问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		hiveservice2常见安装问题 提示：这里项目是学习安装hive时遇到的问题
看过网上很多的安装hiveservice2的问题，自己做个小总结第一个就是网上常说的问题，没有添加自己的Hadoop主机名亦或者root账户，然后就会报下面的错误
问题1：Error: Could not open client transport with JDBC Uri: jdbc:xxxx://hadoop1:10000 老师常说遇到报错不要怕，勇往直前
Error: Could not open client transport with JDBC Uri: jdbc:hive2://hadoop1:10000: Failed to open new session: java.lang.RuntimeException:org.apache.hadoop.ipc.RemoteException(org.apache.hadoop.security.authorize.AuthorizationException): User: root is not allowed to impersonateanonymous (state=08S01,code=0)
错误主要问题，root账户没有添加进去 root is not allowed to impersonateanonymous (state=08S01,code=0) 当时我只添加了Hadoop主机名，而hive也需要root权限来进行操作
解决这个问题就是把主机名以及root都添加进去，它就不会报错了。网上一般都是添加一个，记录一下不一样。修改配置要在core-site.xml文件，不要添加错了
问题2：Error: Could not open client transport with JDBC Uri: jdbc:xxxx://hadoop1:10000 由于需要创建个文件给hive存储临时数据，此问题是提示权限不足
Error: Could not open client transport with JDBC Uri: jdbc:hive2://hadoop1:10000: Failed to open new session: java.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dd6472b21daabdb6617d2b6391ff87bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88556863b76f3af01dc1dd05f01557c6/" rel="bookmark">
			Git将远程强制同步到本地
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Git将远程强制同步到本地 有时候不小心将本地代码修改后，会有将远端的代码强制同步到本地的需求，这个时候有很多人会选择删除之后重新将远程仓库的内容clone下来，其实有更好的办法来解决这种问题。
正确的做法应该是：
git fetch --all git reset --hard origin/master git fetch 只下载远程仓库的内容，不做任何的合并，git reset 把HEAD指向刚刚下载的最新版本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a6a7098b76b95919cea3fd8cf09bc80c/" rel="bookmark">
			项目打包总是出错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、uni-app的项目，打包h5可以，打包小程序的时候出现有些文件缺失的情况，例如引用到的组件是在node_modules里面的，查看打包后的小程序代码，确实那部分代码没有打包进来，看了一下node_modules里面的文件结构有点乱，很多下划线_开头的文件，原来是使用cnpm install淘宝镜像安装依赖包导致的，重新切换源
// 查看当前镜像 nrm ls // 切换镜像 nrm use npm 然后使用npm install来安装，问题居然解决了，感觉淘宝镜像安装依赖包有些未知的问题。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0583eeae65385033e087b436435875a9/" rel="bookmark">
			2-1 Python-求最大值及其索引
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本题要求编写程序，找出给定的n个数中的最大值（如果有多个最大值，只找第一个）及其对应的正向索引。
输入格式: 在第一行输入若干个整数，用空格分隔。
输出格式: 在一行中输出最大值及最大值的索引，中间用一个空格分开。
样例"&gt;样例"&gt;样例"&gt;样例"&gt;样例"&gt;样例"&gt;样例"&gt;样例"&gt;样例"&gt;样例"&gt;输入样例: 在这里给出一组输入。例如：
2 8 10 1 9 10 输出样例: 在这里给出相应的输出。例如：
10 2 知识点：
input：输入
print：输出
split：分割函数，可以把输入的内容按一定的元素分隔开(例：split（“ ，”），即用逗号隔开)
map：函数 map ()是 Python 内置的高阶函数，它接收一个函数 f 和一个 list，并通过把函数 f依次作用在list的每个元素上，map ()函数会返回一个迭代器，可以依次迭代得到原来list的元素被函数f处理后的结果。（例如： map (f, list) ，对于list [1, 2, 3, 4, 5, 6, 7, 8, 9]。）
max：寻找最大值并返回
list：列表，所有元素放在一个方括号中，元素之间用逗号隔开，其中元素可以是任意类型
index（x）：返回第一个值为x的坐标，若不存在值为x的元素，则抛出异常
a = list(map(int,input().split())) #输入若干个整数，用空格分开并存入列表a b = max(a) #b为列表a中的最大值 c = a.index(b) #最大值的下标 print(b, c) #输出 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a85f06889cde32849d71a3db60707e0/" rel="bookmark">
			深入理解python中的切片
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		切片的基本使用
sequence[start:stop:step]
start：切片的起始索引，它将包括此索引处的元素，除非它与 stop 相同，默认为 0，即第一个索引。
stop：切片的结束索引，它不包括此索引处的元素，默认为被切片序列的长度，即直到并包括结束。
step：步长，默认为 1。如果它是负数，则从后往前进行切片。
省略开始索引时，默认值为 0，省略结束索引时，默认为到字符串的结尾
同样支持负数的索引，标号从最后一个元素往前依次为-1,-2,…
根据步长的正负的不同，切片表示将有所差异：
[a:b:c]
len = length of string, tuple or list
c – default is +1. The sign of c indicates forward or backward, absolute value of c indicates steps. Default is forward with step size 1. Positive means forward, negative means backward.
a – When c is positive or blank, default is 0. When c is negative, default is -1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a85f06889cde32849d71a3db60707e0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a8a8200588b17b0081f8867b9b526e1b/" rel="bookmark">
			shell脚本的基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Shell脚本概述 1.1Shell基本概念 将要执行的命令按顺序保存到一个文本文件
给该文件可执行权限
可结合各种Shell控制语句以完成更复杂的操作
1.2 Shell脚本应用场景 重复性操作
交互性任务
批量事务处理
服务运行状态监控
定时任务执行
1.3 Shell作用——翻译官 shell是一个特殊的应用程序，它介于操作系统内核和用户之间，充当了一个“命令解释器”的角色，负责接收用户输入的操作指令并进行解释，将需要执行的操作传递给内核执行，并输出执行结果。
二、shell编程规范 2.1 用户登录shell 登录后默认使用的shell程序，一般为/bin/bash
不同shell的内部指令、运行环境等会有所不同
shell说明sh已经被bash所替换（软链接）bash是基准于GNU的框架下发展出的shelltcsh整合了csh，提供更多的功能（增强版）csh语法有点类似于C语言的shellnologin奇怪的shell，这个shell可以让用户无法登录主机 2.2 shell 脚本的概念 1、将要执行的命令按顺序保存到一个文本文件
2、给该文件可执行权限
3、可结合各种Shell控制语句以完成更复杂的操作
总结:将需要执行的命令保存到一个文件中，按照顺序执行，它不需要编译，它是解释型的
2.3 shell脚本解释器 有dash和bash两种，但dash没有bash功能全面，所以通常使用bash。
可以通过命令来查看系统中的脚本解释器： ls -l /bin/*sh
2.4 shell 脚本的应用场景 ①重复性操作
②交互性任务
③批量事务处理
④服务运行状态监控定
⑤时任务执行
2.5shell 脚本的作用 自动化完成软件的安装部署，如安装部署LAMP架构服务
自动化完成系统的管理，如批量添加用户
自动化完成备份，如数据库定时备份
自动化的分析处理，如网站访问量
2.6 编写脚本代码 使用vim文本编辑器
每行一条Linux命令，按执行顺序依次编写
脚本后缀为.sh
第一行为 “#!/bin/bash” ,脚本申明（默认解释器)：
表示此行以下的代码语句是通过 /bin/bash 程序来执行。
还有其他类型的解释器，比如#!/usr/ bin/python、#!/usr/bin/expect
注释信息:以”#“开头的语句表示为注释信息，被注释的语句在脚本运行时不会被执行可执行语句:如echo命令，用于输出"“之间的字符串
创建 shell 程序的步骤：
第一步: 创建一个包含命令和控制结构的文件。
第二步: 修改这个文件的权限使它可以执行#使用chmod +x xxx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a8a8200588b17b0081f8867b9b526e1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/710bae9c4bba8dfa719c7e5189a30f1a/" rel="bookmark">
			Java两种调用sap的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、写一个SDK供外部进行调用
1.用idea的工具通过提供的wsdl文件生成java文件。
将wsdl文件放入项目中，然后通过这个idea自带的工具就可以生成所需的java代码。
2.将生成的文件进行分类、分层级进行存放。
生成的文件都在一个包里，为了更方便的管理，严格按照层级与类型进行存放。
3.生成client与clientImpl文件，提供接口给外部调用，然后实现类进行webService调用。
@WebService(name = "SI_BatchInStock_Out_Syn", targetNamespace = "urn:newhopedariy.cn:MILK:MM:Outbound") @SOAPBinding(parameterStyle = SOAPBinding.ParameterStyle.BARE) @XmlSeeAlso({ BatchInStockFactory.class }) public interface SIBatchInStockOutSyn { /** * @param parameters * @return returns mypackage.ZMMBATCHINSTOCKResponse */ @WebMethod(operationName = "SI_BatchInStock_Out_Syn", action = "http://sap.com/xi/WebService/soap1.1") @WebResult(name = "ZMM_BATCH_IN_STOCK.Response", targetNamespace = "urn:sap-com:document:sap:rfc:functions", partName = "parameters") public ZMMBATCHINSTOCKResponse siBatchInStockOutSyn( @WebParam(name = "ZMM_BATCH_IN_STOCK", targetNamespace = "urn:sap-com:document:sap:rfc:functions", partName = "parameters") ZMMBATCHINSTOCK parameters); } 生成的文件中有一个后缀为Syn的文件，这个文件就相当于sap提供的API，本SDK的主要作用就是调用此API，其他服务就不需要再一次搭建这个连接进行调用了。
自行定义一个client文件，提供给其他服务来调用这个SDK。
clientImpl文件进行调用的基础设置的拼装，并且获取连接，最后调用sap提供的API接口。作为一个SDK可以将返回参数进行一个简单的封装，类似于 状态码+result的方式，其他服务更方便确认调用是否成功。
基础设置：
private void bashInit(LocalAuthenticator localAuthenticator) { Authenticator.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/710bae9c4bba8dfa719c7e5189a30f1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4d3809423f947f3688d805fa18d90e70/" rel="bookmark">
			Linux文本三剑客——awk、sed、grep
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文本三剑客 一、grep——文本过滤工具二、sed——编辑器输出符合条件的文本删除符合条件的文本替换符合条件的文本迁移符合条件的文本 三、awk——报告生成器按行输出文本 按字段输出文本通过管道、双引号调用Shell命令 扩充 一、grep——文本过滤工具 文本过滤器（模式：pattern）工具，grep,egrep（不支持正则表达式搜索）
grep [选项] 条件 目标文件 选项作用–color=auto对匹配到的文本着色显示-v显示不被pattern匹配到的行-n显示行数-c统计匹配到的行数-o仅显示匹配到的字符串 二、sed——编辑器 sed [选项] ‘操作’ 参数 sed [选项] -f scripfile 参数 选项作用-e script ：指定sed编辑命令-f scriptfile ：指定的文件中是sed编辑命令-h ：显示帮助-n ：表示仅显示处理后的结果-i ：直接编辑文本文件-r, -E使用扩展正则表达式-s将多个文件视为独立文件，而不是单个连续的长文件流 操作作用a ：增加，在当前行下面增加一行指定内容c ：替换，将选定行替换为指定内容d ：删除，删除选定的行i ：插入，在选定行上面插入一行指定内容p ：打印s ：替换，替换指定字符y ：字符转换 输出符合条件的文本 输出第三行
sed -n ‘3p’ test.txt 输出第3-5行
sed -n ‘3,5p’ test.txt 输出所有奇数行
sed -n ‘p;n’ test.txt 输出所有偶数行
sed -n ‘n;p’ test.txt 输出第1-5行之间的奇数行
sed -n ‘1,5{p;n}’ test.txt 输出第10行之后的偶数行
sed -n ’10,${n;p}’ test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4d3809423f947f3688d805fa18d90e70/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/59d678dee25c89f99a4fca718f1166d9/" rel="bookmark">
			大文件分片上传、断点上传
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		因为一个政府项目需要上传影像tif文件，文件大小超过20g，以往的上传肯定是不行的，一旦失败就要从头开始，所以了解了分片上传。
分片上传： 分片上传就是将文件分成一个个小块去上传，上传完成之后再将这些文件按顺序合成起来。这里我用来进行分片的组件是百度开源的webuploader,这个组件依赖于jquery
断点上传： 断点上传就是上传分片之前检查分片文件是否存在，如果存在就不再上传。
上后端代码： `private static final String tifPath = “D:/uploadTiff”;
public static Map&lt;String, Integer&gt; riskmap = new HashMap&lt;String, Integer&gt;();
public static ExecutorService fixedThreadPool = Executors.newFixedThreadPool(6);
@RequestMapping(value = “uploadTiff”)
@Transactional(rollbackFor = Exception.class)
public ResResult uploadTiff(@RequestParam(“file”) MultipartFile file, HttpServletRequest request,
HttpServletResponse response) throws IOException {
//判断文件是否为空 if(file.isEmpty()){ return new ResResult(StatusCode.REQUEST_CODE_BAD,"空文件"); } //接收request参数 Integer chunk = MyUtil.convertToInt(request.getParameter("chunk"),0);//当前分片 Integer chunks = MyUtil.convertToInt(request.getParameter("chunks"),0);//总分片数 String name = MyUtil.convertToString(request.getParameter("name"));//文件名字 System.out.println("请求："+chunk); System.out.println("总分片："+chunks); try { String uploadDir = tifPath; File fileDir = new File(uploadDir); //创建目录 if (!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/59d678dee25c89f99a4fca718f1166d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60456593d51b07542747e14e06ea9de6/" rel="bookmark">
			Python中__init__.py文件的作用详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		init.py 文件 init.py 文件的作用是将文件夹变为一个Python模块,Python 中的每个模块的包中，都有__init__.py 文件。
通常__init__.py 文件为空，但是我们还可以为它增加其他的功能。我们在导入一个包时，实际上是导入了它的__init__.py文件。这样我们可以在__init__.py文件中批量导入我们所需要的模块，而不再需要一个一个的导入。
# package # __init__.py import re import urllib import sys import os # a.py import package print(package.re, package.urllib, package.sys, package.os) 注意这里访问__init__.py文件中的引用文件，需要加上包名。
init.py中还有一个重要的变量：** all **, 它用来将模块全部导入。
# __init__.py __all__ = ['os', 'sys', 're', 'urllib'] # a.py from package import * 这时就会把注册在__init__.py文件中__all__列表中的模块和包导入到当前文件中来。
可以了解到，init.py主要控制包的导入行为。要想清楚理解__init__.py文件的作用，还需要详细了解一下import语句引用机制：
可以被import语句导入的对象是以下类型：
模块文件（.py文件）C或C++扩展（已编译为共享库或DLL文件）包（包含多个模块）内建模块（使用C编写并已链接到Python解释器中） 当导入模块时，解释器按照sys.path列表中的目录顺序来查找导入文件。
import sys &gt;&gt;&gt; print(sys.path) # Linux: ['', '/usr/local/lib/python3.4', '/usr/local/lib/python3.4/plat-sunos5', '/usr/local/lib/python3.4/lib-tk', '/usr/local/lib/python3.4/lib-dynload', '/usr/local/lib/python3.4/site-packages'] # Windows: path列表 目录顺序 # 第一个元素空字符串代表当前目录 ['', 'C:\\WINDOWS\\system32\\python34.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/60456593d51b07542747e14e06ea9de6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15b4bc851e841594a94c919696f3d295/" rel="bookmark">
			用于文本去重（相似度计算）的Simhash算法学习及python实现（持续学习中）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Simhash算法学习及python实现 1. Simhash算法是什么？2.Simhash算法思想3.Simhash算法流程3.1 分词3.1.1 短文本的处理3.1.2 长文本的处理-基于TF-IDF的文本关键词抽取方法3.1.2.1 TF-IDF算法思想3.1.2.2 TF-IDF文本关键词抽取方法流程3.1.2.3 代码实现（待修改/实现） 3.2 hash3.3 加权3.4 合并3.5降维 4. SimHash签名距离计算4.1 什么是海明距离呢？4.2 大规模数据下的海明距离计算 5.大规模文本的去重5.1 抽风的第一次测试 参考文章 来源于众多文章的学习，将在文章末尾，集中附录出所有学习的文章 1. Simhash算法是什么？ 一段文字所包含的信息，就是它的信息熵。如果对这段信息进行无损压缩编码，理论上编码后的最短长度就是它的信息熵大小。
如果仅仅是用来做区分，则远不需要那么长的编码，任何一段信息（文字、语音、视频、图片等），都可以被映射(Hash编码)为一个不太长的随机数，作为区别这段信息和其他信息的指纹，只要Hash算法设计得好，任何两段信息的指纹都很难重复。
SimHash算法是Google在2007年发表的论文《Detecting Near-Duplicates for Web Crawling》中提到的一种指纹生成算法，被应用在Google搜索引擎网页去重的工作之中。
简单的说，SimHash算法主要的工作就是将文本进行降维，生成一个SimHash值，也就是论文中所提及的“指纹”，通过对不同文本的SimHash值进而比较海明距离，从而判断两个文本的相似度。
对于文本去重这个问题，常见的解决办法有余弦算法、欧式距离、Jaccard相似度、最长公共子串等方法。但是这些方法并不能对海量数据高效的处理。
比如说，在搜索引擎中，会有很多相似的关键词，用户所需要获取的内容是相似的，但是搜索的关键词却是不同的，如“北京好吃的火锅“和”哪家北京的火锅好吃“，是两个可以等价的关键词，然而通过普通的hash计算，会产生两个相差甚远的hash串。而通过SimHash计算得到的Hash串会非常的相近，从而可以判断两个文本的相似程度。
下面是查看simhash值的实例
from simhash import Simhash def get_Features(s): ''' 设置一个长度为3的滑动窗口，并只匹配数字英文加下划线，如输入'你好啊，今天真高兴': 返回['你好啊', '好啊今', '啊今天', '今天真', '天真高', '真高兴'] ''' width = 3 s = s.lower()#字符小写处理 s = re.sub(r'[^\w]+','',s)#删除非下划线或单词的字符 return [s[i:i + width] for i in range(max(len(s) -width + 1,1))] print(get_Features('How are you?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15b4bc851e841594a94c919696f3d295/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c05a002940f38ae3b2f041250411f007/" rel="bookmark">
			python if not的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 参考 python if not的用法 - 云+社区 - 腾讯云
if not (1 &gt; 2): #如果()中的表达式为假 print("hahaha") #1 &gt; 2结果是假,所以执行hahaha else: print("hihihi") Output: -------- hahaha -------- if not 1: #1为真,并不为假,因此不执行hahaha,执行hihihi print("hahaha") else: print("hihihi") Output: -------- hihihi -------- while(1): data = input() #输入数据 if not data: #如果data为假(即data为空) print("hahaha") else: #如果data不为空 print("hihihi") Output: ----------- hahaha 啊 hihihi ajkjshfjklsd hihihi hahaha hahaha hahaha hahaha ----------- 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/239/">«</a>
	<span class="pagination__item pagination__item--current">240/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/241/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>