<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8ca4f845466c0c306eb7b56f92f6209/" rel="bookmark">
			java代码转python代码（需要手动调整）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 （1）windows 环境安装工具
python版本.7
先下载antlr:
http://www.antlr3.org/download/antlr-3.1.3.tar.gz
链接: https://pan.baidu.com/s/1YX2ndOU-Km8pcx14mITNOw 提取码: a8hj
解压后，进入antlr-3.1.3\runtime\Python目录：
python setup.py install
（2）安装java2python
pip2 install java2python（python安装路径不能有中文，不然报错）
也可以github上下载:https://github.com/natural/java2python.git
（3）使用工具
在Python27\Scripts目录下会生成一个j2py文件，它其实是个python文件
cmd进入该目录下:
然后将一个已写好的java程序跟踪下面的命令后面：
python j2py your_java_file.java
*转化的代码只有相关的元素替换， 需要手动调整才能运行。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87e5b2e110f22ae3badac3195f9b7bc4/" rel="bookmark">
			golang 中的字符串转换为时间戳
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		toBeCharge := "2015-01-01 00:00:00" //待转化为时间戳的字符串 注意 这里的小时 和 分钟还要秒必须写 因为是跟着模版走 的 修改模板的话也可以不写
timeLayout := "2006-01-02 15:04:05" //转化所需模板
loc, _ := time.LoadLocation("Local") //获取时区
theTime, _ := time.ParseInLocation(timeLayout, toBeCharge, loc) //使用模板在对应时区转化为time.time类型
sr := theTime.Unix() //转化为时间戳 类型是int64
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2636e50a68073853bb751c7c3db897af/" rel="bookmark">
			JS通过.方法获取无限级 对象的值 【优雅解决方案】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果遇到不确定的层级，且需要取深层的对象的值的需求
在这里提供一种比较妥当的通用方法：
/* key:字符串 比如 “a.b.c” data:取值的对象 */ const getDeepVal = (key, data) =&gt; { return key.split('.').reduce((p, c) =&gt; { return p &amp;&amp; p[c]; }, data); }; 使用方式：
/* 定义方法 */ const getDeepVal = (key, data) =&gt; { return key.split('.').reduce((p, c) =&gt; { return p &amp;&amp; p[c]; }, data); }; let obj = { a: { b: { g: '我是凯神', }, d: '我是达摩', e: { f: '我是菩提', }, }, }; /* 使用 */ console.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2636e50a68073853bb751c7c3db897af/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/13df15c22484fd4e6a7725cf6849d96e/" rel="bookmark">
			JavaScript洗牌算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 概念 洗牌算法即是把一组数组里的元素随机组合生成一个新数组。
实现 const shuffle = ([...arr]) =&gt; { let m = arr.length; while (m) { const i = Math.floor(Math.random() * m--); [arr[m], arr[i]] = [arr[i], arr[m]]; } return arr; }; // 测试 const testArr = [1, 2, 3, 4, 5, 6, 7, 8] console.log('输出1：' + shuffle(testArr)) // 输出1：[4, 6, 7, 3, 1, 5, 2, 8] console.log('输出2：' + shuffle(testArr)) // 输出2：[6, 8, 2, 1, 7, 3, 5, 4] console.log('输出3：' + shuffle(testArr)) // 输出3：[1, 7, 5, 8, 2, 3, 4, 6] （完） 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8cc94134f83c2a5788e843a00b2703ba/" rel="bookmark">
			Visual Studio 2017的安装（搭建C&#43;&#43;开发环境）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 首先搜到这个网址：
https://blog.csdn.net/weixin_46432435/article/details/123920244
完成他让你完成的第一步。
2 双击“visual_studio_community_2017_version_15.3”这个文件
3 在蹦出如下界面时点击确定
4等待一段时间，就会出现如下界面，点击“使用C++的桌面开发”，接着点击右下角的安装
5安装完点击启动
6过一小段时间你会看到这样的界面这就说明安装完成了！
以下是codeblocks的安装教程网址（codeblocks也是一个C++的编译器）：https://www.onlinedown.net/article/10015881.htm
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3397c394d8670c6da36b1f341c311c5b/" rel="bookmark">
			Effective Java 第3版 创建和销毁对象分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一 前言 最近在看Effective Java 第3版的相关内容，这里做个学习总结，加深一下印象。后面会抽出时间持续更新。 二 创建和销毁对象的阅读分享 2.1 用静态方法代替构造器 背景：
平常我们在创建类的对象的时候一般都是直接通过new的方式创建，这样是最直接也是最简单的方式，但是随着我们的类功能的不断扩展，字段不断增加。直接new的方式会给我们带来一些问题。
类的属性太多调用方不知道该传什么必要的参数。有些工具类不需要频繁的创建，只需要创建一个对象就可以支持各种应用场景调用。不支持根据条件灵活创建子类的对象。 优点：
静态方法创建对象可以有名称。 相对于直接new的方式创建对象，这种可以更好的理解创建对象的常见。比如我们常见的Java自带的类的使用姿势
Date date = Date.from(Instant.now()); // 根据Instant对象常见Date类型对象 Set&lt;ApprovalStatusEnum&gt; set = EnumSet.of(ApprovalStatusEnum.DRAFT); // 根据多个枚举值参数返回一个枚举值集合 Array[]stringArray = (Array[]) Array.newInstance(String.class, 2); // 根据类和数字创建一个字符串数组 List&lt;String&gt; edg = Collections.singletonList("edg"); // 创建只有一个元素的链表 实际项目中类似的用法。rpc返回Response时返回BaseResp中的静态工厂防范，根据名称可以明显知道这个方法的作用，望文生义。
public static BaseResp successBaseResp() { BaseResp baseResp = new BaseResp(); baseResp.StatusMessage = ResponseEnum.SUCCESS.getMessage(); baseResp.StatusCode = ResponseEnum.SUCCESS.getCode(); return baseResp; } public static BaseResp failedBaseResp(String message) { BaseResp baseResp = new BaseResp(); baseResp.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3397c394d8670c6da36b1f341c311c5b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40593c1ecb481bc2ae644d64f83ba6f0/" rel="bookmark">
			“常量中有换行符”的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		简介 在使用MSVC编译的时候出现“常量中有换行符”这一错误，网上搜索后可知是由于文件是utf-8编码但没有带BOM导致的。解决方法有很多，因为感觉很麻烦，所以这里我使用python来给没有BOM的文件加上BOM。
代码 import os cur_dir = os.path.dirname(__file__) # def test(): # u8_nb_path = os.path.join(cur_dir, 'utf-8_nobom.txt') # u8_b_path = os.path.join(cur_dir, 'utf-8_bom.txt') # u8_nb = open(u8_nb_path, "rb") # u8_b = open(u8_b_path, "rb") # print(u8_nb.read(1)) # print(u8_nb.read(1)) # print(u8_nb.read(1)) # print(u8_nb.read(1)) # print("") # print(u8_b.read(1)) # print(u8_b.read(1)) # print(u8_b.read(1)) # print(u8_b.read(1)) # # efbbbf # u8_nb.close() # u8_b.close() def has_bom(content): return len(content) &gt;= 3 and content[0] == 0xef \ and content[1] == 0xbb and content[2] == 0xbf def to_utf8_bom_f(filename): print("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/40593c1ecb481bc2ae644d64f83ba6f0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9129d9180915604d726773488cd95f8f/" rel="bookmark">
			Observability：从零基础到能够完成微服务可观测性的专家 - Service Map 实践
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		现在的 IT 系统越来越复杂，而微服务也被广泛使用于越来越多的大型 IT 系统中。 微服务是一种软件开发技术- 面向服务的体系结构（SOA）架构样式的一种变体，将应用程序构造为一组松散耦合的服务。在微服务体系结构中，服务是细粒度的，协议是轻量级的。
对于一些大型的 IT 系统来说，微服务的个数可能达到 1000 多个或者更多。如果我们的系统变得很慢，我们想查出是哪个环节出了问题。如果没有一个很好的可观测性的工具。我们有时是一头的雾水。很幸运的是 Elastic Stack 提供了一套完整的 APM （应用性能监控）可观测性软件栈，为我们对微服务的调试提供了完美的解决方案。
在今天的文章中，我们将使用一个简单的例子来展示如何从0基础到一个掌控微服务可观察性的专家。你不需要具有先前的很多知识。对于 Elastic APM 不是很熟的开发者来说，你可以阅读我之前的文章 “Elastic：应用程序性能监控/管理（APM）实践”。
在今天的实践中，我将使用如下的代码来进行展示：
git clone https://github.com/liu-xiao-guo/from-zero-to-hero-with-observability 在做实验之前，请使用上面的命令下载代码。
Service Map 是应用程序体系结构中已检测服务的实时可视表示。 它显示了这些服务的连接方式，以及诸如平均交易持续时间，每分钟请求数和每分钟错误数之类的高级指标。 如果启用，服务图还将与机器学习集成-基于异常检测分数的实时健康指标。 所有这些功能都可以帮助你快速直观地评估服务的状态和运行状况。上面的例子的微服务服务图如下：
整个软件有如下的几个部分组成：
h2：是一个本地数据库backend-java ：是一个 Spring 的网路服务器。它接受来自 fronend-react 的数据请求localhost:3000： 是一个服务器，它用作数据展示backend-golang：它是一个由 Golang 写的服务，可以访问 redis 数据库 在下面，我们一步一步地来展示如何从 0 开始启动微服务的可观测性。我将以 7.10 版本为例来进行展示。
安装 Elasticsearch 及 Kibana 我们可以按照我们的文章 “Elastic：开发者上手指南” 来安装及运行我们的 Elasticsearch 及 Kibana。安装完后，并安装相应的指令分别进行运行。
APM server 我们接下来安装 APM 服务器。打开 Kibana：
我们可以根据自己的操作系统来分别进行安装。在我的实验中，我将以 macOS 为例来进行展示。通过这种安装的好处是它永远可以匹配你当前运行的 Elasticsearch 及 Kibana 的版本，同时你也可以找到适合自己 OS 的 APM Server 的安装方法。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9129d9180915604d726773488cd95f8f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/610ef07447b2c7b9ac5c17eff5cd6262/" rel="bookmark">
			[论文研读]天天看到的 ground truth，到底是什么意思？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 维基百科中文版Statistics and machine learning I Can See Clearly Now : Image Restoration via De-Raining 维基百科 中文版 基准真相：(ground truth) 是一个相对概念；
它是指相对于新的测量方式得到的测量值，作为基准的，由已有的、可靠的测量方式得到的测量值（即经验证据）。人们往往会利用基准真相，对新的测量方式进行校准，以降低新测量方式的误差和提高新测量方式的准确性。
机器学习领域借用了这一概念。使用训练所得模型对样本进行推理的过程，可以当做是一种广义上的测量行为。因此，在有监督学习中，ground truth 通常指代样本集中的标签。
Statistics and machine learning “Ground truth” may be seen as a conceptual term relative to the knowledge of the truth concerning a specific question. It is the ideal expected result.[2] This is used in statistical models to prove or disprove research hypotheses. The term “ground truthing” refers to the process of gathering the proper objective (provable) data for this test.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/610ef07447b2c7b9ac5c17eff5cd6262/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88f33f0c224d9d897c99b4f6613da95e/" rel="bookmark">
			CSS 中的 BFC 是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是前端西瓜哥。今天来学习 BFC。
BFC，为 Block Formatting Context 的缩写，中文翻译为 块格式上下文。
BFC 是 Web 页面 CSS 渲染的一个机制，是块级盒子布局中产生的区域。
你可以将一个 BFC 可以理解为一个容器，里面的元素不会影响到容器外的布局。
怎样的元素属于 BFC？ 根元素，也就是 HTML 元素
浮动元素，即使用了 float 属性且值不为 none
绝对定位元素
块级容器（如 display 的值为 inline-blocks、table-cells、table-captions）
overflow 的值不为 visible 的元素
使用了 display: flow-root 的元素。这是新出的值，专门用来创建无副作用的 BFC。兼容性存疑，比较少用。
当然还有一些 CSS 属性也可以触发 BFC，但比较少见，这里就不一一列举了，读者可自行阅读 MDN 文档。
目前来说，最常见的是通过 overflow: hidden 来构建 BFC。一般情况下，它的副作用最小。但如果元素下有超出盒子范围的内容，会被截掉，请谨慎使用。
BFC 的特性 BFC 主要有两个特性，我们来学习一下。
特性1：上下外边距重叠 同一个 BFC 下的两个相邻块级元素，会发生上下方向的 margin 重叠。
比如前一个 div 设置了 margin-bottom: 20px，下一个 div 设置了 margin-top: 10px，然后你会发现它们的上下距离其实是 20px（二者的最大值），而不是 30px（二者之和）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88f33f0c224d9d897c99b4f6613da95e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/48ffc3f50eac85ba475b2399ba792385/" rel="bookmark">
			3分钟带你快速了解常用的数组方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常用的数组方法汇总： concat（） 作用：合并数组
该方法可以合并两个或者多个数组，且不会更改现有的数组，而是返回一个新的数组。
示范：
find（） 作用：通过值找值的对象
该方法可以通过一个对象的键，查找到键所对应的整个对象，再把整个对象返回。如果没有找到相同对应的，则返回undefined
示范：
findIndex（） 作用：查找索引
该方法返会数组中要找的第一个元素的索引，如果没有找到，则会返回-1
示范：
includes（） 作用：判断数组是否有特定的值
该方法可以判断数组中是否有特定的子盒子，如果有返回一个true，没有的话，则返回false
示范：
indexOf（） 作用：查找索引
该方法会在数组中可以找到一个给定元素的索引，如果不存在，则返回-1
示范：
join（） 作用：数组变字符串
该方法会将一个数组（或者类数组对象），的使用元素连接成一个字符串，并返回这个字符串。如果数组只有一个项目，那么可以将返回项目，而不是用分隔符
示范
pop（） 作用：删除数组最后一个
该方法可以将数组中最后一个数组的数据删除，并返回该元素的值，可以修改数组的长度
示范：
push（） 作用：数组添加到最后一个
该方法可以将多个或者一个元素，添加到数组的末尾，并返回该数组的长度
示范：
shift（） 作用：删除第一个元素
该方法会将数组中的第一个元素删除，并返回该元素的值，也可以修改数组的长度
示范：
unshift（） 作用：添加到开头
该方法可以将一个元素或者多个元素添加到数组的开头，并且返回该数组的新长度（会修改原有的数组）
示范：
splice（） 作用：实现数组的值替换
该方法通过删除或者替换现有元素或者原地添加新的元素来修改数组，并以数组的形式返回修改内容，会改变原数组
示范：
第一个参数代表删除的索引，
第二个参数代表删除的数量，
第三个代表：新增的值
如果不传参，且声明变量赋值，接则返回空数组
reverse() 作用：数组颠倒
该方法可以让数组中的元素位置颠倒，并返回该数组，会改变原数组
示范：
sort() 作用：对数组进行排序
该方法用原地算法 对数组的元素进行排序，并返回数组，默认排序是将元素转换成字符串，然后比较他们的UTF-16代码单元值序列时构建的。
示范：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/93a647bd7be0f9bb7aeab935eca36632/" rel="bookmark">
			Linux中GDB安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言
gdb是Linux环境下的代码调试工具，为了能在linux环境下更有好的编程体验。其安装可谓是势在必行。
安装过程
安装gdb的过程很简单，具体步骤如下：
查看当前gdb安装情况
rpm -qa|grep gdb
if(有)（删除）
rpm -e --nodeps 文件名
if（没有）
首先（下载gdb源码包）,直接在Linux中输入
wget http://ftp.gnu.org/gnu/gdb/gdb-7.10.1.tar.gz
解压
tar -zxf gdb-7.10.1.tar.gz
进入gdb目录
cd gdb-7.10.1
用以下命令生成makefile文件
1、输入命令
./configure
2、编译（时间比较长）
make
3、在输入一个命令
make install
这个时候我出错了，但是不要怕,输入这个命令
yum install texinfo
make install
Ubuntu版本是sudo apt-get install texinfo
查看https://blog.csdn.net/summy_j/article/details/72846076
最后判断是否成功
gdb -v
以上原文链接：https://blog.csdn.net/hannah___/article/details/90720172
举个简单例子：
#include&lt;stdio.h&gt; int main(void){ int arr[4]={1,2,3,4}; int i=0; for(i=0;i&lt;4;i++){ printf("%d\n",arr[i]); } } 要用gcc进行编译，具体的命令如下：
gcc -g 源文件.c -o 输出的目标文件 进入jdb
r是运行 quit 是退出
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/93a647bd7be0f9bb7aeab935eca36632/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2aef0c6000e77c3f9f6ae52006434bab/" rel="bookmark">
			gitlab如何修改项目clone克隆地址
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		打开gitlab容器、编辑gitlab.yml文件
root@061df89f4dbb:/# vim /opt/gitlab/embedded/service/gitlab-rails/config/gitlab.yml
host: 192.168.2.238
port: 8088
https: false
配置完了之后 gitlab-ctl restart 重启gitlab 服务器
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1d7e0ecd4875bcf831b48396719ea1a/" rel="bookmark">
			python复制文件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		python复制文件 公司一个程序同步出问题，写了一个定时同步的脚本
需要一个filename.json的配置文件
格式：
{ "path_read":"D:\\xx\\xx", "path_write":"E:\\xx\\xx" } 程序代码：
import os import sys import json from shutil import copyfile # 复制一个文件到另一个文件夹下 copyfile(src,dst) import schedule # 递归函数 def copy_file(path_read, path_write): # 输出path_read目录下的所有文件包括文件夹的名称 names = os.listdir(path_read) # 循环遍历所有的文件或文件夹 for name in names: # 定义新的读入路径（就是在原来目录下拼接上文件名） path_read_new = path_read + "\\" + name # 定义新的写入路径（就是在原来目录下拼接上文件名） path_write_new = path_write + "\\" + name # 判断该读入路径是否是文件夹，如果是文件夹则执行递归，如果是文件则执行复制操作 if os.path.isdir(path_read_new): # 判断写入路径中是否存在该文件夹，如果不存在就创建该文件夹 if not os.path.exists(path_write_new): # 创建要写入的文件夹 os.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1d7e0ecd4875bcf831b48396719ea1a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24f98df4bde94921e59ce850c6a64e79/" rel="bookmark">
			oracle oci.dll 12版本下 载方法及路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 oracle数据库oci.dll下载版本不同就会报错
错误一般如下
这种情况我们需要下载对应版本的oci.dll 进行切换，这样就可以将问题解决
解决方法有两种
第一种 官方网站下载对应版本的oci.dll
链接如下：https://www.oracle.com/database/technologies/instant-client/winx64-64-downloads.html
第二种 直接下载别人已上传的oci.dll
这里提供免费的oci.dll 12 版本下载地址
https://download.csdn.net/download/weixin_42277816/85391409 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9b26dadc77a5065a45923eb9a891c793/" rel="bookmark">
			RS485串口驱动源代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 串口驱动是最简单的一种驱动了，在Linux下一切设备都认为是文件，打开设备就像打开文件一样简单，直接上代码
2、RS485.c //-------------------------------------------------------------------------------------------------- // Include head files //-------------------------------------------------------------------------------------------------- #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;fcntl.h&gt; #include &lt;termios.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;sys/ioctl.h&gt; #include &lt;sys/socket.h&gt; #include "RS485.h" //------------------------------------------------------------------------------------------------- // Private Definitions //------------------------------------------------------------------------------------------------- //------------------------------------------------------------------------------------------------- // Private Members //------------------------------------------------------------------------------------------------- //------------------------------------------------------------------------------------------------- // Private Functions //------------------------------------------------------------------------------------------------- static int SetAttributes(int fd, RS485PARA Rs485Para) { struct termios newtio; bzero(&amp;newtio, sizeof(newtio)); newtio.c_cflag |= CLOCAL | CREAD; newtio.c_cflag &amp;= ~CSIZE; switch (Rs485Para.m_Bits) { case SEVEN: newtio.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9b26dadc77a5065a45923eb9a891c793/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f62dd2f48aa913df9bfa7950ee178d8/" rel="bookmark">
			对于基本的AT命令学习与掌握
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、AT命令的基本执行流程？二、基本AT与功能1.一般指令2.呼叫类控制指令3.网络服务类指令4.安全命令类指令5.电话簿类指令6.短消息类指令7.追加服务类指令 总结 前言 注意：参考http://t.csdn.cn/B2Yd1 以及3Gpp—27007-680：
一、AT命令的基本执行流程？ 1.检测模块：AT
AT OK 2.查看卡在位状态：AT+CPIN?
AT+CPIN? +CPIN:READY OK 3.查看ICCID:AT+ICCID
AT+CCID 89860009101950207720 OK 4.查看IMSI：AT+CIMI
AT+CIMI 460029964466206 OK 5.查看信号强度：AT+CSQ
AT+CSQ +CSQ: 14, 99 OK 6.查看注册信息：AT+CREG
(CREG 是针对2G网络注册信息)
AT+CREG +CGREG: 0,1 OK 判断网络注册正常后，就可以开始真正的业务逻辑
二、基本AT与功能 注意：所有写了全称的是暂时学过的，没写就没学
1.一般指令 序号指令含义1AT+CGMI给出模块厂商的标识2AT+CGMM获得米快标识。这个命令用来得到支持的频带（GSM900,DCS1800或PCS1900）当模块有多频带时，回应可能是不同频带的结合3AT+CGMR获得修订的软件版本4AT+CGSN获得GSM模块的IMEI（国际移动设备标识）序列号5AT+CSCS选择TE特征设定。这个命令报告TE用的是那个状态设定上的ME。ME于是可以转换每一个输入的或者显示的字母。这个是用来发送，读取或者撰写短信。6AT+WPCS设定电话簿状态。这个特殊的命令报告通过TE电话簿所用的状态的ME。ME于是可以转换每一个输入的或者显示的字符串字母。这个用来读或者写电话簿的入口7AT+CIMI获得IMSI。这个命令用来读取或者识别SIM卡的IMSI（国际移动签署者标识）在读取IMSI之前应该先输入PIN（如果需要PIN的话）8AT+CCID获得SIM卡的标识。这个命令时模块读取SIM卡上的EF-CCID文件9AT+GCAP获得能力表。（支持的功能）10A/重复上次命令。只有A/命令不能重复。这个命令重复前一个执行的命令11AT+CPOF关机。这个特殊的命令停止GSM软件堆栈和硬件层。命令AT+CFUN=0的功能与+CPOF相同12AT+CFUN设定电话机能。这个命令选择移动站点的机能水平13AT+CPAS返回移动设备的活动状态14AT+CMEE报告移动设备错误。这个命令决定允许或者不允许用结果代码“+CMEERROR: ”或者 “+CMSERROR: ”代替简单的“ERROR”15AT+CKPD小键盘控制。仿真ME小键盘执行命令16AT+CCLK时钟管理。这个命令用来设置或者获得ME真实时钟的当前日期和时间17AT+CALA警报管理。这个命令用来设定在ME中的警报日期/时间。（闹钟）18AT+CRMP铃声旋律播放。这个命令在模块的蜂鸣器上播放一段旋律。有两种旋律可用：到来语音，数据或传真呼叫旋律和到来短信声音19AT+CRSL设定或获得到来的电话铃声的声音级别 2.呼叫类控制指令 序号指令含义1ATD拨号命令。用来设置通话，数据或者传真呼叫2ATH挂机命令3ATA接电话4AT+CEER （Extended error report +CEER）拓展错误报告。用来给出当上一次通话设设置失败后中断通话的原因5AT+VTD( Tone duration +VTD)给用户提供应用GSM网络发送DTMF（双音多频）双音频。这个命令用来定义双音频的长度（默认值300ms）6AT+VTS(DTMF and tone generation +VTS)给用户提供应用GSM网络发送DTMF双音频。这个命令允许传送双音频7ATDL重播上次电话号码8AT%Dn数据终端就绪（DTR）时自动拨号9ATS0自动应答10AT+CICB来点信差11AT+CSNS(Single numbering scheme +CSNS)单一编号方案12AT+VGR(Receive gain selection +VGR),AT+VGT(Transmit gain selection +VGT)增益控制。用于接收喇叭的接受增益和麦克风的传输增益13AT+CMUT（Mute control +CMUT）语音通话静音控制14AT+SPEAKER喇叭/麦克风选择。用来选择喇叭和麦克风15AT+ECHO回音取消16AT+SIDET侧音修正17AT+VIP(Initialise voice parameters +VIP)初始化声音参数18AT+DUI用附加的用户信息拨号19AT+HUI用附加的用户信息挂机20AT+RUI接受用户附加信息 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2f62dd2f48aa913df9bfa7950ee178d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7cf0fa203858ca42959a9c9426228987/" rel="bookmark">
			Linux系统安装Oracle
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.下载oracle安装包，并上传到/opt目录 2.解压oracle安装包 # cd /opt # unzip linuxx64_12201_database.zip
# ls database
3.关闭selinux(安全模块)和防火墙 关闭selinux:
# vim /etc/selinux/config
将SELINUX设置成disabled 关闭防火墙:
# systemctl stop firewalld
4.安装Oracle12c依赖软件 1.使用阿里yum源代替系统默认的yum源
① 备份默认源 #cd /etc/yum.repos.d/ #mv CentOS-Base.repo CentOS-Base.repo.bak ② 下载新CentOS-Base.repo #wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo
含义:使用阿里云的yum源代替默认的yum源，下载软件更快 ③ 清除所有缓存 #yum clean all ④ 重新生成缓存 #yum makecache
2.依赖的安装
# yum -y install binutils compat-libstdc++-33 compat-libstdc++-33.i686 elfutilslibelf
elfutils-libelf-devel gcc gcc-c++ glibc glibc.i686 glibc-common glibcdevel
glibc-devel.i686 glibc-headers ksh libaio libaio.i686 libaio-devel libaiodevel.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7cf0fa203858ca42959a9c9426228987/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f98e2b3a47d458b47447cd9c988370f3/" rel="bookmark">
			4 - 线程 - Windows 10 - CPython - 理解伪多线程中 join() 线程连接点(主线程堵塞) 和 sleep() 线程睡眠 的作用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、join() 连接点的服务对象是子线程二、sleep() - 线程睡眠的服务对象是主线程和子线程场景 1：主线程 time 小于 子线程 timesleep() 线程睡眠方法：join() 线程连接点方法： 场景 2：主线程 time 大于 子线程 time 三、个人对 join 方法的深入理解：参考链接 测试环境： 操作系统： Window 10 工具：Pycharm Python: 3.7 一、join() 连接点的服务对象是子线程 join
n. 连接处，接合点
| |主线程 |___ join() 连接点 | |子线程 | | |	| | | 主线程创建子线程对象，而子线程对象使用了 join()线程连接点方法后，当前的主线程就会从join()连接点开始堵塞，切换到某一个子线程运行，等到子线程完成它的程序后，会切换回主线程堵塞的位置，继续从主线程堵塞的位置执行下去。
sleep() 是time模块的一个函数，join()是线程模块 threading 的函数
sleep()堵塞的是当前的线程，而join()堵塞的是主线程 main，也就是说用了 join() 函数，那么主线程就必须等到该线程执行程序结束为止，才能运行主线程后面的程序。
比如
import threading t1 = threading.Thread(target=test) t1.join() 这代表着主线程就必须等待 t1 线程程序，执行结束为止，即便 t1 线程内存在了 sleep() 函数，堵塞该 t1 线程程序，也必须等到 sleep() 时间过后，再执行 t1 程序后面的代码，然后还得等到 t1 线程程序结束后，才会运行主线程的开启多线程代码后的其他代码。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f98e2b3a47d458b47447cd9c988370f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/163735d364a8a0b8c725fee84b32842a/" rel="bookmark">
			.net 6 EF Core MySql数据库表生成实体类命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		解决 .net 6 下的efcore 生成实体类问题 安装下面这几个包
Microsoft.EntityFrameworkCore
Microsoft.EntityFrameworkCore.Tools
Microsoft.EntityFrameworkCore.Design
Pomelo.EntityFrameworkCore.MySql
执行命令 Scaffold-DbContext “server=127.0.0.1;port=3306;database=DB;uid=root;pwd=pwdpwd;sslmode=none;” Pomelo.EntityFrameworkCore.MySql -OutputDir Models -Force -NoOnConfiguring -NoPluralize -Context “DataContext”
参考 官网地址:https://docs.microsoft.com/zh-cn/ef/core/cli/powershell#scaffold-dbcontext
Scaffold-DbContext
为 DbContext 数据库的和实体类型生成代码。 为了使 Scaffold-DbContext 生成实体类型，数据库表必须具有主键。
参数：
SCAFFOLD-DBCONTEXT
参数 说明
-连接 用于连接到数据库的连接字符串。 对于 ASP.NET Core 2.x 项目，值可以是 name = 。 在这种情况下，该名称来自为项目设置的配置源。 这是一个位置参数，并且是必需的。
-提供程序 要使用的提供程序。 通常，这是 NuGet 包的名称，例如： Microsoft.EntityFrameworkCore.SqlServer 。 这是一个位置参数，并且是必需的。
-OutputDir 要在其中放置文件的目录。 路径相对于项目目录。
-ContextDir 要在其中放置文件的目录 DbContext 。 路径相对于项目目录。
-命名空间 要用于所有生成的类的命名空间。 默认值为从根命名空间和输出目录生成。 在 EF Core 5.0 中添加。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/163735d364a8a0b8c725fee84b32842a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2608cc104b07f53d89717394360bdfe7/" rel="bookmark">
			Gromacs副本交换分子动力学模拟(REMD)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		REMD(副本交换分子动力学)是一种增强采样方法，其在不同温度下对具有相似势能的体系进行采样。通过这种方法，可以增加体系跳出势能面势阱的可能性，从而达到探索新的构象空间的目的。
一般来说某一温度下蛋白模拟构象分布满足正态分布规律。如上图所示，展示了同一体系在不同温度下的分布情况，横坐标表示模拟过程中出现的构象，纵坐标表示某一构象存在的丰度。对于体系1（绿色）而言，能达到虚线区域内构象的概率比较小，需要延长模拟时间才能提高这个区域构象出现的次数，若模拟时间不充分甚至有可能采样不到该区域的构象。而对于体系2（红色）而言，却很容易达到蓝色虚线之间的构象，如果在模拟过程中体系1与体系2在这个区间进行了构象交换，那么就可以弥补体系1采样不足的问题。
以上个人愚见，仅供参考！
Gromacs 中实现的方式：
注意：只有单线程 gromacs 不支持 REMD，需要多线程编译版本。安装过程和之前的教程相差无几，只是需要额外安装 openmpi，并在最后 gromacs 编译步骤增加一个选项-DGMX_MPI=ON 即可。编译完成并安装后，执行gmx_mpi可以正常调用。
确定所选模拟体系温度变化范围，温度变化梯度；每一个温度下分别进行预平衡（NVT/NPT），每个温度下的预平衡称为一个副本/或系综。在这些副本进行预平衡之前共同都要进行相同的步骤：包括建模、能量最小化。以每个副本预平衡后的终构象作为起始分别开始对应温度下的成品模拟。 实现上述过程并不复杂，我为大家提供了运行脚本：
关注微信公众号grosetta，后台回复“REMD”自取（以溶菌酶模拟为例）
1、模型构建+EM cd REMD chmod 777 run.sh ./run.sh 运行完后，在主文件夹中会出现模拟后的文件（后面不需要的都自动删除了），文件1EM.gro及topol.top是必须存在的。
用编辑器打开1EM.gro及topol.top查看蛋白总原子数及水总分子数。
2、副本温度取值确定 打开网址：
http://virtualchemistry.org/remd-temperature-generator/
其中：
Exchange probability（副本交换频率）可根据需求自行调整；Lower temperature limit 设定温度区间下限（单位K）；Number of water molecules 体系总的水分子数；Number of protein atoms 体系蛋白总原子数；Upper temperature limit 设定温度区间上限(单位K)；Constraints in water 水分子模型是柔性水还是刚性水，一般选刚性水；Constraints in the protein 选择只对氢原子的键进行束缚； 其余各项保持默认即可。
点击submit提交，返回程序推荐的各副本模拟温度取值（需要注意的是该程序针对oplsaa力场发展而来，对于应用其他力场的体系，如AMBER、GROMOS,则多少存在些偏差）。
复制红框内的数据以备后用。
3、多副本预平衡模拟 在REMD文件夹一级目录下打开终端
chmod 777 step1.sh ./step1.sh step1.sh脚本内容如下（第一行的温度数据就是上一步复制结果，替换成你的即可）：
#!/bin/bash T="298.15, 299.47, 300.78, 302.11, 303.44, 304.77, 306.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2608cc104b07f53d89717394360bdfe7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aeb128c3ed31021c5cc38030a1690c18/" rel="bookmark">
			关于java.sql.SQLException: The server time zone value问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		（本文仅供记载，无任何技术含量）
在用java连接mysql时，可能会出现java.sql.SQLException: The server time zone value 问题
这往往是MySQL过高版本导致，只需要登录Mysql ,调整时区即可。
解决方案： ①. 进入mysql命令行界面 ， 输入密码(或打开dos窗口，mysql -u root -p --&gt;回车--&gt;输入密码）
②.成功登进去之后 ，执行语句： set global time_zone='+8:00';
一般来说就解决了高版本时区问题。
（本文仅供记载，无任何技术含量）
---------------- 2022-1-31
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3e894900fabc99a0401384637a5591a5/" rel="bookmark">
			图像分割常用评价指标（mIoU,F1-score）_2022.05.15
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		语义分割任务中的结果，可分为True Positive（TP）、False Positive（FP）、True Negative（TN）、False Negative（FN）。其中Negative指的是非物体标签的部分(一般是为除目标之外的背景信息)，Positive一般指是含标签的部分信息。
TP:输入图像中含有label信息的部分被正确识别为相对应的label信息
FP:输入图像中含有背景信息的部分被错误识别为label信息
TN:输入图像中含有背景信息的部分被正确识别为相对应的背景信息
FN:输入图像中含有label信息的部分被错误识别为背景信息
下述公式中参数的定义含义如下：k+1代表数据集定义的类别总数(包括背景类"background"，通常是“0”，所以下面公式中的i和j均以“0”开头)；pij表示标识为类j的像素数目总数，也就是pii表示正确识别的真正例总数(True Positive，TP)，而 pij和 pji 则分别表示错误识别的假正例FP总数（False Positive, FP）和假反例FN总数（False Negative, FN）。
基于PASCAL-Part数据集的模型评价指标通常是由mIoU值来判断的。mIoU值计算公式如下图：
mIoU值的公式可视化如下图所示
目前，基于ATR数据集的模型评价指标通常是由F1-score分数来判断的。F1-score分数是查准率P（Precision）和查全率R（Recall）的调和平均数。F1-score值计算公式如下图：
其中F1-score的核心思想就是尽可能地提高Precision和Recall，使两者之间的差异尽可能小。
补充：
查准率P（Precision）也可叫准确率
例子：针对模型预测的Predicted值为1的情况下，预测正确的label为1的比率：
查准率R（Precision）也可叫召回率
例子：针对数据集中的label为1的情况下，预测正确的label为1的比率：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90fe774442b00460dcd654da12fdaae2/" rel="bookmark">
			小猫爪：S32K3学习笔记11-S32K3之FCCU
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小猫爪：S32K3学习笔记11-S32K3之FCCU 1 前言2 FCCU的功能框图2.1 错误输入2.2 时钟输入2.3 FSM2.4 FOSU 3 FCCU的状态机4 MCAL配置5 SPD应用代码示例END 1 前言 这一节来学习一下safety中的一个核心模块，它就是FCCU（Fault Collection and Control Unit），看名字就知道这是一个错误收集模块，其他模块发生错误了，就会讲错误信号传递到FCCU中进行统一管理。
2 FCCU的功能框图 这FCCU的功能框图如下：
2.1 错误输入 这DCM可以理解成是K3里面的一个错误集合器，主要体现在6个寄存器中，分别是标志寄存器DCMROD3，DCMROD4和DCMROD5；以及相对应的使能寄存器DCMRWD3，DCMRWD4和DCMRWD5。每一个bit代表着一个DCM错误通道，所以理论上总共有3*32=96个DCM通道（实际上并没有96个，因为有几个通道是reserve状态，S32K3总共有86个错误），只有当标志寄存器位和其对应的使能寄存器位都等于1时，这个错误才能传送到FCCU中去被处理。
这里可以提一下的就是ERM 20个通道所能报告的错误是DCM的一个子集，但是ERM通道和DCM通道并不是一一对应，这里很好理解，因为两者对错误的分类方式不同。ERM针对的是Memory ECC的错误，而DCM则涵盖了K3整个所有的错误。
DCM的96个通道传送到FCCU后，FCCU又把DCM的错误按照错误类型又将其划分成8种通道组，分别对应NCF[7:0]这8个通道组，如下表所示：
这8组通道几乎涵盖了S32K3所有的错误，这8种错误后续会一个一个介绍。除了8个NCF通道组外，FCCU还能通过EIN[1:0]接收来自芯片外部的错误信号，并做一些处理。
2.2 时钟输入 FCCU的时钟源有三个，分别是Primary Clock，Safety Clock0和Safety Clock1，其中Primary Clock为FCCU的主时钟，其来源为AIPS_PLAT_CLK，而Safety Clock是给FCCU中的一些特殊模块使用的，至于到底给了谁，我也不是特别清楚，据我所知，会给EOUT和FOSU提供时钟（嘿嘿嘿，因为RM手册里面有个表格有标），其来源为FIRC_CLK。
2.3 FSM FSM是FCCU的主体，它负责整个FCCU状态机的切换，其实就是接收错误信号，然后根据相关配置来决定触发几个特殊的信号给外部。首先它能触发三个中断，分别是timeout interrupt, alarm interrupt和NMI interrupt，还可以触发一个function reset信号给MC_RGM来让K3执行功能性复位（这里需要注意一点，Function Reset并不能复位FCCU模块），还可以触发两个外部信号EOUT[1:0]给外部SBC，让SBC执行一些操作，另外EOUT[1:0]的点平信号是互补相反的。
2.4 FOSU 这个模块是用来监控FCCU的，是为了防止FCCU失效的。如果一个错误信号传送到了FCCU，而FCCU在短时间内并没有做出相应的反应，那么FOSU就认为FCCU挂了，那么它会触发一个Destructive Reset给MC_RGM来让K3执行破坏性复位（这里需要注意一点，Destructive Reset会复位FCCU模块）。
3 FCCU的状态机 当一个错误传到了FCCU中，FCCU的处理分为几个阶段，即其状态机，每个阶段干不同的事情，FCCU的状态机切换如下图所示：
从图中可以看出，FCCU包含四种状态，分别是CONFIG, NORMAL, ALARM，FAULT，这几种状态的切换也是非常的简单。
CONFIG: K3启动后，默认是CONFIG，在这个状态中，你可以对FCCU的寄存器进行操作配置，等配置完后，再手动切换至NORMAL。在FCCU中有个config timer, 如果在一定时间没有切换至NORMAL而导致config timer超时（该超时时间可配置），那么FCCU会自动切换至NARMAL，而FCCU的配置则为默认配置，同时config timer超时也可触发一个超时中断信号。NORMAL: FCCU检测到NCF的8个通道任何一个及以上有错误时，这个时候FCCU就会从NORMAL切换到ALARM或者FAULT，至于切换到哪种状态取决于是否使能了NCF通道的ALARM中断。ALARM：如果当前NCF通道使能了ALARM中断，并且伴随着错误，那么FCCU就会从NORMAL切换到ALRAM，并且触发ALARM中断，用户可以在ALARM中断中对错误进行处理，如果经过处理后，让错误消失，那么FCCU就会重新切换至NORMAL状态。在FCCU中还有个alarm timer, 如果在一定时间内没有让错误消失而导致alarm timer超时（该超时时间可配置），那么FCCU就会进入FAULT状态。FAULT：如果当前NCF通道没有使能ALARM中断，并且伴随着错误，那么FCCU就会从NORMAL直接切换到FAULT，或者FCCU在ALARM状态中超时那么FCCU就会从ALARM切换到FAULT。一旦FCCU进入到FAULT，那么可以选择触发function reset或者触发NMI中断。如果通过function reset或者NMI中断处理程序消除了所有错误，那么FCCU就会从FAULT切换回NORMAL；如果错误没有清除掉的话，问题会很严重。如果错误连续触发Functional Reset多次都没有解决问题，那么这样Functional复位连续N次后（可配置，最大15次），会直接触发Dectructive Reset信号，而该破坏性复位源为MC_RGM_FRE，如果连破坏性复位都不能解决问题，导致连续破坏性复位超过N次（可配置，最大15次），则芯片会卡在复位状态，软件无法运行，直到重新上电（这其实就是MC_RGM的Escalation功能，具体详情请参考后面解释MC_RGM的文章）。 另外进入FAULT也可以选择是否输出EOUT信号给SBC，SBC接收到信号可以进行一些操作。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90fe774442b00460dcd654da12fdaae2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2268fce2a373c87e581e0ba819403fe/" rel="bookmark">
			[图像处理]3×3中值滤波的verilog实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、原理 1.将连续输入的9个灰度值存入移位寄存器，并通过抽头形成3×3矩阵，而后通过组合逻辑输出9个数的中值。 2.抽头原理 因为数据存入shift reg需要一拍的时间，若选用5、2抽头需要对input单独延迟一拍，本例选用6、3抽头以及input作为滤波矩阵的列输入，避免对input的单独延迟处理。
每个时钟上升沿到来时，矩阵左列为抽头输入，其他列依次右移，如图所示。
3.求中值算法 ①将9个数分成3组，每组3个数。求每一组的最大值、中值、最小值
②对3个最大值求最小值，对3个最小值求最大值，对3个中值求中值，得到3个数
③对这三个数求中值，这个数也是9个像素的中值
二、verilog实现 顶层模块：
// Module Name: mid_9_nums // Target Device: xc7z010clg400-1 // Tool versions: vivado 2017.4 // Last Version: 2022.4.18 // Description: mid_filter //port define module mid_9_nums( input clk, input rst_n, input [7:0] data_in, output [7:0] data_out ); parameter length = 9; reg [7:0] data_reg [length-1:0];//9 shift reg /*********max/mid/min reg**********/ wire [7:0] data_max [2:0]; wire [7:0] data_mid [2:0]; wire [7:0] data_min [2:0]; wire [7:0] data_min_max; wire [7:0] data_max_min; wire [7:0] data_mid_mid; /**********************************/ /**************matrix**************/ reg [7:0] m11,m12,m13; reg [7:0] m21,m22,m23; reg [7:0] m31,m32,m33; /**********************************/ wire [7:0] row1,row2; reg	[7:0] row3; integer i; //9 nums shift reg always @(posedge clk or negedge rst_n)begin if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2268fce2a373c87e581e0ba819403fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8e418d7300a3306dc7ec9146371d8d96/" rel="bookmark">
			python--求最大和子列表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本题要求实现一个函数msslst()，带一个整数列表作为输入参数。要求函数计算并返回输入列表中的最大和子列表之和。最大和子列表是输入列表的子列表（切片），其各项之和最大。所有列表项都为负数，则最大和子列表为空子列表，空子列表的和定义为0。
函数接口定义： msslst(lst) lst为传入的整数列表。
裁判测试程序样例： # 请在这里填写答案 def main(): s = input() items = s.split() lst = [eval(x) for x in items] print(msslst(lst)) main() 输入样例1： 在这里给出一组输入。例如：
4 -2 -8 5 -2 7 7 2 -6 5 输出样例1： 在这里给出相应的输出。例如：
19 输入样例2： 在这里给出一组输入。例如：
3 4 5 输出样例2： 在这里给出相应的输出。例如：
12 输入样例3： 在这里给出一组输入。例如：
-2 -3 -5 输出样例3： 在这里给出相应的输出。例如：
0 def msslst(lst):
ls=[]
for i in range(len(lst)):
for j in range(i,len(lst)+1):
ls.append(sum(lst[i:j]))
if max(ls)&lt;0:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8e418d7300a3306dc7ec9146371d8d96/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fc7765d4b056b72e99504cbd4d7f701/" rel="bookmark">
			webpack 面试题整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 webpack 面试题整理谈谈你对Webpack的理解Webpack的打包过程/打包原理/构建流程？Webpack中loader的作用/ loader是什么？常见的loader有哪些？ Plugin有什么作用？/Plugin是什么常见的Plugin有哪些Webpack 插件的执行顺序（加载机制）？ Webpack中Loader和Plugin的区别Webpack 做过哪些优化手段？有哪些优化手段？tree-shaking 删除没有使用的代码 优化前端性能/提高构建速度使用tree-shaking需要注意什么？ 如何利用webpack来优化前端性能？Webpack如何配置压缩代码？压缩了什么？ 如何提高webpack的构建速度？ webpack 面试题整理 谈谈你对Webpack的理解 1.Webpack是什么？
webpack 是一个静态模块打包器，当 webpack 处理应用程序时，会递归构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将这些模块打包成一个或多个 bundle。
webpack 就像一条生产线,要经过一系列处理流程(loader)后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的,多个流程之间有存在依赖关系,只有完成当前处理后才能交给下一个流程去处理。
插件就像是一个插入到生产线中的一个功能,在特定的时机对生产线上的资源做处理。 webpack 在运行过程中会广播事件,插件只需要监听它所关心的事件,就能加入到这条生产线中,去改变生产线的运作。
2.可以说说打包过程/构建流程
3.可以说说对前端运行的优化
Webpack的打包过程/打包原理/构建流程？ webpack 的运行流程是一个串行的过程，它的工作流程就是将各个插件串联起来。
命令行执行npx webpack打包命令开始
1.初始化编译参数:从配置文件和shell命令中读取与合并参数
2.开始编译:根据上一步得到的参数初始化Compiler对象，加载所有配置的Plugin，执行对象的 run 方法开始执行编译。
3.确定入口:根据配置中的 entry 找出所有的入口文件
4.编译模块:从入口文件触发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，然后递归本步骤直到所有入口依赖的文件都进行翻译。
5.完成模块编译:在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系图。
6.输出资源：根据依赖关系图，组装成一个个包含多个模块的Chunk，再把每个Chunk转化成一个单独的文件加入到输出列表，根据配置确定输出的路径和文件名，输出。
在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑。
总结
初始化:从配置文件和shell命令中读取与合并参数，根据参数初始化Compiler实例，加载Plugin(注册所有配置的插件)，调用Compiler实例的run方法开始执行编译。 Compiler编译对象掌控者webpack生命周期，不执行具体的任务，只是进行一些调度工作。比如执行模块创建、依赖收集、分块、打包等
调用run之后，创建Compiltation实例，每次构建都会新创建一个Compiltation实例，包含了这次构建的基本信息
Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑。
编译:从entry 触发，对每个Module 串行调用对应的 Loader对模块进行翻译，再找出该模块依赖的模块，递归进行编译处理。 从配置文件（ webpack.config.js ）中指定的 entry 入口，开始解析文件构建 AST 语法树
根据依赖关系图，组装成包含多个模块的Chunk，将个Chunk转换成文件输出。 不同entry生成不同chunk，动态导入也会生成自己的chunk
Webpack中loader的作用/ loader是什么？ Loader 是webpack中提供了一种处理多种文件格式的机制，因为webpack只认识JS和JSON，所以Loader相当于翻译官，将其他类型资源进行预处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fc7765d4b056b72e99504cbd4d7f701/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da3e27ea64aa4e16ded6b2d0bd3db310/" rel="bookmark">
			Spring IOC原理，Spring容器，IOC容器以及Spring中的DI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、Spring IOC原理1.IOC定义2.IOC能做什么3.Spring容器管理对象1.添加Spring核心组件2.Spring配置文件3.创建实体类（xxx.java）4.IOC容器管理对象 4.IOC容器1、 BeanFactory2、 ApplicationContext的常用实现类3、 容器管理对象4、 Spring中Bean的实例1.基于XML的配置方式转配Bean2.基于注解方式装配Bean（自动装配）3.通过java代码装配Bean（组件扫描） 二、Spring中DI1、基于XML配置注入依赖1. 有参构造函数注入依赖2. set方法注入依赖3. 注入依赖也可以是自定义类型4. 依赖也可以是集合类型 2、基于注解形式注入依赖@value@Resource@Autowired@Autowired和Resource的异同点 一、Spring IOC原理 1.IOC定义 IOC（Inversion of Control）：即“控制反转”，意味着将设计好的对象交给容器控制；传统的java程序设计，直接在对象的内部通过New形式创建对象，是程序主动去创建依赖对象，而IOC技术是专门的一个容器来创建对象，IOC容器来控制对象的创建而不是显性的使用new；对象的创建交给容器管理，这就是控制反转；控制反转是通过容器来完成的，Spring中提供了这样一个容器，称之为IOC容器；无论是创建对象，处理对象之间的依赖，对象的创建时间还是创建的数量，都是由Spring为我们提供的IOC容器上配置上兑现信息就行； 2.IOC能做什么 有了IOC容器之后，对于使用方来说只需要进行调用就行了，把创建和查找依赖的对象的控制权交给了容器，由容器进行注入组合对象，所以对象与对象之间是松耦合的，这样方便进行测试，利用功能复用，使整个体系结构变得非常灵活；由IOC容器来帮助对象找响应的依赖对象并注入，而不是对象主动去找，核心点在与资源不是有使用资源的调用方管理，而是不使用资源的第三方管理，第三方指的就是IOC容器；资源的集中管理，实现资源的可配置和易管理；降低了使用 资源双方的依赖程度，也就是说松耦合； 3.Spring容器管理对象 1.添加Spring核心组件 2.Spring配置文件 3.创建实体类（xxx.java） 4.IOC容器管理对象 增加一个Spring配置文件；对xml配置文件进行解析（bean标签）BeanFactory工厂类在工厂类的方法中使用反射创建Bean对象 4.IOC容器 ApplicationContext接口是BeanFactory的子接口；BeanFactory是Spring IOC容器所定义的最底层接口；ApplicationContext是BeanFactory的最高级实现之一，并对BeanFactory功能上做了很多的扩展，所以大部分的工厂场景下，都会使用ApplicationContext作为IOC容器； 1、 BeanFactory 1. 最底层的实现，提供了比较先进的配置机制，使得任何对象的配置成为可能； - ApplicationContext： 1. 在BeanFactory的基础上做了很多扩展实现； - 区别： 1. BeanFactory的实现是按需创建，即第一次获取bean时创建bean； 2. ApplicationContext会一次性创建所有的bean，ApplicationContext也创建了一些额外的功能，比如与Spring的AOP更容易继承，也提供了Message Resource的机制（用于处理国际化支持）和通知机制； 2、 ApplicationContext的常用实现类 - ClassPathXmlApplicationContext - 读取classpath，如果配置文件在当前系统类路径下，可以优先使用ClassPathXmlApplicationContext类 - FileSystemXmlApplicationContext - 读取指定路径下的资源，如果配置文件放在文件系统路径下，则可以优先使用ClassPathXmlApplicationContext类； 3、 容器管理对象 4、 Spring中Bean的实例 1.基于XML的配置方式转配Bean 无参构造方法实例化对象 如果不指定构造函数，会生成一个默认的无参构造函数；如果显性的指定有参构造函数，不会生成默认的构造函数，必须显性指定一个无参构造函数 静态工厂类实例化对象普通工厂实例化对象 通过工厂创建一个非静态方法得到对象；
配置文件中时同工厂的非静态方法返回对象；
2.基于注解方式装配Bean（自动装配） 基于注解形式进行bean的管理比bean 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/da3e27ea64aa4e16ded6b2d0bd3db310/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/182fbaba8406314cdbe8775ad6e327c2/" rel="bookmark">
			BeanFactory和ApplicationContext谁才是SpringIoC容器？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Spring-framework 官方文档
简单翻译
在org.springframework.beans和org.springframework.context包是Spring框架的IoC容器的基础。该 BeanFactory 界面提供了一种高级配置机制，能够管理任何类型的对象「这里提到的是管理对象，不是管理Bean」。ApplicationContext 是的子接口BeanFactory。它增加了：
与Spring的AOP功能轻松集成消息资源处理（用于国际化）事件发布应用层特定的上下文，例如WebApplicationContext 用于Web应用程序中的。 简而言之，BeanFactory提供了配置框架和基本功能，并ApplicationContext增加了更多针对企业的功能。该ApplicationContext是对一个完整的超集BeanFactory，并在Spring的IoC容器的描述本章独占使用。有关使用的详细信息BeanFactory，而不是ApplicationContext,看到 的BeanFactory。在Spring中，构成应用程序主干并由Spring IoC容器管理的对象称为bean。Bean是由Spring IoC容器实例化，组装和以其他方式管理的对象。否则，bean仅仅是应用程序中许多对象之一。Bean及其之间的依赖关系反映在容器使用的配置元数据中
BEANFACTORY 作为IOC容器
/** * {@link BeanFactory} 作为 IoC 容器示例 * * @author lisz (shangzhi.ibyte@gmail.com) */ public class BeanFactoryAsIoCContainerDemo { public static void main(String[] args) { // 创建 BeanFactory 容器 DefaultListableBeanFactory beanFactory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(beanFactory); // XML 配置文件 ClassPath 路径 String location = "classpath:/META-INF/dependency-lookup-context.xml"; // 加载配置 int beanDefinitionsCount = reader.loadBeanDefinitions(location); System.out.println("Bean 定义加载的数量：" + beanDefinitionsCount); // 依赖查找集合对象 lookupCollectionByType(beanFactory); } private static void lookupCollectionByType(BeanFactory beanFactory) { if (beanFactory instanceof ListableBeanFactory) { ListableBeanFactory listableBeanFactory = (ListableBeanFactory) beanFactory; Map&lt;String, User&gt; users = listableBeanFactory.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/182fbaba8406314cdbe8775ad6e327c2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f65a1c0541f037845eb5d3e20fa4d42e/" rel="bookmark">
			Orchestrator Failover过程源码分析-II
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Orchestrator Failover过程源码分析-II 书接上文Orchestrator Failover过程源码分析-I
DeadMaster恢复流程 首先通过getCheckAndRecoverFunction获取"checkAndRecoverFunction"
func getCheckAndRecoverFunction(analysisCode inst.AnalysisCode, analyzedInstanceKey *inst.InstanceKey) ( checkAndRecoverFunction func(analysisEntry inst.ReplicationAnalysis, candidateInstanceKey *inst.InstanceKey, forceInstanceRecovery bool, skipProcesses bool) (recoveryAttempted bool, topologyRecovery *TopologyRecovery, err error), isActionableRecovery bool, ) { switch analysisCode { // master case inst.DeadMaster, inst.DeadMasterAndSomeReplicas: // 如果analysisCode是DeadMaster 或 DeadMasterAndSomeReplicas if isInEmergencyOperationGracefulPeriod(analyzedInstanceKey) { // 首先判断是否处于 EmergencyOperationGracefulPeriod return checkAndRecoverGenericProblem, false // 如果处于EmergencyOperationGracefulPeriod, 则又相当于啥也没干, 等下一轮recoverTick } else { return checkAndRecoverDeadMaster, true } 这里先判断isInEmergencyOperationGracefulPeriod
func isInEmergencyOperationGracefulPeriod(instanceKey *inst.InstanceKey) bool { _, found := emergencyOperationGracefulPeriodMap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f65a1c0541f037845eb5d3e20fa4d42e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/07ceee4cb848e3b9fb64ec7854211b1b/" rel="bookmark">
			[转](3条消息) docker安装Mysql8.0的坑之lower(转载请删除括号里的内容)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(转载请删除括号里的内容)
docker安装Mysql8.0的坑之lower_case_table_names 有一只柴犬 2020-09-02 17:32:07 229 收藏
分类专栏： mysql
版权
目录
0、环境：
1、修改my.cnf（无效）：
2、docker指定--lower-case-table-names=1（特定情况无效）：
3、解决方案
0、环境： centos7、docker 17.12.1-ce、mysql 8.0.21
docker安装mysql命令：
docker run --name mysql --restart=always \
-v /home/mysql/conf/my.cnf:/etc/mysql/my.cnf \
-v /home/mysql/data:/var/lib/mysql \
-p 3317:3306 \
-e MYSQL_ROOT_PASSWORD="root" \
-e TZ=Asia/Shanghai \
-d mysql:8.0
[root@shamee shamee]# docker run --name mysql --restart=always -e MYSQL_ROOT_PASSWORD="root" -d mysql:8.0
222f3969bdb4a3c58da50707a73866c48cfd26f4c7b2feed32b56ae7de09b036
[root@shamee shamee]# docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
222f3969bdb4 mysql:8.0 "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/07ceee4cb848e3b9fb64ec7854211b1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f34c54deafc886c6b6506113fb9dfc8d/" rel="bookmark">
			SpringIOC 依赖注入
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 根据Bean名称注入根据Bean类型查找 单个bean 对象集合bean 对象 注入容器内建对象注入非Bean 对象注入类型 实时注入延迟注入 注入方式
接口注入Seter 注入注解注入构造注入 依赖来源
自定义Bean容器内建Bean 对象容器内建依赖 配个图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/26b03aaf256105ca55d5f3e3efb9a158/" rel="bookmark">
			SpringIOC 依赖查找
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 根据名称查找 实时查找延迟查找 根据Bean 类型查找 单个bean 对象集合bean 对象 根据Bean 名称➕类型查找根据注解查找 单个bean 对象集合bean 对象 配个图
下面找些简单例子做一个示范
首先，我们创建一个包含 spring-context 依赖的 maven 项目，然后定义一个 User.class
public class User { private long id; private String name; public long getId() { return id; } public void setId(long id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/26b03aaf256105ca55d5f3e3efb9a158/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba04da3fd73963b5fa51f4eb51581563/" rel="bookmark">
			2022-05-14 Druid源码阅读——Druid连接检查机制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.Druid提供的校验参数 Druid对于连接校验提供了六个参数，其中testOnBorrow、testOnReturn、testWhileIdle是Druid所提供的连接校验时点，其余三个参数为校验的相关配置。
配置缺省值说明validationQuery用来检测连接是否有效的sql，要求是一个查询语句，常用select ‘x’。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。validationQueryTimeout单位：秒，检测连接是否有效的超时时间。底层调用jdbc Statement对象的void setQueryTimeout(int seconds)方法testOnBorrowfalse申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。testOnReturnfalse归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。testWhileIdletrue建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。timeBetweenEvictionRunsMillis1分钟有两个含义：
(1) Destroy线程会检测连接的间隔时间，如果连接空闲时间大于等于minEvictableIdleTimeMillis则关闭物理连接。
(2) testWhileIdle的判断依据，详细看testWhileIdle属性的说明 2. Druid是如何进行连接校验的？ Druid依靠testConnectionInternal方法进行连接校验，如果当前连接池存在validConnectionChecker，则会利用validConnectionChecker进行校验，否则将利用一些内部状态以及执行校验SQL的方式进行探活，主要的校验方式都是以执行校验SQL进行校验，而MySQL可以使用PingMethod校验连接的有效性。
/** * 校验连接是否有效 * @param holder * @param conn * @return */ protected boolean testConnectionInternal(DruidConnectionHolder holder, Connection conn) { //此部分似乎是为了做监控用的 String sqlFile = JdbcSqlStat.getContextSqlFile(); String sqlName = JdbcSqlStat.getContextSqlName(); if (sqlFile != null) { JdbcSqlStat.setContextSqlFile(null); } if (sqlName != null) { JdbcSqlStat.setContextSqlName(null); } try { //判断当前连接池所持有的检查器是否为空 if (validConnectionChecker != null) { //调用检查器的教研方法进行教研 boolean valid = validConnectionChecker.isValidConnection(conn, validationQuery, validationQueryTimeout); long currentTimeMillis = System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba04da3fd73963b5fa51f4eb51581563/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/480a306935c32c43463bb3f23b107f8a/" rel="bookmark">
			拉斯维加斯算法 八皇后问题（C&#43;&#43;实现）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;iostream&gt; #include&lt;vector&gt; #include&lt;cstdlib&gt; using namespace std; //定义一个棋盘，初始化棋盘上没有放置任何王后 bool chess[8][8] = { {0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0}, {0,0,0,0,0,0,0,0}, }; //检测在row,col位置处放置王后是否与之前的王后放置冲突的函数 bool conflict(const int&amp; row, const int&amp; col) { //如果放入的是第一个王后，则一定不会产生冲突 if (row == 0) return false; //首先将棋盘上已经成功放置的每一行王后的列位置存入一个向量中 vector&lt;int&gt; ColPos; for (int i = 0; i &lt; row; i++) { for (int j = 0; j &lt; 8; j++) { if (chess[i][j] == true) { ColPos.push_back(j); break;//由于一行只可能有一个王后，因此找到王后后可以提前终止循环 } } } //检测当前放置的王后与之前的王后是否位于同一列（不检测同一行是因为算法本身就是一行一行放置的，不可能有两个王后位于同一行） for (int i = 0; i &lt; row; i++) { if (col == ColPos[i])//当存在一个之前的王后和当前所放置列相同时，返回冲突标志 return true; } //检测当前放置的王后和之前的王后是否位于同一斜线上，如果是则返回冲突标志 for (int i = 0; i &lt; row; i++) { int Row_dif = row - i; int Col_dif = ColPos[i] - col; if (Row_dif == Col_dif) return true; if (Row_dif == -Col_dif) return true; } //检测后如果不存在冲突，则返回不冲突标志 return false; } //自定义的基于拉斯维加斯概率算法和回溯法的用于进行王后放置的函数 void Queen(void) { int seed = 1;//制定随机数种子，初始化为1 srand(seed);//通过循环遍历来手动设置不同的随机情况 loop: for (int i = 0; i &lt; 8; i++) { //每一次在当前行随机放置一个王后 int pos = rand() % 8; int n = 1;//通过一百次随机数检测，如果仍然有冲突，则由概率原理可知该种情况无解，更换随机数种子进行下一种情况（重新开始摆盘） //检测是否与之前放置的王后有冲突，如果有冲突的话则随机放置在本行的另外一个位置 while (conflict(i, pos) &amp;&amp; n &lt; 100) { pos = rand() % 8; n++; } //当前情况无解时，将当前棋盘清空，更换随机数种子重新摆盘重复上述步骤 if (n &gt;= 100) { for (int i = 0; i &lt; 8; i++) { for (int j = 0; j &lt; 8; j++) { chess[i][j] = false; } } seed++; goto loop; } chess[i][pos] = true; } //输出得到的可行解 for (int i = 0; i &lt; 8; i++) { for (int j = 0; j &lt; 8; j++) { cout &lt;&lt; chess[i][j] &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/480a306935c32c43463bb3f23b107f8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dad36135dd4e57eee7d87da4d7848ff5/" rel="bookmark">
			在树莓派中用python连接emqx，时间长了失去订阅的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		开机测试过两次，一次是7天左右失去订阅，一次是三天。通过向树莓派订阅的主题下发控制指令发现树莓派没响应，看了其他人的经验后怀疑是偶尔的断网导致订阅失效。
在另一篇文章中翻到了paho-mqtt的文档，找到如下内容
需要将clean_session置为False，且只能在client_id不为空（为空默认生成随机id）的情况下设置。弄完后断网后再测试可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dba5f3731cbf6786c28d9a2f3ccba65/" rel="bookmark">
			【保姆级讲解】C语言---32个关键字精华
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言32个关键字 1.1类型关键字（12个） char、short、int、long、float、double、unsigned、signed、struct、union、enum、extern、static
1.2控制语句（12个） if、else、switch、for、while、do-while、case、break、continue、goto 、return、default
1.3存储类型（4个） auto、static、register、volatile
①auto在C语言中只有一个作用就是修饰局部变量，表示这个变量是自动变量，分配在栈上，平时定义的局部变量就是自动局部变量，只是省略了auto。
{int A =10;} A自动变量/局部变量 int A =10；===== auto int A =10;
②static关键字在C语言中有两种用法
A)第一种就是修饰局部变量：static修饰的局部变量只是改变了存储类型，其存储方式和全局变量一样，作用域和普通局部变量一样。
在子函数内定义的静态局部变量:分配至全局静态区;
B)第二种就是修饰全局变量和函数：static修饰全局变量和函数只是改变了他们的链接属性由外链接变为内链接(.C文件内)，全局变量和函数默认的链接属性为外链接（可以跨文件进行链接）
外链接侧重于工程中其它源文件;
内链接:侧重于当前的源文件;
本知识点联系函数:static相关知识点;
对全局变量进行修饰: 修饰全局变量和函数只是改变了他们的链接属性由外链接变为内链接(.C文件内)，全局变量和函数默认的链接属性为外链接（可以跨文件进行链接）.
③register这个关键字不常用，register修饰的变量，编译器会尽量将他们分配在寄存器中，（平时分配的一般变量都是在内存中，分配在寄存器中一样的用，但是读写效率会提高很多）。所以register修饰的变量通常是被反复高频率的使用，通过改善这个变量的访问效率可以极大的提升程序的运行效率。
总耗时比较;
浅析C语言的一个关键字——register_21aspnet的博客-CSDN博客_c语言register
④volatile （可变的 易变的） C语言中volatile用来修饰一个变量，表明这个变量可以被编译器之外的东西改变（编译器不可预知的东西，比如硬件自动更改了这个变量的值，一般这个变量是一个寄存器的值，比如在多线程中在别的线程更改了这个变量的值），如果不该加时加了会降低效率。
C语言中volatile关键字的作用 - 行路人&amp; - 博客园
1.4其他类型（4个） extern、const、typdef、sizeof
const：声明一个变量的值不可变，要求const修饰的变量在定义时必须进行初始化。 #include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main()
{
const int A=10; //初始化时进行赋值
return 0;
}
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main()
{
const int A;
A =10; //错误的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dba5f3731cbf6786c28d9a2f3ccba65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f639f5528ab62c35d2595d2daa64171/" rel="bookmark">
			OpenHarmony开发资料归档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
环境搭建操作篇
​编辑
测试篇
子系统篇
芯片移植适配篇
简单操作体验篇
源码解析篇
应用开发样例篇
版本特性解析篇
视频课程分享篇
开发者体验分享篇
书籍篇
正儿八经官方篇
好用链接
交流渠道篇
​​​​​​​
OpenHarmony是鸿蒙的开源版本，由华为捐赠给开放原子开源基金会（OpenAtom Foundation），定位是一款面向全场景的开源分布式操作系统。在传统的单设备系统能力的基础上，创造性地提出了基于同一套系统能力、适配多种终端形态的理念，支持多种终端设备上运行。
OpenHarmony是自主研发、全新技术生态的全领域下一代开源操作系统。它面向万物互联，是可运行在各种智能终端上的全新分布式操作系统。
OpenHarmony gitee代码官网
OpenHarmony开发大致流程
环境搭建操作篇 1、OpenHarmony代码操作总结
2、OpenHarmony-RK3568开发板操作梳理​​​​​​​​​​​​​​
​​​​​​​3、​​​​​​一种简单的OpenHarmony开发环境搭建
4、【OH 干货】如何向 OpenHarmony 社区提交代码
5、OpenHarmony应用开发（1）--配置OpenHarmony应用签名信息
6、OpenHarmony编译构建系统详解，从零搭建windows下开发环境，巨方便！
7、扬帆RK3399OpenHarmony开发板软件开发环境搭建
8、一文读懂在OpenHarmony轻量设备开发应用
9、鸿蒙开发必备书籍
10、OpenHarmony学习笔记——南向开发环境搭建
11、Linux下使用vscode在线调试STM32开发板
12 、OpenHarmony应用的签名配置的流程解析
13、OpenHarmony系统文档贡献的写作规范
14、Hi3861 通过UART串口协议与其它开发板进行通信
15、Openharmony添加自定义驱动的教程
16、支持开源鸿蒙系统 DAYU200 镜像烧录教程
17、OpenHarmony系统贡献代码流程
18、使用DevEco Studio3.0编译OHOS应用的过程
19、OpenHarmony3.0环境搭建-基于Ubuntu20.04
20、OpenHarmony学习笔记——南向开发环境搭建
21、 OpenHarmony 使用手册
22、鸿蒙研究站 | 每天死磕一点点http://weharmonyos.com/
23、OpenHarmony编译构建详解(Windows版)
测试篇 1.【OpenHarmony】测试代码编译执行流程
2.【OpenHarmony软总线】——告别代码，让Openharmony软总线测试用例跑起来！
3.OpenHarmony移植：XTS子系统之应用兼容性测试套件
4.OpenHarmony性能分析工具之hiperf
5.OpenHarmony XTS兼容性测试分享
6.移植案例与原理 - XTS子系统之应用兼容性测试套件
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f639f5528ab62c35d2595d2daa64171/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4948cbe4675311065a5a849dce805053/" rel="bookmark">
			Day4 多线程下对druid的测试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		多线程下对druid的测试 今天继续Case2, 和之前的Case0相比呢，是继续比较多个线程池的性能对比。这次不同的是，用100个线程并发去执行25000个数据库的连接并释放。我们今天不研究他们不同线程池的性能对比，研究下这个测试用例用到的多线程，并发相关的东西，看懂这段代码。
可以看到下面的代码是druid连接池的测试方法，核心方式是p0
public void test_0() throws Exception { DruidDataSource dataSource = new DruidDataSource(); dataSource.setInitialSize(initialSize); dataSource.setMaxActive(maxActive); dataSource.setMinIdle(minPoolSize); dataSource.setMaxIdle(maxPoolSize); dataSource.setPoolPreparedStatements(true); dataSource.setDriverClassName(driverClass); dataSource.setUrl(jdbcUrl); dataSource.setPoolPreparedStatements(true); dataSource.setUsername(user); dataSource.setPassword(password); dataSource.setValidationQuery(validationQuery); dataSource.setTestOnBorrow(testOnBorrow); for (int i = 0; i &lt; executeCount; ++i) { p0(dataSource, "druid", threadCount); } System.out.println(); } AtomicLong &amp; CountDownLatch 在p0中，看到定义了几个并发相关的类，原子类AtomicLong，并发工具类CountDownLatch,看到这两个熟悉又陌生的类差点给我送走，仔细回忆了下。
AtomicLong AtomicLong是一个线程安全的计数器，不会受多线程的影响。
CountDownLatch CountDownLatch是，初始一个数量这里面是100，每一次调用CountDown数量都会减1，
调用它的await方法，就会阻塞主线程，等待100归0后，才会继续执行。
如下面的代码中的startLatch，每个子线程的主方法体中，startLatch.await（）就是在等待CountDown=0时，所有的子线程一起开始执行方法体的内容。
private void p0(final DataSource dataSource, String name, int threadCount) throws Exception { final CountDownLatch startLatch = new CountDownLatch(1); final CountDownLatch endLatch = new CountDownLatch(threadCount); final AtomicLong blockedStat = new AtomicLong(); final AtomicLong waitedStat = new AtomicLong(); for (int i = 0; i &lt; threadCount; ++i) { Thread thread = new Thread() { public void run() { try { //每个子线程在等待，统一开始 startLatch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4948cbe4675311065a5a849dce805053/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6483b1f5fbe070638add36c67b4a424/" rel="bookmark">
			SwinIR实战：详细记录SwinIR的训练过程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 SwinIR实战：详细记录SwinIR的训练过程。下载训练代码数据集训练完整的代码： SwinIR实战：详细记录SwinIR的训练过程。 论文地址：https://arxiv.org/pdf/2108.10257.pdf
预训练模型下载：https://github.com/JingyunLiang/SwinIR/releases
训练代码下载：https://github.com/cszn/KAIR
测试代码：https://github.com/JingyunLiang/SwinIR
论文翻译：https://blog.csdn.net/hhhhhhhhhhwwwwwwwwww/article/details/124434886
测试：https://wanghao.blog.csdn.net/article/details/124517210
在写这边文章之前，我已经翻译了论文，讲解了如何使用SWinIR进行测试？
接下来，我们讲讲如何SwinIR完成训练，有于作者训练了很多任务，我只复现其中的一种任务。
下载训练代码 地址：https://github.com/cszn/KAIR
这是个超分的库，里面包含多个超分的模型，比如SCUNet、VRT、SwinIR、BSRGGAN、USRNet等模型。
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-B5Md9i7H-1651410061139)(https://gitee.com/wanghao1090220084/cloud-image/raw/master/img/face_09_comparison.png)]
下载后解压，训练SwinIR的REANDME.md,路径：./docs/README_SwinIR.md
数据集 训练和测试集可以下载如下。 请将它们分别放在 trainsets 和 testsets 中。
任务训练集测试集classical/lightweight image SRDIV2K (800 training images) or DIV2K +Flickr2K (2650 images)set5 + Set14 + BSD100 + Urban100 + Manga109 download allreal-world image SRSwinIR-M (middle size):
DIV2K (800 training images) +Flickr2K (2650 images) + OST (10324 images,sky,water,grass,mountain,building,plant,animal) SwinIR-L (large size): DIV2K + Flickr2K + OST + WED(4744 images) + FFHQ (first 2000 images, face) + Manga109 (manga) + SCUT-CTW1500 (first 100 training images, texts) RealSRSet+5imagescolor/grayscale image denoisingDIV2K (800 training images) + Flickr2K (2650 images) + BSD500 (400 training&amp;testing images) + WED(4744 images)grayscale: Set12 + BSD68 + Urban100 color: CBSD68 + Kodak24 + McMaster + Urban100 download allJPEG compression artifact reductionDIV2K (800 training images) + Flickr2K (2650 images) + BSD500 (400 training&amp;testing images) + WED(4744 images)grayscale: Classic5 +LIVE1 download all 我下载了DIV2K数据集和 Flickr2K数据集，DIV2K大小有7G+，Flickr2K约20G。如果网速不好建议只下载DIV2K。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6483b1f5fbe070638add36c67b4a424/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b72269e0d822da883e42e214811f812/" rel="bookmark">
			Debugger executable ‘/usr/local/bin/x86_64-elf-gdb‘ is not signed. &amp;&amp; 在汇编文件中打断点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现问题的原因：在vscode中使用gdb调试，出现“Debugger executable ‘/usr/local/bin/x86_64-elf-gdb’ is not signed. As a result, debugging may not work properly.”问题
按照下面这个步骤即可：
https://gcc.gnu.org/onlinedocs/gcc-4.8.1/gnat_ugn_unw/Codesigning-the-Debugger.html
需要注意的是，创建证书在这里找
另外在vscode汇编文件中打断点，需要开启一个设置：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d685145c769a961af0629557cf5eadf/" rel="bookmark">
			Android开发：基于Kotlin编写一个简易计算器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 前言Kotlin学习tips界面绘制及控件绑定UI界面绘制控件绑定Button点击事件 运算逻辑整体逻辑边界情况输入展示点击数字键点击运算符键点击“=”点击“clean”键在`onCreate()`方法里调用 成果展示后记 前言 本着程序员“拥抱变化”的思想，最近开始学Kotlin了。感觉还是得通过实战来入门一门新语言，所以打算写一个基于Kotlin语言的计算器，本文对开发过程以及学习Kotlin的一些知识进行了记录。
计算器的全部源码已经放到了我的Github中，需要的伙伴自取：Calculator
Kotlin学习tips Kotlin中文站：https://www.kotlincn.net/
这是Kotlin的官方中文网站，里面有Kotlin的介绍、入门使用以及Kotlin官方文档中文版等；Android开发者平台内对Kotlin编程的介绍页面：https://developer.android.google.cn/kotlin/first
Kotlin目前已经是Android官方推荐的编程语言，因此在Android开发者平台也有对使用Kotlin进行Android编程的方法介绍以及使用入门等。 界面绘制及控件绑定 UI界面绘制 使用TextView控件进行输入以及结果展示，使用Button控件充当按键。由于时间限制，这里直接使用LinearLayout布局进行实现，缺点是布局层级嵌套太多，总共嵌套了三层LinearLayout，有空的小伙伴们可以自行优化一下。布局文件代码如下：
&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:padding="15dp" &gt; &lt;TextView android:layout_width="match_parent" android:layout_height="0dp" android:layout_weight="1" android:text="Hello World!" android:textAllCaps="false" android:textSize="30sp" android:gravity="right|bottom" android:background="@drawable/bg_frame" android:padding="15dp" android:id="@+id/mtv_result" /&gt; &lt;LinearLayout android:layout_weight="3" android:layout_height="0dp" android:layout_width="match_parent" android:layout_marginTop="15dp" android:background="@drawable/bg_frame" android:orientation="vertical"&gt; &lt;LinearLayout android:layout_height="0dp" android:layout_width="match_parent" android:layout_weight="1" android:orientation="horizontal"&gt; &lt;Button android:textSize="28sp" android:layout_margin="5dp" android:padding="5dp" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:background="@drawable/bg_frame" android:text="+" android:id="@+id/btn_add"/&gt; &lt;Button android:textSize="28sp" android:layout_margin="5dp" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1" android:background="@drawable/bg_frame" android:text="-" android:id="@+id/btn_subtract"/&gt; &lt;Button android:textSize="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d685145c769a961af0629557cf5eadf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1687aa83d5ce3265e2a6108a4f23e6b7/" rel="bookmark">
			HashMap中put方法（白话加源码分析）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.首先不看代码用白话分析一下流程 我们在使用put方法的时候会传进key和value参数
在我们将这两个参数传入后，
第一步，我们的put方法会去判断这个hashmap是否为null 或者长度是否为0，如果是则对hashmap数组进行resize()扩容，
第二步，put方法会根据这个key计算hash码来得到数组的位置，（这里需要解释一下，我们的hashmap默认是由一个数组加链表组成的）
得到位置后当然是继续判断这个数组下标的值是否为null，为null 自然是直接插入我们的value值，如果不为空的话进行第三步
第三步，判断key是否为null，当key！=null我们就可以覆盖value值，key==null继续第四步
第四步，如果key值也为空，则判断结点类型是链表还是红黑树
第五步，如果节点类型为红黑树，则执行红黑树插入操作
如果节点类型为链表，那么put方法就会遍历这个链表，for循环遍历链表直至链表尾部，然后进行尾插，当链表长度&gt;=8时，会进入链表转红黑树的方法，treeifyBin方法中还会判断数组长度，数组长度&gt;=64,链表长度&gt;=8同时满足，才会将链表转为红黑树；在for循环遍历过程中，如果key相同，则直接插入元素
第五步，记录操作次数变量modCount+1，最后再判断当前map中有多少元素，和阈值做对比，如果超过阈值则进行扩容当数组容量超过最大容量时就会扩容一倍（即二进制的进位），没有则返回null。
put方法是由返回值的，在插入完成后，如果插入之前已经存在这个key，则返回的是插入之前已存在元素的value
二.图解 三.源码分析 //put方法，会先调用一个hash()方法，得到当前key的一个hash值， //用于确定当前key应该存放在数组的哪个下标位置 //这里的 hash方法，我们姑且先认为是key.hashCode()，其实不是的，一会儿细讲 public V put(K key, V value) { //返回调用putVal方法 return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { // tab指代是hashmap的散列表再，在下方初始化，hashmap不是在创建的时候初始化，而是在put的时候初始化，属于懒初始化 // p表示当前散列表元素 // n表示散列表数组长度 // i表示路由寻址的结果 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //判断是否为空，为空的话初始化，不为空对tab和n进行赋值 if ((tab = table) == null || (n = tab.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1687aa83d5ce3265e2a6108a4f23e6b7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8fbd0fd30b1087e5e7d2cef68127ff41/" rel="bookmark">
			解决“VirtualBox VERR_NEM_INIT_FAILED“问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 在win10上使用 VirtualBox创建虚拟机时，有时报"VERR_NEM_INIT_FAILED "错误，如图(1)所示。出现这种情况的原因是，Hyper-V、Container等选项卡没有关闭，VirtualBox软件版本过高等造成的。
解决方法如下：
屏蔽Windows选项卡里的相应功能屏蔽Windows安全中心的"内存完整性"选择低版本的VirtualBox，例如 VirtualBox v6.1.16 图(1) VirtualBox报"VERR_NEM_INIT_FAILED"错误 1、屏蔽Windows选项卡里的相应功能 按Win+D --&gt; 输入命令: optionalfeatures ，弹出Windows功能选项卡，依次屏蔽如下几个选项。
图(2) 打开Windows功能选项卡 图(3) 屏蔽与虚拟机相关的6项 a) 屏蔽"Hyper-V"选项卡
b) 屏蔽"Windows沙盒"选项卡
c) 屏蔽"容器"选项卡
d) 屏蔽"设备锁定"选项卡
e) 屏蔽"适用于Linux的Windows子系统"选项卡
f) 屏蔽"虚拟机平台"选项卡
2、屏蔽"内存完整性" 在桌面左下角点击[开始] --&gt; 设置 --&gt; Windows安全中心 —&gt; 设备安全性 --&gt; 内核隔离详细详细 --&gt; 关闭"内存完整性"选项卡，如图(3)所示。
图(4) 屏蔽"内存完整性" 3、安装低版本的VirtualBox VirtualBox版本过高，会出现不兼容的现象。这里推荐使用 VirtualBox v6.1.16，该版本的兼容性比较好。
win10上使用： https://download.virtualbox.org/virtualbox/6.1.16/VirtualBox-6.1.16-140961-Win.exe
Mac上使用： https://download.virtualbox.org/virtualbox/6.1.16/VirtualBox-6.1.16-140961-OSX.dmg
Ubuntu16上使用： https://download.virtualbox.org/virtualbox/6.1.16/virtualbox-6.1_6.1.16-140961Ubuntuxenial_amd64.deb
汇总下载： VirtualBox v6.1.16 提取码：97vg
4、重启电脑 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aae4b7777ea0e32a3b34a04618c2130b/" rel="bookmark">
			解决Missing essential plugin: com.intellij (platform prefix: null) please reinstall intellij idea
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 出现问题的原因：
从2020.3版本更新到2022.3
安装完之后就会
导致没办法启动
翻译过来就是：
缺少必备插件：
平台前缀：null
请从头开始重新安装intellij idea
但是我卸载之后重新安装还是有问题
解决方法 C:\Users\yjx\AppData\Roaming\JetBrains\IntelliJIdea2022.1\plugins
把这个路径下的文件删了
我删除了这三个
然后
C:\Users\yjx\AppData\Roaming\JetBrains\IntelliJIdea2022.1
这个路径下的idea64.exe.vmoptions文件
用记事本打开
在前面加一个#号 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2bb204fe5ea8e7b24e3d2bad42913265/" rel="bookmark">
			医学成像中的深度学习——基于PyTorch的3D 医学图像分割
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		深度学习和医学成像
计算机视觉领域深度网络的兴起为经典图像处理技术表现不佳的问题提供了最先进的解决方案。在图像识别的广义任务中，包括目标检测、图像分类和分割、活动识别、光流和姿态估计等问题，我们可以很容易地声称 DNN（深度神经网络）取得了卓越的性能。
随着计算机视觉的兴起，人们对医学成像领域的应用产生了浓厚的兴趣。尽管医学成像数据不是那么容易获得，但 DNN 似乎是对如此复杂和高维数据进行建模的理想候选者。
正如我们将看到的，医学图像通常是 3 维或 4 维的。该领域引起广泛关注的另一个原因是它对人类生活的直接影响。在美国，医疗差错是继心脏病和癌症之后的第三大死亡原因。因此，很明显，人类死亡的前三个原因与医学成像有关。这就是为什么预计到2023 年，医学影像中的人工智能和深度学习将创造一个超过 10 亿美元的全新市场。
3D医学图像分割的需求
医学图像中的3D 立体图像分割对于诊断、监测和治疗计划是必不可少的。我们将只使用磁共振图像 (MRI)。手动练习需要解剖知识，而且费用昂贵且耗时。另外，由于人为因素，它们可能不准确。尽管如此，自动体积分割可以节省医生的时间，并为进一步分析提供准确的可重复解决方案。
我们将从描述 MR 成像的基础开始，因为了解输入数据对于训练深度架构至关重要。然后，我们为读者提供可有效用于此任务的 3D-UNET 概述。
医学影像和核磁共振
医学成像旨在揭示隐藏在皮肤和骨骼中的内部结构，以及诊断和治疗疾病。医学磁共振(MR) 成像使用来自氢原子核的信号来生成图像。在氢核的情况下：当它暴露于外部磁场（表示为 B0）时，磁矩或自旋会像罗盘指针一样与磁场方向对齐。
所有恒定磁化强度都通过一个额外的射频脉冲旋转到另一个平面，该脉冲足够强并且施加的时间足够长以倾斜磁化强度。励磁后，磁化立即在另一个平面上旋转。旋转磁化在接收线圈中产生 MR 信号。然而，MR 信号由于两个独立的过程而迅速衰减，这两个过程会降低磁化强度，从而导致返回到激发前存在的稳定状态，从而产生所谓的T1 图像和 T2 磁共振图像. T1 弛豫与原子核对其周围的能量过剩有关，而 T2 弛豫是指各个磁化矢量开始相互抵消的现象。上述现象是完全独立的。因此，不同的强度代表不同的组织，如下图所示：
3D 医学图像表示
由于医学图像表示 3D 结构，因此处理它们的一种方法是使用 3D 体积的切片并执行常规的 2D 滑动卷积，如下图所示。假设红色矩形是一个 5x5 的图像块，可以用包含强度值的矩阵表示。体 素强度和核用 3x3 卷积核进行卷积，如下图所示。在相同的模式下，内核在整个 2D 网格（医学图像切片）上滑动，并且每次我们执行互相关。卷积的 5x5 补丁的结果存储在 3x3 矩阵中（出于说明目的没有填充），并在网络的下一层传播。
或者，您可以将它们表示为类似于中间层的输出。在深度架构中，我们通常有多个特征图，这实际上是一个 3D 张量。如果有理由相信附加维度之间存在模式，则执行 3D 滑动卷积是最佳选择。医学图像就是这种情况。与编码 2D 域中对象的空间关系的 2D 卷积类似，3D 卷积可以描述 3D 空间中对象的空间关系。由于2D 表示对于医学图像来说是次优的，我们将在这篇文章中选择不使用 3D 卷积网络。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2bb204fe5ea8e7b24e3d2bad42913265/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8f9f975ed96f7f1cdc0085941f6aa23/" rel="bookmark">
			基于K8S&#43;ingress改造vue&#43;nginx&#43;springcloud微服务（一）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背景 前端项目整体架构使用vue开发web/h5然后部署到nginx上,后端使用springlcoud+docker进行部署。由于不是很了解service mesh 相关内容因此只将原有容器改为k8s管理并部署。 Ingress介绍 Ingress 是对集群中服务的外部访问进行管理的 API 对象，典型的访问方式是 HTTP和HTTPS。
Ingress 可以提供负载均衡、SSL 和基于名称的虚拟托管。
必须具有 ingress 控制器【例如 ingress-nginx】才能满足 Ingress 的要求。仅创建 Ingress 资源无效。
基于docker的微服务架构 nginx 与nacos 集群为物理机其余应用均使用docker部署
K8S网络架构 ingress其实就是启动一个nginx pod 进行规则匹配与转发，因此通过ingress 对外暴露80端口，暴露方式为nodeport。
vue静态文件直接用nginx镜像打包，nginx作为容器进行发布不在用于负载均衡。
网管还是使用springcloud gateway，使用springcloud 组件进行服务治理
vue nginx，网管，微服务端口均使用clusterId模式，保证集群安全。
至此原spingcloud+docker ，vue+nginx的架构全部转移到k8s，通过k8s管理全部应用。
总结 虽然使用K8S进行容器管理但并未使用K8S下关于微服务治理的架构方案。其实在图中gateway的功能不但承担路由转发而且负责鉴权。而路由转发功能与ingress转发功能重叠因此会多进行一次网络转发。未来会调研service mesh相关方案通过side car 模式进行服务治理而不在使用应用本身方式进行服务治理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d689409c9b879a425cf7497373c32dd/" rel="bookmark">
			基于 Java 机器学习自学笔记 （第63-65天：集成学习之AdaBoost）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		注意：本篇为50天后的Java自学笔记扩充，内容不再是基础数据结构内容而是机器学习中的各种经典算法。这部分博客更侧重于笔记以方便自己的理解，自我知识的输出明显减少，若有错误欢迎指正！
目录
一、关于集成学习
1.1 集成学习
1.2 AdaBoost的过程
1.3 代码总览目录
二、基础代码准备-带权数据集
2.1 基础准备
2.2 权值调整规则
2.3 输出测试
三、基分类器的抽象类
3.1 基本参数说明与抽象方法定义
3.2 通用的准确度计算
四、树桩分类器
4.1 树桩分类器的二分分割思想
· 为什么是树桩？
· 随机选定属性列
· 什么是一次统计操作
· 分割
4.2 二分分割代码
4.3 测试数据分类以及基本测试
五、集成器设计
5.2 成员变量、构造函数与基础初始化函数一览
5.2 串行设计(分类器串行迭代)思想与代码
5.3 并行设计(分类与准确度)思想与代码
六、AdaBoost运行效果测试
一、关于集成学习 1.1 集成学习 所谓集成学习(ensemble learning)给人的感觉就是“ 以多胜优 ”，走群众的路线，众志成城，各自贡献自己的想法并相辅相成。专业来说，进行学习的过程中并不依赖某一个学习器，而是结合多个不同的学习器，或者同个学习器的不同参数环境，一般会获得比任意单个学习器都要好的性能，尤其是在这些学习器都是" 弱学习器 "的时候提升效果会很明显。（所谓弱学习器就是一个学习效率不太好，识别率只能略微超过50%的一类学习器）
西瓜书关于Boosting方面做了一个经典的分析（见公式8.1的推演），即假设有一个二分类问题\(y \in\{-1,+1\}\)和真实函数\(f\)，假定这个基本分类器\(h(x_{i})\)的错误率为\(\epsilon\)，即\(P(h_{i}(x)≠f(x))=\epsilon\)。然后我们利用简单投票的法则，结合\(T\)个基分类器，若有超过一半以上的基分离器正确，那么集成就是成功的：\[H(x)=\operatorname{sign}\left(\sum_{i=1}^{M} h_{i}(x)\right)\] （上式使用求和对于仅仅为+1/-1的二分类取值可以实现投票效果）
继续假设基学习器之间的错误率是相互独立的，那么可有Hoeffding不等式可得集成的错误率为：\[P(H(x) \neq f(x)) \leq \exp \left(-\frac{1}{2} M(1-2 \epsilon)^{2}\right)\] 关于Hoeffding不等式，鄙人数学能力有限暂且不给出说明，这里上面给出西瓜书的说明只是为了引出下面结论：上式表现出来随着个体学习器数目\(T\)的增大，集成错误率是呈现指数级的下降，最终趋于0。
当然上面的介绍是在每个学习器的误差相互独立的条件下推演出来的，但是在现实中，我们采用集成学习设计的诸多学习器都是针对同一个问题学习得到的，因此其彼此之间不可能完全独立。因此我们总是尽可能使得其变得独立，或者说增加基学习器的“多样性”。这些是目前集成学习正在突破的方向。而今天我们学习的Boosting正是针对个体学习器之间存在强依赖关系、必须串行生成的序列化方法。（与之对立的还有弱依赖、同时生成的并行化方法的Bagging和Random Forest）
1.2 AdaBoost的过程 Boosting作为将弱学习器叠加为强学习机的算法，是通过将先前的基学习器的错误样本在后续训练中持续收到关注的方法来调整和训练下一个样本集。其中，AdaBoost（Adapted Boost）是Boosting族算法的一个代表，其采用了指数作为衡量权重的代表，后续在代码中我会给出这个衡量公式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d689409c9b879a425cf7497373c32dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/208fc8def4ac9e246fef50f5099d0172/" rel="bookmark">
			日撸Java三百行：AdaBoost
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		集成学习 集成学习(ensemble learning)通过构建并结合多个学习器来完成学习任务,有时也被称为多分类器系统(multi-classifier svstem).一般结构:先产生一组“个体学习器”(individual learner)，再用某种策略将它们结合起来.个体学习器通常由一个现有的学习算法从训练数据产生.例如决策树算法、BP神经网络算法等,
“同质”（homogeneous）集成：集成中只包含同种类型的个体学习器,例如“决策树集成”中全是决策树,“神经网络集成”中全是神经网络.同质集成中的个体学习器亦称“基学习器”,相应的学习算法称为“基学习算法”(base learning algorithm).
“异质”（heterogenous）集成：集成中包含不同类型的个体学习器,例如同时包含决策树和神经网络,个体学习器一般不称为基学习器,常称为“组件学习器”.
学习器的选择：集成学习通过将多个学习器进行结合，常可获得比单一学习器显著优越的泛化性能.这对“弱学习器”尤为明显，因此集成学习的很多理论研究都是针对弱学习器进行的.但需注意的是,虽然从理论上来说使用弱学习器集成足以获得好的性能,但在实践中出于种种考虑，往往会使用比较强的学习器.
要获得好的集成,个体学习器应“好而不同”，即个体学习器要有一定的“准确性”，即学习器不能太坏,并且要有“多样性”.即学习器间具有差异.个体学习器的“准确性”和“多样性”本身就存在冲突.一般的,准确性很高之后,要增加多样性就需牺牲准确性.事实上,如何产生并结合“好而不同”的个体学习器,是集成学习研究的核心.
分类：根据个体学习器的生成方式,目前的集成学习方法大致可分为两大类,即a)个体学习器间存在强依赖关系、必须串行生成的序列化方法,以及b)个体学习器间不存在强依赖关系、可同时生成的并行化方法;前者的代表是Boosting,后者的代表是Bagging 和Random Forest.
Boosting boosting中不同的分类器是通过串行训练而获得的，每个新分类器都根据已训练出的分类器的性能来进行训练。boosting是通过集中关注被已有分类器错分的那些数据来获得新的分类器。由于boosting分类的结果是基于所有分类器的加权求和结果的,且分类器权重并不相等，每个权重代表的是其对应分类器在上一轮迭代中的成功度。boosting方法拥有多个版本，其中最流行的版本AdaBoost。
AdaBoost AdaBoost是英文"Adaptive Boosting"（自适应增强）的缩写，AdaBoost方法的自适应在于：前一个分类器分错的样本会被用来训练下一个分类器。AdaBoost方法是一种迭代算法，在每一轮中加入一个新的弱分类器，直到达到某个预定的足够小的错误率。每一个训练样本都被赋予一个权重，表明它被某个分类器选入训练集的概率。如果某个样本点已经被准确地分类，那么在构造下一个训练集中，它被选中的概率就被降低；相反，如果某个样本点没有被准确地分类，那么它的权重就得到提高。通过这样的方式，AdaBoost方法能“聚焦于”那些较难分（更富信息）的样本上。
AdaBoost的运行过程：
（1）训练数据中的每个样本，并赋予其一个权重，这些权重构成了向量 D D D ,一开始这些权重都初始化成相等值
（2）首先在训练数据上训练出一个弱分类器并计算该分类器的错误率，然后在同一数据集上再次训练弱分类器。
（3）在分类器的第二次训练当中，将会重新调整每个样本的权重，其中第一次分对的样本的
权重将会降低，而第一次分错的样本的权重将会提高.
为了从所有弱分类器中得到最终的分类结果，AdaBoost为每个分类器都分配了一个权重值 α \alpha α， 这些 α \alpha α值是基干每个弱分类器的错误
率进行计算的。其中，错误率 ε \varepsilon ε的定义为:
ε = 未 分 类 正 确 样 本 数 目 所 有 样 本 数 目 \varepsilon=\frac{未分类正确样本数目}{所有样本数目} ε=所有样本数目未分类正确样本数目​
α = 1 2 l n ( 1 − ε ε ) \alpha=\frac{1}{2}ln(\frac{1-\varepsilon}{\varepsilon}) α=21​ln(ε1−ε​)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/208fc8def4ac9e246fef50f5099d0172/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/199249ce4abc39b345c0aa4dca7b2a36/" rel="bookmark">
			实操 | Hive 数据倾斜问题定位排查及解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实操 | Hive 数据倾斜问题定位排查及解决
多数介绍数据倾斜的文章都是以大篇幅的理论为主，并没有给出具体的数据倾斜案例。当工作中遇到了倾斜问题，这些理论很难直接应用，导致我们面对倾斜时还是不知所措。
今天我们不扯大篇理论，直接以例子来实践，排查是否出现了数据倾斜，具体是哪段代码导致的倾斜，怎么解决这段代码的倾斜。
当执行过程中任务卡在 99%，大概率是出现了数据倾斜，但是通常我们的 SQL 很大，需要判断出是哪段代码导致的倾斜，才能利于我们解决倾斜。通过下面这个非常简单的例子来看下如何定位产生数据倾斜的代码。
表结构描述
先来了解下这些表中我们需要用的字段及数据量：
表的字段非常多，此处仅列出我们需要的字段
第一张表：user_info （用户信息表，用户粒度）
字段名字段含义字段描述userkey用户 key用户标识idno用户的身份证号用户实名认证时获取phone用户的手机号用户注册时的手机号name用户的姓名用户的姓名 user_info 表的数据量：1.02 亿，大小：13.9G，所占空间：41.7G（HDFS三副本）
第二张表：user_active （用户活跃表，用户粒度）
字段名字段含义字段描述userkey用户 key用户没有注册会分配一个 keyuser_active_at用户的最后活跃日期从埋点日志表中获取用户的最后活跃日期 user_active 表的数据量：1.1 亿
第三张表：user_intend（用户意向表，此处只取近六个月的数据，用户粒度）
字段名字段含义字段描述phone用户的手机号有意向的用户必须是手机号注册的用户intend_commodity用户意向次数最多的商品客户对某件商品意向次数最多intend_rank用户意向等级用户的购买意愿等级，级数越高，意向越大 user_intend 表的数据量：800 万
第四张表：user_order（用户订单表，此处只取近六个月的订单数据，用户粒度）
字段名字段含义字段描述idno用户的身份证号下订单的用户都是实名认证的order_num用户的订单次数用户近六个月下单次数order_amount用户的订单总金额用户近六个月下单总金额 user_order 表的数据量：640 万
1. 需求 需求非常简单，就是将以上四张表关联组成一张大宽表，大宽表中包含用户的基本信息，活跃情况，购买意向及此用户下订单情况。
2. 代码 根据以上需求，我们以 user_info 表为基础表，将其余表关联为一个宽表，代码如下：
select a.userkey, a.idno, a.phone, a.name, b.user_active_at, c.intend_commodity, c.intend_rank, d.order_num, d.order_amount from user_info a left join user_active b on a.userkey = b.userkey left join user_intend c on a.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/199249ce4abc39b345c0aa4dca7b2a36/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/237/">«</a>
	<span class="pagination__item pagination__item--current">238/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/239/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>