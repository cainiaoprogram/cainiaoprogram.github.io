<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42a002e86e7df1cb4ff2d71109bf8695/" rel="bookmark">
			kmeans聚类算法及matlab实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、kmeans聚类算法介绍： kmeans算法是一种经典的无监督机器学习算法，名列数据挖掘十大算法之一。作为一个非常好用的聚类算法，kmeans的思想和实现都比较简单。kmeans的主要思想：把数据划分到各个区域(簇)，使得数据与区域中心的距离之和最小。换个角度来说，kmeans算法把数据量化为聚类中心，其目标函数就是使量化过程中损失的“信息”最少。kmeans算法求解目标函数的过程也可以看做是EM(Expectation maximization)迭代优化。
二、kmeans目标函数及优化： 定义：数据集 XN×D ，聚类中心 UK×D ，指示矩阵 rN×K 。 其中 rnk=1 如果第n个样本属于第k个聚类，否则 rnk=0 。kmeans 聚类算法的目标是让数据与相应的聚类中心的距离之和最小： P=∑n=1N∑k=1Krnk∥xn−uk∥2 迭代优化：未知变量是两个矩阵–聚类中心 UK×D 和指示矩阵 rN×K ，直接进行优化太困难（NP问题），所以需要迭代优化这两个变量来得到一个局部最优解。 1、固定聚类中心 UK×D ，优化指示矩阵 rN×K ：如果第n个样本距离第k个聚类最近，则赋值 rnk=1 ，否则赋值 rnk=0 。 2、固定指示矩阵 rN×K ，优化聚类中心 UK×D ：拆分目标函数，分开优化每一个聚类中心（聚类中心之间没有耦合关系），推导如下 P=∑k=1K∑n=1Nrnk∥xn−uk∥2min∑n=1Nrnk∥xn−uk∥2,k=1,...,K平方误差函数，直接求导：2∑n=1Nrnk(xn−uk)=0uk=(∑n=1Nrnkxn)/(∑n=1Nrnk),即率属于第k个聚类的数据均值 从EM角度来看：把指示矩阵 rN×K 当做隐变量，聚类中心 UK×D 当做模型参数，更新 rN×K 和 UK×D 就分别对应于EM算法的E步和M步。 三、判停标准： kmeans算法的迭代优化过程一直持续直到满足某个判停标准，如果在这一轮迭代中：
1、训练样本所属类别不再发生改变或者只有很少几个训练样本改变； 2、目标函数变化很小或者聚类中心向量变化很小； 3、达到最大迭代次数。
满足其中一个条件，即可停止训练。如果满足条件1或2，说明算法已经收敛。
四、K值的选取： 随着聚类数K的增大，目标函数呈减小趋势。但是另一方面K值的增大会导致存储空间和计算量的增加。那么如何选择合适的K值呢？ 1.经验法：根据问题的性质和先验知识，人为指定聚类的数目。 2.爬山法：但当聚类数目到达一定值以后，聚类数目的增加目标函数的变化很小，这个拐点可以认为是最优聚类数目。
五、matlab计算数据与聚类中心之间的距离 matlab诞生的初衷就是为了矩阵运算的方便，所以如果用for循环来计算数据与聚类中心的距离从而得到指示矩阵 rN×K 这种速度极慢的方法是不可取的。对欧氏距离函数做个小小的变换： ∥xn−uk∥2=(xn−uk)⋅(xn−uk)⊤,n=1,...,N,k=1,...,K=xn⋅x⊤n+uk⋅u⊤k−2xn⋅u⊤k=∥xn∥2+∥uk∥2−2xn⋅u⊤k matlab代码（借鉴一下大牛的代码）：
function n2 = sp_dist2(x, c) % DIST2 Calculates squared distance between two sets of points.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42a002e86e7df1cb4ff2d71109bf8695/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a36069b72c42ed3b1d64f0b493a7136d/" rel="bookmark">
			VBScript，提取字符串中的一部分
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 是我肤浅了，直接用Instr函数或InstrRev就可以。
data = "湖东路99号标力大厦2楼" data2 = "鼓楼区五四路159号世界金龙大厦5层" sep = "区" msgbox instr(data2,sep) msgbox left(data2, instr(data2,sep)) ————————————————————————以下为原文————————————————————————————
不知道是否有更快捷的方法。
需求：如果地址中包括“区”，则输出区和之后的地址；不包括，则输出空值和原地址。
Dim firstString,otherString data = "湖东路99号标力大厦2楼" data2 = "鼓楼区五四路159号世界金龙大厦5层" sep = "区" divideString data,sep msgbox firstString&amp;vbCrlf&amp;otherString divideString data2,sep msgbox firstString&amp;vbCrlf&amp;otherString Function divideString(data,sep) Dim array array = split(data,sep,-1,1) if ubound(array) &gt; 0 Then firstString = array(0)&amp;sep otherString = Right(data, len(data)-len(array(0)&amp;sep)) else firstString = "" otherString = data end if End Function 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dfc7109f45dc50a1ec8fb59f35f597a1/" rel="bookmark">
			阶跃响应指标的matlab计算
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文地址：阶跃响应指标的matlab计算 作者：了凡春秋 最近师兄让帮忙计算阶跃响应的指标，就是改定实验数据或仿真数据，求响应指标（概念见程序中）。编程代码和效果如下
%% 求阶跃响应的典型指标
function main_GetPerformanceOfStepResponse
clc
clear all
close all
global gTolerance
gTolerance = 0.05; % 调整时间的偏差容许范围
%% test
wn = 1;
xi = 0.3;
g = tf(wn^2, [1, 2*xi*wn, wn^2]);
t = 0:0.01:15;
y = step(g,t);
%% 计算阶跃响应的指标
stepvalue = 1;
[OverShoot, RiseTime, PeakTime, AdjustTime, SteadyStateError] = GetPerformanceOfStepResponse(t, y, stepvalue);
% 绘图
figure
plot(t,y)
grid on
line([PeakTime, PeakTime], [0, (1 + OverShoot/100)*stepvalue], 'color', 'r')
text(PeakTime, stepvalue*0.05, sprintf('峰值时间%.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dfc7109f45dc50a1ec8fb59f35f597a1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e449cf10ae6de811f01f64c323cd596c/" rel="bookmark">
			异常处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.相关概念的介绍 1）异常情形：是指阻止当前方法或作用域继续执行的问题。
2）监控区域：一段可能产生异常的代码，并且后面跟着处理这些异常的代码。
3）try块：如果在方法的内部或者在方法内部调用某个方法抛出异常，这个方法将在抛出异常的过程中结束，如果不希望该方法结束，可以在方法内设置一个特殊的块来捕获异常，这个块就叫做try块
4）异常处理程序：抛出的异常必须在某个地方进行处理，处理这个异常的地方就叫异常处理程序。
5）异常处理理论上有两种基本模型：java支持终止模型，还有一种是恢复模型
a)终止模型：将假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行，一旦异常被抛出，就表明错误已经无法挽回，也不能回来继续执行。
b)恢复模型：异常处理程序的工作室修正错误，然后重新尝试调用出问题的方法，并认为第二次能成功，恢复模型，通过希望异常被处理之后能继续执行程序。
注：恢复模型不实用的原因是它可能导致耦合：恢复性的处理程序需要了解异常抛出的地点，这势必要包含依赖于抛出位置的非通用性代码，而且增大了代码的编写和维护的困难。
6）异常说明：java提供了相应的语法，使你能够以礼貌的方式告知客户端程序员某个方法 可能会抛出异常，然后客户端程序员就可以进行相应的处理。
7）被检查的异常：在编译时被强制检查的异常。
8）异常链：在捕获一个异常后抛出另外一个异常，并且希望把原始异常的信息保存下来。
9）一个类的子类只能抛出比基类异常更具体的异常，而不能抛出比基类所抛出异常范围更大的异常。
2.异常参数 1）用new在堆上创建异常对象，此时也有存储空间的分配和构造器的调用，所有标准异常类都有两个构造器：一个是默认的构造器，一个是接受字符串为参数，能把相关信息放入异常对象的构造器。
2）关键字throw,它是在使用new创建异常对象之后，然后将此对象的引用传给throw。
3）Throwable是异常的根类，它能够抛出任意类型的Throwable对象。
3.异常处理程序 1）每个要捕的异常，得准备相应的处理程序，异常处理程序紧跟在try块之后，用关键字catch表示。
2）每个catch子句只能接受一个且仅仅接受一个特殊类型的参数的方法，可以在处理程序的内部使用标识符。
3）异常处理程序catch块必须紧跟在try块之后，当有异常被抛出的时候，异常处理机制将负责搜寻参数与异常类型相匹配的第一个程序。然后进入相应的catch子句进行执行，此时认为异常得到了处理。一旦catch子句结束，则处理程序的查找过程也会结束。
注：只有匹配的catch子句才能得到执行。
4.关于自定义异常 有的时候可以不用异常体系中的异常，可以自己创建一个异常类型，如果要自定义异常，则必须从已有的异常类进行继承，最好是选择意思相近的异常类继承，建立新的异常类型最简单的方法就是让编译器为你产生默认的构造器。
5.throws关键字（异常说明） 异常说明是方法声明的一部分，紧跟在形式参数列表之后，异常说明使用了附加的关键字throws，后面接一个所有潜在异常类型的参数列表。
6.在进行异常处理的时候，最好把Exception异常放在异常处理程序的末尾，防止它在其他子异常进行捕获的时候抢先捕获异常，因为它是所有异常类的根基类。 7.JAVA标准异常 1）Throwable是用来表示任何可以作为异常抛出的类，Throwable对象可以分为两个类型：
a)Error类型：用来表示编译时和系统的错误（除了特殊情况以外，一般不用关心）
b)Exception类型：是可以被抛出的基本类型。
8.finally关键字 1）无论异常是否被抛出，finally子句总是可以被执行
2）JAVA在什么时候才能用到finally：
当要把除内存之外的资源恢复到它们的初试状态时，就要用到finally子句。这种需要清理的资源包括：已经打开的文件或者网络链接，在屏幕上画的图形等等
3）当涉及到break或者continue语句的时候，finally子句也会得到执行，如果把finally子句和带标签的break和continue子句配合使用，在java里就没有必要使用goto语句
4)在return中使用finally(笔试的时候这个题很常见在异常处理的读程序题中)
因为finally子句总是会执行的，所以在一个方法中，可以从多个点返回，并且可以保证重要的清理工作仍然会执行。
9.异常的匹配 在抛出异常的时候，异常处理系统会按照代码的书写顺序找出“最近”的处理程序。找到匹配的处理程序之后，他就认为异常将得到处理，然后就不会继续的查找。
10.异常处理的一个重要原则就是：只有在指导如何处理的情况下才捕获异常； 异常处理的一个重要目标就是把错误处理的代码同错误发生的地点相分离。
11.异常应该在这些情况下被使用： 1）再恰当的级别处理问题，前提是要知道该如何处理的情况下才可以捕获异常
2）解决问题并且重新调用产生异常的方法
3）进行少许的修补，然后绕过异常发生的地方继续执行
4）用别的数据进行计算，以代替方法预计会返回的值
5）把当前运行环境下能做的事尽量做完，然后把相同的异常抛到更高的层次
6）把当前运行环境下能做的事尽量做完，然后把相同的异常抛到更低的层次
7）终止程序
8）进行简化
9）让类库和程序更加安全。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2f51fad6c0401585d125998db2c8d10a/" rel="bookmark">
			scala与java的性能对比
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 scala与java的性能对比 http://www.cnblogs.com/superjt/archive/2012/04/22/2465348.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff57ba840e9dd4100823d824ac3f9fdc/" rel="bookmark">
			EXCEL数据导入的三种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、文本导入 2、数据库导入 3、网站数据导入 来自 “ ITPUB博客 ” ，链接：http://blog.itpub.net/2525/viewspace-1823139/，如需转载，请注明出处，否则将追究法律责任。 转载于:http://blog.itpub.net/2525/viewspace-1823139/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aaeea0668984ad09e5bc8f99c5bcf465/" rel="bookmark">
			解决使用iso作为apt源时的WARNING_The_following_packages_cannot_be_authenticated
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 《解决使用iso作为apt源时的WARNING: The following packages cannot be authenticated!》 网上的将iso作为apt源的方法，基本都是如下几步（以debian为例）： 1. mkdir /mnt/iso 2. 编辑/etc/fstab，添加如下内容： /path/debian.iso /mnt/iso udf,iso9660 loop 0 0 3. 编辑/etc/apt/sources.list，添加如下内容： deb file:///mnt/iso/ wheezy main contrib 4. 如果做完前3步之后没重启的话，则执行如下命令： mount /mnt/iso/ 5. apt-get update 但是，做完以上步骤后， 当sources.list中只有iso的apt源时，使用apt-get安装软件会出现如下警告： WARNING: The following packages cannot be authenticated! 当sources.list中有其它的网络apt源时，使用apt-get安装软件时，还会从网络上下载安装包， 并且下载的安装包版本不比iso中的新。 前一种情况是因为，没有对/mnt/iso中包进行签名验证； 后一种情况是因为，网络上的apt源一般是已验证好的，且apt-get会优先选择已验证好的。 对/mnt/iso中的包进行验证比较麻烦， 且本地的iso一般都是可信任的，因为我们一般都会使用官方的checksum进行校验。 所以，能不能使apt-get信任本地的iso的apt源呢？ 通过查看man sources.list，发现了trusted=yes这个option， 于是，将添加到/etc/apt/sources.list中的内容改为如下： deb [ trusted=yes ] file:///mnt/iso/ wheezy main contrib 并且，iso的apt源在网络apt源的前边， 因为如果多个apt源中的包版本相同时会优先选择前边的apt源。 此时使用apt-get安装软件， 如果iso的apt源中的包版本不比网络apt源中的旧时，就会自动选择iso的apt源进行安装， 否则，就会使用网络apt源中的包来安装。 这是我们所希望的效果。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc54189d734e54044025f93120f4c36c/" rel="bookmark">
			mac 邮件自动归类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		mac 让邮箱自动为你的邮件归类 不知道你的工作当中，是否每天会收到一大推的邮件，其中对自己有价值的邮件也许也就是这一大推邮件当中的几封邮件...单这几封邮件往往又会被淹没
巧用邮件分类功能 之前使用邮件没有好好的区研究过邮件的app，直到有一天，我在清理邮件时把一封很重要的邮件删掉了...一直没能恢复。我想，邮箱也许都应该自动分类功能吧，只是我没有去好好研究这些常用的邮件app。于是我仔细看了下mac下自带的邮件，发现还真有我想要的功能，而且还很强大，直接贴图了
1.先打开设置，选规则
2.创建自己的规则，有很多类型的规则可选，也可以随意组合
我们创建号自己的规则，应用后，邮件就会按照你的规则自动分类了，是不是在也不用到月底手动分类管理了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31950ed9326c5daea9e3bea0ad6a53ea/" rel="bookmark">
			How To:配置Linux iSCSI客户端
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、安装客户端
[root@node01 Packages]# rpm -Uvh iscsi-initiator-utils-6.2.0.873-2.el6.x86_64.rpm warning: iscsi-initiator-utils-6.2.0.873-2.el6.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID fd431d51: NOKEY Preparing... ########################################### [100%] 1:iscsi-initiator-utils ########################################### [100%] [root@node01 Packages]# rpm -q iscsi-initiator-utils iscsi-initiator-utils-6.2.0.873-2.el6.x86_64 2、设置服务自启动
[root@node01 Packages]# chkconfig --list | grep iscsi iscsi 0:off 1:off 2:off 3:on 4:on 5:on 6:off iscsid 0:off 1:off 2:off 3:on 4:on 5:on 6:off [root@node01 ~]# chkconfig iscsid on [root@node01 ~]# chkconfig iscsi on [root@node01 ~]# chkconfig --list | grep iscsi iscsi 0:off 1:off 2:on 3:on 4:on 5:on 6:off iscsid 0:off 1:off 2:on 3:on 4:on 5:on 6:off 【此处Linux的版本为RHEL 6.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/31950ed9326c5daea9e3bea0ad6a53ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f60be4996676ee4873373aa45580cad6/" rel="bookmark">
			STM32F103C8T6低功耗测试（待机模式）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		只测试了待机模式，待机模式实现系统的最低功耗。 原理图如下，一开始全部焊接了，其中S2用来进入待机，S1用来唤醒 测试程序为：
#include "stm32f10x.h" #include "system_stm32f10x.h"v oid Sys_Standby(void) { RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR, ENABLE); //使能PWR外设时钟 PWR_WakeUpPinCmd(ENABLE); //使能唤醒管脚功能 PWR_EnterSTANDBYMode(); //进入待机（standby）模式 } //系统进入待机模式 void Sys_Enter_Standby(void) { RCC_APB2PeriphResetCmd(0X01FC,DISABLE); //复位所有IO口，屏蔽这条语句也没有看到什么影响 Sys_Standby(); } void IO_Init(void) { GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6; //PB6上拉输入，对应按键S2 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOB, &amp;GPIO_InitStructure); } int main() { IO_Init(); while(1) { if(GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_6) == 0) { Sys_Enter_Standby(); } } } 电流的测量用的是万用表，串联在电源的输入端，也就是说，实际测量的电流值为电路板消耗电流。电机、喇叭、OLED-0.9寸屏这些外部器件均未接入。 系统时钟选择外部8M晶振，电源为电脑USB口取电，上电后按下S2，进入待机模式，按下S1唤醒。 上电， 正常运行电流7.9mA，待机电流205uA，待机电流比较大； 取下DS1302芯片，正常运行电流7.9mA，待机电流10.5uA； 再取下DS1302芯片的三个上拉电阻，和上面一样，没变化；（看来即便有外部上拉，在待机模式时也是不用管的，只是不知道这上拉电阻接到了外围芯片上对外围电路的功耗有怎样的影响。） 再取下AT24C02芯片模块，正常电流7.7mA，待机电流10.5uA; 再取下L9110S电机驱动芯片，正常电流7.7mA，待机电流10.5uA，没有变化； 再取下SK040G语音芯片，就剩电源和按键部分了，正常电流7.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f60be4996676ee4873373aa45580cad6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d29981e4b8f57d49540af86d49ab303d/" rel="bookmark">
			Yarn 调度器Scheduler详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		理想情况下，我们应用对Yarn资源的请求应该立刻得到满足，但现实情况资源往往是有限的，特别是在一个很繁忙的集群，一个应用资源的请求经常需要等待一段时间才能的到相应的资源。在Yarn中，负责给应用分配资源的就是Scheduler。其实调度本身就是一个难题，很难找到一个完美的策略可以解决所有的应用场景。为此，Yarn提供了多种调度器和可配置的策略供我们选择。
一、调度器的选择 在Yarn中有三种调度器可以选择：FIFO Scheduler ，Capacity Scheduler，FairS cheduler。
FIFO Scheduler把应用按提交的顺序排成一个队列，这是一个先进先出队列，在进行资源分配的时候，先给队列中最头上的应用进行分配资源，待最头上的应用需求满足后再给下一个分配，以此类推。
FIFO Scheduler是最简单也是最容易理解的调度器，也不需要任何配置，但它并不适用于共享集群。大的应用可能会占用所有集群资源，这就导致其它应用被阻塞。在共享集群中，更适合采用Capacity Scheduler或Fair Scheduler，这两个调度器都允许大任务和小任务在提交的同时获得一定的系统资源。
下面“Yarn调度器对比图”展示了这几个调度器的区别，从图中可以看出，在FIFO 调度器中，小任务会被大任务阻塞。
而对于Capacity调度器，有一个专门的队列用来运行小任务，但是为小任务专门设置一个队列会预先占用一定的集群资源，这就导致大任务的执行时间会落后于使用FIFO调度器时的时间。
在Fair调度器中，我们不需要预先占用一定的系统资源，Fair调度器会为所有运行的job动态的调整系统资源。如下图所示，当第一个大job提交时，只有这一个job在运行，此时它获得了所有集群资源；当第二个小任务提交后，Fair调度器会分配一半资源给这个小任务，让这两个任务公平的共享集群资源。
需要注意的是，在下图Fair调度器中，从第二个任务提交到获得资源会有一定的延迟，因为它需要等待第一个任务释放占用的Container。小任务执行完成之后也会释放自己占用的资源，大任务又获得了全部的系统资源。最终的效果就是Fair调度器即得到了高的资源利用率又能保证小任务及时完成。
Yarn调度器对比图: 二、Capacity Scheduler（容器调度器）的配置 2.1 容器调度介绍 Capacity 调度器允许多个组织共享整个集群，每个组织可以获得集群的一部分计算能力。通过为每个组织分配专门的队列，然后再为每个队列分配一定的集群资源，这样整个集群就可以通过设置多个队列的方式给多个组织提供服务了。除此之外，队列内部又可以垂直划分，这样一个组织内部的多个成员就可以共享这个队列资源了，在一个队列内部，资源的调度是采用的是先进先出(FIFO)策略。
通过上面那幅图，我们已经知道一个job可能使用不了整个队列的资源。然而如果这个队列中运行多个job，如果这个队列的资源够用，那么就分配给这些job，如果这个队列的资源不够用了呢？其实Capacity调度器仍可能分配额外的资源给这个队列，这就是“弹性队列”(queue elasticity)的概念。
在正常的操作中，Capacity调度器不会强制释放Container，当一个队列资源不够用时，这个队列只能获得其它队列释放后的Container资源。当然，我们可以为队列设置一个最大资源使用量，以免这个队列过多的占用空闲资源，导致其它队列无法使用这些空闲资源，这就是”弹性队列”需要权衡的地方。
2.2 容器调度的配置 假设我们有如下层次的队列：
root ├── prod └── dev ├── eng └── science 下面是一个简单的Capacity调度器的配置文件，文件名为capacity-scheduler.xml。在这个配置中，在root队列下面定义了两个子队列prod和dev，分别占40%和60%的容量。需要注意，一个队列的配置是通过属性yarn.sheduler.capacity.&lt;queue-path&gt;.&lt;sub-property&gt;指定的，&lt;queue-path&gt;代表的是队列的继承树，如root.prod队列，&lt;sub-property&gt;一般指capacity和maximum-capacity。
我们可以看到，dev队列又被分成了eng和science两个相同容量的子队列。dev的maximum-capacity属性被设置成了75%，所以即使prod队列完全空闲dev也不会占用全部集群资源，也就是说，prod队列仍有25%的可用资源用来应急。我们注意到，eng和science两个队列没有设置maximum-capacity属性，也就是说eng或science队列中的job可能会用到整个dev队列的所有资源（最多为集群的75%）。而类似的，prod由于没有设置maximum-capacity属性，它有可能会占用集群全部资源。
Capacity容器除了可以配置队列及其容量外，我们还可以配置一个用户或应用可以分配的最大资源数量、可以同时运行多少应用、队列的ACL认证等。
2.3 队列的设置 关于队列的设置，这取决于我们具体的应用。比如，在MapReduce中，我们可以通过mapreduce.job.queuename属性指定要用的队列。如果队列不存在，我们在提交任务时就会收到错误。如果我们没有定义任何队列，所有的应用将会放在一个default队列中。
注意：对于Capacity调度器，我们的队列名必须是队列树中的最后一部分，如果我们使用队列树则不会被识别。比如，在上面配置中，我们使用prod和eng作为队列名是可以的，但是如果我们用root.dev.eng或者dev.eng是无效的。
三、Fair Scheduler（公平调度器）的配置 3.1 公平调度 Fair调度器的设计目标是为所有的应用分配公平的资源（对公平的定义可以通过参数来设置）。在上面的“Yarn调度器对比图”展示了一个队列中两个应用的公平调度；当然，公平调度在也可以在多个队列间工作。举个例子，假设有两个用户A和B，他们分别拥有一个队列。当A启动一个job而B没有任务时，A会获得全部集群资源；当B启动一个job后，A的job会继续运行，不过一会儿之后两个任务会各自获得一半的集群资源。如果此时B再启动第二个job并且其它job还在运行，则它将会和B的第一个job共享B这个队列的资源，也就是B的两个job会用于四分之一的集群资源，而A的job仍然用于集群一半的资源，结果就是资源最终在两个用户之间平等的共享。过程如下图所示： 3.2 启用Fair Scheduler 调度器的使用是通过yarn-site.xml配置文件中的yarn.resourcemanager.scheduler.class参数进行配置的，默认采用Capacity Scheduler调度器。如果我们要使用Fair调度器，需要在这个参数上配置FairScheduler类的全限定名： org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.FairScheduler。
3.3 队列的配置 Fair调度器的配置文件位于类路径下的fair-scheduler.xml文件中，这个路径可以通过yarn.scheduler.fair.allocation.file属性进行修改。若没有这个配置文件，Fair调度器采用的分配策略，这个策略和3.1节介绍的类似：调度器会在用户提交第一个应用时为其自动创建一个队列，队列的名字就是用户名，所有的应用都会被分配到相应的用户队列中。
我们可以在配置文件中配置每一个队列，并且可以像Capacity 调度器一样分层次配置队列。比如，参考capacity-scheduler.xml来配置fair-scheduler： 队列的层次是通过嵌套&lt;queue&gt;元素实现的。所有的队列都是root队列的孩子，即使我们没有配到&lt;root&gt;元素里。在这个配置中，我们把dev队列有分成了eng和science两个队列。
Fair调度器中的队列有一个权重属性（这个权重就是对公平的定义），并把这个属性作为公平调度的依据。在这个例子中，当调度器分配集群40:60资源给prod和dev时便视作公平，eng和science队列没有定义权重，则会被平均分配。这里的权重并不是百分比，我们把上面的40和60分别替换成2和3，效果也是一样的。注意，对于在没有配置文件时按用户自动创建的队列，它们仍有权重并且权重值为1。
每个队列内部仍可以有不同的调度策略。队列的默认调度策略可以通过顶级元素&lt;defaultQueueSchedulingPolicy&gt;进行配置，如果没有配置，默认采用公平调度。
尽管是Fair调度器，其仍支持在队列级别进行FIFO调度。每个队列的调度策略可以被其内部的&lt;schedulingPolicy&gt; 元素覆盖，在上面这个例子中，prod队列就被指定采用FIFO进行调度，所以，对于提交到prod队列的任务就可以按照FIFO规则顺序的执行了。需要注意，prod和dev之间的调度仍然是公平调度，同样eng和science也是公平调度。
尽管上面的配置中没有展示，每个队列仍可配置最大、最小资源占用数和最大可运行的应用的数量。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d29981e4b8f57d49540af86d49ab303d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a44064e732157d6a51c0d9c8cb1b223a/" rel="bookmark">
			POST上传JSON数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		POST上传JSON数据到服务器时有以下两种方式，但是最常用的是第二种：
第一种：将要上传的JSON字符串（内容中的双引号前面必须要加转义字符\）然后按照UTF8编码格式转为NSData再设置给请求的数据体。如下所示：NSString *str = @"{\"username\" : \"小明\",\"age\" : \"24\"}";request.HTTPBody = [str dataUsingEncoding:NSUTF8StringEncoding];
第二种：就要上传的数据保存到字典或数组中（只限于此两种容器），然后需要检测给定的对象是否能被序列化。需要使用NSJSONSerialization的方法isValidJSONObject：进行判断，如果能被序列化则进行序列化操作。
NSJSONSerialization的介绍：
An object that may be converted to JSON must have the following properties:
- Top level object is an NSArray or NSDictionary
表示顶级结点是字典或数组
- All objects are NSString, NSNumber, NSArray, NSDictionary, or NSNull
所有对象是 NSString, NSNumber, NSArray, NSDictionary, or NSNull
- All dictionary keys are NSStrings
所有字典的Key必须是NSString
- NSNumbers are not NaN or infinity
NSNumber必须指定，不能是无穷大。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a44064e732157d6a51c0d9c8cb1b223a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/845ee0fd6ab657a79eab6d2400099c26/" rel="bookmark">
			常用排序算法分析与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		排序分为两类：内排序和外排序。
内排序：指排序过程中，待排序列全部存放在内存中处理，不需涉及数据的内、外存交换。适用于元素序列不太大的小文件。
外排序：指排序过程中，待排序列不能全部存放在内存中处理，内、外存之间需要多次进行数据交换。适用于元素序列太大，不能一次将其全部放入内存的大文件。
内排序分为六类：插入排序、交换排序、选择排序、归并排序、分配排序和计数排序。这里主要介绍前四类。
一、插入排序
插入排序是指将无序子序列中的一个或几个元素“插入”到有序子序列中。插入排序主要有直接插入排序，折半插入排序，和希尔（shell）排序。
直接插入排序：时间复杂度为O(n^2)，特殊情况（原表有序）为O(n)。(稳定)
//如果升序排序
void SimpleInsertSort(int* pData, int length)
{
if(NULL == pData || length &lt;= 0)
return ;
int i, j, temp;
for(i = 1; i &lt; length; i++)
{//对待排元素序列进行扫描。从第二个元素开始循环到最后一个元素。
for(j = i - 1; j &gt;= 0; j--)
{//从有序序列最后一个元素开始向前扫描，将待插入元素放入合适位置。
if(pData[j+1] &gt; pData[j])
break;
temp = pData[j+1];
pData[j+1] = pData[j];
pData[j] = temp;
}
}
}
2）折半插入排序：由于插入排序的基本操作是在一个有序表中进行查找和插入，这个查找操作可以利用折半查找来实现，由此称之为折半插入排序。折半插入排序只是减少了元素间的比较次数，而元素的移动次数不变，因此时间复杂度为O(n^2)。(稳定)
void BinaryInsertSort(int data[], int length)
{
if(NULL == data || length &lt;= 0)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/845ee0fd6ab657a79eab6d2400099c26/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3b99fb859402d9bc6f101889b0bf46a4/" rel="bookmark">
			Java线程池 ExecutorService
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本篇主要涉及到的是java.util.concurrent包中的ExecutorService。ExecutorService就是Java中对线程池的实现。 一、ExecutorService介绍 ExecutorService是Java中对线程池定义的一个接口，它java.util.concurrent包中，在这个接口中定义了和后台任务执行相关的方法： Java API对ExecutorService接口的实现有两个，所以这两个即是Java线程池具体实现类（详细了解这两个实现类，点击这里）：
1. ThreadPoolExecutor 2. ScheduledThreadPoolExecutor 除此之外，ExecutorService还继承了Executor接口（注意区分Executor接口和Executors工厂类），这个接口只有一个execute()方法，最后我们看一下整个继承树： 二、ExecutorService的创建 创建一个什么样的ExecutorService的实例（即线程池）需要g根据具体应用场景而定，不过Java给我们提供了一个Executors工厂类，它可以帮助我们很方便的创建各种类型ExecutorService线程池，Executors一共可以创建下面这四类线程池：
1. newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 2. newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。 3. newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。 4. newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 备注：Executors只是一个工厂类，它所有的方法返回的都是ThreadPoolExecutor、ScheduledThreadPoolExecutor这两个类的实例。
三、ExecutorService的使用 ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.execute(new Runnable() { public void run() { System.out.println("Asynchronous task"); } }); executorService.shutdown(); 四、ExecutorService的执行 ExecutorService有如下几个执行方法：
- execute(Runnable) - submit(Runnable) - submit(Callable) - invokeAny(...) - invokeAll(...) 4.1 execute(Runnable) 这个方法接收一个Runnable实例，并且异步的执行，请看下面的实例：
ExecutorService executorService = Executors.newSingleThreadExecutor(); executorService.execute(new Runnable() { public void run() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3b99fb859402d9bc6f101889b0bf46a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/54d1b5e6d1de361d5eb9698c1466ea8f/" rel="bookmark">
			Android检查手机上是否安装了指定的软件（根据包名检测）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Android检查手机上是否安装了指定的软件（根据包名检测）
/** * 检查手机上是否安装了指定的软件 * @param context * @param packageName * @return */ public static boolean isAvilible(Context context, String packageName) { final PackageManager packageManager = context.getPackageManager(); List&lt;PackageInfo&gt; packageInfos = packageManager.getInstalledPackages(0); List&lt;String&gt; packageNames = new ArrayList&lt;String&gt;(); if (packageInfos != null) { for (int i = 0; i &lt; packageInfos.size(); i++) { String packName = packageInfos.get(i).packageName; packageNames.add(packName); } } // 判断packageNames中是否有目标程序的包名，有TRUE，没有FALSE return packageNames.contains(packageName); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa58da03d0d98b0ec3992bf800fe2eb5/" rel="bookmark">
			结合阿里云服务器，设置家中jetson tk1随时远程登陆
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		结合阿里云服务器，设置家中jetson tk1随时远程登陆 溪西创客小屋
原文链接：http://www.cnblogs.com/wyxy2005/p/4274467.html
前提条件：
1.路由配置dmz主机为tk1的ip ,设置路由器中ssh 端口22的访问权限
2.有一台远程服务器，服务器安装了php可以运行php文件（我使用的是阿里云）
家中tk1配置：
脚本python 部署在jetson tk1上，然后设置crontab 定时执行
把python脚本放在 /jetson/testip.py crontab -e */10 * * * * /jetson/testip.py &gt;&gt;/dev/null 2&gt;&amp;1
/*----------------------testip.py-------------------------------*/
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #!/usr/bin/python import re,httplib conn = httplib.HTTPConnection( "1111.ip138.com" ) conn.request( "GET" , "/ic.asp" ) r1 = conn.getresponse() data1 = r1.read() conn.close() matchObj = re.search( r '(\d+)\.(\d+)\.(\d+)\.(\d+)' , data1, re.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aa58da03d0d98b0ec3992bf800fe2eb5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4592144f97bb889a8e322d777b15be28/" rel="bookmark">
			ROS中的depth image转换到laser scan的包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		depthimage_to_laserscan
溪西创客小屋
Overview / Example Scene RGB Here is the scene in which the following screenshots were captured.
DepthImage Note the sensor_msgs/LaserScan overlayed in color on the sensor_msgs/Image. Red is close to camera, purple is far from camera.
LaserScan sensor_msgs/LaserScan projected on top of the sensor_msgs/PointCloud2.
Top Down LaserScan Top down view of the sensor_msgs/LaserScan.
Node depthimage_to_laserscan depthimage_to_laserscan takes a depth image (float encoded meters or preferably uint16 encoded millimeters for OpenNI devices) and generates a 2D laser scan based on the provided parameters.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4592144f97bb889a8e322d777b15be28/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ecfc9162d05374960eec93385fc529cd/" rel="bookmark">
			Linux文件和文件夹复制
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux文件和文件夹复制
1、本地复制：
命令：cp
说明：将一个档案拷贝至另一档案，或将数个档案拷贝至另一目录。
参数：
-a 尽可能将档案状态、权限等资料都照原状予以复制。
-r 若 source 中含有目录名，则将目录下之档案亦皆依序拷贝至目的地。
-f 若目的地已经有相同档名的档案存在，则在复制前先予以删除再行复制。
2、远程传输文件或文件夹
命令：scp
scp是在安全协议下复制和传输文件，基于ssh登录。操作起来比较方便，比如要把当前一个文件copy到远程另外一台主机上，可以如下命令。
scp /home/data root@ip:/home/root
然后会提示你输入另外那台ip主机的root用户的登录密码，接着就开始copy了。
如果想反过来操作，把文件从远程主机copy到当前系统，也很简单。
scp root@ip:/home/root/data /home
文件夹复制是注意递归复制，参数 –r
存在端口情况，命令格式如下：
scp -P 4588 user@IP:/usr/local/sin.sh /home/administrator
3、远程传输大文件
当远程传输的文件或文件夹较大时，中间可能需要断开网络或是终端，这样会导致传输停止。解决由于终端关闭导致的终止情况，通常采用nohup命令后台运行，但是文件远程传输或复制需要输入对方服务器的秘钥，因此需要建立服务器之间的安全信任关系证书。主要使用SSH，一种安全通道协议，主要用于远程登录。
假设需要使用A服务器在不使用密码的情形下从服务器B拷贝文件，步骤如下：
（1）在A服务器生成一对秘钥文件（公钥和私钥）
ssh-keygen
上述命令等价于：
ssh-keygen -rsa
其中，-t指定密钥的类型,默认为SSH-2的rsa类型。生成的秘钥会保存在~/.ssh文件夹下。
运行上面的命令后，系统会出现一系列提示，可以一路回车。特别说明，其中有一个问题是，要不要对私钥设置口令（passphrase），如果担心私钥的安全，可以设置一个。运行结束以后，会在 ~/.ssh/ 目录下新生成两个文件：id_rsa.pub和id_rsa。前者公钥，后者是私钥。
（2）将公钥传送到远程主机B上面
ssh-copy-id -i ~/.ssh/id_rsa.pub -p PORT_B user_B@IP_B
（3）在A上可以使用
nohup scp
从B上进行远程复制
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53658d32eef1d3cf5728dfbc28cf793e/" rel="bookmark">
			iOS中UITableView性能优化
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在iOS应用中，UITableView应该是使用率最高的视图之一了。iPod、时钟、日历、备忘录、Mail、天气、照片、电话、短信、Safari、App Store、iTunes、Game Center⋯几乎所有自带的应用中都能看到它的身影，可见它的重要性。
然而在使用第三方应用时，却经常遇到性能上的问题，普遍表现在滚动时比较卡，特别是table cell中包含图片的情况时。
实际上只要针对性地优化一下，这种问题就不会有了。有兴趣的可以看看LazyTableImages这个官方的例子程序，虽然也要从网上下载图片并显示，但滚动时丝毫不卡。
下面就说说我对UITableView的了解。不过由于我也是初学者，或许会说错或遗漏一些，因此仅供参考。
首先说下UITableView的原理。有兴趣的可以看看《About Table Views in iOS-Based Applications》。
UITableView是UIScrollView的子类，因此它可以自动响应滚动事件（一般为上下滚动）。
它内部包含0到多个UITableViewCell对象，每个table cell展示各自的内容。当新cell需要被显示时，就会调用tableView:cellForRowAtIndexPath:方法来获取或创建一个cell；而不可视时，它又会被释放。由此可见，同一时间其实只需要存在一屏幕的cell对象即可，不需要为每一行创建一个cell。
此外，UITableView还可以分为多个sections，每个区段都可以有自己的head、foot和cells。而在定位一个cell时，就需要2个字段了：在哪个section，以及在这个section的第几行。这在iOS SDK中是用NSIndexPath来表述的，UIKit为其添加了indexPathForRow:inSection:这个创建方法。
其他诸如编辑之类的就不提了，因为和本文无关。
介绍完原理，接下来就开始优化吧。
使用不透明视图。
不透明的视图可以极大地提高渲染的速度。因此如非必要，可以将table cell及其子视图的opaque属性设为YES（默认值）。
其中的特例包括背景色，它的alpha值应该为1（例如不要使用clearColor）；图像的alpha值也应该为1，或者在画图时设为不透明。
当一个view是透明的，iOS需要渲染一个像素两次或多次，这是因为一个像素同时属于很多subviews。这是一个非常耗时的过程。
通过代码或者InterfaceBuilder能够很简单的做到。开发者应该多次检查所有的subviews是不透明的。
对于自定义代码，你可以通过代码来设置，如下：
view.opaque = YES;
不要重复创建不必要的table cell。
前面说了，UITableView只需要一屏幕的UITableViewCell对象即可。因此在cell不可见时，可以将其缓存起来，而在需要时继续使用它即可。
而UITableView也提供了这种机制，只需要简单地设置一个identifier即可：
static NSString *CellIdentifier = @"xxx";
UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier];
if (cell == nil) {
cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifier] autorelease];
}
值得一提的是，cell被重用时，它内部绘制的内容并不会被自动清除，因此你可能需要调用setNeedsDisplayInRect:或setNeedsDisplay方法。
此外，在添加table cell的时候，如果不需要动画效果，最好不要使用insertRowsAtIndexPaths:withRowAnimation:方法，而是直接调用reloadData方法。因为前者会对所有indexPaths调用tableView:cellForRowAtIndexPath:方法，即便该cell并不需要显示（不知道是不是bug），这就可能创建大量多余的cell。勘误：只是在模拟器上测试如此，真机调试时没有这种bug。
减少视图的数目。
UITableViewCell包含了textLabel、detailTextLabel和imageView等view，而你还可以自定义一些视图放在它的contentView里。然而view是很大的对象，创建它会消耗较多资源，并且也影响渲染的性能。
如果你的table cell包含图片，且数目较多，使用默认的UITableViewCell会非常影响性能。奇怪的是，使用自定义的view，而非预定义的view，明显会快些。
当然，最佳的解决办法还是继承UITableViewCell，并在其drawRect:中自行绘制：
- (void)drawRect:(CGRect)rect {
if (image) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53658d32eef1d3cf5728dfbc28cf793e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85cd059a04476f8ffe763b8d32323926/" rel="bookmark">
			java 函数返回多个函数值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天用echarts处理数据，在一个函数里需要返回多个返回值，查了一些资料记录一下：
1、数组或者集合，把需要返回的多个数据放在数组里边，然后返回一个数组，在调用端按照存储的位置，取相应的元素即可，缺点是数组里边的元素是同一类型的。
2、设置全局变量，通过对全局变量赋值来传递参数，但是全局变量的值较难追踪，风险大
3、单独构造一个对象，将需要返回的不同类型的数据封装到对象中，然后在调用处取出即可
4、利用Map，将数据封装到Map中
5、使用按址传递的方法传入参数，这样在函数内部处理更改的参数，函数的外部同样地址的变量也会发生改变
关于值传址传递参见另一篇博客。点击
关注我，获取400个的赚钱金点子，轻松开启程序员的副业生涯
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14fb559bc1325cb9883850051d8ee5f5/" rel="bookmark">
			RAID基础知识总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 计算机和网络技术的高速发展对存储性能和数据可靠性的要求不断的提高，使用RAID技术是很好的解决途径。RAID的全称为廉价磁盘冗余阵列（Redundant Array of Inexpensive Disks），是将多个独立的物理硬盘按照不同的方式组合起来，形成一个虚拟的硬盘。 软件RAID和硬件RAID RAID也有全软、半软半硬与全硬之分，全软RAID就是指 RAID的所有功能都是操作系统（OS）与CPU来完成，没有第三方的控制/处理（RAID协处理器——RAID Co-Processor）与I/O芯片。这样，有关RAID的所有任务的处理都由CPU来完成，可想而知这是效率最低的一种RAID。半软半硬RAID 则主要缺乏自己的I/O处理芯片，所以这方面的工作仍要由CPU与驱动程序来完成。而且，半软半硬RAID所采用的RAID控制/处理芯片的能力一般都比较弱，不能支持高的RAID等级。全硬的RAID则全面具备了自己的RAID控制/处理与I/O处理芯片，甚至还有阵列缓冲（Array Buffer），对CPU的占用率以及整体性能是这三种类型中最优势的，但设备成本也是三种类型中最高的。 RAID组织数据的基本方式 1、并行存取方式 适用于大型的、以长时间顺序访问数据为特征的应用 2、独立存取方式 适用于数据存取频繁，每笔存取数据量较小的应用 镜像冗余 镜像冗余使用了磁盘镜像技术，磁盘镜像是一个简单的设备虚拟化技术，每个I/O操作都会在两个磁盘上执行，两个磁盘看起来就像一个磁盘一样 镜像冗余可以提高磁盘的读性能 镜像冗余的实现方式 校验冗余 根据冗余算法计算阵列中成员磁盘上数据的校验信息，将校验信息保存在其他的磁盘资源上 保证数据可靠性； 和镜像冗余相比较，校验冗余的开销更小 热备和热换 热备是指在不干扰当前系统的正常使用的情况下，用系统中另外一个正常的备用磁盘顶替失效磁盘 热换是指在不影响系统正常运转的情况下，用正常的磁盘物理替换RAID阵列中的失效磁盘 二、常用RAID级别 组成RAID阵列的不同方式称为RAID级别； 不同的RAID级别对应不同的存储性能， 不同的数据可靠性和不同的存储成本 RAID-0 数据被RAID控制器（硬件或软件）分割成大小相同的数据条，以条带的形式同时写入阵列中的各个磁盘上，每个磁盘上的条带深度是一样的，每个条带的具体深度则要看所采用的RAID类型，在NT系统的软RAID-0等级中，每个条带深度只有64KB一种选项，而在硬RAID-0等级，可以提供8、16、32、64以及128KB等多种深度参数。Striped是RAID的一种典型方式，在很多RAID术语解释中，都把 Striped指向RAID 0。在读取时，也是顺序从阵列磁盘中读取后再由RAID控制器进行组合再传送给系统，这也是RAID的一个最重要的特点。 RAID0的特性 RAID-1 RAID-1以镜像为冗余方式，对虚拟磁盘上的数据做多份拷贝，放在成员磁盘上，如果阵列中有两个硬盘，在写入时，RAID控制器将数据同时写入两个硬盘，在大量写入RAID1的情况下，写入性能可能会非常差（数据传到I/O总线后会被复制多份到各个磁盘，但只有一个南桥芯片，如果使用硬RAID，磁盘阵列卡会主动复制一份而不使用系统的I/O总线，性能方面还可以），当其中任何一个硬盘的数据出现问题，可以马上从另一个硬盘中进行恢复，同时，整体RAID的容量几乎少了50% RAID1的特性 RAID-5 采用独立存取的阵列方式，采用了数据块的存储方式，在每个独立的数据盘中都开辟了单独的区域用于存储同级数据的XOR校验数据，在写入时，同级校验数据将即时生成并写入，在读取时，同级校验数据也将被即时读出并检查源数据的正确性。 数据块 简单来说，一个数据块是一个 完整的数据集合，比如一个文件就是一个典型的数据块。当然，对于硬盘的读取，一个数据块并不是一个文件，而是由操作系统所决定的，这就是我们熟悉的簇 （Cluster）。按块存储可以保证块的完整，不受因分条带存储在其他硬盘上而可能产生的不利影响（比如当其他多个硬盘损坏时，数据就完了）。 同级 指在每个硬盘中同一柱面同一扇区位置的数据算是同级。在写入时，RAID就是按这个方法把各硬盘上 同级数据的校验统一写入校验盘，等读取时再即时进行校验。因此即使是当前硬盘上的数据块损坏，也可以通过XOR校验值和其他硬盘上的同级数据进行恢复。 XOR校验 eXclusive OR异或逻辑运算代替了RAID-2中相对复杂的汉明码校验，从而也大幅降低了成本。XOR的校验原理如下表： 这里的A与B值就代表了两个位，当A与B一样时，XOR结果为0，A与B不一样时，XOR结果就是1，而且知道XOR结果和A与B中的任何一个 数值，就可以反推出另一个数值。比如A为1，XOR结果为1，那么B肯定为0，如果XOR结果为0，那么B肯定为1。 RAID5的特性 组合不同级别的RAID 所谓组合RAID是指在这个RAID等级中是由多个RAID等级（一般是两个）组合而成。 RAID-10 Very High Reliability combined with High Performance（高可靠性与高性能的组合） 工作原理：RAID10结合RAID1和RAID0，先镜像，再条带化 RAID-1在这里是一个冗余的备份阵列，而RAID-0则负责数据的读写阵列。下图只是一种RAID 10方式，更多的情况是从主通路分出两路（以4个硬盘时为例），做Striping操作，即把数据分割，而这分出来的每一路则再分两路，做Mirroring操作，即互做镜像。 由于利用了RAID-0极高的读写效率和RAID-1较高的数据保护、恢复能力，使RAID-10成为了一种性价比较高的等级，目前几乎所有的RAID控制卡都支持这一等级。但是，RAID-10对存储容量的利用率和RAID 1一样低，只有50%。 RAID-10的特性 RAID-50 工作原理：RAID50是RAID5和RAID0的结合，先实现RAID5，再条带化 RAID-50的特性 总结： 常用RAID级别中： RAID0的性能最好； RAID1的冗余程度最高； 相同可用容量下，RAID1和RAID 10的开销最高。 RAID的运行状态 建立（Create） 正常（Normal） 降级/临界（Degrade/Critical） 重建（Rebuild/Recover） 重构（Reconstruct） 失效（Failed） 若RAID5的一块磁盘失效，则 目前处在降级/临界状态下 再有一块磁盘发生故障，将进入失效状态 分块、分区、分条是RAID组织数据的重要概念 RAID的冗余方式有镜像冗余和校验冗余 常用RAID级别有RAID1、RAID5和RAID10等 参考博文：http://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14fb559bc1325cb9883850051d8ee5f5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/764ae35a62d3b5049603c54290d2dd98/" rel="bookmark">
			appium滑动操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目的：1.Android手机上、下、左、右滑动操作
2.判断滑动到底部。思路：多次滑动后，比较最后一个元素是否相同。如果相同，则判定滑动到底部。
环境：1.java包：java-client-3.1.0.jar/ java-client-3.1.0-sources.jar 2.使用appium（环境请自行搭建）
写在文章开头，感谢陌神的帮助，也是在他的代码基础上做的。
由于涉及公司自己的APP，所以这里类.函数中类名统统改为：ClassName。需自行修改。控件的Id统统改为resourceId。需自行修改。
// 获取应用占屏幕大小
public static int[] appScreen() {
int width = driver.manage().window().getSize().getWidth();
int height = driver.manage().window().getSize().getHeight();
int[] appSize = { width, height };
return appSize;
}
// 向左滑动
public static void swipeToLeft(int duration) {
int startx = ClassName.appScreen()[0] * 4 / 5;
int endx = ClassName.appScreen()[0] * 1 / 5;
int y = ClassName.appScreen()[1] * 1 / 2;
try {
driver.swipe(startx, y, endx, y, duration);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/764ae35a62d3b5049603c54290d2dd98/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/031a506efd3df8627f807a154db183a9/" rel="bookmark">
			Linux系统下的文件自动备份到Windows系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux系统下的文件自动备份到Windows下
1 linux服务器上安装ftp服务端软件 #wget http://mirror.centos.org/centos-6/6.3/os/x86_64/Packages/vsftpd-2.2.2-11.el6.x86_64.rpm
#rpm -ivh vsftpd-2.2.2-11.el6.x86_64.rpm
或
#yum install vsftpd -y
2 修改/etc/vsftpd/vsftpd.conf 这里主要设置拒绝匿名登录和锁定用户到自家目录
1.#拒绝匿名登录 anonymous_enable=NO 2.#锁定用户到自家目录 chroot_local_user=YES ps:更多ftp设置参考http://zserver.blog.51cto.com/370152/157203/ 3 重启ftp服务 service vsftpd restart
4 设置iptables 这里ftp采用的是Port模式，只需要打开监听端口21和数据端口20
编辑/etc/sysconfig/iptables,添加如下规则 -A INPUT -m state --state NEW -m tcp -p tcp --dport 21 -j ACCEPT -A INPUT -m state --state NEW -m tcp -p tcp --dport 20 -j ACCEPT 5 重启刷新防火墙规则 #service iptables restart
6 linux系统为ftp添加一个用户 并将用户家目录设置为ftp默认目录 通过-d参数设置,最后设置密码。
#useradd ftpuser -d /var/ftp/pub -s /sbin/nologin #passwd ftppwd 黄色自行设置ftp默认目录，ftp用户、ftp密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/031a506efd3df8627f807a154db183a9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca692c06bbb3f0cd93ff73379d161139/" rel="bookmark">
			接口文档管理，版本管理工具，阿里RAP的windows下部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 相关介绍：http://cn.rapapi.net/org/index.do
1 下载war包
https://raw.githubusercontent.com/thx/RAP/release/release/rap_release_v0.11.3_20150727.war 2 在tomcat的webapps/ROOT目录下，删除此文件夹下所有文件(或者全部拷贝另存到其他地方),把这个rap_release_v0.11.3_20150727.war使用winrar解压缩工具解压到此目录下3 开启你的mysql数据库服务，在命令行执行： create database rap_db default charset utf8 COLLATE utf8_general_ci; grant all on rap_db.* to 'rap'@'localhost' IDENTIFIED BY 'password'; flush privileges;4 导入sql: mysql-&gt; source d:\tomcat\webapps\ROOT/WEB-INF/classes/database/initialize.sql (你的目录可能与我的tomcat目录不同) 5 修改d:\tomcat\webapps\ROOT/WEB-INF/classes/mysql.local.properties文件中的 jdbc.username=你自己的数据库用户名称 jdbc.password=你的密码 6 启动tomcat ,访问：http://localhost:8080 即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/960f8cb223c7d7c80f49f1fa4e8b3acd/" rel="bookmark">
			opencv例程解读——dft（离散傅里叶变换）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		废话不多说，直接上代码，代码中我都注明了注释，有些讲不清楚的，会在代码的后面专门拿出来讲。
下面这个cpp文件不是我自己写的程序，是opencv提供的关于dft变换的例程，文件一般会包含在你的opencv路径下opencv\sources\samples\cpp下面，可以自行查找。
#include "opencv2/core/core.hpp" #include "opencv2/imgproc/imgproc.hpp" #include "opencv2/highgui/highgui.hpp" #include &lt;stdio.h&gt; using namespace cv; using namespace std; static void help() { printf("\nThis program demonstrated the use of the discrete Fourier transform (dft)\n" "The dft of an image is taken and it's power spectrum is displayed.\n" "Usage:\n" "./dft [image_name -- default lena.jpg]\n"); } const char* keys = { "{1| |lena.jpg|input image file}" }; int main(int argc, const char ** argv) { help(); CommandLineParser parser(argc, argv, keys); string filename = parser.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/960f8cb223c7d7c80f49f1fa4e8b3acd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9d9d9924e44a606ec6cf60d27098365/" rel="bookmark">
			Vmvare虚拟机vmdk格式转换为 qcow2格式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、 虚拟机vmvare准备 迁移的过程如下：
1. 登录宿主机，在 VMwareWorkstation上检查 A 虚拟机，如果安装了 VMware Tools，以 root用户运行 vmware-uninstall-tools.pl卸载它。
卸载：
/vmware-tools-distrib/bin/vmware-uninstall-tools.pl
2. 关闭 A虚拟机。
3. 检查虚拟机的镜像文件。本例中，虚拟机的镜像存储在多个 vmdk文件中，所以需要在迁移前合并他们。
vmware-vdiskmanager.exe -r sourceDisk.vmdk -t 0 destinationDisk.vmdk
参数介绍：
-r&lt;source-disk&gt; : convert thespecified disk; need to specify
destinationdisk-type. For local destination disks
the disk type mustbe specified.
-t &lt;disk-type&gt; : disk type id Disk types: 0 : single growable virtual disk ex : vmware-vdiskmanager.exe -r sourceDisk.vmdk -t 0 destinationDisk.vmdk 2、 格式转换使用linux系统
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9d9d9924e44a606ec6cf60d27098365/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/85ec6240df99531cb56c74f774f34167/" rel="bookmark">
			centos下安装bugfree3.0.4
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		centos下安装bugfree3.0.4 一、 配置环境 操作系统：centos 6.5
Bugfree版本：3.0.4
xampp 版本: xampp-linux-x64-1.8.3-5-installer.run
xampp简介
xampp是一款跨平台的集成 apache + mysql + php环境，是的配置AMP服务器变得简单轻松，支持windows，solaris，MacOSX，linux。
二、 Xampp的安装： 1. xampp下载地址：
http://sourceforge.net/projects/xampp/files/XAMPP%20Linux/1.8.3/
我下载的是xampp-linux-x64-1.8.3-1-installer.run
wget http://sourceforge.net/projects/xampp/files/XAMPP%20Linux/1.8.3/xampp-linux-x64-1.8.3-1-installer.run/download
2. 下载完以后，给该文件添加执行权限：
chmod a+x xampp-linux-x64-1.8.5-a-installer.run
3. 安装xampp过程如下：
[root@nginxone src]#./xampp-linux-x64-1.8.3-5-installer.run
----------------------------------------------------------------------------
Welcome to the XAMPP Setup Wizard.
----------------------------------------------------------------------------
Select the components you want to install; clear the components youdo not want
to install. Click Next when you are ready to continue.
XAMPP Core Files : Y (Cannot be edited)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/85ec6240df99531cb56c74f774f34167/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c8e3eeaf9bf46aa9e39df2bc4eb7c60/" rel="bookmark">
			mysql 重复记录只选取最后一条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// sid相同，create_time不同，取create_time最后一条
1. 使用 NOT EXISTS参数
SELECT id, sid FROM table_name a WHERE NOT EXISTS (SELECT 1 FROM table_name where a.sid = sid AND a.create_time &lt; create_time) 2. 使用子查询
SELECT id, sid FROM table_name WHERE create_time IN (SELECT max(create_time) FROM table_name group by sid)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97f8fab067a9df19dd2e8b75c5989fff/" rel="bookmark">
			AsyncTask
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		异步任务机制，可以在任务结束后更新UI。
AsyncTask一般步骤
1、execute(Params… params)：执行异步任务，并可以传值。
2、onPreExecute()：调用execute方法后，立即执行此方法，可以写一些初始化操作。
3、doInBackground(Params… params)：执行比较耗时的操作，比如网络请求，在此处可以调用publishProgress(Progress… values)，来更新进度信息。
4、onProgressUpdate(Progress… values)：调用publishProgress()，后方法被执行，可以更新UI中的进度信息。
5、onPostExecute(Result result)：当任务执行成功后，返回信息，执行此方法，在此处进行更新UI的操作。
其他： 当执行cancel()方法时，会执行onCancelled()方法。此方法不会销毁线程，会将任务执行完成，但是不会执行onPostExecute方法。可以参考下面文章
译文：Android中糟糕的AsyncTask http://droidyue.com/blog/2014/11/08/bad-smell-of-asynctask-in-android/
同时也有一些替代的方案，例如：
RxJava https://asce1885.gitbooks.io/android-rd-senior-advanced/content/index.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/66c8026f45bdfb8124872aa81cfeb82a/" rel="bookmark">
			18-EMM Procedure 6. Handover without TAU - Part 3. S1 Handover
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		I. Introduction 之前的文档，我们讨论了X2切换，这篇文档我们关注在EPC干预下的S1切换。这里，我们假设source和target eNB连接在同一个MME/SGW，并且位于UE的TAI列表中的同一个TA下。第二章我们描述S1切换的概念，第三章我们详细描述S1切换，最后第四章我们总结在S1切换前后EPS实体信息的变化。
II. Concept of S1 Handover 2.1 S1协议栈
S1切换是通过S1接口source和target eNB之间执行的。在控制面eNB和MME通过S1AP信令通信，在用户面eNB和SGW通过GTP隧道通信。图1显示控制面和用户的S1接口上的协议栈。
当安装一个新eNB时，就需要在eNB和MME之间执行S1 setup过程。eNB通过发送S1 setup request(eNB ID, eNB Name,TAC)给MME通知eNB配置信息。在MME中也会使用相应的MME容量参数用于MME间的负载均衡。这个值被标记为权值，表示每一个MME处理UE连接的相对容量。eNB连接不止一个MME，当选择一个MME建立新的UE连接时使用这个值。eNB和EPC之间的UE连接如下：在控制面，eNB和MME之间每一个用户的信令都是通过S1AP信令连接提供的，并使用{eNB UES1AP ID, MME UE S1AP ID}标识，在用户面，eNB和SGW之间的每一个用户的S1承载都是通过GTP隧道来提供，并使用{DL S1 TEID (S1 eNB TEID), UL S1 TEID (S1 SGW TEID)}标识。
2.2 和切换相关的S1AP过程和消息
表1和2是在GPP TS 36.413中S1AP的基本过程，包含non-UE和UE相关的过程。这个文档是和切换相关的，所以这里只讨论UE相关的过程。表1列出了S1切换相关的S1AP过程和他们相关的S1AP消息。
列在上表中的这些S1AP消息在下面详细介绍：
Handover Required message: 这个消息用于切换准备阶段，由eNB发送给MME，包含target eNB的信息和source cell的无线资源。Handover Request message: 这个消息在切换准备阶段使用，由MME发送到target eNB，包含UE上下文信息。Handover Request Acknowledge message: 这个消息是在切换准备阶段使用的，它是当在target eNB中成功为UE分配资源时由target eNB发送给MME。target eNB分配DL S1 TEID供S1承载在切换后使用，并分配DL S1 TEID供S1承载(indirect tunnel)用于在切换时下行数据包的传送，包含在这个消息中转发他们。handover command message：这个消息用于切换准备阶段，是由MME发送给source eNB。它包含了UE接入target eNB需要的信息（e.g. Target C-RNTI, Target eNB AS Security algorithm, DRB ID, etc.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/66c8026f45bdfb8124872aa81cfeb82a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7631d01aee64ca41596a8e7ea6ee440/" rel="bookmark">
			2.3 单位矩阵和转置矩阵
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 声明：该文章翻译自MIT出版的《DEEP LEARNING》，博主会定期更新文章内容。由于博主能力有限，中间有过错之处希望大家给予批评指正，一起学习交流。
线性代数提供了一个强有力的工具 ——矩阵求逆，可以解决等式 Ax=b。 为了描述矩阵逆，我们首先需要定义单位矩阵的概念。当我们用单位矩阵乘以其它矩阵时，它不改变矩阵的值。我们用 In 表示n维单位矩阵。正式地，
∀x∈Rn,Inx=x. 单位矩阵的结构很简单：沿着主对角线的元素都是1，而其它元素都是0。如下图： A 的逆表示为 A−1 ，并且满足条件： A−1A=In. 现在我们可以通过下面的步骤解决等式2.1: Ax=b A−1Ax=A−1b Inx=A−1b x=A−1b 当然，这依赖于 A−1 。在下一节，我们将讨论 A−1 存在的条件。 当 A−1 存在时，有几种不同的算法可以在闭合式（closed form）中找到它。理论上，对于不同的 b 值，可以用同样的逆矩阵求解。然而， A−1 作为理论工具有用，但实际中的许多软件应用不应该使用它。因为在数字计算机上 A−1 只能表示有限的精度，而充分利用 b 值的算法通常可以得到 x 更精确的估计值。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fab58d288552d84d5f822b8d5b7b77c/" rel="bookmark">
			Oracle中TO_NUMBER()函数的用法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 用法简介 TO_NUMBER函数()是Oracle中常用的类型转换函数之一，主要是将字符串转换为数值型的格式，与TO_CHAR()函数的作用正好相反。
To_number函数的格式如下：
To_number（varchar2 or char,’format model’） To_number函数中也有很多预定义的固定格式：
格式值含义9代表一个数字0强迫0显示$显示美元符号L强制显示一个当地的货币符号.显示一个小数点,显示一个千位分隔符号 2 一些例子 SQL&gt; select to_number（’RMB234234.4350′，’L999999.0000′） from dual; TO_NUMBER（’RMB234234.4350′，’L999999.0000′） —————————————— 234234.435 SQL&gt; select to_number（’$123,233,455,623.3400′，’$999,999,999,999.0000′） from dual; TO_NUMBER（’$123,233,455,623.3400′，’$999,999,999,999.0000′） ———————————————————- 1.2323E+11 3 用法陷阱 有的时候你会发现，使用了TO_NUMBER()函数并且语法正确，但是Oracle却报“invalid number”的错误，而你在一遍又一遍认认真真检查并确定语句无误之后大呼惊奇，以为TO_NUMBER()函数还有什么可能不知道的用法。其实这很可能是你所查询的数据出现了问题，而非SQL。使用TO_NUMBER()函数的时候，一定要确保所转换字段是可转换为数字的，比如字符串“20151008”是可以转换为数字20151008的，但是字符串“2015-10-08”不可以。如果你的字段中包含了字符串“2015-10-08”，而你还直接使用了TO_NUMBER()函数进行操作的话就会报“invalid number”的错。
4 逃出陷阱 如何逃出陷阱呢？
1 前端校验 尽量在用户输入的时候进行必要的校验，确保输入的数值就是我们需要的格式。
2 后台校验 在后台代码中进行必要的检查，筛选到错误的值并且传给前台合理的提示。
3 SQL校验 一旦你的数值进了数据库，问题就变得复杂了。还有一种情况是，数据是历史的，我们不能修改它，但是还要进行必要的查询。这时候就需要在SQL层面做点什么了。假设需要使用TO_NUMBER()函数的字段是varchar2类型的名为“status”。比如，如果非法数据都是比较长的，你可以在SQL中加上长度的校验，即多加一个where条件：
LENGTH(status) &lt;= 10 或者，也可以将非法字符替换掉，，同样是在where中多加一个条件：
TO_NUMBER(REGEXP_REPLACE(status,'[^0-9]','')) &gt; 30 实例中REGEXP_REPLACE()将“status”字段中所有非数字的字符替换为空字符，然后再用TO_NUMBER()进行比较就可以啦！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bd18fa9f1047afc458b296a7b4d07ea6/" rel="bookmark">
			Redis: 为行情数据库设计键值
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果说用传统关系数据库如MSSQL,MYSQL,PGSQL来设计一个行情数据库，除表名外，就是列字段了。
比如，表名：600036.SH_1min, (这里假定每个个股设计一张表，避免把所有的个股放在一张表中，导致数据以亿计，查询效率太低)
举例而言，其中一条记录（虚拟）
code :600036.SH Date :2014-10-09 DateTime: 930 Open: 9.60 High:10.08 Close:10.02 Low :9.54 Volume: 123456 Amount :78964531 Factor: 5.123
另外，成份股的指数权属作为另外一张表而存在，不放在这里，否则太大，也浪费空间。
如果以内存数据库Redis来设计key-value,相对的key 就会比较长，但value比较简单。
因为key的唯一性，
比如，同样以上面的记录而言，可能就要设计一个唯一的KEY:
key1: 600036.SH_1min:2014-10-09:0930:Open =&gt; value1 :9.60
key2: 600036.SH_1min:2014-10-09:0930:High =&gt; value 2:10.08
key3: 600036.SH_1min:2014-10-09:0930:Close =&gt; value3 :10.02
key4: 600036.SH_1min:2014-10-09:0930:Low =&gt; value4 :9.54
......
也就是说
set 600036.SH_1min:2014-10-09:0930:Open 9.60
set 600036.SH_1min:2014-10-09:0930:High 10.08
set 600036.SH_1min:2014-10-09:0930:Close 10.02
set 600036.SH_1min:2014-10-09:0930:Low 9.54
.......
这样，就可以建立一系列的KEY-VALUE结构的非结构化数据了。
下面，针对历史行情数据库中，典型的日度数据，N分钟数据，TICK数据，我们要进行一个整体上的数据库设计。
(1) 类型的设计
我个人认为，用hash的方式来设历史行情库，可能会更好。
(2) KEY 的设计
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bd18fa9f1047afc458b296a7b4d07ea6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b407bcb8ad8f5c49f7c81a11c766b8f9/" rel="bookmark">
			linux命令行练级攻略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基础 学习 Bash 的基础知识。具体来说，输入 man bash 并至少全文浏览一遍; 它很简单并且不长。其他的 shell 可能很好用，但 Bash 功能强大且几乎所有情况下都是可用的 ( 只学习 zsh，fish 或其他的 shell 的话，在你自己的电脑上会显得很方便，但在很多情况下会限制你，比如当你需要在服务器上工作时)。
学习并掌握至少一个基于文本的编辑器。通常 Vim (vi) 会是你最好的选择。
学会如何使用 man 命令去阅读文档。学会使用 apropos 去查找文档。了解有些命令并不对应可执行文件，而是Bash内置的，可以使用 help 和 help -d 命令获取帮助信息。
学会使用 &gt; 和 &lt; 来重定向输出和输入，学会使用 | 来重定向管道。了解标准输出 stdout 和标准错误 stderr。
学会使用通配符 * (或许再算上 ? 和 {…}) 和引用以及引用中 ' 和 " 的区别。
熟悉 Bash 任务管理工具: &amp;，ctrl-z，ctrl-c，jobs，fg，bg，kill 等。
了解 ssh，以及基本的无密码认证，ssh-agent，ssh-add 等。
学会基本的文件管理: ls 和 ls -l (了解 ls -l 中每一列代表的意义)，less，head，tail 和 tail -f (甚至less +F)，ln 和 ln -s (了解硬链接与软链接的区别)，chown，chmod，du (硬盘使用情况概述: du -hk *)。 关于文件系统的管理，学习 df，mount，fdisk，mkfs，lsblk。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b407bcb8ad8f5c49f7c81a11c766b8f9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d808cf07cbf2e6186f5db14ddc64d73d/" rel="bookmark">
			Matlab - jacobian函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		名称：Jacobian matrix 雅可比矩阵
用法：jacobian(f,v)
描述：jacobian(f,v) computes the Jacobian matrix of f with respect to v. The (i,j) element of the result is jacobian(f,v) 计算了 f 关于 v 的雅可比矩阵，其第(i,j )个元素为.
输入参数说明：
f — Scalar or vector function
symbolic expression | symbolic function | symbolic vector
标量或者向量函数，符号表达式、符号函数、符号向量等。 如果f是一个标量的话，f 的雅可比矩阵是 f 的梯度的转置。
v — Vector of variables with respect to which you compute Jacobian
symbolic variable | symbolic vector
要计算雅可比的变量向量，符号变量、符号向量
如果v 是一个标量，则结果等价于 diff(f,v) 的转置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d808cf07cbf2e6186f5db14ddc64d73d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/874913242ef96250b12fff9cd80d7924/" rel="bookmark">
			App开放接口api安全性—Token签名sign的设计与实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在app开放接口api的设计中，避免不了的就是安全性问题，因为大多数接口涉及到用户的个人信息以及一些敏感的数据，所以对这些接口需要进行身份的认证，那么这就需要用户提供一些信息，比如用户名密码等，但是为了安全起见让用户暴露的明文密码次数越少越好，我们一般在web项目中，大多数采用保存的session中，然后在存一份到cookie中，来保持用户的回话有效性。但是在app提供的开放接口中，后端服务器在用户登录后如何去验证和维护用户的登陆有效性呢，以下是参考项目中设计的解决方案，其原理和大多数开放接口安全验证一样，如淘宝的开放接口token验证，微信开发平台token验证都是同理。
签名设计 对于敏感的api接口，需使用https协议 https是在http超文本传输协议加入SSL层，它在网络间通信是加密的，所以需要加密证书。
https协议需要ca证书，一般需要交费。
签名的设计 原理：用户登录后向服务器提供用户认证信息（如账户和密码），服务器认证完后给客户端返回一个Token令牌，用户再次获取信息时，带上此令牌，如果令牌正取，则返回数据。对于获取Token信息后，访问用户相关接口，客户端请求的url需要带上如下参数：
时间戳：timestamp
Token令牌：token
然后将所有用户请求的参数按照字母排序（包括timestamp，token），然后更具MD5加密（可以加点盐），全部大写，生成sign签名，这就是所说的url签名算法。然后登陆后每次调用用户信息时，带上sign，timestamp，token参数。
例如：原请求https://www.andy.cn/api/user/update/info.shtml?city=北京 （post和get都一样，对所有参数排序加密）
加上时间戳和token
https://www.andy.cn/api/user/update/info.shtml?city=北京&amp;timestamp=12445323134&amp;token=wefkfjdskfjewfjkjfdfnc
然后更具url参数生成sign
最终的请求如
https://www.andy.cn/api/user/update/info.shtml?city=北京&amp;timestamp=12445323134&amp;token=wefkfjdskfjewfjkjfdfnc&amp;sign=FDK2434JKJFD334FDF2
其最终的原理是减小明文的暴露次数；保证数据安全的访问。
具体实现如下：
1. api请求客户端想服务器端一次发送用用户认证信息（用户名和密码），服务器端请求到改请求后，验证用户信息是否正确。
如果正确：则返回一个唯一不重复的字符串（一般为UUID），然后在Redis（任意缓存服务器）中维护Token----Uid的用户信息关系，以便其他api对token的校验。
如果错误：则返回错误码。
2.服务器设计一个url请求拦截规则
（1）判断是否包含timestamp，token，sign参数，如果不含有返回错误码。
（2）判断服务器接到请求的时间和参数中的时间戳是否相差很长一段时间（时间自定义如半个小时），如果超过则说明该 url已经过期（如果url被盗，他改变了时间戳，但是会导致sign签名不相等）。
（3）判断token是否有效，根据请求过来的token，查询redis缓存中的uid，如果获取不到这说明该token已过期。
（4）根据用户请求的url参数，服务器端按照同样的规则生成sign签名，对比签名看是否相等，相等则放行。（自然url签名 也无法100%保证其安全，也可以通过公钥AES对数据和url加密，但这样如果无法确保公钥丢失，所以签名只是很大程 度上保证安全）。
（5）此url拦截只需对获取身份认证的url放行（如登陆url），剩余所有的url都需拦截。
3.Token和Uid关系维护
对于用户登录我们需要创建token--uid的关系，用户退出时需要需删除token--uid的关系。
签名实现 获取全部请求参数
String sign = request.getParameter("sign"); Enumeration&lt;?&gt; pNames = request.getParameterNames(); Map&lt;String, Object&gt; params = new HashMap&lt;String, Object&gt;(); while (pNames.hasMoreElements()) { String pName = (String) pNames.nextElement(); if("sign".equals(pName))continue; Object pValue = request.getParameter(pName); params.put(pName, pValue); } 生成签名
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/874913242ef96250b12fff9cd80d7924/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ffe150206d03285c608f0974051d004/" rel="bookmark">
			修改tomcat中的字符集问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 默认情况下，tomcat使用的是iso8859-1的编码编码方式，浏览器的embed标签中src指向的地址要通过tomcat去解析。如果包含中文，采用这种编码方式就会出现乱码问题，而在这种情况下，乱码问题就表现出无法访问该音频文件了。 解决方法很简单： 修改tomcat下的conf/server.xml文件，找到如下代码： connectionTimeout="20000" redirectPort="8443" /&gt; 这段代码规定了Tomcat监听HTTP请求的端口号等信息。可以在这里添加一个属性：URIEncoding，将该属性值设置为UTF-8，即可让Tomcat（默认ISO-8859-1编码）以UTF-8的编码处理get请求。更改后的代码如下所示： URIEncoding="UTF-8" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/75db856c97aacbc18af679dc0739b3b5/" rel="bookmark">
			Java如何获取ldap中的sid
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		(版权声明：原创作品，允许转载，转载时请务必以超链接形式标明文章 原始出处 、作者信息和本声明。否则将追究法律责任。）
一、对SID的初步认识
SID即安全标识符(System IDentifier)，它用来标识用户身份的。当系统每次创建用户都会分配一个唯一的SID。正因为SID有这样的特性，从Windows 2000以后的W系统对SID的依赖性较高，包括很多系统应用在内的系统内部进程引用帐户的SID而不是帐户的用户名和组名。因为用户的登陆名、显示名和归属的组等都可以修改，将一个帐户删除后再建立一个同名帐户，该账户的SID不同于被删除的那个帐户，所以它也不具有授权给前一个帐户的权利和权限。
二、系统如何使用SID
当用户通过输入用户名口令得到身份验证(authentication)后，系统内部进程会给用户发放一个访问令牌，其实也就相当于一个票证(ticket)。此后用户访问系统资源时不再需要提供用户名和口令，只需要将访问令牌提供给系统，然后系统检查用户试图访问对象(Resources)上的访问控制列表(ACL)。如果用户被允许访问该对象，系统将会分配给用户相应的访问权限，这也就完成了授权(authorization)的过程。
上面描述的其实就是一个authentication &amp; authorization的过程，那么如果系统修改了Resources ACL则需要等待ticket过期更换或者用户注销再登陆重新authentication获得新的ticket。
三、SID号码如何组成
例：S-1-5-21-2062728589-3024857285-4110131050-500
上面着一串是一个标准的SID。第一项S标示该字符串是SID；第二项是SID的版本号，这里版本号是1；第三项十标志符的颁发机构，Win2000之后的颁发机构都是5；最后是一系列资颁发机构前面3组是标志域，最后一组是标志域内的帐户和组。例子中的SID最后一段标志位是500，这代表了它是一个系统内置管理员帐号administrator的SID，又比如最后一段是501的话则是代表GUEST的帐号。有很多内置用户和组的SID相应标志位都是固定的,对应关系这里不再赘述。
四、如何获得用户和主机的SID
1、PsGetSid
PsGetSid是PsTools工具集中，由sysinternals发布,下载地址：http://download.sysinternals.com/Files/PsTools.zip 2、在控制台输入 whoami /all
五、Java代码的实现部分
Java Code 1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/75db856c97aacbc18af679dc0739b3b5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/16f2a792e24726b8287442238f776405/" rel="bookmark">
			dockerfile 多端口映射 expose
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家都知道，如果外界要和Docker容器进行通讯，那么除了link必须是port映射，下面先介绍下Dockerfile EXPOSE的用法，然后做一个多端口随机映射的实例吧。
格式为： EXPOSE PORT 下面是我的Dockerfile
# Tomcat # Version 0.0.1 # GET_IMAGE FROM 192.168.0.216:5000/centos # MAINTAINER_INFO MAINTAINER hongxue hongxue@showjoy.com RUN yum -y install vim RUN yum -y install net-tools RUN yum -y install openssh-server RUN yum -y install wget curl # PORT EXPOSE 8080 EXPOSE 22 EXPOSE 8009 EXPOSE 8005 EXPOSE 8443 我在Dockerfile中定义了 tomcat 的四个端口和ssh 22 端口，并且构建该配置档为镜像文件，镜像名为 port_list
docker build -t port_list . docker images | grep port_list 构建成功后运行该 images，注意在容器运行的时候一定要加-P
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/16f2a792e24726b8287442238f776405/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60c9bd89a8d9df559595c6ec67437e5e/" rel="bookmark">
			字符串转换时间，时区问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.字符串转化为时间，解决了关于相差8个小时的时区问题
NSString *dateStr= @"2012-05-17 11:23:23";
NSDateFormatter *format=[[NSDateFormatter alloc] init];
[format setDateFormat:@"yyyy-MM-dd HH:mm:ss"];
NSDate *fromdate=[format dateFromString:dateStr];
NSTimeZone *fromzone = [NSTimeZone systemTimeZone];
NSInteger frominterval = [fromzone secondsFromGMTForDate: fromdate];
NSDate *fromDate = [fromdate dateByAddingTimeInterval: frominterval];
NSLog(@"fromdate=%@",fromDate);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/55272e9f2cad4acc6098ca841a6d4bf8/" rel="bookmark">
			【iOS开发】Xcode 7 Simulator 问题小记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 问题1：Xcode -&gt; Preferences -&gt; Downloads 点击下载按钮弹出错误提示框 这里我没有再重现当时 Xcode 弹出错误提示框的场景，大概是在你想要下载 iOS 8.x 的 Simulator 或者 iOS 9.0 Documentation 的时候，告诉你有个什么什么地址不安全，你是否仍然要下载模拟器，然后你跟 Xcode 说『是的，我仍然要下载』 的时候，就没有然后了。
解决办法如下：
在终端输入如下内容，通过这个方式打开 Xcode:
/Applications/Xcode.app/Contents/MacOS/Xcode
或者进入 Finder：右键 Xcode.app -&gt; 显示包内容
Xcode.png 在我这里，通过这个方法启动 Xcode 一次之后，之后不再打开这个 Unix可执行文件，而只是在我的 Dock 栏用正常方式点开 Xcode，也可以正常下载 Simulator 了，虽然速度还是慢的出奇，不过至少能下载了。 Xcode -&gt; Preferences.png 问题2：模拟器可以启动 App，也可以进入后台，但是看不见主屏，主屏一直是纯黑色+白色状态栏 Reset Content and Settings.png 这个时候，像往常一样，点『Reset Content and Settings』是 没用的。 Xcode-&gt;Window-&gt;Devices.png 去上图的地方，Xcode-&gt;Window-&gt;Devices，右键左栏的模拟器，Delete掉，再点左下角的+号重新添加回来，就OK了 : ) 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cb7a885404ac15236c3ccb57cf901a5b/" rel="bookmark">
			bugFree环境搭建 及 bugFree环境搭建常见问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.环境搭建所需tools：
1）XAMPP
2）bugFree 3.0.4
2.XAMPP工具环境搭建好后如下图：
2.需要把下下来的bugFree3.0.4文件夹放到如下htdocs文件下，还需要建个BugFile文件夹,如下图：
3.bugFree环境安装好后需要实现邮件及时提醒功能，修改如下图：
4.搭建环境中常见问题及解决办法：
1）bugfree用admin新建用户后,新用户不能登录,提示无产品访问权限是怎么回事？
这样授予权限:后台管理-&gt;产品管理,选择某个产品-&gt;编辑-&gt;产品用户组,选择需要登陆的用户所在的用户组就可以了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39cf80434d458f511c5cac71fb793201/" rel="bookmark">
			OC类的成员变量的定义
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以成员变量 NSString *companyName为例： 1. 纯手工定义以及点语法：
AppDelegate.h @interface AppDelegate : UIResponder &lt;UIApplicationDelegate&gt; { ASIDownloadCache *myCache; NSString *companyName; //NSString *_companyName; 变量签名添加下划线，纯粹是命名习惯，和OC语法无关 } @property (strong, nonatomic) UIWindow *window; @property (nonatomic, retain) ICSDrawerController *drawer; @property (nonatomic, retain) rootBackViewController *rootVC; @property (nonatomic,retain) ASIDownloadCache *myCache; @end @implementation AppDelegate ...... -(void) setCompanyName:(NSString*)str { companyName = str; } -(NSString*) companyName{ return companyName; } ...... -(void) func { //这里点语法赋值，是OC的语法之一，作用就是自动调用setter和getter函数， 也可以通过@property 让编译器自动生成 self.companyName = @"Google Inc."; NSstring name = self.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39cf80434d458f511c5cac71fb793201/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c13b25a1d5e174f2bb60f481b928097b/" rel="bookmark">
			解决Laravel5.1使用composer update时出现Call to undefined method getCachedCompilePath()错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用php composer.phar update升级Laravel5.1时，会出现
PHP Fatal error: Call to undefined method Illuminate\Foundation\Application::getCachedCompilePath()
具体错误如下图所示
解决办法就是删除laravel/vendor/compiled.php文件
删除之后就可以升级成功了，Laravel会再自动生成该文件。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82eb68926e71f1aa7ff46160cd9568b5/" rel="bookmark">
			博客迁移
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 欢迎访问我的新博客 www.peierlong.com 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d050125db409206089a2ca1b56b1fd6/" rel="bookmark">
			STL源码剖析--vector
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		vector容器概述
vector的数据安排以及操作方式，与array非常相似。两者的唯一区别在于空间的运用的灵活性。array是静态空间，一旦配置了就不能改变；要换个大（或小）一点的房子，可以，一切琐细都得由客户端自己来：首先配置一块新空间，然后将元素从旧址一一搬往新址，再把原来的空间释还给系统。vector是动态空间，随着元素的加入，它的内部机制会自行扩充空间以容纳新元素。因此，vector的运用对于内存的合理利用与运用的灵活性有很大的帮助，我们再也不必因为害怕空间不足而一开始要求一个大块头的array了，我们可以安心使用array，吃多少用多少。
vector的实现技术，关键在于其对大小的控制以及重新配置时的数据移动效率。一旦vector的旧有空间满载，如果客户端每新增一个元素，vector的内部只是扩充一个元素的空间，实为不智。因为所谓扩充空间（不论多大），一如稍早所说，是”配置新空间/数据移动/释还旧空间“的大工程，时间成本很高，应该加入某种未雨绸缪的考虑。稍后我们便可看到SGI vector的空间配置策略了。
另外，由于vector维护的是一个连续线性空间，所以vector支持随机存取。
注意：vector动态增加大小时，并不是在原空间之后持续新空间（因为无法保证原空间之后尚有可供配置的空间），而是以原大小的两倍另外配置一块较大的空间，然后将原内容拷贝过来，然后才开始在原内容之后构造新元素，并释放原空间。因此，对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。这是程序员易犯的一个错误，务需小心。
以下是vector定义的源代码摘录：
#include&lt;iostream&gt; using namespace std; #include&lt;memory.h&gt; // alloc是SGI STL的空间配置器 template &lt;class T, class Alloc = alloc&gt; class vector { public: // vector的嵌套类型定义,typedefs用于提供iterator_traits&lt;I&gt;支持 typedef T value_type; typedef value_type* pointer; typedef value_type* iterator; typedef value_type&amp; reference; typedef size_t size_type; typedef ptrdiff_t difference_type; protected: // 这个提供STL标准的allocator接口 typedef simple_alloc &lt;value_type, Alloc&gt; data_allocator; iterator start; // 表示目前使用空间的头 iterator finish; // 表示目前使用空间的尾 iterator end_of_storage; // 表示实际分配内存空间的尾 void insert_aux(iterator position, const T&amp; x); // 释放分配的内存空间 void deallocate() { // 由于使用的是data_allocator进行内存空间的分配, // 所以需要同样使用data_allocator::deallocate()进行释放 // 如果直接释放, 对于data_allocator内部使用内存池的版本 // 就会发生错误 if (start) data_allocator::deallocate(start, end_of_storage - start); } void fill_initialize(size_type n, const T&amp; value) { start = allocate_and_fill(n, value); finish = start + n; // 设置当前使用内存空间的结束点 // 构造阶段, 此实作不多分配内存, // 所以要设置内存空间结束点和, 已经使用的内存空间结束点相同 end_of_storage = finish; } public: // 获取几种迭代器 iterator begin() { return start; } iterator end() { return finish; } // 返回当前对象个数 size_type size() const { return size_type(end() - begin()); } size_type max_size() const { return size_type(-1) / sizeof(T); } // 返回重新分配内存前最多能存储的对象个数 size_type capacity() const { return size_type(end_of_storage - begin()); } bool empty() const { return begin() == end(); } reference operator[](size_type n) { return *(begin() + n); } // 本实作中默认构造出的vector不分配内存空间 vector() : start(0), finish(0), end_of_storage(0) {} vector(size_type n, const T&amp; value) { fill_initialize(n, value); } vector(int n, const T&amp; value) { fill_initialize(n, value); } vector(long n, const T&amp; value) { fill_initialize(n, value); } // 需要对象提供默认构造函数 explicit vector(size_type n) { fill_initialize(n, T()); } vector(const vector&lt;T, Alloc&gt;&amp; x) { start = allocate_and_copy(x.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d050125db409206089a2ca1b56b1fd6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9c055c7074af51e4fd3294ed90d99369/" rel="bookmark">
			一个字段同时满足三个条件的查询语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一种写法： SELECT t.file_id FROM app_polly_file_labels t WHERE t.style = '清新' or t.style = '甜美' or t.style = '韩潮来袭' GROUP BY t.file_id HAVING count(t.file_id)=3 第二种写法： SELECT a.file_id FROM app_polly_file_labels a INNER JOIN app_polly_file_labels b ON a.file_id = b.file_id INNER JOIN app_polly_file_labels c ON a.file_id = c.file_id WHERE a.style ='清新' AND b.style ='甜美' AND c.style ='韩潮来袭' 两种写法的结果是一样的。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4292b362065f50b86d8200b90935ffe/" rel="bookmark">
			golang 反射结构字段类型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		golang 反射用法,做个笔记. package main import ( "fmt" "reflect" ) type roles struct { roleId int roleName string } type User struct { Name string Age int Email string NickName string Telphone int Roles roles } func main() { u := User{Name: "Name", Age: 30, Email: "xxxx@afanty3d.com", NickName: "omni360", Telphone: xxxxx, Roles: roles{roleId: 1001, roleName: "administrator"}} fmt.Println(u) Info(u) } func Info(o interface{}) { t := reflect.TypeOf(o) fmt.Println("Type:", t.Name()) v := reflect.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4292b362065f50b86d8200b90935ffe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f4700bc1e5ea3b00ce977e5d899f792a/" rel="bookmark">
			如何设置SELinux 策略规则 ? 在Kernel Log 中出现&#34;avc: denied&#34; 要如何处理？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		[Description] android KK 4.4 版本后，Google 默认启用了SELinux, 并会把SELinux 审查异常打印在kernel log 或者 android log(L 版本)中，对应的关键字是: "avc: denied" 或者"avc: denied" 如一行LOG： &lt;5&gt;[ 17.285600].(0)[503:idmap]type=1400 audit(1356999072.320:202): avc: denied { create } for pid=503 comm="idmap" name="overlays.list" scontext=u:r:zygote:s0 tcontext=u:object_r:resource_cache_data_file:s0 tclass=file 即表明idmap 这个process, 使用zygote 的source context, 访问/data/resource_cache 目录，并创建文件时，被SELinux 拒绝访问。 [Keyword] android, SELinux, avc: denied, audit [Solution] KK 版本, Google 只有限制的启用SELinux, 即只有针对netd, installd, zygote, vold 以及它们直接fork 出的child process 使用enforcing mode, 但不包括zygote fork的普通app. L 版本, Google 全面开启SELinux, 几乎所有的process 都使enforcing mode， 影响面非常广.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f4700bc1e5ea3b00ce977e5d899f792a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/330cc0144670f37bf0b4046d351a283d/" rel="bookmark">
			基于libevent的多线程通信框架实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		很久没有写博客了，这半年多时间一直很忙，一直没有更新博客，今天心血来潮准备做一篇，刚好把最近的新研究东西拿出来给大家分享一下！自己以前的一个后台程序框架（应用于了很多应用项目，运营商***拦截系统，国内某视频聊天应用的后台系统等），里面的网络部分基于ACE来实现的，最近准备淘汰ACE，大部分组件功能打算重写，所以基于网络这块打算用libevent来实现，在做的过程中发现了一些问题，就是能找到的例子都是单线程实现的，有多线的例子也没有写得那么详细，都是很简单的实现，经过一周时间对源码和api的分析，自己做了实现，经过测试还没有发现问题，效率上比之前的框架做了很大的提升，今天给大家贴出来，做分享交流。
NetFrame.h
// // NetFrame.h // Frame // // Created by chenjianjun on 15/9/7. // Copyright (c) 2015年 jsbn. All rights reserved. // #ifndef __Frame__NetFrame__ #define __Frame__NetFrame__ #include &lt;event.h&gt; #include &lt;glog/logging.h&gt; #include "Common.h" #include "Thread.h" namespace NAME_SPACE { class NetFrame { public: static NetFrame* Instance(); int NetWorkInit(); int NetWorkExit(); protected: NetFrame(); ~NetFrame(); private: class NetRunnable:public Runnable { public: NetRunnable(); ~NetRunnable(); protected: virtual void Run(void*); }; friend class NetRunnable; DISALLOW_EVIL_CONSTRUCTORS(NetFrame); public: static struct event_base* _base; private: Thread _main_loop_thread; volatile bool _run_flg; NetRunnable _runnable; }; } #endif /* defined(__Frame__NetFrame__) */ NetFrame.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/330cc0144670f37bf0b4046d351a283d/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/468/">«</a>
	<span class="pagination__item pagination__item--current">469/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/470/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>