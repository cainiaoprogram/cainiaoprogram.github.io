<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddf25433d45dc60b12c53a8a90cb2e8e/" rel="bookmark">
			Android-JVM基础
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		GC机制
垃圾回收需要完成两件事：找到垃圾，回收垃圾。
找到垃圾一般的话有两种方法：
1、引用计数法： 当一个对象被引用时，它的引用计数器会加一，垃圾回收时会清理掉引用计数为0的对象。但这种方法有一个问题，比方说有两个对象 A 和 B，A 引用了 B，B 又引用了 A，除此之外没有别的对象引用 A 和 B，那么 A 和 B 在我们看来已经是垃圾对象，需要被回收，但它们的引用计数不为 0，没有达到回收的条件。正因为这个循环引用的问题，Java 并没有采用引用计数法。
2、可达性分析法： 我们把 Java 中对象引用的关系看做一张图，从根级对象不可达的对象会被垃圾收集器清除。根级对象一般包括 Java 虚拟机栈中的对象、本地方法栈中的对象、方法区中的静态对象和常量池中的常量。
回收垃圾的话有这么四种方法：
标记清除算法： 顾名思义分为两步，标记和清除。首先标记到需要回收的垃圾对象，然后回收掉这些垃圾对象。标记清除算法的缺点是清除垃圾对象后会造成内存的碎片化。
复制算法： 复制算法是将存活的对象复制到另一块内存区域中，并做相应的内存整理工作。复制算法的优点是可以避免内存碎片化，缺点也显而易见，它需要两倍的内存。
标记整理算法： 标记整理算法也是分两步，先标记后整理。它会标记需要回收的垃圾对象，清除掉垃圾对象后会将存活的对象压缩，避免了内存的碎片化。
分代算法： 分代算法将对象分为新生代和老年代对象。那么为什么做这样的区分呢？主要是在Java运行中会产生大量对象，这些对象的生命周期会有很大的不同，有的生命周期很长，有的甚至使用一次之后就不再使用。所以针对不同生命周期的对象采用不同的回收策略，这样可以提高GC的效率。
新生代对象分为三个区域：Eden 区和两个 Survivor 区。新创建的对象都放在 Eden区，当 Eden 区的内存达到阈值之后会触发 Minor GC，这时会将存活的对象复制到一个 Survivor 区中，这些存活对象的生命存活计数会加一。这时 Eden 区会闲置，当再一次达到阈值触发 Minor GC 时，会将Eden区和之前一个 Survivor 区中存活的对象复制到另一个 Survivor 区中，采用的是我之前提到的复制算法，同时它们的生命存活计数也会加一。这个过程会持续很多遍，直到对象的存活计数达到一定的阈值后会触发一个叫做晋升的现象：新生代的这个对象会被放置到老年代中。 老年代中的对象都是经过多次 GC 依然存活的生命周期很长的 Java 对象。当老年代的内存达到阈值后会触发 Major GC，采用的是标记整理算法。
JVM内存区域的划分，哪些区域会发生 OOM?
JVM 的内存区域可以分为两类：线程私有和区域和线程共有的区域。
线程私有的区域：程序计数器、JVM 虚拟机栈、本地方法栈
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ddf25433d45dc60b12c53a8a90cb2e8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1874b4de50f7a72b34b54ddd7f7fa206/" rel="bookmark">
			【Verilog】期末复习——设计带进位输入和输出的8位全加器，包括测试模块
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 系列文章 数值（整数，实数，字符串）与数据类型（wire、reg、mem、parameter）
运算符
数据流建模
行为级建模
结构化建模
组合电路的设计和时序电路的设计
有限状态机的定义和分类
期末复习——数字逻辑电路分为哪两类？它们各自的特点是什么？
期末复习——VerilogHDL描述数字逻辑电路的建模方式有哪三种？它们的特点是？
期末复习——解释下列名词（FPGA、ASIC、IP、RTL、EDA、HDL、FSM）
期末复习——简要说明仿真时阻塞赋值和非阻塞赋值的区别。always语句和initial语句的关键区别是什么？能否相互嵌套？
系列文章 module fulladder(a,b,ci,sum,co); input [7:0]a,b; input ci; output [7:0] sum; output co; assign {co,sum}=a+b+ci; endmodule 测试模块示例：
module fuadder_tb; reg[7:0] a,b;	//输入信号为reg型 reg ci;	wire[7:0] sum; wire co;	//输出信号为wire型 fulladder U1(a,b,ci,sum,co);	//实例化 initial begin a=8'b0000_0001, a=8'b0000_0001,ci=0; #10 a=8'b0000_0010, a=8'b0000_0001; #10 a=8'b0000_0011, a=8'b0000_0011; #10 a=8'b0000_0110, a=8'b0000_0011; #10 a=8'b0000_1010, a=8'b0000_0111; end endmodule 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9751514c54162871a4af7da4f21c0e1/" rel="bookmark">
			机器学习（四） -- 模型评估（4）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 机器学习（一） -- 概述
机器学习（二） -- 数据预处理（1-3）
机器学习（三） -- 特征工程（1-2）
机器学习（四） -- 模型评估（1-4）
未完待续……
目录
机器学习（四） -- 模型评估（1）
机器学习（四） -- 模型评估（2）
机器学习（四） -- 模型评估（3）
---
目录
系列文章目录
前言
四、 聚类模型评估指标
1、外部指标
1.1、兰德指数（RI，Rand index）
1.1.1、调整兰德指数（Adjusted Rand index）
1.2、基于互信息的分数（MI，Mutual Information-based Score）
1.2.1、标准化互信息（NMI，Normalized Mutual Information）
1.2.2、调整互信息（AMI，Adjusted mutual information）
1.3、同质性（Homogeneity Score）和完整性（Completeness Score）以及其调和平均（V-measure）
1.3.1、同质性（Homogeneity Score）
1.3.2、完整性（Completeness Score）
1.3.3、V-measure
1.4、Fowlkes-Mallows Scores（FMI）
2、内部指标
2.1、轮廓系数（Silhouette Coefficient）
2.2、Calinski-Harabaz指数（Calinski-Harabaz Index，也称Variance Ratio Criterion）
2.3、戴维森堡丁指数（DBI，Davies-Bouldin Index）
3、总结
前言 tips：这里只是总结，不是教程哈。
“***”开头的是给好奇心重的宝宝看的，其实不太重要可以跳过。
此处以下所有内容均为暂定，因为我还没找到一个好的，让小白（我自己）也能容易理解（更系统、嗯应该是宏观）的讲解顺序与方式。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9751514c54162871a4af7da4f21c0e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/164f178b38e32b8936080e38774c4d11/" rel="bookmark">
			机器学习（四） -- 模型评估（2）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章目录 机器学习（一） -- 概述
机器学习（二） -- 数据预处理（1-3）
机器学习（三） -- 特征工程（1-2）
机器学习（四） -- 模型评估（1-4）
未完待续……
目录
机器学习（四） -- 模型评估（1）
---
系列文章目录
前言
三、分类模型评估指标
1、错误率与精度（准确率）
2、查准率（精确率）、查全率（召回率）与F1值（F1_score）
2.1、混淆矩阵（confusion matrix）
2.2、查准率（precision，精确率）
2.3、查全率（recall，召回率）
2.4、P-R图
2.5、F1值（F1_score）
2.6、其他
3、ROC与AUC
4、分类报告
--- 机器学习（四） -- 模型评估（3）
机器学习（四） -- 模型评估（4）
前言 tips：这里只是总结，不是教程哈。
“***”开头的是给好奇心重的宝宝看的，其实不太重要可以跳过。
此处以下所有内容均为暂定，因为我还没找到一个好的，让小白（我自己）也能容易理解（更系统、嗯应该是宏观）的讲解顺序与方式。
第一文主要简述了一下机器学习大致有哪些东西（当然远远不止这些），对大体框架有了一定了解。接着我们根据机器学习的流程一步步来学习吧，掐掉其他不太用得上我们的步骤，精练起来就4步（数据预处理，特征工程，训练模型，模型评估），其中训练模型则是我们的重头戏，基本上所有算法也都是这一步，so，这个最后写，先把其他三个讲了，然后，在结合这三步来进行算法的学习，兴许会好点（个人拙见）。
衡量模型泛化能力的评价标准就是性能度量（模型评估指标、模型评价标准），而针对不同的任务有不同的评价指标。按照数据集的目标值不同，可以把模型评估分为分类模型评估、回归模型评估和聚类模型评估。
三、分类模型评估指标 错误率与精度（准确率）、混淆矩阵、查准率（精确率）、查全率（召回率）与F1值（F1_score）、PR曲线、ROC与AUC
1、错误率与精度（准确率） 概述里面就说过了，这是分类任务中最常用的两种性能度量。
错误率（error rate）：分类错误的样本数/样本总数
​​
（公式还是要知道的，Ⅱ(*)是指示函数，在*为真（假）时取值为1（0））
精度（accuracy，准确率）：1-错误率=分类正确的样本数/样本总数
​​
from sklearn.datasets import load_iris from sklearn.tree import DecisionTreeClassifier from sklearn.model_selection import train_test_split # 引入数据集 iris = load_iris() # 划分数据集以及模型训练 x_train, x_test, y_train, y_test = train_test_split(iris.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/164f178b38e32b8936080e38774c4d11/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10741b581a56c07fd50b09ac1feff6d6/" rel="bookmark">
			【Verilog】期末复习——VerilogHDL描述数字逻辑电路的建模方式有哪三种？它们的特点是？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 系列文章 数值（整数，实数，字符串）与数据类型（wire、reg、mem、parameter）
运算符
数据流建模
行为级建模
结构化建模
组合电路的设计和时序电路的设计
有限状态机的定义和分类
期末复习——数字逻辑电路分为哪两类？它们各自的特点是什么？
系列文章VerilogHDL描述数字逻辑电路的建模方式有哪三种？它们的特点是？ VerilogHDL描述数字逻辑电路的建模方式有哪三种？它们的特点是？ 数据流建模。输入信号经过组合逻辑电路传到输出时类似于数据流动，而不会在其中存储。可以通过连续赋值语句这种特性进行建模，这种建模方式通常被称为数据流建模。行为级建模。从电路外部行为的角度对其进行描述，因此行为级建模是从一个层次很高的抽象角度来表示电路的。结构化建模。结构描述方式就是将硬件电路描述成一个分级子模块系统，通过逐层调用这些子模块构成功能复杂的数字逻辑电路和系统。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae1dafff116d659ba3604c760edd5018/" rel="bookmark">
			css面试题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		background：设置背景色
属性：
background-color：设置元素的背景色。颜色会填充内容、内编剧和边框区域，扩展到元素边框的外边界（但不包含外边距）。如果边框有透明颜色（如虚线边框），则会透过这些透明部分显示出背景色
background-position：设置背景图像的其实位置。提示：您需要把 background-attachment 属性设置为 “fixed”，才能保证该属性在 Firefox 和 Opera 中正常工作。 background-size：背景图像的尺寸
length设置背景图像的高度和宽度。第一个值设置宽度，第二个值设置高度。如果只设置一个值，则第二个值会被设置为 “auto”。
percentage：以父元素的百分比来设置背景图像的宽度和高度。
cover：把背景图像扩展至足够大，以使背景图像完全覆盖背景区域。背景图像的某些部分也许无法显示在背景定位区域中。
contain：把图像图像扩展至最大尺寸，以使其宽度和高度完全适应内容区域。
background-repeat：是否及如何重复背景图片。repeat|repeat-x|repeat-y|no-repeat|inherit;
background-origin：规定 background-position 属性相对于什么位置来定位。规定
background-position：相对于什么位置来定位。padding-box|border-box|content-box;
background-clip：规定背景的绘制区域。padding-box|border-box|content-box;见下图
background-attachment：背景图像是否固定或者随着页面的其余部分滚动。scroll|fixed|inherit;
background-image：使用的背景图像
background: bg-color bg-image position/bg-size bg-repeat bg-origin bg-clip bg-attachment initial|inherit;
+选择器匹配紧邻的兄弟元素
～选择器匹配随后的所有兄弟元素
:nth-of-type(n)选择器匹配属于父元素的特定类型的第N个子元素的每个元素 :nth-child(n)选择器匹配属于其父元素的第N个子元素，不论元素类型 Css优先级：
!important &gt; style(行内1000) &gt; id(权重100) &gt; class，属性选择器或者伪类(权重10) &gt; 元素选择器，伪元素(权重1)，通配符+0。同类别的样式中，后面的会覆盖前面的
css属性content有什么用
Content属性与::before和::after伪元素配合使用，用来插入生成的内容，可以在元素之前或之后放置生成的内容。可以插入文本，图片，引号，并可以结合计数器，为页面元素插入编号
图片间隙问题如何解决
两个图片之间和图片下方出现的空白间隙可以使用以下方式解决
方法1、将图片显示为块 ，解决下方间隙img{display:block}
方法2、改变图片的vertical-align解决下方间隙mg{vertical-align:middle}/top/bottom
方法3、设置图片父级标签的font-size:0;line-height:0;水平间隙，图片下方间隙都能解决
flex布局
Flex 是 Flexible Box 的缩写，意为"弹性布局"，用来为盒状模型提供最大的灵活性。
注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。
align-content作用于纵轴多行元素，一行元素不起作用 Align-items作用域纵轴单行元素
Order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0
Flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae1dafff116d659ba3604c760edd5018/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5f80b9e89dff6992c3c1aafe17f61020/" rel="bookmark">
			闪速优选--五天学会SpringCloud实战
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 本专栏带你用Spring Cloud Alibaba搭建一套项目，让你五天掌握微服务的使用。
微服务是很重要的技术，学会微服务会大大提升个人竞争力，大大提高简历筛选和面试通过率。项目名字：闪速优选。
SpringCloudAlibaba在2020年之后的微服务项目中占主流，学它是最好的选择。
教程地址：SpringCloud项目实战 - 自学精灵
学习路线 运行体验=&gt; 基础知识=&gt; 下载和安装Nacos
=&gt; 搭建网关项目=&gt; 添加项目依赖=&gt; 编写业务代码
=&gt; 提供feign接口=&gt; 在Nacos管理页面进行配置
=&gt; 启动项目并测试=&gt; 项目总结
教程截图 主页 项目场景 运行体验 搭建项目 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/337d0ec02b313ffca03c5b3c84f057e7/" rel="bookmark">
			回味2023
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		回味2023 前言匆匆而逝的一年一些想法希望的2024 前言 2024年1月7日，和过去的几个年头一样，每当过完一年，总会简单的对自己过去的一年做个总结，今年也不例外。
第一次一年的总结我记得是2020年的时候吧，转眼间四年悄然过去，茫茫碌碌中居然过到了2024年，回头仔细想想，自2021年6月走出校门，我以及毕业整整两年半。但心里给自己的感觉却是才过于几个月似的。每每写到一年的回忆，我总是忍不住感叹时间流逝之快，这种感觉时间流逝越来越快的感受，仿佛也在随着时间的流逝越加的浓烈。仿佛我用三个月过完了毕业后的两年半，而且我感觉未来的每一年时间流逝的都会越来越快。我清楚的知道自己和千万的一项漂泊的打工人一样普普通通，做一份普通的工作，挣一份还算可以的薪资，生活过的虽平淡但也算可以；但是内心的自己告诉我，这种过过分的平淡和碌碌无为，周而复始是我的内心无法接受的，每次想到这里我都务必的煎熬，我随普通，但我依旧想追求一个不平凡的人生，最起码让自己觉得每天都有意义。
匆匆而逝的一年 回顾过去的一年时间，仿佛给我印象最深刻的是一年的忙碌以及各种事与愿违的无奈。从年初的2月一直到11月底，感觉都笼罩在忙碌和焦虑之中。再加上时间流逝的飞快，感觉一整个人这一年都处于紧绷的状态。
写个这个年终总结时，我打开写2022年总结时的自己给2023年的计划，看的自己无奈和悲催。总共六件的事情，却只完成了两件，而且是最简单的两件，只需要按部就班平平淡淡度日就能完成的两件，而其他的，需要专注与其中，需要长久不懈的坚持和持续的输出的东西，一样也没有完成。细细想来，从大学毕业至今，好像只有按时上班是我这两年一直坚持下来了的事情，其他的，无论是读书、还是学习摄影、学习吉他、考取证券从业资格亦或者脱单都是没有做到或者没有坚持下来的。
回顾我的2023，感觉平庸无奇的忙碌和加班，以及对自己碌碌无为的焦虑，好想没有其他什么好写的东西了，不过值得自己高兴的是，总算是在这一年时间了自己提车的愿望，这应该是2023年最值得庆幸的日子了，一年的奋斗，终于为自己的汽车梦想交上了一份答卷。
每个人的社交动态大概完整的记录了他的一年生活吧，每当写年终总结的时候，仿佛也只有通过翻相册和自己的社交动态，才能回想起一年以来发生的一幕幕。
**2023年1月：**时隔三年，没有了疫情的影响终于顺利的回了趟家，见了父母和爷爷以及家中的所有亲戚朋友，很多人上次见面其实是四五年前了，2022年由于疫情，回到老家机场后被封锁，最终原路返回，2023年的春节回家，显得更加的有意义。
2023年2、3、4月： 回了趟家后，心也定下来好多，也不像过年前那样一直期待回老家，这几个月的时间基本都处于忙忙碌碌了，加不完的班，做不完的需求，以及充斥在心中的怕完不成任务的各种焦虑。这几个月也是上半年中过的最快的一年。
**2023年5、6月 ** 5月应该是2023年上半年中过的最难忘的一个月，劳动节期间我又一次回了趟家，疫情三年没能回家的时光让我感受到了回家的不易和重要性，所以趁着没有了疫情，趁着能回去，我想抓住每一个能回家的机会好好和家人团聚。而5月的下旬，则是客户生产出问题后凌晨两三点下班，早上八点多上班的两周，也是过的最难熬的两周，每天对着无聊的代码翻bug找bug，写各种测试用例测bug。和现场对接排查问题。6月也是处在无穷的加班中。
2023年7月： 最值得期待的一个月，心心念念的提车计划，终于在这个月实现。从毕业时一直在想在自己有能力时要提一辆自己喜欢的能力范围内的车。可是刚毕业的时间内，即要还助学贷款，又要解决家中的事情，根本一分钱也存不下来，知道2022年下半年开始，才能慢慢的存下一些钱，身上不在背负债务的时候，才有了买车的勇气。在7月终于完成了自己的心愿。
2023年8、9、10月： 关小黑屋的三个月，光大项目的研发，所有人被拉到会议室封闭开发，又是每日每页的加班。仿佛这一年的绝大多数时间都是在加班中度过。
2023年11月、12月： 相比于前面的时间，加班稍微少了一些，但也是处在忙碌和焦虑之中，无时无刻不感觉到时间流逝之快。
一些想法 2023年，完成了一些事情，但更多的是留下了遗憾。没有像预想的那样一步步的提高自己，充实自己，让生活不在焦虑，而是感觉又是浑浑噩噩的过了一年。感觉距离30岁也越来越近。
希望的2024 回首过去的一年时光，除了所谓兢兢业业的工作和无始无终的加班，好像也总结不出什么。
一周一周的，周而复始的工作，仿佛已经把自己二十多岁青春的气息磨得所剩无几，公司到住所的两点一线也让日常生活乏味，这种平淡乏味的生活自毕业一直保持到现在。
但自己想想，自己才二十多岁啊，应该有自己的追求，有自己的理想和爱好，更应该有为改变未来而坚持不懈的勇气，
新的一年，2024我希望自己能够做出一些改变和提升。
怕那和千万漂泊异乡的打工人一样进行着周而复始的工作，我也希望工作生活因尝试做的改变而不在一成不变，不在一眼望到头。26岁的年纪，虽距离人们常说的
三十而立的而立之年只有四年时间，但是如今二十多岁的年纪我还算的上年轻，还有很多机会等着尝试，还有很多想做但还未做的事情等着去完成。尝试做一些改变吧，
尝试提升自己，尝试坚持自己的爱好。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4fbc9d4a28cf97a3e3792840c1b3f255/" rel="bookmark">
			看图识熊（五）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		其它信息 点击界面右上角的齿轮，可以看到免费用户每个项目能够使用的服务额度：
一共可以上传5000张图片，创建50个不同标签，保存10次迭代的结果。
这十次迭代有什么用呢？当需要增删标签、给标签添加或删除训练图片时，这次再训练，就会花费掉一次迭代。
这些都是当前项目的总数而不是累计值。对于一般的免费用户，这基本上就相当于你可以随意使用这项服务了，如果有大量的训练数据，那么建议您还是订阅Azure云服务，Azure秉持着使用多少收费多少的原则，即使收费，也仍然良心。
导出模型 为了构建本地离线推理应用，我们需要下载模型。点击顶部Performance按钮回到训练结果页面并切换到要使用的Iteration，然后点击Export按钮，可以看到如下所示的导出页面。
定制化视觉服务一共提供了四种模型的导出，对三大操作系统都能支持，这里我们选择ONNX。
ONNX，全称Open Neural Network Exchange，即开放神经网络交换格式，是由微软、FaceBook等多个相关公司一起推动的深度学习模型标准。Microsoft Cognitive Toolkit、Caffe2、PyTorch等工具已经支持ONNX。
选择ONNX后，在Choose a version下拉框中选择ONNX1.2，点击Export，等待服务器把模型导出后，然后点击Download，即可下载模型，这里将名字改为BearModel.onnx。
注意，存放模型文件的路径不要包含中文。
查看模型 Netron是一个开源的模型信息的查看器，支持多种模型格式，可以下载安装使用，也可以在线查看模型信息。
Netron打开后，点击Open model选择打开之前下载的BearModel.onnx文件。然后点击左上角的汉堡菜单显示模型的输入输出。
上图中可以看到该模型需要的输入data是一个float数组，数组中要求依次放置227*227图片的所有蓝色分量、绿色分量和红色分量，后面程序中调用时要对输入图片做相应的处理。
上图中还可以看到输出有两个值，第一个值classLabel是确定的分类的标签，这里只需用到第二个输出即可，第二个值loss包含所有分类的得分。
构建应用 模型有了之后，这里就可着手构建应用程序来使用模型了。
这里以Windows平台为例，应用程序使用C#语言。我们有三种方案：
使用Windows Machine Learning加载模型并推理，这种方式要求系统必须是Windows 10，版本号大于等于17763，详细步骤在这个文档
使用ONNX Runtime加载模型并推理。这是微软开源项目，会持续更新，跨平台、跨语言，而且支持CPU、GPU推理，使用也十分方便。详细步骤在这个文档
不推荐使用 Tools for AI对模型进行封装，可以运行在 Windows 7 或 Windows 10，但目前仅支持x64平台，详细步骤在这个文档
小结 我们回顾一下本案例体验了哪些过程。首先，我们收集了一些数据，并给它们进行了分类。然后，使用定制化视觉服务训练并导出了模型。再然后就是代码部分，设计了界面、让它与代码能够联动。再然后就是代码中比较复杂的部分，即数据的规范化。最后的推理预测其实只有一行代码就够了。完成后，我们又添加新数据重新训练了一遍。
这个案例很简单，主要是希望大家体验一下AI应用开发。其实AI应用开发和我们传统的应用开发没有太大区别，可以认为就是调用了一个神奇的函数，给它一些数据，它就还给你一个答案。如果多有几个神奇的函数，那么就能做出更加智能的程序，就成为了真正的产品了。
最后，给大家留个小作业：大家可以用卡通熊或者毛绒熊玩具的照片测试一下，然后考虑如何能把这几种熊从真实熊的照片中区分出来。完成后可以找出一些新的卡通熊或毛绒熊图片进行测试，看看能否达到较好的分类效果。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e20ac8302415082a1e6ec215b5c78b3/" rel="bookmark">
			展开运算符（Spread Operator）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		展开运算符（Spread Operator）是ES6中引入的一种语法，使用三个连续的点（...）表示。它可以在多种场合下使用，主要用途是“展开”数组或对象中的元素或属性。
使用展开运算符的几种常见情景：
在函数调用时展开数组元素: function sum(x, y, z) { return x + y + z; } const numbers = [1, 2, 3]; console.log(sum(...numbers)); // 相当于执行 sum(1, 2, 3)，输出6 在数组字面量中合并多个数组: const fruits = ['apple', 'banana']; const moreFruits = ['orange', 'grape']; const allFruits = [...fruits, ...moreFruits]; console.log(allFruits); // 输出 ['apple', 'banana', 'orange', 'grape'] 复制数组: const arr = [1, 2, 3]; const arrCopy = [...arr]; // 创建arr的一个浅拷贝 在对象字面量中合并对象: const obj1 = { foo: 'bar', x: 42 }; const obj2 = { foo: 'baz', y: 13 }; const mergedObj = { .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e20ac8302415082a1e6ec215b5c78b3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/af894ff75d09afdea7280fee3d9539fe/" rel="bookmark">
			【Verilog】运算符
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系列文章 数值（整数，实数，字符串）与数据类型（wire、reg、mem、parameter）
系列文章算术运算符关系运算符相等关系运算符逻辑运算符按位运算符归约运算符移位运算符条件运算符连接和复制运算符 算术运算符 Verilog HDL中常用的算术运算符主要有五种，分别是加法(+)、减法(-)、乘法(*)、除法(/)和取模(%)。
算术操作结果的位宽。 算术表达式结果的长度由最长的操作数决定。 在赋值语句下，算术操作结果的长度由操作左端的目标长度决定。
关系运算符 关系运算符也是双目运算符，是对两个操作数的大小进行比较。关系运算符有大于(&gt;)、小于(&lt;)、大于等于(&gt;=)和小于等于(&lt;=)几种。
在进行关系比较时，如果成立则结果为“1”，否则返回的结果为“0”；若不确定则返回结果为不定值(x)。例如：10&gt;15的结果为假(0)，20&gt;18的结果为真(1)，而4’b1101&lt;4’hx的结果为不定值(x)。
相等关系运算符 相等关系运算符是对两个操作数进行比较，比较的结果有三种：真(1)、假(0)和不定值(x)。Verilog HDL语言中有四种相等关系运算符：等于( == )、不等于( != )、全等(===)、非全等(! ==)。
“==”和“!=”称为逻辑等式运算符，其结果由两个操作数的值决定。
“ === ”和“ !== ”运算符则不同，它是对操作数进行按位比较，两个操作数必须完全一致，其结果才是1，否则为0。但是，若两个操作数对应位出现不定值x和高阻值z，则可认为是相同的。“ ===”和“!==”运算符常用于case表达式的判别，所以又称为“case等式运算符”。
逻辑运算符 逻辑运算符有三种，分别是逻辑与运算符(&amp;&amp;)、逻辑或运算符(||)、逻辑非运算符(!)。其中逻辑与和逻辑或是双目运算符，逻辑非为单目运算符。
逻辑运算符的操作数只能是逻辑0或者逻辑1。
三种逻辑运算符的真值表如下所示：
在逻辑运算符的操作过程中，如果操作数是1位的，那么1就代表逻辑真，0就代表逻辑假；如果操作数是由多位组成的，则当操作数每一位都是0时才是逻辑0值，只要有某一位为1，这个操作数就是逻辑1值。例如：寄存器变量a、b的初值分别为4’b1110和4’b0000，则 !a=0，!b=1，a&amp;&amp;b=0；a||b=1。
需注意的是，若操作数中存在不定态x，则逻辑运算的结果也是不定态，例如：a的初值为4’b1100，b的初值为4’b01x0，则 !a=0，!b=x，a&amp;&amp;b=x，a||b=x。
按位运算符 数字逻辑电路中，信号与信号之间的运算称为位运算。Verilog HDL提供了以下五种类型的位运算符：按位取反(**)、按位与(&amp;)、按位或(**|**)、按位异或(**^**)、按位同或(**^)。
按位运算举例：
module bit_tb; reg[2:0]a; reg[4:0]b; initial begin a=5'b101;//运算的时候a自动变为5'b00101 b=5'b11101; $display("%b",~a);//结果为3'b010 $display("%b",~b);//结果为5'b00010 $display("%b",a&amp;b);	//结果为5'b00101 $display("%b",a|b); //结果为5'b11101 $display("%b",a^b);	//结果为5'b11000 end endmodule 归约运算符 归约运算符按位进行逻辑运算，属于单目运算符。由于这一类运算符操作的结果是产生1位逻辑值，因而被形象地称为缩位运算符。
Verilog HDL中，缩位运算符包括&amp;(与)、| (或)、^ (异或)以及相应的非操作&amp;、|、^、^。归约运算符的操作数只有一个。
归约运算符的运算过程是：设a是一个4位的寄存器型变量，它的四位分别是a[0]、a[1]、a[2]和a[3]。当对a进行缩位运算时，先对a[0]和a[1]进行缩位运算，产生1位的结果，再将这个结果与a[2]进行缩位运算，再接着是a[3]，最后产生1位的操作结果。
归约操作举例：
module cut_tb; reg[5:0]a; initial begin a=6'b101011; $display("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/af894ff75d09afdea7280fee3d9539fe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d97aafa4e777732c9121384c21f81fa2/" rel="bookmark">
			如何解决数据治理解决方案中数据质量问题？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		随着大数据时代的来临，数据治理已成为企业提升数据质量、保障数据安全、优化业务流程的重要手段。然而，数据治理过程中经常面临各种数据质量问题，如数据不准确、数据缺失、数据冗余等。这些问题可能导致企业决策失误、业务流程受阻，甚至损害企业形象。
因此，解决数据治理中的数据质量问题至关重要。本文将为您解析数据治理中的常见数据质量问题，并提出相应的解决策略与实践。
一、数据治理中的常见数据质量问题 数据不准确：数据在实际操作中经常因为人为错误、系统缺陷等原因产生误差，导致数据不准确。
数据缺失：由于数据采集不全、数据传输中断等原因，导致部分数据无法获取或丢失。
数据冗余：不同数据源之间存在重复数据，导致数据冗余。
数据不一致：不同部门或不同系统之间的数据标准不一致，导致数据难以整合和利用。
数据安全问题：数据泄露、数据篡改等安全问题，威胁企业信息安全。
二、解决数据质量问题的策略与实践 制定严格的数据质量标准：明确数据的精度、完整性、一致性等质量要求，制定相应的数据质量标准。
数据清洗与校验：通过技术手段对数据进行清洗和校验，去除重复、不准确、不完整的数据。
数据备份与恢复：建立健全的数据备份和恢复机制，确保数据的可靠性和安全性。
数据整合与标准化：统一不同部门和系统的数据标准，实现数据的整合与标准化。
建立数据质量监控体系：定期对数据进行质量检查和评估，及时发现并解决数据质量问题。
提高员工的数据素养：加强员工的数据意识和技能培训，提高员工对数据的重视程度和使用能力。
引入第三方专业机构：寻求第三方专业机构的支持和指导，利用其专业知识和经验提高数据质量。
建立奖惩机制：通过建立合理的奖惩机制，激励员工积极参与数据治理工作，提高数据质量。
创新技术应用：不断引入新技术和方法，如人工智能、机器学习等，辅助数据治理工作，提高数据处理效率和准确性。
持续改进与优化：定期评估数据治理实践效果，收集员工反馈意见，持续改进和优化数据治理策略和实践。
三、案例分享：某企业的数据治理实践 某大型企业为了解决数据质量问题，采取了一系列措施。
首先，该企业制定了严格的数据质量标准，明确了数据的精度、完整性、一致性等要求。
其次，该企业引入了先进的数据清洗和校验技术，对数据进行清洗和去重处理，确保数据的准确性。同时，该企业建立了完善的数据备份和恢复机制，确保数据的可靠性和安全性。
此外，该企业统一了不同部门和系统的数据标准，实现了数据的整合与标准化。为了提高员工的数据素养，该企业还加强了对员工的培训和教育。通过这些实践措施的落地实施，该企业的数据质量得到了显著提升，为企业的决策和业务发展提供了有力支持。
总结： 解决数据治理中的数据质量问题需要从多个方面入手，包括制定严格的数据质量标准、进行数据清洗与校验、建立备份与恢复机制、统一数据标准、建立监控体系等。同时，提高员工的数据素养、引入第三方专业机构、创新技术应用、持续改进与优化等也是重要的实践策略。
通过综合运用这些策略与实践方法，企业可以有效地解决数据治理中的数据质量问题，提升数据的准确性和可靠性，为企业的决策和业务发展提供有力支持。
数环通_SaaS应用连接器_无代码数据集成IPAAS - 数环通
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bf06948d13e6051d7aa05916c26a1e48/" rel="bookmark">
			LeetCode 0447.回旋镖的数量：哈希表
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【LetMeFly】447.回旋镖的数量：哈希表 力扣题目链接：https://leetcode.cn/problems/number-of-boomerangs/
给定平面上 n 对 互不相同 的点 points ，其中 points[i] = [xi, yi] 。回旋镖 是由点 (i, j, k) 表示的元组 ，其中 i 和 j 之间的距离和 i 和 k 之间的欧式距离相等（需要考虑元组的顺序）。
返回平面上所有回旋镖的数量。
示例 1：
输入：points = [[0,0],[1,0],[2,0]] 输出：2 解释：两个回旋镖为 [[1,0],[0,0],[2,0]] 和 [[1,0],[2,0],[0,0]] 示例 2：
输入：points = [[1,1],[2,2],[3,3]] 输出：2 示例 3：
输入：points = [[1,1]] 输出：0 提示：
n == points.length1 &lt;= n &lt;= 500points[i].length == 2-104 &lt;= xi, yi &lt;= 104所有点都 互不相同 方法一：哈希表 第一重循环枚举每个 j j j点。对于points[j]，使用一个哈希表，记录所有的点到j点的距离的出现次数。然后遍历哈希表，假设某距离出现了cnt次，那么就将 c n t × ( c n t − 1 ) cnt\times(cnt-1) cnt×(cnt−1)累加到答案中。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bf06948d13e6051d7aa05916c26a1e48/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f40351db7bb0d535b4dac83468b5e9d9/" rel="bookmark">
			全球排名第六！北京程序员年薪中位数超 60 万元，2023 全球程序员收入报告出炉...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		点击上方“视学算法”，选择加"星标"或“置顶”
重磅干货，第一时间送达
| CSDN（ID：CSDNnews）
刚刚过去的 2023 年，被许多人称作“AI 元年”，而实际上不仅是 AI，区块链、大数据、云计算等技术领域也在不断推进创新，其背后程序员的技能和洞察力成为了企业成功不可或缺的一部分。
在这样的动态发展下，程序员的收入水平也呈现出了多样化趋势：于是 2024 年伊始，知名数据收集网站 Levels.fyi 最新发布了一份《2023 年全球程序员收入报告》，深刻解读全球技术人才的市场动态。
北京程序员，年薪中位数超 60 万元
与 2022 年相比，2023 年大多数职位的薪酬中位数都有所增加——除了产品设计师和软件工程师。
过去一年中，技术项目经理的薪酬涨幅最大（3.2%），从 21.5 万美元增至 22.2 万美元，其次是软件工程经理，薪酬涨幅为 2.16%。反观产品设计师和软件工程师，其年薪中位数都有不同程度的下滑，分别下滑了 0.26% 和 0.57%。
除了根据职位观察程序员的收入水平，Levels.fyi 还根据地域不同，对美国、欧洲和全球程序员的年薪中位数进行了排名：
（1）全球热门城市
从全球范围看，程序员收入最高的城市 Top 3 是：以色列特拉维夫（13.7 万美元），加拿大温哥华（11.5 万美元）和澳大利亚悉尼（11 万美元）。其中，中国北京的程序员收入也较高，薪资中位数为 9 万美元（约人民币 64.4万元），位居榜单第六，相较于 2022 年的 7.9 万美元有了较大幅度的提升。
（2）美国热门城市
在美国范围内，程序员收入最高的地区是旧金山湾区（24.9 万美元）、西雅图地区（22.5 万美元）和纽约市地区（18.5 万美元），基本与 2022 年的榜单排名一致。
（3）欧洲热门城市
在欧洲程序员收入最高的城市中，瑞士苏黎世以 18 万美元的年薪中位数稳居第一，其次瑞士洛桑和英国伦敦分别以 12.7 万美元和 11.7 万美元的收入位于第二和第三位。
OpenAI 冲进第一，谷歌和微软已连续两年没有上榜
除了受地域因素影响，程序员的收入水平很大程度取决于其职级的不同。为此，Levels.fyi 根据工程师岗位级别，将程序员分为五个等级：初级工程师，中级工程师，高级工程师，主管工程师以及首席工程师，以此来对比各个级别之间的收入差距。
（1）初级工程师 初级工程师的工作经验通常低于 2 年，多是应届毕业生或几乎没有相关行业经验。一般这类工程师需要更有经验的团队成员的指导，在团队中负责开发和维护复杂度较低的组件。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f40351db7bb0d535b4dac83468b5e9d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/053b4a3979bf5350a8a579df33f415ca/" rel="bookmark">
			微软祭出代码大模型WaveCoder！4项代码任务2万个实例数据集，让LLM泛化能力飙升...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		视学算法报道 编辑：桃子
【视学算法导读】指令调优或许是让大模型性能提升最有潜力的方法。 用高质量数据集进行指令调优，能让大模型性能快速提升。
对此，微软研究团队训练了一个CodeOcean数据集，包含了2万个指令实例的数据集，以及4个通用代码相关任务。
与此同时，研究人员微调了一个代码大模型WaveCoder。
论文地址：https://arxiv.org/abs/2312.14187
实验结果表明，Wavecoder优于其他开源模型，在以前的代码生成任务中表现出色。
指令调优，释放「代码大模型」潜力
过去的一年，GPT-4、Gemini、Llama等大模型在一系列复杂NLP任务中取得了前所未有的性能。
这些LLM利用自监督预训练的过程，以及随后的微调，展示了强大的零/少样本的能力，能够有效遵循人类指示完成不同的任务。
然而，若想训练微调这样一个大模型，其成本非常巨大。
因此，一些相对较小的LLM，特别是代码大语言模型（Code LLM），因其在广泛的代码相关任务上的卓越的性能，而引起了许多研究者的关注。
鉴于LLM可以通过预训练获得丰富的专业知识，因此在代码语料库上进行高效的预训练，对代码大模型至关重要。
包括Codex、CodeGen、StarCoder和CodeLLaMa在内的多项研究已经成功证明，预训练过程可以显著提高大模型处理代码相关问题的能力。
此外，指令调优的多项研究（FLAN、ExT5）表明，指令调优后的模型在各种任务中的表现符合人类预期。
这些研究将数千个任务纳入训练管道，以提高预训练模型对下游任务的泛化能力。
比如，InstructGPT通过整合人类标注者编写的高质量指令数据，有效地调整了用户输入，推进指令调优的进一步探索。
斯坦福的Alpaca利用ChatGPT通过Self-Instruct的方法，自己生成指令数据，进而用于指令调优的过程。
WizardLM和WizardCoder则应用了evol-instruct的方法，进一步提高了预训练模型的有效性。
这些近来的研究都体现了，指令调优在提高大模型性能方面，展现出强大的潜力。
基于这些工作，研究人员的直觉是，指令调优可以激活大模型的潜力，然后将预训练模型微调到出色的智能水平。
对此，他们总结了指令调优的主要功能：
- 泛化
指令调优最初是为了增强大模型的跨任务泛化能力而提出的，当使用不同的NLP任务指令进行微调时，指令调优可提高模型在大量未见任务中的性能。
- 对齐
预训练模型从大量token和句子层面的自监督任务中学习，已经具备了理解文本输入的能力。指令调优为这些预训练模型提供了指令级任务，让它们能够从指令中提取原始文本语义之外的更多信息。这些额外的信息是用户的意图，能增强它们与人类用户的交互能力，从而有助于对齐。
为了通过指令调优提高代码大模型的性能，目前已有许多设计好的生成指令数据的方法，主要集中在两个方面。
例如，self-instructe、vol-instruct利用teacher LLM的零/少样本的能力来生成指令数据，这为教学数据的生成提供了一种神奇的方法。
然而，这些生成方法过于依赖于teacher LLM的性能，有时会产生大量的重复数据，便会降低微调的效率。
CodeOcean：四项任务代码相关指令数据
为了解决这些问题，如图2所示，研究人员提出了一种可以充分利用源代码，并明确控制生成数据质量的方法。
由于指令调优是为了使预训练模型与指令遵循训练集保持一致，研究人员提出了一个用于指令数据生成的LLM Generator-Disciminator（大模型生成器-判别器）框架。
通过使用生成器和判别器，最新方法可以使数据生成过程，更可定制和更可控。
该方法以原始代码作为输入，选择核心数据集，通过调整原始代码的分布，可以稳定地生成更真实的指令数据，控制数据的多样性。
针对上述挑战，研究人员将指令实例分类为4个通用的代码相关任务：代码汇总、代码生成、代码翻译、代码修复。
同时，使用数据生成策略为4个代码相关的任务生成一个由20000个指令实例的数据集，称为CodeOcean。
为了验证最新的方法，研究人员将StarCoder、CodeLLaMa、DeepseekCoder作为基础模型，根据最新的数据生成策略，微调出全新的WaveCoder模型。
与此同时，研究人员在 HumanEval、MBPP、HumanEvalPack对模型进行了评估，结果表明，WaveCoder在小规模指令调优的基准上拥有出色的性能。
代码数据生成
如上所述，研究人员选择了4个具有代表性的编码任务，并从开源数据集中收集原始代码。
以下具体介绍了训练数据生成过程。
在本节中，我们将介绍我们探索的方法细节。我们首先选择4个代表性的编码任务，并从开源数据集中收集原始代码。
对于每个任务，作者使用GPT-3.5-turbo生成指令数据进行微调。生成提示如表2所示。
如下，是LLM Generator-Disciminator整体架构，也是数据生成的完整过程。
Codesearchnet是一个包含来自 GitHub 上托管的开源库的200万对(注释、代码)的数据集。它包括6种编程语言的代码和文档。我们选择 CodeSearchNet 作为我们的基础数据集，并应用基于 coreset 的选择方法KCenterGreedy来最大化原始代码的多样性。
具体来说，生成器根据输入（a）生成指令数据。随后，判别器接受输出并生成分析结果，输出（b）包括四个键，研究人员将这些信息作为指令调优的输入和输出。
分析（c）包括每条规则的详细原因和总体答案，以检查样本是否满足所有要求。
实验评估结果
代码生成任务评估
表3显示了两个基准上不同大模型的pass@1得分。从结果来看，我们有以下观察结果:
WaveCoder大大优于使用少于20k指令调优数据（InsT Data）的指令模型训练。
经过微调过程，与基础模型和开源模型的选择相比，最新模型的性能显示出实质性的改善，但它仍然落后于专有模型的指导模型训练超过70k的训练数据。
研究人员还用HumanEvalPack上最先进的Code LLM对WaveCoder进行评分，如表4。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/053b4a3979bf5350a8a579df33f415ca/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d48314bf435e370e65f9aaa3a0c75a6/" rel="bookmark">
			第10课 实现多对多音视频会议功能
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本课对应文件下载链接（非源码）：https://download.csdn.net/download/XiBuQiuChong/88717642
在前两节课，我们将推流端与播放端合并为一对一音视频聊天功能并解决了关键的回声问题，在此基础上，我们可以进一步改进实现多对多的视频会议功能。
1.备份demo9并修改demo9为demo10。
2.打开工程文件，修改mfc为四分屏画面。
界面左下角为推送端界面，包括：摄像头预览区、推流地址文本框和推流按钮，其余三个为播放端界面，包括：拉流预览区、拉流地址文本框和拉流按钮。
3.添加相应功能
推流端代码fmle.cpp基本不用改动，fmlp.cpp及fmlp.h需要微调以适应复用功能。修改主对话框代码使播放端增加到三个并传递相关参数到fmlp内部以作识别用：
myFmlp1 = new fmlp(); myFmlp1-&gt;btnID = IDC_playBtn; myFmlp1-&gt;videoID = IDC_remotePIC; myFmlp1-&gt;start(playURL, 640, 480); myFmlp2 = new fmlp(); myFmlp2-&gt;btnID = IDC_playBtn2; myFmlp2-&gt;videoID = IDC_remotePIC2; myFmlp2-&gt;start(playURL, 640, 480); myFmlp3 = new fmlp(); myFmlp3-&gt;btnID = IDC_playBtn3; myFmlp3-&gt;videoID = IDC_remotePIC3; myFmlp3-&gt;start(playURL, 640, 480); 3.给播放按钮添加相应的控制程序：
void CflashMeetingDlg::OnBnClickedplaybtn() { myWnd-&gt;GetDlgItem(IDC_playURL)-&gt;GetWindowText(playURL); if (playURL.GetLength() == 0){ MessageBox(L"地址不能为空"); return; } if (!myFmlp1-&gt;isRunning){ myFmlp1-&gt;ifConn(playURL, 640, 480); } else{ myFmlp1-&gt;isRunning = false; myFmlp1-&gt;isAuPlaying = false; } } void CflashMeetingDlg::OnBnClickedplaybtn2() { myWnd-&gt;GetDlgItem(IDC_playURL2)-&gt;GetWindowText(playURL2); if (playURL2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d48314bf435e370e65f9aaa3a0c75a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc7756d5da1e0803d530ea228b41ca25/" rel="bookmark">
			全网最详细的网络安全（白帽黑客）入门教程，282g资源无偿分享
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		近年来，涌入网安这个赛道的人千千万，但最终几乎是全军覆没。新手最大的问题就是找不到学习方法，永远在打基础。
许多同学会在A平台上收藏几集视频课，再去B平台上白嫖几份面试题，最后收藏夹越来越满，自己却什么也没学成，久而久之也丧失了学习的信心。
其实对于初学者而言，系统的学习资源是很重要的。网络上的资源大多比较片面化，且内容很多有重合，这里给大家整理了全套的网络安全（白帽黑客）入门教程，这套教材专为零基础的同学量身定制，讲解非常细致，总共282g资源，有兴趣的同学可以参考，并结合自身情况来调整，事半功倍！
网络安全学习路线 这里将网络安全学习路线整合成了以下21点，从网络安全基础点到web蓝军实战，帮助大家高效学习，完成白帽黑客的进化！
主题1:安全意识与安全运营主题2:网络安全运营主题3:网络攻击前沿–ATT&amp;CK框架主题4:等保测评1.0详解主题5:等保测评2.0详解主题6:渗透测试基础主题7:渗透测试工具实操与实战主题8:TOP10漏洞详解和防御主题9:网络安全之资产管理主题10:网络安全之计算机网络知识主题11:弱口令详解与实战主题12:安全配置基线主题13:高风险漏洞利用主题14:渗透测试工具讲解与实战主题15:网络安全意识主题16:网络安全产品详解主题17:网络安全之运维与升级主题18.网络安全之系统加固主题19:路由交换及网络设备加固主题20:HW蓝军实战教学主题21:WEB中间件和数据库加固 零基础的同学可以参考上面的入门→进阶→高级→蓝队学习路线图
接下来我将给大家安排一个为期1个月的网络安全初级计划，当你学完后，你基本可以从事一份网络安全相关的工作，比如渗透测试、Web渗透、安全服务、安全分析等岗位；如果等保模块学的好，还可以从事等保工程师。薪资区间8k——15k！
初级 1、网络安全理论知识（2天）
①了解行业相关背景，前景，确定发展方向。
②学习网络安全相关法律法规。
③网络安全运营的概念。
④等保简介、等保规定、流程和规范。（非常重要）
2、渗透测试基础（1周）
①渗透测试的流程、分类、标准
②信息收集技术：主动/被动信息搜集、Nmap工具、Google Hacking
③漏洞扫描、漏洞利用、原理，利用方法、工具（MSF）、绕过IDS和反病毒侦察
④主机攻防演练：MS17-010、MS08-067、MS10-046、MS12-20等
3、操作系统基础（1周）
①Windows系统常见功能和命令
②Kali Linux系统常见功能和命令
③操作系统安全（系统入侵排查/系统加固基础）
4、计算机网络基础（1周）
①计算机网络基础、协议和架构
②网络通信原理、OSI模型、数据转发流程
③常见协议解析（HTTP、TCP/IP、ARP等）
④网络攻击技术与网络安全防御技术
⑤Web漏洞原理与防御：主动/被动攻击、DDOS攻击、CVE漏洞复现
5、数据库基础操作（2天）
①数据库基础
②SQL语言基础
③数据库安全加固
6、Web渗透（1周） ①HTML、CSS和JavaScript简介
②OWASP Top10
③Web漏洞扫描工具
④Web渗透工具：Nmap、BurpSuite、SQLMap、其他（菜刀、漏扫等）
中级、高级 7、脚本编程学习（4周）
在网络安全领域。是否具备编程能力是“脚本小子”和真正网络安全工程师的本质区别。
零基础入门的同学，我建议选择脚本语言Python/PHP/Go/Java中的一种，对常用库进行编程学习。
最后 朋友们如果有需要全套网络安全入门+进阶学习资源包，可以点击免费领取（如遇扫码问题，可以在评论区留言领取哦）~
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
1.网安必备全套工具包和源码 2.视频教程 网上虽然也有很多的学习资源，但基本上都残缺不全的，这是我自己录的网安视频教程，路线图上的每一个知识点，我都有配套的视频讲解。
3.技术文档和电子书 技术文档也是我自己整理的，包括我参加护网行动、CTF和挖SRC漏洞的经验和技术要点。
网安方面的电子书我也收藏了200多本，基本上热门的和经典的我都有，也可以共享。
4.NISP、CISP等各种证书备考大礼包 5.CTF项目实战 学习网安技术最忌讳纸上谈兵，而在项目实战中，既能学习又能获得报酬的CTF比赛无疑是最好的试金石！
6.网安大厂面试题 这几年整理的网安方面的面试题，如果你是要找网安方面的工作，它们绝对能帮你大忙。
朋友们如果有需要全套网络安全入门+进阶学习资源包，可以点击免费领取（如遇扫码问题，可以在评论区留言领取哦）~
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3338361ab4424ef07b975125c06ed966/" rel="bookmark">
			【MediaFoundation】OpenCV VideoCapture 读取音频源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenCV 读取音频代码实例 在windows7 以及OpenCV4 过后可以使用 CAP_MSMF 读取音频，但是OpenCV没有播放音频的API。代码示例如下。 本文解析OpenCVCAP_MSMF 进行文件、设备的 音频读取，学习MediaFoundation 的使用。
#include &lt;opencv2/core.hpp&gt; #include &lt;opencv2/videoio.hpp&gt; #include &lt;opencv2/highgui.hpp&gt; #include &lt;iostream&gt; using namespace cv; using namespace std; int main(int argc, const char** argv) { Mat videoFrame; Mat audioFrame; vector&lt;vector&lt;Mat&gt;&gt; audioData; VideoCapture cap; vector&lt;int&gt; params { CAP_PROP_AUDIO_STREAM, 0, CAP_PROP_VIDEO_STREAM, -1, CAP_PROP_AUDIO_DATA_DEPTH, CV_32F }; //cap.open(file, CAP_MSMF, params); // 打开第一个音频输入设备 cap.open(0, CAP_MSMF, params); if (!cap.isOpened()) { cerr &lt;&lt; "ERROR! Can't to open file: " + file &lt;&lt; endl; return -1; } const int audioBaseIndex = (int)cap.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3338361ab4424ef07b975125c06ed966/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d74843dc15a74df03b487bd7bbeaca0/" rel="bookmark">
			网络安全的基本概念（小白入门-附资料）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、什么是网络安全 （1）网络安全
网络安全指网络系统中的硬件、软件以及系统中的数据受到保护，不因偶然或恶意的原因而遭到破坏、更改、泄露，系统连续可靠正常地运行，网络服务不中断。
网络安全包括：网络设备安全、网络软件安全和网络信息安全。
凡是涉及到网络上信息保密性、完整性、可用性、可认证性、可控性和可审查性的相关理论和技术都是网络安全研究的范畴。那么这“6个特性”是什么意思呢？
保密性：确保信息不被泄露或呈现给非授权的人。完整性：信息在传输和存储的过程中不丢失、不被修改和破坏。可用性：确保合法用户不会无缘故地被拒绝访问信息和资源。可认证性：包括对等实体认证和数据源点认证两个方面。可控性：对信息的内容及传播具有可控制力。可审查性：出安全问题时提供依据和手段。 讲了这么多，我们到底为啥要研究网络安全呢？这就要从对网络安全的需求说起了。
（2）对网络安全的需求
计算机病毒层出不穷、黑客攻势逐年攀升、常用系统存在安全漏洞、各国加强信息战的研究…这一系列原因都需要我们加强网络安全的研究。
从另一个层面讲，网络安全与我们个人、企业甚至国家的利益息息相关，我们应该引起重视。但是要注意，我们不可能做到绝对的安全，只能尽量做到相对安全。
二、网络安全攻击 （1）网络攻击的分类
网路攻击分为两类：被动攻击和主动攻击。
被动攻击：试图获取和利用系统信息，但不会对系统资源造成破坏。被动攻击难检测，但采取安全防护措施可有效阻止。
主动攻击：试图破坏系统资源，影响系统工作。主动攻击易发现，但难以阻止，所以对付主动攻击应该及时发现，并采取响应措施使系统恢复正常。
（2）网络攻击常见形式
常见的网络攻击有口令窃取、欺骗攻击、缺陷和后门攻击、认证失效、协议缺陷、信息泄露、指数攻击（病毒和蠕虫）和拒绝服务攻击等。
三、安全服务、机制、策略&amp;安全模型 （1）X.800介绍
X.800 建议（recommendation X.800），是CCITT关于开放系统互连安全体系结构的建议，它为开放系统互连（OSI）的安全通信提供一种概念性和功能性的框架，以及在OSI环境下解决网路安全问题的一致性途径。
安全服务通过安全机制实现安全策略。
（2）安全服务
安全服务是一种由系统提供的对资源进行特殊保护的进程或通信服务。
X.800定义了5类安全服务：
（3）安全机制
X.800定义了以下安全机制：
（4）安全服务与安全机制的关系
注：Y表示该机制适合提供该安全服务，-表示不适合。
（5）在OSI层中安全服务的配置情况
注：Y表示提供该安全服务，-表示不提供。
（6）安全策略
安全策略指在某个安全域内，施加给所有与安全相关活动的一套规则。
安全域指某个组织机构的一系列处理进程和通信资源。
（7）安全模型
下面展示的是两种常见的安全模型：
最后 朋友们如果有需要全套网络安全入门+进阶学习资源包，可以点击免费领取（如遇扫码问题，可以在评论区留言领取哦）~
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
1.网安必备全套工具包和源码 2.视频教程 网上虽然也有很多的学习资源，但基本上都残缺不全的，这是我自己录的网安视频教程，路线图上的每一个知识点，我都有配套的视频讲解。
3.技术文档和电子书 技术文档也是我自己整理的，包括我参加护网行动、CTF和挖SRC漏洞的经验和技术要点。
网安方面的电子书我也收藏了200多本，基本上热门的和经典的我都有，也可以共享。
4.NISP、CISP等各种证书备考大礼包 5.CTF项目实战 学习网安技术最忌讳纸上谈兵，而在项目实战中，既能学习又能获得报酬的CTF比赛无疑是最好的试金石！
6.网安大厂面试题 这几年整理的网安方面的面试题，如果你是要找网安方面的工作，它们绝对能帮你大忙。
朋友们如果有需要全套网络安全入门+进阶学习资源包，可以点击免费领取（如遇扫码问题，可以在评论区留言领取哦）~
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7f61bc58949a00ba1080f142cd10024/" rel="bookmark">
			CreateDIBSection失败的问题记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		错误记录 [ERROR] (:0, ): QPixmap::fromWinHICON(), failed to GetIconInfo() (操作成功完成。)
[ERROR] (:0, ): QPixmap::fromWinHICON(), failed to GetIconInfo() (参数错误。)
[ERROR] (:0, ): QPixmap::fromWinHICON(), failed to GetIconInfo() (参数错误。)
[ERROR] (:0, ): qt_imageToWinHBITMAP, failed to create dibsection (参数错误。)
[ERROR] (:0, ): qt_imageToWinHBITMAP, failed to create dibsection (参数错误。)
[ERROR] (:0, ): qt_imageToWinHBITMAP, failed to create dibsection (参数错误。)
[ERROR] (:0, ): qt_imageToWinHBITMAP, failed to create dibsection (参数错误。)
[FATAL] (:0, ): createDIB: CreateDIBSection failed (300x128, format: 6)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d7f61bc58949a00ba1080f142cd10024/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0846553bebf82fbdda8b2d6b549121e/" rel="bookmark">
			什么是黑客、骇客、白客、红客？他们的工作是什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		黑客 起源
“黑客”一词是英文Hacker的音译。这个词早在莎士比亚时代就已存在了，但是人们第一次真正理解它时，却是在计算机问世之后。根据《牛津英语词典》解释，“hack”一词最早的意思是劈砍，而这个词意很容易使人联想到计算机遭到别人的非法入侵。因此《牛津英语词典》解释“Hacker”一词涉及到计算机的义项是：“利用自己在计算机方面的技术，设法在未经授权的情况下访问计算机文件或网络的人。”
最早的计算机于1946年在宾夕法尼亚大学诞生，而最早的黑客出现于麻省理工学院。贝尔实验室也有。最初的黑客一般都是一些高级的技术人员，他们热衷于挑战、崇尚自由并主张信息的共享。
1994年以来，因特网在中国乃至世界的迅猛发展，为人们提供了方便、自由和无限的财富。政治、军事、经济、科技、教育、文化等各个方面都越来越网络化，并且逐渐成为人们生活、娱乐的一部分。可以说，信息时代已经到来，信息已成为物质和能量以外维持人类社会的第三资源，它是未来生活中的重要介质。而随着计算机的普及和因特网技术的迅速发展，黑客也随之出现了。
术语
黑客基本涵义是指一个拥有熟练电脑技术的人，但大部分的媒体习惯将“黑客”指作电脑侵入者。白帽黑客有能力破坏电脑安全但不具恶意目的的黑客。白帽子一般有清楚的定义道德规范并常常试图同企业合作去改善被发现的安全弱点。灰帽黑客对于伦理和法律暧昧不清的黑客。黑帽黑客怪客:黑帽子黑客— 经常使用于区分黑帽子黑客和一般（正面的）有理性的黑客。这个词自1983年开始流行，大概是由于采用了相似发音和对safe cracker的解释，并且理论化为一个犯罪和黑客的混成语。电脑安全黑客—使用密码破解（password cracking）或穷举法（brute force attack）。软件破解者脚本小孩（Script kiddie）激进黑客（Hacktivist），或译“黑客活动分子”、“侵权黑客”，比如中国的蓝客、红客等。
守则
1、不恶意破坏任何的系统，这样只会给你带来麻烦。恶意破坏他人的软件将导致法律责任，如果你只是使用电脑，那仅为非法使用！注意：千万不要破坏别人的软件或资料！
2、不修改任何的系统档，如果你是为了要进入系统而修改它，请在达到目的后将它改回原状。
3、不要轻易的将你要hack的站台告诉你不信任的朋友。
4、不要在bbs上谈论你hack的任何事情。
5、在post文章的时候不要使用真名。
6、正在入侵的时候，不要随意离开你的电脑。
7、不要在电话中谈论你作为黑客的任何事情。
8、将你的笔记放在安全的地方。
9、想要成为黑客就要学好编程和数学，以及一些TCPIP协议、系统原理、编译原理等计算机知识！
10、已侵入电脑中的帐号不得清除或修改。
11、不得修改系统档案，如果为了隐藏自己的侵入而做的修改则不在此限，但仍须维持原来系统的安全性，不得因得到系统的控制权而将门户大开！
12、不将你已破解的帐号分享于你的朋友。
13、不要侵入或破坏政府机关的主机。
14、不会编程的黑客不是好黑客。
15、黑客世界的高手们不同于“盗取”。
16、黑客并不是一味的攻击用户，而是通过攻击来研究漏洞，从而大大提高系统的安全性。
骇客 骇客并不固定是些什么人，我们每个人都有可能成为骇客，只要你知道一些相关网络与计算机知识就可以。知识积累到一定程度，就可以成为骇客，骇客并不一定就是坏人，大多数的高手都是遵守网络道德和规范，只是一少部分人破坏他人电脑，达到自己的目的。
行为
骇客的行为不能以我们正常的眼光去评价，至于像那些抱着笔记本钻进股票交易所去玩地道战的人实在与骇客半点边都沾不上，而那些侵入别人的电脑盗窃信息的也只是骇客中极少的一部分。千万别小看了骇客，比如电影《独立日》，其中，大炮、导弹、核武器纷纷失灵，最后还是靠骇客上载的计算机病毒要了全体外星人的小命。
补充
现实中的骇客正是把网络搞的乌烟瘴气的罪魁祸首。所谓骇客就是利用现有的一些程序进入别人的计算机系统后发现安全漏洞，并且利用这些漏洞破坏你的网站，让你出洋相；还有那些专门破译软件密码的从而制作盗版软件的人也是骇客的一种，可以说中国盗版如此严重也是骇客的“功劳”。骇客并没有想象中可怕，很多人一提到他们就联想到网络犯罪，这完全是没必要的。骇客们也只不过是为了炫耀自己的技术，大多数人并没有恶意。他们未必具有很高的技术，但有老顽童周伯通的心理，老是喜欢跟你开玩笑，通常用一些简单的攻击手段去搞一搞BBS、聊天室之类的。尽管如此，其中还是不乏一些用心险恶之人，利用自己的技术进行网络犯罪。
黑客与骇客的区别
白客 白客就是指从事正当行业的黑客，他们相当于黑帽与白帽，骇客与白客一般，也就是对网络有很深的了解，并且不骚扰别人。别称为“白客”。 白客还呈散兵游勇之势，但有人预计2030年将会出现一批白客，将是一个真正的群体。他们把白客称为三欣一族……如果你正为本地骇客的恶行感到忧心忡忡，对网络暴民感到厌烦，那告诉你一个好消息，新加坡其实有许多网络守护神——白客，为你紧守家门，执行虚拟世界法纪。另外，中国方面，也有一些网友开始自称白客而维护网络秩序。
红客 红客(**Honker(A person or thing that honks))**是指维护国家利益，不利用网络技术入侵自己国家电脑，而是“维护正义，为自己国家争光的黑客”。
“红客”，红客是一种精神，它是一种热爱祖国、坚持正义、开拓进取的精神。所以只要具备这种精神并热爱着计算机技术的都可称为红客。红客通常会利用自己掌握的技术去维护国内网络的安全，并对外来的进攻进行还击。
守则
1、必须是“爱国”的。
2、技术会向所有"爱国"的红客朋友们共享。
3、不断地学习，并不断地研究新的攻击技术与防护方法。
4、必须熟悉掌握C语言，并掌握任意一门面向对象的语言。
5、攻防技术不是用来炫耀的，这不是红客的作法。
6、不但要懂得系统的常用漏洞的攻防之道，而且还要懂得如何去挖掘系统的漏洞。
7、必须懂得如何使用百度（Baidu）等非常好的学习工具或搜索引擎。
8、必须懂得如何去打破常规的思维方式，“没有什么不可能，只要我们想得到，我们就能够做得到！没有我们进不去“房间”，只要“房间”内能够进得去空气，我们可以变成“空气”进入房间。
9、必须懂得如何去做人！——学技术先学做人！
最后 朋友们如果有需要全套网络安全入门+进阶学习资源包，可以点击免费领取（如遇扫码问题，可以在评论区留言领取哦）~
CSDN大礼包：《黑客&amp;网络安全入门&amp;进阶学习资源包》免费分享
1.网安必备全套工具包和源码 2.视频教程 网上虽然也有很多的学习资源，但基本上都残缺不全的，这是我自己录的网安视频教程，路线图上的每一个知识点，我都有配套的视频讲解。
3.技术文档和电子书 技术文档也是我自己整理的，包括我参加护网行动、CTF和挖SRC漏洞的经验和技术要点。
网安方面的电子书我也收藏了200多本，基本上热门的和经典的我都有，也可以共享。
4.NISP、CISP等各种证书备考大礼包 5.CTF项目实战 学习网安技术最忌讳纸上谈兵，而在项目实战中，既能学习又能获得报酬的CTF比赛无疑是最好的试金石！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b0846553bebf82fbdda8b2d6b549121e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87762debd3db6645066600358d8d5c54/" rel="bookmark">
			为网络安全红队方向提供的资源，工具大合集（渗透测试）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这是一份必备的资源大合集，收录了最优秀的网络安全红队方向（渗透测试）的资源和工具。
（文末领取读者福利）
无论您是初学者还是专业人士，都能从中获得所需的技能和知识。
在这个信息化时代，网络安全红队（渗透测试）的作用越来越重要，而这个合集中的工具和资源将帮助您更好地进行渗透测试，找出您所负责系统和数据的安全漏洞，为您的组织提供更加全面的安全保障。
不要错过这个精选工具、资源大合集，它将成为您进行网络安全红队（渗透测试）的不可或缺的伙伴！
渗透测试是对计算机系统及其物理基础设施发起授权的模拟攻击以暴露潜在的安全弱点和漏洞的做法。如果您发现漏洞，请按照本指南负责任地进行报告。
安卓实用程序 cSploit - Android 上的高级 IT 安全专业工具包，具有集成的 Metasploit 守护进程和 MITM 功能。Fing - 网络扫描和主机枚举应用程序，可执行 NetBIOS、UPnP、Bonjour、SNMP 和各种其他高级设备指纹识别技术。 匿名工具 I2P - 隐形互联网项目。Metadata Anonymization Toolkit (MAT) - 元数据删除工具，支持广泛的常用文件格式，用 Python3 编写。What Every Browser Knows About You - 综合检测页面，用于测试您自己的 Web 浏览器配置是否存在隐私和身份泄露。 Tor 工具 另见awesome-tor。
Nipe - 将所有流量从机器重定向到 Tor 网络的脚本。OnionScan - 通过查找 Tor 隐藏服务运营商引入的操作安全问题来调查暗网的工具。Tails - 旨在保护您的隐私和匿名性的实时操作系统。Tor - 免费软件和洋葱路由覆盖网络，可帮助您抵御流量分析。dos-over-tor - 通过 Tor 压力测试工具拒绝服务的概念证明。kalitorify - 通过 Tor 的 Kali Linux OS 透明代理. 防病毒规避工具 AntiVirus Evasion Tool (AVET) - 包含针对 Windows 机器的可执行文件的后处理漏洞，以避免被防病毒软件识别。CarbonCopy - 创建任何在线网站的欺骗性证书并签署可执行文件以逃避 AV 的工具。Hyperion - 32 位可移植可执行文件（“PE .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87762debd3db6645066600358d8d5c54/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/352aaacf9d4b5249854479f140a90f30/" rel="bookmark">
			WikiChat：维基百科引领未来幻觉率极低的大语言模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 WikiChat是基于英文维基百科信息的聊天模型。其工作原理是，在回答问题之前，先在维基百科上查找相关且准确的信息，确保提供的答案既有用又可靠。在混合人类和语言模型的评估中，WikiChat实现了97.3%的事实准确性，这一结果普遍高于其他模型。该模型几乎不会产生虚构的信息，同时具有高度对话性和低延迟的特点。
GitHub：GitHub - stanford-oval/WikiChat: WikiChat stops the hallucination of large language models by retrieving data from Wikipedia.
论文：https://arxiv.org/abs/2305.14292
在线体验：https://wikichat.genie.stanford.edu
更多消息：AI人工智能行业动态，aigc应用领域资讯
由于不知名原因，给出的在线测试地址都没响应，等修复吧
主要特点：
高度准确：WikiChat以维基百科为依托，直接获取权威、更新频繁的信息源，因此在提供事实和数据时表现异常准确。减少“幻觉”：相较于语言模型在处理最新事件或不太流行话题时可能出现错误信息，WikiChat通过整合维基百科数据有效减少了这类虚构信息的发生。对话性强：虽然强调准确性，WikiChat仍能保持流畅、自然的对话风格。适应性强：WikiChat具备良好的适应性，能够应对各种查询和对话场景。高效性能：通过优化措施，WikiChat在回答问题时更为迅速，同时降低了运行成本。 工作原理：WikiChat采用模型蒸馏技术，将基于GPT-4的模型压缩为更小、更高效的LLaMA模型（70亿参数），以提高响应速度和降低成本。其工作流程包括检索、摘要、生成和事实核查等多个阶段，经过精心设计以确保整体对话的准确性和流畅性。
信息检索：在与用户进行对话时，WikiChat首先判断是否需要获取外部信息。例如，当用户提出具体问题或需要更详细的回答时，WikiChat会创建一个搜索查询，以捕捉用户的兴趣，并从知识库（如维基百科）中检索相关信息。摘要与过滤：检索到的信息可能涵盖相关和非相关内容。WikiChat会提取相关部分，将其摘要为要点，并同时过滤掉无关内容，确保用户得到精炼的回答。LLM回应生成：接下来，利用大型语言模型（例如GPT-4）生成对话历史的回应。这一步骤产生的内容通常既有趣又相关，但其可靠性有限，因为可能包含未经验证或错误的信息。事实核查：WikiChat将LLM的回应分解为多个声明，并对每个声明进行事实核查。使用检索系统从知识库中获得每个声明的证据，并基于这些证据验证每个声明。只有得到证据支持的声明才会被保留。回应形成：最后，WikiChat使用经过筛选和验证的信息来形成引人入胜的回应。这个过程包括首先生成草稿回应，然后根据相关性、自然性、非重复性和时间正确性对其进行优化和改进。这次重写涉及更换词汇和调整语序，以提高表达的准确性和流畅性。 在混合人类和大语言模型（LLM）评估方法下，WikiChat的表现如下：
高水平的事实准确性：在模拟对话场景中，WikiChat的最佳系统展现出97.3%的事实准确性，这表明它在提供信息和回答问题时，绝大部分的回应都是基于真实数据和事实的。与GPT-4的比较：在涉及头部知识、尾部知识和最新知识的测试中，WikiChat在事实准确性上相对于GPT-4分别提高了3.9%、38.6%和51.0%。这表明WikiChat在处理各类信息时均表现出显著的优势，尤其是在处理不常讨论的主题和最新事件方面。与基于检索的聊天机器人的比较：与之前最先进的基于检索的聊天机器人相比，WikiChat不仅在事实准确性上表现更出色，而且更能提供丰富、有趣的信息，吸引用户参与对话。这表明WikiChat能够提供更具吸引力和深度的对话体验。 WikiChat聊天模型具有显著的潜力，未来可能在多个领域发挥重要作用。以下是一些可能的领域：
教育与培训：由于WikiChat能够提供权威、准确的信息，它可以用作教育工具，为学生或学习者提供实时、互动的学习体验。例如，它可以作为在线课程的辅助工具，提供与课程内容相关的详细信息，或者作为教师和学生的互动平台，促进讨论和问题解答。客户服务：在客户服务领域，WikiChat可以作为自动问答系统，快速、准确地回答用户的问题。通过整合企业的知识库和常见问题解答，WikiChat可以帮助企业提高客户满意度，同时降低人工客服的成本。内容创作与媒体：在内容创作和媒体领域，WikiChat可以作为生成高质量文本的辅助工具。例如，它可以为新闻报道提供背景信息和数据支持，为文章提供有趣的对话片段，或者为社交媒体帖子生成引人入胜的标题和摘要。健康与医疗：在健康和医疗领域，WikiChat可以作为患者教育和健康咨询的工具。它能够提供关于疾病、治疗方法、药物等方面的准确信息，帮助患者更好地理解自己的状况，同时为医生提供可靠的参考资料。游戏与娱乐：在游戏和娱乐领域，WikiChat可以用于创建更具吸引力和互动性的虚拟角色。通过与玩家的对话，WikiChat可以帮助虚拟角色展现出更真实、更有趣的性格特点，增加游戏的可玩性和吸引力。智能助手与个人助理：在智能助手和个人助理领域，WikiChat可以作为个人用户的查询工具，帮助他们快速获取信息、安排日程、进行购物等。通过与用户的日常互动，WikiChat可以帮助用户节省时间、提高工作效率。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2c3eb0e92b113355218be6f4704d975/" rel="bookmark">
			ECMAScript6详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		ECMAScript 6（也称为ES6或ECMAScript 2015）是JavaScript语言的一次重大更新，引入了许多新的语法和功能，以提高开发人员的效率并使代码更具可读性。以下是一些ECMAScript 6的主要特性：
let和const关键字：
let 和 const 替代了旧的 var 关键字，引入了块级作用域。let 用于声明变量，而 const 用于声明常量。 let variable = 1; const constantValue = 42; 箭头函数：
箭头函数提供了更简洁的语法，并且没有自己的 this，它会从定义时的父作用域继承 this。 // 传统函数 function add(x, y) { return x + y; } // 箭头函数 const add = (x, y) =&gt; x + y; 模板字符串：
模板字符串允许你在字符串中嵌入表达式，并支持多行字符串。 const name = 'World'; const greeting = `Hello, ${name}!`; 解构赋值：
解构赋值使得从数组或对象中提取值并赋给变量更为方便。 // 数组解构 const [a, b] = [1, 2]; // 对象解构 const { x, y } = { x: 1, y: 2 }; 类：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2c3eb0e92b113355218be6f4704d975/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23796d077c446800dfa3a27693b49e5c/" rel="bookmark">
			ArcGIS中style文件的导入及lyr的文件的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		地图是地理信息的重要载体，科学的配色方案可以有效地传递地理信息，而美观协调的配色方案也是我们进行地图符号化设计的重要内容。在日常工作中，我们常常苦恼于自带颜色不能满足需要或是希望使用现成的颜色模板，自定义配色方案导入及导出成为一个有效技能，今天我们来一起学习一下ArcGIS中style文件的导入及lyr的文件的使用方法。
软件版本：ArcMap10.4.1
1.配色方案的导入
①首先运行ArcMap，点击Customize-Style Manager，进入Style Manager页面。
②之后，点击该页面右侧Styles按钮，进入Style References页面，点击Add Style to List，从本地添加事先保存的后缀为style的文件，点击打开​。
③回到Style References页面，勾选自定义添加的配色方案，最下方点击确定​，再进入到​符号化页面，发现配色方案已添加进来。
2.图层配色方案的导出和导入​
①我们在完成对某一图层的符号化后，右击该图层，选择Save As Layer File，将​其另存为图层文件，完成配色方案的导出。
②打开另一待处理数据，右击打开图层属性面板，在符号化中选择Import，选择Just the symbols，选择之前导出的后缀为.lyr​的图层文件，完成配色方案的导入。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/494658f911d356d9f1af527ad10d82ea/" rel="bookmark">
			DVWA-Hight-DOM型XSS漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 首先打开hight模块的DVWA,并来到DOM型XSS漏洞处
首先试探
这里普通的js代码被过滤
再利用img试探
同样被过滤
这里后端代码不太可能将所有可能利用黑名单的形式全部写入过滤代码中，所以这里后端的过滤代码大概率是白名单，也就是除了这个下拉列表中的名单以外的数据提交过去也大概是不管用的
这里可以用到一个思路，即不让数据到达后端进行判断，直接从前端的角度进行一个弹窗
利用字符#绕过服务端过滤
url中有一个字符为#，该字符后的数据不会发送到服务器端，#后面的内容是对浏览器的操作，不会发送到http请求当中去，从而绕过服务端过滤。
正常语句
xss_d/?default=English
构建语句
xss_d/?default=English#&lt;script&gt;alert(/xss/)&lt;/script&gt;
这时回车提交
啥也不会发生，但是这时刷新页面
成功触发弹窗，DOM型xss漏洞利用完成 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb74375848626373e60dc874593662eb/" rel="bookmark">
			【Microsoft Edge】如何彻底卸载 Edge
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		要彻底卸载Microsoft Edge浏览器，你可以按照以下步骤进行操作。请注意，这可能会删除与Edge相关的所有数据，包括书签、扩展和浏览器历史记录。确保在执行这些步骤之前备份任何重要数据。
使用“控制面板”卸载：
打开“控制面板”：
在Windows搜索框中键入“控制面板”并打开它。选择“程序” -&gt; “卸载程序”。 在程序列表中找到Microsoft Edge。
右键单击Microsoft Edge，并选择“卸载/更改”。
根据系统提示完成卸载过程。
使用PowerShell卸载：
打开PowerShell：
在Windows搜索框中右键单击“Windows PowerShell”并选择以管理员身份运行。 运行以下命令卸载Microsoft Edge：
Get-AppxPackage -allusers Microsoft.MicrosoftEdge | Remove-AppxPackage -AllUsers 删除Edge数据文件夹：
打开资源管理器，转到以下路径：
C:\Users\YourUsername\AppData\Local\Microsoft\Edge\User Data 请将 “YourUsername” 替换为你的用户名。
删除 “User Data” 文件夹。
删除注册表项：
警告：在编辑注册表前，请务必备份注册表或系统。错误的注册表编辑可能导致系统问题。
打开注册表编辑器：
在Windows搜索框中键入“regedit”并打开注册表编辑器。 导航到以下路径：
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Edge 右键单击 “Edge” 文件夹并选择删除。
同样，导航到以下路径删除任何剩余的Edge注册表项：
HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Edge 最后，导航到以下路径删除任何Edge用户数据：
HKEY_CURRENT_USER\Software\Microsoft\Edge 重新启动计算机：
重启计算机确保更改生效。 请注意，卸载Microsoft Edge可能会影响系统中某些Web功能，例如Cortana。如果之后需要再次安装Edge，你可以从Microsoft的官方网站下载并安装最新版本。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2fb75c150a93b2220d9450dc373aa42f/" rel="bookmark">
			在做题中学习（45）：最大连续1的个数III
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1004. 最大连续1的个数 III - 力扣（LeetCode）
解法：同向双指针————“滑动窗口”
思路：因为要返回数组中连续的数，就相当于一个子数组，而要的是一个可以翻转 &lt;= k个0的子数组使它可以变为全1的子数组，那就可以把问题转为：找出一个最大的子数组，它里面有&lt;=k个0.
因此一定要定义一个计数器记录0的个数。
通过上图，可以看到当right进窗口到此位置时，子数组中0的个数 &gt; k ，所以需要通过left出窗口来维持0的数量
1.left = 0,right = 0
2.进窗口————1就略过，0就计数器++
3.判断————0的个数&gt;k
4.出窗口+再次判断————0就略过，1就left++
5.更新数据————选出更大的len
class Solution { public: int longestOnes(vector&lt;int&gt;&amp; nums, int k) { int zcount = 0,len = 0; int z = 0; for(int left = 0,right = 0;right&lt;nums.size();) { //1.进窗口 if(nums[right]==0) { zcount++; } //2.判断 while(zcount&gt;k) { //3.出窗口 if(nums[left]==1) { left++; } else { zcount--; left++; } } //4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2fb75c150a93b2220d9450dc373aa42f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/719df43a718a0b1d9c6d2272c9b9195e/" rel="bookmark">
			Linux 系统日志及其归档
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要记录Linux 系统需要关注的日志文件，以及日志归档服务 rsyslogd
系统日志服务 rsyslogd 日志服务 rsyslogd reliable and extended syslogd 可靠 可扩展的系统日志服务
Rsyslogd是一个系统实用程序，提供对消息日志记录的支持。同时支持internet和unix域套接字使该实用程序能够支持本地和远程日志记录。
配置文件 more /etc/rsyslog.conf|grep -v '#'|grep -v ^$ $umask 0022 $WorkDirectory /var/lib/rsyslog $ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat $IncludeConfig /etc/rsyslog.d/*.conf $OmitLocalLogging on $IMJournalStateFile imjournal.state *.info;mail.none;authpriv.none;cron.none;local0.none /var/log/messages authpriv.* /var/log/secure mail.* -/var/log/maillog cron.* /var/log/cron *.emerg :omusrmsg:* uucp,news.crit /var/log/spooler local7.* /var/log/boot.log local0.* /var/log/keepalived.log 从上述的配置文件里面可以看到我们需要关注的系统日志文件，一般都不动这个配置
感兴趣可以上官网看看：RSyslog Documentation - rsyslog
logrotate 日志归档 logrotate rotates, compresses, and mails system logs 归档 压缩 邮件发送系统日志
配置文件 /etc/logrotate.conf /etc/logrotate.d/ 来，上配置文件，如下是默认的配置：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/719df43a718a0b1d9c6d2272c9b9195e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ebe5b40df359cfe2e38e4a09417bd975/" rel="bookmark">
			虚幻UE 材质-材质编辑器节点 1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 之前的几篇文章基本上都是对一些材质名词进行讲解
而这篇文章会对材质编辑器中的常用节点和常用用法进行讲解
文章目录 前言一、Add添加二、BumpOffset凹凸偏移三、Divide划分除法四、Power亮度/对比度五、MaterialFunctionCall材质函数六、If通道提取七、Lerp线性插值八、Multiply乘法倍增九、OneMinus反向计算十、Subtract减法计算十一、Panner UV平移总结 前言 材质的大致用法我们在之前的文章也讲解的差不多，从这篇文章开始我们会对一些材质编辑器中的节点进行讲解，
并把常用的方法展示出来，供大家参考学习。
一、Add添加 如果是两个颜色相加：
也就会产生X+X / Y+Y / Z+Z得到的颜色的效果
如果是两个贴图叠加：
两张贴图效果叠加，黑0处被其他颜色替换
二、BumpOffset凹凸偏移 可以让凹凸感更加明显
由于没有高度贴图，所以不好测试，大家知道使用方式就行
三、Divide划分除法 反向效果：
白变成黑，其他也是一样进行了反向
白色部分RGB为1，为分母时，颜色自动映射为分子颜色
另一种示例：
先通过除法进行反向效果，再用除法对白色进行覆盖
颜色进行除法：
除法让颜色数值减半
四、Power亮度/对比度 亮度对比：
可以对材质的亮度/对比度进行简单的设置
五、MaterialFunctionCall材质函数 材质函数的创建和编写：
输入：一个标量，用于控制粗糙度
输出：两个变量，一个粗糙度、一个UV
材质函数的使用：
这里只是列举了一个简单的材质函数的使用和方式，材质函数用处很大
六、If通道提取 RGB通道，根据单独的某个RGB通道得到0,1的黑白或者灰的一个标量
通过贴图中每个像素的RGB单通道和下方的值相比，如果大于则输出一种类型，小于则输出另一种类型
可以进行色块划分
七、Lerp线性插值 Lerp值为0：
Lerp值为0.5：
Lerp值为1：
可以看出Lerp的插值效果，逐渐过渡的效果展现的很明显
颜色的Lerp过渡：
黑和白的0.5过渡就是灰色
八、Multiply乘法倍增 贴图中的乘法：
白色1乘法为叠加，黑色0乘法为0
颜色中的乘法：
可以用在自发光等参数过小显示明显的地方，用于参数变大
九、OneMinus反向计算 颜色反向，0变成1，1变成0
十、Subtract减法计算 黑色0被减也就是叠加颜色，白色被减则为接近黑色0
十一、Panner UV平移 UV图片进行移动
总结 其实各节点参数最主要的就是要把握这几点：
白色：RGB全1 黑色：RGB全0 其他：RGB 0-1 最后根据数值运算得到的值是多少，0则黑色，1则白色，理解就好 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2d9ed514cac9541e12870f3abc1e4ab/" rel="bookmark">
			【机器学习】对抗生成网络
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、随机数据生成
随机数据生成算法
随机数据生成的显示建模和隐式建模
二、生成对抗网络结构
生成对抗网络（GAN）中，生成模型（Generator）和判别模型（Discriminator）的任务和训练目标分别是：
生成模型的任务是从随机噪声中生成尽可能真实的数据，例如图像、文本、音频等。生成模型的训练目标是最小化生成数据被判别模型识别为假的概率，也就是最大化生成数据的真实性。
判别模型的任务是区分输入的数据是真实的还是生成模型生成的。判别模型的训练目标是最大化真实数据被识别为真的概率和生成数据被识别为假的概率，也就是最小化判别模型的误判率。
生成模型和判别模型的训练是一个对抗的过程，它们互相竞争，不断提高自己的能力，最终达到一个平衡点，使得生成模型生成的数据无法被判别模型区分。这样，生成模型就可以生成高质量的数据，判别模型就可以提高数据的鉴别能力。
生成对抗网络的原理
三、模型的训练
GAN的训练过程是怎样的？
# 初始化生成器G和判别器D G = Generator() D = Discriminator() # 设置优化器和超参数 optimizer_G = Optimizer(G.parameters(), ...) optimizer_D = Optimizer(D.parameters(), ...) epochs = ... batch_size = ... latent_dim = ... # 循环训练epochs次 for epoch in range(epochs): # 循环训练每个批次的数据 for x in data_loader(batch_size): # 训练判别器D optimizer_D.zero_grad() z = random_noise(latent_dim) fake_x = G(z) real_pred = D(x) fake_pred = D(fake_x.detach()) loss_D = binary_cross_entropy(real_pred, 1) + binary_cross_entropy(fake_pred, 0) loss_D.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2d9ed514cac9541e12870f3abc1e4ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf960ace451e20a6eef796917d630e97/" rel="bookmark">
			用python提取excel表格第一列汉字首字母到第二列
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天有个任务就是需要提取excel表格里面的汉字首字母，然后我就手动写了三个小时，结果还剩3000多行，这样下去不行啊
想了下用python能不能做到呢？
import openpyxl from pypinyin import lazy_pinyin, Style # 加载工作簿 workbook = openpyxl.load_workbook('hanzi.xlsx') # 选择工作表 sheet = workbook.active # 提取每一列汉字的拼音首字母，并将结果统一放到第二列 for column in range(1, sheet.max_column + 1): for row in range(2, sheet.max_row + 1): # 从第二行开始，因为第一行是列标题 cell = sheet.cell(row=row, column=column) if cell.value: # 将汉字转换为拼音 pinyin = lazy_pinyin(cell.value) # 提取每个拼音的第一个字母并转换为小写 first_letters = [p[0].lower() for p in pinyin] # 将首字母合并为一个字符串 merged_letters = ''.join(first_letters) # 将结果写入第二列的单元格 sheet.cell(row=row, column=2).value = merged_letters # 保存修改后的表格 workbook.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf960ace451e20a6eef796917d630e97/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/30642cf028ee6cbad5d1156b9c91e912/" rel="bookmark">
			Unity检测地面坡度丨人物上坡检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Unity检测地面坡度 前言使用 代码 前言 此功能为，人物在爬坡等功能时可以检测地面坡度从而完成向某个方向给力或者完成其他操作
使用 其中我们创建了脚本GradeCalculation，把脚本挂载到人物上即可，或者有其他的使用方式，可自行拆分使用，注：其中需要修改地形的layer层级或者使用默认的就不用修改了。
代码 using System.Collections; using System.Collections.Generic; using System.Linq; using UnityEngine; public class GradeCalculation : MonoBehaviour { private Vector3 mLastPosition; // 上一帧的位置 private Vector3 mForward; // 当前方向 public float NeedleDistance = 1.0f; // 针尖距离 public float NeedleHeightOffset = 1.0f; // 针尖高度偏移 // Start is called before the first frame update void Start() { // 在这里进行初始化 } // Update is called once per frame void Update() { // 在每一帧更新时输出坡度的读数 Debug.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/30642cf028ee6cbad5d1156b9c91e912/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b6529880c0bc0eb2919dcb367bd0162/" rel="bookmark">
			json解析本地数据，使用JSONObject和JsonUtility两种方法。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		json解析丨网址、数据、其他信息 文章目录 json解析丨网址、数据、其他信息介绍一、文中使用了两种方法作为配置二、第一种准备2.代码块 二、第二种总结 介绍 本文可直接解析本地json信息的功能示例，使用JSONObject和JsonUtility两种方法。
一、文中使用了两种方法作为配置 一种使用UnityWebRequest的方法（搭配JSON插件为JSONObject）
一种使用File文件读取方法（搭配Unity自带的JsonUtility）
二、第一种 UnityWebRequest方法
准备 JSONObject需要插件支持，不过可以在Assets Store中找到，直接搜索JSONObject就可以。
因为我开的Unity有点多，所以我选择添加到我的资源然后找到相应的Unity里在Package Manager里选择添加。只打开一个Unity可以直接选择加入到Unity里
需要在Unity里创建文件夹StreamingAssets然后把Json文件放到文件夹下（文件夹目录可以修改代码完成其他需求的文件夹目录使用）
Json格式也很简单{ "appid": "appid11111111" }
文本中只使用了一个数据作为示例。
然后把代码挂载后运行就可以直接出现了
2.代码块 using System.Collections; using System.Collections.Generic; using System.IO; using Defective.JSON; using UnityEngine; using UnityEngine.Networking; public class JsonParsingExample : MonoBehaviour { public string Config = "config.json"; public string appid; // Start is called before the first frame update void Start() { StartCoroutine(LoadConfig()); } private IEnumerator LoadConfig() { var unityWebRequest = UnityWebRequest.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8b6529880c0bc0eb2919dcb367bd0162/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c7a224ddfe7efc7c13ad085f742cbe6/" rel="bookmark">
			单例日常使用模板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 单例使用方法技术细节小结 单例 单例是日常使用中不可避免的工具类，基本大多项目都需要使用到。本文写一个直接拿来使用的单例就可以。
使用方法 技术细节 代码细节
using UnityEngine; public class Singleton&lt;T&gt; : MonoBehaviour where T : Singleton&lt;T&gt; { private static T instance; public static T Instance { get { return instance; } } public static bool IsInitialized { get { return instance != null; } } protected virtual void Awake () { if (instance != null) { Debug.LogErrorFormat ("Trying to instantiate a second instance of singleton class {0}", GetType ().
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5c7a224ddfe7efc7c13ad085f742cbe6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/169c347e445918a8eee423f525b9f0dd/" rel="bookmark">
			Linux--好玩的进度条
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 先来看看我们想要达到的进度条效果，具体代码会在文章最后面放出。 一、创建文件及Makefile 我们需要实现声明的定义的分离，因此创建如下三个文件。
process.h prcess.c main.c。
touch process.h process.c main.c 同时还需要创建Makefile来帮助我们构建代码。
touch Makefile vim打开Makefile进行编辑。
vim Makefile 第一行 代表mybin依赖与main.c和process.c
第二行 gcc命令，$^指第一行 “:” 右边的内容，$@指 “:” 左边的内容，即等于gcc main.c process.c -o mybin。这会生成可执行文件mybin。
第三行 .PHONY声明伪目标：clean，让clean代码一直可以执行。
第四行 代表clean没有依赖任何文件
第五行 删除命令，删除 mybin
1 mybin:main.c process.c 2 gcc $^ -o $@ 3 .PHONY:clean 4 clean: 5 rm -f mybin 二、第一版代码 vim process.h 打开文件进行编辑。（unistd.h是后面需要用到的休眠函数头文件）
#pragma once #include &lt;stdio.h&gt; #include &lt;string.h&gt; #include &lt;unistd.h&gt; void process(); vim process.c 代码部分难度不高，重要的地方在于打印函数，printf("[%-100s][%3d%%][%c]\r",bar,rate,str[rate%num]);
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/169c347e445918a8eee423f525b9f0dd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b5e70cfc1d32eea70fb8a1b3533caedc/" rel="bookmark">
			如何开发一款搬家拉货小程序
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 小程序的兴起让我们的生活变得更加便利。相比于传统的应用程序，小程序无需下载安装即可直接使用，只需要在微信或其他支持的平台中搜索即可打开。这就意味着我们可以立即享受各种功能，无需等待下载和安装过程，节省了时间和手机存储空间。拉货搬家小程序提供了丰富的功能，如搬家、拉货等。通过小程序，我们可以随时随地完成各种操作，比如查看我们的搬家的路程还有多远，可以支持那些货物。这种便捷性极大地满足了我们的需求，让我们能够更加高效地进行各种操作。小程序还提供了个性化的服务和定制化的界面。无论是商家还是用户，都可以根据自己的需求和品牌形象来设计小程序的界面和功能，实现个性化的展示和交互体验。这使得小程序不仅具有实用性，还能够为用户带来更好的视觉享受和用户体验。
步骤
需求分析和UI设计：首先需要确定小程序的功能和需求，并设计用户界面，包括色彩、排版、图标、交互等方面。技术选型：选择适合的开发技术和框架，例如微信开发者工具、微信小程序框架等。开发环境搭建：安装开发所需的软件和工具，如微信开发者工具、代码编辑器等。数据库设计：根据需求设计数据模型，选择适合的数据库类型，如MySQL、MongoDB等。功能实现：依照需求和UI设计，实现小程序的各项功能，例如用户注册、登录、发布搬家拉货信息、下单、支付等。测试和调试：完成开发后，进行测试和调试以确保小程序的正常运行。上线发布：将小程序上传至微信小程序平台，经过审核后即可上线发布。同时要准备好推广计划，提高小程序的曝光度和用户量。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1505aa25187f32f09ca4635e427cb492/" rel="bookmark">
			Windows 如何进行base64编码，base64解码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		生产环境需要进行定期的更换秘钥，生成的新秘钥需要进行如下测试
1、旧秘钥 可以 正常加解密
2、旧秘钥 可以 解密旧密文
3、新秘钥 可以 正常加解密
4、新秘钥 可以 解密旧密文
5、旧秘钥 不可 解密新密文
新秘钥是经过 base64编码 的，所以需要进行 base64解码，然后拿到本地测试。
在llinux上有base64命令，也有很多在线编解码网站（ 在线编码与解码），那么win下能不能用命令行实现呢？ certutil命令：https://docs.microsoft.com/en-us/windows-server/administration/windows-commands/certutil
win是不区分大小写的，CertUtil 还是 certutil 无所谓。 一定不要用于linux，因为linux也有一个certutil命令，功能是不同的
base64编码 certutil -f -encode needEncode.txt afterEncode.txt # -f参数强制覆盖输出文件，避免出错 base64解码 certutil -f -decode needDecode.txt afterDecode.txt 参考 [Ref] Windows下base64编解码命令
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e616b1a4ae1779086c40fa1ed5bcd48d/" rel="bookmark">
			如何使用HadSky搭配内网穿透工具搭建本地论坛并发布至公网可远程访问
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
1. 网站搭建
1.1 网页下载和安装
1.2 网页测试
1.3 cpolar的安装和注册
2. 本地网页发布
2.1 Cpolar临时数据隧道
2.2 Cpolar稳定隧道（云端设置）
2.3 Cpolar稳定隧道（本地设置）
2.4 公网访问测试
总结
前言 作者简介： 懒大王敲代码，计算机专业应届生
今天给大家聊聊如何使用HadSky搭配内网穿透工具搭建本地论坛并发布至公网可远程访问，希望大家能觉得实用！
欢迎大家点赞 👍 收藏 ⭐ 加关注哦！💖💖 经过多年的基础设施建设和科技发展，网络已经成为我们生活中不可缺少的“必需品”。在大部分情况下，我们都可以在网络上找到需要的信息，并且能够通过特定方式（如论坛、留言、评论等）与众网友们交换意见和见解。不过，在别人的地盘呆久了，总会有自己建立交互空间吸引大家来畅聊的想法。今天，笔者就为大家介绍，如何在自家电脑的ubuntu系统上，建立轻量化的HadSky论坛，并让其能够为大家所访问（ 注意：面向公共的论坛网站，必须向当地监管部门申请备案！）。
1. 网站搭建 HadSky是一款开源的PHP轻论坛系统，依托常用的php和MySQL运行。由于其轻量化的特点，因此即便服务器设备性能不高，也能轻松运行。对于笔者这样将退居二线的过时电脑，是很合适的选择。现在，就让我们开始吧。
1.1 网页下载和安装 HadSky作为一款有一定知名度的软件，自然有自己的官网（www.hadsky.com），我们可以在这里找到hadsky网站程序的下载，也能看到hadsky网站的安装要求和问题解答。
根据安装要求，我们需要在本地ubuntu系统上安装PHP5.2和MySQL5.0，当然Apache（或Nginx）也是必不可少的。为了方便起见，笔者在ubuntu系统上安装了宝塔面板，方便快速安装和设置网站运行所需的各种程序。
我们也可以在宝塔面板的主页（可以在浏览器中输入本地地址:宝塔面板输出端口号）左侧，找到“软件商店”按钮，点击进入软件商店页面。在这个页面，我们可以找到常用的网站运行支持程序，包括Nginx、Apache、MySQL、PHP、phpMyadmin、Tomcat、Docker管理器、Redis等等。我们找到所需的软件，点击该软件条目右侧的“安装”，即可将其安装至ubuntu系统上。
依照hadsky官方给出的安装要求，我们需要使用PHP5.2+和MySQL5.0+，我们可以在这里选择对应PHP版本安装即可。
完成Apache、MySQL、PHP几项软件的安装后，我们可以点击软件商店页面上方的“已安装”按钮，查看已经安装的软件。同时，也可以在这里切换每个软件的版本。
接着，我们就可以进行下一步的hadsky网站部署。通常网站部署的步骤是将下载的网站源代码，放置到宝塔面板的wwwroot文件夹下，不过好在hadsky在宝塔面板中提供了“一键部署”模式，又为笔者省了不少事。
点击宝塔面板主界面左侧的“软件商店”。进入软件商店后，在页面上方找到“一键部署”按钮，进入可以一键部署的网站分页，从中选取“hadsky”条目，点击该条目右侧的“一键部署”按钮，
接下来会弹出网站基本设置窗口，在这里我们可以指定网站的基本信息，这些信息包括：
输出端口号 - 在“域名”栏位，通过“打算设置的域名：打算使用的端口”形式设置；
根目录 – 这个栏位可改可不改，但这个根目录内容会与“域名”栏位联动，为防止混淆，笔者还是将其更改为hadsky
数据库 – 这里填入我们之前设置的数据库信息即可；
PHP版本 – 对于某些网站可能会要求使用特定版本的PHP，我们就可以在PHP版本栏位修改（前提是已经安装了对应版本的PHP软件）
完成这些设置后，就可以点击窗口下方的“提交”按钮，创建hadsky网站。
网站创建完成后（一瞬间的事），宝塔面板会弹出已创建网站的地址，重要的网站信息（可能是数据库信息，或是网站后台登录信息）。
下一步打开ubuntu的宝塔面板，在软件主界面左侧点击“网站”按钮，进入网站列表页面，就能看到刚刚安装上线的hadsky网站。
此时我们在ubuntu的浏览器地址栏输入设置好的hadsky网站地址，就能看到haddsky的设置页面。我们继续根据网站显示页面的提示，进行具体的网站设置工作。
在hadsky网站安装过程中，会要求填写数据库相关信息（也就是在一键部署网站时设置的数据库信息），如果记不得网站数据库信息，则可以在宝塔面板左侧的“数据库”页面中找到有关内容。
1.2 网页测试 数据库设置完成后，hadsky网站就会显示出网站安装完成的提示，我们可以在这里选择进入hadsky网站后台，或者直接进入已安装的论坛进行查看。
Hadsky论坛后台页面
Hadsky论坛主页面
1.3 cpolar的安装和注册 完成hadsky论坛的部署后，就可以转入cpolar的安装。想要在ubuntu系统上安装cpolar，可以使用简便的一键安装脚本进行安装。只要在ubuntu的命令行界面输入以下命令，就可以自动执行安装程序（需要注意的是，可能有的ubuntu版本没有安装curl工具，因此最好先执行命令“sudo aptinstall curl”安装curl工具）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e616b1a4ae1779086c40fa1ed5bcd48d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/886f317c83da15afde8bd16ebfadfc9e/" rel="bookmark">
			虚拟主机操作系统 Windows、Linux
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		操作系统将直接影响服务器的性能、安全性和可用性，因此确保选择合适的操作系统对于成功运行您的网站或应用程序至关重要。以下是一些考虑因素，可帮助您选择适合您需求的虚拟主机操作系统。
1. 熟悉度和技术支持：
如何选择操作系统应该考虑您的经验水平和熟悉度。如果您已经熟悉某个特定的操作系统，或者在该操作系统上有丰富的开发经验和技术支持资源，那么您可能会更喜欢选择该操作系统。这样能够确保您能够充分利用已有的知识和技术支持资源，从而更好地管理和维护您的服务器。
2. 特定要求：
考虑到您的网站或应用程序的特定要求，可能需要选择特定的操作系统。一些应用程序可能只能在特定操作系统上运行，比如.NET Framework应用程序需要Windows服务器。因此，如果您使用特定的应用程序和技术栈，确保您选择的操作系统与之兼容。
3. 性能和稳定性：
不同的操作系统在性能和稳定性方面有所不同。对于具有高性能和稳定需求的任务，Linux通常是优选。Linux的内核具有出色的性能和稳定性记录，并且支持大量的开源软件和工具。然而，如果您更关注易用性和可视化界面，则Windows服务器可能更适合您。
4. 安全性：
操作系统的安全性是另一个重要的考虑因素。Linux在许多方面被认为是更安全的，具有更少的漏洞和更丰富的安全选项。然而，Windows服务器通过其成熟的安全功能和常见应用程序的易用性而得到认可。无论选择哪个操作系统，都应该确保及时更新补丁和安全升级，以最大程度保护服务器免受潜在的威胁。
总结起来，选择正确的虚拟主机操作系统对于您的网站或应用程序的成功运行至关重要。考虑自己的经验水平、特定要求、性能和稳定性需求、安全性等因素是做出明智决策的关键。重要的是，在选择后，及时进行安全更新和管理，以保证服务器的稳定性和可用性。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39110aa492be60abbedea3ab88edb4d4/" rel="bookmark">
			在做题中学习（44）：无重复字符的最长字串
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 3. 无重复字符的最长子串 - 力扣（LeetCode）
解法：同向双指针————“滑动窗口”
思路：如下图，当right进窗口后，就出现了a重复，所以在left出窗口时时，需要跳到第一个a 后面的位置，窗口才合法，而这个操作可以用哈希表来实现（判断是否重复出现就看哈希表里那个位置是否为1），而因为窗口的滑动需要重新算数，所以出窗口时left值要--。
1.left = 0,right = 0
2.进窗口————先直接进一个
3.判断————判断是否重复出现就看哈希表里那个位置是否为1
4.出窗口+重复判断————哈希表中left所在字符--
5.更新数据—————选出更长的len
class Solution { public: int lengthOfLongestSubstring(string s) { int hash[128]={0}; int len = 0; for(int left = 0,right = 0;right&lt;s.size();) { //1.进窗口 hash[s[right]]++; //2.循环判断 while(hash[s[right]]&gt;1) { //3.出现重复，出窗口 hash[s[left++]]--; } //4.更新结果 len = max(len,right - left + 1); right++; } return len; } }; 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/08c510651f52b3f03e609bad7b8cd4d1/" rel="bookmark">
			大创项目推荐 深度学习大数据物流平台 python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 0 前言1 课题背景2 物流大数据平台的架构与设计3 智能车货匹配推荐算法的实现**1\. 问题陈述****2\. 算法模型**3\. 模型构建总览 **4 司机标签体系的搭建及算法****1\. 冷启动**2\. LSTM多标签模型算法 5 货运价格预测6 总结7 部分核心代码8 最后 0 前言 🔥 优质竞赛项目系列，今天要分享的是
🚩 深度学习大数据物流平台
该项目较为新颖，适合作为竞赛课题方向，学长非常推荐！
🥇学长这里给一个题目综合评分(每项满分5分)
难度系数：3分工作量：3分创新点：4分 🧿 更多资料, 项目分享：
https://gitee.com/dancheng-senior/postgraduate
1 课题背景 根据研究报告，中国拥有全球最大的道路运输市场，2020年市场规模为人民币6.2万亿元。其中整车（FTL）和零担（LTL）运输占中国公路运输市场的大部分，2020年到达了人民币5.3万亿元。
整个物流市场由物流公司、专项车队、司机等角色组成。一个普通物流订单由货主，物流公司，车队和司机通过逐层人工订单传递完成。物流中还有计划外的货运需求，需要由调度人员通过人工电话联系各个下级的承运方进行承运。另外，物流行业中还有许多地方需要人工支持，如车辆的在途信息、货运单据以及财务结算。可见，人工支持在物流行业中占有较高比例。
较高的人工支持占比导致物流企业在运营过程中无法针对一些具体的情况或者突发事件进行快速的反应和决策，使得一些中小企业在市场竞争中处于劣势。因此，物流公司需要一个智能高效的数字化物流平台，使其拥有信息化、数据处理以及算法能力，形成一个高效的物流生态。
2 物流大数据平台的架构与设计 物流大数据平台通过数字化各个物流环节，使得各流程实时衔接，提升物流系统的效率。随着车辆的移动、票据资金的流转以及交易的完成，所有业务数据都会沉淀到物流大数据平台。接着，通过大数据平台的计算能力，对数据进行整理，归类和分析，将数据提供给物流平台中的各个应用模块。同时，平台引入算法（机器学习和深度学习），在海量数据中不断接近业务问题的全局最优解，借助算法决策使得收益最大化。
目前，物流大数据技术平台主要是由应用层，算法平台，数据仓库和数据平台组成。
最上层的是 应用层 ，包括销售管理、智能调度、货源推荐、图片资料审核等，提供了平台所需要的核心功能，其实现应用了很多算法。这些算法是在算法平台上开发的。
算法平台 提供丰富的算法以及模型来支撑整个平台的运转。
算法层的下一层是 数据仓库 ，存放了集团所有的业务数据。只有基于这些丰富的数据，算法才能够能够为上层应用提供服务。
最底层是整个 大数据平台基础设施 ，包含CDH集群（Hadoop/ spark/
Impala）、Doris集群和监控系统。它们实现了海量数据的基础存储和计算能力，对批量数据进行秒级的统计分析，让企业的业务人员和分析人员能实时掌握企业的运营情况。
应用案例
① 车辆在途追踪
数据平台可追踪到任意一台已经安装了特定GPS设备的车辆。GPS设备每三十秒给数据中心传输一条经纬度位置的数据，从而让数据平台获取车辆的实时位置。连续的实时位置可构成行车记录，用于判断车辆在货运的途中是否正常行驶、是否偏离方向、是否超速行驶等。
② 实时调度中心
实时调度中心可以实时地计算出物流平台上各时间段内累计的货运单量、活跃司机数、货主数、交易金额等，便于业务决策。
3 智能车货匹配推荐算法的实现 1. 问题陈述 智能车货匹配推荐算法的应用场景分为两种：一是人找货，二是货找人。人找货是货运司机通过浏览货运信息找到想要运输的货物；货找人是发货人下单后调度人员推送货源信息给货运司机。两个场景均涉及三个变量：司机、货物、环境。（具体涵盖如下图所示）
唯有合理运用这三个变量，才能计算出合理的车货匹配度。问题可以被抽象地用数学表达为 y=F(Xi, Xu,
Xc)，其中y表示匹配程度，Xi指的是我们的item货物，Xu指的是货运司机user，Xc指的是环境context。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/08c510651f52b3f03e609bad7b8cd4d1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/95f90c8a28f581f2d099b68b83c6412c/" rel="bookmark">
			k8s的集群调度
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k8s的集群调度： scheduler：负责调度资源，把pod调度到node节点。
预算策略
优选策略
1、List-watch k8s集群当中，通过list-watch的机制进行每个组件的协作，保存数据同步。每个组件之间的解耦。
kubectl配置文件，向APIserver发送命令-------apiserver把命令发送给各个组件。
kubectl run nginx --image=nginx:1.22-----------apiserver--------controller manager---------scheduler------------------------kubelet.
创建完成之后，kubelet get pod kubectl describe pod nginx--------------------&gt;etcd的数据库当中。
监听：
list-watch------会在每一步把监听的消息（APIserver:6443）-------------controller manager，schedule，kubelet，etcd都会监听
apiserver:6443端口来监听
如何来把pod分配到node.
2、调度的过程和策略： schedule是k8s集群的调度器，把pod分配搭配集群的节点。
有以下几个问题：
1、公平，每个节点都能够分配到资源
2、资源高效利用：集群当中的每个资源都可以被最大化使用
3、效率：调度的性能要好，能够尽快的完成大批量的pod的调度工作
4、灵活：允许用户根据自己的需求，控制和改变调度的逻辑。
schedule是一个单独运行的程序，启动之后就会一直监听APIserver，获取报文中的字段：spec.nodeName
创建pod的时候，为每个pod创建一个binding，表示该往哪个节点上部署。
创建pod节点时，有两个策略，先执行预算策略，再执行优选策略：这两步的操作都必须成功，否则立刻返回报错。
也就是说，部署的node，必须满足这两个策略。
预算策略： predicate自带一些算法，选择node节点（schedule自带的算法策略，不需要人工干预）
1、podfitsresources：pod适应资源，检查节点上的剩余资源是否满足pod请求的资源。主要是cpu和内存。
2、podfitshost：适应主机，如果pod指定了node的name，nginx1 pod------&gt;node01，检测主机名是否存在，存在要和pod指定的名称匹配。这样才能调度过去。
3、podselectormatches：pod选择器匹配，创建pod的时候可以根据node的标签来进行匹配。查找
指定的node节点上的标签是否存在，存在的标签是否匹配。
4、nodiskconflict：无磁盘冲突，确保已挂载的卷于pod的卷不发生冲突，除非目录是只读，就会覆盖。
node1
nginx1 pod /opt/nginx1
nginx2 pod /opt/nginx1
冲突了，会看node2上有没有，然后部署在node2节点上。
如果预算策略都不满足，pod将始终处于pending的状态，不断的重试调度，直到有节点满足条件为止。
若node1 node2 node3
经过预算策略，上述三个节点都满足条件，那该怎么办？------&gt;进行优选。
优选策略： leastrequestedpriority：最低请求优先级，通过算法计算节点上的cpu和内存使用率，确定节点的权重。
使用率低的节点相应的权重越高。调度时会更倾向使用率低的节点，实现资源合理的理由。
balanceresourceallocation：平衡资源分配，算cpu和内存的使用率，给节点赋予权重。权重算的是cpu和内存使用率接近。权重越高。
和上面的leastrequestedpriority最低请求优先级一起使用。
node1 cpu和内存使用率：20:60
node2 cpu和内存的使用率：50:50
node2在被调度时会被优先。
imagelocalitypriority：节点上是否已经有了要部署的镜像。镜像的总数成正比，满足的镜像数越多，权重越高。
nginx1.22
node1 无
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/95f90c8a28f581f2d099b68b83c6412c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2ad9e723a55cc8c2982633f448a04417/" rel="bookmark">
			DVWA-Hight-远程命令执行漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先打开DVWA漏洞平台
来到高级模块的命令执行漏洞处
这里利用phpinfo页面得知对方机器是一个Windows
这里先用管道符试探一下
观察结果
从这里观察发现whoami成功传入，但是还是报错了
这里我们一共传入管道符|和whoami两个参数，whoami成功传入没有问题，那就是管道符的问题
这里利用常用绕过手法来试一试
首先双写
居然一下子就成功了
这里可以肯定是一个管道符放入时被过滤掉了
但是它的过滤操作只执行了一次，当我们传入两个管道符后，对面的防御措施就被我们绕过了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6243bbcd4ac7104c981cc0261dcb62e2/" rel="bookmark">
			服务发现Discovery
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对于注册进eureka里面的微服务，可以通过服务发现来获得该服务的信息
1、 修改cloud-provider-payment8001的controller
import com.my.springcloud.utils.RestResponse; import com.my.springcloud.entities.Payment; import com.my.springcloud.service.PaymentService; import lombok.extern.slf4j.Slf4j; import org.springframework.beans.factory.annotation.Value; import org.springframework.cloud.client.ServiceInstance; import org.springframework.cloud.client.discovery.DiscoveryClient; import org.springframework.web.bind.annotation.*; import javax.annotation.Resource; import java.util.List; import java.util.concurrent.TimeUnit; @RestController @Slf4j public class PaymentController { @Resource private DiscoveryClient discoveryClient; /** * Discovery服务发现 */ @GetMapping(value = "/payment/discovery") public Object discovery() { // 第一种方式：获取所有服务 List&lt;String&gt; services = discoveryClient.getServices(); // 遍历每一个服务 for (String element : services) { log.info("*****element: " + element); } // 第二种方式：获取键名下的所有服务 List&lt;ServiceInstance&gt; instances = discoveryClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6243bbcd4ac7104c981cc0261dcb62e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/071e63945b583adc4ca888f61b79c3bd/" rel="bookmark">
			vue3用户权限管理（路由控制等）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在前端开发的过程中，我们需要做前端的权限管理，我们需要根据后端提供的信息来控制权限，这时候就需要根据用户的操作来进行权限控制了。逻辑稍微有一点绕，多理解就好了。
用户路由权限管理
大致的实现原理：
一般将路由分为2种，一种是静态路由，就是所有的账号都可以访问的路由，比如登录，比如主页等，还有一种是动态路由，就是我们需要做权限判断的路由。实现逻辑是，当我们登录完成后，获取到token，用token去接口请求，获取权限路由信息，在将路由信息存储到vuex中，然后在路由前置守卫里判断，去筛选，那我们在vuex中存储的权限信息去匹配我们拆分的动态路由，然后将整合的路由通过router.addroute将动态路由添加到前端路由里面，这样就实现了前端路由权限管控。
1，新建组件 我们建3个租价，一个主页组件，一个登录组件，还有一个404页面，其中登录组件是我们的静态组件，代表着所有用户都有权限访问
2，拆分动态路由 在路由配置文件里，新建一个文件，在里面放我们的动态路由。
在组件中把我们的动态组件放进去（主页组件，404组件）
后面我会讲为什么也要把404组件放在动态组件里面去。
export default [ { path: "/", //主页组件 name: "home", component: () =&gt; import("@/views/HomeView.vue"), }, { path: "*", //404组件 name: "notfound", component: () =&gt; import("@/views/NotFound.vue"), }, ]; 3,创建静态组件 静态组件就是每个账号都有的权限，正常在router文件夹下的index里写即可。
4.通过vuex来存储后端返回的权限信息 如何下载vuex我就不过多的说了，在vuex的state里建一个role来存储数据，然后在actions里请求权限接口，将接口返回的权限数据存放在role里，代码如下
import { createStore } from 'vuex' export default createStore({ state: { role:"" }, getters: { }, mutations: { setrole(state,data){ state.role = data } }, actions: { async getrole({commit}){ const role = ["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/071e63945b583adc4ca888f61b79c3bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4a1fe5ad60a6195993df5540e4acacb/" rel="bookmark">
			注解式参数校验@Valid，拒绝if-else炼狱
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 在软件开发中，与客户进行数据的交互是比较频繁的数据采集方式，而为了确保数据的正确落库，数据校验的部分必不可少。参数校验具体指的是对输入数据的大小、类型、正则匹配等对数据本身属性的校验，这一块的校验通常是在前端进行第一轮校验，确保参数具备一定逻辑正确性才将其打包至后端处理，而为了进一步增强安全性，也同样需要在后端板块进行二次校验。而对于此类校验，最常见也是最臃肿的处理方案就是if-else炼狱，如果说参数个数较少，那么无可厚非，但如果包含了七八个参数，那么这就很拉跨了，下面介绍一种基于注解的校验方案，进一步优化校验参数代码的可读性。
效果演示 本例子基于通过在实体类映射接收请求参数的MVC接口，对实体类中需要对属性进行如下验证：
name - 用户姓名，不能为空；
age - 年龄，大于0小于20；
phone - 手机号，满足手机号格式；
实体类代码 @Data public class TestPojo { @NotBlank(message = "不满足时抛出的自定义异常回馈信息") private String name; @Min(value = 0, message = "不满足时抛出的自定义异常回馈信息") @Max(value = 20, message = "不满足时抛出的自定义异常回馈信息") private Integer age; @Pattern(regexp = "^((13[0-9])|(15[^4])|(18[0-9])|(17[0-9])|(147))\d{8}$", message = "不满足时抛出的自定义异常回馈信息") private String phone; } 业务接口 @PostMapping("/test") public ResultVO test(@Valid @RequestBody TestPojo testPojo) { // 直接写业务代码，无需编写if-else校验.... return ResultVO.ok("响应数据"); } 结果VO类 @Data public class ResultVO&lt;T&gt; implements Serializable { private int code; private boolean success; private T data; private String msg; ​ private ResultVO(int code, T data, String msg) { this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d4a1fe5ad60a6195993df5540e4acacb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/78d92a7d749790be07380912f55d1b0f/" rel="bookmark">
			后端程序员开发win小工具(未完待续)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		github：https://gitee.com/forgot940629/win-tool-demo
本地启动，查看http://127.0.0.1:8080/form
场景 在日常工作中可能需要后端开发者开发一些辅助工具。这些辅助工具通常希望能想其他软件一样在桌面系统运行，并且有一些桌面应用的基本功能(可视化页面，配置文件，日志)。与其他应用程序最大的不同是，这种小工具只在很小范围内的开发者之间使用，通常情况下使用者都是开发者的同事。所以对可靠性要求不会特别高(毕竟不是给客户使用)，对页面美观或者交互逻辑也没有很高要求，但是需要在较短的时间内实现相应功能。
本篇文章针对上述场景提供了一个demo(代码链接在最上面)，便于有类似场景的java后端开发者可以快速构建出一些小工具。需要使用者有一定的spring使用经验，能够写一点前端代码。
问题 问题详述交互工具如何与使用者交互？命令行交互还是可视化页面？如果是可视化页面选择什么技术展示页面？错误软件出问题时如何排查错误？如何让用户感知到错误？配置很多东西不能写死在程序中，不能有一点改动就需要重新编译发布。需要有一种方式可以加载配置文件发布使用者可能没有开发者相同的运行环境，所以需要一种方式让没有相应运行环境的用户也可以使用此工具 方案 方案概述 问题方案交互后端使用thymeleaf编写页面，程序运行之后用户可在浏览器上进行相应操作错误可视化页面中打印错误日志，程序运行时在某个文件中记录运行日志配置将工作目录下特定名称的作为配置文件发布使用jpackage将可执行的jar包打包成安装包，用户可通过此安装包安装程序 方案选择的原因 交互 交互的实现方案首先要考虑我会什么。我不想为了开发一个小工具而去学习其他知识，没那么多时间。所以我在方案选择上只考虑了vue和thymeleaf。最终导致我抛弃vue的原因是vue好像要单独启动一个进程去提供前端页面服务(我在github上看了下halo这个项目中对于vue和thymeleaf的使用)，而thymeleaf和后端应用都在一个进程，启动spring之后直接就可以在浏览器上看到thymeleaf的页面。所以选择了thymeleaf。
选用thymeleaf更多的原因是我在这方面了解的确实不多，如果有其他好用的且好学(最好也是用html+js/ts编写页面)的工具，辛苦大佬们告知下。
错误 web服务中，错误一般通过两种形式展示出来，一种是通过页面弹窗告知客户，另一种是通过后端日志或者后端报警告知相关运维人员。
作为一个小工具，不需要连接报警平台，但是需要日志文件记录运行状况。同时为了让用户能在页面感知到相应错误，我决定使用文本框展示错误信息，每次新增的错误信息都追加到"运行日志"这个文本框中。
相比于弹窗，文本框有两点好处，一个是可以展示更多的错误细节，甚至可以把报错堆栈打印到文本框上(因为使用者通常也是程序员，所以打印报错堆栈可能更有助于使用)；另一个好处是文本框有对历史报错信息的保留，如果是弹窗的话可能报错信息一闪而过，于是就只能F12中一条条翻看请求寻找报错信息。
配置 我能想到的最直接的设置配置文件的方式就是让程序去某个绝对路径找配置文件，比如"C:\config.properties"。但是如果所有小工具都是这么加载配置文件，那么不同的工具直接可能会共用一个配置文件，会造成一些问题。比如不能同时使用多个工具，因为多个工具之间会抢占端口。
所以我希望配置文件可以与程序在同一个文件夹。
为了实现这一目的，我调用System.getProperty("user.dir") 获取当前工作目录(这个当前工作目录实际上就是程序安装之后exe文件所在目录，后续会介绍如何生成安装包)，然后在当前目录下找"config.properties"这个文件并加载。
发布 D:\software\jdk17\java\bin\jpackage.exe --win-dir-chooser --name PhoneNumberGeo --main-jar demo-0.0.1-SNAPSHOT.jar --input .\ --type exe
Tips 安装时尽量不要在C盘下，如果一定要安装到C盘下也尽量不要放到"Program Files"这个文件夹下，jpackage默认安装路径就是这个文件夹，但是我安装到这个文件夹下之后总是会出现奇怪的问题，比如日志不全或者配置文件加载错误。
待解决的问题 程序运行时没有图标，只能通过任务管理器关闭程序
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/67a47357911f37a957577111bff1ccfa/" rel="bookmark">
			停止css @keyframes动画
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决方法来源
display重绘异步事件
场景：在做一个基于Vue ElementUI后台系统页面loading的时候，遇到了给v-loading加动画，却会阻塞v-loading结束自动display: none的问题，导致必须等动画时长走完，蒙层才none，才可以点击页面。
机制：由于display:none会引起页面的重绘事件，所以它是一个异步的延时事件，所以浏览器其实会先解析animate的代码，然后再执行display:none。
代码如下，必须加入 animation: none !important 停止动画，否则会有‘阻塞’效果。还有一种暂停动画的方法，试过没起作用 animation-play-state: paused; 。
.el-loading-mask { background: rgba(255, 255, 255, .1); backdrop-filter: blur(3px); background-image: url("../assets/images/XOsX.gif"); background-size: 80px 80px; background-repeat: no-repeat; background-position: center; position: absolute; animation: comeup 10s infinite; // 动画 .el-loading-spinner { display: none !important } } .el-loading-fade-leave-active{ animation: none !important; // 删除动画（解决动画时长阻塞display:none问题） } @keyframes comeup { 0%{background-size: 80px 80px;} 90%{background-size: 210px 210px;} 100%{background-size: 220px 220px;} } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6db206342f7583d11a566ad42d88db8f/" rel="bookmark">
			【开源GPT项目 - 在问】让知识无界,智能触手可及
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Chatanywhere: chatAnywhere
在问 | 让知识无界，智能触手可及
项目简介 这是一个免费的在线聊天工具，旨在让用户更方便地享受科技带来的便利。用户可以使用我们的工具来获取答案、寻求建议、进行翻译和计算等等。这是由一位个人开发者创建的，水平有限，如遇到问题也多包涵。同时，我们欢迎大家一起讨论技术问题和提出技术指导，让我们共同进步。
我们采用了现在最流行的模型提供聊天服务，用户可以直接访问链接使用此工具。我们不会要求用户进行任何登录操作，也不会在后台保留任何用户隐私数据。这样做虽然可能会带来一些不便，但我们坚信保护用户隐私才是正确的做法。
欢迎使用！ 主界面
青春版连带有画图功能。高效工作版的界面干净，有会话整理（类似于浏览器的书签集合）和arxiv搜索总结功能，也可以免费申请使用4的调用。非常适合桌面办公。 点击此处查看精美作画指南
使用问答： 为什么有时候会不出结果： 答：原因可能有很多，最可能的原因有三个：提问的文字太多、模型调用失败或者网站流量太大。您可以减少输入文字，并再次尝试。不管出现哪种情况，您都可以放松一下，过段时间再来尝试。网站不会崩溃，请您放心。 为什么对2022年后的事物，AI总是乱答 答：模型数据收集到2021年，所以对之后的事情，AI无法给出事实性的描述，如您确实需要提问，请使用联网搜索功能。使用方法可参看下方开发日志 5. 为什么每次聊天一段时间后，就会出现一段总结？ - 答：这是个技术问题，每次刷新页面，用户都会在本地打开一个新的流。当前对话会在本地积累，直到用户关闭流或对话数量过多时，程序会触发模型总结之前的交互内容，并结合下一个对话请求的内容做出回应。在这个过程中，所有已经总结的对话都会从服务器上清除，从而保证运行的有效性和效率。但用户可以放心，总结并不代表后台会存储聊天记录，而是在用户本地的流内保存一小段时间，总结完成后，本地流会释放之前的聊天记录
注：新版中不会再有这种现象 6. 为什么偶尔会出现吞字现象？
注：此bug已解决 为什么没有历史记录，以后会不会有这个功能？ ~~ 答：主要是出于保护用户隐私的目的，后续可能会开放用户注册机制，与游客机制并行，以满足有保存历史记录的用户需求。~~
答：现在可以选择保留全部历史记录或删除全部历史记录。为了更好地保护用户数据，我们放弃了注册机制，因此无需在后台保留历史记录就可以完成这个功能。 是否可以有语音输入功能？ 答：网页需要系统的麦克风权限，这可能被浏览器本身利用来收集用户隐私。尽管会带来便利，但以隐私换取的方式与项目的原则违背。很多输入法（搜狗等）自带语音输入功能，可配合使用。 特点 免费：我们的在线聊天工具是完全免费的，用户可以随时使用，无需支付任何费用。多功能：用户可以使用我们的工具来获取答案、寻求建议、进行翻译和计算等等。简单：用户只需通过 HTTP 调用就可以使用我们的在线聊天工具，使用起来非常简单。高效：我们采用了现成的模型提供聊天服务，可以快速地回答用户的问题。隐私保护：我们不会要求用户进行登录操作，也不会在后台保留任何用户隐私数据，保护用户隐私。开放性：我们欢迎用户在 Issues 中提出问题和建议，我们会尽快回复并解决问题。 注意事项 安全性：我们保证后台不记录用户任何个人隐私数据，但我们不确定我们所调用的模型的开发人员是否会保留用户数据，所以，请注意保护个人隐私事实性错误：我们采用的现成模型可能会出现一些事实性的错误，用户需要自行判断信息的正确性。这点很重要！！！很重要！！！不便之处：我们不会要求用户进行登录操作，也不会在后台保留任何用户隐私数据，这可能会带来一些不便之处，但我们相信这是保护用户隐私的正确方式。 联系我们 如果您在使用中遇到任何问题或有任何建议，请在 Issues 中提出，我们会尽快回复并解决问题。
技术座右铭 如果不能享受技术进步的便利，又怎么会有创造技术进步的动力。
您可以对技术感兴趣，但请不要对我这个人感兴趣，如果您使用体验不错的话，说明算法和模型厉害，与本人无关。如一位名人说过：如果你吃到一个鸡蛋，觉得好吃，你又何必去认识下蛋的母鸡呢？
开发心路历程 请移步这里
更新日志 2023年3月1日：启动项目，提供基本的聊天服务功能。2023年3月2日：增加计算功能，用户可以通过我们的工具进行简单的计算。2023年3月3日：优化前端，正式上线。更新项目简介。2023年3月4日：根据用户反馈，过滤到无关的政治争论话题。增加流量限制，单IP用户十分钟内使用次数受限2023年3月5日：重大更新 优化聊天系统响应速度，特别是长文本响应时间优化部署，服务器可承载更大流量负载进一步限制模型对开发后台信息的泄露适当增加了单IP十分钟内使用次数2023年3月6日： 改为域名访问优化界面显示，对空格的显示更加合格，代码复制更容易优化异常处理2023年3月9日： 停止了对非大陆境内IP的服务，因此如果使用外国IP可能造成无法使用的错误。2023年3月10日： 进一步限制了政治相关话题的输出，尽管有大量诉求，但考虑到语言模型的事实性错误实在不可避免，为引起误导，因此关闭了政治话题的讨论权限。2023年3月12日： 设定了每天的北京时间凌晨4点自动重启以更新后台可调度资源，时间大概1秒钟。2023年3月13日： 增加异常处理机制，提高服务的稳定性。改为https加密传输，或者其他加密方式，尽可能提高安全性。2023年3月18日： 界面优化，机器人回复全部改为markdown显示，支持代码高亮与一键复制功能2023年3月21日： 界面优化新增联网搜索功能，使AI系统可以紧跟数据更新。只需要在输入前加上“你帮我找”四个字，后台就会搜索网页内容并整理呈现。如“你帮我找 流浪地球2”2023年3月24日： 界面优化解决了首字吞字bug解决了流量问题，现在基本不会因为流量拥挤而回复失败2023年3月24日： 青春版新增AI作画功能，只需要在文字前加下“你帮我画”四个字即可，如“你帮我画 一只泰迪在清华大学滑滑板，高清摄影，4K，大师级” 2023年3月28日： 实现了用户的历史对话记录功能，而无需在后台保留用户的数据。具体实现方法是，通过 localstorage 存储用户数据的方式，将数据在本地保存。这样，用户在刷新浏览器后，就可以直接从本地读取历史消息。在整个过程中，后台与前端没有进行任何数据传输。而在界面的右上角，我们还添加了一个小的悬浮按钮，用户点击后便可以一键删除历史记录。需要注意的是，这种方式无法将数据在设备或浏览器之间进行迁移。2023年3月30日： 添加绘画指南链接绘画尺寸翻倍2023年3月31日： 开源项目完整代码2023年4月1日： 随着服务器安全等级日渐完善，解除外网IP限制2023年4月10日： 开放4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6db206342f7583d11a566ad42d88db8f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/17/">«</a>
	<span class="pagination__item pagination__item--current">18/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/19/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>