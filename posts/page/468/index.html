<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/229a1fdf350e376fa9ad8a8e678bc13c/" rel="bookmark">
			修改了一个YUV/RGB播放器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在学习过程中查看YUV/RGB像素数据的时候，发现找不到一个合适的播放器。主流的YUV播放器大多只支持YUV格式播放，却不支持RGB格式数据播放。而我正好需要查看RGB像素数据。在Sourceforge上找到了一个比较好用的既支持YUV又支持RGB的播放器，但是发现有一些小毛病，于是把这个播放器源代码下载下来并且做了一些修改，感觉好用了很多。在这里写文章记录一下。 该播放器使用比较简单，可以通过菜单栏打开像素数据文件，也可以通过拖拽方式打开文件。如果文件名称中包含了“{w}x{h}”这样的字符串（例如“test_320x420.yuv”），系统会自动解析为该像素数据的宽和高。 软件在原版的基础上做了如下修改：
(1) 修正了2处内存泄露。 (2) 在“打开文件”对话框中添加“RGB类型”，“所有类型”两种文件类型。 (3) 从文件名中自动解析宽高信息。文件名格式应该是“XXX_{width}x{height}.yuv”，例如“test_1920x1080.yuv”。 (4) 添加中文语言 (5) 添加了8:1放大 YUV Player 原版项目地址：https://sourceforge.net/projects/raw-yuvplayer/
修改版源码地址：https://github.com/leixiaohua1020/YUVplayer
编译后可以直接运行的程序：http://download.csdn.net/detail/leixiaohua1020/9391876
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8bfeea6ee6fb996c281f85141e441aed/" rel="bookmark">
			libevent - 定时器
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		准备工作：
1. 下载libevent源码，进行编译。（这一步生成libevent_core.lib、libevent_extras.lib库文件）
2. 新建目录3rd，将编译生成的库文件(lib)及头文件(include)放在该目录下。
3. 打开我们的工程，将3rd/include添加到include目录，3rd/lib添加到库目录。
4. 在工程Linker中引入libevent_core.lib、libevent_extras.lib、ws2_32.lib等库文件。
5. 编写代码，调用libevent提供的接口，实现定时器功能。（代码如下）
#include &lt;cstdlib&gt; #include &lt;iostream&gt; #include &lt;event2/event.h&gt; #include &lt;event2/event_compat.h&gt; #include &lt;event2/event_struct.h&gt; using namespace std; timeval tv; event ev; void time_cb(int fd, short event, void *argc){ cout &lt;&lt; "time_cb..........." &lt;&lt; endl; event_add(&amp;ev, &amp;tv); } int _tmain(int argc, _TCHAR* argv[]) { event_base *base = event_init(); //event_set(&amp;ev, -1, 0, time_cb, nullptr); evtimer_set(&amp;ev, time_cb, nullptr); event_base_set(base, &amp;ev); // 设置超时 tv.tv_sec = 5; tv.tv_usec = 0; event_add(&amp;ev, &amp;tv); event_base_dispatch(base); system("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8bfeea6ee6fb996c281f85141e441aed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/57d8ba01d7dfff8082ce22bb2efce76d/" rel="bookmark">
			MySQL数据库中如何新建一个带参数的存储过程procedure
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们都知道，现在MySQL的版本，可以支持存储过程了。我使用的是MySQL5.5的版本。
1，创建存储过程
delimiter $
create procedure in_out_procedure(in procedure_id int,out count_number int) begin select count(*) into count_number from temp_url where id=procedure_id;
end $
delimiter ;
注意：delimiter $ 改变分隔符，MySQL数据库中，使用delimiter 关键字来改变分隔符，当我们在创建触发器或者存储过程的时候，经常会用到。
2，执行存储过程：
call in_out_procedure(1,count_number);
MySQL如何调用带参数的存储过程？
call in_out_procedure(1,@param1);
select @param1;
注意，带有输出out的存储过程，我们在使用时，需要先获得输出结果，这里我们使用参数param1，相当于是接收返回结果，然后就可以使用这个返回结果了。
3，再来看下面的例子：
delimiter $
create procedure out_procedure(out count_number int) begin select count(*) into count_number from temp_url where id=1;
end $
delimiter ;
执行存储过程：
call out_procedure(@param1);
select @param1;
4，如何查询数据库中所有的存储过程？
第一种方式：show procedure status;
第二种方式：select name from mysql.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/57d8ba01d7dfff8082ce22bb2efce76d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8457ab4d4d70aa55a804f9030da87613/" rel="bookmark">
			解决android.view.InflateException: Binary XML file line #8: Error inflating class
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 解决异常：android.view.InflateException: Binary XML file line #8: Error inflating class com.match.txtview
现象：在xml布局文件中调用自己写的view时报了这个错误，试了好多办法都不行，我发现继承TextView时少写了一个构造方法public TxtWordView(Context context, AttributeSet attrs)。
原因（百度的）：
1、自定义view需要注意构造函数，所有的xml布局，初始化时构造函数使用的都是 (Context context, AttributeSet attrs) {两个参数的。如果没有该构造函数会报错。
2、如果有自定义属性，则需要在当前xml中引入工程包名，否则自定义属性会报错。
解决方法：
加上这两个方法即可：
//缺少此方法会报错：android.view.InflateException: Binary XML file line #8: Error inflating class
public TxtWordView(Context context) { super(context); }	public TxtWordView(Context context, AttributeSet attrs) { super(context, attrs); } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8deba17ff8a1a72ac579baa531ca49cb/" rel="bookmark">
			Android退出应用最优雅的方式(改进版)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们先来看看几种常见的退出方法（不优雅的方式）
一、容器式
建立一个全局容器，把所有的Activity存储起来，退出时循环遍历finish所有Activity import java.util.ArrayList; import java.util.List; import android.app.Activity; import android.os.Bundle; public class BaseActivity extends Activity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 添加Activity到堆栈 AtyContainer.getInstance().addActivity(this); } @Override protected void onDestroy() { super.onDestroy(); // 结束Activity&amp;从栈中移除该Activity AtyContainer.getInstance().removeActivity(this); } } class AtyContainer { private AtyContainer() { } private static AtyContainer instance = new AtyContainer(); private static List&lt;Activity&gt; activityStack = new ArrayList&lt;Activity&gt;(); public static AtyContainer getInstance() { return instance; } public void addActivity(Activity aty) { activityStack.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8deba17ff8a1a72ac579baa531ca49cb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/76c1c4ff1cc30af3bcdff5840f8ec85e/" rel="bookmark">
			ubuntu12.04用NAT方式通过windows上网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		必要条件：
VMware10中的DHCP和NAT服务已经打开，查看方式
控制面板-》管理工具-》服务
如果没有DHCP和NAT服务，则通过VMware-》编辑（Edit）-》虚拟网络编辑器。然后点击左下角的‘’‘’恢复默认设置‘’‘’‘重启DHCP和NAT服务。
等待片刻，在服务中就能看到DHCP和NAT服务了。
步骤一、在windows中，查看网络连接，将能上网的网卡分享网络，右键能上网的网卡-》共享-》以太网3（因为以太网3 是VMnet8）
此后 以太网3的IP4地址自动改变为192.168.137.1，同时将地址如下图所示改变数据
步骤二、设置VMware-》”编辑“-》虚拟网络编辑器
点击”NAT设置“ ， 设置网关IP为192.168.137.2
保存退出。
步骤三、设置ubuntu12.04的虚拟机设置中的网络连接模式改为NAT
进入ubuntu 系统设置静态IP
手动设置DNS vim /etc/resolv.conf 添加
nameserver 192.168.137.2
nameserver 8.8.8.8
保存退出。
注意：重启Ubuntu后发现又不能上网了，问题出在/etc/resolv.conf。重启后，此文件配置的dns又被自动修改为默认值。所以需要永久性修改DNS。方法如下，参考视图在随后：
sudo gedit /etc/resolvconf/resolv.conf.d/base
nameserver 192.168.137.2
nameserver 8.8.8.8
3、重启networking服务使其生效：
# /etc/init.d/networking restart
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c249b82999ee7517756cef52047c341/" rel="bookmark">
			时间转换报java.lang.NumberFormatException: multiple points问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近项目一直会出现时间转换报错，一直不知道是什么问题，
java.lang.NumberFormatException: multiple points
at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1110)
at java.lang.Double.parseDouble(Double.java:540)
at java.text.DigitList.getDouble(DigitList.java:168)
at java.text.DecimalFormat.parse(DecimalFormat.java:1321)
at java.text.SimpleDateFormat.subParse(SimpleDateFormat.java:1793)
at java.text.SimpleDateFormat.parse(SimpleDateFormat.java:1455)
报错的地方是项目用SimpleDateFormat写了个DateUtil工具类，用来时间转换的，代码如下：
public final class DateUtil { private static SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd"); public static Date parseDateTime(String dateTimeStr) { try { return dateFormat.parse(dateTimeStr); } catch (ParseException e) { // TODO Auto-generated catch block e.printStackTrace(); } return null; } ｝其中 return dateFormat.parse(dateTimeStr); 偶偶会报java.lang.NumberFormatException: multiple points或者报java.lang.NumberFormatException: For input string: ".31023102EE22"
今天实在是忍受了，百度了下，原来是SimpleDateFormat是非线程安全的，在多线程情况下会有问题，在每个线程下得各自new SimpleDateFormat()就可以了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f988aca93db7c600cbe55b513afe4de2/" rel="bookmark">
			Boosting &amp; AdaBoost算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 提升和自适应提升方法
Boosting &amp; AdaBoost
1 算法起源
在机器学习领域中，关键问题就是如何利用观测数据通过学习得到精确估计。但是，在实际应用领域中，构造一个高精度的估计几乎是不可能的。Boosting就给出了一个解决上述问很好的思路。Boosting是一种提高任意给定学习算法准确度的方法。它的思想起源于 valiant在1984年提出的 PAC ( Probably Approximately Correct)学习模型。Valiant和 Kearns提出了弱学习和强学习的概念 ，识别错误率略小于1/2，也即准确率仅比随机猜测略高的学习算法称为弱学习算法；识别准确率很高并能在多项式时间内完成的学习算法称为强学习算法。同时，Valiant和 Kearns首次提出了 PAC学习模型中弱学习算法和强学习算法的等价性问题，即任意给定仅比随机猜测略好的弱学习算法 ，是否可以将其提升为强学习算法？如果二者等价，那么只需找到一个比随机猜测略好的弱学习算法就可以将其提升为强学习算法，而不必寻找很难获得的强学习算法。
1990年, Schapire最先构造出一种多项式级的算法 ,对该问题做了肯定的证明，这就是最初的 Boosting算法。
一年后，Freund提出了一种效率更高的Boosting算法。但是,这两种算法存在共同的实践上的缺陷 ,那就是都要求事先知道弱学习算法学习正确的下限。1995年，Freund和Schapire改进了Boosting算法，提出了 AdaBoost (Adaptive Boosting)算法，该算法效率和 Freund于 1991年提出的 Boosting算法几乎相同，但不需要任何关于弱学习器的先验知识，因而更容易应用到实际问题当中。之后，Freund和 Schapire进一步提出了改变 Boosting投票权重的 AdaBoost . M1，AdaBoost . M2等算法 ,在机器学习领域受到了极大的关注。其实，Boosting是一种把若干个分类器整合为一个分类器的方法，在Boosting算法之前，还出现过两种比较重要的将多个分类器整合为一个分类器的方法，即boostrapping方法和bagging方法。
2 Boosting方法的基本思路
提升方法基于这样一个思想：对于一个复杂任务来说，将多个专家的判断进行适当综合所得出的判断，要比其中任何一个专家单独的判断要好。实际上，就是“三个臭皮匠顶个诸葛亮”的道理。提升方法的问题在于，在学习中，如果已经发现了弱学习算法，能否将它提升为强学习算法。因为在应用中，发现弱学习算法要比强学习算法容易得多。关于提升的策略，最具代表性是AdaBoost算法。对于分类问题，在给定的训练样本上获得一个粗糙规则（弱分类器）要比获得一个精确规则（强分类器）容易的多。提升方法就是在弱学习算法上反复学习，得到一系列的弱分类器（也叫做基本分类器），然后组合这些弱分类器，构造一个能够更加准确分类的强分类器。此时会有两个问题： 1、如何进行弱分类器的学习？
2、如何将弱分类器组合构成强分类器？ 关于第一个问题大多是的提升方法都是通过改变训练样本的概率分布（权值分布）来实现的。AdaBoost的做法是提高那些被前一轮弱分类器分类错误的样本权重，降低正确分类的样本权重。也就是说，没有正确分类的样本在下一轮的弱分类器中将会得到更大的关注。至于第二个问题Adaboost则采用的加权投票，少数服从多数的策略，也就是要增大分类错误率小的弱分类器的权值，使其在决策中起到较大作用，减小分类错误率大的弱分类器的权重，使其表决权也相对减小。 3 AdaBoost方法
3.1AdaBoost算法（二分类）
基本分类器的选择方法 在确定基本分类器时，AdaBoost通常采取的方法是遍历所有的弱分类器（或是所有的特征），求所有的弱分类器在正负样本上的错误率，将最小错误率对应的弱分类器作为本轮迭代的基本分类器。在遍历的过程要注意，弱分类器是有两个方向的，不同的方向判为正例和负例所导致的错误率也是不相同的，所以对一个弱分类器在训练样本上需要计算两次错误率，取最小值作为该弱分类器在训练集上的训练错误率。具体过程如下： 在实际的应用中由于训练的样本量巨大，如果一一比较所有样本的特征值是否过该弱分类器所设定的阈值，需要大量的计算时间，导致训练速度很慢。实际上我们采取的是这样的方法：
训练样本事先分成两类：正样本和负样本，并按照特征值从小到大进行排序。人脸检测的弱分类器（特征）的阈值选取的方法通常定义为两个样本特征值的平均数，选取最优的阈值（错误率最小的阈值）时要遍历所有的样本，由于事先已经排序，只需要计算该样前面或后面的样本个数即可。
例如，下图中为某一个特征10000正样本和1000负样本对应的特征值：
3.2AdaBoost算例
E.X.1 一个虚拟的例子
现在，在一个平面方格中10个样本，被分为两类，非别被标有“＋”和“－”，定义分类器为竖直或水平的直线。例如，一个弱分类器被定义为一条竖直的直线，该直线数据点分为左右两部分，直线左半部分判断为正样本，右半部分的样本点被判断为负样本。这10个样本点中有5个“＋”和5个“－”，如图所示
从图中不难看出，选用任何一条直线对这些点进行划分，错误都要高于30%。对于AdaBoost来说，每次循环t，假设基学习都是找到在权重 Dt下加权错误最小的基假设，从下面的计算结果可以发现AdaBoost只需要通过3步迭代（T＝3）就可以获得对样本点的完美分类。为方便记录直线分类器的符号方向，给定记号P，并且规定若P&gt;0，则直线左侧或是下侧为“+”，若P&lt;0，则直线左侧或是下侧为“—”。为方便观察和计算将10个样本标记在9×9的棋盘网格中，不难理解假设空间为图中20条先构成的分类器。
则分类器分类的结果（Y表示正确分类，N表示错误分类）：
上表中计算的数值为整体四舍五入到小数点后两位。
每一次迭代获得基本分类器如下：
E.X.2一种选择弱分类器的方法
解：
在这里我们定义弱分类器由 产生，其中 是两个样本的平均数（实验中常用的一种弱分类器确定的方法）。
初始化权重分布 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90e7ae35d653cdf3a3ff78ccec817e0b/" rel="bookmark">
			LeetCode 1. Two Sum 解题报告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题意： 数组nums中，有两个元素的和是target，找出这两个元素的位置。 思路： 维护一个map，用数组的元素的值做key，用元素的位置做value。遍历nums，对每个num来说，如果map[target - num] 有值的话，就返回map[target - num]和num的位置，如果没有找到的话，就把num插入到map中，map[num] = index。时间复杂度O(nlogn)。 C++ Code:
class Solution { public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) { std::map&lt;int, int&gt; map; for(int i = 0; i &lt; nums.size(); i++) { if(map.find(target - nums[i]) != map.end()) { std::vector&lt;int&gt; result{map[target - nums[i]], i + 1}; return result; } map[nums[i]] = i + 1; } } }; Python Code: class Solution(object): def twoSum(self, nums, target): """ :type nums: List[int] :type target: int :rtype: List[int] "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90e7ae35d653cdf3a3ff78ccec817e0b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17b8bcca01e925ccf64fa5a346d9f62a/" rel="bookmark">
			Openwrt编译问题:Libnettle 3.1 was not found.
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近在编译Openwrt固件，遇到一个libnettle的问题。对Openwrt不是很熟悉，折腾了几天，解决了，下面说一下思路。
问题日志如下：
checking for inline... inline checking for ANSI C header files... (cached) yes checking for getrandom... no checking for getentropy... no checking for NETTLE... no configure: error: *** *** Libnettle 3.1 was not found. make[3]: *** [/home/huqian/openwrt-sdk-v1.3.5/trunk/build_dir/target-mipsel_24kec+dsp_uClibc-0.9.33.2/gnutls-3.4.7/.configured_yynynyynnynn] Error 1 make[3]: Leaving directory `/home/huqian/openwrt-sdk-v1.3.5/trunk/feeds/packages/libs/gnutls' make[2]: *** [package/feeds/packages/gnutls/compile] Error 2 make[2]: Leaving directory `/home/huqian/openwrt-sdk-v1.3.5/trunk' make[1]: *** [/home/huqian/openwrt-sdk-v1.3.5/trunk/staging_dir/target-mipsel_24kec+dsp_uClibc-0.9.33.2/stamp/.package_compile] Error 2 make[1]: Leaving directory `/home/huqian/openwrt-sdk-v1.3.5/trunk' make: *** [world] Error 2查看日志发现，是在编译gnutls-3.4.7时出现问题。继续查看该目录trunk/build_dir/target-mipsel_24kec+dsp_uClibc-0.9.33.2/gnutls-3.4.7/下的config.log文件，寻找与nettle相关的信息，得如下： configure:8496: checking for NETTLE configure:8504: $PKG_CONFIG --exists --print-errors "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/17b8bcca01e925ccf64fa5a346d9f62a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cdf14a5726ba362ddf5aefb6bee40ab9/" rel="bookmark">
			netty 通过端口调用关闭
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package websocketdemo.timeserver2;
import io.netty.bootstrap.ServerBootstrap;
import io.netty.channel.Channel;
import io.netty.channel.ChannelFuture;
import io.netty.channel.ChannelInitializer;
import io.netty.channel.ChannelOption;
import io.netty.channel.EventLoopGroup;
import io.netty.channel.nio.NioEventLoopGroup;
import io.netty.channel.socket.SocketChannel;
import io.netty.channel.socket.nio.NioServerSocketChannel;
import io.netty.handler.codec.http.HttpServerCodec;
/**
* 通过端口调用关闭netty演示&lt;br /&gt;
* 调用方法&lt;br /&gt;
* new TimeServer(8080, 8081).run(); //8080, 正常工作商品, 8081, 关闭端口&lt;br /&gt;
* http;//127.0.0.1:8081/close; //关闭netty
* @author lizw
*/
public class TimeServer {
private int port;
private int port_shutdown;
public TimeServer(int port) {
this.port = port;
}
public TimeServer(int port, int port_shutdown) {
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cdf14a5726ba362ddf5aefb6bee40ab9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6b015b3f225a905bc12ae4918b3fc52c/" rel="bookmark">
			css 文字长时不换行 显示...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 .title{ text-overflow: ellipsis;//clip 修剪文本。ellipsis 显示省略符号来代表被修剪的文本。string 使用给定的字符串来代表被修剪的文本。 white-space: nowrap;//规定文本不进行换行 直到遇到 &lt;br&gt; 标签为止。 } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3f08bd23116c4615286a7549278c9679/" rel="bookmark">
			MFC 自定义消息ID
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.自定义消息ID起始ID号是WM_USER；
2.自定义消息ID名称最好是UWM ，U意思是自定义的意思，用以与系统消息ID区分；
3.自定义消息变量类型是 UINT 类型。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0de5337619ed3d61d3f883fe58a205ed/" rel="bookmark">
			有没有安全的工作？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果你经常使用互联网，可能知道有一种东西叫做Flash。
它是一种软件，用来制作网页游戏、动画，以及视频播放器。只要观看网络视频，基本都会用到它。
七八年前，它是最热门的互联网技术之一。如果不安装Flash，很多网站根本打不开。那时还流行用它制作动画，随便一个作品，就有几十万、上百万的浏览量。电视台甚至开辟栏目，播放网上流行的Flash动画。各大互联网公司都有专门的Flash工程师，还是属于那种比较抢手、收入较高的工程师。我记得那个时候，社会上也有大量的Flash培训班，它们的招生广告都写着保证就业。
后来，Flash就不行了。2010年，乔布斯宣布，苹果手机不会使用Flash，因为影响手机性能。再后来，新的技术兴起，它就开始没落了。上个月，BBC发表一篇报道，名字就叫《Flash还能活多久？》。话音刚落，一周后，这项技术的拥有者Adobe公司宣布，放弃Flash这个名字，软件将重新定位，只用来制作动画。
说了这么多，我并不是感叹Flash这项技术的没落，这也是很正常的事，而是感叹那些从事Flash开发的工程师，他们该怎么办呢？你在一个领域钻研多年，都成了专家，突然之间那个领域过时了，你的所学所长没人需要了，那将是怎样的处境？
那些年里，我在上海遇见过一个朋友。他开了一家软件公司，专门面向海外市场开发Flash游戏。公司不大，十几个人，那时正是最好的年景，每个月都有几十万、甚至上百万人民币进账，看上去前景一片大好。可是，谁能想到Flash技术突然就会不行了呢？开始时，公司还能维持，后来手机游戏起来了，Flash游戏的市场顿时萎缩。我见过他的招聘广告，改招手机游戏的开发者。再后来，就再没听到过他的消息。
当一种技术消亡的时候，与它相关的工作岗位也就消亡了。这种事情在技术行业特别多，因为技术的升级换代太快了。
我再举一个例子。苹果手机出现之前，最流行的手机都使用Nokia公司开发的"塞班"操作系统。你可能还记得，它的典型标志就是"九宫格"菜单。那时，塞班工程师也是非常抢手的，彻底掌握它那一套开发技术，我估计至少要一两年时间。后来，智能手机流行，塞班一败涂地。2010年，诺基亚宣布放弃塞班，改用微软的操作系统。再后来，Nokia自己也没了，所有手机工程师都遣散了。我知道，Nokia中国有一个资深工程师，选择重进大学去读MBA学位。
试想一下，你花了多年的心血，孜孜不倦地投入和练习，终于掌握了一门赖以谋生的手艺，还进入了世界排名第一位的通信业跨国公司。就在你觉得人生终于有一点安全感的时候，一切就变了，几年之间，曾经的巨无霸土崩瓦解，不仅你的职位没了，更可怕的是，以前的产品已经没人用了，全世界现在不生产任何塞班设备。你的手艺的价值变成了零。
有人说，可以再学习、然后重新就业啊，塞班不行了，可以学习苹果手机开发。没错，说得完全正确。但是，你以前的积累没了，需要从零开始。跟现在刚刚走出校门的学生，站在同一条起跑线上，学习同样的东西。说实话，虽然你有几年开发经验，但很可能并没有那些20岁的年轻人学得快。在一个高速变化的行业，经验有时候不是帮助，而是障碍，因为以前的那套行不通了。退一步说，就算你重新学习了，但苹果手机的开发也在变，你得不停地追赶新东西 。一个人的人生，能经受得起多少次从零开始呢？
"终身学习"这个词完全没错，但是想通过"终身学习"保持职业竞争力，我觉得不太可能。
程序员，乃至其他很多技术岗位，其实是青春饭。只有底层的技术，还有一些稳定性，越接近应用层，技术的升级换代就越快。你学会一门技术，然后吃上三十年，这种事情越来越少见了。更常见的是，几年以后，你会的东西就淘汰了，你被迫重新学习新东西，或者重新就业。
为什么中国很少见35岁以上的程序员？因为他们上学时学习的东西都淘汰了，必须和年轻人一起学习新技术。你很难比年轻人更有竞争力，其中最关键的是，雇佣刚走出校门的学生，比雇佣你便宜得多。
其他行业的升级换代，不如技术行业那么夸张和激进。职业的安全感可以保持得更久一些，但远不是高枕无忧。技术正在取代人力劳动，比如财务会计这样的行业，随着电子支付的兴起，将来肯定不会需要这么多财务人员。"互联网+"从某个方面说，就是使用互联网技术取代一部分人力，更便宜地服务更多的顾客。
回到本文的题目，世界上有没有安全的工作？应该是有的吧，但真的不多。公务员可能比较安全，因为这个职业改变得比较缓慢，而且没有技术升级的压力。医生和律师，也比较安全，因为对于这些行业，经验很重要，但技术正在把它们的成本降下来。厨师和物流，也是比较安全的行业，因为技术再进步，也总需要人来做饭和送货，但是它们是纯粹的体力劳动，没有进入门槛，供给非常大，想拿到高工资不容易。
最终来说，人类社会的就业形态正在发生深刻的改变，"终生职业"越来越少了。每个人都应该尽早打算，如果明天你的职业消失了，你该怎么办？
版权声明：“并发编程网”所推送文章，除非确实无法确认，我们都会注明作者和来源。部分文章推送时未能与原作者取得联系。若涉及版权问题，烦请原作者联系我们，我们会在24小时内删除处理，谢谢！^_^18634795651
微信号：并发编程网 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b4c2cb305271f7cc5e8ea888665a4a9/" rel="bookmark">
			[UE4]鼠标左键右键不触发事件的原因
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		鼠标左键右键不触发事件的原因：Edit -&gt; Project Setting -&gt; Engine -&gt; Input -&gt; Mouse Properties，不勾选“use mouse for touch”
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4328ac70a576412cc297900894eb3dc/" rel="bookmark">
			Java算法---华为oj迷宫问题求解（广度优先搜索）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一万年太久，只争朝夕，只有坚持，才能胜利，经过昨天的努力，解决了广度优先算法实现迷宫问题，题目在这里不赘述，如果不知道题目的请看我的上一篇博客Java算法---华为oj迷宫问题求解，这里面说的很详细，下来就直奔主题，说说广度优先搜索。
一般谈起广搜，我的第一反应就是求最短路径，因为广搜是由内向外逐层扩散，最后肯定能找到一个最短的路径，其实用法也不难，我的这篇博客中也讲到了广搜，可以看下Java算法---求面积，今天说的广搜和之前的不同之处在于，之前求最短路径，最终只需给出一个数字表示最短的长度，而不需要输出具体的路径是什么，也就是怎么走，而今天的广搜是需要输出路径，要是谈起这个路径问题，我想大部分人可能觉得深搜比较好，的确，我也是这样觉得，但是我们要灵活运行多种方法去解决一个问题，下来说说具体的题目吧。
广搜的套路就是利用一个队列，每次将当前点的邻居节点加入队列，然后出队，在将当前点加入队列，一直讲所有路径搜索完毕，直到队列为空停止。同时还需要一个数组去保存该节点是否访问，做个标记。但是怎样输出路径呢，我采取的办法是每次我们需要保存一下当前节点的前驱节点，可以这样设计一个类保存当前坐标和前驱坐标：
&lt;span style="font-family:SimSun;font-size:18px;"&gt;&lt;span style="font-size:18px;"&gt;class Node{ int x; int y; int prex; int prey; }&lt;/span&gt;&lt;/span&gt; 这样最终我们可以通过前驱节点来输出整个的路径。具体怎样做请往下看，就拿迷宫问题给的样例来说吧，每次将所有出队的节点保存在一个arrayList中，最终arrayList中保存了所有出队的节点，我们怎样从这些节点确定一条路径呢？
输入 5 5 0 1 0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 1 0
arrayList中会保存13个节点，分别是
（0,0,0,0）
（1,0,0,0）
（2,0,1,0）
（3,0,2,0）
（2,1,2,0）
（4,0,3,0）
（2,2,2,1）
（4,1,4,0）
（2,3,2,2）
（4,2,4,1）
（2,4,2,3）
（3,4,2,4）
（4,4,3,4）
前两个坐标代表当前坐标位置，后两个代表前驱坐标位置，然后按照从目的节点往起始节点找路径，如下图：
这样最终找到了一条路径(0,0)（1,0)(2,0)(2,1)(2,2)(2,3)(2,4)(3,4)(4,4)，即是我们最终要求解的问题。这样广度搜索也实现了路径的问题，下来就是写代码了，具体怎么实现每个人都不一样，下面贴上我自己的代码：
&lt;span style="font-family:SimSun;"&gt;import java.util.*; /** * Created by Administrator on 2015/12/21.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b4328ac70a576412cc297900894eb3dc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/10f343e22dbdc86d51e3aa8ba67e0368/" rel="bookmark">
			JAVA修改excel的内容
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		package com.bestpay.bpbp.bill.init; /** * Created by Qj on 2015/08/17. */ import jxl.Workbook; import jxl.write.Label; import jxl.write.WritableSheet; import jxl.write.WritableWorkbook; import java.io.File; /** * Created by Qj on 2015/08/03. */ public class OutExcelDataForTestNG { private final File file = new File("E:\\add222.xls"); public void modifyExcel(int SheetNo, int lieshu, int hangshu, String value) { try { Workbook rwb = Workbook.getWorkbook(file); WritableWorkbook wwb = Workbook.createWorkbook(file, rwb);// copy WritableSheet ws = wwb.getSheet(SheetNo); Label labelCF = new Label(lieshu, hangshu, value); ws.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/10f343e22dbdc86d51e3aa8ba67e0368/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c78e7f29f3b6223649cc96aeeab37a89/" rel="bookmark">
			基因算法解决01背包问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		背包问题简述：
有m个物体，每个物体价值为v[i]，重量为w[i]，有一个背包，最多能盛重量为W的物体，
求背包能盛的最大的价值。
基因算法:
编码：编码长度为物体的个数，1表示放进包，0表示不放进包
适应度：包里物品的价值和
交叉：两个随机，采用多点交叉，交叉点的个数是随机的，交叉的位置是随机的
编译：同样两个随机
交叉概率：0.8
变异概率：0.15
个体类（一个个体就是问题的一个解）：
import java.util.Arrays; /** * 0 1背包中的个体，一个个体对应基因算法的一个解 * @author founder */ public class Individual { //基因序列，数组的大小为物体的个数，gene[i]=1表示选择，gene[i]=0表示不选择 public int[] gene;	public double fitness;	//个体的适应度 public double selectProbability;	//选择概率 public double accumulateProbability;	//累积的选择概率 public Individual(Individual ind){ this.gene = new int[ind.gene.length]; this.gene = Arrays.copyOf(ind.gene, ind.gene.length); this.fitness = ind.fitness; this.selectProbability = ind.selectProbability; this.accumulateProbability = ind.accumulateProbability; } public Individual(){ } } 全部代码如下，evaluate给出每个解的评估，crossover交叉操作，mutation编译操作，迭代次数为100，种群大小为50。
代码实现了两种选择算子，轮盘赌算法和二进制锦标赛算法
：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c78e7f29f3b6223649cc96aeeab37a89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2da3f2dda3dd700d5aa3058a2a38dd4c/" rel="bookmark">
			SQL语句order by两个字段同时排序问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可能对不少网友来说非常简单，但是我觉得在一定程度上对我还是有些迷惑之处，下面就通过hibernate中的HQL语句来介绍下这类问题的效果。
首先HQL语句代码：
FROM Topic t WHERE t.id &gt;2 ORDER BY t.type DESC,t.number DESC 也可以按照下面的写法：
FROM Topic t WHERE t.id &gt;2 ORDER BY t.type,t.number DESC 这行代码理解起来实际上是非常简单，首先查处topic表中id字段大于2的所有数据，然后对这些数据首先根据该表的type字段进行降序排序，然后再根据该表的number字段进行降序排序。下面就通过图片来简单介绍： 假设：t.id&gt;2查询后的数据为： 通过对t.type进行降序排序后结果为: 再通过对t.number进行降序排序后起初我认为的结果为： 然而最总的结果为： 所以不难发现其时最终执行的不但是两次排序，他是在保持满足对type排序的前提下再对number排序。
这就非常适用于论坛中“置顶贴”和“普通贴”排序功能的实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d049733ed0c32fd81a0a2f619991b46d/" rel="bookmark">
			WSADATA
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		WSAData结构体如下
功能是:存放windows socket初始化信息.
struct WSAData { WORD wVersion; WORD wHighVersion; char szDescription[WSADESCRIPTION_LEN+1]; char szSystemStatus[WSASYSSTATUS_LEN+1]; unsigned short iMaxSockets; unsigned short iMaxUdpDg; char FAR * lpVendorInfo; }; wVersion为你将使用的Winsock版本号， wHighVersion为载入的Winsock动态库支持的最高版本，注意，它们的高字节代表次版本，低字节代表主版本。 szDescription与szSystemStatus由特定版本的Winsock设置，实际上没有太大用处。 iMaxSockets表示最大数量的并发Sockets，其值依赖于可使用的硬件资源。 iMaxUdpDg表示数据报的最大长度;然而，获取数据报的最大长度，你需要使用WSAEnumProtocols对协议进行查询。 最大数量的并发Sockets并不是什么神奇的数字,它是由可用的物理资源来决定的. lpVendorInfo是为Winsock实现而保留的制造商信息,这个在Windows平台上并没有什么用处. 转载于:https://www.cnblogs.com/myidea/p/5057187.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b7d82c73e86011051cbd67916f19e7c9/" rel="bookmark">
			UIScrollView的滚动，停止(UIScrollViewDelegate)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在使用UIScrollView和它的子类UITableView时，有时需要在不同操作状态下，做不同的响应。
如何截获这些状态，如正在滚动，滚动停止等，使用UIScrollViewDelegate_Protocol。
@interface SampleClass: UITableViewController&lt;UIScrollViewDelegate&gt; {
... }
... @end @implement SampleClass ... #pragma mark - #pragma mark UIScrollViewDelegate // 触摸屏幕来滚动画面还是其他的方法使得画面滚动，皆触发该函数 - (void)scrollViewDidScroll:(UIScrollView *)scrollView { NSLog(@"Scrolling..."); } // 触摸屏幕并拖拽画面，再松开，最后停止时，触发该函数 - (void)scrollViewDidEndDragging:(UIScrollView *)scrollView willDecelerate:(BOOL)decelerate { NSLog(@"scrollViewDidEndDragging - End of Scrolling."); } // 滚动停止时，触发该函数
- (void)scrollViewDidEndDecelerating:(UIScrollView *)scrollView { NSLog(@"scrollViewDidEndDecelerating - End of Scrolling."); } // 调用以下函数，来自动滚动到想要的位置，此过程中设置有动画效果，停止时，触发该函数
// UIScrollView的setContentOffset:animated: // UIScrollView的scrollRectToVisible:animated:
// UITableView的scrollToRowAtIndexPath:atScrollPosition:animated:
// UITableView的selectRowAtIndexPath:animated:scrollPosition:
- (void)scrollViewDidEndScrollin gAnimation :(UIScrollView *)scrollView { NSLog(@"scrollViewDidEndScrollin gAnimation - End of Scrolling.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b7d82c73e86011051cbd67916f19e7c9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/114f20265e6c929d1882d13a9d3400ea/" rel="bookmark">
			Mysql的索引类型和创建方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		FULLTEXT 全文索引，只有MyISAM引擎支持这种索引类型，而且只能作用在CHAR、VARCHAR ，TEXT 列上。 创建： ALTER TABLE table ADD INDEX FULLINDEX USING FULLTEXT(cname1[,cname2…]);
使用： SELECT * FROM table WHERE MATCH(cname1[,cname2…]) AGAINST (‘word’ MODE );
其中， MODE为搜寻方式（IN BOOLEAN MODE ，IN NATURAL LANGUAGE MODE ，IN NATURAL LANGUAGE MODE | WITH QUERY EXPANSION）。 搜寻方式注解： 布尔模式（IN BOOLEAN MODE ），允许word里含一些特殊字符用于标记一些具体的要求，如+表示一定要有，-表示一定没有，*表示通用匹配符，类似正则； 自然语言模式（IN NATURAL LANGUAGE MODE），就是简单的单词匹配； 含表达式的自然语言模式（IN NATURAL LANGUAGE MODE WITH QUERY EXPANSION），就是先用自然语言模式处理，对返回的结果，再进行表达式匹配。
FULLTEXT索引也是按照分词原理建立索引的。西文中，分词可以很方便的按照空格进行分割。中文不能按照这种方式进行分词，要使用Mysql的中文分词插件Mysqlcft，当然还有其他的分词插件可以使用。
HASH hash就是一种（key=&gt;value）形式的键值对，如数学中的函数映射，允许多个key对应相同的value，但不允许一个key对应多个value。适合重复值相对较少的列，同时只能对EMORY/HEAP引擎起作用。 （1）Hash 索引仅仅能满足”=”,”IN”和”&lt;=&gt;”查询，不能使用范围查询。 （2）Hash 索引无法被用来避免数据的排序操作。 （3）Hash 索引不能利用部分索引键查询。也就是建立的组合索引一定要全部字段用上才起效果。 （4）Hash 索引在任何时候都不能避免表扫描。 （5）Hash 索引遇到大量Hash值相等的情况后性能并不一定就会比B-Tree索引高。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/114f20265e6c929d1882d13a9d3400ea/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24519b50b29f1e1b51d2e6c8704956d5/" rel="bookmark">
			前端开发入门：html和css基础知识回顾
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前端入门：零基础：前端基本技能，web开发基础(html+css+javascript)、学习方法、学习资料；兴趣：web技术（html+css网页制作）、ps技能、前端自动化工具、前端架构、前端MVVM、MVC、MV*框架和设计模式、各种调试web抓包工具、移动设备web调试工具、浏览器工作原理、前端安全规范和防护。
1. 文件结构：
HTML用什么写和什么读？建议用火狐和谷歌浏览器，符合W3C的标准。编辑我们可以用sublime Text或文本、UE、EditPlus、Notepad等文本编辑器书写。调试可以用 FireFox+Firebug插件或者谷歌插件进行调试代码。
3种文本类型DocType：（1）Strict(严格)；（2）Tranditional（传统）;（3）FrameSet（框架）
HTML文件的固定结构： &lt;html&gt; &lt;head&gt;...&lt;/head&gt; &lt;body&gt;...&lt;/body&gt; &lt;/html&gt; html是根标签， head定义文档头部，包含： title, script, style, link, meta body是网页主要内容，包含：h1,h2-h6, p, a, img 2. 认识head标签： &lt;head&gt; &lt;title&gt;...&lt;/title&gt; 网页标题 &lt;meta&gt; &lt;link&gt; &lt;style&gt;...&lt;/style&gt; &lt;script&gt;...&lt;/script&gt; &lt;/head&gt; 3. 语义化： 明白每个标签的用途（在什么情况下我可以使用这个标签才合理） 比如，网页上的文章的标题就可以用标题标签， 网页上的各个栏目的栏目名称也可以使用标题标签。 文章中内容的段落就得放在段落标签中，在文章中有想强调的文本，就可以使用em标签表示强调等等。 4. 认识body标签：
&lt;center&gt;中心&lt;/center&gt; 中心标签
&lt;p&gt;段落文本&lt;/p&gt; 有三段就放三个&lt;p&gt;&lt;/p&gt;
&lt;h1&gt;标题文本&lt;/h1&gt; h1-h6共6个标题分级 &lt;em&gt;斜体文本（强调）&lt;/em&gt; 斜体文本内容 &lt;strong&gt;粗体文本&lt;/strong&gt; 粗体显示文本内容 &lt;span&gt;单独样式文本&lt;/span&gt; 没有语义的，它的应用就是为了 设置单独的格式用的 &lt;q&gt;引用的文本&lt;/q&gt; 引用的文本内容，会自动加上双引号
&lt;marquee&gt;滚动效果&lt;/marquee&gt; 引用的文本文字、图片滚动效果
&lt;blockquote&gt;大段引用&lt;/blockquote&gt; 引用大段的文本内容，文本前后会加上缩进 &lt;br/&gt; 换行 &lt;hr/&gt; 水平横线 &amp;nbsp; 空格 &lt;address&gt;地址信息&lt;/address&gt; 地址信息，通常用于公司地址显示 &lt;code&gt;代码内容&lt;/code&gt; 代码，通常是一行内 &lt;pre&gt;多行代码&lt;/pre&gt; 多行代码,你需要在网页中预显示格式时都可以使用它 &lt;ul&gt; ul-li 列表信息，以圆点显示（无序列表） &lt;li&gt;信息1&lt;/li&gt; &lt;li&gt;信息2&lt;/li&gt; .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/24519b50b29f1e1b51d2e6c8704956d5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/da9a07f3cc0c1c31ee94aa3271fdd9ec/" rel="bookmark">
			jQuery遍历之next()、nextAll()方法使用实例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jquery遍历：next()和nextAll()方法。实例如下：
复制代码 代码如下: &lt;html&gt;
&lt;head&gt;
&lt;script type="text/javascript" src="jquery-1.8.2.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
$(document).ready(function(){
//$("div").click(function(){alert($(this).next().text());});
//$("div").click(function(){alert($(this).nextAll().text());});
$("div").click(function(){alert($(this).nextAll("div").text());});
});
&lt;/script&gt;
&lt;style type="text/css"&gt;
div{width:300px;height:30px;background:green;margin-top:10px;}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id="uu"&gt;您好，&lt;font color="blue"&gt;美女&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;hello,world&lt;/div&gt;
&lt;div&gt;美女，亲一下&lt;/div&gt;
&lt;p&gt;我是p标签&lt;/p&gt;
&lt;div&gt;&lt;span&gt;我很帅，有图有真相&lt;/span&gt;&lt;/div&gt;
&lt;p&gt;我也是p标签&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
说明：
（1）next()方法：是指获得匹配元素的相邻同同辈元素（即下一个同辈元素），注意，同辈元素并不是标签相同的元素，而是指该元素闭合后的下一个元素，如实例中的”&lt;div&gt;美女，亲一下&lt;/div&gt;“，div闭合后的下一个元素为&lt;p&gt;。
（2）如果next()加上参数，即next("div")，如果下一个相邻元素不是div，则为空，即一定是相邻的。
（3）nextAll()方法：指获得匹配元素之后所有的同辈元素。它同样可以加上参数，nextAll("p")或nextAll("div")等等。
（4）有些奇怪的是，如果是这样的代码：
复制代码 代码如下: $("div").click(function(){alert($(this).nextAll("div").html());}); 它并不能获得所有的html内容，而只是获得下一个同辈元素的html内容。？？？疑惑
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/287dd59fdf4aa26ddf047851e0ab8bc7/" rel="bookmark">
			Nginx的负载均衡 - 一致性哈希 (Consistent Hash)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Nginx版本：1.9.1
我的博客：http://blog.csdn.net/zhangskd
算法介绍
当后端是缓存服务器时，经常使用一致性哈希算法来进行负载均衡。
使用一致性哈希的好处在于，增减集群的缓存服务器时，只有少量的缓存会失效，回源量较小。
在nginx+ats / haproxy+squid等CDN架构中，nginx/haproxy所使用的负载均衡算法便是一致性哈希。
我们举个例子来说明一致性哈希的好处。
假设后端集群包含三台缓存服务器，A、B、C。
请求r1、r2落在A上。
请求r3、r4落在B上。
请求r5、r6落在C上。
使用一致性哈希时，当缓存服务器B宕机时，r1/r2会仍然落在A上，r5/r6会仍然落在C上，
也就是说这两台服务器上的缓存都不会失效。r3/r4会被重新分配给A或者C，并产生回源。
使用其它算法，当缓存服务器B宕机时，r1/r2不再落在A上，r5/r6不再落在C上了。
也就是说A、B、C上的缓存都失效了，所有的请求都要回源。
这里不介绍一致性哈希算法的基本原理，如果不了解，先花个10分钟看下这篇文章：
http://www.codeproject.com/Articles/56138/Consistent-hashing
在分析模块代码之前，先来看下nginx所实现的一致性哈希算法。
1. 初始化upstream块
主要工作是创建和初始化真实节点、创建和初始化虚拟节点。
其中真实节点是使用round robin的方法创建的。
Q：总共有多少个虚拟节点，一个真实节点对应多少个虚拟节点？
累加真实节点的权重，算出总的权重值total_weight，虚拟节点的个数一般为total_weight * 160。
一个权重为weight的真实节点，对应的虚拟节点数为weight * 160。
Q：对于每一个真实节点，是如何创建其对应的虚拟节点的？
1. 真实节点的server成员是其server指令的第一个参数，首先把它解析为HOST和PORT。
base_hash = crc32(HOST 0 PORT)
一个真实节点对应weight * 160个虚拟节点，对于每个虚拟节点来说，base_hash都是一样的。
2. 为了使每个虚拟节点的hash值都不同，又引入了PREV_HASH，它是上一个虚拟节点的hash值。
hash = crc32(base_hash PREV_HASH)
3. 虚拟节点的server成员，指向真实节点的server成员。如此一来，通过比较虚拟节点和真实节点的
server成员是否相同，可以判断它们是否是相对应的。
创建和初始化好虚拟节点数组后，对其中的虚拟节点按照hash值进行排序，对于hash值相同的虚拟节点，只保留第一个。
经过上述步骤，我们得到一个所有虚拟节点组成的数组，其元素的hash值有序而不重复。也就是说，ring建立起来了。
2. 初始话请求的负载均衡数据
根据hash指令第一个参数的实时值KEY，KEY一般是$host$uri之类的，计算出本次请求的哈希值。
hash = crc32(KEY)
根据请求的哈希值，在虚拟节点数组中，找到“顺时针方向”最近的一个虚拟节点，其索引为i。
什么叫顺时针方向最近？就是point[i - 1].hash &lt; hash &lt;= point[i].hash。
本次请求就落在该虚拟节点上了，之后交由其对应的真实节点来处理。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/287dd59fdf4aa26ddf047851e0ab8bc7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/513fbedfd067e044678124e29edab9b2/" rel="bookmark">
			尾递归
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 普通的线性递归堆栈耗用大，比尾递归更加消耗资源，不过两者效率差不多。。。 举个栗子：递归求n的阶乘 1*2*...*n
// 普通线性递归 function recursive($n) { if ($n &gt; 1) return recursive($n-1) * $n; else return 1; } // 尾递归，s代表乘积 function tailRecursive($n, $s = 1) { if ($n &gt; 1) return tailRecursive($n-1, $s * $n); else return $s; } recursive(5); tailRecursive(5); // 递归过程 --- 线性递归过程： recursive(5) {5 * recursive(4)} {5 * {4 * recursive(3)}} {5 * {4 * {3 * recursive(2)}}} {5 * {4 * {3 * {2 * recursive(1)}}}} {5 * {4 * {3 * {2 * 1}}}} {5 * {4 * {3 * 2}}} {5 * {4 * 6}} {5 * 24} 120 --- 尾递归过程： tailRecursive(5) tailRecursive(4, 5) tailRecursive(3, 20) tailRecursive(2, 60) tailRecursive(1, 120) 120 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7161ac9940560255b969b41c5bad8d2a/" rel="bookmark">
			安卓libStagefright高危漏洞分析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		-序- 本周早些时候, 国外安全公司Zimperium爆出多处Android系统漏洞, 瞬间占据各大媒体头条. 号称一条彩信即可控制手机, 影响范围从Android 2.2到5.1通杀, 号称Android上的”心脏滴血”. 本着不放过任何漏洞细节的原则, 扒了一下相关信息. 要做这篇分析报告的时候, 一开始是拒绝的, 后来各种夸张新闻刷屏, 真的有这么恐怖吗? -漏洞信息初探- 根据原博文指出, 漏洞细节将在下月初的Black Hat以及DEFCON上公布, 但提到了[CVE-2015-1538,CVE-2015-1539,CVE-2015-3824,CVE-2015-3826,CVE-2015-3827,CVE-2015-3828,CVE-2015-3829], 搜索CVE后发现状态都是reserved. 看来除了文中提到的Stagefright, 彩信是不会有太多可用信息了, 好在搜到著名Android第三方ROM CyanogenMod发布的信息, 从中得知CM团队已在前几周修复了该漏洞, 用户可以使用nightly build的版本. 顺藤摸瓜, 前往CM的codereview一探究竟. 顺利从包含libstagefright代码的frameworks/av历史中找到了相关修复信息.
-漏洞影响分析- 根据CM的漏洞修复信息得知受害者为由于会调用libstagefright.so的/system/bin/mediaserver. 根据修复commit说明, 得知漏洞大致是解析mp4格式视频存在溢出或越界.
service media /system/bin/mediaserver class main user media group audio camera inet net_bt net_bt_admin net_bw_acct drmrpc mediadrm ioprio rt 4
从init脚本来看, mediaserver所在用户组权限还蛮高, 可以访问网络, 访问手机存储, 访问摄像头等等权限. 那么又有哪些app会去调用libstagefright库从而触发漏洞呢?
00001. 1. 首先漏洞原文提到彩信, 如果攻击者构造恶意的视频, 通过自动下载彩信后触发解析溢出. 那么真如原文所说一条彩信就能拿下机器.
00002. 00003. 2. 另外如果用户从不明网址下载恶意的视频到sdcard上, 再通过文件管理浏览时, 由于文件管理会解析视频文件得到缩略图, 这个时候也会触发漏洞, 图库应用同理.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7161ac9940560255b969b41c5bad8d2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/18d00adc5f9b0bd9ba1888bdb53552b8/" rel="bookmark">
			IDEA打jar包时出现manifest.mf already exists in vfs解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.什么是MANIFEST.MF
下面MANIFEST.MF的介绍来自百度百科http://baike.baidu.com/link?url=QQ97CnYdkb0RqF33qFh9XiRfF_2NGW_RsZned0F9yC_JVvaayEFVciKj2OFYb7DXaKPr1_BkW-MjSXCqGodN0_
打开Java的JAR文件我们经常可以看到文件中包含着一个META-INF目录，这个目录下会有一些文件，其中必有一个MANIFEST.MF，这个文件描述了该Jar文件的很多信息，下面将详细介绍MANIFEST.MF文件的内容，先来看struts.jar中包含的MANIFEST.MF文件内容： Manifest-Version: 1.0 Created-By: Apache Ant 1.5.1 Extension-Name: Struts Framework Specification-Title: Struts Framework Specification-Vendor: Apache Software Foundation Specification-Version: 1.1 Implementation-Title: Struts Framework Implementation-Vendor: Apache Software Foundation Implementation-Vendor-Id: org.apache Implementation-Version: 1.1 Class-Path: commons-beanutils.jar commons-collections.jar commons-digester.jar commons-logging.jar commons-validator.jar jakarta-oro.jar struts-legacy.jar 如果我们把MANIFEST中的配置信息进行分类，可以归纳出下面几个大类： 一. 一般属性 1. Manifest-Version 用来定义manifest文件的版本，例如：Manifest-Version: 1.0 2. Created-By 声明该文件的生成者，一般该属性是由jar命令行工具生成的，例如：Created-By: Apache Ant 1.5.1 3. Signature-Version 定义jar文件的签名版本 4. Class-Path 应用程序或者类装载器使用该值来构建内部的类搜索路径 二. 应用程序相关属性 1. Main-Class 定义jar文件的入口类，该类必须是一个可执行的类，一旦定义了该属性即可通过 java -jar x.jar来运行该jar文件。 三. 小程序(Applet)相关属性 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/18d00adc5f9b0bd9ba1888bdb53552b8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/20149c2ec656529b2ea6471531f47fc7/" rel="bookmark">
			嵌入式audio基础（一）接口
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		audio接口不少，这里就做一个总结介绍。
最常见的３.5mm
衍生出来6.25mm 6.3mm和2.5mm接口
２.5mm接口相对于３.5mm有点就是尺寸小，一些mp3等便携超薄设备上经常使用，缺点就是接触面积小导致噪声比较大。6.25mm和6.3mm的个他正好相反，主要用与一些音响的接口上。
ＸＬＲ
XLR 是由James H. Cannon, 于美国加州洛杉矶所成立的 Cannon 电气公司所发明
可以快速的拔插,且具有锁定 三针形式可以满足平衡式的传输 可靠的强度满足了相对恶劣的环境,平衡理解主要是基于运放，，平衡式放大由于每个放大器的电流方向相反，弥补了电源电压的波动，使得供电更加稳定。由于电源内阻造成的分离度的影响可以得到有效的抑制，因而声场更为开阔，背景更为纯净。
RCA
RCA插头最早发明于美国无线电公司（Radio Corporation of America）
右声道用红色（或者用字母“R”表示“右”）；左声道用黑色或白色。有的时候，中置和环绕声道连接线会用其他的颜色标注来方便接线时区分，但整个系统中所有的RCA接头在电气性能上都是一样的。一般来讲，RCA立体声音频线都是左右声道为一组，每声道外观上是一根线。
通常都是成对的白色的音频接口和黄色的视频接口。通常采用RCA（俗称莲花头）进行连接，使用时只需要将带莲花头的标准AV 线缆与相应接口连接起来即可.
RCA接口是典型的非平衡接口，他们公用一路地，每路有一路的放大器进行信号放大。但是由于结构简单可以进行高功率的传输，一般用于大功率的音响链接。
BNC
BNC接头，是一种用于同轴电缆的连接器，全称是Bayonet Nut Connector（卡扣配合型连接器，这个名称形象地描述了这种接头外形），又称为British Naval Connector。
British Naval Connector（英国海军连接器，可能是英国海军最早使用这种接头）或Bayonet Neill Conselman（Designer：Paul Neill, Carl Concelman,&amp; Octavio M. Salati）是一种很常见的RF端子同轴电缆终结器。BNC接口即常说的细同轴电缆接口。BNC接口可以隔绝视频输入信号，使信号间互相干扰减少，且信号带宽要比普通15针的D型接口大，可达到更佳的信号响应效果
这中接口一个很到的好处是不易脱落，用于同轴视频传输较多，音频上应用也就主要实在室外露天场所使用。
其他的接口就更加不常用了，例如
光纤
usb
db９
这些接口的主要功能都不是用于音频信号的传输，但是都可以用来进行特殊场景下的音频传输。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41ad752428764fe888116e12dfd7bc1b/" rel="bookmark">
			Android中获取apk安装包信息的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、获取安装包信息
复制代码代码如下: /** * 获取apk包的信息：版本号，名称，图标等 * @param absPath apk包的绝对路径 * @param context */ public void apkInfo(String absPath,Context context) { PackageManager pm = context.getPackageManager(); PackageInfo pkgInfo = pm.getPackageArchiveInfo(absPath,PackageManager.GET_ACTIVITIES); if (pkgInfo != null) { ApplicationInfo appInfo = pkgInfo.applicationInfo; /* 必须加这两句，不然下面icon获取是default icon而不是应用包的icon */ appInfo.sourceDir = absPath; appInfo.publicSourceDir = absPath; String appName = pm.getApplicationLabel(appInfo).toString();// 得到应用名 String packageName = appInfo.packageName; // 得到包名 String version = pkgInfo.versionName; // 得到版本信息 /* icon1和icon2其实是一样的 */ Drawable icon1 = pm.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/41ad752428764fe888116e12dfd7bc1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/179524a923efae471f329180624e577c/" rel="bookmark">
			MySQL 5.7 新特性解读
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2015年10月22日，MySQL发布5.7.9稳定版，虽然MySQL官方手册里已经有很多关于MySQL 5.7新特性的介绍，在这里，还是让我们一起看看在MySQL 5.7里有哪些值得我们关注的新特性吧。
1、安全性 用户表mysql.user的plugin字段不允许为空，默认值是mysql_native_password，而不是mysql_old_password，不再支持旧密码格式； 增加密码过期机制，过期后需要修改密码，否则可能会被禁用，或者进入沙箱模式； 使用mysql_install_db初始化时，默认会自动生成随机密码，并且不创建除root@localhost 外的其他账号，也不创建test库； 在5.7中，推荐使用mysqld –initialize对数据库进行初始化，在初始化时如果加上–initial-insecure，则会创建空密码的 root@localhost 账号，否则会创建带密码的 root@localhost 账号，密码直接写在 log-error 日志文件中（在5.6中是放在~/.mysql_secret里）； 在5.7中可以对普通用户进行unlock及lock操作。 2、增强了InnoDB引擎的一些功能 优化了DDL操作，在涉及到InnoDB临时表时，性能显著提升； 在5.6及以前，InnoDB临时表的元数据存储在InnoDB系统表里，在5.7中，临时表的信息及元数据都存储在新多出来的表INNODB_TEMP_TABLE_INFO中； 在5.7中，InnoDB临时表会存储在一个非压缩的、单独的表空间中，每次启动MySQL服务，都会自动创建该表空间，默认存储在DATADIR下，其路径由参数innodb_temp_data_file_path指定； 支持在线（INPLACE）增加VARCHAR列的长度。不过0-255长度是一个区间，256以上是另一个区间，不能跨越255这个坎，比如把长度从100扩展成1000（因为255长度以内额外用1个字节表示，大于255长度则需要额外2个字节表示）； 不支持在线缩小VARCHAR的长度 ； 支持innodb_page_cleaners选项可设置多个page cleaner线程提高脏页刷新效率 ； 可通过设置innodb_undo_log_truncate等选项自动删除不用的undo log ； 加强InnoDB read-only模式的性能 ； 在5.7中，可以创建一个普通的表空间： CREATE TABLESPACE tablespace_name ADD DATAFILE ‘file_name.ibd’ [FILE_BLOCK_SIZE = n] 3、SQL_MODE 默认启用STRICT_TRANS_TABLES模式； 对ONLY_FULL_GROUP_BY模式实现了更复杂的特性支持，并且也被默认启用； 其他被默认启用的sql mode还有NO_ENGINE_SUBSTITUTION。 在5.6中对一个10字符长度的VARCHAR列写入15个字符，会自动截断并给出告警，而在5.7，则直接抛出错误了。 4、优化online操作，例如修改buffer pool、修改索引名（非主键）、修改REPLICATION FILTER、修改MASTER而无需关闭SLAVE线程等众多特性。 5、在5.7中，可以在INFORMATION_SCHEMA里面的表中查看MySQL的系统参数 6、支持一个表上有多个触发器，这样一来，原先已有触发器表也可以支持用pt-osc 了 7、支持对在线某个连接直接查看执行计划，比如EXPLAIN FOR CONNECTION 1024 8、新增log_syslog选项，可将MySQL日志打印到系统日志文件中 9、在MySQL 5.6以前，在客户端CTRL+C后会直接退出啊MySQL客户端，这一点比较恶心，在5.7以后不会退出客户端而是终端当前的操作 10、新增一个比较好的功能，就是在CREATE | ALTER TABLE时，可以在某张表已有列的基础上，对新增的列进行运算： CREATE TABLE triangle ( sidea DOUBLE, sideb DOUBLE, sidec DOUBLE AS (SQRT(sidea * sidea + sideb * sideb)) ); INSERT INTO triangle (sidea, sideb) VALUES(1,1),(3,4),(6,8); mysql&gt; SELECT * FROM triangle; +——-+——-+——————–+ | sidea | sideb | sidec | +——-+——-+——————–+ | 1 | 1 | 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/179524a923efae471f329180624e577c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/543ac79f2ad1e2dae59f67eb7495b68d/" rel="bookmark">
			Linux网络流量控制工具—Netem（可用于网络故障注入）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux网络流量控制工具—Netem（可用于网络故障注入）
第一篇：概念篇
Netem 是 Linux 2.6 及以上内核版本提供的一个网络模拟功能模块。该功能模块可以用来在性能良好的局域网中，模拟出复杂的互联网传输性能，诸如低带宽、传输延迟、丢包等等情况。使用 Linux 2.6 (或以上) 版本内核的很多发行版 Linux 都开启了该内核功能，比如Fedora、Ubuntu、Redhat、OpenSuse、CentOS、Debian等等。
tc 是 Linux 系统中的一个工具，全名为traffic control（流量控制）。tc 可以用来控制 netem 的工作模式，也就是说，如果想使用 netem ，需要至少两个条件，一个是内核中的 netem 功能被包含，另一个是要有 tc 。
特别注意：本文介绍的内容主要倾向于利用tc工具的发包控制，来实现网络故障部分的注入实现，对于网络流控的介绍相对较少，详细的内容大家可以参考如下网址进行深入了解：
http://www.linuxfoundation.org/collaborate/workgroups/networking /netem#Delay_distribution
第二篇：原理篇
TC用于Linux内核的流量控制，主要是通过在输出端口处建立一个队列来实现流量控制。
TC是一个可以根据数据包的任何一个部分的特征对其进行分类的工具，并且可以为各类数据提供不同带宽，从而控制他们的传输速度。TC是iproute2的一部分，集成在2.2.及以上版本的内核中，还可以与linux内核里的各种架构（如Netfilter netem）协同工作。
接收包从输入接口（Input Interface）进来后，经过流量限制（Ingress Policing）丢弃不符合规定的数据包，由输入多路分配器（Input De-Multiplexing）进行判断选择：如果接收包的目的是本主机，那么将该包送给上层处理；否则需要进行转发，将接收包交到转发块（Forwarding Block）处理。转发块同时也接收本主机上层（TCP、UDP等）产生的包。转发块通过查看路由表，决定所处理包的下一跳。然后，对包进行排列以便将它们传送到输出接口（Output Interface）。一般我们只能限制网卡发送的数据包，不能限制网卡接收的数据包，所以我们可以通过改变发送次序来控制传输速率。Linux流量控制主要是在输出接口排列时进行处理和实现的。 第三篇：应用篇
工具可完成如下功能：（故障模拟）
模拟时延，丢包，重复包，乱序。
1、模拟延迟传输
# tc qdisc add dev eth0 root netem delay 100ms
该命令将 eth0 网卡的传输设置为延迟100毫秒发送。 更真实的情况下，延迟值不会这么精确，会有一定的波动，我们可以用下面的情况来模拟出带有波动性的延迟值： # tc qdisc add dev eth0 root netem delay 100ms 10ms 该命令将 eth0 网卡的传输设置为延迟 100ms ± 10ms （90 ~ 110 ms 之间的任意值）发送。 还可以更进一步加强这种波动的随机性：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/543ac79f2ad1e2dae59f67eb7495b68d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42820955f35e4ffe5d8e94d332b6135e/" rel="bookmark">
			C&#43;&#43;11的enum class &amp; enum struct和enum
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C++标准文档——n2347（学习笔记） 链接：http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2007/n2347.pdf
旧版enum存在的问题 1 问题1向整形的隐式转换2 问题2无法指定底层所使用的数据类型3 问题3enum的作用域4 不同编译器解决该问题的方法不统一 enum class 和 enum struct 1 enum class 和 enum struct 是等价的2 声明3 类型转换4 指定底层数据类型underlying type5 域 C11enum的一些新特点转载请注明出处 1. 旧版enum存在的问题 问题描述1向整形的隐式转换(Implicit conversion to an integer)2无法指定底层所使用的数据类型(Inability to specify underlying type)3enum的作用域(Scope)4不同编译器解决该问题的方法不统一 1.1 问题1：向整形的隐式转换 在开始这个问题之前，我们需要知道什么是整形提升
查看之前的博文：C\C++中的整形提升
在看完什么是整形提升之后，我们开始这个问题：
旧版enum其实并不具有非常完全的类型安全（当然它也体现了一定的类型安全：1.禁止不同枚举体之间的赋值 2.禁止整形向枚举体的隐式转换等），也就是面对整形提升，旧版enum是没有抗拒力的。
例如：
#include &lt;iostream&gt; enum colorA{redA,greenA,grayA}; enum colorB {redB,greenB,yellowB}; void test(int data) { std::cout &lt;&lt; "test called" &lt;&lt; std::endl; } int main() { colorA ca(redA); colorB cb(greenB); //ca = cb; ERROR , 无法从“colorB”转换为“colorA” //ca = 2; ERROR , 无法从“int”转换为“colorA” bool res(ca &lt; cb); //OK std::cout &lt;&lt; std::boolalpha &lt;&lt; res &lt;&lt; std::endl; test(ca); //OK std::cin.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42820955f35e4ffe5d8e94d332b6135e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbbc93a164850bbda0f35c7bff7786bc/" rel="bookmark">
			java 注解的几大作用及使用方法详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.tmser.com/?post=34&amp;page=1
java 注解，从名字上看是注释，解释。但功能却不仅仅是注释那么简单。注解（Annotation） 为我们在代码中添加信息提供了一种形式化的方法，是我们可以在稍后某个时刻方便地使用这些数据（通过 解析注解 来使用这些数据），常见的作用有以下几种：
生成文档。这是最常见的，也是java 最早提供的注解。常用的有@see @param @return 等跟踪代码依赖性，实现替代配置文件功能。比较常见的是spring 2.5 开始的基于注解配置。作用就是减少配置。现在的框架基本都使用了这种配置来减少配置文件的数量。也是在编译时进行格式检查。如@Override 放在方法前，如果你这个方法并不是覆盖了超类方法，则编译时就能检查出。 包 java.lang.annotation 中包含所有定义自定义注解所需用到的原注解和接口。如接口 java.lang.annotation.Annotation 是所有注解继承的接口,并且是自动继承，不需要定义时指定，类似于所有类都自动继承Object。
该包同时定义了四个元注解，Documented,Inherited,Target(作用范围，方法，属性，构造方法等),Retention(生命范围，源代码，class,runtime)。下面将在实例中逐个讲解他们的作用，及使用方法。
Inherited : 在您定义注解后并使用于程序代码上时，预设上父类别中的注解并不会被继承至子类别中，您可以在定义注解时加上java.lang.annotation.Inherited 限定的Annotation，这让您定义的Annotation型别被继承下来。注意注解继承只针对class 级别注解有效（这段建议看完全文后在来回顾）。 多说无益，下面就一步步从零开始建一个我们自己的注解。
建第一个注解
package com.tmser.annotation; /** *@interface 用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。 *方法的名称就是参数的名称，返回值类型就是参数的类型。 *可以通过default来声明参数的默认值。 *在这里可以看到@Retention和@Target这样的元注解，用来声明注解本身的行为。 *@Retention 用来声明注解的保留策略，有CLASS、RUNTIME和SOURCE这三种， *分别表示注解保存在类文件、JVM运行时刻和源代码中。 *只有当声明为RUNTIME的时候，才能够在运行时刻通过反射API来获取到注解的信息。 *@Target 用来声明注解可以被添加在哪些类型的元素上，如类型、方法和域等。 *就可以定义一个注解了，它将自动继承Annotation */ public @interface TestA { //这里定义了一个空的注解，它能干什么呢。我也不知道，但他能用。 } 在下面这个程序中使用它
package com.tmser.annotation; import java.util.HashMap; import java.util.Map; /** * 这个类专门用来测试注解使用 * @author tmser */ @TestA //使用了类注解 public class UserAnnotation { @TestA //使用了类成员注解 private Integer age; @TestA //使用了构造方法注解 public UserAnnotation(){ } @TestA //使用了类方法注解 public void a(){ @TestA //使用了局部变量注解 Map m = new HashMap(0); } public void b(@TestA Integer a){ //使用了方法参数注解 } } 编译没有报错，ok，一个注解实验完成。这个注解也太简单了吧，好像什么信息也不能传递。别急下面就来一步步完善它，也该四位元注解依次开始上场了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbbc93a164850bbda0f35c7bff7786bc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f92f518c37ad8357423e10586929880f/" rel="bookmark">
			获取CheckedListBox选中的项
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 string SelectValues = ""; for (int i = 0; i &lt; checkedListBox1.Items.Count; i++) { if (checkedListBox1.GetItemChecked(i)) { //方法一 this.checkedListBox1.SetSelected(i, true); SelectValues += checkedListBox1.SelectedValue + ";"; //方法二 DataRowView rv = (DataRowView)checkedListBox1.Items[i]; Console.WriteLine(rv.Row[1]); } } MessageBox.Show("你选择了" + SelectValues); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05634cfa600473df0722b87e0dd76a65/" rel="bookmark">
			3D中的OBJ文件格式详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		http://www.cnblogs.com/slysky/p/4081307.html
常见到的*.obj文件有两种：第一种是基于COFF(Common Object File Format)格式的OBJ文件(也称目标文件)，这种格式用于编译应用程序；第二种是Alias|Wavefront公司推出的OBJ模型文件。本文对第二种obj模型文件进行分析。
3D文件格式，常见的有几种 "*.3ds"，"*.max"，"*.lw"，"*.mb"，"*.dxf"，"*.obj"。但是，OBJ文件的具体特征，却很少有人能给出较为圆满的描述。很多人认识OBJ文件是从使用Poser开始的，Poser是一款人体建模软件，要把Poser生成的人体导出到其它3D软件中进行再加工，就用到了OBJ文件。OBJ文件是一种标准的3D模型文件格式，很适合用于3D软件模型之间的互导。比如在3dsMax或LightWave中建了一个模型，想把它调到Maya里面渲染或动画，导出OBJ文件就是一种很好的选择。目前几乎所有知名的3D软件都支持OBJ文件的读写，不过很多软件需要通过插件才能做到这一点。 另外，作为一种优秀的文件格式，很多游戏引擎也都支持OBJ文件的读取。 3D软件模型之间的互导是一件很常见的事情，不幸的是，目前的3D软件模型导出功能都不那么完美，经常会出现缺面少线的情况，有时还会遇到导出的模型根本打不开的情况。
OBJ文件是一种文本文件格式，比起二进制文件为主、连每个块的用途也得试探来试探去的3DS，文本文件为主的OBJ对我们更友好。与3DS文件的树状[块结构]不同，OBJ文件只是很单纯的字典状结构，没有块ID来表征名字而是简单地用易懂的表意字符来表示。总之看上去是赏心悦目的样子，而苦处也就只有实际写导入代码的时候才知道了- -。OBJ文件优化了存储但劣化了读写。
如果Maya自身的模型出错，也可以先转成OBJ格式，修改之后再导回Maya。
OBJ文件 -- 概念
OBJ文件是Wavefront公司为它的一套基于工作站的3D建模和动画软件"Advanced Visualizer"开发的一种文件格式，这种格式同样也以通过Maya读写。
OBJ文件是一种文本文件，可以直接用写字板打开进行查看和编辑修改。
另外，有一种与此相关二进制文件格式(使用".MOD"后缀)，二进制格式作为专利未公开，因此在这里我们不作讨论。
OBJ最近的有文档的版本是v3.0，代替以前的v2.11版本。
OBJ3.0格式支持多边形(Polygon)，直线(Lines)，表面(Surfaces)，和自由形态曲线(Free-form Curves)。
直线和多角形通过它们的点来描述，曲线和表面则根据于它们的控制点和依附于曲线类型的额外信息来定义。这些信息支持规则和不规则的曲线，包括那些基于贝塞尔(Bezier)曲线，B样条(B-spline)，基数(Cardinal/Catmull-Rom样条)，和泰勒方程(Taylor equations)的曲线。
1、OBJ文件 -- 特点
(1)OBJ是一种3D模型文件，因此不包含动画、材质特性、贴图路径、动力学、粒子等信息。
(2)OBJ文件主要支持多边形(Polygons)模型。
虽然OBJ文件也支持曲线(Curves)、表面(Surfaces)、点组材质(Point Group Materials)，但Maya导出的OBJ文件并不包括这些信息。
(3)OBJ文件支持三个点以上的面，这一点很有用。
很多其它的模型文件格式只支持三个点的面，所以我们导入Maya的模型经常被三角化了，这对于我们对模型的再加工甚为不利。
(4)OBJ文件支持法线和贴图坐标。
在其它软件中调整好贴图后，贴图坐标信息可以存入OBJ文件中，这样文件导入Maya后只需指定一下贴图文件路径就行了，不需要再调整贴图坐标了。
2、OBJ文件 -- 基本结构
OBJ文件不需要任何种文件头(File Header)，尽管经常使用几行文件信息的注释作为文件的开头。
OBJ文件由一行行文本组成，注释行以一个“井”号(#)为开头，空格和空行可以随意加到文件中以增加文件的可读性。有字的行都由一两个标记字母也就是关键字(Keyword)开头，关键字可以说明这一行是什么样的数据。多行可以逻辑地连接在一起表示一行，方法是在每一行最后添加一个连接符(\)。
注意连接符(\)后面不能出现空格或tab格，否则将导致文件出错。
下列关键字可以在OBJ文件使用。
在这个列表中, 关键字根据数据类型排列，每个关键字有一段简短描述。
顶点数据(Vertex data)：
v 几何体顶点 (Geometric vertices)
vt 贴图坐标点 (Texture vertices)
vn 顶点法线 (Vertex normals)
vp 参数空格顶点 (Parameter space vertices)
自由形态曲线(Free-form curve)/表面属性(surface attributes):
deg 度 (Degree)
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05634cfa600473df0722b87e0dd76a65/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ade2ce25e6a5bf581530ddcf1270cca5/" rel="bookmark">
			如何开发一个App（Android）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 本篇博客从开发的角度来介绍如何开发一个Android App，需要说明一点是，这里只是提供一个如何开发一个app的思路，并不会介绍很多技术上的细节，从整个大局去把握如何去构思一个app的开发，让你对独立开发一款app的时候有个理解，如果有说的不对的地方，欢迎大家拍砖留言讨论。
开发环境 Android应用层使用的开发语言是Java，自然需要用到Java运行环境，无论你在Window是系统还是Mac系统都需要安装JDK，并且配置它的环境变量，不懂什么叫环境变量的或者不知道怎么配的，请利用好自己的百度技能自行学习。
开发工具 开发工具，Android因为历史原因，前面很长一段时间使用的是Eclipse，我们要开发Android应用的时候需要另外安装Google为它开发的插件ADT，Eclipse这个开源软件很优秀，也很专业，但仅仅只是使用它来开发Android就显得有点鸡肋了，如果没有对Eclipse进行优化的话，会很卡很卡，后面Google实在不愿意寄人篱下，就专门为我们开发者开发了目前很受广大开发者推崇的Android Studio，现在2.0预览版也出来啦，大伙赶紧去下吧。
模拟器 Android自带的模拟器一直广受诟病，实在是太卡太慢了，对比人家IOS模拟器是那么的流畅，Android开发者直喊好苦逼啊，不过还好后面出了第三方比原生流畅n倍的模拟器Genymotion，大家可以去下一个个人版的够你平时开发测试用了。最好的办法还是使用真机测试，毕竟真机才是真实的环境。
Android核心基础 前面是准备工作，想开发一款Android app，你最起码要掌握Android的核心基础知识，针对初学Android的童鞋，想一口吃掉一个胖子是不可能的，还是得把基础打牢之后才能完成独立的开发，Android入门不难，学完基础你只是具备开发app的基本条件，想做一个优秀的app还有很长一段路要走，经验是靠不断实践堆出来的，找一套系统的课程去认真学习一下，在线教育的资源很多，比如慕课网，极客学院都有很多不错的学习资源，童鞋自己择优来学习即可。
推广：http://edu.csdn.net/course/detail/545（笔者的课程）
产品开发流程 正常的互联网开发app的流程大致如下： - 产品规划，定产品方向 - 需求调研，产出需求文档 - 需求评审，修订需求文档 - 产品狗画app线框图提供给射鸡师 - 射鸡师根据线框图设计视觉稿 - 程序猿根据视觉稿搭建UI框架 - 程序猿根据需求文档开发功能 - 测试媛编写测试用例，根据排期进行测试 - 程序猿修复回归测试反馈的bug，提交beta版 - 测试通过，提交给运营喵发布到渠道上线
上面是笔者的经验总结，可能有不太准确的地方，但大致整个流程是这样，我们开发者要清楚自己在整个产品中充当的角色，明白自己的工作职责即可。
快速搭建项目 Android比没有想象那么难，只是刚开始要学习的东西多，一下子消化不了才会比较茫然，笔者写这篇博客就是想帮助大家整理一下开发思路。
快速搭建项目也算是一项技能，而这项技能只能由你自己来完善，刚开始做开发的时候一定会有很多重复性的工作，如果没有意识去提高自己的开发效率的话，可能你的十年工作经验代表的只是一年的经验用了十年而已。
那要怎么做，笔者提供一个自己总结的，仅供参考： - 定开发规范 - 搭建UI框架 - 选用开发库集成（或自造轮子） - 第三方服务集成（视情况而定）
定开发规范 一个项目一般不会只有一个人独立开发，就算是独立开发，我们也应该定一下开发规范，一般会有什么样的规范？ - 命名规范 - 代码规范 - 代码管理规范
命名规范 命名规范包括： - 项目命名 - 包命名 - 类命名、成员变量命名 - 资源文件命名 我们做每一个产品都会有相应的命名，不要用中文来命名，最好用能表达中文意思的英文来表示，例如CSDN客户端，可以用CSDNClient作为命名，我们创建项目的时候可以以它作为Application name。 可以看看以前写的这篇文章： http://blog.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ade2ce25e6a5bf581530ddcf1270cca5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/25b925db2ac11fff4af172f6ff8c2ece/" rel="bookmark">
			在Visual Studio Code配置GoLang开发环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Visual Studio Code配置GoLang开发环境 作者：chszs，未经博主允许不得转载。经许可的转载需注明作者和博客主页：http://blog.csdn.net/chszs Visual Studio Code是我非常喜欢的开发工具。那么，如果能在Visual Studio Code上配置GoLang开发环境，以此开发GoLang程序，无疑很有趣。本文主要讲述这个过程。
一、GoLang的安装 GoLang在Windows的安装比较简单，过程省略。
验证一下:
D:\&gt;go version go version go1.5.1 windows/amd64 要注意，GoLang的安装要确保两个环境变量，一个是GOROOT环境变量；二是PATH环境变量要包含$GOROOT\bin值。
二、GoLang插件介绍 对于Visual Studio Code开发工具，有一款优秀的GoLang插件，它的主页为：https://github.com/microsoft/vscode-go
这款插件的特性包括：
代码着彩色代码自动完成（使用gocode）代码片段快速提示信息（使用godef）跳转到定义（使用godef）搜索参考引用（使用go-find-references）文件大纲（使用go-outline）重命名（使用gorename）保存构建（使用go build和go test）代码格式化（使用goreturns或goimports或gofmt）调试代码（使用delve） 三、插件安装 1、安装Visual Studio Code 0.10.2版 去官方网站：https://code.visualstudio.com/ 下载Visual Studio Code 0.10.2版，安装过程略。
2、安装插件 进入Visual Studio Code界面，使用快捷键Ctrrl+Shift+p，打开命令面板，选择“Extensions: Install Extension”，等待插件名列表的加载（这一步国内较慢）。 然后在输入框“ext install ”输入go，选择go 0.6.15，点击安装，安装完成后要求重启开发环境，点击重启按钮，自动刷新环境。
3、设置GOPATH环境变量 在Windows系统中设置GOPATH环境变量，我的值为D:\tools\VSCode\works 缺少GOPATH环境变量通常会报“$GOPATH not set.”这样的错误。
4、开启自动保存 强烈建议把自动保存功能开启。开启方法为：选择菜单File，点击Auto save。
5、安装Git Windows安装Git的过程省略。记得把git\bin配置到PATH环境变量中。
四、配置插件 Visual Studio Code的配置选项支持GoLang插件的设置，可以通过用户偏好设置或workspace设置进行配置。在菜单File-&gt;Preferences处可以找到。
1、点击User Settings 找到
// Specifies the GOPATH to use when no environment variable is set.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/25b925db2ac11fff4af172f6ff8c2ece/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/783002615aba5314ffe98766203dae55/" rel="bookmark">
			配置git DiffMerge工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		git的命令行貌似没有特别好用的UI工具，不管是Android Studio自带的还是其他的，完全代替命令行好像做不到。再加上对git来说没什么比diff和merge更正常不过的事情了。那就配置命令行吧。
“Git鼓励在工作流程中频繁使用分支与合并，哪怕一天之内进行许多次都没有关系。理解分支的概念并熟练运用后，你才会意识到为什么Git是一个如此强大而独特的工具，并从此真正改变你的开发方式。” 不是我说的，但是很贴切。
我用的工具是 DiffMerge，比较轻，官网是：http://www.sourcegear.com/diffmerge/
安装在 c 盘之后，需要在git里面配置下，DiffMerge_4.2.0.697.stable_x64 .msi，其中exe为C:\Program Files\SourceGear\Common\DiffMerge\sgdm.exe。
具体流程
1.安装DiffMerge
2.配置sgdm.exe路径C:\Program Files\SourceGear\Common\DiffMerge到windows环境变量的path下
3.配置git
git config --global diff.tool sgdm git config --global difftool.diffmerge.cmd 'sgdm "$LOCAL" "$REMOTE"' git config --global merge.tool sgdm git config --global mergetool.diffmerge.cmd 'diffmerge --merge --result="$MERGED" "$LOCAL" "$(if test -f "$BASE"; then echo "$BASE"; else echo "$LOCAL"; fi)" "$REMOTE"' git config --global mergetool.diffmerge.trustExitCode true 4.用DiffMerge
在代码处理MERGING状态时，可以用命令 git mergetool 启动工具
补：
问题1：
工具会生成.orig文件，可以设置下，让git不再生成：
git config --global mergetool.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/783002615aba5314ffe98766203dae55/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/90ab1b0f87ec7ec0a39f3ed530ffb167/" rel="bookmark">
			&lt;5&gt;Android HAL  hardware.h 源码文件分析 路径：/hardware/libhardware/include/hardware/hardware.h
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		// android 源代码里 cat hardware/libhardware/include/hardware/hardware.h /* * Copyright (C) 2008 The Android Open Source Project * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/90ab1b0f87ec7ec0a39f3ed530ffb167/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee6eb55c423d9125a2c82c40c39e14e1/" rel="bookmark">
			开源分词软件
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		由于中文文本词与词之间没有像英文那样有空格分隔，因此很多时候中文文本操作都涉及切词，这里整理了一些中文分词工具。一般来说用CRF实现的分词工具的处理速度是比较慢的（训练CRF模型是非常耗时的），但是精度高，涉及CRF的分词工具有CRF++，Stanford分词工具。
Bakeoff是一个国际中文处理比赛，有多个语料，所以每个语料都有排名。只有部分优秀的Bakeoff工具开源。
介绍了以下18种分词工具（大部分是基于java语言）：
perminusminus Stanford 汉语分词工具（Bakeoff-2两项第一）
哈工大语言云（LTP -cloud）
ICTCLAS&amp;mdash;&amp;mdash;（Bakeoff -1两项第一）
Ansj（ICTCLAS的java实现）
庖丁解牛分词
盘古分词 IKAnalyzer
imdict-chinese-analyzer
mmseg4j
FudanNLP(复旦大学)
Jcseg
SCWS
Friso
HTTPCWS
libmmseg
OpenCLAS
CRF++ （Bakeoff-3四项第一）
perminusminus 项目网址：http://code.google.com/p/perminusminus/
作者：张开旭（清华大学2012届博士毕业生，毕业论文，现在厦大教学）。
个人主页：http://nlp.csai.tsinghua.edu.cn/~zkx/
源码是python。算法原理是感知器模型。
Introduction Per-- is a toolkit of AveragedPerceptron (Freund and Schapire, 1999) for path Labelingunder the KISS principle(Keep It Simple and Stupid).
Features Simple and efficient
Multiple usage: path labeling, path finding, sequence labeling and classification
Can provide n-best outputs
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee6eb55c423d9125a2c82c40c39e14e1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c66909b84e5b532c7604f5d27dabe25f/" rel="bookmark">
			正常编写的程序出现androidmainfest.xml missing错误怎么做
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 如果不是网上说的导入旧项目发生错误，那么可能是这种情况，可以点开project,点击clean，进行重新编译就可以了。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6cf51329f572a447c0aa4ed2d93080e/" rel="bookmark">
			c语言符号常量与常变量的区别？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		&lt;blockquote&gt;定义符号常量：#define PI 3.1415926 //注意后面没有分号
定义常变量 ：const float PI=3.1415926；&lt;/blockquote&gt;
&lt;strong&gt;区别：&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;常变量：变量的特征是存在一个以变量名命名的存储单元，在一般情况下，存储单元中的内容是可以变化的。而对于常变量，在变量的基础上加了一个限定：存储单元中的内容不允许变化，仍然是有存储单元的。&lt;/li&gt;
&lt;li&gt;符号常量：是使用一个字符串代替程序中出现的一个标识符，是编译时把所有的符号常量都替换成制定的字符串，在内存中也不存在一符号常量命名的存储单元。在其作用域内其值不能改变和赋值。&lt;/li&gt;
&lt;/ul&gt;
&amp;nbsp;
&amp;nbsp;
&amp;nbsp;
转载于:https://www.cnblogs.com/liweilijie/p/4984604.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcb410a8b11fe20c135824e51a9e841c/" rel="bookmark">
			Python在线爆破邮箱账号密码测试代码（亲测可用）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dic 字典格式如下(mail.txt) :
username@gmail.com:password
username@gmail.com:password
username@gmail.com:password
以此类推，切记保存成utf-8编码格式。
放置在当前脚本目录，也可自己定义修改。
支持ssl https /imap协议。
# version 3.4.0 # coding='UTF-8' # time='2014-09-16' import _dummy_thread import imaplib import threading # global variant GLOBAL_STRING_GMAIL_ACCOUNT_PWD_ARRAY = [] GLOBAL_STRING_GMAIL_ACCOUNT_PWD_ARRAY_NUM = 0 GLOBAL_STRING_GMAIL_IMAP4_SERVER = 'imap.gmail.com' GLOBAL_INT_GMAIL_IMAP4_SERVER_PORT = 143 GLOBAL_INT_GMAIL_IMAP4_SSL_PORT = 993 GLOBAL_WORKING_THREAD_MUTEX_LOCK = _dummy_thread.allocate_lock() GLOBAL_ARRAY_BUFFER_MAX_LINES = 1000 GMAIL_BYTES_READED_TOTAL_SIZE = 0 GLOBAL_GMAIL_CURRENT_POSITION_TOTAL_LINES = 0 GLOBAL_READ_FINISH_STATUS_SUCCESS = False # define global function def Write_Save_Success_Gmail_Jobs(indexSuccess): Success_File = open('success.txt', 'a') Success_File.write(GLOBAL_STRING_GMAIL_ACCOUNT_PWD_ARRAY[indexSuccess]) Success_File.close() def Write_Save_Fail_Gmail_Jobs(indexFail): Fail_File = open('fail.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcb410a8b11fe20c135824e51a9e841c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c20a7200f94e3289065d84d922d80415/" rel="bookmark">
			基于长密码的PHP函数验证漏洞学习（Long Password Denial of Service (DoS)）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		啥都不说，干货直接上源码。
&lt;?php /* * To change this license header, choose License Headers in Project Properties. * To change this template file, choose Tools | Templates * and open the template in the editor. */ //demo 0x001 //require_once 'phpass.php'; set_time_limit(0); ignore_user_abort(true); class PasswordHash { var $itoa64; var $iteration_count_log2; var $portable_hashes; var $random_state; function PasswordHash($iteration_count_log2, $portable_hashes) { $this-&gt;itoa64 = './0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'; if ($iteration_count_log2 &lt; 4 || $iteration_count_log2 &gt; 31) $iteration_count_log2 = 8; $this-&gt;iteration_count_log2 = $iteration_count_log2; $this-&gt;portable_hashes = $portable_hashes; $this-&gt;random_state = microtime(); if (function_exists('getmypid')) $this-&gt;random_state .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c20a7200f94e3289065d84d922d80415/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3899c8808f9db143ba5624aabae6f2e/" rel="bookmark">
			安卓问题集锦
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 问题1：The specified child already has a parent. You must call removeView()
原因：一个孩子只能有一个父亲，在调用的过程中同一个孩子出现了两个父亲。
解决方案：在添加视图之前断除孩子和其他父亲的关系。
ViewGroup viewParent = (ViewGroup)pauseLinearLayout.getParent(); if(viewParent != null) { viewParent.removeAllViewsInLayout(); } layoutLoading.addView(pauseLinearLayout); 问题2：the project system may be using a version of Gradle that does not contain the method
解决方案：删除build.gradle里面的：
{ compileSdkVersion 17 buildToolsVersion '18.1.0' } dependencies { } 问题3：andriod library projects cannot be launched
原因：工程有缓存
解决方案：
在工程上点击右键，选择properties
在Android中不要选中 Is Library,并且Remove里面的所有东西，选择自己用的就ok了。
问题4：the selected device is incompatible
问题原因：设备未连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3899c8808f9db143ba5624aabae6f2e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3de73c54bf49ebe46a5491cdb7de27ee/" rel="bookmark">
			解决ios下使用uiwebview载入网页时，插放网页中视频或者音频无声音解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 &lt;pre name="code" class="objc"&gt;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { // Override point for customization after application launch. AVAudioSession *audioSession = [AVAudioSession sharedInstance]; BOOL ok; NSError *setCategoryError = nil; ok = [audioSession setCategory:AVAudioSessionCategoryPlayback error:&amp;setCategoryError]; if (!ok) { NSLog(@"%s setCategoryError=%@", __PRETTY_FUNCTION__, setCategoryError); } ……... 其它需求，可以读 iOS Human Interface Guidelines这章 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f032652bfd5d94f1cdb7ffa4f20a9ff/" rel="bookmark">
			第十章学习总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、标识符 identifier
1.程序中的常量，符号常量，变量，自定义函数，自定义类型等 都需要一个名字，这些名字统称为标识符
2.标识符用来标识实体名字
3,,标识符是一个有效的字符序列
二、标识符命名规则
1.标识符只能有数字，下划线，字母组成，且第一个字符必须为字母或者下划线
2.标识符命名的时候不能和关键字（已经被c语言本身使用，不能用作其他用途的字）相同
c语言中的关键字
&lt;span style="color:#330033;"&gt;auto ：声明自动变量 break：跳出当前循环 case：开关语句分支 char ：声明字符型变量或函数返回值类型 const ：声明只读变量 continue：结束当前循环，开始下一轮循环 default：开关语句中的“其它”分支 do ：循环语句的循环体 double ：声明双精度浮点型变量或函数返回值类型 else ：条件语句否定分支（与 if 连用） enum ：声明枚举类型 extern：声明变量或函数是在其它文件或本文件的其他位置定义 float：声明浮点型变量或函数返回值类型 for：一种循环语句 goto：无条件跳转语句 if:条件语句 int： 声明整型变量或函数 long ：声明长整型变量或函数返回值类型 register：声明寄存器变量 return ：子程序返回语句（可以带参数，也可不带参数） short ：声明短整型变量或函数 signed：声明有符号类型变量或函数 sizeof：计算数据类型或变量长度（即所占字节数） static ：声明静态变量 struct：声明结构体类型 switch :用于开关语句 typedef：用以给数据类型取别名 unsigned：声明无符号类型变量或函数 union：声明共用体类型 void ：声明函数无返回值或无参数，声明无类型指针 volatile：说明变量在程序执行中可被隐含地改变 while ：循环语句的循环条件&lt;/span&gt; 1999年12月16日，ISO推出了C99标准，该标准新增了5个C语言关键字：
inline restrict _Bool _Complex _Imaginary（注意bool 从来不是C语言的关键字）
2011年12月8日，ISO发布C语言的新标准C11，该标准新增了7个C语言关键字：
_Alignas _Alignof _Atomic _Static_assert _Noreturn _Thread_local _Generic
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f032652bfd5d94f1cdb7ffa4f20a9ff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/054fb593391d6401398a5c2151eb7dc6/" rel="bookmark">
			javaWeb常见异常的解决方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.如果不能给属性赋上值，就检查getter 和 setter方法；
2.如果不能创建对象，检查是否有空参的构造函数
3.注意文本需要去除回车、换行符，不然修改回显数据时前端会报错
4.用Json写数据传给前台时，导入的jar包不止json一个jar包，还需导入其他包才可以成功构建类
5.后台数据中文为出现乱码，页面设置字符也为UTF-8，但是前台接收的数据中文出现乱码——解决：response.setContentType("text/html;charset=utf-8")
6.当异常信息提示为找不到对应的Method时,可能是表单没有写method=”get“ （或者post） ，JSP中的表单默认不知道为什么没有默认方法；如果是用反射调用方法时，说找不到对应的方法时，可能是方法的可见性（设为public 或者 其方法为Protect 就设置可见性为true）
7.Struts2 中配置验证器 不起作用 --- 因为是自己新建一个xml文件，所以并没有复制Struts下的文件内容，才会导致不起作用。当自己新建的xml文件中 前面要增加这段
&lt;!DOCTYPE validators PUBLIC
"-//Apache Struts//XWork Validator 1.0.2//EN"
"http://struts.apache.org/dtds/xwork-validator-1.0.2.dtd"&gt;
8.当用Struts时，要注意表单各个域的名字，特别是在成员变量和当前对象具有同名属性时。要么把相同属性名使用不同的属性名，要么就把 名字定义为成员变量的属性名（object.property）
9.当在Struts2 中的action类实现了 ModelDriven 和 Preparable 接口，需要修改表单信息时，有些没有在修改表单的数据（如创建时间 或者 设置为 disable），如果在 prepareXxx方法中新new 一个 对象，那么会造成修改数据库时某些字段值为空，解决办法：
①把没有的字段通过隐藏域传给后台--- 当数据比较多时，会造成数据冗余较大
②通过把对象从数据库中取出，而不是 直接new一个新对象
9.在spring的配置文件中，报错: Cannot find the declaration of element 'beans'.
原来是因为 xmlns：beans 错误，应该去掉“:beans”,如下：
10.今天在用maven添加net.sf.json的jar包的时候，代码如下：
? 1 2 3 4 5 &lt; dependency &gt; &lt; groupId &gt;net.sf.json-lib&lt;/ groupId &gt; &lt; artifactId &gt;json-lib&lt;/ artifactId &gt; &lt; version &gt;2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/054fb593391d6401398a5c2151eb7dc6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74aadb543c337deab3d6b3f12d52c1f6/" rel="bookmark">
			用Struts2框架将jsp的form表单数据提交到action处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下是图书管理系统，只有部分代码，主要实现从JSP传数据到action，分页显示没列出，详细在附件
1.add.jsp页面内容
&lt;span style="font-size:18px;"&gt;&lt;%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%&gt; &lt;%@ taglib prefix="s" uri="/struts-tags" %&gt; &lt;% String path = request.getContextPath(); String basePath = request.getScheme()+"://"+request.getServerName()+":"+request.getServerPort()+path+"/"; %&gt; &lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"&gt; &lt;html&gt; &lt;head&gt; &lt;base href="&lt;%=basePath%&gt;"&gt; &lt;title&gt;添加新图书&lt;/title&gt; &lt;meta http-equiv="pragma" content="no-cache"&gt; &lt;meta http-equiv="cache-control" content="no-cache"&gt; &lt;meta http-equiv="expires" content="0"&gt; &lt;meta http-equiv="keywords" content="keyword1,keyword2,keyword3"&gt; &lt;meta http-equiv="description" content="This is my page"&gt; &lt;script src="js/jquery-1.8.3.js"&gt; &lt;/script&gt; &lt;script type="text/javascript"&gt; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form action="addbooks" method="post"&gt; &lt;table align="middle"&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt; &lt;td bgcolor="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74aadb543c337deab3d6b3f12d52c1f6/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/467/">«</a>
	<span class="pagination__item pagination__item--current">468/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/469/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>