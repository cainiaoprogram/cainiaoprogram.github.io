<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/429176b00e379fd5dea7a01504608b8a/" rel="bookmark">
			STM32————按键实现控制LED灯
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32————按键实现控制LED灯 功能简述宏定义与预处理初始化主函数 功能简述 按键控制LED灯分两种情况 1：按下一亮，直到第二次按下熄灭 2：按一下常亮，松开就熄灭 宏定义与预处理 /************LED.h文件************/ #ifndef _ LED.h #define _ LED.h #include “stm32f10x.h” //宏定义LED灯 #define LEDPORT GPIOB //IO组 #define LED1 GPIO_Pin_0 //定义LED1 #define LED2 GPIO_Pin_1 //定义LED2 //宏定义按键 #define KEYPORT GPIOA #define KEY1 GPIO_Pin_0 /************LED.h文件************/ /************LED.c文件************/ #include “LED.h” 初始化 //LED灯初始化 Void Init_Led(void) { GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);//使能其所在时钟 GPIO_InitStructure.GPIO_Pin= LED1|| LED2 //设置引脚 GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP; //设置模式 GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;//设置速度 GPIO_Init(LEDPORT,&amp;GPIO_InitStructure); } //按键初始化 Void Init_ Key(void) { GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);//使能其所在时钟 GPIO_InitStructure.GPIO_Pin= KEY1; //设置引脚 GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP; //设置模式 GPIO_InitStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/429176b00e379fd5dea7a01504608b8a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/525347d911737fa035c9ce1d1fc542f8/" rel="bookmark">
			mysql修改表命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、添加列表
alter table 表名 add 列名 类型;
2、删除某一列
alter table userinfo drop column 列名;
3、修改列的类型
alter table 表名 modify column 列名 类型；
4、同时修改列名和类型
alter table 表名 change 旧的列表名称 新的列表名称 类型；
5、添加主键
alter table 表名 add primary key (列名)；
6、删除主键，因为主键是唯一的，所以这里删除主键不需要指定列的名称
alter table 表名 drop primary key;
7、删除外键
alter table 表名 drop foreign key 外键名称;
8、默认值相关的命令
给某一列设置默认值
alter table 表名 alter 列名 set default 默认值；
删除某一列的默认值
alter table 表名 alter 列名 drop default；
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/24c7ade7d1d699d05cedfbfb8a056dfc/" rel="bookmark">
			常见的微指令编码方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，直接表示法
微指令操作控制字段的每一位都直接表示一个微命令，该位为“1”，表示执行这个微命令。
二、最短编码法
将所有的微命令进行统一编码，每条微指令只定义一个微命令。
三，字段直接编码法
将微指令的微命令字段分为若干小字段,把互斥性微命令组合在同一字段中,把相容性微命令组合在不同的字段中,每个字段独立编码,每种编码代表一个微命令且各字段编码含义单独定义,与其他字段无关,这就是字段直接编码方式。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbabf68d46be71274696e80d886afb01/" rel="bookmark">
			【Vivado工具使用技巧】如何快速查看一个工程的器件型号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		你接手一个项目，如果不是新建，总有想要查看器件类型、软件版本的需求，如何快速获取这些信息呢？
log文件是个好东西，无论是综合目录下的runme.log
还是实现目录下的runme.log都可以查看这些信息：
打开runme.log：
上述runme.log下可不止这些信息，它还记录了你所有的运行记录，综合或者实现下的所以软件操作；
例如，对某个输出引脚加入了IOB约束，但是不知生效了没？无处可查时，就可以通过runme.log进行搜索，如果没有成功，会有记录为什么没有生效的。
最后，如果仅仅是为了快速得到器件信息，还可以直接通过记事本打开工程文件xxx.xpr：
仍可以一览无遗。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1b2e86acdc073c4915ec0f08130c0ac8/" rel="bookmark">
			傅里叶变换及低通滤波再反变换（C&#43;&#43;&amp;&amp;opencv）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对灰度图像做傅里叶变换并进行低通滤波再做傅里叶逆变换。 结果及代码如下： 如上图：mag图表示幅度谱，亮处为低频部分，暗处为高频部分。 #include &lt;iostream&gt; #include &lt;opencv.hpp&gt; #include &lt;opencv2\opencv.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/highgui/highgui_c.h&gt; using namespace cv; using namespace std; void FourierTransform(cv::Mat&amp; image) { image.convertTo(image, CV_32F); vector&lt;Mat&gt; channels; split(image, channels); //分离RGB通道 Mat image_B = channels[0]; //选取最适合做fft的宽和高 int m1 = getOptimalDFTSize(image_B.rows); int n1 = getOptimalDFTSize(image_B.cols); Mat padded; //填充 copyMakeBorder(image_B, padded, 0, m1 - image_B.rows, 0, n1 - image_B.cols, BORDER_CONSTANT, Scalar::all(0)); Mat planes[] = { Mat_&lt;float&gt;(padded), Mat::zeros(padded.size(), CV_32F) }; Mat complexI; merge(planes, 2, complexI); //planes[0], planes[1]是实部和虚部 dft(complexI, complexI, DFT_SCALE | DFT_COMPLEX_OUTPUT); split(complexI, planes); //定义幅度谱和相位谱 Mat ph, mag, idft; phase(planes[0], planes[1], ph); magnitude(planes[0], planes[1], mag); //由实部planes[0]和虚部planes[1]得到幅度谱mag和相位谱ph //重新排列傅里叶图像中的象限，使得原点位于图像中心 int cx = mag.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1b2e86acdc073c4915ec0f08130c0ac8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee129e26da7b54f3256b430969e04aad/" rel="bookmark">
			批处理脚本
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		批处理 1. 常用变量 # 当前工作目录 %cd% # bat文件所在目录 %~dp0 # 传入bat的第一个参数 %~1 %1 # C:\Users\tudou\AppData\Roaming %appdata% # C:\Users\tudou\AppData\Local %localappdata% # C:\Users\tudou\Documents %userprofile%\Documents # C:\Users\Public\Documents %PUBLIC%\Documents # C:\Users\tudou %userprofile% # C:\Program Files (x86) %ProgramFiles(x86)% # C:\Program Files (x86)\Common Files %ProgramFiles(x86)%\Common Files # C:\Program Files %ProgramW6432% # C:\Program Files\Common Files %ProgramW6432%\Common Files # C:\ProgramData %ProgramData% # C:\Users\tudou\AppData\Local\Temp %temp% 2. code 2.1 if…else 等于 ==、equ不等于 neq大于 gtr小于 lss大于等于 geq小于等于 leq if ERRORLEVEL 1 (echo [ERROR] 请用管理员权限运行!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee129e26da7b54f3256b430969e04aad/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2229eab44f44c06b191c930fade2f0d8/" rel="bookmark">
			利用grep进行文本处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用grep进行文本处理 背景相关命令思路过程1.首先用grep过滤出数据2.拆完了肯定是要匹配下数据量是否能对3.发现数据对应不上 背景 需要将一份百万的数据按照一定的规格（开头以地市字符）进行数据拆分。
相关命令 grep
wc
思路 根据grep的正则匹配出以hz、nb开头的数据
过程 1.首先用grep过滤出数据 grep '^hu' aaa.txt &gt;hu.txt grep '^hz' aaa.txt &gt;hz.txt grep '^jh' aaa.txt &gt;jh.txt grep '^jx' aaa.txt &gt;jx.txt grep '^ls' aaa.txt &gt;ls.txt grep '^nb' aaa.txt &gt;nb.txt grep '^qz' aaa.txt &gt;qz.txt grep '^sx' aaa.txt &gt;sx.txt grep '^tz' aaa.txt &gt;tz.txt grep '^wz' aaa.txt &gt;wz.txt grep '^zs' aaa.txt &gt;zs.txt 2.拆完了肯定是要匹配下数据量是否能对 利用wc获取文件行数，然后用excel合并对比下
wc -l * 3.发现数据对应不上 完了bbq了，发现数据量对应不上，只能想法子把差异的数据取出来
发现grep 支持[^] 取其他字符，说干就干，然后使用以下语法
grep '^[^ls]' aaa.txt |grep '^[^nb]'|grep '^[^qz]'|grep '^[^sx]'|grep '^[^hu]' |grep '^[^tz]'|grep '^[^hz]'|grep '^[^wz]'|grep '^[^jh]' |grep '^[^zs]'|grep '^[^jx]' &gt; cy.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2229eab44f44c06b191c930fade2f0d8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aed8caeb5c3dbd984beee14a779df78f/" rel="bookmark">
			CISC和RISC的比较
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		指令系统的发展朝向两种截然不同的方向，一种是增强原有指令的功能，设置更为复杂的新指令实现软件功能的硬化，这类机器称为复杂指令系统计算机(CISC),典型的有采用X86架构的计算机；另一种是减少指令种类和简化指令功能，提高指令的执行速度，这类机器称为精简指令系统计算机(RISC),典型的是ARM、MIPS架构的计算机。
一、CISC（Complex Instruction Set Computer） CISC的主要特点有：
1)指令系统复杂庞大，指令数目一般为200条以上。
2)指令的长度不固定，指令格式多，寻址方式多。
3)可以访存的指令不受限制。
4)各种指令使用频度相差很大。
5)各种指令执行时间相差很大，大多数指令需多个时钟周期才能完成。
6)控制器大多数采用微程序控制。
7)难以用优化编译生成高效的目标代码程序。
如此庞大的指令系统，对指令的设计提出了极高的要求，研制周期变得很长。后来人们发现，一味追求指令系统的复杂和完备程度不是提高计算机性能的唯一途径。在对传统CISC指令系统的测试表明，各种指令的使用频率相差悬殊，大概只有20%的比较简单的指令被反复使用，约占整个程序的80%；而有80%左右的指令则很少使用，约占整个程序的20%。从这一事实出发，人们开始了对指令系统合理性的研究，于是RISC随之诞生。 二、RISC（Reduced Instruction Set Computer） RISC的主要特点有：
1)选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的组合来实现。
2)指令长度固定，指令格式种类少，寻址方式种类少。
3)只有Load/Store(取数/存数)指令访存，其余指令的操作都在寄存器之间进行。
4)CPU中通用寄存器数量相当多。
5)RISC一定采用指令流水线技术，大部分指令在一个时钟周期内完成。
6)以硬布线控制为主，不用或少用微程序控制。
7)特别重视编译优化工作，以减少程序执行时间。
值得注意的是，从指令系统兼容性看，CISC大多能实现软件兼容，即高档机包含了低档机的全部指令，并可加以扩充。但RISC简化了指令系统，指令条数少，格式也不同于老机器，因此大多数RISC机不能与老机器兼容。由于RISC具有更强的实用性，故应该是未来处理器的发展方向。但事实上，当今时代Intel几乎一统江湖，且早期很多软件都是根据CISC设计的，单纯的RISC将无法兼容。此外，现代CISC结构的CPU已经融合了很多RISC的成分，其性能差距已经越来越小。复杂指令CSC可以提供更多的功能，这是程序设计所需要的。
三、比较 1)RISC更能充分利用VLSI芯片的面积。CISC的控制器大多采用微程序控制，其控制存储器在CPU芯片内所占的面积为50%以上，而RISC控制器采用组合逻辑控制，其硬布线逻辑只占CPU芯片面积的10%左右。
2)RISC更能提高运算速度。RISC的指令数、寻址方式和指令格式种类少，又设有多个通用寄存器，采用流水线技术，所以运算速度更快，大多数指令在一个时钟周期内完成。
3)RISC便于设计，可降低成本，提高可靠性。RISC指令系统简单，故机器设计周期短；其逻辑简单，故可靠性高。
4)RISC有利于编译程序代码优化。RISC指令类型少，寻址方式少，使编译程序容易选择更有效的指令和寻址方式，并适当地调整指令顺序，使得代码执行更高效化。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7c52d82c21939e1834b271d6b06f2f1c/" rel="bookmark">
			JDK8：java线程池源码解析：ThreadPoolExecutor源码，execute方法、addWorker方法解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 线程池的作用不用太多说了，线程池会按照一定的规则，创建和维护一定数量的线程，这些线程可以被循环利用来处理用户提交的任务。对比不使用线程池的方式，节省了频繁的创建和销毁线程带来的性能开销。
二、几个比较重要的概念 1. 工作线程（worker） 指的是当前线程池用于处理任务的worker对象，每个worker对象内部都持有一个thread对象实例。
2. 任务 调用方要执行的业务逻辑，一般应该是个Callable或者Runnable的实现。
3. 任务队列 线程池内部维护了一个队列用来存储待处理的任务，每个工作线程都可以从该队列获取任务进行处理。
4. 核心工作线程（worker）数 线程池内部需要维持的一个最小的工作线程数量。工作线程数量不足这个数量的时候，新来的任务都会交给一个新建的工作线程，任务不会被放入队列。工作线程数达到这个数量的时候，新来的任务都会直接放入队列，所有的工作线程会主动去轮询领任务。
5. 最大工作线程（worker）数 线程池内部会限制一个最大的工作线程数量。当工作线程数大于核心线程数值，任务队列也满的情况下，就需要再新建工作线程，但是所有的工作线程数量不能超过最大的工作线程数的设置。
5.1 空闲时间 线程池中工作线程数超过核心线程数配置的时候，对于那些空闲超过一定时间的线程会进行回收。
6. 线程池状态 线程池一共有五个状态
RUNNING：正常的运行状态，此时可以正常接收和处理任务。SHUTDOWN：关闭状态，只能通过调用shutdown()方法达到此状态。此时可以处理任务，但不再接受新任务，并且中断空闲的工作线程。STOP：停止状态，只能通过调用shutdownNow()方法达到此状态。此时清除队列中的未处理的任务，中断所有的（空闲的+正在执行任务的）工作线程。（不建议直接调用shutdownNow，会导致业务逻辑异常终止，会带来很多不可预知的问题）TIDYING：整理中状态，从SHUTDOWN和STOP自动流转到此状态。此时队列中任务为空，工作线程列表为空。TERMINATED：终止状态，从TIDYING状态自动流转到此状态。此时队列中任务为空，工作线程列表为空，并且已经执行完terminated回调函数。 三、有点绕的设计 在上一个小部分里提到了工作线程数和线程池状态。由于线程池本省的目的就是为了并行处理任务来提升效率。其对外暴露的方法也自然存在着被并发调用的可能性。而且内部的很多处理逻辑都和这两个变量息息相关。所以：
无论是状态改变、还是数量改变都应该保证原子性。有时状态改变和数量改变要保证在一个原子范围内。 所以为了简化这两个变量的并发控制，TreadPoolExecutor在实现的时候，把这两个值融合到了一个AtomicInteger类型的变量中。AtomicInteger能够保证这个值的变更是原子的。同时他内部存储的具体业务值是一个整型数值。
整型一共32个二进制位。
前3位用来存储线程池的状态值 因为状态就5种，3个二进制位刚好足够涵盖5种数值可能（因为2位可表示4种可能，3位可表示8种可能）。 后29位用来存储工作线程数，根据用户的不同的选择和线程池配置，有些创建出来的线程池是可能会产生很多的工作线程的（实际工程中都会严格限制工作线程数，毕竟一般单机服务器的核数都不会达到几十上百个的） 通过以上的一个概述，我们再来看源码中的几个变量的定义就简单明了多了。
// Integer.SIZE = 32 ,所以这个 COUNT_BITS = 29，意思是存储工作线程数的二进制为占29位 private static final int COUNT_BITS = Integer.SIZE - 3; /* CAPACITY 实际上就是2的29次方减1，具体的实际数值是多少不重要，重点是关注二进制表示： 1左移29位实际上就是：0010 0000 0000 0000 0000 0000 0000 0000 再减个1后得到的就是：0001 1111 1111 1111 1111 1111 1111 1111 所以这个CAPACITY的有效位就是29个1 */ private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; /* --- 状态值的定义 开始 ---*/ // runState is stored in the high-order bits // 状态值存储在高（3）位 /* -1的二进制表示：1111 1111 1111 1111 1111 1111 1111 1111 （补码标识法） -1左移29位之后：111 00000 0000 0000 0000 0000 0000 0000 （左侧切断，右侧补0） */ private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; /* 0的二进制表示：0000 0000 0000 0000 0000 0000 0000 0000 0左移29位之后：000 00000 0000 0000 0000 0000 0000 0000 （还是0） */ private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; /* 1的二进制表示：0000 0000 0000 0000 0000 0000 0000 0001 0左移29位之后：001 00000 0000 0000 0000 0000 0000 0000 */ private static final int STOP = 1 &lt;&lt; COUNT_BITS; /* 2的二进制表示：0000 0000 0000 0000 0000 0000 0000 0010 0左移29位之后：010 00000 0000 0000 0000 0000 0000 0000 */ private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; /* 3的二进制表示：0000 0000 0000 0000 0000 0000 0000 0011 0左移29位之后：011 00000 0000 0000 0000 0000 0000 0000 */ private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; /* 针对以上5个变量的总结，右侧的29位都是0， RUNNING的二进制以1打头，转换为整型为负值，所以这几个状态的整型数值从上到下依次增大。 */ /* --- 状态值的定义 结束 ---*/ /* 将状态和线程数整合到一个数值的方法（利用二级制的或运算） rs：一定是上面5个状态中的一个 wc：线程数是个不固定的正数值 因为rs的右侧29为都是0，而wc在逻辑上限制了其最大值不能超过CAPACITY，所以wc的前3位一定是0，所以整合之后的数值实际上是：rs的前三位 + wc的后29位 */ private static int ctlOf(int rs, int wc) { return rs | wc; } /* 从整合后数值c中拆分出来状态值 状态值 = c的前3位 + 29个0 c 和 CAPACITY取反 做与运算 CAPACITY：0001 1111 1111 1111 1111 1111 1111 1111 取反之后：1110 0000 0000 0000 0000 0000 0000 0000 因为前3位都是1，所以无论c的前3位是什么，与运算后都会保留c的前3位不变 因为后29位都是0，所以无论c的后面是什么，与运算后都会变为29个0 这样就还原出状态值。 */ // Packing and unpacking ctl private static int runStateOf(int c) { return c &amp; ~CAPACITY; } /* 从整合后数值c中拆分出来工作线程数 工作线程数 = 3个0 + c的后29位 c 和 CAPACITY 做与运算 CAPACITY：0001 1111 1111 1111 1111 1111 1111 1111 因为前3位都是0，所以无论c的前3位是什么，与运算后都会变为0 因为后29位都是1，所以无论c的后面是什么，与运算后都保持c的后29位不变 这样就还原出了工作线程数的值。 */ private static int workerCountOf(int c) { return c &amp; CAPACITY; } // 把整合后的值包装到一个原子变量中，下文称控制标识 private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); 四、方法解析 4.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7c52d82c21939e1834b271d6b06f2f1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ff04228776f9fa461fe75a802cccf43c/" rel="bookmark">
			【数学】初等函数求导和复合函数求导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.初等函数求导公式 二.复合函数求导法则 复合函数求导时，注意一点，从外部依次一步一步进行求导，不要遗漏，求到哪一步就只看哪一步的X。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb98c83104fd5a2158bd8b851bc039fa/" rel="bookmark">
			python统计文件夹中图片的数量个数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		做神经网络科研时，往往需要统计文件夹中照片的个数。代码如下：
import os path ="E:/ResNet_Data/shiyan/train/Bacterialblight" #文件夹路径 count = 0 for file in os.listdir(path): #file 表示的是文件名 count = count+1 print(count) 例如，我的实验中：
import os path1 ="E:/ResNet_Data/shiyan/train/Bacterialblight" train_Bacterialblight = 0 for Bacterialblight in os.listdir(path1): train_Bacterialblight = train_Bacterialblight+1 print("train_Bacterialblight:" + str(train_Bacterialblight) + "张") 输出结果为：
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b89cc5f7da829c71fe67b6d308d8e934/" rel="bookmark">
			使用ganache-cli和truffle构建以太坊智能合约，以实现“基于哈希锁定的跨链技术”为例
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 配置以太坊开发环境部署智能合约调用智能合约 配置以太坊开发环境 系统与工具的版本: Ubuntu 21.04 npm 7.5.2 Ganache CLI v6.12.2 (ganache-core: 2.13.2) Truffle v5.3.4 (core: 5.3.4) Solidity v0.5.16 (solc-js) Node v12.21.0 Web3.js v1.3.5 更新源：
$ sudo apt-get update 安装npm：
$ sudo apt-get install npm 使用root权限，然后安装truffle和ganache-cil：
$ sudo su # npm install -g truffle # npm install -g ganache-cli 克隆智能合约代码：
$ git clone https://github.com/longyangyi/HashTimeLockContract-yi.git 代码目录结构如下：
HashTimeLockContract-yi ├── contracts │ ├── HashTimeLockContract.sol 智能合约源码 │ └── Migrations.sol 用于部署 ├── migrations │ └── 1_initial_migration.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b89cc5f7da829c71fe67b6d308d8e934/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47c926bbf6a68fa8ab6a52d6f62e64ed/" rel="bookmark">
			NMS（非极大值抑制）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		非极大值抑制（Non-Maximum Suppression，NMS），顾名思义就是抑制不是极大值的元素。例如在行人检测中，滑动窗口经特征提取，经分类器分类识别后，每个窗口都会得到一个分数。但是滑动窗口会导致很多窗口与其他窗口存在包含或者大部分交叉的情况。这时就需要用到NMS来选取那些邻域里分数最高（是行人的概率最大），并且抑制那些分数低的窗口。 NMS在计算机视觉领域有着非常重要的应用，如视频目标跟踪、数据挖掘、3D重建、目标识别以及纹理分析等 。
在目标检测中，NMS的目的就是要去除冗余的检测框,保留最好的一个，如下图所示：
NMS的原理是对于预测框的集合S及其对应的置信度score（这里的置信度就是softmax得出的概率值，它的含义是多大的把握预测正确，也就是有多大的把握确定检测框中存在真正的目标）,选择具有最大score的检测框,记为M,将其从集合S中移除并加入到最终的检测结果集合中.并且将集合S中剩余检测框中与检测框M的IoU大于阈值的框从集合S中移除.重复这个过程,直到集合S为空。
使用流程如下图所示：
首先是检测出一系列的检测框
将检测框按照类别进行分类
对同一类别的检测框应用NMS获取最终的检测结果
通过一个例子看些NMS的使用方法，假设定位车辆，算法就找出了一系列的矩形框，我们需要判别哪些矩形框是没用的，需要使用NMS的方法来实现。
假设集合S中有A、B、C、D、E 5个候选框，每个框旁边的数字是它的置信度，我们设定NMS的iou阈值是0.5，接下来进行迭代计算：
第一轮：因为B是得分最高的（即B的置信度最高），在集合S的其余候选框中，如果与B的IoU＞0.5会被删除。A，C，D，E中现在分别与B计算IoU，DE结果＞0.5，剔除DE（说明BDE检测的是同一个目标，保留置信度最大的候选框；而AC可能检测的是另一个目标），B作为一个预测结果，从集合S中移除，并放入最终的检测结果集合中。此时新的集合S中只剩下候选框A,C
第二轮：在新的集合S中，A的置信度得分最高，将集合S中剩下的候选框分别与A计算IoU，因为A与C的iou＞0.5，所以剔除C，A作为另外一个预测结果从集合S中移除，并放入最终的检测结果集合中，此时集合S为空，所以循环结束。
最终结果为在这个5个中检测出了两个目标为A和B。
单类别的NMS的实现方法如下所示：
import numpy as np def nms(bboxes, confidence_score, threshold): """非极大抑制过程 :param bboxes: 同类别候选框坐标 :param confidence: 同类别候选框分数（即置信度） :param threshold: iou阈值 :return: """ # 1、没有传入候选框则返回空列表 if len(bboxes) == 0: return [], [] #强制转换为numpy类型的数组，这样才可以进行切片等numpy所支持的操作 bboxes = np.array(bboxes) score = np.array(confidence_score) # 取出所有候选框的左上角坐标和右下角坐标 x1 = bboxes[:, 0] y1 = bboxes[:, 1] x2 = bboxes[:, 2] y2 = bboxes[:, 3] # 2、对候选框进行NMS筛选 # 返回的框坐标和分数 picked_boxes = [] picked_score = [] # 对置信度进行排序, 获取排序后的下标序号, argsort默认从小到大排序 order = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47c926bbf6a68fa8ab6a52d6f62e64ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/17cc9ef7946c4bf784f20e872f99acb1/" rel="bookmark">
			MODIS数据下载、拼接、裁剪、8天合成月方法以及处理过程中遇到的问题及解决办法（简要整理）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我只是个文章搬运工！！仅供个人参考，主要也是为了我理清思路！！感谢参考的各位大佬！！
一、MODIS数据下载
①下载网址：https://ladsweb.modaps.eosdis.nasa.gov/​​​​​​
建议使用Chrome浏览器，并且需要进行注册账号才可以下载。我下载的数据是MOD17A2、A3，以及MOD16A2，MOD16A3的数据下载地址为（很有可能连接不上）e4ftl01.cr.usgs.gov
②下载步骤：在官网找到Data Discovery/Find data，依次选择数据类型、时间、区域，最后进行下载。注意：单次下载数据量不要超过200个，不然会无法下载！
③选择研究区域可以选择国家，如果是小区域可以根据瓦片进行选择（可以百度看瓦片对应的区域），后期进行裁剪。最后提交数据，在Past Orders中找到提交的数据，并打开数据集所在的位置。
④最后提交数据，在Past Orders中找到提交的数据，并打开数据集所在的位置（这个通常要等几分钟才可以打开），进行数据下载。
直接下载过程较慢，尝试了很多种方式，最后我借鉴大佬的方法，下载的IDM进行下载数据，确实速度快了不少。参考：IDM插件安装、使用方法教程
二、MODIS数据拼接
我进行数据拼接是基于MRT工具，其中需要配置一些环境，MRT的下载和安装参考：MRT(MODIS Reprojection Tool) 下载及安装教程
我用的批处理方法是可行的，MRT影像批量拼接参考：MODIS数据批量处理(基于MRT).
在使用MRT批处理过程中，我遇到了一些问题：①prm文件中选择的波段与生成的结果不同，修改办法参考：MRT批处理中波段选择bug的解决方案
三、MODIS批处理裁剪
借助Python工具在Arcmap中实现批处理，参考：【ArcGIS自定义脚本工具】批量裁剪栅格脚本_Salierib的博客-CSDN博客_arcgis批量裁剪栅格
四、天合成月
参考：[MODIS数据处理#8]批量将ET栅格的时间分辨率从8-day转换为monthly的一种思路 五、批处理其他过程
对MODIS数据进行处理还包括（重采样）、设为空值、乘，具体参考：【MODIS数据处理#14】拼接、投影、裁剪一键完成，比MRT更方便的ArcGIS脚本工具（含代码） 但是其中设为空值的批处理我一直出错，目前还不会修改！QAQ
我终于想明白了！设为空函数的前提是栅格图像必须要有属性表，所以在进行设为空函数之前必须要先创建属性表！！！
创建属性表我采用的模型构造器中的迭代，也可以进行快速处理：
可以对文件夹内（也可以包括子文件夹）的栅格数据进行处理，类似于批处理的过程，适应于数据不太多的情况。如果数据很多的话还是比较建议采用批处理，可惜我不会QAQ
六、其他 对比利用python和MRT进行处理，我觉得还是MRT相对操作简单一些，网上的一些代码对于MODIS数据的处理（转换tif、拼接、投影）大多数是分开的，我代码能力比较弱也写不出来综合处理的脚本，所以相比较而言MRT的批处理可以将转换、拼接、投影一起进行，唯一的缺点就是慢。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/14d25b90e2b8d7258e84f91d2d75727c/" rel="bookmark">
			微信小程序页面跳转：wx.switchTab、wx.reLaunch、wx.redirectTo、wx.navigateTo、wx.navigateBack的使用和区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、wx.switchTab（跳转主页） 跳转到tabBar页面，并关闭其他所有非tabBar页面，用于跳转到主页。
属性：
url：需要跳转的tabBar路径，不能带参数
success：接口调用成功的回调函数
fail：接口调用失败的回调函数
complete：接口调用结束的回调函数（调用成功、失败都会执行）
示例：
wx.switchTab({ url: '/index' }) 2、wx.reLaunch（关闭所有页面跳转） 关闭所有页面，打开到应用内的某个页面。
属性：
url：需要跳转的应用内页面路径，可以带参数
success：接口调用成功的回调函数
fail：接口调用失败的回调函数
complete：接口调用结束的回调函数（调用成功、失败都会执行）
示例：
wx.reLaunch({ url: 'test?id=1' }) 3、wx.redirectTo（关闭当前页面跳转） 关闭当前页面，跳转到应用内的某个页面，但不允许跳转到tabBar页面。
redirectTo与reLaunch的相同点是都销毁之前的页面，不同点是reLaunch销毁内存中所有保留的页面，redirectTo销毁当前页面。
属性：
url：需要跳转的应用内页面路径，可以带参数
success：接口调用成功的回调函数
fail：接口调用失败的回调函数
complete：接口调用结束的回调函数（调用成功、失败都会执行）
4、wx.navigateTo（保留页面跳转） 保留当前页面，跳转到应用内的某个页面，但是不能跳转到tabbar页面。
navigateTo 类似书本向前翻页，虽然从第一页翻到第二页，但是第一页还是存在的，未销毁；如果想返回上一页，可以使用 wx.navigateBack可以返回到原页面，对应使用。
属性：
url：需要跳转的应用内页面路径，可以带参数
events：页面间通信接口，用于监听被打开页面发送到当前页面的数据
success：接口调用成功的回调函数
fail：接口调用失败的回调函数
complete：接口调用结束的回调函数（调用成功、失败都会执行）
示例：
wx.navigateTo({ url: 'test?id=1', events: { // 为指定事件添加一个监听器，获取被打开页面传送到当前页面的数据 acceptDataFromOpenedPage: function(data) { console.log(data) }, someEvent: function(data) { console.log(data) } ... }, success: function(res) { // 通过eventChannel向被打开页面传送数据 res.eventChannel.emit('acceptDataFromOpenerPage', { data: 'test' }) } }) 5、wx.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/14d25b90e2b8d7258e84f91d2d75727c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4bbad0975df547cbf69d041df5c226f/" rel="bookmark">
			AD20 PCB界面颜色变成颜色变暗——＞解决办法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1.用AD20的时候，PCB突然变成了这样，颜色变的很黑。 2.解决办法： 点击左下角，这个选项，之后将下面的60%改为0%
3.效果： 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e0e8aee9a7e30e16e98bdd708e2e0291/" rel="bookmark">
			html用form表单做一个简约漂亮的登录页面
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		html部分 &lt;!DOCTYPE html&gt; &lt;html lang="en"&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;用户登录界面&lt;/title&gt; &lt;link rel="stylesheet" href="./style.css"&gt; &lt;link rel="shortcut icon" href="icon.png" type="image/x-icon"&gt; &lt;/head&gt; &lt;body class="container"&gt; &lt;form action="#" method="post" autocomplete="on"&gt; &lt;table&gt; &lt;tr&gt; &lt;td class="login-wrapper"&gt;&lt;h1&gt;登录&lt;/h1&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt; &lt;input type="text" placeholder="用户名" maxlength="4" required/&gt; &lt;/label&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt; &lt;input type="password" placeholder="密码" minlength="10" required/&gt; &lt;/label&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt; &lt;input type="password" placeholder="确认密码" required/&gt; &lt;/label&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt; &lt;input type="email" placeholder="Email"/&gt; &lt;/label&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;label&gt; &lt;input type="tel" placeholder="手机号码" required/&gt; &lt;/label&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;span class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e0e8aee9a7e30e16e98bdd708e2e0291/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f01a4557fa25a90f19d1f339977b53e0/" rel="bookmark">
			Spring、 Spring MVC、 Spring Boot的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概念
1、Spring
Spring是一个开源容器框架，可以接管web层，业务层，dao层，持久层的组件，并且可以配置各种bean,和维护bean与bean之间的关系。其核心就是控制反转(IOC),和面向切面(AOP),简单的说就是一个分层的轻量级开源框架。
2、SpringMVC
Spring MVC属于SpringFrameWork的后续产品，已经融合在Spring Web Flow里面。SpringMVC是一种web层mvc框架，用于替代servlet（处理|响应请求，获取表单参数，表单校验等。SpringMVC是一个MVC的开源框架，SpringMVC=struts2+spring，springMVC就相当于是Struts2加上Spring的整合。
3、SpringBoot
Springboot是一个微服务框架，延续了spring框架的核心思想IOC和AOP，简化了应用的开发和部署。Spring Boot是为了简化Spring应用的创建、运行、调试、部署等而出现的，使用它可以做到专注于Spring应用的开发，而无需过多关注XML的配置。它提供了一堆依赖打包，并已经按照使用习惯解决了依赖问题---&gt;习惯大于约定。
二、原理和结构
1、Spring的原理和组成
Spring为简化我们的开发工作，封装了一系列的开箱即用的组件功能模块，包括：Spring JDBC 、Spring MVC 、Spring Security、 Spring AOP 、Spring ORM 、Spring Test等。如下图：
Spring官方结构简化的理解图：
简化逻辑图
2、SpringMVC的原理和组成
从上图中可以看出：SpringMVC是属于SpringWeb里面的一个功能模块（SpringWebMVC）。专门用来开发SpringWeb项目的一种MVC模式的技术框架实现。其原理如下：
SpringMVC原理流程
MVC：Model（模型）、VIew（视图）、Controller（控制器）；我们从开始接触并学习javaWeb开发就知道MVC这一种架构，如早起的Sturts1、Sturts2等。
3、SpringBoot的原理和特性
Spring Boot基本上是Spring框架的扩展，它消除了设置Spring应用程序所需的XML配置，为更快，更高效的开发生态系统铺平了道路。
Spring Boot中的一些特点：
创建独立的spring应用。 嵌入Tomcat, Jetty Undertow 而且不需要部署他们。 提供的“starters” poms来简化Maven配置 尽可能自动配置spring应用。 提供生产指标,健壮检查和外部化配置 绝对没有代码生成和XML配置要求。组成和结构如下图： 从图中可以看出SpringBoot是包含了Spring的核心（IOC）和（AOP）；以及封装了一些扩展，如Stater：
三、区别与总结
1.简单理解为：Spring包含了SpringMVC，而SpringBoot又包含了Spring或者说是在Spring的基础上做得一个扩展。
三者区别对比
2、关系大概就是这样：
spring mvc &lt; spring &lt; springboot
3、Spring Boot 对比Spring的一些优点包括：
提供嵌入式容器支持
使用命令java -jar独立运行jar
在外部容器中部署时，可以选择排除依赖关系以避免潜在的jar冲突
部署时灵活指定配置文件的选项
用于集成测试的随机端口生成
4、结论
为了便于理解，可以简单看成上述spring mvc &lt; spring &lt; springboot的关系，但是Spring Boot既是对Spring的扩展，使开发，测试和部署更加方便。也增加了SpringBoot本身的一些功能，Sarter依赖、main函数启动入口，自动化配置等使得SpringBoot优于Spring的实现。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d7e8b0733667ccf9f9246bbe46610da7/" rel="bookmark">
			VMware Workstation Pro设置不同虚拟机、物理机静态ip互通，均能访问外网，搭建属于自己的虚拟机实验环境。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述：文档中的物理机为window10，虚拟机为centos8和window10，注意区分即可。
IP地址规划，网段为192.168.2.0/24,192.168.2.2，物理机IP：192.168.2.5，centos8虚拟机IP：192.168.2.10，window10虚拟机ip192.168.2.20。
一、物理机设置 1、设置物理机的虚拟网卡VMware Network Adapter VMnet8 IP地址为192.168.2.5。
2、windwos10物理机和windows10虚拟机,关闭防火墙，否则ping不通。
二、VMware Workstation Pro设置 1、将虚拟机通讯网卡为NAT模式。
2、VMware Workstation Pro设置虚拟网络编辑NAT网段为192.168.2.0/24,192.168.2.2。
三、虚拟机网络设置 1、设置centos8虚拟机通讯网卡，ip192.168.2.10，掩码255.255.255.0，网关192.168.2.2，dns=114.114.114.114。
2、window10虚拟机设置静态ip，ip192.168.2.20，掩码255.255.255.0，网关192.168.2.2，dns114.114.114.114。
四、验证网络 1、验证物理机网络，ping通centos8虚拟机，ping通window10虚拟机。
2、验证虚拟机centos8,ping通物理机Windows10和虚拟机Windows10，ping通百度。
3、window10虚拟机设置完ip,即可观察出网络图标状态，互相ping一下即可知道，window10虚拟机、centos8虚拟机、Windows10物理机都可互通，直接能上网浏览网页。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/132a472500b72e5a3ac10274f47cec0f/" rel="bookmark">
			Java实现纯后台调用打印机并且打印操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、前言？二、模拟数据库打印1.DemoDto实体类2.打印根据类3.测试效果 三、连接数据库查询数据1.需查询的实体类2.打印工具类3.业务代码4.测试 一、前言？ 本篇讲解关于如何实现纯后台的打印操作，无前端代码，使用JAVA.AWT类实现。代码分为两个部分：打印直连数据库数据以及打印功能的实现。
二、模拟数据库打印 依赖:
&lt;dependency&gt; &lt;groupId&gt;com.google.zxing&lt;/groupId&gt; &lt;artifactId&gt;core&lt;/artifactId&gt; &lt;version&gt;3.3.0&lt;/version&gt; &lt;/dependency&gt; 1.DemoDto实体类 本demo的打印内容包括：标题、资产名称、型号、部门、责任人、启用日期和二维码图片。类定义如下：
/** * @Author: Mr.ZJW * @Description: 测试数据 * @Date: 2022/4/12 16:42 **/ public class DemoDto implements Serializable { private static final long serialVersionUID = 1L; private String assetName;	//资产名称 private String assetType;	//型号 private String deptName;	//部门 private String responsible;	//责任人 private Date useTime;	//启用日期 private String qrCodePath;	//二维码路径 private String title;	//标签页标题 public DemoDto(String assetName, String assetType, String deptName, String responsible, Date useTime, String qrCodePath, String title) { super(); this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/132a472500b72e5a3ac10274f47cec0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/81e667d16dd67664d1d02cc4b3d9073b/" rel="bookmark">
			qPCR与新冠病毒核酸检测
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		qPCR与新冠病毒核酸检测 这篇文章简单记录一下qPCR核酸定量的原理以及它在新型冠状病毒检测中的应用，分享给身边好奇核酸检测的朋友，参考视频链接：https://www.bilibili.com/video/BV1454y1Q7U2/?spm_id_from=333.788.videocard.0
1. 荧光定量PCR 关于荧光定量PCR基本概念（基线、荧光阈值、CT值、扩增曲线、熔解曲线），
基线（Baseline）：是指在PCR扩增反应的最初数个循环里荧光信号变化不大。接近一条直线，这样的直线即是基线。
荧光域值（threshold）的设定 ：一般将 PCR反应前 15个循环的荧光信号作为荧光本底信号，荧光域值是PCR3—15个循环荧光信号标准差的10倍，荧光域值设定在 PCR扩增的指数期。
CT值 ：表示每个PCR反应管内荧光信号到达设定的域值时所经历的循环数。研究表明，各模板的CT值与该模板的起始拷贝数的对数存在线性关系，起始拷贝数越多，CT值越小。反之亦然。利用已知起始拷贝数的标准品可作出标难曲线其中横坐标代表起始拷贝数的对数。纵坐标代表CT值。因此，只要获得未知样品的CT值，即可从标准曲线上计算出该样品的起始拷贝数。
扩增曲线
PCR过程中，以循环数为横坐标，以反应过程中实时荧光强度为纵坐标所做的曲线
判断曲线是否良好的指标主要有几个方面：
​ 1、曲线拐点清楚，特别是低浓度样本指数期明显，扩增曲线整体平行性好，基线平而无上扬现象，低浓度样本扩增曲线指数期明显。
​ 2、曲线指数期斜率与扩增效率成正比，斜率越大扩增效率越高。
​ 3、标准的基线平直或略微下降，无明显的上扬趋势。
​ 4、各管的扩增曲线平行性好，表明个反应罐的扩增效率相近。
溶解曲线
对PCR产物加热，随着温度的升高，双链扩增产物逐渐解链，导致荧光强度下降，到达某一温度时，会导致大量的产物解链，荧光急剧下降。利用该特点以及不同PCR产物其Tm值的不同，因此使其荧光信号发生迅速下降的温度也不同，可通过此对PCR的特异性进行鉴定。
1.1 荧光定量PCR与常规PCR qPCR(quantitative PCR)：利用荧光信号的变化实时监测PCR扩增反应中每一个循环扩增产物量的变化，并进行定量分析。
常规PCR：对PCR扩增的终产物进行定量和定性的分析，无法对扩增反应实时监测。
1.2 荧光定量PCR如何监测产物量变化 如何实现监控信号：
在PCR体系中添加某种可发光物质，使用信号检测器检测
1） DNA嵌合型分子
sybr green：非特异性结合到DNA双链，产生荧光信号–反应体系内双链DNA浓度越高，荧光信号越强
2） 荧光标记的寡核酸序列
TaqMan 探针：探针5’端存在荧光基团，3’端存在猝灭基团，探针完整存在时不会发出荧光。当PCR反应体系中，探针特异性结合到DNA模版链，在DNA复制过程中，由于DNA聚合酶具有核酸外切酶活性，可以将探针从模版上切割下来，使荧光基团与猝灭基团分离，从而产生荧光。反应体系内，TaqMan探针结合的目标序列越多，荧光信号越强。
SYBR Green染料法Taqman 探针法结构嵌合型核酸染料5’ R — Q3’优势成本低；有熔解曲线生成特异性高；低丰度基因定量可信度高劣势特异性较 Taqman 低成本高；引物二聚体的形成，无法直观判定应用SNP分型、表达定量分析、基因突变检测、病原菌检测病毒检测、病毒载量检测、基因分型、基因突变检测、SNP分型、表达量分析等 1.3 qPCR的扩增曲线 从**“qPCR的扩增曲线”**这张图就可以看到，随着循环数的增加，荧光信号强度逐渐增加
基线期：没有明显的荧光信号指数扩增期线性扩增期平台期（酶活性降低，dNTP被消耗尽） 图1.qPCR的扩增曲线
1.4 绘制标准曲线 梯度稀释的标准品作为PCR反应的底物，做出其qPCR的扩增曲线如下图。
**1）设定荧光阈值：**荧光阈值是PCR 3-15个循环荧光信号标准差的10倍（荧光阈值要设定在PCR扩增的指数期，下面图中的红线就是荧光阈值啦）。
**2）获得Ct值：**qPCR的扩增曲线与荧光阈值的交点，其对应的横坐标（PCR循环数）就是该曲线的Ct值。（图中黑色虚线箭头对应的值）
图2.梯度稀释的标准品做qPCR的扩增曲线
3）做出标准曲线方程
logXo = logM - Ct·log(1+En)（logXo 与 Ct 存在线性关系，为一元一次方程）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/81e667d16dd67664d1d02cc4b3d9073b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ba367723e55b966c4b479608a03b8e86/" rel="bookmark">
			esp32学习笔记（3）——LEDC(PWM)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、LEDC介绍二、使用步骤1.定时器配置2.通道配置3.改变PWM信号 总结 前言 控制led灯渐变
硬件：esp32
idf版本：4.3.2
官方介绍
提示：以下是本篇文章正文内容，下面案例可供参考
一、LEDC介绍 LEDC 通道共有两组，分别为 8 路高速通道和 8 路低速通道。
高速通道模式在硬件中实现，可以自动且无干扰地改变 PWM 占空比。
低速通道模式下，PWM 占空比需要由软件中的驱动器改变。
每组通道都可以使用不同的时钟源。
1、Speed Mode LED PWM 控制器高速和低速模式,高速模式的优点是可平稳地改变定时器设置。
意思就是说高速模式下，如果定时器的设置发生了改变，那么在下一次定时器的溢出中断中就会自动改变；但是低速模式下不会自动改变的。
2、频率和占空比分辨率支持范围：
这个先了解一下占空比和分辨率
占空比：就是高电平接通时间与周期的比
例如：一个PWM频率为1000hz，那周期是1ms，如果高电平时间是100us，那么占空比就是100us:1ms=1:10;
分辨率：就是占空比的最小值
是根据PWM的位数计算的，1：2^位数，如果位数是8，那么PWM的分辨率就是1：255，要是想要达到这个分辨率那就要计数器从0计算到255才行，如果计数值太小，那么他的分辨率就达不到1：255，那PWM的输出频率就变高了。
对于esp32控制器 PWM 占空比设置的分辨率范围较广。比如，PWM 频率为 5 kHz 时，占空比分辨率最大可为 13 位。这意味着占空比可为 0 至 100% 之间的任意值，分辨率为 ~0.012%（1/(2 * 13 )= 1/8192）。PWM 频率越高，占空比分辨率越低
二、使用步骤 1、定时器配置 指定 PWM 信号的频率和占空比分辨率。
2、通道配置 绑定定时器和输出 PWM 信号的 GPIO。
3、改变 PWM 信号 输出 PWM 信号来驱动 LED。可通过软件控制或使用硬件渐变功能来改变 LED 的亮度。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ba367723e55b966c4b479608a03b8e86/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d652dd1f58fa95aeb8c3c92a6a5df1b/" rel="bookmark">
			计算机网络教程 笔记整理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一讲、计算机网络概述 1. 对等网：互连的计算机互相提供和使用资源。
客户机/服务器(C/S)：客户 A 向服务器 B 发出请求服务，而服务器 B 向客户 A 提供服务。
注：服务器具有固定的IP地址和端口号。
2. 交换机：动态地分配传输线路的资源，提高传输效率。
3. 互联网：
4. 因特网：各地的局域网或区域互联网连起来，就构成世界上独一无二的最大的互联网。
第二讲、因特网 1. IP地址：因特网上的主机的标识。（网络号+主机号）
网络
类别
可用IP范围
掩码
私有地址
A
1.0.0.1~
126.255.255.254
255.0.0.0
10.0.0.0~
10.255.255.255
B
128.0.0.1~
191.255.255.254
255.255.0.0
172.16.0.0~
172.31.255.255
C
192.0.0.1~
223.255.255.254
255.255.255.0
192.168.0.0~
192.168.255.255
2.网络号:主机所在的局域网的标识。
3. 计算机网络体系结构：分为 OSI 参考模型和 TCP/IP 分层模型。
两者关系：OSI参考模型是一种理论标准，而TCP/IP分层模型是OSI标准的具体运用。
4. 网关：局域网和外网连接的进出口岸。网关也需要有一个IP地址。
注：网关IP地址的网络号必须是所在局域网的网络号。
5. 掩码：用来判断目标IP地址是否是本网的IP地址的机制。
注：掩码决定了一个IP地址里，网络号占了几个字节。
6. 网络协议的三个要素：语法（怎么做）、语义（做什么）、时序（事件顺序）。
7. 域名：域名的作用和IP地址的作用是一样的，都用于标识因特网上的主机地址。
8. 域名解释：域名翻译成IP地址的过程（DNS的作用）。
9. 域名服务器层级：根域名服务器------顶级域名服务器------权威域名服务器------本地域名服务器。
第三讲、万维网
1. 万维网：分布式超媒体系统，是超文本系统的扩充。（万维网以B/S方式工作）
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d652dd1f58fa95aeb8c3c92a6a5df1b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0c63787fdaa53cba7b037d7b81ad0107/" rel="bookmark">
			Vmware安装Ubuntu Kylin麒麟系统图文
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Vmware官网下载安装 五种系统镜像创建
VMware安装Windows10图文VMware安装MacOS10.14图文Vmware16安装MacOS10.15图文VMware安装Centos图文VMware安装Deepin图文VMware安装Ubuntu Kylin图文 目录
一、麒麟系统下载
1、Ubuntu Kylin官网
2、按提示找到下载页面，点击下载
3、下载对应麒麟系统
4、文件大概3G大小
二、新建麒麟系统虚拟机
1、选择典型（推荐）
2、选择kylin镜像
3、虚拟机用户名
4、虚拟机位置
5、磁盘存储文件类型（建议单个）
6、自定义硬件
7、安装过程-copying files
8、安装过程-downloading packages（大概十分钟）
9、登录页面（密码：root）
三、效果
1、首页
2、虚拟机不能全屏
3、Start菜单
一、麒麟系统下载 1、Ubuntu Kylin官网 优麒麟
2、按提示找到下载页面，点击下载 快速通道链接：
Ubuntu Kylin优麒麟19.04：http://mirrors.cqu.edu.cn/UbuntuKylin_release/ubuntukylin-19.04-enhanced-amd64.iso
银河麒麟 4.0.2桌面版：http://nudt.dl.360tpcdn.com/data/Kylin-4.0.2-desktop-sp2_Community-20171127-x86_64.iso
银河麒麟 4.0.2服务器版：http://nudt.dl.360tpcdn.com/data/Kylin-4.0.2-server-sp1-Community-20170412-x86_64.iso
3、下载对应麒麟系统 4、文件大概3G大小 二、新建麒麟系统虚拟机 1、选择典型（推荐） 2、选择kylin镜像 3、虚拟机用户名 4、虚拟机位置 5、磁盘存储文件类型（建议单个） 6、自定义硬件 7、安装过程-copying files 8、安装过程-downloading packages（大概十分钟） 9、登录页面（密码：root） 三、效果 1、首页 2、虚拟机不能全屏 （通过安装Vmware tools重启即可解决，效果如下！）
VMware虚拟机不能全屏：VMware虚拟机不能全屏_IT小李哥的博客-CSDN博客
3、Start菜单 有用请点赞，养成良好习惯！
疑问交流鼓励请留言！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92335068bbf271c71e4bef5b2718bfbd/" rel="bookmark">
			3D Motion Capture(3D运动捕捉)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、前言
二、项目介绍
1.目的
2.技术要点
(1)读取文件
(2)标记关键节点
(3)读取每一帧图像中关键节点的坐标
(4)Unity中创建3D角色
(5)将人物动作3D化
3.需要做的准备
(1)第三方库
(2)Unity安装与使用
(3)C#了解
三、项目实现步骤
1.Python 部分
(1)读取人物动作并标记关键节点
(2)将坐标值写入文件中保存
2.Unity 部分
(1)创建项目
(2)创建空白来存储 3D 结构部位
(3)创建球体
(4)关键节点和模型的连接
(5)将分散的球体进行连接
四、总体代码
1.Python 代码
2.C# 脚本
(1)球体动画
(2)线条
五、结束语
一、前言 《功夫熊猫》、《忍者神龟》等一些大片想必大家都有了解过，里面的一个个建模角色能够出色的完成人类的动作，那么这些都是怎么实现的呢？今天我就和大家一起从零开始实现对一个视频中的人物的动作进行捕捉并将其添加到建模角色上，让建模出来的虚拟角色也可以像人类一样实现多种多样的行为动作，本次的项目实现起来有点麻烦，感兴趣的小伙伴可以一步步尝试下来，完成之后会学到很多东西呢。
二、项目介绍 1.目的 本次项目的名称为3D运动捕捉，不难猜到是需要对视频或者是摄像头中的运动的人物的姿势进行抓取并以3D的形式展现出来。简单来说就是让人物的动作能够被提取出来，方便后续的研究和观察，也可以用来进行虚拟视频的创作，给观众带来视觉上的刺激。
2.技术要点 (1)读取文件 既然是叫做3D运动捕捉的，那么肯定需要对视频或者摄像头中的人物姿势进行捕捉，第一步当然得需要读取文件，读取到的文件只要是完整的人物运动视频即可，因此如果拍摄视频的摄像头是固定的，那么将会极大地提高我们项目的准确率。
(2)标记关键节点 得到了视频文件，接下来就要标记视频中人物的身体的各个关键节点部位了，这对于Python中的第三方库 cvzone 来说就是小菜一碟。该库对人体的33个关键节点做了记录，读取视频后就能对人物的关键节点进行标记，通过节点坐标的变化我们就可以实现对人物运动姿势的把握了。
(3)读取每一帧图像中关键节点的坐标 我们已经得到了33个关键节点的坐标，每一帧图像中它们的值都会发生变化，因此我们需要将每一帧图像中的坐标值记录下来。记录下来的坐标值我们可以创建一个文件来进行存放，在后续的过程中将会使用到这些坐标点。具体的记录实现方式我将在下面的实现步骤中讲解，希望大家能够耐住性子继续往下看！！
(4)Unity中创建3D角色 使用 Unity 创建一个简单的由33个球体和几条线段组成的角色，Unity 的下载和安装我就不在这里赘述了，大家可以在网上找找，一搜一大堆！！创建3D角色的步骤将会在下面的实现步骤中详细介绍。
(5)将人物动作3D化 主要是在 Unity 中使用 C# 脚本将我们的坐标点的变化连接到创建的3D角色身上，其他的就是调整Unity 中的相机的一些参数使我们的3D形象更加合理‘上镜’即可。
3.需要做的准备 (1)第三方库 在本次项目中我们使用 Python 主要是完成人物运动的捕捉和关键节点的标记，并记录一下简单的坐标点的变化，所以只需要一些基础的视觉库即可：
import cv2 from cvzone.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/92335068bbf271c71e4bef5b2718bfbd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea4708e1353aa271ecd9ec3fd8ebf496/" rel="bookmark">
			达梦数据库安装
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、概述 本文将给大家介绍达梦数据库的安装。
二、环境介绍 达梦正式版需要授权，我们自己搭个测试环境，就选试用版。去达梦官网下载适用自己平台的安装包。我的环境使用的是centos7.9。
三、安装 1. 创建安装用户 groupadd dinstall useradd -g dinstall dmdba echo "dmdba" | passwd dmdba --stdin 2. 修改操作系统限制 cat &gt;&gt; /etc/security/limits.conf &lt;&lt; EOF * soft nproc 16384 * hard nproc 16384 * soft nofile 65536 * hard nofile 65536 EOF 3. 关闭防火墙 systemctl stop firewalld systemctl disable firewalld sed -i "s/SELINUX=enforcing/SELINUX=disabled/g" /etc/selinux/config 4. 安装依赖包 yum install glibc yum install libXp yum install libXt yum install libXtst 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea4708e1353aa271ecd9ec3fd8ebf496/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7a34f78aca358349a617167f45e99684/" rel="bookmark">
			esp32学习笔记（2）——timer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档
文章目录 前言一、定时器配置步骤二、参考部分代码三.运行效果 总结 前言 ESP32 内置 4 个定时器分为两组，每组两个。每个定时器包含一个 16-bit 预分频器和一个 64-bit 可自动重新加载向上／向下计数器。
一、定时器配置步骤 要使用定时器首先要引用库
#include "driver/timer.h" //1、定时器初始化 timer_init(TIMER_GROUP_x,TIMER_x,&amp;timer_config_t;) //参数1、定时器组0-1；2、定时器号0-1；3、定时器配置结构体 typedef struct { timer_alarm_t alarm_en; /*!&lt; 报警使能 */ timer_start_t counter_en; /*!&lt; 计数使能，初始化时通常设置为PAUSE，在开启定时器的时候计数器就会开始计数 */ timer_intr_mode_t intr_type; /*!&lt; 中断模式 *///计数器报警后是否产生中断 timer_count_dir_t counter_dir; /*!&lt;计数方向 */	//向上或者向下计数 timer_autoreload_t auto_reload; /*!&lt; 自动重装载*///计数器报警后是否自动重载指定的值 uint32_t divider; /*!&lt; 预分频值. 2 to 65536. */ } timer_config_t; //2、设置计数器的计数开始值	num:值 timer_set_counter_value(TIMER_GROUP_x, TIMER_x, num); //3、设置报警值 timer_set_alarm_value(TIMER_GROUP_x, TIMER_x, num); //	num：计数多少次进入中断 //	1/(Base_clock/divider/num)=定时器时间 //4、使能定时器中断 timer_enable_intr(TIMER_GROUP_x, TIMER_x); //5、添加中断回调函数 timer_isr_callback_add(timer_group_t group_num, timer_idx_t timer_num, timer_isr_t isr_handler, void *arg, int intr_alloc_flags); //注意：这里第三个参数是中断处理函数的名字，第四个参数是中断处理函数的参数；第五个参数是用于分配中断的标志如果设置为ESP_INTR_FLAG_IRAM，那么handler函数必须用IRAM_ATTR属性声明，它只能调用IRAM或ROM中的函数，不能调用其他定时器api //6、打开定时器 timer_start(); //7、中断处理函数 typedef bool (*timer_isr_t)(void *); //这个中断处理函数的返回应是布尔型bool如果你在回调中调用FreeRTOS函数，你需要根据参数'pxHigherPriorityTaskwoken'的返回值返回true或false。例如，'xQueueSendFromISR'在回调中被调用，如果任何FreeRTos调用的返回值' pxhigherprioritytaskoken是pdTRUE，返回true;否则返回false。 二、参考部分代码 定时器初始化：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7a34f78aca358349a617167f45e99684/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cbd826d1e68065128fed107b5a8db95c/" rel="bookmark">
			8、Java控制结构
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		8、Java控制结构 8.1 顺序控制:从上到下顺序执行 8.2 分支控制（if,else,switch） 单分支结构(if)
双分支结构(if…else)
多分支结构(if…else if…else if…else)(斜体else可以没有)
switch…case(break):若case中没有break,则会产生穿透效应，即后面的case不需要判断也会执行，直至有break为止
switch(表达式)里表达式返回值必须是（byte ,short ,int ,char ,enum ,String）,表达式数据类型必须和case后常量类型一致
Scanner scanner = new Scanner(System.in); System.out.println("请输入月份"); int month = scanner.nextInt(); switch (month){ case 3: case 4: case 5: System.out.println("春天"); break; case 6: case 7: case 8: System.out.println("夏天"); break; case 9: case 10: case 11: System.out.println("秋天"); break; case 12: case 1: case 2: System.out.println("冬天"); break; default: System.out.println("输入不正确"); } 8.3 循环控制（for ,while ,dowhile ,多重循环） for(循环变量初始化 ; 循环条件 ; 循环变量迭代){循环语句;} 循环条件是返回Boolean值的表达式
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cbd826d1e68065128fed107b5a8db95c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eec3f3eca0dab231aa7b58f307de0118/" rel="bookmark">
			题目：javaWeb药房药品管理系统(附源码链接免费下载)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
一、 语言和环境 语言和环境
二、 实现功能 实现功能
三、 数据库设计 数据库设计
五、 评分标准
源码下载地址：
一、 语言和环境 语言和环境 1. 实现语言：JAVA 语言。
2. 环境要求：MyEclipse/Eclipse + Tomcat + MySql。
3. 使用技术：Jsp+Servlet+Jdbc 或 SpringMVC + Spring + Mybatis。
4. 功能要求： 不得 使用第三方工具生成实体类、持久层代码，否则不得分。
二、 实现功能 实现功能 随着一些药房不断的发展，其开展的分店越来越多,现急需开发一套药品管理系统，用于组织管理各
种药品信息，以方便库房人员汇总统计，主要功能如下：
1. 首页默认显示所有药品信息，如图 1 所示，注意事项如下：
（1）按生产日期升序排列。
（2）表格底部居中显示“共为您查询出 XX 条数据”。
2. 鼠标悬停某行数据时，给行添加背景色以方便识别，背景色为#84F2E4，如图 2 所示。
3. 药品管理人员输入药品名称，点击查询，则完成模糊查询，显示查询结果，如图 3 所示。
4. 用户点击删除，则弹出提示框，用户点击确定后，删除选中数据并显示最新数据，如图 4 和图 5 所示。
5. 用户点击“添加药品”超链接,则打开新增药品页面,填写完相关信息后，点击新增按钮，对字段进行非空检测，然后提交药品信息数据到数据库,且页面跳转到列表页面展示最新数据，如图 6 和图 7 所示。 三、 数据库设计 数据库设计 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eec3f3eca0dab231aa7b58f307de0118/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/506bcc16576f3057a4642acd65ccd4ec/" rel="bookmark">
			CAN-位时间与同步-1
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		参考链接：
CAN总线个人知识总结_哔哩哔哩_bilibili
CAN通讯之位定时与同步
目录
同步
CAN为什么需要同步？
同步方式
概念——位时间
概念——采样点
实现——硬同步
实现——再同步/重同步
调整同步的规则
编码
曼彻斯特编码
NRZ编码
同步 同步：通常依靠电平信号的边沿达到同步目的。
CAN为什么需要同步？ 因为CAN总线信号传输是异步串行方式，我们一般通过波特率的设置来使得各个节点发送的信号频率一致。
发送单元以与位时序同步的方式开始发送数据，接收单元根据总线上电平的变化进行同步并进行接收工作。
CAN报文在CAN总线上传输时，两个硬件部分存在相应延迟：
在CAN-BUS上传输造成的延迟——传输路径上的（电缆、驱动器等）相位延迟
在节点上传输造成延迟——发送单元和接收单元存在的时钟频率误差
另外，CAN采用NRZ编码，这种编码方式能充分利用带宽，减小电平跳变引起的干扰，但却不具备时钟功能。（关于NRZ的原理介绍在本文末尾）。上面两种延迟无法使用当前编码方式解决。
因此CAN需要采用额外的定时方法来达到收发信号的同步。
因此接收单元通过硬件同步或者再同步的方法调整时序进行接收。
同步方式 CAN有3种同步方式：位填充，硬同步，重同步。
位填充：就是在检测到总线上有连续5个相同电平时，CAN控制器自动插入一个相反电平。除了用来做同步定时，也可用于错误校验。
硬同步：接收节点检测出帧起始位（SOF）时，调整自己的SS同步段位置，使其与发送节点的帧起始位SS一致，调整宽度不限。
重同步/再同步：接收节点检测出除SOF位以外的其他位时进行的同步调整，接收端调整PBS相位缓冲段(PBS1,PBS2)。
下面通过对位时间、采样点的介绍，描述硬同步、重同步的实现方法。
概念——位时间 一个bit是信号的最小单位，但1bit也是持续了一段时间的。又称位时间。
一个位分为4段，每个段又由若干个Tq（Time Quantum）构成，这称为位时序。
概念——采样点 在位时间内是总线上的电平值是连续值，而我们读取的值只是某个时刻的离散数值。
那么将哪个时刻的电平值，作为我们最终的读取值，就是采样点的选取问题。
目前的采样点，设置在PBS1结束处。
实现——硬同步 硬同步是指在总线空闲状态，接收节点检测出帧起始位（SOF）时，会调整当前位的同步段（SS）与发送节点的帧起始位SS段一样，调整宽度不限。
实现的具体步骤: 1）发送节点Node_A在发送SOF位时，SOF位的下降沿在SS段； 2）这时接收节点Node_B发现自己当前位的SS段和发送节点SOF位的SS段不同步。也就是说当Node_A 产生SOF位SS段时，Node_B的当前位的SS段已经在5个Tq之前产生了； 3）这样接收节点Node_B硬将自己当前位的SS段拉到与SOF位的SS段同步。
实现——再同步/重同步 再同步是指接收节点检测出除SOF位以外的其他位时进行的同步调整。
再同步会通过加长PBS1段，或缩短PBS2段来调整同步，以保证采样点的准确。
对于PBS1，PBS2的调整长度是有限制的，即SJW。
概念——SJW
同步跳转宽度（SJW）是指PBS1和PBS2再同步时允许跳转的最大宽度，其必须满足以下2个条件：
SJW必须小于PBS1和PBS2的最小值；
SJW最大值不能超过4。
下面是重同步的两种情况：
情况1：PBS1段加长（发的晚，收的早）
步骤： 1）发送节点Node_A比接收节点Node_B的时间慢了，也就是说Node_A当前位的ss段产生的时候，Node_B 当前位的SS段已经在2个Tq之前产生了； 2）这时接收节点Node_B就将PBS1延长2个Tq的时间； 3）这样Node_A当前位的采样点就和Node_B的采样点同步了。 情况2：PBS2段缩短（发的早，收的晚）
1）发送节点Node_A当前位的SS段诞生2Tq时长之后，接收节点Node_B的当前位才产生SS段； 2）这时接收节点Node_B当前位的PBS2段缩短， 3）这样就导致接收节点Node_B的下一位能够提前2个Tq，从而Node_B的下一位采样点和Node_A下一位 的采样点能够同步。 调整同步的规则 硬同步和再同步遵从如下规则。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/506bcc16576f3057a4642acd65ccd4ec/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d1bf428477a41a117bd1ec23d967605/" rel="bookmark">
			Vue项目修改第三方依赖中的方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前置知识 在前端工程化项目中，一定会存在一个package.json 的文件，它就像一个大管家，管理着这个项目的相关信息。其中会dependencies会存储该项目的依赖关系，当我们初始化一个项目时，会npm包管理器会自动把这些依赖下载到node_modules 文件夹内。
需求来源 公司的项目中使用到了某个第三方的库，但该库有个方法Fun有一丝丝不符合项目的需求，因此萌发修改第三方依赖库A方法的想法。
修改方法 直接拷贝该第三方库的所有文件放置到自己的项目中 (不推荐)。 缺点: 以我自身需求为例，我本意只想改其中的一个方法Fun， 但却拷贝了整个依赖文件，一下子就增加了项目的总体大小。优点: 拷贝整个依赖到本项目中，修改起来方便—&gt;简单方便且快捷。 使用Vue的extends来继承第三方依赖库 缺点: 需要一同把第三方组件使用到的依赖放置到本项目中。优点: 对本项目改动小 实现步骤 这里只介绍方法2的步骤
首先在找到项目存储组件的目录，一般都是components文件夹,并在该目录下新建一个组件A。在A中引入第三方依赖，并让A继承该依赖 import dragTreeTable from "drag-tree-table"; export default { name: "dragTreeTable2", extends: dragTreeTable, components: { row, column, space, }, }; &lt;/script&gt; 如果第三方依赖有使用到其他依赖，即一并引入即可(可在node_modules目录下找到该依赖，便可以查看其是否有引入其他文件)。在methods中重写我们需要改动的方法Fun即可 methods: { filter(x, y) { //重写的内容 }, }, 在需要使用到的地方，引入我们组件创建的组件A，会发现我们已经更改成功第三方依赖库的内容的。 总结 其实就是使用了extends 来继承了第三方依赖，然后重写该依赖内部的方法，达到修改第三方依赖中的东西的一个小知识点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ed089a7545f04c6b3eb0c1908266c7d/" rel="bookmark">
			Rstudio运行时一直报错说找不到对象
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Error in barplot(name) : 找不到对象’name’ 其实这种情况可能不是代码问题而是自己选择运行时的错误
在这里插入图片描述
Rstudio与其他计算机语言编译有点不同 如果你代码不全部选中 点击Run运行代码 它只会运行光标的位置那一行
所以要全部选中再运行 或者把光标放置在第一行一步一步运行
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d6c1ce434b2584b5878935ef87fb5029/" rel="bookmark">
			【复习巩固】OSI七层模型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【复习巩固】OSI七层模型 文章目录 【复习巩固】OSI七层模型1.解释2.分层3.OSI模型通信过程4.总结 1.解释 OSI七层模型 （Open System Interconnect），全称为开放系统互连参考模型，是国际标准化组织(ISO)和国际电报电话咨询委员会(CCITT)联合制定的开放系统互联参考模型，为开放式互联信息系统提供了一种功能结构的框架。
2.分层 应用层
功能：网络服务与最终用户的一个接口。
表示层
功能：数据的表示、安全、压缩。
会话层
功能：建立、管理、终止会话。
（在五层模型中，会话层和表示层被合并到应用层内）
传输层
功能：定义传输数据的协议端口号，以及流控和差错校验。
设备：防火墙
数据单元：数据段
网络层
功能：进行逻辑地址寻址，实现不同网络之间的路径选择。
设备：路由器
数据单元：数据包
数据链路层
功能：建立逻辑连接、进行硬件地址寻址、差错校验等功能。
设备：交换机
数据单元：数据帧
物理层
功能：建立、维护、断开物理连接。
设备：网卡、网线、光纤、集线器、中继器、调制解调器
数据单元：比特流
3.OSI模型通信过程 封装（encapsulate/encapsulation）：数据要通过网络进行传输，要从高层一层一层的向下传送，如果一个主机要传送数据到别的主机，先把数据装到一个特殊协议报头中，这个过程叫——封装。
解封装：封装的逆向过程。
比如：设备A给设备B发送信息”你好“
在设备A的应用层中输入”你好“，经过表示层翻译压缩成计算机语言，再到会话层建立会话，之后传输层将上层数据加上TCP头部，经过网络层再加上IP头部，在数据链路层加上MAC头部，最后经过物理层的传递。
设备B物理层接收到数据，传递给数据链路层开始解封装的过程，在数据链路层中减MAC头部信息，同样，网络层减IP头部，传输层减TCP头部，再经过会话层、表示层，解压缩、翻译为人的语言，最后在应用层中表现出”你好“给用户4.。
4.总结 以上，了解到OSI七层模型的分层和作用，在通信过程封装和解封装中，数据经过OSI模型中的每一层，需知道在经过每一层时，会做哪些事儿。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f1c431e9bd3bdb07e57f62a950bffec5/" rel="bookmark">
			iOS input[type=checkbox]打勾后不显示选中状态的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		webkit内核浏览器样式设置的问题：
原因是，-webkit-appearance样式属性，被设置为了none或者auto。
解决办法：将-webkit-appearance属性设置为checkbox。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/689af36b41c274a473a70c60ed14454c/" rel="bookmark">
			无线渗透----扫描附近WiFi（windows系统）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一.WiFi扫描
1.WirelessMon软件介绍
2.WirelessMon软件使用
二.Windows破解WiFi密码
1.以管理员方式打开cmd
2.查看连接过的wifi
3.输入破解命令
4.找到wifi密码
5.破解多个wifi密码
6.找到对应文件查看wifi密码
一.WiFi扫描 1.WirelessMon软件介绍 WirelessMon是一款无线网络扫描工具，它可以帮助用户扫描附近的无线信号，除了WiFi，蓝牙等普通信号之外，移动网络的基站信号也能被这款软件搜索，当用户搜索到这些信号后，用户可以直接连接没有加密的网路
2.WirelessMon软件使用 WirelessMon软件启动后，默认界面位“概要”界面，如图
在这个界面中，使用者可以看到无线网卡所能搜索到的所有信号及其信息
状态：表明所搜索到信号位“所关联的AP”，“可以连接使用的AP”还是“无法连接使用的AP”三种状态
SSID：搜索到信号的SSID
信道：信号所占用信道
安全：AP是否进行加密
RSSI：Sta所接收到的信号强度（越接近0信号越强）
MAC地址：所搜索到信号源设备的MAC地址
二.Windows破解WiFi密码 使用windows cmd中netsh破解wifi密码，想用netsh，必须已经连接过这个wifi才能破解
1.以管理员方式打开cmd 2.查看连接过的wifi netsh wlan show profile 3.输入破解命令 netsh wlan show profile name="$" key=clear $为要破解的wifi名称 4.找到wifi密码 在安全设置----关键内容中
5.破解多个wifi密码 netsh wlan export profile folder="$" key=clear $为文件存放路径
6.找到对应文件查看wifi密码 name:wifi名称
authentication：wifi加密方式
keyMaterial：wifi密码 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d64ad79427f33fb31f0be8444317d6f1/" rel="bookmark">
			【数据结构】复数的建立、求和、求积、求其实部虚部
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义一个表示复数的抽象数据类型
typedef struct //构建复数框架 { float Realpart; //实部 float Imagepart; //虚部 }Complex; 本文解决以下编程问题：
1、编写函数，输入实部和虚部建立一个复数；
2、编写函数，求两个复数的和；
3、编写函数，求两个复数的积；
4、编写两个函数，分别求复数的实部和虚部。
一、各函数具体展示：
编写函数，输入实部和虚部建立一个复数；
Complex Create(float x,float y) //用输入的实部、虚部建立一个复数 { Complex Cx; Cx.Realpart=x; Cx.Imagepart=y; return Cx; } 编写函数，求两个复数的和；
Complex Add(Complex C1,Complex C2) //求两个复数之和 { Complex sum; //定义一个Complex结构体类型的变量sum sum.Realpart=C1.Realpart+C2.Realpart; sum.Imagepart=C1.Imagepart+C2.Imagepart; return sum; } 编写函数，求两个复数的积；
Complex Multiply(Complex C1,Complex C2) //求两个复数之积 { Complex z; z.Realpart=C1.Realpart*C2.Realpart-C1.Imagepart*C2.Imagepart; z.Imagepart=C1.Realpart*C2.Imagepart+C1.Imagepart*C2.Realpart; return z; } 编写两个函数，分别求复数的实部和虚部。
float GetReal(Complex C) //取实部 { return C.Realpart; } float GetImage(Complex C) //取虚部 { return C.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d64ad79427f33fb31f0be8444317d6f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e030a015de57ebb56c186bb56f99a52c/" rel="bookmark">
			【数据结构】顺序表的创建、插入、删除、合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义一个顺序表结构的学生成绩表结构体
typedef struct{ int score[MAXSIZE];	//学生成绩 int *elem;	//存储空间的基地址 int length;	//学生成绩表中当前记录个数 }Stu; 本文解决以下编程问题：
1、编写函数，创建一个顺序表（数据自拟）；
2、编写函数，在顺序表的指定位置插入一个元素；
3、编写函数，在顺序表的指定位置删除一个元素；
4、编写函数，将两个有序顺序表合并成一个新的有序顺序表；
一、各函数具体代码如下： 写在前面：由于题目作答无法将顺序表内的元素显示在控制台上，故预先造两个函数——
int InitList(Stu &amp;L)、 void PrintList(Stu &amp;L)；
int InitList(Stu &amp;L)	//初始化数据表 { L.elem=new int[MAXSIZE]; if(!L.elem) exit(OVERFLOW); L.length=0; return OK; } void PrintList(Stu &amp;L)	//打印当前数据 { cout&lt;&lt;"当前顺序表所有元素:"; for (int i = 0; i&lt;L.length; i++) { cout&lt;&lt;L.score[i]&lt;&lt;" "; } cout&lt;&lt;endl; } 编写函数，创建一个顺序表（数据自拟）；
void CreateList(Stu &amp;L,int n) { if(n&lt;1||n&gt;MAXSIZE) cout&lt;&lt;"创建失败！请输入合法长度！"&lt;&lt;endl; cout&lt;&lt;"长度合法，请输入各项数据！"&lt;&lt;endl; for(int i=0;i&lt;n;i++) { cin&gt;&gt;L.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e030a015de57ebb56c186bb56f99a52c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44eba8a60bc994155e95d47175b8a41a/" rel="bookmark">
			【数据结构】单链表的创建、插入、删除及合并
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		定义一个链表结构的带头结点的结构体
typedef struct lst{ int data; struct lst *next; } LNode,*LinkList; 本文解决以下问题：
1、编写函数，创建一个带头结点的单链表（数据自拟）；
2、编写函数，在单链表的指定位置插入一个元素；
3、编写函数，在单链表的指定位置删除一个元素；
4、编写函数，将两个有序链表合并成一个新的有序链表；
一、各函数代码如下：
写在前面：由于题目要求无法将链表内的元素显示在控制台上，故预先造一个遍历链表中所含元素的函数——
void myprint(LNode *head)//显示单链表中各数据，以实现用户交互
编写函数，创建一个带头结点的单链表（数据自拟）；
LNode *mycreat()//创建单链表 { int m=0; LNode *head=NULL,*p=NULL,*q=NULL; head=new LNode;	//定义头指针并分配内存 q=head; cout&lt;&lt;"Wonder creating a new list,please input (int)data:(End with -1)"&lt;&lt;endl; cin&gt;&gt;m; while(m!=-1){ p=new LNode;	//开辟一个新的内存 q-&gt;next=p;	//单链表的首元结点指向该地址 p-&gt;data=m; q=p; cin&gt;&gt;m; } q-&gt;next=NULL; return head; } 编写函数，在单链表的指定位置插入一个元素；
void myinsert(LNode *head,int i,int m)//插入，i为插入位置，m为待插入元素 { LNode *p=NULL,*s=NULL; int j=0; p=head; while(p!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44eba8a60bc994155e95d47175b8a41a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/884a02fdc590301dd8f7e5fd6ec9f77c/" rel="bookmark">
			k8s——ingress
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k8s——ingress Ingress简介service的作用外部访问k8s集群内的服务 Ingress组成ingressingress-controller Ingress工作原理部署nginx-ingress-controller部署ingress-controller pod及相关资源修改clusterRole资源配置 ingress暴露服务的方式采用方式二:DaemonSet+HostNetwork+nodeselector指定nginx-ingress-controller运行在node02节点修改Deployment为Daemonset,指定节点运行，并开启 hostNetwork所有node节点上传nginx-ingress-controller镜像压缩包ingree.contro.tar.gz.到/opt/ingress目录，并解压和加载镜像启动nginx-ingress-controller创建ingress规则创建一个deployment和svc创建ingress 做端口映射并访问测试查看nginx-ingress-controller 采用方式三：Deployment+NodePort模式的Service下载nginx-ingress-controller和ingress-nginx暴露端口配置文件在所有node节点上传镜像包ingress-controller-0.30.0.tar到/opt/ingress-nodeport目录，并加载镜像启动nginx-ingress-controller创建deployment、service和ingress的yaml资源做端口映射并访问测试 ingress http代理访问虚拟主机ingress https代理访问创建工作目录创建ssl证书创建secret资源进行存储创建deployment、service和ingress的yaml资源做端口映射并访问测试 nginx进行BasicAuth（访问前输入用户和密码）创建工作目录生成用户密码文件，创建secret资源进行存储创建ingress资源做端口映射并访问测试 nginx进行重写配置说明编写yaml文件做端口映射并访问测试 Ingress简介 service的作用 对集群内部，它不断跟踪pod的变化，更新endpoint中对应pod的对象，提供了ip不断变化的pod的服务发现机制对集群外部，他类似负载均衡器，可以在集群内外部对pod进行访问 外部访问k8s集群内的服务 NodePort:测试环境使用还行，当有几十上百的服务在集群中运行时，NodePort的端口管理就是个灾难LoadBalancer:受限于云平台，且通常在云平台部署LoadBalancer还需要额外的费用Ingress:可以简单理解为service的service，它其实就是一组基于域名和URL路径，把用户的请求转发到一个或多个service的规则 Ingress组成 ingress ingress是一个APr对象，通过yaml文件来配置，ingress对象的作用是定义请求如何转发到service的规则，可以理解为配置模板ingress通过http或https暴露集群内部service，给service提供外部URL、负载均衡、SSL/TLs能力以及基于域名的反向代理。ingress要依靠ingress-controller来具体实现以上功能 ingress-controller ingress-controller是具体实现反向代理及负载均衡的程序，对ingress定义的规则进行解析，根据配置的规则来实现请求转发ingress -controller并不是kes自带的组件，实际上ingress-controller只是一个统称，用户可以选择不同的ingress-controller实现，目前，由k8s维护的ingress-controller只有google云的ccz与ingress-nginx两个，其他还有很多第三方维护的ingres-controller，具体可以参考官方文档。但是不管哪一种ingress-controller，实现的机制都大同小异，只是在具体配置上有差异一般来说，ingress-controller的形式都是一个pod,里面跑着daemon程序和反向代理程序。daemcn负责不断监控集群的变化，根据ingress对象生成配置并应用新配置到反向代理，比如ingress -nginx就是动态生成nginx配置，动态更新upstrea，并在需要的时候reloada程序应用新配置。为了方便，后面的例子都以k8s官方维护的ingress-nginx为例Ingress-Nginx github 地址:https://github.com/kubernetes/ingress-nginx**
Ingress-Nginx官方网站:https:/kubernetes.github.io/ingress-nginx/
5.总结: ingress-controller才是负责具体转发的组件，通过各种方式将它暴露在集群入口，外部对集群的请求流量会先到 Ingress工作原理 ingress-controller通过和 kubernetes APIServer 交互，动态的去感知集群中ingress规则变化然后读取它，按照自定义的规则，规则就是写明了哪个域名对应哪个service，生成一段nginx配置再写到nginx-ingress-controller的pod里，这个ingress-controller的pod里运行着一个nginx服务，控制器会把生成的nginx配置写入/etc/nginx.conf文件中然后reload一下使配置生效。以此达到域名区分配置和动态更新的作用 部署nginx-ingress-controller 部署ingress-controller pod及相关资源 1.mkdir /opt/ingress 2.cd /opt/ingress ========================================================== 官方下载地址： wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/nginx-0.25.0/deploy/static/mandatory.yaml 上面可能无法下载，可用国内的gitee 3.wget https://gitee.com/mirrors/ingress-nginx/raw/nginx-0.25.0/deploy/static/mandatory.yaml wget https://gitee.com/mirrors/ingress-nginx/raw/nginx-0.30.0/deploy/static/mandatory.yaml #mandatory.yaml文件中包含了很多资源的创建，包括namespace、configMap、role，ServiceAccount等等所有部署ingress-controller需要的资源 修改clusterRole资源配置 vim mandatory.yaml .... - apiGroups: - "" resources: -services verbs: - get - list - watch - apiGroups: - "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/884a02fdc590301dd8f7e5fd6ec9f77c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f80633849489feca1445e50e17c3ecd/" rel="bookmark">
			k8s——污点、容忍&#43;3个存储卷（emptyDir、hostpath和nfs）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		k8s——污点、容忍+3个存储卷（emptyDir、hostpath和nfs） 污点(Taint)和容忍(Tolerations)污点(Taint)概念污点的组成格式effect支持如下三个选项master上的NoSchedule污点node上设置污点去除污点污点实例测试 容忍(Tolerations)概念测试污点在设置污点的基础上设置容忍容忍的其他注意事项node升级时，设置污点的流程 Pod启动阶段（相位 phase）pod启动过程phase的状态故障排除步骤对节点执行维护操作:删除节点上的pod数据将Node标记为不可调度的状态用drain删除pod数据将Node标记为可调度的状态 存储卷emptyDir存储卷hostPath存储卷nfs共享存储卷另起服务器nfs01节点在master节点和node节点配置映射主节点操作在nfs服务器额外写网页文件 污点(Taint)和容忍(Tolerations) 污点(Taint) 概念 节点亲和性，是Pod的一种属性（偏好或硬性要求），它使Pod被吸引到一类特定的节点。Taint则相反，它使节点能够排斥一类特定的PodTaint和Toleration相互配合，可以用来避免Pod被分配到不合适的节点上。每个节点上都可以应用一个或多个taint ，这表示对于那些不能容忍这些taint的Pod，是不会被该节点接受的。如果将toleration应用于Pod上，则表示这些 Pod 可以（但不一定）被调度到具有匹配taint的节点上使用kubectl taint命令可以给某个Node节点设置污点，Node被设置上污点之后就和 Pod 之间存在了一种相斥的关系，可以让Node拒绝 Pod 的调度执行，甚至将Node已经存在的Pod驱逐出去 污点的组成格式 key=value:effect 每个污点有一个key和value作为污点的标签，其中value可以为空，effect描述污点的作用 effect支持如下三个选项 ●NoSchedule：表示 k8s 将不会将 Pod 调度到具有该污点的 Node 上 ●PreferNoSchedule：表示 k8s 将尽量避免将 Pod 调度到具有该污点的 Node 上 ●NoExecute：表示 k8s 将不会将 Pod 调度到具有该污点的 Node 上，同时会将 Node 上已经存在的 Pod 驱逐出去 master上的NoSchedule污点 master 就是因为有 NoSchedule 污点，k8s 才不会将 Pod 调度到 master 节点上 kubectl describe node master01 node上设置污点 #设置污点 kubectl taint nodes node01 key1=value1:NoSchedule #节点说明中，查找 Taints 字段 kubectl describe node node01 去除污点 #去除污点 kubectl taint nodes node01 key1:NoSchedule- #节点说明中，查找 Taints 字段 kubectl describe node node01 污点实例测试 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f80633849489feca1445e50e17c3ecd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9d05e62ba211c81ab2f44a8be847bcb8/" rel="bookmark">
			常见的大数据项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大数据项目最重要的两个特点是数据量大，实时性要求强，这也是与小数据和传统数据处理方式的最重要的区别。
大数据领域的主打项目，如下所示：
大数据领域的项目，主要分成以下几个部分
数据的整合，也就是数据的输入和存储。数据的处理，包括流的处理以及专业的大数据处理，离线和实时处理，可视化处理等。数据的快速查询，ETL是典型。数据集群提供服务，也就是集成上面一种或者多种，给用户提供服务。 说到底，也是计算机的设计思想，I/0，存储，处理。只不过数据量变大之后，原有的技术已经不能够快速、实时的处理。所以采用了数仓进行存储，采用了分布式的方式进行计算。
所以，大数据处理的核心和难点也就在于两个方面，一个是如何集成数据，另一个是如何分散处理数据。这也就造就了大数据的职业方向，一个是数仓的建设，另一个是分布式计算和实时计算。当然数据的价值，体现在你能挖掘出来多少价值(废话文学)，所以数据挖掘和数据分析这种岗位也是大数据的重要方向。
参考文献 本文是参照大数据工程师必须掌握的7个项目进行的总结。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/422240741036937043a6159620ff237f/" rel="bookmark">
			怕你不信，100行极简原生html现实3D雪花飘飘动效
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		纯原生JS结合HTML5 Canvas实现逼真的大雪纷飞效果。
用到的snow_1.png是一张很小的雪花图片，通过如下js代码在canvas里面画出来，右键保存备用。
function drawPic() { canvas.width = 20; canvas.height = 20; var grd = context.createRadialGradient(10, 10, 1, 10, 10, 10); grd.addColorStop(0, 'white'); grd.addColorStop(1, 'rgba(255,255,255,0)'); context.fillStyle = grd; context.fillRect(0, 0, canvas.width, canvas.height); } 背景图是在百度图片随便下载了一张雪地图片：
100行完整html代码:
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;大雪纷飞&lt;/title&gt; &lt;meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"&gt; &lt;style&gt; html,body{ height: 100%; margin: 0; padding: 0; } body{ background: url("images/bg.jpg") no-repeat center center; background-size: cover; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;canvas id="main"&gt;&lt;/canvas&gt; &lt;/body&gt; &lt;script&gt; window.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/422240741036937043a6159620ff237f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9bc0ec5bdc9a35f2daf440f6ed353f2d/" rel="bookmark">
			‘.‘ 不是内部或外部命令，也不是可运行的程序 或批处理文件。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Win10命令行执行某个命令报错：'.' 不是内部或外部命令，也不是可运行的程序 或批处理文件。
刚遇到这个错误一头雾水，纳尼，怎么不能执行bat文件了？ 赶紧看下文件是否有执行权限，有的！
报错缘由是，我在一个新目录下准备测试一下babel的polyfill转换功能，配置就绪之后在cmd命令行敲下：
./node_modules/.bin/babel src --out-dir lib '.' 不是内部或外部命令，也不是可运行的程序 或批处理文件。 换成babel.cmd还是一样的错误。
Win10系统是将"." 当成要执行的命令了…
突然抱着试一试的心态将目录分隔符换成Windows默认的\问题解决。
.\node_modules\.bin\babel.cmd src --out-dir lib Successfully compiled 1 file with Babel. 好吧，有点无语（win10系统这么死板…），确实也有点无聊–。–
根据评论区@小红帽!=大灰狼的提醒，补充一下：
如果是将路径写在配置文件中，要写双\\。 因为，程序在读取这种字符串配置的时候，\\才表示一个\，因为前一个\本身是作为一个转义字符。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9633e659414f7eb4cc8134d07ca3f7ee/" rel="bookmark">
			Error in v-on handler: “ReferenceError:xxx is not defined
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一级标题 [Vue warn]: Error in v-on handler: “ReferenceError: xxx is not defined” found in.
在网上查了一下，发现大家大部分都是未将xxx传入该组件。 参考：https://blog.csdn.net/qq_41672008/article/details/89203991
或者是因为子传父中 父元素接受数据的时候没有传参数。 参考：https://blog.csdn.net/xiaoerlang715/article/details/94382221
或者是未引用该组件 参考：https://blog.csdn.net/new_Petrichor/article/details/120431079?spm=1001.2101.3001.6661.1&amp;utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1.pc_relevant_antiscanv2
而本人的均不是上述情况，本人的“xxx”为自己定义的变量，由于在methods中使用该变量时，忘记填加"this."而导致出错，添加上this.即可解决问题
moreChsCountAddBtn(){ this.moreChsCount+=1; this.moreChs.title.push("moreChs_title_"+moreChsCount) this.moreChs.content.push("moreChs_content_"+this.moreChsCount) this.moreChs.moreChsOptions.push("moreChs_options_A_"+this.moreChsCount) this.moreChs.moreChsOptions.push("moreChs_options_B_"+this.moreChsCount) this.moreChs.moreChsOptions.push("moreChs_options_C_"+this.moreChsCount) this.moreChs.moreChsOptions.push("moreChs_options_D_"+this.moreChsCount) this.moreChs.options_answer.push("moreChs_answer_"+this.moreChsCount) console.log(this.moreChs.title) console.log(this.moreChs.moreChsOptions) console.log(this.moreChs.options_answer) console.log(this.moreChsCount) }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0a97b9572ada41e5762b6b7f3c51087a/" rel="bookmark">
			openFeign学习笔记(一)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		OpenFegin Feign是什么？openFeign是什么？Feign和openFeign有什么区别？环境搭建创建服务提供者创建服务消费者1、添加依赖2、添加注解3、新建openFeign接口4、新建一个Controller调试 openFeign如何传参？1、传递JSON数据2、POJO表单传参3、URL中携带参数4、普通表单参数 超时处理1、设置Ribbon的超时时间2、设置openFeign的超时时间 如何开启日志增强？1、配置类中配置日志级别2、yaml文件中设置接口日志级别3、演示效果 如何替换默认的httpclient？1、添加ApacheHttpClient依赖2、配置文件中开启3、如何验证已经替换成功？ 如何通讯优化？如何熔断降级？1、添加Sentinel依赖2、配置文件中开启sentinel熔断降级3、添加降级回调类4、添加fallback属性 Feign是什么？ Feign旨在使得Java Http客户端变得更容易。Feign集成了Ribbon、RestTemplate实现了负载均衡的执行Http调用，只不过对原有的方式（Ribbon+RestTemplate）进行了封装，开发者不必手动使用RestTemplate调服务，而是定义一个接口，在这个接口中标注一个注解即可完成服务调用，这样更加符合面向接口编程的宗旨，简化了开发。
openFeign是什么？ 简单点来说：OpenFeign是springcloud在Feign的基础上支持了SpringMVC的注解，如@RequestMapping等等。OpenFeign的@FeignClient可以解析SpringMVC的@RequestMapping注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务。
Feign和openFeign有什么区别？ 环境搭建 注册中心使用Nacos，创建个微服务，分别为服务提供者Produce，服务消费者Consumer。
创建服务提供者 既然是微服务之间的相互调用，那么一定会有服务提供者了，创建openFeign-provider9005，注册进入Nacos中，配置如下：
server: port: 9005 spring: application: ## 指定服务名称，在nacos中的名字 name: openFeign-provider cloud: nacos: discovery: # nacos的服务地址，nacos-server中IP地址:端口号 server-addr: 127.0.0.1:8848 management: endpoints: web: exposure: ## yml文件中存在特殊字符，必须用单引号包含，否则启动报错 include: '*' 注意：此处的spring.application.name指定的名称将会在openFeign接口调用中使用。
创建服务消费者 新建一个模块openFeign-consumer9006作为消费者服务，步骤如下。
1、添加依赖 除了Nacos的注册中心的依赖，还要添加openFeign的依赖，如下：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 2、添加注解 添加注解@EnableFeignClients开启openFeign功能
@SpringBootApplication @EnableDiscoveryClient @EnableFeignClients public class OpenFeignConsumer9006Application { public static void main(String[] args) { SpringApplication.run(OpenFeignConsumer9006Application.class, args); } } 3、新建openFeign接口 新建一个openFeign接口，使用@FeignClient注解标注，如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0a97b9572ada41e5762b6b7f3c51087a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39e2a199a3d300d99cfc30452e2d5ca2/" rel="bookmark">
			《入坑百度飞桨OCR及打包代码到开源库》
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		常常听到很多人说python这种语言的奇特之处就是你不用再自己造轮子，你只需要懂得车子的构架，就能完整的造出来一辆车子，在此次入坑百度飞桨之后我才深深的理解到这句话的涵义。于是此次想分享一下本人在使用百度飞桨以及打包自己使用百度飞桨中字符识别模块paddleocr的一些踩坑经验，由于公司电脑的一些局限性，导致在公司做的时候坑确实挺多的，不过在公司填完各种坑之后就很顺利在自己的电脑上配置好环境，以下就是我本次带来的百度飞桨环境配置和一键预测字符demo：
一、配置百度飞桨环境、安装paddlepaddle、paddlehub、paddleocr等环境。
二、使用百度飞桨中字符识别模块paddleocr进行字符的一键预测。
三、打包自己的一键预测ocr图形界面demo，测试是否打包成功。
一、配置百度飞桨环境 1、安装paddlepaddle
进入百度飞桨官网中选择自己的电脑环境进行安装
图1-1百度飞桨安装页面 使用上面的命令进行安装paddlepaddle环境，接着在命令行中输入python进入python解释器，接着输入import paddle，再输入paddle.utils.run_check()，查看环境是否安装成功，若安装成功则显示如下：
图1-2 查看百度飞桨是否安装成功 2、安装paddlehub
安装paddlepaddle成功后可以直接使用命令pip install -i https://mirror.baidu.com/pypi/simple paddlehub 安装，接着在python解释器里导入paddlehub，输入padlehub.server_check()，安装成功信息如下：
图1-3 查看paddlehub是否安装成功 3、安装paddleocr
使用 pip install -i https://mirror.baidu.com/pypi/simple paddleocr安装，一般情况下会报出这个错：
图1-4 安装paddleocr报错信息 这是由于我们的电脑里缺少了VC++ 14.0这个东西，到下面链接去下载一个并安装就可以了。Download Visual Studio Tools - Install Free for Windows, Mac, LinuxDownload Visual Studio IDE or VS Code for free. Try out Visual Studio Professional or Enterprise editions on Windows, Mac.https://visualstudio.microsoft.com/downloads/ 安装好 VS Code 之后再使用上面命令进行安装，导入paddleocr模块，输入paddleocr.__version__，进行测试，若显示如下信息，则安装成功。
图1-5 测试paddleocr是否安装成功 二、使用百度飞桨模块paddleocr进行字符一键预测 这里就使用paddleocr进行字符的一键预测，参考paddleocr官方文档，可以使用以下代码进行字符进行一键预测：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39e2a199a3d300d99cfc30452e2d5ca2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3bb02e95590e87085c685cc667f9e744/" rel="bookmark">
			hashcat跑握手包笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		可以在wireshark使用eapol过滤找到握手包
在hashcat站转换格式:
hashcat cap2hccapx - advanced password recovery
hashcat.exe -m 22000 [.hc2200文件的路径] [字典路径]
-D [设备编号] 指定设备
栗子:hashcat.exe -m 22000 ./work/test.hc22000 ./work/data1.txt -D 1
--session [会话名称] 设置会话名称用于恢复进度
栗子:hashcat.exe -m 22000 ./work/test.hc22000 ./work/data1.txt -D 1 --session session_name
恢复会话:
hashcat.exe --session [会话名称] --restore
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7a56a79dabf60b6b124ba07bb58f95f/" rel="bookmark">
			npm安装包时报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如图所示，直接在安装包的后面加上 --legacy-peer-deps
直接成功
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/23f2627cc3eebb9acd87458b5328665d/" rel="bookmark">
			国产高分系列卫星平台介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
高分专项
高分一号（GF-1）
高分二号（GF-2）
高分三号（GF-3)
高分四号（GF-4）
高分五号（GF-5)
高分六号（GF-6）
高分七号（GF-7）
高分八号（GF-8）
高分九号（GF-9）
高分十号（GF-10）
高分十一号（GF-11）
高分十二号（GF-12）
高分十三号（GF-13）
高分十四号（GF-14）
高分专项 高分专项是指高分辨率对地观测系统，它是国务院发布的《国家中长期科学和技术发展规划纲要(2006-2020年)》中确定的16个重大专项之一，高分专项建设目标如下： 1、建设基于卫星、平流层飞艇和飞机的高分辨率先进观测系统，与其他观测手段结合，形成全天候、全天时、全球覆盖的对地观测能力；
2、整合并完善地面资源，建立数据与应用专项中心；到2020年，建成我国自主的陆地、大气、海洋先进对地观测系统，为现代农业、防灾减灾、资源环境、公共安全等重大领域提供服务和决策支持，确保掌握信息资源自主权，促进形成空间信息产业链。
从目标中可以看到未来几年国家对遥感领域的宏伟目标，尤其是卫星的重视程度尤其突出，计划研制和发射7-9颗对地观测卫星。
表1 高分系列卫星
发射时间
卫星名
传感器
20130426
GF-1
2m全色/8m多光谱/16m宽幅多光谱
20140819
GF-2
1m全色/4m多光谱
20160810
GF-3
1m C-SAR合成孔径雷达
20151229
GF-4
50m地球同步轨道凝视相机
2018年5月9日2时28分 GF-5
可见短波红外高光谱相机
全谱段光谱成像仪
大气气溶胶多角度偏振探测仪
大气痕量气体差分吸收光谱仪
大气主要温室气体监测仪
大气环境红外甚高分辨率探测仪
2018年6月2日12时13分 GF-6
2m全色/8m多光谱/16m宽幅多光谱
2019年11月3日 GF-7
高空间立体测绘
2015年6月26日14时22分GF-8光学遥感卫星2015年9月14日12时42分GF-9光学遥感卫星2019年10月5日2时51分GF-10微波遥感卫星2018年7月31日11时GF-11光学遥感卫星2019年11月28日7时52分GF-12微波遥感卫星2020年10月12日GF-13高轨光学遥感卫星2020年12月6日11时58分GF-14光学立体测绘卫星 从上表中可以看到，我国规划中的卫星性能非常高，朝着高空间分辨率和光谱分辨率发展，在时间分辨率上也有很好的表现。
高分一号（GF-1） 高分一号（GF-1）卫星搭载了两台2m分辨率全色/8m分辨率多光谱相机，四台16m分辨率多光谱相机。卫星工程突破了高空间分辨率、多光谱与高时间分辨率结合的光学遥感技术，多载荷图像拼接融合技术，高精度高稳定度姿态控制技术，5年至8年寿命高可靠卫星技术，高分辨率数据处理与应用等关键技术，对于推动我国卫星工程水平的提升，提高我国高分辨率数据自给率，具有重大战略意义。
表2 GF-1卫星有效载荷技术指标
载荷
谱段号
波谱范围（µm）
空间分辨率（m）
幅宽（km）
侧摆能力
重访时间（天）
全色多光谱相机
1
0.45-0.90
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/23f2627cc3eebb9acd87458b5328665d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e7917b53b2f9c2791dc3ac91767d5f1/" rel="bookmark">
			DO、DTO、BO、VO、POJO等各种O浅学（总结）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		DO、DTO、BO、VO、POJO等各种O浅学（总结） 有哪些 O关键的 O ：DO、DTO、VO、BO整个数据流程传递区别用处VO与DTO的区别VO与DTO的应用DTO与DO的区别DTO与DO的应用DO与PO的区别DO与PO的应用 领域模型命名规约： 有哪些 O DO（ Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。PO（Persistant Object）：持久对象，一个 PO 的数据结构对应着库中表的结构，表中的一条记录就是一个 PO 对象DTO（ Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。BO（ Business Object）：业务对象。由 Service 层输出的封装业务逻辑的对象。AO（ Application Object）：应用对象。在 Web 层与 Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。VO（ View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。POJO（ Plain Ordinary Java Object）：POJO 专指只有 setter/getter/toString 的简单类，包括 DO/DTO/BO/VO 等。DAO（Data Access Objects）：数据访问对象，和上面那些 O 不同的是，其功能是用于进行数据操作的。通常不会用于描述数据实体
阿里Java开发手册分层领域模型：
关键的 O ：DO、DTO、VO、BO VO (View Object)，用于表示一个与前端进行交互的视图对象，它的作用是把某个指定页面(或组件)的所有数据封装起来。实际上，这里的 VO 只包含前端需要展示的数据，对于前端不需要的数据，比如数据创建和修改的时间等字段，出于减少传输数据量大小和保护数据库结构不外泄的目的，不应该在 VO 中体现出来。
DTO(Data Transfer Object)，用于表示一个数据传输对象，DTO 通常用于展示层(Controller)和服务层(Service)之间的数据传输对象。DTO 与 VO 概念相似，并且通常情况下字段也基本一致。但 DTO 与 VO 又有一些不同，这个不同主要是设计理念上的，比如 API 服务需要使用的 DTO 就可能与 VO 存在差异。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e7917b53b2f9c2791dc3ac91767d5f1/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/246/">«</a>
	<span class="pagination__item pagination__item--current">247/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/248/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>