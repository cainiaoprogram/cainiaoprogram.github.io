<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88904ddd5d5e316fbb1939468076258a/" rel="bookmark">
			HTML中 meta的基本应用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		meta 标签的定义 meta 标签是 head 部分的一个辅助性标签，提供关于 HTML 文档的元数据。它并不会显示在页面上，但对于机器是可读的。可用于浏览器（如何显示内容或重新加载页面），搜索引擎（SEO）或其他 web 服务。
使用 在 HTML 中，&lt;meta&gt; 标签没有结束标签。
在 XHTML 中，&lt;meta&gt; 标签必须被正确地关闭。
&lt;meta&gt; 标签永远位于 head 元素内部。
元数据总是以 名称/值 的形式被成对传递的。
属性 属性
值
描述
charset
character_set
规定 HTML 文档的字符编码。
content
text
定义与 http-equiv 或 name 属性相关的元信息。
http-equiv
content-security-policycontent-typedefault-stylerefresh 把 content 属性关联到 HTTP 头部。
name
application-nameauthordescriptiongeneratorkeywordsviewport 把 content 属性关联到一个名称。
scheme
some_text
定义用于翻译 content 属性值的格式。
name属性 name 属性主要用于描述网页，与之对应的属性值为 content ，content 中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。
name 属性语法格式：
&lt;meta name="参数" content="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/88904ddd5d5e316fbb1939468076258a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9f351a8e5bda64224d4942d89b4e280/" rel="bookmark">
			【欧瑞博智能家居】ZigBee Mini网关、超静音智能开合帘电机 添加操作流程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、添加ZigBee Mini网关
二、添加超静音智能开合帘电机 参考资料
一、添加ZigBee Mini网关 1. 下载《智家365》APP
2. 网关通电，用网线连接路由器的网线接口
3. 再次扫描产品手册里面的二维码添加ZigBee Mini网关，注意手机wifi要在同一个网络下
4. 添加成功可在【我的设备】看到【ZigBee Mini网关】
二、添加超静音智能开合帘电机 1. 前置条件需要添加好【ZigBee Mini网关】
2. 电机充上电源
3. 选择家-添加设备-手动添加-遮阳晾晒-窗帘-超静音智能开合帘电机
4. 蓝灯慢闪条件：连续按键4次，第五次长按直到指示灯蓝色慢闪，注意：如果出现红灯则需要再次操作
5. 下一步选择【ZigBee Mini网关】，继续点击下一步等待连接，这时保持距离电机近一点，可以不断重复第4步，等待扫描出窗帘设备
6. 扫描出窗帘设备后可以改名以及分配房间，保存，即可APP操作窗帘开关
参考资料 欧瑞博 - 科技美学家居智能引领者 - 全屋智能家居品牌 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8721f17e5e77916fcc71f994539406ab/" rel="bookmark">
			SLAM学习快速入门---CMake简单、基础语法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 研究生阶段开启SLAM的旅程，从此篇博文起会开启一个新的SLAM专题，用以记录入门过程中的问题解决以及笔记分享，内容大多会涉及应用，原理剖析有能力的话后续会添加进来。如有纰漏，敬请指正！
今天记录CMake的有关知识，这是读者在linux上运行cpp代码的必要一环。
一、几个最简单的案例入门 Hello Eigen教程
# 声明所需要的cmake的最低版本 cmake_minimum_required(VERSION 3.11) # 声明一个cmake工程 project(SLAMBook-Eigen) # 添加头文件库 include_directories("/usr/include/eigen3") # 添加一个可执行程序 add_executable(helloEigen eigenMatrix.cpp) Hello PCL教程
# 指定最小的版本 cmake_minimum_required(VERSION 3.14) # 指定项目名称 project(pcl_module) # 找到pcl的指定库和文件位置 find_package(PCL REQUIRED) # 生成可执行文件 add_executable(pcl_module src/pcl_module.cpp) # 添加头文件库 include_directories( ${PCL_LIBRARIES} /usr/include/eigen3 ) # 链接三方库 target_link_libraries(pcl_module ${PCL_LIBRARIES} ) # eigen仅由头文件构成，不需要库文件 Hello Cmake教程
# demostrate the minimum version of cmake cmake_minimum_required(VERSION 3.16) # define the project name project(HelloSLAM) # generate library file add_library(hello_shared SHARED libHelloSLAM.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8721f17e5e77916fcc71f994539406ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbca56a17c4409b7fd1fc61440497e59/" rel="bookmark">
			Kubernetes(k8s)包管理工具Helm：Helm包管理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一.系统环境 本文主要基于Kubernetes1.21.9和Linux操作系统CentOS7.4。
服务器版本docker软件版本Kubernetes(k8s)集群版本CPU架构CentOS Linux release 7.4.1708 (Core)Docker version 20.10.12v1.21.9x86_64 Kubernetes集群架构：k8scloude1作为master节点，k8scloude2，k8scloude3作为worker节点。
服务器操作系统版本CPU架构进程功能描述k8scloude1/192.168.110.130CentOS Linux release 7.4.1708 (Core)x86_64docker，kube-apiserver，etcd，kube-scheduler，kube-controller-manager，kubelet，kube-proxy，coredns，calicok8s master节点k8scloude2/192.168.110.129CentOS Linux release 7.4.1708 (Core)x86_64docker，kubelet，kube-proxy，calicok8s worker节点k8scloude3/192.168.110.128CentOS Linux release 7.4.1708 (Core)x86_64docker，kubelet，kube-proxy，calicok8s worker节点 二.前言 在Kubernetes中，部署一个应用程序需要进行多个步骤，其中包括创建ConfigMap、Secret和Deployment等对象。但是，使用Helm这样的基于Kubernetes的包管理器，可以将所有这些操作打包成一个Chart，从而简化了应用程序的部署流程和管理。
使用Helm进行包管理的前提是已经有一套可以正常运行的Kubernetes集群，关于Kubernetes(k8s)集群的安装部署，可以查看博客《Centos7 安装部署Kubernetes(k8s)集群》https://www.cnblogs.com/renshengdezheli/p/16686769.html。
三.包管理工具Helm简介 Helm是一个基于Kubernetes的包管理器，它由两部分组成：Helm客户端和Tiller服务器。Helm客户端从称为Chart Repositories的位置获取预配置的Charts，然后使用Tiller将它们安装到Kubernetes集群中。
Helm是一个开源项目，旨在简化Kubernetes应用程序的安装和部署。它允许您将应用程序打包为一个称为Chart的可重复的包，并在Kubernetes集群中部署和管理这些应用程序。
具体来说，Helm解决了以下问题：
将Kubernetes应用程序打包到chart中，使其易于分享和重用。管理应用程序依赖关系，因此不需要手动下载或配置库。轻松升级应用程序，通过使用helm upgrade命令，在没有任何停机时间的情况下更新已部署的应用程序。通过使用helm rollback命令，回滚到以前的版本，以防出现故障。在不同的Kubernetes集群之间轻松移植应用程序。 Kubernetes的Helm Chart是一种用于部署应用程序的包管理器，允许用户描述、安装和升级复杂的应用程序。它是一个预定义模板的集合，这些模板描述了在Kubernetes中运行应用程序所需的所有资源，如Pod、Service、Ingress、ConfigMap等。
每个Chart都描述了一个Kubernetes资源的集合，例如一个应用程序或数据库。Chart中包含最终用户所需的所有信息，如Docker镜像名称、端口号和环境变量等。通过使用Helm，我们可以更轻松地部署和管理Kubernetes应用程序。
Helm Chart由多个文件组成，其中包括：
Chart.yaml：定义了当前Chart的版本、名称、描述和依赖项。values.yaml：包含了指定Chart的默认值或者用户自定义的值。templates目录：包含了要在Kubernetes中部署的所有资源定义文件。 使用Helm Chart可以帮助用户避免手动创建资源的复杂性和重复性，使得应用程序的部署更加容易和快速，并且支持在不同的环境中轻松地重现相同的配置。此外，还可以通过命令行修改values.yaml中的值来定制化每个Chart实例的特定配置。
四.安装部署helm 创建放helm文件的目录。
[root@k8scloude1 ~]# mkdir helm [root@k8scloude1 ~]# cd helm/ 创建helm命名空间。
[root@k8scloude1 helm]# kubectl create ns helm namespace/helm created 切换命名空间。
[root@k8scloude1 helm]# kubens helm Context "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fbca56a17c4409b7fd1fc61440497e59/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d5bc4973d017c144de5a7ecf876536cc/" rel="bookmark">
			数字图像处理期末考点整理（全）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		计算：傅里叶变换，双线性插值，直方图均衡化，灰度共生矩阵，霍夫曼编码，区域增长/合并，中值滤波
简答：窗口/模板处理，BMP文件存储格式，滤波器和平滑算子的特点，图像增强/复原，伪彩色/假彩色处理，纹理特征，图像退化
图像处理基础 基础概念 什么是图像？模拟/数字图像处理区别？ 图像是对客观对象的一种相似性的、生动性的描述或写真。
区别：
数学描述方法：模拟图像主要用连续数学方法，数字图像主要用离散数学方法。图像分辨率表示：数字图像分辨率是指反映整个图像画面垂直和水平方向像素数乘积。模拟图像分辨率是指反映整个画面最多的扫描线数。 图像处理：数字图像是通过对模拟图像采样，量化等处理获得的，模拟图像处理的方式很少，往往只能进行简单的放大、缩小等，而数字图像的处理方式可以非常精确、灵活。数字图像处理再现性好，模拟图像的保存性较差，时间长了会有所变化，而数字图像不会因为保存、传输或复制而产生图像质量上的变化。但数字图像处理速度较慢，存储容量大。 图像传输：模拟图像以实物为载体，传输相对困难，而数字图像以数字信息为载体，传输相对较快。 数字图像处理应用 生物医学: 利用电磁波谱成像分析系统诊断病情，如显微镜图像分析，DNA成像分析。
遥感: 农、林等资源的调查，农作物长势监测，自然灾害监测、预报，地势、地貌测绘以及地质构造解译、找矿，环境污染检测等等。
工业生产: 无损探伤，石油勘探，生产过程自动化(识别零件，装配质量检查)，工业机器人研制等。
军事: 航空及卫星侦察照片的测绘、判读，雷达、声纳图像处理，导弹制导，军事仿真等。
通信: 图像传真，数字电视、网络可视聊天、可视电话网页动画等。
公安: 指纹识别，印签、伪钞识别，安检，手迹、印记鉴别分析等。
气象预报: 获取气象云图进行测绘、判读等。
主流医学图像处理软件 3D Slicer：是用于医学图像信息学，图像处理和三维可视化的开源软件平台。 通过国家卫生研究院和全球开发人员社区的支持，二十多年来，Slicer为医生，研究人员和公众提供了免费，强大的跨平台加工工具。 在多种医疗应用中，包括孤独症，多发性硬化，系统性红斑狼疮，前列腺癌，精神分裂症，矫形生物力学， COPD，心血管疾病和神经外科应用。
OpenCV：是一个基于Apache2.0许可（开源）发行的跨平台计算机视觉和机器学习软件库，可以运行在 Linux、Windows、Android和Mac OS操作系统上。它轻量级而且高效——由一系列 C 函数和少量 C++ 类构成，同时提供Python、Ruby、MATLAB等语言的接口，实现了图像处理和计算机视觉方面的很多通用算法。
ITK-SNAP：一款可应用于分割3D医学图像的软件。来自于宾夕法尼亚大学图像计算与科学实验室(PICSL)和犹他大学成像研究所(SCI)长达十年的合作成果，其愿景是创建一个专用于特定功能、分割的工具，并且易于使用和学习。特点是免费、开源、多平台。
窗口处理/模块处理 窗口处理：对图像中选定矩形区域内的像素进行处理。
模块（模板）处理：准备一个和输入图像IP相同大小的二维数组，参照二维数组对输入图像处理。
区别：窗口处理选定区域为矩形，模块处理选定区域由二维数组（模板平面）确定，为任意形状。模块处理必须设置一个模板平面，而窗口处理不需要。
联系：都是对图像中特定的部分进行处理。
图像数字结构 图像数字结构指图像像素灰度值的存储方式，常用方式是将图像各像素灰度值用一维或二维数组相应的各元素加以储存。其它存储方式还有：组合方式（一个字节存放多个像素灰度值，节省内存但计算量大）；比特面方式（将所有像素灰度相同的比特位用一个二维数组表示，形成比特面，能充分利用内存空间，便于进行比特面之间的运算，但灰度图像处理耗时多）；分层结构（先处理低分辨率图像，后处理高分辨率图像，可提高效率）；树结构；多重图像数据存储（逐波段/逐行/逐像素存储）。
BMP格式 组成：
14字节的文件头40字节的信息头4*n的颜色定义（每个颜色长度占4个字节）位图数据 其中文件信息头包括文件的类型、大小和存储位置，位图信息包括信息头和彩色表（调色盘），位图数据记录位图的每一个像素值（分为压缩格式和非压缩格式）。
DICOM标准 DICOM(DigitalImaging andCommunications inMedicine)是指医疗数字影像传输协定，是NEMA（美国国家电器制造商协会）和MITA（影像技术联盟）负责管理和出版的用于医学影像处理、储存、打印、传输的一组通用的标准协定。它是一个开放的系统。
DICOM是以TCP/IP为基础的应用协定，可以在局域网（LAN）或广域网（WAN）内工作。两个能接受DICOM格式的医疗仪器间，可通过DICOM格式的文件，来接收与交换影像及病人资料。
DICOM 文件的所有信息均采用了数据元素（data element）的存储方式，每个数据元素均由标签（tag）、值的含义（value representation，以VR 表示，是可选项），值域长（value length）和值域（value field）组成。
广泛应用于放射医疗，影像组学，心血管成像以及放射诊疗诊断设备(X射线，CT，核磁共振，超声等)以脑影像的数据为例，3D-Slicer就可以查看dicom数据，并且根据dicom的数据结构读取患者及影像的信息，在此基础上可以做进一步处理
如下图，Patient Tag包括了比如患者姓名，ID，出生日期，性别，体重等信息；Study Tag包含了检查的序列号，检查ID，检查日期和时间，检查类型，检查部位和检查的描述等信息；Series Tag包含了序列号，检查模态，检查描述和说明，图像位置，层厚，层与层之间的距离，身体部位等信息；
数据元素存储方式:每一张图像中都携带着大量的信息，这些信息具体可以分为以下四类：1.Patient 2.Study 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d5bc4973d017c144de5a7ecf876536cc/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2b139fc50eaa88559f69aaab799cf15a/" rel="bookmark">
			java操作excel
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		jxl是一个韩国人写的java操作excel的工具, 在开源世界中，有两套比较有影响的API可供使用，一个是POI，一个是jExcelAPI。其中功能相对POI比较弱一点。但jExcelAPI对中文支持非常好，API是纯Java的， 并不依赖Windows系统，即使运行在Linux下，它同样能够正确的处理Excel文件。 另外需要说明的是，这套API对图形和图表的支持很有限，而且仅仅识别PNG格式。
使用如下：
搭建环境
将下载后的文件解包，得到jxl.jar，放入classpath，安装就完成了。
基本操作
一、创建文件
拟生成一个名为“test.xls”的Excel文件，其中第一个工作表被命名为
“第一页”，大致效果如下：
package test;
//生成Excel的类
import java.io.File;
import jxl.Workbook;
import jxl.write.Label;
import jxl.write.WritableSheet;
import jxl.write.WritableWorkbook;
public class CreateExcel {
public static void main(String args[]) {
try {
// 打开文件
WritableWorkbook book = Workbook.createWorkbook(new File("test.xls"));
// 生成名为“第一页”的工作表，参数0表示这是第一页
WritableSheet sheet = book.createSheet("第一页", 0);
// 在Label对象的构造子中指名单元格位置是第一列第一行(0,0)
// 以及单元格内容为test
Label label = new Label(0, 0, "test");
// 将定义好的单元格添加到工作表中
sheet.addCell(label);
/*
* 生成一个保存数字的单元格 必须使用Number的完整包路径，否则有语法歧义 单元格位置是第二列，第一行，值为789.123
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2b139fc50eaa88559f69aaab799cf15a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7bcd812be7f22f17762cd313bc221b4/" rel="bookmark">
			Centos添加路由
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、临时添加
# 多个IP [root@centos7 ~]# route add -net 10.1.0.0 netmask 255.255.255.0 gw 172.1.0.254 [root@centos7 ~]# route add -net 10.1.0.0/32 gw 172.1.0.254 [root@centos7 ~]# route add -net 10.1.0.0/32 dev eno1 # 单个IP [root@centos7 ~]# route add -net 10.1.0.0 netmask 255.255.255.0 gw 172.1.0.254 [root@centos7 ~]# route add -net 10.1.0.0/24 gw 172.1.0.254 [root@centos7 ~]# route add -net 10.1.0.0/24 dev eno1 二、永久添加路由
# 方法一：利用nmcli工具 [root@centos7 ~]# nmcli con mod bond1 +ipv4.routes "10.1.0.0/20 172.1.0.254" [root@centos7 ~]# cat .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f7bcd812be7f22f17762cd313bc221b4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9014525ca62ace9cbb771c9751127b3e/" rel="bookmark">
			Yum源配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、使用网络yum源 1、百度搜索网易mirror；
2、找到Centos帮助文档；
3、备份默认yum源；
4、复制repo文件源地址；
5、Centos中使用wget命令下载repo文件；
6、清除yum源缓存；
# yum clean all 7、生成新的yum源缓存；
# yum makecache 二、搭建本地yum源 1、配置本地yum源——本地挂载光盘等镜像文件 （1）部署步骤
虚拟机添加光盘——挂载——配置yum源——测试。
（2）部署
① 虚拟机添加光盘
② 添加挂载
# mount -r /dev/cdrom /mnt/CentOS7 # echo "/dev/sr0 /mnt/CentOS-cdrom iso9660 defaults 0 0" &gt;&gt; /etc/fstable # mount -t iso9660 -o rw /opt/CentOS-7-x86_64-Minimal-1908.iso /mnt/CentOS7 # mount -t iso9660 -o loop /opt/CentOS-7-x86_64-Minimal-1908.iso /mnt/CentOS7 ③ 配置yum源
[local] name=local baseurl=file:///mnt/CentOS7 enabled=1 gpgcheck=0 ④ 测试
# yum clean all # yum makecache # yum repolist # yum install wget 2、配置yum源服务器——输出yum源给其他主机使用 （1）部署
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9014525ca62ace9cbb771c9751127b3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/68e7081e60bf2299b09b219d75697c68/" rel="bookmark">
			Redis客户端 - RedisSerializer
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		原文首更地址，阅读效果更佳！
Redis客户端 - RedisSerializer | CoderMast编程桅杆https://www.codermast.com/database/redis/redistemplate-redis-serializer.html
前景回顾
在上一篇中，我们实现了一个简单的案例，操作一个 String 类型的数据，插入了一个 name = codermast 的数据到Redis。
使用redis-cli客户端连接对应的Redis服务器后，按道理来讲get name这个指令的返回结果应该是 codermast
redis-cli客户端查看
返回的结果是无，这是为什么呢？使用可视化工具查看一下，看看到底数据是否存储在Redis服务器中。
使用可视化工具查看
可以明显的看到，所存储的 key 之前加上了一段字符，但是从代码中看，存储的 key 为 "name"，但是实际存储的 key 是 \xac\xed\x00\x05t\x00\x04name，而且里面的 value 也做了同样的处理 \xac\xed\x00\x05t\x00\x09codermast
出现这种现象的原因是什么呢？这是因为 RedisTemplate 在底层将数据序列化处理以后，才存储到 Redis 服务器中。
RedisTemplate 可以接收任意 Object 作为值写入 Redis ，只不过在写入之前会把 Object 序列化成为字节形式，默认是采用 JDK 序列化，得到的结果就如图所示。
缺点
可读性差资源占用高 既然这样可读性又差，资源占用又高，那么如何解决这些问题呢？我们可以通过自定义 RedisTemplate 序列化的方式来解决。
#编写一个 RedisConfig 配置类 @Configuration public class RedisTemplate{ @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory){ // 1.创建RedisTemplate对象 RedisTemplate&lt;String ,Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); // 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/68e7081e60bf2299b09b219d75697c68/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dbe0b9169306095e72af170974ffcfa1/" rel="bookmark">
			LaTeX数学公式-详细教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		LaTeX数学公式-详细教程 前言注意事项插入公式注释编号Markdown编辑器LaTeX编辑器 转义字符换行与对齐换行对齐 字体空格上下标绝对值与范数括号大括号分式根式对数省略号最值方程组和分段函数方程组分段函数 累加和累乘矢量极限导数积分矩阵基础矩阵带括号的矩阵行列式元素省略的矩阵增广矩阵 表格希腊字母黑板粗体（空心字母）运算符关系运算符三角运算符箭头运算符离散数学符号 戴帽符号（各种帽子）特殊符号 前言 若想学习Markdown，请参见我的其他博客：Markdown详细教程+技巧总结 。
若想学习LaTeX，请参见我的其他博客：LaTeX详细教程+技巧总结 。
若使用LaTeX编译器编写LaTeX数学公式，需要在导言区引用数学公式的宏包，代码为\usepackage{amsmath}；若要修改公式的字体，还需要引用宏包\usepackage{amsfonts}。
若使用Markdown编写LaTeX数学公式，CSDN支持LaTeX数学公式，但有些本地编辑器可能不支持LaTeX数学公式，Typroa可以更改设置支持，VS Code可以通过安装扩展的方式支持。
本篇博客内容包含前言，注意事项，插入公式，注释，编号，转义字符，换行与对齐，字体，空格，上下标，括号，大括号和行标，分式，开方，对数，省略号，最值，方程组和分段函数，累加和累乘，矢量，积分，极限，导数与偏导，矩阵，表格，希腊字母，运算符，黑板粗体（空心字母），戴帽符号，特殊符号，等等。
官方文档（英文）：
传送门：官方文档
网址：http://www.ctex.org/documents/packages/math/index.htm中文文档：
传送门：中文教程
网址：https://www.latexlive.com/help技巧：使用在线LaTeX公式编辑器，来生成LaTeX公式代码，然后复制到LaTeX编辑器（或Markdown编辑器）中，并在两边加上$或$$即可。
在线LaTeX公式编辑器网址：https://www.latexlive.com/插入公式
左对齐公式（行中公式）：$数学公式$
居中公式（独立公式）：$$数学公式$$
注意：使用$行中公式时，数学公式与$连接处不要有空格，否则公式不会显示；使用$$居中公式时，数学公式与$$连接处可以有空格。即$ 数学公式 $ 不显示公式。注释：%为单行注释。细节请参照下文。 注意事项 使用$，即行中公式时，数学公式与$连接处不要有空格，否则公式不会显示。即$ 数学公式 $ 不显示公式。使用$$，即居中公式时，数学公式与$$连接处可以有空格。使用$$时，上方要空一行。=不要单独打一行，否则可能会出错。+ - * / = ( ) | , . '等符号直接在$或$$之间输入即可识别。 插入公式 左对齐公式（行中公式）：$数学公式$
居中公式（独立公式）：$$数学公式$$
注意： 注意事项请参照目录章节中的注意事项子章节。
左对齐例子：$x+y=z$
x + y = z x+y=z x+y=z
居中对齐例子：$$x+y=z$$
x + y = z x+y=z x+y=z
注释 %为单行注释。
例子：
$$ %第一个极限 \lim_{n \to +\infty} \frac{1}{n(n+1)} \quad %空一格 and %英文单词and \quad %空一格 %第2个极限 \lim_{x\leftarrow{example} \infty} \frac{1}{n(n+1)} $$ 显示：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dbe0b9169306095e72af170974ffcfa1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7dc9a4d5add2ad790ff9752d41d4729d/" rel="bookmark">
			Python 连接Oracle数据库
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 安装cx_Oracle代码 安装cx_Oracle 使用Pycharm，在终端窗口输入pip install cx_Oracle
安装成功后 ， 在解释器地址下的Lib\site-packages 文件夹下产生对应库，我 D:\Python\Pythoncode\venv\Lib\site-packages，
代码 import cx_Oracle def Sql_link(): # 连接数据库 #db = cx_Oracle.connect(user="用户名", password="密码", # dsn="地址") try: db = cx_Oracle.connect(user="用户名", password="密码", dsn="10.48.68.164:1521/xxxx") except cx_Oracle.DatabaseError as meg: print(meg) # 使用 cursor() 方法创建一个游标对象 cursor = db.cursor() return db, cursor def get_ope_type(): """ :return: """ db, cur = Sql_link() # 获得 sqlope_type = """select * from EXE_T_OPE_RECODE """ resql_ope = cur.execute(sqlope_type) resql_ope01 = resql_ope.fetchall() # 将元组转成list\ l_ope_type = [] for v_ope in resql_ope01: l_ope_type.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7dc9a4d5add2ad790ff9752d41d4729d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e23eb00ca82614a8ea34e8d814d7c892/" rel="bookmark">
			R语言随机森林代码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当使用R语言进行随机森林重要性分析时，可以使用randomForest包来实现。下面是一段示例代码，展示了如何进行随机森林的重要性分析：
RCopy code
# 安装和加载 randomForest 包 install.packages("randomForest") library(randomForest) # 读取数据集 data &lt;- read.csv("data.csv") # 设置随机种子，以保证结果可复现 set.seed(123) # 创建随机森林模型 rf_model &lt;- randomForest(Target ~ ., data = data, ntree = 1000) # 输出特征的重要性 importance &lt;- importance(rf_model) # 打印特征的重要性排序 print(importance) # 可视化特征的重要性 varImpPlot(rf_model) 在这段代码中，首先安装并加载了randomForest包。然后，通过read.csv函数读取了名为"data.csv"的数据集，其中包含了特征和目标变量。
接下来，通过set.seed函数设置了随机种子，以确保结果可复现。然后，使用randomForest函数创建了随机森林模型rf_model。在这里，目标变量(Target)被设置为预测目标，而其他变量则被用作特征。
通过调用importance函数，可以获取各个特征的重要性指标。这些指标衡量了每个特征对于模型的预测能力的贡献程度。最后，使用print函数打印了特征的重要性排序，并使用varImpPlot函数可视化了特征的重要性。
请注意，以上代码仅为示例，你需要根据实际情况修改数据集的路径、目标变量和特征的列名，以及其他参数，以适应你的具体分析需求。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/619266d9a77f97744b67df57f12349b6/" rel="bookmark">
			pycharm远程开发之torch环境部署(CUDA initialization Error、libcudart.so.11.0: cannot open shared object file)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在linux服务器上部署torch开发环境踩坑汇总 UserWarning: CUDA initialization: The NVIDIA driver on your system is too old 首先来看显卡版本信息
报错信息，显示cuda版本不匹配问题
服务器显卡显示的cuda最高适配版本为10.2,去官网寻找对应的版本下载（https://pytorch.org/get-started/previous-versions/#osx-9）
下载完成后测试cuda可以使用，问题解决
ImportError: libcudart.so.11.0: cannot open shared object file: No such file or directory 报错信息
这个问题一直没有解决，无赖破防，重头来过使用conda配置环境
conda配置mmgan参考文献传送
conda create -n mmgen python=3.8 conda activate mmgen conda install pytorch==1.11.0 torchvision==0.12.0 torchaudio==0.11.0 cudatoolkit=10.2 -c pytorch pip uninstall mmcv-full pip uninstall mmcv pip install mmcv-full==1.5.0 -f https://download.openmmlab.com/mmcv/dist/cu102/torch1.11.0/index.html pip install mmgen==0.6.0 最后运行代码，没有报错则环境部署成功
import torch, torchvision import mmcv from mmgen.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/619266d9a77f97744b67df57f12349b6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b4a7f7724afd9f3e38fca2632af45ade/" rel="bookmark">
			原生调用webView白屏解决方案
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、适用场景 1、不熟悉原生开发的H5开发人员
2、原生APP使用webView调用H5页面引发的白屏问题以及类似场景
二、排错方案 排错思路：
确定白屏问题是否能被解决确定引发的白屏问题是否是由原生注入到H5的情景A：问题由原生注入到H5，查看报错日志定位引发问题的具体原因协助原生开发者解决问题。情景B：问题由H5页面自身引发的，针对于前端H5开发者运行代码不报错白屏不显的解决方案。 三、问题解决方案 排查白屏问题是否能被解决：原生通过webView调用H5页面白屏引发错的原因有很多，其中大多数问题是可以由原生开发者和H5开发者所解决的，其中较为常见无法解决的问题为：安卓系统硬件不支持webView通信技术：
知识补充扩展：知识补充扩展：WebView在Android 4.4（API level 19）及以上版本中是基于Chromium的，而在Android 4.3（API level 18）及以下版本中是基于WebKit的。WebView是一个系统组件，其版本与安卓系统版本有关。如果WebView版本过低，可能会导致一些功能无法正常使用。（此处分析可以不看）。通过主流浏览器访问webView地址，如果浏览器访问webview不白屏，那么安卓系统硬件是支持。如果浏览器访问webView白屏：情景A，使用的安卓系统为4.4以下版本的用户，通过系统设置、应用、查看手机WebView系统组件是否被禁用，如果被禁用则该型号手机厂商不支持。情景B，如果安卓系统为4.4以上，那么WebView系统组件已经写到了安卓系统内核里了需要后端开发者，使用如下代码测试硬件是否支持webView。 PackageManager pm = getPackageManager(); boolean isWebViewSupported = pm.hasSystemFeature(PackageManager.FEATURE_WEBVIEW); 判断白屏问题是否是原生注入到H5页面：原生通过webView调用H5页面引发白屏的原因有可能是H5本身语法不兼容也可能是原生APP内部报错导致的，作为一名H5开发者需要优先判断是否是H5页面内部问题：
通过谷歌远程调试手机APP环境白屏的webview页面和浏览器环境未白屏webview页面作为对比。情景A：若APP环境下的webview页面无DOM元素，浏览器环境下的webview页面有DOM元素，则引发白屏问题很有可能是原生APP内部报错注入到H5页面。情景B：若APP环境下的webview页面有DOM原生，通过谷歌远程调试定位引发白屏的具体不兼容语法。 注：谷歌远程调试技术需要访问谷歌服务器因此需要设备能科学上网，具体使用方法可以参考 Chrome远程调试webview_chrome webview_卢同学.的博客-CSDN博客
获取APP内部报错日志协助原生定位问题：下载ADB安卓调试工具配置环境变量（自行百度），将设备连接电脑复现白屏页面获取报错日志：
连接Android设备到电脑，并打开USB调试模式 使用命令检查设备是否成功连接
adb devices 使用logcat命令查看报错日志定位具体报错原因 adb logcat -s &lt;package-name&gt; // package-name为对应包名 adb logcat -s &lt;package-name&gt; *:E // E为日志输入级别为Error 注：本人遇到的是低版本安卓跨域问题
四、webView原生调用失败常见问题 H5页面资源加载失败：H5页面中的资源文件（如CSS、JS、图片等）可能加载失败，导致页面无法正常显示。可以通过Chrome浏览器的开发者工具或Fiddler等工具来查看资源加载情况，找出加载失败的资源文件并进行修复。
H5页面代码问题：H5页面中的代码可能存在问题，导致页面无法正常显示。例如，可能存在语法错误、逻辑错误等问题。可以通过Chrome浏览器的开发者工具或其他调试工具来查看H5页面的代码，找出问题并进行修复。
安全策略问题：H5页面中可能存在安全策略问题，导致页面无法正常显示。例如，可能存在跨域访问问题、HTTPS证书问题等。可以通过Chrome浏览器的开发者工具或其他调试工具来查看安全策略问题，找出问题并进行修复。
WebView设置问题：WebView的设置可能不正确，导致页面无法正常显示。例如，可能需要启用JavaScript、启用缓存等设置。可以通过以下代码来设置WebView：
webView.getSettings().setJavaScriptEnabled(true); webView.getSettings().setCacheMode(WebSettings.LOAD_DEFAULT); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fb27816a84060acbf39b32188bdbe24c/" rel="bookmark">
			计算机组成原理——输入输出设备（Input Output Equip-ment）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		输入输出设备 输入输出系统的发展阶段第一阶段（早期阶段）第二阶段（接口模块与DMA阶段）（讲解的重点）第三阶段（具有通道结构的阶段）第四阶段（具有I/O处理机的阶段） 输入输出系统的组成I/O软件软件的主要任务指令I/O指令通道指令 I/O硬件 I/O设备与主机的联系方式I/O设备编址方式设备寻址信息传送方式状态联络方式I/O设备与主机的连接方式 I/O设备与主机信息传送的控制方式程序查询方式程序中断方式DMA（直接存储器存取）方式 I/O接口接口设置的原因(通用)接口的功能与组成总线连接方式的I/O接口电路接口功能 接口类型 程序查询方式程序查询的流程只有一台I/O设备的情况下查询流程程序流程 有较多I/O设备的情况下查询流程 程序查询方式的接口电路接口电路组成工作流程（以输入设备为例） 程序中断方式程序中断程序中断方式的接口电路接口电路组成I/O中断处理流程/工作流程（以输入设备为例） CPU的中断服务程序的流程中断分类（按照是否在CPU执行中断过程中可以被新的中断请求打断） DMA方式DMA方式下I/O设备与主存直接交换数据的方式停止CPU访问主存周期挪用（周期窃取）DMA与CPU交替访问 DMA接口（DMA方式的接口电路）接口电路组成DMA接口的功能工作流程（输入、输出的案例皆有）预处理数据传送后处理 DMA接口与系统的连接方式DMA方式与程序中断方式的比较DMA接口的类型 输入输出系统的发展阶段 第一阶段（早期阶段） I/O设备较少，I/O设备与主存交换信息都必须通过CPU，每一个I/O设备都具有一套独立的逻辑电路与CPU相连，用来实现I/O设备与主机之间的信息交换，线路十分散乱复杂，而且由于I/O设备与主机交换信息时，CPU只能停止运算，即I/O设备与CPU是按照串行方式进行工作的，减低了工作效率，再者，由于每一个I/O设备的逻辑控制电路与CPU的控制器已经构成了一个不可分割的整体，于是进行I/O设备的增添、撤减是极其困难的
第二阶段（接口模块与DMA阶段）（讲解的重点） 计算机系统采用了总线结构，I/O设备通过接口模块与主机相连接，而且通常在接口中都设有数据通路和控制通路，数据经过接口既可以起到缓冲作用，又可以实现串并变换，控制通路用以传送CPU向I/O设备发出的各种控制命令，或者使CPU接收来自I/O设备的反馈信号。许多接口还能满足中断请求处理的要求，使得I/O设备与CPU可以按照并行方式进行工作（虽然并不是绝对的并行工作），提高了CPU的工作效率，此外接口技术还可以实现多台I/O设备分时占用总线，使得I/O设备之间也可以实现并行工作方式，提高了整机效率
为了进一步提高CPU工作效率，又出现了DMA（直接存储器存取）技术，特点是I/O设备与主存之间存在一条直接数据通路，I/O设备可以与主存直接交换信息，使得CPU在I/O设备与主存交换信息这个时间段内可以继续完成自身工作，资源利用率得到了进一步的提升
第三阶段（具有通道结构的阶段） 采用DMA方式虽然可以实现高速I/O设备与主机之间成组数据的交换，但是在大型计算机中使用DMA方式就会出现一些问题：
1、如果每一台I/O设备都配置上专用的DMA接口，不仅会增加硬件成本，还会因为要解决众多DMA接口同时访问主存的冲突问题使得控制变得十分复杂2、CPU需要对众多的DMA接口进行管理，也会影响整机工作效率。因此在大中型计算机系统中，一般采用I/O通道的方式进行数据交换，通道是用来负责管理I/O设备以及实现主存与I/O设备之间交换信息的部件，可以视为一种具有特殊功能的处理器，其具有专用的通道指令，可以独立地执行用通道指令所编写的输入输出程序，但是并不是一个完全独立的处理器，它要依据CPU的I/O指令进行启动、停止或者改变工作状态。是从属于CPU的一个专用处理器。依赖通道管理的I/O设备在与主机交换信息时，CPU不直接参与管理 第四阶段（具有I/O处理机的阶段） I/O处理机又称为外围处理机，基本独立于主机工作，既可以完成I/O通道要完成的I/O控制，又可以完成码制变换、格式处理、数据块检错、纠错等操作。具有I/O处理机的输入输出系统与CPU工作的并行性更高，I/O系统对于主机来说具有更大的独立性
输入输出系统的组成 I/O软件 软件的主要任务 将用户编制的程序或者数据输入主机中将运算结果输送给用户实现输入输出系统与主机工作的协调 指令 不同结构的输入输出系统所采用的软件技术差异很大：在采用接口模块方式时，使用机器指令系统中的I/O指令与系统软件中的管理程序即可实现I/O设备与主机的协调工作，在采用通道管理方式时，除了要使用I/O指令之外，还需要使用通道指令以及相应的操作系统。就算都采用操作系统，不同的机器其操作系统的复杂程度差异也是很大的。
I/O指令 I/O指令为机器指令的一类，为CPU指令系统的一部分，是CPU用来控制输入输出操作的指令，由CPU译码以后执行。I/O指令可以和其他机器指令的字长相同，但是也是会反映CPU与I/O设备交换信息的特点，比如反映出对多台I/O设备的选择以及应该对设备进行哪些具体操作
操作码 可以作为I/O指令与其他指令（比如，访存指令、控制指令、算逻指令）的判别码，标识该指令为I/O指令 命令码 体现了I/O设备的具体操作，命令码相当于CPU普通指令集中的操作码部分 操作分类：1、将数据从I/O设备输入主机；2、将数据从主机输出到I/O设备；3、状态测试，比如利用命令码检测各个I/O设备所处状态为 忙 还是 准备就绪；4、形成某些操作命令，不同I/O设备和主机进行信息交换的时候，需要完成的操作各不相同，比如磁盘驱动器需要进行读扇区、写扇区、找磁道等操作 设备码 是多台I/O设备的选择码，相当于各个设备的地址（只有对I/O设备进行编号，才能准确的选择某一台设备与主机交换信息） 通道指令 通道指令又称为CCW（通道控制字），是对具有通道的I/O系统为通道专门设置的指令，在具有通道结构的计算机中，I/O指令主要完成I/O设备的启动、停止操作、查询通道和I/O设备状态以及控制通道所做的其他操作，不实现I/O数据的传送操作，这种具有通道指令的计算机一旦CPU执行了启动I/O设备的指令，通道就会替代CPU对I/O设备进行管理。通道指令一般用来指明参与传送的数据在主存中的首地址；指明需要传送的字节数或者所传送数据的末地址；指明所选设备的设备码以及完成某种操作的命令码。一般位数比较多，通道程序即由通道指令所构成，用来完成某种外围设备与主存之间传送信息的操作
I/O硬件 输入输出系统的硬件组成是多样的，在带有接口的I/O系统中，一般包括接口模块以及I/O设备两大部分；在具有通道的I/O系统中，一个通道可以和一个以上的设备控制器相连，一个设备控制器又可以控制若干台同一类型的设备
I/O设备与主机的联系方式 I/O设备与主机交换信息和CPU与主存交换信息相比，有许多不同点。例如，CPU如何对I/O设备编址；如何寻找I/O设备号；信息传送是逐位串行还是多位并行；I/O设备与主机以什么方式进行联络，使它们彼此都知道对方处于何种状态；I/O设备与主机是怎么连接的，等等。这一系列问题统称为I/O设备与主机的联系方式
I/O设备编址方式 通常将I/O设备码看作地址码，对I/O地址码的编址可以采用统一编址和不统一编址两种方式
统一编址（映像编址） 将I/O地址看作是存储器地址的一部分，是从存储器空间划出一部分地址空间给I/O设备，把I/O接口中的端口当作存储器单元一样进行访问，比如在64K地址的存储空间中，划分出8K地址作为I/O设备的地址，但凡地址落在这8K地址范围内，该地址要进行的操作就是指向I/O设备的。这种编址方式占用了存储空间，减少了主存容量，但是无需设置专用的I/O指令，有一部分对存储器使用的指令也可以用于端口 不统一编址（独立编址） 指的是I/O地址和存储器地址是分开的，所有对于I/O设备的访问都必须使用专用的I/O指令进行。这种编址方式不占用主存空间，不需要为I/O端口留出地址空间，所以不影响主存容量，但是需要设置I/O专用指令。8086系统采用的就是这种独立的I/O编址方式 设备寻址 由于每一台I/O设备都被赋予了一个设备号，于是，要启动某一台设备是可以由I/O指令的设备码字段直接指出该设备的设备号。通过接口电路中的设备选择电路，即可选中要进行信息交换的I/O设备
信息传送方式 并行传送 在同一时间，n位信息同时从CPU输出至I/O设备，或者由I/O设备输入到CPU，这种传送方式的速度较快，但是要求数据线多 串行传送 在同一时间，只传送一位二进制信息，在不同时刻连续逐位传送一串信息，这种传送方式的速度较慢，但是只需要一根数据线和一根地线，当I/O设备与主机距离遥远的时候，采用串行传送比较合理，比如远距离数据通信 状态联络方式 立即响应方式
对于一些工作速度十分缓慢的I/O设备，比如指示灯的亮与灭、开关的通与断等，当它们与CPU发生联系时，通常都会使这种设备可确定地处于某种等待状态，只要CPU的I/O指令一到，就可以实现响应，无需使用特殊的联络信号来确定设备的状态（即假设外设已经处于就绪状态，所以不必去查询外设的状态，直接执行CPU的I/O指令进行数据传送） 异步工作采用应答信号联络
当I/O设备与主机工作速度不匹配的时候，通常采用异步工作方式，这种方式下，I/O设备与CPU只有在出现联络信号的时候，才会开始准备交换信息
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/fb27816a84060acbf39b32188bdbe24c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3440e3df862fcab1340a932fa38bceef/" rel="bookmark">
			基于YOLOv5s的火焰检测在jetson nano边缘计算设备上的部署（使用tensorrt加速，Deepstream视频推流SDK）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前情提要：本文章是我自己一点点的小感悟，是整个大框架的分析与大的流程，不是你们想要的具体过程，但是如果你们仔细阅读下这篇文章，有一个大局的观念，会对项目流程有一个清晰的认识与想法，效果可能比那些细的流程的文章要好些，也因人而异吧，所以提前告知下大家。 咱们来说下这次课设让做的一个基于人体关键点检测的姿势识别或者跌倒检测的一个项目，我打算基于openpose这个算法做，需要用什么VGA网络训练啥的，我这次没研究怎么训练，时间不够了好吧，这次任务就是如何在jetson nano板子上部署是这次的重点，同样说过了jetson xavier最重要的是什么，是jetpack版本，最基本的生态就是Ubuntu18.04这个默认不多说了，为什么之前tx2那么难用，系统储存在emmc里，要虚拟机烧系统nvidia sdk传输，电脑空间不够用了，还要专用USB线，懒得弄了，而且内存还不足，还得挂载sd卡，解锁，写入开机自启动vim命令，空间不足开不了机，命令行都调不出来，你也亲身经过的，花了150，记得奥别忘了。deepstream版本和jetpack版本根本匹配不了，网上生态还没有，没法搞。好了，言归正传，咱们说这回，问王老师借了个nano和USB摄像头，买了两个sd卡，一个tensorflow，一个pytorch。这回吃一堑长一智，先说tensorflow框架，openpose得用tensorflow框架去搞，你说你在板子上肯定用gpu跑吧，谁部署板子用cpu对吧，查了下，对于nano只有一个jetpack版本4.3适用，为什么听我细细道来，首先查询tensorflow适配的cuda版本，一看没有cuda10.2，寄了一大半哈哈哈，最后一看只有cuda10版本，整10版本，那好了，只有一个适合nano的jetpack版本，卡的死死的，（备注：首先我肯定是在windows上部署的，这个毋庸置疑，才能知道版本问题信息），好了，准备sd卡，清空，烧录分区 flash successful，wohooo！！！成功，这个很简单不多说了，进去一系列先设置英文语言，装jtop。sudo upgrade，pip安装，更新一系列东西，装一堆编译的库之类的，这里可以参考下这位博主的博客：Jetson nano部署Yolov5 ——从烧录到运行 1:1复刻全过程_nano yolo_IamYZD的博客-CSDN博客
参考这个做初始部署操作，写的很好，谢谢这位大佬，可以引用下么，如果有侵权请及时联系我，我立刻删除。好了，装好了后，我查了下，tensorflow-gpu还不好装，甚至可能要编译，一提到编译cmake就头大，我很希望找到whl轮文件直接装，这样就会很简单了，wuhooo，你猜怎么着，我找到了，这里参考我的干爹英伟达官网：
Index of /compute/redist/jp/v43/tensorflow-gpu
4.3jetpack版本的tensorflow-gpu轮文件，给大家啦，这样就简单多了我刚好像看了下，通过命令也能直接装，我当时好像没装成功，算了你们自己再看看，反正whl是最简单的方法了，途中有个h5py还是啥的库老版本不匹配，建议先装这个库，再tensorflow-gpu whl文件，这样就装好了，反正也不容易，装好了，就可以拷贝程序直接运行了，记得使用python3命令，pip也用pip3命令，phthon默认指的2版本，再装些库，运行出来帧率低到爆炸，即使是gpu跑的，我觉得大部分原因是poenpose这个算法的原因（因为我只用pytorch框架跑一个项目的时候帧率都没有这样，还没有tensorrt加速加上deepstream），卡成ppt，如下图：
其实还有个程序，检测跌倒的，不过他的tensorflow用的1，你想想，我要用gpu跑，jetpack只能4.3版本，好了满足tensorflow使用gpu了，现在需要torch也用gpu，查官网傻眼了，如下图：
你猜猜看发生什么了， torch最高1.4，能用么，不可能啦，它检测跌倒的用的yolov5，yolov5我印象中最低torch1.6还是多少，反正一定不能1.4，因为与现在的版本差别太大，很多class或者函数都找不到，靠你手往上解决，根本没法的，我在之前tx2试过，你又要1.4的torch使用gpu，又要跑yolov5，不可能的奥，所以这个程序没法在nano上部署，索性放弃了。
下面补充下我在windows如何部署tensorflow-gpu吧，牵扯到tensorflow框架部署都不简单，因为1版本和2版本区别太大了，contrib这个库，还有各种报错，头大，一个静态的模型。一个动态的模型，cpu好部署，gpu还需要点水平，我现在说如何跑gpu：首先你得找匹配tensorflow-gpu的cuda版本，如下链接你先看下，自己心里先有个数
2021最新：TensorFlow各个GPU版本CUDA和cuDNN对应版本整理(最简洁)_cuda12.1对应的cudnn_Kakaluotuo的博客-CSDN博客
看完了吧，你会发现没有对于tensorflow-gpu版本1的没有cuda10.2，哈哈，真好，我*/*/*/&amp;……￥……*，索性换了cuda10版本，装了cudnn，cudnn版本其实那个不是一定匹配的，你运行时会发现它自己读取cudnn某个版本的dll文件没有，你就装哪个cudnn的驱动就行了，好了，装好了，我猜你还是用cpu跑，因为显示加载AX2 blabla。。。，读取不到对应cuda的dll文件，为啥读不到呢，奇了怪，pytorch都是自己自动使用gpu，你tensorflow事情怎么这么多，经过查找，奥，原来你在这个文件夹读取，如下图所示：
看到了吧，这个路径，他在这里读取，你之前不是替换了cuda的bin文件么，现在把所有的bin文件夹下的文件全部copy过来，你肯定会担心这是系统文件，不会搞搞坏了吧，别担心，我一直用着都没事，即使你害怕，后面你想换cuda版本了，想删除了，怎么办，乱了，没事的，你再拷贝一次，替换掉，他会自动选中那些相同文件，你再删除就可以了，聪明不我，哈哈哈哈。好了，现在基本上没啥问题了，这个是我参考这篇博客的，你们可以看下：
解决:运行 tensorflow-gpu相关代码报错/缺少dll文件（无需修改tensorflow版本）_gpudetect.dll下载_Netceor的博客-CSDN博客 不用下载奥，本来就有的，复制粘贴就行。还有个我想起来的报错，我装了tensorflow-gpu，他报错找不到tensorflow，tensorflow和tensorflow-gpu关系可以看下这个奥，讲的也非常不错：
电脑上同时安装了tensorflow和tensorflow-gpu，如何默认使用tensorflow-gpu_tensorflow 和tensorflowgpu_NuerNuer的博客-CSDN博客
哈哈哈，华生看看这篇，有助你更有效率的解决BUG，基本上没啥了，剩下的都是小问题，祝你成功 ，好了windows插完我们言归正传。
tensorflow说完了。我们现在来说正题部署nano，nano确定好版本，我选的jetpack4.5.1，因为我要用deepstream，看好再下手奥，这个确实很重要，这个版本的资料生态在我做之前感觉是最全的，所以你可以跟着我选。
为什么说是感觉，后面说奥，简单先提一下，因为现在很多博主是之前做的，用到的deepstream-yolov5，或者tensorrtx版本都更新了，还有yolov5版本，有的找不到之前版本了，什么engine模型不匹配，onnx的int32和int64运行不了，各种编译错误，实际上都没有沟通好，毕竟不是官方的，都在做得更好，肯定会出现不兼容问题，所以我们做到这个深度需要有什么能力，需要有看英文文档的能力，和github上看英文issues的能力，纯英文食用是第一手资料，就这都有错误，更别说中文搞过来的了，版本就更新不及时了，这个我们后面说。又是烧录，装一堆编译库，跟刚刚tensorflow开头一样，不多阐述了，奥插一句，有时候会遇到核心转储illegal错误，这个有些大佬说和numpy版本有关，当时是装miniconda，archiconda创建新环境pip的错误，base环境好着呢，但是现在是python3运行程序报的这样的错误，我也没搞懂，参考这位大神的，恩能够解决就行：
解决英伟达Jetson平台使用Python时的出现“Illegal instruction(cpre dumped)”错误_python illegal dump_小宋是呢的博客-CSDN博客
好了，初步cmake，所需要的编译等库装好了（根据的就是第一条链接），下面装torch框架，首先你用pip装可以，没问题，还可以运行起来yolov5，但是运行后有个问题，即使你装的torch-gpu版本，他怎么不用gpu跑啊，玩板子玩板子玩的是什么，玩的当然是gpu，你说你用cpu跑，这真的是你还是去耍树莓派吧，此处流汗黄豆，所以我们需要下torch英伟达官网给的适配whl文件，只有这里的torch是链接好nano的gpu，cuda的（此处有请我们的nvidia二爸）：
PyTorch for Jetson - Jetson Nano - NVIDIA Developer Forums
你们自己看吧，我装的是如上图的版本，这时有人问了，yolov5不是只能跑至少python3.8么，其实不会的，nvidia帮我们解决了这个问题，3.6是可以跑YOLOv5的，反正我的yolov5-7.0没有报错，其实我还训练了yolov5-5.0，他在运行这个报错了，需要高版本python，所以你如果单纯用torch跑yolov5（不用tensorrt加速和deepstream），你就用yolov5-7.0最新的训练，视频出来帧率还行，真的，但是因为没有完全调用gpu所以肯定没有tensorrt的加速快，这是肯定的，如果你用tensorrt加速和deepstream，用yolov5-5.0训练吧，因为可能模型文件不一样，后面转onnx或者engine可能会出问题，没有考证猜的，因为其他能找到的博主都是用yolov5-5.0搞得，虽然官方github项目说支持所有yolov5版本，但是以防万一，你自己看吧好吧。好了，pytorch跑yolov5成功了，如下图所示：
程序里的arguments改视频实时（摄像头代码-1,0,1都有可能，就这三个数字都试下吧），图片视频路径很简单，很方便，唯一什么问题呢，GPU没有开发完全，所以我们不满足于当下，需要加速，人嘛，都是这样的，人之本性便是贪婪永无止境，不过学习上的贪婪叫卷，卷卷更健康，是好事好吧，我们在学习技能知识，继续开干。好，隔了一天，我们继续，我们先来说使用tensorrt加速，tensorrt是英伟达调用开发板的驱动，和tensorrtx区别下哈，对于本次项目yolov5，tensorrtx是个转engine模型的项目程序，是王新宇老师开发的，在这里我们感谢老师对我们的帮助，还有幸跟他成为微信好友，朋友圈真的很厉害，永远向他学习，我们言归正传，先下载这个代码，链接在这里：
GitHub - wang-xinyu/tensorrtx at yolov5-v6.0
一定特别注意奥，这个转engine格式的项目是分yolov5版本的，因为我用v5.0版本训练的，而且v5.0版本的yolov5网上生态资料比较全，所以我点击tags选择v5.0版本下载，然后修改class-num，编译一些操作，这时可以参考下这位博主的博客：
yolov5s模型转tensorrt+deepstream检测+CSI和USB摄像头检测_yolov5s.engine_hhhhhhky的博客-CSDN博客
这是我最喜欢的博主，是我的启蒙老师，所以我当时是以他为主，在这里好好感谢这位大佬，
转成engine格式模型文件后，tensorrtx自带的cpp和python文件只能识别文件夹的图片，输入图片文件夹，吐出来整个图片文件夹，视频什么的没法实现，现在有两种方法：1.使用大佬写的程序cpp或者python程序视频检测，我还没找到导入视频检测的代码，只有视频实时检测的cpp和python代码，我都试了一下，我所有找到的python程序卡住了对于我，没法用，卡的只能重启板子，cpp的程序可以用，还是刚那位我最爱的博主，代码直接替换原来的yolov5.cpp，执行命令：
sudo ./yolov5 -v yolov5s.engine
wohuuu成功，当然摄像头参数-1,0,1都有可能，试一下就可以了，看下，帧率13，如下图所示，
真的实时检测很快，摸了板子烫的爆炸，真的是开发到极致了，同样是jtop的gpu显示满格100，这里才是真正的调用完全，甚至比我之后说的deepstream帧率要高， 其中实时视频检测达到13fps已经很满意了，好了，tensorrt视频实时检测搞完了，但是没法视频导入检测，现在只剩最后一种方法 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3440e3df862fcab1340a932fa38bceef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/83e70499eb7f780fa8b7c41fbb046f8b/" rel="bookmark">
			open-feign调用接口写法总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		open-feign调用接口写法总结 POST请求1、application/json普通请求header中加参数url后面追加参数url中加参数 2、application/x-www-form-urlencoded3、multipart/form-data4、参数全拼接到URL中 GET请求总结demo源码地址 POST请求 post请求，数据格式即Content-Type常见的有以下几种
application/json，form-data，x-www-form-urlencoded等，也可以像GET请求一样，参数直接拼接到url中
1、application/json 普通请求 目标接口代码 @PostMapping("/post1") public String post1(@RequestBody User user) throws JsonProcessingException { return new JsonMapper().writeValueAsString(user); } openFeign请求代码 参数通过 @RequestBody标识
请求头_Content-Type _在 @Headers注解中指定
@FeignClient(name = "feignApiClient", url = "http://localhost:8080/produce") public interface FeignApiInteferce { @Headers({"Content-Type: application/json"}) @PostMapping("/post1") String post1(@RequestBody User user); } header中加参数 目标接口代码 //header中增加参数authorization @PostMapping("/post2") public String post2(@RequestBody User user, HttpServletRequest request) throws JsonProcessingException { String authorization = request.getHeader("authorization"); return new JsonMapper().writeValueAsString(user)+", authorization=" + authorization; } openFeign请求代码 有时候接口验签，header中需要追加一些参数；通过@RequestHeader注解实现
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/83e70499eb7f780fa8b7c41fbb046f8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c6fd54ba4e4bfa960f15066e3ca82fe4/" rel="bookmark">
			关于疲劳驾驶检测的调研
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		关于疲劳驾驶检测的调研 疲劳检测指标主动疲劳 vs 被动疲劳疲劳 vs 嗜睡 数据客观疲劳数据生理数据基于脑的生理数据基于心脏的生理数据基于眼睛的生理数据基于肌肉/皮肤的生理数据基于呼吸/打哈欠的生理学数据 行为数据基于驾驶员的行为数据基于驾驶机器的行为数据 其他客观疲劳数据 主观疲劳数据 特征处理信号数据预处理去分化标准化滤波离群值处理降采样 特征提取时域分析频域分析时频域分析非线性动力学分析 图像数据数值数据多重特征选择 疲劳评估方法基于基线比较基于机器学习 局限设备部署问题环境变化问题性别差异问题实时监测问题脆弱性问题 近期发表的论文 疲劳检测指标 什么是疲劳？关于疲劳没有统一的定义。
在交通运输工业中，疲劳被分为主动型和被动型。疲劳通常被认为是一个渐进的过程，不同个体的表现有一定的差异。疲劳具有多维特征。不同的交通任务和环境导致不同的疲劳性能，对驾驶员的认知有不同的影响。 主动疲劳 vs 被动疲劳 主动性疲劳与高强度驾驶任务有关。常见的驾驶场景包括手动驾驶、在恶劣环境下驾驶、高交通参与度驾驶等，导致驾驶员注意力集中。由于司机在这些场景中的高参与感和大工作量，主动疲劳的表现更倾向于精神（认知）疲劳，如烦躁不安和缺乏体力。
被动疲劳与单调的驾驶环境和不需要主动参与的驾驶任务有关。常见的驾驶场景包括自动驾驶、夜间驾驶、高速公路驾驶、平稳飞行驾驶、平静水上驾驶等，这会逐渐降低驾驶员的警觉性。由于对这些场景的参与感较低，被动疲劳的表现更倾向于生理疲劳，如嗜睡程度的增加和表现能力的减弱。
疲劳 vs 嗜睡 高负荷任务、噪音和体育活动会导致疲劳而不是嗜睡
睡眠障碍、失眠和昼夜节律紊乱会导致嗜睡而不是疲劳
疲劳可能伴随着情绪波动
嗜睡增加瞳孔直径，而疲劳减少瞳孔直径
短暂的休息可以缓解疲劳，但并不能缓解睡意
不同场景，导致疲劳的因素不一样
不同驾驶场景下的无疲劳要求水平不一致
所以说，要根据具体的运输场景，选择合适的监测指标进行疲劳。
数据 客观疲劳数据 生理数据 基于脑的生理数据 EEG
也有研究使用近红外光谱（NIRS）通过脑血流动力的变化来分析驾驶员的状态
关于EEG数据的收集，使用干电极盖信号的缺点是抗堵塞能力差，容易产生伪影干扰，
使用八电极、双电极，甚至单电极来监测疲劳情况，并尝试使用无线、蓝牙和USB接收器来实现数据传输
基于心脏的生理数据 心电图（ECG）和胆囊心电图（BCG）可通过心电传感器、贴片电极等获得。
心率（HR）和心率变异性（HRV）根据计算得到。
可以通过方便的脉搏血氧计来监测心率。
手掌心电信号和非接触式远程生物电信号采集
基于眼睛的生理数据 EOG
通常用于过滤脑电图数据中的伪影
眼睛特征：瞳孔直径、眨眼频率（BF）、闪烁间隔时间、眨眼持续时间、眼睑闭合百分比的时间、眼睛纵横比（EAR）、扫视、眼睛跟踪
可以使用可穿戴眼动仪、护目镜、红外线相机、摄像头、生物传感器来收集眼部的数据
基于肌肉/皮肤的生理数据 皮肤电信号（GSR）
PPG信号通过脉搏血氧计可以通过测量手指[66]的皮下光吸收变化来获得
基于呼吸/打哈欠的生理学数据 疲劳会降低呼吸频率
一些传感器可以捕捉人体微小运动的无线电波，以非接触的方式收集呼吸信号
打哈欠频率，注意应区分说话和打哈欠之间的区别
行为数据 基于驾驶员的行为数据 异常的头部姿势、频繁的颈部旋转
基于驾驶机器的行为数据 横向车道位置的变化和车辆航向差异
其他客观疲劳数据 言语、体温变化等
言语产生与神经行为能力之间的精确关系以及基于言语的疲劳的定量定义有待进一步探索
主观疲劳数据 问卷/量表
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c6fd54ba4e4bfa960f15066e3ca82fe4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/632f4c00e822fbdead932712a7bed3f9/" rel="bookmark">
			在Windows中,开机自启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Windows中，你可以按照以下步骤设置程序的开机自启动： 1 使用快捷键 Win + R 打开运行对话框。 2 输入 shell:startup 并点击 确定，这将打开当前用户的启动文件夹。 3在启动文件夹中创建一个程序的快捷方式。可以右键点击文件或程序，然后选择 发送到 -&gt; 桌面（创建快捷方式）。将生成的快捷方式移动到启动文件夹中。 从此时起，当你的Windows操作系统启动时，该程序将会自动运行。
请注意，这种方法适用于当前用户的启动项。如果你希望设置全局的开机自启动，即所有用户登录后都会自动运行该程序，可以按照以下步骤操作：
使用快捷键 Win + R 打开运行对话框。
输入 shell:common startup 并点击 确定，这将打开全局的启动文件夹。
在全局启动文件夹中创建程序的快捷方式，方法与上述步骤类似。
这样，无论哪个用户登录Windows操作系统，该程序都会自动启动。
请注意，某些程序可能具有自己的选项来设置开机自启动，你可以在程序的设置或选项中查找这些选项。另外，要启动的程序必须位于可执行文件的形式，否则无法创建快捷方式并进行自启动。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7b9982572fdbbb0b56da0fdb5a59912/" rel="bookmark">
			抄袭声明！！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近有博主发布抄袭声明，说我文章很多抄的他的，在此发布声明！
一、解释 @ChuckieZhu 说我许多文章抄袭的他的，这我真记不清了，这些都是我刚学习编程拿博客用来记录时做的“问题”，如下图
如博主所言，那上面专栏的许多文章都是基于该博主的，但后来我将此专栏已关闭，重新写了一个专栏，如下图
这个专栏里的文章基本都是我自己一个字一个字打出来的，首先我写到了word，再上传的CSDN，像博主举报的第19篇文章，可能当时偷懒了，不想写了，就从原来的专栏复制过来了，很抱歉，忘记查看了，此文章已下架。
像我所说的word，我会上传到文件里面，供大家查看监督。
在此我写了spss，java，matlab，C语言等等word文件，R语言我是跟书写的。
像python类文章大多都是之前跟@川川菜鸟 学习时做的，也有很多基于该博主的。他是我的引路人，非常感谢！！
二、声明 如还有其他抄袭文章，麻烦作者私信我即可，我看到后会及时下架整改，感谢理解！！
三、 我已经很少玩博客了，以前的遗留问题，可能还有，希望大家监督，私信我。
四、 本人声明，未通过本博客文章有任何获利行为，很多粉丝我都是免费帮忙的，还记得的请帮我证明一下。本博客只是记载我的学习历程，仅此而已。谢谢大家！！！
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/863891d682a5464208db0dac769289e5/" rel="bookmark">
			【运筹优化】ALNS自适应大领域搜索算法求解TSP问题 &#43; Java代码实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、TSP问题简介二、数学建模三、实现细节四、案例实战4.1 测试案例说明4.2 Java 完整代码4.2.1 TSP_Instance 实例类4.2.2 TSP_Solution 结果类4.2.3 TSP_Util 工具类4.2.4 TSP_Solver_ALNS 算法类4.2.5 RunAndPlot 运行类 4.3 运行结果展示 一、TSP问题简介 旅行推销员问题(TSP)提出以下问题：“给定 n n n 个城市的列表，其中有一个起始城市，以及每对城市之间的距离，访问每个城市一次并返回起始城市的最短可能路线是什么？”。
这又是一个重要的NP-hard组合优化，特别是在运筹学和理论计算机科学领域。这个问题最早是在1930年提出的，是离散最优化中研究最深入的问题之一。
二、数学建模 让我们考虑一组 n n n 个城市，其中每个城市 i i i 具有坐标 ( x i , y i ) , i = 1 , 2 , . . . , n (x_i,y_i),i = 1,2,...,n (xi​,yi​),i=1,2,...,n。
在这种情况下，状态空间的每个点 X X X 必须代表我们访问 n n n 个城市的顺序中的一个可能的排列。
为简单起见，我们考虑使用字典顺序的构造初始解决方案：
目标函数评估在于计算对应于任意向量 X X X 的旅程的长度 f f f：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/863891d682a5464208db0dac769289e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/42cc2768a36d48e89d57dc398a85cbfd/" rel="bookmark">
			我的世界(MC) Forge 1.20.1 服务端搭建教程
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Debian系统使用MCSManager9面板搭建Minecraft Java版MOD服务器的教程，本教程用的Forge1.20.1服务端，用其他服务端的也可以参考一下。
本教程使用Docker来运行mc服，可以方便切换不同Java版本，方便安装多个mc服版本。
视频教程：https://www.bilibili.com/video/BV13s4y1y7sC/
1.20更新内容 1.20版本是足迹与故事的首个正式版，也是Java版的一次主要更新，发布于2023年6月7日。此次更新在Minecraft Live 2022期间宣布，主题名称于2023年3月2日的Minecraft Monthly上公布。它的部分特性从22w42a开始以内置数据包的形式开发。
这次更新加入了很多新的方块、物品和生物，例如樱花树、竹马赛克、嗅探兽、锻造模板等。此外，还增加了考古学要素，可以用刷子清理可疑的方块，发现陶片和其他物品。
Forge介绍 Minecraft Forge是一个用于Minecraft的模组开发和玩家使用的开源API（应用程序编程接口），它允许开发者创建基于Minecraft的模组，可以添加新物品、方块、实体、合成配方等。
同时，Minecraft Forge API也为玩家提供了一种管理和使用模组的方式。在Minecraft Forge API的支持下，玩家可以自由地分享、下载和使用其他开发者创建的模组，为Minecraft增添不同的内容和玩法。
使用Minecraft Forge API，开发者可以创造自己的方块、物品、实体、合成配方，甚至可以修改游戏核心代码以实现高度自定义化的游戏体验。同时，开发者还可以创建新的维度和世界生成器，增加各种新的游戏机制和功能。
对于玩家来说，Minecraft Forge API能够方便地实现安装和管理模组，玩家只需要下载适合自己Minecraft版本的Minecraft Forge，然后将想要使用的模组放入游戏的mods文件夹中，就能在游戏中使用这些模组了。
Debian搭建我的世界(MC) forge 1.19.3 服务器教程：https://blog.zeruns.tech/archives/699.html
MCSM9介绍 分布式，稳定可靠，开箱即用，高扩展性，支持 Minecraft 和其他少数游戏的控制面板。
MCSManager 面板（简称：MCSM 面板）是一款开源，分布式，轻量级，快速部署，支持大部分游戏服务端和控制台程序的管理面板。
此软件在 Minecraft 和其他游戏社区内中已有一定的流行程度，它可以帮助你集中管理多个物理服务器，动态在任何主机上创建游戏服务端，并且提供安全可靠的多用户权限系统，可以很轻松的帮助你管理多个服务器，一直在为 Minecraft，Terraria，Steam 游戏服务器管理员，运维人员和个人开发者提供健康的软件支持。
准备 首先你得有台服务器（已经有的可以忽略），本教程用的是特语云的服务器：
官网地址：https://url.vpszj.cn/teyucloud
优惠注册地址：https://url.vpszj.cn/teyucloud_r
刚好有一个月特语云所以用这个做教程。
雨云 13900K 宿迁高防云服务器性能测评：https://blog.vpszj.cn/archives/1421.html
雨云 宿迁5900X高防云服务器 性能测评：https://blog.vpszj.cn/archives/1125.html
指点云 宿迁 13900K 高防VPS 性能评测：https://blog.vpszj.cn/archives/1689.html
我的世界Java版1.17及以上版本对单核性能和内存要求较高，建议选择5900X或13900K等高主频高单核性能的服务器，内存建议4G起，如果是MOD服或人多需要再加。购买后也可以升级，可以先买低配，不够再升级。
我已经买好服务器了，本教程用的是特语云的宁波服务器，操作系统选择Debian。
默认账号一般是：root 密码在服务器控制台可以看到。
其他高性价比和便宜的VPS/云服务器推荐: https://blog.zeruns.tech/archives/383.html
连接服务器 下载安装并打开ssh客户端软件，ssh客户端软件推荐putty或mobaxterm。
在SSH客户端中输入你的服务器的IP地址或域名，还有SSH端口，然后点击打开。
如果弹出下图的警告就点是
然后输入账号并按回车，账号一般默认为root，接着输入密码并按回车确定，输入密码时不会显示出来。
温馨提示：在SSH终端中按住鼠标左键选择文字，然后松开鼠标，再在空白处单击一下，这样就把选中的文字复制了；在SSH终端单击右键即为粘贴。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/42cc2768a36d48e89d57dc398a85cbfd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f38faeae3ddbf6c547fcfee865ad333a/" rel="bookmark">
			SpringBoot框架详细介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.SpringBoot简介
2. 搭建springboot工程
3. 了解pom.xml以及配置文件
4. springboot的配置文件种类
5. java读取springboot配置文件的内容。
第一种: @Value读取
第二种: @ConfigurationProperties
6.springboot多环境开发配置
7.springboot注册web三大组件
7.1 注册servlet到springboot内置的tomcat中
7.2注册web的filter组件
7.3注册web的监听器Listener组件
8.springboot自动装配原理
8.1springboot自动包扫描
8.2 自动装配原理
1.SpringBoot简介 SpringBoot基于Spring4.0设计，不仅继承了Spring框架原有的优秀特性[IOC AOP DI]，而且还通过简化配置来进一步简化了Spring应用的整个搭建和开发过程。另外SpringBoot通过集成大量的框架使得依赖包的版本冲突，以及引用的不稳定性等问题得到了很好的解决
特征：
可以快速独立的创建Spring应用程序并且基于其Maven或Gradle插件，可以创建可执行的JARs和WARs使用了嵌入式的Servlet容器，无需生成WAR包提供自动配置的“starter”项目对象模型(POMS) 以简化Maven配置大量的自动配置，极大地简化了我们的开发无需XML文件的大量编写,也不会生成代码，底层是利用SpringBoot写好的API来调用实现,开箱即用SpringBoot也有运维监控项目的功能SpringBoot与云计算的集成 springboot:----为了简化spring工程的初始化搭建和开发过程。
2. 搭建springboot工程 (1.)
（2.)
(3)
在主类所在的包下创建controller包并在该包下创建一个HelloController类
@RestController public class HelloController { @GetMapping("hello") public Map&lt;String, Object&gt; hello() { // 创建一个用于存储返回结果的Map对象 Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); // 向Map中添加名为"name"的键值对，值为"张三" map.put("name", "张三"); // 向Map中添加名为"age"的键值对，值为25 map.put("age", 25); // 返回存储结果的Map对象 return map; } } 启动主函数：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f38faeae3ddbf6c547fcfee865ad333a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4403c0d32b228f664f43cb8a340faad2/" rel="bookmark">
			python 中的函数、函数的变量和作用域、函数的返回 return、函数的传递和嵌套、lambda 匿名函数、字典元组的拆包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、函数的作用：在开发程序时使用函数可以提高编写的效率以及代码的重用。 函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。 封装代码==》提高代码的重用性 内置函数： 例如：print() 自定义函数：使用def关键字来创建Python自定义函数 二、函数的使用步骤： 1、定义函数:把代码封装在函数的内部 2、调用函数:执行函数内部封装的代码 三、自定义函数格式: def fun(): # 定义一个函数fun # 这里是函数体 需要默认空一格tab键 # print('hello') # 函数的第一种调用方法 fun() ​ # 调用函数、如果函数只是被定义了不调用不会有输出结果，可以在其他模块种被导入使用 ​ # 函数的第二种调用方法 # __name__ 代表的是当前模块的名称，__main__ 是被运行的模块名称 if __name__=='__main__': # 主函数：是函数的入口、作用一般是用来调用代码 fun() # 调用函数 main 函数下面的代码是不会导入到其他模块中使用 四、不带参数函数 输出20个 * 号 def fun(): print('*' * 20) fun() ​ def my_sum(): a = 10 b = 20 print(a + b) ​ # 调用函数 my_sum() 五、带参数 def fun(name): # name 为行试参数 单个参数 print(name + '都是大佬!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4403c0d32b228f664f43cb8a340faad2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f2a578e2d729175c0a24975d37969f79/" rel="bookmark">
			2.压力测试&#43;优化（Jmeter）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 概述1.性能指标响应时间RT（重要）错误率（重要）HPSTPS吞吐量（重要）QPS（重要）最大响应时间最少响应时间90%响应时间 2.压测工具Apache AB加特林JMeter JMeter1.使用步骤1.1.添加线程组1.2.添加取样器1.3.添加监听器察看结果树汇总报告聚合报告 2.JMeterAddress Already in use 错误解决3.优化3.1.影响性能考虑点3.2.jvm内存模型jconsole和jvisualvm 3.3.优化步骤（重点）nginx动静分离模拟线上崩溃优化三级分类 3.x.压测指标 概述 1.性能指标 从外部看，性能测试主要关注如下三个指标【量越大越好，时间越少越好】 吞吐量:每秒钟系统能够处理的请求数、任务数。 响应时间:服务处理一个请求或一个任务的耗时。 错误率:一批请求中结果出错的请求所占比例。 响应时间RT（重要） 响应时间（Response Time:RT） 响应时间指用户从客户端发起一个请求开始，到客户端接收到从服务器端返回的响 应结束，整个过程所耗费的时间。 错误率（重要） 错误率 一批请求中结果出错的请求所占比例。 HPS HPS（Hits Per Second）: 每秒点击次数，单位是次/秒。 TPS吞吐量（重要） TPS(Transaction per Second）: 系统每秒处理交易数，单位是笔/秒。 QPS（重要） **QPS(Query per Second）:系统每秒处理查询次数，单位是次/秒。** 对于互联网业务中，如果某些业务有且仅有一个请求连接，那么TPS=QPS=HPS，一 般情况下用 TPS来衡量整个业务流程，用QPS来衡量接口查询次数，用HPS来表 示对服务器单击请求。 **无论TPS、QPS、HPS,此指标是衡量系统处理能力非常重要的指标，越大越好，根据经** **验，一般情况下:** 金融行业:1000TPS~5000OTPS，不包括互联网化的活动 保险行业:100TPS~10000OTPS，不包括互联网化的活动 制造行业:10TPS~5000TPS 互联网电子商务:1000OTPS~1000000TPS 互联网中型网站:1000TPS~50000TPS 互联网小型网站:50OTPS~10000TPS 最大响应时间 最大响应时间（MaxResponse Time）: 指用户发出请求或者指令到系统做出反应(响应) 的最大时间。 最少响应时间 最少响应时间(Mininum ResponseTime）: 指用户发出请求或者指令到系统做出反应(响应）的最少时间。 90%响应时间 90%响应时间（90%Response Time）**是指所有用户的响应时间进行排序，第90%的响 应时间。 2.压测工具 Apache AB 加特林 JMeter 文档网址：https://jmeter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f2a578e2d729175c0a24975d37969f79/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a44be6b0836cbf64677d2d5974f13b3f/" rel="bookmark">
			SpringBoot整合定时任务技术Quartz
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人简介：Java领域新星创作者；阿里云技术博主、星级博主、专家博主；正在Java学习的路上摸爬滚打，记录学习的过程~
个人主页：.29.的博客
学习社区：进去逛一逛~
@RequestMapping注解 🚀Quartz应用场景 1.导入Quartz相关坐标2.定义具体任务3. 配置类4.执行 二、SpringBoot整合定时任务技术task（简单好用）Spring task定时任务相关配置 # 一、SpringBoot整合定时任务技术Quartz 🚀Quartz应用场景 Spring Boot整合Quartz的定时任务技术可以应用于许多不同的场景。如：
定时任务调度：Quartz提供了强大的定时任务调度功能，可以帮助你在指定的时间点或按照一定的时间间隔执行任务。这在需要定期执行一些后台任务、批量数据处理、数据同步等场景下非常有用。
数据清理与归档：在系统中，可能会生成大量的临时性或历史性数据，使用Quartz可以定时执行数据清理任务，清除过期或不再需要的数据，保持系统的存储空间和性能。
缓存刷新：当系统中的一些缓存数据需要定期刷新时，可以使用Quartz定时执行任务来触发缓存的刷新操作。这可以确保缓存数据的有效性和实时性。
邮件发送：在某些场景下，需要定时发送邮件通知，比如每天发送一份报表、定期发送统计数据等。通过Quartz可以配置定时任务，定时触发邮件发送操作。
定时数据备份：定时对关键数据进行备份是一种常见的数据安全策略。使用Quartz可以定期触发数据备份任务，确保系统数据的安全性和可恢复性。
系统监控与报警：通过定时任务，可以定期对系统状态进行检查，例如CPU使用率、内存占用、磁盘空间等，当系统出现异常或达到阈值时，可以触发报警机制进行预警处理。
定时数据分析和生成报表：在数据分析和报表生成场景中，可以利用Quartz定时触发数据分析任务，生成相应的报表和统计结果。
相关概念
工作（Job）：用于定义具体执行的工作工作明细（JobDetail）：用于描述定时工作相关的信息触发器（Trigger）：用于描述触发工作的规则，通常使用corn表达式定义调度规则调度器（Scheduler）：描述了工作明细与触发器的对应关系 1.导入Quartz相关坐标 pom.xml文件:
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 2.定义具体任务 定义具体要执行的任务，继承QuartzJobBean抽象类
/** * @author .29. * @create 2023-04-03 16:09 */ //第一步：造任务 //使用Quartz技术，需要让类继承QuartzJobBean抽象类，实现其抽象方法 public class MyQuartz extends QuartzJobBean { //此方法种指定具体功能 @Override protected void executeInternal(JobExecutionContext context) throws JobExecutionException { System.out.println("quartz is running ..."); } } 3. 配置类 定义工作明细与触发器，绑定对应关系
/** * @author .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a44be6b0836cbf64677d2d5974f13b3f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/87621eb644eaa824fbedb30e55d702f1/" rel="bookmark">
			【C/C&#43;&#43;】回溯经典算法之八皇后问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		八皇后问题
八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。
思路：
利用回溯法解决
1.创建一个全局变量的二维数组chess;并初始化全为0。数组中1为皇后，0为空位置。
2.一行一行开始放皇后；放皇后之前检查是否适合，若存在相互攻击，则皇后向右移一列，若位置适合，进行下一行皇后的放置（递归）
3.到达最后一行的时候在合适的位置开始计数。
#include &lt;bits/stdc++.h&gt; using namespace std; #define N 8 //可以根据N来修改棋盘的格数 int cnt = 0;//设置一个计数器 int chess[N][N] = {0};//用于存放棋盘的二维数组 void print()//打印函数 {	int i = 0; int j = 0; printf("*****************************************\n"); for(i = 0; i&lt;N ;i++) { for(j = 0; j&lt;N ; j++) { printf("%d ",chess[i][j]); } printf("\n"); } printf("*****************************************\n"); } //判断放置的位置是否符合要求 //返回0 表示存在互吃 //返回1 表示正常 int check(int i, int j) {	if(i == 0) return 1;//表示正常 if(i&gt;=N||j&gt;=N) return 0; //同一列 int k = 0,s=0; for(k = 0; k&lt;i ; k++) { if(chess[k][j] == 1) return 0; } //同一行 for(k = 0; k&lt;N ; k++) { if(k==j) continue; if(chess[i][k] == 1) return 0; } //左斜上 s = i-1;k = j-1; while(s&gt;=0&amp;&amp;k&gt;=0) { if(chess[s][k] == 1) return 0; s = s-1; k = k-1; } //右斜上 s = i-1;k = j+1; while(s&gt;=0&amp;&amp;k&lt;N) { if(chess[s][k] == 1) return 0; s = s-1; k = k+1; } return 1; } //算法主体 void queen(int i,int j) {	if(i&gt;=N||j&gt;=N) return; //判断是否进入下一行	if(check(i,j)==1)//当可以放皇后时 {	chess[i][j] = 1;//放入 queen(i+1,0);//进行下一行的皇后放置 } if((i==(N-1)))//最后一行 {	if(check(i,j)==1)//当最后一行的皇后可以放下（表示可以成功放置）	{ chess[i][j] = 1; //print();//打印 cnt++;//计数器+1 } }	//不符合，置零，右移 chess[i][j] = 0; queen(i,j+1); } int main() {	queen(0,0); printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/87621eb644eaa824fbedb30e55d702f1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7ab79de825cf9a456859087bec42a8fb/" rel="bookmark">
			echarts图表-饼图、柱状图、折线图、散点图之间相互切换
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如有不足的地方还望大家多多指点
目录
1.创建简单的图表
2.结构样式
3.json数据
4.渲染图表函数
5.柱状图和折线图还有散点图的数据格式
6.柱状图
7.折线图
8.饼图
9.散点图
1.创建简单的图表 首先第一步下载echarts.js插件
点击这里前往下载
点进去之后跟着步骤进行下载
下载完之后引入./js/echarts.js插件
&lt;script src="./js/echarts.js"&gt;&lt;/script&gt; 第二步:
创造一个容器，必须设置宽和高，具体大小不固定
&lt;div id="main" style="width: 100%;height:99vh;"&gt;&lt;/div&gt; 第三步:
创建一个script标签
&lt;script type="text/javascript"&gt;&lt;/script&gt; 第四步：
通过 echarts.init 方法初始化一个 echarts 实例并通过 setOption 方法生成一个简单的柱状图。
下面就是完整的代码。然后具体编辑可以根据上面的链接进行修改哦~
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;ECharts&lt;/title&gt; &lt;!-- 引入刚刚下载的 ECharts 文件 --&gt; &lt;script src="./js/echarts.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 为 ECharts 准备一个定义了宽高的 DOM --&gt; &lt;div id="main" style="width: 100%;height:99vh;"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; // 基于准备好的dom，初始化echarts实例 var myChart = echarts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7ab79de825cf9a456859087bec42a8fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a2a29140ae9ed6cee00bb367ba2cb8b0/" rel="bookmark">
			从小白到大神之路之学习运维第42天---第三阶段----HAProxy开源负载均衡软件（工作原理、架构图、流程图、组成、centos7上部署haproxy&#43;nginx&#43;nfs（脚本部署）操作）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第三阶段基础
时 间：2023年6月16日
参加人：全班人员
内 容：
HAProxy开源负载均衡软件
目录
一、主要信息
整个系统是由以下三个组件构成:
二、HAProxy 工作原理
三、架构图
四、Haproxy 流程图
五、Haproxy 组成
六、centos7上部署haproxy+nginx+nfs（脚本部署）
实验环境配置：
haproxy的服务器配置：
nfs+rps服务器部署：
nginx服务器1部署:
nginx服务器2部署：
结果测试：
一、主要信息 HAProxy 是一款流行的开源负载均衡软件，它可以帮助在高流量网站上分担负载，提高网站的可靠性和性能。
HAProxy 通常用于将来自客户端的流量分发到多个服务器中，以实现负载均衡。
它还提供了高可用性和故障恢复功能，例如健康检查和自动切换到备用服务器。
另外，HAProxy 还提供了很多高级功能，例如 SSL 终止、HTTP 压缩和请求缓存。HAProxy 的架构是基于事件驱动的，它运行在一个单一的进程中，并使用多线程和单线程事件循环机制来处理多个并发连接。
整个系统是由以下三个组件构成: 1.**客户端**:指浏览器或其他客户端应用程序，向 HAProxy 发送请求。
2.**HAProxy 服务器**: 运行在中间层的 HAProxy 服务器，接收来自客户端的请求，并将它们转发到后端服务器以处理请求。
3.**后端服务器**:这些服务器用于响应客户端请求。HAProxy 可以链接到多个服务端以实现负载均衡。在 HAProxy 结构中，后端服务器被组织成一个服务器池，它们可以是物理或虚拟服务器
当客户端连接到 HAProxy 服务器时，它们会被定向到适当的后端服务器。HAProxy 可以使用多种负载平衡算法来判断哪些后端服务器需要处理请求。一旦 HAProxy 选择了一个后端服务器，它会将客户端的请求转发到该服务器并返回响应。HAProxy 的优势在于它可以处理数百万个并发连接，同时提供高可用性、可扩展性和性能优化功能。
二、HAProxy 工作原理 如下：
1.客户端发起连接:当客户端发起连接请求时，它将连接到 HAProxy 提供的 IP 地址和端口。
2.HAProxy 接受连接请求: HAProxy 将客户端连接请求接受到其监听的端口上，以等待后续的请求。
3.检查请求: HAProxy 会检查请求并根据预定义的负载平衡规则，将请求分发到其中一个可用的后端服务器。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a2a29140ae9ed6cee00bb367ba2cb8b0/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/86699b55c9214b8022b78f96227e5e09/" rel="bookmark">
			go语言web开发系列之十六:gin框架中通过gorm使用事务
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一，演示项目的相关信息 1,地址：
GitHub - liuhongdi/digv16: gin框架中通过gorm使用事务
2，功能：以下订单为例，演示了在gorm中启用事务
3, 项目结构：如图:
说明：刘宏缔的go森林是一个专注golang的博客，
网站：https://blog.imgtouch.com
原文: go语言web开发系列之十六:gin框架中通过gorm使用事务 – 架构森林
说明：作者:刘宏缔 邮箱: 371125307@qq.com
二，数据库及sql 1，数据表:
2,建表sql:
CREATE TABLE `m_goods` ( `goodsId` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '商品id', `goodsName` varchar(200) NOT NULL DEFAULT '' COMMENT '商品名称', `stock` int unsigned NOT NULL DEFAULT '0' COMMENT '库存数量', PRIMARY KEY (`goodsId`) ) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='商品表' CREATE TABLE `m_order` ( `orderId` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '订单id', `userId` bigint unsigned NOT NULL DEFAULT '0' COMMENT '用户id', `salePrice` decimal(10,0) NOT NULL DEFAULT '0' COMMENT '订单金额', PRIMARY KEY (`orderId`), KEY `userId` (`userId`) ) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='订单表' CREATE TABLE `m_order_goods` ( `ogId` bigint unsigned NOT NULL AUTO_INCREMENT COMMENT 'id', `orderId` bigint unsigned NOT NULL COMMENT '订单id', `goodsId` bigint unsigned NOT NULL COMMENT '商品id', `buyNum` int unsigned NOT NULL COMMENT '购买数量', PRIMARY KEY (`ogId`), UNIQUE KEY `orderId_2` (`orderId`,`goodsId`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='订单商品表' 3,插入一条演示数据:
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/86699b55c9214b8022b78f96227e5e09/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f7232d758c2564b10851661abed6f968/" rel="bookmark">
			win10 &#43; annaconda &#43; tensorflow2.0环境搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 目录
一、查询tensorflow版本对应环境
二、安装CUDA和cuDNN
三、创建虚拟环境，安装tensorflow2.0
一、查询tensorflow版本对应环境 在tensorflow官网查询，地址如下：
https://www.tensorflow.org/install/source_windows
以tensorflow2.0.0为例：
二、安装CUDA和cuDNN CUDA下载：
CUDA Toolkit - Free Tools and Training | NVIDIA Developer
cuDNN下载：
cuDNN Archive | NVIDIA Developer
三、创建虚拟环境，安装tensorflow2.0 创建虚拟环境：
conda create -n tensorflow python=3.6 激活环境：
activate tensorflow2.0 安装tensorflow2.0：
pip install tensorflow-gpu==2.0.0a.0 numpy==1.16.4 -i https://pypi.tuna.tsinghua.edu.cn/simple 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/683244ddb9dcc7dd77ee0efb5e723d41/" rel="bookmark">
			【读点论文】RTMDet: An Empirical Study of DesigningReal-TimeObjectDetectors.2023年的YOLOv4，很强的工程经验，让智能走出实验室
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		RTMDet: An Empirical Study of Designing Real-Time Object Detectors Abstract 在本文中的目标是设计一个高效的实时目标检测器，它超越了YOLO系列（yolov8,yolo-nas没比较），并且易于扩展到许多目标识别任务，如实例分割和旋转目标检测。为了获得更有效的模型架构，探索了一种在主干和颈部具有兼容能力的架构，该架构由由大核深度卷积组成的基本构建块构建。在动态标签分配中，进一步在计算匹配代价时引入软标签，以提高准确性。结合更好的训练技术，最终的目标检测器RTMDet在NVIDIA 3090 GPU上实现了52.8%的AP和300+ FPS，优于目前主流的工业检测器。
RTMDet在各种应用场景中实现了微型/小型/中型/大型/超大模型尺寸的最佳参数精度权衡，并在实时实例分割和旋转目标检测方面获得了最新的性能。希望实验结果可以为设计多用途实时目标检测器提供新的见解，用于许多目标识别任务。
代码和模型发布在 mmdetection/configs/rtmdet at 3.x · open-mmlab/mmdetection · GitHub 。
官方开源地址： https://github.com/open-mmlab/mmdetection/blob/3.x/configs/rtmdet/README.md
论文地址：[2212.07784] RTMDet: An Empirical Study of Designing Real-Time Object Detectors (arxiv.org)
openmmlabB站视频讲解：【OpenMMLab 2.0 系列直播】RTMDet_哔哩哔哩_bilibili
在调研了当前 YOLO 系列的诸多改进模型后，MMDetection 核心开发者针对这些设计以及训练方式进行了经验性的总结，并进行了优化，推出了高精度、低延时的单阶段目标检测器 RTMDet, Real-time Models for Object Detection (Release to Manufacture)。随着新技术（训练，推理，数据增强，损失函数设计，模块设计，模型配置思路）的出现，还会有新的“RTMDet”。
Introduction 最优的效率一直是目标检测的首要追求，特别是在自动驾驶、机器人和无人机的现实世界感知中。为了实现这一目标，YOLO系列探索了不同的模型架构和训练技术，以不断提高一级目标检测器的精度和效率。
在本报告中，本文的目标是推动YOLO系列的极限，并为目标检测提供一个新的实时模型系列，名为RTMDet，它还能够进行实例分割和旋转目标检测，这是以前的工作没有探索过的。吸引人的改进主要来自大核深度卷积的更好表示和动态标签分配中软标签的更好优化。
具体来说，首先在模型的主干和颈部的基本构建块中利用大核深度卷积，这提高了模型捕获全局上下文的能力。由于直接在构建块中放置深度卷积会增加模型深度从而减慢推理速度，因此进一步减少构建块的数量以减少模型深度并通过增加模型宽度来补偿模型容量。还观察到，在颈部添加更多的参数并使其容量与骨干兼容可以实现更好的速度精度权衡。模型架构的整体修改使得RTMDet的推理速度更快，而不依赖于模型的重新参数化。
进一步重新审视训练策略以提高模型的准确性。除了更好地结合数据增强、优化和训练计划外，还通过经验发现，在匹配ground truth boxes和模型预测时，通过引入软目标而不是硬标签，可以进一步改进现有的动态标签分配策略。这样的设计提高了成本矩阵的判别性，实现了高质量的匹配，同时也降低了标签分配的噪声，从而提高了模型的精度。
RTMDet是通用的，可以很容易地扩展到实例分割和旋转对象检测，几乎没有修改。通过简单地添加一个内核和一个掩码特征生成头[Sparse instance activation for real-time instance segmentation,Conditional convolutions for instance segmentation]，RTMDet只需要大约10%的额外参数就可以执行实例分割。对于旋转对象检测，RTMDet只需要扩展盒回归层的维度(从4到5)，并切换到旋转盒解码器。还观察到，在一般目标检测数据集上的预训练有利于空中场景下的旋转目标检测。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/683244ddb9dcc7dd77ee0efb5e723d41/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8b9d27f174b311e324d8f1e7c0c660bf/" rel="bookmark">
			IDEA嵌入式AI工具 BITO-GPT4导入以及中文设置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		IDEA嵌入式AI BITO效果展示：
1.打开IDEA的Settings 搜索插件 BITO 2.下载后右边工具栏上会出现BITO的小蓝标
这样就可以使用了但是里面是全英文的
相信很多小伙伴看到英文就头疼噢
设置中文
1.打开BITO点击右上角设置
2.点击里面的Settings
进入BITO的Web网页
右边这个改成中文
这样回到IDEA AI就会生成中文啦
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/45fb80c1604c3531edeab488d263baff/" rel="bookmark">
			常用的传递函数离散化方法，差分，双线性，预矫正双线性，matlab源码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 1. 传递函数严格离散化2. 离散化方法，前向欧拉，前向差分3. 离散化方法，后向欧拉，后向差分4. 离散化方法，双线性变换，Tustin5. 离散化方法，预矫正双线性变换，Tustin with Pre-Warping5.1 问题描述5.2 解决方案 6. 总结 1. 传递函数严格离散化 傅里叶变换、拉普拉斯变换，以及 Z Z Z变换的定义如下所示：
傅里叶变换 : { F ( ω ) = ∫ − ∞ ∞ f ( t ) e − j ω t d t f ( t ) = 1 2 π ∫ − ∞ ∞ F ( ω ) e j ω t d ω 傅里叶变换:\left\{ \begin{array}{l} F\left( \omega \right) = \int_{ - \infty }^\infty {f\left( t \right){e^{ - j\omega t}}dt} \\ f\left( t \right) = \frac{1}{{2\pi }}\int_{ - \infty }^\infty {F\left( \omega \right){e^{j\omega t}}d\omega } \end{array} \right.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/45fb80c1604c3531edeab488d263baff/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae83abdf0f0e18f568f3d4c3f7c2702c/" rel="bookmark">
			Linux系统下安装使用anaconda教程。
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装和使用Anaconda是在Linux系统上进行Python开发和数据科学工作的常见方法之一。
以下是在Linux系统下安装和使用Anaconda的基本步骤：
下载Anaconda：访问Anaconda官方网站（https://www.anaconda.com）并下载适用于Linux系统的Anaconda安装包。根据你的系统架构选择合适的版本（通常是64位）。
安装Anaconda：打开终端窗口，导航到下载的Anaconda安装包所在的目录，并运行以下命令进行安装：
bash Anaconda-latest-Linux-x86_64.sh 安装过程中会出现一些提示，你可以按照默认设置进行安装，或者根据需要进行自定义配置。
完成安装：安装完成后，按照终端窗口中的提示，将Anaconda的bin目录添加到系统的PATH环境变量中。这样可以方便地在终端中运行Anaconda的命令。
验证安装：在终端中运行以下命令验证Anaconda是否安装成功：
conda --version 如果能够正确显示Anaconda的版本信息，则表示安装成功。
创建和管理环境：使用Anaconda可以创建和管理不同的Python环境。你可以使用以下命令创建一个新的环境：
conda create --name myenv 其中，myenv是环境的名称，你可以根据需要自定义。
激活环境：要在终端中激活一个环境，可以运行以下命令：
conda activate myenv 这将使得你在该环境下安装的软件包对当前终端会话生效。
安装和管理软件包：使用Anaconda可以方便地安装和管理各种Python软件包。要安装一个软件包，可以运行以下命令：
conda install package_name 其中，package_name是你想要安装的软件包名称。
使用Anaconda Navigator（可选）：Anaconda还提供了一个图形化界面工具Anaconda Navigator，用于管理环境、安装软件包和启动应用程序。你可以在终端中运行以下命令启动Anaconda Navigator：
anaconda-navigator 这将打开Anaconda Navigator的图形界面。
以上是在Linux系统下安装和使用Anaconda的基本步骤。安装完成后，你可以根据自己的需要创建环境、安装软件包，并使用Python和数据科学工具进行开发和分析工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d8bce31984bbae00650af8f0e42ac58c/" rel="bookmark">
			虚拟机Centos7无法ping通百度的详细解决方式(详细有效)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我在这个问题上花费了很多时间，弄了好久才弄懂，所以现在把我自己的总结写下来，希望能帮助到遇到同样问题的人，可以少花点时间，也能把虚拟机的网络环境配置给弄好。
目录
问题描述：虚拟机无法ping通百度的问题
解决方式：
方式1：不使用静态ip，而是使用dhcp，使用网桥连接
解决方式二：配置好静态ip，调试好网络适配器，使用NAT模式连接
如果文章有帮助到你，可以点个赞吗？如果有哪里不太懂了或不对得地方，欢迎留言，看到我会尽快回复
问题描述：虚拟机无法ping通百度的问题 1 有可能是你本身的网卡配置有问题，
2 可能你当前选用了仅主机模式网络配置
3 当你配置到静态ip地址后，导致了ping 通百度（本地可以ping 通虚拟机，但虚拟机无法上网）
问题3：这个问题是我们导致我们无法访问百度的最常见的原因
解决方式： 在这里我给出二种解决方法
方式1：不使用静态ip，而是使用dhcp，使用网桥连接 这种方式就是虚拟机默认的使用方式，这种方式简单使用，缺点就是ip地址会动态变化，不稳定
使用命令:uuidgen 可以获取虚拟机的uuid的值
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=dhcp #动态获取ip
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=19f26a29-00ad-40ab-aa93-a43424d8b749 #获取自己本机的
DEVICE=ens33
ONBOOT=yes #开机自启动
如果你不想麻烦，这种方式是最直接有效的。
解决方式二：配置好静态ip，调试好网络适配器，使用NAT模式连接 类型：使用静态ip导致无法上网
总结：1 虚以太网适配器NAT对应的适配器的网段和虚拟网络编辑器在同一个网段
2 静态ip得设置和虚拟网络编辑器得设置一样
具体步骤：
如图：
第一步：查看主机：以太网适配器 VMware Network Adapter VMnet8（对应NAT模式的适配器）:
打开虚拟机的虚拟网络编辑器（编辑--》虚拟网络编辑器）
将其修改成如下（这里如果不想自己修改的话，直接点击还原默认设置，会自动给你配置好，我建议不熟悉配置的可以这样做）
第三步：配置静态IP（这里自己配置的静态IP如下）
这里不会配置的可以参考我的另一篇配置静态ip的文章
centos7虚拟机静态ip设置详细教程(超全超详细亲测有效)_centos7 配置静态ip_smilehjl的博客-CSDN博客
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=static
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/d8bce31984bbae00650af8f0e42ac58c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bef5704e8aadcdbb1e754303bc8238b/" rel="bookmark">
			计算机网络之链路层和局域网
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		六.链路层和局域网 6.1 链路层概述 6.1.1 链路层可能提供的服务 成帧、链路接入、可靠交付、差错检测和纠正
6.1.2 链路层在何处实现 下图是一个典型的主机体系结构，链路层的主体部分是在网络适配器实现的，部分链路层是在运行于主机CPU上的软件实现的。网络适配器有时也称为网络接口卡。位于网络适配器核心的是链路层控制器，该控制器通常是一个实现了许多链路层服务（成帧、链路接入、差错检测等）的专用芯片。因此，链路层控制器的许多功能是用硬件实现的。
链路层是硬件和软件的结合体，即此处是协议栈中软件与硬件交接的地方。
6.2 差错检测和纠正技术 奇偶校验检验和方法循环冗余检测 6.3 多路访问链路和协议 点对点链路：由链路一端的单个发送方和链路另一端的单个接收方组成。许多链路层协议都是为点对点链路设计的，如点对点协议（point - to - point protocol，PPP）、高级数据链路控制（high-level data link conltrol，HDLG）就是两种这样的协议。
广播链路：它能够让多个发送和接收节点都连接到相同的、单一的、共享的广播信道上。以太网和无线局域网是广播链路层技术的例子。
多路访问问题：如何协调多个发送和接收节点对一个共享广播信道的访问，这就是多路访问问题。
注意
广播信道通常位于局域网中，局域网是一个地理位置上集中在一座建筑物中的网络。如一个公司、一所大学。多路访问链路应该就是广播链路 这些年来，在大量的链路层技术中已经实现了几十种多路访问协议。尽管如此，我们能够将任何多路访问协议划分为 3 种类型之一：信道划分协议，随机接入协议，轮流协议。
6.3.1 信道划分协议
6.3.2 随机接入协议
6.3.3 轮流协议
6.3.4 DOCSIS：用于电缆因特网接入的链路层协议
6.4 交换局域网 6.4.1 链路层寻址和ARP 1.MAC地址
每个主机和路由器的适配器（网络接口）都具有链路层地址，而链路层交换机并不具有链路层地址。这个链路层地址有许多称呼，一般将它称之为MAC地址。
MAC地址长度为6字节，这六个字节地址通常用十六进制表示法，地址的每个字节被表示为一对十六进制数。
注意
没有任何二块适配器具有相同地MAC地址。发送适配器想要广播帧时，只需要在该帧的目的地址字段插入一个特殊的MAC广播地址，广播地址的十六进制表示法为FF-FF-FF-FF-FF-FF。 2.地址解析协议
因为存在网络层地址（例如，因特网的 IP 地址）和链路层地址（即 MAC 地址），所以需要在它们之间进行转换。对于因特网而言、这是地址解析协议的任务。
ARP协议：ARP协议是一个地址解析协议，它能够为同一个子网中上的主机和路由器接口解析IP地址。
ARP协议解析目的IP地址的步骤
如下图所示，每台主机或路由器在其内存中具有一个ARP表，这张表包含IP地址到MAC地址的映射关系。该ARP表也包含了一个寿命值，它指示了从表中删除每个映射的时间。
现在，发送主机需要获得给定 IP 地址的目的主机的 MAC 地址
第一步：如果发送方 ARP 表具有该目的节点的表项，则直接可以获取到
第二步：如果ARP表不存在此表项，发送方用 ARP 协议来解析这个地址。首先，发送方构造一个称为 ARP 分组的特殊分组。一个ARP 分组有几个字段，包括发送和接收 IP 地址及 MAC 地址。 ARP 查询分组和响应分组都具有相同的格式。ARP 查询分组的目的是询问子网上所有其他主机和路由器，以确定对应于要解析的 IP 地址的那个 MAC 地址。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7bef5704e8aadcdbb1e754303bc8238b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1002513f66a2327e4ddd01320057b89/" rel="bookmark">
			盘点五种最常见加密算法！
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		大家好，我是Martin。
今天，就给大家来盘点一下最常见的5种加密算法。
大家平时的工作中，可能也在很多地方用到了加密、解密，比如：
用户的密码不能明文存储，要存储加密后的密文
用户的银行卡号、身份证号之类的敏感数据，需要加密传输
还有一些重要接口，比如支付，客户端要对请求生成一个签名，服务端要对签名进行验证
……
非常安全
那么上面提到的这些能力，我们都可以利用哪些加密算法来实现呢？咱们接着往下看。
常见加密算法 算法整体上可以分为不可逆加密，以及可逆加密，可逆加密又可以分为对称加密和非对称加密。
加密算法分类
不可逆算法 不可逆加密的算法的加密是不可逆的，密文无法被还原成原文。
散列算法，就是一种不可逆算法。散列算法中，明文通过散列算法生成散列值，散列值是长度固定的数据，和明文长度无关。
散列算法
散列算法的具体实现有很多种，常见的包括MD5、SHA1、SHA-224、SHA-256等等。
散列算法常用于数字签名、消息认证、密码存储等场景。
散列算法是不需要密钥的，当然也有一些不可逆算法，需要密钥，例如HMAC算法。
MD5 MD5，全称为“Message-Digest Algorithm 5”，翻译过来叫“信息摘要算法”。它可以将任意长度的数据通过散列算法，生成一个固定长度的散列值。MD5算法的输出长度为128位，通常用32个16进制数表示。
我们来看下MD5算法的Java代码实现：
public class MD5 { private static final String MD5_ALGORITHM = "MD5"; public static String encrypt(String data) throws Exception { // 获取MD5算法实例 MessageDigest messageDigest = MessageDigest.getInstance(MD5_ALGORITHM); // 计算散列值 byte[] digest = messageDigest.digest(data.getBytes()); Formatter formatter = new Formatter(); // 补齐前导0，并格式化 for (byte b : digest) { formatter.format("%02x", b); } return formatter.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1002513f66a2327e4ddd01320057b89/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4b6dc700a322bca7cf207e63b9e19a50/" rel="bookmark">
			相机硬触发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		硬触发后,相机回调会自动触发,监听回调事件就可以了
HOperatorSet.SetFramegrabberParam(AcqHandle,"FrameStartTriggerMode","On");
HOperatorSet.SetFramegrabberParam(AcqHandle,"grab_timeout",100);
HOperatorSet.SetFramegrabberParam(AcqHandle,"LineSelector","Line1");
HOperatorSet.SetFramegrabberParam(AcqHandle,"LineFormat","TTL");
HOperatorSet.SetFramegrabberParam(hv_AcqHandle, "grab_timeout", -1); HFramegrabberCallback delegateCallback; delegateCallback = MyCallbackFunction;
还没验证
delegateCallback = MyCallbackFunction;
HalconDotNet.HOperatorSet.SetFramegrabberParam(camera.AcqHandle, "AcquisitionMode", "Continuous");
HalconDotNet.HOperatorSet.SetFramegrabberParam(camera.AcqHandle, "TriggerSelector", "FrameStart");
HalconDotNet.HOperatorSet.SetFramegrabberParam(camera.AcqHandle, "TriggerActivation", "RisingEdge");
HalconDotNet.HOperatorSet.SetFramegrabberParam(camera.AcqHandle, "ExposureMode", "Timed");
HalconDotNet.HOperatorSet.SetFramegrabberParam(camera.AcqHandle, "ExposureTime", 80000.0);
HalconDotNet.HOperatorSet.SetFramegrabberParam(camera.AcqHandle, "grab_timeout", -1);
IntPtr ptr = Marshal.GetFunctionPointerForDelegate(delegateCallback);
IntPtr ptr1 = GCHandle.Alloc(test, GCHandleType.Pinned).AddrOfPinnedObject();
HalconDotNet.HOperatorSet.SetFramegrabberCallback(camera.AcqHandle, "transfer_end", ptr, ptr1);
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b461264aec94c0870d7f90fd24566bb9/" rel="bookmark">
			python-文件写入操作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文件写入 文章目录 文件写入1. 写入文件的不同模式：2. 写入字符串数据：3. 写入字节数据：4. UTF-8介绍 在Python中，文件写入提供了不同的模式和方法来满足不同的需求。以下是关于文件写入的全部内容及示例代码： 1. 写入文件的不同模式： 覆盖模式（“w”）：打开文件并将内容写入文件，如果文件存在，则覆盖原有内容。如果文件不存在则创建一个新的文件。追加模式（“a”）：打开文件并将内容写入文件，如果文件存在，则在文件末尾添加内容。如果文件不存在则创建一个新的文件。读写模式（“r+”）：打开文件供读取和写入，如果文件存在，则覆盖原有内容。如果文件不存在，将抛出FileNotFoundError异常。 2. 写入字符串数据： 使用write()方法将字符串数据写入文件。可以一次写入完整的字符串，也可以多次写入分段的字符串。 # 写入字符串数据示例 with open("file.txt", "w") as file: file.write("Hello, World!\n") file.write("This is a new line.") 3. 写入字节数据： 使用write()方法将字节数据写入文件。可以使用encode()方法将字符串转换为字节数据进行写入。 # 写入字节数据示例 with open("file.txt", "wb") as file: content = "Hello, World!\n" file.write(content.encode("utf-8")) 4. UTF-8介绍 UTF-8（Unicode Transformation Format - 8-bit）是一种通用的字符编码方案，用于在计算机系统和应用程序中表示Unicode字符集。它是一种可变长度的编码方式，可以表示几乎所有国家的字符，包括拉丁字母、亚洲文字、符号等。
在Python中，字符串是以Unicode编码进行内部表示的。当你需要将字符串写入文件时，通常需要将其编码为字节序列。通过使用encode()方法，你可以将字符串转换为指定的字符编码，其中"utf-8"表示使用UTF-8编码。
在给定的代码中，content.encode("utf-8")是将字符串content编码为UTF-8格式的字节序列。然后，file.write()方法用于将这些字节写入文件中，以便持久保存或传输。这样做可以确保文件中的数据以UTF-8编码进行存储，以便后续读取和处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1fc213c02cc61975bfb3107540ab3200/" rel="bookmark">
			Element Plus 的日期组件修改成中文显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在mainjs中引入import zhCn from ‘element-plus/es/locale/lang/zh-cn’ import ElementPlus from 'element-plus' import 'element-plus/dist/index.css' import zhCn from 'element-plus/es/locale/lang/zh-cn' const app = createApp(App) app.use(ElementPlus, { locale: zhCn }) app.mount('#app') 官网介绍参考
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dca418f28244ca09a40095387655970b/" rel="bookmark">
			基于springboot&#43;微信小程序实现企业活动积分平台系统演示【附项目源码&#43;论文说明】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于springboot+微信小程序实现企业活动积分程序演示
课题背景及意义 在互联网飞速发展的今天，传统企业管理模式已经落伍，建立新型信息管理系统显得尤为重要。在信息化管理模式下，企业的整体效率会大幅改善，同时效益也会大大提高，不仅提高了市场竞争力，而且会相应提高员工待遇和员工参与企业活动的积极性。而在信息化时代背景下如何提高员工的工作积极性？如何在日常的管理过程中对员工的行为进行激励？如何使得员工的表现和企业的目标保持一致，这是企业的管理者都非常关心的问题。奖励员工，不仅是对员工工作业绩的认可，而且也是对员工的一种鼓励。良好的激励机制，有利于充分调动员工的积极性，有利于激发员工的创造性，提高企业的经济效益。因此，企业应当重视对员工的奖励。奖励要得当，恰到好处，让员工感受到自己的利益与企业的命运紧密相连，真正把企业当作自己的企业当作自己的家一样对待。各个企业管理方式不同，奖励的方式也不同，但奖励的目的是一致的。奖励的方式也不外乎物质和精神两种。但企业可以通过设定奖励的具体内容，使员工感受到能者真正能多得，不能者则少得的分配原则，体现按劳分配的精神。在传统的管理模式下，往往对于员工的激励及奖励的手段非常单一，要么是货币的奖励，要么是口头鼓励。 这样的形式较难形成一种机制和体制上管理方式。一方面，企业的管理者操作起来比较麻烦，而同时，员工的感知程度也不是很高。
在此基础上，许多企业慢慢开始借鉴行业的其他一些有效的方式。比如航空公司、银行等对于客户的奖励制度，也就是我们非常熟悉的客户忠诚度计划。在这样的计划中，企业会将希望客户实施的行为设置成一些奖励项，比如，多购买本航空公司的机票，多刷某个银行的信用卡，飞得越多或者刷卡金额越多，那可以获得企业给予的奖励回馈，如里程奖励、积分奖励等。而消费者、客户，因为参加了这样的奖励计划，使得消费行为会显得非常有粘性，非常有忠诚度，而消费者的行为，反过来推动了公司的业绩增长。
因此，客户对于企业的忠诚度就慢慢被延伸到员工对于企业的忠诚度。其实，我们可以看到，这两者在本质上是相通的。即都是希望对某些群体的行为进行激励和奖励，而使得对方的行为产生与企业绩效相一致的效果，提升企业的业绩。而作为群体中的个体，因为在遵循企业导向性的行为过程中获得奖励和激励，因此个体的行为就会更有动力和价值，通过这样的机制，将个体的行为方式和企业的目标绑定在了一起。一方面，提高企业的绩效目标；另一方面，提高了个体员工的忠诚度和粘性，达到和谐发展。
而通过积分奖励，则能够有效地提高全体员工的工作积极性，激发创造性，优化公司激励机制，提升员工的忠诚度，以加强公司核心竞争力，确保公司持续、稳健发展。在此基础之上，本文提出一种企业员工积分微信小程序，通过微信小程序和企业员工奖励措施相结合，能够方便有效的实施奖励计划，从而促进企业员工的积极性。
国内研究现状 企业员工既需要严格管理，也需要奖励。在这方面，国内外企业采取了不同的奖励措施。
美国国际商务机器公司IBM采取创立百分百俱乐部的方法奖励员工，明确规定只要表现好，工作任务完成出色，即可加入。IBM公司还有个惯例，就是为工作成绩名列前85 %以内的销售人员举行隆重的庆祝活。贝尔实验室规定了一项专门奖励采用别人成果而取得突出成绩的人。每月评一次，获奖者的事迹和照片将摆放在最引人注目的地方。美国通用电气公司实施了一个名为快速感谢的奖励计划。该计划规定，员工可以提名任何一位同事接受价值8美元的礼品券。此礼品券可在指定餐馆或商场使用。据统计，在实施的当年就颁发了9万份礼品券。
而在国内，例如，浙江万向集团在改革劳动用工制度中推出的奖励员工新举措是每三年在企业职工中评出3%-5%的终身职工”，评委决定权归职工代表大会。在企业工作满九年以上的干部、合同工和临时工均有资格参与评比。凡评为终身职工者即可享受包括医疗保险、子女入学资助、住房补等多种特殊福利待遇。
而对于积分系统的管理，积分管理系统本身隶属于信息管理系统，信息管理系统的发展对积分应用的深入有直接影响。随着计算机技术和网络信息技术的飞速发展，构建系统所必须的硬件设施和软件水平都取得了长足的进步。越来越多的计算机具备了超大信息处理能力和高性能表现能力，能够支撑企业海量业务的需求。操作系统的进一步完善优化、数据库理论以及在此基础上搭建的数据库管理系统的逐步发展、网络应用技术的更新换代和计算机程序语言的日趋丰富，使得系统的软件选择多种多样，因此带来的系统整体性能也趋于最优。信息管理系统借助信息技术的力量，在各行各业衍生出丰富多样的应用，融入到企业生产的各个环节之中，创造出了巨大的生产力。
从上世纪八十年代起，各行各业开始出现以巩固和提升客户忠诚度为目的的积分项目，“积分促销”的概念开始兴起。英国的 Nectar 积分计划是较早取得成功的积分项目之一。该积分服务提供商本身不销售任何实体商品，恰恰提供的就是积分的虚拟服务。该公司发行积分卡，通过同其他签约商家合作，用户只需要通过积分卡在商家进行消费便可以获得一定的积分奖励，获得的积分可以用于兑换商品或者享受一定的商品折扣等优惠。在英国，超过 1300 万的英国民众成为了 Nectar 的客户，超过半数以上的英国家庭也在使用该卡。截止到 2003 年底，已有超过 70%的Nectar 卡片持有者通过该服务兑换了奖品，涉及到的价值超过 3.4 亿英镑。另外一家经营积分服务小有名气的公司是美国优诺公司，凡是参加该公司积分项目的用户都拥有一个专属账户，当该用户在签约商家进行消费时，签约商家会根据一定的规则计算出金额数，将这笔资金作为激励奖金存入到用户的专属账户中 。公司通过这种方式来吸引用户使用该积分服务，从而为自己带来收益。
而在国内的企业管理中，通过制定积分奖励系统的应用还很少见，尚处于起步阶段。创建方便、有效的企业活动积分管理系统是我们目前急需解决的问题。
本课题主要工作 本文正是基于微信小程序开发平台，针对企业管理中的积分奖励措施，本文设计出一个包含前端和后台相结合的企业员工积分微信小程序。其中，前端包括：成员登录、活动列表、完成活动、积分兑换，后台包括：管理登录、发布活动、查看完成情况，积分统计排行、成活活跃排行、历史积分记录，兑换记录等功能的微信小程序，以此实现企业员工积分管理智能化、规范化。
一开始，本文就对系统内谈到的基本知识，从整体上进行了描述，并在此基础上进行了系统分析。为了能够使本系统较好、较为完善的被设计实现出来，就必须先进行分析调查。基于之前相关的基础，在功能上，对新系统进行了细致的分析。然后通过详细的分析，进行系统设计，其次，系统在实施的可行性上，我选择了微信小程序开发平台来进行开发设计，在数据存储上，采用Mysql数据库来进行设计。由于微信小程序和Mysql都已经非常成熟，因此无论在各个方面，都非常可靠安全实用。最后对系统进行测试完善并发布。
系统页面展示 员工可以点击某个活动，进入活动详情，并且可以对该活动进行评论，如图5.2所示。
员工也可以直接在搜索栏中输入相关信息进行活动的搜索，也可以点击资讯信息，如图5-3所示。
员工点击商品兑换，进入商品列表，可以选择相应的商品进行提交，并且也可以对商品选择进行收藏，如图5-4所示。
后台管理模块包括，用户管理、活动管理、分类管理、兑换商品管理、兑换处理、资讯信息，管理可以选择相应的模块，进行编辑、修改、删除等相关操作，例如，对活动发布信息的操作，如图5-5所示。
如需要可扫取文章下方二维码联系得源码
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/faca1b14cff0d257ff9964d0a3e6514a/" rel="bookmark">
			刁钻面试问题？超全接口测试面试题总结&#43;答案，面试看这篇就够了
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录：导读 前言一、Python编程入门到精通二、接口自动化项目实战三、Web自动化项目实战四、App自动化项目实战五、一线大厂简历六、测试开发DevOps体系七、常用自动化测试工具八、JMeter性能测试九、总结（尾部小惊喜） 前言 面试题：没有接口文档，如果做接口测试？
没有接口文档，那还能咋办，瞎测呗！一个公司的开发流程里面，如果接口文档都没有，是无法展开接口测试的，你都不知道这个接口干什么的，也不知道具体每个字段代表什么意思，那还测啥呢？
当然，你肯定不能回答面试官不测(心理mmp，脸上笑嘻嘻)，接下来就是扯犊子时间
1、没有接口文档，那就需要先跟开发沟通，然后整理接口文档（本来是开发写的，没办法，为了唬住面试官，先说自己整理了）
2、没有接口文档，可以抓包看接口请求参数，然后不懂的跟开发沟通
本题主要靠情商，通俗来说就是忽悠能力，先唬住面试官了再说，进去了也是瞎测测，随时做好背锅的准备
面试题：你平常做接口测试的过程中发现过哪些bug?
这个问题其实回到起来很简单，只要做过接口测试的，总能发现几个BUG吧，把你平常发现的bug说2-3个就可以了。
面试官出这个题，主要是想知道你是不是真的做过接口测试，毕竟现在很多小伙伴简历都是写的假的（你要不写估计面试机会都没有，没办法，为了生存，能理解）
比如一个体现功能，提现输入框，在页面上输入负数，肯定是无法提交过去（前端页面会判断金额），如果我不走前端，直接用接口工具发请求，输入一个负数过去。
（假设服务端没做提现金额数据判断）
余额=当前余额（100）-提现金额（-100），那么提现-100，余额就变成200了，也就是越提现，余额越大了
可以用接口工具去直接请求接口，也可以fiddler抓包，抓到接口后修改金额为负数
所以，接口测试的必要性就体现出来了：
1、可以发现很多在页面上操作发现不了的bug
2、检查系统的异常处理能力
3、检查系统的安全性、稳定性
4、前端随便变，接口测好了，后端不用变
5、可以测试并发情况，一个账号，同时（大于2个请求）对最后一个商品下单，或不同账号，对最后一个商品下单
6、可以修改请求参数，突破前端页面输入限制（如金额）
面试题：平常你是怎么测试接口的？
通过性验证：
首先肯定要保证这个接口功能是好使的，也就是正常的通过性测试，按照接口文档上的参数，正常传入，是否可以返回正确的结果。
参数组合：
现在有一个操作商品的接口，有个字段type，传1的时候代表修改商品，商品id、商品名称、价格有一个是必传的，type传2的时候是删除商品，商品id是必传的，这样的，就要测参数组合了，type传1的时候，只传商品名称能不能修改成功，id、名称、价格都传的时候能不能修改成功。
接口安全：
绕过验证，比如说购买了一个商品，它的价格是300元，那我在提交订单时候，我把这个商品的价格改成3元，后端有没有做验证，更狠点，我把钱改成-3，是不是我的余额还要增加？
绕过身份授权，比如说修改商品信息接口，那必须得是卖家才能修改，那我传一个普通用户，能不能修改成功，我传一个其他的卖家能不能修改成功
参数是否加密，比如说我登陆的接口，用户名和密码是不是加密，如果不加密的话，别人拦截到你的请求，就能获取到你的信息了，加密规则是否容易破解。
密码安全规则，密码的复杂程度校验。
异常验证：
所谓异常验证，也就是我不按照你接口文档上的要求输入参数，来验证接口对异常情况的校验。比如说必填的参数不填，输入整数类型的，传入字符串类型，长度是10的，传11，总之就是你说怎么来，我就不怎么来，其实也就这三种，必传非必传、参数类型、入参长度。
性能测试
接口并发情况，如上面提到的：一个账号，同时（大于2个请求）对最后一个商品下单，或不同账号，对最后一个商品下单接口响应时间，响应时间太长了，肯定需要优化，一般都是毫秒级别
面试题：如何分析一个bug是前端还是后端的？
平常提bug的时候，前端开发和后端开发总是扯皮，不承认是对方的bug
这种情况很容易判断，先抓包看请求报文，对着接口文档，看请求报文有没问题，有问题就是前端发的数据不对
请求报文没问题，那就看返回报文，返回的数据不对，那就是后端开发的问题咯
面试题：在手工接口测试或者自动化接口测试的过程中，上下游接口有数据依赖如何处理？
1、手工测试中，用postman使用Tests中的set a global variable生成全局变量或者set an environment variable生成系统变量，后续直接引用这个变量值；用jmeter则使用后置处理器的正则表达式提取器、边界值提取器、json提取器提取，后续引用该变量值。
2、自动化测试中，通常会把接口响应的数据提取出来赋值给一个变量，后续直接调取该变量的值就可以使用。
用一个全局变量来处理依赖的数据，比如登录后返回token，其它接口都需要这个token，那就用全局变量来传token参数
面试题：当一个接口出现异常时候，你是如何分析异常的？
抓包，用fiddler工具抓包，或者浏览器上f12，app上的话，那就用fiddler设置代理，去看请求报文和返回报文了
查看后端日志，xhell连上服务器，查看日志
面试题：说说接口测试的流程和接口自动化流程，介绍一下request有哪些内容？
流程：获取接口文档，依据文档设计接口参数，获取响应，解析响应，校验结果，判断测试是否通过。
request 内容：
封装了get、post等；
以关键字参数的方式，封装了各类请求参数，params、data、headers、token、
cookie等；
封装了响应内容，status_code、json()、cookies、url等；
session会话对象，可以跨请求；
面试题：不可逆的操作，如何处理，比如删除一个订单这种接口如何测试？
此题考的是造数据的能力，接口的请求数据，很多都是需要依赖前面一个状态的
比如工作流这种，流向不同的人状态不一样，操作权限不一样，测试的时候，每种状态都要测到,就需要自己会造数据了。
平常手工测试造数据，直接在数据库改字段状态。那么自动化也是一样，造数据可以用python连数据库了，做增删改查的操作
测试用例前置操作，setUp做数据准备
后置操作，tearDown做数据清理
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/faca1b14cff0d257ff9964d0a3e6514a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/daef1f9788390d3e3c1a8b9890069037/" rel="bookmark">
			【IMX6ULL驱动开发学习】09.Linux驱动之GPIO中断（附SR501人体红外感应驱动代码）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Linux驱动的GPIO中断编程主要有以下几个步骤：
1、 通过GPIO号获取软件中断号 (中断编程不需要设置GPIO输入输出，当然申请GPIO，设置输入也没问题)
int gpio_to_irq(unsigned int gpio) 参数含义gpioGPIO引脚编号 2、 注册中断处理函数，设置中断触发方式（上升沿、下降沿等）
int request_irq(unsigned int irq, irq_handler_t handler, unsigned long flags, const char *name, void *dev) 参数含义irq软件中断号(通过gpio_to_irq获取)handler中断处理函数flags中断触发方式name自定义中断名字dev自定义参数 3、 驱动出口函数中 注销中断
void free_irq(unsigned int irq, void *dev_id) 参数含义irq软件中断号(通过gpio_to_irq获取)dev_id注册中断函数时传入的 dev 参数 4、 定义中断处理函数
形如
static irqreturn_t gpio_irq_handle(int irq, void *dev_id) { printk("this is irq_handle, irq = %d\n", irq); return IRQ_HANDLED; } 主要注意参数和返回值
参数：int irq, void *dev_id
返回值 ： irqreturn_t 类型（见下图），一般选择 IRQ_HANDLED，因为既然已经进入中断函数了，那就是已经执行了
5、 GPIO中断应用 - SR501人体红外感应
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/daef1f9788390d3e3c1a8b9890069037/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/021f56b66595c67377c562ec4b9ff2a6/" rel="bookmark">
			vue 组件上使用v-model以实现双向绑定
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		默认情况 v-model 实际上就是 $emit('input') 以及 props:value 的组合语法糖，只要组件中满足这两个条件，就可以在组件中使用 v-model
父组件调用子组件，通过v-model绑定属性值，在子组件中默认接收props为modelValue ，子组件中触发更新需要通过emit 触发update:modelValue自定义事件。
// 父组件调用子组件 &lt;SubInput v-model="formState.title0" /&gt; // 子组件 &lt;input :value="modelValue" @input="($event: any) =&gt; $emit('update:modelValue', $event.target.value)" /&gt; props: { modelValue: { type: String, require: true } }, emit: ['update:modelValue'], 传参 默认情况下，v-model 在组件上都是使用 modelValue 作为 prop，并以 update:modelValue 作为对应的事件。我们可以通过给 v-model 指定一个参数来更改这些名字：
在这个例子中，子组件应声明一个 title prop，并通过触发 update:title 事件更新父组件值：
// 父组件调用子组件 &lt;SubInput v-model:title1="formState.title1" /&gt; // 子组件 &lt;input :value="title1" @input="($event: any) =&gt; $emit('update:title1', $event.target.value)" /&gt; props: { title1: { type: String, require: true }, }, emit: [ 'update:title1'], v-model 修饰符 组件的 v-model 上所添加的修饰符，可以通过 modelModifiers prop 在组件内访问到。在下面的组件中，我们声明了 modelModifiers 这个 prop，它的默认值是一个空对象。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/021f56b66595c67377c562ec4b9ff2a6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea91f59e7a82883ccbd45888c453c080/" rel="bookmark">
			多个geojson经过坐标系转换后合并为一个shp数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用geopandas和pyproj将多个geojson数据经过坐标转换后合并成一个shp数据： import geopandas as gpd from pyproj import CRS import pandas as pd BASE_DIR = 'D:/demo' # 输入的WGS84 GeoJSON文件列表 geojson_files = [f"{BASE_DIR}/file1.geojson", f"{BASE_DIR}/file2.geojson", f"{BASE_DIR}/file3.geojson"] # 目标坐标系的EPSG代码，使用一个西安80高斯投影举例 target_epsg = 2363 # 创建一个空的GeoDataFrame merged_gdf = gpd.GeoDataFrame() # 定义WGS84和目标坐标系之间的坐标转换 wgs84_crs = CRS.from_epsg(4326) target_crs = CRS.from_epsg(target_epsg) # 逐个读取、转换和合并GeoJSON文件 for geojson_file in geojson_files: gdf = gpd.read_file(geojson_file, crs=wgs84_crs) # 为每个geodataframe新添加字符类型的字段name，并将文件名赋值给字段name gdf['name'] = geojson_file[-13:-8] gdf = gdf.to_crs(target_crs) merged_gdf = pd.concat([merged_gdf, gdf], ignore_index=True) # 过滤掉面积小于100的要素 gdf_filtered = merged_gdf[merged_gdf["
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea91f59e7a82883ccbd45888c453c080/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c164da002441f8aaf00ddd611b0f0478/" rel="bookmark">
			一、安装与配置：Pycharm Anaconda TensorFlow Keras
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、安装与配置1.Anaconda2.配置Anaconda清华镜像3.Pycharm4.Pycharm配置conda环境（该步骤可省略，直接见7）5.安装TensorFlow 1.14.06.安装keras 2.2.57.Pycharm配置tensorflow环境8.安装numpy、pandas、matplotlib9. 配置jupyter notebookJupyter Notebook 打开指定文件夹将Chrome设置为Jupyter_notebook的默认浏览器Jupyter Notebook中切换conda虚拟环境jupyter打开conda报错 EnviromentLocationNotFoundjupyter 配置环境的 内核无法连接 tf-keras-python对应关系☆python3.7 tf2.2.0 keras2.3.1安装★python3.8 tf2.4.0-gpu安装cudacuDNN环境变量配置测试安装结果报错：各种dll文件找不到 tf2.4-gpu环境运行 其他包安装cv2scipyskimagetqdm(进度条可视化)pyreadline（代码自动补全） 二、问题：（1）关于anaconda prompt无法activate 环境（2）Pycharm配置conda环境报错（3）pip损坏 重新安装（4）pip损坏 重新安装（5）conda一直在 'Solving environment: \' 三、补充说明1、pip和conda区别2、conda常用命令☆3、用conda安装TensorFlow4、用pip装包时的注意事项 待办1.使用.yml文件配置conda环境2. pip安装本地包 一、安装与配置 对照网上的教程先后安装了
1.Anaconda https://www.anaconda.com/distribution/#download-section 可能需要科学上网
若进不去网站，尝试百度云（2020.07版本↓） 链接: https://pan.baidu.com/s/1t2857BzMXGSyVwvpEW5d3A 提取码: sj5s 或者清华镜像
https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/
以百度云安装包为例：
先解压，运行64位版本：
Next→I Agree→Next →（改文件路径 注意要空文件夹）→Next→
（记得勾选 √ 第一项：将Anaconda 添加到环境变量中。见下图）→ Install
→（等待一段时间）→Next→Next→Finish
安装完成后可以将常用的 Anaconda Navigator、Jupyter Notebook、Anaconda Powershell Prompt（这个比Anaconda Prompt多一些功能？）放到开始屏幕，方便使用
测试anaconda是否安装完成：
win+R→cmd→conda
若出现以下信息则安装成功
2.配置Anaconda清华镜像 用Anaconda Prompt运行 可能要以管理员身份运行
（暂时添加官方库的镜像即可，后面若不可用（下载还是慢），再尝试换其他源）
20220710： 直接全给他装上，tmd!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c164da002441f8aaf00ddd611b0f0478/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/11647b67c4b07b8503bc612c5acbb8e6/" rel="bookmark">
			骁龙神经处理引擎SDK参考指南（25）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		骁龙神经处理引擎SDK参考指南（25） 6.5.6 量化 DLC 的 UDO DSP 教程 6.5.6 量化 DLC 的 UDO DSP 教程 概述
本教程介绍了为 DSP 运行时创建 UDO 包并使用该包执行 Inception-V3 模型所需的步骤。本教程中选择了 Softmax 操作来演示使用 SNPE 实现 UDO。本教程还介绍了 DSP V68 的离线缓存生成步骤。
SNPE SDK 为这个例子提供资源
$SNPE_ROOT/示例/NativeCpp/UdoExample/Softmax 有关 UDO 的一般信息可在UDO 概述中找到。
有关在不使用 UDO 的情况下运行 Inception-V3 网络的信息，请参阅Inception-V3 教程。
本教程将生成为 CPU、GPU 和 DSP 运行时运行 Inception-V3 网络所需的工件。此处概述了单独为 DSP 运行时编译和执行 Inception-V3 网络所需的步骤。有关为 CPU 和 GPU 运行时运行 Inception-V3 网络的信息，请访问Inception-V3 UDO 教程。
先决条件
以下教程假定已遵循一般SNPE 设置以支持 SDK 环境、TensorFlow 环境和所需的平台依赖项。此外，我们需要一个提取的 QNN-SDK（不需要 QNN-SDK 设置）来生成框架代码和构建库。有关 QNN-SDK 的详细信息，请参阅页面上的 QNN 文档 Q N N S D K R O O T / d o c s / i n d e x .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/11647b67c4b07b8503bc612c5acbb8e6/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d699f3f997d57889760915aa5ea454ad/" rel="bookmark">
			从VALSE 2023看近期人工智能的研究热点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		VALSE发起于2011年，是Vision And Learning SEminar的简写，取法语“华尔兹舞”之意，中文名称为视觉与学习青年学者研讨会。VALSE为计算机视觉、图像处理、模式识别与机器学习研究领域的华人青年学者提供了一个自由、平等、低成本的深度学术交流舞台。VALSE极大地促进了国内青年学者的思想交流和学术合作，从而使更多的青年学者在相关领域做出了重量级的学术贡献，提升了中国学者在国际学术舞台上的影响力。VALSE每年举办一次，在全国各地轮流举行。VALSE 2023于6月10日到12日在无锡举行。
本次大会包含了3个大会主旨报告、4个大会特邀报告、12个APR报告、4场Tutorial、20场Workshop、200+篇顶会顶刊Poster，由一百余位知名青年学者共同呈现了一场人工智能中的视觉与学习等领域的盛会。
本次大会究竟体现了近期人工智能的哪些研究热点？以下是个人的一些观点，可供参考。
1. 大模型
大模型无疑是人工智能近期的研究热点。特别是以ChatGPT为代表的大语言模型，开启了通用人工智能的新时代。很多行业和领域都会因此发生变革。以教育领域为例，一些以记忆、浅层理解为主的知识将会显得不再重要，这些知识可以非常方便地使用ChatGPT获得。这好比早期在做计算的时候人们使用算盘，后来有了计算器，那么算盘就不再重要了。因此，有了以ChatGPT为代表的大模型后，现有的教育模式和学习方式必然会发生改变，大模型技术会融入到教育领域，显著地改变教育的模式和学习的方式，提高学习的效率。大模型会加快自然科学领域的研究进展，改变现有的做科学研究的模式。在数学领域，大模型可以用于求解偏微分方程，可以进行复杂优化问题的求解等，从而解决数学领域以前无法解决的问题；在物理领域，大模型可以用于量子计算和模拟等；在生物领域，大模型可以用来预测蛋白质的结构等。总而言之，大模型不管对于研究人员还是普通大众来说，都是必然会用到的技术。
大模型技术未来的研究方向有哪些？现有的大模型是基于自然语言处理的，那么会不会出现基于图像和视频处理的大模型，会不会出现基于语音分析的大模型？这就涉及到多模态的大模型。也就是说，可以使用不同模态的数据去训练大模型，从而让大模型能够处理不同类型的任务，让其具有更加丰富的功能。此外，大模型与小模型的协同与合作，也可能是未来的研究热点。类似于去搜索广播电台，先粗调然后再微调，在完成特定的任务时，可以使用大模型先得到初步的结果，然后再使用专门训练的小模型对得到的结果进行精细化的调整，从而得到更优的结果。
2. 多模态
本次VALSE会议上有多个关于多模态的workshop，这也显示了多模态学习的研究热度。多模态学习是一种机器学习方法，它使用多种不同模态的数据来训练模型，从而提高模型的性能。 不同模态的数据包括文本、图像、音频、视频等。为了让模型具有更加丰富的功能，能够完成不同的任务，多模态学习将会显得非常重要。例如，可以使用文本、图像、语音等更加丰富的数据去训练大模型，从而让大模型具有更加丰富的功能。
3. 具身智能
具身智能强调智能的物理实现基础，认为智能存在于身体与环境的相互作用之中，而不仅仅局限于大脑或心灵。具身智能是本次VALSE上的热点之一，也是人工智能一个比较新的研究方向。
4. 面向开放域的视觉
近些年，面向开放域的视觉受到了研究者的高度关注。面向开放域的物体识别的目的是在标签空间和数据分布存在较大域差异的情况下，为每个目标样本分配一个特定的标识。大多数现有方法都依赖于关于源域和目标域之间标签集关系的大量先验信息，这对其在实际应用中的应用是一个很大的限制。因此，研究面向开放域的物体识别非常重要。此外，面向开放域的目标检测也是研究的热点之一。
5. 扩散模型
扩散模型是一类生成模型，具有其强大的生成能力，是生成模型中的研究热点之一。扩散模型分为前向阶段和逆向阶段，在前向阶段中逐步向数据中添加噪声，直至数据变成完全的高斯噪声，然后在逆向阶段学习从高斯噪声中还原为原始数据。扩散模型已经被应用于计算机视觉、语音生成、生物信息学和自然语言处理等领域。可以预见，扩散模型将会在其它更为广泛的领域获得应用。
6. 持续学习
持续学习，也称为增量学习，它建立在不断学习外部世界的理念之上，以实现更复杂的技能和知识的自主、渐进式发展。人类学习知识就是一个不断学习的过程，与之类似，机器要获得足够的智能也需要持续学习。当面对的任务发生改变或者数据的特性发生改变的时候，使用已经训练好的模型可能无法获得满意的效果，这就需要机器继续进行学习。对于实现大模型性能的持续改进，持续学习将是一种重要的方法。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/d4fac5f2a7e3f792349aad897787f6cb/" rel="bookmark">
			使用python的GDAL库将坐标系的wkt转epsg
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Python中使用GDAL库通过WKT格式的坐标系数据获取坐标系的EPSG代码： from osgeo import osr def get_epsg_from_wkt(wkt): spatial_ref = osr.SpatialReference() spatial_ref.ImportFromWkt(wkt) epsg = spatial_ref.GetAuthorityCode(None) return int(epsg) # WKT格式的坐标系数据 wkt_data = 'PROJCS["WGS 84 / UTM zone 31N",GEOGCS["WGS 84",DATUM["WGS_1984",SPHEROID["WGS 84",6378137,298.257223563,AUTHORITY["EPSG","7030"]],AUTHORITY["EPSG","6326"]],PRIMEM["Greenwich",0,AUTHORITY["EPSG","8901"]],UNIT["degree",0.0174532925199433,AUTHORITY["EPSG","9122"]],AUTHORITY["EPSG","4326"]],UNIT["metre",1,AUTHORITY["EPSG","9001"]],PROJECTION["Transverse_Mercator"],PARAMETER["latitude_of_origin",0],PARAMETER["central_meridian",3],PARAMETER["scale_factor",0.9996],PARAMETER["false_easting",500000],PARAMETER["false_northing",0],AUTHORITY["EPSG","32631"],AXIS["Easting",EAST],AXIS["Northing",NORTH]]' # 获取EPSG代码 epsg_code = get_epsg_from_wkt(wkt_data) print(epsg_code) gdal版本：3.2.1
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/124/">«</a>
	<span class="pagination__item pagination__item--current">125/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/126/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>