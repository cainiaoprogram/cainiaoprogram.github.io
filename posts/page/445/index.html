<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2585799805865d9474b9b8d4197d9009/" rel="bookmark">
			vue中 Error in mounted hook: &#34;TypeError: __WEBPACK_IMPORTED_MODULE_0__assets_swiper_js__.default is n...
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		个人小站点：https://sundjly.github.io/
在vue的项目中出现了以下错误：
Error in mounted hook: "TypeError: __WEBPACK_IMPORTED_MODULE_0__assets_swiper_js__.default is not a constructor"
TypeError: __WEBPACK_IMPORTED_MODULE_0__assets_swiper_js__.default is not a constructor
根据检查发现是引入swiper.js导致的问题，导致swiper解析错误（放在了文件src中）
解决方法，是把静态的文件放在static的文件夹下面，即
import Swiper from '../../static/swiper.js' import '../assets/css/swiper.css' console.log(Swiper) export default {} 这样就能打印到结果。分析，swiper.js是不需要经过webpack编译的，不能放在src路径下
转载于:https://www.cnblogs.com/sundjly/p/8046966.html
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a769c476877ac6855188e5269db19daa/" rel="bookmark">
			Centos下“无法打开并写入文件”问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		摘要 当前是root用户，去编辑/etc/ssh/sshd_config 却提示没有权限修改。报错如"/etc/ssh/sshd_config" E212: 无法打开并写入文件。
问题思考 既然提示没有权限，又是root用户，看肯定是给该文件设置了特殊的权限。检查特殊权限设置： + getfacl + lsattr
getfacl 结果正常
root@pts/1 $ getfacl /etc/ssh/sshd_config getfacl: Removing leading '/' from absolute path names # file: etc/ssh/sshd_config # owner: root # group: root user::rw- group::--- other::--- lsattr提示错误：-bash: lsattr: command not found 没有该命令，奇怪。当前系统是CentOS release 6.5 (Final)，那就尝试安装。
查找得知lsattr和chattr属于安装包e2fsprogs，安装之。
root@pts/1 $ yum install e2fsprogs 设置安装进程 解决依赖关系 --&gt; 执行事务检查 ---&gt; Package e2fsprogs.x86_64 0:1.41.12-18.el6_5.1 will be 升级 ---&gt; Package e2fsprogs.x86_64 0:1.41.12-23.el6 will be an update --&gt; 处理依赖关系 libss = 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a769c476877ac6855188e5269db19daa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a92ad69e52d5acae29a454796c0ee796/" rel="bookmark">
			JavaWeb常用异常总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 JavaWeb常用异常总结 org.eclipse.jdt.internal.compiler.classfmt.ClassFormJavaWeb：出现此异常多半是Tomcat版本没有选择正确，换一个版本基本上能解决此问题。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcad20b0a9167dc0e604cf5a4f385146/" rel="bookmark">
			非极大值抑制(Non-Maximum Suppression)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章作者：Tyan 博客：noahsnail.com | CSDN | 简书
1. 什么是非极大值抑制 非极大值抑制，简称为NMS算法，英文为Non-Maximum Suppression。其思想是搜素局部最大值，抑制极大值。NMS算法在不同应用中的具体实现不太一样，但思想是一样的。非极大值抑制，在计算机视觉任务中得到了广泛的应用，例如边缘检测、人脸检测、目标检测（DPM，YOLO，SSD，Faster R-CNN）等。
2. 为什么要用非极大值抑制 以目标检测为例：目标检测的过程中在同一目标的位置上会产生大量的候选框，这些候选框相互之间可能会有重叠，此时我们需要利用非极大值抑制找到最佳的目标边界框，消除冗余的边界框。Demo如下图：
左图是人脸检测的候选框结果，每个边界框有一个置信度得分(confidence score)，如果不使用非极大值抑制，就会有多个候选框出现。右图是使用非极大值抑制之后的结果，符合我们人脸检测的预期结果。
3. 如何使用非极大值抑制 前提：目标边界框列表及其对应的置信度得分列表，设定阈值，阈值用来删除重叠较大的边界框。 IoU：intersection-over-union，即两个边界框的交集部分除以它们的并集。
非极大值抑制的流程如下：
根据置信度得分进行排序
选择置信度最高的比边界框添加到最终输出列表中，将其从边界框列表中删除
计算所有边界框的面积
计算置信度最高的边界框与其它候选框的IoU。
删除IoU大于阈值的边界框
重复上述过程，直至边界框列表为空。
Python代码如下：
#!/usr/bin/env python # _*_ coding: utf-8 _*_ import cv2 import numpy as np """ Non-max Suppression Algorithm @param list Object candidate bounding boxes @param list Confidence score of bounding boxes @param float IoU threshold @return Rest boxes after nms operation """ def nms(bounding_boxes, confidence_score, threshold): # If no bounding boxes, return empty list if len(bounding_boxes) == 0: return [], [] # Bounding boxes boxes = np.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dcad20b0a9167dc0e604cf5a4f385146/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/31a680713b48e153bfbb7edc4fc5fe31/" rel="bookmark">
			PostgreSQL 日志文件位置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		2019独角兽企业重金招聘Python工程师标准&gt;&gt;&gt; 参考http://906179271.iteye.com/blog/2270652
http://blog.csdn.net/shanzhizi/article/details/47616645
查看postgresql.conf文件的配置，看日志文件在哪 logging_collector = on log_directory = 'pg_log' log_filename = 'postgresql-%a.log' log_truncate_on_rotation = o 日志的分类
pg_log（数据库运行日志） 内容可读 默认关闭的，需要设置参数启动pg_xlog（WAL 日志，即重做日志） 内容一般不具有可读性 强制开启pg_clog（事务提交日志，记录的是事务的元数据） 内容一般不具有可读性 强制开启 各个日志的作用 （1）pg_log 这个日志一般是记录服务器与DB的状态，比如各种Error信息，定位慢查询SQL，数据库的启动关闭信息，发生checkpoint过于频繁等的告警信息，诸如此类。该日志有.csv格式和.log。建议使用.csv格式，因为它一般会按大小和时间自动切割，毕竟查看一个巨大的日志文件比查看不同时间段的多个日志要难得多。pg_log是可以被清理删除，压缩打包或者转移，同时并不影响DB的正常运行。当我们有遇到DB无法启动或者更改参数没有生效时，第一个想到的就是查看这个日志。 （2）pg_xlog 这个日志是记录的Postgresql的WAL信息，也就是一些事务日志信息(transaction log)。默认单个大小是16M，源码安装的时候可以更改其大小（./configure --with-wal-segsize=target_value 参数，即可设置）这些日志会在定时回滚恢复(PITR)， 流复制(Replication Stream)以及归档时能被用到，这些日志是非常重要的，记录着数据库发生的各种事务信息，不得随意删除或者移动这类日志文件，不然你的数据库会有无法恢复的风险
转载于:https://my.oschina.net/haokevin/blog/1590525
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5209e5b1993d50aa3f76a14a9bc505a4/" rel="bookmark">
			Unity API——Application类的详解(二)：数据文件路径
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		上一节中将Application类中所有的静态属性和静态方法都一一列举，方便以后查阅。接下将详细介绍Application类的属性和方法。 上一节传送门：Unity API——Application类的详解(一)：列举属性和方法
数据文件路径：总共有四个属性，分别为：dataPath、persistentDataPath、streamingAssetsPath、 temporaryCachePath 基本语法：public static string dataPath { get ;} dataPaht是包含游戏数据文件夹的路径，权限为只读，返回的是一个相对路径，即对于不同的游戏平台返回的路径是不一样的。 Unity Editor: &lt;path tp project folder&gt;/Assets Mac player: &lt;path to player app bundle&gt;/Contents iOS player: &lt;path to player app bundle&gt;/&lt;AppName.app&gt;/Data Android:/data/app/xxx.xxx.xxx.apk
测试代码：
using UnityEngine; using System.Collections; /// &lt;summary&gt; /// 此类用于 dataPath测试 /// &lt;/summary&gt; public class DataPath : MonoBehaviour { private void printDataPath() { Debug.Log("dataPaht:" + Application.dataPath); } void Start () { printDataPath(); } } 由于设备和条件有限，我只在Unity Editor 和android两个环境下作了测试，测试结果如下：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5209e5b1993d50aa3f76a14a9bc505a4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8160bace57c895409451706ca9fa4b30/" rel="bookmark">
			Spring MVC 接收POST表单请求，获取参数总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前段时间遇到一个问题，在spring mvc 服务端接收post请求时，通过html 表单提交的时候，服务端能够接收到参数的值。但是使用httpclient4.3构造post请求，却无法接收到参数的值。
spring 代码：
@RequestMapping(value = "login.do", method = RequestMethod.POST) @ResponseBody public String login(String username, String password) throws Exception { return username + ":" + password; } 表单代码：
&lt;form action="http://localhost:8080/test/login.do" id="frm" method="post"&gt; name:&lt;input type="text" name="username" id="username"/&gt; &lt;/br&gt; psword:&lt;input type="text" name="password" id="password"/&gt; &lt;/br&gt; &lt;input id="submit" type="submit" /&gt; &lt;/form&gt; httpclient4.3发送post代码：
@Test public void testMultipartPost() throws IOException { HttpPost httpPost = new HttpPost("http://localhost:8080/test/login.do"); try { HttpClientBuilder httpClientBuilder = HttpClientBuilder.create(); CloseableHttpClient httpClient = httpClientBuilder.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8160bace57c895409451706ca9fa4b30/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4cab3fd182a3f4b694989f273eadba31/" rel="bookmark">
			Android开发学习之路--APT技术
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今年都快要过去了，也已经2个月没有写博客了，主要还是换了新工作，今年都好几家徘徊了，从最初的公司散伙，也快1年了，这么背的17年终于快要结束了。不过庆幸的是加入了目前的公司，一个暂时觉得可以锻炼自己的平台。从嵌入式到app到嵌入式android系统，这次又回到了app，希望这次可以深耕3-5年，能在移动互联网站稳脚跟。两个月的时间忙于熟悉了解公司业务，也少了自己学习的时间，机器学习还没继续，android也没有深入了解，是时候补一把了。 以前遇到Dagger2, ButterKnife, EventBus3等的都是直接用，也没有太关心内部的源码实现。当想看的时候，发现一堆的注解不是非常好理解，所以还是先打打基础学习下apt技术吧，虽然不是那么新鲜了。
1.前言 首先看下butterknife生成的代码，要是都自己来敲，那就没法去和女神约会潇洒了。作为有家室的，也得多留点时间陪媳妇。
@BindView(R.id.iv_left_menu) ImageView ivLeftMenu; @BindView(R.id.iv_add) ImageView ivAdd; @BindView(R.id.toolbar) Toolbar toolbar; @BindView(R.id.rv_content) RecyclerView rvRobots; @BindView(R.id.coordinator_layout) LinearLayout coordinatorLayout; 然后实际的生成的代码如下：
public class Main2Fragment_ViewBinding implements Unbinder { private Main2Fragment target; @UiThread public Main2Fragment_ViewBinding(Main2Fragment target, View source) { this.target = target; target.ivLeftMenu = Utils.findRequiredViewAsType(source, R.id.iv_left_menu, "field 'ivLeftMenu'", ImageView.class); target.ivAdd = Utils.findRequiredViewAsType(source, R.id.iv_add, "field 'ivAdd'", ImageView.class); target.toolbar = Utils.findRequiredViewAsType(source, R.id.toolbar, "field 'toolbar'", Toolbar.class); target.rvRobots = Utils.findRequiredViewAsType(source, R.id.rv_content, "field 'rvRobots'", RecyclerView.class); target.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4cab3fd182a3f4b694989f273eadba31/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8c9dd463d3892b21d0d202280f0f535f/" rel="bookmark">
			Android 7.0 Camera架构源码分析1 - CameraService启动
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本系列教程主要讲解Camera从APP层到HAL层的整个流程，第一篇先讲解CameraService的启动，后面会讲解open、preview、takepicture的流程。
Android 7.0之前CameraService是在mediaserver进程中注册的，看下Android 6.0的代码：
//path: frameworks\av\media\mediaserver\main_mediaserver.cpp int main() { sp&lt;ProcessState&gt; proc(ProcessState::self()); sp&lt;IServiceManager&gt; sm = defaultServiceManager(); ALOGI("ServiceManager: %p", sm.get()); AudioFlinger::instantiate(); MediaPlayerService::instantiate(); ResourceManagerService::instantiate(); //初始化相机服务 CameraService::instantiate(); AudioPolicyService::instantiate(); SoundTriggerHwService::instantiate(); RadioService::instantiate(); registerExtensions(); ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool(); } 接着看下Android 7.0中main_mediaserver.cpp的代码，发现没有了CameraService::instantiate(); 也就是说Android 7.0之后就不在main_mediaserver.cpp中注册了。
//没有CameraService::instantiate()，也少了几个别的服务，这里只关注CameraService int main(int argc __unused, char **argv __unused) { signal(SIGPIPE, SIG_IGN); sp&lt;ProcessState&gt; proc(ProcessState::self()); sp&lt;IServiceManager&gt; sm(defaultServiceManager()); ALOGI("ServiceManager: %p", sm.get()); InitializeIcuOrDie(); MediaPlayerService::instantiate(); ResourceManagerService::instantiate(); registerExtensions(); ProcessState::self()-&gt;startThreadPool(); IPCThreadState::self()-&gt;joinThreadPool(); } 我们看下FrameWork层Camera的代码(frameworks\av\camera )，发现多了个cameraserver文件夹 ，看下里面的main_cameraserver.cpp，原来CameraServe::instantiaicte()在这里。
int main(int argc __unused, char** argv __unused) { signal(SIGPIPE, SIG_IGN); sp&lt;ProcessState&gt; proc(ProcessState::self()); sp&lt;IServiceManager&gt; sm = defaultServiceManager(); ALOGI("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8c9dd463d3892b21d0d202280f0f535f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1e12530c983702d93a6023017efa7b07/" rel="bookmark">
			VR全景图片浏览实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章主要介绍关于VR全景图片浏览的实现，Github VR全景图片(喜欢的朋友点一下star吧)主要是基于OpenGL ES 2.0 / Swift3.0实现的代码，之后会放入OC版。(接下来会发布关于VR全景视频播放器文章，现在主要是在封装播放器)
实现思路:
创建一个球体模型获取图片的纹理数据，通过着色器渲染到球体上通过手势的变换，改变球体模型视图矩阵值VR模式,则通过拖陀螺仪获取用户的行为，调整视图矩阵。 一、文件介绍。
Sphere.h: 引入C语言头文件 #include &lt;stdio.h&gt;。Sphere.c: 生成球体坐标的C语言方法。Bridging-Header.h: 桥接文件。MMPhotoView.swift: 继承于GLKView，用来渲染球体的。 注: 桥接文件路径。 二、VR全景图片浏览实现
属性一览。 /// 传过来的VR全景图片路径 public var photoURL: String? { didSet { guard let filePath = photoURL else { return } /// 将图片转为纹理信息 photoToSwitchTexture(filePath) } } /// 相机广角角度 fileprivate var overture: CGFloat = 0 /// 索引数 fileprivate var numIndices: Int = 0 /// 顶点索引缓存指针 fileprivate var vertexIndicesBufferID: GLuint = 0 /// 顶点缓存指针 fileprivate var vertexBufferID: GLuint = 0 /// 纹理缓存指针 fileprivate var vertexTexCoordID: GLuint = 0 /// 着色器 fileprivate var effect: GLKBaseEffect?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1e12530c983702d93a6023017efa7b07/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cde2d2c286244c79dbd50f8090d838d/" rel="bookmark">
			QT错误：collect2:ld returned 1 exit status
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		出现collect2:ld returned 1 exit status错误的原因，大概分为以下三种情况：
1、编译成功的例子在后台执行，有时一闪而过，如果再次build ，则会提示上述错误。
解决方法：打开任务管理器，找到相应的exe进程，关闭即可； 或者直接关闭QtCreator。
2、没有编译成功的情况下，最常见情况是程序本身需要include的头文件被遗漏了
解决方法：细心查找基类所用的头文件，include之后即可。
3、.h文件中相关的槽函数在cpp文件中没有定义
解决方法：查找遗漏的槽函数，根据需要，具体的定义。(碰到过一回，很关键)
4、.h文件中声明了全局变量，.cpp文件的函数里面使用了该全局变量
解决方法：.cpp文件外面没有初始化全局变量，初始化即可
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71d43ac3869565f672763fb917bfd6e8/" rel="bookmark">
			跨域iframe高度自适应（兼容IE/FF/OP/Chrome）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		采用JavaScript来控制iframe元素的高度是iframe高度自适应的关键，同时由于JavaScript对不同域名下权限的控制，引发出同域、跨域两种情况。
由于客户端js使用浏览器的同源安全策略，跨域情况下，被嵌套页面如果想要获取和修改父页面的DOM属性会出现权限不足的情况，提示错误：Permission denied to access property 'document'。这是因为除了包含脚本的文档载入的主机外，同源策略禁止客户端脚本链接到其他任何主机或者访问其他任何主机的数据。这意味着访问一个web服务的javascript代码通常只有在它也驻留在Web服务本身所在的同一个服务器的时候才有用。
所以在跨域情况下，我们遇到的问题就是：父窗口无法获得被嵌套页面的高度,而且被嵌套页面也无法通过驻留在其服务器上的js修改父窗口Dom节点的属性。所以我们需要一个媒介，来获得被嵌套页面的高度同时又能修改主界面iframe节点的高度。
思路：现有主界面main在域a下，被嵌套页面B在域b下，被嵌套页面B又嵌套一个在域a下的中介页面A。 当用户打开浏览器访问mail.html的时候载入B，触发B的onload事件获取其自身高度，然后B载入A,并将高度值作为参数赋值给A的location对象。这样A就可以通过location.hash获得B的高度。（location是javascript里边管理地址栏的内置对象，比如location.href就管理页面的url，用location.href=url就可以直接将页面重定向url。而location.hash则可以用来获取或设置页面的标签值。比如http://domain/#admin的location.hash="#admin"。利用这个属性值可以做一些非常有意义的事情。）。由于A和main页面同域，所以可以修改main的dom节点属性，从而达到我们设置iframe标签高度的目的。
关键代码：
www.a.com 下面 2个页面：main.html 和 A.htmlwww.b.com 下面1个页面：B.html，要注意不要搞混了；iframe主页面：main.html
&lt;iframe id="iframeB" name="iframeB" src="www.b.com/B.html" width="100%" height="auto" scrolling="no" frameborder="0"&gt;&lt;/iframe&gt; iframe嵌套页面：B.html （下面的代码，建议放在页面最底部，&lt;/body&gt;前面）
&lt;iframe id="iframeA" name="iframeA" src="" width="0" height="0" style="display:none;" &gt;&lt;/iframe&gt; &lt;script type="text/javascript"&gt; function sethash(){ hashH = document.documentElement.scrollHeight; //获取自身高度 urlC = "www.a.com/A.html"; //设置iframeA的src document.getElementById("iframeA").src=urlC+"#"+hashH; //将高度作为参数传递 } window.οnlοad=sethash; &lt;/script&gt;
中介页面：A.html &lt;script&gt; function pseth() { var iObj = parent.parent.document.getElementById('iframeB');//A和main同域，所以可以访问节点 iObjH = parent.parent.frames["iframeB"].frames["iframeA"].location.hash;//访问自己的location对象获取hash值 iObj.style.height = iObjH.split("#")[1]+"px";//操作dom } pseth(); &lt;/script&gt;上述效果，亲测可用；加载的时候网速影响，会有半秒-1秒的卡顿，这时候宽度加载完成，高度大概150px左右，体验度不是很好，目前暂无解决办法！
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/71d43ac3869565f672763fb917bfd6e8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/eb66e0cc4fe5b2cb1d94d9decc0fb742/" rel="bookmark">
			MySQL安装或重新安装时出现server failed
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天在重新安装mysql服务时，出现了一个错误，
The action ‘Install’ for product ‘MySQL Server 5.7.19’ failed.
1: Action 14:02:10: INSTALL. 1: 1: MySQL Server 5.7 2: {EC09D203-422B-4C9F-B623-230EF57EE709} 1: Action 14:02:10: FindRelatedProducts. Searching for related applications 1: Action 14:02:10: AppSearch. Searching for installed applications 1: Action 14:02:10: LaunchConditions. Evaluating launch conditions 1: This application requires Visual Studio 2013 Redistributable. Please install the Redistributable then run this installer again. 1: 1: MySQL Server 5.7 2: {EC09D203-422B-4C9F-B623-230EF57EE709} 3: 3 1: The action 'Install' for product 'MySQL Server 5.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/eb66e0cc4fe5b2cb1d94d9decc0fb742/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c8357ad4ce7866c77449164ab463befb/" rel="bookmark">
			设置mysql允许远程连接
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION; 其中，root是用户名，123456是密码；根据自己的用户和密码进行。 mysql&gt;use mysql; mysql&gt;update user set host = '%' where user = 'root'; MySQL&gt;flush privileges; 关闭防火墙，或者增加把3306端口对外开放，防火墙设置-入站规则-新建规则，3306端口，允许连接 即可； 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b1016079c1b3d271f4423e381918264b/" rel="bookmark">
			线程中主线程与子线程之间的关系
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、最常见的情况，主线程中开启了一个子线程，开启之后，主线程与子线程互不影响各自的生命周期，即主线程结束，子线程还可以继续执行；子线程介素，主线程也能继续执行。 测试代码如下：
public class TestThread{
public static void main(String[] args) throws InterruptedException {
System.out.println("主线程启动。。。。");
Thread thread = new Thread(new ChildThread());
thread.start();
System.out.println("主线程结束。。。。");
}
}
class ChildThread implements Runnable{
@Override
public void run() {
try {
System.out.println("子线程启动。。。。");
Thread.sleep(5000);
System.out.println("子线程结束。。。。");
} catch (InterruptedException e) {
e.printStackTrace();
}
}
}
运行结果如下：
主线程启动。。。。
主线程结束。。。。
子线程启动。。。。
子线程结束。。。。
2、主线程开启了子线程，但是主线程结束，子线程也随之结束 代码如下：
public class TestThread{
public static void main(String[] args) throws InterruptedException {
System.out.println("主线程启动。。。。");
Thread thread = new Thread(new ChildThread());
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/b1016079c1b3d271f4423e381918264b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b3a1bf69dc6568d2909e213fc2340ae/" rel="bookmark">
			【水仙花数问题】水仙花数是指一个三位数，其各位数字立方和等于该数本身
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		分析：一个布尔类型的函数isNarcissus(int i)用于判断传入的参数是否是水仙花数，其中包含了求一个数的百位，十位，个位，最难理解的求十位，一个三位数取模100后得到一个两位数，比如256%100=56，此时再将这个两位数除以10得到商，余数被自动省略，即56/10=5，两次之后得到256的十位是5
代码如下：
public class Main {
public static boolean isNarcissus(int i){//判断一个数是否是水仙花书
int a = i/100;//百位
int b = (i%100)/10;//十位
int c = i%10;//个位
if(i==(a*a*a+b*b*b+c*c*c)){
return true;
}
return false;
}
public static void main(String[] args) {
// TODO Auto-generated method stub
//那就输出100到999的水仙花数
for(int i=100;i&lt;=999;i++){
if(isNarcissus(i)){
System.out.println(i);
}
}
}
}
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dc7f956895ffdc17627006f26454273e/" rel="bookmark">
			怎样在textarea中输入tab
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 怎样在textarea中输入tab 在网面上按tab键，会默认切换鼠标焦点，我们只要在这个默认事件发生之前来阻止就可以了。
本例使用了Vue和IView， 但是主要部分用js就可以
html
&lt;Input @on-keydown="textareaTab" name="content" v-model="textareValue" type="textarea" :rows="4" &gt;&lt;/Input&gt; js
textareaTab (e) { if (e.keyCode === 9) { if (!this.textareValue) this.textareValue= '' this.textareValue+= '\t' // 阻止默认切换元素的行为 if (e &amp;&amp; e.preventDefault) { e.preventDefault() } else { window.event.returnValue = false } } }, 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5d5dfca90be01001de186da57dd8cee4/" rel="bookmark">
			docker 启动mysql
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		docker 启动mysql docker下 mysql 开启方式 docker run -p 3306:3306 --name msmysql -v $PWD/conf/my.cnf:/etc/my.cnf -v $PWD/logs:/logs -v $PWD/data:/mysql_data -e MYSQL_ROOT_PASSWORD=123456 -d mysql -p 3306:3306：将容器的3306端口映射到主机的3306端口 -v $PWD/conf/my.cnf:/etc/mysql/my.cnf：将主机当前目录下的conf/my.cnf挂载到容器的/etc/mysql/my.cnf -v $PWD/logs:/logs：将主机当前目录下的logs目录挂载到容器的/logs -v $PWD/data:/mysql_data：将主机当前目录下的data目录挂载到容器的/mysql_data -e MYSQL_ROOT_PASSWORD=123456：初始化root用户的密码
root@bogon:/etc/apt/conf# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 65eac24edc5f mysql:5.7 "docker-entrypoint..." 5 minutes ago Up 5 minutes 0.0.0.0:3306-&gt;3306/tcp msmysql root@bogon:/etc/apt/conf# root@bogon:~# docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 65eac24edc5f mysql:5.7 "docker-entrypoint..." 12 minutes ago Up About a minute 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5d5dfca90be01001de186da57dd8cee4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5665ac83841ba446bf01084b31c87a68/" rel="bookmark">
			WPF中textbox强制失去焦点
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在WPF中，常常会在TextBox获得焦点以后，进行其他操作，例如绘图，在绘图过程中，TextBox始终没有失去焦点。为了强制让TextBox失去焦点，可以创建一个虚拟的可获得焦点的控件（用TextBox控件，并将textbox的Width设为0即可。需要注意的是，本来想用Label控件的，但在测试过程中Label是不起作用的）。
比如，创建的虚拟控件为&lt;TextBox Name="XuNiBox" Width="0"/&gt;,在Code中可以用XuNiBox.Focus()来强迫这个虚拟控件获得焦点，此时其它所有控件自然会失去焦点。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cedc4a1162d636ff62d66209d46669a3/" rel="bookmark">
			32个FPGA开源网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. OPENCORES.ORG 这里提供非常多，非常好的PLD了内核，8051内核就可以在里面找到。 进入后，选择project或者由http//www.opencores.org/browse.cgi/by_category进入。 对于想了解这个行业动态人可以看看它的投票调查。 http://www.opencores.org/polls.cgi/list OpenCores is a loose collection of people who are interested in developing hardware, with a similar ethos to the free software movement. Currently the emphasis is on digital modules called 'cores', since FPGAs have reduced the incremental cost of a core to approximately zero. Activity is centered around the opencores web site http://www.opencores.org - 中文 2. FPGAs are fun 提供了大量的关于FPGA应用的文章，项目实际例子。强烈推荐 http://www.fpga4fun.com/ - 外文 3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cedc4a1162d636ff62d66209d46669a3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aa7f8ae840f0c8ce7d8a6fc33eb435c2/" rel="bookmark">
			springboot修改代码无需重启（热部署）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 https://www.cnblogs.com/EasonJim/p/7609911.html 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bcd2dc876c585d5d664057a4a7faec8b/" rel="bookmark">
			浅谈Power&amp;quot;s&amp;quot;家族史--Power Pivot vs. Power Query vs. Power View vs. Power BI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阅读微软BI相关文章，出现最多的就是这四个以Power的开头工具，Power Pivot，Power Query，Power View以及Power BI。相同的姓氏暗示这四兄弟来自同一家族，不同的名称又表明四兄弟的分工各有不同。So，这几个Power兄弟到底是干什么的呢？
一句话简明介绍：Power Query用来加载元数据，Power Pivot负责对数据进行建模分析，Power View则是生成数据图表，三兄弟主要是给Excel这位老板打工；而Power BI是这三兄弟合资经营的新公司，脱离了Excel专注于做BI产业。
Power Pivot
Power Pivot应该是最早被人熟知的Power家族成员。最早是作为Excel 2010的一个Add-in被引入进来，在Excel 2013做了大幅度的功能提升和改进，在最新的Excel 2016中已经变成了Built-in工具。Power Pivot的工作原理是将数据加载到内存中进行建模，因此可以快速的对数据进行分析，整合和计算，缺点吗，当然是对内存的依赖程度比较高，可以分析的数据量于内存大小成正比。Power Pivot可以对多种数据源进行建模分析，当引入多张表时，可以在不同的表之间添加关联关系并且可以使用Data Analysis Expressions (DAX)语言对数据进行计算。同时Power Pivot生成的数据图表可以以Excel为载体发布到SharePoint端已实现数据共享。并且与Excel native的数据分析功能相比，Power Pivot的显著优势是在导入数据时可以指定具体导入哪部分数据（以column为单位做filter），这样能一定程度的减少冗余数据被加载到表单里面而影响数据分析的效率。
Power Query
Power Query的诞生晚于Power Pivot，最初问世于Excel 2013，后来由于需求庞大，微软又对应的开发了对Excel 2010版本的支持。Power Query专注于对数据连接的管理，可以理解为一种ETL (Extract, Transform, Load) 服务。Power Query支持将导入的不同数据源数据进行裁剪和合并生成一个新的表单（例如将SQL，Oracle和Facebook的数据进行整合），同时也支持对数据格式进行调整，去掉空数据，批量替换某些数据，以及拆分某一column或者合并多个column。如果有需要，还可以用Power Query对数据做简单的整理例如计算，排序和过滤。Power Query对数据的处理都在加载数据如Excel之前完成的，也就是说，通过Power Query中的设置，相当于创建了一个模具，只有符合这个模具大小要求的数据才会被加载到Excel之中。相比Power Pivot只能在load数据之前做filter处理，Power Query提供的功能操作就丰富了很多，可以很大程度上减少冗余数据的加载，从而显著提高数据分析的效率和能力。
Power View
跟它的名字一样，Power View是一个让人“看”的工具，提供了丰富的图形模块用已将数据分析的结果展现出来。Power View最早来源于SQL Server2012的Server Reporting Services，并被SharePoint 2010所应用。之后被引入到Excel 2013，与Power Pivot带的Povit Table和Chart相比，Power View提供的可用数据图形模板更加丰富，更加便于操作，大大提升了Report的整体视觉感官。
Power BI
Power BI是基于Power Query，Power Pivot和Power View架构的一个独立软件，在包含了这三者的全部功能同时又增加了一些BI相关工具，允许在没有Excel，SQL Server或者SharePoint的环境上对数据进行可视化分析处理。同时为了的实现数据共享，Power BI除了提供On desktop版本外，还有基于微软Azure运行的SaaS版本以及为mobile用户准备的APP版本，可以实现在不同场合地点对数据的无缝浏览以及修改。同时，Power BI还提供了一套REST API允许第三方Application引用Power BI的相关图形表单。也就是说，第三方application可以专注于数据的收集和初步整理，之后利用Power BI对进行建模分析生成相应的表单图形，之后再将结构引入到自己application里面功任何用户使用。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bcd2dc876c585d5d664057a4a7faec8b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ae92c4371cfbbf3fe04658f111054568/" rel="bookmark">
			http post提交数组
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		方式一：@RequestParam方式 服务提供方用@RequestParam注解接收参数，参数类型为long数组：
@ApiOperation(value = "***", tags = "***", notes = "***", response = ***) @RequestMapping(value = "delivery", method = RequestMethod.POST) public Object convert( @RequestParam(value = "id", required = true) @ApiParam(value = "id数组", required = true) long[] id) { return userService.convert(id); } 服务调用方拼接多个id参数请求服务： http://**/delivery?id=1&amp;id=2 方式二：@RequestBody方式 服务提供方用@RequestBody注解接收参数，参数类型为long数组：
@ApiOperation(value = "***", tags = "***", notes = "***", response = ***) @RequestMapping(value = "/delivery", method = RequestMethod.POST) public Object delivery(@RequestBody long[] id) { return userService.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ae92c4371cfbbf3fe04658f111054568/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4a52ead4e4690213c035ad75013d76f3/" rel="bookmark">
			【斐波那契数列】兔子繁殖问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		古典问题：有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第3个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总数为多少？
算法分析：
假设给兔子的对数编号
第一个月：1 , sum=1;
第二个月：1 ,sum=1;
第三个月：1生2,sum=2;
第四个月：1生3，2，sum=3;
第五个月：1生4，2生5，3，sum=5
第六个月：1生6，2生7，4，5，3生8，sum=8;
第七个月：1生9，6，2生10，7，3生11，8，3生11，4生12，5生13，sum=13;
....
经过以上分析，可以发现，后一想sum等于前两项sum之和，开始编程：
（1）递归形式
public class Main {
public static int f(int n){
if(n==1 || n==2){
return 1;
}
else
return f(n-1)+f(n-2);
}
public static void main(String[] args) {
// TODO Auto-generated method stub
Scanner input = new Scanner(System.in);
int n = input.nextInt();
System.out.println(f(n));
}
}
（2）迭代形式
public class Main {
public static int f(int n)
{
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4a52ead4e4690213c035ad75013d76f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/40f03f5c5e99e68c407ff81e7ab79b18/" rel="bookmark">
			Git更新，出现Can&#39;t update: no tracked branch错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		今天使用webstrom时，本地在dev分支上，点击VCS更新按钮出现如下错误： 怎么解决呢？ 输入以下命令：
git branch --set-upstream master origin/master 来设置分支主机以跟踪远程分支主机
试着更新一下，结果如下： 接着输入以下命令·：
git branch --set-upstream-to origin/dev dev 再试着更新一下，OK了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/087e8b22e362e009359dc0cad69e21d2/" rel="bookmark">
			android异常收集错误信息并保存到crash文件夹下
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		保存日志文件到sdcard，目录：sdcard根目录下的crash文件夹下
首先要设置权限,没有权限出不来最终效果的
&lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt;收集异常的错误信息必须要创建两个类下面就是CrashHandler类 /** * Created by BAIPEI on 2017/12/5. */ import java.io.File; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.PrintWriter; import java.io.StringWriter; import java.io.Writer; import java.lang.Thread.UncaughtExceptionHandler; import java.lang.reflect.Field; import java.text.SimpleDateFormat; import java.util.Date; import java.util.HashMap; import java.util.Map; import android.content.Context; import android.content.pm.PackageInfo; import android.content.pm.PackageManager; import android.content.pm.PackageManager.NameNotFoundException; import android.os.Build; import android.os.Environment; import android.os.Looper; import android.util.Log; import android.widget.Toast; public class CrashHandler implements UncaughtExceptionHandler{ private static final String TAG = "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/087e8b22e362e009359dc0cad69e21d2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6a7a90c08d971d80ef8e2a3cade7a6a5/" rel="bookmark">
			Android启动页广告
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、前言 在Android项目开发中,经常会遇到需要实现启动页广告的需求。今天就来整理下启动页广告的实现,以便在今后的项目中拿来参考使用。 2、概述 实现思路: 1、在启动页初始化阶段,访问后端接口,获取广告数据,广告数据封装在JavaBean当中。 2、根据返回的数据中的广告类型,选择展示方式,比如静态图,Gif动图或者视频等,如果返回的广告数据为空,则在启动页资源初始化后直接跳转到主页面。 3、展示广告，并开始广告倒计时,点击跳过或者倒计时结束,则从启动页跳转到主页面。 总体实现思路如上,本文用到第三方框架Glide。 3、实现 创建工程,配置清单文件,记得在清单文件中加入以下权限: &lt;uses-permission android:name="android.permission.INTERNET"/&gt; &lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE"/&gt; &lt;uses-permission android:name="android.permission.ACCESS_WIFI_STATE"/&gt; &lt;uses-permission android:name="android.permission.CHANGE_WIFI_STATE"/&gt; &lt;uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE"/&gt; &lt;uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE"/&gt; 关键代码如下。
//倒计时Handler private Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { if (time &lt; 0) { mAdShowStatus = true; if (mHandler != null &amp;&amp; mHandler.hasMessages(0)) { mHandler.removeMessages(0); } enterToMain(); } else { time = time - 1; ad_time_tv.setText("跳过" + time); mHandler.sendEmptyMessageDelayed(0, 1000); } } }; //展示广告 private void showAd(AdverBean bean) { ad_time_tv.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6a7a90c08d971d80ef8e2a3cade7a6a5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/82a0030c59621475bc1aa259cb2abff7/" rel="bookmark">
			spring&#43;springmvc&#43;redis配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		主要逻辑代码在com.l.token包中 首先引入相关依赖，其中有一些没有用到的依赖
&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.l&lt;/groupId&gt; &lt;artifactId&gt;SpringProject&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;SpringProject Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.build.timestamp.format&gt;yyyyMMddHHmmss&lt;/maven.build.timestamp.format&gt; &lt;spring.version&gt;4.3.12.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/82a0030c59621475bc1aa259cb2abff7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/33f8ee65d5948bbbc171070d9e7625d9/" rel="bookmark">
			关于微信小程序webview的使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		小程序 微信小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。同时提供一系列工具帮助开发者快速接入并完成小程序开发。关于如何注册配置就不多言了，本文主要还是体验了下web-view的功能。
web-view详解 有了这个组件之后，小程序可以很好的嵌入一些页面，可以环境小程序size告急的问题，同样也使开发更加便捷，毕竟小程序开发者基本都对前端开发较为了解。
web-view能力 说再多还是需要去看官方文档，web-view文档,
兼容 首先就需要注意：兼容问题，版本库和对应版本比例
基础库 1.6.4 开始支持，低版本需做兼容处理， 个人类型与海外类型的小程序暂不支持使用。 目前而言，基本80%的用户会升级微信，所以其实不必担心版本问题，官方截止2017-12-01提供的数据也说明88%的用户支持web-view。
使用 web-view 组件是一个可以用来承载网页的容器，会自动铺满整个小程序页面；
属性：src 是String类型，是一个网站的url，默认值是none，webview 指向网页的链接。需登录小程序管理后台配置域名白名单。
&lt;!-- wxml --&gt; &lt;!-- 指向微信公众平台首页的web-view --&gt; &lt;web-view src="https://mp.weixin.qq.com/"&gt;&lt;/web-view&gt; 可以配合Page实例的onLoad方法来获取url的具体值，也就是一个微信小程序页面中只有一个web-view，但是这个web-view的内容可以根据上一个页面传递的参数来获取页面URL，后面会讲如何实践，
官方提供如下接口：
web-view和小程序的通信 1. 由小程序到`web-view`,其实本质上`WEB-VIEW`也是小程序的一个页面，所以小程序到`web-view`是正常的小程序间的通信，通过`wx.navigateTo`、`wx.redirectTo`，带上`url`参数,`query`参数就像正常`url`的参数一样跟着后面，然后在`web-view`的页面的`Page`实例里面通过`onLoad`的方法的参数来获取`url`的值，设置给`web-view`的`src`属性为改值即可。 2. 由`web-view`到小程序，由于在`web-view`的跳转通常是在`src`对应的网页中的操作来处理的，所以需要结合`jssdk`来处理，不需要`wx.config`配置，直接通过`script`标签来引入`https://res.wx.qq.com/open/js/jweixin-1.3.0.js`，就可以使用`wx.miniProgram.navigateTo`、`wx.miniProgram.navigateBack`、`wx.miniProgram.switchTab`、`wx.miniProgram.reLaunch`、`wx.miniProgram.redirectTo`接口，就像小程序之间的跳转一样，单是只能在当前小程序页面内跳转。
支持以下部分JSSDK接口图像、音频、摇一摇、地理位置等信息，具体可以查看web-view文档,不过这些需要通过wx.config来授权，就和服务号开发类似。用户分享时可获取当前&lt;web-view/&gt;的URL，即在onShareAppMessage回调中返回webViewUrl参数。 Page({ onShareAppMessage(options) { console.log(options.webViewUrl) } }) 在网页内可通过window.__wxjs_environment变量判断是否在小程序环境。 // web-view下的页面内 console.log(window.__wxjs_environment === 'miniprogram') // true
web-view实践 在目前实践了部分web-view的功能，
//index.js Page({ data: { url: 'https://test.com' }, onLoad: function(options){ options.url ? this.setData({url: options.url}) : wx.navigateBack({delta: 2}); } }); //index.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/33f8ee65d5948bbbc171070d9e7625d9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/79cae317b97a2d4ef65bd518ef83adab/" rel="bookmark">
			java 源文件中的中文符号替换成英文符号
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		网上找来的java代码，不知道怎么回事，有时候括号是中文的，或者有中文的逗号，中文的分号。有时候整段代码都是这样，要想在eclipse中一个个的修改很麻烦。
于是想到了，写一段代码来把错误的中文符号改成正确的英文符号。具体的做法是，一行一行的读入代码，一个字符一个字符的遍历每一行，如果发现中文的符号（比如：中文的左括号'（'），就把它替换成英文的左括号，然后放入StringBuffe对象中，其他类似，如果不是这些错误的，就把这个正确的字符放入StringBuffer对象用。扫描结束后，再把StringBuffer对象中修正后的所有字符，重新写入这个文件，覆盖掉原有的文件即可。
下面是中文替换代码：
import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.File; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; import java.util.Scanner; public class CheckChinese { static Scanner scanner=new Scanner(System.in); public static void main(String[] args) { //输入文件地址 System.out.print("输入文件地址："); String filePath=scanner.nextLine(); StringBuffer stringBuffer=checkFileByLines(filePath); System.out.println(stringBuffer.toString()); write(filePath,stringBuffer.toString()); } public static StringBuffer checkFileByLines(String fileName) { File file = new File(fileName); BufferedReader reader = null; try { // System.out.println("以行为单位读取文件内容，一次读一整行："); reader = new BufferedReader(new FileReader(file)); String tempString = null; int line = 1; // 一次读入一行，直到读入null为文件结束 StringBuffer stringBuffer=new StringBuffer(); while ((tempString = reader.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/79cae317b97a2d4ef65bd518ef83adab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e2212120bb13185de5469425d15bac5c/" rel="bookmark">
			《算法4》最短路径之Dijkstra与Bellman-Ford算法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基本数据结构 在本篇文章中将要记录，在加权有向图中的单源最短路径的两个主要算法，所以首先介绍有向边以及加权有向图这两种关键的数据结构，这里的两种数据结构和《算法4》最小生成树之Prim与Kruskal算法中的边以及加权无向图的数据结构很类似，大致看一下就行。 下面是有向边的数据结构：
public class DirectedEdge { private final int v; private final int w; private final double weight; public DirectedEdge(int v, int w, double weight){ this.v = v; this.w = w; this.weight = weight; } public double weight(){ return weight; } public int from (){ return v; } public int to(){ return w; } public String toString(){ return String.format("%d-&gt;%d %.2f", v,w,weight); } } 下面是加权有向图的数据结构：
public class EdgeWeightedDigraph { private final int V; private int E; private Bag&lt;DirectedEdge&gt;[] adj; public EdgeWeightedDigraph(int V){ this.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e2212120bb13185de5469425d15bac5c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/699db740fd28991b8df4c481cabff0e7/" rel="bookmark">
			Fragment简单介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、Fragment概念以及设计原理 Fragment是Android3.0后引入的一个新的API，他出现的初衷是为了适应大屏幕的平板电脑， 当然现在他仍然是平板APP UI设计的宠儿，而且我们普通手机开发也会加入这个Fragment，我们可以把他看成一个小型的Activity，又称Activity片段！想想，如果一个很大的界面，我们就一个布局，写起界面来会有多麻烦，而且如果组件多的话是管理起来也很麻烦！而使用Fragment我们可以把屏幕划分成几块，然后进行分组，进行一个模块化的管理！从而可以更加方便的在运行过程中动态地更新Activity的用户界面！另外Fragment并不能单独使用，他需要嵌套在Activity中使用，尽管他拥有自己的生命周期，但是还是会受到宿主Activity的生命周期的影响。比如，当Activity暂停时，其中的所有片段也会暂停；当Activity被销毁时，所有片段也会被销毁。 不过，当Activity 正在运行（处于已恢复生命周期状态）时，您可以独立操纵每个片段，如添加或移除它们。 当您执行此类片段事务时，您也可以将其添加到由Activity管理的返回栈，Activity中的每个返回栈条目都是一条已发生片段事务的记录。返回栈让用户可以通过按返回按钮撤消片段事务（后退）。
二、android.support.v4.app.Fragment和android.app.Fragment android.app.Fragment 兼容的最低版本是android:minSdkVersion=”11” 即3.0版。android.support.v4.app.Fragment 兼容的最低版本是android:minSdkVersion=”4” 即1.6版。 推荐用android.support.v4.app.Fragment。
请注意：一个应用中，千万不要混合使用给自己增加不必要的麻烦。最好一个应用里面都用v4包或者app包的Ｆｒａｇｍｅｎｔ。
三、Fragment生命周期函数 生命周期函数相关解释 onAttach() 关联到Activity的时候调用。如果，需要使用Activity的引用或者使用Activity作为其他操作的上下文，将在此回调方法中实现 onCreate() 系统创建Fragment的时候回调 onCreateView() 当第一次绘制Fragment的UI时系统调用这个方法，该方法将返回一个View，如果Fragment不提供UI也可以返回null。注意，如果继承自ListFragment，onCreateView()默认的实现会返回一个ListView，所以不用自己实现。这个函数的Bundle参数和onCretate()函数的Bundle蚕食是同一个onActivityCreated() 当Activity中的onCreate方法执行完后调用。可以在这个函数里面做和Activity UI交互的操作（因为Activity的onCreate()函数之后Activity的UI已经准备好了，可以UI交互）。这个函数的Bundle参数和onCretate()函数的Bundle蚕食是同一个 onStart() 启动Fragment的时候回调，这个时候Fragment可见 onResume() Fragment变为活动状态获取焦点的时候是回调，这个时候Fragment已经完全展示在前台，并且可以和用户交互 onPause() Fragemnt变成非活动状态失去焦点的时候调用，注意这个时候Fragment还是可见的，只是不能和用户交互了而已 onStop() Fragment变成不可见的时候调用。这个时候Fragment还是活着的，只是可能别加入到了Fragment的回退栈中 onDestroyView() Fragment中的布局被移除的时候调用 onDestroy() Fragment被销毁的时候调用 onDetach() Fragment和Activity解除关联的时候调用个 &gt; 除了上面列出的标准周期函数之外，还有几个函数也要特别注意：
onViewCreated(): 是不是和onCreateView()很像，onViewCreated()是在onCreateView()函数之后执行，我们通常在onViewCreated()函数里面findViewById。setUserVisibleHint()：当前页面是否可见(一般ViewPager+Fragemnt配合使用会用到，懒(延时)加载的时候这个函数有大用处)，因为ViewPager+Fragemnt的时候是会同时去加载前后多个Fragment的，这个时候就有些Fragment是可见的一些Fragment是不可见的。有一点要注意setUserVisibleHint()只在ViewPager+Fragment这情况下才会回调，其他静态加载和动态加载Fragment不会被调用到。。onHiddenChanged()：hide()、show()来回切换Fragment显示的时候，Fragment只会回调onHiddenChanged()。Fragment在add()的时候不会回调onHiddenChanged()函数，这点要切记。还有，在ViewPager+Fragment使用的时候Fragment也不会回调onHiddenChanged()函数的。 四、Fragment的使用 在Fragment使用之前，有三几个特别重要的类要先来了解下：FragmentManager、FragmentTransaction、FragmentManager.BackStackEntry。
FragmentManager：FragmentManager是负责管理Fragment并将它们的视图添加到Activity视图层级结构中的一个管理类。 FragmentManage可以做那些事情：
通过 findFragmentById()（对于在 Activity 布局中提供 UI 的片段）或 findFragmentByTag()（对于提供或不提供 UI 的片段）获取 Activity 中存在的片段。通过 popBackStack()（模拟用户发出的返回命令）将片段从返回栈中弹出。通过 addOnBackStackChangedListener() 注册一个侦听返回栈变化的侦听器。开启一个事务。 FragmentManager相关API函数解释如下：
/** * 开启一个事务，用于对Fragment操作的一系列处理 */ public abstract FragmentTransaction beginTransaction(); /** * 立即执行挂起的事物FragmentTransaction里面的，commit()、popBackStack()都不是立即执行的， * 它会被发送到主线程的任务队列当中去, 当主线程准备好执行它的时候执行.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/699db740fd28991b8df4c481cabff0e7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc990dfae1259b9eefc30908b1da7d49/" rel="bookmark">
			[微信小程序]聊天对话(文本,图片)的功能(完整代码附效果图)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		相关文章：
1.小程序聊天群，发送语音，文字，图片。
2.微信小程序集成腾讯IM，实现实时音视频通话，1V1聊天
3.云开发微信小程序聊天群
4.接入网易云信IM即时通讯的微信小程序聊天室
5.微信小程序聊天功能 WebSocket 实现发送文字，图片，语音以及WebSocket 常见问题解决方案
6.[微信小程序]聊天对话(文本,图片)的功能(完整代码附效果图)
如果有个性化的需要修改，可以联系我的微信。
微信小程序开发交流qq群 173683895
承接微信小程序开发。扫码加微信。 正文： 这是我实际项目线上的代码, 或许有些不足 || 和你的需求不符合, 上图:
&lt;!--pages/index/to_news/to_news.wxml--&gt; &lt;view class='tab'&gt; &lt;view class='lan'&gt;{{tabdata.title}}&lt;/view&gt; &lt;view class='tent'&gt; &lt;text&gt;{{tabdata.attribute_attribute}}&lt;/text&gt; &lt;text class='fl_r '&gt;{{tabdata.num}}&lt;/text&gt; &lt;/view&gt; &lt;view class='xiahuaxian1'&gt;&lt;/view&gt; &lt;view&gt; &lt;text class='fabu'&gt;发布时间: {{tabdata.time_agree}}&lt;/text&gt; &lt;/view&gt; &lt;/view&gt; &lt;view class='news'&gt; &lt;view class='xiahuaxian1 xiahuaxia'&gt;&lt;/view&gt; &lt;view class='new_top_txt'&gt;您正在与{{tabdata.nickname}}进行沟通&lt;/view&gt; &lt;view class="historycon"&gt; &lt;scroll-view scroll-y="true" scroll-top="{{scrollTop}}" class="history" wx:for="{{centendata}}" wx:key=''&gt; &lt;view&gt; &lt;text class='time'&gt;{{item.time}}&lt;/text&gt; &lt;/view&gt; &lt;block wx:if="{{item.is_show_right ==1}}"&gt; &lt;view class='my_right'&gt; &lt;view class='page_row'&gt; &lt;text wx:if='{{!item.is_img}}' class='new_txt'&gt;{{item.content}}&lt;/text&gt; &lt;image wx:if='{{item.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc990dfae1259b9eefc30908b1da7d49/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/44ebe3ec0c13827f83eed185a16489a8/" rel="bookmark">
			YOCTO编译环境的搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		以下内容为原创，欢迎转载，转载请说明来源：http://blog.csdn.net/masterbee/article/details/78687653
一、YOCTO编译环境的搭建
参照《freescale_imx6_yocto.pdf》文档P14-P16页构建yocto编译环境。同时可参考https://linux.cn/article-8268-1.html?amputm_medium=rss。
具体操作步骤如下(有些命令需要su权限，视具体情况而定)：
以下操作基于ubuntu 16.04 64bit系统，预留至少120G硬盘空间，推荐2G内存。
1、apt-get update
2、apt-get install wget git-core unzip make gcc g++ build-essentialsubversion sed autoconf automake texi2html texinfo coreutils diffstatpython-pysqlite2 docbook-utils libsdl1.2-dev libxml-parser-perl libgl1-mesa-devlibglu1-mesa-dev xsltproc desktop-file-utils chrpath groff libtool xterm gawkfop
3、copy poky 的 morty 稳定分支:
git clone -b mortygit://git.yoctoproject.org/poky.git
4、进入poky目录，然后运行下面的命令为 Yocto 开发环境设置（设置/导出）一些环境变量：
source oe-init-build-env
5、若正常，则如下图所示，会自动进入build目录：
6、修改build/conf/local.conf文件，如提供的local.conf文件所示。
7、编译：
bitbake core-image-minimal
一般要编译几个小时，电脑配置不高时，有可能要编译一天。
8、编译完成后，
runqemu qemux86-64为运行新的基于 Yocto 的 Linux 发行版的 qemu 打开一个新屏幕，则表示安装完成。
二、YOCTO BSP编译：
参考http://blog.csdn.net/wince_lover/article/details/51456745来编译yocto的BSP。具体步骤如下：
1、 下载repo：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/44ebe3ec0c13827f83eed185a16489a8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7fa4d15e17f73390613125a396328c0a/" rel="bookmark">
			oracle查看执行最慢与查询次数最多的sql语句
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		转自：http://www.jb51.net/article/104380.htm
前言
在ORACLE数据库应用调优中，一个SQL的执行次数/频率也是常常需要关注的，因为某个SQL执行太频繁，要么是由于应用设计有缺陷，需要在业务逻辑上做出优化处理，要么是业务特殊性所导致。如果执行频繁的SQL，往往容易遭遇一些并发性的问题。 那么如何查看ORACLE数据库某个SQL的执行频率/次数呢？ 下面来看看完整的示例代码。
一、查询执行最慢的sql
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 select * from ( select sa.SQL_TEXT, sa.SQL_FULLTEXT, sa.EXECUTIONS "执行次数" , round(sa.ELAPSED_TIME / 1000000, 2) "总执行时间" , round(sa.ELAPSED_TIME / 1000000 / sa.EXECUTIONS, 2) "平均执行时间" , sa.COMMAND_TYPE, sa.PARSING_USER_ID "用户ID" , u.username "用户名" , sa.HASH_VALUE from v$sqlarea sa left join all_users u on sa.PARSING_USER_ID = u.user_id where sa.EXECUTIONS &gt; 0 order by (sa.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7fa4d15e17f73390613125a396328c0a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c3f2d319030acfa81df4dd98adee7d2c/" rel="bookmark">
			libevent 多线程实现高并发
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		当你看到这篇文章时，想必你对libevent已经有了足够的了解，笔者在此就不多做描述了，直接进入正题。
1.起因
最近在做Redis中间件，目标实现集群管理、分布式数据处理、高性能。由于在某些情况下，单个节点的Redis性能可能无法满足需求，并且单个机器的内存大小是受限制的。如果采用中间件的方式管理多个Redis实例，不仅可以避免单点机器内存不够用的情况，也能使性能得到大幅提升。经过Redis中间件数据分片后，各个Redis实例可以同时处理读写请求，所以比单线程的Redis实例要快很多。在这里，中间件起到数据转发及管理的功能，特别是数据转发这一块，对中间件的处理能力要求比较高，在高并发情况下也能保证数据正常处理，不能影响业务使用。
2.实现
要实现高性能的服务端网络程序，基本上是异步处理网络IO+多线程。关于异步处理网络IO，网络上现成的库有很多，如果你喜欢动手，自己封装也行。不过我还是建议大家使用已经造好的、成熟稳定的轮子。在这里我比较推荐使用libevent，这个库相对来说比较成熟，使用起来也简单。
3.架构图
在这个架构模型中，我们开启了N个线程，每个线程中包含一个event_base对象，他们都是在自己的线程中工作。何时派发工作给这些工作线程，则由一个专门的AcceptThread线程来完成。这个线程负责接受客户端的连接，接受成功后会将该连接分配给工作线程。在这里我们采用均衡分配的方式，让每个线程处理的连接数是趋于相等的。
4.代码流程
首先要让libevent支持多线程，需要加上一段代码，这段代码只需要执行一次
#ifdef WIN32 evthread_use_windows_threads(); #else evthread_use_pthreads(); #endif 第一步：创建一个WorkThread线程池，每个线程对象中包含一个event_base对象，由于没有事件的话event_dispatch函数会退出，我们可以在里面注册一个永久的定时器事件，这样每个工作进程就不会退出。这个时候的状态是：等待外部给这个工作线程添加事件。
第二步：主线程监听端口，接受客户端连接。每到来一个连接就形成一个ConnectContext的结构，然后分配到一个工作线程去完成读写操作。这个过程不需要我们去加锁，libevent内部已经完成了这个操作。我们只需要在AcceptThread中派发任务给工作线程就可以了。
第三步：没了，按照这个架构，大部分代码就是写处理数据的代码了。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/41dd6b5f213eb058a0b3f1251fe3b573/" rel="bookmark">
			有道云笔记快捷键使用指南
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.切换界面模块隐藏(快捷键：ctrl+←)显示(快捷键：ctrl+→);　2.新建笔记(快捷键：ctrl+n);　3.激活窗口(热键：ctrl+shfit+y);　4.隐藏窗口的截屏方式(热键：ctrl+shfit+PrintScreen);　5.同步(快捷键：F5);　6.插入待办事项(快捷键ctrl+enter)　7.插入当前时间(快捷键shift+alt+d)　您可以点击菜单-设置-快捷键来查看或修改。
8.Alt + ← 隐藏侧边栏
9.Alt+→ 不隐藏侧边栏
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/15c692d69586ff829d4119691241823a/" rel="bookmark">
			kafka的go版本api使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		概述 go语言版本的kafakaAPI
准备 golangsarama 简单使用 生产和消费的过程都是通过一个配置开始的.
生产者 //设置配置 config := sarama.NewConfig() //等待服务器所有副本都保存成功后的响应 config.Producer.RequiredAcks = sarama.WaitForAll //随机的分区类型 config.Producer.Partitioner = sarama.NewRandomPartitioner //是否等待成功和失败后的响应,只有上面的RequireAcks设置不是NoReponse这里才有用. config.Producer.Return.Successes = true config.Producer.Return.Errors = true //设置使用的kafka版本,如果低于V0_10_0_0版本,消息中的timestrap没有作用.需要消费和生产同时配置 config.Version = sarama.V0_11_0_0 //使用配置,新建一个异步生产者 producer, e := sarama.NewAsyncProducer([]string{"IP:9092","IP:9092","IP:9092"}, config) if e != nil { panic(e) } defer producer.AsyncClose() //发送的消息,主题,key msg := &amp;sarama.ProducerMessage{ Topic: "logstash_test", Key: sarama.StringEncoder("test"), } var value string for { value = "this is a message" //设置发送的真正内容 fmt.Scanln(&amp;value) //将字符串转化为字节数组 msg.Value = sarama.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/15c692d69586ff829d4119691241823a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/47f22397390fa0e46e38f52eac680144/" rel="bookmark">
			LeetCode--Longest Consecutive Sequence（最长连续序列）Python
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		题目：
给定一个乱序的整数数组，找到最长连续元素序列的长度。比如给定数组[100, 4, 200, 1, 3, 2],其中最长的连续数组为[1,2,3,4],所以返回的最大长度为4。
解题思路：
因为考虑要降低复杂度，所以先将数据遍历一遍，存储到字典中。再从字典中不断拿出当前的整数相邻两个整数是否在字典中，若存在，则弹出这两个数，并将count+2，若当前整数相邻的两个数都不在字典中，则判断当前的count是否大于之前count的最大值，若大于，则更新最大值为当前的count。
代码（Python）：
class Solution(object): def longestConsecutive(self, nums): """ :type nums: List[int] :rtype: int """ Dict = {} for i in nums: Dict[i] = 1 List = Dict.keys() count_max = 0 while(len(Dict)): List = Dict.keys() count = 1 temp_left = List[0] temp_right = List[0] Dict.pop(temp_left) while(1): if temp_left-1 in Dict and temp_right+1 in Dict: count = count+2 temp_left = temp_left-1 temp_right = temp_right+1 Dict.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/47f22397390fa0e46e38f52eac680144/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2a30708986682cd87ed963b78ecdb6ab/" rel="bookmark">
			局部加权回归（Locally weighted linear regression）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		局部加权回归 通常情况下的线性拟合不能很好地预测所有的值，因为它容易导致欠拟合（under fitting），其多数情况下只能适用于线性的曲线而不能很好的拟合非线性的曲线，比如数据集是一个钟形的曲线。而多项式拟合能拟合所有数据，但是在预测新样本的时候又会变得很糟糕，因为它导致数据的过拟合（overfitting），不符合数据真实的模型。 今天来讲一种非参数学习方法，叫做局部加权回归（LWR）。为什么局部加权回归叫做非参数学习方法呢？ 首先参数学习方法是这样一种方法：在训练完成所有数据后得到一系列训练参数，然后根据训练参数来预测新样本的值，这时不再依赖之前的训练数据了，参数值是确定的。而非参数学习方法是这样一种算法：在预测新样本值时候每次都会重新训练数据得到新的参数值，也就是说每次预测新样本都会依赖训练数据集合，所以每次得到的参数值是不确定的。 接下来，介绍局部加权回归的原理。 exp()为以e为底的指数函数 其意义在于，所选取的x(i)越接近x，相应的w(i)越接近1；x(i)越远离x，w(i)越接近0。直观的说，就是离得近的点权值大，离得远的点权值小。 这个衰减函数比较具有普遍意义，虽然它的曲线是钟形的，但不是高斯分布（既正态分布）。 T被称作波长函数，它控制了权值随距离下降的速率。它越小，钟形越窄，w衰减的很快；它越大，衰减的就越慢。 *局部加权回归的问题： 由于每次进行预测都要根据训练集拟合曲线，若训练集太大，每次进行预测的用到的训练集就会变得很大，有方法可以让局部加权回归对于大型数据集更高效，详情参见Andrew Moore的关于KD-tree的工作。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74314811c0dafd788e602fe14dd07d2e/" rel="bookmark">
			android.view.InflateException: Binary XML file line #0: Error inflating class &amp;lt;unk
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		fragment里面用了constraintlayout
结果一个劲报错~~
我的天啊~~
11-29 17:30:12.053 19479-19479/com.youhui2000.dabaifanyi E/AndroidRuntime: FATAL EXCEPTION: main
Process: com.youhui2000.dabaifanyi, PID: 19479
android.view.InflateException: Binary XML file line #0: Error inflating class &lt;unknown&gt;
at android.view.LayoutInflater.createView(LayoutInflater.java:620)
at android.view.LayoutInflater.createViewFromTag(LayoutInflater.java:696)
at android.view.LayoutInflater.inflate(LayoutInflater.java:469)
at android.view.LayoutInflater.inflate(LayoutInflater.java:397)
at android.view.LayoutInflater.inflate(LayoutInflater.java:353)
at com.youhui2000.dabaifanyi.ui.base.BaseFragment.onCreateView(BaseFragment.java:31)
最后发现 原来是不该设置这个背景~
错误xml
&lt;android.support.constraint.ConstraintLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" xmlns:tools="http://schemas.android.com/tools" android:id="@+id/linearLayout" android:layout_width="match_parent" android:layout_height="match_parent" android:background="@drawable/ic_launcher_background"&gt; &lt;TextView android:id="@+id/textView" android:layout_width="261dp" android:layout_height="272dp" android:layout_marginBottom="8dp" android:layout_marginTop="8dp" android:text="main_fragment" app:layout_constraintBottom_toBottomOf="parent" app:layout_constraintEnd_toEndOf="parent" app:layout_constraintStart_toStartOf="parent" app:layout_constraintTop_toTopOf="parent" /&gt; &lt;/android.support.constraint.ConstraintLayout&gt; 将background取消 果断正常了·~
新手伤不起
总结：资源文件引用错误因为后面还是遇到了同样的问题~~ 结果是某个drawable放到drawable-v24里面去了，放回drawable就好了
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5076af66ad9ef477ef074fc59945f392/" rel="bookmark">
			js获取当前时间，并格式化为&#34;yyyy-MM-dd HH:mm:ss&#34;
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		function getFormatDate() { var date = new Date(); var month = date.getMonth() + 1; var strDate = date.getDate(); if (month &gt;= 1 &amp;&amp; month &lt;= 9) { month = "0" + month; } if (strDate &gt;= 0 &amp;&amp; strDate &lt;= 9) { strDate = "0" + strDate; } var currentDate = date.getFullYear() + "-" + month + "-" + strDate + " " + date.getHours() + ":" + date.getMinutes() + "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5076af66ad9ef477ef074fc59945f392/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/114e5c614eb36c9895136b85ee26f6c1/" rel="bookmark">
			TMS320C6748_SPI_FLASH
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
1.主函数流程
2.初始化
2.1 PSC初始化
2.2 UART初始化
2.3 管脚复用配置
2.4 DSP中断初始化
2.5 SPI中断初始化
2.6 SPI初始化
2.6.1.SPI复位
2.6.2.设置SPI模式
2.6.3.设置SPI的时钟
2.6.4.设置SPI引脚控制寄存器
2.6.5.设置SPIDEF寄存器
2.6.6.设置SPI数据格式
2.6.7.设置SPI数据格式及片选信号
2.6.8.设置中断映射
3.读写SPI外设
3.1 SPI FLASH写使能
3.2 擦除SPI FLASH
3.3 写SPI FLASH
3.4 读SPI FLASH
3.5 比较读出的SPI FLASH的数据和写入的SPI FLASH的数据
1.主函数流程 此程序的作用是实现SPI FLASH设备的数据读写功能，此设备使用SPI1总线CS0片选。主函数流程图如下：
主函数如下：
int main(void) { PSCInit(); GPIOBankPinMuxSet(); char choice; // 初始化串口终端 使用串口2 UARTStdioInit(); UARTPuts("Tronlong SPI Flash Application......\r\n", -1); // 管脚复用配置 GPIOBankPinMuxSet(); // DSP 中断初始化 InterruptInit(); // SPI 中断初始化 SPIInterruptInit(); // SPI 初始化 SPIInit(); // 写使能 WriteEnable(); UARTPuts("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/114e5c614eb36c9895136b85ee26f6c1/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/05df516bb9f6ac8db3ef7c84f1a04901/" rel="bookmark">
			groovy闭包
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Groovy是增强Java平台的唯一的脚本语言。它提供类似于Java的语法，内置映射（Map）、列表（List）、方法、类、闭包（closure）以及生成器。 Groovy是动态弱类型语言，即Groovy不要求声明变量的类型、方法的参数或者方法的返回值。这意味着在不同环境下，变量可以以多种方式使用。 Groovy类和Java是二进制兼容的。这意味着Groovy编译器产生的字节码与Java编译器产生的字节码是完全一样的。因此，对JVM而言，Groovy和Java是完全一样的。 Groovy是一门面向对象的语言。 数值和表达式 两个整数的除法运算通常会产生一个浮点数，即使其结果可能是一个整数。 如表达式6/3的结果是浮点数2.0，而不是整数2. 为了获得两个整型值相除的整数部分，必须调用intdiv方法： 13.intdiv(5) 该表达式的结果是整数2. 使用取模运算符（%）可以得到两个整数操作数相除的余数。但是对一个浮点数求模，或者对一个含有浮点数参数的整数求模都是非法的。 在Groovy中，第一次使用某个变量时，需要使用def关键字来声明变量。 变量的命名规则：可以由字母、数字和下划线组成，对大小写敏感，首字符必须是字母。 字符串和正则表达式 在Groovy中，可以使用单引号('abc')、双引号("abc")、或者三引号('''abc''')来封装字符串。使用三引号表示的字符串可以包含多行文本。 使用单引号封装的字符串的值就是所列出的字符序列本身。而在双引号和三引号中，任何包含在解释型字符串中的${expression}都将被求值， 其结果是字符串的一部分。如： def age = 25 'My age is ${age}' //My age is ${age} "My age is ${age}" //My age is 25 '''My age is ${age}''' //My age is 25 "My age is \${age}" //My age is ${age} 通用的原则是，只在字符串需要被解释的时候使用双引号，在其他情况下字符串使用单引号。
闭包常用方法demo，直接贴代码demo.groovy，运行时直接输入groovy demo.groovy：
[java] view plain copy // groovy中的闭包及常用方法 // 闭包的两种写法： // 1. 有参数的闭包：def clos = {参数名 -&gt; 代码块} // 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/05df516bb9f6ac8db3ef7c84f1a04901/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2d2a46a946bc16dc276e4ef0185b7eeb/" rel="bookmark">
			动态内存开辟  malloc  calloc  realloc  free  函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、malloc和free
malloc和free都是c语言的库函数，一般在stdlib.h中，主要用来进行一段动态内存的分配，包括申请和释放。
malloc的函数原型为Void *malloc(size_t size)，主要用于从堆上进行一段内存的申请，返回无类型的指针，需要将返回的指针转换为数据的类型，同时对申请的数据不进行初始化。
free用于将一段指针所指向的内存进行释放，free(p);由于通过malloc申请的内存在系统中记录了长度，因此不需要传入内存的长度。
二、malloc、calloc和realloc的比较
malloc的功能如上所述，calloc是用来进行堆空间的内存申请， 函数原型为void *calloc(size_t numElements，size_t sizeOfElement)；参数为申请内存元数的个数，以及类型的长度，因此不必计算所要分配的内存的总字节数，同时alloc会对申请的内存进行初始化为0；
malloc和calloc所申请的内存均位于堆空间。malloc由于不需要对所申请的内存进行初始化，因此比calloc的效率要高。
realloc相当于改变指向动态内存区的指针的指向，让它指向新的动态内存地址；函数原型为extern void *realloc(void *mem_address, unsigned int newsize);一般分配了内存之后，如果重新分配内存，当之前分配的内存够用时指针不变，但要分配更大的内存空间时，采用尾部扩展的方式和新开辟一块内存（数据移动了），并返回内存首地址的指针。
#define MEM_BLOCK_SIZE 4096 #define MEM_LARGE_BLOCK_THRESHOLD 40960 //&gt;MEM_LARGE_BLOCK_THRESHOLD :requested size is large block #define MEM_BASE_ADDRESS (0x90000000) #define MEM_ALLOC_TABLE_FIRST_ENTRY 0 #define MAX_MEM_SIZE 7*1024*1024 #define MEM_ALLOC_TABLE_SIZE (MAX_MEM_SIZE/MEM_BLOCK_SIZE) static INT16 memory_map[MEM_ALLOC_TABLE_SIZE]; static char isMemoryManagementReady=0; void *memset(void *s, int c, size_t count) { char *xs = s; while (count--) *xs++ = c; return s; } INT32 ssd_mem_init(void) { memset(memory_map, 0, sizeof(memory_map)); isMemoryManagementReady=1; } INT16 ssd_mem_percentage_used() { int used=0; int i; for(i=0;i&lt;MEM_ALLOC_TABLE_SIZE;i++) { if(memory_map[i]) { used++; } } return used*100/MEM_ALLOC_TABLE_SIZE; } //return -1:FAIL //&gt;=0: return allocated address offset INT32 ssd_mem_malloc(UINT32 size) { int offset=0; int startEntry=MEM_ALLOC_TABLE_FIRST_ENTRY; int nmemb; int i; if(!
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2d2a46a946bc16dc276e4ef0185b7eeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7e1c9f4d3ebb45caee4db19be7f60036/" rel="bookmark">
			算法题：直方图和0-1矩阵中最大矩形
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前几天看到一道算法题目，看起来挺简单，就是有一个由0和1构成的矩形，然后找到这个矩形中全部元素都是1的最大子矩形，初看起来好像挺简单，但是我想半天没有想出来。上网搜了下才发现，这道题目还挺有名的，很多人都写文章探讨过，一个非常好的解法是借用一个找直方图中最大面积矩形的算法，可以用很短的代码来实现。所以我准备记述一下关于这两道题目的解法，有着一些自己的视角可供参考。
寻找直方图中的最大矩形 这道题的题目如下： Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit.
下面介绍一种用栈来解决的方法，快到可以达到 O(N) 。
1 首先考虑一种极端情况，所有的元素是升序的 在这种情况下我们怎么找到最大的矩形？这里先引进一种方法，我们会看到他是可以工作的。
步骤：先考察最右边也就是最大的矩形，它所能够组成的最大矩形就是自己，然后考虑倒数第二个，它所能够组成的最大矩形是自己的面积乘以2（假设矩形的宽度都为1，图画的不标准），也就是（最大位置i-当前矩形位置k+1） 如下图所示 再往前数以此类推直到最小的矩形，最后所有得到的面积中的最大值就是所要求的面积。这个算法的正确性是很显然的。
有了上面那个极端情况的铺垫之后，我们理解真正的算法就简单多了。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7e1c9f4d3ebb45caee4db19be7f60036/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/caca7b88c59f334ab97b72d38f0285fb/" rel="bookmark">
			基于MATLAB的PCA人脸识别实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		基于MATLAB的PCA人脸识别实现 前言 其实这个程序早就完成了，而且还要比另一篇基于opencv的博文还要早，这里主要是回顾一下。关于PCA人脸识别的步骤已经在另一篇博文中有讲解，这里就不多说了，直接上程序。代码下载地址 或移步到 github
目录 文章目录 基于MATLAB的PCA人脸识别实现前言目录1. 函数设计1.1 函数调用过程1.2 函数介绍 2. 数据准备3. 主函数4. 源码 1. 函数设计 1.1 函数调用过程 1.2 函数介绍 从整体上分为训练和测试两大函数，训练函数pca_train将训练的模型数据以pca_data.mat形式保存到当前目录。测试函数pca_test执行时从pca_data.mat从加载数据。
训练函数：
pca_train(path,trainImageNameList, newSize, trainClassType, energy) %pca_train(path,trainImageNameList, newSize, trainClassType, energy) %功能：根据训练样本，计算并保存classType,newSize,originSize，平均脸，特征脸，投影矩阵,到pca_data.mat %输入： % path：训练样本路径 % trainImageNameList：训练图像名称列表（元胞数组） % newSize：缩减后的图像尺度 % trainClassType：训练样本类别标号(列向量) % energy：能量比 %输出： %保存pca_data.mat到当前目录 测试函数：
testClassType = pca_test(path, testImageNameList, trueClassType) %testClassType = pca_test(path, testImageNameList, trueClassType) %功能：训练样本，得到特征空间的投影矩阵，并求测试样本的类别 %输入： % path：测试样本路径 % testImageNameList：测试图像名称列表（元胞数组） % trueClassType：测试真实类别 %输出： %testClassType：分类结果 数据阵准备子函数：
[samples, samplesMean, rawNum, rolNum, originSize]=arrDataMat(path, imageNameList, newSize) %[samples, samplesMean, rawNum, rolNum, originSize]=arrDataMat(path, imageNameList, newSize) %子函数，根据图像名称列表，读取图像数据，并灰度化，转化成 样本数*[newSize(1)*newSize(2)]数据阵 %输入： %path：图像路径 %imageNameList：图像名称列表，类型为元胞数组 %newSize：缩减后图像尺度 %输出： %samples：数据矩阵（一行为一个样本） %samplesMean：数据阵平均值（行向量） %rawNum：样本数 %rolNum：原始的变量维数，即像素的行*像素的列 %originSize：缩减前图片尺寸 特征向量施密特正交化单位化：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/caca7b88c59f334ab97b72d38f0285fb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a15b5d21aafcf2a9d87c7747f5dffddf/" rel="bookmark">
			windows CMD 命令下dir 命令
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		dir /?
显示目录中的文件和子目录列表。 DIR [drive:][path][filename] [/A[[:]attributes]] [/B] [/C] [/D] [/L] [/N] [/O[[:]sortorder]] [/P] [/Q] [/R] [/S] [/T[[:]timefield]] [/W] [/X] [/4] [drive:][path][filename] 指定要列出的驱动器、目录和/或文件。 /A 显示具有指定属性的文件。 属性 D 目录 R 只读文件 H 隐藏文件 A 准备存档的文件 S 系统文件 I 无内容索引文件 L 解析点 - 表示“否”的前缀 /B 使用空格式(没有标题信息或摘要)。 /C 在文件大小中显示千位数分隔符。这是默认值。用 /-C 来禁用分隔符显示。 /D 跟宽式相同，但文件是按栏分类列出的。 /L 用小写。 /N 新的长列表格式，其中文件名在最右边。 /O 用分类顺序列出文件。 排列顺序 N 按名称(字母顺序) S 按大小(从小到大) E 按扩展名(字母顺序) D 按日期/时间(从先到后) G 组目录优先 - 反转顺序的前缀 /P 在每个信息屏幕后暂停。 /Q 显示文件所有者。 /R 显示文件的备用数据流。 /S 显示指定目录和所有子目录中的文件。 /T 控制显示或用来分类的时间字符域。 时间段 C 创建时间 A 上次访问时间 W 上次写入的时间 /W 用宽列表格式。 /X 显示为非 8.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a15b5d21aafcf2a9d87c7747f5dffddf/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/df2cadc3b4b4daccd72bfd0e5d750b0f/" rel="bookmark">
			springBoot下的ftp下载
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		springBoot下的ftp下载 springboot-Environment
ftp登录、退出
打包下载
本实例将创建一个ftp打包文件的工具类
Environment类获取配置信息 springboot的Environment类，可以获取到所有的配置资源。如果我们用到ftp，就会有一些登录ftp的相关ip、port、username、password，按照程序员的尿性，肯定不能直接写在类里。
private FTPClient ftpClient; private String strIp; //ftp ip private int intPort; //ftp port private String user; //ftp username private String password; //ftp password private Environment environment; public FtpUtils(Environment environment){ this.environment = environment; this.strIp = environment.getProperty("配置文件里咋写的你咋写"); String strPort = environment.getProperty("配置文件里咋写的你咋写"); if(!strPort.trim().equals("")){ this.intPort = Integer.valueOf(strPort); } this.user = environment.getProperty("配置文件里咋写的你咋写"); this.password = environment.getProperty("配置文件里咋写的你咋写"); this.ftpClient = new FTPClient(); } FTPClient是啥玩意？ 如果你没有commons-net包，肯定是不行的，这包咋来的就先不说了。 具体咋登陆的ftp服务器，其实FTPClient都写好了，人家就是干这个事的。我们只需要跟它提供登陆需要的信息，就比如我们用filezilla登陆时要填的信息
ftp登录、退出登录 登陆 /** * 登录ftp服务器 * @return */ public boolean ftpLogin(){ boolean isOk = false; // 这个编码的设定因情况而定，这里只告诉大家，能设置编码 ftpClient.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/df2cadc3b4b4daccd72bfd0e5d750b0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/2e078980ae6d11be8de362f1789ab65f/" rel="bookmark">
			快速排序的C语言实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		快速排序方法对整数序列操作的一种C语言实现
目标 给定一个长度为n的整数序列，将序列从小到大进行排序
原理 从序列中任选一个值，将原有序列划分为两个子序列，其中，左侧序列中的值均小于该选出的值，右侧序列中的值均大于或者等于该选中的值，该值位于两个子序列交界（既不属于左侧、也不属于右侧）；分别对左侧、右侧的子序列用同样的方法进行排序；将两个子序列以及中心位置的值进行合并，获得最终排序后的结果。 实现 #include &lt;stdio.h&gt; /** * 将输入序列划分为两个子序列，并返回中间位置的下标 * * @param arr 输入划分的输入序列 * @param left 需要划分序列的最左侧元素下标 * @param right 需要划分序列的最右侧位置下标 * @return 找到的中心位置坐标 */ int partition(int arr[], int left, int right) { int j = left, i; int selectedValue = arr[right]; int temp; // 用j指定预期的中心点位置 // 用游标i从左向右遍历，如果小于选定值，则扔到j指定位置的左侧，否则继续向右 for (i = left; i &lt; right; i++) { if (arr[i] &lt; selectedValue) { // 交换i与j位置的值，并更新j指向的位置 temp = arr[i]; arr[i] = arr[j]; arr[j] = temp; j++; } } arr[right] = arr[j]; arr[j] = selectedValue; return j; } /** * 对输入序列进行快速排序 * * @param arr 待排序数组 * @param left 需要排列位置的最左侧元素下标 * @param right 需要排序位置的最右侧位置下标 */ void quickSort(int arr[], int left, int right) { int q; if (left &lt; right) { q = partition(arr, left, right); quickSort(arr, left, q - 1); quickSort(arr, q + 1, right); } } int main() { int i = 0; int a[15] = { 3, 4, 53, 4, 5, 3, 4, 5, 6, 2, 37, -3,-33, 5, 3 }; quickSort(a, 0, 14); // 输出 for (i = 0; i &lt; 15; i++) { printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/2e078980ae6d11be8de362f1789ab65f/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/444/">«</a>
	<span class="pagination__item pagination__item--current">445/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/446/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>