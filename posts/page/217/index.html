<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8aa72c1762b7512f988650a73faef4b9/" rel="bookmark">
			C语言sscanf()函数（从字符串读取格式化输入，提取需要的信息）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		C语言函数fscanf()（从流 stream 读取格式化输入）（如果成功，返回成功匹配和赋值的个数；否则返回EOF）（分隔符：space、Tab、Enter）
需包含头文件：C 标准库 - &lt;stdio.h&gt;
文章目录 描述声明参数返回值实例我在VS上测试（VS上要用sscanf_s）示例1示例2（提取时能默认以空格分割） 描述 C 库函数 int sscanf(const char *str, const char *format, ...) 从字符串读取格式化输入。
声明 下面是 sscanf() 函数的声明。
int sscanf(const char *str, const char *format, ...) 参数 str – 这是 C 字符串，是函数检索数据的源。format – 这是 C 字符串，包含了以下各项中的一个或多个：空格字符、非空格字符 和 format 说明符。format 说明符形式为 [=%[*][width][modifiers]type=]，具体讲解如下：
sscanf 类型说明符： 附加参数 – 这个函数接受一系列的指针作为附加参数，每一个指针都指向一个对象，对象类型由 format 字符串中相应的 % 标签指定，参数与 % 标签的顺序相同。针对检索数据的 format 字符串中的每个 format 说明符，应指定一个附加参数。如果您想要把 sscanf 操作的结果存储在一个普通的变量中，您应该在标识符前放置引用运算符（&amp;），例如： int n; sscanf (str,"%d",&amp;amp;n); 返回值 如果成功，该函数返回成功匹配和赋值的个数。如果到达文件末尾或发生读错误，则返回 EOF。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8aa72c1762b7512f988650a73faef4b9/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a12c5d7972b3ec3d8aad248bfbc90eee/" rel="bookmark">
			目标检测mAP（Mean Average Precision）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		TP(True Postives） IoU&gt;0.5检测出边框的数量
FP(False Positives) IoU&lt;=0.5检测出边框的数量
FN(False Negatives) 没有检测到gt的的数量
Precision : TP/(TP+FP) 查准率
Recall ： TP/(TP+FN) 查全率
AP： Precision-Recall 曲线下面积
mAP：各种类别AP的平均值
Retrieval cutoffPrecisionRecallTop 1 image100%20%Top 2 images100%40%Top 3 images66%40%Top 4 images75%60%Top 5 images60%60%Top 6 images66%80%Top 7 images57%80%Top 8 images50%80%Top 9 images44%80%Top 10 images50%100% 图来源：It’s a bird… it’s a plane… it… depends on your classifier’s threshold
假设得到的pr数据如上，我们可以得到pr图
首先要删除recell相同，并且precision小于最大值的数据，不加入计算
AP：(1 *0.2) + (1 * 0.2) + (0.75 * 0.2) + (0.66 * 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a12c5d7972b3ec3d8aad248bfbc90eee/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bb902cb55793681058974ea162715ad4/" rel="bookmark">
			何恺明团队提出探索用于目标检测的不分层ViT Backbone
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【写在前面】 作者探索了普通的、非分层的视觉Transformer（ViT）作为目标检测的骨干网络。这种设计使原始 ViT 架构能够针对对象检测进行微调，而无需重新设计用于预训练的分层主干。通过对微调的最小调整，本文的普通骨干检测器可以获得具有竞争力的结果。令人惊讶的是，作者观察到:(1)从单尺度特征图(没有常见的FPN设计)构建一个简单的特征金字塔是足够的，(2)在很少的跨窗口传播块的辅助下，使用窗口注意(不移动)是足够的。通过使用预训练的纯ViT主干mask自动编码器(MAE)，本文的检测器名为ViTDet，可以与之前所有基于分层主干的SOTA方法取得竞争性的结果，仅使用ImageNet-1K预训练就可以在COCO数据集上达到61.3 APbox。
1. 论文和代码地址 Exploring Plain Vision Transformer Backbones
for Object Detection
论文地址：https://arxiv.org/abs/2203.16527
代码地址：https://github.com/facebookresearch/detectron2/tree/main/projects/ViTDet
2. Motivation 现代目标检测器通常由一个与检测任务无关的主干特征提取器和一组包含特定检测先验知识的颈部（neck）和头部（head）组成。颈部/头部中的常见组件可能包括RoI 操作 、区域建议网络 (RPN) 或锚点（Anchor）、特征金字塔网络 (FPN) 等。如果特定任务的颈部/头部的设计与骨干的设计脱钩，它们可能会并行发展。根据实验，目标检测研究受益于对通用主干和检测特定模块的很大程度上独立探索。长期以来，由于卷积网络 (ConvNet) 的实际设计，这些主干一直是多尺度、分层架构，这严重影响了用于检测多尺度对象的颈部/头部设计（例如，FPN ）。
在过去的一年中，视觉Transformer (ViT) 已被确立为视觉识别的强大支柱。与典型的 ConvNets 不同，原始的 ViT 是一个简单的、非分层的架构，它始终保持单尺度特征图。它的“极简主义”追求在应用于对象检测时遇到了挑战——例如，**如何通过上游预训练的简单主干处理下游任务中的多尺度对象？是否普通的 ViT在使用高分辨率检测图像效率低下？**放弃这种追求的一种解决方案是将分层设计重新引入主干。该解决方案，例如 Swin Transformers，可以继承基于 ConvNet 的检测器设计并显示出成功的结果。
在这项工作中，作者追求不同的方向：探索仅使用普通、非分层主干的目标检测器。如果这个方向成功，它将能够使用原始 ViT 主干进行目标检测；这将使预训练设计与微调需求脱钩，保持上游与下游任务的独立性，就像基于 ConvNet 的研究一样。这个方向也部分遵循了 ViT 在追求通用特征时“减少归纳偏置”的哲学。由于非局部自注意力计算可以学习平移等变特征，它们还可以从某些形式的监督或自监督预训练中学习尺度等变特征。
在本文的研究中，作者的目标不是开发新组件。相反，作者进行了足以克服上述挑战的最小调整。特别是，本文的检测器仅从普通 ViT 主干的最后一个特征图构建一个简单的特征金字塔（见上图）。这放弃了 FPN 设计并放弃了分层主干的要求。为了有效地从高分辨率图像中提取特征，本文的检测器使用简单的非重叠窗口注意力。少量的跨窗口块（例如 4 个）可能是全局注意力或卷积，用于传播信息。这些调整仅在微调期间进行，不会改变预训练。
事实证明，本文简单的设计取得了令人惊讶的结果。作者发现在普通的 ViT 主干的情况下，FPN 设计不是必需的，它的好处可以通过从大步幅、单比例特征图构建的简单金字塔有效地获得。作者还发现，只要信息在少量层的窗口中很好地传播，窗口注意力就足够了。
更令人惊讶的是，在某些情况下，本文名为 ViTDet 的普通骨干检测器可以与领先的分层骨干检测器（例如 Swin 、MViT ）竞争。使用 Masked Autoencoder (MAE) 预训练，本文的普通骨干检测器可以胜过在 ImageNet-1K/21K 上通过监督预训练的分层检测器（见上图）。对于较大的模型尺寸，收益更为突出。本文的检测器的竞争力是在不同的目标检测器框架下观察到的，包括 Mask R-CNN 、Cascade Mask R-CNN 及其增强模型。本文基于普通的 ViT-Huge 主干，在 COCO 数据集上报告了 61.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bb902cb55793681058974ea162715ad4/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/39abdcbc5fce4062b7da0249ccd73566/" rel="bookmark">
			Ubuntu 安装 tbb 步骤详解
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 写在前面一、下载二、编译三、安装参考链接 写在前面 自己的测试环境是 Ubuntu16.04.
由于ubuntu版本的的限制，使用 ubuntu 的二进制指令 sudo apt-get install libtbb-dev
进行安装 tbb 的版本较低。Ubuntu16.04 二进制安装的 tbb 版本是 4.4~20151115-0ubuntu3，Ubuntu18.04 二进制安装的 tbb 版本是 2017~U7-8.
此教程同样适用于 ubuntu 18.
一、下载 下载源码
从github 上下载 tbb源码 ，我这里下载 2020_U3 版本。 二、编译 解压
tar -zxvf oneTBB-2020_U3.tar.gz 因为要使用 gcc-9 进行编译，所以需要编辑成 gcc-9 形式
cp build/linux.gcc.inc build/linux.gcc-9.inc 编辑 linux.gcc-9.inc 文件：
第15、16行原来是
CPLUS ?= g++ CONLY ?= gcc 修改为
CPLUS ?= g++-9 CONLY ?= gcc-9 然后在文件夹 oneTBB-2020_U3/ 中编译
cd oneTBB-2020_U3 make compiler=gcc-9 stdver=c++17 tbb_build_prefix=my_tbb_build 编译完成后，在 builld/ 文件夹下会看到编译生成的文件夹 my_tbb_build_release/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/39abdcbc5fce4062b7da0249ccd73566/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b2c1f0d6326586a7fd6377d81a3db52/" rel="bookmark">
			window常用命令合集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先打开命令行窗口
键盘win键+r
输入cmd回车
出现命令提示符窗口
1.命令：dir 浏览当前文件夹内容
格式 dir 要浏览的路径
参数： dir /a 浏览所有内容，包括隐藏
dir /a:d #列出所有目录
dir /a:h #列出所有隐藏文件
2.命令：cd 进入文件夹
格式 cd 文件夹名
参数：cd /d d:/test #切换目录时，可连同所在分区一起切换
cd .. 返回上级目录
cd \ 退到根目录
3.命令：盘符 切换分区
格式 切换的盘：
例如：c: d: e:
4.命令：md 创建新的目录
格式 md 文件夹 [文件夹 文件夹 文件夹]
例如：md .\a
md .\a\b\c
5.命令：rd 删除空的文件夹
格式 rd 文件夹 [文件夹 文件夹 文件夹]
参数：rd 文件夹 /s /q 无提示删除所有文件
6.命令：echo 创建文件
格式 echo 字符串 &gt; [路径\] 文件名.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b2c1f0d6326586a7fd6377d81a3db52/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f87b7ae8690c1fcff826698df419edd/" rel="bookmark">
			Django错误：Migration admin.0001_initial is applied before its dependency users.0001_initial on databas
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 Django错误：Migration admin.0001_initial is applied before its dependency users.0001_initial on databas 完整错误提示：
django.db.migrations.exceptions.InconsistentMigrationHistory: Migration admin.0001_initial is applied before its dependency users.0001_initial on database 'default'. 背景：
在执行makemigrations，migrate后报错。
原因：因为之前有迁移过数据库，使用了django内部自带的admin 认证管理，新用户模型建立之后没有找到user admin依赖，因此，先注释掉原先的admin认证模型，然后执行迁移，让新的用户模型和admin产生依赖即可
解决方法： 1.先注释掉setting.py中 admin app INSTALLED_APPS = [ #'django.contrib.admin', ] urls.py中的路由
urlpatterns = [ path('', include('registers.urls')), # path('admin/', admin.site.urls), ] 2. 执行migrate python manage.py migrate 3. 取消注释 INSTALLED_APPS = [ 'django.contrib.admin', ] urlpatterns = [ path('', include('registers.urls')), path('admin/', admin.site.urls), ] 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1053a1167c3bcf6271e12bf73229f4bd/" rel="bookmark">
			Docker端口映射
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Docker端口映射 前言1 随机映射2 映射所有地址的指定端口3 映射指定地址的随机端口4 映射指定地址的指定端口 前言 在启动容器的时候，如果不指定对应的参数，在容器外部是无法通过网络来访问容器内部的网络应用和服务的。
当容器中运行一些网络应用，要让外部访问这些应用时，可以通过-p或-P参数来指定端口映射。
1 随机映射 当使用-P（大写）标记时，Docker会随机映射一个端口到内部容器开放的网络端口（端口范围在 Linux 系统使用的端口之外且一般过万）。
[root@johnnyg03 ~]# docker run -it --name web1 -P nginx:latest /bin/bash [root@johnnyg03 ~]# docker port web1 80/tcp -&gt; 0.0.0.0:49154 80/tcp -&gt; :::49154 oot@8d7dd9f2147a:/# echo "hello web1" &gt; /usr/share/nginx/html/index.html root@8d7dd9f2147a:/# /usr/sbin/nginx [root@johnnyg03 ~]# curl 10.0.2.12:49154 hello web1 2 映射所有地址的指定端口 [root@johnnyg03 ~]# docker run -it --name web2 -p 80:80 nginx:latest /bin/bash [root@johnnyg03 ~]# docker port web2 80/tcp -&gt; 0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1053a1167c3bcf6271e12bf73229f4bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8348e6a63cc6ecef1e2531ee0e18f8bf/" rel="bookmark">
			物联网的概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 0x01 物联网的概念0x02 物联网的组成0x03 物联网交互的技术大数据云网络网络架构移动设备 0x04 物联网相辅相成的优点 0x01 物联网的概念 物联网(Internet of Things，IoT)是一个由相互关联的计算设备、数字机器、物体或人组成的系统，通过信息传感器、射频识别技术、全球定位系统、红外感应器、激光扫描器等各种装置与技术，实时采集需要监控、连接、互动的物体或过程，
嵌入式系统、无线传感器网络、控制系统、自动化（包括家庭和楼宇自动化）的传统领域，独立和共同使能物联网。
物联网又与嵌入式系统，无线传感器网络，控制系统，自动化（包括家庭和楼宇自动化）等传统领域相关联，可以定义为“人与物之间的智能交互，以交换信息和知识以创造新的价值”。
0x02 物联网的组成 物联网是一个复杂的生态系统，涵盖了Internet的所有方面，包括云、应用程序、安全等等。
从技术上讲，将设备连接到Internet可以通过三个主要技术组件：
物理设备和传感器：物理设备和传感器能够自动收集和感知多维信息，以及事件的客观条件，而无需人工干预。此外，当设备捕获具有嵌入式的信息时，设备可以采取相应措施做出不同的响应。连接和基础设施：连接和基础架构有助于实现实时的数据流与信息流交互。分析与应用：分析与应用程序将传感器生成的信息转换为新的知识源。 0x03 物联网交互的技术 随着互联设备和互联个人的兴起，交互技术同时推动着物联网的发展：
大数据 大数据是指传统数据处理应用软件无法处理的庞大或复杂的数据集，大量的数据提供了更强大的统计能力。
大数据分析挑战包括捕获数据、数据存储、数据分析、搜索、共享、传输、可视化、查询、更新、信息隐私，和数据源。
云网络 云是向用户提供信息和功能的交付平台，云使信息和知识可以随时随地传递并访问。
网络架构 随着网络的迅速发展，网络空间的弹性增强，物联网作为网络连接的其中一个载体，将成千上万的设备进行丽娜姐，在网络层的扩展性上发挥了巨大的作用。
移动设备 移动设备是一种体积很小可以方便携带的设备，全球主要的移动设备制造商有苹果、三星、华为、魅族、中兴、小米、索尼等。
许多移动设备可以连接到互联网并通过Wi-Fi、蓝牙、蜂窝网络或近场通信(NFC)与其他设备相互连接。
0x04 物联网相辅相成的优点 云计算平台：云平台可用性的提高使信息和知识可以随时随地传递并访问。低成本：物联网的发展使很多行业得以迅速发展，发展过程中，更多低成本的产品的但是打开了更广阔的市场。连接的变通性：大量互联网网络协议使得将传感器连接到云和其他设备或产品变得很容易，以实现高效的数据传输。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/082208aa6c0ce1bf4eb7038fe67e9627/" rel="bookmark">
			物联网安全的概念
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 0x01 物联网安全的概念 随着各行业的迅速发展，物联网技术已是人们日常生活中必不可少的一部分，越来越多的设备开始加入IoT生态系统，越来越多未知设备的接入使安全问题成了物联网技术的最大关注点，大多数技术安全问题类似于常规服务器，工作站和智能手机，可能存在弱认证，忘记更改默认凭据，设备之间发送未加密消息，SQL注入等问题。
随着 5G 等技术突破发展，物联网的发展更加迅速，与此同时物联网的安全问题成了关注的焦点。
#0x02 物联网安全威胁
感知层威胁分析 感知层安全威胁分析指全面感知外界信息，感知层包括：传感器、RFID、MEMS、二维码识别等。
可能会面临：感知节点所感知的信息被非法获取、普通节点被非法控制、关键节点被非法控制、普通节点被非法捕捉、节点受到来自网络的DOS攻击等问题。
感知层安全分为信息安全、物理安全两类，能够提供鉴别和认证、保密性、完整性、可用性、容错性、不可否认性、扩展性服务。
网络层威胁分析 网络层安全威胁分析指把感知层收集到的信息安全可靠地传输到应用层，然后根据不同的应用需求进行信息处理。
网络层安全威胁包括DOS攻击、中间人攻击、非法接入等。
网络层安全机制可分为端到端机密性和节点到节点机密性，可以提供加密机制、数字签名机制、数据完整性机制、实体认证机制、访问控制机制、信息过滤机制、路由控制机制、公正机制、主动防御等机制。
应用层威胁分析 应用层能够迅速处理收到的请求，但是可能仅限于按照一定规则进行过滤和判断，攻击者很容易避开这些规则。可能会受到来自于超大量终端的天量数据的识别和处理、自动变为失控、非法人为干预等。
应用层为物联网的核心，而物联网的应用有很多，例如：智能家居、智慧城市、智能医疗、智能水务等等。
物联网安全关键技术 多业务、多层次数据安全传输技术身份认证技术基于多网络的网络安全接入技术网络安全防护技术密码技术分布式密钥管理技术分布式安全管控技术 0x03 物联网常见漏洞 节点越权访问漏洞：感知节点设备应用中用户可能存在特权等级升级到另一个特权等级或同等级其他账户的安全问题；网关节点：可能遭到节点资源耗尽导致其不能正常工作；中间人攻击：设备可能存在证书欺骗等威胁存在；弱口令攻击：设备存在中间件、数据库登录口令、ssh等若口令；信号重放攻击：包含车钥信号重放、门锁信号重放、停车场等场所控制杆重放等；未经验证的软件/固件更新测试：系统没有进行相应的完整性或真实性检查可能导致攻击者可以安装任意固件；固件提取漏洞：攻击者可以通过获取设备的底层固件，得到固件中所包含的敏感信息，例如，加密算法、密钥信息，明文密码等信息。固件敏感信息泄露：攻击者能够通过固件系统中的获取到的后门账号、硬编码密码等信息登陆到设备中；固件提取漏洞：攻击者可以通过获取设备的底层固件，得到固件中所包含的敏感信息，例如，加密算法、密钥信息，明文密码等信息。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/de46fd8e3b46075bee0013cb358fcf9c/" rel="bookmark">
			黑马程序员---三天快速入门Python机器学习（第一天）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器学习入门 一、机器学习概述1.1 人工智能概述1.1.1 机器学习与人工智能、深度学习1.1.2 机器学习、深度学习能做什么1.1.3 人工智能阶段课程安排 1.2 什么是机器学习1.2.1 定义1.2.2 解释1.2.3 数据集构成 1.3 机器学习算法分类1.3.1 总结1.3.2 练习1.3.3 机器学习算法分类 1.4 机器学习开发流程1.5 学习框架和资料介绍1.5.1 机器学习库与框架1.5.2 书籍资料1.5.3 提深内功 二、特征工程2.1 数据集2.1.1 可用数据集2.1.2 sklearn数据集2.1.3 数据集的划分 2.2 特征工程介绍2.2.1 为什么需要特征工程2.2.2 什么是特征工程2.2.3 特征工程的位置与数据处理的比较 2.3 特征提取2.3.1 什么是特征提取2.3.2 字典特征提取2.3.3 文本特征提取 2.4 特征预处理2.4.1 什么是特征预处理2.4.2 归一化2.4.3 标准化 2.5 特征降维2.5.1 降维2.5.2 降维的两种方式2.5.3 什么是特征选择 2.6 主成分分析2.6.1 什么是主成分分析（PCA）2.6.2 案例：探究用户对物品类别的喜好细分降维 2.7 机器学习第一天总结 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站：人工智能从入门到精通教程
一、机器学习概述 1.1 人工智能概述 1.1.1 机器学习与人工智能、深度学习 机器学习是人工智能的一个实现途径深度学习是机器学习的一种方法 1.1.2 机器学习、深度学习能做什么 传统预测：店铺销量预测、量化投资、广告推荐、企业客户分类、SQL语句安全检测分类图像识别：街道交通标志检测、人脸识别自然语言处理：文本分类、情感分析、自动聊天、文本检测 1.1.3 人工智能阶段课程安排 1.2 什么是机器学习 1.2.1 定义 机器学习是从数据中自动分析获得模型，并利用模型对未知数据进行预测
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/de46fd8e3b46075bee0013cb358fcf9c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c221eddef084bb0b8a920d3f8e355593/" rel="bookmark">
			黑马程序员---三天快速入门Python机器学习（第三天）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 四、回归与聚类算法4.1 线性回归4.1.1 线性回归的原理4.1.2 线性回归的损失和优化原理4.1.3 线性回归API4.1.4 波士顿房价预测4.1.5 梯度下降的扩展：GD、SGD、SAG4.1.6 总结 4.2 欠拟合与过拟合4.2.1 什么是过拟合与欠拟合4.2.2 原因以及解决方法 4.3 线性回归的改进---岭回归4.3.1 带有L2正则化的线性回归--岭回归 4.4 分类算法--逻辑回归与二分类4.4.1 逻辑回归的应用场景4.4.2 逻辑回归的原理4.4.3 逻辑回归API4.4.4 案例：癌症分类预测-良/恶性乳腺癌肿瘤预测4.4.5 分类的评估方法 4.5 模型保存和加载4.5.1 模型的保存和加载API4.5.2 线性回归的模型保存加载案例 4.6 无监督学习：K-means算法什么是无监督学习4.6.2 无监督学习包含算法4.6.3 K-means原理4.6.4 K-means API4.6.5 案例：k-means对instacart Market用户聚类4.6.6 K-means性能评估指标4.6.7 K-means总结 前些天发现了一个巨牛的人工智能学习网站，通俗易懂，风趣幽默，忍不住分享一下给大家。点击跳转到网站：人工智能从入门到精通教程
四、回归与聚类算法 4.1 线性回归 学习目标：
记忆线性回归的原理过程应用LinearRegression或SGDRegressor实现回归预测记忆回归算法的评估标准及其公式 4.1.1 线性回归的原理 1 线性回归应用场景
2 什么是线性回归
不同权重加权
2）线性回归的特征与目标的关系分析
广义线性模型
4.1.2 线性回归的损失和优化原理 1 损失函数：最小二乘法
2 优化算法
正规方程：直接求解W梯度下降：试错，改进 正规方程：直接求解W
梯度下降（Gradient Descent）
4.1.3 线性回归API 1）线性回归：
sklearn.linear_model.LinearRegression(fit_intercept=True) fit_intercept：是否计算偏置LinearRegression.coef_：回归系数LinearRegression.intercept_：偏置 2）梯度下降：
sklearn.linear_model.SGDRegressor(loss="squared_loss", fit_intercept=True, learning_rate='invscaling', eta0=0.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c221eddef084bb0b8a920d3f8e355593/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/01381b4e1b68ac53e2095d3cfd90279f/" rel="bookmark">
			各种FIFO硬件设计（FIFO概念、异步、同步、非2次幂深度FIFO）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 一、FIFO概述二、FIFO分类三、FIFO重要信号与参数3.1 信号3.2 参数3.2.1 data_depth的确定 四、FIFO存储原理五、同步FIFO5.1 空满信号判断5.2 同步FIFO源码5.3 测试源码5.4 功能仿真结果在这里插入图片描述 六、异步FIFO6.1 异步FIFO架构6.2 设计源码6.2.1 二进制-格雷码转换器6.2.2 信号同步器(dff)6.2.3 异步FIFO顶层6.2.4 测试源码6.2.5 功能仿真结果 七、非2的次幂FIFO7.1 设计思路7.2 设计源码7.3 测试程序7.4 功能仿真 八、非2次幂FIFO(带将空将满信号与FIFO余量)8.1 设计源码8.2 测试源码8.3 功能仿真结果 (码字不易、三连支持)
一、FIFO概述 FIFO（first in first out）是一种先进先出的存储器，与栈不同，栈对应的是一种先进后出的数据存储理念。
FIFO无论是在IC设计中、IP核设计中、SOC设计中都存在广泛的应用。特别是随着设计复杂度的提高，在一个系统中往往会引入多个时钟，这也就使得数据的跨时钟域处理显得尤为重要，而FIFO正是解决这一问题的有效方法。
FIFO的设计应用：
1.德州仪器tm4c123g单片机的UART模块使用FIFO做缓冲。
2.NXP单片机正交解码器缓冲。
3.摄像头的数据缓冲。
4.使用ADC配合FIFO与DMA实现高速采集。
5.提高状态机模块的数据吞吐率（软件不需要再读状态机的busy标志位，只需关心fifo是否空满）。
二、FIFO分类 FIFO根据读写时钟域的不同可分为同步FIFO与异步FIFO。
同步FIFO是指读写通道均在相同的时钟下进行信号采样的FIFO，主要用于设备之间数据传输速率的匹配。
异步FIFO是指读写通道在不同的时钟下进行信号采样的FIFO，主要处理跨时钟域之间的数据传输问题。
系统2如果直接去采样处于时钟域1的系统数据，很有可能会采样到处于亚稳态的数据。使用异步FIFO对数据进行缓冲一定程度上减少了亚稳态发生的概率。
(无论是同步还是异步的FIFO，都是面向数据流的一种数据存储器，都具有数据缓冲作用）。
三、FIFO重要信号与参数 3.1 信号 通道信号位宽描述nrst1复位信号，有效时将清空FIFO中已缓冲的数据写通道clk_w1写数据时钟，上升沿采样写通道信号写通道wr_en1写有效信号，当其无效时，FIFO将忽略写通道传输的数据；也可视为写数据的同步帧；当其有效时，FIFO会写入当前数据；写通道wrdata任意（需与RAM匹配）写数据输入，位宽视需求任意；写通道full1FIFO满信号，当写满时，此信号有效，此时FIFO将阻塞数据的输入；写通道almost_full1将满信号，当FIFO中存储的数据达到或超过设定的余量时，将有效；此时FIFO不会阻塞数据的写入，但设备可以通过此信号来决定是否继续写入数据；读通道clk_r1读数据通道时钟；（在同步FIFO中，该信号必须与clk_w接至同一时钟）读通道rd_en1读有效信号，当其无效时，FIFO停止数据的读出；也可视为读数据的同步帧；当其有效时，FIFO会读出数据；读通道rddata任意（需与RAM匹配）读数据输出，位宽视需求任意；读通道empty1空信号，当FIFO中数据为空时有效；此时FIFO将阻塞数据的读取；读通道almost_empty1将空信号，当FIFO中存储的数据达到或低于设定的最小余量时，将有效；此时FIFO不会阻塞数据的读出，但设备可以通过此信号来判断是否继续读出数据；data_count任意(与数据深度匹配)存储计数器，表示当前FIFO中存储数据的数量，设备可根据该信号来判断是否写入或读出数据； 在FIFO实际的应用中，一般将empty与almost_full配合起来使用。为了减少FIFO上溢的风险，full信号很少使用。
3.2 参数 参数描述data_depth数据深度，代表了FIFO缓冲数据的能力；一般为2的次幂；在支持非2次幂深度的FIFO中，可任意；data_width数据读写宽度，一般与内部RAM匹配数据宽度，在不匹配情况下需要对数据进行补位处理；addr_width地址宽度，与深度对应，其关系式：addr_width = log2(data_depth) data_depth是否越大越好？
否，data_depth应该根据读写数据方的速率进行合理确定。
过大的data_depth会消耗过多的资源（若RAM是LUT实现，则消耗大量的LUT，若是Block RAM 则消耗Block RAM资源）
3.2.1 data_depth的确定 深度的确定既要满足数据不丢失，且不能过多的浪费资源；
这里首先考虑极端情况：
如果写数据方的写入速率大于读数据方的读出速率，则FIFO的数据深度只有无穷大时，才能确保数据不溢出；显然无穷大深度的FIFO是不存在的；这种情况是无解的；
相较于上述的极端情况，更多的是考虑写入Burst数据的情况，虽然写入数据流是连续的，但写Burst之间数据往往存在时间间隔；
fw&gt;fr，且读写之间没有空闲周期：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/01381b4e1b68ac53e2095d3cfd90279f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a13d5c2437f1fe5cc4f43015c05f6aae/" rel="bookmark">
			Android 获取手机Ram 和 Rom大小
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		项目场景： 在设置模块，工模测试模块中，经常需要查看手机设备的配置信息，比如RAM 和 ROM大小，RAM 我们可以通过读取/proc/meminfo 表里面的信息获得， ROM可以通过计算获取精确的内存大小bit值，但是手机中实际显示的时候一般为 32GB， 64GB，128GB，这里就需要我们稍微变动一下，这里通过代码实现，如下：
解决方案： 1. 获取Ram大小 //RAM内存大小, 返回1GB/2GB/3GB/4GB/8G/16G public static String getTotalRam(){ String path = "/proc/meminfo"; String ramMemorySize = null; int totalRam = 0 ; try{ FileReader fileReader = new FileReader(path); BufferedReader br = new BufferedReader(fileReader, 4096); ramMemorySize = br.readLine().split("\\s+")[1]; br.close(); }catch (Exception e){ e.printStackTrace(); } if(ramMemorySize != null){ totalRam = (int)Math.ceil((new Float(Float.valueOf(ramMemorySize) / (1024 * 1024)).doubleValue())); } return totalRam + "GB"; } 2.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a13d5c2437f1fe5cc4f43015c05f6aae/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e951ce506940b9999e944b7c971ae3d7/" rel="bookmark">
			oracle使用个人总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		oracle简单使用规则 1.简单查询逻辑：SELECT * FROM COMPLAINT_FROM
根据用户名排序（正序可默认或asc 倒叙desc）
2.正序语句：SELECT * FROM COMPLAINT_FROM order by id SELECT * FROM COMPLAINT_FROM order by id asc
3.倒叙语句：SELECT * FROM COMPLAINT_FROM order by id desc
4.条件语句查询
简单单条语句查询：SELECT * FROM COMPLAINT_FROM where CASE_STATUS='主诉'
模糊匹配语句查询：SELECT * FROM COMPLAINT_FROM where TYPES_OF_CASES like '%买卖%'
一般上不建议使用模糊查询，会影响性能，如果必须使用建议只后面加%，前面不加
5.获取20条数据
简单sql:SELECT * FROM COMPLAINT_FROM where rownum&lt;20
根据用户名倒叙获取20条数据
sql语句：select * from (SELECT * FROM COMPLAINT_FROM order by ENTRY_DATE desc)a where rownum&lt;20
6.合并同类项
select listagg(id,',') within group (order by id) col_name from COMPLAINT_FROM;
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b49d26efe05c2dd844a9ef6fb541342e/" rel="bookmark">
			there is no getter for property named 错误
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先 发一下报错的日志：
there is no getter for property named 'user_regtime' in 'class com.fmedu.fmmall.entity.user。
看到这句话 首先反应就是去看一下实体类中是不是忘记写get方法了，但是我在实体类中添加了两个注解分别是
@NoArgsConstructor @AllArgsConstructor 这两个注解分别代表无参和有参构造。
所以排除这个问题，冷静下来后我开始思考问题，从实体类、mapper文件中寻找错误，终于它来了：
&lt;insert id="insertUser"&gt; insert into users(username,password,user_img,user_regtime,user_modtime) values (#{username},#{password},#{userImg},#{user_regtime},#{user_modtime}) &lt;/insert&gt; 一个不该犯的小错误，复制快了，没有改过来! { "code": 10000, "msg": "注册成功！", "data": null } 算是大功告成，细节问题，哈哈。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7f626cbfd74da8a332dc2a19c3bcaea/" rel="bookmark">
			详细解决tomcat乱码 IDEA控制台乱码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、启动Tomcat时打印出一大堆看不懂的文字 如下图：
原因：产生乱码的根本原因就是编码和解码不一致
解决办法：将打开tomcat的安装目录conf下的logging.properties文件，将java.util.logging.ConsoleHandler.encoding = UTF-8
修改为：java.util.logging.ConsoleHandler.encoding = GBK
一般调整完这里，重新启动程序，淇℃伅 这种乱码就不会出现了。
如果打印台还有其他乱码，可进行下面的操作：
2、修改当前 Web 项目 Tomcat Server 的虚拟机输出选项
idea导航栏“Run→Edit Configurations…”进入配置页面，修改当前 Web 项目 Tomcat Server 的虚拟机输出选项 VM options 添加 -Dfile.encoding=UTF-8 。然后重启运行项目
3、修改 IntelliJ IDEA 全局编码、项目编码、属性文件编码
导航栏“File→Settings…”进入配置页面，在“Editor”中下滑找到“File Encodings”，分别将 Global Encoding、Project Encoding、Default encoding for properties files 都设置为 UTF-8。重启项目查看控制台打印。
4、直接修改 IntelliJ IDEA 配置文件的编码信息
打开 IntelliJ IDEA 在本地的安装目录，找到下面两个文件idea.exe.vmoptions，idea64.exe.vmoptions，在最后一行添加-Dfile.encoding=UTF-8 即可。在重启之后运行程序检查控制台信息
总结：上面总结了4 种方法完美解决 IntelliJ IDEA 控制台中文乱码问题，后面三种方法最好是修改之后重启 IntelliJ IDEA 使配置生效。这4种方法应该可以完美解决乱码问题，如果其他朋友有另外的解决方法，欢迎补充。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aab5733c8948a1456fb9f5e91e5079bd/" rel="bookmark">
			（pytorch进阶之路）五种归一化原理和实现
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 LN论文导读LN论文地址五种归一化Batch Normalization及实现Layer Normalization及实现Instance normalization及实现Group normalization及实现Weight normalization及实现 LN论文导读 BN优点：批归一化(BN)技巧是基于batch的训练样本的均值和方差对mini_batch输入进行归一化，能在前馈神经网络（FNN）中显著降低训练时间
BN缺点：批归一化依赖于batch大小，RNN中时间步骤是不确定的，通过训练，我可以确定下第1层或前几层的样本分布，但RNN可能会有N长度的时间片，出现测试样本长度大于训练的所有样本长度情况，往往长序列样本较少，越往后时间片BN越不好学习，计算的μ和σ就会非常不具有代表性
BN和LN不同点：BN训练和测试的行为表现是不一样，训练时BN用指数滑动平均（Weighted Moving Average）的方式不断地积累均值和方差（统计变量：moving average和moving variance），测试的时候使用最后一次采集得到滑动均值和方差作为归一化的统计量
而LN训练和测试行为表现是一样的，LN对单个样本的均值方差归一化，在循环神经网络中每个时间步骤可以看作是一层，LN可以单独在一个时间点做归一化，因此LN可以用在循环神经网络中
BN和LN相同点：LN和BN一样，LN也在归一化之后用了自适应的仿射变换（bias和gain）
内部协变问题：训练网络时候分布一直发生变化
BN公式：权重系数gain，统计变量均值μ和标准差σ，计算新的α_
一般样本集过大，公式确切的计算整个训练集不太现实，因此用经验估计μ和σ（指数滑动平均），batch越少误差越大
LN公式：对同一层的所有神经元做平均，假设这一层的神经元个数为H，对每个神经元α求和再平均，得到第L层所有神经元的均值，标准差也是一样的，对同一层的所有神经元计算公式σ
这样H个数是确定的，而BN的seqLen可能是不确定的
所有神经元共享同一套归一化参数，但是每个样本有各自的归一化参数
不同于批归一化，与mini_batch无关，只与神经元的个数有关，
共享参数是gain和bias
RNN中使用LN：re-center加一个偏置，re-scales乘一个系数
LN论文地址 https://arxiv.org/pdf/1607.06450.pdf
五种归一化 Batch Normalization及实现 BN是per channel across mini_batch，通过batch保持channel维度
[NLC] -&gt; [C]
[NCHW] -&gt; [C]
看一下pytorch官网的batchNorm1D作为例子，输入是x=[N,C,L]，batchNorm2D输入是[N,C,H,W]
torch.nn.BatchNorm1d类
torch.nn.BatchNorm1d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True, device=None, dtype=None)
num_features，表示输入张量的特征维度（embedding大小）
eps用于分母的数值稳定，防止分母为0
momentum，用于计算滑动平均和滑动方差，对于累积移动平均值（即简单平均值），可以设置为“None”，默认为0.1
affine，为True时做仿射变换（gain和bias）
track_running_stats为False时，不会记录历史的移动平均值
公式：
均值和标准差都是通过整个mini_batch对每个维度单独计算的，可学习向量是gama和β，标准差使用的是有偏估计（1/n）， 训练过程中会不断的记录历史的均值和方差，使用0.1的momentum做一个移动的估计，当我们训练结束之后用最后一个时刻的估计量做inference
调用API，传入emb_dim，为了方便验证关闭affine，传入的input的格式是[N,C,L]，输出格式也是[N,C,L]，我们习惯[N,L,C]，我们就转置一下
之后我们自己实现BN，使用torch.mean计算平均值，我们需要从batch维度和时间这个维度求通道的均值，所以dim=(0,1)，同时用torch.std注意是unbiased=False，是有偏估计
import torch batch_size, time_steps, emb_dim = 2, 3, 4 input_x = torch.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/aab5733c8948a1456fb9f5e91e5079bd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea2acaafcfd8a551009e28519797ca73/" rel="bookmark">
			UTM坐标系与GPS坐标系转换笔记
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 UTM坐标系代码示例参考资料 UTM坐标系 像橘子一样均匀地切成60个称为“区域”的部分，展平这些区域中的每个区域，通用横轴Mercator（UTM）投影；
可以这样看：UTM区域是地球的6°区域，因为圆具有360°，这意味着地球上有60个UTM区域。
如何读取UTM坐标
UTM 坐标中的第一个数字称为东距，第二个数字称为北距。
代码示例 用到的maven依赖 对应的开源库
&lt;!-- https://mvnrepository.com/artifact/org.locationtech.proj4j/proj4j --&gt; &lt;dependency&gt; &lt;groupId&gt;org.locationtech.proj4j&lt;/groupId&gt; &lt;artifactId&gt;proj4j&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt; &lt;/dependency&gt; 坐标转换示例代码
CRSFactory crsFactory = new CRSFactory(); CoordinateReferenceSystem WGS84 = crsFactory.createFromName("epsg:4326"); CoordinateReferenceSystem UTM = crsFactory.createFromName("epsg:32649");//32649 是对应中国福建省区域 CoordinateTransformFactory ctFactory = new CoordinateTransformFactory(); CoordinateTransform wgsToUtm = ctFactory.createTransform(WGS84, UTM); // `result` is an output parameter to `transform()` ProjCoordinate result = new ProjCoordinate(); //GPS经纬度 double lon = 118.143196; double lat = 24.505581; wgsToUtm.transform(new ProjCoordinate(lon, lat), result); System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ea2acaafcfd8a551009e28519797ca73/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/baa3d95f61bde3dbcdd4560bef3f8642/" rel="bookmark">
			【Javaweb 2】JSP,Filter,Listener,AJAX,Vue
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		🌈博客主页：屠一乐的博客
📅 发文时间：2022.08.10
🎈 一定存在只有你才能做成的事
🌹 博主水平有限，如有错误，欢迎指正
欢迎各位👍收藏💎评论✉
文章目录 JSPJSP快速入门JSP原理JSP脚本EL表达式JSTL标签JSTL标签 MVC模式三层架构案例 会话跟踪技术Cookie基本使用Session 登录注册案例记住用户 FilterFilter快速入门 ListenerAJAXAJAX快速入门Axios异步框架JSON VueVue快速入门Vue常用指令 ElementElement布局 JSP 概念：Java Server Pages,Java服务端页面
●一种动态的网页技术，其中既可以定义HTML、JS、CSS等静态内容，还可以定义Java代码的动态内容
●JSP = HTML + Java
JSP快速入门 1.导入JSP坐标
&lt;dependency&gt; &lt;groupld&gt;javax.servlet.jsp&lt;/groupld&gt; &lt;artifactld&gt;jsp-api&lt;/artifactld&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; 2.创建JSP文件
3.编写HTML标签和Java代码
&lt;body&gt; &lt;h1&gt;hello jsp~&lt;/h1&gt; &lt;System.out.printf("jsp hello");%&gt; &lt;/body&gt; JSP原理 JSP本质上就是一个Servlet
●JSP在被访问时，由JSP容器(Tomcat)将其转换为Java文件(Servlet),在由SR容器(Tomcat)将其编译，最终对外提供服务的其实就是这个字节码文件
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-EDqHAjLW-1660132880683)(D:\BRILIANT\Documents\图片\image-20220710110818047-16574224999491.png)]
JSP脚本 JSP脚本用于在JSP页面内定义Java代码
●JSP脚本分类：
1.&lt;%.%&gt;内容会直接放到jspService()方法之中
2.&lt;%=.%&gt;:内容会放到out.orint()中，作为out.print()的参数
3.&lt;%! %&gt;:内容会放到」jspService()方法之外，被类直接包含
JSP缺点
。由于JSP页面内，既可以定义HTML标签，又可以定义Java代码，造成了以下问题：
1.书写麻烦：特别是复杂的页面
2.阅读麻烦
3.复杂度高：运行需要依赖于各种环境JRE,JSP容器，JavaEE…
4.占内存和磁盘：JSP会自动生成.java和.class文件占磁盘，运行的是.class文件占内存
5.调试困难：出错后，需要找到自动生成的，java文件进行调试
6.不利于团队协作：前端人员不会Jva,后端人员不精HTML
7…
[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-7kSIxhP3-1660132880684)(D:\BRILIANT\Documents\图片\image-20220710113019499-16574238206182.png)]
EL表达式 Expression Language表达式语言，用于简化JSP页面内的Java代码
主要功能：获取数据
语法：${expression}
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/baa3d95f61bde3dbcdd4560bef3f8642/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9f1871e5ae9658640d2427ea90e5a693/" rel="bookmark">
			数论基础-整除（编程例题）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 编写程序求1000000内的所有素数. #include&lt;iostream&gt; #include&lt;iomanip&gt; using namespace std; int num[1000010]; bool isprimer(int n) { for (int i = 2; i * i &lt;= n; i++) { if (n % i == 0) return false; } return true; } void primer(int n) { for (int i = 2; i * i &lt;= n; i++) { if (isprimer(i)) { for (int j = 2*i; j &lt;= n; j += i) { num[j] = 1; } } } return; } void print(int n) { cout.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9f1871e5ae9658640d2427ea90e5a693/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/65ae0a3cc5091dce90f309460f56554b/" rel="bookmark">
			东方博宜OJ 1264 - 【入门】4位反序数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 题目描述 设N是一个四位数，它的9倍恰好是其反序数，求N。反序数就是将整数的数字倒过来形成的整数。例如：1234的反序数是4321。
输入： 无 输出： 输出N这个四位数 来源： 简单循环 标签： 简单循环 #include&lt;stdio.h&gt; using namespace std; int main() { int i,j,k,qw,bw,sw,gw; for(i=1000;i&lt;10000;i++) { qw=i/1000,bw=i%1000/100,sw=i%100/10,gw=i%10,j=gw*1000+sw*100+bw*10+qw; if(j==i*9) printf("%d",i); } return 0; } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7bc3635870a8632a2fa99e7a74368edb/" rel="bookmark">
			DNS服务器部署
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		系统：centos7.6
软件服务：AdGuardHome
内核版本：3.10.0-957.el7.x86_64
​AdGuard Home 是一款用于拦截广告和跟踪的全网络软件。设置后，它将覆盖您的所有家庭设备，您不需要任何客户端软件。
它作为 DNS 服务器运行，将跟踪域重新路由到“黑洞”，从而阻止您的设备连接到这些服务器。它基于我们用于公共AdGuard DNS服务器的软件，两者共享大量代码。 ​
注意：这边测试时，在centos7.2上运行不了，至于原因未找到，centos7.6和centos7.9都能正常运行。
git开源项目地址：https://github.com/AdguardTeam/AdGuardHome
一、下载安装脚本
wget https://raw.githubusercontent.com/AdguardTeam/AdGuardHome/master/scripts/install.sh 二、安装 AdGuardHome
sh install.sh 三、等待一段时间，检查安装情况
安装结果出来后，检查端口情况: netstat -untpl | grep 3000 四、访问网页，配置DNS服务配置
根据自己的情况配置相关的IP地址和端口，配置前要查看服务器的端口是否已被使用，防止端口冲突
配置账号和密码，密码配置之后不能更改了(有可能能更改，但我未找到)
这里先 下一步，后面再改路由器的东西指向这台服务器的DNS地址
五、登陆管理平台
六、配置日志保留时间，这里不需要保留那么长的时间
七、配置DNS设置 这里的空白处填写，可以在 已知DNS提供商列表 里面找到，然后填写上去，或者根据自己的地区和网络运营商进行填写，这个填写内容的作用是：这台DNS服务器没有的域名就会向这些填写的的服务器上查找相关的域名解析
这个也要改一下，不然会默认走的是路由器，路由器那边一改DNS地址，这边就会报错
点击 测试上游DNS 时，右下角会弹些信息出来，提示正常就点击应用
八、设置广告拦截
规则数出来了就代表更新成功了
九、配置自己的域名解析
十、更改路由器的DHCP服务，把获取DNS的地址改了，我这里用电脑代替了
十一、测试，域名都是由自己搭建的DNS服务器解析出来的，证明DNS服务器搭建的没有问题
十二、设置开启自启： systemctl enable AdGuardHome
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/b0127064942721e2d216006c1cb50b6d/" rel="bookmark">
			jls,jvms,java 语言规范，java虚拟机规范
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Java Language and Virtual Machine Specifications
jls,jvms
官方文档英文
官方下载地址：
https://docs.oracle.com/javase/specs/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dd3cd7c48f80c672b3d0abfa9ed3243e/" rel="bookmark">
			网站架构探测&amp;chrome插件用于信息收集
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 0x01 网站架构探测云悉潮汐指纹 0x02 chrome插件用于信息收集添加插件的方法官网添加方法开发者模式添加 Wappalyzer下载方法功能FOFA Pro view下载方法 ModHeader 0x01 网站架构探测 这部分的工具包括用于识别操作系统，编程语言，中间件及版本信息，数据库及版本信息，服务器及版本信息等。
云悉 http://www.yunsee.cn/
潮汐指纹 http://finger.tidesec.com/
0x02 chrome插件用于信息收集 很多好用的插件可以帮助收集信息过程更加顺利，插件是指在浏览器中起到补充作用的程序。
添加插件的方法 Chrome官网：
https://www.google.com/chrome/ Chrome商店（中文版）：
https://chrome.google.com/webstore/category/extensions?hl=zh-CN 官网添加方法 这里以Wappalyzer为例，直接在Chrome商店搜索Wappalyzer，点击“添加至Chrome”
点击“添加插件”
开发者模式添加 下载.crx后缀的插件文件，在设置中点击“扩展程序”
点击右上角开发者模式
之后直接将.crx文件拖进来就可以了。
Wappalyzer 下载方法 Chrome商店直接点击添加
Wappalyzer官网：
https://www.wappalyzer.com/ 功能 了解网站是用什么构建及使用的技术；创建自定义网站列表数据；监测网站；自动化技术查找，即时技术查询和网站实时抓取分析，快速查看结果等。 总的来说就是快速查询网站的指纹信息，查询出来的结果如下：
FOFA Pro view FOFA Pro view 是一款开源的FOFA Pro 资产展示浏览器插件，可以快速的查询网站的ip、开放端口、主机名、资产信息等。
下载方法 地址：
https://github.com/fofapro/fofa_view ModHeader ModHeader插件可以快速、高效的自定义HTTP请求头或者是重写响应头
添加、修改和删除请求和响应标头覆盖Chrome浏览器设置的请求头的默认值使用 ModHeader 设置 X-Forwarded-For、Authorization、Access-Control-Allow-Origin 等修改请求/响应标头中的 cookie用另一个重定向 URL通过 URL 启用标头修改按选项卡、选项卡组或窗口进行高级过滤 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ef531b7c5490cbcf7be571e9d63dca0f/" rel="bookmark">
			spinal HDL - 09 - 时序逻辑
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Registers 用 SpinalHDL 创建寄存器与用 VHDL 或 Verilog 创建寄存器非常不同。在SpinalHDL ，没有过程/总是阻塞。寄存器在声明中明确定义。这与传统的事件驱动 HDL 的区别有很大的影响:
您可以在相同的范围内分配寄存器和连接，这意味着代码不需要在进程/总是块之间分割。
它使一些事情更加灵活(参见函数)，并且时钟和重置是分开处理的。
实例化 有4种方法可以实例化一个寄存器:
Syntax语法Description描述Reg(type : Data)给定类型的寄存器RegInit(resetValue : Data)重置时使用给定的 resetValue加载的寄存器RegNext(nextValue : Data)寄存器采样给定的nextValue 每个周期RegNextWhen(nextValue : Data, cond : Bool)当条件发生时寄存器采样给定的 nextValue 下面是一个声明某些寄存器的例子:
// UInt register of 4 bits val reg1 = Reg(UInt(4 bit)) // Register that samples reg1 each cycle val reg2 = RegNext(reg1 + 1) // UInt register of 4 bits initialized with 0 when the reset occurs val reg3 = RegInit(U"
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ef531b7c5490cbcf7be571e9d63dca0f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e23a07ddedc1ca544a18a494c263c29/" rel="bookmark">
			2022-06-23 VGMP-OSPF-域间安全策略-NAT策略
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		本文章仅供学习和参考！
欢迎交流~
一、实验拓扑图： 二、实验配置： 1. 配置防火墙： （1）配置FW1
修改设备名称 sysname FW1 配置IP interface GigabitEthernet0/0/0 ip address 192.168.100.1 255.255.0.0 interface GigabitEthernet0/0/1 ip address 10.1.13.1 255.255.255.0 interface GigabitEthernet0/0/5 ip address 10.88.12.1 255.255.255.0 添加安全区域 firewall zone trust add interface GigabitEthernet0/0/0 add interface GigabitEthernet0/0/1 配置OSPF ospf 1 router-id 123.1.1.1 area 0.0.0.0 network 10.1.13.1 0.0.0.0 network 192.168.100.1 0.0.0.0 配置VRRP interface GigabitEthernet0/0/0	vrrp vrid 10 virtual-ip 192.168.10.254 16 master vrrp vrid 20 virtual-ip 192.168.20.254 16 slave vrrp vrid 30 virtual-ip 192.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e23a07ddedc1ca544a18a494c263c29/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8f7bd7368db9e376ae2b56a952b4334c/" rel="bookmark">
			HW-蓝队工作流程（1）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
0x01 护网简介
0x02 HW项目方案及流程
0x03 防守方交付工作内容
0x04 防守方案例
0x01 护网简介
护网行动攻防演习是以获取目标系统的最高权为目标，由多领域安全专家组成攻击队，在保障业务系统安全的前提下，直接在真实网络环境开展对抗，对参演单位目标系进行可控、可审计的网络安全实战攻击，通过攻防演习检验参演单位的安全防护和应急处置能力，提高网络安全的综合防控能力。
近几年我国相继举办了几次较大规模的护网行动，由多个行业单位和监管单位组织相关演习工作，通过实战网络攻击的形式检验我国关键信息基础设施安全防护和应急处置能力，取得了十分显著的效果，督促各单位有效提升了网络安全防护水平
hw组织架构
演习指挥小组：
由组织单位相关部门领导和技术专家组成，负责演习工作总体指挥和调度
演习工作小组：
由演习指挥小组指派专人构成，负责演习工作具体实施和保障
攻击组（红队）：
由参演单位及安全厂商攻击人员构成，负责对演习目标实施攻击
防守组（蓝队）：
由各个防护单位运维技术人员和安全运营人员组成，负责安全监测、应急处置等
技术支撑组：
由演习组织方指定工作人员组成，演习过程监控、基础环境保障（网络、攻防平台等）
组织保障组：
由演习组织方指定工作人员组成，在演习过程中协调和后勤保障相关事宜
0x02 HW项目方案及流程
演习流程
0x03 防守方交付工作内容
1️⃣典型攻击途径
2️⃣防守思路
①演练准备阶段
团队组建
● 角色及职能
隐患排查、安全加固
● 资产梳理
● 应急预案梳理
● 暴露面检查
● 账户检查
● 资产安全评估
● 入侵痕迹排查
● 泄露信息收集
● 安全意识培训
● 防护能力评估
防护措施落地
● 运维策略添加
● 安全设备部署
②演练开展阶段
根据攻击者入侵特征分析
● 扫描行为
● 破解行为
● 远程代码执行漏洞利用行为
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8f7bd7368db9e376ae2b56a952b4334c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ca77815a1725edd990a729a5198f0535/" rel="bookmark">
			RocketMq 封装工具类
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		application.yml
rocketmq: name-server: dev-mqsrv.icbf.plus:9876 producer: group: customerbasic-group-test-huang #目的地（topic:tag） #topic topic: customerbasic-topic-test-huang #sync tag(同步消息tag) sync-tag: anran-sync-tags #async tag(异步消息tag) async-tag: anran-async-tags #oneway tag(单向消息tag) oneway-tag: anran-oneway-tags #消费者配置 mq: consumer: group: customerbasic-group-test-huang #监听主题 topic: customerbasic-topic-test-huang RocketProducer 消息生产者（策略模式）
@Component public class RocketProducer { @Resource private RocketMQTemplate rocketMQTemplate; @Value("${rocketmq.producer.topic}") private String topic; public SendStatus sendMessage(String tag, Object body) { String top = topic; String uuid = IdUtil.randomUUID(); Message&lt;Object&gt; message = MessageBuilder.withPayload(body) .setHeader("KEYS", uuid) .setHeader("authUser", BaseUserUtil.getAuthUserNoThrows() == null ?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ca77815a1725edd990a729a5198f0535/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dec9e859aea4fb0d7e9419c328d6e4f3/" rel="bookmark">
			Tkinterfile
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		文章目录 案例1.辞职小软件案例2.记事本布局案例3：计算器案例4：图片查看器案例5 网络调试小工具案例7.选择文件，只显示指定格式xml解析测试UI代码面向对象写法封装2--按键切换页面修正切换页面 案例1.辞职小软件 import tkinter as tk from tkinter import messagebox from random import random root=tk.Tk() root.geometry('500x300+100+100') root.title('fef') frame1=tk.Frame(root) frame1.pack() tk.Label(frame1,text='尊敬的各位领导',font=24,padx=30,pady=30).pack(side=tk.LEFT,anchor=tk.N) img=tk.PhotoImage(file='t.png') label_img=tk.Label(frame1,image=img,padx=30,pady=30,bd=0) label_img.pack(side=tk.LEFT,anchor=tk.N) tk.Label(frame1,text='辞职人：正心',height=25,font=20,padx=30,pady=30,anchor=tk.S).pack(side=tk.LEFT) yes_img=img no_img=img yes_btn=tk.Button(frame1,text='yes',bd=0) no_btn=tk.Button(frame1,text='no',bd=0) yes_btn.place(relx=0.3,rely=0.8,anchor=tk.CENTER) no_btn.place(relx=0.7,rely=0.8,anchor=tk.CENTER) frame2=tk.Frame(root) # frame2.pack() tk.Label(frame2,text='ffsdfcdcaf',font=('黑体',18), justify=tk.LEFT, height=300, fg='red', padx=50).pack() tk.Button(frame2,text='exit',command=root.quit).place(relx=0.9,rely=0.8) def on_exit(): messagebox.showwarning(title='ff',message='此路不通') root.protocol('WM_DELETE_WINDOW',on_exit) def move(event): no_btn.place(relx=random(),rely=random(),anchor=tk.CENTER) no_btn.bind('&lt;Enter&gt;',move) def sure(): frame1.pack_forget() frame2.pack() yes_btn.config(command=sure) root.mainloop() 案例2.记事本布局 #记事本布局 import tkinter as tk root=tk.Tk() root.title('记事本') root.geometry('800x500+100+100') menu=tk.Menu(root,tearoff=False) file_menu=tk.Menu(menu,tearoff=False) file_menu.add_command(label='新建') file_menu.add_command(label='打开') file_menu.add_command(label='保存') file_menu.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/dec9e859aea4fb0d7e9419c328d6e4f3/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8981f40d131bd35ad9a50e6af7eadf39/" rel="bookmark">
			Tomcat内存马学习5：Agent型
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		利用java-agent修改jvm中已经加载的类比如（org/apache/catalina/core/ApplicationFilterChain#doFilter）来达到注入内存马的目的
具体点来说就是通过VirtualMachine 类的 attach(pid) 方法，可以连接到一个运行中的 java 进程上之后便可以通过 loadAgent(agentJarPath) 来将恶意agent 的 jar 包注入到对应的进程，然后对应的进程会调用agentmain方法，这个方法会遍历所有的已加载类并找到我们需要的类，修改其字节码从而达到注入内存马目的
agent.jar（需要上传到对方服务器）
//AgentMain import java.lang.instrument.Instrumentation; public class AgentMain { public static final String ClassName = "org.apache.catalina.core.ApplicationFilterChain"; public static void agentmain(String agentArgs, Instrumentation ins) { ins.addTransformer(new DefineTransformer(),true); // 获取所有已加载的类 Class[] classes = ins.getAllLoadedClasses(); for (Class clas:classes){ if (clas.getName().equals(ClassName)){ try{ // 找到ClassName类，对其重新定义，此时会调用DefineTransformer#transform ins.retransformClasses(new Class[]{clas}); } catch (Exception e){ e.printStackTrace(); } } } } } //DefineTransformer import javassist.ClassPool; import javassist.CtClass; import javassist.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8981f40d131bd35ad9a50e6af7eadf39/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ddb3fd9761433da27333c5d9cc0a3666/" rel="bookmark">
			机器学习算法——聚类2（距离计算）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		距离度量需要满足以下性质：
非负性：
同一性：当且仅当
对称性：
直递性：
给定样本与，最常用的是“闵可夫斯基距离”（Minkowski distance）：
当p=2时，闵可夫斯基距离即欧氏距离（Euclidean distance）
当p=1时，闵可夫斯基距离即曼哈顿距离（Manhattan distance）
我们常将属性划分为“连续属性”和“离散属性”。前者在定义域上有无穷多个可能的取值，后者在定义域上是有限个取值。然而，在讨论距离计算时，属性是否定义了“序”关系更为重要。例如，
定义域为{1，2，3}能直接在属性值上计算距离：“1”与“2”比较接近，与“3”比较远，这样的属性称为“有序属性”。而定义域为{飞机，火车，轮船}这样的离散属性不能直接在属性值上计算距离，称为“无序属性”。显然，闵可夫斯基距离可用于有序属性。
对于无序属性，可采用VDM(Value Difference Metric)。令表示在属性u上取值为a的样本数，表示在第i个样本簇中在属性u上取值为a的样本数，k为样本簇数，则属性u上两个离散值a与b之间的VDM距离为：
将闵可夫斯基距离和VDM结合可处理混合属性，假定有个有序属性，个无序属性，不失一般性，令有序属性排列在无序属性之前，则：
当样本空间中不同属性的重要性不同时，可使用“加权距离”，以加权闵可夫斯基距离为例：
其中权重表征不同属性的重要性，通常
通常我们是基于某种形式的距离来定义“相似度度量”，距离越大，相似度越小。然而，用于相似度度量的距离未必一定满足距离度量的所有基本性质，尤其是直递性。这样的距离称为“非度量距离”。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3769601a436cdb84e0f1945b4ce04a2/" rel="bookmark">
			云服务器搭建深度学习环境
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		最近配置一个深度学习的服务器，折腾了大半天，每次弄的时候都得去网上找，于是乎想自己记录一下，方便以后再次使用，由于使在网上找了好多个教程而且每个教程的方法都不一样，最开始弄的自己稀里糊涂的，不过后来只跟着其中两个教程就好了，还有一个就是我没有安装CUDNN就能够调用GPU，我不知道这是什么原因，先给自己挖个坑，如果以后找到原因了或者是不安装CUDNN不能进行深度学习的话就过来填坑
以我自己为例，省略前面购买和ssh连接的过程，实例是Ubuntu 18.04 + GPU Telsa T4
安装的是CUDA11.7.1和pytorch1.12.1
目录 GPU驱动安装方法一方法二 CUDA安装安装Anaconda安装pytorch GPU驱动安装 方法一 在英伟达驱动下载页面设置自己的配置，之后点击“SEARCH”，之后点击“DOWNLOAD”，再然后，右键“AGREE$DOWNLOAD”，复制链接地址
返回服务器命令行，输入wget 地址
此处是
wget https://us.download.nvidia.com/tesla/515.65.01/NVIDIA-Linux-x86_64-515.65.01.run 下载完成后，执行以下代码安装驱动
sudo chmod a+x NVIDIA-Linux-x86_64-515.65.01.run sudo ./NVIDAI-Linux-x86_64-515.65.01.run -no-nouveau-x-check -no-opengl-files 注意：这里的版本一定要一致，即我这里的示例是 515.65.01
方法二 直接执行以下命令（前提是你要知道安装的驱动版本是适合你的服务器内核版本的）
sudo apt-get install nvidia-driver-515-server nvidia-settings nvidia-prime 因为我其实之前已经安装过了515.65.01版本的，所以我知道这个版本是可行的
然后需要重启
sudo reboot 至于如何查看可用的驱动版本，这里有一个命令，但是我自己的服务器没有成功
ubuntu-drivers devices 以及查看本机内核版本号
cat /proc/driver/nvidia/version 再使用nvidia-smi命令出现以下界面就发现驱动安装成功了
CUDA安装 一定记得对应版本，这里我们安装的是11.7.01
去CUDA逛网查看安装版本，其实官方给了好几个安装的方法，我这里使用的是“runfile(local)”方法
顺序输入以下两条命令
wget https://developer.download.nvidia.com/compute/cuda/11.7.1/local_installers/cuda_11.7.1_515.65.01_linux.run sudo sh cuda_11.7.1_515.65.01_linux.run 安装完成后出现以下界面则表示安装成功
在这里之后，还需要配置变量环境才行
vim ~/.bashrc 然后在末尾加入以下指令
export PATH=/usr/local/cuda/bin:$PATH export LD_LIBRARY_PATH=/usr/local/cuda/lib64:$LD_LIBRARY_PATH 若环境变量没有生效，可使用
source ~/.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3769601a436cdb84e0f1945b4ce04a2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/7d638075df1c58d7223ca5f756df034f/" rel="bookmark">
			关于ffmpeg的硬解码
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 参考文章
FFmpeg 4.x 从入门到精通（二）—— QT 中用 FFmpeg 实现硬解码并使用QImage显示_q2nAmor的博客-CSDN博客_av_hwdevice_ctx_create 2.环境
Qt + ffmpeg + cuda 下载ffmpeg431，因为网上现版本初入较难，我用的是先前前辈的库等内容
bin文件下内容：
include文件下内容
lib文件下内容
3.代码功能：打开H264编码格式的.mp4文件，通过硬件设备对MP4文件进行转码。即不占用CPU资源的情况下解析视频
1）.pro工程文件需要识别库
$$PWD代表当前工程（.pro）所在的路径
INCLUDEPATH += $$PWD/ffmpeg/include LIBS += $$PWD/ffmpeg/lib/avcodec.lib \ $$PWD/ffmpeg/lib/avdevice.lib \ $$PWD/ffmpeg/lib/avfilter.lib \ $$PWD/ffmpeg/lib/avformat.lib \ $$PWD/ffmpeg/lib/avutil.lib \ $$PWD/ffmpeg/lib/postproc.lib \ $$PWD/ffmpeg/lib/swresample.lib \ $$PWD/ffmpeg/lib/swscale.lib ###################链接动态库 # -L表示路径 -l（小写的L）表示动态库名 LIBS += -L$$PWD/ffmpeg/bin -lavcodec-58 LIBS += -L$$PWD/ffmpeg/bin -lavdevice-58 LIBS += -L$$PWD/ffmpeg/bin -lavformat-58 LIBS += -L$$PWD/ffmpeg/bin -lpostproc-55 LIBS += -L$$PWD/ffmpeg/bin -lswresample-3 LIBS += -L$$PWD/ffmpeg/bin -lswscale-5 2）main.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/7d638075df1c58d7223ca5f756df034f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/f8012da3742aad804e0f6d6d1cebfc93/" rel="bookmark">
			jenkins安装和配置(二):配置第一个项目
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、部署说明 将git clone代码到本地，用maven编译，打包成jar包，利用Dockerfile构建镜像的这一过程在jenkins上参数化，脚本化 二、安装maven环境 管理jenkins--&gt;全局工具配置--&gt;Maven选项--&gt;新增maven--&gt;选择版本，勾选自动安装--&gt;点击保存
那这些在什么时候才真正的安装了呢？
是在初次使用到JDK或Maven的时候，才会去自动安装。
实践，并没有自动安装
ubuntu20.04手动安装maven
apt update
apt install -y maven 会自动设置全局变量，安装jenkins的时候安装过JDK了
root@cn-office-tonytest-jenkins:~# mvn -v Apache Maven 3.6.3 Maven home: /usr/share/maven 本地Maven使用私服 安装和配置好之后，在开发中如何使用呢。可在maven的默认配置settings.xml中修改。
发布自己的jar到私服 如果要发布自己的jar到私服，就需要修改工程的pom.xml，添加如下内容：
&lt;distributionManagement&gt; &lt;repository&gt; &lt;id&gt;releases&lt;/id&gt; &lt;name&gt;Releases&lt;/name&gt; &lt;url&gt;http://192.168.60.231:8081/repository/maven-releases/&lt;/url&gt; &lt;/repository&gt; &lt;snapshotRepository&gt; &lt;id&gt;snapshots&lt;/id&gt; &lt;name&gt;Snapshot&lt;/name&gt; &lt;url&gt;http://192.168.60.231:8081/repository/maven-snapshots/&lt;/url&gt; &lt;/snapshotRepository&gt; &lt;/distributionManagement&gt; 同时
拷贝/usr/share/maven/conf/settings.xml到/var/lib/jenkins/.m2/这个目录下，并添加nexus的用户名和密码
&lt;servers&gt; &lt;server&gt; &lt;id&gt;maven-proxy&lt;/id&gt; &lt;username&gt;nexus&lt;/username&gt; &lt;password&gt;Nginx801&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;leanwork-thirdparty&lt;/id&gt; &lt;username&gt;nexus&lt;/username&gt; &lt;password&gt;Nginx801&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;nexus-release&lt;/id&gt; &lt;username&gt;nexus&lt;/username&gt; &lt;password&gt;Nginx801&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;nexus-snapshot&lt;/id&gt; &lt;username&gt;nexus&lt;/username&gt; &lt;password&gt;Nginx801&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; 注意上面的repository的id值一定要跟settings.xml文件中配置的server一致。
三、jenkins配置第一个JAVA项目 安装插件Git Parameter
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/f8012da3742aad804e0f6d6d1cebfc93/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/88c5352c6e8650dd647cfb29b5db829a/" rel="bookmark">
			ceres错误 (Jets)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“void std::vector&lt;T,std::allocator&lt;_Ty&gt;&gt;::push_back(_Ty &amp;&amp;)”: 无法将参数 1 从“const _Ty”转换为“const _Ty &amp;” robot_auto_machine_track d:\code\robot_auto_machine_track\robot_auto_machine_track\robot_six_angle.cpp 21 在ceres使用代价函数时，出现该错误，要保持loss中数据类型为模板类型（Jets）要将所有类型转化为Jets类型，可以操作
double data; T Tdata=T(data); T(data)
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ee2045a2dcf9b3bbead69b73d9e74679/" rel="bookmark">
			MindSpore GPU异构算子全流程开发指导
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Tips ① 此文档详细介绍了MindSpore GPU异构算子开发流程，与官方文档相比本文档更加侧重于开发文件的解读以及常用开发方法的讲解。同时本文档用词相对简单，主要帮助大家了解GPU算子开发需要写什么，各种文件的作用是什么以及应该怎么写这些文件，而官方文档中则更偏向于基础概念和框架的介绍，建议大家将两个文档结合起来阅读，这样更能够加深理解。 ② 本文篇幅较长，如果有自己熟悉的内容可以直接跳过，但是建议大家能够仔细阅读第三章，充分了解GPU算子需要开发哪些文件、每个开发文件的作用以及常用的方法，这样可以更快的入门，开始开发算子。 ③ MindSpore GPU异构算子调用流程如下 ④ 此文档也有网页版：GPU异构算子全流程开发指导-云社区-华为云，大家愿意的话可以支持一下，刷一刷阅读量。 ⑤ 本文主要为前期准备和开发流程，附加了两个关于接口文档测试的内容，后续进入测试阶段我也会写一个GPU算子测试指导。 ⑥ 如有遗漏或错误，欢迎指出与修改。 常用网址 ① GPU 算子全流程开发指导录屏 ② BartlettWindow 算子 PR ③ MindSpore 算子 Issue 查询网址 ④ MindSpore 官方安装网址 ⑤ MindSpore 官方算子查询网址 ⑥ 谭升 -GPU 编程 一、 环境配置 1. 连接服务器 （1） ssh跳转连接 使用服务器链接软件在同一个连接会话中，依次连续输入以下命令：
① 跳转服务器1：
ssh jump@xxx.xxx.xxx.xxx passwd: xxxxxxxx
② 跳转服务器2：
ssh test@xxx.xxx.xxx.xxx passwd: xxxxxxxx
③ GPU算子服务器：
ssh user14@xxx.xxx.xxx.xxx -p xxxx pwd:xxxxxxxx
输入ls，到达此界面即为连接成功！
（2） VPN连接方法 ① 点击右下角网络（WiFi那个标识），点击网络和Internet设置。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ee2045a2dcf9b3bbead69b73d9e74679/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3adb7bcb3deb724c8d13f0ad22992cc8/" rel="bookmark">
			Flutter个推推送Android端,退出应用后收到消息报错
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景(Android手机,iOS没有测试) 1.集成getuiflut
2.返回退出APP
3.发送推送透传消息
报错 Tried to send a platform message to Flutter, but FlutterJNI was detached from native C++. Could not send . Channel: getuiflut Response ID: XXX
解决方案 1.重写返回键,使其不退出APP只是让APP进入后台等待 插件类MoveTaskChannel:
class MoveTaskChannel { static const String channel = 'move_task'; static const MethodChannel _methodChannel = MethodChannel(channel); static void moveTaskBack() async { await _methodChannel.invokeMethod('moveTaskBack'); } } Android端MainActivity:
override fun configureFlutterEngine(flutterEngine: FlutterEngine) { GeneratedPluginRegistrant.registerWith(flutterEngine) MethodChannel(flutterEngine.dartExecutor, "move_task").setMethodCallHandler { methodCall, result -&gt; if (methodCall.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3adb7bcb3deb724c8d13f0ad22992cc8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/847dccfd5d0ce58e44180efef04ed7c7/" rel="bookmark">
			STM32F103驱动HCSR04超声波测距显示
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		STM32F103驱动HCSR04超声波测距显示 目录超声波模块介绍①实物图②产品说明③电气参数④超声波工作原理 驱动代码①STM32配置初始化代码①超声波驱动应用代码②超声波距离计算代码 具体测试现象总结 目录 超声波模块介绍 超声波模块在电子DIY作品中实现小车避障测距等方面均应用广泛，在大学生智能车DIY爱好者中尤为显眼。
①实物图 点击图片购买 ②产品说明 HC-SR04超声波测距模块可提供2cm-400cm的非接触式距离感测功能，测距精度可达3mm，包括发射器、接收器与控制电路，它是一种压电式传感器，利用电致伸缩现象而制成。
③电气参数 电气参数HCSR04超声波模块工作电压DC5V工作电流15mA工作频率40KHz最远射程4M最近射程2cm测量角度15°输入触发信号10us的TTL脉冲输出回响信号输出TTL电平信号，与射程成比例 ④超声波工作原理 首先我们可以看下面的一张超声波的时序图：
图中我们可以大致看出，要使用HCSR04这个超声波模组，我们必须先给超声波发送一个触发信号，引导超声波内部循环发出8个40Khz的脉冲然后输出回响信号引脚上拉为高电平，然后我们利用超声波回响信号引脚的高电平所得计数时间经过相关运算就可以得到对应的距离，具体公式如下：
测试距离 = （高电平时间声速（340M/S）/2）= ((float)t/58.0)
这个公式的具体换算过程，大家可以用以前学过的知识进行还算下，最后得到的距离单位是厘米。
下面放一张超声波的引脚功能示意图，能更好的理解HCSR04的具体使用和接线在代码中：
驱动代码 之前写过用51单片机驱动HCSR04在LCD1602上的驱动代码，这篇文章我使用STM32驱动HCSR04在0.96OLED（使用人数较多并且开源初始化代码方便移植）上面使用的驱动代码。
①STM32配置初始化代码 时钟和GPIO以及中断相关配置：
void HCSR04_Init(void) { TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure; //定义定时器结构体 GPIO_InitTypeDef GPIO_InitStructure; RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); //IO 初始化 GPIO_InitStructure.GPIO_Pin = HCSR04_TRIG; //发送高点平引脚 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	//推挽输出 GPIO_Init(HCSR04_PORT, &amp;GPIO_InitStructure); GPIO_ResetBits(HCSR04_PORT,HCSR04_TRIG); GPIO_InitStructure.GPIO_Pin = HCSR04_ECHO; //返回电平引脚 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPD;	GPIO_Init(HCSR04_PORT, &amp;GPIO_InitStructure); GPIO_ResetBits(HCSR04_PORT,HCSR04_ECHO);	//定时器初始化使用基本定时器3 RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //打开TIM3定时器时钟 TIM_DeInit(TIM3); TIM_TimeBaseStructure.TIM_Period = 65535; //(1000-1); //设置在下一个更新时间装入活动的自动重装载寄存器周期的值 计数到1000为1ms TIM_TimeBaseStructure.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/847dccfd5d0ce58e44180efef04ed7c7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a551b5e2ea9a4856e6642e7822743c8/" rel="bookmark">
			由纯CSS饼图、stroke-dasharray引出的Firefox对CSS变量运算兼容的问题
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我是一名刚开始接触前端（甚至刚开始接触编程）的菜鸟，以前是做平面设计的，说得有问题的话请多包涵。
这篇文章记录一下我发现的一个小问题。
这几天在做一个饼图的内容，想要实现的效果大概就是一个这样的环形：
选择的方案是用SVG绘制圆形（circle），然后通过stroke-dasharray来控制显示部分。之前考虑过计算锚点位置直接用path来绘制，但是有点复杂，就选择了这种方式。
先简单介绍下stroke-dasharray画饼图的方法。
简单来说，stroke-dasharray是用来将svg图形的描边以虚线呈现的属性，其实线和空格的长度值是会头尾相接自动循环的，而第一个值是第一段实线的长度，第二个值是第一段空格的长度。那么，只要先计算出周长，然后将周长按比例分为两个长度，分别设置为stroke-dasharray的第一个值和第二个值，这样整个周长上虚线会被恰好循环1次，即可呈现出饼图的效果。不光环状的，扇形的其实也可以做到，可以通过stroke-width来控制。
如果是多段饼，用stroke-dashoffset或者transform:rotate()控制有点太复杂了。我的思路是直接在同一位置叠多个circle，最底层是一个整环，往上逐级递减，效果是一样的：
调整各层半径和stroke-width，还可以做出叠层的效果（类似行星环），这里不细说了。
理论存在，接下来就是实践了。
于是我尝试了比较简单的写法，也就是在CSS的:root里定义了一系列的相关变量和运算法则（下面大概示意一下我的做法，不是原代码）。
:root{ --inputnum:1; --inputtotal:1; --array1:calc(3.1415926 * 2 * var(--inputnum) / var(--inputtotal)); --array2:calc(3.1415926 * 2 - var(array2)); --array:var(--array1),var(--array2); } 其中“2”是圆的直径。
接下来就是用js控制其中的元变量。我是自己定义了一个函数来方便地变更CSS的变量。
function dd(key,string){document.documentElement.style.setProperty(key,string);} 然后直接dd("--inputnum",xx)就行了。
最后&lt;circle stroke-dasharray="var(--array)"/&gt;即可。
哦对，默认情况下绘制应该是从3点方向开始的，如果想要实线部分从12点钟方向开始绘制，需要transform:rotate(-90deg)来逆时针旋转90度。也可以用stroke-dashoffset，但我觉得这个逻辑上简单太多了。
这套方法在Chrome和Safari上完美运行，所以我一开始没有急着做兼容测试就写别的内容去了。结果当晚测试的时候发现Firefox无论是PC端还是移动端都无法正常显示，整段都是实线。
然后抓狂的一晚上开始了。
一开始我以为是stroke-width的问题，因为看到有说法说Firefox在绘制的时候会除掉stroke-width，但我将SVG的viewbox缩小，减小半径，将stroke-width改为1之后，仍然是其他浏览器都没问题，唯独Firefox不行。
然后我尝试将stroke-dasharray写到style里而不是作为circle的一个属性，依然无效。
在搜遍整个互联网都没有找到满意的答案后，我突然想到，会不会是CSS变量的问题？
于是我检查了Firefox调试界面的CSS变量，发现确实读不出来值。当时我考虑是不是Firefox不支持calc()对CSS变量的运算？但这显然不对，因为我前面用到颜色的计算，也是采用的类似方式。
--r:0; --g:100; --b:170; --c0:rgb(var(--r),var(--g),var(--b)); --c1:rgb(calc(var(--r) * 0.6),calc(var(--g) * 0.6),calc(var(--b) * 0.6)); 类似这样的运算在任何主流浏览器上都没有兼容性问题。
同样，这也不太可能是多个变量合并为一个变量的问题，比如上面这段代码中的--c0，跟--array的格式几乎一模一样！
--array:var(--array1),var(--array2); 等下，真的是这样吗？
最后我发现，Firefox还真就是对--array这样的格式不支持。而且并不是不支持公式的嵌套（二次运算）而是不支持这个特定格式，因为我将svg部分改为：
&lt;circle stroke-dasharray="var(--array1),var(--array2)"/&gt; 在Firefox下同样是无效的（而其他浏览器都没有问题）。
总结起来就是，Firefox可能无法处理没有外括号并且用逗号分隔的两个CSS变量的组合。当然我并没有在其他属性上测试，所以也可能只是对stroke-dasharray属性存在这种情况。有时间我会测试一下其他类似属性的结果。
最后我只好改为用DOM方式来控制stroke-dasharry属性，这个我就不细说了~
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/53580e111edd7762011d027191820b0e/" rel="bookmark">
			XY的小伙伴你好_TAPD(2022.7版本)测试日报发送
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		# --*--coding:utf-8--*-- # updateDate = 2022/08/09 # 已离职，图表联系刘超、李一鸣调整 import copy import json import webbrowser # 打开网页 import random from faker import Faker import gevent from gevent import monkey monkey.patch_all() import requests from requests import exceptions import re import sqlite3 import datetime import math import numpy as np import matplotlib.pyplot as plt from matplotlib.pyplot import MultipleLocator import smtplib from email.mime.text import MIMEText from email.mime.multipart import MIMEMultipart from email.mime.image import MIMEImage import os from chinese_calendar import is_workday, is_holiday, get_dates, get_workdays, find_workday import configparser import PySimpleGUI as sg from email.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/53580e111edd7762011d027191820b0e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1804649e49dd47151299768a79c2c5eb/" rel="bookmark">
			Java中ExecutorService线程池的使用(Runnable和Callable多线程实现)
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		场景 线程的创建和释放，需要占用不小的内存和资源。如果每次需要使用线程时，都new 一个Thread的话，难免会造成资源的浪费，
而且可以无限制创建，之间相互竞争，会导致过多占用系统资源导致系统瘫痪。
不利于扩展，比如如定时执行、定期执行、线程中断，所以很有必要了解下ExecutorService的使用。
ExecutorService是Java提供的线程池，也就是说，每次我们需要使用线程的时候，可以通过ExecutorService获得线程。
它可以有效控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞，
同时提供定时执行、定期执行、单线程、并发数控制等功能，也不用使用TimerTask了。
线程池的目的是降低系统的开销，因为在高并发的场景下频繁的创建和销毁线程会降低程序的性能，有了线程池，线程就可以
实现复用，这样就可以减少线程的创建和销毁。
API文档 ExecutorService (Java Platform SE 8 )
注：
博客：
霸道流氓气质的博客_CSDN博客-C#,架构之路,SpringBoot领域博主
关注公众号
霸道的程序猿
获取编程相关电子书、教程推送与免费下载。
实现 1、ExecutorService的创建方式
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) 参数说明
corePoolSize : 核心线程数，一旦创建将不会再释放。如果创建的线程数还没有达到指定的核心线程数量，将会继续创建新的核心线程，直到达到最大核心线程数后，核心线程数将不在增加；如果没有空闲的核心线程，同时又未达到最大线程数，则将继续创建非核心线程；如果核心线程数等于最大线程数，则当核心线程都处于激活状态时，任务将被挂起，等待空闲线程来执行。
maximumPoolSize : 最大线程数，允许创建的最大线程数量。如果最大线程数等于核心线程数，则无法创建非核心线程；如果非核心线程处于空闲时，超过设置的空闲时间，则将被回收，释放占用的资源。
keepAliveTime : 也就是当线程空闲时，所允许保存的最大时间，超过这个时间，线程将被释放销毁，但只针对于非核心线程。
unit : 时间单位，TimeUnit.SECONDS等。
workQueue : 任务队列，存储暂时无法执行的任务，等待空闲线程来执行任务。
threadFactory : 线程工程，用于创建线程。
handler : 当线程边界和队列容量已经达到最大时，用于处理阻塞时的程序
线程池有多种类型，一般常用的是固定线程数线程池newFixedThreadPool，创建方式：
ExecutorService executorService = Executors.newFixedThreadPool(5);
这里配置线程数为5。具体数量根据自己的业务需求配置。
2、线程池的使用步骤
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/1804649e49dd47151299768a79c2c5eb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/671275e669446bb497193d0ec8adaa3e/" rel="bookmark">
			【java】对象流
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		对象流 使用DataInputStream或者DataOutputStream可以读写对象数据，但是操作比较繁琐
//从文件中按照id值查找对应的对象 int id=dis.readInt(); //用户id--用户标识 int len=dis.readInt(); //用户名称的字符数 StringBuilder username=new StringBuilder(); //用户名称 for(int i=0;i&lt;len;i++) //一次读取一个字符，然后拼接成完整的字符串 username.append(dis.readChar()); len=dis.readInt(); StringBuilder password=new StringBuilder(); //用户口令 for(int i=0;i&lt;len;i++) password.append(dis.readChar()); double balance=dis.readDouble(); //用户余额 if(dis==id){ res=new Account(); //Account是一个自定义类型，用于封装账户信息 res.setUsername(username.toString()); res.setPassword(password.toString()); res.setBalance(balance); break; } SUN提供了ObjectInputStream/ObjectOutputStream可以直接将Object写入或读出
这里实际上还有针对8种简单类型及其包装类的操作方法，以及针对String类型的操作方法
readObject():ObjectwriteObject(Object):void //简单写法，应该使用try/finally结构或者使用try/resource的写法 Date now=new Date(); ObjectOutputStream oos=new ObjectOutputStream( new BufferedOutputStream(new FileOutputStream("data3.txt"))); oos.writeObject(now); oos.close(); ObjectInputStream ois=new ObjectInputStream( new BufferedInputStream(new FileInputStream("data3.txt"))); Object obj=ois.readObject(); if(obj!=null &amp;&amp; obj instanceof Date) { Date dd=(Date)obj; System.out.println(dd); } ois.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/671275e669446bb497193d0ec8adaa3e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e4ce1a3a48e79675052aca5c8375725b/" rel="bookmark">
			Python时间处理
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在这里想做一个初学者的教程，会不断的更新下去，把学到的有关Python时间处理的内容总结起来。初学者笔记最重要的有两点，一个是要简洁，不要长篇大论，把要点讲明白就行，第二个是要符合二八原则，尽量抓住关键的东西，不要过分的追求大而全，优先掌握关键的20%内容就很可以了。
time模块 Python时间处理，绕不过去的就是time模块，虽然这个模块用来做时间处理并不是很便捷，但是作为Python的内置模块，还是需要掌握基本的用法的。
学习时间处理，我们首先要理解，什么是时间？
关于时间的概念，简单来说，分为两个意思，时刻和时长。时刻就是时间坐标轴上的一个点，时长是一个线段。
time模块是基本用法是用来处理时刻的，在time模块中，时刻有3种表示方式
时间戳（timestamp），是从1970年1月1日零时刻开始的一个秒数。时间元组（time tuple），是time模块中，用整数组合来表示时刻的方法。格式化字符串（format string），就是我们日常的用字符串表示一个时刻，例如“2021-01-01 10:00:00”。 明确这3个概念，然后就可以学习time模块的几个基本的方法。
time.time()
返回一个浮点数，获取当前时间戳。
time.mktime(arg)
接收一个时间元组参数，返回对应的时间戳。
time.localtime(arg)
接收一个时间戳参数，返回对应的时间元组对象。不带参数，返回当前时刻对应的时间元组对象。
time.strftime(format_string,struct_time)
format_string表示一个格式化字符串的表示方式，用%Y表示4位年份，%m表示月，%d表示日，%H表示时，%M表示分，%S表示秒。通过不同的组合，来表示想要的字符串格式，例如使用"%Y-%m-%d %H:%M:%S"来表示"2021-01-01 10:00:00"这种格式，使用"%Y年%m月%d日"来表示"2021年1月1日"这种格式。
struct_time是一个时间元组。整个方法就是把一个时间元组按照指定格式，返回一个字符串。不带struct_time参数的时候，默认指当前时刻。
time.strptime(time_string,format_string)
将一个时间字符串转化成对应的时间元组。time_string和format_string要格式对应才能正确转换。
time.sleep(n)
这个方法，让当前线程沉睡（挂起）n秒。
简单总结一下，我感觉time模块掌握这6个方法就够了。time.time和time.sleep单独记，time.mktime和time.localtime是时间戳和时间元组的相互转换，time.strftime和time.strptime是字符串和时间元组的相互转换。
最后补充一个内容，就是时间元组对象struct_time对象的使用。struct_time对象可以简单理解为(tm_year, tm_mon, tm_mday, tm_hour, tm_min, tm_sec, tm_wday, tm_yday, tm_isdst)这样一个包含9个元素的元组。可以使用元组下标的方式获取元素的值，也可以使用obj.tm_year属性的方式获取指定的值。
datetime模块 相比time模块，datetime模块在使用起来更方便，也更常用。
使用datetime模块，学会使用其中的datetime类和timedelta类就足够了。
datetime类 datetime类是datetime模块中表示日期时间的类，还有两个date类和time类，用法大同小异，不用单独学习。
导入使用： from datetime import datetime
学习一个类的使用，一般从两个方面，一是实例对象的创建，二是对象的属性和方法。
datetime类实例对象的创建
dt = datetime(year,month,day,hour,minute,second)
通过构造函数指定具体的数值来创建，以上参数默认值都是0.
dt = datetime.today() 或者 dt = datetime.now()
获取当前时刻的dt对象。
dt = datetime.fromisoformat(string)
通过string='2021-01-01 10:30:00'标准格式获取dt对象。
dt = datetime.fromtimestamp(n)
通过指定一个时间戳来创建。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e4ce1a3a48e79675052aca5c8375725b/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/71055518dc75c586e42b98df96f5b2a1/" rel="bookmark">
			【FAQ】【Push Kit】 华为怎么设置角标
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【问题描述】
HMS Core Push 怎么设置角标？角标设置不成功如何去排查问题？
【问题解答】
华为推送怎么设置角标？
1、消息体设置
我们可以参考桌面角标这一篇文档进行设置角标
2、端测开发
我们可以参考华为桌面角标开发指导书这一篇文档进行开发
角标设置不成功如何去排查问题？
1）消息体设置
我们参考 受限说明的set_num和add_nun的EMUI和推送服务的版本限制
EMUI的查看方法（设置==&gt;关于手机==&gt;查看EMUI的版本）
推送服务版本的查看（设置==》应用和服务==》应用管理==》推送服务==》查看版本）
2）端测开发
端侧开发需要查看如下几个条件
系统版本：EMUI4.1 及以上
桌面版本：6.3.29
支持设备：华为设备
EMUI的查看方法（设置==&gt;关于手机==&gt;查看EMUI的版本）
桌面版本(设置==》应用和服务==》应用管理==》华为桌面==》查看桌面版本)
如果你还是排查不到问题的话，新建一个demo按照华为桌面角标开发指导书文章重新开发一遍，有可能别的业务存在影响到桌面角标功能失效
欲了解更多更全技术文章，欢迎访问https://developer.huawei.com/consumer/cn/forum/?ha_source=zzh
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5ed6c502ecc19180868c98c932e6e6ef/" rel="bookmark">
			C&#43;&#43;回顾（数组&#43;指针）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.数组 回顾一维数组与二维数组的相关知识，练习了几道题目。
1.1三阶矩阵转置
#define N 10 #include &lt;iostream&gt; using namespace std; int main() { int a[N][N],i,j,t; for(i = 0;i &lt; 3;i++) for(j = 0;j &lt; 3;j++) cin &gt;&gt; a[i][j]; for(i = 0;i &lt; 3;i++)/*注意是i&lt;3而不是i&gt;j*/ for(j = 0;j &lt; i;j++){ t = a[i][j]; a[i][j] = a[j][i]; a[j][i] = t; } for(i = 0;i &lt; 3;i++){ for(j = 0;j &lt; 3;j++) cout &lt;&lt; a[i][j] &lt;&lt;" "; cout &lt;&lt; endl; } system("pause"); return 0; } 1.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5ed6c502ecc19180868c98c932e6e6ef/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/1cd4e9d5b8d7304512a0ee2da3ebd668/" rel="bookmark">
			什么是编译器？什么是解释器？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 什么是编译器？什么是解释器？编译器目标程序 解释器总结扩展思考 什么是编译器？什么是解释器？ 编译器 在计算机上运行的所有软件都是用某种程序设计语言编写的，在一个程序运行前，该程序首先需要被翻译成一种能够被计算机执行的形式，完成这项翻译工作的软件系统被称为编译器。
一个编译器就是一个程序，不同的编译器可以读懂它所对应语言编写的程序，并把该程序翻译成一个等价的，由另一种语言组成的程序，该程序一般是可以放在目标机器上的可执行的目标代码。
编译器的一个重要任务就是 报告它在翻译过程中发现的源程序中的错误。
目标程序 如果目标程序是一个可执行的机器语言程序，那么它就可以被用户调用，处理输入，并产生输出。
该目标程序是可以接受外部输入的，留有输入接口，不管是串口输入或是其他中断。
裸核或操作系统想要接受外部的输入，从本质上来讲，（都是）只能通过中断（不管是内部中断，外部中断，软件中断或者是串口输入中断等。）来接收外部输入的信息。
参见《轮询系统，前后台系统，多任务系统》
解释器 解释器是另外一种常见的程序语言处理器，它并不通过翻译的方式生成目标程序。从用户的角度看，解释器直接利用用户提供的输入，执行源程序中指定的操作。
总结 在把用户的输入映射成为输出的过程中， 使用编译器产生的目标程序所用的时间会比解释器短很多。
但是，使用解释器可以逐个语句的执行源程序，错误诊断效果通常比编译器更好。
扩展思考 debug（直译又叫去除臭虫）
对于工程项目程序调试时，我们可以单步运行，那在这一过程中，它必然使用了解释器。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/deebe7b894e6f58236dbd0e6fbb65d75/" rel="bookmark">
			Navicat连接不上远程服务器MySQL提示10038
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1. 问题如图所示 在xshell可以连接，但是navicat死活连不上。
2. 解决方案 参考链接：解决方案
# 查看防火墙是否开启3306端口 firewall-cmd --query-port=3306/tcp # 配置防火墙开启3306端口 firewall-cmd --add-port=3306/tcp --permanent #重启防火墙 firewall-cmd --reload 实际运行截图
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c9b4cd1c375723524d36a1e75037095a/" rel="bookmark">
			pymysql——从数据库获取数据
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		连接数据库
import pymysql connect = pymysql.connect( host="localhost", user="root", passwd="123456", database='shuju' ) cursor = connect.cursor() cursor.execute("select * from test") cursor.fetchone() # 单条查询结果 cursor.fetchmany(3) # 查询指定条数结果 cursor.fetchall() # 全量查询结果 cursor.close() #关闭游标 connect.close() #关闭与数据库的链接 import pymysql class MysqlReader(object): def __init__(self): self.connect = pymysql.connect(host="localhost",user="root",passwd="123456",database='shuju') def getData(self): cursor = self.connect.cursor() cursor.execute("select * from test") res = cursor.fetchall() cursor.close() self.connect.close() return res # 类调用 MR = MysqlReader() res = MR.getData() res = [list(i) for i in res] df = pd.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c9b4cd1c375723524d36a1e75037095a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/439acc308e0e08677c250066efed1ffd/" rel="bookmark">
			【C基础篇】算法、数据类型、运算符与表达式、常见输入出函数
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		【C基础篇】算法、数据类型、运算符与表达式、常见输入出函数 引言一、算法1、算法的基本概念 二、数据类型1、关键字2、标识符3、数据类型4、变量的存储类别 三、运算符与表达式1、强制类型转换2、逻辑运算符 四、常用数据的输入(出)函数1、字符输入(出)2、字符串输入(出)3、格式输入(出) 引言 算法：熟悉算法概念、算法的描述；数据类型：学习C语言最基础的语法知识、认识变量、常量和数据类型；运算符和表达式：掌握各种运算符、表达式、优先级结合性等内容。 一、算法 1、算法的基本概念 算法是为解决某一特定类型的问题而制定的一个实现过程，具有下列特性：
有穷性：执行步骤有穷、执行时间有穷，不能无限执行；确定性：每个步骤都有确切定义；可行性：每一步都能有效运行；输入：一个算法应有零个或多个输入；输出：一个算法应有一个或多个输出。 衡量一个算法的好坏，通常从以下几个方面来分析
正确性可读性健壮性时间复杂度和空间复杂度 时间复杂度：算法运行所需的时间；
空间复杂度：算法运行时所需的存储空间的大小。
二、数据类型 1、关键字 关键字是C语言规定的具有特定意义的字符串。用户定义的常量、变量、函数等名称不能与关键字相同。
关键字描述关键字描述auto声明自动变量break跳出当前循环case开关语句分支char声明字符型变量或函数const限定变量不被改变continue结束当前循环，开始下一轮循环default开关语句其他分支返回语句do循环语句的循环体double声明双精度变量或函数else条件语句否定分支enum声明枚举类型extern存储类声明修饰符float声明浮点型变量或函数for循环语句goto无条件跳转语句while循环语句的循环条件int声明整型变量或函数long声明长整型变量或函数register声明寄存器变量union声明共用体数据类型short声明短整型变量或函数signed声明有符号型变量或函数sizeof计算数据类型长度static声明静态变量struct声明结构体变量或函数switch用于开关语句typedef用于给数据类型取别名return返回语句unsigned声明无符号型变量或函数void声明函数无返回值或无参数，声明无指针类型volatile说明变量在程序执行中可被隐含地改变if条件语句 利用extern关键字。可以在一个文件中引用另一个文件中定义的变量或函数
2、标识符 标识符基本命名规则：
必须以字母或下划线开头，不能以数字或符号开头；除开头外的其他字符可以由字母、下划线或数字组成；大写和小写的字母代表不同的标识符；标识符不能是关键字；标识符应体现一定的功能含义，便于理解； 3、数据类型 C语言中的数据类型包括：基本类型、构造类型、指针类型和空类型等。
4、变量的存储类别 auto
作用为定义一个局部变量为自动变量，该变量存储于内存的动态存储区中，每次执行到该变量定义语句时，都会产生一个新的变量，并且对其初始化。
#include&lt;stdio.h&gt; void add() { auto int a = 1; a = a + 1; printf("%d\n",a); } int main() { printf("第一次调用："); add(); printf("第二次调用："); add(); return 0; } static
static变量表示静态变量，存储于内存的静态存储区；在语句块执行过程中，static变量将始终保持它的值，并且初始化操作只在第一次执行时起作用，在随后的运行过程中变量将保持语句块在上一次执行时的值。
#include&lt;stdio.h&gt; void click() { static int sum = 0; sum = sum + 1; printf("
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/439acc308e0e08677c250066efed1ffd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c663ec2f215fc23f308724246c8129a8/" rel="bookmark">
			[TI TDA4 J721E] TDA4平台 相关技术文章 汇总
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		首先感谢阅读，如果您也对TDA4相关的开发感兴趣，我们这边有个学习交流微信群，可以入群和大家一起交流学习。
资历较浅，水平有限，如遇错误，请大家多指正！
保持开源精神，共同分享、进步！
博主WX ： AIR_12 我会拉你入群。
链接：TDA4 相关专栏 链接：TDA4 Demo 开源库
欢迎大家加入，一起维护这个开源库，给更多的朋友提供帮助。
为了方便大家快速找到需要阅读的文章，这里增加一个文章分类的汇总，后续如果发布和TDA4相关的新博客，都会在这里进行同步。
下图为简单的YOLOV5模型移植后在开发板上的检测效果：
目录
目录
一、基础知识
1、开发环境搭建
2、SD卡制作及Demo编译与运行
3、网络调试功能及开机网络配置相关
二、OpenVX Kernel 自动生成及验证
1、Python自动化脚本生成Kernel
2、Kernel注册和Node使用
三、视频编解码及流媒体服务器相关
1、SRS开源流媒体服务器的搭建
2、Encode H264视频编码功能
3、Decode H264视频解码功能
4、FFmpeg / X264 ARM平台的移植
四、TIOVX Image 图像 获取 和 显示 相关
1、图像基本操作 修正版
2、OpenGl Mosaic Node应用
3、app_img_mosaic_module模块应用
4、USB摄像头获取YUV 格式图像
五、TIOVX Graph 和 Pipeline 相关
1、Graph 和 Pipeline 的理解和应用
六、TIOVX 常用函数 及 相关对象解析
1、ObjectArray 相关
2、vxReplicateNode 相关
七、深度学习及模型推理相关内容
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c663ec2f215fc23f308724246c8129a8/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/216/">«</a>
	<span class="pagination__item pagination__item--current">217/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/218/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>