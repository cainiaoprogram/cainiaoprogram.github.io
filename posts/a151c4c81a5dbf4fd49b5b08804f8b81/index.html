<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java与设计模式（7）：适配器模式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java与设计模式（7）：适配器模式" />
<meta property="og:description" content="一、定义 适配器模式是一种结构型设计模式，它允许将一个类的接口转换为客户端所期望的另一个接口。适配器模式使得原本由于接口不兼容而无法一起工作的类能够协同工作。
适配器模式通过引入一个适配器类来解决接口不兼容的问题。适配器类实现了客户端所期望的目标接口，并在内部持有一个适配者对象，将适配者对象的接口转换为目标接口。客户端通过调用适配器对象的方法来间接使用适配者对象的功能。
适配器模式包含以下几个角色：
目标接口（Target）：客户端所期望的接口，适配器类实现了该接口。适配者（Adaptee）：需要被适配的类，它包含了客户端所需的功能，但与目标接口不兼容。适配器（Adapter）：适配器类，它实现了目标接口，并在内部持有一个适配者对象。适配器类将适配者对象的接口转换为目标接口，使得客户端能够通过适配器对象来使用适配者对象的功能。 适配器模式的主要优点是可以解决接口不兼容的问题，使得原本无法协同工作的类能够一起工作。它可以使得系统更加灵活，能够适应变化的需求。适配器模式的主要缺点是引入了一个额外的适配器类，增加了系统的复杂性。
适配器模式在实际开发中经常用于集成不同的系统、框架或第三方库，以便使它们能够协同工作。它也可以用于重用现有的类，而不需要修改其原有的接口。
二、Java示例 以下是一个简单的Java示例，展示了适配器模式的使用：
首先，我们有一个目标接口 MediaPlayer，定义了播放音频文件的方法：
public interface MediaPlayer { void playAudio(String filename); } 然后，我们有一个适配者类 AdvancedMediaPlayer，它提供了播放其他格式音频文件的方法：
public class AdvancedMediaPlayer { public void playMp3(String filename) { System.out.println(&#34;Playing MP3 file: &#34; &#43; filename); } public void playFlac(String filename) { System.out.println(&#34;Playing FLAC file: &#34; &#43; filename); } } 接下来，我们创建一个适配器类 MediaAdapter，它实现了目标接口 MediaPlayer，并在内部持有一个适配者对象 AdvancedMediaPlayer。适配器类将适配者对象的方法转换为目标接口的方法：
public class MediaAdapter implements MediaPlayer { private AdvancedMediaPlayer advancedMediaPlayer; public MediaAdapter() { advancedMediaPlayer = new AdvancedMediaPlayer(); } @Override public void playAudio(String filename) { // 假设我们只支持播放MP3格式的音频文件 advancedMediaPlayer." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a151c4c81a5dbf4fd49b5b08804f8b81/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-29T21:19:37+08:00" />
<meta property="article:modified_time" content="2023-06-29T21:19:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java与设计模式（7）：适配器模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>一、定义</h2> 
<p>适配器模式是一种结构型设计模式，它允许将一个类的接口转换为客户端所期望的另一个接口。适配器模式使得原本由于接口不兼容而无法一起工作的类能够协同工作。</p> 
<p>适配器模式通过引入一个适配器类来解决接口不兼容的问题。适配器类实现了客户端所期望的目标接口，并在内部持有一个适配者对象，将适配者对象的接口转换为目标接口。客户端通过调用适配器对象的方法来间接使用适配者对象的功能。</p> 
<p>适配器模式包含以下几个角色：</p> 
<ul><li>目标接口（Target）：客户端所期望的接口，适配器类实现了该接口。</li><li>适配者（Adaptee）：需要被适配的类，它包含了客户端所需的功能，但与目标接口不兼容。</li><li>适配器（Adapter）：适配器类，它实现了目标接口，并在内部持有一个适配者对象。适配器类将适配者对象的接口转换为目标接口，使得客户端能够通过适配器对象来使用适配者对象的功能。</li></ul> 
<p>适配器模式的主要优点是可以解决接口不兼容的问题，使得原本无法协同工作的类能够一起工作。它可以使得系统更加灵活，能够适应变化的需求。适配器模式的主要缺点是引入了一个额外的适配器类，增加了系统的复杂性。</p> 
<p>适配器模式在实际开发中经常用于集成不同的系统、框架或第三方库，以便使它们能够协同工作。它也可以用于重用现有的类，而不需要修改其原有的接口。</p> 
<h2><a id="Java_15"></a>二、Java示例</h2> 
<p>以下是一个简单的Java示例，展示了适配器模式的使用：</p> 
<p>首先，我们有一个目标接口 <code>MediaPlayer</code>，定义了播放音频文件的方法：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">MediaPlayer</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">void</span> <span class="token function">playAudio</span><span class="token punctuation">(</span><span class="token class-name">String</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>然后，我们有一个适配者类 <code>AdvancedMediaPlayer</code>，它提供了播放其他格式音频文件的方法：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdvancedMediaPlayer</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">playMp3</span><span class="token punctuation">(</span><span class="token class-name">String</span> filename<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Playing MP3 file: "</span> <span class="token operator">+</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">playFlac</span><span class="token punctuation">(</span><span class="token class-name">String</span> filename<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Playing FLAC file: "</span> <span class="token operator">+</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>接下来，我们创建一个适配器类 <code>MediaAdapter</code>，它实现了目标接口 <code>MediaPlayer</code>，并在内部持有一个适配者对象 <code>AdvancedMediaPlayer</code>。适配器类将适配者对象的方法转换为目标接口的方法：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MediaAdapter</span> <span class="token keyword">implements</span> <span class="token class-name">MediaPlayer</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">AdvancedMediaPlayer</span> advancedMediaPlayer<span class="token punctuation">;</span>
    
    <span class="token keyword">public</span> <span class="token class-name">MediaAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        advancedMediaPlayer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AdvancedMediaPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">playAudio</span><span class="token punctuation">(</span><span class="token class-name">String</span> filename<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 假设我们只支持播放MP3格式的音频文件</span>
        advancedMediaPlayer<span class="token punctuation">.</span><span class="token function">playMp3</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>最后，我们有一个客户端类 <code>Client</code>，它使用适配器对象来播放音频文件：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">MediaPlayer</span> mediaPlayer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MediaAdapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        mediaPlayer<span class="token punctuation">.</span><span class="token function">playAudio</span><span class="token punctuation">(</span><span class="token string">"song.mp3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的示例中，客户端通过创建一个适配器对象 <code>MediaAdapter</code>，并将其赋值给目标接口 <code>MediaPlayer</code>，然后调用适配器对象的方法 <code>playAudio</code> 来播放音频文件。适配器对象内部使用适配者对象 <code>AdvancedMediaPlayer</code> 的方法来实现播放功能。</p> 
<p>这样，通过适配器模式，我们可以使用目标接口来统一调用不同格式的音频文件播放方法，而不需要直接与适配者类进行交互。</p> 
<h2><a id="_73"></a>三、优点</h2> 
<p>适配器模式具有以下几个优点：</p> 
<ol><li> <p>解决接口不兼容问题：适配器模式可以解决由于接口不兼容而无法协同工作的类之间的问题。通过引入适配器类，可以将不同接口的类适配为客户端所期望的目标接口，使它们能够一起工作。</p> </li><li> <p>增加了灵活性：适配器模式使得系统更加灵活，能够适应变化的需求。当需要引入新的类或接口时，可以通过创建适配器类来适配新的类或接口，而不需要修改已有的代码。</p> </li><li> <p>重用现有的类：适配器模式可以重用已有的类，而无需修改其原有的接口。通过创建适配器类，可以将现有的类适配为目标接口，实现接口的重用。</p> </li><li> <p>系统解耦：适配器模式可以将客户端与适配者类解耦，客户端只需要通过目标接口与适配器类进行交互，而不需要直接与适配者类进行交互。这样可以降低系统的耦合度，提高系统的可维护性和可扩展性。</p> </li><li> <p>提高代码可读性：适配器模式可以使代码更加清晰和易读。通过引入适配器类，可以将适配者类的方法转换为目标接口的方法，使得代码更加符合客户端的理解和使用习惯。</p> </li></ol> 
<p>适配器模式是一种非常有用的设计模式，它可以解决接口不兼容的问题，增加系统的灵活性和可维护性，同时提高代码的可读性和重用性。</p> 
<h2><a id="_88"></a>四、缺点</h2> 
<p>适配器模式虽然有很多优点，但也存在一些缺点：</p> 
<ol><li> <p>增加了系统复杂性：引入适配器类会增加系统的复杂性。适配器类需要额外的代码来实现适配逻辑，这增加了代码的数量和复杂度，可能会增加系统的理解和维护成本。</p> </li><li> <p>过多使用适配器可能导致系统设计问题：如果系统中存在大量的适配器类，这可能意味着系统设计存在问题。过多使用适配器可能暗示着系统中的类和接口设计不够合理，需要重新考虑系统的整体架构。</p> </li><li> <p>不适合频繁变化的接口：适配器模式适用于将一个接口转换为另一个接口的场景，但如果接口经常发生变化，可能需要频繁修改适配器类。这样会增加代码的维护成本和风险。</p> </li><li> <p>可能影响性能：适配器模式在转换接口的过程中会引入额外的开销，可能会影响系统的性能。尤其是在处理大量数据或高频率调用的情况下，需要仔细考虑适配器模式的性能影响。</p> </li></ol> 
<h2><a id="_100"></a>五、使用场景</h2> 
<p>适配器模式适用于以下场景：</p> 
<ol><li> <p>接口不兼容：当需要使用一个已有的类，但其接口与当前系统的接口不兼容时，可以使用适配器模式进行适配。适配器模式可以将该类的接口转换为目标接口，使其能够与当前系统协同工作。</p> </li><li> <p>系统集成：在系统集成过程中，可能会涉及到不同系统或模块之间的接口不兼容问题。适配器模式可以用于将不同系统或模块的接口适配为统一的目标接口，以实现系统之间的协同工作。</p> </li><li> <p>第三方库使用：当使用第三方库或框架时，可能需要将其接口适配为当前系统的接口，以便于与系统其他部分进行集成。适配器模式可以用于将第三方库的接口转换为系统所期望的接口。</p> </li><li> <p>重用现有类：当需要重用已有的类，但其接口与当前需求不匹配时，可以使用适配器模式进行适配。适配器模式可以将现有类的接口转换为目标接口，以满足当前需求。</p> </li><li> <p>系统解耦：适配器模式可以将客户端与适配者类解耦，使客户端只需要与目标接口进行交互，而不需要直接与适配者类进行交互。这样可以降低系统的耦合度，提高系统的可维护性和可扩展性。</p> </li></ol> 
<p>=适配器模式适用于需要解决接口不兼容问题、系统集成、第三方库使用、重用现有类以及系统解耦等场景。在这些场景下，适配器模式可以帮助我们实现接口的适配和集成，提高系统的灵活性和可维护性。</p> 
<h2><a id="_116"></a>六、注意事项</h2> 
<p>在使用适配器模式时，需要注意以下几点：</p> 
<ol><li> <p>确定适配器的角色：在设计适配器模式时，需要明确适配器的角色是充当类适配器还是对象适配器。类适配器使用继承来适配接口，对象适配器使用组合来适配接口。根据具体需求和系统设计，选择合适的适配器角色。</p> </li><li> <p>考虑适配器的复用性：在设计适配器模式时，应考虑适配器的复用性。适配器模式的目的之一是重用现有的类，所以适配器类应该具有一定的通用性，可以适配多个类或接口。这样可以提高代码的重用性和系统的灵活性。</p> </li><li> <p>注意接口的一致性：在适配器模式中，适配器类的目标接口应与客户端所期望的接口一致。适配器类应该实现目标接口，并在内部调用适配者类的方法来实现接口的转换。确保适配器类的接口设计符合客户端的需求。</p> </li><li> <p>考虑性能影响：适配器模式在转换接口的过程中可能会引入额外的开销，可能会影响系统的性能。在设计和使用适配器模式时，需要仔细考虑适配器的性能影响，并在必要时进行性能优化。</p> </li><li> <p>避免过度使用适配器：适配器模式应该被谨慎使用，避免过度使用适配器。如果系统中存在大量的适配器类，这可能意味着系统设计存在问题。适配器模式应该用于解决接口不兼容的问题，而不是作为系统设计的替代品。</p> </li></ol> 
<p>在使用适配器模式时，需要明确适配器的角色，考虑适配器的复用性和接口的一致性，注意性能影响，并避免过度使用适配器。合理地应用适配器模式可以提高系统的灵活性和可维护性，但需要根据具体情况进行设计和实现。</p> 
<h2><a id="spring__131"></a>七、在spring 中的应用</h2> 
<p>在Spring框架中，适配器模式有多种应用场景：</p> 
<ol><li> <p>MVC框架中的处理器适配器（Handler Adapter）：Spring MVC框架使用适配器模式来适配不同类型的处理器（Handler），如Controller、RestController、RequestMapping等。处理器适配器负责将请求适配到对应的处理器上，并将处理结果返回给客户端。</p> </li><li> <p>AOP代理适配器：Spring的AOP模块使用适配器模式来适配不同类型的切面（Aspect）和通知（Advice）。AOP代理适配器负责将切面和通知适配到目标对象上，实现横切关注点的织入。</p> </li><li> <p>数据库访问适配器：Spring的JDBC模块中使用适配器模式来适配不同类型的数据库驱动。数据库访问适配器负责将通用的JDBC接口适配到特定数据库驱动的接口上，使得应用程序可以通过统一的接口访问不同类型的数据库。</p> </li><li> <p>消息队列适配器：Spring的消息模块中使用适配器模式来适配不同类型的消息队列实现，如ActiveMQ、RabbitMQ等。消息队列适配器负责将统一的消息发送和接收接口适配到特定消息队列实现的接口上，实现消息的异步通信。</p> </li></ol> 
<p>Spring框架中广泛使用适配器模式来适配不同类型的组件和接口，以实现统一的调用方式和接口规范。适配器模式在Spring中的应用使得开发者可以更方便地集成和使用各种功能组件，提高系统的灵活性和可扩展性。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e12afca69896c439128930d832f488b0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JMeter 5.5 使用详解（持续更新中......）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f1e5902bc5af8b0d0ef56246aac7ba23/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Chrome浏览器使用AdGuard去除百度热搜</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>