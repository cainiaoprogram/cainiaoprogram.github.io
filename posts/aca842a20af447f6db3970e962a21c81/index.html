<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>react 16.7 hook概述 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="react 16.7 hook概述" />
<meta property="og:description" content="Hook是向后兼容的，有react开发经验的看起来会更顺畅。
State Hook 看下面的例子，他是一个计数器
import { useState } from &#39;react&#39;; function Example() { // Declare a new state variable, which we&#39;ll call &#34;count&#34; const [count, setCount] = useState(0); return ( &lt;div&gt; &lt;p&gt;You clicked {count} times&lt;/p&gt; &lt;button onClick={() =&gt; setCount(count &#43; 1)}&gt; Click me &lt;/button&gt; &lt;/div&gt; ); } 在这里useState是一个Hook（我们将在稍后讨论这意味着什么）。可以看到，在这个函数组件里，我们向他添加一些本地状态。React将在重新渲染之间保留这状态。 useState返回一对：当前状态值(count)和允许你更新状态的函数(setCount)。你可以从事件处理程序或其他位置调用此函数。这个函数类似于类中的this.setState，但是它不会将旧状态和新状态合并在一起。（我们将在使用State Hook中显示一个将useState与this.state进行比较的示例。）
useState的唯一参数是初始状态。 在上面的例子中，它是0，因为我们的计数器从零开始。请注意，与this.state不同，此处的状态不必是对象 - 尽管可以是任何你想要的。初始状态参数仅在第一次渲染期间使用。
声明多个state
你可以在一个组件中多次使用State Hook：
function ExampleWithManyStates() { const [age, setAge] = useState(42); const [fruit, setFruit] = useState(&#39;banana&#39;); const [todos, setTodos] = useState([{ text: &#39;Learn Hooks&#39; }]); // ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/aca842a20af447f6db3970e962a21c81/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-21T15:43:51+08:00" />
<meta property="article:modified_time" content="2019-07-21T15:43:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">react 16.7 hook概述</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><code>Hook</code>是向后兼容的，有<code>react</code>开发经验的看起来会更顺畅。</p> 
<h4>State Hook</h4> 
<p>看下面的例子，他是一个计数器</p> 
<pre class="has"><code>import { useState } from 'react';

function Example() {
  // Declare a new state variable, which we'll call "count"
  const [count, setCount] = useState(0);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre> 
<p>在这里<code>useState</code>是一个<code>Hook</code>（我们将在稍后讨论这意味着什么）。可以看到，在这个函数组件里，我们向他添加一些本地状态。<code>React</code>将在重新渲染之间保留这状态。 <code>useState</code>返回一对：当前状态值(<code>count</code>)和允许你更新状态的函数(<code>setCount</code>)。你可以从事件处理程序或其他位置调用此函数。这个函数类似于类中的<code>this.setState</code>，但是它不会将旧状态和新状态合并在一起。（我们将在<a href="https://reactjs.org/docs/hooks-state.html" rel="nofollow">使用State Hook</a>中显示一个将<code>useState</code>与<code>this.state</code>进行比较的示例。）</p> 
<p><strong><code>useState</code>的唯一参数是初始状态。</strong> 在上面的例子中，它是0，因为我们的计数器从零开始。请注意，与<code>this.state</code>不同，此处的状态不必是对象 - 尽管可以是任何你想要的。<strong>初始状态参数仅在第一次渲染期间使用。</strong></p> 
<p>声明多个<code>state</code></p> 
<p>你可以在一个组件中多次使用<code>State Hook</code>：</p> 
<pre class="has"><code>function ExampleWithManyStates() {
  const [age, setAge] = useState(42);
  const [fruit, setFruit] = useState('banana');
  const [todos, setTodos] = useState([{ text: 'Learn Hooks' }]);
  // ...
}
</code></pre> 
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment#Array_destructuring" rel="nofollow">数组解构</a>语法允许我们为通过调用<code>useState</code>声明的状态变量赋予不同的名称。这些名称不是<code>useState API</code>的一部分。相反，<code>React</code>假定如果多次调用<code>useState</code>，则在每次渲染期间以相同的顺序执行。我们将回到为什么这种方法有效以及何时有用。</p> 
<p>什么是<code>Hook</code></p> 
<p>钩子是允许从功能组件(function component)“挂钩”React状态和生命周期功能的功能。<strong>钩子在类内部不起作用 - 它们允许你在没有类的情况下使用<code>React</code>。</strong> (我们<a href="https://github.com/xiaohesong/TIL/blob/master/front-end/react/hooks/intro.md#%E9%80%90%E6%AD%A5%E9%87%87%E7%94%A8%E7%AD%96%E7%95%A5">不建议</a>你在一夜之间重写现有组件，但如果你愿意，可以开始在新组件中使用<code>Hook</code>。）</p> 
<p><code>React</code>提供了一些像<code>useState</code>这样的内置<code>Hook</code>。你还可以创建自定义<code>Hook</code>以在不同组件之间重用有状态行为。我们先来看看内置的<code>Hooks</code>。</p> 
<blockquote> 
 <p><strong>详细说明</strong> 你可以在<a href="https://reactjs.org/docs/hooks-state.html" rel="nofollow">使用State Hook</a>中了解更多信息。</p> 
</blockquote> 
<h4>Effect Hook</h4> 
<p>你之前可能已经从<code>React</code>组件执行数据提取，订阅或手动更改<code>DOM</code>。我们将这些操作称为“副作用”（或简称为“效果”），因为它们会影响其他组件，并且在渲染过程中无法完成。</p> 
<p><code>Effect Hook</code>中的<code>useEffect</code>增加了在功能组件执行副作用的功能。它与<code>React</code>类中的<code>componentDidMount</code>，<code>componentDidUpdate</code>和<code>componentWillUnmount</code>具有相同的用途，但统一为单个API。(我们将在<a href="https://reactjs.org/docs/hooks-effect.html" rel="nofollow">使用<code>Effect Hook</code></a>时显示将<code>useEffect</code>与这些方法进行比较的示例。）</p> 
<p>例如，下面的组件将在<code>React</code>更新<code>DOM</code>后设置文档标题：</p> 
<pre class="has"><code>import { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0);

  // 类似componentDidMount 和 componentDidUpdate:
  useEffect(() =&gt; {
    // Update the document title using the browser API
    document.title = `You clicked ${count} times`;
  });

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre> 
<p>当你调用<code>useEffect</code>时，你就在告诉<code>react</code>运行你的‘效果’函数当刷新对<code>DOM</code>的更改后(你可以认为是<code>render</code>之后)。<br> 效果在组件内声明，因此可以访问其<code>props</code>和<code>state</code>。默认情况下，<code>React</code>在每次渲染后运行效果 - 包括第一次渲染。 （我们将更多地讨论<a href="https://reactjs.org/docs/hooks-effect.html" rel="nofollow">使用effect hook</a>与类生命周期的比较。）</p> 
<p><code>Effects</code>还可以通过指定返回函数来清理他们。看下面的这个例子：</p> 
<pre class="has"><code>import { useState, useEffect } from 'react';

function FriendStatus(props) {
  const [isOnline, setIsOnline] = useState(null);

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  useEffect(() =&gt; {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);

    return () =&gt; {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  if (isOnline === null) {
    return 'Loading...';
  }
  return isOnline ? 'Online' : 'Offline';
}
</code></pre> 
<p>在这个示例中，当组件卸载时，以及在由于后续渲染而重新运行效果之前，<code>React</code>将取消订阅我们的<code>ChatAPI</code>。（如果你愿意的话，如果我们传递给<code>ChatAPI</code>的<code>props.friend.id</code>没有改变，有办法<a href="https://reactjs.org/docs/hooks-effect.html#tip-optimizing-performance-by-skipping-effects" rel="nofollow">告诉<code>React</code>跳过重新订阅</a>。）</p> 
<p>就像使用<code>useState</code>一样， 你也可以在组件中使用多个效果：</p> 
<pre class="has"><code>function FriendStatusWithCounter(props) {
  const [count, setCount] = useState(0);
  useEffect(() =&gt; {
    document.title = `You clicked ${count} times`;
  });

  const [isOnline, setIsOnline] = useState(null);
  useEffect(() =&gt; {
    ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);
    return () =&gt; {
      ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);
    };
  });

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }
  // ...
}
</code></pre> 
<p><code>Hooks</code>允许你通过哪些部分相关（例如添加和删除订阅）来组织组件中的副作用，而不是基于生命周期方法强制拆分。</p> 
<blockquote> 
 <p><strong>详细说明</strong> 你可以在<a href="https://reactjs.org/docs/hooks-effect.html" rel="nofollow">使用Effect Hook</a>中了解更多信息。</p> 
</blockquote> 
<h4><code>Hooks</code>的规则</h4> 
<p>钩子是<code>JavaScript</code>函数，但它们强加了两个额外的规则：</p> 
<ul><li><strong>只能在顶层调用<code>Hooks</code>。不要在循环，条件或嵌套函数中调用<code>Hook</code></strong></li><li><strong>仅从<code>React</code>功能组件调用<code>Hooks</code>。</strong> 不要从常规<code>JavaScript</code>函数中调用<code>Hook</code>。 （还有另一个有效的地方叫<code>Hooks</code> - 你自己的定制<code>Hooks</code>。我们马上就会了解它们。）</li></ul> 
<blockquote> 
 <p><strong>详细说明</strong> 你可以在<a href="https://reactjs.org/docs/hooks-rules.html" rel="nofollow">Rules Hook</a>中了解更多信息。</p> 
</blockquote> 
<h4>Custom Hooks</h4> 
<p>有时，我们希望在组件之间重用一些有状态逻辑的部分。传统上，这个问题有两个流行的解决方案：<a href="https://reactjs.org/docs/higher-order-components.html" rel="nofollow">高阶组件</a>和<a href="https://reactjs.org/docs/render-props.html" rel="nofollow">渲染道具</a>。<code>Custom Hooks</code>允许你执行这样的操作，并且无需向树中添加更多组件。在上面我们介绍了一个调用<code>useState</code>和<code>useEffect Hooks</code>的<code>FriendStatus</code>组件来订阅朋友的在线状态。假设我们还希望在另一个组件中重用此订阅逻辑。<br> 首先，我们将这个逻辑提取到一个名为<code>useFriendStatus</code>的自定义<code>Hook</code>中：</p> 
<pre class="has"><code>import { useState, useEffect } from 'react';

function useFriendStatus(friendID) {
  const [isOnline, setIsOnline] = useState(null);

  function handleStatusChange(status) {
    setIsOnline(status.isOnline);
  }

  useEffect(() =&gt; {
    ChatAPI.subscribeToFriendStatus(friendID, handleStatusChange);
    return () =&gt; {
      ChatAPI.unsubscribeFromFriendStatus(friendID, handleStatusChange);
    };
  });

  return isOnline;
}
</code></pre> 
<p>它将<code>friendID</code>作为参数，并返回我们的朋友是否在线。<br> 现在我们可以从两个组件中使用它：</p> 
<pre class="has"><code>function FriendStatus(props) {
  const isOnline = useFriendStatus(props.friend.id);

  if (isOnline === null) {
    return 'Loading...';
  }
  return isOnline ? 'Online' : 'Offline';
}
</code></pre> 
<pre class="has"><code>function FriendListItem(props) {
  const isOnline = useFriendStatus(props.friend.id);

  return (
    &lt;li style={<!-- -->{ color: isOnline ? 'green' : 'black' }}&gt;
      {props.friend.name}
    &lt;/li&gt;
  );
}
</code></pre> 
<p>这些组件的状态是完全独立的。<strong>钩子是重用有状态逻辑的一种方式，而不是状态本身。</strong> 事实上，每次调用<code>Hook</code>都有一个完全隔离的状态 - 所以你甚至可以在一个组件中使用相同的自定义<code>Hook</code>两次。</p> 
<p><code>custom hook</code>更像是一种约定而非功能。如果函数的名称以<code>use</code>开头并且它调用其他<code>Hook</code>，我们说它是一个<code>Custom Hook</code>。<code>useSomething</code>命名约定是<code>linter</code>插件如何使用<code>Hooks</code>在代码中查找错误的。</p> 
<blockquote> 
 <p><strong>详细说明</strong> 你可以在<a href="https://reactjs.org/docs/hooks-custom.html" rel="nofollow">Writing Custom Hooks</a>中了解更多信息。</p> 
</blockquote> 
<h4>Other Hooks</h4> 
<p>你可能会发现一些不太常用的内置<code>Hook</code>很有用。例如，<a href="https://reactjs.org/docs/hooks-reference.html#usecontext" rel="nofollow">useContext</a>允许订阅<code>React</code>上下文而不引入嵌套：</p> 
<pre class="has"><code>function Example() {
  const locale = useContext(LocaleContext);
  const theme = useContext(ThemeContext);
  // ...
}
</code></pre> 
<p><a href="https://reactjs.org/docs/hooks-reference.html#usereducer" rel="nofollow">useReducer</a>允许使用<code>reducer</code>管理复杂组件的本地状态：</p> 
<pre class="has"><code>function Todos() {
  const [todos, dispatch] = useReducer(todosReducer);
  // ...
}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/03f72be777c1208ca5031aefc0cd140a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Mac下使用ll命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b1a66ca256fe101e6c99dd193d5285f7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">利用XSS进行网页钓鱼</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>