<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RabbitMQ 笔记一 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RabbitMQ 笔记一" />
<meta property="og:description" content="前言 过往使用一些简单队列功能，直接上redis，包括pub／sub也都可以使用redis完成简单功能。不过既然RabbitMQ作为消息队列非常成熟的组件，还是值得学习使用。演示环境Centos7，MacOS，所有演示代码可去github上下载demo code，演示代码匀为python实现，所用版本python 3.5
概述 简介 Wiki中给出的介绍是：RabbitMQ是实现了高级消息队列协议（AMQP） 的开源消息代理软件（亦称面向消息的中间件）。
AMQP – Advanced Message Queuing Protocol，一个提供统一消息服务的消息队列协议，属于应用层协议。
RabbitMQ官网
RabbitMQ安装 CentOS 7 CentOS 7中可以直接通过yum源安装
# 依赖 erlang等，如果不能自动安装，手动yum安装下各个依赖 yum install -y rabbitmq-server systemctl startrabbitmq-server 手动安装可以去RabbitMQ官网下载
wget https://github.com/rabbitmq/rabbitmq-server/releases/download/rabbitmq_v3_6_12/rabbitmq-server-3.6.12-1.el7.noarch.rpm # 缺少依赖使用yum安装即可 rpm -i rabbitmq-server-3.6.12-1.el7.noarch.rpm docker启动RabbitMQ docker hub上直接有RabbitMQ的镜像，可以直接使用docker来启动RabbitMQ服务。并且docker RabbitMQ镜像有很多种版本，选用带有RabbitMQ官方提供管理界面的RabbitMQ镜像启动，docker-compose.yml文件内容如下：
services: rbmq: image: &#34;rabbitmq:3-management&#34; container_name: test_rbmq ports: - &#34;15672:15672&#34; - &#34;5672:5672&#34; environment: - RABBITMQ_DEFAULT_USER=tester - RABBITMQ_DEFAULT_PASS=test_password restart: always 直接启动
# docker启动RabbitMQ docker-compose up -d docker的相关内容可以参见之前的博文：docker 笔记一，docker 笔记二 服务启动后，可以直接访问界面 http://localhost:15672/#/ 实际效果： 注意： 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/edb4009a7d609ad6268f5a73b9b5b3de/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-11-03T16:55:40+08:00" />
<meta property="article:modified_time" content="2017-11-03T16:55:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RabbitMQ 笔记一</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="前言">前言</h2> 
<p>过往使用一些简单队列功能，直接上redis，包括pub／sub也都可以使用redis完成简单功能。不过既然RabbitMQ作为消息队列非常成熟的组件，还是值得学习使用。演示环境Centos7，MacOS，所有演示代码可去github上下载<a href="https://github.com/wushirenfei/rabbitmq_demo" target="_blank" rel="noopener noreferrer">demo code</a>，演示代码匀为python实现，所用版本python 3.5</p> 
<h2 id="概述">概述</h2> 
<h3 id="简介">简介</h3> 
<p>Wiki中给出的介绍是：RabbitMQ是实现了高级消息队列协议（AMQP） 的开源消息代理软件（亦称面向消息的中间件）。</p> 
<p>AMQP – Advanced Message Queuing Protocol，一个提供统一消息服务的消息队列协议，属于应用层协议。</p> 
<p><a href="https://www.rabbitmq.com/" rel="nofollow noopener noreferrer" target="_blank">RabbitMQ官网</a></p> 
<h3 id="rabbitmq安装">RabbitMQ安装</h3> 
<h4 id="centos-7">CentOS 7</h4> 
<p>CentOS 7中可以直接通过yum源安装</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-comment"># 依赖 erlang等，如果不能自动安装，手动yum安装下各个依赖</span>
yum install -y rabbitmq-server
systemctl startrabbitmq-server </code></pre> 
<p>手动安装可以去RabbitMQ官网下载</p> 
<pre class="prettyprint"><code class="language-python hljs ">wget https://github.com/rabbitmq/rabbitmq-server/releases/download/rabbitmq_v3_6_12/rabbitmq-server-<span class="hljs-number">3.6</span><span class="hljs-number">.12</span>-<span class="hljs-number">1.</span>el7.noarch.rpm

<span class="hljs-comment"># 缺少依赖使用yum安装即可</span>
rpm -i rabbitmq-server-<span class="hljs-number">3.6</span><span class="hljs-number">.12</span>-<span class="hljs-number">1.</span>el7.noarch.rpm</code></pre> 
<h4 id="docker启动rabbitmq">docker启动RabbitMQ</h4> 
<p>docker hub上直接有RabbitMQ的镜像，可以直接使用docker来启动RabbitMQ服务。并且docker RabbitMQ镜像有很多种版本，选用带有RabbitMQ官方提供管理界面的RabbitMQ镜像启动，docker-compose.yml文件内容如下：</p> 
<pre class="prettyprint"><code class="language-docker hljs haml">services:
  rbmq:
    image: "rabbitmq:3-management"
    container_name: test_rbmq
    ports:
     -<span class="ruby"> <span class="hljs-string">"15672:15672"</span>
</span>     -<span class="ruby"> <span class="hljs-string">"5672:5672"</span>
</span>    environment:
     -<span class="ruby"> <span class="hljs-constant">RABBITMQ_DEFAULT_USER</span>=tester
</span>     -<span class="ruby"> <span class="hljs-constant">RABBITMQ_DEFAULT_PASS</span>=test_password
</span>    restart: always</code></pre> 
<p>直接启动</p> 
<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-comment"># docker启动RabbitMQ</span>
docker-compose up <span class="hljs-operator">-d</span></code></pre> 
<p>docker的相关内容可以参见之前的博文：<a href="http://blog.csdn.net/duxiangwushirenfei/article/details/70622377" target="_blank" rel="noopener noreferrer">docker 笔记一</a>，<a href="http://blog.csdn.net/duxiangwushirenfei/article/details/78085214" target="_blank" rel="noopener noreferrer">docker 笔记二</a> <br> 服务启动后，可以直接访问界面 <a href="http://localhost:15672/#/" rel="nofollow noopener noreferrer" target="_blank">http://localhost:15672/#/</a> <br> 实际效果： <br> <img src="https://images2.imgbox.com/e8/ff/dtqwuGVk_o.png" alt="这里写图片描述" title=""></p> 
<p><font color="red">注意： <br> 1. 截图中 Ports and contexts其中rabbitmq:3-management镜像一个监听了3个端口，分别是5672，15672，25672。其中5672是RabbitMQ服务所监听端口，直接在机器上安装的rabbitmq-server也是通过这个端口进行消息接收发送，15672端口接受的http协议，是控制界面的访问端口。另一个在演示中未用到，因此docker-compose中并未将其开放出来。 <br> 2. docker-compose中设置了RabbitMQ的用户名密码，因此使用时必须附带上认证信息才能进行消息交互，后续代码演示中会体现。手动安装的没有设置，可以直接访问。 <br> </font></p> 
<p>个人建议使用docker方式启动RabbitMQ，因为控制界面能够直观帮助我们理解RabbitMQ很多基础理念。</p> 
<h2 id="基础使用">基础使用</h2> 
<h3 id="rabbitmq架构">RabbitMQ架构</h3> 
<p>Google图库中找了一个比较贴切的RabbitMQ架构图： <br> <img src="https://images2.imgbox.com/56/ce/iWUdjwNo_o.jpg" alt="" title=""></p> 
<p>使用RabbitMQ必须要明白几个概念：</p> 
<ul><li>exchange：消息交换池，所有发送至RabbitMQ的消息都是发送至exchange中</li><li>queue：消息队列，所有消息的消费都是从queue中取得</li><li>binding：exchange中的消息，有binding确定路由关系，将池中消息送至相应的queue中</li><li>connection：producer和consumer与RabbitMQ连接，是tcp的长连接</li><li>channel：一个应用需要多个连接到RabbitMQ并非创建多个tcp长连接，而是一个tcp连接中多个channel（姑且理解为信道），共享一个tcp连接 <br> <a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html" rel="nofollow noopener noreferrer" target="_blank">详细的原文解释请参见官网</a></li></ul> 
<h3 id="demo1">demo1</h3> 
<p>python调用RabbitMQ需要安装pika包，演示使用版本是0.11.0。 <br> 生产者 producer.py 代码段如下：</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">import</span> pika
<span class="hljs-keyword">import</span> time

<span class="hljs-comment"># 用户名密码获取认证信息，附带该信息方可成功连接RabbitMQ</span>
credentials = pika.PlainCredentials(<span class="hljs-string">'tester'</span>, <span class="hljs-string">'test_password'</span>)
connection = pika.BlockingConnection(pika.ConnectionParameters(
    <span class="hljs-string">'localhost'</span>, credentials=credentials))

<span class="hljs-comment"># 一个connection中开启多个channel</span>
channel = connection.channel()
channel2 = connection.channel()

<span class="hljs-comment"># 声明队列</span>
channel.queue_declare(queue=<span class="hljs-string">'first_queue'</span>)

i = <span class="hljs-number">0</span>
<span class="hljs-keyword">while</span> i &lt; <span class="hljs-number">5</span>:
    time.sleep(<span class="hljs-number">1</span>)
    a = <span class="hljs-string">'{} message'</span>.format(i)
    channel.basic_publish(exchange=<span class="hljs-string">''</span>, routing_key=<span class="hljs-string">'first_queue'</span>, body=a)
    i += <span class="hljs-number">1</span>

connection.close()</code></pre> 
<p>单独执行 producer.py，管理界面效果如下： <br> <img src="https://images2.imgbox.com/52/b8/pMluWjgv_o.png" alt="这里写图片描述" title=""> <br> 上图可以清晰看出各模块数据信息，点击队列名称可以看到队列详细信息。 <br> 消费者 consumer.py 代码段如下：</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">import</span> pika
<span class="hljs-keyword">import</span> time

<span class="hljs-comment"># 消费函数</span>
<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">callback</span><span class="hljs-params">(ch, method, properties, body)</span>:</span>
    time.sleep(<span class="hljs-number">2</span>)
    print(<span class="hljs-string">"consumer_1 [x] Received %r"</span> % (body,))
    <span class="hljs-comment"># ch.basic_ack(delivery_tag=method.delivery_tag)</span>

credentials = pika.PlainCredentials(<span class="hljs-string">'tester'</span>, <span class="hljs-string">'test_password'</span>)
connection = pika.BlockingConnection(pika.ConnectionParameters(
    <span class="hljs-string">'localhost'</span>, credentials=credentials))

channel = connection.channel()

channel.queue_declare(queue=<span class="hljs-string">'first_queue'</span>)

<span class="hljs-comment"># 为匹配队列指定消费的回调函数</span>
channel.basic_consume(callback, queue=<span class="hljs-string">'first_queue'</span>, no_ack=<span class="hljs-keyword">True</span>)

print(<span class="hljs-string">'Consumer_1 Waiting for messages. To exit press CTRL+C'</span>)
channel.start_consuming()</code></pre> 
<p>分别启动<a href="https://github.com/wushirenfei/rabbitmq_demo" target="_blank" rel="noopener noreferrer">demo code</a> default工程中consumer1 和 consumer2，在启动producer产生消息，运行结果如下： <br> <img src="https://images2.imgbox.com/bd/8c/rDQ6pxJL_o.png" alt="这里写图片描述" title=""></p> 
<p>5条消息分别被consumer1 和 consumer2 认领消费。RabbitMQ使用一种循环分发的机制，顺序将到来的message分给每个consumer，当负载增加时，只需添加更多的consumer来完成拓展即可。</p> 
<h3 id="消息确认">消息确认</h3> 
<p>上面的demo中在队列声明时指定了no_ack=True，也就是说当消息被consumer认领后，就认为该message已经被消费，此时若consumer异常退出未能正常消费该message，那么此条message就丢了。为此可以在消费端声明使用队列时默认使用需要ack的方式。 <br> 修改consumer代码，删除no_ack=True，并且在consumer2修改callback函数，添加1/0，中断consumer2。执行程序如下： <br> <img src="https://images2.imgbox.com/c1/da/UzweLN4f_o.png" alt="这里写图片描述" title=""></p> 
<p><font color="red"> <br> 注意 <br> 1. 如果consumer2消费后没有发送确认，那么consumer2所有处理过的message在consumer2退出后会被重新发送给其他consumer <br> 2. callbcck函数编写其参数时回调式默认传入的四个参数，可以进入 channel.basic_consume 方法中查看，源码注释中已经给出详细解释。 <br> </font></p> 
<h3 id="消息持久化">消息持久化</h3> 
<p>上文的ack确认可以保证消息被正常消费，可是RabbitQM 服务如果在消费尚未进行出现停止，此时已进入RabbitQM 队列中的消息会如何？维持上文produecr代码并执行完，进入Queue管理界面此时能看到first_queue队列中存有5条message。重启RabbitQM后登陆管理界面 first_queue已丢失。 <br> RabbitQM中持久化首先是队列的持久化，调整producer中声明队列代码：</p> 
<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-comment"># 声明持久化队列</span>
channel.queue_<span class="hljs-keyword">declare</span>(queue=<span class="hljs-string">'first_queue'</span>, durable=True)</code></pre> 
<p>重复之前操作，此时队列first_queue在重启RabbitQM仍然存在，但是其中的消息没有了，已经做到了队列持久化。</p> 
<p>在此调整producer中代码如下：</p> 
<pre class="prettyprint"><code class=" hljs livecodeserver"><span class="hljs-comment"># 将发布的消息设置为持久化</span>
channel.basic_publish(
        exchange=<span class="hljs-string">''</span>, routing_key=<span class="hljs-string">'first_queue'</span>, body=<span class="hljs-operator">a</span>,
        properties=pika.BasicProperties(
            delivery_mode=<span class="hljs-number">2</span>,  <span class="hljs-comment"># make message persistent</span>
        )
)</code></pre> 
<p>再次重复操作，重启RabbitQM后队列，消息均维持原样。 <br> <font color="red"> <br> 注意： <br> delivery_mode=2是一个常量设置，在paki包的spec.py中定义了BasicProperties类，并且定义了 <br> TRANSIENT_DELIVERY_MODE = 1 <br> PERSISTENT_DELIVERY_MODE = 2 <br> 两个常量用以区分短暂消息和持久消息。在RabbitQM官网中规定了delivery_mode 1和2分别指定的消息类型。 <br> </font></p> 
<h2 id="路由算法">路由算法</h2> 
<p>exchange有三种类型，<a href="https://www.rabbitmq.com/tutorials/amqp-concepts.html" rel="nofollow noopener noreferrer" target="_blank">官网中给出了相应的解释</a>，分别是：</p> 
<ol><li>direct：routing_key匹配，exchange将消息发送给所有routing_key匹配的队列中，但不是重复发送，一个消息只会发送给所有匹配routing_key队列中的一个，此种模式多用于负载均衡的消费形式</li><li>fanout：广播模式，类似网络广播一样所有属于该exchange中的队列都能收到</li><li>topic：通过队列设定的routing_key pattern，exchange 将消息发送给所有匹配的对列，只要匹配，队列就会收到消息，这是其与direct不同之处，topic多用于pub／sub的功能场景。</li></ol> 
<h3 id="direct-demo">direct demo</h3> 
<p><a href="https://github.com/wushirenfei/rabbitmq_demo" target="_blank" rel="noopener noreferrer">demo code</a> 工程中分别执行两个consumer1，和一个consumer2，之后执行producer，执行结果如下： <br> <img src="https://images2.imgbox.com/8c/4b/ftA5ni5s_o.png" alt="这里写图片描述" title=""> <br> 是否觉得仿佛与之前说明的direct 并不相同？两个consumer1都接收到消息。</p> 
<p>producer代码如下：</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">import</span> pika
<span class="hljs-keyword">import</span> time

credentials = pika.PlainCredentials(<span class="hljs-string">'tester'</span>, <span class="hljs-string">'test_password'</span>)
connection = pika.BlockingConnection(pika.ConnectionParameters(
    <span class="hljs-string">'localhost'</span>, credentials=credentials))
channel = connection.channel()

channel.exchange_declare(exchange=<span class="hljs-string">'direct_exchange'</span>, exchange_type=<span class="hljs-string">'direct'</span>)

i = <span class="hljs-number">0</span>
<span class="hljs-keyword">while</span> i &lt; <span class="hljs-number">5</span>:
    time.sleep(<span class="hljs-number">1</span>)
    a = <span class="hljs-string">'{} message'</span>.format(i)
    <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">2</span>:
        channel.basic_publish(
            exchange=<span class="hljs-string">'direct_exchange'</span>, routing_key=<span class="hljs-string">'mini'</span>, body=a)
    <span class="hljs-keyword">else</span>:
        channel.basic_publish(
            exchange=<span class="hljs-string">'direct_exchange'</span>, routing_key=<span class="hljs-string">'max'</span>, body=a)

    i += <span class="hljs-number">1</span>

connection.close()</code></pre> 
<p>consumer1中代码如下：</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">import</span> pika
<span class="hljs-keyword">import</span> time


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">callback</span><span class="hljs-params">(ch, method, properties, body)</span>:</span>
    time.sleep(<span class="hljs-number">2</span>)
    print(<span class="hljs-string">"consumer [x] Received %r"</span> % (body,))
    ch.basic_ack(delivery_tag=method.delivery_tag)


credentials = pika.PlainCredentials(<span class="hljs-string">'tester'</span>, <span class="hljs-string">'test_password'</span>)
connection = pika.BlockingConnection(pika.ConnectionParameters(
    <span class="hljs-string">'localhost'</span>, credentials=credentials))

channel = connection.channel()

channel.exchange_declare(exchange=<span class="hljs-string">'direct_exchange'</span>, exchange_type=<span class="hljs-string">'direct'</span>)

result = channel.queue_declare(exclusive=<span class="hljs-keyword">True</span>)
queue_name = result.method.queue

channel.queue_bind(
    exchange=<span class="hljs-string">'direct_exchange'</span>, routing_key=<span class="hljs-string">'mini'</span>, queue=queue_name)

channel.basic_consume(callback, queue=queue_name)

print(<span class="hljs-string">' [*] Waiting for messages. To exit press CTRL+C'</span>)
channel.start_consuming()</code></pre> 
<p>与之前的demo代码相比，producer端没有声明队列，而是将消息交exchange，而在consumer1中声明队列多了exclusive=True参数，表示队列跟consumer同步存在，consumer退出该队列也就随即消失。当启动多个consumer1时，实际产生了多个丢列，每个consumer都是消费自己队列中的，管理控制台显示：<img src="https://images2.imgbox.com/82/08/7j7LNuHq_o.png" alt="这里写图片描述" title=""></p> 
<p>因此可以修改consumer1文件：</p> 
<pre class="prettyprint"><code class="language-python hljs ">
<span class="hljs-comment"># 固定队列名称，去除exclusive=True参数，否则无法启动多个</span>
channel.queue_declare(queue=<span class="hljs-string">'mini_queue'</span>)

channel.queue_bind(
    exchange=<span class="hljs-string">'direct_exchange'</span>, routing_key=<span class="hljs-string">'mini'</span>, queue=<span class="hljs-string">'mini_queue'</span>)

channel.basic_consume(callback, queue=<span class="hljs-string">'mini_queue'</span>)

print(<span class="hljs-string">' [*] Waiting for messages. To exit press CTRL+C'</span>)
channel.start_consuming()</code></pre> 
<p>再次启动两个consumer1执行代码结果如下： <br> <img src="https://images2.imgbox.com/c6/eb/acaeEUDS_o.png" alt="这里写图片描述" title=""></p> 
<p>可以看出，两个consumer1是同时工作消费mini_queue队列中的消息，不会重复消费。</p> 
<h3 id="fanout-demo">fanout demo</h3> 
<p>fanout是一种广播模式，所有处于广播模式exchange中的队列都会收到消息，类似上文方式，启动两个consumer1，一个consumer2，执行producer发送消息，结果如下： <br> <img src="https://images2.imgbox.com/f3/6f/rq2tAeFF_o.png" alt="这里写图片描述" title=""></p> 
<p>此时 consumer1所用队列和consumer2所用队列均收到了5条message，并且consumer1启动了两个，同时消费其队列内容。具体代码内容请参见工程中示例，在管理控制界面，代码中所声明的 fanout_exchange 信息如下： <br> <img src="https://images2.imgbox.com/63/e3/4zP4TQVL_o.png" alt="这里写图片描述" title=""></p> 
<h3 id="topic-demo">topic demo</h3> 
<p>主题形式的实用场景，诸如订阅微信公众号，参与群聊，都是此种形式的消息分发。topic类型的exchange中的routing_key是有一定规范写法的，两种特殊符号：</p> 
<ul><li>‘*’：表示任意一个单词</li><li>‘#’：表示0个或多个单词</li></ul> 
<p>producer代码如下：</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">import</span> pika
<span class="hljs-keyword">import</span> time

credentials = pika.PlainCredentials(<span class="hljs-string">'tester'</span>, <span class="hljs-string">'test_password'</span>)
connection = pika.BlockingConnection(pika.ConnectionParameters(
    <span class="hljs-string">'localhost'</span>, credentials=credentials))
channel = connection.channel()

channel.exchange_declare(exchange=<span class="hljs-string">'topic_exchange'</span>, exchange_type=<span class="hljs-string">'topic'</span>)

routing_mapping = {
    <span class="hljs-number">0</span>: <span class="hljs-string">'tech.front'</span>,
    <span class="hljs-number">1</span>: <span class="hljs-string">'tech.end.t1'</span>,
    <span class="hljs-number">2</span>: <span class="hljs-string">'hr.g1.t1'</span>,
    <span class="hljs-number">3</span>: <span class="hljs-string">'hr.g2.t1'</span>,
    <span class="hljs-number">4</span>: <span class="hljs-string">'hr.g2.t2.'</span>,
}

i = <span class="hljs-number">0</span>
<span class="hljs-keyword">while</span> i &lt; <span class="hljs-number">5</span>:
    time.sleep(<span class="hljs-number">1</span>)
    a = <span class="hljs-string">'{} message'</span>.format(i)
    routing = routing_mapping[i % <span class="hljs-number">5</span>]
    channel.basic_publish(
        exchange=<span class="hljs-string">'topic_exchange'</span>, routing_key=routing, body=a)
    i += <span class="hljs-number">1</span>

connection.close()</code></pre> 
<p>consumer1 代码如下：</p> 
<pre class="prettyprint"><code class="language-python hljs "><span class="hljs-keyword">import</span> pika
<span class="hljs-keyword">import</span> time


<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">callback</span><span class="hljs-params">(ch, method, properties, body)</span>:</span>
    time.sleep(<span class="hljs-number">2</span>)
    print(<span class="hljs-string">"consumer [x] Received %r"</span> % (body,))
    ch.basic_ack(delivery_tag=method.delivery_tag)


credentials = pika.PlainCredentials(<span class="hljs-string">'tester'</span>, <span class="hljs-string">'test_password'</span>)
connection = pika.BlockingConnection(pika.ConnectionParameters(
    <span class="hljs-string">'localhost'</span>, credentials=credentials))

channel = connection.channel()

channel.exchange_declare(exchange=<span class="hljs-string">'topic_exchange'</span>, exchange_type=<span class="hljs-string">'topic'</span>)

result = channel.queue_declare(exclusive=<span class="hljs-keyword">True</span>)

queue_name = result.method.queue

channel.queue_bind(
    exchange=<span class="hljs-string">'topic_exchange'</span>, routing_key=<span class="hljs-string">'*.*.t1'</span>, queue=queue_name)

channel.basic_consume(callback, queue=queue_name)

print(<span class="hljs-string">'Consumer1 waiting for messages. To exit press CTRL+C'</span>)
channel.start_consuming()</code></pre> 
<p>consumer1 订阅了所有 第三级是 t1的路径下的消息，consumer2的 routing_key=’tech.#’表示订阅所有 一级 tech 下的全部消息，producer根据mapping表发送消息，启动consumer1，consumer2执行producer，结果如下： <br> <img src="https://images2.imgbox.com/a8/1b/HZg6yuwH_o.png" alt="这里写图片描述" title=""></p> 
<h2 id="小结">小结</h2> 
<p>至此RabbitMQ的基础框架，各种消息分发形式，python如何使用RabbitMQ通信基本介绍完毕，高阶功能再行规整。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/48048cb8e3150e80114fb9a48c5745da/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43; BMP图片转换为PNG图片</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/54cb3a18742c44bc554b162e5d29db32/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HTML-做一个网页的注册登记表单</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>