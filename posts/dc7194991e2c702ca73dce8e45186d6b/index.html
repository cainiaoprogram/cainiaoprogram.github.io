<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>常用STL的使用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="常用STL的使用" />
<meta property="og:description" content="一、STL是什么 STL是一个标准模板库，是一个高效的C&#43;&#43;程序库qsort()：C标准库的快速排序 二、string char str[12] = &#34;Hello&#34;; char *p = str; *p = &#39;h&#39;; //可以赋值，因为创建了数组 ，在内存中又开辟了一块空间，然后把字符串赋值给该数组，是可以改变的量 char *ptr = &#34;Hello&#34;; *ptr = &#39;h&#39;; //不能赋值。ptr指向内存中的一个临时常量。常量不能赋值 //更标准的用法 const char *cptr = &#34;Hello&#34;; string是一个字符串的类string.h和cstring都不是string类的头文件。都是定义的C风格字符串的一些操作方法，如strcpy()、strlen()等。只是string.h是c语言的头文件，cstring是C&#43;&#43;对应的头文件，是为了和c语言进行兼容。 1.string类的实现 string类的底层是一个字符串指针，即char *m_data; 1）普通构造函数 P68 //构造函数见P68 传入的是一个char *类型的字符串； 如果传入是一个空字符串，那么string就也是一个空字符串&#34;\0&#34;； 如果str是非空，那么私有成员m_data就要预留length&#43;1的长度，&#43;1用来存放&#39;\0&#39;； //指针赋值只是把两个指针指向了同一个位置而已 //创建一个char *类型的变量，m_data需要首先分配内存，然后再拷贝 2）sting的析构函数 string::~string() { if(m_data){ //判断m_data是否为空 delete[] m_data; m_data = nullptr; //删除之后需要赋空指针 } } 3）拷贝构造函数 string::string(const string &amp;s) // 传入的参数是一个常引用。一是保证传入参数不变，二是不进行拷贝，减少栈空间的消耗。（如果不使用引用将造成无限循环） { if(!s.m_data) //m_data的null判断 { m_data = nullptr; } else{ m_data = new char[strlen(s." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/dc7194991e2c702ca73dce8e45186d6b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-21T11:12:15+08:00" />
<meta property="article:modified_time" content="2018-03-21T11:12:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">常用STL的使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <span style="font-size:14pt;"><strong>一、STL是什么</strong></span> 
</div> 
<div> 
 <ul><li><span style="font-size:18.6667px;"><span style="font-size:18.6667px;"><strong>STL是一个标准模板库，是一个高效的C++程序库</strong></span></span></li><li><span style="font-size:10pt;">qsort()：C标准库的快速排序</span></li></ul> 
 <div> 
  <span style="font-size:14pt;"><strong>二、string</strong></span> 
 </div> 
</div> 
<div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
 <div>
   char str[12] = "Hello"; 
 </div> 
 <div>
   char *p = str; 
 </div> 
 <div>
   *p = 'h';            //可以赋值，因为创建了数组 
  <span style="font-family:Monaco;font-size:9pt;">，在内存中又开辟了一块空间</span>，然后把字符串赋值给该数组，是可以改变的量 
 </div> 
 <div> 
  <br> 
 </div> 
 <div>
   char *ptr = "Hello"; 
 </div> 
 <div>
   *ptr = 'h';          //不能赋值。ptr指向内存中的一个临时常量。常量不能赋值 
 </div> 
 <div>
   //更标准的用法 
 </div> 
 <div>
   const char *cptr = "Hello"; 
 </div> 
</div> 
<div> 
 <ul><li><span style="background-color:rgb(255,250,165);"><strong>string是一个字符串的类</strong></span></li><li><span style="background-color:rgb(255,250,165);"><strong>string.h和cstring都不是string类的头文件。都是定义的C风格字符串的一些操作方法，如strcpy()、strlen()等。只是string.h是c语言的头文件，cstring是C++对应的头文件，是为了和c语言进行兼容。</strong></span></li></ul> 
 <div> 
  <span style="font-size:12pt;"><strong>1.string类的实现</strong></span> 
 </div> 
</div> 
<div> 
 <ul><li><span style="background-color:rgb(255,250,165);"><strong>string类的底层是一个字符串指针，即char *m_data;</strong></span></li></ul> 
 <div>
   1）普通构造函数   P68 
 </div> 
</div> 
<div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
 <div>
   //构造函数见P68 
 </div> 
 <div>
   传入的是一个char *类型的字符串； 
 </div> 
 <div>
   如果传入是一个空字符串，那么string就也是一个空字符串"\0"； 
 </div> 
 <div>
   如果str是非空，那么私有成员m_data就要预留length+1的长度，+1用来存放'\0'； 
 </div> 
 <div>
   //指针赋值只是把两个指针指向了同一个位置而已 
 </div> 
 <div> 
  <span style="background-color:rgb(255,250,165);">//创建一个char *类型的变量，m_data需要首先分配内存，然后再拷贝</span> 
 </div> 
</div> 
<div>
  2）sting的析构函数 
</div> 
<div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
 <div>
   string::~string() 
 </div> 
 <div>
   { 
 </div> 
 <div>
       if(m_data){                //判断m_data是否为空 
 </div> 
 <div>
           delete[] m_data; 
 </div> 
 <div>
           m_data = nullptr;      //删除之后需要赋空指针 
  <br> 
 </div> 
 <div>
       } 
  <br> 
 </div> 
 <div>
   } 
 </div> 
</div> 
<div>
  3）拷贝构造函数 
</div> 
<div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
 <div>
   string::string(const string &amp;s)  // 
  <span style="background-color:rgb(255,250,165);">传入的参数是一个常引用。一是保证传入参数不变，二是不进行拷贝，减少栈空间的消耗。（如果不使用引用将造成无限循环）</span> 
 </div> 
 <div>
   { 
 </div> 
 <div>
       if(!s.m_data)                //m_data的null判断 
 </div> 
 <div>
       { 
 </div> 
 <div>
           m_data = nullptr; 
  <br> 
 </div> 
 <div>
       } 
  <br> 
 </div> 
 <div>
       else{ 
  <br> 
 </div> 
 <div>
            
  <strong><span style="background-color:rgb(255,250,165);">m_data = new char[strlen(s.m_data)+1];    //开辟空间</span><br></strong> 
 </div> 
 <div> 
  <strong>        <span style="background-color:rgb(255,250,165);">strcpy(m_data,s.m_data);                  //复制</span></strong> 
  <br> 
 </div> 
 <div> 
  <strong><span style="background-color:rgb(255,250,165);">    }</span></strong> 
 </div> 
 <div>
   } 
 </div> 
</div> 
<div>
  4）赋值函数 
</div> 
<div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
 <div>
   string &amp;string::operator=(const string &amp;s)    
  <span style="background-color:rgb(255,250,165);">//返回值是引用，而参数仍是常引用</span> 
 </div> 
 <div>
   { 
 </div> 
 <div>
       if(this != &amp;s){                            
  <span style="background-color:rgb(255,250,165);">//检查自赋值</span> 
 </div> 
 <div>
           delete[] m_data;                      
  <span style="background-color:rgb(255,250,165);">//释放原有的内存资源</span> 
  <br> 
 </div> 
 <div>
           if(!s.m_data){                        //对m_data做null判断 
 </div> 
 <div>
               m_data = nullptr; 
  <br> 
 </div> 
 <div>
           } 
  <br> 
 </div> 
 <div>
           else{ 
 </div> 
 <div>
               m_data = new char[strlen(s.m_data)+1]; 
  <br> 
 </div> 
 <div>
               strcpy(m_data,s.m_data); 
  <br> 
 </div> 
 <div>
           } 
  <br> 
 </div> 
 <div>
       } 
  <br> 
 </div> 
 <div>
       return *this;                              
  <span style="background-color:rgb(255,250,165);">//返回*this</span> 
  <br> 
 </div> 
 <div>
   } 
 </div> 
</div> 
<div>
  5）字符串连接 
</div> 
<div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
 <div>
   //三种情况：1.传入指针为空 2.本身内容为空 3.两者均不为空 
 </div> 
 <div>
   string &amp;string::operator+(const string &amp;s) 
 </div> 
 <div>
   { 
 </div> 
 <div>
       string newstring;        
  <span style="color:#FF0000;"><span style="background-color:rgb(255,250,165);">//需要新建一个对象</span></span> 
  <br> 
 </div> 
 <div>
       if(!s.m_data)            //检查传入指针为空 
  <br> 
 </div> 
 <div>
           newstring = this; 
  <br> 
 </div> 
 <div>
       else if(!m_data)         // 
  <br> 
 </div> 
 <div>
           newstring = s; 
  <br> 
 </div> 
 <div>
       else{ 
 </div> 
 <div>
           newstring.m_data = new char[strlen(m_data)+strlen(s.m_data)+1]; 
  <br> 
 </div> 
 <div>
           strcpy(newstring.m_data,m_data); 
  <br> 
 </div> 
 <div>
           strcat(newstring.m_data,s.m_data); 
  <br> 
 </div> 
 <div>
       } 
 </div> 
 <div> 
  <br> 
 </div> 
 <div>
       return newstring;        //返回新建的对象 
  <br> 
 </div> 
 <div>
   } 
 </div> 
</div> 
<div>
  6）判断相等 
</div> 
<div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
 <div>
   //先判断长度是否相等，再判断内容是否相等 
 </div> 
 <div>
   bool string::operator==(const string &amp;s) 
 </div> 
 <div>
   { 
 </div> 
 <div>
       if(strlen(m_data) != strlen(s.m_data)){  
 </div> 
 <div>
           return false; 
  <br> 
 </div> 
 <div>
       } 
  <br> 
 </div> 
 <div>
       else{ 
 </div> 
 <div>
           return strcmp(m_data,s.m_data)?false:true; 
  <br> 
 </div> 
 <div>
       } 
  <br> 
 </div> 
 <div>
   } 
 </div> 
</div> 
<div>
  7）返回长度 
</div> 
<div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
 <div>
   int string::getlength() 
 </div> 
 <div>
   { 
 </div> 
 <div>
       return strlen(m_data); 
  <br> 
 </div> 
 <div>
   } 
 </div> 
</div> 
<div> 
 <span style="font-size:12pt;"><strong>2.string声明方式 P70</strong></span> 
</div> 
<div> 
 <span style="font-size:12pt;"><strong>3.C++字符串（string）和C字符串的转换</strong></span> 
</div> 
<div> 
 <ul><li><span style="font-size:10pt;">C++字符串转换成对应的C字符串的方法：使用</span><span style="font-size:10pt;background-color:rgb(255,250,165);color:rgb(255,0,0);"><strong>data()、c_str()、copy()</strong></span><span style="font-size:10pt;">来实现。</span></li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div> 
   <span style="color:#FF0000;"><span style="background-color:rgb(255,250,165);">注意：</span></span> 
  </div> 
  <div>
    1.data和c_str在c++11之后好像就没有区别了 
  </div> 
  <div>
    2.c_str()语句可以生成一个const char *指针，并指向空字符的数组。这个数组的数据是临时的，当有一个改变这些数据的成员函数被调用之后，其中的数据会失效 
  </div> 
  <div> 
   <span style="font-size:10pt;"><span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,255);"><em>string</em></span> <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,128);">s</span> <span style="min-height:11pt;font-family:NSimSun;">=</span> <span style="min-height:11pt;font-family:NSimSun;color:rgb(163,21,21);">"Hello"</span><span style="min-height:11pt;font-family:NSimSun;">;</span></span> 
  </div> 
  <div style="min-height:11pt;"> 
   <span style="font-size:10pt;"><span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,255);">const</span> <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,255);">char</span> <span style="min-height:11pt;font-family:NSimSun;">*</span><span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,128);">cptr</span> <span style="min-height:11pt;font-family:NSimSun;">=</span> <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,128);">s</span><span style="min-height:11pt;font-family:NSimSun;">.</span><span style="min-height:11pt;font-family:NSimSun;color:rgb(136,0,0);"><em>data</em></span><span style="min-height:11pt;font-family:NSimSun;">();</span></span> 
  </div> 
  <div style="min-height:11pt;"> 
   <span style="font-size:10pt;"><span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,128);"><em>cout</em></span> <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,128,128);">&lt;&lt;</span> <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,128);">cptr</span> <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,128,128);">&lt;&lt;</span> <span style="min-height:11pt;font-family:NSimSun;color:rgb(136,0,0);"><em>endl</em></span><span style="min-height:11pt;font-family:NSimSun;">;</span></span> 
  </div> 
  <div style="min-height:11pt;"> 
   <span style="font-size:10pt;"><span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,128);">s</span> <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,128,128);">=</span> <span style="min-height:11pt;font-family:NSimSun;color:rgb(163,21,21);">"World"</span><span style="min-height:11pt;font-family:NSimSun;">;</span></span> 
  </div> 
  <div style="min-height:11pt;"> 
   <span style="font-size:10pt;"><span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,128);"><em>cout</em></span> <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,128,128);">&lt;&lt;</span> <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,128);">cptr</span> <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,128,128);">&lt;&lt;</span> <span style="min-height:11pt;font-family:NSimSun;color:rgb(136,0,0);"><em>endl</em></span><span style="min-height:11pt;font-family:NSimSun;">;</span></span> 
  </div> 
  <div style="min-height:11pt;"> 
   <span style="font-size:10pt;"><span style="min-height:11pt;font-family:NSimSun;background-color:rgb(255,250,165);"><strong>//输出为：</strong></span></span> 
  </div> 
  <div style="min-height:11pt;"> 
   <span style="font-family:NSimSun;"><span style="font-size:13.3333px;background-color:rgb(255,250,165);"><strong>Hello</strong></span></span> 
  </div> 
  <div style="min-height:11pt;"> 
   <span style="font-family:NSimSun;"><span style="font-size:13.3333px;background-color:rgb(255,250,165);"><strong>World</strong></span></span> 
  </div> 
  <div style="min-height:11pt;"> 
   <span style="font-family:NSimSun;"><span style="font-size:13.3333px;background-color:rgb(255,250,165);"><strong>//所以要么现用现转换，要么复制后再转换</strong></span></span> 
  </div> 
 </div> 
</div> 
<div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
 <div> 
  <span style="background-color:rgb(255,250,165);">copy(p,n,size_type_off = 0)</span> 
 </div> 
 <div> 
  <span style="background-color:rgb(255,250,165);">//从string拷贝到指针p中，拷贝n个字符，默认从首字符开始，也可以由<span style="font-family:Monaco;font-size:9pt;">size_type_off来进行指定。返回拷贝字符的个数，可以通过返回值来添加空字符'\0'</span></span> 
 </div> 
 <div> 
  <span style="font-family:Monaco;font-size:9pt;background-color:rgb(255,250,165);"><strong>//用户确保p指向控件足够用来保存n个字符</strong></span> 
 </div> 
 <div> 
  <span style="font-family:Monaco;font-size:9pt;background-color:rgb(255,250,165);"><strong><span style="color:#FF0000;">//string::npos：指向string的尾置尾置或者表示string的大小或结束位置</span></strong></span> 
 </div> 
</div> 
<div> 
 <span style="font-size:12pt;"><strong>4.C++字符串（string）和int类型的转换</strong></span> 
</div> 
<div> 
 <span style="font-size:10pt;"><strong>1）int转string</strong></span> 
</div> 
<div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
 <div> 
  <strong><span style="background-color:rgb(255,250,165);font-family:Monaco;"><span style="font-size:12pt;">//1.使用snprintf</span></span></strong> 
 </div> 
 <div> 
  <strong><span style="background-color:rgb(255,250,165);font-family:Monaco;"><span style="font-size:12pt;">//snprintf只能转换到C风格字符串</span></span></strong> 
 </div> 
 <div> 
  <span style="font-family:Monaco;font-size:9pt;">int length = snprintf(p,n,%format,i);</span> 
 </div> 
 <div> 
  <span style="font-family:Monaco;font-size:9pt;">//p为指向char的指针，即char *</span> 
 </div> 
 <div> 
  <span style="font-family:Monaco;font-size:9pt;">//n为输出到p的字符个数</span> 
 </div> 
 <div> 
  <span style="font-family:Monaco;font-size:9pt;">//format为对i进行的格式转换</span> 
 </div> 
 <div> 
  <span style="font-family:Monaco;font-size:9pt;">//i为要转换的整形变量</span> 
 </div> 
 <div> 
  <span style="color:rgb(255,0,0);font-family:Monaco;font-size:9pt;">//注意先进行格式转换，再按照n的值来选择位数输出</span> 
 </div> 
 <div> 
  <span style="color:rgb(255,0,0);font-family:Monaco;font-size:9pt;">//例子</span> 
 </div> 
 <div> 
  <span style="color:rgb(255,0,0);font-family:Monaco;font-size:9pt;">static inline std::string i64tostr(long long a)</span> 
 </div> 
 <div> 
  <span style="color:rgb(255,0,0);font-family:Monaco;font-size:9pt;">{<!-- --></span> 
 </div> 
 <div> 
  <span style="color:rgb(255,0,0);font-family:Monaco;font-size:9pt;">    char buf[32];<br></span> 
 </div> 
 <div> 
  <span style="color:rgb(255,0,0);font-family:Monaco;font-size:9pt;">    snprintf(buf,sizeof(buf),"%lld",a);<br></span> 
 </div> 
 <div> 
  <span style="color:rgb(255,0,0);font-family:Monaco;font-size:9pt;">    return std::string(buf);<br></span> 
 </div> 
 <div> 
  <span style="color:rgb(255,0,0);font-family:Monaco;font-size:9pt;">}</span> 
 </div> 
 <div> 
  <span style="font-family:Monaco;color:#000000;font-size:12pt;"><span style="background-color:rgb(255,250,165);"><strong>//2.使用to_string</strong></span></span> 
 </div> 
 <div> 
  <span style="font-family:Monaco;color:#000000;">string s = to_string(i);</span> 
 </div> 
 <div> 
  <span style="font-family:Monaco;color:#000000;">//i为要进行转换的整形变量</span> 
 </div> 
 <div> 
  <span style="font-family:Monaco;background-color:rgb(255,250,165);"><span style="font-size:12pt;"><strong>//3.使用stringstream（准确的说是ostringstream和.str()结合）</strong></span></span> 
 </div> 
 <div> 
  <span style="font-family:Monaco;font-size:9pt;">int tmp = 10;</span> 
 </div> 
 <div> 
  <span style="font-family:Monaco;font-size:9pt;">ostringstream os;</span> 
 </div> 
 <div> 
  <span style="font-family:Monaco;font-size:9pt;">os &lt;&lt; tmp;</span> 
 </div> 
 <div> 
  <span style="font-family:Monaco;font-size:9pt;">string str = os.str();</span> 
 </div> 
 <div> 
  <span style="font-family:Monaco;font-size:9pt;">//str的值即是10</span> 
 </div> 
</div> 
<div> 
 <span style="font-size:10pt;">2）string转int的方法</span> 
</div> 
<div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
 <div> 
  <span style="font-size:12pt;background-color:rgb(255,250,165);"><strong>//1.<span style="color:#FF0000;">使用strtol、strtoll、strtoul和strtoull函数，其函数原型如下</span></strong></span> 
 </div> 
 <div> 
  <span style="background-color:rgb(255,250,165);">long int strtol(const char *nptr,char **endptr,int base);</span> 
 </div> 
 <div>
   //四个函数的函数原型都差不多，除了返回类型分别问long int,long long int,unsigned long int和unsigned long long int 
 </div> 
 <div>
   //形参nptr为要转换的字符串的的指针，endptr为转换到的位置，base为输出的进制 
 </div> 
 <div>
   //函数会 
  <span style="background-color:rgb(255,250,165);">跳过最前面的空格字符串</span>， 
  <span style="background-color:rgb(255,250,165);">遇上数字或者正负号才开始转换。遇到非数字或者空字符才结束</span> 
 </div> 
 <div>
   //nptr以0x开头，把nptr当作16进制处理，以0开头，则当作8进制处理 
 </div> 
 <div>
   //具体见P75 
 </div> 
 <div> 
  <span style="color:#FF0000;">//这种方法需要先将string转换称为char *，然后再转换称为数字</span> 
 </div> 
 <div> 
  <span style="color:#000000;">//将C++字符串转换成10进制数字的通用函数</span> 
 </div> 
 <div> 
  <span style="color:rgb(255,0,0);"><strong>static inline int64_t strtoint(const str::string &amp;s)</strong></span> 
 </div> 
 <div> 
  <span style="color:#FF0000;"><strong>{<!-- --></strong></span> 
 </div> 
 <div> 
  <span style="color:#FF0000;"><strong>    return strtol(s.c_str(),0,10);<br></strong></span> 
 </div> 
 <div> 
  <span style="color:#FF0000;"><strong>}</strong></span> 
 </div> 
 <div> 
  <span style="font-size:12pt;"><span style="background-color:rgb(255,250,165);">//2.使用stringstream（准确的说是istringstream）</span></span> 
 </div> 
 <div>
   string str = "11 12 32 14 15"; 
 </div> 
 <div>
   istringstream is(str); 
 </div> 
 <div>
   int tmp; 
 </div> 
 <div>
   while(is &gt;&gt; tmp) 
 </div> 
 <div>
       cout &lt;&lt; tmp &lt;&lt; " "; 
  <br> 
 </div> 
 <div>
   //tmp的值就可以分别取的11，12，32，14，15 
 </div> 
</div> 
<div> 
 <span style="font-size:14pt;"><strong>三、vector</strong></span> 
</div> 
<div> 
 <span style="font-weight:bold;">1.vector是什么</span> 
</div> 
<div> 
 <ul><li>Vector是顺序容器，是一个动态数组，支持随机存取、插入、删除、查找等操作，在内存中是一块连续的空间。在原有空间不够情况下自动分配空间。vector随机存取效率高，但是在vector插入元素，需要移动的数目多，效率低下。<br></li><li><span style="font-size:10pt;">vector是线性容器，它的元素严格按照线性顺序排序，和动态数组很相似</span></li><li><span style="font-size:10pt;">它的元素储存在一块连续的内存区域中</span></li><li><span style="font-size:10pt;">不仅可以使用迭代器，还可以使用指针偏移的方式（即可以使用下标访问）</span></li><li><span style="font-size:10pt;">vector可以自动增长或缩小储存空间</span></li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div>
    优点： 
  </div> 
  <div>
    1.下标访问 
  </div> 
  <div>
    2.迭代器访问 
  </div> 
  <div>
    3.容器末尾增加删除元素 
  </div> 
  <div>
    缺点： 
  </div> 
  <div>
    1.在其他位置添加删除元素比较慢 
  </div> 
  <div>
    2.迭代器和引用没有list支持的好 
  </div> 
  <div>
    3.重新分配内存会影响程序的性能 
  </div> 
 </div> 
</div> 
<div> 
 <ul><li><span style="font-size:10pt;"><span style="font-size:10pt;background-color:rgb(255,250,165);"><strong>容器的大小指元素的个数，容量是分配的内存大小，容量一般不小于大小。size返回容器的大小（元素的个数），capacity返回容器的容量（占用内存的大小）</strong></span></span><br></li></ul> 
 <div> 
  <span style="font-weight:bold;">2.vector的查增删</span> 
 </div> 
</div> 
<div> 
 <span style="font-weight:bold;">1）vector的初始化和遍历</span> 
</div> 
<div> 
 <ul><li>遍历可以使用迭代器</li><li>使用for_each遍历vector</li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div>
    void print(int n) 
  </div> 
  <div>
    { 
  </div> 
  <div>
        cout &lt;&lt; n &lt;&lt; " "; 
   <br> 
  </div> 
  <div>
    } 
  </div> 
  <div> 
   <br> 
  </div> 
  <div>
    vector&lt;int&gt; ivec = {1,2,3,4,5}; 
  </div> 
  <div> 
   <span style="background-color:rgb(255,250,165);">for_each(ivec.begin(),ivec.end(),print);</span> 
  </div> 
 </div> 
</div> 
<div> 
 <ul><li><span style="background-color:rgb(255,250,165);"><strong>使用sort函数对存放有结构体的vector进行排序，</strong></span><span style="background-color:rgb(255,250,165);color:rgb(255,0,0);"><strong>需要重载结构体的比较运算符    P80</strong></span></li><li>除了在结构体内部重载比较函数之外，也可以在结构体之外定义比较函数    P81</li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div> 
   <span style="color:#FF0000;">bool cmp(Rect item1,Rect item2){... ...}  //定义的比较函数</span> 
  </div> 
  <div> 
   <span style="color:#FF0000;">sort(vec.begin(),vec.end(),cmp);          //使用sort进行排序，使用了定义的比较函数cmp</span> 
  </div> 
 </div> 
</div> 
<div> 
 <span style="font-weight:bold;">2）vector的查找</span> 
</div> 
<div> 
 <ul><li>使用find函数在vector中查找元素，注意返回值是一个迭代器</li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <span style="color:#FF0000;">vector&lt;int&gt;::iterator iter = find(vec.begin(),vec.end(),3);     //在vector&lt;int&gt;中查找3</span> 
 </div> 
</div> 
<div> 
 <span style="font-weight:bold;">3）vector的删除</span> 
</div> 
<div> 
 <ul><li>使用erase或pop_back删除数据</li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div>
    //使用erase 
  </div> 
  <div> 
   <span style="color:#000000;">for(vector&lt;int&gt;::iterator iter= vec.begin();iter != vec.end();)</span> 
  </div> 
  <div> 
   <span style="color:#000000;">{<!-- --></span> 
  </div> 
  <div> 
   <span style="color:#000000;">    if(*iter == 3)<br></span> 
  </div> 
  <div> 
   <span style="color:#000000;">        iter = vec.erase(iter);<br></span> 
  </div> 
  <div> 
   <span style="color:#000000;">    else<br></span> 
  </div> 
  <div> 
   <span style="color:rgb(0,0,0);">    </span> 
   <span style="color:#000000;">    iter++;        </span> 
   <span style="color:rgb(0,0,0);">    </span> 
   <span style="color:#000000;">   </span> 
   <span style="color:#FF0000;">//不删除的时候才++</span> 
   <br> 
  </div> 
  <div> 
   <span style="color:#000000;">}</span> 
  </div> 
  <div> 
   <span style="color:#FF0000;">//erase返回的是删除的元素的后一个迭代器</span> 
  </div> 
  <div> 
   <span style="color:#000000;">//P83   好好体会这段程序</span> 
  </div> 
 </div> 
</div> 
<div> 
 <ul><li>pop_back则是弹出最后一个数据</li></ul> 
</div> 
<div> 
 <span style="font-weight:bold;">4）vector的增加</span> 
</div> 
<div> 
 <ul><li>使用insert或者push_back来增加元素，其中insert是插入元素到某一个位置，而push_back是在最后添加一个元素</li><li>P84 insert的几种函数原型，<span style="background-color:rgb(255,250,165);"><strong>注意插入发生在指定位置（迭代器）的前面，比如指定插入位置是尾后迭代器，那么会在vec的最后插入元素（尾后迭代器前面）</strong></span></li><li><span style="background-color:rgb(255,250,165);"><span style="font-weight:bold;">注意删除的是迭代器指出的区间，则都是左闭右开的删除   P85</span></span></li><li>可以使用vec.clear()来清空vect<span style="background-color:rgb(255,250,165);"><strong>or</strong></span></li></ul> 
</div> 
<div> 
 <span style="font-weight:bold;">3.vector的内存管理与效率</span> 
</div> 
<div> 
 <span style="font-weight:bold;">1）使用reserve()函数提前设定容量大小</span> 
</div> 
<div> 
 <ul><li>为了支持随机访问，vector内部是通过动态数组的方式来实现的</li><li><span style="color:rgb(255,0,0);"><strong>总是按照指数边界来增大其内部缓冲区的，即重新分配的大小为1.5~2倍，一般就是2倍。一般都是重新申请一块更大的新内存，并把现有的元素逐个复制过去，同时销毁旧内存。所有迭代器也不能使用了，需要及时更新迭代器</strong></span></li><li>其访问速度和一般数组相比，只有在发生重新分配的时候，性能才会下降。因此如果有大量数据需要push_back，应该使用reserve()函数提前设定其容量大小</li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div>
    //几个相关的成员函数  P86 
  </div> 
  <div>
    size()：容器中含有多少个元素 
  </div> 
  <div>
    capacity()：容器在已经分配的内存中可以容纳多少个元素 
  </div> 
  <div>
    resize(size_type n)：强制容器可以容纳n个元素， 
   <span style="background-color:rgb(255,250,165);">主要是n大于小于当前容量的情况</span> 
  </div> 
  <div>
    reserve(size_type n)：强制容器把容量改为不小于n 
   <span style="font-family:Monaco;font-size:9pt;">，</span> 
   <span style="background-color:rgb(255,250,165);font-family:Monaco;font-size:9pt;"><strong>主要是n大于小于当前容量的情况</strong></span> 
  </div> 
 </div> 
</div> 
<div> 
 <ul><li>只要有元素需要插入且容器的容量不足时就会发生重新分配，<span style="background-color:rgb(255,250,165);"><strong>这一过程包括维护的原始内存的分配和回收、对象的拷贝和析构、迭代器，指针和引用的失效</strong></span></li></ul> 
 <div> 
  <span style="font-weight:bold;">2）使用“交换技巧”来休整vector过剩空间和内存</span> 
 </div> 
</div> 
<div> 
 <ul><li>即收缩到合适：</li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div> 
   <span style="color:#FF0000;">vector&lt;int&gt;(ivec).swap(ivec)；</span> 
  </div> 
  <div> 
   <span style="color:#FF0000;">//把ivec收缩到了合适的大小</span> 
  </div> 
  <div> 
   <span style="color:#FF0000;">//使用ivec构造了一个临时的vector&lt;int&gt;变量</span> 
  </div> 
  <div> 
   <span style="color:#FF0000;">//然后交换ivec和这个临时变量（其实交换的是指针）</span> 
  </div> 
  <div> 
   <span style="color:#FF0000;">//语句结束，临时变量指向的内存被释放（即之前有空余的内存），而ivec的大小被调整到了合适</span> 
  </div> 
 </div> 
</div> 
<div> 
 <span style="font-weight:bold;">3）用swap方法强行释放vector所占的内存</span> 
</div> 
<div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
 <div>
   vector&lt;int&gt; v = {1,2,3,4,5,6}; 
 </div> 
 <div>
   vector&lt;int&gt;().swap(x); 
 </div> 
 <div>
   //把vector和一个空临时变量交换，语句结束时临时变量被释放，即原来v的内存空间被释放。v现在为空 
 </div> 
</div> 
<div> 
 <span style="font-weight:bold;">4.vector类的简单实现</span> 
</div> 
<div> 
 <ul><li><span style="font-weight:bold;">assert(表达式)：断言：表达式为真则继续执行余下的语句，表达式为假那么就退出程序，并输出一个错误信息</span></li></ul> 
</div> 
<div> 
 <span style="font-size:14pt;"><strong>四、map</strong></span> 
</div> 
<div> 
 <span style="font-weight:bold;">1.map是什么</span> 
</div> 
<div> 
 <span style="font-size:10pt;"><strong>1）map的本质</strong></span> 
</div> 
<div> 
 <ul><li><span style="font-size:10pt;">map本质是一类关联容器，属于模板类关联的本质在于元素的值与某个特定的键相关联</span></li><li><span style="font-size:10pt;">增加和删除节点对节点的影响很小</span></li><li><span style="font-size:10pt;">对于迭代器来说，</span><span style="font-size:10pt;color:rgb(255,0,0);"><strong>不能修改键值，只能修改其对应的实值</strong></span></li><li><span style="font-size:10pt;">map内部自建一棵红黑树（非严格意义的平衡二叉树），所以在map内部所有的数据都是有序的</span></li></ul> 
 <div> 
  <span style="font-size:10pt;"><strong>2）map的功能</strong></span> 
 </div> 
</div> 
<div> 
 <ul><li>自动建立key-value的一一对应的关系</li><li>map&lt;key,value&gt;，其中key必须要能够支持&lt;操作符（比较操作）</li><li>根据key值进行快速查找，查找的时间复杂度是log(n)</li></ul> 
 <div> 
  <span style="font-weight:bold;">2.map的查增删</span> 
 </div> 
</div> 
<div> 
 <span style="font-size:10pt;"><strong>1）map的插入</strong></span> 
</div> 
<div> 
 <ul><li><span style="font-size:13.3333px;">map插入：使用insert函数插入pair数据、使用insert函数插入value_type数据和用数组方式插入</span></li><li><span style="font-size:13.3333px;background-color:rgb(255,250,165);"><span style="font-size:13.3333px;"><strong>value_type：模板类的迭代器所指向的对象的类型</strong></span></span></li><li><span style="font-size:13.3333px;background-color:rgb(255,250,165);"><span style="font-size:13.3333px;"><strong>使用insert插入已有关键字的元素，插入操作会失败，map不会产生变化</strong></span></span></li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div> 
   <span style="color:#000000;">//insert插入pair数据</span> 
  </div> 
  <div> 
   <span style="color:#000000;">map&lt;int,string&gt; mapItem1;</span> 
  </div> 
  <div> 
   <span style="color:#000000;">mapItem1.insert(pair&lt;int,string&gt;(1,"Hello"));</span> 
  </div> 
  <div> 
   <span style="color:#000000;">或mapItem1.insert(make_pair(1,"World"));</span> 
  </div> 
  <div> 
   <span style="color:#000000;"><br></span> 
  </div> 
  <div> 
   <span style="color:#000000;">//insert插入value_type数据</span> 
  </div> 
  <div> 
   <span style="color:#000000;">mapItem1.insert(</span> 
   <span style="color:#FF0000;">map&lt;int,string&gt;::value_type</span> 
   <span style="color:#000000;">(1,"nihao"));</span> 
  </div> 
  <div> 
   <span style="color:#000000;"><br></span> 
  </div> 
  <div> 
   <span style="color:#000000;">//insert的返回值是一个pair类型，其中第一个元素是map的一个迭代器表示插入的位置，而</span> 
   <span style="color:#FF0000;">第二个元素表示是否插入成功</span> 
  </div> 
  <div> 
   <span style="color:#FF0000;">pair&lt;map&lt;int,string&gt;::iterator,bool&gt;</span> 
   <span style="color:#000000;">insert_resu = mapItem1.insert(make_pair(1,"kenijiwa"));</span> 
  </div> 
 </div> 
</div> 
<div> 
 <ul><li>数组方式插入元素，遇到相同关键字时则直接覆盖</li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div>
    //使用数组方式插入 
  </div> 
  <div>
    map&lt;int,string&gt; mapItem2; 
  </div> 
  <div>
    mapItem2[1] = "Hello"; 
  </div> 
  <div>
    mapItem2[1] = "World"; 
  </div> 
  <div>
    mapItem2[2] = "nihao"; 
  </div> 
  <div>
    //插入的结果为world和你好，hello被覆盖 
  </div> 
 </div> 
</div> 
<div> 
 <span style="font-size:10pt;"><strong>2）map的遍历</strong></span> 
</div> 
<div> 
 <ul><li>三种方法：使用前向迭代器、<span style="color:rgb(255,0,0);">反向迭代器</span>和<span style="color:rgb(65,173,28);">数组方式遍历（应该不好用数组进行遍历）</span></li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div>
    //前向迭代器即是begin()、end() 
  </div> 
  <div>
    //反向迭代器rbegin()、rend() 
  </div> 
  <div>
    //对mapItem1进行反向迭代，从容器尾开始处理直到容器头 
  </div> 
  <div>
    for( 
   <span style="color:#FF0000;">map&lt;int,string&gt;::reverse_iterator riter = mapItem1.rbegin();riter != mapItem1.rend();<span style="background-color:rgb(255,250,165);">riter++</span></span>)    //注意这里迭代器仍然是++ 
  </div> 
  <div>
    {... ...} 
  </div> 
 </div> 
</div> 
<div> 
 <span style="font-size:10pt;"><strong>3）map的查找</strong></span> 
</div> 
<div> 
 <ul><li><span style="font-size:13.3333px;">两种方法：使用count函数来判定关键字是否出现、使用find函数来查找关键字的位置</span></li><li><span style="font-size:13.3333px;"><span style="font-size:13.3333px;color:rgb(255,0,0);">count：判断关键字是否出现，但是无法返回关键字出现的位置，当关键字出现时返回1，未出现返回0</span></span></li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div>
    mapItem1.count(1);        //返回1 
  </div> 
  <div>
    mapItem1.count(5);        //返回0 
  </div> 
 </div> 
</div> 
<div> 
 <ul><li><span style="font-size:13.3333px;">find：定位数据出现的位置，返回一个迭代器。数据出现时，返回数据所在位置的迭代器，否则返回尾后迭代器，即map.end()。</span></li></ul> 
 <div> 
  <span style="font-size:10pt;"><strong>4）map的删除</strong></span> 
 </div> 
</div> 
<div> 
 <ul><li><span style="font-size:13.3333px;"><span style="font-size:13.3333px;"><strong>使用erase来删除函数</strong></span></span></li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div> 
   <span style="font-size:13.3333px;">//三种函数原型</span> 
  </div> 
  <div> 
   <span style="font-size:13.3333px;">size_type map.erase(k);        //删除键值为k的元素，返回删除的元素个数</span> 
  </div> 
  <div>
    void map.erase(p);             //删除迭代器p所指的元素， 
   <span style="color:#FF0000;">p必须指向map中的元素不能越界</span> 
  </div> 
  <div> 
   <span style="color:#000000;">void map.erase(b,e);           //删除迭代器[b,e)所指范围内的元素，</span> 
   <span style="color:#FF0000;">必须是一个有效范围</span> 
  </div> 
  <div> 
   <span style="color:#FF0000;">//</span> 
  </div> 
  <div> 
   <span style="color:#000000;">for(map&lt;int,string&gt;::iterator iter = mapItem1.begin();iter != mapItem1.end();){<!-- --></span> 
  </div> 
  <div> 
   <span style="color:#000000;">    if((<span style="font-family:Monaco;font-size:9pt;">*iter</span>).second == "Hello"){<!-- --></span> 
  </div> 
  <div> 
   <span style="color:#000000;">        mapItem1.erase(iter++);                //这样使用才是正确的，删除之后迭代器本来应该要失效的，但是这里迭代器能够自动指向下一个元素<br></span> 
  </div> 
  <div> 
   <span style="color:#000000;">    }<br></span> 
  </div> 
  <div> 
   <span style="color:#000000;">}</span> 
  </div> 
 </div> 
</div> 
<div> 
 <span style="font-size:10pt;"><strong>5）map的排序</strong></span> 
</div> 
<div> 
 <ul><li><span style="font-size:13.3333px;">map的默认是按照key从小到大排序的</span></li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div>
    //map的STL定义 
  </div> 
  <div>
    template&lt;class Key,class T, 
   <span style="color:#FF0000;">class Compare = less&lt;Key&gt;</span>, 
   <span style="color:#41AD1C;">class Allocator = allocator&lt;pair&lt;const Key,T&gt;&gt;</span>&gt; class map; 
  </div> 
  <div>
    //其中第三个参数是一个函数对象，有一个默认值less&lt;Key&gt;。函数对象本质上是对()运算符的重载 
  </div> 
 </div> 
</div> 
<div> 
 <ul><li><span style="font-size:13.3333px;">binary_function是二元函数对象的模板类，也是一个基类，本身不重载（）运算符，交给派生类完成</span></li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div>
    template&lt;class Arg1,class Arg2,class Result&gt; 
  </div> 
  <div>
    struct binary_function 
  </div> 
  <div>
    { 
  </div> 
  <div>
        typedef Arg1  
   <span style="white-space:pre-wrap;color:rgb(0,0,0);font-family:'Courier New';line-height:1.5;">first_argument_type;</span> 
  </div> 
  <div>
         
   <span style="font-family:Monaco;font-size:9pt;">typedef Arg2 </span> 
   <span style="white-space:pre-wrap;color:rgb(0,0,0);font-family:'Courier New';line-height:1.5;">second_argument_type</span> 
   <span style="white-space:pre-wrap;color:rgb(0,0,0);font-family:'Courier New';line-height:1.5;font-size:9pt;">;</span> 
  </div> 
  <div> 
   <span style="white-space:pre-wrap;color:rgb(0,0,0);font-family:'Courier New';line-height:1.5;">    typedef Result result_type;</span> 
  </div> 
  <div>
    }; 
  </div> 
 </div> 
</div> 
<div> 
 <ul><li><span style="font-size:13.3333px;">map的定义的第三个参数有一个默认参数less，定义如下</span></li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div>
    template&lt;class T&gt;struct less: 
   <span style="color:#FF0000;">binary_function&lt;T,T,bool&gt;        //这里是继承了基类binary_function</span> 
  </div> 
  <div>
    { 
  </div> 
  <div>
        bool operator()(const T &amp;x,const T&amp; y)const 
   <br> 
  </div> 
  <div>
        { 
  </div> 
  <div>
            return x &lt; y; 
   <br> 
  </div> 
  <div>
        } 
   <br> 
  </div> 
  <div>
    }; 
  </div> 
 </div> 
</div> 
<div> 
 <ul><li><span style="font-size:13.3333px;color:rgb(255,0,0);">同样定义了一个greater&lt;key&gt;，所以如果要</span><span style="font-size:14pt;background-color:rgb(255,250,165);"><span style="font-size:14pt;color:rgb(255,0,0);"><strong>让map从大到小排序</strong></span></span><span style="font-size:13.3333px;color:rgb(255,0,0);">就要调用这个函数来定义map</span></li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div> 
   <span style="color:#FF0000;">//greater定义在头文件&lt;functional&gt;中</span> 
  </div> 
  <div>
    #include &lt;functional&gt; 
  </div> 
  <div>
    map&lt;string,int, 
   <span style="color:#FF0000;">greater&lt;string&gt;</span>&gt; mapItem3;            //元素按key从大到小排序, 
   <span style="color:#FF0000;">great&lt;key&gt;中的key值只能够使用键值</span> 
  </div> 
 </div> 
</div> 
<div> 
 <ul><li><span style="font-size:13.3333px;">可以自己定义一个函数对象的类，让map按照我们希望的方式进行排序</span></li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div> 
   <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,255);font-size:9pt;">//先定义比较的函数对象</span> 
  </div> 
  <div> 
   <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,255);font-size:9pt;">class</span> 
   <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,255);font-size:9pt;">cmp</span> 
  </div> 
  <div style="min-height:11pt;"> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;">{<!-- --></span> 
  </div> 
  <div style="min-height:11pt;"> 
   <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,255);font-size:9pt;">public</span> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;">:</span> 
  </div> 
  <div style="min-height:11pt;"> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;">  </span> 
   <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,255);font-size:9pt;">bool</span> 
   <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,128,128);font-size:9pt;">operator()</span> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;">(</span> 
   <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,255);font-size:9pt;">const</span> 
   <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,255);font-size:9pt;"><em>string</em></span> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;">&amp;</span> 
   <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,128);font-size:9pt;">item1</span> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;">,</span> 
   <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,255);font-size:9pt;">const</span> 
   <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,255);font-size:9pt;"><em>string</em></span> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;">&amp;</span> 
   <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,128);font-size:9pt;">item2</span> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;">)</span> 
  </div> 
  <div style="min-height:11pt;"> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;">  {<!-- --></span> 
  </div> 
  <div style="min-height:11pt;"> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;">    </span> 
   <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,255);font-size:9pt;">return</span> 
   <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,128);font-size:9pt;">item1</span> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;">.</span> 
   <span style="min-height:11pt;font-family:NSimSun;color:rgb(136,0,0);font-size:9pt;"><em>size</em></span> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;">() &lt;</span> 
   <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,128);font-size:9pt;">item2</span> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;">.</span> 
   <span style="min-height:11pt;font-family:NSimSun;color:rgb(136,0,0);font-size:9pt;"><em>size</em></span> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;">();</span> 
  </div> 
  <div style="min-height:11pt;"> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;">  }</span> 
  </div> 
  <div style="min-height:11pt;"> 
   <span style="min-height:11pt;font-family:NSimSun;color:rgb(0,0,255);font-size:9pt;">private</span> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;">:</span> 
  </div> 
  <div style="min-height:11pt;"> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;">};</span> 
  </div> 
  <div style="min-height:11pt;"> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;">//使用自己的比较函数对象来定义map</span> 
  </div> 
  <div style="min-height:11pt;"> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;"><span style="min-height:11pt;color:rgb(0,0,255);font-size:9pt;"><em>map</em></span><span style="min-height:11pt;font-size:9pt;">&lt;</span><span style="min-height:11pt;color:rgb(0,0,255);font-size:9pt;"><em>string</em></span><span style="min-height:11pt;font-size:9pt;">,</span> <span style="min-height:11pt;color:rgb(0,0,255);font-size:9pt;">int</span><span style="min-height:11pt;font-size:9pt;">,</span> <span style="min-height:11pt;color:rgb(0,0,255);font-size:9pt;">cmp</span> <span style="min-height:11pt;font-size:9pt;">&gt;</span> <span style="min-height:11pt;color:rgb(0,0,128);font-size:9pt;">mapItem5</span><span style="min-height:11pt;font-size:9pt;">;</span></span> 
  </div> 
  <div style="min-height:11pt;"> 
   <span style="min-height:11pt;font-family:NSimSun;font-size:9pt;">//这样就实现了按照string的长度来排序</span> 
  </div> 
 </div> 
</div> 
<div> 
 <ul><li><span style="font-size:14pt;"><span style="font-size:14pt;background-color:rgb(255,250,165);"><strong>如果key是结构体</strong></span></span><span style="font-size:13.3333px;">，那么</span><span style="font-size:13.3333px;color:rgb(255,0,0);">必须重载该结构体的&lt;符号操作</span><span style="font-size:13.3333px;">。否则会导致编译出错</span></li><li><span style="font-size:13.3333px;"><span style="font-size:13.3333px;color:rgb(255,0,0);">sort排序的对象必须是线性储存的，比如序列容器</span>（vector,list,deque），也可以给sort指定比较方法，sort的第三个参数就是比较方法</span></li><li><span style="font-size:14pt;"><span style="font-size:14pt;background-color:rgb(255,250,165);"><strong>如果要按照value值对其进行排序</strong></span></span><span style="font-size:13.3333px;">，那么需要把map值转存到vector中，然后自己定义一个</span><span style="font-size:13.3333px;color:rgb(255,0,0);">比较函数</span><span style="font-size:13.3333px;">或者是</span><span style="font-size:13.3333px;color:rgb(255,0,0);">函数对象</span><span style="font-size:13.3333px;">来对vector进行排序</span></li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div>
    //可以把mapItem的元素存入pairVec中 
  </div> 
  <div>
    map&lt;string,int&gt; mapItem; 
  </div> 
  <div>
    vector&lt;pair&lt;string,int&gt;&gt; pairVec; 
  </div> 
  <div>
    //定义一个 
   <span style="color:#FF0000;">比较函数</span> 
  </div> 
  <div>
    bool cmpByValue(const pair&lt;string,int&gt; &amp;item1,const pair&lt;string,int&gt; &amp;item2) 
  </div> 
  <div>
    { 
  </div> 
  <div>
        return item1.second &lt; item2.second; 
   <br> 
  </div> 
  <div>
    } 
  </div> 
  <div>
    //定义一个 
   <span style="color:#FF0000;">函数对象</span> 
  </div> 
  <div>
    struct Cmp_By_Value 
  </div> 
  <div>
    { 
  </div> 
  <div>
        bool operator()(const pair&lt;string,int&gt; &amp;lhs,const pair&lt;string,int&gt; &amp;rhs) 
   <br> 
  </div> 
  <div>
        { 
  </div> 
  <div>
            return lhs.second &lt; rhs.second; 
   <br> 
  </div> 
  <div>
        } 
   <br> 
  </div> 
  <div>
    }; 
  </div> 
 </div> 
</div> 
<div> 
 <span style="font-weight:bold;">3.map的原理</span> 
</div> 
<div> 
 <ul><li><span style="font-size:13.3333px;color:rgb(255,0,0);">map内部自建一棵红黑树</span><span style="font-size:13.3333px;">（一种非严格意义的平衡二叉树，本质上是</span><span style="font-size:13.3333px;color:rgb(255,0,0);">二叉搜索/查找树</span><span style="font-size:13.3333px;">），该树对数据自动排序，因此map内部的数据有序</span></li><li><span style="font-size:13.3333px;">红黑书的性质：</span></li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div>
    1.节点非黑即红 
  </div> 
  <div>
    2.根节点为黑色 
  </div> 
  <div>
    3.叶子节点为黑色（叶子节点指树尾端的null或者NIL节点） 
  </div> 
  <div>
    4.红色节点的子节点必为黑色 
  </div> 
  <div>
    5.从任意节点出发，到其所有叶子节点的简单路径上的黑色节点数量相同 
  </div> 
 </div> 
</div> 
<div> 
 <ul><li><span style="font-size:13.3333px;"><span style="font-size:13.3333px;color:rgb(255,0,0);">红黑书确保没有一条路径会比其他路径长出两倍</span>，因此是接近平衡的</span></li><li><span style="font-size:13.3333px;">二叉搜索树的性质</span></li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div>
    1.左子树的所有节点值均小于根节点 
  </div> 
  <div>
    2.右子树的所有节点的值都大于根节点 
  </div> 
  <div>
    3.左、右子树分别也是二叉搜索树 
  </div> 
  <div> 
   <span style="color:#FF0000;">4.没有两个节点键值相等</span> 
  </div> 
 </div> 
</div> 
<div> 
 <ul><li><span style="font-size:13.3333px;">红黑树的查找、插入、删除的<span style="font-size:13.3333px;color:rgb(255,0,0);">时间复杂度最坏为O(lgn)</span></span></li><li><span style="font-size:13.3333px;">树的左旋转和右旋转 《算法导论》P176</span></li></ul> 
 <div> 
  <span style="font-size:14pt;"><strong>五、set</strong></span> 
 </div> 
</div> 
<div> 
 <span style="font-weight:bold;">1.set是什么</span> 
</div> 
<div> 
 <ul><li><span style="font-size:13.3333px;">vector封装了数组，list封装了链表，map和set封装了二叉树</span></li><li><span style="font-size:13.3333px;">set中数元素的值不能直接改变</span></li><li><span style="font-size:13.3333px;">STL中的标准关联容器set,multiset,map和multimap内部采用的都是红黑树</span></li><li><span style="font-size:13.3333px;">set的几个问题</span></li></ul> 
 <div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
  <div>
    1.为什么map和set的插入删除效率比用其他序列容器高？ 
  </div> 
  <div>
    答：对于关联容器来说，不需要做内存拷贝和内存移动。set容器内所有元素都是以节点的方式来储存的，插入删除的时候只需要改变指针指向的位置即可 
  </div> 
  <div>
    2.为何insert之后，之前保存的迭代器不会失效？ 
  </div> 
  <div>
    答：迭代器iterator相当于指向节点的指针，内存没有变化，指向内存的指针也就不会失效，迭代器也就不会变化。 
   <span style="color:#FF0000;">删除操作可能导致迭代器失效。</span> 
  </div> 
  <div>
    原则:不要使用过期的迭代器iterator 
  </div> 
  <div>
    3.当数据元素增多时，set的插入和搜索速度变化如何？ 
  </div> 
  <div>
    答：数据量增大一倍，搜索次数增加1.O(lgn) 
  </div> 
 </div> 
</div> 
<div> 
 <span style="font-weight:bold;">2.set的查增删</span> 
</div> 
<div> 
 <span style="font-size:13.3333px;"><span style="font-size:13.3333px;"><strong>1）创建set对象</strong></span></span> 
</div> 
<div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
 <div> 
  <span style="font-size:13.3333px;">//共有5种方式</span> 
 </div> 
 <div> 
  <span style="font-size:13.3333px;">//1.创建一个空对象</span> 
 </div> 
 <div> 
  <span style="font-size:13.3333px;">set&lt;int&gt; s1;</span> 
 </div> 
 <div> 
  <span style="font-size:13.3333px;"><span style="color:#FF0000;">//2.根据自己的比较函数创建set对象</span></span> 
 </div> 
 <div> 
  <span style="font-size:13.3333px;">struct strLess</span> 
 </div> 
 <div> 
  <span style="font-size:13.3333px;">{<!-- --></span> 
 </div> 
 <div> 
  <span style="font-size:13.3333px;">    bool operator()(const char *s1,const char *s2)<br></span> 
 </div> 
 <div>
       { 
 </div> 
 <div>
           return strcmp(s1,s2) &lt; 0; 
  <br> 
 </div> 
 <div>
       } 
  <br> 
 </div> 
 <div>
   }; 
 </div> 
 <div>
   set&lt;const char *, 
  <span style="color:#FF0000;">strLen</span>&gt; s2( 
  <span style="color:#FF0000;">strLen</span>);        //注意这里要重复写两次 
 </div> 
 <div>
   //3.用set对象来拷贝构造 
 </div> 
 <div>
   set&lt;int&gt; s3(s1); 
 </div> 
 <div>
   //4.使用迭代区间[b,e)来构造 
 </div> 
 <div>
   //5.使用迭代区间 
  <span style="font-family:Monaco;font-size:9pt;">[b,e)和自己创建的比较函数来构造</span> 
 </div> 
</div> 
<div> 
 <span style="font-size:13.3333px;"><span style="font-size:13.3333px;"><strong>2）set对象的插入：使用insert函数</strong></span></span> 
</div> 
<div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
 <div>
   pair&lt;iterator,bool&gt; insert(value); 
 </div> 
 <div>
   //插入value，返回一个pair对象，pair的第一个元素是插入的位置的迭代器，第二个表示插入是否成功（value不能重复） 
 </div> 
</div> 
<div> 
 <span style="font-size:13.3333px;"><span style="font-size:13.3333px;"><strong>3）使用copy对象</strong></span></span> 
</div> 
<div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
 <div>
   #include &lt;iterator&gt;        //ostream_iterator包含在头文件&lt; 
  <span style="font-family:Monaco;font-size:9pt;">iterator</span>&gt;中 
 </div> 
 <div>
   copy(s.begin(),s.end(),ostream_iterator&lt;int&gt;(cout,",")); 
 </div> 
 <div> 
  <span style="color:#FF0000;">//</span> 
  <span style="color:rgb(255,0,0);">copy: <span style="font-size:9pt;"><span style="font-family:simsun;">把一个序列（sequence）拷贝到一个容器（container）中去</span></span></span> 
 </div> 
 <div> 
  <span style="color:rgb(255,0,0);"><span style="font-size:9pt;"><span style="font-family:simsun;">//ostream_iterator&lt;int&gt;(cout,","):创建一个输出对象输出到标准输出，只能输出int型对象，分隔符使用“，”</span></span></span> 
 </div> 
</div> 
<div> 
 <span style="font-size:13.3333px;"><strong>4）set的删除</strong></span> 
</div> 
<div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
 <div>
   //1.size_type 
  <span style="color:#FF0000;">erase</span>(value);    删除元素value，返回删除的元素个数 
 </div> 
 <div>
   //2.void erase(&amp;pos);          删除pos位置上的元素 
 </div> 
 <div>
   //3.void erase(&amp;first,&amp;lasr);  删除[first,last)之间的元素 
 </div> 
 <div>
   //4.void 
  <span style="color:#FF0000;">clear</span>();              删除所有元素 
 </div> 
</div> 
<div> 
 <span style="font-size:13.3333px;"><strong>5）set的查找</strong></span> 
</div> 
<div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
 <div>
   //1. 
  <span style="color:#FF0000;">count</span>(value);              返回set内元素值为value的元素个数 
 </div> 
 <div>
   //2.iterator 
  <span style="color:#FF0000;">find</span>(value);      查找value的位置， 
  <span style="color:#FF0000;">找不到将会返回end()</span> 
 </div> 
 <div> 
  <span style="color:rgb(255,0,0);">//3.lower_bound/upper_bound/equal_range</span> 
 </div> 
</div> 
<div> 
 <span style="font-size:13.3333px;"><strong>6）其他常用函数</strong></span> 
</div> 
<div style="padding:8px;font-family:Monaco, Menlo, Consolas, 'Courier New', monospace;font-size:12px;color:rgb(51,51,51);background-color:rgb(251,250,248);border:1px solid rgba(0,0,0,.14902);"> 
 <div>
   //empty() 
 </div> 
 <div>
   //size() 
 </div> 
 <div>
   //set1.swap(set2); 
 </div> 
 <div>
   //rbegin() 
 </div> 
 <div>
   //rend() 
 </div> 
 <div>
   //max_size() 
 </div> 
</div> 
<div> 
 <span style="font-size:13.3333px;"><br></span> 
</div> 
<div> 
 <span style="font-size:13.3333px;"><br></span> 
</div> 
<div> 
 <span style="font-size:13.3333px;"><br></span> 
</div> 
<div> 
 <span style="font-size:13.3333px;"><br></span> 
</div> 
<div> 
 <span style="font-size:13.3333px;"><br></span> 
</div> 
<div> 
 <span style="font-size:13.3333px;"><br></span> 
</div> 
<div> 
 <span style="font-size:13.3333px;"><br></span> 
</div> 
<div> 
 <span style="font-size:13.3333px;"><br></span> 
</div> 
<div> 
 <span style="font-size:13.3333px;"><br></span> 
</div> 
<div> 
 <br> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/39c96511b316d9c06074c78235c272ea/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">stl sort 涉及相等的元素可能导致core</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1aba8eb5e2b1a07d60aa2ab0a4a52307/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python 提取字符串中的数字组成新的字符串</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>