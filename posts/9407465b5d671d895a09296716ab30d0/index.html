<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>微信支付Native（一）准备和相关知识 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="微信支付Native（一）准备和相关知识" />
<meta property="og:description" content="原文链接：微信支付Native（一）准备和相关知识 – 编程屋
目录
1 需要准备相关参数
2 支付安全
2.1 对称加密和非对称加密
2.2 数字签名
2.2.1 摘要算法
2.3 数字证书
1 需要准备相关参数 1）获取商户号
微信商户平台：https://pay.weixin.qq.com/
场景：Native支付
步骤：提交资料=》签署协议=》获取商户号
2）获取APPID
微信公众平台：https://mp.weixin.qq.com/
步骤：注册服务号=》服务号认证=》获取APPID=》绑定商户号
3）获取API秘钥
API版本的接口需要此秘钥
步骤：登录商户平台=》选择账户中心=》安全中心=》API安全=》设置API秘钥
4）获取APIV3秘钥
APIv3版本的接口需要此秘钥步骤：登录商户平台=》选择账户中心=》安全中心=》API安全=》设置APIv3秘钥
5）申请商户API证书
APIv3版本的所有接口都需要；APIv2版本的高级接口需要（如：退款、企业红包、企业付款）
步骤：登录商户平台=》选择账户中心=》安全中心=》API安全=》申请API证书
2 支付安全 2.1 对称加密和非对称加密 按照秘钥的使用方式，加密可以分为两大类：对称加密和非对称加密
1)对称加密：加密和解密的时候秘钥都是同一个，对称加密算法常见的有:
AES加密算法，秘钥长度128、192或256、安全强度很好，性能很高。
加密分组模式：将明文分组加密，微信支付中使用AEAD_AES_256_GCM
优点：运算速度快
缺点：秘钥需要信息交换的双方共享，一旦被窃取，消息就会被破解
2)非对称加密
非对称加密有两个秘钥，一个是公钥，一个是私钥，两个秘钥不同。
使用公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。其中RSA算法加密算法就是最著名的非对称加密算法。
优点：私钥严格保密 ，公钥任意分发，黑客获取公钥无法破解密文
缺点：运算速度非常慢
一般情况下：如果要保证信息传输的安全性，一般都是对称加密和非对称加密互相结合的。例如：我们可以利用非对称加密传输对称加密所需的秘钥，那么后期的交换过程就可以安全的使用对称加密进行了，这样既能保证对称加密的秘钥不会在传输的过程被拦截，又能保证在后续传输的过程中加密和解密的效率。https底层使用的就是这个原理。
举例：Bob有两把钥匙，一把公钥和一把私钥。Bob将自己的公钥分给自己的三个朋友，一人一把。
如果Susan想要给Bob写信，Susan将信件的内容用公钥加密发给Bob，Bob收到信件之后，用私钥进行解密，就可以看到信件的内容。（只要私钥不泄漏，Bob的朋友都可以给Bob写信，即使信件被截获，敌人也无法获取知道信件的内容）
这个时候大家可以发现，我们写信的时候用的是公钥加密，私钥解密。但是如果我们反过来用私钥加密，公钥解密会发生什么事情呢？
这个时候，当Bob用私钥进行信息加密的时候，持有Bob公钥的朋友都可以对信件进行解密，所以可以发现，当用私钥加密，公钥解密的作用其实就是身份认证。
2.2 数字签名 2.2.1 摘要算法 摘要算法，也是常说的散列函数、哈希函数，它能够将任意长度的数据“压缩”成固定长度。而且独一无二的“摘要”字符串，这好像是给这段数据生成了“指纹”。
作用：保证信心的完整性
特性：
不可逆：只有算法，没有秘钥，只能加密，不能解密难题友好性：想要破解，只能暴力枚举发散性：只要对原文进行一点点改变，摘要就会发生剧烈变化抗碰撞性：原文不同，计算后的摘要也不同。 常见的摘要算法：MD5、SHA1、SHA2
Bob写完信之后，先用摘要算法生成信件原文的摘要（message Digest）bob将摘要附在信件原文的下面，一起发送给pat。
pat接受信之后，使用和Bob一样的摘要算法，加密信件的原文，得到信件的摘要，然后Pat将加密后的摘要和Bob在原文中附加的摘要做一下对比，如果一致说明信件是没有被篡改过的。（但是这种做法存在安全隐患，如果黑客截取了信件并且直接修改了原文，根据原文生成了新的摘要，那么接受者这时候是辨别不出来的）
所以说摘要算法不具有机密性
Bob写完信件之后，先用摘要算法生成信件的摘要，bob使用自己的私钥将摘要加密加密后的结果（加密后的结果称为数字签名）bob将数字签名附在信件下面，一起发给pat。
pat收到信件之后 ，用公钥解密得到信件的摘要，然后pat使用和bob一样的加密算法加密信件的原文，得到信件的摘要，然后比对二者是否一致，如果一致，那么信件就是Bob发的且没有经过篡改。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9407465b5d671d895a09296716ab30d0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-19T11:54:35+08:00" />
<meta property="article:modified_time" content="2023-08-19T11:54:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">微信支付Native（一）准备和相关知识</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>原文链接：<a href="https://rivers-all.com/archives/446.html" rel="nofollow" title="微信支付Native（一）准备和相关知识 – 编程屋"><strong>微信支付Native（一）准备和相关知识 – 编程屋</strong></a></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1%20%E9%9C%80%E8%A6%81%E5%87%86%E5%A4%87%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0-toc" style="margin-left:0px;"><a href="#1%20%E9%9C%80%E8%A6%81%E5%87%86%E5%A4%87%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0" rel="nofollow">1 需要准备相关参数</a></p> 
<p id="2%20%E6%94%AF%E4%BB%98%E5%AE%89%E5%85%A8-toc" style="margin-left:0px;"><a href="#2%20%E6%94%AF%E4%BB%98%E5%AE%89%E5%85%A8" rel="nofollow">2 支付安全</a></p> 
<p id="2.1%20%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86-toc" style="margin-left:40px;"><a href="#2.1%20%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86" rel="nofollow">2.1 对称加密和非对称加密</a></p> 
<p id="2.2%20%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D-toc" style="margin-left:40px;"><a href="#2.2%20%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D" rel="nofollow">2.2 数字签名</a></p> 
<p id="2.2.1%20%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#2.2.1%20%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95" rel="nofollow">2.2.1 摘要算法</a></p> 
<p id="2.3%20%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6-toc" style="margin-left:40px;"><a href="#2.3%20%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6" rel="nofollow">2.3 数字证书</a></p> 
<p></p> 
<h2 id="1%20%E9%9C%80%E8%A6%81%E5%87%86%E5%A4%87%E7%9B%B8%E5%85%B3%E5%8F%82%E6%95%B0">1 需要准备相关参数</h2> 
<p><strong>1）获取商户号</strong></p> 
<p>微信商户平台：https://pay.weixin.qq.com/</p> 
<p>场景：Native支付</p> 
<p>步骤：提交资料=》签署协议=》获取商户号</p> 
<p><strong>2）获取APPID</strong></p> 
<p>微信公众平台：https://mp.weixin.qq.com/</p> 
<p>步骤：注册服务号=》服务号认证=》获取APPID=》绑定商户号</p> 
<p><strong>3）获取API</strong><strong>秘钥</strong></p> 
<p>API版本的接口需要此秘钥</p> 
<p>步骤：登录商户平台=》选择账户中心=》安全中心=》API安全=》设置API秘钥</p> 
<p><strong>4）获取APIV3秘钥</strong></p> 
<p>APIv3版本的接口需要此秘钥步骤：登录商户平台=》选择账户中心=》安全中心=》API安全=》设置APIv3秘钥</p> 
<p><strong>5）申请商户API证书</strong></p> 
<p>APIv3版本的所有接口都需要；APIv2版本的高级接口需要（如：退款、企业红包、企业付款）</p> 
<p>步骤：登录商户平台=》选择账户中心=》安全中心=》API安全=》申请API证书</p> 
<h2 id="2%20%E6%94%AF%E4%BB%98%E5%AE%89%E5%85%A8">2 支付安全</h2> 
<h3 id="2.1%20%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86">2.1 对称加密和非对称加密</h3> 
<p><img alt="" height="709" src="https://images2.imgbox.com/e8/91/aurFBjxM_o.png" width="1200"></p> 
<p>按照秘钥的使用方式，加密可以分为两大类：对称加密和非对称加密</p> 
<p><strong>1)对称加密：</strong>加密和解密的时候秘钥都是同一个，对称加密算法常见的有:</p> 
<p>AES加密算法，秘钥长度128、192或256、安全强度很好，性能很高。</p> 
<p>加密分组模式：将明文分组加密，微信支付中使用AEAD_AES_256_GCM</p> 
<p><strong>优点：</strong>运算速度快</p> 
<p><strong>缺点：</strong>秘钥需要信息交换的双方共享，一旦被窃取，消息就会被破解</p> 
<p><strong>2)非对称加密</strong></p> 
<p>非对称加密有两个秘钥，一个是公钥，一个是私钥，两个秘钥不同。</p> 
<p>使用公钥加密后只能用私钥解密，反过来，私钥加密后也只能用公钥解密。其中<strong>RSA算法</strong>加密算法就是最著名的非对称加密算法。</p> 
<p>优点：私钥严格保密 ，公钥任意分发，黑客获取公钥无法破解密文</p> 
<p>缺点：运算速度非常慢</p> 
<p>一般情况下：如果要保证信息传输的安全性，一般都是对称加密和非对称加密互相结合的。例如：我们可以利用非对称加密传输对称加密所需的秘钥，那么后期的交换过程就可以安全的使用对称加密进行了，这样既能保证对称加密的秘钥不会在传输的过程被拦截，又能保证在后续传输的过程中加密和解密的效率。https底层使用的就是这个原理。</p> 
<p>举例：Bob有两把钥匙，一把公钥和一把私钥。Bob将自己的公钥分给自己的三个朋友，一人一把。</p> 
<p><img alt="" height="490" src="https://images2.imgbox.com/43/ed/lbIQDvPp_o.png" width="1200"></p> 
<p></p> 
<p>如果Susan想要给Bob写信，Susan将信件的内容用公钥加密发给Bob，Bob收到信件之后，用私钥进行解密，就可以看到信件的内容。（只要私钥不泄漏，Bob的朋友都可以给Bob写信，即使信件被截获，敌人也无法获取知道信件的内容）</p> 
<p><img alt="" height="542" src="https://images2.imgbox.com/5e/91/xYugpjsx_o.png" width="1200"></p> 
<p>这个时候大家可以发现，我们写信的时候用的是<strong>公钥加密，私钥解密</strong>。但是如果我们反过来用<strong>私钥加密，公钥解密</strong>会发生什么事情呢？</p> 
<p><img alt="" height="849" src="https://images2.imgbox.com/54/cd/pDFs7fvf_o.png" width="1200"></p> 
<p> 这个时候，当Bob用私钥进行信息加密的时候，持有Bob公钥的朋友都可以对信件进行解密，所以可以发现，当用<strong>私钥加密，公钥解密</strong>的作用其实就是身份认证。</p> 
<h3 id="2.2%20%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D">2.2 数字签名</h3> 
<h4 id="2.2.1%20%E6%91%98%E8%A6%81%E7%AE%97%E6%B3%95">2.2.1 摘要算法</h4> 
<p>摘要算法，也是常说的散列函数、哈希函数，它能够将任意长度的数据“压缩”成固定长度。而且独一无二的“摘要”字符串，这好像是给这段数据生成了“指纹”。</p> 
<p><strong>作用：</strong>保证信心的完整性</p> 
<p><strong>特性：</strong></p> 
<ul><li>不可逆：只有算法，没有秘钥，只能加密，不能解密</li><li>难题友好性：想要破解，只能暴力枚举</li><li>发散性：只要对原文进行一点点改变，摘要就会发生剧烈变化</li><li>抗碰撞性：原文不同，计算后的摘要也不同。</li></ul> 
<p><img alt="" height="873" src="https://images2.imgbox.com/54/4d/2EDxr5Px_o.png" width="1200"></p> 
<p>常见的摘要算法：MD5、SHA1、SHA2</p> 
<p>Bob写完信之后，先用摘要算法生成信件原文的摘要（message Digest）bob将摘要附在信件原文的下面，一起发送给pat。</p> 
<p>pat接受信之后，使用和Bob一样的摘要算法，加密信件的原文，得到信件的摘要，然后Pat将加密后的摘要和Bob在原文中附加的摘要做一下对比，如果一致说明信件是没有被篡改过的。（但是这种做法存在安全隐患，如果黑客截取了信件并且直接修改了原文，根据原文生成了新的摘要，那么接受者这时候是辨别不出来的）</p> 
<p><strong>所以说摘要算法不具有机密性</strong></p> 
<p><img alt="" height="910" src="https://images2.imgbox.com/97/c1/tvdIm2lR_o.png" width="1200"></p> 
<p>Bob写完信件之后，先用摘要算法生成信件的摘要，bob使用自己的私钥将摘要加密加密后的结果（加密后的结果称为数字签名）bob将数字签名附在信件下面，一起发给pat。</p> 
<p>pat收到信件之后 ，用公钥解密得到信件的摘要，然后pat使用和bob一样的加密算法加密信件的原文，得到信件的摘要，然后比对二者是否一致，如果一致，那么信件就是Bob发的且没有经过篡改。</p> 
<h3 id="2.3%20%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6">2.3 数字证书</h3> 
<p><img alt="" height="851" src="https://images2.imgbox.com/2e/86/NLlIWYYI_o.png" width="1200"></p> 
<p> 假使Doug给Pat一把公钥（这把公钥是Doug，但是骗Pat说是Bob的），然后Doug用私钥对信件进行加密发给Pat，Pat用Doug给的假公钥进行解密后认为这是Bob的发的信件。（这个时候就会造成数据的泄漏）（就相当于有人冒充微信服务器和你通信，然后你把重要信息全部泄漏给了骗子）</p> 
<p><strong>那么如何判断公钥是真实的呢？</strong></p> 
<p>就是靠CA数字证书了</p> 
<p><img alt="" height="782" src="https://images2.imgbox.com/ae/34/dNwlJ6Wa_o.png" width="1200"></p> 
<p><img alt="" height="917" src="https://images2.imgbox.com/83/dc/bXePbnzY_o.png" width="1200"> Bob向Pat发送信件的时候，Pat收到信件之后先将数字证书取出，对数字证书中的签名进行取出（Pat用数字证书中指定的hash算法根据证书信息计算整个证书信息的摘要，并且使用CA的公钥从数字证书的签名中解析出数字证书的摘要），然后将两个摘要进行比较，如果摘要相同则说明验签通过，Pat从数字证书中获取Bob的公钥。然后根据获取到Bob的公钥进行验签收到的信件。</p> 
<p> 像我们平常常见的<strong>https协议</strong>就用了这个数字证书。</p> 
<p><img alt="" height="941" src="https://images2.imgbox.com/52/6e/hn5zLDNe_o.png" width="1200"></p> 
<p>如：现在有一个网站向CA申请数字证书，那CA用自己的私钥对数字证书的基本信息进行了加密并签名（数字证书的基本信息中是存有网站公钥的）此时有一个客户端对https网站发送了一个加密请求，网站对网页就行加密之后，会连同它的数字证书一起发送给这个客户端的浏览器，那客户端浏览器接收到服务器发送过来的数字证书之后，会使用CA的公钥解密数字证书并验签（CA的公钥就是证书认证机构的公钥，默认情况下，我们操作系统中都会有权威的CA证书列表，CA证书列表就会有CA的公钥）那么客户端也会判断当前访问的网址和数字证书中的网址是否一致。</p> 
<p>通俗的讲：我们访问一个网站，如果这个网站是https形式的，那么他就会向CA证书列表中注册并申请证书 ，然后浏览器访问的时候，该网站会将自己的数字证书发给浏览器，浏览器会对其进行验签</p> 
<p>以上只是部分内容，为了维护方便，本文已迁移到新地址：<a href="https://rivers-all.com/archives/446.html" rel="nofollow" title="微信支付Native（一）准备和相关知识 – 编程屋"><strong>微信支付Native（一）准备和相关知识 – 编程屋</strong></a></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0a4c3a0e5d453b68ab6eefd63237f266/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">torch.cuda.is_available()为false的解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a402e14711030a1fe6630dc425e436d7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">win10的pycharm开发工具使用Jupyter的各种报错：环境问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>