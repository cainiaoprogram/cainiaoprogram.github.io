<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>1.1.6 LSDB同步 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="1.1.6 LSDB同步" />
<meta property="og:description" content="邻接关系 邻接建立过程 讲完了报文之后我们具体来看一下是怎么同步的，我们可以看到下图是我们LSDB的过程：
注意：
我们要注意，在到达同步过程之前我们先要达到2-way的状态，就是我们首先要有邻居状态的建立，才有可能有下面的这些步骤。
首先第一个是ExStart状态：
在Exstart状态中，是用于选举我们的主从的，这里我们可以看到，选举主从主要是用到了DD报文。
对于最前面的这三个DD报文，实际上是不携带任何的路由摘要消息的，此时有人会问不携带路由摘要，那么这个DD报文的作用是什么？
现在我们来看一下它是如何去选举主从的，首先对于RTA而言，它会发送一个DD报文。
这里有一个Seq，我们可以想象X是一个随机数，它的任意取值都是没有关系的，可以取任意的值。第二个I代表的是这个是否是我的第一个DD报文，很明显是。而M代表我是不是Master，此时也就是我是不是主，RTA在这里并不知道RTB的情况肯定以为自己是主，那么同样是置为1，认为自己是MASTER。而MS是代表后面还没有响应选举的DD报文，这里后面还是要去选举DD的，还是要去发送报文信息，所以也是置为1。 对于RTB来说也是一样的，RTB收到了DD报文也是去比较我们的Router ID。
这里对于DD报文，Router ID越大则会成为一个Master，此时RTB就知道自己已经是MASTER。
回复一个DD报文，Seq=Y，这个就是随机数，我们不用管他。
Y表示是不是我的第一个DD报文。
M表示自己是否为MASTER，现在认为自身是MASTER，所以也置为1。
MS表示后面还有没有相应的选举报文，这里是有的，同样也是置1。
此时RTA收到了DD报文之后，发现RTB的Router ID确实是比我大，那么RTB就可以作为一个MASTER。
此时路由器就从ExStart变为Exchange状态，也就是说代表主从去选举完毕了。但是这里RTA就会去回复一个DD报文。
这里的这个DD报文，可以看到它的SEQ就是遵从于我的RTB的SEQ的值了，也就是说之后再去传递任何的DD报文，都是以Y为基础。
在Y上面进行加一、加二等等，第一次传输就是加一，第二次传输就是加二。它在这里就是以y为基础去传送我们的路由消息已经传送我们的DD报文了。
这里其实就可以去保证我们的可靠性了，这个也是选举出主从的意义，为了保证双方设备的可靠性。
这个时候RTA认定RTB是我的DD报文，这个时候SEQ可以理解为一个会话ID，就置为y，它对于I、M、MS这三个参数在我们的报文中还是有的，但是只不过这三个参数都是置0。
因为I首先并不是我的第一个报文了，此时置为0。现在RTA很明显不是Master，是从，所以M也置为0。现在因为是最后一个参与主从选举的DD报文了，所以也是置为0了。 表示去认可RTB主从的地位。肯定RTB是RTA的主了，此时RTB收到了这个报文之后，就会从Exstart状态变为Exchange。
而在Exchange状态中它们就会开始正式的交互相应的摘要信息了，此时RTB将我们相应的DD报文的摘要信息发给RTA。
这个时候我们的Seq等于Y&#43;1，这是RTB第一次传输摘要信息的报文。这个时候它后面跟着一个MS，表示后面还跟着其他的一些MS的报文。 然后对于Exchange状态，RTA现在已经从Exchange状态，到达了loading状态。
同时它也会发送Seq=Y&#43;1的报文，在这里的话也就相应的去发送路由摘要的信息给RTB。
那么RTB假如收到了这个路由的摘要信息之后，发现RTA在这里的路由信息我完全在之前已经都学习完成了，已经对所有的摘要信息在我自己的LSDB链路状态数据库都存放好了。
那么这个时候我并没有重新要从RTA中重新获取的信息了，我就会直接从Exchange状态变为Full状态。
表示我不需要再去学习任何的路由消息了。
对于RTA来说，假如说RTA在这里有一些路有消息需要去学习，此时就会去发送LSR去请求响应的路由消息。
比如：
现在我想去学习2.2.2.2这个loopback口，即我去请求2.2.2.2这个32位的路由的消息，同时这里只是一个目的网段和一个掩码的摘要信息。
对于RTB就会回复一个详细的路由信息LSU。
包括Cost值、出接口等。
对于RTA。现在我收到了一个信息的话，我就会去回复一些ACK的状态。假如说RTA和RTB之间，RTA已经完全学习了RTB的全部路由消息之后已经到了Full状态。
到了Full状态之后就代表了邻接关系的建立，这个就是整体的过程。
OSPF邻居状态机 对于OSPF状态机的描述，我们可以看一下：
首先第一个是Down状态，对于Down状态就代表我刚刚去发送Hello报文。
如果接收到了Hello报文就会进入到Init状态。
这里我们要注意有一个Attempt状态。
Attempt状态是在对应的NBMA网络中，如果是NBMA网络就会是Attempt状态，即尝试去建立。
然后进入到了Init状态。
如果收到了对端的Hello报文我们会到达下一个状态，即2-way状态。
有部分的路由器邻居关系会卡在2way状态，当然有部分的路由器就可以进入到下一个状态，即ExStart状态。
在Exstart状态会去选举主从，主从选举完成就会进入Exchange状态。
对于Exchange状态就会去开始交互DD报文。（完整则直接变为Full，不完整则进入Loading状态去请求路由）
这里的DD报文就携带了响应的路由摘要信息，知道了对方的路由摘要之后就会开始去互相学习路由。
我们要注意，这里的学习路由并不是1s、或者很短的时间内可以学习完成，肯定是需要一个过程的：
我想要去发送LSR请求，LSU收到相应的信息，然后我再去确认。
此时我们在学习路由的这个过程就是一个Loading状态。
最后，两边的路由报文已经学习完成之后，我们就进入到了最后的状态，即Full状态。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8941b3850a2bd42b27b75a45191bcbec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-24T14:52:39+08:00" />
<meta property="article:modified_time" content="2021-04-24T14:52:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">1.1.6 LSDB同步</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <div style="margin-left:0in;"> 
  <div style="margin-left:0in;"> 
   <h2 style="margin-left:0in;"><span style="color:#1e4e79;">邻接关系</span></h2> 
   <p style="margin-left:0in;"> </p> 
   <h3 style="margin-left:0in;"><span style="color:#2e75b5;">邻接建立过程</span></h3> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">讲完了报文之后我们具体来看一下是怎么同步的，我们可以看到下图是我们LSDB的过程：</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">注意：</p> 
   <p style="margin-left:0in;">我们要注意，在到达同步过程之前我们先要达到2-way的状态，就是我们首先要有邻居状态的建立，才有可能有下面的这些步骤。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;"><img alt="" height="764" src="https://images2.imgbox.com/02/ef/WfSetQ8h_o.png" width="1200"></p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;"><strong><span style="color:#5b9bd5;">首先第一个是</span></strong><strong><span style="color:#5b9bd5;">ExStart</span></strong><strong><span style="color:#5b9bd5;">状态</span></strong>：</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">在Exstart状态中，是用于选举我们的主从的，这里我们可以看到，选举主从主要是用到了DD报文。</p> 
   <p style="margin-left:0in;">对于最前面的这三个DD报文，实际上是不携带任何的路由摘要消息的，此时有人会问不携带路由摘要，那么这个DD报文的作用是什么？</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">现在我们来看一下它是如何去选举主从的，首先对于RTA而言，它会发送一个DD报文。</p> 
   <p style="margin-left:0in;"> </p> 
   <ul style="margin-left:.75in;"><li>这里有一个Seq，我们可以想象X是一个随机数，它的任意取值都是没有关系的，可以取任意的值。</li><li>第二个I代表的是这个是否是我的第一个DD报文，很明显是。</li><li>而M代表我是不是Master，此时也就是我是不是主，RTA在这里并不知道RTB的情况肯定以为自己是主，那么同样是置为1，认为自己是MASTER。</li><li>而MS是代表后面还没有响应选举的DD报文，这里后面还是要去选举DD的，还是要去发送报文信息，所以也是置为1。</li></ul> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">对于RTB来说也是一样的，RTB收到了DD报文也是去比较我们的Router ID。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">这里对于DD报文，Router ID越大则会成为一个Master，此时RTB就知道自己已经是MASTER。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">回复一个DD报文，Seq=Y，这个就是随机数，我们不用管他。</p> 
   <p style="margin-left:0in;">Y表示是不是我的第一个DD报文。</p> 
   <p style="margin-left:0in;">M表示自己是否为MASTER，现在认为自身是MASTER，所以也置为1。</p> 
   <p style="margin-left:0in;">MS表示后面还有没有相应的选举报文，这里是有的，同样也是置1。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">此时RTA收到了DD报文之后，发现RTB的Router ID确实是比我大，那么RTB就可以作为一个MASTER。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;"><strong><span style="color:#5b9bd5;">此时路由器就从</span></strong><strong><span style="color:#5b9bd5;">ExStart</span></strong><strong><span style="color:#5b9bd5;">变为</span></strong><strong><span style="color:#5b9bd5;">Exchange</span></strong><strong><span style="color:#5b9bd5;">状态，也就是说代表主从去选举完毕了。但是这里</span></strong><strong><span style="color:#5b9bd5;">RTA</span></strong><strong><span style="color:#5b9bd5;">就会去回复一个</span></strong><strong><span style="color:#5b9bd5;">DD</span></strong><strong><span style="color:#5b9bd5;">报文</span></strong>。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">这里的这个DD报文，可以看到它的SEQ就是遵从于我的RTB的SEQ的值了，也就是说之后再去传递任何的DD报文，都是以Y为基础。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">在Y上面进行加一、加二等等，第一次传输就是加一，第二次传输就是加二。它在这里就是以y为基础去传送我们的路由消息已经传送我们的DD报文了。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">这里其实就可以去保证我们的可靠性了，这个也是选举出主从的意义，为了保证双方设备的可靠性。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">这个时候RTA认定RTB是我的DD报文，这个时候SEQ可以理解为一个会话ID，就置为y，它对于I、M、MS这三个参数在我们的报文中还是有的，但是只不过这三个参数都是置0。</p> 
   <p style="margin-left:0in;"> </p> 
   <ul style="margin-left:.75in;"><li>因为I首先并不是我的第一个报文了，此时置为0。</li><li>现在RTA很明显不是Master，是从，所以M也置为0。</li><li>现在因为是最后一个参与主从选举的DD报文了，所以也是置为0了。</li></ul> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;"><strong><span style="color:#5b9bd5;">表示去认可</span></strong><strong><span style="color:#5b9bd5;">RTB</span></strong><strong><span style="color:#5b9bd5;">主从的地位。肯定</span></strong><strong><span style="color:#5b9bd5;">RTB</span></strong><strong><span style="color:#5b9bd5;">是</span></strong><strong><span style="color:#5b9bd5;">RTA</span></strong><strong><span style="color:#5b9bd5;">的主了，此时</span></strong><strong><span style="color:#5b9bd5;">RTB</span></strong><strong><span style="color:#5b9bd5;">收到了这个报文之后，就会从</span></strong><strong><span style="color:#5b9bd5;">Exstart</span></strong><strong><span style="color:#5b9bd5;">状态变为</span></strong><strong><span style="color:#5b9bd5;">Exchange</span></strong>。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">而在Exchange状态中它们就会开始正式的交互相应的摘要信息了，此时RTB将我们相应的DD报文的摘要信息发给RTA。</p> 
   <p style="margin-left:0in;"> </p> 
   <ul style="margin-left:.75in;"><li>这个时候我们的Seq等于Y+1，这是RTB第一次传输摘要信息的报文。</li><li>这个时候它后面跟着一个MS，表示后面还跟着其他的一些MS的报文。</li></ul> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;"><strong><span style="color:#5b9bd5;">然后对于</span></strong><strong><span style="color:#5b9bd5;">Exchange</span></strong><strong><span style="color:#5b9bd5;">状态，</span></strong><strong><span style="color:#5b9bd5;">RTA</span></strong><strong><span style="color:#5b9bd5;">现在已经从</span></strong><strong><span style="color:#5b9bd5;">Exchange</span></strong><strong><span style="color:#5b9bd5;">状态，到达了</span></strong><strong><span style="color:#5b9bd5;">loading</span></strong><strong><span style="color:#5b9bd5;">状态</span></strong>。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">同时它也会发送Seq=Y+1的报文，在这里的话也就相应的去发送路由摘要的信息给RTB。</p> 
   <p style="margin-left:0in;">那么RTB假如收到了这个路由的摘要信息之后，发现RTA在这里的路由信息我完全在之前已经都学习完成了，已经对所有的摘要信息在我自己的LSDB链路状态数据库都存放好了。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;"><strong><span style="color:#5b9bd5;">那么这个时候我并没有重新要从</span></strong><strong><span style="color:#5b9bd5;">RTA</span></strong><strong><span style="color:#5b9bd5;">中重新获取的信息了，我就会直接从</span></strong><strong><span style="color:#5b9bd5;">Exchange</span></strong><strong><span style="color:#5b9bd5;">状态变为</span></strong><strong><span style="color:#5b9bd5;">Full</span></strong><strong><span style="color:#5b9bd5;">状态</span></strong>。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">表示我不需要再去学习任何的路由消息了。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;"><img alt="" height="691" src="https://images2.imgbox.com/68/6c/zFMiuU0X_o.png" width="1185"></p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;"><strong><span style="color:#5b9bd5;">对于</span></strong><strong><span style="color:#5b9bd5;">RTA</span></strong><strong><span style="color:#5b9bd5;">来说，假如说</span></strong><strong><span style="color:#5b9bd5;">RTA</span></strong><strong><span style="color:#5b9bd5;">在这里有一些路有消息需要去学习，此时就会去发送</span></strong><strong><span style="color:#5b9bd5;">LSR</span></strong><strong><span style="color:#5b9bd5;">去请求响应的路由消息</span></strong>。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">比如：</p> 
   <p style="margin-left:0in;">现在我想去学习2.2.2.2这个loopback口，即我去请求2.2.2.2这个32位的路由的消息，同时这里只是一个目的网段和一个掩码的摘要信息。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;"><strong><span style="color:#5b9bd5;">对于</span></strong><strong><span style="color:#5b9bd5;">RTB</span></strong><strong><span style="color:#5b9bd5;">就会回复一个详细的路由信息</span></strong><strong><span style="color:#5b9bd5;">LSU</span></strong>。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">包括Cost值、出接口等。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;"><strong><span style="color:#5b9bd5;">对于</span></strong><strong><span style="color:#5b9bd5;">RTA</span></strong><strong><span style="color:#5b9bd5;">。现在我收到了一个信息的话，我就会去回复一些</span></strong><strong><span style="color:#5b9bd5;">ACK</span></strong><strong><span style="color:#5b9bd5;">的状态。假如说</span></strong><strong><span style="color:#5b9bd5;">RTA</span></strong><strong><span style="color:#5b9bd5;">和</span></strong><strong><span style="color:#5b9bd5;">RTB</span></strong><strong><span style="color:#5b9bd5;">之间，</span></strong><strong><span style="color:#5b9bd5;">RTA</span></strong><strong><span style="color:#5b9bd5;">已经完全学习了</span></strong><strong><span style="color:#5b9bd5;">RTB</span></strong><strong><span style="color:#5b9bd5;">的全部路由消息之后已经到了</span></strong><strong><span style="color:#5b9bd5;">Full</span></strong><strong><span style="color:#5b9bd5;">状态</span></strong>。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">到了Full状态之后就代表了邻接关系的建立，这个就是整体的过程。</p> 
   <p style="margin-left:0in;"> </p> 
   <h3 style="margin-left:0in;"><span style="color:#2e75b5;">OSPF邻居状态机</span></h3> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;"><img alt="" height="731" src="https://images2.imgbox.com/ce/0c/fvz5p3nl_o.png" width="1200"></p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">对于OSPF状态机的描述，我们可以看一下：</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;"><strong><span style="color:#5b9bd5;">首先第一个是</span></strong><strong><span style="color:#5b9bd5;">Down</span></strong><strong><span style="color:#5b9bd5;">状态，对于</span></strong><strong><span style="color:#5b9bd5;">Down</span></strong><strong><span style="color:#5b9bd5;">状态就代表我刚刚去发送</span></strong><strong><span style="color:#5b9bd5;">Hello</span></strong><strong><span style="color:#5b9bd5;">报文</span></strong>。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">如果接收到了Hello报文就会进入到Init状态。</p> 
   <p style="margin-left:0in;">这里我们要注意有一个Attempt状态。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">Attempt状态是在对应的NBMA网络中，如果是NBMA网络就会是Attempt状态，即尝试去建立。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;"><strong><span style="color:#5b9bd5;">然后进入到了</span></strong><strong><span style="color:#5b9bd5;">Init</span></strong><strong><span style="color:#5b9bd5;">状态</span></strong>。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">如果收到了对端的Hello报文我们会到达下一个状态，即2-way状态。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;"><strong><span style="color:#5b9bd5;">有部分的路由器邻居关系会卡在</span></strong><strong><span style="color:#5b9bd5;">2way</span></strong><strong><span style="color:#5b9bd5;">状态，当然有部分的路由器就可以进入到下一个状态，即</span></strong><strong><span style="color:#5b9bd5;">ExStart</span></strong><strong><span style="color:#5b9bd5;">状态</span></strong>。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;"><strong><span style="color:#5b9bd5;">在</span></strong><strong><span style="color:#5b9bd5;">Exstart</span></strong><strong><span style="color:#5b9bd5;">状态会去选举主从，主从选举完成就会进入</span></strong><strong><span style="color:#5b9bd5;">Exchange</span></strong><strong><span style="color:#5b9bd5;">状态</span></strong>。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;"><strong><span style="color:#5b9bd5;">对于</span></strong><strong><span style="color:#5b9bd5;">Exchange</span></strong><strong><span style="color:#5b9bd5;">状态就会去开始交互</span></strong><strong><span style="color:#5b9bd5;">DD</span></strong><strong><span style="color:#5b9bd5;">报文</span></strong>。（完整则直接变为Full，不完整则进入Loading状态去请求路由）</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">这里的DD报文就携带了响应的路由摘要信息，知道了对方的路由摘要之后就会开始去互相学习路由。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">我们要注意，这里的学习路由并不是1s、或者很短的时间内可以学习完成，肯定是需要一个过程的：</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;">我想要去发送LSR请求，LSU收到相应的信息，然后我再去确认。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;"><strong><span style="color:#5b9bd5;">此时我们在学习路由的这个过程就是一个</span></strong><strong><span style="color:#5b9bd5;">Loading</span></strong><strong><span style="color:#5b9bd5;">状态</span></strong>。</p> 
   <p style="margin-left:0in;"> </p> 
   <p style="margin-left:0in;"><strong><span style="color:#5b9bd5;">最后，两边的路由报文已经学习完成之后，我们就进入到了最后的状态，即</span></strong><strong><span style="color:#5b9bd5;">Full</span></strong><strong><span style="color:#5b9bd5;">状态</span></strong>。</p> 
  </div> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0cd53583046f99a4abca1a037a73d5ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">synchronized关键字详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d77aa7e7796138c338dd8731b8acd6d4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机网络笔记总结：Part4 网络层</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>