<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 8 Lambda 表达式（二） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java 8 Lambda 表达式（二）" />
<meta property="og:description" content="例1、用lambda表达式实现Runnable 我开始使用Java 8时，首先做的就是使用lambda表达式替换匿名类，而实现Runnable接口是匿名类的最好示例。看一下Java 8之前的runnable实现方法，需要4行代码，而使用lambda表达式只需要一行代码。我们在这里做了什么呢？那就是用() -&gt; {}代码块替代了整个匿名类。
// Java 8之前： new Thread(new Runnable() { @Override public void run() { System.out.println(&#34;Before Java8, too much code for too little to do&#34;); } }).start(); //Java 8方式： new Thread( () -&gt; System.out.println(&#34;In Java8, Lambda expression rocks !!&#34;) ).start(); 输出：
too much code, for too little to do Lambda expression rocks !! 这个例子向我们展示了Java 8 lambda表达式的语法。你可以使用lambda写出如下代码：
(params) -&gt; expression (params) -&gt; statement (params) -&gt; { statements } 例如，如果你的方法不对参数进行修改、重写，只是在控制台打印点东西的话，那么可以这样写：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ed1e9ead054a969b81ae1940db591b5e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-09T16:44:08+08:00" />
<meta property="article:modified_time" content="2019-12-09T16:44:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 8 Lambda 表达式（二）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>例1、用lambda表达式实现Runnable</h4> 
<p>我开始使用Java 8时，首先做的就是使用lambda表达式替换匿名类，而实现Runnable接口是匿名类的最好示例。看一下Java 8之前的runnable实现方法，需要4行代码，而使用lambda表达式只需要一行代码。我们在这里做了什么呢？那就是用() -&gt; {}代码块替代了整个匿名类。</p> 
<pre class="has"><code class="language-java">// Java 8之前：
new Thread(new Runnable() {
    @Override
    public void run() {
    System.out.println("Before Java8, too much code for too little to do");
    }
}).start();

//Java 8方式：
new Thread( () -&gt; System.out.println("In Java8, Lambda expression rocks !!") ).start();</code></pre> 
<p>输出：</p> 
<pre>too much code, for too little to do
Lambda expression rocks !!</pre> 
<p>这个例子向我们展示了Java 8 lambda表达式的语法。你可以使用lambda写出如下代码：</p> 
<pre>(params) -&gt; expression
(params) -&gt; statement
(params) -&gt; { statements }</pre> 
<p>例如，如果你的方法不对参数进行修改、重写，只是在控制台打印点东西的话，那么可以这样写：</p> 
<pre>() -&gt; System.out.println("Hello Lambda Expressions");</pre> 
<p>如果你的方法接收两个参数，那么可以写成如下这样：</p> 
<pre>(int even, int odd) -&gt; even + odd</pre> 
<p>顺便提一句，通常都会把lambda表达式内部变量的名字起得短一些。这样能使代码更简短，放在同一行。所以，在上述代码中，变量名选用a、b或者x、y会比even、odd要好。</p> 
<p> </p> 
<h4>例2、使用Java 8 lambda表达式进行事件处理</h4> 
<p>如果你用过Swing API编程，你就会记得怎样写事件监听代码。这又是一个旧版本简单匿名类的经典用例，但现在可以不这样了。你可以用lambda表达式写出更好的事件监听代码，如下所示：</p> 
<pre class="has"><code class="language-java">// Java 8之前：
JButton show =  new JButton("Show");
show.addActionListener(new ActionListener() {
    @Override
    public void actionPerformed(ActionEvent e) {
    System.out.println("Event handling without lambda expression is boring");
    }
});

// Java 8方式：
show.addActionListener((e) -&gt; {
    System.out.println("Light, Camera, Action !! Lambda expressions Rocks");
});</code></pre> 
<p>Java开发者经常使用匿名类的另一个地方是为 Collections.sort() 定制Comparator。在Java 8中，你可以用更可读的lambda表达式换掉丑陋的匿名类。我把这个留做练习，应该不难，可以按照我在使用lambda表达式实现 Runnable 和 ActionListener 的过程中的套路来做。</p> 
<p> </p> 
<h4>例3、使用lambda表达式对列表进行迭代</h4> 
<p>如果你使过几年Java，你就知道针对集合类，最常见的操作就是进行迭代，并将业务逻辑应用于各个元素，例如处理订单、交易和事件的列表。由于Java是命令式语言，Java 8之前的所有循环代码都是顺序的，即可以对其元素进行并行化处理。如果你想做并行过滤，就需要自己写代码，这并不是那么容易。通过引入lambda表达式和默认方法，将做什么和怎么做的问题分开了，这意味着Java集合现在知道怎样做迭代，并可以在API层面对集合元素进行并行处理。下面的例子里，我将介绍如何在<a href="http://javarevisited.blogspot.sg/2012/03/how-to-loop-arraylist-in-java-code.html" rel="nofollow">使用</a><a href="http://javarevisited.blogspot.sg/2012/03/how-to-loop-arraylist-in-java-code.html" rel="nofollow">lambda</a>或不使用lambda表达式的情况下迭代列表。你可以看到列表现在有了一个 forEach()  方法，它可以迭代所有对象，并将你的lambda代码应用在其中。</p> 
<pre class="has"><code class="language-java">// Java 8之前：
List features = Arrays.asList("Lambdas", "Default Method", "Stream API", "Date and Time API");
for (String feature : features) {
    System.out.println(feature);
}

// Java 8之后：
List features = Arrays.asList("Lambdas", "Default Method", "Stream API", "Date and Time API");
features.forEach(n -&gt; System.out.println(n));
 
// 使用Java 8的方法引用更方便，方法引用由::双冒号操作符标示，
// 看起来像C++的作用域解析运算符
features.forEach(System.out::println);</code></pre> 
<p>输出：</p> 
<pre>Lambdas
Default Method
Stream API
Date and Time API</pre> 
<p>列表循环的最后一个例子展示了如何在Java 8中使用方法引用（method reference）。你可以看到C++里面的双冒号、范围解析操作符现在在Java 8中用来表示方法引用。</p> 
<p> </p> 
<h4>例4、使用lambda表达式和函数式接口Predicate</h4> 
<p>除了在语言层面支持函数式编程风格，Java 8也添加了一个包，叫做 java.util.function。它包含了很多类，用来支持Java的函数式编程。其中一个便是Predicate，使用 java.util.function.Predicate 函数式接口以及lambda表达式，可以向API方法添加逻辑，用更少的代码支持更多的动态行为。下面是Java 8 Predicate 的例子，展示了过滤集合数据的多种常用方法。Predicate接口非常适用于做过滤。</p> 
<pre class="has"><code class="language-java">public static void main(args[]){
    List languages = Arrays.asList("Java", "Scala", "C++", "Haskell", "Lisp");
 
    System.out.println("Languages which starts with J :");
    filter(languages, (str)-&gt;str.startsWith("J"));
 
    System.out.println("Languages which ends with a ");
    filter(languages, (str)-&gt;str.endsWith("a"));
 
    System.out.println("Print all languages :");
    filter(languages, (str)-&gt;true);
 
    System.out.println("Print no language : ");
    filter(languages, (str)-&gt;false);
 
    System.out.println("Print language whose length greater than 4:");
    filter(languages, (str)-&gt;str.length() &gt; 4);
}
 
public static void filter(List names, Predicate condition) {
    for(String name: names)  {
        if(condition.test(name)) {
            System.out.println(name + " ");
        }
    }
}</code></pre> 
<p>输出：</p> 
<pre class="has"><code>Languages which starts with J :
Java
Languages which ends with a
Java
Scala
Print all languages :
Java
Scala
C++
Haskell
Lisp
Print no language :
Print language whose length greater than 4:
Scala
Haskell</code></pre> 
<pre>// 更好的办法
</pre> 
<pre class="has"><code class="language-java">public static void filter(List names, Predicate condition) {
    names.stream().filter((name) -&gt; (condition.test(name))).forEach((name) -&gt; {
        System.out.println(name + " ");
    });
}</code></pre> 
<p>可以看到，Stream API的过滤方法也接受一个Predicate，这意味着可以将我们定制的 filter() 方法替换成写在里面的内联代码，这就是lambda表达式的魔力。另外，Predicate接口也允许进行多重条件的测试，下个例子将要讲到。</p> 
<p> </p> 
<h3>5、如何在lambda表达式中加入Predicate</h3> 
<p>java.util.function.Predicate 允许将两个或更多的 Predicate 合成一个。它提供类似于逻辑操作符AND和OR的方法，名字叫做and()、or()和xor()，用于将传入 filter() 方法的条件合并起来。</p> 
<pre class="has"><code class="language-java">// 甚至可以用and()、or()和xor()逻辑函数来合并Predicate，
// 例如要找到所有以J开始，长度为四个字母的名字，你可以合并两个Predicate并传入
Predicate&lt;String&gt; startsWithJ = (n) -&gt; n.startsWith("J");
Predicate&lt;String&gt; fourLetterLong = (n) -&gt; n.length() == 4;
names.stream()
    .filter(startsWithJ.and(fourLetterLong))
    .forEach((n) -&gt; System.out.print("nName, which starts with 'J' and four letter long is : " + n));</code></pre> 
<p>也可以使用 or() 和 xor() 方法</p> 
<h3>6、Java 8中使用lambda表达式的Map和Reduce示例</h3> 
<p>将 costBeforeTax 列表的每个元素转换成为税后的值。我们将 x -&gt; x*x lambda表达式传到 map() 方法，后者将其应用到流中的每一个元素。然后用 forEach() 将列表元素打印出来。</p> 
<pre class="has"><code class="language-java">// 不使用lambda表达式为每个订单加上12%的税
List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);
for (Integer cost : costBeforeTax) {
    double price = cost + .12*cost;
    System.out.println(price);
}
 
// 使用lambda表达式
List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);
costBeforeTax.stream().map((cost) -&gt; cost + .12*cost).forEach(System.out::println);</code></pre> 
<pre class="has"><code>112.0
224.0
336.0
448.0
560.0
112.0
224.0
336.0
448.0
560.0</code></pre> 
<h3>6.2、Java 8中使用lambda表达式的Map和Reduce示例</h3> 
<p>Map和Reduce操作是函数式编程的核心操作，因为其功能，reduce 又被称为折叠操作。</p> 
<p>SQL中类似 sum()、avg() 或者 count() 的聚集函数，实际上就是 reduce 操作，因为它们接收多个值并返回一个值。</p> 
<p>流API定义的 reduceh() 函数可以接受lambda表达式，并对所有值进行合并。IntStream这样的类有类似 average()、count()、sum() 的内建方法来做 reduce 操作，也有mapToLong()、mapToDouble() 方法来做转换。</p> 
<pre class="has"><code class="language-java">// 为每个订单加上12%的税
// 老方法：
List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);
double total = 0;
for (Integer cost : costBeforeTax) {
    double price = cost + .12*cost;
    total = total + price;
}
System.out.println("Total : " + total);
 
// 新方法：可以用内建方法，也可以自己定义
List costBeforeTax = Arrays.asList(100, 200, 300, 400, 500);
double bill = costBeforeTax.stream().map((cost) -&gt; cost + .12*cost).reduce((sum, cost) -&gt; sum + cost).get();
System.out.println("Total : " + bill);</code></pre> 
<p>output:</p> 
<pre>Total : 1680.0
Total : 1680.0</pre> 
<h3>7、通过过滤创建一个String列表</h3> 
<pre class="has"><code class="language-java">// 创建一个字符串列表，每个字符串长度大于2
List&lt;String&gt; filtered = strList.stream().filter(x -&gt; x.length()&gt; 2).collect(Collectors.toList());
System.out.printf("Original List : %s, filtered list : %s %n", strList, filtered);</code></pre> 
<p>output:</p> 
<pre>Original List : [abc, , bcd, , defg, jk], filtered list : [abc, bcd, defg]</pre> 
<h3>8、对列表的每个元素应用函数</h3> 
<pre class="has"><code class="language-java">// 将字符串换成大写并用逗号链接起来
List&lt;String&gt; G7 = Arrays.asList("USA", "Japan", "France", "Germany", "Italy", "U.K.","Canada");
String G7Countries = G7.stream().map(x -&gt; x.toUpperCase()).collect(Collectors.joining(", "));
System.out.println(G7Countries);</code></pre> 
<h3>9、复制不同的值，创建一个子列表</h3> 
<pre class="has"><code>// 用所有不同的数字创建一个正方形列表
List&lt;Integer&gt; numbers = Arrays.asList(9, 10, 3, 4, 7, 3, 4);
List&lt;Integer&gt; distinct = numbers.stream().map( i -&gt; i*i).distinct().collect(Collectors.toList());
System.out.printf("Original List : %s,  Square Without duplicates : %s %n", numbers, distinct);</code></pre> 
<p>output:</p> 
<pre>Original List : [9, 10, 3, 4, 7, 3, 4],  Square Without duplicates : [81, 100, 9, 16, 49]</pre> 
<h3>10、计算集合元素的最大值、最小值、总和以及平均值</h3> 
<p>ntStream、LongStream 和 DoubleStream 等流的类中，有个非常有用的方法叫做 summaryStatistics() 。可以返回 IntSummaryStatistics、LongSummaryStatistics 或者 DoubleSummaryStatistic s，描述流中元素的各种摘要数据。</p> 
<p>最大值　　最小值　　所有元素的总和　　平均值</p> 
<pre class="has"><code class="language-java">//获取数字的个数、最小值、最大值、总和以及平均值
List&lt;Integer&gt; primes = Arrays.asList(2, 3, 5, 7, 11, 13, 17, 19, 23, 29);
IntSummaryStatistics stats = primes.stream().mapToInt((x) -&gt; x).summaryStatistics();
System.out.println("Highest prime number in List : " + stats.getMax());
System.out.println("Lowest prime number in List : " + stats.getMin());
System.out.println("Sum of all prime numbers : " + stats.getSum());
System.out.println("Average of all prime numbers : " + stats.getAverage());</code></pre> 
<p>输出：</p> 
<pre>Highest prime number in List : 29
Lowest prime number in List : 2
Sum of all prime numbers : 129
Average of all prime numbers : 12.9</pre> 
<h3>Lambda表达式 vs 匿名类</h3> 
<p>既然lambda表达式即将正式取代Java代码中的匿名内部类，那么有必要对二者做一个比较分析。</p> 
<p>一个关键的不同点就是关键字 this:</p> 
<p>匿名类的 this 关键字指向匿名类，而lambda表达式的 this 关键字指向包围lambda表达式的类。</p> 
<p>另一个不同点是二者的编译方式:</p> 
<p>Java编译器将lambda表达式编译成类的私有方法。使用了Java 7的 invokedynamic 字节码指令来动态绑定这个方法</p> 
<h2>注意：</h2> 
<p>1）lambda表达式仅能放入如下代码：预定义使用了 @Functional 注释的函数式接口，自带一个抽象函数的方法，或者SAM（Single Abstract Method 单个抽象方法）类型。这些称为lambda表达式的目标类型，可以用作返回类型，或lambda目标代码的参数。例如，若一个方法接收Runnable、Comparable或者 Callable 接口，都有单个抽象方法，可以传入lambda表达式。类似的，如果一个方法接受声明于 java.util.function 包内的接口，例如 Predicate、Function、Consumer 或 Supplier，那么可以向其传lambda表达式。</p> 
<p>2）lambda表达式内可以使用方法引用，仅当该方法不修改lambda表达式提供的参数。本例中的lambda表达式可以换为方法引用，因为这仅是一个参数相同的简单方法调用。</p> 
<pre class="has"><code class="language-java">list.forEach(n -&gt; System.out.println(n));
list.forEach(System.out::println);  // 使用方法引用
</code></pre> 
<p>然而，若对参数有任何修改，则不能使用方法引用，而需键入完整地lambda表达式，如下所示：</p> 
<pre class="has"><code class="language-java">list.forEach((String s) -&gt; System.out.println("*" + s + "*"));</code></pre> 
<p>事实上，可以省略这里的lambda参数的类型声明，<strong>编译器可以从列表的类属性推测出来。</strong></p> 
<p>3）lambda内部可以使用静态、非静态和局部变量，这称为lambda内的变量捕获。</p> 
<p>4）Lambda表达式在Java中又称为闭包或匿名函数，所以如果有同事把它叫闭包的时候，不用惊讶。</p> 
<p>5）Lambda方法在编译器内部被翻译成私有方法，并派发 invokedynamic 字节码指令来进行调用。可以使用JDK中的 javap 工具来反编译class文件。使用 javap -p 或 javap -c -v 命令来看一看lambda表达式生成的字节码。大致应该长这样：</p> 
<pre class="has"><code class="language-java">private static java.lang.Object lambda$0(java.lang.String);</code></pre> 
<p>6）lambda表达式有个限制，那就是只能引用 final 或 final 局部变量，这就是说不能在lambda内部修改定义在域外的变量。</p> 
<pre class="has"><code class="language-java">List&lt;Integer&gt; primes = Arrays.asList(new Integer[]{2, 3,5,7});
int factor = 2;
primes.forEach(element -&gt; { factor++; });</code></pre> 
<pre>Compile time error : "local variables referenced from a lambda expression must be final or effectively final"</pre> 
<p>另外，只是访问它而不作修改是可以的，如下所示：</p> 
<pre class="has"><code class="language-java">List&lt;Integer&gt; primes = Arrays.asList(new Integer[]{2, 3,5,7});
int factor = 2;
primes.forEach(element -&gt; { System.out.println(factor*element); })</code></pre> 
<p>输出：</p> 
<pre>4
6
10
14</pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ff72e211ce06c30c06604e68ba70f758/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">EPON缺点总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c039466e9ed4a60ace08e007d9362a4e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">iPhone安装企业包出现“无法验证证书”问题解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>