<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机网络——第五章网络层笔记（4） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算机网络——第五章网络层笔记（4）" />
<meta property="og:description" content="距离矢量路由选择协议（DV算法） 每个路由器维护一张表，表中列出了当前已知的到每个目标的最佳距离，以及为了到达那个目标，应该从哪个接口转发。
DV算法是动态的和分布式的，它常被用于小型网络，例子：RIP就是一个典型的DV。
每个路由器（节点）维护两个向量，Di和Si，分别表示从该路由器到其它路由器的距离以及相应的下一跳。
在邻居路由器之间交换路由信息（矢量），每个路由器（节点）根据收到的矢量信息，更新自己的路由表。
di1：从节点i到节点1的度量（代价）
Si1:沿着从节点i到节点1的最优路径上的下一跳
n:网络中的节点数，节点从1、2、......、n
优点：简单
缺点：交换的信息太大了，路由信息传播慢，可能导致路径信息不一致、收敛慢、度量计数到无穷、路由环、不适合大型的网络。
链路状态路由协议（LS） 主要思想：
1、发现它的邻居节点们，了解它们的网络地址。（当一个路由器启动的时候，在每个点到点的线路发送一个特别的HELLLO分组，收到HELLO分组的路由器应该回送一个应答，应答中有它自己的名字）
2、设置到它的每个邻居的成本度量。（为了决定线路的开销，路由器发送一个特别的ECHO分组， 另一端立刻回送一个应答；通过测量往返时间(roundtrip time),发送路由器可以获得一个合理的延迟估计值，了得到更好的结果，可多次测量，取均值；一种常用的选择，与链路带宽成反比）
3、构造一个分组，包含它所了解到的所有信息。
链路状态分组构造后被发送给其他的路由器，分组中包含这些信息：发送方的标识、序列号、年龄、邻居列表、到邻居的成本/量度。
4、发送这个分组给所有其他的路由器。
5、计算到每个路由器的最短路径。
基本算法：
1、每个分组都包含一个序列号，序列号随着新分组产生而递增。
2、路由器记录下他看见的所有(源路由器， 序列号)对。
优点：每个路由器的认识一致、收敛快、适合在大型网络里使用。
缺点：每个路由器需要较大的存储空间，计算负担很大。
开放的最短路径优先（OSPF） 方法：使用图（graph）来表示真实的网络，每一个路由器都是一个节点，测量代价/量度。
概述：
1、OSPF是一种基于开放标准的链路状态路由协议，是目前IGP中应用最广、性能最优的一个协议。
2、OSPF可以在大型网络中使用。
3、无路由自环。
4、OSPF支持VLSM、CIDR等。
5、0使用带宽作为度量值（10^8/BW）。
6、收敛速度快。
7、通过分区实现高效的网络管理。
划分区域 所有子区域必须连到区域01上。
OSPF运行步骤
1、建立路由器毗邻关系。
2、选举DR和BDR。（DR故障则BDR接替DR成为新的DR）
3、发现路由。
4、选择最佳路由。
5、维护路由信息。
SPF算法 为什么说OSPF克服了路由自环？
无类域间路由（CIDR） 一、IP地址的问题
好处：缓解地址枯竭的趋势，控制甚至缩短了路由表的开销。
基本思想：分配IP地址的时候不再以类别分，而是按照可变长的地址块来分配（按需分配）。
路由表扩展 1、增加32bit子网掩码。
2、路由表表项（IP address,subnet mask,outgoing line）。
当一个分组到来时：
1、分组中的目标IP地址（Destination IP）被检查
2、目标IP和子网掩码进行与操作，得到网络地址。查找路由表。
3、若路由表中有许多表项匹配，选子网掩码最长的那个表项。
例子：
例子
​​​​​​​ 集合：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e9b9336f97bac95a7903cb63fc08cac8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-19T14:59:05+08:00" />
<meta property="article:modified_time" content="2022-11-19T14:59:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机网络——第五章网络层笔记（4）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>距离矢量路由选择协议（DV算法）</h2> 
<p>每个路由器维护一张表，表中列出了当前已知的到每个目标的最佳距离，以及为了到达那个目标，应该从哪个接口转发。</p> 
<p>DV算法是动态的和分布式的，它常被用于小型网络，例子：RIP就是一个典型的DV。</p> 
<p>每个路由器（节点）维护两个向量，Di和Si，分别表示从该路由器到其它路由器的距离以及相应的下一跳。</p> 
<p>在邻居路由器之间交换路由信息（矢量），每个路由器（节点）根据收到的矢量信息，更新自己的路由表。</p> 
<p>di1：从节点i到节点1的度量（代价）</p> 
<p>Si1:沿着从节点i到节点1的最优路径上的下一跳</p> 
<p>n:网络中的节点数，节点从1、2、......、n</p> 
<p>优点：简单</p> 
<p>缺点：交换的信息太大了，路由信息传播慢，可能导致路径信息不一致、收敛慢、度量计数到无穷、路由环、不适合大型的网络。</p> 
<h2>链路状态路由协议（LS）</h2> 
<p>主要思想：</p> 
<p>       1、发现它的邻居节点们，了解它们的网络地址。（当一个路由器启动的时候，在每个点到点的线路发送一个特别的HELLLO分组，收到HELLO分组的路由器应该回送一个应答，应答中有它自己的名字）</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/48/15/hXVWoCbc_o.png"></p> 
<p></p> 
<p>        2、设置到它的每个邻居的成本度量。（为了决定线路的开销，路由器发送一个特别的ECHO分组， 另一端立刻回送一个应答；通过测量往返时间(roundtrip time),发送路由器可以获得一个合理的延迟估计值，了得到更好的结果，可多次测量，取均值；一种常用的选择，与链路带宽成反比）</p> 
<p>        3、构造一个分组，包含它所了解到的所有信息。</p> 
<p>链路状态分组构造后被发送给其他的路由器，分组中包含这些信息：发送方的标识、序列号、年龄、邻居列表、到邻居的成本/量度。</p> 
<p>        4、发送这个分组给所有其他的路由器。</p> 
<p>         5、计算到每个路由器的最短路径。</p> 
<p>基本算法：</p> 
<p>        1、每个分组都包含一个序列号，序列号随着新分组产生而递增。</p> 
<p>         2、路由器记录下他看见的所有(源路由器， 序列号)对。</p> 
<p>优点：每个路由器的认识一致、收敛快、适合在大型网络里使用。</p> 
<p>缺点：每个路由器需要较大的存储空间，计算负担很大。</p> 
<h2>开放的最短路径优先（OSPF）</h2> 
<p>方法：使用图（graph）来表示真实的网络，每一个路由器都是一个节点，测量代价/量度。</p> 
<p>概述：</p> 
<p>1、OSPF是一种基于开放标准的链路状态路由协议，是目前IGP中应用最广、性能最优的一个协议。</p> 
<p>2、OSPF可以在大型网络中使用。</p> 
<p>3、无路由自环。</p> 
<p>4、OSPF支持VLSM、CIDR等。</p> 
<p>5、0使用带宽作为度量值（10^8/BW）。</p> 
<p>6、收敛速度快。</p> 
<p>7、通过分区实现高效的网络管理。</p> 
<h3>划分区域</h3> 
<p>所有子区域必须连到区域01上。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/54/d6/ClC0xi9d_o.png"></p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ce/f4/XBYxn3Lt_o.png"></p> 
<p> OSPF运行步骤</p> 
<p>1、建立路由器毗邻关系。</p> 
<p>2、选举DR和BDR。（DR故障则BDR接替DR成为新的DR）</p> 
<p>3、发现路由。</p> 
<p>4、选择最佳路由。</p> 
<p>5、维护路由信息。</p> 
<h3>SPF算法</h3> 
<p>为什么说OSPF克服了路由自环？</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e7/70/uWeNGsDi_o.png"></p> 
<h2> 无类域间路由（CIDR）</h2> 
<p>一、IP地址的问题</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c9/85/72J72cFl_o.png"></p> 
<p> 好处：缓解地址枯竭的趋势，控制甚至缩短了路由表的开销。</p> 
<p>基本思想：分配IP地址的时候不再以类别分，而是按照可变长的地址块来分配（按需分配）。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/84/44/M1ChFU2i_o.png"></p> 
<h3> 路由表扩展</h3> 
<p>1、增加32bit子网掩码。</p> 
<p>2、路由表表项（IP address,subnet mask,outgoing line）。</p> 
<p>当一个分组到来时：</p> 
<p>1、分组中的目标IP地址（Destination IP）被检查</p> 
<p>2、目标IP和子网掩码进行与操作，得到网络地址。查找路由表。</p> 
<p>3、若路由表中有许多表项匹配，选子网掩码最长的那个表项。</p> 
<p>例子：</p> 
<p><img alt="" src="https://images2.imgbox.com/cb/10/tmWCcDmn_o.png">例子</p> 
<p style="text-align:center;"> </p> 
<p><img alt="" src="https://images2.imgbox.com/96/4f/dDisSfzL_o.png">​​​​​​​ <img alt="" src="https://images2.imgbox.com/fe/17/eRZA5jq4_o.png"></p> 
<p> </p> 
<p> 集合：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/41/d1/WBJhaYYZ_o.png"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/13f9801f9b29bb511640b0104b092ac9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">激活Windows时出现错误代码0xC004C003怎么办？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b803ba411b080f19d8d2da460fe09569/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Visual Studio Code （VSCode）使用之普通Web项目启动</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>