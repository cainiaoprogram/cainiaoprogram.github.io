<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【机器学习基础】集成模型 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【机器学习基础】集成模型" />
<meta property="og:description" content="文章目录 概述1. Boosting2. Bagging偏差和方差的区别 3. Stacking4. Dropout训练Random Forest1.原理2.优缺点拓展：【RF模型能够输出特征的重要性程度】 GBDT1. GBDT适用范围？2. GBDT和随机森林（RF）的区别？3. GBDT相较于决策树有什么优点？4. GBDT的gradient体现在哪里？5. GBDT的re-sample Xgboost建树方式树分裂方式:exact树集成方式分布式稀疏数据level_wise LGBM树分裂方式建树方式:hist分布式类别特征 常见问题1. Bagging vs Boosting2. Xgboost vs GBDT拓：Xgboost vs LGBM3. 为什么xgboost使用泰勒展开？4. Xgboost如何寻找最优特征？是有放回还是无放回？5. gbdt原理6. xgboost源码看过吗 概述 个体学习器之间存在强依赖关系，必须串行生成的序列化方法*个体学习器之间不存在强依赖关系，可同时生成的并行化方法
1.【机器学习基础】决策树及其ensemble方法（RF, LGBM, Xgboost, GBDT, 梯度提升boosting） 1. Boosting 降低偏差（bias)
2. Bagging 降低方差
偏差和方差的区别 偏差：预估值与真实值的偏离程度，是算法对数据的拟合能力。
方差：数据扰动，训练集变化时，模型的学习性能。
噪声：任何学习算法在泛化能力的下界，是学习问题本身的难度。
3. Stacking 将第一层的输出train再结合其他的特征集再做一层，就是stacking。例如gbt&#43;lr
4. Dropout训练 Dropout 训练继承模型的方式 from 花书7.12
Dropout 训练的集成包括所有从基础网络除去非输出单元后形成的子网络。在 Dropout 的情况下，所有模型共享参数，其中每个模型继承父神经网络参数的不同子集。
Random Forest 1.原理 在Bagging集成的基础上，进一步在决策树的训练过程中引入了随机特征选择。过程分为四个部分：
随机选择样本（bootstrap放回抽样）随机选择特征构建决策树随机森林投票（平均） 2.优缺点 （1）缺点：
随机森林在分类的效果比回归好。因为RF并不能给出一个连续型的输出。而且预测的时候不能超出数据的范围，可能导致有噪声的数据出现过拟合。忽略属性之间可能存在的相关性无法控制模型内部的运行，只能在不同的参数和随机种子之间进行尝试
（2）优点:高度并行，易于分布式实现随机森林可以解决分类和回归，方差和偏差都较低，泛化性能比较好对高维数据处理很好，并确定最重要的变量，因此被认为是一个不错的降维方法。存在分类不平衡时，可以提供平衡数据集误差的方法？由于是树模型，不需要归一化即可直接使用 拓展：【RF模型能够输出特征的重要性程度】 利用随机森林对特征重要性进行评估" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/52ee72385ac121bbbc8d4addde928ac9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-16T17:45:14+08:00" />
<meta property="article:modified_time" content="2021-05-16T17:45:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【机器学习基础】集成模型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_2" rel="nofollow">概述</a></li><li><a href="#1_Boosting_6" rel="nofollow">1. Boosting</a></li><li><a href="#2_Bagging_8" rel="nofollow">2. Bagging</a></li><li><ul><li><a href="#_10" rel="nofollow">偏差和方差的区别</a></li></ul> 
   </li><li><a href="#3_Stacking_14" rel="nofollow">3. Stacking</a></li><li><a href="#4_Dropout_16" rel="nofollow">4. Dropout训练</a></li><li><a href="#Random_Forest_19" rel="nofollow">Random Forest</a></li><li><ul><li><a href="#1_20" rel="nofollow">1.原理</a></li><li><a href="#2_26" rel="nofollow">2.优缺点</a></li><li><ul><li><a href="#RF_37" rel="nofollow">拓展：【RF模型能够输出特征的重要性程度】</a></li></ul> 
   </li></ul> 
   </li><li><a href="#GBDT_45" rel="nofollow">GBDT</a></li><li><ul><li><a href="#1_GBDT_46" rel="nofollow">1. GBDT适用范围？</a></li><li><a href="#2_GBDTRF_49" rel="nofollow">2. GBDT和随机森林（RF）的区别？</a></li><li><a href="#3_GBDT_59" rel="nofollow">3. GBDT相较于决策树有什么优点？</a></li><li><a href="#4_GBDTgradient_61" rel="nofollow">4. GBDT的gradient体现在哪里？</a></li><li><a href="#5_GBDTresample_63" rel="nofollow">5. GBDT的re-sample</a></li></ul> 
   </li><li><a href="#Xgboost_67" rel="nofollow">Xgboost</a></li><li><ul><li><a href="#_72" rel="nofollow">建树方式</a></li><li><a href="#exact_80" rel="nofollow">树分裂方式:exact</a></li><li><a href="#_97" rel="nofollow">树集成方式</a></li><li><a href="#_101" rel="nofollow">分布式</a></li><li><a href="#_115" rel="nofollow">稀疏数据</a></li><li><a href="#level_wise_118" rel="nofollow">level_wise</a></li></ul> 
   </li><li><a href="#LGBM_120" rel="nofollow">LGBM</a></li><li><ul><li><a href="#_121" rel="nofollow">树分裂方式</a></li><li><a href="#hist_125" rel="nofollow">建树方式:hist</a></li><li><a href="#_134" rel="nofollow">分布式</a></li><li><a href="#_139" rel="nofollow">类别特征</a></li></ul> 
   </li><li><a href="#_141" rel="nofollow">常见问题</a></li><li><ul><li><a href="#1_Bagging_vs_Boosting_143" rel="nofollow">1. Bagging vs Boosting</a></li><li><a href="#2_Xgboost_vs_GBDT_151" rel="nofollow">2. Xgboost vs GBDT</a></li><li><a href="#Xgboost_vs_LGBM_156" rel="nofollow">拓：Xgboost vs LGBM</a></li><li><a href="#3_xgboost_163" rel="nofollow">3. 为什么xgboost使用泰勒展开？</a></li><li><a href="#4_Xgboost_166" rel="nofollow">4. Xgboost如何寻找最优特征？是有放回还是无放回？</a></li><li><a href="#5_gbdt_169" rel="nofollow">5. gbdt原理</a></li><li><a href="#6_xgboost_172" rel="nofollow">6. xgboost源码看过吗</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_2"></a>概述</h3> 
<ul><li>个体学习器之间存在强依赖关系，必须串行生成的序列化方法*</li><li>个体学习器之间不存在强依赖关系，可同时生成的并行化方法<br> 1.<a href="https://blog.csdn.net/qq_25024883/article/details/84900635">【机器学习基础】决策树及其ensemble方法（RF, LGBM, Xgboost, GBDT, 梯度提升boosting）</a></li></ul> 
<h3><a id="1_Boosting_6"></a>1. Boosting</h3> 
<p>降低偏差（bias)</p> 
<h3><a id="2_Bagging_8"></a>2. Bagging</h3> 
<p>降低方差</p> 
<h4><a id="_10"></a>偏差和方差的区别</h4> 
<p>偏差：预估值与真实值的偏离程度，是算法对数据的拟合能力。<br> 方差：数据扰动，训练集变化时，模型的学习性能。<br> 噪声：任何学习算法在泛化能力的下界，是学习问题本身的难度。</p> 
<h3><a id="3_Stacking_14"></a>3. Stacking</h3> 
<p>将第一层的输出train再结合其他的特征集再做一层，就是stacking。例如gbt+lr</p> 
<h3><a id="4_Dropout_16"></a>4. Dropout训练</h3> 
<p><em>Dropout 训练继承模型的方式 from 花书7.12</em><br> Dropout 训练的集成包括所有从基础网络除去非输出单元后形成的子网络。在 Dropout 的情况下，所有模型共享参数，其中每个模型继承父神经网络参数的不同子集。</p> 
<h3><a id="Random_Forest_19"></a>Random Forest</h3> 
<h4><a id="1_20"></a>1.原理</h4> 
<p>在Bagging集成的基础上，进一步在决策树的训练过程中引入了随机特征选择。过程分为四个部分：</p> 
<ul><li>随机选择样本（bootstrap放回抽样）</li><li>随机选择特征</li><li>构建决策树</li><li>随机森林投票（平均）</li></ul> 
<h4><a id="2_26"></a>2.优缺点</h4> 
<p>（1）缺点：</p> 
<ul><li>随机森林在分类的效果比回归好。因为RF并不能给出一个连续型的输出。而且预测的时候不能超出数据的范围，可能导致有噪声的数据出现过拟合。</li><li>忽略属性之间可能存在的相关性</li><li>无法控制模型内部的运行，只能在不同的参数和随机种子之间进行尝试<br> （2）优点:</li><li>高度并行，易于分布式实现</li><li>随机森林可以解决分类和回归，方差和偏差都较低，泛化性能比较好</li><li>对高维数据处理很好，并确定最重要的变量，因此被认为是一个不错的降维方法。</li><li>存在分类不平衡时，可以提供平衡数据集误差的方法？</li><li>由于是树模型，不需要归一化即可直接使用</li></ul> 
<h5><a id="RF_37"></a>拓展：【RF模型能够输出特征的重要性程度】</h5> 
<p><a href="https://blog.csdn.net/zjuPeco/article/details/77371645">利用随机森林对特征重要性进行评估</a><br> 本质：计算该特征在分支前后对树的平均gini提升占比所有特征的值。<br> 步骤：</p> 
<ol><li>计算所有树中该特征节点分支前后的所有 gini 指数，包括分支前一个，分支后两个。</li><li>计算每棵树中gini指数的变化量 = gini前 - gini后一 - gini后二</li><li>sum(每棵树的delta gini)/所有特征的delta gini</li></ol> 
<h3><a id="GBDT_45"></a>GBDT</h3> 
<h4><a id="1_GBDT_46"></a>1. GBDT适用范围？</h4> 
<ul><li>GBDT 可以适用于回归问题（线性和非线性）；</li><li>GBDT 也可用于二分类问题（设定阈值，大于为正，否则为负）和多分类问题。</li></ul> 
<h4><a id="2_GBDTRF_49"></a>2. GBDT和随机森林（RF）的区别？</h4> 
<p>相同点：) 都是多棵树<br> (2) 最终结构由多棵树共同决定<br> 不同点：<br> (1) RF的组成可以是分类树、回归树；组成 GBDT 只能是回归树。<br> (2) RF的树可以并行生成（Bagging）；GBDT 只能串行生成（Boosting）<br> (3) 对于最终的输出结果而言，RF使用多数投票或者简单平均；而 GBDT 则是将所有结果累加起来，或者加权累加起来；<br> (4) RF对异常值不敏感，GBDT 对异常值非常敏感；<br> (5) RF对训练集一视同仁权值一样，GBDT 是基于权值的弱分类器的集成；<br> (6) RF通过减小模型的方差提高性能，GBDT 通过减少模型偏差提高性能。</p> 
<h4><a id="3_GBDT_59"></a>3. GBDT相较于决策树有什么优点？</h4> 
<p>泛化性能更好！GBDT 的最大好处在于，每一步的残差计算其实变相的增大了分错样本的权重，而已经分对的样本则都趋向于0。这样后面就更加专注于那些分错的样本。</p> 
<h4><a id="4_GBDTgradient_61"></a>4. GBDT的gradient体现在哪里？</h4> 
<p>可以理解为残差是全局最优的绝对方向，类似于求梯度。</p> 
<h4><a id="5_GBDTresample_63"></a>5. GBDT的re-sample</h4> 
<p>GBDT 也可以在使用残差的同时引入 Bootstrap re-sampling，GBDT 多数实现版本中引入了这个选项，但是是否一定使用有不同的看法。<br> 原因在于 re-sample 导致的随机性，使得模型不可复现，对于评估提出一定的挑战，比如很难确定性能的提升是由于 feature 的原因还是 sample 的随机因素。</p> 
<h3><a id="Xgboost_67"></a>Xgboost</h3> 
<p><strong>不放回抽样</strong><br> Xgboost是GBDT的一个变种，最大的区别是xgboost通过对目标函数做二阶泰勒展开，从而更新树的叶子的权重和树的权重，并根据loss function求出每一次分裂节点的损失减小的大小，根据分裂损失选择合适的属性进行分裂。<br> 【源码参考：<a href="https://blog.csdn.net/matrix_zzl/article/details/78699605">XGBoost解析系列–源码主流程</a>】</p> 
<h4><a id="_72"></a>建树方式</h4> 
<ul><li>和RF相同。在构建树的过程中，对每棵树随机选择一些属性作为分裂属性（build_single_tree的方法类似，即)</li></ul> 
<pre><code class="prism language-python">features <span class="token operator">=</span> np<span class="token punctuation">.</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> col<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> col<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>
features <span class="token operator">=</span> np<span class="token punctuation">.</span>unique<span class="token punctuation">(</span>features<span class="token punctuation">)</span>
fea_list <span class="token operator">=</span> features<span class="token punctuation">.</span>tolist<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<ul><li>xgboost使用exact算法。</li></ul> 
<h4><a id="exact_80"></a>树分裂方式:exact</h4> 
<p>两种分裂算法：精确分裂exact，近似分裂approx。</p> 
<ul><li>精确：把每个属性的每个取值作为阈值进行遍历切割，采用CART决策树。</li><li>近似：对每个属性的所有取值进行分桶，按照各个桶之间的值作为划分阈值。（spark RF里面使用等频分桶） （spark里面使用sort实现）</li></ul> 
<pre><code class="prism language-scala"><span class="token comment">//找到切分点（splits）及箱子信息（Bins）</span>
<span class="token comment">//对于连续型特征，利用切分点抽样统计简化计算</span>
<span class="token comment">//对于离散型特征，如果是无序的，则最多有个 splits=2^(numBins-1)-1 划分</span>
<span class="token comment">//如果是有序的，则最多有 splits=numBins-1 个划分</span>
</code></pre> 
<p><strong>xgboost的特点</strong><br> 提出了一种特殊的分桶策略，一般的分桶策略是每个样本的权重都是相同的，但是xgboost使每个样本的权重为损失函数在该样本点的二阶导。<br> (泰勒展开不应该是损失函数关于模型的展开吗？为什么会有在该样本点的二阶导这种说法？ 因为模型是对所有样本点都通用的，把该样本输入到二阶导公式中就可以得到了)。</p> 
<p><em>所有建树算法：‘auto’, ‘approx’, ‘exact’, ‘hist’, ‘gpu_exact’, ‘gpu_hist’等，默认设置为’auto’。使用’auto’自适应到具体的算法，对于数据量小于222222使用’exact’精确方法，否则会重置’approx’近视方法。计算批次量大小max_row_perbatch=min(用户设置max_row_perbatch, safe_max_row)，进行批次处理，其中safe_max_row=216216</em></p> 
<h4><a id="_97"></a>树集成方式</h4> 
<ul><li>xgboost对每棵树的叶子节点个数和权重做了惩罚，避免过拟合。具体是：<br> 参数 * 叶子个数N + 参数 * sum(叶子权重 * 叶子上的样本数)</li></ul> 
<h4><a id="_101"></a>分布式</h4> 
<p>RF的并行化是树与树之间的并行化。<br> xgboost和boosting方法一样，在树的计算上是串行的，但是在构建树的过程中，也就是在<strong>分裂节点</strong>的时候支持并行化。<br> 比如同时计算多个取值作为分裂特征及其值，然后选择收益最大的特征及其取值对节点分裂。<br> <em>一般的feature parallel就是对数据做垂直分割（partiion data vertically，就是对属性分割），然后将分割后的数据分散到各个workder上，各个workers计算其拥有的数据的best splits point, 之后再汇总得到全局最优分割点。</em></p> 
<p>【源码讲解】<br> [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-BgQpzIKv-1621158296838)(evernotecid://F168D203-45D2-4FD0-BB36-6F63414FB4C7/appyinxiangcom/21940830/ENResource/p232)]<br> 三个函数：</p> 
<ul><li>AddBudget：将每个不为0的值放到多个线程中，一个线程中统计该线程中不同值出现的次数。类似于map</li><li>InitStorage：统计多个线程中值的个数。类似于reduce</li><li>Push：进行排序。类似于shift<br> <em>稀疏矩阵的存储方式：外层一维数组，内层是每个feature不为0的值和不为0的值的偏移量。理解就是，假如有N个不为0的值，一个N✖️2的矩阵，第一行是值，第二行是位置（到0的偏移量）。</em></li></ul> 
<h4><a id="_115"></a>稀疏数据</h4> 
<p>xgboost在计算分裂收益的时候只利用了没有missing值的样本。但是在确定了树的结构的时候！xgboost分别假设该样本属于左子树和右子树，比较两者的分裂增益，选择增益较大的那一边作为该样本的分裂方向。</p> 
<h4><a id="level_wise_118"></a>level_wise</h4> 
<p>对每一个叶节点进行增益的计算。</p> 
<h3><a id="LGBM_120"></a>LGBM</h3> 
<h4><a id="_121"></a>树分裂方式</h4> 
<p>xgboost:level-wise. LGBM:leaf-wise.<br> xgboost对每一层所有节点进行无差别分裂，可能有些节点的增益非常小，对结果影响不大，但是xgboost也进行了分裂，开销太大了。<br> leaf-wise是在当前所有叶子节点中选择分裂收益最大的节点进行分裂，如此递归，但很容易过拟合，陷入比较高的深度当中，<strong>所以要对最大深度做限制</strong>，避免过拟合。</p> 
<h4><a id="hist_125"></a>建树方式:hist</h4> 
<p>histogram算法在内存和计算代价上都有不小优势。</p> 
<ul><li>内存上优势：直方图算对特征分桶后只需保存特征离散化之后的值，而xgboost的exact算法既要保存原始feature的值，也要保存这个值的顺序索引。</li><li>计算上的优势，预排序算法需要遍历所有样本的特征值，,而直方图算法只需要遍历桶就行了。</li></ul> 
<p><strong>为什么xgboost的近似直方图比LGBM的直方图算法慢？</strong><br> 一个子节点的直方图可以通过父节点的直方图减去兄弟节点的直方图得到，从而加速计算。<br> xgboost在每一层都动态构建直方图， 因为xgboost的直方图算法不是针对某个特定的feature，而是所有feature共享一个直方图(每个样本的权重是二阶导),所以每一层都要重新构建直方图，而lightgbm中对每个特征都有一个直方图，所以构建一次直方图就够了。</p> 
<h4><a id="_134"></a>分布式</h4> 
<ul><li>特征计算增益</li><li>数据集的直方图汇总的时候<br> 常用方式是各个worker做自己的直方图，然后汇总各个worker的直方图得到全局的直方图。LGBM是不汇总所有的直方图，只汇总不同worker的不同feature的直方图。</li></ul> 
<h4><a id="_139"></a>类别特征</h4> 
<p>在对离散特征分裂时，分裂时的增益算的是“是否属于某个类别的”增益。</p> 
<h3><a id="_141"></a>常见问题</h3> 
<h4><a id="1_Bagging_vs_Boosting_143"></a>1. Bagging vs Boosting</h4> 
<p>1.最主要的区别是取样方式不同。Bagging的训练集的选择是随机均匀的，Boosting的训练集的选择与前面的学习结果有关，所以Boosting的分类精度要优于Bagging。<br> 2.模型的集成方式上，Bagging的各个预测函数没有权重，Boosting有。<br> 3.运行方式上，Bagging可以并行生成各个预测函数，Boosting只能顺序生成。所以针对NN，Bagging可以节省大量时间开销。<br> 【Bagging是降低方差，Boosting是偏差】<br> 理解：<br> Bagging是多个模型并行集成，并且样本可放回抽样。<br> Boosting是每一次都在修订前面模型的结果，也就是说在降低错误率，降低偏差。</p> 
<h4><a id="2_Xgboost_vs_GBDT_151"></a>2. Xgboost vs GBDT</h4> 
<p>1.xgboost使用了泰勒展开<br> 2.xgboost使用了多线程<br> 3.xgboost在代价函数中加入了正则项，用于控制模型的复杂度。</p> 
<h4><a id="Xgboost_vs_LGBM_156"></a>拓：Xgboost vs LGBM</h4> 
<p>4.LGBM基本原理与Xgboost一样，但是速度更快：</p> 
<ul><li>分裂方式不同：xgboost是level-wise，GBDT是leaf-wise（xgboost对每一层所有节点进行无差别分裂，可能有些节点的增益非常小，对结果影响不大，但是xgboost也进行了分裂，开销太大了）（GBDT更容易过拟合，需要控制最大深度）</li><li>建树方式不同：Xgboost是exact，LGBM是hist（建树方式的原理说明；直方图可以直接相减计算）</li><li>并发不同（两个并发的原理）</li><li>LGBM可以接受类别feature，类似于one-hot编码</li></ul> 
<h4><a id="3_xgboost_163"></a>3. 为什么xgboost使用泰勒展开？</h4> 
<p>使用泰勒展开是为了能够【自定义loss function】。<br> 实际上，使用最小二乘法的损失函数进行直接推导和泰勒展开的推导结果相同。两者虽然结果相同，但是OLS的计算量太大了。在实际的代码过程中，任何损失函数只要二阶可导都可以【复用】泰勒展开，例如基于分类的对数损失函数。这样的话，【代码可以在分类和回归进行复用】。</p> 
<h4><a id="4_Xgboost_166"></a>4. Xgboost如何寻找最优特征？是有放回还是无放回？</h4> 
<p>Xgboost在训练的过程中给出各个特征的评分，从而表明每个特征对模型训练的重要性。<br> 无放回抽样。Xgboost是梯度优化模型，如果一个样本连续重复抽出，则梯度来回踏步，不利于收敛。</p> 
<h4><a id="5_gbdt_169"></a>5. gbdt原理</h4> 
<p>提升树是：计算每个样本的残差，对残差进行拟合得到回归树。<br> GBDT（梯度提升树）：使用loss function的偏导代替残差进行拟合。</p> 
<h4><a id="6_xgboost_172"></a>6. xgboost源码看过吗</h4> 
<p>讲多线程计算的三个函数：<br> map -&gt; reduce -&gt; shift</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2a34fbf4e686b2b1f40df78f0cf385a6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">轻量级网络——MobileNetV2</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/34170d24da5040290a3a94da0b0aa088/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">光通信的最新技术趋势</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>