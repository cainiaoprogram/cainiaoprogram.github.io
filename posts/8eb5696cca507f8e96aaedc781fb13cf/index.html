<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java中Writer的线程安全性 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java中Writer的线程安全性" />
<meta property="og:description" content="以前负责一个项目，我负责从一个超大的文本文件中读取信息存入数据库再进一步分析。而文本文件内容是每行一个json串。我在解析的过程中发现，有很小的概率json串的结构会破坏，比如前一个json串只写了半行，后面就被另一个json串覆盖掉了。 与产生日志的部门沟通，他们说是多线程使用log4j写入，可能偶尔会有串行。 具体他们是否使用log4j的AsyncAppender我不太了解，暂时也没去看log4j的源码，当时只是简单的忽略异常的行了事儿。 现在比较闲，想测试一下jdk里面各种输出方式，例如Writer，在多线程交替写入文件一行时是否会出现串行的情况，于是便出现了本文。 测试分两部分： 1，多个线程各自开启一个FileWriter写入同一个文件。 2，多个线程共用一个FileWriter写入同一个文件。 -------------------------------------------------- 首先来看FileWriter的JDK说明： “某些平台一次只允许一个 FileWriter（或其他文件写入对象）打开文件进行写入”——如果是这样，那么第1个测试便不用做了，可事实上至少在windows下并非如此。 上代码(别嫌丑，咱是在IO，不是在测多线程，您说是吧？)： 1，多个线程各自开启一个FileWriter写入同一个文件。 //在100毫秒的时间内，10个线程各自开一个FileWriter， //同时向同一个文件写入字符串，每个线程每次写一行。 //测试结果：文件内容出现混乱，串行 private void multiThreadWriteFile() throws IOException{ File file=new File(basePath&#43;jumpPath&#43;fileName); file.createNewFile(); //创建10个线程 int totalThreads=10; WriteFileThread[] threads=new WriteFileThread[totalThreads]; for(int i=0;i&lt;totalThreads;i&#43;&#43;){ WriteFileThread thread=new WriteFileThread(file,i); threads[i]=thread; } //启动10个线程 for(Thread thread: threads){ thread.start(); } //主线程休眠100毫秒 try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } //所有线程停止 for(WriteFileThread thread: threads){ thread.setToStop(); } System.out.println(&#34;还楞着干什么，去看一下文件结构正确与否啊！&#34;); } class WriteFileThread extends Thread{ private boolean toStop=false; private FileWriter writer; private int threadNum; private String lineSeparator; WriteFileThread(File file,int threadNum) throws IOException{ lineSeparator=System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8eb5696cca507f8e96aaedc781fb13cf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-09-01T23:38:35+08:00" />
<meta property="article:modified_time" content="2012-09-01T23:38:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java中Writer的线程安全性</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    以前负责一个项目，我负责从一个超大的文本文件中读取信息存入数据库再进一步分析。而文本文件内容是每行一个json串。我在解析的过程中发现，有很小的概率json串的结构会破坏，比如前一个json串只写了半行，后面就被另一个json串覆盖掉了。 
<br> 与产生日志的部门沟通，他们说是多线程使用log4j写入，可能偶尔会有串行。 
<br> 具体他们是否使用log4j的AsyncAppender我不太了解，暂时也没去看log4j的源码，当时只是简单的忽略异常的行了事儿。 
<br> 现在比较闲，想测试一下jdk里面各种输出方式，例如Writer，在多线程交替写入文件一行时是否会出现串行的情况，于是便出现了本文。 
<br> 
<br> 
<br> 测试分两部分： 
<br> 1，多个线程各自开启一个FileWriter写入同一个文件。 
<br> 2，多个线程共用一个FileWriter写入同一个文件。 
<br> -------------------------------------------------- 
<br> 首先来看FileWriter的JDK说明： 
<br> “某些平台一次只允许一个 FileWriter（或其他文件写入对象）打开文件进行写入”——如果是这样，那么第1个测试便不用做了，可事实上至少在windows下并非如此。 
<br> 
<br> 上代码(别嫌丑，咱是在IO，不是在测多线程，您说是吧？)： 
<br> 1，多个线程各自开启一个FileWriter写入同一个文件。 
<br> 
<pre><code class="language-java">	//在100毫秒的时间内，10个线程各自开一个FileWriter，
	//同时向同一个文件写入字符串，每个线程每次写一行。
	//测试结果：文件内容出现混乱，串行
	private void multiThreadWriteFile() throws IOException{
		File file=new File(basePath+jumpPath+fileName);
		file.createNewFile();
		
		//创建10个线程
		int totalThreads=10;
		WriteFileThread[] threads=new WriteFileThread[totalThreads];
		for(int i=0;i&lt;totalThreads;i++){
			WriteFileThread thread=new WriteFileThread(file,i);
			threads[i]=thread;
		}
		
		//启动10个线程
		for(Thread thread: threads){
			thread.start();
		}
		
		//主线程休眠100毫秒
		try {
			Thread.sleep(100);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		//所有线程停止
		for(WriteFileThread thread: threads){
			thread.setToStop();
		}
		System.out.println("还楞着干什么，去看一下文件结构正确与否啊！");
	}</code></pre> 
<br> 
<pre><code class="language-java">	class WriteFileThread extends Thread{
		private boolean toStop=false;
		private FileWriter writer;
		private int threadNum;
		private String lineSeparator;
		
		WriteFileThread(File file,int threadNum) throws IOException{
			lineSeparator=System.getProperty("line.separator");
			writer=new FileWriter(file,true);
			this.threadNum=threadNum;
		}
		
		@Override
		public void run() {
			while(!toStop){
				try {
					writer.append("线程"+threadNum+"正在写入文件，" +
							"妈妈说名字要很长才能够测试出这几个线程有没有冲突啊，" +
							"不过还是没有论坛里帖子的名字长，怎么办呢？" +
							"哎呀，后面是换行符了"+lineSeparator);
					
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			System.out.println("---------线程"+threadNum+"停止执行了");
		}

		public void setToStop() {
			this.toStop = true;
		}
	}</code></pre> 
<br> 
<br> 
<br> 测试结果： 
<br> 产生5MB左右的文本文件，里面出现大约5%的文本串行现象。 
<br> -------------------------------------------------- 
<br> 接下来我们看多个线程共用一个FileWriter写入同一个文件的情况： 
<br> 在Writer抽象类里面有一个protected类型的lock属性，是一个简单Object对象。 
<br> JDK里对这个lock属性的描述如下：“用于同步针对此流的操作的对象。为了提高效率，字符流对象可以使用其自身以外的对象来保护关键部分。因此，子类应使用此字段中的对象，而不是 this 或者同步的方法。 ”——看来，多线程共用同一个writer的方案有戏。 
<br> 
<br> 
<br> 继续看下源代码，从FileWriter的writer方法开始看起，调用过程如下： 
<br> FileWriter-&gt;OutputStreamWriter.write-&gt;StreamEncoder.write 
<br> 其中StreamEncoder.write的源码如下： 
<br> (JDK自带源码不包括StreamExcoder，可以在这里查看 http://www.docjar.com/html/api/sun/nio/cs/StreamEncoder.java.html) 
<br> 
<pre><code class="language-java">public void write(char cbuf[], int off, int len) throws IOException {
	synchronized (lock) {
		ensureOpen();
		if ((off &lt; 0) || (off &gt; cbuf.length) || (len &lt; 0) ||
				((off + len) &gt; cbuf.length) || ((off + len) &lt; 0)) 
			{
				throw new IndexOutOfBoundsException();
			} else if (len == 0) {
				return;
			}
		implWrite(cbuf, off, len);
	}
}</code></pre> 
<br> 
<br> 
<br> 可以看到FileWriter在写入时，同步在了对应的FileOutputStream对象上——依此分析，多个线程共用一个FileWriter写入同一个文件，一次一行的情况下，不会出现串行。 
<br> 写代码测试一下： 
<br> 
<br> 
<pre><code class="language-java">	//多线程争抢写入同一个文件的测试，一次一行
	//多个线程公用一个FileWriter
	//测试结果：
	private void multiThreadWriteFile2() throws IOException{
		File file=new File(basePath+jumpPath+fileName);
		file.createNewFile();
		FileWriter fw=new FileWriter(file);
		
		//创建10个线程
		int totalThreads=10;
		WriteFileThread2[] threads=new WriteFileThread2[totalThreads];
		for(int i=0;i&lt;totalThreads;i++){
			WriteFileThread2 thread=new WriteFileThread2(fw,i);
			threads[i]=thread;
		}
		
		//启动10个线程
		for(Thread thread: threads){
			thread.start();
		}
		
		//主线程休眠100毫秒
		try {
			Thread.sleep(100);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		
		//所有线程停止
		for(WriteFileThread2 thread: threads){
			thread.setToStop();
		}
		System.out.println("还楞着干什么，去看一下文件结构正确与否啊！");
	}</code></pre> 
<br> 
<br> 
<pre><code class="language-java">	class WriteFileThread2 extends Thread{
		private boolean toStop=false;
		private FileWriter writer;
		private int threadNum;
		private String lineSeparator;
		
		WriteFileThread2(FileWriter writer,int threadNum){
			lineSeparator=System.getProperty("line.separator");
			this.writer=writer;
			this.threadNum=threadNum;
		}
		
		@Override
		public void run() {
			while(!toStop){
				try {
					writer.append("线程"+threadNum+"正在写入文件，" +
							"妈妈说名字要很长才能够测试出这几个线程有没有冲突啊，" +
							"不过还是没有论坛里帖子的名字长，怎么办呢？" +
							"哎呀，后面是换行符了"+lineSeparator);
				} catch (IOException e) {
					e.printStackTrace();
				}
			}
			System.out.println("---------线程"+threadNum+"停止执行了");
		}

		public void setToStop() {
			this.toStop = true;
		}
	}</code></pre> 
<br> 
<br> 
<br> 
<br> 
<br> 测试结果： 
<br> 产生2.2MB左右的文本文件，里面没有出现任何串行现象。 
<br> -------------------------------------------------- 
<br> 那么BufferedWriter又如何呢？ 
<br> 按道理BufferedWriter只是把别的Writer装饰了一下，在底层写的时候也是同步的。 
<br> 看源码： 
<br> 
<pre><code class="language-java">    void flushBuffer() throws IOException {
        synchronized (lock) {
            ensureOpen();
            if (nextChar == 0)
                return;
            out.write(cb, 0, nextChar);
            nextChar = 0;
        }
    }</code></pre> 
<br> 
<br> 
<br> BufferedWriter.write和BufferedWriter.flushBuffer的方法同步在了被包装的Writer这个对象上。 
<br> 也就是说，BufferedWriter.write和BufferedWriter.flushBuffer都有同步块包围，说明按上述环境测试时，是不会出现串行现象的。 
<br> -------------------------------------------------- 
<br> 最终结果： 
<br> 1，windows下，可以开多个线程操作多个FileWriter写入同一个文件，多个FileWriter切换时，会导致相互交错，破坏字符串结构的完整性。 
<br> 2，多个线程操作FileWriter或者BufferedWriter时，每一次写入操作都是可以保证原子性的，也即：FileWriter或者BufferedWriter是线程安全的——呃，这个结论貌似好简单啊，JDK文档里有说明吗？没看到啊。 
<br> 3，由于第2条中的线程安全，写入速度下降超过一半。
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3db2e07334b1eb19f138fdbb5317e078/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于客户端（浏览器）证书身份认证的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2e4446da6b273745cc8c82e821478710/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ENVI4.8安装之MSVC_sp1_x86</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>