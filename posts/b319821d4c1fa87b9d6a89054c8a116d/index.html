<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>jpa 定义中间表实体_Spring Data JPA实体详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="jpa 定义中间表实体_Spring Data JPA实体详解" />
<meta property="og:description" content="1. Spring Data JPA实体概述
JPA提供了一种简单高效的方式来管理Java对象(POJO)到关系数据库的映射，此类Java对象称为JPA实体或简称实体。实体通常与底层数据库中的单个关系表相关联，每个实体的实例表示数据库表格中的某一行。
2. Spring Data JPA实体管理器
2.1 实体管理器概述
实体管理器(EntityManager)用于管理系统中的实体，它是实体与数据库之间的桥梁，通过调用实体管理器的相关方法可以把实体持久化到数据库中，同时也可以把数据库中的记录打包成实体对象。
2.2 实体管理器的常用方法
2.2.1 实体的四种状态
在此之前我们要先了解实体的状态及其转换，见下图
JPA实体生命周期有四种状态
新建状态(New)：对象在保存进数据库之前为临时状态。此时数据库中没有该对象的信息，该对象的ID属性也为空。如果没有被持久化，程序退出时临时状态的对象信息将丢失。
托管状态(Managed)：对象在保存进数据库后或者从数据库中加载后、并且没有脱离Session时为持久化状态。这时候数据库中有对象的信息，改对象的id为数据库中对应记录的主键值。由于还在Session中，持久化状态的对象可以执行任何有关数据库的操作，例如获取集合属性的值等。
游离状态(Datached)：是对象曾经处于持久化状态、但是现在已经离开Session了。虽然分离状态的对象有id值，有对应的数据库记录，但是已经无法执行有关数据库的操作。例如，读取延迟加载的集合属性，可能会抛出延迟加载异常。
删除状态(Removed)：删除的对象，有id值，尚且和Persistence Context有关联，但是已经准备好从数据库中删除。
状态名
作为java对象存在
在实体管理器中存在
在数据库存在
New
Y
N
N
Managed
Y
Y
Y
Datached
N
N
N
Removed
Y
Y
N
用一段程序来示范
@Transactionalpublic voidsave(){//New 状态
Task t = newTask();
t.setTaskName(&#34;task&#34; &#43; newDate().getTime());
t.setCreateTime(newDate());//Managed状态
em.persist(t); //实体类t已经有id t.getId();
t.setTaskName(&#34;kkk&#34;); //更新任务名称，这时，如果提交事务，则直接将kkk更新到数据库//Detached状态 事务提交或者调用em.clear都直接将实体任务状态变为Detached
em.clear();
t.setTaskName(&#34;kkk&#34;); //更新数据不会更新到数据库//Removed状态
em.remove(t);
}
2.2.2 实体管理器的常用方法
对应于实体的四种状态，实体管理器有四种常用的方法，分别是：persist / merge / clear / remove，结合状态图，可以判断，对于不同状态下的实体，各个方法操作结果会有不同：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b319821d4c1fa87b9d6a89054c8a116d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-24T09:18:42+08:00" />
<meta property="article:modified_time" content="2020-12-24T09:18:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">jpa 定义中间表实体_Spring Data JPA实体详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>1. Spring Data JPA实体概述</p> 
 <p>JPA提供了一种简单高效的方式来管理Java对象(POJO)到关系数据库的映射，此类Java对象称为JPA实体或简称实体。实体通常与底层数据库中的单个关系表相关联，每个实体的实例表示数据库表格中的某一行。</p> 
 <p>2. Spring Data JPA实体管理器</p> 
 <p>2.1 实体管理器概述</p> 
 <p>实体管理器(EntityManager)用于管理系统中的实体，它是实体与数据库之间的桥梁，通过调用实体管理器的相关方法可以把实体持久化到数据库中，同时也可以把数据库中的记录打包成实体对象。</p> 
 <p>2.2 实体管理器的常用方法</p> 
 <p>2.2.1 实体的四种状态</p> 
 <p>在此之前我们要先了解实体的状态及其转换，见下图</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>JPA实体生命周期有四种状态</p> 
 <p>新建状态(New)：对象在保存进数据库之前为临时状态。此时数据库中没有该对象的信息，该对象的ID属性也为空。如果没有被持久化，程序退出时临时状态的对象信息将丢失。</p> 
 <p>托管状态(Managed)：对象在保存进数据库后或者从数据库中加载后、并且没有脱离Session时为持久化状态。这时候数据库中有对象的信息，改对象的id为数据库中对应记录的主键值。由于还在Session中，持久化状态的对象可以执行任何有关数据库的操作，例如获取集合属性的值等。</p> 
 <p>游离状态(Datached)：是对象曾经处于持久化状态、但是现在已经离开Session了。虽然分离状态的对象有id值，有对应的数据库记录，但是已经无法执行有关数据库的操作。例如，读取延迟加载的集合属性，可能会抛出延迟加载异常。</p> 
 <p>删除状态(Removed)：删除的对象，有id值，尚且和Persistence Context有关联，但是已经准备好从数据库中删除。</p> 
 <p>状态名</p> 
 <p>作为java对象存在</p> 
 <p>在实体管理器中存在</p> 
 <p>在数据库存在</p> 
 <p>New</p> 
 <p>Y</p> 
 <p>N</p> 
 <p>N</p> 
 <p>Managed</p> 
 <p>Y</p> 
 <p>Y</p> 
 <p>Y</p> 
 <p>Datached</p> 
 <p>N</p> 
 <p>N</p> 
 <p>N</p> 
 <p>Removed</p> 
 <p>Y</p> 
 <p>Y</p> 
 <p>N</p> 
 <p>用一段程序来示范</p> 
 <p>@Transactionalpublic voidsave(){//New 状态</p> 
 <p>Task t = newTask();</p> 
 <p>t.setTaskName("task" + newDate().getTime());</p> 
 <p>t.setCreateTime(newDate());//Managed状态</p> 
 <p>em.persist(t); //实体类t已经有id t.getId();</p> 
 <p>t.setTaskName("kkk"); //更新任务名称，这时，如果提交事务，则直接将kkk更新到数据库//Detached状态 事务提交或者调用em.clear都直接将实体任务状态变为Detached</p> 
 <p>em.clear();</p> 
 <p>t.setTaskName("kkk"); //更新数据不会更新到数据库//Removed状态</p> 
 <p>em.remove(t);</p> 
 <p>}</p> 
 <p>2.2.2  实体管理器的常用方法</p> 
 <p>对应于实体的四种状态，实体管理器有四种常用的方法，分别是：persist / merge / clear / remove，结合状态图，可以判断，对于不同状态下的实体，各个方法操作结果会有不同：</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>对于不同状态下的实体，persist 操作结果如下：</p> 
 <p>新建状态：实体状态迁移到托管状态</p> 
 <p>托管状态：实体状态不发生改变，但会执行数据库的insert操作</p> 
 <p>游离状态：方法的调用将会抛出异常信息</p> 
 <p>删除状态：实体将重返托管状态</p> 
 <p>对于不同状态下的实体，merge操作结果如下：</p> 
 <p>新建状态：系统会执行数据库insert操作，同时返回一个托管状态的实体</p> 
 <p>托管状态：实体状态不发生改变</p> 
 <p>游离状态：系统将实体的修改保存到数据库，同时返会一个托管状态的实体</p> 
 <p>删除状态：方法调用将抛出异常</p> 
 <p>对于不同状态下的实体，refresh 操作结果如下：</p> 
 <p>新建状态：系统会执行数据库insert操作，同时返回一个托管状态的实体</p> 
 <p>托管状态：实体状态不发生改变，但会执行数据库的update操作</p> 
 <p>游离状态：实体状态将返回托管状态</p> 
 <p>删除状态：方法调用将抛出异常</p> 
 <p>对于不同状态下的实体，remove 操作结果如下：</p> 
 <p>新建状态：方法调用将抛出异常</p> 
 <p>托管状态：实体状态变成删除状态</p> 
 <p>分离状态：方法调用将抛出异常</p> 
 <p>删除状态：不发生任何操作</p> 
 <p>2.2.3 利用实体管理器管理实体(实现实体的CURD)</p> 
 <p>public classUserRepositoryImpl {<!-- --></p> 
 <p>@PersistenceContextprivateEntityManager entityManager;</p> 
 <p>@Transactionalpublic voidadd(User user) {<!-- --></p> 
 <p>entityManager.persist(user);</p> 
 <p>}</p> 
 <p>@TransactionalpublicUser update(User user) {<!-- --></p> 
 <p>User userUpdate= entityManager.find(User.class, user.getId());</p> 
 <p>userUpdate.setAddress(user.getAddress());</p> 
 <p>userUpdate.setName(user.getName());</p> 
 <p>userUpdate.setPhone(user.getPhone());returnuserUpdate;</p> 
 <p>}</p> 
 <p>@TransactionalpublicUser addOrUpdate(User user) {returnentityManager.merge(user);</p> 
 <p>}</p> 
 <p>@Transactionalpublic voiddelete(User user) {<!-- --></p> 
 <p>entityManager.remove(user);</p> 
 <p>}publicUser findOne(Integer id) {return entityManager.find(User.class, id);</p> 
 <p>}public ListfindAll() {<!-- --></p> 
 <p>String queryString= "select u from User u";</p> 
 <p>Query query=entityManager.createQuery(queryString);returnquery.getResultList();</p> 
 <p>}</p> 
 <p>}</p> 
 <p>3. Spring Data JPA实体基础映射</p> 
 <p>3.1 表映射</p> 
 <p>@Entity //表示该类为JPA实体类</p> 
 <p>@Table(name="t_user") //对应数据库中哪张表</p> 
 <p>public classUser {<!-- --></p> 
 <p>@Column(name="phone_", length=11, nullable=true,columnDefinition="CHAR(10) default '000'") //对应数据库表中哪个列字段及对该字段的自定义</p> 
 <p>private String phone;</p> 
 <p>3.2 主键映射</p> 
 <p>@Id //标明主键</p> 
 <p>@GeneratedValue //主键生成策略</p> 
 <p>@Column(name="id_")private Integer id;</p> 
 <p>更多的主键生成策略，详见3.6 的总体代码</p> 
 <p>3.3 字段映射和约束条件</p> 
 <p>@Column(name="phone_", length=11, nullable=true,columnDefinition="CHAR(10) default '000'") //对应数据库中哪个列及对该字段的自定义</p> 
 <p>private String phone;</p> 
 <p>3.4 单实体多表格存储</p> 
 <p>通常一个实体对应于一个表格，即表格中的所有的实体属性都存放于一张表，如果将实体的属性分配到多个表格存放，就涉及到单实体多表格存储</p> 
 <p>@Entity</p> 
 <p>@Table(name="t_user",catalog="",schema="")</p> 
 <p>@SecondaryTables({//指明存放的第二张表</p> 
 <p>@SecondaryTable(name = "t_address",pkJoinColumns=@PrimaryKeyJoinColumn(name="address_id"))</p> 
 <p>})public classUser {<!-- --></p> 
 <p>@Column(name="name_", length=60, nullable=false,unique=true,insertable=false)privateString name;//分表存储</p> 
 <p>@Column(table = "t_address", name="street_", length = 100)private String street;</p> 
 <p>3.5 内嵌实体</p> 
 <p>在定义实体时可能需要将某几个的属性剥离出放到另外一个实体中，以使程序更有层次感，并且当其他实体也需要这几个属性时，我们也不需要再定义这几个属性，把存放这几个属性的实体重新引用即可，操作方法如下：</p> 
 <p>@Embeddable //标识该实体可嵌入到其他实体中</p> 
 <p>public classComment {<!-- --></p> 
 <p>@Column(name="title_",length=100)</p> 
 <p>String title;</p> 
 <p>@Column(name="content_")</p> 
 <p>String content;</p> 
 <p>/*//被剥离出的属性</p> 
 <p>@Column(name="title_",length=100)</p> 
 <p>String title;</p> 
 <p>@Column(name="content_")</p> 
 <p>String content;*/@Embedded//引入该实体</p> 
 <p>@AttributeOverrides({ //罗列出所有需要重新命名的属性</p> 
 <p>@AttributeOverride(name = "title", column = @Column(name = "user_title")),</p> 
 <p>@AttributeOverride(name= "content", column = @Column(name = "user_content"))</p> 
 <p>})privateComment comment;</p> 
 <p>内嵌实体在数据库中不会一点单独的表格存放，而是跟数组实体存放于同一表格中。</p> 
 <p>3.6 实体类代码</p> 
 <p>importjava.math.BigDecimal;importjava.util.Date;import javax.persistence.*;importorg.hibernate.annotations.GenericGenerator;</p> 
 <p>@Entity</p> 
 <p>@Table(name="t_user",catalog="",schema="")</p> 
 <p>@SecondaryTables({<!-- --></p> 
 <p>@SecondaryTable(name= "t_address",pkJoinColumns=@PrimaryKeyJoinColumn(name="address_id"))</p> 
 <p>})public classUser {<!-- --></p> 
 <p>@Id//标明主键</p> 
 <p>@GeneratedValue //主键生成策略</p> 
 <p>@Column(name="id_")privateInteger id;/*@Id</p> 
 <p>@GeneratedValue(generator="uuidGenerator")</p> 
 <p>@GenericGenerator(name="uuidGenerator",strategy="uuid")</p> 
 <p>@Column(name="id_",length=32)</p> 
 <p>private String id;*/</p> 
 <p>/*@Id</p> 
 <p>@GeneratedValue(strategy = GenerationType.AUTO)</p> 
 <p>@Column(name="id_")</p> 
 <p>private Integer id;*/</p> 
 <p>/**</p> 
 <p>@Id</p> 
 <p>@GeneratedValue(strategy=GenerationType.IDENTITY)</p> 
 <p>@Column(name="id_")</p> 
 <p>private Integer id;*/</p> 
 <p>/*@Id</p> 
 <p>@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "idGenerator")</p> 
 <p>@SequenceGenerator(name = "idGenerator",sequenceName="mySeq",allocationSize=1)</p> 
 <p>@Column(name="id_")</p> 
 <p>private Integer id;*/</p> 
 <p>/*@Id</p> 
 <p>@GeneratedValue(strategy = GenerationType.TABLE, generator = "userGenerator")</p> 
 <p>@TableGenerator(name = "userGenerator",table="pk_generator",</p> 
 <p>pkColumnName="gen_name",</p> 
 <p>valueColumnName="gen_value",</p> 
 <p>pkColumnValue="user_pk",</p> 
 <p>initialValue=0,</p> 
 <p>allocationSize=1)</p> 
 <p>@Column(name="id_")</p> 
 <p>private Integer id;*/@Column(name="name_", length=60, nullable=false,unique=true,insertable=false)privateString name;</p> 
 <p>@Column(name="address_", length=60, nullable=false)privateString address;</p> 
 <p>@Column(name="phone_", length=11, nullable=true,columnDefinition="CHAR(10) default '000'")privateString phone;</p> 
 <p>@Column(name="inCome_", precision=12, scale=2)privateBigDecimal inCome;</p> 
 <p>@Temporal(TemporalType.DATE)privateDate birthday;//Date 日期型，精确到年月日，例如“2008-08-08”//Time 时间型，精确到时分秒，例如“20:00:00”//Timestamp 时间戳，精确到纳秒，例如“2008-08-08 20:00:00.000000001”</p> 
 <p>@Lob</p> 
 <p>@Column(name="pic_")</p> 
 <p>@Basic(fetch=FetchType.LAZY)private byte[] pic;</p> 
 <p>@Lob</p> 
 <p>@Column(name="note_")</p> 
 <p>@Basic(fetch=FetchType.LAZY)privateString note;//分表存储</p> 
 <p>@Column(table = "t_address", name="street_", length = 100)privateString street;//分表存储</p> 
 <p>@Column(table = "t_address", name="city_")privateString city;//分表存储</p> 
 <p>@Column(table = "t_address", name="conutry_",length = 20)privateString conutry;</p> 
 <p>@Column(name="title_",length=100)</p> 
 <p>String title;</p> 
 <p>@Column(name="content_")</p> 
 <p>String content;/*@Embedded //引入该实体</p> 
 <p>@AttributeOverrides({ //罗列出所有需要重新命名的属性</p> 
 <p>@AttributeOverride(name = "title", column = @Column(name = "user_title")),</p> 
 <p>@AttributeOverride(name = "content", column = @Column(name = "user_content"))</p> 
 <p>})</p> 
 <p>private Comment comment;*/</p> 
 <p>//省略get/set方法</p> 
 <p>}</p> 
 <p>4. Spring Data JPA实体高级映射</p> 
 <p>4.1 一对一实体映射的概念和实现方法</p> 
 <p>如下例，人员表(person)和地址表(adddress)，person表是关系的拥有者，表中的address_id字段关联着address表的主键id。</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>@Entitypublic classPerson {//略</p> 
 <p>@OneToOne</p> 
 <p>@JoinColumn(name="address_id",referencedColumnName="aid")//name：主表的外键字段； referencedColumnName：从表的主键//如果关联的字段有多个，采用如下注解//@JoinColumns(value={@JoinColumn(name="address_id",referencedColumnName="aid"),@JoinColumn(name="address_id2",referencedColumnName="aid2")})</p> 
 <p>private Address address;</p> 
 <p>4.2 一对多实体映射的概念和实现方法</p> 
 <p>部门表(depart)和员工表(employee)，一个部门可以有多个员工，一对多关系可以采用如下两种实现方法。</p> 
 <p>4.2.1 中间表方式</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>创建中间表(depart_employee)，表中存放两个表的主键。通过部门id可查询关联员工的id，三张表存在两个主外键关系。</p> 
 <p>@Entitypublic classDepart {//略</p> 
 <p>@OneToMany</p> 
 <p>@JoinTable(name= "depart_employee", //name：关联表</p> 
 <p>joinColumns = @JoinColumn(name = "depart_id",referencedColumnName="did"), //joinColumns：关系的拥有者与关联表的关系</p> 
 <p>inverseJoinColumns = @JoinColumn(name = "employee_id",referencedColumnName="eid"))//inverseJoinColumns：关系的被拥有者与关联表的关系</p> 
 <p>private List employees;</p> 
 <p>4.2.2 从表增加外键方式</p> 
 <p>在员工表(employee2)中添加一个depart_id字段，它作为外键关联部门表(depart2)的主键id。</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>@Entitypublic classDepart2 {//略</p> 
 <p>@OneToMany</p> 
 <p>@JoinColumn(name="depart_id",referencedColumnName="id")private List employee2s;</p> 
 <p>4.3 多对多实体映射的概念的实现方法</p> 
 <p>多对多的实现也是通过中间表，方法同一对多的中间表实现方式。</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>@Entitypublic classTeacher {//略</p> 
 <p>@ManyToMany</p> 
 <p>@JoinTable(name= "teacher_student",</p> 
 <p>joinColumns= @JoinColumn(name = "teacher_id",referencedColumnName="tid"),</p> 
 <p>inverseJoinColumns= @JoinColumn(name = "student_id",referencedColumnName="sid"))private Liststudents;</p> 
 <p>@Entitypublic classStudent {//略</p> 
 <p>@ManyToMany(mappedBy= "students")private List teachers;</p> 
 <p>4.4 级联策略和懒加载</p> 
 <p>以@OneToOne为例，当我希望删除人员信息时，也将其地址信息删除，则可使用级联策略；当我想要查询人员信息(主实体)时，并不想同时查询出其地址信息(子实体)，可以设置懒加载。</p> 
 <p>@Entitypublic classPerson {<!-- --></p> 
 <p>@OneToOne(cascade={CascadeType.REFRESH,CascadeType.REMOVE},fetch=FetchType.LAZY)//@JoinColumn(name="address_id",referencedColumnName="aid")</p> 
 <p>private Address address;</p> 
 <p>5. Spring Data JPA实体继承</p> 
 <p>5.1 实体继承的概念</p> 
 <p>继承[extends]想必已不陌生，对于JPA来说，我们不但要考虑如何实现Java端的继承关系，还要考虑如何持久化到数据库中。JPA为此提供了三种策略，如下：</p> 
 <p>5.2 实体继承策略</p> 
 <p>继承关系如图，继承策略的注解主要应用于父类Item。</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>5.2.1 继承策略之单一表策略</p> 
 <p>@Entity</p> 
 <p>@Inheritance(strategy=InheritanceType.SINGLE_TABLE)public class Item {<!-- --></p> 
 <p>执行单一表策略会将所有实体的信息存放于一张表中，它的优点是信息存放于一张表，查询效率较高，缺点是大量字段为空，浪费存储空间。</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>如果类名过长或需要更改鉴别字段的名称，可对鉴别字段及可选值自定义：</p> 
 <p>@Entity</p> 
 <p>@Inheritance(strategy=InheritanceType.SINGLE_TABLE)</p> 
 <p>@DiscriminatorColumn(name="ITYPE",discriminatorType=discriminatorType.CHAR) //声明鉴别字段的字段名，类型</p> 
 <p>@DiscriminatorValue("I") //该表在鉴别字段列显示的值</p> 
 <p>public class Item {<!-- --></p> 
 <p>@Entity</p> 
 <p>@DiscriminatorValue("P")public class Phone extends Item {<!-- --></p> 
 <p>@Entity</p> 
 <p>@DiscriminatorValue("B")public class Book extends Item {<!-- --></p> 
 <p>效果如下</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>5.2.2 继承策略之连接表策略</p> 
 <p>@Entity</p> 
 <p>@Inheritance(strategy=InheritanceType.JOINED)public class Item {<!-- --></p> 
 <p>连接表策略会生成三张表，通过共享主键彼此关联。</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>这种策略避免了空字段的浪费，但由于采用表关联查询，当数据量过大时，查询效率较低。</p> 
 <p>5.2.3 继承策略之每个类策略</p> 
 <p>@Entity</p> 
 <p>@Inheritance(strategy=InheritanceType.TABLE_PER_CLASS)public classItem {/*@Id</p> 
 <p>@GeneratedValue(strategy = GenerationType.AUTO)*/@Id</p> 
 <p>@GeneratedValue(strategy= GenerationType.TABLE, generator = "ItemGenerator")</p> 
 <p>@TableGenerator(name= "ItemGenerator",table="pk_generator",</p> 
 <p>pkColumnName="gen_name",</p> 
 <p>valueColumnName="gen_value",</p> 
 <p>pkColumnValue="item_pk",</p> 
 <p>initialValue=0,</p> 
 <p>allocationSize=1)private Long id;</p> 
 <p>每个类策略实际上是每个类一个表策略，这种策略要求主键不能使用自增的方式，如上面的代码，采用表中获取的方式。</p> 
 <p align="center"><img src="" alt=""></p> 
 <p>三张表各自存放自己的完整信息，表之间没有任何的关联关系。虽然他们各自存放各自的数据，但主键是连续的。即三个表共用一套主键生成策略(三个表的主键都从另一个表中获取)。</p> 
 <p>这种策略查询效率高，同时也不存在大量空字段的浪费。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/228dc6f6aabbe73dca1549b7489d3c7f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">air换电池 macbook_MacBook 键盘坏了怎么办？键盘服务计划 13 寸 Pro 王府井送修记录...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b8fea197942154611ca7cd06b3304871/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">seajs动态加载js原理_seajs的加载原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>