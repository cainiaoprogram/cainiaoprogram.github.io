<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c语言图形函数 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c语言图形函数" />
<meta property="og:description" content="c语言图形函数 封闭图形的填充 填充就是用规定的颜色和图模填满一个封闭图形。 一、先画轮廓再填充 TURBO C提供了一些先画出基本图形轮廓, 再按规定图模和颜色填充整个封 闭图形的函数。在没有改变填充方式时, TURBO C以默认方式填充。 下面介绍这 些函数。 void far bar(int x1, int y1, int x2, int y2); 确定一个以(x1, y1)为左上角, (x2, y2)为右下角的矩形窗口, 再按规定图 模和颜色填充。 说明: 此函数不画出边框, 所以填充色为边框。 void far bar3d(int x1, int y1, int x2, int y2, int depth, int topflag); 当topflag为非0时, 画出一个三维的长方体。当topflag为0时, 三维图形不 封顶, 实际上很少这样使用。 说明: bar3d()函数中, 长方体第三维的方向不随任何参数而变, 即始终为 45度的方向。 void far pieslice(int x, int y, int stangle, int endangle, int radius); 画一个以(x, y)为圆心, radius为半径, stangle为起始角度, endangle 为 终止角度的扇形, 再按规定方式填充。当stangle=0, endangle=360 时变成一个 实心圆, 并在圆内从圆点沿X轴正向画一条半径。 void far sector(int x, int y, int stanle, intendangle, int xradius, int yradius); 画一个以(x, y)为圆心分别以xradius, yradius为x轴和y轴半径, stangle 为起始角, endangle为终止角的椭圆扇形, 再按规定方式填充。 二、设定填充方式 TURBO C有四个与填充方式有关的函数。下面分别介绍: void far setfillstyle(int pattern, int color); color的值是当前屏幕图形模式时颜色的有效值。pattern的值及与其等价的 符号常数如表7所示。 表7." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/24d2d31228d4d82a1a1faee43b21b84c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-03T16:41:17+08:00" />
<meta property="article:modified_time" content="2019-07-03T16:41:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c语言图形函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="post_detail"> 
 <div class="post"> 
  <div class="postTitle"> 
   <a id="cb_post_title_url" href="https://www.cnblogs.com/aween/archive/2006/02/28/339893.html" rel="nofollow">c语言图形函数</a> 
  </div> 
  <div class="postText"> 
   <div id="cnblogs_post_body" class="blogpost-body">
     封闭图形的填充 
    <br>填充就是用规定的颜色和图模填满一个封闭图形。 
    <br> 
    <br>一、先画轮廓再填充 
    <br>TURBO C提供了一些先画出基本图形轮廓, 再按规定图模和颜色填充整个封 
    <br>闭图形的函数。在没有改变填充方式时, TURBO C以默认方式填充。 下面介绍这 
    <br>些函数。 
    <br> 
    <br>void far bar(int x1, int y1, int x2, int y2); 
    <br>确定一个以(x1, y1)为左上角, (x2, y2)为右下角的矩形窗口, 再按规定图 
    <br>模和颜色填充。 
    <br>说明: 此函数不画出边框, 所以填充色为边框。 
    <br> 
    <br>void far bar3d(int x1, int y1, int x2, int y2, int depth, int 
    <br>topflag); 
    <br>当topflag为非0时, 画出一个三维的长方体。当topflag为0时, 三维图形不 
    <br>封顶, 实际上很少这样使用。 
    <br>说明: bar3d()函数中, 长方体第三维的方向不随任何参数而变, 即始终为 
    <br>45度的方向。 
    <br> 
    <br>void far pieslice(int x, int y, int stangle, int endangle, int 
    <br>radius); 
    <br>画一个以(x, y)为圆心, radius为半径, stangle为起始角度, endangle 为 
    <br>终止角度的扇形, 再按规定方式填充。当stangle=0, endangle=360 时变成一个 
    <br>实心圆, 并在圆内从圆点沿X轴正向画一条半径。 
    <br> 
    <br>void far sector(int x, int y, int stanle, intendangle, int 
    <br>xradius, int yradius); 
    <br>画一个以(x, y)为圆心分别以xradius, yradius为x轴和y轴半径, stangle 
    <br>为起始角, endangle为终止角的椭圆扇形, 再按规定方式填充。 
    <br> 
    <br>二、设定填充方式 
    <br>TURBO C有四个与填充方式有关的函数。下面分别介绍: 
    <br> 
    <br>void far setfillstyle(int pattern, int color); 
    <br>color的值是当前屏幕图形模式时颜色的有效值。pattern的值及与其等价的 
    <br>符号常数如表7所示。 
    <br>表7. 关于填充式样pattern的规定 
    <br>━━━━━━━━━━━━━━━━━━━━━━━━━━━ 
    <br>符号常数 数值 含义 
    <br>─────────────────────────── 
    <br>EMPTY_FILL 0 以背景颜色填充 
    <br>SOLID_FILL 1 以实填充 
    <br>LINE_FILL 2 以直线填充 
    <br>LTSLASH_FILL 3 以斜线填充(阴影线) 
    <br>SLASH_FILL 4 以粗斜线填充(粗阴影线) 
    <br>BKSLASH_FILL 5 以粗反斜线填充(粗阴影线) 
    <br>LTBKSLASH_FILL 6 以反斜线填充(阴影线) 
    <br>HATCH_FILL 7 以直方网格填充 
    <br>XHATCH_FILL 8 以斜网格填充 
    <br>INTTERLEAVE_FILL 9 以间隔点填充 
    <br>WIDE_DOT_FILL 10 以稀疏点填充 
    <br>CLOSE_DOS_FILL 11 以密集点填充 
    <br>USER_FILL 12 以用户定义式样填充 
    <br>━━━━━━━━━━━━━━━━━━━━━━━━━━━━ 
    <br> 
    <br>除USER_FILL(用户定义填充式样)以外, 其它填充式样均可由setfillstyle() 
    <br>函数设置。当选用USER_FILL时, 该函数对填充图模和颜色不作任何改变。 之所 
    <br>以定义USER_FILL主要因为在获得有关填充信息时用到此项。 
    <br>void far setfillpattern(char * upattern,int color); 
    <br>设置用户定义的填充图模的颜色以供对封闭图形填充。 
    <br>其中upattern是一个指向8个字节的指针。这8个字节定义了8x8点阵的图形。 
    <br>每个字节的8位二进制数表示水平8点, 8个字节表示8行, 然后以此为模型向个封 
    <br>闭区域填充。 
    <br>void far getfillpattern(char * upattern); 
    <br>该函数将用户定义的填充图模存入upattern指针指向的内存区域。 
    <br>void far getfillsetings(struct fillsettingstype far * fillinfo); 
    <br>获得现行图模的颜色并将存入结构指针变量fillinfo中。其中fillsettingstype 
    <br>结构定义如下: 
    <br>struct fillsettingstype{ 
    <br>int pattern; /* 现行填充模式 * / 
    <br>int color; /* 现行填充模式 * / 
    <br>}; 
    <br>有关图形填充图模的颜色的选择, 请看下面例程。 
    <br>例11: 
    <br>#include&lt;graphics.h&gt; 
    <br>main(){ 
    <br>char str[8]={10,20,30,40,50,60,70,80}; /*用户定义图模*/ 
    <br>int gdriver,gmode,i; 
    <br>struct fillsettingstype save; /*定义一个用来存储填充信息的结构变量*/ 
    <br>gdriver=DETECT; 
    <br>initgraph(&amp;gdriver,&amp;gmode,"c:\\tc"); 
    <br>setbkcolor(BLUE); 
    <br>cleardevice(); 
    <br>for(i=0;i&lt;13;i++) 
    <br>{ 
    <br>setcolor(i+3); 
    <br>setfillstyle(i,2+i); /* 设置填充类型 * 
    <br>bar(100,150,200,50); /*画矩形并填充*/ 
    <br>bar3d(300,100,500,200,70,1); /* 画长方体并填充*/ 
    <br>pieslice(200, 300, 90, 180, 90);/*画扇形并填充*/ 
    <br>sector(500,300,180,270,200,100);/*画椭圆扇形并填充*/ 
    <br>delay(1000); /*延时1秒*/ 
    <br>} 
    <br>cleardevice(); 
    <br>setcolor(14); 
    <br>setfillpattern(str, RED); 
    <br>bar(100,150,200,50); 
    <br>bar3d(300,100,500,200,70,0); 
    <br>pieslice(200,300,0,360,90); 
    <br>sector(500,300,0,360,100,50); 
    <br>getch(); 
    <br>getfillsettings(&amp;save); /*获得用户定义的填充模式信息*/ 
    <br>closegraph(); 
    <br>clrscr(); 
    <br>printf("The pattern is %d, The color of filling is %d", 
    <br>save.pattern, save.color); /*输出目前填充图模和颜色值*/ 
    <br>getch(); 
    <br>} 
    <br>以上程序运行结束后, 在屏幕上显示出现行填充图模和颜色的常数值。 
    <br> 
    <br>三、任意封闭图形的填充 
    <br>截止目前为止, 我们只能对一些特定形状的封闭图形进行填充, 但还不能对 
    <br>任意封闭图形进行填充。为此, TURBO C 提供了一个可对任意封闭图形填充的函 
    <br>数, 其调用格式如下: 
    <br>void far floodfill(int x, int y, int border); 
    <br>其中: x, y为封闭图形内的任意一点。border为边界的颜色, 也就是封闭图 
    <br>形轮廓的颜色。调用了该函数后, 将用规定的颜色和图模填满整个封闭图形。 
    <br>注意: 
    <br>1. 如果x或y取在边界上, 则不进行填充。 
    <br>2. 如果不是封闭图形则填充会从没有封闭的地方溢出去, 填满其它地方。 
    <br>3. 如果x或y在图形外面, 则填充封闭图形外的屏幕区域。 
    <br>4. 由border指定的颜色值必须与图形轮廓的颜色值相同, 但填充色可选任 
    <br>意颜色。下例是有关floodfill()函数的用法, 该程序填充了bar3d()所画长方体 
    <br>中其它两个未填充的面。 
    <br>例12: 
    <br>#include&lt;stdlib.h&gt; 
    <br>#include&lt;graphics.h&gt; 
    <br>main() 
    <br>{ 
    <br>int gdriver, gmode; 
    <br>strct fillsettingstype save; 
    <br>gdriver=DETECT; 
    <br>initgraph(&amp;gdriver, &amp;gmode, ""); 
    <br>setbkcolor(BLUE); 
    <br>cleardevice(); 
    <br>setcolor(LIGHTRED); 
    <br>setlinestyle(0,0,3); 
    <br>setfillstyle(1,14); /*设置填充方式*/ 
    <br>bar3d(100,200,400,350,200,1); /*画长方体并填充*/ 
    <br>floodfill(450,300,LIGHTRED); /*填充长方体另外两个面*/ 
    <br>floodfill(250,150, LIGHTRED); 
    <br>rectanle(450,400,500,450); /*画一矩形*/ 
    <br>floodfill(470,420, LIGHTRED); /*填充矩形*/ 
    <br>getch(); 
    <br>closegraph(); 
    <br>} 
    <br> 
    <br>6. 有关图形窗口和图形屏幕操作函数 
    <br> 
    <br>一、图形窗口操作 
    <br>象文本方式下可以设定屏幕窗口一样, 图形方式下也可以在屏幕上某一区域 
    <br>设定窗口, 只是设定的为图形窗口而已, 其后的有关图形操作都将以这个窗口的 
    <br>左上角(0,0)作为坐标原点, 而且可为通过设置使窗口之外的区域为不可接触。 
    <br>这样, 所有的图形操作就被限定在窗口内进行。 
    <br>void far setviewport(int xl,int yl,int x2, int y2,int clipflag); 
    <br>设定一个以(xl,yl)象元点为左上角, (x2,y2)象元为右下角的图形窗口, 其 
    <br>中x1,y1,x2,y2是相对于整个屏幕的坐标。若clipflag为非0, 则设定的图形以外 
    <br>部分不可接触, 若clipflag为0, 则图形窗口以外可以接触。 
    <br>void far clearviewport(void); 
    <br>清除现行图形窗口的内容。 
    <br>void far getviewsettings(struct viewporttype far * viewport); 
    <br>获得关于现行窗口的信息,并将其存于viewporttype定义的结构变量viewport 
    <br>中, 其中viewporttype的结构说明如下: 
    <br>struct viewporttype{ 
    <br>int left, top, right, bottom; 
    <br>int cliplag; 
    <br>}; 
    <br>注明: 
    <br>1. 窗口颜色的设置与前面讲过的屏幕颜色设置相同, 但屏幕背景色和窗口 
    <br>背景色只能是一种颜色, 如果窗口背景色改变, 整个屏幕的背景色也将改变这与 
    <br>文本窗口不同。 
    <br>2. 可以在同一个屏幕上设置多个窗口, 但只能有一个现行窗口工作, 要对 
    <br>其它窗口操作, 通过将定义那个窗口的setviewport()函数再用一次即可。 
    <br>3. 前面讲过图形屏幕操作的函数均适合于对窗口的操作。 
    <br> 
    <br>/// 
    <br>本文没有结束 
    <br> 
    <br> 
    <br>二、有关文本字体、字型和输出方式的设置 
    <br>有关图形方式下的文本输出函数, 可以通过setcolor()函数设置输出文本的 
    <br>颜色。另外, 也可以改变文本字体大小以及选择是水平方向输出还是垂直方向输 
    <br>出。 
    <br> 
    <br>void far settexjustify(int horiz, int vert); 
    <br>该函数用于定位输出字符串。 
    <br>对使用outtextxy(int x, int y, char far *str textstring) 函数所输出 
    <br>的字符串, 其中哪个点对应于定位坐标(x, y)在Turbo C2.0中是有规定的。如果 
    <br>把一个字符串看成一个长方形的图形, 在水平方向显示时, 字符串长方形按垂直 
    <br>方向可分为顶部, 中部和底部三个位置, 水平方向可分为左, 中, 右三个位置, 
    <br>两者结合就有9个位置。 
    <br>settextjustify()函数的第一个参数horiz指出水平方向三个位置中的一个, 
    <br>第二个参数vert指出垂直方向三个位置中的一个, 二者就确定了其中一个位置。 
    <br>当规定了这个位置后, 用outtextxy()函数输出字符串时, 字符串长方形的这个 
    <br>规定位置就对准函数中的(x, y)位置。而对用outtext()函数输出字符串时, 这 
    <br>个规定的位置就位于现行游标的位置。有关参数horiz和vert的取值参见表9。 
    <br> 
    <br>表9. 参数horiz和vert的取值 
    <br>━━━━━━━━━━━━━━━━━━━━━━━━ 
    <br>符号常数 数值 用于 
    <br>──────────────────────── 
    <br>LEFT_TEXT 0 水平 
    <br>RIGHT_TEXT 2 水平 
    <br>BOTTOM_TEXT 0 垂直 
    <br>TOP_TEXT 2 垂直 
    <br>CENTER_TEXT 1 水平或垂直 
    <br>━━━━━━━━━━━━━━━━━━━━━━━━ 
    <br> 
    <br>void far settextstyle(int font, int direction, int charsize); 
    <br>该函数用来设置输出字符的字形(由font确定)、输出方向(由direction确定) 
    <br>和字符大小(由charsize确定)等特性。Turbo C2.0对函数中各个参数的规定见下 
    <br>列各表所示: 
    <br> 
    <br>表10. font的取值 
    <br>━━━━━━━━━━━━━━━━━━━━━━━━ 
    <br>符号常数 数值 含义 
    <br>──────────────────────── 
    <br>DEFAULT_FONT 0 8*8点阵字(缺省值) 
    <br>TRIPLEX_FONT 1 三倍笔划字体 
    <br>SMALL_FONT 2 小号笔划字体 
    <br>SANSSERIF_FONT 3 无衬线笔划字体 
    <br>GOTHIC_FONT 4 黑体笔划字 
    <br>━━━━━━━━━━━━━━━━━━━━━━━━ 
    <br> 
    <br>表11. direction的取值 
    <br>━━━━━━━━━━━━━━━━━━━━━━━━ 
    <br>符号常数 数值 含义 
    <br>──────────────────────── 
    <br>HORIZ_DIR 0 从左到右 
    <br>VERT_DIR 1 从底到顶 
    <br>━━━━━━━━━━━━━━━━━━━━━━━━ 
    <br> 
    <br>表12. charsize的取值 
    <br>━━━━━━━━━━━━━━━━━━━━━━━━ 
    <br>符号常数或数值 含义 
    <br>──────────────────────── 
    <br>1 8*8点阵 
    <br>2 16*16点阵 
    <br>3 24*24点阵 
    <br>4 32*32点阵 
    <br>5 40*40点阵 
    <br>6 48*48点阵 
    <br>7 56*56点阵 
    <br>8 64*64点阵 
    <br>9 72*72点阵 
    <br>10 80*80点阵 
    <br>USER_CHAR_SIZE=0 用户定义的字符大小 
    <br>━━━━━━━━━━━━━━━━━━━━━━━━ 
    <br> 
    <br> 
    <br>有关图形屏幕下文本输出和字体字型设置函数的用法请看下例: 
    <br>例14: 
    <br>#include&lt;graphics.h&gt; 
    <br>#include&lt;stdio.h&gt; 
    <br>int main() 
    <br>{ 
    <br>int i, gdriver, gmode; 
    <br>char s[30]; 
    <br>gdriver=DETECT; 
    <br>initgraph(&amp;gdriver, &amp;gmode, ""); 
    <br>setbkcolor(BLUE); 
    <br>cleardevice(); 
    <br>setviewport(100, 100, 540, 380, 1); /*定义一个图形窗口*/ 
    <br>setfillstyle(1, 2); /*绿色以实填充*/ 
    <br>setcolor(YELLOW); 
    <br>rectangle(0, 0, 439, 279); 
    <br>floodfill(50, 50, 14); 
    <br>setcolor(12); 
    <br>settextstyle(1, 0, 8); /*三重笔划字体, 水平放大8倍*/ 
    <br>outtextxy(20, 20, "Good Better"); 
    <br>setcolor(15); 
    <br>settextstyle(3, 0, 5); /*无衬笔划字体, 水平放大5倍*/ 
    <br>outtextxy(120, 120, "Good Better"); 
    <br>setcolor(14); 
    <br>settextstyle(2, 0, 8); 
    <br>i=620; 
    <br>sprintf(s, "Your score is %d", i); /*将数字转化为字符串*/ 
    <br>outtextxy(30, 200, s); /*指定位置输出字符串*/ 
    <br>setcolor(1); 
    <br>settextstyle(4, 0, 3); 
    <br>outtextxy(70, 240, s); 
    <br>getch(); 
    <br>closegraph(); 
    <br>return 0; 
    <br>} 
    <br> 
    <br>三、用户对文本字符大小的设置 
    <br>前面介绍的settextstyle()函数, 可以设定图形方式下输出文本字符这字体 
    <br>和大小但对于笔划型字体(除8*8点阵字以个的字体), 只能在水平和垂直方向以 
    <br>相同的放大倍数放大。为此Turbo C2.0又提供了另外一个setusercharsize() 函 
    <br>数, 对笔划字体可以分别设置水平和垂直方向的放大倍数。该函数的调用格式为: 
    <br>void far setusercharsize(int mulx, int divx, int muly, int divy); 
    <br>该函数用来设置笔划型字和放大系数, 它只有在settextstyle( ) 函数中的 
    <br>charsize为0(或USER_CHAR_SIZE)时才起作用, 并且字体为函数settextstyle() 
    <br>规定的字体。调用函数setusercharsize()后, 每个显示在屏幕上的字符都以其 
    <br>缺省大小乘以mulx/divx为输出字符宽, 乘以muly/divy为输出字符高。该函数的 
    <br>用法见下例。 
    <br> 
    <br>例15: 
    <br>#include&lt;stdio.h&gt; 
    <br>#include&lt;graphics.h&gt; 
    <br>int main() 
    <br>{ 
    <br>int gdirver, gmode; 
    <br>gdriver=DETETC; 
    <br>initgraph(&amp;gdriver, &amp;gmode, ""); 
    <br>setbkcolor(BLUE); 
    <br>cleardevice(); 
    <br>setfillstyle(1, 2); /*设置填充方式*/ 
    <br>setcolor(WHITE); /*设置白色作图*/ 
    <br>rectangle(100, 100, 330, 380); 
    <br>floodfill(50, 50, 14); /*填充方框以外的区域*/ 
    <br>setcolor(12); /*作图色为淡红*/ 
    <br>settextstyle(1, 0, 8);/*三重笔划字体, 放大8倍*/ 
    <br>outtextxy(120, 120, "Very Good"); 
    <br>setusercharsize(2, 1, 4, 1);/*水平放大2倍, 垂直放大4倍*/ 
    <br>setcolor(15); 
    <br>settextstyle(3, 0, 5); /*无衬字笔划, 放大5倍*/ 
    <br>outtextxy(220, 220, "Very Good"); 
    <br>setusercharsize(4, 1, 1, 1); 
    <br>settextstyle(3, 0, 0); 
    <br>outtextxy(180, 320, "Good"); 
    <br>getch(); 
    <br>closegraph(); 
    <br>return 0; 
    <br>} 
    <br> 
   </div> 
   <div id="MySignature"></div> 
   <div class="clear"></div> 
   <div id="blog_post_info_block"> 
    <div id="BlogPostCategory"></div> 
    <div id="EntryTag"></div> 
    <div id="blog_post_info"> 
    </div> 
    <div class="clear"></div> 
    <div id="post_next_prev"></div> 
   </div> 
  </div> 
  <div class="postfoot">
    posted on 
   <span id="post-date">2006-02-28 20:43</span> 
   <a href="https://www.cnblogs.com/aween/" rel="nofollow">Aween's Blog</a> 阅读( 
   <span id="post_view_count">...</span>) 评论( 
   <span id="post_comment_count">...</span>) 
   <a href="https://i.cnblogs.com/EditPosts.aspx?postid=339893" rel="nofollow">编辑</a> 
   <a href="#" rel="nofollow">收藏</a> 
  </div> 
 </div> 
</div> 
<p>转载于:https://www.cnblogs.com/aween/archive/2006/02/28/339893.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ba3932dbaf9baa350f58af59f63146c2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">昨天看了一本c#的教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f004d1d4da27a18eb37391e1af12ea03/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">要开始准备找工作了，昨天闲时就自己写了个数据结构排序类，包括了堆排序，归并排序，速度排序，插入排序。...</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>