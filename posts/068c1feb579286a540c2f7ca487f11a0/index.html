<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【小猫爪】AUTOSAR学习笔记10-Communication Stack之CanTsyn模块 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【小猫爪】AUTOSAR学习笔记10-Communication Stack之CanTsyn模块" />
<meta property="og:description" content="【小猫爪】AUTOSAR学习笔记10-Communication Stack之CanTsyn模块 前言1 时间同步的引入2 时间同步的角色3 时间同步过程3.1 四种报文3.2 时间同步过程 END 前言 这一节来稍微介绍一下基于CAN总线实现时间同步的CanTsyn模块。
1 时间同步的引入 时间同步有啥用呢？就拿现在爆火的ADAS来说，域控制器需要融合雷达，摄像头等传感器的数据，然后进行算法融合所有传感器的数据后最终才能进行判断和执行，这个时候就存在一个问题，因为传感器数据并不都是来源于同一个ECU，所以就需要一个手段来保证域控融合的所有传感器数据都是产自同一时刻，所以传感器在向域控制器发送传感数据时都需要加上一个时间戳，所以让车上所有的ECU里面的时间戳都保证一模一样就成了必要的事情。
而CanTsyn模块就是基于CAN总线的时间同步方案，所以它的功能也是非常的简单，就是接收一些时间同步报文，然后根据报文中包含的时间信息获取当前时间。
这里多说一句，还有在Ethernet总线上的负责时间同步的模块叫做EthTSyn模块，这个模块其实就是基于PTP (Precision Time Protocol)协议搞出来的，有的朋友可能还知道gPTP，gPTP其实是PTP协议的一个子集，而EthTSyn模块则是针对汽车应用基于PTP还额外做出一点点改变，感兴趣的朋友可自行搜索一下。
2 时间同步的角色 时间同步框架如下图所示：
Time Domain：表示哪些组件（例如节点，通信系统）链接到某个时基。一个时域可以没有、包含一个或多个子时域。如果时域的时序层次结构中不包含时间网关，即所有节点都连接到同一总线系统，则不存在子时域。
Time Subdomain：表示哪些组件（例如节点）链接到某个时基，范围仅限于一条通信总线。
Global Time Master： 在整个Time Domain中提供全局时钟基准的主时钟。
Time Master：在同一个Time Subdomain中提供全局时间基准的主时钟。
Time Gateway：在整个Time Domain中既作为上级时钟源的从时钟，又同时作为下级时钟源的主时钟源。
Time Slave：在一个Time Subdomain中作为需要同步的从时钟。
3 时间同步过程 基于CAN总线的时间同步过程从下至上可分为CANDrv、CanIf、CanTsyn、StbM四个模块，如下：
其中CanTsync模块负责时间同步实现，而StbM则负责抽象基于不同传输介质的AUTOSAR时间同步协议，为整个软件系统来提供时间同步之后的全局时间戳。其他总线原理和过程一样，下面就以CanTsync模块为例说明一下时间同步过程。
3.1 四种报文 在时间同步过程中主要有SYNC、FUP、OFS、OFNS 这四种报文，每一种报文又分为需要校验 CRC 和不需要校验 CRC 两种方式，有无CRC校验由参数CanTSynGlobalTimeTxCrcSecured决定。
在时间同步过程中，SYNC和FUP报文为一组，需要成对发送和接收，其格式如下：
报文类型(Type)Byte0Byte1Byte2Byte3Byte4~Byte7SYNC no CRC0x10User Data, 默认为 0bit7 ~ bit4:Time Domain
bit3 ~ bit0:Sequence CountUser Data, 默认为 0SyncTimeSec：48 位秒的低 32 位的部分时间SYNC CRC0x20CRCTime Domain(bit7 ~ bit4)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/068c1feb579286a540c2f7ca487f11a0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-21T11:18:14+08:00" />
<meta property="article:modified_time" content="2023-03-21T11:18:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【小猫爪】AUTOSAR学习笔记10-Communication Stack之CanTsyn模块</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>【小猫爪】AUTOSAR学习笔记10-Communication Stack之CanTsyn模块</h4> 
 <ul><li><a href="#_1" rel="nofollow">前言</a></li><li><a href="#1__5" rel="nofollow">1 时间同步的引入</a></li><li><a href="#2__12" rel="nofollow">2 时间同步的角色</a></li><li><a href="#3__23" rel="nofollow">3 时间同步过程</a></li><li><ul><li><a href="#31__30" rel="nofollow">3.1 四种报文</a></li><li><a href="#32__52" rel="nofollow">3.2 时间同步过程</a></li></ul> 
  </li><li><a href="#END_66" rel="nofollow">END</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>前言</h2> 
<p>  这一节来稍微介绍一下基于CAN总线实现时间同步的CanTsyn模块。</p> 
<h2><a id="1__5"></a>1 时间同步的引入</h2> 
<p>  时间同步有啥用呢？就拿现在爆火的ADAS来说，域控制器需要融合雷达，摄像头等传感器的数据，然后进行算法融合所有传感器的数据后最终才能进行判断和执行，这个时候就存在一个问题，因为传感器数据并不都是来源于同一个ECU，所以就需要一个手段来保证域控融合的所有传感器数据都是产自同一时刻，所以传感器在向域控制器发送传感数据时都需要加上一个时间戳，所以让车上所有的ECU里面的时间戳都保证一模一样就成了必要的事情。</p> 
<p>  而CanTsyn模块就是基于CAN总线的时间同步方案，所以它的功能也是非常的简单，就是接收一些时间同步报文，然后根据报文中包含的时间信息获取当前时间。</p> 
<p>  这里多说一句，还有在Ethernet总线上的负责时间同步的模块叫做EthTSyn模块，这个模块其实就是基于PTP (Precision Time Protocol)协议搞出来的，有的朋友可能还知道gPTP，gPTP其实是PTP协议的一个子集，而EthTSyn模块则是针对汽车应用基于PTP还额外做出一点点改变，感兴趣的朋友可自行搜索一下。</p> 
<h2><a id="2__12"></a>2 时间同步的角色</h2> 
<p>  时间同步框架如下图所示：<br> <img src="https://images2.imgbox.com/6c/61/FmECxJCq_o.png" alt="在这里插入图片描述"><br>   Time Domain：表示哪些组件（例如节点，通信系统）链接到某个时基。一个时域可以没有、包含一个或多个子时域。如果时域的时序层次结构中不包含时间网关，即所有节点都连接到同一总线系统，则不存在子时域。<br>   Time Subdomain：表示哪些组件（例如节点）链接到某个时基，范围仅限于一条通信总线。<br>   Global Time Master： 在整个Time Domain中提供全局时钟基准的主时钟。<br>   Time Master：在同一个Time Subdomain中提供全局时间基准的主时钟。<br>   Time Gateway：在整个Time Domain中既作为上级时钟源的从时钟，又同时作为下级时钟源的主时钟源。<br>   Time Slave：在一个Time Subdomain中作为需要同步的从时钟。</p> 
<h2><a id="3__23"></a>3 时间同步过程</h2> 
<p>  基于CAN总线的时间同步过程从下至上可分为CANDrv、CanIf、CanTsyn、StbM四个模块，如下：<br> <img src="https://images2.imgbox.com/93/a5/ouwbGACt_o.png" alt="在这里插入图片描述"></p> 
<p>  其中CanTsync模块负责时间同步实现，而StbM则负责抽象基于不同传输介质的AUTOSAR时间同步协议，为整个软件系统来提供时间同步之后的全局时间戳。其他总线原理和过程一样，下面就以CanTsync模块为例说明一下时间同步过程。</p> 
<h3><a id="31__30"></a>3.1 四种报文</h3> 
<p>  在时间同步过程中主要有SYNC、FUP、OFS、OFNS 这四种报文，每一种报文又分为需要校验 CRC 和不需要校验 CRC 两种方式，有无CRC校验由参数CanTSynGlobalTimeTxCrcSecured决定。</p> 
<p>  在时间同步过程中，SYNC和FUP报文为一组，需要成对发送和接收，其格式如下：</p> 
<table><thead><tr><th>报文类型</th><th>(Type)Byte0</th><th>Byte1</th><th>Byte2</th><th>Byte3</th><th>Byte4~Byte7</th></tr></thead><tbody><tr><td>SYNC no CRC</td><td>0x10</td><td>User Data, 默认为 0</td><td>bit7 ~ bit4:Time Domain<br>bit3 ~ bit0:Sequence Count</td><td>User Data, 默认为 0</td><td>SyncTimeSec：48 位秒的低 32 位的部分时间</td></tr><tr><td>SYNC CRC</td><td>0x20</td><td>CRC</td><td>Time Domain(bit7 ~ bit4)<br>Sequence Count(bit3 ~ bit0)</td><td>User Data, 默认为 0</td><td>SyncTimeSec：48 位秒的低 32 位的部分时间</td></tr><tr><td>FUP no CRC</td><td>0x18</td><td>User Data,默认为 0</td><td>Time Domain(bit7 ~ bit4)<br>Sequence Count(bit3 ~ bit0)</td><td>bit7 ~ bit3:保留位，默认为0;<br>bit2:SGW, 时间网关同步状态, 当 SGW 值为 0 时，本地时间与 GTM 同步；当 SGW 值为 1 时，本地时间与 GTM 下的 TG 同步。bit1 ~ bit0:OVS,SyncTimeNSec 溢出的部分</td><td>SyncTimeNSec：以纳秒为单位的 32 位的时间戳</td></tr><tr><td>FUP CRC</td><td>0x28</td><td>CRC</td><td>Time Domain(bit7 ~ bit4)<br>Sequence Count(bit3 ~ bit0)</td><td>bit7 ~ bit3:保留位，默认为0;<br>bit2:SGW, 时间网关同步状态, 当 SGW 值为 0 时，本地时间与 GTM 同步；当 SGW 值为 1 时，本地时间与 GTM 下的 TG 同步。bit1 ~ bit0:OVS,SyncTimeNSec 溢出的部分</td><td>SyncTimeNSec：以纳秒为单位的 32 位的时间戳</td></tr></tbody></table> 
<p>  在时间同步过程中，OFS和OFNS 报文为一组，需要成对发送和接收，其格式如下：</p> 
<table><thead><tr><th>报文类型</th><th>(Type)Byte0</th><th>Byte1</th><th>Byte2</th><th>Byte3</th><th>Byte4~Byte7</th></tr></thead><tbody><tr><td>OFS no CRC</td><td>0x30</td><td>User Data, 默认为 0</td><td>bit7 ~ bit4:Time Domain<br>bit3 ~ bit0:Sequence Count</td><td>OfsTimeSecLsbHi：从 secondsHi 开始的 8 位偏移时间戳(LSB)</td><td>OfsTimeSecLsbLo：来自 secondsLo 的 32 位偏移时间戳(LSB)</td></tr><tr><td>OFS CRC</td><td>0x40</td><td>CRC</td><td>Time Domain(bit7 ~ bit4)<br>Sequence Count(bit3 ~ bit0)</td><td>OfsTimeSecLsbHi：从 secondsHi 开始的 8 位偏移时间戳(LSB)</td><td>OfsTimeSecLsbLo：来自 secondsLo 的 32 位偏移时间戳(LSB)</td></tr><tr><td>OFNS no CRC</td><td>0x38</td><td>User Data,默认为 0</td><td>Time Domain(bit7 ~ bit4)<br>Sequence Count(bit3 ~ bit0)</td><td>OfsTimeSecMsb ：从 secondsHi 开始的 8 位偏移时间戳(MSB)</td><td>OfsTimeNSec ：以纳秒为单位的 32 位的时间戳</td></tr><tr><td>OFNS CRC</td><td>0x48</td><td>CRC</td><td>Time Domain(bit7 ~ bit4)<br>Sequence Count(bit3 ~ bit0)</td><td>OfsTimeSecMsb ：从 secondsHi 开始的 8 位偏移时间戳(MSB)</td><td>OfsTimeNSec ：以纳秒为单位的 32 位的时间戳</td></tr></tbody></table> 
<p><strong>注</strong>：当参数CanTSynUseExtendedMsgFormat为TRUE时，OFS和OFNS的报文格式就会发生改变，这里就不多做介绍了，感兴趣的朋友可参考AUTOSAR官方文档。</p> 
<h3><a id="32__52"></a>3.2 时间同步过程</h3> 
<p>  CanTsyn模块的时间同步过程如下图所示：<br> <img src="https://images2.imgbox.com/a4/ce/SvcakvUs_o.png" alt="在这里插入图片描述"></p> 
<ol><li> <p>TM节点在t0r时刻调用接口发送SYNC信号，SYNC信号中包含当前时间戳为s(t0r)，在t1r时刻SYNC信号发送完成，此时的时间为t1r，所以从TM开始发送报文，到发送成功需要时间t4r = t1r - t0r; 此时TM节点再次发送FUP信号，信号中包含的时间信息为t4r = t1r - t0r。</p> </li><li> <p>TS节点在t2r时刻接收到了SYNC报文；在t3r时间接收到了FUP报文。</p> </li><li> <p>根据以上信息，TS节点在接收完SYNC和FUP报文的时候，即可根据下面的式子算出当前时间：real time = t3r-t2r+s(t0r)+t4r。</p> </li></ol> 
<p>  对于CanTsyn模块的基本原理就说到这里了，其实还有很多小细节没有涉及到，比如Sequence Count的检查， OVS处理， CRC校验等，感兴趣的朋友可以参考文章：<a href="https://blog.csdn.net/wto9109/article/details/126475417">《AUTOSAR基础篇之CanTsyn》</a>。</p> 
<h2><a id="END_66"></a>END</h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e522a0939222b34624c1c6dc25181419/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【小猫爪】AUTOSAR学习笔记01-AUTOSAR架构简介</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/67bfec38a7f4e124914036033bc161be/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">全网最详细中英文ChatGPT-API文档（一）开始使用ChatGPT——导言</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>