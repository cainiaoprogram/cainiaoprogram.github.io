<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C# 委托和事件委托 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C# 委托和事件委托" />
<meta property="og:description" content="C# 委托和事件委托 目录 C# 委托和事件委托什么是委托？1、概念2、代码描述委托 什么是事件委托？1、概念2、代码描述事件委托 利用事件委托在不同窗体传参1、建窗体2、主窗体代码：3、子窗体代码： 什么是委托？ 1、概念 委托（Delegate）类似于 C 或 C&#43;&#43; 中函数的指针。是存有对某个方法的引用的一种引用类型变量。引用委托可在运行时被改变，特别是用于实现事件和回调方法。其来自于System.Delegate 类。
通俗的讲，委托就是让别人来做，当特别是你需要做一个不确定什么时间来操作的时候就特别有用。比如说 ，小孩不确定的肚子饿这件事情，作为父母非常负责的家长并不需要总是来询问他的小孩是否肚子饿了，只要告诉（委托）其小孩在自己肚子饿的时候表达（发出）肚子饿，来提示家长（触发请求）即可。这样就不要家长（主线程）来实时询问（查询）。大大减小了父母工作负担。
委托常用的函数方法：
public object Invoke(Delegate method);
public object Invoke(Delegate method, params object[] args);
2、代码描述委托 public delegate void weituoFunction(string data, bool Cs); //定义委托 weituoFunction _weituoFunction;//实例化委托 //WinForm加载 private void Form_Load(object sender, EventArgs e) { //委托添加对应实现的方法 _weituoFunction= new weituoFunction(RichTextboxAddDsiplay); } //定义的事件入口 private void OnPowerChange(object sender, EventArgs e) { hungryShow(&#34;Iam hungry!&#34;,true); } //委托实现的方法操作 private void RichTextboxAddDsiplay（string data, bool Cs） { if （Cs） this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/337528287a4b62cdbd73fc69bb262389/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-23T12:29:52+08:00" />
<meta property="article:modified_time" content="2023-12-23T12:29:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C# 委托和事件委托</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="C__0"></a>C# 委托和事件委托</h2> 
<p></p> 
<div class="toc"> 
 <h4>目录 </h4> 
 <ul><li><a href="#C__0" rel="nofollow">C# 委托和事件委托</a></li><li><ul><li><a href="#_5" rel="nofollow">什么是委托？</a></li><li><ul><li><a href="#1_6" rel="nofollow">1、概念</a></li><li><a href="#2_15" rel="nofollow">2、代码描述委托</a></li></ul> 
   </li><li><a href="#_55" rel="nofollow">什么是事件委托？</a></li><li><ul><li><a href="#1_56" rel="nofollow">1、概念</a></li><li><a href="#2_62" rel="nofollow">2、代码描述事件委托</a></li></ul> 
   </li><li><a href="#_123" rel="nofollow">利用事件委托在不同窗体传参</a></li><li><ul><li><a href="#1_126" rel="nofollow">1、建窗体</a></li><li><a href="#2_131" rel="nofollow">2、主窗体代码：</a></li><li><a href="#3_162" rel="nofollow">3、子窗体代码：</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr color="#000000" size='1"'> 
<h3><a id="_5"></a>什么是委托？</h3> 
<h4><a id="1_6"></a>1、概念</h4> 
<p>  委托（Delegate）类似于 C 或 C++ 中函数的指针。是存有对某个方法的引用的一种引用类型变量。引用委托可在运行时被改变，特别是用于实现事件和回调方法。其来自于System.Delegate 类。<br>   通俗的讲，委托就是让别人来做，当特别是你需要做一个不确定什么时间来操作的时候就特别有用。比如说 ，小孩不确定的肚子饿这件事情，作为父母非常负责的家长并不需要总是来询问他的小孩是否肚子饿了，只要告诉（委托）其小孩在自己肚子饿的时候表达（发出）肚子饿，来提示家长（触发请求）即可。这样就不要家长（主线程）来实时询问（查询）。大大减小了父母工作负担。</p> 
<p>  委托常用的函数方法：</p> 
<blockquote> 
 <p>public object Invoke(Delegate method);<br> public object Invoke(Delegate method, params object[] args);</p> 
</blockquote> 
<h4><a id="2_15"></a>2、代码描述委托</h4> 
<pre><code class="prism language-c">
public delegate <span class="token keyword">void</span> <span class="token function">weituoFunction</span><span class="token punctuation">(</span>string data<span class="token punctuation">,</span> bool Cs<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//定义委托</span>
weituoFunction _weituoFunction<span class="token punctuation">;</span><span class="token comment">//实例化委托</span>

<span class="token comment">//WinForm加载</span>
private <span class="token keyword">void</span> <span class="token function">Form_Load</span><span class="token punctuation">(</span>object sender<span class="token punctuation">,</span> EventArgs e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
		<span class="token comment">//委托添加对应实现的方法</span>
		_weituoFunction<span class="token operator">=</span> new <span class="token function">weituoFunction</span><span class="token punctuation">(</span>RichTextboxAddDsiplay<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>

<span class="token comment">//定义的事件入口</span>
private <span class="token keyword">void</span> <span class="token function">OnPowerChange</span><span class="token punctuation">(</span>object sender<span class="token punctuation">,</span> EventArgs e<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span> 
		<span class="token function">hungryShow</span><span class="token punctuation">(</span><span class="token string">"Iam hungry!"</span><span class="token punctuation">,</span>true<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//委托实现的方法操作</span>
private <span class="token keyword">void</span> RichTextboxAddDsiplay（string data<span class="token punctuation">,</span> bool Cs）
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> （Cs）
	this<span class="token punctuation">.</span>richTextBox_Display<span class="token punctuation">.</span><span class="token function">AppendText</span><span class="token punctuation">(</span>data <span class="token operator">+</span> “\r\n”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true则显示</span>
<span class="token punctuation">}</span>

<span class="token comment">//委托函数的定义实现，传递参数</span>
public <span class="token keyword">void</span> <span class="token function">hungryShow</span><span class="token punctuation">(</span>string data<span class="token punctuation">,</span> bool Cs<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
     this<span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>_weituoFunction<span class="token punctuation">,</span> data<span class="token punctuation">,</span> Cs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//运行委托功能</span>
<span class="token punctuation">}</span>


</code></pre> 
<p>  我用一个精简的实例，描述了一个委托，看起来有点复杂有点绕，仔细思考还是比较容易理解，和回调的方法大同小异。一个委托也是可以实行多个方法，也可以同时调用多个委托。可以携带参数，也可以不适用参数，例子中就使用了两个不同的参数。</p> 
<hr color="#000000" size='1"'> 
<h3><a id="_55"></a>什么是事件委托？</h3> 
<h4><a id="1_56"></a>1、概念</h4> 
<p>  事件委托也称之为事件代理（Event Delegation）。 是常用绑定事件的常用技巧 ，可以让底层类或方法担当的监听职责，触发自定义的事件。<br>   这里再举个简单的例子，在我们以前小时候，那时候没有这么发达的快递，也没有这么强大的互联网，我就是经常去查看我们楼下的邮箱，每一户都有一个铁箱子。有信寄到的时候邮递员就会放进去，我们不确定里面有没有信件，就经常有事没事去打开看一下。但是很大机会是空空如也，什么也没有，经常让我很是失望。现在就不一样了，什么快递短信消息，什么丰巢快递微信推送消息等等。再也不需要我们自己去查看柜子有没有收到自己的信件或快递了。这些问题都交（委托）给了邮递员或快递柜系统来处理，就好像 我们用户（最高的应用层）交给了邮递方（更底层的传输层），而事件由下至上发送事件。</p> 
<p>System.EventHandler类中的public delegate void EventHandler(object sender, EventArgs e)，就是专门针对事件委托进行为的方法。</p> 
<h4><a id="2_62"></a>2、代码描述事件委托</h4> 
<pre><code class="prism language-c">class Form1
<span class="token punctuation">{<!-- --></span>
   	<span class="token comment">//功能类实例化</span>
   	Mail _Mail<span class="token operator">=</span> new <span class="token function">Mail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   	<span class="token comment">//加载WinForm框架</span>
	private <span class="token keyword">void</span> <span class="token function">Form_Load</span><span class="token punctuation">(</span>object sender<span class="token punctuation">,</span> EventArgs e<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>	
		<span class="token comment">//添加委托事件处理</span>
		_Mail<span class="token punctuation">.</span>RxChange <span class="token operator">+=</span> OnReceivedChange<span class="token punctuation">;</span>
		_Mail<span class="token punctuation">.</span><span class="token function">RxStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//启动接收线程</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">//接收改变事件功能方法</span>
	private <span class="token keyword">void</span> <span class="token function">OnReceivedChange</span><span class="token punctuation">(</span>object sender<span class="token punctuation">,</span> EventArgs e<span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span> 
	   this<span class="token punctuation">.</span>richTextBox_Display<span class="token punctuation">.</span><span class="token function">AppendText</span><span class="token punctuation">(</span> “您有一个快递！\r\n”<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true则显示</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>


class Mail
<span class="token punctuation">{<!-- --></span>
	public event EventHandler RxChange<span class="token punctuation">;</span> <span class="token comment">//定义事件委托  </span>
	private <span class="token keyword">void</span> <span class="token function">OnDelegateChange</span><span class="token punctuation">(</span>EventArgs eventArgs<span class="token punctuation">)</span> <span class="token comment">//事件委托定义</span>
	<span class="token punctuation">{<!-- --></span>
	    this<span class="token punctuation">.</span>RxChange<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">Invoke</span><span class="token punctuation">(</span>this<span class="token punctuation">,</span> eventArgs<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//委托此类的事件功能</span>
	<span class="token punctuation">}</span>  
	<span class="token comment">//启动线程</span>
	public <span class="token keyword">void</span> <span class="token function">RxStart</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>
			ReceiveMailThread <span class="token operator">=</span> new <span class="token function">Thread</span><span class="token punctuation">(</span>new <span class="token function">ThreadStart</span><span class="token punctuation">(</span>RxThread<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//指定线程函数</span>
			ReceiveMailThread<span class="token punctuation">.</span>IsBackground <span class="token operator">=</span> true<span class="token punctuation">;</span><span class="token comment">//可后台运行</span>
			ReceiveMailThread<span class="token punctuation">.</span>Name <span class="token operator">=</span> <span class="token string">"接收邮件"</span><span class="token punctuation">;</span><span class="token comment">//线程名</span>
			ReceiveMailThread<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//线程开始</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//接收线程</span>
	public <span class="token keyword">void</span>  <span class="token function">RxThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{<!-- --></span>  	         
         try
          <span class="token punctuation">{<!-- --></span>
               <span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span>
              <span class="token punctuation">{<!-- --></span> 	
                   <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">ReceiveMailMonitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span>true<span class="token punctuation">)</span>   
                   this<span class="token punctuation">.</span><span class="token function">OnDelegateChange</span><span class="token punctuation">(</span>new <span class="token function">EventArgs</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//使用事件委托</span>
               <span class="token punctuation">}</span>
          <span class="token punctuation">}</span>
          <span class="token function">catch</span> <span class="token punctuation">(</span>Exception ex<span class="token punctuation">)</span>
          <span class="token punctuation">{<!-- --></span>                
            ex<span class="token punctuation">.</span>MessageBox<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span>ex<span class="token punctuation">.</span>Message<span class="token punctuation">,</span><span class="token string">"Err"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
	       
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  class Form1类为主类，class _Mail为分支功能类，注意他们首先必须在同一个工作空间，在_Mail类中委托事件给到 EventHandler RxChange这个定义的委托中， 传递到Form1中去。主程序中有在实例化的对象中添加OnReceivedChange方法（_Mail.RxChange += OnReceivedChange;），从而在_Mail中的委托事件触发到上层OnReceivedChange的工作。一个事件委托也可以执行多个事件或多个添加的方法。ReceiveMailMonitor()是自定义的接收监控，就没有在代码中描述了。</p> 
<hr color="#000000" size='1"'> 
<h3><a id="_123"></a>利用事件委托在不同窗体传参</h3> 
<p>  介绍一个很实用的方法，来通过委托传递窗体之间的参数，将子窗口的参数传递给主窗口并显示，这个例子没有使用到invoke，相对比较简单实用。</p> 
<h4><a id="1_126"></a>1、建窗体</h4> 
<p>  我们建立两个窗体，一个主窗体Form1，一个输入子窗体input。<br> <img src="https://images2.imgbox.com/3c/86/YxptRt6a_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/b6/cf/NoOP6U99_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_131"></a>2、主窗体代码：</h4> 
<pre><code class="prism language-c">namespace test
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 委托可以声明在命名空间中， 如果声明在类中不是全局，要加前缀引用</span>
    public delegate <span class="token keyword">void</span> <span class="token function">setTextValue</span><span class="token punctuation">(</span>string textValue<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    public partial class Form1 <span class="token operator">:</span> Form
    <span class="token punctuation">{<!-- --></span>
        public <span class="token function">Form1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">InitializeComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//按键单击事件</span>
        private <span class="token keyword">void</span> <span class="token function">button1_Click</span><span class="token punctuation">(</span>object sender<span class="token punctuation">,</span> EventArgs e<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
             <span class="token comment">//实例化输入窗口</span>
            input _input <span class="token operator">=</span> new <span class="token function">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//初始化事件添加委托的实现方法diaplay，注意不要带参。</span>
            _input<span class="token punctuation">.</span>setFormTextValue <span class="token operator">+=</span> new <span class="token function">setTextValue</span><span class="token punctuation">(</span>diaplay<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//显示输入窗口</span>
            _input<span class="token punctuation">.</span><span class="token function">ShowDialog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
	   <span class="token comment">//委托实现的方法，带参数</span>
        public  <span class="token keyword">void</span> <span class="token function">diaplay</span><span class="token punctuation">(</span>string textValue<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            DISPLAY<span class="token punctuation">.</span>Text <span class="token operator">=</span> textValue<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

</code></pre> 
<h4><a id="3_162"></a>3、子窗体代码：</h4> 
<pre><code class="prism language-c">
    public partial class input <span class="token operator">:</span> Form
    <span class="token punctuation">{<!-- --></span>
        public <span class="token function">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">InitializeComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//声明一个委托类型的事件</span>
        public event setTextValue setFormTextValue<span class="token punctuation">;</span>
		<span class="token comment">//退出关闭事件</span>
        private <span class="token keyword">void</span> <span class="token function">input_FormClosing</span><span class="token punctuation">(</span>object sender<span class="token punctuation">,</span> FormClosingEventArgs e<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//启动事件，获取输入的参数。</span>
            <span class="token function">setFormTextValue</span><span class="token punctuation">(</span>this<span class="token punctuation">.</span>textBox1<span class="token punctuation">.</span>Text<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

</code></pre> 
<p>这个实例完成了从子窗口到主窗口的数据传递，参数可以是一个也可以是多个，可以是不同的数据类型，也包括结构体等。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fd82f5b908772b2ac09f64c3a1a31d94/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">一个简单的获取显示器长宽和显示器分辨的代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/01ba66ca1824886472b1bd87c13a2315/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">洛谷 NOIP2016 普及组 回文日期 &#43; 洛谷 NOIP2017 图书管理员</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>