<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JPA：Spring Data JPA     @OneToMany级联，多方删除修改新增总结（尤其删除操作:添加注解属性orphanRemoval在下一篇解释删除） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JPA：Spring Data JPA     @OneToMany级联，多方删除修改新增总结（尤其删除操作:添加注解属性orphanRemoval在下一篇解释删除）" />
<meta property="og:description" content="一方维护关系体现在更新多方中的外键字段。
一方在oneToMany上设置的级联保存和更新很好理解，多方会随着一方进行保存和更新。但是级联删除其实只是指一方删除时会把关联的多方数据全部删除，并不能删除一方维护的多方list中remove掉的数据。所以本文所讨论的实验和是否设置级联删除是没有关系的。
本文基于实验，我们先设定有如下对象，User为一方，ContactInfo为多方。每个user有多个contactInfo。
所做的操作是先查询User，然后对关联的ContactInfo做增删改。
public class User { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String userName; private String password; @Fetch(FetchMode.SUBSELECT) @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY) @JoinColumn(name = &#34;user_id&#34;) private List&lt;ContactInfo&gt; contactInfos = new ArrayList&lt;&gt;(); } public class ContactInfo { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; private String phoneNumber; private String address; @ManyToOne(fetch = FetchType.LAZY) @JoinColumn(name = &#34;user_id&#34;) @JsonIgnore private User user; } 一对多关系，通过@onToMany注解实现，此注解有个属性mappedBy，这个属性默认为空（上面示例代码未设置，取默认值），代表一方要维护关系。如果mappedBy设置为一方对象的值，如mappedBy = &#34;user&#34;，代表一方放弃维护关系，具体表现就是在插入或者删除操作的时候，一方不会去update多方的外键。这在后面的实验中会有所体现。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/270e0a7cf81bbcc73f33c5d7587cca68/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-13T14:03:24+08:00" />
<meta property="article:modified_time" content="2019-12-13T14:03:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JPA：Spring Data JPA     @OneToMany级联，多方删除修改新增总结（尤其删除操作:添加注解属性orphanRemoval在下一篇解释删除）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#f33b45;">一方维护关系体现在更新多方中的外键字段。</span></p> 
<p>一方在oneToMany上设置的级联保存和更新很好理解，多方会随着一方进行保存和更新。但是级联删除其实只是指一方删除时会把关联的多方数据全部删除，并不能删除一方维护的多方list中remove掉的数据。所以本文所讨论的实验和是否设置级联删除是没有关系的。</p> 
<p> </p> 
<p>本文基于实验，我们先设定有如下对象，User为一方，ContactInfo为多方。每个user有多个contactInfo。</p> 
<p>所做的操作是先查询User，然后对关联的ContactInfo做增删改。</p> 
<pre class="has"><code class="language-java">public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
 
    private String userName;
 
    private String password;
 
    @Fetch(FetchMode.SUBSELECT)
    @OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    private List&lt;ContactInfo&gt; contactInfos = new ArrayList&lt;&gt;();
}
 
public class ContactInfo {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
 
    private String phoneNumber;
 
    private String address;
 
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id")
    @JsonIgnore
    private User user;
}</code></pre> 
<p>一对多关系，通过@onToMany注解实现，此注解有个属性mappedBy，这个属性默认为空（上面示例代码未设置，取默认值），代表一方要维护关系。如果mappedBy设置为一方对象的值，如mappedBy = "user"，代表一方放弃维护关系，具体表现就是在插入或者删除操作的时候，一方不会去update多方的外键。这在后面的实验中会有所体现。</p> 
<p>在讲解实验前，为了照顾没时间看完全文的读者，我先给出最终的结论：<span style="color:#f33b45;">一方应放弃维护关系，由多方自行维护。这适用于绝大多数的场景。下文会详细描述整个实验过程以及如何得出的结论。</span></p> 
<p>我们先看上面示例代码这种配置（不设置mappedBy），也就是一方不放弃维护关系的实验。</p> 
<h2>一方不放弃维护关系<br> 关系配置代码</h2> 
<pre class="has"><code class="language-java">User类
@Fetch(FetchMode.SUBSELECT)
@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
@JoinColumn(name = "user_id")
private List&lt;ContactInfo&gt; contactInfos = new ArrayList&lt;&gt;();
 
ContactInfo类
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "user_id")
@JsonIgnore
private User user;</code></pre> 
<p>实验如下</p> 
<h4><a name="t3"></a>1、多方新增</h4> 
<p> 持久化代码：</p> 
<pre class="has"><code class="language-java">User user=userRepository.findById(1L).get();
user.getContactInfos().add(ContactInfo.builder()
        	.address("朝阳望京街道")
        	.phoneNumber("18612938250").build());
userRepository.save(user);</code></pre> 
<p>JPA执行过程：</p> 
<p>1、先插入一条userId为空的contactInfo（由于未设置user）</p> 
<p> insert into contact_info (address, phone_number, user_id) values (?, ?, ?)</p> 
<p>2、然后更新userId</p> 
<p>update contact_info set user_id=? where id=?</p> 
<p>分析：</p> 
<p>步骤1的insert操作是一方级联persist触发的操作。步骤2是因为一方还要维护外键，所以会对多方新增的数据update外键。</p> 
<p>问题：</p> 
<p>如果数据库设置了外键不能为空，那么步骤1无法执行。为了避免这个问题，可以在构造ContactInfo的时候把user对象设置进来。</p> 
<h4>2、多方更新：</h4> 
<p>持久化代码：</p> 
<pre class="has"><code class="language-java">User user=userRepository.findById(1L).get();
user.getContactInfos().get(0).setPhoneNumber("88888888");
userRepository.save(user);</code></pre> 
<p>JPA执行过程：</p> 
<p>1、直接根据多方主键进行更新</p> 
<p>update contact_info set address=?, phone_number=?, user_id=? where id=?</p> 
<p> </p> 
<p>分析：</p> 
<p>因为设置了级联update，所以save user的时候会update多方contactInfo</p> 
<p> </p> 
<h4>3、多方删除：</h4> 
<p><strong>A）仅从一方的list中remove</strong></p> 
<p>持久化代码：</p> 
<pre class="has"><code class="language-java">User user=userRepository.findById(1L).get();
ContactInfo deletedContact = user.getContactInfos().get(1);
user.getContactInfos().remove(deletedContact);
userRepository.save(user);</code></pre> 
<p>JPA执行过程：</p> 
<p>只是把deletedContact的user_Id更新为null，相当于断开了关系连接。如果您的表设计外键不能为空，则数据库报错。</p> 
<p>update contact_info set user_id=null where user_id=? and id=?</p> 
<p>分析：</p> 
<p>所以从list中移除deletedContact，意味着user和此条contactInfo的关系断开了。又因为一方没有放弃关系的维护，这个操作会触发被remove掉的deletedContact的外键userId被置空。</p> 
<p>此时去掉userRepository.save(user)，什么都不会发生。这好像是废话，不过结合下面的实验对比来看，是有不同效果的。</p> 
<p>问题：</p> 
<p>并没有删除掉deletedContact数据，只是外键被置空。<span style="color:#f33b45;">如果一方和多方是聚合关系，并且不想真正删除多方数据（多方数据可以和别的一方数据再次关联），那么适用这种方式。但如果是组合关系，那么不存在多方和一方再次关联的情况，是不适用这种方式的。</span></p> 
<p>另外数据库也存在如果设置外键不能为空，不能更新的问题。</p> 
<p> </p> 
<p>B）一方list中remove，并且多方显示delete</p> 
<p>持久化代码：<br>  </p> 
<pre class="has"><code class="language-java">User user=userRepository.findById(1L).get();
ContactInfo deletedContact = user.getContactInfos().get(1);
user.getContactInfos().remove(deletedContact);
contactInfoRepository.delete(deletedContact);
userRepository.save(user);</code></pre> 
<p>JPA执行过程：</p> 
<p>1、remove操作把此条记录的user_id更新为null。</p> 
<p>update contact_info set user_id=null where user_id=? and id=?</p> 
<p>2、显式delete方法彻底删除多方的数据</p> 
<p>delete from contact_info where id=?</p> 
<p> </p> 
<p>分析：</p> 
<p>1、更新外键为空，这是因为一方要维护关系。</p> 
<p>2、删除多方数据，是因为显示调用了多方的delete方法。</p> 
<p><span style="color:#f33b45;">如果我们想彻底删除掉多方的数据，这里其实做了一次无用的更新外键为空的操作。这个操作不但无用，而切一旦设置了外键不能为空，还会导致sql执行报错！</span></p> 
<p><span style="color:#f33b45;">因此想彻底删除多方时，不要用这种方式（即一方不放弃维护关系）！</span></p> 
<p>在这个实验中，我还做了个小测试，我把userRepository.save(user)可以去掉。发现程序正确执行，并且和去掉前的结果一样。我推断是因为此时持久化操作从多方delete发出，但是外键维护关系一方未放弃，还是会执行update的操作。</p> 
<p> </p> 
<p><strong>C）只在多方delete</strong></p> 
<p>持久化代码：</p> 
<pre class="has"><code class="language-java">User user=userRepository.findById(1L).get();
ContactInfo deletedContact = user.getContactInfos().get(1);
contactInfoRepository.delete(deletedContact);
userRepository.save(user);</code></pre> 
<p>JPA执行过程：</p> 
<p>什么都没发生！</p> 
<p>分析：</p> 
<p>由于先进行了查询，所以jpa认为被删除的contactInfo数据和user的关系还在。直接删除contactInfo无效。必须先从一方持有的list中remove掉才行。</p> 
<h2> <br> 一方不放弃维护关系实验结论：</h2> 
<p><br> 由于双方都维护外键关系，一方维护关系体现在对多方外键的更新上。而remove操作，只是断开关联。但不会删除多方数据。remove之后，多方显式调用delete操作，多方才会被删除。</p> 
<p><span style="color:#f33b45;">在这种配置下，插入和删除，都会多执行一条update多方外键的sql，很多情况下是完全没必要的。而且如果数据库外键如果不能为空会报错。</span></p> 
<p>适用场景：</p> 
<p>1、多方的外键可以为空。也就是说多方和一方的关系是聚合，允许多方不关联一方。</p> 
<p>2、只想update多方外键为空，而不想彻底删除多方数据。也就是3-A)的场景。</p> 
<p> </p> 
<p>不适用场景：</p> 
<p>1、想彻底删除多方数据，而且多方外键不能为空</p> 
<p> </p> 
<p> </p> 
<h3>一方放弃维护关系</h3> 
<h4><a name="t9"></a>关系配置代码</h4> 
<pre class="has"><code class="language-java">User
@Fetch(FetchMode.SUBSELECT)
@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.LAZY, mappedBy = "user")
private List&lt;ContactInfo&gt; contactInfos = new ArrayList&lt;&gt;();</code></pre> 
<p>注：User中加上了mappedBy，代表user放弃维护外键关系</p> 
<p> </p> 
<h4>1、多方新增</h4> 
<p><strong>A）没有给contactInfo设置user</strong></p> 
<p> </p> 
<p>持久化代码：</p> 
<pre class="has"><code class="language-java">User user=userRepository.findById(1L).get();
user.getContactInfos().add(ContactInfo.builder()
        	.address("朝阳望京街道")
        	.phoneNumber("18612938250").build());
userRepository.save(user);</code></pre> 
<p>JPA执行过程：</p> 
<p>只会新增一条userId为空的contactInfo</p> 
<p>insert into contact_info (address, phone_number, user_id) values (?, ?, ?)</p> 
<p> </p> 
<p>分析：</p> 
<p>由于一方放弃维护关系，那么不会有update外键的操作。而由于设置了级联persist，所以多方数据会级联插入。但是导致插入的多方数据没有外键。如果数据库做了限制则会报错。</p> 
<p>这种方式是错误的方式，即使成功插入也没有外键值。插入的数据和代码表述的含义不一致。</p> 
<p> </p> 
<p>B）contactInfo设置user</p> 
<p>持久化代码：<br>  </p> 
<pre class="has"><code class="language-java">User user=userRepository.findById(1L).get();
user.getContactInfos().add(ContactInfo.builder()
        	.address("朝阳望京街道")
        	.phoneNumber("18612938250")
.user(user).build());
userRepository.save(user);</code></pre> 
<p>JPA执行过程：</p> 
<p>新增contactInfo，user_id正常</p> 
<p>insert into contact_info (address, phone_number, user_id) values (?, ?, ?)</p> 
<p>分析：</p> 
<p>1、由于一方放弃维护多方外键，所以新增的时候不会去更新外键。</p> 
<p>2、但由于级联新增的设置，所以还是会插入多方数据。</p> 
<p>3、多方需手动设置外键的关联对象，插入时外键才会有值。</p> 
<p><span style="color:#f33b45;">这是一方放弃关系维护时，正确的多方插入姿势！！别忘了给插入的多方数据设置关联的一方对象</span>！</p> 
<p> </p> 
<h4><strong>2、多方更新</strong></h4> 
<p>持久化代码：</p> 
<pre class="has"><code class="language-java">User user=userRepository.findById(1L).get();
user.getContactInfos().get(0).setPhoneNumber("88888888");
userRepository.save(user);</code></pre> 
<p>JPA执行过程：</p> 
<p>直接根据多方主键进行更新。和一方未放弃维护关系时一致</p> 
<p>update contact_info set address=?, phone_number=?, user_id=? where id=?</p> 
<p>分析：</p> 
<p>由于更新前，先进行了查询，并且配置了双向关联，所以被更新的contactInfo数据是有关联user的，因此更新正常。<br>  </p> 
<h4>3、多方删除</h4> 
<p><strong>A）仅从一方的list中remove</strong></p> 
<p> </p> 
<p>JPA执行过程：</p> 
<p>什么都没有发生</p> 
<p>分析：</p> 
<p>remove操作只是使关系断开。但由于一方放弃外键关系维护，所以不会更新多方外键。而由于没有显式delete多方，所以也不会删除contactInfo数据。这种删除方式显然是错误的。</p> 
<p><strong>B）仅在多方delete</strong> </p> 
<pre class="has"><code class="language-java">User user=userRepository.findById(1L).get();
 
ContactInfo deletedContact = user.getContactInfos().get(1);
//需要调用下：理解为清除对ContactInfo 表数据的引用，不然会报错关闭session或者deleted instance passed to merge:
user.getContactInfos().clear();

 
contactInfoRepository.delete(deletedContact);
 
userRepository.save(user);</code></pre> 
<p>JPA执行过程：</p> 
<p>如果没有加事务的话会删除那一条数据，但是由于user与contactInfo关联关系还在，又会新增一条一样的数据进入</p> 
<p><img alt="" class="has" height="159" src="https://images2.imgbox.com/81/6f/5ODIg4XH_o.png" width="930"></p> 
<p>分析：</p> 
<p>由于先进行了查询，所以jpa认为被删除的contactInfo和user的关系还在。直接显式删除contactInfo无效。这种删除方式也是错误的。</p> 
<p> </p> 
<p><strong>C）从一方的list中remove，并且多方显式执行delete</strong></p> 
<pre class="has"><code class="language-java">User user=userRepository.findById(1L).get();
 
ContactInfo deletedContact = user.getContactInfos().get(1);
 
user.getContactInfos().remove(deletedContact);
 
contactInfoRepository.delete(deletedContact);
 
userRepository.save(user);</code></pre> 
<p>JPA执行过程：</p> 
<p>根据主键直接删除掉contactInfo</p> 
<p>delete from contact_info where id=?</p> 
<p>结论：由于一方放弃了外键关系所以维护，所以remove的时候，一方不会去更新多方外键为null。在remove后关系断开，多方显式调用delete，可以删除掉contactInfo。</p> 
<p><span style="color:#f33b45;">这是一方放弃关系维护时，正确的多方删除姿势！！别忘了先要在一方维护的多方list中remove掉删除数据，然后多方显式调用delete。</span></p> 
<p>另外，去掉userRepository.save(user)，删除操作也是可以正常被触发的。<br>  </p> 
<h3>实验总结</h3> 
<p>我先用表格的方式呈现实验结果：</p> 
<p><img alt="" class="has" height="521" src="https://images2.imgbox.com/6f/bf/b51VyPM9_o.png" width="788"></p> 
<p> </p> 
<p>从上面总结可以看出，绝大多数场景下，<span style="color:#f33b45;">应该采取一方放弃维护关系的方式。</span>这避免了插入和删除时执行两条sql的问题，而且也不会因为数据库设置了外键字段不能为空，导致update的sql报错。新增时候，多方自己设置外键，一条insert语句搞定。删除时候也是一条delete语句搞定，效率更高。</p> 
<p>只有在一方和多方是聚合关系，并且不想彻底删除多方的场景下，一方不放弃维护关系的方式才有用武之地。</p> 
<p>其实看到最后，我们可以得出这样的结论：</p> 
<p><span style="color:#f33b45;">一方设置mappedBy，放弃关系维护。这适用于绝大多数场景。</span></p> 
<p>正确的多方新增方式：</p> 
<p><span style="color:#f33b45;">手动在多方对象设置一方对象</span></p> 
<p>正确的多方删除方式：</p> 
<p><span style="color:#f33b45;">1、从一方维护的多方list中remove，</span></p> 
<p><span style="color:#f33b45;">2、显式delete多方对象。</span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1343242e9b299581f2ba2e3f5314d8d4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">win10怎样永久设置护眼颜色，注册表改了以后重新开机又回到了原来的颜色，怎样才能永久设置，求救？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/100b04f0c6c550009c7126d4c9629ac2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LTE切换信令详析及注释（附图）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>