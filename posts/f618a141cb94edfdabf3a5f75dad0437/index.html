<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从代理模式说起，简单聊聊Java的动态代理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="从代理模式说起，简单聊聊Java的动态代理" />
<meta property="og:description" content="从代理模式说起 「代理模式」是设计模式的一种，代理模式中有两个关键的成员：「代理类」（Proxy）和「被代理类」（RealSubject）
那Proxy有啥用呢，直接访问RealSubject不行嘛？
如果「被代理类」十分庞大（消耗内存空间），但真正需要它的时候很少，我们不希望立即初始化「被代理类」从而占用内存，交给轻量级的「代理类」Proxy完成任务即可。我们希望对「被代理类」进行一些增强，比如说在方法开始执行前后打印参数的变化，执行结果等等信息，为了解耦「被代理类」的业务实现和这种与业务无关的行为逻辑，我们需要将这些与业务无关的行为逻辑剥离出来，就可以封装在「代理类」中往往这种与业务无关的行为逻辑有很多共性，这些逻辑可以被抽象为「切面」，也就是AOP，面向切面编程，通过代理模式可以极大地减少重复代码。 代理模式的实现方法 代理模式一般有两种实现方法：静态代理和动态代理。
静态代理 静态代理就是上述UML图的实现方法，可以看到「代理类」Proxy内聚一个RealObject，实现共同的接口，可以很轻松地在这个方法上做加强。
接口：
csharp
复制代码
public interface Subject { void dosth(); } 被代理类：
java
复制代码
public class RealSubject implements Subject{ @Override public void dosth(){ System.out.println(&#34;dosth...&#34;); } } 代理类：
java
复制代码
public class Proxy implements Subject{ private Subject subject; @Override public void dosth(){ System.out.println(&#34;before-------执行前增强逻辑&#34;); subject.dosth(); System.out.println(&#34;after--------执行后增强逻辑&#34;); } } 静态代理的局限性 每需要一个类被代理，就需要为之编写一个代理类，这会导致文件数量膨胀。上文提到的Proxy的第三个好处，即AOP的功能还没有实现，我们希望一个代理类能代理多个类，并且被代理的方法是我们可以指定的，这就需要动态代理来解决了。 动态代理 动态代理又有两种常见的实现：JDK动态代理和CGLIB动态代理。
JDK动态代理 基本使用 JDK动态代理中：「代理类」Proxy不再实现Subject接口，而是implements InvocationHandler，但仍聚合了被代理类（通过构造函数传入被代理类，Object类型）
代理类implements InvocationHandler,重写invoke方法
java
复制代码
public class TestInterceptor implements InvocationHandler { private Object target;//目标对象的引用，这里设计成Object类型，更具通用性 public TestInterceptor(Object target){ this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f618a141cb94edfdabf3a5f75dad0437/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-07T14:15:35+08:00" />
<meta property="article:modified_time" content="2023-10-07T14:15:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从代理模式说起，简单聊聊Java的动态代理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>从代理模式说起</h3> 
<p>「代理模式」是设计模式的一种，代理模式中有两个关键的成员：「代理类」（Proxy）和「被代理类」（RealSubject）</p> 
<p></p> 
<p class="img-center"><img alt="image-20231001220341479.png" height="338" src="https://images2.imgbox.com/0e/f9/neIK8wdD_o.png" width="865"></p> 
<p>那Proxy有啥用呢，直接访问RealSubject不行嘛？</p> 
<ul><li>如果「被代理类」十分庞大（消耗内存空间），但真正需要它的时候很少，我们不希望立即初始化「被代理类」从而占用内存，交给轻量级的「代理类」Proxy完成任务即可。</li><li>我们希望对「被代理类」进行一些增强，比如说在方法开始执行前后打印参数的变化，执行结果等等信息，为了解耦「被代理类」的业务实现和这种与业务无关的行为逻辑，我们需要将这些与业务无关的行为逻辑剥离出来，就可以封装在「代理类」中</li><li>往往这种与业务无关的行为逻辑有很多共性，这些逻辑可以被抽象为「切面」，也就是AOP，面向切面编程，通过代理模式可以极大地减少重复代码。</li></ul> 
<h3>代理模式的实现方法</h3> 
<p>代理模式一般有两种实现方法：静态代理和动态代理。</p> 
<h3>静态代理</h3> 
<p>静态代理就是上述UML图的实现方法，可以看到「代理类」Proxy内聚一个RealObject，实现共同的接口，可以很轻松地在这个方法上做加强。</p> 
<p>接口：</p> 
<pre></pre> 
<p>csharp</p> 
<p>复制代码</p> 
<p><code>public interface Subject {    void dosth(); } </code></p> 
<p>被代理类：</p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>public class RealSubject implements Subject{    @Override    public void dosth(){        System.out.println("dosth...");   } } </code></p> 
<p>代理类：</p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>public class Proxy implements Subject{    private Subject subject;    @Override    public void dosth(){        System.out.println("before-------执行前增强逻辑");        subject.dosth();        System.out.println("after--------执行后增强逻辑");   } } </code></p> 
<h5>静态代理的局限性</h5> 
<ul><li>每需要一个类被代理，就需要为之编写一个代理类，这会导致文件数量膨胀。</li><li>上文提到的Proxy的第三个好处，即AOP的功能还没有实现，我们希望一个代理类能代理多个类，并且被代理的方法是我们可以指定的，这就需要动态代理来解决了。</li></ul> 
<h3>动态代理</h3> 
<p>动态代理又有两种常见的实现：JDK动态代理和CGLIB动态代理。</p> 
<h4>JDK动态代理</h4> 
<h5>基本使用</h5> 
<p>JDK动态代理中：「代理类」Proxy不再实现Subject接口，而是<code>implements InvocationHandler</code>，但仍聚合了被代理类（通过构造函数传入被代理类，Object类型）</p> 
<p><strong>代理类<code>implements InvocationHandler</code>,重写invoke方法</strong></p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>public class TestInterceptor implements InvocationHandler {    private Object target;//目标对象的引用，这里设计成Object类型，更具通用性      public TestInterceptor(Object target){          this.target = target;     }        public Object invoke(Object proxy, Method method, Object[] arg)  throws Throwable {          System.out.println("before-------执行前逻辑");          Object result = method.invoke(target, arg);//调用目标对象的方法          System.out.println("Before return:"+result);          return result;     }   }   </code></p> 
<p><strong>利用Proxy类.newProxyInstance方法</strong></p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>public class Main {      public static void main(String[] args) {          RealSubject target = new RealSubject();//生成目标对象          //接下来创建代理对象          Subject proxy = (Subject) Proxy.newProxyInstance(                  target.getClass().getClassLoader(),                  target.getClass().getInterfaces(), new TestInterceptor(target));          //调用代理类的方法，有切面逻辑        proxy.dosth();     }   }   </code></p> 
<p>获取proxy的名称，发现是$Proxy0</p> 
<h5>实现原理</h5> 
<p>通过前文的基本使用，我们了解到了两个关键点：InvocationHandler接口和Proxy代理类。</p> 
<p>InvocationHandler只有一个invoke方法</p> 
<pre></pre> 
<p>typescript</p> 
<p>复制代码</p> 
<p><code>public interface InvocationHandler {   public Object invoke(Object proxy, Method method, Object[] args)        throws Throwable; } </code></p> 
<p>那么重点就是Proxy.newProxyInstance方法</p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>public static Object newProxyInstance(ClassLoader loader,                                      Class&lt;?&gt;[] interfaces,                                      InvocationHandler h) {    // 1. 获取到代理类的class对象    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);    // 2. 拿到代理类的构造器，通过反射创建出一个代理类实例    final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);    final InvocationHandler ih = h;    if (!Modifier.isPublic(cl.getModifiers())) {        AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() {         public Void run() {              cons.setAccessible(true);                 return null;             }           });       }    return cons.newInstance(new Object[]{h}); } </code></p> 
<p>那getProxyClass0这个方法是如何拿到代理的class的呢</p> 
<p>其实这个方法做了参数的校验，然后直接调用proxyClassCache.get方法</p> 
<pre></pre> 
<p>kotlin</p> 
<p>复制代码</p> 
<p><code>return proxyClassCache.get(loader, interfaces); </code></p> 
<p>这个Cache也很好理解，我们两次获取代理对象，没必要生成两个class对象，因此要复用代理类的class，我们来关注cache未命中的情况，proxyClass是如何生成的。</p> 
<p>这个proxyClassCache是Proxy内部的一个字段如下（注意两个入参）：</p> 
<pre></pre> 
<p>swift</p> 
<p>复制代码</p> 
<p><code>private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;    proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory()); </code></p> 
<p>get方法最重要的部分如下：</p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter)); // 最终这个class对象就是supplier.get方法返回的 // Supplier是一个lambda表达式 Supplier&lt;V&gt; supplier = valuesMap.get(subKey); Factory factory = null; ​ while (true) {    // 如果有supplier了 直接get，正常就返回(一般缓存命中就在这里直接return了)    if (supplier != null) {        V value = supplier.get();        if (value != null) {            return value;       }   } // 一般缓存未命中 会先创建一个Factory , Factory是一个实现了supplier的内部类    if (factory == null) {        factory = new Factory(key, parameter, subKey, valuesMap);   } // 尝试放入缓存    if (supplier == null) {        supplier = valuesMap.putIfAbsent(subKey, factory);        if (supplier == null) {            supplier = factory;       }   } else {        if (valuesMap.replace(subKey, supplier, factory)) {            supplier = factory;       } else {            supplier = valuesMap.get(subKey);       }   } } </code></p> 
<p>那么核心就是Factory.get方法了：</p> 
<pre></pre> 
<p>ini</p> 
<p>复制代码</p> 
<p><code>value = Objects.requireNonNull(valueFactory.apply(key, parameter)); return value; </code></p> 
<p>兜兜转转又回到了proxyClassCache的构造函数的第二个参数了，就是ProxyClassFactory</p> 
<p>核心：ProxyClassFactory</p> 
<p><strong>代理类名的由来</strong></p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>// 前缀 private static final String proxyClassNamePrefix = "$Proxy"; // 原子long private static final AtomicLong nextUniqueNumber = new AtomicLong(); // 代理类名 long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; </code></p> 
<p>最后调用到：</p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>byte[] proxyClassFile = ProxyGenerator.generateProxyClass(   proxyName, interfaces, accessFlags); return defineClass0(loader, proxyName,                    proxyClassFile, 0, proxyClassFile.length); </code></p> 
<p>发现generateProxyClass非常晦涩难懂，并且defineClass0是个native方法，总之是生成了字节码文件并加载了class对象，只能反编译查看代理类的实现。</p> 
<p>发现代理类继承了Proxy，被代理的方法以Method的形式存储，最终通过反射的方式来调用。</p> 
<h4>CGLIB动态代理</h4> 
<p><strong>cglib不再需要被代理类实现一个接口</strong>，这是和JDK动态代理与静态代理的不同点，这可以帮助我们远离必须实现接口的困扰。</p> 
<h5>基本使用</h5> 
<p>被代理类：</p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>public class RealSubject{    public void dosth(){        System.out.println("dosth...");   } } ​ </code></p> 
<p>代理类， 实现 <code>MethodInterceptor</code>接口</p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>public class CglibProxy implements MethodInterceptor {    @Override    public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {        System.out.println("xxx");        methodProxy.invokeSuper(object, args);        System.out.println("xxx");        return null;   } } </code></p> 
<p>利用Enhancer创建代理对象。</p> 
<pre></pre> 
<p>java</p> 
<p>复制代码</p> 
<p><code>public class CglibTest {    public static void main(String[] args) {        CglibProxy cglibproxy = new CglibProxy();        Enhancer enhancer = new Enhancer();        // 设置enhancer对象的父类(被代理类)        enhancer.setSuperclass(RealSubject.class);        // 设置enhancer的回调对象(代理类)        enhancer.setCallback(cglibproxy);        // 创建代理对象        RealSubject proxy = (RealSubject) enhancer.create();        proxy.dosth();   } } </code></p> 
<h5>实现原理</h5> 
<p>如果要从ASM开始了解太费精力了，一种做法是直接看cglib生成的所有类反向推。</p> 
<p>cglib主要通过ASM直接修改字节码文件，再通过类加载器加载生成一个class对象，就是我们的代理类Proxy，最后依然通过反射拿到Proxy的构造方法并创建一个实例对象并返回。</p> 
<p>cglib的代理类Proxy实际上是继承被代理类RealSubject的，并且实现了Factory接口，因此cglib的局限性是：<strong>final类是无法被代理的</strong>。</p> 
<p>cglib实际会生成五个字节码文件，比较重要的有三个，代理类，以及两个FastClass分别对应代理类和被代理类，所以在生成代理对象时会慢一些。cglib调用原始方法是通过FastClass的下标进行调用的。而JDK动态代理是通过反射进行调用的。</p> 
<p>建议自己动手反编译代理类看一下，篇幅原因这里就不贴了，实在不想动手也可以参考：<a href="https://juejin.cn/post/6844904054833807374" rel="nofollow" title="分析cglib动态代理的实现">分析cglib动态代理的实现</a></p> 
<h3>如何理解静态与动态的区别</h3> 
<p>静态代理，是一对一的关系。是确定了「被代理类」，专为此「被代理类」创建了一个代理类。</p> 
<p>而动态代理，是多对多关系。解耦了「代理逻辑」与「被代理类」，彼此不相干。静态代理的主体是「被代理类」，而动态代理的主体既是「被代理类」，也是「代理逻辑」。只是我们在真正需要代理的时候，才把他们结合到一起。这里说「代理逻辑」，是因为真正的「代理类」是动态生成的，在此之前并不知道会用什么「代理逻辑」。而静态代理的「代理类」是静态的，代理逻辑是确定的。所以也可以说，静态代理我们是在编写「代理类」，而动态代理我们是在编写「代理逻辑」。</p> 
<h3>JDK与cglib的区别</h3> 
<ul><li>JDK的核心是反射，cglib的核心是ASM</li><li>通常JDK的效率更高，一种佐证是：Spring默认使用JDK，没有实现接口才用cglib</li><li>JDK是委托机制，cglib是继承关系</li><li>JDK要求被代理类必须实现某个接口，而cglib要求被代理类不被final修饰</li></ul> 
<h4>SpringBoot默认cglib实现AOP</h4> 
<p>SpringBoot关于Spring AOP的配置类：AopAutoConfiguration，默认使用 Cglib 来实现AOP。</p> 
<p>这样设置的原因是：避免在没有实现接口时报错（无法使用JDK动态代理）</p> 
<p>可以通过在配置文件中输入如下命令关闭cglib</p> 
<pre></pre> 
<p>properties</p> 
<p>复制代码</p> 
<p><code>spring.aop.proxy-target-class=false</code></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c00b44bd240756a8eb76383a28510b9c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JavaScript入门——基础知识（3）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/01fdf1db4fede79e97f6b833c2be1d29/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">qt开发从入门到实战2</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>