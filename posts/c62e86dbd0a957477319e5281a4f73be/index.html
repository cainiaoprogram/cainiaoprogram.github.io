<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>requestparam与requestbody - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="requestparam与requestbody" />
<meta property="og:description" content="@RequestParam 注解@RequestParam接收的参数是来自HTTP请求体或请求url的QueryString中。
RequestParam可以接受简单类型的属性，也可以接受对象类型。
@RequestParam有三个配置参数：
required 表示是否必须，默认为 true，必须。defaultValue 可设置请求参数的默认值。value 为接收url的参数名（相当于key值）。 @RequestParam用来处理 Content-Type 为 application/x-www-form-urlencoded 编码的内容，Content-Type默认为该属性。@RequestParam也可用于其它类型的请求，例如：POST、DELETE等请求。
所以在postman中，要选择body的类型为 x-www-form-urlencoded，这样在headers中就自动变为了 Content-Type : application/x-www-form-urlencoded 编码格式。如下图所示：
但是这样不支持批量插入数据啊，如果改用 json 字符串来传值的话，类型设置为 application/json，点击发送的话，会报错，后台接收不到值，为 null。
但可以入参后再转换，参考如下：
@PostMapping(&#34;/ali-receive&#34;)
public void aliReceive(@RequestParam(&#34;message&#34;) String message) { ReceiveLog receiveLog = JSON.parseObject(message, ReceiveLog.class);
}
解决Spring/SpringBoot @RequestParam注解无法读取application/json格式数据：https://blog.csdn.net/weixin_42536015/article/details/106906055
@RequestParam 接受JSON的字符串：https://blog.csdn.net/qq_40470612/article/details/104225419
不推荐使用@RequestParam接收application/json，这时候就需要使用到@RequestBody。
@RequestBody 注解@RequestBody接收的参数是来自requestBody中，即请求体。一般用于处理非 Content-Type: application/x-www-form-urlencoded编码格式的数据，比如：application/json、application/xml等类型的数据。
就application/json类型的数据而言，使用注解@RequestBody可以将body里面所有的json数据传到后端，后端再进行解析。
GET请求中，因为没有HttpEntity，所以@RequestBody并不适用。
POST请求中，通过HttpEntity传递的参数，必须要在请求头中声明数据的类型Content-Type，SpringMVC通过使用
HandlerAdapter 配置的HttpMessageConverters来解析HttpEntity中的数据，然后绑定到相应的bean上。
向表中批量插入数据
举个批量插入数据的例子，Controller层的写法如下图所示：
由于@RequestBody可用来处理 Content-Type 为 application/json 编码的内容，所以在postman中，选择body的类型为row -&gt; JSON(application/json)，这样在 Headers 中也会自动变为 Content-Type : application/json 编码格式。body内的数据如下图所示：
批量向表中插入两条数据，这里的 saveBatchNovel()方法已经封装了 JPA的 saveAll() 方法。body 里面的 json 语句的 key 值要与后端实体类的属性一一对应。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c62e86dbd0a957477319e5281a4f73be/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-30T14:57:28+08:00" />
<meta property="article:modified_time" content="2022-05-30T14:57:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">requestparam与requestbody</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <div id="article_content" class="article_content clearfix"> 
 <div id="content_views" class="htmledit_views"> 
  <h2>@RequestParam</h2> 
  <p>注解@RequestParam接收的参数是来自HTTP请求体或请求url的QueryString中。</p> 
  <p>RequestParam可以接受简单类型的属性，也可以接受对象类型。</p> 
  <p>@RequestParam有三个配置参数：</p> 
  <ul><li><code>required</code> 表示是否必须，默认为 <code>true</code>，必须。</li><li><code>defaultValue</code> 可设置请求参数的默认值。</li><li><code>value</code> 为接收url的参数名（相当于key值）。</li></ul> 
  <p><strong>@RequestParam用来处理 <code>Content-Type</code> 为 <code>application/x-www-form-urlencoded</code> 编码的内容，<code>Content-Type</code>默认为该属性</strong><strong>。@RequestParam也可用于其它类型的请求，例如：POST、DELETE等请求</strong>。</p> 
  <p>所以在postman中，要选择body的类型为 <code>x-www-form-urlencoded</code>，这样在headers中就自动变为了 <code>Content-Type</code> : <code>application/x-www-form-urlencoded</code> 编码格式。如下图所示：</p> 
  <p><img alt="" src="https://images2.imgbox.com/0a/9a/ZMgHztoh_o.jpg"></p> 
  <p>但是这样不支持批量插入数据啊，如果改用 <code>json</code> 字符串来传值的话，类型设置为 <code>application/json</code>，点击发送的话，会报错，后台接收不到值，为 <code>null</code>。</p> 
  <p>但可以入参后再转换，参考如下：</p> 
  <pre> </pre> 
  <ol><li> <p><code>@PostMapping("/ali-receive")</code></p> </li><li> <p><code>public void aliReceive(@RequestParam("message") String message) { 
      </code></p> </li><li> <p><code>ReceiveLog receiveLog = JSON.parseObject(message, ReceiveLog.class);</code></p> </li><li> </li><li> <p><code>}</code></p> </li></ol> 
  <p>解决Spring/SpringBoot @RequestParam注解无法读取application/json格式数据：<a href="https://blog.csdn.net/weixin_42536015/article/details/106906055">https://blog.csdn.net/weixin_42536015/article/details/106906055</a></p> 
  <p>@RequestParam 接受JSON的字符串：<a href="https://blog.csdn.net/qq_40470612/article/details/104225419">https://blog.csdn.net/qq_40470612/article/details/104225419</a></p> 
  <p> </p> 
  <p>不推荐使用@RequestParam接收application/json，这时候就需要使用到@RequestBody。</p> 
  <p> </p> 
  <h2>@RequestBody</h2> 
  <p><br> 注解@RequestBody接收的参数是<strong>来自requestBody</strong>中，即<strong>请求体</strong>。一般用于处理非 <code>Content-Type: application/x-www-form-urlencoded</code>编码格式的数据，比如：<code>application/json</code>、<code>application/xml</code>等类型的数据。</p> 
  <p>就<code>application/json</code>类型的数据而言，使用注解@RequestBody可以将body里面所有的json数据传到后端，后端再进行解析。</p> 
  <p>GET请求中，因为没有HttpEntity，所以@RequestBody并不适用。</p> 
  <p>POST请求中，通过HttpEntity传递的参数，必须要在请求头中声明数据的类型Content-Type，SpringMVC通过使用</p> 
  <p>HandlerAdapter 配置的HttpMessageConverters来解析HttpEntity中的数据，然后绑定到相应的bean上。</p> 
  <p> </p> 
  <p><strong>向表中批量插入数据</strong></p> 
  <p>举个批量插入数据的例子，Controller层的写法如下图所示：</p> 
  <p><img alt="" src="https://images2.imgbox.com/d3/9f/UYhwme0n_o.jpg"></p> 
  <p>由于@RequestBody可用来处理 <code>Content-Type</code> 为 <code>application/json</code> 编码的内容，所以在postman中，选择body的类型为<code>row</code> -&gt; <code>JSON(application/json)</code>，这样在 <code>Headers</code> 中也会自动变为 <code>Content-Type</code> : <code>application/json</code> 编码格式。body内的数据如下图所示：</p> 
  <p><img alt="" src="https://images2.imgbox.com/3a/43/HI8s8tqs_o.jpg"></p> 
  <p>批量向表中插入两条数据，这里的 <code>saveBatchNovel()</code>方法已经封装了 <code>JPA</code>的 <code>saveAll()</code> 方法。<code>body</code> 里面的 <code>json</code> 语句的 <code>key</code> 值要与后端实体类的属性一一对应。</p> 
  <p><strong>注意：</strong>前端使用$.ajax的话，一定要指定 <code>contentType: "application/json;charset=utf-8;"</code>，默认为 <code>application/x-www-form-urlencoded</code>。</p> 
  <p><strong>后端解析json数据</strong></p> 
  <p>上述示例是传递到实体类中的具体写法，那么如果传递到非实体类中，body里面的json数据需要怎么解析呢？我们再来看下面这个例子：</p> 
  <p>在body中，我们还是输入上面的json数据，根据分析，上面的json数据是一个List数组内嵌套着map对象，那么在后台的接收形式可写为 <code>List&lt;Map&lt;String, String&gt;&gt;</code>，具体代码如下图所示：</p> 
  <p><img alt="" src="https://images2.imgbox.com/8a/c5/qaye4G8Z_o.jpg"></p> 
  <p>postman请求：</p> 
  <p><img alt="" src="https://images2.imgbox.com/61/fe/sbILNFQ2_o.jpg"></p> 
  <p>控制台输出：</p> 
  <p><img alt="" src="https://images2.imgbox.com/68/6c/ft5Pm6x3_o.jpg"></p> 
  <p>得出结论，通过@RequestBody可以解析Body中json格式的数据。</p> 
  <h2> </h2> 
  <p> </p> 
  <h2><strong>POST请求时</strong></h2> 
  <p>@RequestBody --&gt; JSON字符串部分</p> 
  <p>@RequestParam --&gt; 请求参数部分</p> 
  <p>application/json格局图<br><img alt="" src="https://images2.imgbox.com/08/34/78dWF46V_o.jpg"></p> 
  <p>form-data、x-www-form-urlencoded格局图</p> 
  <p><img alt="" src="https://images2.imgbox.com/79/5d/wMTEOMJc_o.jpg"></p> 
  <p> </p> 
  <h3><strong>1、从content-type方面总结：</strong></h3> 
  <p>① form-data、x-www-form-urlencoded：不可以用@RequestBody；可以用@RequestParam。见postman的格局，这两种方式的时候没有json字符串部分。</p> 
  <p>② application/json：json字符串部分可以用@RequestBody；url中的?后面参数可以用@RequestParam。见postman的格局</p> 
  <p> </p> 
  <h3><strong>2、从两种注解方式总结：</strong></h3> 
  <p><strong>@RequestBody</strong></p> 
  <pre> </pre> 
  <ol><li> <p><code>(@RequestBody Map map)</code></p> </li><li> <p><code>(@RequestBody Object object)</code></p> </li><li> <p><code>application/json时候可用</code></p> </li><li> <p><code>form-data、x-www-form-urlencoded时候不可用</code></p> </li></ol> 
  <p><strong>@RequestParam</strong></p> 
  <pre> </pre> 
  <ol><li> <p><code>(@RequestParam Map map)</code></p> </li><li> <p><code>application/json时候，json字符串部分不可用，url中的?后面添加参数即可用，form-data、x-www-form-urlencoded时候可用，但是要将Headers里的Content-Type删掉</code></p> </li></ol> 
  <pre> </pre> 
  <ol><li> <p><code>(@RequestParam String waterEleId,@RequestParam String enterpriseName)</code></p> </li><li> <p><code>application/json时候，json字符串部分不可用，url中的?后面添加参数即可用</code></p> </li><li> <p><code>form-data、x-www-form-urlencoded时候可用，且参数可以没有顺序（即前端传过来的参数或者url中的参数顺序不必和后台接口中的参数顺序一致，只要字段名相同就可以），但是要将Headers里的Content-Type删掉</code></p> </li></ol> 
  <pre> </pre> 
  <ol><li> <p><code>(@RequestParam Object object)</code></p> </li><li> <p><code>不管application/json、form-data、x-www-form-urlencoded都不可用</code></p> </li></ol> 
  <p><strong>既不是@RequestBody也不是@RequestParam，没有指定参数哪种接收方式</strong></p> 
  <pre> </pre> 
  <ol><li> <p><code>(Map map)</code></p> </li><li> <p><code>(Object object)</code></p> </li><li> <p><code>application/json时候：json字符串部分不可用，url中的?后面添加参数不可用。</code></p> </li><li> <p><code>因为没有指定，它也不知道到底是用json字符串部分还是?后面添加参数部分，所以干脆都不可以用</code></p> </li><li> <p><code>form-data、x-www-form-urlencoded时都不可用，见图二</code></p> </li><li> </li><li> <p><code>(HttpServletRequest request)</code></p> </li><li> <p><code>application/json不可用</code></p> </li><li> <p><code>form-data、x-www-form-urlencoded时可用</code></p> </li></ol> 
  <h2><strong>GET请求</strong></h2> 
  <p><strong>@RequestBody</strong></p> 
  <pre> </pre> 
  <ol><li> <p><code>RequestBody -- Map / Object</code></p> </li><li> <p><code>GET请求中不可以使用@RequestBody</code></p> </li></ol> 
  <p><strong>@RequestParam</strong></p> 
  <pre> </pre> 
  <ol><li> <p><code>(@RequestParam Map map)</code></p> </li><li> <p><code>在url中的?后面添加参数即可使用</code></p> </li></ol> 
  <pre> </pre> 
  <ol><li> <p><code>(@RequestParam String waterEleId,@RequestParam String enterpriseName)</code></p> </li><li> <p><code>在url中的?后面添加参数即可使用</code></p> </li></ol> 
  <pre> </pre> 
  <ol><li> <p><code>(@RequestParam Object object)</code></p> </li><li> <p><code>GET请求中不可以使用</code></p> </li></ol> 
  <p>当使用GET请求时，通过postman添加?后面的参数，不用在url中自己一个一个拼，点击Params，在下面key-value中输入就自动拼接到url中</p> 
  <p> </p> 
  <p><img alt="" src="https://images2.imgbox.com/8e/87/i366FZyM_o.jpg"></p> 
  <p> </p> 
  <h3><strong>举栗子</strong></h3> 
  <p>上传文件，包含了图中圈出来的两部分</p> 
  <p><img alt="" src="https://images2.imgbox.com/f5/03/ftAUZdAw_o.jpg"></p> 
  <p>如果这样，没有@RequestParam，那么url?后的参数就拿不到</p> 
  <pre> </pre> 
  <ol><li> <p><code>@RequestMapping(value = "/leadingIn", method = RequestMethod.POST)</code></p> </li><li> <p><code>public ResponseObj&lt;Boolean&gt; leadingIn(Map formData,</code></p> </li><li> <p><code>HttpServletRequest request,</code></p> </li><li> <p><code>Map&lt;String, InputStream&gt; files) { 
      </code></p> </li><li> <p><code>}</code></p> </li></ol> 
  <p>如果control中这样接收，本来想formData只接收url?后的参数，结果将{ "retCode": null, "data": true }这部分内容也拿到了，真实意外之喜。字符串这部分内容还可以从request中取到，见下面完整方法。</p> 
  <pre> </pre> 
  <ol><li> <p><code>@RequestMapping(value = "/leadingIn", method = RequestMethod.POST)</code></p> </li><li> <p><code>public ResponseObj&lt;Boolean&gt; leadingIn(@RequestParam Map formData,</code></p> </li><li> <p><code>HttpServletRequest request,</code></p> </li><li> <p><code>Map&lt;String, InputStream&gt; files) { 
      </code></p> </li><li> <p><code>}</code></p> </li></ol> 
  <p>完整方法</p> 
  <pre> </pre> 
  <ol><li> <p><code>/**</code></p> </li><li> <p><code>* 导入</code></p> </li><li> <p><code>*/</code></p> </li><li> <p><code>@RequestMapping(value = "/leadingIn", method = RequestMethod.POST)</code></p> </li><li> <p><code>public ResponseObj&lt;Boolean&gt; leadingIn(@RequestParam Map formData,</code></p> </li><li> <p><code>HttpServletRequest request,</code></p> </li><li> <p><code>Map&lt;String, InputStream&gt; files) { 
      </code></p> </li><li> <p><code>//测试</code></p> </li><li> <p><code>try { 
      </code></p> </li><li> <p><code>MultipartHttpServletRequest mulRequest = (MultipartHttpServletRequest) request;</code></p> </li><li> <p><code>Set&lt;Map.Entry&lt;String, MultipartFile&gt;&gt; set = mulRequest.getFileMap().entrySet();</code></p> </li><li> <p><code>Map&lt;String, InputStream&gt; listFile = new LinkedHashMap&lt;&gt;();</code></p> </li><li> <p><code>System.out.println("个数" + set.size());</code></p> </li><li> <p><code>for (Map.Entry&lt;String, MultipartFile&gt; each : set) { 
      </code></p> </li><li> <p><code>String fileName = each.getKey();</code></p> </li><li> <p><code>MultipartFile file = each.getValue();</code></p> </li><li> <p><code>//这里需要上传FTP</code></p> </li><li> <p><code>try { 
      </code></p> </li><li> <p><code>listFile.put(fileName, file.getInputStream());</code></p> </li><li> <p><code>} catch (Exception ex) { 
      </code></p> </li><li> <p><code>return new ResponseObj&lt;&gt;(false, null);</code></p> </li><li> <p><code>}</code></p> </li><li> <p><code>}</code></p> </li><li> </li><li> <p><code>String formjson = mulRequest.getParameter("content");</code></p> </li><li> <p><code>ObjectMapper mapper = new ObjectMapper();</code></p> </li><li> <p><code>mapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);</code></p> </li><li> <p><code>mapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);</code></p> </li><li> </li><li> <p><code>// boolean result = iInstallWorkOrder.upLoadFile(listFile);</code></p> </li><li> <p><code>boolean result = true;</code></p> </li><li> </li><li> <p><code>return new ResponseObj&lt;&gt;(result, null);</code></p> </li><li> <p><code>} catch (Exception ex) { 
      </code></p> </li><li> <p><code>System.out.println(ex.toString());</code></p> </li><li> <p><code>return new ResponseObj&lt;&gt;(false, null);</code></p> </li><li> <p><code>}</code></p> </li><li> </li><li> <p><code>}</code></p> </li></ol> 
  <p><br><br> 按F12看一下Network里对应请求：<br><br> 使用@RequestParam：Content-Type为application/x-www-form-urlencoded，参数在FormData中<br><img alt="" src="https://images2.imgbox.com/6c/3f/a2EXnuT0_o.png"><br><br><br> 使用@RequestBody：Content-Type为application/json，参数在Request PayLoad中<br><img alt="" src="https://images2.imgbox.com/54/82/92cwtOFR_o.png"><br><br> 总结 •在GET请求中，不能使用@RequestBody。 •在POST请求，可以使用@RequestBody和@RequestParam，但是如果使用@RequestBody，对于参数转化的配置必须统一。<br> 可以使用多个@RequestParam获取数据，@RequestBody不可以 举个例子，在SpringMVC配置了HttpMessageConverters处理栈中，指定json转化的格式，如Date转成‘yyyy-MM-dd’,则参数接收对象包含的字段如果是Date类型，就只能让客户端传递年月日的格式，不能传时分秒。因为不同的接口，它的参数可能对时间参数有不同的格式要求，所以这样做会让客户端调用同事对参数的格式有点困惑，所以说扩展性不高。 如果使用@RequestParam来接受参数，可以在接受参数的model中设置@DateFormat指定所需要接受时间参数的格式。 另外，使用@RequestBody接受的参数是不会被Servlet转化统一放在request对象的Param参数集中，@RequestParam是可以的。</p> 
  <p> </p> 
  <p>另外，还有一种应用场景，接口规范为resultful风格时，举个例子：如果要获取某个id下此条问题答案的查询次数的话，则后台就需要动态获取参数，其注解为@PathVariable，并且requestMapping中的value应为value="/{id}/queryNum"，截图如下：</p> 
  <p><img alt="" src="https://images2.imgbox.com/08/be/uvkAudOD_o.png"></p> 
  <p> </p> 
 </div> 
 <div> 
  <div></div> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/facf4610594d7904a8dc051f82f6ecd6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【游戏开发环境】Unity使用Mac电脑开发，开发环境的搭建（Mac mini M1 | VSCode | Git | 好用工具）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d78b536b1b9ee9d5cf2a4cb657549532/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【SOLIDWORKS-详细记录】解决默认模板无效问题及添加自定义模板</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>