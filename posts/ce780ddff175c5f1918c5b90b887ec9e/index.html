<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue3&#43;ts实现视频根据时间轴截取，并可以通过传入截取起止时间进行当前剪辑的回显 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue3&#43;ts实现视频根据时间轴截取，并可以通过传入截取起止时间进行当前剪辑的回显" />
<meta property="og:description" content="公司提出想做一个视频编辑功能，每次只裁剪一段即可，UI同时也想实现时间轴为关键帧图片的效果，从网上也没找到合适的组件，简单思考后觉得并不难，决定自己封装一个吧。组件涉及到的只有vue3&#43;ts&#43;scss，没有使用其他插件。
穿插一个简化版本，时间轴是一条线，功能比这个简化，或许会符合部分人的需求。 链接vue3&#43;ts实现视频根据时间轴截取_vue项目截取一段正在播放的视频_一个人的咖啡~的博客-CSDN博客
功能概述 通过传入源视频时长，源视频的视频地址，当前剪辑的开始时间，当前剪辑的结束时间和关键帧缩略图（需要20张图片，后端提供，根据视频时长分为20节，每节取一张图）五个必传参数，视频地址将通过video标签播放，组件尺寸为100%，根据父级组件的宽度自动撑满。
时间轴模块，会根据传入的起止时间自动换算出1px===毫秒数，起止时间间隔我设置了1秒以上，开始时间拖动到结束时间前一秒左右将停止移动，结束时间拖动到开始时间后一秒左右将无法拖动，拖动开始时间时会自动将video标签的开始播放时间定位到截取的开始时间，设置结束时间后，video播放到截取的结束时间后会自动暂停，这时video标签将只能播放所截取的起止时间范围的视频。最后设置了回调queryTime()，通过回调将起止时间传出，我的业务中视频截取是后端操作，前端只需要提供截取的起止时间即可，具体看代码，如下：
参数描述 endTime视频结束时间，精确到毫秒url视频地址，将通过video标签展示spliterStartTime视频截取开始时间spliterEndTime视频截取结束时间photoList时间轴缩略图列表 回调描述 回调方法回调参数（形参）参数描述queryTimeArray[开始时间，结束时间] template部分 &lt;template&gt; &lt;video id=&#34;videoPlayer&#34; @play=&#34;onplay&#34; controls=&#34;true&#34; preload=&#34;auto&#34; muted class=&#34;video&#34; width=&#34;100%&#34; :src=&#34;props.url&#34;&gt;&lt;/video&gt; &lt;ul class=&#34;time-list&#34;&gt; &lt;li v-for=&#34;item in data.timeList&#34; :key=&#34;item&#34;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;div class=&#34;crop-filter&#34;&gt; &lt;div class=&#34;timer-shaft&#34; ref=&#34;shaft&#34;&gt; &lt;div class=&#34;white-shade&#34; :style=&#34;{width:(data.endLeft-data.startLeft&#43;12)&#43;&#39;px&#39;,left:data.startLeft-6&#43;&#39;px&#39;}&#34;&gt; &lt;/div&gt; &lt;div class=&#34;left-shade&#34; :style=&#34;{width: (data.startLeft-6)&#43;&#39;px&#39;}&#34;&gt;&lt;/div&gt; &lt;div class=&#34;right-shade&#34; :style=&#34;{width: (shaft?.clientWidth-data.endLeft-6) &#43;&#39;px&#39;}&#34;&gt;&lt;/div&gt; &lt;div class=&#34;strat-circle circle&#34; ref=&#34;start&#34; @mousedown=&#34;startMouseDown&#34;&gt; &lt;div class=&#34;center&#34;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&#34;end-circle circle&#34; ref=&#34;end&#34; @mousedown=&#34;endMouseDown&#34;&gt; &lt;div class=&#34;center&#34;&gt;&lt;/div&gt; &lt;/div&gt; &lt;!-- 此处src应绑定item --&gt; &lt;img @dragstart.prevent style=&#34;width: 5%;user-select: none;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ce780ddff175c5f1918c5b90b887ec9e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-20T11:25:13+08:00" />
<meta property="article:modified_time" content="2023-11-20T11:25:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue3&#43;ts实现视频根据时间轴截取，并可以通过传入截取起止时间进行当前剪辑的回显</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> 公司提出想做一个视频编辑功能，每次只裁剪一段即可，UI同时也想实现时间轴为关键帧图片的效果，从网上也没找到合适的组件，简单思考后觉得并不难，决定自己封装一个吧。组件涉及到的只有vue3+ts+scss，没有使用其他插件。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f6/a5/lGy9TaOQ_o.jpg"></p> 
<h4>穿插一个简化版本，时间轴是一条线，功能比这个简化，或许会符合部分人的需求。</h4> 
<p>链接<a href="https://blog.csdn.net/wed2019/article/details/126988597" title="vue3+ts实现视频根据时间轴截取_vue项目截取一段正在播放的视频_一个人的咖啡~的博客-CSDN博客">vue3+ts实现视频根据时间轴截取_vue项目截取一段正在播放的视频_一个人的咖啡~的博客-CSDN博客</a></p> 
<p></p> 
<h3>功能概述</h3> 
<p>通过传入源视频时长，源视频的视频地址，当前剪辑的开始时间，当前剪辑的结束时间和关键帧缩略图（需要20张图片，后端提供，根据视频时长分为20节，每节取一张图）五个必传参数，视频地址将通过video标签播放，组件尺寸为100%，根据父级组件的宽度自动撑满。</p> 
<p>时间轴模块，会根据传入的起止时间自动换算出1px===毫秒数，起止时间间隔我设置了1秒以上，开始时间拖动到结束时间前一秒左右将停止移动，结束时间拖动到开始时间后一秒左右将无法拖动，拖动开始时间时会自动将video标签的开始播放时间定位到截取的开始时间，设置结束时间后，video播放到截取的结束时间后会自动暂停，这时video标签将只能播放所截取的起止时间范围的视频。最后设置了回调queryTime()，通过回调将起止时间传出，我的业务中视频截取是后端操作，前端只需要提供截取的起止时间即可，具体看代码，如下：</p> 
<table align="left" border="1" cellpadding="1" cellspacing="1"><caption>
   参数描述 
 </caption><tbody><tr><td>endTime</td><td>视频结束时间，精确到毫秒</td></tr><tr><td>url</td><td>视频地址，将通过video标签展示</td></tr><tr><td>spliterStartTime</td><td>视频截取开始时间</td></tr><tr><td>spliterEndTime</td><td>视频截取结束时间</td></tr><tr><td>photoList</td><td>时间轴缩略图列表</td></tr></tbody></table> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<table border="1" cellpadding="1" cellspacing="1"><caption>
   回调描述 
 </caption><tbody><tr><td>回调方法</td><td>回调参数（形参）</td><td>参数描述</td></tr><tr><td>queryTime</td><td>Array</td><td>[开始时间，结束时间]</td></tr></tbody></table> 
<p></p> 
<h4><strong>template</strong>部分</h4> 
<pre><code class="language-html">&lt;template&gt;
	&lt;video id="videoPlayer" @play="onplay" controls="true" preload="auto" muted class="video" width="100%"
		:src="props.url"&gt;&lt;/video&gt;
	&lt;ul class="time-list"&gt;
		&lt;li v-for="item in data.timeList" :key="item"&gt;{<!-- -->{item}}&lt;/li&gt;
	&lt;/ul&gt;
	&lt;div class="crop-filter"&gt;
		&lt;div class="timer-shaft" ref="shaft"&gt;
			&lt;div class="white-shade" :style="{width:(data.endLeft-data.startLeft+12)+'px',left:data.startLeft-6+'px'}"&gt;
			&lt;/div&gt;
			&lt;div class="left-shade" :style="{width: (data.startLeft-6)+'px'}"&gt;&lt;/div&gt;
			&lt;div class="right-shade" :style="{width: (shaft?.clientWidth-data.endLeft-6) +'px'}"&gt;&lt;/div&gt;
			&lt;div class="strat-circle circle" ref="start" @mousedown="startMouseDown"&gt;
				&lt;div class="center"&gt;&lt;/div&gt;
			&lt;/div&gt;
			&lt;div class="end-circle circle" ref="end" @mousedown="endMouseDown"&gt;
				&lt;div class="center"&gt;&lt;/div&gt;
			&lt;/div&gt;
			&lt;!-- 此处src应绑定item --&gt;
			&lt;img @dragstart.prevent style="width: 5%;user-select: none;" v-for="item in props.photoList"
				src="../../../public/favicon.ico" alt=""&gt;
		&lt;/div&gt;
	&lt;/div&gt;
&lt;/template&gt;</code></pre> 
<p>分为三个部分，上面是video标签，中间是根据总时长处理出的时间数组，下面是时间轴。</p> 
<h4>script部分</h4> 
<pre><code class="language-javascript">&lt;!-- 起止时间间隔最小≈1秒 --&gt;
&lt;script setup lang="ts"&gt;
	import {
		getNowTime,
		dateStrChangeTimeTamp,
		cropFilter,
		videoRef,
	} from '@/types/type'
	// 进度条dom
	const shaft = ref(null);
	// 开始按钮dom
	const start = ref(null);
	// 结束按钮dom
	const end = ref(null);
	const data = reactive(new cropFilter)
	// props参数类型
	interface Props {
		startTime ? : string;
		endTime: string;
		url: string;
		spliterStartTime ? : string;
		spliterEndTime: string;
		// 此处为模拟
		photoList: string[];
	}
	// 设置默认值,需要显式的开启,具体查看vue3文档
	const props = withDefaults(defineProps &lt; Props &gt; (), {
		startTime: '00:00:00.0',
		endTime: '00:00:08.0',
		spliterStartTime: '00:00:00.0',
		spliterEndTime: '00:00:08.0',
		url: '',
		photoList: [],
	})
	const emit = defineEmits(['queryTime'])
	onMounted(() =&gt; {
		// 随便拼一个1970年以后的年月日字符串+' '
		let str = '1970-01-02 '
		let time = dateStrChangeTimeTamp(str + props.endTime) - dateStrChangeTimeTamp(str + props.startTime)
		data.roal = time / shaft.value.clientWidth
		// 结束毫秒数
		let endM = (dateStrChangeTimeTamp('1970-01-02 ' + props?.spliterEndTime) - (1000 * 60 * 60 * 16))
		// 开始毫秒数
		let startM = (dateStrChangeTimeTamp('1970-01-02 ' + (props?.spliterStartTime)) - (1000 * 60 * 60 * 16))
		console.log(startM, endM)
		// 设置开始结束位置
		start.value.style.left = startM / data.roal - (end.value.clientWidth / 2) + 'px'
		end.value.style.left = endM / data.roal - (end.value.clientWidth / 2) + 'px'

		data.endLeft = end.value.offsetLeft
		data.endright = shaft.value.clientWidth - (end.value.clientWidth / 2)
		data.startLeft = start.value.offsetLeft + (start.value.clientWidth / 2)
		getVideoTime()
		data.timeList.push(props.startTime)
		let paragraph = (dateStrChangeTimeTamp(str + props.endTime) - (1000 * 60 * 60 * 16)) / 5
		for (let i = 1; i &lt; 6; i++) {
			data.timeList.push(getNowTime(paragraph * i))
		}
	})
	// 播放事件
	const onplay = () =&gt; {
		let myVideo: videoRef = document.getElementById('videoPlayer');
		// 开始秒数
		let startM = (dateStrChangeTimeTamp('1970-01-02 ' + (data.startTime ? data.startTime : props
			.spliterStartTime)) - (1000 * 60 * 60 * 16)) / 1000
		// 结束秒数
		let endM = (dateStrChangeTimeTamp('1970-01-02 ' + (data.endTime ? data.endTime : props
			.spliterEndTime)) - (1000 * 60 * 60 * 16)) / 1000
		// 如果当前秒数小于等于截取的开始时间,就按截取的开始时间播放,如果不是,则为继续播放
		if (myVideo.currentTime &lt;= startM || myVideo.currentTime &gt; endM) {
			myVideo.currentTime = startM;
			myVideo.play();
		}
	}
	// 获取视频播放时长
	const getVideoTime = () =&gt; {
		if (document.getElementById('videoPlayer')) {
			let videoPlayer: videoRef = document.getElementById('videoPlayer');
			videoPlayer.addEventListener('timeupdate', function() {
				// 结束秒数
				let endM = (dateStrChangeTimeTamp('1970-01-02 ' + (data.endTime ? data.endTime : props
					.spliterEndTime)) - (1000 * 60 * 60 * 16)) / 1000
				// 如果当前播放时间大于等于截取的结束秒数,就暂停
				if (videoPlayer.currentTime &gt;= endM) {
					videoPlayer.pause()
				}
			}, false)
		}
	}
	//设置播放点
	const playBySeconds = (num: number) =&gt; {
		if (num &amp;&amp; document.getElementById('videoPlayer')) {
			let myVideo: videoRef = document.getElementById('videoPlayer');
			myVideo.currentTime = num;
		}
	}
	// 起始按钮
	const startMouseDown = (e) =&gt; {
		let odiv = e.currentTarget; //获取目标父元素
		//算出鼠标相对元素的位置
		let disX = e.clientX - odiv.offsetLeft;
		document.onmousemove = (e) =&gt; { //鼠标按下并移动的事件
			//用鼠标的位置减去鼠标相对元素的位置，得到元素的位置
			let left = e.clientX - disX;

			//移动当前元素
			odiv.style.left = left + 'px';
			//获取距离窗口宽度
			let mas = odiv.offsetLeft;
			if (mas &lt;= -(start.value.clientWidth / 2)) {
				odiv.style.left = -(start.value.clientWidth / 2) + 'px';
			} else if (mas &gt;= (data.endLeft - Math.ceil(1000 / data.roal))) {
				odiv.style.left = (data.endLeft - Math.ceil(1000 / data.roal)) + 'px';
			}
			data.startTime = getNowTime(data.roal *  Math.floor(start.value.offsetLeft + (start.value.clientWidth /
				2)))
			data.startLeft = start.value.clientWidth + start.value.offsetLeft
			// 开始秒数
			let startM = (dateStrChangeTimeTamp('1970-01-02 ' + (data.startTime ? data.startTime : props
				.spliterStartTime)) - (1000 * 60 * 60 * 16)) / 1000
			playBySeconds(startM)
		};
		document.onmouseup = (e) =&gt; {
			document.onmousemove = null;
			document.onmouseup = null;
			handleTime()
		};
	}
	// 结束按钮
	const endMouseDown = (e) =&gt; {
		let odiv = e.currentTarget; //获取目标父元素
		//算出鼠标相对元素的位置
		let disX = e.clientX - odiv.offsetLeft;
		document.onmousemove = (e) =&gt; { //鼠标按下并移动的事件
			//用鼠标的位置减去鼠标相对元素的位置，得到元素的位置
			let left = e.clientX - disX;

			//移动当前元素
			odiv.style.left = left + 'px';
			//获取距离窗口宽度
			let mas = odiv.offsetLeft;
			if (mas &lt;= (data.startLeft - end.value.clientWidth + Math.ceil(1000 / data.roal))) {
				odiv.style.left = (data.startLeft - end.value.clientWidth + Math.ceil(1000 / data.roal)) +
					'px';
			} else if (mas &gt;= data.endright) {
				odiv.style.left = data.endright + 'px';
			}
			data.endTime = getNowTime(data.roal *  Math.floor(end.value.offsetLeft + (end.value.clientWidth / 2)))
			data.endLeft = end.value.offsetLeft
		};
		document.onmouseup = (e) =&gt; {
			document.onmousemove = null;
			document.onmouseup = null;
			handleTime()
		};
	}
	// 传出起止时间的回调
	const handleTime = () =&gt; {
		let arr = [data.startTime, data.endTime]
		emit('queryTime', arr)
	}
&lt;/script&gt;</code></pre> 
<h4></h4> 
<h4>css部分</h4> 
<pre><code class="language-html">&lt;style scoped lang="scss"&gt;
	.video {
		width: 100%;
		margin-bottom: 0.2rem;
	}

	.time-list {
		width: 100%;
		color: #C0C0C0;
		font-size: 0.12rem;
		margin-bottom: 0.1rem;
		display: flex;
		align-items: center;
		justify-content: space-between;
	}

	.crop-filter {
		width: 100%;
		padding: 0 0.1rem;
		box-sizing: border-box;
		display: flex;
		align-items: center;

		.timer-shaft {
			width: 100%;
			position: relative;

			.circle {
				width: 0.2rem;
				position: absolute;
				top: -8%;
				height: 110%;
				background-color: #ffffff;
				cursor: e-resize;
				display: flex;
				align-items: center;
				justify-content: center;

				.center {
					width: 0.02rem;
					height: 0.15rem;
					background-color: #D8D8D8;
				}
			}

			.strat-circle {
				left: -0.09rem;
				border-radius: 0.03rem 0 0 0.03rem;
			}

			.end-circle {
				right: -0.1rem;
				border-radius: 0 0.03rem 0.03rem 0;
			}

			.white-shade {
				position: absolute;
				top: -8%;
				height: 110%;
				width: 100%;
				background-color: transparent;
				border: 0.04rem solid #fff;
				box-sizing: border-box;
				border-left: 0;
				border-right: 0;
			}

			.left-shade {
				position: absolute;
				left: 0;
				top: 0;
				height: 100%;
				background: rgba(0, 0, 0, 0.6);
			}

			.right-shade {
				position: absolute;
				right: 0;
				top: 0;
				height: 100%;
				background: rgba(0, 0, 0, 0.6);
			}
		}
	}
&lt;/style&gt;</code></pre> 
<h4>.vue完整代码</h4> 
<pre><code class="language-html">&lt;template&gt;
	&lt;video id="videoPlayer" @play="onplay" controls="true" preload="auto" muted class="video" width="100%"
		:src="props.url"&gt;&lt;/video&gt;
	&lt;ul class="time-list"&gt;
		&lt;li v-for="item in data.timeList" :key="item"&gt;{<!-- -->{item}}&lt;/li&gt;
	&lt;/ul&gt;
	&lt;div class="crop-filter"&gt;
		&lt;div class="timer-shaft" ref="shaft"&gt;
			&lt;div class="white-shade" :style="{width:(data.endLeft-data.startLeft+12)+'px',left:data.startLeft-6+'px'}"&gt;
			&lt;/div&gt;
			&lt;div class="left-shade" :style="{width: (data.startLeft-6)+'px'}"&gt;&lt;/div&gt;
			&lt;div class="right-shade" :style="{width: (shaft?.clientWidth-data.endLeft-6) +'px'}"&gt;&lt;/div&gt;
			&lt;div class="strat-circle circle" ref="start" @mousedown="startMouseDown"&gt;
				&lt;div class="center"&gt;&lt;/div&gt;
			&lt;/div&gt;
			&lt;div class="end-circle circle" ref="end" @mousedown="endMouseDown"&gt;
				&lt;div class="center"&gt;&lt;/div&gt;
			&lt;/div&gt;
			&lt;!-- 此处src应绑定item --&gt;
			&lt;img @dragstart.prevent style="width: 5%;user-select: none;" v-for="item in props.photoList"
				src="../../../public/favicon.ico" alt=""&gt;
		&lt;/div&gt;
	&lt;/div&gt;
&lt;/template&gt;
&lt;!-- 起止时间间隔最小≈1秒 --&gt;
&lt;script setup lang="ts"&gt;
	import {
		getNowTime,
		dateStrChangeTimeTamp,
		cropFilter,
		videoRef,
	} from '@/types/type'
	// 进度条dom
	const shaft = ref(null);
	// 开始按钮dom
	const start = ref(null);
	// 结束按钮dom
	const end = ref(null);
	const data = reactive(new cropFilter)
	// props参数类型
	interface Props {
		startTime ? : string;
		endTime: string;
		url: string;
		spliterStartTime ? : string;
		spliterEndTime: string;
		// 此处为模拟
		photoList: string[];
	}
	// 设置默认值,需要显式的开启,具体查看vue3文档
	const props = withDefaults(defineProps &lt; Props &gt; (), {
		startTime: '00:00:00.0',
		endTime: '00:00:08.0',
		spliterStartTime: '00:00:00.0',
		spliterEndTime: '00:00:08.0',
		url: '',
		photoList: [],
	})
	const emit = defineEmits(['queryTime'])
	onMounted(() =&gt; {
		// 随便拼一个1970年以后的年月日字符串+' '
		let str = '1970-01-02 '
		let time = dateStrChangeTimeTamp(str + props.endTime) - dateStrChangeTimeTamp(str + props.startTime)
		data.roal = time / shaft.value.clientWidth
		// 结束毫秒数
		let endM = (dateStrChangeTimeTamp('1970-01-02 ' + props?.spliterEndTime) - (1000 * 60 * 60 * 16))
		// 开始毫秒数
		let startM = (dateStrChangeTimeTamp('1970-01-02 ' + (props?.spliterStartTime)) - (1000 * 60 * 60 * 16))
		console.log(startM, endM)
		// 设置开始结束位置
		start.value.style.left = startM / data.roal - (end.value.clientWidth / 2) + 'px'
		end.value.style.left = endM / data.roal - (end.value.clientWidth / 2) + 'px'

		data.endLeft = end.value.offsetLeft
		data.endright = shaft.value.clientWidth - (end.value.clientWidth / 2)
		data.startLeft = start.value.offsetLeft + (start.value.clientWidth / 2)
		getVideoTime()
		data.timeList.push(props.startTime)
		let paragraph = (dateStrChangeTimeTamp(str + props.endTime) - (1000 * 60 * 60 * 16)) / 5
		for (let i = 1; i &lt; 6; i++) {
			data.timeList.push(getNowTime(paragraph * i))
		}
	})
	// 播放事件
	const onplay = () =&gt; {
		let myVideo: videoRef = document.getElementById('videoPlayer');
		// 开始秒数
		let startM = (dateStrChangeTimeTamp('1970-01-02 ' + (data.startTime ? data.startTime : props
			.spliterStartTime)) - (1000 * 60 * 60 * 16)) / 1000
		// 结束秒数
		let endM = (dateStrChangeTimeTamp('1970-01-02 ' + (data.endTime ? data.endTime : props
			.spliterEndTime)) - (1000 * 60 * 60 * 16)) / 1000
		// 如果当前秒数小于等于截取的开始时间,就按截取的开始时间播放,如果不是,则为继续播放
		if (myVideo.currentTime &lt;= startM || myVideo.currentTime &gt; endM) {
			myVideo.currentTime = startM;
			myVideo.play();
		}
	}
	// 获取视频播放时长
	const getVideoTime = () =&gt; {
		if (document.getElementById('videoPlayer')) {
			let videoPlayer: videoRef = document.getElementById('videoPlayer');
			videoPlayer.addEventListener('timeupdate', function() {
				// 结束秒数
				let endM = (dateStrChangeTimeTamp('1970-01-02 ' + (data.endTime ? data.endTime : props
					.spliterEndTime)) - (1000 * 60 * 60 * 16)) / 1000
				// 如果当前播放时间大于等于截取的结束秒数,就暂停
				if (videoPlayer.currentTime &gt;= endM) {
					videoPlayer.pause()
				}
			}, false)
		}
	}
	//设置播放点
	const playBySeconds = (num: number) =&gt; {
		if (num &amp;&amp; document.getElementById('videoPlayer')) {
			let myVideo: videoRef = document.getElementById('videoPlayer');
			myVideo.currentTime = num;
		}
	}
	// 起始按钮
	const startMouseDown = (e) =&gt; {
		let odiv = e.currentTarget; //获取目标父元素
		//算出鼠标相对元素的位置
		let disX = e.clientX - odiv.offsetLeft;
		document.onmousemove = (e) =&gt; { //鼠标按下并移动的事件
			//用鼠标的位置减去鼠标相对元素的位置，得到元素的位置
			let left = e.clientX - disX;

			//移动当前元素
			odiv.style.left = left + 'px';
			//获取距离窗口宽度
			let mas = odiv.offsetLeft;
			if (mas &lt;= -(start.value.clientWidth / 2)) {
				odiv.style.left = -(start.value.clientWidth / 2) + 'px';
			} else if (mas &gt;= (data.endLeft - Math.ceil(1000 / data.roal))) {
				odiv.style.left = (data.endLeft - Math.ceil(1000 / data.roal)) + 'px';
			}
			data.startTime = getNowTime(data.roal *  Math.floor(start.value.offsetLeft + (start.value.clientWidth /
				2)))
			data.startLeft = start.value.clientWidth + start.value.offsetLeft
			// 开始秒数
			let startM = (dateStrChangeTimeTamp('1970-01-02 ' + (data.startTime ? data.startTime : props
				.spliterStartTime)) - (1000 * 60 * 60 * 16)) / 1000
			playBySeconds(startM)
		};
		document.onmouseup = (e) =&gt; {
			document.onmousemove = null;
			document.onmouseup = null;
			handleTime()
		};
	}
	// 结束按钮
	const endMouseDown = (e) =&gt; {
		let odiv = e.currentTarget; //获取目标父元素
		//算出鼠标相对元素的位置
		let disX = e.clientX - odiv.offsetLeft;
		document.onmousemove = (e) =&gt; { //鼠标按下并移动的事件
			//用鼠标的位置减去鼠标相对元素的位置，得到元素的位置
			let left = e.clientX - disX;

			//移动当前元素
			odiv.style.left = left + 'px';
			//获取距离窗口宽度
			let mas = odiv.offsetLeft;
			if (mas &lt;= (data.startLeft - end.value.clientWidth + Math.ceil(1000 / data.roal))) {
				odiv.style.left = (data.startLeft - end.value.clientWidth + Math.ceil(1000 / data.roal)) +
					'px';
			} else if (mas &gt;= data.endright) {
				odiv.style.left = data.endright + 'px';
			}
			data.endTime = getNowTime(data.roal *  Math.floor(end.value.offsetLeft + (end.value.clientWidth / 2)))
			data.endLeft = end.value.offsetLeft
		};
		document.onmouseup = (e) =&gt; {
			document.onmousemove = null;
			document.onmouseup = null;
			handleTime()
		};
	}
	// 传出起止时间的回调
	const handleTime = () =&gt; {
		let arr = [data.startTime, data.endTime]
		emit('queryTime', arr)
	}
&lt;/script&gt;

&lt;style scoped lang="scss"&gt;
	.video {
		width: 100%;
		margin-bottom: 0.2rem;
	}

	.time-list {
		width: 100%;
		color: #C0C0C0;
		font-size: 0.12rem;
		margin-bottom: 0.1rem;
		display: flex;
		align-items: center;
		justify-content: space-between;
	}

	.crop-filter {
		width: 100%;
		padding: 0 0.1rem;
		box-sizing: border-box;
		display: flex;
		align-items: center;

		.timer-shaft {
			width: 100%;
			position: relative;

			.circle {
				width: 0.2rem;
				position: absolute;
				top: -8%;
				height: 110%;
				background-color: #ffffff;
				cursor: e-resize;
				display: flex;
				align-items: center;
				justify-content: center;

				.center {
					width: 0.02rem;
					height: 0.15rem;
					background-color: #D8D8D8;
				}
			}

			.strat-circle {
				left: -0.09rem;
				border-radius: 0.03rem 0 0 0.03rem;
			}

			.end-circle {
				right: -0.1rem;
				border-radius: 0 0.03rem 0.03rem 0;
			}

			.white-shade {
				position: absolute;
				top: -8%;
				height: 110%;
				width: 100%;
				background-color: transparent;
				border: 0.04rem solid #fff;
				box-sizing: border-box;
				border-left: 0;
				border-right: 0;
			}

			.left-shade {
				position: absolute;
				left: 0;
				top: 0;
				height: 100%;
				background: rgba(0, 0, 0, 0.6);
			}

			.right-shade {
				position: absolute;
				right: 0;
				top: 0;
				height: 100%;
				background: rgba(0, 0, 0, 0.6);
			}
		}
	}
&lt;/style&gt;
</code></pre> 
<h4>type.ts代码</h4> 
<pre><code class="language-javascript">export interface videoRef {
	// 其他冗余字段
	[propName: string]: any;
	// 数字值，表示当前播放的时间，以秒计
	currentTime: number;
}
export class cropFilter {
	// 结束按钮距离左侧距离
	endLeft: string | number = 0;
	// 结束按钮初始位置
	endright: string | number = 0;
	// 开始按钮距离左侧距离
	startLeft: string | number = 0;
	// 毫秒/px(1px===的毫秒数)
	roal: string | number = 0;
	// 开始时间
	startTime: string | number = 0;
	// 结束时间
	endTime: string | number = 0;
	// 时间轴显示时间数组
	timeList: string[] = [];
}

//日期字符串转成时间戳
export function dateStrChangeTimeTamp(dateStr: string) {
	dateStr = dateStr.substring(0, 23);
	dateStr = dateStr.replace(/-/g, '/');
	let timeTamp = new Date(dateStr).getTime();
	return timeTamp
}
// 精准到毫秒
export function getNowTime(val: string | number) {
	const date = new Date(val)
	const hour = (date.getHours() - 8) &lt; 10 ? '0' + (date.getHours() - 8) : date.getHours() - 8
	const minute = date.getMinutes() &lt; 10 ? '0' + date.getMinutes() : date.getMinutes()
	const second = date.getSeconds() &lt; 10 ? '0' + date.getSeconds() : date.getSeconds()
	const milliSeconds = date.getMilliseconds() //毫秒
	const currentTime = hour + ':' + minute + ':' + second + '.' + milliSeconds
	console.log(currentTime)
	return currentTime
}
</code></pre> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/156d644889dec350d1edce4725a36bd0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">为什么FPGA的薪资可以那么高？FPGA怎么学习？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1f19ee411b9d5f5a9ae8b9d800c5f545/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Ant Design合集】自用总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>