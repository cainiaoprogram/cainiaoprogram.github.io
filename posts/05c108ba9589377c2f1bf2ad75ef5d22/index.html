<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>再学DataX - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="再学DataX" />
<meta property="og:description" content="一、DataX简介 DataX官网文档：https://github.com/alibaba/DataX/blob/master/introduction.md
DataX 是一个异构数据源离线同步工具，致力于实现包括关系型数据库(MySQL、Oracle等)、HDFS、Hive、ODPS、HBase、FTP等各种异构数据源之间稳定高效的数据同步功能。
1.1、DataX 3.0框架设计 DataX本身作为离线数据同步框架，采用Framework &#43; plugin架构构建。将数据源读取和写入抽象成为Reader/Writer插件，纳入到整个同步框架中。
Reader：Reader为数据采集模块，负责采集数据源的数据，将数据发送给Framework。
Writer： Writer为数据写入模块，负责不断向Framework取数据，并将数据写入到目的端。
Framework：Framework用于连接reader和writer，作为两者的数据传输通道，并处理缓冲，流控，并发，数据转换等核心技术问题。
1.2、DataX3.0核心架构 DataX 3.0 开源版本支持单机多线程模式完成同步作业运行
1、Job
DataX完成单个数据同步的作业。一个Job对应一个进程。Job模块负责task切分，TaskGroup管理等。
2、Task
Task是DataX的最小单元，每个task负责一部分数据同步工作。
3、TaskGroup
Job在切分完多个Task后，会调用DataX的scheduler模块，根据配置的并发量，将拆分成的多个Task分配到不同的TaskGroup中，每个TaskGroup负责以一定并发运行分配给他的全部Task，每个TaskGroup默认的并发量是5.
4、Task的执行流程
每个Task由TaskGroup启动，每个Task对固定启动Reader—&gt;Channel—&gt;Writer的线程来完成数据同步工作。
DataX Job运行起来后，由Job监控并等待每个TaskGroup的task执行完成，等所有TaskGroup任务执行完成后，Job成功退出。否则，异常退出。
5、DataX调度流程
举例来说，用户提交了一个DataX作业，并且配置了20个并发，目的是将一个100张分表的mysql数据同步到odps里面。
DataX的调度决策思路是：
1）DataX Job根据分库分表切分成了100个Task。
2）由于配置了20个并发，每个TaskGroup默认并发度是5，所以需要4个TaskGroup
3）由4个TaskGroup平均切分100个Task，每个TaskGroup被分到了25个Task，共启动5个并发。
1.3、DataX优势 1、可靠的监控
2、数据转换功能丰富
3、精准的流控
4、同步性能好
5、容错机制健壮
6、使用体验好
二、DataX源码解读 2.1、入口类：Engine 入口类为com.alibaba.datax.core.Engine.java main函数
1、解析args入参：
Options options = new Options(); options.addOption(&#34;job&#34;, true, &#34;Job config.&#34;); options.addOption(&#34;jobid&#34;, true, &#34;Job unique id.&#34;); options.addOption(&#34;mode&#34;, true, &#34;Job runtime mode.&#34;); BasicParser parser = new BasicParser(); CommandLine cl = parser." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/05c108ba9589377c2f1bf2ad75ef5d22/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-21T16:27:38+08:00" />
<meta property="article:modified_time" content="2022-11-21T16:27:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">再学DataX</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="DataX_1"></a>一、DataX简介</h2> 
<p>DataX官网文档：https://github.com/alibaba/DataX/blob/master/introduction.md</p> 
<p>DataX 是一个异构数据源离线同步工具，致力于实现包括关系型数据库(MySQL、Oracle等)、HDFS、Hive、ODPS、HBase、FTP等各种异构数据源之间稳定高效的数据同步功能。</p> 
<p><img src="https://images2.imgbox.com/0c/49/QmsJSw9w_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="11DataX_30_10"></a>1.1、DataX 3.0框架设计</h3> 
<p><img src="https://images2.imgbox.com/eb/f3/zzitbVPw_o.png" alt="在这里插入图片描述"></p> 
<p>DataX本身作为离线数据同步框架，采用Framework + plugin架构构建。将数据源读取和写入抽象成为Reader/Writer插件，纳入到整个同步框架中。</p> 
<p>Reader：Reader为数据采集模块，负责采集数据源的数据，将数据发送给Framework。<br> Writer： Writer为数据写入模块，负责不断向Framework取数据，并将数据写入到目的端。<br> Framework：Framework用于连接reader和writer，作为两者的数据传输通道，并处理缓冲，流控，并发，数据转换等核心技术问题。</p> 
<h3><a id="12DataX30_18"></a>1.2、DataX3.0核心架构</h3> 
<p>DataX 3.0 开源版本支持单机多线程模式完成同步作业运行</p> 
<p><img src="https://images2.imgbox.com/85/23/nhAIKOnx_o.png" alt="在这里插入图片描述"></p> 
<p>1、Job</p> 
<p>DataX完成单个数据同步的作业。一个Job对应一个进程。Job模块负责task切分，TaskGroup管理等。</p> 
<p>2、Task</p> 
<p>Task是DataX的最小单元，每个task负责一部分数据同步工作。</p> 
<p>3、TaskGroup</p> 
<p>Job在切分完多个Task后，会调用DataX的scheduler模块，根据配置的并发量，将拆分成的多个Task分配到不同的TaskGroup中，每个TaskGroup负责以一定并发运行分配给他的全部Task，每个TaskGroup默认的并发量是5.</p> 
<p>4、Task的执行流程</p> 
<p>每个Task由TaskGroup启动，每个Task对固定启动Reader—&gt;Channel—&gt;Writer的线程来完成数据同步工作。</p> 
<p>DataX Job运行起来后，由Job监控并等待每个TaskGroup的task执行完成，等所有TaskGroup任务执行完成后，Job成功退出。否则，异常退出。</p> 
<p>5、DataX调度流程</p> 
<p>举例来说，用户提交了一个DataX作业，并且配置了20个并发，目的是将一个100张分表的mysql数据同步到odps里面。</p> 
<p>DataX的调度决策思路是：</p> 
<p>1）DataX Job根据分库分表切分成了100个Task。</p> 
<p>2）由于配置了20个并发，每个TaskGroup默认并发度是5，所以需要4个TaskGroup</p> 
<p>3）由4个TaskGroup平均切分100个Task，每个TaskGroup被分到了25个Task，共启动5个并发。</p> 
<h3><a id="13DataX_54"></a>1.3、DataX优势</h3> 
<p>1、可靠的监控</p> 
<p>2、数据转换功能丰富</p> 
<p>3、精准的流控</p> 
<p>4、同步性能好</p> 
<p>5、容错机制健壮</p> 
<p>6、使用体验好</p> 
<h2><a id="DataX_68"></a>二、DataX源码解读</h2> 
<h3><a id="21Engine_69"></a>2.1、入口类：Engine</h3> 
<p>入口类为com.alibaba.datax.core.Engine.java main函数</p> 
<p>1、解析args入参：</p> 
<pre><code class="prism language-java"><span class="token class-name">Options</span> options <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Options</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
options<span class="token punctuation">.</span><span class="token function">addOption</span><span class="token punctuation">(</span><span class="token string">"job"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string">"Job config."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
options<span class="token punctuation">.</span><span class="token function">addOption</span><span class="token punctuation">(</span><span class="token string">"jobid"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string">"Job unique id."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
options<span class="token punctuation">.</span><span class="token function">addOption</span><span class="token punctuation">(</span><span class="token string">"mode"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string">"Job runtime mode."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">BasicParser</span> parser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BasicParser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">CommandLine</span> cl <span class="token operator">=</span> parser<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>options<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>针对命令行参数采用了org.apache.commons的BasicParser解析，针对任务的配置文件则通过其本身的ConfigParser进行解析（可以支持本地和网络文件）。</p> 
<p>2、启动Engine<br> 参数启动完毕后，调用Engine.start方法启动</p> 
<pre><code class="prism language-java"><span class="token class-name">ConfigurationValidate</span><span class="token punctuation">.</span><span class="token function">doValidate</span><span class="token punctuation">(</span>configuration<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Engine</span> engine <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Engine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
engine<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span>configuration<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>然后选择是Job模式还是TaskGroup模式：</p> 
<pre><code class="prism language-java"><span class="token keyword">boolean</span> isStandAloneMode <span class="token operator">=</span> <span class="token string">"standalone"</span><span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token constant">RUNTIME_MODE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>实际上基本都是Job模式，后续我们主要以JobContainer为切入点，另一个则为TaskGroupContainer。两者均继承自AbstractContainer基类，并通过调用他们的start方法进行启动。</p> 
<h3><a id="22JobContainer_101"></a>2.2、JobContainer</h3> 
<p>JobContainer.start方法是入口</p> 
<h4><a id="preHander_104"></a>preHander</h4> 
<p>Job前置操作，即初始化preHandler插件并执行其preHandler</p> 
<p>1）init<br> 初始化reader和writer，实际方法中根据读写插件各自执行了对应的初始化方法:</p> 
<pre><code class="prism language-java"><span class="token comment">//必须先Reader ，后Writer</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>jobReader <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initJobReader</span><span class="token punctuation">(</span>jobPluginCollector<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>jobWriter <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initJobWriter</span><span class="token punctuation">(</span>jobPluginCollector<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>2）prepare<br> 全局准备工作，比如odpswriter清空目标表。由于读写插件的特殊性质，其方法内部主要也是执行了各类型插件的方法来实现准备工作</p> 
<pre><code class="prism language-java"><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepareJobReader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">prepareJobWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>3）split<br> 拆分Task，参数adviceNumber为建议的拆分数。除此之外我们还可以通过字节和事务的限速来进行控制，从而决定Channel的数量。</p> 
<ul><li>job.setting.speed.byte：总BPS限速，如果存在值则单个Channel的BPS不能为空，通过总限速除以单个Channel限速得出Channel的需求数量；</li><li>core.transport.channel.speed.byte：单个Channel的BPS限速；</li><li>job.setting.speed.record：总TPS限速，如果存在则单个Channel的TPS不能为空，通过总限速除以单个Channel限速得出Channel的需求数量；</li><li>core.transport.channel.speed.record：单个Channel的TPS限速；</li></ul> 
<p>4）schedule<br> schedule首先完成的工作是把上一步reader和writer split的结果整合到具体taskGroupContainer中, 同时不同的执行模式调用不同的调度策略，将所有任务调度起来</p> 
<p>由于实际任务是由TaskGroupContainer执行，为此我们还需要划分对应TaskGroup需要运行的Task，该参数通过core.container.taskGroup.channel进行配置，默认为5。决定每个Group运行那些Task的则由以下方法进行决定，将直接返回对应任务组的配置参数。</p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * 通过获取配置信息得到每个taskGroup需要运行哪些tasks任务
 */</span>
<span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Configuration</span><span class="token punctuation">&gt;</span></span> taskGroupConfigs <span class="token operator">=</span> <span class="token class-name">JobAssignUtil</span><span class="token punctuation">.</span><span class="token function">assignFairly</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>configuration<span class="token punctuation">,</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>needChannelNumber<span class="token punctuation">,</span> channelsPerTaskGroup<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>完成任务分配后我们就需要根据运行模式决定调度器，通过这里的源码可以明显看出其DataX 3.0是经过了阉割，仅保留了单机运行模式。</p> 
<pre><code class="prism language-java">executeMode <span class="token operator">=</span> <span class="token class-name">ExecuteMode</span><span class="token punctuation">.</span><span class="token constant">STANDALONE</span><span class="token punctuation">;</span>
scheduler <span class="token operator">=</span> <span class="token function">initStandaloneScheduler</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>configuration<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>后续我们仅能描述单机模式下关于任务调度的工作原理：<br> Step1：调度器初始化的核心方法initStandaloneScheduler，其方法主要是初始化了StandAloneJobContainerCommunicator类用于通信（其中collect由ProcessInnerCollector提供，reporter由ProcessInnerReporter提供），StandAloneScheduler则为实际调度器。</p> 
<p>最终执行：</p> 
<pre><code class="prism language-java">scheduler<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span>taskGroupConfigs<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在AbstractScheduler的schedule中通过StandAloneJobContainerCommunicator类调用了其collect方法：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">Communication</span> <span class="token function">collect</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getCollector</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collectFromTaskGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>该类为ProcessInnerCollector类，其对应的方法依然是LocalTGCommunicationManager静态类其中一个静态方法。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">Communication</span> <span class="token function">collectFromTaskGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token class-name">LocalTGCommunicationManager</span><span class="token punctuation">.</span><span class="token function">getJobCommunication</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>其内部也是将之前每个TaskGroup所创建的Communication维护了一个静态字典并在需要的时候进行合并。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Communication</span> <span class="token function">getJobCommunication</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Communication</span> communication <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Communication</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    communication<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token class-name">State</span><span class="token punctuation">.</span><span class="token constant">SUCCEEDED</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Communication</span> taskGroupCommunication <span class="token operator">:</span>
            taskGroupCommunicationMap<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        communication<span class="token punctuation">.</span><span class="token function">mergeFrom</span><span class="token punctuation">(</span>taskGroupCommunication<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> communication<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/50bb6f5c70cab17dc38c7ab60e5b3399/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vscode 在debug模式给被调试程序传递环境变量</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ae1f3d2616e0a2da462ac90a56e8556a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">编写程序模拟2-3个事务并发执行，简单实现调度器功能：加锁（含更新锁），根据锁表判断事务是否可获得锁，解锁</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>