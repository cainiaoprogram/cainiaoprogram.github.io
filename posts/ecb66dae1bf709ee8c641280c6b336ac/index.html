<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>＜JVM下篇：性能监控与调优篇＞01-概述篇-02-JVM监控及诊断工具-命令行篇 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="＜JVM下篇：性能监控与调优篇＞01-概述篇-02-JVM监控及诊断工具-命令行篇" />
<meta property="og:description" content="笔记来源：尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）
同步更新：https://gitee.com/vectorx/NOTE_JVM
https://codechina.csdn.net/qq_35925558/NOTE_JVM
https://github.com/uxiahnan/NOTE_JVM
文章目录 1. 概述篇1.1. 大厂面试题1.2. 背景说明1.3. 调优概述1.4. 性能优化的步骤1.5. 性能评价/测试指标 2. JVM监控及诊断工具-命令行篇2.1. 概述2.2. jps：查看正在运行的Java进程2.3. jstat：查看JVM统计信息2.4. jinfo：实时查看和修改JVM配置参数2.5. jmap：导出内存映像文件&amp;内存使用情况2.6. jhat：JDK自带堆分析工具2.7. jstack：打印JVM中线程快照2.8. jcmd：多功能命令行2.9. jstatd：远程主机信息收集 1. 概述篇 1.1. 大厂面试题 支付宝：
支付宝三面：JVM性能调优都做了什么？
小米：
有做过JVM内存优化吗？
从SQL、JVM、架构、数据库四个方面讲讲优化思路
蚂蚁金服：
JVM的编译优化
jvm性能调优都做了什么
JVM诊断调优工具用过哪些？
二面：jvm怎样调优，堆内存、栈空间设置多少合适
三面：JVM相关的分析工具使用过的有哪些？具体的性能调优步骤如何
阿里：
如何进行JVM调优？有哪些方法？
如何理解内存泄漏问题？有哪些情况会导致内存泄漏？如何解决？
字节跳动：
三面：JVM如何调优、参数怎么调？
拼多多：
从SQL、JVM、架构、数据库四个方面讲讲优化思路
京东：
JVM诊断调优工具用过哪些？
每秒几十万并发的秒杀系统为什么会频繁发生GC？
日均百万级交易系统如何优化JVM？
线上生产系统OOM如何监控及定位与解决？
高并发系统如何基于G1垃圾回收器优化性能？
1.2. 背景说明 生产环境中的问题
生产环境发生了内存溢出该如何处理？生产环境应该给服务器分配多少内存合适？如何对垃圾回收器的性能进行调优？生产环境CPU负载飙高该如何处理？生产环境应该给应用分配多少线程合适？不加log，如何确定请求是否执行了某一行代码？不加log，如何实时查看某个方法的入参与返回值？ 为什么要调优
防止出现OOM解决OOM减少Full GC出现的频率 不同阶段的考虑
上线前项目运行阶段线上出现OOM 1.3. 调优概述 监控的依据
运行日志异常堆栈GC日志线程快照堆转储快照 调优的大方向
合理地编写代码充分并合理的使用硬件资源合理地进行JVM调优 1.4. 性能优化的步骤 第1步：性能监控" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ecb66dae1bf709ee8c641280c6b336ac/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-04T21:52:43+08:00" />
<meta property="article:modified_time" content="2021-05-04T21:52:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">＜JVM下篇：性能监控与调优篇＞01-概述篇-02-JVM监控及诊断工具-命令行篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>笔记来源：<a href="https://www.bilibili.com/video/BV1PJ411n7xZ" rel="nofollow" title="尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）">尚硅谷JVM全套教程，百万播放，全网巅峰（宋红康详解java虚拟机）</a></p> 
 <p>同步更新：https://gitee.com/vectorx/NOTE_JVM</p> 
 <p>https://codechina.csdn.net/qq_35925558/NOTE_JVM</p> 
 <p>https://github.com/uxiahnan/NOTE_JVM</p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1__9" rel="nofollow">1. 概述篇</a></li><li><ul><li><a href="#11__11" rel="nofollow">1.1. 大厂面试题</a></li><li><a href="#12__73" rel="nofollow">1.2. 背景说明</a></li><li><a href="#13__97" rel="nofollow">1.3. 调优概述</a></li><li><a href="#14__113" rel="nofollow">1.4. 性能优化的步骤</a></li><li><a href="#15__141" rel="nofollow">1.5. 性能评价/测试指标</a></li></ul> 
  </li><li><a href="#2_JVM_188" rel="nofollow">2. JVM监控及诊断工具-命令行篇</a></li><li><ul><li><a href="#21__190" rel="nofollow">2.1. 概述</a></li><li><a href="#22_jpsJava_212" rel="nofollow">2.2. jps：查看正在运行的Java进程</a></li><li><a href="#23_jstatJVM_241" rel="nofollow">2.3. jstat：查看JVM统计信息</a></li><li><a href="#24_jinfoJVM_367" rel="nofollow">2.4. jinfo：实时查看和修改JVM配置参数</a></li><li><a href="#25_jmap_468" rel="nofollow">2.5. jmap：导出内存映像文件&amp;内存使用情况</a></li><li><a href="#26_jhatJDK_502" rel="nofollow">2.6. jhat：JDK自带堆分析工具</a></li><li><a href="#27_jstackJVM_523" rel="nofollow">2.7. jstack：打印JVM中线程快照</a></li><li><a href="#28_jcmd_548" rel="nofollow">2.8. jcmd：多功能命令行</a></li><li><a href="#29_jstatd_572" rel="nofollow">2.9. jstatd：远程主机信息收集</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="1__9"></a>1. 概述篇</h2> 
<h3><a id="11__11"></a>1.1. 大厂面试题</h3> 
<blockquote> 
 <p><mark>支付宝：</mark></p> 
 <p>支付宝三面：JVM性能调优都做了什么？</p> 
 <p><mark>小米：</mark></p> 
 <p>有做过JVM内存优化吗？</p> 
 <p>从SQL、JVM、架构、数据库四个方面讲讲优化思路</p> 
 <p><mark>蚂蚁金服：</mark></p> 
 <p>JVM的编译优化</p> 
 <p>jvm性能调优都做了什么</p> 
 <p>JVM诊断调优工具用过哪些？</p> 
 <p>二面：jvm怎样调优，堆内存、栈空间设置多少合适</p> 
 <p>三面：JVM相关的分析工具使用过的有哪些？具体的性能调优步骤如何</p> 
 <p><mark>阿里：</mark></p> 
 <p>如何进行JVM调优？有哪些方法？</p> 
 <p>如何理解内存泄漏问题？有哪些情况会导致内存泄漏？如何解决？</p> 
 <p><mark>字节跳动：</mark></p> 
 <p>三面：JVM如何调优、参数怎么调？</p> 
 <p><mark>拼多多：</mark></p> 
 <p>从SQL、JVM、架构、数据库四个方面讲讲优化思路</p> 
 <p><mark>京东：</mark></p> 
 <p>JVM诊断调优工具用过哪些？</p> 
 <p>每秒几十万并发的秒杀系统为什么会频繁发生GC？</p> 
 <p>日均百万级交易系统如何优化JVM？</p> 
 <p>线上生产系统OOM如何监控及定位与解决？</p> 
 <p>高并发系统如何基于G1垃圾回收器优化性能？</p> 
</blockquote> 
<h3><a id="12__73"></a>1.2. 背景说明</h3> 
<p><strong>生产环境中的问题</strong></p> 
<ul><li>生产环境发生了内存溢出该如何处理？</li><li>生产环境应该给服务器分配多少内存合适？</li><li>如何对垃圾回收器的性能进行调优？</li><li>生产环境CPU负载飙高该如何处理？</li><li>生产环境应该给应用分配多少线程合适？</li><li>不加log，如何确定请求是否执行了某一行代码？</li><li>不加log，如何实时查看某个方法的入参与返回值？</li></ul> 
<p><strong>为什么要调优</strong></p> 
<ul><li>防止出现OOM</li><li>解决OOM</li><li>减少Full GC出现的频率</li></ul> 
<p><strong>不同阶段的考虑</strong></p> 
<ul><li>上线前</li><li>项目运行阶段</li><li>线上出现OOM</li></ul> 
<h3><a id="13__97"></a>1.3. 调优概述</h3> 
<p><strong>监控的依据</strong></p> 
<ul><li>运行日志</li><li>异常堆栈</li><li>GC日志</li><li>线程快照</li><li>堆转储快照</li></ul> 
<p><strong>调优的大方向</strong></p> 
<ul><li>合理地编写代码</li><li>充分并合理的使用硬件资源</li><li>合理地进行JVM调优</li></ul> 
<h3><a id="14__113"></a>1.4. 性能优化的步骤</h3> 
<p><strong>第1步：性能监控</strong></p> 
<ul><li>GC频繁</li><li>cpu load过高</li><li>OOM</li><li>内存泄露</li><li>死锁</li><li>程序响应时间较长</li></ul> 
<p><strong>第2步：性能分析</strong></p> 
<ul><li>打印GC日志，通过GCviewer或者 http://gceasy.io 来分析异常信息</li><li>灵活运用命令行工具、jstack、jmap、jinfo等</li><li>dump出堆文件，使用内存分析工具分析文件</li><li>使用阿里Arthas、jconsole、JVisualVM来实时查看JVM状态</li><li>jstack查看堆栈信息</li></ul> 
<p><strong>第3步：性能调优</strong></p> 
<ul><li>适当增加内存，根据业务背景选择垃圾回收器</li><li>优化代码，控制内存使用</li><li>增加机器，分散节点压力</li><li>合理设置线程池线程数量</li><li>使用中间件提高程序效率，比如缓存、消息队列等</li><li>其他……</li></ul> 
<h3><a id="15__141"></a>1.5. 性能评价/测试指标</h3> 
<p><strong>停顿时间（或响应时间）</strong></p> 
<p>提交请求和返回该请求的响应之间使用的时间，一般比较关注平均响应时间。常用操作的响应时间列表：</p> 
<table><thead><tr><th align="left">操作</th><th align="left">响应时间</th></tr></thead><tbody><tr><td align="left">打开一个站点</td><td align="left">几秒</td></tr><tr><td align="left">数据库查询一条记录（有索引）</td><td align="left">十几毫秒</td></tr><tr><td align="left">机械磁盘一次寻址定位</td><td align="left">4毫秒</td></tr><tr><td align="left">从机械磁盘顺序读取1M数据</td><td align="left">2毫秒</td></tr><tr><td align="left">从SSD磁盘顺序读取1M数据</td><td align="left">0.3毫秒</td></tr><tr><td align="left">从远程分布式换成Redis 读取一个数据</td><td align="left">0.5毫秒</td></tr><tr><td align="left">从内存读取 1M数据</td><td align="left">十几微妙</td></tr><tr><td align="left">Java程序本地方法调用</td><td align="left">几微妙</td></tr><tr><td align="left">网络传输2Kb数据</td><td align="left">1 微妙</td></tr></tbody></table> 
<p>在垃圾回收环节中：</p> 
<ul><li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间。</li><li>-XX:MaxGCPauseMillis</li></ul> 
<p><strong>吞吐量</strong></p> 
<ul><li>对单位时间内完成的工作量（请求）的量度</li><li>在GC中：运行用户代码的事件占总运行时间的比例（总运行时间：程序的运行时间+内存回收的时间）</li><li>吞吐量为1-1/(1+n)，其中-XX::GCTimeRatio=n</li></ul> 
<p><strong>并发数</strong></p> 
<ul><li>同一时刻，对服务器有实际交互的请求数</li></ul> 
<p><strong>内存占用</strong></p> 
<ul><li>Java堆区所占的内存大小</li></ul> 
<p><strong>相互间的关系</strong></p> 
<p>以高速公路通行状况为例</p> 
<ul><li>吞吐量：每天通过高速公路收费站的车辆的数据</li><li>并发数：高速公路上正在行驶的车辆的数目</li><li>响应时间：车速</li></ul> 
<hr> 
<h2><a id="2_JVM_188"></a>2. JVM监控及诊断工具-命令行篇</h2> 
<h3><a id="21__190"></a>2.1. 概述</h3> 
<p>性能诊断是软件工程师在日常工作中需要经常面对和解决的问题，在用户体验至上的今天，解决好应用的性能问题能带来非常大的收益。</p> 
<p>Java 作为最流行的编程语言之一，其应用性能诊断一直受到业界广泛关注。可能造成 Java 应用出现性能问题的因素非常多，例如线程控制、磁盘读写、数据库访问、网络I/O、垃圾收集等。想要定位这些问题，一款优秀的性能诊断工具必不可少。</p> 
<p>体会1：使用数据说明问题，使用知识分析问题，使用工具处理问题。</p> 
<p>体会2：无监控、不调优！</p> 
<p><strong>简单命令行工具</strong></p> 
<p>在我们刚接触java学习的时候，大家肯定最先了解的两个命令就是javac，java，那么除此之外，还有没有其他的命令可以供我们使用呢？</p> 
<p>我们进入到安装jdk的bin目录，发现还有一系列辅助工具。这些辅助工具用来获取目标 JVM 不同方面、不同层次的信息，帮助开发人员很好地解决Java应用程序的一些疑难杂症。</p> 
<p><img src="https://images2.imgbox.com/30/13/Ajz1N3do_o.png" alt="image-20210504195803526"></p> 
<p><img src="https://images2.imgbox.com/8a/99/ycFneanv_o.png" alt="image-20210504195836342"></p> 
<p>官方源码地址：<a href="http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools" rel="nofollow">http://hg.openjdk.java.net/jdk/jdk11/file/1ddf9a99e4ad/src/jdk.jcmd/share/classes/sun/tools</a></p> 
<h3><a id="22_jpsJava_212"></a>2.2. jps：查看正在运行的Java进程</h3> 
<p>jps(Java Process Status)：显示指定系统内所有的HotSpot虚拟机进程（查看虚拟机进程信息），可用于查询正在运行的虚拟机进程。</p> 
<p>说明：对于本地虚拟机进程来说，进程的本地虚拟机ID与操作系统的进程ID是一致的，是唯一的。</p> 
<p>基本使用语法为：jps [options] [hostid]</p> 
<p>我们还可以通过追加参数，来打印额外的信息。</p> 
<p><strong>options参数</strong></p> 
<ul><li>-q：仅仅显示LVMID（local virtual machine id），即本地虚拟机唯一id。不显示主类的名称等</li><li>-l：输出应用程序主类的全类名 或 如果进程执行的是jar包，则输出jar完整路径</li><li>-m：输出虚拟机进程启动时传递给主类main()的参数</li><li>-v：列出虚拟机进程启动时的JVM参数。比如：-Xms20m -Xmx50m是启动程序指定的jvm参数。</li></ul> 
<p>说明：以上参数可以综合使用。</p> 
<p>补充：如果某 Java 进程关闭了默认开启的UsePerfData参数（即使用参数-XX：-UsePerfData），那么jps命令（以及下面介绍的jstat）将无法探知该Java 进程。</p> 
<p><strong>hostid参数</strong></p> 
<p>RMI注册表中注册的主机名。如果想要远程监控主机上的 java 程序，需要安装 jstatd。</p> 
<p>对于具有更严格的安全实践的网络场所而言，可能使用一个自定义的策略文件来显示对特定的可信主机或网络的访问，尽管这种技术容易受到IP地址欺诈攻击。</p> 
<p>如果安全问题无法使用一个定制的策略文件来处理，那么最安全的操作是不运行jstatd服务器，而是在本地使用jstat和jps工具。</p> 
<h3><a id="23_jstatJVM_241"></a>2.3. jstat：查看JVM统计信息</h3> 
<p>jstat（JVM Statistics Monitoring Tool）：用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。在没有GUI图形界面，只提供了纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。常用于检测垃圾回收问题以及内存泄漏问题。</p> 
<p>官方文档：<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html" rel="nofollow">https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html</a></p> 
<p>基本使用语法为：jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</p> 
<p>查看命令相关参数：jstat-h 或 jstat-help</p> 
<p>其中vmid是进程id号，也就是jps之后看到的前面的号码，如下：</p> 
<p><img src="https://images2.imgbox.com/13/f0/5uud9azz_o.png" alt="image-20210504201703222"></p> 
<p><strong>option参数</strong></p> 
<p>选项option可以由以下值构成。</p> 
<p><mark>类装载相关的：</mark></p> 
<ul><li>-class：显示ClassLoader的相关信息：类的装载、卸载数量、总空间、类装载所消耗的时间等</li></ul> 
<p><mark>垃圾回收相关的：</mark></p> 
<ul><li>-gc：显示与GC相关的堆信息。包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息。</li><li>-gccapacity：显示内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间。</li><li>-gcutil：显示内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比。</li><li>-gccause：与-gcutil功能一样，但是会额外输出导致最后一次或当前正在发生的GC产生的原因。</li><li>-gcnew：显示新生代GC状况</li><li>-gcnewcapacity：显示内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</li><li>-geold：显示老年代GC状况</li><li>-gcoldcapacity：显示内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</li><li>-gcpermcapacity：显示永久代使用到的最大、最小空间。</li></ul> 
<p><mark>JIT相关的：</mark></p> 
<ul><li> <p>-compiler：显示JIT编译器编译过的方法、耗时等信息</p> </li><li> <p>-printcompilation：输出已经被JIT编译的方法</p> </li></ul> 
<p><strong>jstat -class</strong></p> 
<p><img src="https://images2.imgbox.com/f2/8d/Pe57LLml_o.png" alt="img"></p> 
<p><strong>jstat -compiler</strong></p> 
<p><img src="https://images2.imgbox.com/19/20/iGiWPJaq_o.png" alt="img"></p> 
<p><strong>jstat -printcompilation</strong></p> 
<p><img src="https://images2.imgbox.com/88/41/5i0RJ8Qr_o.png" alt="img"></p> 
<p><strong>jstat -gc</strong></p> 
<p><img src="https://images2.imgbox.com/5b/c6/OxQFgkkI_o.png" alt="img"></p> 
<p><strong>jstat -gccapacity</strong></p> 
<p><img src="https://images2.imgbox.com/38/fa/PxTUJ6WI_o.png" alt="img"></p> 
<p><strong>jstat -gcutil</strong></p> 
<p><img src="https://images2.imgbox.com/7c/b1/HdiR21La_o.png" alt="img"></p> 
<p><strong>jstat -gccause</strong></p> 
<p><img src="https://images2.imgbox.com/a4/ed/dNK2bsA6_o.png" alt="img"></p> 
<p><strong>jstat -gcnew</strong></p> 
<p><img src="https://images2.imgbox.com/01/bc/zFUt3j7P_o.png" alt="img"></p> 
<p><strong>jstat -gcnewcapacity</strong></p> 
<p><img src="https://images2.imgbox.com/cb/b2/C8QcfuFc_o.png" alt="img"></p> 
<p><strong>jstat -gcold</strong></p> 
<p><img src="https://images2.imgbox.com/d3/20/eeoYgW9A_o.png" alt="img"></p> 
<p><strong>jstat -gcoldcapacity</strong></p> 
<p><img src="https://images2.imgbox.com/18/57/nYrkJpxz_o.png" alt="img"></p> 
<p><strong>jstat -t</strong></p> 
<p><img src="https://images2.imgbox.com/5c/eb/zCFbZCw6_o.png" alt="img"></p> 
<p><strong>jstat -t -h</strong></p> 
<p><img src="https://images2.imgbox.com/ad/1c/6FZhMRRj_o.png" alt="img"></p> 
<table><thead><tr><th align="left">表头</th><th align="left">含义（字节）</th></tr></thead><tbody><tr><td align="left">EC</td><td align="left">Eden区的大小</td></tr><tr><td align="left">EU</td><td align="left">Eden区已使用的大小</td></tr><tr><td align="left">S0C</td><td align="left">幸存者0区的大小</td></tr><tr><td align="left">S1C</td><td align="left">幸存者1区的大小</td></tr><tr><td align="left">S0U</td><td align="left">幸存者0区已使用的大小</td></tr><tr><td align="left">S1U</td><td align="left">幸存者1区已使用的大小</td></tr><tr><td align="left">MC</td><td align="left">元空间的大小</td></tr><tr><td align="left">MU</td><td align="left">元空间已使用的大小</td></tr><tr><td align="left">OC</td><td align="left">老年代的大小</td></tr><tr><td align="left">OU</td><td align="left">老年代已使用的大小</td></tr><tr><td align="left">CCSC</td><td align="left">压缩类空间的大小</td></tr><tr><td align="left">CCSU</td><td align="left">压缩类空间已使用的大小</td></tr><tr><td align="left">YGC</td><td align="left">从应用程序启动到采样时young gc的次数</td></tr><tr><td align="left">YGCT</td><td align="left">从应用程序启动到采样时young gc消耗时间（秒）</td></tr><tr><td align="left">FGC</td><td align="left">从应用程序启动到采样时full gc的次数</td></tr><tr><td align="left">FGCT</td><td align="left">从应用程序启动到采样时的full gc的消耗时间（秒）</td></tr><tr><td align="left">GCT</td><td align="left">从应用程序启动到采样时gc的总时间</td></tr></tbody></table> 
<p><strong>interval参数：</strong> 用于指定输出统计数据的周期，单位为毫秒。即：查询间隔</p> 
<p><strong>count参数：</strong> 用于指定查询的总次数</p> 
<p><strong>-t参数：</strong> 可以在输出信息前加上一个Timestamp列，显示程序的运行时间。单位：秒</p> 
<p><strong>-h参数：</strong> 可以在周期性数据输出时，输出多少行数据后输出一个表头信息</p> 
<p><strong>补充：</strong> jstat还可以用来判断是否出现内存泄漏。</p> 
<p>第1步：在长时间运行的 Java 程序中，我们可以运行jstat命令连续获取多行性能数据，并取这几行数据中 OU 列（即已占用的老年代内存）的最小值。</p> 
<p>第2步：然后，我们每隔一段较长的时间重复一次上述操作，来获得多组 OU 最小值。如果这些值呈上涨趋势，则说明该 Java 程序的老年代内存已使用量在不断上涨，这意味着无法回收的对象在不断增加，因此很有可能存在内存泄漏。</p> 
<h3><a id="24_jinfoJVM_367"></a>2.4. jinfo：实时查看和修改JVM配置参数</h3> 
<p>jinfo(Configuration Info for Java)：查看虚拟机配置参数信息，也可用于调整虚拟机的配置参数。在很多情况卡，Java应用程序不会指定所有的Java虚拟机参数。而此时，开发人员可能不知道某一个具体的Java虚拟机参数的默认值。在这种情况下，可能需要通过查找文档获取某个参数的默认值。这个查找过程可能是非常艰难的。但有了jinfo工具，开发人员可以很方便地找到Java虚拟机参数的当前值。</p> 
<p>基本使用语法为：jinfo [options] pid</p> 
<p>说明：java 进程ID必须要加上</p> 
<table><thead><tr><th>选项</th><th>选项说明</th></tr></thead><tbody><tr><td>no option</td><td>输出全部的参数和系统属性</td></tr><tr><td>-flag name</td><td>输出对应名称的参数</td></tr><tr><td>-flag [±]name</td><td>开启或者关闭对应名称的参数 只有被标记为manageable的参数才可以被动态修改</td></tr><tr><td>-flag name=value</td><td>设定对应名称的参数</td></tr><tr><td>-flags</td><td>输出全部的参数</td></tr><tr><td>-sysprops</td><td>输出系统属性</td></tr></tbody></table> 
<p><strong>jinfo -sysprops</strong></p> 
<pre><code class="prism language-properties">&gt; jinfo -sysprops
jboss.modules.system.pkgs = com.intellij.rt
java.vendor = Oracle Corporation
sun.java.launcher = SUN_STANDARD
sun.management.compiler = HotSpot 64-Bit Tiered Compilers
catalina.useNaming = true
os.name = Windows 10
...
</code></pre> 
<p><strong>jinfo -flags</strong></p> 
<pre><code class="prism language-shell"><span class="token operator">&gt;</span> jinfo -flags 25592
Non-default VM flags: -XX:CICompilerCount<span class="token operator">=</span>4 -XX:InitialHeapSize<span class="token operator">=</span>333447168 -XX:MaxHeapSize<span class="token operator">=</span>5324668928 -XX:MaxNewSize<span class="token operator">=</span>1774714880 -XX:MinHeapDeltaBytes<span class="token operator">=</span>524288 -XX:NewSize<span class="token operator">=</span>111149056 -XX:OldSize<span class="token operator">=</span>222298112 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseFastUnorderedTimeStamps -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC
Command line:  -agentlib:jdwp<span class="token operator">=</span>transport<span class="token operator">=</span>dt_socket,address<span class="token operator">=</span>127.0.0.1:8040,suspend<span class="token operator">=</span>y,server<span class="token operator">=</span>n -Drebel.base<span class="token operator">=</span>C:\Users\Vector\.jrebel -Drebel.env.ide.plugin.version<span class="token operator">=</span>2021.1.2 -Drebel.env.ide.version<span class="token operator">=</span>2020.3.3 -Drebel.env.ide.product<span class="token operator">=</span>IU -Drebel.env.ide<span class="token operator">=</span>intellij -Drebel.notification.url<span class="token operator">=</span>http://localhost:7976 -agentpath:C:\Users\Vector\AppData\Roaming\JetBrains\IntelliJIdea2020.3\plugins\jr-ide-idea\lib\jrebel6\lib\jrebel64.dll -Dmaven.home<span class="token operator">=</span>D:\eclipse\env\maven -Didea.modules.paths.file<span class="token operator">=</span>C:\Users\Vector\AppData\Local\JetBrains\IntelliJIdea2020.3\Maven\idea-projects-state-596682c7.properties -Dclassworlds.conf<span class="token operator">=</span>C:\Users\Vector\AppData\Local\Temp\idea-6755-mvn.conf -Dmaven.ext.class.path<span class="token operator">=</span>D:\IDEA\plugins\maven\lib\maven-event-listener.jar -javaagent:D:\IDEA\plugins\java\lib\rt\debugger-agent.jar -Dfile.encoding<span class="token operator">=</span>UTF-8
</code></pre> 
<p><strong>jinfo -flag</strong></p> 
<pre><code class="prism language-shell"><span class="token operator">&gt;</span> jinfo -flag UseParallelGC 25592
-XX:+UseParallelGC

<span class="token operator">&gt;</span> jinfo -flag UseG1GC 25592
-XX:-UseG1GC
</code></pre> 
<p><strong>jinfo -flag name</strong></p> 
<pre><code class="prism language-shell"><span class="token operator">&gt;</span> jinfo -flag UseParallelGC 25592
-XX:+UseParallelGC

<span class="token operator">&gt;</span> jinfo -flag UseG1GC 25592
-XX:-UseG1GC
</code></pre> 
<p><strong>jinfo -flag [±]name</strong></p> 
<pre><code class="prism language-shell"><span class="token operator">&gt;</span> jinfo -flag +PrintGCDetails 25592
<span class="token operator">&gt;</span> jinfo -flag PrintGCDetails 25592
-XX:+PrintGCDetails

<span class="token operator">&gt;</span> jinfo -flag -PrintGCDetails 25592
<span class="token operator">&gt;</span> jinfo -flag PrintGCDetails 25592
-XX:-PrintGCDetails
</code></pre> 
<p>拓展：</p> 
<ul><li> <p>java -XX:+PrintFlagsInitial 查看所有JVM参数启动的初始值</p> <pre><code class="prism language-shell"><span class="token punctuation">[</span>Global flags<span class="token punctuation">]</span>
     intx ActiveProcessorCount                      <span class="token operator">=</span> -1                                  <span class="token punctuation">{<!-- --></span>product<span class="token punctuation">}</span>
    uintx AdaptiveSizeDecrementScaleFactor          <span class="token operator">=</span> 4                                   <span class="token punctuation">{<!-- --></span>product<span class="token punctuation">}</span>
    uintx AdaptiveSizeMajorGCDecayTimeScale         <span class="token operator">=</span> 10                                  <span class="token punctuation">{<!-- --></span>product<span class="token punctuation">}</span>
    uintx AdaptiveSizePausePolicy                   <span class="token operator">=</span> 0                                   <span class="token punctuation">{<!-- --></span>product<span class="token punctuation">}</span>
<span class="token punctuation">..</span>.
</code></pre> </li><li> <p>java -XX:+PrintFlagsFinal 查看所有JVM参数的最终值</p> <pre><code class="prism language-shell"><span class="token punctuation">[</span>Global flags<span class="token punctuation">]</span>
     intx ActiveProcessorCount                      <span class="token operator">=</span> -1                                  <span class="token punctuation">{<!-- --></span>product<span class="token punctuation">}</span>
<span class="token punctuation">..</span>.
     intx CICompilerCount                          :<span class="token operator">=</span> 4                                   <span class="token punctuation">{<!-- --></span>product<span class="token punctuation">}</span>
    uintx InitialHeapSize                          :<span class="token operator">=</span> 333447168                           <span class="token punctuation">{<!-- --></span>product<span class="token punctuation">}</span>
    uintx MaxHeapSize                              :<span class="token operator">=</span> 1029701632                          <span class="token punctuation">{<!-- --></span>product<span class="token punctuation">}</span>
    uintx MaxNewSize                               :<span class="token operator">=</span> 1774714880                          <span class="token punctuation">{<!-- --></span>product<span class="token punctuation">}</span>
</code></pre> </li><li> <p>java -XX:+PrintCommandLineFlags 查看哪些已经被用户或者JVM设置过的详细的XX参数的名称和值</p> <pre><code class="prism language-shell">-XX:InitialHeapSize<span class="token operator">=</span>332790016 -XX:MaxHeapSize<span class="token operator">=</span>5324640256 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC 
</code></pre> </li></ul> 
<h3><a id="25_jmap_468"></a>2.5. jmap：导出内存映像文件&amp;内存使用情况</h3> 
<p>jmap（JVM Memory Map）：作用一方面是获取dump文件（堆转储快照文件，二进制文件），它还可以获取目标Java进程的内存相关信息，包括Java堆各区域的使用情况、堆中对象的统计信息、类加载信息等。开发人员可以在控制台中输入命令“jmap -help”查阅jmap工具的具体使用方式和一些标准选项配置。</p> 
<p>官方帮助文档：<a href="https://docs.oracle.com/en/java/javase/11/tools/jmap.html" rel="nofollow">https://docs.oracle.com/en/java/javase/11/tools/jmap.html</a></p> 
<p>基本使用语法为：</p> 
<ul><li>jmap [option] &lt;pid&gt;</li><li>jmap [option] &lt;executable &lt;core&gt;</li><li>jmap [option] [server_id@] &lt;remote server IP or hostname&gt;</li></ul> 
<table><thead><tr><th align="left">选项</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">-dump</td><td align="left">生成dump文件（Java堆转储快照），-dump:live只保存堆中的存活对象</td></tr><tr><td align="left">-heap</td><td align="left">输出整个堆空间的详细信息，包括GC的使用、堆配置信息，以及内存的使用信息等</td></tr><tr><td align="left">-histo</td><td align="left">输出堆空间中对象的统计信息，包括类、实例数量和合计容量，-histo:live只统计堆中的存活对象</td></tr><tr><td align="left">-J &lt;flag&gt;</td><td align="left">传递参数给jmap启动的jvm</td></tr><tr><td align="left">-finalizerinfo</td><td align="left">显示在F-Queue中等待Finalizer线程执行finalize方法的对象，仅linux/solaris平台有效</td></tr><tr><td align="left">-permstat</td><td align="left">以ClassLoader为统计口径输出永久代的内存状态信息，仅linux/solaris平台有效</td></tr><tr><td align="left">-F</td><td align="left">当虚拟机进程对-dump选项没有任何响应时，强制执行生成dump文件，仅linux/solaris平台有效</td></tr></tbody></table> 
<p>说明：这些参数和linux下输入显示的命令多少会有不同，包括也受jdk版本的影响。</p> 
<pre><code class="prism language-shell"><span class="token operator">&gt;</span> jmap -dump:format<span class="token operator">=</span>b,file<span class="token operator">=</span><span class="token operator">&lt;</span>filename.hprof<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>pid<span class="token operator">&gt;&gt;</span> jmap -dump:live,format<span class="token operator">=</span>b,file<span class="token operator">=</span><span class="token operator">&lt;</span>filename.hprof<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>pid<span class="token operator">&gt;</span>
</code></pre> 
<p>由于jmap将访问堆中的所有对象，为了保证在此过程中不被应用线程干扰，jmap需要借助安全点机制，让所有线程停留在不改变堆中数据的状态。也就是说，由jmap导出的堆快照必定是安全点位置的。这可能导致基于该堆快照的分析结果存在偏差。</p> 
<p>举个例子，假设在编译生成的机器码中，某些对象的生命周期在两个安全点之间，那么:live选项将无法探知到这些对象。</p> 
<p>另外，如果某个线程长时间无法跑到安全点，jmap将一直等下去。与前面讲的jstat则不同，垃圾回收器会主动将jstat所需要的摘要数据保存至固定位置之中，而jstat只需直接读取即可。</p> 
<h3><a id="26_jhatJDK_502"></a>2.6. jhat：JDK自带堆分析工具</h3> 
<p>jhat(JVM Heap Analysis Tool)：Sun JDK提供的jhat命令与jmap命令搭配使用，用于分析jmap生成的heap dump文件（堆转储快照）。jhat内置了一个微型的HTTP/HTML服务器，生成dump文件的分析结果后，用户可以在浏览器中查看分析结果（分析虚拟机转储快照信息）。</p> 
<p>使用了jhat命令，就启动了一个http服务，端口是7000，即http://localhost:7000/，就可以在浏览器里分析。</p> 
<p>说明：jhat命令在JDK9、JDK10中已经被删除，官方建议用VisualVM代替。</p> 
<p>基本适用语法：jhat &lt;option&gt; &lt;dumpfile&gt;</p> 
<table><thead><tr><th align="left">option参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">-stack false｜true</td><td align="left">关闭｜打开对象分配调用栈跟踪</td></tr><tr><td align="left">-refs false｜true</td><td align="left">关闭｜打开对象引用跟踪</td></tr><tr><td align="left">-port port-number</td><td align="left">设置jhat HTTP Server的端口号，默认7000</td></tr><tr><td align="left">-exclude exclude-file</td><td align="left">执行对象查询时需要排除的数据成员</td></tr><tr><td align="left">-baseline exclude-file</td><td align="left">指定一个基准堆转储</td></tr><tr><td align="left">-debug int</td><td align="left">设置debug级别</td></tr><tr><td align="left">-version</td><td align="left">启动后显示版本信息就退出</td></tr><tr><td align="left">-J &lt;flag&gt;</td><td align="left">传入启动参数，比如-J-Xmx512m</td></tr></tbody></table> 
<h3><a id="27_jstackJVM_523"></a>2.7. jstack：打印JVM中线程快照</h3> 
<p>jstack（JVM Stack Trace）：用于生成虚拟机指定进程当前时刻的线程快照（虚拟机堆栈跟踪）。线程快照就是当前虚拟机内指定进程的每一条线程正在执行的方法堆栈的集合。</p> 
<p>生成线程快照的作用：可用于定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等问题。这些都是导致线程长时间停顿的常见原因。当线程出现停顿时，就可以用jstack显示各个线程调用的堆栈情况。</p> 
<p>官方帮助文档：<a href="https://docs.oracle.com/en/java/javase/11/tools/jstack.html" rel="nofollow">https://docs.oracle.com/en/java/javase/11/tools/jstack.html</a></p> 
<p>在thread dump中，要留意下面几种状态</p> 
<ul><li><mark>死锁，Deadlock（重点关注）</mark></li><li><mark>等待资源，Waiting on condition（重点关注）</mark></li><li><mark>等待获取监视器，Waiting on monitor entry（重点关注）</mark></li><li><mark>阻塞，Blocked（重点关注）</mark></li><li>执行中，Runnable</li><li>暂停，Suspended</li><li>对象等待中，Object.wait() 或 TIMED＿WAITING</li><li>停止，Parked</li></ul> 
<table><thead><tr><th align="left">option参数</th><th align="left">作用</th></tr></thead><tbody><tr><td align="left">-F</td><td align="left">当正常输出的请求不被响应时，强制输出线程堆栈</td></tr><tr><td align="left">-l</td><td align="left">除堆栈外，显示关于锁的附加信息</td></tr><tr><td align="left">-m</td><td align="left">如果调用本地方法的话，可以显示C/C++的堆栈</td></tr></tbody></table> 
<h3><a id="28_jcmd_548"></a>2.8. jcmd：多功能命令行</h3> 
<p>在JDK 1.7以后，新增了一个命令行工具jcmd。它是一个多功能的工具，可以用来实现前面除了jstat之外所有命令的功能。比如：用它来导出堆、内存使用、查看Java进程、导出线程信息、执行GC、JVM运行时间等。</p> 
<p>官方帮助文档：<a href="https://docs.oracle.com/en/java/javase/11/tools/jcmd.html" rel="nofollow">https://docs.oracle.com/en/java/javase/11/tools/jcmd.html</a></p> 
<p>jcmd拥有jmap的大部分功能，并且在Oracle的官方网站上也推荐使用jcmd命令代jmap命令</p> 
<p>**jcmd -l：**列出所有的JVM进程</p> 
<p>**jcmd 进程号 help：**针对指定的进程，列出支持的所有具体命令</p> 
<p><img src="https://images2.imgbox.com/d0/1b/RSWHqRLH_o.png" alt="image-20210504213044819"></p> 
<p>**jcmd 进程号 具体命令：**显示指定进程的指令命令的数据</p> 
<ul><li>Thread.print 可以替换 jstack指令</li><li>GC.class_histogram 可以替换 jmap中的-histo操作</li><li>GC.heap_dump 可以替换 jmap中的-dump操作</li><li>GC.run 可以查看GC的执行情况</li><li>VM.uptime 可以查看程序的总执行时间，可以替换jstat指令中的-t操作</li><li>VM.system_properties 可以替换 jinfo -sysprops 进程id</li><li>VM.flags 可以获取JVM的配置参数信息</li></ul> 
<h3><a id="29_jstatd_572"></a>2.9. jstatd：远程主机信息收集</h3> 
<p>之前的指令只涉及到监控本机的Java应用程序，而在这些工具中，一些监控工具也支持对远程计算机的监控（如jps、jstat）。为了启用远程监控，则需要配合使用jstatd 工具。命令jstatd是一个RMI服务端程序，它的作用相当于代理服务器，建立本地计算机与远程监控工具的通信。jstatd服务器将本机的Java应用程序信息传递到远程计算机。</p> 
<p><img src="https://images2.imgbox.com/0d/ec/Bc1bZ17J_o.png" alt="image-20210504213301077"></p> 
<hr> 
<blockquote> 
 <p>下一篇 <a href="https://blog.csdn.net/qq_35925558/article/details/116429595">＜JVM下篇：性能监控与调优篇＞03-JVM监控及诊断工具-GUI篇</a></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7c610f02acdb20af217a707efceaddf7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux 静态配置多个ip,CentOS8单网卡配置多个静态IP地址</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/351bc6191e350d8d0f026cc994ee1507/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux 网卡地址 ens32,linux没有eth0的解决办法（但是有ifcfg-ens33或ifcfg-en32）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>