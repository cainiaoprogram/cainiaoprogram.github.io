<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>软件工程笔记：通用职责分配模式(grasp) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="软件工程笔记：通用职责分配模式(grasp)" />
<meta property="og:description" content=" 通用职责分配模式(grasp) — 笔记整理自 北京理工大学 计算机学院
什么是GRASP? General Responsibility Assignment Software Patterns(通用职责分配软件模式)GRASP包括4个基本模式和5个扩展模式，描述了对象设计和职责分配的基本原则职责是一个类的契约或义务“做”型职责是通过类的方法来实现的“知道”型职责是通过类内部封装的属性以及类间关系来 体现GRASP是如何设计一个面向对象系统的基础 GRASP的9个模式 专家 :应该将职责分配给信息专家(谁的数据谁负责)创建者 :创建对象的职责(何时，由谁来创建和销毁)低耦合 :类间的关系代表了类之间的耦合程度高内聚 :一个类的职责之间的相关程度和集中程度控制者 :把协调处理系统消息的职责分配给不同控制类多态 :为不同的派生类分配具体的工作，具有相同接口纯虚构 :非实体类，从其他类中抽取相关高内聚职责中介者 :隔离藕合度过大的多个类，可能是虚构的受保护变化:把易于变化部分封装起来便于扩展 信息专家 Information Expert信息专家模式是面向对象设计的最基本原则如果某个类拥有完成某个职责所需要的所有信息，那么这个职责就应该分配给这个类来实现示例:网上购物系统的购物车设计 需求:需要让每种商品只在购物车内出现一次，购买相同商品，只需要更新商品的数量即可方案1:判断相同的职责与商品ID相关，它存在商品类中方案2:商品类为实体类，商品ID相关职责太多，应分散 创建者 尽可能少的建立对象之间的耦合和依赖关系一般情况下，只在下列情况下才由类A来创建类B，即A是B的创建者: 1.A是B的聚合2.A是B的容器3.A持有初始化B的信息(数据)4.A记录B的实例5.A频繁使用B 低耦合 低耦合降低了因一个类的变化而影响其他类的范围，而且让类更简单，更容易理解造成类A、B之间耦合的情况: A是B的属性A调用B的实例的方法A的方法中引用了B，包括B是A方法的返回值或参数A是B的子类，或者A实现了B 遵循一些面向对象设计的基本原则可以降低类间耦合，如LoD，信息专家(职责迁移)，避免夸模块类之间的直接访问等 高内聚 给类尽量分配内聚的职责，即功能性内聚的职责功能性紧密相关的职责应该放在一个类里，并共同完成有限的功能高内聚更有利于类的理解和重用，也便于类的维护高内聚也是一种隔离 控制者 将处理系统事件消息的职责分派给代表下列事物的类:
代表整个系统的类代表整个企业或组织的类代表真实世界中参与职责的主动对象类代表一个用例中所有事件的人工处理者类 控制者模式的相关原则:
1.系统事件的接收与处理通常由一个高级控制者类来代替2.一个子系统会有很多控制者类，分别处理不同的事务3.控制者一般将需要完成的工作分配给其他对象 多态 含义同面向对象的基本特性中的多态当相关的可选择的方法或行为随着类型变化时，将行为的职责分配给那些行为变化的类型典型编程应用:用多态的方法判断具体应该用哪个类，而不是用if来判断类该执行什么行为指导:尽量对抽象层编程 纯虚构 纯虚构与纯虚函数意思相近高内聚低耦合是系统设计的终极目标从某种角度看，内聚和耦合永远都是矛盾对立的高内聚要求拆分出更多的类，但对象之间需要更多的协作来完成任务，这又造成了高耦合，反之亦然。用纯虚构模式，由一个纯虚构的类来协调内聚和耦合，可以在一定程度上解决二者之间的矛盾 中介者 当多个类之间存在复杂的信息交互时，引入一个中介者类，把多个类之间的关联职责分配给它，从而降低类之间的耦合程度
备注：图片托管于github，请确保网络的可访问性
受保护变化 预先找出不稳定的变化点，使用统一的接口封装起来，如果未来发生变化的时候，可以通过接口扩展新的功能，而不需要去 修改原来旧的实现与OCP(开闭原则)类似，即一个软件实体应当对扩展开发，对修改关闭在设计一个模块的时候，要保证这个模块可以在不需要被修改 的前提下可以得到扩展通过扩展给系统提供了新的职责，以满足新的需求，同时又没有改变系统原来的功能 在迭代中使用GRASP 使用GRASP的根本原因是为了满足需求的变更敏捷方法通过快速的迭代来刺激变化，让变化及早暴露，再根据变化进行相应改动，并让这种改动遵循GRASP，力图使代码以及代码所表达的设计保持干净软件开发活动就是各种权衡:在简单与复杂之间权衡，在一种方案与另一种方案之间权衡不可能把每个问题、每个权衡的利弊都考虑清楚和全面 GRASP与设计模式 GRASP是学习使用设计模式的基础GRASP着重考虑设计类的原则及职责分配，比设计模式更重要设计模式是关于类和对象的一种高效、灵活的使用方式，是对面向对象的基本原则的多种良好的实现或经验的总结GoF设计模式提供具体的类结构，考虑设计的实现、类的交互和软件的质量GoF设计模式背后都遵循的就是永恒的设计原则和模式GoF设计模式就是符合GRASP模式要求的面向对象设计模式 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e74f02d029dc969ca9e1f0a26ac68a0e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-16T18:35:40+08:00" />
<meta property="article:modified_time" content="2020-06-16T18:35:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">软件工程笔记：通用职责分配模式(grasp)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="grasp_0"></a>通用职责分配模式(grasp)</h3> 
<p>— 笔记整理自 北京理工大学 计算机学院</p> 
<h4><a id="GRASP_5"></a>什么是GRASP?</h4> 
<ul><li>General Responsibility Assignment Software Patterns(通用职责分配软件模式)</li><li>GRASP包括4个基本模式和5个扩展模式，描述了对象设计和职责分配的基本原则</li><li>职责是一个类的契约或义务</li><li>“做”型职责是通过类的方法来实现的</li><li>“知道”型职责是通过类内部封装的属性以及类间关系来 体现</li><li>GRASP是如何设计一个面向对象系统的基础</li></ul> 
<h4><a id="GRASP9_14"></a>GRASP的9个模式</h4> 
<ul><li>专家 :应该将职责分配给信息专家(谁的数据谁负责)</li><li>创建者 :创建对象的职责(何时，由谁来创建和销毁)</li><li>低耦合 :类间的关系代表了类之间的耦合程度</li><li>高内聚 :一个类的职责之间的相关程度和集中程度</li><li>控制者 :把协调处理系统消息的职责分配给不同控制类</li><li>多态 :为不同的派生类分配具体的工作，具有相同接口</li><li>纯虚构 :非实体类，从其他类中抽取相关高内聚职责</li><li>中介者 :隔离藕合度过大的多个类，可能是虚构的</li><li>受保护变化:把易于变化部分封装起来便于扩展</li></ul> 
<h4><a id="_26"></a>信息专家</h4> 
<ul><li>Information Expert</li><li>信息专家模式是面向对象设计的最基本原则</li><li>如果某个类拥有完成某个职责所需要的所有信息，那么这个职责就应该分配给这个类来实现</li><li>示例:网上购物系统的购物车设计 
  <ul><li>需求:需要让每种商品只在购物车内出现一次，购买相同商品，只需要更新商品的数量即可</li><li>方案1:判断相同的职责与商品ID相关，它存在商品类中</li><li>方案2:商品类为实体类，商品ID相关职责太多，应分散</li></ul> </li></ul> 
<h4><a id="_36"></a>创建者</h4> 
<ul><li>尽可能少的建立对象之间的耦合和依赖关系</li><li>一般情况下，只在下列情况下才由类A来创建类B，即A是B的创建者: 
  <ul><li>1.A是B的聚合</li><li>2.A是B的容器</li><li>3.A持有初始化B的信息(数据)</li><li>4.A记录B的实例</li><li>5.A频繁使用B</li></ul> </li></ul> 
<h4><a id="_46"></a>低耦合</h4> 
<ul><li>低耦合降低了因一个类的变化而影响其他类的范围，而且让类更简单，更容易理解</li><li>造成类A、B之间耦合的情况: 
  <ul><li>A是B的属性</li><li>A调用B的实例的方法</li><li>A的方法中引用了B，包括B是A方法的返回值或参数</li><li>A是B的子类，或者A实现了B</li></ul> </li><li>遵循一些面向对象设计的基本原则可以降低类间耦合，如LoD，信息专家(职责迁移)，避免夸模块类之间的直接访问等</li></ul> 
<h4><a id="_56"></a>高内聚</h4> 
<ul><li>给类尽量分配内聚的职责，即功能性内聚的职责</li><li>功能性紧密相关的职责应该放在一个类里，并共同完成有限的功能</li><li>高内聚更有利于类的理解和重用，也便于类的维护</li><li>高内聚也是一种隔离</li></ul> 
<h4><a id="_63"></a>控制者</h4> 
<ul><li> <p>将处理系统事件消息的职责分派给代表下列事物的类:</p> 
  <ul><li>代表整个系统的类</li><li>代表整个企业或组织的类</li><li>代表真实世界中参与职责的主动对象类</li><li>代表一个用例中所有事件的人工处理者类</li></ul> </li><li> <p>控制者模式的相关原则:</p> 
  <ul><li>1.系统事件的接收与处理通常由一个高级控制者类来代替</li><li>2.一个子系统会有很多控制者类，分别处理不同的事务</li><li>3.控制者一般将需要完成的工作分配给其他对象</li></ul> </li></ul> 
<h4><a id="_76"></a>多态</h4> 
<ul><li>含义同面向对象的基本特性中的多态</li><li>当相关的可选择的方法或行为随着类型变化时，将行为的职责分配给那些行为变化的类型</li><li>典型编程应用:用多态的方法判断具体应该用哪个类，而不是用if来判断类该执行什么行为</li><li>指导:尽量对抽象层编程</li></ul> 
<h4><a id="_83"></a>纯虚构</h4> 
<ul><li>纯虚构与纯虚函数意思相近</li><li>高内聚低耦合是系统设计的终极目标</li><li>从某种角度看，内聚和耦合永远都是矛盾对立的</li><li>高内聚要求拆分出更多的类，但对象之间需要更多的协作来完成任务，这又造成了高耦合，反之亦然。</li><li>用纯虚构模式，由一个纯虚构的类来协调内聚和耦合，可以在一定程度上解决二者之间的矛盾</li></ul> 
<h4><a id="_91"></a>中介者</h4> 
<p>当多个类之间存在复杂的信息交互时，引入一个中介者类，把多个类之间的关联职责分配给它，从而降低类之间的耦合程度</p> 
<div align="center"> 
 <img width="800" src="https://images2.imgbox.com/37/29/qZC6Zbyc_o.jpg"> 
</div> 
<p>备注：图片托管于github，请确保网络的可访问性</p> 
<h4><a id="_101"></a>受保护变化</h4> 
<ul><li>预先找出不稳定的变化点，使用统一的接口封装起来，如果未来发生变化的时候，可以通过接口扩展新的功能，而不需要去 修改原来旧的实现</li><li>与OCP(开闭原则)类似，即一个软件实体应当对扩展开发，对修改关闭</li><li>在设计一个模块的时候，要保证这个模块可以在不需要被修改 的前提下可以得到扩展</li><li>通过扩展给系统提供了新的职责，以满足新的需求，同时又没有改变系统原来的功能</li></ul> 
<h4><a id="GRASP_108"></a>在迭代中使用GRASP</h4> 
<ul><li>使用GRASP的根本原因是为了满足需求的变更</li><li>敏捷方法通过快速的迭代来刺激变化，让变化及早暴露，再根据变化进行相应改动，并让这种改动遵循GRASP，力图使代码以及代码所表达的设计保持干净</li><li>软件开发活动就是各种权衡:在简单与复杂之间权衡，在一种方案与另一种方案之间权衡</li><li>不可能把每个问题、每个权衡的利弊都考虑清楚和全面</li></ul> 
<h4><a id="GRASP_115"></a>GRASP与设计模式</h4> 
<ul><li>GRASP是学习使用设计模式的基础</li><li>GRASP着重考虑设计类的原则及职责分配，比设计模式更重要</li><li>设计模式是关于类和对象的一种高效、灵活的使用方式，是对面向对象的基本原则的多种良好的实现或经验的总结</li><li>GoF设计模式提供具体的类结构，考虑设计的实现、类的交互和软件的质量</li><li>GoF设计模式背后都遵循的就是永恒的设计原则和模式</li><li>GoF设计模式就是符合GRASP模式要求的面向对象设计模式</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/13a8430bac3f69246b16fa2dba233a36/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Tensorflow官方Android demo运行步骤和遇到的问题总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a3bfe6c70cf91a9e44eb24e4a4c17048/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">灰色关联分析笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>