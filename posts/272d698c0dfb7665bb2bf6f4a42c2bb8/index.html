<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于TC和netem实现网络异常情况的模拟 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于TC和netem实现网络异常情况的模拟" />
<meta property="og:description" content="一、TC介绍
Linux内核内置了一个TC（Traffic Control）框架，可以实现流量限速，流量整形，策略应用(丢弃，NAT等)。原理大致如下图所示，主要是通过在输出端口处建立一个队列来实现流量控制：
报文分组从输入网卡(入口)接收进来，经过路由的查找，以确定是发给本机的，还是需要转发的。如果是发给本机的，就直接向上递交给上层的协议，比如TCP，如果是转发的，则会从输出网卡(出口)发出。网络流量的控制通常发生在输出网卡处。虽然在路由器的入口处也可以进行流量控制，Linux也具有相关的功能，但一般说来，由于我们无法控制自己网络之外的设备，入口处的流量控制相对较难，反之出口处的流量控制较为容易。
流量控制的一个基本概念是队列(Qdisc)，每个网卡都与一个队列(Qdisc)相联系，每当内核需要将报文分组从网卡发送出去，都会首先将该报文分组添加到该网卡所配置的队列中，由该队列决定报文分组的发送顺序，即所有的流量控制都发生在队列中。
有些队列的功能是非常简单的，它们对报文分组实行先来先走的策略。有些队列则功能复杂，会将不同的报文分组进行排队、分类，并根据不同的原则，以不同的顺序发送队列中的报文分组。为实现这样的功能，这些复杂的队列需要使用不同的过滤器(Filter)来把报文分组分成不同的类别(Class)。这里把这些复杂的队列称为可分类(ClassfuI)的队列。
通常， 要实现功能强大的流量控制，可分类的队列是必不可少的。因此，类别(class)和过滤器(Filter)也是流量控制的另外两个重要的基本概念。图2所示的是一个可分类队列的例子。
使用TC 在Linux中，流量控制都是通过TC这个工具来完成的。通常，要对网卡进行流量控制的配置，需要进行如下的步骤：
为网卡配置一个队列； 在该队列上建立分类； 根据需要建立子队列和子分类； 为每个分类建立过滤器。 具体命令参见https://blog.csdn.net/hexf9632/article/details/118568933
二、netem简介 netem是linux内核提供的Network emulation服务，可以用来模拟广域网下的延迟、丢包、重复、损坏和乱序等问题。2.6版本后的linux发行版都已经在内核中启用了netem，netem内核组件在以下情况下启用：
Networking --&gt; Networking Options --&gt; QoS and/or fair queuing --&gt; Network emulator 重要：netem 是直接添加到网卡上的，也就是说所有从网卡发送出去的包都会收到配置参数的影响！
假如需要回退到正常情况，请谨记下面这个命令：
删除 eth0网卡之前添加的netem配置 tc qdisc del dev eth0 root netem延迟设置
DELAY := delay TIME [ JITTER [ CORRELATION ]]] [ distribution { uniform | normal | pareto | paretonormal } ] TIME：延迟的时间
JITTER：抖动，增加一个随机时间长度，让延迟时间出现在某个范围
CORRELATION：相关，下一个报文延迟时间和上一个报文的相关系数
distribution：分布，延迟的分布模式，可以选择的值有 uniform、normal、pareto 和 paretonormal" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/272d698c0dfb7665bb2bf6f4a42c2bb8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-27T10:16:36+08:00" />
<meta property="article:modified_time" content="2021-12-27T10:16:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于TC和netem实现网络异常情况的模拟</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一、TC介绍</p> 
<p>Linux内核内置了一个TC（Traffic Control）框架，可以实现流量限速，流量整形，策略应用(丢弃，NAT等)。原理大致如下图所示，主要是通过在输出端口处建立一个队列来实现流量控制：</p> 
<p></p> 
<p><img alt="" height="133" src="https://images2.imgbox.com/4d/4f/OowN9vOx_o.png" width="450"></p> 
<p> </p> 
<p>报文分组从输入网卡(入口)接收进来，经过路由的查找，以确定是发给本机的，还是需要转发的。如果是发给本机的，就直接向上递交给上层的协议，比如TCP，如果是转发的，则会从输出网卡(出口)发出。网络流量的控制通常发生在输出网卡处。虽然在路由器的入口处也可以进行流量控制，Linux也具有相关的功能，但一般说来，由于我们无法控制自己网络之外的设备，入口处的流量控制相对较难，反之出口处的流量控制较为容易。</p> 
<p><img alt="" height="161" src="https://images2.imgbox.com/18/76/uhzgoC0H_o.png" width="483"></p> 
<p> </p> 
<p></p> 
<p>流量控制的一个基本概念是队列(Qdisc)，每个网卡都与一个队列(Qdisc)相联系，每当内核需要将报文分组从网卡发送出去，都会首先将该报文分组添加到该网卡所配置的队列中，由该队列决定报文分组的发送顺序，即所有的流量控制都发生在队列中。</p> 
<p>有些队列的功能是非常简单的，它们对报文分组实行先来先走的策略。有些队列则功能复杂，会将不同的报文分组进行排队、分类，并根据不同的原则，以不同的顺序发送队列中的报文分组。为实现这样的功能，这些复杂的队列需要使用不同的过滤器(Filter)来把报文分组分成不同的类别(Class)。这里把这些复杂的队列称为可分类(ClassfuI)的队列。</p> 
<p>通常， 要实现功能强大的流量控制，可分类的队列是必不可少的。因此，类别(class)和过滤器(Filter)也是流量控制的另外两个重要的基本概念。图2所示的是一个可分类队列的例子。</p> 
<p><img alt="" height="169" src="https://images2.imgbox.com/cc/38/AY5ehhOC_o.png" width="456"></p> 
<p> </p> 
<p></p> 
<h3>使用TC</h3> 
<p>在Linux中，流量控制都是通过TC这个工具来完成的。通常，要对网卡进行流量控制的配置，需要进行如下的步骤：</p> 
<ul><li>为网卡配置一个队列；</li></ul> 
<ul><li>在该队列上建立分类；</li></ul> 
<ul><li>根据需要建立子队列和子分类；</li></ul> 
<ul><li>为每个分类建立过滤器。</li></ul> 
<p>具体命令参见https://blog.csdn.net/hexf9632/article/details/118568933</p> 
<h2>二、netem简介</h2> 
<p>netem是linux内核提供的Network emulation服务，可以用来模拟广域网下的延迟、丢包、重复、损坏和乱序等问题。2.6版本后的linux发行版都已经在内核中启用了netem，netem内核组件在以下情况下启用：</p> 
<pre></pre> 
<p><code>Networking --&gt; </code></p> 
<p><code>Networking Options --&gt; </code></p> 
<p><code>QoS and/or fair queuing --&gt; </code></p> 
<p><code>Network emulator </code></p> 
<p>重要：netem 是直接添加到网卡上的，也就是说所有从网卡发送出去的包都会收到配置参数的影响！</p> 
<p>假如需要回退到正常情况，请谨记下面这个命令：</p> 
<h2>删除 eth0网卡之前添加的netem配置</h2> 
<pre></pre> 
<p><code>tc qdisc del dev eth0 root </code></p> 
<p>netem延迟设置</p> 
<pre></pre> 
<p><code>DELAY := delay TIME [ JITTER [ CORRELATION ]]] </code></p> 
<p><code>[ distribution { uniform | normal | pareto | paretonormal } ] </code></p> 
<p>TIME：延迟的时间</p> 
<p>JITTER：抖动，增加一个随机时间长度，让延迟时间出现在某个范围</p> 
<p>CORRELATION：相关，下一个报文延迟时间和上一个报文的相关系数</p> 
<p>distribution：分布，延迟的分布模式，可以选择的值有 uniform、normal、pareto 和 paretonormal</p> 
<pre></pre> 
<p><code># eth0 网卡延迟增加100ms </code></p> 
<p><code>tc qdisc add dev eth0 root netem delay 100ms </code></p> 
<p><code># 报文延迟的时间在 100ms ± 20ms 之间（90ms - 110ms） </code></p> 
<p><code>tc qdisc add dev eth0 root netem delay 100ms 20ms </code></p> 
<p><code># 因为网络状况是平滑变化的，短时间里相邻报文的延迟应该是近似的而不是完全随机的。这个值是个百分比，如果为 100%，就退化到固定延迟的情况；如果是 0% 则退化到随机延迟的情况 </code></p> 
<p><code>tc qdisc change dev eth0 root netem delay 100ms 20ms 50% </code></p> 
<p><code># distribution 参数来限制它的延迟分布模型。比如让报文延迟时间满足正态分布 </code></p> 
<p><code>tc qdisc change dev eth0 root netem delay 100ms 20ms distribution normal </code></p> 
<h3>netem模拟丢包设置</h3> 
<pre></pre> 
<p><code><em># 发送的报文有 50% 的丢包率</em> </code></p> 
<p><code>tc qdisc change dev eth0 root netem loss 50% </code></p> 
<p><code><em># 发送的报文有 0.3% ~ 25% 的丢包率</em> </code></p> 
<p><code>tc qdisc change dev eth0 root netem loss 0.3% 25% </code></p> 
<p>丢包也支持 state（4-state Markov 模型） 和 gemodel（Gilbert-Elliot 丢包模型） 两种模型的丢包配置。不过相对比较复杂，这里我们就不再详细描述。</p> 
<h3>netem模拟报文重复\损坏设置</h3> 
<pre></pre> 
<p><code># 随机产生 50% 重复的包 </code></p> 
<p><code>tc qdisc change dev eth0 root netem loss 50% </code></p> 
<p><code># 随机产生 2% 损坏的报文（在报文的随机位置造成一个比特的错误） </code></p> 
<p><code>tc qdisc change dev eth0 root netem corrupt 2% </code></p> 
<h3>netem模拟包乱序</h3> 
<p>网络传输并不能保证顺序，传输层 TCP 会对报文进行重组保证顺序，所以报文乱序对应用的影响比上面的几种问题要小。</p> 
<pre></pre> 
<p><code># 固定的每隔一定数量的报文就乱序一次 </code></p> 
<p><code>tc qdisc change dev eth0 root netem reorder 50% gap 3 delay 100ms </code></p> 
<p><code># 使用概率来选择乱序的报文 </code></p> 
<p><code>tc qdisc change dev eth0 root netem reorder 50% 15% delay 300ms </code></p> 
<p>参考：</p> 
<p>https://blog.csdn.net/u013128262/article/details/84784663</p> 
<p>https://blog.csdn.net/hexf9632/article/details/118568933</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aff14f8c16d6fdf278a4dfcd596d5449/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL：千万级数据删除导致的慢查询优化实践</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/76b26d629b729f2803b1aed2536b6d15/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">单例模式的N种实现方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>