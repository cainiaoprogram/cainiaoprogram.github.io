<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式系列之代理模式(Proxy) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式系列之代理模式(Proxy)" />
<meta property="og:description" content="概述： 代理模式，顾名思义就是一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。
代理，在显示生活中有很多代理的例子，比如我们可以在售票点买到火车站的火车票，售卖点就是铁路公司的代理，Windows电脑桌面的快捷方式就是应用软件启动程序的代理。
从上面的例子可以明白代理的意图就是代替原有的对象执行该对象的功能。
那么为什么需要代理呢？不能直接访问该对象的功能吗？
因为有时候我们直接访问该对象会比较麻烦，比如 我们买火车票总不能每次跑到几十公里外的火车站去买吧，家门口的售票点就能买到火车站的火车票，简单方便；我们打开软件，总不能打开文件资源管理器，根据安装目录一层层地找到应用启动程序文件（还得记住启动程序文件地路径），多麻烦呀，在桌面放一个代理这个启动程序文件，一键启动快捷方便。
特点： 优点：
职责清晰高扩展性智能化 缺点：
在客户端和被代理对象之间增加了一个代理对象 ，因此有些类型的代理模式可能会造成请求处理的速度变慢实现代理模式需要额外的工作，有些代理模式实现非常复杂 对比适配器模式和装饰器模式：
适配器模式主要改变所考虑对象的接口，代理模式则不能改变所代理的对象的接口装饰器模式主要为了增强功能，代理模式是为了加以控制 使用场景： 远程代理虚拟代理Copy-on-Write 代理保护（Protect or Access）代理Cache代理防火墙（Firewall）代理同步化（Synchronization）代理智能引用（Smart Reference）代理 实现方法： 现在我们有这样一个需求，我们需要加载一个图片返回给客户端进行展示，但是我们程序所在的这个服务器呢特别差，需要减少对象加载对内存的占用。
首先我们有一个图片展示的接口
public interface Image { void display(); } 然后有一个实际加载图片并实现该接口的RealImage类来实现实际的加载和展示
public class RealImage implements Image{ private String filename; public RealImage (String filename){ this.filename = filename; loadFromDisk(filename); } @Override public void display() { System.out.println(&#34;image display &#34;&#43; filename); } private void loadFromDisk(String filename){ // 这个方法特别占用内存 System.out.println(&#34;image loading from disk &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a7487ae4c3c891e612037f9b973f4512/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-23T16:51:59+08:00" />
<meta property="article:modified_time" content="2023-08-23T16:51:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式系列之代理模式(Proxy)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h5><a id="_0"></a>概述：</h5> 
<p>代理模式，顾名思义就是一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。<br> 代理，在显示生活中有很多代理的例子，比如我们可以在售票点买到火车站的火车票，售卖点就是铁路公司的代理，Windows电脑桌面的快捷方式就是应用软件启动程序的代理。<br> 从上面的例子可以明白代理的意图就是代替原有的对象执行该对象的功能。<br> 那么为什么需要代理呢？不能直接访问该对象的功能吗？<br> 因为有时候我们直接访问该对象会比较麻烦，比如 我们买火车票总不能每次跑到几十公里外的火车站去买吧，家门口的售票点就能买到火车站的火车票，简单方便；我们打开软件，总不能打开文件资源管理器，根据安装目录一层层地找到应用启动程序文件（还得记住启动程序文件地路径），多麻烦呀，在桌面放一个代理这个启动程序文件，一键启动快捷方便。</p> 
<h5><a id="_6"></a>特点：</h5> 
<p><strong>优点：</strong></p> 
<ol><li>职责清晰</li><li>高扩展性</li><li>智能化</li></ol> 
<p><strong>缺点：</strong></p> 
<ol><li>在客户端和被代理对象之间增加了一个代理对象 ，因此有些类型的代理模式可能会造成请求处理的速度变慢</li><li>实现代理模式需要额外的工作，有些代理模式实现非常复杂</li></ol> 
<p><strong>对比适配器模式和装饰器模式：</strong></p> 
<ul><li>适配器模式主要改变所考虑对象的接口，代理模式则不能改变所代理的对象的接口</li><li>装饰器模式主要为了增强功能，代理模式是为了加以控制</li></ul> 
<h5><a id="_22"></a>使用场景：</h5> 
<ol><li>远程代理</li><li>虚拟代理</li><li>Copy-on-Write 代理</li><li>保护（Protect or Access）代理</li><li>Cache代理</li><li>防火墙（Firewall）代理</li><li>同步化（Synchronization）代理</li><li>智能引用（Smart Reference）代理</li></ol> 
<h5><a id="_32"></a>实现方法：</h5> 
<p>现在我们有这样一个需求，我们需要加载一个图片返回给客户端进行展示，但是我们程序所在的这个服务器呢特别差，需要减少对象加载对内存的占用。<br> 首先我们有一个图片展示的接口</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Image</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>然后有一个实际加载图片并实现该接口的<code>RealImage</code>类来实现实际的加载和展示</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RealImage</span> <span class="token keyword">implements</span> <span class="token class-name">Image</span><span class="token punctuation">{<!-- --></span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> filename<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">RealImage</span> <span class="token punctuation">(</span><span class="token class-name">String</span> filename<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>filename <span class="token operator">=</span> filename<span class="token punctuation">;</span>
        <span class="token function">loadFromDisk</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"image display "</span><span class="token operator">+</span> filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">loadFromDisk</span><span class="token punctuation">(</span><span class="token class-name">String</span> filename<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 这个方法特别占用内存</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"image loading from disk "</span> <span class="token operator">+</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>然后我们为这个特别占用内存的类创建一个代理类<code>ImageProxy</code></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ImageProxy</span> <span class="token keyword">implements</span> <span class="token class-name">Image</span><span class="token punctuation">{<!-- --></span>

    <span class="token comment">// 代理对象</span>
    <span class="token keyword">private</span> <span class="token class-name">RealImage</span> realImage<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> filename<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">ImageProxy</span><span class="token punctuation">(</span><span class="token class-name">String</span> filename<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>filename <span class="token operator">=</span> filename<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>realImage <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            realImage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealImage</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        realImage<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这样客户端每次调用展示图片方法<code>display()</code>时通过代理类就不用每次去执行<code>loadFromDisk()</code>方法去加载图片了</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyTest</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Image</span> image <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ImageProxy</span><span class="token punctuation">(</span><span class="token string">"test.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        image<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        image<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>执行<code>main</code>方法，我们可以看到<code>loadFromDisk()</code>方法只被执行了一次</p> 
<pre><code class="prism language-java">image loading from disk test<span class="token punctuation">.</span>jpg
image display test<span class="token punctuation">.</span>jpg

image display test<span class="token punctuation">.</span>jpg
</code></pre> 
<h3><a id="_106"></a>欢迎关注我的公众号</h3> 
<p><img src="https://images2.imgbox.com/b0/2e/Nh3nenVl_o.png" alt=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6cef9cdbae03ae2827ad58eab5fb6b0f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">设计模式系列之装饰器模式(Decorator)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/61fed2f6e7b1caae6bf8a46bf4807845/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">利用免费WAF雷池社区版解决「爬虫占用网络带宽问题」</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>