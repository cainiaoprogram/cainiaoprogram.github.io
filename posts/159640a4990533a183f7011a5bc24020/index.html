<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法--排序算法效率比较 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法--排序算法效率比较" />
<meta property="og:description" content="《算法设计与分析》课程实验报告 （ 实验一）
实验名称：排序算法效率比较
实验地点：
所使用的开发工具及环境： PC机，DEV&#43;&#43;
一、实验目的：
比较至少 4 种排序（从小到大排）算法的执行效率。已学过的算法：冒泡排序、选择排序、插入排序、shell 排序，归并排序、快速排序等。 二、基本思想、原理和算法描述：
本次实验中使用到的冒泡排序、选择排序、插入排序、快速排序四种排序算法，它们的基本思想、原理和算法描述如下:
（1）冒泡排序：
重复遍历数组，每次遍历将当前最大的元素冒泡到最后。对于未排序部分，从数组首元素开始，依次比较相邻的两个元素。
（2）选择排序：
对于未排序部分，从数组首元素开始，逐个选择最小（或最大）的元素。将选出的最小（或最大）元素与未排序部分的首元素交换位置，将其放到已排序部分。重复上述步骤，直到全部排序完成。
（3）插入排序：
将数组分为已排序和未排序两部分，初始时已排序部分只包含一个元素（即数组的第一个元素）。从未排序部分选择一个元素，将它插入到已排序部分的正确位置，使已排序部分仍然有序。重复上述步骤，直到未排序部分为空。
（4）快速排序：
选择一个基准元素，一般选择数组的最后一个元素。将比基准小的元素移到左侧，比基准大的元素移到右侧。可以使用双指针或单指针的方式进行分区操作。对基准元素左右的两个分区分别进行递归快速排序。重复上述步骤，直到每个分区只包含一个元素或为空。
（5）归并排序：
分割：将待排序的数组分割为两个子数组，找到数组的中间位置 mid = (left &#43; right)/2，其中 left 表示数组的起始位置，right 表示数组的终止位置。
递归排序：对左右两个子数组分别递归调用归并排序函数 mergeSort，将其分割为更小的子数组，并进行排序。
合并：将排好序的左右两个子数组按照大小顺序合并到原始数组中。为此，需要创建一个临时数组 temp，用来存储合并后的结果。设置三个指针：i 指向左子数组的起始位置，j 指向右子数组的起始位置，k 指向临时数组的起始位置。比较左右两个子数组的元素大小，将较小的元素放入临时数组，并将指针向后移动。重复这个过程，直到其中一个子数组的元素全部放入临时数组。将剩余的子数组中的元素直接拷贝到临时数组中，最后将临时数组的元素复制回原始数组相应的位置。
三、实验内容。
1、随机产生 50000&#43;个数据，并保存至文件 test 中。
核心代码：
2、至少编写 4 种排序算法。
（1）冒泡排序：
（2）插入排序：
（3）选择排序：
（4）快速排序：
（5）归并排序：
3、调用步骤 2 中编写的程序，并从 test 中读取数据并排序，输出从读取到排好序，总共需要的时间。
4、结合时间复杂度，验证并分析几种排序算法的优劣。
（1）冒泡排序(Bubble Sort)的时间复杂度为O(n^2)。
（2）选择排序(Selection Sort)的时间复杂度也为O(n^2)。
（3）插入排序(Insertion Sort)的时间复杂度也为O(n^2)
（4）快速排序的平均时间复杂度为O(nlogn)。
（5）归并排序的平均时间复杂度为O(nlogn)。
在上述实验中测试的数据时间从大到小的排序是：选择&gt;插入&gt;冒泡&gt;快速&gt;归并。所以，综上所述，快速排序和归并排序不论是从时间复杂度来讲还是实际操作中所用的时间来说，都要比其他（实验中的的选择排序，插入排序，冒泡排序）算法来讲，都要好得多。
5、如果随机生成的数据是基本有序，或者是有序，或者是反序时，运行结果会怎么样？怎样解决这种问题，试提出你的解决方法。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/159640a4990533a183f7011a5bc24020/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-18T18:25:59+08:00" />
<meta property="article:modified_time" content="2023-10-18T18:25:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法--排序算法效率比较</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;text-align:center;"><strong><span style="color:#000000;">《算法设计与分析》课程实验报告 （ 实验一）</span></strong></p> 
<table border="1" cellspacing="0" style="margin-left:14.4pt;"><tbody><tr><td style="border-color:#000000;width:253.15pt;"> <p style="margin-left:0;text-align:justify;"><strong><span style="color:#000000;">实验名称</span></strong><span style="color:#000000;">：排序算法效率比较</span></p> </td><td style="border-color:#000000;width:158.55pt;"> <p style="margin-left:0;text-align:justify;"><strong><span style="color:#000000;">实验地点</span></strong><span style="color:#000000;">：</span></p> </td></tr><tr><td colspan="2" style="border-color:#000000;"> <p style="margin-left:0;text-align:justify;"><strong><span style="color:#000000;">所使用的开发工具及环境：</span><span style="color:#000000;">   PC</span></strong><strong><span style="color:#000000;">机，</span><span style="color:#000000;">DEV++</span></strong></p> </td></tr><tr><td colspan="2" style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;"><span style="color:#000000;"><strong>一、实验目的：</strong></span></p> <p style="margin-left:0;text-align:justify;"><span style="color:#000000;">比较至少</span><span style="color:#000000;"> 4 </span><span style="color:#000000;">种排序（从小到大排）算法的执行效率。已学过的算法：冒泡排序、选择排序、插入排序、</span><span style="color:#000000;">shell </span><span style="color:#000000;">排序，归并排序、快速排序等。</span>  </p> </td></tr><tr><td colspan="2" style="border-color:#000000;vertical-align:top;"> 
    <div> 
     <p style="margin-left:0;text-align:justify;"><strong><span style="color:#000000;">二、</span></strong><strong><span style="color:#000000;">基本思想、原理和算法描述：</span></strong></p> 
     <p style="margin-left:0;text-align:justify;"><span style="color:#000000;">本次实验中使用到的冒泡排序、选择排序、插入排序、快速排序四种排序算法，它们的基本思想、原理和算法描述如下:</span></p> 
     <p style="margin-left:0;text-align:justify;"><span style="color:#000000;">（1）冒泡排序：</span></p> 
     <p style="margin-left:0;text-align:justify;"><span style="color:#000000;">重复遍历数组，每次遍历将当前最大的元素冒泡到最后。对于未排序部分，从数组首元素开始，依次比较相邻的两个元素。</span></p> 
     <p style="margin-left:0;text-align:justify;"><span style="color:#000000;">（2）选择排序：</span></p> 
     <p style="margin-left:0;text-align:justify;"><span style="color:#000000;">对于未排序部分，从数组首元素开始，逐个选择最小（或最大）的元素。将选出的最小（或最大）元素与未排序部分的首元素交换位置，将其放到已排序部分。重复上述步骤，直到全部排序完成。</span></p> 
     <p style="margin-left:0;text-align:justify;"><span style="color:#000000;">（3）插入排序：</span></p> 
     <p style="margin-left:0;text-align:justify;"><span style="color:#000000;">将数组分为已排序和未排序两部分，初始时已排序部分只包含一个元素（即数组的第一个元素）。从未排序部分选择一个元素，将它插入到已排序部分的正确位置，使已排序部分仍然有序。重复上述步骤，直到未排序部分为空。</span></p> 
     <p style="margin-left:0;text-align:justify;"><span style="color:#000000;">（4）快速排序：</span></p> 
     <p style="margin-left:0;text-align:justify;"><span style="color:#000000;">选择一个基准元素，一般选择数组的最后一个元素。将比基准小的元素移到左侧，比基准大的元素移到右侧。可以使用双指针或单指针的方式进行分区操作。对基准元素左右的两个分区分别进行递归快速排序。重复上述步骤，直到每个分区只包含一个元素或为空。</span></p> 
     <p style="margin-left:0;text-align:justify;"><span style="color:#000000;">（5）归并排序：</span></p> 
     <p style="margin-left:0;text-align:justify;"><span style="color:#000000;">分割：将待排序的数组分割为两个子数组，找到数组的中间位置 mid = (left + right)/2，其中 left 表示数组的起始位置，right 表示数组的终止位置。</span></p> 
     <p style="margin-left:0;text-align:justify;"><span style="color:#000000;">递归排序：对左右两个子数组分别递归调用归并排序函数 mergeSort，将其分割为更小的子数组，并进行排序。</span></p> 
     <p style="margin-left:0;text-align:justify;"><span style="color:#000000;">合并：将排好序的左右两个子数组按照大小顺序合并到原始数组中。为此，需要创建一个临时数组 temp，用来存储合并后的结果。设置三个指针：i 指向左子数组的起始位置，j 指向右子数组的起始位置，k 指向临时数组的起始位置。比较左右两个子数组的元素大小，将较小的元素放入临时数组，并将指针向后移动。重复这个过程，直到其中一个子数组的元素全部放入临时数组。将剩余的子数组中的元素直接拷贝到临时数组中，最后将临时数组的元素复制回原始数组相应的位置。</span></p> 
    </div> </td></tr><tr><td colspan="2" style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:justify;"><strong><span style="color:#000000;">三、实验内容</span></strong><span style="color:#000000;">。</span></p> <p style="margin-left:0;text-align:justify;">1、随机产生 50000+个数据，并保存至文件 test 中。</p> <p style="margin-left:0;text-align:justify;">核心代码：</p> <p style="margin-left:0;text-align:justify;">2、至少编写 4 种排序算法。</p> <p style="margin-left:0;text-align:justify;">（1）冒泡排序：</p> <p style="margin-left:0;text-align:justify;"><img alt="" height="353" src="https://images2.imgbox.com/bf/d7/sMNPSp0m_o.png" width="693"></p> <p style="margin-left:0;text-align:justify;">（2）插入排序：</p> <p style="margin-left:0;text-align:justify;"><img alt="" height="328" src="https://images2.imgbox.com/22/39/6e5L9oKo_o.png" width="617"></p> <p style="margin-left:0;text-align:justify;">（3）选择排序：</p> <p style="margin-left:0;text-align:justify;"><img alt="" height="408" src="https://images2.imgbox.com/33/71/yvwfYrBM_o.png" width="569"></p> <p style="margin-left:0;text-align:justify;">（4）快速排序：</p> <p style="margin-left:0;text-align:justify;"><img alt="" height="819" src="https://images2.imgbox.com/71/6d/nUKyPHRp_o.png" width="665"></p> <p style="margin-left:0;text-align:justify;">（5）归并排序：</p> <p style="margin-left:0;text-align:justify;"><img alt="" height="526" src="https://images2.imgbox.com/38/59/5YuQ0yLG_o.png" width="1087"></p> <p style="margin-left:0;text-align:justify;"><img alt="" height="649" src="https://images2.imgbox.com/c1/97/FFGLqnVg_o.png" width="786"></p> <p style="margin-left:0;text-align:justify;">3、调用步骤 2 中编写的程序，并从 test 中读取数据并排序，输出从读取到排好序，总共需要的时间。</p> <p style="margin-left:0;text-align:justify;"><img alt="" height="212" src="https://images2.imgbox.com/68/cc/uhIBlo04_o.png" width="737"></p> <p style="margin-left:0;text-align:justify;"><img alt="" height="231" src="https://images2.imgbox.com/18/4a/wyyPCYHp_o.png" width="720"></p> <p style="margin-left:0;text-align:justify;"><img alt="" height="230" src="https://images2.imgbox.com/51/96/ZcMoi9yk_o.png" width="776"></p> <p style="margin-left:0;text-align:justify;"><img alt="" height="212" src="https://images2.imgbox.com/63/96/4MnaaDPB_o.png" width="710"></p> <p style="margin-left:0;text-align:justify;"><img alt="" height="189" src="https://images2.imgbox.com/6c/57/61VSmFf5_o.png" width="759"></p> <p style="margin-left:0;text-align:justify;"></p> <p style="margin-left:0;text-align:justify;">4、结合时间复杂度，验证并分析几种排序算法的优劣。</p> <p style="margin-left:0;text-align:justify;">（1）<span style="background-color:#FFFFFF;"><span style="color:#24292f;">冒泡排序</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">(Bubble Sort)</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">的时间复杂度为</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">O(n^2)</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">。</span></span></p> <p style="margin-left:0;text-align:justify;"><span style="background-color:#FFFFFF;"><span style="color:#24292f;">（</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">2</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">）选择排序</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">(Selection Sort)</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">的时间复杂度也为</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">O(n^2)</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">。</span></span></p> <p style="margin-left:0;text-align:justify;"><span style="background-color:#FFFFFF;"><span style="color:#24292f;">（</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">3</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">）插入排序</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">(Insertion Sort)</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">的时间复杂度也为</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">O(n^2)</span></span></p> <p style="margin-left:0;text-align:justify;"><span style="background-color:#FFFFFF;"><span style="color:#24292f;">（</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">4</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">）快速排序的平均时间复杂度为</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">O(nlogn)</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">。</span></span></p> <p style="margin-left:0;text-align:justify;"><span style="background-color:#FFFFFF;"><span style="color:#24292f;">（</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">5</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">）归并排序的平均时间复杂度为</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">O(nlogn)</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">。</span></span></p> <p style="margin-left:0;text-align:justify;">在上述实验中测试的数据时间从大到小的排序是：选择&gt;插入&gt;冒泡&gt;快速&gt;归并。所以，综上所述，快速排序和归并排序不论是从时间复杂度来讲还是实际操作中所用的时间来说，都要比其他（实验中的的选择排序，插入排序，冒泡排序）算法来讲，都要好得多。</p> <p style="margin-left:0;text-align:justify;">5、如果随机生成的数据是基本有序，或者是有序，或者是反序时，运行结果会怎么样？怎样解决这种问题，试提出你的解决方法。</p> <p style="margin-left:0;text-align:justify;"><span style="background-color:#FFFFFF;"><span style="color:#24292f;">冒泡排序、选择排序和插入排序的性能会受到较大影响，而快速排序在不同数据情况下的性能相对更为稳定。</span></span></p> <p style="margin-left:0;text-align:justify;"><span style="background-color:#FFFFFF;"><span style="color:#24292f;">归并排序在任何情况下都能保持稳定的</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">O(n log n)</span></span><span style="background-color:#FFFFFF;"><span style="color:#24292f;">时间复杂度，因此在基本有序、有序或反序的情况下，性能都相对稳定。</span></span></p> <p style="margin-left:0;text-align:justify;"><span style="background-color:#FFFFFF;"><span style="color:#24292f;">解决这种问题的方法之一是通过检测数据的有序程度，在数据已经有序或接近有序的情况下，采用更适合的排序算法以提升性能。</span></span></p> </td></tr><tr><td colspan="2" style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:justify;"><strong><span style="color:#000000;">四、程序运行结果分析。</span></strong></p> <p style="margin-left:0;text-align:justify;"><span style="color:#000000;">就之前的实验步骤中的操作来说，</span>选择&gt;插入&gt;冒泡&gt;快速&gt;归并是此次实验的结论，快速排序和归并排序不论是从时间复杂度来讲还是实际操作中所用的时间来说，都要比其他实验中的选择排序，插入排序，冒泡排序算法来讲，都要好得多，但是归并排序不会受数据顺序的影响，在所有情况下都很稳定。并且<span style="background-color:#FFFFFF;"><span style="color:#24292f;">冒泡排序、选择排序和插入排序的性能会受到较大影响，而快速排序在不同数据情况下的性能相对更为稳定。</span></span></p> <p style="margin-left:0;text-align:justify;"></p> <p style="margin-left:0;text-align:justify;"></p> <p style="margin-left:0;text-align:justify;"></p> </td></tr><tr><td colspan="2" style="border-color:#000000;vertical-align:top;"> <p style="margin-left:0;text-align:justify;"><strong><span style="color:#000000;">五、实验总结</span></strong></p> <p style="margin-left:0;text-align:justify;"><span style="color:#000000;">此次实验</span><span style="color:#000000;">比较至少</span><span style="color:#000000;"> 5 </span><span style="color:#000000;">种排序算法的执行效率，分别将冒泡排序、选择排序、插入排序、快速排、归并排序，五种算法进行比较。增强了我们的动手能力和编程能力，以及将算法进行实际应用的能力。</span></p> <p style="margin-left:0;text-align:justify;"></p> <p style="margin-left:0;text-align:justify;"></p> <p style="margin-left:0;text-align:justify;"></p> </td></tr></tbody></table> 
<p style="margin-left:0;text-align:justify;">                                        </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f3cb29c3310ddf529e811c1c30755ed1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">P1952 火星上的加法运算</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f521cf458887e00ce6b311dc340ea7c1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Aria2NG连接aria2-pro提示认证失败的处理办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>