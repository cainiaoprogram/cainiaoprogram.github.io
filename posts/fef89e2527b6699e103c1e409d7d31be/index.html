<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>zookeeper【封神录】下篇 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="zookeeper【封神录】下篇" />
<meta property="og:description" content="目录
🥞1.客户端API 🌭2.服务器动态上下线 🧂3.分布式锁 1.客户端API 1.1导入依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.14.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;version&gt;3.5.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 1.2代码实现 public class zkClient { //一定不要有空格 private String connectString = &#34;192.168.20.129:2181,192.168.20.130:2181,192.168.20.131:2181&#34;; private int sessionTimeOut = 2000; private ZooKeeper zkClient; /** * 初始话zookeeper * 参数1：连接地址 * 参数2：超时时间 * 参数3：监听器 */ @Before public void init() throws IOException { zkClient = new ZooKeeper(connectString, sessionTimeOut, new Watcher() { @Override public void process(WatchedEvent watchedEvent) { List&lt;String&gt; children = null; try { children = zkClient." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fef89e2527b6699e103c1e409d7d31be/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-04T19:30:16+08:00" />
<meta property="article:modified_time" content="2024-01-04T19:30:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">zookeeper【封神录】下篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><img alt="" class="left" height="626" src="https://images2.imgbox.com/8b/4f/TpVJFFit_o.png" width="1121"></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E5%AE%A2%E6%88%B7%E7%AB%AFAPI%C2%A0-toc" style="margin-left:0px;">🥞<a href="#1.%E5%AE%A2%E6%88%B7%E7%AB%AFAPI%C2%A0" rel="nofollow">1.客户端API </a></p> 
<p id="2.%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A8%E6%80%81%E4%B8%8A%E4%B8%8B%E7%BA%BF%C2%A0-toc" style="margin-left:0px;">🌭<a href="#2.%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A8%E6%80%81%E4%B8%8A%E4%B8%8B%E7%BA%BF%C2%A0" rel="nofollow">2.服务器动态上下线 </a><a href="#2.2%E6%9C%8D%E5%8A%A1%E7%AB%AF%C2%A0" rel="nofollow"> </a></p> 
<p id="3.%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%C2%A0-toc" style="margin-left:0px;">🧂<a href="#3.%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%C2%A0" rel="nofollow">3.分布式锁 </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E5%AE%A2%E6%88%B7%E7%AB%AFAPI%C2%A0" style="background-color:transparent;">1.客户端API </h2> 
<h3 id="1.1%E5%AF%BC%E5%85%A5%E4%BE%9D%E8%B5%96">1.1导入依赖</h3> 
<pre><code class="language-java">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;junit&lt;/groupId&gt;
            &lt;artifactId&gt;junit&lt;/artifactId&gt;
            &lt;version&gt;4.13.2&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;
            &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;
            &lt;version&gt;2.14.1&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;
            &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;
            &lt;version&gt;3.5.7&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</code></pre> 
<h3 id="1.2%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">1.2代码实现</h3> 
<pre><code class="language-java">public class zkClient {
    //一定不要有空格
    private String connectString = "192.168.20.129:2181,192.168.20.130:2181,192.168.20.131:2181";
    private int sessionTimeOut = 2000;
    private ZooKeeper zkClient;

    /**
     * 初始话zookeeper
     * 参数1：连接地址
     * 参数2：超时时间
     * 参数3：监听器
     */
    @Before
    public void init() throws IOException {
        zkClient = new ZooKeeper(connectString, sessionTimeOut, new Watcher() {
            @Override
            public void process(WatchedEvent watchedEvent) {
                List&lt;String&gt; children = null;
                try {
                    children = zkClient.getChildren("/", true);
                } catch (Exception e) {
                    e.printStackTrace();
                }
                System.out.println("========================");
                for (String child : children) {
                    System.out.println(child);
                }
                System.out.println("========================");
            }
        });
    }

    /**
     * 创建子节点
     * 参数1：创建节点的路径
     * 参数2：节点的数据（转化为字节）
     * 参数3：节点的权限
     * 参数4：节点的类型（临时/永久）
     **/
    @Test
    public void create() throws InterruptedException, KeeperException {
        String nodeCreate = zkClient.create("/class", "s1".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
    }

    /**
     * 监控子节点变化
     * 参数1：要监控的节点目录
     * 参数2：监听器（true:使用初始化是的监听器）
     */
    @Test
    public void getChildren() throws InterruptedException, KeeperException {
        List&lt;String&gt; children = zkClient.getChildren("/", true);
        for (String child : children) {
            System.out.println(child);
        }
        //延时
        Thread.sleep(Long.MAX_VALUE);
    }

    /**
     * 判断节点是否存在
     * 参数1：判断的节点路径
     * 参数：是否使用监听器
     */
    @Test
    public void isExist() throws InterruptedException, KeeperException {
        Stat stat = zkClient.exists("/class", false);
        System.out.println(stat == null ? "不存在" : "存在");
    }
}</code></pre> 
<h3 id="%C2%A01.3%E5%86%99%E6%95%B0%E6%8D%AE%E5%8E%9F%E7%90%86"> 1.3写数据原理</h3> 
<h4 id="1.%E5%86%99%E5%85%A5%E8%AF%B7%E6%B1%82%E7%9B%B4%E6%8E%A5%E5%8F%91%E9%80%81%E7%BB%99Leader">1.写入请求直接发送给Leader</h4> 
<blockquote> 
 <ul><li><strong>1.客户端发请求给Leader</strong></li><li><strong>2.leader执行请求并应答，然后把请求分发给下一个follower</strong></li><li><strong>3.follower会执行请求并应答。</strong></li><li><strong>4.当应答数超过半数，Leader就会回复客户端，完成了写请求</strong></li><li><strong>5.leader会继续发送写请求给剩下的follower</strong></li></ul> 
</blockquote> 
<p><img alt="" class="left" height="557" src="https://images2.imgbox.com/0b/ae/XGApwTlO_o.png" width="1052"></p> 
<h4 id="2.%E5%86%99%E5%85%A5%E8%AF%B7%E6%B1%82%E5%8F%91%E9%80%81%E7%BB%99Follower">2.写入请求发送给Follower</h4> 
<blockquote> 
 <ul><li><strong>1.客户端发请求给follower，follower没有写权限，立即把写请求发给leader</strong></li><li><strong>2.leader执行写请求并应答，然后把写请求分发给follower</strong></li><li><strong>3.follower会执行请求并应答。</strong></li><li><strong>4.当应答数超过半数，Leader回复follower，由follower回复客户端，完成了写请求</strong></li><li><strong>5.leader会继续发送写请求给剩下的follower</strong></li></ul> 
</blockquote> 
<h2 id="2.%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8A%A8%E6%80%81%E4%B8%8A%E4%B8%8B%E7%BA%BF%C2%A0">2.服务器动态上下线 </h2> 
<h3 id="2.1%E5%AE%A2%E6%88%B7%E7%AB%AF">2.1客户端</h3> 
<blockquote> 
 <ul><li><strong>1.获取zookeeper连接</strong></li><li><strong>2.监听节点的变化</strong></li><li><strong>3.业务逻辑（睡眠）</strong></li></ul> 
</blockquote> 
<pre><code class="language-java">public class DisClient {
    private String connectString = "192.168.20.129:2181,192.168.20.130:2181,192.168.20.131:2181";
    private int sessionTimeOut = 2000;
    private ZooKeeper zooKeeper;

    public static void main(String[] args) throws IOException, InterruptedException, KeeperException {
        DisClient client = new DisClient();
        //1.获取zk连接
        client.getConnect();
        //2.监听/servers下面的节点变化
        client.getServerList();
        //3.业务逻辑
        client.business();

    }

    private void business() throws InterruptedException {
        Thread.sleep(Long.MAX_VALUE);
    }

    /**
     * 监听服务端（获取节点信息）
     * @throws InterruptedException
     * @throws KeeperException
     */
    private void getServerList() throws InterruptedException, KeeperException {
        List&lt;String&gt; children = zooKeeper.getChildren("/servers", true);
        //服务器地址存放到集合中
        ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
        for (String child : children) {
            byte[] data = zooKeeper.getData("/servers/" + child, false, null);
            list.add(new String(data));
        }
        System.out.println(list);

    }

    /**
     * 初始话zookeeper
     * @throws IOException
     */
    private void getConnect() throws IOException {
        zooKeeper = new ZooKeeper(connectString, sessionTimeOut, new Watcher() {
            @Override
            public void process(WatchedEvent watchedEvent) {

                try {
                    getServerList();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (KeeperException e) {
                    e.printStackTrace();
                }
            }
        });
    }
}</code></pre> 
<h3 id="2.2%E6%9C%8D%E5%8A%A1%E7%AB%AF%C2%A0">2.2服务端 </h3> 
<blockquote> 
 <ul><li><strong>1.获取zookeeper连接</strong></li><li><strong>2.创建节点（服务端注册到zookeeper）</strong></li><li><strong>3.业务逻辑（睡眠）</strong></li></ul> 
</blockquote> 
<pre><code class="language-java">/**
 * 服务端注册zookeeper
 */
public class DisServer {
    private String connectString = "192.168.20.129:2181,192.168.20.130:2181,192.168.20.131:2181";
    private int sessionTimeOut = 2000;
    private ZooKeeper zooKeeper;

    public static void main(String[] args) throws Exception {
        DisServer dIsServer = new DisServer();
        //1.获取zk连接
        dIsServer.getConnect();
        //2.注册服务器到zk节点（创建节点）
        dIsServer.register(args[0]);
        //3.启动业务逻辑
        dIsServer.business();
    }

    private void business() throws InterruptedException {
        Thread.sleep(Long.MAX_VALUE);
    }

    /**
     * 注册服务器（创建节点）
     * @param hostname
     * @throws InterruptedException
     * @throws KeeperException
     */
    private void register(String hostname) throws InterruptedException, KeeperException {
        String create = zooKeeper.create("/servers/"+hostname, hostname.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);
        System.out.println(hostname + "已经上线");
    }


    /**
     * 初始化zookeeper
     * @throws IOException
     */
    private void getConnect() throws IOException {
        zooKeeper = new ZooKeeper(connectString, sessionTimeOut, new Watcher() {
            @Override
            public void process(WatchedEvent watchedEvent) {

            }
        });
    }
}</code></pre> 
<h2 id="3.%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%C2%A0">3.分布式锁 </h2> 
<blockquote> 
 <p><span style="color:#0d0016;"><strong>Zookeeper的分布式锁实现基于其znode（zk节点）功能。每个znode都可以有数据和子节点，并且每个znode都有一个版本号。Zookeeper的分布式锁利用了znode的版本号特性，同时使用watcher机制实现分布式锁的互斥</strong></span></p> 
</blockquote> 
<h3 id="3.1%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">3.1执行流程</h3> 
<blockquote> 
 <ol><li><span style="color:#0d0016;"><strong>当一个客户端需要获取锁时，它会在Zookeeper上创建一个</strong></span><span style="color:#fe2c24;"><strong>临时且有序</strong></span><span style="color:#0d0016;"><strong>的znode节点。</strong></span></li><li><span style="color:#0d0016;"><strong>客户端通过获取Zookeeper上的znode列表，并判断自己创建的节点是否是所有节点中最小的那个，如果是，则表示客户端获得了锁。</strong></span></li><li><span style="color:#0d0016;"><strong>如果客户端没有获得锁，则监听它前面（比它序号小的）的节点，等待锁的释放。</strong></span></li><li><span style="color:#0d0016;"><strong>当客户端释放锁时，它会删除自己创建的znode节点，此时，Zookeeper会通知正在等待前面的节点上的watcher机制，让等待锁的客户端尝试重新获取锁</strong></span></li></ol> 
</blockquote> 
<h3 id="3.2%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">3.2代码实现</h3> 
<pre><code class="language-java">/**
 * 分布式锁
 */
public class ZkLock {
    private final String connectString = "192.168.20.129:2181,192.168.20.130:2181,192.168.20.131:2181";
    private final int sessionTimeOut = 2000;
    private final ZooKeeper zooKeeper;
    private String path;

    private CountDownLatch countDownLatch = new CountDownLatch(1);
    private CountDownLatch countPathLatch = new CountDownLatch(1);
    private String currentNode;

    //构造器初始化
    public ZkLock() throws IOException, InterruptedException, KeeperException {
        //1.获取链接
        zooKeeper = new ZooKeeper(connectString, sessionTimeOut, new Watcher() {
            @Override
            public void process(WatchedEvent watchedEvent) {
                //countDownLatch 连接上zookeeper，释放
                if (watchedEvent.getState() == Event.KeeperState.SyncConnected) {
                    countDownLatch.countDown();
                }
                //countPathLatch 释放
                if (watchedEvent.getType() == Event.EventType.NodeDeleted &amp;&amp; watchedEvent.getPath().equals(path)) {
                    countPathLatch.countDown();

                }
            }
        });
        //等待zookeeper正常连接后，往下执行程序
        countDownLatch.await();

        //2.判断根节点locks是否存在
        Stat stat = zooKeeper.exists("/locks", false);
        if (stat == null) {
            //说明不存在，创建根节点
            zooKeeper.create("/locks", "locks".getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);
        }

    }


    //3.加锁
    public void zkLock() {
        //创建对应的临时带序号的节点
        try {
            currentNode = zooKeeper.create("/locks/" + "seq-", null, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);

            //判断创建的节点是否是最小的序号节点，如果是，获取到锁，如果不是，监听他前一个结点
            List&lt;String&gt; children = zooKeeper.getChildren("/locks", false);

            //如果只有一个值，直接获取锁，如果不是，则判断
            if (children.size() == 1) {
                //直接枷锁
                return;
            } else {
                //对节点进行排序
                Collections.sort(children);
                //获取节点名称
                String thisNode = currentNode.substring("/locks/".length());
                //通过界节点名称，获取在集合中的下标
                int index = children.indexOf(thisNode);

                //判断下标
                if (index == -1) {
                    System.out.println("数据异常");
                } else if (index == 0) {//第一个数据
                    //直接枷锁
                    return;
                } else {//说明多个节点，进行监听前一个节点
                    path = "/locks/" + children.get(index - 1);
                    zooKeeper.getData(path, true, new Stat());
                    //等待监听
                    countPathLatch.await();
                    return;
                }
            }
        } catch (KeeperException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    //4.解锁
    public void unZkLock() {
        //删除节点
        try {
            zooKeeper.delete(currentNode, -1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (KeeperException e) {
            e.printStackTrace();
        }
    }
}</code></pre> 
<h3 id="3.3%E7%BA%BF%E7%A8%8B%E6%B5%8B%E8%AF%95%C2%A0">3.3线程测试 </h3> 
<pre><code class="language-java">public class ZkLockTest {
    public static void main(String[] args) throws IOException, InterruptedException, KeeperException {
        ZkLock zkLock1 = new ZkLock();
        ZkLock zkLock2 = new ZkLock();
        ZkLock zkLock3 = new ZkLock();

        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    zkLock1.zkLock();
                    System.out.println("线程1，获取到锁");
                    Thread.sleep(3 * 1000);
                    zkLock1.unZkLock();
                    System.out.println("线程1，释放锁");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    zkLock2.zkLock();
                    System.out.println("线程2，获取到锁");
                    Thread.sleep(3 * 1000);
                    zkLock2.unZkLock();
                    System.out.println("线程2，释放锁");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    zkLock3.zkLock();
                    System.out.println("线程3，获取到锁");
                    Thread.sleep(3 * 1000);
                    zkLock3.unZkLock();
                    System.out.println("线程3，释放锁");
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }
}</code></pre> 
<h2>4.Curator框架 </h2> 
<blockquote> 
 <p><strong><span style="color:#0d0016;">Curator是Apache ZooKeeper的一个</span><span style="color:#fe2c24;">高级客户端库</span><span style="color:#0d0016;">，旨在使开发人员更容易编写可靠的分布式系统。它为ZooKeeper提供了许多有用的功能，包括</span><span style="color:#4da8ee;">连接管理</span><span style="color:#0d0016;">，</span><span style="color:#4da8ee;">分布式锁</span><span style="color:#0d0016;">和</span><span style="color:#4da8ee;">选举</span><span style="color:#0d0016;">，</span><span style="color:#4da8ee;">缓存</span><span style="color:#0d0016;">和</span><span style="color:#4da8ee;">观察</span><span style="color:#0d0016;">。Curator还提供了一组易于使用的API，可以轻松管理ZooKeeper的节点和数据。</span></strong></p> 
</blockquote> 
<h3>4.1添加依赖</h3> 
<pre><code class="language-java">        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-framework&lt;/artifactId&gt;
            &lt;version&gt;5.5.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-client&lt;/artifactId&gt;
            &lt;version&gt;5.5.0&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.curator&lt;/groupId&gt;
            &lt;artifactId&gt;curator-recipes&lt;/artifactId&gt;
            &lt;version&gt;5.5.0&lt;/version&gt;
        &lt;/dependency&gt;</code></pre> 
<h3>4.2代码实现</h3> 
<pre><code class="language-java">    /**
     * 客户端连接
     * @return
     */
    private static CuratorFramework getCuratorFramework() {

        //创建zookeeper的客户端:重试策略，初始化每次重试之间需要等待的时间，基准等待时间为3秒
        ExponentialBackoffRetry policy = new ExponentialBackoffRetry(3000, 3);

        CuratorFramework client = CuratorFrameworkFactory.builder().connectString("192.168.20.129:2181,192.168.20.131:2181,192.168.20.130:2181")
                .connectionTimeoutMs(2000)
                .sessionTimeoutMs(2000)
                .retryPolicy(policy).build();
        client.start();
        System.out.println("zookeeper启动~");
        return client;
    }</code></pre> 
<h3 style="background-color:transparent;">4.3创建线程测试</h3> 
<pre><code class="language-java">InterProcessMutex lock1 = new InterProcessMutex(getCuratorFramework(), "/locks");
        InterProcessMutex lock2 = new InterProcessMutex(getCuratorFramework(), "/locks");
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    lock1.acquire();
                    System.out.println("线程一获取到锁");
                    Thread.sleep(3000);
                    lock1.release();
                    System.out.println("线程一释放锁");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                try {
                    lock2.acquire();
                    System.out.println("线程二获取到锁");
                    Thread.sleep(3000);
                    lock2.release();
                    System.out.println("线程二释放锁");
                } catch (Exception e) {
                    e.printStackTrace();
                }
            }
        }).start();
    }</code></pre> 
<p><img alt="" class="left" height="300" src="https://images2.imgbox.com/37/0d/kvzAlZ3X_o.gif" width="300"><img alt="" class="left" height="300" src="https://images2.imgbox.com/51/25/5pkgowN7_o.gif" width="300"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e98aade5d86a970b1720f022dc66e72e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">9.java——（杂例）组合，代理，向上转型static,fianl,关键字（有道云笔记复制粘贴，大家整体性的把握）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fc56406c1f4aa40b865fe604084ad67b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Everything结合内网穿透搭建在线资料库并实现随时随地远程访问</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>