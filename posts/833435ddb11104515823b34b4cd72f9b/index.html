<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>是什么让Lisp宏如此特别？ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="是什么让Lisp宏如此特别？" />
<meta property="og:description" content="本文翻译自：What makes Lisp macros so special?
Reading Paul Graham&#39;s essays on programming languages one would think that Lisp macros are the only way to go. 阅读Paul Graham关于编程语言的论文 ，人们会认为Lisp宏是唯一可行的方法。 As a busy developer, working on other platforms, I have not had the privilege of using Lisp macros. 作为一个忙于开发人员，在其他平台上工作，我没有使用Lisp宏的特权。 As someone who wants to understand the buzz, please explain what makes this feature so powerful. 作为想要了解嗡嗡声的人，请解释是什么让这个功能如此强大。 Please also relate this to something I would understand from the worlds of Python, Java, C# or C development." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/833435ddb11104515823b34b4cd72f9b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-20T17:33:12+08:00" />
<meta property="article:modified_time" content="2020-08-20T17:33:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">是什么让Lisp宏如此特别？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本文翻译自：<a href="https://oldbug.net/q/17Gm/What-makes-Lisp-macros-so-special" rel="nofollow">What makes Lisp macros so special?</a></p> 
<p> <i>Reading <a href="http://www.paulgraham.com/articles.html" rel="nofollow">Paul Graham's essays</a> on programming languages one would think that <a href="http://wiki.c2.com/?LispMacro" rel="nofollow">Lisp macros</a> are the only way to go.</i> <b>阅读<a href="http://www.paulgraham.com/articles.html" rel="nofollow">Paul Graham</a>关于编程语言<a href="http://www.paulgraham.com/articles.html" rel="nofollow">的论文</a> ，人们会认为<a href="http://wiki.c2.com/?LispMacro" rel="nofollow">Lisp宏</a>是唯一<a href="http://wiki.c2.com/?LispMacro" rel="nofollow">可行</a>的方法。</b> <i>As a busy developer, working on other platforms, I have not had the privilege of using Lisp macros.</i> <b>作为一个忙于开发人员，在其他平台上工作，我没有使用Lisp宏的特权。</b> <i>As someone who wants to understand the buzz, please explain what makes this feature so powerful.</i> <b>作为想要了解嗡嗡声的人，请解释是什么让这个功能如此强大。</b> </p> 
<p> <i>Please also relate this to something I would understand from the worlds of Python, Java, C# or C development.</i> <b>还请将此与我从Python，Java，C＃或C开发世界中理解的内容联系起来。</b> </p> 
<hr> 
<h4>#1楼</h4> 
<p>参考：<a href="https://stackoom.com/question/17Gm/%E6%98%AF%E4%BB%80%E4%B9%88%E8%AE%A9Lisp%E5%AE%8F%E5%A6%82%E6%AD%A4%E7%89%B9%E5%88%AB" rel="nofollow">https://stackoom.com/question/17Gm/是什么让Lisp宏如此特别</a></p> 
<hr> 
<h4>#2楼</h4> 
<p> <i>I got this from The common lisp cookbook but I think it explained why lisp macros are good in a nice way.</i> <b>我从普通的lisp食谱中得到了这个，但我认为它解释了为什么lisp宏好的方式。</b> </p> 
<p> <i>"A macro is an ordinary piece of Lisp code that operates on another piece of putative Lisp code, translating it into (a version closer to) executable Lisp. That may sound a bit complicated, so let's give a simple example. Suppose you want a version of setq that sets two variables to the same value. So if you write</i> <b>“宏是一段普通的Lisp代码，它运行在另一个推定的Lisp代码上，将其转换为（更接近于可执行Lisp的版本）。这可能听起来有点复杂，所以让我们举一个简单的例子。假设你想要一个setq的两个版本将两个变量设置为相同的值。所以如果你写的话</b> </p> 
<pre><code>(setq2 x y (+ z 3))
</code></pre> 
<p> <i>when <code>z=8</code> both x and y are set to 11. (I can't think of any use for this, but it's just an example.)</i> <b>当<code>z=8</code> ，x和y都设置为11.（我想不出任何用途，但这只是一个例子。）</b> </p> 
<p> <i>It should be obvious that we can't define setq2 as a function.</i> <b>很明显，我们不能将setq2定义为函数。</b> <i>If <code>x=50</code> and <code>y=-5</code> , this function would receive the values 50, -5, and 11;</i> <b>如果<code>x=50</code>且<code>y=-5</code> ，则该函数将接收值50，-5和11;</b> <i>it would have no knowledge of what variables were supposed to be set.</i> <b>它不知道应该设置哪些变量。</b> <i>What we really want to say is, When you (the Lisp system) see <code>(setq2 v1 v2 e)</code> , treat it as equivalent to <code>(progn (setq v1 e) (setq v2 e))</code> .</i> <b>我们真正想说的是，当你（Lisp系统）看到<code>(setq2 v1 v2 e)</code> ，将它视为等同于<code>(progn (setq v1 e) (setq v2 e))</code> 。</b> <i>Actually, this isn't quite right, but it will do for now.</i> <b>实际上，这不太对，但它现在会做。</b> <i>A macro allows us to do precisely this, by specifying a program for transforming the input pattern <code>(setq2 v1 v2 e)</code> " into the output pattern <code>(progn ...)</code> ."</i> <b>宏允许我们通过指定用于将输入模式<code>(setq2 v1 v2 e)</code>转换为输出模式<code>(progn ...)</code> 。</b> </p> 
<p> <i>If you thought this was nice you can keep on reading here: <a href="http://cl-cookbook.sourceforge.net/macros.html" rel="nofollow">http://cl-cookbook.sourceforge.net/macros.html</a></i> <b>如果您认为这很好，您可以继续阅读： <a href="http://cl-cookbook.sourceforge.net/macros.html" rel="nofollow">http</a> ： <a href="http://cl-cookbook.sourceforge.net/macros.html" rel="nofollow">//cl-cookbook.sourceforge.net/macros.html</a></b> </p> 
<hr> 
<h4>#3楼</h4> 
<p> <i>Since the existing answers give good concrete examples explaining what macros achieve and how, perhaps it'd help to collect together some of the thoughts on why the macro facility is a significant gain <em>in relation to other languages</em> ;</i> <b>既然现有的答案提供了很好的具体例子来解释宏实现了什么以及如何实现，也许它有助于汇集一些关于为什么宏观设施<em>相对于其他语言</em>获得显着收益的想法;</b> <i>first from these answers, then a great one from elsewhere:</i> <b>首先来自这些答案，然后是来自其他地方的伟大答案：</b> </p> 
<blockquote> 
 <p> <i>... in C, you would have to write a custom pre-processor [which would probably qualify as a <a href="https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule" rel="nofollow">sufficiently complicated C program</a> ] ...</i> <b>...在C中，你必须编写一个自定义的预处理器[这可能有资格作为一个<a href="https://en.wikipedia.org/wiki/Greenspun%27s_tenth_rule" rel="nofollow">足够复杂的C程序</a> ] ......</b> </p> 
</blockquote> 
<p> <i>— <a href="https://stackoverflow.com/a/268091/1234179" rel="nofollow">Vatine</a></i> <b>- <a href="https://stackoverflow.com/a/268091/1234179" rel="nofollow">Vatine</a></b> </p> 
<blockquote> 
 <p> <i>Talk to anyone that's mastered C++ and ask them how long they spent learning all the template fudgery they need to do template metaprogramming [which is still not as powerful].</i> <b>与任何掌握了C ++的人交谈，并询问他们花了多长时间学习模板元编程所需的模板所有模板[这仍然没有那么强大]。</b> </p> 
</blockquote> 
<p> <i>— <a href="https://stackoverflow.com/a/268360/1234179" rel="nofollow">Matt Curtis</a></i> <b>- <a href="https://stackoverflow.com/a/268360/1234179" rel="nofollow">马特柯蒂斯</a></b> </p> 
<blockquote> 
 <p> <i>... in Java you have to hack your way with bytecode weaving, although some frameworks like AspectJ allows you to do this using a different approach, it's fundamentally a hack.</i> <b>...在Java中你必须使用字节码编织来破解你的方式，尽管像AspectJ这样的一些框架允许你使用不同的方法来实现这一点，但它从根本上说是一个黑客攻击。</b> </p> 
</blockquote> 
<p> <i>— <a href="https://stackoverflow.com/a/268451/1234179" rel="nofollow">Miguel Ping</a></i> <b>- <a href="https://stackoverflow.com/a/268451/1234179" rel="nofollow">米格尔·平</a></b> </p> 
<blockquote> 
 <p> <i>DOLIST is similar to Perl's foreach or Python's for.</i> <b>DOLIST类似于Perl的foreach或Python的。</b> <i>Java added a similar kind of loop construct with the "enhanced" for loop in Java 1.5, as part of JSR-201.</i> <b>作为JSR-201的一部分，Java在Java 1.5中添加了类似的循环结构和“增强”for循环。</b> <i>Notice what a difference macros make.</i> <b>注意宏有什么区别。</b> <i>A Lisp programmer who notices a common pattern in their code can write a macro to give themselves a source-level abstraction of that pattern.</i> <b>一个Lisp程序员在他们的代码中注意到一个共同的模式，可以编写一个宏来给自己提供该模式的源级抽象。</b> <i>A Java programmer who notices the same pattern has to convince Sun that this particular abstraction is worth adding to the language.</i> <b>注意到相同模式的Java程序员必须说服Sun，这种特殊的抽象值得添加到该语言中。</b> <i>Then Sun has to publish a JSR and convene an industry-wide "expert group" to hash everything out.</i> <b>然后Sun必须发布一个JSR并召集一个行业范围的“专家组”来解决所有问题。</b> <i>That process--according to Sun--takes an average of 18 months.</i> <b>根据Sun的说法，这个过程平均需要18个月。</b> <i>After that, the compiler writers all have to go upgrade their compilers to support the new feature.</i> <b>之后，编译器编写者都必须升级他们的编译器以支持新功能。</b> <i>And even once the Java programmer's favorite compiler supports the new version of Java, they probably ''still'' can't use the new feature until they're allowed to break source compatibility with older versions of Java.</i> <b>甚至一旦Java程序员最喜欢的编译器支持新版本的Java，他们可能“仍然”不能使用新功能，直到它们被允许破坏与旧版Java的源兼容性。</b> <i>So an annoyance that Common Lisp programmers can resolve for themselves within five minutes plagues Java programmers for years.</i> <b>因此，Common Lisp程序员可以在五分钟内自行解决的烦恼困扰着Java程序员多年。</b> </p> 
</blockquote> 
<p> <i>— <a href="http://www.gigamonkeys.com/book/macros-standard-control-constructs.html" rel="nofollow">Peter Seibel, in "Practical Common Lisp"</a></i> <b>- <a href="http://www.gigamonkeys.com/book/macros-standard-control-constructs.html" rel="nofollow">Peter Seibel，“Practical Common Lisp”</a></b> </p> 
<hr> 
<h4>#4楼</h4> 
<p> <i>You will find a comprehensive debate around <a href="http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html" rel="nofollow">lisp macro here</a> .</i> <b>你会在<a href="http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html" rel="nofollow">这里</a>找到关于<a href="http://lists.warhead.org.uk/pipermail/iwe/2005-July/000130.html" rel="nofollow">lisp宏</a>的全面辩论。</b> </p> 
<p> <i>An interesting subset of that article:</i> <b>该文章的一个有趣的子集：</b> </p> 
<blockquote> 
 <p> <i>In most programming languages, syntax is complex.</i> <b>在大多数编程语言中，语法很复杂。</b> <i>Macros have to take apart program syntax, analyze it, and reassemble it.</i> <b>宏必须拆分程序语法，分析它并重新组装它。</b> <i>They do not have access to the program's parser, so they have to depend on heuristics and best-guesses.</i> <b>他们无法访问程序的解析器，因此他们必须依赖于启发式和最佳猜测。</b> <i>Sometimes their cut-rate analysis is wrong, and then they break.</i> <b>有时他们的降价分析是错误的，然后他们就会破裂。</b> </p> 
 <p> <i>But Lisp is different.</i> <b>但是Lisp是不同的。</b> <i>Lisp macros <em>do</em> have access to the parser, and it is a really simple parser.</i> <b>Lisp的宏<em>做</em>访问解析器，这是一个非常简单的解析器。</b> <i><strong>A Lisp macro is not handed a string, but a preparsed piece of source code in the form of a list, because the source of a Lisp program is not a string;</strong></i> <b><strong>Lisp宏不是一个字符串，而是一个列表形式的预处理源代码，因为Lisp程序的源不是字符串;</strong></b> <i><strong>it is a list.</strong></i> <b><strong>这是一个清单。</strong></b> <i>And Lisp programs are really good at taking apart lists and putting them back together.</i> <b>Lisp程序非常擅长拆分列表并将它们重新组合在一起。</b> <i>They do this reliably, every day.</i> <b>他们每天都可靠地做到这一点。</b> </p> 
 <p> <i>Here is an extended example.</i> <b>这是一个扩展的例子。</b> <i>Lisp has a macro, called "setf", that performs assignment.</i> <b>Lisp有一个名为“setf”的宏，它执行赋值。</b> <i>The simplest form of setf is</i> <b>最简单的setf形式是</b> </p> 
 <pre> <code> (setf x whatever)</code> </pre> 
 <p> <i>which sets the value of the symbol "x" to the value of the expression "whatever".</i> <b>它将符号“x”的值设置为表达式“whatever”的值。</b> </p> 
 <p> <i>Lisp also has lists;</i> <b>Lisp也有名单;</b> <i>you can use the "car" and "cdr" functions to get the first element of a list or the rest of the list, respectively.</i> <b>您可以使用“car”和“cdr”函数分别获取列表的第一个元素或列表的其余部分。</b> </p> 
 <p> <i>Now what if you want to replace the first element of a list with a new value?</i> <b>现在，如果您想用新值替换列表的第一个元素，该怎么办？</b> <i>There is a standard function for doing that, and incredibly, its name is even worse than "car".</i> <b>这样做有一个标准功能，令人难以置信的是，它的名字甚至比“汽车”更糟糕。</b> <i>It is "rplaca".</i> <b>这是“rplaca”。</b> <i>But you do not have to remember "rplaca", because you can write</i> <b>但你不必记住“rplaca”，因为你可以写</b> </p> 
 <pre> <code> (setf (car somelist) whatever)</code> </pre> 
 <p> <i>to set the car of somelist.</i> <b>设置某人的车。</b> </p> 
 <p> <i>What is really happening here is that "setf" is a macro.</i> <b>这里真正发生的是“setf”是一个宏。</b> <i>At compile time, it examines its arguments, and it sees that the first one has the form (car SOMETHING).</i> <b>在编译时，它检查它的参数，并且它看到第一个具有形式（汽车SOMETHING）。</b> <i>It says to itself "Oh, the programmer is trying to set the car of somthing. The function to use for that is 'rplaca'."</i> <b>它对自己说“哦，程序员正试图设置汽车的东西。用于此的功能是'rplaca'。”</b> <i>And it quietly rewrites the code in place to:</i> <b>它悄悄地将代码重写为：</b> </p> 
 <pre> <code> (rplaca somelist whatever)</code> </pre> 
</blockquote> 
<hr> 
<h4>#5楼</h4> 
<p> <i>Lisp macros allow you to decide when (if at all) any part or expression will be evaluated.</i> <b>Lisp宏允许您决定何时（如果有的话）将评估任何部分或表达式。</b> <i>To put a simple example, think of C's:</i> <b>举一个简单的例子，想想C：</b> </p> 
<pre><code>expr1 &amp;&amp; expr2 &amp;&amp; expr3 ...
</code></pre> 
<p> <i>What this says is: Evaluate <code>expr1</code> , and, should it be true, evaluate <code>expr2</code> , etc.</i> <b>这就是：评估<code>expr1</code> ，如果它是真的，评估<code>expr2</code>等。</b> </p> 
<p> <i>Now try to make this <code>&amp;&amp;</code> into a function... thats right, you can't.</i> <b>现在尝试将此<code>&amp;&amp;</code>变成一个函数......这是正确的，你不能。</b> <i>Calling something like:</i> <b>打电话给：</b> </p> 
<pre><code>and(expr1, expr2, expr3)
</code></pre> 
<p> <i>Will evaluate all three <code>exprs</code> before yielding an answer regardless of whether <code>expr1</code> was false!</i> <b>无论<code>expr1</code>是否为假，都会在得到答案之前评估所有三个<code>exprs</code> ！</b> </p> 
<p> <i>With lisp macros you can code something like:</i> <b>使用lisp宏，您可以编写如下代码：</b> </p> 
<pre><code>(defmacro &amp;&amp; (expr1 &amp;rest exprs)
    `(if ,expr1                     ;` Warning: I have not tested
         (&amp;&amp; ,@exprs)               ;   this and might be wrong!
         nil))
</code></pre> 
<p> <i>now you have an <code>&amp;&amp;</code> , which you can call just like a function and it won't evaluate any forms you pass to it unless they are all true.</i> <b>现在你有一个<code>&amp;&amp;</code> ，你可以像一个函数一样调用它，它不会评估你传递给它的任何形式，除非它们都是真的。</b> </p> 
<p> <i>To see how this is useful, contrast:</i> <b>对比，看看这是如何有用的：</b> </p> 
<pre><code>(&amp;&amp; (very-cheap-operation)
    (very-expensive-operation)
    (operation-with-serious-side-effects))
</code></pre> 
<p> <i>and:</i> <b>和：</b> </p> 
<pre><code>and(very_cheap_operation(),
    very_expensive_operation(),
    operation_with_serious_side_effects());
</code></pre> 
<p> <i>Other things you can do with macros are creating new keywords and/or mini-languages (check out the <a href="http://www.ai.sri.com/pkarp/loop.html" rel="nofollow"><code>(loop ...)</code></a> macro for an example), integrating other languages into lisp, for example, you could write a macro that lets you say something like:</i> <b>你可以用宏做的其他事情是创建新的关键字和/或迷你语言（查看<a href="http://www.ai.sri.com/pkarp/loop.html" rel="nofollow"><code>(loop ...)</code></a>宏的例子），将其他语言集成到lisp中，例如，你可以写一个宏，让你说出类似的话：</b> </p> 
<pre><code>(setvar *rows* (sql select count(*)
                      from some-table
                     where column1 = "Yes"
                       and column2 like "some%string%")
</code></pre> 
<p> <i>And thats not even getting into <a href="http://dorophone.blogspot.com/2008/03/common-lisp-reader-macros-simple.html" rel="nofollow">Reader macros</a> .</i> <b>而这甚至没有进入<a href="http://dorophone.blogspot.com/2008/03/common-lisp-reader-macros-simple.html" rel="nofollow">Reader宏</a> 。</b> </p> 
<p> <i>Hope this helps.</i> <b>希望这可以帮助。</b> </p> 
<hr> 
<h4>#6楼</h4> 
<p> <i>Common Lisp macros essentially extend the "syntactic primitives" of your code.</i> <b>Common Lisp宏本质上扩展了代码的“语法原语”。</b> </p> 
<p> <i>For example, in C, the switch/case construct only works with integral types and if you want to use it for floats or strings, you are left with nested if statements and explicit comparisons.</i> <b>例如，在C中，switch / case结构只适用于整数类型，如果你想将它用于浮点数或字符串，你可以使用嵌套的if语句和显式比较。</b> <i>There's also no way you can write a C macro to do the job for you.</i> <b>你也无法编写C宏来为你完成这项工作。</b> </p> 
<p> <i>But, since a lisp macro is (essentially) a lisp program that takes snippets of code as input and returns code to replace the "invocation" of the macro, you can extend your "primitives" repertoire as far as you want, usually ending up with a more readable program.</i> <b>但是，由于lisp宏（基本上）是一个lisp程序，它将代码片段作为输入并返回代码以替换宏的“调用”，因此您可以根据需要扩展“原语”指令集，通常最终有一个更易读的程序。</b> </p> 
<p> <i>To do the same in C, you would have to write a custom pre-processor that eats your initial (not-quite-C) source and spits out something that a C compiler can understand.</i> <b>要在C中执行相同的操作，您必须编写一个自定义预处理器，它会占用您的初始（非C）源并吐出C编译器可以理解的内容。</b> <i>It's not a wrong way to go about it, but it's not necessarily the easiest.</i> <b>这不是一个错误的方法，但它不一定是最容易的。</b> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/725ffe79c56e3cde55d8c1c6b288bbee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何以编程方式退出android应用程序</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4595b135f2554cb7ac4b9fb47d1b5836/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据增强：模拟雨天算法Python</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>