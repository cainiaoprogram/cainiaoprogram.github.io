<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>机器学习入门（2）之模型评估与选择 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="机器学习入门（2）之模型评估与选择" />
<meta property="og:description" content="目录
一、误差与拟合
1. 泛化误差与经验误差
2. 损失函数与训练误差
3. 过拟合与欠拟合
4. 过拟合的另一种现象：数据泄露
二、评估方法
1. 留出法
2. 交叉验证法（留一法）
3. 自助法
4. 调参与最终模型
三、性能度量
1. 混淆矩阵
2.准确率
3.精确率（查准率）和召回率（查全率）
4. F1值和Fβ值
5. ROC曲线及其AUC值
6. AUC值的计算
7. 代价敏感错误率与代价曲线
四、比较检验
1.性能比较的三个要素
2.假设检验
（1）估计假设精度
（2）采样理论基础
（3）多次训练/测试的检验-t检验
（4）交叉验证 t 检验
（5）McNemar 检验
（6）Friedman检验与 Nemenyi后续检验
五、偏差与方差
一、误差与拟合 1. 泛化误差与经验误差 泛化误差：在“未来”样本上的误差（generalization error）
经验误差：在训练样本上的误差(training error),也称为训练误差
错误率 ：分类错误的样本数占样本总数的比例(error)
精度 ：1-错误率(accuracy)
我有个小问号？？？？
不是说泛化误差越小越好，那经验误差是否越小越好？
当然不是，因为会出现“过拟合”问题
2. 损失函数与训练误差 2.1 损失函数
损失函数是关于模型计算结果f(x)和样本实际目标结果y的非负实值函数，记作L(y,f(x)).用它来解释模型在每个样本实例上的误差,损失函数的值越小，说明预测值与实际值越接近，即模型的拟合效果越好. 损失函数主要包括以下几种： 0-1损失函数、平方损失函数、绝对损失函数、对数损失函数.
2.2 训练误差" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/cef8070394bfb3b912fec1d4a3c139c9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-30T19:49:47+08:00" />
<meta property="article:modified_time" content="2021-12-30T19:49:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">机器学习入门（2）之模型评估与选择</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E8%AF%AF%E5%B7%AE%E4%B8%8E%E6%8B%9F%E5%90%88-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E8%AF%AF%E5%B7%AE%E4%B8%8E%E6%8B%9F%E5%90%88" rel="nofollow">一、误差与拟合</a></p> 
<p id="1.%20%E6%B3%9B%E5%8C%96%E8%AF%AF%E5%B7%AE%E4%B8%8E%E7%BB%8F%E9%AA%8C%E8%AF%AF%E5%B7%AE-toc" style="margin-left:40px;"><a href="#1.%20%E6%B3%9B%E5%8C%96%E8%AF%AF%E5%B7%AE%E4%B8%8E%E7%BB%8F%E9%AA%8C%E8%AF%AF%E5%B7%AE" rel="nofollow">1. 泛化误差与经验误差</a></p> 
<p id="2.%20%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%B8%8E%E8%AE%AD%E7%BB%83%E8%AF%AF%E5%B7%AE-toc" style="margin-left:40px;"><a href="#2.%20%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%B8%8E%E8%AE%AD%E7%BB%83%E8%AF%AF%E5%B7%AE" rel="nofollow">2. 损失函数与训练误差</a></p> 
<p id="3.%20%E8%BF%87%E6%8B%9F%E5%90%88%E4%B8%8E%E6%AC%A0%E6%8B%9F%E5%90%88-toc" style="margin-left:40px;"><a href="#3.%20%E8%BF%87%E6%8B%9F%E5%90%88%E4%B8%8E%E6%AC%A0%E6%8B%9F%E5%90%88" rel="nofollow">3. 过拟合与欠拟合</a></p> 
<p id="4.%20%E8%BF%87%E6%8B%9F%E5%90%88%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E7%8E%B0%E8%B1%A1%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2-toc" style="margin-left:40px;"><a href="#4.%20%E8%BF%87%E6%8B%9F%E5%90%88%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E7%8E%B0%E8%B1%A1%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2" rel="nofollow">4. 过拟合的另一种现象：数据泄露</a></p> 
<p id="%C2%A0%E4%BA%8C%E3%80%81%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%8C%E3%80%81%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95" rel="nofollow"> 二、评估方法</a></p> 
<p id="1.%20%E7%95%99%E5%87%BA%E6%B3%95-toc" style="margin-left:40px;"><a href="#1.%20%E7%95%99%E5%87%BA%E6%B3%95" rel="nofollow">1. 留出法</a></p> 
<p id="2.%20%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%B3%95%EF%BC%88%E7%95%99%E4%B8%80%E6%B3%95%EF%BC%89-toc" style="margin-left:40px;"><a href="#2.%20%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%B3%95%EF%BC%88%E7%95%99%E4%B8%80%E6%B3%95%EF%BC%89" rel="nofollow">2. 交叉验证法（留一法）</a></p> 
<p id="3.%20%E8%87%AA%E5%8A%A9%E6%B3%95-toc" style="margin-left:40px;"><a href="#3.%20%E8%87%AA%E5%8A%A9%E6%B3%95" rel="nofollow">3. 自助法</a></p> 
<p id="%C2%A04.%C2%A0%E8%B0%83%E5%8F%82%E4%B8%8E%E6%9C%80%E7%BB%88%E6%A8%A1%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%C2%A04.%C2%A0%E8%B0%83%E5%8F%82%E4%B8%8E%E6%9C%80%E7%BB%88%E6%A8%A1%E5%9E%8B" rel="nofollow">4. 调参与最终模型</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F" rel="nofollow">三、性能度量</a></p> 
<p id="1.1%20%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5-toc" style="margin-left:40px;"><a href="#1.1%20%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5" rel="nofollow">1. 混淆矩阵</a></p> 
<p id="2.%E5%87%86%E7%A1%AE%E7%8E%87-toc" style="margin-left:40px;"><a href="#2.%E5%87%86%E7%A1%AE%E7%8E%87" rel="nofollow">2.准确率</a></p> 
<p id="3.%E7%B2%BE%E7%A1%AE%E7%8E%87%EF%BC%88%E6%9F%A5%E5%87%86%E7%8E%87%EF%BC%89%E5%92%8C%E5%8F%AC%E5%9B%9E%E7%8E%87%EF%BC%88%E6%9F%A5%E5%85%A8%E7%8E%87%EF%BC%89-toc" style="margin-left:40px;"><a href="#3.%E7%B2%BE%E7%A1%AE%E7%8E%87%EF%BC%88%E6%9F%A5%E5%87%86%E7%8E%87%EF%BC%89%E5%92%8C%E5%8F%AC%E5%9B%9E%E7%8E%87%EF%BC%88%E6%9F%A5%E5%85%A8%E7%8E%87%EF%BC%89" rel="nofollow">3.精确率（查准率）和召回率（查全率）</a></p> 
<p id="1.4%20F1%E5%80%BC%E5%92%8CF%CE%B2%E5%80%BC-toc" style="margin-left:40px;"><a href="#1.4%20F1%E5%80%BC%E5%92%8CF%CE%B2%E5%80%BC" rel="nofollow">4. F1值和Fβ值</a></p> 
<p id="1.5%20ROC%E6%9B%B2%E7%BA%BF%E5%8F%8A%E5%85%B6AUC%E5%80%BC-toc" style="margin-left:40px;"><a href="#1.5%20ROC%E6%9B%B2%E7%BA%BF%E5%8F%8A%E5%85%B6AUC%E5%80%BC" rel="nofollow">5. ROC曲线及其AUC值</a></p> 
<p id="1.6%20AUC%E5%80%BC%E7%9A%84%E8%AE%A1%E7%AE%97-toc" style="margin-left:40px;"><a href="#1.6%20AUC%E5%80%BC%E7%9A%84%E8%AE%A1%E7%AE%97" rel="nofollow">6. AUC值的计算</a></p> 
<p id="%C2%A01.7%C2%A0%E4%BB%A3%E4%BB%B7%E6%95%8F%E6%84%9F%E9%94%99%E8%AF%AF%E7%8E%87%E4%B8%8E%E4%BB%A3%E4%BB%B7%E6%9B%B2%E7%BA%BF-toc" style="margin-left:40px;"><a href="#%C2%A01.7%C2%A0%E4%BB%A3%E4%BB%B7%E6%95%8F%E6%84%9F%E9%94%99%E8%AF%AF%E7%8E%87%E4%B8%8E%E4%BB%A3%E4%BB%B7%E6%9B%B2%E7%BA%BF" rel="nofollow"> 7. 代价敏感错误率与代价曲线</a></p> 
<p id="%E5%9B%9B%E3%80%81%E6%AF%94%E8%BE%83%E6%A3%80%E9%AA%8C-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E6%AF%94%E8%BE%83%E6%A3%80%E9%AA%8C" rel="nofollow">四、比较检验</a></p> 
<p id="1.%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E7%9A%84%E4%B8%89%E4%B8%AA%E8%A6%81%E7%B4%A0-toc" style="margin-left:40px;"><a href="#1.%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E7%9A%84%E4%B8%89%E4%B8%AA%E8%A6%81%E7%B4%A0" rel="nofollow">1.性能比较的三个要素</a></p> 
<p id="2.%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C-toc" style="margin-left:40px;"><a href="#2.%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C" rel="nofollow">2.假设检验</a></p> 
<p id="%EF%BC%881%EF%BC%89%E4%BC%B0%E8%AE%A1%E5%81%87%E8%AE%BE%E7%B2%BE%E5%BA%A6-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E4%BC%B0%E8%AE%A1%E5%81%87%E8%AE%BE%E7%B2%BE%E5%BA%A6" rel="nofollow">（1）估计假设精度</a></p> 
<p id="%EF%BC%882%EF%BC%89%E9%87%87%E6%A0%B7%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E9%87%87%E6%A0%B7%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80" rel="nofollow">（2）采样理论基础</a></p> 
<p id="%C2%A0%EF%BC%883%EF%BC%89%E5%A4%9A%E6%AC%A1%E8%AE%AD%E7%BB%83%2F%E6%B5%8B%E8%AF%95%E7%9A%84%E6%A3%80%E9%AA%8C-t%E6%A3%80%E9%AA%8C-toc" style="margin-left:80px;"><a href="#%C2%A0%EF%BC%883%EF%BC%89%E5%A4%9A%E6%AC%A1%E8%AE%AD%E7%BB%83%2F%E6%B5%8B%E8%AF%95%E7%9A%84%E6%A3%80%E9%AA%8C-t%E6%A3%80%E9%AA%8C" rel="nofollow"> （3）多次训练/测试的检验-t检验</a></p> 
<p id="%EF%BC%884%EF%BC%89%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%20t%20%E6%A3%80%E9%AA%8C-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%20t%20%E6%A3%80%E9%AA%8C" rel="nofollow">（4）交叉验证 t 检验</a></p> 
<p id="%EF%BC%885%EF%BC%89McNemar%20%E6%A3%80%E9%AA%8C-toc" style="margin-left:80px;"><a href="#%EF%BC%885%EF%BC%89McNemar%20%E6%A3%80%E9%AA%8C" rel="nofollow">（5）McNemar 检验</a></p> 
<p id="%EF%BC%886%EF%BC%89Friedman%E6%A3%80%E9%AA%8C%E4%B8%8E%20Nemenyi%E5%90%8E%E7%BB%AD%E6%A3%80%E9%AA%8C-toc" style="margin-left:80px;"><a href="#%EF%BC%886%EF%BC%89Friedman%E6%A3%80%E9%AA%8C%E4%B8%8E%20Nemenyi%E5%90%8E%E7%BB%AD%E6%A3%80%E9%AA%8C" rel="nofollow">（6）Friedman检验与 Nemenyi后续检验</a></p> 
<p id="%C2%A0%E4%BA%94%E3%80%81%E5%81%8F%E5%B7%AE%E4%B8%8E%E6%96%B9%E5%B7%AE-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%BA%94%E3%80%81%E5%81%8F%E5%B7%AE%E4%B8%8E%E6%96%B9%E5%B7%AE" rel="nofollow"> 五、偏差与方差</a></p> 
<hr id="hr-toc"> 
<h2 id="%E4%B8%80%E3%80%81%E8%AF%AF%E5%B7%AE%E4%B8%8E%E6%8B%9F%E5%90%88">一、误差与拟合</h2> 
<h3 id="1.%20%E6%B3%9B%E5%8C%96%E8%AF%AF%E5%B7%AE%E4%B8%8E%E7%BB%8F%E9%AA%8C%E8%AF%AF%E5%B7%AE">1. 泛化误差与经验误差</h3> 
<p><strong>泛化误差</strong>：在“未来”样本上的误差（generalization error）</p> 
<p><strong>经验误差</strong>：在训练样本上的误差(training error),也称为训练误差</p> 
<p><strong>错误率</strong> ：分类错误的样本数占样本总数的比例(error)</p> 
<p><strong>精度 </strong>：1-错误率(accuracy)</p> 
<blockquote> 
 <p>我有个小问号？？？？</p> 
 <p>不是说泛化误差越小越好，那经验误差是否越小越好？</p> 
 <p>当然不是，因为会出现“过拟合”问题</p> 
</blockquote> 
<h3 id="2.%20%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E4%B8%8E%E8%AE%AD%E7%BB%83%E8%AF%AF%E5%B7%AE">2. 损失函数与训练误差</h3> 
<p>2.1 损失函数</p> 
<p>        损失函数是关于模型计算结果f(x)和样本实际目标结果y的非负实值函数，记作L(y,f(x)).用它来解释模型在每个样本实例上的误差,损失函数的值越小，说明预测值与实际值越接近，即模型的拟合效果越好. 损失函数主要包括以下几种： <strong>0-1损失函数、平方损失函数、绝对损失函数、对数损失函数.</strong></p> 
<p style="text-align:center;"><img alt="" height="56" src="https://images2.imgbox.com/bc/57/nl136wd3_o.png" width="388"></p> 
<p style="text-align:center;"><img alt="" height="42" src="https://images2.imgbox.com/13/79/Ah135r3Q_o.png" width="369"></p> 
<p style="text-align:center;"><img alt="" height="45" src="https://images2.imgbox.com/59/6a/BkVw9vNf_o.png" width="394"></p> 
<p style="text-align:center;"><img alt="" height="44" src="https://images2.imgbox.com/a0/29/ABkiqkx7_o.png" width="398"></p> 
<p> 2.2 训练误差</p> 
<p>        损失函数仅是对一个样本而言，模型优化目标函数应当是使全局损失函数最小，即所有样本的损失函数的均值，其中训练误差可表示为：</p> 
<p style="text-align:center;"><img alt="" height="89" src="https://images2.imgbox.com/55/37/kj6ZTIjZ_o.png" width="262"></p> 
<p style="text-align:center;"><img alt="" height="80" src="https://images2.imgbox.com/c9/ee/2xkShixn_o.png" width="437"></p> 
<p style="text-align:center;"><img alt="" height="101" src="https://images2.imgbox.com/de/11/Oze5kAx8_o.png" width="559"></p> 
<h3 id="3.%20%E8%BF%87%E6%8B%9F%E5%90%88%E4%B8%8E%E6%AC%A0%E6%8B%9F%E5%90%88">3. 过拟合与欠拟合</h3> 
<p>        在机器学习表现不佳的原因要么是过度拟合或欠拟合数据。</p> 
<p style="text-align:center;"><img alt="" height="338" src="https://images2.imgbox.com/41/0e/xrNGmgxg_o.png" width="554"></p> 
<h4 id="h2-u673Au5668u5B66u4E60u4E2Du7684u903Cu8FD1u76EEu6807u51FDu6570u8FC7u7A0B"><strong>3.1 机器学习中的逼近目标函数过程</strong></h4> 
<p>        监督式机器学习通常理解为逼近一个目标函数f，此函数映射输入变量(X)到输出变量(Y)得到Y=f(X)</p> 
<p>        这种特性描述可以用于定义分类和预测问题和机器学习算法的领域。</p> 
<p>        从训练数据中学习目标函数的过程中，我们必须考虑的问题是模型在预测新数据时的泛化性能。泛化好坏是很重要的，因为我们收集到的数据只是样本，其带有噪音并且是不完全的。</p> 
<h4 id="h2-u673Au5668u5B66u4E60u4E2Du7684u6CDBu5316"><a name="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%B3%9B%E5%8C%96"></a><strong>3.2 机器学习中的泛化</strong></h4> 
<p>        在机器学习中，我们描述从训练数据学习目标函数的学习过程为归纳性的学习。</p> 
<p>        归纳与特别的样本中学习到通用的概念有关，而这就是监督式机器学习致力于解决的问题。这与推演不同，其主要是另一种解决问题和寻求从通常的规则中找寻特别的内容。</p> 
<p>        泛化即是，机器学习模型学习到的概念在它处于学习的过程中时模型没有遇见过的样本时候的表现。</p> 
<p>        好的机器学习模型的模板目标是从问题领域内的训练数据到任意的数据上泛化性能良好。这让我们可以在未来对模型没有见过的数据进行预测。</p> 
<p>        在机器学习领域中，当我们讨论一个机器学习模型学习和泛化的好坏时，我们通常使用术语：过拟合和欠拟合.</p> 
<h4 id="h2-u7EDFu8BA1u62DFu5408"><a name="%E7%BB%9F%E8%AE%A1%E6%8B%9F%E5%90%88"></a><strong>3.3 统计拟合</strong></h4> 
<p>        在统计学中，拟合指的是你逼近目标函数的远近程度。</p> 
<p>        这个术语同样可以用于机器学习中，因为监督式机器学习算法的目标也是逼近一个未知的潜在映射函数，其把输入变量映射到输出变量。</p> 
<p>        统计学通常<strong>通过用于描述函数和目标函数逼近的吻合程度来描述拟合的好坏</strong>。</p> 
<p>        这类理论中的一些在机器学习中也是有用的(例如，计算残差)，但是一些技巧假设我们已经知道了我们要逼近的函数。这和机器学习的场景就不同了。</p> 
<p>        如果我们已经知道了目标函数的形式，我们将可以直接用它来做预测，而不是从一堆有噪音的数据中把它费力的学习出来。</p> 
<h4 id="h2-u673Au5668u5B66u4E60u4E2Du7684u8FC7u62DFu5408"><a name="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E8%BF%87%E6%8B%9F%E5%90%88"></a><strong>3.4 机器学习中的过拟合</strong></h4> 
<p>        过拟合指的是模型对于训练数据拟合程度<strong>过当</strong>的情况。</p> 
<p>        当某个模型过度的学习训练数据中的细节和噪音，以至于模型在新的数据上表现很差，我们称过拟合发生了。这意味着训练数据中的噪音或者随机波动也被当做概念被模型学习了。而问题就在于这些概念不适用于新的数据，从而导致模型泛化性能的变差。</p> 
<p>        过拟合更可能在无参数非线性模型中发生，因为学习目标函数的过程是易变的具有弹性的。同样的，许多的无参数器学习算法也包括限制约束模型学习概念多少的参数或者技巧。</p> 
<p>        例如，决策树就是一种无参数机器学习算法，非常有弹性并且容易受过拟合训练数据的影响。这种问题可以通过对学习过后的树进行剪枝来解决，这种方法就是为了移除一些其学习到的细节。</p> 
<h4 id="h2-u673Au5668u5B66u4E60u4E2Du7684u6B20u62DFu5408"><a name="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E7%9A%84%E6%AC%A0%E6%8B%9F%E5%90%88"></a><strong>3.5 机器学习中的欠拟合</strong></h4> 
<p>        欠拟合指的是模型在训练和预测时表现都不好的情况。</p> 
<p>        一个欠拟合的机器学习模型<strong>不是一个良好的模型并且由于在训练数据上表现不好</strong>这是显然的。</p> 
<p>        欠拟合通常不被讨论，因为给定一个评估模型表现的指标的情况下，欠拟合很容易被发现。矫正方法是继续学习并且试着更换机器学习算法。</p> 
<h4 id="h2-u673Au5668u5B66u4E60u4E2Du597Du7684u62DFu5408"><a name="%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B8%AD%E5%A5%BD%E7%9A%84%E6%8B%9F%E5%90%88"></a><strong>3.6 机器学习中好的拟合</strong></h4> 
<p>        理想上，你肯定想选择一个正好介于欠拟合和过拟合之间的模型。</p> 
<p>        这就是我们学习的目标，但是实际上很难达到。</p> 
<p>        为了理解这个目标，我们可以观察正在学习训练数据机器学习算法的表现。我们可以把这个过程划分为分别是<strong>训练过程和测试过程</strong>。</p> 
<p>        随着时间进行，算法不断地学习，模型在训练数据和测试数据上的错误都在不断下降。但是，如果我们学习的时间过长的话，模型在训练数据上的表现将继续下降，这是因为模型已经过拟合并且学习到了训练数据中的不恰当的细节以及噪音。同时，测试数据集上的错误率开始上升，也即是模型的泛化能力在下降。</p> 
<p>        这个完美的临界点就处于<strong>测试集上的错误率开始上升时，此时模型在训练集和测试集上都有良好的表现</strong>。</p> 
<p>        你可以用你自己喜爱的机器学习算法来实践这个实验。而在实践中这通常是无用的，因为在测试数据上运用这个技巧来选择训练停止的时机，这意味着这个测试集对于我们并不是“不可见的”或者单独的衡量标准。数据的一些知识(许多有用的知识)已经泄露到了训练过程。</p> 
<p>        通常有两种手段可以帮助你找到这个完美的临界点：<strong>重采样方法和验证集方法</strong>。</p> 
<h4 id="%C2%A03.7%E5%A6%82%E4%BD%95%E9%99%90%E5%88%B6%E8%BF%87%E6%8B%9F%E5%90%88"><strong> 3.7如何限制过拟合</strong></h4> 
<p>        过拟合和欠拟合可以导致很差的模型表现。但是到目前为止大部分机器学习实际应用时的问题都是过拟合。</p> 
<p>        过拟合是个问题因为训练数据上的机器学习算法的评价方法与我们最关心的实际上的评价方法，也就是算法在位置数据上的表现是不一样的。</p> 
<p><strong>当评价机器学习算法时我们有两者重要的技巧来限制过拟合:</strong></p> 
<ul><li>使用重采样来评价模型效能</li><li>保留一个验证数据集</li></ul> 
<p>        最流行的重采样技术是<strong>k折交叉验证</strong>。指的是在训练数据的子集上训练和测试模型k次，同时建立对于机器学习模型在未知数据上表现的评估。</p> 
<h3 id="4.%20%E8%BF%87%E6%8B%9F%E5%90%88%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E7%8E%B0%E8%B1%A1%EF%BC%9A%E6%95%B0%E6%8D%AE%E6%B3%84%E9%9C%B2">4. 过拟合的另一种现象：数据泄露</h3> 
<p><strong>1、数据泄露现象</strong></p> 
<p>        机器学习中还有一个与过拟合非常相似的现象：训练时模型表现的非常好，但是在真实的预测中表现的很差。这种情况可能是数据泄露。数据泄露又叫特征穿越，指的是在建模过程中的数据收集、处理时不小心将未来信息引入到训练集中。当把未来信息引入到训练集中时，模型训练的效果往往非常好，但真实的预测效果会大打折扣。</p> 
<p> <strong>2、数据泄露容易发生的场景</strong></p> 
<p><strong>        </strong>数据泄露一般发生在时间序列场景或具有时间属性的场景中。例如，在金融的信贷领域，建模工程师在取数的时候，误取到了建模时间点之后的还款信息、表现等。</p> 
<p> <strong>3、检查数据泄露的方法</strong></p> 
<p><strong>（1）数据探索性分析</strong></p> 
<p>        查看特征分布和特征与目标之间的关系，并从具体问题角度出发，分析和论证该特征的含义。</p> 
<p><strong>（2）特征分析</strong></p> 
<p>        可以进行特征与目标变量的相关性分析，使用一些统计算法，去分析特征的重要性。如果有表现特别突出的特性，需重点检查。</p> 
<p><strong>（3）模型比较</strong></p> 
<p>        详细的模型性能评估和分析，与之前的版本的模型和行业模型进行对比。</p> 
<p><strong>（4）加强测试</strong></p> 
<p>        对模型进行现场测试，查看真实环境的表现与模型训练效果是否有很大差别。</p> 
<p><strong>4、避免出现数据泄露需要注意的点</strong></p> 
<p><strong>（1）</strong>具有时间属性的场合要严格控制时间，取得所需历史快照数据，并追溯变量业务的物理含义；</p> 
<p><strong>（2）</strong>使用特征区分力指标进行直观检查，重点检查区分力强的特征；</p> 
<p><strong>（3）</strong>当怀疑某个特征有泄露的可能性时，不要使用；</p> 
<p><strong>（4）</strong>不要使用ID类的变量；</p> 
<p><strong>（5）</strong>只有在训练数据集或交叉验证的训练组中执行数据信息提取等相关处理方法（特征选择、异常值删除、编码、特征缩放和降维等），交叉验证时在每个循环周期内独立进行；</p> 
<p><strong>（6）</strong>在独立的、模型完全未见的数据集上进行模型的最终评估；</p> 
<p><strong>（7）</strong>采取管道方式，使用统一的数据处理方法。</p> 
<h2 id="%C2%A0%E4%BA%8C%E3%80%81%E8%AF%84%E4%BC%B0%E6%96%B9%E6%B3%95"> 二、评估方法</h2> 
<p><strong>        如何获得测试结果？？？</strong></p> 
<p>        在学习得到的模型投放使用之前，通常需要对其进行性能评估。为此， 需使用一个“测试集”（testing set）来测试模型对新样本的泛化能力，然后以测试集上的“测试误差”（testing error）作为泛化误差的近似。</p> 
<p>        而“测试集”的获得，我们一般假设是从样本真实分布中独立采样获得的，所以要求测试集和训练集中的样本尽量互斥</p> 
<p>给定一个已知的数据集，将数据集拆分成训练集S和测试集T，通常的做法包括：</p> 
<h3 id="1.%20%E7%95%99%E5%87%BA%E6%B3%95">1. 留出法</h3> 
<p><img alt="" height="201" src="https://images2.imgbox.com/ee/0d/OBaicXiB_o.png" width="743"></p> 
<p><strong> 注意：</strong></p> 
<ul><li>保持数据分布的一致性（例如：分层采样）</li><li>多次重复划分（例如：100次随机划分）</li><li>测试集不能太大、不能太小 (例如：1/5~1/3)</li></ul> 
<h3 id="2.%20%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%E6%B3%95%EF%BC%88%E7%95%99%E4%B8%80%E6%B3%95%EF%BC%89">2. 交叉验证法（留一法）</h3> 
<p>        将数据集分层采样划分为k个大小相似的互斥子集，每次用k-1个子集的并集作为训练集，余下的子集作为测试集，最终返回k个测试结果的均值，“k折交叉验证”（k-fold cross validation）。k最常用的取值是10，其他常用的k值有5、20等。</p> 
<p style="text-align:center;"><img alt="" height="303" src="https://images2.imgbox.com/33/97/gHxfZJCD_o.png" width="784"></p> 
<p>         与留出法类似，将数据集D划分为k个子集同样存在多种划分方式，为了减小因样本划分不同而引入的差别，k折交叉验证通常随机使用不同的划分重复p次，最终的评估结果是这p次k折交叉验证结果的均值，例如常见的“10次10折交叉验证”。</p> 
<p> <strong>假设数据集D包含m个样本，若令k=m，则得到留一法： </strong></p> 
<ul><li>NFL 定理仍然有效</li><li>不受随机样本划分方式的影响  </li><li>结果往往比较准确  </li><li>当数据集比较大时，计算开销难以忍受</li></ul> 
<h3 id="3.%20%E8%87%AA%E5%8A%A9%E6%B3%95">3. 自助法</h3> 
<p>        以<strong>自助采样法</strong>为基础，对数据集D有<strong>放回采样</strong>m次得到训练集D′ , D\D′用做测试集。</p> 
<p style="text-align:center;"><img alt="" height="143" src="https://images2.imgbox.com/63/a6/Dsi2E8xY_o.png" width="613"></p> 
<ul><li>训练集与原样本集同规模</li><li>数据分布有所改变</li></ul> 
<p>        约有 36.8% 的样本不出现，称为“包外估计”(out-of-bag estimation)</p> 
<p style="text-align:center;"><img alt="" height="77" src="https://images2.imgbox.com/b8/d5/Iu65zH7Q_o.png" width="345"></p> 
<p><strong> 注意：</strong></p> 
<ul><li>自助法在数据集较小、难以有效划分训练/测试集时很有用</li><li>从初始数据集中产生多个不同的训练集，对集成学习有很大的好处</li><li>由于改变了数据集分布可能引入估计偏差，在数据量足够时，留出法和交叉验证法更常用</li></ul> 
<h3 id="%C2%A04.%C2%A0%E8%B0%83%E5%8F%82%E4%B8%8E%E6%9C%80%E7%BB%88%E6%A8%A1%E5%9E%8B">4. 调参与最终模型</h3> 
<p><strong>算法的参数</strong>：一般由人工设定，亦称“超参数”</p> 
<p><strong>模型的参数</strong>：一般由学习确定</p> 
<p><strong>调参过程相似</strong>：先产生若干模型，然后基于某种评估方法进行选择</p> 
<p><strong>注：</strong>参数调得好不好往往对模型最终性能有关键影响</p> 
<p><strong>区别</strong>：训练集  vs.  测试集  vs. 验证集(validation set)</p> 
<p>算法参数选定后，要用“<strong>训练集+验证集</strong>”重新训练<strong>最终模型</strong></p> 
<p><strong>模型持久化（model persistence）:</strong></p> 
<ul><li><strong>1.pickle</strong></li><li><strong>2.joblib</strong></li></ul> 
<h2 id="%E4%B8%89%E3%80%81%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F">三、性能度量</h2> 
<p>        性能度量(performance measure)是<strong>衡量模型泛化能力的评价标准</strong>，反映了任务需求。</p> 
<p>        使用不同的性能度量往往会导致不同的评判结果</p> 
<p>        什么样的模型是“好”的，不仅取决于算法和数据，还取决于任务需求。</p> 
<p><strong>评价指标：</strong></p> 
<p>        准确率、精确率（查准率）、召回率（查全率）、F1值、ROC曲线的AUC值，都可以作为评价一个机器学习模型好坏的指标（evaluation metrics），而这些评价指标直接或间接都与混淆矩阵有关，前四者可以从混淆矩阵中直接计算得到，AUC值则要通过ROC曲线进行计算，而ROC曲线的横纵坐标又和混淆矩阵联系密切，所以在了解这些评价指标之前，先知道什么是混淆矩阵很有必要，也方便记忆。</p> 
<h3 id="1.1%20%E6%B7%B7%E6%B7%86%E7%9F%A9%E9%98%B5">1. 混淆矩阵</h3> 
<p>　　对于一个二分类问题，我们可以得到如表 1所示的的混淆矩阵（confusion matrix）：</p> 
<p style="text-align:center;">表 1：混淆矩阵</p> 
<table align="center" border="1" cellspacing="0"><tbody><tr><td colspan="2" rowspan="2" style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:center;"></p> </td><td colspan="2" style="background-color:#ff6347;"> <p style="margin-left:.0001pt;text-align:center;"><span style="color:#000000;">Actual class</span><span style="color:#000000;">（真实结果）</span></p> </td></tr><tr><td style="background-color:#ffe4b5;"> <p style="margin-left:.0001pt;text-align:center;"><span style="color:#000000;">positive class</span><span style="color:#000000;">(正向)</span></p> </td><td style="background-color:#ffe4b5;"> <p style="margin-left:.0001pt;text-align:center;"><span style="color:#000000;">negative class</span><span style="color:#000000;">(负向)</span></p> </td></tr><tr><td rowspan="2" style="background-color:#ff6347;"> <p style="margin-left:.0001pt;text-align:center;"><span style="color:#000000;">Predicted class</span></p> <p style="margin-left:.0001pt;text-align:center;"><span style="color:#000000;">（预测结果）</span></p> </td><td style="background-color:#ffe4b5;"> <p style="margin-left:.0001pt;text-align:center;"><span style="color:#000000;">positive class</span><span style="color:#000000;">(正向)</span></p> </td><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:center;"><span style="color:#000000;">True Positive(TP)</span></p> </td><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:center;"><span style="color:#000000;">False Positive(FP)</span></p> </td></tr><tr><td style="background-color:#ffe4b5;"> <p style="margin-left:.0001pt;text-align:center;"><span style="color:#000000;">negative class</span><span style="color:#000000;">(负向)</span></p> </td><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:center;"><span style="color:#000000;">False Negative(FN)</span></p> </td><td style="background-color:#ffffff;"> <p style="margin-left:.0001pt;text-align:center;"><span style="color:#000000;">True Negative(TN)</span></p> </td></tr></tbody></table> 
<p>表 1 所示的混淆矩阵中，行表示数据在模型上的预测类别（predicted class/predicted condition），列表示数据的真实类别（actual class/true condition）。在看混淆矩阵时，要分清样本的真实类别和预测类别，有些地方的行列表示可能和这里不一致。<a href="http://scikit-learn.org/stable/modules/generated/sklearn.metrics.confusion_matrix.html" rel="nofollow" title="在sklearn中，二分类问题下的混淆矩阵需要分别将表 1 中的predicted class和Actual class对调，将横纵坐标的positive class和negative class都分别对调，再重新计算混淆矩阵。">在sklearn中，二分类问题下的混淆矩阵需要分别将表 1 中的predicted class和Actual class对调，将横纵坐标的positive class和negative class都分别对调，再重新计算混淆矩阵。</a></p> 
<p>　　通过混淆矩阵，我们可以很直观地看清一个模型在各个类别（positive和negative）上分类的情况。</p> 
<p style="text-align:center;">表 2：TP、FP、FN、TN</p> 
<table align="center" border="0"><tbody><tr><td>TP</td><td>真实类别为positive，模型预测的类别也为positive</td></tr><tr><td>FP</td><td>预测为positive，但真实类别为negative，真实类别和预测类别不一致</td></tr><tr><td>FN</td><td>预测为negative，但真实类别为positive，真实类别和预测类别不一致</td></tr><tr><td>TN</td><td>真实类别为negative，模型预测的类别也为negative</td></tr></tbody></table> 
<p>        TP、FP、TN、FN，第二个字母表示样本被预测的类别，第一个字母表示样本的预测类别与真实类别是否一致。</p> 
<p><strong>查准率(P)</strong>：被分为正类的样本中实际为正类的样本比例。</p> 
<p style="text-align:center;"><img alt="" height="56" src="https://images2.imgbox.com/bb/e9/48enBXoM_o.png" width="153"></p> 
<p><strong>查全率(R)</strong>：实际为正类的样本中被分为正类的样本比例。</p> 
<p style="text-align:center;"><img alt="" height="59" src="https://images2.imgbox.com/1a/62/qS5NrtA8_o.png" width="163"></p> 
<p style="text-align:center;"><img alt="" height="337" src="https://images2.imgbox.com/87/0e/lVgklAyu_o.png" width="403"></p> 
<p> <strong>PR图：</strong></p> 
<ul><li>学习器 A 优于 学习器 C</li><li>学习器 B 优于 学习器 C</li><li>学习器 A  ?? 学习器 B</li></ul> 
<p><strong> BEP</strong>：</p> 
<ul><li>学习器 A 优于 学习器 B</li><li>学习器 A 优于 学习器 C</li><li>学习器 B 优于 学习器 C</li></ul> 
<h3 id="2.%E5%87%86%E7%A1%AE%E7%8E%87">2.准确率</h3> 
<p> 　　准确率（accuracy）计算公式如下所示：</p> 
<p style="text-align:center;"><img alt="" height="52" src="https://images2.imgbox.com/b0/c5/YWef7E2E_o.png" width="349"></p> 
<p>        准确率表示预测正确的样本（TP和TN）在所有样本（all data）中占的比例。</p> 
<p>　　在数据集不平衡时，准确率将不能很好地表示模型的性能。可能会存在准确率很高，而少数类样本全分错的情况，此时应选择其它模型评价指标。</p> 
<h3 id="3.%E7%B2%BE%E7%A1%AE%E7%8E%87%EF%BC%88%E6%9F%A5%E5%87%86%E7%8E%87%EF%BC%89%E5%92%8C%E5%8F%AC%E5%9B%9E%E7%8E%87%EF%BC%88%E6%9F%A5%E5%85%A8%E7%8E%87%EF%BC%89">3.精确率（查准率）和召回率（查全率）</h3> 
<p>　　positive class的精确率（precision）计算公式如下：</p> 
<p style="text-align:center;"><img alt="" height="55" src="https://images2.imgbox.com/a3/42/JJmQjeaO_o.png" width="375"></p> 
<p>　　positive class的召回率（recall）计算公式如下：</p> 
<p style="text-align:center;"><img alt="" height="55" src="https://images2.imgbox.com/bf/3d/NjznGiTL_o.png" width="349"></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;">        positive class的精确率表示<span style="background-color:#ffffff;">在预测为positive的样本中真实类别为positive的样本所占比例</span>；positive class的召回率表<span style="background-color:#ffffff;">示在真实为positive的样本中模型成功预测出的样本所占比例。</span></span></p> 
<p style="margin-left:.0001pt;text-align:left;"><span style="background-color:#ffffff;"><span style="color:#000000;">        positive class的召回率只和真实为positive的样本相关，与真实为negative的样本无关；而精确率则受到两类样本的影响。</span></span></p> 
<h3 id="1.4%20F1%E5%80%BC%E5%92%8CF%CE%B2%E5%80%BC">4. F1值和Fβ值</h3> 
<p>F1度量:基于查准率和查全率的调合平均(harmonic mean)</p> 
<p>F1值的计算公式如下：</p> 
<p style="text-align:center;"><img alt="" height="84" src="https://images2.imgbox.com/3d/60/G7eRgNvx_o.png" width="393"></p> 
<p><br> F1值就是精确率和召回率的调和平均值，F1值认为精确率和召回率一样重要。</p> 
<p> 若对查准率/查全率有不同偏好：</p> 
<p>　　Fβ值的计算公式如下：</p> 
<p style="text-align:center;"><img alt="" height="78" src="https://images2.imgbox.com/b6/2f/tTkuzjxt_o.png" width="478"></p> 
<ul><li>在β=1时，Fβ就是F1值，此时Fβ认为精确率和召回率一样重要</li><li>当β&gt;1时，Fβ认为召回率更重要</li><li>当0&lt;β&lt;1时，Fβ认为精确率更重要。</li><li>除了F1值之外，常用的还有F2和F0.5。</li></ul> 
<h3 id="1.5%20ROC%E6%9B%B2%E7%BA%BF%E5%8F%8A%E5%85%B6AUC%E5%80%BC">5. ROC曲线及其AUC值</h3> 
<p>　　AUC全称为Area Under Curve，表示一条曲线下面的面积，ROC曲线的AUC值可以用来对模型进行评价。ROC曲线如图所示：</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ce/5f/8uznZHwC_o.png"></p> 
<p style="text-align:center;"> ROC曲线</p> 
<p>（注：图片摘自<a href="https://en.wikipedia.org/wiki/Receiver_operating_characteristic" rel="nofollow" title="https://en.wikipedia.org/wiki/Receiver_operating_characteristic">https://en.wikipedia.org/wiki/Receiver_operating_characteristic</a>）</p> 
<p>　　ROC曲线的纵坐标True Positive Rate（TPR）在数值上就等于positive class的recall，记作recallpositive，横坐标False Positive Rate（FPR）在数值上等于(1 - negative class的recall)，记作(1 - recallnegative)如下所示：</p> 
<p style="text-align:center;"><img alt="" height="44" src="https://images2.imgbox.com/58/ee/7jT6hcA7_o.png" width="238"></p> 
<p style="text-align:center;"><img alt="" height="44" src="https://images2.imgbox.com/21/6a/rDbt4K0O_o.png" width="497"></p> 
<p>        通过对分类阈值θθ（默认0.5）从大到小或者从小到大依次取值，我们可以得到很多组TPR和FPR的值，将其在图像中依次画出就可以得到一条ROC曲线，阈值θ取值范围为[0,1]。</p> 
<p style="margin-left:.0001pt;text-align:justify;">        通过对分类阈值θ（默认0.5）从大到小或者从小到大依次取值，我们可以得到很多组TPR和FPR的值，将其在图像中依次画出就可以得到一条ROC曲线，阈值θ取值范围为[0,1]。</p> 
<p style="margin-left:.0001pt;text-align:justify;">        ROC曲线在图像上越接近左上角(0,1)模型越好，即ROC曲线下面与横轴和直线FPR = 1围成的面积（AUC值）越大越好。直观上理解，纵坐标TPR就是recallpositive值，横坐标FPR就是(1 - recallnegative)，前者越大越好，后者整体越小越好，在图像上表示就是曲线越接近左上角(0,1)坐标越好。</p> 
<p style="text-align:center;"><img alt="" height="375" src="https://images2.imgbox.com/f5/e6/TYhSsiDk_o.png" width="408"></p> 
<ul><li>理想模型是真正例率为100%，假正例率为0%的一点。</li><li>随机猜测模型则是真正例率与假正例率持平的直线。</li><li>由此可知，在随机猜测模型左上方的曲线和在其右下方的曲线都代表了什么。（右下方的模型，还不如随机猜测准。）</li><li>性能度量的方法：绘制ROC曲线</li><li>当曲线<strong>没有交叉</strong>的时候：外侧曲线的学习器性能优于内侧；</li><li>当曲线<strong>有交叉</strong>的时候：比较ROC面积，即AUC。</li></ul> 
<h3 id="1.6%20AUC%E5%80%BC%E7%9A%84%E8%AE%A1%E7%AE%97">6. AUC值的计算</h3> 
<p>        <strong>AUC(Area under Curve)</strong>：Roc曲线下的面积，介于0.1和1之间AUC作为数值可以直观的评价分类器的好坏，值越大越好。</p> 
<p>        首先AUC值是一个概率值，当你随机挑选一个正样本以及负样本，当前的分类算法根据计算得到的Score值将这个正样本排在负样本前面的概率就是AUC值，AUC值越大，当前分类算法越有可能将正样本排在负样本前面，从而能够更好地分类。</p> 
<p><strong>方法一 ：定义法</strong></p> 
<p style="text-align:center;"><img alt="" height="277" src="https://images2.imgbox.com/f7/c2/xirLmwKv_o.png" width="295"></p> 
<p>        从定义可知，AUC可通过ROC曲线下各部分的面积求和而得。假定ROC曲线是由坐标为{(x1,y1), {(x2,y2),…,{(xm,ym)}的点按序连接而形成(x1=0, xm=1),则AUC可估算为：</p> 
<p style="text-align:center;"><img alt="" height="82" src="https://images2.imgbox.com/3e/4d/3ACYtw3p_o.png" width="375"></p> 
<p style="text-align:center;"><img alt="" height="253" src="https://images2.imgbox.com/20/c2/Cz2xQIzb_o.png" width="282"></p> 
<p style="text-align:center;"><img alt="" height="259" src="https://images2.imgbox.com/e0/b5/EaM0Azqn_o.png" width="332"></p> 
<p style="text-align:center;"><strong>AUC=0.75 </strong></p> 
<p><strong>方法二 ：排序损失法</strong></p> 
<p><strong>        </strong>形式化地看，AUC考虑的是样本预测的排序质量，因此它与排序误差有紧密联系。给定m^+个正例和m^−个反例，令D^+和D^−分别表示正、反例集合，则排序“损失”(loss)定义为：</p> 
<p style="text-align:center;"><img alt="" height="142" src="https://images2.imgbox.com/de/56/43iPULQX_o.png" width="594"></p> 
<p style="text-align:center;"><img alt="" height="229" src="https://images2.imgbox.com/a7/9f/aJNFkwBk_o.png" width="256"></p> 
<p style="text-align:center;"><img alt="" height="283" src="https://images2.imgbox.com/4a/2f/WSsT3PD9_o.png" width="438"></p> 
<p style="text-align:center;"><img alt="" height="233" src="https://images2.imgbox.com/90/7c/Efrf3Khj_o.png" width="276"></p> 
<p style="text-align:center;"><img alt="" height="62" src="https://images2.imgbox.com/3d/ca/gzCWVzgp_o.png" width="296"></p> 
<p> 所以：<strong>AUC=1-0.25=0.75</strong></p> 
<p><strong> 方法三 ：排序收益法</strong></p> 
<p style="text-align:center;"><img alt="" height="226" src="https://images2.imgbox.com/4c/eb/NRCfv2wi_o.png" width="253"></p> 
<p style="text-align:center;"><img alt="" height="254" src="https://images2.imgbox.com/12/f2/FIZTiHlW_o.png" width="383"></p> 
<p style="text-align:center;"><img alt="" height="48" src="https://images2.imgbox.com/91/93/fOec4BpZ_o.png" width="234"></p> 
<p><strong> 方法四 ：排序法</strong></p> 
<p style="text-align:center;"><img alt="" height="60" src="https://images2.imgbox.com/56/98/3uvtHsg8_o.png" width="307"></p> 
<ul><li><strong>ri </strong>:第i条样本的序号（概率得分从大到小排序，排在第r个位置）</li><li>n0,n1:负样本和正样本的个数</li></ul> 
<p style="text-align:center;"><img alt="" height="187" src="https://images2.imgbox.com/c2/02/l5VPg9z4_o.png" width="552"></p> 
<p style="text-align:center;"><img alt="" height="283" src="https://images2.imgbox.com/57/bc/gQeS561b_o.png" width="452"></p> 
<p style="text-align:center;"><img alt="" height="56" src="https://images2.imgbox.com/47/f8/uw2ys6Ob_o.png" width="326"></p> 
<h3 id="%C2%A01.7%C2%A0%E4%BB%A3%E4%BB%B7%E6%95%8F%E6%84%9F%E9%94%99%E8%AF%AF%E7%8E%87%E4%B8%8E%E4%BB%A3%E4%BB%B7%E6%9B%B2%E7%BA%BF"> 7. 代价敏感错误率与代价曲线</h3> 
<p>         为均衡不同类型错误所造成的不同损失，可为错误赋予“非均等代价”(unequal cost)</p> 
<p>         以二分类为例，引入了“代价矩阵”（cost matrix）：</p> 
<p style="text-align:center;"><img alt="" height="211" src="https://images2.imgbox.com/5a/1a/DbcN7AQJ_o.png" width="402"></p> 
<p> 在非均等错误代价下，我们希望的是最小化“总体代价”，这样“代价敏感”的错误率:</p> 
<p style="text-align:center;"><img alt="" height="80" src="https://images2.imgbox.com/3a/22/VzDGHJkQ_o.png" width="686"></p> 
<p>         同样对于ROC曲线，在非均等错误代价下，演变成了“代价曲线”，代价曲线横轴是取值在[0,1]之间的正例概率代价，式中p表示正例的概率，纵轴是取值为[0,1]的归一化代价。</p> 
<p style="text-align:center;"><img alt="" height="59" src="https://images2.imgbox.com/96/b0/J0p2lJ5h_o.png" width="348"></p> 
<p style="text-align:center;"><img alt="" height="70" src="https://images2.imgbox.com/69/8c/C4rjRT0E_o.png" width="490"></p> 
<p><strong> 代价曲线的绘制</strong>：</p> 
<ul><li>ROC曲线上取一个点(FPR,TPR)；</li><li>取相应的(0,FPR)和(1,FNR)，连成线段；</li><li>取遍ROC曲线上所有点并重复前步骤；</li><li>所有线段的下界就是学习器期望总体代价。</li><li>实际上就是通过将样例为正例的概率p设为0和1，来作出曲线的所有切线，最后连成曲线。</li></ul> 
<p style="text-align:center;"><img alt="" height="276" src="https://images2.imgbox.com/61/4e/DPOsJOvR_o.png" width="401"></p> 
<p></p> 
<h2 id="%E5%9B%9B%E3%80%81%E6%AF%94%E8%BE%83%E6%A3%80%E9%AA%8C">四、比较检验</h2> 
<h3 id="1.%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83%E7%9A%84%E4%B8%89%E4%B8%AA%E8%A6%81%E7%B4%A0">1.性能比较的三个要素</h3> 
<p>1.希望比较的和实际获得的性能并不相同，两者对比结果也可能不会相同。</p> 
<p style="text-align:center;"><img alt="" height="101" src="https://images2.imgbox.com/4e/bf/MfPcB8BT_o.png" width="266"></p> 
<p> 2.测试集的性能与测试集本身的选择有很大关系，也就是说，测试数据好，性能就好，数据不好，性能也跟着不好。</p> 
<p style="text-align:center;"><img alt="" height="117" src="https://images2.imgbox.com/fe/67/5msaTQNi_o.png" width="342"></p> 
<p> 3. 很多机器学习算法都具有随机性，相同的参数、相同的测试集，运行多次，结果却不同。</p> 
<p><strong>注</strong>： 直接选取相应评估方法在相应度量下比大小的方法不可取！</p> 
<h3 id="2.%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C">2.假设检验</h3> 
<p>由于泛化错误率与测试错误率比较接近，因此，可根据测试错误率估推出泛化错误率的分布。<br> 泛化错误率为ϵ 学习器被测得测试错误率为ϵ ^ 的概率:</p> 
<p style="text-align:center;"><img alt="" height="81" src="https://images2.imgbox.com/00/e4/iS36uwWB_o.png" width="466"></p> 
<p> 比较检验的重要方法是<strong>统计假设检验</strong></p> 
<p>        数理统计学中根据一定假设条件由样本推断总体的一种方法。 在总体的分布函数完全未知或已知其形式，但不知其参数的情况，为了推断总体的某些未知特性，提出某些关于总体的假设。我们要根据样本对所提出的假设作出是接受还是拒绝的决策。</p> 
<p><strong>假设检验四步走： </strong></p> 
<ul><li>1、条件：满足情况。（总体的分布函数完全未知或已知其形式，但不知其参数）</li><li>2、目标：以推断总体的某些未知特性为目标。</li><li>3、方法：提出某些关于总体的假设。</li><li>4、行动：根据样本对所提出的假设作出是接受还是拒绝的决策</li></ul> 
<p><strong>问题：</strong>假设检验在机器学习的【比较检验】中究竟如何应用呢？</p> 
<p><strong>分为四步加以分析</strong>：</p> 
<p><img alt="" height="358" src="https://images2.imgbox.com/3d/35/RBuBWeoJ_o.png" width="894"></p> 
<h4 id="%EF%BC%881%EF%BC%89%E4%BC%B0%E8%AE%A1%E5%81%87%E8%AE%BE%E7%B2%BE%E5%BA%A6">（1）估计假设精度</h4> 
<p><strong>在评估一个假设时，我们一般更感兴趣：</strong>    </p> 
<p>        估计其对未来实例的分类精度     知道这一精度估计中的可能的误差（即与此估计相联系的误差门限）</p> 
<p><strong>定义学习问题的框架如下</strong>：</p> 
<p>        有一多有可能实例的空间X，其上定义了多个目标函数。假定X中不同实例具有不同的出现频率，即存在一个未知的概率分布D。学习任务是在假设空间H上学习一个目标函数f。</p> 
<p><strong>确切区分两种精度（或两种错误率）：</strong></p> 
<p style="text-align:center;"><img alt="" height="97" src="https://images2.imgbox.com/e9/55/M7Y3iFKT_o.png" width="502"></p> 
<p><strong>离散值假设的置信区间</strong>：</p> 
<p>要基于某离散值假设h 在样本S 上观察到的样本错误率，估计 它的真实错误率，其中：</p> 
<blockquote> 
 <p>样本S 包含n 个样例，它们的抽取按照概率分布D，抽取过程是相互独立的，并且不依赖于h</p> 
 <p>n≥30</p> 
 <p>假设h 在这n 个样例上犯了r 个错误（errorS(h)=r/n）</p> 
</blockquote> 
<h4 id="%EF%BC%882%EF%BC%89%E9%87%87%E6%A0%B7%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80">（2）采样理论基础</h4> 
<p style="text-align:center;"><img alt="" height="301" src="https://images2.imgbox.com/4e/ea/togd2QSm_o.png" width="571"></p> 
<p>        测量样本错误率相当于在作一个有随机输出的实验。我们先从分布D 中随机抽取出n 个独立的实例，形成样本S，然后测量样本错误率errorS(h) ，如果将实验重复多次，每次抽取大小为n 的不同的样本Si，将可以得到不同的errorSi(h)的值，它取决于不同Si 的组成中的随机差异。这种情况下，第i 个这样的实验的输出errorSi(h)被称为一随机变量（random variable）。一般情况下，可以将随机变量看成一个有随机输出的实验。</p> 
<p>        设想要运行 k 个这样的随机实验，测量随机变量errorS1(h) ，errorS2(h)，⋯⋯，errorSk(h)。 然后我们以图表的形式显示出观察到的每个错误率值的频率。当k 不断增长，该图表将呈现二项分布。</p> 
<p style="text-align:center;"><img alt="" height="196" src="https://images2.imgbox.com/42/60/CKkezPUj_o.png" width="418"></p> 
<p style="text-align:center;"><img alt="" height="289" src="https://images2.imgbox.com/1e/60/bGxDe4Gf_o.png" width="548"></p> 
<p><strong> 即对于足够大的样本，二项分布可以很好地由正态分布来近似</strong>：</p> 
<p style="text-align:center;"><img alt="" height="208" src="https://images2.imgbox.com/bc/f4/3OGFgld4_o.png" width="407"></p> 
<p style="text-align:center;"><img alt="" height="85" src="https://images2.imgbox.com/15/12/zfYGIrPU_o.png" width="234"></p> 
<p style="text-align:center;"><img alt="" height="247" src="https://images2.imgbox.com/c0/cd/Qe44PGx0_o.png" width="457"></p> 
<p><strong>置信区间</strong>：某个参数 p 的N％置信区间是一个以N％的概率包含p 的区间</p> 
<p><strong>推导置信区间的一般方法</strong>：</p> 
<ol><li>确定基准总体中要估计的参数p，例如errorD(h)。</li><li>定义一个估计量Y（如errorS(h)）它的选择应为最小方差的无偏估计量。</li><li>确定估计量所服从的概率分布DY，包括其均值和方差。</li><li>确定N％置信区间，通过寻找阈值L 和U 以使这个按DY 分布的随机变量有N％机会落入L 和U 之间。</li></ol> 
<p style="text-align:center;"><img alt="" height="187" src="https://images2.imgbox.com/f8/80/VjZeEfTj_o.png" width="545"></p> 
<p style="text-align:center;"><img alt="" height="313" src="https://images2.imgbox.com/9c/e5/o2tRDUbj_o.png" width="600"></p> 
<p> 在包含了 m 个样本的测试集上，【泛化错误率为ϵ的学习器】被测得测试错误率为ϵ ̂ 的概率为：</p> 
<p style="text-align:center;"><img alt="" height="57" src="https://images2.imgbox.com/5c/80/5qOwOECC_o.png" width="344"></p> 
<p> 给定泛化错误率后，测试错误率与样本数的乘积（即测试错误数）是一个典型的二项分布</p> 
<p style="text-align:center;"><img alt="" height="72" src="https://images2.imgbox.com/c0/83/Y5v4LMuB_o.png" width="189"></p> 
<p style="text-align:center;"><img alt="" height="29" src="https://images2.imgbox.com/ed/30/wIN8VPeG_o.png" width="432"></p> 
<h4 id="%C2%A0%EF%BC%883%EF%BC%89%E5%A4%9A%E6%AC%A1%E8%AE%AD%E7%BB%83%2F%E6%B5%8B%E8%AF%95%E7%9A%84%E6%A3%80%E9%AA%8C-t%E6%A3%80%E9%AA%8C"> （3）多次训练/测试的检验-t检验</h4> 
<p><img alt="" height="53" src="https://images2.imgbox.com/a4/6d/NuouYWL9_o.png" width="550"></p> 
<p> </p> 
<p></p> 
<p style="text-align:center;"><img alt="" height="76" src="https://images2.imgbox.com/59/65/kWZJv81k_o.png" width="147"></p> 
<p style="text-align:center;"><img alt="" height="84" src="https://images2.imgbox.com/79/f2/bzpmcN57_o.png" width="273"></p> 
<p> 考虑到这 k个测试错误率可以看做泛化错误率ϵ的独立采样，则变量：</p> 
<p style="text-align:center;"><img alt="" height="69" src="https://images2.imgbox.com/24/98/HwVYAhsu_o.png" width="187"></p> 
<p> 服从自由度为 k−1的t分布。</p> 
<h4 id="%EF%BC%884%EF%BC%89%E4%BA%A4%E5%8F%89%E9%AA%8C%E8%AF%81%20t%20%E6%A3%80%E9%AA%8C">（4）交叉验证 t 检验</h4> 
<p>对两个学习器A和B，使用 k 折交叉验证法得到的测试错误率分别为ϵ i A \epsilon_i^AϵiA​和ϵ i B \epsilon_i^BϵiB​。<br> 对 k 折交叉验证产生的 k 对测试错误率:先对每对结果求差，Δ i = ϵ i A − ϵ i B \Delta_i=\epsilon_i^A-\epsilon_i^BΔi​=ϵiA​−ϵiB​, 若两个学习器性能相同，则差值均值班为零。对"学习器 A 与 B 性能相同"这个假设做 t 检验，在显著度 α 下，若变量为：<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/a8/70/j0bqrsbp_o.png"><br> 小于临界值则假设不能被拒绝，即认为两个学习器的性能没有显著差差别; 否则可认为两个学习器的性能有显著差别，且平均错误率较小的那个学习 器性能较优。</p> 
<h4 id="%EF%BC%885%EF%BC%89McNemar%20%E6%A3%80%E9%AA%8C"><a name="t4"></a><a id="McNemar__24"></a>（5）McNemar 检验</h4> 
<p>学习器 A 和 B 的测试错误率列联表为：</p> 
<p style="text-align:center;"><img alt="" height="198" src="https://images2.imgbox.com/75/1a/UOvtx7Wn_o.png" width="409"></p> 
<p>我们可以构建自由度为 1 的 χ2 分布，</p> 
<p style="text-align:center;"><img alt="在这里插入图片描述" height="72" src="https://images2.imgbox.com/4b/44/zgOpaIbs_o.png" width="523"></p> 
<h4 id="%EF%BC%886%EF%BC%89Friedman%E6%A3%80%E9%AA%8C%E4%B8%8E%20Nemenyi%E5%90%8E%E7%BB%AD%E6%A3%80%E9%AA%8C"><a name="t5"></a><a id="Friedman_Nemenyi_29"></a>（6）Friedman检验与 Nemenyi后续检验</h4> 
<p>        为解决一组数据集上的多个算法比较，我们构建基于算法排序的Friedman 检验。</p> 
<p style="text-align:center;"><img alt="在这里插入图片描述" height="148" src="https://images2.imgbox.com/4c/c4/sf8dotlF_o.png" width="488"></p> 
<p>        N是数据集的个数，k是算法的个数。在 k 和 N 都较大时，服从自由度为 k-1 的 χ2 分布.<br> 常用的Friedman 检验为：</p> 
<p style="text-align:center;"><img alt="" height="91" src="https://images2.imgbox.com/e5/19/g9W6khtK_o.png" width="282"></p> 
<p>        若"所有算法的性能相同"这个假设被拒绝，则说明算法的性能显著不同.这时需进行"后续检验" (post-hoc test)来进一步区分各算法.常用的有 Nemenyi 后续检验。<br> Nemenyi 检验计算出平均序值差别的临界值域：</p> 
<p style="text-align:center;"><img alt="" height="81" src="https://images2.imgbox.com/01/20/ki3HINz3_o.png" width="254"></p> 
<h2 id="%C2%A0%E4%BA%94%E3%80%81%E5%81%8F%E5%B7%AE%E4%B8%8E%E6%96%B9%E5%B7%AE"> 五、偏差与方差</h2> 
<p style="text-align:center;"><img alt="" height="207" src="https://images2.imgbox.com/4a/dd/MxrHqnPm_o.png" width="542"></p> 
<p> <strong>偏差</strong>：指的是预测的期望值与真实值的偏差，度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力；（准确度）</p> 
<p><strong>方差</strong>：每一次预测值与预测值的期望之间的差均方，度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响；（稳定性）</p> 
<p><strong>噪声</strong>：表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。（难度）</p> 
<p style="text-align:center;"><img alt="" height="53" src="https://images2.imgbox.com/f1/ea/4bbhYhNr_o.png" width="453"></p> 
<p><strong>偏差一方差分解说明</strong>，泛化性能是由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定的。 </p> 
<p><strong>偏差-方差窘境</strong>：</p> 
<p style="text-align:center;"><img alt="" height="231" src="https://images2.imgbox.com/93/bd/ZJKwczvW_o.png" width="356"></p> 
<p><strong>此图说明了什么问题呢？</strong></p> 
<p style="text-align:center;"><img alt="" height="72" src="https://images2.imgbox.com/ea/87/N86CTnwK_o.png" width="310"></p> 
<p>         给出了寻找最优平衡点的数学描述。若模型复杂度大于平衡点，则模型的方差会偏高，模型倾向于过拟合；若模型复杂度小于平衡点，则模型的偏差会偏高，模型倾向于欠拟合。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6c7a7d0ed710d2fbc23f4360551a038a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spark课程设计——电影推荐系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0506fce3e2c6d62cc04d59390b16f1cd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【OpenCV-Python】29.OpenCV的特征检测——特征匹配</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>