<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>DeepLabV3&#43;：Mobilenetv2的改进以及浅层特征和深层特征的融合 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="DeepLabV3&#43;：Mobilenetv2的改进以及浅层特征和深层特征的融合" />
<meta property="og:description" content="目录
Mobilenetv2的改进
浅层特征和深层特征的融合
完整代码
参考资料
Mobilenetv2的改进 在DeeplabV3当中，一般不会5次下采样，可选的有3次下采样和4次下采样。因为要进行五次下采样的话会损失较多的信息。
在这里mobilenetv2会从之前写好的模块中得到，但注意的是，我们在这里获得的特征是[-1]，也就是最后的1x1卷积不取，只取循环完后的模型。
down_idx是InvertedResidual进行的次数。
# t, c, n, s [1, 16, 1, 1], [6, 24, 2, 2], 2 [6, 32, 3, 2], 4 [6, 64, 4, 2], 7 [6, 96, 3, 1], [6, 160, 3, 2], 14 [6, 320, 1, 1], 根据下采样的不同，当downsample_factor=8时，进行3次下采样，对倒数两次，步长为2的InvertedResidual进行参数的修改，让步长变为1，膨胀系数为2。
当downsample_factor=16时，进行4次下采样，只需对最后一次进行参数的修改。
import torch import torch.nn as nn import torch.nn.functional as F from functools import partial from net.mobilenetv2 import mobilenetv2 from net.ASPP import ASPP class MobileNetV2(nn." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d88dbd2b8f57318d6b7d78b9a359e512/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-16T16:26:03+08:00" />
<meta property="article:modified_time" content="2023-02-16T16:26:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">DeepLabV3&#43;：Mobilenetv2的改进以及浅层特征和深层特征的融合</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="Mobilenetv2%E7%9A%84%E6%94%B9%E8%BF%9B-toc" style="margin-left:0px;"><a href="#Mobilenetv2%E7%9A%84%E6%94%B9%E8%BF%9B" rel="nofollow">Mobilenetv2的改进</a></p> 
<p id="%E6%B5%85%E5%B1%82%E7%89%B9%E5%BE%81%E5%92%8C%E6%B7%B1%E5%B1%82%E7%89%B9%E5%BE%81%E7%9A%84%E8%9E%8D%E5%90%88-toc" style="margin-left:0px;"><a href="#%E6%B5%85%E5%B1%82%E7%89%B9%E5%BE%81%E5%92%8C%E6%B7%B1%E5%B1%82%E7%89%B9%E5%BE%81%E7%9A%84%E8%9E%8D%E5%90%88" rel="nofollow">浅层特征和深层特征的融合</a></p> 
<p id="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81-toc" style="margin-left:0px;"><a href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81" rel="nofollow">完整代码</a></p> 
<p id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99-toc" style="margin-left:0px;"><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" rel="nofollow">参考资料</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="Mobilenetv2%E7%9A%84%E6%94%B9%E8%BF%9B">Mobilenetv2的改进</h2> 
<p><span style="color:#ed7976;"><strong>在DeeplabV3当中，一般不会5次下采样，可选的有3次下采样和4次下采样。因为要进行五次下采样的话会损失较多的信息。</strong></span></p> 
<p>在这里mobilenetv2会从之前写好的模块中得到，但注意的是，我们在这里获得的特征是[-1]，也就是最后的1x1卷积不取，只取循环完后的模型。</p> 
<p>down_idx是InvertedResidual进行的次数。</p> 
<pre><code class="language-python"># t, c, n, s
[1, 16, 1, 1], 
[6, 24, 2, 2],    2
[6, 32, 3, 2],    4
[6, 64, 4, 2],    7  
[6, 96, 3, 1],
[6, 160, 3, 2],   14
[6, 320, 1, 1], </code></pre> 
<p>根据下采样的不同，当downsample_factor=8时，进行3次下采样，对倒数两次，步长为2的InvertedResidual进行参数的修改，让步长变为1，膨胀系数为2。</p> 
<p>当downsample_factor=16时，进行4次下采样，只需对最后一次进行参数的修改。</p> 
<pre><code class="language-python">import torch
import torch.nn as nn
import torch.nn.functional as F
from functools import partial

from net.mobilenetv2 import mobilenetv2
from net.ASPP import ASPP

class MobileNetV2(nn.Module):
    def __init__(self, downsample_factor=8, pretrained=True):
        super(MobileNetV2, self).__init__()
        
        model           = mobilenetv2(pretrained)
        self.features   = model.features[:-1]

        self.total_idx  = len(self.features)
        self.down_idx   = [2, 4, 7, 14]

        if downsample_factor == 8:
            for i in range(self.down_idx[-2], self.down_idx[-1]):
                self.features[i].apply(
                    partial(self._nostride_dilate, dilate=2)
                )
            for i in range(self.down_idx[-1], self.total_idx):
                self.features[i].apply(
                    partial(self._nostride_dilate, dilate=4)
                )
        elif downsample_factor == 16:
            for i in range(self.down_idx[-1], self.total_idx):
                self.features[i].apply(
                    partial(self._nostride_dilate, dilate=2)
                )
        
    def _nostride_dilate(self, m, dilate):
        classname = m.__class__.__name__
        if classname.find('Conv') != -1:
            if m.stride == (2, 2):
                m.stride = (1, 1)
                if m.kernel_size == (3, 3):
                    m.dilation = (dilate//2, dilate//2)
                    m.padding = (dilate//2, dilate//2)
            else:
                if m.kernel_size == (3, 3):
                    m.dilation = (dilate, dilate)
                    m.padding = (dilate, dilate)

    def forward(self, x):
        low_level_features = self.features[:4](x)
        x = self.features[4:](low_level_features)
        return low_level_features, x</code></pre> 
<p>forward当中，会输出两个特征层，一个是浅层特征层，具有浅层的语义信息；另一个是深层特征层，具有深层的语义信息。</p> 
<h2 id="%E6%B5%85%E5%B1%82%E7%89%B9%E5%BE%81%E5%92%8C%E6%B7%B1%E5%B1%82%E7%89%B9%E5%BE%81%E7%9A%84%E8%9E%8D%E5%90%88">浅层特征和深层特征的融合</h2> 
<p><img alt="" height="591" src="https://images2.imgbox.com/66/38/6Oj3s5up_o.png" width="1092"></p> 
<p> 具有高语义信息的部分先进行上采样，低语义信息的特征层进行1x1卷积，二者进行特征融合，再进行3x3卷积进行特征提取</p> 
<pre><code class="language-python">self.aspp = ASPP(dim_in=in_channels, dim_out=256, rate=16//downsample_factor)</code></pre> 
<p>这一步就是获得那个绿色的特征层；</p> 
<pre><code class="language-python">low_level_features = self.shortcut_conv(low_level_features)</code></pre> 
<p>从这里将是对浅层特征的初步处理（1x1卷积）；</p> 
<pre><code class="language-python">x = F.interpolate(x, size=(low_level_features.size(2), low_level_features.size(3)), mode='bilinear', align_corners=True)
x = self.cat_conv(torch.cat((x, low_level_features), dim=1))</code></pre> 
<p>上采样后进行特征融合，这样我们输入和输出的大小才相同，每一个像素点才能进行预测；</p> 
<p></p> 
<h2 id="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81">完整代码</h2> 
<pre><code class="language-python"># deeplabv3plus.py

import torch
import torch.nn as nn
import torch.nn.functional as F
from functools import partial

from net.xception import xception
from net.mobilenetv2 import mobilenetv2
from net.ASPP import ASPP

class MobileNetV2(nn.Module):
    def __init__(self, downsample_factor=8, pretrained=True):
        super(MobileNetV2, self).__init__()
        
        model           = mobilenetv2(pretrained)
        self.features   = model.features[:-1]

        self.total_idx  = len(self.features)
        self.down_idx   = [2, 4, 7, 14]

        if downsample_factor == 8:
            for i in range(self.down_idx[-2], self.down_idx[-1]):
                self.features[i].apply(
                    partial(self._nostride_dilate, dilate=2)
                )
            for i in range(self.down_idx[-1], self.total_idx):
                self.features[i].apply(
                    partial(self._nostride_dilate, dilate=4)
                )
        elif downsample_factor == 16:
            for i in range(self.down_idx[-1], self.total_idx):
                self.features[i].apply(
                    partial(self._nostride_dilate, dilate=2)
                )
        
    def _nostride_dilate(self, m, dilate):
        classname = m.__class__.__name__
        if classname.find('Conv') != -1:
            if m.stride == (2, 2):
                m.stride = (1, 1)
                if m.kernel_size == (3, 3):
                    m.dilation = (dilate//2, dilate//2)
                    m.padding = (dilate//2, dilate//2)
            else:
                if m.kernel_size == (3, 3):
                    m.dilation = (dilate, dilate)
                    m.padding = (dilate, dilate)

    def forward(self, x):
        low_level_features = self.features[:4](x)
        x = self.features[4:](low_level_features)
        return low_level_features, x

class DeepLab(nn.Module):
    def __init__(self, num_classes, backbone="mobilenet", pretrained=True, downsample_factor=16):
        super(DeepLab, self).__init__()
        if backbone=="xception":
         
            #   获得两个特征层：浅层特征 主干部分    
            self.backbone = xception(downsample_factor=downsample_factor, pretrained=pretrained)
            in_channels = 2048
            low_level_channels = 256
        elif backbone=="mobilenet":

            #   获得两个特征层：浅层特征 主干部分
            self.backbone = MobileNetV2(downsample_factor=downsample_factor, pretrained=pretrained)
            in_channels = 320
            low_level_channels = 24
        else:
            raise ValueError('Unsupported backbone - `{}`, Use mobilenet, xception.'.format(backbone))

        #   ASPP特征提取模块
        #   利用不同膨胀率的膨胀卷积进行特征提取
        self.aspp = ASPP(dim_in=in_channels, dim_out=256, rate=16//downsample_factor)
       
        # 浅层特征边
        self.shortcut_conv = nn.Sequential(
            nn.Conv2d(low_level_channels, 48, 1),
            nn.BatchNorm2d(48),
            nn.ReLU(inplace=True)
        )		

        self.cat_conv = nn.Sequential(
            nn.Conv2d(48+256, 256, kernel_size=(3,3), stride=(1,1), padding=1),
            nn.BatchNorm2d(256),
            nn.ReLU(inplace=True),
            nn.Dropout(0.5),

            nn.Conv2d(256, 256, kernel_size=(3,3), stride=(1,1), padding=1),
            nn.BatchNorm2d(256),
            nn.ReLU(inplace=True),

            nn.Dropout(0.1),
        )
        self.cls_conv = nn.Conv2d(256, num_classes, kernel_size=(1,1), stride=(1,1))

    def forward(self, x):
        H, W = x.size(2), x.size(3)

        # 获得两个特征层，low_level_features: 浅层特征-进行卷积处理
        #                x : 主干部分-利用ASPP结构进行加强特征提取
  
        low_level_features, x = self.backbone(x)
        x = self.aspp(x)
        low_level_features = self.shortcut_conv(low_level_features)

        #   将加强特征边上采样，与浅层特征堆叠后利用卷积进行特征提取
        x = F.interpolate(x, size=(low_level_features.size(2), low_level_features.size(3)), mode='bilinear', align_corners=True)
        x = self.cat_conv(torch.cat((x, low_level_features), dim=1))
        x = self.cls_conv(x)
        x = F.interpolate(x, size=(H, W), mode='bilinear', align_corners=True)
        return x

</code></pre> 
<h2 id="%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99">参考资料</h2> 
<p><a href="https://github.com/Auorui/DeepLabV3-/tree/main/%E8%AE%BA%E6%96%87%E7%B2%BE%E9%80%89" title="DeepLabV3-/论文精选 at main · Auorui/DeepLabV3- (github.com)">DeepLabV3-/论文精选 at main · Auorui/DeepLabV3- (github.com)</a></p> 
<p><a href="https://blog.csdn.net/weixin_44791964/article/details/120113686" title="(6条消息) 憨批的语义分割重制版9——Pytorch 搭建自己的DeeplabV3+语义分割平台_Bubbliiiing的博客-CSDN博客">(6条消息) 憨批的语义分割重制版9——Pytorch 搭建自己的DeeplabV3+语义分割平台_Bubbliiiing的博客-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3118fd48382c667f96076302454d2493/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">存储性能软件加速库（SPDK）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0b53998282b1408bd2a0eac8a8629ff7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于java.io使用相对路径读取文件找不到文件但是文件存在的解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>