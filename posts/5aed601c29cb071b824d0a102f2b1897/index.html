<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Postgresql 14配置文件解释说明 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Postgresql 14配置文件解释说明" />
<meta property="og:description" content="Postgresql 14配置文件postgresql.conf的解释说明 Postgresql 14配置文件，配置项翻译及解释说明 [suntoon@postgres14 data]# sudo nano postgresql.conf #----------------------------- # PostgreSQL configuration file #----------------------------- # #This file consists of lines of the form: # #name = value # #(The &#34;=&#34; is optional.) Whitespace may be used. Comments are introduced with #&#34;#&#34; anywhere on a line. The complete list of parameter names and allowed #values can be found in the PostgreSQL documentation.Shared Library Preloading # #The commented-out settings shown in this file represent the default values." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5aed601c29cb071b824d0a102f2b1897/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-28T09:55:21+08:00" />
<meta property="article:modified_time" content="2023-04-28T09:55:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Postgresql 14配置文件解释说明</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="Postgresql_14postgresqlconf_0"></a>Postgresql 14配置文件postgresql.conf的解释说明</h4> 
<pre><code>Postgresql 14配置文件，配置项翻译及解释说明
[suntoon@postgres14 data]# sudo nano postgresql.conf 
#-----------------------------
# PostgreSQL configuration file
#-----------------------------
#
#This file consists of lines of the form:
#
#name = value
#
#(The "=" is optional.)  Whitespace may be used.  Comments are introduced with
#"#" anywhere on a line.  The complete list of parameter names and allowed
#values can be found in the PostgreSQL documentation.Shared Library Preloading
#
#The commented-out settings shown in this file represent the default values.
#Re-commenting a setting is NOT sufficient to revert it to the default value;
#you need to reload the server.
#
#This file is read on server startup and when the server receives a SIGHUP
#signal.  If you edit the file on a running system, you have to SIGHUP the
#server for the changes to take effect, run "pg_ctl reload", or execute
#"SELECT pg_reload_conf()".  Some parameters, which are marked below,
#require a server shutdown and restart to take effect.
#
#Any parameter can also be given as a command-line option to the server, e.g.,
#"postgres -c log_connections=on".  Some parameters can be changed at run time
#with the "SET" SQL command.
#
#Memory units:  B  = bytes            Time units:  us  = microseconds
#kB = kilobytes                     ms  = milliseconds
#MB = megabytes                     s   = seconds
#GB = gigabytes                     min = minutes
#TB = terabytes                     h   = hours
#d   = days


#------------------------------------------------------------------------------
## FILE LOCATIONS
#------------------------------------------------------------------------------
#除了已经提到的 postgresql.conf 文件之外，PostgreSQL 还使用了另外两个手动编辑的配置文件，它们控制客户端身份验证
#默认情况下，所有三个配置文件都存储在数据库集群的数据目录中。
#本节中描述的参数允许将配置文件放置在其他地方。 
#这样做可以简化管理。尤其是当配置文件分开保存时，通常更容易确保它们得到正确备份。）
#The default values of these variables are driven from the -D command-line
#option or PGDATA environment variable, represented here as ConfigDir.

#data_directory = 'ConfigDir'           # use data in another directory
                                        # (change requires restart)
					# 指定用于数据存储的目录。此参数只能在服务器启动时设置。
#hba_file = 'ConfigDir/pg_hba.conf'     # host-based authentication file
                                        # (change requires restart)
					# 指定基于主机的身份验证的配置文件（通常称为 pg_hba.conf）。
					# 此参数只能在服务器启动时设置。
#ident_file = 'ConfigDir/pg_ident.conf' # ident configuration file
                                        # (change requires restart)
					# 指定用户名映射的配置文件（通常称为 pg_ident.conf）。此参数只能在服务器启动时设置。

#If external_pid_file is not explicitly set, no extra PID file is written.
#external_pid_file = ''                 # write an extra PID file
                                        # (change requires restart)
					# 指定服务器应创建以供服务器管理程序使用的附加进程 ID (PID) 文件的名称。此参数只能在服务器启动时设置。



#在默认安装中，上述参数均未明确设置。相反，数据目录由 -D 命令行选项或 PGDATA 环境变量指定，配置文件都在数据目录中。
#如果您希望将配置文件保存在数据目录以外的其他位置，postgres -D 命令行选项或 PGDATA 环境变量必须指向包含配置文件的目录，
#并且 data_directory 参数必须在 postgresql.conf 中设置（或命令行）来显示数据目录的实际位置。
#请注意，data_directory 覆盖了数据目录位置的 -D 和 PGDATA，但没有覆盖配置文件的位置。

#如果您愿意，可以使用参数 config_file、hba_file 和/或 ident_file 分别指定配置文件的名称和位置。
#config_file (string)	指定主服务器配置文件（通常称为 postgresql.conf）。此参数只能在 postgres 命令行上设置。
#config_file 只能在 postgres 命令行中指定，但其他可以在主配置文件中设置。
#如果所有三个参数加上 data_directory 都被显式设置，则不需要指定 -D 或 PGDATA。

#设置任何这些参数时，将相对于启动 postgres 的目录解释相对路径。

#------------------------------------------------------------------------------
## CONNECTIONS AND AUTHENTICATION
#------------------------------------------------------------------------------

### - Connection Settings -

listen_addresses = '*'          # what IP address(es) to listen on;
                                        # comma-separated list of addresses;
                                        # defaults to 'localhost'; use '*' for all
                                        # (change requires restart)
										# 指定服务器用于侦听来自客户端应用程序的连接的 TCP/IP 地址。
										# 该值采用逗号分隔的主机名和/或数字 IP 地址列表的形式。
										# 特殊条目 * 对应于所有可用的 IP 接口。
										# 条目 0.0.0.0 允许监听所有 IPv4 地址， :: 允许监听所有 IPv6 地址。
										# 如果列表为空，则服务器根本不会侦听任何 IP 接口，在这种情况下，只能使用 Unix 域套接字连接到它。
										# 默认值为 localhost，它只允许建立本地 TCP/IP “环回”连接。
										# 虽然客户端身份验证（第 21 章）允许对谁可以访问服务器进行细粒度控制，但 listen_addresses 控制哪些接口接受连接尝试，
										# 这有助于防止在不安全的网络接口上重复的恶意连接请求。此参数只能在服务器启动时设置。
port = 1931                             # (change requires restart)
										# 服务器监听的 TCP 端口；默认为 5432。请注意，服务器侦听的所有 IP 地址都使用相同的端口号。此参数只能在服务器启动时设置。
max_connections = 100                   # (change requires restart)
										# 确定与数据库服务器的最大并发连接数。
										# 默认值通常为 100 个连接，但如果您的内核设置不支持它可能会更少（在 initdb 期间确定）。
										# 此参数只能在服务器启动时设置。
#superuser_reserved_connections = 3     # (change requires restart)  超级用户预留连接数
#unix_socket_directories = '/tmp'       # comma-separated list of directories 默认值通常是/ tmp，但可以在构建时更改。 
                                        # (change requires restart)
#unix_socket_group = ''                 # (change requires restart)  设置Unix域套接字的拥有组 默认情况下，这是空字符串，它使用服务器用户的默认组
#unix_socket_permissions = 0777         # begin with 0 to use octal notation  设置Unix域套接字的访问权限
                                        # (change requires restart)
#bonjour = off                          # advertise server via Bonjour  通过Bonjour启用服务器存在的广告。 默认是关闭的。
                                        # (change requires restart)
#bonjour_name = ''                      # defaults to the computer name  指定Bonjour服务名称。 如果此参数设置为空字符串”（这是默认值），则使用计算机名称。
                                        # (change requires restart)

### - TCP settings -
#see "man tcp" for details

#tcp_keepalives_idle = 0                # TCP_KEEPIDLE, in seconds; 指定TCP在发送Keepalive消息给客户端之后不活动的秒数。 值为0时使用系统默认值。 
                                        # 0 selects the system default 此参数仅在支持TCP_KEEPIDLE或等效套接字选项的系统上以及在Windows上受支持; 在其他系统上，
										#它必须是零。 
										# 在通过Unix域套接字连接的会话中，该参数将被忽略并始终读为零。
#tcp_keepalives_interval = 0            # TCP_KEEPINTVL, in seconds; 指定客户端未确认的TCP保持活动消息应重新传输的秒数。 值为0时使用系统默认值。 
										#此参数仅在支持TCP_KEEPINTVL或等效套接字选项的系统上以及在Windows上受支持; 在其他系统上，它必须是零。 
										#在通过Unix域套接字连接的会话中，该参数将被忽略并始终读为零。
                                        # 0 selects the system default
#tcp_keepalives_count = 0               # TCP_KEEPCNT;   指定在服务器连接到客户端之前可能丢失的TCP保持活动的数量已被终止。 
										#值为0时使用系统默认值。 此参数仅在支持TCP_KEEPCNT或等效套接字选项的系统上受支持; 在其他系统上，它必须是零。 
										#在通过Unix域套接字连接的会话中，该参数将被忽略并始终读为零。
                                        # 0 selects the system default
#tcp_user_timeout = 0                   # TCP_USER_TIMEOUT, in milliseconds;
                                        # 0 selects the system default
										# 在强制关闭 TCP 连接之前，指定传输数据可能保持未确认的时间量
										# 如果指定此值没有单位，则以毫秒为单位。值 0（默认值）选择操作系统的默认值。
										# 此参数仅在支持 TCP_USER_TIMEOUT 的系统上受支持；在其他系统上，它必须为零。
										# 在通过 Unix 域套接字连接的会话中，此参数被忽略并始终读取为零。

#client_connection_check_interval = 0   # time between checks for client
                                        # disconnection while running queries;
                                        # 0 for never

#### - Authentication -

#authentication_timeout = 1min          # 1s-600s  这个参数只能在postgresql.conf文件中被设置，它指定一个时间长度，在这个时间长度内，必须完成客户端认证操作，
										#否则客户端连接请求将被拒绝。它可以阻止某些客户端进行认证时长时间占用数据库连接。单位是秒，默认值是60。
#password_encryption = scram-sha-256    # scram-sha-256 or md5
#db_user_namespace = off				#此参数启用每个数据库用户名。它默认关闭。该参数只能在postgresql.conf文件或服务器命令行中设置。
										#如果这样，您应该将用户创建为username @ dbname。当连接客户端传递用户名时，@和数据库名称将附加到用户名中，
										#并且该服务器会查找特定于数据库的用户名。请注意，当您在SQL环境中创建名称包含@的用户时，您需要引用用户名。
										#启用此参数后，您仍然可以创建普通的全局用户。在客户端指定用户名时简单追加@，例如乔@。在用户名被服务器查找之前，@将被剥离。
										#db_user_namespace导致客户端和服务器的用户名表示方式不同。身份验证检查始终使用服务器的用户名完成，
										#因此必须为服务器的用户名配置身份验证方法，而不是客户端。因为md5在客户端和服务器上均使用用户名作为salt，
										#所以md5不能与db_user_namespace一起使用。


#### GSSAPI using Kerberos
#krb_server_keyfile = 'FILE:${sysconfdir}/krb5.keytab' 
										#设置Kerberos服务器密钥文件的位置。 该参数只能在postgresql.conf文件或服务器命令行中设置。
#krb_caseins_users = off				#设置是否应该区分大小写地处理GSSAPI用户名。 默认是关闭的（区分大小写）。 
										#该参数只能在postgresql.conf文件或服务器命令行中设置。

### - SSL -

#ssl = off  							#这个参数只有在启动数据库时，才能被设置。决定数据库是否接受SSL连接。默认值是off。
#ssl_ca_file = ''						#指定包含SSL服务器证书颁发机构（CA）的文件的名称。 缺省值为空，表示未加载CA文件，并且不执行客户端证书验证。 
										#（在以前的PostgreSQL版本中，这个文件的名称被硬编码为root.crt。）相对路径是相对于数据目录的。 
										#该参数只能在服务器启动时设置。
#ssl_cert_file = 'server.crt'			#指定包含SSL服务器证书的文件的名称。 缺省值是server.crt。 相对路径与数据目录有关。 该参数只能在服务器启动时设置。
#ssl_crl_file = ''						#指定包含SSL服务器证书吊销列表（CRL）的文件的名称。 缺省值为空，表示没有加载CRL文件。 
										#（在以前的PostgreSQL版本中，该文件的名称被硬编码为root.crl。）相对路径与数据目录相关。 该参数只能在服务器启动时设置。
#ssl_crl_dir = ''
#ssl_key_file = 'server.key'			#指定包含SSL服务器私钥的文件的名称。 缺省值是server.key。 相对路径与数据目录有关。 该参数只能在服务器启动时设置。
#ssl_ciphers = 'HIGH:MEDIUM:+3DES:!aNULL' # allowed SSL ciphers  #指定可以使用的SSL加密算法。
										#查看操作系统关于openssl的用户手册可以得到完整的加密算法列表（执行命令openssl ciphers –v也可以得到）。
#ssl_prefer_server_ciphers = on			# 指定是否使用服务器的 SSL 密码首选项，而不是客户端的。此参数只能在 postgresql.conf 文件或服务器命令行中设置。默认为开启。
										# 较旧的 PostgreSQL 版本没有此设置，并且始终使用客户端的首选项。此设置主要是为了向后兼容这些版本。
										# 使用服务器的首选项通常会更好，因为服务器配置得当的可能性更大。
#ssl_ecdh_curve = 'prime256v1'
#ssl_min_protocol_version = 'TLSv1.2'
#ssl_max_protocol_version = ''
#ssl_dh_params_file = ''
#ssl_passphrase_command = ''
#ssl_passphrase_command_supports_reload = off


#------------------------------------------------------------------------------
## RESOURCE USAGE (except WAL)
#------------------------------------------------------------------------------

### - Memory -

shared_buffers = 128MB                  # min 128kB		共享缓存区大小 不应超过总内存1/4  一般为1/8
                                        # (change requires restart)
#huge_pages = try                       # on, off, or try 当为try时，未开启大页或分配大页内存太小，数据库仍能启动，但不使用大页；当on时不能分配足够内存时，启动失败
                                        # (change requires restart)
#huge_page_size = 0                     # zero for system default
                                        # (change requires restart)
		#当使用huge_pages 启用大页面时，控制大页面的大小。默认为零 (0)。
		#当设置为 0 时，将使用系统上默认的超大页面大小。此参数只能在服务器启动时设置。
#temp_buffers = 8MB                     # min 800kB  
		# 临时表的缓存大小，默认为8M 通常保持默认值就可以
#max_prepared_transactions = 0          # zero disables the feature
                                        # (change requires restart)
#Caution: it is not advisable to set max_prepared_transactions nonzero unless
#you actively intend to use prepared transactions.
										#设置可以同时处于“准备”状态的最大事务数（请参阅 PREPARE TRANSACTION）。
										#将此参数设置为零（这是默认值）将禁用准备事务功能。
										#此参数只能在服务器启动时设置。
										#如果您不打算使用准备好的事务，则应将此参数设置为零以防止意外创建准备好的事务。
										#如果您使用准备好的事务，您可能希望 max_prepared_transactions 至少与 max_connections 一样大，以便每个会话都可以有一个准备好的事务待处理。
#work_mem = 4MB                         # min 64kB 为每个进程单独分配的内存，主要用于排序、HASH等操作
		#在写入临时磁盘文件之前，设置查询操作（例如排序或哈希表）使用的基本最大内存量。如果此值指定为不带单位，则以千字节为单位。
		#默认值为四兆字节 (4MB)。
		#请注意，对于复杂的查询，可能会并行运行多个排序或散列操作；在开始将数据写入临时文件之前，通常允许每个操作使用此值指定的内存量。
		#此外，几个正在运行的会话可以同时执行此类操作。因此，使用的总内存可能是 work_mem 值的许多倍；在选择值时必须牢记这一事实。
		#排序操作用于 ORDER BY、DISTINCT 和合并连接。哈希表用于哈希连接、基于哈希的聚合、结果缓存节点和基于哈希的 IN 子查询处理。

基于哈希的操作通常比等效的基于排序的操作对内存可用性更敏感。可用于哈希表的内存是通过将 work_mem 乘以 hash_mem_multiplier 来计算的。这使得基于散列的操作可以使用超过通常 work_mem 基本数量的内存量。
#hash_mem_multiplier = 1.0              # 1-1000.0 multiplier on hash table work_mem 
										#用于计算基于哈希的操作可以使用的最大内存量。
										#最终限制是通过将 work_mem 乘以 hash_mem_multiplier 来确定的。
										#默认值为 1.0，这使得基于散列的操作服从与基于排序的操作相同的简单 work_mem 最大值。
#maintenance_work_mem = 64MB            # min 1MB
										#指定维护操作使用的最大内存量，例如 VACUUM、CREATE INDEX 和 ALTER TABLE ADD FOREIGN KEY。
										#如果此值指定为不带单位，则以千字节为单位。默认为 64 兆字节 (64MB)。
										#由于数据库会话一次只能执行其中一个操作，并且安装通常不会同时运行许多操作，因此将此值设置为远大于 work_mem 是安全的。
										#较大的设置可能会提高清理和还原数据库转储的性能。
										#请注意，当 autovacuum 运行时，最多可能会分配 autovacuum_max_workers 次此内存，因此请注意不要将默认值设置得太高。
										#通过单独设置 autovacuum_work_mem 来控制这一点可能很有用。
										#请注意，对于死元组标识符的收集，VACUUM 最多只能使用 1GB 的内存。
#autovacuum_work_mem = -1               # min 1MB, or -1 to use maintenance_work_mem
										#指定每个 autovacuum 工作进程要使用的最大内存量。
										#如果此值指定为不带单位，则以千字节为单位。它默认为 -1，表示应该使用 maintenance_work_mem 的值。
										#当在其他上下文中运行时，该设置对 VACUUM 的行为没有影响。
										#此参数只能在 postgresql.conf 文件或服务器命令行中设置。
										#对于死元组标识符的收集，autovacuum 最多只能使用 1GB 内存，
										#因此将 autovacuum_work_mem 设置为高于该值的值不会影响 autovacuum 在扫描表时可以收集的死元组数量。
										
#logical_decoding_work_mem = 64MB       # min 64kB
										#指定在将某些已解码更改写入本地磁盘之前，逻辑解码要使用的最大内存量。
										#这限制了逻辑流复制连接使用的内存量。
										#默认为 64 兆字节 (64MB)。
										#由于每个复制连接仅使用此大小的单个缓冲区，并且安装通常不会同时具有许多此类连接（受 max_wal_senders 限制），
										#因此将此值设置为明显高于 work_mem 是安全的，从而减少写入的解码更改量到磁盘。
										
#max_stack_depth = 2MB                  # min 100kB
										#指定服务器执行堆栈的最大安全深度。
										#此参数的理想设置是内核强制执行的实际堆栈大小限制（由 ulimit -s 或本地等效项设置），减去大约 1 兆字节的安全余量。
										#需要安全边际，因为堆栈深度不会在服务器中的每个例程中检查，而只是在关键的潜在递归例程中检查。
										#如果此值指定为不带单位，则以千字节为单位。默认设置为 2 兆字节 (2MB)，相对较小，不太可能导致崩溃。
										#但是，它可能太小而无法执行复杂的功能。只有超级用户可以更改此设置。
										#将 max_stack_depth 设置为高于实际内核限制将意味着失控的递归函数可能会使单个后端进程崩溃。
										#在 PostgreSQL 可以确定内核限制的平台上，服务器不允许将此变量设置为不安全的值。
										#但是，并非所有平台都提供信息，因此建议在选择值时谨慎。
										
#shared_memory_type = mmap              # the default is the first option
                                        # supported by the operating system:
                                        #   mmap
                                        #   sysv
                                        #   windows
                                        # (change requires restart)
										#指定服务器应该用于保存 PostgreSQL 的共享缓冲区和其他共享数据的主共享内存区域的共享内存实现。
										#可能的值是 mmap（用于使用 mmap 分配的匿名共享内存）、
										#sysv（用于通过 shmget 分配的 System V 共享内存）和 windows（用于 Windows 共享内存）。
										#并非所有平台都支持所有值；第一个支持的选项是该平台的默认选项。
										#通常不鼓励使用 sysv 选项，这在任何平台上都不是默认选项，因为它通常需要非默认内核设置来允许大分配（参见第 19.4.1 节）。
										
dynamic_shared_memory_type = posix      # the default is the first option
                                        # supported by the operating system:
                                        #   posix
                                        #   sysv
                                        #   windows
                                        #   mmap
                                        # (change requires restart)
										# 指定服务器应该使用的动态共享内存实现。
										# 可能的值是 posix（用于使用 shm_open 分配的 POSIX 共享内存）、
										# sysv（用于通过 shmget 分配的 System V 共享内存）、
										# windows（用于 Windows 共享内存）和 
										# mmap（使用存储在数据中的内存映射文件模拟共享内存目录）。
										# 并非所有平台都支持所有值；第一个支持的选项是该平台的默认选项。
										# mmap 选项在任何平台上都不是默认选项，通常不鼓励使用，
										# 因为操作系统可能会反复将修改后的页面写回磁盘，从而增加系统 I/O 负载；
										# 但是，当 pg_dynshmem 目录存储在 RAM 磁盘上或其他共享内存设施不可用时，它可能对调试有用。
										
#min_dynamic_shared_memory = 0MB        # (change requires restart)
										# 指定应在服务器启动时分配以供并行查询使用的内存量。
										# 当此内存区域不足或被并发查询耗尽时，新的并行查询会尝试使用配置了 dynamic_shared_memory_type 的方法临时
										# 从操作系统分配额外的共享内存，由于内存管理开销，这可能会更慢。
										# 在启动时使用 min_dynamic_shared_memory 分配的内存受支持的操作系统上的 huge_pages 设置的影响，
										# 并且可能更有可能从自动管理的操作系统上的较大页面中受益。默认值为 0（无）。此参数只能在服务器启动时设置。

### - Disk -

#temp_file_limit = -1                   # limits per-process temp file space
                                        # in kilobytes, or -1 for no limit
										# 指定进程可用于临时文件（例如排序和散列临时文件）或保留游标的存储文件的最大磁盘空间量。
										# 试图超过此限制的交易将被取消。如果此值指定为不带单位，则以千字节为单位。 -1（默认）表示没有限制。
										# 只有超级用户可以更改此设置。
										# 此设置限制给定 PostgreSQL 进程使用的所有临时文件在任何时刻使用的总空间。
										# 应该注意的是，用于显式临时表的磁盘空间，而不是在查询执行中在幕后使用的临时文件，不计入此限制。

### - Kernel Resources - 内核资源使用

#max_files_per_process = 1000           # min 64
                                        # (change requires restart)
										# 设置每个服务器子进程允许同时打开的文件的最大数量。
										# 默认值为一千个文件。如果内核强制执行每个进程的安全限制，则无需担心此设置。
										# 但是在某些平台上（特别是大多数 BSD 系统），如果许多进程都试图打开那么多文件，
										# 内核将允许单个进程打开比系统实际支持的更多的文件。
										# 如果您发现自己看到“打开的文件太多”失败，请尝试减少此设置。此参数只能在服务器启动时设置。

### - Cost-Based Vacuum Delay -  基于代价的清理延迟
										# 在VACUUM和ANALYZE命令的执行过程中，系统维持着一个内部计数器来跟踪各种被执行的I/O操作的估算开销。
										# 当累计的代价达到一个限制（由vacuum_cost_limit指定），执行这些操作的进程将按照vacuum_cost_delay所指定的休眠一小段时间。
										# 然后它将重置计数器并继续执行。
										# 这个特性的出发点是允许管理员降低这些命令对并发的数据库活动产生的I/O影响。
										# 在很多情况下，VACUUM和ANALYZE等维护命令能否快速完成并不重要，
										# 而非常重要的是这些命令不会对系统执行其他数据库操作的能力产生显著的影响。
										# 基于代价的清理延迟提供了一种方式让管理员能够保证这一点。

										# 对于手动发出的VACUUM命令，该特性默认被禁用。要启用它，只要把vacuum_cost_delay变量设为一个非零值。
#vacuum_cost_delay = 0                  # 0-100 milliseconds (0 disables)
										# 当超出开销限制时进程将要休眠的时间量。如果指定值时没有单位，则以毫秒为单位。 
										# 其默认值为0，这将禁用基于代价的清理延迟特性。正值将启用基于代价的清理。
										# 在使用基于代价的清理时，vacuum_cost_delay的合适值通常很小，也许是小于1毫秒。 
										# 虽然vacuum_cost_delay可以被设置为毫秒级别的值，但是在较老的平台上可能无法准确地测量这种延迟。 
										# 在这样的平台上，增加 VACUUM的节流资源消耗在1ms以上，需要改变其他的清理开销参数。 
										# 尽管如此，你应该保持 vacuum_cost_delay 在平台能持续测量的情况下尽可能小；大延迟没有帮助。
#vacuum_cost_page_hit = 1               # 0-10000 credits
										# 清理一个在共享缓存中找到的缓冲区的估计代价。它表示锁住缓冲池、查找共享哈希表和扫描页内容的代价。默认值为1。
#vacuum_cost_page_miss = 2              # 0-10000 credits
										# 清理一个必须从磁盘上读取的缓冲区的代价。它表示锁住缓冲池、查找共享哈希表、从磁盘读取需要的块以及扫描其内容的代价。
										# 默认值为10。
#vacuum_cost_page_dirty = 20            # 0-10000 credits
										# 当清理修改一个之前干净的块时需要花费的估计代价。它表示再次把脏块刷出到磁盘所需要的额外I/O。默认值为20。
#vacuum_cost_limit = 200                # 1-10000 credits
										# 将导致vacuum过程休眠的累积成本。默认值为 200。
										
										# 有些操作会保持关键性的锁，这样可以尽快完成。基于代价的清理延迟在这类操作期间不会发生。
										# 因此有可能代价会累计至大大超过指定的限制。
										# 为了防止在这种情况下的无意义的长时间延迟，
										# 实际延迟的计算方式是 vacuum_cost_delay * accumulated_balance / vacuum_cost_limit，且最大值是 vacuum_cost_delay * 4。

### - Background Writer -
										# 有一个独立的服务器进程，叫做后台写入器，它的功能就是发出写“脏”（新的或修改过的）共享缓冲区的命令。
										# 它写出共享缓冲区，这样让处理用户查询的服务器进程很少或者永不等待写动作的发生。
										# 不过，后台写入器确实会增加 I/O 的总负荷，因为虽然在每个检查点间隔中一个重复弄脏的页面可能只会写出一次，
										# 但在同一个间隔中后台写入器可能会把它写出好几次。在这一小节讨论的参数可以被用于调节本地需求的行为。
#bgwriter_delay = 200ms                 # 10-10000ms between rounds
										# 指定后台写入器活动轮次之间的延迟。在每个轮次中，写入器都会为一定数量的脏缓冲区发出写操作（可以用下面的参数控制）。 
										# 然后它就休眠 bgwriter_delay的时长， 然后重复动作。
										# 当缓冲池中没有脏缓冲区时，不管 bgwriter_delay，它都会进入更长的休眠。
										# 如果指定值时没有单位，则以毫秒为单位。默认值是 200 毫秒（200ms）。 
										# 注意在许多系统上，休眠延迟的有效解析度是 10 毫秒；
										# 因此，为bgwriter_delay设置一个 不是 10 的倍数的值与把它设置为下一个更高的 10 的倍数是一样的效果。
										# 这个选项只能在服务器命令行上或者在postgresql.conf文件中设置。
#bgwriter_lru_maxpages = 100            # max buffers written/round, 0 disables
										# 在每个轮次中，不超过这么多个缓冲区将被后台写入器写出。
										# 把这个参数设置为零可禁用后台写出（注意被一个独立、专用辅助进程管理的检查点不受影响）。
										# 默认值是 100 个缓冲区。这个参数只能在postgresql.conf文件中或在服务器命令行上设置。
#bgwriter_lru_multiplier = 2.0          # 0-10.0 multiplier on buffers scanned/round
										# 每一轮次要写的脏缓冲区的数目基于最近几个轮次中服务器进程需要的新缓冲区的数目。 
										# 最近所需的平均值乘以bgwriter_lru_multiplier可以估算下一轮次中将会需要的缓冲区数目。
										# 脏缓冲区将被写出直到有很多干净可重用的缓冲区（然而，每一轮次中写出的缓冲区数不超过bgwriter_lru_maxpages）。 
										# 因此，设置为 1.0 表示一种“刚刚好的”策略，这种策略会写出正好符合预测值的数目的缓冲区。 
										# 更大的值可以为需求高峰提供某种缓冲，而更小的值则需要服务进程来处理一些写出操作。
										# 默认值是 2.0。这个参数只能在postgresql.conf文件中或在服务器命令行上设置。
#bgwriter_flush_after = 512kB           # measured in pages, 0 disables
										# 只要后台写入的数据超过这个数量，尝试强制 OS 把这些写发送到底层存储上。
										# 这样做将限制内核页缓存中脏数据的量，降低了在检查点末尾发出一个 fsync 时或者 OS 在后台大批量写回数据时卡住的可能性。
										# 那常常会导致大幅度压缩的事务延迟，但是也有一些情况（特别是负载超过shared_buffers但小于 OS 页面高速缓存）的性能会降低。
										# 这种设置可能会在某些平台上没有效果。 
										# 如果指定值时没有单位，则以块为单位，即为BLCKSZ 字节，通常为8kB.合法的范围在0（禁用受控写回）和2MB之间。
										# Linux 上的默认值是512kB，其他平台上是0（如果BLCKSZ不是8kB，则默认值和最大值会按比例缩放至这个值）。
										# 这个参数只能在postgresql.conf文件中或者服务器命令行上设置。

### - Asynchronous Behavior -

#backend_flush_after = 0                # measured in pages, 0 disables
										# 只要一个后端写入的数据量超过这个数量时，就会尝试强制 OS 把这些写发送到底层存储。
										# 这样做将会限制内核页高速缓存中的脏数据数量，降低在检查点末尾发出fsync时或者 OS 在后台大批写回数据时卡住的可能性。
										# 这常常会导致极大降低的事务延迟，但是也有一些情况中（特别是负载超过shared_buffers但低于 OS 的页面高速缓存时），
										# 性能可能会下降。这个设置可能在某些平台上没有效果。 
										# 如果指定值时没有单位，则以块为单位，即为 BLCKSZ 字节，通常为8kB。
										# 合法的范围位于0（禁用受控写回）和2MB之间。默认是0（即没有强制写回）。（如果BLCKSZ不是8kB，最大值会按比例缩放到它）。
#effective_io_concurrency = 1           # 1-1000; 0 disables prefetching
										# 设置PostgreSQL可以同时被执行的并发磁盘 I/O 操作的数量。
										# 调高这个值，可以增加任何单个PostgreSQL会话试图并行发起的 I/O 操作的数目。 
										# 允许的范围是 1 到 1000，或 0 表示禁用异步 I/O 请求。当前这个设置仅影响位图堆扫描。

										# 对于磁盘驱动器，这个设置的一个很好的出发点是组成一个被用于该数据库的 RAID 0 条带或 RAID 1 镜像的独立驱动器数量
										# （对 RAID 5 而言，校验驱动器不计入）。
										# 但是， 如果数据库经常忙于在并发会话中发出的多个查询，较低的值可能足以使磁盘阵列繁忙。
										# 比保持磁盘繁忙所需的值更高的值只会造成额外的 CPU 开销。
										# SSD 以及其他基于内存的存储常常能处理很多并发请求，因此它们的最佳值可能是数百。

										# 异步 I/O 依赖于一个有效的posix_fadvise函数（一些操作系统可能没有）。 
										# 如果不存在这个函数，将这个参数设置为除 0 之外的任何东西将导致错误。
										# 在一些操作系统上（如Solaris）虽然提供了这个函数，但它不会做任何事情。

										# 在支持的系统上默认值为 1，否则为 0。
										# 对于一个特定表空间中的表，可以通过设定该表空间的同名参数（见ALTER TABLESPACE）可以覆盖这个值。
#maintenance_io_concurrency = 10        # 1-1000; 0 disables prefetching
										# 与effective_io_concurrency相似，但用于支持许多客户端会话完成的维护工作。
										# 在支持的系统上的默认值为 10，否则为 0。 
										# 对于特定表空间中的表，这个值可以被覆盖，通过设置同名的表空间参数（参见 ALTER TABLESPACE）。
#max_worker_processes = 8               # (change requires restart)
										# 设置系统能够支持的后台进程的最大数量。这个参数只能在服务器启动时设置。默认值为 8。
										# 在运行一个后备服务器时，你必须把这个参数设置为等于或者高于主控服务器上的值。否则， 后备服务器上可能不会允许查询。
										# 在更改这个值时，考虑也对max_parallel_workers、max_parallel_maintenance_workers以及max_parallel_workers_per_gather进行调整。
#max_parallel_workers_per_gather = 2    # taken from max_parallel_workers
										# 设置单个Gather或者Gather Merge节点能够开始的工作者的最大数量。
										# 并行工作者会从max_worker_processes建立的进程池中取得，数量由max_parallel_workers限制。
										# 注意所要求的工作者数量在运行时可能实际无法被满足。
										# 如果这种事情发生，该计划将会以比预期更少的工作者运行，这可能会不太高效。默认值是2。
										# 把这个值设置为0将会禁用并行查询执行。
#max_parallel_maintenance_workers = 2   # taken from max_parallel_workers
										# 设置单一工具性命令能够启动的并行工作者的最大数目。 
										# 当前，支持使用并行工作者的工具性命令是CREATE INDEX，并且只有在构建B-树索引时才能并行，并且 VACUUM 没有 FULL选项。 
										# 并行工作者从由max_worker_processes创建的进程池中取出，数量由max_parallel_workers控制。 
										# 注意实际在运行时所请求数量的工作者可能不可用。如果发生这种情况，工具性操作将使用比预期数量少的工作者运行。
										# 默认值为2。将这个值设置为0可以禁用工具性命令对并行工作者的使用。

										# 注意并行工具性命令不应该消耗比同等数量非并行操作更多的内存。
										# 这种策略与并行查询不同，并行查询的资源限制通常是应用在每个工作者进程上。
										# 并行工具性命令把资源限制maintenance_work_mem当作对整个工具性命令的限制，而不管其中用到了多少个并行工作者进程。
										# 不过，并行工具性命令实际上可能仍会消耗更多的CPU资源和I/O带宽。
#max_parallel_workers = 8               # maximum number of max_worker_processes that
                                        # can be used in parallel operations
										# 设置系统为并行操作所支持的工作者的最大数量。
										# 默认值为8。
										# 在增加或者减小这个值时，也要考虑对max_parallel_maintenance_workers以及max_parallel_workers_per_gather进行调整。
										# 此外，要注意将这个值设置得大于max_worker_processes将不会产生效果，因为并行工作者进程都是从max_worker_processes所建立的工作者进程池中取出来的。
#parallel_leader_participation = on
										# Gather允许领导进程在和节点下执行查询计划，Gather Merge而不是等待工作进程。
										# 默认值为on. 将此值设置为off可降低由于领导者读取元组的速度不够快而导致工作人员阻塞的可能性，
										# 但需要领导进程等待工作进程启动，然后才能生成第一个元组。
										# 领导者可以帮助或阻碍性能的程度取决于计划类型、工作人员数量和查询持续时间。
#old_snapshot_threshold = -1            # 1min-60d; -1 disables; 0 is immediate
                                        # (change requires restart)
										# 设置在使用快照时，一个快照可以被使用而没有发生“snapshot too old” 错误的风险的最小时间。
										# 超过此阈值时间的死数据将允许被清除。 这可以有助于阻止长时间使用的快照造成的快照膨胀。
										# 为了阻止由于本来对该快照可见的数据被清理导致的不正确结果，
										# 当快照比这个阈值更旧并且该快照被用来读取一个该快照建立以来被修改过的页面时，将会产生一个错误。

										# 如果指定值时没有单位，则以分钟为单位。 
										# 值 -1 (默认值) 禁用此功能,实际上将快照的时限设置为无穷大。 这个参数只能在服务器启动时设置。

										# 对于生产工作有用的值的范围可能从几个小时到几天不等。只允许小的值（例如0或者1min）是因为它们有时可能对测试有用。 
										# 虽然允许高达60d的设置，但是请注意很多负载情况下，很短的时间帧里就可能发生极大的膨胀或者事务 ID 回卷。

										# 当这个特性被启用时，关系末尾的被清出的空间不能被释放给操作系统，因为那可能会移除用于检测“snapshot too old”情况所需的信息。
										# 所有分配给关系的空间还将与该关系关联在一起便于重用，除非它们被显式地释放（例如，用VACUUM FULL）。

										# 这个设置不会尝试保证在任何特殊情况下都会生成错误。
										# 事实上，如果（例如）可以从一个已经物化了一个结果集的游标中生成正确的结果，
										# 即便被引用表中的底层行已经被清理掉也不会生成错误。某些表不能被过早地安全清除，并且因此将不受这个设置的影响，例如系统目录。
										# 对于这些表，这个设置将不能降低膨胀，也不能降低在扫描时产生“snapshot too old”错误的可能性。

#------------------------------------------------------------------------------
## WRITE-AHEAD LOG
#------------------------------------------------------------------------------

### - Settings -

wal_level = replica                     # minimal, replica, or logical
                                        # (change requires restart)
										# wal_level决定多少信息写入到 WAL 中。
										# 默认值是replica，它会写入足够的数据以支持WAL归档和复制，包括在后备服务器上运行只读查询。
										# minimal会去掉除从崩溃或者立即关机中进行恢复所需的信息之外的所有记录。最后，logical会增加支持逻辑解码所需的信息。
										# 每个层次包括所有更低层次记录的信息。这个参数只能在服务器启动时设置。
										# 在logical层，与replica相同的信息会被记录，外加上 允许从 WAL 抽取逻辑修改集所需的信息。
										# 使用级别 logical将增加 WAL 容量，特别是如果为了REPLICA IDENTITY FULL配置了很多表并且执行了很多UPDATE和DELETE 语句时。

										# 在 9.6 之前的版本中，这个参数也允许值archive和hot_standby。现在仍然接受这些值，但是它们会被映射到replica。
#fsync = on                             # flush data to disk for crash safety
                                        # (turning this off can cause
                                        # unrecoverable data corruption)
#synchronous_commit = on                # synchronization level;
                                        # off, local, remote_write, remote_apply, or on
										# 指定数据库服务器返回“success”指示给客户端之前，必须要完成多少WAL处理。 合法的值为remote_apply, on(默认值), remote_write,local, 和 off。
										# 如果synchronous_standby_names为空，则唯一有意义的设置为on 和 off ； 
										# remote_apply，remote_write 和 local都提供与on相同的本地同步级别。 
										# 所有非off模式的本地行为都是等待WAL的本地刷新到磁盘。 
										# 在 off模式，无需等待，因此在向客户端报告成功和以后保证事务安全防止服务器崩溃之间可能会出现延迟。 
										# 当设置为off时，在向客户端报告成功和真正保证事务不会被服务器崩溃威胁之间会有延迟（最大的延迟是wal_writer_delay的三倍）。 
										# 不同于fsync，将这个参数设置为off不会产生数据库不一致性的风险：
										# 一个操作系统或数据库崩溃可能会造成一些最近据说已提交的事务丢失，但数据库状态是一致的，就像这些事务已经被干净地中止。 
										# 因此，当性能比完全确保事务的持久性更重要时，关闭synchronous_commit可以作为一个有效的代替手段。更多讨论见第 30.3 节。

										# 如果synchronous_standby_names为非空，synchronous_commit也控制是否事务提交将等待它们的 WAL 记录在后备服务器上被处理。

										# 当设置为 remote_apply 时，提交将等待，直到来自当前同步备用服务器的答复显示他们已收到事务的提交记录并应用了它，
										# 以便它变得对备用服务器上的查询可见，并写入备用服务器上的持久存储。 
										# 这将导致比以前的设置更大的提交延迟，因为它等待 WAL 重放(replay)。 
										# 当设置为on时，提交将等待，直到来自于当前同步的后备服务器的回复显示它们已经收到了事务的提交记录并将其刷入了磁盘。 
										# 这保证事务将不会被丢失，除非主服务器和所有同步后备都遭受到了数据库存储损坏的问题。 
										# 当这个参数被设置为remote_write时，提交将等待，直到来自当前的同步后备的回复指示它们已经收到了该事务的提交记录
										# 并且已经把该记录写到它们的文件系统，这种设置保证数据得以保存，在PostgreSQL的后备服务器实例崩溃时，
										# 但是不能保证后备服务器遭受操作系统级别崩溃时数据能被保持，因为数据不一定必须要在后备机上达到持久存储。 
										# 设置local会导致提交等待本地刷写到磁盘，而不是复制。在使用同步复制时这通常是不可取的，但是为了完整性提供了这个选项。

										# 这个参数可以随时被修改；任何一个事务的行为由其提交时生效的设置决定。
										# 因此，可以同步提交一些事务，同时异步提交其他事务。
										# 例如，当默认是相反时，实现一个单一多语句事务的异步提交，在事务中发出SET LOCAL synchronous_commit TO OFF。
#wal_sync_method = fsync                # the default is the first option
                                        # supported by the operating system:
                                        #   open_datasync  用open()选项O_DSYNC写 WAL 文件
                                        #   fdatasync (default on Linux and FreeBSD)  在每次提交时调用fdatasync()
                                        #   fsync    在每次提交时调用fsync()
                                        #   fsync_writethrough  在每次提交时调用fsync()，强制任何磁盘写高速缓存的直通写
                                        #   open_sync   用open()选项O_SYNC写 WAL 文件
										# 用来向强制 WAL 更新到磁盘的方法。如果fsync是关闭的，那么这个设置就不相关，因为 WAL 文件更新将根本不会被强制。
full_page_writes = on                   # recover from partial page writes
										# 当这个参数为打开时，PostgreSQL服务器在一个检查点之后的页面的第一次修改期间将每个页面的全部内容写到 WAL 中。
										# 这么做是因为在操作系统崩溃期间正在处理的一次页写入可能只有部分完成，从而导致在一个磁盘页面中混合有新旧数据。
										# 在崩溃后的恢复期间，通常存储在 WAL 中的行级改变数据不足以完全恢复这样一个页面。
										# 存储完整的页面映像可以保证页面被正确存储，但代价是增加了必须被写入 WAL 的数据量（因为 WAL 重放总是从一个检查点开始，
										# 所以在检查点后每个页面的第一次改变时这样做就够了。因此，一种减小全页面写开销的方法是增加检查点间隔参数值）。

										# 把这个参数关闭会加快正常操作，但是在系统失败后可能导致不可恢复的数据损坏，或者静默的数据损坏。
										# 其风险类似于关闭fsync， 但是风险较小。并且只有在可关闭fsync的情况下才应该关闭它。

										# 关闭这个选项并不影响用于时间点恢复（PITR）的 WAL 归档使用（见第 26.3 节）。

										# 这个参数只能在postgresql.conf文件中或在服务器命令行上设置。默认值是on。
										
#wal_log_hints = off                    # also do full page writes of non-critical updates
                                        # (change requires restart)
										# 当这个参数为on时，PostgreSQL服务器一个检查点之后页面被第一次修改期间把该磁盘页面的整个内容都写入 WAL，
										# 即使对所谓的提示位做非关键修改也会这样做。

										# 如果启用了数据校验和，提示位更新总是会被 WAL 记录并且这个设置会被忽略。
										# 你可以使用这个 设置测试如果你的数据库启用了数据校验和，会有多少额外的 WAL 记录发生。

										# 这个参数只能在服务器启动时设置。默认值是off。
										
#wal_compression = off                  # enable compression of full-page writes
										# 当这个参数为on时，如果full_page_writes 为打开或者处于基础备份期间，PostgreSQL服务器 会压缩写入到 WAL 中的完整页面镜像。
										# 压缩页面镜像将在 WAL 重放时 被解压。默认值为off。只有超级用户可以更改这个设置。

										# 打开这个参数可以减小 WAL 所占的空间且无需承受不可恢复的数据损坏风险， 但是代价是需要额外的 CPU 开销以便在 WAL 记录期间
										# 进行压缩以及在 WAL 重放时解压。
										
#wal_init_zero = on                     # zero-fill new WAL files
										# 如果设置为on（默认值），此选项会导致新的 WAL 文件被零填充。 
										# 在某些文件系统上，这可确保在我们需要写入 WAL 记录之前分配空间。 但是，Copy-On-Write（COW）文件系统
										# 可能不会从此技术中受益，因此可以选择跳过不必要的工作。 
										# 如果设置为off，则在创建文件时仅写入最终字节，以便其具有预期大小。
#wal_recycle = on                       # recycle WAL files
										# 如果设置为 on （默认值），此选项通过重命名来回收 WAL 文件，从而避免创建新文件。 
										# 在 COW 文件系统上，创建新文件系统可能更快，因此提供了禁用此行为的选项。
#wal_buffers = -1                       # min 32kB, -1 sets based on shared_buffers
                                        # (change requires restart)
										# 用于还未写入磁盘的 WAL 数据的共享内存量。
										# 默认值 -1 选择等于shared_buffers的 1/32 的尺寸（大约3%），但是不小于64kB也不大于 WAL 段的尺寸（通常为）。
										# 如果自动的选择太大或太小可以手工设置该值，但是任何小于32kB的正值都将被当作32kB。 
										# 如果指定值时没有单位，则以WAL块作为单位，即为 XLOG_BLCKSZ 字节，通常为8kB。这个参数只能在服务器启动时设置。

										# 在每次事务提交时，WAL 缓冲区的内容被写出到磁盘，因此极大的值不可能提供显著的收益。
										# 不过，把这个值设置为几个兆字节可以在一个繁忙的服务器（其中很多客户端会在同一时间提交）上提高写性能。
										# 由默认设置 -1 选择的自动调节将在大部分情况下得到合理的结果。
#wal_writer_delay = 200ms               # 1-10000 milliseconds
										# 指定 WAL 写入器刷写 WAL 的频繁程度，以时间为单位。 
										# 在刷写WAL之后，写入器将根据wal_writer_delay所给出的时间长度进行睡眠，除非被一个异步提交的事务提前唤醒。 
										# 如果最近的刷写发生在 wal_writer_delay 之前，并且小于 wal_writer_flush_after WAL的值产生之后，
										# 那么WAL只会被写入操作系统，而不会被刷写到磁盘。 
										# 如果指定值时没有单位，则以毫秒作为单位。 默
										# 认值是 200 毫秒（200ms）。
										# 注意在很多系统上，有效的睡眠延迟粒度是 10 毫秒，把wal_writer_delay设置为一个不是 10 的倍数的值，
										# 其效果和把它设置为大于该值的下一个 10 的倍数产生的效果相同。这个参数只能在postgresql.conf文件中或者服务器命令行上设置。
#wal_writer_flush_after = 1MB           # measured in pages, 0 disables
										# 指定 WAL 写入器刷写 WAL 的频繁程度，以卷为单位。 
										# 如果最近的刷写发生在 wal_writer_delay 之前，并且小于 wal_writer_flush_after WAL的值产生之后，
										# 那么WAL只会被写入操作系统，而不会被刷写到磁盘。 如果wal_writer_flush_after被设置为0，则WAL数据总是会被立即刷写。 
										# 如果指定值时没有单位，则以WAL块作为单位，即为XLOG_BLCKSZ字节，通常为8kB。 默认是1MB。
										# 这个参数只能在postgresql.conf文件中或者服务器命令行上设置。
#wal_skip_threshold = 2MB				# 当wal_level为minimal，并且在创建或重写永久关系之后提交事务时，此设置将确定如何保留新数据。 
										# 如果数据小于此设置，将其写入 WAL 日志;否则，使用受影响文件的 fsync。 
										# 根据存储的属性，如果此类提交减慢了并发事务，提高或降低此值可能会有所帮助。 
										# 如果指定此值时没有单位，则视为千字节。默认为两兆字节（2MB）。

#commit_delay = 0                       # range 0-100000, in microseconds
										# 在一次 WAL 刷写被发起之前，commit_delay增加一个时间延迟。 
										# 如果系统负载足够高，使得在一个给定间隔内有额外的事务准备好提交，
										# 那么通过允许更多事务通过一个单次 WAL 刷写来提交能够提高组提交的吞吐量。 
										# 但是，它也把每次 WAL 刷写的潜伏期增加到了最多commit_delay。 
										# 因为如果没有其他事务准备好提交，就会浪费一次延迟，只有在当一次刷写将要被发起时有至少commit_siblings个其他活动事务时，
										# 才会执行一次延迟。 另外，如果fsync被禁用，则将不会执行任何延迟。 
										# 如果指定值时没有单位，则以微秒作为单位。 
										# 默认的commit_delay是零（无延迟）。只有超级用户才能修改这个设置。

										# 在PostgreSQL的 9.3 发布之前，commit_delay的行为不同并且效果更差：
										# 它只影响提交，而不是所有 WAL 刷写，并且即使在 WAL 刷写马上就要完成时也会等待一整个配置的延迟。
										# 从PostgreSQL 9.3 中开始，第一个准备好刷写的进程会等待配置的间隔，而后续的进程只等到领先者完成刷写操作。
#commit_siblings = 5                    # range 1-1000
										# 在执行commit_delay延迟时，要求的并发活动事务的最小数目。
										# 大一些的值会导致在延迟间隔期间更可能有至少另外一个事务准备好提交。
										# 默认值是五个事务。
### - Checkpoints -  检查点相关

#checkpoint_timeout = 5min              # range 30s-1d
										# 自动 WAL 检查点之间的最长时间。如果指定值时没有单位，则以秒为单位。 合理的范围在 30 秒到 1 天之间。
										# 默认是 5 分钟（5min）。
										# 增加这个参数的值会增加崩溃恢复所需的时间。
										# 这个参数只能在postgresql.conf文件中或在服务器命令行上设置。
#checkpoint_completion_target = 0.9     # checkpoint target duration, 0.0 - 1.0
										# 指定检查点完成的目标，作为检查点之间总时间的一部分。
										# 默认是 0.5。 
										# 这个参数只能在postgresql.conf文件中或在服务器命令行上设置。
#checkpoint_flush_after = 256kB         # measured in pages, 0 disables
										# 在 Linux 和 POSIX 平台上，checkpoint_flush_after 允许强制操作系统在可配置的字节数之后将检查点写入的页面刷新到磁盘。
										# 否则，这些页面可能会保存在操作系统的页面缓存中，从而在检查点结束时发出 fsync 时导致停顿。
										# 此设置通常有助于减少事务延迟，但也会对性能产生不利影响；特别是对于大于 shared_buffers 但小于操作系统页面缓存的工作负载。
#checkpoint_warning = 30s               # 0 disables
										# 为了确保数据页的一致性，在每个检查点之后对数据页的第一次修改会导致记录整个页的内容。在这种情况下，
										# 较小的检查点间隔会增加 WAL 日志的输出量，部分否定使用较小间隔的目标，并且无论如何都会导致更多的磁盘 I/O。
										# 检查点相当昂贵，首先因为它们需要写出所有当前脏缓冲区，其次因为它们会导致额外的后续 WAL 流量，如上所述。
										# 因此，明智的做法是将检查点参数设置得足够高，这样检查点就不会经常发生。
										# 作为对检查点参数的简单完整性检查，您可以设置 checkpoint_warning 参数。
										# 如果检查点发生的时间比 checkpoint_warning 秒更近，则会向服务器日志输出一条消息，
										# 建议增加 max_wal_size。这种消息偶尔出现不会引起警报，但如果经常出现，则应增加检查点控制参数。
										# 如果您没有将 max_wal_size 设置得足够高，则诸如大型 COPY 传输之类的批量操作可能会导致出现许多此类警告。
max_wal_size = 1GB						# 服务器的检查点进程每隔一段时间就会自动执行一个检查点。
										# 每 checkpoint_timeout 秒开始一个检查点，或者如果 max_wal_size 即将被超过，
										# 以先到者为准。默认设置分别为 5 分钟和 1 GB。
										# 如果自上一个检查点以来没有写入 WAL，即使 checkpoint_timeout 已经过去，也会跳过新的检查点。 
										#（如果正在使用 WAL 归档，并且您希望对归档文件的频率设置下限以限制潜在的数据丢失，
										# 则应调整 archive_timeout 参数而不是检查点参数。）也可以强制检查点通过使用 SQL 命令 CHECKPOINT。
										
min_wal_size = 80MB						# pg_wal 目录中 WAL 段文件的数量取决于 min_wal_size、max_wal_size 和之前检查点周期中生成的 WAL 数量。
										# 当不再需要旧的日志段文件时，它们会被删除或回收（即，重命名为按编号顺序成为未来的段）。
										# 如果由于日志输出率的短期峰值超过了 max_wal_size，则将删除不需要的段文件，直到系统回到此限制之下。
										# 低于该限制，系统会回收足够的 WAL 文件来满足下一个检查点之前的估计需求，并删除其余文件。
										# 该估计值基于先前检查点周期中使用的 WAL 文件数量的移动平均值。
										# 如果实际使用量超过估计值，移动平均值会立即增加，因此它在一定程度上适应了峰值使用量而不是平均使用量。
										# min_wal_size 为将来使用的 WAL 文件的回收量设置了最小值；即使系统空闲并且 WAL 使用情况估计表明需要很少的 WAL，
										# 也总是会回收那么多 WAL 以供将来使用。

### - Archiving -  归档

archive_mode = always           # enables archiving; off, on, or always
                                # (change requires restart)
								# 启用archive_mode 后，通过设置archive_command 将完成的WAL 段发送到归档存储。
								# 除了关闭、禁用之外，还有两种模式：on和always。
								#在正常操作期间，这两种模式之间没有区别，但是当设置为 always 时，WAL 归档程序也会在归档恢复或待机模式期间启用。
								# 在always模式下，从存档中恢复的所有文件或使用流复制进行流式传输的所有文件都将被存档（再次）。有关详细信息，请参阅第 27.2.9 节。

								# archive_mode 和archive_command 是单独的变量，因此archive_command 可以在不离开归档模式的情况下进行更改。
								# 此参数只能在服务器启动时设置。
								# 当 wal_level 设置为 minimum 时，无法启用 archive_mode。
								
archive_command = '"pg_probackup" archive-push -B "/pgdata/pg_probackup" --instance pg14.2 --wal-file-name=%f --compress --archive-timeout=270'         # command to use to archive a logfile segment
                                # placeholders: %p = path of file to archive
                                #               %f = file name only
                                # e.g. 'test ! -f /mnt/server/archivedir/%f &amp;&amp; cp %p /mnt/server/archivedir/%f'
								# 要执行以归档已完成的 WAL 文件段的本地 shell 命令。
								# 字符串中的任何 %p 都将替换为要归档的文件的路径名，而任何 %f 仅替换为文件名。 
								# 使用 %% 在命令中嵌入一个实际的 % 字符。该命令只有在成功时才返回零退出状态，这一点很重要。有关详细信息，请参阅第 26.3.1 节。

								# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
								# 除非在服务器启动时启用了 archive_mode，否则它会被忽略。
								# 如果 archive_command 是一个空字符串（默认），而 archive_mode 被启用，WAL 归档暂时被禁用，
								# 但服务器继续积累 WAL 段文件，以期很快就会提供命令。
								# 将 archive_command 设置为只返回 true 的命令，例如 /bin/true（Windows 上的 REM），有效地禁用归档，
								# 但也会破坏归档恢复所需的 WAL 文件链，因此它应该只在异常情况下使用.
archive_timeout = 900           # force a logfile segment switch after this
                                # number of seconds; 0 disables
								# archive_command 仅对已完成的 WAL 段调用。
								# 因此，如果您的服务器生成的 WAL 流量很少（或在此期间有松弛期），那么在事务完成和其在存档存储中的安全记录之间可能会有很长的延迟。
								# 要限制未归档数据的旧时间，您可以设置 archive_timeout 以强制服务器定期切换到新的 WAL 段文件。
								# 当此参数大于零时，服务器将切换到新的段文件，只要自上次段文件切换以来经过了这段时间，并且有任何数据库活动，
								# 包括单个检查点（如果存在检查点，则跳过没有数据库活动）。
								# 请注意，由于强制切换而提前关闭的存档文件的长度仍与完全完整的文件相同。
								# 因此，使用非常短的 archive_timeout 是不明智的——它会使你的存档存储膨胀。 
								# archive_timeout 1分钟左右的设置通常是合理的。
								# 如果您希望更快地将数据从主服务器复制出来，您应该考虑使用流复制而不是归档。
								# 如果指定此值没有单位，则以秒为单位。此参数只能在 postgresql.conf 文件或服务器命令行中设置。

### - Archive Recovery -

#These are only used in recovery mode.

#restore_command = ''           # command to use to restore an archived logfile segment
                                # placeholders: %p = path of file to restore
                                #               %f = file name only
                                # e.g. 'cp /mnt/server/archivedir/%f %p'
								# 要执行以检索 WAL 文件系列的存档段的本地 shell 命令。
								# 此参数对于归档恢复是必需的，但对于流复制是可选的。
								# 字符串中的任何 %p 都将替换为要归档的文件的路径名，而任何 %f 仅替换为文件名
								# （路径名是相对于当前工作目录的，即集群的数据目录。）
								# 任何 %r 都替换为包含最后一个有效重启点的文件名。
								# 这是必须保留的最早文件以允许恢复可重新启动，因此此信息可用于将存档截断为支持从当前恢复重新启动所需的最低限度。 
								# %r 通常仅用于热备份配置（请参阅第 27.2 节）。
								# 写入 %% 以嵌入实际的 % 字符。
								# restore_command = 'cp /mnt/server/archivedir/%f "%p"'
								# restore_command = 'copy "C:\\server\\archivedir\\%f" "%p"'  # Windows
								
#archive_cleanup_command = ''   # command to execute at every restartpoint
								# 此可选参数指定将在每个重新启动点执行的 shell 命令。 
								# archive_cleanup_command 的目的是提供一种机制来清理备用服务器不再需要的旧归档 WAL 文件。
								# 任何 %r 都将替换为包含最后一个有效重新启动点的文件的名称。
								# 这是必须保留的最早文件以允许可重新启动还原，因此可以安全地删除早于 %r 的所有文件。
								# 此信息可用于将存档截断为支持从当前还原重新启动所需的最低限度。 
								# pg_archivecleanup 模块经常在 archive_cleanup_command 中用于单备配置，例如：
								# archive_cleanup_command = 'pg_archivecleanup /mnt/server/archivedir %r'
								# 但是请注意，如果多个备用服务器从同一个存档目录恢复，则需要确保在任何服务器不再需要 WAL 文件之前不要删除它们。 
								# archive_cleanup_command 通常用于热备份配置（参见第 27.2 节）。
								# 写入 %% 以在命令中嵌入实际的 % 字符。
								# 如果命令返回非零退出状态，则将写入警告日志消息。
								# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
#recovery_end_command = ''      # command to execute at completion of recovery
								# 此参数指定仅在恢复结束时执行一次的 shell 命令。
								# 此参数是可选的。 
								# recovery_end_command 的目的是为复制或恢复后的清理提供一种机制。
								# 任何 %r 都将替换为包含最后一个有效重启点的文件的名称，例如在 archive_cleanup_command 中。

								# 如果命令返回非零退出状态，则将写入警告日志消息，并且数据库将继续启动。
								# 一个例外是，如果命令被 shell 的信号或错误终止（例如找不到命令），数据库将不会继续启动。

								#此参数只能在 postgresql.conf 文件或服务器命令行中设置。

### - Recovery Target -

#Set these only when performing a targeted recovery.
#默认情况下，恢复将恢复到 WAL 日志的末尾。以下参数可用于指定较早的停止点。
#最多可以使用 recovery_target、recovery_target_lsn、recovery_target_name、recovery_target_time 或 recovery_target_xid 之一；
#如果在配置文件中指定了其中一个以上，则会引发错误。
#这些参数只能在服务器启动时设置。

#recovery_target = ''           # 'immediate' to end recovery as soon as a
                                # consistent state is reached
                                # (change requires restart)
								# immediate是当前唯一允许的值。
								# 此参数指定恢复应在达到一致状态后立即结束，即尽可能早。从在线备份恢复时，这意味着备份结束的时间点。
								
#recovery_target_name = ''      # the named restore point to which recovery will proceed
                                # (change requires restart)
								# 此参数指定恢复将继续到的命名还原点（使用 pg_create_restore_point() 创建）。
#recovery_target_time = ''      # the time stamp up to which recovery will proceed
                                # (change requires restart)
								# 此参数指定将继续进行恢复的时间戳。精确停止点也受 recovery_target_inclusive 的影响。
								
								# 此参数的值是时间戳与时区数据类型所接受的格式相同的时间戳，
								# 但您不能使用时区缩写（除非在配置文件中较早地设置了 timezone_abbreviations 变量）。
								# 首选样式是使用与 UTC 的数字偏移量，或者您可以编写完整的时区名称，例如 Europe/Helsinki 而不是 EEST。
								# recovery_target_time = '2013-08-07 13:45:00+08'
								
#recovery_target_xid = ''       # the transaction ID up to which recovery will proceed
                                # (change requires restart)
								# 此参数指定恢复将继续到的事务 ID。
								# 请记住，虽然事务 ID 在事务开始时按顺序分配，但事务可以以不同的数字顺序完成。
								# 将恢复的事务是那些在指定事务之前（并且可选地包括）提交的事务。
								# 精确停止点也受 recovery_target_inclusive 的影响。
#recovery_target_lsn = ''       # the WAL LSN up to which recovery will proceed
                                # (change requires restart)
								# 此参数指定将进行恢复的预写日志位置的 LSN。
								# 精确停止点也受 recovery_target_inclusive 的影响。
								# 此参数使用系统数据类型 pg_lsn 进行解析。

#以下选项进一步指定恢复目标，并影响达到目标时发生的情况：
#recovery_target_inclusive = on # Specifies whether to stop:
                                # just after the specified recovery target (on)
                                # just before the recovery target (off)
                                # (change requires restart)
								# 指定是在指定的恢复目标之后停止 (on)，还是在恢复目标之前 (off) 停止。
								# 在指定 recovery_target_lsn、recovery_target_time 或 recovery_target_xid 时应用。
								# 此设置控制是否将具有确切目标 WAL 位置 (LSN)、提交时间或事务 ID 的事务分别包含在恢复中。
								# 默认开启。
#recovery_target_timeline = 'latest'    # 'current', 'latest', or timeline ID
                                # (change requires restart)
								# 指定恢复到特定时间线。
								# 该值可以是数字时间线 ID 或特殊值。
								# 当前值沿进行基本备份时的当前时间线恢复。
								# 值 latest 恢复到存档中找到的最新时间线，这在备用服务器中很有用。
								# latest的是默认值。
								# 通常只需要在复杂的重新恢复情况下设置此参数，需要在时间点恢复后返回到自身达到的状态。
								# 有关讨论，请参见第 26.3.5 节。
#recovery_target_action = 'pause'       # 'pause', 'promote', 'shutdown'
                                # (change requires restart)
								# 指定达到恢复目标后服务器应采取的操作。
								# 默认为暂停，这意味着恢复将被暂停。
								# 提升意味着恢复过程将完成，服务器将开始接受连接。
								# 最后关闭将在达到恢复目标后停止服务器。
								# pause设置的预期用途是允许对数据库执行查询，以检查此恢复目标是否是最理想的恢复点。
								# 可以使用 pg_wal_replay_resume() 恢复暂停状态（参见表 9.89），然后导致恢复结束。
								# 如果此恢复目标不是所需的停止点，则关闭服务器，将恢复目标设置更改为稍后的目标，然后重新启动以继续恢复。
								
								# shutdown设置对于使实例在所需的确切重放点准备好很有用。
								# 该实例仍然能够重放更多 WAL 记录（实际上，它必须在下次启动时重放自上次检查点以来的 WAL 记录）。
								
								# 请注意，因为当 recovery_target_action 设置为关闭时，recovery.signal 不会被删除，
								# 所以任何后续启动都将以立即关闭结束，除非更改配置或手动删除 recovery.signal 文件。
								
								# 如果未设置恢复目标，则此设置无效。
								# 如果未启用 hot_standby，则 pause 设置将与shutdown相同。如果在升级过程中达到恢复目标，则pause设置的作用与promote相同。

#在任何情况下，如果配置了恢复目标但存档恢复在达到目标之前结束，则服务器将关闭并出现致命错误。
								
#------------------------------------------------------------------------------
### REPLICATION
#------------------------------------------------------------------------------
#这些设置控制内置流复制功能的行为（参见第 27.2.5 节）。
#服务器将是主服务器或备用服务器。主节点可以发送数据，而备用节点始终是复制数据的接收者。
#当使用级联复制（参见第 27.2.7 节）时，备用服务器也可以是发送者，也可以是接收者。
#参数主要用于发送服务器和备用服务器，但有些参数只对主服务器有意义。
#如果需要，设置可能会因集群而异而不会出现问题。


### - Sending Servers -
#可以在将复制数据发送到一个或多个备用服务器的任何服务器上设置这些参数。
#主服务器始终是发送服务器，因此必须始终在主服务器上设置这些参数。
#这些参数的作用和含义在备用变为主后不会改变。
#Set these on the primary and on any standby that will send replication data.

#max_wal_senders = 10           # max number of walsender processes
                                # (change requires restart)
								# 指定来自备用服务器或流式基本备份客户端的最大并发连接数（即同时运行的 WAL 发送方进程的最大数量）。
								# 默认值为 10。值 0 表示禁用复制。
								# 流式客户端的突然断开可能会留下一个孤立的连接槽，直到达到超时，
								# 因此此参数应设置为略高于预期客户端的最大数量，以便断开连接的客户端可以立即重新连接。
								# 此参数只能在服务器启动时设置。
								# 此外，wal_level 必须设置为replica或更高以允许来自备用服务器的连接。

								# 运行备用服务器时，您必须将此参数设置为与主服务器上相同或更高的值。
								# 否则，备用服务器中将不允许查询。
								
#max_replication_slots = 10     # max number of replication slots
                                # (change requires restart)
								# 指定服务器可以支持的最大复制槽数（参见第 27.2.6 节）。
								# 默认值为 10。
								# 此参数只能在服务器启动时设置。
								# 将其设置为低于当前现有复制槽数的值将阻止服务器启动。
								# 此外，wal_level 必须设置为replica 或更高以允许使用复制槽。
								# 在订阅方，指定可以同时跟踪多少个复制源（参见第 50 章），有效地限制了可以在服务器上创建多少个逻辑复制订阅。
								# 将其设置为低于当前跟踪的复制源数（反映在 pg_replication_origin_status 中，而不是 pg_replication_origin）将阻止服务器启动。
								
#wal_keep_size = 0              # in megabytes; 0 disables
								# 指定保存在 pg_wal 目录中的过去日志文件段的最小大小，以防备用服务器需要获取它们以进行流复制。
								# 如果连接到发送服务器的备用服务器落后超过 wal_keep_size 兆字节，
								# 发送服务器可能会删除备用服务器仍需要的 WAL 段，在这种情况下，复制连接将被终止。
								# 结果，下游连接最终也会失败。 
								# （但是，如果 WAL 归档正在使用，备用服务器可以通过从归档中获取段来恢复。）

								# 这仅设置保留在 pg_wal 中的段的最小大小；系统可能需要为 WAL 归档或从检查点恢复保留更多段。
								# 如果 wal_keep_size 为零（默认值），系统不会为备用目的保留任何额外的段，
								# 因此备用服务器可用的旧 WAL 段的数量是前一个检查点的位置和 WAL 归档状态的函数。
								# 如果此值指定为不带单位，则以兆字节为单位。
								# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
								
#max_slot_wal_keep_size = -1    # in megabytes; -1 disables
								# 指定在检查点时复制槽允许保留在 pg_wal 目录中的 WAL 文件的最大大小。
								# 如果 max_slot_wal_keep_size 为 -1（默认值），则复制槽可以保留无限量的 WAL 文件。
								# 否则，如果复制槽的 restart_lsn 落后于当前 LSN 超过给定大小，则使用该槽的备用服务器可能由于删除所需的 WAL 文件而不再能够继续复制。
								# 您可以在 pg_replication_slots 中查看复制槽的 WAL 可用性。
								# 如果此值指定为不带单位，则以兆字节为单位。
								# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
								
#wal_sender_timeout = 60s       # in milliseconds; 0 disables
								# 终止超过此时间不活动的复制连接。
								# 这对于发送服务器检测备用崩溃或网络中断很有用。
								# 如果指定此值没有单位，则以毫秒为单位。
								# 默认值为 60 秒。
								# 零值禁用超时机制。

								# 由于集群分布在多个地理位置，每个位置使用不同的值会在集群管理中带来更大的灵活性。
								# 较小的值对于使用具有低延迟网络连接的备用数据库进行更快的故障检测很有用，
								# 而较大的值有助于更好地判断备用数据库（如果位于远程位置且具有高延迟网络连接）的运行状况。
#track_commit_timestamp = off   # collect timestamp of transaction commit
                                # (change requires restart)
								# 记录事务的提交时间。
								# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
								# 默认值为关闭。

### - Primary Server -

#These settings are ignored on a standby server.
#可以在将复制数据发送到一个或多个备用服务器的主服务器上设置这些参数。
#请注意，除了这些参数之外，还必须在主服务器上适当地设置 wal_level，并且还可以选择启用 WAL 归档（参见第 20.5.3 节）。
#备用服务器上这些参数的值无关紧要，尽管您可能希望在此处设置它们以准备备用服务器成为主服务器的可能性。
#synchronous_standby_names = '' # standby servers that provide sync rep
                                # method to choose sync standbys, number of sync standbys,
                                # and comma-separated list of application_name
                                # from standby(s); '*' = all
								# 指定可以支持同步复制的备用服务器列表，如第 27.2.8 节所述。
								# 将有一个或多个活动同步备用；在这些备用服务器确认收到其数据后，将允许等待提交的事务继续进行。
								# 同步备用数据库将是其名称出现在此列表中的那些，并且它们都是当前连接的和实时流式传输数据（
								# 如 pg_stat_replication 视图中的流式传输状态所示）。
								# 指定多个同步备用可以实现非常高的可用性并防止数据丢失。
								# 
								# 为此目的，备用服务器的名称是备用服务器的 application_name 设置，在备用服务器的连接信息中设置。
								# 在物理复制备用的情况下，这应该在 primary_conninfo 设置中设置；如果设置，则默认为 cluster_name 的设置，否则为 walreceiver。
								# 对于逻辑复制，可以在订阅的连接信息中设置，默认为订阅名。
								# 对于其他复制流消费者，请查阅他们的文档。
								# 此参数使用以下任一语法指定备用服务器列表：
								# [FIRST] num_sync ( standby_name [, ...] )
								# ANY num_sync ( standby_name [, ...] )
								# standby_name [, ...]
								# 其中 num_sync 是事务需要等待回复的同步备用服务器的数量，standby_name 是备用服务器的名称。 
								# FIRST 和 ANY 指定从列出的服务器中选择同步备用服务器的方法。
								# 关键字 FIRST 与 num_sync 结合使用，指定基于优先级的同步复制，
								# 并使事务提交等到其 WAL 记录被复制到根据优先级选择的 num_sync 同步备用数据库。
								# 名称在列表中较早出现的备用数据库具有更高的优先级，并将被视为同步的。
								# 此列表后面出现的其他备用服务器代表潜在的同步备用服务器。
								# 如果任何当前同步备用数据库由于某种原因断开连接，它将立即被下一个最高优先级备用数据库替换。
								# 关键字 FIRST 是可选的。
								

								# 第三种语法在 PostgreSQL 版本 9.6 之前使用并且仍然受支持。
								# 它与第一个语法相同，FIRST 和 num_sync 等于 1。例如，FIRST 1 (s1, s2) 和 s1, s2 具有相同的含义：选择 s1 或 s2 作为同步备用。

								# 特殊条目 * 匹配任何备用名称。

								# 没有强制备用名称唯一性的机制。在重复的情况下，匹配的备用数据库之一将被视为更高的优先级，但究竟哪一个是不确定的。
								
								# 如果此处未指定同步备用名称，则不会启用同步复制，并且事务提交不会等待复制。
								# 这是默认配置。
								# 即使启用了同步复制，也可以通过将 synchronous_commit 参数设置为 local 或 off 来将单个事务配置为不等待复制。

								# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
								
#vacuum_defer_cleanup_age = 0   # number of xacts by which cleanup is delayed
								# 指定 VACUUM 和 HOT 更新将延迟清除死行版本的事务数。
								# 默认值为零事务，这意味着可以尽快删除死行版本，也就是说，只要它们不再对任何打开的事务可见。
								# 您可能希望在支持热备用服务器的主服务器上将其设置为非零值，如第 27.4 节所述。
								# 这允许有更多时间完成备用数据库上的查询，而不会因提前清理行而引发冲突。
								# 但是，由于该值是根据主服务器上发生的写入事务数来衡量的，因此很难预测有多少额外的宽限时间可用于备用查询。
								# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。

								# 您还应该考虑在备用服务器上设置 hot_standby_feedback 作为使用此参数的替代方法。

								# 这不会阻止清除已达到 old_snapshot_threshold 指定期限的死行。

### - Standby Servers -

#These settings are ignored on a primary server.
#这些设置控制接收复制数据的备用服务器的行为。它们在主服务器上的值无关紧要。


#primary_conninfo = ''                  # connection string to sending server
										# 指定用于备用服务器与发送服务器连接的连接字符串。
										# 此字符串采用第 34.1.1 节中描述的格式。
										# 如果此字符串中未指定任何选项，则检查相应的环境变量（参见第 34.15 节）。
										# 如果环境变量也未设置，则使用默认值。

										# 连接字符串应该指定发送服务器的主机名（或地址），以及端口号（如果它与备用服务器的默认值不同）。
										# 还要指定与发送服务器上具有适当特权的角色相对应的用户名（参见第 27.2.5.1 节）。
										# 如果发件人要求密码验证，也需要提供密码。
										# 它可以在 primary_conninfo 字符串中提供，也可以在备用服务器上的单独 ~/.pgpass 文件中提供（使用复制作为数据库名称）。
										# 不要在 primary_conninfo 字符串中指定数据库名称。

										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
										# 如果在 WAL 接收器进程运行时更改了此参数，则该进程将被通知关闭并预期以新设置重新启动（除非 primary_conninfo 为空字符串）。
										# 如果服务器未处于待机模式，此设置无效。
#primary_slot_name = ''                 # replication slot on sending server
										# 可选地指定在通过流复制连接到发送服务器时要使用的现有复制槽，以控制上游节点上的资源删除（参见第 27.2.6 节）。
										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
										# 如果在 WAL 接收器进程正在运行时更改了此参数，则该进程会发出关闭信号，并希望以新设置重新启动。
										# 如果未设置 primary_conninfo 或服务器未处于待机模式，则此设置无效。
#promote_trigger_file = ''              # file name whose presence ends recovery
										# 指定一个触发器文件，其存在结束备用数据库中的恢复。
										# 即使没有设置这个值，你仍然可以使用 pg_ctl_promote 或调用 pg_promote() 来提升备用数据库。
										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
#hot_standby = on                       # "off" disallows queries during recovery
                                        # (change requires restart)
										# 指定您是否可以在恢复期间连接和运行查询，如第 27.4 节中所述。
										# 默认值为开启。
										# 此参数只能在服务器启动时设置。它仅在存档恢复或待机模式下有效。
										
#max_standby_archive_delay = 30s        # max delay before canceling queries
                                        # when reading WAL from archive;
                                        # -1 allows indefinite delay
										# 当 Hot Standby 处于活动状态时，此参数确定备用服务器在取消与即将应用的 WAL 条目冲突的备用查询之前应等待多长时间，
										# 如第 27.4.2 节所述。 
										# max_standby_streaming_delay 适用于通过流复制接收 WAL 数据时。
										# 如果指定此值没有单位，则以毫秒为单位。
										# 默认值为 30 秒。
										# 值 -1 允许备用数据库永远等待冲突查询完成。
										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。

										# 请注意，max_standby_archive_delay 与取消之前查询可以运行的最大时间长度不同；
										# 相反，它是允许应用任何一个 WAL 段数据的最大总时间。
										# 因此，如果一个查询在 WAL 段的早期导致了显着延迟，那么后续的冲突查询将具有更少的宽限时间。
										
#max_standby_streaming_delay = 30s      # max delay before canceling queries
                                        # when reading streaming WAL;
                                        # -1 allows indefinite delay
										# 当 Hot Standby 处于活动状态时，此参数确定备用服务器在取消与即将应用的 WAL 条目冲突的备用查询之前应等待多长时间，
										# 如第 27.4.2 节所述。 
										# max_standby_streaming_delay 适用于通过流复制接收 WAL 数据时。
										# 如果指定此值没有单位，则以毫秒为单位。
										# 默认值为 30 秒。
										# 值 -1 允许备用数据库永远等待冲突查询完成。
										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。

										# 请注意，max_standby_streaming_delay 与取消之前查询可以运行的最大时间长度不同；
										# 相反，它是从主服务器接收到 WAL 数据后允许应用的最大总时间。
										# 因此，如果一个查询导致了明显的延迟，那么后续的冲突查询将有更少的宽限时间，直到备用服务器再次赶上。
										
#wal_receiver_create_temp_slot = off    # create temp slot if primary_slot_name
                                        # is not set
										# 指定当没有配置要使用的永久复制槽时（使用 primary_slot_name），WAL 接收器进程是否应在远程实例上创建临时复制槽。
										# 默认为关闭。
										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
										# 如果在 WAL 接收器进程正在运行时更改了此参数，则该进程会发出关闭信号，并希望以新设置重新启动。
#wal_receiver_status_interval = 10s     # send replies at least this often
                                        # 0 disables
										# 指定备用服务器上的 WAL 接收器进程向主备用服务器或上游备用服务器发送有关复制进度的信息的最小频率，
										# 可以使用 pg_stat_replication 视图查看。
										# 备用数据库将报告它写入的最后一个预写日志位置、它刷新到磁盘的最后一个位置以及它应用的最后一个位置。
										# 此参数的值是报告之间的最长时间。
										# 每次写入或刷新位置更改时发送更新，或者如果设置为非零值，则按照此参数指定的频率发送更新。
										# 还有其他情况会在忽略此参数的情况下发送更新；
										# 例如，当现有 WAL 的处理完成或 synchronous_commit 设置为 remote_apply 时。
										# 因此，应用位置可能会稍微落后于真实位置。
										# 如果指定此值没有单位，则以秒为单位。
										# 默认值为 10 秒。
										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
#hot_standby_feedback = off             # send info from standby to prevent
                                        # query conflicts
										# 指定热备库是否将有关当前在备库上执行的查询的反馈发送到主库或上游备库。
										# 此参数可用于消除因清除记录而导致的查询取消，但可能会导致某些工作负载的主数据库膨胀。
										# 每个 wal_receiver_status_interval 发送反馈消息的频率不会超过一次。
										# 默认值为关闭。
										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。

										# 如果级联复制正在使用，则反馈将向上传递，直到最终到达主节点。除了向上游传递之外，备用服务器不使用他们收到的反馈。

										# 此设置不会覆盖主节点上 old_snapshot_threshold 的行为；
										# 备用数据库上超过主数据库年龄阈值的快照可能会变得无效，从而导致备用数据库上的事务取消。
										# 这是因为 old_snapshot_threshold 旨在为死行可能导致膨胀的时间提供绝对限制，否则会因为备用配置而被违反。
										
#wal_receiver_timeout = 60s             # time that receiver waits for
                                        # communication from primary
                                        # in milliseconds; 0 disables
										# 终止超过此时间不活动的复制连接。
										# 这对于接收备用服务器检测主节点崩溃或网络中断很有用。
										# 如果指定此值没有单位，则以毫秒为单位。
										# 默认值为 60 秒。
										# 零值禁用超时机制。
										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
#wal_retrieve_retry_interval = 5s       # time to wait before retrying to
                                        # retrieve WAL after a failed attempt
										# 指定当 WAL 数据不能从任何源（流复制、本地 pg_wal 或 WAL 归档）获得时，备用服务器应等待多长时间，
										# 然后再尝试检索 WAL 数据。
										# 如果指定此值没有单位，则以毫秒为单位。
										# 默认值为 5 秒。
										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。

										# 此参数在恢复中的节点需要控制等待新 WAL 数据可用的时间量的配置中很有用。
										# 例如，在归档恢复中，可以通过减小该参数的值来使恢复在检测到新的 WAL 日志文件时更加灵敏。
										# 在 WAL 活动较低的系统上，增加它会减少访问 WAL 档案所需的请求数量，这在考虑访问基础设施的次数的云环境中很有用。
										
#recovery_min_apply_delay = 0           # minimum delay for applying changes during recovery
										# 默认情况下，备用服务器会尽快从发送服务器恢复 WAL 记录。
										# 拥有数据的延时副本可能很有用，它提供了纠正数据丢失错误的机会。
										# 此参数允许您将恢复延迟指定的时间量。
										# 例如，如果您将此参数设置为 5min，则仅当备用数据库上的系统时间比主数据库报告的提交时间至少 5 分钟时，
										# 备用数据库才会重播每个事务提交。
										# 如果指定此值没有单位，则以毫秒为单位。
										# 默认为零，不添加延迟。

### - Subscribers -
#这些设置控制逻辑复制订阅者的行为。
#请注意，wal_receiver_timeout、wal_receiver_status_interval 和 wal_retrieve_retry_interval 配置参数也会影响逻辑复制工作者。
#These settings are ignored on a publisher.

#max_logical_replication_workers = 4    # taken from max_worker_processes
                                        # (change requires restart)
										# 指定逻辑复制工作者的最大数量。这包括应用工作者和表同步工作者。

										# 逻辑复制工作者从 max_worker_processes 定义的池中获取。

										# 默认值为 4。
										# 此参数只能在服务器启动时设置。
#max_sync_workers_per_subscription = 2  # taken from max_logical_replication_workers
										# 每个订阅的最大同步工作者数。此参数控制订阅初始化期间或添加新表时初始数据副本的并行度。

										# 目前，每个表只能有一个同步工作者。

										# 同步工作者从 max_logical_replication_workers 定义的池中获取。

										# 默认值为 2。
										# 该参数只能在 postgresql.conf 文件或服务器命令行中设置。


#------------------------------------------------------------------------------
## QUERY TUNING
#------------------------------------------------------------------------------

### - Planner Method Configuration -
#这些配置参数提供了一种影响查询优化器选择的查询计划的粗略方法。
#如果优化器为特定查询选择的默认计划不是最优的，临时解决方案是使用这些配置参数之一来强制优化器选择不同的计划。
#提高优化器选择的计划质量的更好方法包括调整计划器成本常量（参见第 20.7.2 节）、手动运行 ANALYZE、增加 default_statistics_target 配置参数的值
#以及增加为特定列收集的统计信息量使用 ALTER TABLE SET STATISTICS。

#enable_async_append = on 					# 启用或禁用查询计划器对异步感知追加计划类型的使用。默认为开启。
#enable_bitmapscan = on 					# 启用或禁用查询计划器对位图扫描计划类型的使用。默认为开启。
#enable_gathermerge = on 					# 启用或禁用查询计划器对收集合并计划类型的使用。默认为开启。
#enable_hashagg = on  						# 启用或禁用查询计划器对散列聚合计划类型的使用。默认为开启。
#enable_hashjoin = on						# 启用或禁用查询计划器对散列连接计划类型的使用。默认为开启。
#enable_incremental_sort = on				# 启用或禁用查询计划器对增量排序步骤的使用。默认为开启。
#enable_indexscan = on						# 启用或禁用查询计划器对索引扫描计划类型的使用。默认为开启。
#enable_indexonlyscan = on					# 启用或禁用查询计划器对仅索引扫描计划类型的使用（请参阅第 11.9 节）。默认为开启。
#enable_material = on						# 启用或禁用查询计划器对物化的使用。完全抑制物化是不可能的，但是关闭这个变量可以防止规划器插入物化节点，除非在需要正确性的情况下。默认为开启。
#enable_memoize = on						# 启用或禁用查询计划器使用 memoize 计划缓存来自嵌套循环连接内的参数化扫描的结果。当当前参数的结果已经在缓存中时，此计划类型允许跳过对基础计划的扫描。当新条目需要更多空间时，可能会从缓存中逐出不太常见的查找结果。默认为开启。
#enable_mergejoin = on						# 启用或禁用查询计划器对合并连接计划类型的使用。默认为开启。
#enable_nestloop = on						# 启用或禁用查询计划器对嵌套循环连接计划的使用。完全禁止嵌套循环连接是不可能的，但是如果有其他方法可用，关闭这个变量会阻止计划器使用一个。默认为开启。
#enable_parallel_append = on				# 启用或禁用查询计划器对并行感知追加计划类型的使用。默认为开启。
#enable_parallel_hash = on					# 启用或禁用查询计划器使用具有并行散列的散列连接计划类型。如果散列连接计划也未启用，则无效。默认为开启。
#enable_partition_pruning = on				# 启用或禁用查询计划器从查询计划中消除分区表的分区的能力。这也控制了规划器生成查询计划的能力，这些查询计划允许查询执行器在查询执行期间删除（忽略）分区。默认为开启。有关详细信息，请参阅第 5.11.4 节。
#enable_partitionwise_join = off			# 启用或禁用查询计划器对分区联接的使用，这允许通过联接匹配分区来执行分区表之间的联接。 Partitionwise join 当前仅适用于连接条件包括所有分区键的情况，这些分区键必须是相同的数据类型并且具有一对一匹配的子分区集。因为分区连接计划在计划期间可以使用显着更多的 CPU 时间和内存，所以默认是关闭的。
#enable_partitionwise_aggregate = off		# 启用或禁用查询计划器对分区分组或聚合的使用，这允许对每个分区单独执行的分区表进行分组或聚合。如果 GROUP BY 子句不包含分区键，则只能在每个分区的基础上执行部分聚合，并且必须稍后执行最终确定。因为按分区分组或聚合可以在规划期间使用显着更多的 CPU 时间和内存，所以默认设置为关闭。
#enable_seqscan = on                        # 启用或禁用查询计划程序对顺序扫描计划类型的使用。完全禁止顺序扫描是不可能的，但是如果有其他可用的方法，关闭这个变量会阻止规划器使用一个。默认为开启。
#enable_sort = on                           # 启用或禁用查询计划器对显式排序步骤的使用。完全禁止显式排序是不可能的，但是如果有其他可用的方法，关闭这个变量会阻止规划器使用一个。默认为开启。
#enable_tidscan = on                        # 启用或禁用查询计划程序对 TID 扫描计划类型的使用。默认为开启。

### - Planner Cost Constants -计划员成本常数
#本节中描述的成本变量是在任意尺度上测量的。只有它们的相对值很重要，因此将它们全部放大或缩小相同的因子不会导致规划者的选择发生变化。
#默认情况下，这些成本变量基于顺序页面获取的成本；也就是说，seq_page_cost 通常设置为 1.0，其他成本变量参考该值设置。
#但是，如果您愿意，可以使用不同的比例，例如在特定机器上以毫秒为单位的实际执行时间。

#注意
#不幸的是，没有明确的方法来确定成本变量的理想值。
#最好将它们视为特定安装将收到的整个查询组合的平均值。
#这意味着仅在几次实验的基础上更改它们是非常冒险的。

#seq_page_cost = 1.0                    # measured on an arbitrary scale 
										#设置计划者对作为一系列顺序提取的一部分的磁盘页面提取成本的估计。
										# 默认值为 1.0。
										# 通过设置同名的表空间参数，可以为特定表空间中的表和索引覆盖此值（请参阅 ALTER TABLESPACE）。
#random_page_cost = 4.0                 # same scale as above
										# 设置计划者对非顺序获取磁盘页面成本的估计。
										# 默认值为 4.0。通过设置同名的表空间参数，可以为特定表空间中的表和索引覆盖此值（请参阅 ALTER TABLESPACE）。
										# 相对于 seq_page_cost 减小这个值会导致系统更喜欢索引扫描；提高它会使索引扫描看起来相对更昂贵。
										# 可以同时提高或降低这两个值，以更改磁盘 I/O 成本相对于 CPU 成本的重要性，由以下参数描述。
										# 随机访问机械磁盘存储通常比顺序访问昂贵四倍多。
										# 但是，使用较低的默认值 (4.0)，因为大多数对磁盘的随机访问，例如索引读取，都假定在缓存中。
										# 可以将默认值视为将随机访问建模为比顺序访问慢 40 倍，同时期望 90% 的随机读取被缓存。
										
										# 如果您认为 90% 的缓存率对于您的工作负载来说是不正确的假设，您可以增加 random_page_cost 以更好地反映随机
										# 存储读取的真实成本。
										# 相应地，如果您的数据可能完全在缓存中，例如当数据库小于服务器总内存时，减少 random_page_cost 可能是合适的。
										# 相对于顺序读取成本较低的存储，例如固态驱动器，也可以使用较低的 random_page_cost 值（例如 1.1）更好地建模。
#提示
#尽管系统会让您将 random_page_cost 设置为小于 seq_page_cost，但这样做在物理上并不明智。
#但是，如果数据库完全缓存在 RAM 中，则将它们设置为相等是有意义的，因为在这种情况下，不按顺序触摸页面不会受到惩罚。
#此外，在一个高速缓存的数据库中，应该相对于 CPU 参数降低这两个值，因为获取已经在 RAM 中的页面的成本比通常要小得多。

#cpu_tuple_cost = 0.01                  # same scale as above 设置计划者对查询期间处理每一行的成本的估计。默认值为 0.01。
#cpu_index_tuple_cost = 0.005           # same scale as above 设置计划者对索引扫描期间处理每个索引条目的成本的估计。默认值为 0.005。
#cpu_operator_cost = 0.0025             # same scale as above 设置计划者对处理查询期间执行的每个运算符或函数的成本的估计。默认值为 0.0025。
#parallel_setup_cost = 1000.0   # same scale as above 设置计划者对启动并行工作进程成本的估计。默认值为 1000。
#parallel_tuple_cost = 0.1              # same scale as above 设置计划者对将一个元组从并行工作进程转移到另一个进程的成本的估计。默认值为 0.1。
#min_parallel_table_scan_size = 8MB		# 设置为考虑并行扫描而必须扫描的最小表数据量。
										# 对于并行顺序扫描，扫描的表数据量总是等于表的大小，但是当使用索引时，扫描的表数据量通常会更少。
										# 如果这个值没有指定单位，它被视为块，即 BLCKSZ 字节，通常为 8kB。
										# 默认值为 8 兆字节 (8MB)。
#min_parallel_index_scan_size = 512kB	# 设置为考虑并行扫描而必须扫描的最小索引数据量。
										# 请注意，并行索引扫描通常不会触及整个索引。
										# 规划者认为扫描实际会触及的页数是相关的。
										# 该参数还用于决定特定索引是否可以参与并行vacuum。见vacuum。
										# 如果这个值没有指定单位，它被视为块，即 BLCKSZ 字节，通常为 8kB。
										# 默认值为 512 KB (512kB)。
										
#effective_cache_size = 4GB             # 文件系统缓存，通常设置为总内存80% 50%~90%  多 少 并不会有严重影响
										# 设置规划器对单个查询可用的磁盘缓存的有效大小的假设。
										# 这被计入使用指数的成本估算中；较高的值使其更有可能使用索引扫描，较低的值使其更有可能使用顺序扫描。
										# 设置此参数时，您应该同时考虑 PostgreSQL 的共享缓冲区和将用于 PostgreSQL 数据文件的内核磁盘缓存部分，
										# 尽管这两个地方可能都存在一些数据。此外，还要考虑不同表上的预期并发查询数，因为它们必须共享可用空间。
										# 该参数对PostgreSQL分配的共享内存大小没有影响，也不保留内核磁盘缓存；它仅用于估计目的。
										# 系统也不假设数据在查询之间保留在磁盘缓存中。
										# 如果这个值没有指定单位，它被视为块，即 BLCKSZ 字节，通常为 8kB。
										# 默认值为 4 GB (4GB)。 （如果 BLCKSZ 不是 8kB，默认值会按比例缩放。）
										
#jit_above_cost = 100000                # perform JIT compilation if available
                                        # and query more expensive than this;
                                        # -1 disables
										# 如果启用，则设置激活 JIT 编译的查询成本（参见第 32 章）。
										# 执行 JIT 会花费计划时间，但可以加速查询执行。
										# 将此设置为 -1 将禁用 JIT 编译。
										# 默认值为 100000。
#jit_inline_above_cost = 500000         # inline small functions if query is
                                        # more expensive than this; -1 disables
										# 设置 JIT 编译尝试内联函数和运算符的查询成本。内联增加了计划时间，但可以提高执行速度。
										# 将此设置为小于 jit_above_cost 没有意义。
										# 将此设置为 -1 将禁用内联。
										# 默认值为 500000。
#jit_optimize_above_cost = 500000       # use expensive JIT optimizations if
                                        # query is more expensive than this;
                                        # -1 disables
										# 设置 JIT 编译应用昂贵优化的查询成本。这种优化增加了计划时间，但可以提高执行速度。
										# 将其设置为小于 jit_above_cost 没有意义，将其设置为大于 jit_inline_above_cost 不太可能有益。
										# 将此设置为 -1 会禁用昂贵的优化。
										# 默认值为 500000。

### - Genetic Query Optimizer - 查询优化器
#遗传查询优化器 (GEQO) 是一种使用启发式搜索进行查询规划的算法。
#这减少了复杂查询（加入许多关系的查询）的计划时间，代价是生成的计划有时不如正常的穷举搜索算法找到的计划。
#有关详细信息，请参阅第 60 章。

#geqo = on
										# 启用或禁用遗传查询优化。这是默认开启的。通常最好不要在生产中关闭它； geqo_threshold 变量提供对 GEQO 的更精细控制。
#geqo_threshold = 12					# 使用遗传查询优化来计划至少涉及这么多 FROM 项的查询。 （
										# 请注意，FULL OUTER JOIN 构造仅计为一个 FROM 项。）
										# 默认值为 12。
										# 对于更简单的查询，通常最好使用常规的详尽搜索计划器，但对于具有许多表的查询，
										# 详尽搜索需要太长时间，通常比执行次优计划的惩罚要长。
										# 因此，查询大小的阈值是管理 GEQO 使用的便捷方式。
#geqo_effort = 5                        # range 1-10
										# 控制 GEQO 中计划时间和查询计划质量之间的权衡。
										# 此变量必须是 1 到 10 范围内的整数。
										# 默认值为 5。
										# 较大的值会增加执行查询计划所花费的时间，但也会增加选择有效查询计划的可能性。
										
#geqo_pool_size = 0                     # selects default based on effort
										# 控制 GEQO 使用的池大小，即遗传种群中的个体数量。
										# 它必须至少为两个，有用的值通常是 100 到 1000。
										# 如果将其设置为零（默认设置），则根据 geqo_effort 和查询中的表数选择合适的值。
#geqo_generations = 0                   # selects default based on effort
										# 控制 GEQO 使用的代数，即算法的迭代次数。
										# 它必须至少为 1，并且有用的值与池大小在同一范围内。
										# 如果它设置为零（默认设置），则根据 geqo_pool_size 选择合适的值。
#geqo_selection_bias = 2.0              # range 1.5-2.0
										# 控制 GEQO 使用的选择偏差。选择偏差是群体内的选择压力。值可以从 1.50 到 2.00；后者是默认值。
#geqo_seed = 0.0                        # range 0.0-1.0
										# 控制 GEQO 用于通过连接顺序搜索空间选择随机路径的随机数生成器的初始值。
										# 该值的范围可以从零（默认值）到一。
										# 改变值会改变探索的连接路径集，并可能导致找到更好或更差的最佳路径。

### - Other Planner Options -  其他规划器选项

#default_statistics_target = 100        # range 1-10000
										# 为没有通过 ALTER TABLE SET STATISTICS 设置特定列目标的表列设置默认统计目标。
										# 较大的值会增加执行 ANALYZE 所需的时间，但可能会提高规划者估计的质量。
										# 默认值为 100。
										# 有关 PostgreSQL 查询计划器使用统计信息的更多信息，请参阅第 14.2 节。
#constraint_exclusion = partition       # on, off, or partition
										# 控制查询计划器使用表约束来优化查询。 
										# constraint_exclusion 的允许值为 on（检查所有表的约束）、off（从不检查约束）和 partition（仅检查继承子表和 UNION ALL 子查询的约束）。
										# 分区是默认设置。
										# 它通常与传统的继承树一起使用以提高性能。

										# 当此参数允许它用于特定表时，计划程序将查询条件与表的 CHECK 约束进行比较，并省略扫描条件与约束相矛盾的表。
										# 启用约束排除后，此 SELECT 将根本不扫描 child1000，从而提高性能。
										# 目前，默认情况下，仅对经常用于通过继承树实现表分区的情况启用约束排除。
										# 为所有表打开它会带来额外的计划开销，这在简单查询中非常明显，并且通常不会对简单查询产生任何好处。
										# 如果您没有使用传统继承进行分区的表，您可能更愿意完全关闭它。 
										# （请注意，分区表的等效功能由单独的参数 enable_partition_pruning 控制。）
#cursor_tuple_fraction = 0.1            # range 0.0-1.0
										# 设置计划者对将被检索的游标行的分数的估计。
										# 默认值为 0.1。
										# 此设置的较小值会使规划器倾向于使用游标的“快速启动”规划，这将快速检索前几行，而可能需要很长时间才能获取所有行。
										# 较大的值更加强调总估计时间。
										# 在最大设置为 1.0 时，游标的计划与常规查询完全一样，只考虑总估计时间，而不考虑第一行的交付时间。
#from_collapse_limit = 8
										# 如果生成的 FROM 列表不超过这么多项目，则计划器会将子查询合并到上层查询中。
										# 较小的值会减少计划时间，但可能会产生较差的查询计划。
										# 默认值为八。
										# 有关详细信息，请参阅第 14.3 节。
#jit = on                               # allow JIT compilation 
										# 确定 PostgreSQL 是否可以使用 JIT 编译（如果可用）（参见第 32 章）。默认为开启。
#join_collapse_limit = 8                # 1 disables collapsing of explicit
                                        # JOIN clauses
										# 每当生成不超过这么多项目的列表时，计划器将把显式 JOIN 构造（FULL JOIN 除外）重写为 FROM 项目列表。
										# 较小的值会减少计划时间，但可能会产生较差的查询计划。
										# 默认情况下，此变量设置为与 from_collapse_limit 相同，适用于大多数用途。
										# 将其设置为 1 可防止显式 JOIN 的任何重新排序。
										# 因此，查询中指定的显式连接顺序将是连接关系的实际顺序。
										# 因为查询计划器并不总是选择最佳连接顺序，高级用户可以选择暂时将此变量设置为 1，然后明确指定他们想要的连接顺序。
										# 有关详细信息，请参阅第 14.3 节。
										# 将此值设置为 geqo_threshold 或更大可能会触发 GEQO 计划器的使用，从而导致非最佳计划。请参阅第 20.7.3 节。
#plan_cache_mode = auto                 # auto, force_generic_plan or
                                        # force_custom_plan
										# 准备好的语句（显式准备或隐式生成，例如通过 PL/pgSQL）可以使用自定义或通用计划执行。
										# 使用其特定的参数值集为每次执行重新制定自定义计划，而通用计划不依赖于参数值并且可以跨执行重复使用。
										# 因此，使用通用计划可以节省计划时间，但如果理想计划强烈依赖于参数值，那么通用计划可能效率低下。
										# 这些选项之间的选择通常是自动进行的，但可以用 plan_cache_mode 覆盖。
										# 允许的值为 auto（默认值）、force_custom_plan 和 force_generic_plan。
										# 当要执行缓存计划时会考虑此设置，而不是在准备好计划时。有关更多信息，请参阅准备。


#------------------------------------------------------------------------------
## REPORTING AND LOGGING
#------------------------------------------------------------------------------

### - Where to Log -

log_destination = 'stderr'              # Valid values are combinations of
                                        # stderr, csvlog, syslog, and eventlog,
                                        # depending on platform.  csvlog
                                        # requires logging_collector to be on.
										# PostgreSQL 支持多种记录服务器消息的方法，包括 stderr、csvlog 和 syslog。在 Windows 上，还支持事件日志。
										# 将此参数设置为以逗号分隔的所需日志目标列表。
										# 默认情况下仅记录到 stderr。
										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。

										# 如果log_destination中包含csvlog，则日志条目以“逗号分隔值”（CSV）格式输出，便于将日志加载到程序中。
										# 必须启用 logging_collector 才能生成 CSV 格式的日志输出。

										# current_logfiles 在创建新日志文件作为轮换的效果时重新创建，并且当重新加载 log_destination 时。
										# 当 log_destination 中既不包含 stderr 也不包含 csvlog 并且禁用了日志收集器时，它将被删除。

#This is used when logging to stderr:
logging_collector = on          # Enable capturing of stderr and csvlog
                                        # into log files. Required to be on for
                                        # csvlogs.
                                        # (change requires restart)
										# 此参数启用日志收集器，这是一个后台进程，用于捕获发送到 stderr 的日志消息并将它们重定向到日志文件中。
										# 这种方法通常比记录到 syslog 更有用，因为某些类型的消息可能不会出现在 syslog 输出中。 
										# （一个常见的例子是动态链接器失败消息；另一个是脚本产生的错误消息，例如archive_command。）
										# 这个参数只能在服务器启动时设置。

#These are only used if logging_collector is on:
log_directory = 'log'                   # directory where log files are written,
                                        # can be absolute or relative to PGDATA
										# 启用 logging_collector 时，此参数确定将在其中创建日志文件的目录。
										# 它可以指定为绝对路径，或相对于集群数据目录。
										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
										# 默认为日志。
log_filename = 'postgresql-%Y-%m-%d_%H%M%S.log' # log file name pattern,
                                        # can include strftime() escapes
log_file_mode = 0600                    # creation mode for log files,
                                        # begin with 0 to use octal notation
										# 参数值应为以 chmod 和 umask 系统调用接受的格式指定的数字模式。 
										# （要使用惯用的八进制格式，数字必须以 0（零）开头。）
log_rotation_age = 1d                   # Automatic rotation of logfiles will
                                        # happen after that time.  0 disables.
										# 启用 logging_collector 时，此参数确定使用单个日志文件的最长时间，之后将创建一个新的日志文件。
										# 如果此值指定为不带单位，则以分钟为单位。
										# 默认值为 24 小时。
										# 设置为零以禁用基于时间的新日志文件创建。
										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
log_rotation_size = 10MB                # Automatic rotation of logfiles will
                                        # happen after that much log output.
                                        # 0 disables.
										# 此参数确定单个日志文件的最大大小。
										# 在将这些数据量发送到日志文件后，将创建一个新的日志文件。
										# 如果此值指定为不带单位，则以千字节为单位。
										# 默认值为 10 兆字节。
										# 设置为零以禁用基于大小的新日志文件创建。
										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
#log_truncate_on_rotation = off         # If on, an existing log file with the
                                        # same name as the new log file will be
                                        # truncated rather than appended to.
                                        # But such truncation only occurs on
                                        # time-driven rotation, not on restarts
                                        # or size-driven rotation.  Default is
                                        # off, meaning append to existing files
                                        # in all cases.
										# 此参数将导致 PostgreSQL 截断（覆盖）而不是附加到任何现有的同名日志文件。
										# 但是，仅当由于基于时间的轮换而打开新文件时才会发生截断，而不是在服务器启动或基于大小的轮换期间。
										# 关闭时，在所有情况下都将附加预先存在的文件。
										# 例如，将此设置与 postgresql-%H.log 之类的 log_filename 结合使用将导致生成 24 小时日志文件，然后循环覆盖它们。
										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
										
										# 示例：要保留7天的日志，每天一个日志文件名为server_log.Mon、server_log.Tue等，并自动用本周的日志覆盖上周的日志，
										# 设置：
										# log_filename = server_log.%a
										# log_truncate_on_rotation = on
										# log_rotation_age = 1440

#These are relevant when logging to syslog:
#syslog_facility = 'LOCAL0'
										# 启用日志记录到 syslog 时，此参数确定要使用的 syslog “工具”。
										# 您可以选择LOCAL0、LOCAL1、LOCAL2、LOCAL3、LOCAL4、LOCAL5、LOCAL6、LOCAL7；
										# 默认为 LOCAL0。另请参阅系统的 syslog 守护程序的文档。
										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
#syslog_ident = 'postgres'				# 启用日志记录到 syslog 时，此参数确定用于标识 syslog 日志中的 PostgreSQL 消息的程序名称。
										# 默认为 postgres。
										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
#syslog_sequence_numbers = on			# 当登录到 syslog 并且这是打开的（默认设置）时，每条消息都将以递增的序列号作为前缀（例如 [2]）。
										# 这绕过了许多 syslog 实现默认执行的“---最后一条消息重复 N 次 ---”抑制。
										# 在更现代的 syslog 实现中，可以配置重复消息抑制（例如，rsyslog 中的 $RepeatedMsgReduction），因此这可能不是必需的。
										# 此外，如果您真的想抑制重复的消息，您可以将其关闭。
#syslog_split_messages = on				# 启用日志记录到 syslog 时，此参数确定如何将消息传递到 syslog。
										# 启用时（默认），消息按行拆分，长行被拆分，以便它们适合 1024 字节，这是传统 syslog 实现的典型大小限制。
										# 关闭时，PostgreSQL 服务器日志消息按原样传递给 syslog 服务，由 syslog 服务来处理可能庞大的消息。

										# 如果 syslog 最终记录到一个文本文件，那么任何一种方式的效果都是一样的，最好保持设置打开，
										# 因为大多数 syslog 实现要么无法处理大消息，要么需要专门配置来处理它们。
										# 但是，如果 syslog 最终要写入其他介质，则将消息逻辑地放在一起可能是必要的或更有用的。

										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。

#This is only relevant when logging to eventlog (Windows):
#(change requires restart)
#event_source = 'PostgreSQL'
										# 启用记录到事件日志时，此参数确定用于标识日志中的 PostgreSQL 消息的程序名称。
										# 默认为 PostgreSQL。
										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。

### - When to Log -

#log_min_messages = warning             # values in order of decreasing detail:
                                        #   debug5
                                        #   debug4
                                        #   debug3
                                        #   debug2
                                        #   debug1
                                        #   info
                                        #   notice
                                        #   warning
                                        #   error
                                        #   log
                                        #   fatal
                                        #   panic
										# 控制将哪些消息级别写入服务器日志。
										# 每个级别包括其后的所有级别。
										# 级别越高，发送到日志的消息就越少。
										# 默认值为警告。
										# 请注意，此处的 LOG 与 client_min_messages 中的排名不同。只有超级用户可以更改此设置。
										# 
										
#log_min_error_statement = error        # values in order of decreasing detail:
                                        #   debug5
                                        #   debug4
                                        #   debug3
                                        #   debug2
                                        #   debug1
                                        #   info
                                        #   notice
                                        #   warning
                                        #   error
                                        #   log
                                        #   fatal
                                        #   panic (effectively off)
										# 控制在服务器日志中记录哪些导致错误条件的 SQL 语句。
										# 当前 SQL 语句包含在指定严重性或更高严重性的任何消息的日志条目中。
										# 默认值为 ERROR，这意味着将记录导致错误、日志消息、致命错误或恐慌的语句。
										# 要有效关闭失败语句的日志记录，请将此参数设置为 PANIC。
										# 只有超级用户可以更改此设置。
										
#log_min_duration_statement = -1        # -1 is disabled, 0 logs all statements
                                        # and their durations, &gt; 0 logs only
                                        # statements running at least this number
                                        # of milliseconds
										# 如果语句至少运行了指定的时间，则记录每个已完成语句的持续时间。
										# 例如，如果您将其设置为 250 毫秒，那么所有运行 250 毫秒或更长时间的 SQL 语句都将被记录。
										# 启用此参数有助于跟踪应用程序中未优化的查询。
										# 如果指定此值没有单位，则以毫秒为单位。将此设置为零会打印所有语句持续时间。 
										# -1（默认值）禁用记录语句持续时间。只有超级用户可以更改此设置。

										# 这将覆盖 log_min_duration_sample，这意味着持续时间超过此设置的查询不受采样的影响，并且始终被记录。

										# 对于使用扩展查询协议的客户端，Parse、Bind 和 Execute 步骤的持续时间是独立记录的。
										# 当将此选项与 log_statement 一起使用时，由于 log_statement 而记录的语句文本将不会在持续时间日志消息中重复。
										# 如果您不使用 syslog，建议您使用 log_line_prefix 记录 PID 或会话 ID，
										# 以便您可以使用进程 ID 或会话 ID 将语句消息链接到稍后的持续时间消息。

#log_min_duration_sample = -1           # -1 is disabled, 0 logs a sample of statements
                                        # and their durations, &gt; 0 logs only a sample of
                                        # statements running at least this number
                                        # of milliseconds;
                                        # sample fraction is determined by log_statement_sample_rate
										# 允许对至少运行指定时间量的已完成语句的持续时间进行采样。
										# 这会产生与 log_min_duration_statement 相同类型的日志条目，但仅针对已执行语句的子集，
										# 采样率由 log_statement_sample_rate 控制。
										# 例如，如果将其设置为 100 毫秒，那么所有运行 100 毫秒或更长的 SQL 语句都将被考虑进行采样。
										# 当流量太高而无法记录所有查询时，启用此参数会很有帮助。
										# 如果指定此值没有单位，则以毫秒为单位。
										# 将此设置为零对所有语句持续时间进行采样。 
										# -1（默认值）禁用采样语句持续时间。
										# 只有超级用户可以更改此设置。

										# 此设置的优先级低于 log_min_duration_statement，这意味着持续时间超过 log_min_duration_statement 的语句不受采样并始终记录。

#log_statement_sample_rate = 1.0        # fraction of logged statements exceeding
                                        # log_min_duration_sample to be logged;
                                        # 1.0 logs all such statements, 0.0 never logs
										# 确定将记录的持续时间超过 log_min_duration_sample 的语句的比例。
										# 抽样是随机的，例如 0.5 意味着在统计上，有二分之一的机会记录任何给定的语句。
										# 默认值为 1.0，表示记录所有采样语句。
										# 将此设置为零将禁用采样语句持续时间日志记录，与将 log_min_duration_sample 设置为 -1 相同。
										# 只有超级用户可以更改此设置。


#log_transaction_sample_rate = 0.0      # fraction of transactions whose statements
                                        # are logged regardless of their duration; 1.0 logs all
                                        # statements from all transactions, 0.0 never logs
										# 除了出于其他原因记录的语句之外，设置其语句全部记录的事务的比例。
										# 它适用于每笔新交易，无论其语句的持续时间如何。
										# 抽样是随机的，例如 0.1 表示统计上有十分之一的机会记录任何给定的交易。 
										# log_transaction_sample_rate 有助于构建交易样本。
										# 默认值为 0，表示不记录来自任何其他事务的语句。
										# 将此设置为 1 记录所有事务的所有语句。
										# 只有超级用户可以更改此设置。
										
										# 与所有语句记录选项一样，此选项会增加大量开销。
### - What to Log -

#application_name = 
										# application_name 可以是少于 NAMEDATALEN 字符的任何字符串（标准构建中为 64 个字符）。
										# 它通常由应用程序在连接到服务器时设置。
										# 该名称将显示在 pg_stat_activity 视图中并包含在 CSV 日志条目中。
										# 它也可以通过 log_line_prefix 参数包含在常规日志条目中。 
										# application_name 值中只能使用可打印的 ASCII 字符。其他字符将替换为问号 (?)。
#debug_print_parse = off
#debug_print_rewritten = off
#debug_print_plan = off
										# 这些参数可以发出各种调试输出。
										# 设置后，它们会打印生成的解析树、查询重写器输出或每个已执行查询的执行计划。
										# 这些消息在 LOG 消息级别发出，因此默认情况下它们会出现在服务器日志中，但不会发送到客户端。
										# 您可以通过调整 client_min_messages 和/或 log_min_messages 来更改它。
										# 这些参数默认是关闭的。
#debug_pretty_print = on
										# 设置后，debug_pretty_print 缩进由 debug_print_parse、debug_print_rewritten 或 debug_print_plan 生成的消息。
										# 与关闭时使用的“紧凑”格式相比，这会产生更具可读性但更长的输出。
										# 默认开启。
#log_autovacuum_min_duration = -1       # log autovacuum activity;
                                        # -1 disables, 0 logs all actions and
                                        # their durations, &gt; 0 logs only
                                        # actions running at least this number
                                        # of milliseconds.
										# 如果 autovacuum 执行的每个操作至少运行了指定的时间，则记录该操作。
										# 将此设置为零会记录所有 autovacuum 操作。 
										# -1（默认值）禁用记录 autovacuum 操作。
										# 如果指定此值没有单位，则以毫秒为单位。
										# 例如，如果您将其设置为 250 毫秒，那么所有运行 250 毫秒或更长时间的autovacuum和分析都会被记录下来。
										# 此外，当此参数设置为 -1 以外的任何值时，如果由于锁冲突或同时删除的关系而跳过自动清理操作，则会记录一条消息。
										# 启用此参数有助于跟踪 autovacuum 活动。
										# 该参数只能在 postgresql.conf 文件或服务器命令行中设置；但是可以通过更改表存储参数来覆盖单个表的设置。
#log_checkpoints = off
										# 导致在服务器日志中记录检查点和重新启动点。
										# 日志消息中包含一些统计信息，包括写入的缓冲区数量和写入它们所花费的时间。
										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
										# 默认为关闭。
										
#log_connections = off
										# 导致记录到服务器的每个尝试连接，以及成功完成客户端身份验证（如果需要）和授权。
										# 只有超级用户可以在会话开始时更改此参数，并且在会话中根本无法更改。
										# 默认为关闭。
										# 一些客户端程序，如 psql，在确定是否需要密码时尝试连接两次，因此重复的“收到连接”消息并不一定表示存在问题。
#log_disconnections = off				
										# 导致记录会话终止。
										# 日志输出提供类似于 log_connections 的信息，以及会话的持续时间。
										# 只有超级用户可以在会话开始时更改此参数，并且在会话中根本无法更改。
										# 默认为关闭。
#log_duration = off						# 导致记录每个已完成语句的持续时间。
										# 默认为关闭。
										# 只有超级用户可以更改此设置。

										# 对于使用扩展查询协议的客户端，Parse、Bind 和 Execute 步骤的持续时间是独立记录的。
										
#log_error_verbosity = default          # terse, default, or verbose messages
										# 控制记录在服务器日志中的每条消息的详细信息量。
										# 有效值为 TERSE、DEFAULT 和 VERBOSE，每个都向显示的消息添加更多字段。 
										# TERSE 不包括 DETAIL、HINT、QUERY 和 CONTEXT 错误信息的记录。 
										# VERBOSE 输出包括 SQLSTATE 错误代码（另请参阅附录 A）以及生成错误的源代码文件名、函数名和行号。
										# 只有超级用户可以更改此设置。
#log_hostname = off						# 
										# 默认情况下，连接日志消息仅显示连接主机的 IP 地址。
										# 打开此参数也会导致记录主机名。
										# 请注意，根据您的主机名解析设置，这可能会带来不可忽略的性能损失。
										# 此参数只能在 postgresql.conf 文件或服务器命令行中设置。
#log_line_prefix = '%m [%p] '           # special values:
                                        #   %a = application name
                                        #   %u = user name
                                        #   %d = database name
                                        #   %r = remote host and port
                                        #   %h = remote host
                                        #   %b = backend type
                                        #   %p = process ID
                                        #   %P = process ID of parallel group leader
                                        #   %t = timestamp without milliseconds
                                        #   %m = timestamp with milliseconds
                                        #   %n = timestamp with milliseconds (as a Unix epoch)
                                        #   %Q = query ID (0 if none or not computed)
                                        #   %i = command tag
                                        #   %e = SQL state
                                        #   %c = session ID
                                        #   %l = session line number
                                        #   %s = session start timestamp
                                        #   %v = virtual transaction ID
                                        #   %x = transaction ID (0 if none)
                                        #   %q = stop here in non-session
                                        #        processes
                                        #   %% = '%'
                                        # e.g. '&lt;%u%%%d&gt; '
#这是一个 printf 样式的字符串，在每个日志行的开头输出。 
#% 字符开始“转义序列”，这些字符被替换为如下所述的状态信息。
#无法识别的转义将被忽略。其他字符直接复制到日志行。
#有些转义只有会话进程才能识别，会被主服务器进程等后台进程视为空。
#通过在 % 之后和选项之前指定数字文字，状态信息可以左对齐或右对齐。
#负值将导致状态信息在右侧填充空格以使其具有最小宽度，而正值将在左侧填充。
#填充有助于提高日志文件的人类可读性。

#此参数只能在 postgresql.conf 文件或服务器命令行中设置。
#默认值为 '%m [%p] '，它记录时间戳和进程 ID。
#后端类型对应于视图 pg_stat_activity 中的列 backend_type，但在该视图中未显示的日志中可能会出现其他类型。

#%c 转义打印一个准唯一的会话标识符，由两个 4 字节的十六进制数字（不带前导零）组成，
#由一个点分隔。数字是进程开始时间和进程 ID，因此 %c 也可以用作打印这些项目的节省空间的方式。
#例如，要从 pg_stat_activity 生成会话标识符，请使用以下查询：
#提示
#如果您为 log_line_prefix 设置了一个非空值，您通常应该将其最后一个字符设置为空格，以提供与日志行其余部分的视觉分离。也可以使用标点符号。
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2f668cd135e5b14fb4eeeea203f5a89e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">idea使用 ( 二 ) 创建java项目</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6caabf474c8c97b34d02d40a6ed11127/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用docker搭建RocketMQ(非集群搭建官方镜像)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>