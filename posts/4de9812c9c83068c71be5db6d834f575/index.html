<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Shiro 中的 Realm - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Shiro 中的 Realm" />
<meta property="og:description" content="前言 之前写项目用了 Shiro 框架，来进行安全验证以及权限管理。当时项目赶得急，没怎么深入了解，只能说能跑能改，不过在使用的过程中发现 Shiro 确实很优秀。现在回过头来学习原理，读读源码，深入的学习下。·
本篇博文主要写的是关于使用 Shiro 起步时最重要的一块，找了一些资料，力求写得简单明了。
简介 Realm：域，Realm 充当了 Shiro 与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro 会从应用配置的 Realm 中查找用户及其权限信息。从这个意义上讲，Realm 实质上是一个安全相关的 DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给 Shiro 。当配置 Shiro时，你必须至少指定一个 Realm ，用于认证和（或）授权。配置多个 Realm 是可以的，但是至少需要一个。 Shiro 内置了可以连接大量安全数据源（又名目录）的 Realm，如 LDAP、关系数据库（JDBC）、类似 INI 的文本配置资源以及属性文件等。如果缺省的 Realm 不能满足需求，你还可以插入代表自定义数据源的自己的 Realm 实现。
功能 Realm能做的工作主要有以下几个方面：
身份验证（getAuthenticationInfo 方法）验证账户和密码，并返回相关信息
权限获取（getAuthorizationInfo 方法） 获取指定身份的权限，并返回相关信息
令牌支持（supports方法）判断该令牌（Token）是否被支持
令牌有很多种类型，例如：HostAuthenticationToken（主机验证令牌），UsernamePasswordToken（账户密码验证令牌）
这里主来说明一下关于前两点验证方面的逻辑，因为令牌一般用的都是 UsernamePasswordToken，哪怕用 HostAuthenticationToken，也没必要细讲，这个函数很少用到。
身份验证 我们看到第一个方法就是我们上面说的“验证账户和密码，并返回相关信息”的方法。从方法的名字上看，只有取得验证信息的意思，其实这里面还包括了进行验证的逻辑。 看Javadoc，这个方法的作用是：根据传进来的 Token，返回用户的验证信息。下面说明一下 Token 和 用户验证信息 。
Token：就是要拿来进行验证的信息，例如：如果是 UsernamePasswordToken 的话，这个 Token 的内容就是“用户提交的用户名和密码”。
来看下 UsernamePasswordToken 的属性。
public class UsernamePasswordToken implements HostAuthenticationToken, RememberMeAuthenticationToken { private String username; private char[] password; private boolean rememberMe; private String host; ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4de9812c9c83068c71be5db6d834f575/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-05-29T23:26:11+08:00" />
<meta property="article:modified_time" content="2018-05-29T23:26:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Shiro 中的 Realm</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="前言">前言</h3> 
<p>之前写项目用了 Shiro 框架，来进行安全验证以及权限管理。当时项目赶得急，没怎么深入了解，只能说能跑能改，不过在使用的过程中发现 Shiro 确实很优秀。现在回过头来学习原理，读读源码，深入的学习下。·</p> 
<p>本篇博文主要写的是关于使用 Shiro 起步时最重要的一块，找了一些资料，力求写得简单明了。</p> 
<h3 id="简介">简介</h3> 
<p>Realm：域，Realm 充当了 Shiro 与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro 会从应用配置的 Realm 中查找用户及其权限信息。从这个意义上讲，Realm 实质上是一个安全相关的 DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给 Shiro 。当配置 Shiro时，你必须至少指定一个 Realm ，用于认证和（或）授权。配置多个 Realm 是可以的，但是至少需要一个。 <br> Shiro 内置了可以连接大量安全数据源（又名目录）的 Realm，如 LDAP、关系数据库（JDBC）、类似 INI 的文本配置资源以及属性文件等。如果缺省的 Realm 不能满足需求，你还可以插入代表自定义数据源的自己的 Realm 实现。</p> 
<h3 id="功能">功能</h3> 
<p>Realm能做的工作主要有以下几个方面：</p> 
<ul><li><p><strong>身份</strong>验证（<code>getAuthenticationInfo</code> 方法）验证账户和密码，并返回相关信息</p></li><li><p><strong>权限</strong>获取（<code>getAuthorizationInfo</code> 方法） 获取指定身份的权限，并返回相关信息</p></li><li><p><strong>令牌</strong>支持（<code>supports</code>方法）判断该令牌（Token）是否被支持</p> <p>令牌有很多种类型，例如：HostAuthenticationToken（主机验证令牌），UsernamePasswordToken（账户密码验证令牌）</p></li></ul> 
<p>这里主来说明一下关于前两点验证方面的逻辑，因为令牌一般用的都是 UsernamePasswordToken，哪怕用 HostAuthenticationToken，也没必要细讲，这个函数很少用到。</p> 
<h4 id="身份验证">身份验证</h4> 
<p>我们看到第一个方法就是我们上面说的“验证账户和密码，并返回相关信息”的方法。从方法的名字上看，只有取得验证信息的意思，其实这里面还包括了进行验证的逻辑。 <br> 看Javadoc，这个方法的作用是：根据传进来的 Token，返回用户的验证信息。下面说明一下 Token 和 用户验证信息 。</p> 
<ul><li><p>Token：就是要拿来进行验证的信息，例如：如果是 UsernamePasswordToken 的话，这个 Token 的内容就是“用户提交的用户名和密码”。</p> <p>来看下 UsernamePasswordToken 的属性。</p> <pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsernamePasswordToken</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HostAuthenticationToken</span>, <span class="hljs-title">RememberMeAuthenticationToken</span> {<!-- --></span>
  <span class="hljs-keyword">private</span> String username;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] password;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> rememberMe;
  <span class="hljs-keyword">private</span> String host;
...</code></pre> <p>​</p></li><li><p>用户验证信息：就是用户验证通过后，返回给系统的信息。例如：用户登录验证的话，一般来说，返回给系统的“用户验证信息”就应该是这个用户的“用户名和密码”。但也可以返回其它信息，例如返回用户的“邮箱地址和登录密码”信息，做为“用户验证信息”。 那么返回给谁呢，Shiro 中的三大组件之一的 Subject。</p> <p>不细谈，这么说吧，Subject：即“<strong>当前操作用户</strong>”。但是，在 Shiro 中，Subject 这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着“当前跟软件交互的东西”。但考虑到大多数目的和用途，你可以把它认为是 Shiro 的“用户”概念。</p></li></ul> 
<p>上面说了“根据传进来的Token”和“返回用户的验证信息”，但没有说验证的过程，这个过程也是在这个方法中进行。我们看一下源码：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> AuthenticationInfo <span class="hljs-title">getAuthenticationInfo</span>(AuthenticationToken token) <span class="hljs-keyword">throws</span> AuthenticationException {

    AuthenticationInfo info = getCachedAuthenticationInfo(token);
    <span class="hljs-comment">// doGetAuthenticationInfo方法的内容，由各个子类来实现。</span>
    <span class="hljs-comment">// 主要是用来取得我们保存的“用户验证信息”，例如DB里保存的密码（具体看JdbcRealm的方法实现）</span>
    <span class="hljs-keyword">if</span> (info == <span class="hljs-keyword">null</span>) {
        info = doGetAuthenticationInfo(token);
        ...
    }
    <span class="hljs-comment">// 在这里，把用户提交的信息（Token）和我们保存的“用户验证信息”进行比较</span>
    <span class="hljs-comment">// 如果不通过，直接抛出定义好的异常。</span>
    <span class="hljs-keyword">if</span> (info != <span class="hljs-keyword">null</span>) {
        assertCredentialsMatch(token, info);
    } <span class="hljs-keyword">else</span> {

    <span class="hljs-keyword">return</span> info;
}</code></pre> 
<h4 id="权限获取">权限获取</h4> 
<p>“权限验证”的处理，是由接口定义的。但“验证是否有访问权限”的逻辑，则是由类定义的。定义的类为：<code>AuthorizingRealm</code> ，在这个类中有个<code>getAuthorizationInfo</code> 方法。这个方法和<code>getAuthenticationInfo</code> 方法的处理流程有点像：</p> 
<ul><li><p>验证是否有指定的权限</p></li><li><p>返回用户的权限信息</p></li></ul> 
<h4 id="调用时机">调用时机</h4> 
<p>下面看一个实际登录的 Controller 的例子：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-annotation">@Controller</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> {<!-- --></span>

    <span class="hljs-comment">//登录跳转</span>
    <span class="hljs-annotation">@RequestMapping</span>(value = <span class="hljs-string">"/login"</span>, method = {RequestMethod.GET})
    <span class="hljs-keyword">public</span> String <span class="hljs-title">loginUI</span>() <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"../../login"</span>;
    }

    <span class="hljs-comment">//登录跳转</span>
    <span class="hljs-annotation">@RequestMapping</span>(value = <span class="hljs-string">"/sxqy"</span>, method = {RequestMethod.GET})
    <span class="hljs-keyword">public</span> String <span class="hljs-title">loginUI2</span>() <span class="hljs-keyword">throws</span> Exception {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"../../login"</span>;
    }

    <span class="hljs-comment">//重点！！！！！！</span>
    <span class="hljs-comment">//登录表单处理</span>
    <span class="hljs-annotation">@RequestMapping</span>(value = <span class="hljs-string">"/login"</span>, method = {RequestMethod.POST})
    <span class="hljs-keyword">public</span> String <span class="hljs-title">login</span>(ViewEmployeeMiPsd viewEmployeeMiPsd) <span class="hljs-keyword">throws</span> Exception {

        <span class="hljs-comment">//Shiro实现登录</span>
        UsernamePasswordToken token = <span class="hljs-keyword">new</span> UsernamePasswordToken(viewEmployeeMiPsd.getCode(),
                viewEmployeeMiPsd.getPsd());
        Subject subject = SecurityUtils.getSubject();
        <span class="hljs-comment">//如果获取不到用户名就是登录失败，但登录失败的话，会直接抛出异常</span>
        <span class="hljs-keyword">try</span>{
            <span class="hljs-comment">//重点！！！！！！</span>
            <span class="hljs-comment">//getAuthenticationInfo 执行时机</span>
            subject.login(token);
        }<span class="hljs-keyword">catch</span> (Exception e){
            e.printStackTrace();
        }

        <span class="hljs-comment">//重点！！！！！！</span>
         <span class="hljs-comment">//getAuthorizationInfo  执行时机 -- subject.hasRole()</span>
        <span class="hljs-keyword">if</span> (subject.hasRole(<span class="hljs-string">"admin"</span>)) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/admin/showComputerProblems"</span>;
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!subject.hasRole(<span class="hljs-string">"admin"</span>)) {
            <span class="hljs-keyword">return</span> <span class="hljs-string">"redirect:/normal/showComputerProblems"</span>;
        }

        <span class="hljs-keyword">return</span> <span class="hljs-string">"/login"</span>;
    }

}</code></pre> 
<p>不过，<code>getAuthorizationInfo</code> 的执行调用方式包括上面的总共有三个：</p> 
<ol><li>subject.hasRole(“admin”) 或 subject.isPermitted(“admin”)：自己去调用这个是否有什么角色或者是否有什么权限的时候；</li><li>@RequiresRoles(“admin”) ：在方法上加注解的时候；</li><li>[@shiro.hasPermission name = “admin”][/@shiro.hasPermission]：在页面上加shiro标签的时候，即进这个页面的时候扫描到有这个标签的时候。</li></ol> 
<h3 id="实现">实现</h3> 
<p>需要注意的是，在 Shiro 实际使用中，我们是肯定会自定义一个 Realm 类的。</p> 
<p>从上面的功能说明可以看出来，在权限控制中比较重要的验证（登录或权限）逻辑，都是在Realm中做的。Realm的类继承如下： </p> 
<p><img src="https://images2.imgbox.com/12/bc/3P2yl1bv_o.png" alt="Realm类继承图" title=""></p> 
<p>不同的继承，需要实现不同的方法。继承了 AuthorizingRealm 的类，都要实现上面说的 <code>getAuthenticationInfo</code> 和 <code>getAuthorizationInfo</code> 方法，来完成身份验证和权限获取。但如果自定义的 Realm 类只实现 Realm 接口的话，只需要 <code>getAuthenticationInfo</code> 方法就可以。下面看一个只实现 Realm 接口的自定义 Realm：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRealm1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Realm</span> {<!-- --></span>  
    <span class="hljs-annotation">@Override</span>  
    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>() {  
        <span class="hljs-keyword">return</span> <span class="hljs-string">"myrealm1"</span>;  
    }  
    <span class="hljs-annotation">@Override</span>  
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">supports</span>(AuthenticationToken token) {  
        <span class="hljs-comment">//仅支持UsernamePasswordToken类型的Token  </span>
        <span class="hljs-keyword">return</span> token <span class="hljs-keyword">instanceof</span> UsernamePasswordToken;   
    }  
    <span class="hljs-annotation">@Override</span>  
    <span class="hljs-keyword">public</span> AuthenticationInfo <span class="hljs-title">getAuthenticationInfo</span>(AuthenticationToken token) <span class="hljs-keyword">throws</span> AuthenticationException {  
        String username = (String)token.getPrincipal();  <span class="hljs-comment">//得到用户名  </span>
        String password = <span class="hljs-keyword">new</span> String((<span class="hljs-keyword">char</span>[])token.getCredentials()); <span class="hljs-comment">//得到密码  </span>
        <span class="hljs-keyword">if</span>(!<span class="hljs-string">"zhang"</span>.equals(username)) {  
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAccountException(); <span class="hljs-comment">//如果用户名错误  </span>
        }  
        <span class="hljs-keyword">if</span>(!<span class="hljs-string">"123"</span>.equals(password)) {  
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IncorrectCredentialsException(); <span class="hljs-comment">//如果密码错误  </span>
        }  
        <span class="hljs-comment">//如果身份认证验证成功，返回一个AuthenticationInfo实现；  </span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(username, password, getName());  
    }  
}   </code></pre> 
<p>但是在使用中基本上都会对账户进行权限管理，下面看一个继承 AuthorizingRealm 的自定义 Realm：</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-annotation">@Component</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginRealm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AuthorizingRealm</span>{<!-- --></span>

    <span class="hljs-annotation">@SuppressWarnings</span>(<span class="hljs-string">"SpringJavaAutowiringInspection"</span>)<span class="hljs-comment">//忽略警告，下同</span>
    <span class="hljs-annotation">@Resource</span>(name = <span class="hljs-string">"roleServiceImpl"</span>)
    <span class="hljs-keyword">private</span> RoleService roleService;

    <span class="hljs-annotation">@SuppressWarnings</span>(<span class="hljs-string">"SpringJavaAutowiringInspection"</span>)<span class="hljs-comment">//忽略警告，下同</span>
    <span class="hljs-annotation">@Resource</span>(name = <span class="hljs-string">"viewEmployeeMiPsdServiceImpl"</span>)
    <span class="hljs-keyword">private</span> ViewEmployeeMiPsdService viewEmployeeMiPsdService;



    <span class="hljs-javadoc">/**
     *      获取身份信息，我们可以在这个方法中，从数据库获取该用户的权限和角色信息
     *      当调用权限验证时，就会调用此方法
     */</span>
    <span class="hljs-keyword">protected</span> AuthorizationInfo <span class="hljs-title">doGetAuthorizationInfo</span>(PrincipalCollection principalCollection) {

        String code = (String) getAvailablePrincipal(principalCollection);

        Role role = <span class="hljs-keyword">null</span>;
        ViewEmployeeMiPsd viewEmployeeMiPsd = <span class="hljs-keyword">null</span>;
        viewEmployeeMiPsd = viewEmployeeMiPsdService.findByCode(code);
        <span class="hljs-comment">//通过用户名从数据库获取角色权限集</span>
        SimpleAuthorizationInfo info = <span class="hljs-keyword">new</span> SimpleAuthorizationInfo();
        Set&lt;String&gt; r = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();
        <span class="hljs-keyword">if</span> (role != <span class="hljs-keyword">null</span>) {
            String[] roles = role.getRolename().split(<span class="hljs-string">"\\+"</span>);
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; roles.length; i++){
                r.add(roles[i].toString());
            }
            <span class="hljs-comment">//放入该用户权限信息</span>
            info.setRoles(r);
        }

        <span class="hljs-keyword">return</span> info;
    }

    <span class="hljs-javadoc">/**
     * 在这个方法中，进行身份验证
     * login时调用
     */</span>
    <span class="hljs-keyword">protected</span> AuthenticationInfo <span class="hljs-title">doGetAuthenticationInfo</span>(AuthenticationToken token) <span class="hljs-keyword">throws</span> AuthenticationException {
        <span class="hljs-comment">//工号</span>
        String code = (String) token.getPrincipal();
        <span class="hljs-comment">//密码</span>
        String password = <span class="hljs-keyword">new</span> String((<span class="hljs-keyword">char</span>[])token.getCredentials());

        ViewEmployeeMiPsd viewEmployeeMiPsd = <span class="hljs-keyword">null</span>;
        viewEmployeeMiPsd = viewEmployeeMiPsdService.findByCode(code);

        <span class="hljs-keyword">if</span> (viewEmployeeMiPsd == <span class="hljs-keyword">null</span>) {
            <span class="hljs-comment">//没有该用户</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnknownAccountException();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!password.equals(viewEmployeeMiPsd.getPsd())) {
            <span class="hljs-comment">//密码错误</span>
            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IncorrectCredentialsException();
        }

        <span class="hljs-comment">//身份验证通过,返回一个身份信息</span>
        AuthenticationInfo aInfo = <span class="hljs-keyword">new</span> SimpleAuthenticationInfo(code,password,getName());

        <span class="hljs-keyword">return</span> aInfo;
    }
}</code></pre> 
<h3 id="参考">参考</h3> 
<ol><li><a href="https://blog.csdn.net/hotdust/article/details/53869252">关于Shiro中的Realm</a> – <a href="https://blog.csdn.net/hotdust">hotdust</a></li><li><a href="https://blog.csdn.net/fj200821/article/details/54601629">关于何时执行shiro AuthorizingRealm 里的 doGetAuthenticationInfo与doGetAuthorizationInfo</a> – <a href="https://blog.csdn.net/fj200821">fj200821</a></li><li><a href="https://baike.baidu.com/item/shiro/17753571?fr=aladdin" rel="nofollow">shiro</a> – 百度百科</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3f443de916b896a36de21ea89ad5019c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">理解path.join() 和 path.resolve()</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f054ac8e58276f0c10f8354a46b2790f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">alibaba  trace_201708 数据集简介</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>