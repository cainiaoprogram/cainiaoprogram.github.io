<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>分类算法常用的评价指标 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="分类算法常用的评价指标" />
<meta property="og:description" content="文章目录 1，评价指标列表2，基本概念3，准确率(Accuracy)4，精确率(Precision)、召回率(Recall)和F1值5，综合评价指标F-Measure6，ROC曲线和AUC6.1，TPR、FPR&amp;TNR6.2 ，为什么引入ROC曲线？6.3 ，什么是ROC曲线？6.4，如何画ROC曲线6.5，什么是AUC曲线？6.6，怎样计算AUC？ 7，为什么使用ROC和AUC评价分类器呢？8，参考资料 该博文内容大部分是参考自Poll的笔记和dzl_ML两位博主的写作内容，再经过自己的学习，理解和整理后形成该文。参考资料的链接在最后部分给出。 1，评价指标列表 2，基本概念 针对一个二分类问题，即将实例分成正类（positive）或负类（negative），在实际分类中会出现以下四种情况：
（1）若一个实例是正类，并且被预测为正类，即为真正类(True Positive TP)
（2）若一个实例是正类，但是被预测为负类，即为假负类(False Negative FN)
（3）若一个实例是负类，但是被预测为正类，即为假正类(False Positive FP)
（4）若一个实例是负类，并且被预测为负类，即为真负类(True Negative TN)
3，准确率(Accuracy) 定义：对于给定的测试数据集，分类器正确分类的样本数与总样本数之比。计算公式： A c c u r a c y = T P &#43; T N T P &#43; T N &#43; F P &#43; F N Accuracy = \frac{TP&#43;TN}{TP&#43;TN&#43;FP&#43;FN} Accuracy=TP&#43;TN&#43;FP&#43;FNTP&#43;TN​缺点：在正负样本不平衡的情况下，这个指标有很大的缺陷。例如：给定一组测试样本共1100个实例，其中1000个是负类，剩余100个是正类。即使分类模型将所有实例均预测为负类，Accuracy也有90%以上，这样就没什么意义了。 4，精确率(Precision)、召回率(Recall)和F1值 精确率和召回率是广泛用于信息检索和统计学分类领域的两个度量值，用来评价结果的质量。其中：
精确率是检索出相关文档数与检索出的文档总数的比率（正确分类的正例个数占分类为正例的实例个数的比例），衡量的是检索系统的查准率。 p r e c i s i o n = T P T P &#43; F P precision = \frac{TP}{TP&#43;FP} precision=TP&#43;FPTP​召回率是指检索出的相关文档数和文档库中所有的相关文档数的比率（正确分类的正例个数占实际正例个数的比例），衡量的是检索系统的查全率。 r e c a l l = T P T P &#43; F N recall = \frac{TP}{TP&#43;FN} recall=TP&#43;FNTP​ 为了能够评价不同算法优劣，在Precision和Recall的基础上提出了F1值的概念，来对Precision和Recall进行整体评价。F1的定义如下： F 1 = 精确率 ∗ 召回率 ∗ 2 精确率 &#43; 召回率 F1 = \frac{精确率*召回率*2}{精确率&#43;召回率} F1=精确率&#43;召回率精确率∗召回率∗2​" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a2f8a32f7fdc76ede8500207d81f7a26/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-20T10:16:19+08:00" />
<meta property="article:modified_time" content="2023-01-20T10:16:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">分类算法常用的评价指标</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1_2" rel="nofollow">1，评价指标列表</a></li><li><a href="#2_4" rel="nofollow">2，基本概念</a></li><li><a href="#3Accuracy_10" rel="nofollow">3，准确率(Accuracy)</a></li><li><a href="#4PrecisionRecallF1_14" rel="nofollow">4，精确率(Precision)、召回率(Recall)和F1值</a></li><li><a href="#5FMeasure_21" rel="nofollow">5，综合评价指标F-Measure</a></li><li><a href="#6ROCAUC_24" rel="nofollow">6，ROC曲线和AUC</a></li><li><ul><li><a href="#61TPRFPRTNR_25" rel="nofollow">6.1，TPR、FPR&amp;TNR</a></li><li><a href="#62_ROC_30" rel="nofollow">6.2 ，为什么引入ROC曲线？</a></li><li><a href="#63_ROC_33" rel="nofollow">6.3 ，什么是ROC曲线？</a></li><li><a href="#64ROC_41" rel="nofollow">6.4，如何画ROC曲线</a></li><li><a href="#65AUC_46" rel="nofollow">6.5，什么是AUC曲线？</a></li><li><a href="#66AUC_49" rel="nofollow">6.6，怎样计算AUC？</a></li></ul> 
  </li><li><a href="#7ROCAUC_58" rel="nofollow">7，为什么使用ROC和AUC评价分类器呢？</a></li><li><a href="#8_63" rel="nofollow">8，参考资料</a></li></ul> 
</div> 
<br> 
<mark>该博文内容大部分是参考自<a href="https://www.cnblogs.com/maybe2030/p/5375175.html#_label3" rel="nofollow">Poll的笔记</a>和<a href="https://www.cnblogs.com/dlml/p/4403482.html" rel="nofollow">dzl_ML</a>两位博主的写作内容，再经过自己的学习，理解和整理后形成该文。参考资料的链接在最后部分给出。</mark> 
<p></p> 
<h2><a id="1_2"></a>1，评价指标列表</h2> 
<p><img src="https://images2.imgbox.com/12/4f/qUtj7Myt_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="2_4"></a>2，基本概念</h2> 
<p>针对一个二分类问题，即将实例分成正类（positive）或负类（negative），在实际分类中会出现以下四种情况：<br> （1）若一个实例是正类，并且被预测为正类，即为真正类(True Positive <strong>TP</strong>)<br> （2）若一个实例是正类，但是被预测为负类，即为假负类(False Negative <strong>FN</strong>)<br> （3）若一个实例是负类，但是被预测为正类，即为假正类(False Positive <strong>FP</strong>)<br> （4）若一个实例是负类，并且被预测为负类，即为真负类(True Negative <strong>TN</strong>)</p> 
<h2><a id="3Accuracy_10"></a>3，准确率(Accuracy)</h2> 
<ul><li>定义：对于给定的测试数据集，分类器正确分类的样本数与总样本数之比。</li><li>计算公式：<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           A 
          
         
           c 
          
         
           c 
          
         
           u 
          
         
           r 
          
         
           a 
          
         
           c 
          
         
           y 
          
         
           = 
          
          
           
           
             T 
            
           
             P 
            
           
             + 
            
           
             T 
            
           
             N 
            
           
           
           
             T 
            
           
             P 
            
           
             + 
            
           
             T 
            
           
             N 
            
           
             + 
            
           
             F 
            
           
             P 
            
           
             + 
            
           
             F 
            
           
             N 
            
           
          
         
        
          Accuracy = \frac{TP+TN}{TP+TN+FP+FN} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8778em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">cc</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0359em;">cy</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.1297em; vertical-align: -0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.3603em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">TP</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">TN</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">FP</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">FN</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">TP</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">TN</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.7693em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></li><li>缺点：在正负样本不平衡的情况下，这个指标有很大的缺陷。例如：给定一组测试样本共1100个实例，其中1000个是负类，剩余100个是正类。即使分类模型将所有实例均预测为负类，Accuracy也有90%以上，这样就没什么意义了。</li></ul> 
<h2><a id="4PrecisionRecallF1_14"></a>4，精确率(Precision)、召回率(Recall)和F1值</h2> 
<p>精确率和召回率是广泛用于信息检索和统计学分类领域的两个度量值，用来评价结果的质量。其中：</p> 
<ul><li><strong>精确率</strong>是检索出相关文档数与检索出的文档总数的比率（正确分类的正例个数占分类为正例的实例个数的比例），衡量的是检索系统的<strong>查准率</strong>。<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           p 
          
         
           r 
          
         
           e 
          
         
           c 
          
         
           i 
          
         
           s 
          
         
           i 
          
         
           o 
          
         
           n 
          
         
           = 
          
          
           
           
             T 
            
           
             P 
            
           
           
           
             T 
            
           
             P 
            
           
             + 
            
           
             F 
            
           
             P 
            
           
          
         
        
          precision = \frac{TP}{TP+FP} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.854em; vertical-align: -0.1944em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal">rec</span><span class="mord mathnormal">i</span><span class="mord mathnormal">s</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.1297em; vertical-align: -0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.3603em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">TP</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">FP</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">TP</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.7693em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></li><li><strong>召回率</strong>是指检索出的相关文档数和文档库中所有的相关文档数的比率（正确分类的正例个数占实际正例个数的比例），衡量的是检索系统的<strong>查全率</strong>。<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           r 
          
         
           e 
          
         
           c 
          
         
           a 
          
         
           l 
          
         
           l 
          
         
           = 
          
          
           
           
             T 
            
           
             P 
            
           
           
           
             T 
            
           
             P 
            
           
             + 
            
           
             F 
            
           
             N 
            
           
          
         
        
          recall = \frac{TP}{TP+FN} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal">rec</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right: 0.0197em;">ll</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.1297em; vertical-align: -0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.3603em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">TP</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">FN</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">TP</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.7693em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></li></ul> 
<p>为了能够评价不同算法优劣，在Precision和Recall的基础上提出了<strong>F1值</strong>的概念，来对Precision和Recall进行整体评价。F1的定义如下：<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          F 
         
        
          1 
         
        
          = 
         
         
          
          
            精确率 
           
          
            ∗ 
           
          
            召回率 
           
          
            ∗ 
           
          
            2 
           
          
          
          
            精确率 
           
          
            + 
           
          
            召回率 
           
          
         
        
       
         F1 = \frac{精确率*召回率*2}{精确率+召回率} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">F</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.1297em; vertical-align: -0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.3603em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord cjk_fallback">精确率</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord cjk_fallback">召回率</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord cjk_fallback">精确率</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord cjk_fallback">召回率</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.7693em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span><br> 我们当然希望检索结果（分类结果）的Precision越高越好，同时Recall也越高越好，但事实上这两者在某些情况下有矛盾的。比如极端情况下，我们只搜索出了一个结果，且是准确的（分类后的正确实例只有一个，且该实例原本就是正实例），那么Precision就是100%，但是Recall就会很低；而如果我们把所有结果都返回（所有的结果都被分类为正实例），那么Recall是100%，但是Precision就会很低。因此在不同的场合中需要自己判断希望Precision比较高还是Recall比较高。如果是做实验研究，可以绘制Precision-Recall曲线来帮助分析。</p> 
<h2><a id="5FMeasure_21"></a>5，综合评价指标F-Measure</h2> 
<p>Precision和Recall指标有时候会出现矛盾的情况，这样就需要综合考虑他们，最常见的方法就是F-Measure（又称为F-Score）。F-Score是Precision和Recall的加权调和平均：<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          F 
         
        
          = 
         
         
          
          
            ( 
           
           
           
             a 
            
           
             2 
            
           
          
            + 
           
          
            1 
           
          
            ) 
           
          
            P 
           
          
            ∗ 
           
          
            R 
           
          
          
           
           
             a 
            
           
             2 
            
           
          
            ( 
           
          
            P 
           
          
            + 
           
          
            R 
           
          
            ) 
           
          
         
        
       
         F=\frac{(a^2+1)P*R}{a^2(P+R)} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.1389em;">F</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.4271em; vertical-align: -0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.4911em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.7401em;"><span class="" style="top: -2.989em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal" style="margin-right: 0.0077em;">R</span><span class="mclose">)</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8141em;"><span class="" style="top: -3.063em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right: 0.1389em;">P</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal" style="margin-right: 0.0077em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.936em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span><br> 当参数<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
     
      
       
       
         a 
        
       
         = 
        
       
         1 
        
       
      
        a=1 
       
      
    </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>时，就是最常见的F1.因此，F1综合了P和R的结果，当F1较高时则能说明试验方法比较有效。</p> 
<h2><a id="6ROCAUC_24"></a>6，ROC曲线和AUC</h2> 
<h3><a id="61TPRFPRTNR_25"></a>6.1，TPR、FPR&amp;TNR</h3> 
<p>在介绍ROC和AUC之前，我们需要明确以下几个概念：</p> 
<ul><li><strong>真正类率（true positive rate, TPR）</strong>，也称为<strong>sensitivity</strong>，刻画的是被分类器正确分类的正实例占所有正实例的比例。<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           T 
          
         
           P 
          
         
           R 
          
         
           = 
          
          
           
           
             T 
            
           
             P 
            
           
           
           
             T 
            
           
             P 
            
           
             + 
            
           
             F 
            
           
             N 
            
           
          
         
        
          TPR=\frac{TP}{TP+FN} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0077em;">TPR</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.1297em; vertical-align: -0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.3603em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">TP</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">FN</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">TP</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.7693em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></li><li><strong>负正类率（false positive rate, FPR）</strong>，也称为<strong>1-specificity</strong>，计算的是被分类器错认为正类的负实例占所有负实例的比例。<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           F 
          
         
           P 
          
         
           R 
          
         
           = 
          
          
           
           
             F 
            
           
             P 
            
           
           
           
             F 
            
           
             P 
            
           
             + 
            
           
             T 
            
           
             N 
            
           
          
         
        
          FPR =\frac{FP}{FP+TN} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0077em;">FPR</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.1297em; vertical-align: -0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.3603em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">FP</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">TN</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">FP</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.7693em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></li><li><strong>真负类率（true negative rate, TNR）</strong>，也称为<strong>specificity</strong>，刻画的是被分类器正确分类的负实例占所有负实例的比例。<span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           T 
          
         
           N 
          
         
           R 
          
         
           = 
          
         
           1 
          
         
           − 
          
         
           F 
          
         
           P 
          
         
           R 
          
         
           = 
          
          
           
           
             T 
            
           
             N 
            
           
           
           
             F 
            
           
             P 
            
           
             + 
            
           
             T 
            
           
             N 
            
           
          
         
        
          TNR = 1 - FPR = \frac{TN}{FP+TN} 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0077em;">TNR</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7278em; vertical-align: -0.0833em;"></span><span class="mord">1</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.0077em;">FPR</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.1297em; vertical-align: -0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.3603em;"><span class="" style="top: -2.314em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.1389em;">FP</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">TN</span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.677em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">TN</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.7693em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></li></ul> 
<h3><a id="62_ROC_30"></a>6.2 ，为什么引入ROC曲线？</h3> 
<ul><li>Motivation1：在一个二分类模型中，对于所得到的连续结果，假设已确定一个阈值，比如说0.6，大于这个值的实例为正类，小于这个值则为负类。如果减小阈值，比如减到0.5，固然能之别出更多的正类，也就是提高了识别出的正例占所有正例的比例，即TPR值变大；但同时也将更多的负实例当作了正实例，即，提高了FPR。为了形象化这一变化，引入了ROC，ROC可以用于评价一个分类器。</li><li>Motivation2：在类不平衡的情况下，如正样本90个，负样本10个，直接把所有样本分类为正样本，得到识别率为90%。但这显然是没有意义的。单纯根据Precision和Rcall来衡量算法的优劣已经不能表征这种病态问题。</li></ul> 
<h3><a id="63_ROC_33"></a>6.3 ，什么是ROC曲线？</h3> 
<p>ROC曲线：接收者操作特征（receiver operating characteristic），ROC曲线上每个点反映着对同一信号刺激的感受性。</p> 
<ul><li>横轴：负正类率（FPR，特异度）；</li><li>纵轴：真正类率（TPR，灵敏度）。</li></ul> 
<p>以逻辑回归分类器（LR）举例，LR给出了针对每个实例为正类的概率，那么通过设定一个阈值如0.6，概率大于等于0.6的为正类，小于0.6的为负类。对应的就可以算出一组（FPR,TPR），在平面中得到对应坐标点。随着阈值的逐渐减小，越来越多的实例被划分为正类，但是这些正类汇中同样也掺杂着真正的负实例，即TPR和FPR会同时增大。阈值最大时，对应坐标点为（0,0），阈值最小时，对应坐标点（1,1）。如下这幅图，图(a)中实线为ROC曲线，线上每个点对应一个阈值。<br> <img src="https://images2.imgbox.com/dd/f4/qtQn5eDZ_o.jpg" alt="在这里插入图片描述"><br> <strong>理想目标： TPR=1, FPR=0，即图中(0,1)点。故ROC曲线越靠拢(0,1)点，即，越偏离45度对角线越好。</strong></p> 
<h3><a id="64ROC_41"></a>6.4，如何画ROC曲线</h3> 
<p>假设已经得出一系列被划分为正类的概率，然后按照大小排序，下图是一个示例，图中共有20个测试样本，“Class”一栏表示每个测试样本真正的标签（p表示正样本，n表示负样本），“Score”表示每个测试样本属于正样本的概率。<br> <img src="https://images2.imgbox.com/b7/ab/Ue5QUvsz_o.jpg" alt="在这里插入图片描述"><br> 接下来，我们从高到低，依次将“Score”值作为阈值threshold，当测试样本属于正样本的概率大于或等于这个threshold时，我们认为它为正样本，否则为负样本。举例来说，对于图中的第4个样本，其“Score”值为0.6，那么样本1，2，3，4都被认为是正样本，因为它们的“Score”值都大于等于0.6，而其他样本则都认为是负样本。每次选取一个不同的threshold，我们就可以得到一组FPR和TPR，即ROC曲线上的一点。这样一来，我们一共得到了20组FPR和TPR的值，将它们画在ROC曲线的结果如下图：<br> <img src="https://images2.imgbox.com/ad/79/VDOhmIzz_o.jpg" alt="在这里插入图片描述"></p> 
<h3><a id="65AUC_46"></a>6.5，什么是AUC曲线？</h3> 
<p>AUC(Area Under Curve)：ROC曲线下的面积，介于0.1和1之间。AUC作为数值可以直观的评价分类器的好坏，值越大越好。<br> <strong>AUC的物理意义</strong>：首先AUC值是一个概率值。假设分类器的输出是样本属于正类的Score（置信度），则AUC的物理意义为，任取一对（正、负）样本，正样本的Score大于负样本的Score的概率。</p> 
<h3><a id="66AUC_49"></a>6.6，怎样计算AUC？</h3> 
<ul><li> <p>方法一：AUC为ROC曲线下的面积，那我们直接极端面积可得。面积为一个个小的梯形面积之和。计算的精度与阈值的精度有关。</p> </li><li> <p><strong>方法二</strong>：根据AUC的物理意义，我们计算正样本Score大于负样本Score的概率。取<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           N 
          
         
           ∗ 
          
         
           M 
          
         
           ( 
          
         
           N 
          
         
           为正样本数， 
          
         
           M 
          
         
           为负样本数 
          
         
           ) 
          
         
        
          N*M(N为正样本数，M为负样本数) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mord cjk_fallback">为正样本数，</span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mord cjk_fallback">为负样本数</span><span class="mclose">)</span></span></span></span></span>个二元组，比较Score，最后得到AUC。时间复杂度为<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           O 
          
         
           ( 
          
         
           N 
          
         
           ∗ 
          
         
           M 
          
         
           ) 
          
         
        
          O(N*M) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mclose">)</span></span></span></span></span>。<br> <mark>具体的计算方法详见</mark><a href="https://blog.csdn.net/qq_22238533/article/details/78666436">AUC的计算方法</a></p> </li><li> <p><strong>方法三</strong>：我们首先把所有样本按照score排序（从小到大或从大到小），依次用rank表示他们，如，按从大到小排序的时候，最大score的样本序号值<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           r 
          
         
           a 
          
         
           n 
          
         
           k 
          
         
           = 
          
         
           n 
          
         
        
          rank=n 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal" style="margin-right: 0.0315em;">ank</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span></span>，其中<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           n 
          
         
           = 
          
         
           M 
          
         
           + 
          
         
           N 
          
         
        
          n=M+N 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 0.7667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span></span></span>，其次是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           n 
          
         
           − 
          
         
           1 
          
         
        
          n-1 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6667em; vertical-align: -0.0833em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 0.6444em;"></span><span class="mord">1</span></span></span></span></span>。然后利用下面的公式计算AUC,<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
        
         
          
          
            A 
           
          
            U 
           
          
            C 
           
          
            = 
           
           
            
             
             
               ∑ 
              
             
               所有正样本 
              
             
            
              r 
             
            
              a 
             
            
              n 
             
            
              k 
             
            
              − 
             
             
              
              
                M 
               
              
                ∗ 
               
              
                ( 
               
              
                M 
               
              
                − 
               
              
                1 
               
              
                ) 
               
              
             
               2 
              
             
            
            
            
              M 
             
            
              ∗ 
             
            
              N 
             
            
           
          
         
           AUC = \frac{\sum_{所有正样本}rank-\frac{M*(M-1)}{2}}{M*N} 
          
         
       </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6833em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right: 0.109em;">U</span><span class="mord mathnormal" style="margin-right: 0.0715em;">C</span><span class="mspace" style="margin-right: 0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.2778em;"></span></span><span class="base"><span class="strut" style="height: 2.431em; vertical-align: -0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.745em;"><span class="" style="top: -2.324em;"><span class="pstrut" style="height: 3.01em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span></span></span><span class="" style="top: -3.24em;"><span class="pstrut" style="height: 3.01em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.745em;"><span class="pstrut" style="height: 3.01em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: 0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1786em;"><span class="" style="top: -2.4003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">所有正样本</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2997em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal" style="margin-right: 0.0315em;">ank</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.01em;"><span class="" style="top: -2.655em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span class="" style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span class="" style="top: -3.485em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right: 0.109em;">M</span><span class="mbin mtight">∗</span><span class="mopen mtight">(</span><span class="mord mathnormal mtight" style="margin-right: 0.109em;">M</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.345em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.686em;"><span class=""></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span><br> 其中，<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            ∑ 
           
          
            所有正样本 
           
          
         
           r 
          
         
           a 
          
         
           n 
          
         
           k 
          
         
        
          \sum_{所有正样本}rank 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1.0497em; vertical-align: -0.2997em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position: relative; top: 0em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.1786em;"><span class="" style="top: -2.4003em; margin-left: 0em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">所有正样本</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.2997em;"><span class=""></span></span></span></span></span></span><span class="mspace" style="margin-right: 0.1667em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal" style="margin-right: 0.0315em;">ank</span></span></span></span></span> 表示所有正样本的序号值<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           r 
          
         
           a 
          
         
           n 
          
         
           k 
          
         
        
          rank 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.6944em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">r</span><span class="mord mathnormal" style="margin-right: 0.0315em;">ank</span></span></span></span></span>之和；时间复杂度是<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           O 
          
         
           ( 
          
         
           M 
          
         
           + 
          
         
           N 
          
         
           ) 
          
         
        
          O(M+N) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.0278em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right: 0.109em;">M</span><span class="mspace" style="margin-right: 0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.2222em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathnormal" style="margin-right: 0.109em;">N</span><span class="mclose">)</span></span></span></span></span>。<br> <mark>具体的计算案例详见</mark><a href="https://blog.csdn.net/qq_22238533/article/details/78666436">AUC的计算方法</a></p> </li></ul> 
<h2><a id="7ROCAUC_58"></a>7，为什么使用ROC和AUC评价分类器呢？</h2> 
<p>既然已经这么多标准，为什么还要使用ROC和AUC呢？因为ROC曲线有个很好的特性：<strong>当测试集中的正负样本的分布变换的时候，ROC曲线能够保持不变</strong>。在实际的数据集中经常会出现样本类不平衡，即正负样本比例差距较大，而且测试数据中的正负样本也可能随着时间变化。下图是ROC曲线和Presision-Recall曲线的对比：<br> <img src="https://images2.imgbox.com/38/84/AwMJ41r1_o.jpg" alt="在这里插入图片描述"><br> 在上图中，(a)和©为Roc曲线，(b)和(d)为Precision-Recall曲线。<br> (a)和(b)展示的是分类其在原始测试集(正负样本分布平衡)的结果，©(d)是将测试集中负样本的数量增加到原来的10倍后，分类器的结果，可以明显的看出，ROC曲线基本保持原貌，而Precision-Recall曲线变化较大。</p> 
<h2><a id="8_63"></a>8，参考资料</h2> 
<blockquote> 
 <p>https://www.cnblogs.com/maybe2030/p/5375175.html#_label3<br> https://www.cnblogs.com/dlml/p/4403482.html<br> https://blog.csdn.net/qq_22238533/article/details/78666436</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a72abc98cb893fd319d49822996a4e22/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">(附源码)基于vue框架潮牌官网设计与实现 毕业设计010955</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9ba0c96c7c2fb8c089b24a4e1c7ad655/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Pytorch实战笔记(2)——CNN实现情感分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>