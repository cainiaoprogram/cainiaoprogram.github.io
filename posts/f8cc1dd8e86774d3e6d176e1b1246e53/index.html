<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>逻辑斯谛回归（Logistic回归）最详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="逻辑斯谛回归（Logistic回归）最详解" />
<meta property="og:description" content="Logistic回归学习思路
一.逻辑回归模型的原理与定义（主要思想） 逻辑斯谛回归是经典的分类方法，它属于对数线性模型，原理是根据现有的数据对分类边界线建立回归公式，以此进行分类。（主要思想）
定义： 在线性回归模型的基础上，使用Sigmoid函数，将线性模型的结果压缩到[0,1]之间，使其拥有概率意义，它可以将任意输入映射到[0,1]区间，实现值到概率转换。
属于概率性判别式模型线性分类算法 在学习逻辑回归模型之前，先来看一下逻辑斯谛分布，因为我们的逻辑斯蒂模型就是根据逻辑斯蒂分布得到的；通过参数估计方法直接估计出参数，从而得到P(Y|X)。
下面给出《统计学习方法》上逻辑斯蒂分布的定义：
二.逻辑回归的推导过程 为了实现根据所有输入预测出类别，为此引入了sigmoid函数p=1/（1&#43;exp(-z)）,sigmoid函数刚好也有二分类的功能。
1. 为什么要使用sigmoid函数作为假设？
因为线性回归模型的预测值为一般为大于1的实数，而样本的类标签为（0,1），我们需要将分类任务的真实标记y与线性回归模型的预测值联系起来，也就是找到广义线性模型中的联系函数。如果选择单位阶跃函数的话，它是不连续的不可微。而如果选择sigmoid函数，它是连续的，而且能够将z转化为一个接近0或1的值。
当z=0时，p=0.5
当z&gt;0时，p&gt;0.5 归为1类
当z&lt;0时，p&lt;0.5 归为0类
确定了分类器的函数形式，最佳回归系数是多少，如何确定？
sigmoid函数的输入记为z,将线性模型结果赋值到z,即：
z=w0x0&#43;w1x1&#43;w2x2&#43;w3x3...wnxn
如果采用向量的写法，
上述公式写成z=WT*X，
其中向量X是分类器的输入数据，即为特征值；向量W就是我们要找到的最佳参数，从而使得分类器尽可能精确。
为了找出最佳的回归系数，所以我们可以对两种损失函数进行优化算法
①均方差 （后面会介绍舍弃使用这种作为损失函数）
②对数极大似然估计法
三.数学模型 二项逻辑斯蒂回归模型
知道分布的定义和推导过程之后，就是给出我们的逻辑斯蒂模型了：
引用了李航的《统计学习方法》书中如下
注意：（1）最终的结果是通过比较P(Y=1|X)和P(Y=0|X)的大小来确定类别的（类似于朴素贝叶斯）；
（2）b在这里其实可以看做是w0x0，其中x0 = 1；
（3）其实本质上这个就是一个二项分布，所以遵循二项分布的分布律。
事件的对数几率（log odds）
也就是说，如果我的模型是逻辑回归模型，那么事件{Y=1|X}发生的对数几率就是输入X的线性函数（模型），反之，知道了这个推论，我们是可以反推出逻辑斯蒂模型的形式的
四.目标函数 求目标参数，常用目标函数的选取：
①损失函数：均方差（标准值-预测值）
②对数似然函数
首先极大似然函数是一种确定模型参数的方法，它确定参数值的方法是通过找到最大化模型产生真实数据的那一组参数。
最大似然估计就是通过已知结果去反推最大概率导致该结果的参数。
极大似然估计是概率论在统计学中的应用，它提供了一种给定观察数据来评估模型参数的方法，即 “模型已定，参数未知”，通过若干次试验，观察其结果，利用实验结果得到某个参数值能够使样本出现的概率为最大，则称为极大似然估计。逻辑回归是一种监督式学习，是有训练标签的，就是有已知结果的，从这个已知结果入手，去推导能获得最大概率的结果参数，只要我们得出了这个参数，那我们的模型就自然可以很准确的预测未知的数据了。（对极大似然函数的详细理解可以参考：https://blog.csdn.net/qq_44543774/article/details/109735754）
通过极大似然推导得出逻辑回归的目标函数，这里我给出手写的推导：
极大似然函数是概率论在统计学中的应用，它提供了一种给定观察数据来评估模型参数的方法，即 “模型已定，参数未知”，通过若干次试验，观察其结果，利用实验结果得到某个参数值能够使样本出现的概率为最大，则称为极大似然估计。通过求极大似然函数来得到参数w的估计值。
以上就是通过极大似然函数作为目标函数，得出了参数向量w值
综上logistic回归模型的目标函数是极大似然函数
五.算法源码 源码：
from sklearn.linear_model import LogisticRegression from math import exp from math import * from sklearn.datasets import load_iris from sklearn." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f8cc1dd8e86774d3e6d176e1b1246e53/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-14T20:33:44+08:00" />
<meta property="article:modified_time" content="2021-03-14T20:33:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">逻辑斯谛回归（Logistic回归）最详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>                                                                                Logistic回归学习思路</strong></p> 
<p><strong><img alt="" height="235" src="https://images2.imgbox.com/93/3e/gXVQaRlZ_o.png" width="780"></strong></p> 
<h2>一.逻辑回归模型的原理与定义（主要思想）</h2> 
<p>逻辑斯谛回归是经典的分类方法，它属于对数线性模型，原理是根据现有的数据对分类边界线建立回归公式，以此进行分类。（主要思想）</p> 
<h4>定义：</h4> 
<p>在线性回归模型的基础上，使用Sigmoid函数，将线性模型的结果压缩到[0,1]之间，使其拥有概率意义，它可以将任意输入映射到[0,1]区间，实现值到概率转换。</p> 
<ul><li>属于概率性判别式模型</li><li>线性分类算法</li></ul> 
<p>在学习逻辑回归模型之前，先来看一下逻辑斯谛分布，因为我们的逻辑斯蒂模型就是根据逻辑斯蒂分布得到的；通过参数估计方法直接估计出参数，从而得到P(Y|X)。</p> 
<p>下面给出《统计学习方法》上逻辑斯蒂分布的定义：</p> 
<p><img alt="" src="https://images2.imgbox.com/14/d1/OwZWQ4sf_o.png"></p> 
<h2>二.逻辑回归的推导过程</h2> 
<p>为了实现根据所有输入预测出类别，为此引入了sigmoid函数p=1/（1+exp(-z)）,sigmoid函数刚好也有二分类的功能。</p> 
<p>1. 为什么要使用sigmoid函数作为假设？</p> 
<p>因为线性回归模型的预测值为一般为大于1的实数，而样本的类标签为（0,1），我们需要将分类任务的真实标记y与线性回归模型的预测值联系起来，也就是找到广义线性模型中的联系函数。如果选择单位阶跃函数的话，它是不连续的不可微。而如果选择sigmoid函数，它是连续的，而且能够将z转化为一个接近0或1的值。</p> 
<p>当z=0时，p=0.5<br> 当z&gt;0时，p&gt;0.5  归为1类<br> 当z&lt;0时，p&lt;0.5  归为0类<br> 确定了分类器的函数形式，最佳回归系数是多少，如何确定？<br><strong>sigmoid函数的输入记为z,将线性模型结果赋值到z</strong>,即：<br> z=w0x0+w1x1+w2x2+w3x3...wnxn<br> 如果采用向量的写法，<br> 上述公式写成z=WT*X，<br> 其中向量X是分类器的输入数据，即为特征值；向量W就是我们要找到的最佳参数，从而使得分类器尽可能精确。<br> 为了找出最佳的回归系数，所以我们可以对两种损失函数进行优化算法<br> ①均方差 （后面会介绍舍弃使用这种作为损失函数）</p> 
<p>②对数极大似然估计法</p> 
<h2>三.数学模型</h2> 
<p><strong>二项逻辑斯蒂回归模型</strong></p> 
<p>知道分布的定义和推导过程之后，就是给出我们的逻辑斯蒂模型了：</p> 
<p>引用了李航的《统计学习方法》书中如下</p> 
<p><img alt="" src="https://images2.imgbox.com/09/ef/Ii5le5WS_o.png"></p> 
<p><span style="color:#7c79e5;"><u><strong>注意</strong></u></span>：<strong>（1）最终的结果是通过比较P(Y=1|X)和P(Y=0|X)的大小来确定类别的（类似于朴素贝叶斯）；</strong></p> 
<p><strong>          （2）b在这里其实可以看做是w0x0，其中x0 = 1；</strong></p> 
<p><strong>          （3）其实本质上这个就是一个二项分布，所以遵循二项分布的分布律。</strong></p> 
<p><strong>事件的对数几率（log odds）</strong></p> 
<p><img alt="" src="https://images2.imgbox.com/21/7b/ySo5kBcU_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/4c/d5/n0fB3z9m_o.png"></p> 
<p>也就是说，如果我的模型是逻辑回归模型，那么事件{Y=1|X}发生的对数几率就是输入X的线性函数（模型），反之，知道了这个推论，我们是可以反推出逻辑斯蒂模型的形式的</p> 
<p><img alt="" height="527" src="https://images2.imgbox.com/6d/58/3fKwqlu5_o.png" width="542"></p> 
<h2>四.目标函数</h2> 
<p>求目标参数，常用目标函数的选取：</p> 
<p style="margin-left:0pt;"><strong>①损失函数</strong>：均方差（标准值-预测值）</p> 
<p style="margin-left:0pt;"><img alt="" src="https://images2.imgbox.com/0d/46/AsVCxVs4_o.png"></p> 
<p style="margin-left:0pt;"><img alt="" src="https://images2.imgbox.com/08/a8/dsWxcAQd_o.png"></p> 
<p style="margin-left:0pt;"><strong><strong>②</strong></strong>对数似然函数</p> 
<p style="margin-left:0pt;">首先极大似然函数是一种确定模型参数的方法，它确定参数值的方法是通过找到最大化模型产生真实数据的那一组参数。</p> 
<p style="margin-left:0pt;"><strong><span style="color:#4d4d4d;"><strong>最大似然估计就是通过已知结果去反推最大概率导致该结果的参数</strong></span></strong><span style="color:#4d4d4d;">。</span></p> 
<p style="margin-left:0pt;"><span style="color:#4d4d4d;">极大似然估计是概率论在统计学中的应用，它提供了一种给定观察数据来评估模型参数的方法，即 “模型已定，参数未知”，通过若干次试验，观察其结果，利用实验结果得到某个参数值能够使样本出现的概率为最大，则称为极大似然估计。逻辑回归是一种监督式学习，是有训练标签的，就是有已知结果的，从这个已知结果入手，去推导能获得最大概率的结果参数，只要我们得出了这个参数，那我们的模型就自然可以很准确的预测未知的数据了。（对极大似然函数的详细理解可以参考：</span><a href="https://blog.csdn.net/qq_44543774/article/details/109735754">https://blog.csdn.net/qq_44543774/article/details/109735754</a><span style="color:#4d4d4d;">）</span></p> 
<p style="margin-left:0pt;"> </p> 
<p>通过极大似然推导得出逻辑回归的目标函数，这里我给出手写的推导：</p> 
<p><img alt="" height="681" src="https://images2.imgbox.com/ad/55/7bWzjQJ8_o.png" width="511"></p> 
<p style="margin-left:0pt;"><span style="color:#4d4d4d;">极大似然函数是概率论在统计学中的应用，它提供了一种给定观察数据来评估模型参数的方法，即 “模型已定，参数未知”，通过若干次试验，观察其结果，<u><strong>利用实验结果得到某个参数值</strong></u></span><span style="color:#7c79e5;">能够使样本出现的概率为最大</span><span style="color:#4d4d4d;">，则称为极大似然估计。通过求极大似然函数来得到参数w的估计值。</span></p> 
<p style="margin-left:0pt;"><img alt="" height="707" src="https://images2.imgbox.com/23/69/7ntPcniO_o.png" width="530"></p> 
<p style="margin-left:0pt;">以上就是通过极大似然函数作为目标函数，得出了参数向量w值</p> 
<p style="margin-left:0pt;"><strong>综上logistic回归模型的目标函数是极大似然函数</strong></p> 
<h2 style="margin-left:0pt;">五.算法源码</h2> 
<p>源码：</p> 
<pre><code class="language-python">from sklearn.linear_model import LogisticRegression
from math import exp
from math import *
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split
from numpy import *
import numpy as np


class LogisticRegressionClassifier(object):
    def __init__(self,eta=0.1,loop=30):
        self.eta=eta
        self.loop=loop
    def sigmoid(self,x):
        return 1.0/(1+exp(-x))
    def data_tranforce(self,x_train):
        data=[]
        d=[]
        for x in x_train:   #x因为是数组类型
            data.append([1.0,*x])   #将每一行数组增加一个1.0数值,*x是去掉[]符号，形成一行数值
            #c=list(x)  #将一维数组变成列表
            #c.insert(0, 1.0)  #这种insert()方法必须是列表
            #print(list(x).insert(0,1.0))
            #d.append(c)  #类似d=[[1.0,2,3],[1.0,3,4.8]]

        return data

    def fit(self,x_train,y_train):
        data_mat=self.data_tranforce(x_train)  #处理每个样本的特征值
        n=shape(data_mat)[1]  #求出data_mat对应参数的个数
        self.weight=ones((n,1))  #初始化参数w数组
        cls=self.loop
        for k in range(cls):     #循环多少次
            for i in range(len(x_train)):    #遍历每一个样本
                h=self.sigmoid(np.dot(data_mat[i],self.weight))
                err=(y_train[i]-h)
                #随着每次更新err下面就会更新self.weight的向量
                self.weight+=self.eta*err*np.transpose([data_mat[i]])   #[data_mat[i]]变成1*4的数组，一维数组转置必须加一个[]
    #测试训练模型的准确性
    def test(self,x_test,y_test):
        numbers=0
        x_test = self.data_tranforce(x_test)  # 处理每个样本的特征值加一个1.0
        for x,y in zip(x_test,y_test):
            result=np.dot(x,self.weight)
            if(result&gt;0 and y==1)or(result&lt;0 and y==0):
                numbers+=1
        return float(numbers)/float(len(x_test))
def main():
    load=load_iris()
    x=load.data[:100,:2]
    y=load.target[:100]
    y=np.where(y==1,1,0)
    x_train,x_test,y_train,y_test=train_test_split(x,y,test_size=0.3)
    my_l=LogisticRegressionClassifier()
    my_l.fit(x_train,y_train)
    print("准确率：",my_l.test(x_test,y_test))

if __name__== "__main__":
    main()</code></pre> 
<p style="margin-left:0pt;">运行结果：</p> 
<p style="margin-left:0pt;"><img alt="" height="113" src="https://images2.imgbox.com/b2/c3/yDdEhIpU_o.png" width="730"></p> 
<p style="margin-left:0pt;">用示例来解释代码的执行过程：</p> 
<p style="margin-left:0pt;"><img alt="" height="549" src="https://images2.imgbox.com/03/c1/D60HXBAa_o.jpg" width="732"></p> 
<p style="margin-left:0pt;"><img alt="" height="549" src="https://images2.imgbox.com/7d/dd/N16H1JAP_o.jpg" width="731"></p> 
<h2 style="margin-left:0pt;">六.优缺点</h2> 
<p>优点：计算代价不高，易于理解和实现<br> 缺点：容易欠拟合，分类精度不高</p> 
<h2>七.应用场景</h2> 
<p>逻辑回归主要是解决二分类问题</p> 
<h3>使用逻辑回归判断年收入</h3> 
<h4><strong>项目描述</strong></h4> 
<p>二元分类是机器学习中最基础的问题之一，在这份教学中，你将学会如何实作一个线性二元分类器，来根据人们的个人资料，判断其年收入是否高于 50,000 美元。我们将用 logistic regression 来达成以上目的，你可以尝试了解、分析两者的设计理念及差别。 实现二分类任务：</p> 
<ul><li>个人收入是否超过50000元？</li></ul> 
<h4>数据集介绍</h4> 
<p>这个资料集是由UCI Machine Learning Repository 的Census-Income (KDD) Data Set 经过一些处理而得来。为了方便训练，我们移除了一些不必要的资讯，并且稍微平衡了正负两种标记的比例。事实上在训练过程中，只有 X_train、Y_train 和 X_test 这三个经过处理的档案会被使用到，train.csv 和 test.csv 这两个原始资料档则可以提供你一些额外的资讯。</p> 
<ul><li>已经去除不必要的属性。</li><li>已经平衡正标和负标数据之间的比例。</li></ul> 
<p><strong>特征格式</strong></p> 
<ol><li>train.csv，test_no_label.csv。</li></ol> 
<ul><li>基于文本的原始数据</li><li>去掉不必要的属性，平衡正负比例。</li></ul> 
<ol><li>X_train, Y_train, X_test(测试)</li></ol> 
<ul><li>train.csv中的离散特征=&gt;在X_train中onehot编码(学历、状态...)</li><li>train.csv中的连续特征 =&gt; 在X_train中保持不变(年龄、资本损失...)。</li><li>X_train, X_test : 每一行包含一个510-dim的特征，代表一个样本。</li><li>Y_train: label = 0 表示 "&lt;=50K" 、 label = 1 表示 " &gt;50K " 。</li></ul> 
<h4>项目要求</h4> 
<ol><li> <p>请动手编写 gradient descent 实现 logistic regression</p> </li><li>请动手实现概率生成模型。</li><li>单个代码块运行时长应低于五分钟。</li><li>禁止使用任何开源的代码(例如，你在GitHub上找到的决策树的实现)。</li></ol> 
<h4>数据准备</h4> 
<p><strong>项目数据集以及源码</strong>：<a href="https://e.coding.net/xucancan1/logistic/logistic.git" rel="nofollow">https://e.coding.net/xucancan1/logistic/logistic.git</a>。</p> 
<h4><strong>源码：</strong></h4> 
<pre><code># 下面该你动手啦！
import pandas as pd
import numpy as np
from math import exp
from math import *
df=pd.read_csv("work/data/X_train",encoding="big5")
#print(df)
train_label=pd.read_csv("work/data/Y_train",encoding="big5")
train_label=train_label.iloc[:700,1:]  #处理标签
train_label=np.array(train_label)  #处理标签
print(train_label.shape)
#print(train_label)  #打印标签
df=df.iloc[:700,1:]  #处理特征
print("&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;")
df=np.array(df)
df=df.astype("float")  #训练集特征的处理
#print(df.shape)
#print(df)


w=np.ones((511,1))  #初始化w
eta=0.00000008
loop=  100 #循环次数
m=len(train_label)
data=[]
def sigmoid(x):
    return 1.0/(1+exp(-x))
for k in df:
    data.append([1.0,*k])  #每一个特征数据样本添加一个1.0
#print(np.shape(data))
data=np.array(data)  #特征数据
#print(data)

w=np.mat(w)
data=np.mat(data)

for i in range(1000):   #梯度下降，第一种：根据矩阵乘法直接计算w
    h1=[]
    for k in range(m):
        h=sigmoid(np.dot(data[k],w))
        h1.append(h)
    h2=np.array(h1)
    h2=h2.reshape(700,1)  #变成列向量
    #print(h2.shape)
    err=train_label-h2
    w+=eta*data.transpose()*err  #用矩阵梯度下降，下面也是
#print(w.shape)打印参数w
#print(w)
'''
for i in range(100):  #梯度下降，第二种：一个一个的下降，训练模型参数w
    for k in range(m):
        h=sigmoid(np.dot(data[k],w))
        err=train_label[k]-h
        #print(err)
        d=data[k].reshape(511,1)
        d=np.array(d)
        w+=eta*err*d  #梯度下降

print(w)
'''

test=pd.read_csv("work/data/X_test",encoding="big5")  #处理测试集
test=test.iloc[:,1:]  #处理数据集
test=np.array(test)
print(test.shape)
#print(test)
true=1
false=0
for t in test: #在每个测试样本增加一个1.0的特征值,并预测年收入
    dt=[1.0,*t]
    h=np.dot(dt,w)
    if h&gt;0:
        print(true)  #输出为1，大于5000
    else:
        print(false) #输出为0，小于等于5000</code></pre> 
<p><strong>逻辑回归也可以做以下的二分类问题：</strong><br> 1.区分是否是垃圾邮件<br> 2.银行判断是否给用户办信用卡</p> 
<p>3.从氙气病症预测病马的死亡率</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/66e52d0f1ad6b2c881c7bf2fd555abd2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">各向异性滤波</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/da2daa0f68e175100a512a6e5e946a63/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">QFlags详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>