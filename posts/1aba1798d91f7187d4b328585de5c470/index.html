<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《漫画算法：小灰的算法之旅》读后 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《漫画算法：小灰的算法之旅》读后" />
<meta property="og:description" content="第一章:算法概述
略
第二章:数据结构基础
基础定义
同量级函数: 存在函数f(n),使得f(n)/T(n)的极限值为不是0的常数。记作T(n) = O(f(n))，这里的O渐进时间复杂度，简称时间复杂度
if f(n) exist &amp;&amp; f(n max)/T(n) !=0
其实就是把时间函数T（n），简化成一个数
随机读取:
比如有个数组，你array[3]，就是拿下标为3的数据，这种根据下标读取元素的方式就叫随机读取
物理结构:内存中实实在在存在的就叫物理结构，比如list、array
逻辑结构:靠意淫想象出来的结构，比如redis的跳表
栈:线性的数据结构。先入后出(FILO)，比如吧一个球放进只有一个孔的半密闭容器，只能从上往下拿球。最上面的叫栈顶，最下面的叫栈底。方法分别对应压栈/入栈 push和出栈pop
队列：线性的数据结构。先入先出。按照顺序一个一个的执行，不能跳过或者删除。队列的出口叫队头，入口叫队尾。方法分别对应入队enqueue和出队dequeue。需要注意的是出队只允许出对头的那个
循环队列:吧队列想成一个首尾相接的圆环，下次取队头的时候就根据 (队尾下标&#43;1)%数组长度 来算。
栈的一些小应用举例
1.比如某些网页的返回上一次
2.比如递归找到上一层调用，从而找到整个的调用链
队列的一些小应用举例
1.按顺序争夺公平锁的等待队列
2.rabbitmq
优先级队列的小举例:
1.非公平锁里面可能是按照优先级来获取的
散列表/哈希表:其实就是键值对
哈希函数:将键和数据下班进行转换的方法，就叫哈希函数
哈希的写操作:
1.先对key做hash操作，返回值就是找到key的下标位置
具体的是
// 先对key做哈希运算 // 这个&gt;&gt;&gt; 表示无符号右移，如果是正数 则和&gt;&gt;一样，表示除以2的n次方； 忽略符号位，空位都以0补齐 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)
2.putValue
如果长度不够就扩容(含负载因子)
如果对应的下标没有就吧这个entry放过去
如果已经存在了，则吧原来的key的值和当前的值做对比。如果是一样的，就覆盖；如果不是一样的，就先变成链表，数量到了8个以上就变成红黑树。这就是所谓的哈希冲突
发生哈希碰撞（就是出现了多个相同的哈希值），jdk7是将新的放到头部去，jdk8是放到数组最后面去。哈希碰撞主要是为了避免哈希碰撞拒绝服务攻击（因为在元素放置过程中，如果一个对象哈希冲突, 都被放置到同一个桶里，则会形成一个链表，我们知道链表查询是线性的，查的慢，会严重影响存取的性能。然后导致cpu大量占用）
至于解决哈希冲突的方法方法，有4个方法
开放地址再哈希链地址（这个是hashmap现在用的大value链表的，出现重复的就把它们串在同一个list里面。这个方法叫链地址法）建立公共溢出区 其中开放地址又分为：
线性探测再散列二次探测再散列伪随机探测再散列 开放地址寻址法可以理解为：比如我的key的下标是5，那么我继续往下看看下标为6的有没有数据，有的话，去看看7.如果7没有数据，则吧当前数据插进去。ThreadLoack就是用的开放寻址法
map的getValue
1.寻找下标等等和put一样。
2.明显是如果找到了就先比较下字面值，如果一样则返回走，如果不一样则继续往下查。现在知道为什么哈希冲突会增大查询速度吧？
我们知道链表查询是线性的，查的慢，会严重影响存取的性能。然后导致cpu大量占用
扩容" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1aba1798d91f7187d4b328585de5c470/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-24T10:36:39+08:00" />
<meta property="article:modified_time" content="2022-05-24T10:36:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《漫画算法：小灰的算法之旅》读后</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>第一章:算法概述</p> 
<p>略</p> 
<p></p> 
<p>第二章:数据结构基础</p> 
<p>基础定义</p> 
<p>同量级函数: 存在函数f(n),使得f(n)/T(n)的极限值为不是0的常数。记作T(n) = O(f(n))，这里的O渐进时间复杂度，简称时间复杂度</p> 
<p>if f(n) exist &amp;&amp; f(n max)/T(n) !=0</p> 
<p>其实就是把时间函数T（n），简化成一个数</p> 
<p></p> 
<p></p> 
<p></p> 
<p>随机读取:</p> 
<p>比如有个数组，你array[3]，就是拿下标为3的数据，这种根据下标读取元素的方式就叫随机读取</p> 
<p></p> 
<p>物理结构:内存中实实在在存在的就叫物理结构，比如list、array</p> 
<p>逻辑结构:靠意淫想象出来的结构，比如redis的跳表</p> 
<p></p> 
<p></p> 
<p>栈:线性的数据结构。先入后出(FILO)，比如吧一个球放进只有一个孔的半密闭容器，只能从上往下拿球。最上面的叫栈顶，最下面的叫栈底。方法分别对应压栈/入栈 push和出栈pop</p> 
<p></p> 
<p>队列：线性的数据结构。先入先出。按照顺序一个一个的执行，不能跳过或者删除。队列的出口叫队头，入口叫队尾。方法分别对应入队enqueue和出队dequeue。需要注意的是出队只允许出对头的那个</p> 
<p></p> 
<p>循环队列:吧队列想成一个首尾相接的圆环，下次取队头的时候就根据 (队尾下标+1)%数组长度 来算。</p> 
<p></p> 
<p></p> 
<p></p> 
<p>栈的一些小应用举例</p> 
<p>1.比如某些网页的返回上一次</p> 
<p>2.比如递归找到上一层调用，从而找到整个的调用链</p> 
<p></p> 
<p>队列的一些小应用举例</p> 
<p>1.按顺序争夺公平锁的等待队列</p> 
<p>2.rabbitmq</p> 
<p></p> 
<p>优先级队列的小举例:</p> 
<p>1.非公平锁里面可能是按照优先级来获取的</p> 
<p></p> 
<p>散列表/哈希表:其实就是键值对</p> 
<p></p> 
<p></p> 
<p>哈希函数:将键和数据下班进行转换的方法，就叫哈希函数</p> 
<p></p> 
<p></p> 
<p>哈希的写操作:</p> 
<p>1.先对key做hash操作，返回值就是找到key的下标位置</p> 
<p>具体的是</p> 
<p>// 先对key做哈希运算 // 这个&gt;&gt;&gt; 表示无符号右移，如果是正数 则和&gt;&gt;一样，表示除以2的n次方； 忽略符号位，空位都以0补齐 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/aa/b9/OiOAO7Fv_o.png"></p> 
<p> </p> 
<p></p> 
<p></p> 
<p>2.putValue</p> 
<p>如果长度不够就扩容(含负载因子)</p> 
<p>如果对应的下标没有就吧这个entry放过去</p> 
<p>如果已经存在了，则吧原来的key的值和当前的值做对比。如果是一样的，就覆盖；如果不是一样的，就先变成链表，数量到了8个以上就变成红黑树。这就是所谓的哈希冲突</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/7c/2a/AHjteSta_o.png"></p> 
<p> </p> 
<p>发生哈希碰撞（就是出现了多个相同的哈希值），jdk7是将新的放到头部去，jdk8是放到数组最后面去。哈希碰撞主要是为了避免哈希碰撞拒绝服务攻击（因为在元素放置过程中，如果一个对象哈希冲突, 都被放置到同一个桶里，则会形成一个链表，我们知道链表查询是线性的，查的慢，会严重影响存取的性能。然后导致cpu大量占用）</p> 
<p></p> 
<p></p> 
<p>至于解决哈希冲突的方法方法，有4个方法</p> 
<ol><li>开放地址</li><li>再哈希</li><li>链地址（这个是hashmap现在用的大value链表的，出现重复的就把它们串在同一个list里面。这个方法叫链地址法）</li><li>建立公共溢出区</li></ol> 
<p></p> 
<p>其中开放地址又分为：</p> 
<ul><li>线性探测再散列</li><li>二次探测再散列</li><li>伪随机探测再散列</li></ul> 
<p></p> 
<p>开放地址寻址法可以理解为：比如我的key的下标是5，那么我继续往下看看下标为6的有没有数据，有的话，去看看7.如果7没有数据，则吧当前数据插进去。ThreadLoack就是用的开放寻址法</p> 
<p></p> 
<p></p> 
<p></p> 
<p>map的getValue</p> 
<p></p> 
<p>1.寻找下标等等和put一样。</p> 
<p>2.明显是如果找到了就先比较下字面值，如果一样则返回走，如果不一样则继续往下查。现在知道为什么哈希冲突会增大查询速度吧？</p> 
<p>我们知道链表查询是线性的，查的慢，会严重影响存取的性能。然后导致cpu大量占用</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f1/aa/8oXvIphk_o.png"></p> 
<p> </p> 
<p></p> 
<p>扩容</p> 
<p>需要注意的是扩容的大小和重新哈希</p> 
<p>大小是原来的2倍</p> 
<p>重新哈希:遍历原来的数组，吧原来的key全部重新再hash放进新的数组。重哈希的原因是长度扩大后，hash的规则也会跟着改变。经过扩容，如果原来的数据不再哈希，那么所有的老数据都会挤在前面，后面空荡荡的</p> 
<p></p> 
<p></p> 
<p>回到最开始，为什么哈希查询这么快呢？</p> 
<p>因为hash是通过下标查询的，所以是O（1）</p> 
<p></p> 
<p>第三章:树</p> 
<p></p> 
<p>树的定义:</p> 
<p>1.有且仅有一个特定的称为根</p> 
<p>2.n&gt;1时候，其余节点可分为m个互不相交的有限集，每一个集合本身又是一棵树</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/49/ac/2fvwk7jM_o.png"></p> 
<p> </p> 
<p></p> 
<p>最外层的叫叶子节点。比如图中的3 、6 、18 、21</p> 
<p>由同一个节点衍生出来的节点叫兄弟节点，比如4和6 5和10 18和21</p> 
<p>树的最大层级数，叫树的高度或者深度 上图的高度是4</p> 
<p></p> 
<p></p> 
<p>二叉树:在普通树的限制上，再加上每个节点最多只有2个子节点，左边的叫左孩子，右边的叫右孩子。这左右的顺序是固定的</p> 
<p></p> 
<p>二叉树又分城 满二叉树和完全二叉树</p> 
<p>满二叉树:要求叶子节点都在同一行，并且每个非叶子节点都存在左右孩子</p> 
<p>完全二叉树:满二叉树的弱化版本。叶子结点只能出现在最下层和次下层，且最下层的叶子结点集中在树的左部。上图是符合的</p> 
<p></p> 
<p>因为二叉树属于逻辑结构，所以还是要通过物理结构来表述的</p> 
<p></p> 
<p>二叉查找树:在二叉树的基础上新增:</p> 
<p>1.如果左子树不为空，那么这下面的所有子节点的的值都小于这个节点的值</p> 
<p>2.如果右子树不为空，那么这下面的所有子节点的值都大于这个节点的值</p> 
<p>3.左右子树也是二叉查找树(相当于递归了)-</p> 
<p>二叉查找树的好处:对于节点分布相对均衡的二叉树来说，搜索节点的时间复杂度是o（logn）</p> 
<p>比如上图要查4 ，先查根节点，发现4比7小，所以继续查5,；发现4比5小 所以查左下角的4.找到了。二叉树分成两半，所以搜索节点的时间复杂度是o（logn）。是不是感觉很像redis的跳表？</p> 
<p></p> 
<p>因为二叉查找树会维持着左右平衡，所以又叫做二叉平衡树</p> 
<p></p> 
<p>二叉堆:也维持着相对的顺序，但是只要求父节点比左右孩子大</p> 
<p></p> 
<p>根据遍历节点的关系:</p> 
<p>一棵树，总共由三个部分组成，分别为 根、左节点、右节点。英文简称D、L、R。</p> 
<p>所以按照顺序 排列组合有六种:DLR、DRL、LDR、LRD、RLD、RDL</p> 
<p>因为先遍历左节点和遍历右节点的顺序是没有本质的区别的，就是左撇子和右撇子的区别。所以真正的就3种组合 6/2=3</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/df/ec/Jk6frO5C_o.png"></p> 
<p> </p> 
<p></p> 
<p>前序遍历DLR。顾名思义，从根节点开始，先查左节点，然后查右节点。按照上图就是:先查根节点G。G有左节点D，查D。 D有左节点A。A没有左节点，则回到上一层查D。那么查D的右节点；同理，查到完。。。。。。。。。等等等等。所以总体顺序是 G--&gt;D--&gt;A--&gt;F--&gt;E--&gt;M--&gt;H--&gt;Z</p> 
<p></p> 
<p>中序LDR。L是左节点，所以先左一路走到底，发现走不下去了，回退一格(即父节点),然后走右节点找最左边的节点。按照图中的顺序是A--&gt;D--&gt;E--&gt;F--&gt;G--&gt;H--&gt;M--&gt;Z</p> 
<p></p> 
<p></p> 
<p></p> 
<p>后序LRD。输出它的左孩子，然后输出它的右孩子，最后输出该结点。A--&gt;E--&gt;F--&gt;D--&gt;H--&gt;Z--&gt;M--&gt;G 。需要注意的是查到D的时候，先看到D的右节点是M，但是不是马上查M，而是查最左边的H，因为要走到底嘛</p> 
<p></p> 
<p>大部分可以通过递归来遍历的，都可以用栈来表示</p> 
<p>至于通过栈来遍历的话，可以理解为前序遍历++</p> 
<p>比如上图，先放G入栈，找到G的左D入栈，继续找到D的左节点A入栈。A没有左右节点，所以A出栈(栈的特点就是先入先出)。重新回到了D，因为自己已经没什么利用价值了，所以D出栈(这里的出栈原因是，因为这是先一直往左，所以D实际上是没有用的)，找到D的儿子F入栈，找到F的儿子E入栈，没用了，然后E出栈，然后F出栈。</p> 
<p>整体的顺序是G入栈--&gt;D入栈--&gt;A入栈--&gt;A出栈--&gt;D出栈--&gt;F入栈--&gt;E入栈--&gt;E出栈--&gt;F出栈--&gt;G出栈--&gt;M入栈--&gt;H入栈--&gt;H出栈--&gt;M出栈--&gt;Z入栈--&gt;Z出栈</p> 
<p></p> 
<p>深度优先遍历:直接走到无路可走再回头看继续走到死</p> 
<p>广度优先遍历，大家一起放射性的走，一个深度走一步</p> 
<p>拿队列来举例子，</p> 
<p>比如上图是G入队--&gt;G出队--&gt;D、M入队--&gt;D、M出队--&gt;A、F、H、Z入队--&gt;A、F、H、Z出队--&gt;E入队--&gt;E出队</p> 
<p></p> 
<p></p> 
<p></p> 
<p>二叉堆:二叉堆本质上是完全二叉树，只是多了个最大值的最大堆和最小值的最小堆的概念</p> 
<p>最大堆的堆顶是整个堆的最大元素，最大堆任何一个父节点的值，都大于等于它左右孩子节点的值；</p> 
<p>最小堆的堆顶是整个堆的最小元素，最小堆任何一个父节点的值，都小于等于它左右孩子节点的值。</p> 
<p><a href="https://www.cs.usfca.edu/~galles/visualization/Heap.html" rel="nofollow" title="Heap Visualization">Heap Visualization</a></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/03/93/XrYjOpGL_o.png"></p> 
<p> </p> 
<p></p> 
<p>二叉堆的插入、删除、构建，略</p> 
<p></p> 
<p>1.插入节点</p> 
<p>二叉堆的节点插入，插入位置是完全二叉树的最后一个位置</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2e/ea/pAvOz2qL_o.png"></p> 
<p> </p> 
<p></p> 
<p>比如这样图准备插入个1，则先放到7的右子节点去(当然，如果7的左右节点都满了，则跑到8的左节点去，以此类推；如果这一行没有了，则跑到最左边去，即9的左节点)，发现1比7小，两者换个位置；发现1比3小，和3换个位置，发现比2小，和2换个位置</p> 
<p>2.删除节点</p> 
<p>二叉堆的节点删除过程和插入过程正好相反，所删除的是处于堆顶的节点。比如我们删除最小堆的堆顶节点1。目前我看到的好像只能删堆顶，知道为啥不？因为它这个是出栈，先从顶上来搞。</p> 
<p>比如要删2，；吧最下面的11放到堆顶去(和增加一样，替换的是完全二叉树的最后一个位置)，比较11和3、4的大小，发现3比11小，3、11互换位置；同理，比较11和6、7的大小，和6互换位置；比较11和9 、10的大小，和9互换位置，下面没有可以比的了，完事</p> 
<p></p> 
<p></p> 
<p>本质上都是为了维持二叉堆的结构，即 让所有非叶子节点下沉。找到最大的/最小的，然后放到栈顶，然后所有连着的节点都往下走</p> 
<p>因为删除和新增，每次都是对左右节点一半做判断，所以时间复杂度是O（logN）。但是堆的构建就是O（n）了，</p> 
<p>解释:</p> 
<p>自底向上建堆时： 1.最下层的元素n/2个元素不需要移动，剩下的n/2个元素在上面 2.倒数第二层的n/4个元素需要下沉1层，即n/4 *1 3.倒数第三层的n/8个元素需要下沉2层，即n/8*2 4.倒数第三层的n/16个元素需要下沉3层，即n/16*2 所以Sn=0*(n/2)+1*(n/4)+2*(n/8)+3*(n/16)+.............. 两边乘以2 2Sn=0*(n)+1*(n/2)+2*(n/4)+3*(n/8)+.............. 2Sn-Sn=n Sn=n... 所以时间复杂度为O(n) 熟悉不。。。。典型的高中错位相减</p> 
<p>参考自<a href="https://www.zhihu.com/question/264693363" rel="nofollow" title="为什么建立一个二叉堆的时间为O(N)而不是O(Nlog(N))? - 知乎">为什么建立一个二叉堆的时间为O(N)而不是O(Nlog(N))? - 知乎</a></p> 
<p>二叉堆是实现堆排序和优先队列的基础</p> 
<p></p> 
<p></p> 
<p></p> 
<p>优先队列又分成两种:最大优先队列和最小优先队列</p> 
<p>顾名思义，就是不管入队顺序怎么样，出队的那个都是当前队列里面最大/最小的元素</p> 
<p></p> 
<p>是不是感觉和最大/最小二叉堆很像？入队就是放到堆的末尾，然后浮上去。出队就是把顶给拿走咯</p> 
<p>因为二叉堆的上浮起和下沉的时间复杂度都是O(logN)，所以优先队列入队的入队和出队也都是O(logN)</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p>第三章:排序算法</p> 
<p></p> 
<p>可以把算法按照时间复杂度分成</p> 
<p>O(n2)：</p> 
<ul><li>冒泡排序</li><li>选择排序</li><li>插入排序</li></ul> 
<p>O(n logn)</p> 
<ul><li>快排</li><li>规定排序</li><li>堆排序</li></ul> 
<p>O(1)</p> 
<ul><li>计数排序</li><li>桶排序</li><li>基数排序</li></ul> 
<p></p> 
<p>一.冒泡</p> 
<p>吧相邻的元素两两对比，然后交换顺序。最大的数放到最右边</p> 
<p>冒泡是一种稳定排序，因为不会打乱元素相等时原来的顺序</p> 
<p>复杂度分析下</p> 
<p>1.两两对比，然后交换 花费O（n）</p> 
<p>2.要遍历 n-1轮，所以总体是O(n2)</p> 
<p>二.鸡尾酒排序</p> 
<p>把相邻的元素两两对比，然后交换顺序。最大的数放到最右边，第二轮的时候吧最小的数放最左边，第三轮的时候第二大的放最右边-1的位置。。。以此类推。因为很像摇可乐，但是为了讲究虚伪的优雅，叫鸡尾酒排序更好听点</p> 
<p>优势当然是大部分元素已经有序的情况</p> 
<p>优点是特定条件下排序的回合数减少了，缺点当然是代码也差不多加了一倍，因为你往右摇和往左摇都要区分的</p> 
<p>复杂度分析下</p> 
<p>1.先往左遍历一遍 找到最小的，花费O(n)</p> 
<p>2.再往右遍历一遍 找到最大的，花费O(n)</p> 
<p>.....</p> 
<p>因为总共有n个元素，所以总体花费O（n2）</p> 
<p></p> 
<p></p> 
<p>三.快速排序</p> 
<p>分而治之，和以前的砍树一样，每次砍一半，直到砍不下去为止.</p> 
<p>平均时间复杂度是O(nLog n)：假设有n个元素，每个元素都要被作为基准元素，平均情况下 每个元素需要logN轮才可以。所以是O(nLog n)</p> 
<p>最坏的时间复杂度是O（n2），比如基准元素取得不好，每次都是当前未排序的元素里面最大/最小的，这样就达不到分而治之的程度了，只能一边倒</p> 
<p>因为快拍每次选完基准元素之后，还要进行再排序，即把大的放到右边，小的放到左边。所以又分成两种元素交换的方法，即双边排序和单边排序</p> 
<p></p> 
<p>双边排序，</p> 
<p>搞2个指针，最左边一个，最右边一个。如果右指针比左边的小，则两者交换位置，如果大，则右指针往左移一位，然后继续比较大小。比到左指针没有比较更小的时候，左指针右移，继续比，直到没有的比为止</p> 
<p>单边排序，只要一个左指针，然后依次和右边的来比较，同理，比到左指针没有比较更小的时候，左指针右移，继续比，知道没有的比为止</p> 
<p></p> 
<p>大部分的递归 都可以用堆来代替，比如上面的单边排序---&gt;只要一个左指针，然后依次和右边的来比较，比到左指针没有比较更小的时候，最左边的出栈，然后最左边下一个数据作为左指针，继续比，直到栈空了为止。</p> 
<p></p> 
<p>四.堆排序</p> 
<p>最大/最小二叉堆本质上可以理解为一个有序的数组，那么也可以通过二叉堆来进行排序</p> 
<p>步骤</p> 
<p>1.先把无需数组构建成二叉堆，时间复杂度O(n)-----》可以理解为插入到空的二叉堆，n个元素就是O(n)</p> 
<p>2.构建最大/最小二叉树。需要n-1次（去掉自己那层）调用二叉堆叶子下移的方法，因为二叉每次遍历一半，所以时间复杂度是(n-1)*logN 即时间复杂度为O(nLog n)</p> 
<p></p> 
<p>堆排序和快拍的对比:</p> 
<p>相同点</p> 
<p>1.平均时间复杂度都是O(n log n)</p> 
<p>2.都是不稳定排序，打乱了原有相同元素的顺序</p> 
<p>不同点</p> 
<p>1.快排的最坏时间复杂度是O(n2),即基准数每次选的最小边或者最大的；堆排序最坏的时间复杂度在O(nLog n)</p> 
<p>2.快排和递归的平均空间复杂度是O(logn),堆排序是O(1)------------------&gt;以前我误认为快排空间复杂度是O（1）。和时间复杂度相关，每次递归需要的空间是固定的，总体空间复杂度即为递归层数，因此平均/最好空间复杂度为O(logn)，最坏空间复杂度为O(n)。         因为堆排序是就地排序，空间复杂度为常数：O(1)</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p>五.计数排序</p> 
<p>找出最大数m和最小数n，然后建立m-n+1个有序的格子，统计这些数出现的次数</p> 
<p>比如 有数据 5，8,7,10,2,5,6，则建立格子2,3,4,5,6,7,8,9,10 ，统计各个数字出现的次数即最终2*1,3*0,4*0,5*2,6*1,7*1，8*1,9*0,10*1</p> 
<p>去掉次数为0的 ，即2，5*2,6,7,8,10，把乘号去掉即 2,5,6,7,8,10</p> 
<p></p> 
<p>适用于取值范围差别不是很大的情况，性能甚至能超过那些时间复杂度为O(logN)的排序。并且排序不适用于整数</p> 
<p></p> 
<p>但是如果取值范围差别很大，就很浪费了，比如由数据1,10000 排这2个数，就要建10000个格子。而且无法保持数组原有的顺序，比如2个5的顺序你就没法区分哪个在前面</p> 
<p></p> 
<p></p> 
<p>六.桶排序:</p> 
<p>先建立n个桶，这个桶里面装一个区间范围。先把所有数据按区间放入不同的桶。然后再对每个桶内部的元素进行排序，有点类似于分而治之。</p> 
<p>区间跨度=(最大值-最小值)/（桶的数量-1）</p> 
<p>桶排序可以看做是计数排序缺点的改良版本</p> 
<p></p> 
<p>桶排序的时间复杂度分析:</p> 
<p>1.找到数列最大和最小值，花费O（n）</p> 
<p>2.创建n个空桶，花费的也是O(n)</p> 
<p>3.把原来的数组都放到桶里面，也是O（n）</p> 
<p>4.每个桶做排序， 如果元素分布均匀还是 O(n)；如果极不均匀，则是O(nLogN)</p> 
<p>5.输出新的排序序列，也是O（n）</p> 
<p>因为时间复杂度前面的常数是可以省略的，所以总体的 常规情况分布均匀还是O（n），极端最坏的条件是O(nLogN)</p> 
<p></p> 
<p></p> 
<table><tbody><tr><td> <p>排序算法</p> </td><td> <p>平均时间复杂度</p> </td><td> <p>最坏时间复杂度</p> </td><td> <p>最坏情况</p> </td><td> <p>空间复杂度</p> </td><td> <p>是否稳定排序(保持顺序)</p> </td></tr><tr><td> <p>冒泡</p> </td><td> <p>O(n2)</p> </td><td> <p>O(n2)</p> </td><td> <p>已经有序了还会继续O(n2)</p> </td><td> <p>O(1)</p> </td><td> <p>稳定</p> </td></tr><tr><td> <p>鸡尾酒</p> </td><td> <p>O(n2)</p> </td><td> <p>O(n2)</p> </td><td> <p>已经有序了还会继续O(n2)</p> </td><td> <p>O(1)</p> </td><td> <p>稳定</p> </td></tr><tr><td> <p>快排</p> </td><td> <p>O(nLogN)</p> </td><td> <p>O(n2)</p> </td><td> <p>1.已经有序了，无论是正序还是倒序，还会继续O(n2),就和普通冒泡没区别了</p> <p>2.所有的元素都相同</p> </td><td> <p>O(logN)</p> </td><td> <p>不稳定</p> </td></tr><tr><td> <p>堆排序</p> </td><td> <p>O(nLogN)</p> </td><td> <p>O(nLogN)</p> </td><td> <p>无</p> </td><td> <p>O(1)--&gt;数组内构建的</p> </td><td> <p>不稳定</p> </td></tr><tr><td> <p>计数排序</p> </td><td> <p>O(n+m)</p> </td><td> <p>O(n+m)</p> </td><td> <p>最大值m和最小值m的差距过大</p> </td><td> <p>o(m)</p> </td><td> <p>稳定</p> </td></tr><tr><td> <p>桶排序</p> </td><td> <p>O(n)</p> </td><td> <p>O(nLogN)</p> </td><td> <p>第一个桶n-1个元素，第二个桶1个元素</p> </td><td> <p>O(n)</p> </td><td> <p>稳定</p> </td></tr></tbody></table> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p>LRU:最近最少使用</p> 
<p>redis里面经常有</p> 
<p>最初的代码如下:key都没有优化，感觉和限流一样</p> 
<p>private static final int ARRAYS_MAX_LENGTH = 4; public static void main(String[] args) { List&lt;Integer&gt; array = new ArrayList&lt;&gt;(); add(1, array); add(2, array); add(3, array); add(4, array); add(5, array); add(6, array); add(7, array); add(8, array); System.out.println(array); } public static void add(int addNum, List&lt;Integer&gt; array) { if (array.size() &lt; ARRAYS_MAX_LENGTH) { array.add(array.size(), addNum); return; } // 如果超过了数组最大的长度，移除最左边的 for (int i = 0; i &lt; array.size(); i++) { if (i &lt; array.size() - 1) { array.set(i, array.get(i + 1)); } else { array.set(i, addNum); } } }</p> 
<p></p> 
<p>// 如果是用map的话，当然 能被优化空间还有很大</p> 
<p>/** * @author PrinceCharimgDong * @description: * @date 2021/12/28 18:55 */ @Data @Builder @NoArgsConstructor @AllArgsConstructor public class Node { //双向链表 private Node pre; private Node next; private String key; private String value; // 因为属性引用子属性，导致toString方法会不断调用子节点的属性。最终栈溢出。 所以pre和next不能toString出来 @Override public String toString() { return "Node{" + ", key='" + key + '\'' + ", value='" + value + '\'' + '}'; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Node node = (Node) o; return Objects.equals(pre, node.pre) &amp;&amp; Objects.equals(next, node.next) &amp;&amp; Objects.equals(key, node.key) &amp;&amp; Objects.equals(value, node.value); } @Override public int hashCode() { return Objects.hash(pre, next, key, value); } } class LruDemo { private static final int ARRAYS_MAX_LENGTH = 4; private Node head; private Node end; private Map&lt;String, Node&gt; saveDate; public void add(String key, String value) { Node lruDemo = saveDate.get(key); if (null != lruDemo) { return; } lruDemo = Node.builder().key(key).value(value).build(); if (saveDate.size() == 0) { head = lruDemo; end = null; } //如果超过了长度，则去掉第一个 if (saveDate.size() &gt;= ARRAYS_MAX_LENGTH) { String oldFirstKey = head.getKey(); Node node2 = head.getNext(); saveDate.remove(oldFirstKey); // 修改新的第一个数据 head = node2; } // init上一个的next if (saveDate.size() &gt; 1) { String lastKey2 = end.getKey(); Node lastNode2 = saveDate.get(lastKey2); lastNode2.setNext(lruDemo); saveDate.put(lastKey2, lastNode2); lruDemo.setPre(lastNode2); lruDemo.setNext(null); } saveDate.put(key, lruDemo); end = lruDemo; } } public static void main(String[] args) { LruDemo lruDemo = new LruDemo(); lruDemo.add("1", "a"); lruDemo.add("2", "b"); lruDemo.add("3", "c"); lruDemo.add("2", "b"); lruDemo.add("4", "d"); lruDemo.add("5", "e"); lruDemo.add("6", "f"); lruDemo.add("7", "g"); lruDemo.add("7", "g"); lruDemo.add("8", "h"); System.out.println(); }</p> 
<p></p> 
<p>A星算法==&gt; A*</p> 
<p></p> 
<p>我们从起点开始，检查其相邻的方格，然后向四周扩展，直至找到目标。</p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/30/ec/zd02sbx7_o.png"></p> 
<p> </p> 
<p></p> 
<p>1.拆成二维坐标系，确定起点和重点</p> 
<p>2.忽略障碍物！引入常量，E即当前点和终点的最短直线距离。S即当前点和起点的步数。F即起点到终点的距离</p> 
<p>3.从起点开始走，走一步计算下下一个</p> 
<p>3.每一步找出最小的F</p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p>拆红包的比较公平的小技巧:线段切割法和二倍均值法</p> 
<p>n倍均值法:把每个人的预期金额*n，最后一次的取余。</p> 
<p>比如 100块钱的红包10个人抢</p> 
<p>那么第一个人的概率是 100/10*2，范围在0-20，中位数是10</p> 
<p>第2个人的概率是 100/10*2，范围在0-20，中位数是10</p> 
<p>第n个人的概率是 100/10*2，范围在0-20，中位数是10</p> 
<p>最后一个人的范围是 0-（100-前面所有个人金额加起来的值）</p> 
<p>缺点：除了最后一次取余抢，任何一次抢到的金额都不会超过人均金额的n倍，且并不是绝对的任意的随机</p> 
<p>线段切割法</p> 
<p>将金额看成一条线段，线段的长度放大一百倍，即范围是0到M*100，首先需要生成1-（M*100-1） 中间的(N-1)个随机的且不重复的数，可以使用这(N-1)个数去切割线段，切割后的每一份就是红包的金额数。</p> 
<p></p> 
<p></p> 
<p>2022年1月11日15:13:02</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/74c2dee9ba62ab17bd02dd473efccad8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux--Ubuntu18.04交叉编译链；多窗口终端；彻底删除不用的虚拟机镜像</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ed852c165acdc2338896243f19811291/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VUE 记录学习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>