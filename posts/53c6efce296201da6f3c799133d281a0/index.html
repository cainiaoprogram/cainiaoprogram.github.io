<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《数据结构》邓俊辉 网课习题详细解析（第五章：二叉树） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《数据结构》邓俊辉 网课习题详细解析（第五章：二叉树）" />
<meta property="og:description" content="文章目录 （a）树（b）树的表示（c）二叉树（e1）先序遍历（e2）中序遍历（e4）层次遍历（e5）重构 （a）树 1.下列那种数据结构可以高效地兼顾静态操作和动态操作（D）
A.array数组
B.vector向量
C.list列表
D.tree树
解析：数组可以被视为一种简单的向量。向量的静态操作效率高而动态操作效率低；列表的动态操作效率高而静态操作效率低。树能够兼顾静态操作和动态操作的高效性。
2.n个顶点的树有多少条边？（B）
A.n
B.n-1
C.n²
D.2的n次方
解析：树的性质之一就是边数=顶点数-1。
3.树是（C）
A.有向连通图
B.无环平面图
C.连通无环图
D.有向无环图
解析：树是一种特殊的图。树是一种连通无环图、极大无环图、极小连通图。
4.在一棵树中，顶点p是顶点v的父亲，则它们的高度关系是（A）
A.height v &lt;height p
B.height v =height p -1
C.height v =height p &#43;1
D.height p &lt;height v
解析：由于p是v的父亲，因此p的高度一定比v要大，但是具体的大小关系不能确定，只有在顶点v所在的子树刚好对应顶点p最大高度的子树时，才能有B选项成立。
（b）树的表示 1.用父节点&#43;孩子节点的方法存储n个结点的树，需要的空间是（B）
A.O(1)
B.O(n)
C.O(nlgn)
D.O(n²)
解析：父亲孩子表示法中，每个结点存储的内容包括：自身的秩、自身的数据、父节点的秩、孩子链表。因此总共需要的存储空间线性正比于结点的个数。
2.
以上图中的树在计算机中表示如下，则第三行中parent[]的内容应该是（B）
A.0,5,-1,7,0,5,4,7,0,7
B.-1,5,5,7,0,4,5,0,0,7
C.0,1,2,3,4,5,6,7,8,9
D.-1,7,5,2,5,4,1,-1,0,7
解析：parent[]中存放的是父节点的秩，因此只需要找到每一个结点的父节点记录其秩即可。根节点的父节点秩记录为-1。
（c）二叉树 1.高度为h的满二叉树有多少个节点（A）
A.2的(h&#43;1)次方-1
B.2的(h&#43;1)次方
C.2的h次方-1
D.2的h次方
解析：高度为h的满二叉树在每一层上分别有1、2、4…2的h次方个节点，通过等比数列求和公式可以得出答案。
2.一棵高度为h，节点数为n的真二叉树的特点是（D）
A.h=O(logn)
B.真的是二叉树，而不是其他种类的树
C.不存在只有一个父亲的节点
D.不存在只有一个孩子的节点
解析：对于退化为一条单链的二叉树，其高度h=O(n)。真二叉树的特点为不存在度数为1的节点。
3.在长子-兄弟表示法中，树中某节点的长子相当于二叉树中的（B）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/53c6efce296201da6f3c799133d281a0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-18T14:59:55+08:00" />
<meta property="article:modified_time" content="2022-07-18T14:59:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《数据结构》邓俊辉 网课习题详细解析（第五章：二叉树）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#a_2" rel="nofollow">（a）树</a></li><li><a href="#b_38" rel="nofollow">（b）树的表示</a></li><li><a href="#c_61" rel="nofollow">（c）二叉树</a></li><li><a href="#e1_87" rel="nofollow">（e1）先序遍历</a></li><li><a href="#e2_124" rel="nofollow">（e2）中序遍历</a></li><li><a href="#e4_143" rel="nofollow">（e4）层次遍历</a></li><li><a href="#e5_163" rel="nofollow">（e5）重构</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="a_2"></a>（a）树</h3> 
<p><strong>1.下列那种数据结构可以高效地兼顾静态操作和动态操作（D）</strong><br> A.array数组<br> B.vector向量<br> C.list列表<br> D.tree树</p> 
<blockquote> 
 <p>解析：数组可以被视为一种简单的向量。向量的静态操作效率高而动态操作效率低；列表的动态操作效率高而静态操作效率低。树能够兼顾静态操作和动态操作的高效性。</p> 
</blockquote> 
<p><strong>2.n个顶点的树有多少条边？（B）</strong><br> A.n<br> B.n-1<br> C.n²<br> D.2的n次方</p> 
<blockquote> 
 <p>解析：树的性质之一就是边数=顶点数-1。</p> 
</blockquote> 
<p><strong>3.树是（C）</strong><br> A.有向连通图<br> B.无环平面图<br> C.连通无环图<br> D.有向无环图</p> 
<blockquote> 
 <p>解析：树是一种特殊的图。树是一种连通无环图、极大无环图、极小连通图。</p> 
</blockquote> 
<p><strong>4.在一棵树中，顶点p是顶点v的父亲，则它们的高度关系是（A）</strong><br> A.height v &lt;height p<br> B.height v =height p -1<br> C.height v =height p +1<br> D.height p &lt;height v</p> 
<blockquote> 
 <p>解析：由于p是v的父亲，因此p的高度一定比v要大，但是具体的大小关系不能确定，只有在顶点v所在的子树刚好对应顶点p最大高度的子树时，才能有B选项成立。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/f5/fe/xnyjFkyN_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="b_38"></a>（b）树的表示</h3> 
<p><strong>1.用父节点+孩子节点的方法存储n个结点的树，需要的空间是（B）</strong><br> A.O(1)<br> B.O(n)<br> C.O(nlgn)<br> D.O(n²)</p> 
<blockquote> 
 <p>解析：父亲孩子表示法中，每个结点存储的内容包括：自身的秩、自身的数据、父节点的秩、孩子链表。因此总共需要的存储空间线性正比于结点的个数。</p> 
</blockquote> 
<p><strong>2.</strong><br> <img src="https://images2.imgbox.com/44/9f/sfFqUCTL_o.png" alt="在这里插入图片描述"><br> <strong>以上图中的树在计算机中表示如下，则第三行中parent[]的内容应该是（B）</strong><br> <img src="https://images2.imgbox.com/ba/ad/JBfest8V_o.png" alt="在这里插入图片描述"></p> 
<p>A.0,5,-1,7,0,5,4,7,0,7<br> B.-1,5,5,7,0,4,5,0,0,7<br> C.0,1,2,3,4,5,6,7,8,9<br> D.-1,7,5,2,5,4,1,-1,0,7</p> 
<blockquote> 
 <p>解析：parent[]中存放的是父节点的秩，因此只需要找到每一个结点的父节点记录其秩即可。根节点的父节点秩记录为-1。</p> 
</blockquote> 
<h3><a id="c_61"></a>（c）二叉树</h3> 
<p><strong>1.高度为h的满二叉树有多少个节点（A）</strong><br> A.2的(h+1)次方-1<br> B.2的(h+1)次方<br> C.2的h次方-1<br> D.2的h次方</p> 
<blockquote> 
 <p>解析：高度为h的满二叉树在每一层上分别有1、2、4…2的h次方个节点，通过等比数列求和公式可以得出答案。</p> 
</blockquote> 
<p><strong>2.一棵高度为h，节点数为n的真二叉树的特点是（D）</strong><br> A.h=O(logn)<br> B.真的是二叉树，而不是其他种类的树<br> C.不存在只有一个父亲的节点<br> D.不存在只有一个孩子的节点</p> 
<blockquote> 
 <p>解析：对于退化为一条单链的二叉树，其高度h=O(n)。真二叉树的特点为不存在度数为1的节点。</p> 
</blockquote> 
<p><strong>3.在长子-兄弟表示法中，树中某节点的长子相当于二叉树中的（B）</strong><br> A.幼子<br> B.左子<br> C.右子<br> D.长子</p> 
<blockquote> 
 <p>解析：二叉树本身是通过长子兄弟表示法进行表示的，而某个节点的长子就是二叉树中的左孩子。</p> 
</blockquote> 
<h3><a id="e1_87"></a>（e1）先序遍历</h3> 
<p><strong>1.对以下二叉树进行先序遍历：刚访问完结点d时（迭代实现2）栈中的元素从栈顶到栈底依次为（D）</strong><br> <img src="https://images2.imgbox.com/82/3f/s0tzyzYD_o.png" alt="在这里插入图片描述"></p> 
<p>A.e<br> B.g,f<br> C.f,g<br> D.f</p> 
<blockquote> 
 <p>解析：第二种迭代实现的方式为：创建一个栈。从根节点开始，沿着左侧链进行逐一访问，同时将每个结点的右节点放入栈中。每访问完一条左侧链，则将栈顶结点出栈并从该结点开始进行左侧链访问。重复上述过程直到栈变空为止。本题中，栈的元素变化为：<br> c（访问a后入栈）→f（访问c后入栈）→f,e（访问d后入栈）→e。</p> 
</blockquote> 
<p><strong>2.二叉树是（B）</strong><br> A.线性结构<br> B.半线性结构<br> C.非线性结构<br> D.钢筋混凝土结构</p> 
<blockquote> 
 <p>解析：本题根据定义可知二叉树是半线性结构。</p> 
</blockquote> 
<p><strong>3.若在先序遍历中规定访问完根节点后先访问右子树再访问左子树，则左右子树的入栈顺序是（D）</strong><br> A.先左后右<br> B.先右后左<br> C.同时入栈<br> D.只有左子入栈，右子不入栈</p> 
<blockquote> 
 <p>解析：根据先序遍历的第二种实现方式可知，将左右子的地位对换即可。因此可以得出结论，即只有左子入栈。</p> 
</blockquote> 
<p><strong>4.先序遍历的顺序是（C）</strong><br> A.先自下而上访问左侧链上的结点，再自下而上访问它们的右子树<br> B.先自下而上访问左侧链上的结点，再自上而下访问它们的右子树<br> C.先自上而下访问左侧链上的结点，再自下而上访问它们的右子树<br> D.先自下而上访问左侧链上的结点，再自上而下访问它们的右子树。</p> 
<blockquote> 
 <p>解析：根据先序遍历的特点可知，先序遍历需要首先自上而下访问左侧链上的结点，再自下而上访问这些结点的右子树。</p> 
</blockquote> 
<h3><a id="e2_124"></a>（e2）中序遍历</h3> 
<p><strong>1.中序遍历中第一个被访问的节点是（A）</strong><br> A.最左的节点<br> B.最右的节点<br> C.根节点<br> D.左侧分支的叶节点</p> 
<blockquote> 
 <p>解析：中序遍历中首先需要访问整棵树中最左侧的节点。</p> 
</blockquote> 
<p><strong>2.对以下二叉树进行中序遍历，则节点c刚被访问完毕时栈中的元素从栈顶到栈底为（B）</strong><br> <img src="https://images2.imgbox.com/63/49/sDU0zhXx_o.png" alt="在这里插入图片描述"></p> 
<p>A.d,c,f<br> B.d,f<br> C.f,g,d,e<br> D.d</p> 
<blockquote> 
 <p>解析：由于本题采用中序遍历，因此栈中元素的变化情况为：b、a（第一条左侧链）→f、d、c（第二条左侧链）。因此c刚被访问完时栈中的元素为：d、f（换一个顺序）。</p> 
</blockquote> 
<h3><a id="e4_143"></a>（e4）层次遍历</h3> 
<p>1.层次遍历的次序是（C）<br> A.先根再左子最后右子<br> B.先左子再根最后右子‘<br> C.自上而下访问各个深度的结点，同样深度的结点中自左向右<br> D.自下而上访问各个深度的结点，同样深度的结点中自左向右。</p> 
<blockquote> 
 <p>解析：层次遍历的过程就是：将所有节点按照深度划分为不同的等价类，每个等价类中的结点按照从左到右的顺序进行访问。</p> 
</blockquote> 
<p>2.对以下二叉树进行层次遍历：结点F正欲出队时队列中的元素从队头到队尾为：<br> <img src="https://images2.imgbox.com/ee/7c/MYnRabC4_o.png" alt="在这里插入图片描述"></p> 
<p>A.F<br> B.F,G<br> C.E,F<br> D.E,F,G</p> 
<blockquote> 
 <p>解析：本题中结点的入队顺序为：A→B→C,D→D→E,F→F,G→G</p> 
</blockquote> 
<h3><a id="e5_163"></a>（e5）重构</h3> 
<p><strong>后序遍历序列中最后一个结点是（A）</strong><br> A.根节点<br> B.最左边的结点<br> C.最右边的结点<br> D.深度最大的结点</p> 
<blockquote> 
 <p>解析：后序遍历可以视为左子树、右子树、根节点的顺序进行遍历，因此后序遍历中最后一个结点是根节点。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/17a940942aacad3958a5409e08a2ac04/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在GitHub上学黑客 --- 黑客成长技术清单</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/550d28ec98aac70a30ce555ecdddb05f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">linux mysql 5.7 离线安装（tar.gz）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>