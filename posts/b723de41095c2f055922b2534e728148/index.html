<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>大大大大大模型部署方案抛砖引玉 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="大大大大大模型部署方案抛砖引玉" />
<meta property="og:description" content="借着热点，简单聊聊大模型的部署方案，作为一个只搞过CV部署的算法工程师，在最近LLM逐渐改变生活的大背景下，猛然意识到LLM部署也是很重要的。大模型很火，而且确实有用（很多垂类场景可以针对去训练），并且和Vision结合的大模型也逐渐多了起来。所以怎么部署大模型是一个超级重要的工程问题，很多公司也在紧锣密鼓的搞着。
目前效果最好讨论最多的开源实现就是LLAMA，所以我这里讨论的也是基于LLAMA的魔改部署。
基于LLAMA的finetune模型有很多，比如效果开源最好的vicuna-13b和较早开始基于llama做实验的alpaca-13b，大家可以看：
https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard 开源LLMhttps://lmsys.org/blog/2023-05-03-arena/ 基于llama的开源对比https://github.com/camenduru/text-generation-webui-colab 一些开源LLM的notebook 至于为啥要选LLAMA，因为当前基于LLAMA的模型很多，基础的llama的效果也不错，当然RWKV也很不错，我也一直在看。
具体的可以看这里，https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard
Github上较多的是实现是直接python推理然后基于gradio的网页端展示，还不能被当成服务调用（或者说不大优雅），一般来说作为服务：
响应速度要快，每秒的tokens越多越好稳定性，出现core了不会影响推理或者可以及时恢复支持各种形式，http、sse、grpc等形式 其实最重要的一点还是要快，其次必须要量化，因为大模型的权重往往很大，量化可以有效减小权重（省显卡），是非常必要的。要做成服务的话，需要稍稍花一点功夫和魔改一下，幸运的是网上已经有不错的demo实现供我们尝试，这篇文章主要是总结下以LLAMA为例的LLM部署方案，希望能抛砖引玉。
PS：我们常用的ChatGPT据说是居于Python服务搭建的，相比模型的耗时，python环境的开销可以忽略不计。
以LLAMA为例 LLM很大，比如GPT3-175B的大模型，700GB的参数以及运行过程中600GB的激活值，1.3TB总共，正常来说，得32个A100-40GB才能放的下。
但实际应用中，消费级显卡要比专业显卡便宜的多（比如3090相比A10，同样都是24G显存），所以用消费级显卡部署LLM也很有钱途。一张卡放不下那就放两张，如果没有nvlink，那么PCIE的也凑合用。
回到LLAMA模型，有7B、13B、30B、65B的版本，当然是越大的版本效果最好，相应的也需要更多的显存（其实放到内存或者SSD也是可以的，但是速度相比权重全放到显存里头，肯定要慢）。
LLAMA的实现很多，简单列几个我看过的，都可以参考：
https://github.com/juncongmoo/pyllama 原始llama的实现方式https://github.com/qwopqwop200/GPTQ-for-LLaMa 支持量化，INT4、INT8量化的llamahttps://github.com/tpoisonooo/llama.onnx.git 以ONNX的方式运行llama 量化和精度 对于消费级显卡，直接FP32肯定放不下，一般最基本的是FP16（llama的7B，FP16需要14G的显存，大多数的消费级显卡已经说拜拜了），而INT8和INT4量化则就很有用了，举几个例子：
对于3080显卡，10G显存，那么13B的INT4就很有性价比，精度比7B-FP16要高很多对于3090显卡，24G显存，那么30B的INT4可以在单个3090显卡部署，精度更高 可以看下图，列举了目前多种开源预训练模型在各种数据集上的分数和量化精度的关系：
我自己也测试了几个模型，我使用的是A6000显卡，48G的显存，基于GPTQ-for-LLAMA测试了各种不同规格模型的PPL精度和需要的显存大小。
执行以下命令CUDA_VISIBLE_DEVICES=0 python llama.py ${MODEL_DIR} c4 --wbits 4 --groupsize 128 --load llama7b-4bit-128g.pt --benchmark 2048 --check测试不同量化精度不同规格模型的指标：
# 7B-FP16 Median: 0.03220057487487793 PPL: 5.227280139923096 max memory(MiB): 13948.7333984375 # 7B-INT8 Median: 0.13523507118225098 PPL: 5.235021114349365 max memory(MiB): 7875.92529296875 # 7B-INT4 Median: 0.038548946380615234 PPL: 5.268043041229248 max memory(MiB): 4850.73095703125 # 13B-FP16 Median: 0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b723de41095c2f055922b2534e728148/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-04T21:30:08+08:00" />
<meta property="article:modified_time" content="2023-06-04T21:30:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">大大大大大模型部署方案抛砖引玉</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>借着热点，简单聊聊<strong>大模型的部署方案</strong>，作为一个只搞过CV部署的算法工程师，在最近LLM逐渐改变生活的大背景下，猛然意识到LLM部署也是很重要的。大模型很火，而且确实有用（很多垂类场景可以针对去训练），并且和Vision结合的大模型也逐渐多了起来。所以怎么部署大模型是一个<strong>超级重要的工程问题</strong>，很多公司也在紧锣密鼓的搞着。<br>目前效果最好讨论最多的开源实现就是LLAMA，所以我这里讨论的也是基于<strong>LLAMA的魔改部署</strong>。<br>基于LLAMA的finetune模型有很多，比如效果开源最好的<a href="https://lmsys.org/blog/2023-03-30-vicuna/" rel="nofollow">vicuna-13b</a>和较早开始基于llama做实验的<a href="https://crfm.stanford.edu/2023/03/13/alpaca.html" rel="nofollow">alpaca-13b</a>，大家可以看：</p> 
<ul><li><a href="https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard" rel="nofollow">https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard</a> 开源LLM</li><li><a href="https://lmsys.org/blog/2023-05-03-arena/" rel="nofollow">https://lmsys.org/blog/2023-05-03-arena/</a> 基于llama的开源对比</li><li><a href="https://github.com/camenduru/text-generation-webui-colab">https://github.com/camenduru/text-generation-webui-colab</a> 一些开源LLM的notebook</li></ul> 
<p>至于为啥要选LLAMA，因为当前基于LLAMA的模型很多，基础的llama的效果也不错，当然<a href="https://github.com/BlinkDL/ChatRWKV">RWKV</a>也很不错，我也一直在看。<br><img src="https://images2.imgbox.com/58/42/bfEBFDdC_o.png" alt="openllm-leader-board" title="openllm-leader-board"></p> 
<blockquote> 
 <p>具体的可以看这里，<a href="https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard" rel="nofollow">https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard</a></p> 
</blockquote> 
<p>Github上较多的是实现是直接python推理然后基于gradio的网页端展示，还不能被当成服务调用（或者说不大优雅），一般来说作为服务：</p> 
<ul><li>响应速度要快，每秒的tokens越多越好</li><li>稳定性，出现core了不会影响推理或者可以及时恢复</li><li>支持各种形式，http、sse、grpc等形式</li></ul> 
<p>其实最重要的一点还是<strong>要快</strong>，其次必须要量化，因为大模型的权重往往很大，量化可以有效减小权重（省显卡），是非常必要的。要做成服务的话，需要稍稍花一点功夫和魔改一下，幸运的是网上已经有不错的demo实现供我们尝试，这篇文章主要是总结下以LLAMA为例的LLM部署方案，希望能抛砖引玉。</p> 
<blockquote> 
 <p>PS：我们常用的ChatGPT<a href="https://www.zhihu.com/question/594050309/answer/2976728922" rel="nofollow">据说是居于Python服务搭建的</a>，相比模型的耗时，python环境的开销可以忽略不计。</p> 
</blockquote> 
<h2><a id="LLAMA_18"></a>以LLAMA为例</h2> 
<p>LLM很大，比如GPT3-175B的大模型，700GB的参数以及运行过程中600GB的激活值，1.3TB总共，正常来说，得32个A100-40GB才能放的下。<br>但实际应用中，消费级显卡要比专业显卡便宜的多（比如3090相比A10，同样都是24G显存），所以用消费级显卡部署LLM也很有钱途。一张卡放不下那就放两张，如果没有nvlink，那么PCIE的也凑合用。<br>回到LLAMA模型，有7B、13B、30B、65B的版本，当然是越大的版本效果最好，相应的也需要更多的显存（其实放到内存或者SSD也是可以的，但是速度相比权重全放到显存里头，肯定要慢）。<br>LLAMA的实现很多，简单列几个我看过的，都可以参考：</p> 
<ul><li><a href="https://github.com/juncongmoo/pyllama">https://github.com/juncongmoo/pyllama</a> 原始llama的实现方式</li><li><a href="https://github.com/qwopqwop200/GPTQ-for-LLaMa">https://github.com/qwopqwop200/GPTQ-for-LLaMa</a> 支持量化，INT4、INT8量化的llama</li><li><a href="https://github.com/tpoisonooo/llama.onnx.git">https://github.com/tpoisonooo/llama.onnx.git</a> 以ONNX的方式运行llama</li></ul> 
<h3><a id="_24"></a>量化和精度</h3> 
<p>对于消费级显卡，直接FP32肯定放不下，一般最基本的是FP16（llama的7B，FP16需要14G的显存，大多数的消费级显卡已经说拜拜了），而INT8和INT4量化则就很有用了，举几个例子：</p> 
<ul><li>对于3080显卡，10G显存，那么13B的INT4就很有性价比，精度比7B-FP16要高很多</li><li>对于3090显卡，24G显存，那么30B的INT4可以在单个3090显卡部署，精度更高</li></ul> 
<p>可以看下图，列举了目前多种开源预训练模型在各种数据集上的分数和量化精度的关系：<br><img src="https://images2.imgbox.com/99/26/objNjhsX_o.png" alt="各种开源模型量化精度比较" title="各种开源模型量化精度比较"><br>我自己也测试了几个模型，我使用的是A6000显卡，48G的显存，基于<a href="https://github.com/qwopqwop200/GPTQ-for-LLaMa">GPTQ-for-LLAMA</a>测试了各种不同规格模型的PPL精度和需要的显存大小。<br>执行以下命令<code>CUDA_VISIBLE_DEVICES=0 python llama.py ${MODEL_DIR} c4 --wbits 4 --groupsize 128 --load llama7b-4bit-128g.pt --benchmark 2048 --check</code>测试不同量化精度不同规格模型的指标：</p> 
<pre><code class="prism language-bash"><span class="token comment"># 7B-FP16</span>
Median: <span class="token number">0.03220057487487793</span>
PPL: <span class="token number">5.227280139923096</span>
max memory<span class="token punctuation">(</span>MiB<span class="token punctuation">)</span>: <span class="token number">13948.7333984375</span>

<span class="token comment"># 7B-INT8</span>
Median: <span class="token number">0.13523507118225098</span>
PPL: <span class="token number">5.235021114349365</span>
max memory<span class="token punctuation">(</span>MiB<span class="token punctuation">)</span>: <span class="token number">7875.92529296875</span>

<span class="token comment"># 7B-INT4</span>
Median: <span class="token number">0.038548946380615234</span>
PPL: <span class="token number">5.268043041229248</span>
max memory<span class="token punctuation">(</span>MiB<span class="token punctuation">)</span>: <span class="token number">4850.73095703125</span>

<span class="token comment"># 13B-FP16</span>
Median: <span class="token number">0.039263248443603516</span>
PPL: <span class="token number">4.999974727630615</span>
max memory<span class="token punctuation">(</span>MiB<span class="token punctuation">)</span>: <span class="token number">26634.0205078125</span>

<span class="token comment"># 13B-INT8</span>
Median: <span class="token number">0.18153250217437744</span>
PPL: <span class="token number">5.039003849029541</span>
max memory<span class="token punctuation">(</span>MiB<span class="token punctuation">)</span>: <span class="token number">14491.73095703125</span>

<span class="token comment"># 13B-INT4</span>
Median: <span class="token number">0.06513667106628418</span>
PPL: <span class="token number">5.046994209289551</span>
max memory<span class="token punctuation">(</span>MiB<span class="token punctuation">)</span>: <span class="token number">8677.134765625</span>

<span class="token comment"># 30B-FP16 </span>
OOM 

<span class="token comment"># 30B-INT8</span>
Median: <span class="token number">0.2696110010147095</span>
PPL: <span class="token number">4.5508503913879395</span>
max memory<span class="token punctuation">(</span>MiB<span class="token punctuation">)</span>: <span class="token number">34745.9384765625</span>

<span class="token comment"># 30B-INT4</span>
Median: <span class="token number">0.1333252191543579</span>
PPL: <span class="token number">4.526902675628662</span>
max memory<span class="token punctuation">(</span>MiB<span class="token punctuation">)</span>: <span class="token number">20070.197265625</span>
</code></pre> 
<p>30B的FP16和65B的爆显存了，还没搞自己的多卡环境，之后会补充结果到这里。<br>可以先看看其他大佬的测试结果，大概有个预期，65B模型的话，INT4在两张3090上是可以放得下的：<br><img src="https://images2.imgbox.com/a8/76/C3nfCsoY_o.png" alt="INT8-LLAMA显存需求" title="INT8-LLAMA显存需求"></p> 
<h3><a id="_76"></a>速度测试</h3> 
<p>我这边也测试了llama在huggingface中Python库的实现速度、以及基于GPTQ的量化、多卡的速度，其中stream模式参考了<a href="https://github.com/oobabooga/text-generation-webui">text-generation-webui</a>中的<a href="https://github.com/oobabooga/text-generation-webui/blob/2eeb27659d6adfa38ef140f2ebf2d8e5d12637bf/modules/callbacks.py#L39">Stream</a>实现。<br>其中FP16就是直接调用<code>GPTQ-for-LLaMa/llama_inference.py</code>中未量化的FP16推理，调用方式为<code>model.generate</code>，model来自：</p> 
<pre><code class="prism language-python">model <span class="token operator">=</span> LlamaForCausalLM<span class="token punctuation">.</span>from_pretrained<span class="token punctuation">(</span>model<span class="token punctuation">,</span> torch_dtype<span class="token operator">=</span><span class="token string">'auto'</span><span class="token punctuation">,</span>
                                        <span class="token comment"># load_in_8bit=True, device_map='auto'</span>
                                        <span class="token punctuation">)</span>
</code></pre> 
<p>而量化版本的模型：</p> 
<ul><li>INT8模型调用方式同FP16，参数<code>load_in_8bit</code>设置为True，直接利用hugglingface的transformer库INT8的实现</li><li>INT4的模型使用GPTQ的方式进行量化，具体代码通过<a href="https://openai.com/research/triton" rel="nofollow">triton</a>语言（区别于我之前提到的triton inference server）进行加速</li></ul> 
<p>下面是测试结果：</p> 
<table><thead><tr><th><strong>模型</strong></th><th><strong>平台</strong></th><th><strong>精度</strong></th><th><strong>显存</strong></th><th><strong>速度</strong></th><th><strong>备注</strong></th></tr></thead><tbody><tr><td>llama-7B</td><td>A4000</td><td>FP16</td><td>13.6g</td><td>Output generated in 1.74 seconds (28.74 tokens/s, 50 tokens)<br>Output generated in 9.63 seconds (25.97 tokens/s, 250 tokens)</td><td>GPTQ-for-LLaMa/llama_inference.py <br>测试包含模型前后处理<br>利用率99%</td></tr><tr><td></td><td>A4000</td><td>4-bit</td><td>5g</td><td>Output generated in 2.89 seconds (17.51 tokens/s, 50 tokens)</td><td></td></tr><tr><td></td><td>A4000</td><td>4-bit</td><td>5g</td><td>Output generated in 2.93 seconds (17.11 tokens/s, 50 tokens)</td><td>stream模式<br>一次输出1个token</td></tr><tr><td></td><td>A4000</td><td>4-bit</td><td>3.4+2.3g</td><td>Output generated in 2.91 seconds (17.31 tokens/s, 50 tokens)</td><td>多卡测试双A4000<br>两张卡利用率 20-30左右</td></tr><tr><td></td><td>A4000</td><td>INT8</td><td>8.3g</td><td>Output generated in 10.20 seconds (5.8 tokens/s, 50 tokens)<br>int8 实现用的huggingface的实现</td><td>利用率25%</td></tr></tbody></table> 
<p>我这边拿我的A4000测了下，测试从tokenizer编码后开始，到tokenizer解码后结束。<br>大概的结论：</p> 
<ul><li>FP16速度最快，因为INT4和INT8的量化没有优化好（理论上INT8和INT4比FP16要快不少），而INT4的triton优化明显比huggingface中INT8的实现要好，建议使用INT4量化</li><li>stream模式和普通模型的速度似乎差不多</li></ul> 
<p>A6000的懒得测试了，补充一个网上搜到的指标，A6000相比A4000相当于类似于3090和3070的性能差距吧…<br><img src="https://images2.imgbox.com/6e/17/9TCEpYvH_o.png" alt="image.png"></p> 
<h2><a id="LLM_104"></a>LLM和普通小模型在部署方面的区别</h2> 
<p>在我以往的任务中，都是处理CV相关的模型，检测、分类、识别、关键点啥的，最大模型可能也只有2、3G的样子。平时的检测模型，大点的也就300多M，在FP16或者INT8量化后则更小了，所以一般来说没有显存焦虑（当然有特殊情况，有时候可能会在一张卡上部署很多个模型，比如自动驾驶场景或者其他工业场景，这时候也是需要合理分配模型的显存占用）。<br>但部署LLM这种大模型就不一样了，随便一个6、7B的模型，动不动就20多G的权重；65B、175B的模型更是有几百G，<strong>模型变得异常大，因为这个原因</strong>，原来的部署方式都要发生一些变化。</p> 
<h3><a id="_106"></a>模型方面的区别</h3> 
<ul><li>首先模型很大，<a href="https://github.com/pytorch/pytorch/pull/33062">大模型导出ONNX有一些问题</a>，ONNX保存大模型的权重存在一些限制</li><li>LLM模型中一般包含很多if-else分支，比如是否采用kv-cache，对转换一些个别结构的模型（比如tensorrt）不是很友好</li><li>我们之前都是单GPU运行，多GPU的话，很多常用的runtime都不支持，onnxruntime或者tensorrt（tensorrt有内测多GPU的支持）默认都不支持多GPU</li><li>对于大模型来说，量化是必要的，因为FP16或者FP32的模型需要的显存太大，都是钱啊。量化起来也不容易，QAT代价太大，PTQ校准的时候也需要很大的内存和显存，会用INT8和INT4量化</li><li>网上对于这类模型的加速kernel不是很多，可以参考的较少，很多需要自己手写</li></ul> 
<h3><a id="_113"></a>服务方式的区别</h3> 
<p>对于小模型来说，推理速度一般不会太慢，基本都在500ms以内，稍微等待下就得到结果了，也即是普通的http请求，一次请求得到一次结果。<br>而LLM因为是一个一个token产出来的，如果等全部token都出来再返回，那么用户等待时间就挺长的，体验不好，所以一般都是使用stream模式，就是出一点返回一点，类似于打字机的赶脚。</p> 
<h2><a id="_115"></a>部署方案讨论</h2> 
<p>这部分是本篇文章主要想说的地方，也是想和大家讨论，一起想想方案，抛砖引玉。<br>对于部署像LLAMA这种的大语言模型，我之前也没有经验，浏览了一些开源的仓库和资料，大概也有些思路，简单总结总结，有那么几个方案：</p> 
<h3><a id="Python_117"></a>依赖Python实现的方案</h3> 
<p>和普通的CV模型一样，python实现肯定是最简单也是实现最多的，我们可以基于现有的开源实现直接包一层服务框架，类似于flask的服务即可，但是也需要有一定的可靠性。<br>所以这里可以选择<strong>triton-inference-server的python后端</strong>，自己包一层前后处理，可以支持stream模式（使用grpc）。<br>这个实现起来比较简单，多注意输入输出即可，相对于CV来说，我们的输入可以是text或者是input_ids，要和图像的unchar区别开，加速部分只能依赖python实现，同时也依赖python环境。<br><img src="https://images2.imgbox.com/8c/8c/RZAV5qiD_o.png" alt="triton也原生支持python了" title="triton也原生支持python了"></p> 
<h3><a id="fastertransformer_backend_119"></a>fastertransformer_backend方案</h3> 
<p>对于生产环境的部署，可以使用triton inference server，然后基于tritonserver有fastertransformer-backend。fastertransformer-backend是一个支持多个LLM模型的backend，手工实现了很多高性能的针对transformer的算子，每个模型都是手写cuda搭建起来的，性能相比使用库要高一档。不过代价就是比较难支持新的模型框架，需要修改大量的源码。<br>NVIDIA Triton introduces Multi-GPU Multi-node inference. It uses model parallelism techniques below to split a large model across multiple GPUs and nodes:</p> 
<ul><li>Pipeline (Inter-Layer) Parallelism that splits contiguous sets of layers across multiple GPUs. This maximizes GPU utilization in single-node.</li><li>Tensor (Intra-Layer) Parallelism that splits individual layers across multiple GPUs. This minimizes latency in single-node</li></ul> 
<p><img src="https://images2.imgbox.com/17/02/JbWWpAfj_o.png" alt="image.png"><br>所幸开源社区的大佬很多，<a href="https://github.com/NVIDIA/FasterTransformer/issues/506">近期的非官方PR也支持了LLAMA</a>。我自己尝试跑了下速度要比第一个huggingface的实现要快20%，这个精度基于FP16，支持多卡，目前暂时未支持INT8和INT4。</p> 
<h3><a id="_126"></a>利用加速库分而治之的方案</h3> 
<p>我们知道LLAMA的7B模型包含32个结构相同的decoder：</p> 
<pre><code class="prism language-python"><span class="token comment"># transformers/src/transformers/models/llama/modeling_llama.py</span>
self<span class="token punctuation">.</span>layers <span class="token operator">=</span> nn<span class="token punctuation">.</span>ModuleList<span class="token punctuation">(</span><span class="token punctuation">[</span>LlamaDecoderLayer<span class="token punctuation">(</span>config<span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>num_hidden_layers<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<p>因此我们也可以将这32个子模型分别使用我们常用的加速库部署起来，比如7B的大模型，拆分成子模型每个模型300多M，使用TensorRT可以轻松转换，也有大佬已经在做了：</p> 
<ul><li><a href="https://github.com/tpoisonooo/llama.onnx">https://github.com/tpoisonooo/llama.onnx</a></li></ul> 
<p>7B的llama模型转成ONNX大概是这些：</p> 
<ul><li>decoder-merge-0.onnx</li></ul> 
<p><img src="https://images2.imgbox.com/a1/21/mzZv3YPU_o.png" alt="image.png"></p> 
<ul><li>embed.onnx</li></ul> 
<p><img src="https://images2.imgbox.com/9c/df/P9nQMKuX_o.png" alt="image.png"></p> 
<ul><li>head.onnx</li></ul> 
<p><img src="https://images2.imgbox.com/c7/33/XAAz52Rb_o.png" alt="image.png"></p> 
<ul><li>norm.onnx</li></ul> 
<p><img src="https://images2.imgbox.com/07/2f/bgl4kYCx_o.png" alt="image.png"><br>串起来的话，可以把这些模型放到不同的显卡上也是可以的，比如两张显卡，第一张卡放15个子模型，第二张卡放剩余17个子模型，组成pipeline parallelism也是可以的。<br>有几点需要注意：</p> 
<ul><li>加速库可以使用不限于TensorRT，比如TVM、AItemplate啥的</li><li>需要一个后端将所有子模型串起来，最好C++实现</li><li>对于kv-cache，怎么存放需要考虑下</li></ul> 
<p>可以使用triton-inference-server去组pipeline，不同子模型的instance可以放到不同的gpu上。</p> 
<h2><a id="_159"></a>后记</h2> 
<p>暂时先说这些，这篇文章之后也会随时更新。目前只是简单列了列我自己的想法，大家如果有好的想法也欢迎跟老潘一起交流。<br>每天出的新东西新技术太多了，看不过来，这篇文章也拖了好久，上述的这三种方案我自己都尝试过了，都是可行的，大家感兴趣可以试试，不过有个消息是<a href="https://developer.nvidia.com/blog/power-your-ai-inference-with-new-nvidia-triton-and-nvidia-tensorrt-features/" rel="nofollow">TensorRT已经在默默支持多卡推理了</a>，最快可能下个月（6月）就会出来（可能是对外release），不知道TensorRT大模型版本怎么样？</p> 
<h3><a id="TensorRThttpsimgblogcsdnimgcnimg_convert1f11e7f8011bac8594d01c568d2ea9d2pngaverageHuef2f0efclientIduc3fc8eb61d004frompasteheight213idu7caf6bf7originHeight320originWidth1158originalTypebinaryratio15rotation0showTitletruesize50238statusdonestylenonetaskIdu35fff9d68c834a46bed86b2a64c2767titleTensorRTwidth772_TensorRT_161"></a><img src="https://images2.imgbox.com/0b/e5/xvfaalx6_o.png" alt="TensorRT大模型版本" title="TensorRT大模型版本"></h3> 
<h2><a id="_162"></a>参考链接</h2> 
<ul><li><a href="https://github.com/huggingface/text-generation-inference">https://github.com/huggingface/text-generation-inference</a></li><li><a href="https://github.com/huggingface/chat-ui/issues">https://github.com/huggingface/chat-ui/issues</a></li><li><a href="https://github.com/ELS-RD/transformer-deploy">https://github.com/ELS-RD/transformer-deploy</a></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4e94c79648acc3d98952b27bd347615c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2023年最新react面试题 附详细答案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/faeab8a932a6005b5305a14382255837/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">YOLO8自定义检测实战</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>