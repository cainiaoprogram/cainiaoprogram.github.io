<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>结构体（算法） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="结构体（算法）" />
<meta property="og:description" content="6.1 结构体概念 结构体(struct)：是由一系列具有相同类型或不同类型的数据构成的数据集合。“结构”是一种构造类型，它是由若干“成员”组成的。每一个成员可以是一个基本数据类型或者又是一个构造类型。结构即是一种“构造”而成的数据类型， 那么在说明和使用之前必须先定义它，也就是构造它。 6.2 C&#43;&#43;语言中的结构体 6.2.1 结构体的声明和定义
声明一个结构体类型的一般形式为：
struct 结构体名{ 成员列表; }； eg:
struct Stu{//Stu是声明的一个结构体类型名 int score;//整型成员变量 int math;//整型成员变量 char name[10];//字符型成员变量 }； struct为结构体关键字，上面只是声明了一个结构构造类型Stu
和int,float类似，Stu是一个类型名，可以定义结构体变量
类型声明只是告诉系统此类型的构造形式，并不会实际分配内存
注意：结构体的声明和定义必须以分号结束。
定义结构后，便可以创建这种类型的变量了：
Stu a;//定义一个结构体变量a Stu hat;//定义一个结构体变量hat (2) 示例代码
此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c，但没有标明其标签，声明了结构体变量s1
struct { int a; char b; double c; } s1;//s1是结构体变量 此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c，结构体的类型名被命名为Stu，另外定义了变量t1, t2[20], *t3
struct Stu{ int a; char b; double c; }; Stu t1, t2[20], *t3; 可以用typedef创建新类型，此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c，结构体的标签被命名为Simple2，用Simple2作为类型声明新的结构体变量u1, u2[20], *u3
typedef struct Simple{//Simple是结构体类型名 int a; char b; double c; } Simple2;//注意：Simple2也是结构体类型名，相当于Simple的别名 Simple2 u1, u2[20], *u3;//若去掉typedef则编译报错，error C2371: “Simple2”: 重定义；不同的基类型 同类型的结构体可以直接赋值。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/99937de2be653a70620391f700a55616/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-25T16:47:42+08:00" />
<meta property="article:modified_time" content="2023-02-25T16:47:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">结构体（算法）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 id="61-结构体概念" style="margin-left:0;text-align:left;"><strong><span style="color:#000000;"><span style="background-color:#ffffff;">6.1 结构体概念</span></span></strong></h4> 
<ul style="margin-left:30px;"><li>结构体(struct)：是由一系列具有相同类型或不同类型的数据构成的数据集合。</li><li>“结构”是一种构造类型，它是由若干“成员”组成的。</li><li>每一个成员可以是一个基本数据类型或者又是一个构造类型。</li><li>结构即是一种“构造”而成的数据类型， 那么在说明和使用之前必须先定义它，也就是构造它。</li></ul> 
<h4 id="62-c语言中的结构体" style="margin-left:0;text-align:left;"><strong><span style="color:#000000;"><span style="background-color:#ffffff;">6.2 C++语言中的结构体</span></span></strong></h4> 
<p><strong><span style="color:#333333;"><span style="background-color:#ffffff;">6.2.1 结构体的声明和定义</span></span></strong></p> 
<ul style="margin-left:30px;"><li> <p style="margin-left:auto;">声明一个结构体类型的一般形式为：</p> 
  <ul style="margin-left:30px;"><li> <pre class="highlighter-hljs" style="margin-left:0;"><code class="language-c language-c++"><span style="color:#0000ff;">struct</span> 结构体名{
    成员列表;
}；
</code></pre> </li><li> <p style="margin-left:auto;"><strong>eg:</strong></p> <pre class="highlighter-hljs" style="margin-left:0;"><code class="language-c language-c++"><span style="color:#0000ff;">struct</span> <span style="color:#a31515;">Stu</span>{<!-- --><span style="color:#008000;">//Stu是声明的一个结构体类型名</span>
    <span style="color:#a31515;">int</span> score;<span style="color:#008000;">//整型成员变量</span>
    <span style="color:#a31515;">int</span> math;<span style="color:#008000;">//整型成员变量</span>
    <span style="color:#a31515;">char</span> name[<span style="color:#880000;">10</span>];<span style="color:#008000;">//字符型成员变量</span>
}；
</code></pre> </li><li> <p style="margin-left:auto;"><strong>struct</strong>为结构体关键字，上面只是声明了一个结构构造类型<code>Stu</code></p> </li><li> <p style="margin-left:auto;">和<code>int,float</code>类似，<code>Stu</code>是一个类型名，可以定义结构体变量</p> </li><li> <p style="margin-left:auto;">类型声明只是告诉系统此类型的构造形式，并不会实际分配内存</p> </li><li> <p style="margin-left:auto;">注意：结构体的声明和定义必须以<strong>分号</strong>结束。</p> </li></ul></li><li> <p style="margin-left:auto;">定义结构后，便可以创建这种类型的变量了：</p> <pre class="highlighter-hljs" style="margin-left:0;"><code class="language-c language-c++">Stu a;<span style="color:#008000;">//定义一个结构体变量a</span>
Stu hat;<span style="color:#008000;">//定义一个结构体变量hat</span>
</code></pre> </li><li> <p style="margin-left:auto;">(2) 示例代码</p> 
  <ol style="margin-left:0;"><li> <p style="margin-left:auto;">此声明声明了拥有<code>3</code>个成员的结构体，分别为整型的<code>a</code>，字符型的b和双精度的<code>c</code>，但没有标明其标签，声明了结构体变量<code>s1</code></p> <pre class="highlighter-hljs" style="margin-left:0;"><code class="language-c language-c++"><span style="color:#0000ff;">struct</span> {
    <span style="color:#a31515;">int</span> a;
    <span style="color:#a31515;">char</span> b;
    <span style="color:#a31515;">double</span> c;
} s1;<span style="color:#008000;">//s1是结构体变量</span>
</code></pre> </li><li> <p style="margin-left:auto;">此声明声明了拥有<code>3</code>个成员的结构体，分别为整型的<code>a</code>，字符型的<code>b</code>和双精度的<code>c</code>，结构体的类型名被命名为<code>Stu</code>，另外定义了变量<code>t1, t2[20], *t3</code></p> <pre class="highlighter-hljs" style="margin-left:0;"><code class="language-c language-c++"><span style="color:#0000ff;">struct</span> <span style="color:#a31515;">Stu</span>{
    <span style="color:#a31515;">int</span> a;
    <span style="color:#a31515;">char</span> b;
    <span style="color:#a31515;">double</span> c;
};
Stu t1, t2[<span style="color:#880000;">20</span>], *t3; 
</code></pre> </li><li> <p style="margin-left:auto;">可以用<code>typedef</code>创建新类型，此声明声明了拥有<code>3</code>个成员的结构体，分别为整型的<code>a</code>，字符型的<code>b</code>和双精度的<code>c</code>，结构体的标签被命名为<code>Simple2</code>，用<code>Simple2</code>作为类型声明新的结构体变量<code>u1, u2[20], *u3</code></p> <pre class="highlighter-hljs" style="margin-left:0;"><code class="language-c language-c++"><span style="color:#0000ff;">typedef</span> <span style="color:#0000ff;">struct</span> <span style="color:#a31515;">Simple</span>{<!-- --><span style="color:#008000;">//Simple是结构体类型名</span>
    <span style="color:#a31515;">int</span> a;
    <span style="color:#a31515;">char</span> b;
    <span style="color:#a31515;">double</span> c; 
} Simple2;<span style="color:#008000;">//注意：Simple2也是结构体类型名，相当于Simple的别名</span>
Simple2 u1, u2[<span style="color:#880000;">20</span>], *u3;<span style="color:#008000;">//若去掉typedef则编译报错，error C2371: “Simple2”: 重定义；不同的基类型</span>
</code></pre> </li><li> <p style="margin-left:auto;">同类型的结构体可以直接赋值。</p> <pre class="highlighter-hljs" style="margin-left:0;"><code class="language-c language-c++"><span style="color:#0000ff;">struct</span> <span style="color:#a31515;">Stu</span>{
    <span style="color:#a31515;">int</span> score;
    <span style="color:#a31515;">int</span> math;
    <span style="color:#a31515;">char</span> name[<span style="color:#880000;">10</span>];
}；
Stu a,b={<!-- --><span style="color:#880000;">100</span>,<span style="color:#880000;">50</span>,<span style="color:#a31515;">"Tom"</span>};
a=b;<span style="color:#008000;">//正确，a,b是同为Stu类型的结构题变量</span>
</code></pre> </li></ol></li></ul> 
<h4 id="63-结构体内存分配机制" style="margin-left:0;text-align:left;"><strong><span style="color:#000000;"><span style="background-color:#ffffff;">6.3 结构体内存分配机制</span></span></strong></h4> 
<ul style="margin-left:30px;"><li>结构体和其他的数据类型是一样的，在定义一个结构体的时候，系统并不会真正的分配内存空间，只有在定义变量的时候，才会分配。</li><li>结构体对于成员变量的内存分配有以下要求：</li></ul> 
<ol style="margin-left:0;"><li> <p style="margin-left:auto;">结构体变量的<strong>首地址</strong>能够被其最宽基本类型成员的大小所<strong>整除</strong>；</p> </li><li> <p style="margin-left:auto;">结构体每个成员相对于结构体首地址的偏移量都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节；</p> </li><li> <p style="margin-left:auto;">结构体的<strong>总大小</strong>为结构体最宽基本类型成员大小的<strong>整数倍</strong>，如有需要编译器会在最末一个成员之后加上填充字节</p> </li><li> <p style="margin-left:auto;">例如：</p> 
  <ul style="margin-left:30px;"><li> <pre class="highlighter-hljs" style="margin-left:0;"><code class="language-c language-c++"><span style="color:#0000ff;">struct</span> <span style="color:#a31515;">Stu</span> {
　　<span style="color:#a31515;">char</span> a;
　　<span style="color:#a31515;">int</span> b;
　　<span style="color:#a31515;">char</span> c;
};
</code></pre> 
    <ol style="margin-left:0;"><li>在<code>Stu</code>中，最宽数据类型为<code>int</code>，在<code>32</code>位系统中为<code>4Byte</code>）；</li><li>参照第二条，第一个数据是<code>char</code>，存储一个<code>char</code>占 <code>1 Byte</code> ，要保证下一个<code>int</code>的存储起始地址是<code>4</code>的整数倍，所以要在<code>char</code>后面填充 <code>3 Byte</code>，然后再存储<code>int</code> 变量 <code>b</code> 。</li><li>最后一个也是<code>char</code> 类型，他就占<code>1 Byte</code> ，肯定是他存储位置的整数倍</li><li>最后参照第三条，结构体的总大小为最宽数据类型的整数倍，所以会在第二个<code>char</code> 之后再填充<code>3 Byte</code>。</li><li>这样的话，总共占据的空间是1+<span style="color:#FF0000;">3</span>+4+1+<span style="color:#FF0000;">3</span> = 12（红色为填充字节）</li></ol></li><li> <p style="margin-left:auto;"><strong>但是</strong>，调换一下结构中数据成员的顺序：</p> <pre class="highlighter-hljs" style="margin-left:0;"><code class="language-c language-c++"><span style="color:#0000ff;">struct</span> <span style="color:#a31515;">s1</span> {
　　<span style="color:#a31515;">int</span> b;
　　<span style="color:#a31515;">char</span> a;
　　<span style="color:#a31515;">char</span> c;
};
</code></pre> 
    <ul style="margin-left:30px;"><li>同样地分析4+1+1+<span style="color:#FF0000;">2</span> = 8</li><li>相比之下，存储空间的效率提高33%。</li><li><em><strong>提示：</strong></em><u>在竞赛阶段，为了节约内存</u>，在组织数据结构的数据成员的时候，可以将相同类型的成员放在一起，这样就减少了编译器为了对齐而添加的填充字符。</li></ul></li></ul></li></ol> 
<h4 id="64-结构体初始化" style="margin-left:0;text-align:left;"><strong><span style="color:#000000;"><span style="background-color:#ffffff;">6.4 结构体初始化</span></span></strong></h4> 
<blockquote> 
 <ol style="margin-left:0;"><li>定义时初始化</li></ol> 
 <pre class="highlighter-hljs" style="margin-left:0;"><code class="language-c language-c++"><span style="color:#0000ff;">struct</span> <span style="color:#a31515;">Stu</span>{
    <span style="color:#a31515;">int</span> Num;
    <span style="color:#a31515;">bool</span> Sex;
    <span style="color:#a31515;">char</span> Name[<span style="color:#880000;">20</span>];
};
<span style="color:#008000;">//定义时初始化</span>
Stu a={<!-- --><span style="color:#880000;">0</span>};<span style="color:#008000;">//初始化所有成员为0</span>
Stu b={<!-- --><span style="color:#880000;">15</span>,<span style="color:#880000;">1</span>,<span style="color:#a31515;">"Tom"</span>};<span style="color:#008000;">//依次为成员赋值</span>
</code></pre> 
 <ol style="margin-left:0;"><li>构造函数初始化</li></ol> 
 <pre class="highlighter-hljs" style="margin-left:0;"><code class="language-c language-c++">方法一：
<span style="color:#0000ff;">struct</span> <span style="color:#a31515;">Stu</span>{
    <span style="color:#a31515;">int</span> Num;
    <span style="color:#a31515;">bool</span> Sex;
    <span style="color:#a31515;">char</span> Name[<span style="color:#880000;">20</span>];
    <span style="color:#008000;">//构造函数初始化</span>
    Stu(){
        Num=<span style="color:#880000;">0</span>;
        Sex=<span style="color:#a31515;">false</span>;
        <span style="color:#0000ff;">memset</span>(Name,<span style="color:#880000;">0</span>,<span style="color:#0000ff;">sizeof</span>(Name));
    }
};
方法二：
<span style="color:#0000ff;">struct</span> <span style="color:#a31515;">Stu</span>{
    <span style="color:#a31515;">int</span> Num;
    <span style="color:#a31515;">bool</span> Sex;
    <span style="color:#a31515;">char</span> Name[<span style="color:#880000;">20</span>];
    <span style="color:#008000;">//构造函数初始化</span>
    Stu(){
        <span style="color:#0000ff;">memset</span>(this-&gt;Name,<span style="color:#880000;">0</span>,<span style="color:#0000ff;">sizeof</span>(Name));
    }
};

</code></pre> 
 <ol style="margin-left:0;"><li>结构体成员的访问可以使用成员运算符："."</li></ol> 
 <pre class="highlighter-hljs" style="margin-left:0;"><code class="language-c language-c++"><span style="color:#0000ff;">struct</span> <span style="color:#a31515;">Stu</span>{
    <span style="color:#a31515;">int</span> Num;
    <span style="color:#a31515;">bool</span> Sex;
    <span style="color:#a31515;">char</span> Name[<span style="color:#880000;">20</span>];
    <span style="color:#008000;">//构造函数初始化</span>
    Stu(){
        <span style="color:#0000ff;">memset</span>(this,<span style="color:#880000;">0</span>,<span style="color:#0000ff;">sizeof</span>(Name));
    }
};
Stu a;
<span style="color:#008000;">//访问结构体a的成员函数</span>
a.Num=<span style="color:#880000;">10</span>;
a.Sex=<span style="color:#880000;">1</span>;
a.Name=<span style="color:#a31515;">"Tom"</span>;

</code></pre> 
</blockquote> 
<h4 id="65-结构体重载运算符重载" style="margin-left:0;text-align:left;"><strong><span style="color:#000000;"><span style="background-color:#ffffff;">6.5 结构体重载运算符重载</span></span></strong></h4> 
<p><strong><span style="color:#333333;"><span style="background-color:#ffffff;">6.5.1 运算符重载</span></span></strong></p> 
<ul style="margin-left:30px;"><li>基本概念 
  <ol style="margin-left:0;"><li>重载的运算符是具有特殊名字的<strong>函数</strong></li><li>由关键字 operatoroperator 和要重载的运算符号共同组成。eg:operator+()eg:operator+()</li><li>重载运算符也包含返回类型、参数列表以及函数体</li><li>重载运算符函数的参数数量与该运算符作用的运算对象数量一样多。(一元运算符有一个参数，二元有两个参数)</li><li>如果运算符函数是成员函数，则它的第一个运算对象绑定到隐式的 thisthis 指针上，因此显式的参数比实际参<strong>数少一个</strong></li><li>只能重载已有的运算符，无权发明新的运算符</li><li>可以重载绝大多数运算符。(不能重载 <strong>::</strong> ， <strong>.</strong> ，<strong>.</strong>* ，<strong>?:</strong> )</li><li>通常情况下，不应重载逗号、取地址、逻辑与、逻辑或运算符</li></ol></li></ul> 
<p><strong><span style="color:#333333;"><span style="background-color:#ffffff;">6.5.2 结构体重载运算符重载</span></span></strong></p> 
<ul style="margin-left:30px;"><li> <p style="margin-left:auto;">结构体是构造类型，是无法直接进行逻辑运算、四则运算等，如果需要，我们可以对相应的运算符进行重载</p> 
  <ul style="margin-left:30px;"><li> <p style="margin-left:auto;">结构体重载小于号 "&lt;"</p> </li><li> <pre class="highlighter-hljs" style="margin-left:0;"><code class="language-c language-c++"><span style="color:#0000ff;">struct</span> <span style="color:#a31515;">Stu</span>{
    <span style="color:#a31515;">int</span> score;<span style="color:#008000;">//总分</span>
    <span style="color:#a31515;">int</span> math;<span style="color:#008000;">//数学</span>
    <span style="color:#a31515;">char</span> Id[maxn];<span style="color:#008000;">//学号</span>
    <span style="color:#008000;">//方式一：作为成员函数重载，二元运算符，省略第一个参数，第一个const表示形参为只读，第二个const表示</span>
    <span style="color:#008000;">//不允许修改成员变量，固定格式。</span>
    <span style="color:#a31515;">bool</span> operator &lt;(<span style="color:#a31515;">const</span> Stu &amp;a)<span style="color:#a31515;">const</span>{
        <span style="color:#0000ff;">if</span>(score==a.score){<!-- --><span style="color:#008000;">//如果总分相等按数学进行比较</span>
            <span style="color:#008000;">//如果总分、数学都相等按学号进行比较</span>
            <span style="color:#0000ff;">if</span>(math==a.math)<span style="color:#0000ff;">return</span> (<span style="color:#0000ff;">strcmp</span>(Id,a.Id)&lt;<span style="color:#880000;">0</span>);
            <span style="color:#008000;">//如果总分相等，数学不等，数学进行比较</span>
            <span style="color:#0000ff;">return</span> math&gt;a.math;
        }
        <span style="color:#008000;">//如果总分不等，按总分进行比较</span>
        <span style="color:#0000ff;">return</span> score&gt;a.score;
    }
};
<span style="color:#008000;">//方法二：全局重载</span>
<span style="color:#a31515;">bool</span> operator &lt;(<span style="color:#a31515;">const</span> Stu &amp;a,<span style="color:#a31515;">const</span> Stu &amp;b){
     <span style="color:#0000ff;">if</span>(a.score==b.score){<!-- --><span style="color:#008000;">//如果总分相等按数学进行比较</span>
         <span style="color:#008000;">//如果总分、数学都相等按学号进行比较</span>
         <span style="color:#0000ff;">if</span>(a.math==b.math)<span style="color:#0000ff;">return</span> (<span style="color:#0000ff;">strcmp</span>(a.Id,b.Id)&lt;<span style="color:#880000;">0</span>);
         <span style="color:#008000;">//如果总分相等，数学不等，数学进行比较</span>
         <span style="color:#0000ff;">return</span> a.math&gt;b.math;
     }
        <span style="color:#008000;">//如果总分不等，按总分进行比较</span>
     <span style="color:#0000ff;">return</span> a.score&gt;b.score;
}
</code></pre> </li><li> <p style="margin-left:auto;">结构体重载小于号 "+"</p> <pre class="highlighter-hljs" style="margin-left:0;"><code class="language-c language-c++"><span style="color:#0000ff;">struct</span> <span style="color:#a31515;">Stu</span>{
    <span style="color:#a31515;">int</span> score;<span style="color:#008000;">//总分</span>
    <span style="color:#a31515;">int</span> math;<span style="color:#008000;">//数学    </span>
    <span style="color:#008000;">//方式一：作为成员函数重载，二元运算符，省略第一个参数，第一个const表示形参为只读，第二个const表示</span>
    <span style="color:#008000;">//不允许修改成员变量，固定格式。tongxue</span>
    Stu operator +(<span style="color:#a31515;">const</span> Stu &amp;a)<span style="color:#a31515;">const</span>{
        Stu temp;<span style="color:#008000;">//临时结构体变量</span>
        temp.score=this-&gt;score+a.score;<span style="color:#008000;">//this-&gt;score等价与score表示改结构题的score成员变量</span>
        temp.math=this-&gt;math+a.math;
        rerturn temp;<span style="color:#008000;">//计算后的结构变量</span>
    }
};
<span style="color:#008000;">//全局重在略……</span>
</code></pre> </li></ul></li><li> <p style="margin-left:auto;">结构体成员函数和构造函数</p> <pre class="highlighter-hljs" style="margin-left:0;"><code class="language-c language-c++"><span style="color:#0000ff;">struct</span> <span style="color:#a31515;">Stu</span>{
    <span style="color:#a31515;">int</span> score;<span style="color:#008000;">//总分</span>
    <span style="color:#a31515;">int</span> math;<span style="color:#008000;">//数学    </span>
    <span style="color:#a31515;">char</span> Id[maxn];<span style="color:#008000;">//学号</span>
    <span style="color:#008000;">//创建结构题时会自动创建一个默认的同名构造函数,构造函数在定义变量时会自动调用</span>
    Stu(){
        <span style="color:#0000ff;">memset</span>(this,<span style="color:#880000;">0</span>,<span style="color:#0000ff;">sizeof</span>(Stu));
    }
    <span style="color:#008000;">//成员函数，需要调用才会执行</span>
    <span style="color:#a31515;">void</span> <span style="color:#a31515;">Init</span>(){
        <span style="color:#0000ff;">memset</span>(this,<span style="color:#880000;">0</span>,<span style="color:#0000ff;">sizeof</span>(Stu));
    }
    <span style="color:#008000;">//成员函数是自己定义的实现某些功能的函数，需要调用才能使用</span>
    <span style="color:#a31515;">void</span> <span style="color:#a31515;">Print</span>(){
        <span style="color:#0000ff;">printf</span>(<span style="color:#a31515;">"%s\n"</span>,Id);
    }
}a;
<span style="color:#008000;">//调用</span>
a.Init();
a.Print();
</code></pre> </li><li> <p style="margin-left:auto;">有能力的同学可以尝试这重载一下高精度加、减、乘法。</p> <pre class="highlighter-hljs" style="margin-left:0;"><code class="language-c language-c++"><span style="color:#0000ff;">struct</span> <span style="color:#a31515;">Stu</span>{
	<span style="color:#a31515;">int</span> a[maxn];
	Stu(){
		<span style="color:#0000ff;">memset</span>(this,<span style="color:#880000;">0</span>,<span style="color:#0000ff;">sizeof</span>(Stu));
	}
	<span style="color:#008000;">//重载赋值语句</span>
	Stu operator =(<span style="color:#a31515;">const</span> Stu &amp;b){
		<span style="color:#0000ff;">for</span>(<span style="color:#a31515;">int</span> i=<span style="color:#880000;">0</span>;i&lt;=b.a[<span style="color:#880000;">0</span>];++i)
			a[i]=b.a[i];
		<span style="color:#0000ff;">return</span> *this;
	}
	<span style="color:#008000;">//重载赋值语句</span>
	Stu operator +(<span style="color:#a31515;">const</span> Stu &amp;b){
		Stu c;
		<span style="color:#a31515;">int</span> i=<span style="color:#880000;">1</span>;
		<span style="color:#0000ff;">while</span>(i&lt;=a[<span style="color:#880000;">0</span>] || i&lt;=b.a[<span style="color:#880000;">0</span>]){
			c.a[i]+=a[i]+b.a[i];
			c.a[i+<span style="color:#880000;">1</span>]=c.a[i]/<span style="color:#880000;">10</span>;
			c.a[i]%=<span style="color:#880000;">10</span>;
			++i;
		}
		<span style="color:#0000ff;">if</span>(c.a[i])c.a[<span style="color:#880000;">0</span>]=i;
		<span style="color:#0000ff;">else</span> c.a[<span style="color:#880000;">0</span>]=i<span style="color:#880000;">-1</span>;
		<span style="color:#0000ff;">return</span> c;
	}
	<span style="color:#a31515;">void</span> <span style="color:#a31515;">read</span>(){
		<span style="color:#a31515;">char</span> s[maxn];
		<span style="color:#0000ff;">scanf</span>(<span style="color:#a31515;">"%s"</span>,s);
		a[<span style="color:#880000;">0</span>]=<span style="color:#0000ff;">strlen</span>(s);
		<span style="color:#0000ff;">for</span>(<span style="color:#a31515;">int</span> i=<span style="color:#880000;">0</span>;i&lt;a[<span style="color:#880000;">0</span>];++i)
			a[a[<span style="color:#880000;">0</span>]-i]=s[i]<span style="color:#880000;">-48</span>;
	}
	<span style="color:#a31515;">void</span> <span style="color:#a31515;">Print</span>(){
		<span style="color:#0000ff;">for</span>(<span style="color:#a31515;">int</span> i=a[<span style="color:#880000;">0</span>];i&gt;<span style="color:#880000;">0</span>;--i)
			<span style="color:#0000ff;">printf</span>(<span style="color:#a31515;">"%d"</span>,a[i]);
		<span style="color:#0000ff;">printf</span>(<span style="color:#a31515;">"\n"</span>);
	}
};</code></pre> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/21edd3418df1b7390a4b2d44870e8a4a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Web安全攻防世界04 unseping（江苏工匠杯）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dc2c265e9f65ca78c9b605209e10dc13/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">分析 HTTP，TCP 的长连接和短连接以及 socket</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>