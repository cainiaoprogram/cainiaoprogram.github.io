<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HttpClient获取Cookie的一次踩坑实录 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HttpClient获取Cookie的一次踩坑实录" />
<meta property="og:description" content="本文原地址：http://www.fullstackyang.com/...，转发请注明本博客地址或segmentfault地址，谢谢！
在使用HttpClient进行抓取一些网页的时候，经常会保留从服务器端发回的Cookie信息，以便发起其他需要这些Cookie的请求。大多数情况下，我们使用内置的cookie策略，便能够方便直接地获取这些cookie。
下面的一小段代码，就是访问http://www.baidu.com，并获取对应的cookie：
@Test public void getCookie(){ CloseableHttpClient httpClient = HttpClients.createDefault(); HttpGet get=new HttpGet(&#34;http://www.baidu.com&#34;); HttpClientContext context = HttpClientContext.create(); try { CloseableHttpResponse response = httpClient.execute(get, context); try{ System.out.println(&#34;&gt;&gt;&gt;&gt;&gt;&gt;headers:&#34;); Arrays.stream(response.getAllHeaders()).forEach(System.out::println); System.out.println(&#34;&gt;&gt;&gt;&gt;&gt;&gt;cookies:&#34;); context.getCookieStore().getCookies().forEach(System.out::println); } finally { response.close(); } } catch (IOException e) { e.printStackTrace(); }finally { try { httpClient.close(); } catch (IOException e) { e.printStackTrace(); } } } 打印结果
&gt;&gt;&gt;&gt;&gt;&gt;headers: Server: bfe/1.0.8.18 Date: Tue, 12 Sep 2017 06:19:06 GMT Content-Type: text/html Last-Modified: Mon, 23 Jan 2017 13:28:24 GMT Transfer-Encoding: chunked Connection: Keep-Alive Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform Pragma: no-cache Set-Cookie: BDORZ=27315; max-age=86400; domain=." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b7e54707f86c12fd6aee4f990b58f447/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-09-13T23:01:27+08:00" />
<meta property="article:modified_time" content="2017-09-13T23:01:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HttpClient获取Cookie的一次踩坑实录</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article fmt article__content"> 
 <blockquote> 
  <p>本文原地址：<a href="http://www.fullstackyang.com/archives/416.html" rel="nofollow">http://www.fullstackyang.com/...</a>，转发请注明本博客地址或segmentfault地址，谢谢！</p> 
 </blockquote> 
 <p>在使用HttpClient进行抓取一些网页的时候，经常会保留从服务器端发回的Cookie信息，以便发起其他需要这些Cookie的请求。大多数情况下，我们使用内置的cookie策略，便能够方便直接地获取这些cookie。<br>下面的一小段代码，就是访问<a href="http://www.baidu.com" rel="nofollow">http://www.baidu.com</a>，并获取对应的cookie：</p> 
 <pre><code>@Test
public void getCookie(){
    CloseableHttpClient httpClient = HttpClients.createDefault();
    HttpGet get=new HttpGet("http://www.baidu.com");
    HttpClientContext context = HttpClientContext.create();
    try {
        CloseableHttpResponse response = httpClient.execute(get, context);
        try{
            System.out.println("&gt;&gt;&gt;&gt;&gt;&gt;headers:");
            Arrays.stream(response.getAllHeaders()).forEach(System.out::println);
            System.out.println("&gt;&gt;&gt;&gt;&gt;&gt;cookies:");
            context.getCookieStore().getCookies().forEach(System.out::println);
        }
        finally {
            response.close();
        }
    } catch (IOException e) {
        e.printStackTrace();
    }finally {
        try {
            httpClient.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre> 
 <p>打印结果</p> 
 <pre><code>&gt;&gt;&gt;&gt;&gt;&gt;headers:
Server: bfe/1.0.8.18
Date: Tue, 12 Sep 2017 06:19:06 GMT
Content-Type: text/html
Last-Modified: Mon, 23 Jan 2017 13:28:24 GMT
Transfer-Encoding: chunked
Connection: Keep-Alive
Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform
Pragma: no-cache
Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/
&gt;&gt;&gt;&gt;&gt;&gt;cookies:
[version: 0][name: BDORZ][value: 27315][domain: baidu.com][path: /][expiry: null]</code></pre> 
 <p>但是也有一些网站返回的cookie并不一定完全符合规范，例如下面这个例子，从打印出的header中可以看到，这个cookie中的Expires属性是时间戳形式，并不符合标准的时间格式，因此，httpclient对于cookie的处理失效，最终无法获取到cookie，并且发出了一条警告信息：“Invalid ‘expires’ attribute: 1505204523”</p> 
 <pre><code>警告: Invalid cookie header: "Set-Cookie: yd_cookie=90236a64-8650-494b332a285dbd886e5981965fc4a93f023d; Expires=1505204523; Path=/; HttpOnly". Invalid 'expires' attribute: 1505204523
&gt;&gt;&gt;&gt;&gt;&gt;headers:
Date: Tue, 12 Sep 2017 06:22:03 GMT
Content-Type: text/html
Connection: keep-alive
Set-Cookie: yd_cookie=90236a64-8650-494b332a285dbd886e5981965fc4a93f023d; Expires=1505204523; Path=/; HttpOnly
Cache-Control: no-cache, no-store
Server: WAF/2.4-12.1
&gt;&gt;&gt;&gt;&gt;&gt;cookies:</code></pre> 
 <p>虽然我们可以利用header的数据，重新构造一个cookie出来，也有很多人确实也是这么做的，但这种方法不够优雅，那么如何解决这个问题？网上相关的资料又很少，所以就只能先从官方文档入手。在官方文档3.4小节custom cookie policy中讲到允许自定义的cookie策略，自定义的方法是实现CookieSpec接口，并通过CookieSpecProvider来完成在httpclient中的初始化和注册策略实例的工作。好了，关键的线索在于CookieSpec接口，我们来看一下它的源码：</p> 
 <pre><code>public interface CookieSpec {
……
    /**
      * Parse the {@code "Set-Cookie"} Header into an array of Cookies.
      *
      * &lt;p&gt;This method will not perform the validation of the resultant
      * {@link Cookie}s&lt;/p&gt;
      *
      * @see #validate
      *
      * @param header the {@code Set-Cookie} received from the server
      * @param origin details of the cookie origin
      * @return an array of {@code Cookie}s parsed from the header
      * @throws MalformedCookieException if an exception occurs during parsing
      */
    List&lt;Cookie&gt; parse(Header header, CookieOrigin origin) throws MalformedCookieException;
……
}</code></pre> 
 <p>在源码中我们发现了一个parse方法，看注释就知道正是这个方法，将Set-Cookie的header信息解析为Cookie对象，自然地再了解一下在httplcient中的默认实现DefaultCookieSpec，限于篇幅，源码就不贴了。在默认的实现中，DefaultCookieSpec主要的工作是判断header中Cookie规范的类型，然后再调用具体的某一个实现。像上述这种Cookie，最终是交由NetscapeDraftSpec的实例来做解析，而在NetscapeDraftSpec的源码中，定义了默认的expires时间格式为“EEE, dd-MMM-yy HH:mm:ss z”</p> 
 <pre><code>public class NetscapeDraftSpec extends CookieSpecBase {

    protected static final String EXPIRES_PATTERN = "EEE, dd-MMM-yy HH:mm:ss z";

    /** Default constructor */
    public NetscapeDraftSpec(final String[] datepatterns) {
        super(new BasicPathHandler(),
                new NetscapeDomainHandler(),
                new BasicSecureHandler(),
                new BasicCommentHandler(),
                new BasicExpiresHandler(
                        datepatterns != null ? datepatterns.clone() : new String[]{EXPIRES_PATTERN}));
    }

    NetscapeDraftSpec(final CommonCookieAttributeHandler... handlers) {
        super(handlers);
    }

    public NetscapeDraftSpec() {
        this((String[]) null);
    }
……
}</code></pre> 
 <p>到这里已经比较清楚了，我们只需要将Cookie中expires的时间转换为正确的格式，然后再送入默认的解析器就可以了。</p> 
 <p><strong>解决方法：</strong></p> 
 <ol><li>自定义一个CookieSpec类，继承DefaultCookieSpec</li><li>重写parser方法</li><li>将Cookie中的expires转换为正确的时间格式</li><li>调用默认的解析方法</li></ol> 
 <p>实现如下（URL就不公开了，已经隐去）</p> 
 <pre><code>public class TestHttpClient {
    
    String url = sth;

    class MyCookieSpec extends DefaultCookieSpec {
        @Override
        public List&lt;Cookie&gt; parse(Header header, CookieOrigin cookieOrigin) throws MalformedCookieException {
            String value = header.getValue();
            String prefix = "Expires=";
            if (value.contains(prefix)) {
                String expires = value.substring(value.indexOf(prefix) + prefix.length());
                expires = expires.substring(0, expires.indexOf(";"));
                String date = DateUtils.formatDate(new Date(Long.parseLong(expires) * 1000L),"EEE, dd-MMM-yy HH:mm:ss z");
                value = value.replaceAll(prefix + "\\d{10};", prefix + date + ";");
            }
            header = new BasicHeader(header.getName(), value);
            return super.parse(header, cookieOrigin);
        }
    }

    @Test
    public void getCookie() {

        CloseableHttpClient httpClient = HttpClients.createDefault();

        Registry&lt;CookieSpecProvider&gt; cookieSpecProviderRegistry = RegistryBuilder.&lt;CookieSpecProvider&gt;create()
                .register("myCookieSpec", context -&gt; new MyCookieSpec()).build();//注册自定义CookieSpec

        HttpClientContext context = HttpClientContext.create();
        context.setCookieSpecRegistry(cookieSpecProviderRegistry);

        HttpGet get = new HttpGet(url);
        get.setConfig(RequestConfig.custom().setCookieSpec("myCookieSpec").build());

        try {
            CloseableHttpResponse response = httpClient.execute(get, context);
            try{
                System.out.println("&gt;&gt;&gt;&gt;&gt;&gt;headers:");
                Arrays.stream(response.getAllHeaders()).forEach(System.out::println);
                System.out.println("&gt;&gt;&gt;&gt;&gt;&gt;cookies:");
                context.getCookieStore().getCookies().forEach(System.out::println);
            }
            finally {
                response.close();
            }
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                httpClient.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
}</code></pre> 
 <p>再次运行，顺利地打印出正确的结果，完美！</p> 
 <pre><code>&gt;&gt;&gt;&gt;&gt;&gt;headers:
Date: Tue, 12 Sep 2017 07:24:10 GMT
Content-Type: text/html
Connection: keep-alive
Set-Cookie: yd_cookie=9f521fc5-0248-4ab3ee650ca50b1c7abb1cd2526b830e620f; Expires=1505208250; Path=/; HttpOnly
Cache-Control: no-cache, no-store
Server: WAF/2.4-12.1
&gt;&gt;&gt;&gt;&gt;&gt;cookies:
[version: 0][name: yd_cookie][value: 9f521fc5-0248-4ab3ee650ca50b1c7abb1cd2526b830e620f][domain: www.sth.com][path: /][expiry: Tue Sep 12 17:24:10 CST 2017]</code></pre> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/056e6218e659f9d8543f6e30c63a5752/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微信小程序服务器请求和上传数据，上传图片并展示，提交表单完整实例代码附效果图</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cdc06fd32899536cb3004abb54500fd3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于用MyEclipse6.6,jdk1.8，class不编译的问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>