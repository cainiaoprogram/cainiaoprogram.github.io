<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>套接字的创建时机、新创建连接套接字的端口、套接字描述符的解惑 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="套接字的创建时机、新创建连接套接字的端口、套接字描述符的解惑" />
<meta property="og:description" content="套接字 套接字 socket是操作系统内核的一个数据结构，它是网络中节点进行相互通信的门户。网络编程实际上也可以称作套接字编程。
套接字有3种类型：
流式套接字，即TCP套接字，用SOCK_STREAM表示数据报套接字，即UDP套接字（或称无连接套接字），用SOCK_DGRAM表示原始套接字，用SOCK_RAM表示 套接字地址结构由网络地址和端口号组成。
传输方式 （1）TCP
TCP是一个面向连接的传输层协议，在数据发送之前（即进程通信之前)，必须先建立连接。通信完毕后，必须关闭连接。基于TCP传输协议的服务器与客户机间的通信工作流程如下图：
大致流程如下：
服务器先用socket()函数来建立一个套接字，用这个套接字完成通信的监听及数据的收发。服务器用bind()函数来绑定一个端口号和IP地址，使套接字与指定的端口号和IP地址相关联。服务器调用listen()函数，使服务器的这个端口和IP处于监听状态，等待网络中某一客户机的连接请求。客户机用socket()函数建立一个套接字，设定远程IP和端口。客户机调用connect()函数连接远程计算机指定的端口。服务器调用accept()函数来接受远程计算机的连接请求，建立起与客户机之间的通信连接。建立连接以后，客户机用write()函数（或close()函数）向socket中写入数据，也可以用read()函数（或recv()函数）读取服务器发来的数据。服务器用read()函数（或recv()函数）读取客户机发来的数据，也可以用write()函数（或send()函数）来发送数据。完成通信以后，使用close()函数关闭socket连接。 （2）UDP
不同于TCP协议，UDP是一个无连接的、不可靠服务的传输层协议，它不对数据进行确认、出错重传和排序等可靠性处理，但它却是具有代码小、实现简单那、速度快和系统开销小等优点。对于某些应用，使用UDP将带来更高的效率，如域名服务系统DNS、网络文件系统NFS等。
基于UDP传输协议的服务器与客户机间的通信工作流程如下图：
对比TCP套接字通信流程，区别在于：
使用TCP套接字必须先建立连接（如客户机进程的connect()，服务器进程的listen()和accept()） 而UDP套接字不需要先建立连接，它在调用socket()生成一个套接字后，在服务器端调用bind()绑定一个端口，然后服务器进程挂起于recvfrom()调用，等待并接收网络中某一客户机的数据请求。而客户端调用sendto()发送数据请求，同样也挂起于recvfrom()调用，等待并接收服务器的应答信号。
当数据传输完毕后，UDP套接字中的客户端调用close()释放通信链路，但不再发送“断开连接通知”信息来通知服务器端释放通信链路。 创建时机 每一个来自客户端的TCP请求在服务器端都会对应一个 socket。事实上，这个新 socket 的创建实机既不是在 listen 的时候，也不是在 accept 的时候，而是在三次握手成功之后创建的，然后放在对应的全连接队列中。
服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN&#43;ACK，接着客户端会返回 ACK，如果服务器超时还未收到 ACK 会进行 SYN&#43;ACK 的重传，重传的次数由 tcp_synack_retries 值确定，在 CentOS 上这个值等于 5。服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 全连接 队列，等待进程调用 accept 函数时把连接取出来。
accept会阻塞直到3次握手成功为止，也就是说accept发生在三次握手之后(没有accept 3次握手照样成功)。
服务器在 listen 状态的时候可以接收来自客户端的握手请求。当客户端发出的第三次 ack 到达时，服务器创建了新的 sock 对象（socket 的核心），然后加入到了全连接队列中。然后accept的时候，仅仅只是从全连接队列里把 sock 取出来而已。
套接字描述符 套接字描述符是一个整数类型的值，就如程序通过文件描述符访问文件一样，套接字描述符是访问套接字的一种路径。每个进程的进程空间里都有一个套接字描述符表(每个进程维护一个单独的套接字描述符表。因此，应用程序可以拥有相同的套接字描述符)，该表中存放着套接字描述符和套接字数据结构的对应关系。该表中有一个字段存放新创建的套接字的描述符，另一个字段存放套接字数据结构的地址，因此根据套接字描述符就可以找到其对应的套接字数据结构。每个进程在自己的进程空间里都有一个套接字描述符表但是套接字数据结构都是在操作系统的内核缓冲里。
从某种意义上说，套接字也是文件，所以许多对文件描述符使用的函数，对套接字描述符同样适用。每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。
在redis中，当下次这个client端往Redis服务器发送数据的时候，数据就会被内核拷贝到这个socket的输入缓冲区，然后aeEvent模块监听到这个事件就会调用readQueryFromClient函数。
write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再写入协议栈，即由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。read()/recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取。 套接字端口 有一个问题：比如我的程序开了一个监听端口，与客户端建立连接之后，生成了一个新套接字。这时我执行了只关闭监听端口的语句，结果却发现监听端口和已建立的连接仍然存在。我都已经关闭了监听套接字，为什么客户端还可以继续往监听端口发信息？这到底是因为什么呢？新套接字和监听套接字有什么关系呢？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/701e36609d5a379d509c8f1b412d3822/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-06T15:20:08+08:00" />
<meta property="article:modified_time" content="2023-08-06T15:20:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">套接字的创建时机、新创建连接套接字的端口、套接字描述符的解惑</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_2"></a>套接字</h3> 
<p><strong>套接字 socket</strong>是操作系统内核的一个数据结构，它是网络中节点进行相互通信的门户。网络编程实际上也可以称作套接字编程。</p> 
<p>套接字有3种类型：</p> 
<ul><li><strong>流式</strong>套接字，即TCP套接字，用<code>SOCK_STREAM</code>表示</li><li><strong>数据报</strong>套接字，即UDP套接字（或称无连接套接字），用<code>SOCK_DGRAM</code>表示</li><li><strong>原始</strong>套接字，用<code>SOCK_RAM</code>表示</li></ul> 
<p>套接字地址结构由<strong>网络地址</strong>和<strong>端口号</strong>组成。</p> 
<h4><a id="_14"></a>传输方式</h4> 
<p><strong>（1）TCP</strong></p> 
<p>TCP是一个<strong>面向连接的</strong>传输层协议，在数据发送之前（即进程通信之前)，必须先建立连接。通信完毕后，必须关闭连接。基于TCP传输协议的服务器与客户机间的通信工作流程如下图：</p> 
<p><img src="https://images2.imgbox.com/06/ca/K9Pmjcmz_o.png" alt="在这里插入图片描述"></p> 
<p>大致流程如下：</p> 
<ol><li><strong>服务器先用<code>socket()</code>函数来建立一个套接字</strong>，用这个套接字完成通信的监听及数据的收发。</li><li>服务器用<code>bind()</code>函数来<strong>绑定一个端口号和IP地址</strong>，使套接字与指定的端口号和IP地址相关联。</li><li>服务器调用<code>listen()</code>函数，使服务器的这个端口和IP处于<strong>监听状态，等待网络中某一客户机的连接请求</strong>。</li><li><strong>客户机用<code>socket()</code>函数建立一个套接字，设定远程IP和端口</strong>。</li><li>客户机调用<code>connect()</code>函数<strong>连接远程计算机指定的端口</strong>。</li><li><strong>服务器</strong>调用<code>accept()</code>函数来<strong>接受</strong>远程计算机的<strong>连接请求</strong>，建立起与客户机之间的通信连接。</li><li><strong>建立连接以后，客户机</strong>用<code>write()</code>函数（或<code>close()</code>函数）向socket中写入数据，也可以用<code>read()</code>函数（或<code>recv()</code>函数）读取服务器发来的数据。</li><li><strong>服务器</strong>用<code>read()</code>函数（或<code>recv()</code>函数）读取客户机发来的数据，也可以用<code>write()</code>函数（或<code>send()</code>函数）来发送数据。</li><li>完成通信以后，使用<code>close()</code>函数<strong>关闭socket连接</strong>。</li></ol> 
<p><strong>（2）UDP</strong></p> 
<p>不同于TCP协议，UDP是一个<strong>无连接的、不可靠服务的</strong>传输层协议，它不对数据进行确认、出错重传和排序等可靠性处理，但它却是具有<strong>代码小、实现简单那、速度快和系统开销小</strong>等优点。对于某些应用，使用UDP将带来更高的效率，如域名服务系统DNS、网络文件系统NFS等。</p> 
<p>基于UDP传输协议的服务器与客户机间的通信工作流程如下图：</p> 
<p><img src="https://images2.imgbox.com/2a/32/HgKRsEuV_o.png" alt="在这里插入图片描述"></p> 
<p>对比TCP套接字通信流程，区别在于：</p> 
<ul><li>使用TCP套接字必须先建立连接（如客户机进程的<code>connect()</code>，服务器进程的<code>listen()</code>和<code>accept()</code>）</li></ul> 
<p>而UDP套接字<strong>不需要先建立连接</strong>，它在调用<code>socket()</code>生成一个套接字后，在<strong>服务器端</strong>调用<code>bind()</code>绑定一个端口，然后服务器进程挂起于<code>recvfrom()</code>调用，等待并接收网络中某一客户机的数据请求。而<strong>客户端</strong>调用<code>sendto()</code>发送数据请求，同样也挂起于<code>recvfrom()</code>调用，等待并接收服务器的应答信号。</p> 
<ul><li>当数据传输完毕后，UDP套接字中的客户端调用<code>close()</code>释放通信链路，但<strong>不再发送“断开连接通知”信息</strong>来通知服务器端释放通信链路。</li></ul> 
<h4><a id="_56"></a>创建时机</h4> 
<p>每一个来自客户端的TCP请求在服务器端都会对应一个 socket。事实上，这个新 socket 的创建实机既不是在 listen 的时候，也不是在 accept 的时候，而是在三次握手成功之后创建的，然后放在对应的全连接队列中。</p> 
<p><img src="https://images2.imgbox.com/4e/54/xRBCCxH6_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，如果服务器超时还未收到 ACK 会进行 SYN+ACK 的重传，重传的次数由 tcp_synack_retries 值确定，在 CentOS 上这个值等于 5。服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 全连接 队列，等待进程调用 accept 函数时把连接取出来。</strong></p> 
</blockquote> 
<p>accept会阻塞直到3次握手成功为止，也就是说accept发生在三次握手之后(没有accept 3次握手照样成功)。</p> 
<p>服务器在 listen 状态的时候可以接收来自客户端的握手请求。当客户端发出的第三次 ack 到达时，服务器创建了新的 sock 对象（socket 的核心），然后加入到了全连接队列中。然后accept的时候，仅仅只是从全连接队列里把 sock 取出来而已。</p> 
<h4><a id="_71"></a>套接字描述符</h4> 
<p><strong>套接字描述符</strong>是一个整数类型的值，就如程序通过文件描述符访问文件一样，套接字描述符是访问套接字的一种路径。每个进程的进程空间里都有一个<strong>套接字描述符</strong>表(每个进程维护一个单独的套接字描述符表。因此，应用程序可以拥有相同的套接字描述符)，该表中存放着<strong>套接字描述符</strong>和套接字数据结构的对应关系。该表中有一个字段存放新创建的套接字的描述符，另一个字段存放套接字数据结构的地址，因此根据<strong>套接字描述符</strong>就可以找到其对应的套接字数据结构。每个进程在自己的进程空间里都有一个<strong>套接字描述符</strong>表但是套接字数据结构都是在操作系统的内核缓冲里。</p> 
<p><strong>从某种意义上说，套接字也是文件，所以许多对文件描述符使用的函数，对套接字描述符同样适用。每个 socket 被创建后，都会分配两个缓冲区，输入缓冲区和输出缓冲区。</strong></p> 
<blockquote> 
 <p>在redis中，当下次这个client端往Redis服务器发送数据的时候，数据就会被内核拷贝到这个socket的输入缓冲区，然后aeEvent模块监听到这个事件就会调用readQueryFromClient函数。</p> 
</blockquote> 
<ul><li>write()/send() 并不立即向网络中传输数据，而是先将数据写入缓冲区中，再写入协议栈，即由TCP协议将数据从缓冲区发送到目标机器。一旦将数据写入到缓冲区，函数就可以成功返回，不管它们有没有到达目标机器，也不管它们何时被发送到网络，这些都是TCP协议负责的事情。</li><li>read()/recv() 函数也是如此，也从输入缓冲区中读取数据，而不是直接从网络中读取。</li></ul> 
<h4><a id="_84"></a>套接字端口</h4> 
<p>有一个问题：比如我的程序开了一个监听端口，与客户端建立连接之后，生成了一个新套接字。这时我执行了只关闭监听端口的语句，结果却发现监听端口和已建立的连接仍然存在。我都已经关闭了监听套接字，为什么客户端还可以继续往监听端口发信息？这到底是因为什么呢？新套接字和监听套接字有什么关系呢？</p> 
<p>监听套接字就是个牵线指路的，你实质上是跟它指的那个人说话。因为你要找的那个人不可能随时等你来，而监听套接字就是专职等你来问，它回答你要找的人在哪，并唤醒你要找的人，于是通话就建立起来了，就像现实生活中的接线员一样。</p> 
<p>也就是说，<strong>在连接建立后，客户端用发出连接的那个SOCKET向服务器发数据，是发给服务器新创建的SOCKET，而不是服务器的监听SOCKET。服务器的监听SOCKET永远只是用来接受连接请求。</strong></p> 
<p>而<strong>新创建的SOCKET的端口其实和监听SOCKET是一样的</strong>。一般来说一个应用使用一个端口，但是一个应用一般采用一进程多线程，所以各连接套接字的端口是相同的，哪怕是多进程并行应该也是相同的。可以理解为在程序与程序间不能用同一端口，但是在程序内部不同的Socket还是可以用同一端口的。</p> 
<blockquote> 
 <p>如果是随机使用一个新的端口，是一定会被防火墙拦截的。</p> 
</blockquote> 
<p><strong>对于tcp，服务器的连接套接字靠四元组唯一标识（本端同，对端不同），监听套接字因为有且只有一个所以靠二元组唯一标识（仅本端），客户端的套接字靠四元组唯一标识（本端不同，对端同），之所以本机收到信息后，能将信息分配到正确的套接字，是通过判断源IP地址和源端口号，如果没有找到匹配源IP地址和源端口号的连接套接字，就把该信息交给监听套接字；对于udp，发送方发过去就完事了，接收方接受一下就完事了，不存在来回来回来回的反复通信，某方的套接字只为本地的那一方负责（收/发那么一下），所以两端都靠二元组唯一标识即可（仅本端）</strong>（强调一下“唯一标识套接字”指的是在某一台主机的4和4.5层的多路复用/多路分解时不混淆地区分、标识不同套接字实例）；但是对于某次udp/tcp通信的流向，一定都是四元组，不能把它和套接字混淆。</p> 
<p>另外，接收端的应用进程和端口可以是一对一、一对多、多对一的关系，即一个进程可以同时监听多个端口，或多个进程的端口复用。所以，进程和端口并不是像之前想的一定一一对应，端口不同的udp/tcp套接字一定会上交给不同的进程（如80、21，因为协议/服务是不同的则进程一定不同），但端口相同的udp/tcp套接字也可能上交给不同的进程（多进程）、相同进程的不同线程（多线程）。</p> 
<h4><a id="_104"></a>相关函数</h4> 
<p>Socket 网络模型的非阻塞模式设置，主要体现在三个关键的函数调用上，如果想要使用 socket 非阻塞模式，就必须要了解这三个函数的调用返回类型和设置模式。</p> 
<p>在 socket 模型中，不同操作调用后会返回不同的套接字类型。socket() 方法会返回主动套接字，然后调用 listen() 方法，<strong>将主动套接字转化为监听套接字</strong>，此时，可以监听来自客户端的连接请求。最后，调<strong>用 accept() 方法接收到达的客户端连接，并返回已连接套接字</strong>。</p> 
<p><img src="https://images2.imgbox.com/4a/14/N0RK2vt8_o.png" alt=""></p> 
<p>针对监听套接字，我们可以设置非阻塞模式：当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。但是，你要注意的是，调用 accept() 时，已经存在监听套接字了。</p> 
<p>相关函数：</p> 
<ul><li> <p>int <strong>socket</strong>(int domain,int type,int protocol)</p> <p>domain(协议族)：常用的协议族便是IPV4(PF_INET), IPV6(PF_INET6),本地通信协议的UNIX族(PF_LOCAL)；<br> type：数据传输类型；典型数据传输类型：SOCK_DGRAM(数据报套接字/无连接的套接字),SOCK_RAW,SOCK_SEQPACKET,SOCK_STREAM(流格式套接字/面向连接的套接字)；<br> protocal：具体协议，通常为0，表示按给定的域或套接字类型选择默认协议。当对同一域和套接字类型支持多个协议时，可以使用protocol参数选择一个特定协议，常用的有 IPPROTO_TCP 和 IPPTOTO_UDP，分别表示 TCP 传输协议和 UDP 传输协议。</p> <p>作用：socket() 函数用来创建套接字，返回值就是一个 int 类型的文件描述符。</p> </li><li> <p>int <strong>bind</strong>(int sock, struct sockaddr *addr, socklen_t addrlen)</p> <p>int <strong>connect</strong>(int sock, struct sockaddr *serv_addr, socklen_t addrlen)</p> <p>sock 为 socket 文件描述符，addr 为 sockaddr 结构体变量的指针，addrlen 为 addr 变量的大小，可由 sizeof() 计算得出。</p> <p>作用：服务端用 bind() 函数将套接字与特定的 IP 地址和端口绑定起来，只有这样，流经该 IP 地址和端口的数据才能交给套接字处理。类似地，客户端也要用 connect() 函数建立连接。</p> </li><li> <p>int <strong>listen</strong>(int sock, int backlog)</p> <p>sock 为需要进入监听状态的套接字，backlog 为请求队列的最大长度。</p> <p>请求队列：当套接字正在处理客户端请求时，如果有新的请求进来，套接字是没法处理的，只能把它放进缓冲区，待当前请求处理完毕后，再从缓冲区中读取出来处理。如果不断有新的请求进来，它们就按照先后顺序在缓冲区中排队，直到缓冲区满。这个缓冲区，就称为请求队列（Request Queue）。如果将 backlog 的值设置为 SOMAXCONN，就由系统来决定请求队列长度，这个值一般比较大，可能是几百，或者更多。当请求队列满时，就不再接收新的请求，对于 Linux，客户端会收到 ECONNREFUSED 错误，对于 Windows，客户端会收到 WSAECONNREFUSED 错误。</p> <p>作用：对于服务器端程序，使用 bind() 绑定套接字后，还需要使用 listen() 函数让套接字进入被动监听状态。所谓被动监听，是指当没有客户端请求时，套接字处于“睡眠”状态，只有当接收到客户端请求时，套接字才会被“唤醒”来响应请求。</p> </li><li> <p>int <strong>accept</strong>(int sock, struct sockaddr *addr, socklen_t *addrlen)</p> <p>sock 为服务器端套接字，addr 为 sockaddr_in 结构体变量，addrlen 为参数 addr 的长度，可由 sizeof() 求得。</p> <p>作用：accept() 返回一个新的套接字来和客户端通信，addr 保存了客户端的IP地址和端口号，而 sock 是服务器端的套接字，要注意区分。后面和客户端通信时，要使用这个新生成的套接字，而不是原来服务器端的套接字。</p> </li><li> <p>1）linux下数据的接收发送：</p> <p>ssize_t <strong>read</strong>(int fd, void *buf, size_t nbytes)</p> <p>ssize_t <strong>write</strong>(int fd, const void *buf, size_t nbytes)</p> <p>fd 为要读取/写入的文件的描述符，buf 为要读取/写入的数据的缓冲区地址，nbytes 为要读取/写入的数据的字节数。</p> <p>作用：read() 函数会从 fd 文件中读取 nbytes 个字节并保存到缓冲区 buf，成功则返回读取到的字节数（但遇到文件结尾则返回0），失败则返回 -1；write() 函数会将缓冲区 buf 中的 nbytes 个字节写入文件 fd，成功则返回写入的字节数，失败则返回 -1。</p> <p>2）win下数据的接收发送：</p> <p>int <strong>recv</strong>(SOCKET sock, char *buf, int len, int flags)</p> <p>int <strong>send</strong>(SOCKET sock, const char *buf, int len, int flags)</p> <p>sock 为要接收/发送数据的套接字，buf 为要接收/发送的数据的缓冲区地址，len 为要接收/发送的数据的字节数，flags 为发送数据时的选项，一般设置为 0 或 NULL。</p> </li><li> <p>int <strong>shutdown</strong>(int socketfd,int how)</p> <p>关闭sockfd指向的套接字的how。其中how的取值可以为：SHUT_RD,SHUT_WR,SHUT_RDWR。</p> <p>与close的区别：close是关闭一个指向文件的文件描述符，其实只是关闭了这个文件描述符对文件表的指针。如果该文件仍有其他文件描 述符引用的话，该文件的V节点表并没有关闭。只有当关闭的文件描述符是最后一个指向文件的文件描述符，V节点才能也被关闭；而shutdown是关闭对一文件的读写等属性，不问有多少个文件描述符对该文件引用。</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6d348f92b3fa7e3987af9d2a686a5d9b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【独立后台】快递小程序便宜寄快递系统小程序 对接易达</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b2712578abc1b90772b29fa09d85543d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JavaEE——作业管理系统</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>