<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>轻松搞懂Java类加载与SPI机制 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="轻松搞懂Java类加载与SPI机制" />
<meta property="og:description" content="你知道Java的类加载机制吗？你了解双亲委派模型吗？你知道怎么打破双亲委派模型吗？这些都是面试经常出现的问题，今天我带大家从类加载机制出发，帮助大家快速掌握Java的SPI机制与Spring的SPI机制。
1.Java类加载机制 java的类加载如图，大概分为以下阶段：
1.1加载：加载.class文件进入内存，以双亲委派模式
1.2.验证：验证文件的正确性、合法性，确保.class文件格式的正确
1.3准备：将类变量分配内存，赋予初值(注意，初值是临时值，比如boolean类型变量会统一赋予false,int变量会统一赋予0)
1.4解析：符号引用替换成直接引用，什么意思呢，如果你一个类里面有引用另一个类。.class文件使用字符来去引用描述，在这个阶段会替换直接指向实际的物理内存地址。
1.5将初值替换为程序指定的值，初值只是赋予的临时值，这个阶段会变成你程序设置的实际数值。
初始化后，类方法执行顺序：
父类静态方法 -&gt; 子类的静态方法 -&gt;父类的非静态方法 -&gt;父类的构造方法 -&gt;子类的非静态方法 -&gt;子类的构造方法。
2.双亲委派模式 上面提到，在加载阶段，会用双亲委派模式去加载.class文件。那么什么是双亲委派呢
当一个类加载器收到一个加载请求，它不会自己加载，它会委托父类加载器进行加载。如果父类加载器上面还有父类，它会继续向上委托，一直到顶部加载器。如果父类加载器能够进行加载，会直接加载任务返回，否则子类加载器才会自己尝试加载。
3.双亲委派模式怎么打破 3.1 继承ClassLoader，重写findClass方法 public class ClassLoaderTest extends ClassLoader{ @Override protected Class&lt;?&gt; findClass(String name) { //读取.class数据 String fileName=&#34;xxx/&#34;&#43;name.replace(&#34;.&#34;,&#34;/&#34;)&#43;&#34;.class&#34;; byte[] classData =null; try (InputStream fileInputStream = new FileInputStream(fileName)) { classData=new byte[fileInputStream.available()]; fileInputStream.read(classData); } catch (Exception e) { e.printStackTrace(); return null; } //定义类返回类对象，ClassLoader自带方法 return defineClass(fileName,classData,0,classData.length); } } 3.2 Java的SPI机制 Java的一种机制，在ClassPath路径下的META-INF/services定义文件，就会自动加载文件里所定义的类。最典型的就是jdbc的SPI机制。因为有Oracle,mysql等等各种第三方数据库，Java源码不可能把所有数据库厂商都对接一遍，所以使用SPI机制，让数据库厂商自己去实现对应的逻辑。mysql-connector.jar就是这么实现的
4.Spring SPI机制 Spring框架在实现时，无疑也采用了Java的设计。只要找到Spring-boot-autoConfigure包，照着这个文件复制，修改下，Springboot启动时就会自动加载第三方类。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c9c741af3eba85e50d63b4e5e0ca0751/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-06T21:52:55+08:00" />
<meta property="article:modified_time" content="2023-06-06T21:52:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">轻松搞懂Java类加载与SPI机制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:justify;">        你知道Java的类加载机制吗？你了解双亲委派模型吗？你知道怎么打破双亲委派模型吗？这些都是面试经常出现的问题，今天我带大家从类加载机制出发，帮助大家快速掌握Java的SPI机制与Spring的SPI机制。</p> 
<h4>1.Java类加载机制</h4> 
<p>java的类加载如图，大概分为以下阶段：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/12/3d/B6F9QI3S_o.png"></p> 
<p>1.1加载：加载.class文件进入内存，以双亲委派模式</p> 
<p>1.2.验证：验证文件的正确性、合法性，确保.class文件格式的正确</p> 
<p>1.3准备：将类变量分配内存，赋予初值(注意，初值是临时值，比如boolean类型变量会统一赋予false,int变量会统一赋予0)</p> 
<p>1.4解析：符号引用替换成直接引用，什么意思呢，如果你一个类里面有引用另一个类。.class文件使用字符来去引用描述，在这个阶段会替换直接指向实际的物理内存地址。</p> 
<p>1.5将初值替换为程序指定的值，初值只是赋予的临时值，这个阶段会变成你程序设置的实际数值。</p> 
<p>初始化后，类方法执行顺序：</p> 
<p>父类静态方法 -&gt; 子类的静态方法 -&gt;父类的非静态方法 -&gt;父类的构造方法 -&gt;子类的非静态方法 -&gt;子类的构造方法。</p> 
<h4>2.双亲委派模式</h4> 
<p>上面提到，在加载阶段，会用双亲委派模式去加载.class文件。那么什么是双亲委派呢</p> 
<p>当一个类加载器收到一个加载请求，它不会自己加载，它会委托父类加载器进行加载。如果父类加载器上面还有父类，它会继续向上委托，一直到顶部加载器。如果父类加载器能够进行加载，会直接加载任务返回，否则子类加载器才会自己尝试加载。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c9/06/9PA7Hdct_o.png"></p> 
<h4>3.双亲委派模式怎么打破</h4> 
<h4>3.1 继承ClassLoader，重写findClass方法</h4> 
<pre><code class="language-java">public class ClassLoaderTest extends ClassLoader{
    @Override
    protected Class&lt;?&gt; findClass(String name) {

        //读取.class数据
        String fileName="xxx/"+name.replace(".","/")+".class";
        byte[] classData =null;
        try (InputStream fileInputStream = new FileInputStream(fileName)) {
            classData=new byte[fileInputStream.available()];
            fileInputStream.read(classData);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }

        //定义类返回类对象，ClassLoader自带方法
        return defineClass(fileName,classData,0,classData.length);
    }
}</code></pre> 
<h4>3.2 Java的SPI机制</h4> 
<p>Java的一种机制，在ClassPath路径下的META-INF/services定义文件，就会自动加载文件里所定义的类。最典型的就是jdbc的SPI机制。因为有Oracle,mysql等等各种第三方数据库，Java源码不可能把所有数据库厂商都对接一遍，所以使用SPI机制，让数据库厂商自己去实现对应的逻辑。mysql-connector.jar就是这么实现的</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1a/a7/RSYbZK3g_o.png"></p> 
<h3>4.Spring SPI机制</h3> 
<p>Spring框架在实现时，无疑也采用了Java的设计。只要找到Spring-boot-autoConfigure包，照着这个文件复制，修改下，Springboot启动时就会自动加载第三方类。</p> 
<p>Spring-boot-autoConfigure的Jar包：</p> 
<p><img alt="" height="493" src="https://images2.imgbox.com/f5/60/PuOhFeTI_o.png" width="1200"></p> 
<p> </p> 
<p>自定义：</p> 
<p><img alt="" height="534" src="https://images2.imgbox.com/97/d1/2ak7hKZk_o.png" width="1200"></p> 
<p> <img alt="" height="702" src="https://images2.imgbox.com/5e/a4/Sj5NMkhP_o.png" width="1111"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4a364b4f60cdccecd5e290cb39b316a9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C&#43;&#43;：【数据结构】trie树</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e587212ea996c21715852263bd9acd7f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Flink】DataStream API使用之输出算子（Sink）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>