<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Qt实现Excel表操作 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Qt实现Excel表操作" />
<meta property="og:description" content="Qt中的QAxObject类可以实现读写excel文件，但是QAxObject在使用时需要系统中安装了offie或wps，这种方法不推荐使用；因为如果安装了wps，可能部分功能用不了；同时安装了office、wps在使用时可能有问题；或者电脑里安装了一些pdf阅读器则直接不能使用了。而QXlsx不依赖于系统环境，使用时打开excel文件将所有数据读入内存，然后就关闭文件了，也不存在文件被占用的情况。
1.源码下载 下载网址：https://gitcode.net/mirrors/QtExcel/QXlsx?utm_source=csdn_github_accelerator使用Git命令下载 git clone git@github.com:QtExcel/QXlsx.git 2.加载QXlsx库 （1）将QXlsx源码文件夹拷贝到创建的Qt工程路径下（也可以是其它路径）
（2）在工程的.pro文件中添加下列代码（注意QXlsx文件夹的路径改成自己的）
include($$PWD/QXlsx/QXlsx.pri) # QXlsx源代码 INCLUDEPATH &#43;= $$PWD/QXlsx 3.创建excel文件 Document xlsx; if(!xlsx.saveAs(&#34;1.xlsx&#34;)){ qDebug()&lt;&lt;&#34;创建失败&#34;; } 4.打开excel文件 Document *m_xlsx; m_xlsx = new Document(&#34;1.xlsx&#34;,this); if(!m_xlsx-&gt;load()){ qDebug()&lt;&lt;&#34;打开失败&#34;; } 5.关闭excel文件 delete m_xlsx; m_xlsx = nullptr; 6.写入excel m_xlsx-&gt;write(&#34;A1&#34;,&#34;1&#34;); m_xlsx-&gt;write(&#34;B1&#34;,&#34;2&#34;); m_xlsx-&gt;write(&#34;C1&#34;,&#34;3&#34;); m_xlsx-&gt;write(&#34;D1&#34;,&#34;4&#34;); m_xlsx-&gt;write(1,2,&#34;xmr1&#34;); m_xlsx-&gt;write(2,2,&#34;xmr1&#34;); m_xlsx-&gt;write(3,2,&#34;xmr1&#34;); m_xlsx-&gt;write(4,2,&#34;xmr1&#34;); m_xlsx-&gt;save(); 7.读取excel int row = m_xlsx-&gt;dimension().rowCount(); int col = m_xlsx-&gt;dimension().columnCount(); for(int i = 0;i &lt; row;i&#43;&#43;){ for(int j = 0;j &lt; col;j&#43;&#43;){ qDebug()&lt;&lt;m_xlsx-&gt;read(i,j)&lt;&lt;m_xlsx-&gt;read(QString(&#34;%1%2&#34;).arg(char(64&#43;i)).arg(j)); } } //另存为 m_xlsx-&gt;saveAs(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5cc04866134e5fb3a6ea893070ce6632/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-04T22:32:36+08:00" />
<meta property="article:modified_time" content="2024-01-04T22:32:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Qt实现Excel表操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        Qt中的QAxObject类可以实现读写excel文件，但是QAxObject在使用时需要系统中安装了offie或wps，这种方法不推荐使用；因为如果安装了wps，可能部分功能用不了；同时安装了office、wps在使用时可能有问题；或者电脑里安装了一些pdf阅读器则直接不能使用了。而QXlsx不依赖于系统环境，使用时打开excel文件将所有数据读入内存，然后就关闭文件了，也不存在文件被占用的情况。</p> 
<h6>1.源码下载</h6> 
<ul><li>下载网址：<a href="https://gitcode.net/mirrors/QtExcel/QXlsx?utm_source=csdn_github_accelerator" rel="nofollow" title="https://gitcode.net/mirrors/QtExcel/QXlsx?utm_source=csdn_github_accelerator">https://gitcode.net/mirrors/QtExcel/QXlsx?utm_source=csdn_github_accelerator</a></li><li>使用Git命令下载 git clone git@github.com:QtExcel/QXlsx.git</li></ul> 
<h6>2.加载QXlsx库</h6> 
<p>（1）将QXlsx源码文件夹拷贝到创建的Qt工程路径下（也可以是其它路径）</p> 
<p>（2）在工程的.pro文件中添加下列代码（注意QXlsx文件夹的路径改成自己的）</p> 
<pre><code class="language-cpp">include($$PWD/QXlsx/QXlsx.pri)             # QXlsx源代码
INCLUDEPATH += $$PWD/QXlsx</code></pre> 
<h6>3.创建excel文件</h6> 
<pre><code class="language-cpp">    Document xlsx;
    if(!xlsx.saveAs("1.xlsx")){
        qDebug()&lt;&lt;"创建失败";
    }</code></pre> 
<h6>4.打开excel文件</h6> 
<pre><code class="language-cpp">    Document *m_xlsx;
    m_xlsx = new Document("1.xlsx",this);
    if(!m_xlsx-&gt;load()){
        qDebug()&lt;&lt;"打开失败";
    }</code></pre> 
<h6>5.关闭excel文件</h6> 
<pre><code class="language-cpp">    delete m_xlsx;
    m_xlsx = nullptr;</code></pre> 
<h6>6.写入excel</h6> 
<pre><code class="language-cpp">    m_xlsx-&gt;write("A1","1");
    m_xlsx-&gt;write("B1","2");
    m_xlsx-&gt;write("C1","3");
    m_xlsx-&gt;write("D1","4");

    m_xlsx-&gt;write(1,2,"xmr1");
    m_xlsx-&gt;write(2,2,"xmr1");
    m_xlsx-&gt;write(3,2,"xmr1");
    m_xlsx-&gt;write(4,2,"xmr1");

    m_xlsx-&gt;save();</code></pre> 
<h6>7.读取excel</h6> 
<pre><code class="language-cpp">    int row = m_xlsx-&gt;dimension().rowCount();
    int col = m_xlsx-&gt;dimension().columnCount();

    for(int i = 0;i &lt; row;i++){
        for(int j = 0;j &lt; col;j++){
            qDebug()&lt;&lt;m_xlsx-&gt;read(i,j)&lt;&lt;m_xlsx-&gt;read(QString("%1%2").arg(char(64+i)).arg(j));
        }
    }
    
    //另存为
    m_xlsx-&gt;saveAs("2.excel");</code></pre> 
<h6>8.查询所有的工作表</h6> 
<pre><code class="language-cpp">QStringList list = m_xlsx-&gt;sheetNames();</code></pre> 
<h6>9.在指定位置插入工作表，可设置工作表名称和类型</h6> 
<pre><code class="language-cpp">    //enum SheetType { ST_WorkSheet, ST_ChartSheet, ST_DialogSheet, ST_MacroSheet };
    QString sheet_name = "sheet2";
    AbstractSheet::SheetType type = AbstractSheet::ST_WorkSheet;
    int index = 1;
    m_xlsx-&gt;insertSheet(index,sheet_name,type);
    m_xlsx-&gt;save();</code></pre> 
<h6>10.重命名工作表</h6> 
<pre><code class="language-cpp">m_xlsx-&gt;renameSheet("sheet2","xmr"); 
m_xlsx-&gt;save();</code></pre> 
<h6>11.将指定的strName工作表拷贝为strNewName，如果strNewName已存在则拷贝失败</h6> 
<pre><code class="language-cpp">m_xlsx-&gt;copySheet("strName","strNewName"); 
m_xlsx-&gt;save();</code></pre> 
<h6>12.移动工作表</h6> 
<p>根据输入的工作表名称，将工作表移动到指定位置，如果工作表不存在或移动到当前位置则失败，移动位置从0开始，如果大于sheet总数则移动到最后位置，如果小于0则移动到最开始位置</p> 
<pre><code class="language-cpp">m_xlsx-&gt;moveSheet("xmr2",0); 
m_xlsx-&gt;save();</code></pre> 
<h6>13.删除工作表</h6> 
<pre><code class="language-cpp">m_xlsx-&gt;deleteSheet("xmr"); 
m_xlsx-&gt;save();</code></pre> 
<h6>14.查询工作表隐藏或可见状态</h6> 
<pre><code class="language-cpp">//enum SheetState { SS_Visible,SS_Hidden, SS_VeryHidden };

Document xlsx(EXCEL_NAME);
AbstractSheet* sheet = xlsx.sheet(sheet_name);   // 根据名称获取工作表指针
int state = sheet-&gt;sheetState();</code></pre> 
<h6>15.设置工作表隐藏或可见状态</h6> 
<pre><code class="language-cpp">//enum SheetState { SS_Visible,SS_Hidden, SS_VeryHidden };

Document xlsx(EXCEL_NAME);
AbstractSheet* sheet = xlsx.sheet(sheet_name);   // 根据名称获取工作表指针
sheet-&gt;setSheetState(AbstractSheet::SheetState(index));             // 修改工作表状态
xlsx.saveAs(EXCEL_NAME);</code></pre> 
<h6>16.工作表中插入图表</h6> 
<p>演示在工作表中插入图表，这里演示了Qxlsx中所有图表类型；从源码中 void ChartPrivate::saveXmlChart(QXmlStreamWriter &amp;writer) const函数看，部分ChartType类型还不支持，如CT_StockChart</p> 
<pre><code class="language-cpp">    Document xlsx;                    // 创建一个Excel对象（默认有一个Sheet1）
    for(int i = 1; i &lt; 10; i++)
    {
        xlsx.write(i, 1, i * i * i);    // 在第一列写入9个数据
        xlsx.write(i, 2, i * i);       // 在第二列写入9个数据
        xlsx.write(i, 3, i *i - 1);    // 写入第三列数据
    }
    qDebug() &lt;&lt; CellReference(1, 2).toString();                    // 可将行列号转换为【字符串】单元格引用

    // 插入面积图
    xlsx.write(3, 4, "CT_AreaChart");  // 在图标左上角单元格中写入图标的类型
    Chart* areaChart = xlsx.insertChart(3, 3, QSize(300, 300));
    areaChart-&gt;setChartType(Chart::CT_AreaChart);
    areaChart-&gt;addSeries(CellRange("A1:C9"));

    // 插入3D面积图（在WPS中显示存在问题，office没有测试）
    xlsx.write(3, 10, "CT_Area3DChart");
    Chart *area3DChart = xlsx.insertChart(3, 9, QSize(300, 300));
    area3DChart-&gt;setChartType(Chart::CT_Area3DChart);
    area3DChart-&gt;addSeries(CellRange("A1:C9"));

    // 插入折线图
    xlsx.write(3, 16, "CT_LineChart");
    Chart* lineChart = xlsx.insertChart(3, 15, QSize(300, 300));
    lineChart-&gt;setChartType(Chart::CT_LineChart);
    lineChart-&gt;addSeries(CellRange("A1:C9"));

    // 插入3D折线图
    xlsx.write(23, 4, "CT_Line3DChart");
    Chart* line3DChart = xlsx.insertChart(23, 3, QSize(300, 300));
    line3DChart-&gt;setChartType(Chart::CT_Line3DChart);
    line3DChart-&gt;addSeries(CellRange("A1:C9"));

    // 插入股价图（貌似还不支持）
    xlsx.write(23, 10, "CT_StockChart");
    Chart* stockChart = xlsx.insertChart(23, 9, QSize(300, 300));
    stockChart-&gt;setChartType(Chart::CT_StockChart);
    stockChart-&gt;addSeries(CellRange("A1:C9"));

    // 插入雷达图（貌似还不支持）
    xlsx.write(23, 16, "CT_RadarChart");
    Chart* radarChart = xlsx.insertChart(23, 15, QSize(300, 300));
    radarChart-&gt;setChartType(Chart::CT_RadarChart);
    radarChart-&gt;addSeries(CellRange("A1:A9"));

    // 插入散点图（在WPS中效果和CT_LineChart一样）
    xlsx.write(43, 4, "CT_ScatterChart");
    Chart* scatterChart = xlsx.insertChart(43, 3, QSize(300, 300));
    scatterChart-&gt;setChartType(Chart::CT_ScatterChart);
    scatterChart-&gt;addSeries(CellRange("A1:A9"));             // 插入三个数据系列
    scatterChart-&gt;addSeries(CellRange("B1:B9"));
    scatterChart-&gt;addSeries(CellRange("C1:C9"));
    // 散点图不能以A1:C9这种方式同时选择三列数据，在WPS中会默认把第一列数据当做X轴数据，QXlsx中会直接舍弃掉第一列数据，
    // 由addSeries函数中if (d-&gt;chartType == CT_ScatterChart || d-&gt;chartType == CT_BubbleChart)可看出
//    scatterChart-&gt;addSeries(CellRange("A1:C9"));

    // 插入饼图
    xlsx.write(43, 10, "CT_PieChart");
    Chart* pieChart = xlsx.insertChart(43, 9, QSize(300, 300));    // 在第三行、三列的单元格右下角位置插入一个长宽为300的图表
    pieChart-&gt;setChartType(Chart::CT_PieChart);                    // 指定图表类型为【饼图】（支持16种类型图表）
    pieChart-&gt;addSeries(CellRange("A1:A9"));                       // 添加饼图的数据系列1（单元格引用字符串方式指定【第一列数据】）
    pieChart-&gt;addSeries(CellRange(CellReference(1, 2), CellReference(9, 2))); // 添加饼图数据2（通过CellReference指定【第二列数据】）
    pieChart-&gt;addSeries(CellRange(1, 3, 9, 3));                    // 添加饼图数据系列3（通过[开始行列号]和[结束行列号]指定【第三列数据】）

    // 插入3D饼图（这个图表在WPS中样式和CT_PieChart一样，没有表现出3D效果，无法设置三维旋转）
    xlsx.write(43, 16, "CT_Pie3DChart");
    Chart* pie3DChart = xlsx.insertChart(43, 15, QSize(300, 300));
    pie3DChart-&gt;setChartType(Chart::CT_Pie3DChart);
    pie3DChart-&gt;addSeries(CellRange("A1:A9"));

    // 插入圆环图
    xlsx.write(63, 4, "CT_DoughnutChart");
    Chart* doughnutChart = xlsx.insertChart(63, 3, QSize(300, 300));
    doughnutChart-&gt;setChartType(Chart::CT_DoughnutChart);
    doughnutChart-&gt;addSeries(CellRange("A1:A9"));

    // 插入柱状图
    xlsx.write(63, 10, "CT_BarChart");
    Chart* barChart = xlsx.insertChart(63, 9, QSize(300, 300));
    barChart-&gt;setChartType(Chart::CT_BarChart);
    barChart-&gt;addSeries(CellRange("A1:A9"));

    // 插入3D柱状图（在WPS中显示异常，不支持3D柱状图）
    xlsx.write(63, 16, "CT_Bar3DChart");
    Chart* bar3DChart = xlsx.insertChart(63, 15, QSize(300, 300));
    bar3DChart-&gt;setChartType(Chart::CT_Bar3DChart);
    bar3DChart-&gt;addSeries(CellRange("A1:A9"));

    // 插入饼图（还不支持）
    xlsx.write(83, 4, "CT_OfPieChart");
    Chart* ofPieChart = xlsx.insertChart(83, 3, QSize(300, 300));
    ofPieChart-&gt;setChartType(Chart::CT_OfPieChart);
    ofPieChart-&gt;addSeries(CellRange("A1:A9"));

    // 插入曲面图（还不支持）
    xlsx.write(83, 10, "CT_SurfaceChart");
    Chart* surfaceChart = xlsx.insertChart(83, 9, QSize(300, 300));
    surfaceChart-&gt;setChartType(Chart::CT_SurfaceChart);
    surfaceChart-&gt;addSeries(CellRange("A1:A9"));

    // 插入3D曲面图（还不支持）
    xlsx.write(83, 16, "CT_Surface3DChart");
    Chart* surface3DChart = xlsx.insertChart(83, 15, QSize(300, 300));
    surface3DChart-&gt;setChartType(Chart::CT_Surface3DChart);
    surface3DChart-&gt;addSeries(CellRange("A1:A9"));

    // 插入气泡图（还不支持）
    xlsx.write(103, 4, "CT_BubbleChart");
    Chart* bubbleChart = xlsx.insertChart(103, 3, QSize(300, 300));
    bubbleChart-&gt;setChartType(Chart::CT_BubbleChart);
    bubbleChart-&gt;addSeries(CellRange("A1:A9"));
    
    xlsx.saveAs(EXCEL_NAME);</code></pre> 
<h6>17.插入图表Sheet，并绘制一个柱状图</h6> 
<pre><code class="language-cpp">    Document xlsx;
    for(int i = 1; i &lt; 10; i++)
    {
        xlsx.write(i, 1, i * i);         // 在Sheet1中写入1列数据
    }

    xlsx.addSheet("Chart1", AbstractSheet::ST_ChartSheet);               // 插入一个名称为【Chart1】，类型为【图表】的Sheet
    Chartsheet* sheet = static_cast&lt;Chartsheet*&gt;(xlsx.currentSheet());   // 获取当前工作表，并将类型转换为Chartsheet*
    Chart* barChart = sheet-&gt;chart();           // 图表Sheet中会默认内置一个Chart，从这一步开始就和正常操作图表一样了
    barChart-&gt;setChartType(Chart::CT_BarChart); // 设置图表类型位柱状图
    barChart-&gt;addSeries(CellRange("A1:A9"), xlsx.sheet("Sheet1")); // 添加数据系列，数据位于Sheet1中的A1-A9

    xlsx.saveAs(EXCEL_NAME);</code></pre> 
<h6>18.设置图表样式</h6> 
<blockquote> 
 <p>（1）设置【图例】位置；</p> 
 <p>（2）设置图表【标题】；</p> 
 <p>（3）打开图表网格线；</p> 
 <p>（4）行列交换标头；</p> 
 <p>（5）设置插入的数据范围是否包含标题；</p> 
 <p>（6）插入图表，引用其它工作表数据。</p> 
</blockquote> 
<pre><code class="language-cpp">    Document xlsx;

    for(int i = 1; i &lt; 10; i++)
    {
        xlsx.write(1, i + 1, QString("Pos %1").arg(i));      // 写入列标题
        xlsx.write(2, i + 1, i * i * i);                     // 写入数据
        xlsx.write(3, i + 1, i * i);
    }
    // 写入行标题
    xlsx.write(2, 1, "Set 1");
    xlsx.write(3, 1, "Set 2");

    // 插入一个柱状图，并设置图例在【右边】
    xlsx.write(5, 4, "图例在右边");
    Chart* barChart1 = xlsx.insertChart(5, 3, QSize(300, 300));  // 插入图表
    barChart1-&gt;setChartType(Chart::CT_BarChart);
    barChart1-&gt;setChartLegend(Chart::Right);     // 设置图例在右边，可设置None：无图例, Left：左边, Right：右边， Top：上边, Bottom：下边
    barChart1-&gt;setChartTitle("Test1");
    barChart1-&gt;addSeries(CellRange(1, 1, 3, 10), nullptr, true, true, false);

    // 插入一个柱状图，启动【主网格线】
    xlsx.write(5, 10, "图例在左边，启动主网格线");
    Chart* barChart2 = xlsx.insertChart(5, 9, QSize(300, 300));  // 插入图表
    barChart2-&gt;setChartType(Chart::CT_BarChart);
    barChart2-&gt;setChartLegend(Chart::Left);
    barChart2-&gt;setChartTitle("Test2");
    barChart2-&gt;setGridlinesEnable(true);   // 启动主网格线
    barChart2-&gt;addSeries(CellRange(1, 1, 3, 10), nullptr, true, true, false);

    // 插入一个柱状图，启动【次网格线】
    xlsx.write(5, 16, "图例在上边，启动次网格线");
    Chart* barChart3 = xlsx.insertChart(5, 15, QSize(300, 300));  // 插入图表
    barChart3-&gt;setChartType(Chart::CT_BarChart);
    barChart3-&gt;setChartLegend(Chart::Top);
    barChart3-&gt;setChartTitle("Test3");
    barChart3-&gt;setGridlinesEnable(false, true);  // 关闭主网格线，启动子网格线
    barChart3-&gt;addSeries(CellRange(1, 1, 3, 10), nullptr, true, true, false);

    // 插入一个柱状图，【行列交换标头】
    xlsx.write(25, 4, "图例在下边，行列交换标头");
    Chart* barChart4 = xlsx.insertChart(25, 3, QSize(300, 300));  // 插入图表
    barChart4-&gt;setChartType(Chart::CT_BarChart);
    barChart4-&gt;setChartLegend(Chart::Bottom);
    barChart4-&gt;setChartTitle("Test4");
    barChart4-&gt;addSeries(CellRange(1, 1, 3, 10), nullptr, false, true, true);  // 参数5【true：以1列为1个数据系列，false：以1行为1个数据系列】

    // 插入一个柱状图，【数据范围不包含标题】
    xlsx.write(25, 10, "数据范围不包含标题");
    Chart* barChart5 = xlsx.insertChart(25, 9, QSize(300, 300));  // 插入图表
    barChart5-&gt;setChartType(Chart::CT_BarChart);
    barChart5-&gt;setChartLegend(Chart::Right);
    barChart5-&gt;setChartTitle("Test5");
    // 参数1：添加数据系列范围；参数2：指定插入的数据位于哪个工作表（Sheet），默认为NULL，即当前工作表；
    // 参数3，数据系列范围第一行是否为列标题，true：为标题；参数4，数据系列范围第1列是否为行标题，true：为标题；默认都不为标题
    // 参数5：交换行列标头。
    barChart5-&gt;addSeries(CellRange(1, 1, 3, 10));

    // 插入一个柱状图，【数据范围包含列标题】
    xlsx.write(25, 16, "数据范围包含列标题");
    Chart* barChart6 = xlsx.insertChart(25, 15, QSize(300, 300));  // 插入图表
    barChart6-&gt;setChartType(Chart::CT_BarChart);
    barChart6-&gt;setChartLegend(Chart::Right);
    barChart6-&gt;setChartTitle("Test6");
    barChart6-&gt;addSeries(CellRange(1, 1, 3, 10), nullptr, true);

    // 插入一个柱状图，【数据范围包含行标题】
    xlsx.write(45, 4, "数据范围包含行标题");
    Chart* barChart7 = xlsx.insertChart(45, 3, QSize(300, 300));  // 插入图表
    barChart7-&gt;setChartType(Chart::CT_BarChart);
    barChart7-&gt;setChartLegend(Chart::Right);
    barChart7-&gt;setChartTitle("Test7");
    barChart7-&gt;addSeries(CellRange(1, 1, 3, 10), nullptr, false, true);

    // 添加一个工作表（Sheet2）,在Sheet2中插入图表，数据为Sheet1中的数据
    xlsx.addSheet("Sheet2");                                     // 添加一个工作表，当前工作表为Sheet2
    xlsx.write(3, 4, "插入图表，引用Sheet1数据");
    Chart* barChart8 = xlsx.insertChart(3, 3, QSize(300, 300));  // 插入图表
    barChart8-&gt;setChartType(Chart::CT_BarChart);
    barChart8-&gt;setChartLegend(Chart::Right);
    barChart8-&gt;setChartTitle("Test8");
    barChart8-&gt;addSeries(CellRange(1, 1, 3, 10), xlsx.sheet("Sheet1"));   // 添加数据系列范围，并指定为Sheet1中的数据

    xlsx.saveAs(EXCEL_NAME);                             // 如果文件已经存在则覆盖</code></pre> 
<h6>19.插入图片</h6> 
<pre><code class="language-cpp">    Document xlsx;
    QImage image1("://image/C++.PNG");
    QImage image2("://image/Qt.PNG");
    qDebug() &lt;&lt; "插入图片："&lt;&lt;xlsx.insertImage(3, 3, image1);  // 在3行3列单元格右下角位置插入图片
    qDebug() &lt;&lt; "插入图片："&lt;&lt;xlsx.insertImage(23, 3, image2);  // 在23行3列单元格右下角位置插入图片
    xlsx.saveAs(EXCEL_NAME);</code></pre> 
<h6>20.打开Excel文件，并查询当前Sheet中图片数量</h6> 
<pre><code class="language-cpp">    Document xlsx(EXCEL_NAME);
    if(!xlsx.load())
    {
        QMessageBox::warning(this, "错误", QString("打开%1失败，可能是文件不存在！").arg(EXCEL_NAME));
        return;
    }

    uint count = xlsx.getImageCount();       // 查询当前Sheet中图片数量
    QMessageBox::about(this, "插入图片数", QString("共有%1张图片！").arg(count));</code></pre> 
<h6>21.读取Excel中的图片（通过索引读取）</h6> 
<p>注意：这里索引从1开始，而不是从0开始（Qxlsx的一些小bug）</p> 
<pre><code class="language-cpp">    Document xlsx(EXCEL_NAME);
    if(!xlsx.load())
    {
        QMessageBox::warning(this, "错误", QString("打开%1失败，可能是文件不存在！").arg(EXCEL_NAME));
        return;
    }

    QImage image;
    bool ret = xlsx.getImage(1, image);       // 读取当前Sheet中第1张图片(注意：索引是从1开始，而不是从0开始)
    if(ret)
    {
        ui-&gt;label-&gt;setPixmap(QPixmap::fromImage(image));   // 显示读取到的图片
    }
    else
    {
        QMessageBox::warning(this, "错误", "读取图片失败，可能是不存在！");
    }</code></pre> 
<h6>22.读取Excel中的图片（通过行列号读取）</h6> 
<pre><code class="language-cpp">    Document xlsx(EXCEL_NAME);
    if(!xlsx.load())
    {
        QMessageBox::warning(this, "错误", QString("打开%1失败，可能是文件不存在！").arg(EXCEL_NAME));
        return;
    }

    QImage image;
    bool ret = xlsx.getImage(23, 3, image);       // 读取当前Sheet中第2张图片
    if(ret)
    {
        ui-&gt;label-&gt;setPixmap(QPixmap::fromImage(image));   // 显示读取到的图片
    }
    else
    {
        QMessageBox::warning(this, "错误", "读取图片失败，可能是不存在或位置错误！");
    }</code></pre> 
<h6>23.设置单元格水平对齐</h6> 
<pre><code class="language-cpp">    Document xlsx(EXCEL_NAME);
    if(!xlsx.load())
    {
        QMessageBox::warning(this, "错误", QString("打开%1失败，可能是文件不存在！").arg(EXCEL_NAME));
        return;
    }

    Format format = xlsx.cellAt(8, 2)-&gt;format();                        // 获取单元格原有格式
    format.setHorizontalAlignment(Format::HorizontalAlignment(index));  // 设置单元格水平对齐格式
    xlsx.write(8, 2, xlsx.read(8, 2), format);                          // 将单元格原有内容、格式写入原来位置

    xlsx.saveAs(EXCEL_NAME);</code></pre> 
<h6>24.设置单元格垂直对齐</h6> 
<pre><code class="language-cpp">    Document xlsx(EXCEL_NAME);
    if(!xlsx.load())
    {
        QMessageBox::warning(this, "错误", QString("打开%1失败，可能是文件不存在！").arg(EXCEL_NAME));
        return;
    }

    Format format = xlsx.cellAt(8, 2)-&gt;format();                        // 获取单元格原有格式
    format.setVerticalAlignment(Format::VerticalAlignment(index));      // 设置单元格垂直对齐格式
    xlsx.write(8, 2, xlsx.read(8, 2), format);                          // 将单元格原有内容、格式写入原来位置

    xlsx.saveAs(EXCEL_NAME);</code></pre> 
<h6>25.合并单元格</h6> 
<pre><code class="language-cpp">    Document xlsx;

    // 在Excel中写入三组数据
    xlsx.write("B3", "hello");
    xlsx.write("C3", "123");
    xlsx.write("B8", 123456);
    xlsx.write("E8", "北风卷地白草折，胡天八月即飞雪");

    xlsx.mergeCells("B3:F6");                  // 可以通过【单元格引用】直接设置单元格合并(注意，有数据的单元格应该时第一个位置)
    xlsx.mergeCells(CellRange(8, 2, 20, 3));   // 通过【行列号】设置单元格合并

    Format format;
    format.setHorizontalAlignment(Format::AlignHCenter);  // 水平居中
    format.setVerticalAlignment(Format::AlignVCenter);    // 垂直居中
    xlsx.mergeCells("E8:F20", format);                    // 在设置单元格合并时可以设置单元格【格式】，如文本居中对齐
    xlsx.saveAs(EXCEL_NAME);</code></pre> 
<h6>26.取消合并单元格</h6> 
<pre><code class="language-cpp">    Document xlsx(EXCEL_NAME);
    if(!xlsx.load())
    {
        QMessageBox::warning(this, "错误", QString("打开%1失败，可能是文件不存在！").arg(EXCEL_NAME));
        return;
    }

    xlsx.unmergeCells("B3:F6");   // 这里取消合并的范围【B3:F6】必须和之前合并单元格的【范围相同】，否则取消合并失败
    xlsx.saveAs(EXCEL_NAME);</code></pre> 
<h6>27.设置字体样式</h6> 
<pre><code class="language-cpp">    Document xlsx;
    xlsx.write(1, 1, "默认样式");

    // 设置字体大小
    Format format;
    format.setFontSize(15);
    xlsx.write(1, 2, "字体大小15", format);
    qDebug() &lt;&lt; xlsx.cellAt(1, 2)-&gt;format().fontSize();  // 获取当前单元格的字体大小

    // 设置字体斜体
    Format format1;
    format1.setFontItalic(true);
    xlsx.write(1, 3, "斜体", format1);
    qDebug() &lt;&lt; xlsx.cellAt(1, 3)-&gt;format().fontItalic();  // 获取当前单元格的字体是否为 斜体

    // 设置字体删除线
    Format format2;
    format2.setFontStrikeOut(true);
    xlsx.write(1, 4, "删除线", format2);
    qDebug() &lt;&lt; xlsx.cellAt(1, 4)-&gt;format().fontStrikeOut();  // 获取当前单元格的字体是否有 删除线

    // 设置字体颜色
    Format format3;
    format3.setFontColor(Qt::red);
    xlsx.write(1, 5, "字体颜色", format3);
    qDebug() &lt;&lt; xlsx.cellAt(1, 5)-&gt;format().fontColor();  // 获取当前单元格的字体颜色

    // 设置字体加粗
    Format format4;
    format4.setFontBold(true);
    xlsx.write(1, 6, "字体加粗", format4);
    qDebug() &lt;&lt; xlsx.cellAt(1, 6)-&gt;format().fontBold();  // 获取当前单元格的字体是否加粗

    // 设置字体特殊格式（上、下标）
    Format format5;
    format5.setFontScript(Format::FontScriptSub);   // 设置下标
    xlsx.write(1, 7, "字体下标", format5);
    format5.setFontScript(Format::FontScriptSuper); // 设置上标
    xlsx.write(1, 8, "字体上标", format5);
    qDebug() &lt;&lt; xlsx.cellAt(1, 7)-&gt;format().fontScript();  // 获取当前单元格的字体的特殊格式

    // 设置下划线
    Format format6;
    format6.setFontUnderline(Format::FontUnderlineNone);
    xlsx.write(1, 9, "无下划线", format6);
    format6.setFontUnderline(Format::FontUnderlineSingle);
    xlsx.write(1, 10, "单下划线", format6);
    format6.setFontUnderline(Format::FontUnderlineDouble);
    xlsx.write(1, 11, "双下划线", format6);
    format6.setFontUnderline(Format::FontUnderlineSingleAccounting);
    xlsx.write(1, 12, "会计用单下划线", format6);
    format6.setFontUnderline(Format::FontUnderlineDoubleAccounting);
    xlsx.write(1, 13, "会计用双下划线", format6);
    qDebug() &lt;&lt; xlsx.cellAt(1, 9)-&gt;format().fontUnderline();  // 获取当前单元格文本下划线格式

    // 设置字体轮廓
    Format format7;
    format7.setFontOutline(true);
    xlsx.write(1, 14, "字体轮廓", format7);
    qDebug() &lt;&lt; xlsx.cellAt(1, 14)-&gt;format().fontOutline();  // 获取当前单元格是否打开字体轮廓

    // 设置字体类型
    Format format8;
    format8.setFontName("黑体");
    xlsx.write(1, 15, "字体类型", format8);
    qDebug() &lt;&lt; xlsx.cellAt(1, 15)-&gt;format().fontName();  // 获取当前单元格字体类型

    xlsx.saveAs(EXCEL_NAME);</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e174ad8cfb3b758fd3b1088e3270122d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于WSN网络的定向步幻影路由算法matlab仿真</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bb64cf5737e45f39bea4aeb081d1ec9c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">node.js安装web3.js</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>