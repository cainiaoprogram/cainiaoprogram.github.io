<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>用C&#43;&#43;实现8皇后问题&#43;代码 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="用C&#43;&#43;实现8皇后问题&#43;代码" />
<meta property="og:description" content="首先感谢B站小姐姐耐心讲解
主要思路： 用二维列表表示摆放皇后后的攻击位置，（即1表示不可放，0表示可放），记为attack。如图 每行放置一个皇后后，更新attack，然后遍历下一行的每列，通过判断该位置是否为0，寻找可放位置（注意要备份attack，以回溯）关于棋盘用一维queen来表示，用“.”表示空，“Q”表示皇后 最后将每种棋盘摆放方法记录 代码： #include&lt;iostream&gt; #include&lt;vector&gt; using namespace std; vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n); void backtrack(int k, int n, vector&lt;string&gt;&amp; queen, vector&lt;vector&lt;int&gt;&gt;&amp; attack, vector&lt;vector&lt;string&gt;&gt;&amp; solve);//k表示下一个需要摆放皇后行位置 void put_queen(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; attack); int main() { vector&lt;vector&lt;string&gt;&gt; res; //保存棋盘摆放情况 res = solveNQueens(8); cout &lt;&lt; &#34;8皇后问题一共有&#34;&lt;&lt;res.size()&lt;&lt;&#34;种情况&#34;&lt;&lt;endl; //展示 cout &lt;&lt; &#34;结果如下：&#34; &lt;&lt; endl; for (int i = 0; i &lt; res.size(); i&#43;&#43;) { cout &lt;&lt; &#34;第&#34; &lt;&lt; i&#43;1 &lt;&lt; &#34;种&#34; &lt;&lt; endl; for (int j = 0; j &lt; res[i]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5ada5d88fa73274f74b4a2ef3ef5b6bb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-02T14:29:13+08:00" />
<meta property="article:modified_time" content="2023-06-02T14:29:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">用C&#43;&#43;实现8皇后问题&#43;代码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>首先感谢B站小姐姐耐心讲解</p> 
<h4>主要思路：</h4> 
<ul><li>用二维列表表示摆放皇后后的攻击位置，（即1表示不可放，0表示可放），记为attack。如图 <p><img src="https://images2.imgbox.com/e9/0e/steRY2zf_o.png" alt="4ca9e01a1e3644c68223a746494c95dd.png"></p> <p><img src="https://images2.imgbox.com/9d/66/iNAsqnWE_o.png" alt="c81557333c7140d1917473a95f161897.png"></p> </li><li>每行放置一个皇后后，更新attack，然后遍历下一行的每列，通过判断该位置是否为0，寻找可放位置（注意要备份attack，以回溯）</li><li>关于棋盘用一维queen来表示，用“.”表示空，“Q”表示皇后</li></ul> 
<p><img src="https://images2.imgbox.com/00/56/9XEIMA25_o.png" alt="49e22789385a45f784ec5c5df7d2c580.png"></p> 
<ul><li> 最后将每种棋盘摆放方法记录</li></ul> 
<h4> 代码：</h4> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;

vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n);
void backtrack(int k, int n, vector&lt;string&gt;&amp; queen, vector&lt;vector&lt;int&gt;&gt;&amp; attack, vector&lt;vector&lt;string&gt;&gt;&amp; solve);//k表示下一个需要摆放皇后行位置
void put_queen(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; attack);

int main() {
	vector&lt;vector&lt;string&gt;&gt; res;  //保存棋盘摆放情况
	res = solveNQueens(8);
	cout &lt;&lt; "8皇后问题一共有"&lt;&lt;res.size()&lt;&lt;"种情况"&lt;&lt;endl;
	//展示
	cout &lt;&lt; "结果如下：" &lt;&lt; endl;
	for (int i = 0; i &lt; res.size(); i++) {
		cout &lt;&lt; "第" &lt;&lt; i+1 &lt;&lt; "种" &lt;&lt; endl;
		for (int j = 0; j &lt; res[i].size(); j++) {
			cout &lt;&lt; res[i][j] &lt;&lt; endl;
		}
	}
	return 0;
}
vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {
	vector&lt;vector&lt;string&gt;&gt; solve; //保存最终结果
	vector&lt;vector&lt;int&gt;&gt; attack;  //保存皇后攻击位置  0表示不攻击；1表示攻击
	vector&lt;string&gt;queen;  //保存皇后位置
	//1.初始化
	for (int i = 0; i &lt; n; i++) {
		attack.push_back(vector&lt;int&gt;());
		for (int j = 0; j &lt; n; j++) {
			attack[i].push_back(0);
		}
		queen.push_back("");
		queen[i].append(n, '.');//结尾添加n个.
	}
	//求
	backtrack(0, n, queen, attack, solve);
	return solve;
}

void backtrack(int k, int n, vector&lt;string&gt;&amp; queen, vector&lt;vector&lt;int&gt;&gt;&amp; attack, vector&lt;vector&lt;string&gt;&gt;&amp; solve)
{
	if (k == n) {
		//找到一组解
		solve.push_back(queen);
		return;
	}
	//
	for (int i = 0; i &lt; n; i++) {  //遍历第k行的每一列，找到可以放皇后的位置
		if (attack[k][i] == 0) {  //找到
			vector&lt;vector&lt;int&gt;&gt; temp = attack;//备份，便于回溯
			queen[k][i] = 'Q'; //皇后位置标记为Q
			put_queen(k, i, attack);//放皇后后，更新attack
			backtrack(k + 1, n, queen, attack, solve);//递归，试探第k+1行能不能放皇后
			attack = temp;//回溯，回复attack，查找其他可能
			queen[k][i] = '.';//取消皇后放置位置
		}
	}
}

void put_queen(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; attack)
{
	//放置皇后后，更新attack
	static const int dx[] = { -1,-1,-1,0,1,1,1,0 };
	static const int dy[] = { -1,0,1,1,1,0,-1,-1 };
	attack[x][y] = -1;
	for (int i = 1; i &lt; attack.size(); i++) {
		for (int j=0;j&lt;8;j++)
		{
			int nx = x + i * dx[j];
			int ny = y + i * dy[j];
			if (nx &gt;= 0 &amp;&amp; nx &lt; attack.size() &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; attack.size()) {
				attack[nx][ny] = -1;
			}
		}
	}
}
</code></pre> 
<p> 运行结果部分截图：</p> 
<p><img src="https://images2.imgbox.com/5d/71/loJgnkix_o.png" alt="95677b11aeea4651bba65522a77d23c2.png"></p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9e50f0207f958cc82f429b48abb4705b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux搭建redis真集群(三主三从)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/794bdf75f7dc96955167b818b8e77af7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android退出应用方法 Exit App</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>