<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>微服务循环依赖调用引发的血案 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="微服务循环依赖调用引发的血案" />
<meta property="og:description" content="程序员的成长之路
互联网/程序员/技术/资料共享 关注
阅读本文大概需要 4 分钟。
来自：juejin.cn/post/7090331001485787149
1.问题表现 最近的迭代转测后，遇到了一个比较有意思的问题。系统在测试环境整体运行还算平稳，但是过一段时间之后，就开始有接口超时了，日志中出现非常多的 “java.net.SocketTimeoutException: Read timed out”。试了几次重启大法，每次都是坚持一会之后，就再次出现 SocketTimeoutException。
注意，在测试环境于遇到问题重启服务，并不是一个好的实践，因为重启可能会让不容易出现的问题现场被破坏。如果问题在测试环境不能再重新，却在发版后出现在生产环境的话，那不仅会造成生产运维事件，还要顶着巨大的压力去解决问题，有过经验的小伙伴一定知道个中滋味。
2.初步分析 顺着测试汇报的出现问题的场景，跟踪调用链上相关服务的日志，发现出现了微服务之间循依赖调用。大致情况可以抽象如下所示（图中所有调用都是 http 协议）：
Client 调用服务 Foo.hello()
Foo.hello() 逻辑中会调用服务 Boo.boo()
Boo.boo() 又调用回服务 Foo 的另外一个方法 another()
当然真实的场景要比较这个复杂，调用链更长，不过最终形成了环形依赖调用。至于这个环形依赖为什么回导致超时，当时想了多种可能，比如数据库慢查询、数据库锁、分布式锁等等。但是整个调用链上都是查询请求，而且查询相关的数据量也非常小，不会出现慢查询。发生问题的时候也没有与查询数据相关的数据库写请求。
鉴于这个环形依赖调用确实是这个迭代版本中引入的变更，虽然没有理清其中的因果关系原理，但是这个环性依赖调用还是很可疑的，而且这个环形调用是可以通过其他方法消除的。就抱着将环形依赖调用去掉试试看的态度，做了修复。修复完后，SocketTimeoutException不再出现了。问题解决了。
3.探寻原因 问题虽然不再出现，但是凭运气解决的问题，通常有可能不是真的的解决。只有弄清楚背后的原理，我们才能真正的确认问题是不是这个原因导致的，这样的修复是不是真的把问题解决了。
通过假设环形调用就是导致调用超时的直接原因。我们看看能不能推出因果关系。通过把Foo 服务容器画的更详细一点，如下图：
通过这个图示，我们可以发现，如果容器中接收请求的线程池如果都在等待服务Boo.boo()的响应，而 Boo 又需要调用回服务 Foo.another()。这个时候，如果所有的线程都处于这样的状态，我们就会发现服务 Foo 容器中以及没有线程来处理 Boo 的请求了。某种程度上来说就是死锁了。
到这里，我们就可以很确定了，这个环形依赖调用就是导致出现调用超时的罪魁祸首。当 client 发起的请求速度大于这个环形调用链的处理速度的时候，慢慢的就会导致服务 Foo 的所有线程都进入这种死锁状态。
4.验证 这里只列出关键的代码，具体的代码可以参考 gitee 工程：
https://gitee.com/donghbcn/CircularDependency
4.1 Eureka 服务器 建个简单工程将Eureka server启动起来。
4.2 服务 Foo 创建 SpringBoot 工程实现 Foo 服务。Foo 通过 FeignClient 调用 Boo 服务。设置缺省的容器 Tomcat 的最大线程数为 16，Tomcat 默认配置最大线程数 200，对于验证这个场景有点了大了，要看到效果需要等的时间有点长。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0ad74403e9b6f7208ccb4f5c784012f8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-19T00:00:03+08:00" />
<meta property="article:modified_time" content="2023-01-19T00:00:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">微服务循环依赖调用引发的血案</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p><img title="0D5F937FE12312312D81F17F.jpg" src="https://images2.imgbox.com/43/7a/9acFBU9W_o.jpg" alt="2514ced46cddc0ad047023a0dfd71eb7.jpeg"></p> 
 <p>程序员的成长之路</p> 
 <p>互联网/程序员/技术/资料共享 </p> 
 <p><a href="" rel="nofollow">关注</a></p> 
 <p>阅读本文大概需要 4 分钟。</p> 
 <p>来自：<em>juejin.cn/post/7090331001485787149</em></p> 
 <h2>1.问题表现</h2> 
 <p style="text-align:justify;">最近的迭代转测后，遇到了一个比较有意思的问题。系统在测试环境整体运行还算平稳，但是过一段时间之后，就开始有接口超时了，日志中出现非常多的 “<code>java.net.SocketTimeoutException: Read timed out</code>”。试了几次重启大法，每次都是坚持一会之后，就再次出现 <code>SocketTimeoutException</code>。</p> 
 <blockquote> 
  <p style="text-align:justify;"><strong>注意</strong>，在测试环境于遇到问题重启服务，并不是一个好的实践，因为重启可能会让不容易出现的问题现场被破坏。如果问题在测试环境不能再重新，却在发版后出现在生产环境的话，那不仅会造成生产运维事件，还要顶着巨大的压力去解决问题，有过经验的小伙伴一定知道个中滋味。</p> 
 </blockquote> 
 <h2>2.初步分析</h2> 
 <p style="text-align:justify;">顺着测试汇报的出现问题的场景，跟踪调用链上相关服务的日志，发现出现了微服务之间循依赖调用。大致情况可以抽象如下所示（图中所有调用都是 http 协议）：</p> 
 <p><img src="https://images2.imgbox.com/5c/21/uX3FSx5L_o.png" alt="fad336ca152e2897702854bf1b111911.png"></p> 
 <ul><li><p style="text-align:justify;">Client 调用服务 <code>Foo.hello()</code></p></li><li><p style="text-align:justify;"><code>Foo.hello()</code> 逻辑中会调用服务 <code>Boo.boo()</code></p></li><li><p style="text-align:justify;"><code>Boo.boo()</code> 又调用回服务 Foo 的另外一个方法 <code>another()</code></p></li></ul> 
 <p style="text-align:justify;">当然真实的场景要比较这个复杂，调用链更长，不过最终形成了环形依赖调用。至于这个环形依赖为什么回导致超时，当时想了多种可能，比如数据库慢查询、数据库锁、分布式锁等等。但是整个调用链上都是查询请求，而且查询相关的数据量也非常小，不会出现慢查询。发生问题的时候也没有与查询数据相关的数据库写请求。</p> 
 <p style="text-align:justify;">鉴于这个环形依赖调用确实是这个迭代版本中引入的变更，虽然没有理清其中的因果关系原理，但是这个环性依赖调用还是很可疑的，而且这个环形调用是可以通过其他方法消除的。就抱着将环形依赖调用去掉试试看的态度，做了修复。修复完后，<code>SocketTimeoutException</code>不再出现了。问题解决了。</p> 
 <h2>3.探寻原因</h2> 
 <p style="text-align:justify;">问题虽然不再出现，但是凭运气解决的问题，通常有可能不是真的的解决。只有弄清楚背后的原理，我们才能真正的确认问题是不是这个原因导致的，这样的修复是不是真的把问题解决了。</p> 
 <p style="text-align:justify;">通过假设环形调用就是导致调用超时的直接原因。我们看看能不能推出因果关系。通过把Foo 服务容器画的更详细一点，如下图：</p> 
 <p><img src="https://images2.imgbox.com/bb/6c/UINiXuRx_o.png" alt="dadc5aaacee8db34d95ebfb3d5866688.png"></p> 
 <p style="text-align:justify;">通过这个图示，我们可以发现，如果容器中接收请求的线程池如果都在等待服务<code>Boo.boo()</code>的响应，而 Boo 又需要调用回服务 <code>Foo.another()</code>。这个时候，如果所有的线程都处于这样的状态，我们就会发现服务 Foo 容器中以及没有线程来处理 Boo 的请求了。某种程度上来说就是死锁了。</p> 
 <p style="text-align:justify;">到这里，我们就可以很确定了，这个环形依赖调用就是导致出现调用超时的罪魁祸首。当 client 发起的请求速度大于这个环形调用链的处理速度的时候，慢慢的就会导致服务 Foo 的所有线程都进入这种死锁状态。</p> 
 <h2>4.验证</h2> 
 <p style="text-align:justify;">这里只列出关键的代码，具体的代码可以参考 gitee 工程：</p> 
 <blockquote> 
  <p style="text-align:justify;">https://gitee.com/donghbcn/CircularDependency</p> 
 </blockquote> 
 <h3>4.1 Eureka 服务器</h3> 
 <p style="text-align:justify;">建个简单工程将Eureka server启动起来。</p> 
 <h3>4.2 服务 Foo</h3> 
 <p style="text-align:justify;">创建 SpringBoot 工程实现 Foo 服务。Foo 通过 FeignClient 调用 Boo 服务。设置缺省的容器 Tomcat 的最大线程数为 16，Tomcat 默认配置最大线程数 200，对于验证这个场景有点了大了，要看到效果需要等的时间有点长。</p> 
 <p style="text-align:justify;">application.properties</p> 
 <pre class="has"><code class="language-go">spring.application.name=demo-foo
server.port=8000
eureka.client.serviceUrl.defaultZone=http://localhost:8080/eureka
server.tomcat.threads.max=16</code></pre> 
 <pre class="has"><code class="language-go">package com.cd.demofoo;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class FooController {
    @Autowired
    BooFeignClient booFeignClient;
    @RequestMapping("/hello")
    public String hello(){
        long start = System.currentTimeMillis();
        System.out.println("[" + Thread.currentThread() +
                "] foo:hello called, call boo:boo now");
        booFeignClient.boo();
        System.out.println("[" + Thread.currentThread() +
                "] foo:hello called, call boo:boo, total cost:" +
                (System.currentTimeMillis() - start));
        return "hello world";
    }

    @RequestMapping("/another")
    public String another(){
        long start = System.currentTimeMillis();
        try {
            //通过 slepp 模拟一个耗时调用
            Thread.sleep(100);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("foo:another called, total cost:" + (System.currentTimeMillis() - start));
        return "another";
    }
}</code></pre> 
 <h3>4.3 服务 Boo</h3> 
 <p style="text-align:justify;">创建 SpringBoot 工程实现 Boo 服务。Boo 通过 FeignClient 调用 Foo 服务。</p> 
 <pre class="has"><code class="language-go">package com.cd.demoboo;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class BooController {

    @Autowired
    FooFeignClient fooFeignClient;

    @RequestMapping("/boo")
    public String boo(){
        long start = System.currentTimeMillis();

        fooFeignClient.another();
        System.out.println("boo:boo called, call foo:another, total cost:" +
                        (System.currentTimeMillis() - start));
        return "boo";
    }
}</code></pre> 
 <h3>4.4 Jmeter</h3> 
 <p style="text-align:justify;">采用 Jmeter 来模拟并发 Client 调用。配置了30 个 线程，无限循环。</p> 
 <p><img src="https://images2.imgbox.com/5b/b6/AFrEQ97H_o.png" alt="300b36c69cf6be8b4033b67f5afc8768.png"></p> 
 <p style="text-align:justify;">很快服务 Foo 日志就卡死了。过一会 Boo 的日志开始出现 <code>SocketTimeoutException</code>，如下图：</p> 
 <p><img src="https://images2.imgbox.com/f4/e9/S5VbeyiP_o.png" alt="8854ce8ea679cf84355798185f1b5f98.png"></p> 
 <h3>4.5 jstack</h3> 
 <p style="text-align:justify;">通过 jstack 我们可以看到 Foo 进程的所有线程都卡在 <code>hello()</code> 调用上了。</p> 
 <p><img src="https://images2.imgbox.com/ea/d8/ZEkYmAYK_o.png" alt="4b6b70c2866a427b753540be5f5ff05f.png"></p> 
 <h2>5.总结</h2> 
 <p style="text-align:justify;">微服务之间的环形依赖类似于类之间的循环依赖，当依赖关系形成了环，会造成比较严重的问题：</p> 
 <ul><li><p style="text-align:justify;">微服务直接不能形成环形调用，否则非常容易出现死锁状态</p></li><li><p style="text-align:justify;">微服务之间的耦合性非常强，这严重违反了微服务的初衷；这种情况往往是服务之间的调用没有约束导致的，为了方便取到或更新数据，服务之间可以随意的调用，以”微服务“为设计目标的系统会逐渐演变成一个<strong>分布式大单体</strong></p></li></ul> 
 <p style="text-align:center;">&lt;END&gt;</p> 
 <p><strong>推荐阅读：</strong><br></p> 
 <p><a href="" rel="nofollow">高端操作，只改了五行代码接口吞吐量提升了10多倍</a><br></p> 
 <p><a href="" rel="nofollow">2万字系统总结，帮你实现 Linux 命令自由</a><br></p> 
 <pre class="has"><code class="language-go">互联网初中高级大厂面试题(9个G)
内容包含Java基础、JavaWeb、MySQL性能优化、JVM、锁、百万并发、消息队列、高性能缓存、反射、Spring全家桶原理、微服务、Zookeeper......等技术栈！
⬇戳阅读原文领取！                                  朕已阅</code></pre> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eaf765ea60ca952063242627f7239675/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python 之数据类型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b04ea34c04e83d18cad908b3cd559fd7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">JavaScript 库之 vanilla-tilt（一个平滑的 3D 倾斜库）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>