<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言定义的数据类型/声明内容的理解(int *p[]与int (*p)[]) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言定义的数据类型/声明内容的理解(int *p[]与int (*p)[])" />
<meta property="og:description" content="前言 本文主要涵盖了以下三部分的内容：
C语言中的运算优先级.
C语言中的声明优先级
C语言下怎么理解声明内容.
本文是一些我自己关于C语言定义的数据类型的理解，希望能解开C语言初学者对于一些较复杂的数据类型（如int *p[] , int (*p)[])等内容的一些疑惑。
一、了解C语言的运算符优先级 如果一个表达式中的两个操作数具有相同的优先级，那么它们的结合律（associativity）决定它们的组合方式是从左到右或是从右到左。
优先级
运算符
结合律
1
后缀运算符：[] () · -&gt; &#43;&#43; --(类型名称){列表}
从左到右
2
一元运算符：&#43;&#43; -- ! ~ &#43; - (正负号) * &amp; sizeof_Alignof
从右到左
3
类型转换运算符：(类型名称)
从右到左
4
乘除法运算符：* / %
从左到右
5
加减法运算符：&#43; -
从左到右
6
移位运算符：&lt;&lt; &gt;&gt;
从左到右
7
关系运算符：&lt;&lt;= &gt;&gt;=
从左到右
8
相等运算符：== !=
从左到右
9
位运算符 AND：&amp;
从左到右
10
位运算符 XOR：^
从左到右
11
位运算符 OR：|" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/730ada1e65442e0a5395656160034698/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-04T10:46:17+08:00" />
<meta property="article:modified_time" content="2023-03-04T10:46:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言定义的数据类型/声明内容的理解(int *p[]与int (*p)[])</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">前言</span></h4> 
 <p style="text-align:null;">本文主要涵盖了以下三部分的内容：</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p><span class="kdocs-color" style="color:#C21C13;">C语言</span>中的运算优先级.</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p><span class="kdocs-color" style="color:#C21C13;">C语言</span>中的声明优先级</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p><span class="kdocs-color" style="color:#C21C13;">C语言</span>下怎么理解声明内容.</p></li></ul> 
 <p style="">本文是一些我自己关于C语言定义的数据类型的理解，希望能解开C语言初学者对于一些较复杂的数据类型（如int *p[] , int (*p)[])等内容的一些疑惑。</p> 
 <h3 style="">一、了解C语言的<span class="kdocs-color" style="color:#0E52D4;">运算符</span>优先级</h3> 
 <p style=""></p> 
 <p style="">如果一个表达式中的两个操作数具有相同的优先级，那么它们的结合律（associativity）决定它们的组合方式是从左到右或是从右到左。</p> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;"><span class="kdocs-bold" style="font-weight:bold;">优先级</span></p></td><td class="kdocs-tableCell" style="width:537px;vertical-align:top;height:52px;"><p style="text-align:center;"><span class="kdocs-bold" style="font-weight:bold;">运算符</span></p></td><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;"><span class="kdocs-bold" style="font-weight:bold;">结合律</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">1</p></td><td class="kdocs-tableCell" style="width:537px;vertical-align:top;height:52px;"><p style=""><span class="kdocs-color" style="color:#C21C13;">后缀运算符：[] () </span> · -&gt; ++ --(类型名称){列表}</p></td><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">从左到右</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">2</p></td><td class="kdocs-tableCell" style="width:537px;vertical-align:top;height:52px;"><p style=""><span class="kdocs-color" style="color:#C21C13;">一元运算符：</span>++ -- ! ~ + - (正负号) <span class="kdocs-color" style="color:#C21C13;"> * </span> &amp; sizeof_Alignof</p></td><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;"><span class="kdocs-color" style="color:#C21C13;">从右到左</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">3</p></td><td class="kdocs-tableCell" style="width:537px;vertical-align:top;height:52px;"><p style="">类型转换运算符：(类型名称)</p></td><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;"><span class="kdocs-color" style="color:#C21C13;">从右到左</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">4</p></td><td class="kdocs-tableCell" style="width:537px;vertical-align:top;height:52px;"><p style="">乘除法运算符：* / %</p></td><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">从左到右</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">5</p></td><td class="kdocs-tableCell" style="width:537px;vertical-align:top;height:52px;"><p style="">加减法运算符：+ -</p></td><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">从左到右</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">6</p></td><td class="kdocs-tableCell" style="width:537px;vertical-align:top;height:52px;"><p style="">移位运算符：&lt;&lt; &gt;&gt;</p></td><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">从左到右</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">7</p></td><td class="kdocs-tableCell" style="width:537px;vertical-align:top;height:52px;"><p style="">关系运算符：&lt;&lt;= &gt;&gt;=</p></td><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">从左到右</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">8</p></td><td class="kdocs-tableCell" style="width:537px;vertical-align:top;height:52px;"><p style="">相等运算符：== !=</p></td><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">从左到右</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">9</p></td><td class="kdocs-tableCell" style="width:537px;vertical-align:top;height:52px;"><p style="">位运算符 AND：&amp;</p></td><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">从左到右</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">10</p></td><td class="kdocs-tableCell" style="width:537px;vertical-align:top;height:52px;"><p style="">位运算符 XOR：^</p></td><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">从左到右</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">11</p></td><td class="kdocs-tableCell" style="width:537px;vertical-align:top;height:52px;"><p style="">位运算符 OR：|</p></td><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">从左到右</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">12</p></td><td class="kdocs-tableCell" style="width:537px;vertical-align:top;height:52px;"><p style="">逻辑运算符 AND：&amp;&amp;</p></td><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">从左到右</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">13</p></td><td class="kdocs-tableCell" style="width:537px;vertical-align:top;height:52px;"><p style="">逻辑运算符 OR：||</p></td><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">从左到右</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">14</p></td><td class="kdocs-tableCell" style="width:537px;vertical-align:top;height:52px;"><p style="">条件运算符：?:</p></td><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;"><span class="kdocs-color" style="color:#C21C13;">从右到左</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:53px;"><p style="text-align:center;">15</p></td><td class="kdocs-tableCell" style="width:537px;vertical-align:middle;height:53px;"><p style="text-align:left;">赋值运算符： = += -= *= /= %= &amp;= ^= |= </p></td><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:53px;"><p style="text-align:center;"><span class="kdocs-color" style="color:#C21C13;">从右到左</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">16</p></td><td class="kdocs-tableCell" style="width:537px;vertical-align:top;height:52px;"><p style="">逗号运算符：，</p></td><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;">从左到右</p></td></tr></tbody></table> 
 </div> 
 <p style="text-align:center;">表1运算符优先级和结合律</p> 
 <p style="text-align:left;">由上表我们可以看到，在运算符优先级中，后缀运算符 <span class="kdocs-color" style="color:#C21C13;"> () , [] 优先级</span><span class="kdocs-color" style="color:#080F17;">是</span><span class="kdocs-color" style="color:#C21C13;">最高</span>的，<span class="kdocs-color" style="color:#C21C13;">超过一元运算符 *</span> ，</p> 
 <p style="">可以以此猜测并记忆C语言中的声明优先级规则。</p> 
 <p style="">补充：由于优先级运算符从左到右的结合律较多，我们可以着重记忆结合律为<span class="kdocs-color" style="color:#C21C13;">从右到左</span>的相应运算符。</p> 
 <h3 style="">二、C语言中的声明优先级规则</h3> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;text-align:left;"><p>首先 声明<span class="kdocs-color" style="color:#C21C13;">从它的名字开始</span>读取，然后按照优先级顺序依次读取</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>优先级顺序由高到低依次是：</p></li></ol> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p> 声明中<span class="kdocs-color" style="color:#0E52D4;">被括号括起的内容</span>。例如：int *p[2] 与 int (*p)[2]</p></li></ul> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p> <span class="kdocs-color" style="color:#0E52D4;"> () 与 [] </span>。例如：int *fun(int x, int y) 与 int *a[2];</p></li></ul> 
 <p style="text-indent:1.4em;padding-left:2.8em;">()表示这是一个函数</p> 
 <p style="text-indent:1.4em;padding-left:2.8em;">[]表示这是一个数组</p> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p> 指针 *（* 表示<span class="kdocs-color" style="background-color:#E6E6E6;">"指向'读取到的下一部分'的指针"</span>）。例如：</p></li></ul> 
 <p style="padding-left:1.4em;"> </p> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:top;height:52px;"><p style="text-align:center;"><span class="kdocs-bold" style="font-weight:bold;">定义</span></p></td><td class="kdocs-tableCell" style="width:257px;vertical-align:top;height:52px;"><p style="text-align:center;"><span class="kdocs-bold" style="font-weight:bold;">含义理解（方法一）</span></p></td><td class="kdocs-tableCell" style="width:235px;vertical-align:top;height:52px;"><p style="text-align:center;"><span class="kdocs-bold" style="font-weight:bold;">含义理解（方法二）</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style="text-align:center;">int *p</p></td><td class="kdocs-tableCell" style="width:257px;vertical-align:top;height:52px;"><p style="text-align:left;">p为指向一个整形数据(int)类型的指针变量</p></td><td class="kdocs-tableCell" style="width:235px;vertical-align:top;height:52px;"><p style="text-align:left;">p为指针变量，它指向一个整型数据</p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:100px;vertical-align:middle;height:52px;"><p style="text-align:center;">int **p</p></td><td class="kdocs-tableCell" style="width:257px;vertical-align:top;height:52px;"><p style="text-align:left;">p为指向一个整形数据(int)类型指针的指针变量</p></td><td class="kdocs-tableCell" style="width:235px;vertical-align:top;height:52px;"><p style="text-align:left;">p为指针变量，它指向一个整型数据类型的指针变量</p></td></tr></tbody></table> 
 </div> 
 <ul><li style="margin-left:1.4em;list-style-type:disc;text-indent:0;"><p>const/volatie关键字：</p></li></ul> 
 <p style="">const：如果const后面<span class="kdocs-bold" style="font-weight:bold;">紧跟</span>类型说明符（int\short\long等）时，const作用于<span class="kdocs-bold" style="font-weight:bold;">类型说明符</span>；</p> 
 <p style="">若const后<span class="kdocs-bold" style="font-weight:bold;">不</span>紧跟类型说明符（类型说明符在const前面）时，const作用于它<span class="kdocs-color" style="color:#080F17;"><span class="kdocs-bold" style="font-weight:bold;">左边部分</span></span>。</p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">接下来我们以“指向常量的指针 与 指针类型的常量“来理解上述内容。</span></p> 
 <p style="">我们先来看“<span class="kdocs-bold" style="font-weight:bold;">指向常量的指针/常量指针</span>”。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int const *a;            //指向常量的指针
const int *a;            //指向常量的指针</code></pre> 
 <p style="">第一行、第二行声明意义相同，都把a声明为指向const int的指针（即指向整型常量的指针）。</p> 
 <p style="">指针a指向的<span class="kdocs-color" style="color:#0E52D4;">变量</span>被const限定，因此不能在后续操作中<span class="kdocs-color" style="background-color:#E6E6E6;">间接（通过指针修改）</span>修改它的值。但是a并没有被限定，故而a本身的值是可以被修改的，即a所指向的地址是可以修改的。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">// test1 -- 指向常量的指针
# include &lt;stdio.h&gt;
int main(void)
{
    const int *p;
    const int a = 2;
    int b = 1;
    p = &amp;a;
    printf("This is a pointer that points to a changliang. val_a:%d\n",*p);

    p = &amp;b;        //p本身的值可以修改
    printf("This is a pointer that points to a changliang. val_b:%d",*p);

    
    b = 10;
    printf("This is a pointer that points to a changliang. val_b:%d",*p);

 //   *p = 10;      //不能通过指针间接修改b的值
 //   a = 10;       //a被const修饰，为常量，不能改变值
 //   b = 10;       //b没被const修饰，为变量，可以改变值
    return 0;
}
/* **********运行结果********** */
/*

This is a pointer that points to a changliang. val_a:2
This is a pointer that points to a changliang. val_b:1
This is a pointer that points to a changliang. val_b:10

*/</code></pre> 
 <p style="">在上面的例子中，指针p开始时赋予指向一个整型常量（即a），后来指向整型变量（即b）。</p> 
 <p style="">整型常量a的值是无法修改的，但p 的值却可以修改,整型变量b的值也可以修改。</p> 
 <p style="text-align:null;">再看“<span class="kdocs-bold" style="font-weight:bold;">指针类型的常量/指针常量</span>”。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int *const a;        //a是常量指针</code></pre> 
 <p style="">此时a被声明为指向int（即整型变量）的常量指针。指针a被const所限制，指向的地址赋值后便不能改变。但指向的<span class="kdocs-color" style="background-color:#FBF5B3;">变量(若为const常量会产生错误）</span>是通过直接或间接方法改变的。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">// test2 -- 指针常量
# include &lt;stdio.h&gt;
int main(void)
{
    const int a = 2;
    int b = 1;
//  int *const p = &amp;a;      //initializing 'int *const' with an expression of type 'const int *' discards qualifiers(类型不匹配)
    int *const p = &amp;b;
//  p = &amp;a;   p = &amp;b;       //不能修改p指向的地址
    printf("This is a pointer that is a changliang. val_pb1:%d, val_p:%p\n",*p,p);

    *p = 0;                 //p所指向的值可通过间接方式（*p）修改
    printf("This is a pointer that points to a changliang. val_pb2:%d, val_p:%p\n",*p,p);

    b = 10;                 //p所指向的值可通过直接方式（直接给指向的变量赋值）修改
    printf("This is a pointer that points to a changliang. val_pb3:%d, val_p:%p",*p,p);

    return 0;
}

/* **********运行结果********** */
/*

This is a pointer that is a changliang. val_pb1:1, val_p:0x7fff3da12f94
This is a pointer that points to a changliang. val_pb2:0, val_p:0x7fff3da12f94
This is a pointer that points to a changliang. val_pb3:10, val_p:0x7fff3da12f94

（我们可以看到p指向的地址一直不变）
*/</code></pre> 
 <p style="">volatile关键字声明情况与const类似。</p> 
 <p style="">最后我们再看一个例子加以理解：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">char *const *(*funp)();</code></pre> 
 <p style="">按照我们所提的声明优先级规则分步解决：</p> 
 <ol start="1"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>首先，<span class="kdocs-bold" style="font-weight:bold;">声明中被括号括起的部分优先级最高。</span>故先看（*funp），所以funp是一个指针。</p></li></ol> 
 <ol start="2"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>其次，<span class="kdocs-bold" style="font-weight:bold;">（），[ ]优先考虑。</span>所以funp是一个指向函数的指针。</p></li></ol> 
 <ol start="3"><li style="margin-left:1.4em;list-style-type:decimal;text-indent:0;"><p>再处理 <span class="kdocs-bold" style="font-weight:bold;">"*" 前缀与const。</span>所以funp是一个函数指针，指向一个返回一个字符类型的指针常量的*的函数（即该funp指向的函数返回一个字符变量的地址的地址，该字符变量的地址为常量）。</p></li></ol> 
 <h3 style="">三、C语言定义的数据类型（声明内容）理解</h3> 
 <p style="">通过文章的上述内容，我们对于C语言中的声明优先级规则有了一些了解。接下来我们通过几个例子<span class="kdocs-color" style="color:#C21C13;">（int *p, int *p[], int (*p)[]</span><span class="kdocs-color" style="color:#080F17;">等</span><span class="kdocs-color" style="color:#C21C13;">）</span>来进一步理解声明内容。</p> 
 <p style="">首先，我们知道 <span class="kdocs-color" style="background-color:#E6E6E6;">' * '</span> 作为运算符作用是<span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">取</span></span><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">内容</span></span>，需要<span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">给</span></span>它<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">地址</span></span>；<span class="kdocs-color" style="background-color:#E6E6E6;">' &amp; '</span>是<span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">取</span></span><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">地址</span></span>，需要<span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">给</span></span>它<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">内容</span></span>。则我们定义一个变量中有<span class="kdocs-color" style="background-color:#E6E6E6;">' * '</span>，则它的前一个环节需要<span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">给</span></span>它一个地址。这样说明似乎不太好理解，我们后面用例子使其直观体现。</p> 
 <p style="">例一：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int *p;            //p是一个指针，指向int类型的变量</code></pre> 
 <p style="">我们看到，定义的p前有<span class="kdocs-color" style="background-color:#E6E6E6;">' * '</span>，所以p是一个指向int的指针；又根据<span class="kdocs-color" style="background-color:#E6E6E6;">' * '</span> 作为运算符作用是<span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">取</span></span><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">内容</span></span>，需要<span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">给</span></span>它<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">地址，</span></span>所以我们赋给p的值应该是<span class="kdocs-color" style="background-color:#E6E6E6;">（&amp;）地址。</span>综合起来就是，我们需要给p<span class="kdocs-color" style="color:#078654;">一个int类型变量的地址。</span></p> 
 <pre class="kdocs-cpp"><code class="language-cpp"># include &lt;stdio.h&gt;
void swap(int * u, int * v)
{  
    int temp;
    temp = *u; 
    *u = *v; 
    *v = temp;
}

int main(void)
{    
    int x = 5,y = 10;                      //我们定义一个整型的变量
    double a = 1.234, b = 2.345;           //a, b变量类型不为int，测试是否需要int类型的地址
    printf( "before : x=%d,y=%d\n",x,y );
    swap(&amp;x, &amp;y);                          //int *u = &amp;x, int *v = &amp;y
//  swap(&amp;a, &amp;b);                          // 出现报错
//   warning: incompatible pointer types passing 'double *' to parameter of type 'int *' [-Wincompatible-pointer-types]
    printf( "after : x=%d,y=%d\n",x,y );

    return 0;
}

/* **********运行结果********** */
/*

before : x=5,y=10
after : x=10,y=5

*/</code></pre> 
 <p style="">int **p 与 int *p思路相同。p为指针变量，它指向一个指向整型数据的指针变量<span class="kdocs-color" style="background-color:#D9EEFB;color:#C21C13;">(即它取两次地址后得到一个整型数据，<span class="kdocs-bold" style="font-weight:bold;">倒过来思考，</span>也等价于我们需要给它一个整型变量地址的地址）</span>。</p> 
 <hr> 
 <p style="">例二：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int *p[n];                //n个指向整型数据的指针变量组成的指针数组p</code></pre> 
 <p style="">依据上文所提到的优先级，我们可以知道p为一个<span class="kdocs-color" style="color:#58A401;">数组</span>，且该数组中的n个量是指向整型数据的n个指针。又根据<span class="kdocs-color" style="background-color:#E6E6E6;">' * '</span> 作为运算符作用是<span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">取</span></span><span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">内容</span></span>，需要<span class="kdocs-color" style="color:#0E52D4;"><span class="kdocs-bold" style="font-weight:bold;">给</span></span>它<span class="kdocs-color" style="color:#C21C13;"><span class="kdocs-bold" style="font-weight:bold;">地址，</span></span>所以我们赋给p的值应该是<span class="kdocs-color" style="background-color:#D9EEFB;color:#C21C13;">一个储存着n个int类型变量地址的数组</span>。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">//      *********        To test int *p[]         *********      //
# include &lt;stdio.h&gt;
int test_fun(int *p[], int n, int m)            // 输出矩阵形式,其中n为行数,m为列数
{
    for(int i = 0; i &lt; n; i++)
    {
        for(int j = 0; j &lt; m; j++)
        {
            printf("%d ",*(*(p + i) + j));
        }
            printf("\n");
    }
    return 0;
}
int main(void)
{    
    int num1[3] = {1, 2, 3},
        num2[3] = {4, 5, 6}, 
        num3[3] = {7, 8, 9};
    int *p[3] = {num1,num2,num3};           
    // num1,num2,num3是三个数组，直接使用等价于给出&amp;num1[0],&amp;num2[0],num3[0];
    test_fun(p, 3, 3);

    return 0;
}

/* **********运行结果********** */
/*

1 2 3 
4 5 6 
7 8 9 

*/</code></pre> 
 <p style="">由上述例子我们可以发现,(<span class="kdocs-color" style="background-color:#E6E6E6;">p[] == *p</span>),<span class="kdocs-color" style="background-color:#F7C7D3;">int *p[] 等价于 int **p</span>. <span class="kdocs-color" style="color:#080F17;"><span class="kdocs-bold" style="font-weight:bold;">倒过来思考，</span></span>我们也可以直接赋予它一个整型变量<span class="kdocs-color" style="color:#C21C13;">地址的地址</span>。</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int x = 0;
int *p = &amp;x;
void try[int *p[]];           
int main(void)
{
    try(&amp;p); //放到VS中可以发现没报错

    return 0;
}   </code></pre> 
 <p style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">注意：</span></p> 
 <p style=""><span class="kdocs-bold" style="font-weight:bold;">指针数组元素的作用相当于二维数组的行名,但指针数组中元素是指针变量,二维数组的行名是地址常量.</span></p> 
 <hr> 
 <p style="">例三：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">int (*p)[n];       //p为指向含n个元素的一维整型数组的指针变量</code></pre> 
 <p style="">同理，我们按照优先级分析该声明。不难看出，p为一个指针变量，指向一个整型数组。<span class="kdocs-color" style="color:#080F17;"><span class="kdocs-bold" style="font-weight:bold;">倒过来想</span></span>，我们需要赋给它一个整型数组的地址。又<span class="kdocs-color" style="background-color:#E6E6E6;">*p == p[] , </span><span class="kdocs-color" style="background-color:#F7C7D3;color:#C21C13;">int (*p)[] 与 int p[][]</span>等价。</p> 
 <p style=""></p> 
 <pre class="kdocs-cpp"><code class="language-cpp"># include &lt;stdio.h&gt;
int main(void)
{   
      static int a[3][4]={1,3,5,7,9,11,13,15,17,19,21,23};
      int  i, j, (*p)[4];
      for( p=a, i=0; i&lt;3; i++,p++)
      {
         for(j=0; j&lt;4; j++)
              printf("%d ",*(*p+j));  //等价于 p[0][j]
         printf("\n");
      }
}</code></pre> 
 <p style="">图示：</p> 
 <div class="kdocs-line-container" style="display:flex;"> 
  <div class="kdocs-img" style="flex-direction:column;max-width:100%;display:flex;width:507px;justify-content:center;align-items:center;height:auto;"> 
   <div class="kdocs-img" style="padding-top:61.143986%;height:0;"> 
    <img src="https://images2.imgbox.com/52/af/eif3wII0_o.png" style="margin-left:;border:solid 1px #E4E4E4;display:block;width:507px;margin-top:-61.143986%;height:auto;"> 
   </div> 
  </div> 
 </div> 
 <hr> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">练习</span></h4> 
 <p style="text-align:null;">最后，我们将通过两个简单的练习，来巩固上面所提到的知识。</p> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">例1</span></h5> 
 <p style="text-align:null;">试理解以下语句：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">const int a;
int const a;
const int * a;
int * const a;</code></pre> 
 <h5 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">例2</span></h5> 
 <p style="text-align:left;">试理解以下语句：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">（1）int  *p[3];
（2）int   (*p)[3];
（3）int  *p(int);
（4）int  (*p)(int);
（5）int  *(*p)(int);
（6）int (*p[3])(int);
（7）int  *(*p[3])(int);
（8）int  (*p[2])[3];</code></pre> 
 <p style=""><span class="kdocs-fontSize" style="font-size:15pt;"><span class="kdocs-bold" style="font-weight:bold;">参考答案：</span></span></p> 
 <p style="">例一：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">1.  const int a;等价于int const a，都是一个整型常量的声明方式。
2.  const int * a;表示一个指向整型常量的指针。
3.  int * const a;表示一个指向整型变量的常量指针。</code></pre> 
 <p style="text-align:null;">例二：</p> 
 <pre class="kdocs-cpp"><code class="language-cpp">1. 指针数组
2. 指向一维数组的指针
3. 返回指针的函数
4. 指向函数的指针，函数返回int型变量
5. 指向函数的指针，函数返回int型指针
6. 函数指针数组，函数返回int型变量
7. 函数指针数组，函数返回int型指针
8. 指针数组，每个元素指向一维数组</code></pre> 
 <p style="">以上就是对C语言定义的数据类型/声明内容(int *p[]与int (*p)[])的理解，文章中出现错误或者小伙伴对以上内容有所疑问，欢迎大家在评论区留言。</p> 
 <hr> 
 <h4 style="text-align:left;"><span class="kdocs-bold" style="font-weight:bold;">参考资料</span></h4> 
 <p style="">[1] 《C Primer Plus》. [美] Stephen Prata 著.</p> 
 <p style="">[2] 博客: <a class="kdocs-link" style="color:#0A6CFF;" href="https://blog.csdn.net/qq_36132127/article/details/81940015" target="_blank" rel="noopener noreferrer"> 指针常量和常量指针_qq_36132127的博客-CSDN博客_指针常量和常量指针</a></p> 
 <p style="">[3] 博客：<a class="kdocs-link" style="color:#0A6CFF;" href="https://blog.csdn.net/TomMMRunNEr/article/details/78359694" target="_blank" rel="noopener noreferrer"> C语言中const的详细用法及声明规则_RMSnow的博客-CSDN博客</a></p> 
 <p style="">[4] 博客： <a class="kdocs-link" style="color:#0A6CFF;" href="https://blog.csdn.net/TanTrey/article/details/62895826" target="_blank" rel="noopener noreferrer">C语言中的声明优先级规则_hanhanLiao的博客-CSDN博客_c语言 声明优先级</a></p> 
 <p style="">[5] 博客： <a class="kdocs-link" style="color:#0A6CFF;" href="http://c.biancheng.net/view/285.html" rel="nofollow noopener noreferrer" target="_blank">http://c.biancheng.net/view/285.html</a></p> 
 <p style=""></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8e213d035e8506eac9176fd25ffdd99f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">清理bib文件（删除重复项，仅保留tex中引用的条目）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/41b43b432354d657bc074ceca421d2ff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机网络中的原码、反码、补码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>