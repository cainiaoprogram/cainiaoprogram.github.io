<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TEE/Trustzone学习 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TEE/Trustzone学习" />
<meta property="og:description" content="TEE/Trustzone学习 TEE 可信执行环境 Trusted Execution Environment(TEE) 是一种安全环境，该隔离的安全环境运行在隔离的硬件之上，用来专门处理敏感数据以保证信心安全，其中执行的代码和访问的数据在机密性（没有人可以访问数据）和不可篡改性（没有人可以更改代码及其行为）方面被隔离和保护。
Intel SGX（Intel Software Guard Extensions） 是Intel提供的TEE实现，由于过去十年Intel在市场上的主流位置，Intel SGX也自然而然地成为了最常用的TEE方案之一。在SGX中，用于执行代码的TEE环境被称为Enclave（飞地），在Enclave中的数据可以确保其机密性和完整性；而Intel也提供了一个用于验证某个结果是否由SGX所执行出来，以此确保恶意者伪装成SGX来窃取信息；最后SGX方案提供了更广阔的安全边界，内存数据，包括Bios都无法获取到SGX中的加密数据。
除了Intel SGX外，几乎所有主流的芯片企业都提供了TEE解决方案。在ARM中是TrustZone方案，而在AMD中则是 PSP方案。其它手机端芯片例如联发科，高通等也广泛采取了TEE技术。
Arm的TrustZone技术提供了一种高效的、系统范围的安全方法，它将硬件强制隔离内置于CPU中。
多区域安全是Hex-Five安全创建的第一个RISC-V可信执行环境。
AMD平台安全处理器（PSP）的正式名称是AMD安全技术，是一个集成在AMD微处理器中的可信执行环境子系统。
苹果使用了一种专用处理器SEP（Secure Enclave processor）来实现数据保护、触摸ID和人脸识别等功能。SEP负责处理密钥和其他信息，如生物特征识别，这些信息非常敏感，不会被应用处理器处理。
谷歌也有一个类似的解决方案称为Titan M，这是一些Android Pixel设备上可用的外部芯片，可以实现TEE和处理安全引导、锁屏保护、磁盘加密等功能。
TEE将整个系统环境分为安全环境与 非安全或不受信任的富执行环境（REE，Rich Execution Environment）
TEE操作系统通常由具有较高特权的内核和具有较低特权的多个应用程序（称为可信应用程序，TA，Trusted Applications）组成。TA之间彼此隔离，且与TEE内核隔离。这样一来，如果有应用程序被攻陷，它就无法危害到其他应用程序或TEE内核。
简而言之，一个强大的TEE机制可以实现下述三类隔离：
1、TEE与REE之间的隔离；
2、TA和TEE内核之间的隔离；
3、TA之间的隔离。
为了达到这些安全需求，TEE需要硬件原语的支持，以强制进行隔离。硬件和软件之间的配合是至关重要的，并且需要持续配合。
TEE只接受经过适当授权并由其他授权代码检查的代码来执行。因此，在TEE中，我们需要一个安全引导特性来检查所有操作系统组件（引导加载程序、内核、文件系统、可信应用程序等）的完整性和真实性。这样可以确保在设备关机时没有人篡改操作系统的代码。
TrustZone 在现代计算机中，CPU 通过内存映射手段给每个进程营造一个单独的地址空间来隔离多个进程的代码和数据，通过内核空间和用户空间不同的特权级来隔离操作系统和用户进程的代码和数据。但由于内存中的代码和数据都是明文，容易被同处于内存中的其它应用偷窥，因此出现了扩展的安全模块，应用将加密数据送往安全模块，由安全模块处理完后再返回结果给相应的应用。
TrustZone 是 ARM 针对消费电子设备设计的一种硬件架构，其目的是为消费电子产品构建一个安全框架来抵御各种可能的攻击。
TrustZone 在概念上将 SoC 的硬件和软件资源划分为安全(Secure World) 和 非安全(Normal World) 两个世界。
所有需要保密的操作在安全世界执行（如指纹识别、密码处理、数据加解密、安全认证等），其余操作在非安全世界执行（如用户操作系统、各种应用程序等），安全世界和非安全世界通过一个名为 Monitor Mode的模式进行转换，如图：
在monitor模式下运行时，CPU处于安全状态，可以访问设备的所有外围设备和内存。不在这种模式下运行时，CPU处于非安全状态，只能访问外设的子集和特定范围的物理内存。
处理器架构上，TrustZone 将每个物理核虚拟为两个核，一个非安全核 （Non-secure Core, NS Core），运行非安全世界的代码；和另一个安全核 （Secure Core），运行安全世界的代码。
两个虚拟的核以基于时间片的方式运行，根据需要实时占用物理核，并通过 Monitor Mode 在安全世界和非安全世界之间切换，类似同一CPU下的多应用程序环境，不同的是多应用程序环境下操作系统实现的是进程间切换，而 Trustzone 下的 Monitor Mode 实现了同一 CPU 上两个操作系统间的切换。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3ac340e2696f7598592663c601e04d3a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-12T11:11:01+08:00" />
<meta property="article:modified_time" content="2022-12-12T11:11:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TEE/Trustzone学习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="TEETrustzone_0"></a>TEE/Trustzone学习</h2> 
<h3><a id="TEE_1"></a>TEE</h3> 
<p><strong>可信执行环境 Trusted Execution Environment(TEE)</strong> 是一种安全环境，该隔离的安全环境运行在隔离的硬件之上，用来专门处理敏感数据以保证信心安全，其中执行的代码和访问的数据在机密性（没有人可以访问数据）和不可篡改性（没有人可以更改代码及其行为）方面被隔离和保护。</p> 
<p><strong>Intel SGX（Intel Software Guard Extensions）</strong> 是Intel提供的TEE实现，由于过去十年Intel在市场上的主流位置，Intel SGX也自然而然地成为了最常用的TEE方案之一。在SGX中，用于执行代码的TEE环境被称为Enclave（飞地），在Enclave中的数据可以确保其机密性和完整性；而Intel也提供了一个用于验证某个结果是否由SGX所执行出来，以此确保恶意者伪装成SGX来窃取信息；最后SGX方案提供了更广阔的安全边界，内存数据，包括Bios都无法获取到SGX中的加密数据。</p> 
<p>除了Intel SGX外，几乎所有主流的芯片企业都提供了TEE解决方案。在ARM中是<strong>TrustZone</strong>方案，而在AMD中则是 <strong>PSP</strong>方案。其它手机端芯片例如联发科，高通等也广泛采取了TEE技术。</p> 
<p>Arm的TrustZone技术提供了一种高效的、系统范围的安全方法，它将硬件强制隔离内置于CPU中。<br> 多区域安全是Hex-Five安全创建的第一个RISC-V可信执行环境。<br> AMD平台安全处理器（PSP）的正式名称是AMD安全技术，是一个集成在AMD微处理器中的可信执行环境子系统。<br> 苹果使用了一种专用处理器SEP（Secure Enclave processor）来实现数据保护、触摸ID和人脸识别等功能。SEP负责处理密钥和其他信息，如生物特征识别，这些信息非常敏感，不会被应用处理器处理。<br> 谷歌也有一个类似的解决方案称为Titan M，这是一些Android Pixel设备上可用的外部芯片，可以实现TEE和处理安全引导、锁屏保护、磁盘加密等功能。</p> 
<p><img src="https://images2.imgbox.com/ef/48/Id1lii55_o.png" alt="在这里插入图片描述"></p> 
<p>TEE将整个系统环境分为<strong>安全环境</strong>与 非安全或不受信任的<strong>富执行环境（REE，Rich Execution Environment）</strong></p> 
<p>TEE操作系统通常由具有较高特权的内核和具有较低特权的多个应用程序（称为可信应用程序，<strong>TA，Trusted Applications</strong>）组成。TA之间彼此隔离，且与TEE内核隔离。这样一来，如果有应用程序被攻陷，它就无法危害到其他应用程序或TEE内核。<br> 简而言之，一个强大的TEE机制可以实现下述三类隔离：</p> 
<p>1、TEE与REE之间的隔离；<br> 2、TA和TEE内核之间的隔离；<br> 3、TA之间的隔离。</p> 
<p>为了达到这些安全需求，TEE需要硬件原语的支持，以强制进行隔离。硬件和软件之间的配合是至关重要的，并且需要持续配合。</p> 
<p>TEE只接受经过适当授权并由其他授权代码检查的代码来执行。因此，在TEE中，我们需要一个安全引导特性来检查所有操作系统组件（引导加载程序、内核、文件系统、可信应用程序等）的完整性和真实性。这样可以确保在设备关机时没有人篡改操作系统的代码。</p> 
<p><img src="https://images2.imgbox.com/03/cd/KpYurM48_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="TrustZone_32"></a>TrustZone</h3> 
<p>在现代计算机中，CPU 通过内存映射手段给每个进程营造一个单独的地址空间来隔离多个进程的代码和数据，通过内核空间和用户空间不同的特权级来隔离操作系统和用户进程的代码和数据。但由于内存中的代码和数据都是明文，容易被同处于内存中的其它应用偷窥，因此出现了扩展的安全模块，应用将加密数据送往安全模块，由安全模块处理完后再返回结果给相应的应用。</p> 
<p>TrustZone 是 ARM 针对消费电子设备设计的一种硬件架构，其目的是为消费电子产品构建一个安全框架来抵御各种可能的攻击。</p> 
<p>TrustZone 在概念上将 SoC 的硬件和软件资源划分为<strong>安全(Secure World)</strong> 和 <strong>非安全(Normal World)</strong> 两个世界。</p> 
<p>所有需要保密的操作在安全世界执行（如指纹识别、密码处理、数据加解密、安全认证等），其余操作在非安全世界执行（如用户操作系统、各种应用程序等），安全世界和非安全世界通过一个名为 <strong>Monitor Mode</strong>的模式进行转换，如图：</p> 
<p><img src="https://images2.imgbox.com/24/2a/nbcWVZtR_o.png" alt=""></p> 
<p>在monitor模式下运行时，CPU处于安全状态，可以访问设备的所有外围设备和内存。不在这种模式下运行时，CPU处于非安全状态，只能访问外设的子集和特定范围的物理内存。</p> 
<p>处理器架构上，TrustZone 将每个物理核虚拟为两个核，一个非安全核 <strong>（Non-secure Core, NS Core）</strong>，运行非安全世界的代码；和另一个安全核 <strong>（Secure Core）</strong>，运行安全世界的代码。</p> 
<p>两个虚拟的核以基于<strong>时间片</strong>的方式运行，<strong>根据需要实时占用物理核，并通过 Monitor Mode 在安全世界和非安全世界之间切换，类似同一CPU下的多应用程序环境，不同的是多应用程序环境下操作系统实现的是进程间切换，而 Trustzone 下的 Monitor Mode 实现了同一 CPU 上两个操作系统间的切换。</strong></p> 
<h4><a id="_50"></a>组件</h4> 
<p>要实现这样一套硬件架构，首先需要SoC中的各个硬件模块都实现对 Trustzone 的支持，才能称之为完整的 security system。</p> 
<p>其中主要的组件有：</p> 
<p><strong>必选组件</strong></p> 
<p><strong>AMBA3 AXI总线，安全机制的基础设施</strong><br> AMBA3 AXI(AMBA3 Advanced eXtensible Interface)系统总线作为 TrustZone 的基础架构设施，提供了安全世界和非安全世界的隔离机制，确保非安全核只能访问非安全世界的系统资源，而安全核能访问所有资源，因此安全世界的资源不会被非安全世界（或普通世界）所访问。</p> 
<p><strong>虚拟化的ARM Core，虚拟安全和非安全核</strong></p> 
<p><strong>TZPC (TrustZone Protection Controller)</strong>，根据需要控制外设的安全特性</p> 
<p><strong>TZASC (TrustZone Address Space Controller)</strong>，对内存进行安全和非安全区域划分和保护</p> 
<p><strong>可选组件</strong></p> 
<p><strong>TZMA (TrustZone Memory Adapter)</strong>，片上ROM或RAM安全区域和非安全区域的划分和保护</p> 
<p><strong>AXI-to-APB bridge</strong>，桥接 APB 总线，配合 TZPC 使 APB 总线外设支持 TrustZone 安全特性</p> 
<p>设计上，TrustZone 并不是采用一刀切的方式让每个芯片厂家都使用同样的实现。总体上以 AMBA3 AXI 总线为基础，针对不同的应用场景设计了各种安全组件，芯片厂商根据具体的安全需求，选择不同的安全组件来构建他们的 TrustZone 实现。</p> 
<p><strong>常见大致上需要以下几个模块：</strong></p> 
<h5><a id="1_Bus_79"></a>1. Bus</h5> 
<p>这里涉及的总线分为两种，一种是 <strong>AMBA3 AXI system bus（系统总线）</strong>，一种是 <strong>AMBA3 APB peripheral bus（外围总线）</strong>。</p> 
<p>前面说到 trustzone 技术会将系统划分为两种模式：secure 和 Non-secure。而划分的基础就是 AXI 系统总线一条控制线的电平高低。简单来说，就是 ARM 为 AXI 总线每个信道的读写操作都新增了一个标记位：<strong>NS bit</strong>。</p> 
<p><strong>主设备为Non-secure 状态时，发起读写请求，NS bit 必须置为高电平；主设备为 Secure 状态时，发起读写请求，NS bit 必须置为低电平。</strong></p> 
<p>APB 外围总线通过 AXI-to-APB bridge 连接到系统总线，可以实现对外设的安全访问管控，这里的外设可以包括 interrupt controller，timer 等。</p> 
<h5><a id="2_Processor_88"></a>2. Processor</h5> 
<p>ARMv6 之前的 Processor 有 6 种 privilege mode：FIQ，IRQ，Supervisor（SVC），Abort（ABT），Undefined（UND），System（SYS），以及一种 non-privilege mode：User（USR）。<br> 引入 Trustzone 之后，CPU core 被虚拟出 <strong>secure state</strong> 和 <strong>non-secure state</strong>，那么很自然就需要一个能够切换两种 state 的开关，由此在 7 种 CPU mode 之外，新增了 <strong>monitor（MON）mode</strong></p> 
<p>在 ARM core 的 technical reference manual 中，对 Trustzone 技术的支持一般被描述为 <strong>security extension</strong>。</p> 
<p>目前主流使用的 ARM core architecture 主要是 ARMv7 和 ARMv8。两种架构下的 CPU security extension 差异巨大，但总的来说，都是将 CPU 的每个 core 都虚拟出 secure 和 Non-secure 两种模式，<strong>当 core 为 Non-secure 时，Secure Configuration Register 的 NS bit 置为 1，为 secure 模式时，NS bit 置为 0。NS bit 默认为 0，也就是说，CPU 上电后每个 core 都默认为 secure mode。</strong></p> 
<p><img src="https://images2.imgbox.com/ba/1d/y3CpXXnz_o.png" alt="在这里插入图片描述"></p> 
<p>secure world 和 normal world 的切换需要CPU 先进入 <strong>monitor mode</strong>。与 userspace 通过 <strong>svc 指令</strong>可以从 USR mode 切换到 SVC mode 类似，ARM 也提供了一条可以进入 monitor mode 的软中断指令： <strong>smc</strong>。下图是通过 monitor mode 切换 secure 和 normal world 的示意图：<br> <img src="https://images2.imgbox.com/08/80/YnGXTyc7_o.png" alt="在这里插入图片描述"></p> 
<p>以 userspace application 进程需要访问某安全资源举例，简要说明一下切换流程：</p> 
<p>1、App 通过 <strong>syscall svc</strong> 指令进入Kernel space OS（SVC mode）；</p> 
<p>2、Kernel space OS 通过 <strong>smc</strong> 指令进入 monitor mode；</p> 
<p>3、运行在 Monitor mode 的代码首先保存 <strong>Non-secure 状态下的 CPU contexts</strong>，如 lr，sp，spsr等，然后将 <strong>CPU NS bit 置为 0</strong>，表示进入 secure state，通过 rfe 指令（return from exception）进入 secure OS；</p> 
<p>4、 secure OS 叫起 secure application 处理完相应的安全资源访问请求之后，发送 <strong>smc</strong> 指令，再次回到 monitor mode;</p> 
<p>5、运行在 Monitor mode 的代码同样首先保存 <strong>secure 状态下的 CPU contexts</strong>，如 lr，sp，spsr等，然后将 <strong>CPU NS bit 置为 1</strong>，表示进入 non-secure state，然后恢复 Non-secure state下的CPU contexts，通过 **rfe 指令（reture from exception）**重新回到 non-secure OS；</p> 
<p>除了 smc 指令触发的software exception 会进入 monitor mode，也可以配置某些硬件中断触发进入 monitor mode，如 FIQ，IRQ，external data abort，external prefetch abort。都可以通过配置 system register 来决定哪些 hardware exception 可以触发 cpu 陷入 monitor mode。</p> 
<p>除此之外，两种模式下 CPU core 对中断的处理，MMU / Cache访问，Timer，Debug 等等都做了相应的安全扩展。</p> 
<h5><a id="3_Interrupt_controller_120"></a>3. Interrupt controller</h5> 
<p>常见支持 Trustzone 的 interrupt controller IP 有 PL390，GIC-400，GIC-500，简单说就是能够区分 secure interrupt 和 Non-secure interrupt，实现对中断处理的隔离。同样 GIC 的不同版本对 security extension 的设计也不尽相同，常见的 GICv2 和 GICv3 就有着较大差异。</p> 
<h5><a id="4_Trustzone_Address_Space_Controller_123"></a>4. Trustzone Address Space Controller</h5> 
<p>CPU core MMU 的 security extension 主要是针对 CPU 内存空间的安全访问控制，而 TZASC 主要是针对 DRAM。TZASC通常布置在 CPU 和 DRAM controller 之间，通过新增一条地址线表示 NS bit，可以将 DRAM 划分为 secure CPU core 可访问区域和 Non-secure CPU core 可访问区域，实现 DRAM 的隔离。常见的 TZASC IP 有 PL-380 和 TZC-400。针对 on-SoC 的静态内存（ROM 和 SRAM）的区域划分，则需要通过使用 Trustzone Memory Adapter （TZMA）来完成。</p> 
<h5><a id="5_Trustzone_Protection_Controller_126"></a>5. Trustzone Protection Controller</h5> 
<p>挂在 AXI-to-APB bridge 上，用以区分外设是 secure 还是 Non-secure。</p> 
<p><img src="https://images2.imgbox.com/f0/33/JllV2wqa_o.png" alt="在这里插入图片描述"></p> 
<p>上图中，支持 Trustzone 的 ARM core 通过 <strong>AXI 总线</strong>和 <strong>TZMA，SRAM，AXI-to-APB bridge</strong> 相连，其中 AXI-to-APB bridge 上挂了四个外设，<strong>TZPC 永远配置为 secure peripheral</strong>，timer 和 RTC 是 Non-secure peripheral，而 KMI （Keyboard and Mouse Interface）为 secure peripheral 还是 Non-secure peripheral 是 software programmable。KMI secure 和 Non-secure 的切换，由软件配置 TZPC 来完成，而由于 TZPC always 是 secure 外设，所以 TZPC 的配置只能在 CPU 是 secure mode 下才能实现。</p> 
<p>从软件层面来看，就是只有 Trusted OS 才能配置 TZPC。那么将 Keyboard 设置为 secure 的一个作用就是可以在安全环境下让用户输入密码。<br> 同样，当有外设需要访问 DRAM 或者 SRAM 的 secure region 时，也需要通过 TZPC 实现对外设的控制。</p> 
<p>参考：<br> PRD29-GENC-009492C_trustzone_security_whitepaper.pdf<br> https://www.jianshu.com/p/3f952f2c8bf4<br> https://zhuanlan.zhihu.com/p/504531528<br> https://zuopeng.blog.csdn.net/article/details/115608087<br> https://blog.csdn.net/Thanksgining/article/details/111248666</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ccbc489642c7e4cd6c90885704f9c813/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">下MFC中对象、句柄、ID之间的区别.</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/210536f0559848c020aa461df87e3d91/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微信扫码登陆在chrome浏览器失败,浏览器禁止重定向</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>