<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【JavaEE】死锁是什么？如何避免死锁（保姆级讲解） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【JavaEE】死锁是什么？如何避免死锁（保姆级讲解）" />
<meta property="og:description" content="博主简介：想进大厂的打工人博主主页：@xyk:所属专栏: JavaEE初阶 本篇文章将介绍什么是死锁，死锁的四大必要条件，如何去避免死锁~~~ 目录
一、死锁是什么？
二、关于死锁的情况
2.1 一个线程的情况
2.2 两个线程的情况
2.2.1 形如这样的代码：
2.2.2 吃饺子
2.3 N个线程的情况
2.4 加锁代码
三、如何避免死锁
3.1 死锁产生的四个必要条件
当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失。其中最容易破坏的就是 &#34;循环等待&#34;.
3.2 破坏循环等待：
四、相关面试题
4.1 谈谈 volatile关键字的用法?
4.2 Java多线程是如何实现数据共享的?
4.3 Java创建线程池的接口是什么？参数 LinkedBlockingQueue 的作用是什么？
4.4 Java线程共有几种状态？状态之间怎么切换的？
4.5 在多线程下，如果对一个数进行叠加，该怎么做？
4.6 Servlet是否是线程安全的？
4.7 Thread和Runnable的区别和联系?
4.8 多次start一个线程会怎么样
4.9 有synchronized两个方法，两个线程分别同时用这个方法，请问会发生什么？ 4.10 进程和线程的区别？
一、死锁是什么？
死锁是这样一种情形：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。
简单来说，死锁，就是没人能解锁了~~
举例：
我有个女神，我向女神表白了：女神I love you，她欣然同意，我就加锁成功了~~接下来，我换个微信小号，再偷偷加她一把，再在小号上也表白~~此时第二次尝试加锁，就不会成功了，我就只能阻塞等待~~
形如这样的代码：
就是加锁俩次的情况，第二次尝试加锁，需要等待第一个锁释放；第一个锁释放，需要等待第二个锁加锁成功；
逻辑上矛盾了！！！ ==&gt;这就是死锁~~
二、关于死锁的情况 2.1 一个线程的情况 一个线程，一把锁（上面的情况），可重入锁没事，不可重入锁死锁；
2.2 两个线程的情况 两个线程，两把锁，即使是可重入锁，也会死锁~~
2.2.1 形如这样的代码： t1和t2线程在互相抢占锁，t1拥有了locker1再去竞争locker2，t2拥有了locker2再去竞争locker1，这样就形成了死锁~~" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/bd9e1254b2d4698e698a6e19d5f9997f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-13T21:45:40+08:00" />
<meta property="article:modified_time" content="2023-04-13T21:45:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【JavaEE】死锁是什么？如何避免死锁（保姆级讲解）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E2%80%8B%E7%BC%96%E8%BE%91" style="text-align:center;"><a id="_0"></a><img alt="" src="https://images2.imgbox.com/e0/f5/fF49TykT_o.gif"></h2> 
<blockquote> 
 <ul><li><span style="color:#ed7976;"><strong>博主简介：想进大厂的打工人</strong></span></li><li><span style="color:#1c7331;"><strong>博主主页：</strong><a href="https://blog.csdn.net/asad21654864?spm=1000.2115.3001.5343" title="@xyk:">@xyk:</a></span></li><li><strong><span style="color:#e6b223;">所属专栏: <a href="https://blog.csdn.net/asad21654864/category_12243955.html?spm=1001.2014.3001.5482" title="JavaEE初阶">JavaEE初阶</a></span></strong></li></ul> 
</blockquote> 
<p>本篇文章将介绍什么是死锁，死锁的四大必要条件，如何去避免死锁~~~ </p> 
<hr> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%AD%BB%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%AD%BB%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">一、死锁是什么？</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%85%B3%E4%BA%8E%E6%AD%BB%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%85%B3%E4%BA%8E%E6%AD%BB%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5" rel="nofollow">二、关于死锁的情况</a></p> 
<p id="2.1%20%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%83%85%E5%86%B5-toc" style="margin-left:40px;"><a href="#2.1%20%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%83%85%E5%86%B5" rel="nofollow">2.1 一个线程的情况</a></p> 
<p id="2.2%20%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%83%85%E5%86%B5-toc" style="margin-left:40px;"><a href="#2.2%20%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%83%85%E5%86%B5" rel="nofollow">2.2 两个线程的情况</a></p> 
<p id="2.2.1%20%E5%BD%A2%E5%A6%82%E8%BF%99%E6%A0%B7%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9A-toc" style="margin-left:80px;"><a href="#2.2.1%20%E5%BD%A2%E5%A6%82%E8%BF%99%E6%A0%B7%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9A" rel="nofollow">2.2.1 形如这样的代码：</a></p> 
<p id="2.2.2%20%E5%90%83%E9%A5%BA%E5%AD%90-toc" style="margin-left:80px;"><a href="#2.2.2%20%E5%90%83%E9%A5%BA%E5%AD%90" rel="nofollow">2.2.2 吃饺子</a></p> 
<p id="2.3%20N%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%83%85%E5%86%B5-toc" style="margin-left:40px;"><a href="#2.3%20N%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%83%85%E5%86%B5" rel="nofollow">2.3 N个线程的情况</a></p> 
<p id="2.4%20%E5%8A%A0%E9%94%81%E4%BB%A3%E7%A0%81-toc" style="margin-left:40px;"><a href="#2.4%20%E5%8A%A0%E9%94%81%E4%BB%A3%E7%A0%81" rel="nofollow">2.4 加锁代码</a></p> 
<p id="%C2%A0%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81" rel="nofollow"> 三、如何避免死锁</a></p> 
<p id="3.1%20%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6-toc" style="margin-left:40px;"><a href="#3.1%20%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6" rel="nofollow">3.1 死锁产生的四个必要条件</a></p> 
<p id="%E5%BD%93%E4%B8%8A%E8%BF%B0%E5%9B%9B%E4%B8%AA%E6%9D%A1%E4%BB%B6%E9%83%BD%E6%88%90%E7%AB%8B%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BE%BF%E5%BD%A2%E6%88%90%E6%AD%BB%E9%94%81%E3%80%82%E5%BD%93%E7%84%B6%EF%BC%8C%E6%AD%BB%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%A6%82%E6%9E%9C%E6%89%93%E7%A0%B4%E4%B8%8A%E8%BF%B0%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA%E6%9D%A1%E4%BB%B6%EF%BC%8C%E4%BE%BF%E5%8F%AF%E8%AE%A9%E6%AD%BB%E9%94%81%E6%B6%88%E5%A4%B1%E3%80%82%E5%85%B6%E4%B8%AD%E6%9C%80%E5%AE%B9%E6%98%93%E7%A0%B4%E5%9D%8F%E7%9A%84%E5%B0%B1%E6%98%AF%20%22%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%22.-toc" style="margin-left:40px;"><a href="#%E5%BD%93%E4%B8%8A%E8%BF%B0%E5%9B%9B%E4%B8%AA%E6%9D%A1%E4%BB%B6%E9%83%BD%E6%88%90%E7%AB%8B%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BE%BF%E5%BD%A2%E6%88%90%E6%AD%BB%E9%94%81%E3%80%82%E5%BD%93%E7%84%B6%EF%BC%8C%E6%AD%BB%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%A6%82%E6%9E%9C%E6%89%93%E7%A0%B4%E4%B8%8A%E8%BF%B0%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA%E6%9D%A1%E4%BB%B6%EF%BC%8C%E4%BE%BF%E5%8F%AF%E8%AE%A9%E6%AD%BB%E9%94%81%E6%B6%88%E5%A4%B1%E3%80%82%E5%85%B6%E4%B8%AD%E6%9C%80%E5%AE%B9%E6%98%93%E7%A0%B4%E5%9D%8F%E7%9A%84%E5%B0%B1%E6%98%AF%20%22%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%22." rel="nofollow">当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失。其中最容易破坏的就是 "循环等待".</a></p> 
<p id="3.2%20%E7%A0%B4%E5%9D%8F%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%EF%BC%9A-toc" style="margin-left:40px;"><a href="#3.2%20%E7%A0%B4%E5%9D%8F%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%EF%BC%9A" rel="nofollow">3.2 破坏循环等待：</a></p> 
<p id="%E5%9B%9B%E3%80%81%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">四、相关面试题</a></p> 
<p id="4.1%C2%A0%E8%B0%88%E8%B0%88%20volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95%3F-toc" style="margin-left:40px;"><a href="#4.1%C2%A0%E8%B0%88%E8%B0%88%20volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95%3F" rel="nofollow">4.1 谈谈 volatile关键字的用法?</a></p> 
<p id="4.2%C2%A0Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E7%9A%84%3F-toc" style="margin-left:40px;"><a href="#4.2%C2%A0Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E7%9A%84%3F" rel="nofollow">4.2 Java多线程是如何实现数据共享的?</a></p> 
<p id="4.3%20Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%82%E6%95%B0%20LinkedBlockingQueue%20%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:40px;"><a href="#4.3%20Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%82%E6%95%B0%20LinkedBlockingQueue%20%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">4.3 Java创建线程池的接口是什么？参数 LinkedBlockingQueue 的作用是什么？</a></p> 
<p id="4.4%20Java%E7%BA%BF%E7%A8%8B%E5%85%B1%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E6%80%8E%E4%B9%88%E5%88%87%E6%8D%A2%E7%9A%84%EF%BC%9F-toc" style="margin-left:40px;"><a href="#4.4%20Java%E7%BA%BF%E7%A8%8B%E5%85%B1%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E6%80%8E%E4%B9%88%E5%88%87%E6%8D%A2%E7%9A%84%EF%BC%9F" rel="nofollow">4.4 Java线程共有几种状态？状态之间怎么切换的？</a></p> 
<p id="4.5%20%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%8F%A0%E5%8A%A0%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F-toc" style="margin-left:40px;"><a href="#4.5%20%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%8F%A0%E5%8A%A0%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F" rel="nofollow">4.5 在多线程下，如果对一个数进行叠加，该怎么做？</a></p> 
<p id="4.6%20Servlet%E6%98%AF%E5%90%A6%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F-toc" style="margin-left:40px;"><a href="#4.6%20Servlet%E6%98%AF%E5%90%A6%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F" rel="nofollow">4.6 Servlet是否是线程安全的？</a></p> 
<p id="4.7%C2%A0Thread%E5%92%8CRunnable%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%3F-toc" style="margin-left:40px;"><a href="#4.7%C2%A0Thread%E5%92%8CRunnable%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%3F" rel="nofollow">4.7 Thread和Runnable的区别和联系?</a></p> 
<p id="4.8%20%E5%A4%9A%E6%AC%A1start%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7-toc" style="margin-left:40px;"><a href="#4.8%20%E5%A4%9A%E6%AC%A1start%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7" rel="nofollow">4.8 多次start一个线程会怎么样</a></p> 
<p id="4.9%20%E6%9C%89synchronized%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%88%86%E5%88%AB%E5%90%8C%E6%97%B6%E7%94%A8%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E8%AF%B7%E9%97%AE%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%C2%A0-toc" style="margin-left:40px;"><a href="#4.9%20%E6%9C%89synchronized%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%88%86%E5%88%AB%E5%90%8C%E6%97%B6%E7%94%A8%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E8%AF%B7%E9%97%AE%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%C2%A0" rel="nofollow">4.9 有synchronized两个方法，两个线程分别同时用这个方法，请问会发生什么？ </a></p> 
<p id="4.10%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F-toc" style="margin-left:40px;"><a href="#4.10%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F" rel="nofollow">4.10 进程和线程的区别？</a></p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81%E6%AD%BB%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">一、死锁是什么？<br><a id="_12"></a></h2> 
<p>死锁是这样一种情形：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。<br> 简单来说，死锁，就是没人能解锁了~~</p> 
<p>举例：</p> 
<p>我有个女神，我向女神表白了：女神I love you，她欣然同意，我就加锁成功了~~接下来，我换个微信小号，再偷偷加她一把，再在小号上也表白~~此时第二次尝试加锁，就不会成功了，我就只能阻塞等待~~</p> 
<p>形如这样的代码：</p> 
<p><img alt="" height="178" src="https://images2.imgbox.com/3c/51/CeTbtNKJ_o.png" width="244"></p> 
<p> 就是加锁俩次的情况，第二次尝试加锁，需要等待第一个锁释放；第一个锁释放，需要等待第二个锁加锁成功；</p> 
<p>逻辑上矛盾了！！！ ==&gt;这就是死锁~~</p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%85%B3%E4%BA%8E%E6%AD%BB%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5"><a id="_26"></a>二、关于死锁的情况</h2> 
<h3 id="2.1%20%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%83%85%E5%86%B5"><a id="1_27"></a>2.1 一个线程的情况</h3> 
<p>一个线程，一把锁（上面的情况），可重入锁没事，不可重入锁死锁；</p> 
<p><img alt="" height="286" src="https://images2.imgbox.com/93/f9/DNWti9IP_o.png" width="386"> </p> 
<h3 id="2.2%20%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%83%85%E5%86%B5">2.2 两个线程的情况</h3> 
<p>两个线程，两把锁，即使是可重入锁，也会死锁~~</p> 
<h4 id="2.2.1%20%E5%BD%A2%E5%A6%82%E8%BF%99%E6%A0%B7%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%9A">2.2.1 形如这样的代码：</h4> 
<p><img alt="" height="462" src="https://images2.imgbox.com/60/c1/QbMSMt5d_o.png" width="705"></p> 
<p> t1和t2线程在互相抢占锁，t1拥有了locker1再去竞争locker2，t2拥有了locker2再去竞争locker1，这样就形成了死锁~~</p> 
<h4 id="2.2.2%20%E5%90%83%E9%A5%BA%E5%AD%90">2.2.2 吃饺子</h4> 
<p style="text-align:justify;">滑稽老哥和女神一起去饺子馆吃饺子，吃饺子需要酱油和醋.<br> 滑稽老哥抄起了酱油瓶，女神抄起了醋瓶.<br> 滑稽: 你先把醋瓶给我，我用完了就把酱油瓶给你.<br> 女神: 你先把酱油瓶给我，我用完了就把醋瓶给你.<br> 如果这俩人彼此之间互不相让，就构成了死锁.<br> 酱油和醋相当于是两把锁，这两个人就是两个线程.</p> 
<h3 id="2.3%20N%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%83%85%E5%86%B5" style="text-align:justify;">2.3 N个线程的情况</h3> 
<p style="text-align:justify;">此时有N个线程，M把锁，线程数量和锁数量更多了，就更容易死锁了！！</p> 
<p style="text-align:justify;">比如哲学家，就餐问题：</p> 
<p style="text-align:justify;"><img alt="" height="595" src="https://images2.imgbox.com/1a/2b/jb8aczEn_o.png" width="810"></p> 
<p> 这五个哲学家：</p> 
<p>1.随机的进行 吃面条（拿起筷子）和思考人生（放下筷子）</p> 
<p>2.固执的，如果他想拿筷子，被别人占用了，就会等待；等的过程中不会放下手里已经拿到的筷子~~<img alt="" height="672" src="https://images2.imgbox.com/2c/34/xeL2pebH_o.png" width="764"></p> 
<p>假设这五个哲学家，同时拿起左手边的筷子！！！就死锁了！！</p> 
<p> <img alt="" height="671" src="https://images2.imgbox.com/9f/a6/puDL62b8_o.png" width="774"></p> 
<p>死锁是一种严重的 BUG！！ 导致一个程序的线程 "卡死", 无法正常工作！！</p> 
<p>那么实践中，如何去避免出现死锁呢？？一个简单有效的方法就是，破解循环等待这个条件：</p> 
<p>针对锁进行编号，如果需要同时获取多把锁，约定加锁顺序，必须是先对小的编号加锁，后对大的编号加锁~~~</p> 
<p><img alt="" height="565" src="https://images2.imgbox.com/69/b3/zMRX3kiR_o.png" width="710"></p> 
<p>约定，获取多把锁，先获取小的，后获取大的！！</p> 
<p>只要约定了加锁顺序，循环等待自然破除，死锁就不会形成了！！</p> 
<p><img alt="" height="572" src="https://images2.imgbox.com/e1/d9/7SeK7MRQ_o.png" width="719"></p> 
<p>此时，5号老铁就可以先拿起两支筷子进行吃面，吃完了放下筷子，下一位老铁继续进行拿起筷子吃面，依次进行到最后一位老铁，就不会形成死锁~~</p> 
<h3 id="2.4%20%E5%8A%A0%E9%94%81%E4%BB%A3%E7%A0%81">2.4 加锁代码</h3> 
<p>还是上面的代码，进行加锁顺序调整，就可以避免死锁了</p> 
<p><img alt="" height="368" src="https://images2.imgbox.com/a9/e4/wQcwxKDZ_o.png" width="588"></p> 
<p> 两个线程t1，t2都先对locker1进行加锁，就可以避免死锁了~~</p> 
<h2 id="%C2%A0%E4%B8%89%E3%80%81%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"> 三、如何避免死锁</h2> 
<h3 id="3.1%20%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6">3.1 死锁产生的四个必要条件</h3> 
<p>死锁产生的四个必要条件：</p> 
<ul><li>互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用</li><li>不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放。</li><li>请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有。</li><li>循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路</li></ul> 
<h3 id="%E5%BD%93%E4%B8%8A%E8%BF%B0%E5%9B%9B%E4%B8%AA%E6%9D%A1%E4%BB%B6%E9%83%BD%E6%88%90%E7%AB%8B%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E4%BE%BF%E5%BD%A2%E6%88%90%E6%AD%BB%E9%94%81%E3%80%82%E5%BD%93%E7%84%B6%EF%BC%8C%E6%AD%BB%E9%94%81%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E5%A6%82%E6%9E%9C%E6%89%93%E7%A0%B4%E4%B8%8A%E8%BF%B0%E4%BB%BB%E4%BD%95%E4%B8%80%E4%B8%AA%E6%9D%A1%E4%BB%B6%EF%BC%8C%E4%BE%BF%E5%8F%AF%E8%AE%A9%E6%AD%BB%E9%94%81%E6%B6%88%E5%A4%B1%E3%80%82%E5%85%B6%E4%B8%AD%E6%9C%80%E5%AE%B9%E6%98%93%E7%A0%B4%E5%9D%8F%E7%9A%84%E5%B0%B1%E6%98%AF%20%22%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%22.">当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失。<span style="color:#fe2c24;">其中最容易破坏的就是 "循环等待".</span></h3> 
<h3 id="3.2%20%E7%A0%B4%E5%9D%8F%E5%BE%AA%E7%8E%AF%E7%AD%89%E5%BE%85%EF%BC%9A"><br> 3.2 破坏循环等待：</h3> 
<p>最常用的一种死锁阻止技术就是锁排序. 假设有 N 个线程尝试获取 M 把锁, 就可以针对 M 把锁进行编号(1, 2, 3...M)<br> N 个线程尝试获取锁的时候, 都按照固定的按编号由小到大顺序来获取锁. 这样就可以避免环路等待<br><strong>可能产生环路等待的代码:</strong></p> 
<pre><code class="language-java">Object lock1 = new Object();
Object lock2 = new Object();
Thread t1 = new Thread() {
@Override
public void run() {
synchronized (lock1) {
synchronized (lock2) {
// do something...
}
}
}
};
t1.start();
Thread t2 = new Thread() {
@Override
public void run() {
synchronized (lock2) {
synchronized (lock1) {
// do something...
}
}
}
};
t2.start();</code></pre> 
<p><strong>不会产生环路等待的代码:</strong><br> 约定好先获取 lock1, 再获取 lock2 , 就不会环路等待</p> 
<pre><code class="language-java">Object lock1 = new Object();
Object lock2 = new Object();
Thread t1 = new Thread() {
@Override
public void run() {
synchronized (lock1) {
synchronized (lock2) {
// do something...
}
}
}
};
t1.start();
Thread t2 = new Thread() {
@Override
public void run() {
synchronized (lock1) {
synchronized (lock2) {
// do something...
}
}
}
};
t2.start();</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98">四、相关面试题</h2> 
<h3 id="4.1%C2%A0%E8%B0%88%E8%B0%88%20volatile%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E7%94%A8%E6%B3%95%3F">4.1 谈谈 volatile关键字的用法?</h3> 
<p>volatile 能够保证内存可见性. 强制从主内存中读取数据. 此时如果有其他线程修改被 volatile 修饰<br> 的变量, 可以第一时间读取到最新的值.</p> 
<h3 id="4.2%C2%A0Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB%E7%9A%84%3F">4.2 Java多线程是如何实现数据共享的?</h3> 
<p>JVM 把内存分成了这几个区域:<br> 方法区, 堆区, 栈区, 程序计数器.<br> 其中堆区这个内存区域是多个线程之间共享的.<br> 只要把某个数据放到堆内存中, 就可以让多个线程都能访问到</p> 
<h3 id="4.3%20Java%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%8E%A5%E5%8F%A3%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%8F%82%E6%95%B0%20LinkedBlockingQueue%20%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><br> 4.3 Java创建线程池的接口是什么？参数 LinkedBlockingQueue 的作用是什么？</h3> 
<p>创建线程池主要有两种方式:</p> 
<ul><li>通过 Executors 工厂类创建. 创建方式比较简单, 但是定制能力有限.</li><li>通过 ThreadPoolExecutor 创建. 创建方式比较复杂, 但是定制能力强.<br>  </li></ul> 
<p>LinkedBlockingQueue 表示线程池的任务队列. 用户通过 submit / execute 向这个任务队列中添加任务, 再由线程池中的工作线程来执行任务</p> 
<h3 id="4.4%20Java%E7%BA%BF%E7%A8%8B%E5%85%B1%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E6%80%8E%E4%B9%88%E5%88%87%E6%8D%A2%E7%9A%84%EF%BC%9F">4.4 Java线程共有几种状态？状态之间怎么切换的？</h3> 
<ul><li>NEW: 安排了工作, 还未开始行动. 新创建的线程, 还没有调用 start 方法时处在这个状态.</li><li>RUNNABLE: 可工作的. 又可以分成正在工作中和即将开始工作. 调用 start 方法之后, 并正在CPU 上运行/在即将准备运行 的状态.</li><li>BLOCKED: 使用 synchronized 的时候, 如果锁被其他线程占用, 就会阻塞等待, 从而进入该状态.</li><li>WAITING: 调用 wait 方法会进入该状态.</li><li>TIMED_WAITING: 调用 sleep 方法或者 wait(超时时间) 会进入该状态.</li><li>TERMINATED: 工作完成了. 当线程 run 方法执行完毕后, 会处于这个状态<br>  </li></ul> 
<h3 id="4.5%20%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%AF%B9%E4%B8%80%E4%B8%AA%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%8F%A0%E5%8A%A0%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%81%9A%EF%BC%9F">4.5 在多线程下，如果对一个数进行叠加，该怎么做？</h3> 
<p>使用 synchronized / ReentrantLock 加锁<br> 使用 AtomInteger 原子操作.</p> 
<h3 id="4.6%20Servlet%E6%98%AF%E5%90%A6%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><br> 4.6 Servlet是否是线程安全的？</h3> 
<p>Servlet 本身是工作在多线程环境下.<br> 如果在 Servlet 中创建了某个成员变量, 此时如果有多个请求到达服务器, 服务器就会多线程进行<br> 操作, 是可能出现线程不安全的情况的.</p> 
<h3 id="4.7%C2%A0Thread%E5%92%8CRunnable%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB%3F"><br> 4.7 Thread和Runnable的区别和联系?</h3> 
<p>Thread 类描述了一个线程.<br> Runnable 描述了一个任务.<br> 在创建线程的时候需要指定线程完成的任务, 可以直接重写 Thread 的 run 方法, 也可以使用<br> Runnable 来描述这个任务</p> 
<h3 id="4.8%20%E5%A4%9A%E6%AC%A1start%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7"><br> 4.8 多次start一个线程会怎么样</h3> 
<p>第一次调用 start 可以成功调用<br> 后续再调用 start 会抛出 java.lang.IllegalThreadStateException 异常</p> 
<h3 id="4.9%20%E6%9C%89synchronized%E4%B8%A4%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%88%86%E5%88%AB%E5%90%8C%E6%97%B6%E7%94%A8%E8%BF%99%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E8%AF%B7%E9%97%AE%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F%C2%A0"><br> 4.9 有synchronized两个方法，两个线程分别同时用这个方法，请问会发生什么？ </h3> 
<p>synchronized 加在非静态方法上, 相当于针对当前对象加锁.<br> 如果这两个方法属于同一个实例:<br> 线程1 能够获取到锁, 并执行方法. 线程2 会阻塞等待, 直到线程1 执行完毕, 释放锁, 线程2 获取到<br> 锁之后才能执行方法内容.<br> 如果这两个方法属于不同实例:<br> 两者能并发执行, 互不干扰.</p> 
<h3 id="4.10%20%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F">4.10 进程和线程的区别？</h3> 
<p><br> 进程是包含线程的. 每个进程至少有一个线程存在，即主线程。<br> 进程和进程之间不共享内存空间. 同一个进程的线程之间共享同一个内存空间.<br> 进程是系统分配资源的最小单位，线程是系统调度的最小单位。<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ed0cb5277156bd70191271e260986b80/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">阿里云服务器安装宝塔面板搭建网站全流程（一步步详解）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6370ab9342d809adee5265b48418df04/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">postman进行post、get参数传递及中文乱码和各类型参数传递和json格式传参和日期型参数传递和响应数据传回</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>