<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>spring data jpa 学习整理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="spring data jpa 学习整理" />
<meta property="og:description" content="Spring Data Jpa 依赖 maven依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; .yml文件 配置mysql,jpa等 server: port: 8080 context-path: / helloWorld: spring Boot\u5927\u7237\u4F60\u597D msyql: jdbcName: com.mysql.jdbc.Driver dbUrl: jdbc:mysql://localhost:3306/wj33 userName: root password: spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/wj33?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false username: root password: jpa: hibernate.ddl-auto: update show-sql: true database-platform: com.lunwen.wangjie.config.MySQL5DialectUTF8 thymeleaf: cache: false 实体类 实体类的注解 会根据注解自动生成表字段，@Table指定表名，不填，默认为类名@Column指定字段名，不填，默认为属性名其他注解指定字段的规则 import javax.persistence.*; @Entity @Table(name = &#34;user&#34;) public class User { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; /** 姓名 */ @Column(name = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ceac4379865ec3382c17b032b8997962/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-12-29T13:47:47+08:00" />
<meta property="article:modified_time" content="2017-12-29T13:47:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">spring data jpa 学习整理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4 id="spring-data-jpa">　Spring Data Jpa</h4> 
<h2 id="依赖">依赖</h2> 
<ul><li>maven依赖</li></ul> 
<pre class="prettyprint"><code class=" hljs xml"><span class="hljs-tag">&lt;<span class="hljs-title">dependency</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-title">groupId</span>&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-title">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="hljs-tag">&lt;/<span class="hljs-title">artifactId</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-title">dependency</span>&gt;</span></code></pre> 
<h2 id="yml文件">.yml文件</h2> 
<ul><li>配置mysql,jpa等</li></ul> 
<pre class="prettyprint"><code class=" hljs avrasm"><span class="hljs-label">server:</span>
  port: <span class="hljs-number">8080</span>
  context-path: /

<span class="hljs-label">helloWorld:</span> spring Boot\u5927\u7237\u4F60\u597D

<span class="hljs-label">msyql:</span>
   jdbcName: <span class="hljs-keyword">com</span><span class="hljs-preprocessor">.mysql</span><span class="hljs-preprocessor">.jdbc</span><span class="hljs-preprocessor">.Driver</span>
   dbUrl: jdbc:mysql://localhost:<span class="hljs-number">3306</span>/wj33
   userName: root
   password: 

<span class="hljs-label">spring:</span>
   datasource:
      driver-class-name: <span class="hljs-keyword">com</span><span class="hljs-preprocessor">.mysql</span><span class="hljs-preprocessor">.jdbc</span><span class="hljs-preprocessor">.Driver</span>
      url: jdbc:mysql://localhost:<span class="hljs-number">3306</span>/wj33?useUnicode=true&amp;characterEncoding=utf-<span class="hljs-number">8</span>&amp;useSSL=false
      username: root
      password: 
   jpa:
     hibernate<span class="hljs-preprocessor">.ddl</span>-auto: update
     show-sql: true
     database-platform: <span class="hljs-keyword">com</span><span class="hljs-preprocessor">.lunwen</span><span class="hljs-preprocessor">.wangjie</span><span class="hljs-preprocessor">.config</span><span class="hljs-preprocessor">.MySQL</span>5DialectUTF8

   thymeleaf:
     cache: false</code></pre> 
<h2 id="实体类">实体类</h2> 
<ul><li>实体类的注解 会根据注解自动生成表字段，</li><li>@Table指定表名，不填，默认为类名</li><li>@Column指定字段名，不填，默认为属性名</li><li>其他注解指定字段的规则</li></ul> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">import</span> javax.persistence.*;

<span class="hljs-annotation">@Entity</span>
<span class="hljs-annotation">@Table</span>(name = <span class="hljs-string">"user"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> {<!-- --></span>

    <span class="hljs-annotation">@Id</span>
    <span class="hljs-annotation">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)
    <span class="hljs-keyword">private</span> Integer id;

    <span class="hljs-javadoc">/** 姓名 */</span>
    <span class="hljs-annotation">@Column</span>(name = <span class="hljs-string">"name"</span>)
    <span class="hljs-keyword">private</span> String name;

    <span class="hljs-javadoc">/** 密码 */</span>
    <span class="hljs-annotation">@Column</span>(name = <span class="hljs-string">"password"</span>)
    <span class="hljs-keyword">private</span> String password;

    <span class="hljs-javadoc">/** email */</span>
    <span class="hljs-annotation">@Column</span>(name = <span class="hljs-string">"email"</span>)
    <span class="hljs-keyword">private</span> String email;

    <span class="hljs-javadoc">/** level 用于判断学生0 教师1 管理员2*/</span>
    <span class="hljs-annotation">@Column</span>(name = <span class="hljs-string">"level"</span>)
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> level;

    <span class="hljs-javadoc">/** 学号 工号 */</span>
    <span class="hljs-annotation">@Column</span>(name = <span class="hljs-string">"number"</span>, unique = <span class="hljs-keyword">true</span>)
    <span class="hljs-keyword">private</span> String number;

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span>() {
        <span class="hljs-keyword">return</span> name;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span>(String name) {
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span>() {
        <span class="hljs-keyword">return</span> password;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span>(String password) {
        <span class="hljs-keyword">this</span>.password = password;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getEmail</span>() {
        <span class="hljs-keyword">return</span> email;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmail</span>(String email) {
        <span class="hljs-keyword">this</span>.email = email;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLevel</span>() {
        <span class="hljs-keyword">return</span> level;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLevel</span>(<span class="hljs-keyword">int</span> level) {
        <span class="hljs-keyword">this</span>.level = level;
    }

    <span class="hljs-keyword">public</span> String <span class="hljs-title">getNumber</span>() {
        <span class="hljs-keyword">return</span> number;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNumber</span>(String number) {
        <span class="hljs-keyword">this</span>.number = number;
    }
}
</code></pre> 
<h2 id="数据访问层">数据访问层</h2> 
<ul><li>操作数据访问的接口，支持三种查询，hql, sql, 方法名语义分析。</li><li>下列代码是通过hql查询，也就是通过类名，属性名</li></ul> 
<pre class="prettyprint"><code class=" hljs scala"><span class="hljs-keyword">import</span> com.lunwen.wangjie.model.User;
<span class="hljs-keyword">import</span> org.springframework.data.jpa.repository.JpaRepository;
<span class="hljs-keyword">import</span> org.springframework.data.jpa.repository.Query;
<span class="hljs-keyword">import</span> org.springframework.data.repository.query.Param;

public interface UserDao <span class="hljs-keyword">extends</span> JpaRepository&lt;User, Long&gt;{

    <span class="hljs-javadoc">/**
     * 通过名字 查找用户
     * <span class="hljs-javadoctag">@param</span> name 姓名
     * <span class="hljs-javadoctag">@return</span> User
     */</span>
    <span class="hljs-annotation">@Query</span>(<span class="hljs-string">"from User u where u.name=:name"</span>)
    User findUser(<span class="hljs-annotation">@Param</span>(<span class="hljs-string">"name"</span>) String name);

    <span class="hljs-javadoc">/**
     * 通过email查找用户
     * <span class="hljs-javadoctag">@param</span> email
     * <span class="hljs-javadoctag">@return</span>
     */</span>
    <span class="hljs-annotation">@Query</span>(<span class="hljs-string">"from User u where u.email=:email"</span>)
    User findUserByEmail(<span class="hljs-annotation">@Param</span>(<span class="hljs-string">"email"</span>) String email);

    <span class="hljs-javadoc">/**
     * 通过学号/工号查找用户
     * <span class="hljs-javadoctag">@param</span> number number
     * <span class="hljs-javadoctag">@return</span> User
     */</span>
    <span class="hljs-annotation">@Query</span>(<span class="hljs-string">"from User u where u.number=:number"</span>)
    User findUserByNumber(<span class="hljs-annotation">@Param</span>(<span class="hljs-string">"number"</span>) String number);

    <span class="hljs-comment">//User findUserByNumber(String numer);</span>
}
</code></pre> 
<ul><li>也可能过原生的sql查询@Query(“原生sql”)</li><li>也可通过方法名拼接如下</li><li>findAllByWno，会语义分析为查找所有的当前类，通过wno字段，从数据库中去捞数据，一般Idea会自动告诉你如何拼接可行的方法名。</li><li>还可以继承分页的数据访问Repository,现在继承的是JpaRepository，里面指定类名，就会关联的数据库中的表。</li></ul> 
<pre class="prettyprint"><code class=" hljs php">import com.lunwen.wangjie.model.StudentWork;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.<span class="hljs-keyword">List</span>;

<span class="hljs-comment">/**
 * Created with IDEA
 * author: wangjie
 */</span>
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentWorkDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JpaRepository</span>&lt;<span class="hljs-title">StudentWork</span>, <span class="hljs-title">Long</span>&gt;{<!-- --></span>

    <span class="hljs-keyword">List</span>&lt;StudentWork&gt; findAllByWno(Long wno);

    <span class="hljs-keyword">List</span>&lt;StudentWork&gt; findAllBySno(String sno);


    StudentWork findStudentWorkBySnoAndWno(String sno, Long wno);

}
</code></pre> 
<ul><li>高级内容，一对一，一对多，多对多，懒延迟等，后续说。</li></ul> 
<h3 id="急切和延迟加载">急切和延迟加载</h3> 
<ul><li>JPA中最重要的概念是为了使数据库的副本在高速缓冲存储器中。虽然有一个数据库事务，但JPA首先创建一个重复的数据集，只有当它使用实体管理提交，所做的更改影响到数据库中。</li><li>从数据库中获取记录有两种方式 <br> 
  <ul><li>预先抓取，相关子对象获取一个特定的记录自动上传</li><li>延迟加载，在延迟装载，涉及的对象不会自动上传，除非你特别要求他们。</li></ul></li></ul> 
<h4 id="级联">级联</h4> 
<ul><li>cascade:定义类和类之间的级联关系。级联关系定义对当前对象的操作将波及到关联类的对象，而且这个种关系是递归调用的。如School与Student有级联删除关系，那么删除School时将同时删除关联的Student对象。如果Student还与其他关联，会递归删除下去。</li><li>CascadeType.PERSIST 级联持久化（保存）操作（持久保存拥有方实体时，也会持久保存该实体的所有相关数据。）</li><li>CascadeType.REMOVE Cascade remove operation，级联删除操作。 删除当前实体时，与它有映射关系的实体也会跟着被删除。</li><li>CascadeType.MERGE Cascade merge operation，级联更新（合并）操作。当Student中的数据改变，会相应地更新Course中的数据 </li><li>CascadeType.DETACH Cascade detach operation，级联脱管/游离操作。如果你要删除一个实体，但是它有外键无法删除，你就需要这个级联权限了。它会撤销所有相关的外键关联。</li><li>CascadeType.REFRESH Cascade refresh operation，级联刷新操作。假设场景 有一个订单,订单里面关联了许多商品,这个订单可以被很多人操作,那么这个时候A对此订单和关联的商品进行了修改,与此同时,B也进行了相同的操作,但是B先一步比A保存了数据,那么当A保存数据的时候,就需要先刷新订单信息及关联的商品信息后,再将订单及商品保存。(来自良心会痛的评论) CascadeType.ALL</li><li>Cascade all operations，清晰明确，拥有以上所有级联操作权限。</li></ul> 
<h4 id="jpa实体关系">JPA实体关系</h4> 
<ul><li>实体关系是指实体与实体之间的关系，从方向上分为单向关联和双向关联，从实体数量上分为一对一，一对多，多对多等，对于任何两个实体，都要从这个两个方面区分它们之间的关系。单向关联是一个实体中引用了另外一个实体，也即通过一个实体可以获取另一个实体对象的引用，双向关联是两个实体之间可以互相获取对方对象的引用。</li><li>一对一 @OneToOne <br> 
  <ul><li>学生证和身份证是一对一的关系。 <br> 
    <ul><li>单向关联 <br> 
      <ul><li>假设在学生实体中可以获取身份证对象的引用；反之，不能再身份证实体中获取学生对象的引用，则学生和身份证是一对一的单向关联关系</li><li>这时候只需要在学生实体中的IDCrad_id加上@JoinColumn(name = “外键表字段名”)，以及@OneToOne(cascade=CascadeType.All)</li><li>@OneToOne 只能确定实体与实体之间的关系是一对一的关系，不能指定数据库表中的保存的关联字段，所以要结合@JoinColumn来指定关联字段</li><li>在默认情况下，关联实体(IDCard)的主键一般是用来做外键的，但如果此时不想将关联实体的主键作为外键，需要设置@JoinColumn的referencedColumnName属性</li></ul></li><li>双向关联 <br> 
      <ul><li>需要在接受方的字段定义一个@OneToOne(mappedBy = “主动方一对一的属性名”)</li></ul></li><li>主键关联 <br> 
      <ul><li>既让两个实体对象具有相同的主键值，以表明它们之间的一一对应关系；而数据库不会有额外的字段来维护它们之间的关系，仅通过表的主键来关联，主键的值需要程序来显示维护。 </li><li>只要在@OneToOne的下面添加一个@PrimaryKeyJoinColumn</li></ul></li><li>总结 <br> 
      <ul><li>确定实体与实体之间的关系，如果是一对一关系 则使用@OneToOne</li><li>确定表的结构的设计 <br> 
        <ul><li>如果是外键关联，在关系维护段考虑默认的实体关系映射或@JoinColumn</li><li>如果表位于不同的数据中，可以采用主键关联，使用@PrimaryKeyJoinColumn</li></ul></li><li>确定实体关系的方向 <br> 
        <ul><li>单向关系 在保存关联关系的实体中，使用@JoinColumn</li><li>双向关系 则在保存关联关系（也即存在外键）的实体中，要配合@JoinColumn；在没有保存关联关系的实体中，需使用mappedBy属性明确所关联的实体</li><li>mappedBy用在双向关联中，mappedBy所在的实体为关系被维护端，而另一个实体为关系维护端（也即保存关联关系的一端） </li></ul></li></ul></li></ul></li></ul></li><li>一对多 <br> 
  <ul><li>单向关联 <br> 
    <ul><li>使用@ManyToOne 比如一个学校可能有多个学生 ，那就可以在学生的schoolId字段加上@JoinColumn(name=”school_id”) @ManyToOne </li></ul></li><li>双向关联 <br> 
    <ul><li>在学校的students字段加一个 @OneToMany(mappedBy=”school”, cascade=CascadeType.ALL) 学生表中的SchoolId字段@JoinColumn(name = “”) @ManyToOne </li><li>option：指定级联方是否可以为空，默认为true,允许外键字段为空，若将其设置为false,则双方必须存在，也即外键字段不能为空</li></ul></li><li>表关联（双向） <br> 
    <ul><li>在一对多或多对一的关联关系中，除了使用默认的外键关联外；还可以使用表关联，多的一方可以作为关系表的主键（唯一性约束）,而一的一方可以作为关系表另一个字段。</li><li>在多的一方作为关系表的主键 name : 中间表 joinColumns:中间表中，指向关系维护端的外键； inverseJoinColumns:与joinColumns相似，指向中间表中被维护端的外键 <br> <code>java <br> @ManyToOne <br> @JoinTable(name="SCHOOL_STUDENT", <br> joinColumns={ <br> @JoinColumn(name="student_id",referencedColumnName="id") //自方 <br> }, <br> inverseJoinColumns={ <br> @JoinColumn(name="school_id",referencedColumnName="id") //一方 <br> }) <br> </code></li><li>在一的一方 @OneToMany(mappedBy=”school”)</li></ul></li><li>总结 <br> 
    <ul><li>确定实体与实体之间的关系，如果是一对多的关系，则使用@OneToMany；如果是多对一的关系使用@ManyToOne</li><li>确认表结构的设计 <br> 
      <ul><li>如果是外键关联，在关系维护端考虑默认的实体关系映射或配合JoinColumn</li><li>如果是表关联，则在关系维护端使用@JoinTable</li></ul></li><li>确定实体关系的方向 <br> 
      <ul><li>单向关联 一般情况下，多的一方为关系维护端，在保存关联关系实体中使用@JoinColumn或@JoinTable</li><li>若为双向关联，则在关系维护端，配合@JoinColumn或@JoinTable；在关系呗维护端，要使用mappedBy属性明确所关联的实体</li></ul></li></ul></li></ul></li><li>多对多 <br> 
  <ul><li>单向关联 <br> 
    <ul><li>老师和学生就是一个多对多关系 ,在老师实体类中维护 <br> <code>java <br> @ManyToMany(fetch=FetchType.LAZY) <br> @JoinTable(name="TEACHER_STUDENT", <br> joinColumns={@JoinColumn(name="teacher_id")}, <br> inverseJoinColumns={@JoinColumn(name="student_id")}) <br> </code> </li></ul></li><li>双向关联 <br> 
    <ul><li>在老师中如上维护，在学生中处理接受方 @ManyToMany(mappedBy=”students”,fetch=FetchType.LAZY) </li></ul></li><li>总结 <br> 
    <ul><li>单向关联在维护端使用@JoinTable</li><li>双向关联在维护端使用@JoinTable 在关系被维护端，要使用mappedBy属性明确所关联 </li><li>FetchType.EAGER:代表立即加载； </li><li>FetchType.LAZY:代表延迟加载。 </li></ul></li></ul></li></ul> 
<h4 id="数据的级联抓取fetch">数据的级联抓取(Fetch)</h4> 
<ul><li>基础知识 <br> 
  <ul><li>级联抓取(Fetch)是JPA提供的实体键的关联属性，用于执行实体的读操作，同时对其关联的其他实体进行操作</li><li>如果不配置fetch属性，则缺省值为 <br> 
    <ul><li>如果对端为”一”,即@OneToOne或@ManyToOne映射的属性，缺省为FetchType.EAGER，即缺省会将关联数据抓取出来。</li><li>如果对端为”多”,即@OneToMany或@ManyToMany映射的属性，缺省为FetchType.LAZY,即缺省不会将关联的数据抓取出来。</li></ul></li><li>使用 JPA 级联抓取数据时，可通过指定 EntityGraph 配置连接关系 @EntityGraph(attributePaths = “extra”) ，EntityGraph 已经将实体本身的 fetch 属性覆盖了，即使配置了 FetchType.LAZY，只要在查询时配置了 EntityGraph，关联的对象将以最高效的方式查询出来。</li><li>如果 Fetch 属性配置在实体上，那么所有对实体的查询操作都将受其影响，无论这些关联数据是否需要都会被查出来。而使用 EntityGraph，配置到数据访问方法上，则可以很精确的配置究竟需要哪些关联数据，粒度更精准。</li><li>为了避免无谓的效率浪费，我们建议：所有的 @OneToOne 和 @ManyToOne 关联实体，均应配置 fetch = FetchType.LAZY，避免缺省将关联实体查询出来。当确实需要使用关联实体时，在数据访问方法中使用 EntityGraph 配置。</li><li>@Transactional 注解；同时由于要执行数据保存操作，故需要增加 @Commit 注解，使得事物在方法退出后提交。如果只写 @Transactional，不写 @Commit，则方法退出后事物缺省回滚</li></ul></li><li>spring框架对Jpa提供了以下的支持 <br> 
  <ul><li>它使得 JPA 配置变得更加灵活。JPA 规范要求，配置文件必须命名为 persistence.xml，并存在于类路径下的 META-INF 目录中。该文件通常包含了初始化 JPA 引擎所需的全部信息。Spring 提供的 LocalContainerEntityManagerFactoryBean 提供了非常灵活的配置，persistence.xml 中的信息都可以在此以属性注入的方式提供</li><li>其次，Spring实现了部分在EJB容器 下才具有的功能</li><li>Spring将EntityManager的创建和销毁，事务管理等代码抽取出来，并由其统一管理</li></ul></li><li>Spring Data Jpa框架主要针对的就是Spring唯一没有简化到的业务逻辑代码，不用实现持久层的业务逻辑，唯一需要做的是声明持久层的接口，其他都交托给spring data Jpa完成。</li><li>让持久层接口DAO,集成Repository接口 <br> 
  <ul><li>该接口使用了泛型，需要为其提供两个类型：第一个为该接口处理的域对象类型，第二个为该域对象的主键类型。如下： <br> <code>java <br> public interface UserDao extends Repository&lt;AccountInfo, Long&gt; { <br> public AccountInfo save(AccountInfo accountInfo); <br> } <br> </code> <br> 
    <ul><li>不需要使用UserDao的实现类，框架会为我们完成业务逻辑</li><li>在spring配置文件中启用扫描并创建代理的功能 <br> <code>xml <br> &lt;-- 需要在 &lt;beans&gt; 标签中增加对jpa命名空间的引用 --&gt; <br> &lt;jpa:repositories base-package="footmark.springdata.jpa.dao" <br> entity-manager-factory-ref="entityManagerFactory" <br> transaction-manager-ref="transactionManager" /&gt; <br> </code></li></ul></li></ul></li><li>spring data jpa进行持久层开发大致需要的三个步骤 <br> 
  <ul><li>声明持久层的接口，该接口继承Repository,Repository是一个标记型接口，它不包含任何方法，当然如果有需要，Spring Data 也提供了若干的Repository的子接口，其中定义了一些常用的增删改查，以及分页相关的方法。</li><li>在接口中声明需要的业务方法，spring data 将根据给定的策略来为其生成实现代码。</li><li>在spring配置文件中增加一行声明，让spring为声明的接口创建代理对象。配置了后，spring初始化容器时会扫描base-package指定的包目录及其子目录，为继承Repository或其子接口的接口创建代理对象，并将代理对象注册为Spring bean,业务层便可以通过spring自动封装的特性来直接使用该对象。</li><li>此外还提供了一些属性和子标签，便于做更细粒度的控制，可以在内部使用、来过滤掉一些不希望被扫描的接口</li></ul></li><li>如果持久层接口较多，且每一个接口都需要声明相似的增删改查，可以继承CrudRepository接口，会自动为域对象创建增删改查方法，供业务层使用，可能暴露了不希望暴露给业务层的方法</li><li>分页查询和排序是持久层常用的功能，spring data 为此提供了PagingAndSortingRepository接口，它继承自CrudRepository接口，在CrudRepository基础上新增了两个与分页有关的方法。但是，我们很少会将自定义的持久层接口直接继承自PagingAndSortingRepository，而是在继承Repository或CrudRepository,在自己声明的方法的参数列表加一个Pageable或Sort类型的参数，用于指定分页或排序信息即可，这比直接使用PagingAndSortingRepository提供了更大的灵活性。</li><li><p>JpaRepository是继承自PagingAndSortingRepository的针对JPA提供接口，它在父及接口的基础上提供了其他一些方法，比如flush(),saveAndFlush,deleteInBatch().</p></li><li><p>查询方法</p> 
  <ul><li>框架会对方法名进行解析，会把方法名多余的前辍截取掉，比如find,findBy,read,readBy,get,getBy,然后对剩下部分进行解析。并且如果方法的最后一个参数是Sort或者Pagealbe类型，也会提取相关信息，以便按规则进行排序或者分页查询。</li><li>在创建查询时，我们通过在方法名中使用属性名称来表达，比如findByUserAddressZip(). 首先剔除findBy,然后对剩下属性进行解析，详细规则如下（此处假设该方法针对的域对象为AccountInfo类型） <br> 
    <ul><li>先判断userAddressZip(根据POJO规范,首字母变为小写，下同),是否为AccountInfo的一个属性，如果是，则表示根据该属性进行查询；如果没有该属性，继续第二步；</li><li>从右往左边截取第一个大写字母开头的字符串（此处是Zip),然后检查剩下的字符串是否为AccountInfo的一个属性，如果是，则表示根据该属性进行查询，如果没有该属性，则重复第二步，继续从右往左进行字符串截取，最后假设user为AccountInfo的一个属性</li><li>接着处理剩下部分（AddressZip)，先判断user所对于的类型是否有addressZip属性，如果有，则表示该方法最终是根据”AccountInfo.user.addressZip”的取值进行查询的，否则继续按照步骤2的规则从右往左边截取，最终表示更加”AccountInfo.user.address.zip”的值进行查询。否则继续按照步骤2的规则从右往截取；最后表示根据”AccountInfo.user.addrsss.zip”的值进行查询。</li></ul></li><li>在查询时通常需要同时根据多个属性进行查询，且查询的条件也各式各样（大于某个值，在某个范围等等）,spring data jpa为此提供了一些表达条件查询的关键字 <br> 
    <ul><li>And — 等价于 SQL 中的 and 关键字，比如 findByUsernameAndPassword(String user, Striang pwd)；</li><li>Or — 等价于 SQL 中的 or 关键字，比如 findByUsernameOrAddress(String user, String addr)；</li><li>Between — 等价于 SQL 中的 between 关键字，比如 findBySalaryBetween(int max, int min)；</li><li>LessThan — 等价于 SQL 中的 “&lt;”，比如 findBySalaryLessThan(int max)；</li><li>GreaterThan — 等价于 SQL 中的”&gt;”，比如 findBySalaryGreaterThan(int min)；</li><li>IsNull — 等价于 SQL 中的 “is null”，比如 findByUsernameIsNull()；</li><li>IsNotNull — 等价于 SQL 中的 “is not null”，比如 findByUsernameIsNotNull()；</li><li>NotNull — 与 IsNotNull 等价；</li><li>Like — 等价于 SQL 中的 “like”，比如 findByUsernameLike(String user)；</li><li>NotLike — 等价于 SQL 中的 “not like”，比如 findByUsernameNotLike(String user)；</li><li>OrderBy — 等价于 SQL 中的 “order by”，比如 findByUsernameOrderBySalaryAsc(String user)；</li><li>Not — 等价于 SQL 中的 “！ =”，比如 findByUsernameNot(String user)；</li><li>In — 等价于 SQL 中的 “in”，比如 findByUsernameIn(Collection userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数；</li><li>NotIn — 等价于 SQL 中的 “not in”，比如 findByUsernameNotIn(Collection userList) ，方法的参数可以是 Collection 类型，也可以是数组或者不定长参数；</li></ul></li><li><p>@Query创建查询</p> 
    <ul><li><p>@Query注解的使用非常简单，只需要在声明的方法上面标注该注解，同时提供一个JPQL查询语句即可如下所示</p> <pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Repository</span>&lt;<span class="hljs-title">AccountInfo</span>, <span class="hljs-title">Long</span>&gt; {<!-- --></span>
    <span class="hljs-annotation">@Query</span>(<span class="hljs-string">"select a from AccountInfo a where a.accountId = ?1"</span>)
    <span class="hljs-keyword">public</span> AccountInfo <span class="hljs-title">findByAccountId</span>(Long accountId);
    <span class="hljs-annotation">@Query</span>(<span class="hljs-string">"select a from AccountInfo a where a.balance &gt;?1"</span>)
    <span class="hljs-keyword">public</span> Page&lt;AccountInfo&gt; <span class="hljs-title">findByBalanceGreaterThan</span>(Integer balance, Pageable pageable);
}
</code></pre></li><li>创建JP QL时用明明参数来代替位置编号，@Query也对此提供了支持。JP QL中通过”:变量”的格式来制定参数，同时在方法的参数前面使用@Param将方法参数与JP QL中的命名参数对应。 <br> <code>java <br> public interface UserDao extends Repository&lt;AccountInfo, Long&gt; { <br> @Query("from AccountInfo a where a where a.ccountId = :id") <br> public AccountInfo findByAccountId(@Param("id")Long accountId); <br> @Query("from AccountInfo a where a.banlace &gt; :balance") <br> public Page&lt;AccountInfo&gt; findByBalanceGreaterThan(@Param("balance")Integer balance,Pageable pageable); <br> } <br> </code></li><li>此外可以使用@Query来执行一个更新操作，为此我们需要在使用@Query的同时，用@Modifying来将该操作标识符标注就好了 <br> <code>java <br> @Modifying <br> @Query("updata AccountInfo a set a.salary = ?1 where a.salary &lt; ?2") <br> public int increaseSalary(int after,int before); <br> </code></li><li>通过JPA命名查询语句创建查询 <br> 
      <ul><li>命名查询是JPA提供的一种将查询语句从方法体重独立出来，以供多个方法共用的功能</li></ul></li><li>JpaRepository 接口特色 <br> 
      <ul><li>将一些查询方法返回类型由Iterable转换成了List</li><li>新增了保存或更细的方法 <br> <code>java <br> List&lt;T&gt; findAll(); <br> List&lt;T&gt; findAll(Sort sort); <br> List&lt;T&gt; findAll(Iterable&lt;ID&gt; ids); <br> &lt;S extends T&gt; List&lt;S&gt; save(Iterable&lt;S&gt; entities); <br> void flush(); <br> &lt;S extends T&gt; S saveAndFlush(S entity); <br> void deleteInBatch(Iterable&lt;T&gt; entities); <br> void deleteAllInBatch(); <br> T getOne(ID id); <br> </code></li></ul></li><li>JpaSpecificationExecutor特色：实现了带条件的查询，类似于Hiberante的cretira <br> <code>java <br> T findOne(Specification&lt;T&gt;); <br> List&lt;T&gt; findAll(Specification&lt;T&gt;); <br> List&lt;T&gt; findAll(Specification&lt;T&gt;, Sort); <br> List&lt;T&gt; findAll(Specification&lt;T&gt;, Pageable); <br> long count(Specification&lt;T&gt;); <br> </code></li></ul></li></ul></li><li><p>spring Data Jpa对实务的支持 </p> 
  <ul><li>默认情况下，Spring Data JPA实现的方法都是使用事务的。针对查询类型的方法，其等价于@Transactional(readOnly=true);增删该查类型的方法，等价于@Transactional.除了查询的方法设为只读事务外，其他食物属性均采用默认值。</li></ul></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/60252e86e50d4b16848f91a423a07287/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kinect V2.0得到RGB图像各个像素点对应的三维坐标（相机坐标系）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/453888ff18067537923798165513aa20/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">常用注解（Annotation）整理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>