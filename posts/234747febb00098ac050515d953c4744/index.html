<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Gin 框架的路由结构浅析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Gin 框架的路由结构浅析" />
<meta property="og:description" content="Gin 是 go 语言的一款轻量级框架，风格简单朴素，支持中间件，动态路由等功能。 gin项目github地址 路由是web框架的核心功能。在没有读过 gin 的代码之前，在我眼里的路由实现是这样的：根据路由里的 / 把路由切分成多个字符串数组，然后按照相同的前子数组把路由构造成树的结构；寻址时，先把请求的 url 按照 / 切分，然后遍历树进行寻址。
比如：定义了两个路由 /user/get，/user/delete，则会构造出拥有三个节点的路由树，根节点是 user，两个子节点分别是 get delete。
上述是一种实现路由树的方式，且比较直观，容易理解。对 url 进行切分、比较，时间复杂度是 O(2n)。
Gin的路由实现使用了类似前缀树的数据结构，只需遍历一遍字符串即可，时间复杂度为O(n)。
当然，对于一次 http 请求来说，这点路由寻址优化可以忽略不计。
Engine Gin 的 Engine 结构体内嵌了 RouterGroup 结构体，定义了 GET，POST 等路由注册方法。
Engine 中的 trees 字段定义了路由逻辑。trees 是 methodTrees 类型（其实就是 []methodTree），trees 是一个数组，不同请求方法的路由在不同的树（methodTree）中。
最后，methodTree 中的 root 字段（*node类型）是路由树的根节点。树的构造与寻址都是在 *node的方法中完成的。
UML 结构图
trees 是个数组，数组里会有不同请求方法的路由树。
node node 结构体定义如下
type node struct { path string // 当前节点相对路径（与祖先节点的 path 拼接可得到完整路径） indices string // 所以孩子节点的path[0]组成的字符串 children []*node // 孩子节点 handlers HandlersChain // 当前节点的处理函数（包括中间件） priority uint32 // 当前节点及子孙节点的实际路由数量 nType nodeType // 节点类型 maxParams uint8 // 子孙节点的最大参数数量 wildChild bool // 孩子节点是否有通配符（wildcard） } path 和 indices 关于 path 和 indices，其实是使用了前缀树的逻辑。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/234747febb00098ac050515d953c4744/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-11T02:38:25+08:00" />
<meta property="article:modified_time" content="2018-10-11T02:38:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Gin 框架的路由结构浅析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article fmt article__content"> 
 <blockquote> 
  <code>Gin</code> 是 
  <code>go</code> 语言的一款轻量级框架，风格简单朴素，支持中间件，动态路由等功能。 
  <a href="https://github.com/gin-gonic/gin">gin项目github地址</a> 
 </blockquote> 
 <p>路由是web框架的核心功能。在没有读过 <code>gin</code> 的代码之前，在我眼里的路由实现是这样的：根据路由里的 <code>/</code> 把路由切分成多个字符串数组，然后按照相同的前子数组把路由构造成树的结构；寻址时，先把请求的 <code>url</code> 按照 <code>/</code> 切分，然后遍历树进行寻址。</p> 
 <p>比如：定义了两个路由 <code>/user/get</code>，<code>/user/delete</code>，则会构造出拥有三个节点的路由树，根节点是 <code>user</code>，两个子节点分别是 <code>get</code> <code>delete</code>。</p> 
 <p>上述是一种实现路由树的方式，且比较直观，容易理解。对 url 进行切分、比较，时间复杂度是 <code>O(2n)</code>。</p> 
 <p>Gin的路由实现使用了类似前缀树的数据结构，只需遍历一遍字符串即可，时间复杂度为<code>O(n)</code>。</p> 
 <p>当然，对于一次 http 请求来说，这点路由寻址优化可以忽略不计。</p> 
 <h4>Engine</h4> 
 <p><code>Gin</code> 的 <code>Engine</code> 结构体内嵌了 <code>RouterGroup</code> 结构体，定义了 <code>GET</code>，<code>POST</code> 等路由注册方法。</p> 
 <p><code>Engine</code> 中的 <code>trees</code> 字段定义了路由逻辑。<code>trees</code> 是 <code>methodTrees</code> 类型（其实就是 <code>[]methodTree</code>），<code>trees</code> 是一个数组，不同请求方法的路由在不同的树（<code>methodTree</code>）中。</p> 
 <p>最后，<code>methodTree</code> 中的 <code>root</code> 字段（<code>*node</code>类型）是路由树的根节点。树的构造与寻址都是在 <code>*node</code>的方法中完成的。</p> 
 <p>UML 结构图<br><span class="img-wrap"><img src="https://images2.imgbox.com/8c/bd/tkkwaTmM_o.jpg" alt="engine结构图" title="engine结构图"></span></p> 
 <p><code>trees</code> 是个数组，数组里会有不同请求方法的路由树。</p> 
 <p><span class="img-wrap"><img src="https://images2.imgbox.com/f5/90/xlqnHJx2_o.jpg" alt="tree结构" title="tree结构"></span></p> 
 <h4>node</h4> 
 <p>node 结构体定义如下</p> 
 <pre><code class="go">type node struct {
    path      string           // 当前节点相对路径（与祖先节点的 path 拼接可得到完整路径）
    indices   string           // 所以孩子节点的path[0]组成的字符串
    children  []*node          // 孩子节点
    handlers  HandlersChain    // 当前节点的处理函数（包括中间件）
    priority  uint32           // 当前节点及子孙节点的实际路由数量
    nType     nodeType         // 节点类型
    maxParams uint8            // 子孙节点的最大参数数量
    wildChild bool             // 孩子节点是否有通配符（wildcard）
}</code></pre> 
 <h5>path 和 indices</h5> 
 <p>关于 <code>path</code> 和 <code>indices</code>，其实是使用了前缀树的逻辑。</p> 
 <p>举个栗子：<br>如果我们有两个路由，分别是 <code>/index</code>，<code>/inter</code>，则根节点为 <code>{path: "/in", indices: "dt"...}</code>，两个子节点为<code>{path: "dex", indices: ""}，{path: "ter", indices: ""}</code></p> 
 <h5>handlers</h5> 
 <p><code>handlers</code>里存储了该节点对应路由下的所有处理函数，处理业务逻辑时是这样的：</p> 
 <pre><code class="go">func (c *Context) Next() {
    c.index++
    for s := int8(len(c.handlers)); c.index &lt; s; c.index++ {
        c.handlers[c.index](c)
    }
}</code></pre> 
 <p>一般来说，除了最后一个函数，前面的函数被称为<strong>中间件</strong>。</p> 
 <p>如果某个节点的 <code>handlers</code>为空，则说明该节点对应的路由不存在。比如上面定义的根节点对应的路由 <code>/in</code> 是不存在的，它的 <code>handlers</code>就是<code>[]</code>。</p> 
 <h5>nType</h5> 
 <p>Gin 中定义了四种节点类型：</p> 
 <pre><code class="go">const (
    static nodeType = iota // 普通节点，默认
    root       // 根节点
    param      // 参数路由，比如 /user/:id
    catchAll   // 匹配所有内容的路由，比如 /article/*key
)</code></pre> 
 <p><code>param</code> 与 <code>catchAll</code> 使用的区别就是 <code>:</code> 与 <code>*</code> 的区别。<code>*</code> 会把路由后面的所有内容赋值给参数 <code>key</code>；但 <code>:</code> 可以多次使用。<br>比如：<code>/user/:id/:no</code> 是合法的，但 <code>/user/*id/:no</code> 是非法的，因为 <code>*</code> 后面所有内容会赋值给参数 <code>id</code>。</p> 
 <h5>wildChild</h5> 
 <p>如果孩子节点是通配符（<code>*</code>或者<code>:</code>），则该字段为 <code>true</code>。</p> 
 <h5>一个路由树的例子</h5> 
 <p>定义路由如下：</p> 
 <pre><code class="go">r.GET("/", func(context *gin.Context) {})
r.GET("/index", func(context *gin.Context) {})
r.GET("/inter", func(context *gin.Context) {})
r.GET("/go", func(context *gin.Context) {})
r.GET("/game/:id/:k", func(context *gin.Context) {})</code></pre> 
 <p>得到的路由树结构图为：<br><span class="img-wrap"><img src="https://images2.imgbox.com/3b/bd/dvZe5SGk_o.jpg" alt="路有树" title="路有树"></span></p> 
 <p>附一篇前缀树的文章，<a href="https://blog.csdn.net/u013949069/article/details/78056102">前缀树和后缀树</a></p> 
 <hr> 
 <p><span class="img-wrap"><img src="https://images2.imgbox.com/8a/22/GqUByrkT_o.png" alt="图片描述" title="图片描述"></span></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e569e558726625c331518fe50af690ae/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux之终端信息输出到日志文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e3a2a349d0d81e9df72413cd7996b65c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于Redis简易缓存对象存储设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>