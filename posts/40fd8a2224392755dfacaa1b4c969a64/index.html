<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL事务管理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL事务管理" />
<meta property="og:description" content="MySQL事务管理 事务的概念 事务的概念
事务由一条或多条SQL语句组成，这些语句在逻辑上存在相关性，共同完成一个任务，事务主要用于处理操作量大，复杂度高的数据。比如转账就涉及多条SQL语句，包括查询余额（select）、在当前账户上减去指定金额（update）、在指定账户上加上对应金额（update）等，将这多条SQL语句打包便构成了一个事务。MySQL同一时刻可能存在大量事务，如果不对这些事务加以控制，在执行时就可能会出现问题。比如单个事务内部的某些SQL语句执行失败，或是多个事务同时访问同一份数据导致数据不一致的问题。 因此一个完整的事务并不是简单的SQL集合，事务还需要满足如下四个属性：
原子性： 一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中如果发生错误，则会自动回滚到事务开始前的状态，就像这个事务从来没有执行过一样。持久性： 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。隔离性： 数据库允许多个事务同时访问同一份数据，隔离性可以保证多个事务在并发执行时，不会因为由于交叉执行而导致数据的不一致。一致性： 在事务开始之前和事务结束以后，数据库的完整型没有被破坏，这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联型以及后续数据库可以自发性地完成预定的工作。 上面的四个属性简称ACID：
原子性（Atomicity，又称不可分割性）。一致性（Consistency）。隔离性（Isolation，又称独立性）。持久性（Durability）。 为什么会出现事务？
事务被MySQL编写者设计出来，本质是为了当应用程序访问数据库的时候，事务能够简化我们的编程模型，不需要用户自己去考虑各种各样的潜在错误和并发问题。
如果MySQL只是单纯的提供数据存储服务，那么用户在访问数据库时就需要自行考虑各种潜在问题，包括网络异常、服务器宕机等。因此事务本质是为了应用服务的，而不是伴随着数据库系统天生就有的。
事务的版本支持 事务的版本支持
通过show engines命令可以查看数据库引擎。如下：
说明一下：
Engine： 表示存储引擎的名称。Support： 表示服务器对存储引擎的支持级别，YES表示支持，NO表示不支持，DEFAULT表示数据库默认使用的存储引擎，DISABLED表示支持引擎但已将其禁用。Comment： 表示存储引擎的简要说明。Transactions： 表示存储引擎是否支持事务，可以看到InnoDB存储引擎支持事务，而MyISAM存储引擎不支持事务。XA： 表示存储引擎是否支持XA事务。Savepoints： 表示存储引擎是否支持保存点。 事务的提交方式 查看事务的提交方式
事务常见的提交方式有两种，分别是自动提交和手动提交。
通过show命令查看autocommit全局变量，可以查看事务的自动提交是否被打开。如下：
说明一下： autocommit的值为ON表示自动提交被打开，值为OFF表示自动提交被关闭，即事务的提交方式为手动提交。
设置事务的提交方式
通过set命令设置autocommit全局变量的值，可以打开或关闭事务的自动提交。如下：说明一下： 将autocommit的值设置为1表示打开自动提交，设置为0表示关闭自动提交，相当于将事务提交方式设置为手动提交。
事务的相关演示 准备测试表
为了便于演示，我们将MySQL的隔离级别设置成读未提交，也就是把隔离级别设置的比较低，方便看到实验现象。如下：
需要注意的是，设置全局隔离级别后当前会话的隔离级别不会改变，只会影响后续与MySQL新建立的连接，因此需要重启终端才能看到会话的隔离级别被成功设置。如下：
创建一个银行用户表，表中包含用户的id、姓名和账户余额。如下：
演示一：事务的常规操作
启动两个终端，左终端使用begin或start transaction命令启动一个事务，右终端查看银行用户表中的信息。如下：
左终端中的事务向表中插入一条记录，由于我们将隔离级别设置成了读未提交，因此在左终端中的事务使用commit提交之前，在右终端中就能查看到事务向表中插入的记录。如下：
左终端中的事务使用savepoint命令创建一个保存点，然后继续向表中插入一条记录，这时在右终端中也能看到新插入的这条记录。如下：
左终端中的事务使用rollback命令回滚到保存点，这时右终端在查看表中数据时就看不到刚才插入的第二条记录了。如下：
左终端中的事务使用rollback命令回滚到事务最开始，这时右终端在查看表中数据时就看不到任何记录了。如下：
说明一下：
使用begin或start transaction命令，可以启动一个事务。使用savepoint 保存点命令，可以在事务中创建指定名称的保存点。使用rollback to 保存点命令，可以让事务回滚到指定保存点。使用rollback命令，可以直接让事务回滚到最开始。使用commit命令，可以提交事务，提交事务后就不能回滚了。 演示二：原子性
在左终端中启动一个事务，在右终端查看银行用户表中的信息。如下：
左终端中的事务向表中插入一条记录，由于隔离级别是读未提交，因此在右终端中能够查询到插入的这条记录。如下：
如果左终端中的事务在提交之前因为某些原因与MySQL断开连接，那么MySQL会自动让事务回滚到最开始，这时右终端中就看不到之前插入的记录了。如下：
演示三：持久性
在左终端中启动一个事务，在右终端查看银行用户表中的信息。如下：
左终端中的事务向表中插入一条记录，由于隔离级别是读未提交，因此在右终端中能够查询到插入的这条记录。如下：
左终端中的事务在提交后与MySQL断开连接，这时右终端中仍然可以看到之前插入的记录，因为事务提交后数据就被持久化了。如下：
演示四：begin会自动更改提交方式
通过show命令查看autocommit的值为ON，表示事务的提交方式是自动提交，此时银行用户表中有一条记录。如下：
在左终端中启动一个事务并向表中新插入一条记录，由于隔离级别是读未提交，因此在右终端中能够查询到新插入的这条记录。如下：
如果左终端中的事务在提交之前与MySQL断开连接，那么MySQL依旧会自动让事务回滚到最开始，这时右终端中就看不到之前新插入的记录了。如下：
也就是说，使用begin或start transaction命令启动的事务，都必须要使用commit命令手动提交，数据才会被持久化，与是否设置autocommit无关。
演示五：单条SQL与事务的关系" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/40fd8a2224392755dfacaa1b4c969a64/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-07T21:41:51+08:00" />
<meta property="article:modified_time" content="2023-07-07T21:41:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL事务管理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<h2><a id="MySQL_1"></a>MySQL事务管理</h2> 
<p></p> 
<h3><a id="_3"></a>事务的概念</h3> 
<blockquote> 
 <p>事务的概念</p> 
</blockquote> 
<ul><li>事务由一条或多条SQL语句组成，这些语句在逻辑上存在相关性，共同完成一个任务，事务主要用于处理操作量大，复杂度高的数据。比如转账就涉及多条SQL语句，包括查询余额（select）、在当前账户上减去指定金额（update）、在指定账户上加上对应金额（update）等，将这多条SQL语句打包便构成了一个事务。</li><li>MySQL同一时刻可能存在大量事务，如果不对这些事务加以控制，在执行时就可能会出现问题。比如单个事务内部的某些SQL语句执行失败，或是多个事务同时访问同一份数据导致数据不一致的问题。</li></ul> 
<p>因此一个完整的事务并不是简单的SQL集合，事务还需要满足如下四个属性：</p> 
<ul><li><strong>原子性</strong>： 一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中如果发生错误，则会自动回滚到事务开始前的状态，就像这个事务从来没有执行过一样。</li><li><strong>持久性</strong>： 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li><li>隔离性： 数据库允许多个事务同时访问同一份数据，隔离性可以保证多个事务在并发执行时，不会因为由于交叉执行而导致数据的不一致。</li><li><strong>一致性</strong>： 在事务开始之前和事务结束以后，数据库的完整型没有被破坏，这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联型以及后续数据库可以自发性地完成预定的工作。</li></ul> 
<p>上面的四个属性简称ACID：</p> 
<ul><li>原子性（Atomicity，又称不可分割性）。</li><li>一致性（Consistency）。</li><li>隔离性（Isolation，又称独立性）。</li><li>持久性（Durability）。</li></ul> 
<blockquote> 
 <p>为什么会出现事务？</p> 
</blockquote> 
<p>事务被MySQL编写者设计出来，本质是为了当应用程序访问数据库的时候，事务能够简化我们的编程模型，不需要用户自己去考虑各种各样的潜在错误和并发问题。<br>如果MySQL只是单纯的提供数据存储服务，那么用户在访问数据库时就需要自行考虑各种潜在问题，包括网络异常、服务器宕机等。因此事务本质是为了应用服务的，而不是伴随着数据库系统天生就有的。<br> </p> 
<h3><a id="_28"></a>事务的版本支持</h3> 
<blockquote> 
 <p>事务的版本支持</p> 
</blockquote> 
<p>通过show engines命令可以查看数据库引擎。如下：<img src="https://images2.imgbox.com/c6/e3/ZYiFmPDe_o.png" alt="image.png"></p> 
<p>说明一下：</p> 
<ul><li><strong>Engine</strong>： 表示存储引擎的名称。</li><li><strong>Support</strong>： 表示服务器对存储引擎的支持级别，YES表示支持，NO表示不支持，DEFAULT表示数据库默认使用的存储引擎，DISABLED表示支持引擎但已将其禁用。</li><li><strong>Comment</strong>： 表示存储引擎的简要说明。</li><li><strong>Transactions</strong>： 表示存储引擎是否支持事务，可以看到InnoDB存储引擎支持事务，而MyISAM存储引擎不支持事务。</li><li><strong>XA</strong>： 表示存储引擎是否支持XA事务。</li><li><strong>Savepoints</strong>： 表示存储引擎是否支持保存点。</li></ul> 
<p></p> 
<h3><a id="_43"></a>事务的提交方式</h3> 
<blockquote> 
 <p>查看事务的提交方式</p> 
</blockquote> 
<p>事务常见的提交方式有两种，分别是自动提交和手动提交。</p> 
<p>通过show命令查看autocommit全局变量，可以查看事务的自动提交是否被打开。如下：<img src="https://images2.imgbox.com/a3/e8/bZt2FqVc_o.png" alt="image.png"><br><strong>说明一下：</strong> autocommit的值为ON表示自动提交被打开，值为OFF表示自动提交被关闭，即事务的提交方式为手动提交。</p> 
<blockquote> 
 <p>设置事务的提交方式</p> 
</blockquote> 
<p>通过set命令设置autocommit全局变量的值，可以打开或关闭事务的自动提交。如下：<img src="https://images2.imgbox.com/c8/71/rq0ToTUE_o.png" alt="image.png"><strong>说明一下：</strong> 将autocommit的值设置为1表示打开自动提交，设置为0表示关闭自动提交，相当于将事务提交方式设置为手动提交。</p> 
<p></p> 
<h3><a id="_55"></a>事务的相关演示</h3> 
<blockquote> 
 <p>准备测试表</p> 
</blockquote> 
<p>为了便于演示，我们将MySQL的<a href="https://so.csdn.net/so/search?q=%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB&amp;spm=1001.2101.3001.7020">隔离级别</a>设置成读未提交，也就是把隔离级别设置的比较低，方便看到实验现象。如下：<img src="https://images2.imgbox.com/36/19/mdRJQwZR_o.png" alt="image.png"></p> 
<p>需要注意的是，设置全局隔离级别后当前会话的隔离级别不会改变，只会影响后续与MySQL新建立的连接，因此需要重启终端才能看到会话的隔离级别被成功设置。如下：<img src="https://images2.imgbox.com/eb/98/9mSr89HC_o.png" alt="image.png"></p> 
<p>创建一个银行用户表，表中包含用户的id、姓名和账户余额。如下：<br><img src="https://images2.imgbox.com/bf/26/JmzVPxWj_o.png" alt="image.png"><br></p> 
<blockquote> 
 <p>演示一：事务的常规操作</p> 
</blockquote> 
<p>启动两个终端，左终端使用begin或start transaction命令启动一个事务，右终端查看银行用户表中的信息。如下：<img src="https://images2.imgbox.com/62/1d/K5kqI3lV_o.png" alt="image.png"></p> 
<p>左终端中的事务向表中插入一条记录，由于我们将隔离级别设置成了读未提交，因此在左终端中的事务使用commit提交之前，在右终端中就能查看到事务向表中插入的记录。如下：<img src="https://images2.imgbox.com/e1/e4/ZelZwY7n_o.png" alt="image.png"></p> 
<p>左终端中的事务使用savepoint命令创建一个保存点，然后继续向表中插入一条记录，这时在右终端中也能看到新插入的这条记录。如下：<img src="https://images2.imgbox.com/75/04/lxWsE1tX_o.png" alt="image.png"></p> 
<p>左终端中的事务使用rollback命令回滚到保存点，这时右终端在查看表中数据时就看不到刚才插入的第二条记录了。如下：<img src="https://images2.imgbox.com/cf/d6/xDXOy7mD_o.png" alt="image.png"></p> 
<p>左终端中的事务使用rollback命令回滚到事务最开始，这时右终端在查看表中数据时就看不到任何记录了。如下：<img src="https://images2.imgbox.com/76/37/GzBTEZav_o.png" alt="image.png"></p> 
<p>说明一下：</p> 
<ul><li>使用begin或start transaction命令，可以启动一个事务。</li><li>使用savepoint 保存点命令，可以在事务中创建指定名称的保存点。</li><li>使用rollback to 保存点命令，可以让事务回滚到指定保存点。</li><li>使用rollback命令，可以直接让事务回滚到最开始。</li><li>使用commit命令，可以提交事务，提交事务后就不能回滚了。</li></ul> 
<blockquote> 
 <p>演示二：原子性</p> 
</blockquote> 
<p>在左终端中启动一个事务，在右终端查看银行用户表中的信息。如下：<img src="https://images2.imgbox.com/09/2f/kx5vdw6z_o.png" alt="image.png"></p> 
<p>左终端中的事务向表中插入一条记录，由于隔离级别是读未提交，因此在右终端中能够查询到插入的这条记录。如下：<br><img src="https://images2.imgbox.com/c4/d7/CfbBaCzg_o.png" alt="image.png"></p> 
<p>如果左终端中的事务在提交之前因为某些原因与MySQL断开连接，那么MySQL会自动让事务回滚到最开始，这时右终端中就看不到之前插入的记录了。如下：<img src="https://images2.imgbox.com/44/0d/r16vUPvo_o.png" alt="image.png"></p> 
<blockquote> 
 <p>演示三：持久性</p> 
</blockquote> 
<p>在左终端中启动一个事务，在右终端查看银行用户表中的信息。如下：<img src="https://images2.imgbox.com/00/be/E7937rJs_o.png" alt="image.png"></p> 
<p>左终端中的事务向表中插入一条记录，由于隔离级别是读未提交，因此在右终端中能够查询到插入的这条记录。如下：<img src="https://images2.imgbox.com/dc/b7/1baj6QsN_o.png" alt="image.png"></p> 
<p>左终端中的事务在提交后与MySQL断开连接，这时右终端中仍然可以看到之前插入的记录，因为事务提交后数据就被持久化了。如下：<img src="https://images2.imgbox.com/4c/76/vqvRsp2U_o.png" alt="image.png"></p> 
<blockquote> 
 <p>演示四：begin会自动更改提交方式</p> 
</blockquote> 
<p>通过show命令查看autocommit的值为ON，表示事务的提交方式是自动提交，此时银行用户表中有一条记录。如下：<img src="https://images2.imgbox.com/54/44/3f63SypB_o.png" alt="image.png"></p> 
<p>在左终端中启动一个事务并向表中新插入一条记录，由于隔离级别是读未提交，因此在右终端中能够查询到新插入的这条记录。如下：<br><img src="https://images2.imgbox.com/a4/51/3hhH6lh0_o.png" alt="image.png"></p> 
<p>如果左终端中的事务在提交之前与MySQL断开连接，那么MySQL依旧会自动让事务回滚到最开始，这时右终端中就看不到之前新插入的记录了。如下：<img src="https://images2.imgbox.com/e0/58/kWv2LHE3_o.png" alt="image.png"></p> 
<p>也就是说，使用begin或start transaction命令启动的事务，都必须要使用commit命令手动提交，数据才会被持久化，与是否设置autocommit无关。</p> 
<blockquote> 
 <p>演示五：单条SQL与事务的关系</p> 
</blockquote> 
<ul><li>实际全局变量autocommit是否被设置影响的是单条SQL语句，InnoDB中的每一条SQL都会默认被封装成事务。</li><li>autocommit为ON，则单条SQL语句执行后会自动被提交，如果为OFF，则SQL语句执行后需要使用commit进行手动提交。</li></ul> 
<p>比如通过show命令查看autocommit的值为ON，表示事务的提交方式是自动提交，此时银行用户表中有一条记录。如下：<br><img src="https://images2.imgbox.com/3f/e0/nRnTOill_o.png" alt="image.png"></p> 
<p>在左终端中直接向表中新插入一条记录，由于隔离级别是读未提交，因此在右终端中肯定能够查询到新插入的这条记录。如下：<img src="https://images2.imgbox.com/dc/89/a026eU5F_o.png" alt="image.png"></p> 
<p>但就算左终端在执行单条SQL后不使用commit进行提交，而直接与MySQL断开连接，这时右终端仍然可以看到之前新插入的记录了，因为单条SQL在执行后被自动提交持久化了。如下：<br><img src="https://images2.imgbox.com/d5/e3/NJHG0E62_o.png" alt="image.png"></p> 
<p>相反，如果将autocommit设置为OFF，表示事务执行后需要手动提交，此时银行用户表中有两条记录。如下：<img src="https://images2.imgbox.com/39/d0/cIC6ys0b_o.png" alt="image.png"></p> 
<p>在左终端中直接向表中新插入一条记录，由于隔离级别是读未提交，因此在右终端中肯定能够查询到新插入的这条记录。如下：<img src="https://images2.imgbox.com/75/04/cpoovA4D_o.png" alt="image.png"></p> 
<p>但如果此时左终端在执行单条SQL后不使用commit进行提交，而直接与MySQL断开连接，那么这时右终端中就看不到之前新插入的记录了，因为这时单条SQL执行后需要使用commit手动提交后才会持久化，在commit之前与MySQL断开连接则会自动进行回滚操作。如下：<br><img src="https://images2.imgbox.com/5d/e6/mYtEd2Dn_o.png" alt="image.png"></p> 
<p>也就是说，实际我们之前一直都在使用单SQL事务，只不过autocommit默认是打开的，因此单SQL事务执行后自动就被提交了。</p> 
<p></p> 
<h3><a id="_137"></a>事务的隔离级别</h3> 
<ul><li>MySQL服务可能会同时被多个客户端进程（线程）访问，访问的方式以事务的方式进行。</li><li>一个事务可能由多条SQL语句构成，也就意味着任何一个事务，都有执行前、执行中和执行后三个阶段，而所谓的原子性就是让用户层要么看到执行前，要么看到执行后，执行中如果出现问题，可以随时进行回滚，所以单个事务对用户表现出来的特性就是原子性。</li><li>但毕竟每个事务都有一个执行的过程，在多个事务各自执行自己的多条SQL时，仍然可能会出现互相影响的情况，比如多个事务同时访问同一张表，甚至是表中的同一条记录。</li><li>数据库为了保证事务执行过程中尽量不受干扰，于是出现了隔离性的概念，而数据库为了允许事务在执行过程中受到不同程度的干扰，于是出现了隔离级别的概念。</li></ul> 
<p>数据库事务的隔离级别有以下四种：</p> 
<ul><li><strong>读未提交（Read Uncommitted）</strong>： 在该隔离级别下，所有的事务都可以看到其他事务没有提交的执行结果，实际生产中不可能使用这种隔离级别，因为这种隔离级别相当于没有任何隔离性，会存在很多并发问题，如脏读、幻读、不可重复读等。</li><li><strong>读提交（Read Committed）</strong>： 该隔离级别是大多数数据库的默认隔离级别，但它不是MySQL默认的隔离级别，它满足了隔离的简单定义：一个事务只能看到其他已经提交的事务所做的改变，但这种隔离级别存在不可重复读和幻读的问题。</li><li><strong>可重复读（Repeatable Read）</strong>： 这是MySQL默认的隔离级别，该隔离级别确保同一个事务在执行过程中，多次读取操作数据时会看到同样的数据，即解决了不可重复读的问题，但这种隔离级别下仍然存在幻读的问题。</li><li><strong>串行化（Serializable）</strong>： 这是事务的最高隔离级别，该隔离级别通过强制事务排序，使之不可能相互冲突，从而解决了幻读问题。它在每个读的数据行上面加上共享锁，但是可能会导致超时和锁竞争问题，这种隔离级别太极端，实际生成中基本不使用。</li></ul> 
<p><strong>说明一下：</strong></p> 
<ul><li>虽然数据库事务的隔离级别有以上四种，但一个稳态的数据库只会选择这其中的一种，作为自己的默认隔离级别。但数据库默认的隔离级别有时可能并不满足上层的业务需求，因此数据库提供了这四种隔离级别，可以让我们自行设置。</li><li>隔离级别基本上都是通过加锁的方式实现的，不同的隔离级别对锁的使用是不同的，常见的有表锁、行锁、写锁、间隙锁（GAP）、Next-Key锁（GAP+行锁）等。</li></ul> 
<p></p> 
<h4><a id="_158"></a>查看与设置隔离级别</h4> 
<blockquote> 
 <p>查看全局隔离级别</p> 
</blockquote> 
<p>通过select @@global.tx_isolation命令，可以查看全局隔离级别。如下：<img src="https://images2.imgbox.com/23/0f/J7umRezi_o.png" alt="image.png"></p> 
<blockquote> 
 <p>查看会话隔离级别</p> 
</blockquote> 
<p>通过select @@session.tx_isolation命令，可以查看当前会话的隔离级别。如下：<img src="https://images2.imgbox.com/f0/32/Mw42TUCa_o.png" alt="image.png"></p> 
<p>此外，通过select @@tx_isolation命令，也可以查看当前会话的隔离级别。如下：<br> <img src="https://images2.imgbox.com/3c/71/btD34gEz_o.png" alt="image.png"></p> 
<blockquote> 
 <p>设置会话隔离级别</p> 
</blockquote> 
<p>通过set session transaction isolation level 隔离级别命令，可以设置当前会话的隔离级别。如下：<img src="https://images2.imgbox.com/b5/d3/GZZY5hBG_o.png" alt="image.png"><br><strong>说明一下：</strong> 设置会话的隔离级别只会影响当前会话，新起的会话依旧采用全局隔离级。</p> 
<blockquote> 
 <p>设置全局隔离级别</p> 
</blockquote> 
<p>通过set global transaction isolation level 隔离级别命令，可以设置全局隔离级别。如下：<img src="https://images2.imgbox.com/de/25/s6DME55y_o.png" alt="image.png"><strong>说明一下：</strong> 设置全局隔离级别会影响后续的新会话，但当前会话的隔离级别没有发生变化，如果要让当前会话的隔离级别也改变，则需要重启会话。</p> 
<p></p> 
<h4><a id="Read_Uncommitted_180"></a>读未提交（Read Uncommitted）</h4> 
<blockquote> 
 <p>读未提交（Read Uncommitted）</p> 
</blockquote> 
<p>启动两个终端，将隔离级别都设置为读未提交，并查看此时银行用户表中的数据。如下：<img src="https://images2.imgbox.com/e4/c1/k1Sv2LYf_o.png" alt="image.png"></p> 
<p>在两个终端各自启动一个事务，左终端中的事务所作的修改在没有提交之前，右终端中的事务就已经能够看到了。如下：<img src="https://images2.imgbox.com/03/e0/3Eusuabz_o.png" alt="image.png"></p> 
<p><strong>说明一下：</strong></p> 
<ul><li>读未提交是事务的最低隔离级别，几乎没有加锁，虽然效率高，但是问题比较多，所以严重不建议使用。</li><li>一个事务在执行过程中，读取到另一个执行中的事务所做的修改，但是该事务还没有进行提交，这种现象叫做脏读。</li></ul> 
<p></p> 
<h4><a id="Read_Committed_195"></a>读提交（Read Committed）</h4> 
<blockquote> 
 <p>读提交（Read Committed）</p> 
</blockquote> 
<p>启动两个终端，将隔离级别都设置为读提交，并查看此时银行用户表中的数据。如下：<img src="https://images2.imgbox.com/67/fd/Lg0o8Ypx_o.png" alt="image.png"></p> 
<p>在两个终端各自启动一个事务，左终端中的事务所做的修改在没有提交之前，右终端中的事务无法看到。如下：<br><img src="https://images2.imgbox.com/7e/16/QCDEXQkx_o.png" alt="image.png"></p> 
<p>只有当左终端中的事务提交后，右终端中的事务才能看到修改后的数据。如下：<img src="https://images2.imgbox.com/88/e8/VvWKYRDO_o.png" alt="image.png"></p> 
<p><strong>说明一下：</strong></p> 
<ul><li>一个事务在执行过程中，两个相同的select查询得到了不同的数据，这种现象叫做不可重复读。</li></ul> 
<p></p> 
<h4><a id="Repeatable_Read_210"></a>可重复读（Repeatable Read）</h4> 
<blockquote> 
 <p>可重复读（Repeatable Read）</p> 
</blockquote> 
<p>启动两个终端，将隔离级别都设置为可重复读，并查看此时银行用户表中的数据。如下：<img src="https://images2.imgbox.com/ce/2b/YwmZmNKA_o.png" alt="image.png"></p> 
<p>在两个终端各自启动一个事务，左终端中的事务所作的修改在没有提交之前，右终端中的事务无法看到。如下：<br><img src="https://images2.imgbox.com/06/46/DJ6LdEBz_o.png" alt="image.png"></p> 
<p>并且当左终端中的事务提交后，右终端中的事务仍然看不到修改后的数据。如下：<img src="https://images2.imgbox.com/a2/09/HiC8X0Yq_o.png" alt="image.png"></p> 
<p>只有当右终端中的事务提交后再查看表中的数据，这时才能看到修改后的数据。如下：<img src="https://images2.imgbox.com/19/2e/jV4iq8kB_o.png" alt="image.png"></p> 
<p><strong>说明一下：</strong></p> 
<ul><li>在可重复读隔离级别下，一个事务在执行过程中，相同的select查询得到的是相同的数据，这就是所谓的可重复读。</li><li>一般的数据库在可重复读隔离级别下，update数据是满足可重复读的，但insert数据会存在幻读问题，因为隔离性是通过对数据加锁完成的，而新插入的数据原本是不存在的，因此一般的加锁无法屏蔽这类问题。</li><li>一个事务在执行过程中，相同的select查询得到了新的数据，如同出现了幻觉，这种现象叫做幻读。</li></ul> 
<p>MySQL解决了可重复读隔离级别下的幻读问题，比如重新在这两个终端各自启动一个事务，左终端中的事务向表中插入数据的在没有提交之前，右终端中的事务无法看到。如下：<br><img src="https://images2.imgbox.com/80/4d/iVmtwTZL_o.png" alt="image.png"></p> 
<p>并且当左终端中的事务提交后，右终端中的事务仍然看不到新插入的数据。如下：<img src="https://images2.imgbox.com/1f/e1/4ORePd6Z_o.png" alt="image.png"></p> 
<p>只有当右终端中的事务提交后再查看表中的数据，这时才能看到新插入的数据。如下：<img src="https://images2.imgbox.com/ed/8a/SlSLHSO1_o.png" alt="image.png"></p> 
<p><strong>说明一下：</strong></p> 
<ul><li>MySQL是通过Next-Key锁（GAP+行锁）来解决幻读问题的。</li></ul> 
<p></p> 
<h4><a id="Serializable_242"></a>串行化（Serializable）</h4> 
<blockquote> 
 <p>串行化（Serializable）</p> 
</blockquote> 
<p>启动两个终端，将隔离级别都设置为串行化，并查看此时银行用户表中的数据。如下：<img src="https://images2.imgbox.com/82/a2/aq21bFB9_o.png" alt="image.png"></p> 
<p>在两个终端各自启动一个事务，如果这两个事务都对表进行的是读操作，那么这两个事务可以并发执行，不会被阻塞。如下：<img src="https://images2.imgbox.com/06/7c/xEqWmO4q_o.png" alt="image.png"></p> 
<p>但如果这两个事务中有一个事务要对表进行写操作，那么这个事务就会立即被阻塞。如下：<img src="https://images2.imgbox.com/c0/41/njJdPqFl_o.png" alt="image.png"></p> 
<p>直到访问这张表的其他事务都提交后，这个被阻塞的事务才会被唤醒，然后才能对表进行修改操作。如下：<img src="https://images2.imgbox.com/9f/b7/QiVy2vUc_o.png" alt="image.png"></p> 
<p><strong>说明一下：</strong></p> 
<ul><li>串行化是事务的最高隔离级别，多个事务同时进行读操作时加的是共享锁，因此可以并发执行读操作，但一旦需要进行写操作，就会进行串行化，效率很低，几乎不会使用。</li></ul> 
<p></p> 
<h4><a id="_261"></a>隔离级别总结</h4> 
<blockquote> 
 <p>隔离级别总结</p> 
</blockquote> 
<p>对MySQL中的隔离级别总结如下：</p> 
<table><thead><tr><th><strong>隔离级别</strong></th><th><strong>脏读</strong></th><th><strong>不可重复读</strong></th><th><strong>幻读</strong></th><th><strong>加锁读</strong></th></tr></thead><tbody><tr><td>读未提交（read uncommitted）</td><td>√</td><td>√</td><td>√</td><td>不加锁</td></tr><tr><td>读已提交（read committed）</td><td>X</td><td>√</td><td>√</td><td>不加锁</td></tr><tr><td>可重复读（repeatable read）</td><td>X</td><td>X</td><td>X</td><td>不加锁</td></tr><tr><td>可串行化（serializable）</td><td>X</td><td>X</td><td>X</td><td>加锁</td></tr></tbody></table> 
<p>√：会发生该问题<br>X：不会发生该问题</p> 
<p><strong>说明一下：</strong></p> 
<ul><li>隔离级别越严格，安全性越高，但数据库的并发性能也就越低，在选择隔离级别时往往需要在两者之间找一个平衡点。</li><li>表中只写出了各种隔离级别下进行读操作时是否需要加锁，因为无论哪种隔离级别，只要需要进行写操作就一定需要加锁。<br> </li></ul> 
<h3><a id="_280"></a>关于一致性</h3> 
<blockquote> 
 <p>关于一致性</p> 
</blockquote> 
<p>事务执行的结果，必须使数据库从一个一致性状态，变到另一个一致性状态，当数据库只包含事务成功提交的结果时，数据库就处于一致性状态。</p> 
<ul><li>事务在执行过程中如果发生错误，则需要自动回滚到事务最开始的状态，就像这个事务从来没有执行过一样，即一致性需要原子性来保证。</li><li>事务处理结束后，对数据的修改必须是永久的，即便系统故障也不能丢失，即一致性需要持久性来保证。</li><li>多个事务同时访问同一份数据时，必须保证这多个事务在并发执行时，不会因为由于交叉执行而导致数据的不一致，即一致性需要隔离性来保证。</li><li>此外，一致性与用户的业务逻辑强相关，如果用户本身的业务逻辑有问题，最终也会让数据库处于一种不一致的状态。</li></ul> 
<p>也就是说，一致性实际是数据库最终要达到的效果，一致性不仅需要原子性、持久性和隔离性来保证，还需要上层用户编写出正确的业务逻辑。</p> 
<p></p> 
<h3><a id="_294"></a>多版本并发控制</h3> 
<blockquote> 
 <p>数据库的并发场景</p> 
</blockquote> 
<p>数据库并发的场景无非如下三种：</p> 
<ul><li>读-读并发：不存在任何问题，也不需要并发控制。</li><li>读-写并发：有线程安全问题，可能会存在事务隔离性问题，可能遇到脏读、幻读、不可重复读。</li><li>写-写并发：有线程安全问题，可能会存在两类更新丢失问题。</li></ul> 
<p><strong>说明一下：</strong></p> 
<ul><li>写-写并发场景下的第一类更新丢失又叫做回滚丢失，即一个事务的回滚把另一个已经提交的事务更新的数据覆盖了，第二类更新丢失又叫做覆盖丢失，即一个事务的提交把另一个已经提交的事务更新的数据覆盖了。</li><li>读-读并发不需要进行并发控制，写-写并发实际也就是对数据进行加锁，这里最值得讨论的是读-写并发，读-写并发是数据库当中最高频的场景，在解决读-写并发时不仅需要考虑线程安全问题，还需要考虑并发的性能问题。</li></ul> 
<blockquote> 
 <p>多版本并发控制</p> 
</blockquote> 
<ul><li>多版本并发控制（Multi-Version Concurrency Control，MVCC）是一种用来解决读写冲突的无锁并发控制，主要依赖记录中的3个隐藏字段、undo日志和Read View实现。</li><li>为事务分配单向增长的事务ID，为每个修改保存一个版本，将版本与事务ID相关联，读操作只读该事务开始前的数据库快照。</li><li>MVCC保证读写并发时，读操作不会阻塞写操作，写操作也不会阻塞读操作，提高了数据库并发读写的性能，同时还可以解决脏读、幻读和不可重复读等事务隔离性问题。</li></ul> 
<p></p> 
<h4><a id="3_316"></a>记录中的3个隐藏字段</h4> 
<blockquote> 
 <p>记录中的3个隐藏字段</p> 
</blockquote> 
<p>数据库表中的每条记录都会有如下3个隐藏字段：</p> 
<ul><li>DB_TRX_ID：6字节，创建或最近一次修改该记录的事务ID。</li><li>DB_ROW_ID：6字节，隐含的自增ID（隐藏主键）。</li><li>DB_ROLL_PTR：7字节，回滚指针，指向这条记录的上一个版本。</li></ul> 
<p><strong>说明一下：</strong></p> 
<ul><li>采用InnoDB存储引擎建立的每张表都会有一个主键，如果用户没有设置，InnoDB就会自动以DB_ROW_ID产生一个聚簇索引。</li><li>此外，数据库表中的每条记录还有一个删除flag隐藏字段，用于表示该条记录是否被删除，便于进行数据回滚。</li></ul> 
<blockquote> 
 <p>示例</p> 
</blockquote> 
<p>创建一个学生表，表中包含学生的姓名和年龄。如下：<img src="https://images2.imgbox.com/50/70/jqQnQZqt_o.png" alt="image.png"></p> 
<p>当向表中插入一条记录后，该记录不仅包含name和age字段，还包含三个隐藏字段。如下：<img src="https://images2.imgbox.com/fc/55/lYZ3SlSA_o.png" alt="image.png"></p> 
<p><strong>说明一下：</strong></p> 
<ul><li>假设插入该记录的事务的事务ID为9，那么该记录的DB_TRX_ID字段填的就是9。</li><li>因为这是插入的第一条记录，所以隐式主键DB_ROW_ID字段填的就是1。</li><li>由于这条记录是新插入的，没有历史版本，所以回滚指针DB_ROLL_PTR的值设置为null。</li><li>MVCC重点需要的就是这三个隐藏字段，实际还有其他隐藏字段，只不过没有画出。</li></ul> 
<p></p> 
<h4><a id="undo_347"></a>undo日志</h4> 
<blockquote> 
 <p>undo日志</p> 
</blockquote> 
<p>MySQL的三大日志如下：</p> 
<ul><li><strong>redo log</strong>：重做日志，用于MySQL崩溃后进行数据恢复，保证数据的持久性。</li><li><strong>bin log</strong>：逻辑日志，用于主从数据备份时进行数据同步，保证数据的一致性。</li><li><strong>undo log</strong>：回滚日志，用于对已经执行的操作进行回滚，保证事务的原子性。</li></ul> 
<p>MySQL会为上述三大日志开辟对应的缓冲区，用于存储日志相关的信息，必要时会将缓冲区中的数据刷新到磁盘。</p> 
<p><strong>说明一下：</strong></p> 
<ul><li>MVCC的实现主要依赖三大日志中的undo log，记录的历史版本就是存储在undo log对应的缓冲区中的。</li></ul> 
<p></p> 
<h4><a id="_365"></a>快照的概念</h4> 
<blockquote> 
 <p>快照的概念</p> 
</blockquote> 
<p>现在有一个事务ID为10的事务，要将刚才插入学生表中的记录的学生姓名改为“李四”：</p> 
<ul><li>因为是要进行写操作，所以需要先给该记录加行锁。</li><li>修改前，先将该行记录拷贝到undo log中，此时undo log中就有了一行副本数据。</li><li>然后再将原始记录中的学生姓名改为“李四”，并将该记录的DB_TRX_ID改为10，回滚指针DB_ROLL_PTR设置成undo log中副本数据的地址，从而指向该记录的上一个版本。</li><li>最后当事务10提交后释放锁，这时最新的记录就是学生姓名为“李四”的那条记录。</li></ul> 
<p>修改后的示意图如下：<img src="https://images2.imgbox.com/94/9a/XIbXPRkj_o.png" alt="image.png"></p> 
<p>现在又有一个事务ID为11的事务，要将刚才学生表中的那条记录的学生年龄改为38：</p> 
<ul><li>因为是要进行写操作，所以需要先给该记录（最新的记录）加行锁。</li><li>修改前，先将该行记录拷贝到undo log中，此时undo log中就又有了一行副本数据。</li><li>然后再将原始记录中的学生年龄改为38，并将该记录的DB_TRX_ID改为11，回滚指针DB_ROLL_PTR设置成刚才拷贝到undo log中的副本数据的地址，从而指向该记录的上一个版本。</li><li>最后当事务11提交后释放锁，这时最新的记录就是学生年龄为38的那条记录。</li></ul> 
<p>修改后的示意图如下：<br><img src="https://images2.imgbox.com/4c/be/A0XxV79w_o.png" alt="image.png"></p> 
<p>此时我们就有了一个基于链表记录的历史版本链，而undo log中的一个个的历史版本就称为一个个的快照。</p> 
<p><strong>说明一下：</strong></p> 
<ul><li>所谓的回滚实际就是用undo log中的历史数据覆盖当前数据，而所谓的创建保存点就可以理解成是给某些版本做了标记，让我们可以直接用这些版本数据来覆盖当前数据。</li><li>这种技术实际就是基于版本的写时拷贝，当需要进行写操作时先将最新版本拷贝一份到undo log中，然后再进行写操作，和父子进程为了保证独立性而进行的写时拷贝是类似的。</li></ul> 
<blockquote> 
 <p>insert和delete的记录如何维护版本链？</p> 
</blockquote> 
<ul><li>删除记录并不是真的把数据删除了，而是先将该记录拷贝一份放入undo log中，然后将该记录的删除flag隐藏字段设置为1，这样回滚后该记录的删除flag隐藏字段就又变回0了，相当于删除的数据又恢复了。</li><li>新插入的记录是没有历史版本的，但是一般为了回滚操作，新插入的记录也需要拷贝一份放入undo log中，只不过被拷贝到undo log中的记录的删除flag隐藏字段被设置为1，这样回滚后就相当于新插入的数据就被删除了。</li></ul> 
<p>也就是说，增加、删除和修改数据都是可以形成版本链的。</p> 
<blockquote> 
 <p>当前读 VS 快照读</p> 
</blockquote> 
<ul><li>当前读：读取最新的记录，就叫做当前读。</li><li>快照读：读取历史版本，就叫做快照读。</li></ul> 
<p>事务在进行增删查改的时候，并不是都需要进行加锁保护：</p> 
<ul><li>事务对数据进行增删改的时候，操作的都是最新记录，即当前读，需要进行加锁保护。</li><li>事务在进行select查询的时候，既可能是当前读也可能是快照读，如果是当前读，那也需要进行加锁保护，但如果是快照读，那就不需要加锁，因为历史版本不会被修改，也就是可以并发执行，提高了效率，这也就是MVCC的意义所在。</li></ul> 
<p>而select查询时应该进行当前读还是快照读，则是由隔离级别决定的，在读未提交和串行化隔离级别下，进行的都是当前读，而在读提交和可重复读隔离级别下，既可能进行当前读也可能进行快照读。</p> 
<blockquote> 
 <p>undo log中的版本链何时才会被清除？</p> 
</blockquote> 
<ul><li>在undo log中形成的版本链不仅仅是为了进行回滚操作，其他事务在执行过程中也可能读取版本链中的某个版本，也就是快照读。</li><li>因此，只有当某条记录的最新版本已经修改并提交，并且此时没有其他事务与该记录的历史版本有关了，这时该记录在undo log中的版本链才可以被清除。</li></ul> 
<p><strong>说明一下：</strong></p> 
<ul><li>对于新插入的记录来说，没有其他事务会访问它的历史版本，因此新插入的记录在提交后就可以将undo log中的版本链清除了。</li><li>因此版本链在undo log中可能会存在很长时间，尤其是有其他事务和这个版本链相关联的时候，但这也没有坏处，这说明它是一个热数据。</li></ul> 
<p></p> 
<h4><a id="Read_View_428"></a>Read View</h4> 
<blockquote> 
 <p>Read View</p> 
</blockquote> 
<ul><li>事务在进行快照读操作时会生成读视图Read View，在该事务执行快照读的那一刻，会生成数据库系统当前的一个快照，记录并维护系统当前活跃的事务ID。</li><li>Read View在MySQL源码中就是一个类，本质是用来进行可见性判断的，当事务对某个记录执行快照读的时候，对该记录创建一个Read View，根据这个Read View来判断，当前事务能够看到该记录的哪个版本的数据。</li></ul> 
<p>ReadView类的源码如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">ReadView</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">// 省略...</span>
<span class="token keyword">private</span><span class="token operator">:</span>
<span class="token comment">/** 高水位：大于等于这个ID的事务均不可见*/</span>
trx_id_t m_low_limit_id<span class="token punctuation">;</span>

<span class="token comment">/** 低水位：小于这个ID的事务均可见 */</span>
trx_id_t m_up_limit_id<span class="token punctuation">;</span>

<span class="token comment">/** 创建该 Read View 的事务ID*/</span>
trx_id_t m_creator_trx_id<span class="token punctuation">;</span>

<span class="token comment">/** 创建视图时的活跃事务id列表*/</span>
ids_t m_ids<span class="token punctuation">;</span>

<span class="token comment">/** 配合purge，标识该视图不需要小于m_low_limit_no的UNDO LOG，
* 如果其他视图也不需要，则可以删除小于m_low_limit_no的UNDO LOG*/</span>
trx_id_t m_low_limit_no<span class="token punctuation">;</span>

<span class="token comment">/** 标记视图是否被关闭*/</span>
<span class="token keyword">bool</span> m_closed<span class="token punctuation">;</span>

<span class="token comment">// 省略...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

</code></pre> 
<p><strong>部分成员说明：</strong></p> 
<ul><li>m_ids： 一张列表，记录Read View生成时刻，系统中活跃的事务ID。</li><li>m_up_limit_id： 记录m_ids列表中事务ID最小的ID。</li><li>m_low_limit_id： 记录Read View生成时刻，系统尚未分配的下一个事务ID。</li><li>m_creator_trx_id： 记录创建该Read View的事务的事务ID。</li></ul> 
<p>由于事务ID是单向增长的，因此根据Read View中的m_up_limit_id和m_low_limit_id，可以将事务ID分为三个部分：</p> 
<ul><li>事务ID小于m_up_limit_id的事务，一定是生成Read View时已经提交的事务，因为m_up_limit_id是生成Read View时刻系统中活跃事务ID中的最小ID，因此事务ID比它小的事务在生成Read View时一定已经提交了。</li><li>事务ID大于等于m_low_limit_id的事务，一定是生成Read View时还没有启动的事务，因为m_low_limit_id是生成Read View时刻，系统尚未分配的下一个事务ID。</li><li>事务ID位于m_up_limit_id和m_low_limit_id之间的事务，在生成Read View时可能正处于活跃状态，也可能已经提交了，这时需要通过判断事务ID是否存在于m_ids中来判断该事务是否已经提交。</li></ul> 
<p>示意图如下：<img src="https://images2.imgbox.com/23/c2/JCwE7VOj_o.png" alt="image.png"></p> 
<ul><li>一个事务在进行读操作时，只应该看到自己或已经提交的事务所作的修改，因此我们可以根据Read View来判断当前事务能否看到另一个事务所作的修改。</li><li>版本链中的每个版本的记录都有自己的DB_TRX_ID，即创建或最近一次修改该记录的事务ID，因此可以依次遍历版本链中的各个版本，通过Read View来判断当前事务能否看到这个版本，如果不能则继续遍历下一个版本。</li></ul> 
<p>源码策略如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">changes_visible</span><span class="token punctuation">(</span>trx_id_t id<span class="token punctuation">,</span> <span class="token keyword">const</span> table_name_t<span class="token operator">&amp;</span> name<span class="token punctuation">)</span> <span class="token keyword">const</span> 
	<span class="token function">MY_ATTRIBUTE</span><span class="token punctuation">(</span><span class="token punctuation">(</span>warn_unused_result<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token function">ut_ad</span><span class="token punctuation">(</span>id <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//1、事务id小于m_up_limit_id（已提交）或事务id为创建该Read View的事务的id，则可见</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">&lt;</span> m_up_limit_id <span class="token operator">||</span> id <span class="token operator">==</span> m_creator_trx_id<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token function">check_trx_id_sanity</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//2、事务id大于等于m_low_limit_id（生成Read View时还没有启动的事务），则不可见</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>id <span class="token operator">&gt;=</span> m_low_limit_id<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//3、事务id位于m_up_limit_id和m_low_limit_id之间，并且活跃事务id列表为空（即不在活跃列表中），则可见</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>m_ids<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">const</span> ids_t<span class="token double-colon punctuation">::</span>value_type<span class="token operator">*</span> p <span class="token operator">=</span> m_ids<span class="token punctuation">.</span><span class="token function">data</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//4、事务id位于m_up_limit_id和m_low_limit_id之间，如果在活跃事务id列表中则不可见，如果不在则可见</span>
	<span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token operator">!</span>std<span class="token double-colon punctuation">::</span><span class="token function">binary_search</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> p <span class="token operator">+</span> m_ids<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><strong>说明一下：</strong> 使用该函数时将版本的DB_TRX_ID传给参数id，该函数的作用就是根据Read View，判断当前事务能否看到这个版本。</p> 
<p></p> 
<h3><a id="RRRC_513"></a>RR与RC的本质区别</h3> 
<blockquote> 
 <p>现象演示</p> 
</blockquote> 
<p>启动两个终端，将隔离级别都设置为可重复读，并查看此时银行用户表中的数据。如下：<img src="https://images2.imgbox.com/0f/e3/eYiEiGTi_o.png" alt="image.png"></p> 
<p>在两个终端各自启动一个事务，在左终端中的事务操作之前，先让右终端中的事务查看一下表中的信息。如下：<img src="https://images2.imgbox.com/f8/bd/rX3bRGUU_o.png" alt="image.png"></p> 
<p>左终端中的事务对表中的信息进行修改并提交，右终端中的事务看不到修改后的数据。如下：<img src="https://images2.imgbox.com/46/9d/iymlRBkL_o.png" alt="image.png"></p> 
<p>在右终端中使用select … lock in share mode命令进行当前读，可以看到表中的数据确实是被修改了，只是右终端中的事务看不到而已。如下：<img src="https://images2.imgbox.com/18/3b/hBBTQZ7m_o.png" alt="image.png"></p> 
<p>但如果修改一下SQL的执行顺序，在两个终端各自启动一个事务后，直接让左终端中的事务对表中的信息进行修改并提交，然后再让右终端中的事务进行查看，这时右终端中的事务就直接看到了修改后的数据。如下：<br><img src="https://images2.imgbox.com/9a/ac/3IeSM8fD_o.png" alt="image.png"></p> 
<p>在右终端中使用select … lock in share mode命令进行当前读，可以看到刚才读取到的确实是最新的数据。如下：<img src="https://images2.imgbox.com/c3/70/jonZ4Mvg_o.png" alt="image.png"></p> 
<p><strong>说明一下：</strong></p> 
<ul><li>上面两次实验的唯一区别在于，右终端中的事务在左终端中的事务修改数据之前是否进行过快照读。</li><li>由于RR级别下要求事务内每次读取到的结果必须是相同的，因此事务首次进行快照读的地方，决定了该事务后续快照读结果的能力。</li></ul> 
<blockquote> 
 <p>RR与RC的本质区别</p> 
</blockquote> 
<ul><li>正是因为Read View生成时机的不同，从而造成了RC和RR级别下快照读的结果的不同。</li><li>在RR级别下，事务第一次进行快照读时会创建一个Read View，将当前系统中活跃的事务记录下来，此后再进行快照读时就会直接使用这个Read View进行可见性判断，因此当前事务看不到第一次快照读之后其他事务所作的修改。</li><li>而在RC级别下，事务每次进行快照读时都会创建一个Read View，然后根据这个Read View进行可见性判断，因此每次快照读时都能读取到被提交了的最新的数据。</li><li>RR级别下快照读只会创建一次Read View，所以RR级别是可重复读的，而RC级别下每次快照读都会创建新的Read View，所以RC级别是不可重复读的。</li></ul> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0cd45e89e7e06c3b4af3760dab165271/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot &#43; Docker 实现一次构建到处运行</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ec09cbea291a956fce8c871c2ca1a80e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java中的回调函数是什么?</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>