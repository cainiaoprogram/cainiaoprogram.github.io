<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浅析一致性哈希算法的原理及实现 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浅析一致性哈希算法的原理及实现" />
<meta property="og:description" content="1.分布式缓存问题 以上是单节点环境下，但随着流量的增大，可能就演变为了如下情形：
❓这个负载均衡算法该如何设计最为合理呢？
首先能想到的最简单的方法可能就是随机或者轮询，这样会产生两个问题：一是数据冗余；二是数据可能已经被缓存，但请求却命中了不存在该数据的节点上。
如何解决这个问题？只需要保证相同的key被发送给相同节点上即可。再一想这不就是hash算法嘛【index = hash(key) % n】（n为节点的数量）
public class SimpleHash { public int loadBalance(String key) { return hash(key) % 3; } private int hash(String key) { int hash = Math.abs(key.hashCode()); ..... ..... return hash; } } 这种算法它的容错性和扩展性不是很好；一旦某个节点宕机或者加入新的节点时，导致n发生了变化，需要重新hash计算，这样可能导致大量缓存不命中，一瞬间给磁盘数据库造成了很大的压力。
容错性是指当某个节点宕机时，整个系统是否可以继续高效运行；扩展性是指加入新节点时，整个系统是否可以高效运行。
所以这种简单的哈希算法并不适用于实际场景，而本文所讲的一致性哈希算法解决了大量哈希重定位的问题。
2.一致性哈希算法 一致性哈希引入了一个虚拟的圆环，这个圆环有2^32个节点组成(0~ 2^32）；
📚它的原理如下：
(1)对每个缓存服务器的IP作为key进行哈希计算，得到的结果一定分布在环上。
(2)对每个数据作为key进行哈希计算，得到的结果也一定分布在环上
按照顺时针，第一台遇到的节点就是该数据定位到的服务器。
❓当节点宕机或者添加新的节点时，它会出现什么样的结果呢？
public class ConsistentHash { private static final String[] NODES = {&#34;123.23.34.1&#34;, &#34;123.52.2.1&#34;, &#34;43.122.54.1&#34;}; //模拟环形哈希表 private static final SortedMap&lt;Integer, String&gt; CIRCLE_Map = new TreeMap&lt;&gt;(); static { for (String node : NODES) { int index = hash(node); System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6722215cb37a80316a7b09853e152f1b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-16T01:25:17+08:00" />
<meta property="article:modified_time" content="2022-07-16T01:25:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浅析一致性哈希算法的原理及实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1_0"></a>1.分布式缓存问题</h3> 
<p><img src="https://images2.imgbox.com/2a/04/dGyNOe70_o.png" alt="在这里插入图片描述"><br> 以上是单节点环境下，但随着流量的增大，可能就演变为了如下情形：<br> <img src="https://images2.imgbox.com/eb/43/9pPlc6AI_o.png" alt="在这里插入图片描述"></p> 
<p>❓<font color="asfdanrg"><strong>这个负载均衡算法该如何设计最为合理呢？</strong></font><br> 首先能想到的最简单的方法可能就是随机或者轮询，这样会产生两个问题：一是数据冗余；二是数据可能已经被缓存，但请求却命中了不存在该数据的节点上。</p> 
<p>如何解决这个问题？只需要保证相同的key被发送给相同节点上即可。再一想这不就是hash算法嘛【index = hash(key) % n】（n为节点的数量）</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleHash</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">loadBalance</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">return</span> hash<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这种算法它的容错性和扩展性不是很好；一旦某个节点宕机或者加入新的节点时，导致n发生了变化，需要重新hash计算，<font color="sndfa">这样可能导致大量缓存不命中，一瞬间给磁盘数据库造成了很大的压力。</font></p> 
<blockquote> 
 <p>容错性是指当某个节点宕机时，整个系统是否可以继续高效运行；扩展性是指加入新节点时，整个系统是否可以高效运行。</p> 
</blockquote> 
<p>所以这种简单的哈希算法并不适用于实际场景，而本文所讲的<font color="joiuea">一致性哈希算法</font>解决了大量哈希重定位的问题。</p> 
<h3><a id="2_32"></a>2.一致性哈希算法</h3> 
<p>一致性哈希引入了一个虚拟的圆环，这个圆环有2^32个节点组成(0~ 2^32）；<br> <img src="https://images2.imgbox.com/a8/a4/2U090CK6_o.png" alt="在这里插入图片描述"><br> 📚它的原理如下：</p> 
<p><strong>(1)对每个缓存服务器的IP作为key进行哈希计算，得到的结果一定分布在环上。<br> (2)对每个数据作为key进行哈希计算，得到的结果也一定分布在环上</strong><br> <img src="https://images2.imgbox.com/f4/e3/fQTh94S0_o.png" alt="在这里插入图片描述"><br> 按照顺时针，第一台遇到的节点就是该数据定位到的服务器。</p> 
<p>❓当节点宕机或者添加新的节点时，它会出现什么样的结果呢？<br> <img src="https://images2.imgbox.com/3c/0a/mMDztEoJ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b8/cc/0mvCEBYa_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConsistentHash</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> NODES <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token string">"123.23.34.1"</span><span class="token punctuation">,</span> <span class="token string">"123.52.2.1"</span><span class="token punctuation">,</span> <span class="token string">"43.122.54.1"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token comment">//模拟环形哈希表</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">SortedMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">CIRCLE_Map</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> node <span class="token operator">:</span> NODES<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>node <span class="token operator">+</span> <span class="token string">"节点的哈希值为:"</span> <span class="token operator">+</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token class-name">CIRCLE_Map</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> <span class="token function">loadBalance</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> index2 <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//返回一个大于或等于index2的map</span>
        <span class="token class-name">SortedMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> tailMap <span class="token operator">=</span> <span class="token class-name">CIRCLE_Map</span><span class="token punctuation">.</span><span class="token function">tailMap</span><span class="token punctuation">(</span>index2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//如果tailMap为空，则直接返回哈希表的第一个数据</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tailMap<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> <span class="token class-name">CIRCLE_Map</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token class-name">CIRCLE_Map</span><span class="token punctuation">.</span><span class="token function">firstKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//第一个Key就是顺时针过去离node最近的那个结点</span>
            <span class="token keyword">return</span> <span class="token class-name">CIRCLE_Map</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>tailMap<span class="token punctuation">.</span><span class="token function">firstKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">String</span> key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"zsh被路由到的节点为:"</span> <span class="token operator">+</span> <span class="token function">loadBalance</span><span class="token punctuation">(</span><span class="token string">"zsh"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>此时可以看到只有一小部分数据进行了重定位，所以它具有很好的容错性和扩展性，❓那么它就没一点问题吗？答案肯定不是的，在某种情况下，会出现节点倾斜的问题。</p> 
<p><img src="https://images2.imgbox.com/f5/5b/dyGgWHJW_o.png" alt="在这里插入图片描述"><br> 当节点2宕机之后，数据1和数据2都重定位到了节点3上，<font color="oiweweijj"><strong>节点分布式不均匀会导致数据倾斜的问题</strong>。</font></p> 
<h3><a id="3_86"></a>3.引入虚拟节点</h3> 
<p>解决数据倾斜问题，可以通过增加大量节点使其分布均匀；但是实际上不可行，太浪费钱。所以引入虚拟节点，并将虚拟机节点定位到某个物理节点上即可。</p> 
<blockquote> 
 <p>如下图引入v1~v6虚拟节点，并建立与物理节点的映射关系；如定位到v1和v2的数据均定位到节点1上。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/3e/f3/ECURxHxx_o.png" alt="在这里插入图片描述"><br> 带虚拟节点的哈希算法实现</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> cl
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4b9bbc8a1bbc4788019bea7581b914dc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">高通常见nv</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f7089ba383310d374d04929e7470b55d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">TICK回测二：数据如何存储</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>