<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Spring Boot】拦截器与统一功能处理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Spring Boot】拦截器与统一功能处理" />
<meta property="og:description" content="博主简介：想进大厂的打工人博主主页：@xyk:所属专栏: JavaEE进阶 上一篇文章我们讲解了Spring AOP是一个基于面向切面编程的框架，用于将某方面具体问题集中处理，通过代理对象来进行传递，但使用原生Spring AOP实现统一的拦截是非常繁琐的。而在本节，我们将使用一种简单的方式进行统一功能处理，具体如下：
统一用户登录权限验证统一数据格式返回统一异常处理 目录
文章目录
0、我们先来回顾⼀下最初⽤户登录验证的实现方法：
一、统一用户登录权限验证
1.1 使用原生Spring AOP 实现统一拦截
1.2 使用Spring 拦截器实现统一用户登录验证
1.3 拦截器实现原理
1.4 实现原理源码分析
二、统一异常处理
三、统一数据返回格式
3.1 为什么要统一数据返回格式？
3.2 统一数据返回格式的实现
结语
0、我们先来回顾⼀下最初用户登录验证的实现方法： @RestController @RequestMapping(&#34;/user&#34;) public class UserController { /** * 某⽅法 1 */ @RequestMapping(&#34;/m1&#34;) public Object method(HttpServletRequest request) { // 有 session 就获取，没有不会创建 HttpSession session = request.getSession(false); if (session != null &amp;&amp; session.getAttribute(&#34;userinfo&#34;) != null) { // 说明已经登录，业务处理 return true; } else { // 未登录 return false; } } /** * 某⽅法 2 */ @RequestMapping(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ec43236748a99626bd6a6d4ae12da7ef/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-07T09:49:01+08:00" />
<meta property="article:modified_time" content="2023-08-07T09:49:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Spring Boot】拦截器与统一功能处理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><a id="_0"></a></h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/50/5a/Kj6DKYQs_o.gif"></p> 
<blockquote> 
 <ul><li><span style="color:#4da8ee;"><strong>博主简介：想进大厂的打工人</strong></span></li><li><span style="color:#1c7331;"><strong>博主主页：</strong><a href="https://blog.csdn.net/asad21654864?spm=1000.2115.3001.5343" title="@xyk:">@xyk:</a></span></li><li><strong><span style="color:#b95514;">所属专栏: <a href="http://t.csdn.cn/SpyLE" rel="nofollow" title="JavaEE进阶">JavaEE进阶</a></span></strong><span style="color:#b95514;"> </span></li></ul> 
</blockquote> 
<p>上一篇文章我们讲解了Spring AOP是一个基于面向切面编程的框架，用于将某方面具体问题集中处理，通过代理对象来进行传递，但使用原生Spring AOP实现统一的拦截是非常繁琐的。而在本节，我们将使用一种简单的方式进行统一功能处理，具体如下：</p> 
<ul><li>统一用户登录权限验证</li><li>统一数据格式返回</li><li>统一异常处理</li></ul> 
<hr> 
<div> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95-toc" style="margin-left:80px;"><a href="#%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95" rel="nofollow">文章目录</a></p> 
 <p id="0%E3%80%81%E6%88%91%E4%BB%AC%E5%85%88%E6%9D%A5%E5%9B%9E%E9%A1%BE%E2%BC%80%E4%B8%8B%E6%9C%80%E5%88%9D%E2%BD%A4%E6%88%B7%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A-toc" style="margin-left:0px;"><a href="#0%E3%80%81%E6%88%91%E4%BB%AC%E5%85%88%E6%9D%A5%E5%9B%9E%E9%A1%BE%E2%BC%80%E4%B8%8B%E6%9C%80%E5%88%9D%E2%BD%A4%E6%88%B7%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A" rel="nofollow">0、我们先来回顾⼀下最初⽤户登录验证的实现方法：</a></p> 
 <p id="%E4%B8%80%E3%80%81%E7%BB%9F%E4%B8%80%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E7%BB%9F%E4%B8%80%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81" rel="nofollow">一、统一用户登录权限验证</a></p> 
 <p id="1.1%20%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9FSpring%20AOP%20%E5%AE%9E%E7%8E%B0%E7%BB%9F%E4%B8%80%E6%8B%A6%E6%88%AA-toc" style="margin-left:40px;"><a href="#1.1%20%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9FSpring%20AOP%20%E5%AE%9E%E7%8E%B0%E7%BB%9F%E4%B8%80%E6%8B%A6%E6%88%AA" rel="nofollow">1.1 使用原生Spring AOP 实现统一拦截</a></p> 
 <p id="1.2%20%E4%BD%BF%E7%94%A8Spring%20%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%BB%9F%E4%B8%80%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81-toc" style="margin-left:40px;"><a href="#1.2%20%E4%BD%BF%E7%94%A8Spring%20%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%BB%9F%E4%B8%80%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81" rel="nofollow">1.2 使用Spring 拦截器实现统一用户登录验证</a></p> 
 <p id="1.3%20%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#1.3%20%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" rel="nofollow">1.3 拦截器实现原理</a></p> 
 <p id="1.4%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#1.4%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" rel="nofollow">1.4 实现原理源码分析</a></p> 
 <p id="%E4%BA%8C%E3%80%81%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86" rel="nofollow">二、统一异常处理</a></p> 
 <p id="%E4%B8%89%E3%80%81%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F" rel="nofollow">三、统一数据返回格式</a></p> 
 <p id="3.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F%EF%BC%9F-toc" style="margin-left:40px;"><a href="#3.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F%EF%BC%9F" rel="nofollow">3.1 为什么要统一数据返回格式？</a></p> 
 <p id="3.2%20%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#3.2%20%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">3.2 统一数据返回格式的实现</a></p> 
 <p id="%E7%BB%93%E8%AF%AD-toc" style="margin-left:0px;"><a href="#%E7%BB%93%E8%AF%AD" rel="nofollow">结语</a></p> 
</div> 
<hr> 
<h2 id="0%E3%80%81%E6%88%91%E4%BB%AC%E5%85%88%E6%9D%A5%E5%9B%9E%E9%A1%BE%E2%BC%80%E4%B8%8B%E6%9C%80%E5%88%9D%E2%BD%A4%E6%88%B7%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95%EF%BC%9A">0、我们先来回顾⼀下最初用户登录验证的实现方法：</h2> 
<pre><code class="language-java">@RestController
@RequestMapping("/user")
public class UserController {
    /**
     * 某⽅法 1
     */
    @RequestMapping("/m1")
    public Object method(HttpServletRequest request) {
// 有 session 就获取，没有不会创建
        HttpSession session = request.getSession(false);
        if (session != null &amp;&amp; session.getAttribute("userinfo") != null) {
// 说明已经登录，业务处理
            return true;
        } else {
// 未登录
            return false;
        }
    }
    /**
     * 某⽅法 2
     */
    @RequestMapping("/m2")
    public Object method2(HttpServletRequest request) {
// 有 session 就获取，没有不会创建
        HttpSession session = request.getSession(false);
        if (session != null &amp;&amp; session.getAttribute("userinfo") != null) {
// 说明已经登录，业务处理
            return true;
        } else {
// 未登录
            return false;
        }
    }
// 其他⽅法...
}</code></pre> 
<p>从上述代码可以看出，每个⽅法中都有相同的⽤户登录验证权限，它的缺点是：<br> 1. 每个⽅法中都要单独写⽤户登录验证的⽅法，即使封装成公共⽅法，也⼀样要传参调⽤和在⽅法中进⾏判断。<br> 2. 添加控制器越多，调⽤⽤户登录验证的⽅法也越多，这样就增加了后期的修改成本和维护成本。<br> 3. 这些⽤户登录验证的⽅法和接下来要实现的业务⼏何没有任何关联，但每个⽅法中都要写⼀遍。</p> 
<h2 id="%E4%B8%80%E3%80%81%E7%BB%9F%E4%B8%80%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E6%9D%83%E9%99%90%E9%AA%8C%E8%AF%81"><strong>一、统一用户登录权限验证</strong></h2> 
<h3 id="1.1%20%E4%BD%BF%E7%94%A8%E5%8E%9F%E7%94%9FSpring%20AOP%20%E5%AE%9E%E7%8E%B0%E7%BB%9F%E4%B8%80%E6%8B%A6%E6%88%AA">1.1 使用原生Spring AOP 实现统一拦截</h3> 
<p>我们上一篇文章讲解了原生AOP：<a href="https://blog.csdn.net/asad21654864/article/details/132116095?spm=1001.2014.3001.5502" title="【Spring】Spring AOP 初识及实现原理解析">【Spring】Spring AOP 初识及实现原理解析</a></p> 
<p></p> 
<p>以使用原生 Spring AOP 来实现⽤户统⼀登录验证为例， 主要是使用前置通知和环绕通知实现的，具体实现如下：</p> 
<pre><code class="language-java">package com.example.demo.aop;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

@Component // 随着框架的启动而启动
@Aspect // 告诉框架我是一个切面类
public class UserAspect {

    // 定义切点(配置拦截规则)
    @Pointcut("execution(* com.example.demo.controller.UserController.*(..))")
    public void pointcut(){

    }

    @Before("pointcut()")
    public void beforeAdvice(){
        System.out.println("执行了前置通知~");
    }

    @After("pointcut()")
    public void AfterAdvice(){
        System.out.println("执行了后置通知~");
    }

    /**
     * 环绕通知
     * @param joinPoint
     * @return
     */
    @Around("pointcut()")
    public Object aroundAdvice(ProceedingJoinPoint joinPoint){
        System.out.println("进入了环绕通知~");
        Object obj = null;
        try {
            obj = joinPoint.proceed();
        } catch (Throwable e) {
            e.printStackTrace();
        }
        System.out.println("退出了环绕通知~");
        return obj;
    }

}
</code></pre> 
<p>从上面代码可以看出，使用原生的 Spring AOP 实现统一拦截的难点比较复杂，不易实现。定义拦截规则非常困难。如注册⽅法和登录⽅法是不拦截的，这样的话排除⽅法的规则很难定义，甚⾄没办法定义。而且在切面类中拿到 HttpSession 比较难。</p> 
<p>为了解决Spring AOP的问题，Spring 提供了拦截器~</p> 
<h3 id="1.2%20%E4%BD%BF%E7%94%A8Spring%20%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E7%BB%9F%E4%B8%80%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81">1.2 使用Spring 拦截器实现统一用户登录验证</h3> 
<p>要使用Spring 拦截器，需要先创建一个实现了 HandlerInterceptor 接口的拦截器类，该接口定义了三个方法：preHandle、postHandle和afterCompletion。</p> 
<ol><li>preHandle方法在请求到达控制器之前执行，可以用于进行身份验证、参数校验等；</li><li>postHandle方法在控制器处理完请求后执行，可以对模型和视图进行操作；</li><li>afterCompletion方法在视图渲染完成后执行，用于清理资源或记录日志。</li></ol> 
<p>拦截器的实现分为以下两个步骤：</p> 
<p>1. 创建⾃定义拦截器，实现 <strong>HandlerInterceptor 接⼝的 preHandle</strong>（执⾏具体⽅法之前的预处理）方法。</p> 
<p>2. 将⾃定义拦截器加入 <strong>WebMvcConfigurer 的 addInterceptors </strong>方法中</p> 
<p>具体实现如下：</p> 
<p>1.先创建自定义拦截器</p> 
<pre><code class="language-java">package com.example.demo.config;

import org.springframework.web.servlet.HandlerInterceptor;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

public class LoginInterceptor implements HandlerInterceptor {

    /**
     * 此方法返回一个 boolean,如果为 true 表示验证成功，可以继续执行后续流程
     * @param request
     * @param response
     * @param handler
     * @return
     * @throws Exception
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        // 用户登录业务判断
        HttpSession session = request.getSession(false);
        if (session != null &amp;&amp; session.getAttribute("userinfo") != null){
            // 说明用户已经登录
            return true;
        }
        // 可以跳转到登录页面 or 返回一个 401 / 403 没有权限码
        response.sendRedirect("/login.html");
//        response.setStatus(403);
        return false;

    }
}
</code></pre> 
<p>2.配置拦截器并设置拦截规则：</p> 
<pre><code class="language-java">package com.example.demo.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.PathMatchConfigurer;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class AppConfig implements WebMvcConfigurer {

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new LoginInterceptor())
                .addPathPatterns("/**") // 拦截所有请求
                .excludePathPatterns("/user/login") // 排除的url地址
                .excludePathPatterns("/user/reg")
                .excludePathPatterns("/**/*.html");
    }
}</code></pre> 
<h3 id="1.3%20%E6%8B%A6%E6%88%AA%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">1.3 拦截器实现原理</h3> 
<p>当有了拦截器后，会在调用 Controller 之前进行相应的业务处理，执行的流程如下图所示：</p> 
<p><img alt="" height="439" src="https://images2.imgbox.com/14/9d/UNgQhKfh_o.png" width="746"></p> 
<p></p> 
<h3 id="1.4%20%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90">1.4 实现原理源码分析</h3> 
<p>所有的 Controller 执⾏都会通过⼀个调度器 <strong>DispatcherServlet</strong> 来实现，这⼀点可以从 Spring Boot 控制台的打印信息看出，如下图所示：</p> 
<p><img alt="" height="128" src="https://images2.imgbox.com/b5/17/pFDlQttp_o.png" width="708"></p> 
<p> 而所有的方法都会执行 DispatcherServlet 中的 doDispatch 调度方法，doDispatch 源码如下：</p> 
<pre><code class="language-java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {
        HttpServletRequest processedRequest = request;
        HandlerExecutionChain mappedHandler = null;
        boolean multipartRequestParsed = false;
        WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

        try {
            try {
                ModelAndView mv = null;
                Object dispatchException = null;

                try {
                    processedRequest = this.checkMultipart(request);
                    multipartRequestParsed = processedRequest != request;
                    mappedHandler = this.getHandler(processedRequest);
                    if (mappedHandler == null) {
                        this.noHandlerFound(processedRequest, response);
                        return;
                    }

                    HandlerAdapter ha = this.getHandlerAdapter(mappedHandler.getHandler());
                    String method = request.getMethod();
                    boolean isGet = HttpMethod.GET.matches(method);
                    if (isGet || HttpMethod.HEAD.matches(method)) {
                        long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
                        if ((new ServletWebRequest(request, response)).checkNotModified(lastModified) &amp;&amp; isGet) {
                            return;
                        }
                    }
                    // 调⽤预处理【重点】
                    if (!mappedHandler.applyPreHandle(processedRequest, response)) {
                        return;
                    }
                    // 执⾏ Controller 中的业务
                    mv = ha.handle(processedRequest, response, mappedHandler.getHandler());
                    if (asyncManager.isConcurrentHandlingStarted()) {
                        return;
                    }

                    this.applyDefaultViewName(processedRequest, mv);
                    mappedHandler.applyPostHandle(processedRequest, response, mv);
                } catch (Exception var20) {
                    dispatchException = var20;
                } catch (Throwable var21) {
                    dispatchException = new NestedServletException("Handler dispatch failed", var21);
                }

                this.processDispatchResult(processedRequest, response, mappedHandler, mv, (Exception)dispatchException);
            } catch (Exception var22) {
                this.triggerAfterCompletion(processedRequest, response, mappedHandler, var22);
            } catch (Throwable var23) {
                this.triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException("Handler processing failed", var23));
            }

        } finally {
            if (asyncManager.isConcurrentHandlingStarted()) {
                if (mappedHandler != null) {
                    mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
                }
            } else if (multipartRequestParsed) {
                this.cleanupMultipart(processedRequest);
            }

        }
    }</code></pre> 
<p>从上述源码可以看出在开始执⾏ Controller 之前，会先调⽤ 预处理⽅法 applyPreHandle，⽽<br> applyPreHandle ⽅法的实现源码如下：</p> 
<pre><code class="language-java">    boolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {
        for(int i = 0; i &lt; this.interceptorList.size(); this.interceptorIndex = i++) {
            HandlerInterceptor interceptor = (HandlerInterceptor)this.interceptorList.get(i);
            if (!interceptor.preHandle(request, response, this.handler)) {
                this.triggerAfterCompletion(request, response, (Exception)null);
                return false;
            }
        }

        return true;
    }</code></pre> 
<p>从上述源码可以看出，在 applyPreHandle 中会获取所有的拦截器 HandlerInterceptor 并执⾏拦截器中的 preHandle ⽅法，这样就会我们前⾯定义的拦截器对应上了，如下图所示：</p> 
<p><img alt="" height="432" src="https://images2.imgbox.com/c0/31/onlwmlwt_o.png" width="822"></p> 
<p> 此时，相应的preHandle中的业务逻辑就会执行。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">二、统一异常处理</h2> 
<p>统一异常处理是指在应用程序中定义一个公共的异常处理机制，用来处理所有的异常情况。</p> 
<p>本文讲述的统一异常处理使用的是 <strong>@ControllerAdvice + @ExceptionHandler</strong> 来实现的：</p> 
<ul><li>@ControllerAdvice 表示控制器通知类。</li><li>@ExceptionHandler 异常处理器。</li></ul> 
<p>以上两个注解组合使用，表示当出现异常的时候执行某个通知，即执行某个方法事件，<strong>具体实现代码如下：</strong></p> 
<pre><code class="language-java">package com.example.demo.config;

import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseBody;

import java.util.HashMap;

/**
 * @author xyk的电脑
 * @version 1.0
 * @description: TODO
 * @date 2023/7/15 18:49
 */

@ControllerAdvice
@ResponseBody
public class MyExHandler {

    /**
     * 拦截所有的空指针异常，进行统一的数据返回了
     * @param e
     * @return
     */
    @ExceptionHandler(NullPointerException.class)
    public HashMap&lt;String,Object&gt; nullException(NullPointerException e){
        HashMap&lt;String,Object&gt; result = new HashMap&lt;&gt;();
        result.put("code",-1);
        result.put("msg","空指针异常:" + e.getMessage()); // 错误码的描述信息
        result.put("data",null);
        return result;
    }

    @ExceptionHandler(Exception.class)
    public HashMap&lt;String,Object&gt; exception(Exception e){
        HashMap&lt;String,Object&gt; result = new HashMap&lt;&gt;();
        result.put("code",-1);
        result.put("msg","异常:" + e.getMessage()); // 错误码的描述信息
        result.put("data",null);
        return result;
    }


}
</code></pre> 
<p>上述代码中，实现了对所有空指针异常和所有异常的保底措施的拦截并进行统一的数据返回。</p> 
<h2 id="%E4%B8%89%E3%80%81%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F"><a id="_26"></a>三、统一数据返回格式</h2> 
<h3 id="3.1%20%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F%EF%BC%9F">3.1 为什么要统一数据返回格式？</h3> 
<p>统⼀数据返回格式的优点有很多，⽐如以下几个：<br> 1. ⽅便前端程序员更好的接收和解析后端数据接口返回的数据。<br> 2. 降低前端程序员和后端程序员的沟通成本，按照某个格式实现就⾏了，因为所有接⼝都是这样返回的。<br> 3. 有利于项⽬统⼀数据的维护和修改。<br> 4. 有利于后端技术部⻔的统⼀规范的标准制定，不会出现稀奇古怪的返回内容</p> 
<h3 id="3.2%20%E7%BB%9F%E4%B8%80%E6%95%B0%E6%8D%AE%E8%BF%94%E5%9B%9E%E6%A0%BC%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0">3.2 统一数据返回格式的实现</h3> 
<p>统⼀的数据返回格式可以使⽤ <strong>@ControllerAdvice + ResponseBodyAdvice</strong> 的⽅式实现，具体实现代码如下：</p> 
<p>1.创建一个类，并添加@ControllerAdvice注解</p> 
<p>2.实现ResponseBodyAdvice接口，并重写 supports 和 beforeBodyWrite方法</p> 
<pre><code class="language-java">package com.example.demo.config;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.MethodParameter;
import org.springframework.http.MediaType;
import org.springframework.http.server.ServerHttpRequest;
import org.springframework.http.server.ServerHttpResponse;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.servlet.mvc.method.annotation.ResponseBodyAdvice;

import java.util.HashMap;

/**
 * @author xyk的电脑
 * @version 1.0
 * @description: TODO
 * @date 2023/7/15 19:18
 */

@ControllerAdvice
public class ResponseAdvice implements ResponseBodyAdvice {
    @Autowired
    private ObjectMapper objectMapper;

    /**
     * 此方法返回 true 则执行下面 beforeBodyWrite 方法
     * 反之则不执行
     */
    @Override
    public boolean supports(MethodParameter returnType, Class converterType) {
        return true;
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {
        HashMap&lt;String,Object&gt; result = new HashMap&lt;&gt;();
        result.put("code",200);
        result.put("msg","");
        result.put("data",body);
        if (body instanceof String){
            // 需要特殊处理，因为 String 在转换的时候会报错
            try {
                return objectMapper.writeValueAsString(result);
            } catch (JsonProcessingException e) {
                e.printStackTrace();
            }
        }
        return result;
    }
}
</code></pre> 
<p>注意，如果返回的 body 原始数据类型是 String ，<strong><span style="color:#fe2c24;">则会出现类型转化异常，因为当我们返回给前端Spring引用类型时，Spring的渲染引擎还没有加载好就已经返回给前端了，会出现<code>ClassCastException</code>。</span></strong>因此，如果原始返回数据类型为 String ，则需要使用 jackson 进行单独处理。</p> 
<hr> 
<h2 id="%E7%BB%93%E8%AF%AD">结语</h2> 
<p>创作不易，如果你有任何问题，欢迎评论区讨论哦~~ </p> 
<p style="text-align:center;"><img alt="" height="224" src="https://images2.imgbox.com/b1/10/xogx5lhs_o.gif" width="399"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8eeb2eef66dc39d9a9dea8569f8d5842/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【三】Vue之后端交互</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0bdf479ad77e807ef9f4273746a7fa85/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">贝尔曼期望方程(Bellman Expectation Equation)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>