<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>shmget物理内存_共享内存的常用函数详解shmget shmat - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="shmget物理内存_共享内存的常用函数详解shmget shmat" />
<meta property="og:description" content="共享内存区域是被多个进程共享的一部分物理内存。如果多个进程都把该内存区域映射到自己的虚拟地址空间，则这些进程就都可以直接访问该共享内存区域，从而可以通过该区域进行通信。共享内存是进程间共享数据的一种最快的方法，一个进程向共享内存区域写入了数据，共享这个内存区域的所有进程就可以立刻看到其中的内容。这块共享虚拟内存的页面，出现在每一个共享该页面的进程的页表中。但是它不需要在所有进程的虚拟内存中都有相同的虚拟地址。
象所有的 System V IPC对象一样，对于共享内存对象的获取是由key控制。内存共享之后，对进程如何使用这块内存就不再做检查。它们必须依赖于其它机制，比如System V的信号灯来同步对于共享内存区域的访问(信号灯如何控制对临界代码的访问另起一篇说话)。
每一个新创建的共享内存对象都用一个shmid_kernel数据结构来表达。系统中所有的shmid_kernel数据结构都保存在shm_segs向量表中，该向量表的每一个元素都是一个指向shmid_kernel数据结构的指针。
shm_segs向量表的定义如下：
struct shmid_kernel *shm_segs[SHMMNI];
SHMMNI为128，表示系统中最多可以有128个共享内存对象。
数据结构shmid_kernel的定义如下：struct shmid_kernel
{
struct shmid_ds u;
unsigned long shm_npages;
unsigned long *shm_pages;
struct vm_area_struct *attaches;
};
其中：
shm_pages代表该共享内存对象的所占据的内存页面数组，数组里面的每个元素当然是每个内存页面的起始地址.
shm_npages则是该共享内存对象占用内存页面的个数，以页为单位。这个数量当然涵盖了申请空间的最小整数倍.
(A new shared memory segment, with size equal to the value of size rounded up to a multiple of PAGE_SIZE)
shmid_ds是一个数据结构，它描述了这个共享内存区的认证信息，字节大小，最后一次粘附时间、分离时间、改变时间，创建该共享区域的进程，最后一次对它操作的进程，当前有多少个进程在使用它等信息。
其定义如下：
struct shmid_ds {
struct ipc_perm shm_perm;
int shm_segsz;
__kernel_time_t shm_atime;
__kernel_time_t shm_dtime;
__kernel_time_t shm_ctime;
__kernel_ipc_pid_t shm_cpid;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ba772be6e4562eec9c1a519d78903173/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-19T20:07:08+08:00" />
<meta property="article:modified_time" content="2020-12-19T20:07:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">shmget物理内存_共享内存的常用函数详解shmget shmat</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>共享内存区域是被多个进程共享的一部分物理内存。如果多个进程都把该内存区域映射到自己的虚拟地址空间，则这些进程就都可以直接访问该共享内存区域，从而可以通过该区域进行通信。共享内存是进程间共享数据的一种最快的方法，一个进程向共享内存区域写入了数据，共享这个内存区域的所有进程就可以立刻看到其中的内容。这块共享虚拟内存的页面，出现在每一个共享该页面的进程的页表中。但是它不需要在所有进程的虚拟内存中都有相同的虚拟地址。</p> 
 <p>象所有的 System V IPC对象一样，对于共享内存对象的获取是由key控制。内存共享之后，对进程如何使用这块内存就不再做检查。它们必须依赖于其它机制，比如System V的信号灯来同步对于共享内存区域的访问(信号灯如何控制对临界代码的访问另起一篇说话)。</p> 
 <p>每一个新创建的共享内存对象都用一个shmid_kernel数据结构来表达。系统中所有的shmid_kernel数据结构都保存在shm_segs向量表中，该向量表的每一个元素都是一个指向shmid_kernel数据结构的指针。</p> 
 <p>shm_segs向量表的定义如下：</p> 
 <p>struct shmid_kernel *shm_segs[SHMMNI];</p> 
 <p>SHMMNI为128，表示系统中最多可以有128个共享内存对象。</p> 
 <p>数据结构shmid_kernel的定义如下：struct shmid_kernel</p> 
 <p>{<!-- --></p> 
 <p>struct shmid_ds u;</p> 
 <p>unsigned long shm_npages;</p> 
 <p>unsigned long *shm_pages;</p> 
 <p>struct vm_area_struct *attaches;</p> 
 <p>};</p> 
 <p>其中：</p> 
 <p>shm_pages代表该共享内存对象的所占据的内存页面数组，数组里面的每个元素当然是每个内存页面的起始地址.</p> 
 <p>shm_npages则是该共享内存对象占用内存页面的个数，以页为单位。这个数量当然涵盖了申请空间的最小整数倍.</p> 
 <p>(A new shared memory segment,  with size  equal to the value of size rounded up to a multiple of PAGE_SIZE)</p> 
 <p>shmid_ds是一个数据结构，它描述了这个共享内存区的认证信息，字节大小，最后一次粘附时间、分离时间、改变时间，创建该共享区域的进程，最后一次对它操作的进程，当前有多少个进程在使用它等信息。</p> 
 <p>其定义如下：</p> 
 <p>struct shmid_ds {<!-- --></p> 
 <p>struct ipc_perm shm_perm;</p> 
 <p>int shm_segsz;</p> 
 <p>__kernel_time_t shm_atime;</p> 
 <p>__kernel_time_t shm_dtime;</p> 
 <p>__kernel_time_t shm_ctime;</p> 
 <p>__kernel_ipc_pid_t shm_cpid;</p> 
 <p>__kernel_ipc_pid_t shm_lpid;</p> 
 <p>unsigned short shm_nattch;</p> 
 <p>unsigned short shm_unused;</p> 
 <p>void *shm_unused2;</p> 
 <p>void *shm_unused3;</p> 
 <p>};</p> 
 <p>attaches描述被共享的物理内存对象所映射的各进程的虚拟内存区域。每一个希望共享这块内存的进程都必须通过系统调用将其关联(attach)到它的虚拟内存中。这一过程将为该进程创建了一个新的描述这块共享内存的vm_area_struct数据结构。创建时可以指定共享内存在它的虚拟地址空间的位置，也可以让Linux自己为它选择一块足够的空闲区域。</p> 
 <p>这个新的vm_area_struct结构是维系共享内存和使用它的进程之间的关系的,所以除了要关联进程信息外，还要指明这个共享内存数据结构shmid_kernel所在位置; 另外,便于管理这些经常变化的vm_area_struct,所以采取了链表形式组织这些数据结构,链表由attaches指向,同时 vm_area_struct数据结构中专门提供了两个指针：vm_next_shared和 vm_prev_shared，用于连接该共享区域在使用它的各进程中所对应的vm_area_struct数据结构。</p> 
 <p>Linux为共享内存提供了四种操作。</p> 
 <p>1. 共享内存对象的创建或获得。与其它两种IPC机制一样，进程在使用共享内存区域以前，必须通过系统调用sys_ipc (call值为SHMGET)创建一个键值为key的共享内存对象，或获得已经存在的键值为key的某共享内存对象的引用标识符。以后对共享内存对象的访问都通过该引用标识符进行。对共享内存对象的创建或获得由函数sys_shmget完成，其定义如下：</p> 
 <p>int sys_shmget (key_t key, int size, int shmflg)</p> 
 <p>这里key是表示该共享内存对象的键值，size是该共享内存区域的大小(以字节为单位)，shmflg是标志(对该共享内存对象的特殊要求)。</p> 
 <p>它所做的工作如下：</p> 
 <p>1) 如果key == IPC_PRIVATE，则总是会创建一个新的共享内存对象。</p> 
 <p>但是  (The name choice IPC_PRIVATE was perhaps unfortunate, IPC_NEW would more clearly show its function)    * 算出size要占用的页数，检查其合法性。</p> 
 <p>* 申请一块内存用于建立shmid_kernel数据结构，注意这里申请的内存区域大小不包括真正的共享内存区，实际上，要等到第一个进程试图访问它的时候才真正创建共享内存区。</p> 
 <p>* 根据该共享内存区所占用的页数，为其申请一块空间用于建立页表(每页4个字节)，将页表清0。</p> 
 <p>* 搜索向量表shm_segs，为新创建的共享内存对象找一个空位置。</p> 
 <p>* 填写shmid_kernel数据结构，将其加入到向量表shm_segs中为其找到的空位置。</p> 
 <p>* 返回该共享内存对象的引用标识符。</p> 
 <p>2) 在向量表shm_segs中查找键值为key的共享内存对象，结果有三：</p> 
 <p>* 如果没有找到，而且在操作标志shmflg中没有指明要创建新共享内存，则错误返回，否则创建一个新的共享内存对象。</p> 
 <p>* 如果找到了，但该次操作要求必须创建一个键值为key的新对象，那么错误返回。</p> 
 <p>* 否则，合法性、认证检查，如有错，则错误返回；否则，返回该内存对象的引用标识符。</p> 
 <p>共享内存对象的创建者可以控制对于这块内存的访问权限和它的key是公开还是私有。如果有足够的权限，它也可以把共享内存锁定在物理内存中。</p> 
 <p>参见include/linux/shm.h</p> 
 <p>2. 关联。在创建或获得某个共享内存区域的引用标识符后，还必须将共享内存区域映射(粘附)到进程的虚拟地址空间，然后才能使用该共享内存区域。系统调用 sys_ipc(call值为SHMAT)用于共享内存区到进程虚拟地址空间的映射，而真正完成粘附动作的是函数sys_shmat，</p> 
 <p>其定义如下：</p> 
 <p>#include #include</p> 
 <p>void *shmat(int shmid, const void *shmaddr, int shmflg);</p> 
 <p>其中：</p> 
 <p>shmid是shmget返回的共享内存对象的引用标识符；</p> 
 <p>shmaddr用来指定该共享内存区域在进程的虚拟地址空间对应的虚拟地址；</p> 
 <p>shmflg是映射标志；</p> 
 <p>返回的是在进程中的虚拟地址</p> 
 <p>该函数所做的工作如下：</p> 
 <p>1) 根据shmid找到共享内存对象。</p> 
 <p>2) 如果shmaddr为0，即用户没有指定该共享内存区域在它的虚拟空间中的位置，则由系统在进程的虚拟地址空间中为其找一块区域(从1G开始)；否则，就用shmaddr作为映射的虚拟地址。</p> 
 <p>(If  shmaddr  is NULL, the system chooses a suitable (unused) address a他 which to attach the segment)</p> 
 <p>3) 检查虚拟地址的合法性(不能超过进程的最大虚拟空间大小—3G，不能太接近堆栈栈顶)。</p> 
 <p>4) 认证检查。</p> 
 <p>5) 申请一块内存用于建立数据结构vm_area_struct，填写该结构。</p> 
 <p>6) 检查该内存区域，将其加入到进程的mm结构和该共享内存对象的vm_area_struct队列中。</p> 
 <p>共享内存的粘附只是创建一个vm_area_struct数据结构，并将其加入到相应的队列中，此时并没有创建真正的共享内存页。</p> 
 <p>当进程第一次访问共享虚拟内存的某页时，因为所有的共享内存页还都没有分配，所以会发生一个page fault异常。当Linux处理这个page fault的时候，它找到发生异常的虚拟地址所在的vm_area_struct数据结构。在该数据结构中包含有这类共享虚拟内存的一组处理程序，其中的 nopage操作用来处理虚拟页对应的物理页不存在的情况。对共享内存，该操作是shm_nopage(定义在ipc/shm.c中)。该操作在描述这个共享内存的shmid_kernel数据结构的页表shm_pages中查找发生page fault异常的虚拟地址所对应的页表条目，看共享页是否存在(页表条目为0，表示共享页是第一次使用)。如果不存在，它就分配一个物理页，并为它创建一个页表条目。这个条目不但进入当前进程的页表，同时也存到shmid_kernel数据结构的页表shm_pages中。</p> 
 <p>当下一个进程试图访问这块内存并得到一个page fault的时候，经过同样的路径，也会走到函数shm_nopage。此时，该函数查看shmid_kernel数据结构的页表shm_pages时，发现共享页已经存在，它只需把这里的页表项填到进程页表的相应位置即可，而不需要重新创建物理页。所以，是第一个访问共享内存页的进程使得这一页被创建，而随后访问它的其它进程仅把此页加到它们的虚拟地址空间。</p> 
 <p>3. 分离。当进程不再需要共享虚拟内存的时候，它们与之分离(detach)。只要仍旧有其它进程在使用这块内存，这种分离就只会影响当前的进程，而不会影响其它进程。当前进程的vm_area_struct数据结构被从shmid_ds中删除，并被释放。当前进程的页表也被更新，共享内存对应的虚拟内存页被标记为无效。当共享这块内存的最后一个进程与之分离时，共享内存页被释放，同时，这块共享内存的shmid_kernel数据结构也被释放。</p> 
 <p>系统调用sys_ipc (call值为SHMDT) 用于共享内存区与进程虚拟地址空间的分离，而真正完成分离动作的是函数sys_shmdt，其定义如下：</p> 
 <p>int sys_shmdt (char *shmaddr)</p> 
 <p>其中shmaddr是进程要分离的共享页的开始虚拟地址。</p> 
 <p>该函数搜索进程的内存结构中的所有vm_area_struct数据结构，找到地址shmaddr对应的一个，调用函数do_munmap将其释放。</p> 
 <p>在函数do_munmap中，将要释放的vm_area_struct数据结构从进程的虚拟内存中摘下，清除它在进程页表中对应的页表项(可能占多个页表项).</p> 
 <p>如果共享的虚拟内存没有被锁定在物理内存中，分离会更加复杂。因为在这种情况下，共享内存的页可能在系统大量使用内存的时候被交换到系统的交换磁盘。为了避免这种情况，可以通过下面的控制操作，将某共享内存页锁定在物理内存不允许向外交换。共享内存的换出和换入，已在第3章中讨论。</p> 
 <p>4. 控制。Linux在共享内存上实现的第四种操作是共享内存的控制(call值为SHMCTL的sys_ipc调用)，它由函数sys_shmctl实现。控制操作包括获得共享内存对象的状态，设置共享内存对象的参数(如uid、gid、mode、ctime等)，将共享内存对象在内存中锁定和释放(在对象的mode上增加或去除SHM_LOCKED标志)，释放共享内存对象资源等。</p> 
 <p>共享内存提供了一种快速灵活的机制，它允许进程之间直接共享大量的数据，而无须使用拷贝或系统调用。共享内存的主要局限性是它不能提供同步，如果两个进程企图修改相同的共享内存区域，由于内核不能串行化这些动作，因此写的数据可能任意地互相混合。所以使用共享内存的进程必须设计它们自己的同步协议，如用信号灯等。</p> 
 <p>以下是使用共享内存机制进行进程间通信的基本操作：</p> 
 <p>需要包含的头文件：</p> 
 <p>#include</p> 
 <p>#include</p> 
 <p>#include</p> 
 <p>1.创建共享内存：</p> 
 <p>int shmget(key_t key,int size,int shmflg);</p> 
 <p>参数说明：</p> 
 <p>key:用来表示新建或者已经存在的共享内存去的关键字。</p> 
 <p>size：创建共享内存的大小。</p> 
 <p>shmflg：可以指定的特殊标志。IPC_CREATE,IPC_EXCL以及低九位的权限。</p> 
 <p>eg：</p> 
 <p>int shmid;</p> 
 <p>shmid=shmget(IPC_PRIVATE,4096,IPC_CREATE|IPC_EXCL|0660);</p> 
 <p>if(shmid==-1)</p> 
 <p>perror("shmget()");</p> 
 <p>2.连接共享内存</p> 
 <p>char *shmat(int shmid,char *shmaddr,int shmflg);</p> 
 <p>参数说明</p> 
 <p>shmid：共享内存的关键字</p> 
 <p>shmaddr：指定共享内存出现在进程内存地址的什么位置，通常我们让内核自己决定一个合适的地址位置，用的时候设为0。</p> 
 <p>shmflg：制定特殊的标志位。</p> 
 <p>eg：</p> 
 <p>int shmid;</p> 
 <p>char *shmp;</p> 
 <p>shmp=shmat(shmid,0,0);</p> 
 <p>if(shmp==(char *)(-1))</p> 
 <p>perror("shmat()\n");</p> 
 <p>3.使用共享内存</p> 
 <p>在使用共享内存是需要注意的是，为防止内存访问冲突，我们一般与信号量结合使用。</p> 
 <p>4.分离共享内存：当程序不再需要共享内后，我们需要将共享内存分离以便对其进行释放，分离共享内存的函数原形如下：</p> 
 <p>int shmdt(char *shmaddr);</p> 
 <p>5. 释放共享内存</p> 
 <p>int shmctl(int shmid,int cmd,struct shmid_ds *buf);</p> 
 <p>Posix有名信号灯</p> 
 <p>1.posix有名信号灯函数</p> 
 <p>函数sem_open创建一个新的有名信号灯或打开一个已存在的有名信号灯。有名信号灯总是既可用于线程间的同步，又能用于进程间的同步。</p> 
 <p>1. sem_open</p> 
 <p>名称:：</p> 
 <p>sem_open</p> 
 <p>功能：</p> 
 <p>创建并初始化有名信号灯</p> 
 <p>头文件：</p> 
 <p>#include</p> 
 <p>函数原形：</p> 
 <p>sem_t *sem_open(const char *name,int oflag,/*mode_t mode,unsigned int value*/);</p> 
 <p>参数：</p> 
 <p>name   信号灯的外部名字</p> 
 <p>oflag   选择创建或打开一个现有的信号灯</p> 
 <p>mode 权限位</p> 
 <p>value 信号灯初始值</p> 
 <p>返回值：</p> 
 <p>成功时返回指向信号灯的指针，出错时为SEM_FAILED</p> 
 <p>oflag参数能是0、O_CREAT(创建一个信号灯)或O_CREAT|O_EXCL(如果没有指定的信号灯就创建)，如果指定了O_CREAT，那么第三个和第四个参数是需要的；其中mode参数指定权限位，value参数指定信号灯的初始值，通常用来指定共享资源的书面。该初始不能超过 SEM_VALUE_MAX，这个常值必须低于为32767。二值信号灯的初始值通常为1，计数信号灯的初始值则往往大于1。</p> 
 <p>如果指定了O_CREAT(而没有指定O_EXCL)，那么只有所需的信号灯尚未存在时才初始化他。所需信号灯已存在条件下指定O_CREAT不是个错误。该标志的意思仅仅是“如果所需信号灯尚未存在，那就创建并初始化他”。不过所需信号灯等已存在条件下指定O_CREAT|O_EXCL却是个错误。</p> 
 <p>sem_open返回指向sem_t信号灯的指针，该结构里记录着当前共享资源的数目。</p> 
 <p>/*semopen.c*/</p> 
 <p>#include  /* For O_* constants */</p> 
 <p>#include  /* For mode constants */</p> 
 <p>#include </p> 
 <p>int main(int argc, char **argv)</p> 
 <p>{<!-- --></p> 
 <p>sem_t *sem;</p> 
 <p>if (argc != 2)</p> 
 <p>{<!-- --></p> 
 <p>printf("please input a file name!\n");</p> 
 <p>exit(1);</p> 
 <p>}</p> 
 <p>sem = sem_open(argv[1], O_CREAT, 0644, 1);</p> 
 <p>exit(0);</p> 
 <p>}</p> 
 <p>2. sem_close</p> 
 <p>名称:：</p> 
 <p>sem_close</p> 
 <p>功能：</p> 
 <p>关闭有名信号灯</p> 
 <p>头文件：</p> 
 <p>#include</p> 
 <p>函数原形：</p> 
 <p>int sem_close(sem_t *sem);</p> 
 <p>参数：</p> 
 <p>sem 指向信号灯的指针</p> 
 <p>返回值：</p> 
 <p>若成功则返回0，否则返回-1。</p> 
 <p>一个进程终止时，内核还对其上仍然打开着的所有有名信号灯自动执行这样的信号灯关闭操作。不论该进程是自愿终止的还是非自愿终止的，这种自动关闭都会发生。</p> 
 <p>但应注意的是关闭一个信号灯并没有将他从系统中删除。这就是说，Posix有名信号灯至少是随内核持续的：即使当前没有进程打开着某个信号灯，他的值仍然保持。</p> 
 <p>3. sem_unlink</p> 
 <p>名称:：</p> 
 <p>sem_unlink</p> 
 <p>功能：</p> 
 <p>从系统中删除信号灯</p> 
 <p>头文件：</p> 
 <p>#include</p> 
 <p>函数原形：</p> 
 <p>int sem_unlink(count char *name);</p> 
 <p>参数：</p> 
 <p>name   信号灯的外部名字</p> 
 <p>返回值：</p> 
 <p>若成功则返回0，否则返回-1。</p> 
 <p>有名信号灯使用sem_unlink从系统中删除。</p> 
 <p>每个信号灯有一个引用计数器记录当前的打开次数，sem_unlink必须等待这个数为0时才能把name所指的信号灯从文件系统中删除。也就是要等待最后一个sem_close发生。</p> 
 <p>/*semunlink.c*/</p> 
 <p>int main(int argc, char **argv)</p> 
 <p>{<!-- --></p> 
 <p>sem_t *sem;</p> 
 <p>int val;</p> 
 <p>if (argc != 2)</p> 
 <p>{<!-- --></p> 
 <p>printf("please input a file name!\n");</p> 
 <p>exit(1);</p> 
 <p>}</p> 
 <p>if ((sem_unlink(argv[1])) != 0)</p> 
 <p>perror("sem_unlink");</p> 
 <p>else</p> 
 <p>printf("success");</p> 
 <p>exit(0);</p> 
 <p>}</p> 
 <p>4. sem_getvalue</p> 
 <p>名称:：</p> 
 <p>sem_getvalue</p> 
 <p>功能：</p> 
 <p>测试信号灯</p> 
 <p>头文件：</p> 
 <p>#include</p> 
 <p>函数原形：</p> 
 <p>int sem_getvalue(sem_t *sem,int *valp);</p> 
 <p>参数：</p> 
 <p>sem 指向信号灯的指针</p> 
 <p>返回值：</p> 
 <p>若成功则返回0，否则返回-1。</p> 
 <p>sem_getvalue在由valp指向的正数中返回所指定信号灯的当前值。如果该信号灯当前已上锁，那么返回值或为0，或为某个负数，其绝对值就是等待该信号灯解锁的线程数。</p> 
 <p align="center"><img src="" alt=""></p> 
 <p align="center"><img src="" alt="">代码</p> 
 <p>/*semgetvalue.c*/</p> 
 <p>int main(int argc, char **argv)</p> 
 <p>{<!-- --></p> 
 <p>sem_t *sem;</p> 
 <p>int val;</p> 
 <p>if (argc != 2)</p> 
 <p>{<!-- --></p> 
 <p>printf("please input a file name!\n");</p> 
 <p>exit(1);</p> 
 <p>}</p> 
 <p>sem = sem_open(argv[1], 0);</p> 
 <p>sem_getvalue(sem, &amp;val);</p> 
 <p>printf("getvalue: value = %d\n", val);</p> 
 <p>exit(0)</p> 
 <p>}</p> 
 <p>5. sem_wait/sem_trywait</p> 
 <p>名称:：</p> 
 <p>sem_wait/sem_trywait</p> 
 <p>功能：</p> 
 <p>等待共享资源</p> 
 <p>头文件：</p> 
 <p>#include</p> 
 <p>函数原形：</p> 
 <p>int sem_wait(sem_t *sem);</p> 
 <p>int sem_trywait(sem_t *sem);</p> 
 <p>参数：</p> 
 <p>sem 指向信号灯的指针</p> 
 <p>返回值：</p> 
 <p>若成功则返回0，否则返回-1。</p> 
 <p>我们能用sem_wait来申请共享资源，sem_wait函数能测试所指定信号灯的值，如果该值大于0，那就将他减1并即时返回。我们就能使用申请来的共享资源了。如果该值等于0，调用线程就被进入睡眠状态，直到该值变为大于0，这时再将他减1，函数随后返回。sem_wait操作必须是原子的。 sem_wait和sem_trywait的差别是：当所指定信号灯的值已是0时，后者并不将调用线程投入睡眠。相反，他返回一个EAGAIN错误。</p> 
 <p>下面的程式我们先不去运行，稍后再运行。</p> 
 <p>代码</p> 
 <p>/*semwait.c*/</p> 
 <p>int main(int argc, char **argv)</p> 
 <p>{<!-- --></p> 
 <p>sem_t *sem;</p> 
 <p>int val;</p> 
 <p>if (argc != 2)</p> 
 <p>{<!-- --></p> 
 <p>printf("please input a file name!\n");</p> 
 <p>exit(1);</p> 
 <p>}</p> 
 <p>sem = sem_open(argv[1], 0);</p> 
 <p>sem_wait(sem);</p> 
 <p>sem_getvalue(sem, &amp;val);</p> 
 <p>printf("pid % ld has semaphore, value = %d\n", (long)getpid(), val);</p> 
 <p>pause();</p> 
 <p>exit(0);</p> 
 <p>}</p> 
 <p>6. sem_post</p> 
 <p>名称:：</p> 
 <p>sem_post</p> 
 <p>功能：</p> 
 <p>挂出共享资源</p> 
 <p>头文件：</p> 
 <p>#include</p> 
 <p>函数原形：</p> 
 <p>int sem_post(sem_t *sem);</p> 
 <p>int sem_getvalue(sem_t *sem,int *valp);</p> 
 <p>参数：</p> 
 <p>sem 指向信号灯的指针</p> 
 <p>返回值：</p> 
 <p>若成功则返回0，否则返回-1。</p> 
 <p>当一个线程使用完某个信号灯时，他应该调用sem_post来告诉系统申请的资源已用完。本函数和sem_wait函数的功能正好相反，他把所指定的信号灯的值加1，然后唤醒正在等待该信号灯值变为正数的任意线程。</p> 
 <p>下面的程式我们先不去运行，稍后再运行。</p> 
 <p>代码</p> 
 <p>/*sempost.c*/</p> 
 <p>int main(int argc, char **argv)</p> 
 <p>{<!-- --></p> 
 <p>sem_t *sem;</p> 
 <p>int val;</p> 
 <p>if (argc != 2)</p> 
 <p>{<!-- --></p> 
 <p>printf("please input a file name!\n");</p> 
 <p>exit(1);</p> 
 <p>}</p> 
 <p>sem = sem_open(argv[1], 0);</p> 
 <p>sem_post(sem);</p> 
 <p>sem_getvalue(sem, &amp;val);</p> 
 <p>printf("value = %d\n", val);</p> 
 <p>exit(0);</p> 
 <p>}</p> 
 <p>二. 关于posix有名信号灯使用的几点注意</p> 
 <p>我们要注意以下几点：</p> 
 <p>1.Posix有名信号灯的值是随内核持续的。也就是说，一个进程创建了一个信号灯，这个进程结束后，这个信号灯还存在，并且信号灯的值也不会改动。</p> 
 <p>下面我们利用上面的几个程式来证实这点</p> 
 <p>#./semopen test</p> 
 <p>#./semgetvalue test</p> 
 <p>value=1   信号的值仍然是1</p> 
 <p>2。当持有某个信号灯锁的进程没有释放他就终止时，内核并不给该信号灯解锁。</p> 
 <p>#./semopen test</p> 
 <p>#./semwait test&amp;</p> 
 <p>pid 1834 has semaphore,value=0</p> 
 <p>#./semgetvalue test</p> 
 <p>value=0 信号量的值变为0了</p> 
 <p>3.posix有名信号灯应用于多线程</p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>#include  /* For O_* constants */</p> 
 <p>#include  /* For mode constants */</p> 
 <p>#include </p> 
 <p>#include </p> 
 <p>void *thread_function(void *arg); /* 线程入口函数 */</p> 
 <p>void print(); /* 共享资源函数 */</p> 
 <p>sem_t *sem; /* 定义Posix有名信号灯 */</p> 
 <p>int val; /* 定义信号灯当前值 */</p> 
 <p>int main(int argc, char *argv[])</p> 
 <p>{<!-- --></p> 
 <p>int n = 5;</p> 
 <p>pthread_t a_thread;</p> 
 <p>if (argc != 2)</p> 
 <p>{<!-- --></p> 
 <p>printf("please input a file name!\n");</p> 
 <p>exit(1);</p> 
 <p>}</p> 
 <p>sem = sem_open(argv[1], O_CREAT, 0644, 3); /* 打开一个信号灯 */</p> 
 <p>sem_getvalue(sem, &amp;val);</p> 
 <p>printf("The total sem is %d\n", val);</p> 
 <p>while(n--) /*循环创建5个子线程，使他们同步运行*/</p> 
 <p>{<!-- --></p> 
 <p>if ((pthread_create(&amp;a_thread, NULL, thread_function, &amp;n) != 0))</p> 
 <p>{<!-- --></p> 
 <p>perror("Thread creation failed");</p> 
 <p>exit(1);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>pthread_join(a_thread, NULL);</p> 
 <p>sem_getvalue(sem, &amp;val);</p> 
 <p>printf("In the end, sem is %d\n", val);</p> 
 <p>sem_close(sem);</p> 
 <p>sem_unlink(argv[1]);</p> 
 <p>}</p> 
 <p>void *thread_function(void *arg)</p> 
 <p>{<!-- --></p> 
 <p>int *ttid = arg;</p> 
 <p>sem_wait(sem); /* 申请信号灯 */</p> 
 <p>printf("the thread is %d\n", *ttid);</p> 
 <p>print(); /* 调用共享代码段 */</p> 
 <p>sleep(1);</p> 
 <p>sem_post(sem); /* 释放信号灯 */</p> 
 <p>printf("I'm finished, my tid is %d\n\n", pthread_self());</p> 
 <p>}</p> 
 <p>void print()</p> 
 <p>{<!-- --></p> 
 <p>printf("I get it, my tid is %d\n", pthread_self());</p> 
 <p>sem_getvalue(sem, &amp;val);</p> 
 <p>printf("Now the value have %d\n", val);</p> 
 <p>}</p> 
 <p>程式用循环的方法建立5个线程，然后让他们调用同一个线程处理函数thread_function，在函数里我们利用信号量来限制访问共享资源的线程数。共享资源我们用print函数来代表，在真正编程中他有能是个终端设备(如打印机)或是一段有实际意义的代码。</p> 
 <p>运行结果为：</p> 
 <p>#gcc sem1.c -o sem1 -lrt -lpthread</p> 
 <p>#.I get it,my tid is 1082330304</p> 
 <p>Now the value have 2</p> 
 <p>Iget it,my pid is 1894</p> 
 <p>Now the value have 1</p> 
 <p>Iget it,my pid is 1895</p> 
 <p>Now the value have 0</p> 
 <p>I’m finished,my pid is 1893</p> 
 <p>I’m finished,my pid is 1894</p> 
 <p>I’m finished,my pid is 1895</p> 
 <p>I get it,my pid is 1896</p> 
 <p>Now the value have 2</p> 
 <p>I get it,mypid is 1897</p> 
 <p>Now the value have 1</p> 
 <p>I’m finished,my pid is 1896</p> 
 <p>I’m finished,my pid is 1897</p> 
 <p>4.posix有名信号灯应用于多进程</p> 
 <p>下面就是应用Posix有名信号灯的一个小程序。用它来限制访问共享代码的进程数目。</p> 
 <p>#include</p> 
 <p>#include</p> 
 <p>#include</p> 
 <p>#include</p> 
 <p>void print(pid_t);</p> 
 <p>sem_t *sem; /*定义Posix有名信号灯*/</p> 
 <p>int val; /*定义信号灯当前值*/</p> 
 <p>int main(int argc,char *argv[])</p> 
 <p>{<!-- --></p> 
 <p>int n=0;</p> 
 <p>if(argc!=2)</p> 
 <p>{<!-- --></p> 
 <p>printf(“please input a file name!\n”);</p> 
 <p>exit(1);</p> 
 <p>}</p> 
 <p>sem=sem_open(argv[1],O_CREAT,0644,2); /*打开一个信号灯, 初值设为2*/</p> 
 <p>while(n++循环创建5个子进程，使它们同步运行*/</p> 
 <p>{<!-- --></p> 
 <p>if(fork()==0)</p> 
 <p>{<!-- --></p> 
 <p>sem_wait(sem); /*申请信号灯*/</p> 
 <p>print(getpid()); /*调用共享代码段*/</p> 
 <p>sleep(1);</p> 
 <p>sem_post(sem); /*释放信号灯*/</p> 
 <p>printf(“I’m finished,my pid is %d\n”,getpid());</p> 
 <p>return 0;</p> 
 <p>}</p> 
 <p>}</p> 
 <p>wait(); /*等待所有子进程结束*/</p> 
 <p>sem_close(sem);</p> 
 <p>sem_unlink(argv[1]);</p> 
 <p>exit(0);</p> 
 <p>}</p> 
 <p>void print(pid_t pid)</p> 
 <p>{<!-- --></p> 
 <p>printf(“I get it,my pid is %d\n”,pid);</p> 
 <p>sem_getvalue(sem,&amp;val);</p> 
 <p>printf(“Now the value have %d\n”,val);</p> 
 <p>}</p> 
 <p>程序编译后运行会得到如下结果：</p> 
 <p>#./8_2 8_2.c</p> 
 <p>I get it,my tid is 1082330304</p> 
 <p>Now the value have 1</p> 
 <p>I get it,my tid is 1090718784</p> 
 <p>Now the value have 0</p> 
 <p>I finished,my pid is 1082330304</p> 
 <p>I finished,my pid is 1090718784</p> 
 <p>I get it,my tid is 1099107264</p> 
 <p>Now the value have 1</p> 
 <p>I get it,my tid is 1116841120</p> 
 <p>Now the value have 0</p> 
 <p>I finished,my pid is 1099107264</p> 
 <p>I finished,my pid is 1116841120</p> 
 <p>I get it,my tid is 1125329600</p> 
 <p>Now the value have 1</p> 
 <p>I finished,my pid is 1125329600</p> 
 <p>三、基于内存的信号灯</p> 
 <p>前面已经介绍了Posix有名信号灯。这些信号灯由一个name参数标识，它通常指代文件系统中的某个文件。然而Posix也提供基于内存的信号灯，它们由应用程序分配信号灯的内存空间，然后由系统初始化它们的值。</p> 
 <p>7.</p> 
 <p>名称:：</p> 
 <p>sem_init/sem_destroy</p> 
 <p>功能：</p> 
 <p>初始化/关闭信号等</p> 
 <p>头文件：</p> 
 <p>#include</p> 
 <p>函数原形：</p> 
 <p>int sem_init(sem_t *sem,int shared,unsigned int value);</p> 
 <p>int sem_getvalue(sem_t *sem);</p> 
 <p>参数：</p> 
 <p>sem 指向信号灯的指针</p> 
 <p>shared   作用范围</p> 
 <p>value 信号灯初始值</p> 
 <p>返回值：</p> 
 <p>若成功则返回0，否则返回-1。</p> 
 <p>基于内存的信号灯是由sem_init初始化的。sem参数指向必须由应用程序分配的sem_t变量。如果shared为0，那么待初始化的信号灯是在同一进程的各个线程共享的，否则该信号灯是在进程间共享的。当shared为零时，该信号灯必须存放在即将使用它的所有进程都能访问的某种类型的共享内存中。跟sem_open一样，value参数是该信号灯的初始值。</p> 
 <p>使用完一个基于内存的信号灯后，我们调用sem_destroy关闭它。</p> 
 <p>除了sem_open和sem_close外，其它的poisx有名信号灯函数都可以用于基于内存的信号灯。</p> 
 <p>注意：posix基于内存的信号灯和posix有名信号灯有一些区别，我们必须注意到这些。</p> 
 <p>1.sem_open不需要类型与shared的参数，有名信号灯总是可以在不同进程间共享的。</p> 
 <p>2.sem_init不使用任何类似于O_CREAT标志的东西，也就是说，sem_init总是初始化信号灯的值。因此，对于一个给定的信号灯，我们必须小心保证只调用一次sem_init。</p> 
 <p>3.sem_open返回一个指向某个sem_t变量的指针，该变量由函数本身分配并初始化。但sem_init的第一个参数是一个指向某个sem_t变量的指针，该变量由调用者分配，然后由sem_init函数初始化。</p> 
 <p>4.posix有名信号灯是通过内核持续的，一个进程创建一个信号灯，另外的进程可以通过该信号灯的外部名(创建信号灯使用的文件名)来访问它。 posix基于内存的信号灯的持续性却是不定的，如果基于内存的信号灯是由单个进程内的各个线程共享的，那么该信号灯就是随进程持续的，当该进程终止时它也会消失。如果某个基于内存的信号灯是在不同进程间同步的，该信号灯必须存放在共享内存区中，这要只要该共享内存区存在，该信号灯就存在。</p> 
 <p>5.基于内存的信号灯应用于线程很麻烦(待会你会知道为什么)，而有名信号灯却很方便，基于内存的信号灯比较适合应用于一个进程的多个线程。</p> 
 <p>下面是posix基于内存的信号灯实现一个进程的各个线程间的互次。</p> 
 <p>#include</p> 
 <p>#include</p> 
 <p>#include</p> 
 <p>#include</p> 
 <p>#include</p> 
 <p>#incude</p> 
 <p>void *thread_function(void *arg); /*线程入口函数*/</p> 
 <p>void print(void); /*共享资源函数*/</p> 
 <p>sem_t bin_sem; /*定义信号灯*/</p> 
 <p>int value; /*定义信号量的灯*/</p> 
 <p>int main()</p> 
 <p>{<!-- --></p> 
 <p>int n=0;</p> 
 <p>pthread_t a_thread;</p> 
 <p>if((sem_init(&amp;bin_sem,0,2))!=0) /*初始化信号灯，初始值为2*/</p> 
 <p>{<!-- --></p> 
 <p>perror(“sem_init”);</p> 
 <p>exit(1);</p> 
 <p>}</p> 
 <p>while(n++循环创建5个线程*/</p> 
 <p>{<!-- --></p> 
 <p>if((pthread_create(&amp;a_thread,NULL,thread_function,NULL))!=0)</p> 
 <p>{<!-- --></p> 
 <p>perror(“Thread creation failed”);</p> 
 <p>exit(1);</p> 
 <p>}</p> 
 <p>}</p> 
 <p>pthread_join(a_thread,NULL);/*等待子线程返回*/</p> 
 <p>}</p> 
 <p>void *thread_function(void *arg)</p> 
 <p>{<!-- --></p> 
 <p>sem_wait(&amp;bin_sem); /*等待信号灯*/</p> 
 <p>print();</p> 
 <p>sleep(1);</p> 
 <p>sem_post(&amp;bin_sem); /*挂出信号灯*/</p> 
 <p>printf(“I finished,my pid is %d\n”,pthread_self());</p> 
 <p>pthread_exit(arg);</p> 
 <p>}</p> 
 <p>void print()</p> 
 <p>{<!-- --></p> 
 <p>printf(“I get it,my tid is %d\n”,pthread_self());</p> 
 <p>sem_getvalue(&amp;bin_sem,&amp;value); /*获取信号灯的值*/</p> 
 <p>printf(“Now the value have %d\n”,value);</p> 
 <p>}</p> 
 <p>posix基于内存的信号灯和有名信号灯基本是一样的，上面的几点区别就可以了。</p> 
 <p>下面是运行结果：</p> 
 <p>#gcc –lpthread –o seminitthread seminitthread.c</p> 
 <p>#./seminitthread</p> 
 <p>I get it,my tid is 1082330304</p> 
 <p>Now the value have 1</p> 
 <p>I get it,my tid is 1090718784</p> 
 <p>Now the value have 0</p> 
 <p>I finished,my pid is 1082330304</p> 
 <p>I finished,my pid is 1090718784</p> 
 <p>I get it,my tid is 1099107264</p> 
 <p>Now the value have 1</p> 
 <p>I get it,my tid is 1116841120</p> 
 <p>Now the value have 0</p> 
 <p>I finished,my pid is 1099107264</p> 
 <p>I finished,my pid is 1116841120</p> 
 <p>I get it,my tid is 1125329600</p> 
 <p>Now the value have 1</p> 
 <p>I finished,my pid is 1125329600</p> 
 <p>下面的程序并不能得到我们想要的结果。</p> 
 <p>#include</p> 
 <p>#include</p> 
 <p>#include</p> 
 <p>#include</p> 
 <p>void print(pid_t);</p> 
 <p>sem_t *sem; /*定义Posix有名信号灯*/</p> 
 <p>int val; /*定义信号灯当前值*/</p> 
 <p>int main(int argc,char *argv[])</p> 
 <p>{<!-- --></p> 
 <p>int n=0;</p> 
 <p>sem=sem_open(argv[1],O_CREAT,0644,3); /*打开一个信号灯*/</p> 
 <p>sem_getvalue(sem,&amp;val); /*查看信号灯的值*/</p> 
 <p>printf(“The value have %d\n”,val);</p> 
 <p>while(n++循环创建5个子进程，使它们同步运行*/</p> 
 <p>{<!-- --></p> 
 <p>if(fork()==0)</p> 
 <p>{<!-- --></p> 
 <p>sem_wait(sem); /*申请信号灯*/</p> 
 <p>print(getpid()); /*调用共享代码段*/</p> 
 <p>sleep(1);</p> 
 <p>sem_post(sem); /*释放信号灯*/</p> 
 <p>printf(“I’m finished,my pid is %d\n”,getpid());</p> 
 <p>return 0;</p> 
 <p>}</p> 
 <p>wait(); /*等待所有子进程结束*/</p> 
 <p>return 0;</p> 
 <p>}</p> 
 <p>void print(pid_t pid)</p> 
 <p>{<!-- --></p> 
 <p>printf(“I get it,my pid is %d\n”,pid);</p> 
 <p>sem_getvalue(sem,&amp;val);</p> 
 <p>printf(“Now the value have %d\n”,val);</p> 
 <p>}</p> 
 <p>下面是运行结果：</p> 
 <p>#cc –lpthread –o sem sem.c</p> 
 <p>#./sem</p> 
 <p>The value have 3</p> 
 <p>I get it,my pid is 2236</p> 
 <p>Now the value have 2</p> 
 <p>I get it,my pid is 2237</p> 
 <p>Now the value have 2</p> 
 <p>I get it,my pid is 2238</p> 
 <p>Now the value have 2</p> 
 <p>I get it,my pid is 2239</p> 
 <p>Now the value have 2</p> 
 <p>Iget it,my pid is 2240</p> 
 <p>Now the value have 2</p> 
 <p>I’m finished,my pid is 2236</p> 
 <p>I’m finished,my pid is 2237</p> 
 <p>I’m finished,my pid is 2238</p> 
 <p>I’m finished,my pid is 2239</p> 
 <p>I’m finished,my pid is 2240</p> 
 <p>问题在于sem信号灯不在共享内存区中。fork出来的子进程通常不共享父进程的内存空间。子进程是在父进程内存空间的拷贝上启动的，它跟共享内存不是一回事。</p> 
 <p>if ($ != jQuery) { $ = jQuery.noConflict(); } var isLogined = false; var cb_blogId = 73254; var cb_entryId = 1938552; var cb_blogApp = "BloodAndBone"; var cb_blogUserGuid = "b0469f6d-1f92-df11-ba8f-001cf0cd104b"; var cb_entryCreatedDate = '2011/1/18 18:05:00';</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e14a1d72ad33f05746247bbdccbde1d7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">米家的扫地机器人是灰色_米家扫地机器人怎么清理灰尘盒</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c78ca9bd859f1304e06ec64db7448283/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VS2019 c&#43;&#43;使用sqlite3中文乱码解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>