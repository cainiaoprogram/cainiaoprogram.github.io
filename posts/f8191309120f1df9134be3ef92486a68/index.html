<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CeresSolver采用稀疏矩阵求解大规模BA时参数块设定 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CeresSolver采用稀疏矩阵求解大规模BA时参数块设定" />
<meta property="og:description" content="CeresSolver采用稀疏矩阵求解大规模BA时参数块设定 前言 在大规模BA求解中，通常会关注到相机位姿与路标参数构成矩阵的稀疏性，将相机位姿参数与路标点参数分组，采用舒尔补充等方法进行消元求解数据量大的组别，提升求解效率，具体可以参考ceres的LinearSolver¶部分。
在实际使用中，构造代价函数时需明确哪些参数为路标点参数，需要被消去；哪些参数为相机参数，首先求解，相当于将参数分组，并决定其消去的顺序。ceres内置了自动分组的方法，但有时不能奏效，此时就需要我们手工指定参数块的分组，并且来决定参数被消去的顺序。
CeresSolver教程相关说明 Ordering¶ The order in which variables are eliminated in a linear solver can have a significant of impact on the efficiency and accuracy of the method. For example when doing sparse Cholesky factorization, there are matrices for which a good ordering will give a Cholesky factor with O(n) storage, where as a bad ordering will result in an completely dense factor.
线性解算器中变量的消除顺序对方法的效率和准确性有重大影响。例如，在进行稀疏Cholesky分解时，对于某些矩阵，良好的排序将给出具有O（n）存储的Cholesky因子，而糟糕的排序将导致完全稠密因子。
Ceres allows the user to provide varying amounts of hints to the solver about the variable elimination ordering to use." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f8191309120f1df9134be3ef92486a68/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-19T15:19:52+08:00" />
<meta property="article:modified_time" content="2022-05-19T15:19:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CeresSolver采用稀疏矩阵求解大规模BA时参数块设定</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="CeresSolverBA_0"></a>CeresSolver采用稀疏矩阵求解大规模BA时参数块设定</h2> 
<h3><a id="_2"></a>前言</h3> 
<p>在大规模BA求解中，通常会关注到相机位姿与路标参数构成矩阵的稀疏性，将相机位姿参数与路标点参数分组，采用舒尔补充等方法进行消元求解数据量大的组别，提升求解效率，具体可以参考ceres的LinearSolver<a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#linearsolver" rel="nofollow">¶</a>部分。</p> 
<p>在实际使用中，构造代价函数时需明确哪些参数为路标点参数，需要被消去；哪些参数为相机参数，首先求解，相当于将参数分组，并决定其消去的顺序。ceres内置了自动分组的方法，但有时不能奏效，此时就需要我们手工指定参数块的分组，并且来决定参数被消去的顺序。</p> 
<h3><a id="CeresSolver_8"></a>CeresSolver教程相关说明</h3> 
<h4><a id="Orderinghttpceressolverorgnnls_solvinghtmlhighlightorderingordering_10"></a><strong>Ordering</strong><a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#ordering" rel="nofollow">¶</a></h4> 
<p>The order in which variables are eliminated in a linear solver can have a significant of impact on the efficiency and accuracy of the method. For example when doing sparse Cholesky factorization, there are matrices for which a good <strong>ordering</strong> will give a Cholesky factor with O(n) storage, where as a bad ordering will result in an completely dense factor.</p> 
<p>线性解算器中变量的消除顺序对方法的效率和准确性有重大影响。例如，在进行稀疏Cholesky分解时，对于某些矩阵，良好的<strong>排序</strong>将给出具有O（n）存储的Cholesky因子，而糟糕的排序将导致完全稠密因子。</p> 
<p>Ceres allows the user to provide varying amounts of hints to the solver about the variable elimination <strong>ordering</strong> to use. This can range from no hints, where the solver is free to decide the best ordering based on the user’s choices like the linear solver being used, to an exact order in which the variables should be eliminated, and a variety of possibilities in between.</p> 
<p>Ceres允许用户向解算器提供不同数量的关于变量消除<strong>顺序</strong>使用的提示。这可能包括从没有提示，解算器可以根据用户的选择（如使用的线性解算器）自由决定最佳顺序，到消除变量的确切顺序，以及介于两者之间的各种可能性。</p> 
<p>Instances of the <a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4N5ceres22ParameterBlockOrderingE" rel="nofollow"><code>ParameterBlockOrdering</code></a> class are used to communicate this information to Ceres.</p> 
<p>[<code>ParameterBlockOrdering</code>]的实例类用于将此信息传达给Ceres。</p> 
<p>Formally an <strong>ordering</strong> is an ordered partitioning of the parameter blocks. Each parameter block belongs to exactly one group, and each group has a unique integer associated with it, that determines its order in the set of groups. We call these groups <em>Elimination Groups</em></p> 
<p>形式上，<strong>排序</strong>是参数块的有序划分。每个参数块只属于一个组，每个组都有一个与之关联的唯一整数，该整数决定了它在组集中的顺序。我们称之为消除组*</p> 
<p>Given such an <strong>ordering</strong>, Ceres ensures that the parameter blocks in the lowest numbered elimination group are eliminated first, and then the parameter blocks in the next lowest numbered elimination group and so on. Within each elimination group, Ceres is free to order the parameter blocks as it chooses. For example, consider the linear system</p> 
<p>给定这样的<strong>顺序</strong>，Ceres确保首先消除编号最低的消除组中的参数块，然后消除下一个编号最低的消除组中的参数块，依此类推。在每个消除组中，Ceres可以根据自己的选择自由排列参数块。例如，考虑线性系统<br> <span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          x 
         
        
          + 
         
        
          y 
         
        
          = 
         
        
          3 
         
         
        
          2 
         
        
          x 
         
        
          + 
         
        
          3 
         
        
          y 
         
        
          = 
         
        
          7 
         
        
       
         x+y=3\\ 2x+3y=7 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.66666em; vertical-align: -0.08333em;"></span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.625em; vertical-align: -0.19444em;"></span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">3</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height: 0.72777em; vertical-align: -0.08333em;"></span><span class="mord">2</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right: 0.222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.222222em;"></span></span><span class="base"><span class="strut" style="height: 0.83888em; vertical-align: -0.19444em;"></span><span class="mord">3</span><span class="mord mathdefault" style="margin-right: 0.03588em;">y</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.64444em; vertical-align: 0em;"></span><span class="mord">7</span></span></span></span></span></span><br> There are two ways in which it can be solved. First eliminating x from the two equations, solving for y and then back substituting for x, or first eliminating y, solving for x and back substituting for y. The user can construct three <strong>ordering</strong>s here.</p> 
<p>有两种方法可以解决这个问题。首先从两个方程中消除x，解出y，然后反代x，或者先消除y，解出x，反代y。用户可以在这里构造三个<strong>排序</strong>s。</p> 
<ol><li>{0:x},{1:y} : Eliminate x first.</li><li>{0:y},{1:x} : Eliminate y first.</li><li>{0:x,y} : Solver gets to decide the elimination order.</li></ol> 
<p>Thus, to have Ceres determine the <strong>ordering</strong> automatically using heuristics, put all the variables in the same elimination group. The identity of the group does not matter. This is the same as not specifying an ordering at all. To control the ordering for every variable, create an elimination group per variable, ordering them in the desired order.</p> 
<p>因此，为了让Ceres使用启发法自动确定<strong>排序</strong>，将所有变量放在同一个消除组中。团体的身份无关紧要。这与根本不指定排序相同。要控制每个变量的顺序，请为每个变量创建一个消除组，并按所需顺序对它们进行排序。</p> 
<p>If the user is using one of the Schur solvers (<code>DENSE_SCHUR</code>, <code>SPARSE_SCHUR</code>, <code>ITERATIVE_SCHUR</code>) and chooses to specify an <strong>ordering</strong>, it must have one important property. The lowest numbered elimination group must form an independent set in the graph corresponding to the Hessian, or in other words, no two parameter blocks in in the first elimination group should co-occur in the same residual block. For the best performance, this elimination group should be as large as possible. For standard bundle adjustment problems, this corresponds to the first elimination group containing all the 3d points, and the second containing the all the cameras parameter blocks.</p> 
<p>如果用户正在使用一个舒尔解算器（“稠密舒尔”、“稀疏舒尔”、“迭代舒尔”），并选择指定<strong>排序</strong>，则它必须具有一个重要属性。编号最低的消除组必须在对应于Hessian的图中形成一个独立集，或者换句话说，第一个消除组中的两个参数块不应同时出现在同一个剩余块中。为了获得最佳性能，该淘汰组应尽可能大。对于标准束调整问题，这对应于包含所有3d点的第一个消除组，以及包含所有摄影机参数块的第二个消除组。</p> 
<p>If the user leaves the choice to Ceres, then the solver uses an approximate maximum independent set algorithm to identify the first elimination group [<a href="http://ceres-solver.org/bibliography.html#lisaad" rel="nofollow">LiSaad]</a>.</p> 
<p>如果用户将选择权留给Ceres，则解算器使用近似最大独立集算法来识别第一个消除组[<a href="http://ceres-solver.org/bibliography.html#lisaad" rel="nofollow">LiSaad]</a>.</p> 
<h4><a id="CeresSolver_55"></a>CeresSolver中对应类的实现</h4> 
<h5><a id="ParameterBlockOrderinghttpceressolverorgnnls_solvinghtmlhighlightordering_CPPv4N5ceres22ParameterBlockOrderingEhttpceressolverorgnnls_solvinghtmlhighlightorderingparameterblockordering_57"></a><a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4N5ceres22ParameterBlockOrderingE" rel="nofollow"><code>ParameterBlockOrdering</code></a><a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#parameterblockordering" rel="nofollow">¶</a></h5> 
<ul><li> <p><em>class</em> ParameterBlock<strong>Ordering</strong><a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4N5ceres22ParameterBlockOrderingE" rel="nofollow">¶</a></p> <p><code>ParameterBlockOrdering</code> is a class for storing and manipulating an ordered collection of groups/sets with the following semantics:Group IDs are non-negative integer values. Elements are any type that can serve as a key in a map or an element of a set.An element can only belong to one group at a time. A group may contain an arbitrary number of elements.Groups are ordered by their group id.</p> <p><code>ParameterBlockOrdering</code>是一个用于存储和操作有序的组/集集合的类，具有以下语义：组ID是非负整数值。元素是可以作为地图中的键或集合中的元素的任何类型。一个元素一次只能属于一个组。一个组可以包含任意数量的元素。组按其组id排序。</p> </li><li> <p>bool <a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4N5ceres22ParameterBlockOrderingE" rel="nofollow">ParameterBlock<strong>Ordering</strong></a>::AddElementToGroup(<em>const</em> double *element, <em>const</em> int group)<a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4N5ceres22ParameterBlockOrdering17AddElementToGroupEPKdKi" rel="nofollow">¶</a></p> <p>Add an element to a group. If a group with this id does not exist, one is created. This method can be called any number of times for the same element. Group ids should be non-negative numbers. Return value indicates if adding the element was a success.</p> <p>向组中添加元素。如果不存在具有此id的组，则会创建一个组。对于同一个元素，可以多次调用此方法。组ID应该是非负数。返回值指示添加元素是否成功。</p> </li><li> <p>void <a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4N5ceres22ParameterBlockOrderingE" rel="nofollow">ParameterBlock<strong>Ordering</strong></a>::Clear()<a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4N5ceres22ParameterBlockOrdering5ClearEv" rel="nofollow">¶</a></p> <p>Clear the <strong>ordering</strong>.</p> <p>清除<strong>命令</strong>。</p> </li><li> <p>bool <a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4N5ceres22ParameterBlockOrderingE" rel="nofollow">ParameterBlock<strong>Ordering</strong></a>::Remove(<em>const</em> double *element)<a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4N5ceres22ParameterBlockOrdering6RemoveEPKd" rel="nofollow">¶</a></p> <p>Remove the element, no matter what group it is in. If the element is not a member of any group, calling this method will result in a crash. Return value indicates if the element was actually removed.</p> <p>移除该元素，无论它在哪个组中。如果元素不是任何组的成员，调用此方法将导致崩溃。返回值指示元素是否已实际删除。</p> </li><li> <p>void <a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4N5ceres22ParameterBlockOrderingE" rel="nofollow">ParameterBlock<strong>Ordering</strong></a>::Reverse()<a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4N5ceres22ParameterBlockOrdering7ReverseEv" rel="nofollow">¶</a></p> <p>Reverse the order of the groups in place.</p> <p>颠倒分组顺序。</p> </li><li> <p>int <a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4N5ceres22ParameterBlockOrderingE" rel="nofollow">ParameterBlock<strong>Ordering</strong></a>::GroupId(<em>const</em> double *element) <em>const</em><a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4NK5ceres22ParameterBlockOrdering7GroupIdEPKd" rel="nofollow">¶</a></p> <p>Return the group id for the element. If the element is not a member of any group, return -1.</p> <p>返回元素的组id。如果元素不是任何组的成员，则返回-1。</p> </li><li> <p>bool <a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4N5ceres22ParameterBlockOrderingE" rel="nofollow">ParameterBlock<strong>Ordering</strong></a>::IsMember(<em>const</em> double *element) <em>const</em><a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4NK5ceres22ParameterBlockOrdering8IsMemberEPKd" rel="nofollow">¶</a></p> <p>True if there is a group containing the parameter block.</p> <p>如果存在包含参数块的组，则为True。</p> </li><li> <p>int <a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4N5ceres22ParameterBlockOrderingE" rel="nofollow">ParameterBlock<strong>Ordering</strong></a>::GroupSize(<em>const</em> int group) <em>const</em><a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4NK5ceres22ParameterBlockOrdering9GroupSizeEKi" rel="nofollow">¶</a></p> <p>This function always succeeds, i.e., implicitly there exists a group for every integer.</p> <p>这个函数总是成功的，也就是说，每个整数隐式地存在一个组。</p> </li><li> <p>int <a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4N5ceres22ParameterBlockOrderingE" rel="nofollow">ParameterBlock<strong>Ordering</strong></a>::NumElements() <em>const</em><a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4NK5ceres22ParameterBlockOrdering11NumElementsEv" rel="nofollow">¶</a></p> <p>Number of elements in the <strong>ordering</strong>.</p> <p><strong>排序</strong>中的元素数。</p> </li><li> <p>int <a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4N5ceres22ParameterBlockOrderingE" rel="nofollow">ParameterBlock<strong>Ordering</strong></a>::NumGroups() <em>const</em><a href="http://ceres-solver.org/nnls_solving.html?highlight=ordering#_CPPv4NK5ceres22ParameterBlockOrdering9NumGroupsEv" rel="nofollow">¶</a></p> <p>Number of groups with one or more elements.</p> <p>包含一个或多个元素的组数。</p> </li></ul> 
<h4><a id="_119"></a>代码实战</h4> 
<pre><code class="prism language-c++">ceres::ParameterBlockOrdering* ordering = new ceres::ParameterBlockOrdering();
 
// set all points in ordering to 0
for(int i = 0; i &lt; num_points; i++){
    ordering-&gt;AddElementToGroup(points + i * point_block_size, 0);
}
// set all cameras in ordering to 1
for(int i = 0; i &lt; num_cameras; i++){
    ordering-&gt;AddElementToGroup(cameras + i * camera_block_size, 1);
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a45c1692785dbfa111746d82dcbb2726/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ADB操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2a856fa34b4ce00a3d63305fa3028127/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【杂项学习】Open3D的基本使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>