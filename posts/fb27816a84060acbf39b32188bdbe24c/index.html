<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机组成原理——输入输出设备（Input Output Equip-ment） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算机组成原理——输入输出设备（Input Output Equip-ment）" />
<meta property="og:description" content="输入输出设备 输入输出系统的发展阶段第一阶段（早期阶段）第二阶段（接口模块与DMA阶段）（讲解的重点）第三阶段（具有通道结构的阶段）第四阶段（具有I/O处理机的阶段） 输入输出系统的组成I/O软件软件的主要任务指令I/O指令通道指令 I/O硬件 I/O设备与主机的联系方式I/O设备编址方式设备寻址信息传送方式状态联络方式I/O设备与主机的连接方式 I/O设备与主机信息传送的控制方式程序查询方式程序中断方式DMA（直接存储器存取）方式 I/O接口接口设置的原因(通用)接口的功能与组成总线连接方式的I/O接口电路接口功能 接口类型 程序查询方式程序查询的流程只有一台I/O设备的情况下查询流程程序流程 有较多I/O设备的情况下查询流程 程序查询方式的接口电路接口电路组成工作流程（以输入设备为例） 程序中断方式程序中断程序中断方式的接口电路接口电路组成I/O中断处理流程/工作流程（以输入设备为例） CPU的中断服务程序的流程中断分类（按照是否在CPU执行中断过程中可以被新的中断请求打断） DMA方式DMA方式下I/O设备与主存直接交换数据的方式停止CPU访问主存周期挪用（周期窃取）DMA与CPU交替访问 DMA接口（DMA方式的接口电路）接口电路组成DMA接口的功能工作流程（输入、输出的案例皆有）预处理数据传送后处理 DMA接口与系统的连接方式DMA方式与程序中断方式的比较DMA接口的类型 输入输出系统的发展阶段 第一阶段（早期阶段） I/O设备较少，I/O设备与主存交换信息都必须通过CPU，每一个I/O设备都具有一套独立的逻辑电路与CPU相连，用来实现I/O设备与主机之间的信息交换，线路十分散乱复杂，而且由于I/O设备与主机交换信息时，CPU只能停止运算，即I/O设备与CPU是按照串行方式进行工作的，减低了工作效率，再者，由于每一个I/O设备的逻辑控制电路与CPU的控制器已经构成了一个不可分割的整体，于是进行I/O设备的增添、撤减是极其困难的
第二阶段（接口模块与DMA阶段）（讲解的重点） 计算机系统采用了总线结构，I/O设备通过接口模块与主机相连接，而且通常在接口中都设有数据通路和控制通路，数据经过接口既可以起到缓冲作用，又可以实现串并变换，控制通路用以传送CPU向I/O设备发出的各种控制命令，或者使CPU接收来自I/O设备的反馈信号。许多接口还能满足中断请求处理的要求，使得I/O设备与CPU可以按照并行方式进行工作（虽然并不是绝对的并行工作），提高了CPU的工作效率，此外接口技术还可以实现多台I/O设备分时占用总线，使得I/O设备之间也可以实现并行工作方式，提高了整机效率
为了进一步提高CPU工作效率，又出现了DMA（直接存储器存取）技术，特点是I/O设备与主存之间存在一条直接数据通路，I/O设备可以与主存直接交换信息，使得CPU在I/O设备与主存交换信息这个时间段内可以继续完成自身工作，资源利用率得到了进一步的提升
第三阶段（具有通道结构的阶段） 采用DMA方式虽然可以实现高速I/O设备与主机之间成组数据的交换，但是在大型计算机中使用DMA方式就会出现一些问题：
1、如果每一台I/O设备都配置上专用的DMA接口，不仅会增加硬件成本，还会因为要解决众多DMA接口同时访问主存的冲突问题使得控制变得十分复杂2、CPU需要对众多的DMA接口进行管理，也会影响整机工作效率。因此在大中型计算机系统中，一般采用I/O通道的方式进行数据交换，通道是用来负责管理I/O设备以及实现主存与I/O设备之间交换信息的部件，可以视为一种具有特殊功能的处理器，其具有专用的通道指令，可以独立地执行用通道指令所编写的输入输出程序，但是并不是一个完全独立的处理器，它要依据CPU的I/O指令进行启动、停止或者改变工作状态。是从属于CPU的一个专用处理器。依赖通道管理的I/O设备在与主机交换信息时，CPU不直接参与管理 第四阶段（具有I/O处理机的阶段） I/O处理机又称为外围处理机，基本独立于主机工作，既可以完成I/O通道要完成的I/O控制，又可以完成码制变换、格式处理、数据块检错、纠错等操作。具有I/O处理机的输入输出系统与CPU工作的并行性更高，I/O系统对于主机来说具有更大的独立性
输入输出系统的组成 I/O软件 软件的主要任务 将用户编制的程序或者数据输入主机中将运算结果输送给用户实现输入输出系统与主机工作的协调 指令 不同结构的输入输出系统所采用的软件技术差异很大：在采用接口模块方式时，使用机器指令系统中的I/O指令与系统软件中的管理程序即可实现I/O设备与主机的协调工作，在采用通道管理方式时，除了要使用I/O指令之外，还需要使用通道指令以及相应的操作系统。就算都采用操作系统，不同的机器其操作系统的复杂程度差异也是很大的。
I/O指令 I/O指令为机器指令的一类，为CPU指令系统的一部分，是CPU用来控制输入输出操作的指令，由CPU译码以后执行。I/O指令可以和其他机器指令的字长相同，但是也是会反映CPU与I/O设备交换信息的特点，比如反映出对多台I/O设备的选择以及应该对设备进行哪些具体操作
操作码 可以作为I/O指令与其他指令（比如，访存指令、控制指令、算逻指令）的判别码，标识该指令为I/O指令 命令码 体现了I/O设备的具体操作，命令码相当于CPU普通指令集中的操作码部分 操作分类：1、将数据从I/O设备输入主机；2、将数据从主机输出到I/O设备；3、状态测试，比如利用命令码检测各个I/O设备所处状态为 忙 还是 准备就绪；4、形成某些操作命令，不同I/O设备和主机进行信息交换的时候，需要完成的操作各不相同，比如磁盘驱动器需要进行读扇区、写扇区、找磁道等操作 设备码 是多台I/O设备的选择码，相当于各个设备的地址（只有对I/O设备进行编号，才能准确的选择某一台设备与主机交换信息） 通道指令 通道指令又称为CCW（通道控制字），是对具有通道的I/O系统为通道专门设置的指令，在具有通道结构的计算机中，I/O指令主要完成I/O设备的启动、停止操作、查询通道和I/O设备状态以及控制通道所做的其他操作，不实现I/O数据的传送操作，这种具有通道指令的计算机一旦CPU执行了启动I/O设备的指令，通道就会替代CPU对I/O设备进行管理。通道指令一般用来指明参与传送的数据在主存中的首地址；指明需要传送的字节数或者所传送数据的末地址；指明所选设备的设备码以及完成某种操作的命令码。一般位数比较多，通道程序即由通道指令所构成，用来完成某种外围设备与主存之间传送信息的操作
I/O硬件 输入输出系统的硬件组成是多样的，在带有接口的I/O系统中，一般包括接口模块以及I/O设备两大部分；在具有通道的I/O系统中，一个通道可以和一个以上的设备控制器相连，一个设备控制器又可以控制若干台同一类型的设备
I/O设备与主机的联系方式 I/O设备与主机交换信息和CPU与主存交换信息相比，有许多不同点。例如，CPU如何对I/O设备编址；如何寻找I/O设备号；信息传送是逐位串行还是多位并行；I/O设备与主机以什么方式进行联络，使它们彼此都知道对方处于何种状态；I/O设备与主机是怎么连接的，等等。这一系列问题统称为I/O设备与主机的联系方式
I/O设备编址方式 通常将I/O设备码看作地址码，对I/O地址码的编址可以采用统一编址和不统一编址两种方式
统一编址（映像编址） 将I/O地址看作是存储器地址的一部分，是从存储器空间划出一部分地址空间给I/O设备，把I/O接口中的端口当作存储器单元一样进行访问，比如在64K地址的存储空间中，划分出8K地址作为I/O设备的地址，但凡地址落在这8K地址范围内，该地址要进行的操作就是指向I/O设备的。这种编址方式占用了存储空间，减少了主存容量，但是无需设置专用的I/O指令，有一部分对存储器使用的指令也可以用于端口 不统一编址（独立编址） 指的是I/O地址和存储器地址是分开的，所有对于I/O设备的访问都必须使用专用的I/O指令进行。这种编址方式不占用主存空间，不需要为I/O端口留出地址空间，所以不影响主存容量，但是需要设置I/O专用指令。8086系统采用的就是这种独立的I/O编址方式 设备寻址 由于每一台I/O设备都被赋予了一个设备号，于是，要启动某一台设备是可以由I/O指令的设备码字段直接指出该设备的设备号。通过接口电路中的设备选择电路，即可选中要进行信息交换的I/O设备
信息传送方式 并行传送 在同一时间，n位信息同时从CPU输出至I/O设备，或者由I/O设备输入到CPU，这种传送方式的速度较快，但是要求数据线多 串行传送 在同一时间，只传送一位二进制信息，在不同时刻连续逐位传送一串信息，这种传送方式的速度较慢，但是只需要一根数据线和一根地线，当I/O设备与主机距离遥远的时候，采用串行传送比较合理，比如远距离数据通信 状态联络方式 立即响应方式
对于一些工作速度十分缓慢的I/O设备，比如指示灯的亮与灭、开关的通与断等，当它们与CPU发生联系时，通常都会使这种设备可确定地处于某种等待状态，只要CPU的I/O指令一到，就可以实现响应，无需使用特殊的联络信号来确定设备的状态（即假设外设已经处于就绪状态，所以不必去查询外设的状态，直接执行CPU的I/O指令进行数据传送） 异步工作采用应答信号联络
当I/O设备与主机工作速度不匹配的时候，通常采用异步工作方式，这种方式下，I/O设备与CPU只有在出现联络信号的时候，才会开始准备交换信息" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fb27816a84060acbf39b32188bdbe24c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-17T13:15:32+08:00" />
<meta property="article:modified_time" content="2023-06-17T13:15:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机组成原理——输入输出设备（Input Output Equip-ment）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>输入输出设备</h4> 
 <ul><li><a href="#_1" rel="nofollow">输入输出系统的发展阶段</a></li><li><ul><li><a href="#_2" rel="nofollow">第一阶段（早期阶段）</a></li><li><a href="#DMA_5" rel="nofollow">第二阶段（接口模块与DMA阶段）（讲解的重点）</a></li><li><a href="#_10" rel="nofollow">第三阶段（具有通道结构的阶段）</a></li><li><a href="#IO_15" rel="nofollow">第四阶段（具有I/O处理机的阶段）</a></li></ul> 
  </li><li><a href="#_18" rel="nofollow">输入输出系统的组成</a></li><li><ul><li><a href="#IO_19" rel="nofollow">I/O软件</a></li><li><ul><li><a href="#_20" rel="nofollow">软件的主要任务</a></li><li><a href="#_25" rel="nofollow">指令</a></li><li><ul><li><a href="#IO_28" rel="nofollow">I/O指令</a></li><li><a href="#_41" rel="nofollow">通道指令</a></li></ul> 
   </li></ul> 
   </li><li><a href="#IO_45" rel="nofollow">I/O硬件</a></li></ul> 
  </li><li><a href="#IO_49" rel="nofollow">I/O设备与主机的联系方式</a></li><li><ul><li><a href="#IO_52" rel="nofollow">I/O设备编址方式</a></li><li><a href="#_59" rel="nofollow">设备寻址</a></li><li><a href="#_62" rel="nofollow">信息传送方式</a></li><li><a href="#_68" rel="nofollow">状态联络方式</a></li><li><a href="#IO_83" rel="nofollow">I/O设备与主机的连接方式</a></li></ul> 
  </li><li><a href="#IO_92" rel="nofollow">I/O设备与主机信息传送的控制方式</a></li><li><ul><li><a href="#_95" rel="nofollow">程序查询方式</a></li><li><a href="#_108" rel="nofollow">程序中断方式</a></li><li><a href="#DMA_118" rel="nofollow">DMA（直接存储器存取）方式</a></li></ul> 
  </li><li><a href="#IO_129" rel="nofollow">I/O接口</a></li><li><ul><li><a href="#_136" rel="nofollow">接口设置的原因</a></li><li><a href="#_143" rel="nofollow">(通用)接口的功能与组成</a></li><li><ul><li><a href="#IO_144" rel="nofollow">总线连接方式的I/O接口电路</a></li><li><a href="#_160" rel="nofollow">接口功能</a></li></ul> 
   </li><li><a href="#_173" rel="nofollow">接口类型</a></li></ul> 
  </li><li><a href="#_191" rel="nofollow">程序查询方式</a></li><li><ul><li><a href="#_192" rel="nofollow">程序查询的流程</a></li><li><ul><li><a href="#IO_198" rel="nofollow">只有一台I/O设备的情况下</a></li><li><ul><li><a href="#_199" rel="nofollow">查询流程</a></li><li><a href="#_201" rel="nofollow">程序流程</a></li></ul> 
    </li><li><a href="#IO_218" rel="nofollow">有较多I/O设备的情况下</a></li><li><ul><li><a href="#_219" rel="nofollow">查询流程</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_222" rel="nofollow">程序查询方式的接口电路</a></li><li><ul><li><a href="#_223" rel="nofollow">接口电路组成</a></li><li><a href="#_234" rel="nofollow">工作流程（以输入设备为例）</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_245" rel="nofollow">程序中断方式</a></li><li><ul><li><a href="#_246" rel="nofollow">程序中断</a></li><li><a href="#_251" rel="nofollow">程序中断方式的接口电路</a></li><li><ul><li><a href="#_252" rel="nofollow">接口电路组成</a></li><li><a href="#IO_286" rel="nofollow">I/O中断处理流程/工作流程（以输入设备为例）</a></li></ul> 
   </li><li><a href="#CPU_314" rel="nofollow">CPU的中断服务程序的流程</a></li><li><a href="#CPU_329" rel="nofollow">中断分类（按照是否在CPU执行中断过程中可以被新的中断请求打断）</a></li></ul> 
  </li><li><a href="#DMA_343" rel="nofollow">DMA方式</a></li><li><ul><li><a href="#DMAIO_348" rel="nofollow">DMA方式下I/O设备与主存直接交换数据的方式</a></li><li><ul><li><a href="#CPU_350" rel="nofollow">停止CPU访问主存</a></li><li><a href="#_357" rel="nofollow">周期挪用（周期窃取）</a></li><li><a href="#DMACPU_370" rel="nofollow">DMA与CPU交替访问</a></li></ul> 
   </li><li><a href="#DMADMA_377" rel="nofollow">DMA接口（DMA方式的接口电路）</a></li><li><ul><li><a href="#_380" rel="nofollow">接口电路组成</a></li><li><a href="#DMA_395" rel="nofollow">DMA接口的功能</a></li><li><a href="#_401" rel="nofollow">工作流程（输入、输出的案例皆有）</a></li><li><ul><li><a href="#_402" rel="nofollow">预处理</a></li><li><a href="#_410" rel="nofollow">数据传送</a></li><li><a href="#_441" rel="nofollow">后处理</a></li></ul> 
    </li><li><a href="#DMA_449" rel="nofollow">DMA接口与系统的连接方式</a></li><li><a href="#DMA_456" rel="nofollow">DMA方式与程序中断方式的比较</a></li><li><a href="#DMA_465" rel="nofollow">DMA接口的类型</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>输入输出系统的发展阶段</h2> 
<h3><a id="_2"></a>第一阶段（早期阶段）</h3> 
<p>I/O设备较少，<mark>I/O设备与主存交换信息都必须通过CPU，每一个I/O设备都具有一套独立的逻辑电路与CPU相连</mark>，用来实现I/O设备与主机之间的信息交换，线路十分散乱复杂，而且由于I/O设备与主机交换信息时，CPU只能停止运算，即<mark>I/O设备与CPU是按照串行方式进行工作的</mark>，减低了工作效率，再者，由于每一个I/O设备的逻辑控制电路与CPU的控制器已经构成了一个不可分割的整体，于是<mark>进行I/O设备的增添、撤减是极其困难的</mark></p> 
<h3><a id="DMA_5"></a>第二阶段（接口模块与DMA阶段）（讲解的重点）</h3> 
<p>计算机系统<mark>采用了总线结构，I/O设备通过接口模块与主机相连接</mark>，而且通常在接口中都设有数据通路和控制通路，数据经过接口既可以起到缓冲作用，又可以实现串并变换，控制通路用以传送CPU向I/O设备发出的各种控制命令，或者使CPU接收来自I/O设备的反馈信号。许多接口还能满足中断请求处理的要求，使得<mark>I/O设备与CPU可以按照并行方式进行工作</mark>（虽然并不是绝对的并行工作），提高了CPU的工作效率，此外接口技术还可以实现<mark>多台I/O设备分时占用总线，使得I/O设备之间也可以实现并行工作方式</mark>，提高了整机效率</p> 
<p>为了进一步提高CPU工作效率，又出现了<mark>DMA（直接存储器存取）技术</mark>，特点是<mark>I/O设备与主存之间存在一条直接数据通路，I/O设备可以与主存直接交换信息</mark>，使得CPU在I/O设备与主存交换信息这个时间段内可以继续完成自身工作，资源利用率得到了进一步的提升</p> 
<h3><a id="_10"></a>第三阶段（具有通道结构的阶段）</h3> 
<p>采用DMA方式虽然可以实现高速I/O设备与主机之间成组数据的交换，但是在大型计算机中使用DMA方式就会出现一些问题：</p> 
<ul><li>1、如果每一台I/O设备都配置上专用的DMA接口，不仅会<mark>增加硬件成本</mark>，还会因为要解决<mark>众多DMA接口同时访问主存的冲突问题</mark>使得控制变得十分复杂</li><li>2、CPU需要对众多的DMA接口进行管理，也会影响整机工作效率。因此在大中型计算机系统中，一般<mark>采用I/O通道的方式进行数据交换</mark>，通道是用来负责管理I/O设备以及实现主存与I/O设备之间交换信息的部件，可以视为一种具有特殊功能的处理器，其具有专用的通道指令，可以独立地执行用通道指令所编写的输入输出程序，但是并不是一个完全独立的处理器，它要依据CPU的I/O指令进行启动、停止或者改变工作状态。<mark>是从属于CPU的一个专用处理器</mark>。依赖通道管理的I/O设备在与主机交换信息时，CPU不直接参与管理</li></ul> 
<h3><a id="IO_15"></a>第四阶段（具有I/O处理机的阶段）</h3> 
<p><mark>I/O处理机又称为外围处理机，基本独立于主机工作</mark>，既可以完成I/O通道要完成的I/O控制，又可以完成码制变换、格式处理、数据块检错、纠错等操作。具有I/O处理机的输入输出系统与CPU工作的并行性更高，I/O系统对于主机来说具有更大的独立性</p> 
<h2><a id="_18"></a>输入输出系统的组成</h2> 
<h3><a id="IO_19"></a>I/O软件</h3> 
<h4><a id="_20"></a>软件的主要任务</h4> 
<ul><li>将用户编制的程序或者数据输入主机中</li><li>将运算结果输送给用户</li><li>实现输入输出系统与主机工作的协调</li></ul> 
<h4><a id="_25"></a>指令</h4> 
<p><mark>不同结构的输入输出系统所采用的软件技术差异很大</mark>：在采用接口模块方式时，使用机器指令系统中的I/O指令与系统软件中的管理程序即可实现I/O设备与主机的协调工作，在采用通道管理方式时，除了要使用I/O指令之外，还需要使用通道指令以及相应的操作系统。就算都采用操作系统，不同的机器其操作系统的复杂程度差异也是很大的。</p> 
<h5><a id="IO_28"></a>I/O指令</h5> 
<p>I/O指令为机器指令的一类，<mark>为CPU指令系统的一部分，是CPU用来控制输入输出操作的指令，由CPU译码以后执行</mark>。I/O指令可以和其他机器指令的字长相同，但是也是会反映CPU与I/O设备交换信息的特点，比如反映出对多台I/O设备的选择以及应该对设备进行哪些具体操作<br> <img src="https://images2.imgbox.com/41/bd/wH4f37vM_o.png" alt="在这里插入图片描述" width="380" height="150"></p> 
<ul><li>操作码 
  <ul><li>可以作为I/O指令与其他指令（比如，访存指令、控制指令、算逻指令）的判别码，<mark>标识该指令为I/O指令</mark></li></ul> </li><li>命令码 
  <ul><li><mark>体现了I/O设备的具体操作，命令码相当于CPU普通指令集中的操作码部分</mark> 
    <ul><li>操作分类：1、将数据从I/O设备输入主机；2、将数据从主机输出到I/O设备；3、状态测试，比如利用命令码检测各个I/O设备所处状态为 忙 还是 准备就绪；4、形成某些操作命令，不同I/O设备和主机进行信息交换的时候，需要完成的操作各不相同，比如磁盘驱动器需要进行读扇区、写扇区、找磁道等操作</li></ul> </li></ul> </li><li>设备码 
  <ul><li>是多台I/O设备的选择码，<mark>相当于各个设备的地址</mark>（只有对I/O设备进行编号，才能准确的选择某一台设备与主机交换信息）</li></ul> </li></ul> 
<h5><a id="_41"></a>通道指令</h5> 
<p>通道指令又称为CCW（通道控制字），是<mark>对具有通道的I/O系统为通道专门设置的指令</mark>，在具有通道结构的计算机中，I/O指令主要完成I/O设备的启动、停止操作、查询通道和I/O设备状态以及控制通道所做的其他操作，不实现I/O数据的传送操作，<mark>这种具有通道指令的计算机一旦CPU执行了启动I/O设备的指令，通道就会替代CPU对I/O设备进行管理</mark>。通道指令一般用来指明参与传送的数据在主存中的首地址；指明需要传送的字节数或者所传送数据的末地址；指明所选设备的设备码以及完成某种操作的命令码。<mark>一般位数比较多，通道程序即由通道指令所构成，用来完成某种外围设备与主存之间传送信息的操作</mark></p> 
<h3><a id="IO_45"></a>I/O硬件</h3> 
<p>输入输出系统的硬件组成是多样的，在带有接口的I/O系统中，一般包括接口模块以及I/O设备两大部分；在具有通道的I/O系统中，一个通道可以和一个以上的设备控制器相连，一个设备控制器又可以控制若干台同一类型的设备</p> 
<h2><a id="IO_49"></a>I/O设备与主机的联系方式</h2> 
<p>I/O设备与主机交换信息和CPU与主存交换信息相比，有许多不同点。例如，CPU如何对I/O设备编址；如何寻找I/O设备号；信息传送是逐位串行还是多位并行；I/O设备与主机以什么方式进行联络，使它们彼此都知道对方处于何种状态；I/O设备与主机是怎么连接的，等等。<mark>这一系列问题统称为I/O设备与主机的联系方式</mark></p> 
<h3><a id="IO_52"></a>I/O设备编址方式</h3> 
<p>通常将I/O设备码看作地址码，对I/O地址码的编址可以采用统一编址和不统一编址两种方式</p> 
<ul><li>统一编址（映像编址） 
  <ul><li><mark>将I/O地址看作是存储器地址的一部分，是从存储器空间划出一部分地址空间给I/O设备，把I/O接口中的端口当作存储器单元一样进行访问</mark>，比如在64K地址的存储空间中，划分出8K地址作为I/O设备的地址，<mark>但凡地址落在这8K地址范围内，该地址要进行的操作就是指向I/O设备的</mark>。这种编址方式占用了存储空间，减少了主存容量，但是<mark>无需设置专用的I/O指令，有一部分对存储器使用的指令也可以用于端口</mark></li></ul> </li><li>不统一编址（独立编址） 
  <ul><li><mark>指的是I/O地址和存储器地址是分开的，所有对于I/O设备的访问都必须使用专用的I/O指令进行</mark>。这种编址方式<mark>不占用主存空间，不需要为I/O端口留出地址空间，所以不影响主存容量</mark>，但是<mark>需要设置I/O专用指令</mark>。8086系统采用的就是这种独立的I/O编址方式</li></ul> </li></ul> 
<h3><a id="_59"></a>设备寻址</h3> 
<p>由于每一台I/O设备都被赋予了一个设备号，于是，要启动某一台设备是可以由I/O指令的设备码字段直接指出该设备的设备号。<mark>通过接口电路中的设备选择电路，即可选中要进行信息交换的I/O设备</mark></p> 
<h3><a id="_62"></a>信息传送方式</h3> 
<ul><li>并行传送 
  <ul><li>在同一时间，n位信息<mark>同时</mark>从CPU输出至I/O设备，或者由I/O设备输入到CPU，这种传送方式的速度较快，但是要求数据线多</li></ul> </li><li>串行传送 
  <ul><li>在同一时间，只传送一位二进制信息，在不同时刻<mark>连续逐位</mark>传送一串信息，这种传送方式的速度较慢，但是只需要一根数据线和一根地线，<mark>当I/O设备与主机距离遥远的时候，采用串行传送比较合理，比如远距离数据通信</mark></li></ul> </li></ul> 
<h3><a id="_68"></a>状态联络方式</h3> 
<ul><li> <p>立即响应方式</p> 
  <ul><li>对于一些工作速度十分缓慢的I/O设备，比如指示灯的亮与灭、开关的通与断等，当它们与CPU发生联系时，通常都会使这种设备可确定地处于某种等待状态，只要CPU的I/O指令一到，就可以实现响应，无需使用特殊的联络信号来确定设备的状态（即<mark>假设外设已经处于就绪状态，所以不必去查询外设的状态，直接执行CPU的I/O指令进行数据传送</mark>）</li></ul> </li><li> <p>异步工作采用应答信号联络</p> 
  <ul><li> <p><mark>当I/O设备与主机工作速度不匹配的时候，通常采用异步工作方式</mark>，这种方式下，I/O设备与CPU只有在出现联络信号的时候，才会开始准备交换信息</p> </li><li> <p><mark>并行传送</mark>的异步联络方式</p> 
    <ul><li>当CPU将数据输出到I/O接口后，接口立即向I/O设备发送了一个Ready信号，告诉I/O设备现在可以从接口中取数据了，I/O设备接收到Ready信号以后，就会立即从取出数据，同时向接口发送一个Strobe信号，让接口转告CPU数据已经被取出，可以继续向此接口发送数据了。类似的，若干I/O设备需要向CPU传送数据，则要在将数据发送给接口以后，向接口发送一个Strobe信号，让接口转告CPU数据已经送出，一旦数据被取走，接口就会向I/O设备发送Ready信号，告诉I/O设备设备已经被取走了，可以继续向接口发送数据<br> <img src="https://images2.imgbox.com/ca/b0/01ONG4oM_o.png" alt="在这里插入图片描述"></li></ul> </li><li> <p><mark>串行传送</mark>的异步联络方式</p> 
    <ul><li><mark>I/O设备与CPU双方协定了一组特殊标记</mark>，共同使用 起始位 和 终止位 来建立联系<br> <img src="https://images2.imgbox.com/09/34/lfCk9s5f_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> </li><li> <p>同步工作采用应答信号联络</p> 
  <ul><li><mark>当I/O设备与主机工作速度相匹配的时候，通常采用同步工作方式</mark>，这种方式下，CPU与I/O设备之间要具有专用电路，用以产生<mark>同步时标</mark>来控制双方的同步工作</li></ul> </li></ul> 
<h3><a id="IO_83"></a>I/O设备与主机的连接方式</h3> 
<ul><li> <p>辐射式</p> 
  <ul><li>要求<mark>每一台I/O设备都具有一套控制线路和一组信号线</mark>，使用到的器件和连线比较多，对I/O设备的增删都比较困难，而且可移植性差<br> <img src="https://images2.imgbox.com/1a/04/iP2BddIU_o.png" alt="在这里插入图片描述"></li></ul> </li><li> <p>总线式</p> 
  <ul><li><mark>通过一组总线（包括地址线、数据线、控制线等）将所有的I/O设备（通过I/O接口）都与主机相连接</mark>，接口可以向外部设备传输主机的控制命令，也可以向主机传输外部设备的状态信息，同样，接口也可以完成数据缓存，而且接口一般采用工业标准、国家标准或者国际标准进行制作，于是外部设备可移植性是比较高的。这种连接方式是现代大多数计算机系统所采用的方式<br> <img src="https://images2.imgbox.com/ee/8f/lMctPL6q_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<h2><a id="IO_92"></a>I/O设备与主机信息传送的控制方式</h2> 
<p><mark>I/O设备与主机交换信息具有5种控制方式：程序查询方式、程序中断方式、直接存储器方式（DMA）、I/O通道方式、I/O处理机方式</mark>。后面两种不在此处介绍，只介绍前面三种，皆<mark>使用外部数据输入的案例</mark>进行讲解。三种方式逐步使I/O设备的自治能力越来越强</p> 
<h3><a id="_95"></a>程序查询方式</h3> 
<p>CPU在要对I/O设备进行读操作的时候，就会<mark>通过程序不断查询I/O设备是否已经准备就绪</mark>，从而实现I/O设备与主机的数据交换过程。采用这种方式，要求I/O接口内设置<mark>一个能够反映I/O设备是否准备就绪的状态标记</mark>，CPU通过对此标记的检测即可得知I/O设备的准备情况，实现电路简单</p> 
<p>图中为CPU从某一个I/O设备读数据块（比如从磁盘上读取一个记录块）到内存中的查询方式流程，当现行程序需要启动某一个I/O设备读取信息的时候，就会将此程序流程插入到运行的程序中</p> 
<p><img src="https://images2.imgbox.com/cc/9d/YvOSxS6X_o.png" alt="在这里插入图片描述"></p> 
<p>从流程图中即可看出，<mark>只要一启动I/O设备，CPU就会不断查询I/O设备的准备情况，从而终止了原理程序的执行过程，这是一个原地踏步的过程</mark>，而且在I/O设备准备就绪以后，CPU要一个字一个字地从I/O设备中取出数据，经过CPU送到主存中，这个过程中依旧不能执行原程序，可见这种I/O设备与主机信息传送的控制方式使得<mark>CPU与I/O设备处于串行工作状态</mark>，CPU工作效率不高</p> 
<p><img src="https://images2.imgbox.com/22/ec/gGBg1f2U_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_108"></a>程序中断方式</h3> 
<p>程序中断方式中，CPU在启动I/O设备以后并不会一直停留在原地，不断发送查询信息，而是<mark>不管I/O设备的准备状态，继续执行现行程序，直到I/O设备准备就绪了，I/O设备会自动向CPU发送中断请求，这个时候CPU才会进行I/O设备设备情况的查询</mark>，对现行程序进行中断，转而执行中断服务程序，等待与I/O的信息传输完毕以后，会返回原程序断点处，继续执行原程序，由于这种I/O设备与主机信息传送的控制方式使得原程序中断了运行，于是这种方式被称为程序中断方式</p> 
<p>如果系统挂接的设备的数目和种类不多，而且CPU不忙，则使用程序查询法实现数据的输入输出较为适合<br> <img src="https://images2.imgbox.com/43/9e/yLNTlqyQ_o.png" alt="在这里插入图片描述"></p> 
<p>从流程图中可以看出，<mark>CPU在接收了I/O设备的中断请求以后，才会从I/O接口一个字一个字地将数据写入主存中（这是通过执行中断程序而不是现行程序完成的）</mark>，<mark>CPU与I/O设备为部分并行工作</mark>，如果I/O设备的一个数据块中的全部数据尚未传输结束的时候，CPU会再次启动I/O设备，命令I/O设备再进行准备，传输数据，一旦又接收到I/O设备的中断请求时，CPU会重复上述过程，直到一个数据块中的全部数据传输完毕。<mark>采用程序中断方式的时候，CPU和I/O接口不仅在硬件方面需要增加相应的电路，在软件方面还必须编制中断服务程序</mark>。要保证在CPU中断程序，后续返回之后能够能正确地继续执行下去，中断时要保存现场，保存程序断点，返回时要恢复现场，恢复程序断点，这些都是需要一定时间的</p> 
<p><img src="https://images2.imgbox.com/ae/30/07mtvk7j_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="DMA_118"></a>DMA（直接存储器存取）方式</h3> 
<p>DMA方式下，<mark>I/O设备与主存之间具有一条专门的数据通路，可以直接与主存交换现行，而不需要占用CPU资源（即CPU不需要暂停现行程序去为设备服务，省去了保护现场和恢复现场的过程）</mark>，CPU的资源利用率将进一步提高。如果出现了<mark>DMA和CPU同时访问主存的情况，CPU总是将总线占用全让给DMA</mark>，通常将DMA的这种占用称为"窃取"或者"挪用"，窃取的时间一般为一个存取周期，故又<mark>把DMA占用的存取周期称为"窃取周期"或者"挪用周期"</mark>，在挪用周期中，CPU可以进行内部的操作（比如乘法运算），即与程序查询和程序中断方式相比，DMA方式进一步提高了CPU资源的利用率，基本上实现了CPU与I/O设备的并行工作。同时也是有一些不足之处的，在本文的开头处有略微提及，这里不再叙述</p> 
<p><mark>DMA方式实际上是把输入/输出过程中外设与内存交换数据的那部分操作与控制交给了DMAC（DMA控制器）</mark>，从而简化了CPU对输入/输出的控制。在程序查询方式或者程序中断方式是通过CPU执行指令实现数据传送的（即通过软件控制实现），数据必须要通过CPU进行中转，而在DMA方式中，都是<mark>使用硬件DMAC进行I/O设备与内存之间的数据传送的，由DMA控制器实现内存和外设，或者外设与外设之间的直接快速数据传送</mark></p> 
<p><mark>DMA方式的最大优势就在于速度快</mark>，这对于<mark>高速率大批量数据传送</mark>特别有用，所以DMA传送主要用于需要高速大批量数据传送的系统中，以提高数据的吞吐量，如磁盘存取、图像处理、高速数据采集系统、同步通信中的收发信号等方面应用甚广。DMA传送方式的优点是以增加系统硬件的复杂性和成本为代价的，电路结构复杂，硬件开销大。</p> 
<p>DMA传送虽然脱离了CPU的控制，但是并不是说DMA传送的整个过程就不需要进行控制和管理了，通常是采用<mark>DMA控制器</mark>(DMAC)取代了CPU，负责DMA传送的全过程控制。当外设准备好数据以后，就会向DMA控制器发送DMA请求，进而DMA控制器就会向CPU发送总线占有请求。在系统同意让出总线的情况下，高速外设就可以利用总线在DMA控制器的控制下完成数据交换。DMA数据交换的根本就是需要获得<mark>总线控制权</mark></p> 
<p><img src="https://images2.imgbox.com/67/b8/jOXUqchH_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="IO_129"></a>I/O接口</h2> 
<p>"接口"可以看作是两个系统或者两个部件之间的交接部分，既可以是两种硬设备之间的连接电路，也可以是两个软件之间的共同逻辑边界，还可以是硬件和软件的边界</p> 
<p><mark>I/O接口通常是指主机与I/O设备之间设置的一个硬件电路及其相应的软件控制，不同的I/O设备都具有其相对应的设备控制器，它们往往都是通过I/O接口与主机取得联系的</mark>。值得注意的是，"接口"和"端口"是两个不同的概念，<mark>端口指的是接口电路中的一些寄存器（一个接口内部可以具有多个端口）</mark>，这些寄存器分别用来存放数据信息、控制信息、状态信息，相应的端口分别称为数据端口、控制端口、状态端口（不同的端口用于传输不同的类型的信息）。<mark>若干个端口加上相应的控制逻辑才能组成接口</mark>。CPU通过输入指令，从端口读入信息，通过输出指令，可以将信息写入端口中（每一个I/O端口都会被分配一个I/O端口地址，简称I/O地址）</p> 
<p>使得CPU与外部设备进行通信的I/O接口电路一般称为<mark>I/O硬件</mark>，系统要通过这个I/O接口电路实现设备和I/O接口的通信，还需要编写相应的程序，一般将这个程序称为<mark>I/O软件</mark>，对于I/O硬件和I/O软件的综合设计称为<mark>I/O接口技术</mark></p> 
<h3><a id="_136"></a>接口设置的原因</h3> 
<ul><li>一台机器通常配有多台I/O设备，它们各自具有其设备号（地址），通过接口可以<mark>实现I/O设备的选择</mark></li><li>I/O设备种类繁多，速度不一，与CPU速度相差可能很大，无法与CPU直接匹配，所以不可能直接将I/O设备简单地连接到系统总线，通过接口<mark>实现数据缓冲，达到速度匹配</mark></li><li>有些I/O接口可能串行传送数据，而CPU一般为并行传送，通过接口可以<mark>实现数据串-并格式的转化</mark></li><li>I/O设备的输入输出电平可能与CPU的输入输出电平不同，通过接口可以<mark>实现电平转化</mark></li><li>CPU启动I/O设备工作，要向I/O设备发送各种控制信号，通过接口即可<mark>传送控制命令</mark></li><li>I/O设备需要将其工作状态（如"忙"、“就绪”、“错误”、"中断请求"等）及时向CPU报告，通过接口<mark>可以监视设备的工作状态，并可以保存状态信息，供CPU查询</mark></li></ul> 
<h3><a id="_143"></a>(通用)接口的功能与组成</h3> 
<h4><a id="IO_144"></a>总线连接方式的I/O接口电路</h4> 
<ul><li>数据线 
  <ul><li><mark>数据线是I/O设备与主机之间数据代码的传送线</mark>，其根数一般等于存储字长的位数或者字符的位数</li><li><mark>通常是双向的，也可以是单向的</mark>。如果采用单向数据总线，则必须使用两组才能实现数据的输入输出功能，而双向数据总线只需要一组即可</li></ul> </li><li>设备选择线 
  <ul><li>设备选择线是用来传送设备码的，根数取决于I/O指令中设备码的位数。<mark>如果设备码看成是地址号，那么设备选择线也可以称为地址线</mark></li><li><mark>设备选择线可以有一组，也可以有两组，其中一组用于主机向I/O设备发送设备码，另一组用于I/O设备向主机会送设备码</mark>，当然设备选择线也可以采用一组双向总线代替两组单向总线</li></ul> </li><li>命令线 
  <ul><li><mark>命令线主要用来传输CPU向设备发出的各种命令信号</mark>，比如启动、清除、屏蔽、读、写等</li><li>为<mark>一组单向线</mark>，其根数于命令信号多少有关</li></ul> </li><li>状态线 
  <ul><li> <p><mark>状态线是将I/O设备的状态向主机报告的信号线</mark>，比如，设备是否准备就绪，是否向CPU发送中断请求等</p> </li><li> <p>也是<mark>一组单向总线</mark></p> <p><img src="https://images2.imgbox.com/47/5a/BSoOCBh9_o.png" alt="在这里插入图片描述"></p> </li></ul> </li></ul> 
<h4><a id="_160"></a>接口功能</h4> 
<ul><li>选址功能 
  <ul><li>I/O总线与所有设备的接口电路相连接，<mark>设备选择线上的设备码决定了CPU要选择哪一台设备</mark>。设备码会传输至所有设备的接口，因此，要求每<mark>一个接口都具有选址的能力，即当设备选择线上的设备码与本设备码相符合的时候，接口应该发送出设备选中信号SEL</mark>，这种功能可以通过接口内部的设备选择电路实现，一旦设备选择电路具有输出，就可以控制这个设备通过命令线、状态线以及数据线与主机交换信息</li></ul> </li><li>传送命令的功能 
  <ul><li>当CPU向I/O设备发送命令的时候，I/O设备必须具有做出响应的能力，通常在I/O接口中设置有存放命令的命令寄存器以及命令译码器。命令寄存器用来存放I/O指令中的命令码，它受设备选中信号SEL的控制，命令线和所有接口电路的命令寄存器相连接，<mark>只有被选中设备的SEL信号有效，命令寄存器才能接收命令线上的命令码</mark></li></ul> </li><li>传送数据的功能 
  <ul><li>接口位于主机和I/O设备之间，数据必须通过接口才能实现主机与I/O设备之间的传送，这就要求<mark>接口中具有数据通路，能够完成数据传送，这种数据通路应该还要具有缓冲能力，即可以将数据暂存在接口中</mark>，接口中通常设置有DBR（数据缓冲寄存器），用来暂时存放I/O设备与主机准备交换的信息，与I/O总线中的数据线是相连接的。每一个接口中的数据缓冲寄存器的位数可以各不相同，这取决于各类I/O设备的不同需求。对于有些外部设备，还会要求DBR具有串-并转化能力，只要对原电路稍加改进即可</li></ul> </li><li>反映I/O设备工作状态的功能 
  <ul><li>为了使CPU可以及时了解到各个I/O设备的工作状态，<mark>接口中必须设置一些可以反映设备工作状态的触发器</mark>，比如，使用完成触发器D和工作触发器B来对设备状态进行标识：完成触发器D用于标记设备是否完成准备工作，D = 1表示外部设备准备工作完成，D = 0表示准备工作尚未完成；工作触发器用来标识设备工作状态是否忙，D = 1表示外部设备忙，D = 0表示外部设备不在工作状态中。进行组合，可有以下这几种情况：当D = 0；B = 0时表示I/O设备处于暂停状态；当D = 1；B = 0时表示I/O设备处于准备就绪状态；当D = 0；B = 1时表示I/O设备处于准备状态；<mark>所有的状态标志触发器都与I/O总线中的状态线相连接</mark>。此外，不同的I/O设备的接口电路中还需要增设一些其他状态标志触发器，比如，"出错"触发器、"数据迟到"触发器，或者配置一奇偶校验电路、循环码校验电路等</li><li>由于现代计算机系统中大多采用中断技术，于是接口电路中一般还设置有中断请求触发器INTR，当其为"1"时，表示该I/O设备向CPU发送中断请求。接口内部还会同时设置有屏蔽触发器MASK，其与中断请求触发器配合使用，共同完成设备的屏蔽功能</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/48/13/92UIIQKL_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_173"></a>接口类型</h3> 
<ul><li> <p>分类（按照数据传送方式不同）</p> 
  <ul><li>值得说明的一点，<mark>并行通信和串行通信指的是接口与外部设备一侧的通信方式</mark>，而接口与CPU之间的通信均是按字节或字并行传送的，所以串行接口和并行接口在于CPU连接一侧是类似的，二者的区别在于串行接口在发送数据时需要实现并/串转换，在接收数据时需要进行串/并转换</li><li><mark>并行接口</mark>：在设备与接口之间一位一位进行传送（即使用到的仅仅是其中的某一位数据，也是一次输入/输出8位或者16位数据），传送的信息不要求有固定的格式</li><li><mark>串行接口</mark>：将一个字节（或者一个字）的所有位同时传送，传送的信息必须要有固定格式</li></ul> </li><li> <p>分类（按照功能选择的灵活性不同）</p> 
  <ul><li><mark>可编程接口</mark>：接口的功能和操作方式可以使用程序来改变或者选择，具有广泛的适应性和很高的灵活性</li><li><mark>不可编程接口（硬接线接口）</mark>：接口的功能不能由程序来改变，但是可以通过硬连线逻辑来实现不同功能，一旦完成硬件电路的设计，则接口的工作方式就被固定了</li></ul> </li><li> <p>分类（按照通用性不同）</p> 
  <ul><li><mark>通用接口</mark>：可以供多种I/O设备使用</li><li><mark>专用接口</mark>：是为了某类外设或者某种用途专门设计的</li></ul> </li><li> <p>分类（按照数据传送的控制方式不同，程序查询方式不需要特殊的接口）</p> 
  <ul><li><mark>程序型接口</mark>：用于连接速度较慢的I/O设备，比如显示终端、键盘、打印机等，由于现代计算机一般都可采用程序中断方式实现主机与I/O设备之间的信息交换，于是都配有这种接口</li><li><mark>DMA型接口</mark>：用于连接高速I/O设备，如磁带、磁盘等，对应于DMA控制方式</li></ul> </li></ul> 
<h2><a id="_191"></a>程序查询方式</h2> 
<h3><a id="_192"></a>程序查询的流程</h3> 
<p>通常需要执行三条指令</p> 
<ul><li>测试指令：用来查询I/O设备是否已经准备就绪</li><li>传送指令：当I/O设备已经准备就绪时，执行传送指令</li><li>转移指令：若I/O设备未准备就绪，执行转移指令，转至测试指令，继续测试I/O设备的状态</li></ul> 
<h4><a id="IO_198"></a>只有一台I/O设备的情况下</h4> 
<h5><a id="_199"></a>查询流程</h5> 
<p><img src="https://images2.imgbox.com/a3/bf/i2rQG4HA_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_201"></a>程序流程</h5> 
<ul><li>由于这种方式传送数据时要占用CPU中的寄存器，所以要先<mark>将寄存器的原内容保护起来</mark>（如果该寄存器中具有有用信息的话）</li><li>由于传送往往是一批数据，于是需要先<mark>设置I/O设备与主机交换数据的计数值，用来标识是否所需数据已经传送完毕了</mark></li><li>设置欲传送<mark>数据在主存缓冲区的首地址</mark></li><li>CPU启动I/O设备</li><li>将I/O接口中的<mark>设备状态标志</mark>取至CPU并<mark>测试I/O设备是否准备就绪</mark> 
  <ul><li>如果还在准备状态，则进行等待，<mark>直到设备状态准备就绪为止</mark>。当准备就绪，接着可以实现数据传送 
    <ul><li>如果该设备为输入设备，准备就绪意味着接口电路中的数据缓冲寄存器已经装满了欲传送的数据，称为输入缓冲满，CPU即可取出数据</li><li>如果该设备为输出设备，准备就绪意味着接口电路中的数据已经被设备取走，称为输出缓冲空，CPU可以再次将数据送到接口</li></ul> </li></ul> </li><li>CPU<mark>执行I/O指令</mark>，或者从I/O接口的数据缓冲寄存器中读出一个数据，或者把一个数据写入I/O接口中的数据缓冲寄存器中，同时将接口中的状态标志复位</li><li><mark>修改主存地址</mark></li><li><mark>修改计数值</mark>，如果原设置计数值为原码，则依次减1；如果原设置计数值为负数的补码，则依次加一</li><li><mark>判断计数值</mark>，若计数值不为0，表示一批设备尚未发送完毕，则重新启动外部设备继续传送；若计数值为0，表示一批数据已经传送完毕</li><li>结束I/O传送，继续执行现行程序</li></ul> 
<p><img src="https://images2.imgbox.com/45/f7/Bc6hXvDo_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="IO_218"></a>有较多I/O设备的情况下</h4> 
<h5><a id="_219"></a>查询流程</h5> 
<p>CPU需要按照各个I/O设备的优先级进行逐级的查询<br> <img src="https://images2.imgbox.com/c0/95/qgXwgXX4_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_222"></a>程序查询方式的接口电路</h3> 
<h4><a id="_223"></a>接口电路组成</h4> 
<ul><li>设备选择电路 
  <ul><li>识别本设备地址，<mark>当地址线上的设备号与本设备号相符时，SEL信号有效，可以接收CPU发送的启动命令</mark></li></ul> </li><li>数据缓冲寄存器 
  <ul><li>用于存放预传送的数据</li></ul> </li><li>完成触发器D 
  <ul><li>为状态标记，反映设备工作状态</li></ul> </li><li>工作触发器B 
  <ul><li>为状态标记，反映设备工作状态</li></ul> </li></ul> 
<h4><a id="_234"></a>工作流程（以输入设备为例）</h4> 
<ul><li>CPU在执行主程序的过程中，执行到一条输入指令，这条输入指令要求指定的外部设备把数据输入到主机中，<mark>CPU会发送指令的设备码部分，设备码通过地址线送至设备选择电路</mark></li><li>如果该接口中的设备码与地址线上的代码吻合，说明这次启动的就是连接在该接口电路上的设备，其<mark>输出SEL信号有效，接口电路开始工作</mark></li><li>同时，I/O指令的启动命令经过"与非门"<mark>将工作触发器B置"1"，将完成触发器D置"0"，表示数据未准备好，设备开始工作，进入忙状态</mark></li><li>设备接收到B的标记信号以及B发送的启动信号之后，设备开始工作</li><li>输入设备将数据送至数据缓冲寄存器</li><li>由设备通过与接口电路相连接的状态线，发送设备工作结束信号，<mark>修改接口电路中的两个标记，即将D置"1"，B置"0"，表示外部设备准备就绪，设备工作完毕，退出忙状态</mark></li><li>D触发器向CPU发送"准备就绪"信号，表示"数据缓冲满"。<mark>在程序查询方式中，CPU在接收D的"准备就绪"信号之前，完全就是在原地踏步，CPU等待的就是这个标记D置"1"的状态</mark></li><li>CPU执行输入指令，开始数据传输，将数据缓冲寄存器中的数据送至CPU的通用寄存器，再存入主存相关单元</li></ul> 
<p><img src="https://images2.imgbox.com/00/2e/5WXaqR01_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_245"></a>程序中断方式</h2> 
<h3><a id="_246"></a>程序中断</h3> 
<p>在计算机执行程序的过程中，当出现异常情况或者特殊情况时，计算机停止现行程序的执行，转向对这些异常情况或者特殊请求的处理，<mark>处理完毕以后在返回到现行程序的间断出，继续执行原程序</mark>，这就是"中断"</p> 
<p>中断是现代计算机可以有效合理得发挥效能和提高效率的一种十分重要的功能。CPU总是在统一的时间，即<mark>每一条指令执行阶段的最后时刻，查询所有设备是否发送了中断请求</mark>。由于向CPU提出中断请求的原因越来越多，<mark>把向CPU提出中断请求的各种原因统称为中断源</mark></p> 
<h3><a id="_251"></a>程序中断方式的接口电路</h3> 
<h4><a id="_252"></a>接口电路组成</h4> 
<ul><li> <p>完成触发器D</p> 
  <ul><li>为状态标记，反映设备工作状态</li></ul> </li><li> <p>中断请求触发器</p> 
  <ul><li>实际上和前面提到的完成触发器D和工作触发器B一样，为状态标记。当中断请求触发器为"1"时，表示该接口所连接的设备需要向CPU发送中断请求，但是设备发送中断请求的时候，必须自身处于准备就绪状态，即接口内部的完成触发器D的状态必须为"1"而且<mark>该中断请求不会被屏蔽掉</mark>，等到CPU发送中断查询信号的时候，才能实现中断请求的成功发送</li></ul> </li><li> <p>中断屏蔽触发器</p> 
  <ul><li>实际上和前面提到的完成触发器D和工作触发器B一样，为状态标记。有的时候，计算机正在执行的程序或者正在执行的中断服务程序，其重要性比提出中断请求的设备要进行处理的事件的重要性更高，我们要设定不允许优先级较低的中断源中断正在运行的中断程序，于是在I/O接口中必须设置一个屏蔽触发器MASK，当其为"1"的时候，表示<mark>被屏蔽，即会封锁其对应的中断源的请求，该接口连接的设备发送的中断请求会被中途拦截，给屏蔽掉，中断请求无法成功发送</mark></li><li>中断屏蔽的工作原理（在后续CPU的文章中还会有更加详细的介绍） 
    <ul><li>每个中断源都对应有一个中断屏蔽字（图中一个中断屏蔽字为16个bit）， <mark>当该中断源的中断请求被响应或执行该中断的服务请求时，中断屏蔽寄存器的值就会被设置为该中断源对应的屏蔽字</mark>；这样在其他设备要发送中断请求的时候，接口会根据屏蔽寄存器的值来判断是否应该对该设备发送的中断请求进行中途拦截封锁。根据下表可以看出，优先级较高的中断源发送中断请求，修改中断屏蔽寄存器中的值以后，较低优先级的中断源就无法成功发送中断请求了</li><li><mark>中断屏蔽字的长度等于中断源的个数，屏蔽字的每个比特位可以对应到每个中断源上，中断屏蔽寄存器中数字为1对应的中断源是处于被屏蔽状态的</mark><br> <img src="https://images2.imgbox.com/d5/cc/cyowW0fF_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> </li><li> <p>前三者之间的关系</p> 
  <ul><li>只有设备准备就绪（D=1），并且该设备未被屏蔽（MASK=0）的时候，CPU的中断查询信号可以将中断请求触发器置"1"（INTR=1），成功发送中断请求信号<br> <img src="https://images2.imgbox.com/36/93/DXeC5kVO_o.png" alt="在这里插入图片描述"></li></ul> </li><li> <p>排队器</p> 
  <ul><li>当多个中断源同时向CPU发送请求的时候，我们要确保<mark>CPU在任何瞬间只能接收一个中断源的请求，即CPU要按照中断源的不同性质，赋予不同的优先级，从而按照优先级进行请求信号的接收</mark>，对于I/O中断而言，速度越高的I/O设备，优先级越高，因为如果CPU不及时响应高速I/O的请求，其信息就可能会立即丢失，于是在I/O接口中必须设置一个排队器</li><li><mark>设备优先权的赋予可以使用硬件方法，也可以使用软件方法</mark>。硬件排队器的实现方法中，既可以在CPU中设置<mark>一个统一的排队器</mark>，对所有中断源进行排队，也可以在每个接口电路中分别设置<mark>各个设备的排队器</mark>，比如链式排队器 
    <ul><li>链式排队器 
      <ul><li>图中下面一排门电路是核心，每一个接口中都具有一个反相器和一个与非门。<mark>该电路中级别最高的是中断源1号，其次分别是2号、3号、4号</mark></li><li>无论是哪一种中断源（一个或者多个）提出中断请求，排队器的输出端INTPi都只有一个为高电平，即实现了高级别信号比低级别信号先处理的功能。当各个中断源均无信号时，各个<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
            
             
              
               
                
                
                  I 
                 
                
                  N 
                 
                
                  T 
                 
                
                  R 
                 
                
                  i 
                 
                
               
                 ‾ 
                
               
              
             
               \overline{INTRi} 
              
             
           </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8833em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="mord mathnormal" style="margin-right: 0.0077em;">NTR</span><span class="mord mathnormal">i</span></span></span><span class="" style="top: -3.8033em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>为高电平，各个INTPi’均为高电平，一旦一个中断源提出中断请求，即<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
            
             
              
               
                
                
                  I 
                 
                
                  N 
                 
                
                  T 
                 
                
                  R 
                 
                
                  i 
                 
                
               
                 ‾ 
                
               
              
             
               \overline{INTRi} 
              
             
           </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.8833em;"></span><span class="mord overline"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height: 0.8833em;"><span class="" style="top: -3em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right: 0.0785em;">I</span><span class="mord mathnormal" style="margin-right: 0.0077em;">NTR</span><span class="mord mathnormal">i</span></span></span><span class="" style="top: -3.8033em;"><span class="pstrut" style="height: 3em;"></span><span class="overline-line" style="border-bottom-width: 0.04em;"></span></span></span></span></span></span></span></span></span></span>转为低电平时，由于与非门的作用，所有比起优先级低的中断源的INTPi’均为低电平，即无请求信号输出，实现了低优先级中断源的中断请求的封锁，而高优先级的中断源的INTPi’不受影响<br> <img src="https://images2.imgbox.com/a9/53/txg1uDoa_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> </li></ul> </li><li> <p>中断向量地址形成部件（设备编码器）</p> 
  <ul><li> <p>不同的设备具有不同的中断服务程序，同时每一个服务程序都具有一个入口地址，CPU必须找到这个入口地址，才能执行中断服务程序，入口地址的寻找可以使用硬件也可以使用软件，这里仅介绍硬件向量法</p> </li><li> <p>硬件向量法</p> 
    <ul><li>硬件向量法就是<mark>通过向量地址（用于存储中断向量的内存单元的地址）来寻找设备的中断服务程序入口地址，并且向量地址是由硬件电路产生的</mark>，中断向量地址形成部件的输入是排队器的所有输出信号INTP1、INTP2、INTP3、…INTPn，它的输出是中断向量地址（一个二进制数值），其位数与计算机可以处理的中断源的个数有关，<mark>一个中断源对应一个向量地址</mark>，实际上，该部件就是一个译码器，<mark>排队器的输入就是中断向量地址形成部件的输入信号，排队器的所有输出中，一次只会有一个输出信号有效（即只有一个是高电平，其他输入信号都是低电平），排队器所有的输出信号输入中断向量地址形成部件，输出的结果是这个中断源对应的向量地址（一串二进制01编码）</mark>。由设备编码器形成的这个（中断）向量地址通过数据总线传输给CPU，CPU可以根据这个向量地址获得到对应于该I/O设备的中断服务程序的入口地址，从而找到该I/O设备的中断服务程序并执行它</li><li>这里必须区分"（中断）向量地址"和"中断服务程序的入口地址"，"<mark>（中断）向量地址"指的是保存"中断服务程序的入口地址"或者跳转指令（可以跳转到中断服务程序所在位置）的那个内存单元的地址，而"中断服务程序的入口地址"才是CPU真正需要的中断服务程序在内存中的所在地址</mark></li></ul> <p><img src="https://images2.imgbox.com/35/73/zGt3KwmO_o.png" alt="在这里插入图片描述"></p> <p><img src="https://images2.imgbox.com/62/c3/6ZwDuWhF_o.png" alt="在这里插入图片描述"></p> </li></ul> </li></ul> 
<h4><a id="IO_286"></a>I/O中断处理流程/工作流程（以输入设备为例）</h4> 
<ul><li> <p>CPU响应中断请求</p> 
  <ul><li>条件 
    <ul><li><mark>必须满足CPU中的允许中断触发器EINT值为"1"</mark>，该触发器可以使用"开中断指令"实现置位（允许中断触发器EINT置为"1"的这个过程称为"开中断"）；可以使用"关中断指令"或者通过硬件自动实现复位（允许中断触发器EINT置为"0"的这个过程称为"关中断"）</li><li><mark>允许中断触发器和中断屏蔽触发器的作用对比</mark>：允许中断触发器的作用就是总开关，即为针对所有接口的中断请求能否被响应的总控制，如果允许中断触发器EINT值为"0"，那么所有的中断都不会被响应。而中断屏蔽触发器实际上是针对每一个具体的接口的中断请求控制，某一个中断源的中断请求被屏蔽了，不一定会导致其他所有的中断请求都被屏蔽</li></ul> </li><li>时间 
    <ul><li><mark>一定是在每一条指令执行阶段的结束时刻</mark>，因为I/O设备准备就绪（即D=1）的时间是随机的，而<mark>CPU是在一个统一的时间，即每一条指令执行阶段结束之前，CPU才会向接口发送中断查询信号</mark></li></ul> </li></ul> </li><li> <p>CPU在执行主程序的过程中，执行到一条输入指令，这条输入指令要求指定的外部设备把数据输入到主机中</p> </li><li> <p>CPU通过这条指令，在地址线上给出对应设备地址，设备地址送入对应的接口电路当中后，接口利用设备选择电路，对设备地址进行比较，如果相同，该接口以及该接口相连接的设备就被选中的了，SEL信号有效，接口电路开始工作</p> </li><li> <p>由CPU发送启动设备命令，和SEL信号同时有效，经过译码以后，将接口中的B置"1"，D置"0"，表示设备开始准备数据，设备进入忙状态</p> </li><li> <p>B为"1"使得该接口所连接的输入设备开始准备数据</p> </li><li> <p>输入设备将数据送入数据缓冲寄存器</p> </li><li> <p>输入设备向接口发送"设备工作结束信号"，将接口中的B置"0"，D置"1"，标志设备工作结束，数据准备完毕，设备准备就绪，设备退出忙状态</p> </li><li> <p><mark>设备准备就绪（D=1），且本设备未被屏蔽（MASK=0），同时在CPU的指令执行阶段的结束时刻，由CPU发送了中断查询信号</mark></p> </li><li> <p><mark>在中断查询信号的作用下，设备中断请求触发器INTR置"1"，标志设备向CPU成功发送了中断请求</mark>，于此同时，<mark>INTR送至排队器，进行中断判优过程</mark>，排队器的众多输出信号中只有一个信号是有效的</p> </li><li> <p><mark>如果CPU允许中断（即允许中断触发器EINT值为"1"），标志设备中断请求成功</mark>，CPU发送中断响应信号，设备进入了中断响应阶段，<mark>由中断响应信号INTA将排队器的所有输出作为设备编码器的输入信号，设备编码器输出向量地址，向量地址通过数据总线送至CPU，作为CPU要执行的下一条指令的地址</mark></p> </li><li> <p><mark>如果向量地址对应的内存空间中存放的是一条无条件转移指令，这一条指令执行完毕以后，会无条件转至内存中该设备的中断服务程序处</mark>，开始执行中断服务程序，进入中断服务阶段，其中在保护现场阶段过后，进行屏蔽字设置（涉及到接口的中断屏蔽触发器）和关中断（涉及到CPU的允许中断触发器）的操作。开始进行数据的传输过程，即通过输入指令将数据缓冲寄存器的输入数据送至CPU的通用寄存器中，再通过CPU存入主存</p> </li><li> <p>中断服务程序的最后一条指令为中断返回指令，当其执行结束的时候，中断返回至原程序断点处，至此，一个完整的程序中断处理过程结束</p> </li></ul> 
<p>一次中断处理过程可以简单归纳为中断请求、中断判优、中断响应、中断服务和中断返回5个阶段<br> <img src="https://images2.imgbox.com/13/cb/VozerN9S_o.png" alt="在这里插入图片描述"><br> 有些同学可能会有疑问：为什么这里的设备编码器看起来只有一个INTP输入，而前面讲述排队器的时候，示意图中具有多个INTP输入呢？</p> 
<p>因为<mark>这里仅仅指画出了一整个编码器的一小部分而已</mark>，整体的编码器应该如下图所示，这里采用的排队器是每个接口电路中分别设置各个设备的排队器，是一个链式排队器，重点看设备译码器处，是所有的排队器的输出信号（只有一个信号是有效的）进入一个设备编码器（即中断向量地址形成部件）中<br> <img src="https://images2.imgbox.com/e8/89/oSsUmAmF_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="CPU_314"></a>CPU的中断服务程序的流程</h3> 
<p>不同设备的中断服务程序各不相同，可是它们的程序流程又是类似的<br> 一般中断服务程序的流程可以分为四大部分：保护现场、中断服务、恢复现场、中断返回</p> 
<ul><li>保护现场 
  <ul><li>所谓的保护现场实际上有两个含义 
    <ul><li><mark>保存程序的断点</mark>（包括1.保存中断返回以后，需要执行的那条指令的地址；2.保存程序执行状态），<mark>这个工作由中断隐指令完成（中断服务程序不需要具有相应的代码用于完成这个工作，硬件自动完成）</mark>（实际上，中断隐指令并不是一条指令，是由硬件自动执行的一系列操作）</li><li><mark>保存通用寄存器和体系结构寄存器的内容</mark>。可以在中断服务程序的起始部分安排若干条存数指令，实现寄存器中的内容可以先放入存储器中进行保存，或者使用进栈指令（PUSH指令）将各个寄存器的内容推入堆栈中进行保存，即将程序中断时的"现场"保存起来，<mark>这个工作由中断服务程序完成（即中断服务程序需要具有相应的代码用于完成这个工作）</mark></li></ul> </li></ul> </li><li>中断服务 
  <ul><li><mark>这个部分是中断服务程序的主体部分，对于不同的中断请求源，其中断服务操作的内容各不相同</mark>。比如，打印机要求CPU将需要进行打印的一行字符代码，通过接口送入打印机的缓冲存储器中供打印机打印，而显示设备要求CPU将需要进行显示的一屏字符代码通过接口送入显示器的显示存储器中</li></ul> </li><li>恢复现场 
  <ul><li><mark>这是中断服务程序的结尾部分，要求在退出该服务程序之前，将原程序中断时的"现场"恢复到原来的寄存器中，对应于"保护现场"中的"保存通用寄存器和体系结构寄存器的内容"操作</mark>，通常可以使用取数指令或者出栈指令（POP指令），将保存在存储器（或堆栈）中的信息送回到原来的寄存器中</li></ul> </li><li>中断返回 
  <ul><li>中断返回指令为中断服务程序的最后一条指令，使其<mark>返回到原程序的断点处，以便继续执行原程序</mark></li></ul> </li></ul> 
<h3><a id="CPU_329"></a>中断分类（按照是否在CPU执行中断过程中可以被新的中断请求打断）</h3> 
<p>CPU一旦响应了某一中断源的请求，硬件线路就会自动关中断，即允许触发器EINT置"0"，以确保该中断服务程序的顺利进行，此时如果此时不使用"开中断"指令将EINT置"1"，则意味着CPU不能再响应其他任何一个中断源的中断请求。<mark>多重中断和单重中断这两种不同处理方式的区别，就是"开中断"的设置时间不同</mark></p> 
<ul><li> <p>单重中断</p> 
  <ul><li>在计算机处理中断的过程中，可能还会出现新的中断请求，此时如果<mark>CPU暂停现行的中断服务程序，转去处理新的中断请求</mark>，这种现象称为多重中断（中断嵌套）</li><li>对于单重中断，<mark>开中断指令在最后"中断返回"之前才执行</mark>，这意味着在整个中断服务程序执行的过程中，不能再响应其他中断源的请求</li><li>单重中断流程<br> <img src="https://images2.imgbox.com/f6/ec/2Rztfnl6_o.png" alt="在这里插入图片描述"></li></ul> </li><li> <p>多重中断</p> 
  <ul><li>如果<mark>CPU在执行中断程序时，对于新的中断请求不予理睬</mark>，这种中断则称为单重中断</li><li>对于多重中断，<mark>开中断指令在"保护现场"之后就得到了执行</mark>，于是在保护现场之后，如果有更高级别的中断源发送了中断请求（"更高级别"是实现多重中断的必要条件，这是由中断屏蔽器的设置所决定的），CPU也可以响应，即再次中断现行的中断服务程序，转移至更新的中断服务程序进行执行</li><li>多重中断流程（这个图其实画得不太准确，<mark>多重中断中实际需要开关中断2次</mark>，除了流程图中的在断点进栈以后CPU自动关中断，以及在保护现场以后为了实现中断嵌套而开中断以外，<mark>在恢复现场之前，需要进行关中断，保证恢复现场的正确执行，在恢复现场以后，需要进行开中断，让CPU能再次响应中断，最后进行中断返回</mark>）<br> <img src="https://images2.imgbox.com/8f/6f/jXTWQFXm_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<h2><a id="DMA_343"></a>DMA方式</h2> 
<p><mark>DMA方式中，主机与I/O设备的DMA接口具有一条直接的数据通路</mark>，因此在主存与I/O设备交换信息时，不需要通过CPU，也不需要CPU暂停现行程序为设备服务，省去了保护现场和恢复现场的操作，因此CPU的工作效率得到了很好的提升</p> 
<p><mark>DMA方式特别适合与高速I/O设备或辅存与主存之间进行现行交换</mark>，因为高速I/O设备如果需要申请与主机交换信息，即要等待CPU做出中断响应以后才能进行信息传递，则很有可能在这段时间内，数据就丢失了</p> 
<h3><a id="DMAIO_348"></a>DMA方式下I/O设备与主存直接交换数据的方式</h3> 
<p>在DMA方式中，由于DMA接口与CPU共享主存，于是就可能发生两者争用主存的冲突，为了有效地分时使用主存，解决发生的冲突，通常DMA接口与主存交换数据实现下面三种方法</p> 
<h4><a id="CPU_350"></a>停止CPU访问主存</h4> 
<p>这种方法下，如果外部设备要求传送一批数据，就会由DMA接口向CPU发送一个停止信号，要求CPU放弃地址线、数据线和有关控制线的使用权，在DMA接口获得总线控制权以后，就会开始就进行持续的数据传送，<mark>在数据完全传送结束以后，DMA接口才会通知CPU可以实现主存，并把总线控制权交还回CPU</mark></p> 
<p><img src="https://images2.imgbox.com/91/5f/GaUP7eAV_o.png" alt="在这里插入图片描述"><br> 这种方法的优点是控制简单，<mark>适用于数据传输率很高的I/O设备实现成组数据的传输</mark>。缺点是<mark>DMA接口在访问主存的同时，CPU基本处于一个长时间不工作的状态，或者保持原状态</mark>（当然，如果在CPU内部的指令缓冲器当中具有指令或者指令已经被取入到Cache，只要执行指令的过程中，不访问主存，CPU还是可以继续工作的），而且即使I/O设备高速允许，但是<mark>两个数据之间的准备间隔时间也总是大于一个存取周期的时间的，而这一段时间内，主存处于一个空闲的状态，而CPU也不能对主存进行访问，于是主存的利用率就没有得到充分的发挥</mark></p> 
<h4><a id="_357"></a>周期挪用（周期窃取）</h4> 
<p>这种方法中，<mark>每当I/O设备发送DMA请求的时候，I/O设备只能得到一个或者几个主存周期的总线占用权</mark></p> 
<p>I/O设备向CPU发送DMA请求的时候，会有三种情况</p> 
<ul><li><mark>CPU此时不需要访问主存</mark>（比如CPU此时可能正在执行乘法指令，乘法指令执行时间较长，此时CPU就不需要访问主存），所以I/O设备于CPU的工作就不会发生冲突，<mark>I/O设备直接获得总线占有权</mark></li><li><mark>I/O设备发送请求的同时，CPU正在访问主存</mark>，此时必须<mark>要等待存取周期结束以后，设备才能获得总线占有权</mark></li><li><mark>I/O设备需要访问主存的时候，CPU也恰恰好要访问主存</mark>，这个时候，I/O访存的优先级要高于CPU（因为如果I/O不能立即访存，信息就会面临丢失的风险），于是<mark>I/O设备就会窃取一个或者几个主存周期的总线占用权</mark>，即CPU在执行访问主存指令过程中插入了DMA请求，并且被窃取了窃取一个或者几个主存周期的总线占用权，<mark>CPU必须要延缓窃取一个或者几个主存周期，才能访问主存</mark></li></ul> 
<p><img src="https://images2.imgbox.com/44/f1/mouYFYl8_o.png" alt="在这里插入图片描述"></p> 
<p>这种方法于CPU暂停访存的方法相比，<mark>既实现了I/O传送，又可以较好地发挥了主存与CPU的效率</mark>，是一种广泛采用的方法，但是同时<mark>I/O设备每挪用一个主存周期就要进行申请总线控制权、建立总线控制权和归还总线控制权这些步骤</mark>，因此，即使传送一个字的过程对于主存来说只需要占用一个主存周期，实际上，对于DMS接口来说，因为总线控制权的问题，这一整个过程需要消耗2-5个主存周期，因此<mark>周期挪用的方法比较适合于I/O设备的读写周期要大于主存周期的情况</mark></p> 
<h4><a id="DMACPU_370"></a>DMA与CPU交替访问</h4> 
<p>这种方法<mark>适合于CPU的工作周期比主存的存取周期要长的情况</mark>，这样<mark>一个CPU的工作周期就可以分为前后两段，一个用来专门进行DMA访存，一个用来专门进行CPU访存</mark><br> <img src="https://images2.imgbox.com/c5/dd/pTgNZGTz_o.png" alt="在这里插入图片描述"></p> 
<p>这种方法<mark>不需要进行总线使用权的申请、建立和归还的过程</mark>，总线使用权是通过CPU工作周期的两部分进行拥有者的区分的，实际上，总线变成了在两段时间控制下的多路转化器，而这个转移过程基本不需要花费多少时间，这种方法下，<mark>CPU既不需要停止主程序的运行，也不需要进入等待状态，就可以完成DMA数据的传送</mark>。当然，其相应的硬件逻辑变得更加复杂了，CPU和DMA接口各自具有独立的访存地址寄存器、数据寄存器和读/写信号</p> 
<h3><a id="DMADMA_377"></a>DMA接口（DMA方式的接口电路）</h3> 
<p>利用DMA方式传送数据时，数据的传输过程完全由DMA接口电路所控制，于是DMA接口又称为DMA控制器</p> 
<h4><a id="_380"></a>接口电路组成</h4> 
<ul><li>主存地址寄存器（AR） 
  <ul><li>AR用于存放主存中需要交换数据的地址，在DMA传送数据之前，必须通过程序将数据在主存中的首地址送到主存地址寄存器，在DMA传送过程中，<mark>每交换一次数据，将地址寄存器存储的地址值加1，直到一批数据传送完毕为止</mark></li></ul> </li><li>字计数器（WC） 
  <ul><li>WC用于记录传送数据的总字数，通常以交换字数的补码值预置，在DMA传送过程中，<mark>每传送一个字，字计数器加1，直到最高为产生进位时，表示这批数据传送完毕</mark>；如果最初使用交换字数的原码值对字计数器进行预置，则<mark>每传输一个字，字计数器减1，直到计数器为0时，表示该批数据传送结束</mark></li></ul> </li><li>数据缓冲寄存器（BR） 
  <ul><li>BR用于暂存每次传送的数据，通常DMA接口与主存直接采用字传送，而DMA与设备之间可能是字节或者是位传送，因此，DMA接口中还可能具有装配或者拆卸字信息的硬件逻辑，比如数据移位缓冲寄存器、字节计数器等</li></ul> </li><li>DMA控制逻辑 
  <ul><li>DMA控制逻辑负责管理DMA的传送过程，由控制电路、时序电路以及命令状态控制寄存器等组成，每当设备准备好一个字的数据（或者一个字传送结束），就会向DMA接口提出申请（DREQ），<mark>DMA控制逻辑便会向CPU请求DMA服务，发送总线使用权的请求信号（HRQ）</mark>，等到接收到CPU发送的响应信号（HLDA）以后，DMA控制逻辑就开始<mark>负责管理DMA传送数据的全过程</mark>，包括对于主存地址寄存器和字计数器的修改、识别总线地址、指定传送类型（输入或者是输出）以及通知I/O设备已经被授予了一个DMA周期（DACK）等</li></ul> </li><li>设备地址寄存器（DAR） 
  <ul><li>DAR存放I/O设备的设备码或者表示设备信息存储区的寻址信息，比如磁盘数据所在区号、盘面号和柱面号，具体内容取决于设备的数据个数和地址的编码方式</li><li><mark>供设备选择电路使用，查看这次要进行访问的设备是否为该接口当前连接的设备，是否是该接口正在管理的设备</mark></li></ul> </li><li>中断机构 
  <ul><li>用来当字计数器溢出（全为"0"）时，表示一批数据交换完毕，由"溢出信号"通过中断机构向CPU发送中断请求</li></ul> </li></ul> 
<h4><a id="DMA_395"></a>DMA接口的功能</h4> 
<ul><li>向CPU申请DMA传送</li><li>在CPU允许DMA工作时，处理总线控制权的转交，避免因为进入DMA工作而影响CPU的正常活动或者引起总线竞争</li><li>在DMA传送数据期间管理系统总线，控制数据传送</li><li>确定数据传送的起始地址和数据长度，在数据传送过程中对数据地址和数据长度进行修正（对数据长度进行修改，主要是为了确定数据块的传输是否结束）</li><li>在数据块传送结束时，给出DMA操作完成的信号，发送中断请求信号，请求CPU进行DMA操作的后处理（注意，这里的中断的目的是为了报告一批数据传送过程的结束，和前面所提的中断信号的目的不同）</li></ul> 
<h4><a id="_401"></a>工作流程（输入、输出的案例皆有）</h4> 
<h5><a id="_402"></a>预处理</h5> 
<p><mark>在DMA接口开始工作之前，CPU必须要通过几条I/O指令完成下列信息的预置，实现预置以后，CPU会继续执行原来的程序</mark>，而如果I/O设备准备就绪，DMA接口就会向CPU提出占用总线的申请，如果同时有多个DMA进行申请，则按照事情的轻重缓急由硬件排队判断优逻辑决定优先级。等到I/O设备得到主存总线占有权以后，DMA接口就会开始对数据的传送进行管理</p> 
<ul><li>给DMA控制逻辑指明数据传送方向是输入（写主存）还是输出（读主存）</li><li>给DMA设备地址寄存器送入设备号，并启动设备</li><li>向DMA主存地址寄存器送入交换数据的主存起始地址</li><li>对字计数器赋予交换数据的个数</li></ul> 
<h5><a id="_410"></a>数据传送</h5> 
<p>DMA方式是以数据块为单位进行传送的，<mark>以周期挪用的DMA方式为例</mark>，对数据传送的流程进行讲解</p> 
<ul><li>以数据输入为例 
  <ul><li>当设备准备好一个字时，发送选通信号，将该字读到DMA的数据缓冲寄存器（BR）中，表示数据缓冲寄存器"满"（如果I/O设备是面向字符的，则一次读入一个字节，经过组装，形成一个字的数据）</li><li>同时设备向DMA接口发送设备请求信号（DREQ），向DMA控制逻辑表明数据准备完毕</li><li>DMA接口向CPU申请总线和主存的占有请求信号（HRQ）</li><li>CPU发送响应信号（HLDA），表示允许将总线和主存的占有权交给DMA接口</li><li>接口将DMA主存地址寄存器中的主存地址送到地址总线上</li><li>DMA接口向设备发送一个应答信号，通知设备已经被授权了一个DMA周期（DACK），而且数据传输已经开始</li><li>DAM控制器发送对主存的写控制指令，DMA数据缓冲寄存器的数据被送到数据总线上</li><li>主存将数据总线上的信息写入地址总线指定的存储单元中</li><li>修改主存地址和字计数值</li><li>判断数据是否传送结束，如果尚未结束，则继续传送，如果已经结束（字计数值溢出），则将字计数器WC的溢出信号发送给中断控制机构，由中断控制机构向CPU发送中断信号，表明数据块传送结束<br> <img src="https://images2.imgbox.com/bf/e1/ban58LDZ_o.png" alt="在这里插入图片描述"></li></ul> </li><li>以数据输出为例 
  <ul><li>当DMA数据缓冲寄存器已将输出数据送至I/O设备以后，表示数据缓冲寄存器已"空"</li><li>设备向DAM接口发送设备请求信号（DREQ），向DMA控制逻辑表明数据传输完毕，可以接着接收数据</li><li>DMA接口向CPU申请总线和主存的占有权（HRQ）</li><li>CPU发送响应信号（HLDA），表示允许将总线和主存占有权交给DMA接口使用</li><li>将DMA主存寄存器中的主存地址送上地址总线</li><li>DMA接口向设备发送一个应答信号，通知设备已被授予一个DMA周期（DACK），而且数据传输已经开始</li><li>DAM控制器发送对主存的读控制指令，主存将相应地址单元的内容通过数据总线放入到DMA的数据缓冲寄存器中</li><li>将DAM数据缓冲寄存器的内容送到输出设备，如果为字符设备，则需要将字拆分为字符进行输出</li><li>修改主存地址和字计数值</li><li>判断数据块是否已经传送完毕，如果尚未结束，则继续传送，如果已经传送完毕（字计数值溢出），则将字计数器WC的溢出信号发送给中断控制机构，由中断控制机构向CPU发送中断信号，表明数据块传送结束</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/01/61/2fUKT9Js_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_441"></a>后处理</h5> 
<p>当DMA的中断请求得到响应以后，CPU停止原程序的执行，转而去执行中断服务程序，做一些DMA的结束工作，包括</p> 
<ul><li>校验送入主存的数据是否正确</li><li>决定是否继续使用DMA传送其他数据块，如果继续传送，则又要对DMA接口进行初始化，如果不需要进行传送，则停止外设</li><li>测试在传送过程中是否发生了错误，如果出错，则转至错误诊断以及处理错误程序</li></ul> 
<p><img src="https://images2.imgbox.com/e8/cf/v0G2FdMq_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="DMA_449"></a>DMA接口与系统的连接方式</h4> 
<ul><li>具有公共请求线的DMA请求方式 
  <ul><li>若干个DMA接口通过一条公用的DMA请求线向CPU申请总线控制权。<mark>CPU发送响应信号，用链式查询方式通过DMA接口</mark>，首先选中的设备获得总线控制权，即可占用总线与主存传送信息<br> <img src="https://images2.imgbox.com/60/85/RKP5cubS_o.png" alt="在这里插入图片描述"></li></ul> </li><li>独立DMA请求方式 
  <ul><li>每一个DMA接口各有一对独立的DMA请求线和DMA响应线，它<mark>由CPU的优先级判别机构裁决首先响应哪个请求，并在响应线上发送响应信号</mark>，获得响应信号的DMA接口便可以控制总线与主存传送数据<br> <img src="https://images2.imgbox.com/c6/45/5HEWYtnW_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<h4><a id="DMA_456"></a>DMA方式与程序中断方式的比较</h4> 
<ul><li>从数据传送看，程序中断方式依靠程序（程序即中断服务程序，需要CPU参与）传送，<mark>DMA方式依靠硬件（不需要CPU参与）传送</mark></li><li>从CPU响应时间看，程序中断方式是在一条指令执行结束时响应，而<mark>DMA方式由于是外部设备和主存直接进行数据交换，所以可以在指令周期中的任一存取周期结束时响应</mark></li><li><mark>程序中断方式具有处理异常事件的能力，DMA方式没有</mark>，用于大批量数据的传送，比如硬盘存取、图像处理、高速数据采集系统等，可以提高数据吞吐量</li><li><mark>都会向CPU发送中断请求，但是目的不同</mark>，程序中断方式通过中断请求，执行中断服务程序，开启数据传输阶段；DMA方式用于开启数据传输过程结束以后的后处理</li><li>程序中断方式需要中断现行程序，需要保护现场；<mark>DMA方式不需要中断现行程序，不需要保护现场</mark></li><li>由于DMA方式一般为主存与高速外设之间直接进行数据交换，于是<mark>DMA的优先级比程序中断的优先级高</mark></li></ul> 
<h4><a id="DMA_465"></a>DMA接口的类型</h4> 
<ul><li>选择型DMA接口 
  <ul><li>这种接口的主要特点是<mark>物理上可以连接多个设备，但是在逻辑上只能连接一个设备，即在某一段时候内，DMA接口只能为一个设备服务，只有一套寄存器</mark></li><li>如果某一个设备要使用DMA接口进行数据传输，则CPU会通过运行一条输入输出指令，对这些寄存器的值预置为该设备与主存交换信息对应的数值，与此同时，其他设备就无法提出DMA请求，也无法和主存之间进行数据交换，整个运行过程的关键是在预处理时将所选这个的设备号送入设备地址寄存器中。选择型DMA接口特别适用于数据传输效率很高的设备<br> <img src="https://images2.imgbox.com/df/93/gneBAvbB_o.png" alt="在这里插入图片描述"></li></ul> </li><li>多路型DMA接口 
  <ul><li>这种接口的主要特点是<mark>物理上可以连接多个设备，而且在逻辑上也能连接多个设备，但是真正地进行数据传输的过程中，依旧只能有一台设备和内存之间进行数据传输</mark>，数据准备阶段是可以有多个设备同时进行数据准备的。<mark>各个设备采用字节交叉的方式通过DMA接口进行数据传输，在多路型DMA接口中，为每一个设备与其连接的设备都设置了一套寄存器</mark>，分别存放设备各自的传送参数</li><li>图中分别是链式多路型DMA接口和独立请求多路型DMA接口。这类接口特别适合于同时为多个数据传输率不十分高的设备服务<br> <img src="https://images2.imgbox.com/8a/bc/6IlgEz7L_o.png" alt="-"></li><li>图中为多路型DMA接口工作原理示意图。图中磁盘、磁带、打印机同时工作。磁盘、磁带、打印机分别每隔30us、45us、150us向DMA接口发送DMA请求，磁盘的优先级高于磁带，磁带的优先级高于打印机<br> <img src="https://images2.imgbox.com/9f/0d/md4Z22LU_o.png" alt="在这里插入图片描述"></li></ul> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3440e3df862fcab1340a932fa38bceef/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于YOLOv5s的火焰检测在jetson nano边缘计算设备上的部署（使用tensorrt加速，Deepstream视频推流SDK）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b4a7f7724afd9f3e38fca2632af45ade/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">原生调用webView白屏解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>