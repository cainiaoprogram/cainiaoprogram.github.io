<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HashMap面试题总结 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HashMap面试题总结" />
<meta property="og:description" content="文章目录 HashMap简介问题集合问点一：你了解HashMap的底层数据结构吗？问点二：为什么JDK 7使用数组&#43;链表？JDK8中为什么要使用红黑树？哈希冲突是怎么回事？HashMap又是怎么解决的？问点三：HashMap的扩容机制是怎么样的？JDK7与JDK8有什么不同吗？问点四：HashMap中的键值可以为Null吗？能简单说一下原理吗？问点五：HashMap中能put两个相同的Key吗？为什么能或为什么不能？问点六：聊一聊JDK 7的HashMap中的“死锁”是怎么回事？问点七：HashMap是线程安全的吗？为什么安全或者不安全？问点八：什么 HashMap 的加载因子是0.75？为什么是超过“8”才用红黑树？问点九：HashMap、HashTable、ConcurrentHashMap的区别问点十：谈谈你理解的 HashMap，讲讲其中的 get和put 过程 由于HashMap在面试中是一个重点，内容十分多，需要单独写一篇文章总结
HashMap在Jdk1.7与1.8之中有很大区别！！
HashMap简介 HashMap 是用来存储数据的，它底层在JDK 1.7是数组&#43;链表实现的，而JDK 1.8是使用数组&#43;链表&#43;红黑树实现，通过对 key 进行哈希计算等操作后得到数组下标，把 value 等信息存放在链表或红黑树存在此位置。
如果两个不同的 key 运算后获取的数组下标一致，就出现了哈希冲突。数组默认长度是16，如果实际数组长度超过一定的值，就会进行扩容。
问题集合 问点一：你了解HashMap的底层数据结构吗？ 在JDK1.7使用的是数组&#43;链表的实现，在JDK1.8中使用的是数组&#43;链表&#43;红黑树
问点二：为什么JDK 7使用数组&#43;链表？JDK8中为什么要使用红黑树？哈希冲突是怎么回事？HashMap又是怎么解决的？ JDK 7使用数组&#43;链表，是因为HashMap是根据Key计算Hash值，从而得到哈希表的索引下标，而哈希表本质是数组实现。当出现Hash冲突时，则一个桶可能需要存放多个数据。HashMap将会根据equals()方法，判断Hash冲突的Key是否是同一个值，此时如果仍然不相同，就会利用头插法，将出现Hash冲突的Key&#43;Value存放在链表上。但是如果一个链表比较长，那么查询的效率将会降低，所以JDK8中又使用了红黑树来解决链表过长导致查询效率变差的问题，会在一个桶上链表长度为8时，进行树化。但是树化的时候，会判断当前的长度是否小于64，如果小于，则不进行树化，而是选择进行一次扩容，因为扩容的时候会使哈希表长度增加，hash值会重新计算，将重新打乱当前的元素排列，分配到新的空间上，这样也避免了链表过长。 对于HashMap中的每个key，根据一个Hash函数，计算出一个Hash值，对应就是桶的编号，桶实际上是用数组实现的。
//key 进行哈希计算 int hash = hash(key); //获取数组下标 int i = indexFor(hash, table.length); 通过计算后的下标，从而得到数组的对应下标的位置，最后把k，v值存进去，同样的当再次第二次存值的时候，同样把k，v传进来，当k再次进行计算出数组下标index，有可能和第一次计算的index的值相同。
但是，两次的需要存进去的value值是不同的，这就出现了同一个数组后面有一条链表，会比较链表上的每一个value值与当前的value是否相同，若是不相同，通过头插法，将数值插入链表中。如下图所示：
接下来通通过源码进行分析，在jdk 7插入的put 方法源码如下：
public V put(K key, V value) { //数组为空就进行初始化 if (table == EMPTY_TABLE) { inflateTable(threshold); } if (key == null) return putForNullKey(value); //key 进行哈希计算 int hash = hash(key); //获取数组下标 int i = indexFor(hash, table." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/52ab0e8339022a7cfce33dd4547fba9a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-03T11:21:44+08:00" />
<meta property="article:modified_time" content="2020-07-03T11:21:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HashMap面试题总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#HashMap_7" rel="nofollow">HashMap简介</a></li><li><a href="#_17" rel="nofollow">问题集合</a></li><li><ul><li><a href="#HashMap_19" rel="nofollow">问点一：你了解HashMap的底层数据结构吗？</a></li><li><a href="#JDK_7JDK8HashMap_37" rel="nofollow">问点二：为什么JDK 7使用数组+链表？JDK8中为什么要使用红黑树？哈希冲突是怎么回事？HashMap又是怎么解决的？</a></li><li><a href="#HashMapJDK7JDK8_251" rel="nofollow">问点三：HashMap的扩容机制是怎么样的？JDK7与JDK8有什么不同吗？</a></li><li><a href="#HashMapNull_285" rel="nofollow">问点四：HashMap中的键值可以为Null吗？能简单说一下原理吗？</a></li><li><a href="#HashMapputKey_291" rel="nofollow">问点五：HashMap中能put两个相同的Key吗？为什么能或为什么不能？</a></li><li><a href="#JDK_7HashMap_297" rel="nofollow">问点六：聊一聊JDK 7的HashMap中的“死锁”是怎么回事？</a></li><li><a href="#HashMap_338" rel="nofollow">问点七：HashMap是线程安全的吗？为什么安全或者不安全？</a></li><li><a href="#_HashMap_0758_344" rel="nofollow">问点八：什么 HashMap 的加载因子是0.75？为什么是超过“8”才用红黑树？</a></li><li><a href="#HashMapHashTableConcurrentHashMap_369" rel="nofollow">问点九：HashMap、HashTable、ConcurrentHashMap的区别</a></li><li><a href="#_HashMap_getput__413" rel="nofollow">问点十：谈谈你理解的 HashMap，讲讲其中的 get和put 过程</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<blockquote> 
 <p>由于HashMap在面试中是一个重点，内容十分多，需要单独写一篇文章总结</p> 
 <p>HashMap在Jdk1.7与1.8之中有很大区别！！</p> 
</blockquote> 
<h3><a id="HashMap_7"></a>HashMap简介</h3> 
<p><code>HashMap</code> 是用来存储数据的，它底层在<code>JDK 1.7</code>是<strong>数组+链表</strong>实现的，而<code>JDK 1.8</code>是使用<strong>数组+链表+红黑树</strong>实现，通过对 <code>key</code> 进行哈希计算等操作后得到数组下标，把 <code>value</code> 等信息存放在<strong>链表</strong>或<strong>红黑树</strong>存在此位置。</p> 
<p>如果两个不同的 <code>key</code> 运算后获取的数组下标一致，就出现了<strong>哈希冲突</strong>。数组默认长度是<strong>16</strong>，如果实际数组长度超过一定的值，就会进行<strong>扩容</strong>。</p> 
<h3><a id="_17"></a>问题集合</h3> 
<h4><a id="HashMap_19"></a>问点一：你了解HashMap的底层数据结构吗？</h4> 
<blockquote> 
 <p>在JDK1.7使用的是<strong>数组+链表</strong>的实现，在JDK1.8中使用的是<strong>数组+链表+红黑树</strong></p> 
</blockquote> 
<img src="https://images2.imgbox.com/b0/2a/Ze25gQVu_o.png" alt="img"> 
<img src="https://images2.imgbox.com/63/e6/MTp7Xolt_o.jpg" alt="img"> 
<h4><a id="JDK_7JDK8HashMap_37"></a>问点二：为什么JDK 7使用数组+链表？JDK8中为什么要使用红黑树？哈希冲突是怎么回事？HashMap又是怎么解决的？</h4> 
<blockquote> 
 <ul><li>JDK 7使用数组+链表，是因为HashMap是根据Key计算Hash值，从而得到哈希表的索引下标，而哈希表本质是数组实现。当出现Hash冲突时，则一个桶可能需要存放多个数据。HashMap将会根据equals()方法，判断Hash冲突的Key是否是同一个值，此时如果仍然不相同，就会利用头插法，将出现Hash冲突的Key+Value存放在链表上。</li><li>但是如果一个链表比较长，那么查询的效率将会降低，所以JDK8中又使用了红黑树来解决链表过长导致查询效率变差的问题，会在一个桶上链表长度为8时，进行树化。但是树化的时候，会判断当前的长度是否小于64，如果小于，则不进行树化，而是选择进行一次扩容，因为扩容的时候会使哈希表长度增加，hash值会重新计算，将重新打乱当前的元素排列，分配到新的空间上，这样也避免了链表过长。</li></ul> 
</blockquote> 
<p>对于HashMap中的每个key，根据一个Hash函数，计算出一个Hash值，对应就是桶的编号，桶实际上是用数组实现的。</p> 
<pre><code class="prism language-java"><span class="token comment">//key 进行哈希计算</span>
<span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//获取数组下标</span>
<span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>通过计算后的下标，从而得到数组的对应下标的位置，最后把k，v值存进去，同样的当再次第二次存值的时候，同样把<code>k，v</code>传进来，当k再次进行计算出数组下标<code>index</code>，有可能和第一次计算的<code>index</code>的值相同。</p> 
<p>但是，两次的需要存进去的<code>value</code>值是不同的，这就出现了同一个数组后面有一条链表，会比较链表上的每一个<code>value</code>值与当前的<code>value</code>是否相同，若是不相同，通过<strong>头插法</strong>，将数值插入链表中。如下图所示：</p> 
<img src="https://images2.imgbox.com/db/fb/c75XlO62_o.png" alt="img"> 
<p>接下来通通过源码进行分析，在jdk 7插入的put 方法源码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
　　　　　<span class="token comment">//数组为空就进行初始化</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> EMPTY_TABLE<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
　　　　　<span class="token comment">//key 进行哈希计算</span>
        <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
　　　　　<span class="token comment">//获取数组下标</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
　　　　　<span class="token comment">//如果此下标有值，遍历链表上的元素，key 一致的话就替换 value 的值</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            Object k<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
                e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>

        modCount<span class="token operator">++</span><span class="token punctuation">;</span>
　　　　　<span class="token comment">//新增一个key</span>
        <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><code>put</code>方法中主要做了以下几件事：</p> 
<ol><li>判断<code>table</code>数组是否为空，若为空进行初始化<code>table</code>数组。</li><li>判断key值是否为<code>null</code>，将null是作为<code>key</code>存进去。</li><li>若<code>key</code>不为空，通过<code>key</code>计算出数组下标，判断<code>table[i]</code>是否为空。</li><li>若是不为空通过链表循环，判断在链表中是否存在与该<code>key</code>相等，若是存在，直接将<code>value</code>替换成新的<code>value</code>。若是<code>table[i]</code>为空或者链表中不存在与之相同的<code>key</code>，就<code>addEntry(hash, key, value, i)</code>新增一个节点。</li></ol> 
<p>接下来看看<code>addEntry(hash, key, value, i)</code>新增节点的源码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token comment">//数组长度大于阈值且存在哈希冲突（即当前数组下标有元素），就将数组扩容至2倍</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
            hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
            bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>这个方法很简单，直接就是判断当前数组的大小是否&gt;=<code>threshold</code>并且<code>table[bucketIndex]</code>是否为<code>null</code>。若成立扩容，然后rehash，重新得到新数组的下标值，最后 <code>createEntry(hash, key, value, bucketIndex)</code>创建新节点。</p> 
<p>最后来看一下<code>createEntry(hash, key, value, bucketIndex)</code>创建新节点的源码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
　　<span class="token comment">//此位置有元素，就在链表头部插入新元素（头插法）</span>
        Entry<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>
        table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>
        size<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/7e/0b/3eXlYeUR_o.png" alt=""></p> 
<p>在<code>JDK 7</code>中，链表存储有一个缺点，就是当数据很多的时候，链表就会很长，每次查询都会遍历很长的链表。</p> 
<p>因此在<code>JDK 8</code>中为了优化<code>HashMap</code>的查询效率，将内部的结构改为<strong>数组+链表+和红黑树</strong>，当一个哈希桶后面的链表长度<code>&gt;8</code>的时候，就会将链表转化为<strong>红黑树</strong>，红黑树是二分查找，提高了查询的效率。接下来通过<code>JDK 8</code>的<code>put</code>源码分析如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Node<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
　　　　　<span class="token comment">//数组为空就初始化</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
　　　　　<span class="token comment">//当前下标为空，就直接插入</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>
            tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
            Node<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>
　　　　　　　<span class="token comment">//key 相同就覆盖原来的值</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                e <span class="token operator">=</span> p<span class="token punctuation">;</span>
　　　　　　　<span class="token comment">//树节点插入数据</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
                e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
　　　　　　　　　　　　<span class="token comment">//链表，尾插法插入数据</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
　　　　　　　　　　　　　　<span class="token comment">//链表长度超过8，就把链表转为红黑树</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>
                            <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
　　　　　　　　　　　　<span class="token comment">//key相同就覆盖原来的值</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                        <span class="token keyword">break</span><span class="token punctuation">;</span>
                    p <span class="token operator">=</span> e<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// existing mapping for key</span>
                V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>
                    e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
                <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token operator">++</span>modCount<span class="token punctuation">;</span>
　　　　　<span class="token comment">//数组长度大于阈值，就扩容</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> null<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><strong>通过分析源码，上面的方法主要做了以下几件事</strong>：</p> 
<ol><li>判断当前桶是否为空，空的就需要初始化（<code>resize</code> 中会判断是否进行初始化）。</li><li>根据当前 <code>key</code> 的 <code>hashcode</code> 定位到具体的桶中并判断是否为空，为空表明没有 <code>Hash</code> 冲突就直接在当前位置创建一个新桶即可。</li><li>如果当前桶有值（ <strong>Hash 冲突</strong>），那么就要比较当前桶中的 <code>key</code>、<code>key</code> 的 <code>hashcode</code> 与写入的 <code>key</code>是否相等，相等就赋值给 e。</li><li>如果当前桶为红黑树，那就要按照红黑树的方式写入数据。</li><li>如果是个链表，就需要将当前的 <code>key、value</code> 封装成一个新节点写入到当前桶的后面（形成链表）。</li><li>接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。</li><li>如果在遍历过程中找到 <code>key</code> 相同时直接退出遍历。</li><li>如果 <code>e != null</code> 就相当于存在相同的 <code>key</code>,那就需要将值覆盖。</li><li>最后判断是否需要进行扩容。</li></ol> 
<p>继续看下 treeifyBin 的源码：</p> 
<pre><code class="prism language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">treeifyBin</span><span class="token punctuation">(</span>Node<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span> <span class="token keyword">int</span> hash<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> n<span class="token punctuation">,</span> index<span class="token punctuation">;</span> Node<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
　　　　　<span class="token comment">//链表转为红黑树时，若此时数组长度小于64，扩容数组</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TREEIFY_CAPACITY<span class="token punctuation">)</span>
            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>index <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            TreeNode<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span> hd <span class="token operator">=</span> null<span class="token punctuation">,</span> tl <span class="token operator">=</span> null<span class="token punctuation">;</span>
　　　　　　　<span class="token comment">//链表转为树结构</span>
            <span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span>
                TreeNode<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span> p <span class="token operator">=</span> <span class="token function">replacementTreeNode</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>tl <span class="token operator">==</span> null<span class="token punctuation">)</span>
                    hd <span class="token operator">=</span> p<span class="token punctuation">;</span>
                <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
                    p<span class="token punctuation">.</span>prev <span class="token operator">=</span> tl<span class="token punctuation">;</span>
                    tl<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                tl <span class="token operator">=</span> p<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> hd<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>
                hd<span class="token punctuation">.</span><span class="token function">treeify</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>由此可以看到1.8中，数组有两种情况会发生扩容：</p> 
<ol><li>一是超过阈值</li><li>二是链表转为红黑树且数组元素小于64时</li></ol> 
<p>由此在<code>jdk1.8</code>中，默认长度为<code>16</code>情况下，要么元素一直放在同一下标，链表转为红黑树且数组元素小于64时就会扩容，要么超过阈值<code>12</code>时才会扩容。</p> 
<p>依据上面的源码分析，在<code>JDK 1.8</code>中<code>put</code>方法的执行的原理图如下</p> 
<p><img src="https://images2.imgbox.com/28/02/7Adg1csu_o.png" alt="image-20200702094441458"></p> 
<h4><a id="HashMapJDK7JDK8_251"></a>问点三：HashMap的扩容机制是怎么样的？JDK7与JDK8有什么不同吗？</h4> 
<blockquote> 
 <p><code>JDK 1.7</code>的扩容条件是<strong>数组长度大于阈值且存在哈希冲突</strong>，而<code>JDK 1.8</code>扩容条件是<strong>数组长度大于阈值</strong>或<strong>链表转为红黑树且数组元素小于64</strong>时，源码中的体现如下所示：</p> 
</blockquote> 
<p><strong>JDK1.7扩容源码</strong>：</p> 
<pre><code class="prism language-java"><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
　　　　　<span class="token comment">//数组长度大于阈值且存在哈希冲突（即当前数组下标有元素），就将数组扩容至2倍</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">&gt;=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
            hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
            bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><strong>JDK1.8扩容源码</strong>：</p> 
<pre><code class="prism language-java"><span class="token comment">//数组长度大于阈值，就扩容</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
      <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//链表转为红黑树时，若此时数组长度小于64，扩容数组</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>tab <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&lt;</span> MIN_TREEIFY_CAPACITY<span class="token punctuation">)</span>
      <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="HashMapNull_285"></a>问点四：HashMap中的键值可以为Null吗？能简单说一下原理吗？</h4> 
<blockquote> 
 <p>JDK两个版本都可以。JDK1.7和1.8本质都是去寻找Hash值为0的那个桶，然后如果key为null，则直接替换值</p> 
</blockquote> 
<h4><a id="HashMapputKey_291"></a>问点五：HashMap中能put两个相同的Key吗？为什么能或为什么不能？</h4> 
<blockquote> 
 <p>在<code>JDK7</code>和<code>JDK8</code>中的做法是一样的，若是存入的<code>key</code>值一样，就会将原来的key所对应的value值直接替换掉</p> 
</blockquote> 
<h4><a id="JDK_7HashMap_297"></a>问点六：聊一聊JDK 7的HashMap中的“死锁”是怎么回事？</h4> 
<blockquote> 
 <p>首先JDK7采用的头插法，会有链表成环的问题，JDK采用的尾插法，不会有循环链表的问题。</p> 
 <p><code>HashMap</code>是线程不安全的，在<code>HashMap</code>的源码中并未对其操作进行同步执行，所以在并发访问的时候就会出现线程安全的问题。</p> 
 <p>JDK 7死锁出现在高并发的时候，此时两个线程都将对数据进行扩容，每次扩容的时候，会让链表翻转。</p> 
</blockquote> 
<p><code>transfer</code>函数源码（<code>transfer</code>函数是resize扩容方法中调用的另一个方法）：</p> 
<pre><code class="prism language-java"><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> rehash<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>null <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Entry<span class="token generics function"><span class="token punctuation">&lt;</span>K<span class="token punctuation">,</span>V<span class="token punctuation">&gt;</span></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span> <span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>rehash<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span>hash <span class="token operator">=</span> null <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>
        e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
        e <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token comment">// while</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>假设一个链表，A.next = B , B.next = null</strong>：</p> 
<ul><li>正常情况下，新扩容的数组应该是位null，然后A.next = newTable[i]，则<code>A.next = null</code>，newTable[i] = A ，B.next = newTable[i]，则<code>B.next = A</code>，newTable[i] = B</li><li>如果两个线程同时转换，此时已然会执行 A.next = newTable[i] , 则将<code>A.next = null变成A.next = B</code>，剩下过程一致，<code>出现循环链表</code></li></ul> 
<h4><a id="HashMap_338"></a>问点七：HashMap是线程安全的吗？为什么安全或者不安全？</h4> 
<blockquote> 
 <p>不是线程安全的，比如会在扩容的时候产生循环链表；在put的时候会覆盖别的线程的值</p> 
</blockquote> 
<h4><a id="_HashMap_0758_344"></a>问点八：什么 HashMap 的加载因子是0.75？为什么是超过“8”才用红黑树？</h4> 
<blockquote> 
 <p>因为HashMap底层的数据结构是哈希表，在插入数据的时候会出现hash冲突，而HashMap的解决方式是使用拉链法，即采用额外的空间来解决冲突。</p> 
 <p>而选择加载因子是0.75主要跟数学上泊松分布有关系，选择的参数平均为0.5的泊松分布，计算出来当前加载因子是0.75，这更是空间与时间的一种选择折中。</p> 
 <p>而超过8才使用红黑树，源于该泊松分布计算出来的，一个节点哈希冲突8次的概率极为的小，几乎为不可能时间，这也是一次空间与时间的折中。</p> 
</blockquote> 
<p>​</p> 
<pre><code class="prism language-java"><span class="token comment">//1个节点哈希冲突n次的概率</span>
<span class="token number">0</span><span class="token operator">:</span>    <span class="token number">0.60653066</span>
<span class="token number">1</span><span class="token operator">:</span>    <span class="token number">0.30326533</span>
<span class="token number">2</span><span class="token operator">:</span>    <span class="token number">0.07581633</span>
<span class="token number">3</span><span class="token operator">:</span>    <span class="token number">0.01263606</span>
<span class="token number">4</span><span class="token operator">:</span>    <span class="token number">0.00157952</span>
<span class="token number">5</span><span class="token operator">:</span>    <span class="token number">0.00015795</span>
<span class="token number">6</span><span class="token operator">:</span>    <span class="token number">0.00001316</span>
<span class="token number">7</span><span class="token operator">:</span>    <span class="token number">0.00000094</span>
<span class="token number">8</span><span class="token operator">:</span>    <span class="token number">0.00000006</span>
</code></pre> 
<h4><a id="HashMapHashTableConcurrentHashMap_369"></a>问点九：HashMap、HashTable、ConcurrentHashMap的区别</h4> 
<blockquote> 
 <p>HashMap是线程不安全的，在jdk1.7高并发的时候，可能会在扩容的时候，产生循环链表，所以在高并发的时候，不去使用。</p> 
 <p>HashTable是一个线程安全的，采用的是synchronize的方式，关键字加在方法上，即对当前HashTable对象加锁，会导致所有的数据加上锁。</p> 
 <p>ConcurrentHashMap在JDK1.7的时候使用的是Segment分段锁的思想，将数据分成段，每个段都有个可重入锁，则多线程的时候不会影响到其他线程访问其他段的数据。</p> 
 <p>ConcurrentHashMap在JDK1.8的时候使用的是CAS+synchronized方式，抛弃了Segment分段锁的思想，CAS是一个乐观锁，则在不加锁情况下实现赋值，在当前节点为空的时候，会采用CAS的方式添加节点；而用synchronized而不用是可重入锁的原因是因为官方对synchronized做了很多优化。</p> 
</blockquote> 
<p><code>HashTable</code>其中使用synchronize来保证线程安全，即当有一个线程拥有锁的时候，其他的线程都会进入阻塞或者轮询状态,这样会使得效率越来越低。</p> 
<p>而<code>ConcurrentHashMapMap</code>的锁分段技术可以有效的提高并发访问率，<code>HashTable</code>访问效率低下的原因，就是因为所有的线程在竞争同一把锁。</p> 
<p>如果容器中有多把锁，不同的锁锁定不同的位置，这样线程间就不会存在锁的竞争，这样就可以有效的提高并发访问效率,这就是<code>ConcurrentHashMap</code>所使用的锁分段技术将数据一段一段的存储，为每一段都配一把锁，当一个线程只是占用其中的一个数据段时,其他段的数据也能被其他线程访问。</p> 
<p>在JDK1.7中currentHashMap采用的是<strong>Segment分段锁的思想</strong>方式实现：</p> 
<ul><li>Segment是将数据分成段，默认是16，每个段都有一把锁，则理论最高支持16个线程并发</li></ul> 
<p><img src="https://images2.imgbox.com/94/96/hGLA25Gb_o.png" alt="image-20200703093226831"></p> 
<p>JDK1.8的currentHashMap采用的是**数组+链表+红黑树，抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized **方式实现：</p> 
<ul><li> <p>CAS，是一个乐观锁，他主要思想是<strong>比较然后再执行操作</strong>，比较的是内存的值和预期的原值是否一致，如果不一致，则需要自旋获取新值，但是CAS的最大问题就是可能出现ABA的问题。</p> </li><li> <p>在<code>no lock when adding to empty bin</code> ，也就是桶为空的时候采用CAS方式添加数据，而不为空的时候采用synchronized 的方式</p> <p><img src="https://images2.imgbox.com/1f/ce/7H3ExjQg_o.png" alt="image-20200703093803430"></p> </li></ul> 
<h4><a id="_HashMap_getput__413"></a>问点十：谈谈你理解的 HashMap，讲讲其中的 get和put 过程</h4> 
<p><strong>put方法</strong>：</p> 
<ul><li>考虑是否要初始化</li><li>根据key计算哈希值，找到hash表对应的索引</li><li>然后判断是否出现的hash冲突，如果没有则直接插入，查看是否需要扩容</li><li>JDK1.7出现hash冲突直接插入链表中即可</li><li>JDK1.8出现hash冲突，需要先判断当前是红黑树还是链表，对于链表可能会有一个树化的过程</li></ul> 
<p><strong>get方法</strong>：</p> 
<ul><li>思路与上面一致，只是少了一个扩容和树化的过程</li></ul> 
<p><img src="https://images2.imgbox.com/08/21/KShw6nuv_o.png" alt="image-20200702094441458"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d831843f6c01e090f7e5f7f3583ed6e0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">springboot整合mybatis配置异常:Property ‘configuration‘and‘configLocation‘cannotspecifiedwithtogether源码角度分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c0e4001a8b57c4f3987c0528f09a4cac/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">专业课错题记录（数据结构）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>