<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>专业课错题记录（数据结构） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="专业课错题记录（数据结构）" />
<meta property="og:description" content="文章目录 五、二叉树七、二叉搜索树八、高级搜索树九、字典十一、优先级队列十二、排序 五、二叉树 1.高度为h的满二叉树有多少个节点?(A)
A.2h&#43;1−1
B.2h&#43;1
C.2h−1
D.2h
解析：这里的h是高度，不是层次，两者的对应关系应该是高度h=总的层级数-1
2.设二叉树有n个节点,高度为h.在其中插入一个新的节点,高度发生改变的节点个数为:C
A.O(1)
B.O(n)
C.O(h)
D.O(hlog2(n))
解析：这个题也是做的我一脸懵逼，这不是和插入的位置有关吗?看了答案才知道，原来问题想说的可能是插入一个叶子节点。答案的解析是，插入的节点的这条路径上所有的节点的高度都会发生变化
3.中序遍历中第一个被访问的节点是:(A)
A.Leftmost node最左的节点
B.Rightmost node最右的节点
C.Root node根节点
D.Leaf node on the left branch左侧分枝的叶节点
解析：这个对我而言也是懵逼题。我不太清楚这个左侧分支的叶结点和最左的节点有什么区别，如果硬要说区别，大概就是左侧分支的叶节点分为左叶子和右叶子吧？
4.从n个节点的二叉树的叶节点u逐个节点地上溯到根节点的过程中，以下说法中错误的是：（D）
A.The passing nodes are all ancestors of u.经过的节点都是u的祖先。
B.The worst time complexity is O(n)最坏时间复杂度为O(n)
C.The path that is passed is uniquely determined经过的路径是唯一确定的
D.Each time it goes up one level, the depth of the current node decreases by one and the height increases by one." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c0e4001a8b57c4f3987c0528f09a4cac/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-03T12:30:15+08:00" />
<meta property="article:modified_time" content="2020-07-03T12:30:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">专业课错题记录（数据结构）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">五、二叉树</a></li><li><a href="#_53" rel="nofollow">七、二叉搜索树</a></li><li><a href="#_81" rel="nofollow">八、高级搜索树</a></li><li><a href="#_113" rel="nofollow">九、字典</a></li><li><a href="#_124" rel="nofollow">十一、优先级队列</a></li><li><a href="#_128" rel="nofollow">十二、排序</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>五、二叉树</h2> 
<p>1.高度为h的满二叉树有多少个节点?(A)<br> A.2<sup>h+1</sup>−1<br> B.2<sup>h</sup>+1<br> C.2<sup>h</sup>−1<br> D.2<sup>h</sup></p> 
<p>解析：这里的h是高度，不是层次，两者的对应关系应该是<code>高度h=总的层级数-1</code></p> 
<p>2.设二叉树有n个节点,高度为h.在其中插入一个新的节点,高度发生改变的节点个数为:C<br> A.O(1)<br> B.O(n)<br> C.O(h)<br> D.O(hlog2(n))</p> 
<p>解析：这个题也是做的我一脸懵逼，这不是和插入的位置有关吗?看了答案才知道，原来问题想说的可能是插入一个叶子节点。答案的解析是，插入的节点的这条路径上所有的节点的高度都会发生变化</p> 
<p>3.中序遍历中第一个被访问的节点是:(A)<br> A.Leftmost node最左的节点<br> B.Rightmost node最右的节点<br> C.Root node根节点<br> D.Leaf node on the left branch左侧分枝的叶节点</p> 
<p>解析：这个对我而言也是懵逼题。我不太清楚这个<code>左侧分支的叶结点</code>和<code>最左的节点</code>有什么区别，如果硬要说区别，大概就是左侧分支的叶节点分为左叶子和右叶子吧？</p> 
<p>4.从n个节点的二叉树的叶节点u逐个节点地上溯到根节点的过程中，以下说法中错误的是：（D）<br> A.The passing nodes are all ancestors of u.经过的节点都是u的祖先。<br> B.The worst time complexity is O(n)最坏时间复杂度为O(n)<br> C.The path that is passed is uniquely determined经过的路径是唯一确定的<br> D.Each time it goes up one level, the depth of the current node decreases by one and the height increases by one.每上溯一层，当前节点的深度减小1，而高度增加1</p> 
<p>解析：上溯一层，深度的确减1，但是高度可能会增加1以上，因为节点的高度由左右子树中更深的那棵决定</p> 
<p>5.对二叉树进行中序遍历，节点v在中序遍历下的后继为（假设v的后继存在）：©<br> A.The first visited node in its right subtree其右子树中第一个被访问的节点<br> B.The first visited node in its left subtree其左子树中第一个被访问的节点<br> C.The first visited node in its right subtree or an ancestor of v其右子树中第一个被访问的节点或v的某个祖先<br> D.The first node in its right subtree or a node in its left subtree其右子树中第一个被访问的节点或其左子树中的某个节点</p> 
<p>解析：这个v可能是左子节点，它的后继为它的老爸；也可能是某棵子树的根节点，它的后继为右子树中第一个被访问的节点；也可能是右节点，这时候它的后继为它的某个爷爷级或者爷爷级以上的祖先</p> 
<p>6.与先序、中序遍历类似，以左子-&gt;右子-&gt;根节点的顺序来访问二叉树称为后序遍历。后序遍历中第一个被访问的节点是：()</p> 
<p>A.The deepest node in the left chain左侧链中最深的节点<br> B.Root node根节点<br> C.The deepest node in the right chain右侧链中最深的节点<br> D.None of the above以上皆不是</p> 
<p>解析：D。正解是<code>从根节点开始，对于中途每个节点，能往左就往左，不能往左就往右，若左右都无路可走，则该节点是后序遍历中第一个被访问的节点。</code>至于A为什么错，比如这样的树：<br> <img src="https://images2.imgbox.com/4f/69/xhKNebLd_o.png" alt="在这里插入图片描述"></p> 
<p>这时候最先访问的就不是左侧链中最深的节点了，而是节点A</p> 
<h2><a id="_53"></a>七、二叉搜索树</h2> 
<p>1.在含n个节点的BST中进行查找的最坏时间复杂度为：<br> A.O(1)<br> B.O(log2(n))<br> C.O(n)<br> D.O(nlog2(n))<br> 解析：最坏的情况是这棵BST只有左子树或者只有右子树，反正就是拉开后可以变成一条边的那种树，这时候查找效率为O(n)</p> 
<p>2.在AVL中插入节点的时间复杂度为（B）</p> 
<p>A.O(1)</p> 
<p>B.O(lgn)</p> 
<p>C.O(n)</p> 
<p>D.O(nlgn)</p> 
<p>解析：插入还包括查找，而不仅仅是一个简单的构建节点、插入节点</p> 
<p>3.二叉搜索树的高度h和节点个数n满足关系 ()</p> 
<p>A.h=O(1)<br> B.h=O(lgn)<br> C.h=O(n)<br> D.h=O(nlgn)<br> 解析：C。大O表示的是上界，因此我们要考虑的是最坏的情况</p> 
<h2><a id="_81"></a>八、高级搜索树</h2> 
<p>1.Tarjan提出的伸展算法每几层一起伸展？<br> 解析：2。你本来填的是3，因为考虑到每次伸展都是子父爷三代一起考虑的。反正你记住，tarjan提出的算法就是每次追溯两层，因为每次伸展完成后，子节点都是往上提了两层（除非只有节点个数不足3个）</p> 
<p><br>2. 内存“越来越小”的原因是：</p> 
<p>A.机器上运行的程序越来越多，平均每个程序使用的内存变小<br> B.实际应用对存储的需求急剧增长<br> C.用于制造内存芯片的硅资源消耗殆尽<br> D. 随着工艺的进步，内存的体积变小，集成度变高</p> 
<p>解析：B。内存变小，指的是相对变小</p> 
<p>2.B树高度的减少只会发生于（）</p> 
<p>A 根节点的两个孩子合并</p> 
<p>B 根节点被删除</p> 
<p>C 根节点发生旋转</p> 
<p>D 根节点有多个关键码</p> 
<p>解析：A。我又晕了。估计是我和老师对根节点被删除的意思理解不一样吧，我觉得处理下溢导致根节点不再含有任何节点时，就相当于删除了该节点；我不选A的原因是，觉得A并不是充要条件，但题目的意思是求必要条件，即如果B树高度减少了，那么下列哪个选项一定发生了？如果删除根节点不是我想的那样的话，就应该是A了</p> 
<p>3.当叔父节点u为红色时，修正双红缺陷导致的红黑树拓扑结构的变化为：<br> A 没有变化<br> B 有变化，但是不超过O(1)<br> C 有变化，但是不超过O(lgn)<br> D 有变化，但是不超过O(n)<br> 解析：A。估计就是问一次调整导致的拓扑变化，没有考虑后面的变化</p> 
<h2><a id="_113"></a>九、字典</h2> 
<p>1.规模为11的桶数组当前状态为 A = { *, *, *, *, *, 0, 15, 26, <em>, 5, 9}，其中</em>表示空桶<br> 散列函数为h(key) = (3 * key + 5) % 11<br> 用开放定址+平方试探排解冲突<br> 插入词条4, 它的实际存放位置是<br> A. A[4]<br> B. A[6]<br> C. A[7]<br> D. A[8]<br> 解析：A。hash(4)=6，（6+1<sup>2</sup>)%11=7,A[7]有人；（6+2<sup>2</sup>)%11=10，A[10]有人；（6+3<sup>2</sup>)%11=4，A[4]没人，所以实际存放位置是A[4]。你一开始没想到的是，6+2<sup>2</sup>=10&lt;11,6+3<sup>2</sup>=15&gt;11，你就以为不能继续做下去了。</p> 
<h2><a id="_124"></a>十一、优先级队列</h2> 
<p>1.堆排序的空间复杂度是多少？（不包括它输入的数据的空间）<br> 解析：O(1)。我本来以为是O(n)，因为我以为输入n个数据，就需要另外n个数据的空间来存放这n个数据；但实际上堆排序是直接在原来的数据空间基础上进行排序的，也就是原地排序，所以只需要常数个空间来保存其它的无关紧要的中间变量，所以空间复杂度为O(n)</p> 
<h2><a id="_128"></a>十二、排序</h2> 
<p>1.在希尔排序的每一趟排序中，为什么使用插入排序：<br> A 插入排序渐进的效率高<br> B 插入排序简单，容易实现<br> C 入排序对输入序列的有序程度敏感<br> D 入排序是稳定的<br> 解析：C。书本P353的<strong>底层算法</strong>的第一段说明支持希尔排序的底层排序算法，必须是输入敏感的；而至于渐进效率，则是希尔排序中的插入排序的优点。虽然暂时没懂，但应该输入敏感才是最重要的吧？</p> 
<p>2.计数排序：原序列中的元素是一定范围内的整数，计算每个可能的整数在其中出现的次数，便可得排序结果。详见：https://www.cnblogs.com/kyoner/p/10604781.html</p> 
<p>3.我们在本节中已经得到了最坏时间复杂度为O(n)的中位数选取算法，若把它用于快速排序的轴点选取，得到的快速排序最坏时间复杂度为（）<br> 解析：O(nlogn)。选取到中位数作为轴点后，就相当于选到了一个刚好位于正中间的，可以把数组对半分，所以正确的时间复杂度为O(nlogn)。但是实际上这个算法并不可行，因为根据P350的内容，线性选取中位数的算法的常系数非常大，所以在通常规模的应用中难以体现效率的优势</p> 
<p>4.快速排序算法选取轴点时可以采取不同的策略，本题试图说明“三者取中”的策略比随机选取的策略倾向于得到更平衡的轴点</p> 
<p>设待排序序列的长度n很大，若轴点的选取使得分割后长/短子序列的长度比大于9:1，则称为不平衡</p> 
<p>问题：针对不同的轴点选取策略，估计其发生不平衡的概率(请填十进制小数)：<br> 1）从n个元素中等概率随机选取一个作为轴点：<br> 2）n个元素中等概率选取三个元素，以它们的中间元素作为轴点：<br> 第一题为0.2，很简单<br> 第二题：空间几何坐标轴中，取立方体S={(x,y,z)|x属于[0,1]，y属于[0,1]，z属于[0,1]}<br> 然后计算公式为2×（0.1*0.1*1*3-0.1*0.1*0.1*2）=0.056</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/52ab0e8339022a7cfce33dd4547fba9a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">HashMap面试题总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4d16f7d04c0603766e7cd27af7897b93/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">笔记：jdk 1.8 使用switch报错:Incompatible types. Found: ‘java.lang.String‘, required: ‘byte, char, short o</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>