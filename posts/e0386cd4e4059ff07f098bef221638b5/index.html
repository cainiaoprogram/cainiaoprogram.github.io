<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>mybatis二级缓存 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="mybatis二级缓存" />
<meta property="og:description" content="MyBatis
缓存可以极大的提升查询效率。
MyBatis系统中默认定义两级缓存（一级缓存和二级缓存）。
一、两级缓存
1、一级缓存：（本地缓存）：sqlSession级别的缓存。一级缓存是一直开启的；sqlSession级别的一个Map。
与数据库同一次会话期间查询到的数据会放在本地缓存中
以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库；
一级缓存失效情况（没有使用到当前一级缓存的情况，效果就是，还需要再向数据库发出查询）：
1、sqlSession不同。
2、sqlSession相同，查询条件不同。（当前一级缓存中还没有这个数据）
3、sqlSession相同，两次查询之间执行了增删改操作（这次增删改可能对当前数据有影响）
4、sqlSession相同，手动清除了一级缓存（缓存清空）
2、二级缓存：（全局缓存）：基于namespace级别的缓存：一个namespace对应一个二级缓存：
工作机制：
1、一个会话，查询一条数据，这个数据就会被放在当前会话的一级缓存中；
2、如果会话关闭；一级缓存中的数据会被保存到二级缓存中；新的会话查询信息，就可以参照二级缓存中的内容。
3、sqlSession=EmployeeMapper=&gt;Employee
DepartmentMapper===&gt;Department
不同的namespace查出的数据会放在自己对应的缓存中（Map）
效果：数据会从二级缓存中获取
查出的数据都会被默认先放在一级缓存中。
只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中。
使用步骤：
1）、开启全局二级缓存配置：mybatis默认开启二级缓存，还是要在配置文件中显式的开启
在配置文件mybatis-config.xml的setting将其开启
//显式的指定每个我们需要更改的配置的值，即使他是默认的。防止版本更新带来的问题
2）、去mapper.xml中配置使用二级缓存： 在哪个mapper文件中使用cache标签，那个mapper中有二级缓存
在mapper标签中写标签。
&lt;!-- eviction：缓存的回收策略： LRU==最近最少使用：移除最长时间不被使用的对象。 FIFO==先进先出：按对象进入缓存的顺序来移除它们。 SOFT==软引用：移除基于垃圾回收器状态和软引用规则的对象。 WEAK==弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。 默认是LRU。 flushInterval：缓存刷新间隔 缓存多长时间清空一次，默认是不清空，设置一个毫秒值 readOnly：是否只读； true：只读；mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。 mybatis为了加快获取速度，直接就会将数据在缓存中的引用交给用户。不安全，速度快。 false：非只读；mybatis觉得获取的数据可能会被修改。 mybatis会利用序列化&amp;反序列化的技术克隆一份新的数据给你。安全，速度慢。默认为false。 size：缓存存放多少元素； type：指定自定义缓存的全类名； 实现Cache接口即可； --&gt; &lt;cache&gt;&lt;/cache&gt; 3）、我们的POJO需要实现序列化接口
两个不同的sqlSession，开启二级缓存之后。第一次会话关闭之后，第二次查询时直接在二级缓存中取。
3、缓存有关的设置以及属性
和缓存有关的设置/属性：
1）、cacheEnabled=true：
=false：关闭缓存（关闭二级缓存）（一级缓存一直可用）
2）、每个select标签都有useCache=“true”：
=false：不使用缓存（一级缓存依然可以使用，二级缓存不使用）
3）、每个增删改标签：flushCache=“true”：增删改执行完成后就会清除缓存（一级二级都会清除）
测试：flushCache=“true”：一级缓存就清空了；二级缓存也会被清空。
在select标签中默认flushCache=false：不清缓存，如果改为true，每次查完就会清缓存。
4）、sqlSession.clearCache()：只是清除当前sqlSession的一级缓存； 5）、在全局配置文件的settings标签中localCacheScope：本地缓存作用域：（一级缓存SESSION）；当前会话的所有数据保存在会话缓存中；
STATEMENT：可以禁用一级缓存；
4、缓存原理图示
Cache接口：
mybatis的缓存就是一个小Map" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e0386cd4e4059ff07f098bef221638b5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-15T09:37:00+08:00" />
<meta property="article:modified_time" content="2023-06-15T09:37:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">mybatis二级缓存</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p><a class="hl hl-1" href="https://so.csdn.net/so/search?q=MyBatis&amp;spm=1001.2101.3001.7020">MyBatis</a><br> 缓存可以极大的提升查询效率。<br> MyBatis系统中默认定义两级缓存（一级缓存和二级缓存）。<br><strong>一、两级缓存</strong><br> 1、一级缓存：（本地缓存）：sqlSession级别的缓存。一级缓存是一直开启的；sqlSession级别的一个Map。<br> 　　与数据库同一次会话期间查询到的数据会放在本地缓存中<br> 　　以后如果需要获取相同的数据，直接从缓存中拿，没必要再去查询数据库；<br> 　　<img alt="在这里插入图片描述" src="https://images2.imgbox.com/b4/b0/73JoSUVT_o.png"><br> 一级缓存失效情况（没有使用到当前一级缓存的情况，效果就是，还需要再向数据库发出查询）：<br> 　　1、sqlSession不同。<br> 　　<img alt="在这里插入图片描述" src="https://images2.imgbox.com/64/24/19FgEvqy_o.png"><br> 2、sqlSession相同，查询条件不同。（当前一级缓存中还没有这个数据）<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/13/a3/tTMtNNDa_o.png"><br> 3、sqlSession相同，两次查询之间执行了增删改操作（这次增删改可能对当前数据有影响）<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/8c/b6/rYdYlDCz_o.png"><br> 4、sqlSession相同，手动清除了一级缓存（缓存清空）<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/c8/92/tEFXrYb4_o.png"><br><strong>2、二级缓存：（全局缓存）：基于namespace级别的缓存：一个namespace对应一个二级缓存：</strong><br> 　　工作机制：<br> 　　1、一个会话，查询一条数据，这个数据就会被放在当前会话的一级缓存中；<br> 　　2、如果会话关闭；一级缓存中的数据会被保存到二级缓存中；新的会话查询信息，就可以参照二级缓存中的内容。<br> 　　3、sqlSession=EmployeeMapper=&gt;Employee<br> 　　　　　　　　　　DepartmentMapper===&gt;Department<br> 　　　　不同的namespace查出的数据会放在自己对应的缓存中（Map）<br> 　　　　效果：数据会从二级缓存中获取<br> 　　　　　　查出的数据都会被默认先放在一级缓存中。<br> 　　　　　　只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中。<br> 　　使用步骤：<br> 　　1）、开启全局二级缓存配置：mybatis默认开启二级缓存，还是要在配置文件中显式的开启<br> 在配置文件mybatis-config.xml的setting将其开启<br><br> //显式的指定每个我们需要更改的配置的值，即使他是默认的。防止版本更新带来的问题<br><br><br> 　　2）、去mapper.xml中配置使用二级缓存： 在哪个mapper文件中使用cache标签，那个mapper中有二级缓存<br> 在mapper标签中写标签。</p> 
<p></p> 
<pre><code class="hljs">&lt;!--
    eviction：缓存的回收策略：
        LRU==最近最少使用：移除最长时间不被使用的对象。
        FIFO==先进先出：按对象进入缓存的顺序来移除它们。
        SOFT==软引用：移除基于垃圾回收器状态和软引用规则的对象。
        WEAK==弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。
        默认是LRU。
    flushInterval：缓存刷新间隔
        缓存多长时间清空一次，默认是不清空，设置一个毫秒值
    readOnly：是否只读；
        true：只读；mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。
                    mybatis为了加快获取速度，直接就会将数据在缓存中的引用交给用户。不安全，速度快。
        false：非只读；mybatis觉得获取的数据可能会被修改。
                    mybatis会利用序列化&amp;反序列化的技术克隆一份新的数据给你。安全，速度慢。默认为false。
    size：缓存存放多少元素；
    type：指定自定义缓存的全类名；
            实现Cache接口即可；
--&gt;

&lt;cache&gt;&lt;/cache&gt;
</code></pre> 
<p></p> 
<p>3）、我们的POJO需要实现序列化接口<br> 两个不同的sqlSession，开启二级缓存之后。第一次会话关闭之后，第二次查询时直接在二级缓存中取。</p> 
<p></p> 
<p>3、缓存有关的设置以及属性<br> 和缓存有关的设置/属性：<br> 　　1）、cacheEnabled=true：<br> 　　　　　　　　　　　=false：关闭缓存（关闭二级缓存）（一级缓存一直可用）<br> 　　2）、每个select标签都有useCache=“true”：<br> 　　　　　　　　　　　　　　=false：不使用缓存（一级缓存依然可以使用，二级缓存不使用）<br> 　　3）、每个增删改标签：flushCache=“true”：增删改执行完成后就会清除缓存（一级二级都会清除）<br> 　　　　　　　　测试：flushCache=“true”：一级缓存就清空了；二级缓存也会被清空。<br> 　　　　　　在select标签中默认flushCache=false：不清缓存，如果改为true，每次查完就会清缓存。<br> 　　4）、sqlSession.clearCache()：只是清除当前sqlSession的一级缓存； 　　<br> 　　5）、在全局配置文件的settings标签中localCacheScope：本地缓存作用域：（一级缓存<a class="hl hl-1" href="https://so.csdn.net/so/search?q=SESSION&amp;spm=1001.2101.3001.7020">SESSION</a>）；当前会话的所有数据保存在会话缓存中；<br> 　　　　　　　　STATEMENT：可以禁用一级缓存；<br> 4、缓存原理图示<br><img alt="" src="https://images2.imgbox.com/33/0b/qfcGY1tx_o.png"></p> 
<p></p> 
<p>Cache接口：<br><img alt="" src="https://images2.imgbox.com/3e/13/8NRm5Ion_o.png"></p> 
<p></p> 
<p>mybatis的缓存就是一个小Map<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/d9/59/WJ6ROwU3_o.png"></p> 
<p><br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d8e01e43c04236f7c2d6707f31143e7e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python函数详解（超详细）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d4fac5f2a7e3f792349aad897787f6cb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用python的GDAL库将坐标系的wkt转epsg</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>