<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Token认证模式以及JWT介绍 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Token认证模式以及JWT介绍" />
<meta property="og:description" content="Token 认证模式 鉴于基于 Session 的会话管理⽅式存在上述多个缺点，基于 Token 的⽆状态会话管理⽅式诞⽣了，所谓⽆状态，就是服务端可以不再存储信息，甚⾄是不再存储 Session ，逻辑如下。 客户端使⽤⽤户名、密码进⾏认证 服务端验证⽤户名、密码正确后⽣成 Token 返回给客户端 客户端保存 Token，访问需要认证的接⼝时在 URL 参数或 HTTP Header 中加⼊ Token 服务端通过解码 Token 进⾏鉴权，返回给客户端需要的数据 基于 Token 的会话管理⽅式有效解决了基于 Session 的会话管理⽅式带来的问题。 服务端不需要存储和⽤户鉴权有关的信息，鉴权信息会被加密到 Token 中，服务端只需要读取 Token 中包含的鉴权信息即可 避免了共享 Session 导致的不易扩展问题 不需要依赖 Cookie，有效避免 Cookie 带来的 CSRF 攻击问题 使⽤ CORS 可以快速解决跨域问题 JWT介绍 JWT 是 JSON Web Token 的缩写，是为了在⽹络应⽤环境间传递声明⽽执⾏的⼀种基于 JSON 的开放标准（ (RFC 7519 ) 。 JWT 本身没有定义任何技术实现，它只是定义了⼀种基于 Token 的会话管理的规则，涵盖 Token 需要包含的标准内容和 Token 的⽣成过程，特别适⽤于分布式站点的单点登录（ SSO） 场景。 ⼀个 JWT Token 就像这样： eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c5d6e7b44d8c03e527d573596ba92758/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-11T20:31:52+08:00" />
<meta property="article:modified_time" content="2023-10-11T20:31:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Token认证模式以及JWT介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><span style="color:#333333;"><strong>Token </strong></span><span style="color:#333333;"><strong>认证模式 </strong></span></h2> 
<div> 
 <span style="color:#333333;">        鉴于基于 Session </span> 
 <span style="color:#333333;">的会话管理⽅式存在上述多个缺点，基于</span> 
 <span style="color:#333333;"> Token </span> 
 <span style="color:#333333;">的⽆状态会话管理⽅式诞⽣了，所谓⽆状态，就是服务端可以不再存储信息，甚⾄是不再存储 Session</span> 
 <span style="color:#333333;">，逻辑如下。 </span> 
</div> 
<ul><li><span style="color:#333333;">客户端使⽤⽤户名、密码进⾏认证 </span></li><li><span style="color:#333333;">服务端验证⽤户名、密码正确后⽣成</span><span style="color:#333333;"> Token </span><span style="color:#333333;">返回给客户端 </span></li><li><span style="color:#333333;">客户端保存</span><span style="color:#333333;"> Token</span><span style="color:#333333;">，访问需要认证的接⼝时在</span><span style="color:#333333;"> URL </span><span style="color:#333333;">参数或</span><span style="color:#333333;"> HTTP Header </span><span style="color:#333333;">中加⼊</span><span style="color:#333333;"> Token </span></li><li><span style="color:#333333;">服务端通过解码</span><span style="color:#333333;"> Token </span><span style="color:#333333;">进⾏鉴权，返回给客户端需要的数据</span></li></ul> 
<p> <img alt="" height="469" src="https://images2.imgbox.com/02/0f/S1RxypT3_o.png" width="755"></p> 
<div> 
 <span style="color:#333333;">        基于 Token </span> 
 <span style="color:#333333;">的会话管理⽅式有效解决了基于</span> 
 <span style="color:#333333;"> Session </span> 
 <span style="color:#333333;">的会话管理⽅式带来的问题。 </span> 
</div> 
<ul><li><span style="color:#333333;">服务端不需要存储和⽤户鉴权有关的信息，鉴权信息会被加密到</span><span style="color:#333333;"> Token </span><span style="color:#333333;">中，服务端只需要读取 Token 中包含的鉴权信息即可 </span></li><li><span style="color:#333333;">避免了共享</span><span style="color:#333333;"> Session </span><span style="color:#333333;">导致的不易扩展问题 </span></li><li><span style="color:#333333;">不需要依赖</span><span style="color:#333333;"> Cookie</span><span style="color:#333333;">，有效避免</span><span style="color:#333333;"> Cookie </span><span style="color:#333333;">带来的</span><span style="color:#333333;"> CSRF </span><span style="color:#333333;">攻击问题 </span></li><li><span style="color:#333333;">使⽤</span><span style="color:#333333;"> CORS </span><span style="color:#333333;">可以快速解决跨域问题</span></li></ul> 
<p> </p> 
<h2><span style="color:#333333;"><strong>JWT</strong></span><span style="color:#333333;"><strong>介绍 </strong></span></h2> 
<div></div> 
<div> 
 <span style="color:#333333;">        JWT 是</span> 
 <span style="color:#333333;"> JSON Web Token </span> 
 <span style="color:#333333;">的缩写，是为了在⽹络应⽤环境间传递声明⽽执⾏的⼀种基于</span> 
 <span style="color:#333333;">JSON</span> 
 <span style="color:#333333;">的开放标准（</span> 
 <span style="color:#4183c4;">(RFC 7519</span> 
 <span style="color:#333333;">)</span> 
 <span style="color:#333333;">。</span> 
 <span style="color:#333333;">JWT </span> 
 <span style="color:#333333;">本身没有定义任何技术实现，它只是定义了⼀种基于</span> 
 <span style="color:#333333;"> Token </span> 
 <span style="color:#333333;">的会话管理的规则，涵盖 Token </span> 
 <span style="color:#333333;">需要包含的标准内容和</span> 
 <span style="color:#333333;"> Token </span> 
 <span style="color:#333333;">的⽣成过程，特别适⽤于分布式站点的单点登录（</span> 
 <span style="color:#333333;">SSO）</span> 
 <span style="color:#333333;">场景。</span> 
</div> 
<div> 
 <span style="color:#333333;">        ⼀个 JWT Token 就像这样：  </span> 
</div> 
<div> 
 <pre><code class="hljs">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoyODAxODcyNzQ4ODMyMzU4NSwiZ
XhwIjoxNTk0NTQwMjkxLCJpc3MiOiJibHVlYmVsbCJ9.lk_ZrAtYGCeZhK3iupHxP1kgjBJzQTVTtX
0iZYFx9wU</code></pre> 
 <span style="color:#333333;">     </span> 
 <div> 
  <span style="color:#333333;">它是由 </span> 
  <span style="color:#333333;">. </span> 
  <span style="color:#333333;">分隔的三部分组成，这三部分依次是： </span> 
 </div> 
 <ul><li><span style="color:#333333;">头部（</span><span style="color:#333333;">Header</span><span style="color:#333333;">） </span></li><li><span style="color:#333333;">负载（</span><span style="color:#333333;">Payload</span><span style="color:#333333;">） </span></li><li><span style="color:#333333;">签名（</span><span style="color:#333333;">Signature</span><span style="color:#333333;">） </span></li></ul> 
 <div> 
  <span style="color:#333333;">头部和负载以</span> 
  <span style="color:#333333;"> JSON </span> 
  <span style="color:#333333;">形式存在，这就是</span> 
  <span style="color:#333333;"> JWT </span> 
  <span style="color:#333333;">中的</span> 
  <span style="color:#333333;"> JSON</span> 
  <span style="color:#333333;">，三部分的内容都分别单独经过了</span> 
  <span style="color:#333333;"> Base64 </span> 
  <span style="color:#333333;">编码，以 . </span> 
  <span style="color:#333333;">拼接成⼀个</span> 
  <span style="color:#333333;"> JWT Token</span> 
  <span style="color:#333333;">。 </span> 
 </div> 
 <div> 
  <img alt="" height="196" src="https://images2.imgbox.com/20/db/QqlfoTqD_o.png" width="712"> 
 </div> 
</div> 
<p></p> 
<div> 
 <span style="color:#333333;"><strong>Header </strong></span> 
</div> 
<div> 
 <span style="color:#333333;">JWT </span> 
 <span style="color:#333333;">的</span> 
 <span style="color:#333333;"> Header </span> 
 <span style="color:#333333;">中存储了所使⽤的加密算法和</span> 
 <span style="color:#333333;"> Token </span> 
 <span style="color:#333333;">类型</span> 
 <pre><code class="hljs">{
 "alg": "HS256",
 "typ": "JWT"
}</code></pre> 
</div> 
<div> 
 <div> 
  <span style="color:#333333;"><strong>Payload </strong></span> 
 </div> 
 <div> 
  <span style="color:#333333;">Payload </span> 
  <span style="color:#333333;">表示负载，也是⼀个</span> 
  <span style="color:#333333;"> JSON </span> 
  <span style="color:#333333;">对象，</span> 
  <span style="color:#333333;">JWT </span> 
  <span style="color:#333333;">规定了</span> 
  <span style="color:#333333;">7</span> 
  <span style="color:#333333;">个官⽅字段供选⽤，</span> 
 </div> 
 <div> 
  <pre><code class="hljs">iss (issuer)：签发⼈
exp (expiration time)：过期时间
sub (subject)：主题
aud (audience)：受众
nbf (Not Before)：⽣效时间
iat (Issued At)：签发时间
jti (JWT ID)：编号</code></pre> 
  <div> 
   <span style="color:#333333;">除了官⽅字段，开发者也可以⾃⼰指定字段和内容，例如下⾯的内容。</span> 
   <pre><code class="hljs">{
 "sub": "1234567890",
 "name": "John Doe",
 "admin": true
}</code></pre> 
  </div> 
 </div> 
</div> 
<div> 
 <span style="color:#333333;">注意，</span> 
 <span style="color:#333333;">JWT </span> 
 <span style="color:#333333;">默认是不加密的，任何⼈都可以读到，所以不要把秘密信息放在这个部分。这个</span> 
 <span style="color:#333333;">JSON </span> 
 <span style="color:#333333;">对象 也要使⽤ Base64URL </span> 
 <span style="color:#333333;">算法转成字符串。</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#333333;"><strong>Signature </strong></span> 
</div> 
<div> 
 <span style="color:#333333;">Signature </span> 
 <span style="color:#333333;">部分是对前两部分的签名，防⽌数据篡改。</span> 
</div> 
<div></div> 
<div> 
 <span style="color:#333333;">⾸先，需要指定⼀个密钥（</span> 
 <span style="color:#333333;">secret</span> 
 <span style="color:#333333;">）。这个密钥只有服务器才知道，不能泄露给⽤户。然后，使⽤ </span> 
</div> 
<div> 
 <span style="color:#333333;">Header </span> 
 <span style="color:#333333;">⾥⾯指定的签名算法（默认是</span> 
 <span style="color:#333333;"> HMAC SHA256</span> 
 <span style="color:#333333;">），按照下⾯的公式产⽣签名。</span> 
 <pre><code class="hljs">HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload),secret)</code></pre> 
</div> 
<p> </p> 
<div> 
 <span style="color:#333333;"><strong>JWT</strong></span> 
 <span style="color:#333333;"><strong>优缺点 </strong></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#333333;">        JWT 拥有基于</span> 
 <span style="color:#333333;"> Token </span> 
 <span style="color:#333333;">的会话管理⽅式所拥有的⼀切优势，不依赖</span> 
 <span style="color:#333333;"> Cookie</span> 
 <span style="color:#333333;">，使得其可以防⽌</span> 
 <span style="color:#333333;"> CSRF </span> 
 <span style="color:#333333;">攻击，也能在禁⽤ Cookie </span> 
 <span style="color:#333333;">的浏览器环境中正常运⾏。 </span> 
</div> 
<div> 
 <span style="color:#333333;">        ⽽ JWT </span> 
 <span style="color:#333333;">的最⼤优势是服务端不再需要存储</span> 
 <span style="color:#333333;"> Session</span> 
 <span style="color:#333333;">，使得服务端认证鉴权业务可以⽅便扩展，避免存储 Session 所需要引⼊的</span> 
 <span style="color:#333333;"> Redis </span> 
 <span style="color:#333333;">等组件，降低了系统架构复杂度。但这也是</span> 
 <span style="color:#333333;"> JWT </span> 
 <span style="color:#333333;">最⼤的劣势，由于有效期 存储在 Token </span> 
 <span style="color:#333333;">中，</span> 
 <span style="color:#333333;">JWT Token </span> 
 <span style="color:#333333;">⼀旦签发，就会在有效期内⼀直可⽤，⽆法在服务端废⽌，当⽤户进⾏登出操作，只能依赖客户端删除掉本地存储的 JWT Token</span> 
 <span style="color:#333333;">，如果需要禁⽤⽤户，单纯使⽤</span> 
 <span style="color:#333333;"> JWT </span> 
 <span style="color:#333333;">就⽆法做到了。</span> 
</div> 
<p></p> 
<div> 
 <span style="color:#333333;"><strong>基于</strong></span> 
 <span style="color:#333333;"><strong>jwt</strong></span> 
 <span style="color:#333333;"><strong>实现认证实践 </strong></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#333333;">        前⾯讲的 Token</span> 
 <span style="color:#333333;">，都是</span> 
 <span style="color:#333333;"> Access Token</span> 
 <span style="color:#333333;">，也就是访问资源接⼝时所需要的</span> 
 <span style="color:#333333;"> Token</span> 
 <span style="color:#333333;">，还有另外⼀种 Token，</span> 
 <span style="color:#333333;">Refresh Token</span> 
 <span style="color:#333333;">，通常情况下，</span> 
 <span style="color:#333333;">Refresh Token </span> 
 <span style="color:#333333;">的有效期会⽐较⻓，⽽</span> 
 <span style="color:#333333;"> Access Token </span> 
 <span style="color:#333333;">的有效期⽐较短，当 Access Token </span> 
 <span style="color:#333333;">由于过期⽽失效时，使⽤</span> 
 <span style="color:#333333;"> Refresh Token </span> 
 <span style="color:#333333;">就可以获取到新的</span> 
 <span style="color:#333333;">Access Token</span> 
 <span style="color:#333333;">，如果 Refresh Token </span> 
 <span style="color:#333333;">也失效了，⽤户就只能重新登录了。 </span> 
</div> 
<div></div> 
<div> 
 <span style="color:#333333;">        在 JWT </span> 
 <span style="color:#333333;">的实践中，引⼊</span> 
 <span style="color:#333333;"> Refresh Token</span> 
 <span style="color:#333333;">，将会话管理流程改进如下。 </span> 
</div> 
<ul><li><span style="color:#333333;">客户端使⽤⽤户名密码进⾏认证 </span></li><li><span style="color:#333333;">服务端⽣成有效时间较短的</span><span style="color:#333333;"> Access Token</span><span style="color:#333333;">（例如</span><span style="color:#333333;"> 10 </span><span style="color:#333333;">分钟），和有效时间较⻓的</span><span style="color:#333333;"> Refresh </span></li><li><span style="color:#333333;">Token</span><span style="color:#333333;">（例如</span><span style="color:#333333;"> 7 </span><span style="color:#333333;">天） </span></li><li><span style="color:#333333;">客户端访问需要认证的接⼝时，携带</span><span style="color:#333333;"> Access Token </span></li><li><span style="color:#333333;">如果</span><span style="color:#333333;"> Access Token </span><span style="color:#333333;">没有过期，服务端鉴权后返回给客户端需要的数据 </span></li><li><span style="color:#333333;">如果携带</span><span style="color:#333333;"> Access Token </span><span style="color:#333333;">访问需要认证的接⼝时鉴权失败（例如返回</span><span style="color:#333333;"> 401 </span><span style="color:#333333;">错误），则客户端使⽤ </span></li><li><span style="color:#333333;">Refresh Token </span><span style="color:#333333;">向刷新接⼝申请新的</span><span style="color:#333333;"> Access Token </span></li><li><span style="color:#333333;">如果</span><span style="color:#333333;"> Refresh Token </span><span style="color:#333333;">没有过期，服务端向客户端下发新的</span><span style="color:#333333;"> Access Token </span></li><li><span style="color:#333333;">客户端使⽤新的</span><span style="color:#333333;"> Access Token </span><span style="color:#333333;">访问需要认证的接⼝</span></li></ul> 
<p><img alt="" height="732" src="https://images2.imgbox.com/f1/b2/hqlGkuG6_o.png" width="676"></p> 
<div> 
 <span style="color:#333333;">后端需要对外提供⼀个刷新</span> 
 <span style="color:#333333;">Token</span> 
 <span style="color:#333333;">的接⼝，前端需要实现⼀个当</span> 
 <span style="color:#333333;">Access Token</span> 
 <span style="color:#333333;">过期时⾃动请求刷新 </span> 
</div> 
<div> 
 <span style="color:#333333;">Token</span> 
 <span style="color:#333333;">接⼝获取新</span> 
 <span style="color:#333333;">Access Token</span> 
 <span style="color:#333333;">的拦截器。</span> 
</div> 
<p></p> 
<div> 
 <span style="color:#333333;"><strong>gin</strong></span> 
 <span style="color:#333333;"><strong>框架使⽤</strong></span> 
 <span style="color:#333333;"><strong>jwt</strong></span> 
</div> 
<p><a href="https://www.liwenzhou.com/posts/Go/jwt_in_gin/" rel="nofollow" title="在gin框架中使用JWT | 李文周的博客 (liwenzhou.com)">在gin框架中使用JWT | 李文周的博客 (liwenzhou.com)</a></p> 
<div> 
 <span style="color:#333333;"><strong>鉴权中间件开发</strong></span> 
</div> 
<div> 
 <pre><code class="language-Go">const (
 ContextUserIDKey = "userID"
)
var (
 ErrorUserNotLogin = errors.New("当前⽤户未登录")
)
⽣成access token和refresh token
// JWTAuthMiddleware 基于JWT的认证中间件
func JWTAuthMiddleware() func(c *gin.Context) {
 return func(c *gin.Context) {
 // 客户端携带Token有三种⽅式 1.放在请求头 2.放在请求体 3.放在URI
 // 这⾥假设Token放在Header的中
 // 这⾥的具体实现⽅式要依据你的实际业务情况决定
 authHeader := c.Request.Header.Get("Auth")
 if authHeader == "" {
 ResponseErrorWithMsg(c, CodeInvalidToken, "请求头缺少Auth Token")
 c.Abort()
 return
 }
 mc, err := utils.ParseToken(authHeader)
 if err != nil {
 ResponseError(c, CodeInvalidToken)
 c.Abort()
 return
 }
 // 将当前请求的username信息保存到请求的上下⽂c上
 c.Set(ContextUserIDKey, mc.UserID)
 c.Next() // 后续的处理函数可以⽤过c.Get("userID")来获取当前请求的⽤户信息
 }
}</code></pre> 
 <div> 
  <span style="color:#333333;"><strong>⽣成</strong></span> 
  <span style="color:#333333;"><strong>access token</strong></span> 
  <span style="color:#333333;"><strong>和</strong></span> 
  <span style="color:#333333;"><strong>refresh token</strong></span> 
 </div> 
</div> 
<pre><code class="language-Go">// GenToken ⽣成access token 和 refresh token
func GenToken(userID int64) (aToken, rToken string, err error) {
 // 创建⼀个我们⾃⼰的声明
 c := MyClaims{
 userID, // ⾃定义字段
 jwt.StandardClaims{
 ExpiresAt: time.Now().Add(TokenExpireDuration).Unix(), // 过期时间
 Issuer: "bluebell", // 签发⼈
 },
 }
 // 加密并获得完整的编码后的字符串token
 aToken, err = jwt.NewWithClaims(jwt.SigningMethodHS256,
c).SignedString(mySecret)
 // refresh token 不需要存任何⾃定义数据
 rToken, err = jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.StandardClaims{
 ExpiresAt: time.Now().Add(time.Second * 30).Unix(), // 过期时间
 Issuer: "bluebell", // 签发⼈
 }).SignedString(mySecret)
 // 使⽤指定的secret签名并获得完整的编码后的字符串token
 return
}</code></pre> 
<div> 
 <span style="color:#333333;"><strong>解析</strong></span> 
 <span style="color:#333333;"><strong>access token</strong></span> 
 <pre><code class="language-Go">// ParseToken 解析JWT
func ParseToken(tokenString string) (claims *MyClaims, err error) {
 // 解析token
 var token *jwt.Token
 claims = new(MyClaims)
 token, err = jwt.ParseWithClaims(tokenString, claims, keyFunc)
 if err != nil {
 return
 }
 if !token.Valid { // 校验token
 err = errors.New("invalid token")
 }
 return
}</code></pre> 
 <div> 
  <span style="color:#333333;"><strong>refresh token</strong></span> 
  <pre><code class="language-Go">// RefreshToken 刷新AccessToken
func RefreshToken(aToken, rToken string) (newAToken, newRToken string, err
error) {
 // refresh token⽆效直接返回
 if _, err = jwt.Parse(rToken, keyFunc); err != nil {
 return
 }
 // 从旧access token中解析出claims数据
 var claims MyClaims
 _, err = jwt.ParseWithClaims(aToken, &amp;claims, keyFunc)
 v, _ := err.(*jwt.ValidationError)
 // 当access token是过期错误 并且 refresh token没有过期时就创建⼀个新的access token
 if v.Errors == jwt.ValidationErrorExpired {
 return GenToken(claims.UserID)
 }
 return
}</code></pre> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9ae50fb475bbdec51b1ec29eb4fcb014/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">web ide分享</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/405751504767999c2e74ecc526dae2ba/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Nginx】Nginx双机热备</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>