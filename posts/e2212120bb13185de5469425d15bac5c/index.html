<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《算法4》最短路径之Dijkstra与Bellman-Ford算法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《算法4》最短路径之Dijkstra与Bellman-Ford算法" />
<meta property="og:description" content="基本数据结构 在本篇文章中将要记录，在加权有向图中的单源最短路径的两个主要算法，所以首先介绍有向边以及加权有向图这两种关键的数据结构，这里的两种数据结构和《算法4》最小生成树之Prim与Kruskal算法中的边以及加权无向图的数据结构很类似，大致看一下就行。 下面是有向边的数据结构：
public class DirectedEdge { private final int v; private final int w; private final double weight; public DirectedEdge(int v, int w, double weight){ this.v = v; this.w = w; this.weight = weight; } public double weight(){ return weight; } public int from (){ return v; } public int to(){ return w; } public String toString(){ return String.format(&#34;%d-&gt;%d %.2f&#34;, v,w,weight); } } 下面是加权有向图的数据结构：
public class EdgeWeightedDigraph { private final int V; private int E; private Bag&lt;DirectedEdge&gt;[] adj; public EdgeWeightedDigraph(int V){ this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e2212120bb13185de5469425d15bac5c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-12-03T17:51:20+08:00" />
<meta property="article:modified_time" content="2017-12-03T17:51:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《算法4》最短路径之Dijkstra与Bellman-Ford算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="基本数据结构">基本数据结构</h2> 
<p>在本篇文章中将要记录，在加权有向图中的单源最短路径的两个主要算法，所以首先介绍有向边以及加权有向图这两种关键的数据结构，这里的两种数据结构和<a href="http://blog.csdn.net/leonliu1995/article/details/78634015" target="_blank" rel="noopener noreferrer">《算法4》最小生成树之Prim与Kruskal算法</a>中的边以及加权无向图的数据结构很类似，大致看一下就行。 <br> 下面是有向边的数据结构：</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectedEdge</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> v;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> w;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">double</span> weight;

    <span class="hljs-keyword">public</span> <span class="hljs-title">DirectedEdge</span>(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span> w, <span class="hljs-keyword">double</span> weight){
        <span class="hljs-keyword">this</span>.v = v;
        <span class="hljs-keyword">this</span>.w = w;
        <span class="hljs-keyword">this</span>.weight = weight;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">weight</span>(){
        <span class="hljs-keyword">return</span> weight;
    }

    <span class="hljs-keyword">public</span>  <span class="hljs-keyword">int</span> <span class="hljs-title">from</span> (){
        <span class="hljs-keyword">return</span> v;
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">to</span>(){
        <span class="hljs-keyword">return</span> w;
    }


    <span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span>(){
        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">"%d-&gt;%d  %.2f"</span>, v,w,weight);
    }


}</code></pre> 
<p>下面是加权有向图的数据结构：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> EdgeWeightedDigraph {
    <span class="hljs-keyword">private</span> final <span class="hljs-keyword">int</span> V;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> E;
    <span class="hljs-keyword">private</span> Bag&lt;DirectedEdge&gt;[] adj;

    <span class="hljs-keyword">public</span> <span class="hljs-title">EdgeWeightedDigraph</span>(<span class="hljs-keyword">int</span> V){
        <span class="hljs-keyword">this</span>.V = V;
        <span class="hljs-keyword">this</span>.E = <span class="hljs-number">0</span>;
        adj = (Bag&lt;DirectedEdge&gt;[]) <span class="hljs-keyword">new</span> Bag[V];
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v&lt;V;v++){
            adj[v] = <span class="hljs-keyword">new</span> Bag&lt;DirectedEdge&gt;();
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-title">EdgeWeightedDigraph</span>(In <span class="hljs-keyword">in</span>){
        <span class="hljs-keyword">this</span>(<span class="hljs-keyword">in</span>.readInt());
        <span class="hljs-keyword">int</span> E = <span class="hljs-keyword">in</span>.readInt();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;E;i++){
            <span class="hljs-keyword">int</span> v = <span class="hljs-keyword">in</span>.readInt();
            <span class="hljs-keyword">int</span> w = <span class="hljs-keyword">in</span>.readInt();
            Double weight = <span class="hljs-keyword">in</span>.readDouble();
            DirectedEdge e= <span class="hljs-keyword">new</span> DirectedEdge(v, w, weight);
            addEdge(e);
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">V</span>(){<!-- --><span class="hljs-keyword">return</span> V;}
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">E</span>(){<!-- --><span class="hljs-keyword">return</span> E;}

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addEdge</span>(DirectedEdge e){
        <span class="hljs-keyword">int</span> v = e.<span class="hljs-keyword">from</span>();
        adj[v].add(e);
        E++;
    }
    <span class="hljs-keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="hljs-title">adj</span>(<span class="hljs-keyword">int</span> v){
        <span class="hljs-keyword">return</span> adj[v];
    }

    <span class="hljs-keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="hljs-title">edges</span>(){
        Bag&lt;DirectedEdge&gt; bag = <span class="hljs-keyword">new</span> Bag&lt;DirectedEdge&gt;();
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> v=<span class="hljs-number">0</span>;v&lt;V;v++)
            <span class="hljs-keyword">for</span> (DirectedEdge e:adj[v])
                 bag.add(e);
        <span class="hljs-keyword">return</span> bag;
    }


}</code></pre> 
<h2 id="最短路径基本原理">最短路径基本原理</h2> 
<p>对于一幅加权有向图，从源点开始到所有顶点的所有最短路径构成了一个最短路径树。我们在算法中维护了两个关键的数据结构,edgeTo[]代表在最短路径树中指向每个顶点的边， distTo[]代表从源到某个顶点的“距离”也就是所经过的最短路径边的权重之和。</p> 
<p>下面介绍一种关键的技术：<strong>“放松”</strong>，可以参考下图： <br> <img title="" alt="这里写图片描述" src="https://images2.imgbox.com/5d/17/dietlqHX_o.png"></p> 
<p>所谓松弛就是对于一条边v-&gt;w，此时w到源点的最短路径为distTo[w]，这个值不管是不是真的，目前来看是最优值，然后现在如果distTo[v]+e.weight()&gt;distTo[w]那么就证明v-&gt;w这条边一定不可能在最短路径树里面，那么这条边就可以不用管了。等于的话我们没必要管它。 <br> 如果相反，dist[w]&gt;distTo[v]+e.weoght(),那么就证明我们找到了从源点到达w顶点的一条更短路径，那么就可以更新edgeTo[w]和distTo[w]，以上两种情况分别对应于上图左右两种情况。</p> 
<p><strong>最短路径的最优性条件</strong>：当且仅当对于从v到w的任意一条边e，这些值都满足distTo[w]&lt;=distTo[v]+e.weight()时，他们是最短路径。 <br> 具体的证明在此处略过，证明它并不难。下面我们先看两个主要的算法。</p> 
<h2 id="dijkstra算法">Dijkstra算法</h2> 
<p>其实Dijkstra算法和Prim算法很相似，Prim算法是在横切边中找到权重最小的边加入最小生成树，Dijkstra算法也可以说是在横切边中找权重最小的边。两个算法也都维护了一个索引优先队列，不过一个是存储边的权值，一个存储从源点到该点的路径长度。 所以两个算法完全可以类比，同时加深理解。 <br> 对于Dijkstra索引优先队列pq代表在最小路径树之外的还需要进行放松（这里用的为relax()函数）的边，每次从pq中删除路径长度最小的顶点，其实删除就意味着顶点加入最小路径树，因为它不参与之后的比较了。然后将该顶点相连的所有边进行放松，这一步可能会改变某些已经放松过的顶点的路径值，但是这没有关系，首先对于这样的顶点和它相邻的顶点，以前的放松让它满足distTo[w]&lt;=distTo[v]+e.weight()，这一次的放松只会让distTo[w]更小，那么不等式还是满足的。就这样不断delMin()，当索引优先队列为空的时候，所有的边都松弛过了，同时是所有顶点都在最小路径树中了。 <br> 下面是代码实现：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> DijkstraSP {
    <span class="hljs-keyword">private</span> DirectedEdge[] edgeTo;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span>[] distTo;
    <span class="hljs-keyword">private</span> IndexMinPQ&lt;Double&gt; pq;

    <span class="hljs-keyword">private</span> <span class="hljs-title">DijkstraSP</span>(EdgeWeightedDigraph G, <span class="hljs-keyword">int</span> s){
        edgeTo = <span class="hljs-keyword">new</span> DirectedEdge[G.V()];
        distTo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[G.V()];
        pq = <span class="hljs-keyword">new</span> IndexMinPQ&lt;Double&gt;(G.V());

        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v=<span class="hljs-number">0</span>;v&lt;G.V();v++){
            distTo[v] =Double.POSITIVE_INFINITY;
        }
        distTo[s] =<span class="hljs-number">0.0</span>;

        pq.insert(s, <span class="hljs-number">0.0</span>);
        <span class="hljs-keyword">while</span>(!pq.isEmpty())
            relax(G, pq.delMin());

    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">relax</span>(EdgeWeightedDigraph G, <span class="hljs-keyword">int</span> v){
        <span class="hljs-keyword">for</span> (DirectedEdge e:G.adj(v)){
            <span class="hljs-keyword">int</span> w = e.to();
            <span class="hljs-keyword">if</span> (distTo[w]&gt;distTo[v]+e.weight()){
                distTo[w] = distTo[v] + e.weight();
                edgeTo[w] = e;
                <span class="hljs-keyword">if</span> (pq.contains(w)) pq.change(w, distTo[w]);
                <span class="hljs-keyword">else</span>                pq.insert(w, distTo[w]);
            }
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">distTo</span>(<span class="hljs-keyword">int</span> v){
        <span class="hljs-keyword">return</span> distTo[v];
    }
    <span class="hljs-keyword">public</span> boolean <span class="hljs-title">hasPathTo</span>(<span class="hljs-keyword">int</span> v){
        <span class="hljs-keyword">return</span> distTo[v]&lt;Double.POSITIVE_INFINITY;
    }

    <span class="hljs-keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="hljs-title">pathTo</span>(<span class="hljs-keyword">int</span> v){
        <span class="hljs-keyword">if</span> (!hasPathTo(v)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        Stack&lt;DirectedEdge&gt; path =<span class="hljs-keyword">new</span>  Stack&lt;DirectedEdge&gt;();
        <span class="hljs-keyword">for</span> (DirectedEdge edge = edgeTo[v];edge !=<span class="hljs-keyword">null</span>;edge  =edgeTo[edge.<span class="hljs-keyword">from</span>()])
            path.push(edge);
        <span class="hljs-keyword">return</span> path;

    }

}</code></pre> 
<p>可以看到代码都和Prim很像，时间成本也是相同的都是<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-1-Frame"> 
   
   <span class="math" id="MathJax-Span-1" style="width: 3.48em; display: inline-block;"><span style="width: 2.77em; height: 0px; font-size: 125%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.56em; position: absolute; clip: rect(1.7em, 1000em, 2.92em, -0.44em);"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math; font-style: italic;">E<span style="width: 0.02em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mi" id="MathJax-Span-4" style="font-family: MathJax_Math; font-style: italic;">l</span><span class="mi" id="MathJax-Span-5" style="font-family: MathJax_Math; font-style: italic;">o</span><span class="mi" id="MathJax-Span-6" style="font-family: MathJax_Math; font-style: italic;">g<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mi" id="MathJax-Span-7" style="font-family: MathJax_Math; font-style: italic;">V<span style="width: 0.18em; height: 1px; overflow: hidden; display: inline-block;"></span></span></span><span style="width: 0px; height: 2.56em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.25em; overflow: hidden; vertical-align: -0.32em; border-left-color: currentColor; border-left-width: 0em; border-left-style: solid; display: inline-block;"></span></span> 
  </span><script id="MathJax-Element-1" type="math/tex">ElogV</script>。</p> 
<p>但是Dijkstra算法默认边的权重非负，对于有负权重的边，他是不能给出合理的最短路径的，这时候就要用上另一个算法Bellman-Ford算法。</p> 
<h2 id="bellman-ford算法">Bellman-Ford算法</h2> 
<p><strong>Bellman-Ford算法</strong>：在任意含有V个顶点的加权有向图中给定起点s，从s无法到达任何负权重环，然后将distTo[s]初始化为0，其他初始化为无穷大，以任意顺序放松所有边，重复V轮。</p> 
<p>一个简单的证明可以利用归纳法来证，考虑从s到t的一条最短路径：<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-2-Frame"> 
   
   <span class="math" id="MathJax-Span-8" style="width: 11.01em; display: inline-block;"><span style="width: 8.8em; height: 0px; font-size: 125%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.72em; position: absolute; clip: rect(1.87em, 1000em, 3.04em, -0.42em);"><span class="mrow" id="MathJax-Span-9"><span class="msubsup" id="MathJax-Span-10"><span style="width: 1em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -2.56em; position: absolute; clip: rect(1.71em, 1000em, 2.74em, -0.42em);"><span class="mi" id="MathJax-Span-11" style="font-family: MathJax_Math; font-style: italic;">V<span style="width: 0.18em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 2.56em; display: inline-block;"></span></span><span style="left: 0.56em; top: -2.3em; position: absolute;"><span class="mn" id="MathJax-Span-12" style="font-family: MathJax_Main; font-size: 70.7%;">0</span><span style="width: 0px; height: 2.45em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-13" style="padding-left: 0.27em; font-family: MathJax_Main;">→</span><span class="msubsup" id="MathJax-Span-14" style="padding-left: 0.27em;"><span style="width: 1em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -2.56em; position: absolute; clip: rect(1.71em, 1000em, 2.74em, -0.42em);"><span class="mi" id="MathJax-Span-15" style="font-family: MathJax_Math; font-style: italic;">V<span style="width: 0.18em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 2.56em; display: inline-block;"></span></span><span style="left: 0.56em; top: -2.3em; position: absolute;"><span class="mn" id="MathJax-Span-16" style="font-family: MathJax_Main; font-size: 70.7%;">1</span><span style="width: 0px; height: 2.45em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-17" style="padding-left: 0.27em; font-family: MathJax_Main;">→</span><span class="mo" id="MathJax-Span-18" style="padding-left: 0.27em; font-family: MathJax_Main;">⋯</span><span class="mo" id="MathJax-Span-19" style="padding-left: 0.27em; font-family: MathJax_Main;">→</span><span class="msubsup" id="MathJax-Span-20" style="padding-left: 0.27em;"><span style="width: 1em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -2.56em; position: absolute; clip: rect(1.71em, 1000em, 2.74em, -0.42em);"><span class="mi" id="MathJax-Span-21" style="font-family: MathJax_Math; font-style: italic;">V<span style="width: 0.18em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 2.56em; display: inline-block;"></span></span><span style="left: 0.56em; top: -2.25em; position: absolute;"><span class="mi" id="MathJax-Span-22" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">k</span><span style="width: 0px; height: 2.4em; display: inline-block;"></span></span></span></span></span><span style="width: 0px; height: 2.72em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.19em; overflow: hidden; vertical-align: -0.27em; border-left-color: currentColor; border-left-width: 0em; border-left-style: solid; display: inline-block;"></span></span> 
  </span><script id="MathJax-Element-2" type="math/tex">V_0  \rightarrow V_1 \rightarrow \cdots \rightarrow V_k</script>， 其中<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-3-Frame"> 
   
   <span class="math" id="MathJax-Span-23" style="width: 1.28em; display: inline-block;"><span style="width: 1.01em; height: 0px; font-size: 125%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.34em; position: absolute; clip: rect(1.5em, 1000em, 2.67em, -0.42em);"><span class="mrow" id="MathJax-Span-24"><span class="msubsup" id="MathJax-Span-25"><span style="width: 1em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -2.56em; position: absolute; clip: rect(1.71em, 1000em, 2.74em, -0.42em);"><span class="mi" id="MathJax-Span-26" style="font-family: MathJax_Math; font-style: italic;">V<span style="width: 0.18em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 2.56em; display: inline-block;"></span></span><span style="left: 0.56em; top: -2.3em; position: absolute;"><span class="mn" id="MathJax-Span-27" style="font-family: MathJax_Main; font-size: 70.7%;">0</span><span style="width: 0px; height: 2.45em; display: inline-block;"></span></span></span></span></span><span style="width: 0px; height: 2.34em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.19em; overflow: hidden; vertical-align: -0.27em; border-left-color: currentColor; border-left-width: 0em; border-left-style: solid; display: inline-block;"></span></span> 
  </span><script id="MathJax-Element-3" type="math/tex">V_0</script>等于s，<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-4-Frame"> 
   
   <span class="math" id="MathJax-Span-28" style="width: 1.28em; display: inline-block;"><span style="width: 1.01em; height: 0px; font-size: 125%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.34em; position: absolute; clip: rect(1.5em, 1000em, 2.66em, -0.42em);"><span class="mrow" id="MathJax-Span-29"><span class="msubsup" id="MathJax-Span-30"><span style="width: 1em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -2.56em; position: absolute; clip: rect(1.71em, 1000em, 2.74em, -0.42em);"><span class="mi" id="MathJax-Span-31" style="font-family: MathJax_Math; font-style: italic;">V<span style="width: 0.18em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 2.56em; display: inline-block;"></span></span><span style="left: 0.56em; top: -2.25em; position: absolute;"><span class="mi" id="MathJax-Span-32" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">k</span><span style="width: 0px; height: 2.4em; display: inline-block;"></span></span></span></span></span><span style="width: 0px; height: 2.34em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.18em; overflow: hidden; vertical-align: -0.26em; border-left-color: currentColor; border-left-width: 0em; border-left-style: solid; display: inline-block;"></span></span> 
  </span><script id="MathJax-Element-4" type="math/tex">V_k</script>等于t，首先对于平凡情况，即i=0的情况是显然的，然后假设第i次我们得到了从<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-5-Frame"> 
   
   <span class="math" id="MathJax-Span-33" style="width: 1.28em; display: inline-block;"><span style="width: 1.01em; height: 0px; font-size: 125%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.34em; position: absolute; clip: rect(1.5em, 1000em, 2.67em, -0.42em);"><span class="mrow" id="MathJax-Span-34"><span class="msubsup" id="MathJax-Span-35"><span style="width: 1em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -2.56em; position: absolute; clip: rect(1.71em, 1000em, 2.74em, -0.42em);"><span class="mi" id="MathJax-Span-36" style="font-family: MathJax_Math; font-style: italic;">V<span style="width: 0.18em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 2.56em; display: inline-block;"></span></span><span style="left: 0.56em; top: -2.3em; position: absolute;"><span class="mn" id="MathJax-Span-37" style="font-family: MathJax_Main; font-size: 70.7%;">0</span><span style="width: 0px; height: 2.45em; display: inline-block;"></span></span></span></span></span><span style="width: 0px; height: 2.34em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.19em; overflow: hidden; vertical-align: -0.27em; border-left-color: currentColor; border-left-width: 0em; border-left-style: solid; display: inline-block;"></span></span> 
  </span><script id="MathJax-Element-5" type="math/tex">V_0</script>到<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-6-Frame"> 
   
   <span class="math" id="MathJax-Span-38" style="width: 1.15em; display: inline-block;"><span style="width: 0.9em; height: 0px; font-size: 125%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.34em; position: absolute; clip: rect(1.5em, 1000em, 2.66em, -0.42em);"><span class="mrow" id="MathJax-Span-39"><span class="msubsup" id="MathJax-Span-40"><span style="width: 0.9em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -2.56em; position: absolute; clip: rect(1.71em, 1000em, 2.74em, -0.42em);"><span class="mi" id="MathJax-Span-41" style="font-family: MathJax_Math; font-style: italic;">V<span style="width: 0.18em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 2.56em; display: inline-block;"></span></span><span style="left: 0.56em; top: -2.25em; position: absolute;"><span class="mi" id="MathJax-Span-42" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">i</span><span style="width: 0px; height: 2.4em; display: inline-block;"></span></span></span></span></span><span style="width: 0px; height: 2.34em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.18em; overflow: hidden; vertical-align: -0.26em; border-left-color: currentColor; border-left-width: 0em; border-left-style: solid; display: inline-block;"></span></span> 
  </span><script id="MathJax-Element-6" type="math/tex">V_i</script>的最短路径，那么第i+1次放松之后我们根据前面的最短路径最优性条件，一定有<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-7-Frame"> 
   
   <span class="math" id="MathJax-Span-43" style="width: 26.75em; display: inline-block;"><span style="width: 21.38em; height: 0px; font-size: 125%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.72em; position: absolute; clip: rect(1.81em, 1000em, 3.13em, -0.44em);"><span class="mrow" id="MathJax-Span-44"><span class="mi" id="MathJax-Span-45" style="font-family: MathJax_Math; font-style: italic;">d<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mi" id="MathJax-Span-46" style="font-family: MathJax_Math; font-style: italic;">i</span><span class="mi" id="MathJax-Span-47" style="font-family: MathJax_Math; font-style: italic;">s</span><span class="mi" id="MathJax-Span-48" style="font-family: MathJax_Math; font-style: italic;">t</span><span class="mi" id="MathJax-Span-49" style="font-family: MathJax_Math; font-style: italic;">T<span style="width: 0.12em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mi" id="MathJax-Span-50" style="font-family: MathJax_Math; font-style: italic;">o</span><span class="mo" id="MathJax-Span-51" style="font-family: MathJax_Main;">[</span><span class="msubsup" id="MathJax-Span-52"><span style="width: 1.8em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -2.56em; position: absolute; clip: rect(1.71em, 1000em, 2.74em, -0.42em);"><span class="mi" id="MathJax-Span-53" style="font-family: MathJax_Math; font-style: italic;">V<span style="width: 0.18em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 2.56em; display: inline-block;"></span></span><span style="left: 0.56em; top: -2.3em; position: absolute;"><span class="texatom" id="MathJax-Span-54"><span class="mrow" id="MathJax-Span-55"><span class="mi" id="MathJax-Span-56" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">i</span><span class="mo" id="MathJax-Span-57" style="font-family: MathJax_Main; font-size: 70.7%;">+</span><span class="mn" id="MathJax-Span-58" style="font-family: MathJax_Main; font-size: 70.7%;">1</span></span></span><span style="width: 0px; height: 2.45em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-59" style="font-family: MathJax_Main;">]</span><span class="mo" id="MathJax-Span-60" style="padding-left: 0.27em; font-family: MathJax_Main;">≤</span><span class="mi" id="MathJax-Span-61" style="padding-left: 0.27em; font-family: MathJax_Math; font-style: italic;">d<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mi" id="MathJax-Span-62" style="font-family: MathJax_Math; font-style: italic;">s</span><span class="mi" id="MathJax-Span-63" style="font-family: MathJax_Math; font-style: italic;">t</span><span class="mi" id="MathJax-Span-64" style="font-family: MathJax_Math; font-style: italic;">T<span style="width: 0.12em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mi" id="MathJax-Span-65" style="font-family: MathJax_Math; font-style: italic;">o</span><span class="mo" id="MathJax-Span-66" style="font-family: MathJax_Main;">[</span><span class="msubsup" id="MathJax-Span-67"><span style="width: 0.9em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -2.56em; position: absolute; clip: rect(1.71em, 1000em, 2.74em, -0.42em);"><span class="mi" id="MathJax-Span-68" style="font-family: MathJax_Math; font-style: italic;">V<span style="width: 0.18em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 2.56em; display: inline-block;"></span></span><span style="left: 0.56em; top: -2.25em; position: absolute;"><span class="mi" id="MathJax-Span-69" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">i</span><span style="width: 0px; height: 2.4em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-70" style="font-family: MathJax_Main;">]</span><span class="mo" id="MathJax-Span-71" style="padding-left: 0.22em; font-family: MathJax_Main;">+</span><span class="mi" id="MathJax-Span-72" style="padding-left: 0.22em; font-family: MathJax_Math; font-style: italic;">e</span><span class="mo" id="MathJax-Span-73" style="font-family: MathJax_Main;">(</span><span class="msubsup" id="MathJax-Span-74"><span style="width: 0.9em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -2.56em; position: absolute; clip: rect(1.71em, 1000em, 2.74em, -0.42em);"><span class="mi" id="MathJax-Span-75" style="font-family: MathJax_Math; font-style: italic;">V<span style="width: 0.18em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 2.56em; display: inline-block;"></span></span><span style="left: 0.56em; top: -2.25em; position: absolute;"><span class="mi" id="MathJax-Span-76" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">i</span><span style="width: 0px; height: 2.4em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-77" style="padding-left: 0.27em; font-family: MathJax_Main;">→</span><span class="msubsup" id="MathJax-Span-78" style="padding-left: 0.27em;"><span style="width: 1.8em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -2.56em; position: absolute; clip: rect(1.71em, 1000em, 2.74em, -0.42em);"><span class="mi" id="MathJax-Span-79" style="font-family: MathJax_Math; font-style: italic;">V<span style="width: 0.18em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 2.56em; display: inline-block;"></span></span><span style="left: 0.56em; top: -2.3em; position: absolute;"><span class="texatom" id="MathJax-Span-80"><span class="mrow" id="MathJax-Span-81"><span class="mi" id="MathJax-Span-82" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">i</span><span class="mo" id="MathJax-Span-83" style="font-family: MathJax_Main; font-size: 70.7%;">+</span><span class="mn" id="MathJax-Span-84" style="font-family: MathJax_Main; font-size: 70.7%;">1</span></span></span><span style="width: 0px; height: 2.45em; display: inline-block;"></span></span></span></span><span class="mo" id="MathJax-Span-85" style="font-family: MathJax_Main;">)</span><span class="mo" id="MathJax-Span-86" style="font-family: MathJax_Main;">.</span><span class="mi" id="MathJax-Span-87" style="padding-left: 0.16em; font-family: MathJax_Math; font-style: italic;">w</span><span class="mi" id="MathJax-Span-88" style="font-family: MathJax_Math; font-style: italic;">e</span><span class="mi" id="MathJax-Span-89" style="font-family: MathJax_Math; font-style: italic;">i</span><span class="mi" id="MathJax-Span-90" style="font-family: MathJax_Math; font-style: italic;">g<span style="width: 0em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mi" id="MathJax-Span-91" style="font-family: MathJax_Math; font-style: italic;">h</span><span class="mi" id="MathJax-Span-92" style="font-family: MathJax_Math; font-style: italic;">t</span><span class="mo" id="MathJax-Span-93" style="font-family: MathJax_Main;">(</span><span class="mo" id="MathJax-Span-94" style="font-family: MathJax_Main;">)</span></span><span style="width: 0px; height: 2.72em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.38em; overflow: hidden; vertical-align: -0.37em; border-left-color: currentColor; border-left-width: 0em; border-left-style: solid; display: inline-block;"></span></span> 
  </span><script id="MathJax-Element-7" type="math/tex">distTo[V_{i+1}] \le dstTo[V_i] +e(V_i \rightarrow V_{i+1}).weight()</script>，然而从起点到<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-8-Frame"> 
   
   <span class="math" id="MathJax-Span-95" style="width: 1.15em; display: inline-block;"><span style="width: 0.9em; height: 0px; font-size: 125%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.34em; position: absolute; clip: rect(1.5em, 1000em, 2.66em, -0.42em);"><span class="mrow" id="MathJax-Span-96"><span class="msubsup" id="MathJax-Span-97"><span style="width: 0.9em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -2.56em; position: absolute; clip: rect(1.71em, 1000em, 2.74em, -0.42em);"><span class="mi" id="MathJax-Span-98" style="font-family: MathJax_Math; font-style: italic;">V<span style="width: 0.18em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 2.56em; display: inline-block;"></span></span><span style="left: 0.56em; top: -2.25em; position: absolute;"><span class="mi" id="MathJax-Span-99" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">i</span><span style="width: 0px; height: 2.4em; display: inline-block;"></span></span></span></span></span><span style="width: 0px; height: 2.34em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.18em; overflow: hidden; vertical-align: -0.26em; border-left-color: currentColor; border-left-width: 0em; border-left-style: solid; display: inline-block;"></span></span> 
  </span><script id="MathJax-Element-8" type="math/tex">V_i</script>已经是最短路径了而经过这次放松证明<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-9-Frame"> 
   
   <span class="math" id="MathJax-Span-100" style="width: 2.28em; display: inline-block;"><span style="width: 1.81em; height: 0px; font-size: 125%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.34em; position: absolute; clip: rect(1.5em, 1000em, 2.71em, -0.42em);"><span class="mrow" id="MathJax-Span-101"><span class="msubsup" id="MathJax-Span-102"><span style="width: 1.8em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -2.56em; position: absolute; clip: rect(1.71em, 1000em, 2.74em, -0.42em);"><span class="mi" id="MathJax-Span-103" style="font-family: MathJax_Math; font-style: italic;">V<span style="width: 0.18em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 2.56em; display: inline-block;"></span></span><span style="left: 0.56em; top: -2.3em; position: absolute;"><span class="texatom" id="MathJax-Span-104"><span class="mrow" id="MathJax-Span-105"><span class="mi" id="MathJax-Span-106" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">i</span><span class="mo" id="MathJax-Span-107" style="font-family: MathJax_Main; font-size: 70.7%;">+</span><span class="mn" id="MathJax-Span-108" style="font-family: MathJax_Main; font-size: 70.7%;">1</span></span></span><span style="width: 0px; height: 2.45em; display: inline-block;"></span></span></span></span></span><span style="width: 0px; height: 2.34em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.24em; overflow: hidden; vertical-align: -0.32em; border-left-color: currentColor; border-left-width: 0em; border-left-style: solid; display: inline-block;"></span></span> 
  </span><script id="MathJax-Element-9" type="math/tex">V_{i+1}</script>连接到<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-10-Frame"> 
   
   <span class="math" id="MathJax-Span-109" style="width: 1.15em; display: inline-block;"><span style="width: 0.9em; height: 0px; font-size: 125%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.34em; position: absolute; clip: rect(1.5em, 1000em, 2.66em, -0.42em);"><span class="mrow" id="MathJax-Span-110"><span class="msubsup" id="MathJax-Span-111"><span style="width: 0.9em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -2.56em; position: absolute; clip: rect(1.71em, 1000em, 2.74em, -0.42em);"><span class="mi" id="MathJax-Span-112" style="font-family: MathJax_Math; font-style: italic;">V<span style="width: 0.18em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 2.56em; display: inline-block;"></span></span><span style="left: 0.56em; top: -2.25em; position: absolute;"><span class="mi" id="MathJax-Span-113" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">i</span><span style="width: 0px; height: 2.4em; display: inline-block;"></span></span></span></span></span><span style="width: 0px; height: 2.34em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.18em; overflow: hidden; vertical-align: -0.26em; border-left-color: currentColor; border-left-width: 0em; border-left-style: solid; display: inline-block;"></span></span> 
  </span><script id="MathJax-Element-10" type="math/tex">V_i</script>是距离最短的,那么从s到<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-11-Frame"> 
   
   <span class="math" id="MathJax-Span-114" style="width: 2.28em; display: inline-block;"><span style="width: 1.81em; height: 0px; font-size: 125%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.34em; position: absolute; clip: rect(1.5em, 1000em, 2.71em, -0.42em);"><span class="mrow" id="MathJax-Span-115"><span class="msubsup" id="MathJax-Span-116"><span style="width: 1.8em; height: 0px; display: inline-block; position: relative;"><span style="left: 0em; top: -2.56em; position: absolute; clip: rect(1.71em, 1000em, 2.74em, -0.42em);"><span class="mi" id="MathJax-Span-117" style="font-family: MathJax_Math; font-style: italic;">V<span style="width: 0.18em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span style="width: 0px; height: 2.56em; display: inline-block;"></span></span><span style="left: 0.56em; top: -2.3em; position: absolute;"><span class="texatom" id="MathJax-Span-118"><span class="mrow" id="MathJax-Span-119"><span class="mi" id="MathJax-Span-120" style="font-family: MathJax_Math; font-size: 70.7%; font-style: italic;">i</span><span class="mo" id="MathJax-Span-121" style="font-family: MathJax_Main; font-size: 70.7%;">+</span><span class="mn" id="MathJax-Span-122" style="font-family: MathJax_Main; font-size: 70.7%;">1</span></span></span><span style="width: 0px; height: 2.45em; display: inline-block;"></span></span></span></span></span><span style="width: 0px; height: 2.34em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.24em; overflow: hidden; vertical-align: -0.32em; border-left-color: currentColor; border-left-width: 0em; border-left-style: solid; display: inline-block;"></span></span> 
  </span><script id="MathJax-Element-11" type="math/tex">V_{i+1}</script>也是一条最短路径。这种算法比较慢，需要<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-12-Frame"> 
   
   <span class="math" id="MathJax-Span-123" style="width: 3.81em; display: inline-block;"><span style="width: 3.04em; height: 0px; font-size: 125%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.72em; position: absolute; clip: rect(1.81em, 1000em, 3.13em, -0.43em);"><span class="mrow" id="MathJax-Span-124"><span class="mi" id="MathJax-Span-125" style="font-family: MathJax_Math; font-style: italic;">O</span><span class="mo" id="MathJax-Span-126" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-127" style="font-family: MathJax_Math; font-style: italic;">E<span style="width: 0.02em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mi" id="MathJax-Span-128" style="font-family: MathJax_Math; font-style: italic;">V<span style="width: 0.18em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mo" id="MathJax-Span-129" style="font-family: MathJax_Main;">)</span></span><span style="width: 0px; height: 2.72em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.38em; overflow: hidden; vertical-align: -0.37em; border-left-color: currentColor; border-left-width: 0em; border-left-style: solid; display: inline-block;"></span></span> 
  </span><script id="MathJax-Element-12" type="math/tex">O(EV)</script>的时间成本，实际中很浪费。</p> 
<p>还有一个重要的问题是如果存在负权重环（就是环的所有边的权重加起来为负），那么经过该环的所有顶点的最短路径都是无意义的，所以算法还需要嫩能够检测负权重环，不过这里的算法和我在<a href="http://blog.csdn.net/leonliu1995/article/details/78509599" target="_blank" rel="noopener noreferrer">《算法4》图&amp;深度优先与广度优先算法</a>这篇文章里面检测无环图部分的思想是一样的，这里就不再赘述。</p> 
<p>下面是相关代码:</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BellmanFordSP</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span>[] distTo;
    <span class="hljs-keyword">private</span> DirectedEdge[] edgeTo;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] onQ;
    <span class="hljs-keyword">private</span> Queue&lt;Integer&gt; queue;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> cost;
    <span class="hljs-keyword">private</span> Iterable&lt;DirectedEdge&gt; cycle;

    <span class="hljs-keyword">public</span> <span class="hljs-title">BellmanFordSP</span>(EdgeWeightedDigraph G, <span class="hljs-keyword">int</span> s){
        distTo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">double</span>[G.V()];
        edgeTo = <span class="hljs-keyword">new</span> DirectedEdge[G.V()];
        onQ = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[G.V()];
        queue = <span class="hljs-keyword">new</span> Queue&lt;Integer&gt;();
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v=<span class="hljs-number">0</span>;v&lt;G.V();v++)
            distTo[v] = Double.POSITIVE_INFINITY;
        distTo[s] = <span class="hljs-number">0.0</span>;

        queue.enqueue(s);
        onQ[s] = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">while</span>(!queue.isEmpty() &amp;&amp; !hasNegativeCycle()){
            <span class="hljs-keyword">int</span> v = queue.dequeue();
            onQ [v] =<span class="hljs-keyword">false</span>;
            relax(G, v);
        }

    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">relax</span>(EdgeWeightedDigraph G, <span class="hljs-keyword">int</span> v){
        <span class="hljs-keyword">for</span> (DirectedEdge e:G.adj(v)){
            <span class="hljs-keyword">int</span> w = e.to();
            <span class="hljs-keyword">if</span>(distTo[w] &gt; distTo[v]+e.weight()){
                distTo[w] = distTo[v]+e.weight();
                edgeTo[w] = e;
                <span class="hljs-keyword">if</span>(!onQ[w]){
                    queue.enqueue(w);
                    onQ[w] = <span class="hljs-keyword">true</span>;
                }
            }
            <span class="hljs-keyword">if</span>(cost++ % G.V() ==<span class="hljs-number">0</span>){
                findNegativeCycle();
                <span class="hljs-keyword">if</span> (hasNegativeCycle()) <span class="hljs-keyword">return</span> ;
            }
        }
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">distTo</span>(<span class="hljs-keyword">int</span> v){
        <span class="hljs-keyword">return</span> distTo[v];
    }
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasPathTo</span>(<span class="hljs-keyword">int</span> v){
        <span class="hljs-keyword">return</span> distTo[v]&lt;Double.POSITIVE_INFINITY;
    }

    <span class="hljs-keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="hljs-title">pathTo</span>(<span class="hljs-keyword">int</span> v){
        <span class="hljs-keyword">if</span> (!hasPathTo(v)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;
        Stack&lt;DirectedEdge&gt; path =<span class="hljs-keyword">new</span>  Stack&lt;DirectedEdge&gt;();
        <span class="hljs-keyword">for</span> (DirectedEdge edge = edgeTo[v];edge !=<span class="hljs-keyword">null</span>;edge  =edgeTo[edge.from()])
            path.push(edge);
        <span class="hljs-keyword">return</span> path;

    }

    <span class="hljs-keyword">private</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">findNegativeCycle</span>(){
        <span class="hljs-keyword">int</span> V = edgeTo.length;
        EdgeWeightedDigraph spt=<span class="hljs-keyword">new</span> EdgeWeightedDigraph(V);
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>;v&lt;V; v++)
            <span class="hljs-keyword">if</span> (edgeTo[v] !=<span class="hljs-keyword">null</span>)
                spt.addEdge(edgeTo[v]);
        EdgeWeightedDirectedCycle finderCycle = <span class="hljs-keyword">new</span> EdgeWeightedDirectedCycle(spt);
        cycle =finderCycle.cycle(); 
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNegativeCycle</span>(){
        <span class="hljs-keyword">return</span> cycle != <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="hljs-title">nagativeCycle</span>(){
        <span class="hljs-keyword">return</span> cycle;
    }


}</code></pre> 
<p>上面的代码是基于队列的，从其中关键的循环部分<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-141-Frame"><span class="math" id="MathJax-Span-386"><span class="noError" id="MathJax-Span-387" style="display: inline-block;">while(!queue.isEmpty() &amp;&amp; !hasNegativeCycle())</span></span></span><script id="MathJax-Element-141" type="math/tex">while(!queue.isEmpty() && !hasNegativeCycle())</script>， 可以看出，首先我们要一直运行到队列为空，队列什么时候会有顶点入队？当有顶点的distTo[]值被改变的时候，所以当算法运行结束的时候，所有顶点的路径长都已经是最小值，不能再改了。另一种情况是，我们的算法运行了V轮之后，如果有负权重环的话，队列一定是非空的，所以我们每隔V轮检测一下是不是遇到了负权重环，如果遇到了就退出。</p> 
<p>可以看出Bellman-Ford其实和Dijstra也有一些相似之处。 <br> 下面的代码就是在加权有向图中检测环的代码</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EdgeWeightedDirectedCycle</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] marked;
    <span class="hljs-keyword">private</span> DirectedEdge[] edgeTo;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] onStack;
    <span class="hljs-keyword">private</span> Stack&lt;DirectedEdge&gt; cycle;

    <span class="hljs-keyword">public</span> <span class="hljs-title">EdgeWeightedDirectedCycle</span>(EdgeWeightedDigraph G){
        marked = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[G.V()];
        onStack = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[G.V()];
        edgeTo = <span class="hljs-keyword">new</span> DirectedEdge[G.V()];
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>;v&lt;G.V();v++)
            <span class="hljs-keyword">if</span> (!marked[v]) dfs(G, v);
    }

    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span>(EdgeWeightedDigraph G, <span class="hljs-keyword">int</span> v){
        onStack[v] = <span class="hljs-keyword">true</span>;
        marked[v] = <span class="hljs-keyword">true</span>;
        <span class="hljs-keyword">for</span> (DirectedEdge e:G.adj(v)){
            <span class="hljs-keyword">int</span> w = e.to();
            <span class="hljs-keyword">if</span>(cycle !=<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> ;

            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!marked[w]){
                edgeTo[w] = e;
                dfs(G, w);
            }
            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(onStack[w]){
                cycle = <span class="hljs-keyword">new</span> Stack&lt;DirectedEdge&gt;();
                DirectedEdge f = e;
                <span class="hljs-keyword">while</span>(f.from() !=w){
                    cycle.push(f);
                    f = edgeTo[f.from()];
                }
                cycle.push(f);
                <span class="hljs-keyword">return</span> ;
            }
        }
        onStack[v] =<span class="hljs-keyword">false</span>;
    }

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span>(){
        <span class="hljs-keyword">return</span> cycle!= <span class="hljs-keyword">null</span>;
    }

    <span class="hljs-keyword">public</span> Iterable&lt;DirectedEdge&gt; <span class="hljs-title">cycle</span>(){
        <span class="hljs-keyword">return</span> cycle;
    }

}</code></pre> 
<p>综上，基于队列的Bellman-Ford算法要比原始版快得多基本是<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-208-Frame"> 
   
   <span class="math" id="MathJax-Span-880" style="width: 5.35em; display: inline-block;"><span style="width: 4.26em; height: 0px; font-size: 125%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.72em; position: absolute; clip: rect(1.81em, 1000em, 3.13em, -0.43em);"><span class="mrow" id="MathJax-Span-881"><span class="mi" id="MathJax-Span-882" style="font-family: MathJax_Math; font-style: italic;">O</span><span class="mo" id="MathJax-Span-883" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-884" style="font-family: MathJax_Math; font-style: italic;">V<span style="width: 0.18em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mo" id="MathJax-Span-885" style="padding-left: 0.22em; font-family: MathJax_Main;">+</span><span class="mi" id="MathJax-Span-886" style="padding-left: 0.22em; font-family: MathJax_Math; font-style: italic;">E<span style="width: 0.02em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mo" id="MathJax-Span-887" style="font-family: MathJax_Main;">)</span></span><span style="width: 0px; height: 2.72em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.38em; overflow: hidden; vertical-align: -0.37em; border-left-color: currentColor; border-left-width: 0em; border-left-style: solid; display: inline-block;"></span></span> 
  </span><script id="MathJax-Element-208" type="math/tex">O(V+E)</script>的，但是最坏情况也有<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-209-Frame"> 
   
   <span class="math" id="MathJax-Span-888" style="width: 3.81em; display: inline-block;"><span style="width: 3.04em; height: 0px; font-size: 125%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.72em; position: absolute; clip: rect(1.81em, 1000em, 3.13em, -0.43em);"><span class="mrow" id="MathJax-Span-889"><span class="mi" id="MathJax-Span-890" style="font-family: MathJax_Math; font-style: italic;">O</span><span class="mo" id="MathJax-Span-891" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-892" style="font-family: MathJax_Math; font-style: italic;">V<span style="width: 0.18em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mi" id="MathJax-Span-893" style="font-family: MathJax_Math; font-style: italic;">E<span style="width: 0.02em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mo" id="MathJax-Span-894" style="font-family: MathJax_Main;">)</span></span><span style="width: 0px; height: 2.72em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.38em; overflow: hidden; vertical-align: -0.37em; border-left-color: currentColor; border-left-width: 0em; border-left-style: solid; display: inline-block;"></span></span> 
  </span><script id="MathJax-Element-209" type="math/tex">O(VE)</script>，可是它的适用范围要大得多，可以存在负权重环，还可以检测出负权重环。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/699db740fd28991b8df4c481cabff0e7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Fragment简单介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/79cae317b97a2d4ef65bd518ef83adab/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java 源文件中的中文符号替换成英文符号</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>