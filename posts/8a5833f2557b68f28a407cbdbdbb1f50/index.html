<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MTK6580（Android6.0)-camera 驱动分析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MTK6580（Android6.0)-camera 驱动分析" />
<meta property="og:description" content="一、MTK6580 平台 Camera 驱动整体框架 mtk平台三大件调试中，camera的调试难度最大，问题也就最多，为此特地分析了一下整个camera驱动部分
实现过程，以下为camera驱动框架序列图：
从图中可以看出，整个框架分为三个部分hal部分逻辑调用，kernel层的通用驱动sensorlist.c 和具体IC的驱动
xxxx_mipi_raw.c，kernel起来后不会直接去访问硬件sensor,而是会注册相关的驱动，之后Android系统起来后
会启动相关的服务如：camera_service，在camera服务中会直接去访问hal,kernel驱动，进而操作camera。
为此本文也穿插了部分hal层的调用,至于camera_service后面章节会继续补充。
二、 Camera 驱动的具体实现 ========================HAL 层部分初始调用========================
文件：vendor/mediatek/proprietary/hardware/mtkcam/common/module_hal/devicemgr/CamDeviceManagerBase.cpp
[cpp] view plain copy
int32_t CamDeviceManagerBase:: getNumberOfDevices() { … mi4DeviceNum = enumDeviceLocked(); … } int32_t CamDeviceManagerBase:: getNumberOfDevices() { … mi4DeviceNum = enumDeviceLocked(); ... }文件：vendor/mediatek/proprietary/hardware/mtkcam/legacy/platform/mt6580/devicemgr/CamDeviceManagerImp.cpp
[cpp] view plain copy
int32_t CamDeviceManagerImp:: enumDeviceLocked() { … //—————————————————————————— #if ‘1’==MTKCAM_HAVE_SENSOR_HAL // IHalSensorList*const pHalSensorList = IHalSensorList::get(); size_t const sensorNum = pHalSensorList-&gt;searchSensors(); #endif … return i4DeviceNum; } int32_t CamDeviceManagerImp:: enumDeviceLocked() { … //—————————————————————————— if ‘1’==MTKCAM_HAVE_SENSOR_HAL // IHalSensorList*const pHalSensorList = IHalSensorList::get(); size_t const sensorNum = pHalSensorList-&amp;gt;searchSensors(); endif ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8a5833f2557b68f28a407cbdbdbb1f50/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-15T23:54:05+08:00" />
<meta property="article:modified_time" content="2020-08-15T23:54:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MTK6580（Android6.0)-camera 驱动分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="一mtk6580-平台-camera-驱动整体框架">一、MTK6580 平台 Camera 驱动整体框架</h2> 
<p> </p> 
<p>mtk平台三大件调试中，camera的调试难度最大，问题也就最多，为此特地分析了一下整个camera驱动部分</p> 
<p>实现过程，以下为camera驱动框架序列图：</p> 
<p>      <img alt="" src="https://images2.imgbox.com/bd/f5/WIOF3gVz_o.png"></p> 
<p>从图中可以看出，整个框架分为三个部分hal部分逻辑调用，kernel层的通用驱动sensorlist.c 和具体IC的驱动</p> 
<p>xxxx_mipi_raw.c，kernel起来后不会直接去访问硬件sensor,而是会注册相关的驱动，之后Android系统起来后</p> 
<p>会启动相关的服务如：camera_service，在camera服务中会直接去访问hal,kernel驱动，进而操作camera。</p> 
<p>为此本文也穿插了部分hal层的调用,至于camera_service后面章节会继续补充。</p> 
<h2 id="二-camera-驱动的具体实现"><a name="t1"></a>二、 Camera 驱动的具体实现</h2> 
<p>========================HAL 层部分初始调用========================<br> 文件：vendor/mediatek/proprietary/hardware/mtkcam/common/module_hal/devicemgr/CamDeviceManagerBase.cpp</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>int32_t  </li><li>CamDeviceManagerBase::  </li><li>getNumberOfDevices()  </li><li>{  </li><li>        …  </li><li>        mi4DeviceNum = enumDeviceLocked();  </li><li>      </li><li>        …  </li><li>}  </li></ol> 
<pre><code>int32_t 

CamDeviceManagerBase:: 

getNumberOfDevices() 

{ 

        … 

        mi4DeviceNum = enumDeviceLocked();</code></pre> 
<ul><li> </li></ul> 
<pre><code>    ...
</code></pre> 
<ul><li> </li></ul> 
<p>}文件：vendor/mediatek/proprietary/hardware/mtkcam/legacy/platform/mt6580/devicemgr/CamDeviceManagerImp.cpp</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>int32_t  </li><li>CamDeviceManagerImp::  </li><li>enumDeviceLocked()  </li><li>{  </li><li>    …  </li><li>//——————————————————————————  </li><li>#if ‘1’==MTKCAM_HAVE_SENSOR_HAL  </li><li>    //  </li><li>    IHalSensorList*const pHalSensorList = IHalSensorList::get();  </li><li>    size_t const sensorNum = pHalSensorList-&gt;searchSensors();  </li><li>#endif  </li><li>    …  </li><li>    return  i4DeviceNum;  </li><li>}  </li></ol> 
<pre><code>int32_t 

CamDeviceManagerImp:: 

enumDeviceLocked() 

{ 

    … 

//——————————————————————————</code></pre> 
<p> </p> 
<h2 id="if-1mtkcamhavesensorhal"><a name="t2"></a>if ‘1’==MTKCAM_HAVE_SENSOR_HAL</h2> 
<pre><code>//
IHalSensorList*const pHalSensorList = IHalSensorList::get();
size_t const sensorNum = pHalSensorList-&amp;gt;searchSensors();
</code></pre> 
<h2 id="endif"><a name="t3"></a>endif</h2> 
<pre><code>...
return  i4DeviceNum;
</code></pre> 
<p>}文件：vendor/mediatek/proprietary/hardware/mtkcam/legacy/platform/mt6580/hal/sensor/HalSensorList.cpp</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>MUINT  </li><li>HalSensorList::  </li><li>searchSensors()  </li><li>{  </li><li>    Mutex::Autolock _l(mEnumSensorMutex);  </li><li>    //  </li><li>    MY_LOGD(”searchSensors”);  </li><li>    return  enumerateSensor_Locked();  </li><li>}  </li></ol> 
<pre><code>MUINT 

HalSensorList:: 

searchSensors() 

{ 

    Mutex::Autolock _l(mEnumSensorMutex); 

    // 

    MY_LOGD("searchSensors"); 

    return  enumerateSensor_Locked(); 

}</code></pre> 
<p>文件：vendor/mediatek/proprietary/hardware/mtkcam/legacy/platform/mt6580/hal/sensor/HalSensorList.enumList.cpp</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>MUINT  </li><li>HalSensorList::  </li><li>enumerateSensor_Locked()  </li><li>{  </li><li>    ….  </li><li>  </li><li>  </li><li>    MUINT halSensorDev = SENSOR_DEV_NONE;  </li><li>    NSFeature::SensorInfoBase* pSensorInfo ;  </li><li>  </li><li>  </li><li>    SensorDrv <em>const pSensorDrv = SensorDrv::get();  </em></li><li>    SeninfDrv const pSeninfDrv = SeninfDrv::createInstance();  </li><li>      </li><li>    int const iSensorsList = pSensorDrv-&gt;impSearchSensor(NULL);  </li><li>  </li><li>  </li><li>    ….  </li><li>}  </li></ol> 
<pre><code>MUINT 

HalSensorList:: 

enumerateSensor_Locked() 

{ 

    ….</code></pre> 
<p> </p> 
<pre><code>MUINT halSensorDev = SENSOR_DEV_NONE;
NSFeature::SensorInfoBase* pSensorInfo ;


SensorDrv *const pSensorDrv = SensorDrv::get();
SeninfDrv *const pSeninfDrv = SeninfDrv::createInstance();

int const iSensorsList = pSensorDrv-&amp;gt;impSearchSensor(NULL);


....
</code></pre> 
<p>}文件：vendor/mediatek/proprietary/hardware/mtkcam/legacy/platform/mt6580/hal/sensor/imgsensor_drv.cpp</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>MINT32  </li><li>ImgSensorDrv::impSearchSensor(pfExIdChk pExIdChkCbf)  </li><li>{  </li><li>    ….  </li><li>  </li><li>  </li><li>    GetSensorInitFuncList(&amp;m_pstSensorInitFunc);  </li><li>  </li><li>  </li><li>    LOG_MSG(”SENSOR search start \n”);  </li><li>  </li><li>  </li><li>    sprintf(cBuf,”/dev/%s”,CAMERA_HW_DEVNAME);  </li><li>    m_fdSensor = ::open(cBuf, O_RDWR);  </li><li>  </li><li>  </li><li>    ……  </li><li>      </li><li>        for (i = 0; i &lt; MAX_NUM_OF_SUPPORT_SENSOR; i++) {  </li><li>            ….  </li><li>            err = ioctl(m_fdSensor, KDIMGSENSORIOC_X_SET_DRIVER,&amp;id[KDIMGSENSOR_INVOKE_DRIVER_0] );  </li><li>            …  </li><li>            err = ioctl(m_fdSensor, KDIMGSENSORIOC_T_CHECK_IS_ALIVE);  </li><li>  </li><li>  </li><li>    ……  </li><li>}  </li></ol> 
<pre><code>MINT32 

ImgSensorDrv::impSearchSensor(pfExIdChk pExIdChkCbf) 

{ 

    ….</code></pre> 
<ul><li> </li></ul> 
<pre><code>GetSensorInitFuncList(&amp;amp;m_pstSensorInitFunc);


LOG_MSG("SENSOR search start \n");


sprintf(cBuf,"/dev/%s",CAMERA_HW_DEVNAME);
m_fdSensor = ::open(cBuf, O_RDWR);


......

    for (i = 0; i &amp;lt; MAX_NUM_OF_SUPPORT_SENSOR; i++) {
        ....
        err = ioctl(m_fdSensor, KDIMGSENSORIOC_X_SET_DRIVER,&amp;amp;id[KDIMGSENSOR_INVOKE_DRIVER_0] );
        ...
        err = ioctl(m_fdSensor, KDIMGSENSORIOC_T_CHECK_IS_ALIVE);


......
</code></pre> 
<p>}GetSensorInitFuncList的实现<br> 文件：vendor/mediatek/proprietary/custom/mt6580/hal/imgsensor_src/sensorlist.cpp</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>UINT32 GetSensorInitFuncList(MSDK_SENSOR_INIT_FUNCTION_STRUCT **ppSensorList)  </li><li>{  </li><li>    if (NULL == ppSensorList) {  </li><li>        ALOGE(”ERROR: NULL pSensorList\n”);  </li><li>        return MHAL_UNKNOWN_ERROR;  </li><li>    }  </li><li>    *ppSensorList = &amp;SensorList[0];  </li><li>    return MHAL_NO_ERROR;  </li><li>}   </li></ol> 
<pre><code>UINT32 GetSensorInitFuncList(MSDK_SENSOR_INIT_FUNCTION_STRUCT **ppSensorList) 

{ 

    if (NULL == ppSensorList) { 

        ALOGE("ERROR: NULL pSensorList\n"); 

        return MHAL_UNKNOWN_ERROR; 

    } 

    *ppSensorList = &amp;SensorList[0]; 

    return MHAL_NO_ERROR; 

} </code></pre> 
<p>Sensor 列表的定义如下：</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>MSDK_SENSOR_INIT_FUNCTION_STRUCT SensorList[] =  </li><li>{  </li><li>//xc add camera start  </li><li>#if defined(GC2365MIPI_RAW)  </li><li>    RAW_INFO(GC2365MIPI_SENSOR_ID, SENSOR_DRVNAME_GC2365MIPI_RAW, NULL),  </li><li>#endif  </li><li>  </li><li>  </li><li>#if defined(GC2355_MIPI_RAW_BAIKANG_M8112)  </li><li>    RAW_INFO(GC2355_SENSOR_ID, SENSOR_DRVNAME_GC2355_MIPI_RAW,NULL),  </li><li>#endif  </li><li>….  </li><li>}  </li></ol> 
<pre><code>MSDK_SENSOR_INIT_FUNCTION_STRUCT SensorList[] = 

{ 

//xc add camera start</code></pre> 
<ul><li> </li></ul> 
<h2 id="if-definedgc2365mipiraw"><a name="t4"></a>if defined(GC2365MIPI_RAW)</h2> 
<pre><code>RAW_INFO(GC2365MIPI_SENSOR_ID, SENSOR_DRVNAME_GC2365MIPI_RAW, NULL),
</code></pre> 
<ul><li> </li></ul> 
<h2 id="endif-1"><a name="t5"></a>endif</h2> 
<h2 id="if-definedgc2355mipirawbaikangm8112"><a name="t6"></a>if defined(GC2355_MIPI_RAW_BAIKANG_M8112)</h2> 
<pre><code>RAW_INFO(GC2355_SENSOR_ID, SENSOR_DRVNAME_GC2355_MIPI_RAW,NULL),
</code></pre> 
<ul><li>1</li></ul> 
<h2 id="endif-2"><a name="t7"></a>endif</h2> 
<p>….<br> }获取sensor列表后，紧接着通过：<br> err = ioctl(m_fdSensor, KDIMGSENSORIOC_X_SET_DRIVER,&amp;id[KDIMGSENSOR_INVOKE_DRIVER_0] );<br> err = ioctl(m_fdSensor, KDIMGSENSORIOC_T_CHECK_IS_ALIVE);<br> 访问kernel层的数据<br> ====================== Kernel 层驱动的实现 ========================<br> 1. 针对前后摄注册platform 设备和驱动<br> 文件：kernel-3.18/drivers/misc/mediatek/imgsensor/src/mt6580/kd_sensorlist.c</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>static int __init CAMERA_HW_i2C_init(void)  </li><li>{  </li><li>    ….  </li><li>      </li><li>  </li><li>  </li><li>    if (platform_driver_register(&amp;g_stCAMERA_HW_Driver)) //注册主摄platform 驱动  </li><li>    if (platform_driver_register(&amp;g_stCAMERA_HW_Driver2)) //注册副摄platform 驱动  </li><li>  </li><li>  </li><li>    ….  </li><li>    return 0;  </li><li>}  </li></ol> 
<pre><code>static int __init CAMERA_HW_i2C_init(void) 

{ 

    ….</code></pre> 
<ul><li> </li></ul> 
<pre><code>if (platform_driver_register(&amp;amp;g_stCAMERA_HW_Driver)) //注册主摄platform 驱动
if (platform_driver_register(&amp;amp;g_stCAMERA_HW_Driver2)) //注册副摄platform 驱动


....
return 0;
</code></pre> 
<p>}主摄平台驱动的定义：</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>#ifdef CONFIG_OF  </li><li>static const struct of_device_id CAMERA_HW_of_ids[] = {  </li><li>    {.compatible = ”mediatek,camera_hw”,},  //主摄匹配规则  </li><li>    {}  </li><li>};  </li><li>#endif  </li><li>  </li><li>  </li><li>static struct platform_driver g_stCAMERA_HW_Driver = {  </li><li>    .probe = CAMERA_HW_probe,  </li><li>    .remove = CAMERA_HW_remove,  </li><li>    .suspend = CAMERA_HW_suspend,  </li><li>    .resume = CAMERA_HW_resume,  </li><li>    .driver = {  </li><li>           .name = ”image_sensor”,  </li><li>           .owner = THIS_MODULE,  </li><li>#ifdef CONFIG_OF  </li><li>           .of_match_table = CAMERA_HW_of_ids,  </li><li>#endif  </li><li>           }  </li><li>};  </li></ol> 
<pre><code>#ifdef CONFIG_OF 

static const struct of_device_id CAMERA_HW_of_ids[] = { 

    {.compatible = “mediatek,camera_hw”,},  //主摄匹配规则 

    {} 

};</code></pre> 
<ul><li> </li></ul> 
<h2 id="endif-3"><a name="t8"></a>endif</h2> 
<p>static struct platform_driver g_stCAMERA_HW_Driver = {<!-- --><br> .probe = CAMERA_HW_probe,<br> .remove = CAMERA_HW_remove,<br> .suspend = CAMERA_HW_suspend,<br> .resume = CAMERA_HW_resume,<br> .driver = {<!-- --><br> .name = “image_sensor”,<br> .owner = THIS_MODULE,</p> 
<h2 id="ifdef-configof"><a name="t9"></a>ifdef CONFIG_OF</h2> 
<pre><code>       .of_match_table = CAMERA_HW_of_ids,
</code></pre> 
<ul><li> </li></ul> 
<h2 id="endif-4"><a name="t10"></a>endif</h2> 
<pre><code>       }
</code></pre> 
<ul><li> </li></ul> 
<p>};副摄平台驱动的定义：</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>#ifdef CONFIG_OF  </li><li>static const struct of_device_id CAMERA_HW2_of_ids[] = {  </li><li>    {.compatible = ”mediatek,camera_hw2”,},//副摄匹配规则  </li><li>    {}  </li><li>};  </li><li>#endif  </li><li>  </li><li>  </li><li>static struct platform_driver g_stCAMERA_HW_Driver2 = {  </li><li>    .probe = CAMERA_HW_probe2,  </li><li>    .remove = CAMERA_HW_remove2,  </li><li>    .suspend = CAMERA_HW_suspend2,  </li><li>    .resume = CAMERA_HW_resume2,  </li><li>    .driver = {  </li><li>           .name = ”image_sensor_bus2”,  </li><li>           .owner = THIS_MODULE,  </li><li>#ifdef CONFIG_OF  </li><li>           .of_match_table = CAMERA_HW2_of_ids,  </li><li>#endif  </li><li>  </li><li>  </li><li>    }  </li><li>};  </li></ol> 
<pre><code>#ifdef CONFIG_OF 

static const struct of_device_id CAMERA_HW2_of_ids[] = { 

    {.compatible = “mediatek,camera_hw2”,},//副摄匹配规则 

    {} 

};</code></pre> 
<p> </p> 
<h2 id="endif-5"><a name="t11"></a>endif</h2> 
<p>static struct platform_driver g_stCAMERA_HW_Driver2 = {<!-- --><br> .probe = CAMERA_HW_probe2,<br> .remove = CAMERA_HW_remove2,<br> .suspend = CAMERA_HW_suspend2,<br> .resume = CAMERA_HW_resume2,<br> .driver = {<!-- --><br> .name = “image_sensor_bus2”,<br> .owner = THIS_MODULE,</p> 
<h2 id="ifdef-configof-1"><a name="t12"></a>ifdef CONFIG_OF</h2> 
<pre><code>       .of_match_table = CAMERA_HW2_of_ids,
</code></pre> 
<ul><li> </li></ul> 
<h2 id="endif-6"><a name="t13"></a>endif</h2> 
<pre><code>}
</code></pre> 
<ul><li> </li></ul> 
<p>};主副摄cam在dts中定义设备信息：</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>kd_camera_hw1:kd_camera_hw1@15008000 {  </li><li>    compatible = ”mediatek,camera_hw”; //这里必须和主摄一致  </li><li>    reg = &lt;0x15008000 0x1000&gt;;  /<em> SENINF_ADDR </em>/  </li><li>    vcama-supply = &lt;&amp;mt_pmic_vcama_ldo_reg&gt;;  </li><li>    vcamd-supply = &lt;&amp;mt_pmic_vcamd_ldo_reg&gt;;  </li><li>    vcamaf-supply = &lt;&amp;mt_pmic_vcamaf_ldo_reg&gt;;  </li><li>    vcamio-supply = &lt;&amp;mt_pmic_vcamio_ldo_reg&gt;;  </li><li>  </li><li>  </li><li>};  </li><li>kd_camera_hw2:kd_camera_hw2@15008000 {  </li><li>    compatible = ”mediatek,camera_hw2”; //这里必须和副摄一致  </li><li>    reg = &lt;0x15008000 0x1000&gt;;  /<em> SENINF_ADDR </em>/  </li><li>};  </li></ol> 
<pre><code>kd_camera_hw1:kd_camera_hw1@15008000 { 

    compatible = “mediatek,camera_hw”; //这里必须和主摄一致 

    reg = &lt;0x15008000 0x1000&gt;;  /* SENINF_ADDR */ 

    vcama-supply = &lt;&amp;mt_pmic_vcama_ldo_reg&gt;; 

    vcamd-supply = &lt;&amp;mt_pmic_vcamd_ldo_reg&gt;; 

    vcamaf-supply = &lt;&amp;mt_pmic_vcamaf_ldo_reg&gt;; 

    vcamio-supply = &lt;&amp;mt_pmic_vcamio_ldo_reg&gt;;</code></pre> 
<p> </p> 
<p>};<br> kd_camera_hw2:kd_camera_hw2@15008000 {<!-- --><br> compatible = “mediatek,camera_hw2”; //这里必须和副摄一致<br> reg = &lt;0x15008000 0x1000&gt;; /* SENINF_ADDR */<br> };       当内核启动后，会解析dts编译生成的dtb文件，注册里面定义的device,如果和驱动中定义id一致，则挂载启动。</p> 
<p>上面注册了两个platform 驱动g_stCAMERA_HW_Driver，g_stCAMERA_HW_Driver2，如果匹配成功会调用各自的</p> 
<p>probe函数CAMERA_HW_probe，CAMERA_HW_probe2</p> 
<p>2. 平台probe 函数的实现<br> 主摄probe，CAMERA_HW_probe的实现如下：</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>static int CAMERA_HW_probe(struct platform_device *pdev)  </li><li>{  </li><li>#if !defined(CONFIG_MTK_LEGACY)  </li><li>    mtkcam_gpio_init(pdev);  </li><li>    mtkcam_pin_mux_init(pdev);  </li><li>#endif  </li><li>    return i2c_add_driver(&amp;CAMERA_HW_i2c_driver);  </li><li>}  </li></ol> 
<pre><code>static int CAMERA_HW_probe(struct platform_device *pdev) 

{<!-- --></code></pre> 
<ul><li>1</li></ul> 
<p> </p> 
<h2 id="if-definedconfigmtklegacy"><a name="t14"></a>if !defined(CONFIG_MTK_LEGACY)</h2> 
<pre><code>mtkcam_gpio_init(pdev);
mtkcam_pin_mux_init(pdev);
</code></pre> 
<h2 id="endif-7"><a name="t15"></a>endif</h2> 
<pre><code>return i2c_add_driver(&amp;amp;CAMERA_HW_i2c_driver);
</code></pre> 
<ul><li> </li></ul> 
<p>}副摄probe，CAMERA_HW_probe的实现如下：</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>static int CAMERA_HW_probe2(struct platform_device *pdev)  </li><li>{  </li><li>    return i2c_add_driver(&amp;CAMERA_HW_i2c_driver2);  </li><li>}  </li></ol> 
<pre><code>static int CAMERA_HW_probe2(struct platform_device *pdev) 

{ 

    return i2c_add_driver(&amp;CAMERA_HW_i2c_driver2); 

}</code></pre> 
<p>从上可以看出在main/sub 的平台probe中分别注册了各自的i2c驱动CAMERA_HW_i2c_driver，<br> CAMERA_HW_i2c_driver2，main sensor 的CAMERA_HW_i2c_driver定义如下：</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>#ifdef CONFIG_OF  </li><li>static const struct of_device_id CAMERA_HW_i2c_of_ids[] = {  </li><li>    { .compatible = ”mediatek,camera_main”, },  </li><li>    {}  </li><li>};  </li><li>#endif  </li><li>  </li><li>  </li><li>struct i2c_driver CAMERA_HW_i2c_driver = {  </li><li>    .probe = CAMERA_HW_i2c_probe,  </li><li>    .remove = CAMERA_HW_i2c_remove,  </li><li>    .driver = {  </li><li>           .name = CAMERA_HW_DRVNAME1,  </li><li>           .owner = THIS_MODULE,  </li><li>  </li><li>  </li><li>#ifdef CONFIG_OF  </li><li>           .of_match_table = CAMERA_HW_i2c_of_ids,  </li><li>#endif  </li><li>           },  </li><li>    .id_table = CAMERA_HW_i2c_id,  </li><li>};  </li><li>sub sensor 的CAMERA_HW_i2c_driver定义如下：  </li><li>#ifdef CONFIG_OF  </li><li>    static const struct of_device_id CAMERA_HW2_i2c_driver_of_ids[] = {  </li><li>    { .compatible = ”mediatek,camera_sub”, },  </li><li>    {}  </li><li>    };  </li><li>#endif  </li><li>  </li><li>  </li><li>struct i2c_driver CAMERA_HW_i2c_driver2 = {  </li><li>    .probe = CAMERA_HW_i2c_probe2,  </li><li>    .remove = CAMERA_HW_i2c_remove2,  </li><li>    .driver = {  </li><li>    .name = CAMERA_HW_DRVNAME2,  </li><li>    .owner = THIS_MODULE,  </li><li>#ifdef CONFIG_OF  </li><li>    .of_match_table = CAMERA_HW2_i2c_driver_of_ids,  </li><li>#endif  </li><li>           },  </li><li>    .id_table = CAMERA_HW_i2c_id2,  </li><li>};  </li></ol> 
<pre><code>#ifdef CONFIG_OF 

static const struct of_device_id CAMERA_HW_i2c_of_ids[] = { 

    { .compatible = “mediatek,camera_main”, }, 

    {} 

};</code></pre> 
<ul><li> </li></ul> 
<h2 id="endif-8"><a name="t16"></a>endif</h2> 
<p>struct i2c_driver CAMERA_HW_i2c_driver = {<!-- --><br> .probe = CAMERA_HW_i2c_probe,<br> .remove = CAMERA_HW_i2c_remove,<br> .driver = {<!-- --><br> .name = CAMERA_HW_DRVNAME1,<br> .owner = THIS_MODULE,</p> 
<h2 id="ifdef-configof-2"><a name="t17"></a>ifdef CONFIG_OF</h2> 
<pre><code>       .of_match_table = CAMERA_HW_i2c_of_ids,
</code></pre> 
<ul><li> </li></ul> 
<h2 id="endif-9"><a name="t18"></a>endif</h2> 
<pre><code>       },
.id_table = CAMERA_HW_i2c_id,
</code></pre> 
<ul><li> </li></ul> 
<p>};<br> sub sensor 的CAMERA_HW_i2c_driver定义如下：</p> 
<h2 id="ifdef-configof-3"><a name="t19"></a>ifdef CONFIG_OF</h2> 
<pre><code>static const struct of_device_id CAMERA_HW2_i2c_driver_of_ids[] = {
{ .compatible = "mediatek,camera_sub", },
{}
};
</code></pre> 
<h2 id="endif-10"><a name="t20"></a>endif</h2> 
<p>struct i2c_driver CAMERA_HW_i2c_driver2 = {<!-- --><br> .probe = CAMERA_HW_i2c_probe2,<br> .remove = CAMERA_HW_i2c_remove2,<br> .driver = {<!-- --><br> .name = CAMERA_HW_DRVNAME2,<br> .owner = THIS_MODULE,</p> 
<h2 id="ifdef-configof-4"><a name="t21"></a>ifdef CONFIG_OF</h2> 
<pre><code>.of_match_table = CAMERA_HW2_i2c_driver_of_ids,
</code></pre> 
<ul><li>1</li></ul> 
<h2 id="endif-11"><a name="t22"></a>endif</h2> 
<pre><code>       },
.id_table = CAMERA_HW_i2c_id2,
</code></pre> 
<ul><li>1</li><li>2</li></ul> 
<p>};对应main/sub camera i2c 设备dts定义如下<br> 文件：kernel-3.18/arch/arm/boot/dts/cust_i2c.dtsi</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>&amp;i2c0 {  </li><li>    camera_main@10 {  </li><li>        compatible = ”mediatek,camera_main”; //和 CAMERA_HW_i2c_driver定义的一致  </li><li>        reg = &lt;0x10&gt;;  </li><li>    };  </li><li>  </li><li>  </li><li>    camera_main_af@0c {  </li><li>        compatible = ”mediatek,camera_main_af”;  </li><li>        reg = &lt;0x0c&gt;;  </li><li>    };  </li><li>  </li><li>  </li><li>    camera_sub@3c {  </li><li>        compatible = ”mediatek,camera_sub”; //和CAMERA_HW_i2c_driver2定义的一致  </li><li>        reg = &lt;0x3c&gt;;  </li><li>    };  </li><li>  </li><li>  </li><li>};  </li></ol> 
<pre><code>&amp;i2c0 { 

    camera_main@10 { 

        compatible = “mediatek,camera_main”; //和 CAMERA_HW_i2c_driver定义的一致 

        reg = &lt;0x10&gt;; 

    };</code></pre> 
<ul><li> </li></ul> 
<pre><code>camera_main_af@0c {
    compatible = "mediatek,camera_main_af";
    reg = &amp;lt;0x0c&amp;gt;;
};


camera_sub@3c {
    compatible = "mediatek,camera_sub"; //和CAMERA_HW_i2c_driver2定义的一致
    reg = &amp;lt;0x3c&amp;gt;;
};
</code></pre> 
<p>};3. I2c probe的实现</p> 
<p>从上可以看出main/sub sensor在各自的平台probe中，注册了i2c_driver,当各自的i2c_driver和设备匹配</p> 
<p>（如何匹配本章不作分析）成功后，会调用各自的i2c_probe函数。main sensor 的probe函数<br> CAMERA_HW_i2c_probe：</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>static int CAMERA_HW_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)  </li><li>{  </li><li>    …..  </li><li>    /* Register char driver */  </li><li>    i4RetValue = RegisterCAMERA_HWCharDrv();  </li><li>  </li><li>  </li><li>    …..  </li><li>    return 0;  </li><li>}  </li></ol> 
<pre><code>static int CAMERA_HW_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
{
    .....
    /* Register char driver */
    i4RetValue = RegisterCAMERA_HWCharDrv();


    .....
    return 0;
}</code></pre> 
<p>sub sensor 的probe函数CAMERA_HW_i2c_probe2：</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>static int CAMERA_HW_i2c_probe2(struct i2c_client *client, const struct i2c_device_id *id)  </li><li>{  </li><li>    …..  </li><li>  </li><li>  </li><li>    /* Register char driver */  </li><li>    i4RetValue = RegisterCAMERA_HWCharDrv2();  </li><li>  </li><li>  </li><li>    …..  </li><li>}  </li></ol> 
<pre><code>static int CAMERA_HW_i2c_probe2(struct i2c_client *client, const struct i2c_device_id *id)
{
    .....


    /* Register char driver */
    i4RetValue = RegisterCAMERA_HWCharDrv2();


    .....
}</code></pre> 
<p>       从上可以看出main/sub 在各自的i2cprobe中，通过该调用RegisterCAMERA_HWCharDrv，RegisterCAMERA_HWCharDrv2注册了字符设备。各自注册cdev函数实现如下：</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>static inline int RegisterCAMERA_HWCharDrv(void)//main sensor 注册cdev  </li><li>{  </li><li>  </li><li>  </li><li>    …..  </li><li>    /* Attatch file operation. */  </li><li>    cdev_init(g_pCAMERA_HW_CharDrv, &amp;g_stCAMERA_HW_fops); //初始化字符设备  </li><li>      </li><li>    /* Add to system */  </li><li>    cdev_add(g_pCAMERA_HW_CharDrv, g_CAMERA_HWdevno, 1) //注册到内核  </li><li>  </li><li>  </li><li>    //创建目录 /sys/class/sensordrv/  </li><li>    sensor_class = class_create(THIS_MODULE, ”sensordrv”);   </li><li>    //创建目录/sys/class/sensordrv/kd_camera_hw   </li><li>    sensor_device = device_create(sensor_class, NULL, g_CAMERA_HWdevno, NULL, CAMERA_HW_DRVNAME1);   </li><li>  </li><li>  </li><li>    ….      </li><li>    return 0;  </li><li>}  </li><li>static inline int RegisterCAMERA_HWCharDrv2(void)//sub sensor 注册cdev  </li><li>{  </li><li>    ….  </li><li>  </li><li>  </li><li>    /* Attatch file operation. */  </li><li>    cdev_init(g_pCAMERA_HW_CharDrv2, &amp;g_stCAMERA_HW_fops0);//初始化字符设备   </li><li>    /* Add to system */  </li><li>    cdev_add(g_pCAMERA_HW_CharDrv2, g_CAMERA_HWdevno2, 1));//注册到内核  </li><li>    //创建目录 /sys/class/sensordrv2/  </li><li>    sensor2_class = class_create(THIS_MODULE, ”sensordrv2”);  </li><li>    //创建目录/sys/class/sensordrv2/kd_camera_hw_bus2  </li><li>    sensor_device2 = device_create(sensor2_class, NULL, g_CAMERA_HWdevno2, NULL, CAMERA_HW_DRVNAME2);  </li><li>    ….  </li><li>    return 0;  </li><li>}  </li><li>main/sub 创建各自的字符设备过程中绑定各自的fops,g_stCAMERA_HW_fops和g_stCAMERA_HW_fops0  </li><li>他们各自定义如下  </li><li>static const struct file_operations g_stCAMERA_HW_fops = { //main sensor fops  </li><li>    .owner = THIS_MODULE,  </li><li>    .open = CAMERA_HW_Open,  </li><li>    .release = CAMERA_HW_Release,  </li><li>    .unlocked_ioctl = CAMERA_HW_Ioctl,  </li><li>#ifdef CONFIG_COMPAT  </li><li>    .compat_ioctl = CAMERA_HW_Ioctl_Compat,  </li><li>#endif  </li><li>  </li><li>  </li><li>};  </li><li>  </li><li>  </li><li>static const struct file_operations g_stCAMERA_HW_fops0 = { //sub sensor fops  </li><li>    .owner = THIS_MODULE,  </li><li>    .open = CAMERA_HW_Open2,  </li><li>    .release = CAMERA_HW_Release2,  </li><li>    .unlocked_ioctl = CAMERA_HW_Ioctl,  </li><li>#ifdef CONFIG_COMPAT  </li><li>    .compat_ioctl = CAMERA_HW_Ioctl_Compat,  </li><li>#endif  </li><li>  </li><li>  </li><li>};  </li></ol> 
<pre><code>static inline int RegisterCAMERA_HWCharDrv(void)//main sensor 注册cdev
{


    .....
    /* Attatch file operation. */
    cdev_init(g_pCAMERA_HW_CharDrv, &amp;g_stCAMERA_HW_fops); //初始化字符设备

    /* Add to system */
    cdev_add(g_pCAMERA_HW_CharDrv, g_CAMERA_HWdevno, 1) //注册到内核


    //创建目录 /sys/class/sensordrv/
    sensor_class = class_create(THIS_MODULE, "sensordrv"); 
    //创建目录/sys/class/sensordrv/kd_camera_hw 
    sensor_device = device_create(sensor_class, NULL, g_CAMERA_HWdevno, NULL, CAMERA_HW_DRVNAME1); 


    ....    
    return 0;
}
static inline int RegisterCAMERA_HWCharDrv2(void)//sub sensor 注册cdev
{
    ....


    /* Attatch file operation. */
    cdev_init(g_pCAMERA_HW_CharDrv2, &amp;g_stCAMERA_HW_fops0);//初始化字符设备 
    /* Add to system */
    cdev_add(g_pCAMERA_HW_CharDrv2, g_CAMERA_HWdevno2, 1));//注册到内核
    //创建目录 /sys/class/sensordrv2/
    sensor2_class = class_create(THIS_MODULE, "sensordrv2");
    //创建目录/sys/class/sensordrv2/kd_camera_hw_bus2
    sensor_device2 = device_create(sensor2_class, NULL, g_CAMERA_HWdevno2, NULL, CAMERA_HW_DRVNAME2);
    ....
    return 0;
}
main/sub 创建各自的字符设备过程中绑定各自的fops,g_stCAMERA_HW_fops和g_stCAMERA_HW_fops0
他们各自定义如下
static const struct file_operations g_stCAMERA_HW_fops = { //main sensor fops
    .owner = THIS_MODULE,
    .open = CAMERA_HW_Open,
    .release = CAMERA_HW_Release,
    .unlocked_ioctl = CAMERA_HW_Ioctl,




</code></pre> 
<h2 id="ifdef-configcompat"><a name="t23"></a>ifdef CONFIG_COMPAT</h2> 
<pre><code>.compat_ioctl = CAMERA_HW_Ioctl_Compat,
</code></pre> 
<ul><li>1</li></ul> 
<h2 id="endif-12"><a name="t24"></a>endif</h2> 
<p>};</p> 
<p>static const struct file_operations g_stCAMERA_HW_fops0 = { //sub sensor fops<br> .owner = THIS_MODULE,<br> .open = CAMERA_HW_Open2,<br> .release = CAMERA_HW_Release2,<br> .unlocked_ioctl = CAMERA_HW_Ioctl,</p> 
<h2 id="ifdef-configcompat-1"><a name="t25"></a>ifdef CONFIG_COMPAT</h2> 
<pre><code>.compat_ioctl = CAMERA_HW_Ioctl_Compat,
</code></pre> 
<ul><li>1</li></ul> 
<h2 id="endif-13"><a name="t26"></a>endif</h2> 
<p>};</p> 
<p>从上可以看出各自的fops指定了相同的Iioctl函数，意味着上层操作main/sub sensor 只需要对应一个底层</p> 
<p>的ioctl即可，至于sensor的区分可以借助idx,后面会讲到</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>/******************************************************************************* </li><li>* CAMERA_HW_Ioctl </li><li>********************************************************************************/  </li><li>  </li><li>  </li><li>static long CAMERA_HW_Ioctl(struct file *a_pstFile,  </li><li>                unsigned int a_u4Command, unsigned long a_u4Param)  </li><li>{  </li><li>  </li><li>  </li><li>    …  </li><li>    pIdx = (u32 *) pBuff;  </li><li>    switch (a_u4Command) {  </li><li>    …  </li><li>  </li><li>  </li><li>    case KDIMGSENSORIOC_X_SET_DRIVER:  </li><li>        i4RetValue = kdSetDriver((unsigned int *)pBuff);  </li><li>        break;  </li><li>  </li><li>  </li><li>    case KDIMGSENSORIOC_X_FEATURECONCTROL:  </li><li>        i4RetValue = adopt_CAMERA_HW_FeatureControl(pBuff);  </li><li>        break;  </li><li>  </li><li>  </li><li>    case KDIMGSENSORIOC_T_CHECK_IS_ALIVE:  </li><li>        i4RetValue = adopt_CAMERA_HW_CheckIsAlive();  </li><li>        break;  </li><li>      </li><li>    ….  </li><li>    default:  </li><li>        PK_DBG(”No such command\n”);  </li><li>        i4RetValue = -EPERM;  </li><li>        break;  </li><li>  </li><li>  </li><li>    }  </li><li>  </li><li>  </li><li>    …..  </li><li>}  </li></ol> 
<pre><code>/*******************************************************************************
* CAMERA_HW_Ioctl
********************************************************************************/


static long CAMERA_HW_Ioctl(struct file *a_pstFile,
                unsigned int a_u4Command, unsigned long a_u4Param)
{


    ...
    pIdx = (u32 *) pBuff;
    switch (a_u4Command) {
    ...


    case KDIMGSENSORIOC_X_SET_DRIVER:
        i4RetValue = kdSetDriver((unsigned int *)pBuff);
        break;


    case KDIMGSENSORIOC_X_FEATURECONCTROL:
        i4RetValue = adopt_CAMERA_HW_FeatureControl(pBuff);
        break;


    case KDIMGSENSORIOC_T_CHECK_IS_ALIVE:
        i4RetValue = adopt_CAMERA_HW_CheckIsAlive();
        break;

    ....
    default:
        PK_DBG("No such command\n");
        i4RetValue = -EPERM;
        break;


    }


    .....
}</code></pre> 
<p>这里ioctl和上层一一对应，上层要控制caemra 只需要传入相应的cmd和data而已<br><br> ============================== HAL 调用Kernel 层驱动的逻辑 ========================<br>        前面介绍了HAL层调用ioctl 和 kernel层注册驱动，接下来继续分析，HAL层调用后驱动具体的实现流程。<br> 4. ioctl 底层的实现<br> 4.1先来看ioctl(m_fdSensor, KDIMGSENSORIOC_X_SET_DRIVER,&amp;id[KDIMGSENSOR_INVOKE_DRIVER_0] );<br> 当KDIMGSENSORIOC_X_SET_DRIVER被传下时，会调用kernel层的kdSetDriver接口</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>int kdSetDriver(unsigned int *pDrvIndex)  </li><li>{  </li><li>    …  </li><li>  </li><li>  </li><li>    kdGetSensorInitFuncList(&amp;pSensorList))   //获得sensor初始化列表  </li><li>  </li><li>  </li><li>    for (i = KDIMGSENSOR_INVOKE_DRIVER_0; i &lt; KDIMGSENSOR_MAX_INVOKE_DRIVERS; i++) {  </li><li>    ….  </li><li>        pSensorList[drvIdx[i]].SensorInit(&amp;g_pInvokeSensorFunc[i]); //获取各个cam驱动中Init函数入口  </li><li>  </li><li>  </li><li>    ….  </li><li>    }  </li><li>    return 0;  </li><li>}  </li></ol> 
<pre><code>int kdSetDriver(unsigned int *pDrvIndex)
{
    ...


    kdGetSensorInitFuncList(&amp;pSensorList))   //获得sensor初始化列表


    for (i = KDIMGSENSOR_INVOKE_DRIVER_0; i &lt; KDIMGSENSOR_MAX_INVOKE_DRIVERS; i++) {
    ....
        pSensorList[drvIdx[i]].SensorInit(&amp;g_pInvokeSensorFunc[i]); //获取各个cam驱动中Init函数入口


    ....
    }
    return 0;
}</code></pre> 
<p>kdGetSensorInitFuncList的实现：</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>UINT32 kdGetSensorInitFuncList(ACDK_KD_SENSOR_INIT_FUNCTION_STRUCT **ppSensorList)  </li><li>{  </li><li>    if (NULL == ppSensorList) {  </li><li>        PK_ERR(”[kdGetSensorInitFuncList]ERROR: NULL ppSensorList\n”);  </li><li>        return 1;  </li><li>    }  </li><li>    *ppSensorList = &amp;kdSensorList[0];  //获取sensorlist数组首地址  </li><li>    return 0;  </li><li>}               /* kdGetSensorInitFuncList() */  </li></ol> 
<pre><code>UINT32 kdGetSensorInitFuncList(ACDK_KD_SENSOR_INIT_FUNCTION_STRUCT **ppSensorList)
{
    if (NULL == ppSensorList) {
        PK_ERR("[kdGetSensorInitFuncList]ERROR: NULL ppSensorList\n");
        return 1;
    }
    *ppSensorList = &amp;kdSensorList[0];  //获取sensorlist数组首地址
    return 0;
}               /* kdGetSensorInitFuncList() */
</code></pre> 
<p>kdSensorList定义如下：<br> 文件：kernel-3.18/drivers/misc/mediatek/imgsensor/src/mt6580/kd_sensorlist.h</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>ACDK_KD_SENSOR_INIT_FUNCTION_STRUCT kdSensorList[MAX_NUM_OF_SUPPORT_SENSOR+1] =  </li><li>{  </li><li>    ….  </li><li>  </li><li>  </li><li>#if defined(SUB_GC2355_MIPI_RAW)  </li><li>    {GC2355S_SENSOR_ID, SENSOR_DRVNAME_GC2355S_MIPI_RAW,Sub_GC2355_MIPI_RAW_SensorInit},  </li><li>#endif  </li><li>  </li><li>  </li><li>    ….  </li><li>}  </li></ol> 
<pre><code>ACDK_KD_SENSOR_INIT_FUNCTION_STRUCT kdSensorList[MAX_NUM_OF_SUPPORT_SENSOR+1] =
{
    ....






</code></pre> 
<h2 id="if-definedsubgc2355mipiraw"><a name="t27"></a>if defined(SUB_GC2355_MIPI_RAW)</h2> 
<pre><code>{GC2355S_SENSOR_ID, SENSOR_DRVNAME_GC2355S_MIPI_RAW,Sub_GC2355_MIPI_RAW_SensorInit},
</code></pre> 
<ul><li>1</li></ul> 
<h2 id="endif-14"><a name="t28"></a>endif</h2> 
<pre><code>....
</code></pre> 
<ul><li> </li></ul> 
<p>}获取列表之后紧接着调用各自的Init函数,这里以GC2355为例</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>UINT32 GC2235MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT <em>pfFunc)  </em></li><li>{  </li><li>    / To Do : Check Sensor status here <em>/</em>  </li><li>    if (pfFunc!=NULL)  </li><li>        *pfFunc=&amp;sensor_func;  </li><li>    return ERROR_NONE;  </li><li>}   /  GC2235MIPI_RAW_SensorInit   */  </li></ol> 
<pre><code>UINT32 GC2235MIPI_RAW_SensorInit(PSENSOR_FUNCTION_STRUCT *pfFunc) 

{ 

    /* To Do : Check Sensor status here */ 

    if (pfFunc!=NULL) 

        *pfFunc=&amp;sensor_func; 

    return ERROR_NONE; 

}   /*  GC2235MIPI_RAW_SensorInit   */</code></pre> 
<ul><li> </li></ul> 
<p>     丛中可以看出，gc2355的Init函数地址传给了pfFunc，也就是时候，后面在通用驱动可以直接凭借</p> 
<p>pfun指针调用sensorlist中的驱动<br> 4.2 再来看ioctl(m_fdSensor, KDIMGSENSORIOC_T_CHECK_IS_ALIVE);</p> 
<p>当KDIMGSENSORIOC_T_CHECK_IS_ALIVE被传下时，会调用kernel层的adopt_CAMERA_HW_CheckIsAlive</p> 
<p>Control接口</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>static inline int adopt_CAMERA_HW_CheckIsAlive(void)  </li><li>{  </li><li>    ….  </li><li>    /* power on sensor */  </li><li>    kdModulePowerOn((CAMERA_DUAL_CAMERA_SENSOR_ENUM *) g_invokeSocketIdx, g_invokeSensorNameStr,  </li><li>            true, CAMERA_HW_DRVNAME1);  </li><li>  </li><li>  </li><li>    ….  </li><li>      </li><li>    if (g_pSensorFunc) {  </li><li>        for (i = KDIMGSENSOR_INVOKE_DRIVER_0; i &lt; KDIMGSENSOR_MAX_INVOKE_DRIVERS; i++) {  </li><li>            if (DUAL_CAMERA_NONE_SENSOR != g_invokeSocketIdx[i]) {  </li><li>                err =  </li><li>                    g_pSensorFunc-&gt;SensorFeatureControl(g_invokeSocketIdx[i],  </li><li>                                    SENSOR_FEATURE_CHECK_SENSOR_ID,  </li><li>                                    (MUINT8 *) &amp;sensorID,  </li><li>                                    &amp;retLen);  </li><li>                if (sensorID == 0) {    /* not implement this feature ID */  </li><li>                    PK_DBG  </li><li>                        (” Not implement!!, use old open function to check\n”);  </li><li>                    err = ERROR_SENSOR_CONNECT_FAIL;  </li><li>                } else if (sensorID == 0xFFFFFFFF) {    /* fail to open the sensor */  </li><li>                    PK_DBG(” No Sensor Found”);  </li><li>                    err = ERROR_SENSOR_CONNECT_FAIL;  </li><li>                } else {  </li><li>  </li><li>  </li><li>                    PK_INF(” Sensor found ID = 0x%x\n”, sensorID);  </li><li>                    snprintf(mtk_ccm_name, sizeof(mtk_ccm_name),  </li><li>                         ”%s CAM[%d]:%s;”, mtk_ccm_name,  </li><li>                         g_invokeSocketIdx[i], g_invokeSensorNameStr[i]);  </li><li>                    psensorResolution[0] = &amp;sensorResolution[0];  </li><li>                    psensorResolution[1] = &amp;sensorResolution[1];  </li><li>                    // don’t care of the result  </li><li>                    g_pSensorFunc-&gt;SensorGetResolution(psensorResolution);  </li><li>                    if(g_invokeSocketIdx[i] == DUAL_CAMERA_MAIN_SENSOR)  </li><li>                        curr_sensor_id = 0;  </li><li>                    else if(g_invokeSocketIdx[i] == DUAL_CAMERA_SUB_SENSOR)  </li><li>                        curr_sensor_id = 1;  </li><li>                    /* fill the cam infos with name/width/height */  </li><li>                    snprintf(g_cam_infos, sizeof(g_cam_infos),“%s CAM[%d]:%s,Width:%d, Height:%d;”,  </li><li>                                g_cam_infos, g_invokeSocketIdx[i], g_invokeSensorNameStr[i],  </li><li>                                sensorResolution[curr_sensor_id].SensorFullWidth, sensorResolution[curr_sensor_id].SensorFullHeight);  </li><li>  </li><li>  </li><li>                    err = ERROR_NONE;  </li><li>                }  </li><li>                if (ERROR_NONE != err) {  </li><li>                    PK_DBG  </li><li>                        (”ERROR:adopt_CAMERA_HW_CheckIsAlive(), No imgsensor alive\n”);  </li><li>                }  </li><li>            }  </li><li>        }  </li><li>    } else {  </li><li>        PK_DBG(”ERROR:NULL g_pSensorFunc\n”);  </li><li>    }  </li><li>}               /* adopt_CAMERA_HW_Open() */  </li></ol> 
<pre><code>static inline int adopt_CAMERA_HW_CheckIsAlive(void)
{
    ....
    /* power on sensor */
    kdModulePowerOn((CAMERA_DUAL_CAMERA_SENSOR_ENUM *) g_invokeSocketIdx, g_invokeSensorNameStr,
            true, CAMERA_HW_DRVNAME1);


    ....

    if (g_pSensorFunc) {
        for (i = KDIMGSENSOR_INVOKE_DRIVER_0; i &lt; KDIMGSENSOR_MAX_INVOKE_DRIVERS; i++) {
            if (DUAL_CAMERA_NONE_SENSOR != g_invokeSocketIdx[i]) {
                err =
                    g_pSensorFunc-&gt;SensorFeatureControl(g_invokeSocketIdx[i],
                                    SENSOR_FEATURE_CHECK_SENSOR_ID,
                                    (MUINT8 *) &amp;sensorID,
                                    &amp;retLen);
                if (sensorID == 0) {    /* not implement this feature ID */
                    PK_DBG
                        (" Not implement!!, use old open function to check\n");
                    err = ERROR_SENSOR_CONNECT_FAIL;
                } else if (sensorID == 0xFFFFFFFF) {    /* fail to open the sensor */
                    PK_DBG(" No Sensor Found");
                    err = ERROR_SENSOR_CONNECT_FAIL;
                } else {


                    PK_INF(" Sensor found ID = 0x%x\n", sensorID);
                    snprintf(mtk_ccm_name, sizeof(mtk_ccm_name),
                         "%s CAM[%d]:%s;", mtk_ccm_name,
                         g_invokeSocketIdx[i], g_invokeSensorNameStr[i]);
                    psensorResolution[0] = &amp;sensorResolution[0];
                    psensorResolution[1] = &amp;sensorResolution[1];
                    // don't care of the result
                    g_pSensorFunc-&gt;SensorGetResolution(psensorResolution);
                    if(g_invokeSocketIdx[i] == DUAL_CAMERA_MAIN_SENSOR)
                        curr_sensor_id = 0;
                    else if(g_invokeSocketIdx[i] == DUAL_CAMERA_SUB_SENSOR)
                        curr_sensor_id = 1;
                    /* fill the cam infos with name/width/height */
                    snprintf(g_cam_infos, sizeof(g_cam_infos),"%s CAM[%d]:%s,Width:%d, Height:%d;",
                                g_cam_infos, g_invokeSocketIdx[i], g_invokeSensorNameStr[i],
                                sensorResolution[curr_sensor_id].SensorFullWidth, sensorResolution[curr_sensor_id].SensorFullHeight);


                    err = ERROR_NONE;
                }
                if (ERROR_NONE != err) {
                    PK_DBG
                        ("ERROR:adopt_CAMERA_HW_CheckIsAlive(), No imgsensor alive\n");
                }
            }
        }
    } else {
        PK_DBG("ERROR:NULL g_pSensorFunc\n");
    }
}               /* adopt_CAMERA_HW_Open() */</code></pre> 
<p>这个函数非常重要，它主要进行了以下几个动作，<br> 1）通过kdModulePowerOn给Sensor上电<br> 2）通过SensorFeatureControl读取SensorID <br> 先看kdModulePowerOn的实现</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>int  </li><li>kdModulePowerOn(CAMERA_DUAL_CAMERA_SENSOR_ENUM socketIdx[KDIMGSENSOR_MAX_INVOKE_DRIVERS],  </li><li>        char sensorNameStr[KDIMGSENSOR_MAX_INVOKE_DRIVERS][32], BOOL On, char *mode_name)  </li><li>{  </li><li>    MINT32 ret = ERROR_NONE;  </li><li>    u32 i = 0;  </li><li>  </li><li>  </li><li>    for (i = KDIMGSENSOR_INVOKE_DRIVER_0; i &lt; KDIMGSENSOR_MAX_INVOKE_DRIVERS; i++) {  </li><li>        if (g_bEnableDriver[i]) {  </li><li>            /* PK_XLOG_INFO(“[%s][%d][%d][%s][%s]\r\n”,__FUNCTION__,g_bEnableDriver[i],socketIdx[i],sensorNameStr[i],mode_name); */  </li><li>#ifndef CONFIG_FPGA_EARLY_PORTING  </li><li>            ret = _kdCISModulePowerOn(socketIdx[i], sensorNameStr[i], On, mode_name);  </li><li>#endif  </li><li>            if (ERROR_NONE != ret) {  </li><li>                PK_ERR(”[%s]”, __func__);  </li><li>                return ret;  </li><li>            }  </li><li>        }  </li><li>    }  </li><li>    return ERROR_NONE;  </li><li>}  </li></ol> 
<pre><code>int
kdModulePowerOn(CAMERA_DUAL_CAMERA_SENSOR_ENUM socketIdx[KDIMGSENSOR_MAX_INVOKE_DRIVERS],
        char sensorNameStr[KDIMGSENSOR_MAX_INVOKE_DRIVERS][32], BOOL On, char *mode_name)
{
    MINT32 ret = ERROR_NONE;
    u32 i = 0;


    for (i = KDIMGSENSOR_INVOKE_DRIVER_0; i &lt; KDIMGSENSOR_MAX_INVOKE_DRIVERS; i++) {
        if (g_bEnableDriver[i]) {
            /* PK_XLOG_INFO("[%s][%d][%d][%s][%s]\r\n",__FUNCTION__,g_bEnableDriver[i],socketIdx[i],sensorNameStr[i],mode_name); */




</code></pre> 
<h2 id="ifndef-configfpgaearlyporting"><a name="t29"></a>ifndef CONFIG_FPGA_EARLY_PORTING</h2> 
<pre><code>        ret = _kdCISModulePowerOn(socketIdx[i], sensorNameStr[i], On, mode_name);
</code></pre> 
<ul><li>1</li></ul> 
<h2 id="endif-15"><a name="t30"></a>endif</h2> 
<pre><code>        if (ERROR_NONE != ret) {
            PK_ERR("[%s]", __func__);
            return ret;
        }
    }
}
return ERROR_NONE;
</code></pre> 
<p>}在kdModulePowerOn中又调用_kdCISModulePowerOn</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>int _kdCISModulePowerOn(CAMERA_DUAL_CAMERA_SENSOR_ENUM SensorIdx, char *currSensorName, BOOL On,  </li><li>            char *mode_name)  </li><li>{  </li><li>    ….  </li><li>  </li><li>  </li><li>    ret = kdCISModulePowerOn(SensorIdx, currSensorName, On, mode_name);  </li><li>    ….  </li><li>    return ret;  </li><li>}  </li></ol> 
<pre><code>int _kdCISModulePowerOn(CAMERA_DUAL_CAMERA_SENSOR_ENUM SensorIdx, char *currSensorName, BOOL On, 

            char *mode_name) 

{ 

    ….</code></pre> 
<ul><li> </li></ul> 
<pre><code>ret = kdCISModulePowerOn(SensorIdx, currSensorName, On, mode_name);
....
return ret;
</code></pre> 
<p>}在<em>kdCISModulePowerOn又调用kdCISModulePowerOn函数</em><br> 文件：kernel-3.18/drivers/misc/mediatek/imgsensor/src/mt6580/camera_hw/kd_camera_hw.c<br> //改函数为上下电函数，通过传入BOOL值来判断上/下电</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>int kdCISModulePowerOn(CAMERA_DUAL_CAMERA_SENSOR_ENUM SensorIdx, char *currSensorName, BOOL On,  </li><li>               char *mode_name)  </li><li>{  </li><li>  </li><li>  </li><li>    u32 pinSetIdx = 0;  /* default main sensor */  </li><li>  </li><li>  </li><li>#define IDX_PS_CMRST 0  </li><li>#define IDX_PS_CMPDN 4  </li><li>#define IDX_PS_MODE 1  </li><li>#define IDX_PS_ON   2  </li><li>#define IDX_PS_OFF  3  </li><li>#define VOL_2800 2800000  </li><li>#define VOL_1800 1800000  </li><li>#define VOL_1500 1500000  </li><li>#define VOL_1200 1200000  </li><li>#define VOL_1000 1000000  </li><li>  </li><li>  </li><li>  </li><li>  </li><li>    u32 pinSet[3][8] = {  </li><li>        /* for main sensor */  </li><li>        {       /* The reset pin of main sensor uses GPIO10 of mt6306, please call mt6306 API to set */  </li><li>         CAMERA_CMRST_PIN,  </li><li>         CAMERA_CMRST_PIN_M_GPIO,   /* mode */  </li><li>         GPIO_OUT_ONE,  /* ON state */  </li><li>         GPIO_OUT_ZERO, /* OFF state */  </li><li>         CAMERA_CMPDN_PIN,  </li><li>         CAMERA_CMPDN_PIN_M_GPIO,  </li><li>         GPIO_OUT_ONE,  </li><li>         GPIO_OUT_ZERO,  </li><li>         },  </li><li>        /* for sub sensor */  </li><li>        {  </li><li>         CAMERA_CMRST1_PIN,  </li><li>         CAMERA_CMRST1_PIN_M_GPIO,  </li><li>         GPIO_OUT_ONE,  </li><li>         GPIO_OUT_ZERO,  </li><li>         CAMERA_CMPDN1_PIN,  </li><li>         CAMERA_CMPDN1_PIN_M_GPIO,  </li><li>         GPIO_OUT_ONE,  </li><li>         GPIO_OUT_ZERO,  </li><li>         },  </li><li>        /* for main_2 sensor */  </li><li>        {  </li><li>         GPIO_CAMERA_INVALID,  </li><li>         GPIO_CAMERA_INVALID,   /* mode */  </li><li>         GPIO_OUT_ONE,  /* ON state */  </li><li>         GPIO_OUT_ZERO, /* OFF state */  </li><li>         GPIO_CAMERA_INVALID,  </li><li>         GPIO_CAMERA_INVALID,  </li><li>         GPIO_OUT_ONE,  </li><li>         GPIO_OUT_ZERO,  </li><li>         }  </li><li>    };  </li><li>  </li><li>  </li><li>    if (DUAL_CAMERA_MAIN_SENSOR == SensorIdx)  </li><li>        pinSetIdx = 0;  </li><li>    else if (DUAL_CAMERA_SUB_SENSOR == SensorIdx)  </li><li>        pinSetIdx = 1;  </li><li>    else if (DUAL_CAMERA_MAIN_2_SENSOR == SensorIdx)  </li><li>        pinSetIdx = 2;  </li><li>  </li><li>  </li><li>    /* power ON */  </li><li>    if (On) {  </li><li>  </li><li>  </li><li>#if 0  </li><li>        ISP_MCLK1_EN(1);  </li><li>        ISP_MCLK2_EN(1);  </li><li>        ISP_MCLK3_EN(1);  </li><li>#else  </li><li>        if (pinSetIdx == 0)  </li><li>            ISP_MCLK1_EN(1);  </li><li>        else if (pinSetIdx == 1)  </li><li>            ISP_MCLK2_EN(1);  </li><li>#endif  </li><li>  </li><li>  </li><li>    printk(”fangkuiccm %d ,currSensorName = %s pinSetIdx = %d ”,<strong>LINE</strong>,currSensorName,pinSetIdx );  </li><li>      </li><li>    //通过DriverName来区分SensorIC  </li><li>    if (currSensorName &amp;&amp; (0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName))) {  </li><li>              </li><li>            /* First Power Pin low and Reset Pin Low */  </li><li>            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN])  </li><li>                mtkcam_gpio_set(pinSetIdx, CAMPDN,  </li><li>                        pinSet[pinSetIdx][IDX_PS_CMPDN + IDX_PS_OFF]);  </li><li>  </li><li>  </li><li>            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST])  </li><li>                mtkcam_gpio_set(pinSetIdx, CAMRST,  </li><li>                        pinSet[pinSetIdx][IDX_PS_CMRST + IDX_PS_OFF]);  </li><li>  </li><li>  </li><li>            mdelay(50);  </li><li>  </li><li>  </li><li>            /* VCAM_A */  </li><li>            if (TRUE != _hwPowerOn(VCAMA, VOL_2800)) {  </li><li>                PK_DBG  </li><li>                    (”[CAMERA SENSOR] Fail to enable analog power (VCAM_A),power id = %d\n”,  </li><li>                     VCAMA);  </li><li>                goto _kdCISModulePowerOn_exit;  </li><li>            }  </li><li>  </li><li>  </li><li>            mdelay(10);  </li><li>  </li><li>  </li><li>            /<em> VCAM_IO </em>/  </li><li>            if (TRUE != <em>hwPowerOn(VCAMIO, VOL_1800)) {  </em></li><li>                PK_DBG  </li><li>                    (”[CAMERA SENSOR] Fail to enable IO power (VCAM_IO),power id = %d\n”,  </li><li>                     VCAMIO);  </li><li>                goto _kdCISModulePowerOn_exit;  </li><li>            }  </li><li>  </li><li>  </li><li>            mdelay(10);  </li><li>  </li><li>  </li><li>            if (TRUE != <em>hwPowerOn(VCAMD, VOL_1500)) {  </em></li><li>                PK_DBG  </li><li>                    (”[CAMERA SENSOR] Fail to enable digital power (VCAM_D),power id = %d\n”,  </li><li>                     VCAMD);  </li><li>                goto _kdCISModulePowerOn_exit;  </li><li>            }  </li><li>  </li><li>  </li><li>            mdelay(10);  </li><li>  </li><li>  </li><li>            /<em> AF_VCC </em>/  </li><li>            if (TRUE != <em>hwPowerOn(VCAMAF, VOL_2800)) {  </em></li><li>                PK_DBG  </li><li>                    (”[CAMERA SENSOR] Fail to enable analog power (VCAM_AF),power id = %d\n”,  </li><li>                     VCAMAF);  </li><li>                goto _kdCISModulePowerOn_exit;  </li><li>            }  </li><li>  </li><li>  </li><li>  </li><li>  </li><li>            mdelay(50);  </li><li>  </li><li>  </li><li>            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {  </li><li>                mtkcam_gpio_set(pinSetIdx, CAMRST,  </li><li>                        pinSet[pinSetIdx][IDX_PS_CMRST + IDX_PS_OFF]);  </li><li>                mdelay(5);  </li><li>                mtkcam_gpio_set(pinSetIdx, CAMRST,  </li><li>                        pinSet[pinSetIdx][IDX_PS_CMRST + IDX_PS_ON]);  </li><li>            }  </li><li>            mdelay(5);  </li><li>            /<em> enable active sensor </em>/  </li><li>            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {  </li><li>                mtkcam_gpio_set(pinSetIdx, CAMPDN,  </li><li>                        pinSet[pinSetIdx][IDX_PS_CMPDN + IDX_PS_ON]);  </li><li>                mdelay(5);  </li><li>                mtkcam_gpio_set(pinSetIdx, CAMPDN,  </li><li>                        pinSet[pinSetIdx][IDX_PS_CMPDN + IDX_PS_OFF]);  </li><li>            }  </li><li>  </li><li>  </li><li>            mdelay(5);  </li><li>        }   </li><li>    }else{ //poweroff  </li><li>     if (currSensorName   //上完电就要下电不然会造成漏电，最终会影响手机功耗  </li><li>               &amp;&amp; (0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName))) {  </li><li>#if 0  </li><li>            mt_set_gpio_mode(GPIO_SPI_MOSI_PIN, GPIO_MODE_00);  </li><li>            mt_set_gpio_dir(GPIO_SPI_MOSI_PIN, GPIO_DIR_OUT);  </li><li>            mt_set_gpio_out(GPIO_SPI_MOSI_PIN, GPIO_OUT_ONE);  </li><li>#endif  </li><li>            /<em> First Power Pin low and Reset Pin Low </em>/  </li><li>            if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {  </li><li>                if (mt_set_gpio_mode  </li><li>                    (pinSet[pinSetIdx][IDX_PS_CMPDN],  </li><li>                     pinSet[pinSetIdx][IDX_PS_CMPDN + IDX_PS_MODE])) {  </li><li>                    PK_DBG(”[CAMERA LENS] set gpio mode failed!! (CMPDN)\n”);  </li><li>                }  </li><li>                if (mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN], GPIO_DIR_OUT)) {  </li><li>                    PK_DBG(”[CAMERA LENS] set gpio dir failed!! (CMPDN)\n”);  </li><li>                }  </li><li>                if (mt_set_gpio_out  </li><li>                    (pinSet[pinSetIdx][IDX_PS_CMPDN],  </li><li>                     pinSet[pinSetIdx][IDX_PS_CMPDN + IDX_PS_OFF])) {  </li><li>                    PK_DBG(”[CAMERA LENS] set gpio failed!! (CMPDN)\n”);  </li><li>                }  </li><li>            }  </li><li>    }  </li><li>}  </li></ol> 
<pre><code>int kdCISModulePowerOn(CAMERA_DUAL_CAMERA_SENSOR_ENUM SensorIdx, char *currSensorName, BOOL On, 

               char *mode_name) 

{<!-- --></code></pre> 
<ul><li>1</li><li>2</li></ul> 
<p> </p> 
<pre><code>u32 pinSetIdx = 0;  /* default main sensor */
</code></pre> 
<ul><li>1</li></ul> 
<h2 id="define-idxpscmrst-0"><a name="t31"></a>define IDX_PS_CMRST 0</h2> 
<h2 id="define-idxpscmpdn-4"><a name="t32"></a>define IDX_PS_CMPDN 4</h2> 
<h2 id="define-idxpsmode-1"><a name="t33"></a>define IDX_PS_MODE 1</h2> 
<h2 id="define-idxpson-2"><a name="t34"></a>define IDX_PS_ON 2</h2> 
<h2 id="define-idxpsoff-3"><a name="t35"></a>define IDX_PS_OFF 3</h2> 
<h2 id="define-vol2800-2800000"><a name="t36"></a>define VOL_2800 2800000</h2> 
<h2 id="define-vol1800-1800000"><a name="t37"></a>define VOL_1800 1800000</h2> 
<h2 id="define-vol1500-1500000"><a name="t38"></a>define VOL_1500 1500000</h2> 
<h2 id="define-vol1200-1200000"><a name="t39"></a>define VOL_1200 1200000</h2> 
<h2 id="define-vol1000-1000000"><a name="t40"></a>define VOL_1000 1000000</h2> 
<pre><code>u32 pinSet[3][8] = {
    /* for main sensor */
    {       /* The reset pin of main sensor uses GPIO10 of mt6306, please call mt6306 API to set */
     CAMERA_CMRST_PIN,
     CAMERA_CMRST_PIN_M_GPIO,   /* mode */
     GPIO_OUT_ONE,  /* ON state */
     GPIO_OUT_ZERO, /* OFF state */
     CAMERA_CMPDN_PIN,
     CAMERA_CMPDN_PIN_M_GPIO,
     GPIO_OUT_ONE,
     GPIO_OUT_ZERO,
     },
    /* for sub sensor */
    {
     CAMERA_CMRST1_PIN,
     CAMERA_CMRST1_PIN_M_GPIO,
     GPIO_OUT_ONE,
     GPIO_OUT_ZERO,
     CAMERA_CMPDN1_PIN,
     CAMERA_CMPDN1_PIN_M_GPIO,
     GPIO_OUT_ONE,
     GPIO_OUT_ZERO,
     },
    /* for main_2 sensor */
    {
     GPIO_CAMERA_INVALID,
     GPIO_CAMERA_INVALID,   /* mode */
     GPIO_OUT_ONE,  /* ON state */
     GPIO_OUT_ZERO, /* OFF state */
     GPIO_CAMERA_INVALID,
     GPIO_CAMERA_INVALID,
     GPIO_OUT_ONE,
     GPIO_OUT_ZERO,
     }
};


if (DUAL_CAMERA_MAIN_SENSOR == SensorIdx)
    pinSetIdx = 0;
else if (DUAL_CAMERA_SUB_SENSOR == SensorIdx)
    pinSetIdx = 1;
else if (DUAL_CAMERA_MAIN_2_SENSOR == SensorIdx)
    pinSetIdx = 2;


/* power ON */
if (On) {
</code></pre> 
<h2 id="if-0"><a name="t41"></a>if 0</h2> 
<pre><code>    ISP_MCLK1_EN(1);
    ISP_MCLK2_EN(1);
    ISP_MCLK3_EN(1);
</code></pre> 
<h2 id="else"><a name="t42"></a>else</h2> 
<pre><code>    if (pinSetIdx == 0)
        ISP_MCLK1_EN(1);
    else if (pinSetIdx == 1)
        ISP_MCLK2_EN(1);
</code></pre> 
<h2 id="endif-16"><a name="t43"></a>endif</h2> 
<pre><code>printk("fangkuiccm %d ,currSensorName = %s pinSetIdx = %d ",__LINE__,currSensorName,pinSetIdx );

//通过DriverName来区分SensorIC
if (currSensorName &amp;amp;&amp;amp; (0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName))) {

        /* First Power Pin low and Reset Pin Low */
        if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN])
            mtkcam_gpio_set(pinSetIdx, CAMPDN,
                    pinSet[pinSetIdx][IDX_PS_CMPDN + IDX_PS_OFF]);


        if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST])
            mtkcam_gpio_set(pinSetIdx, CAMRST,
                    pinSet[pinSetIdx][IDX_PS_CMRST + IDX_PS_OFF]);


        mdelay(50);


        /* VCAM_A */
        if (TRUE != _hwPowerOn(VCAMA, VOL_2800)) {
            PK_DBG
                ("[CAMERA SENSOR] Fail to enable analog power (VCAM_A),power id = %d\n",
                 VCAMA);
            goto _kdCISModulePowerOn_exit_;
        }


        mdelay(10);


        /* VCAM_IO */
        if (TRUE != _hwPowerOn(VCAMIO, VOL_1800)) {
            PK_DBG
                ("[CAMERA SENSOR] Fail to enable IO power (VCAM_IO),power id = %d\n",
                 VCAMIO);
            goto _kdCISModulePowerOn_exit_;
        }


        mdelay(10);


        if (TRUE != _hwPowerOn(VCAMD, VOL_1500)) {
            PK_DBG
                ("[CAMERA SENSOR] Fail to enable digital power (VCAM_D),power id = %d\n",
                 VCAMD);
            goto _kdCISModulePowerOn_exit_;
        }


        mdelay(10);


        /* AF_VCC */
        if (TRUE != _hwPowerOn(VCAMAF, VOL_2800)) {
            PK_DBG
                ("[CAMERA SENSOR] Fail to enable analog power (VCAM_AF),power id = %d\n",
                 VCAMAF);
            goto _kdCISModulePowerOn_exit_;
        }




        mdelay(50);


        if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMRST]) {
            mtkcam_gpio_set(pinSetIdx, CAMRST,
                    pinSet[pinSetIdx][IDX_PS_CMRST + IDX_PS_OFF]);
            mdelay(5);
            mtkcam_gpio_set(pinSetIdx, CAMRST,
                    pinSet[pinSetIdx][IDX_PS_CMRST + IDX_PS_ON]);
        }
        mdelay(5);
        /* enable active sensor */
        if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
            mtkcam_gpio_set(pinSetIdx, CAMPDN,
                    pinSet[pinSetIdx][IDX_PS_CMPDN + IDX_PS_ON]);
            mdelay(5);
            mtkcam_gpio_set(pinSetIdx, CAMPDN,
                    pinSet[pinSetIdx][IDX_PS_CMPDN + IDX_PS_OFF]);
        }


        mdelay(5);
    } 
}else{ //poweroff
 if (currSensorName   //上完电就要下电不然会造成漏电，最终会影响手机功耗
           &amp;amp;&amp;amp; (0 == strcmp(SENSOR_DRVNAME_GC2355_MIPI_RAW, currSensorName))) {
</code></pre> 
<h2 id="if-0-1"><a name="t44"></a>if 0</h2> 
<pre><code>        mt_set_gpio_mode(GPIO_SPI_MOSI_PIN, GPIO_MODE_00);
        mt_set_gpio_dir(GPIO_SPI_MOSI_PIN, GPIO_DIR_OUT);
        mt_set_gpio_out(GPIO_SPI_MOSI_PIN, GPIO_OUT_ONE);
</code></pre> 
<h2 id="endif-17"><a name="t45"></a>endif</h2> 
<pre><code>        /* First Power Pin low and Reset Pin Low */
        if (GPIO_CAMERA_INVALID != pinSet[pinSetIdx][IDX_PS_CMPDN]) {
            if (mt_set_gpio_mode
                (pinSet[pinSetIdx][IDX_PS_CMPDN],
                 pinSet[pinSetIdx][IDX_PS_CMPDN + IDX_PS_MODE])) {
                PK_DBG("[CAMERA LENS] set gpio mode failed!! (CMPDN)\n");
            }
            if (mt_set_gpio_dir(pinSet[pinSetIdx][IDX_PS_CMPDN], GPIO_DIR_OUT)) {
                PK_DBG("[CAMERA LENS] set gpio dir failed!! (CMPDN)\n");
            }
            if (mt_set_gpio_out
                (pinSet[pinSetIdx][IDX_PS_CMPDN],
                 pinSet[pinSetIdx][IDX_PS_CMPDN + IDX_PS_OFF])) {
                PK_DBG("[CAMERA LENS] set gpio failed!! (CMPDN)\n");
            }
        }
}
</code></pre> 
<p>}上电操作完成后，紧接着读取SensorID，通用驱动使用SensorFeatureControl来读取ID如：<br>  g_pSensorFunc-&gt;SensorFeatureControl(g_invokeSocketIdx[i],<br> SENSOR_FEATURE_CHECK_SENSOR_ID,<br> (MUINT8 *) &amp;sensorID,<br> &amp;retLen);<br> 这步操作会调用GC2355中的feature_control函数如下：<br> 文件：kernel-3.18/drivers/misc/mediatek/imgsensor/src/mt6580/gc2355_mipi_raw/gc2355mipi_Sensor.c</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id,  </li><li>                             UINT8 *feature_para,UINT32 *feature_para_len)  </li><li>{  </li><li>    ….  </li><li>    LOG_INF(”feature_id = %d\n”, feature_id);  </li><li>    switch (feature_id) {  </li><li>        ….  </li><li>        case SENSOR_FEATURE_CHECK_SENSOR_ID:  </li><li>            get_imgsensor_id(feature_return_para_32);  </li><li>            break;  </li><li>        ….  </li><li>        default:  </li><li>            break;  </li><li>    }  </li><li>  </li><li>  </li><li>    return ERROR_NONE;  </li><li>}      </li></ol> 
<pre><code>static kal_uint32 feature_control(MSDK_SENSOR_FEATURE_ENUM feature_id, 

                             UINT8 *feature_para,UINT32 *feature_para_len) 

{ 

    …. 

    LOG_INF(“feature_id = %d\n”, feature_id); 

    switch (feature_id) { 

        …. 

        case SENSOR_FEATURE_CHECK_SENSOR_ID: 

            get_imgsensor_id(feature_return_para_32); 

            break; 

        …. 

        default: 

            break; 

    }</code></pre> 
<ul><li> </li></ul> 
<pre><code>return ERROR_NONE;
</code></pre> 
<ul><li>1</li></ul> 
<p>}</p> 
<p>优化传入的cmd为SENSOR_FEATURE_CHECK_SENSOR_ID，则会调用feature_control中的</p> 
<p>get_imgsensor_id再看get_imgsensor_id的实现</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)  </li><li>{  </li><li>    kal_uint8 i = 0;  </li><li>    kal_uint8 retry = 2;  </li><li>    //sensor have two i2c address 0x6c 0x6d &amp; 0x21 0x20, we should detect the module used i2c address  </li><li>    while (imgsensor_info.i2c_addr_table[i] != 0xff) {  </li><li>        spin_lock(&amp;imgsensor_drv_lock);  </li><li>        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];  </li><li>        spin_unlock(&amp;imgsensor_drv_lock);  </li><li>        do {  </li><li>            *sensor_id = return_sensor_id(); //return_sensor_id读取IC的ID  </li><li>            if (*sensor_id == imgsensor_info.sensor_id) {  </li><li>                LOG_INF(”i2c write id: 0x%x, sensor id: 0x%x\n”, imgsensor.i2c_write_id,*sensor_id);  </li><li>                return ERROR_NONE;  </li><li>            }  </li><li>            LOG_INF(”Read sensor id fail, write id: 0x%x, id: 0x%x\n”, imgsensor.i2c_write_id,*sensor_id);  </li><li>            retry–;  </li><li>        } while(retry &gt; 0);  </li><li>        i++;  </li><li>        retry = 2;  </li><li>    }  </li><li>    ….  </li><li>    return ERROR_NONE;  </li><li>}  </li></ol> 
<pre><code>static kal_uint32 get_imgsensor_id(UINT32 *sensor_id)
{
    kal_uint8 i = 0;
    kal_uint8 retry = 2;
    //sensor have two i2c address 0x6c 0x6d &amp; 0x21 0x20, we should detect the module used i2c address
    while (imgsensor_info.i2c_addr_table[i] != 0xff) {
        spin_lock(&amp;imgsensor_drv_lock);
        imgsensor.i2c_write_id = imgsensor_info.i2c_addr_table[i];
        spin_unlock(&amp;imgsensor_drv_lock);
        do {
            *sensor_id = return_sensor_id(); //return_sensor_id读取IC的ID
            if (*sensor_id == imgsensor_info.sensor_id) {
                LOG_INF("i2c write id: 0x%x, sensor id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
                return ERROR_NONE;
            }
            LOG_INF("Read sensor id fail, write id: 0x%x, id: 0x%x\n", imgsensor.i2c_write_id,*sensor_id);
            retry--;
        } while(retry &gt; 0);
        i++;
        retry = 2;
    }
    ....
    return ERROR_NONE;
}</code></pre> 
<p>再看return_sensor_id的实现</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>static kal_uint32 return_sensor_id(void)  </li><li>{  </li><li>    return ((read_cmos_sensor(0xf0) &lt;&lt; 8) | read_cmos_sensor(0xf1));  </li><li>}  </li><li>static kal_uint16 read_cmos_sensor(kal_uint32 addr)  </li><li>{  </li><li>    kal_uint16 get_byte=0;  </li><li>  </li><li>  </li><li>    char pu_send_cmd[1] = {(char)(addr &amp; 0xFF) };  </li><li>    iReadRegI2C(pu_send_cmd, 1, (u8*)&amp;get_byte, 1, imgsensor.i2c_write_id);  </li><li>  </li><li>  </li><li>    return get_byte;  </li><li>  </li><li>  </li><li>}  </li></ol> 
<pre><code>static kal_uint32 return_sensor_id(void)
{
    return ((read_cmos_sensor(0xf0) &lt;&lt; 8) | read_cmos_sensor(0xf1));
}
static kal_uint16 read_cmos_sensor(kal_uint32 addr)
{
    kal_uint16 get_byte=0;


    char pu_send_cmd[1] = {(char)(addr &amp; 0xFF) };
    iReadRegI2C(pu_send_cmd, 1, (u8*)&amp;get_byte, 1, imgsensor.i2c_write_id);


    return get_byte;


}</code></pre> 
<p>文件：kernel-3.18/drivers/misc/mediatek/imgsensor/src/mt6580/kd_sensorlist.c</p> 
<p><strong>[cpp]</strong> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">view plain</a> <a href="https://blog.csdn.net/qq_38500662/article/details/80093384#">copy</a></p> 
<ol><li>int iReadRegI2C(u8 *a_pSendData, u16 a_sizeSendData, u8 *a_pRecvData, u16 a_sizeRecvData,  </li><li>        u16 i2cId)  </li><li>{  </li><li>    int i4RetValue = 0;  </li><li>  </li><li>  </li><li>    if (gI2CBusNum == SUPPORT_I2C_BUS_NUM1) {  </li><li>        spin_lock(&amp;kdsensor_drv_lock);  </li><li>        g_pstI2Cclient-&gt;addr = (i2cId &gt;&gt; 1);  </li><li>        g_pstI2Cclient-&gt;ext_flag = (g_pstI2Cclient-&gt;ext_flag) &amp; (~I2C_DMA_FLAG);  </li><li>  </li><li>  </li><li>        /* Remove i2c ack error log during search sensor */  </li><li>        /* PK_ERR(“g_pstI2Cclient-&gt;ext_flag: %d”, g_IsSearchSensor); */  </li><li>        if (g_IsSearchSensor == 1) {  </li><li>            g_pstI2Cclient-&gt;ext_flag = (g_pstI2Cclient-&gt;ext_flag) | I2C_A_FILTER_MSG;  </li><li>        } else {  </li><li>            g_pstI2Cclient-&gt;ext_flag = (g_pstI2Cclient-&gt;ext_flag) &amp; (~I2C_A_FILTER_MSG);  </li><li>        }  </li><li>  </li><li>  </li><li>        spin_unlock(&amp;kdsensor_drv_lock);  </li><li>        /*  */  </li><li>        i4RetValue = i2c_master_send(g_pstI2Cclient, a_pSendData, a_sizeSendData);  </li><li>        if (i4RetValue != a_sizeSendData) {  </li><li>            PK_ERR(”[CAMERA SENSOR] I2C send failed!!, Addr = 0x%x\n”, a_pSendData[0]);  </li><li>            return -1;  </li><li>        }  </li><li>  </li><li>  </li><li>        i4RetValue = i2c_master_recv(g_pstI2Cclient, (char *)a_pRecvData, a_sizeRecvData);  </li><li>        if (i4RetValue != a_sizeRecvData) {  </li><li>            PK_ERR(”[CAMERA SENSOR] I2C read failed!!\n”);  </li><li>            return -1;  </li><li>        }  </li><li>    } else {  </li><li>        spin_lock(&amp;kdsensor_drv_lock);  </li><li>        g_pstI2Cclient2-&gt;addr = (i2cId &gt;&gt; 1);  </li><li>  </li><li>  </li><li>        /* Remove i2c ack error log during search sensor */  </li><li>        /* PK_ERR(“g_pstI2Cclient2-&gt;ext_flag: %d”, g_IsSearchSensor); */  </li><li>        if (g_IsSearchSensor == 1) {  </li><li>            g_pstI2Cclient2-&gt;ext_flag = (g_pstI2Cclient2-&gt;ext_flag) | I2C_A_FILTER_MSG;  </li><li>        } else {  </li><li>            g_pstI2Cclient2-&gt;ext_flag = (g_pstI2Cclient2-&gt;ext_flag) &amp; (~I2C_A_FILTER_MSG);  </li><li>        }  </li><li>        spin_unlock(&amp;kdsensor_drv_lock);  </li><li>        i4RetValue = i2c_master_send(g_pstI2Cclient2, a_pSendData, a_sizeSendData);  </li><li>        if (i4RetValue != a_sizeSendData) {  </li><li>            PK_ERR(”[CAMERA SENSOR] I2C send failed!!, Addr = 0x%x\n”, a_pSendData[0]);  </li><li>            return -1;  </li><li>        }  </li><li>  </li><li>  </li><li>        i4RetValue = i2c_master_recv(g_pstI2Cclient2, (char *)a_pRecvData, a_sizeRecvData);  </li><li>        if (i4RetValue != a_sizeRecvData) {  </li><li>            PK_ERR(”[CAMERA SENSOR] I2C read failed!!\n”);  </li><li>            return -1;  </li><li>        }  </li><li>    }  </li><li>    return 0;  </li><li>}  </li></ol> 
<pre><code>int iReadRegI2C(u8 *a_pSendData, u16 a_sizeSendData, u8 *a_pRecvData, u16 a_sizeRecvData,
        u16 i2cId)
{
    int i4RetValue = 0;


    if (gI2CBusNum == SUPPORT_I2C_BUS_NUM1) {
        spin_lock(&amp;kdsensor_drv_lock);
        g_pstI2Cclient-&gt;addr = (i2cId &gt;&gt; 1);
        g_pstI2Cclient-&gt;ext_flag = (g_pstI2Cclient-&gt;ext_flag) &amp; (~I2C_DMA_FLAG);


        /* Remove i2c ack error log during search sensor */
        /* PK_ERR("g_pstI2Cclient-&gt;ext_flag: %d", g_IsSearchSensor); */
        if (g_IsSearchSensor == 1) {
            g_pstI2Cclient-&gt;ext_flag = (g_pstI2Cclient-&gt;ext_flag) | I2C_A_FILTER_MSG;
        } else {
            g_pstI2Cclient-&gt;ext_flag = (g_pstI2Cclient-&gt;ext_flag) &amp; (~I2C_A_FILTER_MSG);
        }


        spin_unlock(&amp;kdsensor_drv_lock);
        /*  */
        i4RetValue = i2c_master_send(g_pstI2Cclient, a_pSendData, a_sizeSendData);
        if (i4RetValue != a_sizeSendData) {
            PK_ERR("[CAMERA SENSOR] I2C send failed!!, Addr = 0x%x\n", a_pSendData[0]);
            return -1;
        }


        i4RetValue = i2c_master_recv(g_pstI2Cclient, (char *)a_pRecvData, a_sizeRecvData);
        if (i4RetValue != a_sizeRecvData) {
            PK_ERR("[CAMERA SENSOR] I2C read failed!!\n");
            return -1;
        }
    } else {
        spin_lock(&amp;kdsensor_drv_lock);
        g_pstI2Cclient2-&gt;addr = (i2cId &gt;&gt; 1);


        /* Remove i2c ack error log during search sensor */
        /* PK_ERR("g_pstI2Cclient2-&gt;ext_flag: %d", g_IsSearchSensor); */
        if (g_IsSearchSensor == 1) {
            g_pstI2Cclient2-&gt;ext_flag = (g_pstI2Cclient2-&gt;ext_flag) | I2C_A_FILTER_MSG;
        } else {
            g_pstI2Cclient2-&gt;ext_flag = (g_pstI2Cclient2-&gt;ext_flag) &amp; (~I2C_A_FILTER_MSG);
        }
        spin_unlock(&amp;kdsensor_drv_lock);
        i4RetValue = i2c_master_send(g_pstI2Cclient2, a_pSendData, a_sizeSendData);
        if (i4RetValue != a_sizeSendData) {
            PK_ERR("[CAMERA SENSOR] I2C send failed!!, Addr = 0x%x\n", a_pSendData[0]);
            return -1;
        }


        i4RetValue = i2c_master_recv(g_pstI2Cclient2, (char *)a_pRecvData, a_sizeRecvData);
        if (i4RetValue != a_sizeRecvData) {
            PK_ERR("[CAMERA SENSOR] I2C read failed!!\n");
            return -1;
        }
    }
    return 0;
}</code></pre> 
<p>      这一步完成I2c的读取，也就是说如果I2c配置正确，并且上电正确，到这一步就可以正确的读取ID，</p> 
<p>整个camera也就基本就调通了。</p> 
<h2 id="三总结"><a name="t46"></a>三、总结</h2> 
<p>     通过上述分析，我们可以看出，camera驱动先是注册平台驱动，再注册I2c驱动，然后又为前后摄</p> 
<p>注册字符设备，封装底层方法，上层访问底层驱动时候显示使用setdriver将具体IC的驱动入口获取，</p> 
<p>然后使用checkisalive对sensorlist中的IC进行上电，上电完成就读取设备ID，到此为止，上层应用与</p> 
<p>底层驱动挂接完成，紧接着就是预览和拍照，不过这都是具体IC驱动的实现了。</p> 
<p>      本人建了个android camera系统 微信群，不过现在群成员超200了，不能通过二维码扫码加入，有兴趣的，可以加我微信号：xuhui_7810，到时拉你们入群。</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/57a9058fda3d79178bf1d67f5d82b32b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">5.整数规划</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c94d8302b12ac653c8d11c0455831e68/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">五分钟读完一篇文章之仿射变换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>