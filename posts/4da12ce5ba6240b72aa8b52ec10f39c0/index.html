<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Cesium 模型开挖 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Cesium 模型开挖" />
<meta property="og:description" content="和模型压平类似，此处开挖也是采用修改了模型的顶点，通过判断定的位置来判断改顶点是否加载。
缺点：会有毛边。
后续我会再上个修改源码无毛边的版本。
// 三维模型裁剪 class TilesetCut { constructor(tileset, opt) { if (!tileset) { console.log(&#34;缺少模型&#34;); return; } this.tileset = tileset; this.opt = opt || {}; /** * @property {Boolean} iscutOutter 是否为外部裁剪，默认为内部裁剪 */ this._iscutOutter = this.opt.iscutOutter; // 是否为外部裁剪 默认为内部裁剪 this.cutRegions = []; // 当前裁剪面数组对象 /* this.modelMatrix = new Cesium.Matrix4(); // 世界坐标系--》模型坐标系 Cesium.Matrix4.inverseTransformation(this.tileset.root.computedTransform, this.modelMatrix) */ // 建立模型中心点坐标系 const center = this.tileset.boundingSphere.center; const enuMtx4 = Cesium.Transforms.eastNorthUpToFixedFrame(center); this.modelMatrix = Cesium.Matrix4.inverse(enuMtx4, new Cesium.Matrix4()); this.canvas = undefined; } get iscutOutter() { return this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4da12ce5ba6240b72aa8b52ec10f39c0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-11T21:39:49+08:00" />
<meta property="article:modified_time" content="2024-01-11T21:39:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Cesium 模型开挖</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>和模型压平类似，此处开挖也是采用修改了模型的顶点，通过判断定的位置来判断改顶点是否加载。<br> 缺点：会有毛边。<br> 后续我会再上个修改源码无毛边的版本。<br><img alt="" height="1037" src="https://images2.imgbox.com/d0/41/G7aoRIap_o.png" width="1200"></p> 
<pre><code class="language-javascript">// 三维模型裁剪
class TilesetCut {
    constructor(tileset, opt) {
        if (!tileset) {
            console.log("缺少模型");
            return;
        }
        this.tileset = tileset;
        this.opt = opt || {};
        /**
         * @property {Boolean} iscutOutter 是否为外部裁剪，默认为内部裁剪
         */
        this._iscutOutter = this.opt.iscutOutter; // 是否为外部裁剪  默认为内部裁剪
        this.cutRegions = []; // 当前裁剪面数组对象
        /* this.modelMatrix = new Cesium.Matrix4(); // 世界坐标系--》模型坐标系
        Cesium.Matrix4.inverseTransformation(this.tileset.root.computedTransform, this.modelMatrix) */
        // 建立模型中心点坐标系
        const center = this.tileset.boundingSphere.center;
        const enuMtx4 = Cesium.Transforms.eastNorthUpToFixedFrame(center);
        this.modelMatrix = Cesium.Matrix4.inverse(enuMtx4, new Cesium.Matrix4());
        this.canvas = undefined;
    }

    get iscutOutter() {
        return this._iscutOutter
    }

    set iscutOutter(val) {
        this._iscutOutter = val;
        this.updateShader();
    }

    /**
     * 添加裁剪面
     * @param {Object} attr 参数
     * @param {Cesium.Cartesian3[]} attr.positions 压平面坐标
     * @param {Number} attr.id 唯一标识
     */
    addRegion(attr) {
        let { positions, id } = attr || {};
        if (!id) id = (new Date()).getTime() + "" + Number(Math.random() * 1000).toFixed(0);
        if (!positions || positions.length &lt; 3) {
            console.log("缺少裁剪面坐标");
            return;
        }
        const index = this.cutRegions.findIndex(item =&gt; item.id === id)
        if (index == -1) {
            this.cutRegions.push({
                id: id,
                positions: positions
            })
        } else {
            this.cutRegions[index].positions = positions;
        }
        this.updateShader()
    }
    /**
     * 移除裁剪面
     * @param {String} id 
     */
    removeRegionById(id) {
        if (id) { // 表示移除所有的裁剪面
            const index = this.cutRegions.findIndex(item =&gt; item.id === id)
            if (index != -1) this.cutRegions.splice(index, 1)
        } else { // 表示移除单个的裁剪面
            this.cutRegions = [];
        }
        this.updateShader();
    }

    /**
     * 销毁
     */
    destroy() {
        this.tileset.customShader = undefined;
    }

    /**
     * 修改模型着色器
     */
    updateShader() {
        debugger
        // 定义着色器中裁剪函数
        const fs_textureMapRect = `
            vec4 textureMapRect(vec4 rect, sampler2D map, vec2 xy) {
                // 判断当前图元坐标和多边形关系 如果在多边形内 进行纹素拾取
                if (xy.x &gt;= rect.x &amp;&amp; xy.x &lt;= rect.z &amp;&amp; xy.y &gt;= rect.y &amp;&amp; xy.y &lt;= rect.w) {
                    float w = rect.z - rect.x;
                    float h = rect.w - rect.y;
                    float s = (xy.x - rect.x) / w;
                    float t = (xy.y - rect.y) / h;
                    vec4 color = texture(map, vec2(s, 1.0 - t));
                    return color;
                }
                return vec4(1.0);
            }
        `;

        let allUniforms = {
            u_inverseModel: {
                type: Cesium.UniformType.MAT4,
                value: this.modelMatrix.clone()
            },
            u_unionCutRegions: {
                type: Cesium.UniformType.BOOL,
                value: this._iscutOutter
            }
        }

        // 构建多区域着色器
        let fs = ``;
        this.cutRegions.forEach(element =&gt; {
            const uniforms = this.createUniforms(element.positions, element.id)
            allUniforms = Cesium.combine(allUniforms, uniforms)
            fs += `
                vec4 color_${element.id} = textureMapRect(u_rect_${element.id}, u_map_${element.id}, xy);
                cutColor *= color_${element.id};
            `
        })

        fs += `
            if (u_unionCutRegions) {
                material.diffuse *= (vec3(1.0) - cutColor.rgb);
            } else {
                material.diffuse *= cutColor.rgb;
            }
            if (material.diffuse.r &lt;= 0.0001 &amp;&amp; material.diffuse.g &lt;= 0.0001 &amp;&amp; material.diffuse.b &lt;= 0.0001) {
                discard;
            }
        `;

        this.tileset.customShader = new Cesium.CustomShader({
            uniforms: allUniforms,
            fragmentShaderText: ` 
            ${fs_textureMapRect}
            void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material) {
                vec4 positionMC = u_inverseModel * vec4(fsInput.attributes.positionWC, 1.0);
                vec2 xy = positionMC.xy;
                vec4 cutColor = vec4(1.0);
                ${fs}
            }`
        })

    }

    /**
     * 根据坐标创建片元着色器
     * @param {Cartesian3[]} positions 
     * @param {String} id 
     */
    createUniforms(positions, id) {
        if (!positions || positions.length &lt; 3) {
            console.log("缺少裁剪面坐标");
            return;
        }
        id = id || Math.ceil(Math.random() * 100000) + '_' + Math.ceil(Math.random() * 100000)
        // 根据世界坐标范围计算相对模型坐标范围
        const xs = [], ys = [], zs = []
        // 计算模型坐标系下坐标
        const modelPoints = positions.map(p =&gt; {
            const point = Cesium.Matrix4.multiplyByPoint(this.modelMatrix, p, new Cesium.Cartesian3());
            xs.push(point.x)
            ys.push(point.y)
            zs.push(point.z)
            return point
        })
        // 计算当前裁剪面边界范围（模型坐标系下）
        const rect = new Cesium.Cartesian4(Math.min.apply(null, xs), Math.min.apply(null, ys), Math.max.apply(null, xs), Math.max.apply(null, ys))
        const canvas = document.createElement('canvas')
        canvas.width = 1024
        canvas.height = 1024
        const width = rect.z - rect.x
        const height = rect.w - rect.y
        const ctx = canvas.getContext('2d')
        ctx.fillStyle = '#fff' // 设置整体背景为白色
        ctx.fillRect(0, 0, canvas.width, canvas.height)
        ctx.beginPath()

        ctx.moveTo(canvas.width * (modelPoints[0].x - rect.x) / width, canvas.height * (modelPoints[0].y - rect.y) / height)

        for (let i = 1; i &lt; modelPoints.length; i++) {
            ctx.lineTo(canvas.width * (modelPoints[i].x - rect.x) / width, canvas.height * (modelPoints[i].y - rect.y) / height)
        }

        ctx.closePath()
        ctx.fillStyle = '#000' // 根据填充的黑色来裁剪模型
        ctx.fill()

        this.canvas = canvas;

        const uniforms = {}
        uniforms[`u_rect_${id}`] = {
            type: Cesium.UniformType.VEC4,
            value: rect
        }
        uniforms[`u_map_${id}`] = {
            type: Cesium.UniformType.SAMPLER_2D,
            value: new Cesium.TextureUniform({
                url: canvas.toDataURL()
            }),
            minificationFilter: Cesium.TextureMinificationFilter.LINEAR,
            magnificationFilter: Cesium.TextureMagnificationFilter.LINEAR
        }

        return uniforms
    }

}

export default TilesetCut</code></pre> 
<p>调用方式：<br>  </p> 
<pre><code class="language-javascript">let cutTool = new Cut(tileset);
 cutTool.addRegion({
                positions : positions,
                id : new Date().getTime()
            });</code></pre> 
<p>仓库地址：<a class="link-info" href="https://gitee.com/caozl1132/CesiumExp-tilesetFlat" rel="nofollow" title="https://gitee.com/caozl1132/CesiumExp-tilesetFlat">https://gitee.com/caozl1132/CesiumExp-tilesetFlat</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/18800c613a54726c87165d7e2588da25/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Cesium 模型压平</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4cfccbb01e2d521671e43c8b56dacbdf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【C&#43;&#43;】STL 算法 ⑪ ( 函数适配器嵌套用法 | modulus 函数对象 - 取模运算 | std::count_if 函数原型 | std::not1 函数原型 )</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>