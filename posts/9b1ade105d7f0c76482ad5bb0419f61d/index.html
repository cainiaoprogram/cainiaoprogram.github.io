<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>我的创作纪念日--数据结构(四)——渐进时间复杂度 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="我的创作纪念日--数据结构(四)——渐进时间复杂度" />
<meta property="og:description" content="😀前言
今天是我的创造256天有太多太多的感想和感谢了言不表意在文章体现吧
🏠个人主页：尘觉主页
🧑个人简介：大家好，我是尘觉，希望我的文章可以帮助到大家，您的满意是我的动力😉
在csdn获奖荣誉: 🏆csdn城市之星2名
⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　💓Java全栈群星计划top前5
⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　🤗 端午大礼包获得者
⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　🥰阿里云专家博主
⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　😉亚马逊DyamoDB结营
💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，感谢大家的观看🥰
如果文章有什么需要改进的地方还请大佬不吝赐教 先在次感谢啦😊
文章目录 数据结构——渐进时间复杂度渐进时间复杂度分析算法时间复杂度的基本方法常数阶线性阶对数阶平方阶立方阶 最好、最坏和平均时间复杂度计算公式 算法的空间复杂度：算法要占据的空间时间与空间的取舍 数据结构——渐进时间复杂度 渐进时间复杂度 ​ 对于稍微复杂一些的算法，计算出算法中所有语句的频度通常是比较困难的。通常，算法的执行时间是随问题规模增长而增长的，因此对算法的评价通常只需考虑其随问题规模增长的趋势。
这种情况下，我们只需要考虑当问题规模充分大时，算法中基本语句的执行次数在渐近意义下的阶。
基本语句：执行次数最多；对算法运行时间贡献最大；嵌套最深的语句。
分析算法时间复杂度的基本方法 找出语句频度最大的那条语句作为基本语句；
计算基本语句的频度，得到问题规模n的某一个函数；
取其数量级用O表示
忽略所有低次幂项和最高次幂的系数，这样可以简化算法分析，也体现出了增长率的含义。
常数阶 实际上，如果算法的执行时间不随问题规模n的增加而增长，算法中语句频度就是某个常数。即使这个常数再大，算法的时间复杂度都是O(1)。
线性阶 给小羊一个长度为10cm小草，小羊每三分钟吃掉1cm小草，那么他吃掉整个小草要多久？
答案自然是3*10=30min
如果小草的长度为n cm呢？
此时吃掉整个小草需要3*n即3n分钟。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9b1ade105d7f0c76482ad5bb0419f61d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-12T18:20:33+08:00" />
<meta property="article:modified_time" content="2023-12-12T18:20:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">我的创作纪念日--数据结构(四)——渐进时间复杂度</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>😀前言<br> 今天是我的创造256天有太多太多的感想和感谢了言不表意在文章体现吧</p> 
</blockquote> 
<p>🏠个人主页：<a href="https://blog.csdn.net/apple_67445472?type=blog">尘觉主页</a><br> <img src="https://images2.imgbox.com/d8/6a/DdNC77Gh_o.png" alt="在这里插入图片描述"></p> 
<p>🧑个人简介：大家好，我是尘觉，希望我的文章可以帮助到大家，您的满意是我的动力😉</p> 
<blockquote> 
 <p>在csdn获奖荣誉: 🏆csdn城市之星2名<br> ⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　💓Java全栈群星计划top前5<br> ⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　🤗 端午大礼包获得者<br> ⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　🥰阿里云专家博主<br> ⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　⁣⁣⁣⁣　😉亚马逊DyamoDB结营</p> 
</blockquote> 
<p>💕欢迎大家：这里是CSDN，我总结知识的地方，欢迎来到我的博客，感谢大家的观看🥰<br> 如果文章有什么需要改进的地方还请大佬不吝赐教 先在次感谢啦😊</p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_22" rel="nofollow">数据结构——渐进时间复杂度</a></li><li><ul><li><a href="#_24" rel="nofollow">渐进时间复杂度</a></li><li><a href="#_38" rel="nofollow">分析算法时间复杂度的基本方法</a></li><li><ul><li><a href="#_54" rel="nofollow">常数阶</a></li><li><a href="#_60" rel="nofollow">线性阶</a></li><li><a href="#_72" rel="nofollow">对数阶</a></li><li><a href="#_98" rel="nofollow">平方阶</a></li><li><a href="#_110" rel="nofollow">立方阶</a></li></ul> 
   </li><li><a href="#_120" rel="nofollow">最好、最坏和平均时间复杂度</a></li><li><ul><li><a href="#_142" rel="nofollow">计算公式</a></li></ul> 
   </li><li><a href="#_158" rel="nofollow">算法的空间复杂度：算法要占据的空间</a></li><li><ul><li><a href="#_170" rel="nofollow">时间与空间的取舍</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_22"></a>数据结构——渐进时间复杂度</h2> 
<h3><a id="_24"></a>渐进时间复杂度</h3> 
<p>​ 对于稍微复杂一些的算法，计算出算法中所有语句的频度通常是比较困难的。通常，算法的执行时间是随问题规模增长而增长的，因此对算法的评价通常只需考虑其随问题规模增长的趋势。</p> 
<p>这种情况下，我们只需要考虑当问题规模充分大时，算法中基本语句的执行次数在渐近意义下的阶。</p> 
<p><img src="https://images2.imgbox.com/18/f3/7zv7t9Rq_o.png" alt="image-20230916141845969"></p> 
<p><strong>基本语句：执行次数最多；对算法运行时间贡献最大；嵌套最深的语句。</strong></p> 
<h3><a id="_38"></a>分析算法时间复杂度的基本方法</h3> 
<ol><li> <p>找出语句频度最大的那条语句作为基本语句；</p> </li><li> <p>计算基本语句的频度，得到问题规模n的某一个函数；</p> </li><li> <p>取其数量级用O表示</p> </li></ol> 
<p><img src="https://images2.imgbox.com/7e/04/FRpR4ETB_o.png" alt="img"></p> 
<p>忽略所有低次幂项和最高次幂的系数，这样可以简化算法分析，也体现出了增长率的含义。</p> 
<p><img src="https://images2.imgbox.com/8c/df/5SnfcBYg_o.png" alt="img"></p> 
<h4><a id="_54"></a>常数阶</h4> 
<p><img src="https://images2.imgbox.com/d5/a9/ntwsox2H_o.png" alt="img"></p> 
<p>实际上，如果算法的执行时间不随问题规模n的增加而增长，算法中语句频度就是某个常数。即使这个常数再大，算法的时间复杂度都是O(1)。</p> 
<h4><a id="_60"></a>线性阶</h4> 
<p>给小羊一个长度为10cm小草，小羊每三分钟吃掉1cm小草，那么他吃掉整个小草要多久？</p> 
<p>答案自然是3*10=30min</p> 
<p>如果小草的长度为n cm呢？</p> 
<p>此时吃掉整个小草需要3*n即3n分钟。</p> 
<p>如果用一个函数来表达吃掉整个小草所需要的时间可以记作T(n)=3n(n表示小草的长度即处理的数据的规模)</p> 
<h4><a id="_72"></a>对数阶</h4> 
<p>给小羊一个长度为16cm的小草，小羊小羊每5min吃掉小草剩余长度的一半，第1min吃掉8cm，第2min吃掉4cm，第三min吃掉2cm…那么小羊把小草吃得只剩下1cm，需要多少天呢？</p> 
<p>这个问题翻译一下，就是数字16不断地除以2，除几次以后的结果等于1？这里要涉及到数学当中的对数，以2位底，16的对数，可以简写为log216。(下文对函数的底数全部省略)</p> 
<p>因此，把小草吃得只剩下1寸，需要 5<em>log16=5</em>4=20 min</p> 
<p>如果小草的长度为n cm呢？</p> 
<p>此时吃掉整个小草需要5<em>logn分钟记作T(n)=5</em>logn</p> 
<p><img src="https://images2.imgbox.com/a6/1a/DugDQoWi_o.png" alt="image-20230916142527973"></p> 
<p>也可以给n几个具体的值找规律</p> 
<h4><a id="_98"></a>平方阶</h4> 
<p><img src="https://images2.imgbox.com/5e/1f/F3V3gXiV_o.png" alt="img"></p> 
<p>由于当i=0时内循环执行n次，当i=1时内循环执行n-1次，…，当i=n-1时内循环执行1次总执行次数n+(n-1)++(n-2)+…+1=n(n+1)/2</p> 
<p>时间复杂度是O(n^2)</p> 
<h4><a id="_110"></a>立方阶</h4> 
<p><img src="https://images2.imgbox.com/50/39/eX0gbniX_o.png" alt="image-20230916142820411"></p> 
<p>显见,该程序段中频度最大的语句是(5),这条最深层循环内的基本语句的频度,依赖于各层循环变量的取值,由内向外可分析出语句(5)的执行次数为:</p> 
<p><img src="https://images2.imgbox.com/92/ff/0TM1NNuK_o.png" alt="img"></p> 
<h3><a id="_120"></a>最好、最坏和平均时间复杂度</h3> 
<p>有的情况算法的基本操作重复执行的次数还随问题输入的数据集不同而不同</p> 
<p><img src="https://images2.imgbox.com/fc/7e/Pfgo5u1v_o.png" alt="img"></p> 
<p>最好的情况a0=e执行1次</p> 
<p>最坏数组中没有e/an-1=e执行n次</p> 
<p>而对于一个算法来说，需要考虑各种可能出现的情况，以及每一种情况出现的概率，一般情况下，可假设待查找的元素在数组中所有位置上出现的可能性均相同。类似于数学中求期望值。计算每一种情况执行次数与概率的乘积在求和。</p> 
<ul><li>最坏时间复杂度是指在最坏情况下算法的的复杂度；</li><li>最好时间复杂度是指在最好情况下算法的的复杂度；</li><li>平均时间复杂度是指算法在所有可能情况下，按照输入实例以等概率出现时，算法计算量的加权平均值。</li></ul> 
<p>通常考虑最坏和平均但有时平均比较难计算只考虑最坏时间复杂度，最坏情况运行时间是一种保证，那就是运行时间不会再坏了。</p> 
<h4><a id="_142"></a>计算公式</h4> 
<p><img src="https://images2.imgbox.com/66/a1/ILmOhPZY_o.png" alt="image-20230916142918940"></p> 
<p><img src="https://images2.imgbox.com/0c/f4/WuTRwHm1_o.png" alt="image-20230916142926283"></p> 
<p>常见的时间复杂度按数量级递增排列依次为:</p> 
<p>常量阶O(1)、对数阶O(log<sub>2</sub>n)、线性阶O(n)、线性对数阶O( nlog<sub>2</sub>n)、平方阶O(n<sup>2</sup>)、立方阶O(n<sup>3</sup>) k次方阶O(n<sup>k</sup>)、指数阶O(2<sup>n</sup>)等。</p> 
<p>如果时间复杂度是平方阶最好降低到对数阶实在不行平方阶也可以接受，立方阶也尚可。</p> 
<h3><a id="_158"></a>算法的空间复杂度：算法要占据的空间</h3> 
<p><strong>算法本身要占据的空间</strong>：输入/输出、指令、常数、变量等。</p> 
<p>算法要使用的<strong>辅助空间</strong>。</p> 
<p>若输入数据所占据的空间只取决于问题本身和算法无关，这样只需分析该算法在实现时所需的辅助单元即可，若算法执行时所需的辅助单元相对于输入数据量而言是个常数，则称此算法为原地施工，空间复杂度为O(1)</p> 
<p><img src="https://images2.imgbox.com/27/ab/WINPDhs5_o.png" alt="img"></p> 
<h4><a id="_170"></a>时间与空间的取舍</h4> 
<p>​ 人们之所以花大力气去评估算法的时间复杂度和空间复杂度，其根本原因是计算机的运算速度和空间资源是有限的。就如一个大财主，基本不必为日常的花销而伤脑筋，而一个没有多少积蓄的普通人则不得不为日常的花销精打细算。对于计算机系统来说也是如此，虽然目前计算机的CPU处理速度不断飙升，内存和硬盘空间也越来越大，但是面对庞大而复杂的数据和业务，我们仍要精打细算，选择最有效的利用方式。</p> 
<p>​ 举个例子说，要判断某年是不是闰年，你可能会花一点心思来写一个算法，每给一个年份，就可以通过这个算法计算得到是否闰年的结果。</p> 
<p>​ 另外一种方法是，事先建立一个有2050个元素的数组，然后把所有的年份按下标的数字对应，如果是闰年，则此数组元素的值是1，如果不是元素的值则为0。这样，所谓的判断某一年是否为闰年就变成了查找这个数组某一个元素的值的问题。</p> 
<p>​ 第一种方法相比起第二种来说很明显非常节省空间，但每一次查询都需要经过一系列的计算才能知道是否为闰年。第二种方法虽然需要在内存里存储2050个元素的数组，但是每次查询只需要一次索引判断即可。</p> 
<p>​ 这就是通过一笔空间上的开销来换取计算时间开销的小技巧。到底哪一种方法好？其实还是要看你用在什么地方。<strong>但在绝大多数情况下，时间复杂度更重要一些，我们宁愿多分配一些内存空间也要提升程序的执行速度。</strong></p> 
<p><strong>😁热门专栏推荐</strong><br> <a href="https://blog.csdn.net/apple_67445472/category_12393266.html?spm=1001.2014.3001.5482">想学习vue的可以看看这个 </a></p> 
<p><a href="https://blog.csdn.net/apple_67445472/category_12320670.html">java基础合集 </a></p> 
<p><a href="https://blog.csdn.net/apple_67445472/category_12347484.html">数据库合集 </a></p> 
<p><a href="https://blog.csdn.net/apple_67445472/category_12385449.html">redis合集 </a></p> 
<p><a href="https://blog.csdn.net/apple_67445472/category_12385450.html">nginx合集 </a></p> 
<p><a href="https://blog.csdn.net/apple_67445472/category_12337492.html"> linux合集</a></p> 
<p><a href="https://blog.csdn.net/apple_67445472/category_12384542.html?spm=1001.2014.3001.5482">手写机制</a></p> 
<p><a href="https://blog.csdn.net/apple_67445472/category_12384550.html?spm=1001.2014.3001.5482">微服务组件</a></p> 
<p><a href="https://blog.csdn.net/apple_67445472/category_12384534.html?spm=1001.2014.3001.5482">spring_尘觉</a></p> 
<p><a href="https://blog.csdn.net/apple_67445472/category_12384537.html">springMVC</a></p> 
<p><a href="https://blog.csdn.net/apple_67445472/category_12384538.html">mybits</a></p> 
<p>等等等还有许多优秀的合集在主页等着大家的光顾感谢大家的支持</p> 
<p>🤔欢迎大家加入我的社区 <a href="https://bbs.csdn.net/forums/58c2ca9b8de344c69384b471dd4bd744">尘觉社区</a></p> 
<blockquote> 
 <p>文章到这里就结束了，如果有什么疑问的地方请指出，诸佬们一起来评论区一起讨论😁<br> 希望能和诸佬们一起努力，今后我们一起观看感谢您的阅读🍻<br> 如果帮助到您不妨3连支持一下，创造不易您们的支持是我的动力🤞</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e471f48413345ad6ab64cca5dc9d14cc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">opencv图像配准导引</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f5c5a5b236024e5ddf654ab1346f4156/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">降低检索系统搭建门槛，轻松实现 RAG 应用！Zilliz Cloud Pipelines 惊喜上线</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>