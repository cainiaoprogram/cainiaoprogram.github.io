<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>头歌---数据挖掘算法原理与实践：数据预处理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="头歌---数据挖掘算法原理与实践：数据预处理" />
<meta property="og:description" content="第1关：标准化 为什么要进行标准化
对于大多数数据挖掘算法来说，数据集的标准化是基本要求。这是因为，如果特征不服从或者近似服从标准正态分布（即，零均值、单位标准差的正态分布）的话，算法的表现会大打折扣。实际上，我们经常忽略数据的分布形状，而仅仅做零均值、单位标准差的处理。在一个机器学习算法的目标函数里的很多元素所有特征都近似零均值，方差具有相同的阶。如果某个特征的方差的数量级大于其它的特征，那么，这个特征可能在目标函数中占主导地位，这使得模型不能从其它特征有效地学习。
代码实现如下：
# -*- coding: utf-8 -*- from sklearn.preprocessing import scale,MaxAbsScaler,MinMaxScaler #实现数据预处理方法 def Preprocessing(x,y): &#39;&#39;&#39; x(ndarray):处理 数据 y(str):y等于&#39;z_score&#39;使用z_score方法 y等于&#39;minmax&#39;使用MinMaxScaler方法 y等于&#39;maxabs&#39;使用MaxAbsScaler方法 &#39;&#39;&#39; #********* Begin *********# if y==&#39;z_score&#39;: x = scale(x) return x elif y==&#39;minmax&#39;: x = MinMaxScaler().fit_transform(x) return x elif y==&#39;maxabs&#39;: x = MaxAbsScaler().fit_transform(x) return x #********* End *********# 第2关：非线性转换 为什么要非线性转换
在上一关中已经提到，对于大多数数据挖掘算法来说，如果特征不服从或者近似服从标准正态分布（即，零均值、单位标准差的正态分布）的话，算法的表现会大打折扣。非线性转换就是将我们的特征映射到均匀分布或者高斯分布(即正态分布)。
代码实现如下：
# -*- coding: utf-8 -*- from sklearn.preprocessing import QuantileTransformer #实现非线性转换方法 def non_linear_transformation(x,y): &#39;&#39;&#39; x(ndarray):待处理数据 y(int):y等于0映射到均匀分布 y等于1映射到高斯分布 &#39;&#39;&#39; #********* Begin *********# if y==0: x = QuantileTransformer(random_state=666)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/200908d1926d5d5496a3931f4578e47a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-14T11:36:04+08:00" />
<meta property="article:modified_time" content="2023-04-14T11:36:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">头歌---数据挖掘算法原理与实践：数据预处理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>第1关：标准化</h4> 
<p>为什么要进行标准化</p> 
<p>对于大多数数据挖掘算法来说，数据集的标准化是基本要求。这是因为，如果特征不服从或者近似服从标准正态分布（即，零均值、单位标准差的正态分布）的话，算法的表现会大打折扣。实际上，我们经常忽略数据的分布形状，而仅仅做零均值、单位标准差的处理。在一个机器学习算法的目标函数里的很多元素所有特征都近似零均值，方差具有相同的阶。如果某个特征的方差的数量级大于其它的特征，那么，这个特征可能在目标函数中占主导地位，这使得模型不能从其它特征有效地学习。</p> 
<p>代码实现如下：</p> 
<pre><code class="hljs"># -*- coding: utf-8 -*-

from sklearn.preprocessing import scale,MaxAbsScaler,MinMaxScaler

#实现数据预处理方法
def Preprocessing(x,y):
    '''
    x(ndarray):处理 数据
    y(str):y等于'z_score'使用z_score方法
           y等于'minmax'使用MinMaxScaler方法
           y等于'maxabs'使用MaxAbsScaler方法
    '''
    #********* Begin *********#
    if y=='z_score':
       x = scale(x)
       return x
    elif y=='minmax':
       x = MinMaxScaler().fit_transform(x)
       return x
    elif y=='maxabs':
       x = MaxAbsScaler().fit_transform(x)
       return x
    #********* End *********#

</code></pre> 
<h4>第2关：非线性转换</h4> 
<p>为什么要非线性转换</p> 
<p>在上一关中已经提到，对于大多数数据挖掘算法来说，如果特征不服从或者近似服从标准正态分布（即，零均值、单位标准差的正态分布）的话，算法的表现会大打折扣。非线性转换就是将我们的特征映射到均匀分布或者高斯分布(即正态分布)。</p> 
<p>代码实现如下：</p> 
<pre><code class="hljs"># -*- coding: utf-8 -*-
from sklearn.preprocessing import QuantileTransformer

#实现非线性转换方法
def non_linear_transformation(x,y):
    '''
    x(ndarray):待处理数据
    y(int):y等于0映射到均匀分布
           y等于1映射到高斯分布
    '''
    #********* Begin *********#
    if y==0:
       x = QuantileTransformer(random_state=666).fit_transform(x)
       return x
    elif y==1:
       x = QuantileTransformer(output_distribution='normal',  random_state=666).fit_transform(x)
       return x
    #********* End *********#

</code></pre> 
<h4>第3关：归一化</h4> 
<p>为什么使用归一化</p> 
<p>归一化是缩放<strong>单个样本</strong>以具有<strong>单位范数</strong>的过程。归一化实质是一种线性变换，线性变换有很多良好的性质，这些性质决定了对数据改变后不会造成“失效”，反而能提高数据的表现，这些性质是归一化的前提。归一化能够<strong>加快模型训练速度</strong>，<strong>统一特征量纲</strong>，<strong>避免数值太大</strong>。值得注意的是，归一化是对每一个样本做转换，所以是<strong>对数据的每一行进行变换</strong>。而之前我们讲过的方法是对数据的每一列做变换。</p> 
<p>代码实现如下：</p> 
<pre><code class="hljs"># -*- coding: utf-8 -*-

from sklearn.preprocessing import normalize

#实现数据归一化方法
def normalization(x,y):
    '''
    x(ndarray):待处理数据
    y(int):y等于1则使用"l1"归一化
           y等于2则使用"l2"归一化
    '''
    #********* Begin *********#
    if y==1:
       x = normalize(x,'l1')
       return x
    elif y==2:
       x = normalize(x,'l2')
       return x
    #********* End *********#
</code></pre> 
<h4>第4关：离散值编码</h4> 
<p>代码实现如下：</p> 
<pre><code class="hljs"># -*- coding: utf-8 -*-
import numpy as np
from sklearn.preprocessing import LabelEncoder,OneHotEncoder

def onehot_label(label):
    '''
    input:label(list):待处理标签
    output:lable(ndarray):onehot处理后的标签
    '''
    #********* Begin *********#
    label = LabelEncoder().fit_transform(label)
    label = np.array(label).reshape(len(label),1)
    label = OneHotEncoder().fit_transform(label).toarray()
    return label
    #********* End *********#</code></pre> 
<h4><br> 第5关：生成多项式特征</h4> 
<p>为什么需要多项式特征</p> 
<p>在数据挖掘中，获取数据的代价经常是非常高昂的。所以有时就需要人为的制造一些特征，并且有的特征之间是有关联的。生成多项式特征可以轻松的为我们获取更多的数据，并获得特征的更高维度和互相间关系的项且引入了特征之间的非线性关系，可以有效的增加模型的复杂度。</p> 
<p>代码实现如下：</p> 
<pre><code class="hljs"># -*- coding: utf-8 -*-
from sklearn.preprocessing import PolynomialFeatures
def polyfeaturs(x,y):
    '''
    x(ndarray):待处理特征
    y(int):y等于0生成二项式特征
           y等于1生成二项式特征，只需要特征之间交互
    '''
    #********* Begin *********#
    if y==0:
       x = PolynomialFeatures(2).fit_transform(x)
       return x
    elif y==1:
       x = PolynomialFeatures(degree=2, interaction_only=True).fit_transform(x)
       return x
    #********* End *********#
        </code></pre> 
<h4>第6关：估算缺失值</h4> 
<p>为什么要估算缺失值</p> 
<p>由于各种原因，真实世界中的许多数据集都包含缺失数据，这类数据经常被编码成空格、<code>NaNs</code>，或者是其他的占位符。但是这样的数据集并不能被<code>sklearn</code>学习算法兼容，因为大多的学习算法都默认假设数组中的元素都是数值，因而所有的元素都有自己的意义。 使用不完整的数据集的一个基本策略就是舍弃掉整行或整列包含缺失值的数据。但是这样就付出了舍弃可能有价值数据（即使是不完整的 ）的代价。 处理缺失数值的一个更好的策略就是从已有的数据推断出缺失的数值。</p> 
<p>代码实现如下：</p> 
<pre><code class="hljs"># -*- coding: utf-8 -*-
from sklearn.preprocessing import Imputer

def imp(x,y):
    '''
    x(ndarray):待处理数据
    y(str):y为'mean'则用取平均方式补充缺失值
           y为'meian'则用取中位数方式补充缺失值
           y为'most_frequent'则用出现频率最多的值代替缺失值        
    '''
    #********* Begin *********#
    if y=='mean':
       x = Imputer(missing_values='NaN', strategy='mean', axis=0).fit_transform(x)
       return x
    elif y=='meian':
       x = Imputer(missing_values='NaN', strategy='meian', axis=0).fit_transform(x)
       return x
    elif y=='most_frequent':
       x = Imputer(missing_values='NaN', strategy='most_frequent', axis=0).fit_transform(x)
       return x
    #********* End *********#
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/10a171edfc088ddc30d7beed77e8961c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前端面试真题宝典（二）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9bb09a4740812657ae74631f578d642d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android开发 登录注册设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>