<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Winsock库学习2-服务器端编程 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Winsock库学习2-服务器端编程" />
<meta property="og:description" content="为服务器创建套接字 所述的getaddrinfo函数被用来确定该值的sockaddr结构
AF_INET用于指定IPv4地址族。SOCK_STREAM用于指定流套接字。IPPROTO_TCP用于指定TCP协议。AI_PASSIVE标志指示调用者打算在对bind函数的调用中使用返回的套接字地址结构。当设置了AI_PASSIVE标志并且getaddrinfo函数的nodename参数为NULL指针时，套接字地址结构的IP地址部分对于IPv4地址设置为INADDR_ANY或对于IPv6地址设置为IN6ADDR_ANY_INIT。27015是与客户端将连接到的服务器关联的端口号。 #define DEFAULT_PORT &#34;27015&#34; struct addrinfo *result = NULL,hints; ZeroMemory(&amp;hints, sizeof (hints)); hints.ai_family = AF_INET; hints.ai_socktype = SOCK_STREAM; hints.ai_protocol = IPPROTO_TCP; hints.ai_flags = AI_PASSIVE; // Resolve the local address and port to be used by the server iResult = getaddrinfo(NULL, DEFAULT_PORT, &amp;hints, &amp;result); if (iResult != 0) { cout &lt;&lt; &#34;WSAStartup failed:&#34; &lt;&lt; iResult &lt;&lt; endl; WSACleanup(); return 1; } 为服务器创建一个名为ListenSocket的SOCKET对象，以侦听客户端连接。
SOCKET ListenSocket = INVALID_SOCKET; 调用套接字函数，并将其值返回到ListenSocket变量。对于此服务器应用程序，请使用调用返回的第一个IP地址获取与addsinfo参数（在hints参数中指定的地址），套接字类型和协议相匹配的getaddrinfo。在此示例中，使用IPv4的地址族，SOCK_STREAM的套接字类型和IPPROTO_TCP的协议请求了IPv4的TCP流套接字。因此，为ListenSocket请求了一个IPv4地址。
如果服务器应用程序希望侦听IPv6，则需要在hints参数中将地址族设置为AF_INET6 。如果服务器要同时监听IPv6和IPv4，则必须创建两个监听套接字，一个用于IPv6，另一个用于IPv4。这两个套接字必须由应用程序分别处理。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f02bb867a8e3f51200610ce668678668/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-06T16:59:04+08:00" />
<meta property="article:modified_time" content="2021-01-06T16:59:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Winsock库学习2-服务器端编程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>为服务器创建套接字</h3> 
<ol><li> <p>所述的getaddrinfo函数被用来确定该值的sockaddr结构</p> 
  <ul><li><strong>AF_INET</strong>用于指定IPv4地址族。</li><li><strong>SOCK_STREAM</strong>用于指定流套接字。</li><li><strong>IPPROTO_TCP</strong>用于指定TCP协议。</li><li><strong>AI_PASSIVE</strong>标志指示调用者打算在对<strong>bind</strong>函数的调用中使用返回的套接字地址结构。当设置了AI_PASSIVE标志并且<strong>getaddrinfo</strong>函数的nodename参数为NULL指针时，套接字地址结构的IP地址部分对于IPv4地址设置为INADDR_ANY或对于IPv6地址设置为IN6ADDR_ANY_INIT。</li><li>27015是与客户端将连接到的服务器关联的端口号。</li></ul> <pre><code class="prism language-c++">#define DEFAULT_PORT "27015"

struct addrinfo *result = NULL,hints;

ZeroMemory(&amp;hints, sizeof (hints));
hints.ai_family = AF_INET;
hints.ai_socktype = SOCK_STREAM;
hints.ai_protocol = IPPROTO_TCP;
hints.ai_flags = AI_PASSIVE;

// Resolve the local address and port to be used by the server
iResult = getaddrinfo(NULL, DEFAULT_PORT, &amp;hints, &amp;result);
if (iResult != 0) {
    cout &lt;&lt; "WSAStartup failed:" &lt;&lt; iResult &lt;&lt; endl;
    WSACleanup();
    return 1;
}
</code></pre> </li><li> <p>为服务器创建一个名为ListenSocket的SOCKET对象，以侦听客户端连接。</p> <pre><code class="prism language-c++">SOCKET ListenSocket = INVALID_SOCKET;
</code></pre> </li><li> <p>调用套接字函数，并将其值返回到ListenSocket变量。对于此服务器应用程序，请使用调用返回的第一个IP地址获取与addsinfo参数（在hints参数中指定的地址），套接字类型和协议相匹配的getaddrinfo。在此示例中，使用IPv4的地址族，SOCK_STREAM的套接字类型和IPPROTO_TCP的协议请求了IPv4的TCP流套接字。因此，为ListenSocket请求了一个IPv4地址。</p> <p>如果服务器应用程序希望侦听IPv6，则需要在hints参数中将地址族设置为AF_INET6 。如果服务器要同时监听IPv6和IPv4，则必须创建两个监听套接字，一个用于IPv6，另一个用于IPv4。这两个套接字必须由应用程序分别处理。</p> <p>Windows Vista和更高版本提供了创建单个IPv6套接字的功能，该套接字被置于双堆栈模式下，可以同时监听IPv6和IPv4。有关此功能的更多信息，请参见Dual-Stack Sockets。</p> <pre><code class="prism language-c++">ListenSocket = socket(result-&gt;ai_family, result-&gt;ai_socktype, result-&gt;ai_protocol);
</code></pre> </li><li> <p>检查是否有错误，以确保该套接字是有效的套接字。</p> <pre><code class="prism language-c++">if (ListenSocket == INVALID_SOCKET) {
    cout &lt;&lt; "Error at socket():" &lt;&lt; WSAGetLastError() &lt;&lt; endl;
    freeaddrinfo(result);
    WSACleanup();
    return 1;
}
</code></pre> </li></ol> 
<h3><a id="_57"></a>绑定套接字</h3> 
<p>为了使服务器接受客户端连接，必须将其绑定到系统内的网络地址。以下代码演示了如何将已经创建的套接字绑定到IP地址和端口。客户端应用程序使用IP地址和端口连接到主机网络。</p> 
<p>该sockaddr的结构保存有关家庭地址，IP地址和端口号的信息。</p> 
<p>调用bind函数，将从getaddrinfo函数返回的创建的套接字和sockaddr结构作为参数传递。检查一般错误。</p> 
<pre><code class="prism language-C++">    // Setup the TCP listening socket
    iResult = bind( ListenSocket, result-&gt;ai_addr, (int)result-&gt;ai_addrlen);
    if (iResult == SOCKET_ERROR) {
        cout &lt;&lt; "bind failed with error:" &lt;&lt; WSAGetLastError() &lt;&lt; endl;
        freeaddrinfo(result);
        closesocket(ListenSocket);
        WSACleanup();
        return 1;
    }
</code></pre> 
<p>一旦绑定函数被调用，在返回的地址信息的getaddrinfo功能不再需要。该freeaddrinfo函数被调用，以释放该分配的内存的getaddrinfo这个地址信息的功能。</p> 
<p>C ++复制</p> 
<pre><code class="prism language-C++">    freeaddrinfo(result);
</code></pre> 
<h3><a id="_85"></a>在套接字上侦听</h3> 
<p>将套接字绑定到系统上的IP地址和端口后，服务器必须随后在该IP地址和端口上侦听传入的连接请求。</p> 
<p>调用<strong>listen</strong>函数，将创建的套接字和backlog的值作为参数传递，backlog的值是要接受的未决连接队列的最大长度。在此示例中，backlog参数设置为SOMAXCONN。此值是一个特殊的常数，它指示Winsock提供程序为此套接字允许在队列中允许最大数量的合理挂起连接。检查返回值是否存在一般错误。</p> 
<pre><code class="prism language-C++">if ( listen( ListenSocket, SOMAXCONN ) == SOCKET_ERROR ) {
    cout &lt;&lt; "Listen failed with error:" &lt;&lt; WSAGetLastError() &lt;&lt; endl;
    closesocket(ListenSocket);
    WSACleanup();
    return 1;
}
</code></pre> 
<h3><a id="_100"></a>接收连接</h3> 
<p>套接字侦听连接后，程序必须处理该套接字上的连接请求。</p> 
<ol><li> <p>创建一个名为ClientSocket的临时<strong>SOCKET</strong>对象，以接受来自客户端的连接。</p> <pre><code class="prism language-C++">SOCKET ClientSocket;
</code></pre> </li><li> <p>通常，服务器应用程序将被设计为侦听来自多个客户端的连接。对于高性能服务器，通常使用多个线程来处理多个客户端连接。</p> <p>使用Winsock有几种不同的编程技术，可用于侦听多个客户端连接。一种编程技术是创建一个连续循环，使用<strong>listen</strong>函数检查连接请求（请参见在Socket上侦听）。如果发生连接请求，则应用程序将调用<strong>accept</strong>，<strong>AcceptEx</strong>或<strong>WSAAccept</strong>函数，并将工作传递给另一个线程来处理该请求。其他几种编程技术也是可能的。</p> <p>请注意，此基本示例非常简单，并且不使用多个线程。该示例还仅侦听并接受单个连接。</p> <pre><code class="prism language-C++">ClientSocket = INVALID_SOCKET;

// Accept a client socket
ClientSocket = accept(ListenSocket, NULL, NULL);
if (ClientSocket == INVALID_SOCKET) {
    cout &lt;&lt; "accept failed:" &lt;&lt; WSAGetLastError() &lt;&lt; endl;
    closesocket(ListenSocket);
    WSACleanup();
    return 1;
}
</code></pre> </li><li> <p>接受客户端连接后，服务器应用程序通常会将接受的客户端套接字（上述示例代码中的ClientSocket变量）传递给工作线程或I / O完成端口，然后继续接受其他连接。在此基本示例中，服务器继续进行下一步。</p> <p>还有许多其他编程技术可用于侦听和接受多个连接。这些包括使用<strong>select</strong>或<strong>WSAPoll</strong>函数。Microsoft Windows软件开发工具包（SDK）附带的<strong>Advanced Winsock Samples</strong>中说明了其中各种编程技术的示例。</p> </li></ol> 
<h3><a id="_133"></a>在服务器上接收和发送数据</h3> 
<p>以下代码演示了服务器使用的<strong>recv</strong>和<strong>send</strong>函数。</p> 
<pre><code class="prism language-C++">#define DEFAULT_BUFLEN 512

char recvbuf[DEFAULT_BUFLEN];
int iResult, iSendResult;
int recvbuflen = DEFAULT_BUFLEN;

// Receive until the peer shuts down the connection
do {

    iResult = recv(ClientSocket, recvbuf, recvbuflen, 0);
    if (iResult &gt; 0) {
        printf("Bytes received: %d\n", iResult);

        // Echo the buffer back to the sender
        iSendResult = send(ClientSocket, recvbuf, iResult, 0);
        if (iSendResult == SOCKET_ERROR) {
            printf("send failed: %d\n", WSAGetLastError());
            closesocket(ClientSocket);
            WSACleanup();
            return 1;
        }
        printf("Bytes sent: %d\n", iSendResult);
    } else if (iResult == 0)
        printf("Connection closing...\n");
    else {
        printf("recv failed: %d\n", WSAGetLastError());
        closesocket(ClientSocket);
        WSACleanup();
        return 1;
    }

} while (iResult &gt; 0);
</code></pre> 
<p>的<strong>send</strong>和<strong>recv</strong>的功能都返回分 别发送或接收的，字节数，或错误的一个整数值。每个函数还具有相同的参数：活动套接字，char缓冲区，要发送或接收的字节数以及要使用的任何标志。</p> 
<h3><a id="_174"></a>断开服务器</h3> 
<p>服务器完成从客户端接收数据并将数据发送回客户端后，服务器将与客户端断开连接并关闭套接字。</p> 
<p><strong>断开和关闭套接字</strong></p> 
<ol><li> <p>服务器完成向客户端的数据发送后，可以通过指定SD_SEND调用<strong>shutdown</strong>函数来关闭套接字的发送端。这允许客户端释放该套接字的一些资源。服务器应用程序仍可以在套接字上接收数据。</p> <pre><code class="prism language-C++">// shutdown the send half of the connection since no more data will be sent
iResult = shutdown(ClientSocket, SD_SEND);
if (iResult == SOCKET_ERROR) {
    printf("shutdown failed: %d\n", WSAGetLastError());
    closesocket(ClientSocket);
    WSACleanup();
    return 1;
}
</code></pre> </li><li> <p>客户端应用程序完成数据接收后，将调用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-closesocket" rel="nofollow"><strong>closesocket</strong></a>函数关闭套接字。</p> <p>使用Windows套接字DLL完成客户端应用程序后，将调用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winsock/nf-winsock-wsacleanup" rel="nofollow"><strong>WSACleanup</strong></a>函数以释放资源。</p> <pre><code class="prism language-C++">// cleanup
closesocket(ClientSocket);
WSACleanup();

return 0;
</code></pre> </li></ol> 
<h3><a id="_205"></a>示例</h3> 
<pre><code class="prism language-c++">#undef UNICODE
#define WIN32_LEAN_AND_MEAN
#include&lt;iostream&gt;
#include&lt;winsock2.h&gt;
#include&lt;ws2tcpip.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;

#define DEFAULT_PORT "27015"
#define DEFAULT_BUFLEN 512
//#define WIN32_LEAN_AND_MEAN
using namespace std;
#pragma comment(lib,"ws2_32.lib")

//赋值操作
int main()
{
	//初始化Winsock
	WSADATA wsadata;
	int iResult;
	iResult = WSAStartup(MAKEWORD(2, 2), &amp;wsadata);
	if (iResult != 0) {
		cout &lt;&lt; "WSAStartup failed:" &lt;&lt; iResult &lt;&lt; endl;
		return 1;
	}
	//为服务器创建套接字
	//SOCKET serversocket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);
	struct addrinfo* result = NULL, hints;
	ZeroMemory(&amp;hints, sizeof(hints));
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;
	hints.ai_flags = AI_PASSIVE;
	iResult = getaddrinfo(NULL, DEFAULT_PORT, &amp;hints, &amp;result);
	if (iResult != 0) {
		cout &lt;&lt; "getaddrinfo failed:" &lt;&lt; iResult &lt;&lt; endl;
		WSACleanup();
		return 1;
	}
	SOCKET ListenSocket = INVALID_SOCKET;
	ListenSocket = socket(result-&gt;ai_family, result-&gt;ai_socktype, result-&gt;ai_protocol);
	if (ListenSocket == INVALID_SOCKET) {
		cout &lt;&lt; "Error at socket():" &lt;&lt; WSAGetLastError() &lt;&lt; endl;
		freeaddrinfo(result);
		WSACleanup();
		return 1;
	}
	//绑定套接字
	iResult = ::bind(ListenSocket, result-&gt;ai_addr, (int)result-&gt;ai_addrlen);
	if (iResult == SOCKET_ERROR) {
		cout &lt;&lt; "bind failed with error:" &lt;&lt; WSAGetLastError() &lt;&lt; endl;
		freeaddrinfo(result);
		closesocket(ListenSocket);
		WSACleanup();
		return 1;
	}
	freeaddrinfo(result);
	//进入监听状态
	if (listen(ListenSocket, SOMAXCONN) == SOCKET_ERROR) {
		cout &lt;&lt; "Listen failed with error:" &lt;&lt; WSAGetLastError() &lt;&lt; endl;
		closesocket(ListenSocket);
		WSACleanup();
		return 1;
	}
	//接收客户端请求
	SOCKET ClientSocket = accept(ListenSocket, NULL, NULL);
	if (ClientSocket == INVALID_SOCKET) {
		cout &lt;&lt; "accept failed:" &lt;&lt; WSAGetLastError() &lt;&lt; endl;
		closesocket(ListenSocket);
		WSACleanup();
		return 1;
	}
	//在服务器上接收和发送数据
	char recvbuf[DEFAULT_BUFLEN];
	int iSendResult;
	int recvbuflen = DEFAULT_BUFLEN;
	do {
		iResult = recv(ClientSocket, recvbuf, recvbuflen, 0);
		if (iResult &gt; 0) {
			cout &lt;&lt; "Bytes received:" &lt;&lt; iResult &lt;&lt; endl;
			iSendResult = send(ClientSocket, recvbuf, iResult, 0);
			if (iSendResult == SOCKET_ERROR) {
				cout &lt;&lt; "send failed:" &lt;&lt; WSAGetLastError() &lt;&lt; endl;
				closesocket(ClientSocket);
				WSACleanup();
				return 1;
			}
			cout &lt;&lt; "Bytes sent:" &lt;&lt; iSendResult &lt;&lt; endl;
		}
		else if (iResult == 0) {
			cout &lt;&lt; "Connection closing..." &lt;&lt; endl;

		}
		else {
			cout &lt;&lt; "recv failed:" &lt;&lt; WSAGetLastError() &lt;&lt; endl;
			closesocket(ClientSocket);
			WSACleanup();
			return 1;
		}
	} while (iResult &gt; 0);
	iResult = shutdown(ClientSocket, SD_SEND);
	if (iResult == SOCKET_ERROR) {
		cout &lt;&lt; "shutdown failed: " &lt;&lt; WSAGetLastError() &lt;&lt; endl;
		closesocket(ClientSocket);
		WSACleanup();
		return 1;
	}
	closesocket(ClientSocket);
	WSACleanup();
	return 0;
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/20e79d3f4e0ff167189849105576ddb1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Arduino Uno 实验15——MQ-135 气体传感器模块</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/90f289a0b28b7ea1cd082c6de52866ab/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">安卓dts音频解码_互联网场景化的未来：DTS:X Ultra带来最佳声效体验</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>