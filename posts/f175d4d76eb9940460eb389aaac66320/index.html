<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>使用Python和Numpy进行波士顿房价预测任务（二）【深度学习入门_学习笔记】 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="使用Python和Numpy进行波士顿房价预测任务（二）【深度学习入门_学习笔记】" />
<meta property="og:description" content="使用Python和Numpy进行波士顿房价预测任务–详解
目录：
一、数据处理
（1）读入数据
（2）数据形状变换
（3）数据集划分
（4）数据归一化处理
（5）封装成load data函数 二、模型设计
三、训练配置
四、训练过程
（1）梯度下降法
- 使用Numpy进行梯度计算
（2）确定损失函数更小的点
（3）随机梯度下降法
波士顿房价预测是一个经典的机器学习任务，类似于程序员世界的“Hello World”。和大家对房价的普遍认知相同，波士顿地区的房价是由诸多因素影响的。
下载数据集：https://archive.ics.uci.edu/ml/machine-learning-databases/housing/housing.data
该数据集统计了13种可能影响房价的因素和该类型房屋的均价，期望构建一个基于13个因素进行房价预测的模型，如图所示。
对于预测问题，可以根据预测输出的类型是连续的实数值，还是离散的标签，区分为回归任务和分类任务。因为房价是一个连续值，所以房价预测显然是一个回归任务。下面我们尝试用最简单的线性回归模型解决这个问题，并用神经网络来实现这个模型。
线性回归模型
假设房价和各影响因素之间能够用线性关系来描述：
模型的求解即是通过数据拟合出每个wj和b。其中，wj和b分别表示该线性模型的权重和偏置。一维情况下，wj和 b 是直线的斜率和截距。
线性回归模型使用均方误差作为损失函数（Loss），用以衡量预测房价和真实房价的差异，公式如下：
线性回归模型的神经网络结构
神经网络的标准结构中每个神经元由加权和与非线性变换构成，然后将多个神经元分层的摆放并连接形成神经网络。线性回归模型可以认为是神经网络模型的一种极简特例，是一个只有加权和、没有非线性变换的神经元（无需形成网络），如图所示。
构建波士顿房价预测任务的神经网络模型
深度学习不仅实现了实现模型的端到端学习，还推动了人工智能进入工业大生产阶段，产生了标准化、自动化和模块化的通用框架。不同场景的深度学习模型具具备一定的通用性，五个步骤即可完成模型的构建和训练，如图所示。
正是由于深度学习的建模和训练的过程存在通用性，在构建不同的模型时，只有模型三要素不同，其它步骤基本一致，深度学习框架才有用武之地。
一、数据处理 数据处理包含五个部分：数据导入、数据形状变换、数据集划分、数据归一化处理和封装load data函数。数据预处理后，才能被模型调用。
（1）读入数据 通过如下代码读入数据，了解下波士顿房价的数据集结构，数据存放在本地目录下housing.data文件中。
# 导入需要用到的package import numpy as np import json # 读入训练数据 datafile = &#39;./housing.data&#39; #注：定位到存放数据目录 data = np.fromfile(datafile, sep=&#39; &#39;) data array([6.320e-03, 1.800e&#43;01, 2.310e&#43;00, …, 3.969e&#43;02, 7.880e&#43;00,1.190e&#43;01])
（2）数据形状变换 由于读入的原始数据是1维的，所有数据都连在一起。因此需要我们将数据的形状进行变换，形成一个2维的矩阵，每行为一个数据样本（14个值），每个数据样本包含13个X（影响房价的特征）和一个Y（该类型房屋的均价）。
# 读入之后的数据被转化成1维array，其中array的第0-13项是第一条数据，第14-27项是第二条数据，以此类推.... # 这里对原始数据做reshape，变成N x 14的形式 feature_names = [ &#39;CRIM&#39;, &#39;ZN&#39;, &#39;INDUS&#39;, &#39;CHAS&#39;, &#39;NOX&#39;, &#39;RM&#39;, &#39;AGE&#39;,&#39;DIS&#39;, &#39;RAD&#39;, &#39;TAX&#39;, &#39;PTRATIO&#39;, &#39;B&#39;, &#39;LSTAT&#39;, &#39;MEDV&#39; ] feature_num = len(feature_names) data = data." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f175d4d76eb9940460eb389aaac66320/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-08T18:09:12+08:00" />
<meta property="article:modified_time" content="2020-06-08T18:09:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">使用Python和Numpy进行波士顿房价预测任务（二）【深度学习入门_学习笔记】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>使用Python和Numpy进行波士顿房价预测任务–详解<br> 目录：<br> <a href="#01" rel="nofollow">一、数据处理</a><br> <a href="#011" rel="nofollow">（1）读入数据</a><br> <a href="#012" rel="nofollow">（2）数据形状变换</a><br> <a href="#013" rel="nofollow">（3）数据集划分</a><br> <a href="#014" rel="nofollow">（4）数据归一化处理</a><br> <a href="#015" rel="nofollow">（5）封装成load data函数</a> <br> <a href="#02" rel="nofollow">二、模型设计</a><br> <a href="#03" rel="nofollow">三、训练配置</a><br> <a href="#04" rel="nofollow">四、训练过程</a><br> <a href="#041" rel="nofollow">（1）梯度下降法</a><br> <a href="#0412" rel="nofollow">- 使用Numpy进行梯度计算</a><br> <a href="#042" rel="nofollow">（2）确定损失函数更小的点</a><br> <a href="#043" rel="nofollow">（3）随机梯度下降法</a></p> 
<p>波士顿房价预测是一个经典的机器学习任务，类似于程序员世界的“Hello World”。和大家对房价的普遍认知相同，波士顿地区的房价是由诸多因素影响的。<br> 下载数据集：<a href="https://archive.ics.uci.edu/ml/machine-learning-databases/housing/housing.data" rel="nofollow">https://archive.ics.uci.edu/ml/machine-learning-databases/housing/housing.data</a><br> 该数据集统计了13种可能影响房价的因素和该类型房屋的均价，期望构建一个基于13个因素进行房价预测的模型，如图所示。<br> <img src="https://images2.imgbox.com/ef/dc/xVnVIBWe_o.png" alt="在这里插入图片描述"></p> 
<p>对于预测问题，可以根据预测输出的类型是连续的实数值，还是离散的标签，区分为回归任务和分类任务。因为房价是一个连续值，所以房价预测显然是一个回归任务。下面我们尝试用最简单的线性回归模型解决这个问题，并用神经网络来实现这个模型。</p> 
<p><strong>线性回归模型</strong></p> 
<p>假设房价和各影响因素之间能够用线性关系来描述：<br> <img src="https://images2.imgbox.com/6d/d9/VDQfLpL4_o.png" alt="在这里插入图片描述"><br> 模型的求解即是通过数据拟合出每个wj和b。其中，wj和b分别表示该线性模型的权重和偏置。一维情况下，wj和 b 是直线的斜率和截距。<br> 线性回归模型使用均方误差作为损失函数（Loss），用以衡量预测房价和真实房价的差异，公式如下：<br> <img src="https://images2.imgbox.com/d2/da/J5b0Ngqs_o.png" alt="在这里插入图片描述"></p> 
<p><strong>线性回归模型的神经网络结构</strong><br> 神经网络的标准结构中每个神经元由加权和与非线性变换构成，然后将多个神经元分层的摆放并连接形成神经网络。线性回归模型可以认为是神经网络模型的一种极简特例，是一个只有加权和、没有非线性变换的神经元（无需形成网络），如图所示。</p> 
<p><img src="https://images2.imgbox.com/34/5a/yv8IpVms_o.png" alt="在这里插入图片描述"></p> 
<p><strong>构建波士顿房价预测任务的神经网络模型</strong><br> 深度学习不仅实现了实现模型的端到端学习，还推动了人工智能进入工业大生产阶段，产生了标准化、自动化和模块化的通用框架。不同场景的深度学习模型具具备一定的通用性，五个步骤即可完成模型的构建和训练，如图所示。</p> 
<p><img src="https://images2.imgbox.com/09/42/k6Gl4MTe_o.png" alt="在这里插入图片描述"></p> 
<p>正是由于深度学习的建模和训练的过程存在通用性，在构建不同的模型时，只有模型三要素不同，其它步骤基本一致，深度学习框架才有用武之地。</p> 
<h2><a id="h1_id01_52"></a></h2> 
<h2 id="01">一、数据处理</h2> 
<p>数据处理包含五个部分：数据导入、数据形状变换、数据集划分、数据归一化处理和封装load data函数。数据预处理后，才能被模型调用。</p> 
<h3><a id="h2_id0111_55"></a></h3> 
<h3 id="011">（1）读入数据</h3> 
<p>通过如下代码读入数据，了解下波士顿房价的数据集结构，数据存放在本地目录下housing.data文件中。</p> 
<pre><code># 导入需要用到的package
import numpy as np
import json
# 读入训练数据
datafile = './housing.data'  #注：定位到存放数据目录
data = np.fromfile(datafile, sep=' ')
data
</code></pre> 
<p>array([6.320e-03, 1.800e+01, 2.310e+00, …, 3.969e+02, 7.880e+00,1.190e+01])</p> 
<h3><a id="h2_id0122_69"></a></h3> 
<h3 id="012">（2）数据形状变换</h3> 
<p>由于读入的原始数据是1维的，所有数据都连在一起。因此需要我们将数据的形状进行变换，形成一个2维的矩阵，每行为一个数据样本（14个值），每个数据样本包含13个X（影响房价的特征）和一个Y（该类型房屋的均价）。</p> 
<pre><code># 读入之后的数据被转化成1维array，其中array的第0-13项是第一条数据，第14-27项是第二条数据，以此类推.... 
# 这里对原始数据做reshape，变成N x 14的形式
feature_names = [ 'CRIM', 'ZN', 'INDUS', 'CHAS', 'NOX', 'RM', 'AGE','DIS',  'RAD', 'TAX', 'PTRATIO', 'B', 'LSTAT', 'MEDV' ]
feature_num = len(feature_names)
data = data.reshape([data.shape[0] // feature_num, feature_num])

# 查看数据
x = data[0]
print(x.shape)
print(x)
</code></pre> 
<p>(14,)<br> [6.320e-03 1.800e+01 2.310e+00 0.000e+00 5.380e-01 6.575e+00 6.520e+01<br> 4.090e+00 1.000e+00 2.960e+02 1.530e+01 3.969e+02 4.980e+00 2.400e+01]</p> 
<h3><a id="h2_id0133_87"></a></h3> 
<h3 id="013">（3）数据集划分</h3> 
<p>将数据集划分成训练集和测试集，其中训练集用于确定模型的参数，测试集用于评判模型的效果。我们将80%的数据用作训练集，20%用作测试集，实现代码如下。<br> 通过打印训练集的形状，可以发现共有404个样本，每个样本含有13个特征和1个预测值。</p> 
<pre><code>ratio = 0.8
offset = int(data.shape[0] * ratio)
training_data = data[:offset]
training_data.shape
</code></pre> 
<p>(404, 14)</p> 
<h3><a id="h2_id0144_100"></a></h3> 
<h3 id="014">（4）数据归一化处理</h3> 
<p>对每个特征进行归一化处理，使得每个特征的取值缩放到0~1之间。这样做有两个好处：一是模型训练更高效；二是特征前的权重大小可以代表该变量对预测结果的贡献度（因为每个特征值本身的范围相同）。</p> 
<pre><code># 计算train数据集的最大值，最小值，平均值
maximums, minimums, avgs = \
                     training_data.max(axis=0), \
                     training_data.min(axis=0), \
     training_data.sum(axis=0) / training_data.shape[0]
# 对数据进行归一化处理
for i in range(feature_num):
    #print(maximums[i], minimums[i], avgs[i])
    data[:, i] = (data[:, i] - avgs[i]) / (maximums[i] - minimums[i])
</code></pre> 
<h3><a id="h2_id0155load_data_115"></a></h3> 
<h3 id="015">（5）封装成load data函数</h3> 
<p>将上述几个数据处理操作封装成load data函数，以便下一步模型的调用，代码如下。</p> 
<pre><code>def load_data():
    # 从文件导入数据
    datafile = './housing.data'
    data = np.fromfile(datafile, sep=' ')
    # 每条数据包括14项，其中前面13项是影响因素，第14项是相应的房屋价格中位数
    feature_names = [ 'CRIM', 'ZN', 'INDUS', 'CHAS', 'NOX', 'RM', 'AGE', \
                      'DIS', 'RAD', 'TAX', 'PTRATIO', 'B', 'LSTAT', 'MEDV' ] 
    feature_num = len(feature_names)
    # 将原始数据进行Reshape，变成[N, 14]这样的形状
    data = data.reshape([data.shape[0] // feature_num, feature_num])
    # 将原数据集拆分成训练集和测试集
    # 这里使用80%的数据做训练，20%的数据做测试
    # 测试集和训练集必须是没有交集的
    ratio = 0.8
    offset = int(data.shape[0] * ratio) 
    training_data = data[:offset]
    # 计算train数据集的最大值，最小值，平均值
    maximums, minimums, avgs = training_data.max(axis=0), training_data.min(axis=0), \
                                 training_data.sum(axis=0) / training_data.shape[0]
    # 对数据进行归一化处理
    for i in range(feature_num):
        #print(maximums[i], minimums[i], avgs[i])
        data[:, i] = (data[:, i] - avgs[i]) / (maximums[i] - minimums[i])
    # 训练集和测试集的划分比例
    training_data = data[:offset]
    test_data = data[offset:]
    return training_data, test_data
</code></pre> 
<pre><code># 获取数据
training_data, test_data = load_data()
x = training_data[:, :-1]
y = training_data[:, -1:]
# 查看数据
print(x[0])
print(y[0])
</code></pre> 
<p>[-0.02146321 0.03767327 -0.28552309 -0.08663366 0.01289726 0.04634817<br> 0.00795597 -0.00765794 -0.25172191 -0.11881188 -0.29002528 0.0519112<br> -0.17590923]<br> [-0.00390539]</p> 
<h2><a id="h1_id02_162"></a></h2> 
<h2 id="02">二、模型设计</h2> 
<p>模型设计是深度学习模型关键要素之一，也称为网络结构设计，相当于模型的假设空间，即实现模型“前向计算”（从输入到输出）的过程。<br> 如果将输入特征和输出预测值均以向量表示，输入特征x有13个分量，y有1个分量，那么参数权重的形状（shape）是13×1。假设我们以如下任意数字赋值参数做初始化：</p> 
<pre><code>w = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, -0.1, -0.2, -0.3, -0.4, 0.0]
w = np.array(w).reshape([13, 1])
</code></pre> 
<p>取出第1条样本数据，观察样本的特征向量与参数向量相乘的结果。</p> 
<pre><code>x1=x[0]
t = np.dot(x1, w)
print(t)
</code></pre> 
<p>[0.03395597]</p> 
<p>完整的线性回归公式，还需要初始化偏移量bbb，同样随意赋初值-0.2。那么，线性回归模型的完整输出是z=t+bz=t+bz=t+b，这个从特征和参数计算输出值的过程称为“前向计算”。</p> 
<pre><code>b = -0.2
z = t + b
print(z)
</code></pre> 
<p>[-0.16604403]</p> 
<p>将上述计算预测输出的过程以“类和对象”的方式来描述，类成员变量有参数w和b。通过写一个forward函数（代表“前向计算”）完成上述从特征和参数到输出预测值的计算过程，代码如下所示。</p> 
<pre><code>class Network(object):
    def __init__(self, num_of_weights):
        # 随机产生w的初始值
        # 为了保持程序每次运行结果的一致性，
        # 此处设置固定的随机数种子
        np.random.seed(0)
        self.w = np.random.randn(num_of_weights, 1)
        self.b = 0.
    def forward(self, x):
        z = np.dot(x, self.w) + self.b
        return z
</code></pre> 
<p>基于Network类的定义，模型的计算过程如下所示。</p> 
<pre><code>net = Network(13)
x1 = x[0]
y1 = y[0]
z = net.forward(x1)
print(z)
</code></pre> 
<p>[-0.63182506]</p> 
<h2><a id="h1_id03__220"></a></h2> 
<h2 id="03"> 三、训练配置</h2> 
<p>模型设计完成后，需要通过训练配置寻找模型的最优值，即通过损失函数来衡量模型的好坏。训练配置也是深度学习模型关键要素之一。<br> 通过模型计算x1​表示的影响因素所对应的房价应该是z, 但实际数据告诉我们房价是y。这时我们需要有某种指标来衡量预测值z跟真实值y之间的差距。对于回归问题，最常采用的衡量方法是使用均方误差作为评价模型好坏的指标，具体定义如下：</p> 
<p>上式中的Loss（简记为: L）通常也被称作损失函数，它是衡量模型好坏的指标。在回归问题中均方误差是一种比较常见的形式，分类问题中通常会采用交叉熵作为损失函数，在后续的章节中会更详细的介绍。对一个样本计算损失的代码实现如下：</p> 
<pre><code>Loss = (y1 - z)*(y1 - z)
print(Loss)
</code></pre> 
<p>[0.39428312]</p> 
<p>因为计算损失时需要把每个样本的损失都考虑到，所以我们需要对单个样本的损失函数进行求和，并除以样本总数NNN。</p> 
<p>在Network类下面添加损失函数的计算过程如下：</p> 
<pre><code>class Network(object):
    def __init__(self, num_of_weights):
        # 随机产生w的初始值
        # 为了保持程序每次运行结果的一致性，此处设置固定的随机数种子
        np.random.seed(0)
        self.w = np.random.randn(num_of_weights, 1)
        self.b = 0.
        
    def forward(self, x):
        z = np.dot(x, self.w) + self.b
        return z
    
    def loss(self, z, y):
        error = z - y
        cost = error * error
        cost = np.mean(cost)
        return cost
</code></pre> 
<p>使用定义的Network类，可以方便的计算预测值和损失函数。需要注意的是，类中的变量x, w，b, z, error等均是向量。以变量x为例，共有两个维度，一个代表特征数量（值为13），一个代表样本数量，代码如下所示。</p> 
<pre><code>net = Network(13)
# 此处可以一次性计算多个样本的预测值和损失函数
x1 = x[0:3]
y1 = y[0:3]
z = net.forward(x1)
print('predict: ', z)
loss = net.loss(z, y1)
print('loss:', loss)
</code></pre> 
<p>predict: [[-0.63182506]<br> [-0.55793096]<br> [-1.00062009]]<br> loss: 0.7229825055441156</p> 
<h2><a id="h1_id04_278"></a></h2> 
<h2 id="04">四、训练过程</h2> 
<p>上述计算过程描述了如何构建神经网络，通过神经网络完成预测值和损失函数的计算。接下来介绍如何求解参数w和b的数值，这个过程也称为模型训练过程。<br> 训练过程是深度学习模型的关键要素之一，其目标是让定义的损失函数Loss尽可能的小，也就是说找到一个参数解w和b使得损失函数取得极小值。</p> 
<h3 id="041">（1）梯度下降法 </h3> 
<p>在现实中存在大量的函数正向求解容易，反向求解较难，被称为单向函数。这种函数在密码学中有大量的应用，密码锁的特点是可以迅速判断一个密钥是否是正确的(已知x，求y很容易)，但是即使获取到密码锁系统，无法破解出正确的密钥是什么（已知y，求x很难）。<br> 求解Loss函数最小值可以“从当前的参数取值，一步步的按照下坡的方向下降，直到走到最低点”实现。<br> 训练的关键是找到一组(w,b)，使得损失函数L取极小值。我们先看一下损失函数L只随两个参数w5​、w9​变化时的简单情形，启发下寻解的思路。<br> <img src="https://images2.imgbox.com/88/7f/XVn6wQDV_o.png" alt="在这里插入图片描述"></p> 
<p>将w0,w1,…,w12​中除w5,w9​之外的参数和b都固定下来，可以用图画出L(w5,w9)的形式。</p> 
<pre><code>net = Network(13)
losses = []
#只画出参数w5和w9在区间[-160, 160]的曲线部分，以及包含损失函数的极值
w5 = np.arange(-160.0, 160.0, 1.0)
w9 = np.arange(-160.0, 160.0, 1.0)
losses = np.zeros([len(w5), len(w9)])

#计算设定区域内每个参数取值所对应的Loss
for i in range(len(w5)):
    for j in range(len(w9)):
        net.w[5] = w5[i]
        net.w[9] = w9[j]
        z = net.forward(x)
        loss = net.loss(z, y)
        losses[i, j] = loss

#使用matplotlib将两个变量和对应的Loss作3D图
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
fig = plt.figure()
ax = Axes3D(fig)

w5, w9 = np.meshgrid(w5, w9)

ax.plot_surface(w5, w9, losses, rstride=1, cstride=1, cmap='rainbow')
plt.show()
</code></pre> 
<p><img src="https://images2.imgbox.com/cf/18/jK2zdWov_o.png" alt="在这里插入图片描述"></p> 
<p>对于这种简单情形，我们利用上面的程序，可以在三维空间中画出损失函数随参数变化的曲面图。从图中可以看出有些区域的函数值明显比周围的点小。</p> 
<p>需要说明的是：为什么这里我们选择 w5 和 w9 来画图？这是因为选择这两个参数的时候，可比较直观的从损失函数的曲面图上发现极值点的存在。其他参数组合，从图形上观测损失函数的极值点不够直观。</p> 
<p>观察上述曲线呈现出“圆滑”的坡度，这正是我们选择以均方误差作为损失函数的原因之一。</p> 
<p><img src="https://images2.imgbox.com/a6/2e/caXfhMe7_o.png" alt="在这里插入图片描述"></p> 
<p>由此可见，均方误差表现的“圆滑”的坡度有两个好处：</p> 
<p>曲线的最低点是可导的。<br> 越接近最低点，曲线的坡度逐渐放缓，有助与基于当前的梯度来判断接近最低点的程度（是否逐渐减少步长，以免错过最低点）。<br> 而这两个特性绝对值误差是不具备的，这也是损失函数的设计不仅仅要考虑“合理性”，还要追求“易解性”的原因。</p> 
<p><strong>计算梯度</strong></p> 
<p><img src="https://images2.imgbox.com/f3/82/YDXaML8v_o.png" alt="在这里插入图片描述"></p> 
<p>按上面的公式，当只有一个样本时，可以计算某个wj，比如w0​的梯度。</p> 
<pre><code>gradient_w0 = (z1 - y1) * x1[0]
print('gradient_w0 {}'.format(gradient_w0))
</code></pre> 
<p>gradient_w0 [0.25875126]</p> 
<p>同样我们可以计算w1​的梯度。</p> 
<pre><code>gradient_w1 = (z1 - y1) * x1[1]
print('gradient_w1 {}'.format(gradient_w1))
</code></pre> 
<p>gradient_w1 [-0.45417275]</p> 
<p>写一个for循环即可计算从w0​到w12的所有权重的梯度</p> 
<pre><code>for i in range(0,13):
    gradient_w1 = (z1 - y1) * x1[i]
    print('gradient_w1 {}'.format(gradient_w1))
</code></pre> 
<h4 id="0412">使用Numpy进行梯度计算 </h4> 
<p>基于Numpy广播机制（对向量和矩阵计算如同对1个单一变量计算一样），可以更快速的实现梯度计算。计算梯度的代码中直接用(z1 - y1) * x1，得到的是一个13维的向量，每个分量分别代表该维度的梯度。</p> 
<pre><code>gradient_w = (z1 - y1) * x1
print('gradient_w_by_sample1 {}, gradient.shape {}'.format(gradient_w, gradient_w.shape))
</code></pre> 
<p>输入数据中有多个样本，每个样本都对梯度有贡献。如上代码计算了只有样本1时的梯度值，同样的计算方法也可以计算样本2和样本3对梯度的贡献。</p> 
<pre><code>#样本2
x2 = x[1]
y2 = y[1]
z2 = net.forward(x2)
gradient_w = (z2 - y2) * x2
print('gradient_w_by_sample2 {}, gradient.shape {}'.format(gradient_w, gradient_w.shape))
</code></pre> 
<pre><code>#样本3
x3 = x[2]
y3 = y[2]
z3 = net.forward(x3)
gradient_w = (z3 - y3) * x3
print('gradient_w_by_sample3 {}, gradient.shape {}'.format(gradient_w, gradient_w.shape))
</code></pre> 
<p>可以使用for循环把每个样本对梯度的贡献都计算出来，然后再作平均。但是我们不需要这么做，仍然可以使用Numpy的矩阵操作来简化运算，如3个样本的情况。</p> 
<pre><code>#  注意这里是一次取出3个样本的数据，不是取出第3个样本
x3samples = x[0:3]
y3samples = y[0:3]
z3samples = net.forward(x3samples)

print('x {}, shape {}'.format(x3samples, x3samples.shape))
print('y {}, shape {}'.format(y3samples, y3samples.shape))
print('z {}, shape {}'.format(z3samples, z3samples.shape))
</code></pre> 
<p>上面的x3samples, y3samples, z3samples的第一维大小均为3，表示有3个样本。下面计算这3个样本对梯度的贡献。</p> 
<pre><code>gradient_w = (z3samples - y3samples) * x3samples
print('gradient_w {}, gradient.shape {}'.format(gradient_w, gradient_w.shape))
</code></pre> 
<p>此处可见，计算梯度gradient_w的维度是3×13，并且其第1行与上面第1个样本计算的梯度gradient_w_by_sample1一致，第2行与上面第2个样本计算的梯度gradient_w_by_sample1一致，第3行与上面第3个样本计算的梯度gradient_w_by_sample1一致。这里使用矩阵操作，可能更加方便的对3个样本分别计算各自对梯度的贡献。</p> 
<p>那么对于有N个样本的情形，我们可以直接使用如下方式计算出所有样本对梯度的贡献，这就是使用Numpy库广播功能带来的便捷。 小结一下这里使用Numpy库的广播功能：</p> 
<p>一方面可以扩展参数的维度，代替for循环来计算1个样本对从w0 到w12 的所有参数的梯度。<br> 另一方面可以扩展样本的维度，代替for循环来计算样本0到样本403对参数的梯度。</p> 
<pre><code>z = net.forward(x)
gradient_w = (z - y) * x
print('gradient_w shape {}'.format(gradient_w.shape))
print(gradient_w)
</code></pre> 
<p>上面gradient_w的每一行代表了一个样本对梯度的贡献。根据梯度的计算公式，总梯度是对每个样本对梯度贡献的平均值。<br> <img src="https://images2.imgbox.com/73/59/RFnoQQjJ_o.png" alt="在这里插入图片描述"><br> 我们也可以使用Numpy的均值函数来完成此过程：</p> 
<pre><code># axis = 0 表示把每一行做相加然后再除以总的行数
gradient_w = np.mean(gradient_w, axis=0)
print('gradient_w ', gradient_w.shape)
print('w ', net.w.shape)
print(gradient_w)
print(net.w)
</code></pre> 
<p>我们使用numpy的矩阵操作方便的完成了gradient的计算，但引入了一个问题，gradient_w的形状是(13,)，而w的维度是(13, 1)。导致该问题的原因是使用np.mean函数的时候消除了第0维。为了加减乘除等计算方便，gradient_w和w必须保持一致的形状。因此我们将gradient_w的维度也设置为(13, 1)，代码如下：</p> 
<pre><code>gradient_w = gradient_w[:, np.newaxis]
print('gradient_w shape', gradient_w.shape)
</code></pre> 
<p>计算梯度（w的梯度计算）的代码如下所示</p> 
<pre><code>z = net.forward(x)
gradient_w = (z - y) * x
gradient_w = np.mean(gradient_w, axis=0)
gradient_w = gradient_w[:, np.newaxis]
gradient_w
</code></pre> 
<p>同样，计算b的梯度的代码也是类似的原理。</p> 
<pre><code>gradient_b = (z - y)
gradient_b = np.mean(gradient_b)
# 此处b是一个数值，所以可以直接用np.mean得到一个标量
gradient_b
</code></pre> 
<p>将上面计算www和bbb的梯度的过程，写成Network类的gradient函数，代码如下所示。</p> 
<pre><code>class Network(object):
    def __init__(self, num_of_weights):
        # 随机产生w的初始值
        # 为了保持程序每次运行结果的一致性，此处设置固定的随机数种子
        np.random.seed(0)
        self.w = np.random.randn(num_of_weights, 1)
        self.b = 0.
        
    def forward(self, x):
        z = np.dot(x, self.w) + self.b
        return z
    
    def loss(self, z, y):
        error = z - y
        num_samples = error.shape[0]
        cost = error * error
        cost = np.sum(cost) / num_samples
        return cost
    
    def gradient(self, x, y):
        z = self.forward(x)
        gradient_w = (z-y)*x
        gradient_w = np.mean(gradient_w, axis=0)
        gradient_w = gradient_w[:, np.newaxis]
        gradient_b = (z - y)
        gradient_b = np.mean(gradient_b)
        
        return gradient_w, gradient_b
</code></pre> 
<pre><code># 调用上面定义的gradient函数，计算梯度
# 初始化网络，
net = Network(13)
# 设置[w5, w9] = [-100., +100.]
net.w[5] = -100.0
net.w[9] = -100.0

z = net.forward(x)
loss = net.loss(z, y)
gradient_w, gradient_b = net.gradient(x, y)
gradient_w5 = gradient_w[5][0]
gradient_w9 = gradient_w[9][0]
print('point {}, loss {}'.format([net.w[5][0], net.w[9][0]], loss))
print('gradient {}'.format([gradient_w5, gradient_w9]))
</code></pre> 
<p>point [-100.0, -100.0], loss 686.3005008179159<br> gradient [-0.850073323995813, -6.138412364807849]</p> 
<h3 id="042">（2）确定损失函数更小的点 </h3> 
<p>下面我们开始研究更新梯度的方法。首先沿着梯度的反方向移动一小步，找到下一个点P1，观察损失函数的变化。</p> 
<pre><code># 在[w5, w9]平面上，沿着梯度的反方向移动到下一个点P1
# 定义移动步长 eta
eta = 0.1
# 更新参数w5和w9
net.w[5] = net.w[5] - eta * gradient_w5
net.w[9] = net.w[9] - eta * gradient_w9
# 重新计算z和loss
z = net.forward(x)
loss = net.loss(z, y)
gradient_w, gradient_b = net.gradient(x, y)
gradient_w5 = gradient_w[5][0]
gradient_w9 = gradient_w[9][0]
print('point {}, loss {}'.format([net.w[5][0], net.w[9][0]], loss))
print('gradient {}'.format([gradient_w5, gradient_w9]))
</code></pre> 
<p>运行上面的代码，可以发现沿着梯度反方向走一小步，下一个点的损失函数的确减少了。不停的点击上面的代码块，损失函数会一直在变小。<br> 在上述代码中，每次更新参数使用的语句： net.w[5] = net.w[5] - eta * gradient_w5</p> 
<ul><li>相减：参数需要向梯度的反方向移动。</li><li>eta：控制每次参数值沿着梯度反方向变动的大小，即每次移动的步长，又称为学习率。</li></ul> 
<p>特征输入归一化后，不同参数输出的Loss是一个比较规整的曲线，学习率可以设置成统一的值 ；特征输入未归一化时，不同特征对应的参数所需的步长不一致，尺度较大的参数需要大步长，尺寸较小的参数需要小步长，导致无法设置统一的学习率。</p> 
<p><img src="https://images2.imgbox.com/9d/ee/YACEaQKC_o.png" alt="在这里插入图片描述"><br> <strong>代码封装Train函数</strong><br> 将上面的循环的计算过程封装在train和update函数中，代码如下所示。</p> 
<pre><code>class Network(object):
    def __init__(self, num_of_weights):
        # 随机产生w的初始值
        # 为了保持程序每次运行结果的一致性，此处设置固定的随机数种子
        np.random.seed(0)
        self.w = np.random.randn(num_of_weights,1)
        self.w[5] = -100.
        self.w[9] = -100.
        self.b = 0.
        
    def forward(self, x):
        z = np.dot(x, self.w) + self.b
        return z
    
    def loss(self, z, y):
        error = z - y
        num_samples = error.shape[0]
        cost = error * error
        cost = np.sum(cost) / num_samples
        return cost
    
    def gradient(self, x, y):
        z = self.forward(x)
        gradient_w = (z-y)*x
        gradient_w = np.mean(gradient_w, axis=0)
        gradient_w = gradient_w[:, np.newaxis]
        gradient_b = (z - y)
        gradient_b = np.mean(gradient_b)        
        return gradient_w, gradient_b
    
    def update(self, graident_w5, gradient_w9, eta=0.01):
        net.w[5] = net.w[5] - eta * gradient_w5
        net.w[9] = net.w[9] - eta * gradient_w9
        
    def train(self, x, y, iterations=100, eta=0.01):
        points = []
        losses = []
        for i in range(iterations):
            points.append([net.w[5][0], net.w[9][0]])
            z = self.forward(x)
            L = self.loss(z, y)
            gradient_w, gradient_b = self.gradient(x, y)
            gradient_w5 = gradient_w[5][0]
            gradient_w9 = gradient_w[9][0]
            self.update(gradient_w5, gradient_w9, eta)
            losses.append(L)
            if i % 50 == 0:
                print('iter {}, point {}, loss {}'.format(i, [net.w[5][0], net.w[9][0]], L))
        return points, losses

# 获取数据
train_data, test_data = load_data()
x = train_data[:, :-1]
y = train_data[:, -1:]
# 创建网络
net = Network(13)
num_iterations=2000
# 启动训练
points, losses = net.train(x, y, iterations=num_iterations, eta=0.01)

# 画出损失函数的变化趋势
plot_x = np.arange(num_iterations)
plot_y = np.array(losses)
plt.plot(plot_x, plot_y)
plt.show()
</code></pre> 
<p>iter 0, point [-99.99144364382136, -99.93861587635192], loss 686.3005008179159<br> iter 50, point [-99.56362583488914, -96.92631128470325], loss 649.221346830939<br> iter 100, point [-99.13580802595692, -94.02279509580971], loss 614.6970095624063<br> iter 150, point [-98.7079902170247, -91.22404911807594], loss 582.543755023494<br> …<br> iter 1750, point [-85.01782033119372, -39.21364012642417], loss 175.61640587468244<br> iter 1800, point [-84.5900025222615, -38.35768737548557], loss 171.59326591927967<br> iter 1850, point [-84.16218471332928, -37.530876349682856], loss 167.76521193253296<br> iter 1900, point [-83.73436690439706, -36.73213067476985], loss 164.11884842217898<br> iter 1950, point [-83.30654909546485, -35.96041373329276], loss 160.64174090423475<br> <img src="https://images2.imgbox.com/b7/3e/P23gxpPi_o.png" alt="在这里插入图片描述"></p> 
<p><strong>训练扩展到全部参数</strong><br> 为了能给读者直观的感受，上面演示的梯度下降的过程仅包含w5 和w9 两个参数，但房价预测的完整模型，必须要对所有参数w和b进行求解。这需要将Network中的update和train函数进行修改。由于不再限定参与计算的参数（所有参数均参与计算），修改之后的代码反而更加简洁。实现逻辑：“前向计算输出、根据输出和真实值计算Loss、基于Loss和输入计算梯度、根据梯度更新参数值”四个部分反复执行，直到到达参数最优点。具体代码如下所示。</p> 
<pre><code>class Network(object):
    def __init__(self, num_of_weights):
        # 随机产生w的初始值
        # 为了保持程序每次运行结果的一致性，此处设置固定的随机数种子
        np.random.seed(0)
        self.w = np.random.randn(num_of_weights, 1)
        self.b = 0.
        
    def forward(self, x):
        z = np.dot(x, self.w) + self.b
        return z
    
    def loss(self, z, y):
        error = z - y
        num_samples = error.shape[0]
        cost = error * error
        cost = np.sum(cost) / num_samples
        return cost
    
    def gradient(self, x, y):
        z = self.forward(x)
        gradient_w = (z-y)*x
        gradient_w = np.mean(gradient_w, axis=0)
        gradient_w = gradient_w[:, np.newaxis]
        gradient_b = (z - y)
        gradient_b = np.mean(gradient_b)        
        return gradient_w, gradient_b
    
    def update(self, gradient_w, gradient_b, eta = 0.01):
        self.w = self.w - eta * gradient_w
        self.b = self.b - eta * gradient_b
        
    def train(self, x, y, iterations=100, eta=0.01):
        losses = []
        for i in range(iterations):
            z = self.forward(x)
            L = self.loss(z, y)
            gradient_w, gradient_b = self.gradient(x, y)
            self.update(gradient_w, gradient_b, eta)
            losses.append(L)
            if (i+1) % 10 == 0:
                print('iter {}, loss {}'.format(i, L))
        return losses

# 获取数据
train_data, test_data = load_data()
x = train_data[:, :-1]
y = train_data[:, -1:]
# 创建网络
net = Network(13)
num_iterations=1000
# 启动训练
losses = net.train(x,y, iterations=num_iterations, eta=0.01)

# 画出损失函数的变化趋势
plot_x = np.arange(num_iterations)
plot_y = np.array(losses)
plt.plot(plot_x, plot_y)
plt.show()
</code></pre> 
<h3 id="043">（3）随机梯度下降法 </h3> 
<p>在上述程序中，每次损失函数和梯度计算都是基于数据集中的全量数据。对于波士顿房价预测任务数据集而言，样本数比较少，只有404个。但在实际问题中，数据集往往非常大，如果每次都使用全量数据进行计算，效率非常低，通俗的说就是“杀鸡焉用牛刀”。由于参数每次只沿着梯度反方向更新一点点，因此方向并不需要那么精确。一个合理的解决方案是每次从总的数据集中随机抽取出小部分数据来代表整体，基于这部分数据计算梯度和损失来更新参数，这种方法被称作随机梯度下降法</p> 
<p>随机梯度下降法的核心概念如下：</p> 
<ul><li>min-batch：每次迭代时抽取出来的一批数据被称为一个min-batch。</li><li>batch_size：一个mini-batch所包含的样本数目称为batch_size。</li><li>epoch：当程序迭代的时候，按mini-batch逐渐抽取出样本，当把整个数据集都遍历到了的时候，则完成了一轮的训练，也叫一个epoch。启动训练时，可以将训练的轮数num_epochs和batch_size作为参数传入。</li></ul> 
<p>下面结合程序介绍具体的实现过程，涉及到数据处理和训练过程两部分代码的修改。</p> 
<p><strong>1.数据处理代码修改</strong><br> 数据处理需要实现拆分数据批次和样本乱序（为了实现随机抽样的效果）两个功能。</p> 
<pre><code># 获取数据
train_data, test_data = load_data()

# 打乱样本顺序
np.random.shuffle(train_data)

# 将train_data分成多个mini_batch
batch_size = 10
n = len(train_data)
mini_batches = [train_data[k:k+batch_size] for k in range(0, n, batch_size)]

# 创建网络
net = Network(13)

# 依次使用每个mini_batch的数据
for mini_batch in mini_batches:
    x = mini_batch[:, :-1]
    y = mini_batch[:, -1:]
    loss = net.train(x, y, iterations=1)
</code></pre> 
<p><strong>2.训练过程代码修改</strong><br> 将每个随机抽取的mini-batch数据输入到模型中用于参数训练。训练过程的核心是两层循环：</p> 
<ul><li> <p>第一层循环，代表样本集合要被训练遍历几次，称为“epoch”，代码如下： for epoch_id in<br> range(num_epoches):</p> </li><li> <p>第二层循环，代表每次遍历时，样本集合被拆分成的多个批次，需要全部执行训练，称为“iter (iteration)”， 代码如下：for<br> iter_id,mini_batch in emumerate(mini_batches):</p> </li></ul> 
<p>在两层循环的内部是经典的四步训练流程：前向计算-&gt;计算损失-&gt;计算梯度-&gt;更新参数，这与大家之前所学是一致的，代码如下：</p> 
<pre><code>            x = mini_batch[:, :-1]
            y = mini_batch[:, -1:]
            a = self.forward(x)  #前向计算
            loss = self.loss(a, y)  #计算损失
            gradient_w, gradient_b = self.gradient(x, y)  #计算梯度
            self.update(gradient_w, gradient_b, eta)  #更新参数
</code></pre> 
<p>将两部分改写的代码集成到Network类中的train函数中，最终的实现如下。</p> 
<pre><code>import numpy as np

class Network(object):
    def __init__(self, num_of_weights):
        # 随机产生w的初始值
        # 为了保持程序每次运行结果的一致性，此处设置固定的随机数种子
        #np.random.seed(0)
        self.w = np.random.randn(num_of_weights, 1)
        self.b = 0.
        
    def forward(self, x):
        z = np.dot(x, self.w) + self.b
        return z
    
    def loss(self, z, y):
        error = z - y
        num_samples = error.shape[0]
        cost = error * error
        cost = np.sum(cost) / num_samples
        return cost
    
    def gradient(self, x, y):
        z = self.forward(x)
        N = x.shape[0]
        gradient_w = 1. / N * np.sum((z-y) * x, axis=0)
        gradient_w = gradient_w[:, np.newaxis]
        gradient_b = 1. / N * np.sum(z-y)
        return gradient_w, gradient_b
    
    def update(self, gradient_w, gradient_b, eta = 0.01):
        self.w = self.w - eta * gradient_w
        self.b = self.b - eta * gradient_b
            
                
    def train(self, training_data, num_epoches, batch_size=10, eta=0.01):
        n = len(training_data)
        losses = []
        for epoch_id in range(num_epoches):
            # 在每轮迭代开始之前，将训练数据的顺序随机的打乱，
            # 然后再按每次取batch_size条数据的方式取出
            np.random.shuffle(training_data)
            # 将训练数据进行拆分，每个mini_batch包含batch_size条的数据
            mini_batches = [training_data[k:k+batch_size] for k in range(0, n, batch_size)]
            for iter_id, mini_batch in enumerate(mini_batches):
                #print(self.w.shape)
                #print(self.b)
                x = mini_batch[:, :-1]
                y = mini_batch[:, -1:]
                a = self.forward(x)
                loss = self.loss(a, y)
                gradient_w, gradient_b = self.gradient(x, y)
                self.update(gradient_w, gradient_b, eta)
                losses.append(loss)
                print('Epoch {:3d} / iter {:3d}, loss = {:.4f}'.
                                 format(epoch_id, iter_id, loss))
        
        return losses

# 获取数据
train_data, test_data = load_data()

# 创建网络
net = Network(13)
# 启动训练
losses = net.train(train_data, num_epoches=50, batch_size=100, eta=0.1)

# 画出损失函数的变化趋势
plot_x = np.arange(len(losses))
plot_y = np.array(losses)
plt.plot(plot_x, plot_y)
plt.show()
</code></pre> 
<p>观察上述Loss的变化，随机梯度下降加快了训练过程，但由于每次仅基于少量样本更新参数和计算损失，所以损失下降曲线会出现震荡。（说明：由于房价预测的数据量过少，所以难以感受到随机梯度下降带来的性能提升。）</p> 
<p>总结<br> 使用神经网络建模房价预测有三个要点：<br> 构建网络，初始化参数w和b，定义预测和损失函数的计算方法。<br> 随机选择初始点，建立梯度的计算方法和参数更新方式。<br> 从总的数据集中抽取部分数据作为一个mini_batch，计算梯度并更新参数，不断迭代直到损失函数几乎不再下降。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/65f63e77dfcf522a86da078dd25d5a0e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在Ubuntu 20.04中安装ROS2最新版本Foxy Fitzroy</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f8e8c94357962b0ecff4d7380e7b9427/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">NLP 中的Mask全解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>