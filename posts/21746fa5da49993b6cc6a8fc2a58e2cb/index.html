<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【云原生】k8s之pod基础（下） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【云原生】k8s之pod基础（下）" />
<meta property="og:description" content="1.pod的镜像拉取策略 1.1 镜像拉取说明 当你在创建容器时会针对指定的镜像来进行容器的创建，所以pod的创建是以镜像为基础。当你在拉取镜向不指定仓库的主机名，Kubernetes 认为你在使用 Docker 公共仓库。
在镜像名称之后，你可以添加一个标签（Tag）（与使用 docker 或 podman 等命令时的方式相同）。 使用标签能让你辨识同一镜像序列中的不同版本。
镜像标签可以包含小写字母、大写字母、数字、下划线（_）、句点（.）和连字符（-）。 关于在镜像标签中何处可以使用分隔字符（_、- 和 .）还有一些额外的规则。 如果你不指定标签，Kubernetes 认为你想使用标签latest
1.2 镜像拉取的策略 首先在资源式声明中存在着imagePullPolicy的字段，它的value决定着k8s创建容器时拉取镜像的方式策略。【此字段所在位置也说明了在声明式yaml中，imagePullPolicy是包含containers中】
kubectl explain pod.spec.containers.imagePullPolicy
如图所示，这三种便是k8s拉取镜像的三种策略：
IfNotPresent
只有当镜像在本地不存在时才会拉取。（先对本地进行排查，本地有该镜像直接使用，本地没有该镜像则选择在仓库中拉取）
Always
总是从仓库拉取镜像，无论本地是否存在镜像（即使本地中存在我们所指定的相关镜像，该策略也会先从仓库中拉取进行应用）
Never
Kubelet 不会尝试获取镜像。如果镜像已经以某种方式存在本地， kubelet 会尝试启动容器；否则，会启动失败。（如果本地不存在，并不会在仓库中拉取，直接报错）
注意：如果没有显式设定的话， Pod 中所有容器的默认镜像拉取策略是IfNotPresent。但是也存在着默认策略选择Always的情况。
此外：
在生产环境中部署容器时，你应该避免使用 :latest 标签，因为这使得正在运行的镜像的版本难以追踪，并且难以正确地回滚。（难以追溯版本，且latest一直会不断迭代更新，给版本维护照成困扰） 1.3 镜像拉取策略的设置操作 （1）Never策略的使用 kubectl run app-test --image=httpd --dry-run=client -o yaml &gt; demo1.yaml
vim demo1.yaml
（2）IfNotPresent策略在本地无镜像的情况下使用 vim demo1.yaml
#查看详细的pod信息，其中也有日志的作用
kubectl describe pod app-test
（3）Always策略 2.pod的启动命令说明 在k8s的容器中也存在着和docker-compose类似的shell启动命令字段，用于pod容器启动后执行命令的操作。 该字段存在containers中：
kubectl explain pod." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/21746fa5da49993b6cc6a8fc2a58e2cb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-30T23:03:17+08:00" />
<meta property="article:modified_time" content="2023-06-30T23:03:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【云原生】k8s之pod基础（下）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%C2%A01.pod%E7%9A%84%E9%95%9C%E5%83%8F%E6%8B%89%E5%8F%96%E7%AD%96%E7%95%A5"><span style="background-color:#ff9900;"> 1.pod的镜像拉取策略</span></h2> 
<h3 id="1.1%20%E9%95%9C%E5%83%8F%E6%8B%89%E5%8F%96%E8%AF%B4%E6%98%8E%C2%A0"><span style="background-color:#a2e043;">1.1 镜像拉取说明 </span></h3> 
<p><strong>当你在创建容器时会针对指定的镜像来进行容器的创建，所以pod的创建是以镜像为基础。当你在拉取镜向不指定仓库的主机名，Kubernetes 认为你在使用 Docker 公共仓库。</strong></p> 
<p><strong>在镜像名称之后，你可以添加一个标签（Tag）（与使用 docker 或 podman 等命令时的方式相同）。 使用标签能让你辨识同一镜像序列中的不同版本。</strong></p> 
<p><strong>镜像标签可以包含小写字母、大写字母、数字、下划线（_）、句点（.）和连字符（-）。 关于在镜像标签中何处可以使用分隔字符（_、- 和 .）还有一些额外的规则。 如果你不指定标签，Kubernetes 认为你想使用标签latest</strong><br>  </p> 
<h3 id="1.2%20%E9%95%9C%E5%83%8F%E6%8B%89%E5%8F%96%E7%9A%84%E7%AD%96%E7%95%A5%C2%A0"><span style="background-color:#a2e043;">1.2 镜像拉取的策略 </span></h3> 
<p><strong> 首先在资源式声明中存在着imagePullPolicy的字段，它的value决定着k8s创建容器时拉取镜像的方式策略。【此字段所在位置也说明了在声明式yaml中，imagePullPolicy是包含containers中】</strong></p> 
<blockquote> 
 <p>kubectl explain pod.spec.containers.imagePullPolicy<br>  </p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8d/6e/ZayMYUWZ_o.png"></p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/28/e3/QU1Wzya8_o.png"></p> 
<p></p> 
<p><strong>如图所示，这三种便是k8s拉取镜像的三种策略：</strong></p> 
<p><span style="color:#fe2c24;"><strong>IfNotPresent</strong></span></p> 
<p><strong>只有当镜像在本地不存在时才会拉取。（先对本地进行排查，本地有该镜像直接使用，本地没有该镜像则选择在仓库中拉取）</strong></p> 
<p><span style="color:#fe2c24;"><strong>Always</strong></span></p> 
<p><strong>总是从仓库拉取镜像，无论本地是否存在镜像（即使本地中存在我们所指定的相关镜像，该策略也会先从仓库中拉取进行应用）</strong></p> 
<p><span style="color:#fe2c24;"><strong>Never</strong></span></p> 
<p><strong>Kubelet 不会尝试获取镜像。如果镜像已经以某种方式存在本地， kubelet 会尝试启动容器；否则，会启动失败。（如果本地不存在，并不会在仓库中拉取，直接报错）</strong><br>  </p> 
<p><strong> 注意：如果没有显式设定的话， Pod 中所有容器的默认镜像拉取策略是IfNotPresent。但是也存在着默认策略选择Always的情况。</strong></p> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>此外：</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>在生产环境中部署容器时，你应该避免使用 <code>:latest</code> 标签，因为这使得正在运行的镜像的版本难以追踪，并且难以正确地回滚。（难以追溯版本，且latest一直会不断迭代更新，给版本维护照成困扰） </strong></span></p> 
<p></p> 
<h3 id="1.3%20%E9%95%9C%E5%83%8F%E6%8B%89%E5%8F%96%E7%AD%96%E7%95%A5%E7%9A%84%E8%AE%BE%E7%BD%AE%E6%93%8D%E4%BD%9C%C2%A0"><span style="background-color:#a2e043;">1.3 镜像拉取策略的设置操作 </span></h3> 
<h4 id="%C2%A0%EF%BC%881%EF%BC%89Never%E7%AD%96%E7%95%A5%E7%9A%84%E4%BD%BF%E7%94%A8">（1）Never策略的使用</h4> 
<blockquote> 
 <p>kubectl run app-test --image=httpd  --dry-run=client -o yaml &gt; demo1.yaml</p> 
 <p>vim demo1.yaml</p> 
</blockquote> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/60/a2/qV6ruc4I_o.png"></p> 
<p></p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c7/a8/H6xjbriO_o.png"></p> 
<p></p> 
<h4 id="%EF%BC%882%EF%BC%89IfNotPresent%E7%AD%96%E7%95%A5%E5%9C%A8%E6%9C%AC%E5%9C%B0%E6%97%A0%E9%95%9C%E5%83%8F%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8">（2）IfNotPresent策略在本地无镜像的情况下使用</h4> 
<blockquote> 
 <p>vim demo1.yaml</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/4f/07/twvzH6ik_o.png"></p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1b/62/emTCJNKS_o.png"></p> 
<p></p> 
<blockquote> 
 <p>#查看详细的pod信息，其中也有日志的作用<br> kubectl describe pod  app-test</p> 
</blockquote> 
<p></p> 
<p><img alt="" height="862" src="https://images2.imgbox.com/29/6c/m4BcVr76_o.png" width="1200"></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/dc/db/qZCELDly_o.png"></p> 
<p></p> 
<p></p> 
<p></p> 
<h4 id="%EF%BC%884%EF%BC%89%E5%86%8D%E6%AC%A1%E4%BD%BF%E7%94%A8Never%E7%AD%96%E7%95%A5%E8%BF%9B%E8%A1%8C%E6%B5%8B%E8%AF%95%C2%A0">（3）Always策略 </h4> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c3/7a/Mcmf9kvC_o.png"></p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e9/68/SsKD9WOX_o.png"></p> 
<p></p> 
<p></p> 
<h2 id="%C2%A02.pod%E7%9A%84%E5%90%AF%E5%8A%A8%E5%91%BD%E4%BB%A4%E8%AF%B4%E6%98%8E"><span style="background-color:#ff9900;"> 2.pod的启动命令说明</span></h2> 
<p></p> 
<p><strong>在k8s的容器中也存在着和docker-compose类似的shell启动命令字段，用于pod容器启动后执行命令的操作。 </strong></p> 
<p><strong>该字段存在containers中：</strong></p> 
<blockquote> 
 <p>kubectl explain pod.spec.containers<br>  </p> 
</blockquote> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/40/63/c1Oz2kSJ_o.png"></p> 
<p></p> 
<p><strong>command，用于在 pod 中的容器初始化完毕之后运行一个命令</strong></p> 
<blockquote> 
 <p> command: ["/bin/sh","-c","touch /tmp/hello.txt"]</p> 
</blockquote> 
<p></p> 
<ul><li><strong>"/bin/sh","-c", 使用sh执行命令</strong></li><li><strong>touch /tmp/hello.txt; 创建一个/tmp/hello.txt 文件</strong></li></ul> 
<p><strong> 该字段还可以运用args进行编写（起到同样的效果）：</strong></p> 
<blockquote> 
 <p>args:<br> - /bin/bash<br> - touch /tmp/hello.txt</p> 
</blockquote> 
<p></p> 
<p><strong>除了 command 参数外，还有一个 args 参数</strong></p> 
<p><strong> command 已经可以完成启动命令和传递参数的功能，为什么这里还要提供一个 args 选项，用于传递参数呢?这其实跟 docker 有点关系，<span style="color:#fe2c24;">kubernetes 中的 command、args 两项其实是实现覆盖 Dockerfile 中 ENTRYPOINT 的功能</span>。</strong><br>  </p> 
<p><span style="color:#ff9900;"><strong>1)如果 command 和 args 均没有写，那么用 Dockerfile 的配置。<br> 2)如果 command 写了，但 args 没有写，那么 Dockerfile 默认的配置会被忽略，执行输入的 command<br> 3)如果 command 没写，但 args 写了，那么 Dockerfile 中配置的 ENTRYPOINT 的命令会被执行，使用当前 args 的参数<br> 4)如果 command 和 args 都写了，那么 Dockerfile 的配置被忽略，执行 command 并追加上 args 参数</strong></span><br>  </p> 
<h2 id="%C2%A03.Pod%20%E5%AE%B9%E5%99%A8%E7%9A%84%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5"><span style="background-color:#ff9900;"> 3.Pod 容器的重启策略</span></h2> 
<p><strong> k8s中重启策略适用于pod对象中的所有容器，首次需要重启的容器，将在其需要时立即进行重启，随后再次需要重启的操作将由kubelet延迟一段时间后进行，且反复的重启操作的延迟时长为10s，20s，40s，80s，160s，300s，  <span style="color:#fe2c24;">300s是最大延迟时长</span></strong></p> 
<blockquote> 
 <p>kubectl explain pod.spec.restartPolicy<br>  </p> 
</blockquote> 
<p></p> 
<p><img alt="" height="796" src="https://images2.imgbox.com/e1/50/4PXBiIaI_o.png" width="1003"></p> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>注意：yaml方式创建Deployment和StatefulSet类型时，restartPolicy只能是Always，kubectl run -个pod可以选择Always,OnFailure,Never三种策略</strong></span></p> 
<p></p> 
<h2 id="%C2%A04.%20pod%E7%9A%84%E7%8A%B6%E6%80%81%E8%AF%B4%E6%98%8E"><span style="background-color:#ff9900;"> 4. pod的状态说明</span></h2> 
<h3 id="%EF%BC%881%EF%BC%89Pod%20%E4%B8%80%E7%9B%B4%E5%A4%84%E4%BA%8EPending%E7%8A%B6%E6%80%81"><span style="background-color:#a2e043;">（1）Pod 一直处于Pending状态</span></h3> 
<p></p> 
<p><strong> Pending状态意味着Pod的YAML文件已经提交给Kubernetes，API对象已经被创建并保存在Etcd当中。但是，这个Pod里有些容器因为某种原因而不能被顺利创建。比如，调度不成功(可以通过kubectl describe pod命令查看到当前Pod的事件，进而判断为什么没有调度)。</strong></p> 
<p><strong>可能原因:资源不足（集群内所有的Node都不满足该Pod请求的CPU、内存、GPU等资源);      HostPort  已被占用(通常推荐使用Service对外开放服务端口)。</strong><br>  </p> 
<h3 id="%EF%BC%882%EF%BC%89Pod%E4%B8%80%E7%9B%B4%E5%A4%84%E4%BA%8EWaiting%20%E6%88%96%20ContainerCreating%E7%8A%B6%E6%80%81"><span style="background-color:#a2e043;">（2）Pod一直处于Waiting 或 ContainerCreating状态</span></h3> 
<p></p> 
<p><strong>首先还是通过 kubectl describe pod命令查看当前Pod的事件。可能的原因有:<br> 1）镜像拉取失败，比如镜像地址配置错误、拉取不了国外镜像源（gcr.io)、私有镜像密钥配置错误、镜像太大导致拉取超时 (可以适当调整kubelet的-image-pull-progress-deadline和-runtime-request-timeout选项)等。<br> 2）CNI网络错误，一般需要检查CNI网络插件的配置，比如:无法配置Pod 网络、无法分配IP地址。<br> 3）容器无法启动，需要检查是否打包了正确的镜像或者是否配置了正确的容器参数<br> 4）Failed create pod sandbox，查看kubelet日志，原因可能是磁盘坏道（input/output error)。</strong><br>  </p> 
<h3 id="%EF%BC%883%EF%BC%89Pod%20%E4%B8%80%E7%9B%B4%E5%A4%84%E4%BA%8EImagePullBackOff%E7%8A%B6%E6%80%81"><span style="background-color:#a2e043;">（3）Pod 一直处于ImagePullBackOff状态</span></h3> 
<p><strong>通常是镜像名称配置错误或者私有镜像的密钥配置错误导致。</strong></p> 
<h4 id="%EF%BC%884%EF%BC%89Pod%20%E4%B8%80%E7%9B%B4%E5%A4%84%E4%BA%8ECrashLoopBackOff%E7%8A%B6%E6%80%81"></h4> 
<h3><span style="background-color:#a2e043;">（4）Pod 一直处于CrashLoopBackOff状态</span></h3> 
<p><strong>此状态说明容器曾经启动了，但又异常退出。这时可以先查看一下容器的日志。<br> 通过命令kubectl logs 和kubectl logs --previous 可以发下一些容器退出的原因，比如:容器进程退出、健康检查失败退出;此时如果还未发现线索，还而已到容器内执行命令(kubectl exec cassandra - cat /var.log/cassandra/system.loq)来进一步查看退出原因;如果还是没有线索，那就需要SSH登录该Pod所在的Node上，查看Kubelet或者Docker的日志进一步排查。</strong><br>  </p> 
<h3 id="%EF%BC%885%EF%BC%89%C2%A0%20Pod%E5%A4%84%E4%BA%8EError%E7%8A%B6%E6%80%81"><span style="background-color:#a2e043;">（5）  Pod处于Error状态</span></h3> 
<p><strong>通常处于Error状态说明Pod启动过程中发生了错误。</strong></p> 
<p><strong>常见的原因:依赖的ConfigMap、Secret或PV等不存在;请求的资源超过了管理员设置的限制，比如超过了LimitRange等;违反集群的安全策略，比如违反了PodSecurityPolicy.等;容器无法操作集群内的资源，比如开启RDAC后，需要为ServiceAccount配置角色绑定。</strong><br>  </p> 
<h3><span style="background-color:#a2e043;">（6）  Pod 处于Terminating或 Unknown状态</span></h3> 
<p><br><strong> 从v1.5开始，Kubernetes不会因为Node失联而删除其上正在运行的Pod，而是将其标记为Terminating 或 Unknown 状态。想要删除这些状态的Pod有三种方法：</strong></p> 
<p><strong>1）从集群中删除Node。使用公有云时，kube-controller-manager会在VM删除后自动删除对应的Node。而在物理机部署的集群中，需要管理员手动删除Node（kubectl delete node）。</strong></p> 
<p><strong>2）Node恢复正常。kubelet会重新跟kube-apiserver通信确认这些Pod的期待状态，进而再决定删除或者继续运行这些Pod。用户强制删除，用户可以执行（kubectl delete pods pod-name --grace-period=0 --force）强制删除Pod。除非明确知道Pod的确处于停止状态（比如Node所在VM或物理机已经关机），否则不建议使用该方法。特别是StatefulSet 管理的Pod，强制删除容易导致脑裂或数据丢失等问题。</strong></p> 
<p><strong>3）Pod行为异常，这里所说的行为异常是指Pod没有按预期的行为执行，比如没有运行podSpec 里面设置的命令行参数。这一般是podSpec yaml文件内容有误，可以尝试使用 --validate 参数重建容器，比如（kubectl delete pod mypod 和 kubectl create --validate -f mypod.yaml）；也可以查看创建后的podSpec是否是对的，比如（kubectl get pod mypod -o yaml）；修改静态Pod的Manifest后未自动重建，kubelet 使用inotify 机制检测 /etc/kubernetes/manifests 目录（可通过 kubelet 的 -pod-manifest-path 选项指定）中静态Pod的变化，并在文件发生变化后重新创建相应的 Pod。但有时也会发现修改静态Pod的 Manifest后未自动创建新 Pod的情景，此时已过简单的修复方法是重启 Kubelet。</strong></p> 
<p><strong>Unknown 这个异常状态意味着Pod的状态不能持续地被 kubelet汇报给 kube-apiserver，这很有可能是主从节点（Master 和 Kubelet）间的通信出现了问题。</strong><br>  </p> 
<h3><span style="background-color:#a2e043;">（7）pod从创建到成功或失败的事件</span></h3> 
<p><strong>PodScheduled<br> pod正处于调度中，刚开始调度的时候，hostip还没绑定上，持续调度之后，有合适的节点就会绑定hostip，然后更新etcd数据<br> Initialized<br> pod中的所有初始化容器已经初启动完毕</strong></p> 
<p><strong>Ready<br> pod中的容器可以提供服务了</strong></p> 
<p><strong>Unschedulable<br> 不能调度，没有合适的节点</strong><br>  </p> 
<blockquote> 
 <p> <br> CrashLoopBackOff：    容器退出，kubelet正在将它重启<br> InvalidImageName：    无法解析镜像名称<br> ImageInspectError：   无法校验镜像<br> ErrImageNeverPull：   策略禁止拉取镜像<br> ImagePullBackOff：    正在重试拉取<br> RegistryUnavailable： 连接不到镜像中心<br> ErrImagePull：        通用的拉取镜像出错<br> CreateContainerConfigError： 不能创建kubelet使用的容器配置<br> CreateContainerError： 创建容器失败<br> m.internalLifecycle.PreStartContainer 执行hook报错<br> RunContainerError：   启动容器失败<br> PostStartHookError：   执行hook报错<br> ContainersNotInitialized： 容器没有初始化完毕<br> ContainersNotReady：   容器没有准备完毕<br> ContainerCreating：    容器创建中<br> PodInitializing：pod   初始化中<br> DockerDaemonNotReady：  docker还没有完全启动<br> NetworkPluginNotReady： 网络插件还没有完全启动<br> Evicte:     pod被驱赶</p> 
 <p></p> 
</blockquote> 
<p></p> 
<p></p> 
<h2 id="%C2%A05.%C2%A0Pod%20%E5%AE%B9%E5%99%A8%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span style="background-color:#ff9900;">5. Pod 容器资源限制</span></h2> 
<p></p> 
<h3><span style="background-color:#a2e043;">5.1 资源限制的了解 </span></h3> 
<p><br><strong>  在我前面Docker的Cgroup文章中，就提到过，为什么我们对容器进行资源限制。同理：首先K8s中pod使用宿主机的资源默认情况下是无节制的，但是当一个集群搭建成功后并投入生产环境中。如果其中的某一个pod因为不明原因出现了bug，疯狂占用宿主机资源，抢占其他pod的资源。势必会导致整个集群的瘫痪，所以pod资源的限制是非常有必要的</strong></p> 
<p><strong> 在资源控制器中我们也可以准确的找到相应的资源控制字段：</strong><br>  </p> 
<blockquote> 
 <p>kubectl explain deployment.spec.template.spec.containers.resources<br> kubectl explain  statefulset.spec.template.spec.containers.resources<br>  </p> 
</blockquote> 
<p><strong>在官方文档中（<a href="https://kubernetes.io/zh-cn/docs/concepts/policy/resource-quotas/" rel="nofollow" title="资源配额 | Kubernetes">资源配额 | Kubernetes</a>） 我们可以得知：pod控制的资源总共为三大类：</strong></p> 
<p><strong>cpu，memory，hugepages（巨页）。其中我们运用最多的限制还是cpu和memory。</strong></p> 
<p></p> 
<h4><strong><span style="background-color:#a2e043;">（1）cpu限制的参数了解</span></strong></h4> 
<p><br><strong> pod对于cpu限制的参数有两种表达形式：</strong></p> 
<p><strong>第一种是指定个数的表达形式，例如：1 ，2， 0.5 ，0.2 ，0.3 指定cpu的个数（该个数可以为整数，也可以为小数点后一位的小数）</strong></p> 
<p><strong>第二种是以毫核为单位的表达形式：100m  500m   1000m   2000m （<span style="color:#fe2c24;">这里1000m等价于一个cpu</span>，该方式来自于cpu时间分片原理得来） </strong><br>  </p> 
<h4><strong><span style="background-color:#a2e043;">（2）memory的表达形式 </span></strong></h4> 
<p><br><strong>pod对内存参数的要求十分严谨。对硬件有过研究的朋友，应该会了解到,我们常常提到的GB，MB,TB其实是于实际字节总数是有误差的（原因是GB是以10为底数计量，而真正的换算是以2为底数计量。导致了总量的误差。）而真正没有此误差的单位是Ki  Mi  Gi  Ti </strong></p> 
<p><span style="color:#fe2c24;"><strong>所以k8s中pod资源限制为了对pod的内存限制更为精准，采用的单位是 Ki  Mi  Gi  Ti </strong></span><br>  </p> 
<p></p> 
<h3 id="5.2%20%E5%AE%9E%E4%BE%8B%E8%BF%90%E7%94%A8%C2%A0"><span style="background-color:#a2e043;">5.2 实例运用 </span></h3> 
<p></p> 
<p><strong> 需求：创建一个deployment资源，镜像使用nginx:latest，创建3个pod副本，镜像拉取策略使用IfNotPresent，重启策略使用Always，容器资源预留cpu 0.25个，内存128MiB，上限最多1个cpu，1g内存</strong></p> 
<pre><code class="hljs">kubectl create deployement nginx-test --images=nginx:latest  --dry-run=client -o yaml &gt;test.yaml
vim test.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: nginx-test
  name: nginx-test
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx-test
  template:
    metadata:
      labels:
        app: nginx-test
    spec:
      containers:
      - image: nginx:latest
        name: nginx
        resources:
          requests:
            memory: "128Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "1"
        imagePullPolicy: IfNotPresent
      restartPolicy: Always
 
 
kubectl apply -f test.yaml</code></pre> 
<p style="text-align:center;"></p> 
<p> </p> 
<p></p> 
<blockquote> 
 <p>#查看pod的资源使用情况<br> kubectl describe pod nginx-test</p> 
</blockquote> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/fd/51/NocElu2y_o.png"></p> 
<p> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/ee/74/9RgnWMgE_o.png"></p> 
<p> </p> 
<p></p> 
<p></p> 
<h2 id="%C2%A06.%C2%A0Pod%20%E5%AE%B9%E5%99%A8%E7%9A%84%E6%8E%A2%E9%92%88"><span style="background-color:#ff9900;">6. Pod 容器的探针</span></h2> 
<p></p> 
<h3><strong><span style="background-color:#a2e043;">6.1 探针的概念及其作用 </span></strong></h3> 
<p><br><strong> 探针是由 kubelet 对容器执行的定期诊断（pod中探针又分为三类）:</strong></p> 
<p><strong> <span style="color:#fe2c24;">存活探针</span>（livenessProbe）探测容器是否运行正常。如果探测失败则kubelet杀掉容器（不是Pod），容器会根据重启策略决定是否重启</strong></p> 
<p><strong><span style="color:#fe2c24;">就绪探针</span>（readinessProbe）探测Pod是否能够进入READY状态，并做好接收请求的准备。如果探测失败Pod则会进入NOTREADY状态（READY为0/1）并且从所关联的service资源的端点（endpoints）中踢出，service将不会再把访问请求转发给这个Pod</strong></p> 
<p><strong><span style="color:#fe2c24;">启动探针</span>（startupProbe）探测容器内的应用是否启动成功，在启动探针探测成功之前，其它类型的探针都会暂时处于禁用状态 </strong><br>  </p> 
<p><span style="color:#fe2c24;"><strong>注意：启动探针只是在容器启动后按照配置满足一次后就不再进行后续的探测了。存活探针和就绪探针会一直探测到Pod生命周期结束为止</strong></span></p> 
<blockquote> 
 <p>kubectl explain pod.spec.containers</p> 
</blockquote> 
<p><img alt="" height="883" src="https://images2.imgbox.com/64/55/bO9OUVI4_o.png" width="1162"></p> 
<p></p> 
<p> </p> 
<h3><span style="background-color:#a2e043;">6.2 探针的探测方式 </span></h3> 
<p><br><span style="color:#fe2c24;"><strong>exec : 通过command字段设置在容器内执行的Linux命令来进行探测，如果命令返回码为0，则认为探测成功，返回码非0则探测失败</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>httpGet : 通过向容器的指定端口和uri路径发起HTTP GET请求，如果HTTP返回状态码为 &gt;=200且&lt;400的（2XX,3XX），则认为探测成功，返回状态码为4XX,5XX则探测失败</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>tcpSocket1 : 通过向容器的指定端口发送tcp三次握手连接，如果端口正确却tcp连接成功，则认为探测成功，tcp连接失败则探测失败 </strong></span></p> 
<p><span style="color:#ff9900;"><strong>探针探测结果有以下值：<br> Success：表示通过检测。<br> Failure：表示未通过检测。<br> Unknown：表示检测没有正常进行。 </strong></span><br>  </p> 
<h3><strong><span style="background-color:#a2e043;">6.3 探针字段 </span></strong></h3> 
<p><br><strong> 探针(Probe)有许多可选字段，可以用来更加精确的控制<span style="color:#fe2c24;">Liveness</span>和<span style="color:#fe2c24;">Readiness</span>两种探针的行为(Probe)：</strong></p> 
<p><strong><span style="color:#fe2c24;">(1)initialDelaySeconds：容器启动后要等待多少秒后就探针开始工作，单位“秒”，默认是 0s，最小值是 0s;</span></strong></p> 
<p><strong><span style="color:#fe2c24;">(2)periodSeconds：执行探测的时间间隔（单位是秒），默认为 10s，最小值是 1s，</span></strong></p> 
<p><strong>(3)timeoutSeconds：探针执行检测请求后，等待响应的超时时间，默认为 1s，最小值是 1s，</strong></p> 
<p><br><strong>(4)successThreshold：探针检测失败后认为成功的最小连接成功次数，默认为 1，在 Liveness和startup探针中必须为 1，最小值为 1。</strong></p> 
<p><br><strong><span style="color:#fe2c24;">(5)failureThreshold：探测失败的重试次数，重试一定次数后将认为失败，默认为 3，最小值为 1</span></strong><br>  </p> 
<h3><span style="background-color:#a2e043;">6.4 探针实验测试 </span></h3> 
<h3 id="%C2%A0%EF%BC%881%EF%BC%89LivenessProbe%20%E6%8E%A2%E9%92%88%E4%BD%BF%E7%94%A8"><span style="background-color:#a2e043;">（1）</span><strong><span style="background-color:#a2e043;">LivenessProbe 探针使用</span></strong></h3> 
<h4 id="1)%C2%A0%E9%80%9A%E8%BF%87exec%E6%96%B9%E5%BC%8F%E5%81%9A%E5%81%A5%E5%BA%B7%E6%8E%A2%E6%B5%8B%C2%A0"><span style="background-color:#a2e043;">1) </span><strong><span style="background-color:#a2e043;">通过exec方式做健康探测</span></strong><span style="background-color:#a2e043;"> </span></h4> 
<pre><code class="hljs">apiVersion: v1
kind: Pod
metadata:
  name: demo-live
  labels:
    app: demo-live
spec:
  containers:
  - name: demo-live
    image: centos:7
    args:                       #创建测试探针探测的文件
    - /bin/sh
    - -c
    - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600
    livenessProbe:
      initialDelaySeconds: 10   #延迟检测时间
      periodSeconds: 5          #检测时间间隔
      exec:                     #使用命令检查
        command:                #指令，类似于运行命令sh
        - cat                   #sh 后的第一个内容，直到需要输入空格，变成下一行

        - /tmp/healthy          #由于不能输入空格，需要另外声明，结果为sh cat"空格"/tmp/healthy
 
 
 
</code></pre> 
<p><strong>容器在初始化后，执行（/bin/sh -c "touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy; sleep 600"）首先创建一个 /tmp/healthy 文件，然后执行睡眠命令，睡眠 30 秒，到时间后执行删除 /tmp/healthy 文件命令。而设置的存活探针检检测方式为执行 shell 命令，用 cat 命令输出 healthy 文件的内容，如果能成功执行这条命令一次(默认successThreshold:1)，存活探针就认为探测成功，由于没有配置(failureThreshold、timeoutSeconds)，所以执行（cat /tmp/healthy）并只等待1s，如果1s内执行后返回失败，探测失败。在前 30 秒内，由于文件存在，所以存活探针探测时执行 cat /tmp/healthy 命令成功执行。30 秒后 healthy 文件被删除，所以执行命令失败，Kubernetes 会根据 Pod 设置的重启策略来判断，是否重启 Pod。</strong><br>  </p> 
<h4 id="2)%E9%80%9A%E8%BF%87HTTP%E6%96%B9%E5%BC%8F%E5%81%9A%E5%81%A5%E5%BA%B7%E6%8E%A2%E6%B5%8B%C2%A0"><span style="background-color:#a2e043;">2)</span><strong><span style="background-color:#a2e043;">通过HTTP方式做健康探测</span></strong><span style="background-color:#a2e043;"> </span></h4> 
<blockquote> 
 <p>apiVersion: v1<br> kind: Pod<br> metadata:<br>   name: liveness-http<br>   labels:<br>     test: liveness<br> spec:<br>   containers:<br>   - name: liveness<br>     image: mydlqclub/springboot-helloworld:0.0.1<br>     livenessProbe:<br>       failureThreshold: 5       #检测失败5次表示未就绪<br>       initialDelaySeconds: 20   #延迟加载时间<br>       periodSeconds: 10          #重试时间间隔<br>       timeoutSeconds: 5         #超时时间设置<br>       successThreshold: 2       #检查成功为2次表示就绪<br>       httpGet:<br>         scheme: HTTP           # 用于连接host的协议，默认为HTTP。<br>         port: 8081             #容器上要访问端口号或名称。<br>         path: /actuator/health    #http服务器上的访问URI。<br>  <br>  <br> 此外：<br>  <br> host：要连接的主机名，默认为Pod IP，可以在http request head中设置host头部。<br>  <br> httpHeaders：自定义HTTP请求headers，HTTP允许重复headers<br>  <br>  <br> #####过程了解##########################<br>  <br>  <br>  Pod 中启动的容器是一个 SpringBoot 应用，其中引用了 Actuator 组件，提供了 /actuator/health 健康检查地址，在pod启动后，初始化等待20s后，livenessProbe开始工作，去请求HTTP://podIP:8081/actuator/health 接口，类似于curl -I HTTP://podIP:8081/actuator/health接口,考虑到请求会有延迟(curl -I后一直出现假死状态)，所以给这次请求操作一直持续5s，如果5s内访问返回数值在&gt;=200且&lt;=400代表第一次检测success，如果是其他的数值，或者5s后还是假死状态，执行类似（ctrl+c）中断，并反回failure失败。等待10s后，再一次的去请求HTTP://podIP:8081/actuator/health接口。如果有连续的2次都是success，代表无问题。如果期间有连续的5次都是failure，代表有问题，直接重启pod，此操作会伴随pod的整个生命周期</p> 
</blockquote> 
<p></p> 
<h4 id="%C2%A03%EF%BC%89%E9%80%9A%E8%BF%87TCP%E6%96%B9%E5%BC%8F%E5%81%9A%E5%81%A5%E5%BA%B7%E6%8E%A2%E6%B5%8B"><span style="background-color:#a2e043;">3）</span><strong><span style="background-color:#a2e043;">通过TCP方式做健康探测</span></strong></h4> 
<blockquote> 
 <p>apiVersion: v1<br> kind: Pod<br> metadata:<br>   name: liveness-tcp<br>   labels:<br>     app: liveness<br> spec:<br>   containers:<br>   - name: liveness<br>     image: nginx<br>     livenessProbe:<br>       initialDelaySeconds: 15<br>       periodSeconds: 20<br>       tcpSocket:<br>         port: 80<br>  <br> #########过程解析#####################<br>  <br>  <br> TCP 检查方式和 HTTP 检查方式非常相似，在容器启动 initialDelaySeconds 参数设定的时间后，kubelet 将发送第一个 livenessProbe 探针，尝试连接容器的 80 端口，类似于telnet 80端口，如果连接失败则将杀死 Pod 重启容器。</p> 
</blockquote> 
<p></p> 
<h3 id="%C2%A0%EF%BC%882%EF%BC%89ReadinessProbe%20%E6%8E%A2%E9%92%88%E4%BD%BF%E7%94%A8"><span style="background-color:#a2e043;">（2）</span><strong><span style="background-color:#a2e043;">ReadinessProbe 探针使用</span></strong></h3> 
<p><strong>  livenessProbe+readinessProbe通过httpGet探测方法的实验过程：</strong></p> 
<p><strong> 本次过程我将nginx的网页目录中index.html修改为test.html。并写下了下面的资源yaml进行测试</strong></p> 
<p></p> 
<blockquote> 
 <p>apiVersion: v1<br> kind: Pod<br> metadata:<br>   name: myapp-test4<br> spec:<br>   containers:<br>   - image: nginx:1.14<br>     imagePullPolicy: IfNotPresent<br>     name: myapp-test4<br>     ports:<br>     - containerPort: 80<br>       name: http<br>     livenessProbe:<br>       httpGet:<br>         port: http<br>         path: /index.html<br>       initialDelaySeconds: 5<br>       periodSeconds: 4<br>       failureThreshold: 2<br>     readinessProbe:<br>       httpGet:<br>         port: 80<br>         path: /test.html<br>       initialDelaySeconds: 1<br>       periodSeconds: 3<br>       failureThreshold: 3<br>       timeoutSeconds: 10<br>   restartPolicy: Always<br>  </p> 
</blockquote> 
<p></p> 
<p><strong>该过程：</strong></p> 
<p><strong>（1）首先是就绪探针在容器重启1s后进行httpGet方式探测，寻找到了 test.html网页验证成功。将该Pod 标记为就绪状态，kubelet 将继续每隔 10 秒运行一次探测。 </strong></p> 
<p><strong> （2）除此之外我还设置了存活探针，存活探针在容器启动的5s后，进行httpGet探测，因为默认网页被修改的缘故，找不到index.html,随后继续了两次4s间隔的探测，依旧没有发现uri目标网页。根据重启策略重启容器（该过程实际上就是删除原有pod，根据镜像拉取新的pod）。</strong></p> 
<p><strong>（3）由于容器被重启，所以一切恢复默认初始化，此时默认的网页目录只存在Index.html,不在存在test.html。所以本次中就绪探针的httpGet进行uri的探测失败，此后期间会做出3次间隔3s的重复探测，最终均为失败。该pod则会进入NOTREADY状态，并且从所关联的service资源的端点（endpoints）中踢出，该pod将彻底称为notready状态，后面的就绪探针也就不在进行探测。</strong><br>  </p> 
<p></p> 
<h3 id="%EF%BC%883%EF%BC%89%E5%90%AF%E5%8A%A8%E6%8E%A2%E9%92%88%E7%9A%84%E4%BD%BF%E7%94%A8%C2%A0"><span style="background-color:#a2e043;">（3）启动探针的使用 </span></h3> 
<p></p> 
<p><strong>启动探针存在的必要：</strong></p> 
<p><strong>有时候，会有一些现有的应用在启动时需要较长的初始化时间。 要这种情况下，若要不影响对死锁作出快速响应的探测，设置存活探测参数是要技巧的。 技巧就是使用相同的命令来设置启动探测，针对 HTTP 或 TCP 检测，可以通过将 failureThreshold * periodSeconds 参数设置为足够长的时间来应对糟糕情况下的启动时间。（因为启动探针在启动后，其他的两种探针就会进入短暂的禁用装态，于是给容器启动预留了充足的时间，保证容器中业务启动的顺利进行。而且启动探针只会启动一次，后续工作就完全交给其他两个探针，直到容器的生命周期结束）。</strong><br>  </p> 
<blockquote> 
 <p>ports:<br> - name: liveness-port<br>   containerPort: 8080<br>   hostPort: 8080<br>  <br> livenessProbe:<br>   httpGet:<br>     path: /healthz<br>     port: liveness-port<br>   failureThreshold: 1<br>   periodSeconds: 10<br>  <br> startupProbe:<br>   httpGet:<br>     path: /healthz<br>     port: liveness-port<br>   failureThreshold: 30<br>   periodSeconds: 10</p> 
</blockquote> 
<p></p> 
<p><strong>在这里，幸亏有了启动探测，应用程序将会有最多 5 分钟（30 * 10 = 300s）的时间来完成其启动过程。 一旦启动探测成功一次，存活探测任务就会接管对容器的探测，对容器死锁作出快速响应。 如果启动探测一直没有成功，容器会在 300 秒后被杀死，并且根据 restartPolicy 来执行进一步处置。</strong><br>  </p> 
<p></p> 
<p></p> 
<h2 id="%C2%A07.Pod%20%E5%AE%B9%E5%99%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E5%92%8C%E9%80%80%E5%87%BA%E5%8A%A8%E4%BD%9C"><span style="background-color:#ff9900;"> 7.Pod 容器的启动和退出动作</span></h2> 
<p><strong>postStart    配置 exec.command 字段设置 Linux 命令，实现当应用容器启动时，会执行的额外操作</strong></p> 
<p><strong>preStop      配置 exec.command 字段设置 Linux 命令，实现当应用容器退出时，会执行的最后一个操作</strong></p> 
<h4 id="%E5%AE%9E%E4%BE%8B%E8%BF%90%E7%94%A8"><span style="background-color:#a2e043;">实例运用</span></h4> 
<blockquote> 
 <p>apiVersion: v1<br> kind: Pod<br> metadata:<br>   name: lifecycle-demo<br> spec:<br>   containers:<br>   - name: lifecycle-demo-container<br>     image: soscscs/myapp:v1<br>     lifecycle:   #此为关键字段<br>       postStart:<br>         exec:<br>           command: ["/bin/sh", "-c", "echo Hello from the postStart handler &gt;&gt; /var/log/nginx/message"]      <br>       preStop:<br>         exec:<br>           command: ["/bin/sh", "-c", "echo Hello from the prestop handler &gt;&gt; /var/log/nginx/message"]<br>     volumeMounts:<br>     - name: message-log<br>       mountPath: /var/log/nginx/<br>       readOnly: false<br>   initContainers:<br>   - name: init-myservice<br>     image: soscscs/myapp:v1<br>     command: ["/bin/sh", "-c", "echo 'Hello initContainers'   &gt;&gt; /var/log/nginx/message"]<br>     volumeMounts:<br>     - name: message-log<br>       mountPath: /var/log/nginx/<br>       readOnly: false<br>   volumes:<br>   - name: message-log<br>     hostPath:<br>       path: /data/volumes/nginx/log/<br>       type: DirectoryOrCreate</p> 
</blockquote> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1d45b709b8f1d03f31fbac529129625f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">主成分分析法及spss实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/46ad28f183d63f27601342e3ad92ef6d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring Boot 中的 @Field 注解详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>