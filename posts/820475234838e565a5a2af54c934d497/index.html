<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring security之授权 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring security之授权" />
<meta property="og:description" content="前言 本篇为大家带来Spring security的授权，首先要理解一些概念，有关于：权限、角色、安全上下文、访问控制表达式、方法级安全性、访问决策管理器
一.授权的基本介绍 Spring Security 中的授权分为两种类型：
基于角色的授权：以用户所属角色为基础进行授权，如管理员、普通用户等，通过为用户分配角色来控制其对资源的访问权限。
基于资源的授权：以资源为基础进行授权，如 URL、方法等，通过定义资源所需的权限，来控制对该资源的访问权限。
Spring Security 提供了多种实现授权的机制，最常用的是使用基于注解的方式，建立起访问资源和权限之间的映射关系。
其中最常用的两个注解是 @Secured 和 @PreAuthorize。@Secured 注解是更早的注解，基于角色的授权比较适用，@PreAuthorize 基于 SpEL 表达式的方式，可灵活定义所需的权限，通常用于基于资源的授权。
二.修改User配置角色和权限 方法一. 使用SQL语句的方式查询该角色的权限，并且可以对它进行修改
根据用户id查询出对应的角色信息
SELECT * FROM sys_user a, sys_user_role b, sys_role_module c, sys_module d WHERE a.id = b.user_id and b.role_id=c.role_id and c.module_id = d.id and a.id=#{id} 根据用户ID查询出角色对应的权限信息
select m.url from sys_user u,sys_user_role ur,sys_role r,sys_role_module rm,sys_module m where u.id=ur.userid and ur.roleid=r.roleid and r.roleid=rm.roleid and rm.moduleid=m.id and u.id=#{userid} and url is not null 但是并不推荐使用这种方法，当我们在实际开发中，要考虑到不同的数据表可能来自不同的库中，使用SQL查询时就会出现链表查询不同库的表的情况，所以，更多的时候我们会使用Java利用不同的操作对表进行依次查询作为条件最终得到结果" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/820475234838e565a5a2af54c934d497/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-23T16:25:15+08:00" />
<meta property="article:modified_time" content="2023-12-23T16:25:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring security之授权</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>前言</h2> 
<p>本篇为大家带来Spring security的授权，首先要理解一些概念，有关于：权限、角色、安全上下文、访问控制表达式、方法级安全性、访问决策管理器</p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/ac/0c/A3tp9PBE_o.png" width="900"></p> 
<h2>一.授权的基本介绍</h2> 
<p>Spring Security 中的授权分为两种类型：</p> 
<ul><li> <p><strong>基于角色的授权</strong>：以用户所属角色为基础进行授权，如管理员、普通用户等，通过为用户分配角色来控制其对资源的访问权限。</p> </li><li> <p><strong>基于资源的授权</strong>：以资源为基础进行授权，如 URL、方法等，通过定义资源所需的权限，来控制对该资源的访问权限。</p> </li></ul> 
<p>Spring Security 提供了多种实现授权的机制，最常用的是使用基于注解的方式，建立起访问资源和权限之间的映射关系。</p> 
<p>其中最常用的两个注解是 <code>@Secured</code> 和 <code>@PreAuthorize</code>。<code>@Secured</code> 注解是更早的注解，基于角色的授权比较适用，<code>@PreAuthorize</code> 基于 <code>SpEL</code> 表达式的方式，可灵活定义所需的权限，通常用于基于资源的授权。</p> 
<h2>二.修改User配置角色和权限</h2> 
<h3>方法一.</h3> 
<p>使用SQL语句的方式查询该角色的权限，并且可以对它进行修改</p> 
<p>根据用户id查询出对应的角色信息</p> 
<pre><code class="language-sql"> SELECT
            *
        FROM
            sys_user a,
            sys_user_role b,
            sys_role_module c,
            sys_module d
        WHERE a.id = b.user_id and
            b.role_id=c.role_id and
            c.module_id = d.id and
            a.id=#{id}</code></pre> 
<p> </p> 
<p>根据用户ID查询出角色对应的权限信息</p> 
<pre><code class="language-sql">select
	m.url
from
	sys_user u,sys_user_role ur,sys_role r,sys_role_module rm,sys_module m
where
    u.id=ur.userid and ur.roleid=r.roleid and
    r.roleid=rm.roleid and rm.moduleid=m.id and
    u.id=#{userid} and url is not null</code></pre> 
<blockquote> 
 <p>但是并不推荐使用这种方法，当我们在实际开发中，要考虑到不同的数据表可能来自不同的库中，使用SQL查询时就会出现链表查询不同库的表的情况，所以，更多的时候我们会使用Java利用不同的操作对表进行依次查询作为条件最终得到结果</p> 
</blockquote> 
<h3>方法二.利用Java对表单一查询然后作为查询条件，最终查询出结果</h3> 
<pre><code class="language-java">@Service
public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements IUserService, UserDetailsService {

    @Autowired
    private IUserRoleService userRoleService;
    @Autowired
    private IRoleService roleService;
    @Autowired
    private IRoleModuleService roleModuleService;
    @Autowired
    private IModuleService moduleService;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = getOne(new QueryWrapper&lt;User&gt;().eq("username", username));
        if(user==null){
            throw new UsernameNotFoundException("用户名无效");
        }
        //查询出身份
        //map遍历所有对象，返回新的数据放到新的集合中
        //filter 过滤流中的内容
        //collect将流中的元素变成一个集合
        List&lt;Integer&gt; role_ids = userRoleService
                .list(new QueryWrapper&lt;UserRole&gt;().eq("user_id", user.getId()))
                .stream().map(UserRole::getRoleId)
                .collect(Collectors.toList());
        //根据身份字段查询身份对应的名字字段
        List&lt;String&gt; roles = roleService
                .list(new QueryWrapper&lt;Role&gt;())
                .stream().map(Role::getRoleName)
                .collect(Collectors.toList());
        //根据身份id查询具备的权限id
        List&lt;Integer&gt; module_ids = roleModuleService
                .list(new QueryWrapper&lt;RoleModule&gt;().in("role_id", role_ids))
                .stream().map(RoleModule::getModuleId)
                .collect(Collectors.toList());
        //根据权限id查询对应的权限
        List&lt;String&gt; modules = moduleService
                .list(new QueryWrapper&lt;Module&gt;().in("id", module_ids))
                .stream().map(Module::getUrl)
                .collect(Collectors.toList());
        // 将权限字段加到身份中
        roles.addAll(modules);
        //将当前集合内容加到权限字段中
        List&lt;SimpleGrantedAuthority&gt; authorities = roles.stream()
                .map(SimpleGrantedAuthority::new)
                .filter(Objects::nonNull)
                .collect(Collectors.toList());
        user.setAuthorities(authorities);
        return user;
    }
}</code></pre> 
<h2>三.SpringSecurity配置类</h2> 
<p>当我们想要开启<code>spring</code>方法级安全时，只需要在任何 <code>@Configuration</code>实例上使用<code>@EnableGlobalMethodSecurity</code> 注解就能达到此目的。同时这个注解为我们提供了<code>prePostEnabled</code> 、<code>securedEnabled</code> 和 <code>jsr250Enabled</code> 三种不同的机制来实现同一种功能。</p> 
<p>修改<code>WebSecurityConfig</code>配置类，开启基于方法的安全认证机制，也就是说在web层的controller启用注解机制的安全确认。</p> 
<pre><code class="language-java">@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class WebSecurityConfig {

    @Autowired
    private UserServiceImpl userDetailsService;
    @Autowired
    private ObjectMapper objectMapper;
    @Autowired
    private MyAuthenticationFailureHandler myAuthenticationFailureHandler;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager() throws Exception {
        //创建DaoAuthenticationProvider
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        //设置userDetailsService，基于数据库方式进行身份认证
        provider.setUserDetailsService(userDetailsService);
        //配置密码编码器
        provider.setPasswordEncoder(passwordEncoder());
        return new ProviderManager(provider);
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.authorizeRequests()
                //antMatchers 匹配对应的路径
                //permitAll 允许
                .antMatchers("/").permitAll()
                //anyRequest 其余所有请求
                //authenticated 登录
                .anyRequest().authenticated()
                .and()
                .formLogin()
                //loginPage 登录页面
                .loginPage("/")
                //设置处理登录请求的接口
                .loginProcessingUrl("/userLogin")
                //用户的数据的参数
                .usernameParameter("username")
                .passwordParameter("password")
                //登录成功
                .successHandler((req, resp, auth) -&gt; {
                    Object user = auth.getPrincipal();
                    objectMapper
                            .writeValue(resp.getOutputStream(), JsonResponseBody.success(user));
                })
                //登录失败
                .failureHandler(myAuthenticationFailureHandler)
                .and()
                .exceptionHandling()
                //权限不足
                .accessDeniedHandler((req, resp, ex) -&gt; {
                    objectMapper
                            .writeValue(resp.getOutputStream(), JsonResponseBody.other(JsonResponseStatus.NO_ACCESS));
                })
                //没有认证
                .authenticationEntryPoint((req, resp, ex) -&gt; {
                    objectMapper
                            .writeValue(resp.getOutputStream(), JsonResponseBody.other(JsonResponseStatus.NO_LOGIN));
                })
                .and()
                .logout()
                .logoutUrl("/logout")
                .logoutSuccessUrl("/");
        http.csrf().disable();
        return http.build();
    }

}</code></pre> 
<blockquote> 
 <p>这里需要注意的是：<code>@EnableGlobalMethodSecurity</code>是Spring Security提供的一个注解，用于启用方法级别的安全性。它可以在任何@Configuration类上使用，以启用Spring Security的方法级别的安全性功能。它接受一个或多个参数，用于指定要使用的安全注解类型和其他选项。以下是一些常用的参数</p> 
 <ul><li> <p><code>prePostEnabled</code>：如果设置为<code>true</code>，则启用<code>@PreAuthorize</code>和<code>@PostAuthorize</code>注解。默认值为<code>false</code>。</p> </li><li> <p><code>securedEnabled</code>：如果设置为<code>true</code>，则启用<code>@Secured</code>注解。默认值为<code>false</code>。</p> </li><li> <p><code>jsr250Enabled</code>：如果设置为<code>true</code>，则启用<code>@RolesAllowed</code>注解。默认值为<code>false</code>。</p> </li><li> <p><code>proxyTargetClass</code>：如果设置为<code>true</code>，则使用CGLIB代理而不是标准的JDK动态代理。默认值为<code>false</code>。</p> </li></ul> 
 <p>使用<code>@EnableGlobalMethodSecurity</code>注解后，可以在应用程序中使用Spring Security提供的各种注解来保护方法，例如<code>@Secured</code>、<code>@PreAuthorize</code>、<code>@PostAuthorize</code>和<code>@RolesAllowed</code>。这些注解允许您在方法级别上定义安全规则，以控制哪些用户可以访问哪些方法。</p> 
</blockquote> 
<p><strong>注解介绍：</strong></p> 
<table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td><code>@PreAuthorize</code></td><td>用于在方法执行之前对访问进行权限验证</td></tr><tr><td><code>@PostAuthorize</code></td><td>用于在方法执行之后对返回结果进行权限验证</td></tr><tr><td><code>@Secured</code></td><td>用于在方法执行之前对访问进行权限验证</td></tr><tr><td><code>@RolesAllowed</code></td><td>是Java标准的注解之一，用于在方法执行之前对访问进行权限验证</td></tr></tbody></table> 
<h2> 四.管理控制Controller层的权限</h2> 
<pre><code class="language-java">@Controller
public class IndexController {

    @RequestMapping("/")
    public String toLogin() {
        return "login";
    }

    @RequestMapping("/userLogin")
    public String userLogin() {
        return "index";
    }

    @RequestMapping("/index")
    public String toIndex() {
        return "index";
    }

    @RequestMapping("/noAccess")
    public String noAccess() {
        return "accessDenied";
    }

    @ResponseBody
    @RequestMapping("/order_add")
    @PreAuthorize("hasAuthority('order:manager:add')")
    public String order_add() {
        return "订单新增";
    }

    @ResponseBody
    @PreAuthorize("hasAuthority('book:manager:add')")
    @RequestMapping("/book_add")
    public String book_add() {
        return "书本新增";
    }

}</code></pre> 
<p>在当前登录的用户必须拥有当前的权限字段才能进行访问，例如：book:manager:add</p> 
<h2>五.异常处理</h2> 
<p><code>AccessDeniedHandler</code>是Spring Security提供的一个接口，用于处理访问被拒绝的情况。当用户尝试访问受保护资源但没有足够的权限时，Spring Security会调用<code>AccessDeniedHandler</code>来处理这种情况。</p> 
<p><code>AccessDeniedHandler</code>接口只有一个方法<code>handle()</code>，该方法接收<code>HttpServletRequest</code>、<code>HttpServletResponse</code>和<code>AccessDeniedException</code>三个参数。在<code>handle()</code>方法中，可以自定义响应的内容，例如返回一个自定义的错误页面或<code>JSON</code>响应。</p> 
<p>创建<code>AccessDeniedHandlerImpl</code>类并实现<code>AccessDeniedHandler</code>接口，实现自定义的<code>JSON</code>响应。例如：</p> 
<pre><code class="language-java">package com.yu.security.resp;

import lombok.Getter;

@Getter
public enum JsonResponseStatus {

    OK(200, "OK"),
    UN_KNOWN(500, "未知错误"),
    RESULT_EMPTY(1000, "查询结果为空"),
    NO_ACCESS(3001, "没有权限"),
    NO_LOGIN(4001, "没有登录"),
    LOGIN_FAILURE(5001, "登录失败"),
    ;

    private final Integer code;
    private final String msg;

    JsonResponseStatus(Integer code, String msg) {
        this.code = code;
        this.msg = msg;
    }

}
</code></pre> 
<p>单独写一个接口进行实现，并将出现异常后的操作在里面实现</p> 
<pre><code class="language-java">package com.yu.security.config;

import com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.yu.security.pojo.User;
import com.yu.security.resp.JsonResponseBody;
import com.yu.security.resp.JsonResponseStatus;
import com.yu.security.service.IUserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.authentication.AuthenticationFailureHandler;
import org.springframework.stereotype.Component;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

@Component
public class MyAuthenticationFailureHandler implements AuthenticationFailureHandler {

    @Autowired
    private ObjectMapper objectMapper;

    // 在redis中定义一个键当登录失败是就对那个键的值进行加一

    //如果大于三就锁住

    @Autowired
    private IUserService userService;

    @Override
    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
        if(1==2){
            User user = userService.getOne(new QueryWrapper&lt;User&gt;().eq("username", request.getParameter("username")));
            user.setAccountNonLocked(false);
            userService.updateById(user);
        }
        objectMapper.writeValue(response.getOutputStream(), JsonResponseBody.other(JsonResponseStatus.LOGIN_FAILURE));
    }

}
</code></pre> 
<blockquote> 
 <p>在当前例子中：我们通过在配置类引入当前接口，并实现当前接口，在实现类中，对登录失败进行 对应的操作，在Redis中定义一个键当登录失败是就对那个键的值进行加一,如果大于三就对当前账号进行冻结</p> 
</blockquote> 
<pre></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5cab712f60e3c8da485dd59a07715a61/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Neo4j突然运行不了，log文件显示“Neo4j Server shutdown initiated by request,Stopping...,Stopped.”解决方案</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/162636d35beda0f59602a857650ef266/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CycleGAN-两个领域非匹配图像的相互转换</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>