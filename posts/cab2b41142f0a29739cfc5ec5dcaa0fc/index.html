<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>gui卡顿 python_【整理】【分享】有关PyQt界面卡顿的解决方案大全 | 勤奋的小青蛙... - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="gui卡顿 python_【整理】【分享】有关PyQt界面卡顿的解决方案大全 | 勤奋的小青蛙..." />
<meta property="og:description" content="之前写过两篇博客，可以参考：
此篇博客是对上述两篇博客的补充。
参考这篇博客：http://themkbytes.blogspot.kr/2012/05/pyqt-gui-freeze-while-loops.html
得出如下结论，主线程中如果有一些耗时的计算，界面会暂时失去响应，那么，在计算的过程中，可以调用下界面的processEvents方法，让整个程序继续执行，处于事件循环中。
代码主要如下：
耗时导致界面失去响应的代码：
import itertools ,string
x=1
file=open(&#34;file&#34;,&#34;w&#34;)
while x&lt;=200:
it=itertools.product(string.printable,repeat=x)
for i in it:
ij=&#34;&#34;.join(i)
file.write(&#34;ij&#34;&#43;&#34;\n&#34;)
x=x&#43;1
file.close()
由于循环比较多，所以，导致界面失去响应，解决方案如下：
只需要在循环内部，加入：
gui=QtGui.Application.processEvents
gui()
改造后的代码：
x = 1
file = open(&#34;file&#34;,&#34;w&#34;)
gui()
while x&lt;=200:
it=itertools.product(string.printable,repeat=x)
time.sleep(0.1)
gui()
for i in it:
ij=&#34;&#34;.join(i)
time.sleep(0.001)
gui()
file.write(&#34;ij&#34;&#43;&#34;\n&#34;)
gui()
x = x&#43;1
gui()
file.close()
gui()
这样子界面就不会卡顿了。
补充：PyQt采用moveToThread解决卡顿问题
首先是一个worker类，主要是负责处理任务的：
其中Worker.py定义了两个信号，一个是madeProgress信号，一个是完成信号finished
class Worker(QtCore.QObject):
madeProgress = QtCore.pyqtSignal([int])
finished = QtCore.pyqtSignal()
def __init__(self, cmdlist):" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/cab2b41142f0a29739cfc5ec5dcaa0fc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-13T11:38:04+08:00" />
<meta property="article:modified_time" content="2021-01-13T11:38:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">gui卡顿 python_【整理】【分享】有关PyQt界面卡顿的解决方案大全 | 勤奋的小青蛙...</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>之前写过两篇博客，可以参考：</p> 
 <p>此篇博客是对上述两篇博客的补充。</p> 
 <p>参考这篇博客：http://themkbytes.blogspot.kr/2012/05/pyqt-gui-freeze-while-loops.html</p> 
 <p>得出如下结论，主线程中如果有一些耗时的计算，界面会暂时失去响应，那么，在计算的过程中，可以调用下界面的processEvents方法，让整个程序继续执行，处于事件循环中。</p> 
 <p>代码主要如下：</p> 
 <p>耗时导致界面失去响应的代码：</p> 
 <p>import itertools ,string</p> 
 <p>x=1</p> 
 <p>file=open("file","w")</p> 
 <p>while x&lt;=200:</p> 
 <p>it=itertools.product(string.printable,repeat=x)</p> 
 <p>for i in it:</p> 
 <p>ij="".join(i)</p> 
 <p>file.write("ij"+"\n")</p> 
 <p>x=x+1</p> 
 <p>file.close()</p> 
 <p>由于循环比较多，所以，导致界面失去响应，解决方案如下：</p> 
 <p>只需要在循环内部，加入：</p> 
 <p>gui=QtGui.Application.processEvents</p> 
 <p>gui()</p> 
 <p>改造后的代码：</p> 
 <p>x = 1</p> 
 <p>file = open("file","w")</p> 
 <p>gui()</p> 
 <p>while x&lt;=200:</p> 
 <p>it=itertools.product(string.printable,repeat=x)</p> 
 <p>time.sleep(0.1)</p> 
 <p>gui()</p> 
 <p>for i in it:</p> 
 <p>ij="".join(i)</p> 
 <p>time.sleep(0.001)</p> 
 <p>gui()</p> 
 <p>file.write("ij"+"\n")</p> 
 <p>gui()</p> 
 <p>x = x+1</p> 
 <p>gui()</p> 
 <p>file.close()</p> 
 <p>gui()</p> 
 <p>这样子界面就不会卡顿了。</p> 
 <p>补充：PyQt采用moveToThread解决卡顿问题</p> 
 <p>首先是一个worker类，主要是负责处理任务的：</p> 
 <p>其中Worker.py定义了两个信号，一个是madeProgress信号，一个是完成信号finished</p> 
 <p>class Worker(QtCore.QObject):</p> 
 <p>madeProgress = QtCore.pyqtSignal([int])</p> 
 <p>finished = QtCore.pyqtSignal()</p> 
 <p>def __init__(self, cmdlist):</p> 
 <p>self.cmdlist = cmdlist</p> 
 <p>def run(self):</p> 
 <p>for icmd, cmd in enumerate(self.cmdlist):</p> 
 <p># execute your work</p> 
 <p># processCommand(cmd)</p> 
 <p># signal that we've made progress</p> 
 <p>self.madeProgress.emit(icmd)</p> 
 <p># emit the finished signal - we're done</p> 
 <p>self.finished.emit()</p> 
 <p>然后，通过moveToThread，我们将worker类放到线程里，通过thread类的started信号连接到worker类的运行函数(run方法)，这样就使得worker类的run方法也处于线程里，通过run方法的信号释放，来绑定外部的槽函数。代码如下：</p> 
 <p>workerThread = QThread()</p> 
 <p>workerObject = Worker(cmdlist)</p> 
 <p>workerObject.moveToThread(workerThread)</p> 
 <p>workerThread.started.connect(workerObject.run)</p> 
 <p>workerObject.finished.connect(workerThread.quit)</p> 
 <p># create a progressbar with min/max according to</p> 
 <p># the length of your cmdlist</p> 
 <p>progressBar = QProgressBar()</p> 
 <p>progressBar.setRange(0, len(cmdlist))</p> 
 <p># connect the worker's progress signal with the progressbar</p> 
 <p>workerObject.madeProgress.connect(progressBar.setValue)</p> 
 <p># start the thread (starting your worker at the same time)</p> 
 <p>workerThread.start()</p> 
 <p>上述例子即可完成线程操作方法，GUI便不会卡顿。</p> 
 <p>文章的脚注信息由WordPress的wp-posturl插件自动生成</p> 
 <p>|2|left</p> 
 <p>打赏</p> 
 <p align="center"><img src="" alt=""></p> 
 <p align="center"><img src="" alt="">微信扫一扫，打赏作者吧～</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bed91074ba86d7178371112fb3e7f017/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">疲劳检测（一）Landmark &#43; HeadPose</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e34f5c9ce7ad91bebb93c638bafaea9d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Zabbix---2 监控主机CPU使用率</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>