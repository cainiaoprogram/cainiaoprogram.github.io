<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>推导正交投影变换 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="推导正交投影变换" />
<meta property="og:description" content="-潘宏
-2009.4.20 -本人水平有限，疏忽错误在所难免，还请各位数学高手、编程高手不吝赐教
-email: popyy@netease.com
-B站专栏：https://b23.tv/oWsl6PD
之前我们在《深入探索透视投影变换》以及《深入探索透视投影变换（续）》中研究了OpenGL、D3D以及M3G的透视投影变换的原理以及生成方法。这些方法在当前的主流图形API中得到了普遍使用。但关于投影应用，还有一类经常使用的投影方式需要我们深入理解——正交投影，我们在本篇文章里面研究它（这里假设读者已经看过前两篇文章，并理解了绝大多数的理论，因为正交投影比透视投影的推导关系简单得多，因此我们的推导会非常得快，如果读者有任何的不解，请参考前两篇文章或者通过email联系我）。
在具体研究之前我觉得有必要把平面投影的分类简单介绍一下，目的是为了让大家有一个总体的认识，从而更好的理解这个知识体系。请看下图：
平面投影分为平行投影和透视投影两种类型，后者我们在前两篇文章中介绍了。平行投影则是具有矩形观察体的投影方式（透视投影则是视锥观察体），它不会根据物体离视点的远近缩放物体（透视投影则会）。平行投影可以分成侧投影和正交投影两种类型。这两种类型如何区分呢？我们继续看图吧：
上图中，v是投影平面，n是它的法线。p和q是平面外两点，p’和q’分别是它们在平面上的投影点。q的投影方向向量为Q = 单位化（q’-q），而p的投影方向向量为P = 单位化（p’-p），其中Q不平行于n而P平行于n，则q的投影叫做侧投影，而p的投影叫做正交投影。正交投影是我们今天的研究对象。
实际上上面对平面投影的分类还可以继续向下细分，比如透视投影可以分为一灭点、二灭点以及三灭点透视投影。侧投影则可以继续分为散点侧投、斜二轴侧投等等。而正交投影则可以分成轴侧投影以及多视点正交投影等等。如果读者对此感兴趣，可以参考相关的图形学教程。
接下来我们研究正交投影。分别介绍OpenGL、D3D以及M3G的。我们的环境约定（左右手坐标系、行列向量乘法、CVV范围）仍然尊重相应API自己的设置。
OpenGL正交投影变换 下图是OpenGL的右手坐标系中观察空间的情形，我们看到的是正交投影的矩形观察体，原点是相机位置，n是近裁剪平面到相机平面的距离，f是远裁剪平面到相机平面的距离。p是观察体中的一个点，p’是它投影之后的点。
投影之后我们有关系：
因为是正交投影，没有统一的投影射线目标点，因此投影之后的x和y不会变，而z则永远地变成了-n，跑到了投影平面上（我们让投影平面和近裁剪平面重合），它已经没用了，则我们用这个没用的信息保存z（为了之后片元操作的时候用），写为：
从而在z方向上构建 CVV，使得当z在近裁剪平面的时候，az&#43;b=-1，而z在远裁剪平面的时候az&#43;b=1（OpenGL的CVV的z范围是[-1,1]，我已经说了三遍了，如果读者感到迷惑不解，强烈建议把前两篇文章理解）。我们算出a和b
然后我们就通过当前的结果反推正交投影矩阵版本一
接着把x和y建立成CVV情形（简单的线性插值）
反推正交投影矩阵版本二（最终版本）
则右边的那个矩阵就是OpenGL的正交投影矩阵，它可以通过glOrtho创建出来。如果你读过并理解了之前两篇文章，你会觉得我的推导越来越简洁利落了：）OpenGL的解决了，下面是D3D的。
D3D正交投影变换 下图是D3D左手坐标系中观察空间的情形。因为是左手坐标系，因此近裁剪平面在z = n平面，而远裁剪平面在z = f平面。
投影之后，有 用第三个没用的信息保存z，写为
使得（D3D的CVV的z范围是[0, 1]）
反推正交投影矩阵版本一
对x和y进行CVV线性插值
分两种情况讨论（如果读者对此不清楚，请参考第二篇文章《深入探索透视投影变换（续）》）：
（1） 投影平面居中，销掉两边的1/2，然后反推正交投影矩阵
后面那个矩阵就是相应正交投影矩阵，这个也是D3DXMatrixOrthoLH方法所使用的情况。
（2） 一般情况，投影平面不一定居中，直接通过投影结果反推正交投影矩阵
后面那个矩阵就是相应的正交投影矩阵，这个也是D3DXMatrixOrthoOffCenterLH方法所使用的情况。好了，D3D的也介绍完毕，接下来是M3G的。
M3G正交投影变换 M3G是对OpenGL的封装，因此环境和OpenGL的相同，我们从对x和y的插值来看
M3G只使用居中的投影平面，因此可以销掉两边的1/2，得到
接着反推出正交投影矩阵
最后那个矩阵就是M3G的正交投影矩阵，也就是Camera.setParallel所使用的形式。
结束语 以上介绍了三个API所使用的正交投影矩阵的生成方法，三者的正交投影矩阵依然可以通过视野（FOV）以及投影平面的宽高比（Aspect Ratio）来设置，这里请读者自行推导，可以参考第二篇文章《深入探索透视投影变换（续）》。
正交投影矩阵和透视投影矩阵一样可以有无穷多个，但原理相同，不同的只是环境。目前正交投影在3D引擎中有着和透视投影同样的地位，它至少是3D用户界面系统的基础。因此，有必要清晰地理解正交投影矩阵和透视投影矩阵的原理，如此才能够真正创建、修改、使用好图形引擎。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4c46dd712b127c158268439490952492/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-28T00:09:20+08:00" />
<meta property="article:modified_time" content="2023-01-28T00:09:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">推导正交投影变换</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0;text-align:left;">-潘宏</p> 
<p style="margin-left:0;text-align:left;">-2009.4.20 </p> 
<p style="margin-left:0;text-align:left;">-本人水平有限，疏忽错误在所难免，还请各位数学高手、编程高手不吝赐教</p> 
<p style="margin-left:0;text-align:left;">-email: <a href="mailto:popyy@netease.com" rel="nofollow">popyy@netease.com</a></p> 
<p style="margin-left:0;text-align:left;">-B站专栏：https://b23.tv/oWsl6PD</p> 
<p style="margin-left:0;"> </p> 
<p style="margin-left:0;">    之前我们在《深入探索透视投影变换》以及《深入探索透视投影变换（续）》中研究了OpenGL、D3D以及M3G的透视投影变换的原理以及生成方法。这些方法在当前的主流图形API中得到了普遍使用。但关于投影应用，还有一类经常使用的投影方式需要我们深入理解——正交投影，我们在本篇文章里面研究它（这里假设读者已经看过前两篇文章，并理解了绝大多数的理论，因为正交投影比透视投影的推导关系简单得多，因此我们的推导会非常得快，如果读者有任何的不解，请参考前两篇文章或者通过email联系我）。</p> 
<p style="margin-left:0;">在具体研究之前我觉得有必要把平面投影的分类简单介绍一下，目的是为了让大家有一个总体的认识，从而更好的理解这个知识体系。请看下图：</p> 
<p style="margin-left:0;"> </p> 
<p style="margin-left:0;text-align:center;"><img src="https://images2.imgbox.com/da/56/aFpI8gP2_o.jpg" alt="fig1_category.jpg">      </p> 
<p style="margin-left:0;text-align:left;">平面投影分为平行投影和透视投影两种类型，后者我们在前两篇文章中介绍了。平行投影则是具有矩形观察体的投影方式（透视投影则是视锥观察体），它不会根据物体离视点的远近缩放物体（透视投影则会）。平行投影可以分成侧投影和正交投影两种类型。这两种类型如何区分呢？我们继续看图吧：</p> 
<p style="margin-left:0;text-align:center;"><img src="https://images2.imgbox.com/ed/4c/o5VFOTJD_o.jpg" alt="fig2_parallel.jpg"></p> 
<p style="margin-left:0;">上图中，v是投影平面，n是它的法线。p和q是平面外两点，p’和q’分别是它们在平面上的投影点。q的投影方向向量为Q = 单位化（q’-q），而p的投影方向向量为P = 单位化（p’-p），其中Q不平行于n而P平行于n，则q的投影叫做侧投影，而p的投影叫做正交投影。正交投影是我们今天的研究对象。</p> 
<p style="margin-left:0;">实际上上面对平面投影的分类还可以继续向下细分，比如透视投影可以分为一灭点、二灭点以及三灭点透视投影。侧投影则可以继续分为散点侧投、斜二轴侧投等等。而正交投影则可以分成轴侧投影以及多视点正交投影等等。如果读者对此感兴趣，可以参考相关的图形学教程。</p> 
<p style="margin-left:0;">接下来我们研究正交投影。分别介绍OpenGL、D3D以及M3G的。我们的环境约定（左右手坐标系、行列向量乘法、CVV范围）仍然尊重相应API自己的设置。</p> 
<h3 style="margin-left:0;">OpenGL正交投影变换</h3> 
<p style="margin-left:0;">    下图是OpenGL的右手坐标系中观察空间的情形，我们看到的是正交投影的矩形观察体，原点是相机位置，n是近裁剪平面到相机平面的距离，f是远裁剪平面到相机平面的距离。p是观察体中的一个点，p’是它投影之后的点。</p> 
<p style="margin-left:0;text-align:center;"><img src="https://images2.imgbox.com/b5/81/9Og3FyPr_o.jpg" alt="fig3_oglvv.jpg"></p> 
<p style="margin-left:0;">投影之后我们有关系：</p> 
<p style="margin-left:0;text-align:center;"><img src="https://images2.imgbox.com/72/58/0eiod4Jb_o.jpg" alt="fig4_pp.jpg"></p> 
<p style="margin-left:0;">因为是正交投影，没有统一的投影射线目标点，因此投影之后的x和y不会变，而z则永远地变成了-n，跑到了投影平面上（我们让投影平面和近裁剪平面重合），它已经没用了，则我们用这个没用的信息保存z（为了之后片元操作的时候用），写为：</p> 
<p style="margin-left:0;text-align:center;"><img src="https://images2.imgbox.com/48/0e/WkeKJ6aT_o.jpg" alt="fig5_p.jpg"></p> 
<p style="margin-left:0;">从而在z方向上构建 CVV，使得当z在近裁剪平面的时候，az+b=-1，而z在远裁剪平面的时候az+b=1（OpenGL的CVV的z范围是[-1,1]，我已经说了三遍了，如果读者感到迷惑不解，强烈建议把前两篇文章理解）。我们算出a和b</p> 
<p style="margin-left:0;text-align:center;"><img src="https://images2.imgbox.com/5a/f2/gAbvWpFh_o.jpg" alt="fig6_ab.jpg"></p> 
<p style="margin-left:0;">然后我们就通过当前的结果反推正交投影矩阵版本一</p> 
<p style="margin-left:0;"> </p> 
<p style="margin-left:0;text-align:center;"><img src="https://images2.imgbox.com/bc/cc/glthrQeq_o.jpg" alt="fig7_ver1.jpg"></p> 
<p style="margin-left:0;text-align:center;"> </p> 
<p style="margin-left:0;">接着把x和y建立成CVV情形（简单的线性插值）</p> 
<p style="margin-left:0;"> </p> 
<p style="margin-left:0;text-align:center;"><img src="https://images2.imgbox.com/14/fc/kxc3dTTQ_o.jpg" alt="fig8_xy.jpg"></p> 
<p style="margin-left:0;text-align:center;"> </p> 
<p style="margin-left:0;">反推正交投影矩阵版本二（最终版本）</p> 
<p style="margin-left:0;"> </p> 
<p style="margin-left:0;text-align:center;"> <img src="https://images2.imgbox.com/d7/a3/PcDivA9n_o.jpg" alt="fig9_ogl_ortho.jpg"></p> 
<p style="margin-left:0;text-align:center;"> </p> 
<p style="margin-left:0;">则右边的那个矩阵就是OpenGL的正交投影矩阵，它可以通过glOrtho创建出来。如果你读过并理解了之前两篇文章，你会觉得我的推导越来越简洁利落了：）OpenGL的解决了，下面是D3D的。</p> 
<h3 style="margin-left:0;">D3D正交投影变换</h3> 
<p style="margin-left:0;">    下图是D3D左手坐标系中观察空间的情形。因为是左手坐标系，因此近裁剪平面在z = n平面，而远裁剪平面在z = f平面。</p> 
<p style="margin-left:0;text-align:center;"> <img src="https://images2.imgbox.com/52/ed/POssocYk_o.jpg" alt="fig10_d3dvv2.jpg"></p> 
<p style="margin-left:0;">投影之后，有                                                                                                    </p> 
<p style="text-align:center;"><img src="https://images2.imgbox.com/f9/3d/ebMPot0n_o.jpg" alt="fig11_pp.jpg"></p> 
<p style="margin-left:0;text-align:center;"> </p> 
<p style="margin-left:0;">用第三个没用的信息保存z，写为</p> 
<p style="margin-left:0;text-align:center;"><img src="https://images2.imgbox.com/56/03/wVaHywDV_o.jpg" alt="fig12_p.jpg"> </p> 
<p style="margin-left:0;">使得（D3D的CVV的z范围是[0, 1]）</p> 
<p style="margin-left:0;text-align:center;"><img src="https://images2.imgbox.com/e2/d3/M4CdN8Ot_o.jpg" alt="fig13_ab.jpg"></p> 
<p style="margin-left:0;">反推正交投影矩阵版本一</p> 
<p style="margin-left:0;text-align:center;"><img src="https://images2.imgbox.com/9f/4a/MhqjZd4D_o.jpg" alt="fig14_ver1.jpg"></p> 
<p style="margin-left:0;">对x和y进行CVV线性插值</p> 
<p style="margin-left:0;"> </p> 
<p style="margin-left:0;text-align:center;"><img src="https://images2.imgbox.com/d9/80/tzqjNUx7_o.jpg" alt="fig15_xy.jpg"></p> 
<p style="margin-left:0;text-align:center;"> </p> 
<p style="margin-left:0;">分两种情况讨论（如果读者对此不清楚，请参考第二篇文章《深入探索透视投影变换（续）》）：</p> 
<p style="margin-left:36pt;">（1）       投影平面居中，销掉两边的1/2，然后反推正交投影矩阵</p> 
<p style="margin-left:36pt;"> </p> 
<p style="margin-left:0;text-align:center;"><img src="https://images2.imgbox.com/f0/c3/HX7pkzc6_o.jpg" alt="fig16_case1.jpg"></p> 
<p style="margin-left:0;text-align:center;"> </p> 
<p style="margin-left:0;">后面那个矩阵就是相应正交投影矩阵，这个也是D3DXMatrixOrthoLH方法所使用的情况。</p> 
<p style="margin-left:0;"> </p> 
<p style="margin-left:36pt;">（2）       一般情况，投影平面不一定居中，直接通过投影结果反推正交投影矩阵</p> 
<p style="margin-left:36pt;"> </p> 
<p style="margin-left:0;text-align:center;"><img src="https://images2.imgbox.com/75/68/WXD0l2Vh_o.jpg" alt="fig17_case2.jpg"></p> 
<p style="margin-left:0;text-align:center;"> </p> 
<p style="margin-left:0;">后面那个矩阵就是相应的正交投影矩阵，这个也是D3DXMatrixOrthoOffCenterLH方法所使用的情况。好了，D3D的也介绍完毕，接下来是M3G的。</p> 
<p style="margin-left:0;"> </p> 
<h3 style="margin-left:0;">M3G正交投影变换</h3> 
<p style="margin-left:0;">M3G是对OpenGL的封装，因此环境和OpenGL的相同，我们从对x和y的插值来看</p> 
<p style="margin-left:0;"> </p> 
<p style="margin-left:0;text-align:center;"><img src="https://images2.imgbox.com/79/e9/9l7HL1jC_o.jpg" alt="fig18_xy.jpg"></p> 
<p style="margin-left:0;text-align:center;"> </p> 
<p style="margin-left:0;">M3G只使用居中的投影平面，因此可以销掉两边的1/2，得到</p> 
<p style="margin-left:0;"> </p> 
<p style="margin-left:0;text-align:center;"><img src="https://images2.imgbox.com/c2/34/Uu9iMM0t_o.jpg" alt="fig19_case1.jpg"></p> 
<p style="margin-left:0;text-align:center;"> </p> 
<p style="margin-left:0;">接着反推出正交投影矩阵</p> 
<p style="margin-left:0;"> </p> 
<p style="margin-left:0;text-align:center;"><img src="https://images2.imgbox.com/33/e2/9L03L5Xn_o.jpg" alt="fig20_m3g_ortho.jpg"></p> 
<p style="margin-left:0;text-align:center;"> </p> 
<p style="margin-left:0;">最后那个矩阵就是M3G的正交投影矩阵，也就是Camera.setParallel所使用的形式。</p> 
<h3 style="margin-left:0;">结束语</h3> 
<p style="margin-left:0;">以上介绍了三个API所使用的正交投影矩阵的生成方法，三者的正交投影矩阵依然可以通过视野（FOV）以及投影平面的宽高比（Aspect Ratio）来设置，这里请读者自行推导，可以参考第二篇文章《深入探索透视投影变换（续）》。</p> 
<p style="margin-left:0;">正交投影矩阵和透视投影矩阵一样可以有无穷多个，但原理相同，不同的只是环境。目前正交投影在3D引擎中有着和透视投影同样的地位，它至少是3D用户界面系统的基础。因此，有必要清晰地理解正交投影矩阵和透视投影矩阵的原理，如此才能够真正创建、修改、使用好图形引擎。</p> 
<p style="margin-left:0;"> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b994845b3b7f15c76c3451d48d575a6f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">推导相机变换矩阵</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bf9f67204797b017898a2b396590fe87/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">华为云、阿里云、腾讯云、百度云、浪潮云、金山云哪家强？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>