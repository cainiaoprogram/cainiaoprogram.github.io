<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>安卓服务Service - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="安卓服务Service" />
<meta property="og:description" content="1、Service概念及用途
2、Service生命周期
3、Service与Activity通信
4、IntentService
5、跨进程访问AIDL
6、关于服务的应用
一、Service概念及用途
1、Service（服务）是一个没有用户界面的在后台运行执行耗时操作的应用组件。
2、其他应用组件能够启动Service，并且当用户切换到另外的应用场景，Service将持续在后台运行。
3、一个组件能够绑定到一个service来交互，例如，一个service可能会处理网络操作，播放音乐，操作文件I/O或者与内容提供者（content provider）交互，所有这些活动都是在后台进行。
4、Service有两种状态，“启动的”和“绑定”
Service的种类（了解）
按运行地点分类：
其实remote服务还是很少见的，并且一般都是系统服务。
按运行类型分类：
后台服务我们可以自己创建 ONGOING 的 Notification 这样就成为前台服务吗？答案是否定的，前台服务是在做了上述工作之后需要调用 startForeground （ android 2.0 及其以后版本 ）或 setForeground （android 2.0 以前的版本）使服务成为 前台服务。这样做的好处在于，当服务被外部强制终止掉的时候，ONGOING 的 Notification 任然会移除掉。
按使用方式分类：
以上面三种方式启动的服务其生命周期也有区别，将在随后给出。
类别
区别
优点
缺点 应用
本地服务（Local）
该服务依附在主进程上
服务依附在主进程上而不是独立的进程，这样在一定程度上节约了资源，另外Local服务因为是在同一进程因此不需要IPC，也不需要AIDL。相应bindService会方便很多。
主进程被Kill后，服务便会终止。
非常常见的应用如：HTC的音乐播放服务，天天动听音乐播放服务。
远程服务（Remote）
该服务是独立的进程，
服务为独立的进程，对应进程名格式为所在包名加上你指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行，不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。
该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。
一些提供系统服务的Service，这种Service是常驻的。
类别
区别
应用
前台服务
会在通知一栏显示 ONGOING 的 Notification，
当服务被终止的时候，通知一栏的 Notification 也会消失，这样对于用户有一定的通知作用。常见的如音乐播放服务。
后台服务
默认的服务即为后台服务，即不会在通知一栏显示 ONGOING 的 Notification。
当服务被终止的时候，用户是看不到效果的。某些不需要运行或终止提示的服务，如天气更新，日期同步，邮件同步等。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fa3e302770cb5c5951d045d03499afb3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-08T11:00:26+08:00" />
<meta property="article:modified_time" content="2022-03-08T11:00:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">安卓服务Service</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <table><tbody><tr><td> <p>1、Service概念及用途</p> <p>2、Service生命周期</p> <p>3、Service与Activity通信</p> <p>4、IntentService</p> <p>5、跨进程访问AIDL</p> <p>6、关于服务的应用</p> </td></tr></tbody></table> 
<p></p> 
<p> </p> 
<table><tbody><tr><td> <p>一、Service概念及用途</p> <p>1、Service（服务）是一个没有用户界面的在后台运行执行耗时操作的应用组件。</p> <p>2、其他应用组件能够启动Service，并且当用户切换到另外的应用场景，Service将持续在后台运行。</p> <p>3、一个组件能够绑定到一个service来交互，例如，一个service可能会处理网络操作，播放音乐，操作文件I/O或者与内容提供者（content provider）交互，所有这些活动都是在后台进行。</p> <p>4、Service有两种状态，“启动的”和“绑定”</p> <p></p> </td></tr></tbody></table> 
<p></p> 
<table><tbody><tr><td> <p>Service的种类（了解）</p> <p>按运行地点分类：</p> <p>其实remote服务还是很少见的，并且一般都是系统服务。</p> <p>按运行类型分类：</p> <p>后台服务我们可以自己创建 ONGOING 的 Notification 这样就成为前台服务吗？答案是否定的，前台服务是在做了上述工作之后需要调用 startForeground （ android 2.0 及其以后版本 ）或 setForeground （android 2.0 以前的版本）使服务成为 前台服务。这样做的好处在于，当服务被外部强制终止掉的时候，ONGOING 的 Notification 任然会移除掉。</p> <p></p> <p>按使用方式分类：</p> <p>以上面三种方式启动的服务其生命周期也有区别，将在随后给出。</p> </td></tr></tbody></table> 
<p></p> 
<table><tbody><tr><td> <p>类别</p> </td><td> <p>区别</p> </td><td> <p> 优点</p> </td><td> <p>缺点 </p> </td><td> <p> 应用</p> </td></tr><tr><td> <p>本地服务（Local）</p> </td><td> <p>该服务依附在主进程上</p> </td><td> <p> 服务依附在主进程上而不是独立的进程，这样在一定程度上节约了资源，另外Local服务因为是在同一进程因此不需要IPC，也不需要AIDL。相应bindService会方便很多。</p> </td><td> <p> 主进程被Kill后，服务便会终止。</p> </td><td> <p> 非常常见的应用如：HTC的音乐播放服务，天天动听音乐播放服务。</p> </td></tr><tr><td> <p>远程服务（Remote）</p> </td><td> <p>该服务是独立的进程，</p> </td><td> <p> 服务为独立的进程，对应进程名格式为所在包名加上你指定的android:process字符串。由于是独立的进程，因此在Activity所在进程被Kill的时候，该服务依然在运行，不受其他进程影响，有利于为多个进程提供服务具有较高的灵活性。</p> </td><td> <p> 该服务是独立的进程，会占用一定资源，并且使用AIDL进行IPC稍微麻烦一点。</p> </td><td> <p> 一些提供系统服务的Service，这种Service是常驻的。</p> </td></tr></tbody></table> 
<p></p> 
<table><tbody><tr><td> <p>类别</p> </td><td> <p>区别</p> </td><td> <p>应用</p> </td></tr><tr><td> <p>前台服务</p> </td><td> <p>会在通知一栏显示 ONGOING 的 Notification，</p> </td><td> <p>当服务被终止的时候，通知一栏的 Notification 也会消失，这样对于用户有一定的通知作用。常见的如音乐播放服务。</p> </td></tr><tr><td> <p>后台服务</p> </td><td> <p>默认的服务即为后台服务，即不会在通知一栏显示 ONGOING 的 Notification。</p> </td><td> <p>当服务被终止的时候，用户是看不到效果的。某些不需要运行或终止提示的服务，如天气更新，日期同步，邮件同步等。</p> </td></tr></tbody></table> 
<p></p> 
<table><tbody><tr><td> <p>类别</p> </td><td> <p>区别</p> </td></tr><tr><td> <p>startService 启动的服务</p> </td><td> <p>主要用于启动一个服务执行后台任务，不进行通信。停止服务使用stopService</p> </td></tr><tr><td> <p>bindService 启动的服务</p> </td><td> <p>该方法启动的服务要进行通信。停止服务使用unbindService</p> </td></tr><tr><td> <p>startService 同时也 bindService 启动的服务</p> </td><td> <p>停止服务应同时使用stepService与unbindService</p> </td></tr></tbody></table> 
<p></p> 
<table><tbody><tr><td> <p>Service 与 Thread 的区别</p> <p>1). Thread：Thread 是程序执行的最小单元，它是分配CPU的基本单位。可以用 Thread 来执行一些异步的操作。</p> <p>2). Service：Service 是android的一种机制，当它运行的时候如果是Local Service，那么对应的 Service 是运行在主进程的 main 线程上的。如：onCreate，onStart 这些函数在被系统调用的时候都是在主进程的 main 线程上运行的。如果是Remote Service，那么对应的 Service 则是运行在独立进程的 main 线程上。因此请不要把 Service 理解成线程，它跟线程半毛钱的关系都没有！</p> <p></p> </td></tr></tbody></table> 
<p></p> 
<table><tbody><tr><td> <p>二、生命周期</p> <p>onCreate　　onStart　　onDestroy　　onBind </p> <p>startService：</p> <p>  多次启动服务，startid会上升，强行杀死带服务的进程，则Service的startid会加+；</p> <p></p> <p>1、一旦启动，service就在后台运行，即使启动它的应用组件已经被销毁了。</p> <p>2、通常started状态的service执行单任务并且不返回任何结果给启动者。比如当下载或上传一个文件，当这项操作完成时，service应该停止它本身。</p> <p></p> <p>bindService：</p> <p>  只能绑定一次，绑定之后不能再重新绑定，也不能取消绑定两次。</p> <p>  绑定会和当前应用程序共存亡，当前绑定的Activity销毁，自己也会销毁</p> <p></p> <p>1、一个绑定的service提供一个允许组件与service交互的接口，可以发送请求、获取返回结果，还可以通过夸进程通信来交互（IPC）。</p> <p>2、绑定的service只有当应用组件绑定后才能运行，多个组件可以绑定一个service，当调用unbind()方法时，这个service就会被销毁了。</p> <p></p> <p>startService和bindService一起使用</p> <p>特别注意：</p> <p>***：service与activity一样都存在与当前进程的主线程中，所以，一些阻塞UI的操作，比如耗时操作不能放在service里进行，比如另外开启一个线程来处理诸如网络请求的耗时操作。</p> <p>1、你应当知道在调用 bindService 绑定到Service的时候，你就应当保证在某处调用 unbindService 解除绑定（尽管 Activity 被 finish 的时候绑定会自动解除，并且Service会自动停止）；</p> <p>2、你应当注意 使用 startService 启动服务之后，一定要使用 stopService停止服务</p> <p>3、同时使用 startService 与 bindService 要注意到，Service 的终止，只需要unbindService，不管 startService 与 bindService 的调用顺序，调用 unbindService 服务再调用stop就会停止。</p> <p>4、当在旋转手机屏幕的时候，当手机屏幕在“横”“竖”变换时，此时如果你的 Activity 如果会自动旋转的话，旋转其实是 Activity 的重新创建，因此旋转之前的使用 bindService 建立的连接便会断开（Context 不存在了），对应服务的生命周期与上述相同。</p> <p>5、在 sdk 2.0 及其以后的版本中，对应的 onStart 已经被否决变为了 onStartCommand，不过之前的 onStart 任然有效。这意味着，如果你开发的应用程序用的 sdk 为 2.0 及其以后的版本，那么你应当使用 onStartCommand 而不是 onStart。</p> </td></tr></tbody></table> 
<p></p> 
<p></p> 
<p></p> 
<p><img alt="" src="https://images2.imgbox.com/9f/74/N0lAIwOI_o.jpg"></p> 
<p> </p> 
<table><tbody><tr><td> <p> 1、先start再bind：  那么bind不会再执行oncreate方法，如果按back,只会取消绑定，不会stop服务。</p> <p>      unbind-&gt;ondestroy</p> <p>       先unbind再stop：  unbind  ondestroy</p> <p>       先stop再unbind：执行stop的时候 不会执行destroy的方法，直到执行unbind的时候才会unbind和destroy方法</p> <p>2、先bind再start： oncreate-&gt;bind-&gt;onstart  </p> <p>          unbind-&gt;ondestroy</p> <p>       先unbind再stop：  unbind  ondestroy</p> <p>       先stop再unbind：执行stop的时候 不会执行destroy的方法，直到执行unbind的时候才会unbind和destroy方法</p> <p></p> </td></tr></tbody></table> 
<p></p> 
<p> </p> 
<table><tbody><tr><td> <p>三、Service与Activity通信</p> <p></p> <p>Activity与Service通信  使用Intent</p> <p>Service与Activity通信  使用 ServiceConnection</p> </td></tr></tbody></table> 
<p></p> 
<p> </p> 
<table><tbody><tr><td> <p>public String getTime(){<!-- --></p> <p>        String time = new Date().toString();</p> <p>        return time;</p> <p>    }</p> <p>    class MyBinder extends Binder{<!-- --></p> <p>        public MyService getMyService(){<!-- --></p> <p>            return MyService.this;</p> <p>        }</p> <p>    }</p> <p>    @Override</p> <p>    public IBinder onBind(Intent intent) {<!-- --></p> <p>        Log.i("msg", "onBind");</p> <p>        return new MyBinder();</p> <p>    }</p> <p></p> </td></tr></tbody></table> 
<p></p> 
<p> </p> 
<table><tbody><tr><td> <p>ServiceConnection conn = new  ServiceConnection() {<!-- --></p> <p></p> <p>        @Override</p> <p>        public void onServiceDisconnected(ComponentName name) {<!-- --></p> <p>            Log.i("msg", "onServiceDisconnected");</p> <p></p> <p>        }</p> <p></p> <p>        @Override</p> <p>        public void onServiceConnected(ComponentName name, IBinder service) {<!-- --></p> <p>            Log.i("msg", "onServiceConnected");</p> <p>            MyBinder  myBinder = (MyBinder)service;</p> <p>            MyService myService = myBinder.getMyService();</p> <p>            Log.i("msg", myService.getTime());</p> <p>        }</p> <p>    };</p> </td></tr></tbody></table> 
<p></p> 
<p> </p> 
<table><tbody><tr><td> <p>四、IntentService</p> <p>1、IntentService是继承于Service并处理异步请求的一个类</p> <p>2、在IntentService内有一个工作线程来处理耗时操作，启动IntentService的方式和启动传统Service一样</p> <p>3、当任务执行完后，IntentService会自动停止，而不需要我们去手动控制。</p> <p>4、启动IntentService多次，而每一个耗时操作会以工作队列的方式在IntentService的onHandleIntent回调方法中执行</p> <p>5、每次只会执行一个工作线程，执行完第一个再执行第二个，以此类推。</p> <p>6、所有请求都在一个单线程中，不会阻塞应用程序的主线程（UI Thread），同一时间只处理一个请求。</p> <p>优点：省去了在Service中手动开线程的麻烦，第二，当操作完成时，我们不用手动停止Service，第三，it's so easy to use！</p> <p></p> </td></tr></tbody></table> 
<p></p> 
<p> </p> 
<table><tbody><tr><td> <p>public class MyIntentService extends IntentService {<!-- --></p> <p>    public MyIntentService() {<!-- --></p> <p>        super("name");</p> <p>    }  </p> <p></p> <p>    @Override</p> <p>    public void onCreate() {<!-- --></p> <p>        Log.i("msg", "onCreate ");</p> <p>        super.onCreate();</p> <p>    }</p> <p>    @Override</p> <p>    protected void onHandleIntent(Intent intent) {<!-- --></p> <p>        Log.i("msg", "onHandleIntent");</p> <p>        try {<!-- --></p> <p>            Thread.sleep(15000);</p> <p>        } catch (InterruptedException e) {<!-- --></p> <p>            // TODO Auto-generated catch block</p> <p>            e.printStackTrace();</p> <p>        }</p> <p></p> <p>    }</p> <p></p> <p></p> <p>}</p> <p>startService(new Intent(this,MyIntentService.class));</p> <p>        startService(new Intent(this,MyIntentService.class));</p> <p></p> <p>说明：onHandleIntent里面是可以执行耗时操作，并且是以队列的形式一个一个执行</p> </td></tr></tbody></table> 
<p></p> 
<p> </p> 
<table><tbody><tr><td> <p>五、AIDL跨进程之间的访问</p> <p></p> </td></tr></tbody></table> 
<p></p> 
<p> </p> 
<table><tbody><tr><td> <p>Server</p> <p>1、建立一个aidl的文件  建立在包里面，如果自动在gen里面生命一个IPerson的java文件，则正确   这个java文件是最终继承了BInder对象</p> <p>2、写一个类继承IPerson，然后实现里面的方法</p> <p>3、写一个Service类  ，把onBInder方法的返回值设置成Person对象，注册</p> </td></tr></tbody></table> 
<p></p> 
<p> </p> 
<table><tbody><tr><td> <p>package com.bwf.a75_serviceaidl_server;</p> <p></p> <p> interface IPerson {<!-- --></p> <p>    void setAge(int age);</p> <p>    void setName(String name);</p> <p>    String show();</p> <p>}</p> <p></p> </td></tr></tbody></table> 
<p></p> 
<p> </p> 
<table><tbody><tr><td> <p>public class Person extends IPerson.Stub{<!-- --></p> <p>    private String name;</p> <p>    private int age;</p> <p>    @Override</p> <p>    public void setAge(int age) throws RemoteException {<!-- --></p> <p>        this.age = age;</p> <p>    }</p> <p></p> <p>    @Override</p> <p>    public void setName(String name) throws RemoteException {<!-- --></p> <p>        // TODO Auto-generated method stub</p> <p>        this.name = name;</p> <p>    }</p> <p></p> <p>    @Override</p> <p>    public String show() throws RemoteException {<!-- --></p> <p>        Log.i("msg", "name: "+name+"  age: "+age);</p> <p>        return "name: "+name+"  age: "+age;</p> <p>    }</p> <p></p> <p>}</p> </td></tr></tbody></table> 
<p></p> 
<p> </p> 
<table><tbody><tr><td> <p>    @Override</p> <p>    public IBinder onBind(Intent intent) {<!-- --></p> <p></p> <p>        return new Person();</p> <p>    }</p> <p>   &lt;service android:name="com.bwf.a75_serviceaidl_server.MyService" android:exported="true"&gt;</p> <p>            &lt;intent-filter &gt;</p> <p>                &lt;action android:name="com.bwf.service"/&gt;</p> <p>                &lt;category android:name="android.intent.category.DEFAULT"/&gt;</p> <p>            &lt;/intent-filter&gt;</p> <p>        &lt;/service&gt;</p> </td></tr></tbody></table> 
<p></p> 
<p> </p> 
<table><tbody><tr><td> <p>2、Client</p> <p>1、建一个和Server一样的包名，然后再把IPersonjava类复制过来</p> <p>2、</p> </td></tr></tbody></table> 
<p></p> 
<p> </p> 
<table><tbody><tr><td> <p>private IPerson per;</p> <p>    private ServiceConnection conn = new ServiceConnection() {<!-- --></p> <p></p> <p>        @Override</p> <p>        public void onServiceDisconnected(ComponentName name) {<!-- --></p> <p>            // TODO Auto-generated method stub</p> <p></p> <p>        }</p> <p></p> <p>        @Override</p> <p>        public void onServiceConnected(ComponentName name, IBinder service) {<!-- --></p> <p>            Log.i("msg", "onServiceConnected");</p> <p>            per = IPerson.Stub.asInterface(service);</p> <p>            try {<!-- --></p> <p>                per.setAge(30);</p> <p>                per.setName("Tom");</p> <p>                Log.i("msg", "onServiceConnected "+per.show());</p> <p>            } catch (RemoteException e) {<!-- --></p> <p>                // TODO Auto-generated catch block</p> <p>                e.printStackTrace();</p> <p>            }</p> <p></p> <p>        }</p> <p>    };</p> <p>    @Override</p> <p>    protected void onCreate(Bundle savedInstanceState) {<!-- --></p> <p>        super.onCreate(savedInstanceState);</p> <p>        setContentView(R.layout.activity_main);</p> <p>        Intent intent = new Intent();</p> <p>        intent.setAction("com.bwf.service");</p> <p>        bindService(intent, conn, Context.BIND_AUTO_CREATE);</p> <p>    }</p> <p></p> <p>    @Override</p> <p>    protected void onDestroy() {<!-- --></p> <p>        unbindService(conn);</p> <p>        super.onDestroy();</p> <p>    }</p> </td></tr></tbody></table> 
<p></p> 
<p> </p> 
<table><tbody><tr><td> <p>六、应用：使用服务播放音乐</p> <p></p> </td></tr></tbody></table> 
<p></p> 
<p> </p> 
<table><tbody><tr><td> <p>public class MyService extends Service {<!-- --></p> <p>    private MediaPlayer media;</p> <p>    @Override</p> <p>    public void onCreate() {<!-- --></p> <p>        Log.i("msg", "onCreate");</p> <p>        media = MediaPlayer.create(this, R.raw.aw);</p> <p>        media.setLooping(false);</p> <p>        try {<!-- --></p> <p>            media.prepare();//准备</p> <p>        } catch (IllegalStateException e) {<!-- --></p> <p>            // TODO Auto-generated catch block</p> <p>            e.printStackTrace();</p> <p>        } catch (IOException e) {<!-- --></p> <p>            // TODO Auto-generated catch block</p> <p>            e.printStackTrace();</p> <p>        }</p> <p>        super.onCreate();</p> <p>    }</p> <p></p> <p></p> <p>    @Override</p> <p>    public int onStartCommand(Intent intent, int flags, int startId) {<!-- --></p> <p>        Log.i("msg", "onStartCommand: "+intent.getStringExtra("info"));</p> <p>        switch (intent.getIntExtra("oop", 0)) {<!-- --></p> <p>        case 1://开始音乐</p> <p>            if(media != null &amp;&amp; !media.isPlaying() ){<!-- --></p> <p>                media.start();//播放</p> <p>            }</p> <p>            break;</p> <p>        case 2://重头开始</p> <p>            if(media != null){    </p> <p>                media.seekTo(0);</p> <p>//                media.stop();</p> <p>//                media = MediaPlayer.create(this, R.raw.aw);</p> <p>//                try {<!-- --></p> <p>//                    media.prepare();</p> <p>//                } catch (IllegalStateException e) {<!-- --></p> <p>//                    // TODO Auto-generated catch block</p> <p>//                    e.printStackTrace();</p> <p>//                } catch (IOException e) {<!-- --></p> <p>//                    // TODO Auto-generated catch block</p> <p>//                    e.printStackTrace();</p> <p>//                }</p> <p>//                media.start();</p> <p>            }</p> <p>            break;</p> <p>        case 3://暂停</p> <p>            if(media != null &amp;&amp; media.isPlaying()){<!-- --></p> <p>                media.pause();</p> <p>            }</p> <p>            break;</p> <p>        default:</p> <p>            break;</p> <p>        }</p> <p></p> <p>        return super.onStartCommand(intent, flags, startId);</p> <p>    }</p> <p></p> <p>    @Override</p> <p>    public IBinder onBind(Intent intent) {<!-- --></p> <p>        Log.i("msg", "onBind");</p> <p>        return null;</p> <p>    }</p> <p></p> <p>    @Override</p> <p>    public boolean onUnbind(Intent intent) {<!-- --></p> <p>        Log.i("msg", "onUnbind");</p> <p>        return super.onUnbind(intent);</p> <p>    }</p> <p></p> <p>    @Override</p> <p>    public void onDestroy() {<!-- --></p> <p>        Log.i("msg", "onDestroy");</p> <p>        if(media != null){<!-- --></p> <p>            media.stop();</p> <p>            media.release();//释放</p> <p>            media = null;</p> <p>        }</p> <p>        super.onDestroy();</p> <p>    }</p> <p>}</p> </td></tr></tbody></table> 
<p></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3c61e75ee32619ac51faa643c0919230/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android AsyncTask已被弃用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b9c47c7d3d51434fdd0c35e3ead3ccad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue 学习总结笔记 (六)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>