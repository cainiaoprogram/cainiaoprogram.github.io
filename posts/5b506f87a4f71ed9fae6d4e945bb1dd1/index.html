<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>docker搭建proxySql&#43;MHA的读写分离与故障切换的数据库集群 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="docker搭建proxySql&#43;MHA的读写分离与故障切换的数据库集群" />
<meta property="og:description" content="参考文章：https://blog.breezelin.cn/practice-mysql-mha-docker-compose.html
参考文章的git地址：https://github.com/breeze2/mysql-mha-docker/tree/2dcd29996a9ecade0eeda96434180c998368bdfa
我的部署文件：待补充
要搭建一主一备的mysql集群。
proxysql负责读写分离，MHA负责故障切换，如果不担心脑裂的风险，故障切换用keepalived更简单。
一、MHA的搭建 mha包含有mha_manager与mha_node，node部署在每个mysql的机器上。manager管理这些node，并在故障发生时，进行主从的切换。
1.镜像准备 可以自己制作镜像，也可以使用网上已有的镜像，我这里使用的是这两个：
docker pull breeze2/mha4mysql-node:0.57 docker pull breeze2/mha4mysql-manager:0.57 2.docker-compose基础目录 准备一个docker-compose的基础目录，以后执行的命令均默认在此目录下
mkdir /home/docker/proxysql-MHA 再创建一个mha子目录，存放mha相关的配置文件与映射目录，
再创建一个scripts目录，存放mha启动相关的便捷脚本
mkdir /home/docker/proxysql-MHA/mha mkdir /home/docker/proxysql-MHA/scripts 3.编排docker-compose.yml文件 在目录/home/docker/proxysql-MHA下，创建文件docker-compose.yml，包含3个容器，一个主库、一个备库，以及一个管理节点。
version: &#34;3&#34; services: mha_master: image: breeze2/mha4mysql-node:0.57 container_name: mha_master restart: always networks: mhanet: ipv4_address: 10.5.0.10 ports: - &#34;3307:3306&#34; volumes: - &#34;/etc/localtime:/etc/localtime:ro&#34; - &#34;./mha/mha_share/:/root/mha_share/&#34; - &#34;./mha/mha_master/data/:/var/lib/mysql/&#34; - &#34;./mha/mha_master/conf/:/etc/mysql/conf.d/&#34; env_file: - ./parameters.env environment: - CONTAINER_NAME=mha_master mha_slave: image: breeze2/mha4mysql-node:0.57 container_name: mha_slave restart: always depends_on: - mha_master networks: mhanet: ipv4_address: 10." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5b506f87a4f71ed9fae6d4e945bb1dd1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-25T17:08:06+08:00" />
<meta property="article:modified_time" content="2020-09-25T17:08:06+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">docker搭建proxySql&#43;MHA的读写分离与故障切换的数据库集群</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>参考文章：<a href="https://blog.breezelin.cn/practice-mysql-mha-docker-compose.html" rel="nofollow">https://blog.breezelin.cn/practice-mysql-mha-docker-compose.html</a></p> 
<p>参考文章的git地址：<a href="https://github.com/breeze2/mysql-mha-docker/tree/2dcd29996a9ecade0eeda96434180c998368bdfa">https://github.com/breeze2/mysql-mha-docker/tree/2dcd29996a9ecade0eeda96434180c998368bdfa</a></p> 
<p>我的部署文件：待补充</p> 
<p> </p> 
<p style="text-indent:33px;">要搭建一主一备的mysql集群。</p> 
<p style="text-indent:33px;">proxysql负责读写分离，MHA负责故障切换，如果不担心脑裂的风险，故障切换用keepalived更简单。</p> 
<h3 style="text-indent:0px;">一、MHA的搭建</h3> 
<p style="text-indent:33px;">mha包含有mha_manager与mha_node，node部署在每个mysql的机器上。manager管理这些node，并在故障发生时，进行主从的切换。</p> 
<h4 style="text-indent:33px;">1.镜像准备</h4> 
<p style="text-indent:33px;">可以自己制作镜像，也可以使用网上已有的镜像，我这里使用的是这两个：</p> 
<pre><code>docker pull breeze2/mha4mysql-node:0.57
docker pull breeze2/mha4mysql-manager:0.57</code></pre> 
<h4 style="text-indent:33px;">2.docker-compose基础目录</h4> 
<p style="text-indent:33px;">准备一个docker-compose的基础目录，<span style="color:#f33b45;">以后执行的命令均默认在此目录下</span></p> 
<pre><code>mkdir /home/docker/proxysql-MHA</code></pre> 
<p style="text-indent:33px;">再创建一个mha子目录，存放mha相关的配置文件与映射目录，</p> 
<p style="text-indent:33px;">再创建一个scripts目录，存放mha启动相关的便捷脚本</p> 
<pre><code>mkdir /home/docker/proxysql-MHA/mha
mkdir /home/docker/proxysql-MHA/scripts</code></pre> 
<h4 style="text-indent:33px;">3.编排docker-compose.yml文件</h4> 
<p style="text-indent:33px;">在目录<span style="color:#86ca5e;">/home/docker/proxysql-MHA</span>下，创建文件<span style="color:#3399ea;">docker-compose.yml</span>，包含3个容器，一个主库、一个备库，以及一个管理节点。</p> 
<pre><code class="language-bash">version: "3"
services:
  mha_master:
    image: breeze2/mha4mysql-node:0.57
    container_name: mha_master
    restart: always
    networks:
      mhanet:
        ipv4_address: 10.5.0.10
    ports:
      - "3307:3306"
    volumes:
      - "/etc/localtime:/etc/localtime:ro"
      - "./mha/mha_share/:/root/mha_share/"
      - "./mha/mha_master/data/:/var/lib/mysql/"
      - "./mha/mha_master/conf/:/etc/mysql/conf.d/"
    env_file:
      - ./parameters.env
    environment:
      - CONTAINER_NAME=mha_master

  mha_slave:
    image: breeze2/mha4mysql-node:0.57
    container_name: mha_slave
    restart: always
    depends_on:
      - mha_master
    networks:
      mhanet:
        ipv4_address: 10.5.0.11
    ports:
      - "3308:3306"
    volumes:
      - "/etc/localtime:/etc/localtime:ro"
      - "./mha/mha_share/:/root/mha_share/"
      - "./mha/mha_slave/data/:/var/lib/mysql/"
      - "./mha/mha_slave/conf/:/etc/mysql/conf.d/"
    env_file:
      - ./parameters.env
    environment:
      - CONTAINER_NAME=mha_slave

  mha_manager:
    image: breeze2/mha4mysql-manager:0.57
    container_name: mha_manager
    depends_on:
      - mha_master
      - mha_slave
    restart: always
    networks:
      mhanet:
        ipv4_address: 10.5.0.9
    volumes:
      - "/etc/localtime:/etc/localtime:ro"
      - "./mha/mha_share/:/root/mha_share/"
      - "./mha/mha_manager/conf:/etc/mha"
      - "./mha/mha_manager/work:/usr/local/mha"
    entrypoint: "tailf /dev/null"
    env_file:
      - ./parameters.env
    environment:
      - CONTAINER_NAME=mha_manager
networks:
  mhanet:
    driver: bridge
    ipam:
      config:
        - subnet: 10.5.0.0/16

</code></pre> 
<p style="text-indent:33px;">同目录下的环境变量文件，<span style="color:#3399ea;">parameters.env</span>：</p> 
<pre><code>ROOT_PASSWORD=123456
MYSQL_ROOT_PASSWORD=root
MHA_SHARE_SCRIPTS_PATH=/root/mha_share/scripts
MHA_SHARE_SSHKEYS_PATH=/root/mha_share/sshkeys
</code></pre> 
<h4 style="text-indent:33px;">4.准备mysql的配置文件</h4> 
<p style="text-indent:33px;">创建目录：</p> 
<pre><code>#创建master节点的目录
mkdir ./mha/mha_master
mkdir ./mha/mha_master/conf
mkdir ./mha/mha_master/data
chmod 777 ./mha/mha_master/data

#创建slave节点的目录
mkdir ./mha/mha_slave
mkdir ./mha/mha_slave/conf
mkdir ./mha/mha_slave/data
chmod 777 ./mha/mha_slave/data</code></pre> 
<p style="text-indent:33px;">mysql主库的配置文件,执行 <span style="color:#3399ea;">vim mha/mha_master/conf/my.cnf</span>  ，内容如下</p> 
<p style="text-indent:33px;">就是常见的主从同步的配置，注意server-id不能重复以及自增id的起点不能重复</p> 
<pre><code>[mysqld]
server-id=1
log-bin=mysql-bin
binlog-ignore-db=mysql
replicate-ignore-db=mysql
auto_increment_increment=2
auto_increment_offset=1
expire_logs_days=7
</code></pre> 
<p style="text-indent:33px;">mysql从库的配置文件，执行 <span style="color:#3399ea;">vim mha/mha_slave/conf/my.cnf</span>   ,内容如下</p> 
<pre><code>[mysqld]
server-id=2
log-bin=mysql-bin
binlog-ignore-db=mysql
replicate-ignore-db=mysql
auto_increment_increment=2
auto_increment_offset=2
expire_logs_days=7

#本库只读。主库挂了以后，mha会改变只读标记
read_only=ON
relay_log_purge=0
</code></pre> 
<h4 style="text-indent:33px;">5.准备mha的配置文件以及ssh脚本和主从配置脚本</h4> 
<p style="text-indent:33px;">创建目录：</p> 
<pre><code>#创建MHA的管理节点的目录
mkdir mha/mha_manager
mkdir mha/mha_manager/conf

#创建ssh的脚本及存放sshkey的目录
mkdir mha/mha_share
mkdir mha/mha_share/scripts
mkdir mha/mha_share/sshkeys</code></pre> 
<p style="text-indent:33px;">manager的配置文件，执行 <span style="color:#3399ea;">vim mha/mha_manager/conf/app1.conf</span>  ，内容如下</p> 
<p style="text-indent:33px;">user和password是数据库的账户密码，repl_user为后面主从同步创建的用户【写在脚本里了】</p> 
<p style="text-indent:33px;">那俩目录是docker里的目录，数据库的地址则是上面docker-compose.yml中配置的内联网络，candidate_master的意思是该库可以是备选主库</p> 
<pre><code>[server default]
user=root
password=root
ssh_user=root

manager_workdir=/usr/local/mha
remote_workdir=/usr/local/mha

repl_user=myslave
repl_password=myslave

[server0]
hostname=10.5.0.10
candidate_master=1

[server1]
hostname=10.5.0.11
candidate_master=1
</code></pre> 
<p style="text-indent:33px;">接下来准备脚本了，脚本很简单，基本都能看懂。</p> 
<p style="text-indent:33px;">sshKey生成脚本<span style="color:#3399ea;">  vim mha/mha_share/scripts/ssh_generate_key.sh</span></p> 
<pre><code>ssh-keygen -t rsa -P "" -f /root/.ssh/id_rsa
if [ ! -d "$MHA_SHARE_SSHKEYS_PATH"   ];then
  mkdir "$MHA_SHARE_SSHKEYS_PATH" 
fi
cp /root/.ssh/id_rsa.pub "$MHA_SHARE_SSHKEYS_PATH/id_rsa_$CONTAINER_NAME.pub"
</code></pre> 
<p style="text-indent:33px;">sshKey共享写入脚本  <span style="color:#3399ea;">vim mha/mha_share/scripts/ssh_auth_keys.sh</span></p> 
<pre><code>cat $MHA_SHARE_SSHKEYS_PATH/*.pub &gt; /root/.ssh/authorized_keys
</code></pre> 
<p style="text-indent:33px;">mysql的主库主从同步脚本  <span style="color:#3399ea;">vim mha/mha_share/scripts/mysql_grant_slave.sh</span></p> 
<pre><code>mysql -u root -p$MYSQL_ROOT_PASSWORD &lt;&lt;EOSQL
GRANT ALL ON *.* TO myuser@'%' IDENTIFIED BY 'mypass';
GRANT ALL privileges ON *.* TO monitor@"%" IDENTIFIED BY "monitor";
GRANT REPLICATION SLAVE ON *.* TO 'myslave'@'%' IDENTIFIED BY 'myslave';
reset master;
EOSQL
</code></pre> 
<p style="text-indent:33px;">mysql的从库主从同步脚本 <span style="color:#3399ea;">vim mha/mha_share/scripts/mysql_start_slave1.sh</span></p> 
<pre><code>mysql -u root -p$MYSQL_ROOT_PASSWORD &lt;&lt;EOSQL
GRANT ALL ON *.* TO myuser@'%' IDENTIFIED BY 'mypass';
GRANT ALL privileges ON *.* TO monitor@"%" IDENTIFIED BY "monitor";
CHANGE MASTER TO MASTER_HOST='10.5.0.10', MASTER_USER='myslave', MASTER_PASSWORD='myslave', MASTER_CONNECT_RETRY=60;
start slave;
EOSQL
</code></pre> 
<p style="text-indent:33px;">mysql的从库主从同步脚本 <span style="color:#3399ea;">vim mha/mha_share/scripts/mysql_start_slave2.sh</span></p> 
<pre><code>mysql -u root -p$MYSQL_ROOT_PASSWORD &lt;&lt;EOSQL
GRANT ALL ON *.* TO myuser@'%' IDENTIFIED BY 'mypass';
GRANT ALL privileges ON *.* TO monitor@"%" IDENTIFIED BY "monitor";
CHANGE MASTER TO MASTER_HOST='10.5.0.11', MASTER_USER='myslave', MASTER_PASSWORD='myslave', MASTER_CONNECT_RETRY=60;
start slave;
EOSQL
</code></pre> 
<h4 style="text-indent:33px;">6.便捷脚本准备</h4> 
<p style="text-indent:33px;">在基础目录下的scripts目录下，准备一些便捷脚本</p> 
<p style="text-indent:33px;">ssh启动脚本，  <span style="color:#3399ea;">vim scripts/ssh_start.sh </span>，如下</p> 
<pre><code>docker exec -it mha_master /bin/bash service ssh start
docker exec -it mha_slave /bin/bash service ssh start
docker exec -it mha_manager /bin/bash service ssh start
</code></pre> 
<p style="text-indent:33px;">sshKey共享脚本,   <span style="color:#3399ea;">vim scripts/ssh_share.sh</span></p> 
<pre><code>docker exec -it mha_master /bin/bash /root/mha_share/scripts/ssh_generate_key.sh
docker exec -it mha_slave /bin/bash /root/mha_share/scripts/ssh_generate_key.sh
docker exec -it mha_manager /bin/bash /root/mha_share/scripts/ssh_generate_key.sh

docker exec -it mha_master /bin/bash /root/mha_share/scripts/ssh_auth_keys.sh
docker exec -it mha_slave /bin/bash /root/mha_share/scripts/ssh_auth_keys.sh
docker exec -it mha_manager /bin/bash /root/mha_share/scripts/ssh_auth_keys.sh
</code></pre> 
<p style="text-indent:33px;">ssh通讯检查脚本，<span style="color:#3399ea;">vim scripts/mha_check_ssh.sh </span></p> 
<pre><code>docker exec -it mha_manager masterha_check_ssh  --conf=/etc/mha/app1.conf
</code></pre> 
<p style="text-indent:33px;">数据库主从同步脚本，<span style="color:#3399ea;">vim scripts/mysql_set_mbs.sh</span></p> 
<pre><code>docker exec -it mha_master /bin/bash /root/mha_share/scripts/mysql_grant_slave.sh
docker exec -it mha_slave /bin/bash /root/mha_share/scripts/mysql_grant_slave.sh
docker exec -it mha_slave /bin/bash /root/mha_share/scripts/mysql_start_slave1.sh
docker exec -it mha_master /bin/bash /root/mha_share/scripts/mysql_start_slave2.sh</code></pre> 
<p style="text-indent:33px;">主从同步关系检查脚本， <span style="color:#3399ea;">vim scripts/mha_check_repl.sh</span></p> 
<pre><code>docker exec -it mha_manager masterha_check_repl  --conf=/etc/mha/app1.conf
</code></pre> 
<p style="text-indent:33px;">mha监控启动脚本，  <span style="color:#3399ea;">vim scripts/mha_start_manager.sh</span></p> 
<pre><code>docker exec -it mha_manager masterha_manager --conf=/etc/mha/app1.conf
</code></pre> 
<h4 style="text-indent:33px;">7.启动MHA集群</h4> 
<pre><code>#创建并启动docker容器
docker-compose up -d

#启动各个容器的ssh服务，如果重启了容器，只需执行此步骤即可
sh ./scripts/ssh_start.sh

#将各个容器的sshKey共享给其它容器
sh ./scripts/ssh_share.sh

#检查各个容器间，ssh互通情况
sh ./scripts/mha_check_ssh.sh

#配置数据库的主从关系
sh ./scripts/mysql_set_mbs.sh

#检查数据库的主从关系
sh ./scripts/mha_check_repl.sh</code></pre> 
<p style="text-indent:33px;">还有最后一步，启动mha的监控，这是一个监控的脚本，所以最好放在后台运行，我这里使用了screen程序，不知道的可以百度。</p> 
<pre><code>#创建mha监控的会话
screen -S mha_manager

#默认进入了会话，执行监控脚本
sh ./scripts/mha_start_manager.sh

#退出会话，按键盘上的Ctrl+A+D

#查看已有会话
screen -ls

#恢复会话
screen -r mha_manager

#关闭会话，在会话内执行
exit</code></pre> 
<p style="text-indent:33px;">如果有容器重启了，只需执行启动ssh的脚本即可，如果mha的监控脚本停下来了，也要再执行。</p> 
<h3 style="text-indent:0px;">二、proxysql部署</h3> 
<h4 style="text-indent:33px;">1.下载镜像</h4> 
<p style="text-indent:33px;">proxysql有官方的镜像，下载官方镜像最新版即可</p> 
<pre><code>docker pull proxysql/proxysql</code></pre> 
<h4 style="text-indent:33px;">2.编排docker-compose.yml文件</h4> 
<p style="text-indent:33px;">还是同一个<span style="color:#3399ea;">docker-compose.yml</span>文件，再加一个容器即可</p> 
<pre><code>  proxysql:
    image: proxysql/proxysql
    restart: always
    networks:
      mhanet:
        ipv4_address: 10.5.0.2
    ports:
      - "6032:6032"
      - "6033:6033"
    environment:
      MONITOR_CONFIG_CHANGE: "true"
    volumes:
      - "/etc/localtime:/etc/localtime:ro"
      - "./proxysql/proxysql.cnf:/etc/proxysql.cnf:ro"</code></pre> 
<h4 style="text-indent:33px;">3.准备proxysql的配置文件</h4> 
<p style="text-indent:33px;">创建目录</p> 
<pre><code>#创建proxysql的目录
mkdir /home/docker/proxysql-MHA/proxysql</code></pre> 
<p style="text-indent:33px;">创建配置文件，<span style="color:#3399ea;">vim proxusql/proxysql.cnf</span>, 内容如下</p> 
<pre><code>#file proxysql.cfg
 
datadir="/var/lib/proxysql"
 
admin_variables=
{
        #登录proxysql的管理库时使用的账号，admin只能在本地使用，必须再配一个
        admin_credentials="admin:admin;root:root"
        mysql_ifaces="0.0.0.0:6032"
}
 
#proxysql的地址，在建立proxysql集群时，有用
proxysql_servers =
(
    {
        hostname="10.5.0.2"
        port=6032
        comment="proxysql_01"
    }
)

#一些变量，monitor_username这个要在数据库中建立相应账户
mysql_variables=
{
  threads=4
  max_connections=2048
  default_query_delay=0
  default_query_timeout=36000000
  have_compress=true
  poll_timeout=2000
  interfaces="0.0.0.0:6033"
  default_schema="information_schema"
  stacksize=1048576
  server_version="5.5.30"
  connect_timeout_server=3000
  monitor_username="monitor"
  monitor_password="monitor"
  monitor_history=600000
  monitor_connect_interval=60000
  monitor_ping_interval=10000
  monitor_read_only_interval=1500
  monitor_read_only_timeout=500
  ping_interval_server_msec=120000
  ping_timeout_server=500
  commands_stats=true
  sessions_sort=true
  connect_retries_on_failure=10
}
 
# 数据库的地址，hostgroup时数据库的组别，
mysql_servers =
(
  { address="10.5.0.10" , port=3306 , hostgroup=1 },
  { address="10.5.0.11" , port=3306 , hostgroup=2 }
)
 
# proxysql最终代理库的账号密码
mysql_users:
(
  {
    username = "myuser" 
    password = "mypass"
    default_hostgroup = 1
    active = 1 
  }
)
 
#mysql的规则，读写分离规则，读走组别2，写走组别1
mysql_query_rules:
(
 {
   rule_id=100
   active=1
   schemaname="test"
   username="myuser"
   match_digest="(?i)^SELECT.*$"
   destination_hostgroup=2
   apply=1
 },
 {
   rule_id=200
   active=1
   schemaname="test"
   username="myuser"
   match_digest="(?i)^(?!SELECT).*$"
   destination_hostgroup=1
   apply=1
 }
)
 
scheduler=
(
#  {
#    id=1
#    active=0
#    interval_ms=10000
#    filename="/var/lib/proxysql/proxysql_galera_checker.sh"
#    arg1="0"
#    arg2="0"
#    arg3="0"
#    arg4="1"
#    arg5="/var/lib/proxysql/proxysql_galera_checker.log"
#  }
)
 
#readongly为0的库认为是写库，readonly为1的库认为是读库，搭配mha切换主从使用
mysql_replication_hostgroups=
(
        {
                writer_hostgroup=1
                reader_hostgroup=2
                comment="test repl 1"
       }
)
</code></pre> 
<h4 style="text-indent:33px;">4.启动proxysql</h4> 
<pre><code>docker-compose up -d proxysql</code></pre> 
<p style="text-indent:33px;">登入proxysql的管理数据库（最好用命令行模式），宿主机IP+PORT，账户密码root/root</p> 
<pre><code>mysql -h 192.168.3.237 -P 6032 -u root -proot</code></pre> 
<p style="text-indent:33px;">检查当前活跃的数据库，以及分组状况</p> 
<pre><code class="language-sql">select * from runtime_mysql_servers;</code></pre> 
<p style="text-indent:33px;">结果：能看到 两个数据库一个是组1（写），一个是组2（读），写都走10.5.0.10，读都走10.5.0.11</p> 
<p><img alt="" height="171" src="https://images2.imgbox.com/db/c6/MmZ0wuob_o.png" width="1200"></p> 
<p style="text-indent:33px;">这时我们把主库关掉，然后再看下情况。</p> 
<p style="text-indent:33px;">回到服务器的<span style="color:#86ca5e;">/home/docker/proxysql-MHA</span>目录，执行关闭master的数据库的命令</p> 
<pre><code>#先把容器自动重启关闭
docker update --restart=no mha_master

#关闭mha_master 的数据库
docker exec -it mha_master mysqladmin shutdown -uroot -proot</code></pre> 
<p style="text-indent:33px;">使用命令<span style="color:#3399ea;">screen -r mha_manager</span>，回到mha监控的会话，可以看到mha进行了主从切换</p> 
<p style="text-indent:33px;">再回到mha的管理库，查看表runtime_mysql_servers，可以看到10.5.0.11这个库即在写组，也在读组，完成了故障转移。</p> 
<p style="text-indent:0;"><img alt="" height="162" src="https://images2.imgbox.com/b4/aa/XdiKbFsW_o.png" width="1200"></p> 
<p style="text-indent:33px;">若想恢复，先启动主库，再启动ssh，（等数据从从库同步到主库完成后），再重配主从同步，把从库readonly设为1，删除上次failover的标记文件，然后再次启动manager的监控进程</p> 
<p style="text-indent:33px;">从库只读设置</p> 
<pre><code class="language-sql">set  GLOBAL read_only=1</code></pre> 
<p style="text-indent:33px;">删除上次failover的标记文件的命令</p> 
<pre><code>docker exec -it mha_manager rm /usr/local/mha/app1.failover.complete</code></pre> 
<p style="text-indent:33px;">如此就会恢复原来的主从状态。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a8aa89a6c4f16b32f7bd4fe7da1e42ee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android   APPbarlayout与SwipeRefreshLayout刷新滑动冲突解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/53fddf65017c643d391c6f0862f83ba7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Unity中c#为客户端，c&#43;&#43;为服务器端进行socket通信</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>