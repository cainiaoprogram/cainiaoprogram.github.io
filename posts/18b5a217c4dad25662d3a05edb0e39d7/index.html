<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JVM" />
<meta property="og:description" content="1.说一下 JVM 的主要组成部分？及其作用？ 类加载器（ClassLoader）
运行时数据区（Runtime Data Area）
执行引擎（Execution Engine）
本地库接口（Native Interface）
组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。
2.java内存模型 https://blog.csdn.net/javazejian/article/details/72772461
2.说一下 JVM 运行时数据区？ 不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：
程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；
Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；
本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；
Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；
方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。
3.说一下堆栈的区别？ 功能方面：堆是用来存放对象的，栈是用来执行程序的。
共享性：堆是线程共享的，栈是线程私有的。
空间大小：堆大小远远大于栈。
4.队列和栈是什么？有什么区别？ 队列和栈都是被用来预存储数据的。
队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。
栈和队列很相似，但它运行对元素进行后进先出进行检索。
5.什么是双亲委派模型？ 在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/18b5a217c4dad25662d3a05edb0e39d7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-04T22:12:11+08:00" />
<meta property="article:modified_time" content="2021-08-04T22:12:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1_JVM__1"></a>1.说一下 JVM 的主要组成部分？及其作用？</h3> 
<p>类加载器（ClassLoader）</p> 
<p>运行时数据区（Runtime Data Area）</p> 
<p>执行引擎（Execution Engine）</p> 
<p>本地库接口（Native Interface）</p> 
<p>组件的作用： 首先通过类加载器（ClassLoader）会把 Java 代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，而字节码文件只是 JVM 的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。</p> 
<h3><a id="2java_13"></a>2.java内存模型</h3> 
<p>https://blog.csdn.net/javazejian/article/details/72772461</p> 
<h3><a id="2_JVM__17"></a>2.说一下 JVM 运行时数据区？</h3> 
<p>不同虚拟机的运行时数据区可能略微有所不同，但都会遵从 Java 虚拟机规范， Java 虚拟机规范规定的区域分为以下 5 个部分：</p> 
<p>程序计数器（Program Counter Register）：当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成；</p> 
<p>Java 虚拟机栈（Java Virtual Machine Stacks）：用于存储局部变量表、操作数栈、动态链接、方法出口等信息；</p> 
<p>本地方法栈（Native Method Stack）：与虚拟机栈的作用是一样的，只不过虚拟机栈是服务 Java 方法的，而本地方法栈是为虚拟机调用 Native 方法服务的；</p> 
<p>Java 堆（Java Heap）：Java 虚拟机中内存最大的一块，是被所有线程共享的，几乎所有的对象实例都在这里分配内存；</p> 
<p>方法区（Methed Area）：用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</p> 
<h3><a id="3_31"></a>3.说一下堆栈的区别？</h3> 
<p>功能方面：堆是用来存放对象的，栈是用来执行程序的。</p> 
<p>共享性：堆是线程共享的，栈是线程私有的。</p> 
<p>空间大小：堆大小远远大于栈。</p> 
<h3><a id="4_39"></a>4.队列和栈是什么？有什么区别？</h3> 
<p>队列和栈都是被用来预存储数据的。</p> 
<p>队列允许先进先出检索元素，但也有例外的情况，Deque 接口允许从两端检索元素。</p> 
<p>栈和队列很相似，但它运行对元素进行后进先出进行检索。</p> 
<h3><a id="5_47"></a>5.什么是双亲委派模型？</h3> 
<p>在介绍双亲委派模型之前先说下类加载器。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立在 JVM 中的唯一性，每一个类加载器，都有一个独立的类名称空间。类加载器就是根据指定全限定名称将 class 文件加载到 JVM 内存，然后再转化为 class 对象。</p> 
<p>jvm对class文件采用的是按需加载的方式，当需要使用该类时，jvm才会将它的class文件加载到内存中产生class对象。</p> 
<p>在加载类的时候，是采用的<code>双亲委派机制</code>，即把请求交给父类处理的一种任务委派模式。</p> 
<p>类加载器分类：</p> 
<p>启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分，用来加载 Java_HOME/lib/目录中的，或者被 -Xbootclasspath 参数所指定的路径中并且被虚拟机识别的类库；</p> 
<p>其他类加载器：</p> 
<p>扩展类加载器（Extension ClassLoader）：负责加载\lib\ext 目录或 Java. ext. dirs 系统变量指定的路径中的所有类库；</p> 
<p>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p> 
<ul><li><strong>工作原理</strong></li></ul> 
<p>（1）如果一个<code>类加载器</code>接收到了<code>类加载</code>的请求，它自己不会先去加载，会把这个请求委托给<code>父类加载器</code>去执行。</p> 
<p>（2）如果父类还存在父类加载器，则继续向上委托，一直委托到<code>启动类加载器：Bootstrap ClassLoader</code></p> 
<p>（3）如果父类加载器可以完成加载任务，就返回成功结果，如果父类加载失败，就由子类自己去尝试加载，如果子类加载失败就会抛出<code>ClassNotFoundException</code>异常，这就是<code>双亲委派模式</code></p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-EwCtr9ob-1630242241412)(JVM.assets/bVcHO1J.jpg)]</p> 
<ul><li><strong>第三方包加载方式：反向委派机制</strong></li></ul> 
<p>在Java应用中存在着很多服务提供者接口（Service Provider Interface，SPI），这些接口允许第三方为它们提供实现，如常见的 SPI 有 JDBC、JNDI等，这些 SPI 的接口属于 Java 核心库，一般存在rt.jar包中，由Bootstrap类加载器加载。而Bootstrap类加载器无法直接加载SPI的实现类，同时由于双亲委派模式的存在，Bootstrap类加载器也无法反向委托AppClassLoader加载器SPI的实现类。在这种情况下，我们就需要一种特殊的类加载器来加载第三方的类库，而线程上下文类加载器（双亲委派模型的破坏者）就是很好的选择。</p> 
<p>从图可知rt.jar核心包是有Bootstrap类加载器加载的，其内包含SPI核心接口类，由于SPI中的类经常需要调用外部实现类的方法，而jdbc.jar包含外部实现类(jdbc.jar存在于classpath路径)无法通过Bootstrap类加载器加载，因此只能委派线程上下文类加载器把jdbc.jar中的实现类加载到内存以便SPI相关类使用。显然这种线程上下文类加载器的加载方式破坏了“双亲委派模型”，它在执行过程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器，当然这也使得Java类加载器变得更加灵活。</p> 
<p><img src="https://images2.imgbox.com/79/5d/ISLmRUvV_o.png" alt="image.png"></p> 
<ul><li><strong>沙箱安全机制</strong></li></ul> 
<p>自定义 String 类，但是在加载自定义 String 类的时候会率先使用引导类加载器加载，而引导类加载器在加载的过程中会先加载 JDK 自带的文件（rt.jar 包中的 javalangString.class），报错信息说没有 main 方法就是因为加载的 rt.jar 包中的 String 类。这样可以保证对 Java 核心源代码的保护，这就是沙箱安全机制。</p> 
<h3><a id="6_87"></a>6.类加载的过程</h3> 
<p>这里简要说明下Java中的绑定：绑定指的是把一个方法的调用与方法所在的类(方法主体)关联起来，对java来说，绑定分为静态绑定和动态绑定：</p> 
<ul><li>静态绑定：即前期绑定。在程序执行前方法已经被绑定，此时由编译器或其它连接程序实现。针对java，简单的可以理解为程序编译期的绑定。java当中的方法只有final，static，private和构造方法是前期绑定的。</li><li>动态绑定：即晚期绑定，也叫运行时绑定。在运行时根据具体对象的类型进行绑定。在java中，几乎所有的方法都是后期绑定的。</li></ul> 
<p>Java代码执行流程图</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CSzhYyZx-1630242241417)(JVM.assets/v2-ecf6c3d0f5146029e9693d6223d23afb_720w-16280613795251.jpg)]</p> 
<p><strong>前言</strong></p> 
<p>一个Java文件从编码完成到最终执行，一般主要包括两个过程</p> 
<ul><li>编译</li><li>运行</li></ul> 
<p><strong>编译</strong>，即把我们写好的java文件，通过javac命令编译成字节码，也就是我们常说的.class文件。</p> 
<p><strong>运行</strong>，则是把编译生成的.class文件交给Java虚拟机(JVM)执行。</p> 
<p>而我们所说的类加载过程即是指JVM虚拟机把.class文件中类信息加载进内存，并进行解析生成对应的class对象的过程。</p> 
<p>举个通俗点的例子来说，JVM在执行某段代码时，遇到了class A， 然而此时内存中并没有class A的相关信息，于是JVM就会到相应的class文件中去寻找class A的类信息，并加载进内存中，这就是我们所说的类加载过程。</p> 
<p>由此可见，JVM不是一开始就把所有的类都加载进内存中，而是只有第一次遇到某个需要运行的类时才会加载，且<strong>只加载一次</strong>。</p> 
<p><strong>类加载</strong></p> 
<p>类加载的过程主要分为三个部分：</p> 
<ul><li>加载</li><li>链接</li><li>初始化</li></ul> 
<p>而链接又可以细分为三个小部分：</p> 
<ul><li>验证</li><li>准备</li><li>解析</li></ul> 
<p><strong>第一步加载</strong></p> 
<p>简单来说，加载指的是把class字节码文件从各个来源通过类加载器装载入内存中。通过类的全限定名（包名 + 类名），获取到该类的<code>.class</code>文件的二进制字节流。</p> 
<blockquote> 
 <p>将二进制字节流所代表的静态存储结构，转化为方法区运行时的数据结构</p> 
 <p>在内存中生成一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p> 
 <p>总结：加载二进制数据到内存 —&gt; 映射成jvm能识别的结构 —&gt; 在内存中生成class文件。</p> 
</blockquote> 
<p>这里有两个重点：</p> 
<ul><li><strong>字节码来源</strong>。一般的加载来源包括从本地路径下编译生成的.class文件，从jar包中的.class文件，从远程网络，以及动态代理实时编译</li><li><strong>类加载器</strong>。一般包括<strong>启动类加载器</strong>，<strong>扩展类加载器</strong>，<strong>应用类加载器</strong>，以及用户的<strong>自定义类加载器</strong>。</li></ul> 
<p><strong>注：为什么会有自定义类加载器？</strong></p> 
<ul><li>一方面是由于java代码很容易被反编译，如果需要对自己的代码加密的话，可以对编译后的代码进行加密，然后再通过实现自己的自定义类加载器进行解密，最后再加载。</li><li>另一方面也有可能从非标准的来源加载代码，比如从网络来源，那就需要自己实现一个类加载器，从指定源进行加载。</li></ul> 
<p><strong>第二步链接</strong></p> 
<p>链接是指将上面创建好的class类合并至Java虚拟机中，使之能够执行的过程，可分为验证、准备、解析三个阶段。</p> 
<ul><li><strong>验证</strong></li></ul> 
<p>主要是为了保证加载进来的字节流符合虚拟机规范，不会造成安全错误。确保class文件中的字节流包含的信息，符合当前虚拟机的要求，保证这个被加载的class类的正确性，不会危害到虚拟机的安全。</p> 
<blockquote> 
 <p>包括对于<strong>文件格式的验证</strong>，比如常量中是否有不被支持的常量？文件中是否有不规范的或者附加的其他信息？</p> 
 <p>对于<strong>元数据的验证</strong>，比如该类是否继承了被final修饰的类？类中的字段，方法是否与父类冲突？是否出现了不合理的重载？</p> 
 <p>对于<strong>字节码的验证</strong>，保证程序语义的合理性，比如要保证类型转换的合理性。</p> 
 <p>对于<strong>符号引用的验证</strong>，比如校验符号引用中通过全限定名是否能够找到对应的类？校验符号引用中的访问性（private，public等）是否可被当前类访问？</p> 
</blockquote> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-WPlt29Kq-1630242241419)(JVM.assets/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d362f2545392541412538432545382541462538312545392539382542362545362541452542352e706e67.jpg)]</p> 
<ul><li><strong>准备</strong></li></ul> 
<p>主要是为类变量（注意，不是实例变量）分配内存，并且赋予<strong>初值</strong>。</p> 
<p>特别需要注意，<strong>初值，不是代码中具体写的初始化的值</strong>，而是Java虚拟机根据不同变量类型的默认初始值。</p> 
<p>比如8种<strong>基本类型</strong>的初值，默认为0；<strong>引用类型</strong>的初值则为null；被final修饰的static字段不会设置，因为final在编译的时候就分配了<strong>常量</strong>的初值即为代码中设置的值，final static tmp = 456， 那么该阶段tmp的初值就是456</p> 
<ul><li><strong>解析</strong></li></ul> 
<p>将常量池内的符号引用替换为直接引用的过程。</p> 
<p>解析动作主要针对类、接口、字段、类方法、接口方法、方法类型等。对应常量池中的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等。</p> 
<blockquote> 
 <p>两个重点：</p> 
 <ul><li><strong>符号引用</strong>。即一个字符串，但是这个字符串给出了一些能够唯一性识别一个方法，一个变量，一个类的相关信息。</li><li><strong>直接引用</strong>。可以理解为一个内存地址，或者一个偏移量。比如<strong>类方法，类变量</strong>的直接引用是指向方法区的<strong>指针</strong>；而<strong>实例方法，实例变量</strong>的直接引用则是从实例的头指针开始算起到这个实例变量位置的<strong>偏移量</strong></li></ul> 
 <p>举个例子来说，现在调用方法hello()，这个方法的地址是1234567，那么hello就是符号引用，1234567就是直接引用。</p> 
 <p>在解析阶段，虚拟机会把所有的类名，方法名，字段名这些符号引用替换为具体的内存地址或偏移量，也就是直接引用。</p> 
</blockquote> 
<p><strong>初始化</strong></p> 
<p>初始化就是执行类的构造器方法<code>init</code>()的过程。</p> 
<p>这个方法不需要定义，是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并来的。</p> 
<p>若该类具有父类，<code>jvm</code>会保证父类的<code>init</code>先执行，然后在执行子类的<code>init</code>。</p> 
<blockquote> 
 <p>这个阶段主要是对<strong>类变量</strong>初始化，是执行类构造器的过程。</p> 
 <p>换句话说，只对static修饰的变量或语句进行初始化。</p> 
 <p>如果初始化一个类的时候，其父类尚未初始化，则优先初始化其父类。</p> 
 <p>如果同时包含多个静态变量和静态代码块，则按照自上而下的顺序依次执行。</p> 
</blockquote> 
<h3><a id="8_206"></a>8.类加载器的分类</h3> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eSEXjtI5-1630242241421)(JVM.assets/bVcHO1F.jpg)]</p> 
<ul><li><strong>第一个：启动类/引导类：Bootstrap ClassLoader</strong></li></ul> 
<blockquote> 
 <p>这个类加载器使用C/C++语言实现的，嵌套在JVM内部，java程序无法直接操作这个类。</p> 
 <p>它用来加载Java核心类库，如：<code>JAVA_HOME/jre/lib/rt.jar</code>、<code>resources.jar</code>、<code>sun.boot.class.path</code>路径下的包，用于提供jvm运行所需的包。</p> 
 <p>并不是继承自java.lang.ClassLoader，它没有父类加载器</p> 
 <p>它加载<code>扩展类加载器</code>和<code>应用程序类加载器</code>，并成为他们的父类加载器</p> 
 <p>出于安全考虑，启动类只加载包名为：java、javax、sun开头的类</p> 
</blockquote> 
<ul><li><strong>第二个：扩展类加载器：Extension ClassLoader</strong></li></ul> 
<blockquote> 
 <p>Java语言编写，由</p> 
 <pre><code>sun.misc.Launcher$ExtClassLoader
</code></pre> 
 <p>实现，我们可以用Java程序操作这个加载器</p> 
 <p>派生继承自java.lang.ClassLoader，父类加载器为<code>启动类加载器</code></p> 
 <p>从系统属性：<code>java.ext.dirs</code>目录中加载类库，或者从JDK安装目录：<code>jre/lib/ext</code>目录下加载类库。我们就可以将我们自己的包放在以上目录下，就会自动加载进来了。</p> 
</blockquote> 
<ul><li><strong>第三个：应用程序类加载器：Application Classloader</strong></li></ul> 
<blockquote> 
 <p>Java语言编写，由</p> 
 <pre><code>sun.misc.Launcher$AppClassLoader
</code></pre> 
 <p>实现。</p> 
 <p>派生继承自java.lang.ClassLoader，父类加载器为<code>启动类加载器</code></p> 
 <p>它负责加载<code>环境变量classpath</code>或者<code>系统属性java.class.path</code>指定路径下的类库</p> 
 <p>它是程序中默认的类加载器，我们Java程序中的类，都是由它加载完成的。</p> 
 <p>我们可以通过<code>ClassLoader#getSystemClassLoader()</code>获取并操作这个加载器</p> 
</blockquote> 
<ul><li><strong>第四个：自定义加载器</strong></li></ul> 
<blockquote> 
 <p>一般情况下，以上3种加载器能满足我们日常的开发工作，不满足时，我们还可以自定义加载器</p> 
 <p>比如用网络加载Java类，为了保证传输中的安全性，采用了加密操作，那么以上3种加载器就无法加载这个类，这时候就需要<code>自定义加载器</code></p> 
</blockquote> 
<p><strong>自定义加载器实现步骤</strong></p> 
<blockquote> 
 <p>继承</p> 
 <pre><code>java.lang.ClassLoader
</code></pre> 
 <p>类，重写findClass()方法</p> 
 <p>如果没有太复杂的需求，可以直接继承<code>URLClassLoader</code>类，重写<code>loadClass</code>方法，具体可参考<code>AppClassLoader</code>和<code>ExtClassLoader</code>。</p> 
</blockquote> 
<p><strong>获取ClassLoader几种方式</strong></p> 
<p>它是一个抽象类，其后所有的类加载器继承自 ClassLoader（不包括启动类加载器）</p> 
<pre><code class="prism language-java"><span class="token comment">// 方式一：获取当前类的 ClassLoader</span>
clazz<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 方式二：获取当前线程上下文的 ClassLoader</span>
<span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 方式三：获取系统的 ClassLoader</span>
<span class="token class-name">ClassLoader</span><span class="token punctuation">.</span><span class="token function">getSystemClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// 方式四：获取调用者的 ClassLoader</span>
<span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getCallerClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="7_287"></a>7.怎么判断对象是否可以被回收？</h3> 
<p>一般有两种方法来判断：</p> 
<p>引用计数器：为每个对象创建一个引用计数，有对象引用时计数器 +1，引用被释放时计数 -1，当计数器为 0 时就可以被回收。它有一个缺点不能解决循环引用的问题；</p> 
<p>可达性分析：从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是可以被回收的。</p> 
<h3><a id="8Java__295"></a>8.Java 中都有哪些引用类型？</h3> 
<p>强引用：发生 gc 的时候不会被回收。</p> 
<p>软引用：有用但不是必须的对象，在发生内存溢出之前会被回收。</p> 
<p>弱引用：有用但不是必须的对象，在下一次 GC 时会被回收。</p> 
<p>虚引用（幽灵引用/幻影引用）：无法通过虚引用获得对象，用 PhantomReference 实现虚引用，虚引用的用途是在 gc 时返回一个通知。</p> 
<h3><a id="9_JVM__305"></a>9.说一下 JVM 有哪些垃圾回收算法？</h3> 
<p>标记-清除算法：标记无用对象，然后进行清除回收。缺点：效率不高，无法清除垃圾碎片。</p> 
<p>标记-整理算法：标记无用对象，让所有存活的对象都向一端移动，然后直接清除掉端边界以外的内存。</p> 
<p>复制算法：按照容量划分二个大小相等的内存区域，当一块用完的时候将活着的对象复制到另一块上，然后再把已使用的内存空间一次清理掉。缺点：内存使用率不高，只有原来的一半。</p> 
<p>分代算法：根据对象存活周期的不同将内存划分为几块，一般是新生代和老年代，新生代基本采用复制算法，老年代采用标记整理算法。</p> 
<h3><a id="10_JVM__315"></a>10.说一下 JVM 有哪些垃圾回收器？</h3> 
<p>Serial：最早的单线程串行垃圾回收器。</p> 
<p>Serial Old：Serial 垃圾回收器的老年版本，同样也是单线程的，可以作为 CMS 垃圾回收器的备选预案。</p> 
<p>ParNew：是 Serial 的多线程版本。</p> 
<p>Parallel 和 ParNew 收集器类似是多线程的，但 Parallel 是吞吐量优先的收集器，可以牺牲等待时间换取系统的吞吐量。</p> 
<p>Parallel Old 是 Parallel 老生代版本，Parallel 使用的是复制的内存回收算法，Parallel Old 使用的是标记-整理的内存回收算法。</p> 
<p>CMS：一种以获得最短停顿时间为目标的收集器，非常适用 B/S 系统。</p> 
<p>G1：一种兼顾吞吐量和停顿时间的 GC 实现，是 JDK 9 以后的默认 GC 选项。</p> 
<h3><a id="11__CMS__331"></a>11. 详细介绍一下 CMS 垃圾回收器？</h3> 
<p>CMS 是英文 Concurrent Mark-Sweep 的简称，是以牺牲吞吐量为代价来获得最短回收停顿时间的垃圾回收器。对于要求服务器响应速度的应用上，这种垃圾回收器非常适合。在启动 JVM 的参数加上“-XX:+UseConcMarkSweepGC”来指定使用 CMS 垃圾回收器。</p> 
<p>CMS 使用的是标记-清除的算法实现的，所以在 gc 的时候回产生大量的内存碎片，当剩余内存不能满足</p> 
<p>程序运行要求时，系统将会出现 Concurrent Mode Failure，临时 CMS 会采用 Serial Old 回收器进行垃圾清除，此时的性能将会被降低。</p> 
<h3><a id="12_339"></a>12.新生代垃圾回收器和老生代垃圾回收器都有哪些？有什么区别？</h3> 
<p>新生代回收器：Serial、ParNew、Parallel Scavenge</p> 
<p>老年代回收器：Serial Old、Parallel Old、CMS</p> 
<p>整堆回收器：G1</p> 
<p>新生代垃圾回收器一般采用的是复制算法，复制算法的优点是效率高，缺点是内存利用率低；老年代回收器一般采用的是标记-整理的算法进行垃圾回收。</p> 
<h3><a id="13_349"></a>13.简述分代垃圾回收器是怎么工作的？</h3> 
<p>分代回收器有两个分区：老生代和新生代，新生代默认的空间占比总空间的 1/3，老生代的默认占比是2/3。</p> 
<p>新生代使用的是复制算法，新生代里有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：</p> 
<p>把 Eden + From Survivor 存活的对象放入 To Survivor 区；</p> 
<p>清空 Eden 和 From Survivor 分区；</p> 
<p>From Survivor 和 To Survivor 分区交换，From Survivor 变 To Survivor，To Survivor 变 From Survivor。</p> 
<p>每次在 From Survivor 到 To Survivor 移动时都存活的对象，年龄就 +1，当年龄到达 15（默认配置是15）时，升级为老生代。大对象也会直接进入老生代。</p> 
<p>老生代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理的执行算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。</p> 
<h3><a id="14_JVM__365"></a>14说一下 JVM 调优的工具？</h3> 
<p>JDK 自带了很多监控工具，都位于 JDK 的 bin 目录下，其中最常用的是 jconsole 和 jvisualvm 这两款视图监控工具。</p> 
<p>jconsole：用于对 JVM 中的内存、线程和类等进行监控；</p> 
<p>jvisualvm：JDK 自带的全能分析工具，可以分析：内存快照、线程快照、程序死锁、监控内存的变化、gc 变化等。</p> 
<h3><a id="15_JVM__373"></a>15.常用的 JVM 调优的参数都有哪些？</h3> 
<p>-Xms2g：初始化推大小为 2g；</p> 
<p>-Xmx2g：堆最大内存为 2g；</p> 
<p>-XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；</p> 
<p>-XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；</p> 
<p>–XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；</p> 
<p>-XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；</p> 
<p>-XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；</p> 
<p>-XX:+PrintGC：开启打印 gc 信息；</p> 
<p>-XX:+PrintGCDetails：打印 gc 详细信息。</p> 
<h3><a id="16_393"></a>16.线程池</h3> 
<p>https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0d6288b49a1f8cea8a6deacb4e845fac/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">战争雷霆显示认证服务器不可用,战争雷霆81110007错误怎么办 代码原因解决方法...</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1d08729631b5c8cff97038ab830bcb05/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">华为服务器微信公众号,记录：华为配置小程序后台服务器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>