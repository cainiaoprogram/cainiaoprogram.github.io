<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>线程等待的四种方式-join/future/countDownLatch/cylicBarrier实现 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="线程等待的四种方式-join/future/countDownLatch/cylicBarrier实现" />
<meta property="og:description" content="场景如下：一共三个线程a,b,c,其中c需要用到a,b,执行的结果,应该怎么处理? 1）CountDownLatch，主线程中调用await方法，每个线程调用countdown 上面两种方法需要分别调用多次join或future的get方法,不太好,有一种方法是使用CountDownLatch类
认知CountDownLatch的方法:
await():阻塞主线程,直到countDownLatch的计数器减少到0的位置,
countDown:将当前的计数器减1
getCount:返回当前的数
思路如下:让a,b线程使用CountDowmLatch,然后执行countDownLatch的await方法
主类:
public static void main(String[] args) {
CountDownLatch countDownLaunch = new CountDownLatch(5);
for(int i=1;i&lt;6;i&#43;&#43;){
ThreadWithCountDownLatch threadWithCountDownLatch = new ThreadWithCountDownLatch(i*1000L,countDownLaunch,&#34;THREAD&#34;&#43;i);
Thread thread = new Thread(threadWithCountDownLatch);
thread.start();
}
mainThreadWork();
try {
countDownLaunch.await();//下面的代码要等待所有的countDown的计数器为零再执行
} catch (InterruptedException e) {
// TODO Auto-generated catch block
e.printStackTrace();
}
System.out.println(&#34;all done&#34;); }
线程类:
public class ThreadWithCountDownLatch implements Runnable{
long time;
CountDownLatch countDownLatch;
String name;
public ThreadWithCountDownLatch(long time,CountDownLatch countDownLatch,String name){" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/393a259167452249cab2faec2c02d48e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-11T16:31:32+08:00" />
<meta property="article:modified_time" content="2023-08-11T16:31:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">线程等待的四种方式-join/future/countDownLatch/cylicBarrier实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>场景如下：一共三个线程a,b,c,其中c需要用到a,b,执行的结果,应该怎么处理?    </p> 
<h4>1）CountDownLatch，主线程中调用await方法，每个线程调用countdown</h4> 
<p>上面两种方法需要分别调用多次join或future的get方法,不太好,有一种方法是使用CountDownLatch类<br> 认知CountDownLatch的方法:<br> await():阻塞主线程,直到countDownLatch的计数器减少到0的位置,<br> countDown:将当前的计数器减1<br> getCount:返回当前的数<br> 思路如下:让a,b线程使用CountDowmLatch,然后执行countDownLatch的await方法<br> 主类:<br>     public static void main(String[] args) {<!-- --><br>         CountDownLatch countDownLaunch = new CountDownLatch(5);<br>         for(int i=1;i&lt;6;i++){<!-- --><br>             ThreadWithCountDownLatch threadWithCountDownLatch = new ThreadWithCountDownLatch(i*1000L,countDownLaunch,"THREAD"+i);<br>             Thread thread = new Thread(threadWithCountDownLatch);<br>             thread.start();<br>         }<br>         mainThreadWork();<br>         try {<!-- --><br>             countDownLaunch.await();//下面的代码要等待所有的countDown的计数器为零再执行<br>         } catch (InterruptedException e) {<!-- --><br>             // TODO Auto-generated catch block<br>             e.printStackTrace();<br>         }</p> 
<p>        System.out.println("all done");    <br>     }<br> 线程类:<br> public class ThreadWithCountDownLatch implements Runnable{<!-- --><br>     long time;<br>     CountDownLatch countDownLatch;<br>     String name;<br>     public ThreadWithCountDownLatch(long time,CountDownLatch countDownLatch,String name){<!-- --><br>         this.time=time;<br>         this.countDownLatch = countDownLatch;<br>         this.name=name;<br>     }<br>     @Override<br>     public void run() {<!-- --><br>         try {<!-- --><br>             System.out.println(name+" start");<br>             work(time);<br>             System.out.println(name+" end");<br>         } catch (InterruptedException e) {<!-- --><br>             // TODO Auto-generated catch block<br>             e.printStackTrace();<br>         }finally{<!-- --><br>             countDownLatch.countDown();<br>         }<br>     }</p> 
<p>    private void work(long time2) throws InterruptedException {<!-- --><br>         Thread.sleep(time2);    <br>     }<br> }</p> 
<h4>2）CyclicBarrier-每个线程中调用await，调用达到次数再一起放行</h4> 
<p>调用栅栏(计数器为5)的await,相当于告诉栅栏已经有一个线程到达栅栏,同时线程本身不再继续执行;当cyclicBarrier的await方法调用5次时,所有线程继续执行,同时触发栅栏的run方法<br> 主类:<br>     public static void main(String[] args) {<!-- --><br>         CyclicBarrier cylicBarrier = new CyclicBarrier(5,new Runnable() {<!-- --><br>             //栅栏动作,在计数器为零的时候执行<br>             @Override<br>             public void run() {//栅栏的await方法执行五次后会调用此处<br>                 // TODO Auto-generated method stub<br>                 System.out.println("all work done");<br>             }<br>         });<br>         ExecutorService pool = Executors.newFixedThreadPool(5);<br>         for(int i=1;i&lt;6;i++){<!-- --><br>             pool.submit(new ThreadWithCyclicBarrier(i,cylicBarrier));<br>         }<br>         pool.shutdown();<br>         System.out.println("last ");    <br>     }<br> 线程类:<br> public class ThreadWithCyclicBarrier  implements Runnable{<!-- --><br>     int id;<br>     CyclicBarrier cyclicBarrier;<br>     <br>     public ThreadWithCyclicBarrier(int id,CyclicBarrier cyclicBarrier){<!-- --><br>         this.id = id;<br>         this.cyclicBarrier=cyclicBarrier;<br>     }<br>     @Override<br>     public void run() {<!-- --><br>         System.out.println("thread"+id+" start");<br>         try {<!-- --><br>             cyclicBarrier.await();//栅栏计数值为零后会继续执行<br>             Thread.sleep(1000L);<br>         } catch (InterruptedException e) {<!-- --><br>             // TODO Auto-generated catch block<br>             e.printStackTrace();<br>         } catch (BrokenBarrierException e) {<!-- --><br>             // TODO Auto-generated catch block<br>             e.printStackTrace();<br>         }<br>         System.out.println("thread"+id+" end");<br>     }<br> }</p> 
<h4>3)join方法实现</h4> 
<p>对a,b使用a.join()和b.join();    然后下面使用c.start()<br> SubTThread subthread = new SubTThread("subthread");<br>         SubTThread subthread2 = new SubTThread("subthread2");<br>         SubTThread subthread3 = new SubTThread("subthread3");<br>         Thread thread = new Thread(subthread);<br>         Thread thread2 = new Thread(subthread2);<br>         Thread thread3 = new Thread(subthread3);<br>         thread.start();<br>         thread2.start();<br>         mainThreadWork();<br>         System.out.println("wait subthread done");<br>         try {<!-- --><br>             thread.join();<br>             thread2.join();//当thread和thread2的run方法执行完毕后才会继续下面的代码<br>         } catch (InterruptedException e) {<!-- --><br>             e.printStackTrace();<br>         }<br>         thread3.start();<br>         System.out.println("all work done");</p> 
<h4>4）线程池submit线程返回Future,并调用future的get方法</h4> 
<p>使用线程池,线程池submit线程返回Future,并调用future的get方法.则get方法下的代码都需要等待调用了get方法的线程完全执行后再执行<br>     public static void main(String[] args) {<!-- --><br>         ExecutorService pool = Executors.newFixedThreadPool(3);<br>         <br>         SubTThreadByRun subthread = new SubTThreadByRun("subthread");<br>         SubTThreadByRun subthread2 = new SubTThreadByRun("subthread2");        <br>         Thread thread = new Thread(subthread);<br>         Thread thread2 = new Thread(subthread2);<br>         ThreadByCall threadByCall = new ThreadByCall("call1");<br>         <br>         Future future1 = pool.submit(thread);<br>         Future future2 = pool.submit(thread2);<br>         Future future3 = pool.submit(threadByCall);<br>         mainThreadWork();<br>         try {<!-- --><br>             future1.get();<br>             future2.get();<br>             String str = (String) future3.get();//下面的代码需要等待thread1/thread2和threadByCall 执行完毕后执行下面的代码<br>             System.out.println("得到结果:"+str);<br>         } catch (InterruptedException e) {<!-- --><br>             e.printStackTrace();<br>         } catch (ExecutionException e) {<!-- --><br>             e.printStackTrace();<br>         }</p> 
<p>SubTThreadByRun subthread3 = new SubTThreadByRun("subthread3");        <br> Thread thread3 = new Thread(subthread3);<br>         thread3.start();<br>         System.out.println("all work done");<br>         pool.shutdown();//关闭线程池<br>     }</p> 
<h4>四种实现方式比较</h4> 
<p>join--适用于少量线程<br> 线程池submit+future.get--适用于实际使用的线程数量不定，且所有线程执行完毕<br> CountDownLatch--设置线程数，每个线程结尾使用countDown()方法减值，主线程中调用await方法来阻塞，当数据减为0时，主线程继续执行，适用于实际使用线程数量固定<br> 栅栏--多个线程都执行到某个点暂停，然后再一起开始，并且增加栅栏的run方法<br> new CyclicBarrier(5,new Runnable()）;每个线程执行到CyclicBarrier.await方法，线程会暂停，当await方法执行5次时，所有线程继续运行，并且执行cyclicBarrier的runner的run方法</p> 
<p></p> 
<h4>countdownLatch在项目中的实际使用</h4> 
<p>背景：现在n个班级缺了个需要展示的属性，需要rpc从外部获取，但是一次只能查50个班级的；所以需要使用多线程提升性能，分页查询，但是需要所有班级属性查询完成后，才能继续执行，这里就可以使用countdownLatch进行控制<br> 线程的个数（即rpc的次数）: (n-1)/50 +1<br> 具体代码如下：<br>     private  Map&lt;String, String&gt; concurrentClassByTeacherProcessor(ClassByTeacherParamDto param, List&lt;ClassByCourseDto&gt; rows) {<!-- --><br>         Stopwatch stopwatch = Stopwatch.createStarted();<br>         //  线程安全 - 同时提效<br>         Map&lt;String, String&gt; concurrentHashMap = new ConcurrentHashMap&lt;&gt;();<br>         if (CollectionUtils.isNotEmpty(rows)) {<!-- --><br>             // 获取classId list<br>             List&lt;String&gt; classIds = rows.stream()<br>                     .map(ClassByCourseDto::getId)<br>                     .collect(Collectors.toList());</p> 
<p>            int times = (classIds.size() - 1) / 50 + 1;<br>             CountDownLatch countDownLatch = new CountDownLatch(times);<br>             ExecutorService executorService = Executors.newFixedThreadPool(times);</p> 
<p>            try {<!-- --><br>                 // 50 一组开启多线程<br>                 for (int i = 0; i &lt; classIds.size(); i += 50) {<!-- --><br>                     List&lt;String&gt; classIdList = classIds.subList(i, Math.min(i + 50, classIds.size()));<br>                     executorService.submit(()-&gt;{<!-- --><br>                         List&lt;ClassBySelfBuiltDto&gt; classBySelfBuiltDtoList = courseClient.queueSelfBuiltClassById(classIdList, null);<br>                         classBySelfBuiltDtoList.forEach(classBySelfBuiltDto -&gt; concurrentHashMap.put(classBySelfBuiltDto.getClassId(), classBySelfBuiltDto.getClassTimeDisplay()));<br>                         countDownLatch.countDown();<br>                     });<br>                 }<br>                 try {<!-- --><br>                     countDownLatch.await();// 这里阻塞主线程，等待子线程执行完成<br>                 } catch (InterruptedException e) {<!-- --><br>                     Thread.currentThread().interrupt();<br>                 }<br>             } finally {<!-- --><br>                 executorService.shutdown();<br>             }<br>         }<br>         log.info("concurrentClassByTeacherProcessor param:[{}], it costs:[{}]", param, stopwatch.elapsed(TimeUnit.MILLISECONDS));<br>         return concurrentHashMap;<br>     }</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/18cd7cb46731c81b7597f7ae58ffbc50/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">路由策略实验分析（一）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1133b2dbfce3d1b1a69b71f474bd7fe1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一文读懂分布式熔断与服务降级</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>