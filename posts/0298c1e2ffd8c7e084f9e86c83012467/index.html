<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Zookeeper 基础知识汇总 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Zookeeper 基础知识汇总" />
<meta property="og:description" content="一、zookeeper 概述 中文教程：https://www.docs4dev.com/docs/zh/zookeeper/r3.5.6/reference/zookeeperOver.html
1.1 概述 ZooKeeper 是⼀种分布式协调服务，⽤于管理⼤型主机。在分布式环境中协调和管理服务是 ⼀个复杂的过程。ZooKeeper 通过其简单的架构和 API 解决了这个问题。ZooKeeper 允许开 发⼈员专注于核⼼应⽤程序逻辑，⽽不必担⼼应⽤程序的分布式特性。
1.2 使用场景 分布式协调组讲 分布式服务下需要对数据状态进行统计管理，比如用户的登录情况。
分布式锁 zk在实现分布式锁上，可以做到强⼀致性，关于分布式锁相关的知识，在之后的ZAB协议中介绍。
无状态实现 二、zookeeper 服务配置与使用 2.1 zookeeper 服务搭建 2.1.1 安装包部署 官方网址：https://zookeeper.apache.org/releases.html
详细安装过程大家可以自行百度
2.1.2 Docker 部署 docker run -d \ -e TZ=&#34;Asia/Shanghai&#34; \ -p 2181:2181 \ -v /Users/rion/Data/DockerVolumesData/zookeeper/zookeeper01/data:/data \ -v /Users/rion/Data/DockerVolumesData/zookeeper/zookeeper01/conf:/conf/ \ -v /Users/rion/Data/DockerVolumesData/zookeeper/zookeeper01/log:/datalog/ \ --name zookeeper01 zookeeper 参数：
-e：表示添加环境变量
-p：设置宿主机和容器内部端口的映射
-v：表示挂载目录
/data : zookeeper 的数据目录
/conf ：zookeeper 的配置文件目录
/datalog ： zookeeper 的日志目录" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0298c1e2ffd8c7e084f9e86c83012467/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-11T22:29:15+08:00" />
<meta property="article:modified_time" content="2023-06-11T22:29:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Zookeeper 基础知识汇总</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="zookeeper__1"></a>一、zookeeper 概述</h2> 
<blockquote> 
 <p>中文教程：https://www.docs4dev.com/docs/zh/zookeeper/r3.5.6/reference/zookeeperOver.html</p> 
</blockquote> 
<h3><a id="11__5"></a>1.1 概述</h3> 
<p>ZooKeeper 是⼀种分布式协调服务，⽤于管理⼤型主机。在分布式环境中协调和管理服务是 ⼀个复杂的过程。ZooKeeper 通过其简单的架构和 API 解决了这个问题。ZooKeeper 允许开 发⼈员专注于核⼼应⽤程序逻辑，⽽不必担⼼应⽤程序的分布式特性。</p> 
<h3><a id="12__9"></a>1.2 使用场景</h3> 
<ul><li><strong>分布式协调组讲</strong></li></ul> 
<p>分布式服务下需要对数据状态进行统计管理，比如用户的登录情况。</p> 
<ul><li><strong>分布式锁</strong></li></ul> 
<p>zk在实现分布式锁上，可以做到强⼀致性，关于分布式锁相关的知识，在之后的ZAB协议中介绍。</p> 
<ul><li><strong>无状态实现</strong></li></ul> 
<p><img src="https://images2.imgbox.com/61/fe/njiWoIv6_o.png" alt="img"></p> 
<h2><a id="zookeeper__25"></a>二、zookeeper 服务配置与使用</h2> 
<h3><a id="21__zookeeper__27"></a>2.1 zookeeper 服务搭建</h3> 
<h4><a id="211__29"></a>2.1.1 安装包部署</h4> 
<p>官方网址：https://zookeeper.apache.org/releases.html</p> 
<p>详细安装过程大家可以自行百度</p> 
<h4><a id="212_Docker__37"></a>2.1.2 Docker 部署</h4> 
<pre><code class="prism language-bash"><span class="token function">docker</span> run -d <span class="token punctuation">\</span>
-e <span class="token assign-left variable">TZ</span><span class="token operator">=</span><span class="token string">"Asia/Shanghai"</span> <span class="token punctuation">\</span>
-p <span class="token number">2181</span>:2181 <span class="token punctuation">\</span>
-v /Users/rion/Data/DockerVolumesData/zookeeper/zookeeper01/data:/data  <span class="token punctuation">\</span>
-v /Users/rion/Data/DockerVolumesData/zookeeper/zookeeper01/conf:/conf/ <span class="token punctuation">\</span>
-v /Users/rion/Data/DockerVolumesData/zookeeper/zookeeper01/log:/datalog/ <span class="token punctuation">\</span>
--name zookeeper01  zookeeper
</code></pre> 
<p>参数：</p> 
<p>-e：表示添加环境变量</p> 
<p>-p：设置宿主机和容器内部端口的映射</p> 
<p>-v：表示挂载目录</p> 
<p>/data : zookeeper 的数据目录</p> 
<p>/conf ：zookeeper 的配置文件目录</p> 
<p>/datalog ： zookeeper 的日志目录</p> 
<h3><a id="22__65"></a>2.2 配置文件</h3> 
<pre><code class="prism language-bash"><span class="token comment"># zookeeper时间配置中的基本单位 (毫秒)</span>
<span class="token assign-left variable">tickTime</span><span class="token operator">=</span><span class="token number">2000</span>
<span class="token comment"># 允许follower初始化连接到leader最⼤时⻓，它表示tickTime时间倍数</span>
即:initLimit*tickTime
<span class="token assign-left variable">initLimit</span><span class="token operator">=</span><span class="token number">10</span>
<span class="token comment"># 允许follower与leader数据同步最⼤时⻓,它表示tickTime时间倍数</span>
<span class="token assign-left variable">syncLimit</span><span class="token operator">=</span><span class="token number">5</span>
<span class="token comment">#zookeper 数据存储⽬录及⽇志保存⽬录（如果没有指明dataLogDir，则⽇志也保存在这个</span>
⽂件中）
<span class="token assign-left variable">dataDir</span><span class="token operator">=</span>/tmp/zookeeper
<span class="token comment">#对客户端提供的端⼝号</span>
<span class="token assign-left variable">clientPort</span><span class="token operator">=</span><span class="token number">2181</span>
<span class="token comment">#单个客户端与zookeeper最⼤并发连接数</span>
<span class="token assign-left variable">maxClientCnxns</span><span class="token operator">=</span><span class="token number">60</span>
<span class="token comment"># 保存的数据快照数量，之外的将会被清除</span>
autopurge.snapRetainCount<span class="token operator">=</span><span class="token number">3</span>
<span class="token comment">#⾃动触发清除任务时间间隔，⼩时为单位。默认为0，表示不⾃动清除。</span>
autopurge.purgeInterval<span class="token operator">=</span><span class="token number">1</span>
<span class="token comment"># zookeeper Web UI</span>
admin.enableServer<span class="token operator">=</span>true
<span class="token comment"># 它表示ZooKeeper运行在单个服务器上，没有复制或分布式的特性。</span>
<span class="token comment"># 当standaloneEnabled设置为true时，ZooKeeper将以Standalone模式启动，这意味着它将在单个服务器上运行，</span>
<span class="token comment"># 并且没有复制或高可用性的功能。这对于测试、开发或单服务器环境可能是合适的。</span>
<span class="token comment"># 当standaloneEnabled设置为false时，ZooKeeper将以分布式模式启动，可以在多个服务器上组成一个ZooKeeper集群。</span>
<span class="token comment"># 在分布式模式下，ZooKeeper可以实现数据的复制和高可用性，以提供更好的容错和可扩展性。</span>
<span class="token assign-left variable">standaloneEnabled</span><span class="token operator">=</span>true
</code></pre> 
<h3><a id="23__96"></a>2.3 服务启动与停止</h3> 
<ol><li>先进入docker 容器中</li></ol> 
<pre><code>docker exec -it &lt;containerd_name&gt; | &lt;containerd_id&gt; bash
</code></pre> 
<ol><li>在bin目录下存放则服务启动的脚本</li></ol> 
<p><img src="https://images2.imgbox.com/ad/8f/o8T3kVx8_o.png" alt="img"></p> 
<p>zkCli.sh ：连接服务端的脚本</p> 
<p>zkServer.sh：服务端服务控制脚本</p> 
<pre><code class="prism language-bash">zkServer.sh start /conf/zoo.cfg   <span class="token comment"># 默认会使用该文件，不存在会提示</span>
zkServer.sh status 								<span class="token comment"># 查看服务器状态</span>
zkServer.sh stop
</code></pre> 
<h2><a id="zookeeper__120"></a>三、zookeeper 数据模型</h2> 
<h3><a id="31_zookeeper__122"></a>3.1 zookeeper 如何保存数据结构</h3> 
<p>zk中的数据是保存在节点上的，节点就是znode，多个znode之间构成⼀颗树的⽬录结构。</p> 
<p>ZooKeeper 提供的名称空间与标准文件系统的名称空间非常相似。名称是由斜杠(/)分隔的一系列路径元素。 ZooKeeper 名称空间中的每个节点都由路径标识。</p> 
<p><img src="https://images2.imgbox.com/5e/96/BDuFD6DC_o.png" alt="img"></p> 
<p>节点路径可以理解为key，同时还可以给key设置value。</p> 
<h3><a id="32_znode__134"></a>3.2 znode 结构</h3> 
<p>zookeeper 中的node包含一下四个部分：</p> 
<ul><li> <p><strong>data</strong>：保存数据</p> </li><li> <p><strong>acl</strong>：权限，定义了什么样的⽤户能够操作这个节点，且能够进⾏怎样的操作。</p> </li><li> 
  <ul><li><strong>c</strong>: <strong>create</strong> 创建权限，允许在该节点下创建⼦节点</li><li><strong>w：write</strong> 更新权限，允许更新该节点的数据</li><li><strong>r：read</strong> 读取权限，允许读取该节点的内容以及⼦节点的列表信息</li><li><strong>d：delete</strong> 删除权限，允许删除该节点的⼦节点</li><li><strong>a：admin</strong> 管理者权限，允许对该节点进⾏acl权限设置 /动物/猫 /汽⻋/宝⻢ 1 2</li></ul> </li><li> <p><strong>stat</strong>：描述当前znode的元数据（节点的信息），<code>get -s &lt;nodeName&gt;</code></p> </li><li> <p><strong>child</strong>：当前节点的⼦节点</p> </li></ul> 
<h3><a id="33_znode__152"></a>3.3 znode 类型</h3> 
<ul><li><strong>持久节点</strong>: 创建出的节点，在会话结束后依然存在。保存数据</li><li><strong>持久序号节点</strong>: 创建出的节点，根据先后顺序，会在节点之后带上⼀个数值，越后执⾏数 值越⼤，适⽤于分布式锁的应⽤场景- 单调递增 , 就类似于数据库中加锁时使用version字段，逐步增加version字段的值。</li><li><strong>临时节点</strong>： 临时节点是在会话结束后，⾃动被删除的，通过这个特性，zk可以实现服务注册与发现的 效果。那么临时节点是如何维持⼼跳呢？</li></ul> 
<p><img src="https://images2.imgbox.com/ed/d1/p3o2kASG_o.png" alt="img"></p> 
<ul><li><strong>临时序号节点</strong>：跟持久序号节点相同，适⽤于临时的分布式锁。</li><li><strong>Container节点（3.5.3版本新增）</strong>：Container容器节点，当容器中没有任何⼦节点，该 容器节点会被zk定期删除（60s）。</li><li><strong>TTL节点</strong>：可以指定节点的到期时间，到期后被zk定时删除。只能通过系统配置 zookeeper.extendedTypesEnabled=true 开启</li></ul> 
<h3><a id="34__166"></a>3.4 数据持久化</h3> 
<p><strong>zk</strong>的数据是运⾏在内存中，zk提供了两种持久化机制：</p> 
<ul><li><strong>事务⽇志</strong></li></ul> 
<p>zk把执⾏的命令以⽇志形式保存在dataLogDir指定的路径中的⽂件中（如果没有指定 dataLogDir，则按dataDir指定的路径）。</p> 
<ul><li>数据快照</li></ul> 
<p>zk会在⼀定的时间间隔内做⼀次内存数据的快照，把该时刻的内存数据保存在快照⽂件中。</p> 
<p>zk通过两种形式的持久化，在恢复时先恢复快照⽂件中的数据到内存中，再⽤⽇志⽂件中的 数据做增量恢复，这样的恢复速度更快。</p> 
<p>你会发现和redis的数据持久化有些类似。</p> 
<h2><a id="zkCli__184"></a>四、zkCli 客户端</h2> 
<h3><a id="41__186"></a>4.1 创建节点</h3> 
<pre><code class="prism language-bash">create /t     <span class="token comment"># 默认为持久化节点</span>
create -s /t  <span class="token comment"># 创建持久化序号节点，即有事务序号, 会在节点末尾添加序号</span>
create -c /t  <span class="token comment"># 容器节点</span>
create -ttl 	<span class="token comment"># 有时限的节点，就像rediskey设置过期时间一样</span>
create -e /t  <span class="token comment"># 临时节点，当前会话存在时，该节点会存在，若会话关闭，则该节点会被删除</span>
            	<span class="token comment"># 常被用于注册中心服务发现等</span>
</code></pre> 
<p>节点元数据信息</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>zk xxx<span class="token punctuation">]</span> get -s /t

	cZxid: 创建节点的事务ID
  mZxid：修改节点的事务ID
  pZxid：添加和删除⼦节点的事务ID
  ctime：节点创建的时间
  mtime: 节点最近修改的时间
  dataVersion: 节点内数据的版本，每更新⼀次数据，版本会+1
  aclVersion: 此节点的权限版本
  ephemeralOwner: 如果当前节点是临时节点，该值是当前节点所有者的session
  id。如果节点不是临时节点，则该值为零。
  dataLength: 节点内数据的⻓度
  numChildren: 该节点的⼦节点个数
</code></pre> 
<h3><a id="42__215"></a>4.2 查询节点</h3> 
<ul><li><strong>ls</strong></li></ul> 
<pre><code class="prism language-bash"><span class="token function">ls</span> /t   			<span class="token comment"># 默认显示当前节点下的一级子节点信息</span>
<span class="token function">ls</span> -w /t      <span class="token comment"># 监听⽬录,创建和删除⼦节点会收到通知。⼦节点中新增节点不会收到通知</span>
<span class="token function">ls</span> -R /t      <span class="token comment"># 递归显示该节点下的所有子节点</span>
<span class="token function">ls</span> -w -R /t   <span class="token comment"># 对于⼦节点中⼦节点的变化，但内容的变化不会收到通知</span>
</code></pre> 
<ul><li><strong>get</strong></li></ul> 
<pre><code class="prism language-bash">get -s 			<span class="token comment"># 查询节点的元信息</span>
get -w 			<span class="token comment"># w (watch) 监听节点的数据变化（一次性的）</span>
</code></pre> 
<p>get -w znode</p> 
<p>一旦数据节点发送变化，会出发一个监听事件，type 表明了数据变化类型，如下：</p> 
<p>WATCHER::</p> 
<p>WatchedEvent state:SyncConnected type:NodeDataChanged path:/t</p> 
<h3><a id="43__241"></a>4.3 设置值</h3> 
<pre><code class="prism language-bash"><span class="token builtin class-name">set</span> <span class="token operator">&lt;</span>znode<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>value<span class="token operator">&gt;</span>
<span class="token comment"># set /t "hello"</span>

<span class="token builtin class-name">set</span> -v <span class="token operator">&lt;</span>dataVersion<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>znode<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>data<span class="token operator">&gt;</span>
<span class="token comment"># set -v 2 /t 1234</span>
<span class="token comment"># 只有当节点的版本号与提供的版本号匹配时，才会进行更新。如果版本号不匹配，操作将失败。</span>

<span class="token builtin class-name">set</span> <span class="token operator">&lt;</span>znode<span class="token operator">&gt;</span> -f <span class="token operator">&lt;</span>filePath<span class="token operator">&gt;</span>
<span class="token comment"># set /myNode -f /path/to/data.txt</span>
</code></pre> 
<p>需要注意的是，在使用<strong>set</strong>命令设置节点值时，节点路径和数据值都需要用引号括起来（除非路径或数据中不包含空格）。还要确保指定的节点路径在ZooKeeper中存在，否则会创建一个新的节点。</p> 
<h3><a id="44__257"></a>4.4 删除节点</h3> 
<pre><code class="prism language-bash">delete <span class="token operator">&lt;</span>znode<span class="token operator">&gt;</span>

delete -v <span class="token operator">&lt;</span>dataVersion<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>znode<span class="token operator">&gt;</span>
<span class="token comment"># 指定节点的版本进行删除，乐观锁。适用于读多写少的情况</span>

deleteall <span class="token operator">&lt;</span>znode<span class="token operator">&gt;</span>
<span class="token comment"># 递归删除节点，即删除该节点下的所有子节点</span>
</code></pre> 
<h3><a id="45__269"></a>4.5 权限</h3> 
<pre><code class="prism language-bash"><span class="token comment"># 设置摘要</span>
<span class="token function">add</span> auth digest root:123456

<span class="token comment"># 设置test节点值为abcd，并且需要进行认证，只有xiaowang:123456才可以进行增删写读的权限</span>
create /test abcd auth:xiaowang:123456:cdwr
</code></pre> 
<h2><a id="zookeeper__281"></a>五、zookeeper 实现分布式锁</h2> 
<h3><a id="51_zookeeper__283"></a>5.1 zookeeper 锁类型</h3> 
<h4><a id="511__285"></a>5.1.1 读锁</h4> 
<p>⼤家都可以读，要想上读锁的<strong>前提</strong>：<strong>之前的锁没有写锁</strong></p> 
<h4><a id="512__289"></a>5.1.2 写锁</h4> 
<p>只有得到写锁的才能写。要想上写锁的<strong>前提是，之前没有任何锁。</strong></p> 
<h3><a id="52_zookeeper__295"></a>5.2 zookeeper 如何上读锁</h3> 
<ol><li> <p>创建⼀个临时序号节点，节点的数据是read，表示是读锁</p> </li><li> <p>获取当前zk中序号⽐⾃⼰⼩的所有节点</p> </li><li> <p>判断最⼩节点是否是读锁：</p> </li><li> 
  <ol><li>如果不是读锁的话，则上锁失败，为最⼩节点设置监听。阻塞等待，zk的watch机制 会当最⼩节点发⽣变化时通知当前节点，于是再执⾏第⼆步的流程</li><li>如果是读锁的话，则上锁成功</li></ol> </li></ol> 
<p><img src="https://images2.imgbox.com/e3/1b/ooJkbaqb_o.png" alt="img"></p> 
<h3><a id="53_zookeeper__308"></a>5.3 zookeeper 如何上写锁</h3> 
<ol><li> <p>创建⼀个临时序号节点，节点的数据是write，表示是 写锁</p> </li><li> <p>获取zk中所有的⼦节点</p> </li><li> <p>判断⾃⼰是否是最⼩的节点：</p> </li><li> 
  <ol><li>如果是，则上写锁成功</li><li>如果不是，说明前⾯还有锁，则上锁失败，监听最⼩的节点，如果最⼩节点有变化， 则回到第⼆步。</li></ol> </li></ol> 
<p><img src="https://images2.imgbox.com/a0/6d/y8i9YT2h_o.png" alt="img"></p> 
<h3><a id="54_zookeeper__321"></a>5.4 zookeeper 羊群效应</h3> 
<p>如果⽤上述的上锁⽅式，只要有节点发⽣变化，就会触发其他节点的监听事件，这样的话对 zk的压⼒⾮常⼤，——⽺群效应。可以调整成链式监听。解决这个问题。</p> 
<p><img src="https://images2.imgbox.com/35/26/s3Da60mC_o.png" alt="img"></p> 
<h2><a id="zookeeper__329"></a>六、zookeeper 集群实战</h2> 
<h3><a id="61_zookeeper__331"></a>6.1 zookeeper 集群角色</h3> 
<p>zookeeper 集群有三种角色：</p> 
<ul><li><strong>Leader</strong>：处理集群的所有事务请求，集群中只有⼀个Leader。</li><li><strong>Follower</strong>：只能处理读请求，参与Leader选举。</li><li><strong>Observer</strong>：只能处理读请求，提升集群读的性能，但不能参与Leader选举。</li></ul> 
<h3><a id="62__341"></a>6.2 集群搭建</h3> 
<p>本次搭建以视频内容为模版，使用docker 部署应该也是类似的</p> 
<p>搭建4个节点，其中⼀个节点为Observer</p> 
<p><strong>（1）创建4个节点的myid，并设值</strong></p> 
<p>在/usr/local/zookeeper中创建以下四个⽂件</p> 
<pre><code class="prism language-bash">/usr/local/zookeeper/zkdata/zk1<span class="token comment"># echo 1 &gt; myid</span>
/usr/local/zookeeper/zkdata/zk2<span class="token comment"># echo 2 &gt; myid</span>
/usr/local/zookeeper/zkdata/zk3<span class="token comment"># echo 3 &gt; myid</span>
/usr/local/zookeeper/zkdata/zk4<span class="token comment"># echo 4 &gt; myid</span>
</code></pre> 
<p><strong>（2）编写4个zoo.cfg</strong></p> 
<pre><code class="prism language-bash"><span class="token comment"># The number of milliseconds of each tick</span>
<span class="token assign-left variable">tickTime</span><span class="token operator">=</span><span class="token number">2000</span>
<span class="token comment"># The number of ticks that the initial</span>
<span class="token comment"># synchronization phase can take</span>
<span class="token assign-left variable">initLimit</span><span class="token operator">=</span><span class="token number">10</span>
<span class="token comment"># The number of ticks that can pass between</span>
<span class="token comment"># sending a request and getting an acknowledgement</span>
<span class="token assign-left variable">syncLimit</span><span class="token operator">=</span><span class="token number">5</span>
<span class="token comment"># 修改对应的zk1 zk2 zk3 zk4</span>
<span class="token assign-left variable">dataDir</span><span class="token operator">=</span>/usr/local/zookeeper/zkdata/zk1
<span class="token comment"># 修改对应的端⼝ 2181 2182 2183 2184</span>
<span class="token assign-left variable">clientPort</span><span class="token operator">=</span><span class="token number">2181</span>
<span class="token comment"># 2001为集群通信端⼝，3001为集群选举端⼝，observer表示不参与集群选举</span>
server.1<span class="token operator">=</span><span class="token number">172.16</span>.253.54:2001:3001
server.2<span class="token operator">=</span><span class="token number">172.16</span>.253.54:2002:3002
server.3<span class="token operator">=</span><span class="token number">172.16</span>.253.54:2003:3003
server.4<span class="token operator">=</span><span class="token number">172.16</span>.253.54:2004:3004:observer
</code></pre> 
<p><strong>（3）启动4台Zookeeper</strong></p> 
<pre><code class="prism language-bash">./bin/zkServer.sh status ./conf/zoo1.cfg
./bin/zkServer.sh status ./conf/zoo2.cfg
./bin/zkServer.sh status ./conf/zoo3.cfg
./bin/zkServer.sh status ./conf/zoo4.cfg
</code></pre> 
<p><strong>（4）zkCli 连接集群</strong></p> 
<pre><code class="prism language-bash">./bin/zkCli.sh -server <span class="token number">172.16</span>.253.54:2181,172.16.253.54:2182,172.16.253.54:2183
</code></pre> 
<h2><a id="ZAB__397"></a>七、ZAB 协议</h2> 
<h3><a id="71_ZAB_399"></a>7.1 什么是ZAB协议</h3> 
<p>zookeeper作为⾮常重要的分布式协调组件，需要进⾏集群部署，集群中会以⼀主多从的形式 进⾏部署。zookeeper为了保证数据的⼀致性，使⽤了ZAB（Zookeeper Atomic Broadcast）协议，这个协议解决了Zookeeper的崩溃恢复和主从数据同步的问题。</p> 
<p><img src="https://images2.imgbox.com/0c/f1/atp6S3Hc_o.png" alt="img"></p> 
<h3><a id="72_zookeeper__407"></a>7.2 zookeeper 定义四种节点状态</h3> 
<ul><li><strong>Looking</strong> ：选举状态。</li><li><strong>Following</strong> ：Follower 节点（从节点）所处的状态。</li><li><strong>Leading</strong> ：Leader 节点（主节点）所处状态。</li><li><strong>Observing</strong>：观察者节点所处的状态</li></ul> 
<h3><a id="73_leader_416"></a>7.3 集群上线的leader选举</h3> 
<p>Zookeeper集群中的节点在上线时，将会进⼊到<strong>Looking</strong>状态，也就是选举<strong>Leader</strong>的状态，这 个状态具体会发⽣什么？</p> 
<p><img src="https://images2.imgbox.com/34/49/1tBSkdbZ_o.png" alt="img"></p> 
<ul><li><strong>第一轮</strong></li></ul> 
<ol><li> <p><code>节点1</code>服务启动，生成一个一张自己的选票（1, 0）<code>1表示节点myid，0 表示事务id</code>，因为刚启动服务，所以事务id为0</p> </li><li> <p><code>节点2</code>服务启动，生成一个一张自己的选票（2, 0）<code>1表示节点myid，0 表示事务id</code>，因为刚启动服务，所以事务id为0</p> </li><li> <p><code>节点1</code> 和 <code>节点2</code> 都将自己的选票投给对方，即<code>节点1</code>存在2张选票，<code>节点2</code>存在2张选票</p> </li><li> <p><code>节点1</code> 和 <code>节点2</code> 选出最大的选票，<strong>选择方式：先比较zxid，再比较myid</strong>。 故节点1和节点2都选择了选票（2, 0）投入到投票箱中。</p> </li><li> <p>第一轮选票结束，此时选票箱中存在1张选票，由于当前存在三个节点，配置文件中（6.2小节）定义了<code>server.1=ip:port1:port2, server.2=xxx, server.3=xxx</code>，<code>server.4=xxx</code> 是observer节点，不参与选票。</p> </li><li> <p>在选举leader过程中，需要投票箱中的票数超过集群的半数才可以。所以会进行第二轮选举</p> </li></ol> 
<ul><li><strong>第二轮</strong></li></ul> 
<ol><li>此时<code>节点1</code>中含有 1 张选票(2, 0)，因为会保留它选择投到投票箱中的票。它会将最大的选票投递给对方，<code>节点2</code>也是如此。所以都会把选票(2, 0) 投给对方</li><li><code>节点1</code> 和 <code>节点2</code>此时再次进行对比，然后把选票(2, 0) 投递到投票箱中</li><li>此时投票箱中存在2张选票，大于集群数量的一半。故而<code>节点2</code>成为<code>leader</code>，<code>节点1</code>成为<code>follower</code></li></ol> 
<pre><code>节点3` 启动时发现已经存在`leader`，便会直接成为`follower
</code></pre> 
<p>以上就是leader选举的全过程</p> 
<h3><a id="74_leader_450"></a>7.4 崩溃恢复时的leader选举</h3> 
<p>Leader建⽴完后，Leader周期性地不断向Follower发送⼼跳（ping命令，没有内容的 socket）。</p> 
<p>当Leader崩溃后，Follower发现socket通道已关闭，于是Follower开始进⼊到 Looking状态，重新回到7.3节中的Leader选举过程，此时集群不能对外提供服务。</p> 
<h3><a id="75__458"></a>7.5 主从服务器之间的数据同步</h3> 
<p>主要包含两阶段提交</p> 
<ul><li>第一阶段为节点将数据写入到本地数据文件中</li><li>第二阶段为节点将数据写入到内存中</li></ul> 
<p><img src="https://images2.imgbox.com/d5/e5/Q5yeFKTX_o.png" alt="img"></p> 
<h3><a id="76_zookeeper_NIOBIO_469"></a>7.6 zookeeper 的NIO和BIO</h3> 
<p><strong>NIO</strong></p> 
<p>NIO （non-blocking IO）同步非阻塞IO</p> 
<ul><li>⽤于被客户端连接的2181端⼝，使⽤的是NIO模式与客户端建⽴连接</li><li>客户端开启Watch时，也使⽤NIO，等待Zookeeper服务器的回调</li></ul> 
<p><strong>BIO</strong></p> 
<p>BIO（blocking IO）</p> 
<ul><li>集群在选举时，多个节点之间的投票通信端⼝，使⽤BIO进⾏通信。</li></ul> 
<p>详细解释nio&amp;bio：https://blog.csdn.net/CSDN2497242041/article/details/120278946</p> 
<h2><a id="CAP_490"></a>八、CAP理论</h2> 
<h3><a id="81_CAP__492"></a>8.1 CAP 定理</h3> 
<p>2000 年 7 ⽉，加州⼤学伯克利分校的 Eric Brewer 教授在 ACM PODC 会议上提出 CAP 猜 想。2年后，麻省理⼯学院的 Seth Gilbert 和 Nancy Lynch 从理论上证明了 CAP。之后， CAP 理论正式成为分布式计算领域的公认定理。</p> 
<p><strong>CAP 理论为：</strong></p> 
<p>⼀个分布式系统最多只能同时满⾜⼀致性（Consistency）、可⽤性 （Availability）和分区容错性（Partition tolerance）这三项中的两项。</p> 
<p><strong>⼀致性</strong>（Consistency） ⼀致性指 “all nodes see the same data at the same time”，即更新操作成功并返回客户端 完成后，所有节点在同⼀时间的数据完全⼀致。</p> 
<p><strong>可⽤性</strong>（Availability）可⽤性指“Reads and writes always succeed”，即服务⼀直可⽤，⽽且是正常响应时间。</p> 
<p><strong>分区容错性</strong>（Partition tolerance） 分区容错性指“the system continues to operate despite arbitrary message loss or failure of part of the system”，即分布式系统在遇到某节点或⽹络分区故障的时候，仍然能够对外 提供满⾜⼀致性或可⽤性的服务。——避免单点故障，就要进⾏冗余部署，冗余部署相当于 是服务的分区，这样的分区就具备了容错性。</p> 
<h3><a id="82_CAP__508"></a>8.2 CAP 权衡</h3> 
<p>通过 CAP 理论，我们知道⽆法同时满⾜⼀致性、可⽤性和分区容错性这三个特性，那要舍弃哪个呢？</p> 
<p>对于多数⼤型互联⽹应⽤的场景，主机众多、部署分散，⽽且现在的集群规模越来越⼤，所 以节点故障、⽹络故障是常态，⽽且要保证服务可⽤性达到 N 个 9，即保证 P 和 A，舍弃 C（退⽽求其次保证最终⼀致性）。虽然某些地⽅会影响客户体验，但没达到造成⽤户流程的 严重程度。 对于涉及到钱财这样不能有⼀丝让步的场景，C 必须保证。⽹络发⽣故障宁可停⽌服务，这是 保证 CA，舍弃 P。貌似这⼏年国内银⾏业发⽣了不下 10 起事故，但影响⾯不⼤，报到也不 多，⼴⼤群众知道的少。还有⼀种是保证 CP，舍弃 A。例如⽹络故障是只读不写。</p> 
<p>孰优孰略，没有定论，只能根据场景定夺，适合的才是最好的。</p> 
<p><img src="https://images2.imgbox.com/22/5f/jbMnc47J_o.png" alt="img"></p> 
<h3><a id="83_BASE__518"></a>8.3 BASE 理论</h3> 
<p>eBay 的架构师 Dan Pritchett 源于对⼤规模分布式系统的实践总结，在 ACM 上发表⽂章提出 BASE 理论，BASE 理论是对 CAP 理论的延伸，核⼼思想是即使⽆法做到强⼀致性（Strong Consistency，CAP 的⼀致性就是强⼀致性），但应⽤可以采⽤适合的⽅式达到最终⼀致性 （Eventual Consitency）。</p> 
<ul><li><strong>基本可⽤（Basically Available）</strong></li></ul> 
<p>基本可⽤是指分布式系统在出现故障的时候，允许损失部分可⽤性，即保证核⼼可⽤。 电商⼤促时，为了应对访问量激增，部分⽤户可能会被引导到降级⻚⾯，服务层也可能只提 供降级服务。这就是损失部分可⽤性的体现。</p> 
<ul><li><strong>软状态（Soft State）</strong></li></ul> 
<p>软状态是指允许系统存在中间状态，⽽该中间状态不会影响系统整体可⽤性。分布式存储中 ⼀般⼀份数据⾄少会有三个副本，允许不同节点间副本同步的延时就是软状态的体现。mysql replication 的异步复制也是⼀种体现。</p> 
<ul><li><strong>最终⼀致性（Eventual Consistency）</strong></li></ul> 
<p>最终⼀致性是指系统中的所有数据副本经过⼀定时间后，最终能够达到⼀致的状态。弱⼀致 性和强⼀致性相反，最终⼀致性是弱⼀致性的⼀种特殊情况。</p> 
<h3><a id="84_Zookeeper_534"></a>8.4 Zookeeper追求的⼀致性</h3> 
<p>Zookeeper在数据同步时，追求的并不是强⼀致性，⽽是顺序⼀致性（事务id的单调递增）。</p> 
<p>本文中内容依照千锋的视频课程：https://www.bilibili.com/video/BV1Ph411n7Ep/?spm_id_from=333.999.top_right_bar_window_custom_collection.content.click&amp;vd_source=08c2f1f4d2e43d15d6addcceb732feff</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6ff73aaea282eec1360da52c0544dd65/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2023最新IEDA全网安装、使用、配置保姆级教学</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f41d1b6e1bc99fda6b13680d9a4a0b8a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Redis 的安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>