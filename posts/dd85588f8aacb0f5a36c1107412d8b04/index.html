<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java 并发 -- lock vs synchronized、volatile（保证可见性和有序性）、悲观锁 vs 乐观锁 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java 并发 -- lock vs synchronized、volatile（保证可见性和有序性）、悲观锁 vs 乐观锁" />
<meta property="og:description" content="1. lock vs synchronized 关于锁的概念不明白的可以参考这篇文章
要求
掌握 lock 与 synchronized 的区别理解 ReentrantLock 的公平、非公平锁理解 ReentrantLock 中的条件变量 三个层面
不同点
语法层面 synchronized 是关键字，源码在 jvm 中，用 c&#43;&#43; 语言实现Lock 是接口，源码由 jdk 提供，用 java 语言实现使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁 功能层面 二者均属于悲观锁、都具备下面3个基本的功能 互斥（多个线程争夺同一个锁，但是只有一个线程可以成功。其余的线程则陷入等待）同步（多个线程可以同时运行，但是如果其中的某个线程需要其他线程的结果，则该线程会一直等待其他线程返回结果才继续运行）锁重入（已经获得锁的线程，可以重复的去被锁住的资源加上多次锁） Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态（可以获取哪些线程被阻塞了）、公平锁、可打断、可超时、多条件变量Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock 性能层面 在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖在竞争激烈时，Lock 的实现通常会提供更好的性能 公平锁
公平锁的公平体现 已经处在阻塞队列中的线程（不考虑超时）始终都是公平的，先进先出公平锁是指未处于阻塞队列中的线程来争抢锁，如果队列不为空，则老实到队尾等待非公平锁是指未处于阻塞队列中的线程来争抢锁，与队列头唤醒的线程去竞争，谁抢到算谁的 公平锁会降低吞吐量，一般不用 条件变量
ReentrantLock 中的条件变量功能类似于普通 synchronized 的 wait，notify，用在当线程获得锁后，发现条件不满足时，临时等待的链表结构与 synchronized 的等待集合不同之处在于，ReentrantLock 中的条件变量可以有多个，可以实现更精细的等待、唤醒控制。 2. volatile 要求
掌握线程安全要考虑的三个问题掌握 volatile 能解决哪些问题 2.1 掌握线程安全要考虑的三个问题（原子性、可见性、有序性） 原子性" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/dd85588f8aacb0f5a36c1107412d8b04/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-21T16:44:54+08:00" />
<meta property="article:modified_time" content="2022-08-21T16:44:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java 并发 -- lock vs synchronized、volatile（保证可见性和有序性）、悲观锁 vs 乐观锁</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_lock_vs_synchronized_0"></a>1. lock vs synchronized</h2> 
<p><a href="https://blog.csdn.net/I_r_o_n_M_a_n/article/details/124118803">关于锁的概念不明白的可以参考这篇文章</a></p> 
<p><strong>要求</strong></p> 
<ul><li>掌握 lock 与 synchronized 的区别</li><li>理解 ReentrantLock 的公平、非公平锁</li><li>理解 ReentrantLock 中的条件变量</li></ul> 
<p><strong>三个层面</strong></p> 
<p>不同点</p> 
<ul><li>语法层面 
  <ul><li>synchronized 是关键字，源码在 jvm 中，用 c++ 语言实现</li><li>Lock 是接口，源码由 jdk 提供，用 java 语言实现</li><li>使用 synchronized 时，退出同步代码块锁会自动释放，而使用 Lock 时，需要手动调用 unlock 方法释放锁</li></ul> </li><li>功能层面 
  <ul><li>二者均属于悲观锁、都具备下面3个基本的功能 
    <ul><li><strong>互斥</strong>（多个线程争夺同一个锁，但是只有一个线程可以成功。其余的线程则陷入等待）</li><li><strong>同步</strong>（多个线程可以同时运行，但是如果其中的某个线程需要其他线程的结果，则该线程会一直等待其他线程返回结果才继续运行）</li><li><strong>锁重入</strong>（已经获得锁的线程，可以重复的去被锁住的资源加上多次锁）</li></ul> </li><li>Lock 提供了许多 synchronized 不具备的功能，例如获取等待状态（可以获取哪些线程被阻塞了）、公平锁、可打断、可超时、多条件变量</li><li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock</li></ul> </li><li>性能层面 
  <ul><li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li><li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li></ul> </li></ul> 
<p><strong>公平锁</strong></p> 
<ul><li>公平锁的公平体现 
  <ul><li><strong>已经处在阻塞队列</strong>中的线程（不考虑超时）始终都是公平的，先进先出</li><li>公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，如果队列不为空，则老实到队尾等待</li><li>非公平锁是指<strong>未处于阻塞队列</strong>中的线程来争抢锁，与队列头唤醒的线程去竞争，谁抢到算谁的</li></ul> </li><li>公平锁会降低吞吐量，一般不用</li></ul> 
<p><strong>条件变量</strong></p> 
<ul><li>ReentrantLock 中的条件变量功能类似于普通 synchronized 的 wait，notify，用在当线程获得锁后，发现条件不满足时，临时等待的链表结构</li><li>与 synchronized 的等待集合不同之处在于，ReentrantLock 中的条件变量可以有多个，可以实现更精细的等待、唤醒控制。</li></ul> 
<hr> 
<h2><a id="2_volatile_42"></a>2. volatile</h2> 
<p><strong>要求</strong></p> 
<ul><li>掌握线程安全要考虑的三个问题</li><li>掌握 volatile 能解决哪些问题</li></ul> 
<hr> 
<h3><a id="21__49"></a>2.1 掌握线程安全要考虑的三个问题（原子性、可见性、有序性）</h3> 
<p><strong>原子性</strong></p> 
<ul><li>起因：多线程下，不同线程的<strong>指令发生了交错</strong>导致的共享变量的读写混乱</li><li>解决：用悲观锁或乐观锁解决，volatile 并不能解决原子性</li></ul> 
<p><strong>可见性</strong></p> 
<ul><li>起因：由于<strong>编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致的对共享变量所做的修改另外的线程看不到</li><li>解决：用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</li></ul> 
<p><strong>有序性</strong></p> 
<ul><li>起因：由于<strong>JIT编译器优化、或缓存优化、或 CPU 指令重排序优化</strong>导致指令的实际执行顺序与编写顺序不一致</li><li>解决：用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</li><li>注意： 
  <ul><li><strong>volatile 变量写</strong>加的屏障是阻止上方其它写操作越过屏障排到 <strong>volatile 变量写</strong>之下</li><li><strong>volatile 变量读</strong>加的屏障是阻止下方其它读操作越过屏障排到 <strong>volatile 变量读</strong>之上</li><li>volatile 读写加入的屏障只能防止同一线程内的指令重排</li></ul> </li></ul> 
<hr> 
<h3><a id="22_volatile_71"></a>2.2 volatile解决可见性、有序性</h3> 
<p>volatile可以保证共享变量的可见性和有序性。</p> 
<blockquote> 
 <p>保证可见性：</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/c8/7b/rNTPf1T1_o.png" alt="在这里插入图片描述"></p> 
<ul><li><mark><strong>写屏障</strong>（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</mark></li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actor2</span><span class="token punctuation">(</span><span class="token class-name">I_Result</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
 ready <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// ready 是 volatile 赋值带写屏障</span>
 <span class="token comment">// 写屏障</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><mark><strong>读屏障</strong>（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</mark></li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actor1</span><span class="token punctuation">(</span><span class="token class-name">I_Result</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 <span class="token comment">// 读屏障</span>
 <span class="token comment">// ready 是 volatile 读取值带读屏障</span>
 <span class="token keyword">if</span><span class="token punctuation">(</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 r<span class="token punctuation">.</span>r1 <span class="token operator">=</span> num <span class="token operator">+</span> num<span class="token punctuation">;</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
 r<span class="token punctuation">.</span>r1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<hr> 
<blockquote> 
 <p>保证有序性：</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/e4/29/P1uTc7HT_o.png" alt="在这里插入图片描述"></p> 
<ul><li><mark>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</mark></li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actor2</span><span class="token punctuation">(</span><span class="token class-name">I_Result</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 num <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
 ready <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// ready 是 volatile 赋值带写屏障</span>
 <span class="token comment">// 写屏障</span>
<span class="token punctuation">}</span>
</code></pre> 
<ul><li><mark>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</mark></li></ul> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">actor1</span><span class="token punctuation">(</span><span class="token class-name">I_Result</span> r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 <span class="token comment">// 读屏障</span>
 <span class="token comment">// ready 是 volatile 读取值带读屏障</span>
 <span class="token keyword">if</span><span class="token punctuation">(</span>ready<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 r<span class="token punctuation">.</span>r1 <span class="token operator">=</span> num <span class="token operator">+</span> num<span class="token punctuation">;</span>
 <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
 r<span class="token punctuation">.</span>r1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<blockquote> 
 <p>volatile 不能解决指令交错（不能保证原子性）：</p> 
</blockquote> 
<ul><li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去</li><li>而有序性的保证也只是保证了本线程内相关代码不被重排序</li></ul> 
<hr> 
<h3><a id="23_volatile_138"></a>2.3 volatile解决可见性示例</h3> 
<p><img src="https://images2.imgbox.com/f9/97/N78gsdAQ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d5/23/yk5vd91K_o.png" alt="在这里插入图片描述"></p> 
<p>对此，网上的解释是这样的：<br> <img src="https://images2.imgbox.com/79/b2/Mao0R0mc_o.png" alt="在这里插入图片描述"></p> 
<p>按照这个说法，另外的线程去读共享变量读的应该只是副本（即false）<br> <img src="https://images2.imgbox.com/a8/99/V4vCRrlV_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/53/f2/aYPutoRE_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>真正原因：JIT即时编译器</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/da/d2/lCNCzI6f_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/7e/15/JlB0vyY6_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b4/a0/XCG5I8v4_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/dd/38/UFjBGiBZ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/22/97/CihUwykt_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h2><a id="3__vs__162"></a>3. 悲观锁 vs 乐观锁</h2> 
<p><strong>要求</strong></p> 
<ul><li>掌握悲观锁和乐观锁的区别</li></ul> 
<p><strong>对比悲观锁与乐观锁</strong></p> 
<ul><li> <p>悲观锁的代表是 synchronized 和 Lock 锁</p> 
  <ul><li>其核心思想是【线程只有占有了锁，才能去操作共享变量，每次只有一个线程占锁成功，获取锁失败的线程，都得停下来等待】</li><li>线程从运行到阻塞、再从阻塞到唤醒，涉及线程上下文切换，如果频繁发生，影响性能</li><li>实际上，线程在获取 synchronized 和 Lock 锁时，如果锁已被占用，都会做几次重试操作，减少阻塞的机会</li></ul> </li><li> <p>乐观锁的代表是 AtomicInteger，使用 cas 来保证原子性</p> 
  <ul><li>其核心思想是【无需加锁，每次只有一个线程能成功修改共享变量，其它失败的线程不需要停止，不断重试直至成功】</li><li>由于线程一直运行，不需要阻塞，因此不涉及线程上下文切换</li><li>它需要多核 cpu 支持，且线程数不应超过 cpu 核数</li></ul> </li></ul> 
<h3><a id="31__179"></a>3.1 乐观锁图示</h3> 
<p><img src="https://images2.imgbox.com/78/44/NZ8iwiSc_o.png" alt="在这里插入图片描述"></p> 
<p><strong>乐观锁是一种乐观思想</strong>，假定当前环境是读多写少，遇到并发写的概率比较低，读数据时认为别的线程不会正在进行修改（所以没有上锁）。写数据时，判断当前与期望值是否相同，如果相同则进行更新（更新期间加锁，保证是原子性的）。</p> 
<p><strong>Java中的乐观锁</strong>：<a href="https://blog.csdn.net/I_r_o_n_M_a_n/article/details/120167189">CAS（Compare And Set）</a>，比较并替换，比较当前值（主内存中的值），与预期值（当前线程中的值，主内存中值的一份拷贝）是否一样，一样则更新，否则继续进行CAS操作。</p> 
<p><strong>如上图所示，乐观锁可以同时进行读操作，读的时候其他线程不能进行写操作</strong>。</p> 
<hr> 
<h3><a id="32__191"></a>3.2 悲观锁图示</h3> 
<p><img src="https://images2.imgbox.com/a8/50/TjTtgjaZ_o.png" alt="在这里插入图片描述"></p> 
<p><strong>悲观锁是一种悲观思想</strong>，即认为写多读少，遇到并发写的可能性高，每次去拿数据的 时候都认为其他线程会修改，所以每次读写数据都会认为其他线程会修改，所以每次读写数据时都会上锁。其他线程想要读写这个数据时，会被这个线程block，直到这个线程释放锁然后其他线程获取到锁。</p> 
<p><strong>Java中的悲观锁</strong>：<code>synchronized</code>修饰的方法和方法块、<code>ReentrantLock</code>锁。</p> 
<p><strong>如上图所示，只能有一个线程进行读操作或者写操作，其他线程的读写操作均不能进行（被阻塞）。</strong></p> 
<hr> 
<hr>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fae5fd5bc16fb415d5b38916569e4a51/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">图像处理之图像傅里叶变换</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7bd1309bf0f26f6195a83896c9695f9a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">教资（1）---＞信息技术概述</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>