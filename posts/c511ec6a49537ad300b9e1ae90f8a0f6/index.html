<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>实现element-ui对话框可拖拽功能 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="实现element-ui对话框可拖拽功能" />
<meta property="og:description" content="element-ui对话框可拖拽及边界处理 应业务需求，需要实现对话框可拖拽问题，应element-ui没有提供官方支持，于是便参考大神的文章，得出了适合业务需要的解决方案。很多大神给出的代码是没有解决边界问题的，但是不解决边界问题存在一个bug，拖到不可视区域后边再也拖不回来了，不信你们可以试试。
在实现的功能的情况下，封装成了js文件，然后再main.js中引入后可全局使用。先看下vue-draggable-resizable 可拖拽缩放的组件
还是上代码吧
功能实现代码directives.js代码如下：
import Vue from &#39;vue&#39;; // v-dialogDrag: 弹窗拖拽属性 Vue.directive(&#39;dialogDrag&#39;, { bind(el, binding, vnode, oldVnode) { const dialogHeaderEl = el.querySelector(&#39;.el-dialog__header&#39;); const dragDom = el.querySelector(&#39;.el-dialog&#39;); //dialogHeaderEl.style.cursor = &#39;move&#39;; dialogHeaderEl.style.cssText &#43;= &#39;;cursor:move;&#39; dragDom.style.cssText &#43;= &#39;;top:0px;&#39; // 获取原有属性 ie dom元素.currentStyle 火狐谷歌 window.getComputedStyle(dom元素, null); const sty = (function() { if (window.document.currentStyle) { return (dom, attr) =&amp;gt; dom.currentStyle[attr]; } else{ return (dom, attr) =&amp;gt; getComputedStyle(dom, false)[attr]; } })() dialogHeaderEl.onmousedown = (e) =&amp;gt; { // 鼠标按下，计算当前元素距离可视区的距离 const disX = e." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c511ec6a49537ad300b9e1ae90f8a0f6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-12-19T21:45:21+08:00" />
<meta property="article:modified_time" content="2018-12-19T21:45:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">实现element-ui对话框可拖拽功能</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3>element-ui对话框可拖拽及边界处理</h3> 
<p>应业务需求，需要实现对话框可拖拽问题，应element-ui没有提供官方支持，于是便参考大神的文章，得出了适合业务需要的解决方案。很多大神给出的代码是没有解决边界问题的，但是不解决边界问题存在一个bug，拖到不可视区域后边再也拖不回来了，不信你们可以试试。<br>在实现的功能的情况下，封装成了js文件，然后再main.js中引入后可全局使用。先看下<a href="http://www.jqhtml.com/22660.html" rel="nofollow noopener noreferrer" target="_blank">vue-draggable-resizable 可拖拽缩放的组件</a><br>还是上代码吧</p> 
<hr> 
<p>功能实现代码directives.js代码如下：</p> 
<pre><code>
import Vue from 'vue';
 
// v-dialogDrag: 弹窗拖拽属性
Vue.directive('dialogDrag', {
    bind(el, binding, vnode, oldVnode) {
        const dialogHeaderEl = el.querySelector('.el-dialog__header');
        const dragDom = el.querySelector('.el-dialog');
        //dialogHeaderEl.style.cursor = 'move';
        dialogHeaderEl.style.cssText += ';cursor:move;'
        dragDom.style.cssText += ';top:0px;'
 
        // 获取原有属性 ie dom元素.currentStyle 火狐谷歌 window.getComputedStyle(dom元素, null);
        const sty = (function() {
                if (window.document.currentStyle) {
                        return (dom, attr) =&amp;gt; dom.currentStyle[attr];
                } else{
                        return (dom, attr) =&amp;gt; getComputedStyle(dom, false)[attr];
                }
        })()       
        
        dialogHeaderEl.onmousedown = (e) =&amp;gt; {
            // 鼠标按下，计算当前元素距离可视区的距离
            const disX = e.clientX - dialogHeaderEl.offsetLeft;
            const disY = e.clientY - dialogHeaderEl.offsetTop;
            
            const screenWidth = document.body.clientWidth; // body当前宽度
                const screenHeight = document.documentElement.clientHeight; // 可见区域高度(应为body高度，可某些环境下无法获取) 
                
                const dragDomWidth = dragDom.offsetWidth; // 对话框宽度
                const dragDomheight = dragDom.offsetHeight; // 对话框高度
                
                const minDragDomLeft = dragDom.offsetLeft;
                const maxDragDomLeft = screenWidth - dragDom.offsetLeft - dragDomWidth;
                
                const minDragDomTop = dragDom.offsetTop;
                const maxDragDomTop = screenHeight - dragDom.offsetTop - dragDomheight;
 
            
            // 获取到的值带px 正则匹配替换
            let styL = sty(dragDom, 'left');
            let styT = sty(dragDom, 'top');
 
            // 注意在ie中 第一次获取到的值为组件自带50% 移动之后赋值为px
            if(styL.includes('%')) {
                styL = +document.body.clientWidth * (+styL.replace(/\%/g, '') / 100);
                styT = +document.body.clientHeight * (+styT.replace(/\%/g, '') / 100);
            }else {
                styL = +styL.replace(/\px/g, '');
                styT = +styT.replace(/\px/g, '');
            };
            
            document.onmousemove = function (e) {
                // 通过事件委托，计算移动的距离 
                                let left = e.clientX - disX;
                                let top = e.clientY - disY;
                                
                                // 边界处理
                                if (-(left) &amp;gt; minDragDomLeft) {
                                        left = -(minDragDomLeft);
                                } else if (left &amp;gt; maxDragDomLeft) {
                                        left = maxDragDomLeft;
                                }
                                
                                if (-(top) &amp;gt; minDragDomTop) {
                                        top = -(minDragDomTop);
                                } else if (top &amp;gt; maxDragDomTop) {
                                        top = maxDragDomTop;
                                }
 
                // 移动当前元素  
                                dragDom.style.cssText += `;left:${left + styL}px;top:${top + styT}px;`;
            };
 
            document.onmouseup = function (e) {
                document.onmousemove = null;
                document.onmouseup = null;
            };
        }  
    }
})
</code></pre> 
<p>在边界处理上，因为在我的项目中无法获取到body的高度（被这个折磨了好久），所以采取了获取可见区域高度，这里补充点知识</p> 
<pre><code>
document.body.clientWidth  //BODY对象宽度
document.body.clientHeight //BODY对象高度
document.documentElement.clientWidth  //可见区域宽度
document.documentElement.clientHeight //可见区域高度
</code></pre> 
<p>在main.js中引入</p> 
<pre><code>
// 引入Dialog可拖拽，注意文件所在目录。目前尚未发现引入的先后关系，若有再补充
import './directives.js';
</code></pre> 
<p>ue文件中使用：<br>在el-dialog标签中加入v-dialogDrag属性</p> 
<pre><code>
&amp;lt;el-dialog v-dialogDrag&amp;gt;&amp;lt;/el-dialog&amp;gt;
</code></pre> 
<p>具体使用便是这样，希望有人看到哈哈哈，当然主要还是想帮到大家。</p> 
<p>来源：<a href="https://segmentfault.com/a/1190000016040327" rel="nofollow">https://segmentfault.com/a/1190000016040327</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/878ef0dc744a9ca7985a0994fb68aeda/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring里面Bean的生命周期和循环依赖问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/71456ad179783594572a593d2759dc53/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue实现后台实时编辑预览页面，小程序端展示</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>