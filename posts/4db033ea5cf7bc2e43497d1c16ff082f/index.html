<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一文让你搞懂WebSocket原理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一文让你搞懂WebSocket原理" />
<meta property="og:description" content="小编最近在工作上碰到了用WebSocket方式连接客户端和服务端的问题，顺便研究了一下WebSocket，现在做一下归纳总结，希望通过此文可以帮助您搞懂WebSocket原理。
一、WebSocket简述
首先，象征性的来说说WebSocket是个啥，标准的定义是：
WebSocket是一种在单个TCP连接上进行全双工通信的协议。
说人话就是：WebSocket是一个通信协议，基于这种协议客户端和服务端都可以在同一个TCP连接上主动发起通信请求。
二、WebSocket特点
对于初学者来说，记住WebSocket以下几个特点即可：
使用很简单
支持双向通信，即时性强
长连接
较少的控制开销
三、WebSocket握手原理
在WebSocket API中，客户端和服务端只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。啥都不说，直接看小编我在调试过程中抓包获取的握手协议。
1、客户端：申请协议升级
GET /ums/websocket?id=01030212080000026&amp;terminalType=1&amp;appKey=seeCloud HTTP/1.1 Upgrade: websocket Connection: Upgrade Host: 192.168.15.167:9700 Sec-WebSocket-Key: hkFKN6jn3BRX9hEPWU1zvA== Sec-WebSocket-Version: 13 熟悉HTTP的童鞋可能就发现了，这段类似HTTP协议的握手请求中，多了几个东西。
Upgrade:websocket：表示我发起的是websocket协议请求。
Connection:Upgrade：表示要升级协议
Sec-WebSocket-Key：是一个Base64 encode的值，这个是浏览器随机生成的，告诉服务器，不要忽悠我，我要通过这个验证你是不是真的升级到WebSocket。这个Key与后面服务端响应首部的 Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。
Sec-WebSocket-Version:13：表示WebSocket的版本。
2、服务端：响应协议升级​​​​​​​
HTTP/1.1 101 Switching Protocols Connection: Upgrade Sec-WebSocket-Accept: K9phjpOTC23muj7pYwH/Dn/Jq6o= Server: Jetty(9.3.10.v20160621) Upgrade: WebSocket 其中Upgrade和Connection就是告诉客户端，我服务端已经切换成Websocket协议啦。
Sec-WebSocket-Accept则是返回经过服务器确认，并且加密过后的 Sec-WebSocket-Key。客户端拿到这个key解密就知道服务端是不是忽悠啦~
四、WebSocket通信
以前很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点就是浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。下面我们来看一段对话：​​​​​​​
客户端：有没有新信息(Request) 服务端：没有（Response） 客户端：有没有新信息(Request) 服务端：没有。。（Response） 客户端：有没有新信息(Request) 服务端：没有啊。。。（Response） 客户端：有没有新消息（Request） 服务端：好啦好啦，有啦给你。（Response） 客户端：有没有新消息（Request） 服务端：。。。。。没。。。。没。。。没有（Response） 通过上面这个例子，我们可以看出，这种方式需要很多资源，而根据我们的理解最好的方式就是我需要你，你就在，你需要我，恰好我也在。小编在谈恋爱的时候，也稀饭这种感觉，屏幕前的你呢？哈哈哈~~~~
而WebSocket的出现完美的解决了这么一个问题。于是就出现了下面的对话：​​​​​​​
客户端：洞幺，我要建立WebSocket协议，需要的服务：WebSocket协议版本：13（HTTP Request） 服务端：洞两，ok，确认，已升级为WebSocket协议（HTTP Protocols Switched） 客户端：我需要消息。。。 服务端：暂时没有，有的时候会告诉你的。 服务端：起床了 服务端：吃早饭了。。。 服务端：上班了。。。。 服务端：笑死我了哈哈哈哈哈哈哈 就是这样，只需要客户端经过一次HTTP请求，服务端就可以做到源源不断的给客户端传送信息了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4db033ea5cf7bc2e43497d1c16ff082f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-19T15:08:18+08:00" />
<meta property="article:modified_time" content="2019-03-19T15:08:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一文让你搞懂WebSocket原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>小编最近在工作上碰到了用WebSocket方式连接客户端和服务端的问题，顺便研究了一下WebSocket，现在做一下归纳总结，希望通过此文可以帮助您搞懂WebSocket原理。</p> 
<p> </p> 
<p>一、WebSocket简述</p> 
<p>首先，象征性的来说说WebSocket是个啥，标准的定义是：</p> 
<p><strong>WebSocket是一种在单个TCP连接上进行全双工通信的协议。</strong></p> 
<p> </p> 
<p><strong>说人话就是：</strong>WebSocket是一个通信协议，基于这种协议客户端和服务端都可以在同一个TCP连接上<strong>主动</strong>发起通信请求。</p> 
<p> </p> 
<p>二、WebSocket特点</p> 
<p>对于初学者来说，记住WebSocket以下几个特点即可：</p> 
<ol><li> <p>使用很简单</p> </li><li> <p>支持双向通信，即时性强</p> </li><li> <p>长连接</p> </li><li> <p>较少的控制开销</p> <p> </p> </li></ol> 
<p>三、WebSocket握手原理</p> 
<p>在WebSocket API中，客户端和服务端只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。啥都不说，直接看小编我在调试过程中抓包获取的握手协议。</p> 
<p> </p> 
<p>1、客户端：申请协议升级</p> 
<pre class="has"><code>GET /ums/websocket?id=01030212080000026&amp;terminalType=1&amp;appKey=seeCloud HTTP/1.1
Upgrade: websocket
Connection: Upgrade
Host: 192.168.15.167:9700
Sec-WebSocket-Key: hkFKN6jn3BRX9hEPWU1zvA==
Sec-WebSocket-Version: 13</code></pre> 
<p> </p> 
<p>熟悉HTTP的童鞋可能就发现了，这段类似HTTP协议的握手请求中，多了几个东西。</p> 
<ul><li> <p>Upgrade:websocket：表示我发起的是websocket协议请求。</p> </li><li> <p>Connection:Upgrade：表示要升级协议</p> </li><li> <p>Sec-WebSocket-Key：是一个Base64 encode的值，这个是浏览器随机生成的，告诉服务器，不要忽悠我，我要通过这个验证你是不是真的升级到WebSocket。这个Key与后面服务端响应首部的 Sec-WebSocket-Accept是配套的，提供基本的防护，比如恶意的连接，或者无意的连接。</p> </li><li> <p>Sec-WebSocket-Version:13：表示WebSocket的版本。</p> </li></ul> 
<p> </p> 
<p>2、服务端：响应协议升级​​​​​​​</p> 
<pre class="has"><code>HTTP/1.1 101 Switching Protocols
Connection: Upgrade
Sec-WebSocket-Accept: K9phjpOTC23muj7pYwH/Dn/Jq6o=
Server: Jetty(9.3.10.v20160621)
Upgrade: WebSocket</code></pre> 
<p> </p> 
<p>其中Upgrade和Connection就是告诉客户端，我服务端已经切换成Websocket协议啦。</p> 
<p>Sec-WebSocket-Accept则是返回经过服务器确认，并且加密过后的 Sec-WebSocket-Key。客户端拿到这个key解密就知道服务端是不是忽悠啦~</p> 
<p> </p> 
<p>四、WebSocket通信</p> 
<p>以前很多网站为了实现推送技术，所用的技术都是轮询。轮询是在特定的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点就是浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。下面我们来看一段对话：​​​​​​​</p> 
<pre class="has"><code>客户端：有没有新信息(Request)
服务端：没有（Response）
客户端：有没有新信息(Request)
服务端：没有。。（Response）
客户端：有没有新信息(Request)
服务端：没有啊。。。（Response）
客户端：有没有新消息（Request）
服务端：好啦好啦，有啦给你。（Response）
客户端：有没有新消息（Request）
服务端：。。。。。没。。。。没。。。没有（Response）</code></pre> 
<p> </p> 
<p>通过上面这个例子，我们可以看出，这种方式需要很多资源，而根据我们的理解最好的方式就是<strong>我需要你，你就在，你需要我，恰好我也在。</strong>小编在谈恋爱的时候，也稀饭这种感觉，屏幕前的你呢？哈哈哈~~~~</p> 
<p> </p> 
<p>而WebSocket的出现完美的解决了这么一个问题。于是就出现了下面的对话：​​​​​​​</p> 
<pre class="has"><code>客户端：洞幺，我要建立WebSocket协议，需要的服务：WebSocket协议版本：13（HTTP Request）
服务端：洞两，ok，确认，已升级为WebSocket协议（HTTP Protocols Switched）
客户端：我需要消息。。。
服务端：暂时没有，有的时候会告诉你的。
服务端：起床了
服务端：吃早饭了。。。
服务端：上班了。。。。
服务端：笑死我了哈哈哈哈哈哈哈</code></pre> 
<p>就是这样，只需要客户端经过一次HTTP请求，服务端就可以做到源源不断的给客户端传送信息了。</p> 
<p>五、关于WebSocket</p> 
<p>WebSocket可写的东西还挺多，比如WebSocket扩展、数据帧格式等，客户端、服务端之间是如何协商、使用扩展的？WebSocket扩展可以给协议本身增加很多能力和想象空间，比如数据的压缩、加密，以及多路复用等。客户端、服务端数据的交换，离不开数据帧格式的定义。客户端、服务端之间能够实现长连接，为什么？在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你这样的协议解决了上面同步有延迟，而且还非常消耗资源的这种情况。</p> 
<p> </p> 
<p>小编目前也是粗略学习了其中的皮毛，更详细深刻的内容，等到日后学习好了再向大家汇报。扫描关注下方二维码和我们多多交流WebSocket的问题吧，欢迎不吝赐教！</p> 
<p> </p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/13/59/TVDNoIue_o.jpg"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/af23648532c59bb404b8d520c0874f7d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">6.Python3标准库--数学运算</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/16e53dc5e946a580c1d314f09a43a9c6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决Python报错UnicodeDecodeError: &#39;gbk&#39; codec can&#39;t decode byte 0x80 in position 658: illegal multibyte</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>