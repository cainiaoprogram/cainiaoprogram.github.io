<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HashMap中put方法（白话加源码分析） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HashMap中put方法（白话加源码分析）" />
<meta property="og:description" content="一.首先不看代码用白话分析一下流程 我们在使用put方法的时候会传进key和value参数
在我们将这两个参数传入后，
第一步，我们的put方法会去判断这个hashmap是否为null 或者长度是否为0，如果是则对hashmap数组进行resize()扩容，
第二步，put方法会根据这个key计算hash码来得到数组的位置，（这里需要解释一下，我们的hashmap默认是由一个数组加链表组成的）
得到位置后当然是继续判断这个数组下标的值是否为null，为null 自然是直接插入我们的value值，如果不为空的话进行第三步
第三步，判断key是否为null，当key！=null我们就可以覆盖value值，key==null继续第四步
第四步，如果key值也为空，则判断结点类型是链表还是红黑树
第五步，如果节点类型为红黑树，则执行红黑树插入操作
如果节点类型为链表，那么put方法就会遍历这个链表，for循环遍历链表直至链表尾部，然后进行尾插，当链表长度&gt;=8时，会进入链表转红黑树的方法，treeifyBin方法中还会判断数组长度，数组长度&gt;=64,链表长度&gt;=8同时满足，才会将链表转为红黑树；在for循环遍历过程中，如果key相同，则直接插入元素
第五步，记录操作次数变量modCount&#43;1，最后再判断当前map中有多少元素，和阈值做对比，如果超过阈值则进行扩容当数组容量超过最大容量时就会扩容一倍（即二进制的进位），没有则返回null。
put方法是由返回值的，在插入完成后，如果插入之前已经存在这个key，则返回的是插入之前已存在元素的value
二.图解 三.源码分析 //put方法，会先调用一个hash()方法，得到当前key的一个hash值， //用于确定当前key应该存放在数组的哪个下标位置 //这里的 hash方法，我们姑且先认为是key.hashCode()，其实不是的，一会儿细讲 public V put(K key, V value) { //返回调用putVal方法 return putVal(hash(key), key, value, false, true); } final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { // tab指代是hashmap的散列表再，在下方初始化，hashmap不是在创建的时候初始化，而是在put的时候初始化，属于懒初始化 // p表示当前散列表元素 // n表示散列表数组长度 // i表示路由寻址的结果 Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //判断是否为空，为空的话初始化，不为空对tab和n进行赋值 if ((tab = table) == null || (n = tab." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1687aa83d5ce3265e2a6108a4f23e6b7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-14T13:36:58+08:00" />
<meta property="article:modified_time" content="2022-05-14T13:36:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HashMap中put方法（白话加源码分析）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一.首先不看代码用白话分析一下流程</h2> 
<p>我们在使用put方法的时候会传进key和value参数</p> 
<p>在我们将这两个参数传入后，</p> 
<p><strong>第一步，</strong>我们的put方法会去判断这个hashmap是否为null 或者长度是否为0，如果是则对hashmap数组进行resize()扩容，</p> 
<p><strong>第二步，</strong>put方法会根据这个key计算<a href="https://so.csdn.net/so/search?q=hash&amp;spm=1001.2101.3001.7020" title="hash">hash</a>码来得到数组的位置，（这里需要解释一下，我们的hashmap默认是由一个数组加链表组成的）</p> 
<p>得到位置后当然是继续判断这个数组下标的值是否为null，为null 自然是直接插入我们的value值，如果不为空的话进行第三步</p> 
<p><strong>第三步，</strong>判断key是否为null，当key！=null我们就可以覆盖value值，key==null继续第四步</p> 
<p><strong>第四步，</strong>如果key值也为空，则判断结点类型是链表还是红黑树</p> 
<p><strong>第五步</strong>，如果节点类型为<a href="https://so.csdn.net/so/search?q=%E7%BA%A2%E9%BB%91%E6%A0%91&amp;spm=1001.2101.3001.7020" title="红黑树">红黑树</a>，则执行红黑树插入操作</p> 
<p>如果节点类型为链表，那么put方法就会遍历这个链表，for循环遍历链表直至链表尾部，然后进行尾插，当链表长度&gt;=8时，会进入链表转红黑树的方法，treeifyBin方法中还会判断<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6&amp;spm=1001.2101.3001.7020" title="数组长度">数组长度</a>，数组长度&gt;=64,链表长度&gt;=8同时满足，才会将链表转为红黑树；在for循环遍历过程中，如果key相同，则直接插入元素</p> 
<p><strong>第五步，</strong>记录操作次数变量modCount+1，最后再判断当前map中有多少元素，和阈值做对比，如果超过阈值则进行扩容当数组容量超过最大容量时就会扩容一倍（即二进制的进位），没有则返回null。</p> 
<p>put方法是由返回值的，在插入完成后，如果插入之前已经存在这个key，则返回的是插入之前已存在元素的value</p> 
<h2>二.图解</h2> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/bb/7b/ChAluPb7_o.png"></p> 
<p></p> 
<p></p> 
<h2> 三.源码分析</h2> 
<pre><code class="language-java">//put方法，会先调用一个hash()方法，得到当前key的一个hash值，
//用于确定当前key应该存放在数组的哪个下标位置
//这里的 hash方法，我们姑且先认为是key.hashCode()，其实不是的，一会儿细讲
 public V put(K key, V value) {

        //返回调用putVal方法
        return putVal(hash(key), key, value, false, true);
    }</code></pre> 
<pre><code class="language-java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        // tab指代是hashmap的散列表再，在下方初始化，hashmap不是在创建的时候初始化，而是在put的时候初始化，属于懒初始化
        // p表示当前散列表元素
        // n表示散列表数组长度
        // i表示路由寻址的结果
        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
       //判断是否为空，为空的话初始化，不为空对tab和n进行赋值
        if ((tab = table) == null || (n = tab.length) == 0)
            //resize扩容
            n = (tab = resize()).length;
         //这个i就是（n-1）和hash做与运算得到的位置，p就是这个位置的Node元素
        if ((p = tab[i = (n - 1) &amp; hash]) == null)
            //直接在当前下表newNode
            tab[i] = newNode(hash, key, value, null);
         //如果要插入的元素在这个位置有元素了，执行以下操作
        else {
            //e 临时的node元素
            //k 表示临时的一个key
            Node&lt;K,V&gt; e; K k;
            //如果这个桶的位置的元素的key和将要插入的key是一个，会进行替换
            // 比较 哈希值 ： 引用地址  ： key
            if (p.hash == hash &amp;&amp;
                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                 
                //如果相等则老元素地址指向新元素
                e = p;
            //不相等则判断节点类型：
            //结点类型为树 TreeNode是Node的一个子类
            else if (p instanceof TreeNode)                
                //红黑树的插入操作
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
            //节点类型为链表
            else {
                ///for循环：1.遍历到链表尾部，进行尾插
                //2.判断链表长度，超过8将链表改为红黑树
                for (int binCount = 0; ; ++binCount) {
                    //判断节点的下一个节点为空，遍历到链表尾部，进行尾插
                    if ((e = p.next) == null) {                       
                        //生成一个Node对象，将Node对象作为新节点插入到链表(p.next)
                        p.next = newNode(hash, key, value, null);
                          //如果链表长度 &gt;= TREEIFY_THRESHOLD-1 = 7 因为是从0开始遍历，所以此时链表长度为8
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                            //树化函数
                            treeifyBin(tab, hash);
                        break;
                    }
                    
                    //key相同时同样插入返回
                    if (e.hash == hash &amp;&amp;
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                        break;
                    p = e;
                }
            }
            //这种属于覆盖操作，当e中有值进入操作
            if (e != null) { // existing mapping for key
                //oldValue保存老的值，方便return
                V oldValue = e.value;
                //onlyIfAbsent传入的是false，指定能进入判断
                if (!onlyIfAbsent || oldValue == null)
                    //新元素的值将老元素的值覆盖掉
                    e.value = value;
                //HashMap提供给子类的方法
                afterNodeAccess(e);
                //put操作有返回值，返回的是插入之前已经存在的元素的value值
                return oldValue;
            }
        }

        //增加修改次数
        ++modCount;
    	//统计当前map中有多少元素，和阈值对比，判断是否需要扩容
        if (++size &gt; threshold)
            resize();
        afterNodeInsertion(evict);
        return null;
    }</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8fbd0fd30b1087e5e7d2cef68127ff41/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决“VirtualBox VERR_NEM_INIT_FAILED“问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6d685145c769a961af0629557cf5eadf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android开发：基于Kotlin编写一个简易计算器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>