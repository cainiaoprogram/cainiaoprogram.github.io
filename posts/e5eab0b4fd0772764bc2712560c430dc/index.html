<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JUC中的FutureTask - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JUC中的FutureTask" />
<meta property="og:description" content="package JUC;
import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;
/**
* RunnableAndCallable两个类的比较
* @author YEXIN
*
*/
/**
FutureTask可用于异步获取执行结果或取消执行任务的场景。通过传入Runnable或者Callable的任务给FutureTask，
直接调用其run方法或者放入线程池执行，之后可以在外部通过FutureTask的get方法异步获取执行结果，
因此，FutureTask非常适合用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。
另外，FutureTask还可以确保即使调用了多次run方法，
它都只会执行一次Runnable或者Callable任务，或者通过cancel取消FutureTask的执行等。
1. FutureTask执行多任务计算的使用场景
利用FutureTask和ExecutorService，可以用多线程的方式提交计算任务，主线程继续执行其他任务，
当主线程需要子线程的计算结果时，在异步获取子线程的执行结果。
2. FutureTask在高并发环境下确保任务只执行一次
在很多高并发的环境下，往往我们只需要某些任务只执行一次。这种使用情景FutureTask的特性恰能胜任。
举一个例子，假设有一个带key的连接池，当key存在时，即直接返回key对应的对象；当key不存在时，
则创建连接。对于这样的应用场景，通常采用的方法为使用一个Map对象来存储key和连接池对应的对应关系
*
*/
public class RunnableAndCallable {
class MyThread2 implements Runnable{
@Override
public void run() {
System.out.println(&#34;come in Runnable1&#34;);
}
}
class MyThread implements Callable&lt;Integer&gt;{
@Override
public Integer call() throws Exception {//实现call方法
System.out.println(&#34;come in Callable1&#34;);
return 200;//有返回值
}
}" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e5eab0b4fd0772764bc2712560c430dc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-27T17:22:56+08:00" />
<meta property="article:modified_time" content="2019-08-27T17:22:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JUC中的FutureTask</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>package JUC;</p> 
<p>import java.util.concurrent.Callable;<br> import java.util.concurrent.ExecutionException;<br> import java.util.concurrent.FutureTask;</p> 
<p>/**<br>  * RunnableAndCallable两个类的比较<br>  * @author YEXIN<br>  *<br>  */<br> /**<br> FutureTask可用于异步获取执行结果或取消执行任务的场景。通过传入Runnable或者Callable的任务给FutureTask，<br>  直接调用其run方法或者放入线程池执行，之后可以在外部通过FutureTask的get方法异步获取执行结果，<br>  因此，FutureTask非常适合用于耗时的计算，主线程可以在完成自己的任务后，再去获取结果。<br>  另外，FutureTask还可以确保即使调用了多次run方法，<br>   它都只会执行一次Runnable或者Callable任务，或者通过cancel取消FutureTask的执行等。<br> 1. FutureTask执行多任务计算的使用场景<br> 利用FutureTask和ExecutorService，可以用多线程的方式提交计算任务，主线程继续执行其他任务，<br> 当主线程需要子线程的计算结果时，在异步获取子线程的执行结果。</p> 
<p>2. FutureTask在高并发环境下确保任务只执行一次<br> 在很多高并发的环境下，往往我们只需要某些任务只执行一次。这种使用情景FutureTask的特性恰能胜任。<br> 举一个例子，假设有一个带key的连接池，当key存在时，即直接返回key对应的对象；当key不存在时，<br> 则创建连接。对于这样的应用场景，通常采用的方法为使用一个Map对象来存储key和连接池对应的对应关系</p> 
<p> *<br>  */<br> public class RunnableAndCallable {<!-- --><br>     <br>     class MyThread2 implements Runnable{<!-- --></p> 
<p>        @Override<br>         public void run() {<!-- --><br>             System.out.println("come in Runnable1");<br>             <br>         }<br>         <br>     }<br>     <br>     class MyThread implements Callable&lt;Integer&gt;{<!-- --></p> 
<p>        @Override<br>         public Integer call() throws Exception {//实现call方法<br>             System.out.println("come in Callable1");<br>             return 200;//有返回值<br>         }<br>         <br>     }<br>     <br>     public static void main(String[] args) throws InterruptedException, ExecutionException {<!-- --><br>         Runnable myThread2  = () -&gt; {System.out.println("come in Runnable2");};//lamda实现，覆盖了原来中的方法体<br>         myThread2.run();<br>         <br>         Callable myThread  = () -&gt; {System.out.println("come in Callable2");return 100;};//lamda实现,覆盖了原来中的方法体<br>         try {<!-- --><br>             Integer m = (Integer) myThread.call();<br>             System.out.println(m);<br>         } catch (Exception e) {<!-- --><br>             e.printStackTrace();<br>         }<br>         <br> //==================================================================================================        <br>         //使用FutureTask，它同时实现了Runnable和Callable接口，new的时候可以传入一个Callable接口的实现<br>         //<br>         FutureTask&lt;Integer&gt; fTask = new FutureTask&lt;Integer&gt;(() -&gt; {<!-- --><br>             System.out.println("come in Callable3");<br>             return 300;<br>         });<br>         <br>         new Thread(fTask,"AA").start();<br>         //一般FutureTask多用于耗时计算，主线程在自己的任务完成后，再去获取结果<br>         //仅在计算完成时才能检索结果，如果计算没完成，则阻塞get方法<br>         System.out.println(fTask.get());<br>         <br>         <br>     }                                                                                    <br> }</p> 
<p>================================================</p> 
<p>come in Runnable2<br> come in Callable2<br> 100<br> come in Callable3<br> 300</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6faa16df64c7f986543201416e9bcab2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用yocto工具编译qt5.9.6总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c71324fffa02e52687d84d8bf3b6abfb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[20190825]Join View and delete.txt</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>