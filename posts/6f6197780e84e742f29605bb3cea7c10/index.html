<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>rabbitmq消费端限流:一次只能消费一条消息 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="rabbitmq消费端限流:一次只能消费一条消息" />
<meta property="og:description" content="1. 什么是消费端的限流？ 场景：在订单高峰期，rabbitmq上已经堆积了很多消息等待消费，如果没有任何限流措施，贸然启动一个消费者时，如此多的消息瞬间推送给消费者，消费者可能因无法处理这么多的消息而承受巨大压力，甚至崩溃！
2. 解决方案 rabbitmq 提供了basicQos方法实现了限流，也就是在关闭了消费端的自动ack的前提 下，我们可以设置阈值（出队）的消息数。 没有手动确认，那么就不会推送新的消息过来！可以有效防止消费者压力过大而崩溃。
/** * 限流设置: prefetchSize：每条消息大小的设置，0是无限制 * prefetchCount:标识每次推送多少条消息 一般是一条 * global:false标识channel级别的 true:标识消费者级别的 */ channel.basicQos(0,1,false); 3. 代码示例 生产者：
public class Producer { public static void main(String[] args) throws Exception{ // 1、创建连接工厂 ConnectionFactory factory = new ConnectionFactory(); factory.setVirtualHost(&#34;/&#34;); factory.setPort(5672); factory.setHost(&#34;192.168.200.130&#34;); factory.setUsername(&#34;mqs&#34;); factory.setPassword(&#34;mqs123&#34;); // 2、创建连接 Connection connection = factory.newConnection(); // 3、获取通道 Channel channel = connection.createChannel(); // 4、声明交换机和路由 String exchangeName = &#34;limit_exchange&#34;; String routingKey = &#34;limit.key&#34;; //消息体 String msg = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6f6197780e84e742f29605bb3cea7c10/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-01T14:03:10+08:00" />
<meta property="article:modified_time" content="2023-11-01T14:03:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">rabbitmq消费端限流:一次只能消费一条消息</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1__0"></a>1. 什么是消费端的限流？</h2> 
<p>场景：在订单高峰期，rabbitmq上已经堆积了很多消息等待消费，如果没有任何限流措施，贸然启动一个消费者时，如此多的消息瞬间推送给消费者，消费者可能因无法处理这么多的消息而承受巨大压力，甚至崩溃！</p> 
<h2><a id="2__2"></a>2. 解决方案</h2> 
<p>rabbitmq 提供了basicQos方法实现了限流，也就是在关闭了消费端的自动ack的前提 下，我们可以设置阈值（出队）的消息数。 没有手动确认，那么就不会推送新的消息过来！可以有效防止消费者压力过大而崩溃。</p> 
<pre><code> /**
  * 限流设置:  prefetchSize：每条消息大小的设置，0是无限制
  * prefetchCount:标识每次推送多少条消息 一般是一条
  * global:false标识channel级别的  true:标识消费者级别的
  */
 channel.basicQos(0,1,false);
</code></pre> 
<h2><a id="3__13"></a>3. 代码示例</h2> 
<p>生产者：</p> 
<pre><code>public class Producer {
    public static void main(String[] args) throws Exception{
        // 1、创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        factory.setVirtualHost("/");
        factory.setPort(5672);
        factory.setHost("192.168.200.130");
        factory.setUsername("mqs");
        factory.setPassword("mqs123");
        // 2、创建连接
        Connection connection = factory.newConnection();
        // 3、获取通道
        Channel channel = connection.createChannel();
        // 4、声明交换机和路由
        String exchangeName = "limit_exchange";
        String routingKey = "limit.key";
        //消息体
        String msg = "send message test limit mandatory ";
 
        // 5、生产者发送消息
        for (int i = 0; i &lt; 6; i++){
            channel.basicPublish(exchangeName, routingKey, true, null, msg.getBytes());
        }
    }
}
</code></pre> 
<p>消费者：</p> 
<pre><code>    public static void main(String[] args)throws Exception {
        // 1、创建连接工厂
        ConnectionFactory factory = new ConnectionFactory();
        factory.setVirtualHost("/");
        factory.setPort(5672);
        factory.setHost("192.168.200.130");
        factory.setUsername("mqs");
        factory.setPassword("mqs123");
        // 2、创建连接
        Connection connection = factory.newConnection();
        // 3、获取通道
        Channel channel = connection.createChannel();
        // 4、声明
        String exchangeName = "limit_exchange";
        String routingKey = "limit.key";
        String exchangeType = "direct";
        String queueName = "limit_queue";
        // 5、声明一个交换器
        channel.exchangeDeclare(exchangeName, exchangeType, true, false, null);
        // 6、声明一个队列
        channel.queueDeclare(queueName, true, false, false, null);
        // 7、绑定队列到交换器
        channel.queueBind(queueName, exchangeName, routingKey);
       
        /**
         * 限流设置:  
         * prefetchSize：每条消息大小的设置，0是无限制
         * prefetchCount:标识每次推送多少条消息 一般是一条
         * global:false标识channel级别的  true:标识消费者级别的
         */
        channel.basicQos(0, 1, false);
       
        // 8、消费者，要想做限流必须将自动ack设置为false，代表手动ack，一条条的消费
        // MyConsumer  自定义消费者
        channel.basicConsume(queueName, false, new MyConsumer(channel));
 
    }
}
</code></pre> 
<p>限流必须将自动ack设置为false，代表手动ack，不然限流是不生效的。<br> channel.basicConsume(queueName, false, new MyConsumer(channel));</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3cce416a914253766b24e17862688714/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数组基础知识二</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/acdca89e42661845b923809bd5fb29d3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">较高的采样频率和较低的采样频率的结果有什么不同？比如10240和5120的采样频率的结果有什么不同？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>