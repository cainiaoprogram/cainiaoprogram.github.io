<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python3的gui教程_Python3学习笔记-tkinter制作简易GUI - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python3的gui教程_Python3学习笔记-tkinter制作简易GUI" />
<meta property="og:description" content="最近需要用python做一个GUI，实现实时采集数据并显示的功能。作为一个还没学过python的小白，在经历了两三周断断续续的学习和请教学长之后，总算是做出了一些成果，特于此记录一下学习过程。
一、了解Python3基础语法
因为做我这个GUI不需要太复杂的语法或者功能，我简单的浏览了一个很不错的Python3教程：
我觉得做GUI需要的基础语法，里面几章的内容就大概可以。
紧接着，我选择了很好用的Python IDE，Pycharm作为编译器。
二、库的选择和学习
Python令我很惊喜的就是库太强大了，几乎无所不包，大大降低了上手难度。就像当初玩单片机遇到Arduino一样。
Python做GUI的库有好几个，我选择了上手比较容易的tkinter，它创建GUI的流程大体上就是，首先创建顶层窗口对象，然后创建其他组件放进该对象中，最后进入主事件循环：循环刷新窗口。所以在布局的过程中，布局到哪里，对应的功能就相应的跟在后面。
由于实时显示采集数据和串口助手功能很相似，所以我决定先设计一个最普通的串口助手，为后面GUI的框架再用以改进。
我最开始想的大概布局就是这样：
接下来最重要的就是学会使用tkinter的各个组件了，这边我姑且以自己的理解总结一下我用到的一些组件和编程的思路。
1. 创建顶层窗口对象，我就叫它父容器
GUI = tk.Tk() # 创建父容器GUI
GUI.title(&#34;Serial Tool&#34;) # 父容器标题
GUI.geometry(&#34;460x380&#34;) # 设置父容器窗口初始大小，如果没有这个设置，窗口会随着组件大小的变化而变化
此时的效果如下：
2. 接下来是每个子容器及其组件的创建
首先是调试信息窗口，我设想的是一个带有滚动条的窗口，可以显示当前的操作状态和一些操作信息，当窗口显示满的时候可以自动往下滚动显示。
在这里，我用到的组件主要有LabelFrame，ScrolledText，grid，place，button，Entry。
LabelFrame组件会自动绘制一个边框将子组件包围起来，并在它们上方显示一个文本标题，组件选项如下：
咋一看好多参数，其实很多都可以使用默认参数，自定义几个参数即可。
ScrolledText组件是创建一个带有滚动条的文本窗口，全部参数选项有哪些我也没搞清楚，因为它是Text的一个子组件，所以Text部分选项参数它也可以调用，其中Text的全部选项我就不贴了，只选取一个贴一下：
我在这里使用的是选项是wrap=tk.WORD,这个值表示在行的末尾如果有一个单词跨行，会将该单词放到下一行显示,比如输入hello，he在第一行的行尾，llo在第二行的行首, 这时如果wrap=tk.WORD，则表示会将 hello 这个单词挪到下一行行首显示。
grid，pack，place是tkinter的三个布局器。
gird的实现机制是将窗口逻辑上分割成表格，在指定的位置放置想要的组件，主要参数如下：
pack采用块的方式组织配件，它是一个弹性的容器，容器的大小会随着内部子容器的大小而变化，但是可以使用.propagate(False)，限定组件的大小不变。如果不指定pack的option参数，pack会从上到下的放置组件。主要参数如下：
grid采用行列确定位置，行列号只是指定放置的相对位置，而不是实际的像素坐标。行列交汇处为一个单元格。每一列中，列宽由这一列中最宽的单元格确定。每一行中，行高由这一行中最高的单元格决定。组件并不是充满整个单元格的，你可以指定单元格中剩余空间的使用。你可以空出这些空间，也可以在水平或竖直或两个方 向上填满这些空间。你可以连接若干个单元格为一个更大空间， 这一操作被称作跨越。创建的单元格必须相邻。主要参数如下：
Place 布局管理可以显式的指定控件的绝对位置或相对于其他控件的位置. 要使用 Place 布局, 调用相应控件的 place() 方法就可以了。说简单点，指定一个坐标即可放置组件。
简单了解完这三个布局器说实话一头雾水，不过实际用起来多尝试很快就可以理解它们的作用，我每个子容器主要是使用place，因为简单暴力，直接指定坐标，指哪放哪。grid和pack多用在子容器内部布局使用。
button组件用于实现各种各样的按钮，选项参数如下：
咋一看好多参数，其实很多都可以使用默认参数，自定义几个参数即可。
Entry组件通常用于获取用户输入的文本，选项参数如下：
好了，组件介绍完毕可以开始布局了，首先我的调试信息窗口写法如下：
Information = tk.LabelFrame(GUI, text=&#34;操作信息&#34;, padx=10, pady=10) # 创建子容器，水平，垂直方向上的边距均为10
Information.place(x=20, y=20)
Information_Window = scrolledtext." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8d2c67a1cd06ac5e3a1ed140f16b7745/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-01T09:12:37+08:00" />
<meta property="article:modified_time" content="2020-12-01T09:12:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python3的gui教程_Python3学习笔记-tkinter制作简易GUI</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>最近需要用python做一个GUI，实现实时采集数据并显示的功能。作为一个还没学过python的小白，在经历了两三周断断续续的学习和请教学长之后，总算是做出了一些成果，特于此记录一下学习过程。</p> 
 <p>一、了解Python3基础语法</p> 
 <p>因为做我这个GUI不需要太复杂的语法或者功能，我简单的浏览了一个很不错的Python3教程：</p> 
 <p>我觉得做GUI需要的基础语法，里面几章的内容就大概可以。</p> 
 <p>紧接着，我选择了很好用的Python IDE，Pycharm作为编译器。</p> 
 <p>二、库的选择和学习</p> 
 <p>Python令我很惊喜的就是库太强大了，几乎无所不包，大大降低了上手难度。就像当初玩单片机遇到Arduino一样。</p> 
 <p>Python做GUI的库有好几个，我选择了上手比较容易的tkinter，它创建GUI的流程大体上就是，首先创建顶层窗口对象，然后创建其他组件放进该对象中，最后进入主事件循环：循环刷新窗口。所以在布局的过程中，布局到哪里，对应的功能就相应的跟在后面。</p> 
 <p>由于实时显示采集数据和串口助手功能很相似，所以我决定先设计一个最普通的串口助手，为后面GUI的框架再用以改进。</p> 
 <p align="center">我最开始想的大概布局就是这样：<img src="" alt=""></p> 
 <p>接下来最重要的就是学会使用tkinter的各个组件了，这边我姑且以自己的理解总结一下我用到的一些组件和编程的思路。</p> 
 <p>1. 创建顶层窗口对象，我就叫它父容器</p> 
 <p>GUI = tk.Tk() # 创建父容器GUI</p> 
 <p>GUI.title("Serial Tool") # 父容器标题</p> 
 <p>GUI.geometry("460x380") # 设置父容器窗口初始大小，如果没有这个设置，窗口会随着组件大小的变化而变化</p> 
 <p align="center">此时的效果如下：<img src="" alt=""></p> 
 <p>2. 接下来是每个子容器及其组件的创建</p> 
 <p>首先是调试信息窗口，我设想的是一个带有滚动条的窗口，可以显示当前的操作状态和一些操作信息，当窗口显示满的时候可以自动往下滚动显示。</p> 
 <p>在这里，我用到的组件主要有LabelFrame，ScrolledText，grid，place，button，Entry。</p> 
 <p align="center">LabelFrame组件会自动绘制一个边框将子组件包围起来，并在它们上方显示一个文本标题，组件选项如下：<img src="" alt=""><img src="" alt=""></p> 
 <p>咋一看好多参数，其实很多都可以使用默认参数，自定义几个参数即可。</p> 
 <p align="center">ScrolledText组件是创建一个带有滚动条的文本窗口，全部参数选项有哪些我也没搞清楚，因为它是Text的一个子组件，所以Text部分选项参数它也可以调用，其中Text的全部选项我就不贴了，只选取一个贴一下：<img src="" alt=""></p> 
 <p>我在这里使用的是选项是wrap=tk.WORD,这个值表示在行的末尾如果有一个单词跨行，会将该单词放到下一行显示,比如输入hello，he在第一行的行尾，llo在第二行的行首, 这时如果wrap=tk.WORD，则表示会将 hello 这个单词挪到下一行行首显示。</p> 
 <p>grid，pack，place是tkinter的三个布局器。</p> 
 <p align="center">gird的实现机制是将窗口逻辑上分割成表格，在指定的位置放置想要的组件，主要参数如下：<img src="" alt=""></p> 
 <p align="center">pack采用块的方式组织配件，它是一个弹性的容器，容器的大小会随着内部子容器的大小而变化，但是可以使用.propagate(False)，限定组件的大小不变。如果不指定pack的option参数，pack会从上到下的放置组件。主要参数如下：<img src="" alt=""></p> 
 <p align="center">grid采用行列确定位置，行列号只是指定放置的相对位置，而不是实际的像素坐标。行列交汇处为一个单元格。每一列中，列宽由这一列中最宽的单元格确定。每一行中，行高由这一行中最高的单元格决定。组件并不是充满整个单元格的，你可以指定单元格中剩余空间的使用。你可以空出这些空间，也可以在水平或竖直或两个方 向上填满这些空间。你可以连接若干个单元格为一个更大空间， 这一操作被称作跨越。创建的单元格必须相邻。主要参数如下：<img src="" alt=""></p> 
 <p>Place 布局管理可以显式的指定控件的绝对位置或相对于其他控件的位置. 要使用 Place 布局, 调用相应控件的 place() 方法就可以了。说简单点，指定一个坐标即可放置组件。</p> 
 <p>简单了解完这三个布局器说实话一头雾水，不过实际用起来多尝试很快就可以理解它们的作用，我每个子容器主要是使用place，因为简单暴力，直接指定坐标，指哪放哪。grid和pack多用在子容器内部布局使用。</p> 
 <p align="center">button组件用于实现各种各样的按钮，选项参数如下：<img src="" alt=""><img src="" alt=""><img src="" alt=""></p> 
 <p>咋一看好多参数，其实很多都可以使用默认参数，自定义几个参数即可。</p> 
 <p align="center">Entry组件通常用于获取用户输入的文本，选项参数如下：<img src="" alt=""><img src="" alt=""></p> 
 <p>好了，组件介绍完毕可以开始布局了，首先我的调试信息窗口写法如下：</p> 
 <p>Information = tk.LabelFrame(GUI, text="操作信息", padx=10, pady=10) # 创建子容器，水平，垂直方向上的边距均为10</p> 
 <p>Information.place(x=20, y=20)</p> 
 <p>Information_Window = scrolledtext.ScrolledText(Information, width=20, height=5, padx=10, pady=10,wrap=tk.WORD)</p> 
 <p>Information_Window.grid()</p> 
 <p align="center">此时效果如下：<img src="" alt=""></p> 
 <p>接下来如法炮制，创建数据接收子容器：</p> 
 <p>Receive = tk.LabelFrame(GUI, text="接收区", padx=10, pady=10 ) # 水平，垂直方向上的边距均为 10</p> 
 <p>Receive.place(x=240, y=150)</p> 
 <p>Receive_Window = scrolledtext.ScrolledText(Receive, width=20, height=12, padx=10, pady=10, wrap=tk.WORD)</p> 
 <p>Receive_Window.grid()</p> 
 <p align="center">此时效果如下：<img src="" alt=""></p> 
 <p>发送子容器需要文本窗口，和发送按钮，按下发送按钮时将文本窗口的内容发送至设备，写法如下：</p> 
 <p>Send = tk.LabelFrame(GUI, text="发送指令", padx=10, pady=5)</p> 
 <p>Send.place(x=240, y=20)</p> 
 <p>DataSend = tk.StringVar() # 定义DataSend为保存文本框内容的字符串</p> 
 <p>EntrySend = tk.StringVar()</p> 
 <p>Send_Window = ttk.Entry(Send, textvariable=EntrySend, width=23)</p> 
 <p>Send_Window.grid()</p> 
 <p>def WriteData(): # 按钮按下时触发的动作函数</p> 
 <p>global DataSend</p> 
 <p>DataSend = EntrySend.get() # 读取当前文本框的内容保存到字符串变量DataSend</p> 
 <p>Information_Window.insert("end", '发送指令为：' + str(DataSend) + '\n') # 在操作信息窗口显示发送的指令并换行，end为在窗口末尾处显示</p> 
 <p>Information_Window.see("end") # 此处为显示操作信息窗口进度条末尾内容，以上两行可实现窗口内容满时，进度条自动下滚并在最下方显示新的内容</p> 
 <p>SerialPort.write(bytes(DataSend, encoding='utf8')) # 串口发送文本框内容</p> 
 <p>tk.Button(Send, text="发送", command=WriteData).grid(pady=5, sticky=tk.E)</p> 
 <p align="center">此时效果如下：<img src="" alt=""></p> 
 <p>接下来开始创建选项子容器，作为一个串口助手，选项里肯定得有端口号，波特率的下拉菜单栏，在这里使用的主要组件有Label，Combobox</p> 
 <p align="center">Label组件用于显示文本和图像，组件选项如下：<img src="" alt=""><img src="" alt=""></p> 
 <p>emmm....依旧是很多参数，不过依旧还是大部分使用默认参数，自定义几个参数即可。</p> 
 <p>Combobox用来创建下拉菜单栏，我用到的组件选项如下：</p> 
 <p>values 设定下拉菜单可选内容</p> 
 <p>state 设定状态。readonly时为只可选择，不可更改内容</p> 
 <p>current 设定初始选择内容，参数为可选列表的0-index</p> 
 <p>于是我选项子容器的写法如下：</p> 
 <p>option = tk.LabelFrame( GUI, text = "选项", padx = 10, pady = 10 )</p> 
 <p>option.place(x = 20, y = 150, width = 203)</p> 
 <p># ************创建下拉列表**************</p> 
 <p>ttk.Label( option, text = "串口号:" ).grid( column = 0, row = 0 ) # 添加串口号标签</p> 
 <p>ttk.Label( option, text = "波特率:" ).grid( column = 0, row = 1 ) # 添加波特率标签</p> 
 <p>Port = tk.StringVar() # 端口号字符串</p> 
 <p>Port_list = ttk.Combobox( option, width = 12, textvariable = Port, state = 'readonly' )</p> 
 <p>ListPorts = list(serial.tool.list_ports.comports) # 扫描当前可用串口保存到表ListPorts</p> 
 <p>Port_list['values'] = [i[0] for i in ListPorts] # 下拉列表的值为ListPorts的所有值</p> 
 <p>Port_list.current(0) # 初始显示表中第一个值</p> 
 <p>Port_list.grid(column=1, row=0) # 设置其在界面中出现的位置 column代表列 row 代表行</p> 
 <p>BaudRate = tk.StringVar() # 波特率字符串</p> 
 <p>BaudRate_list = ttk.Combobox( option, width = 12, textvariable = BaudRate, state = 'readonly' )</p> 
 <p>BaudRate_list['values'] = (1200, 2400, 4800, 9600, 14400, 19200, 38400, 43000, 57600, 76800, 115200)</p> 
 <p>BaudRate_list.current(3) # 初始显示9600</p> 
 <p>BaudRate_list.grid(column=1, row=1)</p> 
 <p align="center">此时效果如下：<img src="" alt=""></p> 
 <p>最后是创建开/停按钮的子容器了，停止按钮则是直接关闭串口即可实现停止采集，而开始采集按钮按下后需要接收数据并把数据显示到接收区，接收数据的核心是要添加一个线程跟主线程并行，这样才能保证一直接收数据且不和主事件循环冲突。这一块我的写法如下：</p> 
 <p>switch = tk.LabelFrame(GUI, text="", padx = 10, pady=10)</p> 
 <p>switch.place(x=20, y=315, width=203)</p> 
 <p>def ReceiveData():</p> 
 <p>while SerialPort.isOpen():</p> 
 <p>Receive_Window.insert("end", str(SerialPort.readline()) + '\n')</p> 
 <p>Receive_Window.see("end")</p> 
 <p>def Close_Serial():</p> 
 <p>SerialPort.close()</p> 
 <p>def Open_Serial():</p> 
 <p>if not SerialPort.isOpen():</p> 
 <p>SerialPort.port = Port_list.get() # 读取端口下拉菜单栏的选择，将其设为串口的端口</p> 
 <p>SerialPort.baudrate = BaudRate_list.get() # 读取波特率下拉菜单栏的选择，将其设为串口的波特率</p> 
 <p>SerialPort.timeout = 0.1</p> 
 <p>SerialPort.open() # 打开串口</p> 
 <p>if SerialPort.isOpen():</p> 
 <p>t = threading.Thread(target=ReceiveData) # 新建线程用来不断接收数据并显示</p> 
 <p>t.setDaemon(True) # 守护线程</p> 
 <p>t.start() # 开始线程</p> 
 <p>else:</p> 
 <p>SerialPort.close()</p> 
 <p>tk.Button(switch, text = "开始采集", command = Open_Serial ).pack( side = "left", padx = 13)</p> 
 <p>tk.Button(switch, text = "停止采集", command = Close_Serial ).pack( side = "right", padx = 13)</p> 
 <p align="center">此时效果如下：<img src="" alt=""></p> 
 <p align="center">至此，最基础的串口助手设计完成了，可以实现最基础的串口助手功能，也为我后边GUI的设计搭建了基础框架，最后运行效果如下图所示：<img src="" alt=""></p> 
 <p>附上此时我的整体程序：</p> 
 <p>#! /usr/bin/env python</p> 
 <p># -*- coding: utf-8 -*-</p> 
 <p>import threading</p> 
 <p>import tkinter as tk</p> 
 <p>import serial.tools.list_ports</p> 
 <p>from tkinter import ttk</p> 
 <p>from tkinter import scrolledtext</p> 
 <p>SerialPort = serial.Serial()</p> 
 <p>GUI = tk.Tk() # 父容器</p> 
 <p>GUI.title("Serial Tool") # 父容器标题</p> 
 <p>GUI.geometry("440x320") # 父容器大小</p> 
 <p>Information = tk.LabelFrame(GUI, text="操作信息", padx=10, pady=10) # 水平，垂直方向上的边距均为10</p> 
 <p>Information.place(x=20, y=20)</p> 
 <p>Information_Window = scrolledtext.ScrolledText(Information, width=20, height=5, padx=10, pady = 10,wrap = tk.WORD)</p> 
 <p>Information_Window.grid()</p> 
 <p>Send = tk.LabelFrame(GUI, text="发送指令", padx=10, pady=5) # 水平，垂直方向上的边距均为 10</p> 
 <p>Send.place(x=240, y=20)</p> 
 <p>DataSend = tk.StringVar() # 定义DataSend为保存文本框内容的字符串</p> 
 <p>EntrySend = tk.StringVar()</p> 
 <p>Send_Window = ttk.Entry(Send, textvariable=EntrySend, width=23)</p> 
 <p>Send_Window.grid()</p> 
 <p>def WriteData():</p> 
 <p>global DataSend</p> 
 <p>DataSend = EntrySend.get()</p> 
 <p>Information_Window.insert("end", '发送指令为：' + str(DataSend) + '\n')</p> 
 <p>Information_Window.see("end")</p> 
 <p>SerialPort.write(bytes(DataSend, encoding='utf8'))</p> 
 <p>tk.Button(Send, text="发送", command=WriteData).grid(pady=5, sticky=tk.E)</p> 
 <p>Receive = tk.LabelFrame( GUI, text = "接收区", padx = 10, pady = 10 ) # 水平，垂直方向上的边距均为 10</p> 
 <p>Receive.place(x = 240, y = 124)</p> 
 <p>Receive_Window = scrolledtext.ScrolledText(Receive, width = 18, height = 9, padx = 8, pady = 10,wrap = tk.WORD)</p> 
 <p>Receive_Window.grid()</p> 
 <p>option = tk.LabelFrame( GUI, text = "选项", padx = 10, pady = 10 ) # 水平，垂直方向上的边距均为10</p> 
 <p>option.place(x = 20, y = 150, width = 203) # 定位坐标</p> 
 <p># ************创建下拉列表**************</p> 
 <p>ttk.Label( option, text = "串口号:" ).grid( column = 0, row = 0 ) # 添加串口号标签</p> 
 <p>ttk.Label( option, text = "波特率:" ).grid( column = 0, row = 1 ) # 添加波特率标签</p> 
 <p>Port = tk.StringVar() # 端口号字符串</p> 
 <p>Port_list = ttk.Combobox( option, width = 12, textvariable = Port, state = 'readonly' )</p> 
 <p>ListPorts = list(serial.tools.list_ports.comports())</p> 
 <p>Port_list['values'] = [i[0] for i in ListPorts]</p> 
 <p>Port_list.current(0)</p> 
 <p>Port_list.grid(column=1, row=0) # 设置其在界面中出现的位置 column代表列 row 代表行</p> 
 <p>BaudRate = tk.StringVar() # 波特率字符串</p> 
 <p>BaudRate_list = ttk.Combobox( option, width = 12, textvariable = BaudRate, state = 'readonly' )</p> 
 <p>BaudRate_list['values'] = (1200, 2400, 4800, 9600, 14400, 19200, 38400, 43000, 57600, 76800, 115200)</p> 
 <p>BaudRate_list.current(3)</p> 
 <p>BaudRate_list.grid(column=1, row=1) # 设置其在界面中出现的位置 column代表列 row 代表行</p> 
 <p>switch = tk.LabelFrame( GUI, text = "", padx = 10, pady = 10 ) # 水平，垂直方向上的边距均为 10</p> 
 <p>switch.place(x = 20, y = 250, width = 203) # 定位坐标</p> 
 <p>def ReceiveData():</p> 
 <p>while SerialPort.isOpen():</p> 
 <p>Receive_Window.insert("end", str(SerialPort.readline()) + '\n')</p> 
 <p>Receive_Window.see("end")</p> 
 <p>def Close_Serial():</p> 
 <p>SerialPort.close()</p> 
 <p>def Open_Serial():</p> 
 <p>if not SerialPort.isOpen():</p> 
 <p>SerialPort.port = Port_list.get()</p> 
 <p>SerialPort.baudrate = BaudRate_list.get()</p> 
 <p>SerialPort.timeout = 0.1</p> 
 <p>SerialPort.open()</p> 
 <p>if SerialPort.isOpen():</p> 
 <p>t = threading.Thread(target=ReceiveData)</p> 
 <p>t.setDaemon(True)</p> 
 <p>t.start()</p> 
 <p>else:</p> 
 <p>SerialPort.close()</p> 
 <p>tk.Button( switch, text = "开始采集", command = Open_Serial ).pack( side = "left", padx = 13 )</p> 
 <p>tk.Button( switch, text = "停止采集", command = Close_Serial ).pack( side = "right", padx = 13 )</p> 
 <p>GUI.mainloop()</p> 
 <p>在反复运行多次之后，我又发现了一些小毛病，接下来一一列举并改正：</p> 
 <p align="center">1. 在电脑未接入设备的时候，程序运行会报错无法运行：<img src="" alt=""></p> 
 <p>看到这个错误提示应该能立马想到是哪里了，问题正出在下面这几行：</p> 
 <p>ListPorts = list(serial.tools.list_ports.comports())</p> 
 <p>Port_list['values'] = [i[0] for i in ListPorts]</p> 
 <p>Port_list.current(0)</p> 
 <p>当电脑没接入任何设备的时候，ListPorts读回来的是一个空表，里边此时没有元素。因此当运行到Port_list.current(0)时，自然会报错，此时是个空表，怎么显示表中第一个元素？为了解决这个问题，我们需要加一个判断表是否为空的判断，来避免程序在未接入设备的时候无法运行。为了提醒使用者当前是否接入设备，我决定再加一个扫描端口按钮，用以检测是否有设备接入。扫描按钮触发的函数如下：</p> 
 <p>def scan_serial():</p> 
 <p>global ListPorts</p> 
 <p>ListPorts = list(serial.tools.list_ports.comports())</p> 
 <p>if ListPorts:</p> 
 <p>Information_Window.insert("end", '请选择端口' + '\n')</p> 
 <p>Information_Window.see("end")</p> 
 <p>Port_list['values'] = [i[0] for i in ListPorts]</p> 
 <p>Port_list.current(0)</p> 
 <p>else:</p> 
 <p>Port_list['values'] = [" "]</p> 
 <p>Port_list.current(0)</p> 
 <p>Information_Window.insert("end", '无可用端口' + '\n')</p> 
 <p>Information_Window.see("end")</p> 
 <p align="center">这样在电脑未接入设备的时候程序便可以运行，运行效果如下：<img src="" alt=""></p> 
 <p align="center">此时按一下扫描端口按钮，操作信息窗口便会显示“无可用端口”，同时串口号后面为空白。当接入设备后再按下扫描端口，此时串口号后面便可以出现当前所有设备的端口号，接下来选择正确的端口号后，按下开始采集便可开始采集数据，这个问题便解决了！效果如下：<img src="" alt=""><img src="" alt=""></p> 
 <p align="center">2. 解决了上一个问题之后，我又手残反复运行了几次，又发现了个问题。操作信息窗口和接收区窗口由于使用的默认参数，导致它俩变成了可以外部输入的文本框。没错，鼠标一点便会有光标出现，你可以直接输入任何内容，即使接收区正在采集数据你也可以直接鼠标点击，出现光标之后就可以插入任何内容了。不仅如此，你还可以直接删除窗口里的任何内容。问题如下：<img src="" alt=""></p> 
 <p align="center">我需要把这两个窗口设置为只读属性，不允许外部修改。这样一来便可以解决问题。查一下Text的选项参数表，找到了这个设置：<img src="" alt=""></p> 
 <p>没错，将这两个窗口的state属性设置为DISABLED即可。但是注意后面，设置为DISABLED时，无法修改里面内容，意思就是此时你程序也无法向里边插入内容，这两个窗口会一直保持空白，无论外部或是程序输入任何内容都没反应。所以，应对的办法就是程序需要插入内容时将窗口属性改为NORMAL，其余时间始终保持DISABLED属性！然而强迫症的我紧接着发现窗口在插入内容的时候会有光标在那里闪闪闪，关不掉看着很难受。思考了几秒钟之后，我把光标颜色改成了白色，这样窗口就干净了。使用了insertbackground这个参数设置。写法如下：</p> 
 <p>Information_Window.configure(insertbackground='white') # 操作信息窗口光标颜色设为白色</p> 
 <p>Information_Window.configure(state='disabled') # 操作信息窗口属性设为disabled</p> 
 <p>Information_Window.configure(state='normal') # 操作信息窗口属性设为normal</p> 
 <p>Receive_Window.configure(insertbackground='white')</p> 
 <p>Receive_Window.configure(state='disabled')</p> 
 <p>Receive_Window.configure(state='normal')</p> 
 <p>解决了以上两个问题后，串口助手的功能和界面得到了进一步完善。于是我便在此基础上进行实际GUI的改造。</p> 
 <p>实际GUI的要求如下：</p> 
 <p>1. 采集卡共有八个通道，需要有八个窗口来分开显示采集的数据</p> 
 <p>2. 不需要向设备发送的功能，只需可以采集数据即可</p> 
 <p>这样一来我的布局便需要大改了，我大概设计了一下布局。</p> 
 <p>经过简单的修改代码后，我将布局成功的实现了出来。</p> 
 <p>接下来只需要解决接收数据这一块即可完成任务。采集卡使用Modbus协议的RTU方式传输数据，在查阅了Modbus协议的基础知识和使用专用的测试工具后，我们了解了采集卡的数据帧格式，弄明白通道地址和返回数据格式后，我们选择了Python里的MinimalModbus这个库，通过依次读取八个通道的数据，在前面加上时间戳并将其转换格式显示在各自的窗口后，我们最终实现了GUI的要求的全部功能。</p> 
 <p>时间怎么加呢，很简单，一句代码就可以解决：</p> 
 <p>time.strftime("%H:%M:%S&gt;&gt;", time.localtime())</p> 
 <p>当然还可以显示年月日等其他内容，只是我的窗口显示不下了就没加了。</p> 
 <p>至此，GUI所有功能全部实现！</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2722b5ad43152bcec7ce83534e8b01eb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">bios uefi legacy_戴尔电脑新BIOS关闭UEFI，开启legacy</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d868cbd7e6f8011e85bff3c56c4dd259/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用 tc netem 模拟网络异常</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>