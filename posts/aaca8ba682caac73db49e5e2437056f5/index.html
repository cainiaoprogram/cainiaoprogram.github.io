<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数据结构】串的基本操作及应用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数据结构】串的基本操作及应用" />
<meta property="og:description" content="分别定义两个结构体——串的定长顺序存储、串的堆式顺序存储
typedef struct { char ch[MAXSTRLEN&#43;1]; int length; }SString; typedef struct { char *ch; int length; }HString; 问题：
1、编写函数，串用定长顺序存储表示来实现串的基本操作；
2、 编写串的匹配算法，实现查找功能。
算法思想阐述：
BF算法：首先S[1]和T[1]比较，若相等，则再比较S[2]和T[2]，一直到T[M]为止；若S[1]和T[1]不等，则S向右移动一个字符的位置，再依次进行比较。如果存在k，1≤k≤N，且S[k&#43;1…k&#43;M]=T[1…M]，则匹配成功；否则失败。
该算法最坏情况下要进行M*(N-M&#43;1)次比较， 时间复杂度为O(M*N)。
一、各函数代码如下 解题一：
//生成串 Status StrAssign(SString &amp;S,char chars[]) { int i;	S[0]=strlen(chars); for(i=0;chars[i]!=&#39;\0&#39;&amp;&amp;i&#43;1&lt;MAXSTRLEN;i&#43;&#43;){ S[i&#43;1]=chars[i]; } S[i&#43;1]=&#39;\0&#39;; return OK; } //输出串 void PrintStr(SString S) { int i; for(i=1;i&lt;S[0]&#43;1;i&#43;&#43;){ cout&lt;&lt;S[i]; } cout&lt;&lt;endl; } //求串长 Status StrLength(SString S) { return S[0]; } //判空 Status StrEmpty(SString S) { if(S[0]==0){ return OK; } else{ return FALSE; } } //比较字符串 Status StrCompare(SString S,SString T) { int i=0; for(i=0;i&lt;S[0]&amp;&amp;i&lt;T[0];i&#43;&#43;){ if(S[i]!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/aaca8ba682caac73db49e5e2437056f5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-27T10:06:33+08:00" />
<meta property="article:modified_time" content="2022-08-27T10:06:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数据结构】串的基本操作及应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>分别定义两个结构体——串的定长顺序存储、串的堆式顺序存储</strong></p> 
</blockquote> 
<pre><code class="language-cpp">typedef struct
{
	char ch[MAXSTRLEN+1];
	int length;
}SString;</code></pre> 
<pre><code class="language-cpp">typedef struct
{
	char *ch;
	int length;
}HString;</code></pre> 
<p> </p> 
<p></p> 
<p><strong>问题：</strong></p> 
<p><strong>1、编写函数，串用定长顺序存储表示来实现串的基本操作；</strong></p> 
<p><strong>2、 编写串的匹配算法，实现查找功能。</strong></p> 
<p></p> 
<blockquote> 
 <p>算法思想阐述：</p> 
 <p style="margin-left:0;text-align:justify;"><strong>BF</strong><strong>算法：首先S[1]</strong><strong>和T[1]</strong><strong>比较，若相等，则再比较S[2]</strong><strong>和T[2]</strong><strong>，一直到T[M]</strong><strong>为止；若S[1]</strong><strong>和T[1]</strong><strong>不等，则S</strong><strong>向右移动一个字符的位置，再依次进行比较。如果存在k</strong><strong>，1≤k≤N</strong><strong>，且S[k+1…k+M]=T[1…M]</strong><strong>，则匹配成功；否则失败。</strong></p> 
 <p style="margin-left:0;text-align:justify;"><strong>该算法最坏情况下要进行M*(N-M+1)</strong><strong>次比较， </strong><a href="https://baike.sogou.com/lemma/ShowInnerLink.htm?lemmaId=105680" rel="nofollow" title="时间复杂度">时间复杂度</a><strong>为O(M*N)</strong><strong>。</strong></p> 
</blockquote> 
<p> </p> 
<blockquote> 
 <p><strong>一、各函数代码如下  </strong></p> 
</blockquote> 
<blockquote> 
 <p>  解题一：</p> 
</blockquote> 
<pre><code class="language-cpp">//生成串 
Status StrAssign(SString &amp;S,char chars[])
{
	int i;	
	S[0]=strlen(chars);
	for(i=0;chars[i]!='\0'&amp;&amp;i+1&lt;MAXSTRLEN;i++){
		S[i+1]=chars[i]; 
	}
	S[i+1]='\0';
	return OK; 
}</code></pre> 
<pre><code class="language-cpp">//输出串
void PrintStr(SString S)
{
	int i;
	for(i=1;i&lt;S[0]+1;i++){
		cout&lt;&lt;S[i];
	}
	cout&lt;&lt;endl;
}</code></pre> 
<pre><code class="language-cpp">//求串长
Status StrLength(SString S)
{
 	return S[0];
}</code></pre> 
<pre><code class="language-cpp">//判空
Status StrEmpty(SString S)
{
	if(S[0]==0){
		return OK;
	}
	else{
		return FALSE;
	}
}</code></pre> 
<pre><code class="language-cpp">//比较字符串
Status StrCompare(SString S,SString T)
{
 	int i=0;
 	for(i=0;i&lt;S[0]&amp;&amp;i&lt;T[0];i++){
 		if(S[i]!=T[i])
 		    return S[i]-T[i];
	 }
	return S[0]-T[0];
}</code></pre> 
<pre><code class="language-cpp">//字符串连接:用T返回由S1和S2连接成的新串 
Status Concat(SString &amp;T,SString S1,SString S2)
{
 	int i,j;
 	if(S1[0]+S2[0]&lt;=MAXSTRLEN){
 		//未超出用户定义的最大串长
		 for(i=1;S1[i]!='\0';i++){
		 	T[i]=S1[i];
		 } 
		 for(j=1;S2[j]!='\0';j++){
		 	T[S1[0]+j]=S2[j];
		 }
		 //两次循环连接两串
		 T[S1[0]+j+1]='\0';
		 T[0]=S1[0]+S2[0]; 	 
	 }
	 else if(S1[0]&lt;MAXSTRLEN){
	 	//超出用户定义的最大串长,这里会出现截断情况 
	 	for(i=1;S1[i]!='\0';i++){
		 	T[i]=S1[i];
		 } 
		for(j=1;j&lt;=MAXSTRLEN-S1[0];i++){
			T[S1[0]+j]=S2[j];
			
		}
		  T[0]=MAXSTRLEN;
	 }
	 else{
	 	//条件是S1[0]&gt;MAXSTRLEN,这里仅截断S1
		 for(i=1;S1[i]!='\0';i++){
		 	T[i]=S1[i];
		 }
		 T[i+1]='\0';
		 T[0]=S1[0]; 
	 }
	 return OK;	
}</code></pre> 
<pre><code class="language-cpp">//取子串:用Sub返回串S的第pos个字符起长度为len的子串 
//注意：1&lt;=pos&lt;=StrLength(S),0&lt;=len&lt;=StrLength(S)-pos+1 
Status SubString(SString &amp;Sub,SString S,int pos,int len)
{
 	int i,j;
 	if(pos&lt;1||pos&gt;S[0]||len&lt;0||len&gt;S[0]-pos+1){
 		return ERROR;
	 }
	for(i=1,j=pos;i&lt;=len&amp;&amp;j&lt;=pos+len-1;i++,j++){
		Sub[i]=S[j];
	}
	Sub[i+1]='\0';
	Sub[0]=len;
	return OK;
}</code></pre> 
<pre><code class="language-cpp">//串的模式匹配：返回子串T(非空)在主串中第pos个字符之后的位置。若不存在，则返回0 
Status Index(SString S,SString T,int pos)
{
	int i=pos;
	int j=1;
	while(i&lt;=S[0]&amp;&amp;j&lt;=T[0]){
		if(S[i]==T[j]){
			++i;
			++j;
		}else{
			i=i-j+2;
			j=1;
		}
	}
	if(j&gt;T[0]){
		return i-T[0];
	} 
	else return FALSE;
}</code></pre> 
<pre><code class="language-cpp">//串插入
Status StrInsert(SString&amp; S, int pos, SString T)
{
	int i;
	if (StrEmpty(T))
	return ERROR;
	if (pos&lt;1||pos&gt;S[0]+1)
		return ERROR;
	else
	{
		for (i=S[0]-1;i&gt;=pos-1;i--)
			S[i+T[0]]=S[i];

		for (i=0;i&lt;T[0];i++)
			S[pos+i-1]=T[i];

		S[0] += T[0];
	}
	return OK;
}</code></pre> 
<pre><code class="language-cpp">//删除：删除串S指定的位置开始的长度为len的子串
Status StrDelete(SString &amp;S,int pos,int len)
{
	int i;
	if(pos&lt;1||len&gt;S[0]-pos+1){
		return ERROR;
	}
	for(i=pos+len;i&lt;=S[0];i++){
		S[i-len]=S[i];
	}
	S[0]-=len;
	return OK;
}</code></pre> 
<pre><code class="language-cpp">//串替换
Status Replace(SString	&amp;S, SString T, SString V)//最终以S返回 
{
	int i;
	if (StrEmpty(T))
		return ERROR;
	i = Index(S, T, 1);
	while (i != 0)
	{
		StrDelete(S, i, StrLength(T));
		StrInsert(S, i, V);
		i += StrLength(V);
		i = Index(S, T, i);
	}
	return OK;
}</code></pre> 
<pre><code class="language-cpp">//清空串
Status ClearString(SString &amp;S)
{
	int i;
	for(i=1;S[i]!='\0';i++){
		S[i]='\0';
	}
	S[0]=0;
	return OK;
}</code></pre> 
<p></p> 
<blockquote> 
 <p><strong>解题一完整代码： </strong></p> 
</blockquote> 
<pre><code class="language-cpp">#include &lt;iostream.h&gt;
#include &lt;string.h&gt;
#define OK 1
#define ERROR 1
#define FALSE 0
#define MAXSTRLEN 255
typedef int Status;
typedef unsigned char SString[MAXSTRLEN+1];//0号单元存放串的长度 
using namespace std;
/*********以下是各类函数的实现*********/ 
//初始化:0号单元存放串的长度 
Status InitStr(SString &amp;S)
{
	S[0]=0; 
	return OK;
} 
//生成串 
Status StrAssign(SString &amp;S,char chars[])
{
	int i;	
	S[0]=strlen(chars);
	for(i=0;chars[i]!='\0'&amp;&amp;i+1&lt;MAXSTRLEN;i++){
		S[i+1]=chars[i]; 
	}
	S[i+1]='\0';
	return OK; 
 } 
//输出串
void PrintStr(SString S)
{
	int i;
	for(i=1;i&lt;S[0]+1;i++){
		cout&lt;&lt;S[i];
	}
	cout&lt;&lt;endl;
 } 
 //求串长
Status StrLength(SString S)
{
 	return S[0];
} 
//判空
Status StrEmpty(SString S)
{
	if(S[0]==0){
		return OK;
	}
	else{
		return FALSE;
	}
} 
 //比较字符串
Status StrCompare(SString S,SString T)
{
 	int i=0;
 	for(i=0;i&lt;S[0]&amp;&amp;i&lt;T[0];i++){
 		if(S[i]!=T[i])
 		    return S[i]-T[i];
	 }
	return S[0]-T[0];
} 
 //字符串连接:用T返回由S1和S2连接成的新串 
Status Concat(SString &amp;T,SString S1,SString S2)
{
 	int i,j;
 	if(S1[0]+S2[0]&lt;=MAXSTRLEN){
 		//未超出用户定义的最大串长
		 for(i=1;S1[i]!='\0';i++){
		 	T[i]=S1[i];
		 } 
		 for(j=1;S2[j]!='\0';j++){
		 	T[S1[0]+j]=S2[j];
		 }
		 //两次循环连接两串
		 T[S1[0]+j+1]='\0';
		 T[0]=S1[0]+S2[0]; 	 
	 }
	 else if(S1[0]&lt;MAXSTRLEN){
	 	//超出用户定义的最大串长,这里会出现截断情况 
	 	for(i=1;S1[i]!='\0';i++){
		 	T[i]=S1[i];
		 } 
		for(j=1;j&lt;=MAXSTRLEN-S1[0];i++){
			T[S1[0]+j]=S2[j];
			
		}
		  T[0]=MAXSTRLEN;
	 }
	 else{
	 	//条件是S1[0]&gt;MAXSTRLEN,这里仅截断S1
		 for(i=1;S1[i]!='\0';i++){
		 	T[i]=S1[i];
		 }
		 T[i+1]='\0';
		 T[0]=S1[0]; 
	 }
	 return OK;	
} 
 //取子串:用Sub返回串S的第pos个字符起长度为len的子串 
 //注意：1&lt;=pos&lt;=StrLength(S),0&lt;=len&lt;=StrLength(S)-pos+1 
Status SubString(SString &amp;Sub,SString S,int pos,int len)
{
 	int i,j;
 	if(pos&lt;1||pos&gt;S[0]||len&lt;0||len&gt;S[0]-pos+1){
 		return ERROR;
	 }
	for(i=1,j=pos;i&lt;=len&amp;&amp;j&lt;=pos+len-1;i++,j++){
		Sub[i]=S[j];
	}
	Sub[i+1]='\0';
	Sub[0]=len;
	return OK;
} 
//串的模式匹配：返回子串T(非空)在主串中第pos个字符之后的位置。若不存在，则返回0 
Status Index(SString S,SString T,int pos)
{
	int i=pos;
	int j=1;
	while(i&lt;=S[0]&amp;&amp;j&lt;=T[0]){
		if(S[i]==T[j]){
			++i;
			++j;
		}else{
			i=i-j+2;
			j=1;
		}
	}
	if(j&gt;T[0]){
		return i-T[0];
	} 
	else return FALSE;
 }

//串插入
Status StrInsert(SString&amp; S, int pos, SString T)
{
	int i;
	if (StrEmpty(T))
	return ERROR;
	if (pos&lt;1||pos&gt;S[0]+1)
		return ERROR;
	else
	{
		for (i=S[0]-1;i&gt;=pos-1;i--)
			S[i+T[0]]=S[i];

		for (i=0;i&lt;T[0];i++)
			S[pos+i-1]=T[i];

		S[0] += T[0];
	}
	return OK;
}

//删除：删除串S指定的位置开始的长度为len的子串
Status StrDelete(SString &amp;S,int pos,int len)
{
	int i;
	if(pos&lt;1||len&gt;S[0]-pos+1){
		return ERROR;
	}
	for(i=pos+len;i&lt;=S[0];i++){
		S[i-len]=S[i];
	}
	S[0]-=len;
	return OK;
}

//串替换
Status Replace(SString	&amp;S, SString T, SString V)//最终以S返回 
{
	int i;
	if (StrEmpty(T))
		return ERROR;
	i = Index(S, T, 1);
	while (i != 0)
	{
		StrDelete(S, i, StrLength(T));
		StrInsert(S, i, V);
		i += StrLength(V);
		i = Index(S, T, i);
	}
	return OK;
}

//清空串
Status ClearString(SString &amp;S)
{
	int i;
	for(i=1;S[i]!='\0';i++){
		S[i]='\0';
	}
	S[0]=0;
	return OK;
 } 
//主函数 
int main(int argc, char *argv[])
{
	SString S1,S2,T,Sub,Rep; 
 	int len1,len2,cha,pos,len;
 	InitStr(T);
 	InitStr(Sub);
 	InitStr(Rep);
 	char s1[100];
 	char s2[100];
 	//避免s1.length+s2.length&gt;MAXSTRLEN
 	cout&lt;&lt;"请输入字符串1:"&lt;&lt;endl;
    scanf("%s",s1);
 	StrAssign(S1,s1);
    //PrintStr(S1);
	cout&lt;&lt;"请输入字符串2:"&lt;&lt;endl;
    scanf("%s",s2);
	StrAssign(S2,s2);
	cout&lt;&lt;"1.字符串长度  ";
	cout&lt;&lt;"2.比较字符串  ";
	cout&lt;&lt;"3.取子串  ";
	cout&lt;&lt;"4.匹配模式  " ;
	cout&lt;&lt;"5.连接字符串  ";
	cout&lt;&lt;endl&lt;&lt;"6.字符串的插入  ";
	cout&lt;&lt;"7.字符串的替换  ";
	cout&lt;&lt;"8.删除子字符串  ";
	cout&lt;&lt;"9.清空字符串  "; 
	cout&lt;&lt;"10.退出程序"&lt;&lt;endl;
	int select;
	while(true){
		cout&lt;&lt;"请选择你想要的功能；"&lt;&lt;endl;
		cin&gt;&gt;select;
		switch(select){
		case 1:
			printf("串1的长度是：%d\n",StrLength(S1));
			printf("串2的长度是：%d\n",StrLength(S2));
		    break;
	    case 2:
	    	cha=StrCompare(S1,S2);
	    	cout&lt;&lt;"两串比较的结果是：";
	    	if(cha&gt;0){
	    		cout&lt;&lt;"S1&gt;S2"&lt;&lt;endl; 
			}else if(cha&lt;0){
				cout&lt;&lt;"S1&lt;S2"&lt;&lt;endl;
			}else cout&lt;&lt;"S1=S2"&lt;&lt;endl;
		   	break;
		case 3:
			int a;
			cout&lt;&lt;"请问想对哪个字符串进行取子串操作？(回复1或2)"&lt;&lt;endl;
			cin&gt;&gt;a;
			if(a==1){
				cout&lt;&lt;"输入你想取的S1的子串具体位置和长度：";
				cin&gt;&gt;pos&gt;&gt;len;
				if(SubString(Sub,S1,pos,len)){
				  cout&lt;&lt;"串1的第"&lt;&lt;pos&lt;&lt;"个位置开始长度为"&lt;&lt;len&lt;&lt;"的子串Sub为: ";
				  	PrintStr(Sub);
				}
				else{
					cout&lt;&lt;"查找子串失败！"&lt;&lt;endl;
				}
			   	break;
			}
			if(a==2){
				cout&lt;&lt;"输入你想取的S2的子串具体位置和长度：";
				cin&gt;&gt;pos&gt;&gt;len;
				if(SubString(Sub,S2,pos,len)){
				  cout&lt;&lt;"串2的第"&lt;&lt;pos&lt;&lt;"个位置开始长度为"&lt;&lt;len&lt;&lt;"的子串Sub为: ";
				  	PrintStr(Sub);
				}
				else{
					cout&lt;&lt;"查找子串失败！"&lt;&lt;endl;
				}
			   	break;
			}
			else{
				cout&lt;&lt;"输入错误！查找字串失败！"&lt;&lt;endl;
				break;
			}
		case 4:
			cout&lt;&lt;"请输入匹配的pos位置：";
			cin&gt;&gt;pos;
			if(Index(S1,S2,pos)){
				cout&lt;&lt;"串2在串1中位置是:"&lt;&lt;Index(S1,S2,pos)&lt;&lt;endl; 
			}else cout&lt;&lt;"匹配失败！"&lt;&lt;endl;
		
		   	break;
		case 5:
			Concat(T,S1,S2);
		    cout&lt;&lt;"串1和串2连接后的串为：";
			PrintStr(T);
		   	break;
  		case 6:
  			cout&lt;&lt;"欲实现串2对串1的插入！请输入插入的pos位置：";
			cin&gt;&gt;pos;
			if(StrInsert(S1,pos,S2)){
				PrintStr(S1);
				break;
			}
		case 7:
			Replace(Rep,S1,S2);
			cout&lt;&lt;"替换成功！";
			break;
  		case 8:
  			cout&lt;&lt;"请问想对哪个字符串进行删除操作？(回复1或2)"&lt;&lt;endl;
  			cin&gt;&gt;a;
  			if(a==1){
			  	cout&lt;&lt;"请输入对S1删除的pos位置和长度：";
				cin&gt;&gt;pos&gt;&gt;len;
				if(StrDelete(S1,pos,len)){
					PrintStr(S1);
				}
				else{
					cout&lt;&lt;"删除失败！"&lt;&lt;endl;
				}
				break;
		  	}
  			if(a==2){
			  	cout&lt;&lt;"请输入对S2删除的pos位置和长度：";
				cin&gt;&gt;pos&gt;&gt;len;
				if(StrDelete(S2,pos,len)){
					PrintStr(S2);
				}
				else{
					cout&lt;&lt;"删除失败！"&lt;&lt;endl;
				}
				break;
		  	}
		  	else{
	  			cout&lt;&lt;"输入错误！删除失败！"&lt;&lt;endl;
	  			break;
	  		}
		case 9:
  			cout&lt;&lt;"请问想对哪个字符串进行清空操作？(回复1或2)"&lt;&lt;endl;
  			cin&gt;&gt;a;
  			if(a==1){
  				if(ClearString(S1))	cout&lt;&lt;"已清空串1！"&lt;&lt;endl;
  				break;
  			}
  			if(a==2){
  				if(ClearString(S2))	cout&lt;&lt;"已清空串2！"&lt;&lt;endl;
  				break;
  			}
			else{
				cout&lt;&lt;"输入错误！清空失败！"&lt;&lt;endl;
	  			break;
			}	
		case 10:
		    cout&lt;&lt;"退出程序！";
		    exit(0);
		   	break;
	 	}
	}
}</code></pre> 
<p> 执行效果：</p> 
<p style="text-align:center;"><img alt="" class="left" src="https://images2.imgbox.com/53/06/xcPWoRB9_o.png"></p> 
<p></p> 
<p></p> 
<blockquote> 
 <p>解题二（在题一基础上稍加修改即可）</p> 
</blockquote> 
<pre><code class="language-cpp">/*用回溯法来实现模式匹配算法，寻找模式串t在主串s中从第pos位开始是否出现，若出现则返回第一次出现的位置，否则返回0*/
int StrIndex1(SString s,SString t,int pos)
{
	int s, t, i,j;
	s = S.length;
	t = T.length;
	i = pos;
	 j = 1;

    while(i&lt;=S.length &amp;&amp; j&lt;=T.length)
    {
        if(S.ch[i]==T.ch[j]){
            ++i;++j;}
            else{
                i=i-j+2;j=1;}
                
    }
    if(j&gt;T.length) return i-T.length;
    else return 0;
}</code></pre> 
<pre><code class="language-cpp">/*利用其他函数来实现模式匹配算法*/
int StrIndex2(SString s,SString t,int pos)
{
	int m,n,i;
	SString sub;
	n=StrLength(s);
	m=StrLength(t);
	i=pos;
	while(i&lt;=n-m+1)
	{
		SubString(sub,s,i,m);
		if(StrCompare(sub,t)!=0) ++i;
		else return i;
	}
	return 0;
}</code></pre> 
<p></p> 
<pre><code class="language-cpp">/*用KMP算法来实现模式匹配算法，效率较高*/
int StrIndex_KMP(SString s,SString t,int pos)
{
	int i,j;
	int next[MAX+1];
	i=1;
	next[i]=0;
	j=0;
	while(i&lt;t[0])
	{
		if(j==0||t[i]==t[j])
		{
			i++;
			j++;
			if(t[i]!=t[j]) next[i]=j;
			else next[i]=next[j];
		}
		else j=next[j];
	}


	i=pos;
	j=1;
	while(i&lt;=s[0]&amp;&amp;j&lt;=t[0])
	{
		if(j==0 || s[i]==t[j])
		{
			i++;
			j++;
		}
		else
			j=next[j];
	}
	if(j&gt;t[0])return i-t[0];
	else return 0;
}</code></pre> 
<p> 执行效果：</p> 
<p style="text-align:center;"><img alt="" class="left" src="https://images2.imgbox.com/eb/33/xjQmDH1r_o.png"></p> 
<p></p> 
<p></p> 
<p></p> 
<p><span style="color:#9c8ec1;">分享完毕~</span></p> 
<p><span style="color:#9c8ec1;">欢迎小伙伴们在文下评论和私信喔~</span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a826a9b76c0a590e85ec30cdc9a67c07/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JDK是什么？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d44504a4e52f9498a319a6927cd6a980/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【数据结构】二叉树的基本操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>