<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据库概论学习笔记——关系数据理论 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据库概论学习笔记——关系数据理论" />
<meta property="og:description" content="属性间的联系 1.一对一联系
2.一对多联系
3.多对多联系
数据依赖 是一个关系内部属性与属性之间的一种约束关系
是现实世界属性间相互联系的抽象
是数据内在的性质 是语义的体现
1.函数依赖
2.多值依赖
例：描述一个学生关系，可以有学号、姓名、系名等属性。
一个学号只对应一个学生，一个学生只在一个系中学习 “学号”值确定后，学生的姓名及所在系的值就被唯一确定。
现给出一个关系模式找出其问题：
U ＝{Sno, Sdept, Mname, Cno, Grade}
F={Sno→Sdept, Sdept→ Mname, (Sno, Cno)→ Grade}
（1）数据冗余
（2）更新异常
（3）插入异常
（4）删除异常
把这个单一的模式分成三个关系模式：
S(Sno,Sdept,Sno → Sdept);
SC(Sno,Cno,Grade,(Sno,Cno) → Grade);
DEPT(Sdept,Mname,Sdept → Mname);
这三个模式都不会发生插入异常、删除异常的问题，数据的冗余也得到了控制。
平凡函数依赖与非平凡函数依赖 X→Y，但Y⊈X则称X→Y是非平凡的函数依赖。
X→Y，但Y⊆X 则称X→Y是平凡的函数依赖。
例：在关系SC(Sno, Cno, Grade)中， 非平凡函数依赖： (Sno, Cno) → Grade 平凡函数依赖： (Sno, Cno) → Sno (Sno, Cno) → Cno
完全函数依赖与部分函数依赖 在关系SC(Sno, Cno, Grade)中，有： 由于：Sno ↛Grade，Cno ↛ Grade， 因此：(Sno, Cno) → Grade (Sno,Cno)→Sdept是部分函数依赖 因为Sno →Sdept成立，且Sno是（Sno，Cno）的真子集" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d4cc20644d7ef7cc5e85afcb49c18720/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-11T16:58:36+08:00" />
<meta property="article:modified_time" content="2018-11-11T16:58:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据库概论学习笔记——关系数据理论</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>属性间的联系</h3> 
<p>1.一对一联系</p> 
<p>2.一对多联系</p> 
<p>3.多对多联系</p> 
<h3>数据依赖</h3> 
<p>是一个关系内部属性与属性之间的一种约束关系</p> 
<p>是现实世界属性间相互联系的抽象</p> 
<p>是数据内在的性质 是语义的体现</p> 
<p>1.函数依赖</p> 
<p>2.多值依赖</p> 
<p>例：描述一个学生关系，可以有学号、姓名、系名等属性。</p> 
<p>一个学号只对应一个学生，一个学生只在一个系中学习 “学号”值确定后，学生的姓名及所在系的值就被<span style="color:#f33b45;">唯一确定</span>。</p> 
<p>现给出一个关系模式找出其问题：</p> 
<p>U ＝{Sno, Sdept, Mname, Cno, Grade}</p> 
<p>F={Sno→Sdept, Sdept→ Mname, (Sno, Cno)→ Grade}</p> 
<p>（1）数据冗余</p> 
<p>（2）更新异常</p> 
<p>（3）插入异常</p> 
<p>（4）删除异常</p> 
<p>把这个单一的模式分成三个关系模式：</p> 
<p>S(Sno,Sdept,Sno → Sdept);</p> 
<p>SC(Sno,Cno,Grade,(Sno,Cno) → Grade);</p> 
<p>DEPT(Sdept,Mname,Sdept → Mname);</p> 
<p>这三个模式都不会发生插入异常、删除异常的问题，数据的冗余也得到了控制。</p> 
<h4>平凡函数依赖与非平凡函数依赖</h4> 
<p>X→Y，但Y⊈X则称X→Y是非平凡的函数依赖。</p> 
<p>X→Y，但Y⊆X 则称X→Y是平凡的函数依赖。</p> 
<p>例：在关系SC(Sno, Cno, Grade)中，            </p> 
<p>                                                       非平凡函数依赖： (Sno, Cno) → Grade            </p> 
<p>                                                       平凡函数依赖：     (Sno, Cno) → Sno                                          </p> 
<p>                                                                                     (Sno, Cno) → Cno</p> 
<h4>完全函数依赖与部分函数依赖</h4> 
<p>在关系SC(Sno, Cno, Grade)中，有：  </p> 
<p>由于：Sno ↛Grade，Cno ↛ Grade，          </p> 
<p>因此：(Sno, Cno)  →   Grade  (Sno,Cno)→Sdept是部分函数依赖              </p> 
<p>因为Sno →Sdept成立，且Sno是（Sno，Cno）的真子集</p> 
<h4>传递函数依赖</h4> 
<p>在关系Std(Sno, Sdept, Mname)中，有：</p> 
<p>Sno → Sdept，Sdept → Mname， Mname传递函数依赖于Sno。</p> 
<h3>范式</h3> 
<p>第一范式(1NF)</p> 
<p>第二范式(2NF)</p> 
<p>第三范式(3NF)</p> 
<p>BC范式(BCNF)</p> 
<p>第四范式(4NF)</p> 
<p>第五范式(5NF)</p> 
<h4>2NF</h4> 
<p>若关系模式R∈1NF，并且每一个<span style="color:#f33b45;">非主属性</span>都<span style="color:#f33b45;">完全函数依赖</span>于<span style="color:#f33b45;">任何一个候选码</span>，则R∈2NF</p> 
<p>例：</p> 
<p>S-L-C(Sno,Sdept,Sloc,Cno,Grade)</p> 
<p>(Sno,Cno)→Grade，Sno→Sdept，</p> 
<p>(Sno,Cno)→Sdept，Sno→Sloc,</p> 
<p>(Sno,Cno)→Sloc，Sdept→Sloc</p> 
<p><strong>S-L-C的码为(Sno,Cno)</strong></p> 
<p><strong>S-L-C满足第一范式。 </strong></p> 
<p><strong>非主属性Sdept、Sloc并不完全依赖于码 </strong></p> 
<p><strong>关系模式S-L-C不属于2NF</strong></p> 
<p>产生问题：</p> 
<p>                  插入异常</p> 
<p>                  删除异常</p> 
<p>                  修改复杂</p> 
<h4>3NF</h4> 
<p>设关系模式R&lt;U,F&gt;∈1NF,若R中不存在这样的码X、属性组Y及非主属性Z（Z ⊇ Y）, 使得X→Y，Y→Z成立，Y ↛ X不成立，则称R&lt;U,F&gt; ∈ 3NF。</p> 
<p>例：2NF关系模式S-L(Sno, Sdept, Sloc)中 函数依赖：          </p> 
<p>Sno→Sdept          </p> 
<p>Sdept → Sno          </p> 
<p>Sdept→Sloc          </p> 
<p>可得：Sno→Sloc，即S-L中存在非主属性对码的传递函数依赖，S-L 不属于3NF</p> 
<h4>BCNF</h4> 
<p>设关系模式R&lt;U,F&gt;∈1NF，若X →Y且Y 不含于 X时X必含有码，则R&lt;U,F&gt;∈BCNF。</p> 
<p>换言之，在关系模式R&lt;U,F&gt;中，如果<span style="color:#f33b45;">每一个决定属性集</span>都<span style="color:#f33b45;">包含候选码</span>，则R∈BCNF。</p> 
<p>例子：关系模式SJP(S,J,P)中，S是学生，J表示课程，P表示名次。</p> 
<p>           每一个学生选修每门课程的成绩有一定的名次，每门课程中每一名次只有一 个学生（即没有并列名次）。</p> 
<p>由语义可得到函数依赖：</p> 
<p>    (S,J)→P；(J,P)→S</p> 
<p>    (S,J)与(J,P)都可以作为候选码。</p> 
<p>   关系模式中没有属性对码传递依赖或部分依赖，所以SJP∈3NF。</p> 
<h4>4NF</h4> 
<p>不允许有非平凡且非函数依赖的多值依赖。 允许的非平凡多值依赖实际上是函数依赖。</p> 
<h4>规范化小结</h4> 
<p><img alt="" class="has" height="405" src="https://images2.imgbox.com/fa/24/omNGVlb5_o.png" width="573"></p> 
<h3>数据依赖的公理系统</h3> 
<h4>闭包</h4> 
<p>在关系模式R&lt;U,F&gt;中为F所逻辑蕴涵的函数依赖的全体叫作<span style="color:#f33b45;">F的闭包</span>，记为F +。</p> 
<p>设F为属性集U上的一组函数依赖，X、Y 属于U， XF+={ A|X→A能由F根据Armstrong公理导出}，XF+  称为属性集<span style="color:#f33b45;">X关于函数依赖集F的闭包。</span></p> 
<p>例：已知关系模式R&lt;U, F&gt;，其中U={A, B, C, D, E}；F={AB→C, B→D, C→E, EC→B, AC→B}。     </p> 
<p>求(AB)F+ 。</p> 
<p>AB→C，B→D</p> 
<p>得出ABCD</p> 
<p>C→E，AC→B</p> 
<p>得出ABCDE</p> 
<p>所以闭包为ABCDE</p> 
<h3>模式的分解</h3> 
<p>若要求分解具有无损连接性，那么模式分解一定能够达到4NF。</p> 
<p>若要求分解保持函数依赖，那么模式分解一定能够达到3NF，但不一定能够达到BCNF。</p> 
<p>若要求分解既具有无损连接性，又保持函数依赖，则模式分解一定能够达到3NF，但不一定能够达到BCNF。</p> 
<p> </p> 
<p><img alt="" class="has" height="236" src="https://images2.imgbox.com/41/0c/d4RFSWPc_o.png" width="321"></p> 
<table border="0" cellpadding="0" cellspacing="0" style="width:639px;"><tbody><tr><td> <p> </p> </td><td> <p>A1</p> </td><td> <p>A2</p> </td><td> <p>…</p> </td><td> <p>An</p> </td></tr><tr><td> <p>U1</p> </td><td> <p> </p> </td><td> <p> </p> </td><td> <p> </p> </td><td> <p> </p> </td></tr><tr><td> <p>…</p> </td><td> <p> </p> </td><td> <p> </p> </td><td> <p>Cij</p> </td><td> <p> </p> </td></tr><tr><td> <p>Uk</p> </td><td> <p> </p> </td><td> <p> </p> </td><td> <p> </p> </td><td> <p> </p> </td></tr></tbody></table> 
<p> </p> 
<p><img alt="" class="has" height="270" src="https://images2.imgbox.com/36/05/cxpesxFr_o.png" width="419"></p> 
<p><img alt="" class="has" height="248" src="https://images2.imgbox.com/80/36/oeAgFbEk_o.png" width="415"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f8d76006ae42810e73f16083de74f7e0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用C&#43;&#43;11实现线程池的两种方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e868c3e9d6776d03d6457ebedaa872fb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PyCharm连接虚拟机oracle数据库</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>