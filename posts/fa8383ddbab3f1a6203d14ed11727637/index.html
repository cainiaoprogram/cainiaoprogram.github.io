<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TCP拥塞控制 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TCP拥塞控制" />
<meta property="og:description" content=" TCP拥塞控制 1.TCP拥塞控制概述 什么是网络拥塞
计算机网络中的带宽、交换结点中的缓存和处理机等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏。这种情况就叫做网络拥塞。
什么是拥塞控制
拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制。
2.TCP拥塞控制的原理 假定：
1.数据是单方向传送，而另一个方向只传送确认
2.为了关注拥塞控制以和流量控制形成对比，假设接收方总是有足够大的缓存空间。
3.以TCP报文段的个数为讨论问题的单位，而不是以字节为单位
在上面这三个假设的限制下，会有以下的结论
发送方维护一个称为拥塞窗口cwnd的状态变量，其值取决于网络的拥塞程度，并且动态变化。特别是，在一个发送方中未被确认的数据量不会超过cwnd与rwnd的最小值。因为在上面假设了接收方的接收缓存足够大，所以可以忽略接收窗口rwnd的限制，因此在发送方中未被确认的报文段仅受限于cwnd。
拥塞窗口cwnd的维护原则：只要网络没有出现拥塞，拥塞窗口就再增大一些，但只要网络出现拥塞，拥塞窗口就减少一些。判断出现网络拥塞的依据：当出现丢包事件时，也就是要么出现超时事件，要么收到三个冗余ACK（一个正常的ACK＋三个冗余的ACK），发送方就认为发送方到接收方的路径上出现了拥塞的指示 发送方将拥塞窗口作为发送窗口，即swnd = cwnd
维护一个慢启动阈值ssthresh状态变量：
当cwnd &lt; ssthresh时，使用慢启动算法； 当cwnd &gt; ssthresh时，停止使用慢启动算法而改用拥塞避免算法；当cwnd = ssthresh时，即可使用慢启动算法，也可使用拥塞避免算法。 慢启动算法和拥塞避免算法都是TCP的拥塞控制算法，接下来对这几种算法进行介绍
1.慢启动
在tcp双方建立逻辑连接关系时， 拥塞窗口cwnd的值被设置为1，还需设置慢启动阈值ssthresh，因此发送方当前只能发送一个数据报文段（拥塞窗口cwnd的值是几，就能发送几个数据报文段），接收方收到该数据报文段后，给发送方回复一个确认报文段，发送方收到该确认报文后，将拥塞窗口的值变为2，并继续这样下去。因此，TCP发送速率起始慢，但在慢启动阶段以指数增长。
2.拥塞避免算法
当cwnd &gt; ssthresh时，进入拥塞避免阶段，此时的拥塞窗口缓慢增加，每经过一个往返时间RTT，就把拥塞窗口加1，而不是成倍增加。因此在拥塞避免阶段就有“加法增大”的特点，拥塞窗口按线性规律缓慢增长。
如下图：
红色这一部分就是拥塞避免算法，每次拥塞窗口仅仅增加一个大小，当增加到一定大小时，就碰到了网络超时，即出现网络拥塞。
出现阻塞后调整
当出现阻塞之后，会调整慢启动阈值ssthresh以及拥塞窗口的值：
新的慢开始门限的值：ssthresh=cwnd/2。
如上图所示，此时cwnd已经增长到了24大小，所以此时ssthresh=24/2=12。
拥塞窗口则再次变为1
调整后的运行过程如下图所示：
如上图所示，当在24出现阻塞后，将cwnd变为了1，将ssthresh变为了12
然后在12之前依旧是进行慢开始算法，在12之后进行拥塞避免算法，直到16发生了3个ACK情况（这个后面讲）又一次出现了网络阻塞。
快重传&#43;快恢复
从上面可知，在16的时候又一次出现了拥塞，而这次拥塞出现的原因就是这3个ACK。这个也就是快重传。
快重传：当发生报文段丢失时，为了让发送方尽早知道发生了个别报文段的丢失，因此立即发送确认，怎样让发送方知道是哪个报文段丢失的方法就是连读发送三个确认。
如下图所示：
当丢失某个数据包时，连续发送三个确认，则发送方就知道某个包丢失了，然后立即启动快重传。
快恢复：发送方知道现在只是丢失了个别的报文段。于是不执行慢开始，而是执行快恢复算法。
新的慢开始门限的值：ssthresh=cwnd/2。
如上图所示，此时新的cwnd已经增长到了16大小，所以此时ssthresh=16/2=8。
拥塞窗口不是变为1，而是和门限值一样，此时cwnd=ssthresh=8，然后开始执行拥塞避免算法
如下图所示：
如上图是怎样判断出现了丢包现象，以及出现丢包情况下进行快恢复的流程。
注意：
无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢启动阈值设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢启动算法快速恢复是TCP推荐的而非必须的构件。一种称为 TC Tahoe 的TCP 早期版本，不管是发生超时指示的丢包事件，还是发生3个冗余 ACK 指示的丢包事件，都无条件地将其拥塞窗口减至 1个MSS，并进入慢启动阶段。TCP 的较新版本 TCP Reno , 则综合了快速恢复。 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fa8383ddbab3f1a6203d14ed11727637/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-09T20:22:45+08:00" />
<meta property="article:modified_time" content="2023-12-09T20:22:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TCP拥塞控制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>TCP拥塞控制</h2> 
<h3 style="background-color:transparent;">1.TCP拥塞控制概述</h3> 
<p><strong>什么是网络拥塞</strong></p> 
<p>        计算机网络中的带宽、交换结点中的缓存和处理机等，都是网络的资源。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏。这种情况就叫做网络拥塞。</p> 
<p><strong>什么是拥塞控制</strong></p> 
<p>拥塞控制就是防止过多的数据注入网络中，这样可以使网络中的路由器或链路不致过载。<strong>拥塞控制是一个全局性的过程，和流量控制不同，流量控制指点对点通信量的控制。</strong></p> 
<h3 style="background-color:transparent;"><strong>2.TCP拥塞控制的原理</strong></h3> 
<p><strong>假定</strong>：<br> 1.数据是单方向传送，而另一个方向只传送确认<br> 2.为了关注拥塞控制以和流量控制形成对比，假设接收方总是有足够大的缓存空间。<br> 3.以TCP报文段的个数为讨论问题的单位，而不是以字节为单位</p> 
<p>在上面这三个假设的限制下，会有以下的结论</p> 
<p class="img-center"><img alt="" height="147" src="https://images2.imgbox.com/dd/62/dlGEVTzB_o.png" width="600"></p> 
<p>        发送方维护一个称为拥塞窗口cwnd的状态变量，其值取决于网络的拥塞程度，并且动态变化。特别是，在一个发送方中未被确认的数据量不会超过cwnd与rwnd的最小值。因为在上面假设了接收方的接收缓存足够大，所以可以忽略接收窗口rwnd的限制，因此在发送方中未被确认的报文段仅受限于cwnd。</p> 
<ul><li>拥塞窗口cwnd的维护原则：只要网络没有出现拥塞，拥塞窗口就再增大一些，但只要网络出现拥塞，拥塞窗口就减少一些。</li><li>判断出现网络拥塞的依据：当出现丢包事件时，也就是要么出现超时事件，要么收到三个冗余ACK（一个正常的ACK＋三个冗余的ACK），发送方就认为发送方到接收方的路径上出现了拥塞的指示</li></ul> 
<p>发送方将拥塞窗口作为发送窗口，即swnd = cwnd</p> 
<p>维护一个慢启动阈值ssthresh状态变量：</p> 
<ul><li>当cwnd &lt; ssthresh时，使用慢启动算法； </li><li>当cwnd &gt; ssthresh时，停止使用慢启动算法而改用拥塞避免算法；</li><li>当cwnd = ssthresh时，即可使用慢启动算法，也可使用拥塞避免算法。</li></ul> 
<p>慢启动算法和拥塞避免算法都是TCP的拥塞控制算法，接下来对这几种算法进行介绍</p> 
<p><strong>1.慢启动</strong></p> 
<p>        在tcp双方建立逻辑连接关系时， 拥塞窗口cwnd的值被设置为1，还需设置慢启动阈值ssthresh，因此发送方当前只能发送一个数据报文段（拥塞窗口cwnd的值是几，就能发送几个数据报文段），接收方收到该数据报文段后，给发送方回复一个确认报文段，发送方收到该确认报文后，将拥塞窗口的值变为2，并继续这样下去。因此，TCP发送速率起始慢，但在慢启动阶段以指数增长。</p> 
<p class="img-center"><img alt="" height="300" src="https://images2.imgbox.com/f2/c5/tjCdm51J_o.png" width="279"></p> 
<p><strong>2.拥塞避免算法</strong></p> 
<p>当cwnd &gt; ssthresh时，进入拥塞避免阶段，此时的拥塞窗口缓慢增加，每经过一个往返时间RTT，就把拥塞窗口加1，而不是成倍增加。因此在拥塞避免阶段就有“<strong>加法增大</strong>”的特点，拥塞窗口按<strong>线性规律缓慢增长。</strong></p> 
<p>如下图：</p> 
<p class="img-center"><img alt="" height="316" src="https://images2.imgbox.com/24/15/qfgdvPOZ_o.png" width="500"></p> 
<p>红色这一部分就是拥塞避免算法，每次拥塞窗口仅仅增加一个大小，当增加到一定大小时，就碰到了网络超时，即出现网络拥塞。</p> 
<p><strong>出现阻塞后调整</strong></p> 
<p>当出现阻塞之后，会调整慢启动阈值ssthresh以及拥塞窗口的值：</p> 
<blockquote> 
 <p>新的慢开始门限的值：<strong>ssthresh=cwnd/2。</strong><br>         如上图所示，此时cwnd已经增长到了24大小，所以此时ssthresh=24/2=12。</p> 
 <p>拥塞窗口则再次变为1</p> 
</blockquote> 
<p>调整后的运行过程如下图所示：</p> 
<p class="img-center"><img alt="" height="309" src="https://images2.imgbox.com/f2/e9/PZ3xd1G2_o.png" width="500"></p> 
<p>如上图所示，当在24出现阻塞后，将cwnd变为了1，将ssthresh变为了12</p> 
<p>然后在12之前依旧是进行慢开始算法，在12之后进行拥塞避免算法，直到16发生了3个ACK情况（这个后面讲）又一次出现了网络阻塞。</p> 
<p>快重传+快恢复</p> 
<p>从上面可知，在16的时候又一次出现了拥塞，而这次拥塞出现的原因就是这3个ACK。这个也就是快重传。</p> 
<p><strong>快重传：</strong>当发生报文段丢失时，为了让发送方尽早知道发生了个别报文段的丢失，因此立即发送确认，怎样让发送方知道是哪个报文段丢失的方法就是连读发送三个确认。</p> 
<p><strong>如下图所示：</strong></p> 
<p class="img-center"><img alt="" height="364" src="https://images2.imgbox.com/4a/49/u7ZFD9wD_o.png" width="500"></p> 
<p>当丢失某个数据包时，连续发送三个确认，则发送方就知道某个包丢失了，然后立即启动快重传。</p> 
<p><strong>快恢复：</strong>发送方知道现在只是丢失了个别的报文段。于是不执行慢开始，而是执行快恢复算法。</p> 
<blockquote> 
 <p>新的慢开始门限的值：<strong>ssthresh=cwnd/2。</strong><br>         如上图所示，此时新的cwnd已经增长到了16大小，所以此时ssthresh=16/2=8。</p> 
 <p>拥塞窗口不是变为1，而是和门限值一样，此时cwnd=ssthresh=8，然后开始执行拥塞避免算法</p> 
</blockquote> 
<p>如下图所示：</p> 
<p class="img-center"><img alt="" height="312" src="https://images2.imgbox.com/6e/92/hlJT6IWd_o.png" width="500"></p> 
<p>如上图是怎样判断出现了丢包现象，以及出现丢包情况下进行快恢复的流程。</p> 
<blockquote> 
 <p><strong>注意：</strong></p> 
 <ul><li>无论是在<strong>慢开始阶段</strong>还是在<strong>拥塞避免阶段</strong>，只要发送方判断网络出现拥塞，就把慢启动阈值设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢启动算法</li><li>快速恢复是TCP推荐的而非必须的构件。一种称为 TC Tahoe 的TCP 早期版本，不管是发生超时指示的丢包事件，还是发生3个冗余 ACK 指示的丢包事件，都无条件地将其拥塞窗口减至 1个MSS，并进入慢启动阶段。TCP 的较新版本 TCP Reno , 则综合了快速恢复。</li></ul> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/255d9e7d27ce85e58f98d674e9fccea2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Amis Low Code 结合FastAPI进行前端框架开发】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f952fd6321479c4a06e1c24ba9d7592b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">子网划分（超详细）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>