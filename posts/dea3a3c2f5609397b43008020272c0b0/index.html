<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数位dp入门 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数位dp入门" />
<meta property="og:description" content="数位dp，一般的题意是要求把某个区间的符合某种特征的数的个数求出来，一般的思路就是把最大数按位分解，然后dfs依次判断每一位相应的数是否满足要求。 把以前做过的几道简单数位dp的题总结一下，可以作为入门题做做。 1. hdu 2089 不要62 题意：给定一个区间[a,b]，问在这个区间中的数字，不包含4和62的数有多少个？
分析：数据范围小于1e6，如果暴力的话，再加上分解因数，预处理的时间复杂度数量级最大1e7，查询O(1)。 用数位dp的做法：
#include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;cstring&gt; using namespace std; int f[8][2],bit[8]; /* f[i][j]:i是位数 j==0，尾位不是6 j==1，尾位是6 */ int dfs(int pos,bool six,bool lim)//位数，尾位是否是6，是否是上限 { if(pos&lt;=0)return 1; if(!lim&amp;&amp;f[pos][six]!=-1)return f[pos][six]; int num=lim?bit[pos]:9; //假设该位是2,下一位是3，如果现在算到该位为1，那么lim=0，表示下一位是能取到9的， //如果该位为2，那么lim=1，下一位只能取到3 int ans=0; for(int i=0;i&lt;=num;i&#43;&#43;){ if(i==4||six&amp;&amp;i==2)continue;//如果再加一位是4，或者尾位是6再加一位是2，那么都是不合法的状态，跳过。 ans&#43;=dfs(pos-1,i==6,lim&amp;&amp;i==num); } if(!lim)f[pos][six]=ans; return ans; } int solve(int n) { int len=0; memset(f,-1,sizeof(f)); while(n){ bit[&#43;&#43;len]=n%10; n/=10; } return dfs(len,0,1); } int main() { int a,b; while(~scanf(&#34;%d%d&#34;,&amp;a,&amp;b)&amp;&amp;(a&#43;b)){ printf(&#34;%d\n&#34;,solve(b)-solve(a-1)); } return 0; } 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/dea3a3c2f5609397b43008020272c0b0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-05-18T18:57:00+08:00" />
<meta property="article:modified_time" content="2016-05-18T18:57:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数位dp入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <div class="markdown_views"> 
  <p>数位dp，一般的题意是要求把某个区间的符合某种特征的数的个数求出来，一般的思路就是把最大数按位分解，然后dfs依次判断每一位相应的数是否满足要求。 <br> 把以前做过的几道简单数位dp的题总结一下，可以作为入门题做做。 <br> 1. <br> hdu 2089 不要62 <br> 题意：给定一个区间[a,b]，问在这个区间中的数字，不包含4和62的数有多少个？</p> 
  <p>分析：数据范围小于1e6，如果暴力的话，再加上分解因数，预处理的时间复杂度数量级最大1e7，查询O(1)。 <br> 用数位dp的做法：</p> 
  <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-preprocessor">#include&lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include&lt;cstdio&gt;</span>
<span class="hljs-preprocessor">#include&lt;cstring&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">int</span> f[<span class="hljs-number">8</span>][<span class="hljs-number">2</span>],bit[<span class="hljs-number">8</span>];
<span class="hljs-comment">/*
f[i][j]:i是位数
j==0，尾位不是6
j==1，尾位是6
*/</span>
<span class="hljs-keyword">int</span> dfs(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">bool</span> six,<span class="hljs-keyword">bool</span> lim)<span class="hljs-comment">//位数，尾位是否是6，是否是上限</span>
{
    <span class="hljs-keyword">if</span>(pos&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span>(!lim&amp;&amp;f[pos][six]!=-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> f[pos][six];
    <span class="hljs-keyword">int</span> num=lim?bit[pos]:<span class="hljs-number">9</span>; <span class="hljs-comment">//假设该位是2,下一位是3，如果现在算到该位为1，那么lim=0，表示下一位是能取到9的，</span>
                            <span class="hljs-comment">//如果该位为2，那么lim=1，下一位只能取到3</span>
    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=num;i++){
        <span class="hljs-keyword">if</span>(i==<span class="hljs-number">4</span>||six&amp;&amp;i==<span class="hljs-number">2</span>)<span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果再加一位是4，或者尾位是6再加一位是2，那么都是不合法的状态，跳过。</span>
        ans+=dfs(pos-<span class="hljs-number">1</span>,i==<span class="hljs-number">6</span>,lim&amp;&amp;i==num);
    }
    <span class="hljs-keyword">if</span>(!lim)f[pos][six]=ans;
    <span class="hljs-keyword">return</span> ans;
}
<span class="hljs-keyword">int</span> solve(<span class="hljs-keyword">int</span> n)
{
    <span class="hljs-keyword">int</span> len=<span class="hljs-number">0</span>;
    <span class="hljs-built_in">memset</span>(f,-<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(f));
    <span class="hljs-keyword">while</span>(n){
        bit[++len]=n%<span class="hljs-number">10</span>;
        n/=<span class="hljs-number">10</span>;
    }
    <span class="hljs-keyword">return</span> dfs(len,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);
}
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> a,b;
    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d%d"</span>,&amp;a,&amp;b)&amp;&amp;(a+b)){
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,solve(b)-solve(a-<span class="hljs-number">1</span>));
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
  <p>2. <br> hdu 3652 B-number <br> 题意：求小于n，是13的倍数且含有’13’的数的个数。n&lt;1e9</p> 
  <p>分析：有两个要求，不含13且不是13的倍数，这样的话，可是可以用三维数组表示状态f[i][j][k]，i表示数位，然后增加上用j表示余数，k表示是否含有13。然后dfs，从高位开始以此判断每一位的状态。</p> 
  <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-preprocessor">#include&lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include&lt;cstring&gt;</span>
<span class="hljs-preprocessor">#include&lt;algorithm&gt;</span>
<span class="hljs-preprocessor">#include&lt;cstdio&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">15</span>;
<span class="hljs-keyword">int</span> bit[N],f[N][N][<span class="hljs-number">3</span>];
<span class="hljs-comment">/*
dp[i][j][k] j表示余数
k==0 不包含13且不以1结尾
k==1 不包含13且以1结尾
k==2 包含13
*/</span>
<span class="hljs-keyword">int</span> dfs(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> mod,<span class="hljs-keyword">int</span> have,<span class="hljs-keyword">bool</span> lim)<span class="hljs-comment">//第几位数，余数，状态标号，是否是上限</span>
{
    <span class="hljs-keyword">if</span>(pos&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> mod==<span class="hljs-number">0</span>&amp;&amp;have==<span class="hljs-number">2</span>;
    <span class="hljs-keyword">if</span>(!lim&amp;&amp;f[pos][mod][have]!=-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> f[pos][mod][have];
    <span class="hljs-keyword">int</span> num=lim?bit[pos]:<span class="hljs-number">9</span>;
    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=num;i++){
        <span class="hljs-keyword">int</span> mod_x=(mod*<span class="hljs-number">10</span>+i)%<span class="hljs-number">13</span>; <span class="hljs-comment">//传到下一位的余数，模拟除法的过程</span>
        <span class="hljs-keyword">int</span> have_x=have;
        <span class="hljs-keyword">if</span>(have==<span class="hljs-number">0</span>&amp;&amp;i==<span class="hljs-number">1</span>)have_x=<span class="hljs-number">1</span>;<span class="hljs-comment">//末尾不是1，再加一位是1，标记为1</span>
        <span class="hljs-keyword">if</span>(have==<span class="hljs-number">1</span>&amp;&amp;i!=<span class="hljs-number">1</span>)have_x=<span class="hljs-number">0</span>;<span class="hljs-comment">//末尾是1，再加一位不是1，标记为0</span>
        <span class="hljs-keyword">if</span>(have==<span class="hljs-number">1</span>&amp;&amp;i==<span class="hljs-number">3</span>)have_x=<span class="hljs-number">2</span>;<span class="hljs-comment">//末尾是1，再加一位是3，标记为2</span>
        ans+=dfs(pos-<span class="hljs-number">1</span>,mod_x,have_x,lim&amp;&amp;i==num);
    }
    <span class="hljs-keyword">if</span>(!lim)f[pos][mod][have]=ans;
    <span class="hljs-keyword">return</span> ans;
}
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> n,len;
    <span class="hljs-keyword">while</span>(~<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n)){
        <span class="hljs-built_in">memset</span>(f,-<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(f));
        len=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(n){
            bit[++len]=n%<span class="hljs-number">10</span>;
            n/=<span class="hljs-number">10</span>;
        }
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,dfs(len,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>));
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
  <p>3. <br> hdu 3555 含有49的数： <br> 题意： <br> 找出2^63范围内含有49的数，注意用long long</p> 
  <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-preprocessor">#include&lt;cstdio&gt;</span>
<span class="hljs-preprocessor">#include&lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include&lt;cstring&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">20</span>;
ll f[N][<span class="hljs-number">3</span>];
<span class="hljs-keyword">int</span> bit[N];
<span class="hljs-comment">//f[pos][have]</span>
<span class="hljs-comment">//0 最后一位不是4且不含49</span>
<span class="hljs-comment">//1 最后一位是4</span>
<span class="hljs-comment">//2 有49</span>
ll dfs(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> have,<span class="hljs-keyword">bool</span> lim)
{
    <span class="hljs-keyword">if</span>(pos&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> have==<span class="hljs-number">2</span>;
    <span class="hljs-keyword">if</span>(!lim&amp;&amp;f[pos][have]!=-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> f[pos][have];
    <span class="hljs-keyword">int</span> num=lim?bit[pos]:<span class="hljs-number">9</span>;
    ll ans=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=num;i++){
        <span class="hljs-keyword">int</span> have_x=have;
        <span class="hljs-keyword">if</span>(have==<span class="hljs-number">1</span>&amp;&amp;i==<span class="hljs-number">9</span>)have_x=<span class="hljs-number">2</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(have==<span class="hljs-number">0</span>&amp;&amp;i==<span class="hljs-number">4</span>)have_x=<span class="hljs-number">1</span>;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(have==<span class="hljs-number">1</span>&amp;&amp;i!=<span class="hljs-number">4</span>)have_x=<span class="hljs-number">0</span>;

        ans+=dfs(pos-<span class="hljs-number">1</span>,have_x,lim&amp;i==num);
    }
    <span class="hljs-keyword">if</span>(!lim)f[pos][have]=ans;
    <span class="hljs-keyword">return</span> ans;
}
ll solve(ll n)
{
    <span class="hljs-built_in">memset</span>(f,-<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(f));
    <span class="hljs-keyword">int</span> tot=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">while</span>(n){
        bit[++tot]=n%<span class="hljs-number">10</span>;
        n/=<span class="hljs-number">10</span>;
    }
    <span class="hljs-keyword">return</span> dfs(tot,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);
}
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> T;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);
    <span class="hljs-keyword">while</span>(T--){
        ll n;<span class="hljs-built_in">cin</span>&gt;&gt;n;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%lld\n"</span>,solve(n));
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
  <p>这个也可以用递推解决：</p> 
  <pre class="prettyprint"><code class="hljs markdown">dp[<span class="hljs-link_label">k</span>][<span class="hljs-link_reference">0</span>]=dp[<span class="hljs-link_label">k-1</span>][<span class="hljs-link_reference">0</span>]<span class="hljs-emphasis">*9+dp[k-1][1]*</span>8;         //dp[][0]表示不包含49并且以非4结尾的个数

dp[<span class="hljs-link_label">k</span>][<span class="hljs-link_reference">1</span>]=dp[<span class="hljs-link_label">k-1</span>][<span class="hljs-link_reference">0</span>]+dp[<span class="hljs-link_label">k-1</span>][<span class="hljs-link_reference">1</span>];           //dp[][1]表示不包含49并且以4结尾的个数

dp[<span class="hljs-link_label">k</span>][<span class="hljs-link_reference">2</span>]=dp[<span class="hljs-link_label">k-1</span>][<span class="hljs-link_reference">1</span>]+dp[<span class="hljs-link_label">k-1</span>][<span class="hljs-link_reference">2</span>]*10;        //dp[][2]表示包含49的个数</code></pre> 
  <p>4. <br> 数位dp的思想是处理一个序列，一位位的分析，上面的都是先把数分解成一个序列，有的题目就是直接问哟多少种满足要求的序列，处理也是一样的，对每一个位处理即可。 <br> 例： <br> hdu 5642 数位dp/ 递推 <br> 题意：数一个长度为 n的序列 ， 并且序列中不能出现长度大于 3 的连续的相同的字符 <br> 分析： <br> 这道题目是BC的一道题目，大部分人是用递推解决的，因为递推特别简单。</p> 
  <pre class="prettyprint"><code class="hljs handlebars"><span class="xml"><span class="hljs-tag">    <span class="hljs-attribute">ll</span> <span class="hljs-attribute">f</span>[<span class="hljs-attribute">N</span>][<span class="hljs-attribute">4</span>]; //依次表示末尾应经出现连续相等字母的数量
    <span class="hljs-attribute">f</span>[<span class="hljs-attribute">1</span>][<span class="hljs-attribute">1</span>]=<span class="hljs-value">26;</span>
    <span class="hljs-attribute">for</span>(<span class="hljs-attribute">int</span> <span class="hljs-attribute">i</span>=<span class="hljs-value">2;i&lt;N;i++){<!-- --></span>
        <span class="hljs-attribute">f</span>[<span class="hljs-attribute">i</span>][<span class="hljs-attribute">1</span>]=<span class="hljs-value">(f[i-1][1]+f[i-1][2]+f[i-1][3])*25%mod;</span>
        <span class="hljs-attribute">f</span>[<span class="hljs-attribute">i</span>][<span class="hljs-attribute">2</span>]=<span class="hljs-value">f[i-1][1];</span>
        <span class="hljs-attribute">f</span>[<span class="hljs-attribute">i</span>][<span class="hljs-attribute">3</span>]=<span class="hljs-value">f[i-1][2];</span>
    }</span></span></code></pre> 
  <p>这题用数位dp的思想也是可以做的，d[i][j][k]为处理完 i个字符 , 结尾字符为 ′a′+j, 结尾部分已重复出现了 k次的方案数。 </p> 
  <pre class="prettyprint"><code class="hljs cpp"><span class="hljs-preprocessor">#include&lt;cstdio&gt;</span>
<span class="hljs-preprocessor">#include&lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include&lt;cstring&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;
<span class="hljs-keyword">typedef</span> <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> ll;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> mod=<span class="hljs-number">1e9</span>+<span class="hljs-number">7</span>;
<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> N=<span class="hljs-number">2009</span>;
<span class="hljs-keyword">int</span> f[N][<span class="hljs-number">26</span>][<span class="hljs-number">4</span>];
<span class="hljs-keyword">int</span> dfs(<span class="hljs-keyword">int</span> pos,<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> k)
{
    <span class="hljs-keyword">if</span>(pos&lt;=<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span>(f[pos][m][k]!=-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> f[pos][m][k];
    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++){
        <span class="hljs-keyword">if</span>(i!=m)ans=(ans+dfs(pos-<span class="hljs-number">1</span>,i,<span class="hljs-number">1</span>))%mod;
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i==m&amp;&amp;k&lt;<span class="hljs-number">3</span>)ans=(ans+dfs(pos-<span class="hljs-number">1</span>,i,k+<span class="hljs-number">1</span>))%mod;
    }
    <span class="hljs-keyword">return</span> f[pos][m][k]=ans;
}
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> T;<span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;T);
    <span class="hljs-keyword">int</span> n;
    <span class="hljs-built_in">memset</span>(f,-<span class="hljs-number">1</span>,<span class="hljs-keyword">sizeof</span>(f));
    <span class="hljs-keyword">while</span>(T--){
        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%d"</span>,&amp;n);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)dfs(n,i,<span class="hljs-number">1</span>);
        <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">26</span>;i++)ans=(ans+f[n][i][<span class="hljs-number">1</span>])%mod;
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d\n"</span>,ans);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
  <p>5. <br> hdu 4347 <br> 题意：给一个数A (十进制表示形式为AnAn-1An-2 … A2A1，定义函数 F(x) = An * 2n-1 + An-1 * 2n-2 + … + A2 * 2 + A1 * 1，给一个B,求B以内的i,满足F(i)&lt;=F(A)</p> 
  <p>分析：f[i][j]表示i位比j小的数有多少，先计算出F(a)，然后dfs，找出比fa小的B以内的数，找B以内的数，这就是简单的数位dp了，先把B按位存储，然后从高位dfs一位位比较就好了。</p> 
  <pre class="prettyprint"><code class="hljs perl"><span class="hljs-comment">#include&lt;cstdio&gt;</span>
<span class="hljs-comment">#include&lt;iostream&gt;</span>
<span class="hljs-comment">#include&lt;cstring&gt;</span>
using namespace std;
typedef long long ll;
const <span class="hljs-keyword">int</span> mod=<span class="hljs-number">1</span>e9+<span class="hljs-number">7</span>;
const <span class="hljs-keyword">int</span> N=<span class="hljs-number">2009</span>;
<span class="hljs-keyword">int</span> f[<span class="hljs-number">12</span>][<span class="hljs-number">4600</span>],w[<span class="hljs-number">12</span>];
<span class="hljs-keyword">int</span> bit[<span class="hljs-number">12</span>];
<span class="hljs-keyword">int</span> dfs(<span class="hljs-keyword">int</span> <span class="hljs-keyword">pos</span>,<span class="hljs-keyword">int</span> sum,bool lim)
{
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">pos</span>&lt;=<span class="hljs-number">0</span>)<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">if</span>(!lim&amp;&amp;f[<span class="hljs-keyword">pos</span>][sum]!=-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> f[<span class="hljs-keyword">pos</span>][sum];
    <span class="hljs-keyword">int</span> num=lim?bit[<span class="hljs-keyword">pos</span>]:<span class="hljs-number">9</span>;
    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=num;i++){
        <span class="hljs-keyword">if</span>(sum-i<span class="hljs-variable">*w</span>[<span class="hljs-keyword">pos</span>]&gt;=<span class="hljs-number">0</span>)ans+=dfs(<span class="hljs-keyword">pos</span>-<span class="hljs-number">1</span>,sum-i<span class="hljs-variable">*w</span>[<span class="hljs-keyword">pos</span>],lim&amp;&amp;i==num);
    }
    <span class="hljs-keyword">if</span>(!lim)f[<span class="hljs-keyword">pos</span>][sum]=ans;
    <span class="hljs-keyword">return</span> ans;
}
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">11</span>;i++)w[i+<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>&lt;&lt;i;
    <span class="hljs-keyword">int</span> T;scanf(<span class="hljs-string">"<span class="hljs-variable">%d</span>"</span>,&amp;T);
    memset(f,-<span class="hljs-number">1</span>,sizeof(f));
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> cas=<span class="hljs-number">1</span>;cas&lt;=T;cas++){
        <span class="hljs-keyword">int</span> a,b;
        scanf(<span class="hljs-string">"<span class="hljs-variable">%d</span><span class="hljs-variable">%d</span>"</span>,&amp;a,&amp;b);
        <span class="hljs-keyword">int</span> fa=<span class="hljs-number">0</span>,i=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(a){
            fa+=(a<span class="hljs-variable">%10</span>)<span class="hljs-variable">*w</span>[++i];
            a/=<span class="hljs-number">10</span>;
        }
        i=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">while</span>(b){
            bit[++i]=b<span class="hljs-variable">%10</span>;
            b/=<span class="hljs-number">10</span>;
        }
        <span class="hljs-keyword">printf</span>(<span class="hljs-string">"Case #<span class="hljs-variable">%d</span>: <span class="hljs-variable">%d</span>\n"</span>,cas,dfs(i,fa,<span class="hljs-number">1</span>));
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
  <p>6. <br> 题意： <br> d magic number（0&lt;=d&lt;9）的意思就是一个数，从最高位开始奇数位不是d,偶数位是d <br> 题目问，给a,b,m,d(a&lt;=b,m&lt;2000)问，a,b之间有多少个数满足既是d magic number，又可以被m整除 <br> 分析： <br> 跟上面第二题有些类似，需要注意位数最大可能是2000。</p> 
  <pre class="prettyprint"><code class="hljs perl"><span class="hljs-comment">#include&lt;cstdio&gt;</span>
<span class="hljs-comment">#include&lt;iostream&gt;</span>
<span class="hljs-comment">#include&lt;cstring&gt;</span>
using namespace std;
typedef long long ll;
const <span class="hljs-keyword">int</span> mod=<span class="hljs-number">1</span>e9+<span class="hljs-number">7</span>;
const <span class="hljs-keyword">int</span> N=<span class="hljs-number">2009</span>;
<span class="hljs-keyword">int</span> f[N][N],bit[N];
char a[N],b[N];
<span class="hljs-keyword">int</span> <span class="hljs-keyword">m</span>,d,len;
<span class="hljs-keyword">int</span> dfs(<span class="hljs-keyword">int</span> <span class="hljs-keyword">pos</span>,<span class="hljs-keyword">int</span> pre,bool lim)
{
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">pos</span>==len+<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> pre==<span class="hljs-number">0</span>;
    <span class="hljs-keyword">if</span>(!lim&amp;&amp;f[<span class="hljs-keyword">pos</span>][pre]!=-<span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> f[<span class="hljs-keyword">pos</span>][pre];
    <span class="hljs-keyword">int</span> num=lim?bit[<span class="hljs-keyword">pos</span>]:<span class="hljs-number">9</span>;
    <span class="hljs-keyword">int</span> ans=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;=num;i++){
        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">pos</span>&amp;<span class="hljs-number">1</span>)&amp;&amp;i==d)<span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">if</span>(!(<span class="hljs-keyword">pos</span>&amp;<span class="hljs-number">1</span>)&amp;&amp;i!=d)<span class="hljs-keyword">continue</span>;
        ans=(ans+dfs(<span class="hljs-keyword">pos</span>+<span class="hljs-number">1</span>,(pre<span class="hljs-variable">*10</span>+i)<span class="hljs-variable">%m</span>,lim&amp;&amp;i==num))<span class="hljs-variable">%mod</span>;
    }
    <span class="hljs-keyword">if</span>(!lim)f[<span class="hljs-keyword">pos</span>][pre]=ans;
    <span class="hljs-keyword">return</span> ans;
}
<span class="hljs-keyword">int</span> solve(const char <span class="hljs-variable">*s</span>)
{
    len=strlen(<span class="hljs-keyword">s</span>);
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++)bit[i+<span class="hljs-number">1</span>]=<span class="hljs-keyword">s</span>[i]-<span class="hljs-string">'0'</span>;
    <span class="hljs-keyword">return</span> dfs(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);
}
<span class="hljs-keyword">int</span> judge(const char <span class="hljs-variable">*s</span>)
{
    len-strlen(<span class="hljs-keyword">s</span>);
    <span class="hljs-keyword">int</span> pre=<span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;len;i++){
        pre=(pre<span class="hljs-variable">*10</span>+<span class="hljs-keyword">s</span>[i]-<span class="hljs-string">'0'</span>)<span class="hljs-variable">%m</span>;
        <span class="hljs-keyword">if</span>(i&amp;<span class="hljs-number">1</span>&amp;&amp;(<span class="hljs-keyword">s</span>[i]-<span class="hljs-string">'0'</span>!=d))<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">if</span>(!(i&amp;<span class="hljs-number">1</span>)&amp;&amp;<span class="hljs-keyword">s</span>[i]-<span class="hljs-string">'0'</span>==d)<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }
    <span class="hljs-keyword">return</span> pre==<span class="hljs-number">0</span>;
}
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-regexp">//freopen</span>(<span class="hljs-string">"f.txt"</span>,<span class="hljs-string">"r"</span>,stdin);
    memset(f,-<span class="hljs-number">1</span>,sizeof(f));
    scanf(<span class="hljs-string">"<span class="hljs-variable">%d</span><span class="hljs-variable">%d</span>"</span>,&amp;<span class="hljs-keyword">m</span>,&amp;d);
    scanf(<span class="hljs-string">"<span class="hljs-variable">%s</span><span class="hljs-variable">%s</span>"</span>,a,b);
    <span class="hljs-keyword">printf</span>(<span class="hljs-string">"<span class="hljs-variable">%d</span>\n"</span>,(solve(b)-solve(a)+judge(a)+mod)<span class="hljs-variable">%mod</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
  <p>上面的6道数位dp题可以看出形式差不多是一样的，前几道是直接搬得我以前写的题解，注释写的比较详细，希望可以帮助需要的朋友！</p> 
 </div> 
</div> 
<p>转载于:https://www.cnblogs.com/01world/p/5651204.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3c65716a3f2e6f07adb5355a6d8aa862/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">github代码搜索技巧</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b28f5e4a9268309720f26faa6065fc31/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[Err] 1093 - You can&#39;t specify target table &#39;s&#39; for update in FROM clause</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>