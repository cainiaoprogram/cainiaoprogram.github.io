<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>在Xilinx zynq7020平台使用Marvell6020交换机芯片 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="在Xilinx zynq7020平台使用Marvell6020交换机芯片" />
<meta property="og:description" content="初次写博客，不好的地方欢迎提出建议。 目 标 ：在ZYNQ7020处理器的linux平台调通Marvell 88e6020交换机，实现局域网内可以通讯。 硬件平台：zynq7020（ARM CORTEX-A9），Marvell 88E6020交换机芯片 内核版本：linux4.14.0 说到网络，肯定是先想到网络OSI7层协议模型，直接度娘可以找到很多7层模型的详细介绍，以下介绍简单介绍相关的MAC层和PHY层。 •MAC是Media Access Control的缩写，即媒体访问控制子层协议。该协议位于OSI七层协议中数据链路层的下半部分，主要负责控制与连接物理层的物理介质。 在发送数据的时候，MAC协议可以事先判断是否可以发送数据，如果可以发送将给数据加上一些控制信息，最终将数据以及控制信息以规定的格式发送到物理层； 在接收数据的时候，MAC协议首先判断输入的信息并是否发生传输错误，如果没有错误，则去掉控制信息发送至LLC层。以太网MAC由IEEE-802.3以太网标准定义。 •PHY是物理接口收发器，它实现物理层。包括MII/GMII（介质独立接口）子层、PCS（物理编码子层）、PMA（物理介质附加）子层、PMD（物理介质相关）子层、MDI子层。 PHY在发送数据时，收到MAC过来的数据（对PHY来说，没有帧的概念，对它来说，都是数据而不管什么地址，数据还是CRC），每4bit就增加1bit的检错码，然后把并行数据转化为串行流数据，再按照物理层的编码规则把数据编码，再变为模拟信号把数据送出去。 收数据时的流程反之。 PHY与MAC的通迅接口 MAC和PHY是通过MII（Medium Independent Interface（介质独立接口））进行通信。包括如下：
数据接口，有TX/RX两条独立的通道。管理接口（SMI），由时钟信号和数据信号组成，控制监控PHY的工作状态。 以MII的基础，又有了以下多种数据接口： RMII（Reduced Media Independant Interface）,简化的MII，信号线更少了。GMII（Gigabit Media Independent Interface）千兆的MII接口。RGMII (Reduced Gigabit Media Independent Interface)简化的千兆接口。 SMI（MII管理接口）： 串行管理接口（Serial Management Interface）也被称作MII管理接口（MII Management Interface），包括MDC和MDIO两条信号线。MDIO是一个PHY的管理接口，用来读/写PHY的寄存器，以控制PHY的行为或获取PHY的状态，MDC为MDIO提供时钟。 这次的硬件使用的是RGMII接口： RGMII均采用4位数据接口，工作时钟125MHz，并且在上升沿和下降沿同时传输数据，因此传输速率可达1000Mbps。 PHY层之下是RJ45，RJ45就是我们平常使用的网线水晶头插线口。 以下为MAC和PHY通讯的整体框图 以下为研究代码过程 ZYNQ7020 MAC驱动 在源码包的位置 source_root/drivers/net/ethernet/cadence/
drivers/net/ethernet/cadence/macb_main.c 为MAC驱动代码。
macb_main.c 平台注册到probe执行，在probe中执行了macb_mii_init函数。 /*平台注册*/ static struct platform_driver macb_driver = { .probe = macb_probe, .remove = macb_remove, .driver = { ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5ee69cf1038e0e41650df677674044f3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-05-21T11:21:48+08:00" />
<meta property="article:modified_time" content="2019-05-21T11:21:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">在Xilinx zynq7020平台使用Marvell6020交换机芯片</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <h2><strong><span style="color:#f33b45;">初次写博客，不好的地方欢迎提出建议。</span></strong></h2> 
</blockquote> 
<blockquote> 
 <h3>目    标    ：在ZYNQ7020处理器的linux平台调通Marvell 88e6020交换机，实现局域网内可以通讯。</h3> 
 <h3>硬件平台：zynq7020（ARM CORTEX-A9），Marvell 88E6020交换机芯片</h3> 
 <h3>内核版本：linux4.14.0</h3> 
 <p>                 </p> 
</blockquote> 
<blockquote> 
 <h4>       说到网络，肯定是先想到网络OSI7层协议模型，直接度娘可以找到很多7层模型的详细介绍，以下介绍简单介绍相关的MAC层和PHY层。</h4> 
</blockquote> 
<p><img alt="" class="has" height="449" src="https://images2.imgbox.com/7a/45/XouG5JJH_o.png" width="556"></p> 
<blockquote> 
 <h4>•MAC是Media Access Control的缩写，即媒体访问控制子层协议。该协议位于OSI七层协议中<span style="color:#86ca5e;">数据链路层的下半部分</span>，主要<span style="color:#86ca5e;">负责控制与连接物理层的物理介质</span>。</h4> 
 <ul><li> <h4>在发送数据的时候，MAC协议可以事先判断是否可以发送数据，如果可以发送将给数据加上一些控制信息，最终将数据以及控制信息以规定的格式发送到物理层；</h4> </li><li> <h4>在接收数据的时候，MAC协议首先判断输入的信息并是否发生传输错误，如果没有错误，则去掉控制信息发送至LLC层。以太网MAC由IEEE-802.3以太网标准定义。</h4> </li></ul> 
 <h4>•PHY是物理接口收发器，它实现物理层。包括MII/GMII（介质独立接口）子层、PCS（物理编码子层）、PMA（物理介质附加）子层、PMD（物理介质相关）子层、MDI子层。</h4> 
 <ul><li> <h4>PHY在发送数据时，<span style="color:#86ca5e;">收到MAC过来的数据</span>（对PHY来说，没有帧的概念，对它来说，都是数据而不管什么地址，数据还是CRC），<span style="color:#86ca5e;">每4bit就增加1bit的检错码，然后把并行数据转化为串行流数据，再按照物理层的编码规则把数据编码，再变为模拟信号把数据送出去</span>。</h4> </li><li> <h4>收数据时的流程反之。</h4> </li></ul> 
</blockquote> 
<blockquote> 
 <h3><span style="color:#f33b45;">PHY与MAC的通迅接口</span></h3> 
 <p>MAC和PHY是通过MII（Medium Independent Interface（介质独立接口））进行通信。包括如下：</p> 
 <ul><li>数据接口，有TX/RX两条独立的通道。</li><li>管理接口（SMI），由时钟信号和数据信号组成，控制监控PHY的工作状态。</li></ul> 
 <h4>以MII的基础，又有了以下多种数据接口：</h4> 
 <ol><li>RMII（Reduced Media Independant Interface）,简化的MII，信号线更少了。</li><li>GMII（Gigabit Media Independent Interface）千兆的MII接口。</li><li>RGMII (Reduced Gigabit Media Independent Interface)简化的千兆接口。</li></ol> 
 <h4>SMI（MII管理接口）：</h4> 
 <ul><li>串行管理接口（Serial Management Interface）也被称作MII管理接口（MII Management Interface），包括MDC和MDIO两条信号线。MDIO是一个PHY的管理接口，用来读/写PHY的寄存器，以控制PHY的行为或获取PHY的状态，MDC为MDIO提供时钟。</li></ul> 
 <h4>这次的硬件使用的是RGMII接口：</h4> 
 <ul><li>RGMII均采用4位数据接口，工作时钟125MHz，并且在上升沿和下降沿同时传输数据，因此传输速率可达1000Mbps。 </li></ul> 
 <p><img alt="" class="has" height="248" src="https://images2.imgbox.com/0b/fb/fc8kaIMZ_o.png" width="483"></p> 
</blockquote> 
<blockquote> 
 <h4>PHY层之下是RJ45，RJ45就是我们平常使用的网线水晶头插线口。</h4> 
</blockquote> 
<h3>以下为MAC和PHY通讯的整体框图</h3> 
<p>       <img alt="" class="has" height="371" src="https://images2.imgbox.com/49/db/1u8CdlWg_o.png" width="731"></p> 
<h2><span style="color:#f33b45;">以下为研究代码过程</span></h2> 
<h3>ZYNQ7020 MAC驱动</h3> 
<ul><li> <p>在源码包的位置   source_root/drivers/net/ethernet/cadence/</p> </li><li> <p>drivers/net/ethernet/cadence/macb_main.c  为MAC驱动代码。</p> </li></ul> 
<h4>macb_main.c </h4> 
<ul><li>平台注册到probe执行，在probe中执行了macb_mii_init函数。</li></ul> 
<pre class="has"><code class="language-cpp">/*平台注册*/
static struct platform_driver macb_driver = {
    .probe      = macb_probe,
    .remove     = macb_remove,
    .driver     = {
        .name       = "macb",
        .of_match_table = of_match_ptr(macb_dt_ids),
        .pm = &amp;macb_pm_ops,
    },
};

module_platform_driver(macb_driver);


/*macb_probe*/
static int macb_probe(struct platform_device *pdev)
{
    int (*clk_init)(struct platform_device *, struct clk **,
            struct clk **, struct clk **,  struct clk **,
            struct clk **) = macb_clk_init;
    int (*init)(struct platform_device *) = macb_init;
    struct device_node *np = pdev-&gt;dev.of_node;
    struct device_node *phy_node;
    const struct macb_config *macb_config = NULL;
    struct clk *pclk, *hclk = NULL, *tx_clk = NULL, *rx_clk = NULL;
    struct clk *tsu_clk = NULL;
    unsigned int queue_mask, num_queues;
    struct macb_platform_data *pdata;
    bool native_io;
    struct phy_device *phydev;
    struct net_device *dev;
    struct resource *regs;
    void __iomem *mem;
    const char *mac;
    struct macb *bp;
    int err;

    regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
    mem = devm_ioremap_resource(&amp;pdev-&gt;dev, regs);
    if (IS_ERR(mem))
        return PTR_ERR(mem);
    if (np) {
        const struct of_device_id *match;

        match = of_match_node(macb_dt_ids, np);
        if (match &amp;&amp; match-&gt;data) {
            macb_config = match-&gt;data;
            clk_init = macb_config-&gt;clk_init;
            init = macb_config-&gt;init;
        }
    }

    err = clk_init(pdev, &amp;pclk, &amp;hclk, &amp;tx_clk, &amp;rx_clk, &amp;tsu_clk);
    if (err)
        return err;

    pm_runtime_set_autosuspend_delay(&amp;pdev-&gt;dev, MACB_PM_TIMEOUT);
    pm_runtime_use_autosuspend(&amp;pdev-&gt;dev);
    pm_runtime_get_noresume(&amp;pdev-&gt;dev);
    pm_runtime_set_active(&amp;pdev-&gt;dev);
    pm_runtime_enable(&amp;pdev-&gt;dev);
    native_io = hw_is_native_io(mem);

    macb_probe_queues(mem, native_io, &amp;queue_mask, &amp;num_queues);
    dev = alloc_etherdev_mq(sizeof(*bp), num_queues);
    if (!dev) {
        err = -ENOMEM;
        goto err_disable_clocks;
    }

    dev-&gt;base_addr = regs-&gt;start;

    SET_NETDEV_DEV(dev, &amp;pdev-&gt;dev);

    bp = netdev_priv(dev);
    bp-&gt;pdev = pdev;
    bp-&gt;dev = dev;
    bp-&gt;regs = mem;
    bp-&gt;native_io = native_io;
    if (native_io) {
        bp-&gt;macb_reg_readl = hw_readl_native;
        bp-&gt;macb_reg_writel = hw_writel_native;
    } else {
        bp-&gt;macb_reg_readl = hw_readl;
        bp-&gt;macb_reg_writel = hw_writel;
    }
    bp-&gt;num_queues = num_queues;
    bp-&gt;queue_mask = queue_mask;
    if (macb_config)
        bp-&gt;dma_burst_length = macb_config-&gt;dma_burst_length;
    bp-&gt;pclk = pclk;
    bp-&gt;hclk = hclk;
    bp-&gt;tx_clk = tx_clk;
    bp-&gt;rx_clk = rx_clk;
    bp-&gt;tsu_clk = tsu_clk;
    if (tsu_clk)
        bp-&gt;tsu_rate = clk_get_rate(tsu_clk);

    if (macb_config)
        bp-&gt;jumbo_max_len = macb_config-&gt;jumbo_max_len;

    spin_lock_init(&amp;bp-&gt;lock);

    /* setup capabilities */
    macb_configure_caps(bp, macb_config);

#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT
    if (GEM_BFEXT(DAW64, gem_readl(bp, DCFG6))) {
        dma_set_mask(&amp;pdev-&gt;dev, DMA_BIT_MASK(44));
        bp-&gt;hw_dma_cap |= HW_DMA_CAP_64B;
    }
#endif
    platform_set_drvdata(pdev, dev);
 dev-&gt;irq = platform_get_irq(pdev, 0);
    if (dev-&gt;irq &lt; 0) {
        err = dev-&gt;irq;
        goto err_out_free_netdev;
    }

    /* MTU range: 68 - 1500 or 10240 */
    dev-&gt;min_mtu = GEM_MTU_MIN_SIZE;
    if (bp-&gt;caps &amp; MACB_CAPS_JUMBO)
        dev-&gt;max_mtu = gem_readl(bp, JML) - ETH_HLEN - ETH_FCS_LEN;
    else
        dev-&gt;max_mtu = ETH_DATA_LEN;

    mac = of_get_mac_address(np);
    if (mac)
        ether_addr_copy(bp-&gt;dev-&gt;dev_addr, mac);
    else
        macb_get_hwaddr(bp);

    /* Power up the PHY if there is a GPIO reset */
    phy_node = of_parse_phandle(np, "phy-handle", 0);
    if (!phy_node &amp;&amp; of_phy_is_fixed_link(np)) {
        err = of_phy_register_fixed_link(np);
        if (err &lt; 0) {
            dev_err(&amp;pdev-&gt;dev, "broken fixed-link specification");
            goto failed_phy;
        }
        phy_node = of_node_get(np);
        bp-&gt;phy_node = phy_node;
     } else {
        int gpio = of_get_named_gpio(phy_node, "reset-gpios", 0);
        if (gpio_is_valid(gpio)) {
            bp-&gt;reset_gpio = gpio_to_desc(gpio);
            gpiod_direction_output(bp-&gt;reset_gpio, 1);
        }
    }

    err = of_get_phy_mode(np);
    if (err &lt; 0) {
        pdata = dev_get_platdata(&amp;pdev-&gt;dev);
        if (pdata &amp;&amp; pdata-&gt;is_rmii)
            bp-&gt;phy_interface = PHY_INTERFACE_MODE_RMII;
        else
            bp-&gt;phy_interface = PHY_INTERFACE_MODE_MII;
    } else {
        bp-&gt;phy_interface = err;
    }

    macb_reset_phy(pdev);

    /* IP specific init */
    err = init(pdev);
    if (err)
        goto err_out_free_netdev;
    err = register_netdev(dev);
    if (err) {
        dev_err(&amp;pdev-&gt;dev, "Cannot register net device, aborting.\n");
        goto err_out_unregister_netdev;
    }

    err = macb_mii_init(bp);          /*此处为PHY初始化，匹配PHY的过程*/
    if (err)
        goto err_out_unregister_netdev;

    netif_carrier_off(dev);

    tasklet_init(&amp;bp-&gt;hresp_err_tasklet, macb_hresp_error_task,
             (unsigned long)bp);

    if (bp-&gt;caps &amp; MACB_CAPS_WOL)
        device_set_wakeup_capable(&amp;bp-&gt;dev-&gt;dev, 1);

    netdev_info(dev, "Cadence %s rev 0x%08x at 0x%08lx irq %d (%pM)\n",
            macb_is_gem(bp) ? "GEM" : "MACB", macb_readl(bp, MID),
            dev-&gt;base_addr, dev-&gt;irq, dev-&gt;dev_addr);

    phydev = bp-&gt;phy_dev;
    phy_attached_info(phydev);
    pm_runtime_mark_last_busy(&amp;bp-&gt;pdev-&gt;dev);
    pm_runtime_put_autosuspend(&amp;bp-&gt;pdev-&gt;dev);
    return 0;

err_out_unregister_netdev:
    unregister_netdev(dev);

err_out_free_netdev:
    free_netdev(dev);

failed_phy:
    of_node_put(phy_node);

err_disable_clocks:
    clk_disable_unprepare(tx_clk);
    clk_disable_unprepare(hclk);
    clk_disable_unprepare(pclk);
    clk_disable_unprepare(rx_clk);
    clk_disable_unprepare(tsu_clk);
    pm_runtime_disable(&amp;pdev-&gt;dev);
    pm_runtime_set_suspended(&amp;pdev-&gt;dev);
    pm_runtime_dont_use_autosuspend(&amp;pdev-&gt;dev);

    return err;
}
</code></pre> 
<hr> 
<ul><li>macb_mii_init函数为初始化SMI总线，分配空间，封装SMI读写PHY寄存器函数，然后通过MDIO总线去扫描物理连接的PHY，匹配驱动，代码追踪如下。</li></ul> 
<pre class="has"><code class="language-cpp">static int macb_mii_init(struct macb *bp)
{
    struct macb_platform_data *pdata;
    struct device_node *np, *mdio_np;
    int err = -ENXIO, i;

    /* Enable management port */
    macb_writel(bp, NCR, MACB_BIT(MPE));
    /* ***分配空间*****/
    bp-&gt;mii_bus = mdiobus_alloc();
    if (!bp-&gt;mii_bus) {
        err = -ENOMEM;
        goto err_out;
    }

    bp-&gt;mii_bus-&gt;name = "MACB_mii_bus";
    /****封装读写PHY寄存器函数****/
    bp-&gt;mii_bus-&gt;read = &amp;macb_mdio_read;
    bp-&gt;mii_bus-&gt;write = &amp;macb_mdio_write;
//  bp-&gt;mii_bus-&gt;read = &amp;mdio_phy_read;
//  bp-&gt;mii_bus-&gt;write = &amp;mdio_phy_write;
    snprintf(bp-&gt;mii_bus-&gt;id, MII_BUS_ID_SIZE, "%s-%x",
         bp-&gt;pdev-&gt;name, bp-&gt;pdev-&gt;id);
    bp-&gt;mii_bus-&gt;priv = bp;
    bp-&gt;mii_bus-&gt;parent = &amp;bp-&gt;dev-&gt;dev;
    pdata = dev_get_platdata(&amp;bp-&gt;pdev-&gt;dev);

    dev_set_drvdata(&amp;bp-&gt;dev-&gt;dev, bp-&gt;mii_bus);

    np = bp-&gt;pdev-&gt;dev.of_node;
    mdio_np = of_get_child_by_name(np, "mdio");
    if (mdio_np) {
        of_node_put(mdio_np);
        err = of_mdiobus_register(bp-&gt;mii_bus, mdio_np);
        if (err)
            goto err_out_unregister_bus;
    } else if (np) {
        /* try dt phy registration */
        err = of_mdiobus_register(bp-&gt;mii_bus, np);

        /* fallback to standard phy registration if no phy were
         * found during dt phy registration
         */
        if (!err &amp;&amp; !phy_find_first(bp-&gt;mii_bus)) {
            for (i = 1; i &lt; 2; i++) {
                struct phy_device *phydev;
    /*********扫描物理连接的PHY********/
                phydev = mdiobus_scan(bp-&gt;mii_bus, i);
                if (IS_ERR(phydev) &amp;&amp;
                    PTR_ERR(phydev) != -ENODEV) {
                    err = PTR_ERR(phydev);
                    break;
                }
            }

            if (err)
                goto err_out_unregister_bus;
        }
    } else {
        if (pdata)
            bp-&gt;mii_bus-&gt;phy_mask = pdata-&gt;phy_mask;

        err = mdiobus_register(bp-&gt;mii_bus);
    }

    if (err)
        goto err_out_free_mdiobus;

    err = macb_mii_probe(bp-&gt;dev);
    if (err)
        goto err_out_unregister_bus;

    return 0;

err_out_unregister_bus:
    mdiobus_unregister(bp-&gt;mii_bus);
err_out_free_mdiobus:
    mdiobus_free(bp-&gt;mii_bus);
err_out:
    return err;
}


</code></pre> 
<ul><li>执行mdiobus_scan去扫描MDIO总线上挂载的PHY设备。</li></ul> 
<pre class="has"><code class="language-cpp">struct phy_device *mdiobus_scan(struct mii_bus *bus, int addr)
{
    struct phy_device *phydev;
    int err;

    /*通过设备ID号拿到设备的实例结构体*/
    phydev = get_phy_device(bus, addr, false);
    if (IS_ERR(phydev))
        return phydev;

    /*
     * For DT, see if the auto-probed phy has a correspoding child
     * in the bus node, and set the of_node pointer in this case.
     */
    of_mdiobus_link_mdiodev(bus, &amp;phydev-&gt;mdio);
    /*注册PHY设备*/
    err = phy_device_register(phydev);
    if (err) {
        phy_device_free(phydev);
        return ERR_PTR(-ENODEV);
    }

    return phydev;
}
</code></pre> 
<ul><li>执行get_phy_device通过读取设备的ID号去拿到设备的驱动</li></ul> 
<pre class="has"><code class="language-cpp">struct phy_device *get_phy_device(struct mii_bus *bus, int addr, bool is_c45)
{
    struct phy_c45_device_ids c45_ids = {0};
    u32 phy_id = 0;
    int r;

    r = get_phy_id(bus, addr, &amp;phy_id, is_c45, &amp;c45_ids);
    if (r)
        return ERR_PTR(r);
    /* If the phy_id is mostly Fs, there is no device there */

    if ((phy_id &amp; 0x1fffffff) == 0x1fffffff)
        return ERR_PTR(-ENODEV);
    return phy_device_create(bus, addr, phy_id, is_c45, &amp;c45_ids);
}
</code></pre> 
<ul><li>执行phy_device_register 注册PHY设备</li></ul> 
<pre class="has"><code class="language-cpp">int phy_device_register(struct phy_device *phydev)
{
    int err;
    //注册到MDIO总线上
    err = mdiobus_register_device(&amp;phydev-&gt;mdio);
    if (err)
        return err;

    /* Run all of the fixups for this PHY */
    err = phy_scan_fixups(phydev);
    if (err) {
        pr_err("PHY %d failed to initialize\n", phydev-&gt;mdio.addr);
        goto out;
    }

    phydev-&gt;mdio.dev.groups = phy_dev_groups;

    err = device_add(&amp;phydev-&gt;mdio.dev);
    if (err) {
        pr_err("PHY %d failed to add\n", phydev-&gt;mdio.addr);
        goto out;
    }

    return 0;

 out:
    mdiobus_unregister_device(&amp;phydev-&gt;mdio);
    return err;
}
</code></pre> 
<h3>MDIO总线的实现和目的</h3> 
<p>目的：总线涉及驱动和设备，匹配注册在总线上的驱动和设备来执行驱动。上面的MAC驱动中执行了设备注册过程，这里讲解MDIO总线，最后面讲解驱动的注册过程。</p> 
<p><img alt="" class="has" height="429" src="https://images2.imgbox.com/a6/bb/Zkn5mPs8_o.png" width="368"></p> 
<p>实现：drivers/net/phy/mdio_bus.c</p> 
<p>总线通过match去匹配设备和驱动。</p> 
<pre class="has"><code class="language-cpp">struct bus_type mdio_bus_type = {
    .name       = "mdio_bus",
    .match      = mdio_bus_match,
    .uevent     = mdio_uevent,
    .pm     = MDIO_BUS_PM_OPS,
};</code></pre> 
<h3><img alt="" class="has" height="348" src="https://images2.imgbox.com/51/00/svfZ3TyA_o.png" width="958"><img alt="" class="has" height="824" src="https://images2.imgbox.com/11/5b/tZTFA5qw_o.png" width="940"></h3> 
<h3>PHY6020驱动</h3> 
<p>查看数据手册查找设备88e6020 ID为0x01410db0，通过phy_drivers_register函数注册驱动，驱动和设备匹配上后会执行config_init函数。</p> 
<pre class="has"><code class="language-cpp">static struct phy_driver marvell_drivers[] = {
    {
        .phy_id = 0x01410db0,
        .phy_id_mask = 0x0fffffff,
        .name = "Marvell 88E6020",
        .features = PHY_100BT_FEATURES|PHY_10BT_FEATURES|SUPPORTED_MII |
                        SUPPORTED_AUI | SUPPORTED_FIBRE |SUPPORTED_BNC,
        .flags = PHY_HAS_INTERRUPT,
        .config_init = &amp;m88e6020_config_init,
        .config_aneg = &amp;m88e6020_config_aneg,
        .read_status = &amp;m88e6020_genphy_read_status,
    },
};

static int __init mv88e6020_init(void)
{
    int ret = 0;
    mv88e6020_phydev = NULL;
    ret = phy_drivers_register(marvell_drivers,
        ARRAY_SIZE(marvell_drivers),THIS_MODULE);

    if ( ret )
        goto err;

    swicth_to_cpu_link_status = 0;
err:
    return ret;
}
</code></pre> 
<h4><a href="https://blog.csdn.net/mrwangwang/article/details/17394677">参考的PHY驱动详解网址</a></h4> 
<h4><a href="https://blog.csdn.net/fengyuwuzu0519/article/details/74503650">linux 的总线，设备，驱动三者关系</a></h4> 
<h4><a href="https://www.cnblogs.com/zhangshenghui/p/5723256.html" rel="nofollow">MII/MDIO详解</a></h4> 
<h4><span style="color:#f33b45;">这篇文章追的代码较深，如有不懂可以留下留言。如果想追更深的代码，也可以留言，带你追。。。。</span></h4>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7f7274441e5924ca96f3d08ba2da63cd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">全国行政区划分简单分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e88df3e1f834242e7d4baac5314f665f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C#关于控制线程的停止和继续</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>