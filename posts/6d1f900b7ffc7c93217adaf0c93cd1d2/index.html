<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>雷达相机标定（一）----点云提取标定板角点 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="雷达相机标定（一）----点云提取标定板角点" />
<meta property="og:description" content="目录 思路源码效果数据 图像提取角点：https://blog.csdn.net/xx970829/article/details/123233609
思路 velodyne16线点云稀疏，与相机标定时不利于角点的提取，本文先提取出平面，再把平面边缘点投影到yoz平面，拟合出交点，然后结合空间平面方程计算出其空间位置。
源码 //-------------------------------------------------------------------------------------------- // source /home/xx/catkin_ws/devel/setup.bash &amp;&amp; rosrun my_cam_lidar_calib cloud 1.pcd // // 提取点云中的标定板 //-------------------------------------------------------------------------------------------- #include &lt;iostream&gt; #include &lt;math.h&gt; #include &lt;cmath&gt; #include &lt;string.h&gt; //常用点云类 #include &lt;pcl/io/pcd_io.h&gt; #include &lt;pcl/io/ply_io.h&gt; #include &lt;pcl/filters/passthrough.h&gt; //直通滤波器头文件 #include &lt;pcl/filters/statistical_outlier_removal.h&gt; //滤波相关 #include &lt;pcl/visualization/cloud_viewer.h&gt; //类cloud_viewer头文件申明 //分割类 #include &lt;pcl/sample_consensus/method_types.h&gt; #include &lt;pcl/sample_consensus/model_types.h&gt; #include &lt;pcl/segmentation/sac_segmentation.h&gt; #include &lt;pcl/ModelCoefficients.h&gt; #include &lt;pcl/filters/extract_indices.h&gt; //图像类 #include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/imgproc/imgproc.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;Eigen/Eigen&gt; #include &lt;Eigen/Core&gt; // 稠密矩阵的代数运算（逆，特征值等） #include &lt;Eigen/Dense&gt; //标定板长、宽 #define LONG 0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6d1f900b7ffc7c93217adaf0c93cd1d2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-17T13:57:28+08:00" />
<meta property="article:modified_time" content="2022-04-17T13:57:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">雷达相机标定（一）----点云提取标定板角点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><ul><li><a href="#_3" rel="nofollow">思路</a></li><li><a href="#_6" rel="nofollow">源码</a></li><li><a href="#_490" rel="nofollow">效果</a></li><li><a href="#_495" rel="nofollow">数据</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<p>图像提取角点：<a href="https://blog.csdn.net/xx970829/article/details/123233609">https://blog.csdn.net/xx970829/article/details/123233609</a></p> 
<h3><a id="_3"></a>思路</h3> 
<p>velodyne16线点云稀疏，与相机标定时不利于角点的提取，本文先提取出平面，再把平面边缘点投影到yoz平面，拟合出交点，然后结合空间平面方程计算出其空间位置。</p> 
<h3><a id="_6"></a>源码</h3> 
<pre><code> 
//--------------------------------------------------------------------------------------------
//   source /home/xx/catkin_ws/devel/setup.bash &amp;&amp; rosrun my_cam_lidar_calib  cloud 1.pcd
//
//     提取点云中的标定板
//--------------------------------------------------------------------------------------------

#include &lt;iostream&gt;
#include &lt;math.h&gt;
#include &lt;cmath&gt;
#include &lt;string.h&gt;
//常用点云类
#include &lt;pcl/io/pcd_io.h&gt;
#include &lt;pcl/io/ply_io.h&gt;
#include &lt;pcl/filters/passthrough.h&gt;  //直通滤波器头文件
#include &lt;pcl/filters/statistical_outlier_removal.h&gt; //滤波相关
#include &lt;pcl/visualization/cloud_viewer.h&gt;   //类cloud_viewer头文件申明
//分割类
#include &lt;pcl/sample_consensus/method_types.h&gt;
#include &lt;pcl/sample_consensus/model_types.h&gt;
#include &lt;pcl/segmentation/sac_segmentation.h&gt;
#include &lt;pcl/ModelCoefficients.h&gt;
#include &lt;pcl/filters/extract_indices.h&gt;
//图像类
#include &lt;opencv2/core/core.hpp&gt;
#include &lt;opencv2/imgproc/imgproc.hpp&gt;
#include &lt;opencv2/highgui/highgui.hpp&gt;

#include &lt;Eigen/Eigen&gt;
#include &lt;Eigen/Core&gt;
// 稠密矩阵的代数运算（逆，特征值等）
#include &lt;Eigen/Dense&gt;

//标定板长、宽
#define LONG 0.6
#define WIDE 0.67
#define DisThre 0.03//平面分割阈值
#define SLEEP 2     //睡眠时间

using namespace pcl;
using namespace cv;
using namespace std;

float plane_A ,plane_B ,plane_C,plane_D;
void  cloudPassThrough(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud,const char *zhou,int min,int max);
void  Plane_fitting(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_input );
void  cloudStatisticalOutlierRemoval(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud);
void  output_plane(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_plane ,pcl::ModelCoefficients::Ptr  coefficients,pcl::PointIndices::Ptr inliers);
bool  choicePlane(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_plane);

void  cloudEdge(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud);
bool  Collinear(pcl::PointXYZ A,pcl::PointXYZ B,pcl::PointXYZ C);
void  LineFitLeastFit(const std::vector&lt;cv::Point2f&gt; &amp;_points,float &amp; _k,float &amp; _b,float &amp; _r);
void  intersection(cv::Point2f &amp;point,float &amp; A_k,float &amp; A_b,float &amp; B_k,float &amp; B_b);
void  SpatialPoint(cv::Point2f &amp;point2D,pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr cloud);
void  addSpatialPoint(cv::Point2f &amp;point2A,cv::Point2f &amp;point2B,float &amp; B_k,float &amp; B_b,pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr cloud);


pcl::visualization::CloudViewer viewer("viewer");

int main(int argc,char** argv)
{
    string pcd_mame = argv[1]; 
    //打开PCD
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
    if (pcl::io::loadPCDFile(pcd_mame, *cloud) == -1)
    {
        PCL_ERROR("Could not read pcd file!\n");
    
    }

    //直通滤波  
    cloudPassThrough(cloud,"y",-1.8,1.8);
    cloudPassThrough(cloud,"x",1.8,7);
    cloudPassThrough(cloud,"z",-2,2);
    viewer.showCloud(cloud);
    sleep(SLEEP);
    //去除离群点
    cloudStatisticalOutlierRemoval( cloud);
    viewer.showCloud(cloud);
    pcl::io::savePCDFileASCII("myRemoval.pcd",*cloud);
    cout&lt;&lt;"save myRemoval.pcd success !!"&lt;&lt;endl;
    sleep(SLEEP);
    //平面提取
    Plane_fitting(cloud);
    //边界提取 139
    //cloudEdge(cloud);
    sleep(200);

    return (0);
}

void Plane_fitting(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_input)
{

    pcl::ModelCoefficients::Ptr coefficients(new pcl::ModelCoefficients);
    pcl::PointIndices::Ptr inliers(new pcl::PointIndices);
    pcl::SACSegmentation&lt;pcl::PointXYZ&gt; seg;
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_plane(new pcl::PointCloud&lt;pcl::PointXYZ&gt;());

    seg.setOptimizeCoefficients(true);
    seg.setModelType(pcl::SACMODEL_PLANE);
    seg.setMethodType(pcl::SAC_RANSAC);
    seg.setMaxIterations(300);
    seg.setDistanceThreshold(DisThre);

    while (cloud_input-&gt;size() &gt; 100)
    {
        pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_p(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
        seg.setInputCloud(cloud_input);
        seg.segment(*inliers, *coefficients);
        if (inliers-&gt;indices.size() == 0)
        {
            break;
        }
        pcl::ExtractIndices&lt;pcl::PointXYZ&gt; extract;
        extract.setInputCloud(cloud_input);
        extract.setIndices(inliers);
        extract.filter(*cloud_plane);//输出平面

        if (cloud_plane-&gt;size()&gt;100)
        {
            output_plane(cloud_plane ,coefficients,inliers);
        }
        // 移除plane
        extract.setNegative(true);
        extract.filter(*cloud_p);
        *cloud_input = *cloud_p;
    }

}

void  output_plane(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_plane ,pcl::ModelCoefficients::Ptr  coeff,pcl::PointIndices::Ptr inliers)
{
   if(choicePlane(cloud_plane))
   {
       plane_A=coeff-&gt;values[0];
       plane_B=coeff-&gt;values[1];
       plane_C=coeff-&gt;values[2];
       plane_D=coeff-&gt;values[3];

       cout&lt;&lt; coeff-&gt;values[0]&lt;&lt;"  "&lt;&lt;coeff-&gt;values[1]&lt;&lt;"  "&lt;&lt;coeff-&gt;values[2]&lt;&lt;"  "&lt;&lt;coeff-&gt;values[3]&lt;&lt;endl;
       viewer.showCloud(cloud_plane);
       sleep(SLEEP);
       pcl::io::savePCDFileASCII("myplane.pcd",*cloud_plane);
       cout&lt;&lt;"save myplane.pcd success !!"&lt;&lt;endl;

       //边界提取
       cloudEdge(cloud_plane);
   }

}

//选取标定板所在平面
bool  choicePlane(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud)
{
    double maxDistance=sqrt(pow(LONG,2)+pow(WIDE,2));
    double oldDistance=0;
    for(std::size_t i=0; i&lt;cloud-&gt;size(); i++)
    {
        double thisDistance=sqrt(pow(cloud-&gt;points[i].x-cloud-&gt;points[0].x,2)+pow(cloud-&gt;points[i].y-cloud-&gt;points[0].y,2)+pow(cloud-&gt;points[i].z-cloud-&gt;points[0].z,2));

        if(oldDistance&lt;thisDistance)
        {
            oldDistance=thisDistance;
            if(oldDistance&gt;maxDistance+0.05)
               return false;
        }
    }
    if(oldDistance&lt;LONG)
        return false;
    return true;
}

//直通滤波器对点云进行处理
void  cloudPassThrough(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud,const char *zhou,int min,int max)
{
     pcl::PassThrough&lt;pcl::PointXYZ&gt; passthrough;
     passthrough.setInputCloud(cloud);//输入点云
     passthrough.setFilterFieldName(zhou);//对z轴进行操作
     passthrough.setFilterLimits(min,max);//设置直通滤波器操作范围
     passthrough.filter(*cloud);//);//执行滤波

}
//去除离群点
void cloudStatisticalOutlierRemoval(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud)
{
    pcl::StatisticalOutlierRemoval&lt;pcl::PointXYZ&gt; sor;   //创建滤波器对象
    sor.setInputCloud (cloud);                           //设置待滤波的点云
    sor.setMeanK (20);                                 //设置在进行统计时考虑的临近点个数
    sor.setStddevMulThresh (1.0);                      //设置判断是否为离群点的阀值
    sor.filter (*cloud);
}
void  cloudEdge(pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud)
{
    int index[16][2];
    memset(index,-1,sizeof(index));//赋值
    pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr cloud_all(new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
    for(std::size_t i=0 ; i&lt; cloud-&gt;size(); i++)
    {
        //计算垂直俯仰角
        float angle = atan(cloud-&gt;points[i].z / sqrt( pow(cloud-&gt;points[i].x,2) +  pow(cloud-&gt;points[i].y,2))) * 180 / M_PI;
        int scanID = 0;
        scanID = int((angle + 15) / 2 + 0.5);// + 0.5 用于四舍五入
        if(0&lt;=scanID &amp;&amp; scanID&lt;16)
        {

            if(index[scanID][0]==-1)
                index[scanID][0]=i;
            else
                index[scanID][1]=i;

        }
        pcl::PointXYZRGB thisColor;
        thisColor.x=cloud-&gt;points[i].x;
        thisColor.y=cloud-&gt;points[i].y;
        thisColor.z=cloud-&gt;points[i].z;
        thisColor.r=255;
        thisColor.g=255;
        thisColor.b=255;
        cloud_all-&gt;push_back(thisColor);

    }
    //提取边缘
    pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr cloud_edge(new pcl::PointCloud&lt;pcl::PointXYZRGB&gt;);
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_edge_left(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
    pcl::PointCloud&lt;pcl::PointXYZ&gt;::Ptr cloud_edge_right(new pcl::PointCloud&lt;pcl::PointXYZ&gt;);
    for(int i=0 ;i&lt;16;i++)
    {
        if(index[i][0]!=-1)
        {
            pcl::PointXYZRGB thisColor;
            thisColor.x=cloud-&gt;points[index[i][0]].x;
            thisColor.y=cloud-&gt;points[index[i][0]].y;
            thisColor.z=cloud-&gt;points[index[i][0]].z;
            thisColor.r=255;
            thisColor.g=255;
            thisColor.b=255;
            //cloud_all-&gt;push_back(thisColor);
            cloud_edge-&gt;push_back(thisColor);
            cloud_edge_left-&gt;push_back(cloud-&gt;points[index[i][0]]);
        }
    }
    for(int i=15;i&gt;=0;i--)
    {
        if(index[i][1]!=-1)
        {
            pcl::PointXYZRGB thisColor;
            thisColor.x=cloud-&gt;points[index[i][1]].x;
            thisColor.y=cloud-&gt;points[index[i][1]].y;
            thisColor.z=cloud-&gt;points[index[i][1]].z;
            thisColor.r=255;
            thisColor.g=255;
            thisColor.b=255;
            //cloud_all-&gt;push_back(thisColor);
            cloud_edge-&gt;push_back(thisColor);
            cloud_edge_right-&gt;push_back(cloud-&gt;points[index[i][1]]);
        }
    }

    //划分4条线
    int d_a=0;
    int b_c=0;
    vector&lt;cv::Point2f&gt; pointsA;
    vector&lt;cv::Point2f&gt; pointsB;
    vector&lt;cv::Point2f&gt; pointsC;
    vector&lt;cv::Point2f&gt; pointsD;

    for(std::size_t i=0; i&lt;cloud_edge_left-&gt;size()-2; i++)
    {
        //左侧第三个点到前两个点的距离
        if(Collinear(cloud_edge_left-&gt;points[i],cloud_edge_left-&gt;points[i+1],cloud_edge_left-&gt;points[i+2]))
        {
            d_a=i+1;
            break;
        }
    }
    for(std::size_t i=0; i&lt;cloud_edge_right-&gt;size()-2; i++)
    {
        //右侧第三个点到前两个点的距离
        if(Collinear(cloud_edge_right-&gt;points[i],cloud_edge_right-&gt;points[i+1],cloud_edge_right-&gt;points[i+2]))
        {
            b_c=i+1;
            break;
        }
    }
    for(std::size_t i=0; i&lt;cloud_edge_left-&gt;size(); i++)
    {
        if(i&lt;d_a)
        {
            cv::Point2f thisPoint;
            thisPoint.x=cloud_edge_left-&gt;points[i].y;
            thisPoint.y=cloud_edge_left-&gt;points[i].z;
            pointsD.push_back(thisPoint);
        }
        else
        {
            cv::Point2f thisPoint;
            thisPoint.x=cloud_edge_left-&gt;points[i].y;
            thisPoint.y=cloud_edge_left-&gt;points[i].z;
            pointsA.push_back(thisPoint);
        }
    }
    for(std::size_t i=0; i&lt;cloud_edge_right-&gt;size(); i++)
    {
        if(i&lt;b_c)
        {
            cv::Point2f thisPoint;
            thisPoint.x=cloud_edge_right-&gt;points[i].y;
            thisPoint.y=cloud_edge_right-&gt;points[i].z;
            pointsB.push_back(thisPoint);
        }
        else
        {
            cv::Point2f thisPoint;
            thisPoint.x=cloud_edge_right-&gt;points[i].y;
            thisPoint.y=cloud_edge_right-&gt;points[i].z;
            pointsC.push_back(thisPoint);
        }
    }

    float A_k,A_b,A_r;
    float B_k,B_b,B_r;
    float C_k,C_b,C_r;
    float D_k,D_b,D_r;
    LineFitLeastFit(pointsA,A_k,A_b, A_r);
    LineFitLeastFit(pointsB,B_k,B_b, B_r);
    LineFitLeastFit(pointsC,C_k,C_b, C_r);
    LineFitLeastFit(pointsD,D_k,D_b, D_r);
    //求yoz平面交点
    cv::Point2f pointAb;
    cv::Point2f pointBc;
    cv::Point2f pointCd;
    cv::Point2f pointDa;
    intersection(pointAb, A_k, A_b, B_k, B_b);
    intersection(pointBc, B_k, B_b, C_k, C_b);
    intersection(pointCd, C_k, C_b, D_k, D_b);
    intersection(pointDa, D_k, D_b, A_k, A_b);

    //求空间点 
    SpatialPoint(pointAb,cloud_all);
    SpatialPoint(pointBc,cloud_all);
    SpatialPoint(pointCd,cloud_all);
    SpatialPoint(pointDa,cloud_all);

    //增加空间点
    addSpatialPoint(pointAb,pointBc,B_k,B_b,cloud_all);
    addSpatialPoint(pointBc,pointCd,C_k,C_b,cloud_all);
    addSpatialPoint(pointCd,pointDa,D_k,D_b,cloud_all);
    addSpatialPoint(pointDa,pointAb,A_k,A_b,cloud_all);

    // 保存边界点云和拟合点云 
    viewer.showCloud(cloud_edge);
    sleep(SLEEP);
    pcl::io::savePCDFileASCII("myEdge.pcd",*cloud_edge);
    cout&lt;&lt;"save myEdge.pcd success !!"&lt;&lt;endl;

    viewer.showCloud(cloud_all);
    sleep(SLEEP);
    pcl::io::savePCDFileASCII("myEstimate.pcd",*cloud_all);
    cout&lt;&lt;"save myEstimate.pcd success !!"&lt;&lt;endl;
}
//共线判断 (C到AB的距离)
bool  Collinear(pcl::PointXYZ A,pcl::PointXYZ C,pcl::PointXYZ B)
{
    // 三角形面积*2=叉积的模|axb|=a*b*sin(theta)
    float SABC = sqrt(((B.x - A.x)*(B.y - C.y) - (B.x - C.x)*(B.y - A.y)) * ((B.x - A.x)*(B.y - C.y) - (B.x - C.x)*(B.y - A.y))
                    + ((B.x - A.x)*(B.z - C.z) - (B.x - C.x)*(B.z - A.z)) * ((B.x - A.x)*(B.z - C.z) - (B.x - C.x)*(B.z - A.z))
                    + ((B.y - A.y)*(B.z - C.z) - (B.y - C.y)*(B.z - A.z)) * ((B.y - A.y)*(B.z - C.z) - (B.y - C.y)*(B.z - A.z)));
    //底边边长
    float lAC = sqrt((A.x - C.x)*(A.x - C.x) + (A.y - C.y)*(A.y - C.y) + (A.z - C.z)*(A.z - C.z));
    //点到直线的距离
    float ld = SABC / lAC;
    //cout&lt;&lt; "ld="&lt;&lt; ld&lt;&lt; "  ac:"&lt;&lt;lAC&lt;&lt;endl;
    if(ld&lt;0.08)
        return false;
    return true;

}

//二维直线拟合
void LineFitLeastFit(const std::vector&lt;cv::Point2f&gt; &amp;_points,float &amp; _k,float &amp; _b,float &amp; _r)
{
    //https://blog.csdn.net/jjjstephen/article/details/108053148?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3
    float B = 0.0f;
    float A = 0.0f;
    float D = 0.0f;
    float C = 0.0f;

    int N = _points.size();
    for (int i = 0; i &lt; N; i++)
    {
            B += _points[i].x;
            A += _points[i].x * _points[i].x;
            D += _points[i].y;
            C += _points[i].x * _points[i].y;
    }
    if ((N * A - B * B) == 0)
            return;
    _k = (N * C - B * D) / (N * A - B * B);
    _b = (A * D - C * B) / (N * A - B * B);
    //计算相关系数
    float Xmean = B / N;
    float Ymean = D / N;

    float tempX = 0.0f;
    float tempY = 0.0f;
    float rDenominator = 0.0;
    for (int i = 0; i &lt; N; i++)
    {
            tempX += (_points[i].x - Xmean) * (_points[i].x - Xmean);
            tempY += (_points[i].y - Ymean) * (_points[i].y - Ymean);
            rDenominator += (_points[i].x - Xmean) * (_points[i].y - Ymean);
    }

    float SigmaXY = sqrt(tempX) * sqrt(tempY);
    if (SigmaXY == 0)
            return;
    _r = rDenominator / SigmaXY;
    //cout&lt;&lt;"r:"&lt;&lt;_r&lt;&lt;endl;
}

//求平面两线交点
void intersection(cv::Point2f &amp;point ,float &amp; A_k,float &amp; A_b,float &amp; B_k,float &amp; B_b)
{
    Eigen::Matrix&lt;double,2,2&gt; A;
    A(0,0)=1;
    A(0,1)=-A_k;
    A(1,0)=1;
    A(1,1)=-B_k;
    Eigen::Matrix&lt;double,2,1&gt; B;
    B(0,0)=A_b;
    B(1,0)=B_b;

    Eigen::Matrix&lt;double,2,1&gt; xy=A.fullPivHouseholderQr().solve(B);
    point.x=xy(1,0);
    point.y=xy(0,0);
    //cout&lt;&lt;point.x&lt;&lt;"  "&lt;&lt;point.y&lt;&lt;endl;
}

//空间点估计
void  SpatialPoint(cv::Point2f &amp;point2D,pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr cloud_all)
{
    pcl::PointXYZRGB thisColor;
    thisColor.x=-(plane_B*point2D.x+plane_C*point2D.y+plane_D)/plane_A;
    thisColor.y=point2D.x;
    thisColor.z=point2D.y;
    thisColor.r=0;
    thisColor.g=255;
    thisColor.b=0;
    cloud_all-&gt;push_back(thisColor);
}

//添加空间直线上的点
void  addSpatialPoint(cv::Point2f &amp;point2A,cv::Point2f &amp;point2B,float &amp; _k,float &amp; _b,pcl::PointCloud&lt;pcl::PointXYZRGB&gt;::Ptr cloud_all)
{
    float step=0.01;
    if(point2A.x &lt; point2B.x)
    {
        for(float a=point2A.x ;a&lt;point2B.x ;a=a+step)
        {
            cv::Point2f thisPoint;
            thisPoint.x=a;
            thisPoint.y=_k*a+_b;
            SpatialPoint(thisPoint,cloud_all);
        }

    }
    else{
        for(float a=point2B.x ;a&lt;point2A.x ;a=a+step)
        {
            cv::Point2f thisPoint;
            thisPoint.x=a;
            thisPoint.y=_k*a+_b;
            SpatialPoint(thisPoint,cloud_all);
        }
    }

}

</code></pre> 
<h3><a id="_490"></a>效果</h3> 
<p><img src="https://images2.imgbox.com/eb/b7/oKdqB31n_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_495"></a>数据</h3> 
<p>下载：<a href="https://download.csdn.net/download/xx970829/85161423">https://download.csdn.net/download/xx970829/85161423</a></p> 
<p>注意：根据应用场景，需自己调整部分参数<br> 【转载请标明出处：https://blog.csdn.net/xx970829/article/details/123233029】</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/da21f503b3f779fb0903397665f2ac78/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">torchvision.datasets.CIFAR10模块使用讲解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d6ffc7849b2f335346c23f6eed76beaf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Word中调节图片统一大小</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>