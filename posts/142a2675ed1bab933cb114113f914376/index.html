<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>KVM教程（1）安装KVM与虚拟机的基本管理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="KVM教程（1）安装KVM与虚拟机的基本管理" />
<meta property="og:description" content="KVM是一个基于内核的虚拟机（kernel virtual machine），从Linux内核版本号2.6.20开始已经集成在系统之中。这样要部署虚拟机就不需要额外的软件来支持，效率更高。但是KVM只能虚拟化CPU和内存，对于磁盘、网卡等外设无法模拟，所以需要结合QEMU来模拟其他设备（QEMU虽然也可以模拟CPU和内存，但是效率没有KVM高），也因此KVM其实是QEMU-KVM。
PS：如果虚拟机有安装VirtIO半虚拟化驱动的话能提高虚拟机性能，好在主流Linux系统已经内置了相关驱动，而Windows虚拟机就需要去KVM下载相关驱动了，查询方法：
lsmod | grep virtio 一、宿主机安装KVM
1、用VMware做实验的话第一步就是开启CPU虚拟化功能
2、检查宿主机CPU虚拟化是否开启、KVM内核是否加载 egrep &#34;svm|vmx&#34; /proc/cpuinfo #查看CPU是否开启虚拟化（Inter是vmx，AMD是svm），如果过滤出的flags有内容就是已开启了 lsmod | grep kvm #查看KVM内核是否加载 3、使用yum安装KVM相关软件包 yum install qemu-kvm libvirt virt-install virt-manager bridge-utils #qemu-kvm：核心软件包，实现虚拟化 #libvirt：核心软件包，管理KVM的工具，类似VMware也是管理虚拟机的工具 #virt-install：KVM虚拟机命令行管理工具 #virt-manager：KVM虚拟机图形化管理工具，可不装 #bridge-utils：实现网卡桥接的工具 4、启动libvirtd服务（如果该服务没启动的话virt-install等工具也无法使用）。该服务启动后系统会新增一块virbr0的网卡，该网卡的地址就是虚拟机使用NAT模式时使用的地址。 systemctl enable libvirtd.service systemctl start libvirtd.service 5、为KVM创建桥接网络
KVM默认使用NAT模式来分配网络给虚拟机，在使用NAT模式时虚拟机可以访问外网，但外网无法直接访问虚拟机。所以生产环境更多是配置网桥实现桥接模式上网，让虚拟机与宿主机处于一个网段中，各自有一个自己的IP，可以把他们看成是一个局域网中的不同电脑。配置桥接模式有2种方式：
通过命令行配置桥接模式，该命令会修改配置文件实现永久生效
virsh iface-bridge eth0 br0 #把eth0网卡绑定到br0中 手动编辑配置文件实现桥接模式： vim /etc/sysconfig/network-scripts/ifcfg-br0 #为br0新建配置文件 DEVICE=br0 TYPE=Bridge #类型为桥接 BOOTPROTO=static IPADDR=192.168.1.100 #配置能上网的IP地址，通常就是之前主机的IP NETMASK=255.255.255.0 GATEWAY=192.168.1.1 NBOOT=yes vim /etc/sysconfig/network-scripts/ifcfg-eth0 #将eth0绑定到桥接网络中 DEVICE=eth0 BRIDGE=br0 #这句就是把eth0桥接到br0 ONBOOT=yes 也可以通过命令行模式配置网卡，但是一定要把这些命令写到脚本中一起执行，否则网络就断了 #!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/142a2675ed1bab933cb114113f914376/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-01T00:06:11+08:00" />
<meta property="article:modified_time" content="2021-06-01T00:06:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">KVM教程（1）安装KVM与虚拟机的基本管理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>KVM是一个基于内核的虚拟机（kernel virtual machine），从Linux内核版本号2.6.20开始已经集成在系统之中。这样要部署虚拟机就不需要额外的软件来支持，效率更高。但是KVM只能虚拟化CPU和内存，对于磁盘、网卡等外设无法模拟，所以需要结合QEMU来模拟其他设备（QEMU虽然也可以模拟CPU和内存，但是效率没有KVM高），也因此KVM其实是QEMU-KVM。</p> 
<p>PS：如果虚拟机有安装VirtIO半虚拟化驱动的话能提高虚拟机性能，好在主流Linux系统已经内置了相关驱动，而Windows虚拟机就需要去KVM下载相关驱动了，查询方法：</p> 
<pre><code>lsmod | grep virtio</code></pre> 
<p><strong>一、宿主机安装KVM</strong></p> 
<p>1、用VMware做实验的话第一步就是开启CPU虚拟化功能</p> 
<p><img alt="" src="https://images2.imgbox.com/d8/ca/7sYRZIxT_o.png"></p> 
<p>2、检查宿主机CPU虚拟化是否开启、KVM内核是否加载 </p> 
<pre><code>egrep "svm|vmx" /proc/cpuinfo  #查看CPU是否开启虚拟化（Inter是vmx，AMD是svm），如果过滤出的flags有内容就是已开启了
lsmod | grep kvm #查看KVM内核是否加载</code></pre> 
<p>3、使用yum安装KVM相关软件包 </p> 
<pre><code>yum install qemu-kvm  libvirt virt-install virt-manager bridge-utils
#qemu-kvm：核心软件包，实现虚拟化
#libvirt：核心软件包，管理KVM的工具，类似VMware也是管理虚拟机的工具
#virt-install：KVM虚拟机命令行管理工具
#virt-manager：KVM虚拟机图形化管理工具，可不装
#bridge-utils：实现网卡桥接的工具</code></pre> 
<p>4、启动libvirtd服务（如果该服务没启动的话virt-install等工具也无法使用）。该服务启动后系统会新增一块virbr0的网卡，该网卡的地址就是虚拟机使用NAT模式时使用的地址。 </p> 
<pre><code>systemctl enable libvirtd.service
systemctl start libvirtd.service</code></pre> 
<p>5、为KVM创建桥接网络</p> 
<p>KVM默认使用NAT模式来分配网络给虚拟机，在使用NAT模式时虚拟机可以访问外网，但外网无法直接访问虚拟机。所以生产环境更多是配置网桥实现桥接模式上网，让虚拟机与宿主机处于一个网段中，各自有一个自己的IP，可以把他们看成是一个局域网中的不同电脑。配置桥接模式有2种方式：</p> 
<p>通过命令行配置桥接模式，该命令会修改配置文件实现永久生效</p> 
<pre><code>virsh iface-bridge eth0 br0  #把eth0网卡绑定到br0中</code></pre> 
<p>手动编辑配置文件实现桥接模式： </p> 
<pre><code>vim /etc/sysconfig/network-scripts/ifcfg-br0    #为br0新建配置文件
DEVICE=br0
TYPE=Bridge  #类型为桥接
BOOTPROTO=static
IPADDR=192.168.1.100    #配置能上网的IP地址，通常就是之前主机的IP
NETMASK=255.255.255.0
GATEWAY=192.168.1.1
NBOOT=yes

vim /etc/sysconfig/network-scripts/ifcfg-eth0    #将eth0绑定到桥接网络中
DEVICE=eth0
BRIDGE=br0  #这句就是把eth0桥接到br0
ONBOOT=yes</code></pre> 
<p>也可以通过命令行模式配置网卡，但是一定要把这些命令写到脚本中一起执行，否则网络就断了 </p> 
<pre><code>#!/bin/bash
brctl addbr br0  #增加一块网卡
brctl addif br0 eth0  #让eth0网卡成为br0网卡的一员
ip addr del dev eth0 192.168.1.100/24  #删掉eth0的IP地址，因为BR0已经有这样的地址了
route add default gw 192.168.1.1  #增加网关</code></pre> 
<p>操作完成后查看网络信息会发现eth0已经没有IP了，而新生成的br0网卡有了对应的IP，且是UP状态。也可以通过brctl show命令查看网卡绑定关系 </p> 
<p><img alt="" src="https://images2.imgbox.com/0c/db/872xUxlv_o.png"></p> 
<p><strong>二、创建KVM虚拟机部分（</strong>在创建虚拟机之前需要使用rz或者xftp等工具上传系统镜像到服务器中，并且保证用来存放虚拟机数据的分区容量足够大，可以划分一个分区专门给虚拟机使用）</p> 
<p><strong>1、KVM磁盘管理</strong></p> 
<p>使用qume-img create命令可以为虚拟机创建磁盘（使用VMware也会有建立磁盘的步骤）并设置好磁盘大小、格式、路径，在之后的使用中KVM虚拟机的数据都将在这块磁盘里</p> 
<pre><code>qemu-img create -f qcow2 /data/kvm_disk/server1.qcow2 100G  #-f选项指定了磁盘格式
#qcow2格式：推荐格式，不会立即占用所有磁盘空间，支持快照克隆操作
#raw格式：默认格式，该格式虽然效率高，但是会立即占用磁盘空间，而且不支持快照操作</code></pre> 
<p>使用qemu-img resize命令可以对磁盘进行扩容，需要重启然后xfs_growfs才会生效，如果是ext4文件系统的话则使用resize2fs命令 </p> 
<pre><code>qemu-img resize /data/kvm_disk/server1.qcow2 150G</code></pre> 
<p>使用qemu-img info命令可以查看虚拟机磁盘格式与占用情况 </p> 
<pre><code>qemu-img info  /kvm/centos7.qcow2</code></pre> 
<p><strong>2、创建虚拟机</strong></p> 
<p>使用virt-install命令创建虚拟机（需要保证libvirtd服务已启动，否则该命令无法使用）</p> 
<p>使用光盘镜像的形式全新安装虚拟机</p> 
<pre><code>virt-install \
--virt-type kvm  #虚拟化类型，默认是qemu
--os-type=linux \  #系统类型
--os-variant rhel7  #具体操作系统
--name=centos7_test \  #虚拟机的名字
--memory=1024 \  #虚拟机的内存，以M为单位（老版本中是使用--ram）
--vcpus=2 \  #CPU核心数
--check-cpu \  #检查虚拟机CPU数量是否超过物理机
--arch=x86_64  \  #CPU架构
--disk=/kvm/centos7.qcow2 \  #虚拟机硬盘路径
--cdrom=/usr/local/src/CentOS-7-x86_64-Minimal-1708.iso \  #指定镜像路径
--network bridge=br0 \   #指定虚拟机网络为桥接网卡，默认是NAT
--graphics vnc,listen=0.0.0.0 \  #指定图形显示相关配置，默认是vnc
--noautoconsole \  #禁止自动连接虚拟机控制台
--cpu=host-passthrough  #CPU配置模式，这里使用的是将物理机的CPU暴露给虚拟机的方式

#创建命令实例
virt-install --name=kvm1 --ram=1024 --vcpus=1 --check-cpu --arch=x86_64 --os-type=linux --cdrom=/data/kvm_disk/CentOS-7-x86_64-Minimal-1804.iso --disk=/data/kvm_disk/kvm1.qcow2 --network bridge=br0 --graphics vnc,listen=0.0.0.0 --noautoconsole --cpu=host-passthrough</code></pre> 
<p>使用QCOW2磁盘镜像以导入的形式来复制克隆虚拟机 </p> 
<pre><code>virt-install \
--name=centos7_clone \  #虚拟机的名字
--ram=1024 \  #虚拟机的内存
--vcpus=2 \
--check-cpu \
--arch=x86_64  \
--os-type=linux \
--virt-type=kvm \
--disk=/kvm/centos7.qcow2 \  #导入一个已装好系统的qcow2磁盘镜像，这样可以跳过系统安装步骤
--boot hd \  #从硬盘启动
--network bridge=br0 \
--graphics vnc,listen=0.0.0.0 \
--noautoconsole \
--cpu=host-passthrough</code></pre> 
<p>上面的命令运行后可能会遇到以下报错，附上解决办法：</p> 
<p><strong>问题1</strong>：qemu: could not load PC BIOS 'bios-256k.bin'</p> 
<p>解决：安装seabios-bin组件</p> 
<pre><code>yum install seabios-bin -y</code></pre> 
<p><strong>问题2</strong>：Could not access KVM kernel module: Permission denied </p> 
<p>解决：这是明显的权限问题，修改/etc/libvirt/qemu.conf，修改user和group的用户为root，然后重启服务</p> 
<pre><code>user="root"
group="root"
service libvirtd restart</code></pre> 
<p><strong>3、使用vnc管理虚拟机</strong></p> 
<p>在本地电脑使用VNC Viewer连接虚拟机进行系统安装，VNC的端口默认从5900开始依次往后递增。假设宿主机的地址是192.168.1.100，需要连接第一个KVM虚拟机，那么就需要在VNC客户端输入192.168.1.100:5900，第二个192.168.1.100:5901，以此类推。虚拟机运行后通过ps命令可以查看对应的进程存在，如果虚拟机关闭了那端口也会消失。</p> 
<p><img alt="" src="https://images2.imgbox.com/46/6d/41f75wbZ_o.png"></p> 
<p>在使用VNC客户端访问虚拟机的时候可能会出现VNC闪退的情况，这是因为系统配色不支持导致的，解决方法：打开VNC客户端--option--Advanced--Expert--将ColourLevel默认值pal8修改为full </p> 
<p>4、在虚拟机启动后使用brctl show命令查看网络会看到在br0网卡下会生成新的vnet0虚拟网卡设备（如果启动了多个虚拟机就会生成对应数量的虚拟网卡设备）。该虚拟机的IP地址和宿主机是同一个网段中，可以正常访问外部网络 </p> 
<pre><code>virsh domiflist VM1  #查看某虚拟机的网卡设备，可以与brctl show命令的结果做对比</code></pre> 
<p><strong>三、KVM虚拟机常用管理命令</strong></p> 
<p>1、在宿主机上执行virsh list命令可以查看虚拟机运行状态</p> 
<pre><code>virsh list --all  #查看所有虚拟机的运行状态，不加--all则只能看到开机状态的主机</code></pre> 
<p>2、在宿主机上执行virsh start命令开启虚拟主机 </p> 
<pre><code>virsh start centos7_test1    #启动名为centos_test1的虚拟机</code></pre> 
<p>3、在宿主机上执行virsh shutdown命令关闭虚拟机，直接杀qemu-kvm的进程也会导致虚拟机关闭，需要注意的是要让kvm虚拟机能正常关机的话需要安装acpid这个电源控制软件，否则只能使用virsh destroy来强制断电再启动。 </p> 
<pre><code>virsh shutdown centos7_test2    #关闭一个虚拟机
virsh destroy centos7_test2  #强制断电</code></pre> 
<p>4、在宿主机上执行virsh autostart命令可以让虚拟机在宿主机重启后自动启动</p> 
<p>5、在宿主机上执行virsh edit命令可以对虚拟机配置进行修改</p> 
<pre><code>virsh edit centos7_test2    #对虚拟机做配置修改</code></pre> 
<p>6、在宿主机上执行virsh dumpxml命令导出指定KVM虚拟机的配置文件 </p> 
<pre><code>virsh dumpxml server1 &gt; /root/server1.xml</code></pre> 
<p>7、在宿主机上执行virsh domrename可以修改虚拟机名字 </p> 
<pre><code>virsh domrename old_name new_name</code></pre> 
<p>8、在宿主机上执行virsh vncdisplay可以查看每个虚拟机的VND端口号 </p> 
<pre><code>virsh vncdisplay centos1</code></pre> 
<p>9、在宿主机上执行virsh undefine命令取消指定的KVM虚拟机定义，也就是删掉该虚拟机，同理使用virsh define命令可以通过配置文件来恢复虚拟机 </p> 
<pre><code>virsh undefine server1
virsh define /root/server1.xml</code></pre> 
<p><strong>四、使用Virt-manager图形化管理虚拟机（适合没有安装图形界面的操作系统）</strong></p> 
<p>1、首先要在宿主机上安装x11以支持图形界面</p> 
<pre><code>yum install -y xorg-x11-utils xorg-x11-xinit xorg-x11-xauth xorg-x11-font-utils xorg-x11-server-utils</code></pre> 
<p>2、开启SSH隧道转发X11请求 </p> 
<pre><code>vim /etc/ssh/sshd_config
X11Forwarding yes
systemctl restart sshd</code></pre> 
<p>3、Xshell客户端需要在属性-SSH-隧道-开启X11转发，然后重新打开会话连接执行virt-manager</p> 
<p>4、安装中文字符解决乱码</p> 
<pre><code>export LANG=zh_CN.UTF-8
yum install -y dejavu-lgc-sans-fonts
yum groupinstall "Fonts" -y</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/af4f43cf0773036474eb76c648d443cb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python数据结构——单调栈和单调队列</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7efe0d865bb6de8d42e392fcbf9e798d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Z 字形变换（java版）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>