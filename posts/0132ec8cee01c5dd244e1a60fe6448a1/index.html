<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>@Autowired - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="@Autowired" />
<meta property="og:description" content="文章目录 @Autowired原理：作用：注：@Autowired和构造方法 @Autowired @Autowired是用在JavaBean中的注解，通过byType形式，用来给指定的字段或方法注入所需的外部资源
原理： 在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource(是CommonAnnotationBeanPostProcessor后置处理器处理的)或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性
我通俗的理解为：@Autowired是一个自动装配的工具，当这个注解加在某个变量上时，系统自动的去容器里找这个类型的对象，如果容器里只有一个，那个就把容器里的对象注入到该注解指定的变量的位置上（赋值）;如果容器里，这个类型的对象多于一个，则按ByName方式查找；如果容器里没有这个对象，那么会抛出异常。解决方法时，使用required=false
作用： @Autowired有什么作用呢 作为spring核心思想IOC的核心注解，我认为他的主要作用就是引入容器里已有的对象的值（它比new好的一点就是，new是创建新的，@Autowired是拿现有的，所以@Autowired能做到数据共享，而new不行）
spring是一个容器，这个容器里面有各种各样的对象，当人们想用容器里的对象时，去容器里拿现有的对象直接用。
那么什么时候能体现@Autowired的方便性呢？
当一个类的变量要被多个类使用时，且该变量的内容被多个类共享时，这个时候我们的解决办法就是：把这个要被多次使用且数据共享的类放到spring容器中，由spring容器管理它，我们使用@Autowired引入容器里的类
举个例子：
要求实现一个项目要在指定时间发布出去。方案：我首先想到的就是spring的定时任务，那么实现起来的话，我分为任务类（要做什么），任务管理类（任务调度器,添加任务,移除任务），service
在这个例子是怎么体现数据共享的呢？我们往下看 任务管理类中有一个Map存储正在运行的任务（可以理解为线程池的显示） 那我们发布完项目，这个任务应该结束掉（在线程池中移除），所以，我们需要在执行完任务，就把该任务从线程池中移除，那么就是在任务类中引入任务管理类，并做到共享线程池（map） 做法：在任务管理类上加@Component把它放到spring容器中，再任务类中某变量上加入@Autowired引入容器中的对象。
注：@Autowired和构造方法 Java变量的初始化顺序为：静态变量或静态语句块–&gt;实例变量或初始化语句块–&gt;构造方法
声明：构造方法是在@Autowired前执行。
eg:
@Autowired写在构造方法外，他的实际值为null
public class TaskRunnable implements Runnable { private String name; @Autowired private TaskManager taskManager; public TaskRunnable(String name) { this.name = name; } } 这么写才是正确的，当该类有有参构造时，@Autowired要加在构造方法上能引入容器中的对象
public class TaskRunnable implements Runnable { private String name; private TaskManager taskManager; @Autowired public TaskRunnable(String name,TaskManager taskManager) { this.name = name; this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0132ec8cee01c5dd244e1a60fe6448a1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-09T20:24:59+08:00" />
<meta property="article:modified_time" content="2022-02-09T20:24:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">@Autowired</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Autowired_1" rel="nofollow">@Autowired</a></li><li><ul><li><a href="#_5" rel="nofollow">原理：</a></li><li><a href="#_13" rel="nofollow">作用：</a></li><li><a href="#Autowired_31" rel="nofollow">注：@Autowired和构造方法</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="Autowired_1"></a>@Autowired</h2> 
<p>@Autowired是用在JavaBean中的注解，通过byType形式，用来给指定的字段或方法注入所需的外部资源</p> 
<h3><a id="_5"></a>原理：</h3> 
<p>在启动spring IoC时，容器自动装载了一个AutowiredAnnotationBeanPostProcessor后置处理器，当容器扫描到@Autowied、@Resource(是CommonAnnotationBeanPostProcessor后置处理器处理的)或@Inject时，就会在IoC容器自动查找需要的bean，并装配给该对象的属性</p> 
<p><strong>我通俗的理解为：@Autowired是一个自动装配的工具，当这个注解加在某个变量上时，系统自动的去容器里找这个类型的对象，如果容器里只有一个，那个就把容器里的对象注入到该注解指定的变量的位置上（赋值）;如果容器里，这个类型的对象多于一个，则按ByName方式查找；如果容器里没有这个对象，那么会抛出异常。解决方法时，使用required=false</strong></p> 
<h3><a id="_13"></a>作用：</h3> 
<p>@Autowired有什么作用呢 作为spring核心思想IOC的核心注解，我认为他的主要作用就是引入容器里已有的对象的值（<strong>它比new好的一点就是，new是创建新的，@Autowired是拿现有的，所以@Autowired能做到数据共享，而new不行</strong>）</p> 
<p>spring是一个容器，这个容器里面有各种各样的对象，当人们想用容器里的对象时，去容器里拿现有的对象直接用。</p> 
<p>那么什么时候能体现@Autowired的方便性呢？</p> 
<p><strong>当一个类的变量要被多个类使用时，且该变量的内容被多个类共享时</strong>，这个时候我们的解决办法就是：把这个要被<strong>多次使用且数据共享</strong>的类放到spring容器中，由spring容器管理它，我们使用@Autowired引入容器里的类</p> 
<p>举个例子：</p> 
<p>要求实现一个项目要在指定时间发布出去。方案：我首先想到的就是spring的定时任务，那么实现起来的话，我分为任务类（要做什么），任务管理类（任务调度器,添加任务,移除任务），service</p> 
<p>在这个例子是怎么体现数据共享的呢？我们往下看 任务管理类中有一个Map存储正在运行的任务（可以理解为线程池的显示） 那我们发布完项目，这个任务应该结束掉（在线程池中移除），所以，我们需要在执行完任务，就把该任务从线程池中移除，那么就是在任务类中引入任务管理类，并做到共享线程池（map） 做法：在任务管理类上加@Component把它放到spring容器中，再任务类中某变量上加入@Autowired引入容器中的对象。</p> 
<h3><a id="Autowired_31"></a>注：@Autowired和构造方法</h3> 
<p>Java变量的初始化顺序为：静态变量或静态语句块–&gt;实例变量或初始化语句块–&gt;构造方法</p> 
<p>声明：<strong>构造方法是在@Autowired前执行</strong>。</p> 
<p>eg:</p> 
<p>@Autowired写在构造方法外，他的实际值为null</p> 
<pre><code>public class TaskRunnable implements Runnable  {
    private String name;

    @Autowired
    private TaskManager taskManager;
    
    public TaskRunnable(String name) {
        this.name = name;
    }
}
</code></pre> 
<p>这么写才是正确的，当该类有有参构造时，@Autowired要加在构造方法上能引入容器中的对象</p> 
<pre><code>public class TaskRunnable implements Runnable  {
    private String name;

    private TaskManager taskManager;
    @Autowired
    public TaskRunnable(String name,TaskManager taskManager) {
        this.name = name;
        this.taskManager=taskManager;
    }
}
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c958675ca8bed089a8d5a2d9a419c3a6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LPDDR5原理简介</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8679f962bd80ebf094d3be0414ae764b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">安装Windows系统时磁盘脱机的处理方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>