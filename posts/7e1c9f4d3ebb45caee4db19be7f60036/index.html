<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>算法题：直方图和0-1矩阵中最大矩形 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="算法题：直方图和0-1矩阵中最大矩形" />
<meta property="og:description" content="前几天看到一道算法题目，看起来挺简单，就是有一个由0和1构成的矩形，然后找到这个矩形中全部元素都是1的最大子矩形，初看起来好像挺简单，但是我想半天没有想出来。上网搜了下才发现，这道题目还挺有名的，很多人都写文章探讨过，一个非常好的解法是借用一个找直方图中最大面积矩形的算法，可以用很短的代码来实现。所以我准备记述一下关于这两道题目的解法，有着一些自己的视角可供参考。
寻找直方图中的最大矩形 这道题的题目如下： Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. The largest rectangle is shown in the shaded area, which has area = 10 unit.
下面介绍一种用栈来解决的方法，快到可以达到 O(N) 。
1 首先考虑一种极端情况，所有的元素是升序的 在这种情况下我们怎么找到最大的矩形？这里先引进一种方法，我们会看到他是可以工作的。
步骤：先考察最右边也就是最大的矩形，它所能够组成的最大矩形就是自己，然后考虑倒数第二个，它所能够组成的最大矩形是自己的面积乘以2（假设矩形的宽度都为1，图画的不标准），也就是（最大位置i-当前矩形位置k&#43;1） 如下图所示 再往前数以此类推直到最小的矩形，最后所有得到的面积中的最大值就是所要求的面积。这个算法的正确性是很显然的。
有了上面那个极端情况的铺垫之后，我们理解真正的算法就简单多了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7e1c9f4d3ebb45caee4db19be7f60036/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-11-27T20:23:26+08:00" />
<meta property="article:modified_time" content="2017-11-27T20:23:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">算法题：直方图和0-1矩阵中最大矩形</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>前几天看到一道算法题目，看起来挺简单，就是有一个由0和1构成的矩形，然后找到这个矩形中全部元素都是1的最大子矩形，初看起来好像挺简单，但是我想半天没有想出来。上网搜了下才发现，这道题目还挺有名的，很多人都写文章探讨过，一个非常好的解法是借用一个找直方图中最大面积矩形的算法，可以用很短的代码来实现。所以我准备记述一下关于这两道题目的解法，有着一些自己的视角可供参考。</p> 
<h2 id="寻找直方图中的最大矩形">寻找直方图中的最大矩形</h2> 
<p>这道题的题目如下： <br> Given n non-negative integers representing the histogram’s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram. <br> <img title="" alt="这里写图片描述" src="https://images2.imgbox.com/39/06/u47fvamr_o.png"> <br> Above is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3]. <br> <img title="" alt="这里写图片描述" src="https://images2.imgbox.com/be/ca/1lPlmpL4_o.png"> <br> The largest rectangle is shown in the shaded area, which has area = 10 unit.</p> 
<p>下面介绍一种用栈来解决的方法，快到可以达到<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-1-Frame"> 
   
   <span class="math" id="MathJax-Span-1" style="width: 3.01em; display: inline-block;"><span style="width: 2.4em; height: 0px; font-size: 125%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.72em; position: absolute; clip: rect(1.81em, 1000em, 3.13em, -0.43em);"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3" style="font-family: MathJax_Math; font-style: italic;">O</span><span class="mo" id="MathJax-Span-4" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-5" style="font-family: MathJax_Math; font-style: italic;">N<span style="width: 0.08em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mo" id="MathJax-Span-6" style="font-family: MathJax_Main;">)</span></span><span style="width: 0px; height: 2.72em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.38em; overflow: hidden; vertical-align: -0.37em; border-left-color: currentColor; border-left-width: 0em; border-left-style: solid; display: inline-block;"></span></span> 
  </span><script id="MathJax-Element-1" type="math/tex">O(N)</script>。</p> 
<h4 id="1">1</h4> 
<p>首先考虑一种极端情况，所有的元素是升序的 <br> <img title="" alt="这里写图片描述" src="https://images2.imgbox.com/16/4a/PHjg1hyM_o.png"> <br> 在这种情况下我们怎么找到最大的矩形？这里先引进一种方法，我们会看到他是可以工作的。</p> 
<p><strong>步骤：</strong>先考察最右边也就是最大的矩形，它所能够组成的最大矩形就是自己，然后考虑倒数第二个，它所能够组成的最大矩形是自己的面积乘以2（假设矩形的宽度都为1，图画的不标准），也就是（最大位置i-当前矩形位置k+1） <br> 如下图所示 <br> <img title="" alt="这里写图片描述" src="https://images2.imgbox.com/e3/d4/ELmF98bF_o.png"> <br> 再往前数以此类推直到最小的矩形，最后所有得到的面积中的最大值就是所要求的面积。这个算法的正确性是很显然的。</p> 
<p>有了上面那个极端情况的铺垫之后，我们理解真正的算法就简单多了。</p> 
<p>在完整的算法中，我们要用到栈这种数据结构，对应于上面的情况，栈满了之后的不断pop()，就对应与从最右边不断往左计算的过程。但是，问题是显然的，碰到不是升序的情况怎么办？其实也简单，我们要把问题转化为已知问题，没有升序的情况，我们构造出这种情况： <br> <img title="" alt="这里写图片描述" src="https://images2.imgbox.com/7d/2c/FgjiZSeL_o.png"></p> 
<p>观察上面这种情况，我按照算法的逻辑走一遍，首先我将0压入栈（这里操作的是矩形的编号），然后比较1号矩形和0号的大小，结果比它大，那就把1压入栈，以后类推。假设现在轮到操作五号矩形了，结果发现5号比4号小。那么首先4号矩形就不可能和右边的矩形形成更大的矩形了，他能够形成的最大矩形就是它自己，所以完全可以将它弹出不用管他，也可以理解为我们需要不断把“高个”的矩形弹出，让剩下的在栈里面的矩形能够和5号这个还在外面呆着的矩形组成一组升序的矩形，然后就能够继续添加新的元素直到所有矩形都添加进去，<strong>如果所有矩形都压进栈里面栈里面是个什么情况？没错！所有序号对应的矩形都是升序的！！</strong>，然后我们就能够按照升序的经典情况处理所有的矩形。不过好像还是有点不对，有些矩形弹出了，最后算的结果对不对呢？是对的！还看上面的那幅图，假设就是只有这6个矩形，当我们要加入5的时候发现情况不对，所以就连续把4号和3号弹出，这两个是可以算出最大矩形的，然后2号矩形比5号小，那就把5号入栈，然后没了，接着5号的最大矩形就是它自己，<strong>2号的呢，用序号算（2号的面积*（5-2+1））</strong>。3，4两个矩形虽然弹出了，但是对序号的影响还在，也保证了最终结果的正确性。还有一种特殊情况就是最后一个弹出栈的矩形一定那个是最小的，所以把它的面积乘以总的矩形数就行。</p> 
<p>综上可以看出，这种算法对整个矩形高度的数组，一次压入，一次弹出，所以总的时间成本是<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-2-Frame"> 
   
   <span class="math" id="MathJax-Span-7" style="width: 3.01em; display: inline-block;"><span style="width: 2.4em; height: 0px; font-size: 125%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.72em; position: absolute; clip: rect(1.81em, 1000em, 3.13em, -0.43em);"><span class="mrow" id="MathJax-Span-8"><span class="mi" id="MathJax-Span-9" style="font-family: MathJax_Math; font-style: italic;">O</span><span class="mo" id="MathJax-Span-10" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-11" style="font-family: MathJax_Math; font-style: italic;">N<span style="width: 0.08em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mo" id="MathJax-Span-12" style="font-family: MathJax_Main;">)</span></span><span style="width: 0px; height: 2.72em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.38em; overflow: hidden; vertical-align: -0.37em; border-left-color: currentColor; border-left-width: 0em; border-left-style: solid; display: inline-block;"></span></span> 
  </span><script id="MathJax-Element-2" type="math/tex">O(N)</script>，代码放在后面，原理上是和上面一样的，只是具体的序号方面有一点差异。</p> 
<h2 id="0-1矩阵中的最大矩形">0-1矩阵中的最大矩形</h2> 
<p>0 0 1 1 0 -&gt; 0 0 1 1 0 <br> 0 0 1 1 0 -&gt; 0 0 2 2 0 <br> 1 1 0 0 0 -&gt; 1 1 0 0 0 <br> 1 1 1 0 0 -&gt; 2 2 1 0 0</p> 
<p>如同上面左图的矩形怎样找出最大的矩形？，有了上面的算法，这道题就简单多了，我们先对矩形做一个处理，第一行不变，从第二行开始，如果一个元素为0，那就不变，不为0，就变成上面的元素加1。总的作用就是统计从自己开始算上方有多少个连续的的1。然后对处理后的矩形的每一行运行上面的寻找直方图中最大连续矩形的算法，那么很显然这么求出来的就是以这一行为底最大的连续矩形，对所有行求完之后就能够得到整个矩阵的最大矩形。易知时间成本为<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-3-Frame"> 
   
   <span class="math" id="MathJax-Span-13" style="width: 4.35em; display: inline-block;"><span style="width: 3.46em; height: 0px; font-size: 125%; display: inline-block; position: relative;"><span style="left: 0em; top: -2.72em; position: absolute; clip: rect(1.81em, 1000em, 3.13em, -0.43em);"><span class="mrow" id="MathJax-Span-14"><span class="mi" id="MathJax-Span-15" style="font-family: MathJax_Math; font-style: italic;">O</span><span class="mo" id="MathJax-Span-16" style="font-family: MathJax_Main;">(</span><span class="mi" id="MathJax-Span-17" style="font-family: MathJax_Math; font-style: italic;">M<span style="width: 0.08em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mi" id="MathJax-Span-18" style="font-family: MathJax_Math; font-style: italic;">N<span style="width: 0.08em; height: 1px; overflow: hidden; display: inline-block;"></span></span><span class="mo" id="MathJax-Span-19" style="font-family: MathJax_Main;">)</span></span><span style="width: 0px; height: 2.72em; display: inline-block;"></span></span></span><span style="width: 0px; height: 1.38em; overflow: hidden; vertical-align: -0.37em; border-left-color: currentColor; border-left-width: 0em; border-left-style: solid; display: inline-block;"></span></span> 
  </span><script id="MathJax-Element-3" type="math/tex">O(MN)</script>。</p> 
<p>下面是Java代码：</p> 
<pre class="prettyprint"><code class=" hljs glsl">public class RectangleSolution {
    public <span class="hljs-keyword">int</span> LargestRectangleArea(<span class="hljs-keyword">int</span>[] height){
        <span class="hljs-keyword">if</span> (height.<span class="hljs-built_in">length</span>==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();
        <span class="hljs-keyword">int</span> i=<span class="hljs-number">1</span>, <span class="hljs-built_in">max</span> = height[<span class="hljs-number">0</span>];
        stack.push(<span class="hljs-number">0</span>);

        <span class="hljs-keyword">while</span>(i&lt; height.<span class="hljs-built_in">length</span>||(i==height.<span class="hljs-built_in">length</span>&amp;&amp; !stack.isEmpty()) ){
            <span class="hljs-keyword">if</span>(i!=height.<span class="hljs-built_in">length</span> &amp;&amp; (stack.isEmpty() ||height[i] &gt;= height[stack.peek()])){
                stack.push(i);
                i++;
            }
            <span class="hljs-keyword">else</span> {
                <span class="hljs-keyword">int</span> top  = height[stack.pop()];
                <span class="hljs-keyword">int</span> currMax = !stack.isEmpty()? top *(i - stack.peek()-<span class="hljs-number">1</span>): top *i;
                <span class="hljs-built_in">max</span> = Math.<span class="hljs-built_in">max</span>(currMax, <span class="hljs-built_in">max</span>);
            }
        }

        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;
    }

    public <span class="hljs-keyword">int</span> MaximalRectangle(<span class="hljs-keyword">int</span>[][] rec){
        <span class="hljs-keyword">int</span>[] h = new <span class="hljs-keyword">int</span>[rec[<span class="hljs-number">0</span>].<span class="hljs-built_in">length</span>];
        <span class="hljs-keyword">int</span> m = rec.<span class="hljs-built_in">length</span>;
        <span class="hljs-keyword">int</span> n = rec[<span class="hljs-number">0</span>].<span class="hljs-built_in">length</span>;
        <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span>=<span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;m;i++){
            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>;j&lt;n;j++){
                <span class="hljs-keyword">if</span> (i==<span class="hljs-number">0</span>) 
                    h[j] =rec[i][j];
                <span class="hljs-keyword">else</span> 
                    h[j] = rec[i][j]==<span class="hljs-number">0</span>? <span class="hljs-number">0</span>:rec[i-<span class="hljs-number">1</span>][j]+<span class="hljs-number">1</span>;
            }
            <span class="hljs-built_in">max</span> = Math.<span class="hljs-built_in">max</span>(<span class="hljs-built_in">max</span>, LargestRectangleArea(h));

        }

        <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>;

    }


    public static <span class="hljs-keyword">void</span> main(String[] args) {
        <span class="hljs-keyword">int</span>[][] rec = {<!-- -->{<!-- --><span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>},{<!-- --><span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>},{<!-- --><span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>},{<!-- --><span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>},{<!-- --><span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>}};
        <span class="hljs-keyword">int</span>[] test ={<!-- --><span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>};
        RectangleSolution rSolution = new RectangleSolution();
        <span class="hljs-keyword">int</span> <span class="hljs-built_in">max</span> = rSolution.MaximalRectangle(rec);
        <span class="hljs-keyword">int</span> max2 = rSolution.LargestRectangleArea(test);
        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-built_in">max</span>);
        System.<span class="hljs-keyword">out</span>.println(max2);



    }


}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/caca7b88c59f334ab97b72d38f0285fb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于MATLAB的PCA人脸识别实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2d2a46a946bc16dc276e4ef0185b7eeb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">动态内存开辟  malloc  calloc  realloc  free  函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>