<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>分布式ID生成器 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="分布式ID生成器" />
<meta property="og:description" content="0.背景 公司产品线最初为了快速上线、快速迭代，所使用的ID采用把JDK原生的32位(去掉四个-)或者36位的原始UUID(Universally Unique Identifier)缩短为19位，且不丢失精度的方式。
例如：E3MGMM6SQwsaZqHfcIs
但是UUID太长而且人类不可读（由大写、小写、数字随机组成），且对数据库性能有一定的影响（短且数字递增的最优），所以希望开发出一种全局唯一性、高性能、纯数字、较短、趋势递增的分布式ID生成器。
1.需求/设计 ID不重复、全局唯一长度简短：长度尽量保持短（最好在10位以内），方便用户转述、记录、投诉能通过ID区分业务类型，例如A开头的表示国内机票推荐使用纯数字性能要高适应分布式环境趋势递增 业界常用的ID如下所示：（作为参考）
暂定参考设计为：
2.UUID 2.1概念 UUID 含义是通用唯一识别码 (Universally Unique Identifier)，这是一个软件建构的标准。
也是被开源软件基金会 (Open Software Foundation, OSF) 的组织应用在分布式计算环境领域的一部分。
UUID 的目的，是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指定。
UUID保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。
按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字
2.2优缺点 优点：
UUID的好处是生成和使用简单、性能好、本地生成、没有高可用风险、而且在全球范围内任意分布式系统中都不会重复，不用考虑数据库主键的冲突等。缺点：
缺陷在于生成的结果串会比较长；由大写、小写、数字随机组成，人类完全不可读，不可记；在进行ID转述过程中特别容易出错；查询效率低，数据库的主键若使用数字的性能要高于字符串。 2.3一个生成19位UUID的算法 JDK自带的UUID类中toString方法其实是把128位字节转换为16进制数值，若使用62进制，既0-9a-zA-Z，这样就能缩短UUID到19位。为此，专门编写了一个UUID字符串生成法。
详见：超短的19位UUID，性能几乎翻倍提升
3.数据库自增ID 使用数据库的id自增策略，如 MySQL 的 auto_increment。并且可以使用两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。
能够保证严格有序，但是有严重的性能瓶颈。项目组最早就是使用这种方式，性能低下、吃了不少苦头。
为了解决性能低的问题，可以采用批量生成ID的方式缓解。
主要思想为：一次按需批量生成多个ID，每次生成都需要访问数据库，将数据库修改为最大的ID值，并在内存中记录当前值及最大值。
4.类snowflake方案 1bit:一般是符号位，不做处理41bit:用来记录时间戳，这里可以记录69年，如果设置好起始时间比如今年是2018年，那么可以用到2089年，到时候怎么办？要是这个系统能用69年，我相信这个系统早都重构了好多次了。10bit:10bit用来记录机器ID，总共可以记录1024台机器，一般用前5位代表数据中心，后面5位是某个数据中心的机器ID12bit:循环位，用来对同一个毫秒之内产生不同的ID，12位可以最多记录4095个，也就是在同一个机器同一毫秒最多记录4095个，多余的需要进行等待下毫秒。 优点：
毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。
生成ID的性能也是非常高的。
可以根据自身业务特性分配bit位，非常灵活。
缺点：
强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。
上面只是方案和思路，需要落地实现
详见：ID 生成器 雪花算法
5.Leaf——美团点评分布式ID生成系统 Leaf是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。
详见：Leaf——美团点评分布式ID生成系统
6.百度UidGenerator(项目中最终使用该方案) UidGenerator是Java实现的, 基于Snowflake算法的唯一ID生成器。
UidGenerator通过借用未来时间来解决sequence天然存在的并发限制; 采用RingBuffer来缓存已生成的UID, 并行化UID的生产和消费, 同时对CacheLine补齐，避免了由RingBuffer带来的硬件级「伪共享」问题. 最终单机QPS可达600万
依赖版本：Java8及以上版本, MySQL(内置WorkerID分配器, 启动阶段通过DB进行分配; 如自定义实现, 则DB非必选依赖）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2a103737e8721b1872023634d33141a1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-06-12T22:40:24+08:00" />
<meta property="article:modified_time" content="2019-06-12T22:40:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">分布式ID生成器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="0_0"></a>0.背景</h3> 
<p>公司产品线最初为了快速上线、快速迭代，所使用的ID采用把JDK原生的32位(去掉四个-)或者36位的原始UUID(Universally Unique Identifier)缩短为19位，且不丢失精度的方式。</p> 
<p>例如：<code>E3MGMM6SQwsaZqHfcIs</code></p> 
<p>但是UUID太长而且人类不可读（由大写、小写、数字随机组成），且对数据库性能有一定的影响（短且数字递增的最优），所以希望开发出一种全局唯一性、高性能、纯数字、较短、趋势递增的分布式ID生成器。</p> 
<h3><a id="1_7"></a>1.需求/设计</h3> 
<ul><li>ID不重复、全局唯一</li><li>长度简短：长度尽量保持短（最好在10位以内），方便用户转述、记录、投诉</li><li>能通过ID区分业务类型，例如A开头的表示国内机票</li><li>推荐使用纯数字</li><li>性能要高</li><li>适应分布式环境</li><li>趋势递增</li></ul> 
<p>业界常用的ID如下所示：（作为参考）<br> <img src="https://images2.imgbox.com/ff/1a/XLAidxbF_o.png" alt="在这里插入图片描述"><br> 暂定参考设计为：<br> <img src="https://images2.imgbox.com/5e/9a/hF9N5s41_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2UUID_20"></a>2.UUID</h3> 
<h5><a id="21_21"></a>2.1概念</h5> 
<p>UUID 含义是通用唯一识别码 (Universally Unique Identifier)，这是一个软件建构的标准。<br> 也是被开源软件基金会 (Open Software Foundation, OSF) 的组织应用在分布式计算环境领域的一部分。<br> UUID 的目的，是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指定。</p> 
<p>UUID保证对在同一时空中的所有机器都是唯一的。通常平台会提供生成的API。<br> 按照开放软件基金会(OSF)制定的标准计算，用到了以太网卡地址、纳秒级时间、芯片ID码和许多可能的数字</p> 
<h5><a id="22_28"></a>2.2优缺点</h5> 
<ul><li>优点：<br> UUID的好处是生成和使用简单、性能好、本地生成、没有高可用风险、而且在全球范围内任意分布式系统中都不会重复，不用考虑数据库主键的冲突等。</li><li>缺点：<br> 缺陷在于生成的结果串会比较长；由大写、小写、数字随机组成，人类完全不可读，不可记；在进行ID转述过程中特别容易出错；查询效率低，数据库的主键若使用数字的性能要高于字符串。</li></ul> 
<h5><a id="2319UUID_34"></a>2.3一个生成19位UUID的算法</h5> 
<p>JDK自带的UUID类中toString方法其实是把128位字节转换为16进制数值，若使用62进制，既0-9a-zA-Z，这样就能缩短UUID到19位。为此，专门编写了一个UUID字符串生成法。<br> 详见：<a href="https://www.iteye.com/topic/1134781">超短的19位UUID，性能几乎翻倍提升</a></p> 
<h3><a id="3ID_38"></a>3.数据库自增ID</h3> 
<p>使用数据库的id自增策略，如 MySQL 的 auto_increment。并且可以使用两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。<br> 能够保证严格有序，但是有严重的性能瓶颈。项目组最早就是使用这种方式，性能低下、吃了不少苦头。</p> 
<p>为了解决性能低的问题，可以采用批量生成ID的方式缓解。<br> 主要思想为：一次按需批量生成多个ID，每次生成都需要访问数据库，将数据库修改为最大的ID值，并在内存中记录当前值及最大值。</p> 
<h3><a id="4snowflake_45"></a>4.类snowflake方案</h3> 
<p><img src="https://images2.imgbox.com/be/20/NM0upmv1_o.png" alt="在这里插入图片描述"></p> 
<ul><li>1bit:一般是符号位，不做处理</li><li>41bit:用来记录时间戳，这里可以记录69年，如果设置好起始时间比如今年是2018年，那么可以用到2089年，到时候怎么办？要是这个系统能用69年，我相信这个系统早都重构了好多次了。</li><li>10bit:10bit用来记录机器ID，总共可以记录1024台机器，一般用前5位代表数据中心，后面5位是某个数据中心的机器ID</li><li>12bit:循环位，用来对同一个毫秒之内产生不同的ID，12位可以最多记录4095个，也就是在同一个机器同一毫秒最多记录4095个，多余的需要进行等待下毫秒。</li></ul> 
<p>优点：<br> 毫秒数在高位，自增序列在低位，整个ID都是趋势递增的。<br> 生成ID的性能也是非常高的。<br> 可以根据自身业务特性分配bit位，非常灵活。</p> 
<p>缺点：<br> 强依赖机器时钟，如果机器上时钟回拨，会导致发号重复或者服务会处于不可用状态。<br> 上面只是方案和思路，需要落地实现</p> 
<p>详见：<a href="https://blog.csdn.net/wangming520liwei/article/details/80843248">ID 生成器 雪花算法</a></p> 
<h3><a id="5LeafID_62"></a>5.Leaf——美团点评分布式ID生成系统</h3> 
<p>Leaf是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。<br> 详见：<a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" rel="nofollow">Leaf——美团点评分布式ID生成系统</a></p> 
<h3><a id="6UidGenerator_65"></a>6.百度UidGenerator(项目中最终使用该方案)</h3> 
<p>UidGenerator是Java实现的, 基于Snowflake算法的唯一ID生成器。<br> UidGenerator通过借用未来时间来解决sequence天然存在的并发限制; 采用RingBuffer来缓存已生成的UID, 并行化UID的生产和消费, 同时对CacheLine补齐，避免了由RingBuffer带来的硬件级「伪共享」问题. 最终单机QPS可达600万<br> 依赖版本：Java8及以上版本, MySQL(内置WorkerID分配器, 启动阶段通过DB进行分配; 如自定义实现, 则DB非必选依赖）<br> 详见：<a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">baidu/uid-generator</a></p> 
<h3><a id="7_RedisID_70"></a>7. Redis生成ID</h3> 
<p>Redis的所有命令操作都是单线程的，本身提供像 incr 和 increby 这样的自增原子命令，所以能保证生成的 ID 肯定是唯一有序的<br> 类似数据库自增ID，性能优于数组库自增</p> 
<h3><a id="8_73"></a>8.参考文献</h3> 
<ul><li><a href="https://www.jianshu.com/p/61817cf48cc3" rel="nofollow">全局唯一ID设计</a></li><li><a href="https://juejin.im/post/5b3a23746fb9a024e15cad79" rel="nofollow">分布式唯一ID的几种生成方案</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651960245&amp;idx=1&amp;sn=5cef3d8ca6a3e6e94f61e0edaf985d11&amp;chksm=bd2d06698a5a8f7fc89056af619b9b7e79b158bceb91bdeb776475bc686721e36fb925904a67&amp;mpshare=1&amp;scene=23&amp;srcid=0627tlxFe54jtvb2Ju57eIc2#rd" rel="nofollow">分布式ID生成器 | 架构师之路</a></li><li><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html" rel="nofollow">Leaf——美团点评分布式ID生成系统</a></li><li><a href="https://github.com/baidu/uid-generator/blob/master/README.zh_cn.md">baidu/uid-generator</a></li><li><a href="https://www.cnblogs.com/yeyang/p/10226284.html" rel="nofollow">百度开源分布式id生成器uid-generator源码剖析</a></li><li><a href="https://github.com/wujun234/uid-generator-spring-boot-starter">uid-generator-spring-boot-starter</a></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0ce43229f3f40baa8b1e71873d65ec6e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">连接共享打印机出现0x000000bcb问题的解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/81ab1febd5adf10055dc41d0f1d9c57b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">免费获取省市县的shp，geojson文件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>