<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【计算机网络】3数据链路层 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【计算机网络】3数据链路层" />
<meta property="og:description" content="文章目录 前言一、数据链路层设计数据链路层功能成帧差错控制 二、差错检测和纠正纠错码检错码 三、基本数据链路层协议乌托邦式单工协议（协议1）无错信道上的单工停等协议（协议2）有错信道上的单工停-等式协议（协议3） 四、滑动窗口协议一位滑动窗口协议(协议4)回退N协议(协议5)选择重传协议(协议6) 前言 DLL层设计问题
检错和纠错
数据链路层的协议 滑动窗口
数据链路层协议实例
一、数据链路层设计 数据链路层使用物理层提供的服务在通信信道上发送和接收比特。
数据链路层功能 (1)向网络层提供一个定义良好的服务接口。
(2)处理传输错误。
(3)调节数据流，确保慢速的接收方不会被快速的发送方淹没。
数据包和帧的关系：
提供给网络层的服务：
无确认的无连接服务有确认的无连接服务有确认的有连接服务无确认式指接收方在收到数据帧后无需发回一个确认无连接服务是指在数据传输前无需建立逻辑链路使用前不建立连接即不建立数据链路，但每帧传输必须得到确认，如果没有得到确认，将重传使用前先建立连接，即先建立数据链路，并且每帧的传输必须得到确认无确认并非不可靠，可靠性由上层协议负责适用于信号传播延时较大、线路状态不一定很可靠时适用于长距离不可靠的链路局域网、实时通信无线通信卫星信道、长途电话 成帧 数据链路层使用物理层提供的服务，物理层处理的是位流，数据链路层处理的是帧
为检测错误/纠正错误，将比特流拆成离散的帧，就叫成帧。
(1)字节计数法。
利用头部中的一个字段来标识该帧中的字符数。当接收方的数据链路层看到字符计数值时，它就知道后面跟着多少个字节，因此也就知道了该帧在哪里结束。
优点： 简单
缺点： 出错无法恢复，很少使用
(2）字节填充的标志字节法。
(3)比特填充的标志比特法。
这是一种面向二进制位的帧格式，把所有需传输的数据以比特位一字排开并以特殊的位模式01111110作为帧标志，即一个帧的开始（同时标志前一个帧的结束）
当帧内容中出现一个与帧标志相同的位串01111110，则在5个1后插入一0，即变成01111101，接收方将自动删除第5个1后的0。这称为位填充法，也称为透明传输。
如果由于干扰，一个帧没有正确接收，则可扫描接收串，一旦扫描到01111110，即新的一帧从此开始。即可以再同步
(4）物理层编码违禁法。
在曼切斯特编码中，连续高电平或连续低电平可用作帧边界
采用冗余编码技术，如曼切斯特编码，即两个脉冲宽来表示一个二进制位
数据0：低-高电平对
数据1：高-低电平对
高-高电平对和低-低电平对没有使用，可用作帧边界
差错控制 差错控制： 帧的校验
接收端对帧的确认（确认帧)
超时与重发（计时器)
帧的序号
流量控制： 基于反馈的流控
基于速率的流控（发送端确定，在DLL中几乎不采用)
差错类型：
单个错误突发错误分散在各块集中在各块 突发错误优点： 从优势方面来看，计算机数据总是成块发送。
突发错误缺点： 突发错误的缺点在于当它们发生时比单个错误更难以纠正。
二、差错检测和纠正 纠错码： 前向纠错技术，因其需要太多的冗余位，纠错开销太大，在有线网络中极少使用，主要用于无线网络中。
检错码 ： 只能发现错误，不能纠正，可重传，主要用于局域网
码字： 包含数据位和校验位的n位单元（模式）
海明距离： 两个码字不同位的海明距离
int x=mazi1&amp;mazi2; int distance = 0; while(x){ distance&#43;&#43;; x -= x &amp; -x; } 海明距离越大，纠错能力越强，有效信息越少，传输效率越低" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/daaba732ced8c872f2696d7566c14e5f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-24T20:45:55+08:00" />
<meta property="article:modified_time" content="2021-11-24T20:45:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【计算机网络】3数据链路层</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_7" rel="nofollow">前言</a></li><li><a href="#_18" rel="nofollow">一、数据链路层设计</a></li><li><ul><li><a href="#_22" rel="nofollow">数据链路层功能</a></li><li><a href="#_37" rel="nofollow">成帧</a></li><li><a href="#_65" rel="nofollow">差错控制</a></li></ul> 
  </li><li><a href="#_80" rel="nofollow">二、差错检测和纠正</a></li><li><ul><li><a href="#_97" rel="nofollow">纠错码</a></li><li><a href="#_117" rel="nofollow">检错码</a></li></ul> 
  </li><li><a href="#_132" rel="nofollow">三、基本数据链路层协议</a></li><li><ul><li><a href="#1_181" rel="nofollow">乌托邦式单工协议（协议1）</a></li><li><a href="#2_211" rel="nofollow">无错信道上的单工停等协议（协议2）</a></li><li><a href="#3_248" rel="nofollow">有错信道上的单工停-等式协议（协议3）</a></li></ul> 
  </li><li><a href="#_313" rel="nofollow">四、滑动窗口协议</a></li><li><ul><li><a href="#4_317" rel="nofollow">一位滑动窗口协议(协议4)</a></li><li><a href="#N5_342" rel="nofollow">回退N协议(协议5)</a></li><li><a href="#6_346" rel="nofollow">选择重传协议(协议6)</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr color="#000000" size='1"'> 
<h2><a id="_7"></a>前言</h2> 
<p><font color="#999AAA">DLL层设计问题<br> 检错和纠错<br> 数据链路层的协议 滑动窗口<br> 数据链路层协议实例<br> </font></p> 
<hr color="#000000" size='1"'> 
<h2><a id="_18"></a>一、数据链路层设计</h2> 
<p><img src="https://images2.imgbox.com/7a/91/4K5wHLUs_o.png" alt="在这里插入图片描述"></p> 
<p><font color="#999AAA">数据链路层使用物理层提供的服务在通信信道上发送和接收比特。</font></p> 
<h3><a id="_22"></a>数据链路层功能</h3> 
<p>(1)向网络层提供一个定义良好的服务接口。<br> (2)处理传输错误。<br> (3)调节数据流，确保慢速的接收方不会被快速的发送方淹没。<br> <img src="https://images2.imgbox.com/4f/5e/aKLEz3LO_o.png" alt="在这里插入图片描述"><br> <strong>数据包和帧的关系：</strong></p> 
<p><img src="https://images2.imgbox.com/fa/66/6guDGi3V_o.png" alt="数据包和帧的关系"><br> <strong>提供给网络层的服务：</strong></p> 
<table><thead><tr><th>无确认的无连接服务</th><th>有确认的无连接服务</th><th>有确认的有连接服务</th></tr></thead><tbody><tr><td>无确认式指接收方在收到数据帧后<code>无需</code>发回一个确认无连接服务是指在数据传输前<code>无需</code>建立逻辑链路</td><td>使用前<code>不建立</code>连接即不建立数据链路，但每帧传输<code>必须得到确认</code>，如果没有得到确认，将重传</td><td>使用前先<code>建立</code>连接，即先建立数据链路，并且每帧的传输<code>必须得到确认</code></td></tr><tr><td>无确认并非不可靠，可靠性由上层协议负责</td><td>适用于信号传播延时较大、线路状态不一定很可靠时</td><td>适用于长距离不可靠的链路</td></tr><tr><td>局域网、实时通信</td><td>无线通信</td><td>卫星信道、长途电话</td></tr></tbody></table> 
<h3><a id="_37"></a>成帧</h3> 
<p><font color="#999AAA">数据链路层使用物理层提供的服务，物理层处理的是位流，数据链路层处理的是帧</font><br> 为检测错误/纠正错误，将比特流拆成离散的帧，就叫成帧。<br> <strong>(1)字节计数法。</strong><br> <font color="#999AAA">利用头部中的一个字段来标识该帧中的字符数。当接收方的数据链路层看到字符计数值时，它就知道后面跟着多少个字节，因此也就知道了该帧在哪里结束。</font></p> 
<p><img src="https://images2.imgbox.com/53/ce/YoeaqiiA_o.png" alt="在这里插入图片描述"><br> <strong>优点：</strong> 简单<br> <strong>缺点：</strong> 出错无法恢复，很少使用<br> <br> <strong>(2）字节填充的标志字节法。</strong><br> <img src="https://images2.imgbox.com/3b/34/CDyRSEAN_o.png" alt="在这里插入图片描述"></p> 
<p><strong>(3)比特填充的标志比特法。</strong><br> <em><font color="#999AAA"><br> 这是一种面向二进制位的帧格式，把所有需传输的数据以比特位一字排开并以特殊的位模式01111110作为帧标志，即一个帧的开始（同时标志前一个帧的结束）<br> 当帧内容中出现一个与帧标志相同的位串01111110，则在5个1后插入一0，即变成01111101，接收方将自动删除第5个1后的0。这称为<code>位填充法</code>，也称为<code>透明传输</code>。<br> 如果由于干扰，一个帧没有正确接收，则可扫描接收串，一旦扫描到01111110，即新的一帧从此开始。即可以再同步</font></em></p> 
<p><img src="https://images2.imgbox.com/1e/bf/brFzddmQ_o.png" alt="在这里插入图片描述"></p> 
<p><strong>(4）物理层编码违禁法。</strong><br> <em><font color="#999AAA">在曼切斯特编码中，连续高电平或连续低电平可用作帧边界<br> 采用冗余编码技术，如曼切斯特编码，即两个脉冲宽来表示一个二进制位<br> 数据0：低-高电平对<br> 数据1：高-低电平对<br> 高-高电平对和低-低电平对没有使用，可用作帧边界</font></em></p> 
<h3><a id="_65"></a>差错控制</h3> 
<p><strong>差错控制：</strong> 帧的校验<br>           接收端对帧的确认（确认帧)<br>           超时与重发（计时器)<br>           帧的序号<br> <strong>流量控制：</strong> 基于反馈的流控<br>           基于速率的流控（发送端确定，在DLL中几乎不采用)<br> <strong>差错类型：</strong></p> 
<table><thead><tr><th>单个错误</th><th>突发错误</th></tr></thead><tbody><tr><td>分散在各块</td><td>集中在各块</td></tr></tbody></table> 
<p><strong>突发错误优点：</strong> 从优势方面来看，计算机数据总是成块发送。<br> <strong>突发错误缺点：</strong> 突发错误的缺点在于当它们发生时比单个错误更难以纠正。</p> 
<h2><a id="_80"></a>二、差错检测和纠正</h2> 
<p><strong>纠错码：</strong> 前向纠错技术，因其需要太多的冗余位，纠错开销太大，在有线网络中极少使用，主要用于无线网络中。<br> <strong>检错码 ：</strong> 只能发现错误，不能纠正，可重传，主要用于局域网<br> <strong>码字：</strong> 包含数据位和校验位的n位单元（模式）<br> <strong>海明距离：</strong> 两个码字不同位的海明距离</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> x<span class="token operator">=</span>mazi1<span class="token operator">&amp;</span>mazi2<span class="token punctuation">;</span>
<span class="token keyword">int</span> distance <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	distance<span class="token operator">++</span><span class="token punctuation">;</span>
	x <span class="token operator">-=</span> x <span class="token operator">&amp;</span> <span class="token operator">-</span>x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font color="#999AAA">海明距离越大，纠错能力越强，有效信息越少，传输效率越低<br> 海明距离d+1，可检测d位错，海明距离2d+1，可纠正d位错<br> <em>例：奇偶校验海明距离为2，1个比特错误可检测出来，两个比特错误，不能检测出错。</em></font></p> 
<h3><a id="_97"></a>纠错码</h3> 
<p><strong>纠一位错的海明码：</strong><br> <strong>发送方：</strong> 根据校验集合填充校验位，数据直接填入数据位<br> <img src="https://images2.imgbox.com/1b/46/43zmRcDj_o.png" alt="在这里插入图片描述"><br> <strong>校验位：</strong> 1，2，4，8，16，32,…<br> <strong>数据位：</strong> 3，5，6，7，9，10，…<br> <strong>校验位1校验的集合为：</strong> 1，3，5，7，9，…<br> <strong>校验位2校验的集合为：</strong> 2，3，6，7,10,11，…<br> <strong>校验位3校验的集合为：</strong> 4，5，6，7,12,…<br> 例：发送数据1001000，m=7，计算得r=4，校验位为1，2，4，8<br> <img src="https://images2.imgbox.com/8b/4f/vnyP2c4w_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/25/07/JhakEeCa_o.png" alt="在这里插入图片描述"><br> 则发送数据为<mark>00</mark>1<mark>1</mark>001<mark>0</mark>000<br> <strong>接受端纠正海明码：</strong><br> <strong>接收方：</strong> 根据检验集合判定校验位是否出错，出错位的位编号累加到计数器<br> 将计数器counter=0，将校验位校验集合进行奇/偶校验，出错则counter加上校验位的编号，counter的值则是出错位的编号（counter=0无错误）<br> <em><font color="#999AAA">例:分析得到11位错了，正确码00111000101</font></em><br> <img src="https://images2.imgbox.com/d6/81/JZ28n06S_o.png" alt="在这里插入图片描述"><br> <strong>利用海明码纠正突发错误：</strong> 将连续的k个码按行排列成矩阵发送数据时，按列发送，每列k位，如果一个突发性错误长度是k位，则在k个码字中，至多只有一位受到影响，正好可用海明码纠错改位后恢复<br> <img src="https://images2.imgbox.com/4a/6d/5QCdHTuB_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_117"></a>检错码</h3> 
<p><strong>奇偶校验：</strong><br> 奇偶位取值等同于对数据位进行模2和运算<br> 例如，采用偶校验：发方1110000-&gt;1110000<mark>1</mark><br> 检测出错的概率为50%<br> <strong>循环冗余检错码CRC：</strong><br> <strong>工作原理</strong>：k位的帧等于k-1次多项式<br> 例如：1011001 -&gt; x<sup>6</sup>+x<sup>4</sup>+x<sup>3</sup> +x<sup>0</sup>（6阶7项多项式）<br> <strong>生成多项式:</strong> G(x)为r阶<br> 例如：x<sup>4</sup> +1-&gt;1001为4阶<br> <strong>m位帧的多项式：</strong> m&gt;r,M(x)&gt;G(x)<br> <font color="#999AAA">T(x)=x<sup>r</sup> M(x)（相当于在原码字后加r个0）<br> 如T(x)/G(x) = Q(x) + R(x)/G(x) 其中Q(x)为商，R(x)/G(x)为余数则( T(x) -R(x) )一定能被G(x)整除，即余数为0</font><br> <strong>发送方码字：</strong> 被除数减去模2除法的余数<br> <strong>接收方：</strong> 判断余数是否为0，为0（正确），不为0（错误）</p> 
<h2><a id="_132"></a>三、基本数据链路层协议</h2> 
<p><img src="https://images2.imgbox.com/60/48/5ZJr7kyi_o.png" alt="在这里插入图片描述"><br> <strong>假设：</strong><br> <font color="#999AAA">物理层、数据链路层和网络层各自是独立的处理进程<br> 机器A希望向B发送的是一个可靠的、面向连接的长数据流<br> 假设机器不会崩溃<br> 从网络层拿到的数据是纯数据</font><br> <strong>最简单的三个协议：</strong></p> 
<table><tbody><tr><td>无限制的单工协议</td><td>单工停-等协议</td><td>有噪声信道的单工协议</td></tr><tr><td colspan="3">信号的传播在某时刻是单向的，即单工</td></tr><tr><td>处理的是“完美”的传输 环境一 “ 乌托邦” 协议 </td><td>做简单的流控 防止接收方被数据所淹没 </td><td>解决噪声信道带来的错误 引出肯定确认技术 </td></tr></tbody></table> 
<p><strong>帧结构：</strong></p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	frame_kind kind<span class="token punctuation">;</span><span class="token comment">//帧类型</span>
	seq_nr seq<span class="token punctuation">;</span><span class="token comment">//顺序号</span>
	seq_nr ack <span class="token punctuation">;</span><span class="token comment">//确认号</span>
	packet info<span class="token punctuation">;</span><span class="token comment">//分组（分组是帧的纯数据）</span>
	<span class="token punctuation">}</span> frame<span class="token punctuation">;</span>
</code></pre> 
<p><strong>与物理层、网络层接口：</strong></p> 
<p><img src="https://images2.imgbox.com/a2/b7/RHshLuHL_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="1_181"></a>乌托邦式单工协议（协议1）</h3> 
<p>数据单向传送<br> 收发双方的网络层都处于就绪状态（<code>随时待命</code>)处理时间忽略不计（<code>瞬间完成</code>)<br> 可用的缓存空间无穷大（<code>无限空间</code>)<br> 假设DLL之间的信道永远不会损坏或者丢失帧（<code>完美通道</code>)<br> “乌托邦”</p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{<!-- --></span>frame_arrival<span class="token punctuation">}</span> event_type<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"protocol.h"</span></span>
<span class="token keyword">void</span> <span class="token function">sender1</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//封装</span>
<span class="token punctuation">{<!-- --></span>
	frame s<span class="token punctuation">;</span>
	packet buffer<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">from_network_layer</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">)</span> <span class="token punctuation">;</span>
		s<span class="token punctuation">.</span>info <span class="token operator">=</span> buffer<span class="token punctuation">;</span>
		<span class="token function">to_physical_layer</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">receiver1</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//解封装</span>
<span class="token punctuation">{<!-- --></span>
	frame r<span class="token punctuation">;</span>
	event_type event<span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">wait_for_event</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">from_physical_layer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token function">to_network_layer</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>r <span class="token punctuation">.</span>info<span class="token punctuation">)</span> <span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="2_211"></a>无错信道上的单工停等协议（协议2）</h3> 
<p>解决如何避免收方被涌入的数据淹没，即取<br> 消“接收方允许无限量接收”的假设<br> 解决方法：收方回发一个<code>哑帧</code>，接收方收到<br> 哑帧，表明收方允许接收数据，此时再次发<br> 送下一帧数据。<br> 实际上是半双工协议</p> 
<pre><code class="prism language-c"><span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{<!-- --></span>frame_arrival <span class="token punctuation">}</span> event_type<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"protocol .h"</span></span>
<span class="token keyword">void</span> <span class="token function">sender2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	frame s<span class="token punctuation">;</span><span class="token comment">/*buffer for an outbound frame */</span>
	packet buffer <span class="token punctuation">;</span><span class="token comment">/*buffer for an outbound packet */</span>
	event_type event <span class="token punctuation">;</span><span class="token comment">/*frame_arrival is the only possibility */</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">from_network_1ayer</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">/*go get something to send */</span>
		s<span class="token punctuation">.</span>info <span class="token operator">=</span> buffer<span class="token punctuation">;</span><span class="token comment">/*copy it into s for transmission */</span>
		<span class="token function">to_physical_layer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*bye-bye little frame */</span>
		<span class="token comment">//-----------------------------------------------------------------------------</span>
		<span class="token function">wait_for_event</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">/*do not proceed until given the go ahead*/</span>
		<span class="token comment">//-----------------------------------------------------------------------------</span>
		
<span class="token keyword">void</span> <span class="token function">receiver2</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	frame r<span class="token punctuation">,</span>s<span class="token punctuation">;</span><span class="token comment">/*buffers for frames */</span>
	event_type event<span class="token punctuation">;</span><span class="token comment">/*frame_arrival is the only possibility */</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		<span class="token function">wait_for_event</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*only possibility is frame_arrival */</span>
		<span class="token function">from_physical_layer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*go get the inbound frame */</span>
		<span class="token function">to_network_layer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">.</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*pass the data to the network layer */</span>
		<span class="token comment">//-----------------------------------------------------------------------------</span>
		<span class="token function">to_physical_layer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*send a dummy frame to awaken sender * /
		//-----------------------------------------------------------------------------
</span></code></pre> 
<h3><a id="3_248"></a>有错信道上的单工停-等式协议（协议3）</h3> 
<p><strong>异常：</strong> 发送方发出的数据丢失，收方发送的确认帧丢失导致发送方一直等待<br> <strong>解决：</strong> 发送方设置定时器，一定时间未收到答复，则重发。<br> <strong>异常：</strong> 定时器设置时间过短导致，发送方重复发送帧，接收方无法区别<br> <strong>解决：</strong> 设置帧序号，用于排序</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_SEQ1</span><span class="token comment">/*must be 1 for protocol 3 */</span></span>
<span class="token keyword">typedef</span> <span class="token keyword">enum</span> <span class="token punctuation">{<!-- --></span>frame_arrival<span class="token punctuation">,</span>cksum_err<span class="token punctuation">,</span>timeout <span class="token punctuation">}</span> event_type<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"protocol .h"</span></span>
<span class="token keyword">void</span> <span class="token function">sender3</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	seq_nr next_frame_to_send<span class="token punctuation">;</span><span class="token comment">/*seg number of next outgoing frame*/</span>
	frame s<span class="token punctuation">;</span><span class="token comment">/*scratch variable */</span>
	packet buffer<span class="token punctuation">;</span><span class="token comment">/*buffer for an outbound packet*/</span>
	event_type event<span class="token punctuation">;</span>
	next_frame_to_send <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">/* initialize outbound sequence numbers */</span>
	<span class="token function">from_network_layer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>buffer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* fetch first packet */</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		s <span class="token punctuation">.</span>info <span class="token operator">=</span>buffer<span class="token punctuation">;</span><span class="token comment">/*construct a frame for transmission */</span>
		s<span class="token punctuation">.</span>seq<span class="token operator">=</span> next_frame_to_send<span class="token punctuation">;</span><span class="token comment">/*insert sequence number in frame */</span>
		<span class="token function">to_physical_layer</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">/*send it on its way */</span>
		<span class="token comment">//-----------------------------------------------------------------------------</span>
		<span class="token function">start_timer</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span> seq<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*if answer takes too long. time out*/</span>
		<span class="token comment">//-----------------------------------------------------------------------------</span>
		<span class="token function">wait_for_event</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">/*frame arrival, cksum_err,timeout*/</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>event <span class="token operator">==</span> frame_arrival<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			from_ <span class="token function">physical_layer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*get the acknowledgement*/</span>
			<span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>ack <span class="token operator">==</span> next_frame_to_send<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
			<span class="token comment">//-----------------------------------------------------------------------------</span>
			<span class="token function">stop_timer</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>ack<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">/*turn the timer off */</span>
			<span class="token comment">//-----------------------------------------------------------------------------</span>
			<span class="token function">from_network_layer</span> <span class="token punctuation">(</span> <span class="token operator">&amp;</span>buffer<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">/*get the next one to send*/</span>
			<span class="token function">inc</span> <span class="token punctuation">(</span>next_frame_to_send<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">/*invert next_frame_to send*/</span>
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">receiver3</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	seq_nr frame_expected<span class="token punctuation">;</span>
	frame r<span class="token punctuation">,</span>s<span class="token punctuation">;</span>
	event_type event<span class="token punctuation">;</span>
	frame_expected <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span>true<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token function">wait_for_event</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>event） <span class="token punctuation">;</span><span class="token comment">/*possibilities: frame_arrival, cksum_err */</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>event <span class="token operator">==</span> frame_arrival<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">/*a valia frame has arrived */</span>
			from <span class="token function">physical_layer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">/*go get the newly arrived frame */</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>r<span class="token punctuation">.</span>seq <span class="token operator">==</span> frame_expected<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token comment">/*this is what we have been waiting for */</span>
				<span class="token function">to_network_layer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">.</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/*pass the data to the net work layer */</span>
				<span class="token function">inc</span><span class="token punctuation">(</span>frame_expected<span class="token punctuation">)</span> <span class="token punctuation">;</span><span class="token comment">/*next time expect the other sequence nr */</span>
			<span class="token punctuation">}</span>
		<span class="token comment">//-----------------------------------------------------------------------------</span>
		s<span class="token punctuation">.</span>ack <span class="token operator">=</span><span class="token number">1</span> <span class="token operator">-</span> frame_expected<span class="token punctuation">;</span>
		<span class="token function">to_physical_layer</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token comment">//-----------------------------------------------------------------------------</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>提高传输效率：</strong><br> 全双工<br> 捎带确认（和外发的数据帧一起）<br> 批发数据（在等待的时间发送数据帧）</p> 
<h2><a id="_313"></a>四、滑动窗口协议</h2> 
<table><thead><tr><th>发送窗口</th><th>接受窗口</th></tr></thead><tbody><tr><td>已经发送，未被确认的帧的序列号</td><td>期望接受的帧的序列号</td></tr></tbody></table> 
<h3><a id="4_317"></a>一位滑动窗口协议(协议4)</h3> 
<p><strong>接收方</strong>收到帧后，首先核对是否为预期帧号(seq=frame_expected)，如果是的，则接收并frame_expected+1，即移动接收窗口。<br> <strong>发送端</strong>收到应答帧，核对响应帧号ack=next_frame_to_send，核对无误后，从网络层取新的帧，并执行next_frame_to_send+1，即移动发送窗口。如核对帧号不正确，则不移动窗口</p> 
<p><img src="https://images2.imgbox.com/0f/99/2rxqLoQs_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c9/de/kBybXoVD_o.png" alt="在这里插入图片描述"><br> <strong>特点：</strong><br> 序列号seq和确认值ack“0”“1”交替<br> 滑动窗口长度W=1，收到确认才移动窗口<br> 保证按顺序将接收到的正确帧只一次上交网络层<br> <strong>协议4的信道利用率：</strong><br> 信道传输速率是:b bps<br> 每帧的大小是:k bits<br> 来回的时间是:R sec<br> <strong>则信道的利用率是：</strong><br> k/(k+bR)<br> <strong>提高效率的方法：</strong><br> 增加滑动窗口最大长度W，在等待的时间继续发送<br> W的确定：<br> 带宽-延迟积：BD<br> 窗口值：W=2<em>BD+1<br> 上述的例子：<br> BD=50kbps</em>0.250=12.5kb<br> W=2*12.5kb+1=26kb=26帧<br> <img src="https://images2.imgbox.com/89/d8/mP7GUkd8_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="N5_342"></a>回退N协议(协议5)</h3> 
<p><strong>接受方：</strong> 丢弃错误帧及其以后<br> <strong>发送方：</strong> 重发错误帧及其以后<br> <img src="https://images2.imgbox.com/f5/d1/nG8ULXyy_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6_346"></a>选择重传协议(协议6)</h3> 
<p><img src="https://images2.imgbox.com/96/22/rxCK6nyW_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/aa/c4/dsrTBnbK_o.png" alt="在这里插入图片描述"><br> <strong>回退N帧和选择性重传的比较:</strong></p> 
<table><thead><tr><th></th><th>回退N帧</th><th>选择性重传</th></tr></thead><tbody><tr><td>缓冲区</td><td>发送方</td><td>接收方</td></tr><tr><td>适用网络环境</td><td>出错率小</td><td>出错率大</td></tr></tbody></table> 
<p><strong>协议6滑动窗口的选择：</strong><br> 发送窗口：W=(MAX_SEQ+1)/2<br> 发送窗口通常小于接受窗口，使新老窗口不重叠<br> <strong>三个协议的窗口大小：</strong></p> 
<table><thead><tr><th></th><th>协议4:滑动窗口</th><th>协议5:回退N帧</th><th>协议6:选择性重传</th></tr></thead><tbody><tr><td>发送窗口(SWnd)</td><td>0&lt;SWnd&lt;=1</td><td>0&lt;SWnd&lt;=MAX_SEQ</td><td>0&lt;SWnd&lt;=RWnd</td></tr><tr><td>接受窗口(RWnd)</td><td>RWnd=1</td><td>RWnd=1</td><td>RWnd&lt;=(MAX_SEQ+1)/2</td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3e725b4b3cab237f4097ab3f7a5b670f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Winform内存溢出的几种情况</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f55f8c01460648a931b8265333955244/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">redis集群重启</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>