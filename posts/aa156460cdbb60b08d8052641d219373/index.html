<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>四.Sping之AOP源码 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="四.Sping之AOP源码" />
<meta property="og:description" content="本文解读AOP是如何增强方法功能的。
需要提前了解@Import 注解的功能：一.Spring之组件注册bean_u014203449的博客-CSDN博客_spring注册bean
BeanPostProcessor 后置处理器的功能:二.Spring之实例生命周期_u014203449的博客-CSDN博客
Aware接口：三.Spring之属性赋值和自动装配_u014203449的博客-CSDN博客
一.演示案列 1、导入aop模块；Spring AOP：(spring-aspects)
&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;4.3.12.RELEASE&lt;/version&gt; &lt;/dependency&gt; 2、定义一个业务逻辑类（MathCalculator）；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常，xxx）
public class MathCalculator { public int div(int i,int j){ System.out.println(&#34;MathCalculator...div...&#34;); return i/j;	} } 3、定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行；
通知方法：
前置通知(@Before)：logStart：在目标方法(div)运行之前运行
后置通知(@After)：logEnd：在目标方法(div)运行结束之后运行（无论方法正常结束还是异常结束）
返回通知(@AfterReturning)：logReturn：在目标方法(div)正常返回之后运行
异常通知(@AfterThrowing)：logException：在目标方法(div)出现异常以后运行
环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()）
4、给切面类的目标方法标注何时何地运行（通知注解）；
5、将切面类和业务逻辑类（目标方法所在类）都加入到容器中;
6、必须告诉Spring哪个类是切面类(给切面类上加一个注解：@Aspect)
7、标明切点，切点可以是某包、某类、某方法、某注解，通知注解的value值为切点
/** * 切面类 * @author lfy * * @Aspect： 告诉Spring当前类是一个切面类 * */ @Aspect public class LogAspects { //抽取公共的切入点表达式 //1、本类引用 //2、其他的切面引用 @Pointcut(&#34;execution(public int com.atguigu.aop.MathCalculator.*(..))&#34;) public void pointCut(){}; //@Before在目标方法之前切入；切入点表达式（指定在哪个方法切入） @Before(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/aa156460cdbb60b08d8052641d219373/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-10T13:25:42+08:00" />
<meta property="article:modified_time" content="2022-03-10T13:25:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">四.Sping之AOP源码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本文解读AOP是如何增强方法功能的。</p> 
<p>需要提前了解@Import 注解的功能：<a href="https://blog.csdn.net/u014203449/article/details/86559350" title="一.Spring之组件注册bean_u014203449的博客-CSDN博客_spring注册bean">一.Spring之组件注册bean_u014203449的博客-CSDN博客_spring注册bean</a></p> 
<p>BeanPostProcessor 后置处理器的功能:<a href="https://blog.csdn.net/u014203449/article/details/86665963" title="二.Spring之实例生命周期_u014203449的博客-CSDN博客">二.Spring之实例生命周期_u014203449的博客-CSDN博客</a></p> 
<p>Aware接口：<a href="https://blog.csdn.net/u014203449/article/details/105414733" title="三.Spring之属性赋值和自动装配_u014203449的博客-CSDN博客">三.Spring之属性赋值和自动装配_u014203449的博客-CSDN博客</a></p> 
<h3><strong>一.演示案列</strong></h3> 
<p>1、导入aop模块；Spring AOP：(spring-aspects)</p> 
<pre><code>      &lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
			&lt;version&gt;4.3.12.RELEASE&lt;/version&gt;
		&lt;/dependency&gt;
      &lt;dependency&gt;
			&lt;groupId&gt;org.springframework&lt;/groupId&gt;
			&lt;artifactId&gt;spring-context&lt;/artifactId&gt;
			&lt;version&gt;4.3.12.RELEASE&lt;/version&gt;
		&lt;/dependency&gt;</code></pre> 
<p> 2、定义一个业务逻辑类（MathCalculator）；在业务逻辑运行的时候将日志进行打印（方法之前、方法运行结束、方法出现异常，xxx）</p> 
<pre><code>public class MathCalculator {
	
	public int div(int i,int j){
		System.out.println("MathCalculator...div...");
		return i/j;	
	}

}</code></pre> 
<p>  3、定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行；<br>           通知方法：<br>               前置通知(@Before)：logStart：在目标方法(div)运行之前运行<br>               后置通知(@After)：logEnd：在目标方法(div)运行结束之后运行（无论方法正常结束还是异常结束）<br>               返回通知(@AfterReturning)：logReturn：在目标方法(div)正常返回之后运行<br>               异常通知(@AfterThrowing)：logException：在目标方法(div)出现异常以后运行<br>               环绕通知(@Around)：动态代理，手动推进目标方法运行（joinPoint.procced()）</p> 
<p>  4、给切面类的目标方法标注何时何地运行（通知注解）；<br>   5、将切面类和业务逻辑类（目标方法所在类）都加入到容器中;<br>   6、必须告诉Spring哪个类是切面类(给切面类上加一个注解：@Aspect)</p> 
<p>  7、标明切点，切点可以是某包、某类、某方法、某注解，通知注解的value值为切点</p> 
<pre><code>/**
 * 切面类
 * @author lfy
 * 
 * @Aspect： 告诉Spring当前类是一个切面类
 *
 */
@Aspect
public class LogAspects {
	
	//抽取公共的切入点表达式
	//1、本类引用
	//2、其他的切面引用
	@Pointcut("execution(public int com.atguigu.aop.MathCalculator.*(..))")
	public void pointCut(){};
	
	//@Before在目标方法之前切入；切入点表达式（指定在哪个方法切入）
	@Before("pointCut()")
	public void logStart(JoinPoint joinPoint){
		Object[] args = joinPoint.getArgs();
		System.out.println(""+joinPoint.getSignature().getName()+"运行。。。@Before:参数列表是：{"+Arrays.asList(args)+"}");
	}
	
	@After("com.atguigu.aop.LogAspects.pointCut()")
	public void logEnd(JoinPoint joinPoint){
		System.out.println(""+joinPoint.getSignature().getName()+"结束。。。@After");
	}
	
	//JoinPoint一定要出现在参数表的第一位
	@AfterReturning(value="pointCut()",returning="result")
	public void logReturn(JoinPoint joinPoint,Object result){
		System.out.println(""+joinPoint.getSignature().getName()+"正常返回。。。@AfterReturning:运行结果：{"+result+"}");
	}
	
	@AfterThrowing(value="pointCut()",throwing="exception")
	public void logException(JoinPoint joinPoint,Exception exception){
		System.out.println(""+joinPoint.getSignature().getName()+"异常。。。异常信息：{"+exception+"}");
	}

}</code></pre> 
<p> 8、给配置类中加 @EnableAspectJAutoProxy 【开启基于注解的aop模式】<br>           在Spring中很多的 @EnableXXX;</p> 
<pre><code>@EnableAspectJAutoProxy
@Configuration
public class MainConfigOfAOP {
	 
	//业务逻辑类加入容器中
	@Bean
	public MathCalculator calculator(){
		return new MathCalculator();
	}

	//切面类加入到容器中
	@Bean
	public LogAspects logAspects(){
		return new LogAspects();
	}
}</code></pre> 
<p>单元测试：</p> 
<pre><code>	@Test
	public void test01(){
		AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(MainConfigOfAOP.class);
		MathCalculator mathCalculator = applicationContext.getBean(MathCalculator.class);
		mathCalculator.div(1, 0);
		applicationContext.close();
	}</code></pre> 
<h3><img alt="" height="376" src="https://images2.imgbox.com/c5/c0/aEQQrSJj_o.png" width="812"></h3> 
<h3>二.@EnableAspectJAutoProxy</h3> 
<p>@EnableAspectJAutoProxy注解启动了AOP功能，Spring中很多注解都是EnableXXX 去启动某个功能，我们先来看这个注解。</p> 
<pre><code>@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import(AspectJAutoProxyRegistrar.class)
public @interface EnableAspectJAutoProxy {<!-- --></code></pre> 
<p>@EnableAspectJAutoProxy 上有@Import注解，它会向容器中注入参数类的实例，点击看参数 AspectJAutoProxyRegistrar 类。</p> 
<p>@Import注解有三种用法，我这篇文章介绍过：<a href="https://blog.csdn.net/u014203449/article/details/86559350" title="一.Spring之组件注册bean_u014203449的博客-CSDN博客_spring注册bean">一.Spring之组件注册bean_u014203449的博客-CSDN博客_spring注册bean</a></p> 
<pre><code>/**
 * Registers an {@link org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator
 * AnnotationAwareAspectJAutoProxyCreator} against the current {@link BeanDefinitionRegistry}
 * as appropriate based on a given @{@link EnableAspectJAutoProxy} annotation.
 *
 * @author Chris Beams
 * @author Juergen Hoeller
 * @since 3.1
 * @see EnableAspectJAutoProxy
 */
class AspectJAutoProxyRegistrar implements ImportBeanDefinitionRegistrar {

	/**
	 * Register, escalate, and configure the AspectJ auto proxy creator based on the value
	 * of the @{@link EnableAspectJAutoProxy#proxyTargetClass()} attribute on the importing
	 * {@code @Configuration} class.
	 */
	@Override
	public void registerBeanDefinitions(
			AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {

		AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry);

		AnnotationAttributes enableAspectJAutoProxy =
				AnnotationConfigUtils.attributesFor(importingClassMetadata, EnableAspectJAutoProxy.class);
		if (enableAspectJAutoProxy.getBoolean("proxyTargetClass")) {
			AopConfigUtils.forceAutoProxyCreatorToUseClassProxying(registry);
		}
		if (enableAspectJAutoProxy.getBoolean("exposeProxy")) {
			AopConfigUtils.forceAutoProxyCreatorToExposeProxy(registry);
		}
	}

}</code></pre> 
<p>可以看到类注释说 基于 EnableAspectJAutoProxy注解，将 AnnotationAwareAspectJAutoProxyCreator 用BeanDefinitionRegistry注册。</p> 
<p>AspectJAutoProxyRegistrar 类实现 ImportBeanDefinitionRegistrar 接口，在registerBeanDefinitions方法可以用参数BeanDefinitionRegistry 去手动注册实例到容器中。</p> 
<p>可以看到  AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry); 这行代码方法名 注册AspectJxxx 如果需要的话。</p> 
<p>点进去看。</p> 
<pre><code>	public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry) {
		return registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry, null);
	}</code></pre> 
<pre><code>	public static BeanDefinition registerAspectJAnnotationAutoProxyCreatorIfNecessary(BeanDefinitionRegistry registry, Object source) {
		return registerOrEscalateApcAsRequired(AnnotationAwareAspectJAutoProxyCreator.class, registry, source);
	}</code></pre> 
<p>注意上面这个方法的参数是AnnotationAwareAspectJAutoProxyCreator.Class. 再点进去。</p> 
<pre><code>	public static final String AUTO_PROXY_CREATOR_BEAN_NAME =
			"org.springframework.aop.config.internalAutoProxyCreator";	

private static BeanDefinition registerOrEscalateApcAsRequired(Class&lt;?&gt; cls, BeanDefinitionRegistry registry, Object source) {
		Assert.notNull(registry, "BeanDefinitionRegistry must not be null");
		if (registry.containsBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME)) {
			BeanDefinition apcDefinition = registry.getBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME);
			if (!cls.getName().equals(apcDefinition.getBeanClassName())) {
				int currentPriority = findPriorityForClass(apcDefinition.getBeanClassName());
				int requiredPriority = findPriorityForClass(cls);
				if (currentPriority &lt; requiredPriority) {
					apcDefinition.setBeanClassName(cls.getName());
				}
			}
			return null;
		}
		RootBeanDefinition beanDefinition = new RootBeanDefinition(cls);
		beanDefinition.setSource(source);
		beanDefinition.getPropertyValues().add("order", Ordered.HIGHEST_PRECEDENCE);
		beanDefinition.setRole(BeanDefinition.ROLE_INFRASTRUCTURE);
		registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);
		return beanDefinition;
	}</code></pre> 
<p>这个方法对参数class判断registry中是否有这个BeanDefinition，如果没有就new一个并且register这个BeanDefiniton到registry，如果有则比较优先级，更换beanClassName.</p> 
<p>AnnotationAwareAspectJAutoProxyCreator类对应的BeanDefinition名字是固定的org.springframework.aop.config.internalAutoProxyCreator，根据这个名字取判断是否存在。</p> 
<p>打断点看看是如何判断registry 是否有这个BeanDefinition。</p> 
<p><img alt="" height="142" src="https://images2.imgbox.com/95/68/1iuHYEhG_o.png" width="1069"></p> 
<p>来到了 DefaultListableBeanFactory类，看到用一些集合存储了已注册的BeanDefinition。</p> 
<p><img alt="" height="476" src="https://images2.imgbox.com/fb/0a/zgrQRAID_o.png" width="1196"></p> 
<p>打断点，容器第一次启动时还没有这个BeanDefinition，所以会新创建我们的AnnotationAwareAspectJAutoProxyCreator对应的BeanDefinition.</p> 
<p><img alt="" height="322" src="https://images2.imgbox.com/49/cd/56Qk6l9j_o.png" width="755"></p> 
<p>断点进入 registry.registerBeanDefinition(AUTO_PROXY_CREATOR_BEAN_NAME, beanDefinition);又来到了DefaultListableBeanFactory类。</p> 
<p><img alt="" height="190" src="https://images2.imgbox.com/4c/20/76LYDovB_o.png" width="756"></p> 
<p><img alt="" height="425" src="https://images2.imgbox.com/51/f6/6z5ZvATk_o.png" width="565"></p> 
<p>简单看看就是把BeanDefinition用集合变量存下来。 </p> 
<p>再看看BeanDinition有哪些东西,截取一部分代码:看方法名大概明白什么意思，BeanDinition 可以设置和获取实例在Spring容器中的属性如是否单例、优先级、对应的Class、懒加载、依赖哪些其他组件(这个蛮有用，容器在创建此实例前优先创建它依赖的实例)</p> 
<pre><code>public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement {

	String getParentName();

	void setBeanClassName(String beanClassName);

	String getBeanClassName();

	void setScope(String scope);

	String getScope();

	void setLazyInit(boolean lazyInit);

	boolean isLazyInit();

	void setDependsOn(String... dependsOn);

	String[] getDependsOn();

	void setAutowireCandidate(boolean autowireCandidate);

	boolean isAutowireCandidate();

	void setPrimary(boolean primary);

	boolean isPrimary();</code></pre> 
<p>回到 AopConfigUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(registry)，以上逻辑说明了@EnableAspectJAutoProxy 会将 AnnotationAwareAspectJAutoProxyCreator.Class 做参数创建一个BeanDefinition并保存到DefaultListableBeanFactory。</p> 
<h3>三.AnnotationAwareAspectJAutoProxyCreator的创建、初始化</h3> 
<p>来看看AnnotationAwareAspectJAutoProxyCreator是如何发挥作用的。</p> 
<p><img alt="" height="147" src="https://images2.imgbox.com/d3/7c/BSAvWWvn_o.png" width="745"></p> 
<p><img alt="" height="104" src="https://images2.imgbox.com/a6/21/PboIHVBH_o.png" width="670"></p> 
<p>后面的类层层继承，就不一一截图了，把继承的关系链写下来：</p> 
<p>AnnotationAwareAspectJAutoProxyCreator：<br>           AnnotationAwareAspectJAutoProxyCreator<br>               -&gt;AspectJAwareAdvisorAutoProxyCreator<br>                   -&gt;AbstractAdvisorAutoProxyCreator<br>                       -&gt;AbstractAutoProxyCreator<br>                               <strong>implements SmartInstantiationAwareBeanPostProcessor, BeanFactoryAware(关键)</strong></p> 
<p>SmartInstantiationAwareBeanPostProcessor接口</p> 
<p>       -&gt;InstantiationAwareBeanPostProcessor</p> 
<p>             -&gt;BeanPostProcessor</p> 
<p>BeanPostProcessor 是后置处理器，在实例初始化前后可以对实例进行操作。</p> 
<p>看看InstantiationAwareBeanPostProcessor : 看文档注释可以明白，下面两个方法可以在实例创建前后进行处理。postProcessBeforeInstantiation方法注释：返回的object可以是目标bean的代理对象。</p> 
<pre><code>public interface InstantiationAwareBeanPostProcessor extends BeanPostProcessor {

 /**Apply this BeanPostProcessor &lt;i&gt;before the target bean gets instantiated&lt;/i&gt;.
	 * The returned bean object may be a proxy to use instead of the target bean,
	 * effectively suppressing default instantiation of the target bean.**/
	Object postProcessBeforeInstantiation(Class&lt;?&gt; beanClass, String beanName) throws BeansException;


	boolean postProcessAfterInstantiation(Object bean, String beanName) throws BeansException;
}</code></pre> 
<p>回到AbstractAutoProxyCreator类，它实现了后置处理器接口 这样它会成为一个后置处理器； 实现了BeanFactoryAware接口，会将Spring的工厂组件注入其中。</p> 
<p>关于XXXAware接口：<a href="https://blog.csdn.net/u014203449/article/details/105414733" title="三.Spring之属性赋值和自动装配_u014203449的博客-CSDN博客">三.Spring之属性赋值和自动装配_u014203449的博客-CSDN博客</a></p> 
<p></p> 
<p><strong>以上说明AnnotationAwareAspectJAutoProxyCreator 本质是个后置处理器BeanProcessor,且其注入了BeanFachory。</strong></p> 
<p><strong>我们先把断点打到AnnotationAwareAspectJAutoProxyCreator 和其层层父类的 setBeanFactory 方法上，这样可以看到它是怎样把BeanFactory注入进去，即何时执行的实例初始化方法。</strong></p> 
<p></p> 
<p>AbstractAdvisorAutoProxyCreator 和AbstractAutoProxyCreator 都有setBeanFactory方法，其中调用了 initBeanFactory().</p> 
<p><img alt="" height="401" src="https://images2.imgbox.com/b8/fe/B5AV2Poh_o.png" width="789"></p> 
<p></p> 
<p>断点来了：</p> 
<p><img alt="" height="186" src="https://images2.imgbox.com/73/97/OJRSSspr_o.png" width="524"></p> 
<p>来看看调用链：</p> 
<p><img alt="" height="336" src="https://images2.imgbox.com/59/ec/xknUimZt_o.png" width="498"></p> 
<p>test01是我们的单元测试方法，依次往上看方法</p> 
<p>第一个是 AnnotationConfigApplicationContext的构造器，这是在单元测试创建容器时调用的：</p> 
<p><img alt="" height="127" src="https://images2.imgbox.com/10/ca/usbOYMdi_o.png" width="872"></p> 
<p><img alt="" height="121" src="https://images2.imgbox.com/49/95/CHyIZ7bO_o.png" width="590"></p> 
<p>再往进看，调用到了 refresh的 registerBeanPostProcessors方法，方法名称是注册后置处理器</p> 
<p><img alt="" height="454" src="https://images2.imgbox.com/ef/7c/ouJgIOrl_o.png" width="636"></p> 
<p>点击进入 PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);这个方法要仔细看看。</p> 
<p><img alt="" height="229" src="https://images2.imgbox.com/72/f1/DsVi6GGx_o.png" width="708"></p> 
<p>断点到了 BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class); 从工厂中获得一个BeanPostProcessor，从工厂获得也就是创建实例，这符合我们打断点的目的：在AnnotationAwareAspectJAutoProxyCreator实例创建完成后，执行初始化方法中， 调用setBeanFactory将BeanFactory注入。</p> 
<p></p> 
<p>先整体看看registerBeanPostProcessors。如下图，第一步先得到所有BeanProcessor的名称。</p> 
<p><img alt="" height="109" src="https://images2.imgbox.com/69/c6/UUmyXwiZ_o.png" width="1014"></p> 
<p>第二步，添加一个BeanPostProcessor,看注释是这个后置处理器是为了记录日志，在其他后置处理器创建实例时。</p> 
<p><img alt="" height="129" src="https://images2.imgbox.com/55/e8/0UYOEnaJ_o.png" width="762"></p> 
<p>第三步，看注释和代码，将BeanPostProcossor 的Name数组 按照实现PriorityOrdered 、Orderd 接口和没实现排序接口的划分成不同的集合，如PriorityOrderedPostProcessors、orderedPostProcessors、nonOrderedPostProcessors。</p> 
<p>将实现了MergedBeanDefinitionPostProcessor接口的分到internalPostProcessors 内部后置处理器集合。</p> 
<p>如果实现了PriorityOrdered接口，则直接通过BeanFactory得到实例，并保存到PriorityOrderedPostProcessors集合。</p> 
<p><img alt="" height="434" src="https://images2.imgbox.com/eb/f2/DASFf4Z3_o.png" width="711"></p> 
<p>再往后看，就是将PriorityOrderedPostProcessors集合排序sort，然后调用 registerBeanPostProcessors 方法将实例注册到容器。</p> 
<p>以及将其他实现ordered接口的 和没有实现排序接口的BeanPostProcessor创建并注册。</p> 
<p><img alt="" height="700" src="https://images2.imgbox.com/c8/4b/3lFQqUrD_o.png" width="693"></p> 
<p>看看 registerBeanPostProcessors，如何注册BeanPostProcessor:往BeanFactory中添加</p> 
<p><img alt="" height="189" src="https://images2.imgbox.com/2b/23/bPDteMvQ_o.png" width="687"></p> 
<p>到了 AbstractBeanFactory.addBeanPostProcessor()，注册就是往AbstractBeanFactory类的beanPostProcessors集合中添加一个元素。</p> 
<p><img alt="" height="245" src="https://images2.imgbox.com/cf/28/pR6mDSm9_o.png" width="522"></p> 
<p><img alt="" height="76" src="https://images2.imgbox.com/95/00/7wms73WH_o.png" width="733"></p> 
<p></p> 
<p>回到之前打断点的地方，AnnotationAwareAspectJAutoProxyCreator实现了Ordered接口，所以被分到了OrderedPost集合中。</p> 
<p><img alt="" height="132" src="https://images2.imgbox.com/d2/61/fZDDJaTw_o.png" width="426"></p> 
<p>接下来看看，实例是如何在工厂中创建的。顺着这个线程调用点击，都可以看看，是有关创建实例的过程。</p> 
<p><img alt="" height="274" src="https://images2.imgbox.com/99/84/f9t2Ubv5_o.png" width="458"></p> 
<p>先写下创建实例的简单过程：</p> 
<p>                  1）、创建Bean的实例<br>                   2）、populateBean；给bean的各种属性赋值<br>                   3）、initializeBean：初始化bean；<br>                           1）、invokeAwareMethods()：处理Aware接口的方法回调,(就是debug的注入工厂)<br>                           2）、applyBeanPostProcessorsBeforeInitialization()：应用后置处理器的postProcessBeforeInitialization（）<br>                           3）、invokeInitMethods()；执行自定义的初始化方法<br>                           4）、applyBeanPostProcessorsAfterInitialization()；执行后置处理器的postProcessAfterInitialization（）；</p> 
<p>断点看到AbstractAutowireCapableBeanFactory.doCreateBean(final String beanName, final RootBeanDefinition mbd, final Object[] args).</p> 
<p>看注释:生成实例</p> 
<p><img alt="" height="169" src="https://images2.imgbox.com/f3/e5/We9EYM19_o.png" width="830"></p> 
<p>设置属性，初始化实例，断点在初始化实例这个方法上。</p> 
<p><img alt="" height="208" src="https://images2.imgbox.com/9c/09/k3XHk2Qs_o.png" width="631"></p> 
<p>断点再进去，可以看到断点在 invokeAwareMethods 方法上，即调用Aware方法，看后面分别还有调用前置处理器、ini他、后置处理器等方法，说明前置、后置处理器、Aware方法都是 初始化实例过程的一部分。</p> 
<p><img alt="" height="688" src="https://images2.imgbox.com/fc/89/LNjI0eZe_o.png" width="689"></p> 
<p>进入invokeAwareMethods，根据实例实现了哪些Aware接口，注入对应的组件。</p> 
<p><img alt="" height="276" src="https://images2.imgbox.com/b6/8f/8VRGFJBy_o.png" width="612"></p> 
<p>调用线程链再往上，就来到最初我们打断点的地方。</p> 
<p><img alt="" height="201" src="https://images2.imgbox.com/1d/66/AoSF1B5c_o.png" width="641"></p> 
<p>在上面的过程中，看到了AnnotationAwareAspectJAutoProxyCreator是如何创建并初始化的过程，也简单看了实例创建初始化过程。</p> 
<p>接下来看看AnnotationAwareAspectJAutoProxyCreator 作为后置处理器BeanPostProcessor是如何发挥作用的。</p> 
<h3>四.AnnotationAwareAspectJAutoProxyCreator后置处理器功能</h3> 
<p>把AnnotationAwareAspectJAutoProxyCreator 上有业务逻辑的BeanPostProcessor 方法打上断点，没有逻辑直接返回null或bean的不打断点。来看看AnnotationAwareAspectJAutoProxyCreator 作为BeanPostProcessor是如何发挥作用的。</p> 
<p>有两个方法有业务逻辑：</p> 
<pre><code class="language-html">AbstractAutoProxyCreator.postProcessBeforeInstantiation()</code></pre> 
<p><img alt="" height="169" src="https://images2.imgbox.com/fb/74/n5K51aSY_o.png" width="602"></p> 
<pre><code class="language-html">AbstractAutoProxyCreator.postProcessAfterInitialization()</code></pre> 
<p><img alt="" height="195" src="https://images2.imgbox.com/01/cc/EC4lDFve_o.png" width="688"></p> 
<p>从setBeanFactory那放开断点，就来到了 AbstractAutoProxyCreator.postProcessBeforeInstantiation（）</p> 
<p>从线程调度看，发现依然是refresh方法开始调用的。</p> 
<p><img alt="" height="290" src="https://images2.imgbox.com/24/ac/1FLBdnn9_o.png" width="522"></p> 
<p>看注释，实例化所有剩余的非懒加载的实例。在之前refresh方法中调用了 registerBeanPostProcessors 去实例化并注册了BeanPostProcessor,现在要注册剩余的其他bean。</p> 
<p><img alt="" height="167" src="https://images2.imgbox.com/87/8f/linBCUu8_o.png" width="647"></p> 
<p>按照线程调用链，我们点到 preInstantiateSingletons方法。在里面打断点，把断点放行到此处：</p> 
<p>可以看到，遍历beanDifinitionNames，判断是否spring工厂中有此bean，没有就getbean（）创建bean。</p> 
<p><img alt="" height="664" src="https://images2.imgbox.com/9a/58/wfEvnDzU_o.png" width="570"></p> 
<p>看看目前有多少beanDefinitionNames,之前创建并注册了BeanPostProcessor，现在会实例化剩余的bean，</p> 
<p>重点看calculator，这是被AOP增强的类。</p> 
<p><img alt="" height="253" src="https://images2.imgbox.com/35/87/TfjWfjn5_o.png" width="664"></p> 
<p>把断点放行，让当前beanName 是calculator，看看关注的calculator是如何创建的：</p> 
<p><img alt="" height="53" src="https://images2.imgbox.com/0e/57/dy52xhUM_o.png" width="687"></p> 
<p>判断spring工厂中没有calculator，所以会执行getBean创建：</p> 
<p><img alt="" height="54" src="https://images2.imgbox.com/d4/84/Li8l1nup_o.png" width="285"></p> 
<p>断点一路点进去，来到了 AbstractBeanFactory.doGetBean()，这个方法在之前BeanPostProccessor创建时也调用过，方法很长，看注释基本是对bean的校验、先实例化它depends依赖的组件。最后createBean.</p> 
<p><img alt="" height="144" src="https://images2.imgbox.com/f2/40/oBhVjeqY_o.png" width="576"></p> 
<p>再点进去，也是之前BeanPostProccessor创建时见过的方法。不同的是，这次不会直接doCreateBean,</p> 
<p>直接跳过 resolveBeforeInstantiation 方法，会发现断点进入了之前设置的 postProcessBeforeInstantiation方法。</p> 
<p><img alt="" height="265" src="https://images2.imgbox.com/a8/0f/eNvWgDNn_o.png" width="681"></p> 
<p><img alt="" height="67" src="https://images2.imgbox.com/70/6b/nt3lALWI_o.png" width="481"></p> 
<p>回头看看resolveBeforeInstantiation方法，它会先调用BeanPostProcessor的  BeanPostProcessorsBeforeInstantiation方法，尝试直接返回一个Bean，如果返回成功，就执行 BeanPostProcessorsAfterInitialization方法。</p> 
<p>这符合 InstantiationAwareBeanPostProcessor 的功能，在实例创建前后执行。</p> 
<p><img alt="" height="336" src="https://images2.imgbox.com/f5/08/ytPPA9PG_o.png" width="693"></p> 
<p>这时能看出AnnotationAwareAspectJAutoProxyCreator作为BeanPostProcessor开始发挥作用了，来看看它的postProcessBeforeInstantiation方法：</p> 
<p><img alt="" height="480" src="https://images2.imgbox.com/bb/cb/JWSin9LR_o.png" width="600"></p> 
<p>里面主要是判断，isInfrastructureClass() 判断当前bean是不是切点、增强器之类。如果是，则加入advisedBeans</p> 
<p><img alt="" height="169" src="https://images2.imgbox.com/cc/fd/WI2LCoEz_o.png" width="419"></p> 
<p>判断是否应该跳过，shouldSkip()，里面判断当前bean的名字是不是和 candidateAdvisors 候选增强器的切面相同。如果是也加入</p> 
<p>advisedBeans。</p> 
<p>可见advisedBeans是用来保存增强器的集合。 结果也是LogAspect加入了advisedBeans，MathCalculator没有加入。</p> 
<p><img alt="" height="265" src="https://images2.imgbox.com/7b/d3/Adh0ch6w_o.png" width="739"></p> 
<p> 总结AnnotationAwareAspectJAutoProxyCreator【InstantiationAwareBeanPostProcessor】    的作用：<br>   1）、每一个bean创建之前，调用postProcessBeforeInstantiation()；<br>           关心MathCalculator和LogAspect的创建<br>           1）、判断当前bean是否在advisedBeans中（保存了所有增强器）<br>           2）、判断当前bean是否是基础类型的Advice、Pointcut、Advisor、AopInfrastructureBean，<br>               或者是否是切面（@Aspect）<br>           3）、是否需要跳过shouldSkip（）<br>               1）、获取候选的增强器（切面里面的通知方法）【List&lt;Advisor&gt; candidateAdvisors】<br>                   每一个封装的通知方法的增强器是 InstantiationModelAwarePointcutAdvisor；<br>                   判断每一个增强器是否是 AspectJPointcutAdvisor 类型的；返回true<br>               2）、永远返回false</p> 
<p></p> 
<p>再看AnnotationAwareAspectJAutoProxyCreator 的postProcessAfterInitialization方法，当前bean为calculator时，会进入wrapIfNecessary方法， 包装bean方法。</p> 
<p>earlyProxyReferences是创建bean时会把引用加到这个集合，可以自行查看依赖关系。</p> 
<p><img alt="" height="188" src="https://images2.imgbox.com/5a/dd/bTrMtWvq_o.png" width="743"></p> 
<p><strong>这是AnnotationAwareAspectJAutoProxyCreator 作为BeanPostProcessor最核心的地方</strong>：</p> 
<p>如果bean是增强器已经在advisedBeans中，或者符合isInfrastructureClass 和shouldSkip 方法，就直接返回bean本身。</p> 
<p>否则就会判断增强器数量，如果数量不为空，就认为需要代理、返回一个代理对象。</p> 
<p><img alt="" height="575" src="https://images2.imgbox.com/df/eb/ejaiWir9_o.png" width="773"></p> 
<p>看看getAdvicesAndAdvisorsForBean方法，找到符合当前bean的增强器。</p> 
<p> 1）、获取当前bean的所有增强器（增强器就是通知方法，每个通知对应一个Advisor对象、属性有切点）  Object[]  specificInterceptors<br>               1、找到 候选的 所有的增强器（会遍历所有切面的所有通知，这些通知就是候选增强器）  AbstractAdvisorAutoProxyCreator.getAdvicesAndAdvisorsForBean()<br>               2、获取到能在bean使用的增强器。(遍历候选增强器，去判断增强器是否作用于当前bean，通过通知对应的切点、反射bean类去判断)<br>               3、给增强器排序      AbstractAdvisorAutoProxyCreator.findEligibleAdvisors</p> 
<p><img alt="" height="149" src="https://images2.imgbox.com/32/e0/7nT6GYWh_o.png" width="813"></p> 
<p><img alt="" height="190" src="https://images2.imgbox.com/5f/02/GImsxRce_o.png" width="666"></p> 
<p>然后创建代理：</p> 
<p>  1）、如果当前bean需要增强(有对应的增强器)，创建当前bean的代理对象；<br>               1）、获取所有增强器（通知方法）<br>               2）、保存到proxyFactory<br>               3）、创建代理对象：Spring自动决定 ，何时选用何种代理<a href="https://www.cnblogs.com/caoxb/p/12406005.html" rel="nofollow" title="Spring源码分析-SpringAop什么时候调用jdk动态代理？什么时候调用cglib - cao_xiaobo - 博客园">Spring源码分析-SpringAop什么时候调用jdk动态代理？什么时候调用cglib - cao_xiaobo - 博客园</a><br>                   JdkDynamicAopProxy(config);jdk动态代理；<br>                   ObjenesisCglibAopProxy(config);cglib的动态代理；<br>    2）、给容器中返回当前组件使用cglib增强了的代理对象；<br>    3）、以后容器中获取到的就是这个组件的代理对象，执行目标方法的时候，代理对象就会执行通知方法的流程；</p> 
<p><img alt="" height="454" src="https://images2.imgbox.com/65/ac/l3cWi4QT_o.png" width="682"></p> 
<h3>五.通知方法执行流程</h3> 
<p>将断点打到切点。</p> 
<p><img alt="" height="176" src="https://images2.imgbox.com/0b/3d/Lvy3Bu9Z_o.png" width="589"></p> 
<p>断点进入运行方法，会发现并没有直接进入 div方法，而是进入了 CglibAopProxy的 intercept方法。这就是代理执行的方法</p> 
<p><img alt="" height="107" src="https://images2.imgbox.com/8f/8b/aNruxrLo_o.png" width="674"></p> 
<p>看看方法参数：</p> 
<p>method是切点方法，args有参数。</p> 
<p><img alt="" height="183" src="https://images2.imgbox.com/98/2a/KwRF4hLa_o.png" width="772"></p> 
<p>proxy 有增强的信息，当前bean被哪些增强器(通知增强)</p> 
<p><img alt="" height="324" src="https://images2.imgbox.com/11/32/rDmZ0iRB_o.png" width="529"></p> 
<p>方法中会得到一个chain链，比较关键</p> 
<p><img alt="" height="75" src="https://images2.imgbox.com/2c/25/SFnfIuL6_o.png" width="819"></p> 
<p>往进走，缓存不用管，基本都是为了下次使用，第一次肯定没有缓存。进入</p> 
<pre><code class="language-html">this.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice</code></pre> 
<p><img alt="" height="221" src="https://images2.imgbox.com/8c/29/whwVfYDW_o.png" width="699"></p> 
<p>这个方法简单来说是把advisor遍历，转为 MethodInterceptor集合返回</p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/26/42/n5SJRyvL_o.png" width="716"></p> 
<p>目前有这些advisor增强器，就是切面中的四个通知方法，外加spring默认的ExposeInvocationInterceptor。</p> 
<p><img alt="" height="240" src="https://images2.imgbox.com/8f/f6/AInSrEvc_o.png" width="569"></p> 
<pre><code class="language-html">MethodInterceptor[] interceptors = registry.getInterceptors(advisor); 这个方法时由advisor变为MethodInterceptor的方法，看看。</code></pre> 
<p>判断如果是MethodInterceptor直接强转，如果不是 则通过AdvisorAdapter 适配器转换。</p> 
<p><img alt="" height="366" src="https://images2.imgbox.com/88/b0/PP8YPWqT_o.png" width="668"></p> 
<p>有三个Adapter,遍历尝试转换</p> 
<p><img alt="" height="184" src="https://images2.imgbox.com/7c/f9/B3KNILHT_o.png" width="462"></p> 
<p>转换也就是构造一个MethodInterceptor 方法拦截器</p> 
<p><img alt="" height="106" src="https://images2.imgbox.com/04/2e/cHBSn1HQ_o.png" width="553"></p> 
<p>总之最后得到了一个MethodInterceptorChain，由一个默认的ExposeInvocationInterceptor 和四个 我们写的通知组成。</p> 
<p><img alt="" height="158" src="https://images2.imgbox.com/e1/4a/0jzwnOmY_o.png" width="611"></p> 
<p>继续CglibAopProxy的 intercept方法。看注释，如果链是空的，则直接调用目标方法。</p> 
<p>chain不是空的，则new 一个 CglibMethodInvocation ，并且执行其proceed()方法。</p> 
<p>CglibMethodInvocation继承了 ReflectiveMethodInvocation，proceed是ReflectiveMethodInvocation的方法。</p> 
<p><img alt="" height="280" src="https://images2.imgbox.com/5e/35/eSXdZlaD_o.png" width="814"></p> 
<p>CglibMethodInvocation 构造方法没有什么，就是将形参赋值给它的属性。进入proceed方法。interceptorsAndDynamicMethodMatchers是MethodInterceptorChain，第一步是一个判断，如果链当前索引是-1 则跳出。为-1说明链遍历结束了。但现在大小是5。</p> 
<p><img alt="" height="133" src="https://images2.imgbox.com/03/a4/LYWNyRlY_o.png" width="731"></p> 
<p>然后从链中取出第一个拦截器，调用它的invoke方法，形参是CglibMethodInvocation本身（这个MethodInvocation参数保证了一会能继续执行它的proceed方法，然后遍历通知拦截器 执行）。</p> 
<p>（其实chain这个名字不太对，这不像一个链，因为前后元素并没有指针关联，是通过共同的形参MethodInvocation，去遍历连接器集合）</p> 
<p><img alt="" height="447" src="https://images2.imgbox.com/9b/31/CVOq3Soo_o.png" width="783"></p> 
<p>断点放开，发现程序又执行到了proceed方法。而这次遍历的是第二个元素，</p> 
<p>异常 通知代表的方法拦截器AspectJAfterThrowingAdvice。</p> 
<p><img alt="" height="460" src="https://images2.imgbox.com/84/2f/FZ3K3B91_o.png" width="1030"></p> 
<p>断点进入AspectJAfterThrowingAdvice.invoke(),  里面还是调用CglibMethodInvocation(ReflectiveMethodInvocation</p> 
<p>)的proceed方法，到时索引将会变为3，执行下一个方法拦截器的proceed方法。</p> 
<p>但这里对proceed 捕捉了异常，如果发生异常则调用 增强方法，即异常通知。</p> 
<p><img alt="" height="245" src="https://images2.imgbox.com/ec/e0/hITI5ujZ_o.png" width="525"></p> 
<p>到这里已经很明显了，接下来依次调用的拦截器的会是 返回通知、后置通知、被增强的方法、前置通知。</p> 
<p>调用后还需要回到原方法，当前置通知执行完，再执行div（被增强的方法），然后后置通知、返回通知，直到第一个默认的方法拦截器执行完。</p> 
<p></p> 
<p>一次打断点看，接下来是返回通知：执行proceed后，最终会执行返回通知的增强方法。</p> 
<p><img alt="" height="149" src="https://images2.imgbox.com/46/72/TiYxNgee_o.png" width="695"></p> 
<p>然后是后置通知，这里用了try finally，保证即使异常也会执行后置通知。</p> 
<p><img alt="" height="207" src="https://images2.imgbox.com/67/7d/fPbVyW8u_o.png" width="749"></p> 
<p>最后是前置通知，先执行前置通知的方法，再执行被增强的方法，</p> 
<p><img alt="" height="172" src="https://images2.imgbox.com/44/9e/g3Mkv53c_o.png" width="897"></p> 
<p>当执行了前置通知后，控制台打印出了前置通知内容：</p> 
<p><img alt="" height="325" src="https://images2.imgbox.com/d0/27/sloFEB7A_o.png" width="837"></p> 
<p>执行div后，因为有异常，进入了异常方法拦截器的异常捕捉，调用了异常通知，也一样要把异常抛出去。</p> 
<p><img alt="" height="269" src="https://images2.imgbox.com/44/48/x79Hcy1p_o.png" width="577"></p> 
<p>到这里就说明了通知的执行流程。</p> 
<h3>六.总结</h3> 
<p><br>           1）、  @EnableAspectJAutoProxy 开启AOP功能<br>           2）、 @EnableAspectJAutoProxy 会给容器中注册一个组件 AnnotationAwareAspectJAutoProxyCreator<br>           3）、AnnotationAwareAspectJAutoProxyCreator是一个后置处理器；<br>           4）、容器的创建流程：<br>               1）、registerBeanPostProcessors（）注册后置处理器；创建AnnotationAwareAspectJAutoProxyCreator对象<br>               2）、finishBeanFactoryInitialization（）初始化剩下的单实例bean<br>                   1）、创建业务逻辑组件和切面组件<br>                   2）、AnnotationAwareAspectJAutoProxyCreator拦截组件的创建过程<br>                   3）、组件创建完之后，判断组件是否需要增强</p> 
<p>                        怎么判断？遍历所有的增强器(增强器就是通知),增强器有切点信息，通过反射bean类型判断能否增强bean<br>                       若是：切面的通知方法，包装成增强器（Advisor）;给业务逻辑组件创建一个代理对象（cglib）；如果bean实现了接口，默认是jdk动态代理<br>           5）、执行目标方法：<br>               1）、代理对象执行目标方法<br>               2）、CglibAopProxy.intercept()；<br>                   1）、得到目标方法的拦截器链（增强器包装成拦截器MethodInterceptor）<br>                   2）、利用拦截器的链式机制，依次进入每一个拦截器进行执行；<br>                   3）、效果：<br>                       正常执行：前置通知-》目标方法-》后置通知-》返回通知<br>                       出现异常：前置通知-》目标方法-》后置通知-》异常通知</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5207a21f6dbaaa6b2ff9cac2ca1dfd59/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">usage: conda-script.py [-h] [-V] command ... conda-script.py: error: the following arguments are re</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c75e911b8b0b11c8d6c9bc2dd5a8262f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">最新Via轻插件下载</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>