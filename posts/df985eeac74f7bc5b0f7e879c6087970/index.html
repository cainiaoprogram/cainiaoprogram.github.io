<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JVM -- 垃圾收集 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JVM -- 垃圾收集" />
<meta property="og:description" content="垃圾收集 几个名词强软弱须GC类型Minor GC(年轻代GC)Major GC/Full GC (老年代GC)Full GC STW(Stop the world)GC停顿为什么需要STW TLAB(Thread Local Allocation Buffer))逃逸分析(Escape Analysis)逃逸优化 垃圾收集器Serial收集器ParNew收集器Parallel收集器Serial Old收集器Parallel Old收集器CMS收集器CMS收集器工作分四个步骤CMS缺点 G1收集器G1垃圾回收原理G1收集器工作分四个步骤G1缺点 记忆集-卡表跨代引用卡表 GC日志日志内容 几个名词 强软弱须 强引用
平时写的代码如Test obj = new Test()；这种引用关系就是强引用就算会OOM也不会回收
软引用内存不足的情况下才会回收如果发生了gc但是内存充足，依然不会回收
弱引用只有发生gc就会回收
虚引用形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动 GC类型 分代就是优化GC性能,把那些朝生夕死(新生代)的与链接对象(老不死的老年代)分开做垃圾收集
Minor GC(年轻代GC) Eden区满的时候会触发MinorGC,Survivor不会触发GC,Survivor随着Eden区MinorGC时一同被清理大多数对象都是朝生夕死MinorGC出现的频率相对较高,STW时间相对较短 Major GC/Full GC (老年代GC) 出现Major GC,经常会伴随Minor GC,老年代空间不足的时候会先尝试触发MinorGC,如果还不够再触发MajorGCMajorGC比MinorGC慢10倍以上,会导致STW时间更长MajorGC后空间还不足就会OOM Full GC 调用System.gc(),系统建议执行FullGC,但是不一定执行老年代空间不足方法区空间不足MinorGC后进入老年代的平均占用内存大小大于老年代可用空间从Eden区&#43;s0复制到s1区时,s1区大小存不下该对象,则把该对象转存到老年代,且老年代的可用内存也小于该对象 STW(Stop the world) GC停顿 在执行GC时,jvm会停止其他用户线程的操作,防止产生新垃圾,会导致用户线程出现暂停,GC之后程序计数器和字节码执行引擎会继续从暂停处继续执行用户线程,对用户来说出现了短暂的卡顿,体验收到影响 为什么需要STW GC是从线程的gc root出发,对这个gc root链路可达性分析,如果没有stw,一次GC从gc root出发的时候用户线程依然在运行,发现当前方法的gc root有应用,不是垃圾,但是稍后用户线程执行完成了,又变成了垃圾,导致这种情况的垃圾没法回收,这样会导致GC效果差,性能低下,所以出现STW,即GC停顿 TLAB(Thread Local Allocation Buffer)) 堆内存共享,多线程情况下存在线程安全问题,加锁又会导致性能下降,所有未每个线程分配一个私有的缓存区域,包含在Eden空间内多线程情况下,使用TLAB就可以避免线程安全问题,同时提升内存分配的吞吐量,因此被称为快速分配策略使用-XX:UserTLAB 设置是否开启TLAB空间,默认开启TLAB且只占有Eden区的1%,但JVM将TLAB作为内存分配的首选,可以通过-XX:TLABWasteTargetPercent设置占比如果TLAB分配失败,JVM就会尝试通过加锁机制确保数据的原子性,从而直接在Eden区分配内存 逃逸分析(Escape Analysis) 经过逃逸分析后发现,如果一个对象并没有逃逸出方法,就可能被优化为栈上分配,能使用局部变量的就不用定义为成员变量,-XX : &#43;DoEscapeAnalysis 开启逃逸分析(默认开启)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/df985eeac74f7bc5b0f7e879c6087970/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-04T08:08:23+08:00" />
<meta property="article:modified_time" content="2022-07-04T08:08:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JVM -- 垃圾收集</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>垃圾收集</h4> 
 <ul><li><ul><li><ul><li><a href="#_2" rel="nofollow">几个名词</a></li><li><ul><li><a href="#_3" rel="nofollow">强软弱须</a></li><li><a href="#GC_22" rel="nofollow">GC类型</a></li><li><ul><li><a href="#Minor_GCGC_24" rel="nofollow">Minor GC(年轻代GC)</a></li><li><a href="#Major_GCFull_GC_GC_28" rel="nofollow">Major GC/Full GC (老年代GC)</a></li><li><a href="#Full_GC_32" rel="nofollow">Full GC</a></li></ul> 
     </li><li><a href="#STWStop_the_world_39" rel="nofollow">STW(Stop the world)</a></li><li><ul><li><a href="#GC_40" rel="nofollow">GC停顿</a></li><li><a href="#STW_43" rel="nofollow">为什么需要STW</a></li></ul> 
     </li><li><a href="#TLABThread_Local_Allocation_Buffer_47" rel="nofollow">TLAB(Thread Local Allocation Buffer))</a></li><li><a href="#Escape_Analysis_55" rel="nofollow">逃逸分析(Escape Analysis)</a></li><li><ul><li><a href="#_61" rel="nofollow">逃逸优化</a></li></ul> 
    </li></ul> 
    </li><li><a href="#_68" rel="nofollow">垃圾收集器</a></li><li><ul><li><a href="#Serial_72" rel="nofollow">Serial收集器</a></li><li><a href="#ParNew_77" rel="nofollow">ParNew收集器</a></li><li><a href="#Parallel_86" rel="nofollow">Parallel收集器</a></li><li><a href="#Serial_Old_101" rel="nofollow">Serial Old收集器</a></li><li><a href="#Parallel_Old_107" rel="nofollow">Parallel Old收集器</a></li><li><a href="#CMS_111" rel="nofollow">CMS收集器</a></li><li><ul><li><a href="#CMS_124" rel="nofollow">CMS收集器工作分四个步骤</a></li><li><a href="#CMS_136" rel="nofollow">CMS缺点</a></li></ul> 
     </li><li><a href="#G1_141" rel="nofollow">G1收集器</a></li><li><ul><li><a href="#G1_157" rel="nofollow">G1垃圾回收原理</a></li><li><a href="#G1_162" rel="nofollow">G1收集器工作分四个步骤</a></li><li><a href="#G1_180" rel="nofollow">G1缺点</a></li></ul> 
    </li></ul> 
    </li><li><a href="#_187" rel="nofollow">记忆集-卡表</a></li><li><ul><li><a href="#_188" rel="nofollow">跨代引用</a></li><li><a href="#_196" rel="nofollow">卡表</a></li></ul> 
    </li><li><a href="#GC_205" rel="nofollow">GC日志</a></li><li><ul><li><a href="#_216" rel="nofollow">日志内容</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="_2"></a>几个名词</h4> 
<h5><a id="_3"></a>强软弱须</h5> 
<p><img src="https://images2.imgbox.com/df/3e/sbVoyBqS_o.png" alt="在这里插入图片描述"></p> 
<p><strong>强引用</strong></p> 
<ul><li>平时写的代码如Test obj = new Test()；这种引用关系就是强引用</li><li>就算会OOM也不会回收<br> <strong>软引用</strong></li><li>内存不足的情况下才会回收</li><li>如果发生了gc但是内存充足，依然不会回收<br> <strong>弱引用</strong></li><li>只有发生gc就会回收<br> <strong>虚引用</strong></li><li>形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</li><li>虚引用主要用来跟踪对象被垃圾回收的活动。</li><li>虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。</li><li>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</li><li>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。</li><li>程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动</li></ul> 
<h5><a id="GC_22"></a>GC类型</h5> 
<p>分代就是优化GC性能,把那些朝生夕死(新生代)的与链接对象(老不死的老年代)分开做垃圾收集</p> 
<h6><a id="Minor_GCGC_24"></a>Minor GC(年轻代GC)</h6> 
<ol><li>Eden区满的时候会触发MinorGC,</li><li>Survivor不会触发GC,Survivor随着Eden区MinorGC时一同被清理</li><li>大多数对象都是朝生夕死MinorGC出现的频率相对较高,STW时间相对较短</li></ol> 
<h6><a id="Major_GCFull_GC_GC_28"></a>Major GC/Full GC (老年代GC)</h6> 
<ol><li>出现Major GC,经常会伴随Minor GC,老年代空间不足的时候会先尝试触发MinorGC,如果还不够再触发MajorGC</li><li>MajorGC比MinorGC慢10倍以上,会导致STW时间更长</li><li>MajorGC后空间还不足就会OOM</li></ol> 
<h6><a id="Full_GC_32"></a>Full GC</h6> 
<ol><li>调用System.gc(),系统建议执行FullGC,但是不一定执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>MinorGC后进入老年代的平均占用内存大小大于老年代可用空间</li><li>从Eden区+s0复制到s1区时,s1区大小存不下该对象,则把该对象转存到老年代,且老年代的可用内存也小于该对象</li></ol> 
<h5><a id="STWStop_the_world_39"></a>STW(Stop the world)</h5> 
<h6><a id="GC_40"></a>GC停顿</h6> 
<ul><li>在执行GC时,jvm会停止其他用户线程的操作,防止产生新垃圾,会导致用户线程出现暂停,GC之后程序计数器和字节码执行引擎会继续从暂停处继续执行用户线程,对用户来说出现了短暂的卡顿,体验收到影响</li></ul> 
<h6><a id="STW_43"></a>为什么需要STW</h6> 
<ul><li>GC是从线程的gc root出发,对这个gc root链路可达性分析,</li><li>如果没有stw,一次GC从gc root出发的时候用户线程依然在运行,发现当前方法的gc root有应用,不是垃圾,但是稍后用户线程执行完成了,又变成了垃圾,导致这种情况的垃圾没法回收,这样会导致GC效果差,性能低下,所以出现STW,即GC停顿</li></ul> 
<h5><a id="TLABThread_Local_Allocation_Buffer_47"></a>TLAB(Thread Local Allocation Buffer))</h5> 
<p><img src="https://images2.imgbox.com/2e/c5/gRX5Ay3d_o.png" alt="在这里插入图片描述"></p> 
<ol><li>堆内存共享,多线程情况下存在线程安全问题,加锁又会导致性能下降,所有未每个线程分配一个私有的缓存区域,包含在Eden空间内</li><li>多线程情况下,使用TLAB就可以避免线程安全问题,同时提升内存分配的吞吐量,因此被称为快速分配策略</li><li>使用-XX:UserTLAB 设置是否开启TLAB空间,默认开启TLAB且只占有Eden区的1%,但JVM将TLAB作为内存分配的首选,可以通过-XX:TLABWasteTargetPercent设置占比</li><li>如果TLAB分配失败,JVM就会尝试通过加锁机制确保数据的原子性,从而直接在Eden区分配内存</li></ol> 
<h5><a id="Escape_Analysis_55"></a>逃逸分析(Escape Analysis)</h5> 
<p>经过逃逸分析后发现,如果一个对象并没有逃逸出方法,就可能被优化为栈上分配,能使用局部变量的就不用定义为成员变量,-XX : +DoEscapeAnalysis 开启逃逸分析(默认开启)</p> 
<ol><li>new 的对象在方法外被引用,逃逸</li><li>return 出对象可能会在方法外使用,逃逸</li><li>成员变量赋值的可能发生方法外使用,逃逸</li><li>引用成员变量的值,逃逸</li></ol> 
<h6><a id="_61"></a>逃逸优化</h6> 
<ol><li>栈上分配 : 将对分配转换为栈分配内存,逃逸分析没有逃逸的,方法结束,栈弹出就结束了,不需要对象回收,没有GC</li><li>同步省略 : 一个对象只能从一个线程被访问到,那么对这个对象的操作可以不再考虑同步</li><li>分离对象或标量替换 : 经过逃逸分析,发现一个对象不会被外界访问,经过JIT优化,就会把这个对象拆解为若干个成员变量来替换,标量替换为栈上分配提供更好的支持<br> a. 标量(scalar)是指无法在分割更小的数据的数据,如java中的原始数据类型就是标量;<br> b. 聚合量(aggreagate)可分解的数据</li></ol> 
<h4><a id="_68"></a>垃圾收集器</h4> 
<p>标记阶段标记的是存活对象，回收未被标记的对象。<br> <img src="https://images2.imgbox.com/4d/ec/8kbpkBiU_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Serial_72"></a>Serial收集器</h5> 
<ul><li>串行垃圾收集器，即GC线程与用户线程先后运行，即GC时需要STW（暂停所有用户线程），直至GC结束才恢复用户线程的运行</li><li>专注于收集年轻代，底层是复制算法</li><li>相关参数：-XX:+UseSerialGC<br> <img src="https://images2.imgbox.com/61/fb/xRmFuXa6_o.png" alt="在这里插入图片描述"></li></ul> 
<h5><a id="ParNew_77"></a>ParNew收集器</h5> 
<ul><li>Serial收集器的多线程版本。GC时开启多线程收集</li><li>唯一能与CMS收集器搭配使用的新生代收集器。</li><li>相关参数：<br> ○ -XX:+UseConcMarkSweepGC：指定使用CMS后，会默认使用ParNew作为新生代收集器<br> ○ -XX:+UseParNewGC：强制指定使用ParNew<br> ○ -XX:ParallelGCThreads：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同<br> <img src="https://images2.imgbox.com/2b/91/oArSIetN_o.png" alt="在这里插入图片描述"></li></ul> 
<h5><a id="Parallel_86"></a>Parallel收集器</h5> 
<ul><li>关注吞吐量的收集器<br> ○ 吞吐量 = 运行用户代码时间 / (运行用户代码时间+垃圾收集时间)</li><li>相关参数： 
  <ul><li>-XX:MaxGCPauseMillis：是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过设定值。不过大家不要异想天开地认为如果把这个参数的值设置得稍小一点就能使得系统的垃圾收集速度变得更快，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的：<br> ■ 系统把新生代调小一些，收集300MB新生代肯定比收集500MB快吧，这也直接导致垃圾收集发生得更频繁一些，<br> ■ 原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。</li><li>-XX:GCTimeRatio：一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率。<br> ■ 如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即1 /（1+19）），<br> ■ 默认值为99，就是允许最大1%（即1 /（1+99））的垃圾收集时间。</li><li>-XX:+UseAdaptiveSizePolicy：一个开关参数，当这个参数打开之后，<br> ■ 不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数了，<br> ■ 虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/8b/35/nYr9rd6p_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="Serial_Old_101"></a>Serial Old收集器</h5> 
<ul><li>Serial收集器的老年代版本。基于标记-整理算法实现，</li><li>有两个用途：<br> ○ 与Serial收集器、Parallel收集器搭配使用<br> ○ 作为CMS收集器的后备方案</li></ul> 
<h5><a id="Parallel_Old_107"></a>Parallel Old收集器</h5> 
<ul><li>Parallel收集器的老年代版本。基于标记-整理算法实现。</li></ul> 
<h5><a id="CMS_111"></a>CMS收集器</h5> 
<ul><li>聚焦低延迟。基于标记-清除算法实现(会内存碎片，Serial Old收集器兜底)。</li><li>CMS收集器是并发收集器，即在运行阶段用户线程依然在运行，会产生对象，所以CMS收集器不能等到老年代满了才触发，而是要提前触发，这个阈值是92%。<br> ○ 这个阈值可以通过参数-XX:CMSInitiatingOccupancyFraction 设置</li><li>相关参数： 
  <ul><li>-XX：+UseConcMarkSweepGC：手动开启CMS收集器</li><li>-XX:+CMSIncrementalMode：设置为增量模式</li><li>-XX:CMSFullGCsBeforeCompaction：设定进行多少次CMS垃圾回收后，进行一次内存压缩</li><li>-XX:+CMSClassUnloadingEnabled：允许对类元数据进行回收</li><li>-XX:UseCMSInitiatingOccupancyOnly：表示只在到达阀值的时候，才进行CMS回收</li><li>-XX:CMSInitiatingOccupancyFraction：设置CMS收集器在老年代空间被使用多少后触发</li><li>-XX:+UseCMSCompactAtFullCollection：设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片的整理<br> <img src="https://images2.imgbox.com/fb/84/bBeAagrP_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<h6><a id="CMS_124"></a>CMS收集器工作分四个步骤</h6> 
<ol><li>初始标记<br> a. 会STW。只标记GC Roots直接关联的对象。</li><li>并发标记<br> a. 不会STW。GC线程与用户线程并发运行。<br> b. 会沿着GC Roots直接关联的对象链遍历整个对象图。需要的时间较长，但因为是与用户线程并发运行的，除了能感知到CPU飙升，不会出现卡顿现象。</li><li>重新标记<br> a. 会STW。<br> b. CMS垃圾收集器通过 写屏障+增量更新 记录了并发标记阶段新建立的引用关系，重新标记就是去遍历这个记录。</li><li>并发清除<br> a. GC线程与用户线程并发运行，清理未被标记到的对象<br> b. 默认启动的回收线程数 = (处理器核心数 + 3) / 4</li></ol> 
<h6><a id="CMS_136"></a>CMS缺点</h6> 
<ul><li>运行期间会与用户线程抢夺CPU资源。当然，这是所有并发收集器的缺点</li><li>无法处理浮动垃圾（标记结束后创建的对象）</li><li>内存碎片</li></ul> 
<h5><a id="G1_141"></a>G1收集器</h5> 
<ul><li>G1收集器与之前的所有收集器都不一样，它将堆分成了一个一个Region，</li><li>这些Region用的时候才被赋予角色：Eden、from、to、humongous。</li><li>一个region只能是一个角色，不存在一个region既是Eden又是from。</li><li>整体上使用标记整理算法,局部会使用复制算法</li><li>g1垃圾收集器对应的堆区有2048个region，每个region默认大小是2m</li><li>每个region的大小可通过参数-XX:G1HeapRegionSize设置，取值范围是2-32M。</li><li>一个对象的大小超过region的一半则被认定为大对象,放到old区标记为H，如果对象大于region大小,则会用N个连续的region来存储。</li><li>相关参数： 
  <ul><li>-XX:G1HeapRegionSize：设置region的大小</li><li>-XX:MaxGCPauseMillis：设置GC回收时允许的最大停顿时间（默认200ms）</li><li>-XX:+UseG1GC：开启g1</li><li>-XX:ConcGCThreads：设置并发标记、并发整理的gc线程数</li><li>-XX:ParallelGCThreads：STW期间并行执行的gc线程数</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/b6/4e/fqRy1xeU_o.png" alt="在这里插入图片描述"></p> 
<h6><a id="G1_157"></a>G1垃圾回收原理</h6> 
<ul><li>回收某个region的价值大小 = 回收获得的空间大小 + 回收所需时间</li><li>G1收集器会维护一个优先级列表，每个region按价值大小排序存放在这个优先级列表中。</li><li>收集时优先收集价值更大的region，这就是G1名字的由来。<br> <img src="https://images2.imgbox.com/52/56/fcqCLAyZ_o.png" alt="在这里插入图片描述"></li></ul> 
<h6><a id="G1_162"></a>G1收集器工作分四个步骤</h6> 
<ol><li>初始标记<br> a. 会STW。<br> b. 做了两件事：<br> ⅰ. 修改TAMS的值，TAMS以上的值为新创建的对象，默认标记为存活对象，即多标<br> ⅱ. 标记GC Roots能直接关联到的对象</li><li>root region scanning: 根据rset , 扫描整个表的 old的region区,</li><li>并发标记<br> a. 耗时较长。GC线程与用户线程并发运行。<br> b. 从GC roots能直接关联到的对象开始遍历整个对象图</li><li>最终标记<br> a. 遍历 写屏障+SATB 记录下的旧的引用对象图</li><li>筛选回收<br> a. 更新region的统计数据，对各个region的回收价值进行计算并排序，<br> b. 然后根据用户设置的期望暂停时间的期望值生成回收集。<br> c. 然后开始执行清除操作。将旧的region中的存活对象移动到新的Region中，清理这个旧的region,重置rset。<br> d. 这个阶段需要STW。</li></ol> 
<h6><a id="G1_180"></a>G1缺点</h6> 
<ul><li>需要10%-20%的内存来存储G1收集器运行需要的数据，如cset、rset、卡表等<br> ○ rset: 每个region都有一个叫rset的区域,代表其他region引用当前region对象的记录<br> ○ cset: 本次GC需要清理的region集合记录</li><li>运行期间会与用户线程抢夺CPU资源。这是所有并发收集器的缺点</li></ul> 
<h4><a id="_187"></a>记忆集-卡表</h4> 
<h5><a id="_188"></a>跨代引用</h5> 
<ul><li>新生代对老年代的引用<br> ○ 发生gc后，新生代的对象被回收了，程序还能正常运行</li><li>老年代对新生代的引用<br> ○ gc的时候，新生代的对象被清理了<br> ○ 老年代的对象去访问新生代的对象，会报错<br> ○ 用记忆集与卡表解决这个问题</li></ul> 
<h5><a id="_196"></a>卡表</h5> 
<ul><li>记忆集是理论, 卡表是具体实现</li><li>卡表中的卡页数量与region的数量是相同的, 有2048个卡页</li><li>一个卡页有512B , 卡页中的每个字节对应region中的4KB = 2M / 512<br> ○ region大小变化,卡页数不会变<br> ○ 卡页中的1B映射的region的大小会变8kb = 4M/512</li><li>这个4KB只要有一个对象存在对新生代的引用，这个标记就是1<br> ○ 如果已经被标记了，就不标记了(优化)<br> <img src="https://images2.imgbox.com/d2/f6/di2J22B1_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="GC_205"></a>GC日志</h4> 
<ul><li>查看默认收集器<br> java -XX:+PrintFlagsFinal -version | grep GC</li><li>相关参数： 
  <ul><li>-XX:+PrintGC 输出GC日志</li><li>-XX:+PrintGCDetails 输出GC的详细日志</li><li>-XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式）</li><li>-XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2021-05-04T21:53:59.234+0800）</li><li>-XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息</li><li>-Xloggc:…/logs/gc.log 日志文件的输出路径</li></ul> </li></ul> 
<h5><a id="_216"></a>日志内容</h5> 
<ul><li>gc类型：GC、Full GC</li><li>gc原因：Metadata GC Threshold、Last ditch collection……</li><li>gc前内存数据</li><li>gc后内存数据</li><li>花费的时间：用户态、内核态、实际用时</li></ul> 
<pre><code class="prism language-c"><span class="token punctuation">[</span><span class="token function">GC</span> <span class="token punctuation">(</span>Metadata GC Threshold<span class="token punctuation">)</span> <span class="token punctuation">[</span>PSYoungGen<span class="token operator">:</span> <span class="token number">6398</span>K<span class="token operator">-&gt;</span><span class="token number">1133</span>K<span class="token punctuation">(</span><span class="token number">46592</span>K<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token number">6398</span>K<span class="token operator">-&gt;</span><span class="token number">1141</span>K<span class="token punctuation">(</span><span class="token number">153088</span>K<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0371218</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span>Times<span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.03</span> sys<span class="token operator">=</span><span class="token number">0.01</span><span class="token punctuation">,</span> real<span class="token operator">=</span><span class="token number">0.04</span> secs<span class="token punctuation">]</span> 

<span class="token punctuation">[</span>Full <span class="token function">GC</span> <span class="token punctuation">(</span>Metadata GC Threshold<span class="token punctuation">)</span> <span class="token punctuation">[</span>PSYoungGen<span class="token operator">:</span> <span class="token number">1133</span>K<span class="token operator">-&gt;</span><span class="token number">0</span>K<span class="token punctuation">(</span><span class="token number">46592</span>K<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>ParOldGen<span class="token operator">:</span> <span class="token number">8</span>K<span class="token operator">-&gt;</span><span class="token number">1013</span>K<span class="token punctuation">(</span><span class="token number">76800</span>K<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token number">1141</span>K<span class="token operator">-&gt;</span><span class="token number">1013</span>K<span class="token punctuation">(</span><span class="token number">123392</span>K<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>Metaspace<span class="token operator">:</span> <span class="token number">4061</span>K<span class="token operator">-&gt;</span><span class="token number">4061</span>K<span class="token punctuation">(</span><span class="token number">1056768</span>K<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0.0815840</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span>Times<span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.13</span> sys<span class="token operator">=</span><span class="token number">0.00</span><span class="token punctuation">,</span> real<span class="token operator">=</span><span class="token number">0.08</span> secs<span class="token punctuation">]</span> 
</code></pre> 
<p><img src="https://images2.imgbox.com/cf/d7/lNErXma6_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/55/14/iABir8l0_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/febf54b9ea8abdd2bf5a09d276094a15/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python运行异常</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/184b59ef96faad0cba8b30f8eb4d729c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网络故障排查：Ping和Tracert命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>