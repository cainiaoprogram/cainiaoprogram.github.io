<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从C到C&#43;&#43;2——C&#43;&#43;引用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="从C到C&#43;&#43;2——C&#43;&#43;引用" />
<meta property="og:description" content="一..h头文件书写 如果你长时间只是写一个.c或.cpp文件作为一个项目，那么很少会写.h头文件，但是它是我们必须要会的，曾在某公司的笔试题目中考过，所以第一部分就介绍.h头文件的书写模板。
在写头文件时需要注意，在开头和结尾处必须按照如下样式加上预编译语句（如下）：
#ifndef 你的文件名 #define 你的文件名 //两个文件名保持一致 // 你的代码写在这里 #endif 这样做是为了防止重复编译，不这样做就有可能出错。
​ 我们在理解的基础上记忆，比如ifndef其实是if not define，如果没有定义该文件，那么就define xxx.h定义该文件，具体的定义在下面实现，而endif用来表示结束。曾经笔试的一道题目就是.h头文件的格式和作用，那么上面就是答案啦！
二.C&#43;&#43;引用 今天的主要部分就是C&#43;&#43;引用了，顺带一些其他很少讲解但实用的知识点。
1.基本用法 作用：给变量起一个别名
语法：数据类型 &amp;别名 = 原名
int a=10; int &amp;b=a; ​ 从内存的角度来理解这段简单代码，int a=10表示在内存中分配了一个4B的空间，其存放的值是10，我们可以通过变量a来对这块内存空间进行操作，同时第二句代码给a起一个别名叫b，那么以后我们也可以通过b来操作这块内存空间。那么如果你通过b来改变了这块内存的空间的值，那么a代表的内存空间的值也发生变换。
引用可以看做是数据的一个别名，通过这个别名和原来的名字都能够找到这份数据。
2.引用注意事项 引用创建时就必须初始化（也就是说一定要通过=告诉计算机这个引用是哪个变量的别名）引用一旦初始化后就不能更改 3.引用作为函数参数 在定义或声明函数时，我们可以将函数的形参指定为引用的形式，这样在调用函数时就会将实参和形参绑定在一起，让它们都指代同一份数据。如此一来，如果在函数体中修改了形参的数据，那么实参的数据也会被修改，从而拥有“在函数内部影响函数外部数据”的效果。 ​ 对于函数的参数传递，一般有三种传递方法：值传递、指针传递、引用传递。对于值传递我们知道，形参并不改变实参，最简单等的例如交换函数swap：
void swap(int a,int b){ int temp=a; a=b; b=temp; //可以在这里使用cout输出a和b } int main(){ int a=10,b=20; swap(a,b); //也可以在这里使用cout输出a和b } ​ 也就是说，如果使用的值传递，在main函数里的cout输出你会发现并没有交换a和b两个变量的值，只有在swap函数里的cout才会交换两个变量的值，针对这个问题我们采取了引用传递的办法，这些形参就会带动实参的改变。（如果你对指针传递很熟悉，也可以使用指针传递）
4.引用作函数返回值 引用作为函数的返回值时，需要注意以下两点：
不要返回局部变量的引用如果返回值是引用类型，那么函数调用可以作为左值 第一点好理解，局部变量即在函数内部定义的变量，我们不能返回它的引用；主要是第二点怎么理解，直接看代码：
#include &lt;iostream&gt; //声明命名空间std using namespace std; int &amp;func() { static int a = 10; return a; } int main() { int &amp;result = func(); cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1f20f05a624ca6cc7de6250cff0f0f16/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-02T20:16:01+08:00" />
<meta property="article:modified_time" content="2024-01-02T20:16:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从C到C&#43;&#43;2——C&#43;&#43;引用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="h_0"></a>一.<code>.h</code>头文件书写</h2> 
<blockquote> 
 <p>如果你长时间只是写一个<code>.c</code>或<code>.cpp</code>文件作为一个项目，那么很少会写<code>.h</code>头文件，但是它是我们必须要会的，曾在某公司的笔试题目中考过，所以第一部分就介绍<code>.h</code>头文件的书写模板。</p> 
</blockquote> 
<p><strong>在写头文件时需要注意，在开头和结尾处必须按照如下样式加上预编译语句（如下）：</strong></p> 
<pre><code class="prism language-c"> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">你的文件名</span></span>
 <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span>  <span class="token expression">你的文件名       </span><span class="token comment">//两个文件名保持一致</span></span>

 <span class="token comment">// 你的代码写在这里</span>

 <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
</code></pre> 
<p>这样做是<strong>为了防止重复编译</strong>，不这样做就有可能出错。</p> 
<p>​ 我们在理解的基础上记忆，比如<code>ifndef</code>其实是<code>if not define</code>，如果没有定义该文件，那么就<code>define xxx.h</code>定义该文件，具体的定义在下面实现，而<code>endif</code>用来表示结束。曾经笔试的一道题目就是<code>.h</code>头文件的格式和作用，那么上面就是答案啦！</p> 
<h2><a id="C_19"></a>二.C++引用</h2> 
<blockquote> 
 <p>今天的主要部分就是C++引用了，顺带一些其他很少讲解但实用的知识点。</p> 
</blockquote> 
<h3><a id="1_23"></a>1.基本用法</h3> 
<p>作用：给变量起一个别名</p> 
<p>语法：数据类型 &amp;别名 = 原名</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>b<span class="token operator">=</span>a<span class="token punctuation">;</span> 
</code></pre> 
<p>​ 从内存的角度来理解这段简单代码，<code>int a=10</code>表示在内存中分配了一个<code>4B</code>的空间，其存放的值是10，我们可以通过变量<code>a</code>来对这块内存空间进行操作，同时第二句代码给a起一个别名叫b，那么以后我们也可以通过b来操作这块内存空间。那么如果你通过b来改变了这块内存的空间的值，那么a代表的内存空间的值也发生变换。</p> 
<blockquote> 
 <p>引用可以看做是数据的一个别名，<strong>通过这个别名和原来的名字都能够找到这份数据</strong>。</p> 
</blockquote> 
<h3><a id="2_38"></a>2.引用注意事项</h3> 
<ul><li>引用创建时就必须初始化（也就是说一定要通过=告诉计算机这个引用是哪个变量的别名）</li><li>引用一旦初始化后就不能更改</li></ul> 
<h3><a id="3_43"></a>3.引用作为函数参数</h3> 
<pre><code>在定义或声明函数时，我们可以将函数的形参指定为引用的形式，这样在调用函数时就会将实参和形参绑定在一起，让它们都指代同一份数据。如此一来，如果在函数体中修改了形参的数据，那么实参的数据也会被修改，从而拥有“在函数内部影响函数外部数据”的效果。
</code></pre> 
<p>​ 对于函数的参数传递，一般有三种传递方法：值传递、指针传递、引用传递。对于值传递我们知道，形参并不改变实参，最简单等的例如交换函数<code>swap</code>：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token keyword">int</span> temp<span class="token operator">=</span>a<span class="token punctuation">;</span>
	a<span class="token operator">=</span>b<span class="token punctuation">;</span>
	b<span class="token operator">=</span>temp<span class="token punctuation">;</span>
    <span class="token comment">//可以在这里使用cout输出a和b</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">20</span><span class="token punctuation">;</span>
    <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//也可以在这里使用cout输出a和b</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>​ 也就是说，如果使用的值传递，在<code>main</code>函数里的<code>cout</code>输出你会发现并没有交换a和b两个变量的值，只有在<code>swap</code>函数里的<code>cout</code>才会交换两个变量的值，针对这个问题我们采取了引用传递的办法，这些形参就会带动实参的改变。（如果你对指针传递很熟悉，也可以使用指针传递）</p> 
<h3><a id="4_66"></a>4.引用作函数返回值</h3> 
<p>引用作为函数的返回值时，需要注意以下两点：</p> 
<ul><li>不要返回局部变量的引用</li><li>如果返回值是引用类型，那么函数调用可以作为左值</li></ul> 
<p>第一点好理解，局部变量即在函数内部定义的变量，我们不能返回它的引用；主要是第二点怎么理解，直接看代码：</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token comment">//声明命名空间std</span>
using namespace std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> <span class="token operator">&amp;</span>result <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;result="</span> <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>           <span class="token comment">//函数调用可以整体作为左值进行赋值，其实是对a的内存空间存储的数进行修改</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"&amp;result="</span> <span class="token operator">&lt;&lt;</span> result <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>一般情况下函数调用都是作为右值来进行使用的。</p> 
<h3><a id="5_97"></a>5.引用的本质</h3> 
<blockquote> 
 <p>请确保你已了解相关知识点，或者看过我昨天的博客：<a href="https://blog.csdn.net/weixin_51496226/article/details/135297608?spm=1001.2014.3001.5501">从C向C++1</a></p> 
</blockquote> 
<p>引用的本质其实是一个<strong>指针常量</strong>，我们知道指针常量它是永远指向一个地址的常量，但是对应地址的内存空间存储的值是可以改变的，这也是为什么引用初始化后不能再指向其他变量但可以通过引用修改其内存空间的值。</p> 
<pre><code class="prism language-c++">int &amp;ref=a;
//int *const ref = a     这两行代码是等价的
</code></pre> 
<p>在使用引用的过程中，计算机其实就是把它理解为一个指针常量，只不过调用引用时计算机已经在背后完成的指针的相关操作，使其看起来就是一个引用。</p> 
<h2><a id="_110"></a>三.引用补充</h2> 
<h3><a id="1_112"></a>1.常量引用</h3> 
<p>作用：常量引用用来修饰形参，防止误操作</p> 
<pre><code class="prism language-c"><span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>ref<span class="token operator">=</span>a<span class="token punctuation">;</span>           <span class="token comment">//正确使用引用</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>ref<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>          <span class="token comment">//错误代码，因为引用的本质是一个指针常量，必须指向的是一个变量也就是非常量</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span> ref <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment">//正确的，等价于int temp=10;int &amp;ref=temp;</span>
</code></pre> 
<p>一般来说，引用是不支持指向常量的， 或者说必须与<code>const</code>关键字搭配，他才能指向构成一个常量引用（相当于一个缺少了原名只有别名的引用）。但是因为加入了<code>const</code>关键字，虽然我们可以通过别名来访问这片内存空间，但是<code>const</code>导致了其值不能再发生变换，也就是说其只能永远是10。</p> 
<p>​ 在实际的开发过程中，我们经常使用的是引用传递函数参数，这样如果在函数内部对形参进行了误操作那么实参也会发生改变，所以经常在形参前面加一个<code>const</code>关键字，也就是为了防止函数内部对其实参做了某种修改。</p> 
<h3><a id="2_127"></a>2.引用与指针</h3> 
<ol><li>引用必须在定义时初始化，并且以后也要从一而终，不能再指向其他数据；而指针没有这个限制，指针在定义时不必赋值，以后也能指向任意数据。</li><li>指针可以有多级，但是引用只能有一级，例如，<code>int **p</code>是合法的，而<code>int &amp;&amp;r</code>是不合法的。如果希望定义一个引用变量来指代另外一个引用变量，那么也只需要加一个<code>&amp;</code>，如下所示：</li></ol> 
<pre><code class="prism language-c"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> a<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>rr <span class="token operator">=</span> r<span class="token punctuation">;</span>
</code></pre> 
<ol start="3"><li> <p>指针和引用的自增（++）自减（–）运算意义不一样。对指针使用 ++ 表示指向下一份数据，对引用使用 ++ 表示它所指代的数据本身加 1；自减（–）也是类似的道理。</p> 
  <blockquote> 
   <p>重点：在计算机408考研中的计组会涉及。</p> 
  </blockquote> </li></ol> 
<h3><a id="3_142"></a>3.临时数据</h3> 
<p>​ 其实 C++ 代码中的大部分内容都是放在<strong>内存</strong>中的，例如定义的变量、创建的对象、字符串常量、函数形参、函数体本身、<code>new</code>或<code>malloc()</code>分配的内存等，这些内容都可以用<code>&amp;</code>来获取地址，进而用指针指向它们。除此之外，还有一些我们平时不太留意的<strong>临时数据</strong>，例如表达式的结果、函数的返回值等，它们可能会放在内存中，也可能会放在寄存器中。一旦它们被放到了<strong>寄存器</strong>中，就没法用<code>&amp;</code>获取它们的地址了，也就没法用指针指向它们了。</p> 
<p>​ 寄存器离 CPU 近，并且速度比内存快，将临时数据放到寄存器是为了加快程序运行。但是寄存器的数量是非常有限的，容纳不下较大的数据，所以只能将较小的临时数据放在寄存器中。<code>int、double、bool、char </code>等基本类型的数据往往不超过 8 个字节，用一两个寄存器就能存储，所以这些类型的临时数据通常会放到寄存器中；而对象、结构体变量是自定义类型的数据，大小不可预测，所以这些类型的临时数据通常会放到内存中。</p> 
<p>​ 诸如 100、200+34、34.5*23、3+7/3 等不包含变量的表达式称为常量表达式。常量表达式由于<strong>不包含变量</strong>，没有不稳定因素，所以在编译阶段就能求值。编译器不会分配单独的内存来存储常量表达式的值，而是将常量表达式的值和代码合并到一起，放到虚拟地址空间中的<strong>代码区</strong>(下一部分写程序的分区)。总起来说，常量表达式的值虽然在内存中，但是没有办法寻址，所以也不能使用<code>&amp;</code>来获取它的地址，更不能用指针指向它。</p> 
<p>​ 引用和指针在本质上是一样的，引用仅仅是对指针进行了简单的封装。引用和指针都不能绑定到无法寻址的临时数据，并且 C++ 对引用的要求更加严格，在某些编译器下甚至连放在内存中的临时数据都不能指代，这也是单纯的引用无法指向常量的原因。</p> 
<blockquote> 
 <p>总结起来说，给引用添加<code> const</code> 限定后，不但可以将引用绑定到临时数据，还可以将引用绑定到类型相近的数据，这使得引用更加灵活和通用，它们背后的机制都是临时变量。</p> 
</blockquote> 
<h2><a id="_154"></a>四.程序的内存模型</h2> 
<h3><a id="1_156"></a>1.内存分区模型</h3> 
<p>C++程序在执行时，将内存大方向划分为4个区域：</p> 
<ul><li>代码区:存放函数体的二进制代码，由操作系统进行管理的</li><li>全局区: 存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放,存放函数的参数值局部变最等</li><li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li></ul> 
<h3><a id="2_165"></a>2.程序运行前</h3> 
<p>在程序编译后，生成了<code>.exe</code>可执行程序，未执行该程序前分为两个区域：</p> 
<ul><li>代码区： 
  <ul><li>存放CPU执行的机器指令</li><li>代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</li><li>代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</li></ul> </li><li>全局区： 
  <ul><li>全局变量和<strong>静态变量</strong>（<code>static</code>关键字）存放在此</li><li>全局区还包含了<strong>常量</strong>区，字符串常量和其他常量（<code>const</code>修饰的全局变量）也存放在此</li><li><strong>该区域的数据在程序结束后由操作系统释放</strong></li></ul> </li></ul> 
<blockquote> 
 <p>注意：<code>const</code>修饰的局部变量叫局部常量，其并不在全局区。</p> 
</blockquote> 
<h3><a id="3_180"></a>3.程序运行后</h3> 
<ul><li> <p>栈区：由编译器自动分配释放，存放函数的参教值，局部变量等。</p> 
  <blockquote> 
   <p>注意事项: <strong>不要返回局部变量的地址</strong>，栈区开辟的数据由编译器自动释放</p> 
  </blockquote> </li></ul> 
<p>因为如果某个函数返回的是其局部变量的地址，在其函数执行完后，该函数对应的栈内存空间被自动释放，你在<code>main</code>函数里调用该函数的返回值也得不到你想要的数据。</p> 
<ul><li> <p>堆区：由程序员分配释放，若程序员不释放，程序结束时由操作系统回收。</p> <p>在C++中主要利用new在堆区开辟内存，在C语言中用<code>malloc</code>开辟内存</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d8e9b6a2ce80cae17e1f5cf738fff768/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ABC201(A-C)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a0e83c12ba2f07a307faf4902e27827d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">词嵌入位置编码的实现（基于pytorch）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>