<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>VTK将二维图像向三维空间中无参数化的曲面表面进行纹理映射（含代码） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="VTK将二维图像向三维空间中无参数化的曲面表面进行纹理映射（含代码）" />
<meta property="og:description" content="实现纹理映射主要是建立纹理空间与模型空间、模型空间与屏幕空间之间的映射关系(见图 6-28)：
其中纹理空间可以定义为u-v 空间，每个轴标范围为 (0.1)。其中对于一个纹理图像，其左下角 v 标为 0.0)，右上角标为 1.1)。而对于简单的参数模型，可以方便地建立模型与纹理空间的映射关系，例如球面、圆柱面等。
而根据图形学三维空间变换容易实现模型空间到屏幕空间的变换，因此最终显示在计算机屏幕上的图像即是纹理映射后的结果。
而对于无参数化曲面的纹理映射技术，通常需要将纹理空间到模型空间的映射分解为两个简单映射。这里需要引入一个包围景物的中介三维曲面作为中介映射媒介，主要实现步骤如下：
1.先将二维纹理空间映射为一个简单的三维物体表面，例如球面、圆柱面等;
2.然后将上述中介物体表面的纹理映射到模型表面，例如以模型表面法线与中介模型的交点作为映射点。这样即可实现由纹理空间到模型空间的映射。
VTK中定义了多个类实现纹理空间到模型空间的映射，例如vtkTextureMapToPlane通过一个平面建立纹理空间到模型空间的映射关系;
vtkTextureMapToCylinder 通过圆柱面建立映射关系;
vtkTextureMapToSphere 通过球面建立映射关系。
vtkTexture 则实现加载纹理(在第2章中已经介绍过)。另外，vtkTransformTextureCoords 也是一个非常有用的类，可以实现纹理坐标的平移和缩放，例如，如果要实现重复纹理，只需通过vtkTransformTextureCoords::SetScale()将纹理坐标每个方向进行放大，如由[0,1]变换到[0,101即可。
下例中使用vtkTextureMapToCylinder 来建立纹理映射(TextureMap.cpp):
#include &lt;vtkSmartPointer.h&gt; #include &lt;vtkRenderWindowInteractor.h&gt; #include &lt;vtkRenderWindow.h&gt; #include &lt;vtkRenderer.h&gt; #include &lt;vtkActor.h&gt; #include &lt;vtkPolyDataMapper.h&gt; #include &lt;vtkTransformTextureCoords.h&gt; #include &lt;vtkTexture.h&gt; #include &lt;vtkTextureMapToSphere.h&gt; #include &lt;vtkTextureMapToCylinder.h&gt; #include &lt;vtkBMPReader.h&gt; #include &lt;vtkTexturedSphereSource.h&gt; #include &lt;vtkXMLPolyDataReader.h&gt; //测试：../data/masonry.bmp ../data/cow.vtp int main (int argc, char *argv[]) { if (argc &lt; 3) { std::cout &lt;&lt; &#34;Usage: &#34; &lt;&lt; argv[0] &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/87ef5a93ee9b170ce20e338b10d2e55a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-08T14:14:59+08:00" />
<meta property="article:modified_time" content="2024-01-08T14:14:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">VTK将二维图像向三维空间中无参数化的曲面表面进行纹理映射（含代码）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>实现纹理映射主要是建立纹理空间与模型空间、模型空间与屏幕空间之间的映射关系(见图 6-28)：</p> 
<p>                              <img alt="" height="253" src="https://images2.imgbox.com/56/96/yZlnFbKA_o.png" width="446"></p> 
<p>        其中纹理空间可以定义为u-v 空间，每个轴标范围为 (0.1)。其中对于一个纹理图像，其左下角 v 标为 0.0)，右上角标为 1.1)。而对于简单的参数模型，可以方便地建立模型与纹理空间的映射关系，例如<strong>球面、圆柱面</strong>等。</p> 
<p>        而根据图形学三维空间变换容易实现模型空间到屏幕空间的变换，因此最终显示在计算机屏幕上的图像即是纹理映射后的结果。</p> 
<p>        而对于<strong>无参数化曲面</strong>的纹理映射技术，通常需要将纹理空间到模型空间的映射分解为两个简单映射。这里需要引入一个包围景物的<strong>中介三维曲面作为中介映射媒介</strong>，主要实现步骤如下：</p> 
<p>        1.先将<strong>二维纹理空间</strong>映射为一个<strong>简单的三维物体表面</strong>，例如球面、圆柱面等;</p> 
<p>        2.然后将上述<strong>中介物体表面</strong>的纹理映射到<strong>模型表面</strong>，例如以<strong>模型表面法线</strong>与中介模型的<strong>交点作为映射点</strong>。这样即可实现由纹理空间到模型空间的映射。<br>         VTK中定义了多个类实现纹理空间到模型空间的映射，例如vtkTextureMapToPlane通过一个<strong>平面</strong>建立纹理空间到模型空间的映射关系;</p> 
<p>        vtkTextureMapToCylinder 通过<strong>圆柱面</strong>建立映射关系;</p> 
<p><img alt="" height="636" src="https://images2.imgbox.com/17/18/OyKyEy1X_o.png" width="891"></p> 
<p>        vtkTextureMapToSphere 通过<strong>球面</strong>建立映射关系。</p> 
<p><img alt="" height="616" src="https://images2.imgbox.com/3d/b5/LnZB8jSG_o.png" width="1192"></p> 
<p>        vtkTexture 则实现加载纹理(在第2章中已经介绍过)。另外，vtkTransformTextureCoords 也是一个非常有用的类，可以实现<strong>纹理坐标的平移和缩放</strong>，例如，如果要实现重复纹理，只需通过vtkTransformTextureCoords::SetScale()将纹理坐标每个方向进行放大，如由[0,1]变换到[0,101即可。</p> 
<p>下例中使用vtkTextureMapToCylinder 来建立纹理映射(TextureMap.cpp):</p> 
<pre><code>#include &lt;vtkSmartPointer.h&gt;
#include &lt;vtkRenderWindowInteractor.h&gt;
#include &lt;vtkRenderWindow.h&gt;
#include &lt;vtkRenderer.h&gt;
#include &lt;vtkActor.h&gt;
#include &lt;vtkPolyDataMapper.h&gt;
#include &lt;vtkTransformTextureCoords.h&gt;
#include &lt;vtkTexture.h&gt;
#include &lt;vtkTextureMapToSphere.h&gt;
#include &lt;vtkTextureMapToCylinder.h&gt;
#include &lt;vtkBMPReader.h&gt;
#include &lt;vtkTexturedSphereSource.h&gt;
#include &lt;vtkXMLPolyDataReader.h&gt;

//测试：../data/masonry.bmp ../data/cow.vtp
int main (int argc, char *argv[])
{
	if (argc &lt; 3)
	{
		std::cout &lt;&lt; "Usage: " &lt;&lt; argv[0]
		&lt;&lt; "texture(.png)"
			&lt;&lt; "model(.vtp)" &lt;&lt;std::endl;
		return EXIT_FAILURE;
	}

	double translate[3];
	translate[0] = 10.0;
	translate[1] = 0.0;
	translate[2] = 0.0;
	std::cout &lt;&lt; translate[0] &lt;&lt; ", "
		&lt;&lt; translate[1] &lt;&lt; ", "
		&lt;&lt; translate[2] &lt;&lt; "\n";

	vtkSmartPointer&lt;vtkBMPReader&gt; texReader =
		vtkSmartPointer&lt;vtkBMPReader&gt;::New();
	texReader-&gt;SetFileName(argv[1]);

	vtkSmartPointer&lt;vtkTexture&gt; texture =
		vtkSmartPointer&lt;vtkTexture&gt;::New();
	texture-&gt;SetInputConnection(texReader-&gt;GetOutputPort());

	vtkSmartPointer&lt;vtkXMLPolyDataReader&gt; modelReader =
		vtkSmartPointer&lt;vtkXMLPolyDataReader&gt;::New();
	modelReader-&gt;SetFileName(argv[2]);

	vtkSmartPointer&lt;vtkTextureMapToCylinder&gt; texturemap = 
		vtkSmartPointer&lt;vtkTextureMapToCylinder&gt;::New();
	texturemap-&gt;SetInputConnection(modelReader-&gt;GetOutputPort());

	vtkSmartPointer&lt;vtkPolyDataMapper&gt; mapper =
		vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
	mapper-&gt;SetInputConnection(texturemap-&gt;GetOutputPort());

	vtkSmartPointer&lt;vtkActor&gt; actor =
		vtkSmartPointer&lt;vtkActor&gt;::New();
	actor-&gt;SetMapper( mapper );
	actor-&gt;SetTexture( texture );

	vtkSmartPointer&lt;vtkRenderer&gt; renderer =
		vtkSmartPointer&lt;vtkRenderer&gt;::New();
	renderer-&gt;AddActor(actor);
	renderer-&gt;SetBackground(1.0, 1.0, 1.0);

	vtkSmartPointer&lt;vtkRenderWindow&gt; renderWindow =
		vtkSmartPointer&lt;vtkRenderWindow&gt;::New();
	renderWindow-&gt;AddRenderer( renderer );

	vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; renWinInteractor =
		vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::New();
	renWinInteractor-&gt;SetRenderWindow( renderWindow );

	renderWindow-&gt;SetSize(640, 480);
	renderWindow-&gt;Render();
	renderWindow-&gt;SetWindowName("TextureMap");
	renderWindow-&gt;Render();
	renderWindow-&gt;Render();
	renWinInteractor-&gt;Start();

	return EXIT_SUCCESS;
}</code></pre> 
<p>代码中先使用vtkTexture 来加载纹理图像，并通过vtkActor::SetTexture()设置纹理:然后<br> 使用vtkTextureMapToCylinder 来建立纹理空间与模型空间的映射关系;最后通过VTK 渲染<br> 引擎进行渲染，执行结果如图 6-29所示:</p> 
<p><img alt="" height="377" src="https://images2.imgbox.com/80/f0/euLGJZ7i_o.png" width="661"></p> 
<p><strong>几何纹理</strong><br> 图像纹理不能模拟形状的变化.1978年，Blinn提出产生<strong>几何纹理，模拟凸凹不平的物体表面</strong>的方法（凹凸映射，Bump mapping）</p> 
<p><strong>基本思想</strong><br> 生成图像时，对曲面的法向量进行扰动。</p> 
<p><img alt="" height="498" src="https://images2.imgbox.com/d2/09/eDxTtq3L_o.png" width="1189"></p> 
<p>对景物表面各采样点位置作微小的扰动，改变表面的微观几何形状，引起景物表面法向量的扰动。<br> 景物表面光亮度是法向量的函数：法向量的扰动导致表面光亮度的突变，产生表面凹凸不平的真实效果。</p> 
<p><br><strong>几何纹理的实现</strong><br> 1.将扰动后的法向量单位化，用于计算曲面的明暗度，产生凹凸不平的几何纹理；<br> 2.几何纹理函数：用二维数组记录各象素的值，图案中较暗颜色对应较小F值，较亮颜色对应较大F值；<br> 3.F的偏导数的计算，可以用中心差分实现。</p> 
<p><img alt="" height="298" src="https://images2.imgbox.com/ae/ac/IlPPPl1G_o.png" width="646"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b15ec005c74367eb43f4bae0003b6045/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">那几本霸占我休息时间的PDF！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5255a0145f13896ef1e3cc141163611e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">目标检测-One Stage-YOLOv5</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>