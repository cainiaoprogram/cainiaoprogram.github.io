<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Kafka中的max-poll-records和listener.concurrency配置 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Kafka中的max-poll-records和listener.concurrency配置" />
<meta property="og:description" content="1、max-poll-records是什么 max-poll-records是Kafka consumer的一个配置参数，表示consumer一次从Kafka broker中拉取的最大消息数目，默认值为500条。在Kafka中，一个消费者组可以有多个consumer实例，每个consumer实例负责消费一个或多个partition的消息，每个consumer实例一次从broker中可以拉取一个或多个消息。
max-poll-records参数的作用就是控制每次拉取消息的最大数目，以实现消费弱化和控制内存资源的需求。
2、max-poll-records解决的问题 避免一次性加载大量数据：
一次性拉取数量过大，会导致拉取消息时间过长，对broker和网络资源造成过度压力，同时consumer实例应用内存消耗过大，从而影响应用性能。如果要通过增加consumer实例数量或增加机器内存来解决该问题，则会增加成本；而通过控制每次拉取的消息数目，可以实现内存资源控制和应用性能优化。
更好地控制消息轮询的间隔时间：
当consumer实例消费消息的速度比broker生产消息的速度慢时，consumer会产生轮询时间间隔。如果轮询时间跨度过长，则会严重地延迟消息消费。而通过设置max-poll-records，可以控制consumer拉取消息的频率，进而控制消息消费的时间。
3、max-poll-records的最佳实践 max-poll-records的最佳实践共有下述三个核心思想：
3.1 根据机器内存和consumer实例数量调整参数
在设置max-poll-records参数时，应根据机器内存和实例数量来调整参数值，从而实现更好的性能和内存控制。如果消费数据量不大，可以设置较小的值，反之，如果消费数据量很大，则可以设置更大的值。
3.2 注意正确理解和使用max-poll-records
max-poll-records参数不是为了减少消息延迟而设置的，而是为了控制内存和消费弱化而设置的。在设置参数时应该明确这一点，从而更好地利用这个参数。
3.3 尽可能使用手动提交offset的方式
使用自动提交offset的方式，可能存在一些问题。如果一个消息批次在服务端已经被消费掉，但是由于客户端宕机或重启而没有及时提交offset，则可能导致消息重复消费的情况。因此， 建议在设置max-poll-records的同时，使用手动提交offset的方式。
4、案例实践 当前kafka的版本为2.8.11，Spring Boot的版本为2.7.6，在pom.xml中引入下述依赖：
&lt;dependency&gt; &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt; &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt; &lt;version&gt;2.8.11&lt;/version&gt; &lt;/dependency&gt; 在yml配置文件进行如下配置：
spring: kafka: bootstrap-servers: 127.0.0.1:9092 consumer: group-id: 0 key-deserializer: org.apache.kafka.common.serialization.StringDeserializer value-deserializer: org.apache.kafka.common.serialization.StringDeserializer enable-auto-commit: false max-poll-records: 20 producer: key-serializer: org.apache.kafka.common.serialization.StringSerializer value-serializer: org.apache.kafka.common.serialization.StringSerializer listener: ack-mode: manual_immediate type: batch concurrency: 2 以下为相关配置的说明： spring.kafka.listener.type的值为batch表示开启批量消费，默认值为single(单条)。spring.kafka.consumer.enable-auto-commit的值为false表示关闭Kafka客户端的自动提交offSet。spring.kafka.consumer.max-poll-records的值为20表示在开启了批量消费以后，每次从Kafka服务端拉取的数据最大条数为20。spring.kafka.listener.ack-mode的值为manual_immediate表示关闭Spring的自动提交offSet，我们需要在代码中进行手动提交。spring.kafka.listener.ack-mode的取值有两个比较常见的选项值 MANUAL 和 MANUAL_IMMEDIATE。MANUAL表示处理完业务后，手动调用Acknowledgment.acknowledge()先将offset存放到map本地缓存，在下一次poll之前从缓存拿出来批量提交。MANUAL_IMMEDIATE表示每次处理完业务，手动调用Acknowledgment.acknowledge()后立即提交。 在项目中创建一个生产者用于往主题 topic0 中投递消息，如下所示：
import lombok.extern.slf4j.Slf4j; import org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1922c1c25b3bc0b861ee6a835df77cb0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-23T10:00:00+08:00" />
<meta property="article:modified_time" content="2023-12-23T10:00:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Kafka中的max-poll-records和listener.concurrency配置</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4><strong>1、max-poll-records是什么</strong></h4> 
<p><span style="color:#fe2c24;"><strong>max-poll-records</strong></span>是Kafka consumer的一个配置参数，表示consumer一次从Kafka broker中拉取的最大消息数目，默认值为<span style="color:#fe2c24;"><strong>500</strong></span>条。在Kafka中，一个消费者组可以有多个consumer实例，每个consumer实例负责消费一个或多个partition的消息，每个consumer实例一次从broker中可以拉取一个或多个消息。</p> 
<p><span style="color:#b95514;">max-poll-records参数的作用就是控制每次拉取消息的最大数目，以实现消费弱化和控制内存资源的需求。</span></p> 
<h4><strong>2、max-poll-records解决的问题</strong></h4> 
<p><span style="color:#fe2c24;"><strong>避免一次性加载大量数据：</strong></span></p> 
<blockquote> 
 <p>一次性拉取数量过大，会导致拉取消息时间过长，对broker和网络资源造成过度压力，同时consumer实例应用内存消耗过大，从而影响应用性能。如果要通过增加consumer实例数量或增加机器内存来解决该问题，则会增加成本；而通过控制每次拉取的消息数目，可以实现内存资源控制和应用性能优化。</p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong>更好地控制消息轮询的间隔时间：</strong></span></p> 
<blockquote> 
 <p>当consumer实例消费消息的速度比broker生产消息的速度慢时，consumer会产生轮询时间间隔。如果轮询时间跨度过长，则会严重地延迟消息消费。而通过设置max-poll-records，可以控制consumer拉取消息的频率，进而控制消息消费的时间。</p> 
</blockquote> 
<h4><strong>3、max-poll-records的最佳实践</strong></h4> 
<p><span style="color:#b95514;">max-poll-records的最佳实践共有下述三个核心思想：</span></p> 
<p><span style="color:#511b78;"><strong>3.1 根据机器内存和consumer实例数量调整参数</strong></span></p> 
<p>在设置max-poll-records参数时，应根据机器内存和实例数量来调整参数值，从而实现更好的性能和内存控制。如果消费数据量不大，可以设置较小的值，反之，如果消费数据量很大，则可以设置更大的值。</p> 
<p><span style="color:#1a439c;"><strong>3.2 注意正确理解和使用max-poll-records</strong></span></p> 
<p>max-poll-records参数不是为了减少消息延迟而设置的，而是为了控制内存和消费弱化而设置的。在设置参数时应该明确这一点，从而更好地利用这个参数。</p> 
<p><span style="color:#1c7892;"><strong>3.3 尽可能使用手动提交offset的方式</strong></span></p> 
<p>使用自动提交offset的方式，可能存在一些问题。如果一个消息批次在服务端已经被消费掉，但是由于客户端宕机或重启而没有及时提交offset，则可能导致消息重复消费的情况。因此， 建议在设置max-poll-records的同时，使用手动提交offset的方式。</p> 
<h4><strong>4、案例实践</strong></h4> 
<p>当前kafka的版本为2.8.11，Spring Boot的版本为2.7.6，在pom.xml中引入下述依赖：</p> 
<pre><code class="language-html">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;
    &lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;
    &lt;version&gt;2.8.11&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p>在yml配置文件进行如下配置：</p> 
<pre><code class="language-bash">spring:
  kafka:
    bootstrap-servers: 127.0.0.1:9092
    consumer:
      group-id: 0
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      enable-auto-commit: false
      max-poll-records: 20
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.apache.kafka.common.serialization.StringSerializer
    listener:
      ack-mode: manual_immediate
      type: batch
      concurrency: 2</code></pre> 
<p>以下为相关配置的说明： </p> 
<blockquote> 
 <ul><li><span style="color:#fe2c24;"><strong>spring.kafka.listener.type</strong></span>的值为batch表示开启批量消费，默认值为single(单条)。</li><li><span style="color:#fe2c24;"><strong>spring.kafka.consumer.enable-auto-commit</strong></span>的值为false表示关闭Kafka客户端的自动提交offSet。</li><li><span style="color:#fe2c24;"><strong>spring.kafka.consumer.max-poll-records</strong></span>的值为20表示在开启了批量消费以后，每次从Kafka服务端拉取的数据最大条数为20。</li><li><span style="color:#fe2c24;"><strong>spring.kafka.listener.ack-mode</strong></span>的值为manual_immediate表示关闭Spring的自动提交offSet，我们需要在代码中进行手动提交。spring.kafka.listener.ack-mode的取值有两个比较常见的选项值<span style="color:#1a439c;"> <strong>MANUAL </strong></span>和<span style="color:#1a439c;"><strong> MANUAL_IMMEDIATE</strong></span>。<span style="color:#be191c;"><strong>MANUAL</strong></span>表示处理完业务后，手动调用Acknowledgment.acknowledge()先将offset存放到map本地缓存，在下一次poll之前从缓存拿出来批量提交。<span style="color:#be191c;"><strong>MANUAL_IMMEDIATE</strong></span>表示每次处理完业务，手动调用Acknowledgment.acknowledge()后立即提交。</li></ul> 
</blockquote> 
<p>在项目中创建一个生产者用于往主题 <span style="color:#fe2c24;"><strong>topic0 </strong></span>中投递消息，如下所示：</p> 
<pre><code class="language-java">import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.support.SendResult;
import org.springframework.util.concurrent.ListenableFuture;
import org.springframework.util.concurrent.ListenableFutureCallback;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@Slf4j
@RestController
@RequestMapping("/kafka")
public class KafkaProducer {

    // 自定义的主题名称
    public static final String TOPIC_NAME="topic0";

    @Autowired
    private KafkaTemplate&lt;String, String&gt; kafkaTemplate;

    @RequestMapping("/send")
    public String send(@RequestParam("msg")String msg) {
        log.info("准备发送消息为：{}",msg);
        // 1.发送消息
        ListenableFuture&lt;SendResult&lt;String,String&gt;&gt; future=kafkaTemplate.send(TOPIC_NAME,msg);
        future.addCallback(new ListenableFutureCallback&lt;SendResult&lt;String, String&gt;&gt;() {
            @Override
            public void onFailure(Throwable throwable) {
                // 2.发送失败的处理
                log.error("生产者 发送消息失败："+throwable.getMessage());
            }
            @Override
            public void onSuccess(SendResult&lt;String, String&gt; stringObjectSendResult) {
                // 3.发送成功的处理
                log.info("生产者 发送消息成功："+stringObjectSendResult.toString());
            }
        });
        return "接口调用成功";
    }
}</code></pre> 
<p>接着再在项目中创建一个消费者用于批量消费主题<span style="color:#fe2c24;"><strong> topic0 </strong></span>中的消息，如下所示： </p> 
<pre><code class="language-java">import lombok.extern.slf4j.Slf4j;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.kafka.support.Acknowledgment;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;

@Slf4j
@Component
public class KafkaConsumer {

    // 自定义主题名称，这里要注意的是主题名称中不能包含特殊符号：“.”、“_”
    public static final String TOPIC_NAME = "topic0";

    @KafkaListener(topics = TOPIC_NAME, groupId = "ONE")
    public void topic_one(List&lt;ConsumerRecord&lt;?, ?&gt;&gt; records, Acknowledgment acknowledgment) {
        log.info("消费者组One批量消费的数据量 = {}", records == null ? 0 : records.size());
        for(ConsumerRecord&lt;?, ?&gt; record : records){
            Optional message = Optional.ofNullable(record.value());
            if (message.isPresent()) {
                //Object msg = message.get();
                //log.info("消费者组One消费了消息：Topic:" + TOPIC_NAME + ",Record:" + record + ",Message:" + msg);
            }
        }
        acknowledgment.acknowledge();
    }
}</code></pre> 
<p>启动整个项目，这时控制台中会打印下述信息：</p> 
<pre><code class="language-java language-bash">ConsumerConfig values:
auto.commit.interval.ms = 5000
auto.offset.reset = latest
bootstrap.servers = [127.0.0.1:9092]
client.id = consumer-ONE-1
enable.auto.commit = false
group.id = ONE
max.poll.records = 20
key.deserializer = class org.apache.kafka.common.serialization.StringDeserializer
value.deserializer = class org.apache.kafka.common.serialization.StringDeserializer</code></pre> 
<p>紧接着使用Apipost的压测工具调用<span style="color:#fe2c24;"><strong> /kafka/send?msg=1 </strong></span>接口往主题 <span style="color:#fe2c24;"><strong>topic0 </strong></span>中生产100条消息，稍微等了一会后可以看到在控制台中该消息已经被批量消费了，如下所示：</p> 
<pre><code class="language-bash">消费者组One批量消费的数据量 = 20
消费者组One批量消费的数据量 = 20
消费者组One批量消费的数据量 = 20
消费者组One批量消费的数据量 = 20
消费者组One批量消费的数据量 = 20</code></pre> 
<p>再次使用Apipost的压测工具调用<span style="color:#fe2c24;"><strong> /kafka/send?msg=1 </strong></span>接口往主题<span style="color:#fe2c24;"><strong>topic0</strong></span>中生产100条消息，可以看到后面的消息都是即时批量拉取、即时批量消费，每次批量的拉取的数据量都没有超过最大限制数：</p> 
<pre><code class="language-bash">消费者组One批量消费的数据量 = 2
消费者组One批量消费的数据量 = 20
消费者组One批量消费的数据量 = 10
消费者组One批量消费的数据量 = 20
消费者组One批量消费的数据量 = 8
消费者组One批量消费的数据量 = 10
消费者组One批量消费的数据量 = 6
消费者组One批量消费的数据量 = 10
消费者组One批量消费的数据量 = 11
消费者组One批量消费的数据量 = 3</code></pre> 
<h4><strong>5、listener.concurrency</strong></h4> 
<p>上述yml配置文件中 <span style="color:#fe2c24;"><strong>spring.kafka.listener.concurrency </strong></span>的值为2，这个表示在代码中标记了<span style="color:#1a439c;"><strong>@KafkaListener</strong></span>注解的方法处会启动两个消费者线程任务并发处理。 但是如果一个主题只有一个分区的话，消息只能被一个消费者组里面的一个消息者所消费，所以即使开了多个并发线程也没有用的。</p> 
<p>一个消费者可以消费同一个topic的多个分区，但是一个分区不能被同一个组下的多个消费者消费。同一个组下有多个消费者并发消费同一个topic时，要注意设置的消费者并发个数一定要小于等于topic的分区数，不然会有空置的线程没有分区可以消费。</p> 
<p>设置并发的时候根据分区数和消费者的个数来分配每个消费者消费几个分区，消费者可以消费一个或多个分区。例如两个分区的话，如果想增强消息的消费速度，在没有进行消费者服务的横向扩展时，可以考虑采用增加消费者的并发数量，将并发数量修改为2。</p> 
<p><span style="color:#fe2c24;"><strong>项目中总的消费者线程数量为： concurrency * 标记了@KafkaListener注解方法的数量（默认监听全部的partition）</strong></span></p> 
<blockquote> 
 <ul><li>当concurrency &lt; partition 的数量，会出现消费不均的情况，一个消费者的线程可能消费多个partition 的数据</li><li>当concurrency = partition 的数量，最佳状态，一个消费者的线程消费一个 partition 的数据</li><li>当concurrency &gt; partition 的数量，会出现有的消费者的线程没有可消费的partition， 造成资源的浪费</li></ul> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8b44a9d20035effcc4150f3ff5ec168a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">数据存储【七】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fd82f5b908772b2ac09f64c3a1a31d94/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一个简单的获取显示器长宽和显示器分辨的代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>