<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HashMap实现原理分析(源码分析，ReHash，) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HashMap实现原理分析(源码分析，ReHash，)" />
<meta property="og:description" content="目录
一、HashMap的数据结构
解决hash冲突的办法
二、源码分析
1. 位桶数组
2. 数组元素Node实现了Entry接口,v&gt;
3. HashMap如何put(key，value）
4. HashMap如何getValue值
5. HasMap的扩容机制resize();
6. JDK1.8使用红黑树的改进
三、再谈ReHash
单线程下的ReHash
并发下的Rehash
一、HashMap的数据结构 数据结构中有 数组 和 链表 来实现对数据的存储，但这两者基本上是两个极端。 （堆砌了别人的文章！呵呵呵）
数组
数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；
链表
链表存储区间离散(不连续)，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，O（N）。链表的特点是：寻址困难，插入和删除容易。
哈希表
那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。
当链表数组的容量超过初始容量的0.75时，再散列将链表数组扩大2倍，把原链表数组的搬移到新的数组中
加载因子（默认0.75）：为什么需要使用加载因子，为什么需要扩容呢？因为如果填充比很大，说明利用的空间很多，如果一直不进行扩容的话，链表就会越来越长，这样查找的效率很低，因为链表的长度很大（当然最新版本使用了红黑树后会改进很多），扩容之后，将原来链表数组的每一个链表分成奇偶两个子链表分别挂在新链表数组的散列位置，这样就减少了每个链表的长度，增加查找效率
HashMap本来是以空间换时间，所以填充比没必要太大。但是填充比太小又会导致空间浪费。如果关注内存，填充比可以稍大，如果主要关注查找性能，填充比可以稍小。
即HashMap的原理图是：
解决hash冲突的办法 开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）再哈希法链地址法建立一个公共溢出区 Java中hashmap的解决办法就是采用的链地址法（也称为拉链法）。
二、源码分析 1. 位桶数组 transient Node&lt;K,V&gt;[] table; 2. 数组元素Node&lt;K,V&gt;实现了Entry接口 public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable { private static final long serialVersionUID = 362498820763181265L; /** * 初始大小 - MUST be a power of two." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/804c707e1ec20aaef94c26aa6ed55eb9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-20T19:03:01+08:00" />
<meta property="article:modified_time" content="2019-12-20T19:03:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HashMap实现原理分析(源码分析，ReHash，)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81HashMap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81HashMap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" rel="nofollow">一、HashMap的数据结构</a></p> 
<p id="WizKMOutline_1383296103994211-toc" style="margin-left:80px;"><a href="#WizKMOutline_1383296103994211" rel="nofollow">解决hash冲突的办法</a></p> 
<p id="%E4%BA%8C%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90" rel="nofollow">二、源码分析</a></p> 
<p id="1.%C2%A0%C2%A0%E4%BD%8D%E6%A1%B6%E6%95%B0%E7%BB%84-toc" style="margin-left:80px;"><a href="#1.%C2%A0%C2%A0%E4%BD%8D%E6%A1%B6%E6%95%B0%E7%BB%84" rel="nofollow">1.  位桶数组</a></p> 
<p id="2.%C2%A0%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0Node%3CK%2CV%3E%E5%AE%9E%E7%8E%B0%E4%BA%86Entry%E6%8E%A5%E5%8F%A3-toc" style="margin-left:80px;"><a href="#2.%C2%A0%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0Node%3CK%2CV%3E%E5%AE%9E%E7%8E%B0%E4%BA%86Entry%E6%8E%A5%E5%8F%A3" rel="nofollow">2. 数组元素Node实现了Entry接口,v&gt;</a></p> 
<p id="%C2%A03.%C2%A0HashMap%E5%A6%82%E4%BD%95put(key%EF%BC%8Cvalue%EF%BC%89-toc" style="margin-left:80px;"><a href="#%C2%A03.%C2%A0HashMap%E5%A6%82%E4%BD%95put%28key%EF%BC%8Cvalue%EF%BC%89" rel="nofollow"> 3. HashMap如何put(key，value）</a></p> 
<p id="4.%C2%A0HashMap%E5%A6%82%E4%BD%95getValue%E5%80%BC-toc" style="margin-left:80px;"><a href="#4.%C2%A0HashMap%E5%A6%82%E4%BD%95getValue%E5%80%BC" rel="nofollow">4. HashMap如何getValue值</a></p> 
<p id="5.%C2%A0HasMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6resize()%3B-toc" style="margin-left:80px;"><a href="#5.%C2%A0HasMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6resize%28%29%3B" rel="nofollow">5. HasMap的扩容机制resize();</a></p> 
<p id="6.%20JDK1.8%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%94%B9%E8%BF%9B-toc" style="margin-left:80px;"><a href="#6.%20JDK1.8%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%94%B9%E8%BF%9B" rel="nofollow">6. JDK1.8使用红黑树的改进</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%86%8D%E8%B0%88ReHash-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%86%8D%E8%B0%88ReHash" rel="nofollow">三、再谈ReHash</a></p> 
<p id="%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84ReHash-toc" style="margin-left:40px;"><a href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84ReHash" rel="nofollow">单线程下的ReHash</a></p> 
<p id="%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84Rehash-toc" style="margin-left:40px;"><a href="#%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84Rehash" rel="nofollow">并发下的Rehash</a></p> 
<hr id="hr-toc"> 
<h2 id="%E4%B8%80%E3%80%81HashMap%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span style="color:#3399ea;">一、HashMap的数据结构</span></h2> 
<p><br> 数据结构中有 数组 和 链表 来实现对数据的存储，但这两者基本上是两个极端。  （堆砌了别人的文章！呵呵呵）</p> 
<blockquote> 
 <p><strong>  数组</strong><br> 数组存储区间是连续的，占用内存严重，故空间复杂的很大。但数组的二分查找时间复杂度小，为O(1)；数组的特点是：寻址容易，插入和删除困难；</p> 
</blockquote> 
<blockquote> 
 <p><strong>链表</strong><br> 链表存储区间离散(不连续)，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，O（N）。链表的特点是：寻址困难，插入和删除容易。</p> 
</blockquote> 
<blockquote> 
 <p><strong>哈希表</strong><br> 那么我们能不能综合两者的特性，做出一种寻址容易，插入删除也容易的数据结构？答案是肯定的，这就是我们要提起的哈希表。哈希表（(Hash table）既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。</p> 
</blockquote> 
<p>     当链表数组的容量超过初始容量的0.75时，再散列将链表数组扩大2倍，把原链表数组的搬移到新的数组中</p> 
<p><span style="color:#86ca5e;"><strong>加载因子（默认0.75）：为什么需要使用加载因子，为什么需要扩容呢</strong>？<strong>因为如果填充比很大，说明利用的空间很多，如果一直不进行扩容的话，链表就会越来越长，这样查找的效率很低，因为链表的长度很大（当然最新版本使用了红黑树后会改进很多），扩容之后，将原来链表数组的每一个链表分成奇偶两个子链表分别挂在新链表数组的散列位置，这样就减少了每个链表的长度，增加查找效率</strong></span></p> 
<p>HashMap本来是以空间换时间，所以填充比没必要太大。但是填充比太小又会导致空间浪费。如果关注内存，填充比可以稍大，如果主要关注查找性能，填充比可以稍小。</p> 
<p>即HashMap的原理图是：</p> 
<p>　　<img alt="" class="has" src="https://images2.imgbox.com/0a/8b/N7RP5jAL_o.png"></p> 
<h4 id="WizKMOutline_1383296103994211"><strong>解决hash冲突的办法</strong></h4> 
<ol><li>开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列）</li><li>再哈希法</li><li><strong>链地址法</strong></li><li>建立一个公共溢出区</li></ol> 
<p><strong><span style="color:#3399ea;">  </span><span style="color:#f33b45;">   Java中hashmap的解决办法就是采用的链地址法（也称为拉链法）。</span></strong></p> 
<h2 id="%E4%BA%8C%E3%80%81%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span style="color:#3399ea;">二、源码分析</span></h2> 
<h4 id="1.%C2%A0%C2%A0%E4%BD%8D%E6%A1%B6%E6%95%B0%E7%BB%84">1.  位桶数组</h4> 
<pre class="has"><code class="language-java">  transient Node&lt;K,V&gt;[] table;</code></pre> 
<h4 id="2.%C2%A0%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0Node%3CK%2CV%3E%E5%AE%9E%E7%8E%B0%E4%BA%86Entry%E6%8E%A5%E5%8F%A3"><strong>2. 数组元素Node&lt;K,V&gt;实现了Entry接口</strong></h4> 
<pre class="has"><code class="language-java">public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Cloneable, Serializable {

    private static final long serialVersionUID = 362498820763181265L;

    

    /**
     * 初始大小 - MUST be a power of two.
     */
    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16

    /**
     * The maximum capacity
     */
    static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;

    /**
     * 装载因子
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;


    /**
	 * Node 是单向链表， 实现了 Map.Entry 接口
     */
    static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
        final int hash;
        final K key;
        V value;
        Node&lt;K,V&gt; next;
        /**
	     * 构造函数 Hash值、键、值、下一个节点
         */
        Node(int hash, K key, V value, Node&lt;K,V&gt; next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        public final K getKey()        { return key; }
        public final V getValue()      { return value; }
        public final String toString() { return key + "=" + value; }

        public final int hashCode() {
            return Objects.hashCode(key) ^ Objects.hashCode(value);
        }

        public final V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }
        /**
		 * 判断两个node是否相等,若key和value都相等，返回true。可以与自身比较为true  
		 */
        public final boolean equals(Object o) {
            if (o == this)
                return true;
            if (o instanceof Map.Entry) {
                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
                if (Objects.equals(key, e.getKey()) &amp;&amp;
                    Objects.equals(value, e.getValue()))
                    return true;
            }
            return false;
        }
    }
}</code></pre> 
<h4 id="%C2%A03.%C2%A0HashMap%E5%A6%82%E4%BD%95put(key%EF%BC%8Cvalue%EF%BC%89"> 3. <strong>HashMap如何put(key，value）</strong></h4> 
<blockquote> 
 <p><strong>链地址法解决hash 冲突</strong></p> 
</blockquote> 
<p><img alt="" class="has" height="512" src="https://images2.imgbox.com/0b/f0/h1ZGw4lA_o.png" width="672">  </p> 
<pre class="has"><code class="language-java">public V put(K key, V value) {  
        return putVal(hash(key), key, value, false, true);  
    }  
     /** 
	 *
     */  
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,  
                   boolean evict) {  
        Node&lt;K,V&gt;[] tab;   
		Node&lt;K,V&gt; p;   
		int n, i;  
        if ((tab = table) == null || (n = tab.length) == 0)  
            n = (tab = resize()).length;  
        /*如果table的在（n-1）&amp;hash的值是空，就新建一个节点插入在该位置*/  
        if ((p = tab[i = (n - 1) &amp; hash]) == null)  
            tab[i] = newNode(hash, key, value, null); 
			
        /*表示有冲突,开始处理冲突*/  
        else {  
            Node&lt;K,V&gt; e;   
            K k;  
             /*检查第一个Node，p是不是要找的值*/  
            if (p.hash == hash &amp;&amp;((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))  
                e = p;  
            else if (p instanceof TreeNode)  
                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);  
            else {  
                for (int binCount = 0; ; ++binCount) {  
           /*指针为空就挂在后面*/  
                    if ((e = p.next) == null) {  
                        p.next = newNode(hash, key, value, null);  
                        //如果冲突的节点数已经达到8个，看是否需要改变冲突节点的存储结构，　　　　　　　　　　　　　  
　　　　　　　　　　　　//treeifyBin首先判断当前hashMap的长度，如果不足64，只进行  
                        //resize，扩容table，如果达到64，那么将冲突的存储结构为红黑树  
                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st  
                            treeifyBin(tab, hash);  
                        break;  
                    }  
                    /*如果有相同的key值就结束遍历*/  
                    if (e.hash == hash &amp;&amp;((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))  
                        break;  
                    p = e;  
                }  
            }  
            /*就是链表上有相同的key值*/  
             if (e != null) { // existing mapping for key，就是key的Value存在  
                V oldValue = e.value;  
                if (!onlyIfAbsent || oldValue == null)  
                    e.value = value;  
                afterNodeAccess(e);  
                return oldValue;//返回存在的Value值  
            }  
        }  
        ++modCount;  
     /*如果当前大小大于门限，门限原本是初始容量*0.75*/  
        if (++size &gt; threshold)  
            resize();//扩容两倍  
        afterNodeInsertion(evict);  
        return null;  
    }
}</code></pre> 
<p><strong>简单说下添加键值对put(key,value)的过程：</strong><br> 1，判断键值对数组tab[]是否为空或为null，否则以默认大小resize()；<br> 2，根据键值key计算hash值得到插入的数组索引i，如果tab[i]==null，直接新建节点添加，否则转入3<br> 3，判断当前数组中处理hash冲突的方式为链表还是红黑树(check第一个节点类型即可),分别处理</p> 
<p> </p> 
<h4 id="4.%C2%A0HashMap%E5%A6%82%E4%BD%95getValue%E5%80%BC">4. HashMap如何getValue值</h4> 
<pre class="has"><code class="language-java">public V get(Object key) {  
        Node&lt;K,V&gt; e;  
        return (e = getNode(hash(key), key)) == null ? null : e.value;  
    }  
      /** 
     * Implements Map.get and related methods 
     * 
     * @param hash hash for key 
     * @param key the key 
     * @return the node, or null if none 
     */  
    final Node&lt;K,V&gt; getNode(int hash, Object key) {  
    Node&lt;K,V&gt;[] tab;//Entry对象数组  
    Node&lt;K,V&gt; first,e; //在tab数组中经过散列的第一个位置  
    int n;  
    K k;  
    /*找到插入的第一个Node，方法是hash值和n-1相与，tab[(n - 1) &amp; hash]*/  
    //也就是说在一条链上的hash值相同的  
        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;(first = tab[(n - 1) &amp; hash]) != null) {  
            /*检查第一个Node是不是要找的Node*/  
            if (first.hash == hash &amp;&amp; // always check first node  
			    //判断条件是hash值要相同，key值要相同  
                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
                return first;  
            /*检查first后面的node*/  
            if ((e = first.next) != null) {  
                if (first instanceof TreeNode)  
                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);  
                /*遍历后面的链表，找到key值和hash值都相同的Node*/  
                do {  
                    if (e.hash == hash &amp;&amp;  
                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))  
                        return e;  
                } while ((e = e.next) != null);  
            }  
        }  
        return null;  
    }</code></pre> 
<p>get(key)方法时获取key的hash值，计算hash&amp;(n-1)得到在链表数组中的位置first=tab[hash&amp;(n-1)],先判断first的key是否与参数key相等，不等就遍历后面的链表找到相同的key值返回对应的Value值即可</p> 
<h4 id="5.%C2%A0HasMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6resize()%3B">5. <strong>HasMap的扩容机制resize();</strong></h4> 
<blockquote> 
 <p><strong>构造hash表时，如果不指明初始大小，默认大小为16（即Node数组大小16），如果Node[]数组中的元素达到（填充比*Node.length）重新调整HashMap大小 变为原来2倍大小,</strong>扩容很耗时</p> 
</blockquote> 
<p> </p> 
<pre class="has"><code class="language-java">/** 
    * Initializes or doubles table size.
    */  
   final Node&lt;K,V&gt;[] resize() {  
       Node&lt;K,V&gt;[] oldTab = table;  
       int oldCap = (oldTab == null) ? 0 : oldTab.length;  
       int oldThr = threshold;  
       int newCap, newThr = 0;  
      
/* 如果旧表的长度不是空 */  
       if (oldCap &gt; 0) {  
           if (oldCap &gt;= MAXIMUM_CAPACITY) {  
               threshold = Integer.MAX_VALUE;  
               return oldTab;  
           }  
/* 把新表的长度设置为旧表长度的两倍，newCap=2*oldCap */  
           else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;  
                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)  
    /* 把新表的阈值设置为旧表阈值的两倍，newThr=oldThr*2 */  
               newThr = oldThr &lt;&lt; 1; // double threshold  
       }  
    /* 如果旧表的长度的是0，也就是说第一次初始化表 */  
       else if (oldThr &gt; 0) // initial capacity was placed in threshold  
           newCap = oldThr;  
       else {               // zero initial threshold signifies using defaults  
           newCap = DEFAULT_INITIAL_CAPACITY;  
           newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);  
       }  
      
      
      
       if (newThr == 0) {  
           float ft = (float)newCap * loadFactor;//新表长度乘以加载因子  
           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?  
                     (int)ft : Integer.MAX_VALUE);  
       }  
       threshold = newThr;  
       @SuppressWarnings({"rawtypes","unchecked"})  
    /*下面开始构造新表，初始化表中的数据*/  
       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];  
       table = newTab;//把新表赋值给table  
       if (oldTab != null) {//原表不是空要把原表中数据移动到新表中      
           /*遍历原来的旧表*/        
           for (int j = 0; j &lt; oldCap; ++j) {  
               Node&lt;K,V&gt; e;  
               if ((e = oldTab[j]) != null) {  
                   oldTab[j] = null;  
                   if (e.next == null)//说明这个node没有链表直接放在新表的e.hash &amp; (newCap - 1)位置  
                       newTab[e.hash &amp; (newCap - 1)] = e;  
                   else if (e instanceof TreeNode)  
                       ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);  
            /*如果e后边有链表,到这里表示e后面带着个单链表，需要遍历单链表，将每个结点重*/  
                   else { // preserve order保证顺序  
                新计算在新表的位置，并进行搬运  
                       Node&lt;K,V&gt; loHead = null, loTail = null;  
                       Node&lt;K,V&gt; hiHead = null, hiTail = null;  
                       Node&lt;K,V&gt; next;  
                      
                       do {  
                           next = e.next;//记录下一个结点  
             //新表是旧表的两倍容量，实例上就把单链表拆分为两队，  
　　　　　　　　　　　　　//e.hash&amp;oldCap为偶数一队，e.hash&amp;oldCap为奇数一对  
                           if ((e.hash &amp; oldCap) == 0) {  
                               if (loTail == null)  
                                   loHead = e;  
                               else  
                                   loTail.next = e;  
                               loTail = e;  
                           }  
                           else {  
                               if (hiTail == null)  
                                   hiHead = e;  
                               else  
                                   hiTail.next = e;  
                               hiTail = e;  
                           }  
                       } while ((e = next) != null);  
                      
                       if (loTail != null) {//lo队不为null，放在新表原位置  
                           loTail.next = null;  
                           newTab[j] = loHead;  
                       }  
                       if (hiTail != null) {//hi队不为null，放在新表j+oldCap位置  
                           hiTail.next = null;  
                           newTab[j + oldCap] = hiHead;  
                       }  
                   }  
               }  
           }  
       }  
       return newTab;  
   }</code></pre> 
<h4 id="6.%20JDK1.8%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%94%B9%E8%BF%9B"><strong>6. JDK1.8使用红黑树的改进</strong></h4> 
<p>在<a href="http://lib.csdn.net/base/java" rel="nofollow">Java </a>jdk8中对HashMap的源码进行了优化，在jdk7中，HashMap处理“碰撞”的时候，都是采用链表来存储，当碰撞的结点很多时，查询时间是O（n）。<br> 在jdk8中，<strong>HashMap处理“碰撞”增加了红黑树这种数据结构，当碰撞结点较少时，采用链表存储，当较大时（&gt;8个），采用红黑树（特点是查询时间是O（logn））存储（有一个阀值控制，大于阀值(8个)，将链表存储转换成红黑树存储）</strong></p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/86/f7/8Y7bY7NV_o.png"></p> 
<p><strong>问题分析：</strong></p> 
<p>你可能还知道哈希碰撞会对hashMap的性能带来灾难性的影响。如果多个hashCode()的值落到同一个桶内的时候，这些值是存储到一个链表中的。最坏的情况下，所有的key都映射到同一个桶中，这样hashmap就退化成了一个链表——查找时间从O(1)到O(n)。</p> 
<p> </p> 
<p>随着HashMap的大小的增长，get()方法的开销也越来越大。由于所有的记录都在同一个桶里的超长链表内，平均查询一条记录就需要遍历一半的列表。</p> 
<p><strong> JDK1.8HashMap的红黑树是这样解决的</strong>：</p> 
<p>         <strong>如果某个桶中的记录过大的话（当前是TREEIFY_THRESHOLD = 8），HashMap会动态的使用一个专门的treemap实现来替换掉它。这样做的结果会更好，是O(logn)，而不是糟糕的O(n)。</strong></p> 
<p>        它是如何工作的？前面产生冲突的那些KEY对应的记录只是简单的追加到一个链表后面，这些记录只能通过遍历来进行查找。但是超过这个阈值后HashMap开始将列表升级成一个二叉树，<strong>使用哈希值作为树的分支变量，如果两个哈希值不等，但指向同一个桶的话，较大的那个会插入到右子树里。如果哈希值相等，HashMap希望key值最好是实现了Comparable接口的，这样它可以按照顺序来进行插入</strong>。这对HashMap的key来说并不是必须的，不过如果实现了当然最好。如果没有实现这个接口，在出现严重的哈希碰撞的时候，你就并别指望能获得性能提升了。</p> 
<h2> </h2> 
<h2 id="%E4%B8%89%E3%80%81%E5%86%8D%E8%B0%88ReHash"><span style="color:#3399ea;">三、再谈ReHash</span></h2> 
<h3 id="%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8B%E7%9A%84ReHash"><strong>单线程下的ReHash</strong></h3> 
<ul><li>用key mod 一下表的大小（也就是数组的长度）。</li><li>最上面的是old hash 表，其中的Hash表的size=2, 所以key = 3, 7, 5，在mod 2以后都冲突在table[1]这里了。</li><li>接下来的三个步骤是Hash表 resize成4，然后所有的&lt;key,value&gt; 重新rehash的过程</li></ul> 
<p><img alt="" class="has" src="https://images2.imgbox.com/a0/7e/Day8e0Vf_o.png"></p> 
<p>image</p> 
<p>详细描述可以看下面这张图：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/74/ea/VKNqucES_o.png"></p> 
<p> </p> 
<h3 id="%E5%B9%B6%E5%8F%91%E4%B8%8B%E7%9A%84Rehash">并发下的Rehash</h3> 
<ol><li>假设我们有两个线程。我用红色和浅蓝色标注了一下。</li></ol> 
<pre class="has"><code>do{
    Entry&lt;K,V&gt; next = e.next;// &lt;--假设线程一执行到这里就被调度挂起了
    inti = indexFor(e.hash, newCapacity);
    e.next = newTable[i];
    newTable[i] = e;
    e = next;
}while (e != null);
</code></pre> 
<p>而我们的线程二执行完成了。于是我们有下面的这个样子。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/fe/03/4odL9Ky2_o.png"></p> 
<p> </p> 
<p>注意，因为Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。我们可以看到链表的顺序被反转后。</p> 
<ol><li>线程一被调度回来执行。</li></ol> 
<ul><li>先是执行 newTalbe[i] = e;</li><li>然后是e = next，导致了e指向了key(7)，</li><li>而下一次循环的next = e.next导致了next指向了key(3)</li></ul> 
<p><img alt="" class="has" src="https://images2.imgbox.com/29/7e/zJPVQgvW_o.png"></p> 
<p> </p> 
<ol><li>线程一继续执行</li></ol> 
<p>把key(7)摘下来，放到newTable[i]的第一个，然后把e和next往下移</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/0d/f0/RfFGKrlE_o.png"></p> 
<p> </p> 
<ol><li>环形链接出现</li></ol> 
<p>e.next = newTable[i] 导致 key(3).next 指向了 key(7)<br> 注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/66/1d/7D7JKC8t_o.png"></p> 
<p><br><br> 参考：<br> https://www.jianshu.com/p/13c650a25ed3<br><a href="https://www.cnblogs.com/little-fly/p/7344285.html" rel="nofollow">https://www.cnblogs.com/little-fly/p/7344285.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/69068f953e86b13f75fec63c4f8cb665/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JAVA程序设计：连续数组（LeetCode：525）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/175896c4e8573aa6797de69f4e445097/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">自己公司项目中引用jacoco，及多报告合并</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>