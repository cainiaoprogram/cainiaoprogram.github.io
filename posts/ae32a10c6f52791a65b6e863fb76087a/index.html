<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java中接口是否可以继承多个接口？ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java中接口是否可以继承多个接口？" />
<meta property="og:description" content="接口是常量值和方法定义的集合。接口是一种特殊的抽象类。
java类是单继承的。classB Extends classA
java接口可以多继承。Interface3 Extends Interface0, Interface1, interface……
不允许类多重继承的主要原因是，如果A同时继承B和C，而B和C同时有一个D方法，A如何决定该继承那一个呢？
但接口不存在这样的问题，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。
注意：
1）一个类如果实现了一个接口，则要实现该接口的所有方法。
2）方法的名字、返回类型、参数必须与接口中完全一致。如果方法的返回类型不是void，则方法体必须至少有一条return语句。
3）因为接口的方法默认是public类型的，所以在实现的时候一定要用public来修饰（否则默认为protected类型，缩小了方法的使用范围）。
以下内容转自：http://www.cnblogs.com/littlepanpc/p/3616300.html
java中接口之间的继承 最近在读一些源码的时候突然发现了一个很神奇的东西，它的原始形态是这样的：
在这行代码中，BlockingDeque、BlockingQueue和Deque是三个接口。刚发现这个问题时，我是十分吃惊的，因为即使在《Thinking in Java》中也没有提到接口之间的继承。所以我立即把这个疑问提交到了stackoverflow上面。
这个问答的过程十分简单，在这个链接上面的：http://stackoverflow.com/questions/22498245/one-uncertainty-on-multiple-inheritance-in-universal-image-loader
# 正如在stackoverflow上面所讨论的一样，一个类只能extends一个父类，但可以implements多个接口。java通过使用接口的概念来取代C&#43;&#43;中多继承。与此同时，一个接口则可以同时extends多个接口，却不能implements任何接口。因而，Java中的接口是支持多继承的。
然后我又做了个实验，来验证如果多个父子接口中有多个相同的方法声明，然后在实现这个最终的接口的时候，相同的方法声明在实现的时候会不会有冲突呢？
首先写了个接口：TestInterfaceA.java：
复制代码
复制代码 1 package com.peter.java.dsa.interfaces; 2 3 public interface TestInterfaceA { 4 String pri_key = “guess what the private key is”; 5 6 int add(int x, int y); 7 8 String encryt(byte[] result); 9 10 int get(); 11 } 复制代码 复制代码 注意，里面声明了三个方法和一个变量；
然后再与了一个接口：TestInterfaceB.java：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ae32a10c6f52791a65b6e863fb76087a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-09-16T12:14:41+08:00" />
<meta property="article:modified_time" content="2018-09-16T12:14:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java中接口是否可以继承多个接口？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>接口是常量值和方法定义的集合。接口是一种特殊的抽象类。</p> 
<p>java类是单继承的。classB Extends classA</p> 
<p>java接口可以多继承。Interface3 Extends Interface0, Interface1, interface……</p> 
<p>不允许类多重继承的主要原因是，如果A同时继承B和C，而B和C同时有一个D方法，A如何决定该继承那一个呢？</p> 
<p>但接口不存在这样的问题，接口全都是抽象方法继承谁都无所谓，所以接口可以继承多个接口。</p> 
<p>注意：</p> 
<p>1）一个类如果实现了一个接口，则要实现该接口的所有方法。</p> 
<p>2）方法的名字、返回类型、参数必须与接口中完全一致。如果方法的返回类型不是void，则方法体必须至少有一条return语句。</p> 
<p>3）因为接口的方法默认是public类型的，所以在实现的时候一定要用public来修饰（否则默认为protected类型，缩小了方法的使用范围）。</p> 
<p>以下内容转自：<a href="http://www.cnblogs.com/littlepanpc/p/3616300.html" rel="nofollow">http://www.cnblogs.com/littlepanpc/p/3616300.html</a></p> 
<p>java中接口之间的继承 <br> 最近在读一些源码的时候突然发现了一个很神奇的东西，它的原始形态是这样的：</p> 
<p>在这行代码中，BlockingDeque、BlockingQueue和Deque是三个接口。刚发现这个问题时，我是十分吃惊的，因为即使在《Thinking in Java》中也没有提到接口之间的继承。所以我立即把这个疑问提交到了stackoverflow上面。</p> 
<p>这个问答的过程十分简单，在这个链接上面的：<a href="http://stackoverflow.com/questions/22498245/one-uncertainty-on-multiple-inheritance-in-universal-image-loader" rel="nofollow">http://stackoverflow.com/questions/22498245/one-uncertainty-on-multiple-inheritance-in-universal-image-loader</a></p> 
<h6 id="title">#</h6> 
<p>正如在stackoverflow上面所讨论的一样，一个类只能extends一个父类，但可以implements多个接口。java通过使用接口的概念来取代C++中多继承。与此同时，一个接口则可以同时extends多个接口，却不能implements任何接口。因而，Java中的接口是支持多继承的。</p> 
<p>然后我又做了个实验，来验证如果多个父子接口中有多个相同的方法声明，然后在实现这个最终的接口的时候，相同的方法声明在实现的时候会不会有冲突呢？</p> 
<p>首先写了个接口：TestInterfaceA.java：</p> 
<p>复制代码</p> 
<p>复制代码 <br> 1 package com.peter.java.dsa.interfaces; <br> 2 <br> 3 public interface TestInterfaceA { <br> 4 String pri_key = “guess what the private key is”; <br> 5 <br> 6 int add(int x, int y); <br> 7 <br> 8 String encryt(byte[] result); <br> 9 <br> 10 int get(); <br> 11 } <br> 复制代码 <br> 复制代码 <br> 注意，里面声明了三个方法和一个变量；</p> 
<p>然后再与了一个接口：TestInterfaceB.java：</p> 
<p>复制代码</p> 
<p>复制代码 <br> 1 package com.peter.java.dsa.interfaces; <br> 2 <br> 3 public interface TestInterfaceB { <br> 4 String pub_key = “guess what the public key is”; <br> 5 <br> 6 int minus(int x, int y); <br> 7 <br> 8 byte[] decryt(String src); <br> 9 <br> 10 int get(); <br> 11 } <br> 复制代码 <br> 复制代码 <br> 里面也声明了三个方法和一个变量；</p> 
<p>然后再定义了一个接口InterfaceMultiInheritance.java同时继承了接口TestInterfaceA.java和接口TestInterfaceB.java：</p> 
<p>复制代码</p> 
<p>复制代码 <br> 1 package com.peter.java.dsa.interfaces; <br> 2 <br> 3 public interface InterfaceMultiInheritance extends TestInterfaceA, <br> 4 TestInterfaceB { <br> 5 int num = 1024; <br> 6 <br> 7 double divide(int x, int y); <br> 8 <br> 9 int get(); <br> 10 } <br> 复制代码 <br> 复制代码 <br> 里面声明了两个方法和一个变量；</p> 
<p>注意，在这三个接口中，有一个共同的方法声明：get()。这个都是要讨论的主题。</p> 
<p>最后在一个类InterfaceImplementTest.java中实现了接口InterfaceMultiInheritance.java，源码如下：</p> 
<p>复制代码</p> 
<p>复制代码 <br> 1 package com.peter.java.dsa.common; <br> 2 <br> 3 import com.peter.java.dsa.interfaces.InterfaceMultiInheritance; <br> 4 import com.sun.org.apache.xml.internal.security.exceptions.Base64DecodingException; <br> 5 import com.sun.org.apache.xml.internal.security.utils.Base64; <br> 6 <br> 7 public class InterfaceImplementTest implements InterfaceMultiInheritance { <br> 8 <br> 9 @Override <br> 10 public int add(int x, int y) { <br> 11 // TODO Auto-generated method stub <br> 12 return x + y; <br> 13 } <br> 14 <br> 15 @Override <br> 16 public String encryt(byte[] result) { <br> 17 // TODO Auto-generated method stub <br> 18 return Base64.encode(result); <br> 19 } <br> 20 <br> 21 @Override <br> 22 public int minus(int x, int y) { <br> 23 // TODO Auto-generated method stub <br> 24 return x - y; <br> 25 } <br> 26 <br> 27 @Override <br> 28 public byte[] decryt(String src) { <br> 29 // TODO Auto-generated method stub <br> 30 try { <br> 31 return Base64.decode(src); <br> 32 } catch (Base64DecodingException e) { <br> 33 // TODO Auto-generated catch block <br> 34 e.printStackTrace(); <br> 35 } <br> 36 return null; <br> 37 } <br> 38 <br> 39 @Override <br> 40 public double divide(int x, int y) { <br> 41 // TODO Auto-generated method stub <br> 42 return x/y; <br> 43 } <br> 44 <br> 45 @Override <br> 46 public int get() { <br> 47 // TODO Auto-generated method stub <br> 48 return num; <br> 49 } <br> 50 <br> 51 public void print() { <br> 52 System.out.println(“The public key is: “+pub_key+”\nThe private key is: “+pri_key); <br> 53 } <br> 54 <br> 55 } <br> 复制代码 <br> 复制代码 <br> 在这个类中，只有一个get方法实现了，同时也没有为有多个get要实现而冲突。同时，如果删除了接口InterfaceMultiInheritance.java中的get方法，也只有一个get方法得到了实现并且没有为多个get要实现而出现什么冲突。</p> 
<p>所以，我们可以得到一个结论，当编译器在实现接口的时候会依然检查接口InterfaceMultiInheritance.java、TestInterfaceA.java和TestInterfaceB.java中的方法声明，如果后两者有与前者相冲突的方法声明，编译器将只要求类实现前者的声明，而后两者中相同的方法声明将自动被忽略。而当只有后两者中有相同的方法声明时，编译器将实现其中的一个即可。就好像是编译器中有一个专门存储方法声明的Set一样，在有继承关系的接口中，只保存一次相同的方法声明。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7da9ef9efa2bf02e9c9521178d634514/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机网络基础知识</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0a19c5c6bad53a7c2623bf0fc52fa440/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java语言程序设计（基础篇）第十版 编程练习题**3.15（游戏：彩票）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>