<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java解析XML报文内容及标签属性 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java解析XML报文内容及标签属性" />
<meta property="og:description" content="前言 JSON格式的报文解析，虽然json串短小精悍，也能有效表达层次结构，但是每个元素只能找到对应的元素值，不能体现更丰富的样式特征。比如某个元素除了要传输它的字符串文本，还想传输该文本的类型、字体大小、字体颜色等特征，且这些额外的风格样式与业务逻辑无关，自然不适合为它们单独设立参数字段。倘若采用JSON格式定义包括样式特征在内的文本元素，要么摒弃风格样式这种附加属性，要么将风格样式单列为专门的字段参数，然而不管哪种做法，都未能妥善解决附加属性的表达问题。可见轻量级的JSON格式依然存在力不从心的情况，为此人们早早发明了拥有强大表示能力的XML格式，XML的全称是“Extensible Markup Language”（可扩展标记语言），它不但支持结构化数据的描述，还支持各类附加属性的定义，非常适合在网络中传输信息。
下面先看一个XML报文格式的购物订单样例：
&lt;?xml version=&#34;1.0&#34; encoding=&#34;gbk&#34;?&gt; &lt;order&gt; &lt;user_info&gt; &lt;name type=&#34;string&#34;&gt;思无邪&lt;/name&gt; &lt;address type=&#34;string&#34;&gt;桃花岛水帘洞123号&lt;/address&gt; &lt;phone type=&#34;string&#34;&gt;15960238696&lt;/phone&gt; &lt;/user_info&gt; &lt;goods_list&gt; &lt;goods_item&gt; &lt;goods_name type=&#34;string&#34;&gt;Mate30&lt;/goods_name&gt; &lt;goods_number type=&#34;int&#34;&gt;1&lt;/goods_number&gt; &lt;goods_price type=&#34;double&#34;&gt;8888&lt;/goods_price&gt; &lt;/goods_item&gt; &lt;goods_item&gt; &lt;goods_name type=&#34;string&#34;&gt;格力中央空调&lt;/goods_name&gt; &lt;goods_number type=&#34;int&#34;&gt;1&lt;/goods_number&gt; &lt;goods_price type=&#34;double&#34;&gt;58000&lt;/goods_price&gt; &lt;/goods_item&gt; &lt;goods_item&gt; &lt;goods_name type=&#34;string&#34;&gt;红蜻蜓皮鞋&lt;/goods_name&gt; &lt;goods_number type=&#34;int&#34;&gt;3&lt;/goods_number&gt; &lt;goods_price type=&#34;double&#34;&gt;999&lt;/goods_price&gt; &lt;/goods_item&gt; &lt;/goods_list&gt; &lt;/order&gt; 接着对上面的XML样例庖丁解牛，分析一下XML格式都有哪些特点，分析结果罗列如下：
1、每个元素依然由参数名称和参数值组成，参数名称为尖括号所包裹，且分为标记头与标记尾两部分，标记尾在尖括号内部多了个斜杆。如此一来，一个字段的完整形式为“&lt;参数名称&gt;参数值&lt;/参数名称&gt;”。
2、因为每个元素都自带标记头与标记尾，很容易区分在哪开始在哪结束，所以元素之间无需额外的分隔符，只要有标记头与标记尾就足够辨别了。
3、每个结构也需要专门的标记头与标记尾，中间再填入若干元素或者其它结构。
4、对于数组形式的数据，XML报文采用多个同名的结构标记并排列举，表示这里存在同名结构的数组信息，也可看作是清单信息。
5、XML格式允许在报文开头的encoding属性处指定当前报文的字符编码类型，常见的有汉字内码规范GBK，以及世界通用编码规范UTF-8。
6、每个结构或者元素节点，也支持在标记头部分填充附加属性，用于指定参数值以外的特定信息。
大致了解了XML报文的格式规范，还得在程序中加以解析才行。传统的XML解析方式有DOM和SAX两种，DOM方式会把整个XML报文读进来，并且所有节点全被自动加载到一个树状结构，以后每个节点值都到该树状结构中读取。SAX方式不会事先读入整个XML报文，而是根据节点名称从报文起点开始扫描，一旦找到该节点的标记头位置，即刻往后寻找该节点的标记尾，那么节点标记头尾之间的数据便是节点值了。单就某个节点值的解析过程而言，加载所有节点的DOM方式显然较费功夫，从头顺序查找的SAX方式执行效率更高。但若要求同时获取多个节点的数值，则采取树状结构遍历的DOM方式总体性能更加，而每次都从头找起的SAX方式无疑做了重复劳动。总之两种方式的解析效果各有优劣，需要按照实际场景决定取舍。
尽管JDK集成了DOM与SAX的解析工具，其中DOM解析工具封装在包org.w3c.dom中，SAX解析工具封装在包javax.xml.parsers中，可是它俩用起来着实费劲，解析过程艰深晦涩，实际开发当中基本不予采用。应用比较多的XML解析工具反而是第三方的Dom4j，Dom4j的解析方式遵循DOM规则，但比起Java自带的DOM工具要易用得多，其性能也很优异，几乎成为Java开发必备的XML解析神器了。通过Dom4j解析XML报文的步骤主要有下列五步：
1、创建SAXReader阅读器对象；
2、把字符串形式的XML报文转换为输入流对象；
3、命令阅读器对象从输入流中读取Document文档对象；
4、获得文档对象的根节点Element；
5、从根节点往下依次解析每个层级的节点值；
在具体的节点解析过程之中，会频繁调用Element的相关方法，它的常用方法说明如下：
getText：获得当前节点的字符串值。
element：获得当前节点下面指定名称的子节点对象。
elementText：获得当前节点下面指定名称的子节点值。
elements：获得当前节点下面指定名称的子节点清单。
attribute：获得当前节点自身指定名称的属性对象。
attributeValue：获得当前节点自身指定名称的属性值。
attributes：获得当前节点拥有的全部属性清单。
仍以前述的XML报文为例，下面是采用Dom4j解析该XML串的代码例子：
// 通过dom4j解析xml串 private static GoodsOrder testParserByDom4j(String xml) { GoodsOrder order = new GoodsOrder(); // 创建一个购物订单对象 // 创建SAXReader阅读器对象 SAXReader reader = new SAXReader(); // 根据字符串构建字节数组输入流 try (InputStream is = new ByteArrayInputStream(xml." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d05777c6ee7a75f4de4005fd228da1b5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-14T10:27:59+08:00" />
<meta property="article:modified_time" content="2023-03-14T10:27:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java解析XML报文内容及标签属性</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>前言</h3> 
<p>JSON格式的报文解析，虽然json串短小精悍，也能有效表达层次结构，但是每个元素只能找到对应的元素值，不能体现更丰富的样式特征。比如某个元素除了要传输它的字符串文本，还想传输该文本的类型、字体大小、字体颜色等特征，且这些额外的风格样式与业务逻辑无关，自然不适合为它们单独设立参数字段。倘若采用JSON格式定义包括样式特征在内的文本元素，要么摒弃风格样式这种附加属性，要么将风格样式单列为专门的字段参数，然而不管哪种做法，都未能妥善解决附加属性的表达问题。可见轻量级的JSON格式依然存在力不从心的情况，为此人们早早发明了拥有强大表示能力的XML格式，XML的全称是“Extensible Markup Language”（可扩展标记语言），它不但支持结构化数据的描述，还支持各类附加属性的定义，非常适合在网络中传输信息。<br> 下面先看一个XML报文格式的购物订单样例：</p> 
<pre><code>&lt;?xml version="1.0" encoding="gbk"?&gt;
&lt;order&gt;
    &lt;user_info&gt;
    &lt;name type="string"&gt;思无邪&lt;/name&gt;
    &lt;address type="string"&gt;桃花岛水帘洞123号&lt;/address&gt;
    &lt;phone type="string"&gt;15960238696&lt;/phone&gt;
    &lt;/user_info&gt;
    &lt;goods_list&gt;
        &lt;goods_item&gt;
            &lt;goods_name type="string"&gt;Mate30&lt;/goods_name&gt;
            &lt;goods_number type="int"&gt;1&lt;/goods_number&gt;
            &lt;goods_price type="double"&gt;8888&lt;/goods_price&gt;
        &lt;/goods_item&gt;
        &lt;goods_item&gt;
            &lt;goods_name type="string"&gt;格力中央空调&lt;/goods_name&gt;
            &lt;goods_number type="int"&gt;1&lt;/goods_number&gt;
            &lt;goods_price type="double"&gt;58000&lt;/goods_price&gt;
        &lt;/goods_item&gt;
        &lt;goods_item&gt;
            &lt;goods_name type="string"&gt;红蜻蜓皮鞋&lt;/goods_name&gt;
            &lt;goods_number type="int"&gt;3&lt;/goods_number&gt;
            &lt;goods_price type="double"&gt;999&lt;/goods_price&gt;
        &lt;/goods_item&gt;
    &lt;/goods_list&gt;
&lt;/order&gt;
</code></pre> 
<p>接着对上面的XML样例庖丁解牛，分析一下XML格式都有哪些特点，分析结果罗列如下：<br> 1、每个元素依然由参数名称和参数值组成，参数名称为尖括号所包裹，且分为标记头与标记尾两部分，标记尾在尖括号内部多了个斜杆。如此一来，一个字段的完整形式为“&lt;参数名称&gt;参数值&lt;/参数名称&gt;”。<br> 2、因为每个元素都自带标记头与标记尾，很容易区分在哪开始在哪结束，所以元素之间无需额外的分隔符，只要有标记头与标记尾就足够辨别了。<br> 3、每个结构也需要专门的标记头与标记尾，中间再填入若干元素或者其它结构。<br> 4、对于数组形式的数据，XML报文采用多个同名的结构标记并排列举，表示这里存在同名结构的数组信息，也可看作是清单信息。<br> 5、XML格式允许在报文开头的encoding属性处指定当前报文的字符编码类型，常见的有汉字内码规范GBK，以及世界通用编码规范UTF-8。<br> 6、每个结构或者元素节点，也支持在标记头部分填充附加属性，用于指定参数值以外的特定信息。<br> 大致了解了XML报文的格式规范，还得在程序中加以解析才行。传统的XML解析方式有DOM和SAX两种，DOM方式会把整个XML报文读进来，并且所有节点全被自动加载到一个树状结构，以后每个节点值都到该树状结构中读取。SAX方式不会事先读入整个XML报文，而是根据节点名称从报文起点开始扫描，一旦找到该节点的标记头位置，即刻往后寻找该节点的标记尾，那么节点标记头尾之间的数据便是节点值了。单就某个节点值的解析过程而言，加载所有节点的DOM方式显然较费功夫，从头顺序查找的SAX方式执行效率更高。但若要求同时获取多个节点的数值，则采取树状结构遍历的DOM方式总体性能更加，而每次都从头找起的SAX方式无疑做了重复劳动。总之两种方式的解析效果各有优劣，需要按照实际场景决定取舍。<br> 尽管JDK集成了DOM与SAX的解析工具，其中DOM解析工具封装在包org.w3c.dom中，SAX解析工具封装在包javax.xml.parsers中，可是它俩用起来着实费劲，解析过程艰深晦涩，实际开发当中基本不予采用。应用比较多的XML解析工具反而是第三方的Dom4j，Dom4j的解析方式遵循DOM规则，但比起Java自带的DOM工具要易用得多，其性能也很优异，几乎成为Java开发必备的XML解析神器了。通过Dom4j解析XML报文的步骤主要有下列五步：<br> 1、创建SAXReader阅读器对象；<br> 2、把字符串形式的XML报文转换为输入流对象；<br> 3、命令阅读器对象从输入流中读取Document文档对象；<br> 4、获得文档对象的根节点Element；<br> 5、从根节点往下依次解析每个层级的节点值；<br> 在具体的节点解析过程之中，会频繁调用Element的相关方法，它的常用方法说明如下：<br> <em><strong>getText：获得当前节点的字符串值。<br> element：获得当前节点下面指定名称的子节点对象。<br> elementText：获得当前节点下面指定名称的子节点值。<br> elements：获得当前节点下面指定名称的子节点清单。<br> attribute：获得当前节点自身指定名称的属性对象。<br> attributeValue：获得当前节点自身指定名称的属性值。<br> attributes：获得当前节点拥有的全部属性清单。</strong></em></p> 
<p>仍以前述的XML报文为例，下面是采用Dom4j解析该XML串的代码例子：</p> 
<pre><code>// 通过dom4j解析xml串
private static GoodsOrder testParserByDom4j(String xml) {
    GoodsOrder order = new GoodsOrder(); // 创建一个购物订单对象
    // 创建SAXReader阅读器对象
    SAXReader reader = new SAXReader();
    // 根据字符串构建字节数组输入流
    try (InputStream is = new ByteArrayInputStream(xml.getBytes(CHARSET))) {
        // 命令阅读器从输入流中读取文档对象
        Document document = reader.read(is);
        // 获得文档对象的根节点
        Element root = document.getRootElement();
        // 获取根节点下面名叫user_info的节点
        Element user_info = root.element("user_info");
        // 获取user_info节点下面名叫name的节点值
        order.user_info.name = user_info.element("name").getText();
        // 获取user_info节点下面名叫address的节点值
        order.user_info.address = user_info.element("address").getText();
        // 获取user_info节点下面名叫phone的节点值
        order.user_info.phone = user_info.element("phone").getText();
        System.out.println(String.format("用户信息如下：姓名=%s，地址=%s，手机号=%s",
                order.user_info.name, order.user_info.address, order.user_info.phone));
        // 获取根节点下面名叫goods_list的节点清单
        List&lt;Element&gt; goods_list = root.element("goods_list").elements();
        for (int i=0; i&lt;goods_list.size(); i++) { // 遍历商品节点清单
            Element goods_item = goods_list.get(i);
            GoodsItem item = new GoodsItem(); // 创建一项商品对象
            // 获取当前商品项节点下面名叫goods_name的节点值
            item.goods_name = goods_item.element("goods_name").getText();
            // 获取当前商品项节点下面名叫goods_number的节点值
            item.goods_number = Integer.parseInt(goods_item.element("goods_number").getText());
            // 获取当前商品项节点下面名叫goods_price的节点值
            item.goods_price = Double.parseDouble(goods_item.element("goods_price").getText());
            System.out.println(String.format("第%d个商品：名称=%s，数量=%d，价格=%f",
                    i+1, item.goods_name, item.goods_number, item.goods_price));
            order.goods_list.add(item); // 往商品清单中添加指定商品对象
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return order; // 返回解析后的购物订单对象
}
</code></pre> 
<p>运行以上的解析代码，观察到以下的购物订单日志，可见成功实现了xml串到对象的解析操作：<br> 用户信息如下：姓名=思无邪，地址=桃花岛水帘洞123号，手机号=15960238696<br> 第1个商品：名称=Mate30，数量=1，价格=8888.000000<br> 第2个商品：名称=格力中央空调，数量=1，价格=58000.000000<br> 第3个商品：名称=红蜻蜓皮鞋，数量=3，价格=999.000000</p> 
<p>除了解析各节点的节点值，Dom4j还能解析各节点的属性值，若想正常解析指定名称的属性值，则需明确下列三个要素：该属性的上级节点对象、该属性所在节点的节点名称，该属性的属性名称。有了这三个要素，即可通过以下方法从指定节点的指定属性成功获取属性值：</p> 
<pre><code>// 打印指定节点名称的指定属性值
private static void printValueAndAttr(Element parent, String node_name, String attr_name) {
    // 获取父节点下面指定名称的子节点
    Element element = parent.element(node_name);
    // 获得子节点的节点值
    String node_value = element.getText();
    String attr_value = "";
    // 根据属性名称获取子节点的对应属性对象
    Attribute attr = element.attribute(attr_name);
    if (attr != null) {
        attr_value = attr.getText(); // 获取该属性的属性值
    }
    // 打印子节点的详细信息，包括节点名称、节点值、属性名称、属性值
    System.out.println(String.format("节点名称=%s, 节点值=%s, 属性名称=%s, 属性值=%s",
            node_name, node_value, attr_name, attr_value));
}
</code></pre> 
<p>接下来在原先的XML解析代码里补充如下的一行属性解析代码：</p> 
<p>// 打印user_info节点的name子节点的type属性值 printValueAndAttr(user_info, “name”, “type”);</p> 
<p>再次运行XML解析代码，在输出的购物订单日志中观察到多了下面这行日志，表示解析到了name节点的type属性值：</p> 
<p>节点名称=name, 节点值=思无邪, 属性名称=type, 属性值=string</p> 
<h3><a id="_133"></a>总结：</h3> 
<p>至此可获取xml标签内信息及标签属性</p> 
<p>原文链接: <a href="https://www.cnblogs.com/pinlantu/p/11000515.html" rel="nofollow">link</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0250393fdcba0ce7dc73c98f67f56908/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">System.IO.Ports is currently only supported on Windows</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b46ef90418e0aa73a75c6968b92c9ee2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">NVMf RPC接口文件 nvmf_rpc.c</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>