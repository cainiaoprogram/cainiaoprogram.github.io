<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MySQL半同步复制 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MySQL半同步复制" />
<meta property="og:description" content="目录
MySQL主从复制的几个同步模式：
●异步复制（Asynchronous replication）
●全同步复制（Fully synchronous replication）
●半同步复制（Semisynchronous replication）
//主数据库配置
//从数据库配置
#主数据库执行
#从数据库执行（此时可能还是OFF状态，需要在下一步重启IO线程后，从库半同步状态才会为ON）
#重启从数据库上的IO线程
#在主库查询半同步状态
MySQL主从复制的几个同步模式： ●异步复制（Asynchronous replication） MySQL默认的复制即是异步的，主库在执行完客户端提交的事务后会立即将结果返给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主如果crash掉了，此时主上已经提交的事务可能并没有传到从上，如果此时，强行将从提升为主，可能导致新主上的数据不完整。
●全同步复制（Fully synchronous replication） 指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。
●半同步复制（Semisynchronous replication） 介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。
//主数据库配置 vim /etc/my.cnf #在 [mysqld] 区域添加下面内容
......
plugin-load=rpl_semi_sync_master=semisync_master.so #加载mysql半同步复制的插件
rpl_semi_sync_master_enabled=ON #或者设置为&#34;1&#34;，即开启半同步复制功能
rpl-semi-sync-master-timeout=1000 #超时时间为1000ms，即1s
systemctl restart mysqld
//从数据库配置 vim /etc/my.cnf ......
plugin-load=rpl_semi_sync_slave=semisync_slave.so
rpl_semi_sync_slave_enabled=ON
systemctl restart mysqld
//查看半同步是否在运行
#主数据库执行 show status like &#39;Rpl_semi_sync_master_status&#39;;
show variables like &#39;rpl_semi_sync_master_timeout&#39;;
#从数据库执行（此时可能还是OFF状态，需要在下一步重启IO线程后，从库半同步状态才会为ON） show status like &#39;Rpl_semi_sync_slave_status&#39;;
#重启从数据库上的IO线程 STOP SLAVE IO_THREAD;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9a222d3d3108871978e28c321af4dad6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-09T16:17:56+08:00" />
<meta property="article:modified_time" content="2024-01-09T16:17:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MySQL半同步复制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%EF%BC%9A-toc" style="margin-left:80px;"><a href="#MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%EF%BC%9A" rel="nofollow">MySQL主从复制的几个同步模式：</a></p> 
<p id="%E2%97%8F%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6%EF%BC%88Asynchronous%20replication%EF%BC%89-toc" style="margin-left:120px;"><a href="#%E2%97%8F%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6%EF%BC%88Asynchronous%20replication%EF%BC%89" rel="nofollow">●异步复制（Asynchronous replication）</a></p> 
<p id="%E2%97%8F%E5%85%A8%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6%EF%BC%88Fully%20synchronous%20replication%EF%BC%89-toc" style="margin-left:120px;"><a href="#%E2%97%8F%E5%85%A8%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6%EF%BC%88Fully%20synchronous%20replication%EF%BC%89" rel="nofollow">●全同步复制（Fully synchronous replication）</a></p> 
<p id="%E2%97%8F%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6%EF%BC%88Semisynchronous%20replication%EF%BC%89-toc" style="margin-left:120px;"><a href="#%E2%97%8F%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6%EF%BC%88Semisynchronous%20replication%EF%BC%89" rel="nofollow">●半同步复制（Semisynchronous replication）</a></p> 
<p id="%2F%2F%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE-toc" style="margin-left:120px;"><a href="#%2F%2F%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE" rel="nofollow">//主数据库配置</a></p> 
<p id="%2F%2F%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE-toc" style="margin-left:120px;"><a href="#%2F%2F%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE" rel="nofollow">//从数据库配置</a></p> 
<p id="%23%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A7%E8%A1%8C-toc" style="margin-left:120px;"><a href="#%23%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A7%E8%A1%8C" rel="nofollow">#主数据库执行</a></p> 
<p id="%23%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A7%E8%A1%8C%EF%BC%88%E6%AD%A4%E6%97%B6%E5%8F%AF%E8%83%BD%E8%BF%98%E6%98%AFOFF%E7%8A%B6%E6%80%81%EF%BC%8C%E9%9C%80%E8%A6%81%E5%9C%A8%E4%B8%8B%E4%B8%80%E6%AD%A5%E9%87%8D%E5%90%AFIO%E7%BA%BF%E7%A8%8B%E5%90%8E%EF%BC%8C%E4%BB%8E%E5%BA%93%E5%8D%8A%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E6%89%8D%E4%BC%9A%E4%B8%BAON%EF%BC%89-toc" style="margin-left:120px;"><a href="#%23%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A7%E8%A1%8C%EF%BC%88%E6%AD%A4%E6%97%B6%E5%8F%AF%E8%83%BD%E8%BF%98%E6%98%AFOFF%E7%8A%B6%E6%80%81%EF%BC%8C%E9%9C%80%E8%A6%81%E5%9C%A8%E4%B8%8B%E4%B8%80%E6%AD%A5%E9%87%8D%E5%90%AFIO%E7%BA%BF%E7%A8%8B%E5%90%8E%EF%BC%8C%E4%BB%8E%E5%BA%93%E5%8D%8A%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E6%89%8D%E4%BC%9A%E4%B8%BAON%EF%BC%89" rel="nofollow">#从数据库执行（此时可能还是OFF状态，需要在下一步重启IO线程后，从库半同步状态才会为ON）</a></p> 
<p id="%23%E9%87%8D%E5%90%AF%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8A%E7%9A%84IO%E7%BA%BF%E7%A8%8B-toc" style="margin-left:120px;"><a href="#%23%E9%87%8D%E5%90%AF%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8A%E7%9A%84IO%E7%BA%BF%E7%A8%8B" rel="nofollow">#重启从数据库上的IO线程</a></p> 
<p id="%23%E5%9C%A8%E4%B8%BB%E5%BA%93%E6%9F%A5%E8%AF%A2%E5%8D%8A%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81-toc" style="margin-left:120px;"><a href="#%23%E5%9C%A8%E4%B8%BB%E5%BA%93%E6%9F%A5%E8%AF%A2%E5%8D%8A%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81" rel="nofollow">#在主库查询半同步状态</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h4 id="MySQL%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%87%A0%E4%B8%AA%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F%EF%BC%9A">MySQL主从复制的几个同步模式：</h4> 
<h5 id="%E2%97%8F%E5%BC%82%E6%AD%A5%E5%A4%8D%E5%88%B6%EF%BC%88Asynchronous%20replication%EF%BC%89"><br> ●异步复制（Asynchronous replication）</h5> 
<p>MySQL默认的复制即是异步的，主库在执行完客户端提交的事务后会立即将结果返给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主如果crash掉了，此时主上已经提交的事务可能并没有传到从上，如果此时，强行将从提升为主，可能导致新主上的数据不完整。</p> 
<h5 id="%E2%97%8F%E5%85%A8%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6%EF%BC%88Fully%20synchronous%20replication%EF%BC%89">●全同步复制（Fully synchronous replication）</h5> 
<p>指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。</p> 
<h5 id="%E2%97%8F%E5%8D%8A%E5%90%8C%E6%AD%A5%E5%A4%8D%E5%88%B6%EF%BC%88Semisynchronous%20replication%EF%BC%89">●半同步复制（Semisynchronous replication）</h5> 
<p>介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。</p> 
<h5 id="%2F%2F%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE">//主数据库配置</h5> 
<p><br> vim /etc/my.cnf                #在 [mysqld] 区域添加下面内容<br> ......<br> plugin-load=rpl_semi_sync_master=semisync_master.so            #加载mysql半同步复制的插件<br> rpl_semi_sync_master_enabled=ON                                #或者设置为"1"，即开启半同步复制功能<br> rpl-semi-sync-master-timeout=1000                            #超时时间为1000ms，即1s</p> 
<p>systemctl restart mysqld</p> 
<h5 id="%2F%2F%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E9%85%8D%E7%BD%AE">//从数据库配置</h5> 
<p>vim /etc/my.cnf    <br> ......<br> plugin-load=rpl_semi_sync_slave=semisync_slave.so<br> rpl_semi_sync_slave_enabled=ON</p> 
<p>systemctl restart mysqld</p> 
<p>//查看半同步是否在运行</p> 
<h5 id="%23%E4%B8%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A7%E8%A1%8C">#主数据库执行</h5> 
<p>show status like 'Rpl_semi_sync_master_status';<br> show variables like 'rpl_semi_sync_master_timeout';</p> 
<h5 id="%23%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%89%A7%E8%A1%8C%EF%BC%88%E6%AD%A4%E6%97%B6%E5%8F%AF%E8%83%BD%E8%BF%98%E6%98%AFOFF%E7%8A%B6%E6%80%81%EF%BC%8C%E9%9C%80%E8%A6%81%E5%9C%A8%E4%B8%8B%E4%B8%80%E6%AD%A5%E9%87%8D%E5%90%AFIO%E7%BA%BF%E7%A8%8B%E5%90%8E%EF%BC%8C%E4%BB%8E%E5%BA%93%E5%8D%8A%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E6%89%8D%E4%BC%9A%E4%B8%BAON%EF%BC%89">#从数据库执行（此时可能还是OFF状态，需要在下一步重启IO线程后，从库半同步状态才会为ON）</h5> 
<p>show status like 'Rpl_semi_sync_slave_status';</p> 
<h5 id="%23%E9%87%8D%E5%90%AF%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8A%E7%9A%84IO%E7%BA%BF%E7%A8%8B">#重启从数据库上的IO线程</h5> 
<p>STOP SLAVE IO_THREAD;<br> START SLAVE IO_THREAD;</p> 
<h5 id="%23%E5%9C%A8%E4%B8%BB%E5%BA%93%E6%9F%A5%E8%AF%A2%E5%8D%8A%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81">#在主库查询半同步状态</h5> 
<p>show status like '%Rpl_semi%';    </p> 
<p>参数说明：<br> Rpl_semi_sync_master_clients                      #半同步复制客户端的个数<br> Rpl_semi_sync_master_net_avg_wait_time            #平均等待时间（默认毫秒）<br> Rpl_semi_sync_master_net_wait_time                #总共等待时间<br> Rpl_semi_sync_master_net_waits                    #等待次数<br> Rpl_semi_sync_master_no_times                     #关闭半同步复制的次数<br> Rpl_semi_sync_master_no_tx                        #表示没有成功接收slave提交的次数<br> Rpl_semi_sync_master_status                       #表示当前是异步模式还是半同步模式，on为半同步<br> Rpl_semi_sync_master_timefunc_failures            #调用时间函数失败的次数<br> Rpl_semi_sync_master_tx_avg_wait_time             #事物的平均传输时间<br> Rpl_semi_sync_master_tx_wait_time                 #事物的总共传输时间<br> Rpl_semi_sync_master_tx_waits                     #事物等待次数<br> Rpl_semi_sync_master_wait_pos_backtraverse        #可以理解为"后来的先到了，而先来的还没有到的次数"<br> Rpl_semi_sync_master_wait_sessions                #当前有多少个session因为slave的回复而造成等待<br> Rpl_semi_sync_master_yes_tx                       #成功接受到slave事物回复的次数</p> 
<p>当半同步复制发生超时（由rpl_semi_sync_master_timeout参数控制，默认为10000ms，即10s），会暂时关闭半同步复制，转而使用异步复制，也就是会自动降为异步工作。<br> 当 master dump 线程发送完一个事务的所有事件之后，如果在 rpl_semi_sync_master_timeout 内，收到了从库的响应， 则主从又重新恢复为半同步复制。</p> 
<p><br> 注：<br> 1) 在一主多从的架构中，如果要开启半同步复制，并不要求所有的从都是半同步复制。<br> 2) MySQL 5.7极大的提升了半同步复制的性能。<br> 5.6 版本的半同步复制，dump thread 承担了两份不同且又十分频繁的任务：传送binlog 给 slave ，还需要等待 slave 反馈信息，而且这两个任务是串行的，dump thread 必须等待 slave 返回之后才会传送下一个 events 事务。dump thread 已然成为整个半同步提高性能的瓶颈。在高并发业务场景下，这样的机制会影响数据库整体的系统吞吐量(TPS)。<br> 5.7 版本的半同步复制中，独立出一个 ack collector thread ，专门用于接收 slave 的反馈信息。这样 master 上有两个线程独立工作，可以同时发送 binlog 到 slave ，和接收 slave 的反馈。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0ccaccc05ae51c7f28634604d80c4c8a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">solr8.4配置用户登录验证</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a965e2485679f526832d69339dd18705/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用Java读取Excel文件，实现数据批处理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>