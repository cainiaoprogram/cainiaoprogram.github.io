<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一步一步写算法（之hash表） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一步一步写算法（之hash表）" />
<meta property="og:description" content="【 声明：版权所有，欢迎转载，请勿用于商业用途。 联系信箱：feixiaoxing @163.com】
hash表，有时候也被称为散列表。个人认为，hash表是介于链表和二叉树之间的一种中间结构。链表使用十分方便，但是数据查找十分麻烦；二叉树中的数据严格有序，但是这是以多一个指针作为代价的结果。hash表既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。
打个比方来说，所有的数据就好像许许多多的书本。如果这些书本是一本一本堆起来的，就好像链表或者线性表一样，整个数据会显得非常的无序和凌乱，在你找到自己需要的书之前，你要经历许多的查询过程；而如果你对所有的书本进行编号，并且把这些书本按次序进行排列的话，那么如果你要寻找的书本编号是n，那么经过二分查找，你很快就会找到自己需要的书本；但是如果你每一个种类的书本都不是很多，那么你就可以对这些书本进行归类，哪些是文学类，哪些是艺术类，哪些是工科的，哪些是理科的，你只要对这些书本进行简单的归类，那么寻找一本书也会变得非常简单，比如说如果你要找的书是计算机方面的书，那么你就会到工科一类当中去寻找，这样查找起来也会显得麻烦。
不知道这样举例你清楚了没有，上面提到的归类方法其实就是hash表的本质。下面我们可以写一个简单的hash操作代码。
a）定义hash表和基本数据节点
typedef struct _NODE { int data; struct _NODE* next; }NODE; typedef struct _HASH_TABLE { NODE* value[10]; }HASH_TABLE; b）创建hash表 HASH_TABLE* create_hash_table() { HASH_TABLE* pHashTbl = (HASH_TABLE*)malloc(sizeof(HASH_TABLE)); memset(pHashTbl, 0, sizeof(HASH_TABLE)); return pHashTbl; } c）在hash表当中寻找数据 NODE* find_data_in_hash(HASH_TABLE* pHashTbl, int data) { NODE* pNode; if(NULL == pHashTbl) return NULL; if(NULL == (pNode = pHashTbl-&gt;value[data % 10])) return NULL; while(pNode){ if(data == pNode-&gt;data) return pNode; pNode = pNode-&gt;next; } return NULL; } d）在hash表当中插入数据 STATUS insert_data_into_hash(HASH_TABLE* pHashTbl, int data) { NODE* pNode; if(NULL == pHashTbl) return FALSE; if(NULL == pHashTbl-&gt;value[data % 10]){ pNode = (NODE*)malloc(sizeof(NODE)); memset(pNode, 0, sizeof(NODE)); pNode-&gt;data = data; pHashTbl-&gt;value[data % 10] = pNode; return TRUE; } if(NULL !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/083efad7b6e504e9461f3643b4844819/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-10-18T18:43:51+08:00" />
<meta property="article:modified_time" content="2011-10-18T18:43:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一步一步写算法（之hash表）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>【 声明：版权所有，欢迎转载，请勿用于商业用途。  联系信箱：feixiaoxing @163.com】</p> 
<p><br> </p> 
<p>    hash表，有时候也被称为散列表。个人认为，hash表是介于链表和二叉树之间的一种中间结构。链表使用十分方便，但是数据查找十分麻烦；二叉树中的数据严格有序，但是这是以多一个指针作为代价的结果。hash表既满足了数据的查找方便，同时不占用太多的内容空间，使用也十分方便。</p> 
<p>    打个比方来说，所有的数据就好像许许多多的书本。如果这些书本是一本一本堆起来的，就好像链表或者线性表一样，整个数据会显得非常的无序和凌乱，在你找到自己需要的书之前，你要经历许多的查询过程；而如果你对所有的书本进行编号，并且把这些书本按次序进行排列的话，那么如果你要寻找的书本编号是n，那么经过二分查找，你很快就会找到自己需要的书本；但是如果你每一个种类的书本都不是很多，那么你就可以对这些书本进行归类，哪些是文学类，哪些是艺术类，哪些是工科的，哪些是理科的，你只要对这些书本进行简单的归类，那么寻找一本书也会变得非常简单，比如说如果你要找的书是计算机方面的书，那么你就会到工科一类当中去寻找，这样查找起来也会显得麻烦。</p> 
<p>    不知道这样举例你清楚了没有，上面提到的归类方法其实就是hash表的本质。下面我们可以写一个简单的hash操作代码。</p> 
<p>    <strong><span style="color:#000099"><span style="background-color:rgb(255,102,0)">a）定义hash表和基本数据节点</span></span></strong></p> 
<p></p> 
<pre><code class="language-cpp">typedef struct _NODE
{
	int data;
	struct _NODE* next;
}NODE;

typedef struct _HASH_TABLE
{
	NODE* value[10];
}HASH_TABLE;
</code></pre> 
<br>      
<strong><span style="color:#000099"><span style="background-color:rgb(255,102,0)">b）创建hash表</span></span></strong> 
<p></p> 
<p></p> 
<pre><code class="language-cpp">HASH_TABLE* create_hash_table()
{
	HASH_TABLE* pHashTbl = (HASH_TABLE*)malloc(sizeof(HASH_TABLE));
	memset(pHashTbl, 0, sizeof(HASH_TABLE));
	return pHashTbl;
}</code></pre> 
<br>      
<strong><span style="color:#000099"><span style="background-color:rgb(255,102,0)">c）在hash表当中寻找数据</span></span></strong> 
<p></p> 
<p></p> 
<pre><code class="language-cpp">NODE* find_data_in_hash(HASH_TABLE* pHashTbl, int data)
{
	NODE* pNode;
	if(NULL ==  pHashTbl)
		return NULL;

	if(NULL == (pNode = pHashTbl-&gt;value[data % 10]))
		return NULL;

	while(pNode){
		if(data == pNode-&gt;data)
			return pNode;
		pNode = pNode-&gt;next;
	}
	return NULL;
}</code></pre> 
<br>      
<strong><span style="color:#000099"><span style="background-color:rgb(255,102,0)">d）在hash表当中插入数据</span></span></strong> 
<p></p> 
<p></p> 
<pre><code class="language-cpp">STATUS insert_data_into_hash(HASH_TABLE* pHashTbl, int data)
{
	NODE* pNode;
	if(NULL == pHashTbl)
		return FALSE;

	if(NULL == pHashTbl-&gt;value[data % 10]){
		pNode = (NODE*)malloc(sizeof(NODE));
		memset(pNode, 0, sizeof(NODE));
		pNode-&gt;data = data;
		pHashTbl-&gt;value[data % 10] = pNode;
		return TRUE;
	}

	if(NULL != find_data_in_hash(pHashTbl, data))
		return FALSE;

	pNode = pHashTbl-&gt;value[data % 10];
	while(NULL != pNode-&gt;next)
		pNode = pNode-&gt;next;

	pNode-&gt;next = (NODE*)malloc(sizeof(NODE));
	memset(pNode-&gt;next, 0, sizeof(NODE));
	pNode-&gt;next-&gt;data = data;
	return TRUE;
}</code></pre> 
<br>      
<strong><span style="color:#000099"><span style="background-color:rgb(255,102,0)">e）从hash表中删除数据</span></span></strong> 
<p></p> 
<p></p> 
<pre><code class="language-cpp">STATUS delete_data_from_hash(HASH_TABLE* pHashTbl, int data)
{
	NODE* pHead;
	NODE* pNode;
	if(NULL == pHashTbl || NULL == pHashTbl-&gt;value[data % 10])
		return FALSE;

	if(NULL == (pNode = find_data_in_hash(pHashTbl, data)))
		return FALSE;

	if(pNode == pHashTbl-&gt;value[data % 10]){
		pHashTbl-&gt;value[data % 10] = pNode-&gt;next;
		goto final;
	}

	pHead = pHashTbl-&gt;value[data % 10];
	while(pNode != pHead -&gt;next)
		pHead = pHead-&gt;next;
	pHead-&gt;next = pNode-&gt;next;

final:
	free(pNode);
	return TRUE;
}</code></pre> 
<br> 
<strong><span style="color:#000099"><span style="background-color:rgb(255,102,0)">总结：</span></span></strong> 
<p></p> 
<p>    1、hash表不复杂，我们在开发中也经常使用，建议朋友们好好掌握；</p> 
<p>    2、hash表可以和二叉树形成复合结构，至于为什么，建议朋友们好好思考一下？</p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fc58029788735f8420100a33af2f327b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">不能实例化抽象类 是什么原因？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/78bf0006aaa49e848ff6e00fcb7aabc7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">易康特征（ecognition）零散笔记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>