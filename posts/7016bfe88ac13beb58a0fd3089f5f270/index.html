<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>解密TLS协议全记录之Openssl的使用与Nginx Server的配置 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="解密TLS协议全记录之Openssl的使用与Nginx Server的配置" />
<meta property="og:description" content="引言 Openssl是TLS协议进行报文加密，安全通讯而用到的开源代码包，代码主要由C语言编写，我个人也只看了其中一部分代码，当作工具使用，没有深入分析。
其维基百科的链接:https://zh.wikipedia.org/zh-cn/OpenSSL，
openssl的官网wiki链接：https://wiki.openssl.org/index.php/Enc#Cipher_alogorithmsNginx是一款面向性能设计的HTTP服务器，相较于Apache、lighttpd具有占有内存少，稳定性高等优势。与旧版本（≤ 2.2）的Apache不同，Nginx不采用每客户机一线程的设计模型，而是充分使用异步逻辑从而削减了上下文调度开销，所以并发服务能力更强，其中也有利用到openssl的代码进行安全通讯。 安装与使用 需要注意的是，接下来的编译，安装都将支持TLS1.3协议，由于TLS1.3目前还未完全成熟，因此需要我们进行额外的编译操作来使系统支持。
1. openssl 1.1 openssl 编译与安装 1.1.1 编译安装openssl 1.1.1版本, 来支持TLS1.3协议。 openssl的源码链接：https://www.openssl.org/source/, 选择 Openssl 1.1.1版本，目前这个版本支持最新的TLS1.3协议草案。
编译安装指令： #查看openssl的版本信息 pi@raspberrypi:~ $ openssl version OpenSSL 1.0.1t 3 May 2016 # 卸载系统自带的openssl，避免链接冲突问题。 sudo apt-get remove openssl wget https://www.openssl.org/source/openssl-1.1.1g.tar.gz tar -xf openssl-1.1.1g.tar.gz cd openssl-1.1.1g ./Configure # 在需要确定编译器环境的时候，请执行./config, 参阅Q&amp;A make make install 查看openssl的最新版本信息, 查看openssl支持的加密套件，并确定是否支持 TLS1.3协议
pi@raspberrypi:/usr/local $ openssl version OpenSSL 1.1.1g 21 Apr 2020 pi@raspberrypi:/usr/local $ openssl ciphers -V 0x13,0x02 - TLS_AES_256_GCM_SHA384 TLSv1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7016bfe88ac13beb58a0fd3089f5f270/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-07-09T01:03:05+08:00" />
<meta property="article:modified_time" content="2020-07-09T01:03:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">解密TLS协议全记录之Openssl的使用与Nginx Server的配置</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>引言</h2> 
<ul><li>Openssl是TLS协议进行报文加密，安全通讯而用到的开源代码包，代码主要由C语言编写，我个人也只看了其中一部分代码，当作工具使用，没有深入分析。<br> 其维基百科的链接:<a href="https://zh.wikipedia.org/zh-cn/OpenSSL" rel="nofollow">https://zh.wikipedia.org/zh-cn/OpenSSL</a>，<br> openssl的官网wiki链接：<a href="https://wiki.openssl.org/index.php/Enc#Cipher_alogorithms" rel="nofollow">https://wiki.openssl.org/index.php/Enc#Cipher_alogorithms</a></li><li>Nginx是一款面向性能设计的HTTP服务器，相较于Apache、lighttpd具有占有内存少，稳定性高等优势。与旧版本（≤ 2.2）的Apache不同，Nginx不采用每客户机一线程的设计模型，而是充分使用异步逻辑从而削减了上下文调度开销，所以并发服务能力更强，其中也有利用到openssl的代码进行安全通讯。</li></ul> 
<h2><a id="_5"></a>安装与使用</h2> 
<p><code>需要注意的是，接下来的编译，安装都将支持TLS1.3协议，由于TLS1.3目前还未完全成熟，因此需要我们进行额外的编译操作来使系统支持。</code></p> 
<h3><a id="1_openssl_7"></a>1. openssl</h3> 
<h4><a id="11_openssl__8"></a>1.1 openssl 编译与安装</h4> 
<h5><a id="111_openssl_111_TLS13_9"></a>1.1.1 编译安装openssl 1.1.1版本, 来支持TLS1.3协议。</h5> 
<ul><li>openssl的源码链接：<a href="https://www.openssl.org/source/" rel="nofollow">https://www.openssl.org/source/</a>, 选择 <mark>Openssl 1.1.1版本</mark>，目前这个版本支持最新的TLS1.3协议草案。<br> 编译安装指令：</li></ul> 
<pre><code class="prism language-bash"><span class="token comment">#查看openssl的版本信息</span>
pi@raspberrypi:~ $ openssl version
OpenSSL 1.0.1t  3 May 2016
<span class="token comment"># 卸载系统自带的openssl，避免链接冲突问题。</span>
<span class="token function">sudo</span> <span class="token function">apt-get</span> remove openssl
<span class="token function">wget</span>  https://www.openssl.org/source/openssl-1.1.1g.tar.gz
<span class="token function">tar</span> -xf openssl-1.1.1g.tar.gz
<span class="token function">cd</span> openssl-1.1.1g
./Configure <span class="token comment"># 在需要确定编译器环境的时候，请执行./config, 参阅Q&amp;A</span>
<span class="token function">make</span>
<span class="token function">make</span> <span class="token function">install</span>
</code></pre> 
<p>查看openssl的最新版本信息, 查看openssl支持的加密套件，并确定是否支持 TLS1.3协议</p> 
<pre><code class="prism language-bash">pi@raspberrypi:/usr/local $ openssl version
OpenSSL 1.1.1g  21 Apr 2020
pi@raspberrypi:/usr/local $ openssl ciphers -V
          0x13,0x02 - TLS_AES_256_GCM_SHA384  TLSv1.3 Kx<span class="token operator">=</span>any      Au<span class="token operator">=</span>any  Enc<span class="token operator">=</span>AESGCM<span class="token punctuation">(</span>256<span class="token punctuation">)</span> Mac<span class="token operator">=</span>AEAD
          0x13,0x03 - TLS_CHACHA20_POLY1305_SHA256 TLSv1.3 Kx<span class="token operator">=</span>any      Au<span class="token operator">=</span>any  Enc<span class="token operator">=</span>CHACHA20/POLY1305<span class="token punctuation">(</span>256<span class="token punctuation">)</span> Mac<span class="token operator">=</span>AEAD
          0x13,0x01 - TLS_AES_128_GCM_SHA256  TLSv1.3 Kx<span class="token operator">=</span>any      Au<span class="token operator">=</span>any  Enc<span class="token operator">=</span>AESGCM<span class="token punctuation">(</span>128<span class="token punctuation">)</span> Mac<span class="token operator">=</span>AEAD
          0xC0,0x2C - ECDHE-ECDSA-AES256-GCM-SHA384 TLSv1.2 Kx<span class="token operator">=</span>ECDH     Au<span class="token operator">=</span>ECDSA Enc<span class="token operator">=</span>AESGCM<span class="token punctuation">(</span>256<span class="token punctuation">)</span> Mac<span class="token operator">=</span>AEAD
          0xC0,0x30 - ECDHE-RSA-AES256-GCM-SHA384 TLSv1.2 Kx<span class="token operator">=</span>ECDH     Au<span class="token operator">=</span>RSA  
</code></pre> 
<p>对以上的输出做一下说明：</p> 
<blockquote> 
 <p>Kx 表示<code>密钥交换的加密算法（需要结合wireshark以及TLS协议进行流程分析，在TLS1.2中，主要是指RSA和DH密钥交换算法， 根据rfc5246中的描述，Kx等于any时，表示匿名密钥交换算法， 一般通过Diffie-Hellman来实现密钥交换。</code>，<br> Au表示身份认证算法，Enc表示通信数据的加密算法， Mac表示消息验证算法(计算消息摘要的算法)。</p> 
</blockquote> 
<p>通过openssl 测试网站<mark>是否支持 TLS1.3 协议</mark></p> 
<pre><code class="prism language-bash">openssl s_client -connect www.nike.com:443 -tls1_3
</code></pre> 
<h5><a id="112_QA_44"></a>1.1.2 总结Q&amp;A</h5> 
<h6><a id="Q_configure_Makefile__45"></a>Q: 使用./configure 配置编译环境所使用的Makefile的时候，出现以下警告，此时会提醒 需要选择和系统适配的编译器.</h6> 
<p><code>Notice: Configure脚本是用来生成Makefile的脚本，用于确定系统，编译器， 编译安装目录等等编译环境，便于适应多环境和平台， 类似CMake，其目的就是 用来构建工程项目框架，通过./Configure --help可以查看相关帮助信息。</code><br> 报错的Log如下：</p> 
<blockquote> 
 <p>pi@raspberrypi:~/pkg_compile/openssl-1.1.1g $ ./Configure<br> Usage: Configure [no- …] [enable- …] [-Dxxx] [-lxxx] [-Lxxx] [-fxxx] [-Kxxx] [no-hw-xxx|no-hw] [[no-]threads] [[no[no-]zlib|zlib-dynamic] [no-asm] [no-egd] [sctp] [386] [–prefix=DIR] [–openssldir=OPENSSLDIR] [–with-xxx[=vvv]] [–config=FILE] os/lags]<br> pick os/compiler from:<br> BS2000-OSD BSD-generic32 BSD-generic64<br> NOTE: If in doubt, on Unix-ish systems use ‘./config’，</p> 
</blockquote> 
<p>A: 解决办法，可以通过<br> <s><code>./Configure CC=编译器绝对路径</code>来选择编译器，</s><br> 也可以直接执行 <code>./config</code> 脚本, 该脚本会帮忙确定当前系统的编译环境，然后执行./Configure脚本。</p> 
<blockquote> 
 <p>pi@raspberrypi:~/pkg_compile/openssl-1.1.1g $ ./config<br> Operating system: armv7l-whatever-linux2<br> Configuring OpenSSL version 1.1.1g (0x1010107fL) for linux-armv4<br> Using os-specific seed configuration<br> Creating configdata.pm<br> Creating Makefile</p> 
</blockquote> 
<h6><a id="Qopensslopenssl_error_while_loading_shared_libraries_libsslso11_cannot_open_shared_object_file_No_such_file_or_directory_63"></a>Q:执行openssl的时候，出现openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory</h6> 
<p>A: 在标准的lib库路径找不到库，需要执行</p> 
<pre><code class="prism language-bash"><span class="token function">ln</span> -s /usr/local/lib/libssl.so.1.1 /usr/lib/libssl.so.1.1
<span class="token function">ln</span> -s /usr/local/lib/libcrypto.so.1.1 /usr/lib/libcrypto.so.1.1
</code></pre> 
<p>或者<code>配置 LD_LIBRARY_PATH</code> 的环境变量，来添加动态库的搜索路径。</p> 
<h3><a id="2_nginx_71"></a>2. nginx服务器的搭建</h3> 
<h4><a id="21_nginx_72"></a>2.1 nginx编译与安装</h4> 
<p>通过官网的Change-log文件：<a href="https://nginx.org/en/CHANGES-1.16" rel="nofollow">https://nginx.org/en/CHANGES-1.16</a>, 可以知道最新版本的nginx 默认支持TLS1.3协议。</p> 
<blockquote> 
 <p>Changes with nginx 1.15.6 06 Nov 2018<br> *) Security: when using HTTP/2 a client might cause excessive memory<br> consumption (CVE-2018-16843) and CPU usage (CVE-2018-16844).<br> *) Security: processing of a specially crafted mp4 file with the<br> ngx_http_mp4_module might result in worker process memory disclosure<br> (CVE-2018-16845).<br> *) Feature: the “proxy_socket_keepalive”, “fastcgi_socket_keepalive”,<br> “grpc_socket_keepalive”, “memcached_socket_keepalive”,<br> “scgi_socket_keepalive”, and “uwsgi_socket_keepalive” directives.<br> *) Bugfix: if nginx was built with OpenSSL 1.1.0 and used with OpenSSL<br> 1.1.1, the TLS 1.3 protocol was always enabled.</p> 
</blockquote> 
<p>编译相关的内容也可以查阅官网的<a href="https://nginx.org/en/docs/" rel="nofollow">Documention</a>， 编译与安装的命令：</p> 
<pre><code class="prism language-bash"><span class="token function">cd</span> pkg-compile
<span class="token function">wget</span> https://netix.dl.sourceforge.net/project/pcre/pcre/8.40/pcre-8.40.tar.gz <span class="token comment">#需要支持perl工具</span>
<span class="token function">wget</span> http://www.zlib.net/zlib-1.2.11.tar.gz  <span class="token comment">#需要支持 zlib库</span>
<span class="token function">wget</span> https://nginx.org/download/nginx-1.16.1.tar.gz
<span class="token function">tar</span> -xf nginx-1.16.1.tar.gz
<span class="token function">tar</span> -xf pcre-8.40.tar.gz
<span class="token function">tar</span> -xf zlib-1.2.11.tar.gz
./configure --sbin-path<span class="token operator">=</span>/usr/local/nginx/nginx
    		--conf-path<span class="token operator">=</span>/usr/local/nginx/nginx.conf
   			--pid-path<span class="token operator">=</span>/usr/local/nginx/nginx.pid
    		--with-http_ssl_module
    		--with-pcre<span class="token operator">=</span><span class="token punctuation">..</span>/pcre-8.40
    		--with-zlib<span class="token operator">=</span><span class="token punctuation">..</span>/zlib-1.2.11
<span class="token function">make</span>
<span class="token function">make</span> <span class="token function">install</span>
</code></pre> 
<h4><a id="22_nginx__104"></a>2.2 nginx 配置与测试</h4> 
<h5><a id="221_http_105"></a>2.2.1 支持http服务器</h5> 
<pre><code class="prism language-bash">vim /usr/local/nginx/nginx.conf
<span class="token function">killall</span> nginx
/usr/local/nginx/nginx -c nginx.conf
</code></pre> 
<p>修改server 块中 server_name 为 eth0接口的ip地址。</p> 
<blockquote> 
 <p>server {<!-- --><br> listen 80;<br> server_name 192.168.1.196;<br> …<br> }</p> 
</blockquote> 
<p>也可以修改nginx文件下的html的indexl.html页面代码</p> 
<pre><code class="prism language-html"><span class="token doctype">&lt;!DOCTYPE html&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>Welcome to Starry!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span><span class="token punctuation">&gt;</span></span><span class="token style language-css">
    <span class="token selector">body</span> <span class="token punctuation">{<!-- --></span>
        <span class="token property">width</span><span class="token punctuation">:</span> 35em<span class="token punctuation">;</span>
        <span class="token property">margin</span><span class="token punctuation">:</span> 0 auto<span class="token punctuation">;</span>
        <span class="token property">font-family</span><span class="token punctuation">:</span> Tahoma, Verdana, Arial, sans-serif<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">&gt;</span></span>Welcome to Starry!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span> Fighting For Starry!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span> Go! Go! Go!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>

<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>em</span><span class="token punctuation">&gt;</span></span>Thank you for your love.<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>em</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>效果如图：<br> <img src="https://images2.imgbox.com/49/ed/5Eq3X0g0_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="222__openssl_143"></a>2.2.2 通过openssl制作签名证书</h5> 
<ul><li>在搭建https服务器之前，我们必须要为服务器创建证书，该证书需要通过TLS协议下发到客户端以便进行加密通信，因为创建的是个人的测试服务器，所以，我们通过openssl 制作的证书，就自己签名就可以了，正常来说，<mark>切记不要往浏览器上添加不清楚的签名机构的证书。</mark></li><li>在TLS协议中，当加密通信时，需要公钥信息以及需要确保通信双方的合法性，证书中便会包含这些内容， 一般来说，客户端需要校验服务端的证书内容 <mark>(正常来说， 正常的网页访问，客户端会校验服务器的证书，而网银的话，服务器还会校验客户端的证书， 来确保客户端是合法的。)</mark>， 正常来说， 浏览器会包含一些默认的合法证书和默认的证书签发机构的信息，用于校验绝大多数网站的合法性。</li></ul> 
<h6><a id="__147"></a>第一步， 创建客户端证书请求或者自签名证书。</h6> 
<p>Openssl官网手册： <a href="https://www.openssl.org/docs/man1.1.1/" rel="nofollow">https://www.openssl.org/docs/man1.1.1/</a></p> 
<pre><code class="prism language-bash">openssl genrsa -out cert.key <span class="token comment">#1024</span>
<span class="token comment">#如果生成ras密钥到ca.key， 并使用des3算法加密(之后每次使用该密钥，都要输入密码)</span>
<span class="token comment">#openssl genrsa -des3 -out cert.key 1024 </span>
<span class="token comment">#这条命令会需要如下，需要额外输入密码，对私钥的进行加密。</span>
<span class="token comment">#pi@raspberrypi:/usr/local/nginx/tls_file $ sudo openssl genrsa -des3 -out ca.key</span>
<span class="token comment">#Generating RSA private key, 2048 bit long modulus (2 primes)</span>
<span class="token comment">#..+++++</span>
<span class="token comment">#......................+++++</span>
<span class="token comment">#e is 65537 (0x010001)</span>
<span class="token comment">#Enter pass phrase for ca.key:</span>
<span class="token comment">#Verifying - Enter pass phrase for ca.key: </span>
</code></pre> 
<pre><code class="prism language-bash"><span class="token comment"># openssl rsa -in cert.key -pubout -out pubkey.pem #通过rsa参数，可以生成公钥信息，rsa参数专门用于实现rsa算法相关操作。</span>
<span class="token comment">######################################################################</span>
<span class="token comment"># openssl中 rsautl 参数用于实现基于rsa的加密解密的相关扩展使用工具，</span>
<span class="token comment"># 通过rsa工具，使用公钥加密文件</span>
<span class="token comment"># openssl rsautl -encrypt -in input.file -inkey pubkey.pem -pubin -out output.file </span>
<span class="token comment"># 通过rsa工具，使用私钥来解密文件</span>
<span class="token comment"># openssl rsautl -decrypt -in input.file -inkey key.pem -out output.file</span>
<span class="token comment">######################################################################</span>
<span class="token comment"># 用私钥来生成基于509证书标准的证书请求(req参数)， 这个证书请求将包含了公钥信息，但是要注意这里只是证书请求，不是证书。</span>
<span class="token comment"># 因为接下来还需签名机构加密头部， 类似于盖章，认证合法性， 所以称之为 证书请求。</span>
<span class="token comment"># -new  表示生成证书请求，  </span>
<span class="token comment"># -x509 表示 生成证书请求的同时，生成自签名证书</span>
<span class="token comment"># Notice: 在生成证书请求的时候，将会包含公钥等信息， 但是缺乏签名。</span>
openssl req -new -days 365 -key cert.key -out cert.csr 
</code></pre> 
<p><strong>以上命令会输出以下信息， 由于后续的CA在验证时会被使用到，这边揪出来特别说明。</strong><br> 为何会知道这几个选项会被使用， 查看 <code>cat /usr/local/ssl/openssl.cnf</code> 的时候，就会发现</p> 
<pre><code># For the CA policy
[ policy_match ]
countryName             = match
stateOrProvinceName     = match
organizationName        = match
organizationalUnitName  = optional
commonName              = supplied
emailAddress            = optional
</code></pre> 
<p>openssl在进行证书验证的时候， 需要签发机构的证书中 <strong>countryName，stateOrProvinceName，organizationName</strong>要和证书请求中的值匹配， commonName 作为服务器域名也一定要提供， 并且不能和CA证书中的值一样，否则，在CA校验的时候，因为common name一样，会被认为是自签名证书。</p> 
<blockquote> 
 <p>Ignoring -days; not generating a certificate<br> You are about to be asked to enter information that will be incorporated<br> into your certificate request.<br> What you are about to enter is what is called a Distinguished Name or a DN.<br> There are quite a few fields but you can leave some blank<br> For some fields there will be a default value,<br> If you enter ‘.’, the field will be left blank.<br> Country Name (2 letter code) [AU]:CN <mark>国家名称</mark><br> State or Province Name (full name) [Some-State]:FJ <mark>省份名称</mark><br> Locality Name (eg, city) []:QZ <mark>所属市区</mark><br> Organization Name (eg, company) [Internet Widgits Pty Ltd]:walleva <mark>组织名称</mark><br> Organizational Unit Name (eg, section) []:96<br> Common Name (e.g. server FQDN or YOUR name) []: Starry <mark>全限定域名：同时带有主机名和域名的名称，为持有者取名。</mark><br> Email Address []:chupacabra96@outlook.com<br> Please enter the following ‘extra’ attributes<br> to be sent with your certificate request<br> A challenge password []:96 <mark>挑战密码，用于安全需要的时候，会被拿出来使用，这是一个可选项</mark><br> string is too short, it needs to be at least 4 bytes long<br> A challenge password []:9696<br> An optional company name []:</p> 
</blockquote> 
<hr> 
<pre><code class="prism language-bash"><span class="token comment"># 输出证书请求的细节信息， 可以看到公钥等相关信息。</span>
openssl req -in cert.crt -noout -text
<span class="token comment"># 可以直接就生成请求的同时, 就立马生成自签名证书，不经过机构进行认证签名, 有效期为 365天, </span>
<span class="token comment"># 该证书未经过签名机构的证书的签名， 无法导入CA机构的签名证书到浏览器中被得到校验，纯粹就TLS通信测试时使用，不可用于生产环境。</span>
<span class="token comment"># 如下：</span>
<span class="token comment"># openssl req -x509 -days 365 -key cert.key -out cert.crt</span>

<span class="token comment"># 正规的流程： </span>
<span class="token comment"># 制作签名机构的私钥和签名证书(公钥)</span>
<span class="token comment"># ----&gt;签名(会对证书请求文件使用hash函数来提取摘要，然后对摘要使用私钥加密，得到签名，不影响证书内容，浏览器在验证的使用，则把签名机构的公钥证书拿出来解密，`私钥负责签名，公钥负责验证,`注意 RSA 加密方案和 RSA 签名方案是不同的)</span>
<span class="token comment"># -------&gt;制作私钥以及请求签名的证书 ---&gt;得到用于通信的证书。</span>

<span class="token comment"># 基于509证书参数， 输出证书请求的详细细节, 可以看到RSA 公钥信息。</span>
<span class="token comment"># openssl x509 -in cert.crt -noout -text </span>
<span class="token comment"># Subject Public Key Info:</span>
<span class="token comment">#           Public Key Algorithm: rsaEncryption</span>
<span class="token comment">#               RSA Public-Key: (1024 bit)</span>
<span class="token comment">#                Modulus:</span>
<span class="token comment">#                    00:b8:c9:22:14:28:5c:57:88:82:e9:0c:e6:39:b3:</span>
<span class="token comment">#                    a7:37:71:62:a4:10:89:20:18:97:5a:ec:95:49:e8:</span>
<span class="token comment">#                    64:a2:ea:bb:33:49:43:83:2d:81:2c:6f:43:6a:a8:</span>
<span class="token comment">#                    40:00:11:8c:03:9e:2b:6f:d9:94:f9:77:49:b0:97:</span>
<span class="token comment">#                    08:6a:9d:0b:cb:8f:e1:a8:3f:81:53:98:16:88:aa:</span>
<span class="token comment">#                    a8:a1:c7:80:b6:38:b5:7b:20:02:ea:d7:6a:30:14:</span>
<span class="token comment">#                    5b:1d:c9:b1:63:63:07:36:fc:55:51:e8:6b:10:44:</span>
<span class="token comment">#                    8e:f7:a8:06:83:a6:61:a1:1a:d8:24:8a:d2:dd:d6:</span>
<span class="token comment">#                    b0:f9:72:e4:9a:4f:13:7e:5d</span>
<span class="token comment">#                Exponent: 65537 (0x10001)</span>
<span class="token comment">##########################################################################</span>
</code></pre> 
<h6><a id="_244"></a>第二步，创建用于签名的证书给证书请求的文件做签名</h6> 
<p>给证书请求的文件进行签名有两种，经过验证都可以使用。<br> <strong>第一种：创建私有CA证书进行签名的方式</strong></p> 
<pre><code class="prism language-bash"><span class="token comment">#  创建私有CA证书，使用该 CA证书 给证书请求文件进行签名</span>
<span class="token comment">#  openssl genrsa -des3 -out ca.key 4096  # 创建私有CA的私钥，并选择用des3 算法加密私钥。</span>
openssl genrsa -out ca.key 4096  <span class="token comment"># 创建私有CA的私钥</span>
<span class="token comment"># 生成私有CA的自签名证书，和前面的生成自签名证书，其实是一样的道理， 只是这个我们要把它当作 最顶层的签名证书。</span>
openssl req -x509 -days 365 -key ca.key -out ca.crt 
<span class="token comment"># 使用CA的私有证书和私钥进行证书请求文件的签名， 就可以得到最终的签名证书。</span>
<span class="token comment"># 个人认为这是比较简化，随性的一种实现方式。</span>
<span class="token comment"># set_serial 01 为证书设置序列号。</span>
openssl x509 -req -days 365  -CA ca.crt -CAkey ca.key -set_serial 01 -in cert.csr  -out cert_1.crt 
<span class="token comment"># 对生成的证书进行校验，看是否能正常通过校验。</span>
openssl verify -CAfile ca.crt cert_1.crt 
</code></pre> 
<p><strong>第二种：该方式是比较正规的方式， 将会建立一个完整的CA机构目录，进行统一管理。</strong></p> 
<pre><code class="prism language-bash">openssl genrsa -out ca.key <span class="token comment"># 创建私有CA的私钥，前面已创建CA私钥的话，可以省略。</span>
openssl req -new -x509 -days 365 -key ca.key -out ca.crt <span class="token comment">#生成私有CA的自签名证书，前面已创建CA证书的话，可以省略。</span>

<span class="token comment"># 利用CA签名证书</span>
<span class="token comment"># openssl 将会指定默认的openssl.cnf 文件，来获取一些默认的参数配置。</span>
openssl ca -keyfile ca.key -cert ca.crt -in cert.csr -out cert_2.crt -config /usr/local/openssl/openssl.cnf
<span class="token comment"># 以上命令会报错如下： </span>
<span class="token comment"># Using configuration from /usr/local/ssl/openssl.cnf</span>
<span class="token comment"># 1995927552:error:02001002:system library:fopen:No such file</span>
<span class="token comment"># ordirectory:crypto/bio/bss_file.c:69:fopen('./demoCA/index.txt','r')</span>
<span class="token comment"># 1995927552:error:2006D080:BIO routines:BIO_new_file:no such file:crypto/bio/bss_file.c:76:</span>
<span class="token function">mkdir</span> -p demoCA/newcerts
<span class="token function">touch</span> ./demoCA/index.txt
<span class="token function">touch</span> ./demoCA/serial
<span class="token keyword">echo</span> 01 <span class="token operator">&gt;</span> demoCA/serial  <span class="token comment"># 跟前面的方法一样，要设置证书的序列号。</span>
<span class="token comment"># 对生成的证书进行校验，看是否能正常通过校验。</span>
openssl verify -CAfile ca.crt cert_2.crt  cert_1.crt
<span class="token comment"># 成功的话会出现以下log报告：</span>
<span class="token comment"># cert_2.crt: OK</span>
<span class="token comment"># cert_1.crt: OK</span>
</code></pre> 
<p>**进行校验的时候， 可能会碰到如下问题： **</p> 
<blockquote> 
 <p><strong>Q: unable to load certificate？The countryName field is different</strong><br> A: 因为个人证书请求和CA的签名证书的 countryName, localityName 等不一致， openssl.cnf有要求这几个值要一样，才能正确签名和校验<br> <strong>Q:error 18 at 0 depth lookup: self signed certificate</strong><br> A: 因为个人证书请求和CA证书 中的 commonName 的值一样， 在证书校验的时候，就会当作是自签名证书，无法校验，回顾一下自签名证书的命令，确实就是这样，生成证书请求的同时，便会同时生成证书文件, 在这个时候，证书中的持有者和颁发者是一样的。</p> 
</blockquote> 
<h5><a id="223_openssl_289"></a>2.2.3 利用openssl加密文件</h5> 
<p>Openssl除了进行加密证书的制作，<strong>也可以加密，解密私密的文件。</strong><br> <code>notice： Openssl 设计得很巧妙， 比如想实现 rsa， aes-256-cbc算法相关操作，先设置算法名称，参数前没有‘-’符号，然后再配置该算法名称的具体小参数。 当先选择算法名称之后， 通过 openssl aes-256-cbc -help， 可以查看到其他的配套的功能参数。 同样的， 当先选择其他参数，比如rsautl， 通过openssl rsautl -help，可以查看到该大参数下对应的小参数名称。</code></p> 
<p><strong>1. 对称加密，比如aes， dh加密算法， 一般理解为加密和解密都使用相同的密钥，</strong><br> DH加密算法也是对称加密算法， 客户端和服务器可以通过算法得到一样的密钥， 一般用来作为TLS通信中的密钥交换算法。</p> 
<pre><code class="prism language-bash"><span class="token comment"># -e 表示加密输入文件到输出文件上</span>
openssl aes-256-cbc -e -in des.txt -out enc.txt
<span class="token comment"># -d 表示解密输入文件到输出文件上</span>
openssl aes-256-cbc -d -in enc.txt -out des.txt
</code></pre> 
<p><strong>2. 非对称加密，比如rsa算法， 一般理解为公钥加密，私钥解密.</strong></p> 
<pre><code class="prism language-bash"><span class="token comment"># 生成rsa密钥</span>
<span class="token function">sudo</span> openssl genrsa -out rsa_pri.key
<span class="token function">sudo</span> openssl rsa -help
<span class="token comment"># 通过私钥得到公钥</span>
<span class="token function">sudo</span> openssl rsa -in rsa_pri.key -pubout -out rsa_pub.key
<span class="token comment"># 利用pubin参数，输入公钥来加密明文</span>
<span class="token function">sudo</span> openssl rsautl -encrypt -in plaintext -out ciphertext -inkey rsa_pub.key -pubin
<span class="token comment"># 使用私钥来解密密文。</span>
<span class="token function">sudo</span> openssl rsautl -decrypt -in ciphertext -out plaintext -inkey rsa_pri.key 
<span class="token function">history</span>
</code></pre> 
<h5><a id="224__nginxhttps_316"></a>2.2.4 配置nginx的https服务器</h5> 
<pre><code class="prism language-conf">    #HTTPS server

    server {
        listen       443 ssl;
        server_name  localhost;

        ssl_certificate      /usr/local/nginx/tls_file/cert_sign.crt;
        ssl_certificate_key  /usr/local/nginx/tls_file/cert.key;

        ssl_session_cache    shared:SSL:1m;
        ssl_session_timeout  5m;

        ssl_ciphers  HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers  on;

        location / {
            root   html;
            index  index.html index.htm;
        }
    }
################################################
</code></pre> 
<h5><a id="225__https_340"></a>2.2.5 也可以配置https服务器来支持某一个具体的加密套件(在学习密钥交换的时候，很有用)</h5> 
<pre><code class="prism language-conf"> server {
        listen       443 ssl;
        server_name  localhost;

        ssl_certificate      /usr/local/nginx/tls_file/cert_2.crt;
        ssl_certificate_key  /usr/local/nginx/tls_file/cert.key;

        ssl_session_cache    shared:SSL:1m;
        ssl_session_timeout  5m;

        #ssl_ciphers AES256-GCM-SHA384;
        ssl_ciphers ECDHE-RSA-CHACHA20-POLY1305;
        #ssl_ciphers HIGH:!aNULL:!MD5;
        ssl_protocols  TLSv1 TLSv1.1 TLSv1.2;
        ssl_prefer_server_ciphers  on;

        location / {
            root   html;
            index  index.html index.htm;
        }
    }
</code></pre> 
<p>配置完之后， 重启nginx，注意一旦有报什么错误警告，可以通过nginx记录的log 进行分析，<br> 此时通过浏览器访问的时候，会出现以下警告。<br> <img src="https://images2.imgbox.com/a9/6d/vDZBsgPg_o.png" alt="在这里插入图片描述"><br> 这是因为浏览器中保存的CA证书机构无法校验我们下发的证书是否有效， 因为用来签名的CA机构也是我们自己创建的， 正常的生产环境中， 证书请求的文件要让正规机构去签名，才能正确工作， 此处测试，先忽略该错误。<br> 为了消除上述的错误的话， 可以手动在浏览器中导入私有的签名机构的证书，方便浏览器进行 校验。<br> <code>notice: 常规的生产环境不可随意导入他人的CA证书。</code><br> 将刚刚创建的CA机构的证书导出到本地。<br> <img src="https://images2.imgbox.com/9e/13/bxRvbGp1_o.png" alt="在这里插入图片描述"><br> 打开浏览器的证书管理，将其添加到受信任的证书机构中。<br> <img src="https://images2.imgbox.com/94/0c/gAEZRBfC_o.png" alt="在这里插入图片描述"><br> 这样就可以进行证书的检验，但是，有一点疑问是我的google 浏览器会一直报以下错误：<br> 一直说我的CA机构无效， 关于这一点，就没去追了， 有了解的伙伴可以在文章下方留言。<br> <img src="https://images2.imgbox.com/97/fc/W0RrIoon_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <h2><a id="_377"></a>易混淆点：</h2> 
 <p>同样的X.509证书,可能有不同的编码格式,目前有以下两种编码格式.<br> <strong>PEM</strong> - Privacy Enhanced Mail,打开看文本格式,以"-----BEGIN…"开头, "-----END…"结尾,内容是BASE64编码.<br> <mark>查看PEM格式证书的信息:openssl x509 -in certificate.pem -text -noout</mark><br> Apache和<em>NIX服务器偏向于使用这种编码格式.<br> <strong>DER</strong> - Distinguished Encoding Rules,打开看是二进制格式,不可读.<br> <mark>查看DER格式证书的信息:openssl x509 -in certificate.der -inform der -text -noout</mark><br> Java和Windows服务器偏向于使用这种编码格式.<br> PEM转为DER: <code>openssl x509 -in cert.crt -outform der -out cert.der</code><br> DER转为PEM : <code>openssl x509 -in cert.crt -inform der -outform pem -out cert.pem</code><br> 以下名称，我一般用来作为文件的后缀，以便更好地区分是什么内容的文件。<br> <strong>CRT</strong> - CRT应该是certificate的三个字母,其实还是证书的意思,常见于</em>NIX系统,有可能是PEM编码,也有可能是DER编码,大多数应该是PEM编码,相信你已经知道怎么辨别.<br> <strong>CER</strong> - 还是certificate,还是证书,常见于Windows系统,同样的,可能是PEM编码,也可能是DER编码,大多数应该是DER编码.<br> <strong>KEY</strong> - 通常用来存放一个公钥或者私钥,并非X.509证书,编码同样的,可能是PEM,也可能是DER.<br> 查看KEY的办法:openssl rsa -in mykey.key -text -noout<br> 如果是DER格式的话,同理应该这样了:openssl rsa -in mykey.key -text -noout -inform der<br> <strong>CSR</strong>- Certificate Signing Request, 即证书签名请求,这个并不是证书,而是向权威证书颁发机构获得签名证书的申请,其核心内容是一个公钥(当然还附带了一些别的信息),在生成这个申请的时候,同时也会生成一个私钥,私钥要自己保管好.做过iOS APP的朋友都应该知道是怎么向苹果申请开发者证书的吧.</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f2f9862877aa1c5d8b130246f3b9a9fe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MobaXterm不能上传下载文件的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/11143eb995c37fed62c8a0e88921c9ba/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">销售需求丨购物篮分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>