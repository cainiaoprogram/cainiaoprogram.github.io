<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>R语言学习(五)——聚类分析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="R语言学习(五)——聚类分析" />
<meta property="og:description" content="什么是聚类分析 聚类是一个将数据集划分为若干组（class）或类（cluster）的过程，并使得同一个组内的数据对象具有较高的相似度，而不同组中的数据对象是不相似的。
聚类与分类的区别：
聚类是一 种无监督的学习方法。与分类不同，它不依赖于事先确定的数据类别和标有数据类别的学习训练样本集合。
聚类是观察式学习，而不是示例式学习。
聚类分析的典型应用
在商务上，聚类能帮助市场分析人员从客户基本库中发现不同的客户群，并且用购买模式来刻画不同的客户群的特征。在生物学上，聚类能用于推导植物和动物的分类，对基因进行分类，获得对种群中固有结构的认识。聚类在地球观测数据库中相似地区的确定，汽车保险单持有者的分组，及根据房子的类型、价值和地理位置对一个城市中房屋的分组上也可以发挥作用。聚类也能用于对Web上的文档进行分类，以发现信息。
什么是好的聚类 一个好的聚类方法将产生以下的高聚类：
最大化类内的相似性最小化类间的相似性 聚类结果的质量依靠所使用度量的相似性和它的执行。
聚类方法的质量也可以用它发现一些或所有隐含模式的能力来度量。
聚类分析中的数据类型 基本的数据结构
数据矩阵
数据矩阵是一个对象—属性结构，由n个对象组成，如：人；每个对象利用p个属性加以描述，如：年龄、身高、体重等。数据矩阵采用关系表形式或n*p矩阵来表示：
相异度矩阵
相异度矩阵（又称差异矩阵）是一个对象—对象结构，存放n个对象两两之间的近似性（差异性），采用n*n的矩阵形式表示：
其中，d(i,j)表示对象i和对象j之间的差异（或不相似程度）。通常d(i,j)为一个非负数；当对象i和对象j非常相似或彼此“接近”时，该数值接近0；该数值越大，就表示对象i和对象j越不相似，由于有d(i,j)=d(j,i)且d(i,i)=0。所以，矩阵呈现出上三角或下三角的形式。 注意：
数据矩阵通常称为双模（two-mode）矩阵：行和列分布表示不同的实体；相异度矩阵常被称为单模（one-mode）矩阵：行和列表示同一实体。许多聚类算法都是以相异度矩阵为基础计算的，所以如果数据是以数据矩阵的形式给出的，则需要首先转换为相异度矩阵，才可以利用聚类算法来处理。 区间标度变量
区间标度变量（又称间隔数值变量）为基本呈直线比例的连续变量，如：重量、高度和温度等。
为什么要标准化？ 通常，选用的度量单位将直接影响聚类分析的结果，如：将高度的度量单位由“米”变为“英尺”，或将重量的单位由“千克”变为“英镑”，可能会产生非常不同的聚类结构。一般来说，度量单位越小，变量可能的值域越大，对聚类结果的影响也越大。因此，为避免对度量单位选择的依赖，数据应当标准化。
度量值的标准化 为了实现标准化，一种方法是将初始测量值转换为无单位变量。给定一个属性变量f，可用如下公式对其进行标准化：
计算平均的绝对偏差
计算标准化测量（z-score）
在标准化之后，或在无需标准化的特定应用中，由间隔数值所描述对象之间的差异（或相似）程度可以通过计算相应两个对象之间距离来确定，最常用的距离计算公式是欧氏距离（Euclidean distance），其具体公式如下：
R语言中求欧式距离
使用dist()函数
dist(x, method = &#34;euclidean&#34;, diag = FALSE, upper = FALSE, p = 2) #x是样本矩阵或者数据框。 method表示计算哪一种距离： euclidean 欧几里德距离，即平方再开方。 maximum 切比雪夫距离 manhattan 绝对值距离 canberra Lance 距离 minkowski 明科夫斯基距离，使用时要指定p值 binary 定性变量距离. 例：
A的身高180cm，年龄25岁，有1万存款
B的身高166cm，年龄30，有5万存款
C的身高170cm，年龄45，有20万存款
计算A、B、C的距离
将每个人的数据表示成向量
&gt; a&lt;-c(180,25,1) &gt; b&lt;-c(166,30,5) &gt; c&lt;-c(170,45,20) 形成数据矩阵" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8849ad59a5a1eae4143e2899c7b1e1dd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-27T22:09:39+08:00" />
<meta property="article:modified_time" content="2018-11-27T22:09:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">R语言学习(五)——聚类分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>什么是聚类分析</h3> 
<p>聚类是一个将数据集划分为若干组（class）或类（cluster）的过程，并使得同一个组内的数据对象具有较高的相似度，而不同组中的数据对象是不相似的。</p> 
<p><strong>聚类与分类的区别：</strong><br> 聚类是一 种无监督的学习方法。与分类不同，它不依赖于事先确定的数据类别和标有数据类别的学习训练样本集合。<br> 聚类是观察式学习，而不是示例式学习。</p> 
<p><strong>聚类分析的典型应用</strong><br> 在商务上，聚类能帮助市场分析人员从客户基本库中发现不同的客户群，并且用购买模式来刻画不同的客户群的特征。在生物学上，聚类能用于推导植物和动物的分类，对基因进行分类，获得对种群中固有结构的认识。聚类在地球观测数据库中相似地区的确定，汽车保险单持有者的分组，及根据房子的类型、价值和地理位置对一个城市中房屋的分组上也可以发挥作用。聚类也能用于对Web上的文档进行分类，以发现信息。</p> 
<h3><a id="_10"></a>什么是好的聚类</h3> 
<p>一个好的聚类方法将产生以下的高聚类：</p> 
<ul><li>最大化类内的相似性</li><li>最小化类间的相似性</li></ul> 
<p>聚类结果的质量依靠所使用度量的相似性和它的执行。<br> 聚类方法的质量也可以用它发现一些或所有隐含模式的能力来度量。</p> 
<h3><a id="_19"></a>聚类分析中的数据类型</h3> 
<p><strong>基本的数据结构</strong></p> 
<ol><li>数据矩阵<br> 数据矩阵是一个对象—属性结构，由n个对象组成，如：人；每个对象利用p个属性加以描述，如：年龄、身高、体重等。数据矩阵采用关系表形式或n*p矩阵来表示：<br> <img src="https://images2.imgbox.com/5a/3b/Uy6OD663_o.png" alt="在这里插入图片描述"></li><li>相异度矩阵<br> 相异度矩阵（又称差异矩阵）是一个对象—对象结构，存放n个对象两两之间的近似性（差异性），采用n*n的矩阵形式表示：<br> <img src="https://images2.imgbox.com/cc/fd/RtHJ5Lhi_o.png" alt="在这里插入图片描述"><br> 其中，d(i,j)表示对象i和对象j之间的差异（或不相似程度）。通常d(i,j)为一个非负数；当对象i和对象j非常相似或彼此“接近”时，该数值接近0；该数值越大，就表示对象i和对象j越不相似，由于有d(i,j)=d(j,i)且d(i,i)=0。所以，矩阵呈现出上三角或下三角的形式。</li></ol> 
<p>注意：</p> 
<ol><li>数据矩阵通常称为双模（two-mode）矩阵：行和列分布表示不同的实体；</li><li>相异度矩阵常被称为单模（one-mode）矩阵：行和列表示同一实体。</li><li>许多聚类算法都是以相异度矩阵为基础计算的，所以如果数据是以数据矩阵的形式给出的，则需要首先转换为相异度矩阵，才可以利用聚类算法来处理。</li></ol> 
<p><strong>区间标度变量</strong></p> 
<p>区间标度变量（又称间隔数值变量）为基本呈直线比例的连续变量，如：重量、高度和温度等。</p> 
<ul><li>为什么要标准化？</li></ul> 
<p>通常，选用的度量单位将直接影响聚类分析的结果，如：将高度的度量单位由“米”变为“英尺”，或将重量的单位由“千克”变为“英镑”，可能会产生非常不同的聚类结构。一般来说，度量单位越小，变量可能的值域越大，对聚类结果的影响也越大。因此，为避免对度量单位选择的依赖，数据应当标准化。</p> 
<ul><li>度量值的标准化</li></ul> 
<p>为了实现标准化，一种方法是将初始测量值转换为无单位变量。给定一个属性变量f，可用如下公式对其进行标准化：</p> 
<ol><li>计算平均的绝对偏差<br> <img src="https://images2.imgbox.com/14/20/C1EDWPdm_o.png" alt="在这里插入图片描述"></li><li>计算标准化测量（z-score）<br> <img src="https://images2.imgbox.com/d3/2b/EAbRqBd2_o.png" alt="在这里插入图片描述"><br> 在标准化之后，或在无需标准化的特定应用中，由间隔数值所描述对象之间的差异（或相似）程度可以通过计算相应两个对象之间距离来确定，最常用的距离计算公式是<strong>欧氏距离（Euclidean distance）</strong>，其具体公式如下：<br> <img src="https://images2.imgbox.com/d6/9e/1n3V4Muq_o.png" alt="在这里插入图片描述"></li></ol> 
<p><em><strong>R语言中求欧式距离</strong></em><br> 使用dist()函数</p> 
<pre><code>dist(x, method = "euclidean", diag = FALSE, upper = FALSE, p = 2)
#x是样本矩阵或者数据框。
method表示计算哪一种距离：
euclidean                欧几里德距离，即平方再开方。
maximum                  切比雪夫距离
manhattan                绝对值距离
canberra                 Lance 距离
minkowski                明科夫斯基距离，使用时要指定p值
binary                   定性变量距离.
</code></pre> 
<p>例：<br> A的身高180cm，年龄25岁，有1万存款<br> B的身高166cm，年龄30，有5万存款<br> C的身高170cm，年龄45，有20万存款<br> 计算A、B、C的距离</p> 
<p>将每个人的数据表示成向量</p> 
<pre><code>&gt; a&lt;-c(180,25,1) 
&gt; b&lt;-c(166,30,5) 
&gt; c&lt;-c(170,45,20)
</code></pre> 
<p>形成数据矩阵</p> 
<pre><code>&gt; mydata&lt;-rbind(a,b,c)
</code></pre> 
<p>为避免对度量单位选择的依赖，将数据进行标准化</p> 
<pre><code>&gt; mydatas&lt;-scale(mydata)
</code></pre> 
<p>求欧式距离</p> 
<pre><code>&gt; mydist&lt;-dist(mydatas,method="euclidean")
</code></pre> 
<p>另一个常用的距离计算方法是<strong>曼哈顿距离（Manhattan distance）</strong>，其计算公式如下：<br> <img src="https://images2.imgbox.com/aa/26/Oo3GCQKM_o.png" alt="在这里插入图片描述"><br> <strong>Minkowski 距离</strong>是欧氏距离和曼哈顿距离的一个推广，它的计算公式如下：<br> <img src="https://images2.imgbox.com/1b/ae/cjsQK2lU_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/8f/de/PXLjoXtE_o.png" alt="在这里插入图片描述"></p> 
<p><strong>二元变量</strong></p> 
<ul><li>什么是二元变量</li></ul> 
<p>一个二元变量只有两个状态：0或者1。其中0代表变量所表示的状态不存在；1则代表相应的状态存在。<br> 如：给定变量smoker，用以描述一个病人是否吸烟的情况，如用smoker为1表示病人吸烟；若smoker为0表示病人不吸烟。</p> 
<ul><li>二元变量的相异度计算</li></ul> 
<p>利用差异矩阵法。如果假设所有的二元变量有相同的权重，则可以得到一个两行两列（2*2）的条件表，如下：<br> <img src="https://images2.imgbox.com/83/60/wQYAiOrN_o.png" alt="在这里插入图片描述"><br> 其中：<br> q表示在对象i和对象j中均取1的二值变量个数；<br> r表示在对象i取1但对象j中取0的二值变量个数；<br> s表示在对象i中取0而在对象j中取1的二值变量个数；<br> t则表示在对象i和对象j中均取0的二值变量个数。<br> 二值变量的总数为p，则：p=q+r+s+t。</p> 
<p><em><strong>R语言中二元变量的相异度计算</strong></em><br> 详见我的另一篇文章：R语言——assignment3</p> 
<h3><a id="_124"></a>聚类算法</h3> 
<ul><li>系统聚类（层次聚类）</li><li>基于划分的k-means聚类</li></ul> 
<p><strong>系统聚类</strong><br> 系统聚类的基本思想是将距离相近的样品（或变量）先聚成类，距离相远的后聚成类，过程一直进行下去，每个样品（或变量）总能聚到合适的类中。</p> 
<p>系统聚类过程是：假设总共有n个样品（或变量）<br> 第一步：将每个样品（或变量）独自聚成一类，共有n类；<br> 第二步：根据所确定的样品（或变量）“距离”公式，把距离较近的两个样品（或变量）聚合为一类，其它的样品（或变量）仍各自聚为一类，共聚成n-1类；<br> 第三步：将“距离”最近的两个类进一步聚成一类，共聚成n-2类；……，以上步骤一直进行下去，最后将所有的样品（或变量）全聚成一类。</p> 
<p>这时，有两个关键问题:</p> 
<ul><li>类与类间的距离如何衡量?</li><li>如何选择分几类呢?</li></ul> 
<p>类间距离<br> 主要有最短距离法、最长距离法、类平均法、重心法。<br> 它们的归类步骤基本上是一致的，主要差异是类间距离的计算方法不同。</p> 
<ol><li>最短距离法<br> 定义类与类之间的距离为两类中最近样品(指标)的距离，即为：<br> <img src="https://images2.imgbox.com/9d/a0/vkNWqmZK_o.png" alt="在这里插入图片描述"></li><li>最长距离法<br> 定义类与类之间的距离为两类最远样品的距离，即为：<br> <img src="https://images2.imgbox.com/bc/06/hdQPyGYN_o.png" alt="在这里插入图片描述"></li><li>类平均法<br> 定义类与类之间的距离为两类中任意两样品的距离的平均。<br> <img src="https://images2.imgbox.com/c3/07/jT87LoQs_o.png" alt="在这里插入图片描述"></li><li>重心法<br> 定义类间距离为两类中心（各类样品的均值）的距离。<br> <img src="https://images2.imgbox.com/08/87/slwOF4GU_o.png" alt="在这里插入图片描述"></li></ol> 
<p>聚类分析的步骤<br> <img src="https://images2.imgbox.com/48/47/aVz5s4Hu_o.png" alt="在这里插入图片描述"><br> <em><strong>R语言下系统（层次）聚类</strong></em><br> 使用系统聚类法对如下几个数进行聚类： 1,8,4,5,9,12<br> 将这几个数定义为一组向量</p> 
<pre><code>&gt; mydata&lt;-c(1,8,4,5,9,12)
</code></pre> 
<p>使用dist()函数计算变量间距离，形成相异度矩阵</p> 
<pre><code>&gt; mydist&lt;-dist(mydata,method="euclidean")
</code></pre> 
<p>使用hclust()进行聚类</p> 
<pre><code>&gt; mymodel&lt;-hclust(mydist)
</code></pre> 
<p>画出聚类模型图</p> 
<pre><code>&gt; plot(mymodel,labels=mydata)
</code></pre> 
<p>得到下图<br> <img src="https://images2.imgbox.com/3b/c2/gexFhihY_o.png" alt="在这里插入图片描述"><br> 指定聚为三类，并显示结果</p> 
<pre><code>&gt; result&lt;-cutree(mymodel,3)
&gt; mydata[which(result==3)]
[1] 12
</code></pre> 
<p><strong>K-平均（k-means）聚类算法</strong><br> K-平均（k-means）算法以k为参数，把n个对象分为k个簇，以使簇内对象具有较高的相似度，而簇间的相似度较低。<br> 相似度的计算根据一个簇中对象的平均值（被看作簇的重心）来进行。</p> 
<p>k-means算法的基本思想：<br> 首先，随机的选择k个对象，每个对象初始的代表了一个簇的平均值；<br> 对剩余的每个对象，根据其与各个簇中心的距离，将它赋给最近的簇；<br> 然后重新计算每个簇的平均值。这个过程不断重复，直到准则函数收敛。</p> 
<p>通常选择均方差作为收敛准则函数：<br> <img src="https://images2.imgbox.com/6d/9e/YXcNGuNL_o.png" alt="在这里插入图片描述"><br> k-means算法的特点：<br> 只适用于聚类均值有意义的场合，在某些应用中，如：数据集中包含符号属性时，直接应用k-means算法就有问题；<br> 用户必须事先指定k的个数；<br> 对噪声和孤立点数据敏感，少量的该类数据能够对聚类均值起到很大的影响。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1acd0113a69a1e59c667836f7f20498d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">android蚂蚁金服支付宝支付集成步骤</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c0e1038224da092d1e270bf4638422c5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Intellij关闭双击shift打开全局搜索</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>