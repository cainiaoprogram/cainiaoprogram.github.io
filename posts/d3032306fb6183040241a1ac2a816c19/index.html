<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>nginx 限流配置是如何做到的? - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="nginx 限流配置是如何做到的?" />
<meta property="og:description" content="限流算法 1、令牌桶算法
算法思想是：
令牌以固定速率产生，并缓存到令牌桶中； 令牌桶放满时，多余的令牌被丢弃； 请求要消耗等比例的令牌才能被处理； 令牌不够时，请求被缓存。 2、漏桶算法
算法思想是：
水（请求）从上方倒入水桶，从水桶下方流出（被处理）； 来不及流出的水存在水桶中（缓冲），以固定速率流出； 水桶满后水溢出（丢弃）。
这个算法的核心是：缓存请求、匀速处理、多余的请求直接丢弃。
相比漏桶算法，令牌桶算法不同之处在于它不但有一只“桶”，还有个队列，这个桶是用来存放令牌的，队列才是用来存放请求的。
从作用上来说，漏桶和令牌桶算法最明显的区别就是是否允许突发流量(burst)的处理，漏桶算法能够强行限制数据的实时传输（处理）速率，对突发流量不做额外处理；而令牌桶算法能够在限制数据的平均传输速率的同时允许某种程度的突发传输。
Nginx按请求速率限速模块使用的是漏桶算法，即能够强行保证请求的实时处理速度不会超过设置的阈值。
Nginx官方版本限制IP的连接和并发分别有两个模块：
limit_req_zone 用来限制单位时间内的请求数，即速率限制,采用的漏桶算法 “leaky bucket”。
limit_req_conn 用来限制同一时间连接数，即并发限制。
3、nginx参数配置
limit_req_zone 参数配置
Syntax:	limit_req zone=name [burst=number] [nodelay]; Default:	— Context:	http, server, location 第一个参数：$binary_remote_addr 表示通过remote_addr这个标识来做限制，“binary_”的目的是缩写内存占用量，是限制同一客户端ip地址。
第二个参数：zone=one:10m表示生成一个大小为10M，名字为one的内存区域，用来存储访问的频次信息。
第三个参数：rate=1r/s表示允许相同标识的客户端的访问频次，这里限制的是每秒1次，还可以有比如30r/m的。
limit_req zone=one burst=5 nodelay;
第一个参数：zone=one 设置使用哪个配置区域来做限制，与上面limit_req_zone 里的name对应。
第二个参数：burst=5，重点说明一下这个配置，burst爆发的意思，这个配置的意思是设置一个大小为5的缓冲区当有大量请求（爆发）过来时，超过了访问频次限制的请求可以先放到这个缓冲区内。
第三个参数：nodelay，如果设置，超过访问频次而且缓冲区也满了的时候就会直接返回503，如果没有设置，则所有请求会等待排队。
eg:
http { limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s; server { location /search/ { limit_req zone=one burst=5 nodelay; } } 当服务器由于limit被限速或缓存时，配置写入日志。延迟的记录比拒绝的记录低一个级别。例子：limit_req_log_level notice延迟的的基本是info。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d3032306fb6183040241a1ac2a816c19/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-24T09:25:53+08:00" />
<meta property="article:modified_time" content="2021-08-24T09:25:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">nginx 限流配置是如何做到的?</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>限流算法</h4> 
</div> 
<p></p> 
<p><strong>1、令牌桶算法</strong><br> <img src="https://images2.imgbox.com/e6/dc/YvrL6RCl_o.png" alt="在这里插入图片描述"><br> 算法思想是：</p> 
<pre><code>令牌以固定速率产生，并缓存到令牌桶中；
令牌桶放满时，多余的令牌被丢弃；
请求要消耗等比例的令牌才能被处理；
令牌不够时，请求被缓存。
</code></pre> 
<p><strong>2、漏桶算法</strong><br> <img src="https://images2.imgbox.com/6c/b3/WlX3DFSn_o.png" alt="在这里插入图片描述"><br> 算法思想是：</p> 
<blockquote> 
 <p>水（请求）从上方倒入水桶，从水桶下方流出（被处理）； 来不及流出的水存在水桶中（缓冲），以固定速率流出； 水桶满后水溢出（丢弃）。<br> 这个算法的核心是：缓存请求、匀速处理、多余的请求直接丢弃。<br> 相比漏桶算法，令牌桶算法不同之处在于它不但有一只“桶”，还有个队列，这个桶是用来存放令牌的，队列才是用来存放请求的。<br> 从作用上来说，漏桶和令牌桶算法最明显的区别就是是否允许突发流量(burst)的处理，漏桶算法能够强行限制数据的实时传输（处理）速率，对突发流量不做额外处理；而令牌桶算法能够在限制数据的平均传输速率的同时允许某种程度的突发传输。</p> 
</blockquote> 
<p>Nginx按请求速率限速模块使用的是漏桶算法，即能够强行保证请求的实时处理速度不会超过设置的阈值。</p> 
<p>Nginx官方版本限制IP的连接和并发分别有两个模块：</p> 
<blockquote> 
 <p>limit_req_zone 用来限制单位时间内的请求数，即速率限制,采用的漏桶算法 “leaky bucket”。<br> limit_req_conn 用来限制同一时间连接数，即并发限制。</p> 
</blockquote> 
<p><strong>3、nginx参数配置</strong><br> <strong>limit_req_zone 参数配置</strong></p> 
<pre><code class="prism language-powershell">Syntax:	limit_req zone=name <span class="token namespace">[burst=number]</span> <span class="token namespace">[nodelay]</span><span class="token punctuation">;</span>
Default:	—
Context:	http<span class="token punctuation">,</span> server<span class="token punctuation">,</span> location
</code></pre> 
<p>第一个参数：$binary_remote_addr 表示通过remote_addr这个标识来做限制，“binary_”的目的是缩写内存占用量，是限制同一客户端ip地址。<br> 第二个参数：zone=one:10m表示生成一个大小为10M，名字为one的内存区域，用来存储访问的频次信息。<br> 第三个参数：rate=1r/s表示允许相同标识的客户端的访问频次，这里限制的是每秒1次，还可以有比如30r/m的。<br> limit_req zone=one burst=5 nodelay;</p> 
<p>第一个参数：zone=one 设置使用哪个配置区域来做限制，与上面limit_req_zone 里的name对应。<br> 第二个参数：burst=5，重点说明一下这个配置，burst爆发的意思，这个配置的意思是设置一个大小为5的缓冲区当有大量请求（爆发）过来时，超过了访问频次限制的请求可以先放到这个缓冲区内。<br> 第三个参数：nodelay，如果设置，超过访问频次而且缓冲区也满了的时候就会直接返回503，如果没有设置，则所有请求会等待排队。</p> 
<p>eg:</p> 
<pre><code class="prism language-powershell">http <span class="token punctuation">{<!-- --></span>
    limit_req_zone <span class="token variable">$binary_remote_addr</span> zone=one:10m rate=1r<span class="token operator">/</span>s<span class="token punctuation">;</span>
    server <span class="token punctuation">{<!-- --></span>
        location <span class="token operator">/</span>search<span class="token operator">/</span> <span class="token punctuation">{<!-- --></span>
            limit_req zone=one burst=5 nodelay<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>  
</code></pre> 
<p>当服务器由于limit被限速或缓存时，配置写入日志。延迟的记录比拒绝的记录低一个级别。例子：limit_req_log_level notice延迟的的基本是info。</p> 
<pre><code class="prism language-powershell">Syntax:	limit_req_status code<span class="token punctuation">;</span>
Default:	
limit_req_status 503<span class="token punctuation">;</span>
Context:	http<span class="token punctuation">,</span> server<span class="token punctuation">,</span> location
</code></pre> 
<p>设置拒绝请求的返回值。值只能设置 400 到 599 之间。</p> 
<pre><code>	 **ngx_http_limit_conn_module 参数配置**
	 这个模块用来限制单个IP的请求数。并非所有的连接都被计数。只有在服务器处理了请求并且已经读取了整个请求头时，连接才被计数。
</code></pre> 
<pre><code class="prism language-powershell">Syntax:	limit_conn zone number<span class="token punctuation">;</span>
Default:	—
Context:	http<span class="token punctuation">,</span> server<span class="token punctuation">,</span> location
</code></pre> 
<pre><code class="prism language-powershell">limit_conn_zone <span class="token variable">$binary_remote_addr</span> zone=perip:10m<span class="token punctuation">;</span>
limit_conn_zone <span class="token variable">$server_name</span> zone=perserver:10m<span class="token punctuation">;</span>

server <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    limit_conn perip 10<span class="token punctuation">;</span>
    limit_conn perserver 100<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>可以配置多个limit_conn指令。例如，以上配置将限制每个客户端IP连接到服务器的数量，同时限制连接到虚拟服务器的总数。</p> 
<pre><code class="prism language-powershell">Syntax:	limit_conn_zone key zone=name:size<span class="token punctuation">;</span>
Default:	—
Context:	http
</code></pre> 
<pre><code class="prism language-powershell">limit_conn_zone <span class="token variable">$binary_remote_addr</span> zone=addr:10m<span class="token punctuation">;</span>
</code></pre> 
<p>在这里，客户端IP地址作为关键。请注意，不是$ remote_addr，而是使用$ binary_remote_addr变量。 $ remote_addr变量的大小可以从7到15个字节不等。存储的状态在32位平台上占用32或64字节的内存，在64位平台上总是占用64字节。对于IPv4地址，$ binary_remote_addr变量的大小始终为4个字节，对于IPv6地址则为16个字节。存储状态在32位平台上始终占用32或64个字节，在64位平台上占用64个字节。一个兆字节的区域可以保持大约32000个32字节的状态或大约16000个64字节的状态。如果区域存储耗尽，服务器会将错误返回给所有其他请求。</p> 
<pre><code class="prism language-powershell">Syntax:	limit_conn_log_level info <span class="token punctuation">|</span> notice <span class="token punctuation">|</span> warn <span class="token punctuation">|</span> error<span class="token punctuation">;</span>
Default:	
limit_conn_log_level error<span class="token punctuation">;</span>
Context:	http<span class="token punctuation">,</span> server<span class="token punctuation">,</span> location
</code></pre> 
<p>当服务器限制连接数时，设置所需的日志记录级别。</p> 
<pre><code class="prism language-powershell">Syntax:	limit_conn_status code<span class="token punctuation">;</span>
Default:	
limit_conn_status 503<span class="token punctuation">;</span>
Context:	http<span class="token punctuation">,</span> server<span class="token punctuation">,</span> location
</code></pre> 
<p>设置拒绝请求的返回值。</p> 
<p>实际操作中：</p> 
<pre><code class="prism language-powershell">limit_req_zone <span class="token variable">$binary_remote_addr</span> zone=mylimit:10m rate=2r<span class="token operator">/</span>s<span class="token punctuation">;</span>
server <span class="token punctuation">{<!-- --></span> 
    location <span class="token operator">/</span> <span class="token punctuation">{<!-- --></span> 
        limit_req zone=mylimit<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上述规则限制了每个IP访问的速度为2r/s，并将该规则作用于根目录。如果单个IP在非常短的时间内并发发送多个请求，结果会怎样呢？<br> <img src="https://images2.imgbox.com/3f/06/L2BHZncU_o.png" alt="在这里插入图片描述"></p> 
<p>单个IP 10ms内发送6个请求<br> 我们使用单个IP在10ms内发并发送了6个请求，只有1个成功，剩下的5个都被拒绝。我们设置的速度是2r/s，为什么只有1个成功呢，是不是Nginx限制错了？当然不是，是因为Nginx的限流统计是基于毫秒的，我们设置的速度是2r/s，转换一下就是500ms内单个IP只允许通过1个请求，从501ms开始才允许通过第二个请求。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9e3b503bd770ae702a4ddcca23e39de1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于51单片机的LED显示（静态和动态显示）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/482169877134cd2639d62055a131560f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【WIN10】此用户无法登录，因为该账户当前已被禁用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>