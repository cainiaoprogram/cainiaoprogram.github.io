<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>oracle向PostgreSQL迁移 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="oracle向PostgreSQL迁移" />
<meta property="og:description" content="1. postgreSQL 没有dual 例子： oracle : select sysdate from dual; postgreSQL: select current_timestamp; 为保证程序兼容性，可创建伪视图（view ）替代： CREATE OR REPLACE VIEW dual AS SELECT NULL::&#34;unknown&#34; WHERE 1 = 1; ALTER TABLE dual OWNER TO postgres; GRANT ALL ON TABLE dual TO postgres; GRANT SELECT ON TABLE dual TO public; 必须授权public 以select 权限 2. sequence 创建和oracle一样，不需要修改创建语句。 例子：create sequence seq_test_1 INCREMENT by 1 MINVALUE 1 NO MAXVALUE start with 1 ; --NO MAXVALUE在oracle不支持 使用有区别： 1）查看序列 next 值 select nextval(&#39;seq_test_1&#39;); 2）查看序列最近使用值 select currval(&#39;seq_test_1&#39;); 3）序列重置 方式一 select setval(&#39;seq_test_1&#39;,100); select currval(&#39;seq_test_1&#39;); currval --------- 100 (1 row) select nextval(&#39;seq_test_1&#39;); nextval --------- 101 (1 row) 方式二 alter sequence seq_test_1 restart with 200; --注意这个不会修改 currval 的值 select nextval(&#39;seq_test_1&#39;); nextval --------- 200 (1 row) 另：postgreSQL支持使用以下语句查看序列属性 select * from seq_test_1; 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1610e05517f0b98045345c8e325c83e3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2015-03-11T17:16:48+08:00" />
<meta property="article:modified_time" content="2015-03-11T17:16:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">oracle向PostgreSQL迁移</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    1. postgreSQL 没有dual 
<br>     例子： 
<br>     oracle    : select sysdate from dual; 
<br>     postgreSQL: select current_timestamp; 
<br> 
<br>     为保证程序兼容性，可创建伪视图（view ）替代： 
<br> 
<br>     CREATE OR REPLACE VIEW dual AS 
<br>     SELECT NULL::"unknown" 
<br>     WHERE 1 = 1; 
<br>     ALTER TABLE dual OWNER TO postgres; 
<br>     GRANT ALL ON TABLE dual TO postgres; 
<br>     GRANT SELECT ON TABLE dual TO public; 
<br>     必须授权public 以select 权限 
<br> 
<br> 2. sequence 
<br> 创建和oracle一样，不需要修改创建语句。 
<br> 例子：create sequence seq_test_1 INCREMENT by 1 MINVALUE 1   NO MAXVALUE start with 1 ; --NO MAXVALUE在oracle不支持 
<br> 使用有区别： 
<br>   1）查看序列 next 值 
<br>       select nextval('seq_test_1'); 
<br>   2）查看序列最近使用值 
<br>       select currval('seq_test_1'); 
<br>   3）序列重置 
<br>       方式一 
<br>       select setval('seq_test_1',100); 
<br> 
<br>       select currval('seq_test_1'); 
<br>         currval 
<br>        --------- 
<br>             100 
<br>        (1 row) 
<br>        select nextval('seq_test_1'); 
<br>         nextval 
<br>        --------- 
<br>             101 
<br>        (1 row) 
<br>       方式二 
<br>       alter sequence seq_test_1 restart with 200;  --注意这个不会修改 currval 的值 
<br>       select nextval('seq_test_1'); 
<br>        nextval 
<br>       --------- 
<br>            200 
<br>        (1 row) 
<br>    另：postgreSQL支持使用以下语句查看序列属性 
<br>        select * from seq_test_1; 
<br> 
<br> 3. postgreSQL 中的||用法与其他数据库不同： 
<br> 　　select a||b from table1; 
<br> 　　当a或b其中一个为null时，该查询返回null。 
<br>     如果不希望要这个结果，可以使用COALESCE函数： 
<br>     select COALESCE(a,'')||COALESCE(b,'') from table1; 
<br> 
<br> 4. postgreSQL 一个类型转换声明一个从一种数据类型到另外一种数据类型的转换。 
<br> 
<br>     CAST ( expression AS type ) 
<br>     expression::type 
<br>     CAST语法遵循 SQL 标准；::语法是PostgreSQL历史用法。 
<br> 
<br> 5. COALESCE (expression_1, expression_2, ...,expression_n) 
<br>    依次参考各参数表达式，遇到非null值即停止并返回该值。如果所有的表达式都是空值，最终将返回一个空值。 
<br>    可以替换oracle中的nvl函数。 
<br> 
<br> 6. oracle中的MINUS 用 EXCEPT来替代 
<br> 
<br> 7. postgreSQL 在FROM子条件中字段须有列名，解决方法用AS 别名 
<br> 
<br> 8. 关于'' 
<br>     oracle                                                postgreSQL 
<br> SELECT LENGTH('') AS VALUE1 FROM DUAL                    SELECT LENGTH('') AS VALUE1 
<br> [Result]VALUE1=NULL                                      [Result]VALUE1=0 
<br> 
<br> SELECT TO_DATE('','YYYYMMDD') AS VALUE2                  SELECT TO_DATE('','YYYYMMDD') AS VALUE2 
<br> FROM DUAL 
<br> [Result]VALUE2=NULL                                      [Result]VALUE2=0001-01-01 BC 
<br> 
<br> SELECT TO_NUMBER('',1) AS VALUE3 FROM DUAL               SELECT TO_NUMBER('',1) AS VALUE3 
<br> [Result]VALUE3=NULL                                      [Result]不能执行 
<br> 
<br> INSERT INTO TEST(VALUE4)VALUES('')                       INSERT INTO TEST(VALUE4)VALUES('') 
<br> [Result]VALUE4=NULL (注：VALUE4字段为数值类型)           [Result]VALUE4=0 (注：VALUE4字段为数值类型) 
<br> 
<br> INSERT INTO TEST(VALUE5)VALUES('')                       INSERT INTO TEST(VALUE5)VALUES('') 
<br> [Result]VALUE5=NULL (注：VALUE5字段为字符类型)           [Result]VALUE5=''  (注：VALUE5字段为字符类型,结果为长度为零的字符串) 
<br> 
<br> INSERT INTO TEST(VALUE6)VALUES(TO_DATE('','YYYYMMDD'))   INSERT INTO TEST(VALUE6)VALUES(TO_DATE('','YYYYMMDD')) 
<br> [Result]VALUE6=NULL (注：VALUE6字段为时间类型)           [Result]VALUE6=0001-01-01 BC (注：VALUE7字段为时间类型) 
<br> 
<br> 9. 常用字符串函数 
<br> 函数                                                        返回类型    描述                                                                                示例                                结果 
<br> substring(string [from int] [for int])                         text    截取子字符串                                                                             substring('Thomas' from 2 for 3)    hom 
<br> substr(string, from [, count])                                 text    抽取子字符串。和substring(string from from for count))一样                                 substr('alphabet', 3, 2)            ph 
<br> trim([leading | trailing | both] [characters] from string)     text    从字符串string的开头/结尾/两边删除只包含 characters中字符 (缺省是空白)的最长的字符串     trim(both 'x' from 'xTomxx')        Tom 
<br> 
<br> 10. 聚集函数 
<br> avg、count、max、min、sum用法一样。 
<br> to_number to_char具体转换模式可能会有区别。 
<br> 
<br> 11. 关联查询 
<br> 
<br> ORACLE: 
<br> 
<br> 简单外连接： 
<br> SELECT COUNT(DISTINCT(A.COL1)) AS RCOUNT FROM 
<br> SCHEMA.PREFIX_TABLE1 A,SCHEMA.PREFIX_TABLE2 B 
<br> WHERE 1 = 1 
<br> AND A.COL2 = B.COL2(+) 
<br> AND A.COL3 &gt; 0 
<br> AND A.COL4 = '1' 
<br> 
<br> 复杂外连接： 
<br> SELECT COUNT(DISTINCT(A.COL1)) AS RCOUNT FROM 
<br> SCHEMA.PREFIX_TABLE1 A,SCHEMA.PREFIX_TABLE2 B,SCHEMA.PREFIX_TABLE3 C,SCHEMA.PREFIX_TABLE4 D 
<br> WHERE 1 = 1 
<br> AND A.COL2 = B.COL2 
<br> AND A.COL3 = C.COL3(+) 
<br> AND A.COL4 = D.COL4(+) 
<br> AND A.COL5 &gt; 0 
<br> AND A.COL6 = '1' 
<br> 
<br> 
<br> postgreSQL: 
<br> 
<br> 简单外连接： 
<br> select count(distinct(a.col1)) as rcount from 
<br> schema.prefix_table1 a left outer join schema.prefix_table2 b on (a.col2 = b.col2) 
<br> where 1 = 1 
<br> and a.col3 &gt; 0 
<br> and a.col4 = '1' 
<br> 
<br> 复杂外连接： 
<br> select count(distinct(a.col1)) as rcount from 
<br> schema.prefix_table1 a inner join schema.prefix_table2 b on (a.col2 = b.col2) 
<br> left outer join schema.prefix_table3 c on (a.col3 = c.col3) 
<br> left outer join schema.prefix_table4 d on (a.col4 = d.col4) 
<br> where 1 = 1 
<br> and a.col5 &gt; 0 
<br> and a.col6 = '1' 
<br> 
<br> 12. PostgresQL 中子查询较为规范，子查询结果集必须拥有alias 
<br> 
<br> ORACLE: 
<br> SELECT * FROM ( 
<br> SELECT * FROM ( 
<br> SELECT * FROM SCHEMA.PREFIX_TABLE ORDER BY COL1 
<br> ) WHERE X=1 ORDER BY COL2 
<br> ) WHERE Y=2 ORDER BY COL3 
<br> 
<br> postgreSQL: 
<br> 
<br> SELECT * FROM ( 
<br> SELECT * FROM ( 
<br> SELECT * FROM SCHEMA.PREFIX_TABLE ORDER BY COL1 ALIAS1 
<br> ) WHERE X=1 ORDER BY COL2 ALIAS2 
<br> ) WHERE Y=2 ORDER BY COL3 
<br> 
<br> 13. rownum 
<br> PostgresQL 中没有rownum ，无法 使用where rownum &lt; = X 的方法进行分页，取而代之的是limit X ，offset Y 方法, 而ORACLE 中不允许使用LIMIT X 的 方法 
<br> ORACLE: 
<br> 
<br> SELECT * FROM ( SELECT * FROM (SELECT * FROM SCHEMA.PREFIX_TABLE1 ORDER BY COL1 DESC,COL2 ASC) where ROWNUM &lt;= 50 ORDER BY COL3 ASC,COL4 DESC) 
<br> WHERE ROWNUM &lt;= 20 ORDER BY COL5 DESC,COL6 ASC; 
<br> 
<br> postgreSQL: 
<br> 
<br> select * from ( select * from (SELECT * FROM SCHEMA.PREFIX_TABLE1 ORDER BY COL1 DESC,COL2 ASC) selb order by col3 asc,col4 desc limit 50 ) sela 
<br> order by col5 desc,col6 asc limit 20; 
<br> 
<br> -- 注意！！limit 必须用于order by 之后 
<br> 
<br> -- 例：取1 到50 条数据 
<br> 
<br> select * from VOIP_FEE_RATE temp offset 0 limit 50 
<br> 
<br> 附加上 LIMIT和OFFSET 子句之后，你就可以检索原来查询语句查询出来的结果中的一部分数据行： 
<br> 
<br> SELECT select_list 
<br>     FROM table_expression 
<br>     [LIMIT { number | ALL }] [OFFSET number] 
<br> 
<br> 如果给出了一个限制计数，那么返回不超过那么多的行。 （但可能更少些，因为查询本身可能生成的行数就比较少。） LIMIT ALL和省略 LIMIT子句一样。 
<br> 
<br> OFFSET说明在开始返回行之前忽略多少行。 OFFSET 0和省略OFFSET子句是一样的。 如果OFFSET和LIMIT都出现了， 那么在计算LIMIT个行之前忽略OFFSET行。 
<br> 
<br> 如果使用LIMIT，那么用ORDER BY 子句把结果行约束成一个唯一的顺序是一个好主意。 否则你就会拿到一个不可预料的该查询的行的子集。 — 你要的可能是第十到二十行，但以什么顺序的十到二十？ 除非你声明了ORDER BY，否则顺序是不知道的。 
<br> 
<br> 查询优化器在生成查询规划的时候会考虑LIMIT，因此如果你给 LIMIT和OFFSET不同的东西，那么你很可能收到不同的规划（产生不同的行顺序）。 因此，使用不同的LIMIT/OFFSET值选择不同的查询结果的子集将生成不一致的结果， 除非你用ORDER BY强制一个可预料的顺序。这可不是臭虫； 这是一个很自然的结果，因为 SQL 没有许诺把查询的结果按照任何特定的顺序发出，除非用了ORDER BY来约束顺序。 
<br> 
<br> OFFSET 子句忽略的行仍然需要在服务器内部计算；因此，一个很大的 OFFSET 可能还是不够有效率的。 
<br> 
<br> 14. postgreSQL 没有DECODE函数 
<br> Oracle： 
<br>     SELECT DECODE(ENDFLAG,'1','A','B') ENDFLAGFROM TEST 
<br> postgreSQL： 
<br>     SELECT (CASE ENDFLAG WHEN '1' THEN 'A'ELSE 'B' END) AS ENDFLAG FROM TEST 
<br> 
<br> 15. 当前日期/时间 
<br> PostgreSQL提供许多返回当前日期和时间的函数。 这些符合 SQL 标准的函数全部都按照当前事务的开始时刻返回结果： 
<br> 
<br> CURRENT_DATE 
<br> CURRENT_TIME 
<br> CURRENT_TIMESTAMP 
<br> CURRENT_TIME(precision) 
<br> CURRENT_TIMESTAMP(precision) 
<br> LOCALTIME 
<br> LOCALTIMESTAMP 
<br> LOCALTIME(precision) 
<br> LOCALTIMESTAMP(precision) 
<br> 
<br> CURRENT_TIME和CURRENT_TIMESTAMP 返回带有时区的值；LOCALTIME和LOCALTIMESTAMP 返回不带时区的值。 
<br> 
<br> CURRENT_TIME,CURRENT_TIMESTAMP, LOCALTIME,LOCALTIMESTAMP 可以有选择地获取一个精度参数， 
<br> 该精度导致结果的秒数域园整到指定小数位。 如果没有精度参数，将给予所能得到的全部精度。 
<br> 
<br> 一些例子： 
<br> 
<br> SELECT CURRENT_TIME; 
<br> Result: 14:39:53.662522-05 
<br> 
<br> SELECT CURRENT_DATE; 
<br> Result: 2001-12-23 
<br> 
<br> SELECT CURRENT_TIMESTAMP; 
<br> Result: 2001-12-23 14:39:53.662522-05 
<br> 
<br> SELECT CURRENT_TIMESTAMP(2); 
<br> Result: 2001-12-23 14:39:53.66-05 
<br> 
<br> SELECT LOCALTIMESTAMP; 
<br> Result: 2001-12-23 14:39:53.662522 
<br> 
<br> 16. 常见数据类型中两者不同的部分 
<br> 
<br> Oracle数据类型    PostgresQL数据类型 
<br> VARCHAR2    VARCHAR 
<br> CLOB    TEXT 
<br> DATE    DATE/TIME/TIMESTAMP(DATE仅包含日期、TIME仅包含时间、TIMESTAMP均包含,通常使用DATE) 
<br> NUMBER    SMALLINT/INTEGER/BIGINT/NUMERIC/REAL/DOUBLE PRECISION(通常可用NUMERIC) 
<br> BLOB    BYTEA 
<br> 
<br> 17. sql语句执行结果，sqlcode判断PostgresQL和Oracle不完全一样 
<br> 
<br> 18. PostgresQL 
<br> 当创建游标的事务用COMMIT或ROLLBACK终止之后，每个不可保持的已打开游标都隐含关闭。 
<br> 当创建游标的事务通过ROLLBACK退出之后，每个可以保持的游标都将隐含关闭。 
<br> 当创建游标的事务成功提交，那么可保持的游标保持打开，直到执行一个明确的CLOSE命令或者客户端断开。 
<br> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1ceb0a84bef2b4e4c750f7f37690cf7f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CreateObject(Excel.Application)出错解决方法【转】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0cbaf8c3b32825977f3009deb8a8702e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">apache 使用 mod_fcgid.so模块时 配置指令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>