<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>系统调用中断（EINTR）与SIGCHLD信号的处理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="系统调用中断（EINTR）与SIGCHLD信号的处理" />
<meta property="og:description" content="一、被中断的系统调用(EINTR)的理解 1. 慢系统调用是？2. 慢系统调用的类别3. EINTR产生的原因5. 一般处理方法 二、SIGCHLD信号的处理 1. SIGCHLD信号的产生2. SIGCHLD信号的处理3. 不处理SIGCHLD的后果 三、示例代码 一、被中断的系统调用(EINTR)的理解 1. 慢系统调用是？ 慢系统调用指可能永远阻塞的系统调用。
也就是处于阻塞状态的系统调用，如果不收到需要的信息，就会一直阻塞在那里。例如accept：在服务器等待客户端建立连接时，如果没有客户端来请求连接，那么accept就会一直阻塞，直到有客户端请求连接为止。像这种系统调用，就称为慢系统调用。
2. 慢系统调用的类别 对管道的读写对终端设备设备的读写对网络连接的读写…… 值得注意的是，读写磁盘文件一般不会阻塞，一般会返回给调用者（在没有硬件故障的条件下）
3. EINTR产生的原因 当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误。有些内核会自动重启某些被中断的系统调用。
对这句话的理解： 慢系统调用在阻塞状态中，如果收到了某个信号，该系统调用就会被中断，转而去执行对应的信号处理函数，在信号处理函数执行完后，被中断的系统调用就会返回EINTR。有的内核会在被中断的系统调用返回EINTR后重新执行。
以accept为例，在服务器阻塞于accept时，这时之前已连接的客户端关闭了，对应该客户端的子进程就会退出，并发送SIGCHLD信号。如果定义了信号处理函数，就会造成accept的中断，然后执行该信号处理函数，执行完后accept就会返回EINTR。
5. 一般处理方法 推荐将对accept的调用改为：
while( true ) { int clientlen = sizeof( cliaddr ); int connfd = accept( sockfd, (struct sockaddr *)&amp;cliaddr, &amp;clietnlen ); if( connfd &lt; 0 ) { if( errnp == EINTR ) { //如果返回EINTR，就重启该系统调用 continue; } else { perror( &#34;accept &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ec5634b075e78e8ee2cf5186bb08c2d0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-20T15:11:16+08:00" />
<meta property="article:modified_time" content="2018-08-20T15:11:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">系统调用中断（EINTR）与SIGCHLD信号的处理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <div class="toc"> 
  <ul><li> 
    <ul><li> 
      <ul><li><a href="#%E4%B8%80%E8%A2%AB%E4%B8%AD%E6%96%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8eintr%E7%9A%84%E7%90%86%E8%A7%A3" rel="nofollow">一、被中断的系统调用(EINTR)的理解</a> 
        <ul><li> 
          <ul><li><a href="#1-%E6%85%A2%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%98%AF" rel="nofollow">1. 慢系统调用是？</a></li><li><a href="#2-%E6%85%A2%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E7%B1%BB%E5%88%AB" rel="nofollow">2. 慢系统调用的类别</a></li><li><a href="#3-eintr%E4%BA%A7%E7%94%9F%E7%9A%84%E5%8E%9F%E5%9B%A0" rel="nofollow">3. EINTR产生的原因</a></li><li><a href="#5-%E4%B8%80%E8%88%AC%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95" rel="nofollow">5. 一般处理方法</a></li></ul> </li></ul> </li><li><a href="#%E4%BA%8Csigchld%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86" rel="nofollow">二、SIGCHLD信号的处理</a> 
        <ul><li> 
          <ul><li><a href="#1-sigchld%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BA%A7%E7%94%9F" rel="nofollow">1. SIGCHLD信号的产生</a></li><li><a href="#2-sigchld%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86" rel="nofollow">2. SIGCHLD信号的处理</a></li><li><a href="#3-%E4%B8%8D%E5%A4%84%E7%90%86sigchld%E7%9A%84%E5%90%8E%E6%9E%9C" rel="nofollow">3. 不处理SIGCHLD的后果</a></li></ul> </li></ul> </li><li><a href="#%E4%B8%89%E7%A4%BA%E4%BE%8B%E4%BB%A3%E7%A0%81" rel="nofollow">三、示例代码</a></li></ul> </li></ul> </li></ul> 
 </div> 
</div> 
<p></p> 
<h4 id="一被中断的系统调用eintr的理解">一、被中断的系统调用(EINTR)的理解</h4> 
<h6 id="1-慢系统调用是">1. 慢系统调用是？</h6> 
<blockquote> 
 <p>慢系统调用指可能永远阻塞的系统调用。</p> 
</blockquote> 
<p>也就是处于阻塞状态的系统调用，如果不收到需要的信息，就会一直阻塞在那里。例如<code>accept</code>：在服务器等待客户端建立连接时，如果没有客户端来请求连接，那么<code>accept</code>就会一直阻塞，直到有客户端请求连接为止。像这种系统调用，就称为慢系统调用。</p> 
<h6 id="2-慢系统调用的类别">2. 慢系统调用的类别</h6> 
<ul><li>对管道的读写</li><li>对终端设备设备的读写</li><li>对网络连接的读写</li><li>……</li></ul> 
<p>值得注意的是，读写磁盘文件一般不会阻塞，一般会返回给调用者（在没有硬件故障的条件下）</p> 
<h6 id="3-eintr产生的原因">3. EINTR产生的原因</h6> 
<blockquote> 
 <p>当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误。有些内核会自动重启某些被中断的系统调用。</p> 
</blockquote> 
<p>对这句话的理解： <br> 慢系统调用在阻塞状态中，如果收到了某个信号，该系统调用就会被中断，转而去执行对应的信号处理函数，在信号处理函数执行完后，被中断的系统调用就会返回EINTR。有的内核会在被中断的系统调用返回EINTR后重新执行。</p> 
<p>以<code>accept</code>为例，在服务器阻塞于<code>accept</code>时，这时之前已连接的客户端关闭了，对应该客户端的子进程就会退出，并发送<code>SIGCHLD</code>信号。如果定义了信号处理函数，就会造成accept的中断，然后执行该信号处理函数，执行完后<code>accept</code>就会返回<code>EINTR</code>。</p> 
<h6 id="5-一般处理方法">5. 一般处理方法</h6> 
<p>推荐将对accept的调用改为：</p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">while</span>( <span class="hljs-keyword">true</span> ) {
    <span class="hljs-keyword">int</span> clientlen = <span class="hljs-keyword">sizeof</span>( cliaddr );
    <span class="hljs-keyword">int</span> connfd = accept( sockfd, (<span class="hljs-keyword">struct</span> sockaddr *)&amp;cliaddr, &amp;clietnlen );

    <span class="hljs-keyword">if</span>( connfd &lt; <span class="hljs-number">0</span> ) {
        <span class="hljs-keyword">if</span>( errnp == EINTR ) {  <span class="hljs-comment">//如果返回EINTR，就重启该系统调用</span>
            <span class="hljs-keyword">continue</span>;
        } <span class="hljs-keyword">else</span> {
            perror( <span class="hljs-string">"accept "</span> );
        }
    }

    <span class="hljs-comment">// do other things</span>
}</code></pre> 
<p>还有两种方法：设置SA_RESTART属性、忽略信号，不过推荐使用上述方法。</p> 
<h4 id="二sigchld信号的处理">二、SIGCHLD信号的处理</h4> 
<h6 id="1-sigchld信号的产生">1. SIGCHLD信号的产生</h6> 
<p>在子进程退出时，会发送给父进程一个SIGCHLD信号来表明子进程已退出，此时可以使用wait/waitpid来等待子进程退出并回收子进程占用的资源，避免产生<a href="https://zh.wikipedia.org/wiki/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B" rel="nofollow">僵尸进程</a>。该信号被默认为忽略。</p> 
<h6 id="2-sigchld信号的处理">2. SIGCHLD信号的处理</h6> 
<p>可以定义该信号的信号处理函数，并使用<code>signal()</code>来运行该信号对应的信号处理函数。</p> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-keyword">void</span> sig_chld( <span class="hljs-keyword">int</span> signo ) {
    pid_t pid;
    <span class="hljs-keyword">int</span> stat;

    <span class="hljs-keyword">while</span>( ( pid = waitpid( -<span class="hljs-number">1</span>, &amp;stat, WNOHANG ) ) &gt; <span class="hljs-number">0</span> ) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"child %d terminated\n"</span>, pid );
    }

    <span class="hljs-keyword">return</span> ;
}

signal( SIGCHLD, sig_chld );</code></pre> 
<p>其中，我们必须要为waitpid()函数设置<code>WNOHANG</code>属性，以便告知waitpid在仍有子进程尚未终止时不要阻塞。 <br> 循环中不能使用wait()函数，因为我们不能保证wait在还有子进程运行时不会发生阻塞。</p> 
<p>在使用循环判断后，就可以将所有已结束的子进程的资源进行回收。</p> 
<h6 id="3-不处理sigchld的后果">3. 不处理SIGCHLD的后果</h6> 
<p>如果我们在收到SIGCHLD信号后忽略，而且也没有在父进程最后wait/waitpid子进程结束，就会有僵尸进程产生。僵尸进程虽然不再占有内存等资源，但是会保留进程表中的表项，因此会造成内存泄漏。</p> 
<p>linux下，可以使用ps命令查看，<code>stat</code>一栏标志为<code>Z</code>的就是僵尸进程。</p> 
<h4 id="三示例代码">三、示例代码</h4> 
<ul><li>server.cpp</li></ul> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;sys/socket.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;time.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;unistd.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;fcntl.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;netinet/in.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;arpa/inet.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;signal.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;errno.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;wait.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">8080</span>;

<span class="hljs-comment">/* 接收客户端信息 */</span>
<span class="hljs-keyword">void</span> str_echo( <span class="hljs-keyword">int</span> conn_fd ) {
    ssize_t n;
    <span class="hljs-keyword">char</span> buf[<span class="hljs-number">1024</span>] = {<!-- --><span class="hljs-number">0</span>};

    <span class="hljs-keyword">while</span>( ( n = read( conn_fd, buf, <span class="hljs-number">1024</span> ) ) &gt; <span class="hljs-number">0</span> ) {
        write( conn_fd, buf, n );
    }

    <span class="hljs-keyword">if</span>( n &lt; <span class="hljs-number">0</span> &amp;&amp; errno == EINTR ) {
        <span class="hljs-keyword">continue</span>;
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( n &lt; <span class="hljs-number">0</span> ) {
        perror( <span class="hljs-string">"read "</span> );
    }
}

<span class="hljs-keyword">void</span> sig_chld( <span class="hljs-keyword">int</span> signo ) {
    pid_t pid;
    <span class="hljs-keyword">int</span> stat;

    <span class="hljs-keyword">while</span>( ( pid = waitpid( -<span class="hljs-number">1</span>, &amp;stat, WNOHANG ) ) &gt; <span class="hljs-number">0</span> ) {
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"child %d terminated\n"</span>, pid );
    }

    <span class="hljs-keyword">return</span> ;
}

<span class="hljs-keyword">int</span> main() {
    <span class="hljs-keyword">int</span> sock_fd = socket( AF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );
    <span class="hljs-keyword">if</span>( sock_fd &lt; <span class="hljs-number">0</span> ) {
        perror( <span class="hljs-string">"socket "</span> );
    }

    <span class="hljs-keyword">struct</span> sockaddr_in servaddr;
    <span class="hljs-built_in">memset</span>( &amp;servaddr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>( servaddr ) );
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons( PORT );
    servaddr.sin_addr.s_addr = htonl( INADDR_ANY );
    <span class="hljs-keyword">int</span> ret = bind( sock_fd, ( <span class="hljs-keyword">struct</span> sockaddr * )&amp;servaddr, <span class="hljs-keyword">sizeof</span>( servaddr ) );
    <span class="hljs-keyword">if</span>( ret &lt; <span class="hljs-number">0</span> ) {
        perror( <span class="hljs-string">"bind "</span> );
    }

    ret = listen( sock_fd, <span class="hljs-number">5</span> );
    <span class="hljs-keyword">if</span>( ret &lt; <span class="hljs-number">0</span> ) {
        perror( <span class="hljs-string">"bind "</span> );
    }

    signal( SIGCHLD, sig_chld );

    <span class="hljs-keyword">while</span>( <span class="hljs-keyword">true</span> ) {
        <span class="hljs-keyword">struct</span> sockaddr_in clieaddr;
        socklen_t len;
        <span class="hljs-built_in">memset</span>( &amp;clieaddr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>( clieaddr ) );
        <span class="hljs-keyword">int</span> conn_fd = accept( sock_fd, ( sockaddr * )&amp;clieaddr, &amp;len );

        <span class="hljs-keyword">if</span>( conn_fd &lt; <span class="hljs-number">0</span> ) {
            <span class="hljs-keyword">if</span>( errno == EINTR ) {
                <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"EINTR\n"</span>;
                <span class="hljs-keyword">continue</span>;
            } <span class="hljs-keyword">else</span> {
                perror( <span class="hljs-string">"accept "</span> );
            }
        }

        <span class="hljs-keyword">if</span>( fork() == <span class="hljs-number">0</span> ) {
            close( sock_fd );
            str_echo( conn_fd );
            <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
        }
        close( conn_fd );
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<ul><li>client.cpp</li></ul> 
<pre class="prettyprint"><code class="language-cpp hljs "><span class="hljs-preprocessor">#include &lt;iostream&gt;</span>
<span class="hljs-preprocessor">#include &lt;string.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;sys/socket.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;time.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;unistd.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;sys/types.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;fcntl.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;netinet/in.h&gt;</span>
<span class="hljs-preprocessor">#include &lt;arpa/inet.h&gt;</span>
<span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;

<span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> PORT = <span class="hljs-number">8080</span>;

<span class="hljs-comment">/* 给服务器发送、接收消息的函数 */</span>
<span class="hljs-keyword">void</span> str_cli( FILE *fp, <span class="hljs-keyword">int</span> sock_fd ) {
    <span class="hljs-keyword">char</span> recvline[<span class="hljs-number">1024</span>] = {<!-- --><span class="hljs-number">0</span>}, sendline[<span class="hljs-number">1024</span>] = {<!-- --><span class="hljs-number">0</span>};

    <span class="hljs-keyword">while</span>( fgets( sendline, <span class="hljs-number">1024</span>, fp ) != NULL ) {
        write( sock_fd, sendline, <span class="hljs-built_in">strlen</span>(sendline) );

        <span class="hljs-keyword">if</span>( read( sock_fd, recvline, <span class="hljs-number">1024</span> ) == <span class="hljs-number">0</span> ) {
            perror( <span class="hljs-string">"readline "</span> );
        }

        <span class="hljs-built_in">fputs</span>( recvline, stdout );
    }
}

<span class="hljs-keyword">int</span> main( <span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> **argv ) {
    <span class="hljs-keyword">if</span>( argc != <span class="hljs-number">2</span> ) {
        <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">"Usage : ./client + ip\n"</span>;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-keyword">int</span> sock_fd[<span class="hljs-number">5</span>] = {<!-- --><span class="hljs-number">0</span>};
    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ ) {  <span class="hljs-comment">// 创建5个连接</span>

        sock_fd[i] = socket( AF_INET, SOCK_STREAM, <span class="hljs-number">0</span> );
        <span class="hljs-keyword">if</span>( sock_fd[i] &lt; <span class="hljs-number">0</span> ) {
            perror( <span class="hljs-string">"socket "</span> );
        }

        sockaddr_in servaddr;
        <span class="hljs-built_in">memset</span>( &amp;servaddr, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>( servaddr ) );
        servaddr.sin_family = AF_INET;
        servaddr.sin_port = htons( PORT );
        inet_pton( AF_INET, argv[<span class="hljs-number">1</span>], &amp;servaddr.sin_addr );

        <span class="hljs-keyword">int</span> ret = connect( sock_fd[i], (sockaddr *)&amp;servaddr, <span class="hljs-keyword">sizeof</span>( servaddr ) );
        <span class="hljs-keyword">if</span>( ret &lt; <span class="hljs-number">0</span> ) {
            perror( <span class="hljs-string">"connect "</span> );
        }
    }

    str_cli( stdin, sock_fd[<span class="hljs-number">0</span>] );

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>运行结果： <br> <img src="https://images2.imgbox.com/59/e6/9Raf6v0u_o.png" alt="1" title=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/707448c1ef025ce2b93d4093576ecc84/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python类中的__dict__</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/45656afd65b002287ae0511fe68015f8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">yum install   出现如下错误： Loaded plugins: fastestmirror, langpacks    SyntaxError: invalid syntax</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>