<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>js中的闭包 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="js中的闭包" />
<meta property="og:description" content="1.什么是闭包：
闭包是javascript中的一个重要知识点，面试经常问到，需要我们熟练掌握。根据javascript高级程序设计中解释：闭包是指有权访问一个函数作用域中局部变量的函数。
要认知闭包，就要知道js中有两种作用域：全局作用域，局部作用域，与之对应的是全局变量和局部变量。我们都知道在函数内部中可以访问到全局作用域中的全局变量，但是在全局作用域中一般却无法访问某个函数的局部变量。为了解决这个问题，我们必须知道闭包。
2.闭包展示：
先来个简单的吧
&lt;script&gt; function fn () { var name = &#39;zs&#39; function fon () { console.log(name); } fon() } fn() // zs &lt;/script&gt; 上述代码就用到了闭包，且听我慢慢道来：首先定义了fn函数，在函数内部声明name变量和定义了fon函数。当执行fn（）时，fon函数中的name会读取fn函数中的name，最后打印zs。即在fon函数中可以访问fn这个局部作用域中的局部变量name。这就是闭包的优势，但凡事都有两面性，有优必有缺（会导致内存泄漏）。
再来
&lt;script&gt; function fn () { var name = &#39;zs&#39; function fon () { console.log(name); } return fon; } var f = fn() f(); // zs &lt;/script&gt; 上述代码同样用到了闭包。执行f()打印zs，该过程是在外部就访问到了函数内部的变量。不难看出，闭包的作用之一是延长了局部变量的作用域范围。
再如：
&lt;script&gt; // 闭包 function fn() { var arr = []; for(var i=0;i&lt;5;i&#43;&#43;) { arr[i] = function() { return i; } } return arr } var list = fn() for(var i =0;i&lt;list." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/cee750f4af2f4019d7b7e68046a50219/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-08T21:08:57+08:00" />
<meta property="article:modified_time" content="2022-05-08T21:08:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">js中的闭包</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>1.什么是闭包：</strong></p> 
<p>闭包是javascript中的一个重要知识点，面试经常问到，需要我们熟练掌握。根据javascript高级程序设计中解释：闭包是指有权访问一个函数作用域中局部变量的函数。</p> 
<p>要认知闭包，就要知道js中有两种作用域：全局作用域，局部作用域，与之对应的是全局变量和局部变量。我们都知道在函数内部中可以访问到全局作用域中的全局变量，但是在全局作用域中一般却无法访问某个函数的局部变量。为了解决这个问题，我们必须知道闭包。</p> 
<p></p> 
<p><strong>2.闭包展示：</strong></p> 
<p>先来个简单的吧</p> 
<pre><code>&lt;script&gt;
   function fn () {
      var name = 'zs'
      function fon () {
        console.log(name);
      }
      fon()
    }
    fn() // zs
  &lt;/script&gt;</code></pre> 
<p>上述代码就用到了闭包，且听我慢慢道来：首先定义了fn函数，在函数内部声明name变量和定义了fon函数。当执行fn（）时，fon函数中的name会读取fn函数中的name，最后打印zs。即在fon函数中可以访问fn这个局部作用域中的局部变量name。这就是闭包的优势，但凡事都有两面性，有优必有缺（会导致内存泄漏）。</p> 
<p>再来</p> 
<pre><code> &lt;script&gt;
   function fn () {
      var name = 'zs'
      function fon () {
        console.log(name);
      }
      return fon;
    }
    var f = fn()
    f(); // zs
  &lt;/script&gt;</code></pre> 
<p>上述代码同样用到了闭包。执行f()打印zs，该过程是在外部就访问到了函数内部的变量。不难看出，闭包的作用之一是<span style="color:#fe2c24;">延长了局部变量的作用域范围。</span></p> 
<p>再如：</p> 
<pre><code> &lt;script&gt;
    // 闭包
    function fn() {
      var arr = [];
      for(var i=0;i&lt;5;i++) {
        arr[i] = function() {
          return i;
        }
      }
      return arr
    }
    var list = fn()
    for(var i =0;i&lt;list.length;i++) {
      console.log(list[i]());
    }
  &lt;/script&gt;</code></pre> 
<p>大家猜猜，执行结果是什么？对，就是打印5个5。</p> 
<p>咱们细品：首先执行fn函数，for循环给每个arr[i]赋予了function() {return i;}，循环下来得到五组函数function() {return i;}，并且此时i = 5；继续执行最下面for循环，list[i]()相当于执行function() {return i;}，不过i此时是5，而list中有5个这样的函数，所以打印5个5.</p> 
<p><strong>3.闭包的作用：</strong></p> 
<p>1.<span style="color:#0d0016;">延长了局部变量的作用域范围。</span></p> 
<p><span style="color:#0d0016;">2.使函数外部可读取到函数内部的数据。</span></p> 
<p><strong><span style="color:#0d0016;">4.闭包的缺点：</span></strong><br> 1.函数执行完后，函数内的局部变量没有释放，占用内存时间会变长<br> 2.容易造成内存泄漏</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9284d3c9a131b633c6b285e1baa4dbff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">找不到 raw.githubusercontent.com 的服务器 IP 地址-有效解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d2df9cb6a3fb385e01cf42a41e8e7fb9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">扫雷游戏（实现了网页版的扫雷游戏的所有逻辑）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>