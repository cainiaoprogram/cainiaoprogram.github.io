<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>前端项目中的鉴权是如何实现的？ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="前端项目中的鉴权是如何实现的？" />
<meta property="og:description" content="一、token 验证登录流程 使用基于 Token 的身份验证方法，大概的流程是这样的：
客户端使用用户名跟密码请求登录服务端收到请求，去验证用户名与密码验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里客户端每次向服务端请求资源的时候需要带着服务端签发的 Token服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据 总的来说就是客户端在首次登陆以后，服务端再次接收http请求的时候，就只认token了，请求只要每次把token带上就行了，服务器端会拦截所有的请求，然后校验token的合法性，合法就放行，不合法就返回401（鉴权失败）。
二、最常用的鉴权是 JWT方案（JSON WEB TOKEN） JWT是什么？
JWT是Auth0提出的通过对JSON进行加密签名来实现授权验证的方案。就是登陆成功后将相关信息组成json对象，然后对这个对象进行某中方式的加密，返回给客户端，客户端在下次请求时带上这个token，服务端再收到请求时校验token合法性，其实也就是在校验请求的合法性。
JWT对象通常由三部分构成：
Headers： 包括类别（typ）、加密算法（alg）
{ &#34;alg&#34;: &#34;HS256&#34;, &#34;typ&#34;: &#34;JWT&#34; } Claims ：包括需要传递的用户信息
{ &#34;sub&#34;: &#34;1234567890&#34;, &#34;name&#34;: &#34;John Doe&#34;, &#34;admin&#34;: true } Signature： 根据alg算法与私有秘钥进行加密得到的签名字串， 这一段是最重要的敏感信息，只能在服务端解密；
HMACSHA256( base64UrlEncode(Headers) &#43; &#34;.&#34; &#43; base64UrlEncode(Claims), SECREATE_KEY ) 编码之后的JWT看起来是这样的一串字符：
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 三、 后端设计：nodejs&#43;express&#43;jwt-simple auth.js
let jwt = require(&#39;jwt-simple&#39;); let secret = &#34;wangyy&#34;; let time = 10; module." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b6c48be1818ff77af763d4642c383922/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-14T16:03:05+08:00" />
<meta property="article:modified_time" content="2022-09-14T16:03:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">前端项目中的鉴权是如何实现的？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>一、token 验证登录流程</h4> 
<p>使用基于 Token 的身份验证方法，大概的流程是这样的：</p> 
<ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li><li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据</li></ol> 
<p>总的来说就是客户端在首次登陆以后，服务端再次接收http请求的时候，就只认token了，请求只要每次把token带上就行了，服务器端会拦截所有的请求，然后校验token的合法性，合法就放行，不合法就返回401（鉴权失败）。</p> 
<h4><br> 二、最常用的鉴权是 JWT方案（JSON WEB TOKEN）</h4> 
<p><strong>JWT是什么？</strong></p> 
<p>JWT是Auth0提出的通过对JSON进行加密签名来实现授权验证的方案。就是登陆成功后将相关信息组成json对象，然后对这个对象进行某中方式的加密，返回给客户端，客户端在下次请求时带上这个token，服务端再收到请求时校验token合法性，其实也就是在校验请求的合法性。<br><strong>JWT对象通常由三部分构成：</strong></p> 
<p>Headers： 包括类别（typ）、加密算法（alg）</p> 
<pre><code class="language-javascript">
{
  "alg": "HS256",
  "typ": "JWT"
}
</code></pre> 
<p>Claims ：包括需要传递的用户信息</p> 
<pre><code class="language-javascript">    {
      "sub": "1234567890",
      "name": "John Doe",
      "admin": true
    }
</code></pre> 
<p>Signature： 根据alg算法与私有秘钥进行加密得到的签名字串， 这一段是最重要的敏感信息，只能在服务端解密；</p> 
<pre><code class="language-javascript">HMACSHA256(  
    base64UrlEncode(Headers) + "." +
    base64UrlEncode(Claims),
    SECREATE_KEY
)
</code></pre> 
<p>编码之后的JWT看起来是这样的一串字符：</p> 
<pre><code class="language-javascript">
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
</code></pre> 
<h4>三、 后端设计：nodejs+express+jwt-simple</h4> 
<p><strong>auth.js</strong></p> 
<pre><code class="language-javascript">let jwt = require('jwt-simple');
let secret = "wangyy";
let time = 10;
 module.exports = { 
 /*
  *检验token合法性
 */ 
 validate:function(req,res,next){ 
      let token = req.body.Authorization||req.headers["Authorization"];
        if(token){ 
          let decodeToken = null;
          try { //防止假冒token解析報錯 
             decodeToken = jwt.decode(token,secret,'HS256'); 
          } catch (err) { 
            res.status(401).send("非法访问"); return; 
          } 
        let exp = decodeToken.exp; if(!exp){
        res.status(401).send("非法访问");
     }
     let now = new Date().getTime();
     if(exp&gt;(now+time*60*1000)){
        res.send({code:'401',"errorMsg":"授权超时"})
      }
      next();
    }else{ 
       res.status(401).send("非法访问");
    }
  },
  /* 生成token*/ 
  makeToken(){ 
      let Token = null; 
      let payload = { 
              time:new Date().getTime(), 
              exp:this.makeExp(time) 
              } 
      Token = jwt.encode(payload,secret,HS256) return Token; 
 }, 
 /*生成token过期时间*/ 
 makeExp:function(time){
      let stam = time601000; 
   } 
 }
</code></pre> 
<h4>server.js</h4> 
<pre><code class="language-javascript">let express = require("express"); 
let app = express(); 
let bodyParser = require('body-parser'); 
let auth = require('./lib/auth.js'); 
let chalk = require('chalk'); app.use(bodyParser.json()); app.post('/login',function(req,res,next){ 
            let Token = auth.makeToken(); 
            res.json({result:"success",token:Token},200)
   });
app.use('*',[auth.validate],function(req,res,next){ 
     res.send('success'); 
  }); 
app.listen('9999')
</code></pre> 
<p>上面只是一个简单的token生成和校验，如果有需要可以根据实际需要进行逻辑处理</p> 
<h4>四、前端设计</h4> 
<p><strong>使用vuex保存全局状态，并做数据持久化</strong><br> vuex里面面定义token变量来表示用户是否登录，初始值为’’</p> 
<pre><code class="language-javascript">
import createPersistedState from 'vuex-persistedstate'

export default new Vuex.Store({
	  state: {
	    token: '',
	  },
	  mutations: {
	    setIsLogin(state, isLogin) {  //登录成功调用
	      state.token = isLogin;
	    },
	    FedLogOut(state) {        //退出登陆执行
	      state.token=''
	    }
	  }
    actions,
    getters,
    plugins:[createPersistedState({  //vuex数据固化到本地缓存，数据持久化
        storage: window.localStorage
    })] 
});
</code></pre> 
<p><strong>配置request请求拦截器</strong></p> 
<p>request请求拦截器：发送请求前统一处理，如：设置请求头headers、应用的版本号、终端类型等。</p> 
<pre><code class="language-javascript">
service.interceptors.request.use(
  config =&gt; {
    if (store.state.token) {
     // 为请求头对象，添加token验证的Authorization字段
     config.headers.Authorization = store.state.token;     
    }
        return config
  },
  error =&gt; {
    // do something with request error
    console.log(error) // for debug
    return Promise.reject(error)
  }
)
</code></pre> 
<p><strong>response响应拦截器</strong></p> 
<p>response响应拦截器：有时候我们要根据响应的状态码来进行下一步操作，例如：由于当前的token过期，接口返回401未授权，那我们就要进行重新登录的操作。</p> 
<pre><code class="language-javascript">
service.interceptors.response.use(
  response =&gt; {
    Toast.clear()
    const res = response.data
    if (res.status &amp;&amp; res.status !== 200) {
      // 登录超时,token过期返回401，重新登录
      if (res.status === 401) { 
        store.dispatch('FedLogOut').then(() =&gt; {
                router.replace({
                path: '/login'
                //登录成功后跳入浏览的当前页面
                // query: {redirect: router.currentRoute.fullPath}
            })
        })
      }
      return Promise.reject(res || 'error')
    } else {
      return Promise.resolve(res)
    }
  },
  error =&gt; {
    Toast.clear()
    console.log('err' + error) // for debug
    return Promise.reject(error)
  }
)

</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5419fa6992145e678675433637905608/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JAVA实现Date日期加一天</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0ad9f69c87f6a0449c5c0cca956ad0a3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用 Django 创建项目（入门笔记一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>