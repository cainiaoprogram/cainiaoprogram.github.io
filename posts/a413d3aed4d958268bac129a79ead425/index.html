<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>opencv 坐标转换常用的函数solvePnP()、 projectPoints()、stereoRectify()、stereoCalibrate() - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="opencv 坐标转换常用的函数solvePnP()、 projectPoints()、stereoRectify()、stereoCalibrate()" />
<meta property="og:description" content="1. Finds an object pose from 3D-2D point correspondences.
bool solvePnP(InputArray objectPoints, InputArray imagePoints, InputArray cameraMatrix, InputArray distCoeffs, OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess=false, int flags=ITERATIVE ) 函数solvepnp接收一组对应的3D坐标和2D坐标，计算得到两组坐标对应的几何变换（旋转矩阵rvec，平移矩阵tvec）; 2.Projects 3D points to an image plane.
void projectPoints(InputArray objectPoints, InputArray rvec, InputArray tvec, InputArray cameraMatrix, InputArray distCoeffs, OutputArray imagePoints, OutputArray jacobian=noArray(), double aspectRatio=0 ) 函数projectPoints()根据所给的3D坐标和已知的几何变换来求解投影后的2D坐标。
3. void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, InputArray R, InputArray T,OutputArray R1, OutputArray R2, OutputArray P1, OutputArray P2,OutputArray Q, int flags=CALIB_ZERO_DISPARITY, double alpha=-1, Size newImageSize=Size(), Rect* validPixROI1=0, Rect* validPixROI2=0 ) 立体矫正，该函数计算每个摄像机(实际上)的旋转矩阵，从而使两个摄像机图像平面成为同一平面。因此，这使得所有的外极线平行，从而简化了稠密立体对应问题。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a413d3aed4d958268bac129a79ead425/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-08T10:21:11+08:00" />
<meta property="article:modified_time" content="2019-01-08T10:21:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">opencv 坐标转换常用的函数solvePnP()、 projectPoints()、stereoRectify()、stereoCalibrate()</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0cm;"><span style="color:#000000;">1. Finds an object pose from 3D-2D point correspondences.</span></p> 
<pre class="has"><code class="hljs language-cpp">bool solvePnP(InputArray objectPoints, InputArray imagePoints, 
               InputArray cameraMatrix, InputArray distCoeffs, 
               OutputArray rvec, OutputArray tvec, bool useExtrinsicGuess=false, 
               int flags=ITERATIVE )</code></pre> 
<p style="margin-left:0cm;"><span style="color:#000000;">函数solvepnp</span><span style="color:#000000;">接收一组对应的</span><span style="color:#000000;">3D</span><span style="color:#000000;">坐标和</span><span style="color:#000000;">2D</span><span style="color:#000000;">坐标，计算得到两组坐标对应的几何变换（旋转矩阵</span><span style="color:#000000;">rvec</span><span style="color:#000000;">，平移矩阵</span><span style="color:#000000;">tvec</span><span style="color:#000000;">）</span><span style="color:#000000;">; </span></p> 
<hr> 
<p style="margin-left:0cm;"><span style="color:#000000;">2.Projects 3D points to an image plane.</span></p> 
<pre class="has"><code class="hljs language-cpp">void projectPoints(InputArray objectPoints, InputArray rvec, InputArray tvec,
                   InputArray cameraMatrix, InputArray distCoeffs, 
                   OutputArray imagePoints, OutputArray jacobian=noArray(), 
                   double aspectRatio=0 )</code></pre> 
<p style="margin-left:0cm;"><span style="color:#000000;">函数</span><span style="color:#000000;">projectPoints()</span><span style="color:#000000;">根据所给的</span><span style="color:#000000;">3D</span><span style="color:#000000;">坐标和已知的几何变换来求解投影后的</span><span style="color:#000000;">2D</span><span style="color:#000000;">坐标。</span></p> 
<hr> 
<p style="margin-left:0cm;"><span style="color:#000000;">3. </span></p> 
<pre class="has"><code class="hljs language-cpp"> void stereoRectify(InputArray cameraMatrix1, InputArray distCoeffs1, 
                    InputArray cameraMatrix2, InputArray distCoeffs2, Size imageSize, 
                    InputArray R, InputArray T,OutputArray R1, OutputArray R2, 
                    OutputArray P1, OutputArray P2,OutputArray Q, 
                    int flags=CALIB_ZERO_DISPARITY, double alpha=-1,
                    Size newImageSize=Size(), Rect* validPixROI1=0, 
                    Rect* validPixROI2=0 )</code></pre> 
<p style="margin-left:0cm;"><span style="color:#000000;">立体矫正，该函数计算每个摄像机</span><span style="color:#000000;">(</span><span style="color:#000000;">实际上</span><span style="color:#000000;">)</span><span style="color:#000000;">的旋转矩阵，从而使两个摄像机图像平面成为同一平面。因此，这使得所有的外极线平行，从而简化了稠密立体对应问题。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">输出：</span><span style="color:#000000;">R1</span><span style="color:#000000;">是把第一个相机校正后的坐标系转换为校正前的坐标系所用的旋转矩阵，即把校正前坐标系点坐标转换为校正后的点坐标所需的旋转矩阵。即</span><span style="color:#000000;">pafter = R1 * pbefore</span><span style="color:#000000;">。而返回去则需要</span><span style="color:#000000;">pbefore = R1.inverse() * pafter</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">R2</span><span style="color:#000000;">同上；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">P1</span><span style="color:#000000;">：第一台相机矫正后坐标系的投影矩阵；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">P2</span><span style="color:#000000;">：第二台相机矫正后坐标系的投影矩阵；</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">Q</span><span style="color:#000000;">：重投影误差。</span></p> 
<hr> 
<p style="margin-left:0cm;"><span style="color:#000000;">4. </span></p> 
<pre class="has"><code class="hljs language-cpp">double stereoCalibrate(InputArrayOfArrays objectPoints, InputArrayOfArrays imagePoints1,
　　　　　　　　　　　　　InputArrayOfArrays imagePoints2, 
                       InputOutputArray cameraMatrix1,InputOutputArray distCoeffs1, 
                       InputOutputArray cameraMatrix2, InputOutputArray distCoeffs2, 
                       Size imageSize,OutputArray R,OutputArray T, OutputArray E, 
                       OutputArray F,
                       TermCriteria  criteria=TermCriteria(TermCriteria::COUNT+TermCriteria::EPS, 30, 1e-6),
                       int flags=CALIB_FIX_INTRINSIC )</code></pre> 
<p style="margin-left:0cm;"><span style="color:#000000;">stereoCalibrate() </span><span style="color:#000000;">是用来标定一个立体摄像头的，也就是同时标定两个摄像头。标定的结果除了能够求出两个摄像头的内外参数矩阵，跟能够得出两个摄像头的位置关系</span><span style="color:#000000;">R,T</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">objectPoints- vector&lt;point3f&gt; </span><span style="color:#000000;">型的数据结构，存储标定角点在世界坐标系中的位置</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">imagePoints1- vector&lt;vector&lt;point2f&gt;&gt; </span><span style="color:#000000;">型的数据结构，存储标定角点在第一个摄像机下的投影后的亚像素坐标</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">imagePoints2- vector&lt;vector&lt;point2f&gt;&gt; </span><span style="color:#000000;">型的数据结构，存储标定角点在第二个摄像机下的投影后的亚像素坐标</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">cameraMatrix1-</span><span style="color:#000000;">输入</span><span style="color:#000000;">/</span><span style="color:#000000;">输出型的第一个摄像机的相机矩阵。如果</span><span style="color:#000000;">CV_CALIB_USE_INTRINSIC_GUESS , CV_CALIB_FIX_ASPECT_RATIO ,CV_CALIB_FIX_INTRINSIC , or CV_CALIB_FIX_FOCAL_LENGTH</span><span style="color:#000000;">其中的一个或多个标志被设置，该摄像机矩阵的一些或全部参数需要被初始化</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">distCoeffs1-</span><span style="color:#000000;">第一个摄像机的输入</span><span style="color:#000000;">/</span><span style="color:#000000;">输出型畸变向量。根据矫正模型的不同，输出向量长度由标志决定</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">cameraMatrix2-</span><span style="color:#000000;">输入</span><span style="color:#000000;">/</span><span style="color:#000000;">输出型的第二个摄像机的相机矩阵。参数意义同第一个相机矩阵相似</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">distCoeffs2-</span><span style="color:#000000;">第一个摄像机的输入</span><span style="color:#000000;">/</span><span style="color:#000000;">输出型畸变向量。根据矫正模型的不同，输出向量长度由标志决定</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">imageSize-</span><span style="color:#000000;">图像的大小</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">R-</span><span style="color:#000000;">输出型，第一和第二个摄像机之间的旋转矩阵</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">T-</span><span style="color:#000000;">输出型，第一和第二个摄像机之间的平移矩阵</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">E-</span><span style="color:#000000;">输出型，本质矩阵，其物理意义是左右图像坐标系相互转换的矩阵，描述的是同一空间点投影在左右摄像机图像平面上对应点之间的关系，单位为</span><span style="color:#000000;">mm</span><span style="color:#000000;">。</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">F-</span><span style="color:#000000;">输出型，基础矩阵，同一物理点在左右摄像机图像平面上投影在像素坐标系下的关系：</span> </p> 
<ol><li style="margin-left:0cm;"><span style="color:#000000;">PTpixrFPpixl=0</span></li></ol> 
<p style="margin-left:0cm;"><span style="color:#000000;">term_crit-</span><span style="color:#000000;">迭代优化的终止条件</span></p> 
<p style="margin-left:0cm;"><span style="color:#000000;">flag-</span></p> 
<ul><li> 
  <ul><li><span style="color:#000000;"> CV_CALIB_FIX_INTRINSIC </span><span style="color:#000000;">如果该标志被设置，那么就会固定输入的</span><span style="color:#000000;">cameraMatrix</span><span style="color:#000000;">和</span><span style="color:#000000;">distCoeffs</span><span style="color:#000000;">不变，只求解</span><span style="color:#000000;">R,T,E,F</span></li><li><span style="color:#000000;"> CV_CALIB_USE_INTRINSIC_GUESS </span><span style="color:#000000;">根据用户提供的</span><span style="color:#000000;">cameraMatrix</span><span style="color:#000000;">和</span><span style="color:#000000;">distCoeffs</span><span style="color:#000000;">为初始值开始迭代</span></li><li><span style="color:#000000;"> CV_CALIB_FIX_PRINCIPAL_POINT </span><span style="color:#000000;">迭代过程中不会改变主点的位置</span></li><li><span style="color:#000000;"> CV_CALIB_FIX_FOCAL_LENGTH </span><span style="color:#000000;">迭代过程中不会改变焦距</span></li><li><span style="color:#000000;"> CV_CALIB_SAME_FOCAL_LENGTH </span><span style="color:#000000;">强制保持两个摄像机的焦距相同</span></li><li><span style="color:#000000;"> CV_CALIB_ZERO_TANGENT_DIST </span><span style="color:#000000;">切向畸变保持为零</span></li><li><span style="color:#000000;"> CV_CALIB_FIX_K1,...,CV_CALIB_FIX_K6 </span><span style="color:#000000;">迭代过程中不改变相应的值。如果设置了</span><span style="color:#000000;"> CV_CALIB_USE_INTRINSIC_GUESS </span><span style="color:#000000;">将会使用用户提供的初始值，否则设置为零</span></li><li><span style="color:#000000;"> CV_CALIB_RATIONAL_MODEL </span><span style="color:#000000;">畸变模型的选择，如果设置了该参数，将会使用更精确的畸变模型，</span><span style="color:#000000;">distCoeffs</span><span style="color:#000000;">的长度就会变成</span><span style="color:#000000;">8</span></li></ul></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8ee61afa3424bba5a3cc9a35d0c7e132/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">分布式系统服务的稳定性</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/16867a436bb832eba12034aa1e46a00b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">红黑树原理详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>