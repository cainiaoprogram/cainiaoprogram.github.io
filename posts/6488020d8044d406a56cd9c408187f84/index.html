<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>QQ第三方登录（itsdangerous生成激活token） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="QQ第三方登录（itsdangerous生成激活token）" />
<meta property="og:description" content="一.成为QQ互联的开发者 注册链接：http://wiki.connect.qq.com/%E6%88%90%E4%B8%BA%E5%BC%80%E5%8F%91%E8%80%85
等个3-5 天的工作日审核，审核通过就称为一个开发者了
二.创建应用 在应用管理中创建一个应用，得到APPID
填写相关资料，审核通过得到APPKEY，记录之前的回调地址
三.项目实现 浏览器--&gt; 服务器 -- &gt; QQ服务器
1.浏览器用Vue的axios方法，GET请求服务器获取登录QQ服务器的网址（浏览器--&gt;服务器）
2.服务器拼接url路径返回给浏览器（服务器--&gt;浏览器）
3.浏览器用response接收到的url路径访问QQ服务器。（浏览器--&gt;QQ服务器）
4.QQ服务器返回code值，浏览器截取code值返回给服务器（QQ服务器--&gt;浏览器，浏览器--&gt;服务器）
5.服务器获取浏览器发送过来的code值，拼接字符串重新访问QQ服务器（服务器--&gt;QQ服务器）
6.QQ服务器返回access_token给服务器（QQ服务器--&gt;服务器）
7.服务器获取响应中的access_token值，拼接字符串给QQ服务器（服务器--&gt;QQ服务器）
8.QQ服务器返回openid（用户唯一身份标识）给服务器（QQ服务器--&gt;服务器）
QQ登录开发文档链接：http://wiki.connect.qq.com/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C_oauth2-0
前端代码放置QQ按钮，访问服务器
HTML
&lt;div class=&#34;third_party&#34;&gt; &lt;a @click=&#34;qq_login&#34; class=&#34;qq_login&#34;&gt;QQ&lt;/a&gt; &lt;a href=&#34;#&#34; class=&#34;weixin_login&#34;&gt;微信&lt;/a&gt; &lt;a href=&#34;/register.html&#34; class=&#34;register_btn&#34;&gt;立即注册&lt;/a&gt; &lt;/div&gt; JS
qq_login: function(){ var state = this.get_query_string(&#39;next&#39;) || &#39;/&#39;; axios.get(this.host &#43; &#39;/oauth/qq/statues/?state=&#39; &#43; state, { responseType: &#39;json&#39; }) .then(response =&gt; { location.href = response.data.auth_url; }) .catch(error =&gt; { console.log(error.response.data); }) }, 通过前端axios请求GET方法访问服务器，服务器返回拼接好的URL
class QQAuthURLView(APIView): &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6488020d8044d406a56cd9c408187f84/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-24T15:30:58+08:00" />
<meta property="article:modified_time" content="2018-08-24T15:30:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">QQ第三方登录（itsdangerous生成激活token）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一.成为QQ互联的开发者</h2> 
<p>注册链接：<a href="http://wiki.connect.qq.com/%E6%88%90%E4%B8%BA%E5%BC%80%E5%8F%91%E8%80%85" rel="nofollow">http://wiki.connect.qq.com/%E6%88%90%E4%B8%BA%E5%BC%80%E5%8F%91%E8%80%85</a></p> 
<p>等个3-5 天的工作日审核，审核通过就称为一个开发者了</p> 
<h2>二.创建应用</h2> 
<p>在应用管理中创建一个应用，得到APPID</p> 
<p>填写相关资料，审核通过得到APPKEY，记录之前的回调地址</p> 
<h2>三.项目实现</h2> 
<p>浏览器--&gt; 服务器 -- &gt; QQ服务器</p> 
<p>1.浏览器用Vue的axios方法，GET请求服务器获取登录QQ服务器的网址（浏览器--&gt;服务器）</p> 
<p>2.服务器拼接url路径返回给浏览器（服务器--&gt;浏览器）</p> 
<p>3.浏览器用response接收到的url路径访问QQ服务器。（浏览器--&gt;QQ服务器）</p> 
<p>4.QQ服务器返回code值，浏览器截取code值返回给服务器（QQ服务器--&gt;浏览器，浏览器--&gt;服务器）</p> 
<p>5.服务器获取浏览器发送过来的code值，拼接字符串重新访问QQ服务器（服务器--&gt;QQ服务器）</p> 
<p>6.QQ服务器返回access_token给服务器（QQ服务器--&gt;服务器）</p> 
<p>7.服务器获取响应中的access_token值，拼接字符串给QQ服务器（服务器--&gt;QQ服务器）</p> 
<p>8.QQ服务器返回openid（用户唯一身份标识）给服务器（QQ服务器--&gt;服务器）</p> 
<p><img alt="" class="has" height="626" src="https://images2.imgbox.com/f3/b8/ov841i5B_o.png" width="961"></p> 
<p>QQ登录开发文档链接：<a href="http://wiki.connect.qq.com/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C_oauth2-0" rel="nofollow">http://wiki.connect.qq.com/%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C_oauth2-0</a></p> 
<p><img alt="oauth2.0_guid_3.png" class="has" src="https://images2.imgbox.com/0c/2e/pF7hrLuh_o.png"></p> 
<p>前端代码放置QQ按钮，访问服务器</p> 
<p>HTML</p> 
<pre class="has"><code class="language-html"> &lt;div class="third_party"&gt;
        &lt;a @click="qq_login" class="qq_login"&gt;QQ&lt;/a&gt;
        &lt;a href="#" class="weixin_login"&gt;微信&lt;/a&gt;
        &lt;a href="/register.html" class="register_btn"&gt;立即注册&lt;/a&gt;
 &lt;/div&gt;</code></pre> 
<p>JS</p> 
<pre class="has"><code class="language-javascript">qq_login: function(){
            var state = this.get_query_string('next') || '/';
            axios.get(this.host + '/oauth/qq/statues/?state=' + state, {
                    responseType: 'json'
                })
                .then(response =&gt; {
                    location.href = response.data.auth_url;
                })
                .catch(error =&gt; {
                    console.log(error.response.data);
                })
        },</code></pre> 
<p>通过前端axios请求GET方法访问服务器，服务器返回拼接好的URL</p> 
<pre class="has"><code class="language-python">class QQAuthURLView(APIView):
    """
    请求方式： GET /oauth/qq/statues/
    """

    def get(self, request):
        # 生成auth_url
        # https://graph.qq.com/oauth2.0/authorize?xxx=xxx
        # 请求参数请包含如下内容：
        # response_type   必须      授权类型，此值固定为“code”。
        # client_id       必须      申请QQ登录成功后，分配给应用的appid。
        # redirect_uri    必须      成功授权后的回调地址，必须是注册appid时填写的主域名下的地址，建议设置为网站首页或网站的用户中心。注意需要将url进行URLEncode。
        # state           必须      client端的状态值。用于第三方应用防止CSRF攻击，成功授权后回调时会原样带回。请务必严格按照流程检查用户与state参数状态的绑定。
        # scope              可选      scope=get_user_info
        state = request.query_params.get('state')
        # 1. base_url
        # GET www.baidu.com/a.html?a=xxx&amp;b=xxx
        # ? 是为了将路径和参数进行分割
        base_url = 'https://graph.qq.com/oauth2.0/authorize?'

        # 2. 将参数放在字典中
        params = {
            'response_type': 'code',
            'client_id': settings.QQ_APP_ID,
            'redirect_uri': settings.QQ_REDIRECT_URL,
            'state': 'test',
        }

        # 3.
        # 将query字典转换为url路径中的查询字符串
        auth_url = base_url + urlencode(params)
        return Response({'auth_url': auth_url})</code></pre> 
<p>前端根据返回的auth_url的response访问QQ服务器，服务器返回code给回调函数页面,前端获取code并将其传给服务器</p> 
<p>JS</p> 
<pre class="has"><code class="language-javascript">mounted: function(){
         // 从路径中获取qq重定向返回的code
        var code = this.get_query_string('code');
        axios.get(this.host + '/oauth/qq/users/?code=' + code, {
                responseType: 'json',
            })
            .then(response =&gt; {

            })
            .catch(error =&gt; {
                console.log(error.response.data);
                alert('服务器异常');
            })
    },</code></pre> 
<p>服务器接收到code，拼接字符串用urlopen访问QQ服务器</p> 
<pre class="has"><code class="language-python">class QQTokenView(APIView):
    def get(self, request):
        # PC网站：https://graph.qq.com/oauth2.0/token
        # GET
        # grant_type      必须      授权类型，在本步骤中，此值为“authorization_code”。
        # client_id       必须      申请QQ登录成功后，分配给网站的appid。
        # client_secret   必须      申请QQ登录成功后，分配给网站的appkey。
        # code            必须      上一步返回的authorization
        # redirect_uri    必须      与上面一步中传入的redirect_uri保持一致。
        code = request.query_params.get('code')
        if code is None:
            return Response(status=status.HTTP_400_BAD_REQUEST)
        # PC网站：https://graph.qq.com/oauth2.0/token
        # GET
        # grant_type      必须      授权类型，在本步骤中，此值为“authorization_code”。
        # client_id       必须      申请QQ登录成功后，分配给网站的appid。
        # client_secret   必须      申请QQ登录成功后，分配给网站的appkey。
        # code            必须      上一步返回的authorization
        # redirect_uri    必须      与上面一步中传入的redirect_uri保持一致。
        base_url = 'https://graph.qq.com/oauth2.0/token?'
        params = {
            'grant_type': 'authorization_code',
            'client_id': settings.QQ_APP_ID,
            'client_secret': settings.QQ_APP_KEY,
            'code': code,
            'redirect_uri': settings.QQ_REDIRECT_URL,
        }
        url = base_url + urlencode(params)
        response = urlopen(url)
        data = response.read().decode()
        # print(data)
        acecess_data = parse_qs(data)
        token = acecess_data.get('access_token')[0]
        print(token)
        return token</code></pre> 
<p>获取到QQ服务器返回的access_token值</p> 
<p>服务器在有access_token拼接字符串访问QQ服务器得到openid</p> 
<pre class="has"><code class="language-python">def get_openid_by_token(self, token):
        """
        PC网站：https://graph.qq.com/oauth2.0/me
        2 请求方法
        GET
        3 请求参数
        请求参数请包含如下内容：
        参数	是否必须	含义
        access_token	必须	在Step1中获取到的access token。

        """

        # 1. base_url
        base_url = 'https://graph.qq.com/oauth2.0/me?'
        # 2. 参数
        params = {
            'access_token': token
        }
        # 3. url
        url = base_url + urlencode(params)
        # 4. 根据url获取数据
        response = urlopen(url)

        data = response.read().decode()

        # print(data)
        # 5. 解析数据
        # 因为它返回的数据 不是 字典类型,我们要想获取 字典数据,需要对这个字符串进行截取
        # 'callback( {"client_id":"101474184","openid":"483C55DADEF65CC5735695CBC262F979"} );'
        try:
            openid_data = json.loads(data[10:-4])
        except Exception:
            raise Exception('数据获取错误')

        # print(openid_data)

        return openid_data['openid']</code></pre> 
<p>在视图函数中添加：</p> 
<pre class="has"><code class="language-python">        try:
            qq_user = OAuthQQuser.objects.get(openid=openid)
        except OAuthQQuser.DoesNotExist:
            # 2.没有绑定过需要将openid和user信息绑定
            access_token = OAuthQQuser.generic_token_by_openid(openid)
            return Response({'access_token': access_token})</code></pre> 
<p>由于服务器需要向openid值，但openid是非常重要的信息，不能泄露，所以需要使用itsdangerous生成激活token</p> 
<p>1.安装：pip install itsdangerous</p> 
<p>2.生成用户激活token的方法封装在OAuthQQUser模型类中</p> 
<ul><li>Serializer()生成序列化器，传入混淆字符串和过期时间</li><li>dumps()生成openid加密后的token，传入封装openid的字典</li><li>返回token字符串</li><li> <p>loads()解出token字符串，得到用户id明文</p> </li></ul> 
<pre class="has"><code class="language-python">class OAuthQQUser(BaseModel):
    """
    QQ登录用户数据
    """
   ...

    @staticmethod
    def generate_save_user_token(openid):

        serializer = Serializer(settings.SECRET_KEY, expires_in=3600)

        token = serializer.dumps({'openid': openid})

        return token.decode()
    
    @staticmethod
    def openid_by_token(access_token):
        serializer = Serializer(settings.SECRET_KEY, 3600)
        try:
            result = serializer.loads(access_token)
        except BadData:
            return None
        return result.get('openid')</code></pre> 
<p>然后开始流程的下半部分：</p> 
<p><img alt="" class="has" height="273" src="https://images2.imgbox.com/18/61/4i8BagEG_o.png" width="966"></p> 
<p>接上面第8步后</p> 
<p>9.首先判断用户是不是第一次使用QQ登录，如果不是，返回用户信息和token值，如果是，生成一个token值，返回前端</p> 
<pre class="has"><code class="language-python"># 1.根据openid来判断用户是否存在
        try:
            qq_user = OAuthQQuser.objects.get(openid=openid)
        except OAuthQQuser.DoesNotExist:
            # 2.没有绑定过需要将openid和user信息绑定
            access_token = OAuthQQuser.generic_token_by_openid(openid)
            return Response({'access_token': access_token})
        else:
            # 3.绑定过，直接返回登录的token
            from rest_framework_jwt.settings import api_settings
            # 补充生成记录登录状态的token
            jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER
            jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER
            payload = jwt_payload_handler(qq_user.user)
            token = jwt_encode_handler(payload)
            return Response({
                'token': token,
                'user_id': qq_user.user.id,
                'username': qq_user.user.username,
            })</code></pre> 
<p>10.如果是第一次使用QQ登录，需要绑定用户信息，进入绑定用户信息页面</p> 
<p>前端代码：</p> 
<pre class="has"><code class="language-javascript">mounted: function(){
        // 从路径中获取qq重定向返回的code
        var code = this.get_query_string('code');
        axios.get(this.host + '/oauth/qq/users/?code=' + code, {
                responseType: 'json',
            })
            .then(response =&gt; {
                if (response.data.user_id){
                    // 用户已绑定
                    sessionStorage.clear();
                    localStorage.clear();
                    localStorage.user_id = response.data.user_id;
                    localStorage.username = response.data.username;
                    localStorage.token = response.data.token;

                    // 从路径中取出state,引导用户进入登录成功之后的页面
                    var state = this.get_query_string('state');
                    location.href = state;
                } else {
                    // 用户未绑定
                    this.access_token = response.data.access_token;
                    this.generate_image_code();
                    this.is_show_waiting = false;
                }
            })
            .catch(error =&gt; {
                console.log(error.response.data);
                alert('服务器异常');
            })
    },</code></pre> 
<p>这里可以看出，location.href = state;前面获取code传到前端的state即是成功绑定信息的返回路径</p> 
<p>业务逻辑：</p> 
<ul><li>用户需要填写手机号、密码、图片验证码、短信验证码</li><li>如果用户未在美多商城注册过，则会将手机号作为用户名为用户创建一个美多账户，并绑定用户</li><li>如果用户已在美多商城注册过，则检验密码后直接绑定用户</li></ul> 
<p>后端接口设计</p> 
<p>请求方式： POST /oauth/qq/user/</p> 
<p>请求参数：</p> 
<table><thead><tr><th>参数</th><th>类型</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>mobile</td><td>str</td><td>是</td><td>手机号</td></tr><tr><td>password</td><td>str</td><td>是</td><td>密码</td></tr><tr><td>sms_code</td><td>str</td><td>是</td><td>短信验证码</td></tr><tr><td>access_token</td><td>str</td><td>是</td><td>凭据 （包含openid)</td></tr></tbody></table> 
<p>返回数据：</p> 
<table><thead><tr><th>返回值</th><th>类型</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>token</td><td>str</td><td>是</td><td>JWT token</td></tr><tr><td>user_id</td><td>int</td><td>是</td><td>用户id</td></tr><tr><td>username</td><td>str</td><td>是</td><td>用户名</td></tr></tbody></table> 
<pre class="has"><code class="language-python">def post(self,request):
        """   明确你的需求,分析已知条件, 根据已知条件,创建实现的步骤
        1. 前段应该将 短信,密码和手机号 以及 access_token(openid)的信息 传递给我们
        2. 后端接受到数据之后,对数据进行校验
        3.  user信息??? 我们根据手机号来判断
        4. 我们需要将 openid 和 user信息保存(绑定)起来
        """
        serializer = QQTokenSerializer(data=request.data)
        serializer.is_valid()
        user = serializer.save()
        from rest_framework_jwt.settings import api_settings
        # 补充生成记录登录状态的token
        jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER
        jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER
        payload = jwt_payload_handler(user)
        token = jwt_encode_handler(payload)
        return Response({
            'token': token,
            'user_id': user.id,
            'username': user.username,
        })</code></pre> 
<p>用一个序列化器去判断前端传过来的页面，最后返回给前端token值，user_id,username</p> 
<p>11.判断字段</p> 
<pre class="has"><code class="language-python">def validate(self, attrs):
        access_token = attrs.get('access_token')
        openid = OAuthQQuser.openid_by_token(access_token)
        if openid is None:
            raise serializers.ValidationError('openid发生错误')
        attrs['openid'] = openid

        mobile = attrs['mobile']
        redis_conn = get_redis_connection('code')
        redis_code = redis_conn.get('sms_%s' % mobile)
        if redis_code is None:
            raise serializers.ValidationError('短信验证码已过期')
        sms_code = attrs.get('sms_code')
        if redis_code.decode() != sms_code:
            raise serializers.ValidationError('短信验证码不一致')

        try:
            user = User.objects.get(mobile=mobile)
        except User.DoesNotExist:
            pass
        else:
            password = attrs.get('password')
            if not user.check_password(password):
                raise serializers.ValidationError('密码输入错误')
            attrs['user'] = user
        return attrs</code></pre> 
<p>1.根据openid判断用户是否绑定过</p> 
<p>2.根据mobile和sms_code判断短信验证码是否正确</p> 
<p>3.根据mobile判断用户是否已经注册</p> 
<p>4.根据password判断已经注册的用户密码是否正确</p> 
<p>5.如果没有注册，需要创建一个新用户绑定，重写create方法</p> 
<pre class="has"><code class="language-python">def create(self, validated_data):
        # 1. 获取用户信息
        user = validated_data.get('user')
        # 2. 判断用户信息是否存在
        if user is None:
            # 不存在就创建
            user = User.objects.create(
                username=validated_data.get('mobile'),
                password=validated_data.get('password'),
                mobile=validated_data.get('mobile')
            )

            # 密码还是明文
            user.set_password(validated_data['password'])
            user.save()

        OAuthQQuser.objects.create(
            user=user,
            openid=validated_data.get('openid')
        )

        return user</code></pre> 
<p>补全前端代码：</p> 
<pre class="has"><code class="language-javascript"> on_submit: function(){
            this.check_pwd();
            this.check_phone();
            this.check_sms_code();

            if(this.error_password == false &amp;&amp; this.error_phone == false &amp;&amp; this.error_sms_code == false) {
                axios.post(this.host + '/oauth/qq/users/', {
                        password: this.password,
                        mobile: this.mobile,
                        sms_code: this.sms_code,
                        access_token: this.access_token
                    }, {
                        responseType: 'json',
                    })
                    .then(response =&gt; {
                        // 记录用户登录状态

                        sessionStorage.clear();
                        localStorage.clear();
                        localStorage.token = response.data.token;
                        localStorage.user_id = response.data.user_id;
                        localStorage.username = response.data.username;
                        location.href = this.get_query_string('state');
                    })
                    .catch(error=&gt; {
                        if (error.response.status == 400) {
                            this.error_sms_code_message = error.response.data.message;
                            this.error_sms_code = true;
                        } else {
                            console.log(error.response.data);
                        }
                    })
            }
        }</code></pre> 
<p>使用postman测试时，由于无法保存token信息，需要在请求头加入Authorization：JWT空格+token</p> 
<p><img alt="" class="has" height="459" src="https://images2.imgbox.com/25/58/DvAmF2No_o.png" width="848"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ddfaf149cc3069645257d740ec45bc38/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">怎样规划自己的研究生生活？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3d8ad8fe0cc1aab0e52b7c08aaaa4a92/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">tkinter 做一个exe 加法程序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>