<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>stm32学习笔记（八）中断服务函数与函数调用的区别 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="stm32学习笔记（八）中断服务函数与函数调用的区别" />
<meta property="og:description" content=" 程序, 中断, 调用, 函数 在《微机原理》和《计算机组成》等课程[1-4]教学中（本文以MCS-51单片机为例），中断过程既是教学难点又是教学重点，它与主程序调用子程序过程有一定相似性，但又有很大区别，调用子程序过程相对比较容易掌握，通过把两过程结合起来，采用比较教学方法，能收到了很好的教学效果。 1、两过程定义与作用 子程序是微机基本程序结构中的1种，基本程序结构包括顺序（简单）、分支（判断）、循环、子程序和查表等5种。 子程序是一组可以公用的指令序列，只要给出子程序的入口地址就能从主程序转入子程序。子程序在功能上具有相对的独立性，在执行主程序的过程中往往被多次调用，甚至被不同的程序所调用。一般微机首先执行主程序，碰到调用指令就转去执行子程序，子程序执行完后，返回指令就返回主程序断点（即调用指令的下一条指令），继续执行没有处理完的主程序，这一过程叫做（主程序）调用子程序过程。 子程序结构可简化程序，防止重复书写错误，并可节省内存空间。计算机中经常把常用的各种通用的程序段编成子程序，提供给用户使用。用户在自己编写的程序中，只要会调用这些子程序，就可大大简化用户编程的困难。 中断是计算机中央处理单元CPU与外设I/O交换数据的一种方式，除此方式外，还有无条件、条件（查询）、存贮器直接存取DMA和I/O通道等四种方式。由于无条件不可靠，条件效率低，DMA和I/O通道两方式硬件复杂，而中断方式CPU效率高，因此一般大多采用中断方式。 中断概念是当计算机正在执行某一（主）程序时，收到一中断请求，如果中断响应条件成立，计算机就把正在执行的程序暂停一下，去响应处理这一请求，执行中断服务程序，处理完服务程序后，中断返回指令使计算机返回原来还没有执行完的程序断点处继续执行，这一过程称为中断过程。有了中断，计算机才能具有并行处理，实时处理和故障处理等重要功能。 2、两过程的联系与区别 2.1联系 中断与调用子程序两过程属于完全不同的概念，但它们也有不少相似之处。两者都需要保护断点（即下一条指令地址）、跳至子程序或中断服务程序、保护现场、子程序或中断处理、恢复现场、恢复断点（即返回主程序）。两者都可实现嵌套，即正在执行的子程序再调另一子程序或正在处理的中断程序又被另一新中断请求所中断，嵌套可为多级。 正是由于这些表面上的相似处，很容易使学生把两者混淆起来，特别是把中断也看为子程序，这就大错特错了。 2.2区别 中断过程与调用子程序过程相似点是表面的，从本质上讲两者是完全不一样的。 两者的根本区别主要表现在服务时间与服务对象不一样上。首先，调用子程序过程发生的时间是已知和固定的，即在主程序中的调用指令（CALL）执行时发生主程序调用子程序，调用指令所在位置是已知和固定的。而中断过程发生的时间一般的随机的，CPU在执行某一主程序时收到中断源提出的中断申请时，就发生中断过程，而中断申请一般由硬件电路产生，申请提出时间是随机的（软中断发生时间是固定的），也可以说，调用子程序是程序设计者事先安排的，而执行中断服务程序是由系统工作环境随机决定的；其次，子程序完全为主程序服务的，两者属于主从关系，主程序需要子程序时就去调用子程序，并把调用结果带回主程序继续执行。而中断服务程序与主程序两者一般是无关的，不存在谁为谁服务的问题，两者是平行关系；第三，主程序调用子程序过程完全属于软件处理过程，不需要专门的硬件电路，而中断处理系统是一个软、硬件结合系统，需要专门的硬件电路才能完成中断处理的过程；第四，子程序嵌套可实现若干级，嵌套的最多级数由计算机内存开辟的堆栈大小限制，而中断嵌套级数主要由中断优先级数来决定，一般优先级数不会很大。 http://blog.csdn.net/douyuhua0918/article/details/7473254
中断是嵌入式系统中重要的组成部分，但是在标准C中不包含中断。许多编译开发商在标准C上增加了对中断的支持，提供新的关键字用于标示中断服务程序 (ISR)，类似于__interrupt、#program interrupt等。当一个函数被定义为ISR的时候，编译器会自动为该函数增加中断服务程序所需要的中断现场入栈和出栈代码。
中断服务程序需要满足如下要求：
(1)不能返回值；
(2)不能向ISR传递参数；
(3) ISR应该尽可能的短小精悍；
(4) printf(char * lpFormatString,…)函数会带来重入和性能问题，不能在ISR中采用。
参阅网上资料和个人的一些理解
a.为什么不能有返回值？
中断服务函数的调用是硬件级别的，当中断产生，pc指针强制跳转到对应的中断服务函数入口，进入中断具有随机性，并不是某段代码对其进行调用，那么如果有返回值它的返回值返回给谁?显然这个返回值毫无意义，如果有返回值，它必定需要进行压栈操作，这样一来何时出栈怎么出栈将变得无法解决。
b.不能向ISR传递参数?
同理，也是由于这样会破坏栈的原因，因为函数传递参数必定会要求压栈出栈操作，由于进入中断服务函数的随机行，谁给它传递参数都成问题
c.ISR应尽可能的短小精悍?
如果某个中断频繁产生，而它对应的ISR相当的耗时，那么对中断的响应就会无限的延迟，会丢掉很多的中断请求
d.printf(char * lpFormatString,…)函数会带来重入和性能问题，不能在ISR中采用。
这就涉及到一个中断嵌套问题，由于printf之类的glibc函数采用的是缓冲机制，这个缓冲区是共享的，相当于一个全局变量，第一层中断来时，它向缓冲里面写入一些部分内容，恰好这时来了个优先级更高的中断，它同样调用了printf，也向缓冲里面写入一些内容，这样缓冲区的内容就错乱了。
http://www.cnblogs.com/thammer/p/5017329.html " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fbe05c3ddfd4ac1139ef556e5c83826b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-08-14T17:41:44+08:00" />
<meta property="article:modified_time" content="2017-08-14T17:41:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">stm32学习笔记（八）中断服务函数与函数调用的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="threadtitle" style="font-size:14px; line-height:26px; word-wrap:break-word; margin-bottom:8px; border-bottom-width:1px; border-bottom-style:dashed; border-bottom-color:rgb(230,231,225); color:rgb(68,68,68); font-family:Verdana,Helvetica,Arial,sans-serif"> 
 <div class="threadtags" style="word-wrap:break-word; margin-top:-8px; padding-left:20px; color:rgb(153,153,153); background-color:initial"> 
  <a target="_blank" href="http://bbs.nwpu.edu.cn/npubbs/tag.php?name=%E7%A8%8B%E5%BA%8F" rel="nofollow noopener noreferrer" style="color:rgb(51,51,51); text-decoration:none; word-wrap:break-word; line-height:30px; margin-right:6px">程序</a>,  
  <a target="_blank" href="http://bbs.nwpu.edu.cn/npubbs/tag.php?name=%E4%B8%AD%E6%96%AD" rel="nofollow noopener noreferrer" style="color:rgb(51,51,51); text-decoration:none; word-wrap:break-word; line-height:30px; margin-right:6px">中断</a>,  
  <a target="_blank" href="http://bbs.nwpu.edu.cn/npubbs/tag.php?name=%E8%B0%83%E7%94%A8" rel="nofollow noopener noreferrer" style="color:rgb(51,51,51); text-decoration:none; word-wrap:break-word; line-height:30px; margin-right:6px">调用</a>,  
  <a target="_blank" href="http://bbs.nwpu.edu.cn/npubbs/tag.php?name=%E5%87%BD%E6%95%B0" rel="nofollow noopener noreferrer" style="color:rgb(51,51,51); text-decoration:none; word-wrap:break-word; line-height:30px; margin-right:6px">函数</a> 
 </div> 
</div> 
<p style="word-wrap:break-word; min-height:100px; font-family:Verdana,Helvetica,Arial,sans-serif"> </p> 
<table cellspacing="0" cellpadding="0" style="color:rgb(68,68,68); font-size:14px; line-height:26px; word-wrap:break-word; empty-cells:show; border-collapse:collapse; width:600px; table-layout:fixed; margin-left:1px"><tbody style="word-wrap:break-word"><tr style="word-wrap:break-word"><td class="t_msgfont" id="postmessage_562179" style="word-wrap:break-word; color:rgb(68,68,68); font-family:Verdana,Helvetica,Arial,sans-serif; font-size:14px; line-height:1.6em"> 在《微机原理》和《<span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">计算机</span>组成》等课程[1-4]教学中（本文以MCS-51单片机为例），中断过程既是教学难点又是教学重点，它与主程序调用子程序过程有一定相似性，但又有很大区别，调用子程序过程相对比较容易掌握，通过把两过程结合起来，采用比较教学方法，能收到了很好的教学效果。 <br style="word-wrap:break-word; line-height:normal"> 1、两过程定义与作用<br style="word-wrap:break-word; line-height:normal">     子程序是微机基本程序结构中的1种，基本程序结构包括顺序（简单）、分支（判断）、循环、子程序和查表等5种。<br style="word-wrap:break-word; line-height:normal">     子程序是一组可以公用的指令序列，只要给出子程序的入口地址就能从主程序转入子程序。子程序在功能上具有相对的独立性，在执行主程序的过程中往往被多次调用，甚至被不同的程序所调用。一般微机首先执行主程序，碰到调用指令就转去执行子程序，子程序执行完后，返回指令就返回主程序断点（即调用指令的下一条指令），继续执行没有处理完的主程序，这一过程叫做（主程序）调用子程序过程。<br style="word-wrap:break-word; line-height:normal"> 子程序结构可简化程序，防止重复书写错误，并可节省内存空间。计算机中经常把常用的各种通用的程序段编成子程序，提供给用户使用。用户在自己编写的程序中，只要会调用这些子程序，就可大大简化用户编程的困难。 <br style="word-wrap:break-word; line-height:normal">     中断是计算机中央处理单元CPU与外设I/O交换数据的一种方式，除此方式外，还有无条件、条件（查询）、存贮器直接存取DMA和I/O通道等四种方式。由于无条件不可靠，条件效率低，DMA和I/O通道两方式硬件复杂，而中断方式CPU效率高，因此一般大多采用中断方式。<br style="word-wrap:break-word; line-height:normal"> 中断概念是当计算机正在执行某一（主）程序时，收到一中断请求，如果中断响应条件成立，计算机就把正在执行的程序暂停一下，去响应处理这一请求，执行中断服务程序，处理完服务程序后，中断返回指令使计算机返回原来还没有执行完的程序断点处继续执行，这一过程称为中断过程。有了中断，计算机才能具有并行处理，实时处理和故障处理等重要功能。 <br style="word-wrap:break-word; line-height:normal"> 2、两过程的联系与区别<br style="word-wrap:break-word; line-height:normal"> 2.1联系<br style="word-wrap:break-word; line-height:normal">     中断与调用子程序两过程属于完全不同的概念，但它们也有不少相似之处。两者都需要保护断点（即下一条指令地址）、跳至子程序或中断服务程序、保护现场、子程序或中断处理、恢复现场、恢复断点（即返回主程序）。两者都可实现嵌套，即正在执行的子程序再调另一子程序或正在处理的中断程序又被另一新中断请求所中断，嵌套可为多级。<br style="word-wrap:break-word; line-height:normal"> 正是由于这些表面上的相似处，很容易使学生把两者混淆起来，特别是把中断也看为子程序，这就大错特错了。<br style="word-wrap:break-word; line-height:normal"> 2.2区别<br style="word-wrap:break-word; line-height:normal">     中断过程与调用子程序过程相似点是表面的，从本质上讲两者是完全不一样的。<br style="word-wrap:break-word; line-height:normal"> 两者的根本区别主要表现在服务<span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">时间</span>与服务对象不一样上。首先，调用子程序过程发生的时间是已知和固定的，即在主程序中的调用指令（CALL）执行时发生主程序调用子程序，调用指令所在位置是已知和固定的。而中断过程发生的时间一般的随机的，CPU在执行某一主程序时收到中断源提出的中断申请时，就发生中断过程，而中断申请一般由硬件电路产生，申请提出时间是随机的（软中断发生时间是固定的），也可以说，调用子程序是程序设计者事先安排的，而执行中断服务程序是由系统<span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">工作</span>环境随机决定的；其次，子程序完全为主程序服务的，两者属于主从关系，主程序需要子程序时就去调用子程序，并把调用结果带回主程序继续执行。而中断服务程序与主程序两者一般是无关的，不存在谁为谁服务的问题，两者是平行关系；第三，主程序调用子程序过程完全属于<span class="t_tag" style="word-wrap:break-word; line-height:normal; border-bottom-width:1px; border-bottom-style:solid; border-bottom-color:rgb(255,0,0); white-space:nowrap">软件</span>处理过程，不需要专门的硬件电路，而中断处理系统是一个软、硬件结合系统，需要专门的硬件电路才能完成中断处理的过程；第四，子程序嵌套可实现若干级，嵌套的最多级数由计算机内存开辟的堆栈大小限制，而中断嵌套级数主要由中断优先级数来决定，一般优先级数不会很大。</td></tr></tbody></table> 
<span style="font-size:14px">http://blog.csdn.net/douyuhua0918/article/details/7473254<br> </span> 
<p></p> 
<p style="word-wrap:break-word; min-height:100px; font-family:Verdana,Helvetica,Arial,sans-serif"> <span style="font-size:14px"></span></p> 
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px"> 中断是嵌入式系统中重要的组成部分，但是在标准C中不包含中断。许多编译开发商在标准C上增加了对中断的支持，提供新的关键字用于标示中断服务程序 (ISR)，类似于__interrupt、#program interrupt等。当一个函数被定义为ISR的时候，编译器会自动为该函数增加中断服务程序所需要的中断现场入栈和出栈代码。<br> 　　中断服务程序需要满足如下要求：<br> 　　(1)不能返回值；<br> 　　(2)不能向ISR传递参数；<br> 　　(3) ISR应该尽可能的短小精悍；<br> 　　(4) printf(char * lpFormatString,…)函数会带来重入和性能问题，不能在ISR中采用。</p> 
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px">  </p> 
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px"> 　　参阅网上资料和个人的一些理解</p> 
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px"> <strong>　　a.为什么不能有返回值？</strong></p> 
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px"> 　　　　<span style="color:rgb(0,0,255)">中断服务函数的调用是硬件级别的，当中断产生，pc指针强制跳转到对应的中断服务函数入口，进入中断具有随机性，并不是某段代码对其进行调用，那么如果有返回值它的返回值返回给谁?显然这个返回值毫无意义，如果有返回值，它必定需要进行压栈操作，这样一来何时出栈怎么出栈将变得无法解决。</span></p> 
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px"> <strong>　　b.不能向ISR传递参数?</strong></p> 
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px"> 　　　　<span style="color:rgb(0,0,255)">同理，也是由于这样会破坏栈的原因，因为函数传递参数必定会要求压栈出栈操作，由于进入中断服务函数的随机行，谁给它传递参数都成问题</span></p> 
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px"> <strong>　　c.ISR应尽可能的短小精悍?</strong></p> 
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px"> 　　　　<span style="color:rgb(0,0,255)">如果某个中断频繁产生，而它对应的ISR相当的耗时，那么对中断的响应就会无限的延迟，会丢掉很多的中断请求</span></p> 
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px"> <strong>　　d.printf(char * lpFormatString,…)函数会带来重入和性能问题，不能在ISR中采用。</strong></p> 
<p style="margin:10px auto; font-family:Verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25.2px"> 　　　　<span style="color:rgb(0,0,255)">这就涉及到一个中断嵌套问题，由于printf之类的glibc函数采用的是缓冲机制，这个缓冲区是共享的，相当于一个全局变量，第一层中断来时，它向缓冲里面写入一些部分内容，恰好这时来了个优先级更高的中断，它同样调用了printf，也向缓冲里面写入一些内容，这样缓冲区的内容就错乱了。</span></p> http://www.cnblogs.com/thammer/p/5017329.html 
<br> 
<p style="word-wrap:break-word; min-height:100px; font-family:Verdana,Helvetica,Arial,sans-serif"> <span style="font-size:14px"><br> </span></p> 
<p style="word-wrap:break-word; min-height:100px; font-family:Verdana,Helvetica,Arial,sans-serif"> <span style="font-size:14px"><br> </span></p> 
<p style="word-wrap:break-word; min-height:100px; font-family:Verdana,Helvetica,Arial,sans-serif"> <span style="font-size:14px"><br> </span></p> 
<p style="word-wrap:break-word; min-height:100px; font-family:Verdana,Helvetica,Arial,sans-serif"> <span style="font-size:14px"><br> </span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aeec84988a722ca15b3c546571c049a4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">给初学PLC编程的朋友几点建议</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/42c9525f4da44826bd1b449dd20c2e84/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何将CVBS模拟视频转换成 CSI-2数字视频</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>