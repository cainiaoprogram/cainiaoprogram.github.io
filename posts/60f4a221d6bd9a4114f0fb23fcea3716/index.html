<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python修饰符 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python修饰符" />
<meta property="og:description" content="修饰符基础——闭包 什么是闭包呢？标准的概念大家可以看wikipedia上的解释 点击打开链接 举个例子： def do_add(base): def add(increase): return base &#43; increase return add do_add函数里嵌套了一个内层函数add，这个内层函数就是一个闭包，其实可以也不用管这个“闭包”的概念，先来看下这种模式解决些什么问题. 调用do_add函数：a = do_add(23)，由于内层的函数add里的逻辑用到了do_add函数的入参，而这时这个入参base绑定了值23，由于do_add函数返回的是函数add，所以这时的a其实就是内部的add绑定了23的函数add；同理可知，b = do_add(44)，这里的b就是内部add绑定了44的函数add，a和b这两个add函数是不相同的，因为内部add绑定的值不同，只是两个函数的模板相同罢了，这时我们执行a(100)得到结果是123，b(100)得到结果是144。这样做有什么用呢？其实可以这样看：我们可以把a = do_add(23)和b = do_add(44)看成是配置过程，23和44是配置信息，a(100)和b(100)根据不同的配置获得不同的结果，这样我们就可以解决开发中“根据配置信息不同获得不同结果”的问题
而修饰符实际上就是闭包一种形式，只是配置过程参数是所修饰的一个函数，并且用@符号代替了a=do_add(23)这样的配置方式，下面看一下修饰符的用法 修饰符用法 修饰符无参数，原函数无参数 import time def timeit(func): def wrapper(): start = time.clock() func() end =time.clock() print &#39;used:&#39;, end - start return wrapper @timeit def foo(): print &#39;in foo()&#39; foo() 如上代码：对所修饰函数运行时间的进行统计，最后修饰过的 foo() 等价于 foo=timeit(foo) 而timeit返回wrapper，归根到底真正执行的是wrapper
在实际应用中，函数很少没有参数，所以我们看看foo有参数的情况下，修饰符怎么用
修饰符无参数，原函数有参数 import time def timeit(func): def wrapper(args): start = time.clock() func(args) end =time." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/60f4a221d6bd9a4114f0fb23fcea3716/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-01-30T15:35:35+08:00" />
<meta property="article:modified_time" content="2013-01-30T15:35:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python修饰符</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>修饰符基础——闭包</h4> 
<div> 
 <blockquote style="margin:0 0 0 40px; border:none; padding:0px"> 
  <div>
    什么是闭包呢？标准的概念大家可以看wikipedia上的解释 
   <a href="http://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_%28%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%29" rel="nofollow">点击打开链接</a>   举个例子： 
  </div> 
  <div> 
   <pre><code class="language-python">def do_add(base):
    def add(increase):
        return base + increase
    return add</code></pre> 
   <br> 
   <span style="font-family:Verdana,san-serif,宋体; line-height:20.390625px">do_add函数里嵌套了一个内层函数add，这个内层函数就是一个闭包，其实可以也不用管这个“闭包”的概念，先来看下这种模式解决些什么问题.</span> 
   <br> 
  </div> 
  <div> 
   <span style="font-family:Verdana,san-serif,宋体; line-height:20.390625px"><span style="font-family:Verdana,san-serif,宋体; line-height:20.390625px"><br> </span></span> 
  </div> 
  <div> 
   <span style="font-family:Verdana,san-serif,宋体; line-height:20.390625px"><span style="font-family:Verdana,san-serif,宋体; line-height:20.390625px">调用do_add函数：a = do_add(23)，由于内层的函数add里的逻辑用到了do_add函数的入参，而这时这个入参base绑定了值23，由于do_add函数返回的是函数add，所以这时的a其实就是内部的add绑定了23的函数add；同理可知，b = do_add(44)，这里的b就是内部add绑定了44的函数add，a和b这两个add函数是不相同的，因为内部add绑定的值不同，只是两个函数的模板相同罢了，这时我们执行a(100)得到结果是123，b(100)得到结果是144。这样做有什么用呢？其实可以这样看：我们可以把a = do_add(23)和b = do_add(44)看成是配置过程，23和44是配置信息，a(100)和b(100)根据不同的配置获得不同的结果，这样我们就可以解决开发中“根据配置信息不同获得不同结果”的问题</span><br> </span> 
  </div> 
  <div> 
   <span style="font-family:Verdana,san-serif,宋体; line-height:20.390625px"><span style="font-family:Verdana,san-serif,宋体; line-height:20.390625px"><br> </span></span> 
  </div> 
  <div> 
   <span style="font-family:Verdana,san-serif,宋体"><span style="line-height:20.390625px">而修饰符实际上就是闭包一种形式，只是配置过程参数是所修饰的一个函数，并且用@符号代替了a=do_add(23)这样的配置方式，下面看一下修饰符的用法</span></span> 
  </div> 
 </blockquote> 
 <p><br> </p> 
 <h4><span style="font-family:Verdana,san-serif,宋体"><span style="line-height:20.390625px">修饰符用法</span></span></h4> 
</div> 
<blockquote style="margin:0 0 0 40px; border:none; padding:0px"> 
 <span style="font-family:Verdana,san-serif,宋体"><span style="line-height:20.390625px"></span></span> 
 <p><br> </p> 
 <h5>修饰符无参数，原函数无参数</h5> 
 <pre><code class="language-python">import time
 
def timeit(func):
    def wrapper():
        start = time.clock()
        func()
        end =time.clock()
        print 'used:', end - start
    return wrapper
 
@timeit
def foo():
    print 'in foo()'
 
foo()</code></pre> 
 <br> 
 <p><span style="font-family:Verdana,san-serif,宋体"><span style="line-height:20.390625px">如上代码：对所修饰函数运行时间的进行统计，最后修饰过的 foo()  等价于 foo=timeit(foo) 而timeit返回wrapper，归根到底真正执行的是wrapper</span></span></p> 
 <p><span style="font-family:Verdana,san-serif,宋体"><span style="line-height:20.390625px">在实际应用中，函数很少没有参数，所以我们看看foo有参数的情况下，修饰符怎么用</span></span></p> 
 <p><br> </p> 
 <p><span style="font-family:Verdana,san-serif,宋体"><span style="line-height:20.390625px"></span></span></p> 
 <h5 style="font-family:Verdana,san-serif,宋体; line-height:20.390625px">修饰符无参数，原函数有参数</h5> 
 <pre><code class="language-python">import time
 
def timeit(func):
    def wrapper(args):
        start = time.clock()
        func(args)
        end =time.clock()
        print 'used:', end - start
    return wrapper
 
@timeit
def foo(arg):
    print 'in foo(),arg is' + arg
	foo("aaaaa")
</code></pre> 
 <p></p> 
 <p><br> </p> 
 <p>上述过程可以简化如下：</p> 
 <p><span style="font-family:Verdana,san-serif,宋体"><span style="line-height:20.390625px"><span style="margin:0px; padding:0px; font-family:verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px"><span style="margin:0px; padding:0px">[decorated</span></span><span style="font-family:verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px">] foo(‘aaaaa’)   =&gt;   timeit(foo)(‘aaaaa’)  =&gt;  wrapper(‘aaaaa’)  =&gt;  [</span><span style="margin:0px; padding:0px; font-family:verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px"><span style="margin:0px; padding:0px">real</span></span><span style="font-family:verdana,Arial,Helvetica,sans-serif; font-size:14px; line-height:25px">] foo(‘aaaaa’)</span><br> </span></span></p> 
 <p><span style="font-family:Verdana,san-serif,宋体"><span style="line-height:20.390625px">如果修饰符函数也有参数，又怎么用呢？</span></span></p> 
 <p><br> </p> 
 <h5 style="font-family:Verdana,san-serif,宋体; line-height:20.390625px">修饰符有参数，原函数有参数</h5> 
 <div> 
  <pre><code class="language-python">import time
 
def timeit(s):
  def wrapper1(func)
    def wrapper2(args):
        print "the decorator's arg is"+s
        start = time.clock()
        func(args)
        end =time.clock()
        print 'used:', end - start
    return wrapper2
  return wrapper1

@timeit(s="hello")
def foo(arg):
    print 'in foo(),arg is' + arg
foo("aaaaa")


同理，就是多加了一层闭包。
</code></pre> 
 </div> 
 <p><br> </p> 
 <h5>应用多个修饰符</h5> 
 <div>
   这个记住一个结论就好了，就是修饰符从离原函数最近的开始包裹，最外层的修饰符最后包裹 
 </div> 
 <div> 
  <br> 
 </div> 
</blockquote> 
<h4>应用举例——<span style="font-family:'lucida sans unicode',arial,'times new roman',sans-serif; font-size:13px"><strong>Fibonacci数列</strong></span></h4> 
<blockquote style="margin:0 0 0 40px; border:none; padding:0px"> 
 <p><span style="font-family:'lucida sans unicode',arial,'times new roman',sans-serif; font-size:13px"><strong><br> </strong></span></p> 
 <p><span style="font-family:'lucida sans unicode',arial,'times new roman',sans-serif; font-size:13px"></span></p> 
 <pre><code class="language-python">def memoize(f):
    cache = {}
    def helper(x):
        if x not in cache:            
            cache[x] = f(x)
        return cache[x]
    return helper

@memoize()
def fib(n):
    if n in (0, 1):
        return n
    else:
        return fib(n - 1) + fib(n - 2)</code></pre> 
 <br> 
 <br> 
 <p></p> 
</blockquote> 
<h4><span style="font-family:lucida sans unicode,arial,times new roman,sans-serif; font-size:12px"><strong>参考文献</strong></span></h4> 
<blockquote style="margin:0 0 0 40px; border:none; padding:0px"> 
 <p><span style="font-family:lucida sans unicode,arial,times new roman,sans-serif; font-size:12px">1.http://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)<br> </span></p> 
 <p><span style="font-family:lucida sans unicode,arial,times new roman,sans-serif; font-size:12px">2.http://programmingbits.pythonblogs.com/27_programmingbits/archive/50_function_decorators.html</span></p> 
 <p><span style="font-family:lucida sans unicode,arial,times new roman,sans-serif; font-size:12px">3.http://www.python.org/dev/peps/pep-0318/</span></p> 
 <p><span style="font-family:lucida sans unicode,arial,times new roman,sans-serif; font-size:12px">4.http://www.cnblogs.com/Jerry-Chou/archive/2012/05/23/python-decorator-explain.html</span></p> 
 <p><span style="font-family:lucida sans unicode,arial,times new roman,sans-serif; font-size:12px">5.http://www.cnblogs.com/huxi/archive/2011/03/01/1967600.html</span></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f9de7dd06f6326c4f488ebf1cfc6e4a3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">什么是图形加速卡（二）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b9af0d4941e529294c270b132230d513/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">无法从 读取大纲，未安装该文件类型的文本转换程序</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>