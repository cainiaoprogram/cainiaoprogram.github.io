<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构——堆 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构——堆" />
<meta property="og:description" content="目录
一、堆
1.1 堆的概念
1.2 堆的存储
1.3 堆的应用
二、堆的实现
2.1 堆的调整算法
（1）向下调整算法
（2）向上调整算法
2.2 堆的创建
2.3 堆的删除
三、堆的代码实现 四、堆排序
4.1 原理
4.2 代码实现
一、堆 1.1 堆的概念 堆（Heap）是一种特殊的树，如果将一个集合中的所有元素按照完全二叉树的顺序存储方式存储在一个一维数组中，并满足一定的规则，则称为堆。堆的性质有：
堆中任意节点的值总是不大于或不小于其父节点的值堆总是一颗完全二叉树 【拓展补充】：满二叉树每一层都是满的；完全二叉树最后一层可以不满，但是从左到右必须是连续的
接下来引入大小堆的概念，这也是堆在建立之时必须遵循的规则，如果不满足其中任意一种便不能称为堆
大堆（大根堆/最大堆）：树中任何一个父节点都大于或等于子节点，根节点是最大值
小堆（小根堆/最小堆）：树种任何一个父节点都小于或等于子节点，根节点是最小值
1.2 堆的存储 因为堆是一种特殊的完全二叉树，其存储方式与完全二叉树的顺序存储方式相同。
顺序结构存储就是使用数组来存储，一般只有完全二叉树适合用数组来存储，因为非完全二叉树的元素不连续会造成空间的浪费
使用数组来存储，父子节点的关系如下
父节点：（子节点-1）/ 2
左子节点：（父节点*2）&#43;1
右子节点：（父节点*2）&#43;2
1.3 堆的应用 堆排序
TopK问题
优先级队列
二、堆的实现 2.1 堆的调整算法 假设给出一个数组，我们在逻辑上可以将其看作一颗完全二叉树，但是这个数组不能被称为堆。通过使用堆的调整算法我们可以将其调整成一个大/小堆。
（1）向下调整算法 向下调整算法就是将目标节点与左右子节点对比，符合条件则交换
向下调整算法有一个前提：左右子树必须是堆
例如图中，以27为根的左右子树都满足小堆的性质，只有根节点不满足，所以只需要将其与左右子节点中较小的交换即可
（2）向上调整算法 向上调整算法就是将目标节点与父节点对比，符合条件则交换
堆的插入就需要用到向上调整算法，例如我们在一个小堆中插入了一个新的元素：
使用向上调整算法：
2.2 堆的创建 堆的创建是堆排序中的一个重要部分。如果要将一个数组构建成堆，使用向下调整算法是最优解。但是根节点的左右子树都不是堆，所以我们反其道而行之，从最后一个节点的父节点开始进行向下调整。
因为单个节点也能成堆，所以最后一层的所有叶子节点都可以被视为堆，接着我们就对数组进行从后向前遍历，从最后一个节点的父节点开始向下调整
例如这个数组，我们要将其构建成小堆，先将其看作一颗完全二叉树
然后从最后一个节点的父节点开始向下调整，因为要遵循小堆规则所以二者交换
交换完毕，遍历到前一个节点，此时父节点小于两个子节点，所以不需要交换，跳到10
此时父节点是10，左子节点是7，右子节点是3，3比7更小，所以将10与3交换
现在，小堆就建立完毕了
2.3 堆的删除 一般堆的删除是指删除堆顶的数据。但是我们不能直接将数组的元素向前挪动覆盖第一个元素，因为在逻辑结构上，不同节点之间的关系已经建立，如果单纯的进行元素挪动就会打破所有的关系，将整个堆破坏。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4055e87c8a0f188bc3baf996b2bd0a75/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-07T16:21:50+08:00" />
<meta property="article:modified_time" content="2024-01-07T16:21:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构——堆</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E5%A0%86-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%A0%86" rel="nofollow">一、堆</a></p> 
<p id="1.1%20%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#1.1%20%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">1.1 堆的概念</a></p> 
<p id="1.2%20%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8-toc" style="margin-left:40px;"><a href="#1.2%20%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8" rel="nofollow">1.2 堆的存储</a></p> 
<p id="1.3%20%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8-toc" style="margin-left:40px;"><a href="#1.3%20%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8" rel="nofollow">1.3 堆的应用</a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">二、堆的实现</a></p> 
<p id="2.1%20%E5%A0%86%E7%9A%84%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95-toc" style="margin-left:40px;"><a href="#2.1%20%E5%A0%86%E7%9A%84%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95" rel="nofollow">2.1 堆的调整算法</a></p> 
<p id="%EF%BC%881%EF%BC%89%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95" rel="nofollow">（1）向下调整算法</a></p> 
<p id="%EF%BC%882%EF%BC%89%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95" rel="nofollow">（2）向上调整算法</a></p> 
<p id="2.2%20%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:40px;"><a href="#2.2%20%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">2.2 堆的创建</a></p> 
<p id="2.3%20%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#2.3%20%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4" rel="nofollow">2.3 堆的删除</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%A0%86%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%A0%86%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">三、堆的代码实现 </a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F" rel="nofollow">四、堆排序</a></p> 
<p id="4.1%20%E5%8E%9F%E7%90%86-toc" style="margin-left:40px;"><a href="#4.1%20%E5%8E%9F%E7%90%86" rel="nofollow">4.1 原理</a></p> 
<p id="4.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#4.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">4.2 代码实现</a></p> 
<hr> 
<h2 id="%E4%B8%80%E3%80%81%E5%A0%86" style="background-color:transparent;">一、堆</h2> 
<h3 id="1.1%20%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5">1.1 堆的概念</h3> 
<p>堆（Heap）是一种特殊的树，如果将一个集合中的所有元素按照完全二叉树的顺序存储方式存储在一个一维数组中，并满足<span style="color:#fe2c24;">一定的规则</span>，则称为堆。堆的性质有：</p> 
<ul><li>堆中任意节点的值总是不大于或不小于其父节点的值</li><li>堆总是一颗<span style="color:#fe2c24;">完全二叉树</span></li></ul> 
<p> 【拓展补充】：满二叉树每一层都是满的；完全二叉树最后一层可以不满，但是从左到右必须是连续的</p> 
<p><img alt="" height="410" src="https://images2.imgbox.com/69/e2/oWh2yGOy_o.png" width="1025"></p> 
<p>接下来引入大小堆的概念，这也是堆在建立之时必须遵循的规则，如果不满足其中任意一种便不能称为堆</p> 
<p>大堆（大根堆/最大堆）：树中任何一个父节点都大于或等于子节点，根节点是最大值</p> 
<p>小堆（小根堆/最小堆）：树种任何一个父节点都小于或等于子节点，根节点是最小值</p> 
<h3 id="1.2%20%E5%A0%86%E7%9A%84%E5%AD%98%E5%82%A8">1.2 堆的存储</h3> 
<p>因为堆是一种特殊的完全二叉树，其存储方式与完全二叉树的<span style="color:#fe2c24;">顺序存储</span>方式相同。</p> 
<p>顺序结构存储就是使用数组来存储，一般只有完全二叉树适合用数组来存储，因为非完全二叉树的元素不连续会造成空间的浪费</p> 
<p><img alt="" height="407" src="https://images2.imgbox.com/6c/82/JXE5Nh2F_o.png" width="1200"></p> 
<p> 使用数组来存储，<span style="color:#fe2c24;">父子节点的关系</span>如下</p> 
<blockquote> 
 <p>父节点：（子节点-1）/ 2</p> 
 <p>左子节点：（父节点*2）+1</p> 
 <p>右子节点：（父节点*2）+2</p> 
</blockquote> 
<h3 id="1.3%20%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8">1.3 堆的应用</h3> 
<ol><li> <p>堆排序</p> </li><li> <p>TopK问题</p> </li><li> <p>优先级队列</p> </li></ol> 
<hr> 
<h2 id="%E4%BA%8C%E3%80%81%E5%A0%86%E7%9A%84%E5%AE%9E%E7%8E%B0" style="background-color:transparent;">二、堆的实现</h2> 
<h3 id="2.1%20%E5%A0%86%E7%9A%84%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95">2.1 堆的调整算法</h3> 
<p>假设给出一个数组，我们在逻辑上可以将其看作一颗完全二叉树，但是这个数组不能被称为堆。通过使用堆的调整算法我们可以将其调整成一个大/小堆。</p> 
<h4 id="%EF%BC%881%EF%BC%89%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95" style="background-color:transparent;">（1）向下调整算法</h4> 
<p>向下调整算法就是将目标节点与左右子节点对比，符合条件则交换</p> 
<p>向下调整算法有一个前提：左右子树<span style="color:#fe2c24;">必须是堆</span></p> 
<p><img alt="" height="454" src="https://images2.imgbox.com/f5/36/PafqroNn_o.png" width="929"></p> 
<p>例如图中，以27为根的左右子树都满足小堆的性质，只有根节点不满足，所以只需要将其与左右子节点中较小的交换即可</p> 
<p><img alt="" height="335" src="https://images2.imgbox.com/64/f0/6qHX9YXx_o.png" width="1200"></p> 
<h4 id="%EF%BC%882%EF%BC%89%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E7%AE%97%E6%B3%95" style="background-color:transparent;">（2）向上调整算法</h4> 
<p>向上调整算法就是将目标节点与父节点对比，符合条件则交换</p> 
<p>堆的插入就需要用到向上调整算法，例如我们在一个小堆中插入了一个新的元素：</p> 
<p><img alt="" height="514" src="https://images2.imgbox.com/b7/40/AKKiOCKx_o.png" width="1194"></p> 
<p>使用向上调整算法：</p> 
<p><img alt="" height="368" src="https://images2.imgbox.com/c9/ea/MXLArXCi_o.png" width="1200"></p> 
<h3 id="2.2%20%E5%A0%86%E7%9A%84%E5%88%9B%E5%BB%BA" style="background-color:transparent;">2.2 堆的创建</h3> 
<p>堆的创建是堆排序中的一个重要部分。如果要将一个数组构建成堆，使用向下调整算法是最优解。但是根节点的左右子树都不是堆，所以我们反其道而行之，从最后一个节点的父节点开始进行向下调整。</p> 
<p>因为单个节点也能成堆，所以最后一层的所有叶子节点都可以被视为堆，接着我们就对数组进行从后向前遍历，从最后一个节点的父节点开始向下调整</p> 
<p><img alt="" height="104" src="https://images2.imgbox.com/45/52/3uL5vczB_o.png" width="877"></p> 
<p>例如这个数组，我们要将其构建成小堆，先将其看作一颗完全二叉树</p> 
<p><img alt="" height="252" src="https://images2.imgbox.com/f2/84/gBYgYtxB_o.png" width="695"></p> 
<p>然后从最后一个节点的父节点开始向下调整，因为要遵循小堆规则所以二者交换</p> 
<p><img alt="" height="248" src="https://images2.imgbox.com/0c/66/9tawTDGD_o.png" width="611"></p> 
<p>交换完毕，遍历到前一个节点，此时父节点小于两个子节点，所以不需要交换，跳到10</p> 
<p>此时父节点是10，左子节点是7，右子节点是3，3比7更小，所以将10与3交换</p> 
<p><img alt="" height="250" src="https://images2.imgbox.com/9f/c7/wUqskNt5_o.png" width="589"></p> 
<p>现在，小堆就建立完毕了</p> 
<h3 id="2.3%20%E5%A0%86%E7%9A%84%E5%88%A0%E9%99%A4">2.3 堆的删除</h3> 
<p>一般堆的删除是指删除堆顶的数据。但是我们不能直接将数组的元素向前挪动覆盖第一个元素，因为在逻辑结构上，不同节点之间的关系已经建立，如果单纯的进行元素挪动就会打破所有的关系，将整个堆破坏。</p> 
<p>所以我们要先将堆顶的数据和最后一个数据交换，保持中间所有元素在堆中的相对位置不变，然后删除数组的最后一个元素，再进行向下调整。</p> 
<p><img alt="" height="447" src="https://images2.imgbox.com/09/20/7sfYWEm2_o.png" width="1200"></p> 
<hr> 
<h2 id="%E4%B8%89%E3%80%81%E5%A0%86%E7%9A%84%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%C2%A0" style="background-color:transparent;">三、堆的代码实现 </h2> 
<p>以小堆的创建为例，我们先创建一个头文件"Heap.h"和两个源文件"Heap.c"和"Test.c"</p> 
<p>下面是"Heap.h"的代码：</p> 
<pre><code class="language-cpp">#pragma once

#include &lt;stdio.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;assert.h&gt;
#include &lt;stdlib.h&gt;

typedef int HPDataType;

typedef struct Heap
{
	HPDataType* arr;
	int size;
	int capacity;
}Heap;

void HeapInit(Heap* hp);//初始化堆

void HeapDestory(Heap* hp);//销毁堆

void AdjustUp(HPDataType* arr, int child);//向上调整（小堆）

void AdjustDown(HPDataType* arr, int size, int parent);//向下调整（小堆）

void HeapPush(Heap* hp, HPDataType x);//插入数据

void HeapPop(Heap* hp);//删除数据

HPDataType HeapTop(Heap* hp);//获取堆顶数据

int HeapSize(Heap* hp);//堆的有效数据个数

bool HeapEmpty(Heap* hp);//堆的判空</code></pre> 
<p>下面是"Heap.c"的代码：</p> 
<pre><code class="language-cpp">void HeapInit(Heap* hp)//初始化堆
{
	assert(hp);
	hp-&gt;arr = NULL;
	hp-&gt;size = 0;
	hp-&gt;capacity = 0;
}

void HeapDestory(Heap* hp)//销毁堆
{
	assert(hp);
	free(hp-&gt;arr);
	hp-&gt;arr = NULL;
	hp-&gt;size = hp-&gt;capacity = 0;
}

void AdjustUp(HPDataType* arr, int child)//向上调整（小堆）
{
	int parent = (child - 1) / 2;
	while (child &gt; 0)
	{
		if (arr[child] &lt; arr[parent])
		{
			HPDataType tmp = arr[parent];
			arr[parent] = arr[child];
			arr[child] = tmp;
			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}
	}
}

void AdjustDown(HPDataType* arr, int size, int parent)//向下调整（小堆）
{
	int child = parent * 2 + 1;
	while (child &lt; size)
	{
		if (child + 1 &lt; size &amp;&amp; arr[child + 1] &lt; arr[child])
		{
			child = child + 1;
		}
		if (arr[child] &lt; arr[parent])
		{
			HPDataType tmp = arr[child];
			arr[child] = arr[parent];
			arr[parent] = tmp;
			parent = child;
			child = parent * 2 + 1;
		}
		else
		{
			break;
		}
	}
}

void HeapPush(Heap* hp, HPDataType x)//插入数据
{
	assert(hp);
	if (hp-&gt;size == hp-&gt;capacity)
	{
		int newcapacity = hp-&gt;capacity == 0 ? 4 : hp-&gt;capacity * 2;
		HPDataType* tmp = (HPDataType*)realloc(hp-&gt;arr, sizeof(HPDataType) * newcapacity);
		if (tmp == NULL)
		{
			perror("realloc fail");
			return;
		}
		hp-&gt;arr = tmp;
		hp-&gt;capacity = newcapacity;
	}
	hp-&gt;arr[hp-&gt;size] = x;
	hp-&gt;size++;
	AdjustUp(hp-&gt;arr, hp-&gt;size - 1);
}

void HeapPop(Heap* hp)//删除数据
{
	assert(hp);
	assert(!HeapEmpty(hp));
	HPDataType tmp = hp-&gt;arr[hp-&gt;size - 1];
	hp-&gt;arr[hp-&gt;size - 1] = hp-&gt;arr[0];
	hp-&gt;arr[0] = tmp;
	hp-&gt;size--;
	AdjustDown(hp-&gt;arr, hp-&gt;size, 0);
}

HPDataType HeapTop(Heap* hp)//获取堆顶数据
{
	assert(hp);
	assert(!HeapEmpty(hp));
	return hp-&gt;arr[0];
}

int HeapSize(Heap* hp)//堆的有效数据个数
{
	assert(hp);
	return hp-&gt;size;
}

bool HeapEmpty(Heap* hp)//堆的判空
{
	assert(hp);
	return hp-&gt;size == 0;
}</code></pre> 
<p>测试一下：</p> 
<p><img alt="" height="568" src="https://images2.imgbox.com/3a/12/lwiKaPAv_o.png" width="632"></p> 
<hr> 
<h2 id="%E5%9B%9B%E3%80%81%E5%A0%86%E6%8E%92%E5%BA%8F" style="background-color:transparent;">四、堆排序</h2> 
<h3 id="4.1%20%E5%8E%9F%E7%90%86" style="background-color:transparent;">4.1 原理</h3> 
<p>堆排序即利用堆的思想进行排序，分为两个步骤</p> 
<ol><li>建堆</li><li>利用堆的删除思想进行排序</li></ol> 
<p>例如我们要对一个数组进行<span style="color:#fe2c24;">降序排序</span>，我们要先对目标数组进行<span style="color:#fe2c24;">建小堆</span>，然后将根节点（数组第一个元素）与堆的<span style="color:#fe2c24;">有效范围内</span>最后一个节点（数组<span style="color:#fe2c24;">有效范围内</span>最后一个元素）交换，此时数组的最后一个元素就是最小值，将<span style="color:#fe2c24;">有效元素个数-1</span>后进行向下调整。调整完后根节点就是整个数组的第二小值，再重复前面的操作。</p> 
<p><img alt="" height="453" src="https://images2.imgbox.com/e6/db/08aSyk0d_o.png" width="1200"></p> 
<p><img alt="" height="524" src="https://images2.imgbox.com/11/3b/vqOnpZUv_o.png" width="1200"></p> 
<p><img alt="" height="518" src="https://images2.imgbox.com/0d/76/tm7EBokF_o.png" width="1200"></p> 
<p><img alt="" height="496" src="https://images2.imgbox.com/08/f1/1WidgYch_o.png" width="1200"></p> 
<p><img alt="" height="557" src="https://images2.imgbox.com/9f/f2/pesVxH25_o.png" width="1200"></p> 
<p>如果要进行升序排序，就要先建大堆，在函数中修改符号即可</p> 
<h3 id="4.2%20%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" style="background-color:transparent;">4.2 代码实现</h3> 
<p>下面是堆排序的代码</p> 
<pre><code class="language-cpp">void Heapsort(int* a, int size)
{
	for (int i = (size - 1 - 1) / 2; i &gt;= 0; i--)
    // size-1才是最后一个节点，所以(size-1-1)/2才是最后一个节点的父节点
	{
		AdjustDown(a, size, i);
	}
	while (size &gt; 1)
	{
		int tmp = a[0];
		a[0] = a[size - 1];
		a[size - 1] = tmp;
		size--;
		AdjustDown(a, size, 0);
	}
}
</code></pre> 
<p>测试一下</p> 
<p><img alt="" height="251" src="https://images2.imgbox.com/44/1b/ad7lj4Af_o.png" width="762"></p> 
<p>完.</p> 
<p>PS：画图不易，觉得不错就点个赞吧(╹ڡ╹ )</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6a0926cea5030c250a5e0e8a9b2ff7a0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">神秘的HW到底是做什么的？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/166a68a861246bb0fa67c499983c5d30/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Django 9 常用通用视图分析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>