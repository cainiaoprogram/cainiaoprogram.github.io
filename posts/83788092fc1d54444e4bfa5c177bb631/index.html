<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>利用FFmpeg实现录屏、直播推流、音频视频格式转换、剪裁等功能 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="利用FFmpeg实现录屏、直播推流、音频视频格式转换、剪裁等功能" />
<meta property="og:description" content="一、FFmpeg简介。
二、FFmpeg常用参数及命令。
三、FFmpeg在Unity 3D中的使用。
1、FFmpeg 录屏。
2、FFmpeg 推流。
3、FFmpeg 其他功能简述。
一、FFmpeg简介 对于FFmpeg，其官网上是这样介绍的：
FFmpeg is the leading multimedia framework, able to decode, encode, transcode, mux, demux, stream, filter and play pretty much anything that humans and machines have created.
FFmpeg能够实现对视频音频编码、解码、转码、流传输等等一系列功能。它包含有libavcodec, libavutil, libavformat, libavfilter, libavdevice, libswscale，libswresample 库。其中:
libavcodec 是一个包含用于音频/视频编解码器的解码器和编码器的库。
libavutil 是一个包含简化编程功能的库，包括随机数生成器，数据结构，数学例程，核心多媒体实用程序等等。
libavformat 是一个包含多媒体容器格式的解复用器和复用器的库。
libavdevice 是一个包含输入和输出设备的库，用于从许多常见的多媒体输入/输出软件框架中获取和呈现，包括Video4Linux，Video4Linux2，VfW和ALSA。
libavfilter 是一个包含媒体过滤器的库。
libswscale 是一个执行高度优化的图像缩放和色彩空间/像素格式转换操作的库。
libswresample 是一个执行高度优化的音频重采样，重新矩阵化和样本格式转换操作的库。
二、FFmpeg常用参数及命令 1、命令的格式： ffmpeg [global_options] {[input_file_options] -i input_url} ... {[output_file_options] output_url} ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/83788092fc1d54444e4bfa5c177bb631/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-13T14:06:30+08:00" />
<meta property="article:modified_time" content="2023-06-13T14:06:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">利用FFmpeg实现录屏、直播推流、音频视频格式转换、剪裁等功能</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p>一、FFmpeg简介。</p> 
<p>二、FFmpeg常用参数及命令。</p> 
<p>三、FFmpeg在Unity 3D中的使用。<br> 　　1、FFmpeg 录屏。<br> 　　2、FFmpeg 推流。<br> 　　3、FFmpeg 其他功能简述。</p> 
<p></p> 
<h3>一、FFmpeg简介</h3> 
<p>对于FFmpeg，其官网上是这样介绍的：<br> FFmpeg is the leading multimedia framework, able to decode, encode, transcode, mux, demux, stream, filter and play pretty much anything that humans and machines have created.<br> FFmpeg能够实现对视频音频编码、解码、转码、流传输等等一系列功能。它包含有libavcodec, libavutil, libavformat, libavfilter, libavdevice, libswscale，libswresample 库。其中:</p> 
<p>libavcodec      是一个包含用于音频/视频编解码器的解码器和编码器的库。<br> libavutil       是一个包含简化编程功能的库，包括随机数生成器，数据结构，数学例程，核心多媒体实用程序等等。<br> libavformat     是一个包含多媒体容器格式的解复用器和复用器的库。<br> libavdevice     是一个包含输入和输出设备的库，用于从许多常见的多媒体输入/输出软件框架中获取和呈现，包括Video4Linux，Video4Linux2，VfW和ALSA。<br> libavfilter     是一个包含媒体过滤器的库。<br> libswscale      是一个执行高度优化的图像缩放和色彩空间/像素格式转换操作的库。<br> libswresample   是一个执行高度优化的音频重采样，重新矩阵化和样本格式转换操作的库。</p> 
<h3>二、FFmpeg常用参数及命令</h3> 
<h4>1、命令的格式：</h4> 
<p>ffmpeg [global_options] {[input_file_options] -i input_url} ... {[output_file_options] output_url} ...</p> 
<h4>2、常用参数：</h4> 
<p>-f fmt (input/output)   强制设定输入或输出文件格式。通常会自动检测输入文件的格式，并从输出文件的文件扩展名猜测格式，因此大多数情况下不需要这个选项。<br> -i url (input)          输入<br> -y (global)             在没有请求的情况下覆盖输出文件。<br> -n (global)             不要覆盖输出文件，如果指定的输出文件已经存在，则会立即退出。<br> -stream_loop number     设定输入流循环的次数。循环0表示没有循环，循环1表示无限循环<br> -codec/-c               设置编码格式<br> -r fps                  设置帧速率<br> -vcodec codec (output)  设置视频编码格式，同-codec:v<br> -pix_fmt format         设置像素格式<br> -ar freq                设置音频采样频率<br> -aq q (output)          设置音频质量<br> -acodec codec           设置音频编解码器，同-codec:a</p> 
<h4>3、常用命令</h4> 
<p><strong>（1）将视频的帧速率改为24<br> ffmpeg -i input.avi -r 24 output.avi</strong></p> 
<p><strong>（2）视频格式转换，将avi转成mp4<br> ffmpeg -i input.avi output.mp4</strong></p> 
<p><strong>（3）从视频中提取音频<br> ffmpeg -i test.mp4 -acodec libmp3lame output.mp3</strong></p> 
<p><strong>（4）视频剪切<br> ffmpeg -ss 00:00:15 -t 00:00:05 -i input.mp4 -vcodec copy -acodec copy output.mp4</strong></p> 
<p><strong>（5）视频添加Logo<br> ffmpeg -i input.mp4 -i Logo.png -filter_complex overlay output.mp4</strong></p> 
<p><strong>（6）视频去掉Logo<br> ffmpeg -i input.mp4 -vf delogo=0:0:220:90:100:1 output.mp4</strong></p> 
<p><strong>（7）将100张图片合成视频，并为其添加背景音频（注意：图片要放在同一个文件夹下，并将图片按001--100的格式命名）<br> ffmpeg -i 001.mp3 -i %3d.jpg -s 1024x768 -author fy -vcodec mpeg4 darkdoor.avi</strong></p> 
<p><strong>（8）将视频每隔一秒抽取一张图片，保存名字为 foo-001.jpeg, foo-002.jpeg, 等<br> ffmpeg -i foo.avi -r 1 -s WxH -f image2 foo-%03d.jpeg</strong></p> 
<h3> 三、FFmpeg在Unity 3D中的使用</h3> 
<p>有网友问我如何在Unity中使用FFmpeg呢，趁今天老大出差了，忙里偷闲更新一下博客。<br> 使用FFmpeg首先得有FFmpeg，可以直接从官网免费下载，也可以从Unity Store花费85美元下载插件FFmpeg Unity Bind，<br> 如果你有插件FFmpeg Unity Bind，那你就不用再往下看了，因为本文使用的就是FFmpeg Unity Bind的思想：用命令行参数实现FFmpeg的调用。</p> 
<h4>1、命令行调用FFmpeg的核心代码如下：</h4> 
<p> 　　　　public static void Execute(string command)<br>         {<!-- --><br>             if (isRunning)<br>                 return;</p> 
<p>            //Clear output buffer<br>             buffer = new StringBuilder(short.MaxValue);</p> 
<p>            new Thread(() =&gt;<br>             {<!-- --><br>                 isRunning = true;<br>                 Thread.CurrentThread.IsBackground = true;</p> 
<p>                //Execute binary<br>                 p = new Process();<br>                 p.StartInfo.RedirectStandardOutput = true;<br>                 p.StartInfo.RedirectStandardError = true;<br>                 p.StartInfo.UseShellExecute = false;<br>                 p.StartInfo.CreateNoWindow = true;<br>                 p.StartInfo.FileName = binaryPath;<br>                 p.StartInfo.Arguments = command;</p> 
<p><br>                 p.StartInfo.RedirectStandardInput = true;//这句一定需要，用于模拟该进程控制台的输入</p> 
<p>                p.OutputDataReceived += (s, e) =&gt;<br>                 {<!-- --><br>                     callback(FFmpegParser.COMMAND_CODE + FFmpegParser.PROGRESS_CODE + AppendLog(e.Data));<br>                 };<br>                 p.ErrorDataReceived += (s, e) =&gt;<br>                 {<!-- --></p> 
<p>                    if (!string.IsNullOrEmpty(e.Data) &amp;&amp; e.Data.ToLower().Contains("error"))<br>                         callback(FFmpegParser.ERROR_CODE + AppendLog(e.Data));<br>                     else<br>                         callback(FFmpegParser.COMMAND_CODE + FFmpegParser.PROGRESS_CODE + AppendLog(e.Data));<br>                 };</p> 
<p>                p.Start();</p> 
<p>                callback(FFmpegParser.COMMAND_CODE + FFmpegParser.START_CODE + "\nStarted\n");</p> 
<p>                p.BeginOutputReadLine();<br>                 p.BeginErrorReadLine();</p> 
<p>                p.WaitForExit();</p> 
<p>                if (isStopProcessWhatIthink)<br>                 {<!-- --><br>                     callback(FFmpegParser.COMMAND_CODE + FFmpegParser.SUCCESS_CODE + AppendLog("主动关闭 FFmpeg 进程") );<br>                     isStopProcessWhatIthink = false;<br>                 }<br>                 else<br>                 {<!-- --><br>                     callback(FFmpegParser.COMMAND_CODE +<br>                              (p.ExitCode == 0 ?<br>                               FFmpegParser.SUCCESS_CODE + AppendLog("Success!") :<br>                               FFmpegParser.FAILURE_CODE + AppendLog("Failure. Search details above")));<br>                     p.Close();<br>                 }<br>                 callback(FFmpegParser.COMMAND_CODE + FFmpegParser.FINISH_CODE + "\nFinished\n");<br>                 isRunning = false;<br>             }).Start();<br>         }</p> 
<p>        /// </p> 
<p>        /// 主动退出进程<br>         /// </p> 
<p>        public static void CloseFFmpegProcess()<br>         {<!-- --><br>             if (p!=null)<br>             {<!-- --><br>                 try<br>                 {<!-- --></p> 
<p>                    p.StandardInput.WriteLine("q");//在这个进程的控制台中模拟输入q,用于暂停录制<br>                     p.Close();<br>                     p.Dispose();</p> 
<p>                    isRunning = false;</p> 
<p><br>                     isStopProcessWhatIthink = true;<br>                     p = null;<br>                     UnityEngine.Debug.Log("主动退出FFmpeg进程");<br>                 }<br>                 catch (Exception)<br>                 {<!-- --><br>                     UnityEngine.Debug.Log("No process to kill");<br>                 }</p> 
<p>            }<br>             else<br>             {<!-- --><br>                 UnityEngine.Debug.Log("FFmpeg process is null");</p> 
<p>            }<br>         }</p> 
<h4>2、FFmpeg 录屏、推流常用命令</h4> 
<p>//推流命令<br> //-re -i C:\output.mp4  -vcodec libx264 -acodec copy  -f flv -y rtmp://***/live/chid<br> //拉流<br> //-i rtmp://127.0.0.1/live/chid -acodec copy -vcodec copy -f flv -y chid.mp4<br> //-i rtmp://127.0.0.1/live/chid -c copy dump.flv<br>  <br> // rtsp 推流<br> // -i C:\output.mp4  -vcodec libx264 -f rtsp rtsp://***/myid<br> //-f gdigrab -i desktop -vcodec libx264 -preset ultrafast -acodec libmp3lame -ar 44100 -ac 1 -f rtsp rtsp://***/myid<br> //推 摄像头<br> //-f dshow -i video="HD Pro Webcam C920" -vcodec libx264 -acodec copy -preset:v ultrafast -tune:v zerolatency -f rtsp rtsp://***/myid<br> //音视频录制<br> //-f dshow -video_size 1680x1050 -framerate 30 -pixel_format yuv420p -i audio="麦克风 (HD Pro Webcam C920)" av-out.mp4</p> 
<p>        //-f fmt    指定格式（音视频的格式）<br> //dshow<br> //-i        输入<br> //-vcodec   强制使用codec编解码方式(\'copy\' to copy stream)<br> //libx264  <br> //-acodec   指定音频编码(\'copy\' to copy stream)<br> //copy     <br> //-preset  <br> //-tune    <br> //-y        覆盖已有文件<br> //-c       <br>  <br> //传输的图像为灰色的解决办法，添加：-pix_fmt yuv420p<br> //录制桌面：desktop<br> //录制窗口：title=窗口名<br> // av_interleaved_write_frame(): Broken pipe 问题:在-f rtsp后面加一个-rtsp_transport tcp<br>  <br> //录制整个程序窗口<br> //string command = "-f gdigrab -i title=test -vcodec libx264 -preset ultrafast -pix_fmt yuv420p -acodec libmp3lame -ar 44100 -ac 1 -f rtsp -rtsp_transport tcp rtsp://***/myid";<br>  <br> //录制某一区域（这里是摄像头区域）<br> //-offset_x 10 -offset_y 20 -video_size 640x480 从屏幕的（10,20）点处开始，抓取640x480的屏幕<br> //-s 640x480   指定分辨率 (640x480)<br> //-r 60 设置帧率 （和程序的fps保持一致，解决Past duration 0.692253 too large的问题）<br> //string command = "-f gdigrab -offset_x 920 -offset_y 85 -video_size 320*240 -s 320*240 -i title=test -vcodec libx264 -preset ultrafast -pix_fmt yuv420p -r 60 -acodec libmp3lame -ar 44100 -ac 1 -f rtsp -rtsp_transport tcp rtsp://***/myid";<br> //string command = "-f gdigrab -offset_x 920 -offset_y 85 -video_size 320*240 -s 320*240 -i title=test -f dshow -i audio=\""+ micName + "\" -vcodec libx264 -preset ultrafast -pix_fmt yuv420p -r 60 -acodec aac -ar 16000 -ac 1 -f rtsp -rtsp_transport tcp rtsp://***/myid";<br>  <br> //输入交换视频和音频的位置，画面不卡顿了<br> //string command = "-f dshow -i audio=\"" + micName + "\" -f gdigrab -offset_x 920 -offset_y 85 -video_size 320*240 -s 320*240 -i title=test -vcodec libx264 -preset ultrafast -pix_fmt yuv420p -f rtsp -rtsp_transport tcp "+ ClientController.rtspId;<br> //FFmpegCommands.DirectInput(command);<br>  <br> //-re（输入）主要用于模拟抓取设备或实时输入流（例如，从文件读取时）。不应与实际的抓取设备或实时输入流一起使用（它可能导致数据包丢失）。默认情况下，ffmpeg尝试尽快读取输入。此选项将减慢输入读取到输入的本机帧速率。它对于实时输出（例如直播）非常有用。<br> //string command = "-re -i \"" + path + "\" -vcodec libx264 -preset ultrafast -pix_fmt yuv420p -f rtsp -rtsp_transport tcp " +ClientController.rtspId;</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c532d775b5f0e258584587a7e5dcfa46/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">DAY5 理解输入输出函数（scanf、printf、getchar、putchar）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/31d08bf6c81151cfe18ad767dfedfa79/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mac卸载node环境</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>