<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>WEB服务器-TCP协议之三次握手与四次挥手 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="WEB服务器-TCP协议之三次握手与四次挥手" />
<meta property="og:description" content="本文经过借鉴书籍资料【图解HTTP】、他人博客总结出的知识点。如有冒犯，欢迎联系。
三次握手 与 四次挥手 三次握手：建立连接，保证双方准备资源
四次挥手：断开连接，将资源释放掉
所谓三次握手（Three-Way Handshake）即建立TCP连接，是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。
所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。
HTTP与TCP 的区别 HTTP是应用层协议，TCP是传输层协议！ 从本质上来说，二者没有可比性。Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。而在这个过程中，也就是数据包在网络传输过程中，HTTP被封装在TCP包内！客户端发送的每一次请求，都需要服务端的返回响应。客户端在收到服务端的响应后，主动关闭连接通道。至此，一次TCP连接过程完成。
TCP协议 TCP协议属于传输层协议（UDP也属于传输层协议，但是UDP协议是无状态的）。建立一个TCP连接需要三次握手，断开一个TCP连接需要四次挥手。TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。 TCP报文格式 TCP报文格式图
上图中有几个字段需要重点介绍下：
序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq&#43;1。
标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：
URG：紧急指针（urgent pointer）有效。
ACK：确认序号有效。
PSH：接收方应该尽快将这个报文交给应用层。
RST：重置连接。
SYN：发起一个新连接。
FIN：释放一个连接
TCP三次握手连接和四次挥手断开过程详解 TCP 建立连接需要三次握手 三次握手过程理解
建立连接的过程，主要步骤如下：
第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j&#43;1），同时自己也发送一个SYN包（syn=k），即SYN&#43;ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN&#43;ACK包，向服务器发送确认包ACK(ack=k&#43;1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
TCP 断开连接需要四次挥手 四次挥手过程理解
断开连接的过程，主要步骤如下：
客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。服务器收到连接释放报文，发出确认报文，ACK=1，ack=u&#43;1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u&#43;1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w&#43;1，而自己的序列号是seq=u&#43;1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。 关于四次挥手
先由客户端向服务器端发送一个FIN，请求关闭数据传输。
当服务器接收到客户端的FIN时，向客户端发送一个ACK，其中ack的值等于FIN&#43;SEQ
然后服务器向客户端发送一个FIN，告诉客户端应用程序关闭。
当客户端收到服务器端的FIN是，回复一个ACK给服务器端。其中ack的值等于FIN&#43;SEQ
为什么要四次挥手？
确保数据能够完整传输。
当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。
但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET,它可能还需要发送一些数据给主动方后，
再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。
典型面试题 关于三次握手与四次挥手通常都会有典型的面试题，在此提出供有需求的兄弟姐妹们参考：
1、三次握手是什么或者流程？四次握手呢？
答案前面分析就是。 2、为什么建立连接是三次握手，而关闭连接却是四次挥手呢？
这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。 而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了， 所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接. 因此，己方ACK和FIN一般都会分开发送。 3、为什么不能用两次握手进行连接？
3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)， 也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。 现在把三次握手改成仅需要两次握手，死锁是可能发生的。 作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组， S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了， 可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好， 不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下， C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。 而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。 4、如果已经建立了连接，但是客户端突然出现故障了怎么办？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/69cfac1b86fca11e7c7a0262eda86afd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-20T15:27:45+08:00" />
<meta property="article:modified_time" content="2019-04-20T15:27:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">WEB服务器-TCP协议之三次握手与四次挥手</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><mark>本文经过借鉴书籍资料【<strong>图解HTTP</strong>】、他人博客总结出的知识点。如有冒犯，欢迎联系。</mark></p> 
<h3><a id="___2"></a>三次握手 与 四次挥手</h3> 
<ul><li> <p>三次握手：建立连接，保证双方准备资源</p> </li><li> <p>四次挥手：断开连接，将资源释放掉</p> </li><li> <p>所谓三次握手（Three-Way Handshake）即建立TCP连接，是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。</p> </li><li> <p>所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。在socket编程中，这一过程由客户端或服务端任一方执行close来触发。</p> </li></ul> 
<h4><a id="HTTPTCP__10"></a>HTTP与TCP 的区别</h4> 
<ul><li>HTTP是应用层协议，TCP是传输层协议！</li></ul> 
<p>从本质上来说，二者没有可比性。Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。<mark>而在这个过程中，也就是数据包在网络传输过程中，HTTP被封装在TCP包内！客户端发送的每一次请求，都需要服务端的返回响应。客户端在收到服务端的响应后，主动关闭连接通道。至此，一次TCP连接过程完成。</mark></p> 
<h4><a id="TCP_16"></a>TCP协议</h4> 
<ul><li>TCP协议属于传输层协议（UDP也属于传输层协议，但是UDP协议是无状态的）。建立一个TCP连接需要三次握手，断开一个TCP连接需要四次挥手。</li><li>TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。</li></ul> 
<h5><a id="TCP_21"></a>TCP报文格式</h5> 
<p><strong>TCP报文格式图</strong></p> 
<p><img src="https://images2.imgbox.com/22/5c/dUgd5fLy_o.png" alt="tcp-报文"></p> 
<p><strong>上图中有几个字段需要重点介绍下：</strong></p> 
<ul><li> <p>序号：Seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。</p> </li><li> <p>确认序号：Ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。</p> </li><li> <p>标志位：共6个，即URG、ACK、PSH、RST、SYN、FIN等，具体含义如下：</p> 
  <ul><li> <p>URG：紧急指针（urgent pointer）有效。</p> </li><li> <p>ACK：确认序号有效。</p> </li><li> <p>PSH：接收方应该尽快将这个报文交给应用层。</p> </li><li> <p>RST：重置连接。</p> </li><li> <p>SYN：发起一个新连接。</p> </li><li> <p>FIN：释放一个连接</p> </li></ul> </li></ul> 
<h4><a id="TCP_49"></a>TCP三次握手连接和四次挥手断开过程详解</h4> 
<h5><a id="TCP__51"></a>TCP 建立连接需要三次握手</h5> 
<p><strong>三次握手过程理解</strong></p> 
<p><img src="https://images2.imgbox.com/f4/e2/yIzcVO7A_o.png" alt="tcp-3-1"></p> 
<hr> 
<p><img src="https://images2.imgbox.com/8c/21/7wjx5cQt_o.png" alt="tcp-3-2"></p> 
<p><strong>建立连接的过程，主要步骤如下：</strong></p> 
<ul><li> <p>第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。</p> </li><li> <p>第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</p> </li><li> <p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</p> </li></ul> 
<h5><a id="TCP__71"></a>TCP 断开连接需要四次挥手</h5> 
<p><strong>四次挥手过程理解</strong><br> <img src="https://images2.imgbox.com/eb/b7/HX4hNO5s_o.png" alt="tcp-4-1"></p> 
<p><strong>断开连接的过程，主要步骤如下：</strong></p> 
<ul><li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li><li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li><li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li></ul> 
<p><strong>关于四次挥手</strong></p> 
<ul><li> <p>先由客户端向服务器端发送一个FIN，请求关闭数据传输。</p> </li><li> <p>当服务器接收到客户端的FIN时，向客户端发送一个ACK，其中ack的值等于FIN+SEQ</p> </li><li> <p>然后服务器向客户端发送一个FIN，告诉客户端应用程序关闭。</p> </li><li> <p>当客户端收到服务器端的FIN是，回复一个ACK给服务器端。其中ack的值等于FIN+SEQ</p> </li></ul> 
<p><img src="https://images2.imgbox.com/d7/59/CV87ifVG_o.png" alt="tcp-4-2"></p> 
<p><strong>为什么要四次挥手？</strong></p> 
<ul><li> <p>确保数据能够完整传输。</p> </li><li> <p>当被动方收到主动方的FIN报文通知时，它仅仅表示主动方没有数据再发送给被动方了。</p> </li><li> <p>但未必被动方所有的数据都完整的发送给了主动方，所以被动方不会马上关闭SOCKET,它可能还需要发送一些数据给主动方后，</p> </li><li> <p>再发送FIN报文给主动方，告诉主动方同意关闭连接，所以这里的ACK报文和FIN报文多数情况下都是分开发送的。</p> </li></ul> 
<h4><a id="_111"></a>典型面试题</h4> 
<p><strong>关于三次握手与四次挥手通常都会有典型的面试题，在此提出供有需求的兄弟姐妹们参考：</strong></p> 
<p>1、三次握手是什么或者流程？四次握手呢？</p> 
<pre><code>答案前面分析就是。
</code></pre> 
<p>2、为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</p> 
<pre><code>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。
而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，
所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接.
因此，己方ACK和FIN一般都会分开发送。

</code></pre> 
<p>3、为什么不能用两次握手进行连接？</p> 
<pre><code>3次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，
也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。

现在把三次握手改成仅需要两次握手，死锁是可能发生的。
作为例子，考虑计算机S和C之间的通信，假定C给S发送一个连接请求分组，
S收到了这个分组，并发送了确认应答分组。按照两次握手的协定，S认为连接已经成功地建立了，
可以开始发送数据分组。可是，C在S的应答分组在传输中被丢失的情况下，将不知道S 是否已准备好，
不知道S建立什么样的序列号，C甚至怀疑S是否收到自己的连接请求分组。在这种情况下，
C认为连接还未建立成功，将忽略S发来的任何数据分 组，只等待连接确认应答分组。
而S在发出的分组超时后，重复发送同样的分组。这样就形成了死锁。

</code></pre> 
<p>4、如果已经建立了连接，但是客户端突然出现故障了怎么办？</p> 
<pre><code>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。
服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，
若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。
若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。

</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/31aeb7f09474606f8801b96511127345/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">代理模式---论坛权限控制代理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1989c750ac01bc8108823009251cc7ce/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OpenDroneMap</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>