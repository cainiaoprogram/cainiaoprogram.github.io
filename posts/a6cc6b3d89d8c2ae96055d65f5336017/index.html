<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>yocto构建镜像分析(基于STM32MP1157) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="yocto构建镜像分析(基于STM32MP1157)" />
<meta property="og:description" content="yocto构建自定义镜像 本文将基于STM32MP157开发板分析yocto构建镜像的流程，并刨析开发板自带的自定义镜像菜谱是如何设计的，最后尝试编写自己的自定义镜像。
yocto创建镜像流程 OpenEmbedded核心和其他Yocto项目层包括一些样例镜像。这些镜像提供用于典型Linux操作系统栈的根文件系统配置。所有核心镜像菜谱都继承自core-image类,core-image类自己从image类继承。所有镜像设置IMAGE_INSTALL变量来指定什么包被安装进根文件系统。IMAGE_INSTALL可以指定单个包，也可以指定包组（package group）。core-image类提供的默认值安装packagegroup-core-boot和packagegroup-base-extended这两个包组。默认创建启动到控制台的工作的根文件系统。
如果要增加包到根文件系统，可以在conf/local.conf中添=追加IMAGE_INSTALL_append变量，eg:
IMAGE_INSTALL_append&#43;=&#34; demo&#34; 注意双引号中间前面要加空格。
IMAGE_INSTALL_append_pn-&lt;image&gt; : 可以向特定镜像追加包/包组
CORE_IMAGE_EXTRA_INSTALL: core-image类定义的变量，可以使用该变量增加包到所有继承自core-image的镜像。
定制镜像菜谱必须继承image或者core-image类。
inherit core-image 下面介绍一些和创建镜像相关的变量
PACKAGE_CLASSES :在构建环境的conf/local.conf中控制使用什么包管理系统用于构建镜像
IMAGE_FSTYPES：设置一个或者多个由类提供的文件系统类型, tar ext4…
IMAGE_LINGUAS ：添加语言支持到根文件系统或者镜像中
IMAGE_ROOTFS_SIZE:以KB定义被创建的根文件系统镜像大小。
IMAGE_ROOTFS_ALIGNMENT:以KB定义根文件系统镜像的对齐。
IMAGE_ROOTFS_EXTRA_SPACE:以KB定义增加额外可用空间到根文件系统镜像。
IMAGE_OVERHEAD_FACTOR:这个变量指定用于根文件系统镜像的乘数。
EXTRA_USERS_PARMS:用于增加和修改组、用户和密码等命令。
IMAGE_PREPROCESS_COMMAND:在实际根文件系统镜像被创建前进一步地定制根文件系统
ROOTFS_POSTPROCESS_COMMAND：在其已经被构建系统创建后进一步地定制根文件系统
分析STM32MP1开发板bootfs vendorfs userfs生成过程 STM32MP1 yocto里面创建了除rootfs外的三个镜像，bootfs vendorfs 和userfs。
三个bb文件均引用了st-image-partitions.inc，下面先从它开始分析：
st-image-partitions.inc
inherit core-image # Disable flashlayout generation for the partition image as this is supposed # to be done only for complete image ENABLE_FLASHLAYOUT_CONFIG = &#34;0&#34; # Disable image license summary generation for the partition image as this is # supposed to be done only for complete image ENABLE_IMAGE_LICENSE_SUMMARY = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a6cc6b3d89d8c2ae96055d65f5336017/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-26T21:33:17+08:00" />
<meta property="article:modified_time" content="2022-11-26T21:33:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">yocto构建镜像分析(基于STM32MP1157)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="yocto_0"></a>yocto构建自定义镜像</h2> 
<p>本文将基于STM32MP157开发板分析yocto构建镜像的流程，并刨析开发板自带的自定义镜像菜谱是如何设计的，最后尝试编写自己的自定义镜像。</p> 
<h3><a id="yocto_2"></a>yocto创建镜像流程</h3> 
<p>OpenEmbedded核心和其他Yocto项目层包括一些样例镜像。这些镜像提供用于典型Linux操作系统栈的根文件系统配置。所有核心镜像菜谱都继承自core-image类,core-image类自己从image类继承。所有镜像设置<strong>IMAGE_INSTALL</strong>变量来指定什么包被安装进根文件系统。IMAGE_INSTALL可以指定单个包，也可以指定包组（package group）。core-image类提供的默认值安装packagegroup-core-boot和packagegroup-base-extended这两个包组。默认创建启动到控制台的工作的根文件系统。<br> 如果要增加包到根文件系统，可以在conf/local.conf中添=追加IMAGE_INSTALL_append变量，eg:</p> 
<pre><code>IMAGE_INSTALL_append+=" demo"
</code></pre> 
<p>注意双引号中间前面要加空格。<br> IMAGE_INSTALL_append_pn-&lt;image&gt; : 可以向特定镜像追加包/包组<br> CORE_IMAGE_EXTRA_INSTALL: core-image类定义的变量，可以使用该变量增加包到所有继承自core-image的镜像。</p> 
<p>定制镜像菜谱必须继承image或者core-image类。</p> 
<pre><code>inherit core-image
</code></pre> 
<p>下面介绍一些和创建镜像相关的变量</p> 
<p><strong>PACKAGE_CLASSES</strong> :在构建环境的conf/local.conf中控制使用什么包管理系统用于构建镜像<br> <strong>IMAGE_FSTYPES</strong>：设置一个或者多个由类提供的文件系统类型, tar ext4…<br> <strong>IMAGE_LINGUAS</strong> ：添加语言支持到根文件系统或者镜像中<br> <strong>IMAGE_ROOTFS_SIZE</strong>:以KB定义被创建的根文件系统镜像大小。<br> <strong>IMAGE_ROOTFS_ALIGNMENT</strong>:以KB定义根文件系统镜像的对齐。<br> <strong>IMAGE_ROOTFS_EXTRA_SPACE</strong>:以KB定义增加额外可用空间到根文件系统镜像。<br> <strong>IMAGE_OVERHEAD_FACTOR</strong>:这个变量指定用于根文件系统镜像的乘数。<br> <strong>EXTRA_USERS_PARMS</strong>:用于增加和修改组、用户和密码等命令。<br> <strong>IMAGE_PREPROCESS_COMMAND</strong>:在实际根文件系统镜像被创建前进一步地定制根文件系统<br> <strong>ROOTFS_POSTPROCESS_COMMAND</strong>：在其已经被构建系统创建后进一步地定制根文件系统</p> 
<h3><a id="STM32MP1bootfs_vendorfs_userfs_29"></a>分析STM32MP1开发板bootfs vendorfs userfs生成过程</h3> 
<p>STM32MP1 yocto里面创建了除rootfs外的三个镜像，bootfs vendorfs 和userfs。<br> <img src="https://images2.imgbox.com/29/79/PCHrEB1c_o.png" alt="在这里插入图片描述"><br> 三个bb文件均引用了st-image-partitions.inc，下面先从它开始分析：<br> st-image-partitions.inc</p> 
<pre><code>inherit core-image

# Disable flashlayout generation for the partition image as this is supposed
# to be done only for complete image
ENABLE_FLASHLAYOUT_CONFIG = "0"

# Disable image license summary generation for the partition image as this is
# supposed to be done only for complete image
ENABLE_IMAGE_LICENSE_SUMMARY = "0"

# Remove WIC image generation for the partition image
IMAGE_FSTYPES_remove = "${WKS_IMAGE_FSTYPES}"

# Append DISTRO to image name even if we're not using ST distro setting
# Mandatory to ease flashlayout file configuration
IMAGE_BASENAME_append = "${@'' if 'openstlinuxcommon' in OVERRIDES.split(':') else '-${DISTRO}'}"

# Reset image feature
IMAGE_FEATURE = ""

# Reset PACKAGE_INSTALL to avoid getting installed packages added in machine through IMAGE_INSTALL_append:
PACKAGE_INSTALL = ""

# Reset LINGUAS_INSTALL to avoid getting installed any locale-base package
LINGUAS_INSTALL = ""
IMAGE_LINGUAS = ""

# Reset LDCONFIG to avoid runing ldconfig on image.
LDCONFIGDEPEND = ""

# Remove from IMAGE_PREPROCESS_COMMAND useless buildinfo
IMAGE_PREPROCESS_COMMAND_remove = "buildinfo;"
# Remove from IMAGE_PREPROCESS_COMMAND the prelink_image as it could be run after
# we clean rootfs folder leading to cp error if '/etc/' folder is missing:
#   cp: cannot create regular file
#   ‘/local/YOCTO/build/tmp-glibc/work/stm32mp1-openstlinux_weston-linux-gnueabi/st-image-userfs/1.0-r0/rootfs/etc/prelink.conf’:
#   No such file or directory
IMAGE_PREPROCESS_COMMAND_remove = "prelink_image;"

IMAGE_PREPROCESS_COMMAND_append = "reformat_rootfs;"

# Cleanup rootfs newly created
reformat_rootfs() {
    if [ -d ${IMAGE_ROOTFS}${IMAGE_PARTITION_MOUNTPOINT} ]; then
        bbnote "Mountpoint ${IMAGE_PARTITION_MOUNTPOINT} found in ${IMAGE_ROOTFS}"
        bbnote "&gt;&gt;&gt; Remove all files and folder except ${IMAGE_PARTITION_MOUNTPOINT}"
        TARGETROOTFS=${IMAGE_ROOTFS}${IMAGE_PARTITION_MOUNTPOINT}
        while [ "${TARGETROOTFS}" != "${IMAGE_ROOTFS}" ]
        do
            find $(dirname ${TARGETROOTFS})/ -mindepth 1 ! -regex "^${TARGETROOTFS}\(/.*\)?" -delete
            TARGETROOTFS=$(dirname ${TARGETROOTFS})
        done
        bbnote "&gt;&gt;&gt; Move ${IMAGE_PARTITION_MOUNTPOINT} contents to ${IMAGE_ROOTFS}"
        mv ${IMAGE_ROOTFS}${IMAGE_PARTITION_MOUNTPOINT}/* ${IMAGE_ROOTFS}/
        bbnote "&gt;&gt;&gt; Remove remaining ${IMAGE_PARTITION_MOUNTPOINT} folder"
        # Remove empty boot folder
        TARGETROOTFS=${IMAGE_ROOTFS}${IMAGE_PARTITION_MOUNTPOINT}
        while [ "${TARGETROOTFS}" != "${IMAGE_ROOTFS}" ]
        do
            bbnote "&gt;&gt;&gt; Delete ${TARGETROOTFS}"
            rm -rf ${TARGETROOTFS}/
            TARGETROOTFS=$(dirname ${TARGETROOTFS})
        done
    else
        bbwarn "${IMAGE_PARTITION_MOUNTPOINT} folder not available in rootfs folder, no reformat done..."
    fi
}

</code></pre> 
<p>通过 yocto创建镜像流程介绍的部分变量定义大部分内容都比较易懂，主要关注一下reformat_rootfs函数,部分变量可以通过如下命令查看</p> 
<pre><code> bitbake fs-mp1a-qt -e | grep XXX
</code></pre> 
<p>IMAGE_ROOTFS: tmp-glibc/work/fsmp1a-ostl-linux-gnueabi/fs-mp1a-qt/1.0-r0/rootfs<br> IMAGE_PARTITION_MOUNTPOINT_pn-st-image-bootfs=“/boot”<br> IMAGE_PARTITION_MOUNTPOINT_pn-st-image-userfs=“/usr/local”<br> IMAGE_PARTITION_MOUNTPOINT_pn-st-image-vendorfs=“/vendor”</p> 
<h3><a id="_114"></a>创建自己的自定义镜像</h3> 
<p>TODO</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/385713236ba613b7827beb3529af6368/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux系统内核概述</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0f977ad71cc42d3a351fa7f9ce6f455c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">GCC编译错误分析 collect2: error: ld returned 1 exit status</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>