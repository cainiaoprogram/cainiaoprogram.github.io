<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式之依赖倒置设计原则 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式之依赖倒置设计原则" />
<meta property="og:description" content="周末在看《深入理解Java虚拟机》，其中有关于Java虚拟机部分的描述，忽然来了灵感，感觉可以从这个角度来阐述 依赖倒置 设计原则。
最初接触 依赖倒置，是在《HeadFirst设计模式》这本书中，此后，每当业务重构或者开始一个新项目，我都会先翻一翻这本书，常读常新，每次也都会有新的体悟。
一、破题 - Java虚拟机规范和语言规范 Java 在刚刚诞生之时曾经提出过一个非常著名的宣传口号：“一次编写，到处运行”。“与平台无关” 的理想最终实现在操作系统的应用层上：Sun公司以及其他虚拟机提供商发布了许多可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的 “一次编写，到处运行”。各种不同平台的虚拟机与所有操作系统平台都使用同一程序存储格式–字节码(ByteCode)，这也是平台无关性的基石。
有了Java语言，程序员就可以忽略具体操作系统平台(Win、Mac、Linux等)、忽略特定硬件底层指令集(x86、ARM等)，只需要关注Java语言规范，就可以“一次编写，到处运行”。
二、编程思维的依赖倒置 2.1、在 Java 语言出来之前： 程序员需要依赖特定操作系统来完成具体的工作。例如：绘制一个圆，需要调用不同操作系统的GUI绘制库来完成，库的名称以及API接口是不同的，都需要在代码中具体适配。
从依赖关系来看，高层 的应用程序，依赖 低层 的操作系统绘制库。
每当新增一个运行平台，就是在新增依赖一个绘制库。另外，后续该绘制库API改变了或者有了调整，高层的应用程序也需要跟着调整。
2.2、在 Java 语言出来之后： 程序员只需依赖 Java语言规范 即可完成具体的工作，不需要关心平台。例如：绘制一个圆，调用 Java GUI 库的API，Java 虚拟机会与特定的操作系统平台对接，绘制一个圆。
再去看依赖关系，高层 的应用程序，依赖 Java虚拟机或者语言规范，低层组件也依赖Java虚拟机或者语言规范完成功能对接。
每当新增一个运行平台，只要该平台支持 Java虚拟机或者语言规范 ，就什么都没有发生改变，后续该平台绘制库API改变了或者有了调整，高层的应用程序亦不需要跟着调整。
在Java语言出现的前后，程序编写的思维方式也跟着发生了改变。从 高层组件 依赖 低层组件，到 高层组件 和 低层组件 都依赖于 抽象，这里的 抽象 就是 Java虚拟机或者语言规范，或者说 Java 虚拟机 。
三、这和我们的依赖倒置设计原则有什么关系呢？ 其实，上面的开发思维就是“依赖倒置”设计原则，依赖倒置设计原则有如下几种不同的说法：
要依赖抽象，不要依赖具体类针对接口编程，不针对实现编程。不能让高层组件依赖低层组件，两者都应该依赖于抽象。 刚刚接触这个设计模式时，最困惑的莫过于：依赖倒置原则，究竟倒置在哪里？
依赖倒置设计原则中的“倒置”指的是和一般的面向对象的思考方法完全相反。正常思维，先从顶端设计开始，然后往下到具体的低层类设计。依赖倒置设计原则要求我们先别从顶层开始，而是先看看能“抽象化”些什么。
总结 实际的案例中，完美应用依赖倒置设计原则非常难，尤其是新业务的工程架构设计，往往业务稳定铺开一段时间之后，抽象模型才会慢慢变得“清晰”。
更普遍的场景往往是，新需求无法在旧业务架构实现中迭代，不得不做架构设计调整(架构调整的第一目标就是调整前后，业务效果要一模一样，对用户来讲要像什么都没发生过一样。由于不产生新的增量，不到万不得已，不会做架构调整的）。
踩过坑，才会体会依赖倒置的强大，不说了，说多了都是眼泪。
参考资料 Head First 设计模式（中文版）-- [美] 弗里曼（Freeman，E）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2d08a89fe08c32249c19bfd089a7c121/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-03T13:22:47+08:00" />
<meta property="article:modified_time" content="2021-01-03T13:22:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式之依赖倒置设计原则</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>周末在看《<strong>深入理解Java虚拟机</strong>》，其中有关于Java虚拟机部分的描述，忽然来了灵感，感觉可以从这个角度来阐述 <strong>依赖倒置</strong> 设计原则。</p> 
<p>最初接触 <strong>依赖倒置</strong>，是在《<strong>HeadFirst设计模式</strong>》这本书中，此后，每当业务重构或者开始一个新项目，我都会先翻一翻这本书，常读常新，每次也都会有新的体悟。</p> 
<h3><a id="__Java_4"></a>一、破题 - Java虚拟机规范和语言规范</h3> 
<p><code>Java</code> 在刚刚诞生之时曾经提出过一个非常著名的宣传口号：<strong>“一次编写，到处运行”</strong>。<strong>“与平台无关”</strong> 的理想最终实现在操作系统的应用层上：Sun公司以及其他虚拟机提供商发布了许多可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的 <strong>“一次编写，到处运行”</strong>。各种不同平台的虚拟机与所有操作系统平台都使用同一程序存储格式–字节码(ByteCode)，这也是平台无关性的基石。</p> 
<p>有了Java语言，程序员就可以忽略具体操作系统平台(Win、Mac、Linux等)、忽略特定硬件底层指令集(x86、ARM等)，只需要关注Java语言规范，就可以“一次编写，到处运行”。</p> 
<h3><a id="_10"></a>二、编程思维的依赖倒置</h3> 
<h4><a id="21_Java__12"></a>2.1、在 Java 语言出来之前：</h4> 
<p>程序员需要依赖特定操作系统来完成具体的工作。例如：绘制一个圆，需要调用不同操作系统的GUI绘制库来完成，库的名称以及API接口是不同的，都需要在代码中具体适配。</p> 
<p>从依赖关系来看，<strong>高层</strong> 的应用程序，依赖 <strong>低层</strong> 的操作系统绘制库。</p> 
<p>每当新增一个运行平台，就是在新增依赖一个绘制库。另外，后续该绘制库API改变了或者有了调整，<strong>高层</strong>的应用程序也需要跟着调整。</p> 
<h4><a id="22_Java__20"></a>2.2、在 Java 语言出来之后：</h4> 
<p>程序员只需依赖 <strong>Java语言规范</strong> 即可完成具体的工作，不需要关心平台。例如：绘制一个圆，调用 <strong>Java GUI</strong> 库的API，Java 虚拟机会与特定的操作系统平台对接，绘制一个圆。</p> 
<p>再去看依赖关系，<strong>高层</strong> 的应用程序，依赖 <strong>Java虚拟机或者语言规范</strong>，<strong>低层</strong>组件也依赖<strong>Java虚拟机或者语言规范</strong>完成功能对接。</p> 
<p>每当新增一个运行平台，只要该平台支持 <strong>Java虚拟机或者语言规范</strong> ，就什么都没有发生改变，后续该平台绘制库API改变了或者有了调整，<strong>高层</strong>的应用程序亦不需要跟着调整。</p> 
<p>在Java语言出现的前后，程序编写的思维方式也跟着发生了改变。从 高层组件 依赖 低层组件，到 高层组件 和 低层组件 都依赖于 抽象，这里的 抽象 就是 <strong>Java虚拟机或者语言规范</strong>，或者说 <strong>Java 虚拟机</strong> 。</p> 
<h3><a id="_30"></a>三、这和我们的依赖倒置设计原则有什么关系呢？</h3> 
<p>其实，上面的开发思维就是“依赖倒置”设计原则，依赖倒置设计原则有如下几种不同的说法：</p> 
<ul><li>要依赖抽象，不要依赖具体类</li><li>针对接口编程，不针对实现编程。</li><li>不能让高层组件依赖低层组件，两者都应该依赖于抽象。</li></ul> 
<p><strong>刚刚接触这个设计模式时，最困惑的莫过于：依赖倒置原则，究竟倒置在哪里？</strong></p> 
<p>依赖倒置设计原则中的“倒置”指的是和一般的面向对象的思考方法完全相反。正常思维，先从顶端设计开始，然后往下到具体的低层类设计。依赖倒置设计原则要求我们先别从顶层开始，而是先看看能“抽象化”些什么。</p> 
<h3><a id="_42"></a>总结</h3> 
<p>实际的案例中，完美应用依赖倒置设计原则非常难，尤其是新业务的工程架构设计，往往业务稳定铺开一段时间之后，抽象模型才会慢慢变得“清晰”。</p> 
<p>更普遍的场景往往是，新需求无法在旧业务架构实现中迭代，不得不做架构设计调整(架构调整的第一目标就是调整前后，业务效果要一模一样，对用户来讲要像什么都没发生过一样。由于不产生新的增量，不到万不得已，不会做架构调整的）。</p> 
<p>踩过坑，才会体会依赖倒置的强大，<strong>不说了，说多了都是眼泪。</strong></p> 
<h3><a id="_51"></a>参考资料</h3> 
<ol><li> <p><a href="https://union-click.jd.com/jdc?e=&amp;p=AyIGZRlfFwESA1MbUiUBGgVVG18cBhcCVSsfSlpMWGVCHlBDUAxLBQNQVk4YCQQAQB1AWQkFHUVBRhkSQw9THUJVEEMFSgxUVxZPI0AOEQ9XG1sRCxYCUBtrZ0sIZBVHP0lge1cmcih2WEFEKU8hdQ4eN1QrWxQDEg5THV4XAiI3VRxrVGwSAFcbWRQyEzdVHFodABoCXBxSEgMWN1IbUiXXm7uDotvBo6De5o%2BCproTDmUraxYyIjdVK1glQHxXVEwMFFERD1VPXxAHQQVUE1JBB0ABVRxbRlYSVFcTDiUAEwZREg%3D%3D" rel="nofollow">Head First 设计模式（中文版）-- [美] 弗里曼（Freeman，E）</a></p> </li><li> <p><a href="https://union-click.jd.com/jdc?e=&amp;p=AyIGZRhYFQYVBlYcUhIyEgZWHFMWBBsOVisfSlpMWGVCHlBDUAxLBQNQVk4YCQQAQB1AWQkFHUVBRhkSQw9THUJVEEMFSgxUVxZPI0AOEgZWHFMWBBsOVisOHGFAAh1MX3ZdQncTQT5TfEdhVWAdGQ4iBmUbWhQCGwFTHlkVMiIHUisaewcSBlwZaxQyEgBUE1kdBhIGXR5SHTIVB1wrjpy%2BxL7Vz%2Fqn26GTjKjjFAsiN2UYayUyEjdWKxl7VhEDAktZEgAXVFQSXkcDE1cHT1NACkIAVh5eEgQXAQErWRQDFg4%3D" rel="nofollow">大话设计模式 - 程杰著</a></p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2db5ea5d4e6d6163c50105130c09f807/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kotlin 实战经验中的那些坑&#43;最佳实践</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8729ec731231387d0a5fa740cb3bb170/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">STM32的PWM和DAC练习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>