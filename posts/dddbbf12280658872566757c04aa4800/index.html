<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>过滤器和监听器 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="过滤器和监听器" />
<meta property="og:description" content="一、过滤器 什么是过滤器
当浏览器向服务器发送请求的时候，过滤器可以将请求拦截下来，完成一些特殊的功能，比如：编码设置、权限校验、日志记录等。
过滤器执行流程
1.Filter实例 package com.by.servlet; import javax.servlet.*; import java.io.IOException; public class FilterServletDemo implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } //真正执行过滤业务的方法 @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { //设置请求编码格式 servletRequest.setCharacterEncoding(&#34;UTF-8&#34;); //设置响应编码格式 servletResponse.setContentType(&#34;text/html;charset=utf-8&#34;); //获取前端传送过来的数据 System.out.println(&#34;请求进来，经过过滤器......&#34;); //一个web路径，可以配置多个过滤器，这多个过滤器就被称为过滤器链 filterChain.doFilter(servletRequest,servletResponse); System.out.println(&#34;响应过去，经过过滤器.....&#34;); } @Override public void destroy() { } } 使用过滤器需要注意的事项：
1.过滤器必须实现Filter接口。
2.过滤器拦截的请求执行完毕之后，必须要放行，否则我们的请求就不会被执行。
filterChain.doFilter(request,response); //过滤器放行 3.在web.xml来配置过滤器要拦截的资源，当然我们也可以通过xml的方式配置过滤器。
&lt;filter&gt; &lt;filter-name&gt;filterServlet&lt;/filter-name&gt; &lt;filter-class&gt;com.by.servlet.FilterServletDemo&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;filterServlet&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; Filter的拦截路径的配置" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/dddbbf12280658872566757c04aa4800/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-27T15:28:45+08:00" />
<meta property="article:modified_time" content="2023-12-27T15:28:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">过滤器和监听器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、过滤器</h2> 
<ul><li> <p>什么是过滤器</p> </li></ul> 
<p>当浏览器向服务器发送请求的时候，过滤器可以将请求拦截下来，完成一些特殊的功能，比如：编码设置、权限校验、日志记录等。</p> 
<ul><li> <p>过滤器执行流程</p> </li></ul> 
<p><img alt="" height="615" src="https://images2.imgbox.com/25/5d/MJA5mgML_o.png" width="1200"> </p> 
<h3>1.Filter实例</h3> 
<pre><code class="language-java">package com.by.servlet;

import javax.servlet.*;
import java.io.IOException;

public class FilterServletDemo implements Filter {
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }
    //真正执行过滤业务的方法
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
         //设置请求编码格式
        servletRequest.setCharacterEncoding("UTF-8");
        //设置响应编码格式
        servletResponse.setContentType("text/html;charset=utf-8");

         //获取前端传送过来的数据
        System.out.println("请求进来，经过过滤器......");
        //一个web路径，可以配置多个过滤器，这多个过滤器就被称为过滤器链
        filterChain.doFilter(servletRequest,servletResponse);
        System.out.println("响应过去，经过过滤器.....");

    }

    @Override
    public void destroy() {

    }
}
</code></pre> 
<ul><li> <p>使用过滤器需要注意的事项：</p> </li></ul> 
<p>1.过滤器必须实现Filter接口。</p> 
<p>2.过滤器拦截的请求执行完毕之后，必须要放行，否则我们的请求就不会被执行。</p> 
<pre><code class="language-java"> filterChain.doFilter(request,response); //过滤器放行</code></pre> 
<p>3.在web.xml来配置过滤器要拦截的资源，当然我们也可以通过xml的方式配置过滤器。</p> 
<pre><code class="language-java">&lt;filter&gt;
    &lt;filter-name&gt;filterServlet&lt;/filter-name&gt;
    &lt;filter-class&gt;com.by.servlet.FilterServletDemo&lt;/filter-class&gt;
&lt;/filter&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;filterServlet&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;</code></pre> 
<ul><li> <p>Filter的拦截路径的配置</p> </li></ul> 
<p>1.拦截具体的资源路径:/index.jsp，只有访问index.jsp的时候才会被拦截</p> 
<p>2.目录拦截：/user/*，访问/user下的所有资源，都会被拦截</p> 
<p>3.后缀名拦截:*.jsp 访问后缀名为jsp的资源，都会被拦截</p> 
<p>4.拦截所有：/* 访问所有的资源，都会被拦截</p> 
<h3> 2.测试</h3> 
<p>1.创建servlet  </p> 
<pre><code class="language-java">package com.by.servlet;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

public class FilterTestServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        doPost(req,resp);
    }

    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {

        //通过前端的input的name属性获得前端发送的数据
        String username = req.getParameter("username");
        String password = req.getParameter("password");

        System.out.println("username:"+username+"  ==password:"+password);


        //通过浏览器将获得的数据返回到前端界面上,Servlet响应数据到客户端的时候，如果是中文的话，会乱码

        resp.getWriter().write("username:"+username+"  ==password:"+password);
    }
}
</code></pre> 
<p> 2.在web.xml中配置servlet</p> 
<pre><code class="language-java">&lt;servlet&gt;
    &lt;servlet-name&gt;filterTest&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.by.servlet.FilterTestServlet&lt;/servlet-class&gt;
&lt;/servlet&gt;
    &lt;servlet-mapping&gt;
        &lt;servlet-name&gt;filterTest&lt;/servlet-name&gt;
        &lt;url-pattern&gt;/filterTest&lt;/url-pattern&gt;
    &lt;/servlet-mapping&gt;</code></pre> 
<p> 3.创建filter_test.jsp</p> 
<pre><code class="language-java">&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;form action="filterTest" method="post"&gt;
    &lt;input type="text" name="username"/&gt;&lt;br&gt;
    &lt;input type="text" name="password"/&gt;&lt;br&gt;
    &lt;input type="submit" value="提交"&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
<h3>3.结果</h3> 
<p><img alt="" height="225" src="https://images2.imgbox.com/89/40/Bg0TUptj_o.png" width="455"> </p> 
<h2>二、监听器</h2> 
<ul><li> <p>是什么？</p> </li></ul> 
<p>监听器可以监听就是在servletContext，session，request三个对象创建、销毁或者往其中添加修改删除属性时自动执行代码的功能组件。</p> 
<ul><li> <p>Listener分类：Javaweb提供了8个监听器（接口）</p> </li></ul> 
<p><img alt="" height="552" src="https://images2.imgbox.com/62/d6/eboHcTHh_o.png" width="1200"></p> 
<h3>1.listen实例</h3> 
<pre><code class="language-java">package com.by.servlet;

import javax.servlet.ServletContextEvent;
import javax.servlet.ServletContextListener;

public class ListenServletDemo implements ServletContextListener {
    //监听Servlet上下文对象创建的方法
    @Override
    public void contextInitialized(ServletContextEvent servletContextEvent) {
        System.out.println("==============tomcat启动，调用contextInitialized=======================");
    }
    //监听Servlet上下文对象销毁的方法
    @Override
    public void contextDestroyed(ServletContextEvent servletContextEvent) {
        System.out.println("==============tomcat关闭，调用contextDestroyed=======================");
    }
}
</code></pre> 
<ul><li>  在wen.xml中配置servlet</li></ul> 
<pre><code class="language-java"> &lt;!--配置监听器--&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;com.by.listen.MyListener&lt;/listener-class&gt;
    &lt;/listener&gt;</code></pre> 
<h3> 2.结果</h3> 
<p> <img alt="" height="104" src="https://images2.imgbox.com/be/cd/CqCYhWSY_o.jpg" width="1200"></p> 
<h2><img alt="" height="183" src="https://images2.imgbox.com/78/35/myiMy6i7_o.png" width="1200"> 三、总结</h2> 
<p>过滤器<br>      1、是什么？<br>           Filter(过滤器)是一个特殊的servlet，能过滤所有的请求<br>      2、作用?<br>           设置编码格式<br>      3、怎么使用<br>         public class FilterServletDemo implements Filter {<!-- --><br>             ... ...<br>         }</p> 
<p>        &lt;filter&gt;<br>             &lt;filter-name&gt;filterServlet&lt;/filter-name&gt;<br>             &lt;filter-class&gt;com.by.servlet.FilterServletDemo &lt;/filter-class&gt;<br>         &lt;/filter&gt;<br>         &lt;filter-mapping&gt;<br>             &lt;filter-name&gt;filterServlet&lt;/filter-name&gt;<br>             &lt;!--*代表任意请求--&gt;<br>             &lt;url-pattern&gt;/*&lt;/url-pattern&gt;<br>         &lt;/filter-mapping&gt;<br> 十四、监听器<br>     1、是什么？<br>         监听器可以监听ServletContext、session、request对象的创建和销毁，以及其属性的添加、修改、删除时自动执行的代码<br>     2、怎么使用<br>         public class ListenServletDemo implements ServletContextListener {<!-- --><br>             ... ...<br>         }</p> 
<p>        &lt;listener&gt;<br>             &lt;listener-class&gt;com.by.servlet.ListenServletDemo&lt;/listener-class&gt;<br>         &lt;/listener&gt;</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fb67bd9938402f5b5ceb092ac6fc44f3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">中间件系列 - Redis入门到实战(高级篇-最佳实践)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c50ca01cff53ea717c1d427b9c1828cb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">EasyExcel实现百万级数据的导入导出</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>