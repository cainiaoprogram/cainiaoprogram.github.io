<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>“bash: fork: Resource temporarily unavailable”的解决方案 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="“bash: fork: Resource temporarily unavailable”的解决方案" />
<meta property="og:description" content="这两天，我登陆到一台服务器上，偶尔就出现”bash: fork: Resource temporarily unavailable”的提示，这是什么命令都不能用，但偶尔过一会就好了。前两天也没太在意，今天再次遇到，然后找到了根本原因。
当出现”bash: fork: Resource temporarily unavailable”时，一般来说是系统上的进程数量太多了，达到了命令”ulimit -u”的限制。（当系统进程达到限制后，kernel会自动kill掉一些进程，这就是好我过一会又能操作的原因了。）这种情况产生的原因，一是某个程序有bug，不断地fork新的进程消耗系统资源，二是可能中了病毒（恶意程序），比如所谓的fork炸弹。
我进行了如下操作：
[repo@vt-sync jay]$ ulimit -u 1024 [repo@vt-sync jay]$ ps -ef | wc -l 1221 [repo@vt-sync jay]$ ps ux | wc -l 1020 发现当前用户下面居然有1020个进程，我仔细一看，很多的”vgt-sync.sh”之类的进程，这个shell脚本是我自己以前写的啊，里面有一个while的死循环，本来单独运行这个脚本是正确的，没有任何问题，但是我却把它配置到crontab任务中每小时都去运行，这样就会每小时都会新增一个vgt-sync.sh进程，随着时间的推移，本机上的进程就越来越多了，从而导致了上面的问题。 所以，我的找到原因，解决方法就简单了，显示kill掉这些进程，然后修改我的脚本，既然用了crontab就别写死循环了。 [repo@vt-sync jay]$ ps ux | wc -l 1020 [repo@vt-sync jay]$ killall vgt-sync.sh #(wait for several seconds.) [repo@vt-sync jay]$ ps ux | wc -l 12 再来看看我的那个非常简单脚本吧，刚好和crontab结合起来使用就有了bug了。 #! /bin/bash set -x linux_dir=&#34;/home/repo/pub/linux-vgt.git/&#34; xen_dir=&#34;/home/repo/pub/xen-vgt.git/&#34; while [ 1 ] do cd $linux_dir git pull cd $xen_dir git pull sleep 30 done 我遇到的情况是自己的程序bug，下面简单说一下fork炸弹吧。 所谓fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环，fork炸弹并不需要有特别的权限即可对系统造成破坏。现在来看一个最简单的fork炸弹: :() { :|:&amp; };: 一行看似无法理解的只有13个字符的命令，即可占用掉所有系统的资源。其实，这行命令如果这样写成bash script就不难理解了：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1288eb53cf549fd370aafeb736835197/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2014-05-04T15:26:38+08:00" />
<meta property="article:modified_time" content="2014-05-04T15:26:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">“bash: fork: Resource temporarily unavailable”的解决方案</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>这两天，我登陆到一台服务器上，偶尔就出现”bash: fork: Resource temporarily unavailable”的提示，这是什么命令都不能用，但偶尔过一会就好了。前两天也没太在意，今天再次遇到，然后找到了根本原因。<br> <strong>当出现”bash: fork: Resource temporarily unavailable”时，一般来说是系统上的进程数量太多了，达到了命令”ulimit -u”的限制。</strong>（当系统进程达到限制后，kernel会自动kill掉一些进程，这就是好我过一会又能操作的原因了。）这种情况产生的原因，<strong>一是某个程序有bug，不断地fork新的进程消耗系统资源，二是可能中了病毒（恶意程序），比如所谓的fork炸弹。</strong></p> 
<p>我进行了如下操作：</p> 
<p></p> 
<pre><code class="language-plain">[repo@vt-sync jay]$ ulimit  -u
1024
[repo@vt-sync jay]$ ps -ef | wc -l
1221
[repo@vt-sync jay]$ ps ux | wc -l
1020</code></pre> 
<br> 发现当前用户下面居然有1020个进程，我仔细一看，很多的”vgt-sync.sh”之类的进程，这个shell脚本是我自己以前写的啊，里面有一个while的死循环，本来单独运行这个脚本是正确的，没有任何问题，但是我却把它配置到crontab任务中每小时都去运行，这样就会每小时都会新增一个vgt-sync.sh进程，随着时间的推移，本机上的进程就越来越多了，从而导致了上面的问题。 
<br> 
<span id="more-543"></span> 
<br> 所以，我的找到原因，解决方法就简单了，显示kill掉这些进程，然后修改我的脚本，既然用了crontab就别写死循环了。 
<p></p> 
<p></p> 
<pre><code class="language-plain">[repo@vt-sync jay]$ ps ux | wc -l
1020
[repo@vt-sync jay]$ killall vgt-sync.sh
#(wait for several seconds.)
[repo@vt-sync jay]$ ps ux | wc -l
12</code></pre> 
<br> 再来看看我的那个非常简单脚本吧，刚好和crontab结合起来使用就有了bug了。 
<p></p> 
<p></p> 
<pre><code class="language-plain">#! /bin/bash
set -x
linux_dir="/home/repo/pub/linux-vgt.git/"
xen_dir="/home/repo/pub/xen-vgt.git/"
while [ 1 ]
do
        cd $linux_dir
        git pull
        cd $xen_dir
        git pull
        sleep 30
done</code></pre> 
<br> 我遇到的情况是自己的程序bug，下面简单说一下fork炸弹吧。 
<br> 
<strong>所谓fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环，fork炸弹并不需要有特别的权限即可对系统造成破坏。</strong>现在来看一个最简单的fork炸弹: 
<p></p> 
<p></p> 
<pre><code class="language-plain"> :() { :|:&amp; };:</code></pre> 
<br> 
<p></p> 
<p>一行看似无法理解的只有13个字符的命令，即可占用掉所有系统的资源。其实，这行命令如果这样写成bash script就不难理解了：</p> 
<p></p> 
<pre><code class="language-plain">:()
{
    :|: &amp;
}
;
:</code></pre> 
<br> 冒号”:”其实是函数名，这个bash脚本就是在不断的执行该函数，然后不断fork出新的进程。那么，有没有办法扼制这种情况的发生呢？答案是肯定的，只需设置进程的limit数即可，就算fork炸弹运行也没关系，如果我的limit限制很小的话，几百个简单进程也不消耗完系统的所有资源： 
<br> ulimit -u 200 #设置当前用户最多的进程数量限制为200 
<br> 
<p>　　使用工具ulimit即可设置各种限制数，具体的请参考该工具的manual page（man bash)。在这里笔者限制了max user processes数为200，所以，可以安全地执行这个fork炸弹了：</p> 
<p></p> 
<pre><code class="language-plain">[repo@vt-sync jay]$ :() { :|:&amp; };:
[1] 9593
[repo@vt-sync jay]$ bash: fork: Resource temporarily unavailable
bash: fork: Resource temporarily unavailable
bash: fork: Resource temporarily unavailable
bash: fork: Resource temporarily unavailable</code></pre> 
<br> 
<br> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/74836d989111b10b74a26605ebe08dcf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Llvm的类型转换系统</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/60280f553b2ff35eaf9a0fb39901dc13/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">keil main之前执行过程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>