<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Data JPA 与 MyBatis 的一些心得 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring Data JPA 与 MyBatis 的一些心得" />
<meta property="og:description" content="Spring Data JPA 与 MyBatis 的一些心得 引言 之前一直使用 MyBatis ，习惯了自己写增删改查的 SQL 。在入职新公司后，公司是用的是 Spring Data JPA ，半年过去了，由于公司本身是互联网行业，开发和迭代快速，比较深刻的体会到了 Spring Data JPA 和 MyBatis 的优缺点。
先下结语，互联网行业，开发和迭代快速，如果没有 Spring Data JPA / Hibernate 的大牛，或者技术文档没有维护的想法，不建议使用 Spring Data JPA ，哪怕 Spring Data JPA 具有初始的开发速度优势。
Spring Data JPA 与 MyBatis 由于 Spring Data JPA 默认使用 Hibernate 作为 ORM 实现，Spring Data JPA 与 MyBatis 对比，其实也就是 Hibernate 与 MyBatis 的对比。
Spring Data JPA 与 MyBatis 的查询构建
Spring Data JPA 中，如果一个 DAO 查询类继承了 JpaRepository，即" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/09274f6017e3ee2775f0cd82c610dd18/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-28T18:49:29+08:00" />
<meta property="article:modified_time" content="2019-10-28T18:49:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Data JPA 与 MyBatis 的一些心得</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Spring_Data_JPA__MyBatis__0"></a>Spring Data JPA 与 MyBatis 的一些心得</h2> 
<center> 
 <img src="https://images2.imgbox.com/96/fa/V1JU6hkk_o.gif"> 
</center> 
<h3><a id="_4"></a>引言</h3> 
<p>之前一直使用 MyBatis ，习惯了自己写增删改查的 SQL 。在入职新公司后，公司是用的是 Spring Data JPA ，半年过去了，由于公司本身是互联网行业，开发和迭代快速，比较深刻的体会到了 Spring Data JPA 和 MyBatis 的优缺点。<br> 先下结语，互联网行业，开发和迭代快速，如果没有 Spring Data JPA / Hibernate 的大牛，或者技术文档没有维护的想法，不建议使用 Spring Data JPA ，哪怕 Spring Data JPA 具有初始的开发速度优势。</p> 
<h3><a id="Spring_Data_JPA__MyBatis_9"></a>Spring Data JPA 与 MyBatis</h3> 
<p>由于 Spring Data JPA 默认使用 Hibernate 作为 ORM 实现，Spring Data JPA 与 MyBatis 对比，其实也就是 Hibernate 与 MyBatis 的对比。</p> 
<ol><li> <p>Spring Data JPA 与 MyBatis 的查询构建</p> <p>Spring Data JPA 中，如果一个 DAO 查询类继承了 JpaRepository，即</p> <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">classADAO</span> <span class="token keyword">extends</span> <span class="token class-name">JpaRepository</span><span class="token generics function"><span class="token punctuation">&lt;</span>classA<span class="token punctuation">,</span>Integer<span class="token punctuation">&gt;</span></span><span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> <p>那么查询所有的 classA 有多简单呢：<code>List&lt;classA&gt; list =classADAO.findAll();</code></p> <p>核心在于什么， Spring Data JPA (Hibernate) 是面向对象的，MyBatis 是面向关系的。</p> <p>但面向对象麻烦的地方也就在这里，如果有级联呢？</p> <p>它把表看做一个对象，那表A是一个对象 classA 。如果表A通过中间表B关联了表C，那么毫无意义的表B也成了一个对象。注意，这些都是要写入类中的。</p> <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassA</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Id</span>
    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> GenerationType<span class="token punctuation">.</span>IDENTITY<span class="token punctuation">)</span>
    Integer id<span class="token punctuation">;</span>
    
    <span class="token annotation punctuation">@OneToMany</span><span class="token punctuation">(</span>mappedBy <span class="token operator">=</span> <span class="token string">"classA"</span><span class="token punctuation">,</span> cascade <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>CascadeType<span class="token punctuation">.</span>ALL<span class="token punctuation">}</span><span class="token punctuation">,</span> fetch <span class="token operator">=</span> FetchType<span class="token punctuation">.</span>LAZY<span class="token punctuation">)</span>
    <span class="token keyword">private</span> List<span class="token generics function"><span class="token punctuation">&lt;</span>classB<span class="token punctuation">&gt;</span></span> listB<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassB</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Id</span>
    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> GenerationType<span class="token punctuation">.</span>IDENTITY<span class="token punctuation">)</span>
    Integer id<span class="token punctuation">;</span>
    
    <span class="token annotation punctuation">@OneToMany</span><span class="token punctuation">(</span>mappedBy <span class="token operator">=</span> <span class="token string">"classB"</span><span class="token punctuation">,</span> cascade <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>CascadeType<span class="token punctuation">.</span>ALL<span class="token punctuation">}</span><span class="token punctuation">,</span> fetch <span class="token operator">=</span> FetchType<span class="token punctuation">.</span>LAZY<span class="token punctuation">)</span>
    <span class="token keyword">private</span> List<span class="token generics function"><span class="token punctuation">&lt;</span>classC<span class="token punctuation">&gt;</span></span> listC<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>仔细想想，从 classA 到 classC 查询实现会比较复杂。</p> <p>所以要用好 Spring Data JPA 的查询，一定要有一位大牛，对数据库设计时的表关系进行取舍，尽可能的避免上文这种情况出现。当然肯定还有其他需要考虑的地方，我这方面经验尚缺。</p> <p>但是用好了，就可以很方便的查询，不用 SQL 写来写去，对吧，而 MyBatis 的 SQL 是绕不开的。</p> </li><li> <p>Spring Data JPA 与 MyBatis 的文档维护</p> <p>由上一点就可以延伸到这一点，我之前提到过， Spring Data JPA 具有初始的开发速度优势。</p> <p>为什么，这里可能有些疑问，因为就算你简单的 SQL 能避免，但是总有多表条件查询啊。是的，Spring Data JPA 还有一样利器 Specification ，我贴下基本的结构，你就明白了</p> <pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ClassASpec</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">static</span> Specification<span class="token generics function"><span class="token punctuation">&lt;</span>ClassA<span class="token punctuation">&gt;</span></span> <span class="token function">spec</span><span class="token punctuation">(</span>ClassAQuery classAQuery<span class="token punctuation">,</span> Boolean checkUnique<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token punctuation">(</span>root<span class="token punctuation">,</span> query<span class="token punctuation">,</span> cb<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
			List<span class="token generics function"><span class="token punctuation">&lt;</span>Predicate<span class="token punctuation">&gt;</span></span> predicates <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
			<span class="token keyword">if</span> <span class="token punctuation">(</span>classAQuery<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
				<span class="token keyword">if</span> <span class="token punctuation">(</span>checkUnique <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> checkUnique<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					predicates<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cb<span class="token punctuation">.</span><span class="token function">notEqual</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> classAQuery<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
					predicates<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>cb<span class="token punctuation">.</span><span class="token function">equal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"id"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> classAQuery<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
				<span class="token punctuation">}</span>
			<span class="token punctuation">}</span>
			<span class="token keyword">return</span> cb<span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span>predicates<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Predicate</span><span class="token punctuation">[</span>predicates<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
		<span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> <p>明白了吧，这就是不用写 SQL 的原因所在，所有的查询以此种方式从对象映射为关系，自动生成 SQL。</p> <p>那问题来了，Spring Data JPA 的优势在这里处理不好就会变成劣势。</p> <p>处于互联网行业，开发是快速的，迭代是快速的，数据库中的表关系会层层叠加，表字段会层层叠加，如果不注意维护文档，一段时间，你可以想象得到，这个查询类 Specification 会变成何种怪物。</p> <p>有朋友就问了，我不能通过看 SQL 来看懂查询逻辑吗。可以，极费时间，你可以通过日志查看自动生成的 SQL ，但一是由于级联的存在，二是由于 Specification 自动生成的 SQL 会加载每个表及每个表的所有字段，且会给每个字段生成别名，相信我，你看到 SQL 会爆炸的。</p> <p>我拿一个实际中常见的多表联合条件查询 SQL 举例（来源于网络）：</p> <pre><code class="prism language-SQL">SELECT
	CATENTRY.PARTNUMBER,
	CATENTRY.CATENTRY_ID,
	CATENTDESC.NAME,
	MASSOCCECE.MASSOCCECE_ID 
FROM
	CATENTDESC,
	CATENTRY,
	CATGROUP,
	CATGRPREL,
	CATGPENREL,
	MASSOCCECE 
WHERE
	CATENTDESC.LANGUAGE_ID = 44 
	AND CATENTRY.MARKFORDELETE = 0 
	AND CATENTDESC.CATENTRY_ID = CATENTRY.CATENTRY_ID 
	AND CATENTRY.CATENTRY_ID = MASSOCCECE.CATENTRY_ID_TO 
	AND MASSOCCECE.CATENTRY_ID_FROM = 299811 
	-- AND CATGPENREL.CATALOG_ID = 10201 
	AND MASSOCCECE.MASSOCTYPE_ID = 'EDITORIAL' 
	AND CATGPENREL.CATENTRY_ID = MASSOCCECE.CATENTRY_ID_TO 
	AND CATGRPREL.CATGROUP_ID_CHILD = CATGPENREL.CATGROUP_ID 
	AND CATGRPREL.CATGROUP_ID_PARENT = CATGROUP.CATGROUP_ID 
	AND CATGRPREL.CATALOG_ID = CATGPENREL.CATALOG_ID 
	AND CATGROUP.FIELD1 = 'EDITORIAL' 
GROUP BY
	CATENTRY.PARTNUMBER,
	CATENTRY.CATENTRY_ID,
	CATENTDESC.NAME,
	MASSOCCECE.MASSOCCECE_ID 
ORDER BY
	MASSOCCECE.MASSOCCECE_ID WITH UR
</code></pre> <p>如果没有文档，MyBatis 的语句好歹是直观的。哪怕没文档、排版乱，格式化后，是看得懂的。升级直接改 SQL ，还可以拜托 DBA 优化。</p> <p>要是用 Spring Data JPA 做的话，查询类会极度复杂。没有文档，开发人员一换，后边的开发人员头都得想破。谈到升级和优化，DBA 无从下手，必须有个 Spring Data JPA / Hibernate 的大牛。</p> </li></ol> 
<h3><a id="_136"></a>结语</h3> 
<ol><li>在简单数据库逻辑查询（单表）下 Mybatis 开发效率会比 Spring Data JPA 低，但不会低多少</li><li>在复杂数据库逻辑查询（多表、联合）下，随着表关系和表字段的迭代， Spring Data JPA 查询的效率和优化比 Mybatis 困难得多</li></ol> 
<p>所以，互联网行业，因为开发和迭代快速，如果没有 Spring Data JPA / Hibernate 的大牛，或者技术文档没有维护的想法，不建议使用 Spring Data JPA ，哪怕 Spring Data JPA 具有初始的开发速度优势。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7415b11965111e879dd109d0ccffde85/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">netbeans导入jar包</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bf831cb64cb37f6e6e673544358db3ec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数据结构系列之如何查找单链表中倒数第N个节点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>