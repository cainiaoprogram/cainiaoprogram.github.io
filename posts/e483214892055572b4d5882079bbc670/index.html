<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>k8s基础(3)之RC - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="k8s基础(3)之RC" />
<meta property="og:description" content="k8s基础(3)之RC、Replica Set RC介绍 Replication Controller (简称RC),RC是Kubernetes系统中的核心概念之一,简单来说,它定义了一个期望的场景,即声明某种Pod的副本数量在任意时刻都符合某个预期值
RC定义了如下
1.Pod期待的副本数(replicas)
2.用于筛选目标Pod的Label Seletcor(标签选择器)
3.当Pod的副本小于预期(replicas)时，用于创建新Pod的Pod模板(template)
RC主要功能
确保Pod数量: 它会确保Kubernetes中有指定数量的Pod在运行，如果少于指定数量的Pod，RC就会创建新的，反之会删除多余的，保证Pod的副本数量不变确保Pod健康: 当Pod不健康，RC会杀死不健康的Pod，重新创建新的弹性伸缩: 在业务高峰或者低峰的时候，可以用RC来动态调整Pod数量来提供资源的利用率吧，当然也可以使用HPA来实现滚动升级: 滚动升级是一种平滑的升级方式，通过逐步替换的策略，保证整体系统的稳定性 RC例子演示 当我们定义了一个RC并提交到Kubernetes集群中以后,Master节点上的Controller Manager组件就得到通知,定期巡检系统中当前存活的目标Pod,并确保目标Pod实力的数量刚好等于此RC的期望值,如果有过多的Pod副本在运行,系统就会停掉一些Pod,否则系统就会再自动创建一些Pod。 可以说，通过RC,Kubernetes实现了用户应用集群的高可用性,并大大减少了传统IT需要手动的工作
--- apiVersion: v1 kind: ReplicationController metadata: name: rc-demo labels: app: rc spec: replicas: 3 &lt;=========== 配置Pod数量 selector: app: rc template: metadata: labels: app: rc spec: containers: - name: nginx-demo image: nginx ports: - containerPort: 80 查看结果RC数量
[root@abcdocker yaml]# kubectl get rc NAME DESIRED CURRENT READY AGE rc-demo 3 3 3 5m19s DESIRED #rc设置的数量 CURRENT #已经创建的数量 READY #准备好的数量 查看Pod数量及状态" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e483214892055572b4d5882079bbc670/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-21T17:16:26+08:00" />
<meta property="article:modified_time" content="2020-09-21T17:16:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">k8s基础(3)之RC</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="k8s3RCReplica_Set_0"></a>k8s基础(3)之RC、Replica Set</h2> 
<h4><a id="RC_2"></a>RC介绍</h4> 
<p>Replication Controller (简称RC),RC是Kubernetes系统中的核心概念之一,简单来说,它定义了一个期望的场景,即声明某种Pod的副本数量在任意时刻都符合某个预期值</p> 
<p>RC定义了如下</p> 
<blockquote> 
 <p>1.Pod期待的副本数(replicas)</p> 
 <p>2.用于筛选目标Pod的Label Seletcor(标签选择器)</p> 
 <p>3.当Pod的副本小于预期(replicas)时，用于创建新Pod的Pod模板(template)</p> 
</blockquote> 
<p><strong>RC主要功能</strong></p> 
<ul><li>确保Pod数量: 它会确保Kubernetes中有指定数量的Pod在运行，如果少于指定数量的Pod，RC就会创建新的，反之会删除多余的，保证Pod的副本数量不变</li><li>确保Pod健康: 当Pod不健康，RC会杀死不健康的Pod，重新创建新的</li><li>弹性伸缩: 在业务高峰或者低峰的时候，可以用RC来动态调整Pod数量来提供资源的利用率吧，当然也可以使用HPA来实现</li><li>滚动升级: 滚动升级是一种平滑的升级方式，通过逐步替换的策略，保证整体系统的稳定性</li></ul> 
<hr> 
<h4><a id="RC_23"></a>RC例子演示</h4> 
<p>当我们定义了一个RC并提交到Kubernetes集群中以后,Master节点上的<code>Controller Manager</code>组件就得到通知,定期巡检系统中当前存活的目标Pod,并确保目标Pod实力的数量刚好等于此RC的期望值,如果有过多的Pod副本在运行,系统就会停掉一些Pod,否则系统就会再自动创建一些Pod。 可以说，通过RC,Kubernetes实现了用户应用集群的高可用性,并大大减少了传统IT需要手动的工作</p> 
<pre><code>---
apiVersion: v1
kind: ReplicationController
metadata:
  name: rc-demo
  labels:
     app: rc
spec:
  replicas: 3   &lt;=========== 配置Pod数量
  selector:
    app: rc
  template:
    metadata:
      labels: 
        app: rc
    spec:
      containers:
        - name: nginx-demo
          image: nginx
          ports:
          - containerPort: 80
</code></pre> 
<p>查看结果RC数量</p> 
<pre><code>[root@abcdocker yaml]# kubectl get rc
NAME      DESIRED   CURRENT   READY   AGE
rc-demo   3         3         3       5m19s

DESIRED   #rc设置的数量
CURRENT   #已经创建的数量
READY     #准备好的数量
</code></pre> 
<p>查看Pod数量及状态</p> 
<pre><code>[root@abcdocker yaml]# kubectl get po
NAME            READY   STATUS    RESTARTS   AGE
rc-demo-78c69   1/1     Running   0          4m31s
rc-demo-97w7x   1/1     Running   0          4m31s
rc-demo-lmbzr   1/1     Running   0          72s
</code></pre> 
<p>同时可以使用<code>kubectl describe rc [rc-name]</code>查看rc创建详情 [<img src="https://images2.imgbox.com/6a/56/d0LfaopD_o.png" alt="-w1671"></p> 
<p><strong>例子：</strong> 我们以3个Node节点为例,演示Pod副本数量自动控制的机制,加入我们的RC里定义abcdocker这个Pod需要保持3个副本,系统可能在其中两台上创建Pod</p> 
<p><img src="https://images2.imgbox.com/5d/8c/nutFf2v1_o.png" alt="RC演示1"></p> 
<p>假如Node2 上的Pod 2意外终止,根据RC定义的replicas数量2,Kubernetes将会自动创建并启动一个新的Pod,以保证集群中有2个服务可用</p> 
<p><img src="https://images2.imgbox.com/2b/71/NX8DwO4q_o.png" alt="RC演示2"></p> 
<hr> 
<h4><a id="RC_85"></a>RC动态缩放</h4> 
<p><img src="https://images2.imgbox.com/c3/20/6x3MtlNz_o.png" alt="RC演示3"></p> 
<p>在Pod运行时，我们可以通过修改<code>RC</code>的副本数量，来实现Pod动态缩放**<code>Scaling</code>**功能,这也可以通过过kubectl scale命令来一键完成</p> 
<pre><code class="prism language-o">扩展Pod副本到3
kubectl scale rc [rc名称] --replicas=3 

缩减副本到1
kubectl scale rc [rc名称] --replicas=1
</code></pre> 
<p>演示1: 我们将tomcat的Pod数量由原来的3个更改为7个 <img src="https://images2.imgbox.com/70/dc/6W6nxbgU_o.png" alt="-w1009"></p> 
<p>演示2：我们将tomcat的Pod输了由原来的7个修改为1个 <img src="https://images2.imgbox.com/04/b1/gNEMaaVT_o.png" alt="-w1052"></p> 
<p>提示：deployment 后面的tomcat是我们在yaml文件中定义的 url:什么是yaml文件</p> 
<p>除了通过命令的方式修改，我们还可以通过yaml文件的方式进行调试 <img src="https://images2.imgbox.com/8f/7d/ukFfgl4j_o.png" alt="-w1026"><br> <strong>注意：</strong> 删除RC并不会影响通过该RC已创建号的Pod。为了删除所有Pod，可以设置replicas的值为0，然后更新该RC。另外,kubectl提供了<code>stop</code>和<code>delete</code>命令来一次性删除RC和RC控制的全部Pod</p> 
<h3><a id="Replica_Set_110"></a>Replica Set</h3> 
<p>由于Replication Controller与Kubernetes代码中的模块Replication Controller同名,同时这个词也无法准确表述它的本意,所以在<code>Kubernetes1.2</code>时,它就升级成另一个新的概念—<strong>Replica Set</strong>,官方解释为**“下一代的RC”**</p> 
<p>它与RC当前存在的唯一区别是：Replica Sets支持基于集合的<strong>Label selector(Set-based selector基于集合的标签选择器)</strong>,而RC只支持基于等式的<strong>Label Selector(equality-based selector基于等式)</strong>,这使得Replica Set的功能更强</p> 
<p>matchExpressions 是一个pod的选择器条件的list 。</p> 
<pre><code class="prism language-bash">selector:
  matchLabels:
    tier: frontend
  matchExpressions:
    - <span class="token punctuation">{<!-- --></span>key: tier, operator: In, values: <span class="token punctuation">[</span>frontend<span class="token punctuation">]</span><span class="token punctuation">}</span>
</code></pre> 
<p>kubectl命令行工具适用于RC的绝大部分命令都同样适用于Replica Set，当前我们很少的单独是哦那个Replica Set,它主要被Deployment这个更高层的资源对象所使用,从而形成一整套Pod创建、删除、更新的编排机制。当我们使用Deployment时，无须关心它是如何创建和维护Replica Set的,这一切都是自动发生的。</p> 
<hr> 
<p><strong>RC(Replica Set)功能</strong></p> 
<p>ent这个更高层的资源对象所使用,从而形成一整套Pod创建、删除、更新的编排机制。当我们使用Deployment时，无须关心它是如何创建和维护Replica Set的,这一切都是自动发生的。</p> 
<hr> 
<p><strong>RC(Replica Set)功能</strong></p> 
<blockquote> 
 <p>1.在大多数情况下,我们定义一个RC实现Pod的创建过程及副本数量的自动控制 2.RC里包括完整的Pod定义模板 3.RC通过Label Selector机制实现对Pod副本的自动控制。 4.通过改变RC里的Pod副本数量,可以实现Pod的扩容或缩容功能 5.通过改变RC里的Pod目标中的镜像版本,可以实现Pod的滚动升级功能</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9edcaa8993f54cf217bda4c422caceb6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用宝塔面板搭建WordPress网站（图文教程）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/38a1770f793858bc90243c83148b56cf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">k8s基础(12)之PV与PVC</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>