<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java过滤器（Filter） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java过滤器（Filter）" />
<meta property="og:description" content="原文链接：java过滤器（Filter – 编程屋
目录
1 过滤器简介
2 Filter详细介绍
3 Filter的用法
3.1 用法1
3.2 用法2
1 过滤器简介 filter也称之为过滤器，它是javaWeb三大组件之一（Servlet程序、Listener监听器、Filter过滤器）
作用：既可以对请求进行拦截，也可以对响应进行处理。
常见场景：权限检查，日记操作、拦截请求、过滤操作、对请求字符设置编码。
2 Filter详细介绍 要想介绍filter，就必须介绍Filter中的三个方法。
/** * web应用启动时，web服务器将创建Filter的实例对象，并调用init方法，读取web.xml的配置，完成对象的初始化功能， * 从而为后续的用户请求做好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次，开发人员通过init的参数， * 可或得代表当前filter配置信息的FilterConfig对象） * @param filterConfig * @throws ServletException */ @Override public void init(FilterConfig filterConfig) throws ServletException { } /** * 这个方法完成实际的过滤操作，当客户请求访问与过滤器相关联的URL的时候，Servlet过滤器将先执行doFilter方法，FilterChain参数用于访问后续过滤器 * @param servletRequest * @param servletResponse * @param filterChain * @throws IOException * @throws ServletException */ @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { } /** * filter创建后会保存在内存中，当web应用移除或者服务器停止时才销毁，该方法在Filter的生命周期中仅执行一次，在这个方法中，可以释放过滤器使用的资源 */ @Override public void destroy() { } 3 Filter的用法 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/70c1ceff08e034fcf2845cb9bbd1f9e4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-24T08:49:14+08:00" />
<meta property="article:modified_time" content="2023-08-24T08:49:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java过滤器（Filter）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>原文链接：<a href="https://rivers-all.com/archives/412.html" rel="nofollow" title="java过滤器（Filter – 编程屋"><strong>java过滤器（Filter – 编程屋</strong></a></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="1%20%E8%BF%87%E6%BB%A4%E5%99%A8%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#1%20%E8%BF%87%E6%BB%A4%E5%99%A8%E7%AE%80%E4%BB%8B" rel="nofollow">1 过滤器简介</a></p> 
<p id="2%20Filter%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D-toc" style="margin-left:0px;"><a href="#2%20Filter%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D" rel="nofollow">2 Filter详细介绍</a></p> 
<p id="3%20Filter%E7%9A%84%E7%94%A8%E6%B3%95-toc" style="margin-left:0px;"><a href="#3%20Filter%E7%9A%84%E7%94%A8%E6%B3%95" rel="nofollow">3 Filter的用法</a></p> 
<p id="3.1%20%E7%94%A8%E6%B3%951-toc" style="margin-left:40px;"><a href="#3.1%20%E7%94%A8%E6%B3%951" rel="nofollow">3.1 用法1</a></p> 
<p id="%C2%A03.2%20%E7%94%A8%E6%B3%952-toc" style="margin-left:40px;"><a href="#%C2%A03.2%20%E7%94%A8%E6%B3%952" rel="nofollow"> 3.2 用法2</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1%20%E8%BF%87%E6%BB%A4%E5%99%A8%E7%AE%80%E4%BB%8B">1 过滤器简介</h2> 
<p>filter也称之为过滤器，它是javaWeb三大组件之一（Servlet程序、Listener监听器、Filter过滤器）</p> 
<p><strong>作用：</strong>既可以对请求进行拦截，也可以对响应进行处理。</p> 
<p><img alt="" height="369" src="https://images2.imgbox.com/f3/87/SdFFSg5I_o.png" width="1188"></p> 
<p><strong>常见场景：</strong>权限检查，日记操作、拦截请求、过滤操作、对请求字符设置编码。</p> 
<h2 id="2%20Filter%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D">2 Filter详细介绍</h2> 
<p>要想介绍filter，就必须介绍Filter中的三个方法。</p> 
<pre><code>    /**
     * web应用启动时，web服务器将创建Filter的实例对象，并调用init方法，读取web.xml的配置，完成对象的初始化功能，
     * 从而为后续的用户请求做好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次，开发人员通过init的参数，
     * 可或得代表当前filter配置信息的FilterConfig对象）
     * @param filterConfig
     * @throws ServletException
     */
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    /**
     * 这个方法完成实际的过滤操作，当客户请求访问与过滤器相关联的URL的时候，Servlet过滤器将先执行doFilter方法，FilterChain参数用于访问后续过滤器
     * @param servletRequest
     * @param servletResponse
     * @param filterChain
     * @throws IOException
     * @throws ServletException
     */
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {

    }

    /**
     * filter创建后会保存在内存中，当web应用移除或者服务器停止时才销毁，该方法在Filter的生命周期中仅执行一次，在这个方法中，可以释放过滤器使用的资源
     */
    @Override
    public void destroy() {

    }</code></pre> 
<h2 id="3%20Filter%E7%9A%84%E7%94%A8%E6%B3%95">3 Filter的用法</h2> 
<h3 id="3.1%20%E7%94%A8%E6%B3%951">3.1 用法1</h3> 
<p>1）自定义一个过滤器实现Filter接口、配置@WebFilter注解，配置拦截路径（也可通过web.xml配置）</p> 
<pre><code>@WebFilter(urlPatterns = "/*")
public class MyFilterOne implements Filter {

    /**
     * web应用启动时，web服务器将创建Filter的实例对象，并调用init方法，读取web.xml的配置，完成对象的初始化功能，
     * 从而为后续的用户请求做好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次，开发人员通过init的参数，
     * 可或得代表当前filter配置信息的FilterConfig对象）
     * @param filterConfig
     * @throws ServletException
     */
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    /**
     * 这个方法完成实际的过滤操作，当客户请求访问与过滤器相关联的URL的时候，Servlet过滤器将先执行doFilter方法，FilterChain参数用于访问后续过滤器
     * @param servletRequest
     * @param servletResponse
     * @param filterChain
     * @throws IOException
     * @throws ServletException
     */
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("我是过滤器，我进来了");
    }

    /**
     * filter创建后会保存在内存中，当web应用移除或者服务器停止时才销毁，该方法在Filter的生命周期中仅执行一次，在这个方法中，可以释放过滤器使用的资源
     */
    @Override
    public void destroy() {

    }
}</code></pre> 
<p>2）在启动类上加上<strong>@ServletComponentScan</strong>注解</p> 
<pre><code>@SpringBootApplication
@ServletComponentScan
public class SpringbootInterceptorApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootInterceptorApplication.class, args);
    }

}</code></pre> 
<p>3）controller：</p> 
<pre><code>@RestController
public class LoginController {

    @GetMapping("/test/filter")
    public String testFilter(){
        return "该请求被拦截了，但是在过滤器中已经放行了";
    }
}
</code></pre> 
<p>直接浏览器访问：</p> 
<p><img alt="" height="211" src="https://images2.imgbox.com/36/80/J2wVr28r_o.png" width="1200"></p> 
<p> 控制台输出：发现该请求已经被过滤去拦截</p> 
<p><img alt="" height="187" src="https://images2.imgbox.com/65/71/CQmHXNb9_o.png" width="1200"></p> 
<h3 id="%C2%A03.2%20%E7%94%A8%E6%B3%952"> 3.2 用法2</h3> 
<p>1）自定义一个过滤器实现Filter接口、配置拦截路径（也可通过web.xml配置）</p> 
<pre><code>public class MyFilterOne implements Filter {

    /**
     * web应用启动时，web服务器将创建Filter的实例对象，并调用init方法，读取web.xml的配置，完成对象的初始化功能，
     * 从而为后续的用户请求做好拦截的准备工作（filter对象只会创建一次，init方法也只会执行一次，开发人员通过init的参数，
     * 可或得代表当前filter配置信息的FilterConfig对象）
     * @param filterConfig
     * @throws ServletException
     */
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {

    }

    /**
     * 这个方法完成实际的过滤操作，当客户请求访问与过滤器相关联的URL的时候，Servlet过滤器将先执行doFilter方法，FilterChain参数用于访问后续过滤器
     * @param servletRequest
     * @param servletResponse
     * @param filterChain
     * @throws IOException
     * @throws ServletException
     */
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        System.out.println("我是过滤器，我进来了");
        filterChain.doFilter(servletRequest, servletResponse);
    }

    /**
     * filter创建后会保存在内存中，当web应用移除或者服务器停止时才销毁，该方法在Filter的生命周期中仅执行一次，在这个方法中，可以释放过滤器使用的资源
     */
    @Override
    public void destroy() {

    }
}</code></pre> 
<p>2）在启动类上注册</p> 
<pre><code>@SpringBootApplication
public class SpringbootInterceptorApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringbootInterceptorApplication.class, args);
    }


    /**
     * 注册Filter
     */
    @Bean
    public FilterRegistrationBean getFilterRegistrationBean(){
        FilterRegistrationBean bean = new FilterRegistrationBean(new MyFilterOne());
        //bean.addUrlPatterns(new String[]{"*.do","*.jsp"});
        bean.addUrlPatterns("/*");
        return bean;
    }
}</code></pre> 
<p>测试结果与3.1相同。</p> 
<p><strong>总结：</strong></p> 
<p><strong>要想调用配置一个过滤器：</strong></p> 
<p><strong>1）启动类上增加注解</strong><strong>@ServletComponentScan</strong></p> 
<p><strong>2）新建一个类使其实现Filter接口，并实现里面的三个方法</strong></p> 
<p><strong>3）在新建类上加上@WebFilter()注解，配置需要拦截的规则</strong></p> 
<p><strong>4）在doFilter方法中控制filterChain.doFilter(servletRequest, servletResponse)调用</strong></p> 
<p><strong>同样，如果前后端交互有遇到跨域问题的，也可以通过Filter解决（亲测有效），如：</strong></p> 
<p>以上只是部分内容，为了维护方便，本文已迁移到新地址：<a href="https://rivers-all.com/archives/412.html" rel="nofollow" title="java过滤器（Filter – 编程屋"><strong>java过滤器（Filter – 编程屋</strong></a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/086d8ab57641dac1842ce5921857d181/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Redis 序列化器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1c7eb9cb54a8d207adffde1234b81913/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pandas（一）：read_csv解决第一列Unnamed问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>