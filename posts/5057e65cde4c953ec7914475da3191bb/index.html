<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vs2017 java_在idea2018和vs2017平台下JNI编程调用C&#43;&#43;算法（1）-环境搭建 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vs2017 java_在idea2018和vs2017平台下JNI编程调用C&#43;&#43;算法（1）-环境搭建" />
<meta property="og:description" content="##JNI简介
JNI是Java Native Interface的简称，通过JNI,可以调用C&#43;&#43;或C的程序(称为本地程序)。
##应用场景
我认为应用场景可以用三个字概括“不得不”，即只有遇到必须跨语言的时候，才会选择JNI。从Java的场景出发，使用JNI意味着失去了跨平台的优势；从C&#43;&#43;的角度想，可能需要将程序发布到安卓端等，而不得不采用JNI进行跨语言。
通过调研JNI,目前JNI的应用场景大部分是需要在安卓平台引入C/C&#43;&#43;代码。也有人和我一样，正在开发的java系统需要调用一段C&#43;&#43;的核心代码。于是，让我们愉快地入坑吧~
##本文特色
本文主要讲解在idea2018和vs2017平台下搭建一套Java项目和C&#43;&#43;解决方案，其中Java项目实现一个简单的HelloWorld功能，该功能正是通过JNI调用C&#43;&#43;实现的。
作为一名JNI刚入坑小将，以及多年没写过(只在书本和考试中与其交手)C&#43;&#43;的渣渣，写一个HelloWorld程序也是反复磨炼的过程。在反复磨炼过程中，我发现网上很多教程有些繁琐，需要将各种文件复制来粘贴去，稍有错误就要重新复制粘贴，实在让人恼火。所以本文介绍一种**借助idea和vs平台尽量减少步骤的搭建方法**。
##环境介绍
- 操作系统：Win7专业版64bit
- JDK:1.8
- idea:2018
- vs:2017
&gt; Tips:
&gt; windows系统注定了生成的动态链接库是dll文件
&gt; JDK10将javah工具取消，需要使用javac -h替代，这是与jdk8不同的地方
主要步骤
创建一个java项目，在其中编写一个带有native方法的类
利用idea生成.h头文件
在vs中创建一个动态链接库应用程序的解决方案
在解决方案中创建C&#43;&#43;文件，实现头文件中的方法
生成动态链接库
回到idea,运行java项目，排错重复以上步骤直到运行成功
1.在idea创建java项目
首先本次项目主要想实现一个简单的HelloWorld，java程序声明sayHello函数，并将name当做参数传入。在C&#43;&#43;中实现sayHello，将sayHello的文本传回给java程序。步骤如下
在idea创建java项目，在src目录下新建一个package,本文包为com.study,jni.demo.simple。
在包下创建一个类，用来编写native方法和main函数。
package com.study.jni.demo.simple;
import com.study.jni.demo.common.Constants;
public class SimpleHello {
public static native String sayHello(String name);
public static void main(String[] args) {
String name = &#34;lucyChen&#34;;
String text = sayHello(name);
System.out.println(&#34;after native, java shows:&#34; &#43; text);" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5057e65cde4c953ec7914475da3191bb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-21T04:36:54+08:00" />
<meta property="article:modified_time" content="2021-02-21T04:36:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vs2017 java_在idea2018和vs2017平台下JNI编程调用C&#43;&#43;算法（1）-环境搭建</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>##JNI简介</p> 
 <p>JNI是Java Native Interface的简称，通过JNI,可以调用C++或C的程序(称为本地程序)。</p> 
 <p>##应用场景</p> 
 <p>我认为应用场景可以用三个字概括“不得不”，即只有遇到必须跨语言的时候，才会选择JNI。从Java的场景出发，使用JNI意味着失去了跨平台的优势；从C++的角度想，可能需要将程序发布到安卓端等，而不得不采用JNI进行跨语言。</p> 
 <p>通过调研JNI,目前JNI的应用场景大部分是需要在安卓平台引入C/C++代码。也有人和我一样，正在开发的java系统需要调用一段C++的核心代码。于是，让我们愉快地入坑吧~</p> 
 <p>##本文特色</p> 
 <p>本文主要讲解在idea2018和vs2017平台下搭建一套Java项目和C++解决方案，其中Java项目实现一个简单的HelloWorld功能，该功能正是通过JNI调用C++实现的。</p> 
 <p>作为一名JNI刚入坑小将，以及多年没写过(只在书本和考试中与其交手)C++的渣渣，写一个HelloWorld程序也是反复磨炼的过程。在反复磨炼过程中，我发现网上很多教程有些繁琐，需要将各种文件复制来粘贴去，稍有错误就要重新复制粘贴，实在让人恼火。所以本文介绍一种**借助idea和vs平台尽量减少步骤的搭建方法**。</p> 
 <p>##环境介绍</p> 
 <p>- 操作系统：Win7专业版64bit</p> 
 <p>- JDK:1.8</p> 
 <p>- idea:2018</p> 
 <p>- vs:2017</p> 
 <p>&gt; Tips:</p> 
 <p>&gt; windows系统注定了生成的动态链接库是dll文件</p> 
 <p>&gt; JDK10将javah工具取消，需要使用javac -h替代，这是与jdk8不同的地方</p> 
 <p>主要步骤</p> 
 <p>创建一个java项目，在其中编写一个带有native方法的类</p> 
 <p>利用idea生成.h头文件</p> 
 <p>在vs中创建一个动态链接库应用程序的解决方案</p> 
 <p>在解决方案中创建C++文件，实现头文件中的方法</p> 
 <p>生成动态链接库</p> 
 <p>回到idea,运行java项目，排错重复以上步骤直到运行成功</p> 
 <p>1.在idea创建java项目</p> 
 <p>首先本次项目主要想实现一个简单的HelloWorld，java程序声明sayHello函数，并将name当做参数传入。在C++中实现sayHello，将sayHello的文本传回给java程序。步骤如下</p> 
 <p>在idea创建java项目，在src目录下新建一个package,本文包为com.study,jni.demo.simple。</p> 
 <p>在包下创建一个类，用来编写native方法和main函数。</p> 
 <p>package com.study.jni.demo.simple;</p> 
 <p>import com.study.jni.demo.common.Constants;</p> 
 <p>public class SimpleHello {<!-- --></p> 
 <p>public static native String sayHello(String name);</p> 
 <p>public static void main(String[] args) {<!-- --></p> 
 <p>String name = "lucyChen";</p> 
 <p>String text = sayHello(name);</p> 
 <p>System.out.println("after native, java shows:" + text);</p> 
 <p>}</p> 
 <p>static {<!-- --></p> 
 <p>// System.loadLibrary("JNICPPDEMO");</p> 
 <p>System.load(Constants.DLLPATH + "JNICPPDEMO.dll");</p> 
 <p>}</p> 
 <p>}</p> 
 <p>其中sayHello是一个静态方法，在前面标注为native代表了这是一个本地函数。</p> 
 <p>main函数中，调用sayHello函数。</p> 
 <p>下面的static代码块暂且不谈。</p> 
 <p>代码写好后，在生成头文件前，我们需要build一下项目，生成class文件，build后，可在左侧目录看到out/production目录下生成了对应class文件。</p> 
 <p>2.生成头文件</p> 
 <p>头文件可以使用命令行生成(见参考文献)，或者熟悉格式后自己手写。但是正如前文的介绍，本文希望用一种简便的方式。所以我希望能够随便点一下就生成头文件(真的有点懒得)。于是，我找到了一种用idea工具生成头文件的方法，那就是External Tools。</p> 
 <p>External Tools其实就是将手动输入的命令存下来，本质也是运行javah，后面跟着配置参数，这些参数存在External Tools，避免每次手动输入。</p> 
 <p>添加External Tools.File-&gt;Settings-&gt;Tools-&gt;ExternalTools,点击添加</p> 
 <p align="center"><img src="https://images2.imgbox.com/ce/90/4MMnPTl9_o.png" alt="1e07b6ed0398e83801df7035550a38fc.png"></p> 
 <p>编辑Tools</p> 
 <p>Name:Generate Header File</p> 
 <p>Program:$JDKPath$/bin/javah</p> 
 <p>Arguments:-jni -classpath $OutputPath$ -d ./jni $FileClass$</p> 
 <p>Working directory: $ProjectFileDir$</p> 
 <p>Name:External Tools的名称，喜欢什么起什么，只要自己明白</p> 
 <p>Program是javah工具所在地址，即jdk所在路径下的bin,该参数是指tool采用的运行工具是javah</p> 
 <p>Arguments设置的是javah的参数，具体可在命令行中查看javah的帮助，查看每个函数含义</p> 
 <p align="center"><img src="https://images2.imgbox.com/8f/4e/SL57XvQM_o.png" alt="9638f44ff72c87a693fc0f75ab36136c.png"></p> 
 <p>Working directory：项目名称</p> 
 <p>生成头文件</p> 
 <p>保存工具后，右击需要生成头文件的类，即我们的SimpleHello,选择External Tool，点击我们刚刚创建的tool。</p> 
 <p>然后你就会发现我们的目录中多了一个jni文件夹，jni文件夹里面有一个名字长长的.h文件，成功！</p> 
 <p align="center"><img src="https://images2.imgbox.com/a9/aa/aVBoGPcR_o.png" alt="0b6c4eadd904b36fa0a5cf8fb52be095.png"></p> 
 <p>Tips:</p> 
 <p>该方法适用于jdk8,jdk10中取消了javah，适用javac -h。但是jdk10在使用External Tools时会报错。但是我的工作环境不可能用jdk10，所以我也没有钻进去研究了~</p> 
 <p>3.在vs中创建解决方案</p> 
 <p>长时间没接触过C++了，想当年(10年前)上学那会，我还只会用VC6.0刷刷题，而现在都要vs2017了，而我的C++知识早就忘得差不多了。虽然我作为一个小白，但是仍然阻挡不了我吐槽VS的中文翻译——解决方案,解决方，解决，解，角……emm,真变扭。废话不多说了，我们一起创建一个"解决方案"吧！</p> 
 <p>文件-&gt;新建-&gt;项目-&gt;Windows桌面-&gt;Windows桌面向导，输入名称。</p> 
 <p align="center"><img src="https://images2.imgbox.com/ae/9d/Tz68LstB_o.png" alt="479efaa819631b550763a2a542acdd13.png"></p> 
 <p>选择应用程序类型，注意此处不要勾选预编译标头【参考】</p> 
 <p align="center"><img src="https://images2.imgbox.com/09/07/mMJGZ1ak_o.png" alt="800c8b2aff35bf85bd4706c51c5b69c9.png"></p> 
 <p>设置项目包含目录</p> 
 <p>本来我是按照这篇文章复制jni.h等文件的，但是一直报错“找不到 源 文件 jni.h”。搞来搞去总是不成，后来才发现，我在vs2017直接复制，jni.h并没有到C++项目目录下，而是仍然在原来的目录里，这与java的ide很不同啊。虽然被这个问题搞到差点摔桌子，但我转念一想，在原来的目录下就还不错啊，省得我复制来复制去。于是刷刷刷设置了包含路径</p> 
 <p>点击项目，我的项目叫jniCppDemo,在菜单栏选择项目-&gt;属性-&gt;配置属性-&gt;VC++目录-&gt;包含目录</p> 
 <p align="center"><img src="https://images2.imgbox.com/ed/21/ZwA5BCG0_o.png" alt="d927bde5c941b4a0aecf182107136c5d.png"></p> 
 <p>设置包含路径</p> 
 <p>设置jni.h所在路径 C:\Program Files\Java\jdk1.8.0_181\include</p> 
 <p>设置jni_md.h所在路径 C:\Program Files\Java\jdk1.8.0_181\include\win32</p> 
 <p>设置刚刚生成头文件所在路径 D:\javaWorkspace\jniJavaDemo\jni</p> 
 <p>4.编写cpp文件</p> 
 <p>创建一个cpp文件，其中include jni.h，刚刚生成的头文件。如果上一步设置路径成功，这里不会报错。</p> 
 <p>在这个cpp，参考了这篇文章，实现sayHello，即获取参数name,并返回hello name给java程序。</p> 
 <p>#include "jni.h"</p> 
 <p>#include "stdio.h"</p> 
 <p>#include "string.h"</p> 
 <p>#include "com_study_jni_demo_simple_SimpleHello.h"</p> 
 <p>JNIEXPORT jstring JNICALL Java_com_study_jni_demo_simple_SimpleHello_sayHello(</p> 
 <p>JNIEnv *env, jclass cls, jstring j_str)</p> 
 <p>{<!-- --></p> 
 <p>const char *c_str = NULL;</p> 
 <p>char buff[128] = { 0 };</p> 
 <p>jboolean isCopy;</p> 
 <p>c_str = env-&gt;GetStringUTFChars(j_str, &amp;isCopy);</p> 
 <p>if (c_str == NULL)</p> 
 <p>{<!-- --></p> 
 <p>printf("out of memory.\n");</p> 
 <p>return NULL;</p> 
 <p>}</p> 
 <p>printf("Java Str:%x %s %d %d\n", c_str, c_str, strlen(c_str), isCopy);</p> 
 <p>sprintf_s(buff, "hello %s", c_str);</p> 
 <p>env-&gt;ReleaseStringUTFChars(j_str, c_str);</p> 
 <p>return env-&gt;NewStringUTF(buff);</p> 
 <p>}</p> 
 <p>Tips</p> 
 <p>C++的调用方式和C的调用jni的方式不同，在jni.h中可以看出来，网上很多教程都是基于C的，我这里将其改成了C++的调用方式</p> 
 <p>5.生成dll文件</p> 
 <p>写好了cpp,让我们勇敢地生成dll文件吧。</p> 
 <p>参考文献里指出需要将解决方案平台改成64bit，那就改一下吧，毕竟我们需要运行在64位操作系统上。</p> 
 <p align="center"><img src="https://images2.imgbox.com/1a/ab/O2uxWSIz_o.png" alt="eb6b6b1cb8862a7fb0c15ac5f8119d5e.png"></p> 
 <p>然后右击项目生成/重新生成，就生成了dll文件。从控制台输出可看到dll的地址</p> 
 <p align="center"><img src="https://images2.imgbox.com/19/9e/6GownmTn_o.png" alt="dda28c9b2761f9c668a21d7e208bbe1f.png"></p> 
 <p>6.运行java</p> 
 <p>生成dll文件后，让我们重新回到java项目，我们继续来讨论刚刚遗留的一段代码</p> 
 <p>static {<!-- --></p> 
 <p>// System.loadLibrary("JNICPPDEMO");</p> 
 <p>System.load(Constants.DLLPATH + "JNICPPDEMO.dll");</p> 
 <p>}</p> 
 <p>含义很好理解，就是在java里面加载dll库。注释的方法是如果把dll库拷贝到java项目路径下，可以采用这种方式加载，不用写路径，不需要写后缀。</p> 
 <p>还有一种采用Systerm.load方式，这种需要指定库的位置并加上后缀。由于我在学习过程中，可能会遇到各种问题，来回修改和拷贝很麻烦，于是我采用了第二种方式，为了代码规范及好看，我新建了一个类存放dll的地址。</p> 
 <p>总结</p> 
 <p>至此，一个简单的HelloWorld的JNI项目搭建就打通了，本文采用idea2018和vs2017ide环境，实现了一种简便的搭建方法，这种方法可方便地应用在JNI学习过程中。</p> 
 <p>代码位置</p> 
 <p>后面会更新到github中，敬请期待</p> 
 <p>参考文献</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5c16d9c02820fd707b6e94b2830fd082/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python如何合并数据列表_Python合并两个列表的方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e85d94eb357a1ae9d227a99c8345bb4d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java 反爬虫_springboot反爬虫组件kk-anti-reptile的使用方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>