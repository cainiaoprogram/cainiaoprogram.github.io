<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring 解决循环依赖为什么需要三级缓存，而不是两级缓存? - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring 解决循环依赖为什么需要三级缓存，而不是两级缓存?" />
<meta property="og:description" content="🚀 作者主页： 有来技术
🔥 开源项目： youlai-mall 🍃 vue3-element-admin 🍃 youlai-boot
🌺 仓库主页： Gitee 💫 Github 💫 GitCode
💖 欢迎点赞 👍 收藏 ⭐留言 📝 如有错误敬请纠正！
目录 前言什么是循环依赖？Sprring 的三级缓存为什么需要三级缓存？Spring 循环依赖流程三级缓存源码解析结语 前言 在深入探索Spring框架的高级特性时，一个经常被提及的话题是“循环依赖”，特别是如何通过缓存机制来解决这个问题。循环依赖发生在两个或多个Bean相互依赖的情况下，如果没有合适的处理机制，就会导致应用启动失败或运行时错误。Spring框架通过引入一个三级缓存的机制来优雅地解决这一问题。这引发了一个有趣的问题：为什么是三级缓存而不是两级缓存？在本文中，我们将探讨Spring处理循环依赖的具体机制，尤其是为什么三级缓存是解决这一问题的关键。
什么是循环依赖？ Spring循环依赖指的是两个或多个Bean之间存在直接或间接的循环引用关系。这种情况下，Bean A依赖于Bean B，同时Bean B又依赖于Bean A，形成一个循环依赖关系。在Spring容器中，如果不加以处理，这样的循环依赖可能导致程序无法正常启动或运行时出现异常。
举例说明，假设有两个服务类 A 和 B：
// A.java @Service public class A { private B b; @Autowired public A(B b) { this.b = b; } } // B.java @Service public class B { private A a; @Autowired public B(A a) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4948009c9e18079ac018fb7c3b4fb4d4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-19T23:29:20+08:00" />
<meta property="article:modified_time" content="2023-12-19T23:29:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring 解决循环依赖为什么需要三级缓存，而不是两级缓存?</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>🚀 作者主页： <a href="https://youlai.blog.csdn.net" rel="nofollow">有来技术</a><br> 🔥 开源项目： <a href="https://gitee.com/youlaitech/youlai-mall" rel="nofollow">youlai-mall </a> 🍃 <a href="https://gitee.com/youlaiorg/vue3-element-admin" rel="nofollow">vue3-element-admin</a> 🍃 <a href="https://gitee.com/youlaiorg/youlai-boot" rel="nofollow">youlai-boot</a><br> 🌺 仓库主页： <a href="https://gitee.com/haoxr" rel="nofollow">Gitee</a> 💫 <a href="https://github.com/haoxianrui">Github</a> 💫 <a href="https://gitcode.com/org/youlai">GitCode</a><br> 💖 欢迎点赞 👍 收藏 ⭐留言 📝 如有错误敬请纠正！</p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_7" rel="nofollow">前言</a></li><li><a href="#_11" rel="nofollow">什么是循环依赖？</a></li><li><a href="#Sprring__51" rel="nofollow">Sprring 的三级缓存</a></li><li><a href="#_67" rel="nofollow">为什么需要三级缓存？</a></li><li><a href="#Spring__95" rel="nofollow">Spring 循环依赖流程</a></li><li><a href="#_114" rel="nofollow">三级缓存源码解析</a></li><li><a href="#_180" rel="nofollow">结语</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_7"></a>前言</h2> 
<p>在深入探索Spring框架的高级特性时，一个经常被提及的话题是“循环依赖”，特别是如何通过缓存机制来解决这个问题。循环依赖发生在两个或多个Bean相互依赖的情况下，如果没有合适的处理机制，就会导致应用启动失败或运行时错误。Spring框架通过引入一个三级缓存的机制来优雅地解决这一问题。这引发了一个有趣的问题：为什么是三级缓存而不是两级缓存？在本文中，我们将探讨Spring处理循环依赖的具体机制，尤其是为什么三级缓存是解决这一问题的关键。</p> 
<h2><a id="_11"></a>什么是循环依赖？</h2> 
<p>Spring循环依赖指的是两个或多个Bean之间存在直接或间接的循环引用关系。这种情况下，Bean A依赖于Bean B，同时Bean B又依赖于Bean A，形成一个循环依赖关系。在Spring容器中，如果不加以处理，这样的循环依赖可能导致程序无法正常启动或运行时出现异常。</p> 
<p>举例说明，假设有两个服务类 <code>A</code> 和 <code>B</code>：</p> 
<p><img src="https://images2.imgbox.com/6e/9f/ilXYiwAg_o.jpg" alt="未命名文件 (1)"></p> 
<pre><code class="prism language-java"><span class="token comment">// A.java</span>

<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">B</span> b<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">public</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token class-name">B</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token operator">=</span> b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token comment">// B.java</span>

<span class="token annotation punctuation">@Service</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">A</span> a<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token class-name">A</span> a<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>a <span class="token operator">=</span> a<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>在上面的例子中，<code>A</code> 依赖于 <code>B</code>，而 <code>B</code> 依赖于 <code>A</code>，形成了一个循环依赖。</p> 
<h2><a id="Sprring__51"></a>Sprring 的三级缓存</h2> 
<p>为了解决循环依赖问题，Spring使用了一个三级缓存的机制：</p> 
<ol><li> <p><strong>一级缓存（Singleton Objects）</strong>：这是一个存储完全初始化好的bean的缓存。当一个bean被完全处理并准备好后，它会被放入这个缓存中。</p> </li><li> <p><strong>二级缓存（Early Singleton Objects）</strong>：这个缓存存储的是早期暴露的对象，即还没有完全初始化的bean。这些对象已经被实例化，但可能还没有完成依赖注入和初始化。</p> </li><li> <p><strong>三级缓存（Singleton Factories）</strong>：这个缓存存储的是bean工厂对象，它允许在bean完全初始化之前对其进行引用和操纵。</p> </li></ol> 
<p>关于三级缓存逻辑在方法 <code>DefaultSingletonBeanRegistry#getSingleton</code> 体现的很全面。</p> 
<p><img src="https://images2.imgbox.com/d6/5c/N4fDuyOT_o.png" alt=""></p> 
<h2><a id="_67"></a>为什么需要三级缓存？</h2> 
<p><strong>Spring 解决循环为什么需要三级缓存？两级缓存不可以吗？</strong></p> 
<p>先说结论，两级缓存原则上可以解决循环依赖的问题，包括代理，但在某些情况下实现方式可能不够恰当。</p> 
<table><thead><tr><th>缓存字段名</th><th>缓存级别</th><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td><code>singletonObjects</code></td><td>1</td><td>Map&lt;String, Object&gt;</td><td>存储 Bean 的完成品，完全初始化</td></tr><tr><td><code>earlySingletonObjects</code></td><td>2</td><td>Map&lt;String, Object&gt;</td><td>存储 Bean 的半成品，尚未完成属性填充和初始化</td></tr><tr><td><code>singletonFactories</code></td><td>3</td><td>Map&lt;String, <code>ObjectFactory</code>&gt;</td><td>存储创建 Bean 的 <code>ObjectFactory </code> 对象，生成半成品 Bean 放入二级缓存</td></tr></tbody></table> 
<p>两级缓存分为两种情况来说，分别是 <strong>一级缓存 + 二级缓存</strong> 和 <strong>一级缓存 + 三级缓存</strong> 两种组合。</p> 
<ul><li> <p><strong>组合一：一级缓存 + 二级缓存</strong></p> <p><code>singletonObjects </code>+ <code>earlySingletonObjects</code> 理论可以解决依赖注入，也可以解决代理，但需要每次加入二级缓存都要是代理对象，如果没有代理就完全没有必要，同时也不符合 Spring 对 Bean 生命周期的定义。(对象都应该在创建建之后再进行动态代理而不是单纯的实例化以后就急着进行代理，如果循环依赖就是没办法的事)</p> </li><li> <p><strong>组合二：一级缓存 + 三级缓存</strong></p> <p><code>singletonObjects </code>+ <code>singletonFactories</code> 可以解决依赖注入的问题，但是没法解决代理的问题，若要进行代理从 <code>ObjectFactory </code> 中获取对象实例进行代理，但是这样每次获取对象都不是同一个。</p> </li></ul> 
<p>这里直接说结论，不理解没关系，可以先阅读后续的循环依赖流程和源码再来看结论。</p> 
<h2><a id="Spring__95"></a>Spring 循环依赖流程</h2> 
<p><img src="https://images2.imgbox.com/32/03/TO6VvlZe_o.jpg" alt="Spring 循环依赖流程图"></p> 
<p>循环依赖的处理流程可以大致分为以下几个步骤：</p> 
<ol><li><strong>实例化 A</strong>：Spring容器首先创建Bean A的实例。此时，A还未完全初始化，因为它依赖于B。</li><li><strong>填充B的引用到A中</strong>：在A的创建过程中，Spring检测到A需要B的引用。但是，由于B还未创建，Spring容器会暂停A的创建过程，开始创建B。</li><li><strong>实例化 B</strong>：Spring容器开始创建Bean B的实例。同样，此时B也未完全初始化，因为它依赖于A。</li><li><strong>填充A的引用到B中</strong>：在B的创建过程中，Spring检测到B需要A的引用。这里就出现了循环依赖的情况。但是，由于A的实例已经部分创建，Spring容器可以使用已经存在的A的实例（尽管它还未完全初始化）来解决这个依赖。</li><li><strong>完成 B 的创建</strong>：现在B有了A的引用，Spring可以完成B的初始化过程。</li><li><strong>完成 A的创建</strong>：回到A的创建过程，现在B的实例已经可用，Spring可以完成A的初始化过程。</li><li><strong>处理代理</strong>：如果A有代理（例如，使用了Spring AOP），这个代理将在这个阶段被创建和应用。通常，代理涉及到创建一个新的对象（代理对象），它包装了原始的A实例，并提供了额外的功能（如方法拦截、事务管理等）。</li><li><strong>完全初始化的A和B</strong>：最终，A和B两个Bean都完全初始化了，并且它们相互引用，循环依赖得到了解决。</li></ol> 
<p>Spring通过使用三级缓存机制来解决循环依赖的问题。在这个机制中，Spring会在不同阶段将部分创建的Bean放入不同的缓存中，这样即使在Bean还没有完全初始化的情况下也可以提供这些Bean的引用，从而解决循环依赖的问题。</p> 
<h2><a id="_114"></a>三级缓存源码解析</h2> 
<p>下面是 Spring 循环依赖的调用栈，A和B相互依赖，其中A存在代理。</p> 
<p><img src="https://images2.imgbox.com/b0/9a/bqqWsalw_o.png" alt="image-20231218172644286"></p> 
<p><strong>一切的开始 AbstractBeanFactory#doGetBean</strong></p> 
<pre><code class="prism language-java"> 
<span class="token keyword">protected</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span> <span class="token function">doGetBean</span><span class="token punctuation">(</span>
        <span class="token class-name">String</span> name<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> requiredType<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token keyword">boolean</span> typeCheckOnly<span class="token punctuation">)</span>
        <span class="token keyword">throws</span> <span class="token class-name">BeansException</span> <span class="token punctuation">{<!-- --></span>

    <span class="token class-name">Object</span> beanInstance<span class="token punctuation">;</span>

    <span class="token comment">// 首先尝试从单例缓存中获取手动注册的单例 Bean。</span>
    <span class="token class-name">Object</span> sharedInstance <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>sharedInstance <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> args <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 标识 bean 创建中</span>
        <span class="token class-name">StartupStep</span> beanCreation <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>applicationStartup<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token string">"spring.beans.instantiate"</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">tag</span><span class="token punctuation">(</span><span class="token string">"beanName"</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token comment">// 如果 Bean 定义为单例模式</span>
                sharedInstance <span class="token operator">=</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token comment">// 创建一个新的 Bean 实例。</span>
                        <span class="token keyword">return</span> <span class="token function">createBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                    <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token comment">// 创建失败时销毁单例。</span>
                        <span class="token function">destroySingleton</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>
                        <span class="token keyword">throw</span> ex<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">// 获取 Bean 实例对象，处理特殊情况。</span>
                beanInstance <span class="token operator">=</span> <span class="token function">getObjectForBeanInstance</span><span class="token punctuation">(</span>sharedInstance<span class="token punctuation">,</span> name<span class="token punctuation">,</span> beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">// 原型 Bean 的处理逻辑</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isPrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 标识 Bean 创建结束</span>
            beanCreation<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 将 Bean 实例适配为所需类型。</span>
    <span class="token keyword">return</span> <span class="token function">adaptBeanInsance</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> beanInstance<span class="token punctuation">,</span> requiredType<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> 
<p><strong>代理对象的处理</strong></p> 
<p>实例化A的时候将A工厂(lambda)表达式添加到三级缓存，B填充属性A调用DefaultSingletonBeanRegistry#getSingleton 方法通过<code>singletonFactory.getObject();</code>从三级缓存获取A对象，<code>AbstractAutowireCapableBeanFactory#getEarlyBeanReference</code> → <code>AbstractAutoProxyCreator#getEarlyBeanReference</code>→<code>AbstractAutoProxyCreator#wrapIfNecessary</code></p> 
<p><img src="https://images2.imgbox.com/a2/8b/Pog4QUVG_o.png" alt=""></p> 
<p>关于<code>wrapIfNecessary</code>方法，它是在AOP相关处理中非常关键的一个步骤。如果A的定义中包含了AOP相关的配置（如拦截器、通知等），那么Spring会为A创建一个代理对象，这个代理对象会包含所有的AOP逻辑。</p> 
<p>如果一个bean没有被定义为需要AOP代理，那么<code>wrapIfNecessary</code>方法确实会返回一个原生的半成品对象。这里的“半成品对象”指的是bean实例已经被创建，但可能还没有完成所有的依赖注入或初始化。</p> 
<h2><a id="_180"></a>结语</h2> 
<p>经过对Spring循环依赖处理机制的深入分析，我们可以总结出为什么Spring采用三级缓存而非两级缓存的原因。三级缓存不仅可以解决循环依赖中的依赖注入问题，还能有效处理潜在的代理问题。如果只使用两级缓存，虽然理论上可以解决依赖注入问题，但在处理代理和确保Bean生命周期的一致性方面可能不够完善。三级缓存允许Spring在不完全初始化Bean的情况下提供对其的引用，同时确保在Bean最终完成创建之前，可以对其进行代理和其他必要的处理。这种机制不仅解决了循环依赖的核心问题，而且保持了Spring对Bean生命周期的精确控制，这对于构建稳定和可维护的企业级应用至关重要。通过这种方式，Spring展现了其作为一个成熟和灵活的框架的实力，使开发者能够在复杂的应用场景中有效地管理依赖关系。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/694a1f7f638d21110a774060435dc325/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">gitlab修改代码库的名称、路径和分组</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/52d55089d672a0e84e757ceba5d6019a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">UE4 UE5 一直面向屏幕</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>