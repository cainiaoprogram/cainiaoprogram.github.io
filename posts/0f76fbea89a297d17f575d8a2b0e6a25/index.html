<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JIT VS AOT - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JIT VS AOT" />
<meta property="og:description" content="一、AOT，JIT是什么 JIT，即Just-in-time,动态(即时)编译，边运行边编译；AOT，Ahead Of Time，指运行前编译，是两种程序的编译方式
理解 jit、aot 程序主要有两种运行方式：静态编译与动态解释。静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为AOT （Ahead of time）即 “提前编译”；而解释执行的则是一句一句边翻译边运行，通常将这种类型称为JIT（Just-in-time）即“即时编译”。AOT程序的典型代表是用C/C&#43;&#43;开发的应用，它们必须在执行前编译成机器码，而JIT的代表则非常多，如JavaScript、Python等，事实上，所有脚本语言都支持JIT模式。但需要注意的是JIT和AOT指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以JIT方式运行也可以以AOT方式运行，如Java、Python，它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码，也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，是的，这没有错，不过通常我们区分是否为AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。
2. 区别 这两种编译方式的主要区别在于是否在“运行时”进行编译
优劣 JIT优点： 可以根据当前硬件情况实时编译生成最优机器指令（ps. AOT也可以做到，在用户使用是使用字节码根据机器情况在做一次编译）可以根据当前程序的运行情况生成最优的机器指令序列当程序需要支持动态链接时，只能使用JIT可以根据进程中内存的实际情况调整代码，使内存能够更充分的利用 - JIT缺点： 编译需要占用运行时资源，会导致进程卡顿由于编译时间需要占用运行时间，对于某些代码的编译优化不能完全支持，需要在程序流畅和编译时间之间做权衡在编译准备和识别频繁使用的方法需要占用时间，使得初始编译不能达到最高性能 - AOT优点： 在程序运行前编译，可以避免在运行时的编译性能消耗和内存消耗可以在程序运行初期就达到最高性能可以显著的加快程序的启动 - AOT缺点： 在程序运行前编译会使程序安装的时间增加牺牲Java的一致性将提前编译的内容保存会占用更多的外存 二、JIT深度解析 在从事Java开始的一段时间，那时候经常可以听到什么C&#43;&#43;的瞧不起写Java的，在一些群里也经常看到二个派的人经常互怼。Java能够这么流行与它的跨平台，语言无关性是分不开的，不管你是用Java，python还是Go，只要变成对应的标准字节码文件，那么JVM都是可以识别并执行的，但是那时候的Java之所以被C&#43;&#43;吐槽主要还是因为Java 慢，为什么这么说呢。我们写的程序虽然能被JVM识别，但是不能被机器识别，程序要运行起来，还是得让机器能够识别你的程序，所以JVM还需要一个 解释器，这个解释器就是将你的程序转换成机器能识别的指令，然后执行，如下图
对于一个长期运行的Java进程来说，每次执行都要经过 解释器 将程序翻译成机器指令去执行，那么这个效率就不是很好，这也是为什么Java被吐槽慢的缘故，所以为了解决这个问题，才出现了 JIT。对于一些热点代码（经常被执行的，for循环）的一些代码，在运行时，JVM会将这些代码编译成机器可以执行的机器码，并缓存起来，这样下次执行这些代码的时候，就不需要再经过 解释器去编译了，机器可以直接运行这段程序，提高性能，这个就被称为 即时编译器，简称 JIT编译器。
JIT种类 在JDK1.8中HotSpot虚拟机中，内置了二个JIT，分别为C1编译器和C2编译器C1编译器：是一个简单快速的编译器，主要关注点在于局部性的优化，适用于执行时间较短或者对启动性能有要求的程序，C1编译器几乎不会对代码进行优化。C2编译器：是为长期运行的服务器端应用程序做性能调优的编译器，适用于执行时间较长或对峰值性能有要求的程序，根据各自的适配性，这种即时编译也被称为Server Compiler，但是由于C2代码超级复杂，无人维护，所以才会开发Java编写的Graal编译器代替C2。
热点代码 JIT会将一些热点代码编译成机器能够识别的机器码然后缓存起来，比如一些经常被调用的代码，还有for循环中的代码，那么JIT如何识别出哪些是热点代码呢？？为什么说是一些热点代码缓存起来，而不是全部呢？因为缓存是需要空间存储的。JVM提供了一个参数 -XX:ReservedCodeCacheSize 来限制该缓存的大小，如果空间满了，JIT就无法继续编译，编译执行就会变成解释执行，程序也就会通过解释器去执行。
java -XX:&#43;PrintFlagsFinal -version | grep ReservedCodeCacheSize 热点探测 热点探测也就是检查出那些热点代码，然后进行编译，热点探测是基于计数器的热点探测，也就是会统计每个方法被调用的次数，当次数达到一个阈值的时候，就会被认为是热点代码虚拟机为每个方法准备了俩种计数器，方法调用计数器 和 回边计数器，在确定JVM的运行参数之后，这二个计数器都会有各自的一个阈值，达到阈值就会出发JIT编译。
方法调用计数器：用于统计方法被调用的次数，客户端模式下默认是1500次，在服务端模式下默认是10000次(默认我们都是用服务端模式),我们可以使用以下命令查看 java -XX:&#43;PrintFlagsFinal -version|grep CompileThreshold 回边计数器：用于统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为 回边，该值在服务端模式下默认是10700次 在JVM内存结构中是有一个程序计数器的，它表示的是字节码需要你执行的下一行指令的行号，当我们执行 第一次循环之后，程序又回调到for循环的第一行执行，这个就叫回边 for(int i = 0; i &lt; 10000; i &#43;&#43;) { int a = i; int b = a &#43; i; } JIT是如何优化Java性能的 方法内联 方法内联的优化是指将被调用方法的代码复制到发起调用方法中，避免发生真实的方法调用，举个例子" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0f76fbea89a297d17f575d8a2b0e6a25/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-28T14:38:40+08:00" />
<meta property="article:modified_time" content="2022-07-28T14:38:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JIT VS AOT</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="AOTJIT_0"></a>一、AOT，JIT是什么</h3> 
<p>JIT，即Just-in-time,动态(即时)编译，<code>边运行边编译</code>；AOT，Ahead Of Time，<code>指运行前编译</code>，是两种程序的编译方式</p> 
<ol><li>理解 jit、aot</li></ol> 
<p>程序主要有两种运行方式：静态编译与动态解释。<code>静态编译的程序在执行前全部被翻译为机器码，通常将这种类型称为AOT （Ahead of time）即 “提前编译”；而解释执行的则是一句一句边翻译边运行，通常将这种类型称为JIT（Just-in-time）即“即时编译”</code>。<code>AOT程序的典型代表是用C/C++开发的应用，它们必须在执行前编译成机器码，而JIT的代表则非常多，如JavaScript、Python等</code>，事实上，所有脚本语言都支持JIT模式。但需要注意的是JIT和AOT指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以JIT方式运行也可以以AOT方式运行，如Java、Python，它们可以在第一次执行时编译成中间字节码、然后在之后执行时可以直接执行字节码，也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，是的，这没有错，不过通常我们区分是否为AOT的标准就是看代码在执行之前是否需要编译，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。</p> 
<pre><code>2. 区别
</code></pre> 
<p>这两种编译方式的主要区别在于是否在“运行时”进行编译</p> 
<ol start="3"><li>优劣</li></ol> 
<ul><li>JIT优点：</li></ul> 
<blockquote> 
 <ul><li>可以根据当前硬件情况<code>实时编译生成最优机器指令</code>（ps. AOT也可以做到，在用户使用是使用字节码根据机器情况在做一次编译）</li><li>可以根据当前程序的运行情况<code>生成最优的机器指令序列</code></li><li>当程序<code>需要支持动态链接时，只能使用JIT</code></li><li>可以根据进程中内存的实际情况调整代码，使内存能够更充分的利用</li></ul> 
</blockquote> 
<pre><code>- JIT缺点：
</code></pre> 
<blockquote> 
 <ul><li>编译<code>需要占用运行时资源，会导致进程卡顿</code></li><li>由于<code>编译时间需要占用运行时间，对于某些代码的编译优化不能完全支持，需要在程序流畅和编译时间之间做权衡</code></li><li>在编译准备和识别频繁使用的方法需要占用时间，使得初始编译不能达到最高性能</li></ul> 
</blockquote> 
<pre><code>- AOT优点：
</code></pre> 
<blockquote> 
 <ul><li>在程序<code>运行前编译，可以避免在运行时的编译性能消耗和内存消耗</code></li><li>可以在程序运行初期就达到最高性能</li><li>可以显著的加快程序的启动</li></ul> 
</blockquote> 
<pre><code>- AOT缺点：
</code></pre> 
<blockquote> 
 <ul><li>在程序运行前编译会使程序安装的时间增加</li><li><code>牺牲Java的一致性</code></li><li>将提前编译的内容保存会占用更多的外存</li></ul> 
</blockquote> 
<h3><a id="JIT_48"></a>二、JIT深度解析</h3> 
<p>在从事Java开始的一段时间，那时候经常可以听到什么C++的瞧不起写Java的，在一些群里也经常看到二个派的人经常互怼。Java能够这么流行与它的跨平台，语言无关性是分不开的，<code>不管你是用Java，python还是Go，只要变成对应的标准字节码文件，那么JVM都是可以识别并执行的，但是那时候的Java之所以被C++吐槽主要还是因为Java 慢</code>，为什么这么说呢。我们写的程序虽然能被JVM识别，但是不能被机器识别，程序要运行起来，还是得让机器能够识别你的程序，所以JVM还需要一个 解释器，这个解释器就是将你的程序转换成机器能识别的指令，然后执行，如下图</p> 
<p><img src="https://images2.imgbox.com/7f/12/2pIc3nSx_o.png" alt="在这里插入图片描述"></p> 
<p>对于一个长期运行的Java进程来说，每次执行都要经过 <code>解释器</code> 将程序翻译成机器指令去执行，那么这个效率就不是很好，这也是为什么Java被吐槽慢的缘故，所以为了解决这个问题，才出现了 JIT。对<code>于一些热点代码（经常被执行的，for循环）的一些代码，在运行时，JVM会将这些代码编译成机器可以执行的机器码，并缓存起来，这样下次执行这些代码的时候，就不需要再经过 解释器去编译了，机器可以直接运行这段程序，提高性能，这个就被称为 即时编译器</code>，简称 JIT编译器。</p> 
<ol><li>JIT种类</li></ol> 
<p><img src="https://images2.imgbox.com/9d/9c/HphqSgm1_o.png" alt="在这里插入图片描述"></p> 
<p>在JDK1.8中HotSpot虚拟机中，内置了二个JIT，<code>分别为C1编译器和C2编译器C1编译器</code>：是一个简单快速的编译器，主要关注点在于局部性的优化，适用于执行时间较短或者对启动性能有要求的程序，<code>C1编译器几乎不会对代码进行优化。C2编译器：是为长期运行的服务器端应用程序做性能调优的编译器</code>，适用于执行时间较长或对峰值性能有要求的程序，根据各自的适配性，这种即时编译也被称为Server Compiler，但是由于C2代码超级复杂，无人维护，<code>所以才会开发Java编写的Graal编译器代替C2</code>。</p> 
<ol start="2"><li>热点代码</li></ol> 
<p>JIT会将一些热点代码编译成机器能够识别的机器码然后缓存起来，比如一些经常被调用的代码，还有for循环中的代码，那么JIT如何识别出哪些是热点代码呢？？<code>为什么说是一些热点代码缓存起来，而不是全部呢？因为缓存是需要空间存储的</code>。JVM提供了一个参数 <code>-XX:ReservedCodeCacheSize</code> 来限制该缓存的大小，如果空间满了，JIT就无法继续编译，编译执行就会变成解释执行，程序也就会通过解释器去执行。</p> 
<pre><code class="prism language-java">java <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span><span class="token class-name">PrintFlagsFinal</span> <span class="token operator">-</span>version <span class="token operator">|</span> grep <span class="token class-name">ReservedCodeCacheSize</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/91/19/LmxB6Tcp_o.png" alt="在这里插入图片描述"></p> 
<ol start="3"><li>热点探测</li></ol> 
<p>热点探测也就是检查出那些热点代码，然后进行编译，热点探测是基于计数器的热点探测，<code>也就是会统计每个方法被调用的次数，当次数达到一个阈值的时候，就会被认为是热点代码虚拟机为每个方法准备了俩种计数器</code>，<code>方法调用计数器</code> 和 <code>回边计数器</code>，在确定JVM的运行参数之后，这二个计数器都会有各自的一个阈值，达到阈值就会出发JIT编译。</p> 
<ul><li>方法调用计数器：用于统计方法被调用的次数，客户端模式下默认是1500次，在服务端模式下默认是10000次(默认我们都是用服务端模式),我们可以使用以下命令查看</li></ul> 
<pre><code class="prism language-bash">java -XX:+PrintFlagsFinal -version<span class="token operator">|</span><span class="token function">grep</span> CompileThreshold
</code></pre> 
<ul><li>回边计数器：用于统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为 回边，该值在服务端模式下默认是10700次</li></ul> 
<pre><code class="prism language-java">在JVM内存结构中是有一个程序计数器的，它表示的是字节码需要你执行的下一行指令的行号，当我们执行
第一次循环之后，程序又回调到<span class="token keyword">for</span>循环的第一行执行，这个就叫回边

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">int</span> a <span class="token operator">=</span> i<span class="token punctuation">;</span>
     <span class="token keyword">int</span> b <span class="token operator">=</span> a <span class="token operator">+</span> i<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="4"><li>JIT是如何优化Java性能的</li></ol> 
<ul><li>方法内联</li></ul> 
<p>方法内联的优化是指将被调用方法的代码复制到发起调用方法中，避免发生真实的方法调用，举个例子</p> 
<pre><code class="prism language-java">方法<span class="token function">add1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>要计算四个数加起来的和，然后又调用了 <span class="token function">add2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法，其实根本没必要有 <span class="token function">add2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>这个方法，所以JIT会进行优化
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">,</span><span class="token keyword">int</span> d<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token function">add2</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">add2</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add2</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
优化后就一个方法就行了<span class="token punctuation">,</span>也就是把 <span class="token function">add2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法要执行的代码直接复制到 <span class="token function">add1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法中执行，就不要去，调用 <span class="token function">add2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>这个方法了，这样就不存在方法调用，就一个方法就可以了
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">add1</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">,</span><span class="token keyword">int</span> c<span class="token punctuation">,</span><span class="token keyword">int</span> d<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c <span class="token operator">+</span> d<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>为什么方法内联可以优化Java性能呢？<code>我们知道一个方法的执行在JVM内存结构中虚拟机栈对应的就是入栈，方法结束就对应着出栈，出栈和入栈都是有性能消耗的，所以少一个方法执行就减少了一次对应的出栈和入栈，性能也就能够提升。</code></p> 
<ul><li>锁消除</li></ul> 
<p>在非线程安全情况下，我们都会使用线程安全的容器，举个例子，<code>比如字符串拼接的StringBuffer和StringBuilder，StringBuffer的方法被关键字synchornized修饰，所以性能会比StringBuilder差，但是在局部方法中二者的性能确实差不多的，因为在局部方法中是单线程访问的，不存在线程安全问题。</code></p> 
<pre><code class="prism language-java"><span class="token comment">// jdk8默认情况下开启了锁消除</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">long</span> start_sb <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000000</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">SBuilder</span><span class="token punctuation">(</span><span class="token string">"king"</span><span class="token punctuation">,</span><span class="token string">"coco"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">long</span> end_sb <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"StringBuilder话费的时间："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end_sb <span class="token operator">-</span> start_sb<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token keyword">long</span> start_sf <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10000000</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">SBuffer</span><span class="token punctuation">(</span><span class="token string">"king"</span><span class="token punctuation">,</span><span class="token string">"coco"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">long</span> end_sf <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"StringBuffer话费的时间："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end_sf <span class="token operator">-</span> start_sf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>


<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">SBuilder</span><span class="token punctuation">(</span><span class="token class-name">String</span> str1<span class="token punctuation">,</span><span class="token class-name">String</span> str2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">StringBuilder</span> stringBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    stringBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    stringBuilder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token class-name">SBuffer</span><span class="token punctuation">(</span><span class="token class-name">String</span> str1<span class="token punctuation">,</span><span class="token class-name">String</span> str2<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">StringBuffer</span> stringBuffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    stringBuffer<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    stringBuffer<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>花费的时间差不多<br> <img src="https://images2.imgbox.com/58/b0/BLvzLBgw_o.png" alt="在这里插入图片描述"></p> 
<p>然后我们可以通过启动参数 <code>-XX:-EliminateLocks</code> 关闭锁消除，<code>-XX:+EliminateLocks</code>开启锁消除</p> 
<p><img src="https://images2.imgbox.com/bc/16/SRzrF6sV_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/90/e8/IZVYNuY7_o.png" alt="在这里插入图片描述"></p> 
<p>关<code>闭了锁消除之后，StringBuffer所话费的时间明显增加了很多</code>，性能降低了,JIT在编译的时候发现如果使用了线程安全的容器，比如StringBUffer，但是发现程序不会存在线程并发问题，就会执行锁消除来提高程序的性能</p> 
<ul><li>逃逸分析</li></ul> 
<p>Java创建的大部分对象都是在堆中的，而不是全部的对象。<code>逃逸分析技术就是在创建对象的时候判断你这个对象是在保存在堆中还是保存在栈中</code>，那么保存在栈中有什么好处呢？？首先说说保存在堆中吧，JVM垃圾收集的主要对象就是堆，创建的对象在堆中保存，那么当你这个对象不用 的时候就要被回收，我们知道垃圾回收是会消耗一定的性能的，但是<code>如果你这个对象经过逃逸分析之后，发现这个对象可以在栈中分配，那么当你这个方法结束之后，也就是出栈，那么该对象自然就没了，也不需要垃圾收集器回收，这样就减少了垃圾收集器的工作，性能自然就能提升了。</code></p> 
<pre><code class="prism language-java">我们创建了一个<span class="token class-name">StringBuilder</span>对象，但是这个对象只有在这个方法内部有效，该对象没有被返回出去，也就是说没有方法需要<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法创建的这个<span class="token class-name">StringBuilder</span>对象，所以这个<span class="token class-name">StringBuilder</span>对象不会发生逃逸
<span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token string">"123"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

这个<span class="token class-name">StringBuilder</span>对象就发生逃逸了，因为有其它方法需要<span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法创建的<span class="token class-name">StringBuilder</span>对象，也就是说这个对象发生了逃逸
<span class="token keyword">public</span> <span class="token class-name">StringBuilder</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token class-name">StringBuilder</span> sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> sb<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>逃逸分析性能测试：<code>逃逸分析默认开启</code></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">long</span> start <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">50000000</span><span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token function">createPeople</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">long</span> end <span class="token operator">=</span> <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"花费的时间是："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>end <span class="token operator">-</span> start<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">createPeople</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">People</span> people <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token string">"coco"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">People</span><span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Integer</span> age<span class="token punctuation">;</span>
    <span class="token class-name">String</span> name<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">People</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> age<span class="token punctuation">,</span><span class="token class-name">String</span> name<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>添加打印GC收集信息<br> <img src="https://images2.imgbox.com/2a/42/WWyhOBq7_o.png" alt="在这里插入图片描述"><br> 发现这么多对象很快就创建好了，<code>并且没有垃圾收集日志的打印</code><br> <img src="https://images2.imgbox.com/58/21/W66gKDId_o.png" alt="在这里插入图片描述"></p> 
<ul><li>关闭逃逸分析</li></ul> 
<p><img src="https://images2.imgbox.com/f8/8d/yDfQLFOs_o.png" alt="在这里插入图片描述"><br> 关闭逃逸分析之后，所话费的时间显著上升</p> 
<p><img src="https://images2.imgbox.com/a3/b1/SL6BGSTi_o.png" alt="在这里插入图片描述"><br> 并且我们可以加伤GC打印日志</p> 
<p><img src="https://images2.imgbox.com/b3/d8/fJIaNSig_o.png" alt="在这里插入图片描述"></p> 
<p>发现有GC的收集信息,因为对象都在堆中，所以才发生了GC，相反，<code>开启逃逸分析技术的对象是随着栈的出入直接销毁的，不需要进行GC，所以性能会提升</code><br> <img src="https://images2.imgbox.com/45/19/HuR7DZv9_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="AOT_235"></a>三、AOT深度解析</h3> 
<p>从java9开始，java就引入了aot（Ahead Of Time）的编译技术。</p> 
<p><a href="https://tech.meituan.com/2020/10/22/java-jit-practice-in-meituan.html" rel="nofollow">参考文章</a><br> <a href="https://juejin.cn/post/7120030108076736542" rel="nofollow">参考文章</a><br> <a href="https://www.bilibili.com/video/BV1134y1h7ED?spm_id_from=333.999.0.0&amp;vd_source=143bc861504e0e9f2651de95bcd4561e" rel="nofollow">参考视频</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b108f64602cacb74048031ee30dcf3a6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">numpy和pytorch中的元素拼接操作：stack，concatenat，cat</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ced36ab9544300783ef145290409b120/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android四大组件之——Service</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>