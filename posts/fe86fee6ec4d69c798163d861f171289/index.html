<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>golang实践-目录结构与工具 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="golang实践-目录结构与工具" />
<meta property="og:description" content="这个话题确实是老调重弹，但确异常重要。 老实说，用go做正式项目之前，写过scala，但那个SBT太折磨人，偶然就上了go。两者语法的差别就不说了，但入坑之后才发现水深：没有模块部署及官方的版本管理工具，会带来很多麻烦。 反复折腾了近一年，基本上形成了一点固有的模式，做一般项目还算能够简单支持。没什么特别的技术点，更多只是一点心得。
一、目录结构 我们的代码以rpc为主，http为辅（调用rpc，也辅助测试），基本上一个项目就按照下面这个目录结构定制。
//project directory --src //源代码目录，需纳入vcs --package1 --package1 --main.go //package1编译生成的执行文件源代码 --othersubpackage --package2 --package2 --main.go //这么摆放，是因为执行文件默认是[目录名] --othersubpackage --utils//公共的代码 --vendor //第三方包目录，glide生成，可不纳入vcs glide.yaml //glide生成的文件，需纳入vcs glide.lock //glide生成的文件，需纳入vcs --cfg //配置文件存放目录，需纳入vcs package1.yaml --pkg --bin compile.sh //编译脚本 .bash_profile //工程环境 以上结构，适合于内部项目开发，按照项目进行统一采用glide进行管理。就版本管理工具有很多选择，考虑glide主要是：
简单，第一次用的时候半分钟搞定。只需要在src目录下，先后执行glide init、glide install；定期用一下glide up，自动升级第三方包。golang.org不再被墙之后，基本能一次性更新。 但要特别注意，glide在使用的时候，对tag标签的规则有一定的要求，需要遵循 Semantic Versions 的规则。之前，个别知名的库不是很规范，经常在up的时候反而是老版本，但现在这种问题很少。 安装glide也很简单，因为用的macos，所以brew install glide 就很容易搞定。 当然，github上面很多也用godep，如果有精力，可以投入时间去熟悉、使用。 编译脚本 compile.sh是一个代码编译脚本，偶尔进行一下维护就好。
#清理 go clean all #需要维护的包，只需要列出含有执行文件的包名 MYSERVICE=(&#34;package1&#34; &#34;package2&#34;) #生成本地运行文件 for SERVER in ${MYSERVICE[*]} do echo &#34;正在编译服务$SERVER mac版&#34; go install $SERVER/." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fe86fee6ec4d69c798163d861f171289/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-10-18T16:05:35+08:00" />
<meta property="article:modified_time" content="2016-10-18T16:05:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">golang实践-目录结构与工具</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>这个话题确实是老调重弹，但确异常重要。 <br> 老实说，用go做正式项目之前，写过scala，但那个SBT太折磨人，偶然就上了go。两者语法的差别就不说了，但入坑之后才发现水深：没有模块部署及官方的版本管理工具，会带来很多麻烦。 <br> 反复折腾了近一年，基本上形成了一点固有的模式，做一般项目还算能够简单支持。没什么特别的技术点，更多只是一点心得。</p> 
<hr> 
<h3 id="一目录结构">一、目录结构</h3> 
<p>我们的代码以rpc为主，http为辅（调用rpc，也辅助测试），基本上一个项目就按照下面这个目录结构定制。</p> 
<pre class="prettyprint"><code class="language-Shell hljs haml"><span class="hljs-comment">//project directory</span>
-<span class="ruby">-src  /<span class="hljs-regexp">/源代码目录，需纳入vcs
</span></span>    -<span class="ruby">-package1
</span>        -<span class="ruby">-package1
</span>            -<span class="ruby">-main.go   /<span class="hljs-regexp">/package1编译生成的执行文件源代码
</span></span>        -<span class="ruby">-othersubpackage
</span>    -<span class="ruby">-package2
</span>        -<span class="ruby">-package2
</span>            -<span class="ruby">-main.go  /<span class="hljs-regexp">/这么摆放，是因为执行文件默认是[目录名]
</span></span>        -<span class="ruby">-othersubpackage
</span>    -<span class="ruby">-utils/<span class="hljs-regexp">/公共的代码
</span></span>    -<span class="ruby">-vendor /<span class="hljs-regexp">/第三方包目录，glide生成，可不纳入vcs
</span></span>    glide.yaml  //glide生成的文件，需纳入vcs
    glide.lock  //glide生成的文件，需纳入vcs
-<span class="ruby">-cfg /<span class="hljs-regexp">/配置文件存放目录，需纳入vcs
</span></span>    package1.yaml 
-<span class="ruby">-pkg
</span>-<span class="ruby">-bin
</span>compile.sh  //编译脚本
.bash_profile //工程环境</code></pre> 
<p>以上结构，适合于内部项目开发，按照项目进行统一采用<a href="https://github.com/Masterminds/glide" title="glide">glide</a>进行管理。就版本管理工具有很多选择，考虑glide主要是：</p> 
<ol><li>简单，第一次用的时候半分钟搞定。只需要在src目录下，先后执行glide init、glide install；定期用一下glide up，自动升级第三方包。</li><li>golang.org不再被墙之后，基本能一次性更新。 <br> 但要特别注意，glide在使用的时候，对tag标签的规则有一定的要求，需要遵循 <a href="http://semver.org/" rel="nofollow" title="Semantic Versions">Semantic Versions</a> 的规则。之前，个别知名的库不是很规范，经常在up的时候反而是老版本，但现在这种问题很少。 <br> 安装glide也很简单，因为用的macos，所以brew install glide 就很容易搞定。 <br> 当然，github上面很多也用godep，如果有精力，可以投入时间去熟悉、使用。</li></ol> 
<p><strong>编译脚本</strong> <br> compile.sh是一个代码编译脚本，偶尔进行一下维护就好。</p> 
<pre class="prettyprint"><code class="language-Shell hljs r"><span class="hljs-comment">#清理</span>
go clean all
<span class="hljs-comment">#需要维护的包，只需要列出含有执行文件的包名</span>
MYSERVICE=(<span class="hljs-string">"package1"</span> <span class="hljs-string">"package2"</span>)
<span class="hljs-comment">#生成本地运行文件</span>
 <span class="hljs-keyword">for</span> SERVER <span class="hljs-keyword">in</span> ${MYSERVICE[*]}
        do
        echo <span class="hljs-string">"正在编译服务$SERVER mac版"</span>
        go install $SERVER/<span class="hljs-keyword">...</span>
 done
<span class="hljs-comment">#生成linux运行文件</span>
 <span class="hljs-keyword">for</span> SERVER <span class="hljs-keyword">in</span> ${MYSERVICE[*]}
        do
        echo <span class="hljs-string">"正在编译服务$SERVER linux版"</span>
       GOOS=linux GOARCH=amd64 go install $SERVER/<span class="hljs-keyword">...</span>
 done</code></pre> 
<p><strong>环境变量设置</strong> <br> .bash_profile是工程的环境变量设置。最初是为了避免不同项目在go get的时候，将该项目的包放入其他项目中【后来用了glide不存在这个问题，但这个习惯继续沿用】。我们采用不同项目的根目录下增加了这个文件。每次进相关项目的时候，加载一下即可。加载很简单：</p> 
<pre class="prettyprint"><code class="language-shell hljs avrasm">source <span class="hljs-preprocessor">.bash</span>_profile //或者
. <span class="hljs-preprocessor">.bash</span>_profile</code></pre> 
<p>暂时该文件的内容很少，最核心的就是gopath的设置，这个将直接影响到go get的包存放地址。</p> 
<pre class="prettyprint"><code class="language-shell hljs ruby">export <span class="hljs-constant">GOPATH</span>=<span class="hljs-regexp">/Users/xx</span><span class="hljs-regexp">/dev/code</span><span class="hljs-regexp">/project</span></code></pre> 
<p>采用这个方式，如果要想不同项目用不同的go版本，也就easy了。</p> 
<p><strong>程序配置文件</strong> <br> 项目实施过程中，除了用环境变量，先后用了ini、json、yaml三种格式文件作为程序的启动参数配置文件。 <br> json做配置很简单，直接读即可。可以封装一个方法：</p> 
<pre class="prettyprint"><code class="language-Go hljs ruby">func <span class="hljs-constant">ReadJson</span>(filename string, <span class="hljs-function"><span class="hljs-keyword">def</span> </span>interface{}) error {
    data, err <span class="hljs-symbol">:</span>= ioutil.<span class="hljs-constant">ReadFile</span>(filename)
    <span class="hljs-keyword">if</span> err != <span class="hljs-keyword">nil</span> {
        <span class="hljs-keyword">return</span> fmt.<span class="hljs-constant">Errorf</span>(<span class="hljs-string">"ReadJson failed: %T %v"</span>, <span class="hljs-function"><span class="hljs-keyword">def</span>, </span>err)
    }
    <span class="hljs-keyword">if</span> err = json.<span class="hljs-constant">Unmarshal</span>(data, <span class="hljs-function"><span class="hljs-keyword">def</span>);</span> err != <span class="hljs-keyword">nil</span> {
        <span class="hljs-keyword">return</span> fmt.<span class="hljs-constant">Errorf</span>(<span class="hljs-string">"ReadJson failed: %T %v %v"</span>, <span class="hljs-function"><span class="hljs-keyword">def</span>, </span>filename, err)
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">nil</span>
}</code></pre> 
<p>最大不足在于无法为配置写描述，这在使用的时候要配合第三方文档。</p> 
<p>ini作为配置文件，其实很强悍，可以用第三方库<a href="github.com/larspensjo/config" rel="nofollow">config</a>来调用，支持很全：</p> 
<ul><li>[x] 可以有备注</li><li>[x] 可以分章节</li><li>[x] 可以在值中用变量</li><li>[ ] idea对ini没有好的编写插件。</li></ul> 
<p>最终是因为用glide才开始了解yaml，发现作为配置文件，有很明显的优势：</p> 
<ul><li>写作方式类似于ini，相对于json能备注，不用写括号</li><li>支持数组，缩进表示内嵌struct</li><li>ide有yaml编写插件，能够简单的颜色、缩进显示。</li><li>绝大部分go代码，都采用yaml，本来就有技术需要。</li><li>包的支持不错<a href="http://gopkg.in/yaml.v2" rel="nofollow">gopkg.in/yaml.v2</a>，使用简单。配置文件不正确情况下，只影响对应属性的赋值。从而可以用初始值对象，健壮性提升。 <br> 这一点，可以补充一段代码来描述：</li></ul> 
<pre class="prettyprint"><code class="language-Go hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
    <span class="hljs-string">"fmt"</span>
    <span class="hljs-string">"gopkg.in/yaml.v2"</span>
)

<span class="hljs-keyword">type</span> T <span class="hljs-keyword">struct</span> {
    F <span class="hljs-typename">int</span> <span class="hljs-string">`yaml:"a,omitempty"`</span>
    B []<span class="hljs-typename">string</span>
    C <span class="hljs-typename">int</span>
    D <span class="hljs-typename">float64</span>
}

<span class="hljs-keyword">func</span> main() {
    <span class="hljs-keyword">var</span> t T
    t.D =<span class="hljs-number"> 9</span>                                                        <span class="hljs-comment">//提供一个初始值，判定出错情况下是否改变</span>
    err := yaml.Unmarshal([]<span class="hljs-typename">byte</span>(<span class="hljs-string">"a: 1\nb: 12 \nc: 3 \nd: a"</span>), &amp;t) <span class="hljs-comment">//输入条件中，b和d的值是错误的</span>
    fmt.Println(err)
    fmt.Println(t)
    <span class="hljs-comment">//output:</span>
    <span class="hljs-comment">//yaml: unmarshal errors:</span>
    <span class="hljs-comment">//line 2: cannot unmarshal !!int `12` into []string</span>
    <span class="hljs-comment">//line 4: cannot unmarshal !!str `a` into float64</span>
    <span class="hljs-comment">//{1 [] 3 9}   &lt;--可以看出，a、c的识别没有错，t.D依然为原始值。</span>
}</code></pre> 
<hr> 
<h3 id="二常用工具">二、常用工具</h3> 
<p><strong>IDE</strong> <br> 对于基本没有专属开发工具的语言而言，go的开发环境反而百花齐放。我自己先后用过LiteIDE、subtext line 3 、atom、eclipse、idea。这几个工具各有特长</p> 
<ul><li>LiteIDE 功能单一，容易上手，适合新人。</li><li>Sublime Text 、atom 资源占用少，前者的秒开太无敌。团队中，曾经搞c++、c服务端的玩过。自己用惯IDE，不是很适应同一个语言要装n个插件。</li><li>eclipse，15年的时候很不错，每次修改代码都会自动build一次，很便于查找问题。但相对于前两者，对go语言没有特别亮点的额外支持。</li><li>idea，这是神器，除了coding，对yaml、json的维护，写js、sql等都方便（eclpise也有）。人无我有的重构，至今还是所向披靡。</li></ul> 
<p>由于工程中除了go，js、sql、yaml都有涉及，实际项目中都选择的IDE。16年开始，因为插件越来越成熟，问题处理及时（晚上提交bug，早上醒来就已经搞定），现在只用idea。只是，由于go的接口实现不用显示声明，它的shift+F6有点不够强悍。 <br> 人生苦短。对于有php、python开发经历的，直接选择idea，没必要折腾其他工具。</p> 
<p><strong>代码分析</strong> <br> 作为还算新的语言，加上没有类似于lightbend这种商用公司，go的配套工具比较少。 <br> 平时，内部开发可用go vet、golint这两种辅助工具进行代码分析。虽然效果远远比不上sonar，但可以将就用。 <br> 如果在github上共享，则可以用[goreport card][5]网站，通过内嵌常用工具，以网页+链接方式给出语法警告，可当做sonar简化版。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7574dbc537aa0baa8aa2f7202c1c2d68/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">安全漏洞--C/C&#43;&#43;代码安全漏洞审计技术学习分享</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3087c270eca0737e0a2113a7b229c993/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ES7标准  fetch请求封装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>