<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux 网卡特性配置 ethtool 详解 网卡Offload - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux 网卡特性配置 ethtool 详解 网卡Offload" />
<meta property="og:description" content="网络中校验和比较 2015年10月14日
本文说明了网卡，IP层，TCP层，UDP层的校验和功能，以及异同点。
网卡校验和
高级的网卡(e1000e等千M网卡)的接收，发送的校验和的计算方法是CRC32。
Refs：7.10. Checksums
http://www.intel.com/content/dam/doc/manual/pci-pci-x-family-gbe-controllers-software-dev-manual.pdf
可以使用ethtool查看网卡的校验功能，rx-checksumming是接收端的校验功能，tx-checksumming是发送端的校验功能：
# ethtool -k eth0 Offload parameters for eth0: rx-checksumming: on tx-checksumming: on scatter-gather: on tcp-segmentation-offload: on udp-fragmentation-offload: off generic-segmentation-offload: on generic-receive-offload: on large-receive-offload: off
IP校验和
校验和只对头部进行，不包括数据部分。
发送IP包, 计算checksum：
（1）把IP数据报的首部校验和字段设置为0。 （2）把首部看成以16位为单位的数字组成，依次进行二进制反码求和。 （3）把得到的结果存入校验和字段中。
接收IP包，验证checksum：
（1）把首部看成以16位为单位的数字组成，依次进行二进制反码求和，包括校验和字段。 （2）检查计算出的校验和的结果是否为全1。 （3）如果全1，校验是和正确。否则，校验和就是错误的，协议栈要抛弃这个数据包。但不生成差错报文，由上层去发现丢失的数据报并进行重传。
Refs：
RFC 791 - Internet Protocol
UDP校验和
校验和即覆盖头部，也覆盖数据部分。UDP校验和是可选的，而TCP校验和是必须的。
发送包, 计算checksum：
算法和IP头部的校验和计算方法类似：二进制反码求和。但有下面两个区别：
1) 总长度如果是奇数，则自动补齐，并自动填充为0. 填充的部分不发送出去。
2）添加12个字节的伪头部。源地址(4个字节)，目的地址(4个字节)，0(1个字节)，udp协议号(1个字节)，udp头部中长度字段值(2个字节)。
如果校验和字段是0，表示不需要计算校验和。
接收包, 验证checksum：
验证checksum是根据udp头部中的length字段值所指向的数据长度进行校验，如果length字段值大于实际的数据长度，那么包在校验前会被丢弃。如果length字段值小于实际的数据长度，则需要裁减数据，并校验。
TCP校验和
校验和即覆盖头部，也覆盖数据部分。TCP校验和是必须的。也包含了12个字节的伪头部。
Linux Networking: How todisable/enable offload features, RX/TX checksum, scatter, gather and beyond Submitted by root on Mon,03/02/2015 - 10:17" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5654115a6b479529af992e09c5f8a549/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-16T14:14:37+08:00" />
<meta property="article:modified_time" content="2022-02-16T14:14:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux 网卡特性配置 ethtool 详解 网卡Offload</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p></p> 
<p></p> 
<h3><strong>网络中校验和比较</strong></h3> 
<p></p> 
<p><span style="color:#bbbbbb;">2015</span><span style="color:#bbbbbb;">年10</span>月14日</p> 
<p><span style="color:#666666;">本文说明了网卡，IP</span>层，TCP层，UDP层的校验和功能，以及异同点。</p> 
<p><span style="color:#666666;"> </span></p> 
<p><span style="color:#666666;">网卡校验和</span></p> 
<p><span style="color:#666666;">高级的网卡(e1000e</span>等千M网卡)的接收，发送的校验和的计算方法是CRC32。</p> 
<p><span style="color:#666666;">Refs</span><span style="color:#666666;">：<a href="http://www.wireshark.org/docs/wsug_html_chunked/ChAdvChecksums.html" rel="nofollow" title="7.10. Checksums">7.10. Checksums</a></span></p> 
<p><span style="color:#666666;"><a href="http://www.intel.com/content/dam/doc/manual/pci-pci-x-family-gbe-controllers-software-dev-manual.pdf" rel="nofollow" title="http://www.intel.com/content/dam/doc/manual/pci-pci-x-family-gbe-controllers-software-dev-manual.pdf">http://www.intel.com/content/dam/doc/manual/pci-pci-x-family-gbe-controllers-software-dev-manual.pdf</a></span></p> 
<p><span style="color:#666666;"> </span></p> 
<p><span style="color:#666666;">可以使用ethtool</span>查看网卡的校验功能，rx-checksumming是接收端的校验功能，tx-checksumming是发送端的校验功能：</p> 
<p><span style="color:#666666;"># ethtool -k eth0 </span><br><span style="color:#666666;">Offload parameters for eth0: <br> rx-checksumming: on <br> tx-checksumming: on <br> scatter-gather: on <br> tcp-segmentation-offload: on <br> udp-fragmentation-offload: off <br> generic-segmentation-offload: on <br> generic-receive-offload: on <br> large-receive-offload: off</span></p> 
<p><span style="color:#666666;"> </span></p> 
<p><span style="color:#666666;">IP</span><span style="color:#666666;">校验和</span></p> 
<p><span style="color:#666666;">校验和只对头部进行，不包括数据部分。</span></p> 
<p><span style="color:#666666;">发送IP</span>包, 计算checksum：</p> 
<p><span style="color:#666666;">（1</span>）把IP数据报的首部校验和字段设置为0。 <br> （2）把首部看成以16位为单位的数字组成，依次进行二进制反码求和。 <br> （3）把得到的结果存入校验和字段中。</p> 
<p><span style="color:#666666;"> </span></p> 
<p><span style="color:#666666;">接收IP</span>包，验证checksum：</p> 
<p><span style="color:#666666;">（1</span>）把首部看成以16位为单位的数字组成，依次进行二进制反码求和，包括校验和字段。 <br> （2）检查计算出的校验和的结果是否为全1。 <br> （3）如果全1，校验是和正确。否则，校验和就是错误的，协议栈要抛弃这个数据包。但不生成差错报文，由上层去发现丢失的数据报并进行重传。</p> 
<p><span style="color:#666666;"> </span></p> 
<p><span style="color:#666666;">Refs</span><span style="color:#666666;">：</span></p> 
<p><span style="color:#666666;"><a href="http://tools.ietf.org/html/rfc791" rel="nofollow" title="RFC 791 - Internet Protocol">RFC 791 - Internet Protocol</a></span></p> 
<p><span style="color:#666666;"> </span></p> 
<p><span style="color:#666666;">UDP</span><span style="color:#666666;">校验和</span></p> 
<p><span style="color:#666666;">校验和即覆盖头部，也覆盖数据部分。UDP</span>校验和是可选的，而TCP校验和是必须的。</p> 
<p><span style="color:#666666;">发送包, </span>计算checksum：</p> 
<p><span style="color:#666666;">算法和IP</span>头部的校验和计算方法类似：二进制反码求和。但有下面两个区别：</p> 
<p><span style="color:#666666;">1) </span><span style="color:#666666;">总长度如果是奇数，则自动补齐，并自动填充为0. </span>填充的部分不发送出去。</p> 
<p><span style="color:#666666;">2</span><span style="color:#666666;">）添加12</span>个字节的伪头部。源地址(4个字节)，目的地址(4个字节)，0(1个字节)，udp协议号(1个字节)，udp头部中长度字段值(2个字节)。</p> 
<p><span style="color:#666666;">如果校验和字段是0</span>，表示不需要计算校验和。</p> 
<p><span style="color:#666666;"> </span></p> 
<p><span style="color:#666666;">接收包, </span>验证checksum：</p> 
<p><span style="color:#666666;">验证checksum</span>是根据udp头部中的length字段值所指向的数据长度进行校验，如果length字段值大于实际的数据长度，那么包在校验前会被丢弃。如果length字段值小于实际的数据长度，则需要裁减数据，并校验。</p> 
<p><span style="color:#666666;"> </span></p> 
<p><span style="color:#666666;">TCP</span><span style="color:#666666;">校验和</span></p> 
<p><span style="color:#666666;">校验和即覆盖头部，也覆盖数据部分。TCP</span>校验和是必须的。也包含了12个字节的伪头部。</p> 
<p></p> 
<p></p> 
<h3></h3> 
<h3><a href="http://docs.gz.ro/node/282" rel="nofollow" title="Linux Networking: How todisable/enable offload features, RX/TX checksum, scatter, gather and beyond">Linux Networking: How todisable/enable offload features, RX/TX checksum, scatter, gather and beyond</a></h3> 
<p>Submitted by root on Mon,03/02/2015 - 10:17</p> 
<p>http://docs.gz.ro/node/282</p> 
<p><span style="color:#000000;"> </span></p> 
<p><span style="color:#000000;">TCP offload engine or TOE is a technology used in networkinterface cards (NIC) to offload processing of the entire TCP/IP stack to thenetwork controller. It is primarily used with high-speed network interfaces,such as gigabit Ethernet and 10 Gigabit Ethernet, where processing overhead ofthe network stack becomes significant.<br> The term, TOE, is often used to refer to the NIC itself, although circuit boardengineers may use it to refer only to the integrated circuit included on thecard which processes the TCP headers. TOEs are often suggested as a way toreduce the overhead associated with IP storage protocols such as iSCSI and NFS.Read more about this on <a href="https://en.wikipedia.org/wiki/TCP_offload_engine" rel="nofollow" title="wikipedia">wikipedia</a>.</span></p> 
<p><span style="color:#000000;">Linux doesn't support TOE by default because of many reasonsmentioned <a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/toe" rel="nofollow" title="here">here</a>.<br> But even if TOE is not suitable, at least for now, there are other settingsthat could improve your network (especially if you use it for iSCSI). So readon and remember: in most of the cases, these settings must be ON but you haveto test and see what is suitable for your environment. Enjoy!</span></p> 
<h4><a name="_Toc505244599"></a><a name="Offload_features">Offload features</a></h4> 
<p><br><span style="color:#000000;">Most of these offload features are configured using the <strong><em><u>ethtool</u></em></strong> tool.In order to check which features are set, you can use the <strong><em><u>-k</u></em></strong> parameter.Also, in order to disable/enable, use <strong><em><u>-K</u></em></strong> or <strong><em><u>--offload</u></em></strong> parameteralong with the desired features.<br><strong>Display:</strong> </span><code><span style="background-color:#b2afd1;">ethtool -kethX</span></code><br><span style="color:#000000;"><strong>Enable (recommended):</strong> </span><code><span style="background-color:#b2afd1;">ethtool -K ethX rx on tx on</span></code><br><span style="color:#000000;"><strong>Disable:</strong> </span><code><span style="background-color:#b2afd1;">ethtool -KethX rx off tx off</span></code></p> 
<p><a name="Example"><span style="color:#086782;">Example:</span></a></p> 
<p><br>  </p> 
<div> 
 <pre><span style="color:#03028b;">root@pluto:~# ethtool -k eth2</span></pre> 
 <pre><span style="color:#03028b;">Features for eth2:</span></pre> 
 <pre><span style="color:#03028b;">rx-checksumming: off</span></pre> 
 <pre><span style="color:#03028b;">tx-checksumming: on</span></pre> 
 <pre><span style="color:#03028b;">        </span>tx-checksum-ipv4: off [fixed]</pre> 
 <pre><span style="color:#03028b;">        </span>tx-checksum-unneeded: off [fixed]</pre> 
 <pre><span style="color:#03028b;">        </span>tx-checksum-ip-generic: on</pre> 
 <pre><span style="color:#03028b;">       </span> tx-checksum-ipv6: off [fixed]</pre> 
 <pre><span style="color:#03028b;">        </span>tx-checksum-fcoe-crc: off [fixed]</pre> 
 <pre><span style="color:#03028b;">        </span><a name="baidusnap0"></a><strong><span style="background-color:#ffff66;">tx-checksum-sctp</span></strong><span style="color:#03028b;">: off [fixed]</span></pre> 
 <pre><span style="color:#03028b;">scatter-gather: on</span></pre> 
 <pre><span style="color:#03028b;">        </span>tx-scatter-gather: on</pre> 
 <pre><span style="color:#03028b;">        </span>tx-scatter-gather-fraglist: off [fixed]</pre> 
 <pre><span style="color:#03028b;">tcp-segmentation-offload: on</span></pre> 
 <pre><span style="color:#03028b;">        </span>tx-tcp-segmentation: on</pre> 
 <pre><span style="color:#03028b;">        </span>tx-tcp-ecn-segmentation: off [fixed]</pre> 
 <pre><span style="color:#03028b;">        </span>tx-tcp6-segmentation: off [fixed]</pre> 
 <pre><span style="color:#03028b;">udp-fragmentation-offload: off [fixed]</span></pre> 
 <pre><span style="color:#03028b;">generic-segmentation-offload: on</span></pre> 
 <pre><span style="color:#03028b;">generic-receive-offload: on</span></pre> 
 <pre><span style="color:#03028b;">large-receive-offload: off [fixed]</span></pre> 
 <pre><span style="color:#03028b;">rx-vlan-offload: on</span></pre> 
 <pre><span style="color:#03028b;">tx-vlan-offload: on [fixed]</span></pre> 
 <pre><span style="color:#03028b;">ntuple-filters: off [fixed]</span></pre> 
 <pre><span style="color:#03028b;">receive-hashing: off [fixed]</span></pre> 
 <pre><span style="color:#03028b;">highdma: off [fixed]</span></pre> 
 <pre><span style="color:#03028b;">rx-vlan-filter: on [fixed]</span></pre> 
 <pre><span style="color:#03028b;">vlan-challenged: off [fixed]</span></pre> 
 <pre><span style="color:#03028b;">tx-lockless: off [fixed]</span></pre> 
 <pre><span style="color:#03028b;">netns-local: off [fixed]</span></pre> 
 <pre><span style="color:#03028b;">tx-gso-robust: off [fixed]</span></pre> 
 <pre><span style="color:#03028b;">tx-fcoe-segmentation: off [fixed]</span></pre> 
 <pre><span style="color:#03028b;">fcoe-mtu: off [fixed]</span></pre> 
 <pre><span style="color:#03028b;">tx-nocache-copy: on</span></pre> 
 <pre><span style="color:#03028b;">loopback: off [fixed]</span></pre> 
 <pre><span style="color:#03028b;">root@pluto:~# ethtool --offload eth2 rx off tx off</span></pre> 
 <pre><span style="color:#03028b;">Actual changes:</span></pre> 
 <pre><span style="color:#03028b;">tx-checksumming: off</span></pre> 
 <pre><span style="color:#03028b;">        </span>tx-checksum-ip-generic: off</pre> 
 <pre><span style="color:#03028b;">scatter-gather: off</span></pre> 
 <pre><span style="color:#03028b;">        </span>tx-scatter-gather: off [requested on]</pre> 
 <pre><span style="color:#03028b;">tcp-segmentation-offload: off</span></pre> 
 <pre><span style="color:#03028b;">        </span>tx-tcp-segmentation: off [requested on]</pre> 
 <pre><span style="color:#03028b;">generic-segmentation-offload: off [requested on]</span></pre> 
 <pre><span style="color:#03028b;">root@pluto:~# ethtool --offload eth2 rx on tx on</span></pre> 
 <pre><span style="color:#03028b;">Actual changes:</span></pre> 
 <pre><span style="color:#03028b;">rx-checksumming: on</span></pre> 
 <pre><span style="color:#03028b;">tx-checksumming: on</span></pre> 
 <pre><span style="color:#03028b;">        </span>tx-checksum-ip-generic: on</pre> 
 <pre><span style="color:#03028b;">scatter-gather: on</span></pre> 
 <pre><span style="color:#03028b;">        </span>tx-scatter-gather: on</pre> 
 <pre><span style="color:#03028b;">tcp-segmentation-offload: on</span></pre> 
 <pre><span style="color:#03028b;">        </span>tx-tcp-segmentation: on</pre> 
 <pre><span style="color:#03028b;">generic-segmentation-offload: on</span></pre> 
</div> 
<h4><a name="_Toc505244600"></a><a name="TCP_Segmentation_Offload_TSO">TCP Segmentation Offload (TSO)</a></h4> 
<p><br><span style="color:#000000;">This is useful to reduce CPU overhead and it is also called Large SegmentOffload (LSO).<br> In order to enable/disable TCP segmentation offload, you must use <strong><em><u>ethtool</u></em></strong> commandwith <strong><em><u>tso</u></em></strong> option:<br><strong>Display:</strong> </span><code><span style="background-color:#b2afd1;">ethtool -k ethX | grep tcp-segmentation</span></code><br><span style="color:#000000;"><strong>Enable (recommended):</strong> </span><code><span style="background-color:#b2afd1;">ethtool -K ethX tso on</span></code><br><span style="color:#000000;"><strong>Disable:</strong> </span><code><span style="background-color:#b2afd1;">ethtool -K ethX tso off</span></code></p> 
<p><span style="color:#086782;">Example:</span></p> 
<p><br>  </p> 
<div> 
 <pre><span style="color:#03028b;">root@pluto:~# ethtool -K eth2 tso off</span></pre> 
 <pre><span style="color:#03028b;">root@pluto:~# ethtool -k eth2 | grep segmentation</span></pre> 
 <pre><span style="color:#03028b;">tcp-segmentation-offload: off</span></pre> 
 <pre><span style="color:#03028b;">        </span>tx-tcp-segmentation: off</pre> 
 <pre><span style="color:#03028b;">        </span>tx-tcp-ecn-segmentation: off [fixed]</pre> 
 <pre><span style="color:#03028b;">        </span>tx-tcp6-segmentation: off [fixed]</pre> 
 <pre><span style="color:#03028b;">generic-segmentation-offload: on</span></pre> 
 <pre><span style="color:#03028b;">tx-fcoe-segmentation: off [fixed]</span></pre> 
</div> 
<p><br>  </p> 
<div> 
 <pre><span style="color:#03028b;">root@pluto:~# ethtool -K eth2 tso on</span></pre> 
 <pre><span style="color:#03028b;">root@pluto:~# ethtool -k eth2 | grep segmentation</span></pre> 
 <pre><span style="color:#03028b;">tcp-segmentation-offload: on</span></pre> 
 <pre><span style="color:#03028b;">        </span>tx-tcp-segmentation: on</pre> 
 <pre><span style="color:#03028b;">     </span>   tx-tcp-ecn-segmentation: off [fixed]</pre> 
 <pre><span style="color:#03028b;">        </span>tx-tcp6-segmentation: off [fixed]</pre> 
 <pre><span style="color:#03028b;">generic-segmentation-offload: on</span></pre> 
 <pre><span style="color:#03028b;">tx-fcoe-segmentation: off [fixed]</span></pre> 
</div> 
<h4><a name="_Toc505244601"></a><a name="Scatter_and_Gather">Scatter and Gather</a></h4> 
<p><br><span style="color:#000000;">Scatter and Gather (Vectored I/O) is a concept that was primarily used in harddisks and it enhances large I/O request performance, if supported by thehardware.<br> To manipulate this feature, you must use the same <strong><em><u>ethtool</u></em></strong> commandwith the following parameter:</span></p> 
<p><strong><span style="color:#000000;">Display:</span></strong><span style="color:#000000;"> </span><code><span style="background-color:#b2afd1;">ethtool -kethX | grep scatter-gather</span></code><br><span style="color:#000000;"><strong>Enable (recommended):</strong> </span><code><span style="background-color:#b2afd1;">ethtool -K ethX sg on</span></code><br><span style="color:#000000;"><strong>Disable:</strong> </span><code><span style="background-color:#b2afd1;">ethtool -K ethX sg off</span></code></p> 
<p><span style="color:#086782;">Example:</span></p> 
<p><br>  </p> 
<div> 
 <pre><span style="color:#03028b;">root@pluto:~# ethtool -k eth2 | grep scatter-gather</span></pre> 
 <pre><span style="color:#03028b;">scatter-gather: on</span></pre> 
 <pre><span style="color:#03028b;">        </span>tx-scatter-gather: on</pre> 
 <pre><span style="color:#03028b;">        </span>tx-scatter-gather-fraglist: off [fixed]</pre> 
</div> 
<p><br>  </p> 
<div> 
 <pre><span style="color:#03028b;">root@pluto:~# ethtool -K eth2 sg off</span></pre> 
 <pre><span style="color:#03028b;">Actual changes:</span></pre> 
 <pre><span style="color:#03028b;">scatter-gather: off</span></pre> 
 <pre><span style="color:#03028b;">        </span>tx-scatter-gather: off</pre> 
 <pre><span style="color:#03028b;">tcp-segmentation-offload: off</span></pre> 
 <pre><span style="color:#03028b;">        </span>tx-tcp-segmentation: off [requested on]</pre> 
 <pre><span style="color:#03028b;">generic-segmentation-offload: off [requested on]</span></pre> 
</div> 
<p><br>  </p> 
<div> 
 <pre><span style="color:#03028b;">root@pluto:~# ethtool -K eth2 sg on</span></pre> 
 <pre><span style="color:#03028b;">Actual changes:</span></pre> 
 <pre><span style="color:#03028b;">scatter-gather: on</span></pre> 
 <pre><span style="color:#03028b;">        </span>tx-scatter-gather: on</pre> 
 <pre><span style="color:#03028b;">tcp-segmentation-offload: on</span></pre> 
 <pre><span style="color:#03028b;">        </span>tx-tcp-segmentation: on</pre> 
 <pre><span style="color:#03028b;">generic-segmentation-offload: on</span></pre> 
</div> 
<h4><a name="_Toc505244602"></a><a name="Generic_Segmentation_Offload">Generic Segmentation Offload</a></h4> 
<p><br><span style="color:#000000;">This feature is related to TSO so it is advisable to enable them together. Itcan be done with <strong><em><u>ethtool</u></em></strong> command also:<br><strong>Display:</strong> </span><code><span style="background-color:#b2afd1;">ethtool -k ethX | grepgeneric-segmentation-offload</span></code><br><span style="color:#000000;"><strong>Enable (recommended):</strong> </span><code><span style="background-color:#b2afd1;">ethtool -K ethX gso on</span></code><br><span style="color:#000000;"><strong>Disable:</strong> </span><code><span style="background-color:#b2afd1;">ethtool -K ethX gso off</span></code></p> 
<p><span style="color:#086782;">Example:</span></p> 
<p><br>  </p> 
<div> 
 <pre><span style="color:#03028b;">root@pluto:~# ethtool -K eth2 gso off</span></pre> 
 <pre><span style="color:#03028b;">root@pluto:~# ethtool -k eth2 | grep generic-segmentation-offload</span></pre> 
 <pre><span style="color:#03028b;">generic-segmentation-offload: off</span></pre> 
</div> 
<p><br>  </p> 
<div> 
 <pre><span style="color:#03028b;">root@pluto:~# ethtool -K eth2 gso on</span></pre> 
 <pre><span style="color:#03028b;">root@pluto:~# ethtool -k eth2 | grep generic-segmentation-offload</span></pre> 
 <pre><span style="color:#03028b;">generic-segmentation-offload: on</span></pre> 
</div> 
<h4><a name="_Toc505244603"></a><a name="UDP__TCP_Checksum_errors_in_uitcpdumpiu_">UDP / TCP Checksum errors in <em><u>tcpdump</u></em> output</a></h4> 
<p><br><span style="color:#000000;">To avoid any extra search from your part, if you have offload features enabledand you see <strong><em><u>cksum incorrect</u></em></strong> in tcpdump output,without any packet errors and your network is working properly: it is nothingto worry about because the checksum is actually calculated on the networkadapter and the tcpdump is showing the checksum calculated on kernel level.Read more <a href="http://sokratisg.net/2012/04/01/udp-tcp-checksum-errors-from-tcpdump-nic-hardware-offloading/" rel="nofollow" title="here">here</a> if you are curious.</span></p> 
<p></p> 
<h3><a href="http://www.cnblogs.com/danxi/p/6591885.html" rel="nofollow" title="Linux 网卡特性配置ethtool详解">Linux 网卡特性配置ethtool详解</a></h3> 
<h3>近期遇到一个自定义报文传输性能问题，解决过程中借助了<span style="color:#000000;">ethtool</span><span style="color:#000000;">这个工具，因此发掘一下与此工具相关的网卡的一些特性。</span></h3> 
<p><span style="color:#000000;">ethtool </span> <span style="color:#000000;">常用命令如下，比如对</span><span style="color:#000000;">eth0</span><span style="color:#000000;">的操作：</span></p> 
<p></p> 
<p><span style="color:#000000;">ethtool eth0       </span><span style="color:#008000;">//</span><span style="color:#008000;">查询ethx</span>网口基本设置，其中 x 是对应网卡的编号，如eth0、eth1等等</p> 
<p><span style="color:#000000;">ethtool –h        </span><span style="color:#008000;">//</span><span style="color:#008000;">显示ethtool</span>的命令帮助(help)</p> 
<p><span style="color:#000000;">ethtool –ieth0    </span><span style="color:#008000;">//</span><span style="color:#008000;">查询eth0</span>网口的相关信息</p> 
<p><span style="color:#000000;">ethtool –deth0    </span><span style="color:#008000;">//</span><span style="color:#008000;">查询eth0</span>网口注册性信息</p> 
<p><span style="color:#000000;">ethtool –reth0    </span><span style="color:#008000;">//</span><span style="color:#008000;">重置eth0</span>网口到自适应模式</p> 
<p><span style="color:#000000;">ethtool –Seth0    </span><span style="color:#008000;">//</span><span style="color:#008000;">查询eth0</span>网口收发包统计</p> 
<p><span style="color:#000000;">ethtool –s eth0[speed </span><span style="color:#800080;">10</span><span style="color:#000000;">|</span><span style="color:#800080;">100</span><span style="color:#000000;">|</span><span style="color:#800080;">1000</span><span style="color:#000000;">] [duplex half|full] </span>[autoneg on|off]        <span style="color:#008000;">//</span><span style="color:#008000;">设置网口速率10/100/1000M</span>、设置网口半/全双工、设置网口是否自协商</p> 
<p></p> 
<p><span style="color:#000000;">我这里主要想发掘一下</span><span style="color:#000000;">ethtool -k </span><span style="color:#000000;">相关的内容，以下命令在</span><span style="color:#000000;">ubuntu 14.04</span><span style="color:#000000;">上亲测：</span></p> 
<p><span style="color:#000000;">1</span><span style="color:#000000;">、</span><span style="color:#000000;">rx-checksumming: off      </span></p> 
<p><span style="color:#000000;">    </span><span style="color:#000000;">接收侧硬件校验和计算，如能设置为</span><span style="color:#000000;">on</span><span style="color:#000000;">，表示网卡支持该特性，命令：</span><span style="color:#000000;"> ethtool -K eth0 rx-checksum on|off</span></p> 
<p><span style="color:#000000;">2</span><span style="color:#000000;">、</span><span style="color:#000000;">tx-checksumming:on      </span></p> 
<p><span style="color:#000000;">    </span><span style="color:#000000;">发送侧硬件校验和计算，如能设置为</span><span style="color:#000000;">on</span><span style="color:#000000;">，表示网卡支持该特性，命令：</span><span style="color:#000000;"> ethtool -K eth0 tx-checksum-ip-generic on|off</span></p> 
<p><span style="color:#000000;">3</span><span style="color:#000000;">、</span><span style="color:#000000;">scatter-gather:on          </span></p> 
<p><span style="color:#000000;">    </span><span style="color:#000000;">分散</span><span style="color:#000000;">/</span><span style="color:#000000;">聚集</span><span style="color:#000000;"> (Scatter Gather) </span><span style="color:#000000;">功能，是网卡要支持</span><span style="color:#000000;">TSO</span><span style="color:#000000;">的必要条件之一。</span></p> 
<p><span style="color:#000000;">4</span><span style="color:#000000;">、</span><span style="color:#000000;">tcp-segmentation-offload: on </span></p> 
<p><span style="color:#000000;">    </span><span style="color:#000000;">简称</span><span style="color:#000000;">TSO</span><span style="color:#000000;">，是一种利用网卡对</span><span style="color:#000000;">TCP</span><span style="color:#000000;">数据包分片，减轻</span><span style="color:#000000;">CPU</span><span style="color:#000000;">负荷的一种</span><span style="color:#000000;"><a href="http://www.07net01.com/tags-%E6%8A%80%E6%9C%AF-0.html" rel="nofollow" title="技术">技术</a></span><span style="color:#000000;">，有时也被叫做</span><span style="color:#000000;"> LSO (Large segment offload) </span><span style="color:#000000;">，</span><span style="color:#000000;">TSO</span><span style="color:#000000;">是针对</span><span style="color:#000000;">TCP</span><span style="color:#000000;">的，</span><span style="color:#000000;">UFO</span><span style="color:#000000;">是针对</span><span style="color:#000000;">UDP</span><span style="color:#000000;">的。如果硬件支持</span><span style="color:#000000;"> TSO</span><span style="color:#000000;">功能，同时也需要硬件支持的</span><span style="color:#000000;">TCP</span><span style="color:#000000;">校验计算和分散</span><span style="color:#000000;">/</span><span style="color:#000000;">聚集</span><span style="color:#000000;"> (Scatter Gather) </span><span style="color:#000000;">功能。命令：</span><span style="color:#000000;"> ethtool -K eth0 tso on|off</span></p> 
<p><span style="color:#000000;">     </span><strong><span style="color:#000000;">在不支持</span><span style="color:#000000;">TSO</span><span style="color:#000000;">的网卡上，</span><span style="color:#000000;">TCP</span><span style="color:#000000;">层向</span><span style="color:#000000;">IP</span><span style="color:#000000;">层发送数据会考虑</span><span style="color:#000000;">mss</span><span style="color:#000000;">，使得</span><span style="color:#000000;">TCP</span><span style="color:#000000;">向下发送的数据可以包含在一个</span><span style="color:#000000;">IP</span><span style="color:#000000;">分组中而不会造成分片，</span><span style="color:#000000;"> mss</span><span style="color:#000000;">是在</span><span style="color:#000000;">TCP</span><span style="color:#000000;">初始建立连接时由网卡</span><span style="color:#000000;">MTU</span><span style="color:#000000;">确定并和对端协商的，所以在一个</span><span style="color:#000000;">MTU</span><span style="color:#000000;">＝</span><span style="color:#000000;">1500</span><span style="color:#000000;">的网卡上，</span><span style="color:#000000;">TCP</span><span style="color:#000000;">向下发送的数据不会大于</span><span style="color:#000000;">min(mss_local, mss_remote)-ip</span><span style="color:#000000;">头</span><span style="color:#000000;">-tcp</span><span style="color:#000000;">头。</span></strong><br><span style="color:#000000;"><strong>      </strong></span><strong><span style="color:#000000;">网卡支持</span><span style="color:#000000;">TSO</span><span style="color:#000000;">时，</span><span style="color:#000000;">TCP</span><span style="color:#000000;">层会逐渐增大</span><span style="color:#000000;">mss</span><span style="color:#000000;">（总是整数倍数增加），当</span><span style="color:#000000;">TCP</span><span style="color:#000000;">层向下发送大块数据时，仅仅计算</span><span style="color:#000000;">TCP</span><span style="color:#000000;">头，网卡接到到了</span><span style="color:#000000;">IP</span><span style="color:#000000;">层传下的大数据包后自己重新分成若干个</span><span style="color:#000000;">IP</span><span style="color:#000000;">数据包，添加</span><span style="color:#000000;">IP</span><span style="color:#000000;">头，复制</span><span style="color:#000000;">TCP</span><span style="color:#000000;">头并且重新计算校验和等相关数据，这样就把一部分</span><span style="color:#000000;">CPU</span><span style="color:#000000;">相关的处理工作转移到由网卡来处理。</span></strong></p> 
<p><span style="color:#000000;">5</span><span style="color:#000000;">、</span><span style="color:#000000;">udp-fragmentation-offload: off</span></p> 
<p><span style="color:#000000;">    </span><span style="color:#000000;">简称</span><span style="color:#000000;">UFO</span><span style="color:#000000;">，是网卡对</span><span style="color:#000000;">udp</span><span style="color:#000000;">提供的类似</span><span style="color:#000000;">TSO</span><span style="color:#000000;">的技术。</span><span style="color:#000000;">命令：</span><span style="color:#000000;">ethtool -K eth0 ufo on | off</span></p> 
<p><span style="color:#000000;">    </span><span style="color:#000000;">在我的网卡上不支持这个特性，所以命令执行失败是这样的：</span></p> 
<p><span style="color:#000000;">root@ubuntu:~#ethtool -K eth0 ufo on</span></p> 
<p><span style="color:#000000;">Cannot changeudp-fragmentation-offload</span></p> 
<p><span style="color:#000000;">Could not changeany device features</span></p> 
<p><span style="color:#000000;">6</span><span style="color:#000000;">、</span><span style="color:#000000;">generic-segmentation-offload: on</span></p> 
<p><span style="color:#000000;">     </span> <span style="color:#000000;">简称</span><span style="color:#000000;">GSO</span><span style="color:#000000;">，它比</span><span style="color:#000000;">TSO</span><span style="color:#000000;">更通用，基本思想就是尽可能的推迟数据分片直至发送到网卡驱动之前，此时会检查网卡是否支持分片功能（如</span><span style="color:#000000;">TSO</span><span style="color:#000000;">、</span><span style="color:#000000;">UFO</span><span style="color:#000000;">）</span><span style="color:#000000;">, </span><span style="color:#000000;">如果支持直接发送到网卡，如果不支持就进行分片后再发往网卡。这样大数据包只需走一次协议栈，而不是被分割成几个数据包分别走，这就提高了效率。命令：</span><span style="color:#000000;"> ethtool -K eth0 gso on | off</span></p> 
<p><span style="color:#000000;">7</span><span style="color:#000000;">、</span><span style="color:#000000;">large-receive-offload: off</span></p> 
<p><span style="color:#000000;">　　简称</span><span style="color:#000000;">LRO</span><span style="color:#000000;">，通过将接收到的多个</span><span style="color:#000000;">TCP</span><span style="color:#000000;">数据聚合成一个大的数据包，然后传递给网络协议栈处理，以减少上层协议栈处理</span><span style="color:#000000;">开销，提高系统接收</span><span style="color:#000000;">TCP</span><span style="color:#000000;">数据包的能力。</span></p> 
<p><span style="color:#000000;">8</span><span style="color:#000000;">、</span><span style="color:#000000;">generic-receive-offload: on</span></p> 
<p><span style="color:#000000;">    </span><span style="color:#000000;">简称</span><span style="color:#000000;">GRO</span><span style="color:#000000;">，基本思想跟</span><span style="color:#000000;">LRO</span><span style="color:#000000;">类似，克服了</span><span style="color:#000000;">LRO</span><span style="color:#000000;">的一些缺点，更通用。后续的驱动都使用</span><span style="color:#000000;">GRO</span><span style="color:#000000;">的接口，而不是</span><span style="color:#000000;">LRO</span><span style="color:#000000;">。</span></p> 
<p><span style="color:#000000;"> </span></p> 
<p><span style="color:#000000;">附：</span></p> 
<p><span style="color:#000000;">RSS(Receive Side Scaling)</span><span style="color:#000000;">，是一项网卡的新特性，俗称多队列。具备多个</span><span style="color:#000000;">RSS</span><span style="color:#000000;">队列的网卡，可以将不同的网络流分成不同的队列，再分别将这些队列分配到多个</span><span style="color:#000000;">CPU</span><span style="color:#000000;">核心上进行处理，从而将负荷分散，充分利用多核</span><span style="color:#000000;">CPU</span><span style="color:#000000;">的能力。</span></p> 
<p><span style="color:#000000;"> </span></p> 
<p></p> 
<p></p> 
<h3>网卡Offload</h3> 
<p><span style="color:#666666;">对于网络安全来说，网络传输数据包的捕获和分析是个基础工作，绿盟科技研究员在日常工作中，经常会捕获到一些大小远大于MTU</span>值的数据包，经过分析这些大包的特性，发现和网卡的offload特性有关，本文对网卡Offload技术做简要描述。</p> 
<p></p> 
<h4>MTU</h4> 
<p><span style="color:#666666;">最大传输单元，指一种通信协议的某一层上面所能通过的最大数据包大小（以字节为单位）。</span></p> 
<p><span style="color:#666666;">在以太网通信中，MTU</span>规定了经过网络层封装的数据包的最大长度。例如，若某个接口的MTU值为1500，则通过此接口传送的IP数据包的最大长度为1500字节。</p> 
<p><span style="color:#666666;">小编注：对于普通用户来说，如果你优化过迅雷的下载速度，可能通过这篇文章《<a href="http://yangtai.xunlei.com/?p=1326" rel="nofollow" title="合理设置MTU">合理设置MTU</a></span><span style="color:#4c4c4c;">，提升下载速度</span>》，对MTU的基础知识有所了解。</p> 
<p><strong><span style="color:#666666;">IP</span><span style="color:#666666;">分片</span></strong></p> 
<p><span style="color:#666666;">当IP</span>层需要传送的数据包长度超过MTU值时，则IP层需要对该数据包进行分片，使每一片的长度小于或等于MTU值。在分片过程中，除了对payload进行分片外，数据包的IP首部也需要进行相应的更改：</p> 
<ul><li>将identifier字段的值复制给每个分片；</li><li>将分片数据包的Flags中的DF位置为0；</li><li>除最后一个分片之外的其他分片，将MF位置为1；</li><li>将Fragment Offset字段设置正确的值。  </li></ul> 
<p><strong><span style="color:#666666;">MSS</span></strong></p> 
<p><span style="color:#666666;">最大分段长度，TCP</span>数据包每次能够传输的最大数据分段长度，在TCP协议的实际实现中，MSS往往用MTU-(IPHeader Length + TCP Header Length)来代替。在TCP通信建立连接时，取两端提供的MSS的最小值作为会话的MSS值。由于TCP分段有MSS值的限制，通常情况下TCP数据包经IP层封装后的长度不会大于MTU，因此一般情况下，TCP数据包不会进行IP分片。</p> 
<h4>机制</h4> 
<p><span style="color:#666666;">早先TCP</span>设计的目标是为了解决低速网络传输的不可靠性问题（拨号上网的年代），但随着互联网骨干传输速度的提升（光纤、千兆以太、万兆以太）以及用户端更可靠的访问机制的出现（ADSL等），相关的数据中心及客户端桌面环境上的TCP软件常常需要面临大量的计算需求。</p> 
<p><span style="color:#666666;">当网络速度超过1Gb</span>的时候，这些计算会耗费大量的CPU时间，有数据表明，即便使用千兆全双工网卡，TCP通信也将消耗CPU的80%的使用率（以2.4GHz奔腾4处理器为例），这样留给其他应用程序的时间就很少了，表现出来就是用户可能感觉到很慢。</p> 
<p><span style="color:#666666;">小编注：当年的蠕虫病毒对CPU</span>的影响与此近似。</p> 
<p><span style="color:#666666;">为了解决性能问题，就产生了TOE</span>技术（TCP offload engine），将TCP连接过程中的相关计算工作转移到专用硬件上（比如网卡），从而释放CPU资源。从2012年开始，这项技术开始在普通用户的网卡上应用。</p> 
<p><span style="color:#666666;">随着技术的日趋成熟，目前越来越多的网卡设备开始支持offload</span>特性，以便提升网络收发和处理的性能。本文所描述的offload特性，主要是指将原本在协议栈中进行的IP分片、TCP分段、重组、checksum校验等操作，转移到网卡硬件中进行，降低系统CPU的消耗，提高处理性能。</p> 
<h4>**TSO <span style="color:#666666;"> （tcp-segmentation-offload</span><span style="background-color:#FFFFFF;">） **</span></h4> 
<p><span style="color:#666666;">从名字来看很直观，就是把tcp</span>分段的过程转移到网卡中进行。当网卡支持TSO机制时，可以直接把不超过滑动窗口大小的payload下传给协议栈，即使数据长度大于MSS，也不会在TCP层进行分段，同样也不会进行IP分片，而是直接传送给网卡驱动，由网卡驱动进行tcp分段操作，并执行checksum计算和包头、帧头的生成工作。例如，</p> 
<p><span style="color:#666666;">在本地主机上（10.8.55.1</span>）发送一个超长的HTTP请求，当TSO模式关闭时，10.8.55.1抓包如下</p> 
<p></p> 
<p><span style="color:#666666;"> </span></p> 
<p><span style="color:#666666;">当TSO</span>模式开启时，10.8.55.1抓包如下：</p> 
<p></p> 
<p><span style="color:#666666;"> </span></p> 
<p><span style="color:#666666;">**UFO</span><span style="color:#666666;">（udp-fragmentation-offload</span>） **</p> 
<p><span style="color:#666666;">是一种专门针对udp</span>协议的特性，主要机制就是将IP分片的过程转移到网卡中进行，用户层可以发送任意大小的udp数据包（udp数据包总长度最大不超过64k），而不需要协议栈进行任何分片操作。目前貌似没找到有支持UFO机制的网卡，主要是应用在虚拟化设备上。</p> 
<p><span style="color:#666666;">**GSO</span><span style="color:#666666;">（generic-segmentation-offload</span>） **</p> 
<p><span style="color:#666666;">相对于TSO</span>和UFO，GSO机制是针对所有协议设计的，更为通用。同时，与TSO、UFO不同的是，GSO主要依靠软件的方式实现，对于网卡硬件没有过多的要求。其基本思想就是把数据分片的操作尽可能的向底层推迟直到数据发送给网卡驱动之前，并先检查网卡是否支持TSO或UFO机制，如果支持就直接把数据发送给网卡，否则的话再进行分片后发送给网卡，以此来保证最少次数的协议栈处理，提高数据传输和处理的效率。</p> 
<h4>**LRO/GRO<span style="color:#666666;">（large-receive-offload</span><span style="background-color:#FFFFFF;">） **</span></h4> 
<p><span style="color:#666666;">在网卡驱动层面上将接受到的多个TCP</span>数据包聚合成一个大的数据包，然后上传给协议栈处理。这样可以减少协议栈处理的开销，提高系统接收TCP数据的能力和效率。</p> 
<p><strong><span style="color:#666666;">generic-receive-offload</span></strong><span style="color:#666666;">，基本思想和LRO</span>类似，只是改善了LRO的一些缺点，比LRO更加通用。目前及后续的网卡都采用GRO机制，不再使用LRO机制。例如，</p> 
<p><span style="color:#666666;">当本地主机（10.51.19.40</span>）开启GRO模式时，从主机10.8.55.11向主机10.51.19.40发送一个超长请求。</p> 
<p><span style="color:#666666;">10.8.55.11</span><span style="color:#666666;">抓包如下：</span></p> 
<p></p> 
<p><span style="color:#666666;">10.51.19.40</span><span style="color:#666666;">抓包如下：</span></p> 
<p></p> 
<p><span style="color:#666666;"> **RSS</span><span style="color:#666666;">（Receive Side Scaling</span>）**</p> 
<p><span style="color:#666666;">具备多个RSS</span>队列的网卡，可以将不同的网络流分成不同的队列，再将这些队列分配到多个CPU核心上进行处理，从而将负荷分散，充分利用多核处理器的能力，提交数据接收的能力和效率。</p> 
<h4>模式的设置</h4> 
<p><strong><span style="color:#4c4c4c;">Linux</span></strong></p> 
<p><span style="color:#666666;">在linux</span>系统下，可以通过ethtool查看各模式的状态并进行设置：</p> 
<p><span style="color:#666666;">**</span><span style="color:#666666;">查看状态 **</span></p> 
<p><span style="color:#666666;">1.   </span> <span style="color:#4c4c4c;">ethtool –k </span><span style="color:#4c4c4c;">设备名</span></p> 
<p></p> 
<p><span style="color:#666666;">  **</span><span style="color:#666666;">设置开关状态 **</span></p> 
<ol><li><span style="color:#4c4c4c;">ethtool –K </span><span style="color:#4c4c4c;">设备名</span><span style="color:#4c4c4c;"> </span><span style="color:#4c4c4c;">模式名（缩写）</span><span style="color:#4c4c4c;">on/off</span></li></ol> 
<p></p> 
<p><strong><span style="color:#4c4c4c;">windows</span></strong></p> 
<p><span style="color:#666666;">在windows</span>系统下，可以通过设备管理器中网卡设备的属性对网卡模式进行查看和调整。以Intel 82579LM和Intel I217-LM网卡为例</p> 
<p></p> 
<p></p> 
<ul><li>IPv4、TCP、UDP校验和分载传输控制的是在网卡中进行checksum的计算和校验，其中Rx表示接收数据、Tx表示发送数据。</li><li>大型发送分载对应的是前文中提到的TSO模式</li><li>接收方调整和接收方调整队列对应的是RRS模式的启用状态以及RSS队列的个数设置。</li></ul> 
<h4>技术给网络数据包分析带来的影响</h4> 
<p><span style="color:#666666;">目前常用的抓包工具大部分都是从协议栈中（如数据链路层）捕获数据包，而网卡的offload</span>特性会将数据包的分片、重组等工作转移到协议栈以下的硬件层面进行，因此在开启TSO、GRO等机制的情况下，我们使用tcpdump、wireshark等工具抓取到的数据包往往不能真实反应链路上实际的数据帧，给网络流量特征的分析造成不利影响。</p> 
<p><span style="color:#666666;">在某些情况下，例如分片攻击等攻击方式，甚至可能会因为网卡设备的offload</span>机制处理，而规避防火墙、IDS以及人工的检查。针对这些情况，可以选择关闭网卡offload的相关选项，或者在链路的其他节点进行抓包。</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9dd32638c36e1ad633f7dae54815f0ab/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">jsp基础和jsp内置对象</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f5146d0162a49549489f7d9d8aba644e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">tcp整理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>