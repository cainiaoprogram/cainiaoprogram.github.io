<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Rest Docs使用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring Rest Docs使用" />
<meta property="og:description" content="今天给大家分享一个能通过代码自动生成文档技术，Spring Rest Doc过在单元测试中额外添加 API 信息描述，从而自动生成对应的文档片段。 下面通过一个简单的例子演示下如何快速上手的。在Spring Boot项目中添加maven 依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.restdocs&lt;/groupId&gt; &lt;artifactId&gt;spring-restdocs-mockmvc&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 在controller添加接口
@PostMapping(&#34;/show/entity&#34;) public Dog getDog(@RequestBody Dog dog){ return dog; } 编写测试用例，并且输出文档。
import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; import org.junit.jupiter.api.extension.ExtendWith; import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest; import org.springframework.http.MediaType; import org.springframework.restdocs.RestDocumentationContextProvider; import org.springframework.restdocs.RestDocumentationExtension; import org.springframework.restdocs.mockmvc.MockMvcRestDocumentation; import org.springframework.restdocs.mockmvc.RestDocumentationRequestBuilders; import org.springframework.test.context.junit.jupiter.SpringExtension; import org.springframework.test.web.servlet.MockMvc; import org.springframework.test.web.servlet.result.MockMvcResultMatchers; import org.springframework.test.web.servlet.setup.MockMvcBuilders; import org.springframework.web.context.WebApplicationContext; @WebMvcTest @ExtendWith({RestDocumentationExtension.class, SpringExtension.class}) class DogControllerTest { private MockMvc mockMvc; @BeforeEach public void init(WebApplicationContext applicationContext, RestDocumentationContextProvider contextProvider){ mockMvc = MockMvcBuilders." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/af66a52607b712aead083fc9b154bbb8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-10T10:26:31+08:00" />
<meta property="article:modified_time" content="2022-10-10T10:26:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Rest Docs使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>今天给大家分享一个能通过代码自动生成文档技术，Spring Rest Doc过在单元测试中额外添加 API 信息描述，从而自动生成对应的文档片段。 下面通过一个简单的例子演示下如何快速上手的。在Spring Boot项目中添加maven 依赖</p> 
<pre><code>        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;

        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.restdocs&lt;/groupId&gt;
            &lt;artifactId&gt;spring-restdocs-mockmvc&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre> 
<p>在controller添加接口</p> 
<pre><code>    @PostMapping("/show/entity")
    public Dog getDog(@RequestBody Dog dog){
        return dog;
    }
</code></pre> 
<p>编写测试用例，并且输出文档。</p> 
<pre><code>import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.http.MediaType;
import org.springframework.restdocs.RestDocumentationContextProvider;
import org.springframework.restdocs.RestDocumentationExtension;
import org.springframework.restdocs.mockmvc.MockMvcRestDocumentation;
import org.springframework.restdocs.mockmvc.RestDocumentationRequestBuilders;
import org.springframework.test.context.junit.jupiter.SpringExtension;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.result.MockMvcResultMatchers;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;
import org.springframework.web.context.WebApplicationContext;

@WebMvcTest
@ExtendWith({RestDocumentationExtension.class, SpringExtension.class})
class DogControllerTest {

    private MockMvc mockMvc;

    @BeforeEach
    public void init(WebApplicationContext applicationContext, RestDocumentationContextProvider contextProvider){
        mockMvc = MockMvcBuilders.webAppContextSetup(applicationContext)
                .apply(MockMvcRestDocumentation.documentationConfiguration(contextProvider))
                .build();
    }

    @Test
    void getDog() throws Exception {
        String json = "{\"id\": 12,\"name\":\"Miki\"}";
        mockMvc.perform(RestDocumentationRequestBuilders.post("/dog/show/entity")
                        .content(json)
                        .contentType(MediaType.APPLICATION_JSON_VALUE))
                .andExpect(MockMvcResultMatchers.status().isOk()) //成功响应
                .andExpect(MockMvcResultMatchers.jsonPath("name","Miki").exists()) //结果匹配
                .andDo(MockMvcRestDocumentation.document("dog",
                        requestFields(PayloadDocumentation.fieldWithPath("name").description("名字"),
                                PayloadDocumentation.fieldWithPath("id").description("实体id")),
                        PayloadDocumentation.responseFields(
                                PayloadDocumentation.fieldWithPath("name").description("名字"),
                                PayloadDocumentation.fieldWithPath("id").description("实体id")
                        ))); //输出文档
    }
}
</code></pre> 
<p>在target目录可以看到生成文档</p> 
<p><img src="https://images2.imgbox.com/29/64/lUoK4NC6_o.png" alt=""></p> 
<p>在target/generated-snippets/dog目录下会生成文档片段 例如curl-request.adoc 就是curl执行http命令执行参数，直接copy就可以执行了</p> 
<pre><code>$ curl 'http://localhost:8080/dog/show/entity' -i -X POST \
    -H 'Content-Type: application/json' \
    -d '{"id": 12,"name":"Miki"}'
</code></pre> 
<p>要想生成一个完整文档，这些文档全部合并成一个文档，还需要编写一个集合文档。在项目<code>src/main/asciidoc/</code>目录下新增文件<code>index.adoc</code></p> 
<pre><code>= 这是标题一
:toc: left

文章段落

== 这是标题二

.curl-request
include::{snippets}/dog/curl-request.adoc[]

.http-request
include::{snippets}/dog/http-request.adoc[]

.request-fields
include::{snippets}/dog/request-fields.adoc[]

.response-body
include::{snippets}/dog/response-body.adoc[]

.response-fields
include::{snippets}/dog/response-fields.adoc[]
</code></pre> 
<p>使用asciidoctor-maven-plugin 插件生成html文档</p> 
<pre><code>&lt;plugin&gt;
                &lt;groupId&gt;org.asciidoctor&lt;/groupId&gt;
                &lt;artifactId&gt;asciidoctor-maven-plugin&lt;/artifactId&gt;
                &lt;version&gt;1.5.3&lt;/version&gt;
                &lt;executions&gt;
                    &lt;execution&gt;
                        &lt;id&gt;generate-docs&lt;/id&gt;
                        &lt;phase&gt;prepare-package&lt;/phase&gt;
                        &lt;goals&gt;
                            &lt;goal&gt;process-asciidoc&lt;/goal&gt;
                        &lt;/goals&gt;
                        &lt;configuration&gt;
                            &lt;sourceDocumentName&gt;index.adoc&lt;/sourceDocumentName&gt;
                            &lt;backend&gt;html&lt;/backend&gt;
                            &lt;attributes&gt;
                                &lt;snippets&gt;${project.build.directory}/generated-snippets&lt;/snippets&gt;
                            &lt;/attributes&gt;
                        &lt;/configuration&gt;
                    &lt;/execution&gt;
                &lt;/executions&gt;
            &lt;/plugin&gt;
</code></pre> 
<p>运行<code>mvn package</code>命令后可以在target/generated-docs看见index.html,效果如下</p> 
<p><img src="https://images2.imgbox.com/24/53/jSoaPZhf_o.png" alt=""></p> 
<p>Spring Rest Docs只是提供生成文档片而已，要生成一份完整的问题，仍然需要手动去编写<code>index.adoc</code>,引用文档片，通过组合的方式变成一个自己想要的文档。这个跟Swagger完去自动化生成的文档有很多区别的。两者在使用上也有很多不同。</p> 
<h6><a id="_145"></a>生成方式:</h6> 
<ul><li>Swagger: 只有在方法、实体对象添加注解声明即可，简单、方便，对代码有一定侵入性。文档生成依赖项目提供服务，属于在线文档，支持离线导入文档。</li><li>Spring Rest Docs： 手动编写每一个http 方法的测试用例，并且还有标注每一个请求参数的含义，这些都是通过代码来实现的。对开发人员有一定要求，工作量也有不少。必须测试通过了才会生成相应文档，这个保证了文档有效性。</li></ul> 
<h6><a id="_150"></a>使用场景;</h6> 
<ul><li>Swagger： 因为文档提供必须项目提供http服务在一起，对网络环境有一定要求，对接口权限不敏感。比如提供给同一个开发部门的前端开发使用。Swagger更多适合在同一个开发小组内，要求文档提供速度较快，实时性高，基本就是写完一个http接口，就能提供相应的文档。</li><li>Spring Rest Docs：作为一个离线文档，比较适合跨部门或者跨厂商之间文档提供，像这种一般没有本地开发环境，调试不方便，很需要文档提供curl调用样例。接口的变动不会太频繁的，有着完整测试用例覆盖。</li></ul> 
<p>我个人感觉 Spring Rest Docs心中完美的API文档实现，Mock测试通过生成的文档，保证每一个文档都是可用、准确的，减少人为交流。又可以根据自身需求，自由组合文档内容，既有严谨性、又具备一定灵活性，奈何编写一份API文档需要更长工时，在方便、快捷上完全不能与Swagger比较，在日常开发API文档，大多数都是使用Swagger为主，但是如果现在还有团队使用Yapi这类手动编写API文档，我建议使用Spring Rest Docs替代，让API更严谨。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fdd37958e685ddd99cb397847530a6f0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">教务信息管理系统的设计与实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e9e4bad8367a173b96a61d50e1585d34/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小猫爪：S32K3学习笔记09-S32K3之Safety简介</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>