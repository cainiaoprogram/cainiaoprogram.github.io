<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【EFCore学习】EFCore梳理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【EFCore学习】EFCore梳理" />
<meta property="og:description" content="一、CodeFirst模式 微软官网
1、创建一个.NETCore空项目 2、添加相关引用 通过命令进行安装，工具》NuGet包管理》程序包管理控制台
（1）引用 EntityFrameworkCore
Install-Package Microsoft.EntityFrameworkCore （2）引用 EntityFrameworkCore.SqlServer.Tools
Install-Package Microsoft.EntityFrameworkCore.Tools 3、相关配置 （1）配置连接数据库
（2）在Startup.cs中注册服务
其中的BloggingContext就是接下来我们要新建的数据上下文
4、生成数据库 （1）创建实体模型
public class Blog { public int BlogId { get; set; } public string Url { get; set; } public List&lt;Post&gt; Posts { get; } = new List&lt;Post&gt;(); } public class Post { public int PostId { get; set; } public string Title { get; set; } public string Content { get; set; } public int BlogId { get; set; } public Blog Blog { get; set; } } （2）创建上下文" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f3e6ca8945e1fb6fd2b9cbe9258fdbfe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-23T10:34:15+08:00" />
<meta property="article:modified_time" content="2022-09-23T10:34:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【EFCore学习】EFCore梳理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="CodeFirst_2"></a>一、CodeFirst模式</h3> 
<p><a href="https://docs.microsoft.com/zh-cn/ef/core/get-started/overview/first-app?tabs=visual-studio" rel="nofollow">微软官网</a></p> 
<h3><a id="1NETCore_6"></a>1、创建一个.NETCore空项目</h3> 
<p><img src="https://images2.imgbox.com/be/d6/tcJIiJUa_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_10"></a>2、添加相关引用</h3> 
<p>通过命令进行安装，工具》NuGet包管理》程序包管理控制台</p> 
<p><img src="https://images2.imgbox.com/ca/2e/atLVkqyU_o.png" alt="在这里插入图片描述"></p> 
<p>（1）引用 EntityFrameworkCore</p> 
<pre><code class="prism language-sql">Install<span class="token operator">-</span>Package Microsoft<span class="token punctuation">.</span>EntityFrameworkCore
</code></pre> 
<p><img src="https://images2.imgbox.com/5c/72/of68w6s8_o.png" alt="在这里插入图片描述"></p> 
<p>（2）引用 EntityFrameworkCore.SqlServer.Tools</p> 
<pre><code class="prism language-sql">Install<span class="token operator">-</span>Package Microsoft<span class="token punctuation">.</span>EntityFrameworkCore<span class="token punctuation">.</span>Tools
</code></pre> 
<p><img src="https://images2.imgbox.com/f2/26/kb7DlUaR_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3_33"></a>3、相关配置</h3> 
<p>（1）配置连接数据库</p> 
<p><img src="https://images2.imgbox.com/ea/bf/a0xhtauX_o.png" alt="在这里插入图片描述"></p> 
<p>（2）在Startup.cs中注册服务</p> 
<p><img src="https://images2.imgbox.com/22/fd/jLE8CK5n_o.png" alt="在这里插入图片描述"></p> 
<p>其中的BloggingContext就是接下来我们要新建的数据上下文</p> 
<h3><a id="4_49"></a>4、生成数据库</h3> 
<p>（1）创建实体模型</p> 
<pre><code class="prism language-sql"><span class="token keyword">public</span> class Blog
{
    <span class="token keyword">public</span> <span class="token keyword">int</span> BlogId { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token keyword">public</span> string Url { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Post<span class="token operator">&gt;</span> Posts { get<span class="token punctuation">;</span> } <span class="token operator">=</span> new List<span class="token operator">&lt;</span>Post<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
}
<span class="token keyword">public</span> class Post
{
    <span class="token keyword">public</span> <span class="token keyword">int</span> PostId { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token keyword">public</span> string Title { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token keyword">public</span> string Content { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token keyword">public</span> <span class="token keyword">int</span> BlogId { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token keyword">public</span> Blog Blog { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
}
</code></pre> 
<p>（2）创建上下文</p> 
<pre><code class="prism language-sql"><span class="token keyword">public</span> class BloggingContext : DbContext
{
　　<span class="token keyword">public</span> BloggingContext<span class="token punctuation">(</span>DbContextOptions<span class="token operator">&lt;</span>BloggingContext<span class="token operator">&gt;</span> options<span class="token punctuation">)</span> : base<span class="token punctuation">(</span>options<span class="token punctuation">)</span>
　　{

　　}
　　<span class="token keyword">public</span> DbSet<span class="token operator">&lt;</span>Blog<span class="token operator">&gt;</span> Blogs { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
　　<span class="token keyword">public</span> DbSet<span class="token operator">&lt;</span>Post<span class="token operator">&gt;</span> Posts { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
}
</code></pre> 
<p>（3）迁移搭建基架</p> 
<p><strong>Add-Migration</strong> 命令为迁移搭建基架，以便为模型创建一组初始表。</p> 
<pre><code class="prism language-sql"><span class="token keyword">Add</span><span class="token operator">-</span>Migration InitialCreate
</code></pre> 
<p><img src="https://images2.imgbox.com/88/22/dCYHxkfG_o.png" alt="在这里插入图片描述"></p> 
<p>执行成功后，项目下会生成一个Migrations的文件夹并包含一些初始化生成数据库需要用的文件</p> 
<p>（4）执行 <strong>update-database</strong> 命令生成数据库</p> 
<pre><code class="prism language-sql"><span class="token keyword">Update</span><span class="token operator">-</span><span class="token keyword">Database</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/f1/95/15Adpd4O_o.png" alt="在这里插入图片描述"></p> 
<p>Update-Database命令创建数据库并向其应用新的迁移。</p> 
<p><img src="https://images2.imgbox.com/7c/70/8kaekXbx_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="5model_107"></a>5、添加model模型，迁移数据库</h3> 
<p>（1）新增一个UserInfo模型，并加入数据上下文中</p> 
<p><img src="https://images2.imgbox.com/b1/23/Ukr88JOV_o.png" alt="在这里插入图片描述"></p> 
<p>（2）迁移数据库</p> 
<pre><code class="prism language-sql"><span class="token keyword">Add</span><span class="token operator">-</span>Migration AddUserInfoClass <span class="token comment">//参考迁移，后边也会梳理https://docs.microsoft.com/zh-cn/ef/core/managing-schemas/migrations/?tabs=dotnet-core-cli</span>
<span class="token keyword">Update</span><span class="token operator">-</span><span class="token keyword">Database</span>
</code></pre> 
<h3><a id="6_122"></a>6、创建、读取、更新和删除</h3> 
<p>（1）新建一个API</p> 
<pre><code class="prism language-sql"><span class="token keyword">using</span> Microsoft<span class="token punctuation">.</span>AspNetCore<span class="token punctuation">.</span>Mvc<span class="token punctuation">;</span>
<span class="token keyword">using</span> System<span class="token punctuation">.</span>Linq<span class="token punctuation">;</span>

namespace EFCoreSummary<span class="token punctuation">.</span>Controller
{
    <span class="token punctuation">[</span>Route<span class="token punctuation">(</span><span class="token string">"api/[controller]"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token punctuation">[</span>ApiController<span class="token punctuation">]</span>
    <span class="token keyword">public</span> class ValuesController : ControllerBase
    {
        private readonly BloggingContext _dbContext<span class="token punctuation">;</span>
        <span class="token keyword">public</span> ValuesController<span class="token punctuation">(</span>BloggingContext bloggingContext<span class="token punctuation">)</span>
        {
            _dbContext <span class="token operator">=</span> bloggingContext<span class="token punctuation">;</span>
        }
        <span class="token keyword">public</span> void Init<span class="token punctuation">(</span><span class="token punctuation">)</span>
        {
            <span class="token comment">//insert</span>
            _dbContext<span class="token punctuation">.</span><span class="token keyword">Add</span><span class="token punctuation">(</span>new Blog { Url <span class="token operator">=</span> <span class="token string">"http://blogs.msdn.com/adonet"</span> }<span class="token punctuation">)</span><span class="token punctuation">;</span>
            _dbContext<span class="token punctuation">.</span>SaveChanges<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// Read</span>
            var blog <span class="token operator">=</span> _dbContext<span class="token punctuation">.</span>Blogs
                <span class="token punctuation">.</span>OrderBy<span class="token punctuation">(</span>b <span class="token operator">=</span><span class="token operator">&gt;</span> b<span class="token punctuation">.</span>BlogId<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">First</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// Update</span>
            blog<span class="token punctuation">.</span>Url <span class="token operator">=</span> <span class="token string">"https://devblogs.microsoft.com/dotnet"</span><span class="token punctuation">;</span>
            blog<span class="token punctuation">.</span>Posts<span class="token punctuation">.</span><span class="token keyword">Add</span><span class="token punctuation">(</span>
                new Post { Title <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">,</span> Content <span class="token operator">=</span> <span class="token string">"I wrote an app using EF Core!"</span> }<span class="token punctuation">)</span><span class="token punctuation">;</span>
            _dbContext<span class="token punctuation">.</span>SaveChanges<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// Delete</span>
            _dbContext<span class="token punctuation">.</span>Remove<span class="token punctuation">(</span>blog<span class="token punctuation">)</span><span class="token punctuation">;</span>
            _dbContext<span class="token punctuation">.</span>SaveChanges<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        }
    }
}
</code></pre> 
<p>（2）看下数据表数据<br> <img src="https://images2.imgbox.com/70/82/PqtEcwvs_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="EFCore_169"></a>二、EFCore的概要</h3> 
<p>上边做了一个简单的EFCore的示例，这里根据官网进行下整体梳理，主要是做一下实用的概括。在上边的demo中涉及到DbContext、模型、增删改查等概念，下面先对这些进行个概要。</p> 
<h3><a id="1DbContext_172"></a>1、DbContext</h3> 
<p>DbContext是EFCore的核心，当我们使用EFCore持久化时，在一个工作单元（可以理解为一次http请求）中通常会做以下工作：</p> 
<ul><li>创建 DbContext 实例</li><li>根据上下文跟踪实体实例。 实体将在以下情况下被跟踪，跟踪和非跟踪会在下边的查询中介绍，这里只要知道一个工作单元中DbContext做了什么即可。<br> 正在从查询返回<br> 正在添加或附加到上下文</li><li>根据需要对所跟踪的实体进行更改以实现业务规则调用 SaveChanges 或 SaveChangesAsync。</li><li>EF Core 检测所做的更改，并将这些更改写入数据库。</li><li>释放 DbContext 实例</li></ul> 
<h3><a id="1DbContext__184"></a>（1）DbContext 生存期</h3> 
<p>从上边DbContext的工作流程可以看出，DbContext 的生存期从创建实例时开始，并在释放实例时结束。具体点说，就是从一个请求开始到请求结束， DbContext 也会相应的创建和释放。</p> 
<p>这里需要注意一点：DbContext 不是线程安全的。 不是线程安全怎么理解呢？</p> 
<p>简单来说就是不支持在同一 DbContext 实例上运行多个并行操作。 这包括异步查询的并行执行以及从多个线程进行的任何显式并发使用。所以在异步调用中，await显得尤为重要。举个例子，我们有个登录操作，查询数据库采用的是EFCore，同时有两个用户发出登录请求，那么对于EFCore就是两个工作单元，每一个请求都有自己的DbContext上下文，互不干扰。不要在线程之间共享上下文。 请确保在继续使用上下文实例之前，等待所有异步调用。</p> 
<h3><a id="2DbContext_192"></a>（2）DbContext的配置和初始化</h3> 
<p>DbContext既然这么重要，我们怎么使用到项目中呢？</p> 
<p><strong>通过依赖注入的方式</strong><br> （1）配置上下文：ASP.NET Core 应用程序， 可以使用 Startup.cs 的 ConfigureServices 方法中的 AddDbContext 将 EF Core 添加到此配置。 例如：<br> public void ConfigureServices(IServiceCollection services)</p> 
<pre><code class="prism language-sql">{
    services<span class="token punctuation">.</span>AddControllers<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    services<span class="token punctuation">.</span>AddDbContext<span class="token operator">&lt;</span>ApplicationDbContext<span class="token operator">&gt;</span><span class="token punctuation">(</span>
        options <span class="token operator">=</span><span class="token operator">&gt;</span> options<span class="token punctuation">.</span>UseSqlServer<span class="token punctuation">(</span><span class="token string">"name=ConnectionStrings:DefaultConnection"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
} 
</code></pre> 
<p>（2）使用上边配置的上下文：其中ApplicationDbContext 是DbContext 的子类，ApplicationDbContext 类必须公开具有 DbContextOptions 参数的公共构造函数。 这是将 AddDbContext 的上下文配置传递到 DbContext 的方式。 例如：</p> 
<pre><code class="prism language-sql"><span class="token keyword">public</span> class ApplicationDbContext : DbContext
{
    <span class="token keyword">public</span> ApplicationDbContext<span class="token punctuation">(</span>DbContextOptions<span class="token operator">&lt;</span>ApplicationDbContext<span class="token operator">&gt;</span> options<span class="token punctuation">)</span>
        : base<span class="token punctuation">(</span>options<span class="token punctuation">)</span>
    {
    }
}
</code></pre> 
<p>（3）然后我们就可以把ApplicationDbContext 通过构造函数注入在 ASP.NET Core 控制器或其他服务中使用。 例如：</p> 
<pre><code class="prism language-sql"><span class="token keyword">public</span> class MyController
{
    private readonly ApplicationDbContext _context<span class="token punctuation">;</span>

    <span class="token keyword">public</span> MyController<span class="token punctuation">(</span>ApplicationDbContext context<span class="token punctuation">)</span>
    {
        _context <span class="token operator">=</span> context<span class="token punctuation">;</span>
    }
}
</code></pre> 
<p>上边的三个流程和我们上边demo中的使用方式是一样的，可以参考下上面的demo。</p> 
<p><strong>使用“new”的简单的 DbContext 初始化</strong><br> （1）配置上下文：新建一个DbContext子类ApplicationDbContext，在子类中配置上下文</p> 
<pre><code class="prism language-sql"><span class="token keyword">public</span> class ApplicationDbContext : DbContext
{
    protected override void OnConfiguring<span class="token punctuation">(</span>DbContextOptionsBuilder optionsBuilder<span class="token punctuation">)</span>
    {
        optionsBuilder<span class="token punctuation">.</span>UseSqlServer<span class="token punctuation">(</span><span class="token variable">@"Server=(localdb)\mssqllocaldb;Database=Test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    }
}
</code></pre> 
<p>（2）使用</p> 
<pre><code class="prism language-sql"><span class="token keyword">using</span> System<span class="token punctuation">;</span>
<span class="token keyword">using</span> System<span class="token punctuation">.</span>Linq<span class="token punctuation">;</span>

namespace EFGetStarted
{
    internal class Program
    {
        private static void Main<span class="token punctuation">(</span><span class="token punctuation">)</span>
        {
            <span class="token keyword">using</span> <span class="token punctuation">(</span>var db <span class="token operator">=</span> new BloggingContext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            {                
                db<span class="token punctuation">.</span><span class="token keyword">Add</span><span class="token punctuation">(</span>new Blog { Url <span class="token operator">=</span> <span class="token string">"http://blogs.msdn.com/adonet"</span> }<span class="token punctuation">)</span><span class="token punctuation">;</span>
                db<span class="token punctuation">.</span>SaveChanges<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                
            }
        }
    }
}
</code></pre> 
<p>这种方式和微软官网上提供的demo一样，可以参考下：<a href="https://docs.microsoft.com/zh-cn/ef/core/get-started/overview/first-app?tabs=netcore-cli" rel="nofollow">微软文档</a></p> 
<p><strong>使用 DbContext 工厂</strong><br> 　　应用程序可能需要在一个作用域内执行多个工作单元。 例如，单个 HTTP 请求中的多个工作单元。在这些情况下，可以使用 AddDbContextFactory 来注册工厂以创建 DbContext 实例。 前三个步骤和依赖注入一样。</p> 
<p>（1）配置上下文：</p> 
<pre><code class="prism language-sql"><span class="token keyword">public</span> void ConfigureServices<span class="token punctuation">(</span>IServiceCollection services<span class="token punctuation">)</span>
{
    services<span class="token punctuation">.</span>AddDbContextFactory<span class="token operator">&lt;</span>ApplicationDbContext<span class="token operator">&gt;</span><span class="token punctuation">(</span>
        options <span class="token operator">=</span><span class="token operator">&gt;</span>
            options<span class="token punctuation">.</span>UseSqlServer<span class="token punctuation">(</span><span class="token variable">@"Server=(localdb)\mssqllocaldb;Database=Test"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
}
</code></pre> 
<p>（2）定义DbContext 的子类ApplicationDbContext，同上ApplicationDbContext类必须公开具有 DbContextOptions 参数的公共构造函数。例如：</p> 
<pre><code class="prism language-sql"><span class="token keyword">public</span> class ApplicationDbContext : DbContext
{
    <span class="token keyword">public</span> ApplicationDbContext<span class="token punctuation">(</span>DbContextOptions<span class="token operator">&lt;</span>ApplicationDbContext<span class="token operator">&gt;</span> options<span class="token punctuation">)</span>
        : base<span class="token punctuation">(</span>options<span class="token punctuation">)</span>
    {
    }
}
</code></pre> 
<p>（3）定义一个工厂，在工厂类中注入上下文</p> 
<pre><code class="prism language-sql">private readonly IDbContextFactory<span class="token operator">&lt;</span>ApplicationDbContext<span class="token operator">&gt;</span> _contextFactory<span class="token punctuation">;</span>

<span class="token keyword">public</span> MyController<span class="token punctuation">(</span>IDbContextFactory<span class="token operator">&lt;</span>ApplicationDbContext<span class="token operator">&gt;</span> contextFactory<span class="token punctuation">)</span>
{
    _contextFactory <span class="token operator">=</span> contextFactory<span class="token punctuation">;</span>
}
</code></pre> 
<p>（4）在实现工厂的具体服务中，可以使用在工厂中构造 DbContext 实例。 例如：</p> 
<pre><code class="prism language-sql"><span class="token keyword">public</span> void DoSomething<span class="token punctuation">(</span><span class="token punctuation">)</span>
{
    <span class="token keyword">using</span> <span class="token punctuation">(</span>var context <span class="token operator">=</span> _contextFactory<span class="token punctuation">.</span>CreateDbContext<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    {
        <span class="token comment">// ...</span>
    }
}
</code></pre> 
<h3><a id="2_319"></a>2、模型</h3> 
<p>模型还是非常重要的，看下官网上的这句话：Entity Framework Core 使用一组约定来根据实体类的形状生成模型。 可指定其他配置以补充和/或替代约定的内容。什么意思呢？</p> 
<p>为了便于理解，我们可以直接将实体认为是EFCore中的模型。我们在程序中定义一个实体，其实就是定义了一个模型，然后通过迁移生成数据库中的一个数据表。这里就会有一个问题，数据表会涉及到很多属性，比如索引、主键等，那么模型应该怎么设计才能迁移成我们想看到的数据表呢？</p> 
<p>I、DbSet<br> 在上下文中包含一种类型的 DbSet，其实就是个集合，该集合可以包含不同的实体，我们可以将DbSet作为EFCore中存放实体的集合。</p> 
<p>2、实体属性<br> （1）包含属性（列）<br> 　　按照约定，具有 getter 和 setter 的所有公共属性都将包括在模型中。就是说包含getter和setter的公共属性都会被迁移为数据表的列。</p> 
<p>（2）排除属性（列）<br> 　　性上添加[NotMapped]特性，在迁移时就不会生成表列。例如：</p> 
<pre><code class="prism language-sql"><span class="token keyword">public</span> class Blog
{
    <span class="token punctuation">[</span>NotMapped<span class="token punctuation">]</span>
    <span class="token keyword">public</span> <span class="token keyword">DateTime</span> LoadedFromDatabase { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
}
</code></pre> 
<p>（3）控制列名<br> 　　默认情况下，实体在迁移后生成的表列名就是属性名，但是我们也可以控制实体中某个属性迁移后的列名。例如：</p> 
<pre><code class="prism language-sql"><span class="token keyword">public</span> class Blog
{
    <span class="token punctuation">[</span><span class="token keyword">Column</span><span class="token punctuation">(</span><span class="token string">"blog_id"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">public</span> <span class="token keyword">int</span> BlogId { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
}
</code></pre> 
<p>（4）列数据类型<br> 　　直接看例子，相信都能看得懂：</p> 
<pre><code class="prism language-sql"><span class="token keyword">public</span> class Blog
{
    <span class="token keyword">public</span> <span class="token keyword">int</span> BlogId { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token punctuation">[</span><span class="token keyword">Column</span><span class="token punctuation">(</span>TypeName <span class="token operator">=</span> <span class="token string">"varchar(200)"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">public</span> string Url { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }

    <span class="token punctuation">[</span><span class="token keyword">Column</span><span class="token punctuation">(</span>TypeName <span class="token operator">=</span> <span class="token string">"decimal(5, 2)"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">public</span> <span class="token keyword">decimal</span> Rating { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
}
</code></pre> 
<p>（5）列最大长度</p> 
<pre><code class="prism language-sql"><span class="token keyword">public</span> class Blog
{
    <span class="token keyword">public</span> <span class="token keyword">int</span> BlogId { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token punctuation">[</span>MaxLength<span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token keyword">public</span> string Url { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
}
</code></pre> 
<p>（6）必需属性和可选属性<br> 　　按照约定，.NET 类型可以包含 null 的属性将配置为可选，而 .NET 类型不能包含 null 的属性将根据需要进行配置。 例如，所有具有 .net 值类型的属性 (int 、 decimal ) 、等 bool 都是必需的，并且具有可为 null 的 .net 值类型 (、) 、等）的所有属性 int? decimal? bool? 都配置为可选。<br> public class CustomerWithoutNullableReferenceTypes</p> 
<pre><code class="prism language-sql">{
    <span class="token keyword">public</span> <span class="token keyword">int</span> Id { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token punctuation">[</span>Required<span class="token punctuation">]</span> <span class="token comment">// Data annotations needed to configure as required</span>
    <span class="token keyword">public</span> string FirstName { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token punctuation">[</span>Required<span class="token punctuation">]</span>
    <span class="token keyword">public</span> string LastName { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> } <span class="token comment">// Data annotations needed to configure as required</span>
    <span class="token keyword">public</span> string MiddleName { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> } <span class="token comment">// Optional by convention</span>
}
</code></pre> 
<p>（7）配置主键<br> 　　键充当每个实体实例的唯一标识符。 EF 中的大多数实体都有一个键，此键映射到关系数据库中 主键 的概念 。按照约定，将名为 Id 或的属性 Id 配置为实体的主键。例如：</p> 
<pre><code class="prism language-sql">internal class Car
{
    <span class="token keyword">public</span> string Id { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token keyword">public</span> string Make { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
}
</code></pre> 
<p>可以将单个属性配置为实体的主键，例如：</p> 
<pre><code class="prism language-sql">internal class Car
{
    <span class="token punctuation">[</span><span class="token keyword">Key</span><span class="token punctuation">]</span>
    <span class="token keyword">public</span> string LicensePlate { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token keyword">public</span> string Model { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
}
</code></pre> 
<p>可以将多个属性配置为实体的键，这称为组合键</p> 
<pre><code class="prism language-sql">protected override void OnModelCreating<span class="token punctuation">(</span>ModelBuilder modelBuilder<span class="token punctuation">)</span>
{
    modelBuilder<span class="token punctuation">.</span>Entity<span class="token operator">&lt;</span>Car<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>HasKey<span class="token punctuation">(</span>c <span class="token operator">=</span><span class="token operator">&gt;</span> new { c<span class="token punctuation">.</span>State<span class="token punctuation">,</span> c<span class="token punctuation">.</span>LicensePlate }<span class="token punctuation">)</span><span class="token punctuation">;</span>
}
</code></pre> 
<p>设置主键名称：</p> 
<pre><code class="prism language-sql">protected override void OnModelCreating<span class="token punctuation">(</span>ModelBuilder modelBuilder<span class="token punctuation">)</span>
{
    modelBuilder<span class="token punctuation">.</span>Entity<span class="token operator">&lt;</span>Blog<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>HasKey<span class="token punctuation">(</span>b <span class="token operator">=</span><span class="token operator">&gt;</span> b<span class="token punctuation">.</span>BlogId<span class="token punctuation">)</span>
        <span class="token punctuation">.</span>HasName<span class="token punctuation">(</span><span class="token string">"PrimaryKey_BlogId"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
}
</code></pre> 
<p>（8）设置列默认值</p> 
<pre><code class="prism language-sql">protected override void OnModelCreating<span class="token punctuation">(</span>ModelBuilder modelBuilder<span class="token punctuation">)</span>
{
    modelBuilder<span class="token punctuation">.</span>Entity<span class="token operator">&lt;</span>Blog<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span>Property<span class="token punctuation">(</span>b <span class="token operator">=</span><span class="token operator">&gt;</span> b<span class="token punctuation">.</span>Rating<span class="token punctuation">)</span>
        <span class="token punctuation">.</span>HasDefaultValue<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
}
</code></pre> 
<p>（9）并发标记<br> 　　配置为并发标记的属性用于实现乐观并发控制</p> 
<pre><code class="prism language-sql"><span class="token keyword">public</span> class Person
{
    <span class="token keyword">public</span> <span class="token keyword">int</span> PersonId { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token punctuation">[</span>ConcurrencyCheck<span class="token punctuation">]</span>
    <span class="token keyword">public</span> string LastName { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token keyword">public</span> string FirstName { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
}
</code></pre> 
<p>（10）索引<br> 　　索引是跨多个数据存储区的常见概念。 尽管它们在数据存储中的实现可能会有所不同，但也可用于基于列 (或一组列来进行查找，) 效率更高。<br> [Index(nameof(Url))]</p> 
<pre><code class="prism language-sql"><span class="token keyword">public</span> class Blog
{
    <span class="token keyword">public</span> <span class="token keyword">int</span> BlogId { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token keyword">public</span> string Url { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
}
</code></pre> 
<p>复合索引：</p> 
<pre><code class="prism language-sql"><span class="token punctuation">[</span><span class="token keyword">Index</span><span class="token punctuation">(</span>nameof<span class="token punctuation">(</span>FirstName<span class="token punctuation">)</span><span class="token punctuation">,</span> nameof<span class="token punctuation">(</span>LastName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">public</span> class Person
{
    <span class="token keyword">public</span> <span class="token keyword">int</span> PersonId { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token keyword">public</span> string FirstName { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token keyword">public</span> string LastName { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
}
</code></pre> 
<p>唯一索引：</p> 
<pre><code class="prism language-sql"><span class="token punctuation">[</span><span class="token keyword">Index</span><span class="token punctuation">(</span>nameof<span class="token punctuation">(</span>Url<span class="token punctuation">)</span><span class="token punctuation">,</span> IsUnique <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token keyword">public</span> class Blog
{
    <span class="token keyword">public</span> <span class="token keyword">int</span> BlogId { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token keyword">public</span> string Url { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
}
</code></pre> 
<p>索引名称：<br> [Index(nameof(Url), Name = “Index_Url”)]</p> 
<pre><code class="prism language-sql"><span class="token keyword">public</span> class Blog
{
    <span class="token keyword">public</span> <span class="token keyword">int</span> BlogId { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token keyword">public</span> string Url { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
}
</code></pre> 
<p>以上是常用的配置，当然还有很多高级的用法，可以看下官网：https://docs.microsoft.com/zh-cn/ef/core/managing-schemas/</p> 
<h3><a id="3_506"></a>3、管理数据库架构</h3> 
<p>EF Core 提供两种主要方法来保持 EF Core 模型和数据库架构同步。即codefirst或者dbfirst，codefirst对应迁移，dbfirst对应反向工程。接下来介绍下迁移</p> 
<h3><a id="_509"></a>三、迁移</h3> 
<p>在实际项目中，数据模型随着功能的实现而变化：添加和删除新的实体或属性，并且需要相应地更改数据库架构，使其与应用程序保持同步。 EF Core 中的迁移功能能够以递增方式更新数据库架构，使其与应用程序的数据模型保持同步，同时保留数据库中的现有数据。</p> 
<p>简要地说，迁移的方式如下：</p> 
<p>当引入数据模型更改时，开发人员使用 EF Core 工具添加相应的迁移，以描述使数据库架构保持同步所需的更新。EF Core 将当前模型与旧模型的快照进行比较，以确定差异，并生成迁移源文件；文件可在项目的源代码管理中进行跟踪，如任何其他源文件。<br> 生成新的迁移后，可通过多种方式将其应用于数据库。 EF Core 在一个特殊的历史记录表中记录所有应用的迁移，使其知道哪些迁移已应用，哪些迁移尚未应用。</p> 
<h3><a id="1_517"></a>1、迁移简单示例</h3> 
<p>假设你刚刚完成了第一个 EF Core 应用程序，其中包含以下简单模型：</p> 
<pre><code class="prism language-sql"><span class="token keyword">public</span> class Blog
{
    <span class="token keyword">public</span> <span class="token keyword">int</span> Id { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token keyword">public</span> string Name { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
}
</code></pre> 
<p>在开发过程中，你可能已使用创建和删除 API 以快速迭代，并根据需要更改模型；但现在，你的应用程序将进入生产环境，你需要一种方法来安全地演化架构，而无需删除整个数据库。</p> 
<p>（1）创建第一个迁移<br> 指示 EF Core 创建名为 InitialCreate （名字可自定义）的迁移：</p> 
<pre><code class="prism language-sql"><span class="token keyword">Add</span><span class="token operator">-</span>Migration InitialCreate
</code></pre> 
<p>EF Core 将在项目中创建一个名为“Migrations”的目录，并生成一些文件。</p> 
<p>（2）创建数据库和架构<br> EF 创建数据库并从迁移中创建架构：</p> 
<pre><code class="prism language-sql"><span class="token keyword">Update</span><span class="token operator">-</span><span class="token keyword">Database</span>
</code></pre> 
<p>请注意，这种应用迁移的方法非常适合本地开发，但不太适用于生产环境 - 有关详细信息，请参阅应用迁移页面。</p> 
<p>（3）更新模型<br> 模型更新后如下：</p> 
<pre><code class="prism language-sql"><span class="token keyword">public</span> class Blog
{
    <span class="token keyword">public</span> <span class="token keyword">int</span> Id { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token keyword">public</span> string Name { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
    <span class="token keyword">public</span> <span class="token keyword">DateTime</span> CreatedTimestamp { get<span class="token punctuation">;</span> <span class="token keyword">set</span><span class="token punctuation">;</span> }
}
</code></pre> 
<p>模型和生产数据库现在不同步，我们必须向数据库架构中添加一个新列。创建新迁移：</p> 
<pre><code class="prism language-sql"><span class="token keyword">Add</span><span class="token operator">-</span>Migration AddBlogCreatedTimestamp
</code></pre> 
<p>请注意，我们为迁移提供了一个描述性名称（名称可自定义，不可重复），以便以后更容易了解项目历史记录。由于这不是项目的第一次迁移，EF Core 现在会在添加列之前将更新的模型与旧模型的快照进行比较；模型快照是 EF Core 在你添加迁移时生成的文件之一，并签入到源代码管理中。 基于该比较，EF Core 检测到已添加一列，并添加适当的迁移。然后进行同步：</p> 
<pre><code class="prism language-sql"><span class="token keyword">Update</span><span class="token operator">-</span><span class="token keyword">Database</span>
</code></pre> 
<p>请注意，这次 EF 检测到数据库已存在。 此外，在之前第一次应用迁移时，此事实记录在数据库中的特殊迁移历史记录表中；这允许 EF 自动仅应用新的迁移。</p> 
<h3><a id="2_577"></a>2、管理迁移</h3> 
<p>（1）添加迁移<br> 先来看下迁移的命令：</p> 
<pre><code class="prism language-sql"><span class="token keyword">Add</span><span class="token operator">-</span>Migration AddBlogCreatedTimestamp
</code></pre> 
<p>迁移名称可自定义，最好符合一种规范，常用时间戳的方式，便于管理。迁移后，会向 Migrations 目录下的项目添加以下三个文件：</p> 
<p>XXXXXXXXXXXXXX_AddCreatedTimestamp：主迁移文件。 包含应用迁移所需的操作（在 Up 中）和还原迁移所需的操作（在 Down 中）。<br> XXXXXXXXXXXXXX_AddCreatedTimestamp：迁移元数据文件。 包含 EF 所用的信息。<br> MyContextModelSnapshot.cs：当前模型的快照。 用于确定添加下一迁移时的更改内容。<br> （2）指定迁移文件的路径</p> 
<pre><code class="prism language-sql"><span class="token keyword">Add</span><span class="token operator">-</span>Migration InitialCreate <span class="token operator">-</span>OutputDir Your\Directory
</code></pre> 
<p>（3）删除迁移</p> 
<pre><code class="prism language-sql">Remove<span class="token operator">-</span>Migration
</code></pre> 
<p>（4）列出所有迁移</p> 
<pre><code class="prism language-sql">Get<span class="token operator">-</span>Migration
</code></pre> 
<p>上边列出了简单的使用迁移的只是，当然还有很多关于迁移的高级用法，查看官网：https://docs.microsoft.com/zh-cn/ef/core/managing-schemas/scaffolding?tabs=dotnet-core-cli</p> 
<h3><a id="DbFirst_610"></a>四、反向工程（DbFirst）</h3> 
<p><a href="https://blog.csdn.net/qq_43527485/article/details/126993318?spm=1001.2014.3001.5501">简单记录</a></p> 
<h3><a id="_612"></a>五、查询数据</h3> 
<p>Entity Framework Core 使用语言集成查询 (LINQ) 来查询数据库中的数据。 通过 LINQ 可使用 C#编写强类型查询。 EF Core 将 LINQ 查询的表示形式传递给数据库提供程序。 数据库提供程序将其转换为数据库特定的查询语言（例如，用于关系数据库的 SQL）。 即使结果中返回的实体已存在于上下文中，也始终对数据库执行查询。</p> 
<h3><a id="1_615"></a>1、客户端与服务器评估</h3> 
<p>这块非常重要，我们知道EFCore使用LINQ来查询数据库数据，那么一个条件查询，是在服务端完成后返回需要的数据到客户端，还是将数据全部返回，存在客户端内存，在进行条件筛选呢？作为一般规则，Entity Framework Core 会尝试尽可能全面地评估服务器上的查询。 EF Core 将查询的一部分转换为可在客户端评估的参数。 系统将查询的其余部分（及生成的参数）提供给数据库提供程序，以确定要在服务器上评估的等效数据库查询。 EF Core 支持在顶级投影中进行部分客户端评估。 如果查询中的顶级投影无法转换为服务器，EF Core 将从服务器中提取任何所需的数据，并在客户端上评估查询的其余部分。 如果 EF Core 在顶级投影之外的任何位置检测到不能转换为服务器的表达式，则会引发运行时异常。</p> 
<p>（1）顶级投影中的客户端评估<br> 在下面的示例中，一个辅助方法用于标准化从 SQL Server 数据库中返回的博客的 URL。 由于 SQL Server 提供程序不了解此方法的实现方式，因此无法将其转换为 SQL。 查询的所有其余部分是在数据库中评估的，但通过此方法传递返回的 URL 却是在客户端上完成。</p> 
<pre><code class="prism language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> blogs <span class="token operator">=</span> context<span class="token punctuation">.</span>Blogs
    <span class="token punctuation">.</span><span class="token function">OrderByDescending</span><span class="token punctuation">(</span>blog <span class="token operator">=&gt;</span> blog<span class="token punctuation">.</span>Rating<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">Select</span><span class="token punctuation">(</span>
        blog <span class="token operator">=&gt;</span> <span class="token keyword">new</span> <span class="token punctuation">{<!-- --></span> Id <span class="token operator">=</span> blog<span class="token punctuation">.</span>BlogId<span class="token punctuation">,</span> Url <span class="token operator">=</span> <span class="token function">StandardizeUrl</span><span class="token punctuation">(</span>blog<span class="token punctuation">.</span>Url<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">ToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token return-type class-name"><span class="token keyword">string</span></span> <span class="token function">StandardizeUrl</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> url<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    url <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">ToLower</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>url<span class="token punctuation">.</span><span class="token function">StartsWith</span><span class="token punctuation">(</span><span class="token string">"http://"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        url <span class="token operator">=</span> <span class="token keyword">string</span><span class="token punctuation">.</span><span class="token function">Concat</span><span class="token punctuation">(</span><span class="token string">"http://"</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> url<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>（2）不支持的客户端评估<br> 尽管客户端评估非常有用，但有时会减弱性能。 请看以下查询，其中的 where 筛选器现已使用辅助方法。 由于数据库中不能应用筛选器，因此需要将所有数据提取到内存中，以便在客户端上应用筛选器。 根据服务器上的筛选器和数据量，客户端评估可能会减弱性能。 因此 Entity Framework Core 会阻止此类客户端评估，并引发运行时异常。</p> 
<pre><code class="prism language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> blogs <span class="token operator">=</span> context<span class="token punctuation">.</span>Blogs
    <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>blog <span class="token operator">=&gt;</span> <span class="token function">StandardizeUrl</span><span class="token punctuation">(</span>blog<span class="token punctuation">.</span>Url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span><span class="token string">"dotnet"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">ToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>（3）显式客户端评估<br> 在某些情况下，可能需要以显式方式强制进行客户端评估，如下所示</p> 
<p>由于数据量小，因此在进行客户端评估时才不会大幅减弱性能。<br> 所用的 LINQ 运算符不会进行任何服务器端转换。<br> 在这种情况下，通过调用 AsEnumerable 或 ToList 等方法（若为异步，则调用 AsAsyncEnumerable 或 ToListAsync），以显式方式选择进行客户端评估。 使用 AsEnumerable 将对结果进行流式传输，但使用 ToList 将通过创建列表来进行缓冲，因此也会占用额外的内存。</p> 
<pre><code class="prism language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> blogs <span class="token operator">=</span> context<span class="token punctuation">.</span>Blogs
    <span class="token punctuation">.</span><span class="token function">AsEnumerable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>blog <span class="token operator">=&gt;</span> <span class="token function">StandardizeUrl</span><span class="token punctuation">(</span>blog<span class="token punctuation">.</span>Url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span><span class="token string">"dotnet"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">ToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="2_662"></a>2、客户端评估中潜在的内存泄漏</h3> 
<p>由于查询转换和编译的开销高昂，因此 EF Core 会缓存已编译的查询计划。 缓存的委托在对顶级投影进行客户端评估时可能会使用客户端代码。 EF Core 为树型结构中客户端评估的部分生成参数，并通过替换参数值重用查询计划。 但表达式树中的某些常数无法转换为参数。 如果缓存的委托包含此类常数，则无法将这些对象垃圾回收，因为它们仍被引用。 如果此类对象包含 DbContext 或其中的其他服务，则会导致应用的内存使用量逐渐增多。 此行为通常是内存泄漏的标志。 只要遇到的常数为不能使用当前数据库提供程序映射的类型，EF Core 就会引发异常。 常见原因及其解决方案如下所示：</p> 
<p>使用实例方法：在客户端投影中使用实例方法时，表达式树包含实例的常数。 如果你的方法不使用该实例中的任何数据，请考虑将该方法设为静态方法。 如果需要方法主体中的实例数据，则将特定数据作为实参传递给方法。<br> 将常数实参传递给方法：这种情况通常是由于在客户端方法的实参中使用 this 引起的。 请考虑将实参拆分为多个标量实参，可由数据库提供程序进行映射。<br> 其他常数：如果在任何其他情况下都出现常数，则可以评估在处理过程中是否需要该常数。 如果必须具有常数，或者如果无法使用上述情况中的解决方案，则创建本地变量来存储值，并在查询中使用局部变量。 EF Core 会将局部变量转换为形参</p> 
<h3><a id="3_670"></a>3、跟踪与非跟踪查询</h3> 
<p><a href="https://blog.csdn.net/qq_43527485/article/details/126885755?spm=1001.2014.3001.5501">笔记</a><br> 跟踪行为决定了 Entity Framework Core 是否将有关实体实例的信息保留在其更改跟踪器中。 如果已跟踪某个实体，则该实体中检测到的任何更改都会在 SaveChanges() 期间永久保存到数据库。 EF Core 还将修复跟踪查询结果中的实体与更改跟踪器中的实体之间的导航属性。</p> 
<p>（1）跟踪查询<br> 默认情况下，跟踪返回实体类型的查询。 这表示可以更改这些实体实例，然后通过 SaveChanges() 持久化这些更改。 在以下示例中，将检测到对博客分级所做的更改，并在 SaveChanges() 期间将这些更改永久保存到数据库中。</p> 
<pre><code class="prism language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> blog <span class="token operator">=</span> context<span class="token punctuation">.</span>Blogs<span class="token punctuation">.</span><span class="token function">SingleOrDefault</span><span class="token punctuation">(</span>b <span class="token operator">=&gt;</span> b<span class="token punctuation">.</span>BlogId <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
blog<span class="token punctuation">.</span>Rating <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
context<span class="token punctuation">.</span><span class="token function">SaveChanges</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在跟踪查询中返回结果时，EF Core 将检查上下文中是否已存在实体。 如果 EF Core 找到现有的实体，则返回同样的实例。 EF Core 不会用数据库值覆盖该实体中实体属性的当前值和原始值。 如果未在上下文中找到该实体，EF Core 将创建新的实体实例，并将其附加到上下文。 查询结果不会包含任何已添加到上下文但尚未保存到数据库中的实体。</p> 
<p>（2）非跟踪查询<br> 在只读方案中使用结果时，非跟踪查询十分有用。 可以更快速地执行非跟踪查询，因为无需设置更改跟踪信息。 如果不需要更新从数据库中检索到的实体，则应使用非跟踪查询。 可以将单个查询替换为非跟踪查询。 非跟踪查询也会根据数据库中的内容提供结果，但不考虑本地更改或已添加的实体。</p> 
<pre><code class="prism language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> blogs <span class="token operator">=</span> context<span class="token punctuation">.</span>Blogs
    <span class="token punctuation">.</span><span class="token function">AsNoTracking</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">ToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>还可以在上下文实例级别更改默认跟踪行为：</p> 
<pre><code class="prism language-csharp">context<span class="token punctuation">.</span>ChangeTracker<span class="token punctuation">.</span>QueryTrackingBehavior <span class="token operator">=</span> QueryTrackingBehavior<span class="token punctuation">.</span>NoTracking<span class="token punctuation">;</span>
<span class="token class-name"><span class="token keyword">var</span></span> blogs <span class="token operator">=</span> context<span class="token punctuation">.</span>Blogs<span class="token punctuation">.</span><span class="token function">ToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>（3）标识解析<br> 由于跟踪查询使用更改跟踪器，因此 EF Core 将在跟踪查询中执行标识解析。 当具体化实体时，如果 EF Core 已被跟踪，则会从更改跟踪器返回相同的实体实例。 如果结果中多次包含相同的实体，则每次会返回相同的实例。 非跟踪查询不会使用更改跟踪器，也不会执行标识解析。 因此会返回实体的新实例，即使结果中多次包含相同的实体也是如此。 从 EF Core 5.0 开始，可以在同一个查询中结合使用上述两种行为。 也就是说，可以使用非跟踪查询并对结果执行标识解析。 我们添加了另一个运算符 AsNoTrackingWithIdentityResolution()，就像添加 AsNoTracking() 可查询运算符一样。 QueryTrackingBehavior 枚举中也添加了一个关联项。 如果将查询配置为使用标识解析和非跟踪行为，生成查询结果时我们将在后台使用独立的更改追踪器，以便仅将每个实例具体化一次。 此更改追踪器不同于上下文中的更改追踪器，因此上下文不会追踪这些结果。 完全枚举查询后，该更改追踪器将超出范围，并根据需要对其进行垃圾回收。</p> 
<pre><code class="prism language-csharp"><span class="token class-name"><span class="token keyword">var</span></span> blogs <span class="token operator">=</span> context<span class="token punctuation">.</span>Blogs
    <span class="token punctuation">.</span><span class="token function">AsNoTrackingWithIdentityResolution</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">ToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>加载所有数据</p> 
<pre><code class="prism language-csharp"><span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">BloggingContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name"><span class="token keyword">var</span></span> blogs <span class="token operator">=</span> context<span class="token punctuation">.</span>Blogs<span class="token punctuation">.</span><span class="token function">ToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>加载单个实体</p> 
<pre><code class="prism language-csharp"><span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">BloggingContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name"><span class="token keyword">var</span></span> blog <span class="token operator">=</span> context<span class="token punctuation">.</span>Blogs
        <span class="token punctuation">.</span><span class="token function">Single</span><span class="token punctuation">(</span>b <span class="token operator">=&gt;</span> b<span class="token punctuation">.</span>BlogId <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>筛选</p> 
<pre><code class="prism language-csharp"><span class="token keyword">using</span> <span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">var</span></span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">BloggingContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name"><span class="token keyword">var</span></span> blogs <span class="token operator">=</span> context<span class="token punctuation">.</span>Blogs
        <span class="token punctuation">.</span><span class="token function">Where</span><span class="token punctuation">(</span>b <span class="token operator">=&gt;</span> b<span class="token punctuation">.</span>Url<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span><span class="token string">"dotnet"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">ToList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6b4796fe1c6b092e1edda4ddb9792e31/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">哈诺塔问题及其python代码实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/353b6bbf047076f3cc5b25b13cd861d7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android, Switch滑动事件监听实现。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>