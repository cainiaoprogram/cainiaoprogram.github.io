<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux 内存占用、内存泄漏 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux 内存占用、内存泄漏" />
<meta property="og:description" content="1. slab debug定位kernelspace内存泄露的方法¶ 以下为辅助定位内存泄漏的手段，主要是针对内存kmalloc。
在kernel中打开如下两个config
查看meminfo
如下图，若SUnreclaim一直增加即可初步判断为内核中kmalloc之后没有释放，导致内存泄漏。
slabinfo对比
开机启动时使用cat /proc/slabinfo备份，出现泄露后再使用cat/proc/slabinfo，将两者进行对比。
分析上图数据
图中kmalloc-8192的次数增加较多，在/sys/kernel/slab/kmalloc-8192/alloc_calls中查看调用kmalloc-8192的symbol和他调用的次数，定位到出现泄露的function。
2. kmemleak--Kernel space内存泄露分析工具¶ 2.1. kernel mode的memory申请¶ SDK里申请kernel mode的memory，主要有两种方式：
vmalloc
分配大块内存，走budy system；通过cat/proc/vmallocinfo可以统计；
注：Cat vmallocinfo，如果有buffer块数一直在增加，则是内存泄露。
kmalloc/kmem_cache_create
分配小于pagesize，走slab机制；通过cat /proc/meminfo里的slab字段可以统计。
注：如果怀疑有kernel mode内存泄露，运行应用过程中每间隔一段时间cat/proc/meminfo留意slab。如果一直在增加，大概率有内存泄露的可能。具体模块的函数泄露可以用kmemleak debug。
2.2. 检查内存泄漏的方法 -- Kernel Space¶ Linux kernel 2.6.31后的版本，提供了 KMEMLEAK 的选项，可以拿来测试 kernel modules是否有 memory leakage，用法整理如下。
修改 .config 设定 KMEMLEAK，重新编译 kernel，重烧 image。
摘录 .config 如下：
# # Memory Debugging # CONFIG_HAVE_DEBUG_KMEMLEAK=y CONFIG_DEBUG_KMEMLEAK=y CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE=4096 确认板子上的 kernel 已经提供 kmemleak的功能
# mount -t debugfs nodev /sys/kernel/debug/ # cat /sys/kernel/debug/kmemleak 注：若存在 kmemleak，表示 kernel 已经支援 kmemleak" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/19f52b265b0ed0b1d3dc763ed4886879/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-06T16:16:04+08:00" />
<meta property="article:modified_time" content="2023-06-06T16:16:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux 内存占用、内存泄漏</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="1-slab-debugkernelspace">1. slab debug定位kernelspace内存泄露的方法<a href="https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html#1-slab-debugkernelspace" rel="nofollow" title="¶">¶</a></h3> 
<p>以下为辅助定位内存泄漏的手段，主要是针对内存kmalloc。</p> 
<ol><li> <p>在kernel中打开如下两个config</p> <p class="img-center"><img alt="" src="https://images2.imgbox.com/47/d7/cY6rn6P3_o.png"></p> </li><li> <p>查看meminfo</p> <p>如下图，若SUnreclaim一直增加即可初步判断为内核中kmalloc之后没有释放，导致内存泄漏。</p> </li><li> <p>slabinfo对比</p> <p>开机启动时使用<code>cat /proc/slabinfo</code>备份，出现泄露后再使用<code>cat/proc/slabinfo</code>，将两者进行对比。</p> <p class="img-center"><img alt="" src="https://images2.imgbox.com/56/47/VvZxGYMx_o.png"></p> </li><li> <p>分析上图数据</p> <p>图中kmalloc-8192的次数增加较多，在<code>/sys/kernel/slab/kmalloc-8192/alloc_calls</code>中查看调用kmalloc-8192的symbol和他调用的次数，定位到出现泄露的function。</p> </li></ol> 
<hr> 
<h3 id="2-kmemleak-kernel-space">2. kmemleak--Kernel space内存泄露分析工具<a href="https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html#2-kmemleak-kernel-space" rel="nofollow" title="¶">¶</a></h3> 
<hr> 
<h4 id="21-kernel-modememory">2.1. kernel mode的memory申请<a href="https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html#21-kernel-modememory" rel="nofollow" title="¶">¶</a></h4> 
<p>SDK里申请kernel mode的memory，主要有两种方式：</p> 
<ol><li> <p>vmalloc</p> <p>分配大块内存，走budy system；通过<code>cat/proc/vmallocinfo</code>可以统计；</p> <p>注：<code>Cat vmallocinfo</code>，如果有buffer块数一直在增加，则是内存泄露。</p> </li><li> <p>kmalloc/kmem_cache_create</p> <p>分配小于pagesize，走slab机制；通过<code>cat /proc/meminfo</code>里的slab字段可以统计。</p> <p>注：如果怀疑有kernel mode内存泄露，运行应用过程中每间隔一段时间<code>cat/proc/meminfo</code>留意slab。如果一直在增加，大概率有内存泄露的可能。具体模块的函数泄露可以用kmemleak debug。</p> </li></ol> 
<hr> 
<h4 id="22-kernel-space">2.2. 检查内存泄漏的方法 -- Kernel Space<a href="https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html#22-kernel-space" rel="nofollow" title="¶">¶</a></h4> 
<p>Linux kernel 2.6.31后的版本，提供了 KMEMLEAK 的选项，可以拿来测试 kernel modules是否有 memory leakage，用法整理如下。</p> 
<ol><li> <p>修改 <code>.config</code> 设定 KMEMLEAK，重新编译 kernel，重烧 image。</p> <p>摘录 <code>.config</code> 如下：</p> <pre>#
# Memory Debugging
#
CONFIG_HAVE_DEBUG_KMEMLEAK=y
CONFIG_DEBUG_KMEMLEAK=y
CONFIG_DEBUG_KMEMLEAK_EARLY_LOG_SIZE=4096
</pre> </li><li> <p>确认板子上的 kernel 已经提供 kmemleak的功能</p> <pre># mount -t debugfs nodev /sys/kernel/debug/

# cat /sys/kernel/debug/kmemleak
</pre> <p>注：若存在 kmemleak，表示 kernel 已经支援 kmemleak</p> </li><li> <p>用法举例</p> <p class="img-center"><img alt="" src="https://images2.imgbox.com/3b/9f/6Nih4WjU_o.png"></p> <p>cid:image003.png\\@01D2DB8B.2E89DE10</p> <p>注：若沒有手动执行 scan，系统每10分钟自动扫描一次 memory leakage.</p> </li><li> <p>实际测试 Driver memory leakage 的方法</p> <pre># mount -t debugfs nodev /sys/kernel/debug/
# echo clear &gt; /sys/kernel/debug/kmemleak
# run_your_driver_test_here
# echo scan &gt; /sys/kernel/debug/kmemleak
# cat /sys/kernel/debug/kmemleak
</pre> </li></ol> 
<hr> 
<h3 id="3-dmalloc-usr-space">3. dmalloc--查usr space内存泄露<a href="https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html#3-dmalloc-usr-space" rel="nofollow" title="¶">¶</a></h3> 
<hr> 
<h4 id="31">3.1. 内存泄漏排查<a href="https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html#31" rel="nofollow" title="¶">¶</a></h4> 
<p>程序运行过程meminfo的Memfree不断减少，<code>echo 3 &gt;/proc/sys/vm/drop_cache</code>也不返回内存，则可能存在内存泄露。</p> 
<p>排除kernel space内存泄露后，隔段时间再观察<code>cat /proc/PID/smap</code>每个so的堆，可以找到内存泄漏的so。</p> 
<p>准确定位内存泄露需使用dmalloc工具。</p> 
<hr> 
<h4 id="32">3.2. 交叉编译<a href="https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html#32" rel="nofollow" title="¶">¶</a></h4> 
<ol><li> <p><a href="http://dmalloc.com/" rel="nofollow" title="http://dmalloc.com/">http://dmalloc.com/</a>可下载dmalloc-5.5.2.gz</p> <p>解压，修改configure文件，ac_cv_page_size=0 改为ac_cv_page_size=12</p> </li><li> <p>./configure --prefix=/home/cbm/workplace/dmalloc/output/ --exec-prefix=/home/cbm/workplace/dmalloc/output/CC=arm-buildroot-linux-uclibcgnueabihf-gcc --host=arm-linux CXX=arm-buildroot-linux-uclibcgnueabihf-g++ AR=arm-buildroot-linux-uclibcgnueabihf-ar LD=arm-buildroot-linux-uclibcgnueabihf-ld --enable-threads --enable-shlib</p> </li><li> <p>auto脚本对交叉编译支持不够完善，生成的Makefile有少数命令需替换</p> <p>如<code>ld-G，ar cr</code>需改为<code>$(LD) -G</code> 和 <code>$(AR) cr</code></p> </li><li> <p>make CC=arm-buildroot-linux-uclibcgnueabihf-gcc CXX=arm-buildroot-linux-uclibcgnueabihf-g++ AR=arm-buildroot-linux-uclibcgnueabihf-ar LD=arm-buildroot-linux-uclibcgnueabihf-ld</p> </li><li> <p><code>make install</code>，即可在prefix目录生成bin include和lib。</p> </li></ol> 
<hr> 
<h4 id="33">3.3. 环境变量设置<a href="https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html#33" rel="nofollow" title="¶">¶</a></h4> 
<p>dmalloc工具进行环境变量设置，如：<code>dmalloc -l /tmp/dmalloc.log all</code>，即输出所有信息并存入<code>dmalloc.log</code>文件；</p> 
<p></p> 
<pre># dmalloc -l /tmp/dm.log all
DMALLOC_OPTIONS=debug=0xcf4ed2b,log=/tmp/dm.log `
export DMALLOC_OPTIONS `
</pre> 
<hr> 
<h4 id="34">3.4. 库的应用<a href="https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html#34" rel="nofollow" title="¶">¶</a></h4> 
<ol><li> <p>在主代码中添加<code>#include &lt;dmalloc.h&gt;</code></p> </li><li> <p>更改Makefile，添加<code>CFLAGS += -Iinclude LDFLAGS += -L$(TOP)/dmalloc -ldmalloc</code></p> </li><li> <p>重新build需要detect的应用</p> </li></ol> 
<hr> 
<h4 id="35-leak">3.5. Leak检测<a href="https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html#35-leak" rel="nofollow" title="¶">¶</a></h4> 
<ol><li> <p>通过dmalloc所生产的变量DMALLOC_OPTIONS，手动或自动export到系统中</p> </li><li> <p>执行需detect的应用</p> </li><li> <p>查看变量DMALLOC_OPTIONS中所定义的导出文件内容</p> </li><li> <p>退出需detect的应用</p> </li><li> <p>查看变量DMALLOC_OPTIONS中所定义的导出文件内容</p> </li><li> <p>上述过程所查看的导出文件存在<code>not freed:</code>字串，则为leak点</p> </li></ol> 
<hr> 
<h3 id="4">4. 程序运行内存占用<a href="https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html#4" rel="nofollow" title="¶">¶</a></h3> 
<p>以公板运行mixer为例，详细说明内存如何分配。</p> 
<hr> 
<h4 id="41">4.1. 实验设备<a href="https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html#41" rel="nofollow" title="¶">¶</a></h4> 
<p>335+imx307 sensor</p> 
<hr> 
<h4 id="42">4.2. 实验场景<a href="https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html#42" rel="nofollow" title="¶">¶</a></h4> 
<p>（典型案例）mixer路4路流：JPEG + 主码流 + 子码流 + MD算法</p> 
<hr> 
<h4 id="43">4.3. 实验基础<a href="https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html#43" rel="nofollow" title="¶">¶</a></h4> 
<p>SDK里kernel space 下ko有两种内存申请方式：</p> 
<ul><li> <p>vmalloc</p> <p>分配大块内存，走budysystem；通过<code>cat/proc/vmallocinfo</code>可以统计；</p> </li><li> <p>kmalloc/kmem_cache_create</p> <p>分配小于pagesize，走slab机制；通过<code>cat/proc/meminfo</code>里的slab字段可以统计。</p> <p>内核中常见的还有如alloc_pages/__get_free_page，只能通过free统计，但目前看起来只有emmc会调用。</p> </li><li> <p>Ioremap</p> <p>I/O内存资源的物理地址映射到核心虚地址空间，不占用物理空间；</p> </li><li> <p>PageTable</p> <p>用于将内存的虚拟地址翻译成物理地址，/proc/meminfo中的PageTables统计了Page Table所占用的内存大小。</p> </li><li> <p>KernelStack</p> <p>每一个用户线程都会分配一个kernel stack（内核栈），它是kernel消耗的内存。统计值是/proc/meminfo的KernelStack。</p> </li></ul> 
<p>Userspace中常见malloc，小于128K走c标准库的brk，大于128K走mmap，但对于内核来说，一旦发生缺页中断，都是走pageallocater。可以通过procmem工具统计实际占用的物理空间（实际上就是把cat/proc/PID/smap里的RSS/PSS之和）。</p> 
<hr> 
<h4 id="44">4.4. 实验步骤<a href="https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html#44" rel="nofollow" title="¶">¶</a></h4> 
<ol><li> <p>开机加载完ko后，drop cache再看<code>cat proc/meminfo</code>和 <code>cat /proc/vmallocinfo</code></p> </li><li> <p>运行mixer后，drop cache再看<code>cat proc/meminfo</code>、 <code>cat /proc/vmallocinfo</code>、<code>cat/proc/’PID’/status</code>和<code>./procmem PID</code></p> </li><li> <p>对比工具分析运行前后的vmalloc增加部分</p> </li></ol> 
<hr> 
<h4 id="45">4.5. 总结<a href="https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html#45" rel="nofollow" title="¶">¶</a></h4> 
<p>free减少 = 16836 – 8888 = 7948K</p> 
<p>Vmalloc增加：547page = 2188K</p> 
<p>lab增加：6328 – 4792 = 1536K</p> 
<p>PageTable+KernelStack增加：536+116 – (352+52) = 248K</p> 
<p>应用代码段+ so 代码段 + 栈 + ro段+堆 = 3732K （Pss）</p> 
<p>2188 + 1536 + 248 + 3732 = 7704K，Linux kernel并没有统计所有的内存分配，kernel动态分配的内存中有一部分没有计入<code>/proc/meminfo</code>。我们只能大概的统计出来mixer的内存占用。</p> 
<hr> 
<h3 id="5-procmem-procrank-usr-space">5. procmem procrank--usr space内存分析工具<a href="https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html#5-procmem-procrank-usr-space" rel="nofollow" title="¶">¶</a></h3> 
<p>源码下载：<a href="https://github.com/sunao2002002/mem_proc.git" title="GitHub - sunao2002002/mem_proc">GitHub - sunao2002002/mem_proc</a></p> 
<ol><li> <p>解压后用下文内容替换<code>CMakeLists.txt</code>.</p> <pre>SET(CMAKE_C_COMPILER "arm-buildroot-linux-uclibcgnueabihf-gcc")
SET(CMAKE_CXX_COMPILER "arm-buildroot-linux-uclibcgnueabihf-g++")
cmake_minimum_required(VERSION 2.8)
PROJECT (mem_proc)
file(GLOB SOURCES "${PROJECT_SOURCE_DIR}/libpagemap/*.c")
add_definitions (
-D_LARGEFILE64_SOURCE
)
include_directories (${PROJECT_SOURCE_DIR}/libpagemap/include)
add_library(pagemap ${SOURCES})

add_executable(procmem  ${PROJECT_SOURCE_DIR}/procmem/procmem.c)
target_link_libraries(procmem pagemap)
add_executable(procrank  ${PROJECT_SOURCE_DIR}/procrank/procrank.c)
target_link_libraries(procrank pagemap)
</pre> </li><li> <p>cd mem_proc</p> </li><li> <p>mkdir out</p> </li><li> <p>cd out</p> </li><li> <p>cmake ..</p> </li><li> <p>make 即可生成procmem和procrank</p> </li></ol> 
<p><strong>VSS</strong>：Virtual Set Size，虚拟内存耗用内存，包括共享库的内存</p> 
<p><strong>RSS</strong>：Resident Set Size，实际使用物理内存，包括共享库</p> 
<p><strong>PSS</strong>：Proportional Set Size，实际使用的物理内存，共享库按比例分配</p> 
<p><strong>USS</strong>：Unique Set Size，进程独占的物理内存，不计算共享库，也可以理解为将进程杀死能释</p> 
<p><a href="https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html" rel="nofollow" title="https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html">https://wx.comake.online/doc/doc/Version_Tiramisu_DLS00V011-20220308/customer/faq/m6-ipc/memory.html</a></p> 
<p><a href="https://blog.arstercz.com/what-to-do-when-linux-slab-memory-leak/" rel="nofollow" title="另外可参考l​​​​​​​ ​​​​​​​https://blog.arstercz.com/what-to-do-when-linux-slab-memory-leak/">另外可参考<br> l​​​​​​​ ​​​​​​​https://blog.arstercz.com/what-to-do-when-linux-slab-memory-leak/</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5021802e53b693b928f9c3afcb02c7a1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Flutter 底部列表抽屉，三阶滑动 ， 支持列表Sliver布局</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/29e1d6faf3bd5f2eca61b58f1bb46358/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">qt程序诡异bug一例,ctrl&#43;c，ctrl&#43;x，剪贴板无法使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>