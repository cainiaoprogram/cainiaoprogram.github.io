<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android百度地图(四):百度地图运动轨迹纠偏、去噪、绑路之百度鹰眼 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android百度地图(四):百度地图运动轨迹纠偏、去噪、绑路之百度鹰眼" />
<meta property="og:description" content="上一篇文章介绍了地图画轨迹的基本原理和实现。不难发现，当位置处于建筑物密集区、桥梁、高架桥下，gps信号较差时，画出来的轨迹效果会比较差。即使是在空旷地带，也难免会出现gps漂移的情况而造成轨迹的偏差。这时就需要我们对位置点进行纠偏、去噪、抽稀、绑路操作。百度鹰眼sdk则提供了相应的api，本篇文章将介绍如何使用百度鹰眼sdk画出效果相对较好的轨迹。
先来看看效果图
1.百度地图(三)文章中demo取得原始位置点画出来的轨迹图：
原始位置轨迹图a 可以发现轨迹大致能反应用户所经过的路劲，效果还是不错的，说明gps信号较好，精度较高。但是除了西边的轨迹较为平滑之外，其他方位的轨迹都出现了锯齿形状，原因是gps位置有一定精度差，所以不一定会准确的定位到所行走的路劲上。如果运动范围较大(需缩小地图显示整个轨迹，轨迹将在视觉上变得平滑)，而且轨迹精度要求不高，能确定用户在户外，个人觉得图a就能满足要求了
2.使用百度鹰眼sdk处理后的轨迹图：
经处理后的轨迹图 可以发现经处理的轨迹已经没有锯齿形状了，位置都落到了路劲上，这就是我们想要的效果。如果无法确定用户gps信号的优良，可能会进行网络定位，并且轨迹的精度要求很高，那么位置必须通过百度鹰眼sdk处理后再画出运动轨迹，这样才能达到图b的效果。
下面将介绍如何使用百度鹰眼sdk画出效果相对较好的轨迹，包括驾车、骑行、步行。
一 配置工程 1.申请apikey
2.创建鹰眼轨迹服务空间并获取 service_id
3.在Application标签中声明SERVICE组件,每个APP拥有自己独立的鹰眼追踪service
&lt;service android:name=&#34;com.baidu.trace.LBSTraceService&#34; android:enabled=&#34;true&#34; android:exported=&#34;true&#34; android:process=&#34;:remote&#34; /&gt; 二 百度鹰眼sdk关键api介绍 1.轨迹数据处理流程图
流程图 2.初始化
//以下都是伪代码 /** * 轨迹服务：通过serviceId对应服务端，用于存储、访问和管理自己的终端和轨迹 serviceId：轨迹服务id，这就是配置工程申请的service_id entityName：设备标识 isNeedObjectStorage：是否需要对象存储服务，比如在某个点存一个图层图片，显示这里有超速摄像头， 获取轨迹的时候，也可以获取这个图层图片显示在轨迹的相应位置上. 这里默认为：一般为false，关闭对象存储服务。 注：鹰眼 Android SDK v3.0以上版本支持随轨迹上传图像等对象数据， 若需使用此功能，该参数需设为 true，且需导入bos-android-sdk-1.0.2.jar。 */ Trace mTrace = new Trace(serviceId, entityName,isNeedObjectStorage); /** * 轨迹客户端LBSTraceClient，主要功能： (1)内部封装了百度定位sdk的api，采集定位位置点，定位sdk不清楚的可以篇头阅读百度文章(一) (2)将采集数据打包发给服务端 (3)请求服务端，查询经过处理的轨迹、位置等信息 */ LBSTraceClient mClient = new LBSTraceClient(mContext); 3.定位当前位置显示在地图上
//定位请求参数类 LocRequest locRequest = new LocRequest(serviceId); //时时定位设备当前位置，定位信息不会存储在轨迹服务端，即不会形成轨迹信息,只用于在MapView显示当前位置 mClient.queryRealTimeLoc(locRequest, entityListener);//这里只会一次定位,多次定位使Handler." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/82726935eb41e57ec041dc62e65a1cb4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-31T10:38:40+08:00" />
<meta property="article:modified_time" content="2023-07-31T10:38:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android百度地图(四):百度地图运动轨迹纠偏、去噪、绑路之百度鹰眼</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>上一篇文章介绍了地图画轨迹的基本原理和实现。不难发现，当位置处于建筑物密集区、桥梁、高架桥下，gps信号较差时，画出来的轨迹效果会比较差。即使是在空旷地带，也难免会出现gps漂移的情况而造成轨迹的偏差。这时就需要我们对位置点进行纠偏、去噪、抽稀、绑路操作。百度鹰眼sdk则提供了相应的api，本篇文章将介绍如何使用百度鹰眼sdk画出效果相对较好的轨迹。</p> 
<p>先来看看效果图<br> 1.百度地图(三)文章中demo取得原始位置点画出来的轨迹图：</p> 
<div style="margin-left:-40px;"> 
 <img alt="" src="https://images2.imgbox.com/66/ae/MPJjnTIT_o.png"> 
 <div style="margin-left:0px;">
   原始位置轨迹图a 
 </div> 
</div> 
<p><br> 可以发现轨迹大致能反应用户所经过的路劲，效果还是不错的，说明gps信号较好，精度较高。但是除了西边的轨迹较为平滑之外，其他方位的轨迹都出现了锯齿形状，原因是gps位置有一定精度差，所以不一定会准确的定位到所行走的路劲上。如果运动范围较大(需缩小地图显示整个轨迹，轨迹将在视觉上变得平滑)，而且轨迹精度要求不高，能确定用户在户外，个人觉得图a就能满足要求了</p> 
<p>2.使用百度鹰眼sdk处理后的轨迹图：</p> 
<div style="margin-left:-40px;"> 
 <img alt="" src="https://images2.imgbox.com/29/41/v4cc3722_o.png"> 
 <div style="margin-left:0px;">
   经处理后的轨迹图 
 </div> 
</div> 
<p><br> 可以发现经处理的轨迹已经没有锯齿形状了，位置都落到了路劲上，这就是我们想要的效果。如果无法确定用户gps信号的优良，可能会进行网络定位，并且轨迹的精度要求很高，那么位置必须通过百度鹰眼sdk处理后再画出运动轨迹，这样才能达到图b的效果。</p> 
<p>下面将介绍如何使用百度鹰眼sdk画出效果相对较好的轨迹，包括驾车、骑行、步行。</p> 
<h3 style="margin-left:0px;">一 配置工程</h3> 
<p>1.<a href="http://lbsyun.baidu.com/apiconsole/key" rel="nofollow" title="申请apikey">申请apikey</a><br> 2.<a href="http://lbsyun.baidu.com/trace/admin/service" rel="nofollow" title="创建鹰眼轨迹服务空间并获取 service_id">创建鹰眼轨迹服务空间并获取 service_id</a><br> 3.在Application标签中声明SERVICE组件,每个APP拥有自己独立的鹰眼追踪service</p> 
<pre><code class="language-java">
<code>&lt;service
     android:name=<span style="color:#2aa198;">"com.baidu.trace.LBSTraceService"</span>
     android:enabled=<span style="color:#2aa198;">"true"</span>
     android:exported=<span style="color:#2aa198;">"true"</span>
     android:process=<span style="color:#2aa198;">":remote"</span> /&gt;</code></code></pre> 
<h3 style="margin-left:0px;">二 百度鹰眼sdk关键api介绍</h3> 
<p>1.轨迹数据处理流程图</p> 
<div style="margin-left:-40px;"> 
 <img alt="" src="https://images2.imgbox.com/3c/c0/p1u9ziFO_o.png"> 
 <div style="margin-left:0px;">
   流程图 
 </div> 
</div> 
<p><br> 2.初始化</p> 
<pre><code class="language-java">
<code><span style="color:#93a1a1;">//以下都是伪代码</span>
<span style="color:#93a1a1;">/**
*  轨迹服务：通过serviceId对应服务端，用于存储、访问和管理自己的终端和轨迹
   serviceId：轨迹服务id，这就是配置工程申请的service_id
   entityName：设备标识
   isNeedObjectStorage：是否需要对象存储服务，比如在某个点存一个图层图片，显示这里有超速摄像头，
                        获取轨迹的时候，也可以获取这个图层图片显示在轨迹的相应位置上.
                        这里默认为：一般为false，关闭对象存储服务。
                        注：鹰眼 Android SDK v3.0以上版本支持随轨迹上传图像等对象数据，
                        若需使用此功能，该参数需设为 true，且需导入bos-android-sdk-1.0.2.jar。
*/</span>
Trace mTrace = <span style="color:#859900;">new</span> Trace(serviceId, entityName,isNeedObjectStorage);

<span style="color:#93a1a1;">/**
*  轨迹客户端LBSTraceClient，主要功能：
   (1)内部封装了百度定位sdk的api，采集定位位置点，定位sdk不清楚的可以篇头阅读百度文章(一)
   (2)将采集数据打包发给服务端
   (3)请求服务端，查询经过处理的轨迹、位置等信息
*/</span>
LBSTraceClient mClient = <span style="color:#859900;">new</span> LBSTraceClient(mContext);</code></code></pre> 
<p>3.定位当前位置显示在地图上</p> 
<pre><code class="language-java">
<code><span style="color:#93a1a1;">//定位请求参数类</span>
LocRequest locRequest = <span style="color:#859900;">new</span> LocRequest(serviceId);
<span style="color:#93a1a1;">//时时定位设备当前位置，定位信息不会存储在轨迹服务端，即不会形成轨迹信息,只用于在MapView显示当前位置</span>
mClient.queryRealTimeLoc(locRequest, entityListener);<span style="color:#93a1a1;">//这里只会一次定位,多次定位使Handler.postDelayed(Runnable, interval)实现;</span>

<span style="color:#93a1a1;">//Entity监听器(用于接收实时定位回调)</span>
<span style="color:#859900;">private</span> OnEntityListener entityListener = <span style="color:#859900;">new</span> OnEntityListener() {
     @Override
     <span style="color:#859900;">public</span> <span style="color:#859900;">void</span> <span style="color:#268bd2;">onReceiveLocation</span>(TraceLocation location) {
          <span style="color:#93a1a1;">//将回调的当前位置location显示在地图MapView上，地图显示位置不清楚的可以篇头阅读百度文章(二)</span>
          <span style="color:#93a1a1;">//这里位置点的返回间隔时间为Handler.postDelayed的延时时间</span>
     }   
};

<span style="color:#93a1a1;">/**
* 当轨迹服务开启，且采集数据开启之后，显示在地图上的位置点可以用服务端纠偏后的最新点，
  因为通过mClient.queryRealTimeLoc获取的点可能不精确，出现漂移等情况。
*/</span>
<span style="color:#93a1a1;">//查询服务端纠偏后的最新轨迹点请求参数类</span>
LatestPointRequest request = <span style="color:#859900;">new</span> LatestPointRequest(getTag(), serviceId, entityName);
ProcessOption processOption = <span style="color:#859900;">new</span> ProcessOption();<span style="color:#93a1a1;">//纠偏选项</span>
processOption.setRadiusThreshold(<span style="color:#2aa198;">50</span>);<span style="color:#93a1a1;">//设置精度过滤，0为不需要；精度大于50米的位置点过滤掉</span>
processOption.setTransportMode(TransportMode.walking);
processOption.setNeedDenoise(<span style="color:#859900;">true</span>);<span style="color:#93a1a1;">//去噪处理</span>
processOption.setNeedMapMatch(<span style="color:#859900;">true</span>);<span style="color:#93a1a1;">//绑路处理</span>
request.setProcessOption(processOption);<span style="color:#93a1a1;">//设置参数</span>
mClient.queryLatestPoint(request, trackListener);<span style="color:#93a1a1;">//请求纠偏后的最新点</span>

<span style="color:#93a1a1;">//轨迹监听器(用于接收纠偏后实时位置回调)</span>
<span style="color:#859900;">private</span> OnTrackListener trackListener = <span style="color:#859900;">new</span> OnTrackListener() {
     @Override
     <span style="color:#859900;">public</span> <span style="color:#859900;">void</span> <span style="color:#268bd2;">onLatestPointCallback</span>(LatestPointResponse response) {
          <span style="color:#93a1a1;">//将纠偏后实时位置显示在地图MapView上</span>
          <span style="color:#93a1a1;">//这里位置点的返回间隔时间为数据打包上传的频率；数据发送到服务端，才会更新最新的纠偏位置</span>
     }
};</code></code></pre> 
<p>4.开启服务，开始采集数据</p> 
<pre><code class="language-java">
<code><span style="color:#93a1a1;">//设置定位模式</span>
mClient.setLocationMode(LocationMode.High_Accuracy);

<span style="color:#93a1a1;">/**
* 设置采集频率：这里的采集频率指的是轨迹数据的采集频率，和上面显示当前位置的定位频率要区分开
* 打包上传频率：mClient每隔packInterval时间会自动打包上传
*/</span>
mClient.setInterval(gatherInterval, packInterval);

<span style="color:#93a1a1;">/**
* 开启轨迹服务
*/</span>
mClient.startTrace(mTrace, traceListener);
<span style="color:#93a1a1;">//开启位置点采集</span>
mClient.startGather(traceListener);
startTime = System.currentTimeMillis()/<span style="color:#2aa198;">1000</span>;<span style="color:#93a1a1;">//记录开始采集时间</span>

<span style="color:#93a1a1;">//轨迹服务监听器</span>
<span style="color:#859900;">private</span> OnTraceListener traceListener = <span style="color:#859900;">new</span> OnTraceListener() {

    <span style="color:#93a1a1;">/**
    * 绑定com.baidu.trace.LBSTraceService服务回调接口
    * <span style="color:#2aa198;">@param</span> errorNo  状态码,0：成功,1：失败
    * <span style="color:#2aa198;">@param</span> message 消息
    */</span>
    @Override
    <span style="color:#859900;">public</span> <span style="color:#859900;">void</span> <span style="color:#268bd2;">onBindServiceCallback</span>(<span style="color:#859900;">int</span> errorNo, String message) {

    }

    <span style="color:#93a1a1;">/**
    * 开启服务回调接口
    * <span style="color:#2aa198;">@param</span> errorNo 状态码
    * 0：成功,10000：请求发送失败,10001：服务开启失败,10002：参数错误,10003：网络连接失败
      10004：网络未开启,10005：服务正在开启,10006：服务已开启
    * <span style="color:#2aa198;">@param</span> message 消息
    */</span>
    @Override
    <span style="color:#859900;">public</span> <span style="color:#859900;">void</span> <span style="color:#268bd2;">onStartTraceCallback</span>(<span style="color:#859900;">int</span> errorNo, String message) {

    }

     <span style="color:#93a1a1;">/**
     * 停止服务回调接口
     * <span style="color:#2aa198;">@param</span> errorNo 状态码
     * 0：成功,11000：请求发送失败,11001：服务停止失败,11002：服务未开启,11003：服务正在停止
     * <span style="color:#2aa198;">@param</span> message 消息
     */</span>
     @Override
     <span style="color:#859900;">public</span> <span style="color:#859900;">void</span> <span style="color:#268bd2;">onStopTraceCallback</span>(<span style="color:#859900;">int</span> errorNo, String message) {

     }

     <span style="color:#93a1a1;">/**
     * 开启采集回调接口
     * <span style="color:#2aa198;">@param</span> errorNo 状态码
     * 0：成功,12000：请求发送失败,12001：采集开启失败,12002：服务未开启
     * <span style="color:#2aa198;">@param</span> message 消息             
     */</span>
     @Override
     <span style="color:#859900;">public</span> <span style="color:#859900;">void</span> <span style="color:#268bd2;">onStartGatherCallback</span>(<span style="color:#859900;">int</span> errorNo, String message) {

     }

     <span style="color:#93a1a1;">/**
     * 停止采集回调接口
     * <span style="color:#2aa198;">@param</span> errorNo 状态码
     * 0：成功,13000：请求发送失败,13001：采集停止失败,13002：服务未开启
     * <span style="color:#2aa198;">@param</span> message 消息              
     */</span>
     @Override
     <span style="color:#859900;">public</span> <span style="color:#859900;">void</span> <span style="color:#268bd2;">onStopGatherCallback</span>(<span style="color:#859900;">int</span> errorNo, String message) {

     }

     <span style="color:#93a1a1;">/**
     * 推送消息回调接口
     * <span style="color:#2aa198;">@param</span> messageType 状态码
     * 0x01：配置下发,0x02：语音消息,0x03：服务端围栏报警消息,0x04：本地围栏报警消息,0x05~0x40：系统预留,0x41~0xFF
     * <span style="color:#2aa198;">@param</span> pushMessage 消息            
     */</span>
     @Override
     <span style="color:#859900;">public</span> <span style="color:#859900;">void</span> <span style="color:#268bd2;">onPushCallback</span>(<span style="color:#859900;">byte</span> messageType, PushMessage pushMessage) {
        <span style="color:#93a1a1;">//这个回调其实是比较重要的，本篇主要讲的是画轨迹，所以就不详细讲了</span>
        <span style="color:#93a1a1;">/**
        * 那么这里能实现什么功能呢，我想到的两个例子
        * 1.到达目的地提示用户，在目的地画个圈，进入提醒
           实现：CreateFenceRequest创建围栏：圆形围栏、多边形围栏、线型围栏、行政区围栏，一旦进出则推送报警，
           pushMessage.getFenceAlarmPushInfo().getMonitoredAction()可以知道进或出，
           MonitoredAction.enter:进围栏，MonitoredAction.exit:出围栏
        * 2.用户出一定区域发出提醒，在当前位置地画个圈，出去了则提醒
        *  比如孩子在小区玩，拿着手机和小伙伴在树底下玩王者农药，我们为了孩子的安全，
           只允许他在小区范围内活动，一旦离开了小区的范围就给大人发个短信什么的，哈哈
        */</span>
     }
};</code></code></pre> 
<p>5.停止服务，停止采集数据</p> 
<pre><code class="language-java">
<code>mClient.stopGather(traceListener);
endTime = System.currentTimeMillis()/<span style="color:#2aa198;">1000</span>;<span style="color:#93a1a1;">//记录停止采集时间</span>
mClient.stopTrace(mTrace, traceListener);</code></code></pre> 
<p>6.请求服务端处理后的位置数据</p> 
<pre><code class="language-java">
<code><span style="color:#93a1a1;">/**
 * 历史轨迹请求类
 */</span>
HistoryTrackRequest historyTrackRequest = <span style="color:#859900;">new</span> HistoryTrackRequest();
ProcessOption processOption = <span style="color:#859900;">new</span> ProcessOption();<span style="color:#93a1a1;">//纠偏选项</span>
processOption.setRadiusThreshold(<span style="color:#2aa198;">50</span>);<span style="color:#93a1a1;">//精度过滤</span>
processOption.setTransportMode(TransportMode.walking);<span style="color:#93a1a1;">//交通方式，默认为驾车</span>
processOption.setNeedDenoise(<span style="color:#859900;">true</span>);<span style="color:#93a1a1;">//去噪处理，默认为false，不处理</span>
processOption.setNeedVacuate(<span style="color:#859900;">true</span>);<span style="color:#93a1a1;">//设置抽稀，仅在查询历史轨迹时有效，默认需要false</span>
processOption.setNeedMapMatch(<span style="color:#859900;">true</span>);<span style="color:#93a1a1;">//绑路处理，将点移到路径上，默认不需要false</span>
historyTrackRequest.setProcessOption(processOption);

<span style="color:#93a1a1;">/**
* 设置里程补偿方式，当轨迹中断5分钟以上，会被认为是一段中断轨迹，默认不补充
* 比如某些原因造成两点之间的距离过大，相距100米，那么在这两点之间的轨迹如何补偿
  SupplementMode.driving：补偿轨迹为两点之间最短驾车路线
  SupplementMode.riding：补偿轨迹为两点之间最短骑车路线
  SupplementMode.walking：补偿轨迹为两点之间最短步行路线
  SupplementMode.straight：补偿轨迹为两点之间直线
*/</span>
historyTrackRequest.setSupplementMode(SupplementMode.no_supplement);
historyTrackRequest.setSortType(SortType.asc);<span style="color:#93a1a1;">//设置返回结果的排序规则，默认升序排序；升序：集合中index=0代表起始点；降序：结合中index=0代表终点。</span>
historyTrackRequest.setCoordTypeOutput(CoordType.bd09ll);<span style="color:#93a1a1;">//设置返回结果的坐标类型，默认为百度经纬度</span>

<span style="color:#93a1a1;">/**
*设置是否返回纠偏后轨迹，默认不纠偏
 true：打开轨迹纠偏，返回纠偏后轨迹;
 false：关闭轨迹纠偏，返回原始轨迹。
 打开纠偏时，请求时间段内轨迹点数量不能超过2万，否则将返回错误。
*/</span>
historyTrackRequest.setProcessed(<span style="color:#859900;">true</span>);

<span style="color:#93a1a1;">//请求历史轨迹</span>
((BaseRequest)historyTrackRequest).setTag(tag);<span style="color:#93a1a1;">//设置请求标识，用于唯一标记本次请求，在响应结果中会返回该标识</span>
historyTrackRequest.setServiceId(serviceId);<span style="color:#93a1a1;">//设置轨迹服务id，Trace中的id</span>
historyTrackRequest.setEntityName(entityName);<span style="color:#93a1a1;">//Trace中的entityName</span>

<span style="color:#93a1a1;">/**
* 设置startTime和endTime，会请求这段时间内的轨迹数据;
* 这里查询采集开始到采集结束之间的轨迹数据
*/</span>
historyTrackRequest.setStartTime(startTime);
historyTrackRequest.setEndTime(endTime);

mClient.queryHistoryTrack(historyTrackRequest, mTrackListener);<span style="color:#93a1a1;">//发起请求，设置回调监听</span></code></code></pre> 
<p>7.历史轨迹数据回调<br><strong>注:当我们记录采集的起始时间，然后在查询这段时间内的点，画在地图上，可以实现用户运动结束后，一次性画出整个运动轨迹的功能</strong></p> 
<pre><code class="language-java">
<code><span style="color:#93a1a1;">//伪代码</span>
 <span style="color:#859900;">private</span> List&lt;LatLng&gt; trackPoints = <span style="color:#859900;">new</span> ArrayList&lt;&gt;();<span style="color:#93a1a1;">//轨迹点集合</span>

<span style="color:#93a1a1;">/**
* 轨迹监听器（用于接收历史轨迹回调）
*/</span>
<span style="color:#859900;">private</span> OnTrackListener mTrackListener = <span style="color:#859900;">new</span> OnTrackListener() {

     @Override
     <span style="color:#859900;">public</span> <span style="color:#859900;">void</span> <span style="color:#268bd2;">onHistoryTrackCallback</span>(HistoryTrackResponse response) {
        <span style="color:#93a1a1;">//如果觉得轨迹点可能过多，可以多次分页查询，详细代码参见源码</span>
        List&lt;TrackPoint&gt; points = response.getTrackPoints();<span style="color:#93a1a1;">//获取轨迹点</span>
        <span style="color:#859900;">for</span> (TrackPoint trackPoint : points) {
               <span style="color:#93a1a1;">//将轨迹点转化为地图画图层的LatLng类</span>
               trackPoints.add(MapUtil.convertTrace2Map(trackPoint.getLocation()));
        }
        <span style="color:#93a1a1;">//MapUtil封装了百度地图MapView和BaidumMap中的一些api</span>
        mapUtil.drawHistoryTrack(trackPoints, sortType);<span style="color:#93a1a1;">//将轨迹点画在地图上，对百度地图画图层不清楚的可以阅读偏头百度地图(三)文章</span>
     }

};</code></code></pre> 
<p>8.里程计算</p> 
<pre><code class="language-java">
<code>DistanceRequest distanceRequest = <span style="color:#859900;">new</span> DistanceRequest(tag, serviceId, entityName);
distanceRequest.setStartTime(startTime);<span style="color:#93a1a1;">// 设置开始时间</span>
distanceRequest.setEndTime(endTime);<span style="color:#93a1a1;">// 设置结束时间</span>
distanceRequest.setProcessed(<span style="color:#859900;">true</span>);<span style="color:#93a1a1;">// 纠偏</span>
ProcessOption processOption = <span style="color:#859900;">new</span> ProcessOption();<span style="color:#93a1a1;">// 创建纠偏选项实例</span>
processOption.setNeedDenoise(<span style="color:#859900;">true</span>);<span style="color:#93a1a1;">// 去噪</span>
processOption.setNeedMapMatch(<span style="color:#859900;">true</span>);<span style="color:#93a1a1;">// 绑路</span>
processOption.setTransportMode(TransportMode.walking);<span style="color:#93a1a1;">// 交通方式为步行</span>
distanceRequest.setProcessOption(processOption);<span style="color:#93a1a1;">// 设置纠偏选项</span>
distanceRequest.setSupplementMode(SupplementMode.no_supplement);<span style="color:#93a1a1;">// 里程填充方式为无</span>
mTraceClient.queryDistance(distanceRequest, mTrackListener);<span style="color:#93a1a1;">// 查询里程</span>

<span style="color:#93a1a1;">// 初始化轨迹监听器</span>
OnTrackListener mTrackListener = <span style="color:#859900;">new</span> OnTrackListener() {
    <span style="color:#93a1a1;">// 里程回调</span>
    @Override
    <span style="color:#859900;">public</span> <span style="color:#859900;">void</span> <span style="color:#268bd2;">onDistanceCallback</span>(DistanceResponse response) {
         <span style="color:#859900;">double</span> distance = response.getDistance()<span style="color:#93a1a1;">//里程，单位：米</span>
         <span style="color:#859900;">double</span> speed = distance/(endTime-startTime);<span style="color:#93a1a1;">//速度：m/s</span>
    }
};</code></code></pre> 
<h3 style="margin-left:0px;">三 动态时时画运动轨迹</h3> 
<pre><code class="language-java">
<code><span style="color:#93a1a1;">//伪代码</span>
<span style="color:#93a1a1;">/**
* 使用LatestPointRequest实现：查询服务端纠偏后的最新的点，在3中已经介绍了
* onLatestPointCallback此回调方法不仅可以画出当前的位置点，还可以将每一个最新纠偏后的点加入到位置点集合中，
  每返回一个点，就刷新一次轨迹图，这样就能动态画出轨迹了。
*/</span>

<span style="color:#93a1a1;">//接收纠偏后最新位置回调</span>
<span style="color:#859900;">private</span> OnTrackListener trackListener = <span style="color:#859900;">new</span> OnTrackListener() {
     @Override
     <span style="color:#859900;">public</span> <span style="color:#859900;">void</span> <span style="color:#268bd2;">onLatestPointCallback</span>(LatestPointResponse response) {
          <span style="color:#93a1a1;">//位置点的返回间隔时间为数据打包上传的频率 </span>
         LatestPoint point = response.getLatestPoint();
         LatLng currentLatLng = mapUtil.convertTrace2Map(point.getLocation());
         trackPoints.add(currentLatLng);
         mapUtil.drawHistoryTrack(trackPoints,<span style="color:#859900;">false</span>,mCurrentDirection);<span style="color:#93a1a1;">//显示当前位置，并时时动态的画出运动轨迹</span>
     }
};</code></code></pre> 
<p>动态轨迹效果图</p> 
<div style="margin-left:-40px;"> 
 <img alt="" src="https://images2.imgbox.com/36/3f/Ixibj4uS_o.png"> 
 <div style="margin-left:0px;">
   效果图 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/95c49eae11131d064416c4ef65c17eb1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python爬虫遇到URL错误解决办法大全</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a5a9d04fe683266fa28c49d5b3a6e099/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">对Autosar NM官方文档简单备注</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>