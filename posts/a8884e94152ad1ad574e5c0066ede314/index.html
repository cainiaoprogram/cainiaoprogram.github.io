<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[云原生k8s] k8s资源限制以及探针检查 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[云原生k8s] k8s资源限制以及探针检查" />
<meta property="og:description" content="一、资源限制 1.1、资源限制的使用 当定义Pod时可以选择性地为每个容器设定所需要的资源数量。最常见的可设定资源是CPU和内存大小，以及其他类型的资源。
1.2、request资源（请求）和limit资源（约束） 1.当为Pod中的指定了request资源时，调度器就使用该信息来决定将Pod调度到来哪一个节点中。当还未容器指定了limit资源时，kubelet就回确保运行的容器会不会使用超过所设置的limit资源量
2.如果Pod所在的节点具有足够的可用资源，容器可用使用超过所设置的request资源量。不过，容器不可以使用超过所设置的limit资源量。
3.如果给容器设置了内存的limit值，但未设置内存的request值，Kubernetes会自动为其设置于内存limit相匹配的request值。类似的，如果给容器设置了CPU的limit值但未设置CPU的request值，则Kubernetes自动为其设置CPU的request值，并使之与CPU的limit值匹配。
1.3、Pod和容器的资源请求和限制 定义创建容器时预分配的CPU资源 spec.containers[].resources.requests.cpu 定义创建容器时预分配的内存资源 spec.containers[].resources.requests.memory 定义创建容器时预分配的巨页资源 spec.containers[].resources.requests.hugepages-&lt;size&gt; 定义cpu的资源上限 spec.containers[].resources.limits.cpu 定义内存的资源上限 spec.containers[].resources.limits.memory 定义巨页的资源上限 spec.containers[].resources.limits.hugepages-&lt;size&gt; 1.4、官方文档示例 apiVersion: v1
kind: Pod
metadata:
name: frontend
spec:
containers:
- name: app
image: images.my-company.example/app:v4
env:
- name: MYSQL_ROOT_PASSWORD
value: &#34;password&#34;
resources:
requests:
memory: &#34;64Mi&#34;
cpu: &#34;250m&#34;
limits:
memory: &#34;128Mi&#34;
cpu: &#34;500m&#34;
- name: log-aggregator
image: images.my-company.example/log-aggregator:v6
resources:
requests:
memory: &#34;64Mi&#34;
cpu: &#34;250m&#34;
limits:
memory: &#34;128Mi&#34;
cpu: &#34;500m&#34;
此例子中Pod有两个Container。每个Container的请求为0.25cpu和64MiB（226字节）内存，每个容器的资源约束为0.5cpu和128MiB内存。你可以认为该Pod的资源请求为0.5cpu和128MiB内存，资源限制为1cpu和256MiB内存" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a8884e94152ad1ad574e5c0066ede314/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-15T08:55:40+08:00" />
<meta property="article:modified_time" content="2022-11-15T08:55:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[云原生k8s] k8s资源限制以及探针检查</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="%E4%B8%80%E3%80%81%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6">一、资源限制</h2> 
<p> </p> 
<h3 id="1.1%E3%80%81%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8"><a name="t1"></a>1.1、资源限制的使用</h3> 
<p>当定义Pod时可以选择性地为每个容器设定所需要的资源数量。最常见的可设定资源是CPU和内存大小，以及其他类型的资源。</p> 
<h3 id="1.2%E3%80%81request%E8%B5%84%E6%BA%90%EF%BC%88%E8%AF%B7%E6%B1%82%EF%BC%89%E5%92%8Climit%E8%B5%84%E6%BA%90%EF%BC%88%E7%BA%A6%E6%9D%9F%EF%BC%89">1.2、request资源（请求）和limit资源（约束）</h3> 
<p>1.当为Pod中的指定了request资源时，调度器就使用该信息来决定将Pod调度到来哪一个节点中。当还未容器指定了limit资源时，kubelet就回确保运行的容器会不会使用超过所设置的limit资源量</p> 
<p>2.如果Pod所在的节点具有足够的可用资源，容器可用使用超过所设置的request资源量。不过，容器不可以使用超过所设置的limit资源量。</p> 
<p>3.如果给容器设置了内存的limit值，但未设置内存的request值，Kubernetes会自动为其设置于内存limit相匹配的request值。类似的，如果给容器设置了CPU的limit值但未设置CPU的request值，则Kubernetes自动为其设置CPU的request值，并使之与CPU的limit值匹配。</p> 
<p></p> 
<h3 id="1.3%E3%80%81Pod%E5%92%8C%E5%AE%B9%E5%99%A8%E7%9A%84%E8%B5%84%E6%BA%90%E8%AF%B7%E6%B1%82%E5%92%8C%E9%99%90%E5%88%B6">1.3、Pod和容器的资源请求和限制</h3> 
<pre><code class="language-cs">定义创建容器时预分配的CPU资源
spec.containers[].resources.requests.cpu
定义创建容器时预分配的内存资源
spec.containers[].resources.requests.memory
定义创建容器时预分配的巨页资源
spec.containers[].resources.requests.hugepages-&lt;size&gt;
定义cpu的资源上限
spec.containers[].resources.limits.cpu
定义内存的资源上限
spec.containers[].resources.limits.memory
定义巨页的资源上限
spec.containers[].resources.limits.hugepages-&lt;size&gt;</code></pre> 
<h3> 1.4、官方文档示例</h3> 
<blockquote> 
 <p>apiVersion: v1<br> kind: Pod<br> metadata:<br>   name: frontend<br> spec:<br>   containers:<br>   - name: app<br>     image: images.my-company.example/app:v4<br>     env:<br>     - name: MYSQL_ROOT_PASSWORD<br>       value: "password"<br>     resources:<br>       requests:<br>         memory: "64Mi"<br>         cpu: "250m"<br>       limits:<br>         memory: "128Mi"<br>         cpu: "500m"<br>   - name: log-aggregator<br>     image: images.my-company.example/log-aggregator:v6<br>     resources:<br>       requests:<br>         memory: "64Mi"<br>         cpu: "250m"<br>       limits:<br>         memory: "128Mi"<br>         cpu: "500m"</p> 
</blockquote> 
<p> 此例子中Pod有两个Container。每个Container的请求为0.25cpu和64MiB（226字节）内存，每个容器的资源约束为0.5cpu和128MiB内存。你可以认为该Pod的资源请求为0.5cpu和128MiB内存，资源限制为1cpu和256MiB内存</p> 
<h3 id="1.5%E3%80%81%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E5%AE%9E%E6%93%8D">1.5、资源限制实操</h3> 
<h4 id="%E7%BC%96%E5%86%99yaml%E8%B5%84%E6%BA%90%E9%85%8D%E7%BD%AE%E6%B8%85%E5%8D%95"><a name="t6"></a>编写yaml资源配置清单</h4> 
<blockquote> 
 <p>[root@master ~]# mkdir /opt/test<br> [root@master ~]# cd !$<br> cd /opt/test<br> [root@master test]# vim test1.yaml<br>  <br> apiVersion: v1<br> kind: Pod<br> metadata:<br>   name: test1<br> spec:<br>   containers:<br>   - name: web<br>     image: nginx<br>     env:<br>     - name: WEB_ROOT_PASSWORD<br>       value: "password"<br>     resources:<br>       requests:<br>         memory: "64Mi"<br>         cpu: "250m"<br>       limits:<br>         memory: "128Mi"<br>         cpu: "500m"<br>   - name: db<br>     image: mysql<br>     env:<br>     - name: MYSQL_ROOT_PASSWORD<br>       value: "password"<br>     resources:<br>       requests:<br>         memory: "64Mi"<br>         cpu: "250m"<br>       limits:<br>         memory: "128Mi"<br>         cpu: "500m" </p> 
</blockquote> 
<h4 id="%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%EF%BC%88node%E8%8A%82%E7%82%B9%EF%BC%8C%E4%BB%A5node01%E4%B8%BA%E4%BE%8B%EF%BC%89">释放内存（node节点，以node01为例）</h4> 
<p>由于mysql对于内存的使用要求比较高，因此需要检查内存的可以的空间是否能够满足mysql的正常运行，若剩余内存不够，可对其进行释放操作。</p> 
<p><img alt="" height="663" src="https://images2.imgbox.com/0e/49/YvLN3Rlo_o.png" width="454"></p> 
<p><span style="color:#fe2c24;">查看内存</span></p> 
<pre><code>free -mh</code></pre> 
<p> <img alt="" height="81" src="https://images2.imgbox.com/ae/bc/6wMMDfag_o.png" width="818"></p> 
<p></p> 
<p>内存总量为4G，实际使用1.1G，因此可用内存应该为2.6G左右。</p> 
<p>但是由于有1.4G的内存被用于缓存，导致了free仅为1300M。</p> 
<p>1300M剩余可用内存显然是不够用的美因茨需要释放缓存。</p> 
<p><span style="color:#fe2c24;">手动释放缓存</span></p> 
<blockquote> 
 <p><span style="color:#0d0016;">echo [1\2\3] &gt; /proc/sys/vm/drop_caches</span></p> 
</blockquote> 
<pre><code class="language-cs">[root@master .pokemonsay]# free -mh
              total        used        free      shared  buff/cache   available
Mem:           3.7G        1.1G        600M         18M        2.0G        2.2G
Swap:            0B          0B          0B
[root@master .pokemonsay]# cat /proc/sys/vm/drop_caches
0
[root@master .pokemonsay]# echo 3 &gt; /proc/sys/vm/drop_caches
[root@master .pokemonsay]# free -mh
              total        used        free      shared  buff/cache   available
Mem:           3.7G        1.0G        2.1G         18M        549M        2.3G
Swap:            0B          0B          0B
[root@master .pokemonsay]#</code></pre> 
<p><img alt="" height="212" src="https://images2.imgbox.com/bf/e1/dbjLznuV_o.png" width="791"></p> 
<p>0：0是系统默认值，默认情况下表示不释放内存，由操作系统自动管理<br> 1：释放页缓存<br> 2：释放dentries和inodes<br> 3：释放所有缓存</p> 
<p>注意：</p> 
<p>如果因为是应用有像内存泄漏、溢出的问题，从swap的使用情况是可用比较快速判断的，但free上面的情况反而会比较难查看。相反，在这个时候，我们告诉用户，修改系统的一个值，“可以”释放内存，free就大了。用户会怎么想？不会觉得操作系统有问题吗？所以说，既然核心是可以快速清空buffer或cache，也就不难到（这从上面的操作中可以明显看到），但是核心并没有这么做（默认值是0），我们就不应该随便去改变</p> 
<p>一般情况下，应用在系统上稳定运行了，free值也会保持在一个稳定值，虽然看下去可能比较小。当发生内存不足、应用获取不到可用内存、OOM错误等问题时，还是更应该去分析应用方面的原因，如果用户量太大导致内存不足，发生应用内存溢出等情况，否则，清空buffer，强制腾出free得只是把问题给暂时屏蔽了。</p> 
<h4 id="%E5%88%9B%E5%BB%BA%E8%B5%84%E6%BA%90">创建资源</h4> 
<blockquote> 
 <p>kubectl apply -f test1.yaml</p> 
</blockquote> 
<p> <img alt="" height="52" src="https://images2.imgbox.com/dc/12/q1s5wJFQ_o.png" width="677"></p> 
<p></p> 
<h4 id="%E8%B7%9F%E8%B8%AA%E6%9F%A5%E7%9C%8Bpod%E7%8A%B6%E6%80%81">跟踪查看pod状态</h4> 
<pre><code>kubectl get pod -o wide -w</code></pre> 
<p><img alt="" height="682" src="https://images2.imgbox.com/45/4e/DuZRyqvX_o.png" width="1018"></p> 
<p> OOM（OverOfMemory）表示服务的运行超过了我们所设定的约束值。<br> Ready:2/2，status:Running说明该pod已成功创建并运行，但运行过程中发生OOM问题被kubelet杀死并重新拉起新的pod</p> 
<h4 id="%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8%E6%97%A5%E5%BF%97">查看容器日志</h4> 
<pre><code>kubectl logs test1 -c web</code></pre> 
<p><img alt="" height="320" src="https://images2.imgbox.com/c2/8a/QpeMPQFu_o.png" width="927"></p> 
<p> nginx启动正常，接下来查看mysql日志</p> 
<blockquote> 
 <p>kubectl logs test1 -c db</p> 
</blockquote> 
<p><img alt="" height="275" src="https://images2.imgbox.com/d5/96/jJk7VB4a_o.png" width="1027"></p> 
<p> 锁定问题容器为mysql</p> 
<h4 id="%E5%88%A0%E9%99%A4pod">删除pod</h4> 
<blockquote> 
 <p>kubectl delete -f test1.yaml</p> 
</blockquote> 
<p> <img alt="" height="42" src="https://images2.imgbox.com/06/ac/KRdTV8Yi_o.png" width="472"></p> 
<h4><strong> 修改yaml配置资源清单，提高mysql资源限制</strong></h4> 
<blockquote> 
 <p><strong>[root@master test]# vim test1.yaml  <br>  </strong><br> apiVersion: v1<br> kind: Pod<br> metadata:<br>   name: test1<br> spec:<br>   containers:<br>   - name: web<br>     image: nginx<br>     env:<br>     - name: WEB_ROOT_PASSWORD<br>       value: "password"<br>     resources:<br>       requests:<br>         memory: "64Mi"<br>         cpu: "250m"<br>       limits:<br>         memory: "128Mi"<br>         cpu: "500m"<br>   - name: db<br>     image: mysql<br>     env:<br>     - name: MYSQL_ROOT_PASSWORD<br>       value: "password"<br>     resources:<br>       requests:<br>         memory: "512Mi"<br>         cpu: "0.5"<br>       limits:<br>         memory: "1024Mi"<br>         cpu: "1"<br>  </p> 
</blockquote> 
<p><img alt="" height="59" src="https://images2.imgbox.com/ed/e0/lWOFKlUu_o.png" width="444"></p> 
<p> 再按照上述方法查看一下</p> 
<blockquote> 
 <p>kubectl get pod -o wide -w</p> 
</blockquote> 
<p></p> 
<p><img alt="" height="321" src="https://images2.imgbox.com/a5/73/1o1HndzL_o.png" width="1037"></p> 
<blockquote> 
 <p> kubectl describe pod test1<br> #查看pod的详细信息</p> 
</blockquote> 
<p> <img alt="" height="317" src="https://images2.imgbox.com/79/3d/5PKdiuvy_o.png" width="923"></p> 
<blockquote> 
 <p> kubectl describe node node01<br> #查看node1节点详细信息</p> 
</blockquote> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5">二、健康检查</h2> 
<h3 id="2.1%E3%80%81%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E7%9A%84%E5%AE%9A%E4%B9%89"><a name="t14"></a>2.1、健康检查的定义</h3> 
<p><img alt="" height="428" src="https://images2.imgbox.com/c4/84/ggS3olZe_o.png" width="861"></p> 
<p>  <strong>健康检查又称为探针（Probe），是由kubelet对容器执行的定期诊断。</strong></p> 
<h3 id="2.2%E3%80%81%E6%8E%A2%E9%92%88%E7%9A%84%E4%B8%89%E7%A7%8D%E8%A7%84%E5%88%99"><strong>2.2、探针的三种规则</strong></h3> 
<h4 id="livenessProbe%E5%AD%98%E6%B4%BB%E6%8E%A2%E9%92%88"><a name="t16"></a>livenessProbe存活探针</h4> 
<p>判断容器是否正在运行。如果探测失败，则kubelet会杀死容器，并且容器将根据restartPolicy来设置Pod状态，如果容器不提供存活探针，则默认状态为Success。</p> 
<h4 id="readinessProbe%E5%B0%B1%E7%BB%AA%E6%8E%A2%E9%92%88"><a name="t17"></a>readinessProbe就绪探针</h4> 
<p>判断容器是否准备好接受请求。如果探测失败，端点控制器将从与Pod匹配的所有service endpoints中剔除该Pod的IP地址。初始延迟之前的就绪状态默认为Failure。如果容器不提供就绪探针，则默认状态为Success。</p> 
<h4 id="startupProbe%E5%90%AF%E5%8A%A8%E6%8E%A2%E9%92%88%EF%BC%881.17%E7%89%88%E6%9C%AC%E6%96%B0%E5%A2%9E%EF%BC%89"><a name="t18"></a>startupProbe启动探针（1.17版本新增）</h4> 
<p>判断容器内的应用程序是否已启动，主要针对于不能确定具体启动时间的应用。如果匹配了startupProbe探针，则在startupProbe状态为Success之前，其他所有探针都处于无效状态，直到它成功后才起作用。如果startupProbe，则默认状态为Success。</p> 
<h4 id="%E5%90%8C%E6%97%B6%E5%AE%9A%E4%B9%89"><a name="t19"></a>同时定义</h4> 
<p>以上三种规则可同时定义。在readinessProbe检测成功之前，Pod的running状态是不会变成ready状态的。</p> 
<h3 id="2.3%E3%80%81Probe%E6%94%AF%E6%8C%81%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A3%80%E6%B5%8B%E6%96%B9%E6%B3%95">2.3、Probe支持的三种检测方法</h3> 
<h4 id="exec"><a name="t21"></a>exec</h4> 
<p>在容器内执行命令，如果容器退出时反码为0则认为诊断成功。</p> 
<h4 id="tcpSocket"><a name="t22"></a>tcpSocket</h4> 
<p>对指定端口上的容器的IP地址执行httpGet请求。如果响应的状态码大于等于200且小于400（2xx和3xx），则诊断被认为是成功的</p> 
<h3 id="2.4%E3%80%81%E6%8E%A2%E6%B5%8B%E7%BB%93%E6%9E%9C">2.4、探测结果</h3> 
<p>每次探测都将获得以下三种结果之一：</p> 
<ul><li>成功：容器通过了诊断</li><li>失败：容器未通过诊断</li><li>未知：诊断失败，因此不会采取任何行动</li></ul> 
<h3 id="2.5%E3%80%81exec%E6%96%B9%E5%BC%8F">2.5、exec方式</h3> 
<pre><code class="language-cs">vim exec.yaml
 
apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness				#为了健康检查定义的标签
  name: liveness-exec
spec:						#定义了Pod中containers的属性
  containers:
  - name: liveness
    image: busybox
    args:						#传入的命令
    - /bin/sh
    - -c
    - touch /tmp/healthy; sleep 30; rm -rf /tmp/healthy;sleep 600
    livenessProbe:
      exec:
        command:
        - cat
        - /tmp/healthy
      initialDelaySeconds: 5			#表示pod中容器启动成功后，多少秒后进行健康检查 
      periodSeconds: 5				#在首次健康检查后，下一次健康检查的间隔时间 5s</code></pre> 
<p><strong>在配置文件中，可以看到Pod具有单个Container。该perioSeconds字段指定kubelet应该每5秒执行一次活动性探测。该initiaDelaySeconds字段告诉kubelet在执行第一个探测之前应该等待5秒。为了执行探测，kubelet cat /tmp/healthy在容器中执行命令。如果命令成功执行，则返回0，并且kubelet认为Container仍然重要。如果命令返回非0值，则kubelet将杀死Container并重启它。</strong></p> 
<ol><li>在这个配置文件中，可以看到Pod只有一个容器。</li><li>容器中的command字段表示创建一个/tmp/live文件后休眠30秒，休眠结束后删除该文件，并休眠10分钟。</li><li>仅使用livenessProbe存活探针，并使用exec检查方式，对/tmp/live文件进行存活检测。</li><li>initialDelaySeconds字段表示kubelet在执行第一次探测前应该等待5秒。</li><li>periodSeconds字段表示kubelet每隔5秒执行一次存活探测。<img alt="" height="373" src="https://images2.imgbox.com/1d/29/u1Q2HODD_o.png" width="706"></li></ol> 
<h3> 2.6、httpGet方式</h3> 
<blockquote> 
 <p>apiVersion: v1<br> kind: Pod<br> metadata:<br>   labels:<br>     test: liveness<br>   name: liveness-http<br> spec:<br>   containers:<br>   - name: liveness<br>     image: k8s.gcr.io/liveness<br>     args:<br>     - /server<br>     livenessProbe:<br>       httpGet:<br>         path: /healthz<br>         port: 8080<br>         httpHeaders:<br>         - name: Custom-Header<br>           value: Awesome<br>       initialDelaySeconds: 3<br>       periodSeconds: 3</p> 
 <p></p> 
</blockquote> 
<p> <strong>在配置文件中，可以看到Pod具有单个Container。该periodSeconds字段指定kubectl应该每3秒执行一次活动性探测。该initiaDelaySeconds字段告诉kubelet在执行第一个探测之前应等待3秒。为了执行探测，kubectl将HTTP GET请求发送到Container中运行并在端口8080上侦听的服务器。如果服务器/healthz路径的处理程序返回成功代码，则kubectl会认为任何大于或等于400的代码均表示成功，其他代码都表示失败。</strong></p> 
<p><img alt="" height="525" src="https://images2.imgbox.com/db/01/Y2B8hDGM_o.png" width="775"></p> 
<p></p> 
<h3 id="2.7%E3%80%81tcpSocket%E6%96%B9%E5%BC%8F">2.7、tcpSocket方式</h3> 
<p>定义TCP活动度探针</p> 
<p>第三种类型的活动性探针使用TCP套接字，使用此配置，kubelet将尝试在指定端口上打开容器的套接字。如果可以建立连接，则认为该让其运行状况良好，如果不能，则认为该容器是故障容器。</p> 
<blockquote> 
 <p> apiVersion: v1<br> kind: Pod<br> metadata:<br>   name: goproxy<br>   labels:<br>     app: goproxy<br> spec:<br>   containers:<br>   - name: goproxy<br>     image: k8s.gcr.io/goproxy:0.1<br>     ports:<br>     - containerPort: 8080<br>     readinessProbe:<br>       tcpSocket:<br>         port: 8080<br>       initialDelaySeconds: 5<br>       periodSeconds: 10<br>     livenessProbe:<br>       tcpSocket:<br>         port: 8080<br>       initialDelaySeconds: 15<br>       periodSeconds: 20</p> 
</blockquote> 
<p></p> 
<p>如图所示，TCP检查的配置与HTTP检查非常相似，此示例同时使用就绪和活跃度探针，容器启动5秒后，kubelet将发送第一个就绪探测器。这些尝试连接到goproxy端口8080上的容器。如果探测成功，则容器将标记为就绪，kubelet将继续每10秒运行一次检查。</p> 
<p>除了就绪探针之外，此配置还包括活动探针。容器启动后15秒钟，kubelet将运行第一个活动谈着，就像就绪探针一样，这些尝试goproxy在端口8080上连接到容器。如果活动探针失败，则容器将重新启动。</p> 
<h2 id="%E6%80%BB%E7%BB%93">总结</h2> 
<h3 id="1.%20%E6%8E%A2%E9%92%88"><a name="t28"></a>1. 探针</h3> 
<p>探针分为3种</p> 
<p>livenessProbe（存活探针）∶判断容器是否正常运行，如果失败则杀掉容器（不是pod），再根据重启策略是否重启容器<br> readinessProbe（就绪探针）∶判断容器是否能够进入ready状态，探针失败则进入noready状态，并从service的endpoints中剔除此容器<br> startupProbe∶判断容器内的应用是否启动成功，在success状态前，其它探针都处于无效状态</p> 
<h3>2. 检查方式</h3> 
<p>检查方式分为3种</p> 
<p>exec∶使用 command 字段设置命令，在容器中执行此命令，如果命令返回状态码为0，则认为探测成功<br> httpget∶通过访问指定端口和url路径执行http get访问。如果返回的http状态码为大于等于200且小于400则认为成功<br> tcpsocket∶通过tcp连接pod（IP）和指定端口，如果端口无误且tcp连接成功，则认为探测成功</p> 
<h3 id="3.%20%E5%B8%B8%E7%94%A8%E7%9A%84%E6%8E%A2%E9%92%88%E5%8F%AF%E9%80%89%E5%8F%82%E6%95%B0"><a name="t30"></a>3. 常用的探针可选参数</h3> 
<p>常用的探针可选参数有4个</p> 
<p>initialDelaySeconds∶ 容器启动多少秒后开始执行探测<br> periodSeconds∶探测的周期频率，每多少秒执行一次探测<br> failureThreshold∶探测失败后，允许再试几次<br> timeoutSeconds ∶ 探测等待超时的时间 </p> 
<h3 id="4%E3%80%81%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5"><a name="t31"></a>4、重启策略</h3> 
<p>Pod在遇到故障之后“重启”的动作Pod在遇到故障之后“重启”的动作</p> 
<p>Always：当容器终止退出后，总是“重启”容器，默认策略</p> 
<p>OnFailure：当容器异常退出（退出状态码非0）时，重启容器</p> 
<p>Never：当容器终止退出，从不“重启”容器。</p> 
<p>（注意：k8s中不支持重启Pod资源，只有删除重建，重建）</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fea4df0e4786974844c09789e7b0525b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">C语言飞机大战</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f8ad6906ec306790619088a98aecd427/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【javaweb】javabean-四则运算</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>