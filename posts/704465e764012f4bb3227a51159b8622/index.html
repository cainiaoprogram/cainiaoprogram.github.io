<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>探索性空间数据分析的相关信息解释 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="探索性空间数据分析的相关信息解释" />
<meta property="og:description" content="1.引言 这篇帖子内容有关arcmap地图绘制和局部空间自相关等等，希望可以帮助到你，先发布，后续会完善 2.新版白话空间统计（46）局部莫兰指数计算原理与操作篇（GeoDa版）（转自虾神说D公众号，极力推荐大家关注他） 2.1前言 我们在新版白话空间统计第44节，展示过这样一张图：
用四个象限来表示LISA的结果划分，今天我们具体来讲讲如何计算LISA也就是详细讲讲如何计算这个坐标轴上的空间滞后值和标准化（观测）值。
（PS：LISA是Local Indicators of Spatial Association的简写，是anselin在1995年提出的一种方法论，里面用到的模型，就是local moran&#39;s i）
首先我们先来看这个笛卡尔坐标系的X轴和Y轴。
X轴是标准化之后的观测值，标准化的方法有很多，而这里用的是z-score标准化（zero-mena normalization，此方法最为常用的标准化方法）。
用官方的说法：多指标评价体系中，由于各评价指标的性质不同，通常具有不同的量纲和数量级。当各指标间的水平相差很大时，如果直接用原始指标值进行分析，就会突出数值较高的指标在综合分析中的作用，相对削弱数值水平较低指标的作用。因此，为了保证结果的可靠性，需要对原始指标数据进行标准化处理。
数据的标准化(normalization)是将数据按比例缩放，使之落入一个小的特定区间。在某些比较和评价的指标处理中经常会用到，去除数据的单位限制，将其转化为无量纲的纯数值，便于不同单位或量级的指标能够进行比较和加权。
Z-Score标准化的方法非常简单，公式如下：
Z-Score标准化 = (要标准化的值（观测值） - 平均值) / 标准差
z-score标准化方法适用于属性A的最大值和最小值未知的情况，或有超出取值范围的离群数据的情况。
而Y轴表示的是空间滞后值（何为空间滞后值，我们在下篇中会详细说明），即该要素的相邻要素的所有ZScore标准化观测值的空间加权平均。
为了验证我们的理解对不对，可以直接用Excel来计算，来与GeoDa计算的结果进行对比，对比如下：
用Excel，对我们要计算的字段，进行ZScore标准化，可以得到如下结果：
然后利用Queen&#39;s Case的空间关系矩阵，求空间滞后值（因为太多了，所以我示例性的求其中一个就行）：
比如求北京的空间滞后值，空间权重矩阵如下：
北京有两个邻居，分别是河北和天津，计算北京的空间滞后值，算法如下：
北京的空间滞后值 = 累加 (邻居的观测值的ZScroe标准化值 * 权重）/ 邻居的数量
其实也就是，也就是求了空间关系加权之后的平均值
我们的空间权重矩阵用的是queen&#39;s case，那么所有的邻居权重都是一样的，直接计算平均值就可以了：
北京的空间滞后值 = (-0.490978428[天津的zscore] * 1[天津对北京的空间关系加权] &#43; 0.242135744[河北的zscroe] * 1[河北对北京的空间关系加权]）/ 2 = -0.124421342
依此把所有的数据都算一遍，就可以得到所有要素的Zscroe和空间滞后值，然后，只要有两个值，就构成了X轴和Y轴，就可以绘制出散点图来了。
注意，大家在测试的时候，如果计算的结果和我不同，切记看这里：
如果用默认的空间权重矩阵，海南没有邻居，是不会参与计算的，所以你在手动计算平均值和标准差的时候，需要把海南排除掉。（有同学问，如果我要加入海南呢？答案是需要自定义修改空间权重矩阵，参考以前的文章）
新版白话空间统计（18）空间关系概念化之Geoda的面邻接构建及自定义
下面，我们用GeoDa来做局部莫兰指数，并且把值添加到属性里面，为什么要用GeoDa？因为ArcGIS不支持把计算保存计算出来的ZScore标准化值和空间滞后值，要看这两个值，只能用GeoDa（R语言和Python也行，以后有空说）。
2.2GeoDa进行局部莫兰指数分析，并且获得数值的完整操作流程： STEP1:打开GeoDa软件之后，在连接数据源界面点击选择文件后面的打开按钮，选择我们需要打开的数据，这里我们需要打开shape file，所以选择第一项即可。
STEP2:
找到我们需要打开的Shapefile
STEP 3:在计算之前，需要先定义空间权重矩阵，所以在工具栏上选择空间权重管理：
STEP 4:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/704465e764012f4bb3227a51159b8622/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-25T12:01:48+08:00" />
<meta property="article:modified_time" content="2023-04-25T12:01:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">探索性空间数据分析的相关信息解释</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<h2>1.引言</h2> 
<h2>这篇帖子内容有关arcmap地图绘制和局部空间自相关等等，希望可以帮助到你，先发布，后续会完善</h2> 
<p> </p> 
<p></p> 
<h2 id="2.%E6%96%B0%E7%89%88%E7%99%BD%E8%AF%9D%E7%A9%BA%E9%97%B4%E7%BB%9F%E8%AE%A1%EF%BC%8846%EF%BC%89%E5%B1%80%E9%83%A8%E8%8E%AB%E5%85%B0%E6%8C%87%E6%95%B0%E8%AE%A1%E7%AE%97%E5%8E%9F%E7%90%86%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%AF%87%EF%BC%88GeoDa%E7%89%88%EF%BC%89%EF%BC%88%E8%BD%AC%E8%87%AA%E8%99%BE%E7%A5%9E%E8%AF%B4D%E5%85%AC%E4%BC%97%E5%8F%B7%EF%BC%8C%E6%9E%81%E5%8A%9B%E6%8E%A8%E8%8D%90%E5%A4%A7%E5%AE%B6%E5%85%B3%E6%B3%A8%E4%BB%96%EF%BC%89" style="margin-left:0px;text-align:left;">2.新版白话空间统计（46）局部莫兰指数计算原理与操作篇（GeoDa版）（转自虾神说D公众号，极力推荐大家关注他）</h2> 
<h3 id="2.1%E5%89%8D%E8%A8%80">2.1前言</h3> 
<p>我们在新版白话空间统计第44节，展示过这样一张图：</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="558" src="https://images2.imgbox.com/51/27/PT1SmfZM_o.png" width="815"></p> 
<p style="margin-left:0;text-align:justify;">用四个象限来表示LISA的结果划分，今天我们具体来讲讲如何计算LISA也就是详细讲讲如何计算这个坐标轴上的空间滞后值和标准化（观测）值。<br> （PS：<strong><span style="color:#ab1942;">LISA</span></strong>是<strong><span style="color:#0052ff;">Local Indicators of Spatial Association</span></strong>的简写，是anselin在1995年提出的一种方法论，里面用到的模型，就是local moran's i）<br><br> 首先我们先来看这个笛卡尔坐标系的X轴和Y轴。<br><strong><span style="color:#ab1942;">X</span></strong><strong><span style="color:#ab1942;">轴是标准化之后的观测值</span></strong>，标准化的方法有很多，而这里用的是<strong><span style="color:#ab1942;">z-score</span><span style="color:#ab1942;">标准化</span></strong>（zero-mena normalization，此方法最为常用的标准化方法）。<br> 用官方的说法：多指标评价体系中，由于各评价指标的性质不同，通常具有不同的量纲和数量级。当各指标间的水平相差很大时，如果直接用原始指标值进行分析，就会突出数值较高的指标在综合分析中的作用，相对削弱数值水平较低指标的作用。因此，为了<span style="color:#ab1942;">保证结果的可靠性</span>，需要对原始指标数据进行<span style="color:#ab1942;">标准化处理</span>。</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="349" src="https://images2.imgbox.com/ea/5e/5SG7rIAh_o.png" width="472"></p> 
<p style="margin-left:0;text-align:justify;"><br> 数据的标准化(normalization)是将数据<strong><span style="color:#ab1942;">按比例缩放</span></strong>，使之落入一个小的特定区间。在某些比较和评价的指标处理中经常会用到，去除数据的单位限制，将其转化为无量纲的纯数值，便于不同单位或量级的指标能够进行比较和加权。<br> Z-Score标准化的方法非常简单，公式如下：<br><strong><span style="color:#ab1942;">Z-Score</span></strong><strong><span style="color:#ab1942;">标准化 = (要标准化的值（观测值） -  平均值) / 标准差</span></strong><br> z-score标准化方法适用于属性A的最大值和最小值未知的情况，或有超出取值范围的离群数据的情况。<br> 而<strong><span style="color:#ab1942;">Y</span><span style="color:#ab1942;">轴表示的是空间滞后值</span></strong>（何为空间滞后值，我们在下篇中会详细说明），即<strong><span style="color:#0052ff;">该要素的相邻要素的所有ZScore标准化观测值的空间加权平均</span></strong>。<br> 为了验证我们的理解对不对，可以直接用Excel来计算，来与GeoDa计算的结果进行对比，对比如下：<br> 用Excel，对我们要计算的字段，进行ZScore标准化，可以得到如下结果：</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="466" src="https://images2.imgbox.com/00/46/MYKeh9yi_o.png" width="695"></p> 
<p style="margin-left:0;text-align:justify;"><br> 然后利用<strong><span style="color:#ab1942;">Queen's Case</span></strong>的空间关系矩阵，求空间滞后值（因为太多了，所以我示例性的求其中一个就行）：<br> 比如求北京的空间滞后值，空间权重矩阵如下：</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="210" src="https://images2.imgbox.com/67/36/9hbUdbQO_o.png" width="383"></p> 
<p style="margin-left:0;text-align:justify;">北京有两个邻居，分别是河北和天津，计算北京的空间滞后值，算法如下：<br><strong><span style="color:#ab1942;">北京的空间滞后值 = 累加 (邻居的观测值的ZScroe标准化值 * 权重）/ 邻居的数量</span></strong><br> 其实也就是，也就是求了空间关系加权之后的平均值<br> 我们的空间权重矩阵用的是queen's case，那么所有的邻居权重都是一样的，直接计算平均值就可以了：<br>  </p> 
<p style="margin-left:0;text-align:justify;"><strong><span style="color:#ab1942;">北京的空间滞后值 </span></strong></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#0052ff;">= (<strong>-0.490978428</strong></span><em><span style="color:#0052ff;">[</span></em><em><span style="color:#0052ff;">天津的zscore]</span></em><span style="color:#0052ff;"> * <strong>1</strong></span><em><span style="color:#0052ff;">[</span></em><em><span style="color:#0052ff;">天津对北京的空间关系加权]</span></em> </p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#0052ff;">+<strong> 0.242135744</strong></span><em><span style="color:#0052ff;">[</span></em><em><span style="color:#0052ff;">河北的zscroe]</span></em><span style="color:#0052ff;"> * <strong>1</strong></span><em><span style="color:#0052ff;">[</span></em><em><span style="color:#0052ff;">河北对北京的空间关系加权]</span></em><span style="color:#0052ff;">）/ <strong>2 </strong></span></p> 
<p style="margin-left:0;text-align:justify;"><span style="color:#0052ff;">= <strong>-0.124421342</strong></span></p> 
<p style="margin-left:0;text-align:justify;"><br> 依此把所有的数据都算一遍，就可以得到所有要素的Zscroe和空间滞后值，然后，只要有两个值，就构成了X轴和Y轴，就可以绘制出散点图来了。<br> 注意，大家在测试的时候，如果计算的结果和我不同，切记看这里：</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="157" src="https://images2.imgbox.com/19/ff/jH7eu91c_o.png" width="348"></p> 
<p style="margin-left:0;text-align:justify;">如果用<strong><span style="color:#ab1942;">默认的</span></strong>空间权重矩阵，海南没有邻居，是不会参与计算的，所以你在手动计算平均值和标准差的时候，需要把海南排除掉。（有同学问，如果我要加入海南呢？答案是需要<strong><span style="color:#ab1942;">自定义修改空间权重矩阵</span></strong>，参考以前的文章）<br><a href="http://mp.weixin.qq.com/s?__biz=MzA4ODk4NzgyNA==&amp;mid=2649737168&amp;idx=1&amp;sn=7fc7149963e0b068893f1a8a49c93b78&amp;chksm=883aa60fbf4d2f19932a646b8a4ea23343d420c6229b2cf0a45d2f51af196887b773118ba0db&amp;scene=21#wechat_redirect" rel="nofollow" title="新版白话空间统计（18）空间关系概念化之Geoda的面邻接构建及自定义">新版白话空间统计（18）空间关系概念化之Geoda的面邻接构建及自定义</a><br><br><br>  </p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="501" src="https://images2.imgbox.com/82/05/kOzWxeSN_o.png" width="500"></p> 
<p style="margin-left:0;text-align:justify;"><br> 下面，我们用<strong><span style="color:#ab1942;">GeoDa</span></strong>来做局部莫兰指数，并且把值添加到属性里面，为什么要用GeoDa？因为<span style="color:#0052ff;">ArcGIS</span><span style="color:#0052ff;">不支持把计算保存计算出来的ZScore标准化值和空间滞后值</span>，要看这两个值，只能用GeoDa（R语言和Python也行，以后有空说）。</p> 
<h3 id="2.2GeoDa%E8%BF%9B%E8%A1%8C%E5%B1%80%E9%83%A8%E8%8E%AB%E5%85%B0%E6%8C%87%E6%95%B0%E5%88%86%E6%9E%90%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%8E%B7%E5%BE%97%E6%95%B0%E5%80%BC%E7%9A%84%E5%AE%8C%E6%95%B4%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B%EF%BC%9A" style="margin-left:0px;text-align:justify;"><br> 2.2GeoDa进行局部莫兰指数分析，并且获得数值的完整操作流程：</h3> 
<p style="margin-left:0;text-align:justify;">STEP1:打开GeoDa软件之后，在连接数据源界面点击选择文件后面的打开按钮，选择我们需要打开的数据，这里我们需要打开shape file，所以选择第一项即可。<img alt="" height="556" src="https://images2.imgbox.com/27/13/1ocK27VP_o.jpg" width="890"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP2:</p> 
<p style="margin-left:0;text-align:justify;">找到我们需要打开的Shapefile</p> 
<p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP 3:在计算之前，需要先定义空间权重矩阵，所以在工具栏上选择空间权重管理：</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="491" src="https://images2.imgbox.com/e0/82/ANvGvoRT_o.png" width="585"></p> 
<p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP 4:</p> 
<p style="margin-left:0;text-align:justify;">点击创建</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="483" src="https://images2.imgbox.com/81/c4/XxpzaqcZ_o.jpg" width="376"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP5:</p> 
<p style="margin-left:0;text-align:left;">选择ID（必须是唯一值，而且是整数或者字符串），在GeoDa的新版本里面，支持用字符串类型定义，我们这里选择CNPG_S_Cod，这个字段是各省的行政区划编码。</p> 
<p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0;text-align:left;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP6:</p> 
<p style="margin-left:0;text-align:justify;">选择Queen连接（共点共边即相邻），秩选1（默认）就行，因为我们不需要进行二阶邻域计算。</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="711" src="https://images2.imgbox.com/fc/64/q9djIQMH_o.jpg" width="530"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP7:</p> 
<p style="margin-left:0;text-align:justify;">点击创建的时候，会让你保存空间权重矩阵文件。</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="531" src="https://images2.imgbox.com/61/45/qsGliHdv_o.jpg" width="952"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP8:</p> 
<p style="margin-left:0;text-align:justify;">保存之后，会弹出一个警告（这是因为海南、台湾两地出现无相邻的要素），不用管，直接点击确定，然后会提示创建成功的对话框。</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="124" src="https://images2.imgbox.com/fe/4e/w2vvlskl_o.jpg" width="366"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP9:</p> 
<p style="margin-left:0;text-align:justify;">可以点击直方图或者连通图看目前的空间权重矩阵，也可以直接点击右上角的叉，关闭空间权重管理窗口。</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="485" src="https://images2.imgbox.com/74/9e/nMSTA4hc_o.jpg" width="369"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP10:</p> 
<p style="margin-left:0;text-align:justify;">接下去做局部莫兰指数，在下拉菜单找到空间分析——单变量局部Moran's I：</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="494" src="https://images2.imgbox.com/fc/86/JQC5YQZW_o.jpg" width="585"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP11:</p> 
<p style="margin-left:0;text-align:justify;">选择要进行莫兰指数分析的字段“GDP2018”，下面选择我们的空间权重，如果只有一个，就是默认的，如果定义了多个，可以切换选择。</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="374" src="https://images2.imgbox.com/ef/fc/lBt6DTgx_o.jpg" width="286"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP12:点击确定的时候，会问你结果用什么方式显示，我们可以把下面两个都选上，即聚类地图和Moran散点图，选择之后点击确定。</p> 
<p style="margin-left:0;text-align:center;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP13:</p> 
<p style="margin-left:0;text-align:justify;">此时可以看见莫兰散点图与LISA聚类地图了：</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="365" src="https://images2.imgbox.com/14/06/tcCUOqJG_o.png" width="1080"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP14:</p> 
<p style="margin-left:0;text-align:justify;">下面我们把值保存到数据里面去，首先在散点图上面，点击鼠标右键，弹出功能菜单，并且选择保存结果：</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="391" src="https://images2.imgbox.com/b5/be/aAKRjGDa_o.jpg" width="585"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP15:</p> 
<p style="margin-left:0;text-align:justify;">在保存结果窗体中，把标准化数据和空间滞后两个复选框都选上，点击确定。</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="393" src="https://images2.imgbox.com/2a/4e/L7PtpxPj_o.jpg" width="588"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP16:</p> 
<p style="margin-left:0;text-align:justify;">然后在工具栏上点击表格工具图标，打开数据属性表。</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="431" src="https://images2.imgbox.com/d5/d5/VEKLRZH9_o.jpg" width="620"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP17:</p> 
<p style="margin-left:0;text-align:justify;">这时候，就可以看见计算出来的标准化数据和空间滞后值了。</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="489" src="https://images2.imgbox.com/87/36/6l6X9xqo_o.jpg" width="735"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP18:我们可以来对比一下，GeoDa计算出来的，和我们用Excel计算出来的结果，可以看见基本上是一致的（细节数值的不同，是因为计算的时候，Excel和GeoDa二者之间，保留的小数位不一致导致的）。<br>  </p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="494" src="https://images2.imgbox.com/77/4c/u1p2KqB7_o.jpg" width="733"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP19:同样，我们可以把局部莫兰指数也保存下来。<br>  </p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="389" src="https://images2.imgbox.com/08/56/cGvXqfsD_o.png" width="585"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP20:</p> 
<p style="margin-left:0;text-align:justify;">全部选择之后，点击确定</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="400" src="https://images2.imgbox.com/b6/48/GxW9Gxn5_o.jpg" width="600"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">STEP21:</p> 
<p style="margin-left:0;text-align:justify;">打开属性表，就可以看见多了三个字段，分别是具备莫兰指数、聚类与异常值标识以及P值。</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="490" src="https://images2.imgbox.com/b2/ce/1VbMbNSu_o.jpg" width="891"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;"></p> 
<p style="margin-left:0;text-align:justify;">注意，这里的聚类与异常值里面的数值，代表的是象限，另外因为计算机是从0开始计数的，所以结果就是0123——实际上应该是需要加1：分别表示<strong><span style="color:#ab1942;">第一二三四象限</span></strong>。</p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="534" src="https://images2.imgbox.com/6c/5a/QNFzuG85_o.png" width="669"></p> 
<p style="margin-left:0;text-align:justify;">最后，局部莫兰指数的值是怎么算出来的呢？<br> 非常简单，直接用<strong><span style="color:#ab1942;">标准化值乘以空间滞后值</span></strong>即可，比如：<br> 北京的局部莫兰指数= -0.000386 * -0.12233 = </p> 
<p style="margin-left:0;text-align:center;"><img alt="" height="694" src="https://images2.imgbox.com/56/fd/RZREiwLP_o.png" width="864"></p> 
<p style="margin-left:0;text-align:justify;">2.</p> 
<p></p> 
<h2 id="3.%E6%A0%B8%E5%AF%86%E5%BA%A6%E4%BC%B0%E8%AE%A1%E6%9B%B2%E7%BA%BF%E5%88%86%E6%9E%90">3.核密度估计曲线分析</h2> 
<p>（1）“峰”越高，表示此处数据越“密集”。</p> 
<p>（2）kernel曲线向右移动：XX水平不断提高。</p> 
<p>（3）分布形态：右尾拉长，表示差异增加。</p> 
<p>        第三,右拖尾存在逐年拉长现象,分布延展性在一定程度存在拓宽趋势,意味着全国范围内全要素能源效率的空间差距在逐步扩大。</p> 
<p>（4）多峰：多峰形态明显，说明多极分化现象。双峰向单峰过渡，说明两极分化现象在减弱。</p> 
<p>（5）扁而宽的核密度曲线（峰值降低、宽度加大）：各省份差异程度变大。</p> 
<p>（6）若核密度曲线图中, 波形向左移动 (呈右偏态分布) 、波峰垂直高度上升、水平宽度减小、波峰数量减小, 则表明其核密度趋于向数值减小的方向移动, 即该地区农业碳排放地区差距呈缩小态势, 存在动态收敛性特征。</p> 
<p></p> 
<h2 id="4.%E5%9C%B0%E7%90%86%E6%8E%A2%E6%B5%8B%E5%99%A8%E5%85%A8%E6%96%87%E8%AF%A6%E7%BB%86">4.地理探测器全文详细</h2> 
<p>来源：<a href="https://zhuanlan.zhihu.com/p/612857034" rel="nofollow" title="地理探测器(GeoDetector)原理及其实现 - 知乎 (zhihu.com)">地理探测器(GeoDetector)原理及其实现 - 知乎 (zhihu.com)</a></p> 
<h3 id="h_612857034_0">4.1、地理探测器原理与功能</h3> 
<h4 id="h_612857034_1">4.1.1 用途与目的</h4> 
<p>地理学第二定律的核心思想是地理现象的空间（分层）异质性，其普遍存在于各种地理现象中。</p> 
<p>空间分层异质性（spatial stratified heterogeneity），层内方差小于层间方差的地理现象。即同一地理现象在同一子区域内表现出相似性，但在不同子区域间的分布呈现差异性，例如土地类型、气候分区等。此处，层（strat）是统计学上的概念，对应地理学可理解为子区域。</p> 
<p>地理探测器是探测空间分异性以及揭示其背后驱动力的空间分析方法，被广泛用于进行驱动力分析和因子分析。其核心思想是基于这样的假设：如果某个自变量对某个因变量有重要影响，那么自变量和因变量的空间分布应该具有相似性。地理分异可以利用地理探测器进行统计分析，其有两大优势：一是地理探测器既可以探测数值型数据，也可以探测定性数据；二是可以探测两因子交互作用于因变量。地理探测器通过分别计算和比较各单因子q值及两因子叠加后的q值，可以判断两因子是否存在交互作用，以及交互用用的强弱、方向、线性还是非线性等。两因子叠加既包括相乘关系，也包括其他关系，只要有关系，就能检验出来。</p> 
<p>ref : 王劲峰,徐成东.地理探测器:原理与展望[J].地理学报,2017,72(01):116-134.</p> 
<h4 id="h_612857034_2">4.1.2 功能原理</h4> 
<p>地理探测器用于分析空间分层异质性，主要包括4个探测器（因子探测器、交互作用探测器、风险区探测器、生态探测器），分析结果可分别回答以下问题：</p> 
<p>（1）是否存在空间异质性？什么因素造成了这种分层异质性？</p> 
<p>（2）变量Y是否存在显著的区际差别？</p> 
<p>（3）因素X之间的相对重要性如何？</p> 
<p>（4）因素X对于因素Y是独立起作用还是具有广义的交互作用？</p> 
<ul><li>分异及因子探测</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/99/f9/CIk5yKfo_o.jpg"></p> 
<p>因子探测旨在探测Y的空间分异性以及探测某因子X多大程度上解释了属性Y的空间分异，用q值度量(Wang et al.,2010b)，表达式为：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/15/e9/2wH6RRVJ_o.jpg"></p> 
<p>式中：h = 1， …, L为变量Y或因子X的分层，即分类或分区；Nh和N分别为层h和全区的单元数；σ2h和 σ2分别是层h和全区的Y值的方差。SSW和SST分别为层内方差之和（Within Sum of Squares）和全区总方差（Total Sum of Squares）。</p> 
<p>q的值域为[0, 1]，值越大说明Y的空间分异性越明显；如果分层是由自变量X生成的，则q值越大表示自变量X对属性Y的解释力越强，反之则越弱。极端情况下，q值为1表明因子X完全控制了Y的空间分布，q值为0则表明因子X与Y没有任何关系，q值表示X解释了100xq%的Y。</p> 
<p>q值的一个简单变换满足非中心F分布：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f2/25/kL3jr0Cb_o.jpg"></p> 
<p>式中：λ为非中心参数；Yh为层h的均值。</p> 
<ul><li>交互作用探测</li></ul> 
<p>用于识别不同风险因子Xs之间的交互作用，即评估因子X1和X2共同作用时是否会增加或减弱对因变量Y的解释力，或这些因子对Y的影响是相互独立的。评估的方法是首先分别计算两种因子X1和X2对Y的q值：q(X1)和q(X2)，并且计算它们交互（叠加变量X1和X2两个图层相切所形成的新的多边形分布）时的q值： q(X1∩X2)，比较 q(X1)、 q(X2)与 q(X1∩X2)的大小。两个因子之间的关系可分为以下几类：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/bb/db/3VbiaIwP_o.jpg"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/76/93/KbWey4Zv_o.jpg"></p> 
<ul><li>风险区探测</li></ul> 
<p>用于判断两个子区域间的属性均值是否有显著的差别，用t统计量来检验：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9f/2f/p1evC2ue_o.jpg"></p> 
<p>式中： Yh表示子区域h内的属性均值，如发病率或流行率；nh为子区域h内样本数量，Var表示方差。统计量t近似地服从Student’s t分布，其中自由度的计算方法为：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1e/a3/fzsAlN2X_o.jpg"></p> 
<p>零假设H0： Yh=1=Yh=2，如果在置信水平α下拒绝H0，则认为两个子区域间的属性均值存在着明显的差异。</p> 
<ul><li>生态探测</li></ul> 
<p>用于比较两因子X1和X2对属性Y的空间分布的影响是否有显著的差异，以F统计量来衡量。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/37/a8/db3ITdps_o.jpg"></p> 
<p>式中：NX1及NX2分别表示两个因子X1和X2的样本量；SSWX1和SSWX2分别表示由X1和X2形成的分层的层内方差之和；L1和L2分别表示变量X1和X2分层数目。其中零假设H0：SSWX1=SSWX2。如果在α的显著性水平上拒绝H0，这表明两因子X1和X2对属性Y的空间分布的影响存在着显著的差异。</p> 
<h4 id="h_612857034_3">4.1.3 功能入口</h4> 
<p>工具箱 &gt;&gt; 空间统计分析 &gt;&gt; 分析模式 &gt;&gt; 地理探测器。</p> 
<h4 id="h_612857034_4">4.1.4 主要参数</h4> 
<ul><li><strong>源数据</strong> ：设置待分析的数据集，支持点、线、面及属性表四类数据集。</li><li><strong>因变量字段(Y)</strong>：是被测定或被记录的变量，会随另一个（或另几个）变量的变动而发生变动，为数值量，如各村庄神经管畸形出生缺陷（NTDs）发生率。</li><li><strong>自变量字段(X)</strong>：是引起因变量发生变化的因素或条件，是对因变量的解释变量，支持设置多个解释变量，如土壤类型、高程、水文流域等。注意这里的自变量应为类型量，如果为数值量，则需对其进行分组或分层，使组内方差最小，组间方差最大。分组可以基于专家知识，也可以使用k-means，或者排序后等分。应保证各组或层分类变量中至少有因变量的两个样本单元，从而可以计算该层的均值或方差。</li><li><strong>结果数据</strong> ：指定的保存分析结果的数据源。四种探测器分析结果将分别生成新的属性表数据集存放至该数据源中。</li></ul> 
<h4 id="h_612857034_5">4.1.5 结果说明</h4> 
<p>所有探测器结果将生成新的属性表数据集存储至数据源中，同时在右侧地理探测器面板中输出分析结果，下面将对各探测器结果进行分析：</p> 
<ul><li><strong>因子探测器</strong> ：探测变量Y的空间分层异质性，以及探测某因子X多大程度上解释了变量Y的空间分异，用q值度量。如果分层是由自变量X生成的，则q值越大表示X和Y的空间分布越一致，自变量X对属性Y的解释力越强，反之则越弱。FactorDetector_result 属性表数据集为因子探测结果。</li><li><strong>交互探测器</strong> ：用于识别不同解释变量之间的交互作用，评估两因子共同作用时是否会增加或减弱对因变量的解释力，或这些因子对其影响是否相互独立的。InteractionDetector_result 属性表数据集为交互探测结果，解释变量对因变量交互作用的类型包括： 
  <ul><li>Weaken,nonlinear：非线性减弱；</li><li>Weaken,uni-：单因子非线性减弱；</li><li>Enhance, bi-：双因子增强；</li><li>Independent：独立；</li><li>Enhance,nonlinear：非线性增强。</li></ul></li><li><strong>风险探测器</strong> ：用于判断不同区域的属性均值是否具有显著性。RiskDetector_result 属性表数据集为风险区探测结果。</li><li><strong>生态探测器</strong> ：用于比较不同影响因子对属性值的空间分布的影响是否有显著的差异。EcologicalDetector_result 属性表数据集为生态探测结果。</li></ul> 
<h4 id="h_612857034_6">4.1.6 适用条件</h4> 
<ul><li><strong>擅长自变量X为类型量 （如土地利用图），因变量Y为数值量（碳排放）的分析</strong>；</li><li>当因变量Y和自变量X均为数值量，对X离散化转换为类型量后，运用地理探测器建立的 Y 和X 之间的关系将比经典回归更加可靠，尤其当样本量＜30 时。</li><li>对变量无线性假设，属于方差分析 （ANOVA）范畴，物理含义明确的，其大小反映了X （分层或分类） 对Y解释的百分比100×q%。</li><li>地理探测器探测两变量真正的交互作用，而不限于计量经济学预先指定的乘性交互。</li><li>地理探测器原理保证了其对多自变量共线性免疫。</li><li>在分层中，要求每层至少有2个样本单元。样本越多，估计方差越小。</li></ul> 
<h4 id="h_612857034_7">4.1.7 应用领域</h4> 
<p>包括：土地利用、公共健康、区域经济、区域规划、旅游、考古、地质、气象、植物、生态、环境、污染、遥感和计算机网络等，地理探测器作为驱动力和因子分析的有力工具已经在以上案例中得到充分验证。</p> 
<h4 id="h_612857034_8">4.1.8 数据要求与预处理</h4> 
<p>输入数据包括因变量Y和自变量数据X。自变量应为类型量；如果自变量为数值量，则需要进行<strong>离散化</strong>处理。离散可以基于专家知识，也可以直接等分或使用分类算法如K-means等。若数据为GIS数据，需要先将其转化为下图所示的Excel数据。小编以现有数据2017年城市蔓延度为因变量，选取自变量指标如下表，并将这14个指标进行<strong>自然断点法</strong>划分为5类。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/05/f1/LHR1zTgp_o.jpg"></p> 
<h3 id="h_612857034_9">4.2实现方法</h3> 
<p>可参照方法提出者网站上的解释和分析：<a href="http://www.geodetector.cn/" rel="nofollow" title="欢迎访问地理探测器网站 (geodetector.cn)">欢迎访问地理探测器网站 (geodetector.cn)</a></p> 
<h4 id="h_612857034_10">4.2.1 实现方法一：Geodetector 软件</h4> 
<p>下载：<a href="https://link.zhihu.com/?target=https%3A//links.jianshu.com/go%3Fto%3Dhttp%253A%252F%252Fwww.geodetector.cn%252F" rel="nofollow" title="http://www.geodetector.cn/">http://www.geodetector.cn/</a></p> 
<p>该软件是基于Excel表格运行的，Geodetector软件就相当于是Excel表格文件中的一个宏。</p> 
<p>需要注意，在进行地理探测器操作时，我们的<strong>自变量</strong>（上图中最后两列）必须是<strong>类别数据</strong>（比如土壤类型数据、土地利用类型数据），不能是<strong>连续数据</strong>（比如人口数据、<strong>GDP</strong>数据）；如果大家的自变量中有连续数据的话，一定要先转换成类别数据，再进行地理探测器分析。转换的方式有很多，比如假设你的连续数据是栅格格式的，那就可以用<strong>ArcGIS</strong>中的重分类工具，对原有的连续数据栅格进行转换。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/0d/a8/pfsHStQU_o.jpg"></p> 
<h4 id="h_612857034_11">4.2.2 实现方法二：R语言之geodetector包</h4> 
<p>from: R语言实现地理探测器的流程及代码</p> 
<p><a href="https://zhuanlan.zhihu.com/p/459338927" rel="nofollow" title="谷粒故里：R语言实现地理探测器的流程及代码3 赞同 · 0 评论文章正在上传…重新上传取消">谷粒故里：R语言实现地理探测器的流程及代码3 赞同 · 0 评论文章正在上传…重新上传取消</a></p> 
<p>R语言geodetector包涵盖五个函数：factor_detector，interaction_detector，risk_detector，ecological_detector和geodetector。前四个功能实现因子检测器，交互检测器，风险检测器和生态检测器的计算，可以使用表数据计算，例如csv格式。最后一个函数geodetector是一个辅助函数，可用于实现shapefile格式映射数据的计算。</p> 
<p>数据要求：需要保证输入的<strong>自变量数据</strong>已经全部为<strong>类别数据。</strong></p> 
<p>关于geodetector包官网有详细的介绍和教程，地址如下：<a href="https://link.zhihu.com/?target=https%3A//cran.r-project.org/web/packages/geodetector/vignettes/geodetector.html%23factor-detector" rel="nofollow" title="https://cran.r-project.org/web/packages/geodetector/vignettes/geodetector.html#factor-detector">https://cran.r-project.org/web/packages/geodetector/vignettes/geodetector.html#factor-detector</a></p> 
<p>实现过程如下：</p> 
<h4 id="h_612857034_12"># （1）数据预处理</h4> 
<p>X 处理为离散型数据（对于栅格数据，可用栅格重分类；对于矢量数据(渔网)，在mapGIS中建立gdb文件，将数据导入文件地理数据库，属性-符号化-将字段分级，或矢量数据分级显示之后，convert symbology to representation）</p> 
<p>Y 处理为点数据（渔网）</p> 
<h4 id="h_612857034_13"># （2） 加载geodetector包及数据导入（操作时将”文件夹名称“替换成需处理的文件即可）</h4> 
<p>&gt; install.packages("geodetector") *加载包*</p> 
<p>&gt; library(geodetector) *引用包*</p> 
<p>&gt; install.packages("readr")</p> 
<p>&gt; library(readr)</p> 
<p>&gt; read_csv(“文件夹名称.csv”) *读自己命名的数据 （注意，数据要放在当前工作的文件夹中）*</p> 
<p>&gt; 文件夹名称=read_csv("文件夹名称.csv") *数据赋值*</p> 
<p>&gt; 文件夹名称 *指定文件*</p> 
<h4 id="h_612857034_14">## 2.2.1 因子探测器</h4> 
<p>&gt; factor_detector("Y", "X", as.data.frame(文件夹名称)) *其中as函数为转换为数据框*</p> 
<h4 id="h_612857034_15">## 2.2.2 交互探测器</h4> 
<p>&gt; interaction_detector (17,c(2,3,4,5,6,7,8,9,10,11),as.data.frame(database))</p> 
<p>*其中当”X"为多个因子的时候，可以用c(2,3,4,5,6,7,8,9,10,11) 表示，数字代表列号。*</p> 
<h4 id="h_612857034_16">## 2.2.3 风险探测</h4> 
<p>&gt; risk_detector(17,c(2,3,4,5,6,7,8,9,10,11),as.data.frame(database))</p> 
<h4 id="h_612857034_17">## 2.2.4 生态探测</h4> 
<p>&gt; ecological_detector(17,c(2,3,4,5,6,7,8,9,10,11),as.data.frame(database))</p> 
<h4 id="h_612857034_18"># （3） 导出结果</h4> 
<p>&gt; result&lt;-factor_detector(17,c(2,3,4,5,6,7,8,9,10,11),as.data.frame(database))</p> 
<p>&gt; write.csv(result,'./factor_detector_CMI.csv') *将结果写入csv文件*</p> 
<p>geodetector包应用示例代码：</p> 
<pre><code>geo_data = read_xlss("his1_1.xlsx")
#11代表第11列的因变量；c(6,7,8,9,10)代表五个因变量；
result_1&lt;-factor_detector(11, c(6,7,8,9,10),as.data.frame(geo_data))
result_2&lt;-interaction_detector (11, c(6,7,8,9,10),as.data.frame(geo_data))
result_3&lt;-risk_detector(11, c(6,7,8,9,10),as.data.frame(geo_data))
result_4&lt;-ecological_detector(11, c(6,7,8,9,10),as.data.frame(geo_data))
#分别保存
write.csv(result_1,'./factor_detector_CMI.csv')</code></pre> 
<p>若出现以下缺少程辑包的类似错误，就通过install.packages("utf8")，安装这个包就可以；</p> 
<p>Error in loadNamespace(name) : 不存在叫‘utf8’这个名字的程辑包</p> 
<p>函数返回结果中，q表示决定程度，p表示显著性。</p> 
<h4 id="h_612857034_19">4.2.3 实现方法二：R语言之GD包</h4> 
<p>GD package，全称 Geographical Detectors for Assessing Spatial Factors。</p> 
<p>下载：<a href="https://link.zhihu.com/?target=https%3A//cran.r-project.org/web/packages/GD/index.html" rel="nofollow" title="https://cran.r-project.org/web/packages/GD/index.html">https://cran.r-project.org/web/packages/GD/index.html</a></p> 
<p>&gt; install.packages("GD") *加载包*</p> 
<p>&gt; library("GD") *引用包*</p> 
<p>&gt; install.packages("readr")</p> 
<p>&gt; library(readr)</p> 
<p>Examples</p> 
<pre><code>## NDVI: ndvi_40
# set optional parameters of optimal discretization
# optional methods: equal, natural, quantile, geometric, sd and manual
discmethod &lt;- c("equal", "quantile")
discitv &lt;- c(4:5)
## "gdm" function
ndvigdm &lt;- gdm(NDVIchange ~ Climatezone + Mining + Tempchange, continuous_variable = c("Tempchange"), data = ndvi_40, discmethod = discmethod, discitv = discitv)
ndvigdm
plot(ndvigdm)

# H1N1:h1n1_100
# set optional parameters of optimal discretization
discmethod &lt;- c("equal","natural","quantile")
discitv &lt;- c(4:6)
continuous_variable &lt;- colnames(h1n1_100)[-c(1,11)]
# "gdm" function
h1n1gdm &lt;- gdm(H1N1 ~ ., continuous_variable = continuous_variable, data = h1n1_100, discmethod = discmethod, discitv = discitv)
h1n1gdm
plot(h1n1gdm)
# end</code></pre> 
<p>GD包与geodetector的不同是，GD包输入连续的数据（不需要分级），通过gdm函数的以下两个参数完成自动选择最适合的分级方法和分级类别数量；而geodetector包需要的自变量数据需要是分级之后的（如使用ArcGIS的reclassify工具实现栅格数据分级，再使用点数据提取分级数值），可以是Excel、CSV等格式（分别通过调用readxl,readr包中的read_xlsx,read_csv函数实现）。</p> 
<h4 id="h_612857034_20">2.4 实现方法三：Geodetector software in QGIS (please use google to access)</h4> 
<p>链接：<a href="https://link.zhihu.com/?target=https%3A//github.com/gsnrguo/QGIS-Geographical-detector" title="https://github.com/gsnrguo/QGIS-Geographical-detector">https://github.com/gsnrguo/QGIS-Geographical-detector</a></p> 
<h3 id="h_612857034_21">4.3实例</h3> 
<p>下面利用地理探测器功能对某县神经管畸形出生缺陷（NTDs）发生率进行分析，环境因子变量包括：土壤类型、高程、水文流域。下图为环境因子分析的数据示意：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/6f/77/PRqZM0OR_o.jpg"></p> 
<p>分析结果如下：</p> 
<ul><li>因子探测器：结果展示了所有因子 q 值的计算结果，结果表明，水文流域变量(watershed)具有最高的 q 值，说明这些变量中河流是决定 NTDs 空间格局最主要的环境因子。</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/bd/d7/cDkyJg9m_o.jpg"></p> 
<ul><li>生态探测器：结果采用显著性水平为0.05的 t 检验，“√” 表示存在显著性，“×” 表示不显著。就对NTDs空间分布的作用而言，土壤类型与其他变量存在着显著差异。</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/eb/0b/aJ2bVSV4_o.jpg"></p> 
<ul><li>交互探测器：以高程因子（ elevation）为例，结果表明任何两种变量对 NTDs 空间分布的交互作用都要大于第一种变量的独自作用，两两解释变量对NTDs空间分布的交互作用为双因子增强。</li></ul> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/1f/57/zd7oSw5p_o.jpg"></p> 
<ul><li>风险探测器：结果显示了对于单个风险因子而言的风险区探测的结果。以土壤类型（ soiltype）为例，柱状图中 x 轴为 Unique Value，是环境因子各分层编号；y 轴为 Mean od explained variable，是在每种土壤类型区内的NTDs的平均发病率。</li></ul> 
<p>各类型显著性对比是，采用显著性水平为0.05的t检验，对比各类土壤类型（1-5）上的NTDs发病率是否显著大于另一土壤类型上的 NTDs 发病率，“√” 表示存在显著性，“×” 表示不显著。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8e/10/g8kV0nfI_o.jpg"></p> 
<h2 id="5.%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA">5.聚类算法理论</h2> 
<p>转自：<a href="https://blog.csdn.net/sinat_39027078/article/details/127233925#%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB" title="(28条消息) 聚类算法理论_ward聚类_是鱼儿啊～的博客-CSDN博客">(28条消息) 聚类算法理论_ward聚类_是鱼儿啊～的博客-CSDN博客</a></p> 
<h3 id="%E5%8E%9F%E7%90%86%E4%B8%8E%E7%94%A8%E9%80%94">5.1原理与用途</h3> 
<p><u>聚类是一种无监督学习算法，聚类的过程是一个见李假设的过程，使用聚类之后还需要总结每一类别的基本热证，从而更加清晰了解问题的实质</u>。</p> 
<p><strong>目的</strong>：分类，一个类别的个体具有尽可能高的同质性，类别之间具有尽可能高的异质性。</p> 
<p><strong>原理</strong>：假设研究对象均用自变量所构成的高维空间中的“点”来表示，一般规则中距离较小的同一类，距离较大的为另外一个类。</p> 
<p>以上的是个体的分类方法，使用距离分类。也可以使用变量分类，对于变量的分类一般使用<u>相似系数（如相关系数）</u>作为距离的测量指标。</p> 
<p><strong>用途：</strong></p> 
<p>1、设计抽样方案：分层抽样  （比如调研城市经济发展，先聚类划分成几个类别）；</p> 
<p>2、预分析过程：先通过聚类分析达到简化数据的目的，将众多的个体先聚集成比较好处理的几个类别或者子集，然后再进行后续的多远分析；</p> 
<p>3、细分市场、个体消费行为划分。</p> 
<h3 id="%E5%B8%B8%E8%A7%81%E7%9A%84%E8%81%9A%E7%B1%BB%E6%96%B9%E5%BC%8F">5.2常见的聚类方式</h3> 
<p>1、<strong>划分聚类</strong>：K-Means （中小规模，球形类别、计算速度较快）kmeans ：k个族，且每个族中心采用族中所含值的均值计算而成；</p> 
<p>2、<strong>层次聚类</strong>BIRCH：聚类结果丰富、不同层次结果间有嵌套关系 计算量相对较大；</p> 
<p>3、<strong>基于密度</strong>DBSCAN：一个区域中点的密度大过某个阈值，就归于同一类别中，擅长各种特殊形状的类 计算量大；</p> 
<p>4、<strong>基于网格</strong>STNG：将数据空间划分成有限单元，然后基于单元格进行聚类，处理速度快（效果比较差）；</p> 
<p>5、<strong>基于模型</strong>：SOM、高斯混合模型。</p> 
<h4 id="%E8%81%9A%E7%B1%BB%E4%B8%AD%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A"><strong>聚类中需要注意的问题</strong>：</h4> 
<p> 1、<strong>变量选择</strong>：只引入不同类别间有显著性差别的变量（无关变量会削弱有效信息，导致严重的错分）；</p> 
<p>2、<strong>共线性问题</strong>：相当于某个变量在聚类中的权重大于其他变量，最好进行预处理；</p> 
<p>3、<strong>变量的标准化</strong>：梳理统计算法上要求一律标准化，但标准化后会削弱有用变量的作用，<s>当变量量纲/变异程度相差非常大</s>时候需要进行；</p> 
<p>4、<strong>距离测量方法</strong>：在没有明确准专业知识支持下，首先使用默认值；</p> 
<p>5、<strong>异常值</strong>：影响较大，没有更好解决办法，如果不能避免异常值的影响，则在数据准备过程中加以处理；</p> 
<p>6、<strong>最佳类别数</strong>：2~8数量比较合适。</p> 
<h3 id="%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8">5.3常见算法以及应用</h3> 
<h3 id="k%20-%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB"><strong>k -均值聚类</strong></h3> 
<h4 id="k-%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB%E8%BF%87%E7%A8%8B"><strong>k-均值聚类过程</strong></h4> 
<p>        1、选择距离总和最远的案例作为初始类中心</p> 
<p>        2、按就近原则将其余案例向选中的点计算距离，并按照距离最近进行归类</p> 
<p>        3、计算出各个初始类的中心位置（均值）</p> 
<p>        4、用计算出的中心位置重新计算聚类</p> 
<p>        5、如此反复循环，直到凝聚点位置收敛位置（收敛的意思是所有的点到中心点的距离都最小）</p> 
<h4 id="%E8%AF%A5%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E7%82%B9"><strong>该算法的特点</strong></h4> 
<p>        1、需要知道初始类别、可人为指定初始位置</p> 
<p>        2、速度较快</p> 
<p>        3、只能使用连续变量进行聚类</p> 
<p>        4、衍生：K-中位数聚类</p> 
<h4 id="%E7%AE%97%E6%B3%95%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D"><strong>算法参数介绍</strong></h4> 
<pre><code>class sklearn.cluster.KMeans(
n_clusters : int,#(default=8)
init : {'k-means++', 'random','ndarray'},#(default='k-means++')
n_init : int,#(default=10)
max_iter : int, #(default=300)
tol : float,#(default=1e-4)
verbose : int, #(default=0)
random_state : int, RandomState instance or None, #(default=None)
copy_x : bool, #(default=True)
algorithm : {"lloyd", "elkan", "auto", "full"}, #(default="lloyd")
)

#一些参数解释

'''
1、n_clusters：聚类类别

2、init：初始类中心位置
    'k-means++' : 采用优化后的算法确定类中心
    'random' : 随机选取k个案例作为初始类中心
    ndarray : (n_clusters, n_features)格式提供的初始类中心位置

3、precompute_distances = 'auto' : {'auto', True, False}
    是否预先计算距离，分析速度更快，但需要更多内存
    'auto' : 如果n_samples*n_clusters &gt; 12 million，则不事先计算距离

4、algorithm = 'auto' : 'auto', 'full' or 'elkan'，具体使用的算法
    'full' : 经典的EM风格算法
    'elkan' : 使用三角不等式，速度更快，但不支持稀疏数据
    'auto' : 基于数据类型自动选择
'''


#KMeans类属性
'''
cluster_centers_ : array, [n_clusters, n_features] 聚类整理之后的中心坐标
labels_ : 类标签
inertia_ : float，各样本和其最近的类中心距离的平方和

'''



</code></pre> 
<h4 id="%C2%A0%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B"><strong> 聚类分析的应用案例</strong></h4> 
<pre><code>from sklearn.cluster import KMeans
import numpy as np

X = np.array([[1, 2], [1, 4], [1, 0],[10, 2], [10, 4], [10, 0]])

kmeans = KMeans(n_clusters=2, random_state=0).fit(X)

print(kmeans.labels_) #数据标签，从结果上看前3个组数据分为一类，后3组数据分为一类
# 输出结果：array([1, 1, 1, 0, 0, 0], dtype=int32)

print(kmeans.predict([[0, 0], [12, 3]])) #数据预测 数据[0, 0]和数据[12, 3] 标签分别为1,0
#array([1, 0], dtype=int32)

print(kmeans.cluster_centers_) #数据中心点位置，数据质心
#array([[10., 2.],[1., 2.]])</code></pre> 
<h3 id="%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB"><strong>层次聚类</strong></h3> 
<p><strong>（可用树形结构描述）</strong></p> 
<h4 id="%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB%E7%9A%84%E8%BF%87%E7%A8%8B">层次聚类的过程</h4> 
<p>1、先将所有n个变量/案例看成不同的n类</p> 
<p>2、将性质最接近的两类合并成一类</p> 
<p>3、从n-1类中找到最接近的两类加以合并</p> 
<p>4、依次类推，直到所有的变量/案例被合并为一类</p> 
<p>5、使用者根据具体的问题和聚类结果来决定应当分为几类</p> 
<h4 id="%E7%AE%97%E6%B3%95%E7%89%B9%E7%82%B9"><strong>算法特点</strong></h4> 
<p>1、一旦个体被划定类别，其分类结果就不会再进行更改</p> 
<p>2、可以对变量或案例进行聚类，变量可以是连续变量或者分类变量，但是不同类型的变量不能同时使用</p> 
<p>3、运行速度慢</p> 
<p>4、测量距离的方法非常丰富，但是这不是使用该方法的重点</p> 
<p>案例聚类使用AgglomerativeClustering</p> 
<h4 id="%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D">参数介绍</h4> 
<pre><code>class sklearn.cluster.AgglomerativeClustering(
n_clusters : int or None, default=2
affinity : str or callable, default='euclidean'('euclidean', 'l1', 'l2', 'manhattan', 'cosine', or 'precomputed')
memory : str or object with the joblib.Memory interface, default=None
connectivity : array-like or callable, default=None
compute_full_tree : 'auto' or bool, default='auto'
linkage : {'ward', 'complete', 'average', 'single'}, default='ward'
pooling_func : callable, default=np.mean
distance_threshold : float, default=None
compute_distances : bool, default=False
)


#一些参数解释
'''
1、n_clusters : 聚类的类别数

2、affinity : 使用的距离测量方法

3、linkage = 'ward' 类间距离的计算方法
    ward : 使各类的方差总和最小化
    average : 使用两个类间所有不同类案例的平均距离
    complete : 使用两个类间最远案例的距离

'''


# sklearn.cluster.AgglomerativeClustering类的属性：
'''
labels_ : array [n_samples]，各案例的类标签
n_leaves_ : int，聚类树的叶子数（案例数）
n_components_ : int，聚类变量中潜在的成分数
children_ : array-like, shape (n_nodes-1, 2)，各非终末节点的子节点列表

'''</code></pre> 
<h4 id="%E5%B1%82%E6%AC%A1%E8%81%9A%E7%B1%BB%E7%9A%84%E5%BA%94%E7%94%A8%E5%B0%8F%E6%A1%88%E4%BE%8B">层次聚类的应用小案例</h4> 
<pre><code>from sklearn.cluster import AgglomerativeClustering
import numpy as np
X = np.array([[1, 2], [1, 4], [1, 0],[4, 2], [4, 4], [4, 0]])
clustering = AgglomerativeClustering().fit(X)
print(clustering)
#AgglomerativeClustering()

print(clustering.labels_) #结果标签
#array([1, 1, 1, 0, 0, 0])

print(pd.DataFrame(clustering.labels_)[0].value_counts()) #每个分类的数量
#1    3
#0    3
</code></pre> 
<h3 id="%E7%89%B9%E5%BE%81%E8%81%9A%E7%B1%BB">特征聚类</h3> 
<p>使用 FeatureAgglomeration</p> 
<pre><code>import numpy as np
from sklearn import datasets, cluster
digits = datasets.load_digits()
images = digits.images
X = np.reshape(images, (len(images), -1))
agglo = cluster.FeatureAgglomeration(n_clusters=32)
print(agglo.fit(X))
#FeatureAgglomeration(n_clusters=32)
X_reduced = agglo.transform(X)
print(X_reduced.shape)
#(1797, 32)</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p>#学习自用，若有侵权，联系则删</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0de95fb05f878cea40d077684082c4f9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【C&#43;&#43;11】判断std::map中是否存在某个元素</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2607ed607e534c9cecf0425cc0ad2b49/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Idea】人工智能编程他来了，Idea集成一款和ChatGPT一样智能的编码辅助神器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>