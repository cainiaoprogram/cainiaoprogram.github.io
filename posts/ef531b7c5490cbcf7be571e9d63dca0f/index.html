<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>spinal HDL - 09 - 时序逻辑 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="spinal HDL - 09 - 时序逻辑" />
<meta property="og:description" content="Registers 用 SpinalHDL 创建寄存器与用 VHDL 或 Verilog 创建寄存器非常不同。在SpinalHDL ，没有过程/总是阻塞。寄存器在声明中明确定义。这与传统的事件驱动 HDL 的区别有很大的影响:
您可以在相同的范围内分配寄存器和连接，这意味着代码不需要在进程/总是块之间分割。
它使一些事情更加灵活(参见函数)，并且时钟和重置是分开处理的。
实例化 有4种方法可以实例化一个寄存器:
Syntax语法Description描述Reg(type : Data)给定类型的寄存器RegInit(resetValue : Data)重置时使用给定的 resetValue加载的寄存器RegNext(nextValue : Data)寄存器采样给定的nextValue 每个周期RegNextWhen(nextValue : Data, cond : Bool)当条件发生时寄存器采样给定的 nextValue 下面是一个声明某些寄存器的例子:
// UInt register of 4 bits val reg1 = Reg(UInt(4 bit)) // Register that samples reg1 each cycle val reg2 = RegNext(reg1 &#43; 1) // UInt register of 4 bits initialized with 0 when the reset occurs val reg3 = RegInit(U&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ef531b7c5490cbcf7be571e9d63dca0f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-10T14:25:13+08:00" />
<meta property="article:modified_time" content="2022-08-10T14:25:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">spinal HDL - 09 - 时序逻辑</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Registers_0"></a>Registers</h2> 
<p>用 SpinalHDL 创建寄存器与用 VHDL 或 Verilog 创建寄存器非常不同。在SpinalHDL ，没有过程/总是阻塞。寄存器在声明中明确定义。这与传统的事件驱动 HDL 的区别有很大的影响:</p> 
<ul><li> <p>您可以在相同的范围内分配寄存器和连接，这意味着代码不需要在进程/总是块之间分割。</p> </li><li> <p>它使一些事情更加灵活(参见函数)，并且时钟和重置是分开处理的。</p> </li></ul> 
<h3><a id="_8"></a>实例化</h3> 
<p>有4种方法可以实例化一个寄存器:</p> 
<table><thead><tr><th>Syntax语法</th><th>Description描述</th></tr></thead><tbody><tr><td><code>Reg(type : Data)</code></td><td>给定类型的寄存器</td></tr><tr><td><code>RegInit(resetValue : Data)</code></td><td>重置时使用给定的 resetValue加载的寄存器</td></tr><tr><td><code>RegNext(nextValue : Data)</code></td><td>寄存器采样给定的nextValue 每个周期</td></tr><tr><td><code>RegNextWhen(nextValue : Data, cond : Bool)</code></td><td>当条件发生时寄存器采样给定的 nextValue</td></tr></tbody></table> 
<p>下面是一个声明某些寄存器的例子:</p> 
<pre><code class="prism language-scala"><span class="token comment">// UInt register of 4 bits</span>
<span class="token keyword">val</span> reg1 <span class="token operator">=</span> Reg<span class="token punctuation">(</span>UInt<span class="token punctuation">(</span><span class="token number">4</span> bit<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// Register that samples reg1 each cycle</span>
<span class="token keyword">val</span> reg2 <span class="token operator">=</span> RegNext<span class="token punctuation">(</span>reg1 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>

<span class="token comment">// UInt register of 4 bits initialized with 0 when the reset occurs</span>
<span class="token keyword">val</span> reg3 <span class="token operator">=</span> RegInit<span class="token punctuation">(</span><span class="token string-interpolation"><span class="token id function">U</span><span class="token string">"0000"</span></span><span class="token punctuation">)</span>
reg3 <span class="token operator">:</span><span class="token operator">=</span> reg2
when<span class="token punctuation">(</span>reg2 <span class="token operator">==</span><span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  reg3 <span class="token operator">:</span><span class="token operator">=</span> <span class="token number">0xF</span>
<span class="token punctuation">}</span>

<span class="token comment">// Register that samples reg3 when cond is True</span>
<span class="token keyword">val</span> reg4 <span class="token operator">=</span> RegNextWhen<span class="token punctuation">(</span>reg3<span class="token punctuation">,</span> cond<span class="token punctuation">)</span>
</code></pre> 
<p>上面的代码将推断出以下逻辑:</p> 
<p><img src="https://images2.imgbox.com/93/78/nf5UQNv9_o.png" alt="在这里插入图片描述"></p> 
<p>上面的 reg3示例显示了如何分配 RegInit 寄存器的值。也可以使用相同的语法分配给其他寄存器类型(Reg、 RegNext、 RegNextWhen)。就像组合赋值一样，规则是“最后一次赋值获胜”，但是如果没有完成赋值，寄存器保留其值。</p> 
<p>RegNext 是一个基于 Reg 语法构建的抽象。下面两个代码序列是严格等价的:</p> 
<pre><code class="prism language-scala"><span class="token comment">// Standard way</span>
<span class="token keyword">val</span> something <span class="token operator">=</span> Bool<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> value <span class="token operator">=</span> Reg<span class="token punctuation">(</span>Bool<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
value <span class="token operator">:</span><span class="token operator">=</span> something

<span class="token comment">// Short way</span>
<span class="token keyword">val</span> something <span class="token operator">=</span> Bool<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">val</span> value <span class="token operator">=</span> RegNext<span class="token punctuation">(</span>something<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="Reset_value__59"></a>Reset value 重置值</h3> 
<p>除了使用 RegInit (value: Data)语法直接创建具有重置值的寄存器之外，还可以通过调用寄存器上的 init (value: Data)函数来设置重置值。</p> 
<pre><code>// UInt register of 4 bits initialized with 0 when the reset occurs
val reg1 = Reg(UInt(4 bit)) init(0)
</code></pre> 
<p>如果有一个包含 Bundle 的寄存器，则可以对 Bundle 的每个元素使用 init 函数。</p> 
<pre><code class="prism language-scala"><span class="token keyword">case</span> <span class="token keyword">class</span> ValidRGB<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">extends</span> Bundle<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">val</span> valid   <span class="token operator">=</span> Bool<span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">val</span> r<span class="token punctuation">,</span> g<span class="token punctuation">,</span> b <span class="token operator">=</span> UInt<span class="token punctuation">(</span><span class="token number">8</span> bits<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">val</span> reg <span class="token operator">=</span> Reg<span class="token punctuation">(</span>ValidRGB<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
reg<span class="token punctuation">.</span>valid init<span class="token punctuation">(</span>False<span class="token punctuation">)</span>  <span class="token comment">// Only the valid if that register bundle will have a reset value.</span>
</code></pre> 
<h3><a id="_80"></a>用于仿真的初始化值</h3> 
<p>对于在 RTL 中不需要重置值，但是需要初始化值进行模拟(以避免 x 传播)的寄存器，可以通过调用 randBoot ()函数来请求一个随机初始化值。</p> 
<pre><code class="prism language-scala"><span class="token comment">// UInt register of 4 bits initialized with a random value</span>
<span class="token keyword">val</span> reg1 <span class="token operator">=</span> Reg<span class="token punctuation">(</span>UInt<span class="token punctuation">(</span><span class="token number">4</span> bit<span class="token punctuation">)</span><span class="token punctuation">)</span> randBoot<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h2><a id="RAMROM_89"></a>RAM/ROM</h2> 
<h3><a id="_91"></a>语法</h3> 
<p>要用 SpinalHDL 创建内存，应该使用 Mem 类。它允许您定义一个内存并向其添加读写端口。</p> 
<p>下表显示了如何实例化一个内存:</p> 
<table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td><code>Mem(type : Data, size : Int)</code></td><td>创建一个 RAM</td></tr><tr><td><code>Mem(type : Data, initialContent : Array[Data])</code></td><td>创建一个 ROM。如果您的目标是 FPGA，因为内存可以被推断为块内存，那么您仍然可以在它上面创建写入端口。</td></tr></tbody></table> 
<p>如果你想定义一个 ROM，initialContent 数组的元素应该只是文字值(没有运算符，没有调整大小的函数)。这里有一个例子。要给出 RAM 初始值，还可以使用 init 函数。</p> 
<p>下表显示了如何在内存中添加访问端口:</p> 
<table><thead><tr><th>Syntax</th><th>Description</th><th>Return</th></tr></thead><tbody><tr><td>mem(address) := data</td><td>同步写</td><td></td></tr><tr><td>mem(x)</td><td>异步读取</td><td>T</td></tr><tr><td>mem.write(address data [enable] [mask])</td><td>带有可选掩码的同步写入。如果没有指定 enable，则会从调用此函数的条件作用域自动推断</td><td></td></tr><tr><td>mem.readAsync(address [readUnderWrite] )</td><td>使用可选的读取下写策略进行异步读取</td><td>T</td></tr><tr><td>mem.readSync(address [enable] [readUnderWrite] [clockCrossing])</td><td>具有可选的 enable、read-under-write 策略和 clockCrossing 模式的同步读取</td><td>T</td></tr><tr><td>mem.readWriteSync(address data enable write [mask] [readUnderWrite] [clockCrossing] )</td><td>推断读/写端口，<br>当 enable &amp; write 时写入数据。返回读取的数据，当 enable 为 true 时发生读取。</td><td>T</td></tr></tbody></table> 
<p>如果出于某种原因，你需要一个在 Spinal 中没有实现的特定内存端口，你总是可以通过为它指定一个 BlackBox 来抽象你的内存。SpinalHDL 中的内存端口不是推导出来的，而是显式定义的。不应该像 VHDL/Verilog 中那样使用编码模板来帮助合成工具推断内存。</p> 
<p>下面是一个简单的双端口 ram (32位 * 256)的例子:</p> 
<pre><code class="prism language-scala"><span class="token keyword">val</span> mem <span class="token operator">=</span> Mem<span class="token punctuation">(</span>Bits<span class="token punctuation">(</span><span class="token number">32</span> bits<span class="token punctuation">)</span><span class="token punctuation">,</span> wordCount <span class="token operator">=</span> <span class="token number">256</span><span class="token punctuation">)</span>
mem<span class="token punctuation">.</span>write<span class="token punctuation">(</span>
  enable  <span class="token operator">=</span> io<span class="token punctuation">.</span>writeValid<span class="token punctuation">,</span>
  address <span class="token operator">=</span> io<span class="token punctuation">.</span>writeAddress<span class="token punctuation">,</span>
  data    <span class="token operator">=</span> io<span class="token punctuation">.</span>writeData
<span class="token punctuation">)</span>

io<span class="token punctuation">.</span>readData <span class="token operator">:</span><span class="token operator">=</span> mem<span class="token punctuation">.</span>readSync<span class="token punctuation">(</span>
  enable  <span class="token operator">=</span> io<span class="token punctuation">.</span>readValid<span class="token punctuation">,</span>
  address <span class="token operator">=</span> io<span class="token punctuation">.</span>readAddress
<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="_133"></a>读写策略</h3> 
<p>此策略指定在同一循环中对同一地址进行写操作时，读操作如何受到影响。</p> 
<table><thead><tr><th>Kinds</th><th>Description</th></tr></thead><tbody><tr><td><code>dontCare</code></td><td>当事例发生时，不要关心 read 值</td></tr><tr><td><code>readFirst</code></td><td>读取将获得旧值 ( 在写入之前 )</td></tr><tr><td><code>writeFirst</code></td><td>读取将获得新值 ( 由写入提供 )</td></tr></tbody></table> 
<p>生成的 VHDL/Verilog 始终处于 readFirst 模式，该模式与 dontCare 兼容，但与 writeFirst 不兼容。要生成包含这种特性的设计，您需要启用自动内存黑盒。</p> 
<h3><a id="Mixedwidth_ram_145"></a>Mixed-width ram</h3> 
<p>你可以使用以下函数指定访问内存的端口，其宽度为内存宽度的两分之一的幂:</p> 
<table><thead><tr><th>Syntax</th><th>Description</th></tr></thead><tbody><tr><td>mem.writeMixedWidth(address<br>data<br>[readUnderWrite])</td><td>类似于 mem.write</td></tr><tr><td>mem.readAsyncMixedWidth(address<br>data<br>[readUnderWrite] )</td><td>与 mem.readAsync 类似，但它不返回读取值，而是驱动作为数据参数给定的信号/对象</td></tr><tr><td>mem.readSyncMixedWidth(address<br>data<br>[enable]<br>[readUnderWrite] <br>[clockCrossing])</td><td>与 mem.readSync 类似，但它不返回读取值，而是驱动作为数据参数给出的信号/对象</td></tr><tr><td>mem.readWriteSyncMixedWidth(address<br>data<br>enable<br>write <br>[mask] <br>[readUnderWrite] <br>[clockCrossing])</td><td>等价于 mem.readWriteSync</td></tr></tbody></table> 
<p>至于读写策略，要使用这个特性，您需要启用自动内存黑盒，因为没有通用的 VHDL/Verilog 语言模板来推断混合宽度内存。</p> 
<h3><a id="Automatic_blackboxing_160"></a>Automatic blackboxing</h3> 
<p>由于不可能用常规的 VHDL/Verilog 推断所有的 ram 类型，SpinalHDL 集成了一个可选的自动黑箱系统。这个系统查看你的 RTL 网络列表中的所有内存，并用黑匣子替换它们。然后，生成的代码将依靠第三方 IP 提供内存特性，如写入期间读取策略和混合宽度端口。</p> 
<p>下面是一个默认情况下如何启用存储器黑盒的例子:</p> 
<pre><code class="prism language-scala"><span class="token keyword">def</span> main<span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  SpinalConfig<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span>addStandardMemBlackboxing<span class="token punctuation">(</span>blackboxAll<span class="token punctuation">)</span>
    <span class="token punctuation">.</span>generateVhdl<span class="token punctuation">(</span><span class="token keyword">new</span> TopLevel<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="Blackboxing_policy_174"></a>Blackboxing policy</h4> 
<p>你可以使用多种策略来选择你想要黑匣子的内存，以及当黑匣子不可行时该怎么做:</p> 
<table><thead><tr><th>Kinds</th><th>Description</th></tr></thead><tbody><tr><td><code>blackboxAll</code></td><td>黑盒所有内存。在不可黑盒的内存上抛出错误。</td></tr><tr><td><code>blackboxAllWhatsYouCan</code></td><td>黑匣子所有可黑匣子的内存。</td></tr><tr><td>`blackboxRequestedAndUninferable</td><td>由用户指定的 Blackbox 内存和已知无法推断的内存(mixed-width，…)。在不可黑盒的内存上抛出错误。</td></tr><tr><td><code>blackboxOnlyIfRequested</code></td><td>由用户指定的 Blackbox 内存，在不可黑盒的内存上抛出错误。</td></tr></tbody></table> 
<p>要显式地将内存设置为黑盒，可以使用其 generateAsBlackBox 函数。</p> 
<pre><code>val mem = Mem(Rgb(rgbConfig), 1 &lt;&lt; 16)
mem.generateAsBlackBox()
</code></pre> 
<p>您还可以通过扩展 MemBlackboxingPolicy 类来定义自己的 blackboxing 策略。</p> 
<h4><a id="Standard_memory_blackboxes_194"></a>Standard memory blackboxes</h4> 
<p>下面是 SpinalHDL 中使用的标准黑盒的 VHDL 定义:</p> 
<pre><code class="prism language-scala"><span class="token operator">--</span> Simple asynchronous dual port <span class="token punctuation">(</span><span class="token number">1</span> write port<span class="token punctuation">,</span> <span class="token number">1</span> read port<span class="token punctuation">)</span>
component Ram_1w_1ra is
  generic<span class="token punctuation">(</span>
    wordCount <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    wordWidth <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    technology <span class="token operator">:</span> string<span class="token punctuation">;</span>
    readUnderWrite <span class="token operator">:</span> string<span class="token punctuation">;</span>
    wrAddressWidth <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    wrDataWidth <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    wrMaskWidth <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    wrMaskEnable <span class="token operator">:</span> boolean<span class="token punctuation">;</span>
    rdAddressWidth <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    rdDataWidth <span class="token operator">:</span> integer
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  port<span class="token punctuation">(</span>
    clk <span class="token operator">:</span> in std_logic<span class="token punctuation">;</span>
    wr_en <span class="token operator">:</span> in std_logic<span class="token punctuation">;</span>
    wr_mask <span class="token operator">:</span> in std_logic_vector<span class="token punctuation">;</span>
    wr_addr <span class="token operator">:</span> in unsigned<span class="token punctuation">;</span>
    wr_data <span class="token operator">:</span> in std_logic_vector<span class="token punctuation">;</span>
    rd_addr <span class="token operator">:</span> in unsigned<span class="token punctuation">;</span>
    rd_data <span class="token operator">:</span> out std_logic_vector
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
end component<span class="token punctuation">;</span>

<span class="token operator">--</span> Simple synchronous dual port <span class="token punctuation">(</span><span class="token number">1</span> write port<span class="token punctuation">,</span> <span class="token number">1</span> read port<span class="token punctuation">)</span>
component Ram_1w_1rs is
  generic<span class="token punctuation">(</span>
    wordCount <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    wordWidth <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    clockCrossing <span class="token operator">:</span> boolean<span class="token punctuation">;</span>
    technology <span class="token operator">:</span> string<span class="token punctuation">;</span>
    readUnderWrite <span class="token operator">:</span> string<span class="token punctuation">;</span>
    wrAddressWidth <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    wrDataWidth <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    wrMaskWidth <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    wrMaskEnable <span class="token operator">:</span> boolean<span class="token punctuation">;</span>
    rdAddressWidth <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    rdDataWidth <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    rdEnEnable <span class="token operator">:</span> boolean
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  port<span class="token punctuation">(</span>
    wr_clk <span class="token operator">:</span> in std_logic<span class="token punctuation">;</span>
    wr_en <span class="token operator">:</span> in std_logic<span class="token punctuation">;</span>
    wr_mask <span class="token operator">:</span> in std_logic_vector<span class="token punctuation">;</span>
    wr_addr <span class="token operator">:</span> in unsigned<span class="token punctuation">;</span>
    wr_data <span class="token operator">:</span> in std_logic_vector<span class="token punctuation">;</span>
    rd_clk <span class="token operator">:</span> in std_logic<span class="token punctuation">;</span>
    rd_en <span class="token operator">:</span> in std_logic<span class="token punctuation">;</span>
    rd_addr <span class="token operator">:</span> in unsigned<span class="token punctuation">;</span>
    rd_data <span class="token operator">:</span> out std_logic_vector
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
end component<span class="token punctuation">;</span>

<span class="token operator">--</span> Single port <span class="token punctuation">(</span><span class="token number">1</span> readWrite port<span class="token punctuation">)</span>
component Ram_1wrs is
  generic<span class="token punctuation">(</span>
    wordCount <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    wordWidth <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    readUnderWrite <span class="token operator">:</span> string<span class="token punctuation">;</span>
    technology <span class="token operator">:</span> string
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  port<span class="token punctuation">(</span>
    clk <span class="token operator">:</span> in std_logic<span class="token punctuation">;</span>
    en <span class="token operator">:</span> in std_logic<span class="token punctuation">;</span>
    wr <span class="token operator">:</span> in std_logic<span class="token punctuation">;</span>
    addr <span class="token operator">:</span> in unsigned<span class="token punctuation">;</span>
    wrData <span class="token operator">:</span> in std_logic_vector<span class="token punctuation">;</span>
    rdData <span class="token operator">:</span> out std_logic_vector
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
end component<span class="token punctuation">;</span>

<span class="token operator">--</span>True dual port <span class="token punctuation">(</span><span class="token number">2</span> readWrite port<span class="token punctuation">)</span>
component Ram_2wrs is
  generic<span class="token punctuation">(</span>
    wordCount <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    wordWidth <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    clockCrossing <span class="token operator">:</span> boolean<span class="token punctuation">;</span>
    technology <span class="token operator">:</span> string<span class="token punctuation">;</span>
    portA_readUnderWrite <span class="token operator">:</span> string<span class="token punctuation">;</span>
    portA_addressWidth <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    portA_dataWidth <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    portA_maskWidth <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    portA_maskEnable <span class="token operator">:</span> boolean<span class="token punctuation">;</span>
    portB_readUnderWrite <span class="token operator">:</span> string<span class="token punctuation">;</span>
    portB_addressWidth <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    portB_dataWidth <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    portB_maskWidth <span class="token operator">:</span> integer<span class="token punctuation">;</span>
    portB_maskEnable <span class="token operator">:</span> boolean
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
  port<span class="token punctuation">(</span>
    portA_clk <span class="token operator">:</span> in std_logic<span class="token punctuation">;</span>
    portA_en <span class="token operator">:</span> in std_logic<span class="token punctuation">;</span>
    portA_wr <span class="token operator">:</span> in std_logic<span class="token punctuation">;</span>
    portA_mask <span class="token operator">:</span> in std_logic_vector<span class="token punctuation">;</span>
    portA_addr <span class="token operator">:</span> in unsigned<span class="token punctuation">;</span>
    portA_wrData <span class="token operator">:</span> in std_logic_vector<span class="token punctuation">;</span>
    portA_rdData <span class="token operator">:</span> out std_logic_vector<span class="token punctuation">;</span>
    portB_clk <span class="token operator">:</span> in std_logic<span class="token punctuation">;</span>
    portB_en <span class="token operator">:</span> in std_logic<span class="token punctuation">;</span>
    portB_wr <span class="token operator">:</span> in std_logic<span class="token punctuation">;</span>
    portB_mask <span class="token operator">:</span> in std_logic_vector<span class="token punctuation">;</span>
    portB_addr <span class="token operator">:</span> in unsigned<span class="token punctuation">;</span>
    portB_wrData <span class="token operator">:</span> in std_logic_vector<span class="token punctuation">;</span>
    portB_rdData <span class="token operator">:</span> out std_logic_vector
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
end component<span class="token punctuation">;</span>
</code></pre> 
<p>如你所见，blackboxes 有一个技术参数。要设置它，可以在相应的内存上使用 setTechnology 函数。目前有四种可能的技术:</p> 
<ul><li><code>auto</code></li><li><code>ramBlock</code></li><li><code>distributedLut</code></li><li><code>registerFile</code></li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0e23a07ddedc1ca544a18a494c263c29/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2022-06-23 VGMP-OSPF-域间安全策略-NAT策略</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dd3cd7c48f80c672b3d0abfa9ed3243e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">网站架构探测&amp;chrome插件用于信息收集</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>