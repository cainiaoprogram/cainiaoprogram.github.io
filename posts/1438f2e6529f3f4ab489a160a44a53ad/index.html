<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>springboot源码分析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="springboot源码分析" />
<meta property="og:description" content="目录
1. 概述
2. 基于springboot开发web项目
3. spring容器的创建
4. springboot启动类加入spring容器
5. 基于条件配置bean
5.1 什么时候进行条件判断
5.2 条件判断处理分析
5.3 常见Conditional注解分析
5.3.1 @ConditionalOnBean
5.3.2 @ConditionalOnClass
5.3.3 @ConditionalOnProperty
6. 自动配置
6.1 加载所有的META-INF/spring.factories文件中配置
6.2 将spring.factories文件中EnableAutoConfiguration配置类加入spring
7. 内嵌Tomcat的创建和配置
7.1 创建Tomcat服务器
7.2 DispatcherServlet的创建和加入web容器
8. springboot属性加载
8.1 springboot默认属性加载文件
8.2 springboot配置bean的扫描和初始化
8.2.1 ServerProperties注册到spring容器
8.2.2 ServerProperties属性注入
（本篇测试、分析项目代码路径https://gitee.com/yejuan/springboot-learning.git 对应tag: c1）
1. 概述 springboot有大量的自动配置、条件注册bean使开发者很简单快捷地接入各种服务和组件，是优秀的敏捷开发工具。
springboot中有大量的服务配置在META-INF/spring.factories文件中，使用时通过key找到相应的类再反射获取实例；springboot会自动过滤注册META-INF/spring.factories文件中配置的key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的class到spring容器 2. 基于springboot开发web项目 代码示例
jar包依赖
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;${springboot.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;version&gt;${springboot.version}&lt;/version&gt; &lt;/dependency&gt; spring boot启动类
@SpringBootApplication(scanBasePackages={&#34;com.yej.learning&#34;}) public class App { public static void main( String[] args ) { /** * App." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1438f2e6529f3f4ab489a160a44a53ad/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-13T15:06:33+08:00" />
<meta property="article:modified_time" content="2020-09-13T15:06:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">springboot源码分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%20%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#1.%20%E6%A6%82%E8%BF%B0" rel="nofollow">1. 概述</a></p> 
<p id="2.%E5%9F%BA%E4%BA%8Espringboot%E5%BC%80%E5%8F%91web%E9%A1%B9%E7%9B%AE-toc" style="margin-left:0px;"><a href="#2.%E5%9F%BA%E4%BA%8Espringboot%E5%BC%80%E5%8F%91web%E9%A1%B9%E7%9B%AE" rel="nofollow">2. 基于springboot开发web项目</a></p> 
<p id="3.%20spring%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA-toc" style="margin-left:0px;"><a href="#3.%20spring%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA" rel="nofollow">3. spring容器的创建</a></p> 
<p id="4.%20springboot%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E5%85%A5spring%E5%AE%B9%E5%99%A8-toc" style="margin-left:0px;"><a href="#4.%20springboot%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E5%85%A5spring%E5%AE%B9%E5%99%A8" rel="nofollow">4. springboot启动类加入spring容器</a></p> 
<p id="5.%20%E5%9F%BA%E4%BA%8E%E6%9D%A1%E4%BB%B6%E9%85%8D%E7%BD%AEbean-toc" style="margin-left:0px;"><a href="#5.%20%E5%9F%BA%E4%BA%8E%E6%9D%A1%E4%BB%B6%E9%85%8D%E7%BD%AEbean" rel="nofollow">5. 基于条件配置bean</a></p> 
<p id="5.1%20%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BF%9B%E8%A1%8C%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD-toc" style="margin-left:40px;"><a href="#5.1%20%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BF%9B%E8%A1%8C%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD" rel="nofollow">5.1 什么时候进行条件判断</a></p> 
<p id="5.2%20%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#5.2%20%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90" rel="nofollow">5.2 条件判断处理分析</a></p> 
<p id="5.3%C2%A0%C2%A0%20%C2%A0%E5%B8%B8%E8%A7%81Conditional%E6%B3%A8%E8%A7%A3%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#5.3%C2%A0%C2%A0%20%C2%A0%E5%B8%B8%E8%A7%81Conditional%E6%B3%A8%E8%A7%A3%E5%88%86%E6%9E%90" rel="nofollow">5.3 常见Conditional注解分析</a></p> 
<p id="5.3.1%C2%A0%C2%A0%20%C2%A0%40ConditionalOnBean-toc" style="margin-left:80px;"><a href="#5.3.1%C2%A0%C2%A0%20%C2%A0%40ConditionalOnBean" rel="nofollow">5.3.1 @ConditionalOnBean</a></p> 
<p id="5.3.2%C2%A0%C2%A0%20%C2%A0%40ConditionalOnClass-toc" style="margin-left:80px;"><a href="#5.3.2%C2%A0%C2%A0%20%C2%A0%40ConditionalOnClass" rel="nofollow">5.3.2 @ConditionalOnClass</a></p> 
<p id="5.3.3%20%40ConditionalOnProperty-toc" style="margin-left:80px;"><a href="#5.3.3%20%40ConditionalOnProperty" rel="nofollow">5.3.3 @ConditionalOnProperty</a></p> 
<p id="6.%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE-toc" style="margin-left:0px;"><a href="#6.%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE" rel="nofollow">6. 自动配置</a></p> 
<p id="6.1%C2%A0%C2%A0%20%C2%A0%E5%8A%A0%E8%BD%BD%E6%89%80%E6%9C%89%E7%9A%84META-INF%2Fspring.factories%E6%96%87%E4%BB%B6%E4%B8%AD%E9%85%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#6.1%C2%A0%C2%A0%20%C2%A0%E5%8A%A0%E8%BD%BD%E6%89%80%E6%9C%89%E7%9A%84META-INF%2Fspring.factories%E6%96%87%E4%BB%B6%E4%B8%AD%E9%85%8D%E7%BD%AE" rel="nofollow">6.1 加载所有的META-INF/spring.factories文件中配置</a></p> 
<p id="6.2%20%E5%B0%86spring.factories%E6%96%87%E4%BB%B6%E4%B8%ADEnableAutoConfiguration%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%8A%A0%E5%85%A5spring-toc" style="margin-left:40px;"><a href="#6.2%20%E5%B0%86spring.factories%E6%96%87%E4%BB%B6%E4%B8%ADEnableAutoConfiguration%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%8A%A0%E5%85%A5spring" rel="nofollow">6.2 将spring.factories文件中EnableAutoConfiguration配置类加入spring</a></p> 
<p id="7.%20%E5%86%85%E5%B5%8CTomcat%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE-toc" style="margin-left:0px;"><a href="#7.%20%E5%86%85%E5%B5%8CTomcat%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE" rel="nofollow">7. 内嵌Tomcat的创建和配置</a></p> 
<p id="7.1%20%E5%88%9B%E5%BB%BATomcat%E6%9C%8D%E5%8A%A1%E5%99%A8-toc" style="margin-left:40px;"><a href="#7.1%20%E5%88%9B%E5%BB%BATomcat%E6%9C%8D%E5%8A%A1%E5%99%A8" rel="nofollow">7.1 创建Tomcat服务器</a></p> 
<p id="7.2%20DispatcherServlet%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%8A%A0%E5%85%A5web%E5%AE%B9%E5%99%A8-toc" style="margin-left:40px;"><a href="#7.2%20DispatcherServlet%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%8A%A0%E5%85%A5web%E5%AE%B9%E5%99%A8" rel="nofollow">7.2 DispatcherServlet的创建和加入web容器</a></p> 
<p id="8.%20springboot%E5%B1%9E%E6%80%A7%E5%8A%A0%E8%BD%BD-toc" style="margin-left:0px;"><a href="#8.%20springboot%E5%B1%9E%E6%80%A7%E5%8A%A0%E8%BD%BD" rel="nofollow">8. springboot属性加载</a></p> 
<p id="8.1%C2%A0%C2%A0%20%C2%A0springboot%E9%BB%98%E8%AE%A4%E5%B1%9E%E6%80%A7%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6-toc" style="margin-left:40px;"><a href="#8.1%C2%A0%C2%A0%20%C2%A0springboot%E9%BB%98%E8%AE%A4%E5%B1%9E%E6%80%A7%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6" rel="nofollow">8.1 springboot默认属性加载文件</a></p> 
<p id="8.2%20springboot%E9%85%8D%E7%BD%AEbean%E7%9A%84%E6%89%AB%E6%8F%8F%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96-toc" style="margin-left:40px;"><a href="#8.2%20springboot%E9%85%8D%E7%BD%AEbean%E7%9A%84%E6%89%AB%E6%8F%8F%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96" rel="nofollow">8.2 springboot配置bean的扫描和初始化</a></p> 
<p id="8.2.1%20ServerProperties%E6%B3%A8%E5%86%8C%E5%88%B0spring%E5%AE%B9%E5%99%A8-toc" style="margin-left:80px;"><a href="#8.2.1%20ServerProperties%E6%B3%A8%E5%86%8C%E5%88%B0spring%E5%AE%B9%E5%99%A8" rel="nofollow">8.2.1 ServerProperties注册到spring容器</a></p> 
<p id="8.2.2%20ServerProperties%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5-toc" style="margin-left:80px;"><a href="#8.2.2%20ServerProperties%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5" rel="nofollow">8.2.2 ServerProperties属性注入</a></p> 
<hr id="hr-toc"> 
<p>（本篇测试、分析项目代码路径https://gitee.com/yejuan/springboot-learning.git 对应tag: c1）</p> 
<h2 id="1.%20%E6%A6%82%E8%BF%B0">1. 概述</h2> 
<p style="margin-left:0cm;">springboot有大量的自动配置、条件注册bean使开发者很简单快捷地接入各种服务和组件，是优秀的敏捷开发工具。</p> 
<ol><li>springboot中有大量的服务配置在META-INF/spring.factories文件中，使用时通过key找到相应的类再反射获取实例；</li><li>springboot会自动过滤注册<span style="color:#000000;">META-INF/spring.factories</span><span style="color:#000000;">文件中配置的</span><span style="color:#000000;">key</span><span style="color:#000000;">为</span><span style="color:#000000;">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span><span style="color:#000000;">的</span><span style="color:#000000;">class</span><span style="color:#000000;">到</span><span style="color:#000000;">spring</span><span style="color:#000000;">容器</span></li></ol> 
<h2 id="2.%E5%9F%BA%E4%BA%8Espringboot%E5%BC%80%E5%8F%91web%E9%A1%B9%E7%9B%AE" style="margin-left:0cm;">2. 基于springboot开发web项目</h2> 
<p style="margin-left:0cm;">代码示例</p> 
<p style="margin-left:0cm;">jar包依赖</p> 
<pre><code>&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;
  &lt;version&gt;${springboot.version}&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
  &lt;version&gt;${springboot.version}&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">spring boot启动类</p> 
<pre><code>@SpringBootApplication(scanBasePackages={"com.yej.learning"})

public class App 

{

    public static void main( String[] args )

    {

        /**

         * App.class会设置到SpringApplication中的primarySources参数中

         */

        SpringApplication.run(App.class);

    }

}</code></pre> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">通过上面的代码我们就搭建了一个web项目框架，下面我们分析下相关功能是怎么实现的</p> 
<h2 id="3.%20spring%E5%AE%B9%E5%99%A8%E7%9A%84%E5%88%9B%E5%BB%BA">3. spring容器的创建</h2> 
<p style="margin-left:0cm;">默认创建的spring容器为AnnotationConfigServletWebServerApplicationContext实例</p> 
<ol><li>AnnotationConfigServletWebServerApplicationContext构造方法中会调用父类GenericApplicationContext构造方法new DefaultListableBeanFactory()创建beanFactory</li><li>AnnotationConfigServletWebServerApplicationContext构造方法中会调用 new AnnotatedBeanDefinitionReader(this)方法进行将spring ioc支持组件加入spring 容器AnnotationConfigUtils.registerAnnotationConfigProcessors(this.registry)</li></ol> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">默认创建的spring容器为AnnotationConfigServletWebServerApplicationContext实例org.springframework.boot.SpringApplication#run(java.lang.String...)</p> 
<p style="margin-left:0cm;"><img alt="" height="623" src="https://images2.imgbox.com/e5/8d/X6utJlxY_o.png" width="1027"></p> 
<p style="margin-left:0cm;"><img alt="" height="590" src="https://images2.imgbox.com/a3/57/tYbvWyLw_o.png" width="936"></p> 
<p style="margin-left:0cm;"><img alt="" height="593" src="https://images2.imgbox.com/81/90/h9OHOIFr_o.png" width="1017"></p> 
<p style="margin-left:0cm;">spring容器中beanFactory的创建org.springframework.context.support.GenericApplicationContext#GenericApplicationContext()</p> 
<p style="margin-left:0cm;"><img alt="" height="430" src="https://images2.imgbox.com/cd/e7/uUZXcmZn_o.png" width="1033"></p> 
<p style="margin-left:0cm;">spring ioc支持组件加入spring 容器AnnotationConfigServletWebServerApplicationContext#AnnotationConfigServletWebServerApplicationContext()</p> 
<p style="margin-left:0cm;"><img alt="" height="387" src="https://images2.imgbox.com/32/f0/SuixpWtw_o.png" width="989"></p> 
<p style="margin-left:0cm;"><img alt="" height="466" src="https://images2.imgbox.com/54/05/A8qslri8_o.png" width="1009"></p> 
<p style="margin-left:0cm;"><img alt="" height="631" src="https://images2.imgbox.com/61/95/R8D8SoSW_o.png" width="1100"></p> 
<h2 id="4.%20springboot%E5%90%AF%E5%8A%A8%E7%B1%BB%E5%8A%A0%E5%85%A5spring%E5%AE%B9%E5%99%A8">4. springboot启动类加入spring容器</h2> 
<pre style="margin-left:0cm;"><code class="language-html">spring boot启动时如示例通过SpringApplication.run(App.class)启动，会将run方法参数App类加入到spring容器，通过ConfigurationClassPostProcessor#processConfigBeanDefinitions解析App类时会扫描scanBasePackages配置的包路径下的所有bean并将其加入spring容器。</code></pre> 
<p style="margin-left:0cm;"> org.springframework.boot.SpringApplication#prepareContext</p> 
<p style="margin-left:0cm;"><img alt="" height="606" src="https://images2.imgbox.com/f7/8b/1dOLV1kY_o.png" width="1036"></p> 
<p style="margin-left:0cm;"><img alt="" height="556" src="https://images2.imgbox.com/b2/b9/9T1lkm8c_o.png" width="1023"></p> 
<p style="margin-left:0cm;"><img alt="" height="493" src="https://images2.imgbox.com/7b/13/OS8uGsgs_o.png" width="760"></p> 
<p style="margin-left:0cm;"><img alt="" height="432" src="https://images2.imgbox.com/58/33/O9pl3ARx_o.png" width="850"></p> 
<h2 id="5.%20%E5%9F%BA%E4%BA%8E%E6%9D%A1%E4%BB%B6%E9%85%8D%E7%BD%AEbean" style="margin-left:0cm;">5. 基于条件配置bean</h2> 
<p style="margin-left:0cm;">springboot中有大量的基于条件将bean加入spring容器的配置，我们来分析下。</p> 
<h3 id="5.1%20%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%BF%9B%E8%A1%8C%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD" style="margin-left:0cm;">5.1 什么时候进行条件判断</h3> 
<pre style="margin-left:0cm;"><code class="language-html">spring在扫描到有@Component修饰的类和有@Bean修饰的方法时在创建BeanDefinition注册到spring容器中前都会判断类和方法上是否有Conditional，Conditional不满足时会跳过相关bean的注册。下面示例了两处Conditional条件的判断，整个spring容器加载过程中Conditional条件的判断位置很多，就不一一列举了。org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass</code></pre> 
<p><img alt="" height="639" src="https://images2.imgbox.com/c5/ab/JgGQYVsR_o.png" width="1200"></p> 
<pre style="margin-left:0cm;"><code class="language-html">org.springframework.context.annotation.ConfigurationClassBeanDefinitionReader#loadBeanDefinitionsForBeanMethod</code></pre> 
<p><img alt="" height="590" src="https://images2.imgbox.com/34/6e/cRycAsqp_o.png" width="1192"></p> 
<pre style="margin-left:0cm;"><code class="language-html">org.springframework.context.annotation.ConditionEvaluator#shouldSkip(org.springframework.core.type.AnnotatedTypeMetadata, org.springframework.context.annotation.ConfigurationCondition.ConfigurationPhase)</code></pre> 
<p><img alt="" height="642" src="https://images2.imgbox.com/40/d4/9pgwXIgl_o.png" width="1199"></p> 
<h3 id="5.2%20%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E5%A4%84%E7%90%86%E5%88%86%E6%9E%90">5.2 条件判断处理分析</h3> 
<p style="margin-left:0cm;">获取类或方法上所有Conditional注解中配置的类，通过反射实例化得到Condition对象。依次调用Conditional实例的matches方法进行判断，如果有一个条件不满足则跳过，相关bean不加入spring容器。</p> 
<p style="margin-left:0cm;">org.springframework.context.annotation.ConditionEvaluator#shouldSkip(org.springframework.core.type.AnnotatedTypeMetadata, org.springframework.context.annotation.ConfigurationCondition.ConfigurationPhase)</p> 
<p style="margin-left:0cm;"><img alt="" height="635" src="https://images2.imgbox.com/39/1f/UqhScyXQ_o.png" width="1115"></p> 
<h3 id="5.3%C2%A0%C2%A0%20%C2%A0%E5%B8%B8%E8%A7%81Conditional%E6%B3%A8%E8%A7%A3%E5%88%86%E6%9E%90" style="margin-left:0cm;">5.3 常见Conditional注解分析</h3> 
<pre style="margin-left:0cm;"><code class="language-html">        springboot中有许许多多的基于条件的bean配置，通过自定义Conditional注解实现，常见的有@ConditionalOnBean、@ConditionalOnClass、@ConditionalOnProperty等。自定义Conditional注解是通过引入@Conditional注解并且在@Conditional注解中配置自己的Condition接口实现的。
        springboot中常见的自定义Conditional注解都实现了SpringBootCondition类在调用Conditional实例的matches方法进行判断时会调用到自定义配置的Condition实现类的getMatchOutcome方法进行条件判断。</code></pre> 
<p><img alt="" height="592" src="https://images2.imgbox.com/d9/73/QhZXbSwW_o.png" width="922"></p> 
<pre style="margin-left:0cm;"><code class="language-html">org.springframework.boot.autoconfigure.condition.SpringBootCondition#matches(org.springframework.context.annotation.ConditionContext, org.springframework.core.type.AnnotatedTypeMetadata)</code></pre> 
<p><img alt="" height="556" src="https://images2.imgbox.com/bf/01/gdkon7vv_o.png" width="1159"></p> 
<h4 id="5.3.1%C2%A0%C2%A0%20%C2%A0%40ConditionalOnBean">5.3.1 @ConditionalOnBean</h4> 
<p style="margin-left:0cm;">@ConditionalOnBean的自定义Condition实现类为OnBeanCondition，通过在@ConditionalOnBean注解中配置value、type、annotation、name属性判断spring容器中是否存在相关类型、有相关注解修饰和相关beanName的bean。</p> 
<p style="margin-left:0cm;">org.springframework.boot.autoconfigure.condition.OnBeanCondition#getMatchingBeans</p> 
<p style="margin-left:0cm;"><img alt="" height="593" src="https://images2.imgbox.com/23/7e/ZcnSoYUw_o.png" width="1183"></p> 
<p style="margin-left:0cm;"><img alt="" height="609" src="https://images2.imgbox.com/e4/ba/254t7BMh_o.png" width="1152"></p> 
<p style="margin-left:0cm;"><img alt="" height="482" src="https://images2.imgbox.com/55/05/4PBAxxw2_o.png" width="1160"></p> 
<p style="margin-left:0cm;">org.springframework.boot.autoconfigure.condition.OnBeanCondition#getMatchOutcome</p> 
<p style="margin-left:0cm;">如果value、type、annotation、name 等属性配置存在未匹配到相关bean的情况，返回未匹配ConditionOutcome，反之匹配成功</p> 
<p style="margin-left:0cm;"><img alt="" height="521" src="https://images2.imgbox.com/88/a9/Ii2cbNv5_o.png" width="1200"></p> 
<h4 id="5.3.2%C2%A0%C2%A0%20%C2%A0%40ConditionalOnClass" style="margin-left:0cm;">5.3.2 @ConditionalOnClass</h4> 
<pre style="margin-left:0cm;"><code class="language-html">@ConditionalOnClass的自定义Condition实现类为OnClassCondition，获取ConditionalOnClass注解中配置的值,通过Class.forName过滤没有找到的class,存在未找到的class构建未匹配结果ConditionOutcome返回,所有的class都找到了构建匹配承购ConditionOutcome返回。org.springframework.boot.autoconfigure.condition.OnClassCondition#getMatchOutcome</code></pre> 
<p><img alt="" height="668" src="https://images2.imgbox.com/e4/a2/YQJBRzJt_o.png" width="1200"></p> 
<p><img alt="" height="600" src="https://images2.imgbox.com/c9/f2/iuOtNHLv_o.png" width="957"></p> 
<p><img alt="" height="585" src="https://images2.imgbox.com/ac/b0/8jYkUcCN_o.png" width="1140"></p> 
<h4 id="5.3.3%20%40ConditionalOnProperty">5.3.3 @ConditionalOnProperty</h4> 
<p>@ConditionalOnProperty的自定义Condition实现类为OnPropertyCondition，遍历ConditionalOnProperty注解中配置的name、value，进行前缀拼接，判断资源属性(资源属性的加载可通过spring源码分析第三篇中介绍过通过@PropertySource注解加载资源配置文件)中是否配置相关key，如果未配置或者配置的value与指定值不一致则返回条件匹配不成功。<br> org.springframework.boot.autoconfigure.condition.OnPropertyCondition#getMatchOutcome</p> 
<p><img alt="" height="534" src="https://images2.imgbox.com/30/5a/eUympmAh_o.png" width="1106"></p> 
<p><img alt="" height="614" src="https://images2.imgbox.com/07/42/yZ5HMGTq_o.png" width="1000"></p> 
<pre style="margin-left:0cm;"><code class="language-html">org.springframework.boot.autoconfigure.condition.OnPropertyCondition.Spec#collectProperties</code></pre> 
<p><img alt="" height="641" src="https://images2.imgbox.com/71/fc/MSn7x8Ib_o.png" width="1104"></p> 
<h2 id="6.%20%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE">6. 自动配置</h2> 
<h3 id="6.1%C2%A0%C2%A0%20%C2%A0%E5%8A%A0%E8%BD%BD%E6%89%80%E6%9C%89%E7%9A%84META-INF%2Fspring.factories%E6%96%87%E4%BB%B6%E4%B8%AD%E9%85%8D%E7%BD%AE">6.1 加载所有的META-INF/spring.factories文件中配置</h3> 
<p style="margin-left:0cm;">SpringApplication构造方法中会加载所有的META-INF/spring.factories文件中配置的键值对缓存到SpringFactoriesLoader#cache容器中对应的key为Launcher$AppClassLoader实例</p> 
<p style="margin-left:0cm;">org.springframework.boot.SpringApplication#SpringApplication(org.springframework.core.io.ResourceLoader, java.lang.Class&lt;?&gt;...)</p> 
<p style="margin-left:0cm;"><img alt="" height="482" src="https://images2.imgbox.com/fd/c2/NMS09SCL_o.png" width="1200"></p> 
<p style="margin-left:0cm;"><img alt="" height="633" src="https://images2.imgbox.com/46/2e/9b3Bmwcx_o.png" width="1191"></p> 
<p style="margin-left:0cm;"><img alt="" height="471" src="https://images2.imgbox.com/93/cc/R9dDDUm5_o.png" width="1200"></p> 
<h3 id="6.2%20%E5%B0%86spring.factories%E6%96%87%E4%BB%B6%E4%B8%ADEnableAutoConfiguration%E9%85%8D%E7%BD%AE%E7%B1%BB%E5%8A%A0%E5%85%A5spring" style="margin-left:0cm;">6.2 将spring.factories文件中EnableAutoConfiguration配置类加入spring</h3> 
<pre style="margin-left:0cm;"><code class="language-html">SpringBootApplication注解中通过EnableAutoConfiguration注解import了AutoConfigurationImportSelector类，spring解析AutoConfigurationImportSelector时会获取META-INF/spring.factories文件中配置的key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的class, 获取到spring.factories中key为AutoConfigurationImportFilter配置的filter，filter再根据META-INF/spring-autoconfigure-metadata.properties中配置的ConditionalOnClass、ConditionalOnWebApplication、ConditionalOnBean过滤条件对EnableAutoConfiguration的class进行过滤，然后将过滤后的类加入spring容器org.springframework.boot.autoconfigure.AutoConfigurationImportSelector.AutoConfigurationGroup#process</code></pre> 
<p><img alt="" height="562" src="https://images2.imgbox.com/a7/96/hUmZtwlE_o.png" width="1128"></p> 
<pre style="margin-left:0cm;"><code class="language-html">加载META-INF/spring-autoconfigure-metadata.properties配置文件org.springframework.boot.autoconfigure.AutoConfigurationImportSelector.AutoConfigurationGroup#getAutoConfigurationMetadata</code></pre> 
<p><img alt="" height="495" src="https://images2.imgbox.com/96/b6/0hjZYocu_o.png" width="1144"></p> 
<p><img alt="" height="596" src="https://images2.imgbox.com/c2/ca/P57LlWKl_o.png" width="1141"></p> 
<pre style="margin-left:0cm;"><code class="language-html">加载META-INF/spring.factories文件中配置的key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的类。org.springframework.boot.autoconfigure.AutoConfigurationImportSelector#getAutoConfigurationEntry</code></pre> 
<p><img alt="" height="448" src="https://images2.imgbox.com/10/2c/WbyInzpt_o.png" width="1150"></p> 
<p><img alt="" height="409" src="https://images2.imgbox.com/e9/18/2FMSnVR9_o.png" width="1194"></p> 
<p>获取META-INF/spring.factories文件中配置的key为org.springframework.boot.autoconfigure.AutoConfigurationImportFilter的类并示例化<br> org.springframework.boot.autoconfigure.AutoConfigurationImportSelector#getAutoConfigurationEntry</p> 
<p><img alt="" height="473" src="https://images2.imgbox.com/31/f3/Mc72qHsz_o.png" width="1121"></p> 
<p><img alt="" height="639" src="https://images2.imgbox.com/3b/86/1Pywecrf_o.png" width="1154"></p> 
<p><img alt="" height="459" src="https://images2.imgbox.com/85/fd/rCLsSNLE_o.png" width="1181"></p> 
<p><img alt="" height="564" src="https://images2.imgbox.com/bb/fd/F9sad06t_o.png" width="1200"></p> 
<pre style="margin-left:0cm;"><code class="language-html">配置的AutoConfigurationImportFilter的类为OnBeanCondition,OnClassCondition,OnWebApplicationCondition</code></pre> 
<p><img alt="" height="459" src="https://images2.imgbox.com/b4/d6/HvXOZymH_o.png" width="1045"></p> 
<pre style="margin-left:0cm;"><code class="language-html">根据META-INF/spring-autoconfigure-metadata.properties中配置的ConditionalOnClass、ConditionalOnWebApplication、ConditionalOnBean过滤条件对configurations进行过滤org.springframework.boot.autoconfigure.AutoConfigurationImportSelector#getAutoConfigurationEntry</code></pre> 
<p><img alt="" height="553" src="https://images2.imgbox.com/fc/a2/VkrHECf4_o.png" width="1200"></p> 
<p><img alt="" height="589" src="https://images2.imgbox.com/77/b1/72lIV5l3_o.png" width="1140"></p> 
<pre style="margin-left:0cm;"><code class="language-html">过滤的规则在ConditionalOnClass、ConditionalOnWebApplication、ConditionalOnBean的match方法中有不同的实现org.springframework.boot.autoconfigure.condition.FilteringSpringBootCondition#getOutcomes</code></pre> 
<p><img alt="" height="444" src="https://images2.imgbox.com/6b/e1/CJVzkvK6_o.png" width="1200"></p> 
<pre style="margin-left:0cm;"><code class="language-html">spring.factories文件中EnableAutoConfiguration配置类经过过滤、解析后会加入ConfigurationClassParser的Map&lt;ConfigurationClass, ConfigurationClass&gt; configurationClasses容器，后续加入spring容器org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass</code></pre> 
<p><img alt="" height="584" src="https://images2.imgbox.com/22/b6/FlTlq8Qz_o.png" width="1200"></p> 
<p><img alt="" height="532" src="https://images2.imgbox.com/e8/ba/XRYO9OoH_o.png" width="1200"></p> 
<h2 id="7.%20%E5%86%85%E5%B5%8CTomcat%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E9%85%8D%E7%BD%AE">7. 内嵌Tomcat的创建和配置</h2> 
<h3 id="7.1%20%E5%88%9B%E5%BB%BATomcat%E6%9C%8D%E5%8A%A1%E5%99%A8">7.1 创建Tomcat服务器</h3> 
<p>通过org.springframework.boot.autoconfigure.EnableAutoConfiguration引入配置类ServletWebServerFactoryAutoConfiguration，又通过ServletWebServerFactoryAutoConfiguration import了ServletWebServerFactoryConfiguration.EmbeddedTomcat.class因为spring-boot-starter-web pom 中加入的是tomcat服务器，所有又会通过@Bean将TomcatServletWebServerFactory加入spring容器，从spring中获取ServletWebServerFactory类型的bean拿到TomcatServletWebServerFactory，将创建Tomcat服务器</p> 
<p><img alt="" height="571" src="https://images2.imgbox.com/74/5d/vmXcCqxb_o.png" width="1101"></p> 
<p><img alt="" height="592" src="https://images2.imgbox.com/d2/55/NpHL6eFu_o.png" width="1084"></p> 
<pre style="margin-left:0cm;"><code class="language-html">创建Tomcat服务器org.springframework.boot.web.servlet.context.ServletWebServerApplicationContext#onRefresh</code></pre> 
<p><img alt="" height="563" src="https://images2.imgbox.com/a0/16/WR7UWp4a_o.png" width="1127"></p> 
<p><img alt="" height="599" src="https://images2.imgbox.com/d6/1f/tBviLR7h_o.png" width="1083"></p> 
<p><span style="color:#000000;">org.springframework.boot.web.embedded.tomcat.TomcatServletWebServerFactory#getWebServer</span></p> 
<p><img alt="" height="536" src="https://images2.imgbox.com/82/7b/j65bk1vQ_o.png" width="1020"></p> 
<pre style="margin-left:0cm;"><code class="language-html">启动tomcat服务器，创建非守护进程阻止Tomcat服务器立马关闭org.springframework.boot.web.embedded.tomcat.TomcatWebServer#initialize</code></pre> 
<p><img alt="" height="597" src="https://images2.imgbox.com/33/45/8XwjxVTZ_o.png" width="1200"></p> 
<h3 id="7.2%20DispatcherServlet%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E5%8A%A0%E5%85%A5web%E5%AE%B9%E5%99%A8">7.2 DispatcherServlet的创建和加入web容器</h3> 
<p style="margin-left:0cm;">通过EnableAutoConfiguration引入了配置类DispatcherServletAutoConfiguration，DispatcherServletAutoConfiguration中通过@Bean将DispatcherServlet、DispatcherServletRegistrationBean加入了spring容器，DispatcherServlet实现了ApplicationContextAware接口在初始化方法调用时会将spring容器设置到DispatcherServlet中,spring boot中只有一个spring容器（首次请求web接口时会触发DispatcherServlet.init方法，进而调用到DispatcherServlet#initStrategies方法进行DispatcherServlet的初始化），在Tomcat启动时会调到Tomcat#start方法，进而调用到DispatcherServletRegistrationBean的onStartup方法将DispatcherServlet注册到web容器中。</p> 
<p style="margin-left:0cm;">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration</p> 
<p style="margin-left:0cm;"><img alt="" height="495" src="https://images2.imgbox.com/b7/a0/pQOwbVjc_o.png" width="1200"></p> 
<p style="margin-left:0cm;"><img alt="" height="502" src="https://images2.imgbox.com/81/df/XJebBOQJ_o.png" width="1200"></p> 
<p style="margin-left:0cm;">将spring容器设置到DispatcherServlet中org.springframework.web.servlet.FrameworkServlet#setApplicationContext</p> 
<p style="margin-left:0cm;"><img alt="" height="497" src="https://images2.imgbox.com/04/a9/x6de346o_o.png" width="1200"></p> 
<p style="margin-left:0cm;">将DispatcherServlet加入web容器org.springframework.boot.web.servlet.RegistrationBean#onStartup</p> 
<p style="margin-left:0cm;"><img alt="" height="486" src="https://images2.imgbox.com/22/9d/7GhPCnfk_o.png" width="1057"></p> 
<p style="margin-left:0cm;"><img alt="" height="427" src="https://images2.imgbox.com/9e/e1/gXya6a4u_o.png" width="889"></p> 
<p style="margin-left:0cm;"><img alt="" height="497" src="https://images2.imgbox.com/43/65/6EkZJCEd_o.png" width="1179"></p> 
<h2 id="8.%20springboot%E5%B1%9E%E6%80%A7%E5%8A%A0%E8%BD%BD" style="margin-left:0cm;">8. springboot属性加载</h2> 
<h3 id="8.1%C2%A0%C2%A0%20%C2%A0springboot%E9%BB%98%E8%AE%A4%E5%B1%9E%E6%80%A7%E5%8A%A0%E8%BD%BD%E6%96%87%E4%BB%B6">8.1 springboot默认属性加载文件</h3> 
<p style="margin-left:0cm;">SpringApplication对象实例化时会获取所有的META-INF/spring.factories文件中配置的key为org.springframework.context.ApplicationListener的class通过反射拿到实例设置到listeners容器中，ConfigFileApplicationListener用于加载属性配置文件也是在这时实例化。SpringApplication.run方法会调用到prepareEnvironment方法进而调用到ConfigFileApplicationListener#postProcessEnvironment触发属性文件的加载。org.springframework.boot.SpringApplication#SpringApplication(org.springframework.core.io.ResourceLoader, java.lang.Class&lt;?&gt;...)</p> 
<p style="margin-left:0cm;"><img alt="" height="493" src="https://images2.imgbox.com/9d/97/bRlMj51i_o.png" width="1121"></p> 
<p style="margin-left:0cm;"><img alt="" height="575" src="https://images2.imgbox.com/b9/e2/Rf9lFwgy_o.png" width="1200"></p> 
<p style="margin-left:0cm;">org.springframework.boot.context.config.ConfigFileApplicationListener#postProcessEnvironment</p> 
<p style="margin-left:0cm;"><img alt="" height="473" src="https://images2.imgbox.com/46/87/gLX7MO9d_o.png" width="1200"></p> 
<p style="margin-left:0cm;">获取META-INF/spring.factories 文件中key为org.springframework.boot.env.PropertySourceLoader对应的value,反射获取相关类的实例，spring-boot\spring-boot-project\spring-boot\src\main\resources\META-INF\spring.factories文件中相关key配置的类为PropertiesPropertySourceLoader、YamlPropertySourceLoader。YamlPropertySourceLoader解析"yml", "yaml"后缀的属性文件，PropertiesPropertySourceLoader解析"properties", "xml"后缀的属性文件。解析完后将属性配置文件加入spring容器环境environment中资源属性中。</p> 
<p style="margin-left:0cm;">PropertiesPropertySourceLoader、YamlPropertySourceLoader属性文件加载器的实例化ConfigFileApplicationListener.Loader#Loader</p> 
<p style="margin-left:0cm;"><img alt="" height="598" src="https://images2.imgbox.com/d9/fe/7M76S4QW_o.png" width="1180"></p> 
<p style="margin-left:0cm;">加载属性文件ConfigFileApplicationListener.Loader#load()</p> 
<p style="margin-left:0cm;"><img alt="" height="599" src="https://images2.imgbox.com/78/e1/20aeFlyX_o.png" width="1161"></p> 
<p style="margin-left:0cm;">默认加载DEFAULT_SEARCH_LOCATION常量配置的路径为 "classpath:/,classpath:/config/,file:./,file:./config/"，默认加载文件名为常量DEFAULT_NAMES配置的application</p> 
<p style="margin-left:0cm;"><img alt="" height="613" src="https://images2.imgbox.com/ac/88/Cy7ZAMSG_o.png" width="1137"></p> 
<p style="margin-left:0cm;"><img alt="" height="521" src="https://images2.imgbox.com/a3/1c/ufenqhZn_o.png" width="1153"></p> 
<p style="margin-left:0cm;"><img alt="" height="485" src="https://images2.imgbox.com/5c/a7/DawaaocR_o.png" width="1136"></p> 
<p style="margin-left:0cm;">通过PropertiesPropertySourceLoader、YamlPropertySourceLoader属性文件加载器的实例化进行属性文件的加载</p> 
<p style="margin-left:0cm;"><img alt="" height="610" src="https://images2.imgbox.com/02/81/AgLjtybT_o.png" width="1179"></p> 
<p style="margin-left:0cm;">解析完后将属性文件加入environment的属性资源中</p> 
<p style="margin-left:0cm;">org.springframework.boot.context.config.ConfigFileApplicationListener.Loader#load()</p> 
<p style="margin-left:0cm;"><img alt="" height="575" src="https://images2.imgbox.com/1e/8b/Ot36E93g_o.png" width="993"></p> 
<p style="margin-left:0cm;"><img alt="" height="533" src="https://images2.imgbox.com/bf/f0/ewUMVO5b_o.png" width="966"></p> 
<h3 id="8.2%20springboot%E9%85%8D%E7%BD%AEbean%E7%9A%84%E6%89%AB%E6%8F%8F%E5%92%8C%E5%88%9D%E5%A7%8B%E5%8C%96" style="margin-left:0cm;">8.2 springboot配置bean的扫描和初始化</h3> 
<p style="margin-left:0cm;">springboot web服务我们可以通过在application.yml进行下面的配置指定tomcat的端口，通过8.1我们知道springboot会将application.yml属性文件加载到springenvironment属性资源中。然后springboot会将属性资源的配置设置到org.springframework.boot.autoconfigure.web.ServerProperties bean中，我们分析下相关功能是怎么实现的。</p> 
<p style="margin-left:0cm;"><img alt="" height="323" src="https://images2.imgbox.com/55/51/lHR6Gg2q_o.png" width="792"></p> 
<h4 id="8.2.1%20ServerProperties%E6%B3%A8%E5%86%8C%E5%88%B0spring%E5%AE%B9%E5%99%A8" style="margin-left:0cm;">8.2.1 ServerProperties注册到spring容器</h4> 
<pre style="margin-left:0cm;"><code class="language-html">ServerProperties是通过ServletWebServerFactoryAutoConfiguration bean上的@EnableConfigurationProperties(ServerProperties.class)注解加入到spring容器的。@EnableConfigurationProperties注解import了EnableConfigurationPropertiesRegistrar，EnableConfigurationPropertiesRegistrar实现了ImportBeanDefinitionRegistrar接口，在registerBeanDefinitions方法中：1.将ConfigurationPropertiesBindingPostProcessor、ConfigurationPropertiesBinder.Factory、ConfigurationPropertiesBinder、ConfigurationBeanFactoryMetadata注册到spring容器中 2.将EnableConfigurationProperties注解中配置的class注册到spring容器。
</code></pre> 
<p><img alt="" height="522" src="https://images2.imgbox.com/08/ff/6FwK8W9s_o.png" width="1049"></p> 
<pre style="margin-left:0cm;"><code class="language-html">org.springframework.boot.context.properties.EnableConfigurationPropertiesRegistrar#registerBeanDefinitions</code></pre> 
<p><img alt="" height="636" src="https://images2.imgbox.com/76/e4/pE7p1rs2_o.png" width="1160"></p> 
<p>将EnableConfigurationProperties注解中配置的class注册到spring容器</p> 
<p><img alt="" height="483" src="https://images2.imgbox.com/c8/37/JoLdOmxJ_o.png" width="1125"></p> 
<p>org.springframework.boot.context.properties.ConfigurationPropertiesBeanRegistrar#register(java.lang.Class&lt;?&gt;)</p> 
<p><img alt="" height="508" src="https://images2.imgbox.com/21/06/Dthsizo5_o.png" width="1037"></p> 
<h4 id="8.2.2%20ServerProperties%E5%B1%9E%E6%80%A7%E6%B3%A8%E5%85%A5">8.2.2 ServerProperties属性注入</h4> 
<pre style="margin-left:0cm;"><code class="language-html">上面分析到ServerProperties通过@EnableConfigurationProperties注解的解析加入到spring容器，ServerProperties的属性注入依赖于EnableConfigurationPropertiesRegistrar引入的bean,主要是ConfigurationPropertiesBindingPostProcessor，bean初始化之前会调用到ConfigurationPropertiesBindingPostProcessor.postProcessBeforeInitialization方法，处理有ConfigurationProperties注解修饰的bean,从spring environment的资源属性中获取配置的值设置到bean中。org.springframework.boot.context.properties.ConfigurationPropertiesBindingPostProcessor#postProcessBeforeInitialization</code></pre> 
<p><img alt="" height="468" src="https://images2.imgbox.com/f3/53/evRNeUh3_o.png" width="1113"></p> 
<pre style="margin-left:0cm;"><code class="language-html">org.springframework.boot.context.properties.bind.Binder#bindDataObject</code></pre> 
<p><img alt="" height="616" src="https://images2.imgbox.com/0f/b0/5cizFzhD_o.png" width="1099"></p> 
<pre style="margin-left:0cm;"><code class="language-html">org.springframework.boot.context.properties.bind.JavaBeanBinder#bind(org.springframework.boot.context.properties.bind.DataObjectPropertyBinder, org.springframework.boot.context.properties.bind.JavaBeanBinder.Bean&lt;T&gt;, org.springframework.boot.context.properties.bind.JavaBeanBinder.BeanSupplier&lt;T&gt;)</code></pre> 
<p><img alt="" height="643" src="https://images2.imgbox.com/8b/3e/nmX0VVpP_o.png" width="1190"></p> 
<p><img alt="" height="540" src="https://images2.imgbox.com/c2/7a/IvQC0BuK_o.png" width="1200"></p> 
<p><img alt="" height="565" src="https://images2.imgbox.com/87/f7/nYf1iaCc_o.png" width="1066"></p> 
<pre style="margin-left:0cm;"><code class="language-html">org.springframework.boot.context.properties.bind.Binder#findProperty</code></pre> 
<p><img alt="" height="548" src="https://images2.imgbox.com/82/b5/L94Uv9z0_o.png" width="1157"></p> 
<pre style="margin-left:0cm;"><code class="language-html">这里的context.getSources()获取到的属性资源是在Binder创建时获取到通过PropertySourcesDeducer#extractEnvironmentPropertySources()方法拿到spring容器environment中的属性资源设置到Binder中org.springframework.boot.context.properties.ConfigurationPropertiesBinder#bind</code></pre> 
<p><img alt="" height="416" src="https://images2.imgbox.com/b5/b2/K4Gj1KGM_o.png" width="1007"></p> 
<p><img alt="" height="465" src="https://images2.imgbox.com/36/dd/TmftW1PG_o.png" width="1127"></p> 
<p style="margin-left:0cm;">org.springframework.boot.context.properties.ConfigurationPropertiesBinder#ConfigurationPropertiesBinder</p> 
<p style="margin-left:0cm;"><img alt="" height="551" src="https://images2.imgbox.com/f9/53/jCRpMDzh_o.png" width="1200"></p> 
<p style="margin-left:0cm;"><img alt="" height="502" src="https://images2.imgbox.com/49/60/7El006CQ_o.png" width="1053"></p> 
<p style="margin-left:0cm;"><img alt="" height="516" src="https://images2.imgbox.com/75/49/LNYtz9SQ_o.png" width="1175"></p> 
<p style="margin-left:0cm;">到这里我们就完成了springboot主要功能点的源码分析</p> 
<p style="margin-left:0cm;"> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d2693754423c66ffbc0723018c460272/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">lotus-miner 设置多个存储路径</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f73c3fb628747505e2bf427bc3145285/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">面试官问我：如何设计 QQ、微信等第三方账号登陆 ？还要我说出数据库表设计！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>