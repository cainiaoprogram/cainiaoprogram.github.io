<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机网络——网络层——OSPF协议的介绍 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算机网络——网络层——OSPF协议的介绍" />
<meta property="og:description" content="什么是 OSPF ？ OSPF 是一个基于链路状态的自治系统内部路由协议，在 TCP/IP 的网络层中进行路由选择，常用于构建大型企业网络或者服务上的骨干网络。在互联网核心路由器之间也可以使用。
OSPF 概述 OSPF 使用的是 Dijkstra（最短路径算法）来计算路径，从而构建网络拓扑图。是一种开放性协议，规范公开，允许不同厂商的设备之间实现兼容。
在网络拓扑发生变化时，OSPF 能够迅速适应，通过更新路由表实现快速收敛，确保数据按最短路径传输。
OSPF 将网络划分为区域（Area），每个区域都有自己的数据库，区域之间通过边界路由器连接。 OSPF 将网络划分为区域，其中 Backbone Area（区域0）是所有其他区域的中心，提高了可扩展性。
OSPF 使用链路成本作为度量单位，用于计算路径开销。成本越小，路径的优先级越高。
OSPF 能够适应网络拓扑的变化，比如链路的添加、删除或者变化。它可以快速适应网络的变化并更新路由信息。
文章目录 什么是 OSPF ？ OSPF 概述为什么要使用 OSPF 协议OSPF 的不足OSPF 协议与其他链路状态协议的比较：OSPF 的三张表OSPF 建立邻居关系OSPF 使用的分层结构OSPF 的邻居关系链路状态数据库（LSDB）的同步最短路径计算 OSPF 的运行过程总结 为什么要使用 OSPF 协议 OSPF在设计上具有高度的可扩展性、灵活性和快速收敛的特点，适用于构建复杂网络环境。从而为许多的企业和厂商提供了选择。以下是OSPF的优点：
快速收敛： OSPF具有快速的网络收敛能力。当网络拓扑发生变化时，OSPF能够迅速适应，并在相对较短的时间内更新路由表，确保数据包能够按最优路径传输。
支持分层设计： OSPF的设计允许将网络划分为多个区域，其中Backbone Area（区域0）是所有其他区域的中心。这种分层设计提高了网络的可扩展性。
开放性和厂商中立性： OSPF是一种开放协议，其规范公开可用，使得不同厂商的设备能够实现兼容的OSPF协议。这种开放性有助于确保多样性和互操作性。
支持VLSM（Variable Length Subnet Masking）： OSPF支持可变长度子网掩码（VLSM），允许网络管理员更有效地分配IP地址，提高地址利用率。
灵活的策略控制： OSPF允许管理员通过区域设计、路由汇总和过滤等方式对路由信息进行精确的控制。这使得网络管理员能够更好地适应特定的网络需求和策略。
适应多样化网络环境： OSPF适用于多样化的网络环境，包括企业内部网络、服务提供商的骨干网络以及互联网核心路由器之间的连接。其灵活性使得它能够适应不同规模和类型的网络。
支持IPv4和IPv6： OSPF可以同时支持IPv4和IPv6，使得在网络过渡期或者纯IPv6环境中都能够灵活使用。
强大的安全特性： OSPF支持加密和身份验证机制，如MD5认证，以确保路由器之间的通信的安全性。
OSPF 的不足 OSPF 是一种强大而灵活的路由协议，但它也有一些缺点。在选择使用 OSPF 的时候，最好是先权衡其优点和缺点，考虑网络环境的部署和需求。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e30dca5c22b2c1405a3063a5b4442f63/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-14T17:21:18+08:00" />
<meta property="article:modified_time" content="2023-12-14T17:21:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机网络——网络层——OSPF协议的介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_OSPF__0"></a>什么是 OSPF ？</h3> 
<p>OSPF 是一个基于链路状态的自治系统内部路由协议，在 TCP/IP 的网络层中进行路由选择，常用于构建大型企业网络或者服务上的骨干网络。在互联网核心路由器之间也可以使用。</p> 
<h2><a id="OSPF__3"></a>OSPF 概述</h2> 
<p>OSPF 使用的是 Dijkstra（最短路径算法）来计算路径，从而构建网络拓扑图。是一种开放性协议，规范公开，允许不同厂商的设备之间实现兼容。<br> 在网络拓扑发生变化时，OSPF 能够迅速适应，通过更新路由表实现快速收敛，确保数据按最短路径传输。<br> OSPF 将网络划分为区域（Area），每个区域都有自己的数据库，区域之间通过边界路由器连接。 OSPF 将网络划分为区域，其中 Backbone Area（区域0）是所有其他区域的中心，提高了可扩展性。<br> OSPF 使用链路成本作为度量单位，用于计算路径开销。成本越小，路径的优先级越高。<br> OSPF 能够适应网络拓扑的变化，比如链路的添加、删除或者变化。它可以快速适应网络的变化并更新路由信息。</p> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_OSPF__0" rel="nofollow">什么是 OSPF ？</a></li></ul> 
  </li><li><a href="#OSPF__3" rel="nofollow">OSPF 概述</a></li><li><ul><li><a href="#_OSPF__11" rel="nofollow">为什么要使用 OSPF 协议</a></li><li><a href="#OSPF__24" rel="nofollow">OSPF 的不足</a></li><li><a href="#OSPF__36" rel="nofollow">OSPF 协议与其他链路状态协议的比较：</a></li><li><a href="#OSPF__47" rel="nofollow">OSPF 的三张表</a></li><li><a href="#OSPF__81" rel="nofollow">OSPF 建立邻居关系</a></li><li><a href="#OSPF__113" rel="nofollow">OSPF 使用的分层结构</a></li><li><a href="#OSPF__137" rel="nofollow">OSPF 的邻居关系</a></li><li><a href="#LSDB_159" rel="nofollow">链路状态数据库（LSDB）的同步</a></li><li><a href="#_184" rel="nofollow">最短路径计算</a></li></ul> 
  </li><li><a href="#OSPF__203" rel="nofollow">OSPF 的运行过程</a></li><li><a href="#_229" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<h3><a id="_OSPF__11"></a>为什么要使用 OSPF 协议</h3> 
<p>OSPF在设计上具有高度的可扩展性、灵活性和快速收敛的特点，适用于构建复杂网络环境。从而为许多的企业和厂商提供了选择。以下是OSPF的优点：</p> 
<ol><li> <p>快速收敛： OSPF具有快速的网络收敛能力。当网络拓扑发生变化时，OSPF能够迅速适应，并在相对较短的时间内更新路由表，确保数据包能够按最优路径传输。</p> </li><li> <p>支持分层设计： OSPF的设计允许将网络划分为多个区域，其中Backbone Area（区域0）是所有其他区域的中心。这种分层设计提高了网络的可扩展性。</p> </li><li> <p>开放性和厂商中立性： OSPF是一种开放协议，其规范公开可用，使得不同厂商的设备能够实现兼容的OSPF协议。这种开放性有助于确保多样性和互操作性。</p> </li><li> <p>支持VLSM（Variable Length Subnet Masking）： OSPF支持可变长度子网掩码（VLSM），允许网络管理员更有效地分配IP地址，提高地址利用率。</p> </li><li> <p>灵活的策略控制： OSPF允许管理员通过区域设计、路由汇总和过滤等方式对路由信息进行精确的控制。这使得网络管理员能够更好地适应特定的网络需求和策略。</p> </li><li> <p>适应多样化网络环境： OSPF适用于多样化的网络环境，包括企业内部网络、服务提供商的骨干网络以及互联网核心路由器之间的连接。其灵活性使得它能够适应不同规模和类型的网络。</p> </li><li> <p>支持IPv4和IPv6： OSPF可以同时支持IPv4和IPv6，使得在网络过渡期或者纯IPv6环境中都能够灵活使用。</p> </li><li> <p>强大的安全特性： OSPF支持加密和身份验证机制，如MD5认证，以确保路由器之间的通信的安全性。</p> </li></ol> 
<h3><a id="OSPF__24"></a>OSPF 的不足</h3> 
<p>OSPF 是一种强大而灵活的路由协议，但它也有一些缺点。在选择使用 OSPF 的时候，最好是先权衡其优点和缺点，考虑网络环境的部署和需求。</p> 
<ol><li>复杂性：<br> OSPF的配置和管理相对较复杂，尤其是在大型网络中。需要经验丰富的管理员来正确配置和维护OSPF。</li><li>资源消耗：<br> OSPF需要较多的计算和内存资源来维护链路状态数据库。在大型网络中，可能会导致路由器资源的过度消耗。</li><li>收敛时间：<br> 尽管OSPF相对于某些距离矢量协议有更快的收敛时间，但在某些情况下，特别是在网络拓扑发生较大变化时，仍可能出现较长的收敛时间。</li><li>区域设计复杂性：<br> OSPF的区域设计需要谨慎考虑，不当的设计可能导致网络不稳定。这增加了配置的复杂性。</li></ol> 
<h3><a id="OSPF__36"></a>OSPF 协议与其他链路状态协议的比较：</h3> 
<ol><li>OSPF vs. RIP（Routing Information Protocol）：<br> OSPF更适用于大型、复杂的网络，而RIP通常用于小型网络。OSPF有更好的可扩展性和更快的收敛时间，但RIP更简单，易于配置。</li><li>OSPF vs. IS-IS（Intermediate System to Intermediate System）：<br> IS-IS是一种类似于OSPF的链路状态协议，但通常在ISP网络中使用。IS-IS在某些方面可能更为灵活，但配置和管理可能较为复杂。</li><li>OSPF vs. EIGRP（Enhanced Interior Gateway Routing Protocol）：<br> EIGRP是一种混合型协议，结合了链路状态和距离矢量的优点。在某些情况下，EIGRP可能更容易配置，但它是Cisco专有协议，不具备OSPF的厂商中立性。</li><li>OSPF vs. BGP（Border Gateway Protocol）：<br> BGP通常用于互联网核心路由器之间，而OSPF通常用于内部网络。BGP更强调策略和自治系统之间的路由选择。</li></ol> 
<h3><a id="OSPF__47"></a>OSPF 的三张表</h3> 
<p>三张表在 OSPF 中相互关联，协同工作，确保 OSPF 路由器能够有效地计算最短路径，并维护邻居关系。它们是 OSPF 协议正常运行和数据包转发的关键组成部分。邻居表，链路状态数据库，路由表。</p> 
<ol><li> <p>邻居表<br> 邻居表是 OSPF 协议中的一张表格，用于存储 OSPF 路由器与其直接相邻的其他路由器的信息。邻居表是 OSPF 路由器在邻居关系建立和维护过程中的一种数据结构，其中记录了关于邻居路由器的重要信息。</p> 
  <ul><li>邻居路由器的Router ID： 用于唯一标识邻居路由器的标识符。</li><li>邻居状态（Neighbor State）： 记录了邻居路由器的状态，包括Init、Two-way、Exstart、Exchange、Loading和Full等状态。这些状态是通过 OSPF 邻居状态机的状态转换而改变的。</li><li>邻居路由器的IP地址： 记录了邻居路由器的IP地址。</li><li>Hello计时器（Hello Timer）： 记录了下一次发送 Hello 消息的计时器。</li><li>DR（Designated Router）和BDR（Backup Designated Router）信息： 记录了邻居路由器所选举的 DR 和 BDR。</li><li> 
    <blockquote> 
     <p>邻居表的维护是通过 OSPF 路由器之间的 Hello 消息的交换来实现的。Hello 消息包含了有关发送路由器的信息，包括 Router ID、优先级、Hello 间隔等。通过 Hello 消息的交换，路由器能够建立邻居关系，并将邻居的信息记录在邻居表中。</p> 
    </blockquote> </li></ul> </li><li> <p>链路状态数据表<br> 在 OSPF 协议中，链路状态数据库是一张表格，用于存储网络中所有路由器和链路的状态信息。LSDB 是 OSPF 路由器用于计算最短路径的基础，其中包含了网络拓扑的关键信息。</p> 
  <ul><li>LSA（链路状态通告）： LSDB 中包含各种类型的 LSA，每个 LSA 描述了网络拓扑中的不同方面。常见的 LSA 类型包括： 
    <ul><li>Type 1 LSA（Router LSA）： 描述单个路由器的连接信息。</li><li>Type 2 LSA（Network LSA）： 描述多个路由器连接到同一网络的信息。</li><li>Type 3 LSA（Summary LSA）： 描述区域之间的汇总信息。</li><li>Type 4 LSA（ASBR Summary LSA）： 描述用于到达 ASBR（Autonomous System Border Router）的路径。</li><li>Type 5 LSA（AS External LSA）： 描述来自其他AS的外部路由信息。</li></ul> </li><li>Router ID： 每个 LSA 都与发布它的路由器相关联，并使用 Router ID 进行唯一标识。</li><li>序列号（Sequence Number）： 每个 LSA 都有一个序列号，用于跟踪 LSA 的更新和变化。</li><li>链路状态数据库的同步： OSPF 路由器通过交换 Database Description（DBD）消息和链路状态更新（Link State Update，LSU）消息来同步各自的 LSDB。这确保所有路由器对网络拓扑具有相同的视图。</li><li>最短路径树计算： OSPF 使用 Dijkstra 算法基于 LSDB 中的信息计算最短路径，构建最短路径树。</li><li>定期刷新： LSDB 中的 LSA 在其生命周期内会定期刷新，以确保信息的实时性。</li><li> 
    <blockquote> 
     <p>链路状态数据库是 OSPF 运作的核心，为 OSPF 路由器提供了构建和维护网络拓扑的关键信息。通过 LSDB，路由器能够动态地计算到达网络中所有目的地的最短路径。</p> 
    </blockquote> </li></ul> </li><li> <p>路由表<br> 路由表是路由器上的一张表格，用于存储路由器在转发数据包时使用的路由信息。路由表包含了路由器所知的目的地网络以及到达这些网络的下一跳路由器和出接口等信息。在 OSPF 协议中，路由表是通过最短路径计算构建的，基于链路状态数据库（LSDB）中的信息。</p> 
  <ul><li>目的地网络（Destination Network）： 表示数据包要达到的目标网络地址。</li><li>下一跳路由器（Next Hop Router）： 表示数据包离开当前路由器后，下一个负责将数据包转发到目标网络的路由器的IP地址。</li><li>出接口（Outgoing Interface）： 表示数据包离开路由器的接口，通过这个接口将数据包发送到下一跳路由器。</li><li>度量值（Metric）： 表示到达目的地网络的路径的度量，可以是跳数、带宽、延迟等，具体取决于路由协议。</li><li>优先级（Priority）： 有时路由表中可能包含优先级信息，用于指示某个路由的优先级，常见于一些策略路由的情况。</li><li> 
    <blockquote> 
     <p>在 OSPF 中，路由表是通过计算最短路径树而生成的。最短路径树是基于 OSPF 路由器维护的链路状态数据库（LSDB）中的链路状态信息计算得到的，它反映了到达网络中所有目的地的最短路径。</p> 
    </blockquote> </li><li> 
    <blockquote> 
     <p>维护和更新路由表是路由器的核心功能之一。当网络拓扑发生变化时，路由器会相应地更新路由表，以确保它反映了最新的网络状态。这样，路由器就能够有效地转发数据包，选择最短路径来达到目的地。</p> 
    </blockquote> </li></ul> </li></ol> 
<h3><a id="OSPF__81"></a>OSPF 建立邻居关系</h3> 
<p>OSPF 路由器通过交换 Hello 消息来建立邻接关系。以下是 OSPF 建立邻居关系的基本过程：</p> 
<ol><li>Hello 消息发送： 
  <ul><li>OSPF 路由器通过在其连接的网络上周期性地发送 Hello 消息来通告自己的存在。这些 Hello 消息用于探测相邻的 OSPF 路由器。</li></ul> </li><li>Hello 消息的内容： 
  <ul><li>Hello 消息包含了路由器的一些基本信息，如Router ID、Area ID、网络掩码等。其中，Router ID 是 OSPF 中唯一标识路由器的值。</li></ul> </li><li>Hello 消息的接收： 
  <ul><li>当一个 OSPF 路由器收到另一个路由器发送的 Hello 消息时，它会检查 Hello 消息中的信息，以判断两者是否能够建立邻接关系。</li></ul> </li><li>邻居条件的满足： 
  <ul><li>在 Hello 消息中，路由器会指定 Hello 消息的发送间隔、Router Dead Interval（路由器失效时间）等参数。</li><li>两个路由器能够建立邻接关系的条件包括：</li></ul> </li></ol> 
<blockquote> 
 <p>Hello 消息的参数匹配。<br> 双方在各自的 Hello 消息中都能检测到对方。</p> 
 <blockquote> 
  <p>假设有两个 OSPF 路由器，分别连接到同一网络，路由器A和路由器B都在连接的网络上发送 Hello 消息。消息中包含了Router ID，Area ID，Router Priority等。如果 Hello 消息中的满足了建立邻接关系的条件，满足参数比配，且双方都能检测到对方，那么就满足了建立邻居的条件，则进行邻居状态的转换。<br> <img src="https://images2.imgbox.com/e5/60/05VUn524_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0d/98/vVE09hlp_o.png" alt="在这里插入图片描述"></p> 
 </blockquote> 
</blockquote> 
<p>邻居状态的转换：</p> 
<ul><li>如果两个 OSPF 路由器满足邻居条件，它们会进入邻居状态。邻居状态的转换包括以下几个阶段：</li></ul> 
<blockquote> 
 <p>Down： 路由器尚未检测到邻居。<br> Init：发送了 Hello 消息，但尚未收到对方的 Hello 消息。<br> Two-way： 双方都收到了对方的 Hello消息，但还未建立完全的邻接关系。<br> ExStart： 在这个阶段，路由器交换 Master/Slave 信息，以决定 DBD（Database Description）包的发送顺序。<br> Exchange： 路由器交换 DBD 包，其中包含链路状态数据库的摘要信息。<br> Loading：接收到摘要信息后，开始请求缺失的链路状态信息。<br> Full： 完成链路状态数据库的同步，邻居状态转为 Full，表示邻接已建立。</p> 
</blockquote> 
<p>一旦邻接关系建立，路由器之间就可以交换链路状态信息，构建链路状态数据库，进而进行最短路径计算。 Hello 消息的周期性发送和邻接状态的监测保证了 OSPF 网络能够动态适应拓扑的变化。</p> 
<h3><a id="OSPF__113"></a>OSPF 使用的分层结构</h3> 
<p>OSPF 采用了分层的结构，将网络划分为不同的区域，这种分层有助于提高网络的可扩展性和管理效率。为构建复杂而庞大的网络提供了灵活性和性能的优势。 以下列出了 OSPF 的分层结构：</p> 
<ol><li>区域（Area）：<br> OSPF网络被划分为一个或多个区域，每个区域由一个32位的标识符（Area ID）唯一标识。所有的 OSPF路由器都必须属于至少一个区域，而且有些路由器可能同时属于多个区域。</li><li>骨干区域（Backbone Area）：<br> 骨干区域是所有其他区域的中心，它有一个特殊的标识符，称为骨干区域的标识符（Backbone Area ID），通常为0.0.0.0。所有的非骨干区域都必须连接到骨干区域，这种连接通常是通过位于骨干区域的一个或多个路由器实现的。</li><li>非骨干区域（Non-Backbone Area）：<br> 除了骨干区域外，所有其他的区域都是非骨干区域。这些区域可以被划分为更小的区域，以进一步提高网络的可扩展性。</li><li>区域边界路由器（Area Border Router，ABR）：<br> 区域边界路由器是连接两个或多个区域的路由器，它位于至少两个区域的交界处。ABR 负责在相邻的区域之间交换路由信息，并确保区域之间的通信。</li><li>自治系统边界路由器（Autonomous System Border Router，ASBR）：<br> ASBR 是连接 OSPF 域和其他自治系统（AS）的路由器，负责在 OSPF 网络和其他自治系统之间进行路由信息的交换。</li></ol> 
<blockquote> 
 <blockquote> 
  <p><img src="https://images2.imgbox.com/29/89/fe8OqbQl_o.png" alt="在这里插入图片描述"><br> 骨干必须在所有其他区域的中心，其他区域必须连接到骨干。主要原因是OSPF希望所有区域都将路由信息注人到骨干区域，再由骨干把信息分布到其他区域。骨干区域的另一个重要要求是它必须是连续的。话句话说，不允许分割区域0</p> 
 </blockquote> 
 <p>分层结构的优点包括：</p> 
 <ul><li> <p>可扩展性： 将网络划分为区域允许更好地管理大规模的网络，减少了每个路由器需要维护的信息量。</p> </li><li> <p>管理简便： 区域的分离简化了路由器的配置和管理，提高了网络的可维护性。</p> </li><li> <p>快速收敛： 分层结构使得 OSPF 能够更快速地适应网络拓扑的变化，实现快速的网络收敛。</p> </li></ul> 
</blockquote> 
<h3><a id="OSPF__137"></a>OSPF 的邻居关系</h3> 
<p>OSPF 的邻居关系建立是协议正常运行的关键部分，确保路由器能够相互通信、同步链路状态数据库（LSDB）并计算最短路径。以下是 OSPF 邻居关系的主要特点和步骤：</p> 
<ol><li>Hello 消息交换：</li></ol> 
<ul><li>OSPF 路由器通过发送 Hello 消息来发现周围的 OSPF 邻居。Hello 消息包含了路由器的标识符、Hello 间隔、Dead 间隔等信息。</li><li>Hello 消息的发送和接收是邻居关系建立的起点。</li></ul> 
<ol start="2"><li>邻居状态机的变化：</li></ol> 
<ul><li>邻居关系的建立过程中，路由器的邻居状态机可能会发生变化。邻居状态机定义了邻居关系的不同状态，包括 Down（停机状态）、Attempt（尝试状态）、Init（初始化状态）、2-Way（两向状态）、ExStart（交换起始状态）、Exchange（交换状态）、Loading（加载状态）和 Full（完全状态）等。</li><li>Hello 消息的接收和邻居状态机的状态变化是邻居关系建立的核心。</li></ul> 
<ol start="3"><li>邻居状态机的状态变化导致邻居关系的建立：</li></ol> 
<ul><li>当邻居状态机的状态达到 Full 状态时，表示邻居关系建立成功。</li><li>在 Full 状态下，路由器之间开始进行链路状态数据库（LSDB）的同步，交换数据库描述消息（DBD）以及链路状态更新消息（LSU）。</li></ul> 
<ol start="4"><li>DBD 消息的交换：</li></ol> 
<ul><li>一旦邻居关系建立，路由器之间开始交换 DBD 消息，其中包含了 LSDB 的摘要信息。</li></ul> 
<ol start="5"><li>LSDB 同步：</li></ol> 
<ul><li>在 DBD 消息交换的基础上，链路状态请求消息（LSR）和链路状态更新消息（LSU）的传递，实现了 LSDB 的同步。邻居路由器通过 LSR 请求需要的链路状态信息，然后通过 LSU 响应提供详细的信息。</li><li>邻居关系的建立确保了 OSPF 网络中相邻的路由器能够相互了解并共享链路状态信息，从而构建一个动态的拓扑图。这使得 OSPF 路由器能够计算到达网络中所有目的地的最短路径，并维护更新的路由表，以支持高效的数据包转发。</li></ul> 
<blockquote> 
 <p>邻居关系的建立确保了 OSPF 网络中相邻的路由器能够相互了解并共享链路状态信息，从而构建一个动态的拓扑图。这使得 OSPF 路由器能够计算到达网络中所有目的地的最短路径，并维护更新的路由表，以支持高效的数据包转发。</p> 
</blockquote> 
<h3><a id="LSDB_159"></a>链路状态数据库（LSDB）的同步</h3> 
<p>链路状态数据库（LSDB）的同步是 OSPF（Open Shortest Path First）协议中的一个关键过程，它确保在 OSPF 网络中的路由器之间保持相同的链路状态信息。LSDB 包含了网络中所有路由器和链路的状态信息，是 OSPF 路由器用于计算最短路径的基础。</p> 
<p>以下是链路状态数据库同步的主要步骤：</p> 
<ol><li>Hello 消息交换：</li></ol> 
<ul><li>OSPF 路由器使用 Hello 消息进行邻居关系的建立。当两个相邻的路由器建立了邻居关系，它们开始进行链路状态数据库的同步。</li></ul> 
<ol start="2"><li>数据库描述消息（DBD）的交换：</li></ol> 
<ul><li>在邻居关系建立后，路由器之间开始交换 DBD 消息。DBD 消息包含了发送路由器的 LSDB 的摘要信息。</li><li>DBD 消息交换的目的是确定哪些 LSA（链路状态通告）需要传输。</li></ul> 
<ol start="3"><li>链路状态请求消息（LSR）的传递：</li></ol> 
<ul><li>如果某个路由器在 LSDB 中缺少特定的 LSA，它可以发送链路状态请求消息（LSR）请求邻居路由器提供该 LSA。</li><li>LSR 消息携带了请求的 LSA 类型和标识符。</li></ul> 
<ol start="4"><li>链路状态更新消息（LSU）的传递：</li></ol> 
<ul><li>邻居路由器收到 LSR 请求后，会回应相应的链路状态更新消息（LSU），其中包含了被请求的 LSA 的详细信息。</li><li>LSU 消息的传递实现了对缺失 LSA 的请求响应，并完成了对 LSDB 的同步。</li></ul> 
<ol start="5"><li>链路状态确认消息（LSAck）的交换：</li></ol> 
<ul><li>收到链路状态更新消息后，路由器发送链路状态确认消息（LSAck）以确认接收到的链路状态信息。这有助于确保链路状态信息的正确传递。</li></ul> 
<blockquote> 
 <p>整个过程确保了 OSPF 路由器之间的链路状态数据库保持同步。链路状态的变化（如链路的增加、删除或状态的改变）会触发这个同步过程，以确保所有路由器在 LSDB 中具有相同的视图，从而能够计算相同的最短路径。这种动态的同步机制使得 OSPF 能够适应网络拓扑的变化。<br> 这是收到LSR后回复的LSU报文，LSR请求了11条，LSU把这11条链路状态的详细信息回复给对方。比如LSR请求的第1条链路状态详细信息，LSU回复的是这样：<br> <img src="https://images2.imgbox.com/84/b4/RPqFS5If_o.jpg" alt="请添加图片描述"></p> 
</blockquote> 
<h3><a id="_184"></a>最短路径计算</h3> 
<p>OSPF（Open Shortest Path First）协议使用最短路径优先（Shortest Path First, SPF）算法来计算网络中的最短路径。这一算法的核心是根据链路状态数据库（LSDB）中的信息构建最短路径树，以确定到达网络中所有目的地的最短路径。以下是 OSPF 最短路径计算的主要步骤：</p> 
<ol><li>链路状态数据库（LSDB）的构建： 
  <ul><li>OSPF 路由器维护一个链路状态数据库（LSDB），其中包含了网络中所有路由器和链路的状态信息。这些信息是通过邻居路由器之间的 Hello 消息交换和链路状态更新消息（LSU）传递而来的。</li></ul> </li><li>最短路径树的构建： 
  <ul><li>OSPF 使用 Dijkstra 最短路径优先算法来构建最短路径树。该算法从一个起点（通常是本地路由器）开始，逐步扩展树的边，选择当前距离最短的边并添加相应的节点到树中，直到所有的节点都被包含在最短路径树中。</li><li>最短路径树的根节点是起点，每个节点表示一个路由器，边表示网络中的链路。通过该树，可以找到到达网络中任何目的地的最短路径。</li></ul> </li><li>计算最短路径： 
  <ul><li>最短路径计算考虑了链路的权重，权重通常是与链路的带宽相关。 OSPF 使用链路的带宽作为默认的权重，但管理员可以配置其他参数来影响权重计算。</li><li>路由器在计算最短路径时，选择具有最小累积权重的路径。累积权重是路径上所有链路的权重之和。</li></ul> </li><li>路由表的更新： 
  <ul><li>最短路径计算完成后，路由器将最短路径信息转化为路由表的形式，以便在转发数据包时进行快速查找。路由表包含了到达目的地的最短路径信息，以及下一跳路由器的标识符。</li></ul> </li><li>定期更新和响应拓扑变化： 
  <ul><li>OSPF 路由器会定期发送 Hello 消息以保持邻居关系，并根据链路状态的变化更新链路状态数据库和最短路径树。</li></ul> </li></ol> 
<blockquote> 
 <p>最短路径计算使得 OSPF 能够动态地适应网络拓扑的变化，确保始终选择最短路径来转发数据包。这有助于提高网络的性能和稳定性。<br> 我们要寻找从a点到f点的最短路径，下面图上的数字表示权重，代表每经过一个节点要付出的代价。<img src="https://images2.imgbox.com/1a/6f/ReRsCFsm_o.png" alt="请添加图片描述">经过最短路径计算最后得到<img src="https://images2.imgbox.com/56/e3/J455Vs0w_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<h2><a id="OSPF__203"></a>OSPF 的运行过程</h2> 
<p>OSPF 协议的运行过程可以分为以下几个阶段，从开始到完成涵盖了路由器的相互发现、邻居关系的建立、链路状态数据库（LSDB）的同步和最短路径计算。以下是一般情况下的 OSPF 运行过程：</p> 
<ol><li>Hello 消息交换：</li></ol> 
<ul><li>发现相邻路由器： 路由器通过发送 Hello 消息来发现周围的 OSPF 路由器。Hello 消息包含了路由器的标识符、Hello 间隔、Dead 间隔等信息。</li><li>邻居关系建立： 如果两个路由器能够相互接收对方的 Hello 消息，它们就建立了邻居关系。这标志着 OSPF 的邻居关系建立阶段的开始。</li></ul> 
<ol start="2"><li>邻居关系建立和状态机：</li></ol> 
<ul><li>Hello 消息的接收和检查： 接收到 Hello 消息的路由器检查其中的信息，包括发送方的标识符等。</li><li>邻居状态机的变化： 根据 Hello 消息，邻居状态机的状态可能会发生变化。邻居状态机包括 Down、Attempt、Init、2-Way、ExStart、Exchange、Loading 和 Full 等状态。</li></ul> 
<ol start="3"><li>DBD 消息的交换：</li></ol> 
<ul><li>数据库描述消息（DBD）： 在邻居关系建立后，路由器之间开始交换 DBD 消息，这些消息携带了 LSDB 的摘要信息。</li></ul> 
<ol start="4"><li>LSDB 同步：</li></ol> 
<ul><li>链路状态请求消息（LSR）： 如果某个路由器在 LSDB 中缺少信息，它可以发送 LSR 消息请求邻居路由器提供特定的 LSA。</li><li>链路状态更新消息（LSU）： 在 DBD 交换和 LSR 请求的基础上，路由器通过 LSU 消息向邻居路由器传递链路状态信息的详细内容，以便更新邻居的 LSDB。</li><li>链路状态确认消息（LSAck）： 路由器发送 LSAck 消息以确认接收到的链路状态信息。</li></ul> 
<ol start="5"><li>最短路径计算：</li></ol> 
<ul><li>最短路径树的构建： 路由器使用链路状态数据库中的信息构建最短路径树，计算到达网络中所有目的地的最短路径。</li><li>路由表更新： 最短路径计算完成后，路由器更新其路由表，将最短路径信息存储在路由表中。</li></ul> 
<blockquote> 
 <p>整个过程确保了 OSPF 网络中路由器具有相同的链路状态数据库，能够计算最短路径，并通过路由表更新实现高效的数据包转发。这种动态的协议允许 OSPF 网络在拓扑发生变化时适应并重新计算最短路径，保证网络的稳定性和高效性。</p> 
</blockquote> 
<h2><a id="_229"></a>总结</h2> 
<p>这篇文章主要是讲了 OSPF 的概述，OSPF 路由器之间的互相发现；LSA和LSDB；LSDB的同步；最短路径的计算；OSPF的优点和应用；OSPF 的消息类型。</p> 
<p>在 OSPF 的学习过程中需要注意以下的重点：</p> 
<pre><code>层级结构理解： 掌握 OSPF 的分层设计，包括区域、邻居关系、最短路径计算等。理解 OSPF 的层级结构有助于建立对其工作原理的整体认识。

邻居关系的重要性： 掌握 OSPF 中邻居关系的建立，以及 DR 和 BDR 的选举过程。这对于理解 OSPF 在广播网络和非广播网络中的运作至关重要。

LSA 和 LSDB 的角色： 解释 LSA（链路状态通告）的作用，以及每个 OSPF 路由器维护的 LSDB（链路状态数据库）。强调 LSDB 的同步过程，确保所有路由器对网络拓扑具有相同的视图。

最短路径计算原理： 详细学习 OSPF 如何使用 Dijkstra 算法进行最短路径计算。这包括 LSDB 的构建和最短路径树的生成。

Hello 消息的作用： 掌握 Hello 消息的重要性，它不仅用于路由器之间的相互发现，还触发了邻居关系的建立和维护。

DR 和 BDR 的用途： 学习 DR 和 BDR 在 OSPF 网络中的重要作用，包括负责生成和分发 LSA，以及在 DR 失效时，BDR 接管 DR 的角色。

调整参数的影响： 掌握 OSPF 中参数的调整对网络行为的影响，如 Router Priority 和权重（Cost）的调整。

实际应用和场景： 将理论知识与实际应用相结合，介绍 OSPF 在实际网络环境中的应用和配置。

网络稳定性和收敛速度： 着重强调 OSPF 在网络稳定性和收敛速度方面的优势，以及它是大型企业和互联网骨干网络中常用的协议。
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d14a17b176cbdcf9d729c5771713ded4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Fegin 原理框架</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/71d47da53cd2b0831bdf190e793fdcc3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Milvus 老友汇｜AI、云原生与向量数据库的精彩碰撞回顾！</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>