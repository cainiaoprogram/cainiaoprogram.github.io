<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring AOP源码分析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring AOP源码分析" />
<meta property="og:description" content="目录
1、AOP是什么
2、AOP 的作用及其优势
3、AOP 的底层实现
3.1 JDK动态代理：
3.2 CGLIB动态代理
4、AOP相关概念
5、AOP运行流程图
6、AOP源码解析
6.1 源码解析须知
6.2 注册自动代理创建器
6.3 触发后置处理器
6.4 创建Proxy过程分析
6.5 代理回调增强
6.6 增强器执行
6.7 增强器执行顺序
7、源码总结
1、AOP是什么 AOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。
AOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。
直接看一个例子：
业务接口及其实现
public interface UserService { public void login(String name ,int length); } @Service public class UserServiceImpl implements UserService { public void login(String name, int length) { System.out.println(&#34;-----我是一个接口,我的信息：用户-&#34; &#43; name &#43; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fbc7f1285b84427b53df324bf582dc05/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-02T16:41:00+08:00" />
<meta property="article:modified_time" content="2023-11-02T16:41:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring AOP源码分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p style="margin-left:0px;"> </p> 
<p style="margin-left:40px;"><a href="#1%E3%80%81AOP%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">1、AOP是什么</a></p> 
<p style="margin-left:40px;"><a href="#2%E3%80%81AOP%20%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%85%B6%E4%BC%98%E5%8A%BF" rel="nofollow">2、AOP 的作用及其优势</a></p> 
<p style="margin-left:40px;"><a href="#3%E3%80%81AOP%20%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0" rel="nofollow">3、AOP 的底层实现</a></p> 
<p style="margin-left:80px;"><a href="#3.1%20JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%9A" rel="nofollow">3.1 JDK动态代理：</a></p> 
<p style="margin-left:80px;"><a href="#3.2%20CGLIB%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" rel="nofollow">3.2 CGLIB动态代理</a></p> 
<p style="margin-left:40px;"><a href="#4%E3%80%81AOP%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5" rel="nofollow">4、AOP相关概念</a></p> 
<p style="margin-left:40px;"><a href="#5%E3%80%81AOP%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE" rel="nofollow">5、AOP运行流程图</a></p> 
<p style="margin-left:40px;"><a href="#6%E3%80%81AOP%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" rel="nofollow">6、AOP源码解析</a></p> 
<p style="margin-left:80px;"><a href="#6.1%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E9%A1%BB%E7%9F%A5" rel="nofollow">6.1 源码解析须知</a></p> 
<p style="margin-left:80px;"><a href="#6.2%20%E6%B3%A8%E5%86%8C%E8%87%AA%E5%8A%A8%E4%BB%A3%E7%90%86%E5%88%9B%E5%BB%BA%E5%99%A8" rel="nofollow">6.2 注册自动代理创建器</a></p> 
<p style="margin-left:80px;"><a href="#6.3%20%E8%A7%A6%E5%8F%91%E5%90%8E%E7%BD%AE%E5%A4%84%E7%90%86%E5%99%A8" rel="nofollow">6.3 触发后置处理器</a></p> 
<p style="margin-left:80px;"><a href="#6.4%20%E5%88%9B%E5%BB%BAProxy%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90" rel="nofollow">6.4 创建Proxy过程分析</a></p> 
<p style="margin-left:80px;"><a href="#6.5%20%E4%BB%A3%E7%90%86%E5%9B%9E%E8%B0%83%E5%A2%9E%E5%BC%BA" rel="nofollow">6.5 代理回调增强</a></p> 
<p style="margin-left:80px;"><a href="#6.6%20%E5%A2%9E%E5%BC%BA%E5%99%A8%E6%89%A7%E8%A1%8C" rel="nofollow">6.6 增强器执行</a></p> 
<p style="margin-left:80px;"><a href="#6.7%20%E5%A2%9E%E5%BC%BA%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F" rel="nofollow">6.7 增强器执行顺序</a></p> 
<p style="margin-left:40px;"><a href="#7%E3%80%81%E6%BA%90%E7%A0%81%E6%80%BB%E7%BB%93" rel="nofollow">7、源码总结</a></p> 
<hr> 
<p> </p> 
<h3>1、AOP是什么</h3> 
<p>AOP 为 Aspect Oriented Programming 的缩写，意思为面向切面编程，是通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。</p> 
<p>AOP 是 OOP 的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p> 
<p>直接看一个例子：</p> 
<p><strong>业务接口及其实现</strong></p> 
<pre><code class="language-html">public interface UserService {
   public void login(String name ,int length);
}</code></pre> 
<pre><code class="language-html">@Service
public class UserServiceImpl implements UserService {
   public void login(String name, int length) {
      System.out.println("-----我是一个接口,我的信息：用户-" + name + ", 长度-" +length+"-----") ;
   }
}</code></pre> 
<p><strong>切面类</strong></p> 
<pre><code class="language-html">@Component
@Aspect
public class MyAspect {
​
   @Around("execution(* com.ydt.spring02.service.UserServiceImpl.*(..))")
   public void around(ProceedingJoinPoint point) throws Throwable {
      System.out.println("-----大哥，我来了-----");
      point.proceed();
      System.out.println("-----大哥，我走了-----");
   }</code></pre> 
<p><strong>Spring核心配置</strong></p> 
<pre><code class="language-html">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
      xmlns:context="http://www.springframework.org/schema/context"
      xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
                             http://www.springframework.org/schema/beans/spring-beans.xsd
                     http://www.springframework.org/schema/context
                             http://www.springframework.org/schema/context/spring-context.xsd
                          http://www.springframework.org/schema/aop
                             http://www.springframework.org/schema/aop/spring-aop.xsd
   "&gt;
​
   &lt;context:component-scan base-package="com.ydt.spring02"/&gt;
  &lt;!--
        proxy-target-class="true" 基于基类，使用cglib库，但是它并不是唯一决定走CGLIB的条件，Spring现在做了自适应
        proxy-target-class="false" 先判断目标对象类是否基于接口，如果是：使用JDK动态代理，如果不是：使用CGLIB
        expose-proxy="true"暴露当前代理对象为ThreadLocal模式，代理对象属于当前线程，对其他线程而言是隔离的，使用AopContext.currentProxy()获取当前代理
            如果是单例模式对象的代理对象，设置为true有毛用；多例情况下，存在内存泄漏问题，当前线程结束了，
            没有了Key，但是ThreadLocalMap还存在，不过AOP为我们考虑了这一点，进行代理对象移除，大家看着用吧
    --&gt;
    &lt;aop:aspectj-autoproxy expose-proxy="true"/&gt;
&lt;/beans&gt;</code></pre> 
<p><strong>测试</strong></p> 
<pre><code class="language-html">@Test
public void test(){
   ApplicationContext context =
         new ClassPathXmlApplicationContext("applicationContext02.xml");
   System.out.println("-------------------------------------------------");
   UserService userService = context.getBean(UserService.class);
   userService.login("laohu", 18);
   System.out.println("-------------------------------------------------");
}</code></pre> 
<p><img src="https://images2.imgbox.com/04/13/zO6X611x_o.png" alt="20210122173428269.png"></p> 
<h3>2、AOP 的作用及其优势</h3> 
<p>作用：在程序运行期间，在不修改源码的情况下对方法进行功能增强 优势：减少重复代码，提高开发效率，并且便于维护</p> 
<h3>3、AOP 的底层实现</h3> 
<p>实际上，AOP 的底层是通过 Spring 提供的的动态代理技术实现的。在运行期间，Spring通过动态代理技术动态的生成代理对象，代理对象方法执行时进行增强功能的介入，在去调用目标对象的方法，从而完成功能的增强。</p> 
<p><strong>Spring AOP 的动态代理技术</strong></p> 
<p>JDK 代理 : 基于接口的动态代理技术 Cglib 代理：基于父类的动态代理技术</p> 
<p>原理图：</p> 
<p><img src="https://images2.imgbox.com/d0/1c/BqaqK4s4_o.png" alt="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1eGlhbmcxOTg1MTExNA==,size_16,color_FFFFFF,t_70"></p> 
<p> </p> 
<p>简单代码实现Jdk动态代理和Cglib动态代理</p> 
<h4>3.1 JDK动态代理：</h4> 
<p>目标类接口</p> 
<pre><code class="language-html">public interface TargetInterface {
    public void method();
}
​</code></pre> 
<p>目标类</p> 
<pre><code class="language-html">public class Target implements TargetInterface {
    @Override
    public void method() {
        System.out.println("Target running....");
    }
}
​</code></pre> 
<p> </p> 
<p>动态代理代码</p> 
<pre><code class="language-html">        Target target = new Target();
        TargetInterface proxyObj = (TargetInterface) Proxy.newProxyInstance(
                target.getClass().getClassLoader(),
                target.getClass().getInterfaces(),
                new InvocationHandler() {
                    @Override
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                        System.out.println("-------执行前增强------");
                        method.invoke(userService, null);
                        System.out.println("-------执行后增强------");
                        return null;
                    }
                }
        );
       </code></pre> 
<p>测试执行：</p> 
<pre><code class="language-html"> //测试执行,当调用接口的任何方法时，代理对象的代码都无需修改
 proxy.method(); </code></pre> 
<h4><strong>3.2 CGLIB动态代理</strong></h4> 
<p>目标类</p> 
<pre><code class="language-html">public class Target {
    public void method() {
        System.out.println("Target running....");
    }
}</code></pre> 
<p>动态代理代码</p> 
<pre><code class="language-html">        Target userService = new Target(); //创建目标对象•
        Enhancer enhancer = new Enhancer(); //创建增强器•
        enhancer.setSuperclass(Target.class); //设置父类•
        enhancer.setCallback(new MethodInterceptor() { //设置回调•    @Override•
            public Object intercept(Object o, Method method, Object[] objects,
                                    MethodProxy methodProxy) throws Throwable {
                System.out.println("-------执行前增强------");
                Object invoke = method.invoke(userService, objects);
                System.out.println("-------执行后增强------");
                return invoke;
            }
        });
        Target proxy = (Target) enhancer.create(); //创建代理对象</code></pre> 
<p>测试执行：</p> 
<pre><code class="language-html"> //测试执行,当调用接口的任何方法时，代理对象的代码都无需修改
 proxy.method(); </code></pre> 
<h3>4、AOP相关概念</h3> 
<ul><li> <p>Target（目标对象）：代理的目标对象</p> </li><li> <p>Proxy （代理）：一个类被 AOP 织入增强后，就产生一个结果代理类</p> </li><li> <p>Joinpoint（连接点）：所谓连接点是指那些被拦截到的点。在spring中,这些点指的是方法，因为spring只支持方法类型的连接点</p> </li><li> <p>Pointcut（切入点）：所谓切入点是指我们要对哪些 Joinpoint 进行拦截的定义</p> </li><li> <p>Advice（通知/ 增强）：所谓通知是指拦截到 Joinpoint 之后所要做的事情就是通知</p> </li><li> <p>Aspect（切面）：是切入点和通知（引介）的结合</p> </li><li> <p>Weaving（织入）：是指把增强应用到目标对象来创建新的代理对象的过程。</p> </li></ul> 
<h3>5、AOP运行流程图</h3> 
<p><img src="https://images2.imgbox.com/87/77/U83pZdUP_o.png" alt="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1eGlhbmcxOTg1MTExNA==,size_16,color_FFFFFF,t_70"></p> 
<h3>6、AOP源码解析</h3> 
<h4><strong>6.1 源码解析须知</strong></h4> 
<ul><li> <p>在使用ApplicationContext相关实现类加载bean的时候，会针对所有单例且非懒加载的bean，在构造ApplicationContext的时候就会创建好这些bean，而不会等到使用的时候才去创建。这也就是单例bean默认非懒加载的应用</p> </li><li> <p>读者需要了解BeanPostProcessor的相关使用，所有实现BeanPostProcessor接口的类，在初始化bean的时候都会调用这些类的方法，一般用于在bean初始化前或后对bean做一些修改。而AOP的功能实现正式基于此，在bean初始化后创建针对该bean的proxy，然后返回给用户该proxy</p> </li><li> <p>结合以上两点，被代理后的bean，实际在ApplicationContext构造完成之后就已经被创建完成，getBean()的操作直接从singletonObjects中获取即可</p> </li></ul> 
<p> </p> 
<h4>6.2 注册自动代理创建器</h4> 
<p>还记得上一节课我们在解析xml生成遍历文档树的时候，有几个标签不是默认解析的那个地方吗？</p> 
<pre><code class="language-html">/************************************DefaultBeanDefinitionDocumentReader.java*******************************/
protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) {
   if (delegate.isDefaultNamespace(root)) {
      NodeList nl = root.getChildNodes();
      for (int i = 0; i &lt; nl.getLength(); i++) {
         Node node = nl.item(i);
         if (node instanceof Element) {
            Element ele = (Element) node;
            if (delegate.isDefaultNamespace(ele)) {
               /*default namespace 涉及到的就四个标签
               * &lt;import /&gt;、&lt;alias /&gt;、&lt;bean /&gt; 和 &lt;beans /&gt;
               */
               parseDefaultElement(ele, delegate);
            }
            else {
               /*
               * 其他的属于 custom（拓展）如我们经常会使用到的
               * &lt;mvc /&gt;、&lt;task /&gt;、&lt;context /&gt;、&lt;aop /&gt;等
               */
               delegate.parseCustomElement(ele);
            }
         }
      }
   }
   else {
      delegate.parseCustomElement(root);
   }
}</code></pre> 
<p>但凡注解都有对应的解析器，以用来解析该注解的行为。而且所有的解析器父类为： NamespaceHandlerSupport全局搜索之后可发现(其实你也可以通过调用链来查看)</p> 
<p><img src="https://images2.imgbox.com/84/d9/hqR7n7mw_o.png" alt="2021012217351167.png"></p> 
<pre><code class="language-html">//org.springframework.aop.config.AopNamespaceHandler类中有对应的解析行为，代码如下：
public class AopNamespaceHandler extends NamespaceHandlerSupport {
    @Override
    public void init() {
        // In 2.0 XSD as well as in 2.1 XSD.
        registerBeanDefinitionParser("config", new ConfigBeanDefinitionParser());
         //看这里---AOP自动代理Bean定义对象解析器注册
        registerBeanDefinitionParser("aspectj-autoproxy", new AspectJAutoProxyBeanDefinitionParser());
        registerBeanDefinitionDecorator("scoped-proxy", new ScopedProxyBeanDefinitionDecorator());
 
        // Only in 2.0 XSD: moved to context namespace as of 2.1
        registerBeanDefinitionParser("spring-configured", new SpringConfiguredBeanDefinitionParser());
    }
}</code></pre> 
<p>看看AspectJAutoProxyBeanDefinitionParser这个解析器是一个啥玩意，他实现了BeanDefinitionParser的parse方法</p> 
<pre><code class="language-html">class AspectJAutoProxyBeanDefinitionParser implements BeanDefinitionParser {
​
    @Override
    @Nullable
    public BeanDefinition parse(Element element, ParserContext parserContext) {
        //开始注册切面注解自动代理创建器
        AopNamespaceUtils.registerAspectJAnnotationAutoProxyCreatorIfNecessary(parserContext, element);
        extendBeanDefinition(element, parserContext);
        return null;
    }
    //..............................................................
}</code></pre> 
<h4>6.3 触发后置处理器</h4> 
<p>通过以上的代码分析，可知，AspectJAutoProxyBeanDefinitionParser主要的功能就是将<strong>AnnotationAwareAspectJAutoProxyCreator</strong>注册到Spring容器中，把bean交给Spring去托管。AnnotationAwareAspectJAutoProxyCreator的功能我们大胆猜测一下：应该也就是生成对象的代理类的相关功能，这个我们接下来再看。</p> 
<p>前面我们说了AOP是基于BeanPostProcessor后置处理器来实现的，通过查看AnnotationAwareAspectJAutoProxyCreator的类层次结构，可知，其实现了<strong>BeanPostProcessor</strong>接口，实现类为AbstractAutoProxyCreator（这里就是<strong>模板模式</strong>） :</p> 
<p><img src="https://images2.imgbox.com/b0/8f/izI1JNJf_o.png" alt="20210122173520532.png"></p> 
<p>AbstractAutoProxyCreator主要方法</p> 
<pre><code class="language-html">    
    /*********************************AbstractAutoProxyCreator.java************************/
    //前置方法啥也不干，直接返回
    public Object postProcessBeforeInitialization(Object bean, String beanName) {
        return bean;
    }
 
    // 主要看这个方法，在bean初始化之后对生产出的bean进行包装
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        //对象实例化、属性注入完成后
        // 在initializeBean.applyBeanPostProcessorsAfterInitialization方法中触发
        //PS:AnnotationAwareAspectJAutoProxyCreator他爹实现的后置处理器（看下面调用链截图）
        if (bean != null) {
            Object cacheKey = getCacheKey(bean.getClass(), beanName);
            if (!this.earlyProxyReferences.contains(cacheKey)) {
                 //生成动态代理对象并且包装起来
                return wrapIfNecessary(bean, beanName, cacheKey);
            }
        }
        return bean;
    }</code></pre> 
<p><img src="https://images2.imgbox.com/c4/f3/UCWdNRCd_o.png" alt="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1eGlhbmcxOTg1MTExNA==,size_16,color_FFFFFF,t_70"></p> 
<p>总结：</p> 
<p>1）通过AspectJAutoProxyBeanDefinitionParser类将AnnotationAwareAspectJAutoProxyCreator注册到Spring容器中</p> 
<p>2）AnnotationAwareAspectJAutoProxyCreator类的postProcessAfterInitialization()方法将所有有advice的bean重新包装成proxy---&gt;wrapIfNecessary()</p> 
<h4>6.4 创建Proxy过程分析</h4> 
<p>6.4.1 进入AOP拦截器</p> 
<pre><code class="language-html">/*********************************AbstractAutoProxyCreator.java************************/
protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
   //..........................................
   // Create proxy if we have advice.
   // 意思就是如果该类有advice（增强,还有可能有多个）则创建proxy，这个里面还对所有增强进行了排序
   Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
   if (specificInterceptors != DO_NOT_PROXY) {
      this.advisedBeans.put(cacheKey, Boolean.TRUE);
      // 将普通的Bean替换成代理Bean
      Object proxy = createProxy(
            bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
      this.proxyTypes.put(cacheKey, proxy.getClass());
      return proxy;
   }

   this.advisedBeans.put(cacheKey, Boolean.FALSE);
   return bean;
}</code></pre> 
<p><strong>6.4.2 创建代理工厂</strong></p> 
<pre><code class="language-html">/*********************************AbstractAutoProxyCreator.java************************/
protected Object createProxy(Class&lt;?&gt; beanClass, @Nullable String beanName,
			@Nullable Object[] specificInterceptors, TargetSource targetSource) {
		//保存代理类真实的类型，代理对象执行反射调用的时候还得用
		//public static final String ORIGINAL_TARGET_CLASS_ATTRIBUTE =
		//			Conventions.getQualifiedAttributeName(AutoProxyUtils.class, "originalTargetClass");
		if (this.beanFactory instanceof ConfigurableListableBeanFactory) {
			AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) this.beanFactory, beanName, beanClass);
		}
		// 1.创建ProxyFactory，proxy对象的生产主要就是在ProxyFactory做的（FactoryBean）
		ProxyFactory proxyFactory = new ProxyFactory();
		proxyFactory.copyFrom(this);

		//判断有没有设置proxy-target-class="true" ,默认为false
		if (!proxyFactory.isProxyTargetClass()) {
			//配置了还不行，还得判断该Bean是否包含接口
			//如果不包含，将来要使用CGLIB方式
			//如果包含，还是走JDK方式，并且将接口设置到ProxyFactory代理工厂
			if (shouldProxyTargetClass(beanClass, beanName)) {
				proxyFactory.setProxyTargetClass(true);
			}
			else {
				evaluateProxyInterfaces(beanClass, proxyFactory);
			}
		}
		// 2.将当前bean适合的advice，重新封装下，封装为Advisor类，然后添加到ProxyFactory中
		Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
		proxyFactory.addAdvisors(advisors);
		proxyFactory.setTargetSource(targetSource);
		customizeProxyFactory(proxyFactory);
		//冻结代理工厂，此时不允许其他线程来对该对象再次代理
		proxyFactory.setFrozen(this.freezeProxy);
		if (advisorsPreFiltered()) {
			proxyFactory.setPreFiltered(true);
		}
		// 3.调用getProxy获取bean对应的proxy（命名怎么跟getBean一个德行?）
		return proxyFactory.getProxy(getProxyClassLoader());
	}</code></pre> 
<p>6.4.3 创建何种类型的Proxy</p> 
<pre><code class="language-html">    /*********************************ProxyFactory.java************************/
	public Object getProxy(@Nullable ClassLoader classLoader) {
		//这里有两个方法
		//createAopProxy()--&gt;得到代理工具类对象：JdkDynamicAopProxy or ObjenesisCglibAopProxy
		//getProxy() ---&gt;得到原始bean的代理对象
		return createAopProxy().getProxy(classLoader);
	}
 	
    /*********************************ProxyCreatorSupport.java************************/
    // createAopProxy()方法就是决定究竟创建何种类型的proxy
	protected final synchronized AopProxy createAopProxy() {
		//生成代理对象工具类的计数，避免生成多个
		if (!this.active) {
			activate();
		}
		//获取AOP代理工厂并且创建AOP代理工具类（工厂方法模式）
		return getAopProxyFactory().createAopProxy(this);
	}
 
 	/*********************************DefaultAopProxyFactory.java************************/
    public AopProxy createAopProxy(AdvisedSupport config) throws AopConfigException {
		//isOptimize() :是否使用优化的代理策略(ThreadLocal线程变量 线程隔离)，默认就是false，可以通过expose-proxy="true"改变
		//isProxyTargetClass()：是否直接代理目标类以及任何接口。默认false，可以通过proxy-target-class="true"改变
		//hasNoUserSuppliedProxyInterfaces :确定提供的切面类是否只有SpringProxy指定的接口，或者根本没有指定代理接口
		if (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) {
			Class&lt;?&gt; targetClass = config.getTargetClass();
			if (targetClass == null) {
				throw new AopConfigException("TargetSource cannot determine target class: " +
						"Either an interface or a target is required for proxy creation.");
			}
			if (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) {
				//JDK分支
				return new JdkDynamicAopProxy(config);
			}
			//CGLIB分支
			return new ObjenesisCglibAopProxy(config);
		}
		else {
			//默认走JDK分支
			return new JdkDynamicAopProxy(config);
		}
	}</code></pre> 
<p>6.4.4 生成代理对象</p> 
<pre><code class="language-html">/*********************************JdkDynamicAopProxy.java************************/
public Object getProxy(@Nullable ClassLoader classLoader) {
		if (logger.isTraceEnabled()) {
			logger.trace("Creating JDK dynamic proxy: " + this.advised.getTargetSource());
		}
		//得到目标类接口，SpringProxy,Advised,DecoratingProxy,都要进行反向代理
		Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(this.advised, true);
		//排除equals,hashCode等基类方法的增强，如果有这种增强，直接结束
		findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);
		//进入JDK动态代理方法,这个就不说了，你不可再改了
		return Proxy.newProxyInstance(classLoader, proxiedInterfaces, this);
	}</code></pre> 
<pre><code class="language-html">/*********************************CglibAopProxy.java************************/
public Object getProxy(@Nullable ClassLoader classLoader) {
   if (logger.isTraceEnabled()) {
      logger.trace("Creating CGLIB proxy: " + this.advised.getTargetSource());
   }

   try {
      //判断是否有增强父类存在
      Class&lt;?&gt; rootClass = this.advised.getTargetClass();
      Assert.state(rootClass != null, "Target class must be available for creating a CGLIB proxy");

      Class&lt;?&gt; proxySuperClass = rootClass;
      if (rootClass.getName().contains(ClassUtils.CGLIB_CLASS_SEPARATOR)) {
         proxySuperClass = rootClass.getSuperclass();
         Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();
         for (Class&lt;?&gt; additionalInterface : additionalInterfaces) {
            this.advised.addInterface(additionalInterface);
         }
      }

      // Validate the class, writing log messages as necessary.
      validateClassIfNecessary(proxySuperClass, classLoader);

      // CGLIB增强器
      Enhancer enhancer = createEnhancer();
      if (classLoader != null) {
         //设置类加载器
         enhancer.setClassLoader(classLoader);
         if (classLoader instanceof SmartClassLoader &amp;&amp;
               ((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) {
            enhancer.setUseCache(false);
         }
      }
      //设置父类
      enhancer.setSuperclass(proxySuperClass);
      //需要设置SpringProxy,Advised增强接口，跟JDK动态代理一样，用于反射
      enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
      enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
      enhancer.setStrategy(new ClassLoaderAwareGeneratorStrategy(classLoader));

      //设置增强回调
      Callback[] callbacks = getCallbacks(rootClass);
      Class&lt;?&gt;[] types = new Class&lt;?&gt;[callbacks.length];
      for (int x = 0; x &lt; types.length; x++) {
         types[x] = callbacks[x].getClass();
      }
      // fixedInterceptorMap only populated at this point, after getCallbacks call above
      enhancer.setCallbackFilter(new ProxyCallbackFilter(
            this.advised.getConfigurationOnlyCopy(), this.fixedInterceptorMap, this.fixedInterceptorOffset));
      enhancer.setCallbackTypes(types);

      // 生成代理类和代理对象，这个就跟之前代理模式一样了
      return createProxyClassAndInstance(enhancer, callbacks);
   }
   catch (CodeGenerationException | IllegalArgumentException ex) {
      throw new AopConfigException("Could not generate CGLIB subclass of " + this.advised.getTargetClass() +
            ": Common causes of this problem include using a final class or a non-visible class",
            ex);
   }
   catch (Throwable ex) {
      // TargetSource.getTarget() failed
      throw new AopConfigException("Unexpected AOP exception", ex);
   }
}</code></pre> 
<h4>6.5 代理回调增强</h4> 
<pre><code class="language-html">	/*********************************JdkDynamicAopProxy.java************************/
	/**
	 * 重写了InvocationHandler的invoke回调方法，在此处增强
	 */
	public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
		Object oldProxy = null;
		boolean setProxyContext = false;
		//目标源
		TargetSource targetSource = this.advised.targetSource;
		Object target = null;

		try {
			// 以下的几个判断，判断目标对象有没有实现Object类的equals、hashCode等Object的方法重写
			// 如果没有，不进行增强，直接调用Object里面对应的方法
			if (!this.equalsDefined &amp;&amp; AopUtils.isEqualsMethod(method)) {
				// The target does not implement the equals(Object) method itself.
				return equals(args[0]);
			}
			else if (!this.hashCodeDefined &amp;&amp; AopUtils.isHashCodeMethod(method)) {
				// The target does not implement the hashCode() method itself.
				return hashCode();
			}
			else if (method.getDeclaringClass() == DecoratingProxy.class) {
				// There is only getDecoratedClass() declared -&gt; dispatch to proxy config.
				return AopProxyUtils.ultimateTargetClass(this.advised);
			}
			else if (!this.advised.opaque &amp;&amp; method.getDeclaringClass().isInterface() &amp;&amp;
					method.getDeclaringClass().isAssignableFrom(Advised.class)) {
				// Service invocations on ProxyConfig with the proxy config...
				return AopUtils.invokeJoinpointUsingReflection(this.advised, method, args);
			}

			Object retVal;
			//如果当前通知暴露了代理，则将当前执行对象使用currentProxy()方法变为当前对象代理
			if (this.advised.exposeProxy) {
				// Make invocation available if necessary.
				oldProxy = AopContext.setCurrentProxy(proxy);
				setProxyContext = true;
			}

			// Get as late as possible to minimize the time we "own" the target,
			// in case it comes from a pool.
			// 获得目标对象.
			target = targetSource.getTarget();
			Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);

			// Get the interception chain for this method.
			//获取当前方法配置的拦截方法链（有可能多个增强），通过适配器获取适handler（多个Interceptor）
			List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);

			// Check whether we have any advice. If we don't, we can fallback on direct
			// reflective invocation of the target, and avoid creating a MethodInvocation.
			if (chain.isEmpty()) {
				// We can skip creating a MethodInvocation: just invoke the target directly
				// Note that the final invoker must be an InvokerInterceptor so we know it does
				// nothing but a reflective operation on the target, and no hot swapping or fancy proxying.
				// 如果拦截器为空，那么直接调用target的对应方法，并获取方法返回值.
				Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
				retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);
			}
			else {
				// 为目标对象创建方法回调对象，需要在调用通知之后才调用目标对象的方法
				MethodInvocation invocation =
						new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);
				// 依次调用拦截器链，这是一个递归实现.
				retVal = invocation.proceed();
			}

			// 方法有返回值，则将代理对象作为方法返回.
			Class&lt;?&gt; returnType = method.getReturnType();
			if (retVal != null &amp;&amp; retVal == target &amp;&amp;
					returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;
					!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) {
				//如果目标在另一个返回的对象中设置对自身的引用，我们将无法帮助A
				retVal = proxy;
			}
			else if (retVal == null &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) {
				throw new AopInvocationException(
						"Null return value from advice does not match primitive return type for: " + method);
			}
			return retVal;
		}
		finally {
			if (target != null &amp;&amp; !targetSource.isStatic()) {
				// 释放目标对象
				targetSource.releaseTarget(target);
			}
			if (setProxyContext) {
				//将代理对象工具类对象设置到当前上下文,下次继续用
				AopContext.setCurrentProxy(oldProxy);
			}
		}
	}</code></pre> 
<p>适配器和handler所在包目录：</p> 
<p><img src="https://images2.imgbox.com/45/d3/icClcyqj_o.png" alt="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1eGlhbmcxOTg1MTExNA==,size_16,color_FFFFFF,t_70"></p> 
<p>CGLIB的回调增强差不太多！</p> 
<pre><code class="language-html">/*********************************CglibAopProxy.java************************/
private static class DynamicAdvisedInterceptor implements MethodInterceptor, Serializable {

   private final AdvisedSupport advised;

   public DynamicAdvisedInterceptor(AdvisedSupport advised) {
      this.advised = advised;
   }

   @Override
   @Nullable
   public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
      Object oldProxy = null;
      boolean setProxyContext = false;
      Object target = null;
      TargetSource targetSource = this.advised.getTargetSource();
      try {
         if (this.advised.exposeProxy) {
            // Make invocation available if necessary.
            oldProxy = AopContext.setCurrentProxy(proxy);
            setProxyContext = true;
         }
         // Get as late as possible to minimize the time we "own" the target, in case it comes from a pool...
         target = targetSource.getTarget();
         Class&lt;?&gt; targetClass = (target != null ? target.getClass() : null);
         List&lt;Object&gt; chain = this.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);
         Object retVal;
         // Check whether we only have one InvokerInterceptor: that is,
         // no real advice, but just reflective invocation of the target.
         if (chain.isEmpty() &amp;&amp; Modifier.isPublic(method.getModifiers())) {
            // We can skip creating a MethodInvocation: just invoke the target directly.
            // Note that the final invoker must be an InvokerInterceptor, so we know
            // it does nothing but a reflective operation on the target, and no hot
            // swapping or fancy proxying.
            Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);
            retVal = methodProxy.invoke(target, argsToUse);
         }
         else {
            // We need to create a method invocation...
            retVal = new CglibMethodInvocation(proxy, target, method, args, targetClass, chain, methodProxy).proceed();
         }
         retVal = processReturnType(proxy, target, method, retVal);
         return retVal;
      }
      finally {
         if (target != null &amp;&amp; !targetSource.isStatic()) {
            targetSource.releaseTarget(target);
         }
         if (setProxyContext) {
            // Restore old proxy.
            AopContext.setCurrentProxy(oldProxy);
         }
      }
   }</code></pre> 
<h4>6.6 增强器执行</h4> 
<pre><code class="language-html">/*********************************ReflectiveMethodInvocation.java************************/
public Object proceed() throws Throwable {
		// We start with an index of -1 and increment early.
		if (this.currentInterceptorIndex == this.interceptorsAndDynamicMethodMatchers.size() - 1) {
			//从索引为-1的拦截器开始调用，并按序递增
			//若拦截器链中的拦截器迭代调用完毕，则就是调用target的函数
			//这个函数是通过反射机制完成的，具体实现在AopUtils.invokeJoinpointUsingReflection方法中
			return invokeJoinpoint();
		}

		//获取配置的Advice
		Object interceptorOrInterceptionAdvice =
				this.interceptorsAndDynamicMethodMatchers.get(++this.currentInterceptorIndex);
		//通知是动态匹配方法拦截器类型
		if (interceptorOrInterceptionAdvice instanceof InterceptorAndDynamicMethodMatcher) {
			// Evaluate dynamic method matcher here: static part will already have
			// been evaluated and found to match.
			//动态匹配方法拦截器 .
			InterceptorAndDynamicMethodMatcher dm =
					(InterceptorAndDynamicMethodMatcher) interceptorOrInterceptionAdvice;
			Class&lt;?&gt; targetClass = (this.targetClass != null ? this.targetClass : this.method.getDeclaringClass());
			if (dm.methodMatcher.matches(this.method, targetClass, this.arguments)) {
				//调用拦截器的执行方法，拦截器执行拦截逻辑后继续调用目标方法的proceed()方法
				return dm.interceptor.invoke(this);
			}
			else {
				// Dynamic matching failed.
				// Skip this interceptor and invoke the next in the chain.
				//切面类对象方法和目标类没匹配上，跳过这个拦截器并调用链中的下一个拦截器（递归调用）
				return proceed();
			}
		}
		else {
			// It's an interceptor, so we just invoke it: The pointcut will have
			// been evaluated statically before this object was constructed.
			//如果是一个interceptor，直接调用这个interceptor对应的方法，
			// 进入各种通知过滤器:*AdviceInterceptor和事务过滤器TransactionInterceptor（适配器模式）
			return ((MethodInterceptor) interceptorOrInterceptionAdvice).invoke(this);
		}
	}</code></pre> 
<p>依次遍历拦截器链的每个元素，然后调用其实现，将真正调用工作委托给各个增强器</p> 
<h4>6.7 增强器执行顺序</h4> 
<p>我们知道增强其执行顺序是这样的：</p> 
<p><img src="https://images2.imgbox.com/e2/bc/3zAwUfhM_o.png" alt="watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h1eGlhbmcxOTg1MTExNA==,size_16,color_FFFFFF,t_70"></p> 
<p>现在我们来进行源码调试看看：</p> 
<p>纵观以上过程可知：实际就是为bean创建一个proxy，JDK Proxy或者CGLIB Proxy，然后在调用bean的方法时，会通过proxy来反射调用bean方法，通过执行代理回调来进行功能增强！</p> 
<p><img src="https://images2.imgbox.com/23/65/V9QrJzcT_o.png" alt="20210122173616905.png"></p> 
<p>1：默认 ExposeInvocationInterceptor ​ 2：异常通知 AspectJAfterThrowingAdvice ​ 3：返回通知 AspectJAfterReturningAdvice-&gt;AfterReturningAdviceInterceptor ​ 4：后置通知 AspectJAfterAdvice ​ 5：环绕通知 AspectJAroundAdvice ​ 6：前置通知 AspectJMethodBeforeAdvice-&gt;MethodBeforeAdviceInterceptor</p> 
<p><strong>invoke调用顺序为：</strong> 1-2-3-4-5（joinPoint.proceed()之前的部分先执行，通过proceed继续递归）-6</p> 
<p><strong>那么invoke方法里面各个对应的通知方法执行顺序为：</strong> 5的前一部分（因为在invoke方法中已经先执行）–6（递归的最后一层）–目标方法（递归结束执行目标方法）–返回到5的后一部分–返回到4（finally块必会执行）–返回到3（有异常逃过不执行）–返回到2（try块里有异常才执行）–返回到1默认拦截器方法</p> 
<h3>7、源码总结</h3> 
<p>重点过程可分为：</p> 
<p>1）通过AspectJAutoProxyBeanDefinitionParser类将AnnotationAwareAspectJAutoProxyCreator注册到Spring容器中</p> 
<p>2）AnnotationAwareAspectJAutoProxyCreator类的postProcessAfterInitialization()方法将所有有advice的bean重新包装成proxy</p> 
<p>3）调用bean方法时通过proxy来调用，proxy依次调用增强器的相关方法，来实现方法切入</p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9e8b0eaa7f07ea5b5c7ef7b12497a65b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">阿里面试官内部题库！阿里发布2023年Java社招岗(正式版)面试题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4aa77a5a50a9356d1052123077f42561/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小猫爪：S32K3学习笔记02-S32K3之FlexCAN</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>