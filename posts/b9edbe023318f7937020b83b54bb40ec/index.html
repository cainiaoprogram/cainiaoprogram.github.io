<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java学习----数据结构 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java学习----数据结构" />
<meta property="og:description" content="今日学习内容总结如下： 程序=算法（解决问题的步骤）&#43;数据结构（合理的持有数据）
如何衡量算法的优劣？
1、计算时间 long start=System.currentTimeInMills();
处理步骤；
long end=System.currentTimeInMills();
System.out.println(&#34;该算法用时&#34;&#43;(end-start)&#43;&#34;ms&#34;);
2、时间复杂度 是一个用于度量一个算法的运算时间的一个描述，本质是一个函数，根据这个函数能在不用具体的测试数据来测试的情况下，粗略地估计算法的执行效率
查找一个算法中执行次数最多的部分和算法规模的相互关系--函数
常用大O来表述，这个函数描述了算法执行所要时间的增长速度
常量阶 O(1)对数阶 O(logn)线性阶 O(n)线性对数阶 O(nlogn)n方阶 O(nⁿ)指数阶 O(2ⁿ)阶乘阶 O(n!) package com.list0; import java.util.Arrays; public class Test1 { public static void main(String[] args) { int[] arr = new int[] { 1, 6, 2, 4, 3, 7, 9, 8 }; for (int i = 1; i &lt; arr.length; i&#43;&#43;) { // 7 for (int k = 0; k &lt; arr." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b9edbe023318f7937020b83b54bb40ec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-22T19:10:03+08:00" />
<meta property="article:modified_time" content="2022-08-22T19:10:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java学习----数据结构</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:center;">今日学习内容总结如下：</h2> 
<p>程序=算法（解决问题的步骤）+数据结构（合理的持有数据）</p> 
<p>如何衡量算法的优劣？</p> 
<h3>1、计算时间</h3> 
<p>      long start=System.currentTimeInMills();<br>       处理步骤；<br>       long end=System.currentTimeInMills();<br>       System.out.println("该算法用时"+(end-start)+"ms");</p> 
<h3>2、时间复杂度</h3> 
<p>是一个用于度量一个算法的运算时间的一个描述，本质是一个函数，根据这个函数能在不用具体的测试数据来测试的情况下，粗略地估计算法的执行效率</p> 
<p>查找一个算法中执行次数最多的部分和算法规模的相互关系--函数</p> 
<p>常用大O来表述，这个函数描述了算法执行所要时间的增长速度</p> 
<ul><li>常量阶    O(1)</li><li>对数阶    O(logn)</li><li>线性阶    O(n)</li><li>线性对数阶    O(nlogn)</li><li>n方阶    O(nⁿ)</li><li>指数阶    O(2ⁿ)</li><li>阶乘阶    O(n!)</li></ul> 
<p></p> 
<pre><code class="language-java">package com.list0;

import java.util.Arrays;

public class Test1 {
	public static void main(String[] args) {
		int[] arr = new int[] { 1, 6, 2, 4, 3, 7, 9, 8 };
		for (int i = 1; i &lt; arr.length; i++) { // 7
			for (int k = 0; k &lt; arr.length - i; k++) { // 7 6 5 ... (n-1)*n/2
				if (arr[k] &gt; arr[k + 1]) {
					int tmp = arr[k];
					arr[k] = arr[k + 1];
					arr[k + 1] = tmp;
				}
			}
		}
		System.out.println(Arrays.toString(arr));
		// 时间复杂度为 n^2/2-n/2 时间和问题规模n成正相关关系
		// 使用大O计法时，只保留最高次幂，去掉所有常量O(n^2)
		
		// 折半查找
		int target = 6;
		int min = 0;
		int max = arr.length - 1;
		int pos = (min + max) / 2;
		while (min &lt;= max) {
			pos=(min + max) / 2;
			if (arr[pos] &gt; target) {
				max = pos - 1;
			} else if (arr[pos] &lt; target) {
				min = pos + 1;
			} else if (arr[pos] == target)
				break;
		}
		System.out.println("位置为:" + pos);
		
		//2^k=n   k以2为底n的对数  时间复杂度为O(logN)
	}
}</code></pre> 
<p>线性表</p> 
<p></p> 
<p>数组</p> 
<pre><code class="language-java">package com.list1;

import java.util.Arrays;
/*
 * 存储区间是连续的，占用内存严重，故空间复杂度很大。但数组的二分查找(前提是必须有序)
 * 时间复杂度小，为O(logN)；
 * 
 * 数组的特点是：
 * - 寻址容易(arr[n]=arr[0]+n*每个元素的长度，时间复杂度为O(1))
 * - 插入和删除困难(可能会引发一半以上的数据元素移动，时间复杂度为O(n))；
 * - Java中的数组是定长的，如果需要变长则需要自行编程实现
 */
public class ArrayList {
	private Object[] data; // 真正存储数据
	private int size = 0; // 记录存储的数据个数

	public ArrayList() {
//		data=new Object[10];
		this(10);
	}

	public ArrayList(int len) {
		data = new Object[len];
	}
	
	public void add(Object obj) {
		data[size++] = obj;
		if (size &gt;= data.length)
			resize();  //扩容处理
	}
	public void insert(int pos,Object obj) {
		if(pos&lt;0 || pos&gt;=size)
			throw new ArrayIndexOutOfBoundsException();
		System.arraycopy(data, pos, data, pos+1, size-pos);
		data[pos]=obj;
		size++;
		if (size &gt;= data.length)
			resize();  //扩容处理
	}
	private void resize() {
		System.out.println(size);
		Object[] res=new Object[data.length*3/2];
		System.arraycopy(data, 0, res, 0, size);
		this.data=res;
	}
	public void delete(int position) {
		if(position&lt;0 || position&gt;=size)
			throw new ArrayIndexOutOfBoundsException();
		System.arraycopy(data, position+1, data, position, size-position-1);
		data[--size]=null;
	}
	public void update(int pos,Object obj) {
		if(pos&lt;0 || pos&gt;=size)
			throw new ArrayIndexOutOfBoundsException();
		data[pos]=obj;
	}
	
	public static void main(String[] args) {
		ArrayList list=new ArrayList(5);
		list.add(0);
		for(int i=1;i&lt;10;i++)
//			list.add(i);
			list.insert(0, i);
		System.out.println(Arrays.toString(list.data));
		//容器为15，浪费了6个存储空间
//		list.delete(3);
//		System.out.println(Arrays.toString(list.data));
//		list.update(0, 99);
//		System.out.println(Arrays.toString(list.data));
	}
}</code></pre> 
<pre><code class="language-java">package com.list1;

/*
 * 存储区间离散(数据不是连续存放的)，占用内存比较宽松，故空间复杂度很小，
 * 但时间复杂度很大O（N）。
 * 
 * 链表的特点是：
 * - 寻址困难（可能需要通过遍历的方式查找元素，时间复杂度为O(n)）
 * - 插入和删除容易(不需要引发元素的移动，仅仅只是进行地址的拷贝，时间复杂度为O(1))。
 */
public class LinkedList {   //单向链表，实现不够完善，重点是原理

	private Node header;// 头指针,指向链表中的第一个元素

	public void add(Object data) {
		if (header == null) {
			header = new Node(data);
		} else {
			Node p = header;
			for (; p.next != null; p = p.next)
				;
			p.next = new Node(data);
		}
	}
	//增加和实际长度无关，但是为了查询到对应的位置，时间复杂度还是O(n)
	public void insert(int pos,Object data) {
		Node p=header;
		for(int i=1;i&lt;=pos;i++) {
			p=p.next;
		}
		Node tmp=new Node(data);
		tmp.next=p.next;
		p.next=tmp;
	}
	//功能并不完善
	//删除和实际长度无关，O(1)；但是实际上为了查询到对应的位置，时间复杂度还是O(n)
	public void delete(int pos) {
		Node p=header;
		for(int i=1;i&lt;pos;i++)
			p=p.next;
		p.next=p.next.next;
	}
	public void show() {
		Node p = header;
		for (; p != null; p = p.next)
			System.out.print(p.data + "\t");
		
	}

	public static void main(String[] args) {
		LinkedList list = new LinkedList();
		list.add(99);
		for (int i = 0; i &lt; 10; i++)
			list.insert(0,i);
		list.show();
		list.delete(3);
		System.out.println();
		list.show();
}

	class Node {
		private Object data;// 存储的数据
		private Node next;// 指向下一个Node对象的指针

		public Node(Object data) {
			this.data = data;
		}
	}
}</code></pre> 
<h2>集合</h2> 
<p>Java集合类存放于 java.util 包中，是一个用来存放对象的容器</p> 
<p>集合只能存放对象。比如存一个int型数据1放入集合中，其实它是自动转换成Integer 类后存入的(装箱操作)，Java中每一种基本类型都有对应的引用类型</p> 
<p>集合存放的是多个对象的引用，对象本身还是放在堆内存中</p> 
<p>集合可以存放不同类型，不限数量的数据类型。定义集合变量时如果不指定数据类型，则默认数据类型为Object</p> 
<h3>数组和集合的比较</h3> 
<p>针对Java中的数组定长，Java提出了集合框架，实现了一种变长存储数据的容器---集合</p> 
<p>数组不是面向对象的，存在明显的缺陷，集合弥补了数组的缺点，比数组更灵活更实用，而且不同的集合框架类可适用不同场合。如下：</p> 
<ul><li>数组能存放基本数据类型和对象，而集合类存放的都是对象的引用，而非对象本身</li><li>数组容量固定无法动态改变，集合类容量动态改变</li><li>数组无法判断其中实际存有多少元素，length只告诉了数组的容量，而集合的size()可以确切知道元素的个数</li><li>集合有多种实现方式和不同适用场合，不像数组仅采用顺序表方式</li><li>集合以类的形式存在，具有封装、继承、多态等类的特性，通过简单的方法和属性即可</li><li>实现各种复杂操作，大大提高了软件的开发效率</li></ul> 
<h3>Iterator迭代器</h3> 
<p>Iterator迭代器：走访器，可以理解为集合中元素的指针<br> 它是Java集合的顶层接口（不包括map系列的集合，Map接口是map系列集合的顶层接口）</p> 
<p>public interface Iterator&lt;E&gt; {<!-- --><br>      boolean hasNext();  判断是否有后续元素<br>      E next(); 指针向后移动，同时返回指向的数据<br>      default void remove() {  删除指针所指向的元素<br>           throw new UnsupportedOperationException("remove");<br>      }</p> 
<p>使用lambda表达式的方式遍历所有元素</p> 
<pre><code class="language-java">default void forEachRemaining(Consumer&lt;? super E&gt; action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next());
    }</code></pre> 
<p></p> 
<p>Iterable接口用以表示实现类是可以迭代的</p> 
<pre><code class="language-java">Iterator&lt;T&gt; iterator();</code></pre> 
<pre><code class="language-java">package com.list2;

import java.util.ArrayList;
import java.util.Iterator;

public class Test1 {
	public static void main(String[] args) {
		ArrayList al = new ArrayList();
		for (int i = 0; i &lt; 100; i++)
			al.add(i);
		// 迭代访问集合中的每个元素
		Iterator it = al.iterator();
//		while(it.hasNext()) {
//			Object tmp=it.next();
//			System.out.println(tmp);
//		}
		
		it.forEachRemaining(System.out::println);
		
		al.forEach(System.out::println);  //底层就是迭代访问
	}
}
</code></pre> 
<pre><code class="language-java">package com.list2;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Iterator;
/*
 * 顶级接口Collection
 * 		无序、允许重复
 * 
 * public interface Collection&lt;E&gt; extends Iterable&lt;E&gt;一般说Collection是集合
 * 框架的顶级接口，但是事实上并不是顶级接口
 * 
 * 提供的方法:
 * 	 int size();  获取集合中的元素个数   区分容积和元素个数
 * 
 * 	boolean isEmpty()判断集合中的元素个数是否为0
 *     ​	注意：只判断是否没有元素，但是并不判断集合对象是否为null
 *  boolean contains(Object o)用于判断集合中是否包含对象 
 *  
 *  boolean add(Object o)用于向集合中追加元素o，成功true失败false
 *  
 *  boolean remove(Object o)删除集合中的指定元素o，成功true失败false
 *  
 *  Iterator&lt;E&gt; iterator();获取迭代器，通过迭代器遍历集合中的每个元素
 *  
 *  Object[] toArray();将集合转换为数组
 *  
 *   void clear();删除集合中的所有元素
 */
public class Test2 {
	public static void main(String[] args) {
		Collection cc = new ArrayList();
		cc.add(123);
		cc.add("bbbb");
		cc.add(new Date());
		System.out.println(cc.size());
		System.out.println(cc.isEmpty());
		System.out.println(cc.contains("bbbb"));
		System.out.println(cc.contains(new Date()));
		System.out.println(cc.remove(123));
		System.out.println(cc.size());
	}
}
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b24e06ed0edd153518adb63491ec377c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[C语言学习]----函数递归（超详细！！！）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/17b963c16af83bf1efa3fb4eb69af2b5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">WD5032车充3.1A快充IC</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>