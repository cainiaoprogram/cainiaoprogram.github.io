<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>常用的一些注解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="常用的一些注解" />
<meta property="og:description" content="@Configuration 对比以前原生spring添加组件的区别
如果是以前的原生spring，想要将组件添加到容器中
1.需要在resources目录下创建一个xml配置文件
2.创建bean标签
现在的Spring Boot已经不需要向以前一样了，有一个注解@Configuration（翻译：配置）可以供使用
1.创建一个类。
2.使用注解@Configuration，告诉Spring Boot这是一个配置类。
这个时候在类里边不能写bean标签了需要使用@bean注解，想要构建出user和pet对象需要自己将它创造出来。
@bean ：给容器中添加组件，以方法名作为组件的id。返回类型为组件类型，返回的值，就是组件在容器中的实例
在Spring Boot 5.2之后的@Configuration注解多了一个属性proxyBeanMethods，默认为true（翻译：代理bean的方法）
proxyBeanMethods：代理bean的方法
有两种模式：
1.Full:(proxyBeanMethods = true) //全模式
使用代理模式，保证组件的单实例，启动不如false快，但是重复利用率高，适用于会重复使用组件的场景。
2.lite:(proxyBeanMethods = false) //轻量级
不是用代理模式，不用保证组件的单实例，启动最快。单每次调用组件都会重新创建一个新的组件，组件可重复使用率低。适用于需要组件但不会重复使用的场景
总结：用于解决组件依赖
@MapperScan @Mapper 注解的使用
作用：在接口类上添加了@Mapper，在编译之后会生成相应的接口实现类。添加位置：接口类上面
2、@MapperScan注解的使用
作用：指定要变成实现类的接口所在的包，包下面的所有接口在编译之后都会生成相应的实现类。添加位置：是在Springboot启动类上面添加
区别:
添加@MapperScan(“cn.mybatis.mappers”)注解以后，cn.mybatis.mappers包下面所有的接口类，在编译之后都会生成相应的实现类;
在不使用@MapperScan前，我们需要直接在Mapper类上面添加注解@Mapper，这种方式要求每一个Mapper类都需要添加此注解，非常麻烦，属于重复劳动。通过使用@MapperScan注解，可以让我们不用为每个Mapper类都添加@Mapper注解。
@RestController @RestController的作用等同于@Controller &#43; @ResponseBody
@Controller 在一个类上添加@Controller注解，表明了这个类是一个控制器类。
@ResponseBody表示方法的返回值直接以指定的格式写入Http response body中，而不是解析为跳转路径。
格式的转换是通过HttpMessageConverter中的方法实现的，因为它是一个接口，因此由其实现类完成转换。
如果要求方法返回的是json格式数据，而不是跳转页面，可以直接在类上标注@RestController，而不用在每个方法中标注@ResponseBody，简化了开发过程。
@Controller和@RestController的区别:
@Controller:在对应的方法上，视图解析器可以解析return 的jsp,html页面，并且跳转到相应页面
若返回json等内容到页面，则需要加@ResponseBody注解
@RestController:相当于@Controller&#43;@ResponseBody两个注解的结合，返回json数据不需要在方法前面加@ResponseBody注解了，但使用@RestController这个注解，就不能返回jsp,html页面，视图解析器无法解析jsp,html页面
@RequestMapping 作用：将请求和处理请求的控制器方法关联起来，建立映射关系。
位置：
1、标识类：设置映射请求的请求路径的初始信息
2、表示方法：设置映射请求的请求路径的具体信息
value属性: @RequestMapping(“/hello”) == @RequestMapping(value = “/hello”)
value属性是一个字符串类型的数组，表示请求映射能够匹配多个请求地址所对应的请求。
method属性: method属性通过请求的请求方式（get或post）匹配请求映射。他也是一个数组，但是是RequestMethod类的数组，表示请求映射能够匹配多种请求方式的请求。
直接打开网页的请求方式是GET" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5f51e1918c75d14d9fc7434db668f6c8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-11T17:34:18+08:00" />
<meta property="article:modified_time" content="2022-10-11T17:34:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">常用的一些注解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Configuration_0"></a>@Configuration</h2> 
<p>对比以前原生spring添加组件的区别<br> 如果是以前的原生spring，想要将组件添加到容器中<br> 1.需要在resources目录下创建一个xml配置文件<br> 2.创建bean标签</p> 
<p>现在的Spring Boot已经不需要向以前一样了，有一个注解@Configuration（翻译：配置）可以供使用<br> 1.创建一个类。<br> 2.使用注解@Configuration，告诉Spring Boot这是一个配置类。<br> 这个时候在类里边不能写bean标签了需要使用@bean注解，想要构建出user和pet对象需要自己将它创造出来。</p> 
<h3><a id="bean_11"></a>@bean</h3> 
<p>：给容器中添加组件，以方法名作为组件的id。返回类型为组件类型，返回的值，就是组件在容器中的实例<br> <img src="https://images2.imgbox.com/d6/89/O8tLSYsv_o.png" alt="在这里插入图片描述"><br> 在Spring Boot 5.2之后的@Configuration注解多了一个属性proxyBeanMethods，默认为true（翻译：代理bean的方法）<br> proxyBeanMethods：代理bean的方法<br> 有两种模式：<br> 1.Full:(proxyBeanMethods = true) //全模式<br> 使用代理模式，保证组件的单实例，启动不如false快，但是重复利用率高，适用于会重复使用组件的场景。<br> 2.lite:(proxyBeanMethods = false) //轻量级<br> 不是用代理模式，不用保证组件的单实例，启动最快。单每次调用组件都会重新创建一个新的组件，组件可重复使用率低。适用于需要组件但不会重复使用的场景<br> 总结：用于解决组件依赖</p> 
<h2><a id="MapperScan_24"></a>@MapperScan</h2> 
<h3><a id="Mapper_26"></a>@Mapper</h3> 
<p>注解的使用<br> 作用：在接口类上添加了@Mapper，在编译之后会生成相应的接口实现类。添加位置：接口类上面<br> 2、@MapperScan注解的使用<br> 作用：指定要变成实现类的接口所在的包，包下面的所有接口在编译之后都会生成相应的实现类。添加位置：是在Springboot启动类上面添加<br> 区别:<br> 添加@MapperScan(“cn.mybatis.mappers”)注解以后，cn.mybatis.mappers包下面所有的接口类，在编译之后都会生成相应的实现类;<br> 在不使用@MapperScan前，我们需要直接在Mapper类上面添加注解@Mapper，这种方式要求每一个Mapper类都需要添加此注解，非常麻烦，属于重复劳动。通过使用@MapperScan注解，可以让我们不用为每个Mapper类都添加@Mapper注解。</p> 
<h2><a id="RestController_36"></a>@RestController</h2> 
<p>@RestController的作用等同于@Controller + @ResponseBody</p> 
<h3><a id="Controller_39"></a>@Controller</h3> 
<p>在一个类上添加@Controller注解，表明了这个类是一个控制器类。<br> @ResponseBody表示方法的返回值直接以指定的格式写入Http response body中，而不是解析为跳转路径。</p> 
<p>格式的转换是通过HttpMessageConverter中的方法实现的，因为它是一个接口，因此由其实现类完成转换。</p> 
<p>如果要求方法返回的是json格式数据，而不是跳转页面，可以直接在类上标注@RestController，而不用在每个方法中标注@ResponseBody，简化了开发过程。</p> 
<p>@Controller和@RestController的区别:<br> @Controller:在对应的方法上，视图解析器可以解析return 的jsp,html页面，并且跳转到相应页面</p> 
<p>若返回json等内容到页面，则需要加@ResponseBody注解</p> 
<p>@RestController:相当于@Controller+@ResponseBody两个注解的结合，返回json数据不需要在方法前面加@ResponseBody注解了，但使用@RestController这个注解，就不能返回jsp,html页面，视图解析器无法解析jsp,html页面</p> 
<h2><a id="RequestMapping_54"></a>@RequestMapping</h2> 
<p>作用：将请求和处理请求的控制器方法关联起来，建立映射关系。<br> 位置：<br> 1、标识类：设置映射请求的请求路径的初始信息<br> 2、表示方法：设置映射请求的请求路径的具体信息</p> 
<h3><a id="value_61"></a>value属性:</h3> 
<p>@RequestMapping(“/hello”) == @RequestMapping(value = “/hello”)<br> value属性是一个字符串类型的数组，表示请求映射能够匹配多个请求地址所对应的请求。</p> 
<h3><a id="method_66"></a>method属性:</h3> 
<p>method属性通过请求的请求方式（get或post）匹配请求映射。他也是一个数组，但是是RequestMethod类的数组，表示请求映射能够匹配多种请求方式的请求。<br> 直接打开网页的请求方式是GET<br> 如果当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器会报错405（Request method ‘POST’ not support）<br> 如果不设置method属性，那么无论是GET还是POST都可以打开我们的servlet<br> 1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解：<br> 处理get请求的映射 —&gt; @GetMapping<br> 处理post请求的映射 —&gt; @PostMapping<br> 处理put请求的映射 —&gt; @PutMapping<br> 处理delete请求的映射 —&gt; @DeleteMapping</p> 
<p>2、常用的请求方式有get、post、put、delete<br> 但是目前浏览器只支持get和post，若在form表单提交的时候，为method设置了其他请求方式（put或delete），则默认按照get的请求方式处理。<br> 若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter</p> 
<h3><a id="params_82"></a>params属性:</h3> 
<p>params属性通过请求的请求参数匹配请求映射。params属性也是一个字符串类型的数组，可以通过以下四种表达式设置请求参数和请求映射的匹配关系：<br> 1、“param”：表示要求请求映射所匹配的请求必须携带param请求参数<br> 2、“!param”：表示要求请求映射所匹配的请求不能携带param请求参数<br> 3、“param=value”：表示要求请求映射所匹配的请求必须携带param请求参数且param=value<br> 4、“param!=value”：表示要求请求映射所匹配的请求必须携带param请求参数且param!=value</p> 
<h3><a id="headers_89"></a>headers属性:</h3> 
<p>headers属性通过请求的请求头信息匹配请求映射。他也是一个字符串类型的数组，可以通过以下四种表达式设置请求头信息和请求映射的匹配关系：<br> 1、“header”：表示请求映射所匹配的请求必须携带header请求头信息<br> 2、“!header”：表示请求映射所匹配的请求必须携带header请求头信息<br> 3、“header=value”：表示请求映射所匹配的请求必须携带header请求头信息，且请求头信息header = value<br> 4、“header!=value”：表示请求映射所匹配的请求必须携带header请求头信息，且请求头信息header != value</p> 
<p>注意：若当前请求满足value和method属性，但是不满足headers属性，此时页面显示404错误（资源未找到）。</p> 
<h2><a id="Mapping_99"></a>@Mapping</h2> 
<ul><li>@GetMapping</li><li>@PostMapping</li><li>@PutMapping</li><li>@DeleteMapping</li><li>@PatchMapping</li></ul> 
<p>如果我们想使用传统的*@RequestMapping*注释实现URL处理程序，那么它应该是这样的：</p> 
<p>@RequestMapping(value = “/get/{id}”, method = RequestMethod.GET)</p> 
<p>新方法可以简化为：</p> 
<p>@GetMapping(“/get/{id}”)</p> 
<h2><a id="Autowired_115"></a>@Autowired</h2> 
<p>注解@Autowired是Spring对组件自动装配的一种方式。常用于在一个组件中引入其他组件。<br> 自动装配：sprng通过依赖注入（DI），完成IOC容器中各个组件依赖的关系赋值</p> 
<h2><a id="Repository_121"></a>@Repository</h2> 
<p>@Repository 是 Spring 的注解，用于声明一个 Bean。@Repository单独使用没用。可以这样理解，注解放在接口上本来就没有意义，spring中在mapper接口上写一个@Repository注解，只是为了标识，要想真正是这个接口被扫描，必须使用@MapperScannerConfigurer</p> 
<pre><code class="prism language-java"><span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span> 配置 <span class="token class-name">Mapper</span> 扫描器 <span class="token operator">--</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>bean <span class="token keyword">class</span><span class="token operator">=</span><span class="token string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>property name<span class="token operator">=</span><span class="token string">"basePackage"</span> value<span class="token operator">=</span><span class="token string">"com.shenlei.mapper"</span><span class="token operator">/</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>bean<span class="token operator">&gt;</span>

</code></pre> 
<p>这段配置会扫描com.shenlei.mapper包下所有的接口，然后创建各自的动态代理类。<br> 与spring集成可分三个步骤：<br> 1、把java类对应的Mapper接口类纳入spring总的IOC容器。<br> 2、把Java类对应的XML命名空间添加到Mybatis中的Configuration类中的mapperRegistry（用于管理Mybatis的Mapper）</p> 
<p><strong>@Mapper和@Repository区别</strong><br> 相同点：<br> @Mapper和@Repository都是作用在dao层接口，使得其生成代理对象bean，交给spring 容器管理<br> 对于mybatis来说，都可以不用写mapper.xml文件</p> 
<p>不同点：<br> 1、@Mapper不需要配置扫描地址，可以单独使用，如果有多个mapper文件的话，可以在项目启动类中加入@MapperScan(“mapper文件所在包”)<br> 2、@Repository不可以单独使用，否则会报错误，要想用，必须配置扫描地址（@MapperScannerConfigurer）</p> 
<h2><a id="_146"></a>实体类常用注解</h2> 
<p>引入lombok<br> 要使用 @Data 注解要先引入lombok，lombok 是什么，它是一个工具类库，可以用简单的注解形式来简化代码，提高开发效率。<br> @Data ： 注在类上，提供类的get、set、equals、hashCode、canEqual、toString方法<br> @AllArgsConstructor ： 注在类上，提供类的全参构造<br> @NoArgsConstructor ： 注在类上，提供类的无参构造<br> @Setter ： 注在属性上，提供 set 方法<br> @Getter ： 注在属性上，提供 get 方法<br> @EqualsAndHashCode ： 注在类上，提供对应的 equals 和 hashCode 方法<br> @Log4j/@Slf4j ： 注在类上，提供对应的 Logger 对象，变量名为 log</p> 
<h2><a id="Service_158"></a>@Service</h2> 
<p>对于 service 层的类，在类上用 @Service 注解声明</p> 
<p>value 属性的值，相当于上面代码的 std ,通过该 名字 进行注入</p> 
<p>如果不指定，默认值为 当前类名（首字母小写） ，具体看下面例子</p> 
<h2><a id="Transactional_165"></a>@Transactional</h2> 
<p>@Transactional 是声明式事务管理 编程中使用的注解<br> @Transactional 实质是使用了 JDBC 的事务来进行事务控制的<br> @Transactional 基于 Spring 的动态代理的机制</p> 
<p><strong>添加位置:</strong></p> 
<p>1）接口实现类或接口实现方法上，而不是接口类中。<br> 2）访问权限：public 的方法才起作用。@Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。<br> 系统设计：将标签放置在需要进行事务管理的方法上，而不是放在所有接口实现类上：只读的接口就不需要事务管理，由于配置了@Transactional就需要AOP拦截及事务的处理，可能影响系统性能。<br> <strong>声明式事务管理实现方式：</strong><br> 基于 tx 和 aop 名字空间的 xml 配置文件<br> <img src="https://images2.imgbox.com/79/d7/6GELm3m2_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/98/ac/8EY1N8dK_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0f7cf409e96cb07d30332d8f1d4a60f6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">flask-sqlalchemy一对多 知了传课 flask web全栈开发实战 黄勇</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a63f071d5a7fd6e29161ca75cf61c6dd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">node-red教程 5 函数节点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>