<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GLES2.0中文API-glReadPixels - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GLES2.0中文API-glReadPixels" />
<meta property="og:description" content="名称 glReadPixels - 从帧缓冲区中读取一个像素块
C规范 void glReadPixels（GLint x,
GLint y,
GLsizei width,
GLsizei height,
GLenum format,
GLenum type,
GLvoid * data）;
参数 x，y
指定从帧缓冲区读取的第一个像素的窗口坐标。 此位置是矩形像素块的左下角。
width,height
指定像素矩形的尺寸。 一个宽度和高度对应于单个像素。
format
指定像素数据的格式。 接受以下符号值：GL_ALPHA，GL_RGB和GL_RGBA。
type
指定像素数据的数据类型。 必须是GL_UNSIGNED_BYTE，GL_UNSIGNED_SHORT_5_6_5，GL_UNSIGNED_SHORT_4_4_4_4或GL_UNSIGNED_SHORT_5_5_5_1之一。
data
返回像素数据。
描述 glReadPixels从帧缓冲区返回像素数据，从左下角位于（x，y）的像素开始，从位置data开始返回客户端内存。使用glPixelStorei命令设置的GL_PACK_ALIGNMENT参数会影响像素数据在放入客户端内存之前的处理。
glReadPixels返回每个像素的值，左下角为x &#43; i y &#43; j，0 &lt;= i &lt;width，0 &lt;= j &lt;height。 该像素被称为第j行中的第i个像素。 像素按行顺序从最低行返回到最高行，每行从左到右排列。
format指定返回像素值的格式; 可接受的值是：
GL_ALPHA
GL_RGB
GL_RGBA
从颜色缓冲区读取RGBA颜色分量。 每个颜色分量都转换为浮点，使零强度映射到0.0，全强度映射到1.0。
丢弃不需要的数据。 例如，GL_ALPHA丢弃红色，绿色和蓝色组件，而GL_RGB仅丢弃alpha组件。 最终值被限制在[0 1]的范围内。
最后，组件将转换为由类型指定合适的格式，。 当类型为GL_UNSIGNED_BYTE时，每个组件乘以2^8 - 1。 当类型为GL_UNSIGNED_SHORT_5_6_5，GL_UNSIGNED_SHORT_4_4_4_4或GL_UNSIGNED_SHORT_5_5_5_1时，每个分量乘以2^N-1，其中N是位域中的位数。
返回值按如下方式放入内存中。 如果format是GL_ALPHA，则返回单个值，并且第j行中第i个像素的数据放置在位置j*width &#43; i中。 GL_RGB返回三个值，GL_RGBA为每个像素返回四个值，所有值对应于占据数据中连续空间的单个像素。 由glPixelStorei设置的存储参数GL_PACK_ALIGNMENT会影响数据写入内存的方式。 有关说明，请参阅glPixelStorei。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/55a73037b9edc6d6808180051eca64d9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-21T12:07:59+08:00" />
<meta property="article:modified_time" content="2018-11-21T12:07:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GLES2.0中文API-glReadPixels</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>名称</h3> 
<p>glReadPixels - 从帧缓冲区中读取一个像素块</p> 
<h3>C规范</h3> 
<p>void <strong>glReadPixels</strong>（GLint <em>x</em>,</p> 
<p>                                    GLint <em>y</em>,</p> 
<p>                                    GLsizei <em>width</em>,</p> 
<p>                                    GLsizei <em>height</em>,</p> 
<p>                                    GLenum <em>format</em>,</p> 
<p>                                    GLenum <em>type</em>,</p> 
<p>                                    GLvoid * <em>data</em>）;</p> 
<h3>参数</h3> 
<p><em>x，y</em></p> 
<p style="text-indent:50px;">指定从帧缓冲区读取的第一个像素的窗口坐标。 此位置是矩形像素块的<strong>左下角</strong>。</p> 
<p style="text-indent:0;"><em>width,height</em></p> 
<p style="text-indent:50px;">指定像素矩形的尺寸。 一个宽度和高度对应于单个像素。</p> 
<p style="text-indent:0;"><em>format</em></p> 
<p style="text-indent:50px;">指定像素数据的格式。 接受以下符号值：<strong>GL_ALPHA</strong>，<strong>GL_RGB</strong>和<strong>GL_RGBA</strong>。</p> 
<p style="text-indent:0;"><em>type</em></p> 
<p style="text-indent:50px;">指定像素数据的数据类型。 必须是<strong>GL_UNSIGNED_BYTE</strong>，<strong>GL_UNSIGNED_SHORT_5_6_5</strong>，<strong>GL_UNSIGNED_SHORT_4_4_4_4</strong>或<strong>GL_UNSIGNED_SHORT_5_5_5_1</strong>之一。</p> 
<p style="text-indent:0;"><em>data</em></p> 
<p style="text-indent:50px;">返回像素数据。</p> 
<h3>描述</h3> 
<p style="text-indent:50px;"><strong>glReadPixels</strong>从帧缓冲区返回像素数据，从左下角位于（<em>x，y</em>）的像素开始，从位置<em>data</em>开始返回客户端内存。使用<a href="https://blog.csdn.net/flycatdeng/article/details/82667285">glPixelStorei</a>命令设置的<strong>GL_PACK_ALIGNMENT</strong>参数会影响像素数据在放入客户端内存之前的处理。</p> 
<p style="text-indent:50px;"><strong>glReadPixels</strong>返回每个像素的值，左下角为x + i  y + j，0 &lt;= i &lt;width，0 &lt;= j &lt;height。 该像素被称为第j行中的第i个像素。 像素按行顺序从最低行返回到最高行，每行从左到右排列。</p> 
<p style="text-indent:50px;"><em>format</em>指定返回像素值的格式; 可接受的值是：</p> 
<p><strong><code>GL_ALPHA</code></strong></p> 
<p><strong><code>GL_RGB</code></strong></p> 
<p><strong><code>GL_RGBA</code></strong></p> 
<p><code>从颜色缓冲区读取RGBA颜色分量。 每个颜色分量都转换为浮点，使零强度映射到0.0，全强度映射到1.0。</code></p> 
<p><code>丢弃不需要的数据。 例如，GL_ALPHA丢弃红色，绿色和蓝色组件，而GL_RGB仅丢弃alpha组件。 最终值被限制在[0 1]的范围内。</code></p> 
<p><code>最后，组件将转换为由类型指定合适的格式，。 当类型为<strong>GL_UNSIGNED_BYTE</strong>时，每个组件乘以2^8 - 1。 当类型为<strong>GL_UNSIGNED_SHORT_5_6_5</strong>，<strong>GL_UNSIGNED_SHORT_4_4_4_4</strong>或<strong>GL_UNSIGNED_SHORT_5_5_5_1</strong>时，每个分量乘以2^N-1，其中N是位域中的位数。</code></p> 
<p><code>返回值按如下方式放入内存中。 如果<em>format</em>是<strong>GL_ALPHA</strong>，则返回单个值，并且第j行中第i个像素的数据放置在位置j*<em>width </em>+ i中。 <strong>GL_RGB</strong>返回三个值，<strong>GL_RGBA</strong>为每个像素返回四个值，所有值对应于占据数据中连续空间的单个像素。 由</code><a href="https://blog.csdn.net/flycatdeng/article/details/82667285">glPixelStorei</a><code>设置的存储参数<strong>GL_PACK_ALIGNMENT</strong>会影响数据写入内存的方式。 有关说明，请参阅</code><a href="https://blog.csdn.net/flycatdeng/article/details/82667285">glPixelStorei</a><code>。</code></p> 
<h3>注意</h3> 
<p style="text-indent:50px;">如果当前绑定的帧缓冲区不是默认的帧缓冲区对象，则从附加到<strong>GL_COLOR_ATTACHMENT0</strong>附着点的彩色图像中读取颜色分量。</p> 
<p style="text-indent:50px;">只有两个<em>format/type</em>参数对是可接受的。<strong>GL_RGBA </strong>/ <strong>GL_UNSIGNED_BYTE</strong>是始终都可以接受的，另外的就需要查询了：通过查询<strong>GL_IMPLEMENTATION_COLOR_READ_FORMAT</strong>和<strong>GL_IMPLEMENTATION_COLOR_READ_TYPE</strong>来发现其他可接受的对。</p> 
<p style="text-indent:50px;">位于连接到当前GL上下文的窗口之外的像素值是未定义的。</p> 
<p style="text-indent:50px;">如果生成错误，则不会更改<em>data</em>内容。</p> 
<h3>错误</h3> 
<p><strong><code>GL_INVALID_ENUM</code> </strong>：如果<em>format</em>或<em>type</em>不是可接受的值。</p> 
<p><strong><code>GL_INVALID_VALUE</code> </strong>：如果<em>width</em>或<em>height</em>是负数</p> 
<p><strong><code>GL_INVALID_OPERATION</code> </strong>：如果<em>type</em>为<strong>GL_UNSIGNED_SHORT_5_6_5</strong>且格式不是<strong>GL_RGB</strong>。</p> 
<p><strong><code>GL_INVALID_OPERATION</code> </strong>：如果<em>type</em>为<strong>GL_UNSIGNED_SHORT_4_4_4_4</strong>或<strong>GL_UNSIGNED_SHORT_5_5_5_1</strong>且格式不是<strong>GL_RGBA</strong>。</p> 
<p><strong><code>GL_INVALID_OPERATION</code> </strong>：如果<em>format</em>和<em>type</em>分别既不是<strong>GL_RGBA</strong>又不是<strong>GL_UNSIGNED_BYTE</strong>，也不是通过查询<strong>GL_IMPLEMENTATION_COLOR_READ_FORMAT</strong>和<strong>GL_IMPLEMENTATION_COLOR_READ_TYPE</strong>返回的格式/类型对。</p> 
<p><strong><code>GL_INVALID_FRAMEBUFFER_OPERATION</code> </strong>：如果当前绑定的帧缓冲区不是帧缓冲区完成状态（即<a href="https://blog.csdn.net/flycatdeng/article/details/82664955">glCheckFramebufferStatus</a>的返回值不是<strong>GL_FRAMEBUFFER_COMPLETE</strong>）。</p> 
<h3>相关Gets</h3> 
<p><a href="https://blog.csdn.net/flycatdeng/article/details/82595295">glGet</a> 参数<code><strong>GL_IMPLEMENTATION_COLOR_READ_FORMAT</strong>或</code><strong>GL_IMPLEMENTATION_COLOR_READ_TYPE</strong></p> 
<p><a href="https://blog.csdn.net/flycatdeng/article/details/82595295">glGet</a> 参数<strong>GL_PACK_ALIGNMENT</strong></p> 
<h3>另见</h3> 
<p><a href="https://blog.csdn.net/flycatdeng/article/details/82664955">glCheckFramebufferStatus</a>，<a href="https://blog.csdn.net/flycatdeng/article/details/82667285">glPixelStorei</a></p> 
<h3>版权</h3> 
<p><a href="https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glReadPixels.xml" rel="nofollow">https://www.khronos.org/registry/OpenGL-Refpages/es2.0/xhtml/glReadPixels.xml</a></p> 
<p><a href="https://blog.csdn.net/flycatdeng">https://blog.csdn.net/flycatdeng</a></p> 
<p>Copyright © 1991-2006 Silicon Graphics, Inc.本文档的许可是根据SGI Free Software B License.详见<a href="http://oss.sgi.com/projects/FreeB/" rel="nofollow">http://oss.sgi.com/projects/FreeB/</a>.</p> 
<figure class="image"> 
 <img alt="" src="https://images2.imgbox.com/82/6b/Qgug6VuJ_o.png"> 
 <figcaption>
   Android,OpenGL ES,图形学 
 </figcaption> 
</figure> 
<p> </p> 
<h3>Demo</h3> 
<p>Android Demo：<a href="https://blog.csdn.net/flycatdeng/article/details/90815893">glReadPixel读取当前缓冲区像素并保存成Bitmap</a></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7612dfc7ace56e73fbca4825b5954de0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vs2013编译驱动错误-Inf2Cat,signability test failed</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/17a8860225f7c51cf8a4843dc2dad72d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">添加几行代码实现百度文库的复制</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>