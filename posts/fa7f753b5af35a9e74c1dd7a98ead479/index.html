<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java栈的输出字段的意义 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java栈的输出字段的意义" />
<meta property="og:description" content="java signal SIGQUIT的输出是线程：Signal Catcher完成
&#34;SIG_0&#34;,	/* 0 */ &#34;SIGHUP&#34;,	/* 1 */ &#34;SIGINT&#34;,	/* 2 */ &#34;SIGQUIT&#34;,	/* 3 */ &#34;SIGILL&#34;,	/* 4 */ &#34;SIGTRAP&#34;,	/* 5 */ &#34;SIGABRT&#34;,	/* 6 */ &#34;SIGBUS&#34;,	/* 7 */ &#34;SIGFPE&#34;,	/* 8 */ &#34;SIGKILL&#34;,	/* 9 */ &#34;SIGUSR1&#34;,	/* 10 */ &#34;SIGSEGV&#34;,	/* 11 */ &#34;SIGUSR2&#34;,	/* 12 */ &#34;SIGPIPE&#34;,	/* 13 */ &#34;SIGALRM&#34;,	/* 14 */ &#34;SIGTERM&#34;,	/* 15 */ &#34;SIGSTKFLT&#34;,	/* 16 */ &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fa7f753b5af35a9e74c1dd7a98ead479/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-12-06T15:38:39+08:00" />
<meta property="article:modified_time" content="2016-12-06T15:38:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java栈的输出字段的意义</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>java signal SIGQUIT的输出是线程：Signal Catcher完成</p> 
<p></p> 
<div id="src" style="font-family:sans-serif; font-size:14px"> 
 <pre style="border:0px; margin-top:0px; margin-bottom:0px">	<span class="s" style="color:green">"SIG_0"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 0 */</span>
	<span class="s" style="color:green">"SIGHUP"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 1 */</span>
	<span class="s" style="color:green">"SIGINT"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 2 */</span>
	<strong><span class="s" style="color:green">"SIGQUIT"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 3 */</span></strong>
	<span class="s" style="color:green">"SIGILL"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 4 */</span>
	<span class="s" style="color:green">"SIGTRAP"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 5 */</span>
	<span class="s" style="color:green">"SIGABRT"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 6 */</span>
	<span class="s" style="color:green">"SIGBUS"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 7 */</span>
	<span class="s" style="color:green">"SIGFPE"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 8 */</span>
	<span class="s" style="color:green">"SIGKILL"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 9 */</span>
	<span class="s" style="color:green">"SIGUSR1"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 10 */</span>
	<span class="s" style="color:green">"SIGSEGV"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 11 */</span>
	<span class="s" style="color:green">"SIGUSR2"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 12 */</span>
	<span class="s" style="color:green">"SIGPIPE"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 13 */</span>
	<span class="s" style="color:green">"SIGALRM"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 14 */</span>
	<span class="s" style="color:green">"SIGTERM"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 15 */</span>
	<span class="s" style="color:green">"SIGSTKFLT"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 16 */</span>
	<span class="s" style="color:green">"SIGCHLD"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 17 */</span>
	<span class="s" style="color:green">"SIGCONT"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 18 */</span>
	<span class="s" style="color:green">"SIGSTOP"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 19 */</span>
	<span class="s" style="color:green">"SIGTSTP"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 20 */</span>
	<span class="s" style="color:green">"SIGTTIN"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 21 */</span>
	<span class="s" style="color:green">"SIGTTOU"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 22 */</span>
	<span class="s" style="color:green">"SIGURG"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 23 */</span>
	<span class="s" style="color:green">"SIGXCPU"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 24 */</span>
	<span class="s" style="color:green">"SIGXFSZ"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 25 */</span>
	<span class="s" style="color:green">"SIGVTALRM"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 26 */</span>
	<span class="s" style="color:green">"SIGPROF"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 27 */</span>
	<span class="s" style="color:green">"SIGWINCH"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 28 */</span>
	<span class="s" style="color:green">"SIGIO"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 29 */</span>
	<span class="s" style="color:green">"SIGPWR"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 30 */</span>
	<span class="s" style="color:green">"SIGSYS"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 31 */</span>
	<span class="s" style="color:green">"SIGRTMIN"</span>,	<span class="c" style="color:rgb(102,102,102)">/* 32 */</span></pre> 
 <pre style="border:0px; margin-top:0px; margin-bottom:0px"><span style="font-family:Arial,Helvetica,sans-serif; font-size:12px; text-align:center; color:rgb(119,119,119); background-color:rgb(255,255,255)">
</span></pre> 
 <pre style="border:0px; margin-top:0px; margin-bottom:0px"><span style="font-family:Arial,Helvetica,sans-serif; font-size:12px; text-align:center; color:rgb(119,119,119); background-color:rgb(255,255,255)">root@scorpio:/data/anr # ps -t | grep 4501</span></pre> 
</div> 
<p></p> 
<p>system    4501  667   1608988 64804 SyS_epoll_ 7fac377434 S com.securitycore<br> <strong>system    4507  4501  1608988 64804 do_sigtime 7fac377614 S Signal Catcher</strong><br> system    4508  4501  1608988 64804 unix_strea 7fac377f8c S JDWP<br> system    4509  4501  1608988 64804 futex_wait 7fac32b038 S ReferenceQueueD<br> system    4510  4501  1608988 64804 futex_wait 7fac32b038 S FinalizerDaemon<br> system    4511  4501  1608988 64804 futex_wait 7fac32b038 S FinalizerWatchd<br> system    4513  4501  1608988 64804 futex_wait 7fac32b038 S HeapTaskDaemon<br> system    4514  4501  1608988 64804 binder_thr 7fac377524 S Binder_1<br> system    4515  4501  1608988 64804 binder_thr 7fac377524 S Binder_2<br> system    4517  4501  1608988 64804 SyS_epoll_ 7fac377434 S local_job_dispa<br> system    4519  4501  1608988 64804 SyS_epoll_ 7fac377434 S remote_job_disp<br> system    4520  4501  1608988 64804 SyS_epoll_ 7fac377434 S BindServiceThre<br> system    4522  4501  1608988 64804 futex_wait 7fac32b038 S pool-2-thread-1<br> system    4537  4501  1608988 64804 futex_wait 7fac32b038 S Okio Watchdog<br> system    4539  4501  1608988 64804 futex_wait 7fac32b038 S pool-3-thread-1<br> system    6989  4501  1608988 64804 SyS_epoll_ 7fac377434 S WifiManager<br> </p> 
<p><br> </p> 
<p>/art/runtime/signal_catcher.cc<br> SignalCatcher::SignalCatcher(const std::string&amp; stack_trace_file)<br>     : stack_trace_file_(stack_trace_file),<br>       lock_("SignalCatcher lock"),<br>       cond_("SignalCatcher::cond_", lock_),<br>       thread_(nullptr) {<!-- --><br>   SetHaltFlag(false);<br> <br> <br>   // Create a raw pthread; its start routine will attach to the runtime.<br> <strong>  CHECK_PTHREAD_CALL(pthread_create, (&amp;pthread_, nullptr, &amp;Run, this), "signal catcher thread");</strong><br> <br> <br>   Thread* self = Thread::Current();<br>   MutexLock mu(self, lock_);<br>   while (thread_ == nullptr) {<!-- --><br>     cond_.Wait(self);<br>   }<br> }<br> <br> <br> void* SignalCatcher::Run(void* arg) {<!-- --><br>   SignalCatcher* signal_catcher = reinterpret_cast&lt;SignalCatcher*&gt;(arg);<br>   CHECK(signal_catcher != nullptr);<br> <br> <br>   Runtime* runtime = Runtime::Current();<br>   CHECK(runtime-&gt;AttachCurrentThread("Signal Catcher", true, runtime-&gt;GetSystemThreadGroup(),<br>                                      !runtime-&gt;IsAotCompiler()));<br> <br> <br>   Thread* self = Thread::Current();<br>   DCHECK_NE(self-&gt;GetState(), kRunnable);<br>   {<!-- --><br>     MutexLock mu(self, signal_catcher-&gt;lock_);<br>     signal_catcher-&gt;thread_ = self;<br>     signal_catcher-&gt;cond_.Broadcast(self);<br>   }<br> <br> <br> <strong>  // Set up mask with signals we want to handle.<br>   SignalSet signals;<br>   signals.Add(SIGQUIT);<br>   signals.Add(SIGUSR1);</strong><br> <br> <br>   while (true) {<!-- --><br>     int signal_number = signal_catcher-&gt;WaitForSignal(self, signals);<br>     if (signal_catcher-&gt;ShouldHalt()) {<!-- --><br>       runtime-&gt;DetachCurrentThread();<br>       return nullptr;<br>     }<br> <br> <br>     switch (signal_number) {<!-- --><br> <strong>    case SIGQUIT:<br>       signal_catcher-&gt;HandleSigQuit();</strong><br>       break;<br>     case SIGUSR1:<br>       signal_catcher-&gt;HandleSigUsr1();<br>       break;<br>     default:<br>       LOG(ERROR) &lt;&lt; "Unexpected signal %d" &lt;&lt; signal_number;<br>       break;<br>     }<br>   }<br> }<br> </p> 
<p><br> </p> 
<p>trace文件的控制框架：</p> 
<p>void SignalCatcher::HandleSigQuit() {<!-- --><br>   Runtime* runtime = Runtime::Current();<br>   std::ostringstream os;<br>   os &lt;&lt; "\n"<br>      <strong> &lt;&lt; "----- pid " &lt;&lt; getpid() &lt;&lt; " at " &lt;&lt; GetIsoDate() &lt;&lt; " -----\n";</strong><br> <br> <br>   DumpCmdLine(os);<br> <br> <br>   // Note: The strings "Build fingerprint:" and "ABI:" are chosen to match the format used by<br>   // debuggerd. This allows, for example, the stack tool to work.<br>   std::string fingerprint = runtime-&gt;GetFingerprint();<br>   os &lt;&lt; "Build fingerprint: '" &lt;&lt; (fingerprint.empty() ? "unknown" : fingerprint) &lt;&lt; "'\n";<br>   os &lt;&lt; "ABI: '" &lt;&lt; GetInstructionSetString(runtime-&gt;GetInstructionSet()) &lt;&lt; "'\n";<br> <br> <br>   os &lt;&lt; "Build type: " &lt;&lt; (kIsDebugBuild ? "debug" : "optimized") &lt;&lt; "\n";<br> <br> <br>   runtime-&gt;DumpForSigQuit(os);<br> <br> <br>   if ((false)) {<!-- --><br>     std::string maps;<br>     if (ReadFileToString("/proc/self/maps", &amp;maps)) {<!-- --><br>       os &lt;&lt; "/proc/self/maps:\n" &lt;&lt; maps;<br>     }<br>   }<br> <strong>  os &lt;&lt; "----- end " &lt;&lt; getpid() &lt;&lt; " -----\n";</strong><br>   Output(os.str());<br> }<br> </p> 
<p><br> </p> 
<p>void Runtime::DumpForSigQuit(std::ostream&amp; os) {<!-- --><br>   GetClassLinker()-&gt;DumpForSigQuit(os);<br>   GetInternTable()-&gt;DumpForSigQuit(os);<br>   GetJavaVM()-&gt;DumpForSigQuit(os);<br>   GetHeap()-&gt;DumpForSigQuit(os);<br>   TrackedAllocators::Dump(os);<br>   os &lt;&lt; "\n";<br> <br> <br>   thread_list_-&gt;DumpForSigQuit(os);<br>   BaseMutex::DumpAll(os);<br> }<br> </p> 
<p>void ClassLinker::DumpForSigQuit(std::ostream&amp; os) {<!-- --><br>   Thread* self = Thread::Current();<br>   if (dex_cache_image_class_lookup_required_) {<!-- --><br>     ScopedObjectAccess soa(self);<br>     MoveImageClassesToClassTable();<br>   }<br>   ReaderMutexLock mu(self, *Locks::classlinker_classes_lock_);<br>   os &lt;&lt; "Zygote loaded classes=" &lt;&lt; pre_zygote_class_table_.Size() &lt;&lt; " post zygote classes="<br>      &lt;&lt; class_table_.Size() &lt;&lt; "\n";<br> }<br> <br> <br> void InternTable::DumpForSigQuit(std::ostream&amp; os) const {<!-- --><br>   os &lt;&lt; "Intern table: " &lt;&lt; StrongSize() &lt;&lt; " strong; " &lt;&lt; WeakSize() &lt;&lt; " weak\n";<br> }<br> <br> <br> void JavaVMExt::DumpForSigQuit(std::ostream&amp; os) {<!-- --><br>   os &lt;&lt; "JNI: CheckJNI is " &lt;&lt; (check_jni_ ? "on" : "off");<br>   if (force_copy_) {<!-- --><br>     os &lt;&lt; " (with forcecopy)";<br>   }<br>   Thread* self = Thread::Current();<br>   {<!-- --><br>     ReaderMutexLock mu(self, globals_lock_);<br>     os &lt;&lt; "; globals=" &lt;&lt; globals_.Capacity();<br>   }<br>   {<!-- --><br>     MutexLock mu(self, weak_globals_lock_);<br>     if (weak_globals_.Capacity() &gt; 0) {<!-- --><br>       os &lt;&lt; " (plus " &lt;&lt; weak_globals_.Capacity() &lt;&lt; " weak)";<br>     }<br>   }<br>   os &lt;&lt; '\n';<br> <br> <br>   {<!-- --><br>     MutexLock mu(self, *Locks::jni_libraries_lock_);<br>     os &lt;&lt; "Libraries: " &lt;&lt; Dumpable&lt;Libraries&gt;(*libraries_) &lt;&lt; " (" &lt;&lt; libraries_-&gt;size() &lt;&lt; ")\n";<br>   }<br> }<br> <br> <br> void Heap::DumpForSigQuit(std::ostream&amp; os) {<!-- --><br>   os &lt;&lt; "Heap: " &lt;&lt; GetPercentFree() &lt;&lt; "% free, " &lt;&lt; PrettySize(GetBytesAllocated()) &lt;&lt; "/"<br>      &lt;&lt; PrettySize(GetTotalMemory()) &lt;&lt; "; " &lt;&lt; GetObjectsAllocated() &lt;&lt; " objects\n";<br>   DumpGcPerformanceInfo(os);<br> }<br> <br> <br> void Heap::DumpGcPerformanceInfo(std::ostream&amp; os) {<!-- --><br>   // Dump cumulative timings.<br>   os &lt;&lt; "Dumping cumulative Gc timings\n";<br>   uint64_t total_duration = 0;<br>   // Dump cumulative loggers for each GC type.<br>   uint64_t total_paused_time = 0;<br>   for (auto&amp; collector : garbage_collectors_) {<!-- --><br>     total_duration += collector-&gt;GetCumulativeTimings().GetTotalNs();<br>     total_paused_time += collector-&gt;GetTotalPausedTimeNs();<br>     collector-&gt;DumpPerformanceInfo(os);<br>   }<br>   uint64_t allocation_time =<br>       static_cast&lt;uint64_t&gt;(total_allocation_time_.LoadRelaxed()) * kTimeAdjust;<br>   if (total_duration != 0) {<!-- --><br>     const double total_seconds = static_cast&lt;double&gt;(total_duration / 1000) / 1000000.0;<br>     os &lt;&lt; "Total time spent in GC: " &lt;&lt; PrettyDuration(total_duration) &lt;&lt; "\n";<br>     os &lt;&lt; "Mean GC size throughput: "<br>        &lt;&lt; PrettySize(GetBytesFreedEver() / total_seconds) &lt;&lt; "/s\n";<br>     os &lt;&lt; "Mean GC object throughput: "<br>        &lt;&lt; (GetObjectsFreedEver() / total_seconds) &lt;&lt; " objects/s\n";<br>   }<br>   uint64_t total_objects_allocated = GetObjectsAllocatedEver();<br>   os &lt;&lt; "Total number of allocations " &lt;&lt; total_objects_allocated &lt;&lt; "\n";<br>   os &lt;&lt; "Total bytes allocated " &lt;&lt; PrettySize(GetBytesAllocatedEver()) &lt;&lt; "\n";<br>   os &lt;&lt; "Total bytes freed " &lt;&lt; PrettySize(GetBytesFreedEver()) &lt;&lt; "\n";<br>   os &lt;&lt; "Free memory " &lt;&lt; PrettySize(GetFreeMemory()) &lt;&lt; "\n";<br>   os &lt;&lt; "Free memory until GC " &lt;&lt; PrettySize(GetFreeMemoryUntilGC()) &lt;&lt; "\n";<br>   os &lt;&lt; "Free memory until OOME " &lt;&lt; PrettySize(GetFreeMemoryUntilOOME()) &lt;&lt; "\n";<br>   os &lt;&lt; "Total memory " &lt;&lt; PrettySize(GetTotalMemory()) &lt;&lt; "\n";<br>   os &lt;&lt; "Max memory " &lt;&lt; PrettySize(GetMaxMemory()) &lt;&lt; "\n";<br>   if (kMeasureAllocationTime) {<!-- --><br>     os &lt;&lt; "Total time spent allocating: " &lt;&lt; PrettyDuration(allocation_time) &lt;&lt; "\n";<br>     os &lt;&lt; "Mean allocation time: " &lt;&lt; PrettyDuration(allocation_time / total_objects_allocated)<br>        &lt;&lt; "\n";<br>   }<br>   if (HasZygoteSpace()) {<!-- --><br>     os &lt;&lt; "Zygote space size " &lt;&lt; PrettySize(zygote_space_-&gt;Size()) &lt;&lt; "\n";<br>   }<br>   os &lt;&lt; "Total mutator paused time: " &lt;&lt; PrettyDuration(total_paused_time) &lt;&lt; "\n";<br>   os &lt;&lt; "Total time waiting for GC to complete: " &lt;&lt; PrettyDuration(total_wait_time_) &lt;&lt; "\n";<br>   os &lt;&lt; "Total GC count: " &lt;&lt; GetGcCount() &lt;&lt; "\n";<br>   os &lt;&lt; "Total GC time: " &lt;&lt; PrettyDuration(GetGcTime()) &lt;&lt; "\n";<br>   os &lt;&lt; "Total blocking GC count: " &lt;&lt; GetBlockingGcCount() &lt;&lt; "\n";<br>   os &lt;&lt; "Total blocking GC time: " &lt;&lt; PrettyDuration(GetBlockingGcTime()) &lt;&lt; "\n";<br> <br> <br>   {<!-- --><br>     MutexLock mu(Thread::Current(), *gc_complete_lock_);<br>     if (gc_count_rate_histogram_.SampleSize() &gt; 0U) {<!-- --><br>       os &lt;&lt; "Histogram of GC count per " &lt;&lt; NsToMs(kGcCountRateHistogramWindowDuration) &lt;&lt; " ms: ";<br>       gc_count_rate_histogram_.DumpBins(os);<br>       os &lt;&lt; "\n";<br>     }<br>     if (blocking_gc_count_rate_histogram_.SampleSize() &gt; 0U) {<!-- --><br>       os &lt;&lt; "Histogram of blocking GC count per "<br>          &lt;&lt; NsToMs(kGcCountRateHistogramWindowDuration) &lt;&lt; " ms: ";<br>       blocking_gc_count_rate_histogram_.DumpBins(os);<br>       os &lt;&lt; "\n";<br>     }<br>   }<br> <br> <br>   BaseMutex::DumpAll(os);<br> }<br> void BaseMutex::DumpAll(std::ostream&amp; os) {<!-- --><br>   if (kLogLockContentions) {<!-- --><br>     os &lt;&lt; "Mutex logging:\n";<br>     ScopedAllMutexesLock mu(reinterpret_cast&lt;const BaseMutex*&gt;(-1));<br>     std::set&lt;BaseMutex*&gt;* all_mutexes = gAllMutexData-&gt;all_mutexes;<br>     if (all_mutexes == nullptr) {<!-- --><br>       // No mutexes have been created yet during at startup.<br>       return;<br>     }<br>     typedef std::set&lt;BaseMutex*&gt;::const_iterator It;<br>     os &lt;&lt; "(Contended)\n";<br>     for (It it = all_mutexes-&gt;begin(); it != all_mutexes-&gt;end(); ++it) {<!-- --><br>       BaseMutex* mutex = *it;<br>       if (mutex-&gt;HasEverContended()) {<!-- --><br>         mutex-&gt;Dump(os);<br>         os &lt;&lt; "\n";<br>       }<br>     }<br>     os &lt;&lt; "(Never contented)\n";<br>     for (It it = all_mutexes-&gt;begin(); it != all_mutexes-&gt;end(); ++it) {<!-- --><br>       BaseMutex* mutex = *it;<br>       if (!mutex-&gt;HasEverContended()) {<!-- --><br>         mutex-&gt;Dump(os);<br>         os &lt;&lt; "\n";<br>       }<br>     }<br>   }<br> }<br> <br> <br> void Dump(std::ostream&amp; os) {<!-- --><br>   if (kEnableTrackingAllocator) {<!-- --><br>     os &lt;&lt; "Dumping native memory usage\n";<br>     for (size_t i = 0; i &lt; kAllocatorTagCount; ++i) {<!-- --><br>       uint64_t bytes_used = g_bytes_used[i].LoadRelaxed();<br>       uint64_t max_bytes_used = g_max_bytes_used[i];<br>       uint64_t total_bytes_used = g_total_bytes_used[i].LoadRelaxed();<br>       if (total_bytes_used != 0) {<!-- --><br>         os &lt;&lt; static_cast&lt;AllocatorTag&gt;(i) &lt;&lt; " active=" &lt;&lt; bytes_used &lt;&lt; " max="<br>            &lt;&lt; max_bytes_used &lt;&lt; " total=" &lt;&lt; total_bytes_used &lt;&lt; "\n";<br>       }<br>     }<br>   }<br> }<br> <br> <br> void ThreadList::DumpForSigQuit(std::ostream&amp; os) {<!-- --><br>   {<!-- --><br>     ScopedObjectAccess soa(Thread::Current());<br>     // Only print if we have samples.<br>     if (suspend_all_historam_.SampleSize() &gt; 0) {<!-- --><br>       Histogram&lt;uint64_t&gt;::CumulativeData data;<br>       suspend_all_historam_.CreateHistogram(&amp;data);<br>       suspend_all_historam_.PrintConfidenceIntervals(os, 0.99, data);  // Dump time to suspend.<br>     }<br>   }<br>   Dump(os);<br>   DumpUnattachedThreads(os);<br> }<br> <br> <br> void ThreadList::Dump(std::ostream&amp; os) {<!-- --><br>   {<!-- --><br>     MutexLock mu(Thread::Current(), *Locks::thread_list_lock_);<br>     os &lt;&lt; "DALVIK THREADS (" &lt;&lt; list_.size() &lt;&lt; "):\n";<br>   }<br>   DumpCheckpoint checkpoint(&amp;os);<br>   size_t threads_running_checkpoint = RunCheckpoint(&amp;checkpoint);<br>   if (threads_running_checkpoint != 0) {<!-- --><br>     checkpoint.WaitForThreadsToRunThroughCheckpoint(threads_running_checkpoint);<br>   }<br> }<br> <br> <br> size_t ThreadList::RunCheckpoint(Closure* checkpoint_function) -&gt;<br> <span style="white-space:pre"></span>checkpoint_function-&gt;Run(self);<br> <br> <br>   void Run(Thread* thread) OVERRIDE {<!-- --><br>     // Note thread and self may not be equal if thread was already suspended at the point of the<br>     // request.<br>     Thread* self = Thread::Current();<br>     std::ostringstream local_os;<br>     {<!-- --><br>       ScopedObjectAccess soa(self);<br>       thread-&gt;Dump(local_os);<br>     }<br>     local_os &lt;&lt; "\n";<br>     {<!-- --><br>       // Use the logging lock to ensure serialization when writing to the common ostream.<br>       MutexLock mu(self, *Locks::logging_lock_);<br>       *os_ &lt;&lt; local_os.str();<br>     }<br>     if (thread-&gt;GetState() == kRunnable) {<!-- --><br>       barrier_.Pass(self);<br>     }<br>   }<br> <br> <br> void Thread::Dump(std::ostream&amp; os) const {<!-- --><br>   DumpState(os);<br>   DumpStack(os);<br> }<br> <br> <br> void Thread::DumpState(std::ostream&amp; os, const Thread* thread, pid_t tid) {<!-- --><br>   std::string group_name;<br>   int priority;<br>   bool is_daemon = false;<br>   Thread* self = Thread::Current();<br> <br> <br>   // If flip_function is not null, it means we have run a checkpoint<br>   // before the thread wakes up to execute the flip function and the<br>   // thread roots haven't been forwarded.  So the following access to<br>   // the roots (opeer or methods in the frames) would be bad. Run it<br>   // here. TODO: clean up.<br>   if (thread != nullptr) {<!-- --><br>     ScopedObjectAccessUnchecked soa(self);<br>     Thread* this_thread = const_cast&lt;Thread*&gt;(thread);<br>     Closure* flip_func = this_thread-&gt;GetFlipFunction();<br>     if (flip_func != nullptr) {<!-- --><br>       flip_func-&gt;Run(this_thread);<br>     }<br>   }<br> <br> <br>   // Don't do this if we are aborting since the GC may have all the threads suspended. This will<br>   // cause ScopedObjectAccessUnchecked to deadlock.<br>   if (gAborting == 0 &amp;&amp; self != nullptr &amp;&amp; thread != nullptr &amp;&amp; thread-&gt;tlsPtr_.opeer != nullptr) {<!-- --><br>     ScopedObjectAccessUnchecked soa(self);<br>     priority = soa.DecodeField(WellKnownClasses::java_lang_Thread_priority)<br>         -&gt;GetInt(thread-&gt;tlsPtr_.opeer);<br>     is_daemon = soa.DecodeField(WellKnownClasses::java_lang_Thread_daemon)<br>         -&gt;GetBoolean(thread-&gt;tlsPtr_.opeer);<br> <br> <br>     mirror::Object* thread_group =<br>         soa.DecodeField(WellKnownClasses::java_lang_Thread_group)-&gt;GetObject(thread-&gt;tlsPtr_.opeer);<br> <br> <br>     if (thread_group != nullptr) {<!-- --><br>       ArtField* group_name_field =<br>           soa.DecodeField(WellKnownClasses::java_lang_ThreadGroup_name);<br>       mirror::String* group_name_string =<br>           reinterpret_cast&lt;mirror::String*&gt;(group_name_field-&gt;GetObject(thread_group));<br>       group_name = (group_name_string != nullptr) ? group_name_string-&gt;ToModifiedUtf8() : "&lt;null&gt;";<br>     }<br>   } else {<!-- --><br>     priority = GetNativePriority();<br>   }<br> <br> <br>   std::string scheduler_group_name(GetSchedulerGroupName(tid));<br>   if (scheduler_group_name.empty()) {<!-- --><br>     scheduler_group_name = "default";<br>   }<br> <br> <br>   if (thread != nullptr) {<!-- --><br>     os &lt;&lt; '"' &lt;&lt; *thread-&gt;tlsPtr_.name &lt;&lt; '"';<br>     if (is_daemon) {<!-- --><br>       os &lt;&lt; " daemon";<br>     }<br>     os &lt;&lt; " prio=" &lt;&lt; priority<br>        &lt;&lt; " tid=" &lt;&lt; thread-&gt;GetThreadId()<br>        &lt;&lt; " " &lt;&lt; thread-&gt;GetState();<br>     if (thread-&gt;IsStillStarting()) {<!-- --><br>       os &lt;&lt; " (still starting up)";<br>     }<br>     os &lt;&lt; "\n";<br>   } else {<!-- --><br>     os &lt;&lt; '"' &lt;&lt; ::art::GetThreadName(tid) &lt;&lt; '"'<br>        &lt;&lt; " prio=" &lt;&lt; priority<br>        &lt;&lt; " (not attached)\n";<br>   }<br> <br> <br>   if (thread != nullptr) {<!-- --><br>     MutexLock mu(self, *Locks::thread_suspend_count_lock_);<br>     os &lt;&lt; "  | group=\"" &lt;&lt; group_name &lt;&lt; "\""<br>        &lt;&lt; " sCount=" &lt;&lt; thread-&gt;tls32_.suspend_count<br>        &lt;&lt; " dsCount=" &lt;&lt; thread-&gt;tls32_.debug_suspend_count<br>        &lt;&lt; " obj=" &lt;&lt; reinterpret_cast&lt;void*&gt;(thread-&gt;tlsPtr_.opeer)<br>        &lt;&lt; " self=" &lt;&lt; reinterpret_cast&lt;const void*&gt;(thread) &lt;&lt; "\n";<br>   }<br> <br> <br>   os &lt;&lt; "  | sysTid=" &lt;&lt; tid<br>      &lt;&lt; " nice=" &lt;&lt; getpriority(PRIO_PROCESS, tid)<br>      &lt;&lt; " cgrp=" &lt;&lt; scheduler_group_name;<br>   if (thread != nullptr) {<!-- --><br>     int policy;<br>     sched_param sp;<br>     CHECK_PTHREAD_CALL(pthread_getschedparam, (thread-&gt;tlsPtr_.pthread_self, &amp;policy, &amp;sp),<br>                        __FUNCTION__);<br>     os &lt;&lt; " sched=" &lt;&lt; policy &lt;&lt; "/" &lt;&lt; sp.sched_priority<br>        &lt;&lt; " handle=" &lt;&lt; reinterpret_cast&lt;void*&gt;(thread-&gt;tlsPtr_.pthread_self);<br>   }<br>   os &lt;&lt; "\n";<br> <br> <br>   // Grab the scheduler stats for this thread.<br>   std::string scheduler_stats;<br>   if (ReadFileToString(StringPrintf("/proc/self/task/%d/schedstat", tid), &amp;scheduler_stats)) {<!-- --><br>     scheduler_stats.resize(scheduler_stats.size() - 1);  // Lose the trailing '\n'.<br>   } else {<!-- --><br>     scheduler_stats = "0 0 0";<br>   }<br> <br> <br>   char native_thread_state = '?';<br>   int utime = 0;<br>   int stime = 0;<br>   int task_cpu = 0;<br>   GetTaskStats(tid, &amp;native_thread_state, &amp;utime, &amp;stime, &amp;task_cpu);<br> <br> <br>   os &lt;&lt; "  | state=" &lt;&lt; native_thread_state<br>      &lt;&lt; " schedstat=( " &lt;&lt; scheduler_stats &lt;&lt; " )"<br>      &lt;&lt; " utm=" &lt;&lt; utime<br>      &lt;&lt; " stm=" &lt;&lt; stime<br>      &lt;&lt; " core=" &lt;&lt; task_cpu<br>      &lt;&lt; " HZ=" &lt;&lt; sysconf(_SC_CLK_TCK) &lt;&lt; "\n";<br>   if (thread != nullptr) {<!-- --><br>     os &lt;&lt; "  | stack=" &lt;&lt; reinterpret_cast&lt;void*&gt;(thread-&gt;tlsPtr_.stack_begin) &lt;&lt; "-"<br>         &lt;&lt; reinterpret_cast&lt;void*&gt;(thread-&gt;tlsPtr_.stack_end) &lt;&lt; " stackSize="<br>         &lt;&lt; PrettySize(thread-&gt;tlsPtr_.stack_size) &lt;&lt; "\n";<br>     // Dump the held mutexes.<br>     os &lt;&lt; "  | held mutexes=";<br>     for (size_t i = 0; i &lt; kLockLevelCount; ++i) {<!-- --><br>       if (i != kMonitorLock) {<!-- --><br>         BaseMutex* mutex = thread-&gt;GetHeldMutex(static_cast&lt;LockLevel&gt;(i));<br>         if (mutex != nullptr) {<!-- --><br>           os &lt;&lt; " \"" &lt;&lt; mutex-&gt;GetName() &lt;&lt; "\"";<br>           if (mutex-&gt;IsReaderWriterMutex()) {<!-- --><br>             ReaderWriterMutex* rw_mutex = down_cast&lt;ReaderWriterMutex*&gt;(mutex);<br>             if (rw_mutex-&gt;GetExclusiveOwnerTid() == static_cast&lt;uint64_t&gt;(tid)) {<!-- --><br>               os &lt;&lt; "(exclusive held)";<br>             } else {<!-- --><br>               os &lt;&lt; "(shared held)";<br>             }<br>           }<br>         }<br>       }<br>     }<br>     os &lt;&lt; "\n";<br>   }<br> }<br> <br> <br> void Thread::DumpStack(std::ostream&amp; os) const {<!-- --><br>   // TODO: we call this code when dying but may not have suspended the thread ourself. The<br>   //       IsSuspended check is therefore racy with the use for dumping (normally we inhibit<br>   //       the race with the thread_suspend_count_lock_).<br>   bool dump_for_abort = (gAborting &gt; 0);<br>   bool safe_to_dump = (this == Thread::Current() || IsSuspended());<br>   if (!kIsDebugBuild) {<!-- --><br>     // We always want to dump the stack for an abort, however, there is no point dumping another<br>     // thread's stack in debug builds where we'll hit the not suspended check in the stack walk.<br>     safe_to_dump = (safe_to_dump || dump_for_abort);<br>   }<br>   if (safe_to_dump) {<!-- --><br>     // If we're currently in native code, dump that stack before dumping the managed stack.<br>     if (dump_for_abort || ShouldShowNativeStack(this)) {<!-- --><br>       DumpKernelStack(os, GetTid(), "  kernel: ", false);<br>       DumpNativeStack(os, GetTid(), "  native: ", GetCurrentMethod(nullptr, !dump_for_abort));<br>     }<br>     DumpJavaStack(os);<br>   } else {<!-- --><br>     os &lt;&lt; "Not able to dump stack of thread that isn't suspended";<br>   }<br> }<br> </p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0f7f0f90defb432ffdb0fd1839c8dfee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">EventBus的坑</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ff44e57ec82d6095c524b3bf3954e4fe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于 eclipse 中R类文件报错</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>