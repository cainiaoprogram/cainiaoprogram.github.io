<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux内核配置编译以及模块开发 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux内核配置编译以及模块开发" />
<meta property="og:description" content="文章目录 Linux内核简介Linux体系结构Linux内核架构虚拟文件系统内核源码结构Linux内核配置与编译为什么要配置内核？内核配置方法编译内核过程 Linux内核模块开发什么是内核模块内核模块设计安装与卸载模块可选信息模块申明模块参数符号导出 总结-对比应用编译问题**编译内核错误：Can&#39;t use &#39;defined(@array)&#39; (Maybe you should just omit the defined()?) at kernel/timeconst.p...****linux/compiler-gcc9.h：没有那个文件或目录****编译内核出现：cc1: error: code model kernel does not support PIC mode**&#39;make menuconfig&#39; requires the ncurses libraries/bin/sh: 1: flex: not found/bin/sh: 1: bison: not foundfatal error: openssl/opensslv.h: 没有那个文件或目录make[1]: *** 没有规则可制作目标“debian/canonical-certs.pem” Linux内核简介 Linux体系结构 Linux由用户空间和内核空间组成
现代CPU通常实现了不同的工作模式，以ARM为例,实现了7种工作模式:
用户模式（ usr)、快速中断(fiq)、外部中断(irq)、管理模式( svc)、数据访问中止(abt)、系统模式(sys)、未定义指令异常(und)
X86也实现了4个不同的级别:Ring0-Ring3。Ring0下，可以执行特权指令，可以访问IO设备等，在Ring3则有很多限制。Linux系统利用了CPU的这一特性，使用了其中的两级来分别运行Linux内核与应用程序，这样使操作系统本身得到充分的保护。例如:如果使用X86，用户代码运行在Ring3，内核代码运行在Ring0。
内核空间与用户空间是程序执行的两种不同状态，通过系统调用和硬件中断能够完成从用户空间到内核空间的转移。
Linux内核架构 虚拟文件系统 VFS(虚拟文件系统)隐藏各种文件系统的具体细节，为文件操作提供统一的接口。
内核源码结构 arch目录
arch是architecture的缩写。内核所支持的每种CPU体系，在该目录下都有对应的子目录。每个CPU的子目录，又进一步分解为boot,mm,kernel等子目录，分别包含控制系统引导，内存管理，系统调用等。
documentation
内核的文档
drivers目录
设备驱动程序
include目录
内核所需要的头文件。与平台无关的头文件在include/linux子目录下面，与平台有关的头文件则放在对应的子目录中。
fs目录
存放各种文件系统的实现代码。每个子目录对应一种文件系统的实现，公用的源程序用于实现虚拟文件系统vfs.
net目录
网络协议的实现代码
Linux内核配置与编译 配置内核" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d0cfc0b3174cb95c5b78fc7dcd010e0c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-23T17:10:28+08:00" />
<meta property="article:modified_time" content="2021-09-23T17:10:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux内核配置编译以及模块开发</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Linux_1" rel="nofollow">Linux内核简介</a></li><li><ul><li><a href="#Linux_2" rel="nofollow">Linux体系结构</a></li><li><a href="#Linux_13" rel="nofollow">Linux内核架构</a></li><li><a href="#_17" rel="nofollow">虚拟文件系统</a></li><li><a href="#_22" rel="nofollow">内核源码结构</a></li><li><a href="#Linux_44" rel="nofollow">Linux内核配置与编译</a></li><li><a href="#_62" rel="nofollow">为什么要配置内核？</a></li><li><a href="#_67" rel="nofollow">内核配置方法</a></li><li><a href="#_81" rel="nofollow">编译内核</a></li><li><a href="#_88" rel="nofollow">过程</a></li></ul> 
  </li><li><a href="#Linux_150" rel="nofollow">Linux内核模块开发</a></li><li><ul><li><a href="#_162" rel="nofollow">什么是内核模块</a></li><li><a href="#_167" rel="nofollow">内核模块设计</a></li><li><a href="#_208" rel="nofollow">安装与卸载</a></li><li><a href="#_217" rel="nofollow">模块可选信息</a></li><li><ul><li><a href="#_221" rel="nofollow">模块申明</a></li><li><a href="#_227" rel="nofollow">模块参数</a></li><li><a href="#_264" rel="nofollow">符号导出</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_275" rel="nofollow">总结-对比应用</a></li><li><a href="#_305" rel="nofollow">编译问题</a></li><li><ul><li><a href="#Cant_use_definedarray_Maybe_you_should_just_omit_the_defined_at_kerneltimeconstp_308" rel="nofollow">**编译内核错误：Can't use 'defined(@array)' (Maybe you should just omit the defined()?) at kernel/timeconst.p...**</a></li><li><a href="#linuxcompilergcc9h_312" rel="nofollow">**linux/compiler-gcc9.h：没有那个文件或目录**</a></li><li><a href="#cc1_error_code_model_kernel_does_not_support_PIC_mode_315" rel="nofollow">**编译内核出现：cc1: error: code model kernel does not support PIC mode**</a></li><li><a href="#make_menuconfig_requires_the_ncurses_libraries_320" rel="nofollow">'make menuconfig' requires the ncurses libraries</a></li><li><a href="#binsh_1_flex_not_found_324" rel="nofollow">/bin/sh: 1: flex: not found</a></li><li><a href="#binsh_1_bison_not_found_328" rel="nofollow">/bin/sh: 1: bison: not found</a></li><li><a href="#fatal_error_opensslopensslvh__332" rel="nofollow">fatal error: openssl/opensslv.h: 没有那个文件或目录</a></li><li><a href="#make1__debiancanonicalcertspem_335" rel="nofollow">make[1]: *** 没有规则可制作目标“debian/canonical-certs.pem”</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="Linux_1"></a>Linux内核简介</h2> 
<h3><a id="Linux_2"></a>Linux体系结构</h3> 
<p><img src="https://images2.imgbox.com/87/96/jkqBi2Oy_o.png" alt="在这里插入图片描述"><br> Linux由用户空间和内核空间组成</p> 
<p>现代CPU通常实现了不同的工作模式，以ARM为例,实现了7种工作模式:<br> 用户模式（ usr)、快速中断(fiq)、外部中断(irq)、管理模式( svc)、数据访问中止(abt)、系统模式(sys)、未定义指令异常(und)</p> 
<p>X86也实现了4个不同的级别:Ring0-Ring3。Ring0下，可以执行特权指令，可以访问IO设备等，在Ring3则有很多限制。Linux系统利用了CPU的这一特性，使用了其中的两级来分别运行Linux内核与应用程序，这样使操作系统本身得到充分的保护。例如:如果使用X86，用户代码运行在Ring3，内核代码运行在Ring0。</p> 
<p>内核空间与用户空间是程序执行的两种不同状态，通过系统调用和硬件中断能够完成从用户空间到内核空间的转移。</p> 
<h3><a id="Linux_13"></a>Linux内核架构</h3> 
<p><img src="https://images2.imgbox.com/64/41/GghiIDjq_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_17"></a>虚拟文件系统</h3> 
<p>VFS(虚拟文件系统)隐藏各种文件系统的具体细节，为文件操作提供统一的接口。</p> 
<p><img src="https://images2.imgbox.com/1f/91/aVmnhy2N_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_22"></a>内核源码结构</h3> 
<p><img src="https://images2.imgbox.com/8a/77/BlbegsIs_o.png" alt="在这里插入图片描述"><br> <strong>arch目录</strong></p> 
<p>arch是architecture的缩写。内核所支持的每种CPU体系，在该目录下都有对应的子目录。每个CPU的子目录，又进一步分解为boot,mm,kernel等子目录，分别包含控制系统引导，内存管理，系统调用等。</p> 
<p><strong>documentation</strong><br> 内核的文档</p> 
<p><strong>drivers目录</strong><br> 设备驱动程序</p> 
<p><strong>include目录</strong><br> 内核所需要的头文件。与平台无关的头文件在include/linux子目录下面，与平台有关的头文件则放在对应的子目录中。</p> 
<p><strong>fs目录</strong><br> 存放各种文件系统的实现代码。每个子目录对应一种文件系统的实现，公用的源程序用于实现虚拟文件系统vfs.</p> 
<p><strong>net目录</strong><br> 网络协议的实现代码</p> 
<h3><a id="Linux_44"></a>Linux内核配置与编译</h3> 
<ul><li> <p>配置内核</p> 
  <ul><li>为什么需要配置内核</li><li>如何配置内核 
    <ul><li>make config</li><li>make menuconfig</li></ul> </li><li>内核配置结果</li></ul> </li><li> <p>编译内核</p> 
  <ul><li>make zlmage</li><li>make bzlmage</li></ul> </li><li> <p>编译内核模块</p> 
  <ul><li>make modules</li><li>make modules_install</li></ul> </li><li> <p>安装内核</p> </li><li> <p>清理内核</p> 
  <ul><li>make clean</li><li>make distclean</li></ul> </li></ul> 
<h3><a id="_62"></a>为什么要配置内核？</h3> 
<ol><li>硬件的需求</li><li>软件的需求<br> 选出需要的，去掉不需要的</li></ol> 
<h3><a id="_67"></a>内核配置方法</h3> 
<p>make config: 基于文本模式的交互式配置<br> make menuconfig: 基于文本模式的菜单型配置(更直观高效)</p> 
<p><strong>取值方式</strong><br> &lt;*&gt; 内核镜像直接带有该功能<br> &lt;m&gt; 内核模块方式导入该功能，模块导入的功能不是随时都要用的，需要的时候才会加入到内存中运行，不需要的时候不加载。<br> &lt;&gt; 不选择该功能</p> 
<p><strong>配置后的结果保存在<code>.config</code>中</strong></p> 
<p><strong>要使用内核配置文件简化配置</strong></p> 
<h3><a id="_81"></a>编译内核</h3> 
<p><strong>区别</strong>:在X86平台，zImage只能用于小于512K的内核<br> 如需获取详细编译信息，可使用:<br> <code>make zImage V=1</code><br> <code>make bzImage V=1</code><br> <strong>编译好的内核位干arch//boot/目录下</strong></p> 
<h3><a id="_88"></a>过程</h3> 
<p><strong>获取源码</strong><br> <a href="https://mirrors.edge.kernel.org/pub/linux/kernel/" rel="nofollow">官方网站链接</a></p> 
<p>在这里面选择你想要的源码</p> 
<p><img src="https://images2.imgbox.com/db/ec/4lGlUNMf_o.png" alt="在这里插入图片描述"><br> 在文件目录中<br> 然后将本机的配置文件复制过来，节省自己配置的时间<br> <code>cp /boot/config-5.11.0-27-generic ./.config</code></p> 
<p><img src="https://images2.imgbox.com/00/8b/FKVcpYHI_o.png" alt="在这里插入图片描述"><br> 然后使用<code>make menuconfig</code></p> 
<p><img src="https://images2.imgbox.com/99/ea/xvUnqLWI_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/97/ae/pP5gDo3Y_o.png" alt="在这里插入图片描述"><br> 然后使用<code>tab键</code>EXIT即可<br> 然后使用<br> <code>make bzImage</code><br> 完成后使用<br> <code>make modules</code><br> 然后使用<br> <code>make module_install</code><br> 然后制作init ramdisk<br> <img src="https://images2.imgbox.com/9c/9c/LIDZ8BK1_o.png" alt="在这里插入图片描述"><br> 在centos中使用mkinitrd<br> 方法:<br> <code>mkinitrd initrd-\$version \$version</code><br> 例:<br> <code>mkinitrd initrd-2.6.39 2.6.39</code><br> <code>*$version可以通过查询/lib/modules下的目录得到</code></p> 
<p>在ubuntu中使用mkinitramfs<br> <code>mkinitramfs 5.9.0 -o /boot/initrd-5.9.0</code></p> 
<p><strong>安装内核</strong><br> <a href="http://blog.chinaunix.net/uid-20672257-id-3239246.html" rel="nofollow">ubuntu命令安装内核源码及升级内核源码</a></p> 
<p><code>cp arch/x86/boot/bzImage /boot/vmlinuz-5.9.0</code><br> 将System.map复制至/boot下：<br> <code>cp System.map /boot/System.map-5.9.0</code></p> 
<p><strong>如果开机没有内核选择界面</strong><br> <a href="https://sfclaer.blog.csdn.net/article/details/88851908?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link" rel="nofollow">Ubuntu 系统开机 Grub 界面的开启和关闭</a><br> <img src="https://images2.imgbox.com/27/9d/UidRSz17_o.png" alt="在这里插入图片描述"><br> 在 /etc/default/grub 里面找到<br> GRUB_TIMEOUT_STYLE=hidden<br> GRUB_HIDDEN_TIMEOUT=0<br> 两个注释掉<br> 然后使用<br> <code>sudo update-grub2</code><br> 重启选择advance选项，选择最新的内核<br> <img src="https://images2.imgbox.com/a2/34/A7d7alsu_o.png" alt="在这里插入图片描述"></p> 
<p><strong>如果开机还是没有，那就再开机进入登录管理器后，选择poweroff,重启即可</strong></p> 
<p>然后使用<code>unamr -r</code>确定当前使用的内核版本</p> 
<p><img src="https://images2.imgbox.com/aa/e3/On3n8OAF_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="Linux_150"></a>Linux内核模块开发</h2> 
<ul><li>什么是内核模块</li><li>内核模块设计 
  <ul><li>主体部分设计</li><li>编译内核模块</li><li>安装/卸载内核模块</li><li>可选项使用 
    <ul><li>模块申明</li><li>模块参数</li><li>符号输出</li></ul> </li></ul> </li><li>内核打印</li></ul> 
<h3><a id="_162"></a>什么是内核模块</h3> 
<p>Linux内核的整体结构非常庞大，其包含的组件也非常多，如何使用这些组件呢？<br> 方法1:把所有的组件都编译进内核文件，即: zImage或bzImage，但这样会导致一个问题:内核文件过大，占用内存过多.<br> 有没有一种机制能让内核文件本身并不包含某组件，而是在该组件需要被使用的时候，动态地添加到正在运行的内核中呢?</p> 
<h3><a id="_167"></a>内核模块设计</h3> 
<p><strong>helloworld.c</strong></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//必须要加这句，不加报错</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hello_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_WARNING <span class="token string">"Hello, world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"Goodbye, world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>hello_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>hello_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>Makefile</strong></p> 
<pre><code class="prism language-makefile">obj-m := hello.o

KDIR := /lib/modules/`uname -r`/build

all:
	make -C $(KDIR) M=$(PWD) modules

</code></pre> 
<p>如果有多个文件要生成内核模块<br> <strong>Makefile</strong></p> 
<pre><code>obj-m := test.o
test-objs := hello.o hello1.o
KDIR := /lib/modules/`uname -r`/build

all:
	make -C $(KDIR) M=$(PWD) modules
</code></pre> 
<p><img src="https://images2.imgbox.com/80/3d/QM7tzI7j_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_208"></a>安装与卸载</h3> 
<p><strong>安装 insmod</strong><br> <code>insmod hello.ko</code><br> <strong>卸载 rmmod</strong><br> <code>rmmod hello</code><br> <strong>查看 lsmod</strong></p> 
<p><img src="https://images2.imgbox.com/29/b2/Tei9o5It_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_217"></a>模块可选信息</h3> 
<ul><li>模块申明</li><li>模块参数</li><li>符号输出</li></ul> 
<h4><a id="_221"></a>模块申明</h4> 
<ol><li>MODULE_LICENSE(“遵守的协议”)</li><li>MODULE_AUTHOR(“作者”)</li><li>MODULE_DESCRIPTION(“模块功能描述”)</li><li>MODULE_VERSION(“V1.0版本”)</li></ol> 
<h4><a id="_227"></a>模块参数</h4> 
<ol><li>内核模块可以通过命令行输入参数</li></ol> 
<p>通过宏<code>module param</code>指定保存模块参数的变量。模块参数用于在加载模块时传递参数给模块。<br> <code>module_param(name ,type,perm)</code><br> <strong>name:变量的名称</strong><br> <strong>type:变量类型，bool:布尔型i nt:整型 charp:字符串型<br> perm是访问权限。S_IRUGO:读权限 S_IWUSR:写权限</strong><br> 例;<br> int a = 3;<br> char *st;<br> module_param(a , int , S_IRUGO);<br> module_param(st,charp, S_IRUGO);</p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/module.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;linux/init.h&gt;</span></span>
<span class="token function">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"willpower"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span>
<span class="token function">module_param</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> S_IRUGO<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hello_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token string">"a is %d\n"</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_WARNING <span class="token string">"Hello, world!\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">hello_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">printk</span><span class="token punctuation">(</span>KERN_INFO <span class="token string">"Goodbye, world\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">module_init</span><span class="token punctuation">(</span>hello_init<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>hello_exit<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_264"></a>符号导出</h4> 
<p><strong>为什么到导出符号？</strong><br> 申明此函数是可以其他文件来使用的</p> 
<p><strong>内核符号的导出使用宏</strong><br> EXPORT_SYMBOL(符号名)<br> EXPORT_SYMBOL_GPL(符号名)<br> 说明:<br> 其中EXPORT_SYMBOL_GPL智能包含用于包含GPL许可证的模块</p> 
<h2><a id="_275"></a>总结-对比应用</h2> 
<p>对比应用程序，内核模块具有以下不同:</p> 
<ol><li>应用程序是从头(main)到尾执行任务，执<br> 行结束后从内存中消失。</li><li>内核模块的初始化函数结束时,模块仍然<br> 存在于内核中，直到卸载函数被调用,模块才从内核中消失。</li></ol> 
<p><strong>内核打印</strong><br> printk是内核中出现最频繁的函数之一，通过将printk与printf对比，将有助于理解。<br> 相同点:</p> 
<ul><li>打印信息<br> 不同点:</li><li>printk在内核中使用，printf在应用程序中使用</li><li>printk允许根据严重程度，通过附加不同的“优先级”来对消息分类。</li></ul> 
<p>在&lt;linux/kernel.h&gt;中定义了8种记录级别。按照优先级递减的顺序分别是:</p> 
<pre><code>KERN_EMERG	   “&lt;0&gt;”       用于紧急消息,常常是那些崩溃前的消息。
KERN_ALERT     “&lt;1&gt;"      需要立刻行动的消息。
KERN_CRIT	   “&lt;2&gt;"  	   严重情况。
KERN_ERR	   “&lt;3&gt;"       错误情况。
</code></pre> 
<p>没有指定优先级的printk默认使用<br> DEFAULT_MESSAGE_LOGLEVEL优先级，它是一个在kernel/printk.c中定义的整数。</p> 
<h2><a id="_305"></a>编译问题</h2> 
<p><strong>在ubuntu16.04中编译成功了linux2.6.39版本,18.04及其以上没有成功</strong></p> 
<h3><a id="Cant_use_definedarray_Maybe_you_should_just_omit_the_defined_at_kerneltimeconstp_308"></a><strong>编译内核错误：Can’t use ‘defined(@array)’ (Maybe you should just omit the defined()?) at kernel/timeconst.p…</strong></h3> 
<p><a href="https://blog.csdn.net/weixin_33774883/article/details/93513102">参考文章</a><br> <img src="https://images2.imgbox.com/12/cc/p9PvvoHe_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="linuxcompilergcc9h_312"></a><strong>linux/compiler-gcc9.h：没有那个文件或目录</strong></h3> 
<p>将<code>include/linux/</code>的compiler-gcc3.h复制一份，改为compiler-gcc9.h的名字</p> 
<h3><a id="cc1_error_code_model_kernel_does_not_support_PIC_mode_315"></a><strong>编译内核出现：cc1: error: code model kernel does not support PIC mode</strong></h3> 
<p><a href="https://blog.csdn.net/jasonLee_lijiaqi/article/details/84651138">参考文章</a></p> 
<p><img src="https://images2.imgbox.com/9b/4d/SUIyXV7W_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="make_menuconfig_requires_the_ncurses_libraries_320"></a>‘make menuconfig’ requires the ncurses libraries</h3> 
<p>安装<code>libncurses5-dev</code></p> 
<h3><a id="binsh_1_flex_not_found_324"></a>/bin/sh: 1: flex: not found</h3> 
<p><code>sudo apt install flex -y</code></p> 
<h3><a id="binsh_1_bison_not_found_328"></a>/bin/sh: 1: bison: not found</h3> 
<p><code>sudo apt install bison -y</code></p> 
<h3><a id="fatal_error_opensslopensslvh__332"></a>fatal error: openssl/opensslv.h: 没有那个文件或目录</h3> 
<p><code>sudo apt install libssl-dev</code></p> 
<h3><a id="make1__debiancanonicalcertspem_335"></a>make[1]: *** 没有规则可制作目标“debian/canonical-certs.pem”</h3> 
<p><img src="https://images2.imgbox.com/ad/a1/rdLlORBs_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/80721e00ac2011a2f05b58900eb0b6c0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">KieWorkbench&#43;KieServer&#43;Wildfly安装部署</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7259560525437e4254483a272da06579/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DropdownMenu 下拉菜单的使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>