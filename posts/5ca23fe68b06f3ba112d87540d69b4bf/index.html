<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>远程代码注入及DLL注入教程(InlineHook)---植物大战僵尸为例 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="远程代码注入及DLL注入教程(InlineHook)---植物大战僵尸为例" />
<meta property="og:description" content="远程代码注入及DLL注入教程 说明 ​ 本人刚开始学习逆向，不知道有没有动力学下深去，这一块也没有详细的实战教学，学多少就上传多少，希望能给想学的朋友一点帮助吧，本教程想通过植物大战僵尸这一经典游戏来抛砖引玉，教大家如何编写一个单机辅助。
​ CE找数据的过程本教程不提供，本文着重讲述如何根据找到的数据实现无限阳光，无冷却，其他诸如秒杀僵尸，后台运行等均大同小异。
所需基础 CE找关键数据基址（网上教程很多）、基本汇编命令
涉及工具 VS、CheatEngine（CE，网上很多）、汇编转机器码工具（我在用的https://www.jb51.net/softs/629217.html）、DLL注入工具（网上很多）
开始 无限冷却 ​ 假设第一个植物栏的冷却地址已找到，如图：
此时种下植物后暂停游戏，切到CE，选中冷却地址，右键-找出什么改写了这个地址，然后继续游戏，发现改写的代码：
点击显示汇编代码：
经过分析发现：如果还在冷却，那么在②处判断会跳走，把②处代码nop掉，让代码无论如何也会去Call③，发现植物已经实现无冷却（有很多种方法，比如把①修改为cmp eax,0），那么只需要如下代码即可实现：
BYTE noCD[2] = {0}; memset(noCD, 0x90, 2);//nop硬编码为0x90 WriteProcessMemory(hProcess, (LPVOID)(0x487296), noCD, 2, NULL); 无限阳光 像前面这种替换指令所用空间小于当前代码的方式，实现起来非常简单，但如果替换的汇编指令超过当前代码长度，将会导致后面指令被覆盖，引起崩溃，此时需要用到代码注入。
选中找到的阳光值地址，右键-找出什么访问了这个地址
可以看到有两处频繁访问，我们选择访问次数较少的第二条-显示反汇编程序。
那就在这里注入吧，前面已经知道，阳光值的地址为[[[基址006A9EC0]-&gt;偏移768]-&gt;偏移5560]，所以要注入的汇编代码可以写成：
push eax mov eax,[006A9EC0] mov eax,[eax&#43;768] mov [eax&#43;5560],0xFFF // 0xFFF为阳光值，别太小就行 pop eax mov eax,[esi&#43;00005560] //恢复被覆盖掉的代码 而在注入处发现eax被赋值，所以push eax 及 pop eax可以删掉（实际情况实际分析）。
因此，运行流程为：
代码到达&#34;PlantsVsZombies.exe&#34;&#43;89825（0x489825）处时，JMP到空闲空间，执行我们注入的汇编代码，JMP到&#34;PlantsVsZombies.exe&#34;&#43;8982B处继续向后执行，两种方法的示意图：
远程代码注入 我们需要计算0x489825处 JMP的偏移，推导过程如下：
起跳地址(0x489825) &#43; 5（JMP远跳占用固定5字节，0xE9 &#43; 4字节偏移量） &#43; 偏移量 = 目标地址 因此" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5ca23fe68b06f3ba112d87540d69b4bf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-15T20:34:49+08:00" />
<meta property="article:modified_time" content="2020-03-15T20:34:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">远程代码注入及DLL注入教程(InlineHook)---植物大战僵尸为例</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="DLL_0"></a>远程代码注入及DLL注入教程</h2> 
<h3><a id="_2"></a>说明</h3> 
<p>​ 本人刚开始学习逆向，不知道有没有动力学下深去，这一块也没有详细的实战教学，学多少就上传多少，希望能给想学的朋友一点帮助吧，本教程想通过植物大战僵尸这一经典游戏来抛砖引玉，教大家如何编写一个单机辅助。</p> 
<p>​ CE找数据的过程本教程不提供，本文着重讲述如何根据找到的数据实现无限阳光，无冷却，其他诸如秒杀僵尸，后台运行等均大同小异。</p> 
<h3><a id="_8"></a>所需基础</h3> 
<p>CE找关键数据基址（网上教程很多）、基本汇编命令</p> 
<h3><a id="_12"></a>涉及工具</h3> 
<p>VS、CheatEngine（CE，网上很多）、汇编转机器码工具（我在用的https://www.jb51.net/softs/629217.html）、DLL注入工具（网上很多）</p> 
<h3><a id="_16"></a>开始</h3> 
<h4><a id="_18"></a>无限冷却</h4> 
<p>​ 假设第一个植物栏的冷却地址已找到，如图：<br> <img src="https://images2.imgbox.com/dd/b5/qVJcHMw8_o.png" alt="在这里插入图片描述"><br> 此时种下植物后暂停游戏，切到CE，选中冷却地址，<strong>右键</strong>-<strong>找出什么改写了这个地址</strong>，然后继续游戏，发现改写的代码：<br> <img src="https://images2.imgbox.com/8b/54/337Dgt6t_o.png" alt="在这里插入图片描述"><br> 点击显示汇编代码：<br> <img src="https://images2.imgbox.com/8e/8b/2fCcerj0_o.png" alt="在这里插入图片描述"><br> 经过分析发现：如果还在冷却，那么在②处判断会跳走，把②处代码nop掉，让代码无论如何也会去Call③，发现植物已经实现无冷却（有很多种方法，比如把①修改为cmp eax,0），那么只需要如下代码即可实现：</p> 
<pre><code class="prism language-cpp">BYTE noCD<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">memset</span><span class="token punctuation">(</span>noCD<span class="token punctuation">,</span> <span class="token number">0x90</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//nop硬编码为0x90</span>
<span class="token function">WriteProcessMemory</span><span class="token punctuation">(</span>hProcess<span class="token punctuation">,</span> <span class="token punctuation">(</span>LPVOID<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0x487296</span><span class="token punctuation">)</span><span class="token punctuation">,</span> noCD<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_32"></a>无限阳光</h4> 
<p>像前面这种替换指令所用空间小于当前代码的方式，实现起来非常简单，但如果替换的汇编指令超过当前代码长度，将会导致后面指令被覆盖，引起崩溃，此时需要用到<strong>代码注入</strong>。<br> 选中找到的阳光值地址，<strong>右键</strong>-<strong>找出什么访问了这个地址</strong><br> <img src="https://images2.imgbox.com/6d/80/CyCmy6h4_o.png" alt="在这里插入图片描述"><br> 可以看到有两处频繁访问，我们选择访问次数较少的第二条-显示反汇编程序。<br> <img src="https://images2.imgbox.com/e1/cc/2u2Iowxq_o.png" alt="在这里插入图片描述"><br> 那就在这里注入吧，前面已经知道，阳光值的<strong>地址为[[[基址006A9EC0]-&gt;偏移768]-&gt;偏移5560]</strong>，所以要注入的汇编代码可以写成：</p> 
<pre><code class="prism language-cpp">push eax
mov eax<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">006</span>A9EC0<span class="token punctuation">]</span>
mov eax<span class="token punctuation">,</span><span class="token punctuation">[</span>eax<span class="token operator">+</span><span class="token number">768</span><span class="token punctuation">]</span>
mov <span class="token punctuation">[</span>eax<span class="token operator">+</span><span class="token number">5560</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0xFFF</span> <span class="token comment">// 0xFFF为阳光值，别太小就行</span>
pop eax
mov eax<span class="token punctuation">,</span><span class="token punctuation">[</span>esi<span class="token operator">+</span><span class="token number">00005560</span><span class="token punctuation">]</span> <span class="token comment">//恢复被覆盖掉的代码</span>
</code></pre> 
<p>而在注入处发现eax被赋值，所以push eax 及 pop eax可以删掉（实际情况实际分析）。<br> 因此，运行流程为：<br> 代码到达"PlantsVsZombies.exe"+89825（0x489825）处时，JMP到空闲空间，执行我们注入的汇编代码，JMP到"PlantsVsZombies.exe"+8982B处继续向后执行，两种方法的示意图：<br> <img src="https://images2.imgbox.com/f2/f9/ueZw5Aty_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_52"></a>远程代码注入</h4> 
<p>我们需要计算0x489825处 JMP的偏移，推导过程如下：</p> 
<pre><code class="prism language-c">起跳地址<span class="token punctuation">(</span><span class="token number">0x489825</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">5</span>（JMP远跳占用固定<span class="token number">5</span>字节，<span class="token number">0xE9</span> <span class="token operator">+</span> <span class="token number">4</span>字节偏移量） <span class="token operator">+</span> 偏移量 <span class="token operator">=</span> 目标地址
</code></pre> 
<p>因此</p> 
<pre><code class="prism language-c">偏移量 <span class="token operator">=</span> 目标地址 <span class="token operator">-</span> （起跳地址 <span class="token operator">+</span> <span class="token number">5</span>）
</code></pre> 
<p>目标地址需要我们手动申请，代码如下：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//第三个参数为申请大小</span>
LPVOID virAddr <span class="token operator">=</span> <span class="token function">VirtualAllocEx</span><span class="token punctuation">(</span>hProcess<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token number">64</span><span class="token punctuation">,</span> MEM_COMMIT<span class="token punctuation">,</span> PAGE_EXECUTE_READWRITE<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>那么偏移jmpOffset为：</p> 
<pre><code class="prism language-c">DWORD jmpOffset <span class="token operator">=</span> <span class="token punctuation">(</span>DWORD<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0x489825</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>DWORD<span class="token punctuation">)</span>virAddr <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>接下来组合0x489825处代码：</p> 
<pre><code class="prism language-cpp">BYTE ByteOffset<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">IntTo4Bytes</span><span class="token punctuation">(</span>jmpOffset <span class="token punctuation">,</span> ByteOffset<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//int转4字节byte[]</span>
BYTE JmpToNewCode<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
JmpToNewCode<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xE9</span><span class="token punctuation">;</span>         <span class="token comment">//jmp指令</span>
<span class="token function">memcpy</span><span class="token punctuation">(</span>JmpToNewCode <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> ByteOffset<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
JmpToNewCode<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x90</span><span class="token punctuation">;</span>			<span class="token comment">//空余的1个字节用nop填充</span>
</code></pre> 
<p>到这一步时，我们先不要着急WriteProcessMemory写入，因为我们申请的virAddr中还没有写入我们的汇编代码，这时需要使用汇编代码转机器码工具（文中有下载地址），转成机器码，然后写入到virAddr中，如图：<br> <img src="https://images2.imgbox.com/0b/c1/EcOTp7pa_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c">BYTE machinecode<span class="token punctuation">[</span><span class="token number">32</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">161</span><span class="token punctuation">,</span><span class="token number">192</span><span class="token punctuation">,</span><span class="token number">158</span><span class="token punctuation">,</span><span class="token number">106</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">139</span><span class="token punctuation">,</span><span class="token number">128</span><span class="token punctuation">,</span><span class="token number">104</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">199</span><span class="token punctuation">,</span><span class="token number">128</span><span class="token punctuation">,</span><span class="token number">96</span><span class="token punctuation">,</span><span class="token number">85</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">139</span><span class="token punctuation">,</span><span class="token number">134</span><span class="token punctuation">,</span><span class="token number">96</span><span class="token punctuation">,</span><span class="token number">85</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//27</span>
</code></pre> 
<p>为什么是32字节呢，因为我们的汇编代码还没有JMP跳回0x48982B，需要再加上5字节的JMP 偏移量，计算方法和上面思路一样：</p> 
<pre><code class="prism language-c"><span class="token comment">//起跳地址：virAddr + 27   目标地址：0x48982B</span>
DWORD returnoffset <span class="token operator">=</span> <span class="token punctuation">(</span>DWORD<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0x48982B</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>DWORD<span class="token punctuation">)</span>virAddr <span class="token operator">+</span> <span class="token number">27</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> 
<p>组合注入的机器码：</p> 
<pre><code class="prism language-cpp">BYTE ByteOffset<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">IntTo4Bytes</span><span class="token punctuation">(</span>returnoffset<span class="token punctuation">,</span> ByteOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>
BYTE ReturnCode<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
ReturnCode<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xE9</span><span class="token punctuation">;</span>         <span class="token comment">//jmp指令</span>
<span class="token function">memcpy</span><span class="token punctuation">(</span>ReturnCode <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> ByteOffset<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//组合jmp</span>
<span class="token function">memcpy</span><span class="token punctuation">(</span>machinecode <span class="token operator">+</span> <span class="token number">27</span><span class="token punctuation">,</span> ReturnCode<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//组合完整机器码</span>
</code></pre> 
<p>在注入前，先把原来汇编指令保存下来，方便还原代码。</p> 
<pre><code class="prism language-cpp">BYTE OldCode<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">ReadProcessMemory</span><span class="token punctuation">(</span>hProcess<span class="token punctuation">,</span> <span class="token punctuation">(</span>LPVOID<span class="token punctuation">)</span><span class="token number">0x489825</span><span class="token punctuation">,</span> OldCode<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
</code></pre> 
<p>OK,把machinecode写入到virAddr中：</p> 
<pre><code class="prism language-cpp"><span class="token function">WriteProcessMemory</span><span class="token punctuation">(</span>hProcess<span class="token punctuation">,</span> virAddr<span class="token punctuation">,</span> machinecode<span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>最后再修改注入点(0x489825)：</p> 
<pre><code class="prism language-cpp"><span class="token function">WriteProcessMemory</span><span class="token punctuation">(</span>hProcess<span class="token punctuation">,</span> <span class="token punctuation">(</span>LPVOID<span class="token punctuation">)</span><span class="token number">0x489825</span><span class="token punctuation">,</span> JmpToNewCode<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>至此，代码注入功能基本完毕，编译，运行，测试完美无限阳光。<br> 恢复原来功能只需要:</p> 
<pre><code class="prism language-cpp"><span class="token function">WriteProcessMemory</span><span class="token punctuation">(</span>hProcess<span class="token punctuation">,</span> <span class="token punctuation">(</span>LPVOID<span class="token punctuation">)</span><span class="token number">0x489825</span><span class="token punctuation">,</span> OldCode<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="DLL_130"></a>DLL注入</h4> 
<p>DLL注入相比代码注入少了手动开辟内存以及计算跳回偏移的过程，更加简单，步骤如下：<br> VS创建DLL工程，在DLL_PROCESS_ATTACH中码功能：<br> <img src="https://images2.imgbox.com/d4/d5/7tX2xfAx_o.png" alt="在这里插入图片描述"><br> 内联代码：</p> 
<pre><code class="prism language-cpp">BYTE OldJmp<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
DWORD JmpBack <span class="token operator">=</span> <span class="token number">0x48982B</span><span class="token punctuation">;</span>

<span class="token function">__declspec</span><span class="token punctuation">(</span>naked<span class="token punctuation">)</span> <span class="token keyword">void</span> <span class="token function">InfinateSunshine</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>	
	<span class="token comment">// 不加 dword ptr ss 编译器会翻译成单字赋值，原因不明（求大佬解释）</span>
	__asm
	<span class="token punctuation">{<!-- --></span>
		mov eax<span class="token punctuation">,</span> dword ptr ss<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">0x006A9EC0</span><span class="token punctuation">]</span>
		mov eax<span class="token punctuation">,</span> dword ptr ss <span class="token operator">:</span> <span class="token punctuation">[</span>eax <span class="token operator">+</span> <span class="token number">0x00000768</span><span class="token punctuation">]</span>
		mov dword ptr ss <span class="token operator">:</span> <span class="token punctuation">[</span>eax <span class="token operator">+</span> <span class="token number">0x00005560</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0x00000FFF</span>
		mov eax<span class="token punctuation">,</span> dword ptr ss <span class="token operator">:</span> <span class="token punctuation">[</span>esi <span class="token operator">+</span> <span class="token number">0x5560</span><span class="token punctuation">]</span>
		jmp	JmpBack
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>计算偏移方法和上面一致：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//计算偏移，InfinateSunshine 即为目标函数</span>
DWORD offset <span class="token operator">=</span> <span class="token punctuation">(</span>DWORD<span class="token punctuation">)</span>InfinateSunshine <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">0x489825</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
BYTE NewJmp<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
NewJmp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0xE9</span><span class="token punctuation">;</span>
BYTE ByteOffset<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token function">IntTo4Bytes</span><span class="token punctuation">(</span>offset<span class="token punctuation">,</span> ByteOffset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">memcpy</span><span class="token punctuation">(</span>NewJmp <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> ByteOffset<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
NewJmp<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0x90</span><span class="token punctuation">;</span>

nRet <span class="token operator">=</span> <span class="token function">WriteProcessMemory</span><span class="token punctuation">(</span>hProcess<span class="token punctuation">,</span> <span class="token punctuation">(</span>LPVOID<span class="token punctuation">)</span><span class="token number">0x489825</span><span class="token punctuation">,</span> NewJmp<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>编译后，用注入工具注入：<br> <img src="https://images2.imgbox.com/d2/9e/8cwt7bMu_o.png" alt="在这里插入图片描述"><br> 成功。<br> 但是，如果你再卸载掉DLL，会发现游戏崩溃，原因为在卸载DLL时不会自动还原0x489825 处的代码，因此需要再添加逻辑，卸载时复原代码。<br> <img src="https://images2.imgbox.com/6d/76/iQRgMqv1_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/b2/82/Rfy2a9uo_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_172"></a>再分析</h3> 
<p>后来经过分析，发现无限阳光插入处的代码还可以再优化，因为插入处的代码只有阳光访问时才会到达，如何判断呢，可以先用CE代码注入写一个判断代码，和当前的阳光地址做对比，加入一段没有意义的代码并设置断点，看能否断下，如果没有断下，那说明注入处只会被阳光访问，如图：<br> <img src="https://images2.imgbox.com/27/b4/CSzVQUcN_o.png" alt="在这里插入图片描述"><br> 故[esi+00005560]一定为阳光地址，因此可以省掉使用基址加偏移的方式，注入处代码可以修改为更简单的：</p> 
<pre><code class="prism language-cpp">mov <span class="token punctuation">[</span>esi<span class="token operator">+</span><span class="token number">00005560</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0xffff</span>  <span class="token comment">//确定为阳光唯一，直接赋值</span>
mov eax<span class="token punctuation">,</span><span class="token punctuation">[</span>esi<span class="token operator">+</span><span class="token number">00005560</span><span class="token punctuation">]</span> 	   <span class="token comment">//恢复被覆盖掉的代码</span>
</code></pre> 
<h3><a id="_181"></a>总结</h3> 
<pre><code>代码注入及DLL注入的关键为
1、注入代码中不要破坏原先堆栈平衡，如果不确定寄存器里的值在我们使用之前是不是有用，最好先pushad再写自己的注入代码，最后popad
2、注入处的JMP偏移及返回的JMP偏移一定要计算准确，否则必出错，可以配合OD和CE进行调试检查。
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/03abe92b50e9562bb85e203e9746ba88/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java实现定时备份数据库sql文件，并且通过FTP协议向远程机器发送sql文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/87898fff80f82ae4c56ded42eadcaed6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">sigrity speed 2000的 操作流程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>