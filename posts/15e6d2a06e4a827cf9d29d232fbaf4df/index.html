<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python 简单全自动WORD合并（加程序链接） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python 简单全自动WORD合并（加程序链接）" />
<meta property="og:description" content="环境： python 3.x
python 的 pywin32包
pyinstaller包（把python打包成exe）pyinstaller -F app.py
自己百度安装即可
源码： #导入pywin32包 import win32com.client as win32 import os print(&#39;-&#39;*30) print(&#39;使用方式：&#39;) print(&#39;1、把放在桌面&#39;) print(&#39;2、第一次点击，桌面会出现一个file文件夹&#39;) print(&#39;3、把一些docx后缀的文件放进去&#39;) print(&#39;4、再次点击运行程序&#39;) print(&#39;合并排序方式为：由大到小&#39;) print(&#39;-&#39;*30) input(&#39;回车下一步....&#39;) #创建文件夹，判断是否有文件夹，没有则创建 if not os.path.isdir(&#39;file&#39;): os.mkdir(&#34;file&#34;) #获取file文件目录 file_list = os.listdir(&#34;./file/&#34;); #是否存在文件 if len(file_list): word = win32.gencache.EnsureDispatch(&#39;Word.Application&#39;) #可视化运行 word.Visible = 1 output = word.Documents.Add()#新建合并后空白文档 lists = [] #循环列表 for file in file_list: #判断是不是word docx 后缀的文件 if &#39;.docx&#39; in file: path = os.getcwd() &#43; &#39;\\file\\&#39;&#43; file lists &#43;= [path] for file in lists: output." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/15e6d2a06e4a827cf9d29d232fbaf4df/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-21T11:46:20+08:00" />
<meta property="article:modified_time" content="2019-12-21T11:46:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python 简单全自动WORD合并（加程序链接）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>环境：</h3> 
<p>python 3.x</p> 
<p>python  的 pywin32包</p> 
<p>pyinstaller包（把python打包成exe）pyinstaller -F app.py</p> 
<p>自己百度安装即可</p> 
<h3>源码：</h3> 
<pre class="has"><code class="language-python">#导入pywin32包
import win32com.client as win32
import os
print('-'*30)
print('使用方式：')
print('1、把放在桌面')
print('2、第一次点击，桌面会出现一个file文件夹')
print('3、把一些docx后缀的文件放进去')
print('4、再次点击运行程序')
print('合并排序方式为：由大到小')
print('-'*30)
input('回车下一步....')
#创建文件夹，判断是否有文件夹，没有则创建
if not os.path.isdir('file'):
    os.mkdir("file")
#获取file文件目录
file_list = os.listdir("./file/");
#是否存在文件
if len(file_list):
    word = win32.gencache.EnsureDispatch('Word.Application')
    #可视化运行
    word.Visible = 1
    output = word.Documents.Add()#新建合并后空白文档
    lists = []
    #循环列表
    for file in file_list:
        #判断是不是word docx 后缀的文件
        if '.docx' in file:
            path = os.getcwd() + '\\file\\'+ file
            lists += [path]
    for file in lists:
    	output.Application.Selection.Range.InsertFile(file)#拼接文档
    #获取合并后文档的内容
    doc = output.Range(output.Content.Start, output.Content.End)
    doc.Font.Name = "黑体"	#设置字体
else:
    print('把想要合并的文件放进file文件夹')
    input('输入回车结束')
</code></pre> 
<p>程序下载地址：<a href="https://download.csdn.net/download/Yel_Liang/12044715">https://download.csdn.net/download/Yel_Liang/12044715</a></p> 
<p>改进版 v-1</p> 
<pre class="has"><code class="language-python">#导入pywin32包
import win32com.client as win32
import os
import tkinter
import tkinter.messagebox
import time
top = tkinter.Tk()
top.title('word合并工具')
top.geometry("200x300")
#欢迎弹出框
tkinter.messagebox.showinfo(title='欢迎来到word合并工具', message='使用方式：\n1、把放在桌面\n2、第一次点击，桌面会出现一个file文件夹\n3、把一些docx后缀的文件放进去\n4、再次点击运行程序\n合并排序方式为：由大到小')
def openword():
    global lists
    word = win32.gencache.EnsureDispatch('Word.Application')
    # 可视化运行
    word.Visible = 1
    output = word.Documents.Add()
    # 新建合并后空白文档
    f = open('成功合成的文件.txt','a+')
    f.write('-----' + time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())) + '----\n')
    i = 1
    for file in lists:
        output.Application.Selection.Range.InsertFile(file)
        f.write(str(i)+':'+file+'\n')
        i += 1
    f.write('\n\n\n')
    f.close()
    # 获取合并后文档的内容
    doc = output.Range(output.Content.Start, output.Content.End)
    doc.Font.Name = "黑体"  # 设置字体
    tkinter.messagebox.showinfo(title='提示', message='运行完毕')

#创建文件夹，判断是否有文件夹，没有则创建
if not os.path.isdir('file'):
    os.mkdir("file")
while 1:
    #获取file文件目录
    file_list = os.listdir("./file/");
    l = tkinter.Label(top, text='发现的文件：', font=('Arial', 12), width=30, height=2)
    l.pack()  # Label内容content区域放置位置，自动调节尺寸
    #是否存在文件
    if len(file_list):
        lists = []
        # 创建Listbox
        lb = tkinter.Listbox(top, listvariable=[])  # 将var2的值赋给Listbox

        for file in file_list:
            #判断是不是word docx/doc 后缀的文件
            if '.doc' in file:
                path = os.getcwd() + '\\file\\'+ file
                lists += [path]
                lb.insert('end', file)  # 从最后一个位置开始加入值
        lb.pack()
        #加个按钮
        b1 = tkinter.Button(top, text='执行', width=10,height=2, command=openword)
        b1.pack()
        break
    else:
        tkinter.messagebox.showinfo(title='提示',message='请把你需要合并的文件放进file文件夹')
# 进入消息循环
top.mainloop()

</code></pre> 
<p>改进版 v-2</p> 
<pre class="has"><code class="language-python"># -*- coding: utf-8 -*-
"""
导入tkinter
"""
import tkinter
import tkinter.messagebox  # 要使用message先要导入模块
from tkinter import filedialog
import win32com.client as win32
import time

'''
桌面框架
'''


class frames:
    # 窗口
    tk = ''
    # 窗口标题
    title = '我的窗口'
    # listbox列表对象
    listbox = ''
    '''
    初始化
    '''

    def __init__(self, title=''):
        self.tk = tkinter.Tk()
        if title == '':
            self.tk.title(self.title)
        else:
            self.tk.title(title)
        self.setWidehigh();
        self.tk.resizable(0, 0)  # 防止用户调整尺寸
        self.setlist()
        self.setbutton()
        self.setMenu()

    '''打开窗体'''

    def openwin(self):
        self.tk.mainloop()

    '''setTiele设置窗口标题'''

    def setTiele(self, title):
        self.title = title
        self.tk.title(title)

    '''setWidehigh设置窗口宽度'''

    def setWidehigh(self, wide=300, hige=400):
        self.tk.geometry(repr(wide) + 'x' + repr(hige))

    '''setlist创建一个文本列表listbox'''

    def setlist(self):
        # 创建Listbox
        listbox = tkinter.Listbox(self.tk, width=1000)
        self.listbox = listbox
        self.listbox.pack()

    '''insertlistbox在文本列表中插入一条内容'''

    def insertlistbox(self, text=''):
        if text != '':
            self.listbox.insert('end', text)  # 在末尾加入 end为数字，则在什么位置插入

    '''setbutton设置一个按钮1'''

    def setbutton(self):
        button1 = tkinter.Button(self.tk, text='合并', font=('Arial', 12), width=10, height=1, command=self.button1)
        button1.pack()

    '''button1按钮1的执行方法'''

    def button1(self):
        self.getlistboxdata()

    '''创建一个菜单栏'''

    def setMenu(self):
        # 创建一个菜单栏，这里我们可以把他理解成一个容器，在窗口的上方
        menubar = tkinter.Menu(self.tk)
        # 创建一个File菜单项
        filemenu = tkinter.Menu(menubar, tearoff=0)
        menubar.add_cascade(label='文件(Files)', menu=filemenu)
        filemenu.add_command(label='选择文件', command=self.choosefiles)
        # 创建一个帮助菜单
        menubar.add_cascade(label='帮助(Help)', command=self.helps)
        self.tk.config(menu=menubar)

    '''选择文件按钮'''

    def choosefiles(self):
        file_path = filedialog.askopenfilenames(
            filetypes=[("Word", [".docx", ".doc"]), ("DOCX", ".docx"), ("DOC", ".doc")])
        for file_path_name in file_path:
            self.insertlistbox(file_path_name)

    '''帮助按钮'''

    def helps(self):
        tkinter.messagebox.showinfo(title='使用说明',
                                    message='使用方式：\n1、打开程序\n2、点击文件-&gt;选择文件（可多选）\n3、点击合并\n4、运行完成\n合并的排序为选择文件的顺序')  # 提示信息对话窗

    '''获取listbox里面的数据'''

    def getlistboxdata(self):
        lists = self.listbox.get(0, 'end')
        word = win32.gencache.EnsureDispatch('Word.Application')
        # 可视化运行
        word.Visible = 1
        output = word.Documents.Add()
        # 新建合并后空白文档
        f = open('成功合成的文件.txt', 'a+')
        f.write('-----' + time.strftime('%Y-%m-%d %H:%M:%S', time.localtime(time.time())) + '----\n')
        i = 1
        for file in lists:
            output.Application.Selection.Range.InsertFile(file)
            f.write(str(i) + ':' + file + '\n')
            i += 1
        f.write('\n')
        f.close()
        # 获取合并后文档的内容
        doc = output.Range(output.Content.Start, output.Content.End)
        doc.Font.Name = "黑体"  # 设置字体
        tkinter.messagebox.showinfo(title='提示', message='运行完毕')


if __name__ == '__main__':
    fram = frames()
    # 设置头
    fram.setTiele('word合成工具')
    # 设置宽高
    fram.setWidehigh(600, 250)
    # 打开窗体
    fram.openwin()
</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/175896c4e8573aa6797de69f4e445097/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">自己公司项目中引用jacoco，及多报告合并</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e191f93f10fe3b7b3e60af140a97e555/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CS224N_2019_Assignment3: Dependency Parsing (Solution)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>