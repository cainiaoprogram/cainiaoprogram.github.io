<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java并发编程知识点总结（七）——原子性、有序性、可见性 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java并发编程知识点总结（七）——原子性、有序性、可见性" />
<meta property="og:description" content="这一节来对比下synchronized和volatile关键字在三大性质中的不同。
1. 原子性 原子性是指一个操作是不可中断的，要么全部执行成功，要么全部执行失败。即使在多线程情况下，也能保证不被其它线程干扰。
我们来看下面几个例子
int a = 10; // 1 &#43;&#43;a; // 2 int b = a; // 3 a = a&#43;1; // 4 在上面的三个操作中，只有第一个操作时具有原子性的。第二个自增操作实际上时分为三步的：取a的值、对a的值&#43;1、赋值给a，所以是无法保证原子性的。3、4同理也不具有原子性。
在JMM内存模型中，只有如下8个操作是具有原子性的：
lock(锁定)：作用于主内存中的变量，它把一个变量标识为一个线程独占的状态。unlock(解锁)：作用于主内存中的变量，它把一个处于锁定状态的变量释放出来。read(读取)：作用于主内存中的变量，它把从主内存中读取的变量传送到工作内存，以便后面的load。load(载入)：作用于工作内存的变量，将read操作读取的变量放入工作内存中的变量副本。use(使用)：作用域工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎。assign(赋值)：作用于工作内存中的变量，它把从执行引擎计算的变量赋值给工作内存的变量。store(存储)：作用于工作内存的变量，它把工作内存中的变量值送给主内存中以便随后的write操作。write(操作)：作用于主内存的变量，它把store操作从工作内存中得到的变量值放入主内存中。 值得注意的是：Java内存模型只是要求上述两个操作时顺序执行的而不是连续执行的。也就是说read和load之间可以插入其它指令，store和write可以插入其它指令。例如可以出现这样的顺序：read a,read b,load b,load a。
synchronized synchronized关键字的实现原理是基于monitorenter和monitorexit，其实就相当于lock和unlok的原子性操作。
因此，synchronized是满足原子性的。
volatile 我们来看下面的代码
public class Demo1 { private static volatile int num = 0; public static void add(){ for(int i=0;i&lt;1000;i&#43;&#43;){ num&#43;&#43;; } } public static void main(String[] args) throws InterruptedException { for(int i=0;i&lt;10;i&#43;&#43;){ Thread thread = new Thread(){ @Override public void run() { Demo1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/afe34844ac0d73ed27d603b6186932f7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-07T16:35:18+08:00" />
<meta property="article:modified_time" content="2022-11-07T16:35:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java并发编程知识点总结（七）——原子性、有序性、可见性</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>这一节来对比下synchronized和volatile关键字在三大性质中的不同。</p> 
<h2><a id="1__3"></a>1. 原子性</h2> 
<p>原子性是<strong>指一个操作是不可中断的，要么全部执行成功，要么全部执行失败</strong>。即使在多线程情况下，也能保证不被其它线程干扰。</p> 
<p>我们来看下面几个例子</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token comment">// 1 </span>
<span class="token operator">++</span>a<span class="token punctuation">;</span>  <span class="token comment">// 2</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> a<span class="token punctuation">;</span>  <span class="token comment">// 3</span>
a <span class="token operator">=</span> a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 4</span>
</code></pre> 
<p>在上面的三个操作中，只有第一个操作时具有原子性的。第二个自增操作实际上时分为三步的：取a的值、对a的值+1、赋值给a，所以是无法保证原子性的。3、4同理也不具有原子性。</p> 
<p>在JMM内存模型中，<strong>只有如下8个操作是具有原子性的</strong>：</p> 
<ol><li>lock(锁定)：作用于主内存中的变量，它把一个变量标识为一个线程独占的状态。</li><li>unlock(解锁)：作用于主内存中的变量，它把一个处于锁定状态的变量释放出来。</li><li>read(读取)：作用于主内存中的变量，它把从主内存中读取的变量传送到工作内存，以便后面的load。</li><li>load(载入)：作用于工作内存的变量，将read操作读取的变量放入工作内存中的变量副本。</li><li>use(使用)：作用域工作内存中的变量，它把工作内存中一个变量的值传递给执行引擎。</li><li>assign(赋值)：作用于工作内存中的变量，它把从执行引擎计算的变量赋值给工作内存的变量。</li><li>store(存储)：作用于工作内存的变量，它把工作内存中的变量值送给主内存中以便随后的write操作。</li><li>write(操作)：作用于主内存的变量，它把store操作从工作内存中得到的变量值放入主内存中。</li></ol> 
<p>值得注意的是：Java内存模型只是要求上述两个操作时顺序执行的而不是连续执行的。也就是说read和load之间可以插入其它指令，store和write可以插入其它指令。例如可以出现这样的顺序：read a,read b,load b,load a。</p> 
<h3><a id="synchronized_27"></a>synchronized</h3> 
<p>synchronized关键字的实现原理是基于monitorenter和monitorexit，其实就相当于lock和unlok的原子性操作。<br> 因此，<strong>synchronized是满足原子性的</strong>。</p> 
<h3><a id="volatile_31"></a>volatile</h3> 
<p>我们来看下面的代码</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo1</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            num<span class="token operator">++</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token class-name">Thread</span> thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token annotation punctuation">@Override</span>
                <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token class-name">Demo1</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">;</span>
            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Demo1</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>实际的执行结果可能是1000、也可能是9991，9983…<br> 我们可以设想这样一个场景：首先线程A从主内存中拷贝了一份变量副本到工作内存中，但是还没来得及修改，就被阻塞了。这时，线程B也从主内存中读取了变量到工作内存中，因为这时num还没有被修改，所以是有效的。然后线程B对num进行了自增操作，并写回到了主内存中。虽然volatile关键字是具有可见性的，但是由于线程A已经完成了读取的这个原子性操作了，所以就不会再检查。这时线程A会直接将100加1，然后写回到主内存中。这就造成了数据不一致的问题。因此<strong>volatile不能使得本身不具有原子性的操作变成具有原子性的</strong>。</p> 
<p>因此，<strong>volatile操作是不满足原子性的</strong>。</p> 
<h2><a id="2__63"></a>2. 有序性</h2> 
<p>Java程序的天然的有序性可以解释为：<strong>如果在本线程内观察，所有的操作都是有序的；如果在一个线程观察另外一个线程，所有操作都是无序的。</strong></p> 
<h3><a id="synchronized_66"></a>synchronized</h3> 
<p>synchronized关键字使得在同一个时刻，只能有一个线程获得监视器，进入临界区。其实也就相当于，<strong>要求读写共享变量是串行执行的</strong>。</p> 
<p>因此<strong>synchronized操作是满足有序性的</strong>。</p> 
<h3><a id="volatile_71"></a>volatile</h3> 
<p>我们利用懒汉式的双重检验单例模式（有篇文章介绍<a href="https://juejin.cn/post/6844904106251780109" rel="nofollow">双重检验单例模式</a>讲的很好，值得一看）来分析volatile是否具有有序性。代码如下:</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Demo</span> demo<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>

    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">Demo</span> <span class="token function">getDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>demo<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Demo</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>demo<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> demo<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>创建一个对象实际分为三步：</p> 
<ol><li>分配对象的内存空间</li><li>初始化对象</li><li>设置demo指向刚分配的内存地址</li></ol> 
<p>第一步和第二步是存在依赖关系的，不能被重排序。而第三步和第二步没有依赖关系，实际上是可以重排序的。这样就有可能出现这种情况：<br> <img src="https://images2.imgbox.com/f6/7b/32zoPXXB_o.png" alt="在这里插入图片描述"></p> 
<p>如果2和3进行了重排序，就有可能造成线程B拿到了没有被初始化的对象。而volatile关键字能够禁止操作2和3的重排序，从而避免这种情况。</p> 
<p>因此，<strong>volatile关键字是满足有序性的</strong>。</p> 
<h2><a id="3__105"></a>3. 可见性</h2> 
<p>可见性是<strong>指当一个线程修改了共享变量后，其它线程能够立即得知这个修改</strong>。</p> 
<h3><a id="synchronized_108"></a>synchronized</h3> 
<p>synchronized保证，当线程获取到锁的时候，会从主内存中获取共享变量的最新值，释放锁的时候会将共享变量同步到主内存中。</p> 
<p>因此synchronized关键字是满足可见性的。</p> 
<h3><a id="volatile_113"></a>volatile</h3> 
<p>由于lock前缀指令，volatile写之后会使得其它缓存中的共享变量也失效，强制从主内存中重新读取，从而实现可见性。</p> 
<p>因此volatile关键字是满足可见性的。</p> 
<h3><a id="4__118"></a>4. 总结</h3> 
<p>synchronized：原子性、有序性、可见性<br> volatile：有序性、可见性。</p> 
<p>参考了这篇文章：<a href="https://www.jianshu.com/p/cf57726e77f2" rel="nofollow">三大性质总结：原子性，有序性，可见性</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dbb8f74c10f237b6f7b3ad3ab32cb2d2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">随机森林分析金融数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1ca5eeeee9e8b3af88a1fe5399190837/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux内核编译报错/bin/sh: 1: bison: not found recipe for target ‘scriptskconfigparser.tab.h‘ failed</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>