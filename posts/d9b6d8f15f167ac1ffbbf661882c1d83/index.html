<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Sentinel哨兵框架 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Sentinel哨兵框架" />
<meta property="og:description" content="目录
什么是&#34;雪崩效应&#34;?
解决&#34;雪崩&#34;的常用4种解决方案
sentinel--介绍
sentinel--簇点链路
sentinel--流量控制--三种模式
sentinel--流量控制--三种效果
sentinel--流量控制--热点参数限流
sentinel--线程隔离模式(舱壁模式)
信号量隔离与线程池隔离的区别
sentinel--熔断模式--介绍
sentinel--熔断模式--三种统计方式
sentinel--访问授权
sentinel--自定义异常
sentinel--规则持久化
什么是&#34;雪崩效应&#34;? &#34;雪崩&#34;是指在微服务的调用链路中,一个服务出现问题,会出现连锁反应,导致所有的依赖服务出现异常.
假如A服务调用B服务,B服务宕机,A服务的请求就会无响应,并占用A服务的资源,所有资源都被占用后,A服务也会宕机
解决&#34;雪崩&#34;的常用4种解决方案 请求超时模式:
在请求一定时间无响应后返回请求失败,这样可以防止调用者的资源消耗
线程隔离(舱壁模式):
在调用者调用微服务时,会创建指定数量的线程池,当微服务宕机时,只会影响到调用者一定数量的线程资源,
熔断模式:
会在服务间创建一个断路器,由断路器进行监控服务调用的健康状态,若超过了设置的阈值,就会进行熔断,禁止对该微服务的调用,
流量控制模式:
根据自定义策略限制对微服务访问的QPS, 以防瞬时高并发场景,导致微服务宕机
请求超时,线程隔离,熔断都属于补救策略,而流量控制属于预防策略
sentinel--介绍 sentinel是阿里巴巴开源出的一款微服务保护框架,它支持多种雪崩问题的补救与预防机制
与前期的Hystrix相比,sentinel更为完善
sentinel--簇点链路 当请求进入微服务时，首先会访问DispatcherServlet，然后进入Controller、Service、Mapper，这样的一个调用链就叫做簇点链路。簇点链路中被监控的每一个接口就是一个资源。
默认情况下sentinel会监控SpringMVC的每一个端点（Endpoint，也就是controller中的方法），因此SpringMVC的每一个端点（Endpoint）就是调用链路中的一个资源
sentinel--流量控制--三种模式 直接模式:
统计当前资源的QPS,超过阈值将会直接响应失败,进行限流
关联模式:
统计与当前资源相关的另一个资源的QPS,超过阈值将会对当前资源进行限流
链路模式:
阈值统计时，只统计从指定资源进入当前资源的请求，是对请求来源的限流
直接模式简单暴力,适用于对单一资源的保护,
关联模式适用于有两个竞争关系的资源,且优先级不同,比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流
链路模式适用于不同链路资源请求同一个资源, 比如查询订单和创建订单,都需要调用查询商品,可以针对查询订单请求查询商品进行链路模式流控, 用于保护创建订单的正常执行
sentinel--流量控制--三种效果 快速失败：
达到阈值后，新的请求会被立即拒绝并抛出FlowException异常。是默认的处理方式。
warm up：
预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，刚开始是根据冷启动因子(3)来计算出初始值(阈值/冷启动因子),再逐渐增加到最大阈值。
排队等待：
让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长
warm up适用于服务冷启动, 此时服务还未能承受最高并发,可以进行慢启动,
排队等待适用于需要对进行流量削峰填谷,能够解决瞬时高并发问题
sentinel--流量控制--热点参数限流 前面是三种限流模式都是对同一资源的所有请求进行限流, 热点参数是对同一参数的请求进行限流,
适用于部分商品是热点商品，例如秒杀商品，我们希望这部分商品的QPS限制与其它商品不一样。那就需要配置热点参数限流的高级选项了 sentinel--线程隔离模式(舱壁模式) sentinel默认的舱壁模式是线程信号量隔离:
在微服务调用的时候,sentinel会创建一个线程计数器用于对调用者使用线程的记录,可以自定义线程阈值,
信号量隔离与线程池隔离的区别 线程池隔离：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果
信号量隔离：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d9b6d8f15f167ac1ffbbf661882c1d83/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-03T19:48:05+08:00" />
<meta property="article:modified_time" content="2022-03-03T19:48:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Sentinel哨兵框架</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%22%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94%22%3F-toc" style="margin-left:80px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%22%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94%22%3F" rel="nofollow">什么是"雪崩效应"?</a></p> 
<p id="%E8%A7%A3%E5%86%B3%22%E9%9B%AA%E5%B4%A9%22%E7%9A%84%E5%B8%B8%E7%94%A84%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-toc" style="margin-left:80px;"><a href="#%E8%A7%A3%E5%86%B3%22%E9%9B%AA%E5%B4%A9%22%E7%9A%84%E5%B8%B8%E7%94%A84%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" rel="nofollow">解决"雪崩"的常用4种解决方案</a></p> 
<p id="sentinel--%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#sentinel--%E4%BB%8B%E7%BB%8D" rel="nofollow">sentinel--介绍</a></p> 
<p id="sentinel--%E7%B0%87%E7%82%B9%E9%93%BE%E8%B7%AF-toc" style="margin-left:80px;"><a href="#sentinel--%E7%B0%87%E7%82%B9%E9%93%BE%E8%B7%AF" rel="nofollow">sentinel--簇点链路</a></p> 
<p id="sentinel--%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6--%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#sentinel--%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6--%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F" rel="nofollow">sentinel--流量控制--三种模式</a></p> 
<p id="%C2%A0sentinel--%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6--%E4%B8%89%E7%A7%8D%E6%95%88%E6%9E%9C-toc" style="margin-left:80px;"><a href="#%C2%A0sentinel--%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6--%E4%B8%89%E7%A7%8D%E6%95%88%E6%9E%9C" rel="nofollow">sentinel--流量控制--三种效果</a></p> 
<p id="%C2%A0%C2%A0sentinel--%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6--%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0sentinel--%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6--%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81" rel="nofollow">sentinel--流量控制--热点参数限流</a></p> 
<p id="%C2%A0sentinel--%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%E6%A8%A1%E5%BC%8F(%E8%88%B1%E5%A3%81%E6%A8%A1%E5%BC%8F)-toc" style="margin-left:80px;"><a href="#%C2%A0sentinel--%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%E6%A8%A1%E5%BC%8F%28%E8%88%B1%E5%A3%81%E6%A8%A1%E5%BC%8F%29" rel="nofollow">sentinel--线程隔离模式(舱壁模式)</a></p> 
<p id="%C2%A0%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9A%94%E7%A6%BB%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%9A%94%E7%A6%BB%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#%C2%A0%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9A%94%E7%A6%BB%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%9A%94%E7%A6%BB%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">信号量隔离与线程池隔离的区别</a></p> 
<p id="%C2%A0%C2%A0sentinel--%E7%86%94%E6%96%AD%E6%A8%A1%E5%BC%8F--%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0sentinel--%E7%86%94%E6%96%AD%E6%A8%A1%E5%BC%8F--%E4%BB%8B%E7%BB%8D" rel="nofollow">sentinel--熔断模式--介绍</a></p> 
<p id="%C2%A0%C2%A0sentinel--%E7%86%94%E6%96%AD%E6%A8%A1%E5%BC%8F--%E4%B8%89%E7%A7%8D%E7%BB%9F%E8%AE%A1%E6%96%B9%E5%BC%8F-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0sentinel--%E7%86%94%E6%96%AD%E6%A8%A1%E5%BC%8F--%E4%B8%89%E7%A7%8D%E7%BB%9F%E8%AE%A1%E6%96%B9%E5%BC%8F" rel="nofollow">sentinel--熔断模式--三种统计方式</a></p> 
<p id="%C2%A0%C2%A0sentinel--%E8%AE%BF%E9%97%AE%E6%8E%88%E6%9D%83-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0sentinel--%E8%AE%BF%E9%97%AE%E6%8E%88%E6%9D%83" rel="nofollow">sentinel--访问授权</a></p> 
<p id="%C2%A0%C2%A0%C2%A0sentinel--%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0%C2%A0sentinel--%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8" rel="nofollow">sentinel--自定义异常</a></p> 
<p id="%C2%A0%C2%A0sentinel--%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96-toc" style="margin-left:80px;"><a href="#%C2%A0%C2%A0sentinel--%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96" rel="nofollow">sentinel--规则持久化</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h4 id="%E4%BB%80%E4%B9%88%E6%98%AF%22%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94%22%3F">什么是"雪崩效应"?</h4> 
<blockquote> 
 <p>"雪崩"是指在微服务的调用链路中,一个服务出现问题,会出现连锁反应,导致所有的依赖服务出现异常.</p> 
 <p><strong><span style="color:#4da8ee;">假如A服务调用B服务,B服务宕机,A服务的请求就会无响应,并占用A服务的资源,所有资源都被占用后,A服务也会宕机</span></strong></p> 
</blockquote> 
<h4 id="%E8%A7%A3%E5%86%B3%22%E9%9B%AA%E5%B4%A9%22%E7%9A%84%E5%B8%B8%E7%94%A84%E7%A7%8D%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">解决"雪崩"的常用4种解决方案</h4> 
<blockquote> 
 <p><strong>请求超时模式:</strong></p> 
 <p>        在请求一定时间无响应后返回请求失败,这样可以防止调用者的资源消耗</p> 
 <p><strong>线程隔离(舱壁模式):</strong></p> 
 <p>        在调用者调用微服务时,会创建指定数量的线程池,当微服务宕机时,只会影响到调用者一定数量的线程资源,</p> 
 <p><strong>熔断模式:</strong></p> 
 <p>        会在服务间创建一个断路器,由断路器进行监控服务调用的健康状态,若超过了设置的阈值,就会进行熔断,禁止对该微服务的调用,</p> 
 <p><strong>流量控制模式:</strong></p> 
 <p>        根据自定义策略限制对微服务访问的QPS, 以防瞬时高并发场景,导致微服务宕机</p> 
 <p><strong><span style="color:#4da8ee;">请求超时,线程隔离,熔断都属于补救策略,而流量控制属于预防策略</span></strong></p> 
</blockquote> 
<h4 id="sentinel--%E4%BB%8B%E7%BB%8D">sentinel--介绍</h4> 
<blockquote> 
 <p>sentinel是阿里巴巴开源出的一款微服务保护框架,它支持多种雪崩问题的补救与预防机制</p> 
 <p>与前期的<strong><span style="color:#4da8ee;">Hystrix</span></strong>相比,sentinel更为完善</p> 
 <p><img alt="" height="548" src="https://images2.imgbox.com/1f/08/WrEQn5BG_o.png" width="1200"></p> 
</blockquote> 
<h4 id="sentinel--%E7%B0%87%E7%82%B9%E9%93%BE%E8%B7%AF">sentinel--簇点链路</h4> 
<blockquote> 
 <p>当请求进入微服务时，首先会访问<span style="color:#4da8ee;"><strong>DispatcherServlet</strong></span>，然后进入Controller、Service、Mapper，这样的一个调用链就叫做簇点链路。簇点链路中被监控的每一个接口就是一个资源。</p> 
 <p>默认情况下sentinel会监控SpringMVC的每一个端点（Endpoint，也就是controller中的方法），因此SpringMVC的每一个端点（Endpoint）就是调用链路中的一个资源</p> 
</blockquote> 
<h4 id="sentinel--%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6--%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F">sentinel--流量控制--三种模式</h4> 
<blockquote> 
 <p><strong>直接模式:</strong></p> 
 <p>        统计当前资源的QPS,超过阈值将会直接响应失败,进行限流</p> 
 <p><strong>关联模式:</strong></p> 
 <p>        统计与当前资源相关的另一个资源的QPS,超过阈值将会对当前资源进行限流</p> 
 <p><strong>链路模式:</strong></p> 
 <p>        阈值统计时，只统计从指定资源进入当前资源的请求，是对请求来源的限流</p> 
 <p><span style="color:#4da8ee;"><strong>直接模式简单暴力,适用于对单一资源的保护,</strong></span></p> 
 <p><span style="color:#4da8ee;"><strong>关联模式适用于有两个竞争关系的资源,且优先级不同</strong></span>,比如用户支付时需要修改订单状态，同时用户要查询订单。查询和修改操作会争抢数据库锁，产生竞争。业务需求是优先支付和更新订单的业务，因此当修改订单业务触发阈值时，需要对查询订单业务限流</p> 
 <p><span style="color:#4da8ee;"><strong>链路模式适用于不同链路资源请求同一个资源,</strong></span> 比如查询订单和创建订单,都需要调用查询商品,可以针对查询订单请求查询商品进行链路模式流控, 用于保护创建订单的正常执行</p> 
</blockquote> 
<h4 id="%C2%A0sentinel--%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6--%E4%B8%89%E7%A7%8D%E6%95%88%E6%9E%9C">sentinel--流量控制--三种效果</h4> 
<blockquote> 
 <p><strong>快速失败：</strong></p> 
 <p>        达到阈值后，新的请求会被立即拒绝并抛出<span style="color:#4da8ee;"><strong>FlowException</strong></span>异常。是默认的处理方式。</p> 
 <p><strong>warm up：</strong></p> 
 <p>        预热模式，对超出阈值的请求同样是拒绝并抛出异常。但这种模式阈值会动态变化，刚开始是根据冷启动因子(<span style="color:#4da8ee;"><strong>3</strong></span>)来计算出初始值(<span style="color:#4da8ee;"><strong>阈值/冷启动因子</strong></span>),再逐渐增加到最大阈值。</p> 
 <p><strong>排队等待：</strong></p> 
 <p>        让所有的请求按照先后次序排队执行，两个请求的间隔不能小于指定时长</p> 
 <p><span style="color:#4da8ee;"><strong>warm up适用于服务冷启动, 此时服务还未能承受最高并发,可以进行慢启动,</strong></span></p> 
 <p><span style="color:#4da8ee;"><strong>排队等待适用于需要对进行流量削峰填谷,能够解决瞬时高并发问题</strong></span></p> 
</blockquote> 
<h4 id="%C2%A0%C2%A0sentinel--%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6--%E7%83%AD%E7%82%B9%E5%8F%82%E6%95%B0%E9%99%90%E6%B5%81">sentinel--流量控制--热点参数限流</h4> 
<blockquote> 
 <p> 前面是三种限流模式都是对同一资源的所有请求进行限流, 热点参数是对同一参数的请求进行限流,</p> 
 <p><span style="color:#4da8ee;"><strong>适用于部分商品是热点商品，例如秒杀商品，我们希望这部分商品的QPS限制与其它商品不一样。那就需要配置热点参数限流的高级选项了 </strong></span></p> 
 <p><img alt="" height="395" src="https://images2.imgbox.com/24/49/svdPLXqQ_o.png" width="882"></p> 
</blockquote> 
<h4 id="%C2%A0sentinel--%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BB%E6%A8%A1%E5%BC%8F(%E8%88%B1%E5%A3%81%E6%A8%A1%E5%BC%8F)">sentinel--线程隔离模式(舱壁模式)</h4> 
<blockquote> 
 <p><strong>sentinel默认的舱壁模式是线程信号量隔离:</strong></p> 
 <p>        在微服务调用的时候,sentinel会创建一个<span style="color:#4da8ee;"><strong>线程计数器</strong></span><span style="color:#0d0016;">用于对调用者使用线程的记录,可以自定义线程阈值,</span></p> 
</blockquote> 
<h4 id="%C2%A0%E4%BF%A1%E5%8F%B7%E9%87%8F%E9%9A%94%E7%A6%BB%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%9A%94%E7%A6%BB%E7%9A%84%E5%8C%BA%E5%88%AB"><strong><span style="color:#0d0016;">信号量隔离与线程池隔离的区别</span></strong></h4> 
<blockquote> 
 <p><strong>线程池隔离</strong>：给每个服务调用业务分配一个线程池，利用线程池本身实现隔离效果</p> 
 <p><strong>信号量隔离</strong>：不创建线程池，而是计数器模式，记录业务使用的线程数量，达到信号量上限时，禁止新的请求。</p> 
 <p><img alt="" height="584" src="https://images2.imgbox.com/39/6d/sGVFwC84_o.png" width="851"></p> 
</blockquote> 
<h4 id="%C2%A0%C2%A0sentinel--%E7%86%94%E6%96%AD%E6%A8%A1%E5%BC%8F--%E4%BB%8B%E7%BB%8D">sentinel--熔断模式--介绍</h4> 
<blockquote> 
 <p>熔断机制是调用断路器对微服务的异常比列,慢调用比例进行统计,超过阈值后会进行熔断, 不过断路器会根据指定熔断时间进行恢复尝试,若服务可用,断路器会解除熔断状态</p> 
 <p><img alt="" height="353" src="https://images2.imgbox.com/5c/ce/1aj1RRZO_o.png" width="1154"></p> 
 <p><strong><span style="color:#4da8ee;">closed</span></strong>：关闭状态，断路器放行所有请求，并开始统计异常比例、慢请求比例。超过阈值则切换到open状态</p> 
 <p><span style="color:#4da8ee;"><strong>open</strong></span>：打开状态，服务调用被<strong>熔断</strong>，访问被熔断服务的请求会被拒绝，快速失败，直接走降级逻辑。Open状态5秒后会进入half-open状态</p> 
 <p><span style="color:#4da8ee;"><strong>half-open</strong></span>：半开状态，放行一次请求，根据执行结果来判断接下来的操作。</p> 
 <p>        请求成功：则切换到closed状态<br>         请求失败：则切换到open状态</p> 
</blockquote> 
<h4 id="%C2%A0%C2%A0sentinel--%E7%86%94%E6%96%AD%E6%A8%A1%E5%BC%8F--%E4%B8%89%E7%A7%8D%E7%BB%9F%E8%AE%A1%E6%96%B9%E5%BC%8F">sentinel--熔断模式--三种统计方式</h4> 
<blockquote> 
 <p>慢调用比例:</p> 
 <p>        业务的相应时长(RT)大于自定义时长的被称为慢调用, 若在指定时间内,慢调用的比例大于我们自定义的比例,则会触发熔断机制</p> 
 <p><img alt="" height="356" src="https://images2.imgbox.com/b8/2d/UutlFl2C_o.png" width="843"></p> 
 <p>异常比例;</p> 
 <p>        统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常的比例达到设定的比例阈值，则触发熔断。</p> 
 <p><img alt="" height="312" src="https://images2.imgbox.com/37/f6/lWAF3OEs_o.png" width="642"></p> 
 <p>异常数:</p> 
 <p>        统计指定时间内的调用，如果调用次数超过指定请求数，并且出现异常数超过指定异常数，则触发熔断。</p> 
 <p><img alt="" height="313" src="https://images2.imgbox.com/c9/16/txdKodwY_o.png" width="649"></p> 
</blockquote> 
<h4 id="%C2%A0%C2%A0sentinel--%E8%AE%BF%E9%97%AE%E6%8E%88%E6%9D%83">sentinel--访问授权</h4> 
<blockquote> 
 <p>sentinel的授权可以对请求方资源进行拦截与放行,类似于网关的作用,如果当服务器被绕过网关访问的时候,sentinel的授权就可以对服务进行保护, 有黑名单,白名单两种方式</p> 
 <p><strong>黑名单</strong>: 禁止访问名单</p> 
 <p><strong>白名单</strong>: 允许访问名单</p> 
 <p><img alt="" height="192" src="https://images2.imgbox.com/40/92/9XXi01Pn_o.png" width="833"></p> 
 <p> <span style="color:#4da8ee;"><strong>而流控应用名称(</strong></span><strong>origin</strong><span style="color:#4da8ee;"><strong>)是sentinel是通过RequestOriginParser这个接口获取的</strong></span></p> 
 <pre><code class="language-java">public interface RequestOriginParser {
    /**
     * 从请求request对象中获取origin，获取方式自定义
     */
    String parseOrigin(HttpServletRequest request);
}</code></pre> 
 <p>这个方法的作用就是从request对象中，获取请求者的origin值并返回。</p> 
 <p>默认情况下，sentinel不管请求者从哪里来，返回值永远是<span style="color:#4da8ee;"><strong>default</strong></span>，也就是说一切请求的来源都被认为是一样的值default。</p> 
 <p>因此，我们需要自定义这个接口的实现，让<strong>不同的请求，返回不同的origin</strong>。</p> 
 <pre><code class="language-java">@Component
public class HeaderOriginParser implements RequestOriginParser {
    @Override
    public String parseOrigin(HttpServletRequest request) {
        // 1.获取请求头
        String origin = request.getHeader("origin");
        // 2.非空判断
        if (StringUtils.isEmpty(origin)) {
            origin = "blank";
        }
        return origin;
    }
}</code></pre> 
 <p>既然获取请求origin的方式是从reques-header中获取origin值，我们必须让<strong>所有从gateway路由到微服务的请求都带上origin头</strong>。</p> 
 <p>这个需要利用之前学习的一个GatewayFilter来实现，AddRequestHeaderGatewayFilter。</p> 
 <p>修改gateway服务中的application.yml，添加一个defaultFilter：</p> 
 <pre><code class="language-java">spring:
  cloud:
    gateway:
      default-filters:
        - AddRequestHeader=origin,gateway
</code></pre> 
 <p>这样，从gateway路由的所有请求都会带上origin头，值为gateway。而从其它地方到达微服务的请求则没有这个头。</p> 
</blockquote> 
<h4 id="%C2%A0%C2%A0%C2%A0sentinel--%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8">sentinel--自定义异常</h4> 
<blockquote> 
 <p>默认情况下,触发了sentinel的保护机制后返回的异常结果都是flowLimmiting,（限流）。这样不够友好，无法得知是限流还是降级还是授权拦截。 而如果要自定义异常时的返回结果，需要实现BlockExceptionHandler接口：</p> 
 <pre><code class="language-java">public interface BlockExceptionHandler {
    /**
     * 处理请求被限流、降级、授权拦截时抛出的异常：BlockException
     */
    void handle(HttpServletRequest request, HttpServletResponse response, BlockException e) throws Exception;
}</code></pre> 
 <p>这个方法有三个参数：</p> 
 <p>- HttpServletRequest request：request对象<br> - HttpServletResponse response：response对象<br> - BlockException e：被sentinel拦截时抛出的异常</p> 
 <p><img alt="" height="362" src="https://images2.imgbox.com/87/04/negVU1Ke_o.png" width="930"></p> 
 <p> 我们就可以自定义一个异常类</p> 
 <pre><code class="language-java">@Component
public class SentinelExceptionHandler implements BlockExceptionHandler {
    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, BlockException e) throws Exception {
        String msg = "未知异常";
        int status = 429;

        if (e instanceof FlowException) {
            msg = "请求被限流了";
        } else if (e instanceof ParamFlowException) {
            msg = "请求被热点参数限流";
        } else if (e instanceof DegradeException) {
            msg = "请求被降级了";
        } else if (e instanceof AuthorityException) {
            msg = "没有权限访问";
            status = 401;
        }

        response.setContentType("application/json;charset=utf-8");
        response.setStatus(status);
        response.getWriter().println("{\"msg\": " + msg + ", \"status\": " + status + "}");
    }
}</code></pre> 
</blockquote> 
<h4 id="%C2%A0%C2%A0sentinel--%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96"><strong>sentinel--规则持久化</strong></h4> 
<blockquote> 
 <p>sentinel的开源版本,默认的规则是存储于内存中的,当服务重启的时候就会失效,所以需要对配置规则进行持久化操作</p> 
 <p>规则是否能持久化，取决于规则管理模式，sentinel支持三种规则管理模式：</p> 
 <p>- <span style="color:#4da8ee;"><strong>原始模式</strong></span>：Sentinel的默认模式，将规则保存在内存，重启服务会丢失。<br> - <span style="color:#4da8ee;"><strong>pull模式 </strong></span>：控制台将配置的规则推送到Sentinel客户端，而客户端会将配置规则保存在本地文件或数据库中。以后会定时去本地文件或数据库中查询，更新本地规则。<br> - <span style="color:#4da8ee;"><strong>push模式:</strong></span>  控制台将配置规则推送到远程配置中心，例如Nacos。Sentinel客户端监听Nacos，获取配置变更的推送消息，完成本地配置更新。</p> 
 <p>一般我们使用push模式, 不过需要修改源码,</p> 
 <p>附上教程<a class="link-info" href="https://blog.csdn.net/lilizhou2008/article/details/97075236?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522164622192616780366595607%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=164622192616780366595607&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-97075236.pc_search_result_control_group&amp;utm_term=sentinel%E8%A7%84%E5%88%99%E6%8C%81%E4%B9%85%E5%8C%96nacos&amp;spm=1018.2226.3001.4187" title="push模式到nacos">push模式到nacos</a></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/091983547a7175f948e4ad8f0e8e1f75/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows 下将Python项目打包为.exe可执行文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fbaacf42dc776ab4e9683b9f914f6637/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">spring框架简单入门</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>