<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>OpenCV 图像处理学习手册：6~7 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="OpenCV 图像处理学习手册：6~7" />
<meta property="og:description" content="原文：Learning Image Processing with OpenCV
协议：CC BY-NC-SA 4.0
译者：飞龙
本文来自【ApacheCN 计算机视觉 译文集】，采用译后编辑（MTPE）流程来尽可能提升效率。
当别人说你没有底线的时候，你最好真的没有；当别人说你做过某些事的时候，你也最好真的做过。
六、计算摄影 计算摄影是指使您能够扩展数字摄影的典型功能的技术。 这可能包括硬件附加组件或修改，但主要指基于软件的技术。 这些技术可能会产生“传统”数码相机无法获得的输出图像。 本章介绍了 OpenCV 中用于计算摄影的一些鲜为人知的技术：高动态范围成像，无缝克隆，脱色和非照片级渲染。 这三个位于库的photo模块中。 注意，在前面的章节中已经考虑了该模块内部的其他技术（修复和去噪）。
高动态范围图像 我们处理的典型图像每像素有 8 位（BPP）。 彩色图像还使用 8 位表示每个通道的值，即红色，绿色和蓝色。 这意味着仅使用 256 个不同的强度值。 在数字成像的整个历史中，这个 8 BPP 的限制一直盛行。 但是，很明显，自然界中的光并不只有 256 个不同的水平。 因此，我们应该考虑这种离散化是理想的还是足够的。 例如，已知人眼可以捕获更高的动态范围（最暗和最亮之间的亮度级别数），估计在 1 亿到 1 亿个亮度级别之间。 在只有 256 个光照级别的情况下，有些情况下明亮的光线看起来过度曝光或饱和，而黑暗的场景只是被捕获为黑色。
有些相机可以捕获超过 8 BPP 的图像。 但是，创建高动态范围图像的最常见方法是使用 8 BPP 相机并拍摄具有不同曝光值的图像。 当我们这样做时，动态范围有限的问题显而易见。 例如，考虑下图：
用六个不同的曝光值拍摄的场景
注意 左上方的图像大部分为黑色，但窗口详细信息可见。 相反，右下角的图像显示了房间的细节，但窗口的细节几乎看不见。
我们可以使用现代智能手机相机以不同的曝光水平拍摄照片。 例如，对于 iPhone 和 iPad，从 iOS 8 开始，使用本机相机应用更改曝光非常容易。 触摸屏幕，将出现一个黄色框，侧面带有一个小太阳。 向上或向下滑动可以更改曝光（请参见以下屏幕截图）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8d67f0f5e61c5daeb934ea8ae42453a0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-19T10:30:04+08:00" />
<meta property="article:modified_time" content="2023-04-19T10:30:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">OpenCV 图像处理学习手册：6~7</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>原文：<a href="https://1lib.org/book/2549159/d8a0fd" rel="nofollow">Learning Image Processing with OpenCV</a></p> 
 <p>协议：<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" rel="nofollow">CC BY-NC-SA 4.0</a></p> 
 <p>译者：<a href="https://github.com/wizardforcel">飞龙</a></p> 
 <p>本文来自<a href="https://github.com/apachecn/apachecn-cv-zh">【ApacheCN 计算机视觉 译文集】</a>，采用<a href="https://cn.bing.com/search?q=%E8%AF%91%E5%90%8E%E7%BC%96%E8%BE%91" rel="nofollow">译后编辑（MTPE）</a>流程来尽可能提升效率。</p> 
 <p>当别人说你没有底线的时候，你最好真的没有；当别人说你做过某些事的时候，你也最好真的做过。</p> 
</blockquote> 
<h2><a id="_12"></a>六、计算摄影</h2> 
<p>计算摄影是指使您能够扩展数字摄影的典型功能的技术。 这可能包括硬件附加组件或修改，但主要指基于软件的技术。 这些技术可能会产生“传统”数码相机无法获得的输出图像。 本章介绍了 OpenCV 中用于计算摄影的一些鲜为人知的技术：高动态范围成像，无缝克隆，脱色和非照片级渲染。 这三个位于库的<code>photo</code>模块中。 注意，在前面的章节中已经考虑了该模块内部的其他技术（修复和去噪）。</p> 
<h2><a id="_16"></a>高动态范围图像</h2> 
<p>我们处理的典型图像每像素有 8 位（<strong>BPP</strong>）。 彩色图像还使用 8 位表示每个通道的值，即红色，绿色和蓝色。 这意味着仅使用 256 个不同的强度值。 在数字成像的整个历史中，这个 8 BPP 的限制一直盛行。 但是，很明显，自然界中的光并不只有 256 个不同的水平。 因此，我们应该考虑这种离散化是理想的还是足够的。 例如，已知人眼可以捕获更高的动态范围（最暗和最亮之间的亮度级别数），估计在 1 亿到 1 亿个亮度级别之间。 在只有 256 个光照级别的情况下，有些情况下明亮的光线看起来过度曝光或饱和，而黑暗的场景只是被捕获为黑色。</p> 
<p>有些相机可以捕获超过 8 BPP 的图像。 但是，创建高动态范围图像的最常见方法是使用 8 BPP 相机并拍摄具有不同曝光值的图像。 当我们这样做时，动态范围有限的问题显而易见。 例如，考虑下图：</p> 
<p><img src="https://images2.imgbox.com/00/db/O08ZqMwQ_o.png" alt="High-dynamic-range images"></p> 
<p>用六个不同的曝光值拍摄的场景</p> 
<h4><a id="_26"></a>注意</h4> 
<p>左上方的图像大部分为黑色，但窗口详细信息可见。 相反，右下角的图像显示了房间的细节，但窗口的细节几乎看不见。</p> 
<p>我们可以使用现代智能手机相机以不同的曝光水平拍摄照片。 例如，对于 iPhone 和 iPad，从 iOS 8 开始，使用本机相机应用更改曝光非常容易。 触摸屏幕，将出现一个黄色框，侧面带有一个小太阳。 向上或向下滑动可以更改曝光（请参见以下屏幕截图）。</p> 
<h4><a id="_32"></a>注意</h4> 
<p>曝光级别的范围非常大，因此我们可能不得不重复多次滑动手势。</p> 
<p>如果您使用的是 iOS 的早期版本，则可以下载相机应用，例如 <em>Camera+</em>，这些应用可让您专注于特定点并更改曝光。</p> 
<p>对于 Android，可以在 Google Play 上使用大量相机应用来调整曝光度。 一个例子是 <em>Camera FV-5</em>，它具有免费和付费版本。</p> 
<h4><a id="_40"></a>提示</h4> 
<p>如果使用手持设备捕获图像，请确保该设备是静态的。 实际上，您可能会使用三脚架。 否则，具有不同曝光度的图像将无法对齐。 同样，移动的被摄体将不可避免地产生鬼影。 在大多数情况下，低，中和高曝光量的三张图像就足够了。</p> 
<p><img src="https://images2.imgbox.com/1a/36/prOPsZPr_o.png" alt="High-dynamic-range images"></p> 
<p>使用 iPhone 5S 中的本机摄像头应用进行曝光控制</p> 
<p>智能手机和桌子很方便，可以拍摄许多曝光不同的图像。 要创建 HDR 图像，我们需要知道每个捕获图像的曝光（或快门）时间（原因请参见以下部分）。 并非所有应用都允许您手动控制（甚至查看）此功能（iOS 8 本机应用则不允许）。 在撰写本文时，至少有两个免费的应用允许 iOS 版使用：<em>Manually</em> 和 <em>ManualShot</em>。 在 Android 中，免费的 <em>Camera FV-5</em> 可让您控制和查看曝光时间。 请注意，F/Stop 和 ISO 是控制曝光的其他两个参数。</p> 
<p>捕获的图像可以传输到开发计算机，并用于创建 HDR 图像。</p> 
<h4><a id="_52"></a>注意</h4> 
<p>从 iOS 7 开始，本机相机应用具有 HDR 模式，可自动快速捕获三幅图像，每幅图像具有不同的曝光度。 这些图像也会自动组合为单个（有时更好）的图像。</p> 
<h3><a id="_HDR__56"></a>创建 HDR 图像</h3> 
<p>我们如何将多张（例如三张）曝光图像合成为 HDR 图像？ 如果我们仅考虑一个通道和一个给定的像素，则必须在较大的输出范围（例如 16 bpp）中将这三个像素值（每个曝光级别一个）映射到单个值。 这种映射并不容易。 首先，我们必须考虑像素强度是传感器辐照度（入射在相机传感器上的光量）的（粗略）度量。 数码相机以非线性方式测量辐照度。 相机具有非线性响应函数，可以将辐照度转换为像素强度值，范围为 0 到 255。 为了将这些值映射到更大的离散值集，我们必须估计摄像机的响应函数（即，响应范围在 0 到 255 之间）。</p> 
<p>我们如何估计相机响应函数？ 我们从像素本身做到这一点！ 响应函数是每个颜色通道的 Sigmoid 曲线，可以根据像素进行估计（如果有 3 个像素曝光，则每个颜色通道的曲线上有 3 个点）。 由于这非常耗时，因此通常选择一组随机像素。</p> 
<p>只剩下一件事了。 我们之前曾讨论过估计辐照度和像素强度之间的关系。 我们如何知道辐照度？ 传感器的辐照度与曝光时间（或等效地，快门速度）成正比。 这就是我们需要曝光时间的原因！</p> 
<p>最后，将 HDR 图像计算为从每次曝光的像素中恢复的辐照度值的加权和。 请注意，此图像无法在范围有限的常规屏幕上显示。</p> 
<h4><a id="_66"></a>注意</h4> 
<p>关于高动态范围成像的一本好书是 Reinhard 等人的《高动态范围成像：获取，显示和基于图像的照明》，Morgan Kaufmann Pub。 该书随附 DVD，其中包含不同 HDR 格式的图像。</p> 
<h4><a id="_70"></a>范例</h4> 
<p>OpenCV（仅从 3.0 版开始）提供了从一组以不同曝光拍摄的图像中创建 HDR 图像的函数。 甚至还有一个名为<code>hdr_imaging</code>的教程示例，该示例从图像文件中读取图像文件和曝光时间列表，并创建 HDR 图像。</p> 
<h4><a id="_74"></a>注意</h4> 
<p>为了运行<code>hdr_imaging</code>教程，您将需要使用列表下载所需的图像文件和文本文件。 您可以从<a href="https://github.com/Itseez/opencv_extra/tree/master/testdata/cv/hdr">这个页面</a>下载它们。</p> 
<p><code>CalibrateDebevec</code>和<code>MergeDebevec</code>类实现 Debevec 的方法来估计相机响应函数并将曝光分别合并为 HDR 图像。<code>createHDR</code>示例之后的向您展示了如何使用这两个类：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/photo.hpp&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/highgui.hpp&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> cv<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    vector<span class="token operator">&lt;</span>Mat<span class="token operator">&gt;</span> images<span class="token punctuation">;</span>
    vector<span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span> times<span class="token punctuation">;</span>

    <span class="token comment">// Load images and exposures...</span>
    Mat img1 <span class="token operator">=</span> <span class="token function">imread</span><span class="token punctuation">(</span><span class="token string">"1div66.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>img1<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Error! Input image cannot be read...\n"</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    Mat img2 <span class="token operator">=</span> <span class="token function">imread</span><span class="token punctuation">(</span><span class="token string">"1div32.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Mat img3 <span class="token operator">=</span> <span class="token function">imread</span><span class="token punctuation">(</span><span class="token string">"1div12.jpg"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    images<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>img1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    images<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>img2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    images<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>img3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    times<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">66</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    times<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    times<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token number">1</span><span class="token operator">/</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Estimate camera response...</span>
    Mat response<span class="token punctuation">;</span>
 Ptr<span class="token operator">&lt;</span>CalibrateDebevec<span class="token operator">&gt;</span> calibrate <span class="token operator">=</span> <span class="token function">createCalibrateDebevec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 calibrate<span class="token operator">-&gt;</span><span class="token function">process</span><span class="token punctuation">(</span>images<span class="token punctuation">,</span> response<span class="token punctuation">,</span> times<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Show the estimated camera response function...</span>
    cout <span class="token operator">&lt;&lt;</span> response<span class="token punctuation">;</span>

    <span class="token comment">// Create and write the HDR image...</span>
    Mat hdr<span class="token punctuation">;</span>
 Ptr<span class="token operator">&lt;</span>MergeDebevec<span class="token operator">&gt;</span> merge_debevec <span class="token operator">=</span> <span class="token function">createMergeDebevec</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 merge_debevec<span class="token operator">-&gt;</span><span class="token function">process</span><span class="token punctuation">(</span>images<span class="token punctuation">,</span> hdr<span class="token punctuation">,</span> times<span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">imwrite</span><span class="token punctuation">(</span><span class="token string">"hdr.hdr"</span><span class="token punctuation">,</span> hdr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\nDone. Press any key to exit...\n"</span><span class="token punctuation">;</span>
    <span class="token function">waitKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Wait for key press</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>该示例使用三个杯子的图像（这些图像以及本书随附的代码均可用）。 图像是使用 <em>ManualShot</em> 拍摄的前面提到的应用，使用的曝光时间为 1/66、1/32 和 1/12 秒； 请参考下图：</p> 
<p><img src="https://images2.imgbox.com/7d/47/wPcJxzKR_o.png" alt="Example"></p> 
<p>示例中用作输入的三个图像</p> 
<p>请注意，<code>createCalibrateDebevec</code>方法在 STL 向量中期望图像和曝光时间（STL 是一种有用的常用函数和标准 C++ 中可用的数据结构的库）。 相机响应函数以 256 个实值向量的形式给出。 这表示像素值和辐照度之间的映射。 实际上，它是一个<code>256 x 3</code>的矩阵（三个颜色通道中的每个颜色通道一列）。 下图显示了示例给出的响应：</p> 
<p><img src="https://images2.imgbox.com/30/94/yefrjoYL_o.png" alt="Example"></p> 
<p>估计的 RGB 相机响应函数</p> 
<h4><a id="_141"></a>提示</h4> 
<p>代码的<code>cout</code>部分以 MATLAB 和 Octave（两种用于数值计算的包）使用的格式显示矩阵。 复制输出中的矩阵并将其粘贴到 MATLAB/Octave 中以进行显示很简单。</p> 
<p>生成的 HDR 图像以无损 RGBE 格式存储。 此图像格式使用每个颜色通道一个字节，再加上一个字节作为共享指数。 格式使用与浮点数表示法相同的原理：共享指数允许您表示更大范围的值。 RGBE 图像使用<code>.hdr</code>扩展名。 请注意，由于它是无损图像格式，因此<code>.hdr</code>文件相对较大。 在此示例中，RGB 输入图像分别为 1224 x 1632（每个 100 至 200 KB），而输出<code>.hdr</code>文件占用 5.9 MB。</p> 
<p>该示例使用 Debevec 和 Malik 的方法，但是 OpenCV 还基于 Robertson 的方法提供了另一个校准函数。 校准和合并函数均可用，即<code>createCalibrateRobertson</code>和<code>MergeRobertson</code>。</p> 
<h4><a id="_149"></a>注意</h4> 
<p>有关其他函数及其背后原理的更多信息，请参见<a href="http://docs.opencv.org/trunk/modules/photo/doc/hdr_imaging.html" rel="nofollow">这个页面</a>。</p> 
<p>最后，请注意示例不会显示结果图像。 HDR 图像无法在常规屏幕中显示，因此我们需要执行另一步，称为色调映射。</p> 
<h3><a id="_155"></a>色调映射</h3> 
<p>当要显示高动态范围图像时，信息可能会丢失。 这是由于，因为计算机屏幕的对比度也很有限，而且打印材料通常也限制为 256 色。 当我们具有高动态范围的图像时，有必要将强度映射到一组有限的值。 这称为色调映射。</p> 
<p>为了提供逼真的输出，仅将 HDR 图像值缩放到显示设备的缩小范围是不够的。 缩放通常会产生缺乏细节（对比度）的图像，从而消除了原始场景内容。 最终，色调映射算法旨在提供视觉上看起来类似于原始场景的输出（即类似于人类在查看场景时所看到的输出）。 已经提出了各种音调映射算法，并且仍然是广泛研究的问题。 以下代码行可以将色调映射应用于上一个示例中获得的 HDR 图像：</p> 
<pre><code class="prism language-cpp">Mat ldr<span class="token punctuation">;</span>
Ptr<span class="token operator">&lt;</span>TonemapDurand<span class="token operator">&gt;</span> tonemap <span class="token operator">=</span> <span class="token function">createTonemapDurand</span><span class="token punctuation">(</span><span class="token number">2.2f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
tonemap<span class="token operator">-&gt;</span><span class="token function">process</span><span class="token punctuation">(</span>hdr<span class="token punctuation">,</span> ldr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ldr is a floating point image with </span>
ldr<span class="token operator">=</span>ldr<span class="token operator">*</span><span class="token number">255</span><span class="token punctuation">;</span>      <span class="token comment">//  values in interval [0..1]</span>
<span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"LDR"</span><span class="token punctuation">,</span> ldr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>该方法由 Durand 和 Dorsey 于 2002 年提出。构造器实际上接受许多影响输出的参数。 下图显示了输出。 请注意，此图像不一定比三个原始图像中的任何一个都要好：</p> 
<p><img src="https://images2.imgbox.com/f5/28/Ch72KZkB_o.png" alt="Tone mapping"></p> 
<p>音调输出</p> 
<p>OpenCV 中提供了其他三种音调映射算法：<code>createTonemapDrago</code>，<code>createTonemapReinhard</code>和<code>createTonemapMantiuk</code>。</p> 
<p>可以使用 MATLAB 显示 HDR 图像（RGBE 格式，即扩展名为<code>.hdr</code>的文件）。 它只需要三行代码：</p> 
<pre><code class="prism language-cpp">hdr<span class="token operator">=</span><span class="token function">hdrread</span><span class="token punctuation">(</span><span class="token char">'hdr.hdr'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
rgb<span class="token operator">=</span><span class="token function">tonemap</span><span class="token punctuation">(</span>hdr<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token function">imshow</span><span class="token punctuation">(</span>rgb<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_185"></a>注意</h4> 
<p>pfstools 是命令行工具的开源套件，用于读取，写入和渲染 HDR 图像。 该套件可以读取<code>.hdr</code>和其他格式，其中包括许多相机校准和色调映射算法。 Luminance HDR 是基于 pfstools 的免费 GUI 软件。</p> 
<h3><a id="_189"></a>对齐</h3> 
<p>用多张曝光图像拍摄的场景必须是静态的。 摄像机也必须是静态的。 即使满足两个条件，也建议执行对齐过程。</p> 
<p>OpenCV 提供了 G. Ward 在 2003 年提出的图像对齐算法。主要函数<code>createAlignMTB</code>采用定义最大位移的输入参数（实际上，每个尺寸的最大位移以 2 为底的对数）。 在上一示例中估计摄像机响应函数之前，应插入以下几行：</p> 
<pre><code class="prism language-cpp">    vector<span class="token operator">&lt;</span>Mat<span class="token operator">&gt;</span> <span class="token function">images_</span><span class="token punctuation">(</span>images<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Ptr<span class="token operator">&lt;</span>AlignMTB<span class="token operator">&gt;</span> align<span class="token operator">=</span><span class="token function">createAlignMTB</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 4=max 16 pixel shift</span>
    align<span class="token operator">-&gt;</span><span class="token function">process</span><span class="token punctuation">(</span>images_<span class="token punctuation">,</span> images<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h3><a id="_201"></a>曝光融合</h3> 
<p>我们也可以使用相机响应校准（即曝光时间）或中间 HDR 图像，将具有多次曝光的图像组合在一起。 这称为曝光融合。 该方法由 Mertens 等人在 2007 年提出。以下几行执行曝光融合（<code>images</code>是输入图像的 STL 向量；请参见前面的示例）：</p> 
<pre><code class="prism language-cpp">    Mat fusion<span class="token punctuation">;</span>
    Ptr<span class="token operator">&lt;</span>MergeMertens<span class="token operator">&gt;</span> merge_mertens <span class="token operator">=</span> <span class="token function">createMergeMertens</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    merge_mertens<span class="token operator">-&gt;</span><span class="token function">process</span><span class="token punctuation">(</span>images<span class="token punctuation">,</span> fusion<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// fusion is a </span>
 fusion<span class="token operator">=</span>fusion<span class="token operator">*</span><span class="token number">255</span><span class="token punctuation">;</span> <span class="token comment">// float. point image w. values in [0..1]</span>
 <span class="token function">imwrite</span><span class="token punctuation">(</span><span class="token string">"fusion.png"</span><span class="token punctuation">,</span> fusion<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>下图显示了结果：</p> 
<p><img src="https://images2.imgbox.com/ff/06/KNvRZcHu_o.png" alt="Exposure fusion"></p> 
<p>曝光融合</p> 
<h2><a id="_219"></a>无缝克隆</h2> 
<p>在无缝克隆中，我们通常要在源图像中剪切一个对象/人并将其插入目标图像。 当然，这可以通过简单地粘贴对象以简单的方式完成。 但是，这不会产生现实的效果。 参见下图，例如，我们想要将图像上半部分的船插入图像下半部分的海中：</p> 
<p><img src="https://images2.imgbox.com/70/27/00rkFWUv_o.png" alt="Seamless cloning"></p> 
<p>克隆</p> 
<p>从 OpenCV 3 开始，已有无缝克隆函数可用，其结果更为真实。 此函数称为<code>seamlessClone</code>，它使用 Perez 和 Gangnet 在 2003 年提出的方法。以下<code>SeamlessCloning</code>示例向您展示了如何使用它：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/photo.hpp&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/highgui.hpp&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> cv<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// Load and show images...</span>
    Mat source <span class="token operator">=</span> <span class="token function">imread</span><span class="token punctuation">(</span><span class="token string">"source1.png"</span><span class="token punctuation">,</span> IMREAD_COLOR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Mat destination <span class="token operator">=</span> <span class="token function">imread</span><span class="token punctuation">(</span><span class="token string">"destination1.png"</span><span class="token punctuation">,</span> IMREAD_COLOR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Mat mask <span class="token operator">=</span> <span class="token function">imread</span><span class="token punctuation">(</span><span class="token string">"mask.png"</span><span class="token punctuation">,</span> IMREAD_COLOR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"source"</span><span class="token punctuation">,</span> source<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"mask"</span><span class="token punctuation">,</span> mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"destination"</span><span class="token punctuation">,</span> destination<span class="token punctuation">)</span><span class="token punctuation">;</span>

    Mat result<span class="token punctuation">;</span>
    Point p<span class="token punctuation">;</span>    <span class="token comment">// p will be near top right corner</span>
    p<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span><span class="token number">2</span><span class="token operator">*</span>destination<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>width<span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">;</span>
    p<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>destination<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>height<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token function">seamlessClone</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> destination<span class="token punctuation">,</span> mask<span class="token punctuation">,</span> p<span class="token punctuation">,</span> result<span class="token punctuation">,</span> NORMAL_CLONE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"result"</span><span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\nDone. Press any key to exit...\n"</span><span class="token punctuation">;</span>
    <span class="token function">waitKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Wait for key press</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这个例子很简单。 <code>seamlessClone</code>函数获取源图像，目标图像和遮罩图像以及目标图像中将插入裁剪对象的点（可以从<a href="https://github.com/Itseez/opencv_extra/tree/master/testdata/cv/cloning/Normal_Cloning">这个页面</a>）。 请参见下图的结果：</p> 
<p><img src="https://images2.imgbox.com/1c/1d/8IloDVa7_o.png" alt="Seamless cloning"></p> 
<p>无缝克隆</p> 
<p><code>seamlessClone</code>的最后一个参数表示要使用的确切方法（可以使用三种方法产生不同的最终效果）。 另一方面，库提供以下相关函数：</p> 
<table><thead><tr><th>函数</th><th>效果</th></tr></thead><tbody><tr><td><code>colorChange</code></td><td>将源图像的三个颜色通道中的每个乘以一个因子，仅在遮罩给定的区域中应用乘法</td></tr><tr><td><code>illuminationChange</code></td><td>仅在遮罩指定的区域内更改源图像的照度</td></tr><tr><td><code>textureFlattening</code></td><td>仅在遮罩指定的区域中洗掉源图像中的纹理</td></tr></tbody></table> 
<p>与<code>seamlessClone</code>相反，这三个函数仅接受源图像和遮罩图像。</p> 
<h2><a id="_276"></a>脱色</h2> 
<p>脱色是将彩色图像转换为灰度的过程。 有了这个定义，读者可能会问，我们是否已经有了灰度转换？ 是的，灰度转换是 OpenCV 和任何图像处理库中的基本例程。 标准转换基于 R，G 和 B 通道的线性组合。 问题在于这种转换可能会产生原始图像中的对比度丢失的图像。 原因是两种不同的颜色（在原始图像中被视为对比度）可能最终被映射到相同的灰度值。 考虑将 A 和 B 这两种颜色转换为灰度。 假设 B 是 R 和 G 通道中 A 的变体：</p> 
<pre><code class="prism language-cpp">A <span class="token operator">=</span> <span class="token punctuation">(</span>R<span class="token punctuation">,</span> G<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> G <span class="token operator">=</span> <span class="token punctuation">(</span>R <span class="token operator">+</span> G <span class="token operator">+</span> B<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">3</span>
B <span class="token operator">=</span> <span class="token punctuation">(</span>R<span class="token operator">-</span>x<span class="token punctuation">,</span> G <span class="token operator">+</span> x<span class="token punctuation">,</span> B<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> G <span class="token operator">=</span> <span class="token punctuation">(</span>R<span class="token operator">-</span>x <span class="token operator">+</span> G <span class="token operator">+</span> x <span class="token operator">+</span> B<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">3</span> <span class="token operator">=</span> <span class="token punctuation">(</span>R <span class="token operator">+</span> G <span class="token operator">+</span> B<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">3</span>
</code></pre> 
<p>即使它们被认为是截然不同的，两种颜色 A 和 B 也被映射为相同的灰度值！ 以下<strong>脱色</strong>示例的图像显示如下：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/photo.hpp&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/highgui.hpp&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> cv<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">*</span><span class="token operator">*</span> argv<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// Load and show images...</span>
    Mat source <span class="token operator">=</span> <span class="token function">imread</span><span class="token punctuation">(</span><span class="token string">"color_image_3.png"</span><span class="token punctuation">,</span> IMREAD_COLOR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"source"</span><span class="token punctuation">,</span> source<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// first compute and show standard grayscale conversion...</span>
    Mat grayscale <span class="token operator">=</span> <span class="token function">Mat</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>CV_8UC1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">cvtColor</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> grayscale<span class="token punctuation">,</span> COLOR_BGR2GRAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"grayscale"</span><span class="token punctuation">,</span>grayscale<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// now compute and show decolorization...</span>
    Mat decolorized <span class="token operator">=</span> <span class="token function">Mat</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>CV_8UC1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Mat dummy <span class="token operator">=</span> <span class="token function">Mat</span><span class="token punctuation">(</span>source<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>CV_8UC3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">decolor</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span>decolorized<span class="token punctuation">,</span>dummy<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"decolorized"</span><span class="token punctuation">,</span>decolorized<span class="token punctuation">)</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\nDone. Press any key to exit...\n"</span><span class="token punctuation">;</span>
    <span class="token function">waitKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Wait for key press</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/76/c1/bHxnwYHC_o.png" alt="Decolorization"></p> 
<p>脱色示例输出</p> 
<p>这个例子很简单。 读取图像并显示标准灰度转换的结果后，它使用<code>decolor</code>函数执行脱色。 所使用的图像（<code>color_image_3.png</code>文件）包含在 opencv_extra 存储库中，位于<a href="https://github.com/Itseez/opencv_extra/tree/master/testdata/cv/decolor">这个页面</a>。</p> 
<h4><a id="_325"></a>注意</h4> 
<p>该示例中使用的图像实际上是一个极端的情况。 选择其颜色是为了使标准灰度输出相当均匀。</p> 
<h2><a id="_329"></a>非真实感渲染</h2> 
<p>作为<code>photo</code>模块的的一部分，提供了四个函数，这些函数可以转换输入图像，从而产生不真实但仍具有艺术感的输出。 这些函数非常易于使用，OpenCV（<code>npr_demo</code>）中包含一个很好的示例。 为了说明的目的，在这里我们为您提供一个表格，让您掌握每个函数的效果。 看一下下面的<code>fruits.jpg</code>输入图像，包含在 OpenCV 中：</p> 
<p><img src="https://images2.imgbox.com/fe/72/5q5DMI1P_o.png" alt="Non-photorealistic rendering"></p> 
<p>输入参考图像</p> 
<p>效果是：</p> 
<table><thead><tr><th>函数</th><th>影响</th></tr></thead><tbody><tr><td><code>edgePreservingFilter</code></td><td>平滑是一种方便且经常使用的过滤器。 此函数在保留对象边缘细节的同时执行平滑处理。</td></tr><tr><td></td><td><img src="https://images2.imgbox.com/bd/c7/Hye1sfdF_o.png" alt="Non-photorealistic rendering"></td></tr><tr><td><code>detailEnhance</code></td><td>增强图像中的细节</td></tr><tr><td></td><td><img src="https://images2.imgbox.com/2d/10/ye4G82qX_o.png" alt="Non-photorealistic rendering"></td></tr><tr><td><code>pencilSketch</code></td><td>输入图像的铅笔状线条图版本</td></tr><tr><td></td><td><img src="https://images2.imgbox.com/f4/51/m7Q4uurB_o.png" alt="Non-photorealistic rendering"></td></tr><tr><td><code>stylization</code></td><td>水彩效果</td></tr><tr><td></td><td><img src="https://images2.imgbox.com/7f/34/rwBhjKDm_o.png" alt="Non-photorealistic rendering"></td></tr></tbody></table> 
<h2><a id="_350"></a>总结</h2> 
<p>在本章中，您学习了什么是计算摄影以及 OpenCV 3 中可用的相关功能。我们解释了<code>photo</code>模块中最重要的函数，但请注意，在此模块中还考虑了该模块的其他功能（修复和降噪） 前几章。 计算摄影是一个快速发展的领域，与计算机图形学有着紧密的联系。 因此，预计 OpenCV 的此模块将在将来的版本中增加。</p> 
<p>下一章将讨论我们尚未考虑的重要方面：时间。 解释的许多功能都需要花费大量时间来计算结果。 下一章将向您展示如何使用现代硬件进行处理。</p> 
<h2><a id="_356"></a>七、加速图像处理</h2> 
<p>本章使用通用图形处理单元（<strong>GPGPU</strong>）或简称为 <strong>GPU</strong> 进行并行处理来加速图像处理任务。 GPU 本质上是专用于图形处理或浮点运算的协处理器，旨在提高视频游戏和交互式 3D 图形等应用的性能。 在 GPU 中执行图形处理时，CPU 可以专用于其他计算（例如游戏中的人工智能部分）。 每个 GPU 都配备了数百个简单的处理内核，这些内核可对（通常）浮点数的数百个“简单”数学运算进行大规模并行执行。</p> 
<p>CPU 似乎已达到其速度和热功率极限。 用多个 CPU 构建计算机已成为一个复杂的问题。 这就是 GPU 发挥作用的地方。 GPU 处理是一种新的计算范例，它使用 GPU 来提高计算性能。 GPU 最初实现了某些称为图形基元的并行操作，这些并行操作已针对图形处理进行了优化。 抗锯齿是 3D 图形处理最常见的原语之一，它使图形的边缘具有更逼真的外观。 其他图元是矩形，三角形，圆形和弧形的图形。 GPU 当前包含数百个通用处理功能，它们的功能远远超过渲染图形。 特别是，它们在可以并行执行的任务中非常有价值，许多计算机视觉算法就是这种情况。</p> 
<p>OpenCV 库包括对 OpenCL 和 CUDA GPU 架构的支持。 CUDA 实现了许多算法。 但是，它仅适用于 NVIDIA 图形卡。 CUDA 是由 NVIDIA 创建并由其产生的 GPU 实现的并行计算平台和编程模型。 本章重点介绍 OpenCL 架构，因为它受到更多设备的支持，甚至包括在某些 NVIDIA 图形卡中。</p> 
<p><strong>开放计算语言</strong>（<strong>OpenCL</strong>）是框架，可编写可在连接到主机处理器（CPU）的 CPU 或 GPU 上执行的程序。 它定义了一种类似于 C 的语言来编写称为内核的函数，这些函数在计算设备上执行。 使用 OpenCL，内核可以在与 CPU 或 GPU 并行的所有或许多单个处理元素（PE）上运行。</p> 
<p>此外，OpenCL 定义了<strong>应用编程接口</strong>（<strong>API</strong>），该接口允许在主机（CPU）上运行的程序在计算机设备上启动内核并管理它们的设备存储器，（至少在概念上）与主机存储器分开。 OpenCL 程序旨在在运行时进行编译，以便使用 OpenCL 的应用可在各种主机设备的实现之间移植。 OpenCL 还是非盈利技术联盟 <a href="https://www.khronos.org/" rel="nofollow">Khronos Group</a> 维护的开放标准。</p> 
<p>OpenCV 包含一组类和函数，这些类和函数使用 OpenCL 来实现和加速 OpenCV 功能。 OpenCV 当前提供一个透明的 API，该 API 可以将其原始 API 与 OpenCL 加速的编程统一起来。 因此，您只需要编写一次代码。 有一个新的统一数据结构（<code>UMat</code>），在需要且可能时处理向 GPU 的数据传输。</p> 
<p>OpenCV 中对 OpenCL 的支持是为了易于使用而设计的，不需要任何 OpenCL 知识。 在最低程度上，它可以看作是一组加速，在使用现代 CPU 和 GPU 设备时可以利用强大的计算能力。</p> 
<p>要正确运行 OpenCL 程序，OpenCL 运行时应由设备供应商提供，通常以设备驱动程序的形式提供。 另外，要将 OpenCV 与 OpenCL 一起使用，需要兼容的 SDK。 当前，有五个可用的 OpenCL SDK：</p> 
<ul><li><strong>AMD APP SDK</strong>：此 SDK 在 CPU 和 GPU（例如 X86 + SSE2（或更高）CPU 和 AMD Fusion，AMD Radeon，AMD Mobility 和 ATI FirePro GPU）上支持 OpenCL。</li><li><strong>Intel SDK</strong>：此 SDK 在 Intel Core 处理器和 Intel HD GPU（例如 Intel + SSE4.1，SSE4.2 或 AVX，Intel Core i7，i5 和 i3（ 第 1 代，第 2 代和第 3 代），Intel HD Graphics，Intel Core 2 Solo（Duo Quad 和 Extreme）和 Intel Xeon CPU。</li><li><strong>IBM OpenCL 开发套件</strong>：此 SDK 在 AMD 服务器（例如 IBM Power，IBM PERCS 和 IBM BladeCenter）上支持 OpenCL。</li><li><strong>IBM OpenCL 通用运行时</strong>：此 SDK 在 CPU 和 GPU（例如 X86 + SSE2（或更高版本） CPU 和 AMD Fusion and Raedon，NVIDIA Ion，NVIDIA GeForce 和 NVIDIA）上支持 OpenCV Quadro GPU。</li><li><strong>Nvidia OpenCL 驱动程序和工具</strong>：此 SDK 在某些 Nvidia 图形设备（例如 NVIDIA Tesla，NVIDIA GeForce，NVIDIA Ion 和 NVIDIA Quadro GPU）上支持 OpenCL。</li></ul> 
<h2><a id="_OpenCL__OpenCV_380"></a>安装了 OpenCL 的 OpenCV</h2> 
<p>第 1 章，“处理图像和视频文件”中已经介绍了安装步骤，还需要一些其他步骤来包含 OpenCL。 下节介绍了新需要的软件。</p> 
<p>在 Windows 上使用 OpenCL 编译和安装 OpenCV 有一些新要求：</p> 
<ul><li> <p><strong>支持 OpenCL 的 GPU 或 CPU</strong>：这是最重要的要求。 请注意，OpenCL 支持许多计算设备，但不是全部。 您可以检查图形卡或处理器是否与 OpenCL 兼容。 本章将用于 AMD FirePro W5000 GPU 的 AMD APP SDK 用于执行示例。</p> <h4><a id="_388"></a>注意</h4> <p>在<a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/system-requirements-driver-compatibility/" rel="nofollow">这个页面</a>上有此 SDK 的支持的计算机设备列表。您还可以在此处查询所需的最低 SDK 版本。</p> </li><li> <p><strong>编译器</strong>：具有 OpenCL 的 OpenCV 与 Microsoft 和 MinGW 编译器兼容。 可以安装免费的 Visual Studio Express 版本。 但是，如果选择 Microsoft 编译 OpenCV，则建议至少使用 Visual Studio 2012。 但是，本章使用 MinGW 编译器。</p> </li><li> <p><strong>AMD APP SDK</strong>：此 SDK 是一组高级软件技术，使我们能够使用兼容的计算设备来执行和加速除图形之外的许多应用。 <a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk/" rel="nofollow">该 SDK 可在以下位置获得</a>。本章使用 SDK 的 2.9 版（适用于 64 位 Windows）。 您可以在以下屏幕截图中看到安装进度。</p> <h4><a id="_395"></a>注意</h4> <p>如果此步骤失败，则可能需要更新图形卡的控制器。 可在<a href="http://www.amd.com/en-us/innovations/software-technologies" rel="nofollow">这个页面</a>上获得 AMD 控制器。</p> <p><img src="https://images2.imgbox.com/88/28/dWfvKMjJ_o.png" alt="OpenCV with the OpenCL installation"></p> <p>安装 AMD APP SDK</p> </li><li> <p><strong>OpenCL BLAS</strong>：<strong>基本线性代数子例程</strong>（<strong>BLAS</strong>）是一组开源数学库，用于在 AMD 设备上进行并行处理。 可以从<a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-math-libraries/" rel="nofollow">这个页面</a>下载。 本章使用 Windows 32/64 位的 1.1 BLAS 版本，并且可以在以下屏幕截图（左侧）中看到安装进度。</p> </li><li> <p><strong>OpenCL FFT</strong>：<strong>快速傅立叶变换</strong>（<strong>FFT</strong>）是许多图像处理算法需要的非常有用的功能。 因此，此功能可在 AMD 设备上实现并行处理。 可以从与前面相同的 URL 下载。 本章使用 Windows 32/64 位的 1.1 FFT 版本，并且可以在以下屏幕截图（右侧）中看到安装进度：</p> <p><img src="https://images2.imgbox.com/33/e9/MeJXwXa2_o.png" alt="OpenCV with the OpenCL installation"></p> <p>为 OpenCL 安装 BLAS 和 FFT</p> </li><li> <p><strong>用于 C++ 编译器的 Qt 库</strong>：在本章中，使用 Qt 库的 MinGW 二进制文件通过 OpenCL 编译 OpenCV。 另一种选择是安装最新版本的 Qt 并使用 Visual C++ 编译器。 您可以选择 Qt 版本和使用的编译器。 通过位于<code>C:\Qt\Qt5.3.1</code>的<code>MaintenanceTool.exe</code>应用，包管理器可用于下载其他 Qt 版本。 本章使用 Qt（5.3.1）和 MinGW（4.8.2）32 位来使用 OpenCL 编译 OpenCV。</p> </li></ul> 
<p>当满足之前的要求时，您可以使用 CMake 生成新的构建配置。 该过程与第一章中介绍的典型安装在某些方面有所不同。 差异在此列表中说明：</p> 
<ul><li> <p>为项目选择生成器时，可以选择与计算机中已安装环境相对应的编译器版本。 本章使用 MinGW 使用 OpenCL 编译 OpenCV，然后选择<code>MinGW Makefiles</code>选项，并指定本机编译器。 以下屏幕截图显示了此选择：</p> <p><img src="https://images2.imgbox.com/af/1c/26iPzCld_o.png" alt="OpenCV with the OpenCL installation"></p> <p>CMake 选择生成器项目</p> </li><li> <p>以下屏幕截图中显示的选项是构建带有 OpenCL 项目的 OpenCV 所必需的。 必须启用<code>WITH_OPENCL</code>，<code>WITH_OPENCLAMDBLAS</code>和<code>WITH_OPENCLAMDFFT</code>选项。 必须在<code>CLAMDBLAS_INCLUDE_DIR</code>，<code>CLAMDBLAS_ROOT_DIR</code>，<code>CLAMDFFT_INCLUDE_DIR</code>和<code>CLAMDFFT_ROOT_DIR</code>上引入 BLAS 和 FFT 路径。 此外，如第 1 章“处理图像和视频文件”中所示，您将需要启用<code>WITH_QT</code>并禁用<code>WITH_IPP</code>选项。 也建议启用<code>BUILD_EXAMPLES</code>。 以下屏幕截图显示了在构建配置中选择的主要选项：</p> <p><img src="https://images2.imgbox.com/7e/c8/hAgFvxCL_o.png" alt="OpenCV with the OpenCL installation"></p> <p>CMake 选择主要选项</p> </li></ul> 
<p>最后，要使用 OpenCL 项目构建 OpenCV，必须编译先前生成的 CMake 项目。 该项目是为 MinGW 生成的，因此，需要 MinGW 编译器来构建此项目。 首先，使用 <strong>Windows 控制台</strong>选择<code>[opencv_build]/</code>文件夹，然后执行以下操作：</p> 
<pre><code class="prism language-cpp"><span class="token punctuation">.</span><span class="token operator">/</span>mingw32<span class="token operator">-</span>make<span class="token punctuation">.</span>exe <span class="token operator">-</span>j <span class="token number">4</span> install
</code></pre> 
<p><code>-j 4</code>参数是我们要用于编译并行化的系统核心 CPU 的数量。</p> 
<p>现在可以使用带有 OpenCL 项目的 OpenCV。 新二进制文件的路径必须添加到系统路径，在这种情况下为<code>[opencv_build]/install/x64/mingw/bin</code>。</p> 
<h4><a id="_436"></a>注意</h4> 
<p>不要忘记从路径环境变量中删除旧的 OpenCV 二进制文件。</p> 
<h3><a id="_OpenCL__OpenCV__440"></a>使用 OpenCL 安装 OpenCV 的快速方法</h3> 
<p>可以通过以下步骤总结安装过程：</p> 
<ol><li>下载并安装 AMD APP SDK，该软件可从<a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-app-sdk" rel="nofollow">这个页面</a>获得。</li><li>下载并安装 BLAS 和 FFT AMD，它们可从<a href="http://developer.amd.com/tools-and-sdks/opencl-zone/amd-accelerated-parallel-processing-math-libraries" rel="nofollow">这个页面</a>。</li><li>使用 CMake 配置 OpenCV 构建。 启用 <code>WITH_OPENCL</code> ， <code>WITH_OPENCLAMDBLAS，WITH_QT</code> 和 <code>Build_EXAMPLESWITH_OPENCLAMDFFT</code> 选项。 禁用 <code>WITH_IPP</code> 选项。 最后，介绍 <code>CLAMDBLAS_INCLUDE_DIR</code> ， <code>CLAMDBLAS_ROOT_DIR</code> ， <code>CLAMDFFT_INCLUDE_DIR</code> 和 <code>CLAMDFFT_ROOT_DIR</code> 上的 BLAS 和 FFT 路径。</li><li>用<code>mingw32-make.exe</code>编译 OpenCV 项目。</li><li>最后，修改路径环境变量以更新 OpenCV <code>bin</code>目录（例如<code>[opencv_build]/install/x64/mingw/bin</code>）。</li></ol> 
<h3><a id="_GPU__450"></a>检查 GPU 使用情况</h3> 
<p>在 Windows 平台上使用 GPU 时，没有应用可以测量其使用情况。 使用 GPU 的原因有两个：</p> 
<ul><li>可以知道您是否正确使用了 GPU</li><li>您可以监控 GPU 使用率</li></ul> 
<p>为此，市场上有一些应用。 本章使用 <strong>AMD 系统监视器</strong>检查 GPU 的使用情况。 此应用监视 CPU，内存 RAM 和 GPU 的使用情况。 请参考以下屏幕截图：</p> 
<p><img src="https://images2.imgbox.com/57/a9/2mNuekNV_o.png" alt="Check the GPU usage"></p> 
<p>AMD 系统监视器可监视 CPU，GPU 和内存 RAM 的使用情况</p> 
<h4><a id="_463"></a>注意</h4> 
<p>可以从<a href="http://support.amd.com/es-xl/kb-articles/Pages/AMDSystemMonitor.aspx" rel="nofollow">这个页面</a>下载 Microsoft System Monitor （32 或 64 位）。</p> 
<h2><a id="_467"></a>加速您自己的功能</h2> 
<p>在本节中，有使用 OpenCV 和 OpenCL 的三个示例。 第一个示例使您可以检查已安装的 SDK 是否可用，并获取有关支持 OpenCL 的计算设备的有用信息。 第二个示例分别显示使用 CPU 和 GPU 编程的同一程序的两个版本。 最后一个示例是检测和标记人脸的完整程序。 另外，执行计算比较。</p> 
<h3><a id="_OpenCL_471"></a>检查您的 OpenCL</h3> 
<p>以下是一个简单的程序，用于检查您的 SDK 和可用的计算设备。 该示例是，称为<code>checkOpenCL</code>。它允许您使用 OpenCV 的 OCL 模块显示计算机设备：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/opencv.hpp&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/core/ocl.hpp&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> cv<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> cv<span class="token double-colon punctuation">::</span>ocl<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
vector<span class="token operator">&lt;</span>ocl<span class="token double-colon punctuation">::</span>PlatformInfo<span class="token operator">&gt;</span> info<span class="token punctuation">;</span>
 <span class="token function">getPlatfomsInfo</span><span class="token punctuation">(</span>info<span class="token punctuation">)</span><span class="token punctuation">;</span>
PlatformInfo sdk <span class="token operator">=</span> info<span class="token punctuation">.</span><span class="token function">at</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>sdk<span class="token punctuation">.</span><span class="token function">deviceNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"******SDK*******"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Name: "</span> <span class="token operator">&lt;&lt;</span>sdk<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Vendor: "</span> <span class="token operator">&lt;&lt;</span>sdk<span class="token punctuation">.</span><span class="token function">vendor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Version: "</span> <span class="token operator">&lt;&lt;</span>sdk<span class="token punctuation">.</span><span class="token function">version</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Number of devices: "</span> <span class="token operator">&lt;&lt;</span>sdk<span class="token punctuation">.</span><span class="token function">deviceNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>sdk<span class="token punctuation">.</span><span class="token function">deviceNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
Device device<span class="token punctuation">;</span>
 sdk<span class="token punctuation">.</span><span class="token function">getDevice</span><span class="token punctuation">(</span>device<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
          cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n\n*********************\n Device "</span> <span class="token operator">&lt;&lt;</span> i<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Vendor ID: "</span> <span class="token operator">&lt;&lt;</span>device<span class="token punctuation">.</span><span class="token function">vendorID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Vendor name: "</span> <span class="token operator">&lt;&lt;</span>device<span class="token punctuation">.</span><span class="token function">vendorName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Name: "</span> <span class="token operator">&lt;&lt;</span>device<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Driver version: "</span> <span class="token operator">&lt;&lt;</span>device<span class="token punctuation">.</span><span class="token function">driverVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>device<span class="token punctuation">.</span><span class="token function">isAMD</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Is an AMD device"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>device<span class="token punctuation">.</span><span class="token function">isIntel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Is a Intel device"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Global Memory size: "</span> <span class="token operator">&lt;&lt;</span>device<span class="token punctuation">.</span><span class="token function">globalMemSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Memory cache size: "</span> <span class="token operator">&lt;&lt;</span>device<span class="token punctuation">.</span><span class="token function">globalMemCacheSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Memory cache type: "</span> <span class="token operator">&lt;&lt;</span>device<span class="token punctuation">.</span><span class="token function">globalMemCacheType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Local Memory size: "</span> <span class="token operator">&lt;&lt;</span>device<span class="token punctuation">.</span><span class="token function">localMemSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Local Memory type: "</span> <span class="token operator">&lt;&lt;</span>device<span class="token punctuation">.</span><span class="token function">localMemType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Max Clock frequency: "</span> <span class="token operator">&lt;&lt;</span>device<span class="token punctuation">.</span><span class="token function">maxClockFrequency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_521"></a>代码说明</h4> 
<p>本示例显示安装的 SDK 和与 OpenCL 兼容的可用计算设备。 首先，包含<code>core/ocl.hpp</code>标头，并声明<code>cv::ocl</code>命名空间。</p> 
<p>使用<code>getPlatfomsInfo(info)</code>方法获取有关计算机中可用 SDK 的信息。 该信息存储在<code>vector&lt;ocl::PlatformInfo&gt; info</code>向量中，并通过<code>PlatformInfo sdk = info.at(0)</code>选择。 然后，将显示有关您的 SDK 的主要信息，例如名称，供应商，SDK 版本以及与 OpenCL 兼容的计算设备的数量。</p> 
<p>最后，对于每个兼容设备，其信息都是通过<code>sdk.getDevice(device, i)</code>方法获得的。 现在可以显示有关每个计算设备的不同信息，例如供应商 ID，供应商名称，驱动程序版本，全局内存大小，内存缓存大小等。</p> 
<p>下面的屏幕截图显示了该示例对所用计算机的结果：</p> 
<p><img src="https://images2.imgbox.com/04/8a/x93IVX8u_o.png" alt="The code explanation"></p> 
<p>有关使用的 SDK 和兼容的计算设备的信息</p> 
<h3><a id="_GPU__535"></a>您的第一个基于 GPU 的程序</h3> 
<p>在下面的代码中，显示了同一程序的两个版本：一个仅使用 CPU（本机）执行计算，另一个使用 GPU（带有 OpenCL）。 这两个示例分别称为<code>calculateEdgesCPU</code>和<code>calculateEdgesGPU</code>，使您可以观察 CPU 和 GPU 版本之间的差异。</p> 
<p>首先显示<strong>计算边缘 CPU</strong> 示例：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/opencv.hpp&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> cv<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"./calculateEdgesCPU &lt;image&gt;"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

Mat cpuFrame <span class="token operator">=</span> <span class="token function">imread</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Mat cpuBW<span class="token punctuation">,</span> cpuBlur<span class="token punctuation">,</span> cpuEdges<span class="token punctuation">;</span>

    <span class="token function">namedWindow</span><span class="token punctuation">(</span><span class="token string">"Canny Edges CPU"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">cvtColor</span><span class="token punctuation">(</span>cpuFrame<span class="token punctuation">,</span> cpuBW<span class="token punctuation">,</span> COLOR_BGR2GRAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">GaussianBlur</span><span class="token punctuation">(</span>cpuBW<span class="token punctuation">,</span> cpuBlur<span class="token punctuation">,</span> <span class="token function">Size</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">Canny</span><span class="token punctuation">(</span>cpuBlur<span class="token punctuation">,</span> cpuEdges<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"Canny Edges CPU"</span><span class="token punctuation">,</span> cpuEdges<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">waitKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>现在，显示<strong>计算边缘 GPU</strong> 示例：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"opencv2/opencv.hpp"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"opencv2/core/ocl.hpp"</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> cv<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> cv<span class="token double-colon punctuation">::</span>ocl<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"./calculateEdgesGPU &lt;image&gt;"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token function">setUseOpenCL</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Mat cpuFrame <span class="token operator">=</span> <span class="token function">imread</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
UMat gpuFrame<span class="token punctuation">,</span> gpuBW<span class="token punctuation">,</span> gpuBlur<span class="token punctuation">,</span> gpuEdges<span class="token punctuation">;</span>

cpuFrame<span class="token punctuation">.</span><span class="token function">copyTo</span><span class="token punctuation">(</span>gpuFrame<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">namedWindow</span><span class="token punctuation">(</span><span class="token string">"Canny Edges GPU"</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">cvtColor</span><span class="token punctuation">(</span>gpuFrame<span class="token punctuation">,</span> gpuBW<span class="token punctuation">,</span> COLOR_BGR2GRAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">GaussianBlur</span><span class="token punctuation">(</span>gpuBW<span class="token punctuation">,</span> gpuBlur<span class="token punctuation">,</span> <span class="token function">Size</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">1.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">Canny</span><span class="token punctuation">(</span>gpuBlur<span class="token punctuation">,</span> gpuEdges<span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"Canny Edges GPU"</span><span class="token punctuation">,</span> gpuEdges<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">waitKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_609"></a>代码说明</h4> 
<p>这两个示例获得相同的结果，如以下屏幕截图所示。 他们从标准命令行输入参数读取图像。 然后，将图像转换为灰度，并应用高斯模糊和 Canny 过滤器功能。</p> 
<p>在第二个示例中，使用 GPU 需要一些区别。 首先，必须使用<code>setUseOpenCL(true)</code>方法激活 OpenCL。 其次，<strong>统一矩阵</strong>（<code>UMat</code>）用于在 GPU（<code>UMat gpuFrame, gpuBW, gpuBlur, gpuEdges</code>）中分配内存。 第三，使用<code>cpuFrame.copyTo(gpuFrame)</code>方法将输入图像从 RAM 复制到 GPU 内存。 现在，使用这些功能时，如果它们具有 OpenCL 实现，则这些功能将在 GPU 上执行。 如果其中一些功能没有 OpenCL 实现，则正常功能将在 CPU 上执行。 在此示例中，使用 GPU 编程（第二示例）的时间要好 10 倍：</p> 
<p><img src="https://images2.imgbox.com/87/dc/XC8RY6Rn_o.png" alt="The code explanation"></p> 
<p>前两个示例的结果</p> 
<h3><a id="_619"></a>实时</h3> 
<p>GPU 处理的主要优点之一是以更快的方式执行计算。 速度的提高使您可以在实时应用中执行繁重的计算算法，例如立体视觉，行人检测，光流或人脸检测。 以下<code>detectFaces</code>示例向您展示了一种用于检测摄像机面部的应用。 此示例还允许您在 <strong>CPU</strong> 或 <strong>GPU 处理</strong>之间进行选择，以比较计算时间。</p> 
<p>在 OpenCV 示例（<code>[opencv_source_code]/samples/cpp/facedetect.cpp</code>）中，可以找到相关的人脸检测器示例。 对于以下<code>detectFaces</code>示例，<code>detectFace.pro</code>项目需要以下库：<code>-lopencv_core300</code>，<code>-opencv_imgproc300</code>，<code>-lopencv_highgui300</code>，<code>-lopencv_videoio300</code>和<code>lopencv_objdetct300</code>。</p> 
<p><code>detectFaces</code>示例使用 OpenCV 的<code>ocl</code>模块：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/core/core.hpp&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/core/ocl.hpp&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/objdetect.hpp&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/videoio.hpp&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/highgui.hpp&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;opencv2/imgproc.hpp&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> cv<span class="token punctuation">;</span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> cv<span class="token double-colon punctuation">::</span>ocl<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 1- Set the initial parameters</span>
    <span class="token comment">// Vector to store the faces</span>
    vector<span class="token operator">&lt;</span>Rect<span class="token operator">&gt;</span> faces<span class="token punctuation">;</span>
    CascadeClassifier face_cascade<span class="token punctuation">;</span>
String face_cascade_name <span class="token operator">=</span> argv<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> face_size <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>
    <span class="token keyword">double</span> scale_factor <span class="token operator">=</span> <span class="token number">1.1</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> min_neighbours <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

VideoCapture <span class="token function">cap</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
UMat frame<span class="token punctuation">,</span> frameGray<span class="token punctuation">;</span>
    <span class="token keyword">bool</span> finish <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">// 2- Load the file xml to use the classifier</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>face_cascade<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>face_cascade_name<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Cannot load the face xml!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">namedWindow</span><span class="token punctuation">(</span><span class="token string">"Video Capture"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 3- Select between the CPU or GPU processing</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
          cout <span class="token operator">&lt;&lt;</span> <span class="token string">"./detectFaces [CPU/GPU | C/G]"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
          cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Trying to use GPU..."</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token function">setUseOpenCL</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">"./detectFaces trying to use "</span> <span class="token operator">&lt;&lt;</span> argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token char">'C'</span><span class="token punctuation">)</span>
            <span class="token comment">// Trying to use the CPU processing</span>
            <span class="token function">setUseOpenCL</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span>
            <span class="token comment">// Trying to use the GPU processing</span>
            <span class="token function">setUseOpenCL</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    Rect r<span class="token punctuation">;</span>
 <span class="token keyword">double</span> start_time<span class="token punctuation">,</span> finish_time<span class="token punctuation">,</span> start_total_time<span class="token punctuation">,</span>       finish_total_time<span class="token punctuation">;</span>
    <span class="token keyword">int</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">// 4- Detect the faces for each image capture</span>
    start_total_time <span class="token operator">=</span> <span class="token function">getTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>finish<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        start_time <span class="token operator">=</span> <span class="token function">getTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cap <span class="token operator">&gt;&gt;</span> frame<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>frame<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            cout <span class="token operator">&lt;&lt;</span> <span class="token string">"No capture frame --&gt; finish"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

<span class="token function">cvtColor</span><span class="token punctuation">(</span>frame<span class="token punctuation">,</span> frameGray<span class="token punctuation">,</span> COLOR_BGR2GRAY<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">equalizeHist</span><span class="token punctuation">(</span>frameGray<span class="token punctuation">,</span>frameGray<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Detect the faces</span>
face_cascade<span class="token punctuation">.</span><span class="token function">detectMultiScale</span><span class="token punctuation">(</span>frameGray<span class="token punctuation">,</span> faces<span class="token punctuation">,</span> scale_factor<span class="token punctuation">,</span> min_neighbours<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">|</span>CASCADE_SCALE_IMAGE<span class="token punctuation">,</span> <span class="token function">Size</span><span class="token punctuation">(</span>face_size<span class="token punctuation">,</span>face_size<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// For each detected face</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> f <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> f <span class="token operator">&lt;</span>faces<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> f<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            r <span class="token operator">=</span> faces<span class="token punctuation">[</span>f<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token comment">// Draw a rectangle over the face</span>
<span class="token function">rectangle</span><span class="token punctuation">(</span>frame<span class="token punctuation">,</span> <span class="token function">Point</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>x<span class="token punctuation">,</span> r<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Point</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>x <span class="token operator">+</span> r<span class="token punctuation">.</span>width<span class="token punctuation">,</span> r<span class="token punctuation">.</span>y <span class="token operator">+</span> r<span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Scalar</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">255</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// Show the results</span>
<span class="token function">imshow</span><span class="token punctuation">(</span><span class="token string">"Video Capture"</span><span class="token punctuation">,</span>frame<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Calculate the time processing</span>
        finish_time <span class="token operator">=</span> <span class="token function">getTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Time per frame: "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>finish_time <span class="token operator">-</span> start_time<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">getTickFrequency</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" secs"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

        counter<span class="token operator">++</span><span class="token punctuation">;</span>

        <span class="token comment">// Press Esc key to finish</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">waitKey</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">27</span><span class="token punctuation">)</span> finish <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    finish_total_time <span class="token operator">=</span> <span class="token function">getTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Average time per frame: "</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>finish_total_time <span class="token operator">-</span> start_total_time<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">getTickFrequency</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span>counter <span class="token operator">&lt;&lt;</span> <span class="token string">" secs"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="_734"></a>代码说明</h4> 
<p>第一步，设置初始参数，例如使用分类器检测面部的 xml 文件（<code>String face_cascade_name argv[2]</code>），每个检测到的面部的最小尺寸（<code>face_size=30</code>），比例因子（<code>scale_factor = 1.1</code> ），以及在真正例和假正面检测之间进行权衡的最小邻居数（<code>min_neighbours = 2</code>）。 您还可以看到 CPU 和 GPU 源代码之间更重要的区别。 您只需要使用<strong>统一矩阵</strong>（<code>UMat frame, frameGray</code>）。</p> 
<h4><a id="_738"></a>注意</h4> 
<p><code>[opencv_source_code]/data/haarcascades/</code>文件夹中还有其他可用的 xml 文件，用于检测不同的身体部位，例如眼睛，下半身，微笑等。</p> 
<p>第二步，使用前面的 xml 文件创建检测器以检测面部。 该检测器基于<strong>基于 Haar 特征的分类器</strong>，这是 Paul Viola 和 Michael Jones 提出的一种有效的对象检测方法。 该分类器具有高精度的人脸检测。 此步骤使用<code>face_cascade.load( face_cascade_name)</code>方法加载 xml 文件。</p> 
<h4><a id="_744"></a>注意</h4> 
<p>您可以在<a href="http://en.wikipedia.org/wiki/Viola%E2%80%93Jones_object_detection_framework" rel="nofollow">这个页面</a>上找到有关 Paul Viola 和 Michael Jones 方法的更多详细信息。</p> 
<p>第三步，您可以在 CPU 或 GPU 处理（分别为<code>setUseOpenCL(false)</code>或<code>setUseOpenCL(true)</code>）之间进行选择。 本示例使用标准命令行输入参数（<code>argv[1]</code>）进行选择。 用户可以从 Windows 控制台执行以下操作，以分别在 CPU 或 GPU 处理以及分类器路径之间进行选择：</p> 
<pre><code class="prism language-cpp"><span class="token operator">&lt;</span>bin_dir<span class="token operator">&gt;</span><span class="token operator">/</span>detectFaces CPU pathClassifier
<span class="token operator">&lt;</span>bin_dir<span class="token operator">&gt;</span><span class="token operator">/</span>detectFaces GPU pathClassifier
</code></pre> 
<p>如果用户未引入输入参数，则使用 GPU 处理。</p> 
<p>第四步为从摄像机捕获的每个图像检测面部。 在此之前，每个捕获的图像都将转换为灰度（<code>cvtColor(frame, frameGray, COLOR_BGR2GRAY)</code>）并对其直方图进行均衡（<code>equalizeHist(frameGray, frameGray)</code>）。 然后，使用创建的人脸检测器，使用<code>face_cascade.detectMultiScale(frameGray, faces, scale_factor, min_neighbours, 0|CASCADE_SCALE_IMAGE, Size(face_size,face_size))</code>多尺度检测方法在当前帧中搜索不同的面部。 最后，在每个检测到的面部上绘制一个绿色矩形，然后将其显示。 以下屏幕截图显示了此示例运行的屏幕截图：</p> 
<p><img src="https://images2.imgbox.com/8a/51/y7ZMwjtE_o.png" alt="The code explanation"></p> 
<p>前面的例子检测人脸</p> 
<h4><a id="_763"></a>性能</h4> 
<p>在前面的示例中，计算了计算时间以比较 CPU 和 GPU 处理。 获得每帧的平均处理时间。</p> 
<p>选择 GPU 编程的一大优势是性能。 因此，前面的示例计算时间测量值，以比较相对于 CPU 版本获得的加速比。 时间使用<code>getTickCount()</code>方法存储在程序的开头。 之后，在程序结束时，再次使用相同的函数来估计时间。 存储计数器以也知道迭代次数。 最后，计算每帧的平均处理时间。 前面的示例使用 GPU 时每帧的平均处理时间为 0.057 秒（或 17.5 FPS），而使用 CPU 的相同示例时，每帧的平均处理时间为每帧 0.335 秒（或 2.9 FPS）。 总之，速度增量为<code>6x</code>。 此增量非常重要，尤其是当您只需要更改几行代码时。 但是，有可能实现更高的速度增加速率，这与问题甚至内核的设计有关。</p> 
<h2><a id="_769"></a>总结</h2> 
<p>在本章中，您学习了如何在计算机上安装带有 OpenCL 的 OpenCV 以及如何使用与 OpenCL 兼容的最新 OpenCV 版本的计算机设备开发应用。</p> 
<p>第一部分说明 OpenCL 是什么以及可用的 SDK。 请记住，取决于您的计算设备，您将需要特定的 SDK 才能与 OpenCL 一起正常使用。 在第二部分中，说明了使用 OpenCL 安装 OpenCV 的安装过程，并使用了 AMD APP SDK。 在上一节中，有三个使用 GPU 编程的示例（第二个示例也具有 CPU 版本以便进行比较）。 此外，在最后一节中，在 CPU 和 GPU 处理之间进行了计算比较，显示 GPU 比 CPU 版本快六倍。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7595cd5fab446e3140ef688eaca70ddc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Numpy 数组的合并</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/86cd1ee746afe1d6d2ea1d4141cb8b8c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于DeepSpeed训练ChatGPT</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>