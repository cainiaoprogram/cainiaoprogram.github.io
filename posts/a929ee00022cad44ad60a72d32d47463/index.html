<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>谷粒商城笔记&#43;踩坑（2）——分布式组件、前端基础，nacos&#43;feign&#43;gateway&#43;ES6&#43;vue脚手架 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="谷粒商城笔记&#43;踩坑（2）——分布式组件、前端基础，nacos&#43;feign&#43;gateway&#43;ES6&#43;vue脚手架" />
<meta property="og:description" content="导航：
谷粒商城笔记&#43;踩坑汇总篇_谷粒商城笔记踩坑6_vincewm的博客-CSDN博客
目录
4、分布式组件
4.0. 简介
4.0.1、SpringCloud 对比SpringCloud Alibaba
4.0.2、项目技术搭配方案选择
4.0.3、common模块引入SpringCloud Alibaba依赖管理
4.1 nacos下载、启动、配置
4.1.1、nacos下载安装
4.1.2、配置nacos注册中心
4.1.3、启动gulimall-xxx, 查看服务注册中心
4.2. openfegin远程调用，案例演示
4.2.0、需求，member调用coupon
4.2.1、common模块引入openfegin依赖
4.2.2、 coupon的controller编写测试方法
4.2.3、member的引导类注解@EnableFeignClients
4.2.4、member模块编写coupon的客户端
4.2.5、member模块注入coupon的客户端 4.3. nacos用作配置中心
4.3.1、依赖 nacos-config,bootstrap
4.3.2、coupons模块创建bootstrap.yml
4.3.3、nacos服务端添加配置文件
4.3.4、coupon的controller中编写测试代码
4.3.5、启动测试
4.3.6、配置热更新，controller注解@RefreshScope动态刷新
4.3.7、命名空间
4.3.8、根据服务创建命名空间，各命名空间根据环境分组
4.3.9、按类型抽取配置，加载多配置集 4.4. 网关gateway
4.4.0、简介 4.4.1、gulimall父工程下新建gulimall-gateway模块作为网关
4.4.2、演示，网关路由到百度
5、前端基础（回顾，与项目无关）
5.1. ES6基础
5.1.1、let &amp; const
5.1.2、解构表达式
5.1.3、函数优化
5.1.4、对象优化
5.1.5、map和reduce
5.1.6、promise
5.1.7、模块化
5.2. VUE基础
5.2.1、VUE安装
5.2.2、v-model, v-on
5.2.3、v-text、v-html、v-ref
5.2.4、单向绑定v-bind:
5.2.5、双向绑定v-model
5.2.6、v-on事件
5.2.7、v-for遍历
5.2.8、v-if和v-show
5.2.9、v-else和v-else-if
5.2.10、计算属性和监听器" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a929ee00022cad44ad60a72d32d47463/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-20T19:38:51+08:00" />
<meta property="article:modified_time" content="2023-07-20T19:38:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">谷粒商城笔记&#43;踩坑（2）——分布式组件、前端基础，nacos&#43;feign&#43;gateway&#43;ES6&#43;vue脚手架</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p><strong>  导航：</strong></p> 
 <p><a href="https://blog.csdn.net/qq_40991313/article/details/127099139?spm=1001.2014.3001.5501" title="谷粒商城笔记+踩坑汇总篇_谷粒商城笔记踩坑6_vincewm的博客-CSDN博客">谷粒商城笔记+踩坑汇总篇_谷粒商城笔记踩坑6_vincewm的博客-CSDN博客</a></p> 
</blockquote> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%9B%9B%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6" rel="nofollow">4、分布式组件</a></p> 
<p id="4.0.%20%E7%AE%80%E4%BB%8B-toc" style="margin-left:40px;"><a href="#4.0.%20%E7%AE%80%E4%BB%8B" rel="nofollow">4.0. 简介</a></p> 
<p id="4.0.1%E3%80%81SpringCloud%20%E5%AF%B9%E6%AF%94SpringCloud%20Alibaba-toc" style="margin-left:80px;"><a href="#4.0.1%E3%80%81SpringCloud%20%E5%AF%B9%E6%AF%94SpringCloud%20Alibaba" rel="nofollow">4.0.1、SpringCloud 对比SpringCloud Alibaba</a></p> 
<p id="4.0.2%E3%80%81%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E6%90%AD%E9%85%8D%E6%96%B9%E6%A1%88-toc" style="margin-left:80px;"><a href="#4.0.2%E3%80%81%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E6%90%AD%E9%85%8D%E6%96%B9%E6%A1%88" rel="nofollow">4.0.2、项目技术搭配方案选择</a></p> 
<p id="4.0.3%E3%80%81common%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5SpringCloud%20Alibaba%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86-toc" style="margin-left:80px;"><a href="#4.0.3%E3%80%81common%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5SpringCloud%20Alibaba%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86" rel="nofollow">4.0.3、common模块引入SpringCloud Alibaba依赖管理</a></p> 
<p id="1.%20nacos%E7%94%A8%E4%BD%9C%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-toc" style="margin-left:40px;"><a href="#1.%20nacos%E7%94%A8%E4%BD%9C%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83" rel="nofollow">4.1 nacos下载、启动、配置</a></p> 
<p id="4.1.1%E3%80%81nacos%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85-toc" style="margin-left:80px;"><a href="#4.1.1%E3%80%81nacos%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85" rel="nofollow">4.1.1、nacos下载安装</a></p> 
<p id="4.1%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B.2%E3%80%81%E9%85%8D%E7%BD%AEnacos-toc" style="margin-left:80px;"><a href="#4.1%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B.2%E3%80%81%E9%85%8D%E7%BD%AEnacos" rel="nofollow">4.1.2、配置nacos注册中心</a></p> 
<p id="4.1%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B.3%E3%80%81%E5%90%AF%E5%8A%A8gulimall-xxx%2C%20%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83-toc" style="margin-left:80px;"><a href="#4.1%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B.3%E3%80%81%E5%90%AF%E5%8A%A8gulimall-xxx%2C%20%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83" rel="nofollow">4.1.3、启动gulimall-xxx, 查看服务注册中心</a></p> 
<p id="2.%20openfegin%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8-toc" style="margin-left:40px;"><a href="#2.%20openfegin%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8" rel="nofollow">4.2. openfegin远程调用，案例演示</a></p> 
<p id="4.2.0%E3%80%81%E9%9C%80%E6%B1%82%EF%BC%8Cmember%E8%B0%83%E7%94%A8coupon-toc" style="margin-left:80px;"><a href="#4.2.0%E3%80%81%E9%9C%80%E6%B1%82%EF%BC%8Cmember%E8%B0%83%E7%94%A8coupon" rel="nofollow">4.2.0、需求，member调用coupon</a></p> 
<p id="4.2.1%E3%80%81common%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5openfegin%E4%BE%9D%E8%B5%96-toc" style="margin-left:80px;"><a href="#4.2.1%E3%80%81common%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5openfegin%E4%BE%9D%E8%B5%96" rel="nofollow">4.2.1、common模块引入openfegin依赖</a></p> 
<p id="4.2.2%E3%80%81%20coupon%E7%9A%84controller%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95-toc" style="margin-left:80px;"><a href="#4.2.2%E3%80%81%20coupon%E7%9A%84controller%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95" rel="nofollow">4.2.2、 coupon的controller编写测试方法</a></p> 
<p id="4.2.3%E3%80%81member%E7%9A%84%E5%BC%95%E5%AF%BC%E7%B1%BB%E6%B3%A8%E8%A7%A3%40EnableDiscoveryClient-toc" style="margin-left:80px;"><a href="#4.2.3%E3%80%81member%E7%9A%84%E5%BC%95%E5%AF%BC%E7%B1%BB%E6%B3%A8%E8%A7%A3%40EnableDiscoveryClient" rel="nofollow">4.2.3、member的引导类注解@EnableFeignClients</a></p> 
<p id="4.2.4%E3%80%81member%E6%A8%A1%E5%9D%97%E7%BC%96%E5%86%99coupon%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF-toc" style="margin-left:80px;"><a href="#4.2.4%E3%80%81member%E6%A8%A1%E5%9D%97%E7%BC%96%E5%86%99coupon%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF" rel="nofollow">4.2.4、member模块编写coupon的客户端</a></p> 
<p id="4.2.5%E3%80%81member%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%85%A5coupon%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%C2%A0-toc" style="margin-left:80px;"><a href="#4.2.5%E3%80%81member%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%85%A5coupon%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%C2%A0" rel="nofollow">4.2.5、member模块注入coupon的客户端 </a></p> 
<p id="3.%20nacos%E7%94%A8%E4%BD%9C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83-toc" style="margin-left:40px;"><a href="#3.%20nacos%E7%94%A8%E4%BD%9C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83" rel="nofollow">4.3. nacos用作配置中心</a></p> 
<p id="4.3.1%E3%80%81common%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%20nacos-config-toc" style="margin-left:80px;"><a href="#4.3.1%E3%80%81common%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%20nacos-config" rel="nofollow">4.3.1、依赖 nacos-config,bootstrap</a></p> 
<p id="4.3.2%E3%80%81coupons%E6%A8%A1%E5%9D%97%E5%88%9B%E5%BB%BAbootstrap.yml-toc" style="margin-left:80px;"><a href="#4.3.2%E3%80%81coupons%E6%A8%A1%E5%9D%97%E5%88%9B%E5%BB%BAbootstrap.yml" rel="nofollow">4.3.2、coupons模块创建bootstrap.yml</a></p> 
<p id="4.3.3%E3%80%81nacos%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-toc" style="margin-left:80px;"><a href="#4.3.3%E3%80%81nacos%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6" rel="nofollow">4.3.3、nacos服务端添加配置文件</a></p> 
<p id="4.3.4%E3%80%81coupon%E7%9A%84controller%E4%B8%AD%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#4.3.4%E3%80%81coupon%E7%9A%84controller%E4%B8%AD%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81" rel="nofollow">4.3.4、coupon的controller中编写测试代码</a></p> 
<p id="4.3.5%E3%80%81%E5%90%AF%E5%8A%A8%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#4.3.5%E3%80%81%E5%90%AF%E5%8A%A8%E6%B5%8B%E8%AF%95" rel="nofollow">4.3.5、启动测试</a></p> 
<p id="4.3.6%E3%80%81%E9%85%8D%E7%BD%AE%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%8Ccontroller%E6%B3%A8%E8%A7%A3%40RefreshScope%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0-toc" style="margin-left:80px;"><a href="#4.3.6%E3%80%81%E9%85%8D%E7%BD%AE%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%8Ccontroller%E6%B3%A8%E8%A7%A3%40RefreshScope%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0" rel="nofollow">4.3.6、配置热更新，controller注解@RefreshScope动态刷新</a></p> 
<p id="4.3.7%E3%80%81%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-toc" style="margin-left:80px;"><a href="#4.3.7%E3%80%81%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4" rel="nofollow">4.3.7、命名空间</a></p> 
<p id="4.3.8%E3%80%81%E7%BB%88%E6%9E%81%E7%89%88%EF%BC%8C%E6%A0%B9%E6%8D%AE%E6%9C%8D%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%90%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%A0%B9%E6%8D%AE%E7%8E%AF%E5%A2%83%E5%88%86%E7%BB%84-toc" style="margin-left:80px;"><a href="#4.3.8%E3%80%81%E7%BB%88%E6%9E%81%E7%89%88%EF%BC%8C%E6%A0%B9%E6%8D%AE%E6%9C%8D%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%90%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%A0%B9%E6%8D%AE%E7%8E%AF%E5%A2%83%E5%88%86%E7%BB%84" rel="nofollow">4.3.8、根据服务创建命名空间，各命名空间根据环境分组</a></p> 
<p id="4.3.9%E3%80%81%E6%8C%89%E7%B1%BB%E5%9E%8B%E6%8A%BD%E5%8F%96%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%8A%A0%E8%BD%BD%E5%A4%9A%E9%85%8D%E7%BD%AE%E9%9B%86%C2%A0-toc" style="margin-left:80px;"><a href="#4.3.9%E3%80%81%E6%8C%89%E7%B1%BB%E5%9E%8B%E6%8A%BD%E5%8F%96%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%8A%A0%E8%BD%BD%E5%A4%9A%E9%85%8D%E7%BD%AE%E9%9B%86%C2%A0" rel="nofollow">4.3.9、按类型抽取配置，加载多配置集 </a></p> 
<p id="4.%20%E7%BD%91%E5%85%B3gateway-88-toc" style="margin-left:40px;"><a href="#4.%20%E7%BD%91%E5%85%B3gateway-88" rel="nofollow">4.4. 网关gateway</a></p> 
<p id="4.4.0%E3%80%81%E7%AE%80%E4%BB%8B%C2%A0-toc" style="margin-left:80px;"><a href="#4.4.0%E3%80%81%E7%AE%80%E4%BB%8B%C2%A0" rel="nofollow">4.4.0、简介 </a></p> 
<p id="4.4.1%E3%80%81gulimall%E7%88%B6%E5%B7%A5%E7%A8%8B%E4%B8%8B%E6%96%B0%E5%BB%BAgulimall-gateway%E4%BD%9C%E4%B8%BA%E7%BD%91%E5%85%B3-toc" style="margin-left:80px;"><a href="#4.4.1%E3%80%81gulimall%E7%88%B6%E5%B7%A5%E7%A8%8B%E4%B8%8B%E6%96%B0%E5%BB%BAgulimall-gateway%E4%BD%9C%E4%B8%BA%E7%BD%91%E5%85%B3" rel="nofollow">4.4.1、gulimall父工程下新建gulimall-gateway模块作为网关</a></p> 
<p id="4.4.2%E3%80%81%E6%BC%94%E7%A4%BA%EF%BC%8C%E7%BD%91%E5%85%B3%E8%B7%AF%E7%94%B1%E5%88%B0%E7%99%BE%E5%BA%A6-toc" style="margin-left:80px;"><a href="#4.4.2%E3%80%81%E6%BC%94%E7%A4%BA%EF%BC%8C%E7%BD%91%E5%85%B3%E8%B7%AF%E7%94%B1%E5%88%B0%E7%99%BE%E5%BA%A6" rel="nofollow">4.4.2、演示，网关路由到百度</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80" rel="nofollow">5、前端基础（回顾，与项目无关）</a></p> 
<p id="1.%20ES6%E5%9F%BA%E7%A1%80-toc" style="margin-left:40px;"><a href="#1.%20ES6%E5%9F%BA%E7%A1%80" rel="nofollow">5.1. ES6基础</a></p> 
<p id="1%E3%80%81let%20%26%20const-toc" style="margin-left:80px;"><a href="#1%E3%80%81let%20%26%20const" rel="nofollow">5.1.1、let &amp; const</a></p> 
<p id="2%E3%80%81%E8%A7%A3%E6%9E%84%E8%A1%A8%E8%BE%BE%E5%BC%8F-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E8%A7%A3%E6%9E%84%E8%A1%A8%E8%BE%BE%E5%BC%8F" rel="nofollow">5.1.2、解构表达式</a></p> 
<p id="3%E3%80%81%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96" rel="nofollow">5.1.3、函数优化</a></p> 
<p id="4%E3%80%81%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96" rel="nofollow">5.1.4、对象优化</a></p> 
<p id="5%E3%80%81map%E5%92%8Creduce-toc" style="margin-left:80px;"><a href="#5%E3%80%81map%E5%92%8Creduce" rel="nofollow">5.1.5、map和reduce</a></p> 
<p id="6%E3%80%81promise-toc" style="margin-left:80px;"><a href="#6%E3%80%81promise" rel="nofollow">5.1.6、promise</a></p> 
<p id="7%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96-toc" style="margin-left:80px;"><a href="#7%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96" rel="nofollow">5.1.7、模块化</a></p> 
<p id="2.%20VUE%E5%9F%BA%E7%A1%80-toc" style="margin-left:40px;"><a href="#2.%20VUE%E5%9F%BA%E7%A1%80" rel="nofollow">5.2. VUE基础</a></p> 
<p id="1%E3%80%81VUE%E5%AE%89%E8%A3%85-toc" style="margin-left:80px;"><a href="#1%E3%80%81VUE%E5%AE%89%E8%A3%85" rel="nofollow">5.2.1、VUE安装</a></p> 
<p id="2%E3%80%81v-model%2C%20v-on-toc" style="margin-left:80px;"><a href="#2%E3%80%81v-model%2C%20v-on" rel="nofollow">5.2.2、v-model, v-on</a></p> 
<p id="3%E3%80%81v-text%E3%80%81v-html%E3%80%81v-ref-toc" style="margin-left:80px;"><a href="#3%E3%80%81v-text%E3%80%81v-html%E3%80%81v-ref" rel="nofollow">5.2.3、v-text、v-html、v-ref</a></p> 
<p id="4%E3%80%81%E5%8D%95%E5%90%91%E7%BB%91%E5%AE%9Av-bind%3A-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E5%8D%95%E5%90%91%E7%BB%91%E5%AE%9Av-bind%3A" rel="nofollow">5.2.4、单向绑定v-bind:</a></p> 
<p id="5%E3%80%81%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9Av-model-toc" style="margin-left:80px;"><a href="#5%E3%80%81%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9Av-model" rel="nofollow">5.2.5、双向绑定v-model</a></p> 
<p id="6%E3%80%81v-on%E4%BA%8B%E4%BB%B6-toc" style="margin-left:80px;"><a href="#6%E3%80%81v-on%E4%BA%8B%E4%BB%B6" rel="nofollow">5.2.6、v-on事件</a></p> 
<p id="7%E3%80%81v-for%E9%81%8D%E5%8E%86-toc" style="margin-left:80px;"><a href="#7%E3%80%81v-for%E9%81%8D%E5%8E%86" rel="nofollow">5.2.7、v-for遍历</a></p> 
<p id="8%E3%80%81v-if%E5%92%8Cv-show-toc" style="margin-left:80px;"><a href="#8%E3%80%81v-if%E5%92%8Cv-show" rel="nofollow">5.2.8、v-if和v-show</a></p> 
<p id="9%E3%80%81v-else%E5%92%8Cv-else-if-toc" style="margin-left:80px;"><a href="#9%E3%80%81v-else%E5%92%8Cv-else-if" rel="nofollow">5.2.9、v-else和v-else-if</a></p> 
<p id="10%E3%80%81%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8-toc" style="margin-left:80px;"><a href="#10%E3%80%81%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8" rel="nofollow">5.2.10、计算属性和监听器</a></p> 
<p id="11%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8filter-toc" style="margin-left:80px;"><a href="#11%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8filter" rel="nofollow">5.2.11、过滤器filter</a></p> 
<p id="12%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96-toc" style="margin-left:80px;"><a href="#12%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96" rel="nofollow">5.2.12、组件化</a></p> 
<p id="13%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#13%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0" rel="nofollow">5.2.13、生命周期和钩子函数</a></p> 
<p id="3.%20vue-dome-toc" style="margin-left:40px;"><a href="#3.%20vue-dome" rel="nofollow">5.3. vue脚手架进行模块化开发</a></p> 
<p id="1%E3%80%81%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85webpack-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85webpack" rel="nofollow">5.3.1、全局安装webpack</a></p> 
<p id="2%E3%80%81%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85vue%E8%84%9A%E6%89%8B%E6%9E%B6-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85vue%E8%84%9A%E6%89%8B%E6%9E%B6" rel="nofollow">5.3.2、全局安装vue脚手架</a></p> 
<p id="3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96vue%E9%A1%B9%E7%9B%AE-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96vue%E9%A1%B9%E7%9B%AE" rel="nofollow">5.3.3、初始化vue项目</a></p> 
<p id="4%E3%80%81vue%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#4%E3%80%81vue%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84" rel="nofollow">5.3.4、vue项目目录结构</a></p> 
<p id="5.3.5%E3%80%81%E4%BF%AE%E6%94%B9vue%E9%A1%B9%E7%9B%AE-toc" style="margin-left:80px;"><a href="#5.3.5%E3%80%81%E4%BF%AE%E6%94%B9vue%E9%A1%B9%E7%9B%AE" rel="nofollow">5.3.5、分析主页展示逻辑</a></p> 
<p id="5.3.6%E3%80%81%E6%96%B0%E5%BB%BAHello%E7%BB%84%E4%BB%B6%EF%BC%8C%E8%B4%9F%E8%B4%A3%2Fhello%E8%B7%AF%E5%BE%84-toc" style="margin-left:80px;"><a href="#5.3.6%E3%80%81%E6%96%B0%E5%BB%BAHello%E7%BB%84%E4%BB%B6%EF%BC%8C%E8%B4%9F%E8%B4%A3%2Fhello%E8%B7%AF%E5%BE%84" rel="nofollow">5.3.6、新建Hello组件，负责/hello路径</a></p> 
<p id="5.3.6%E3%80%81%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E7%BB%84%E4%BB%B6%E6%A8%A1%E6%9D%BF-toc" style="margin-left:80px;"><a href="#5.3.6%E3%80%81%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E7%BB%84%E4%BB%B6%E6%A8%A1%E6%9D%BF" rel="nofollow">5.3.7、快速生成组件模板</a></p> 
<p id="5.4.%20ElementUI-toc" style="margin-left:40px;"><a href="#5.4.%20ElementUI" rel="nofollow">5.4. ElementUI</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h2 id="%E5%9B%9B%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E7%BB%84%E4%BB%B6">4、分布式组件</h2> 
<blockquote> 
 <p>本节主要用于回顾，主要就<strong>4.4.1网关模块时真实操作一下</strong>就行，其他都是测试。</p> 
</blockquote> 
<h3 id="4.0.%20%E7%AE%80%E4%BB%8B">4.0. 简介</h3> 
<h4 id="4.0.1%E3%80%81SpringCloud%20%E5%AF%B9%E6%AF%94SpringCloud%20Alibaba">4.0.1、<strong>SpringCloud 对比SpringCloud Alibaba</strong></h4> 
<p><strong>springcloud对比SpringCloud Alibaba： </strong></p> 
<p><img alt="" src="https://images2.imgbox.com/1e/71/Gvgfy4b0_o.png"></p> 
<p><strong>企业需求：</strong></p> 
<p><img alt="" height="537" src="https://images2.imgbox.com/4c/62/Pjkun5Rs_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<h4 id="4.0.2%E3%80%81%E9%A1%B9%E7%9B%AE%E6%8A%80%E6%9C%AF%E6%90%AD%E9%85%8D%E6%96%B9%E6%A1%88">4.0.2、项目技术搭配方案选择</h4> 
<p><img alt="" height="280" src="https://images2.imgbox.com/cf/05/vchXjBET_o.png" width="681"></p> 
<p><img alt="" height="545" src="https://images2.imgbox.com/ea/2a/WR6qWMKx_o.png" width="769"></p> 
<p></p> 
<h4 id="4.0.3%E3%80%81common%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5SpringCloud%20Alibaba%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86">4.0.3、common模块引入<strong>SpringCloud Alibaba</strong>依赖管理</h4> 
<p><a href="https://github.com/alibaba/spring-cloud-alibaba/blob/2021.x/README-zh.md" title="spring-cloud-alibaba/README-zh.md at 2021.x · alibaba/spring-cloud-alibaba · GitHub">spring-cloud-alibaba/README-zh.md at 2021.x · alibaba/spring-cloud-alibaba · GitHub</a></p> 
<p>guimall-common模块的pom： </p> 
<div> 
 <pre><code class="language-XML">    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;/artifactId&gt;
                &lt;version&gt;2.1.0.RELEASE&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;</code></pre> 
</div> 
<h3 id="1.%20nacos%E7%94%A8%E4%BD%9C%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83"><a id="1_nacos_10"></a>4.1 nacos下载、启动、配置</h3> 
<h4 id="4.1.1%E3%80%81nacos%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85">4.1.<strong>1、nacos下载安装</strong></h4> 
<ul><li>下载地址：https://github.com/alibaba/nacos/releases</li></ul> 
<p><img alt="image-20210925231418023" src="https://images2.imgbox.com/3a/a9/6Y5womjg_o.png">​</p> 
<p><strong>启动： </strong></p> 
<ul><li>解压后启动nacos：</li></ul> 
<p> 在bin目录下cmd：</p> 
<div> 
 <pre><code class="language-XML">startup.cmd -m standalone</code></pre> 
</div> 
<ul><li>命令运行成功后直接访问http://localhost:8848/nacos，默认账号密码都是nacos</li></ul> 
<p><a href="http://localhost:8848/nacos/index.html" rel="nofollow" title="http://localhost:8848/nacos/index.html">http://localhost:8848/nacos/index.html</a></p> 
<p><img alt="image-20210925231458882" src="https://images2.imgbox.com/7f/1c/jPt8z6PQ_o.png">​</p> 
<h4 id="4.1%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B.2%E3%80%81%E9%85%8D%E7%BD%AEnacos">4.1​​​​​​​.<strong>2、配置nacos注册中心</strong></h4> 
<ul><li> <p><strong> common引入依赖</strong></p> 
  <div> 
   <pre><code class="language-XML">        &lt;dependency&gt;
            &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre> 
  </div> </li></ul> 
<p></p> 
<p></p> 
<ul><li> <p>在<strong>所有子模块gulimall-xxx里yml</strong>里写<strong><code>spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848</code></strong>（指定nacos的地址）。再指定<strong>spring.applicatin.name</strong>告诉注册到nacos中以什么命名</p> 
  <div> 
   <pre><code class="language-bash">spring:
  application:
#注意修改服务名
    name: gulimall-coupon
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
</code></pre> 
  </div> </li><li> <p>在<strong>所有子模块gulimall-xxx引导类</strong>上使用<strong> <code>@EnableDiscoveryClient</code> 注解开启Feign</strong>服务注册与发现功能</p> </li><li> 
  <div> 
   <pre><code class="language-java">@EnableDiscoveryClient
@SpringBootApplication
public class GulimallCouponApplication {
    public static void main(String[] args) {
        SpringApplication.run(GulimallCouponApplication.class, args);
    }
}
</code></pre> 
  </div> </li></ul> 
<h4 id="4.1%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B.3%E3%80%81%E5%90%AF%E5%8A%A8gulimall-xxx%2C%20%E6%9F%A5%E7%9C%8B%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83">4.1​​​​​​​.<strong>3、启动gulimall-xxx, 查看服务注册中心</strong></h4> 
<p></p> 
<p><img alt="" height="584" src="https://images2.imgbox.com/a6/bf/cUpXfDWN_o.png" width="1200">​</p> 
<p></p> 
<h3 id="2.%20openfegin%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8"><a id="2_openfegin_116"></a>4.2. openfegin远程调用，案例演示</h3> 
<p>声明式远程调用</p> 
<p>feign是一个声明式的HTTP客户端，他的目的就是让远程调用更加简单。给远程服务发的是HTTP请求。</p> 
<p>会员服务想要远程调用优惠券服务，只需要给会员服务里引入openfeign依赖，他就有了远程调用其他服务的能力。</p> 
<h4 id="4.2.0%E3%80%81%E9%9C%80%E6%B1%82%EF%BC%8Cmember%E8%B0%83%E7%94%A8coupon">4.2.0<strong>、需求，member调用coupon</strong></h4> 
<p>会员模块通过feign远程调用优惠券模块controller的方法。</p> 
<h4 id="4.2.1%E3%80%81common%E6%A8%A1%E5%9D%97%E5%BC%95%E5%85%A5openfegin%E4%BE%9D%E8%B5%96">4.2.<strong>1、common模块引入</strong>openfegin<strong>依赖</strong></h4> 
<div> 
 <pre><code class="language-XML">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> 
</div> 
<h4 id="4.2.2%E3%80%81%20coupon%E7%9A%84controller%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95">4.2.<strong>2、 coupon的controller编写测试方法</strong></h4> 
<p> 在gulimall-coupon中的<strong>CouponController</strong>中添加<strong>测试方法</strong></p> 
<div> 
 <pre><code class="language-java">    @RequestMapping("/member/list")
    public R membercoupons(){    //全系统的所有返回都返回R
        // 假数据，模拟去数据库查用户对于的优惠券
        CouponEntity couponEntity = new CouponEntity();
        couponEntity.setCouponName("满100-10");//优惠券的名字
        return R.ok().put("coupons",Arrays.asList(couponEntity));
    }
</code></pre> 
</div> 
<blockquote> 
 <p>R 结果类：</p> 
 <div> 
  <pre><code class="language-java">public class R extends HashMap&lt;String, Object&gt; {
	private static final long serialVersionUID = 1L;
	
	public R() {
		put("code", 0);
		put("msg", "success");
	}
	
	public static R error() {
		return error(HttpStatus.SC_INTERNAL_SERVER_ERROR, "未知异常，请联系管理员");
	}
	
	public static R error(String msg) {
		return error(HttpStatus.SC_INTERNAL_SERVER_ERROR, msg);
	}
	
	public static R error(int code, String msg) {
		R r = new R();
		r.put("code", code);
		r.put("msg", msg);
		return r;
	}

	public static R ok(String msg) {
		R r = new R();
		r.put("msg", msg);
		return r;
	}
	
	public static R ok(Map&lt;String, Object&gt; map) {
		R r = new R();
		r.putAll(map);
		return r;
	}
	
	public static R ok() {
		return new R();
	}

	public R put(String key, Object value) {
		super.put(key, value);
		return this;
	}
}
</code></pre> 
 </div> 
 <p></p> 
</blockquote> 
<h4 id="4.2.3%E3%80%81member%E7%9A%84%E5%BC%95%E5%AF%BC%E7%B1%BB%E6%B3%A8%E8%A7%A3%40EnableDiscoveryClient">4.2.3、member的引导类注解<code><strong>@EnableFeignClients</strong></code></h4> 
<p>在<strong>member的主启动类</strong>上加注解@EnableFeignClients<strong>启用<code>feign</code>客户端</strong></p> 
<div> 
 <pre><code class="language-java">@EnableDiscoveryClient
@SpringBootApplication
@EnableFeignClients(basePackages="com.vince.gulimall.member.feign")//扫描接口方法注解
public class GulimallMemberApplication {
    public static void main(String[] args) {
        SpringApplication.run(GulimallMemberApplication.class, args);
    }
}
</code></pre> 
</div> 
<blockquote> 
 <p> @EnableDiscoveryClient是服务的注册发现。</p> 
</blockquote> 
<h4 id="4.2.4%E3%80%81member%E6%A8%A1%E5%9D%97%E7%BC%96%E5%86%99coupon%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF">4.2.4、member模块编写coupon的客户端</h4> 
<p>在<code>com.xmh.gulimall.member.<strong>feign</strong></code>中<strong>新建接口<code>CouponFeignService（或CouponClient）</code></strong></p> 
<div> 
 <pre><code class="language-java">@FeignClient("gulimall-coupon")//告诉spring cloud这个接口是一个远程客户端，要调用coupon服务(nacos中找到)
public interface CouponFeignService{

    // 远程服务的url
    @RequestMapping("/coupon/coupon/member/list")//注意写全优惠券类上还有映射
    public R membercoupons();//得到一个R对象


}
</code></pre> 
</div> 
<h4 id="4.2.5%E3%80%81member%E6%A8%A1%E5%9D%97%E6%B3%A8%E5%85%A5coupon%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%C2%A0">4.2.5、member模块注入coupon的客户端 </h4> 
<p>在member的<strong>MemberController</strong>写一个<strong>测试</strong></p> 
<div> 
 <pre><code class="language-java">    @Autowired
    private CouponFeignService couponFeignService; //注入刚才的CouponFeignService接口

    @RequestMapping("/coupons")
    public R coupons(){
        MemberEntity memberEntity = new MemberEntity();
        memberEntity.setNickname("会员昵称张三");
        R membercoupons = couponFeignService.membercoupons();

        return R.ok().put("member", memberEntity).put("coupons", membercoupons.get("coupons"));
    }
</code></pre> 
</div> 
<p>启动gulimall-me mber，gulimall-coupon项目。<strong>访问http://localhost:8000/member/member/coupons</strong>测试</p> 
<p><img alt="image-20210925232220401" src="https://images2.imgbox.com/74/58/O0DgJ6rQ_o.png">​</p> 
<p>测试成功！</p> 
<h3 id="3.%20nacos%E7%94%A8%E4%BD%9C%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83"><a id="3_nacos_226"></a>4.3. nacos用作配置中心</h3> 
<p><strong>Nacos</strong>一方面可以<strong>将配置集中管理</strong>，另一方面可以在<strong>配置变更时</strong>，及时<strong>通知微服务</strong>，实现<strong>配置的热更新。</strong> </p> 
<h4 id="4.3.1%E3%80%81common%E4%B8%AD%E6%B7%BB%E5%8A%A0%E4%BE%9D%E8%B5%96%20nacos-config">4.3.<strong>1、依赖 nacos-config,bootstrap</strong></h4> 
<p><strong>common中添加依赖</strong></p> 
<div> 
 <pre><code class="language-XML">&lt;dependency&gt;
     &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
     &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;/artifactId&gt;
 &lt;/dependency&gt;
&lt;!--        在SpringBoot 2.4.x的版本之后，对于bootstrap.properties/bootstrap.yaml配置文件(我们合起来成为Bootstrap配置文件)的支持，需要导入如下的依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-bootstrap&lt;/artifactId&gt;
            &lt;version&gt;3.1.4&lt;/version&gt;
        &lt;/dependency&gt;</code></pre> 
</div> 
<h4 id="4.3.2%E3%80%81coupons%E6%A8%A1%E5%9D%97%E5%88%9B%E5%BB%BAbootstrap.yml">4.3.<strong>2、coupons模块创建bootstrap.yml</strong></h4> 
<p><strong>在coupons模块中创建/src/main/resources/bootstrap.yml，优先级别application.properties高</strong></p> 
<blockquote> 
 <p><strong>问题：nacos配置要先于yml，但如果尚未读取yml，又如何得知nacos地址并获取nacos配置呢？</strong></p> 
 <p><strong>答案：</strong>因此spring引入了一种新的配置文件：<strong>bootstrap.yaml</strong>文件，优先级高于application.yml，会在application.yml之前被读取。</p> 
 <p></p> 
</blockquote> 
<div> 
 <pre><code class="language-bash"># 改名字，对应nacos里的配置文件名
spring:
  application:
    name: gulimall-coupon
  cloud:
    nacos:
      config:
        server-addr: 127.0.0.1:8848
        file-extension: yaml # 指定配置文件为yaml格式
</code></pre> 
</div> 
<h4 id="4.3.3%E3%80%81nacos%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B7%BB%E5%8A%A0%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">4.3.<strong>3、nacos服务端</strong>添加配置文件</h4> 
<p><strong>浏览器去nacos里的配置列表，点击＋号，data ID：<code>gulimall-coupon.yaml</code>，配置</strong></p> 
<p><img alt="" src="https://images2.imgbox.com/8a/6b/w4piwWL5_o.png">​ </p> 
<p></p> 
<p><img alt="image-20210925232732790" src="https://images2.imgbox.com/d2/b2/ng8KmDQ8_o.png">​</p> 
<blockquote> 
 <p><img alt="" src="https://images2.imgbox.com/d9/c4/HEC8cDHG_o.png">​ </p> 
 <p>这里分组名称默认DEFAULT_GROUP，我们看服务列表也可以看到所有服务默认都在这个分组：</p> 
 <p><img alt="" height="603" src="https://images2.imgbox.com/9d/5e/iyUBVua2_o.png" width="909">​</p> 
 <p></p> 
</blockquote> 
<h4 id="4.3.4%E3%80%81coupon%E7%9A%84controller%E4%B8%AD%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81">4.3.<strong>4、coupon的controller中编写测试代码</strong></h4> 
<div> 
 <pre><code class="language-java">    @Value("${coupon.user.name}")
    private String name;
    
    @Value("${coupon.user.age}")
    private int age;

    @RequestMapping("/nacos")
    public R nacos(){
        return R.ok().put("name", name).put("age", age);
    }
</code></pre> 
</div> 
<h4 id="4.3.5%E3%80%81%E5%90%AF%E5%8A%A8%E6%B5%8B%E8%AF%95">4.3.<strong>5、启动测试</strong></h4> 
<p><strong>访问http://localhost:7000/coupon/coupon/nacos测试</strong></p> 
<p><img alt="image-20210925233031028" src="https://images2.imgbox.com/f2/89/aE769nr6_o.png">​</p> 
<h4 id="4.3.6%E3%80%81%E9%85%8D%E7%BD%AE%E7%83%AD%E6%9B%B4%E6%96%B0%EF%BC%8Ccontroller%E6%B3%A8%E8%A7%A3%40RefreshScope%E5%8A%A8%E6%80%81%E5%88%B7%E6%96%B0">4.3.<strong>6、配置热更新，controller注解<code>@RefreshScope</code>动态刷新</strong></h4> 
<p><img alt="image-20210925233121327" src="https://images2.imgbox.com/59/de/XWjpGhjb_o.png">​</p> 
<p></p> 
<h4 id="4.3.7%E3%80%81%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4">4.3.7、命名空间</h4> 
<p><img alt="" height="189" src="https://images2.imgbox.com/1e/6a/n4mirwGy_o.png" width="1182">​ </p> 
<p></p> 
<p>命名空间用于将开发测试生产三种<strong>环境</strong>、<strong>或者</strong>各<strong>微服务</strong>之间<strong>配置隔离</strong>。默认命名空间是public：</p> 
<p><img alt="" height="569" src="https://images2.imgbox.com/17/b0/dpLsrILV_o.png" width="1200">​</p> 
<p><strong>不同命名空间设置不同配置： </strong></p> 
<p><img alt="" height="479" src="https://images2.imgbox.com/c0/c9/j4q49qDT_o.png" width="1200">​ </p> 
<p></p> 
<p><strong>指定命名空间： </strong></p> 
<p> <img alt="" height="199" src="https://images2.imgbox.com/8e/c0/bThR8HBx_o.png" width="1057">​</p> 
<h4 id="4.3.8%E3%80%81%E7%BB%88%E6%9E%81%E7%89%88%EF%BC%8C%E6%A0%B9%E6%8D%AE%E6%9C%8D%E5%8A%A1%E5%88%9B%E5%BB%BA%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%EF%BC%8C%E5%90%84%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E6%A0%B9%E6%8D%AE%E7%8E%AF%E5%A2%83%E5%88%86%E7%BB%84">4.3.8、根据服务创建命名空间，各命名空间根据环境分组</h4> 
<p><img alt="" height="41" src="https://images2.imgbox.com/5a/8f/Sbf0SmWQ_o.png" width="830">​</p> 
<p><img alt="" height="508" src="https://images2.imgbox.com/10/48/kKio44dH_o.png" width="1200">​</p> 
<p></p> 
<p><img alt="" height="223" src="https://images2.imgbox.com/25/aa/kJwSbPxz_o.png" width="1031">​ </p> 
<h4 id="4.3.9%E3%80%81%E6%8C%89%E7%B1%BB%E5%9E%8B%E6%8A%BD%E5%8F%96%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%8A%A0%E8%BD%BD%E5%A4%9A%E9%85%8D%E7%BD%AE%E9%9B%86%C2%A0">4.3.9、按类型抽取配置，加载多配置集 </h4> 
<p><img alt="" height="169" src="https://images2.imgbox.com/37/64/h5Ew7Aw7_o.png" width="846">​ </p> 
<blockquote> 
 <p>开发时为了方便可以将配置文件写在项目中，等发布后再抽取到nacos中。 </p> 
</blockquote> 
<p><strong>将datasource相关配置抽取成一个配置</strong>，在coupon命名空间下，分组名为dev（根据环境分组） ：</p> 
<p><img alt="" height="681" src="https://images2.imgbox.com/dc/84/AJzYBXLh_o.png" width="868">​</p> 
<p><strong>使用：</strong></p> 
<p><img alt="" height="296" src="https://images2.imgbox.com/28/24/EPfdWPI4_o.png" width="965">​ </p> 
<p><strong>或者bootstrap.yml </strong></p> 
<pre><code class="language-bash">spring:
  application:
    name: gulimall-coupon
  cloud:
    nacos:
      config:
        server-addr: 127.0.0.1:8848
        file-extension: yaml
        namespace: xxxx
        extension-configs:
          - data-id: datasource.yml
            group: dev
            refresh: true</code></pre> 
<p></p> 
<h3 id="4.%20%E7%BD%91%E5%85%B3gateway-88"><a id="4_gateway88_319"></a>4.4. 网关gateway</h3> 
<h4 id="4.4.0%E3%80%81%E7%AE%80%E4%BB%8B%C2%A0">4.4.0、简介 </h4> 
<p>网关的<strong>核心功能特性</strong>：</p> 
<ul><li><strong>请求路由</strong></li><li><strong>权限控制</strong></li><li><strong>限流</strong></li></ul> 
<p></p> 
<p>动态上下线：发送请求需要知道商品服务的地址，如果商品服务器有123服务器，1号掉线后，还得改，所以需要网关动态地管理，他能从注册中心中实时地感知某个服务上线还是下线。【先通过网关，网关路由到服务提供者】</p> 
<p>拦截：请求也要加上询问权限，看用户有没有权限访问这个请求，也需要网关。</p> 
<p>所以我们使用spring cloud的gateway组件做网关功能。</p> 
<p>网关是请求流量的入口，常用功能包括<strong>路由转发，权限校验，限流控制</strong>等。</p> 
<p>https://spring.io/projects/spring-cloud-gateway</p> 
<p>参考手册：https://cloud.spring.io/spring-cloud-gateway/2.2.x/reference/html/</p> 
<p><strong>三大核心概念：</strong></p> 
<ul><li><strong>Route路由: </strong>The basic building block of the gateway. It is defined by an ID, a destination URI, a collection of predicates断言, and a collection of filters. A route is matched if the aggregate predicate is true.<strong>发一个请求给网关，网关要将请求路由到指定的服务。路由有id，目的地uri，断言的集合，匹配了断言就能到达指定位置，</strong></li><li><strong>Predicate断言: </strong>This is a Java 8 Function Predicate. The input type is a Spring Framework ServerWebExchange. This lets you match on anything from the HTTP request, such as headers or parameters.<strong>就是java里的断言函数，匹配请求里的任何信息，包括请求头等。根据请求头路由哪个服务</strong></li><li><strong>Filter过滤: </strong>These are instances of Spring Framework GatewayFilter that have been constructed with a specific factory. Here, you can modify requests and responses before or after sending the downstream request.<strong>过滤器请求和响应都可以被修改。<br> 客户端发请求给服务端。中间有网关。先交给映射器，如果能处理就交给handler处理，然后交给一系列filer，然后给指定的服务，再返回回来给客户端。</strong></li></ul> 
<p>客户端发请求给服务端。中间有网关。先交给映射器，如果能处理就交给handler处理，然后交给一系列filer，然后给指定的服务，再返回回来给客户端。</p> 
<p><img alt="image-20210925233712996" src="https://images2.imgbox.com/fc/a9/kJfBuJSg_o.png">​</p> 
<h4 id="4.4.1%E3%80%81gulimall%E7%88%B6%E5%B7%A5%E7%A8%8B%E4%B8%8B%E6%96%B0%E5%BB%BAgulimall-gateway%E4%BD%9C%E4%B8%BA%E7%BD%91%E5%85%B3">4.4.<strong>1、gulimall父工程下新建gulimall-gateway模块作为网关</strong></h4> 
<p>新建springboot项目，勾选gateway：</p> 
<p><img alt="" height="446" src="https://images2.imgbox.com/20/e1/EGkAeQ3u_o.png" width="451">​</p> 
<p><img alt="" height="70" src="https://images2.imgbox.com/cf/22/EMIk8ygr_o.png" width="219">​ </p> 
<p>pom导入common模块 </p> 
<div> 
 <pre><code class="language-XML">    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;com.xmh.gulimall&lt;/groupId&gt;
            &lt;artifactId&gt;gulimall-common&lt;/artifactId&gt;
            &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre> 
</div> 
<p>在nacos上新建gateway命名空间</p> 
<p><img alt="" height="381" src="https://images2.imgbox.com/2f/a4/CwKOHhM7_o.png" width="958">​ </p> 
<p>在gateway命名空间下新建配置<code>gulimall-gateway.yml</code>： </p> 
<p><img alt="image-20210925234232602" src="https://images2.imgbox.com/e6/d0/nFbGTNpk_o.png">​</p> 
<p>配置application.yml</p> 
<div> 
 <pre><code class="language-bash">server:
  port: 88
spring:
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
  application:
    name: gulimall-gateway
</code></pre> 
</div> 
<p>配置bootstrap.yml</p> 
<div> 
 <pre><code class="language-java">spring:
  application:
    name: gulimall-gateway
  cloud:
    nacos:
      config:
        server-addr: 127.0.0.1:8848
        file-extension: yaml
        namespace: 改成你自己命名空间id
        #namespace: d717d0ee-7a07-4125-9881-3ef57d696ad3
</code></pre> 
</div> 
<p><strong>引导类注解@EnableDiscoveryClient，并排除数据源配置：</strong></p> 
<blockquote> 
 <p></p> 
 <p><strong>引入mybatisplus依赖​​​​​​​后不配置数据源报错：</strong></p> 
 <p></p> 
 <p><img alt="" height="87" src="https://images2.imgbox.com/ed/92/mKi35v30_o.png" width="1200"></p> 
 <p> 因为引入了common模块的依赖，common里有mybatisplus依赖。<strong>引入了mybatisplus依赖就必须配置数据源项目才能运行，而网关模块没必要配置数据源，所以这里要排除。</strong></p> 
</blockquote> 
<div> 
 <pre><code class="language-java">@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class}) //不用数据源，过滤掉数据源配置
@EnableDiscoveryClient
public class GulimallGatewayApplication {
    public static void main(String[] args) {
        SpringApplication.run(GulimallGatewayApplication.class, args);
    }
}
</code></pre> 
</div> 
<h4 id="4.4.2%E3%80%81%E6%BC%94%E7%A4%BA%EF%BC%8C%E7%BD%91%E5%85%B3%E8%B7%AF%E7%94%B1%E5%88%B0%E7%99%BE%E5%BA%A6">4.4.<strong>2、演示，网关路由到百度</strong></h4> 
<blockquote> 
 <p><strong>需求：访问http://localhost:88?url=baidu 切换到百度， http://localhost:88?url=qq 切换到qq</strong></p> 
</blockquote> 
<p>在网关的application.yml中配置路由</p> 
<div> 
 <pre><code class="language-bash">server:
  port: 88
spring:
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
    gateway:
      routes:
        - id: baidu_route              # 每一个路由的名字，唯一即可
          uri: https://www.baidu.com   # 匹配后提供服务的路由地址
          predicates:                 # 断言规则
            - Query=url,baidu         #如果url参数等于baidu 符合断言，转到uri

        - id: qq_route                  # 每一个路由的名字，唯一即可
          uri: https://www.qq.com   # 匹配后提供服务的路由地址
          predicates: # 断言规则
            - Query=url,qq         #如果url参数等于baidu 符合断言，转到uri

  application:
    name: gulimall-gateway
</code></pre> 
</div> 
<blockquote> 
 <p><strong>断言工厂包括： </strong></p> 
 <table><thead><tr><th><strong>名称</strong></th><th><strong>说明</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td>After</td><td>是某个时间点后的请求</td><td>- After=2037-01-20T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Before</td><td>是某个时间点之前的请求</td><td>- Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</td></tr><tr><td>Between</td><td>是某两个时间点之前的请求</td><td>- Between=2037-01-20T17:42:47.789-07:00[America/Denver], 2037-01-21T17:42:47.789-07:00[America/Denver]</td></tr><tr><td>Cookie</td><td>请求必须包含某些cookie</td><td>- Cookie=chocolate, ch.p</td></tr><tr><td>Header</td><td>请求必须包含某些header</td><td>- Header=X-Request-Id, \d+</td></tr><tr><td>Host</td><td>请求必须是访问某个host（域名）</td><td>- Host=<strong>.somehost.org,</strong>.anotherhost.org</td></tr><tr><td>Method</td><td>请求方式必须是指定方式</td><td>- Method=GET,POST</td></tr><tr><td><strong>Path</strong></td><td><strong>请求路径</strong>必须符合指定规则</td><td><strong>- Path=</strong>/red/{segment},/blue/**</td></tr><tr><td>Query</td><td>请求参数必须包含指定参数</td><td>- Query=name, Jack或者- Query=name</td></tr><tr><td>RemoteAddr</td><td>请求者的ip必须是指定范围</td><td>- RemoteAddr=192.168.1.1/24</td></tr><tr><td>Weight</td><td>权重处理</td><td></td></tr></tbody></table> ​​​​​​​具体网关内容参考： 
 <a href="https://blog.csdn.net/qq_40991313/article/details/126772669?spm=1001.2014.3001.5501" title="SpringCloud基础2——nacos配置、Feign、Gateway_nacos feign配置_vincewm的博客-CSDN博客">SpringCloud基础2——nacos配置、Feign、Gateway_nacos feign配置_vincewm的博客-CSDN博客</a> 
 <p></p> 
</blockquote> 
<p>启动网关，访问http://localhost:88?url=baidu测试，成功！</p> 
<p><img alt="image-20210925234834078" src="https://images2.imgbox.com/43/e9/RDuJdDuY_o.png">​</p> 
<h2 id="%E4%BA%94%E3%80%81%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80"><a id="_502"></a>5、前端基础（回顾，与项目无关）</h2> 
<blockquote> 
 <p>前端基础<strong>了解即可，初级工程师应该提升深度而非广度</strong>，技术停留在<strong>能基本看懂代码</strong>的基础上即可，<strong>建议选择性过一遍即可</strong>，哪个知识点没学过就过哪里。</p> 
 <p><a href="https://blog.csdn.net/qq_40991313/article/details/125909662" title="【黑马Java笔记】JavaWeb基础4——HTML,JavaScript&amp;CSS_vincewm的博客-CSDN博客_java添加输入框">【黑马Java笔记】JavaWeb基础4——HTML,JavaScript&amp;CSS_vincewm的博客-CSDN博客_java添加输入框</a></p> 
 <p><a href="https://blog.csdn.net/qq_40991313/article/details/126186764?spm=1001.2014.3001.5502" title="【黑马Java笔记】JavaWeb基础10——VUE&amp;Element&amp;整合Javaweb的商品管理系统_vincewm的博客-CSDN博客_javaweb商品管理系统">【黑马Java笔记】JavaWeb基础10——VUE&amp;Element&amp;整合Javaweb的商品管理系统_vincewm的博客-CSDN博客_javaweb商品管理系统</a></p> 
</blockquote> 
<h3 id="1.%20ES6%E5%9F%BA%E7%A1%80"><a id="1_ES6_506"></a>5.1. ES6基础</h3> 
<p><img alt="" height="198" src="https://images2.imgbox.com/19/a7/M2p9hV2S_o.png" width="955">​ </p> 
<p><img alt="" height="72" src="https://images2.imgbox.com/a2/93/RTf4UqF4_o.png" width="936">​ </p> 
<p></p> 
<h4 id="1%E3%80%81let%20%26%20const"><a id="1let__const_510"></a>5.1.1、let &amp; const</h4> 
<p>vscode快捷键：<code>！+ 回车</code>生成html模板</p> 
<p><img alt="" height="105" src="https://images2.imgbox.com/14/8c/VjbFSDvg_o.png" width="582">​ </p> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
</div> 
<p>         </p> 
<ul><li><strong>let声明后不能作用于{}外</strong>，var可以</li><li><strong>let只能声明一次</strong>（let a=1;let a=2;报错），var可以声明多次</li><li><strong>var会变量提升</strong>（使用在定义之前，console.log(x);var x = 10;  // undefined），let必须先定义再使用</li><li>const一旦初始化后，不能改变</li></ul> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;script&gt;
        // var 声明的变量往往会越域
        // let 声明的变量有严格局部作用域
        {
            var a = 1;
            let b = 2;
        }
        console.log(a);  // 1
        console.log(b);  // ReferenceError: b is not defined

        // var 可以声明多次
        // let 只能声明一次
        var m = 1
        var m = 2
        let n = 3
        //         let n = 4
        console.log(m)  // 2
        console.log(n)  // Identifier 'n' has already been declared

        // var 会变量提升
        // let 不存在变量提升
        console.log(x);  // undefined
        var x = 10;
        console.log(y);   //报错ReferenceError: y is not defined
        let y = 20;

        // let
        // 1. const声明之后不允许改变
        // 2. 一但声明必须初始化，否则会报错
        const a = 1;
        a = 3; //Uncaught TypeError: Assignment to constant variable.

    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre> 
</div> 
<p>打开Chrome控制台可以查看报错信息。 </p> 
<p></p> 
<h4 id="2%E3%80%81%E8%A7%A3%E6%9E%84%E8%A1%A8%E8%BE%BE%E5%BC%8F"><a id="2_579"></a>5.1.2、解构表达式</h4> 
<ul><li><strong>数组解构（批量赋值）</strong><code>let arr = [1,2,3];</code> <code>let [a,b,c] = arr</code></li><li><strong>对象解构</strong><code>const{name:abc, age, language} = person;console.log(abc);</code> 其中<code>name:abc</code>代表把name改名为abc</li><li><strong>字符串扩展</strong><code>str.startsWith();str.endsWith();str.includes();str.includes()</code></li><li><strong>字符串模板</strong>，``符号，支持一个字符串定义为多行</li></ul> 
<p><img alt="" height="78" src="https://images2.imgbox.com/28/be/cmHqTq8G_o.png" width="394">​</p> 
<p><img alt="" height="63" src="https://images2.imgbox.com/ac/d8/2lAXh7Ve_o.png" width="417">​ </p> 
<p></p> 
<ul><li><strong>占位符功能</strong> ${}，字符串插入变量</li></ul> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script&gt;
        //数组解构
        let arr = [1,2,3];
        // // let a = arr[0];
        // // let b = arr[1];
        // // let c = arr[2];

        let [a,b,c] = arr;
        console.log(a,b,c)

        const person = {
            name: "jack",
            age: 21,
            language: ['java', 'js', 'css']
        }
        //         const name = person.name;
        //         const age = person.age;
        //         const language = person.language;

        //对象解构 // 把name属性变为abc，声明了abc、age、language三个变量
        const { name: abc, age, language } = person;
        console.log(abc, age, language)

        //4、字符串扩展
        let str = "hello.vue";
        console.log(str.startsWith("hello"));//true
        console.log(str.endsWith(".vue"));//true
        console.log(str.includes("e"));//true
        console.log(str.includes("hello"));//true

        //字符串模板 ``可以定义多行字符串
        let ss = `&lt;div&gt;
                    &lt;span&gt;hello world&lt;span&gt;
                &lt;/div&gt;`;
        console.log(ss);
        
        function fun() {
            return "这是一个函数"
        }

        // 2、字符串插入变量和表达式。变量名写在 ${} 中，${} 中可以放入 JavaScript 表达式。
        let info = `我是${abc}，今年${age + 10}了, 我想说： ${fun()}`;
        console.log(info);

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
</div> 
<h4 id="3%E3%80%81%E5%87%BD%E6%95%B0%E4%BC%98%E5%8C%96"><a id="3_654"></a>5.1.3、函数优化</h4> 
<ul><li>支持函数<strong>形参默认值</strong><code>function add(a, <strong>b = 1</strong>){}</code></li><li>支持<strong>不定参数数量</strong><code>function fun(...values){}，此时能传多个参数，values.length获取数量。</code></li><li>支持<strong>箭头函数</strong><code>var print = obj =&gt; console.log(obj);有点<strong>像Lambda表达式</strong></code></li><li>支持<strong>箭头函数+解构对象</strong><code>var hello2 = ({name}) =&gt; console.log("hello," +name); hello2(person);这里参数{name}是解构出person对象的name属性</code></li></ul> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;script&gt;
        //在ES6以前，我们无法给一个函数参数设置默认值，只能采用变通写法：
        function add(a, b) {
            // 判断b是否为空，为空就给默认值1
            b = b || 1;
            return a + b;
        }
        // 传一个参数
        console.log(add(10));


        //现在可以这么写：直接给参数写上默认值，没传就会自动使用默认值
        function add2(a, b = 1) {
            return a + b;
        }
        console.log(add2(20));


        //2）、不定参数
        function fun(...values) {
            console.log(values.length)
        }
        fun(1, 2)      //2
        fun(1, 2, 3, 4)  //4

        //3）、箭头函数。lambda
        //以前声明一个方法
        // var print = function (obj) {
        //     console.log(obj);
        // }
        var print = obj =&gt; console.log(obj);
        print("hello");

        var sum = function (a, b) {
            c = a + b;
            return a + c;
        }

        var sum2 = (a, b) =&gt; a + b;
        console.log(sum2(11, 12));

        var sum3 = (a, b) =&gt; {
            c = a + b;
            return a + c;
        }
        console.log(sum3(10, 20))


        const person = {
            name: "jack",
            age: 21,
            language: ['java', 'js', 'css']
        }

        function hello(person) {
            console.log("hello," + person.name)
        }

        //箭头函数+解构
        var hello2 = ({name}) =&gt; console.log("hello," +name);
        hello2(person);

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
</div> 
<h4 id="4%E3%80%81%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%8C%96"><a id="4_748"></a>5.1.4、对象优化</h4> 
<ul><li>可以<strong>获取map的键值对</strong><code>Object.keys(personMap)</code>、<code>Object.values(personMap)</code>、<code>Object.entries(personMap)</code></li><li><code>Object.assgn(target,source1,source2)</code> <strong>合并对象</strong>source1，source2到target</li><li>支持<strong>对象名声明简写</strong>：如果属性名和属性值的变量名相同可以省略</li><li><code>let someone = {...person}</code>取出person对象所有的属性拷贝到当前对象</li></ul> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;script&gt;
        const person = {
            name: "jack",
            age: 21,
            language: ['java', 'js', 'css']
        }

        console.log(Object.keys(person));//["name", "age", "language"]
        console.log(Object.values(person));//["jack", 21, Array(3)]
        console.log(Object.entries(person));//[Array(2), Array(2), Array(2)]，这里每个Array能点开查看键值对

        const target = { a: 1 };
        const source1 = { b: 2 };
        const source2 = { c: 3 };

        // 合并
        //{a:1,b:2,c:3}
        Object.assign(target, source1, source2);

        console.log(target);//["name", "age", "language"]

        //2）、声明对象简写
        const age = 23
        const name = "张三"
        const person1 = { age: age, name: name }
        // 等价于
        const person2 = { age, name }//声明对象简写
        console.log(person2);

        //3）、对象的函数属性简写
        let person3 = {
            name: "jack",
            // 以前：
            eat: function (food) {
                console.log(this.name + "在吃" + food);
            },
            //箭头函数this不能使用，要使用的话需要使用：对象.属性
            eat2: food =&gt; console.log(person3.name + "在吃" + food),
            eat3(food) {
                console.log(this.name + "在吃" + food);
            }
        }

        person3.eat("香蕉");
        person3.eat2("苹果")
        person3.eat3("橘子");

        //4）、对象拓展运算符

        // 1、拷贝对象（深拷贝）
        let p1 = { name: "Amy", age: 15 }
        let someone = { ...p1 }
        console.log(someone)  //{name: "Amy", age: 15}

        // 2、合并对象
        let age1 = { age: 15 }
        let name1 = { name: "Amy" }
        let p2 = { name: "zhangsan" }
        p2 = { ...age1, ...name1 }
        console.log(p2)
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre> 
</div> 
<h4 id="5%E3%80%81map%E5%92%8Creduce"><a id="5mapreduce_841"></a>5.1.5、map和reduce</h4> 
<ul><li><code>arr.map()</code>接收一个函数，将arr中的所有元素用接收到的函数处理后放入新的数组</li><li><code>arr.reduce()</code>为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，</li></ul> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;

    &lt;!DOCTYPE html&gt;
    &lt;html lang="en"&gt;

    &lt;head&gt;
        &lt;meta charset="UTF-8"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
        &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
        &lt;title&gt;Document&lt;/title&gt;
    &lt;/head&gt;

    &lt;body&gt;


        &lt;script&gt;
            //数组中新增了map和reduce方法。
            //map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。
            let arr = ['1', '20', '-5', '3'];

            //  arr = arr.map((item)=&gt;{
            //     return item*2
            //  });
            arr = arr.map(item =&gt; item * 2);



            console.log(arr);
            //reduce() 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，
            //[2, 40, -10, 6]
            //arr.reduce(callback,[initialValue])
            /**
             1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））
        2、currentValue （数组中当前被处理的元素）
        3、index （当前元素在数组中的索引）
        4、array （调用 reduce 的数组）*/
            let result = arr.reduce((a, b) =&gt; {
                console.log("上一次处理后：" + a);
                console.log("当前正在处理：" + b);
                return a + b;
            }, 100);
            console.log(result)


        &lt;/script&gt;
    &lt;/body&gt;

    &lt;/html&gt;
    &lt;script&gt;
        //数组中新增了map和reduce方法。
        //map()：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。
        let arr = ['1', '20', '-5', '3'];

        //  arr = arr.map((item)=&gt;{
        //     return item*2
        //  });
        arr = arr.map(item =&gt; item * 2);



        console.log(arr);
        //reduce() 为数组中的每一个元素依次执行回调函数，不包括数组中被删除或从未被赋值的元素，
        //[2, 40, -10, 6]
        //arr.reduce(callback,[initialValue])
        /**
        1、previousValue （上一次调用回调返回的值，或者是提供的初始值（initialValue））
        2、currentValue （数组中当前被处理的元素）
        3、index （当前元素在数组中的索引）
        4、array （调用 reduce 的数组）*/
        let result = arr.reduce((a, b) =&gt; {
            console.log("上一次处理后：" + a);
            console.log("当前正在处理：" + b);
            return a + b;
        }, 100);
        console.log(result)


    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre> 
</div> 
<h4 id="6%E3%80%81promise"><a id="6promise_948"></a>5.1.6、promise</h4> 
<ul><li>优化异步操作。封装ajax</li><li>把Ajax封装到Promise中，赋值给let p</li><li>在Ajax中成功使用resolve(data)，失败使用reject(err)</li><li>p.then().catch()</li></ul> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;

&lt;body&gt;

    &lt;script&gt;
        //1、查出当前用户信息
        //2、按照当前用户的id查出他的课程
        //3、按照当前课程id查出分数
        // $.ajax({
        //     url: "mock/user.json",
        //     success(data) {
        //         console.log("查询用户：", data);
        //         $.ajax({
        //             url: `mock/user_corse_${data.id}.json`,
        //             success(data) {
        //                 console.log("查询到课程：", data);
        //                 $.ajax({
        //                     url: `mock/corse_score_${data.id}.json`,
        //                     success(data) {
        //                         console.log("查询到分数：", data);
        //                     },
        //                     error(error) {
        //                         console.log("出现异常了：" + error);
        //                     }
        //                 });
        //             },
        //             error(error) {
        //                 console.log("出现异常了：" + error);
        //             }
        //         });
        //     },
        //     error(error) {
        //         console.log("出现异常了：" + error);
        //     }
        // });


        //1、Promise可以封装异步操作
        // let p = new Promise((resolve, reject) =&gt; {
        //     //1、异步操作
        //     $.ajax({
        //         url: "mock/user.json",
        //         success: function (data) {
        //             console.log("查询用户成功:", data)
        //             resolve(data);
        //         },
        //         error: function (err) {
        //             reject(err);
        //         }
        //     });
        // });

        // p.then((obj) =&gt; {
        //     return new Promise((resolve, reject) =&gt; {
        //         $.ajax({
        //             url: `mock/user_corse_${obj.id}.json`,
        //             success: function (data) {
        //                 console.log("查询用户课程成功:", data)
        //                 resolve(data);
        //             },
        //             error: function (err) {
        //                 reject(err)
        //             }
        //         });
        //     })
        // }).then((data) =&gt; {
        //     console.log("上一步的结果", data)
        //     $.ajax({
        //         url: `mock/corse_score_${data.id}.json`,
        //         success: function (data) {
        //             console.log("查询课程得分成功:", data)
        //         },
        //         error: function (err) {
        //         }
        //     });
        // })

        function get(url, data) {
            return new Promise((resolve, reject) =&gt; {
                $.ajax({
                    url: url,
                    data: data,
                    success: function (data) {
                        resolve(data);
                    },
                    error: function (err) {
                        reject(err)
                    }
                })
            });
        }

        get("mock/user.json")
            .then((data) =&gt; {
                console.log("用户查询成功~~~:", data)
                return get(`mock/user_corse_${data.id}.json`);
            })
            .then((data) =&gt; {
                console.log("课程查询成功~~~:", data)
                return get(`mock/corse_score_${data.id}.json`);
            })
            .then((data)=&gt;{
                console.log("课程成绩查询成功~~~:", data)
            })
            .catch((err)=&gt;{
                console.log("出现异常",err)
            });

    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre> 
</div> 
<h4 id="7%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96"><a id="7_1087"></a>5.1.7、模块化</h4> 
<ul><li><code>export</code>用于规定模块的对外接口,<code>export</code>不仅可以导出对象，一切JS变量都可以导出。比如：基本类型变量、函数、数组、对象</li><li><code>import</code>用于导入其他模块提供的功能</li></ul> 
<div> 
 <pre><code class="language-javascript">// user.js

var name = "jack"
var age = 21
function add(a,b){
    return a + b;
}
// 导出变量和函数
export {name,age,add}

---------------------------------------------------------------
// hello.js
    
// 导出后可以重命名
export default {
    sum(a, b) {
        return a + b;
    }
}


--------------------------------------------------------------
// main.js

import abc from "./hello.js"
import {name,add} from "./user.js"

abc.sum(1,2);
console.log(name);
add(1,3);
</code></pre> 
</div> 
<h3 id="2.%20VUE%E5%9F%BA%E7%A1%80"><a id="2_VUE_1133"></a>5.2. VUE基础</h3> 
<p>MVVM思想</p> 
<p>M：model 包括数据和一些基本操作<br> V：view 视图，页面渲染结果<br> VM：View-model，模型与视图间的双向操作（无需开发人员干涉）<br> 视图和数据通过VM绑定起来，model里有变化会自动地通过Directives填写到视view中，视图表单中添加了内容也会自动地通过DOM Listeners保存到模型中。</p> 
<p>官方文档：https://cn.vuejs.org/v2/guide/</p> 
<h4 id="1%E3%80%81VUE%E5%AE%89%E8%A3%85"><a id="1VUE_1152"></a>5.2.1、VUE安装</h4> 
<p>给当前项目安装vue</p> 
<div> 
 <pre><code class="language-bash">#npm初始化项目，生成package.json
npm init -y
#安装vue
npm install vue@2.6.10
</code></pre> 
</div> 
<blockquote> 
 <p><strong>npm init -y：</strong>在文件夹下生成默认的<strong>package.json</strong>文件，代表此文件夹是npm管理的项目。</p> 
</blockquote> 
<p><img alt="" height="33" src="https://images2.imgbox.com/0a/3f/1D4ebuxW_o.png" width="200">​</p> 
<p></p> 
<p><strong>引入vue：</strong></p> 
<div> 
 <pre><code>&lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;
</code></pre> 
</div> 
<p><strong>示例：</strong></p> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;p&gt;原始字符串: {<!-- -->{ message }}&lt;/p&gt;
    &lt;/div&gt;
    &lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        var vm = new Vue({
            el: '#app',
            data: {
                message: 'Runoob!'
            }
        })
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre> 
</div> 
<p><img alt="" height="37" src="https://images2.imgbox.com/f1/d5/0GkjQ9Fb_o.png" width="232"></p> 
<p></p> 
<h4 id="2%E3%80%81v-model%2C%20v-on"><a id="2vmodel_von_1181"></a>5.2.2、v-model, v-on</h4> 
<ul><li>new VUE</li><li>v-model 双向绑定</li><li>v-on 绑定事件</li></ul> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;input type="text" v-model="num"&gt;
        &lt;!-- v-model实现双向绑定。此处代表输入框和vue里的data绑定 --&gt;
        
        &lt;button v-on:click="num++"&gt;点赞&lt;/button&gt;
        &lt;!-- v-on:click绑定事件，实现自增。 --&gt;
        
        &lt;button v-on:click="cancel"&gt;取消&lt;/button&gt;
        &lt;!-- 回调自定义的方法。 此时字符串里代表的函数 --&gt;
        
        &lt;h1&gt; {<!-- -->{name}} ,非常帅，有{<!-- -->{num}}个人为他点赞{<!-- -->{hello()}}&lt;/h1&gt;
        &lt;!-- 先从vue中拿到值填充到dom，input再改变num值，vue实例更新，然后此处也更新 --&gt;
    &lt;/div&gt;

    &lt;!-- 导入依赖 --&gt;
    &lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;

    &lt;script&gt;
        //1、vue声明式渲染
        let vm = new Vue({ //生成vue对象
            el: "#app",//绑定元素 div id="app" // 可以指定恰标签，但是不可以指定body标签
            data: {  //封装数据
                name: "张三",  // 也可以使用{} //表单中可以取出
                num: 1
            },
            methods:{  //封装方法
                cancel(){
                    this.num -- ;
                },
                hello(){
                    return "1"
                }
            }
        });
        // 还可以在html控制台vm.name

        //2、双向绑定,模型变化，视图变化。反之亦然。
        //3、事件处理

        //v-xx：指令

        //1、创建vue实例，关联页面的模板，将自己的数据（data）渲染到关联的模板，响应式的
        //2、指令来简化对dom的一些操作。
        //3、声明方法来做更复杂的操作。methods里面可以封装方法。

    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
</div> 
<h4 id="3%E3%80%81v-text%E3%80%81v-html%E3%80%81v-ref"><a id="3vtextvhtmlvref_1255"></a>5.2.3、v-text、v-html、v-ref</h4> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
   
    &lt;div id="app"&gt;
        {<!-- -->{msg}}  {<!-- -->{1+1}}  {<!-- -->{hello()}} 前面的内容如果网速慢的话会先显示括号，然后才替换成数据。
        v-html 和v-text能解决这个问题
        &lt;br/&gt;
        
        用v-html取内容
        &lt;span v-html="msg"&gt;&lt;/span&gt;
        
        &lt;br/&gt;
        原样显示
        &lt;span v-text="msg"&gt;&lt;/span&gt;  
    &lt;/div&gt;
   
    &lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;

    &lt;script&gt;
        new Vue({
            el:"#app",
            data:{
                msg:"&lt;h1&gt;Hello&lt;/h1&gt;",
                link:"http://www.baidu.com"
            },
            methods:{
                hello(){
                    return "World"
                }
            }
        })
    &lt;/&gt;
    
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
</div> 
<h4 id="4%E3%80%81%E5%8D%95%E5%90%91%E7%BB%91%E5%AE%9Av-bind%3A"><a id="4vbind_1308"></a>5.2.4、单向绑定v-bind:</h4> 
<ul><li> <p>花括号只能写在标签体内（<code>&lt;div 标签内&gt; 标签体 &lt;/div&gt;</code>），不能用在标签内。</p> <p>插值表达式只能用在标签体里，如果我们这么用<code>&lt;a href="{<!-- -->{}}"&gt;</code>是不起作用的，所以要用v-bind</p> </li><li> <p>跳转页面<code>&lt;a v-bind:href="link"&gt;跳转&lt;/a&gt;</code></p> </li><li> <p>用<code>v-bind:</code>，简写为<code>:</code>。表示把model绑定到view。可以设置src、title、class等</p> </li></ul> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;!-- 给html标签的属性绑定 --&gt;
    &lt;div id="app"&gt; 

        &lt;a v-bind:href="link"&gt;跳转&lt;/a&gt;

        &lt;!-- class,style  {class名：vue值}--&gt;
        &lt;span v-bind:class="{active:isActive,'text-danger':hasError}"
          :style="{color: color1,fontSize: size}"&gt;你好&lt;/span&gt;

    &lt;/div&gt;

    &lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;

    &lt;script&gt;
        let vm = new Vue({
            el:"#app",
            data:{
                link: "http://www.baidu.com",
                isActive:true,
                hasError:true,
                color1:'red',
                size:'36px'
            }
        })
    &lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
</div> 
<h4 id="5%E3%80%81%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9Av-model"><a id="5vmodel_1366"></a>5.2.5、双向绑定v-model</h4> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

    &lt;!-- 表单项，自定义组件 --&gt;
    &lt;div id="app"&gt;

        精通的语言：如果是多选框，那么会把每个value值赋值给vue数据
            &lt;input type="checkbox" v-model="language" value="Java"&gt; java&lt;br/&gt;
            &lt;input type="checkbox" v-model="language" value="PHP"&gt; PHP&lt;br/&gt;
            &lt;input type="checkbox" v-model="language" value="Python"&gt; Python&lt;br/&gt;
        选中了 {<!-- -->{language.join(",")}}
    &lt;/div&gt;
    
    &lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;

    &lt;script&gt;
        let vm = new Vue({
            el:"#app",
            data:{
                language: []
            }
        })
    &lt;/script&gt;

&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
</div> 
<h4 id="6%E3%80%81v-on%E4%BA%8B%E4%BB%B6"><a id="6von_1410"></a>5.2.6、v-on事件</h4> 
<ul><li>事件监听可以使用 v-on 指令</li><li><code>v-on:事件类型="方法"</code> ，可以简写成<code>@事件类型="方法"</code></li><li>Vue.js 为 v-on 提供了事件修饰符来处理 DOM 事件细节，如：event.preventDefault() 或 event.stopPropagation()。</li><li>Vue.js 通过由点 . 表示的指令后缀来调用修饰符。 
  <ul><li>.stop - 阻止冒泡</li><li>.prevent - 阻止默认事件</li><li>.capture - 阻止捕获</li><li>.self - 只监听触发该元素的事件</li><li>.once - 只触发一次</li><li>.left - 左键事件</li><li>.right - 右键事件</li><li>.middle - 中间滚轮事</li></ul></li></ul> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id="app"&gt;
                
        &lt;!--事件中直接写js片段--&gt;
        &lt;button v-on:click="num++"&gt;点赞&lt;/button&gt;
        &lt;!--事件指定一个回调函数，必须是Vue实例中定义的函数--&gt;
        &lt;button @click="cancel"&gt;取消&lt;/button&gt;
        &lt;!--  --&gt;
        &lt;h1&gt;有{<!-- -->{num}}个赞&lt;/h1&gt;


        &lt;!-- 事件修饰符 --&gt;
        &lt;div style="border: 1px solid red;padding: 20px;" v-on:click.once="hello"&gt;
            大div
            &lt;div style="border: 1px solid blue;padding: 20px;" @click.stop="hello"&gt;
                小div &lt;br /&gt;
                &lt;a href="http://www.baidu.com" @click.prevent.stop="hello"&gt;去百度&lt;/a&gt;
            &lt;/div&gt;
        &lt;/div&gt;



        &lt;!-- 按键修饰符： --&gt;
        &lt;input type="text" v-model="num" v-on:keyup.up="num+=2" @keyup.down="num-=2" @click.ctrl="num=10"&gt;&lt;br /&gt;

        提示：

    &lt;/div&gt;
    &lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;

    &lt;script&gt;
        new Vue({
            el:"#app",
            data:{
                num: 1
            },
            methods:{
                cancel(){
                    this.num--;
                },
                hello(){
                    alert("点击了")
                }
            }
        })
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre> 
</div> 
<h4 id="7%E3%80%81v-for%E9%81%8D%E5%8E%86"><a id="7vfor_1495"></a>5.2.7、v-for遍历</h4> 
<ul><li>可以遍历 数组[] 字典{} 。对于字典<code>&lt;li v-for="(value, key, index) in object"&gt;</code></li><li>遍历的时候都加上:key来区分不同数据，提高vue渲染效率</li></ul> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;

    &lt;div id="app"&gt;
        &lt;ul&gt;
            &lt;!-- 4、遍历的时候都加上:key来区分不同数据，提高vue渲染效率 --&gt;
            &lt;li v-for="(user,index) in users" :key="user.name" v-if="user.gender == '女'"&gt;
                &lt;!-- 1、显示user信息：v-for="item in items" --&gt;
               当前索引：{<!-- -->{index}} ==&gt; {<!-- -->{user.name}}  ==&gt;   
                  {<!-- -->{user.gender}} ==&gt;{<!-- -->{user.age}} &lt;br&gt;
                &lt;!-- 2、获取数组下标：v-for="(item,index) in items" --&gt;
                &lt;!-- 3、遍历对象：
                        v-for="value in object"
                        v-for="(value,key) in object"
                        v-for="(value,key,index) in object" 
                --&gt;
                对象信息：
                &lt;span v-for="(v,k,i) in user"&gt;{<!-- -->{k}}=={<!-- -->{v}}=={<!-- -->{i}}；&lt;/span&gt;
                &lt;!-- 4、遍历的时候都加上:key来区分不同数据，提高vue渲染效率 --&gt;
            &lt;/li&gt;

            
        &lt;/ul&gt;

        &lt;ul&gt;
            &lt;li v-for="(num,index) in nums" :key="index"&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;
    &lt;script&gt;         
        let app = new Vue({
            el: "#app",
            data: {
                users: [
                { name: '柳岩', gender: '女', age: 21 },
                { name: '张三', gender: '男', age: 18 },
                { name: '范冰冰', gender: '女', age: 24 },
                { name: '刘亦菲', gender: '女', age: 18 },
                { name: '古力娜扎', gender: '女', age: 25 }
                ],
                nums: [1,2,3,4,4]
            },
        })
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre> 
</div> 
<h4 id="8%E3%80%81v-if%E5%92%8Cv-show"><a id="8vifvshow_1567"></a>5.2.8、v-if和v-show</h4> 
<ul><li>在vue实例的data指定一个bool变量，然后v-show赋值即可。show里的字符串也可以比较</li><li>if是根据表达式的真假，切换元素的显示和隐藏（操作dom元素）</li><li>区别：show的标签F12一直都在，if的标签会移除，</li><li>if操作dom树对性能消耗大</li></ul> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;!-- 
        v-if，顾名思义，条件判断。当得到结果为true时，所在的元素才会被渲染。
        v-show，当得到结果为true时，所在的元素才会被显示。 
    --&gt;
    &lt;div id="app"&gt;
        &lt;button v-on:click="show = !show"&gt;点我呀&lt;/button&gt;
        &lt;!-- 1、使用v-if显示 --&gt;
        &lt;h1 v-if="show"&gt;if=看到我....&lt;/h1&gt;
        &lt;!-- 2、使用v-show显示 --&gt;
        &lt;h1 v-show="show"&gt;show=看到我&lt;/h1&gt;
    &lt;/div&gt;

    &lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;
        
    &lt;script&gt;
        let app = new Vue({
            el: "#app",
            data: {
                show: true
            }
        })
    &lt;/script&gt;

&lt;/body&gt;

&lt;/html&gt;
</code></pre> 
</div> 
<h4 id="9%E3%80%81v-else%E5%92%8Cv-else-if"><a id="9velsevelseif_1622"></a>5.2.9、v-else和v-else-if</h4> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;button v-on:click="random=Math.random()"&gt;点我呀&lt;/button&gt;
        &lt;span&gt;{<!-- -->{random}}&lt;/span&gt;

        &lt;h1 v-if="random&gt;=0.75"&gt;
            看到我啦? &gt;= 0.75
        &lt;/h1&gt;
        &lt;h1 v-else-if="random&gt;=0.5"&gt;
            看到我啦? &gt;= 0.5
        &lt;/h1&gt;
        &lt;h1 v-else-if="random&gt;=0.2"&gt;
            看到我啦? &gt;= 0.2
        &lt;/h1&gt;
        &lt;h1 v-else&gt;
            看到我啦? &lt; 0.2
        &lt;/h1&gt;

    &lt;/div&gt;


    &lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;
        
    &lt;script&gt;         
        let app = new Vue({
            el: "#app",
            data: { random: 1 }
        })     
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre> 
</div> 
<h4 id="10%E3%80%81%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E5%92%8C%E7%9B%91%E5%90%AC%E5%99%A8"><a id="10_1675"></a>5.2.10、计算属性和监听器</h4> 
<p><strong>计算属性computed：属性</strong>不是具体值，而<strong>是通过一个函数计算出来的</strong>，<strong>随时变化</strong></p> 
<div> 
 <pre><code class="language-html">&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;p&gt;原始字符串: {<!-- -->{ message }}&lt;/p&gt;
        &lt;p&gt;计算后反转字符串: {<!-- -->{ reversedMessage }}&lt;/p&gt;
    &lt;/div&gt;
    &lt;script src="./node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;
    &lt;script&gt;
        var vm = new Vue({
            el: '#app',
            data: {
                message: 'Run,oob!'
            },
            computed: {
                // 计算属性的 getter
                reversedMessage: function () {
                    // `this` 指向 vm 实例
                    return this.message.split(',').reverse().join('')
                }
            }
        })
    &lt;/script&gt;
&lt;/body&gt;</code></pre> 
</div> 
<p><img alt="" height="100" src="https://images2.imgbox.com/3f/bc/LD5fETcL_o.png" width="319"></p> 
<p></p> 
<p><strong>监听watch:</strong>可以让我们<strong>监控一个值的变化，从而做出相应的反应</strong>。</p> 
<p>以下实例通过使用 watch 实现计数器：</p> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;!-- 某些结果是基于之前数据实时计算出来的，我们可以利用计算属性。来完成 --&gt;
        &lt;ul&gt;
            &lt;li&gt;西游记； 价格：{<!-- -->{xyjPrice}}，数量：&lt;input type="number" v-model="xyjNum"&gt; &lt;/li&gt;
            &lt;li&gt;水浒传； 价格：{<!-- -->{shzPrice}}，数量：&lt;input type="number" v-model="shzNum"&gt; &lt;/li&gt;
            &lt;li&gt;总价：{<!-- -->{totalPrice}}&lt;/li&gt;
            {<!-- -->{msg}}
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;

    &lt;script&gt;
        
        new Vue({
            el: "#app",
            data: {
                xyjPrice: 99.98,
                shzPrice: 98.00,
                xyjNum: 1,
                shzNum: 1,
                msg: ""
            },
//计算属性
            computed: {
                totalPrice(){
                    return this.xyjPrice*this.xyjNum + this.shzPrice*this.shzNum
                }
            },
//监听器，watch可以让我们监控一个值的变化。从而做出相应的反应。
            watch: {
                xyjNum: function(newVal,oldVal){
                    if(newVal&gt;=3){
                        this.msg = "库存超出限制";
                        this.xyjNum = 3
                    }else{
                        this.msg = "";
                    }
                }
            },
        })
    &lt;/script&gt;

&lt;/body&gt;

&lt;/html&gt;
</code></pre> 
</div> 
<h4 id="11%E3%80%81%E8%BF%87%E6%BB%A4%E5%99%A8filter"><a id="11filter_1779"></a>5.2.11、过滤器filter</h4> 
<p>过滤器filter：定义filter组件后，管道符“|”后面跟具体过滤器<strong><code>{<!-- -->{user.gender | gFilter}}</code></strong></p> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;!-- 过滤器常用来处理文本格式化的操作。过滤器可以用在两个地方：双花括号插值和 v-bind 表达式 --&gt;
    &lt;div id="app"&gt;
        &lt;ul&gt;
            &lt;li v-for="user in userList"&gt;
                {<!-- -->{user.id}} ==&gt; {<!-- -->{user.name}} ==&gt; {<!-- -->{user.gender == 1?"男":"女"}} ==&gt;
                {<!-- -->{user.gender | genderFilter}} ==&gt; {<!-- -->{user.gender | gFilter}}
            &lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
    &lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;

    &lt;script&gt;

        // 全局过滤器，方法实参是管道符前面的值
        Vue.filter("gFilter", function (val) {
            if (val == 1) {
                return "男~~~";
            } else {
                return "女~~~";
            }
        })

        let vm = new Vue({
            el: "#app",
            data: {
                userList: [
                    { id: 1, name: 'jacky', gender: 1 },
                    { id: 2, name: 'peter', gender: 0 }
                ]
            },
            filters: { // 局部过滤器，只可以在当前vue实例中使用
                genderFilter(val) {
                    if (val == 1) {
                        return "男";
                    } else {
                        return "女";
                    }
                }
            }
        })
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre> 
</div> 
<p><img alt="" height="59" src="https://images2.imgbox.com/4a/62/9XivdWLe_o.png" width="469"></p> 
<p></p> 
<h4 id="12%E3%80%81%E7%BB%84%E4%BB%B6%E5%8C%96"><a id="12_1849"></a>5.2.12、组件化</h4> 
<ul><li>在大型应用开发的时候，页面可以划分成很多部分。往往不同的页面，也会有相同的部分。例如可能会有相同的头部导航。</li><li>但是如果每个页面都自开发，这无疑增加了我们开发的成本。所以我们会把页面的不同分拆分成立的组件，然后在不同页面就可以共享这些组件，避免重复开发。</li><li>在vue里，所有的vue实例都是组件</li><li>组件其实也是一个vue实例，因此它在定义时也会接收：data、methods、生命周期函数等</li><li>不同的是组件不会与页面的元素绑定（所以不写el），否则就无法复用了，因此没有el属性。</li><li>但是组件渲染需要html模板，所以增加了template属性，值就是HTML模板</li><li>data必须是一个函数，不再是一个对象。</li><li>全局组件定义完毕，任何vue实例都可以直接在HTML中通过组件名称来使用组件了</li></ul> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
&lt;/head&gt;

&lt;body&gt;

    &lt;div id="app"&gt;
        &lt;button v-on:click="count++"&gt;我被点击了 {<!-- -->{count}} 次&lt;/button&gt;

        每个对象都是独立统计的
        &lt;counter&gt;&lt;/counter&gt;
        &lt;counter&gt;&lt;/counter&gt;
        &lt;counter&gt;&lt;/counter&gt;
        &lt;counter&gt;&lt;/counter&gt;
        &lt;counter&gt;&lt;/counter&gt;

        &lt;button-counter&gt;&lt;/button-counter&gt;
    &lt;/div&gt;
    &lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;


    &lt;script&gt;
        //1、全局声明注册一个组件 // counter标签，代表button
        // 把页面中&lt;counter&gt;标签替换为指定的template，而template中的数据用data填充
        Vue.component("counter", {
            template: `&lt;button v-on:click="count++"&gt;我被点击了 {<!-- -->{count}} 次&lt;/button&gt;`,
            data() {// 如果 Vue 没有这条规则，点击一个按钮就可能会像如下代码一样影响到其它所有实例：
                return {
                    count: 1 // 数据
                }
            }
        });

        //2、局部声明一个组件
        const buttonCounter = {
            template: `&lt;button v-on:click="count++"&gt;我被点击了 {<!-- -->{count}} 次~~~&lt;/button&gt;`,
            data() {
                return {
                    count: 1
                }
            }
        };

        new Vue({
            el: "#app",
            data: {
                count: 1
            },
            components: { // 局部声明的组件
                'button-counter': buttonCounter
            }
        })
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre> 
</div> 
<h4 id="13%E3%80%81%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><a id="13_1932"></a>5.2.13、生命周期和钩子函数</h4> 
<p>每个vue实例在被创建时都要经过一系列的初始化过程：创建实例，装载模板、渲染模板等等。vue为生命周期中的每个状态都设置了钩子函数（监听函）。每当vue实列处于不同的生命周期时，对应的函数就会被触发调用。</p> 
<p><img alt="" src="https://images2.imgbox.com/c1/f5/Tax6na0N_o.png">​</p> 
<p></p> 
<div> 
 <pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;

&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;span id="num"&gt;{<!-- -->{num}}&lt;/span&gt;
        &lt;button @click="num++"&gt;赞！&lt;/button&gt;
        &lt;h2&gt;{<!-- -->{name}}，有{<!-- -->{num}}个人点赞&lt;/h2&gt;
    &lt;/div&gt;

    &lt;script src="../node_modules/vue/dist/vue.js"&gt;&lt;/script&gt;
    
    &lt;script&gt;
        let app = new Vue({
            el: "#app",
            data: {
                name: "张三",
                num: 100
            },
            methods: {
                show() {
                    return this.name;
                },
                add() {
                    this.num++;
                }
            },
            beforeCreate() {
                console.log("=========beforeCreate=============");
                console.log("数据模型未加载：" + this.name, this.num);
                console.log("方法未加载：" + this.show());
                console.log("html模板未加载：" + document.getElementById("num"));
            },
            created: function () {
                console.log("=========created=============");
                console.log("数据模型已加载：" + this.name, this.num);
                console.log("方法已加载：" + this.show());
                console.log("html模板已加载：" + document.getElementById("num"));
                console.log("html模板未渲染：" + document.getElementById("num").innerText);
            },
            beforeMount() {
                console.log("=========beforeMount=============");
                console.log("html模板未渲染：" + document.getElementById("num").innerText);
            },
            mounted() {
                console.log("=========mounted=============");
                console.log("html模板已渲染：" + document.getElementById("num").innerText);
            },
            beforeUpdate() {
                console.log("=========beforeUpdate=============");
                console.log("数据模型已更新：" + this.num);
                console.log("html模板未更新：" + document.getElementById("num").innerText);
            },
            updated() {
                console.log("=========updated=============");
                console.log("数据模型已更新：" + this.num);
                console.log("html模板已更新：" + document.getElementById("num").innerText);
            }
        });
    &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre> 
</div> 
<p></p> 
<h3 id="3.%20vue-dome"><a id="3_vuedome_2021"></a>5.3. vue脚手架进行模块化开发</h3> 
<h4 id="1%E3%80%81%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85webpack"><a id="1webpack_2025"></a>5.3.1、全局安装webpack</h4> 
<p>在任意目录下cmd，注意命令尾部“-g” 是全局安装的意思。</p> 
<div> 
 <pre><code>npm install webpack -g
</code></pre> 
</div> 
<p>默认安装到目录：</p> 
<p><img alt="" height="44" src="https://images2.imgbox.com/43/e0/1butYSiv_o.png" width="993"></p> 
<p></p> 
<h4 id="2%E3%80%81%E5%85%A8%E5%B1%80%E5%AE%89%E8%A3%85vue%E8%84%9A%E6%89%8B%E6%9E%B6"><a id="2vue_2037"></a>5.3.2、全局安装vue脚手架</h4> 
<div> 
 <pre><code class="language-bash">npm install -g @vue/cli@4.0.3
</code></pre> 
</div> 
<blockquote> 
 <p><strong>注意：</strong>脚手架版本和node版本要匹配，我node版本10.16.3，匹配脚手架4.0.3 </p> 
</blockquote> 
<h4 id="3%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96vue%E9%A1%B9%E7%9B%AE"><a id="3vue_2049"></a>5.3.3、初始化vue项目</h4> 
<p>在工程文件夹下cmd，输入以下命令初始化vue项目。建议工程名与文件夹名一致</p> 
<div> 
 <pre><code class="language-bash">vue init webpack 想要起的工程名
#vue init webpack vue-demo</code></pre> 
</div> 
<p></p> 
<p><img alt="image-20210927110259380" src="https://images2.imgbox.com/71/45/wJcUeWtA_o.png">​</p> 
<p></p> 
<blockquote> 
 <p>standalone单例是选择运行+编译：<img alt="" height="41" src="https://images2.imgbox.com/78/d2/C7aSwFjQ_o.png" width="661"></p> 
 <p></p> 
 <p>ESLint是检查代码规范的，这里不选否。 </p> 
 <p>test是否使用单元测试，这里也是否</p> 
</blockquote> 
<blockquote> 
 <p>如果一直卡在downloading template，配置淘宝镜像</p> 
 <div> 
  <pre><code>npm config set chromedriver_cdnurl https://npm.taobao.org/mirrors/chromedriver
</code></pre> 
 </div> 
 <p></p> 
</blockquote> 
<p></p> 
<p><strong>初始化成功，运行项目</strong></p> 
<div> 
 <pre><code class="language-bash">cd vue-demo

</code></pre> 
</div> 
<pre><code class="language-bash">npm run dev</code></pre> 
<blockquote> 
 <p><strong> 为什么运行命令是npm run dev?</strong></p> 
 <p>在项目目录下，我们可以看到一个名为package.json的文件，该文件是对项目、模块包的描述，在package.json文件中，有一个scripts的字段:</p> 
 <pre><code class="language-javascript">  "scripts": {
    "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js",
    "start": "npm run dev",
    "build": "node build/build.js"
  },</code></pre> 
 <p>修改后运行命令就是npm run serve：</p> 
 <pre><code class="language-javascript">// 运行npm run serve的scripts字段
  "scripts": {
    "serve": "vue-cli-service serve",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  },
</code></pre> 
 <p></p> 
</blockquote> 
<p><strong>启动成功</strong></p> 
<p><img alt="" height="81" src="https://images2.imgbox.com/23/31/PNhobWe3_o.png" width="540"></p> 
<p><strong>访问默认端口</strong><a href="http://localhost:8080/#/" rel="nofollow" title="http://localhost:8080/#/">http://localhost:8080/#/</a><strong>。</strong></p> 
<p></p> 
<p><img alt="image-20210927110328858" src="https://images2.imgbox.com/18/09/h2VRKO21_o.png">​</p> 
<p>关闭cmd窗口，在vscode打开项目，重新启动： </p> 
<pre><code class="language-bash">npm run dev</code></pre> 
<h4 id="4%E3%80%81vue%E9%A1%B9%E7%9B%AE%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><a id="4vue_2102"></a>5.3.4、vue项目目录结构</h4> 
<p><img alt="" height="353" src="https://images2.imgbox.com/46/c2/sSAFJK0k_o.png" width="207"></p> 
<p></p> 
<table><thead><tr><th> <p>目录/文件</p> </th><th> <p>说明</p> </th></tr></thead><tbody><tr><td> <p>build</p> </td><td> <p>项目构建(webpack)相关代码</p> </td></tr><tr><td> <p>config</p> </td><td> <p>配置目录，包括端口号等。我们初学可以使用默认的。</p> </td></tr><tr><td> <p>node_modules</p> </td><td> <p>npm 加载的项目依赖模块</p> </td></tr><tr><td> <p><strong>src</strong></p> </td><td> <p>这里是我们<strong>要开发的目录</strong>，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：<code>assets</code>: 放置一些图片，如logo等。<code>components</code>: 目录里面放了一个组件文件，可以不用。<code>App.vue</code>: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。<code>main.js</code>: 项目的核心文件。</p> </td></tr><tr><td> <p><strong>static</strong></p> </td><td> <p><strong>静态资源目录，如图片、字体等。</strong></p> </td></tr><tr><td> <p>test</p> </td><td> <p>初始测试目录，可删除</p> </td></tr><tr><td> <p>.xxxx文件</p> </td><td> <p>这些是一些配置文件，包括语法配置，git配置等</p> </td></tr><tr><td> <p>index.html</p> </td><td> <p>首页入口文件。</p> </td></tr><tr><td> <p>package.json</p> </td><td> <p>项目配置文件。</p> </td></tr><tr><td> <p>README.md</p> </td><td> <p>项目的说明文档，markdown 格式</p> </td></tr></tbody></table> 
<p id="5%E3%80%81%E4%BF%AE%E6%94%B9vue%E9%A1%B9%E7%9B%AE"><a id="5vue_2119"></a></p> 
<h4 id="5.3.5%E3%80%81%E4%BF%AE%E6%94%B9vue%E9%A1%B9%E7%9B%AE">5.3.5、<strong>分析主页展示逻辑</strong></h4> 
<p></p> 
<blockquote> 
 <p>/config/<strong>index.js配置端口：</strong></p> 
 <p><img alt="" height="55" src="https://images2.imgbox.com/27/d1/bxSZKxrS_o.png" width="249"></p> 
 <p></p> 
</blockquote> 
<p><strong>/index.html主页</strong></p> 
<p>其中只有一个<code>div，内容由src/main.js主程序决定。</code></p> 
<div> 
 <pre><code class="language-html">  &lt;body&gt;
    &lt;div id="app"&gt;&lt;/div&gt;
    &lt;!-- built files will be auto injected --&gt;
  &lt;/body&gt;
</code></pre> 
</div> 
<p>src/<strong>main.js</strong><strong>主程序，里面有vue实例挂载id为“app”元素：</strong></p> 
<div> 
 <pre><code class="language-java">import Vue from 'vue'
import App from './App'
import router from './router'

Vue.config.productionTip = false

/* eslint-disable no-new */
//创建vue实例挂载“app”元素
new Vue({
  el: '#app',
  router, //采用router路由，导入位置./router。这里是简写，完整是router:router
  components: { App },//绑定App组件。完整是App:App
  template: '&lt;App/&gt;'    //元素渲染模板
})
</code></pre> 
</div> 
<p><strong>主组件/src/App.vue，显示页面并引入路由规则</strong></p> 
<ul><li> <p>首先显示一张图片，图片路径为<code>"./assets/logo.png</code></p> </li><li> <p>其中的<code>&lt;router-view/&gt;</code>是根据url要决定访问的vue,在main.js中提及了使用的是<code>./router</code>规则</p> </li></ul> 
<div> 
 <pre><code class="language-html">&lt;!--模板标签，编写页面展示内容--&gt;
&lt;template&gt;
  &lt;div id="app"&gt;
&lt;!--这里引进了一个图片--&gt;
    &lt;img src="./assets/logo.png"&gt;
&lt;!--路由视图，/src/router/index.js路由规则配置访问的模块--&gt;
    &lt;router-view/&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;!--vue实例代码--&gt;
&lt;script&gt;
export default {
  name: 'App'
}
&lt;/script&gt;

&lt;!--当前模板样式--&gt;
&lt;style&gt;
...
&lt;/style&gt;
</code></pre> 
</div> 
<p><strong>配置路由规则</strong>/src/router/<strong>index.js</strong></p> 
<p>routes表示路由规则</p> 
<p>当访问<code>/</code>时， 显示组件<code>Helloword</code></p> 
<div> 
 <pre><code class="language-javascript">import Vue from 'vue'
import Router from 'vue-router'
import HelloWorld from '@/components/HelloWorld'

Vue.use(Router)

export default new Router({
  routes: [
//访问跟路径时，路由到helloworld模块
    {
      path: '/',
      name: 'HelloWorld',
      component: HelloWorld
    }
  ]
})
</code></pre> 
</div> 
<p>/src/components/<strong>HelloWorld.vue组件</strong></p> 
<pre><code class="language-html">&lt;!--模板，设置内容--&gt;
&lt;template&gt;
  &lt;div class="hello"&gt;
    &lt;h1&gt;{<!-- -->{ msg }}&lt;/h1&gt;
    &lt;h2&gt;Essential Links&lt;/h2&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;a
          href="https://vuejs.org"
          target="_blank"
        &gt;
          Core Docs
        &lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a
          href="https://forum.vuejs.org"
          target="_blank"
        &gt;
          Forum
        &lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a
          href="https://chat.vuejs.org"
          target="_blank"
        &gt;
          Community Chat
        &lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a
          href="https://twitter.com/vuejs"
          target="_blank"
        &gt;
          Twitter
        &lt;/a&gt;
      &lt;/li&gt;
      &lt;br&gt;
      &lt;li&gt;
        &lt;a
          href="http://vuejs-templates.github.io/webpack/"
          target="_blank"
        &gt;
          Docs for This Template
        &lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;h2&gt;Ecosystem&lt;/h2&gt;
    &lt;ul&gt;
      &lt;li&gt;
        &lt;a
          href="http://router.vuejs.org/"
          target="_blank"
        &gt;
          vue-router
        &lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a
          href="http://vuex.vuejs.org/"
          target="_blank"
        &gt;
          vuex
        &lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a
          href="http://vue-loader.vuejs.org/"
          target="_blank"
        &gt;
          vue-loader
        &lt;/a&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;a
          href="https://github.com/vuejs/awesome-vue"
          target="_blank"
        &gt;
          awesome-vue
        &lt;/a&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;!--script，vue实例代码。--&gt;
&lt;script&gt;
&lt;!--这里导出组件，名为“HelloWorld”，在路由文件/src/router/index.js会进行导入--&gt;
export default {
  name: 'HelloWorld',
  data () {
    return {
      msg: 'Welcome to Your Vue.js App'
    }
  }
}


&lt;/script&gt;

&lt;!-- Add "scoped" attribute to limit CSS to this component only --&gt;
&lt;!--style ，设置样式--&gt;
&lt;style scoped&gt;
h1, h2 {
  font-weight: normal;
}
ul {
  list-style-type: none;
  padding: 0;
}
li {
  display: inline-block;
  margin: 0 10px;
}
a {
  color: #42b983;
}
&lt;/style&gt;
</code></pre> 
<p></p> 
<h4 id="5.3.6%E3%80%81%E6%96%B0%E5%BB%BAHello%E7%BB%84%E4%BB%B6%EF%BC%8C%E8%B4%9F%E8%B4%A3%2Fhello%E8%B7%AF%E5%BE%84"><strong>5.3.6、新建Hello组件，负责/hello路径</strong></h4> 
<p>/src/components<strong>创建hello.vue组件，编写组件三标签：</strong></p> 
<div> 
 <pre><code class="language-html">&lt;template&gt;
    &lt;div&gt;
        &lt;h1&gt;你好，hello，{<!-- -->{name}}&lt;/h1&gt;
    &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
&lt;!--导出组件，在路由文件/src/router/index.js会导入--&gt;
export default {
    data(){
        return {
            name: "张三"
        }
    }
}
&lt;/script&gt;

&lt;style&gt;

&lt;/style&gt;
</code></pre> 
</div> 
<p><strong>编写路由文件</strong>，修改/src/router/index.js</p> 
<div> 
 <pre><code class="language-java">import Vue from 'vue'
import Router from 'vue-router'
import HelloWorld from '@/components/HelloWorld'
import Hello from '@/components/hello' //导入自定义的组件

Vue.use(Router)

export default new Router({
  routes: [
    {
      path: '/',
      name: 'HelloWorld',
      component: HelloWorld
    },
    //新增路由
    {
      path: '/hello',
      name: "Hello",
      component: Hello
    }
  ]
})
</code></pre> 
</div> 
<p><strong>此时访问</strong><a href="http://localhost:8080/#/hello" rel="nofollow" title="http://localhost:8080/#/hello">http://localhost:8080/#/hello</a></p> 
<p><img alt="" height="445" src="https://images2.imgbox.com/01/14/BzodiLPC_o.png" width="515"></p> 
<p></p> 
<p><strong>添加App.vue点击跳转</strong>，修改/src/App.vue的template标签：</p> 
<div> 
 <pre><code class="language-html">&lt;template&gt;
  &lt;div id="app"&gt;
    &lt;img src="./assets/logo.png"&gt;
    &lt;router-link to="/hello"&gt;去hello&lt;/router-link&gt; &lt;!--新增去hello--&gt;
    &lt;router-link to="/"&gt;去首页&lt;/router-link&gt;&lt;!--新增去首页--&gt;
    &lt;router-view/&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre> 
</div> 
<p>运行测试效果</p> 
<p><img alt="" height="689" src="https://images2.imgbox.com/1a/66/6gUbcPt1_o.png" width="735"></p> 
<p></p> 
<p></p> 
<h4 id="5.3.6%E3%80%81%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90%E7%BB%84%E4%BB%B6%E6%A8%A1%E6%9D%BF"><a id="6_215"></a>5.3.7、快速生成组件模板</h4> 
<p>1、文件-&gt;首选项-&gt;用户代码 新建全局代码片段</p> 
<p>2、把下面代码粘贴进去</p> 
<div> 
 <pre><code class="language-java">{
    "Print to console": {
        "prefix": "vue",
        "body": [
            "&lt;!-- $1 --&gt;",
            "&lt;template&gt;",
            "&lt;div class='$2'&gt;$5&lt;/div&gt;",
            "&lt;/template&gt;",
            "",
            "&lt;script&gt;",
            "//这里可以导入其他文件（比如：组件，工具js，第三方插件js，json文件，图片文件等等）",
            "//例如：import 《组件名称》 from '《组件路径》';",
            "",
            "export default {",
            "//import引入的组件需要注入到对象中才能使用",
            "components: {},",
            "data() {",
            "//这里存放数据",
            "return {",
            "",
            "};",
            "},",
            "//监听属性 类似于data概念",
            "computed: {},",
            "//监控data中的数据变化",
            "watch: {},",
            "//方法集合",
            "methods: {",
            "",
            "},",
            "//生命周期 - 创建完成（可以访问当前this实例）",
            "created() {",
            "",
            "},",
            "//生命周期 - 挂载完成（可以访问DOM元素）",
            "mounted() {",
            "",
            "},",
            "beforeCreate() {}, //生命周期 - 创建之前",
            "beforeMount() {}, //生命周期 - 挂载之前",
            "beforeUpdate() {}, //生命周期 - 更新之前",
            "updated() {}, //生命周期 - 更新之后",
            "beforeDestroy() {}, //生命周期 - 销毁之前",
            "destroyed() {}, //生命周期 - 销毁完成",
            "activated() {}, //如果页面有keep-alive缓存功能，这个函数会触发",
            "}",
            "&lt;/script&gt;",
            "&lt;style scoped&gt;",
            "$4",
            "&lt;/style&gt;"
        ],
        "description": "生成vue模板"
    }
    
}
</code></pre> 
</div> 
<p>3、在创建组件时直接输入<code>vue</code>点击回车就可生成模板</p> 
<h3 id="5.4.%20ElementUI"><a id="4_ElementUI_293"></a>5.4. ElementUI</h3> 
<p>官方文档：https://element.eleme.cn/#/zh-CN/component/installation</p> 
<p>1、安装</p> 
<div> 
 <pre><code>npm install element-ui
</code></pre> 
</div> 
<p>2、在main.js下引入</p> 
<div> 
 <pre><code class="language-bash">import ElementUI from 'element-ui';
import 'element-ui/lib/theme-chalk/index.css';

Vue.use(ElementUI);
</code></pre> 
</div> 
<p>然后就可以使用elementui之中的组件。</p> 
<p>3、快速搭建后台管理系统的页面</p> 
<p>elementui手册中找到<code>Container 布局容器</code>，找到代码直接复制到<code>App.vue</code>组件</p> 
<p>启动测试：</p> 
<p><img alt="image-20210927111110073" src="https://images2.imgbox.com/c5/c6/9mOxX6bL_o.png">​</p> 
<p>4、实现当点击用户列表，显示用户。点击hello组件，显示hello。</p> 
<p><img alt="image-20210927111213237" src="https://images2.imgbox.com/78/50/l9s6jZfg_o.png">​</p> 
<p>把<code>&lt;el-main&gt;</code>中的数据列表换成路由视图<code>&lt;router-view&gt;&lt;/router-view&gt;</code></p> 
<p><img alt="image-20210927111502253" src="https://images2.imgbox.com/ff/8b/3IeF30X6_o.png">​</p> 
<p>新建MyTable组件，用来显示用户数据</p> 
<div> 
 <pre><code class="language-html">&lt;!--  --&gt;
&lt;template&gt;
  &lt;div class=""&gt;
    &lt;el-table :data="tableData"&gt;
      &lt;el-table-column prop="date" label="日期" width="140"&gt; &lt;/el-table-column&gt;
      &lt;el-table-column prop="name" label="姓名" width="120"&gt; &lt;/el-table-column&gt;
      &lt;el-table-column prop="address" label="地址"&gt; &lt;/el-table-column&gt;
    &lt;/el-table&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  data() {
    const item = {
      date: "2016-05-02",
      name: "王小虎",
      address: "上海市普陀区金沙江路 1518 弄",
    };
    return {
      tableData: Array(20).fill(item),
    };
  },
};
&lt;/script&gt;
&lt;style scoped&gt;
&lt;/style&gt;
</code></pre> 
</div> 
<p>添加路由规则</p> 
<div> 
 <pre><code class="language-javascript">import MyTable from '@/components/MyTable'


	{
      path: '/mytable',
      name: "mytable",
      components: MyTable
    }
</code></pre> 
</div> 
<p>修改App.vue</p> 
<p><img alt="image-20210927111630855" src="https://images2.imgbox.com/c5/c1/Y4KcfPHU_o.png">​</p> 
<p>启动测试</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c161622f4a5d46102c18d629003bda3b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">谷粒商城笔记&#43;踩坑（10）——商城首页和Nginx反向代理，thymeleaf&#43;动态展示三级分类</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7c470375452501578515355dc19077a5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Monocle3 基本流程复现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>