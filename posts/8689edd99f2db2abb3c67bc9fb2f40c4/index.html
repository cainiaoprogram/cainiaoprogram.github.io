<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>第三章 语言基础（中） 数据类型 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="第三章 语言基础（中） 数据类型" />
<meta property="og:description" content="3.4 数据类型 ECMAScript有6种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String和Symbol。Symbol（符号）是ECMAScript 6新增的。还有一种复杂数据类
型叫Object（对象）。Object是一种无序名值对的集合。因为在ECMAScript中不能定义自己的数据类型，所有值都可以用上述7种数据类型之一来表示。只有7种数据类型似乎不足以表示全部数据。但ECMAScript的数据类型很灵活，一种数据类型可以当作多种数据类型来使用。
3.4.1 typeof操作符 因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。typeof操作符就是为此而生的。对一个值使用typeof操作符会返回下列字符串之一：
&#34;undefined&#34;表示值未定义；&#34;boolean&#34;表示值为布尔值；&#34;string&#34;表示值为字符串；&#34;number&#34;表示值为数值；&#34;object&#34;表示值为对象（而不是函数）或null；&#34;function&#34;表示值为函数；&#34;symbol&#34;表示值为符号。 下面是使用typeof操作符的例子：
在这个例子中，我们把一个变量（message）和一个数值字面量传给了typeof操作符。注意，因为typeof是一个操作符而不是函数，所以不需要参数（但可以使用参数）。
注意typeof在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用typeof null返回的是&#34;object&#34;。这是因为特殊值null被认为是一个对空对象的引用。
注意 严格来讲，函数在ECMAScript中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过typeof操作符来区分函数和其他对象。
3.4.2 Undefined类型 Undefined类型只有一个值，就是特殊值undefined。当使用var或let声明了变量但没有初始化时，就相当于给变量赋予了undefined值：
在这个例子中，变量message在声明的时候并未初始化。而在比较它和undefined的字面值时，两者是相等的。这个例子等同于如下示例：
这里，变量message显式地以undefined来初始化。但这是不必要的，因为默认情况下，任何未经初始化的变量都会取得undefined值。
注意 一般来说，永远不用显式地给某个变量设置undefined值。字面值undefined主要用于比较，而且在ECMA-262第3版之前是不存在的。增加这个特殊值的目的就是为了正式明确空对象指针（null）和未初始化变量的区别。
注意，包含undefined值的变量跟未定义变量是有区别的。请看下面的例子：
在上面的例子中，第一个console.log会指出变量message的值，即&#34;undefined&#34;。而第二个console.log要输出一个未声明的变量age的值，因此会导致报错。对未声明的变量，只能执行一个有用的操作，就是对它调用typeof。（对未声明的变量调用delete也不会报错，但这个操作没什么用，实际上在严格模式下会抛出错误。）
在对未初始化的变量调用typeof时，返回的结果是&#34;undefined&#34;，但对未声明的变量调用它时，返回的结果还是&#34;undefined&#34;，这就有点让人看不懂了。比如下面的例子：
无论是声明还是未声明，typeof返回的都是字符串&#34;undefined&#34;。逻辑上讲这是对的，因为虽然严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。
注意 即使未初始化的变量会被自动赋予undefined值，但我们仍然建议在声明变量的同时进行初始化。这样，当typeof返回&#34;undefined&#34;时，你就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。
undefined是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可能的值同样是假值。所以一定要明确自己想检测的就是undefined这个字面值，而不仅仅是假值。 let message; // 这个变量被声明了，只是值为undefined // age没有声明 if (message) { // 这个块不会执行 } if (!message) { // 这个块会执行 } if (age) { // 这里会报错 } 3.4.3 Null类型 Null类型同样只有一个值，即特殊值null。逻辑上讲，null值表示一个空对象指针，这也是给typeof传一个null会返回&#34;object&#34;的原因：
在定义将来要保存对象值的变量时，建议使用null来初始化，不要使用其他值。这样，只要检查这个变量的值是不是null就可以知道这个变量是否在后来被重新赋予了一个对象的引用，比如：
if (car != null) { // car是一个对象的引用 } undefined值是由null值派生而来的，因此ECMA-262将它们定义为表面上相等，如下面的例子所示：
用等于操作符（==）比较null和undefined始终返回true。但要注意，这个操作符会为了比较而转换它的操作数。
即使null和undefined有关系，它们的用途也是完全不一样的。如前所述，永远不必显式地将变量值设置为undefined。但null不是这样的。任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用null来填充该变量。这样就可以保持null是空对象指针的语义，并进一步将其与undefined区分开来。
null是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可能的值同样是假值。所以一定要明确自己想检测的就是null这个字面值，而不仅仅是假值。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8689edd99f2db2abb3c67bc9fb2f40c4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-27T18:03:10+08:00" />
<meta property="article:modified_time" content="2023-12-27T18:03:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">第三章 语言基础（中） 数据类型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>3.4 数据类型</h4> 
<p>        ECMAScript有6种简单数据类型（也称为原始类型）：<strong>Undefined、Null、Boolean、Number、String和Symbol。</strong>Symbol（符号）是ECMAScript 6新增的。还有一种复杂数据类<br> 型叫<strong>Object（对象）</strong>。Object是一种无序名值对的集合。因为在ECMAScript中不能定义自己的数据类型，所有值都可以用上述7种数据类型之一来表示。只有7种数据类型似乎不足以表示全部数据。但ECMAScript的数据类型很灵活，一种数据类型可以当作多种数据类型来使用。</p> 
<p></p> 
<h5>3.4.1 typeof操作符</h5> 
<p>        因为ECMAScript的类型系统是松散的，所以需要一种手段来确定任意变量的数据类型。typeof操作符就是为此而生的。对一个值使用typeof操作符会返回下列字符串之一：</p> 
<ul><li>"undefined"表示值未定义；</li><li>"boolean"表示值为布尔值；</li><li>"string"表示值为字符串；</li><li>"number"表示值为数值；</li><li>"object"表示值为对象（而不是函数）或null；</li><li>"function"表示值为函数；</li><li>"symbol"表示值为符号。</li></ul> 
<p>下面是使用typeof操作符的例子：</p> 
<p><img alt="" height="400" src="https://images2.imgbox.com/e6/d4/2IbtAyto_o.png" width="819"></p> 
<p>        在这个例子中，我们把一个变量（message）和一个数值字面量传给了typeof操作符。注意，因为typeof是一个操作符而不是函数，所以不需要参数（但可以使用参数）。<br>         注意typeof在某些情况下返回的结果可能会让人费解，但技术上讲还是正确的。比如，调用typeof null返回的是"object"。这是因为特殊值null被认为是一个对空对象的引用。</p> 
<blockquote> 
 <p><strong>注意        </strong> 严格来讲，函数在ECMAScript中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过typeof操作符来区分函数和其他对象。</p> 
</blockquote> 
<p></p> 
<h5>3.4.2 Undefined类型</h5> 
<p>        Undefined类型只有一个值，就是特殊值undefined。当使用var或let声明了变量但没有初始化时，就相当于给变量赋予了undefined值：</p> 
<p><img alt="" height="352" src="https://images2.imgbox.com/0f/91/nxYw0EvO_o.png" width="768"></p> 
<p>        在这个例子中，变量message在声明的时候并未初始化。而在比较它和undefined的字面值时，两者是相等的。这个例子等同于如下示例：</p> 
<p><img alt="" height="308" src="https://images2.imgbox.com/2c/1c/PjodNLNk_o.png" width="777"></p> 
<p>        这里，变量message显式地以undefined来初始化。但这是不必要的，因为默认情况下，任何未经初始化的变量都会取得undefined值。</p> 
<blockquote> 
 <p><strong>注意         </strong>一般来说，永远不用显式地给某个变量设置undefined值。字面值undefined主要用于比较，而且在ECMA-262第3版之前是不存在的。增加这个特殊值的目的就是为了正式明确空对象指针（null）和未初始化变量的区别。</p> 
</blockquote> 
<p>        注意，包含undefined值的变量跟未定义变量是有区别的。请看下面的例子：</p> 
<p><img alt="" height="461" src="https://images2.imgbox.com/12/b6/vEotbrg3_o.png" width="772"></p> 
<p>        在上面的例子中，第一个console.log会指出变量message的值，即"undefined"。而第二个console.log要输出一个未声明的变量age的值，因此会导致报错。对未声明的变量，只能执行一个有用的操作，就是对它调用typeof。（对未声明的变量调用delete也不会报错，但这个操作没什么用，实际上在严格模式下会抛出错误。）<br>         在对未初始化的变量调用typeof时，返回的结果是"undefined"，但对未声明的变量调用它时，返回的结果还是"undefined"，这就有点让人看不懂了。比如下面的例子：</p> 
<p><img alt="" height="346" src="https://images2.imgbox.com/6c/41/ESCBbsSD_o.png" width="725"></p> 
<p>        无论是声明还是未声明，typeof返回的都是字符串"undefined"。逻辑上讲这是对的，因为虽然严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。</p> 
<blockquote> 
 <p><strong>注意</strong>         即使未初始化的变量会被自动赋予undefined值，但我们仍然建议在声明变量的同时进行初始化。这样，当typeof返回"undefined"时，你就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。</p> 
</blockquote> 
<p>        undefined是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可能的值同样是假值。所以一定要明确自己想检测的就是undefined这个字面值，而不仅仅是假值。 </p> 
<pre><code class="language-javascript">let message; // 这个变量被声明了，只是值为undefined
// age没有声明
if (message) {
// 这个块不会执行
}
if (!message) {
// 这个块会执行
}
if (age) {
// 这里会报错
}</code></pre> 
<p></p> 
<h5>3.4.3 Null类型</h5> 
<p>        Null类型同样只有一个值，即特殊值null。逻辑上讲，null值表示一个空对象指针，这也是给typeof传一个null会返回"object"的原因：</p> 
<p><img alt="" height="325" src="https://images2.imgbox.com/f3/76/qOrC1AyA_o.png" width="690"></p> 
<p>        在定义将来要保存对象值的变量时，建议使用null来初始化，不要使用其他值。这样，只要检查这个变量的值是不是null就可以知道这个变量是否在后来被重新赋予了一个对象的引用，比如：</p> 
<pre><code class="language-javascript">if (car != null) {
// car是一个对象的引用
}</code></pre> 
<p>        undefined值是由null值派生而来的，因此ECMA-262将它们定义为表面上相等，如下面的例子所示：</p> 
<p><img alt="" height="273" src="https://images2.imgbox.com/0b/f5/ryx3iFhx_o.png" width="699"></p> 
<p>        用等于操作符（==）比较null和undefined始终返回true。但要注意，这个操作符会为了比较而转换它的操作数。<br>         即使null和undefined有关系，它们的用途也是完全不一样的。如前所述，永远不必显式地将变量值设置为undefined。但null不是这样的。任何时候，只要变量要保存对象，而当时又没有那个对象可保存，就要用null来填充该变量。这样就可以保持null是空对象指针的语义，并进一步将其与undefined区分开来。<br>         null是一个假值。因此，如果需要，可以用更简洁的方式检测它。不过要记住，也有很多其他可能的值同样是假值。所以一定要明确自己想检测的就是null这个字面值，而不仅仅是假值。</p> 
<pre><code class="language-javascript">let message = null;
let age;
if (message) {
// 这个块不会执行
}
if (!message) {
// 这个块会执行
}
if (age) {
// 这个块不会执行
}
if (!age) {
// 这个块会执行
}</code></pre> 
<p></p> 
<h5>3.4.4 Boolean类型</h5> 
<p>        Boolean（布尔值）类型是ECMAScript中使用最频繁的类型之一，有两个字面值：true和false。这两个布尔值不同于数值，因此true不等于1，false不等于0。下面是给变量赋布尔值的例子：</p> 
<pre><code class="language-javascript">let found = true;
let lost = false;</code></pre> 
<p>        注意，布尔值字面量true和false是区分大小写的，因此True和False（及其他大小混写形式）是有效的标识符，但不是布尔值。<br>         虽然布尔值只有两个，但所有其他ECMAScript类型的值都有相应布尔值的等价形式。要将一个其他类型的值转换为布尔值，可以调用特定的Boolean()转型函数：</p> 
<pre><code class="language-javascript">let message = "Hello world!";
let messageAsBoolean = Boolean(message);</code></pre> 
<p>        在这个例子中，字符串message会被转换为布尔值并保存在变量messageAsBoolean中。Boolean()转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值。什么值能转换为true或false的规则取决于数据类型和实际的值。下表总结了不同类型与布尔值之间的转换规则。</p> 
<p> <img alt="" height="352" src="https://images2.imgbox.com/10/4d/7SnENRzk_o.png" width="1086"></p> 
<p><img alt="" height="331" src="https://images2.imgbox.com/56/c1/uOKNkfsk_o.png" width="1097"></p> 
<p>        理解以上转换非常重要，因为像if等流控制语句会自动执行其他类型值到布尔值的转换，例如：</p> 
<pre><code class="language-javascript">let message = "Hello world!";
if (message) {
    console.log("Value is true");
}</code></pre> 
<p>        在这个例子中，console.log会输出字符串"Value is true"，因为字符串message会被自动转换为等价的布尔值true。由于存在这种自动转换，理解流控制语句中使用的是什么变量就非常重要。错误地使用对象而不是布尔值会明显改变应用程序的执行流。</p> 
<p></p> 
<h5>3.4.5 Number类型</h5> 
<p>        ECMAScript中最有意思的数据类型或许就是Number了。Number类型使用IEEE 754格式表示整数和浮点值（在某些语言中也叫双精度值）。不同的数值类型相应地也有不同的数值字面量格式。最基本的数值字面量格式是十进制整数，直接写出来即可：</p> 
<pre><code class="language-javascript">let intNum = 55; // 整数</code></pre> 
<p>        整数也可以用八进制（以8为基数）或十六进制（以16为基数）字面量表示。对于八进制字面量，第一个数字必须是零（0），然后是相应的八进制数字（数值0~7）。如果字面量中包含的数字超出了应有的范围，就会忽略前缀的零，后面的数字序列会被当成十进制数，如下所示：</p> 
<pre><code class="language-javascript">let octalNum1 = 070; // 八进制的56
let octalNum2 = 079; // 无效的八进制值，当成79处理
let octalNum3 = 08; // 无效的八进制值，当成8处理
</code></pre> 
<p>        八进制字面量在严格模式下是无效的，会导致JavaScript引擎抛出语法错误。</p> 
<p>        要创建十六进制字面量，必须让真正的数值前缀0x（区分大小写），然后是十六进制数字（0~9以及A~F）。十六进制数字中的字母大小写均可。下面是几个例子：</p> 
<pre><code class="language-javascript">let hexNum1 = 0xA; // 十六进制10
let hexNum2 = 0x1f; // 十六进制31</code></pre> 
<p>        使用八进制和十六进制格式创建的数值在所有数学操作中都被视为十进制数值。</p> 
<blockquote> 
 <p><strong>注意</strong>         由于JavaScript保存数值的方式，实际中可能存在正零（+0）和负零（-0）。正零和负零在所有情况下都被认为是等同的，这里特地说明一下。</p> 
</blockquote> 
<p></p> 
<h6>1.浮点值</h6> 
<p>        要定义浮点值，数值中必须包含小数点，而且小数点后面必须至少有一个数字。虽然小数点前面不是必须有整数，但推荐加上。下面是几个例子：</p> 
<pre><code class="language-javascript">let floatNum1 = 1.1;
let floatNum2 = 0.1;
let floatNum3 = .1; // 有效，但不推荐</code></pre> 
<p>        因为存储浮点值使用的内存空间是存储整数值的两倍，所以ECMAScript总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整<br> 数，只是小数点后面跟着0（如1.0），那它也会被转换为整数，如下例所示：</p> 
<pre><code class="language-javascript">let floatNum1 = 1.; // 小数点后面没有数字，当成整数1处理
let floatNum2 = 10.0; // 小数点后面是零，当成整数10处理
</code></pre> 
<p>        对于非常大或非常小的数值，浮点值可以用科学记数法来表示。科学记数法用于表示一个应该乘以10的给定次幂的数值。ECMAScript中科学记数法的格式要求是一个数值（整数或浮点数）后跟一个大写或小写的字母e，再加上一个要乘的10的多少次幂。比如：</p> 
<pre><code class="language-javascript">let floatNum = 3.125e7; // 等于31250000</code></pre> 
<p>        在这个例子中，floatNum等于31 250 000，只不过科学记数法显得更简洁。这种表示法实际上相当于说：“以3.125作为系数，乘以10的7次幂。”<br>         科学记数法也可以用于表示非常小的数值，例如0.000 000 000 000000 03。这个数值用科学记数法可以表示为3e-17。默认情况下，ECMAScript会将小数点后至少包含6个零的浮点值转换为科学记数法（例如，0.000 000 3会被转换为3e-7）。<br>         浮点值的精确度最高可达17位小数，但在算术计算中远不如整数精确。例如，0.1加0.2得到的不是0.3，而是0.300 000 000 000 00004。由于这种微小的舍入错误，导致很难测试特定的浮点值。比如下面的例子：</p> 
<pre><code class="language-javascript">if (a + b == 0.3) { // 别这么干！
    console.log("You got 0.3.");
}</code></pre> 
<p>        这里检测两个数值之和是否等于0.3。如果两个数值分别是0.05和0.25，或者0.15和0.15，那没问题。但如果是0.1和0.2，如前所述，测试将失败。因此永远不要测试某个特定的浮点值。</p> 
<blockquote> 
 <p><strong>注意</strong>         之所以存在这种舍入错误，是因为使用了IEEE 754数值，这种错误并非ECMAScript所独有。其他使用相同格式的语言也有这个问题。</p> 
</blockquote> 
<p></p> 
<h6>2. 值的范围</h6> 
<p>        由于内存的限制，ECMAScript并不支持表示这个世界上的所有数值。ECMAScript可以表示的最小数值保存在Number.MIN_VALUE中，这个值在多数浏览器中是5e-324；可以表示的最大数值保存在Number.MAX_VALUE中，这个值在多数浏览器中是1.797 693 134 862 315 7e+308。如果某个计算得到的数值结果超出了JavaScript可以表示的范围，那么这个数值会被自动转换为一个特殊的Infinity（无穷）值。任何无法表示的负数以-Infinity（负无穷大）表示，任何无法表示的正数以Infinity（正无穷大）表示。<br>         如果计算返回正Infinity或负Infinity，则该值将不能再进一步用于任何计算。这是因为Infinity没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于JavaScript能表示的最小值和最大值之间），可以使用isFinite()函数，如下所示：</p> 
<pre><code class="language-javascript">let result = Number.MAX_VALUE + Number.MAX_VALUE;
console.log(isFinite(result)); // false</code></pre> 
<p>        虽然超出有限数值范围的计算并不多见，但总归还是有可能的。因此在计算非常大或非常小的数值时，有必要监测一下计算结果是否超出范围。</p> 
<blockquote> 
 <p><strong>注意</strong>         使用Number.NEGATIVE_INFINITY和Number.POSITIVE_INFINITY也可以获取正、负Infinity。没错，这两个属性包含的值分别就是-Infinity和Infinity。</p> 
</blockquote> 
<p></p> 
<h6>3. NaN</h6> 
<p>        有一个特殊的数值叫NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作失败了（而不是抛出错误）。比如，用0除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在ECMAScript中，0、+0或-0相除会返回NaN：</p> 
<pre><code class="language-javascript">console.log(0/0); // NaN
console.log(-0/+0); // NaN</code></pre> 
<p>        如果分子是非0值，分母是有符号0或无符号0，则会返回Infinity或-Infinity：</p> 
<pre><code class="language-javascript">console.log(5/0); // Infinity
console.log(5/-0); // -Infinity</code></pre> 
<p>        NaN有几个独特的属性。首先，任何涉及NaN的操作始终返回NaN（如NaN/10），在连续多步计算时这可能是个问题。其次，NaN不等于包括NaN在内的任何值。例如，下面的比较操作会返回false：</p> 
<pre><code class="language-javascript">console.log(NaN == NaN); // false</code></pre> 
<p>        为此，ECMAScript提供了isNaN()函数。该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。把一个值传给isNaN()后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，如字符串"10"或布尔值。任何不能转换为数值的值都会导致这个函数返回true。举例如下：</p> 
<p><img alt="" height="487" src="https://images2.imgbox.com/e0/b0/mpwZ26J8_o.png" width="863"></p> 
<p>        上述的例子测试了5个不同的值。首先测试的是NaN本身，显然会返回true。接着测试了数值10和字符串"10"，都返回false，因为它们的数值都是10。字符串"blue"不能转换为数值，因此函数返回true。布尔值true可以转换为数值1，因此返回false。</p> 
<blockquote> 
 <p><strong>注意         </strong>虽然不常见，但isNaN()可以用于测试对象。此时，首先会调用对象的valueOf()方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用toString()方法，并测试其返回值。</p> 
</blockquote> 
<p></p> 
<h6 style="background-color:transparent;">4. 数值转换</h6> 
<p>        有3个函数可以将非数值转换为数值：Number()、parseInt()和parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。对于同样的参数，这3个函数执行的操作也不同。<br>         Number()函数基于如下规则执行转换。</p> 
<ul><li>布尔值，true转换为1，false转换为0。</li><li>数值，直接返回。</li><li>null，返回0。</li><li>undefined，返回NaN。</li><li>字符串，应用以下规则。</li></ul> 
<ol><li>如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。因此，Number("1")返回1，Number("123")返回123，Number("011")返回11（忽略前面的零）。</li><li>如果字符串包含有效的浮点值格式如"1.1"，则会转换为相应的浮点值（同样，忽略前面的零）。</li><li>如果字符串包含有效的十六进制格式如"0xf"，则会转换为与该十六进制值对应的十进制整数值。</li><li>如果是空字符串（不包含字符），则返回0。如果字符串包含除上述情况之外的其他字符，则返回NaN。</li></ol> 
<ul><li>对象，调用valueOf()方法，并按照上述规则转换返回的值。如果转换结果是NaN，则调用toString()方法，再按照转换字符串的规则转换。</li></ul> 
<p>        从不同数据类型到数值的转换有时候会比较复杂，看一看Number()的转换规则就知道了。下面是几个具体的例子：</p> 
<p><img alt="" height="515" src="https://images2.imgbox.com/b5/ba/VOnjjhrv_o.png" width="823"></p> 
<p>        可以看到，字符串"Hello world"转换之后是NaN，因为它找不到对应的数值。空字符串转换后是0。字符串000011转换后是11，因为前面的零被忽略了。最后，true转换为1。</p> 
<p>        考虑到用Number()函数转换字符串时相对复杂且有点反常规，通常在需要得到整数时可以优先使用parseInt()函数。parseInt()函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt()立即返回NaN。这意味着空字符串也会返回NaN（这一点跟Number()不一样，它返回0）。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。比如，"1234blue"会被转换为1234，因为"blue"会被完全忽略。类似地，"22.5"会被转换为22，因为小数点不是有效的整数字符。<br>         假设字符串中的第一个字符是数值字符，parseInt()函数也能识别不同的整数格式（十进制、八进制、十六进制）。换句话说，如果字符串以"0x"开头，就会被解释为十六进制整数。如果字符串以"0"开头，且紧跟着数值字符，在非严格模式下会被某些实现解释为八进制整数。<br>         下面几个转换示例有助于理解上述规则：</p> 
<p><img alt="" height="717" src="https://images2.imgbox.com/8d/12/hjh2aDoA_o.png" width="846"></p> 
<p>        不同的数值格式很容易混淆，因此parseInt()也接收第二个参数，用于指定底数（进制数）。如果知道要解析的值是十六进制，那么可以传入16作为第二个参数，以便正确解析</p> 
<pre><code class="language-javascript">let num = parseInt("0xAF", 16); // 175</code></pre> 
<p>        事实上，如果提供了十六进制参数，那么字符串前面的"0x"可以省掉：</p> 
<pre><code class="language-javascript">let num1 = parseInt("AF", 16); // 175
let num2 = parseInt("AF"); // NaN</code></pre> 
<p>        在这个例子中，第一个转换是正确的，而第二个转换失败了。区别在于第一次传入了进制数作为参数，告诉parseInt()要解析的是一个十六进制字符串。而第二个转换检测到第一个字符就是非数值字符，随即自动停止并返回NaN。<br>         通过第二个参数，可以极大扩展转换后获得的结果类型。比如：</p> 
<p><img alt="" height="523" src="https://images2.imgbox.com/31/c3/blyUlj5L_o.png" width="833"></p> 
<p>        因为不传底数参数相当于让parseInt()自己决定如何解析，所以为避免解析出错，建议始终传给它第二个参数。</p> 
<blockquote> 
 <p><strong>注意         </strong>多数情况下解析的应该都是十进制数，此时第二个参数就要传入10。</p> 
</blockquote> 
<p>        parseFloat()函数的工作方式跟parseInt()函数类似，都是从位置0开始检测每个字符。同样，它也是解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。因此，"22.34.5"将转换成22.34。<br>         parseFloat()函数的另一个不同之处在于，它始终忽略字符串开头的零。这个函数能识别前面讨论的所有浮点格式，以及十进制格式（开头的零始终被忽略）。十六进制数值始终会返回0。因<br> 为parseFloat()只解析十进制值，因此不能指定底数。最后，如果字符串表示整数（没有小数点或者小数点后面只有一个零），则parseFloat()返回整数。下面是几个示例：</p> 
<p><img alt="" height="710" src="https://images2.imgbox.com/08/fc/n4qhRwhl_o.png" width="847"></p> 
<p></p> 
<h5>3.4.6 String类型</h5> 
<p>        String（字符串）数据类型表示零或多个16位Unicode字符序列。字符串可以使用双引号（"）、单引号（'）或反引号（`）标示，因此下面的代码都是合法的：</p> 
<pre><code class="language-javascript">let firstName = "John";
let lastName = 'Jacob';
let lastName = `Jingleheimerschmidt`</code></pre> 
<p>        跟某些语言中使用不同的引号会改变对字符串的解释方式不同，ECMAScript语法中表示字符串的引号没有区别。不过要注意的是，以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾。比如，下面的写法会导致语法错误：</p> 
<pre><code class="language-javascript">let firstName = 'Nicholas"; // 语法错误：开头和结尾的引号必须是同一种</code></pre> 
<h6>1.字符字面量</h6> 
<p>        字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符，如下表所示：</p> 
<p><img alt="" height="707" src="https://images2.imgbox.com/6b/c9/doSkDZMQ_o.png" width="1028"></p> 
<p>        这些字符字面量可以出现在字符串中的任意位置，且可以作为单个字符被解释：</p> 
<pre><code class="language-javascript">let text = "This is the letter sigma: \u03a3.";</code></pre> 
<p>        在这个例子中，即使包含6个字符长的转义序列，变量text仍然是28个字符长。因为转义序列表示一个字符，所以只算一个字符。字符串的长度可以通过其length属性获取：</p> 
<pre><code class="language-javascript">console.log(text.length); // 28</code></pre> 
<p>        这个属性返回字符串中16位字符的个数。</p> 
<blockquote> 
 <p><strong>注意         </strong>如果字符串中包含双字节字符，那么length属性返回的值可能不是准确的字符数。</p> 
</blockquote> 
<p></p> 
<h6>2.字符串的特点</h6> 
<p>        ECMAScript中的字符串是不可变的（immutable），意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量，如下所示：</p> 
<pre><code class="language-javascript">let lang = "Java";
lang = lang + "Script";</code></pre> 
<p>        这里，变量lang一开始包含字符串"Java"。紧接着，lang被重新定义为包含"Java"和"Script"的组合，也就是"JavaScript"。整个过程首先会分配一个足够容纳10个字符的空间，然后填充<br> 上"Java"和"Script"。最后销毁原始的字符串"Java"和字符串"Script"，因为这两个字符串都没有用了。所有处理都是在后台发生的，而这也是一些早期的浏览器（如Firefox 1.0之前的版本和IE6.0）在拼接字符串时非常慢的原因。这些浏览器在后来的版本中都有针对性地解决了这个问题。</p> 
<p></p> 
<h6>3.转换为字符串</h6> 
<p>        有两种方式把一个值转换为字符串。首先是使用几乎所有值都有的toString()方法。这个方法唯一的用途就是返回当前值的字符串等价物。比如：</p> 
<pre><code class="language-javascript">let age = 11;
let ageAsString = age.toString(); // 字符串"11"
let found = true;
let foundAsString = found.toString(); // 字符串"true"</code></pre> 
<p>        toString()方法可见于数值、布尔值、对象和字符串值。（没错，字符串值也有toString()方法，该方法只是简单地返回自身的一个副本。）null和undefined值没有toString()方法。<br>         多数情况下，toString()不接收任何参数。不过，在对数值调用这个方法时，toString()可以接收一个底数参数，即以什么底数来输出数值的字符串表示。默认情况下，toString()返回数值的十进制字符串表示。而通过传入参数，可以得到数值的二进制、八进制、十六进制，或者其他任何有效基数的字符串表示，比如：</p> 
<pre><code class="language-javascript">let num = 10;
console.log(num.toString()); // "10"
console.log(num.toString(2)); // "1010"
console.log(num.toString(8)); // "12"
console.log(num.toString(10)); // "10"
console.log(num.toString(16)); // "a"</code></pre> 
<p>        这个例子展示了传入底数参数时，toString()输出的字符串值也会随之改变。数值10可以输出为任意数值格式。注意，默认情况下（不传参数）的输出与传入参数10得到的结果相同。<br>         如果你不确定一个值是不是null或undefined，可以使用String()转型函数，它始终会返回表示相应类型值的字符串。String()函数遵循如下规则。</p> 
<ul><li>如果值有toString()方法，则调用该方法（不传参数）并返回结果。</li><li>如果值是null，返回"null"。</li><li>如果值是undefined，返回"undefined"。</li></ul> 
<p>        下面看几个例子：</p> 
<pre><code class="language-javascript">let value1 = 10;
let value2 = true;
let value3 = null;
let value4;
console.log(String(value1)); // "10"
console.log(String(value2)); // "true"
console.log(String(value3)); // "null"
console.log(String(value4)); // "undefined"</code></pre> 
<p>        这里展示了将4个值转换为字符串的情况：一个数值、一个布尔值、一个null和一个undefined。数值和布尔值的转换结果与调用toString()相同。因为null和undefined没有toString()方法，所以String()方法就直接返回了这两个值的字面量文本。</p> 
<blockquote> 
 <p><strong>注意         </strong>用加号操作符给一个值加上一个空字符串""也可以将其转换为字符串。</p> 
</blockquote> 
<p></p> 
<h6>4.模板字面量</h6> 
<p>        ECMAScript 6新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量保留换行字符，可以跨行定义字符串：</p> 
<p><img alt="" height="641" src="https://images2.imgbox.com/37/94/N51dSDUF_o.png" width="1093"></p> 
<p>        顾名思义，模板字面量在定义模板时特别有用，比如下面这个HTML模板：</p> 
<pre><code class="language-html">let pageHTML = `
&lt;div&gt;
    &lt;a href="#"&gt;
        &lt;span&gt;Jake&lt;/span&gt;
    &lt;/a&gt;
&lt;/div&gt;`;</code></pre> 
<p>        由于模板字面量会保持反引号内部的空格，因此在使用时要格外注意。格式正确的模板字符串可能会看起来缩进不当：</p> 
<pre><code class="language-javascript">// 这个模板字面量在换行符之后有25个空格符
let myTemplateLiteral = `first line
                         second line`;
console.log(myTemplateLiteral.length); // 47
// 这个模板字面量以一个换行符开头
let secondTemplateLiteral = `
first line
second line`;
console.log(secondTemplateLiteral[0] === '\n'); // true
// 这个模板字面量没有意料之外的字符
let thirdTemplateLiteral = `first line
second line`;
console.log(thirdTemplateLiteral);
// first line
// second line</code></pre> 
<p></p> 
<h6>5.字符串插值</h6> 
<p>        模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是一种特殊的JavaScript句法表达式，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。<br>         字符串插值通过在${}中使用一个JavaScript表达式实现：</p> 
<pre><code class="language-javascript">let value = 5;
let exponent = 'second';
// 以前，字符串插值是这样实现的：
let interpolatedString =
value + ' to the ' + exponent + ' power is ' + (value * value);
// 现在，可以用模板字面量这样实现：
let interpolatedTemplateLiteral =
`${ value } to the ${ exponent } power is ${ value * value }`;
console.log(interpolatedString); // 5 to the second power is 25
console.log(interpolatedTemplateLiteral); // 5 to the second power is 25</code></pre> 
<p>        所有插入的值都会使用toString()强制转型为字符串，而且任何JavaScript表达式都可以用于插值。嵌套的模板字符串无须转义：</p> 
<pre><code class="language-javascript">console.log(`Hello, ${ `World` }!`); // Hello, World!</code></pre> 
<p>        将表达式转换为字符串时会调用toString()：</p> 
<pre><code class="language-javascript">let foo = { toString: () =&gt; 'World' };
console.log(`Hello, ${ foo }!`); // Hello, World!</code></pre> 
<p>        在插值表达式中可以调用函数和方法：</p> 
<pre><code class="language-javascript">function capitalize(word) {
return `${ word[0].toUpperCase() }${ word.slice(1) }`;
}
console.log(`${ capitalize('hello') }, ${ capitalize('world') }!`); // Hello, Word！</code></pre> 
<p>        此外，模板也可以插入自己之前的值：</p> 
<pre><code class="language-javascript">let value = '';
function append() {
    value = `${value}abc`
    console.log(value);
}
append(); // abc
append(); // abcabc
append(); // abcabcabc</code></pre> 
<p></p> 
<h6>6.模板字面量标签函数</h6> 
<p>        模板字面量也支持定义标签函数（tag function），而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。<br>         标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为，如下例所示。标签函数接收到的参数依次是原始字符串数组和对每个表达式求值的结果。这个函数的返回值是对模板字面量求值得到的字符串。<br>         最好通过一个例子来理解：</p> 
<pre><code class="language-javascript">let a = 6;
let b = 9;
function simpleTag(strings, aValExpression, bValExpression, sumExpression) {
    console.log(strings);
    console.log(aValExpression);
    console.log(bValExpression);
    console.log(sumExpression);
    return 'foobar';
}
let untaggedResult = `${ a } + ${ b } = ${ a + b }`;
let taggedResult = simpleTag`${ a } + ${ b } = ${ a + b }`;
// ["", " + ", " = ", ""]
// 6
// 9
// 15
console.log(untaggedResult); // "6 + 9 = 15"
console.log(taggedResult); // "foobar"</code></pre> 
<p>        因为表达式参数的数量是可变的，所以通常应该使用剩余操作符（rest operator）将它们收集到一个数组中：</p> 
<pre><code class="language-javascript">let a = 6;
let b = 9;
function simpleTag(strings, ...expressions) {
    console.log(strings);
    for(const expression of expressions) {
    console.log(expression);
    }
    return 'foobar';
}
let taggedResult = simpleTag`${ a } + ${ b } = ${ a + b }`;
// ["", " + ", " = ", ""]
// 6
// 9
// 15
console.log(taggedResult); // "foobar"</code></pre> 
<p>        对于有 n个插值的模板字面量，传给标签函数的表达式参数的个数始终是n ，而传给标签函数的第一个参数所包含的字符串个数则始终是 n+1。因此，如果你想把这些字符串和对表达式求值的结果拼接起来作为默认返回的字符串，可以这样做：</p> 
<pre><code class="language-javascript">let a = 6;
let b = 9;
function zipTag(strings, ...expressions) {
    return strings[0] +
            expressions.map((e, i) =&gt; `${e}${strings[i + 1]}`)
                    .join('');
}
let untaggedResult = `${ a } + ${ b } = ${ a + b }`;
let taggedResult = zipTag`${ a } + ${ b } = ${ a + b }`;
console.log(untaggedResult); // "6 + 9 = 15"
console.log(taggedResult); // "6 + 9 = 15"
</code></pre> 
<p></p> 
<h6>7.原始字符串</h6> 
<p>        使用模板字面量也可以直接获取原始的模板字面量内容（如换行符或Unicode字符），而不是被转换后的字符表示。为此，可以使用默认的String.raw标签函数：</p> 
<pre><code class="language-javascript">// Unicode示例
// \u00A9是版权符号
console.log(`\u00A9`); // ©
console.log(String.raw`\u00A9`); // \u00A9
// 换行符示例
console.log(`first line\nsecond line`);
// first line
// second line
console.log(String.raw`first line\nsecond line`); // "first line\nsecond line"
// 对实际的换行符来说是不行的
// 它们不会被转换成转义序列的形式
console.log(`first line
second line`);
// first line
// second line
console.log(String.raw`first line
second line`);
// first line
// second line</code></pre> 
<p>        另外，也可以通过标签函数的第一个参数，即字符串数组的.raw属性取得每个字符串的原始内容：</p> 
<pre><code class="language-javascript">function printRaw(strings) {
    console.log('Actual characters:');
    for (const string of strings) {
        console.log(string);
}
    console.log('Escaped characters;');
    for (const rawString of strings.raw) {
        console.log(rawString);
    }
}
printRaw`\u00A9${ 'and' }\n`;
// Actual characters:
// ©
//（换行符）
// Escaped characters:
// \u00A9
// \n
</code></pre> 
<p></p> 
<h5>3.4.7 Symbol类型</h5> 
<p>        Symbol（符号）是ECMAScript 6新增的数据类型。符号是原始值，且符号实例是唯一、不可变的。符号的用途是确保对象属性使用唯一标识符，不会发生属性冲突的危险。<br>         尽管听起来跟私有属性有点类似，但符号并不是为了提供私有属性的行为才增加的（尤其是因为Object API提供了方法，可以更方便地发现符号属性）。相反，符号就是用来创建唯一记号，进而用作非字符串形式的对象属性。</p> 
<p></p> 
<h6>1.符号的基本用法</h6> 
<p>        符号需要使用Symbol()函数初始化。因为符号本身是原始类型，所以typeof操作符对符号返回symbol。</p> 
<pre><code class="language-javascript">let sym = Symbol();
console.log(typeof sym); // symbol</code></pre> 
<p>        调用Symbol()函数时，也可以传入一个字符串参数作为对符号的描述（description），将来可以通过这个字符串来调试代码。但是，这个字符串参数与符号定义或标识完全无关：</p> 
<pre><code class="language-javascript">let genericSymbol = Symbol();
let otherGenericSymbol = Symbol();
let fooSymbol = Symbol('foo');
let otherFooSymbol = Symbol('foo');
console.log(genericSymbol == otherGenericSymbol); // false
console.log(fooSymbol == otherFooSymbol); // false</code></pre> 
<p>        符号没有字面量语法，这也是它们发挥作用的关键。按照规范，你只要创建Symbol()实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性，无论是符号属性还是字符串属性。</p> 
<pre><code class="language-javascript">let genericSymbol = Symbol();
console.log(genericSymbol); // Symbol()
let fooSymbol = Symbol('foo');
console.log(fooSymbol); // Symbol(foo);
</code></pre> 
<p>        最重要的是，Symbol()函数不能用作构造函数，与new关键字一起使用。这样做是为了避免创建符号包装对象，像使用Boolean、String或Number那样，它们都支持构造函数且可用于初始化包含原始值的包装对象：</p> 
<pre><code class="language-javascript">let myBoolean = new Boolean();
console.log(typeof myBoolean); // "object"

let myString = new String();
console.log(typeof myString); // "object"

let myNumber = new Number();
console.log(typeof myNumber); // "object"

let mySymbol = new Symbol(); // TypeError: Symbol is not a constructor</code></pre> 
<p>        如果你确实想使用符号包装对象，可以借用Object()函数：</p> 
<pre><code class="language-javascript">let mySymbol = Symbol();
let myWrappedSymbol = Object(mySymbol);
console.log(typeof myWrappedSymbol); // "object"</code></pre> 
<p></p> 
<h6>2. 使用全局符号注册表</h6> 
<p>        如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册表中创建并重用符号。<br>         为此，需要使用Symbol.for()方法：</p> 
<pre><code class="language-javascript">let fooGlobalSymbol = Symbol.for('foo');
console.log(typeof fooGlobalSymbol); // symbol</code></pre> 
<p>        Symbol.for()对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。</p> 
<pre><code class="language-javascript">let fooGlobalSymbol = Symbol.for('foo'); // 创建新符号
let otherFooGlobalSymbol = Symbol.for('foo'); // 重用已有符号
console.log(fooGlobalSymbol === otherFooGlobalSymbol); // true
</code></pre> 
<p>        即使采用相同的符号描述，在全局注册表中定义的符号跟使用Symbol()定义的符号也并不等同：</p> 
<pre><code class="language-javascript">let localSymbol = Symbol('foo');
let globalSymbol = Symbol.for('foo');
console.log(localSymbol === globalSymbol); // false</code></pre> 
<p>        全局注册表中的符号必须使用字符串键来创建，因此作为参数传给Symbol.for()的任何值都会被转换为字符串。此外，注册表中使用的键同时也会被用作符号描述。</p> 
<pre><code class="language-javascript">let emptyGlobalSymbol = Symbol.for();
console.log(emptyGlobalSymbol); // Symbol(undefined)</code></pre> 
<p>        还可以使用Symbol.keyFor()来查询全局注册表，这个方法接收符号，返回该全局符号对应的字符串键。如果查询的不是全局符号，则返回undefined。</p> 
<pre><code class="language-javascript">// 创建全局符号
let s = Symbol.for('foo');
console.log(Symbol.keyFor(s)); // foo
// 创建普通符号
let s2 = Symbol('bar');
console.log(Symbol.keyFor(s2)); // undefined</code></pre> 
<p>        如果传给Symbol.keyFor()的不是符号，则该方法抛出TypeError：</p> 
<pre><code class="language-javascript">Symbol.keyFor(123); // TypeError: 123 is not a symbol</code></pre> 
<p></p> 
<h6>3.使用符号作为属性</h6> 
<p>        凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和Object.defineProperty()/Object.defineProperties()定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。</p> 
<pre><code class="language-javascript">let s1 = Symbol('foo'),
s2 = Symbol('bar'),
s3 = Symbol('baz'),
s4 = Symbol('qux');
let o = {
[s1]: 'foo val'
};
// 这样也可以：o[s1] = 'foo val';
console.log(o);
// {Symbol(foo): foo val}
Object.defineProperty(o, s2, {value: 'bar val'});
console.log(o);
// {Symbol(foo): foo val, Symbol(bar): bar val}
Object.defineProperties(o, {
[s3]: {value: 'baz val'},
[s4]: {value: 'qux val'}
});
console.log(o);
// {Symbol(foo): foo val, Symbol(bar): bar val,
// Symbol(baz): baz val, Symbol(qux): qux val}</code></pre> 
<p>        类似于Object.getOwnPropertyNames()返回对象实例的常规属性数组，Object.getOwnPropertySymbols()返回对象实例的符号属性数组。这两个方法的返回值彼此互斥。Object.getOwnPropertyDescriptors()会返回同时包含常规和符号属性描述符的对象。Reflect.ownKeys()会返回两种类型的键：</p> 
<pre><code class="language-javascript">et s1 = Symbol('foo'),
s2 = Symbol('bar');
let o = {
[s1]: 'foo val',
[s2]: 'bar val',
baz: 'baz val',
qux: 'qux val'
};
console.log(Object.getOwnPropertySymbols(o));
// [Symbol(foo), Symbol(bar)]
console.log(Object.getOwnPropertyNames(o));
// ["baz", "qux"]
console.log(Object.getOwnPropertyDescriptors(o));
// {baz: {...}, qux: {...}, Symbol(foo): {...}, Symbol(bar): {...}}
console.log(Reflect.ownKeys(o));
// ["baz", "qux", Symbol(foo), Symbol(bar)]</code></pre> 
<p>        因为符号属性是对内存中符号的一个引用，所以直接创建并用作属性的符号不会丢失。但是，如果没有显式地保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性键：</p> 
<pre><code class="language-javascript">let o = {
[Symbol('foo')]: 'foo val',
[Symbol('bar')]: 'bar val'
};
console.log(o);
// {Symbol(foo): "foo val", Symbol(bar): "bar val"}
let barSymbol = Object.getOwnPropertySymbols(o)
.find((symbol) =&gt; symbol.toString().match(/bar/));
console.log(barSymbol);
// Symbol(bar)</code></pre> 
<p></p> 
<h6>4.常用内置符号</h6> 
<p>        ECMAScript 6也引入了一批常用内置符号（well-known symbol），用于暴露语言内部行为，开发者可以直接访问、重写或模拟这些行为。这些内置符号都以Symbol工厂函数字符串属性的形式存在。<br>         这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，我们知道for-of循环会在相关对象上使用Symbol.iterator属性，那么就可以通过在自定义对象上重新定<br> 义Symbol.iterator的值，来改变for-of在迭代该对象时的行为。<br>         这些内置符号也没有什么特别之处，它们就是全局函数Symbol的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。</p> 
<blockquote> 
 <p><strong>注意         </strong>在提到ECMAScript规范时，经常会引用符号在规范中的名称，前缀为@@。比如，@@iterator指的就是Symbol.iterator。</p> 
</blockquote> 
<p></p> 
<h6></h6> 
<h5>3.4.8 Object类型</h5> 
<p>        ECMAScript中的对象其实就是一组数据和功能的集合。对象通过new操作符后跟对象类型的名称来创建。开发者可以通过创建Object类型的实例来创建自己的对象，然后再给对象添加属性和方法：</p> 
<pre><code class="language-javascript">let o = new Object();</code></pre> 
<p>        这个语法类似Java，但ECMAScript只要求在给构造函数提供参数时使用括号。如果没有参数，如上面的例子所示，那么完全可以省略括号（不推荐）：</p> 
<pre><code class="language-javascript">let o = new Object; // 合法，但不推荐</code></pre> 
<p>        Object的实例本身并不是很有用，但理解与它相关的概念非常重要。类似Java中的java.lang.Object，ECMAScript中的Object也是派生其他对象的基类。Object类型的所有属性和方法在派生的对象上同样存在。<br>         每个Object实例都有如下属性和方法。</p> 
<ul><li>constructor：用于创建当前对象的函数。在前面的例子中，这个属性的值就是Object()函数。</li><li>hasOwnProperty(propertyName)：用于判断当前对象实例（不是原型）上是否存在给定的属性。要检查的属性名必须是字符串（如o.hasOwnProperty("name")）或符号。</li><li>isPrototypeOf(object)：用于判断当前对象是否为另一个对象的原型。</li><li>propertyIsEnumerable(propertyName)：用于判断给定的属性是否可以使用for-in语句枚举。与hasOwnProperty()一样，属性名必须是字符串。</li><li>toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</li><li>toString()：返回对象的字符串表示。</li><li>valueOf()：返回对象对应的字符串、数值或布尔值表示。通常与toString()的返回值相同。</li></ul> 
<p>        因为在ECMAScript中Object是所有对象的基类，所以任何对象都有这些属性和方法。</p> 
<blockquote> 
 <p><strong>注意</strong>         严格来讲，ECMA-262中对象的行为不一定适合JavaScript中的其他对象。比如浏览器环境中的BOM和DOM对象，都是由宿主环境定义和提供的宿主对象。而宿主对象不受ECMA-262约束，所以它们可能会也可能不会继承Object。</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/89a70ee026f6ece06e1cec53bfa99eb3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">身份证正则表达式验证（高级版）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ce5f914097a0ea7caa6c6be12a81d65b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">字体使用软件分享（电脑软件）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>