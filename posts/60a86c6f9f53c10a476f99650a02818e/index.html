<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>矩概念与图像矩详解及其hu矩的运用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="矩概念与图像矩详解及其hu矩的运用" />
<meta property="og:description" content="一、矩概念详解 矩这个东西，能组成的名词太多了，矩形，就是长方形，矩阵，就是m行n列的二维数组，所以想了解矩，就要从其具体的场景中去理解。
今天我们要讲的图像矩，就是一个新的概念，图像矩就是图像的矩，这个概念来源于数学中的矩，所以我们要先来理解一下，数学中的矩。首先我们先来看一下它的定义和相关概念：
在数学和统计学中，矩（moment）是对变量分布和形态特点的一组度量。当所有的变
量矩的定义是各点对某一固定点离差幂的平均值。n阶矩被定义为一变量的n次方与其概率密度函数（ProbabilityDensity Function, PDF）之积的积分。在文献中n阶矩通常用符号μn表示。
直接使用变量计算的矩被称为原始矩（raw moment），移除均值后计算的矩被称为中心矩（central moment）。
1、离散情况 我们从矩的概念出发，我们先考虑离散情况：
假设有一个离散的随机变量X，用A表示一个常数，用k来表示幂（阶数）。那么我们有下面这个公式：
这个称为X关于点A的k阶矩。
如果这个常数A为0，我们把这个k阶矩称之为k阶原点矩。
如果这个常数A为X的均值E(X)，我们把这个k阶矩称之为k阶中心矩。
变量的一阶矩是数学期望（expectation），表示分布重心；
变量的二阶矩是方差（variance），表示离散程度；
变量的三阶矩是偏度（skewness），表示分布偏离对称的程度；
变量的四阶矩是峰度（kurtosis），描述分布的尖峰程度，例如正态分布峰态系数=0。 如果我们有两个离散随机变量：X,Y。A1，A2分别代表对应于两个随机变量的常数，用p，q表示幂（阶数），那么我们有下面的公式：
这个称为X，Y关于点A1，A2的p&#43;q阶矩。
如果两个常数都是0，那么我们称之为p&#43;q阶混合原点矩。
如果两个常数都是对应的均值，即A1=E(X)，A2=E(Y)，那么我们称之为p&#43;q阶混合中心矩。
2、连续情况 接下来我们考虑连续情况：
假设有一个连续的随机变量x，其单变量的概率密度函数为f(x)，用A表示一个常数，用k来表示幂（阶数）。那么我们有下面这个公式：
这个称为X关于点A的k阶矩。 如果我们有两个连续的随机变量：x,y，两个变量的联合概率密度为f(x,y)。A1，A2分别代表对应于两个随机变量的常数，用p，q表示幂（阶数），那么我们有下面的公式： 这个称为x，y关于点A1，A2的p&#43;q阶矩。
一阶原点矩就是期望。二阶中心矩就是随机变量的的方差. 在统计学上，高于4阶的矩极少使用。三阶中心距可以去衡量分布是否有偏。四阶中心矩可以去衡量分布在均值附近的陡峭程度如何。
二、图像的几何矩 1、几何矩的概念 了解了矩的概念，我们接下来说一下图像的几何矩。在图像中，矩的概念如下：
矩是描述图像特征的算子。
这里的图像是单通道，也就是灰度图像，相当于一个矩阵，也就是上面提到的离散的情况。矩阵上每个位置的取值范围是0-255的整数。
2、图像的p&#43;q阶矩 一阶原点矩就是期望。二阶中心矩就是随机变量的的方差. 在统计学上，高于4阶的矩极少使用。三阶中心距可以去衡量分布是否有偏。四阶中心矩可以去衡量分布在均值附近的陡峭程度如何。
那针对一幅图像，我们把像素的坐标看成是一个二维随机变量(X, Y)，那么一副灰度图可以用二维灰度图密度函数来表示，因此可以用矩来描述灰度图像的特征。 空间矩的实质为面积或者质量。可以通过一阶矩计算质心/重心。 图像的重心坐标 为：
物体形状方向 为：
3、HU矩 把图像的像素看做密度函数f(x,y)f(x,y)，对该像素点求期望，即是图像的矩（原点矩）
一般来说，一阶矩和零阶矩可以计算某个形状的重心，二阶矩可以计算形状的方向。
图像的矩主要表征了图像区域的几何特征，又称几何矩，由于具有旋转、平移、尺度等不变的特兴奋，所以又称为不变矩。
利用不变矩可以计算出物体的圆形度（物体形状和园的接近程度）、物体的矩形度（物体形状和矩形的接近程度）、物体的水平和垂直对称性、物体的主轴方向、扁度等。
几何矩： 中心距： 由几何矩可表示出中心距： 请注意，上述中心距是平移不变的。 换句话说，无论图像中的斑点在哪里，如果形状相同，则矩将是相同的。
如果我们还能让这个距具有尺度不变，那会不会很酷？ 那么，为此，我们需要标准化的中心矩，如下所示。
归一化中心距： 其中r=p&#43;q&#43;2, p&#43;q=2,3,…r=p&#43;q&#43;22,p&#43;q=2,3,…
中心距是平移不变的。 但这还不足以进行形状匹配。 我们想要计算对平移，缩放和旋转不变的矩，如下图所示。
幸运的是，我们实际上可以计算出这样的距，他们被称为Hu不变距。
7个Hu不变距计算如下：
感兴趣的可以尝试推导一下，这些都是关于图像的平移，缩放大小，旋转等参数不变性的推导式，
hu不变距的数学依据" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/60a86c6f9f53c10a476f99650a02818e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-25T15:19:27+08:00" />
<meta property="article:modified_time" content="2020-04-25T15:19:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">矩概念与图像矩详解及其hu矩的运用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_2"></a>一、矩概念详解</h2> 
<p>矩这个东西，能组成的名词太多了，矩形，就是长方形，矩阵，就是m行n列的二维数组，所以想了解矩，就要从其具体的场景中去理解。</p> 
<p>今天我们要讲的图像矩，就是一个新的概念，图像矩就是图像的矩，这个概念来源于数学中的矩，所以我们要先来理解一下，数学中的矩。首先我们先来看一下它的定义和相关概念：</p> 
<blockquote> 
 <p><font size="3" face="微软雅黑">       在数学和统计学中，矩（moment）是<font color="#29C1E"><strong>对变量分布和形态特点的一组度量。</strong></font>当所有的变<br> 量矩的定义是<font color="#29C1E"><strong>各点对某一固定点离差幂的平均值。</strong></font>n阶矩被定义为<font color="#29C1E"><strong>一变量的n次方与其概率密度函数（ProbabilityDensity Function, PDF）之积的积分。</strong></font>在文献中n阶矩通常用符号μn表示。<br><br> <font size="3" color="#29C1E" face="微软雅黑"> <strong>直接使用变量计算的矩被称为原始矩（raw moment），移除均值后计算的矩被称为中心矩（central moment）。</strong></font></font></p> 
</blockquote> 
<h3><a id="1_12"></a>1、离散情况</h3> 
<p>我们从矩的概念出发，我们先考虑离散情况：</p> 
<p>假设有一个离散的随机变量X，用A表示一个常数，用k来表示幂（阶数）。那么我们有下面这个公式：</p> 
<p><img src="https://images2.imgbox.com/db/7c/6cPMxGWt_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><font size="3" face="微软雅黑">这个称为<font color="#29C1E"><strong>X关于点A的k阶矩。</strong></font><br> 如果这个常数A为0，我们把这个k阶矩称之为k阶<font color="#29C1E"><strong>原点矩。</strong></font><br> 如果这个常数A为X的均值E(X)，我们把这个k阶矩称之为<font color="#29C1E"><strong>k阶中心矩。</strong></font><br><br> <font color="#29C1E"><strong>变量的一阶矩是数学期望（expectation），表示分布重心；<br> 变量的二阶矩是方差（variance），表示离散程度；<br> 变量的三阶矩是偏度（skewness），表示分布偏离对称的程度；<br> 变量的四阶矩是峰度（kurtosis），描述分布的尖峰程度，例如正态分布峰态系数=0。</strong></font> </font></p> 
</blockquote> 
<blockquote> 
 <p><font size="3" face="微软雅黑">如果我们有两个离散随机变量：X,Y。A1，A2分别代表对应于两个随机变量的常数，用p，q表示幂（阶数），那么我们有下面的公式：<br> <img src="https://images2.imgbox.com/a5/e5/DwI0Ikvm_o.png" alt="在这里插入图片描述"><br> 这个称为X，Y关于点A1，A2的p+q阶矩。<br> 如果两个常数都是0，那么我们称之为<font color="#29C1E"><strong>p+q阶混合原点矩。</strong></font><br> 如果两个常数都是对应的均值，即A1=E(X)，A2=E(Y)，那么我们称之为<font color="#29C1E"><strong>p+q阶混合中心矩。</strong></font></font></p> 
</blockquote> 
<h3><a id="2_35"></a>2、连续情况</h3> 
<blockquote> 
 <p><font size="3" face="微软雅黑"> 接下来我们考虑连续情况：<br><br> 假设有一个连续的随机变量x，其单变量的概率密度函数为f(x)，用A表示一个常数，用k来表示幂（阶数）。那么我们有下面这个公式：</font></p> 
 <p><img src="https://images2.imgbox.com/1c/96/pJUqwVpb_o.png" alt="在这里插入图片描述"></p> 
 <font size="3" face="微软雅黑"> 这个称为X关于点A的k阶矩。 <font size="3" face="微软雅黑"> 如果我们有两个连续的随机变量：x,y，两个变量的联合概率密度为f(x,y)。A1，A2分别代表对应于两个随机变量的常数，用p，q表示幂（阶数），那么我们有下面的公式： </font></font> 
 <p><img src="https://images2.imgbox.com/58/4b/sNQ92FEX_o.png" alt="在这里插入图片描述"></p> 
 <p><font size="3" face="微软雅黑">这个称为x，y关于点A1，A2的p+q阶矩。<br> 一阶原点矩就是期望。二阶中心矩就是随机变量的的方差. 在统计学上，高于4阶的矩极少使用。三阶中心距可以去衡量分布是否有偏。四阶中心矩可以去衡量分布在均值附近的陡峭程度如何。</font></p> 
</blockquote> 
<h2><a id="_54"></a>二、图像的几何矩</h2> 
<h3><a id="1_55"></a>1、几何矩的概念</h3> 
<p>了解了矩的概念，我们接下来说一下图像的几何矩。在图像中，矩的概念如下：</p> 
<blockquote> 
 <p><font size="3" color="#29C1E"><strong>矩是描述图像特征的算子。</strong></font></p> 
</blockquote> 
<p>这里的图像是单通道，也就是灰度图像，相当于一个矩阵，也就是上面提到的离散的情况。矩阵上每个位置的取值范围是0-255的整数。</p> 
<h3><a id="2pq_61"></a>2、图像的p+q阶矩</h3> 
<p>一阶原点矩就是期望。二阶中心矩就是随机变量的的方差. 在统计学上，高于4阶的矩极少使用。三阶中心距可以去衡量分布是否有偏。四阶中心矩可以去衡量分布在均值附近的陡峭程度如何。</p> 
<p><font size="3" color="#29C1E"><strong>那针对一幅图像，我们把像素的坐标看成是一个二维随机变量(X, Y)，那么一副灰度图可以用二维灰度图密度函数来表示，因此可以用矩来描述灰度图像的特征。</strong> </font></p> 
<p><img src="https://images2.imgbox.com/dd/08/GhKatzmL_o.png" alt="在这里插入图片描述"></p> 
<p>空间矩的实质<font size="3" color="#29C1E"><strong>为面积或者质量。可以通过一阶矩计算质心/重心。</strong> </font></p> 
<p>图像的<font size="3" color="#29C1E"><strong>重心坐标</strong> </font>为：</p> 
<p><img src="https://images2.imgbox.com/4e/77/gg3DyPoi_o.png" alt="在这里插入图片描述"></p> 
<p>物体<font size="3" color="#29C1E"><strong>形状方向</strong> </font>为：<br> <img src="https://images2.imgbox.com/6e/cb/jBTX7kGh_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/11/bf/GUyojohN_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3HU_82"></a>3、HU矩</h3> 
<p>把图像的像素看做密度函数f(x,y)f(x,y)，对该像素点求期望，即是图像的矩（原点矩）</p> 
<p>一般来说，一阶矩和零阶矩可以计算某个形状的重心，二阶矩可以计算形状的方向。</p> 
<p>图像的矩主要表征了图像区域的几何特征，又称几何矩，由于具有旋转、平移、尺度等不变的特兴奋，所以又称为不变矩。<br> 利用不变矩可以计算出物体的圆形度（物体形状和园的接近程度）、物体的矩形度（物体形状和矩形的接近程度）、物体的水平和垂直对称性、物体的主轴方向、扁度等。</p> 
<h4><a id="_90"></a>几何矩：</h4> 
<p><img src="https://images2.imgbox.com/44/74/UE77Jd38_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="httpsimgblogcsdnimgcn20200304115019393pngpic_centerhttpsimgblogcsdnimgcn20200304115019393pngpic_center_93"></a>中心距：<img src="https://images2.imgbox.com/19/5e/ar5I25nQ_o.png" alt="(https://img-blog.csdnimg.cn/20200304115019393.png#pic_center"></h4> 
<h5><a id="_94"></a>由几何矩可表示出中心距：</h5> 
<p><img src="https://images2.imgbox.com/f1/dc/UwvSJeHv_o.jpg" alt="在这里插入图片描述"></p> 
<p>请注意，上述中心距是平移不变的。 换句话说，无论图像中的斑点在哪里，如果形状相同，则矩将是相同的。</p> 
<p>如果我们还能让这个距具有尺度不变，那会不会很酷？ 那么，为此，我们需要标准化的中心矩，如下所示。</p> 
<h4><a id="_101"></a>归一化中心距：</h4> 
<p><img src="https://images2.imgbox.com/98/f9/rkwVts9k_o.png" alt="在这里插入图片描述"></p> 
<p><strong>其中r=p+q+2, p+q=2,3,…r=p+q+22,p+q=2,3,…</strong></p> 
<p>中心距是平移不变的。 但这还不足以进行形状匹配。 我们想要计算对平移，缩放和旋转不变的矩，如下图所示。</p> 
<p>幸运的是，我们实际上可以计算出这样的距，他们被称为Hu不变距。</p> 
<p><img src="https://images2.imgbox.com/76/fd/yWgyBHqg_o.png" alt="在这里插入图片描述"><br> 7个Hu不变距计算如下：</p> 
<p><img src="https://images2.imgbox.com/1a/0e/E7UKxNEr_o.png" alt="在这里插入图片描述"><br> 感兴趣的可以尝试推导一下，这些都是关于图像的平移，缩放大小，旋转等参数不变性的推导式，<br> hu不变距的数学依据</p> 
<p>在OpenCV中计算Hu不变距：<br> <img src="https://images2.imgbox.com/f8/0a/fXEQ6TTm_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="4_Log_119"></a>4. Log转化</h3> 
<p>K的7维Hu不变距<br> <img src="https://images2.imgbox.com/f9/9c/mgsLHifR_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a8/b7/YL2B6VS4_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="Python_123"></a>Python</h4> 
<pre><code class="prism language-python"><span class="token comment"># Log scale hu moments</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  huMoments<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token operator">*</span> copysign<span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> huMoments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> log10<span class="token punctuation">(</span><span class="token builtin">abs</span><span class="token punctuation">(</span>huMoments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="C_131"></a>C++</h4> 
<pre><code class="prism language-c"><span class="token comment">// Log scale hu moments</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">7</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  huMoments<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">*</span> <span class="token function">copysign</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">,</span> huMoments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">log10</span><span class="token punctuation">(</span><span class="token function">abs</span><span class="token punctuation">(</span>huMoments<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
</code></pre> 
<h3><a id="5_Hu_139"></a>5. 基于Hu不变距的形状匹配</h3> 
<h4><a id="Hu_140"></a>计算Hu距：</h4> 
<p><img src="https://images2.imgbox.com/b1/b9/eKu15zh6_o.png" alt="在这里插入图片描述"><br> 如图所见，图像K0.png只是字母K，S0.png是字母S.接下来，我们在S1.png中移动字母S，并在S2.png中移动+缩放。 我们添加了一些旋转来制作S3.png并进一步翻转图像以制作S4.png。</p> 
<p>注意，S0，S1，S2，S3和S4的所有Hu矩在值上彼此接近，除了翻转S4的最后Hu矩的符号。 另外，请注意它们与K0非常不同。</p> 
<h4><a id="51__148"></a>5.1 匹配形状的距离</h4> 
<p>在本节中，我们将学习如何使用Hu Moments来找到两个形状之间的距离。 如果距离小，则形状在外观上接近，并且如果距离大，则形状在外观上更加分开。</p> 
<p>OpenCV提供了一个易于使用的名为matchShapes的实用程序函数，它接收两个图像（或轮廓）并使用Hu Moments找到它们之间的距离。 所以，你不必明确计算胡时刻。 只需将图像二值化并使用matchShapes。</p> 
<p>用法如下所示。</p> 
<h4><a id="Python_155"></a>Python</h4> 
<pre><code class="prism language-python">d1 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>matchShapes<span class="token punctuation">(</span>im1<span class="token punctuation">,</span>im2<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>CONTOURS_MATCH_I1<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
d2 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>matchShapes<span class="token punctuation">(</span>im1<span class="token punctuation">,</span>im2<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>CONTOURS_MATCH_I2<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
d3 <span class="token operator">=</span> cv2<span class="token punctuation">.</span>matchShapes<span class="token punctuation">(</span>im1<span class="token punctuation">,</span>im2<span class="token punctuation">,</span>cv2<span class="token punctuation">.</span>CONTOURS_MATCH_I3<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="C_162"></a>C++</h4> 
<pre><code class="prism language-c++">double d1 = matchShapes(im1, im2, CONTOURS_MATCH_I1, 0);
double d2 = matchShapes(im1, im2, CONTOURS_MATCH_I2, 0);
double d3 = matchShapes(im1, im2, CONTOURS_MATCH_I3, 0);
</code></pre> 
<p>第一个参数是待匹配的物体1<br> 第二个是待匹配的物体2<br> 第三个参数method有三种输入：【即三种不同的判定物体相似的方法】</p> 
<ol><li>CV_CONTOURS_MATCH_I1</li><li>CV_CONTOURS_MATCH_I2</li><li>CV_CONTOURS_MATCH_I3</li></ol> 
<p>令D（A，B）为形状A和B之间的距离，并且和为形状A和B的对数变换的Hu矩。定义对应于三种情况的距离 如<br> <img src="https://images2.imgbox.com/ea/06/Nbr4883C_o.png" alt="在这里插入图片描述"><br> 当然也可以自己定义一个hu矩之间的距离：（欧几里德距离）<br> <img src="https://images2.imgbox.com/6a/d3/j66omPEM_o.png" alt="在这里插入图片描述"></p> 
<p>参考文章：</p> 
<p>https://blog.csdn.net/shuiyixin/article/details/104646531<br> https://blog.csdn.net/lql0716/article/details/68267829<br> https://blog.csdn.net/red_ear/article/details/86165142</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/89ffc39700c4d5e37178301da4eab485/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">css遇到的坑：一行文字内容没有填满，就跑去下一行去了。看着很不舒服。怎么办？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3874c61e3a058f341a4c09c313cca0a8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MATLAB-Control System Toolbox™&amp;0.控制系统工具箱说明</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>