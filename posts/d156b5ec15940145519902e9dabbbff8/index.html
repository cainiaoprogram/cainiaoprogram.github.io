<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2018年上海后半年JAVA软件工程师面试真题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2018年上海后半年JAVA软件工程师面试真题" />
<meta property="og:description" content="查询超过该部门员工大于3个的部门 SELECT deptid FROM table1
GROUP BY deptid
HAVING COUNT(deptid) &gt; 3
如果员工名称重复的部门id
SELECT deptid FROM table1
GROUP BY deptid
HAVING COUNT(empname) &gt; 3
单例模式 package com.day01; public class 单例模式 { private final static 单例模式 INSTANCE = new 单例模式(); private 单例模式(){ } public static 单例模式 getInstance(){ return INSTANCE;}} 1 需要写个类
2 在类里面new 一个自己，private final static
3 私有无参构造
4 static 方法，返回自己
3.冒泡排序 package com.day01;
public class 冒泡排序 {
public static void main(String[] args) {" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d156b5ec15940145519902e9dabbbff8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-12-29T00:19:00+08:00" />
<meta property="article:modified_time" content="2018-12-29T00:19:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2018年上海后半年JAVA软件工程师面试真题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <ol><li><strong>查询超过该部门员工大于3个的部门</strong></li></ol> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><strong><span style="color:#323e4f;">SELECT</span></strong> deptid <strong><span style="color:#323e4f;">FROM</span></strong> table1</p> <p style="margin-left:0cm;"><strong><span style="color:#323e4f;">GROUP</span></strong><span style="color:#323e4f;"> <strong>BY</strong> </span>deptid</p> <p style="margin-left:0cm;"><strong><span style="color:#323e4f;">HAVING</span></strong><span style="color:#323e4f;"> <strong>COUNT</strong></span>(deptid) &gt; 3</p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;">如果员工名称重复的部门id</p> 
 <p style="margin-left:0cm;"><strong><span style="color:#323e4f;">SELECT</span></strong> deptid <strong><span style="color:#323e4f;">FROM</span></strong> table1</p> 
 <p style="margin-left:0cm;"><strong><span style="color:#323e4f;">GROUP</span></strong><span style="color:#323e4f;"> <strong>BY</strong> </span>deptid</p> 
 <p style="margin-left:0cm;"><strong><span style="color:#323e4f;">HAVING</span></strong><span style="color:#323e4f;"> <strong>COUNT</strong></span>(empname) &gt; 3</p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <ol><li><strong>单例模式</strong></li></ol> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> 
     <ol><li><strong><span style="color:#7f0055;">package</span></strong><span style="color:#000000;"> com.day01;</span></li><li> </li><li><strong><span style="color:#7f0055;">public</span></strong> <strong><span style="color:#7f0055;">class</span></strong> <span style="color:#000000;">单例模式</span><span style="color:#000000;"> {<!-- --></span></li><li> </li><li> </li><li><strong><span style="color:#7f0055;">private</span></strong> <strong><span style="color:#7f0055;">final</span></strong> <strong><span style="color:#7f0055;">static</span></strong> <span style="color:#000000;">单例模式</span> <strong><em><span style="color:#0000c0;">INSTANCE</span></em></strong><span style="color:#000000;"> = </span><strong><span style="color:#7f0055;">new</span></strong> <span style="color:#000000;">单例模式</span><span style="color:#000000;">();</span></li><li> </li><li><strong><span style="color:#7f0055;">private</span></strong> <span style="color:#000000;">单例模式</span><span style="color:#000000;">(){<!-- --></span></li><li>   </li><li><span style="color:#000000;">}</span></li><li> </li><li><strong><span style="color:#7f0055;">public</span></strong> <strong><span style="color:#7f0055;">static</span></strong> <span style="color:#000000;">单例模式</span><span style="color:#000000;">  getInstance(){<!-- --></span></li><li>    <strong><span style="color:#7f0055;">return</span></strong> <strong><em><span style="color:#0000c0;">INSTANCE</span></em></strong><span style="color:#000000;">;</span></li><li><span style="color:#000000;">}</span></li><li><span style="color:#000000;">}</span></li></ol></td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;">1 需要写个类</p> 
 <p style="margin-left:0cm;">2 在类里面new 一个自己，private final static</p> 
 <p style="margin-left:0cm;">3 私有无参构造</p> 
 <p style="margin-left:0cm;">4 static 方法，返回自己</p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>3.冒泡排序</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><strong><span style="color:#7f0055;">package</span></strong><span style="color:#000000;"> com.day01;</span></p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;"><strong><span style="color:#7f0055;">public</span></strong> <strong><span style="color:#7f0055;">class</span></strong> <span style="color:#000000;">冒泡排序</span><span style="color:#000000;"> {<!-- --></span></p> <p style="margin-left:0cm;">  </p> <p style="margin-left:0cm;">   <strong><span style="color:#7f0055;">public</span></strong> <strong><span style="color:#7f0055;">static</span></strong> <strong><span style="color:#7f0055;">void</span></strong><span style="color:#000000;"> main(String[] </span><span style="color:#6a3e3e;">args</span><span style="color:#000000;">) {<!-- --></span></p> <p style="margin-left:0cm;">     </p> <p style="margin-left:0cm;">     </p> <p style="margin-left:0cm;">      <strong><span style="color:#7f0055;">int</span></strong><span style="color:#000000;">[] </span><span style="color:#6a3e3e;">arr</span><span style="color:#000000;"> = {3,2,1};</span></p> <p style="margin-left:0cm;">     </p> <p style="margin-left:0cm;">      <strong><span style="color:#7f0055;">for</span></strong><span style="color:#000000;"> (</span><strong><span style="color:#7f0055;">int</span></strong> <span style="color:#6a3e3e;">i</span><span style="color:#000000;"> = 0; </span><span style="color:#6a3e3e;">i</span><span style="color:#000000;"> &lt; </span><span style="color:#6a3e3e;">arr</span><span style="color:#000000;">.</span><span style="color:#0000c0;">length</span><span style="color:#000000;"> - </span><span style="color:#6a3e3e;">i</span><span style="color:#000000;">; </span><span style="color:#6a3e3e;">i</span><span style="color:#000000;">++) {<!-- --></span></p> <p style="margin-left:0cm;">        </p> <p style="margin-left:0cm;">         <strong><span style="color:#7f0055;">for</span></strong><span style="color:#000000;"> (</span><strong><span style="color:#7f0055;">int</span></strong> <span style="color:#6a3e3e;">j</span><span style="color:#000000;"> = 0; </span><span style="color:#6a3e3e;">j</span><span style="color:#000000;"> &lt; </span><span style="color:#6a3e3e;">arr</span><span style="color:#000000;">.</span><span style="color:#0000c0;">length</span><span style="color:#000000;"> - 1 - </span><span style="color:#6a3e3e;">i</span><span style="color:#000000;">; </span><span style="color:#6a3e3e;">j</span><span style="color:#000000;">++) {<!-- --></span></p> <p style="margin-left:0cm;">           </p> <p style="margin-left:0cm;">            <strong><span style="color:#7f0055;">if</span></strong><span style="color:#000000;">(</span><span style="color:#6a3e3e;">arr</span><span style="color:#000000;">[</span><span style="color:#6a3e3e;">j</span><span style="color:#000000;">] &gt; </span><span style="color:#6a3e3e;">arr</span><span style="color:#000000;">[</span><span style="color:#6a3e3e;">j</span><span style="color:#000000;">+1]){<!-- --></span></p> <p style="margin-left:0cm;">               </p> <p style="margin-left:0cm;">                <strong><span style="color:#7f0055;">int</span></strong> <span style="color:#6a3e3e;">temp</span><span style="color:#000000;"> = </span><span style="color:#6a3e3e;">arr</span><span style="color:#000000;">[</span><span style="color:#6a3e3e;">j</span><span style="color:#000000;">];</span></p> <p style="margin-left:0cm;">               </p> <p style="margin-left:0cm;">                <span style="color:#6a3e3e;">arr</span><span style="color:#000000;">[</span><span style="color:#6a3e3e;">j</span><span style="color:#000000;">] = </span><span style="color:#6a3e3e;">arr</span><span style="color:#000000;">[</span><span style="color:#6a3e3e;">j</span><span style="color:#000000;">+1];</span></p> <p style="margin-left:0cm;">               </p> <p style="margin-left:0cm;">                <span style="color:#6a3e3e;">arr</span><span style="color:#000000;">[</span><span style="color:#6a3e3e;">j</span><span style="color:#000000;">+1] = </span><span style="color:#6a3e3e;">temp</span><span style="color:#000000;">;</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">            }</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">         }</span></p> <p style="margin-left:0cm;">        </p> <p style="margin-left:0cm;"><span style="color:#000000;">      }</span></p> <p style="margin-left:0cm;">     </p> <p style="margin-left:0cm;"><span style="color:#000000;">      System.</span><strong><em><span style="color:#0000c0;">out</span></em></strong><span style="color:#000000;">.println(</span><span style="color:#6a3e3e;">arr</span><span style="color:#000000;">[0]);</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">      System.</span><strong><em><span style="color:#0000c0;">out</span></em></strong><span style="color:#000000;">.println(</span><span style="color:#6a3e3e;">arr</span><span style="color:#000000;">[1]);</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">      System.</span><strong><em><span style="color:#0000c0;">out</span></em></strong><span style="color:#000000;">.println(</span><span style="color:#6a3e3e;">arr</span><span style="color:#000000;">[2]);</span></p> <p style="margin-left:0cm;">     </p> <p style="margin-left:0cm;"><span style="color:#000000;">   }</span></p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;"><span style="color:#000000;">}</span></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>4.找关键字次数</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><strong><span style="color:#7f0055;">package</span></strong><span style="color:#000000;"> com.day01;</span></p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;"><strong><span style="color:#7f0055;">import</span></strong><span style="color:#000000;"> java.io.BufferedReader;</span></p> <p style="margin-left:0cm;"><strong><span style="color:#7f0055;">import</span></strong><span style="color:#000000;"> java.io.File;</span></p> <p style="margin-left:0cm;"><strong><span style="color:#7f0055;">import</span></strong><span style="color:#000000;"> java.io.FileInputStream;</span></p> <p style="margin-left:0cm;"><strong><span style="color:#7f0055;">import</span></strong><span style="color:#000000;"> java.io.InputStreamReader;</span></p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;"><strong><span style="color:#7f0055;">public</span></strong> <strong><span style="color:#7f0055;">class</span></strong> <span style="color:#000000;">找关键字次数</span><span style="color:#000000;"> {<!-- --></span></p> <p style="margin-left:0cm;">  </p> <p style="margin-left:0cm;">   <strong><span style="color:#7f0055;">public</span></strong> <strong><span style="color:#7f0055;">static</span></strong> <strong><span style="color:#7f0055;">void</span></strong><span style="color:#000000;"> main(String[] </span><span style="color:#6a3e3e;">args</span><span style="color:#000000;">) </span><strong><span style="color:#7f0055;">throws</span></strong><span style="color:#000000;"> Exception {<!-- --></span></p> <p style="margin-left:0cm;">     </p> <p style="margin-left:0cm;"><span style="color:#000000;">      StringBuilder </span><span style="color:#6a3e3e;">sBuilder</span><span style="color:#000000;"> = </span><strong><span style="color:#7f0055;">new</span></strong><span style="color:#000000;"> StringBuilder();   </span><span style="color:#3f7f5f;">// </span><span style="color:#3f7f5f;">创建拼接字符串</span></p> <p style="margin-left:0cm;">     </p> <p style="margin-left:0cm;"><span style="color:#000000;">      File </span><span style="color:#6a3e3e;">file</span><span style="color:#000000;"> = </span><strong><span style="color:#7f0055;">new</span></strong><span style="color:#000000;"> File(</span><span style="color:#2a00ff;">"F:\\get.txt"</span><span style="color:#000000;">);   </span><span style="color:#3f7f5f;">// </span><span style="color:#3f7f5f;">读取文件</span></p> <p style="margin-left:0cm;">     </p> <p style="margin-left:0cm;">      <span style="color:#3f7f5f;">//</span><span style="color:#3f7f5f;">创建</span><span style="color:#3f7f5f;">IO</span><span style="color:#3f7f5f;">留独处文件</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">       InputStreamReader </span><span style="color:#6a3e3e;">isr</span><span style="color:#000000;"> = </span><strong><span style="color:#7f0055;">new</span></strong><span style="color:#000000;"> InputStreamReader(</span><strong><span style="color:#7f0055;">new</span></strong><span style="color:#000000;"> FileInputStream(</span><span style="color:#6a3e3e;">file</span><span style="color:#000000;">), </span><span style="color:#2a00ff;">"utf-8"</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">       BufferedReader </span><span style="color:#6a3e3e;">br</span><span style="color:#000000;"> = </span><strong><span style="color:#7f0055;">new</span></strong><span style="color:#000000;"> BufferedReader(</span><span style="color:#6a3e3e;">isr</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;">       <span style="color:#3f7f5f;">//</span><span style="color:#3f7f5f;">用于暂时保存文本内容</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">       String </span><span style="color:#6a3e3e;">lineTxt</span><span style="color:#000000;"> = </span><strong><span style="color:#7f0055;">null</span></strong><span style="color:#000000;">;</span></p> <p style="margin-left:0cm;">       <span style="color:#3f7f5f;">//</span><span style="color:#3f7f5f;">循环读取</span></p> <p style="margin-left:0cm;">       <strong><span style="color:#7f0055;">while</span></strong><span style="color:#000000;"> ((</span><span style="color:#6a3e3e;">lineTxt</span><span style="color:#000000;"> = </span><span style="color:#6a3e3e;">br</span><span style="color:#000000;">.readLine()) != </span><strong><span style="color:#7f0055;">null</span></strong><span style="color:#000000;">) {<!-- --></span></p> <p style="margin-left:0cm;">         <span style="color:#6a3e3e;">sBuilder</span><span style="color:#000000;">.append(</span><span style="color:#6a3e3e;">lineTxt</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">       }</span></p> <p style="margin-left:0cm;">       <span style="color:#6a3e3e;">br</span><span style="color:#000000;">.close();</span></p> <p style="margin-left:0cm;">      </p> <p style="margin-left:0cm;"><span style="color:#000000;">      String </span><span style="color:#6a3e3e;">srcText</span><span style="color:#000000;"> = </span><span style="color:#6a3e3e;">sBuilder</span><span style="color:#000000;">.toString();</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">      String </span><span style="color:#6a3e3e;">findText</span><span style="color:#000000;"> = </span><span style="color:#2a00ff;">"d"</span><span style="color:#000000;">;</span></p> <p style="margin-left:0cm;">     </p> <p style="margin-left:0cm;">      <strong><span style="color:#7f0055;">int</span></strong> <span style="color:#6a3e3e;">num</span><span style="color:#000000;"> = <em>appearNumber</em>(</span><span style="color:#6a3e3e;">srcText</span><span style="color:#000000;">,</span><span style="color:#6a3e3e;">findText</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">      System.</span><strong><em><span style="color:#0000c0;">out</span></em></strong><span style="color:#000000;">.println(</span><span style="color:#6a3e3e;">num</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">   }</span></p> <p style="margin-left:0cm;">  </p> <p style="margin-left:0cm;">  </p> <p style="margin-left:0cm;">   <strong><span style="color:#7f0055;">public</span></strong> <strong><span style="color:#7f0055;">static</span></strong> <strong><span style="color:#7f0055;">int</span></strong><span style="color:#000000;"> appearNumber(String </span><span style="color:#6a3e3e;">srcText</span><span style="color:#000000;">,String </span><span style="color:#6a3e3e;">findText</span><span style="color:#000000;">){<!-- --></span></p> <p style="margin-left:0cm;">      <strong><span style="color:#7f0055;">int</span></strong> <span style="color:#6a3e3e;">count</span><span style="color:#000000;"> = 0;</span></p> <p style="margin-left:0cm;">      <strong><span style="color:#7f0055;">int</span></strong> <span style="color:#6a3e3e;">index</span><span style="color:#000000;"> = 0;</span></p> <p style="margin-left:0cm;">      <strong><span style="color:#7f0055;">while</span></strong><span style="color:#000000;">((</span><span style="color:#6a3e3e;">index</span><span style="color:#000000;"> = </span><span style="color:#6a3e3e;">srcText</span><span style="color:#000000;">.indexOf(</span><span style="color:#6a3e3e;">findText</span><span style="color:#000000;">,</span><span style="color:#6a3e3e;">index</span><span style="color:#000000;">)) != -1){<!-- --></span></p> <p style="margin-left:0cm;">         <span style="color:#6a3e3e;">index</span><span style="color:#000000;"> = </span><span style="color:#6a3e3e;">index</span><span style="color:#000000;"> + </span><span style="color:#6a3e3e;">findText</span><span style="color:#000000;">.length();</span></p> <p style="margin-left:0cm;">         <span style="color:#6a3e3e;">count</span><span style="color:#000000;">++;</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">      }</span></p> <p style="margin-left:0cm;">      <strong><span style="color:#7f0055;">return</span></strong> <span style="color:#6a3e3e;">count</span><span style="color:#000000;">;</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">   }</span></p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;"><span style="color:#000000;">}</span></p> <p style="margin-left:0cm;"> </p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>5.四个访问修饰符</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#3f7f5f;">// </span><span style="color:#3f7f5f;">访问权限</span>   <span style="color:#3f7f5f;">类</span>   <span style="color:#3f7f5f;">包</span>  <span style="color:#3f7f5f;">子类</span>  <span style="color:#3f7f5f;">其他包</span></p> <p style="margin-left:0cm;"><strong><span style="color:#7f0055;">public</span></strong><span style="color:#000000;"> String </span><span style="color:#0000c0;">aString</span><span style="color:#000000;">;</span></p> <p style="margin-left:0cm;">  </p> <p style="margin-left:0cm;">   <span style="color:#3f7f5f;">// </span><span style="color:#3f7f5f;">继承的类可以访问以及和</span><span style="color:#3f7f5f;">private</span><span style="color:#3f7f5f;">一样的权限</span></p> <p style="margin-left:0cm;">   <strong><span style="color:#7f0055;">protected</span></strong><span style="color:#000000;"> String </span><span style="color:#0000c0;">bString</span><span style="color:#000000;">;</span></p> <p style="margin-left:0cm;">  </p> <p style="margin-left:0cm;">   <span style="color:#3f7f5f;">// </span><span style="color:#3f7f5f;">包访问权限，即在整个包内均可被访问</span></p> <p style="margin-left:0cm;">   <span style="color:#3f7f5f;">/*default*/</span><span style="color:#000000;"> String </span><span style="color:#0000c0;">cString</span><span style="color:#000000;">;</span></p> <p style="margin-left:0cm;">  </p> <p style="margin-left:0cm;">   <span style="color:#3f7f5f;">//</span><span style="color:#3f7f5f;">除类型创建者和类型的内部方法之外的任何人都不能访问的元素</span></p> <p style="margin-left:0cm;">   <strong><span style="color:#7f0055;">private</span></strong><span style="color:#000000;"> String </span><u><span style="color:#0000c0;">dString</span></u><span style="color:#000000;">;</span></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>6.Spring开启注解的方式</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">在Spring的配置文件中</p> <p style="margin-left:0cm;">  <span style="color:#008000;">&lt;!-- </span><span style="color:#008000;">使用annotation定义事务 --&gt;</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">事务：</span></p> <p style="margin-left:0cm;"><span style="color:#0000FF;">&lt;</span><span style="color:#800000;">tx:annotation-driven </span><span style="color:#FF0000;">transaction-manager</span><span style="color:#0000FF;">="defaultTransactionManager"</span><span style="color:#FF0000;"> proxy-target-class</span><span style="color:#0000FF;">="true"</span> <span style="color:#0000FF;">/&gt;</span></p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;"><span style="color:#000000;">&lt;</span><span style="color:#000088;">context</span><span style="color:#000000;">：</span><span style="color:#000088;">component</span><span style="color:#000000;">-scan base-</span><span style="color:#000088;">package</span><span style="color:#000000;"> =“xx.test.*”</span><span style="color:#000088;">use</span><span style="color:#000000;">-</span><span style="color:#000088;">default</span><span style="color:#000000;">-filters =“false”&gt;</span></p> <p style="margin-left:0cm;"> </p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>7.数据库索引</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">第四，在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</span></p> <p style="margin-left:0cm;"> </p> </td></tr><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><strong><span style="color:#000000;">索引类型</span></strong></p> </td></tr><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">普通索引，唯一索引，主键索引，组合索引</span></p> </td></tr><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><strong><span style="color:#000000;">索引的创建</span></strong></p> </td></tr><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">◆</span><span style="color:#000000;">创建索引</span><br><br><span style="color:#000000;">CREATE INDEX indexName ON mytable(username(length)); </span><br><span style="color:#000000;">如果是</span><span style="color:#000000;">CHAR</span><span style="color:#000000;">，</span><span style="color:#000000;">VARCHAR</span><span style="color:#000000;">类型，</span><span style="color:#000000;">length</span><span style="color:#000000;">可以小于字段实际长度；如果是</span><span style="color:#000000;">BLOB</span><span style="color:#000000;">和</span><span style="color:#000000;">TEXT</span><span style="color:#000000;">类型，必须指定</span><span style="color:#000000;"> length</span><span style="color:#000000;">，下同。</span><br><br><span style="color:#000000;">◆</span><span style="color:#000000;">修改表结构</span><br><br><span style="color:#000000;">ALTER mytable ADD INDEX [indexName] ON (username(length))</span><br><br><span style="color:#000000;">◆</span><span style="color:#000000;">创建表的时候直接指定</span><br><br><span style="color:#000000;">CREATE TABLE mytable( ID INT NOT NULL, username VARCHAR(16) NOT NULL, <br> INDEX [indexName] (username(length)) ); </span><span style="color:#000000;">删除索引的语法：</span><br><br><span style="color:#000000;">DROP INDEX [indexName] ON mytable;</span></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>8.线程中run和start的区别</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">每个线程都有要执行的任务。线程的任务处理逻辑可以在</span><span style="color:#000000;">Tread</span><span style="color:#000000;">类的</span><span style="color:#000000;">run</span><span style="color:#000000;">实例方法中直接实现或通过该方法进行调用，因此</span></p> <p style="margin-left:0cm;"><span style="color:#ff6600;">run()</span><span style="color:#ff6600;">相当于线程的任务处理逻辑的入口方法，它由</span><span style="color:#ff6600;">Java</span><span style="color:#ff6600;">虚拟机在运行相应线程时直接调用，而不是由应用代码进行调用。</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">而</span><span style="color:#000000;">start()</span><span style="color:#000000;">的</span><span style="color:#ff6600;">作用</span><span style="color:#000000;">是启动相应的线程。启动一个线程实际是请求</span><span style="color:#000000;">Java</span><span style="color:#000000;">虚拟机运行相应的线程，而这个线程何时能够运行是由线程调度器决定的。</span><span style="color:#ff6600;">start()</span><span style="color:#ff6600;">调用结束并不表示相应线程已经开始运行，这个线程可能稍后运行，也可能永远也不会运行。</span></p> <p style="margin-left:0cm;"> </p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>9.线程状态有哪些</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">第一是</span><strong><span style="color:#FF0000;">创建状态</span></strong><span style="color:#000000;">。在生成线程对象，并没有调用该对象的</span><span style="color:#000000;">start</span><span style="color:#000000;">方法，这是线程处于创建状态。</span><br><span style="color:#000000;">　　第二是</span><strong><span style="color:#FF0000;">就绪状态</span></strong><span style="color:#000000;">。当调用了线程对象的</span><span style="color:#000000;">start</span><span style="color:#000000;">方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。</span><br><span style="color:#000000;">　　第三是</span><strong><span style="color:#FF0000;">运行状态</span></strong><span style="color:#000000;">。线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行</span><span style="color:#000000;">run</span><span style="color:#000000;">函数当中的代码。</span><br><span style="color:#000000;">　　第四是</span><strong><span style="color:#FF0000;">阻塞状态</span></strong><span style="color:#000000;">。线程正在运行的时候，被暂停，通常是为了等待某个事件的发生</span><span style="color:#000000;">(</span><span style="color:#000000;">比如说某项资源就绪</span><span style="color:#000000;">)</span><span style="color:#000000;">之后再继续运行。</span><span style="color:#000000;">sleep</span><span style="color:#000000;">，</span><span style="color:#000000;">suspend</span><span style="color:#000000;">，</span><span style="color:#000000;">wait</span><span style="color:#000000;">等方法都可以导致线程阻塞。</span><br><span style="color:#000000;">　　第五是</span><strong><span style="color:#FF0000;">死亡状态</span></strong><span style="color:#000000;">。如果一个线程的</span><span style="color:#000000;">run</span><span style="color:#000000;">方法执行结束或者调用</span><span style="color:#000000;">stop</span><span style="color:#000000;">方法后，该线程就会死亡。对于已经死亡的线程，无法再使用</span><span style="color:#000000;">start</span><span style="color:#000000;">方法令其进入就绪。</span></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>10.索引的优缺点</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#333333;">创建索引可以大大提高系统的性能:</span><br><span style="color:#333333;">第一，通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</span><br><span style="color:#333333;">第二，可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</span><br><span style="color:#333333;">第三，可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</span><br><span style="color:#333333;">第四，在使用分组和排序 子句进行</span><a href="https://www.baidu.com/s?wd=%E6%95%B0%E6%8D%AE%E6%A3%80%E7%B4%A2&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" rel="nofollow"><span style="color:#3f88bf;">数据检索</span></a><span style="color:#333333;">时，同样可以显著减少查询中分组和排序的时间。</span><br><span style="color:#333333;">第五，通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</span><br><br><span style="color:#333333;">增加索引也有许多不利的方面:</span><br><span style="color:#333333;">第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</span><br><span style="color:#333333;">第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</span><br><span style="color:#333333;">第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</span></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>11.JVM内存模型</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"></p> </td></tr><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>12.跨域的出现和解决</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#999999;">跨域是指</span><span style="color:#999999;">a</span><span style="color:#999999;">页面想获取</span><span style="color:#999999;">b</span><span style="color:#999999;">页面资源，</span><span style="color:#0000FF;">如果</span><span style="color:#0000FF;">a</span><span style="color:#0000FF;">、</span><span style="color:#0000FF;">b</span><span style="color:#0000FF;">页面的协议、域名、端口、子域名不同，或是</span><span style="color:#0000FF;">a</span><span style="color:#0000FF;">页面为</span><span style="color:#0000FF;">ip</span><span style="color:#0000FF;">地址，</span><span style="color:#0000FF;">b</span><span style="color:#0000FF;">页面为域名地址，所进行的访问行动都是跨域的</span><span style="color:#999999;">，而浏览器为了安全问题一般都限制了跨域访问，也就是不允许跨域请求资源。</span></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">解决跨域：</p> <p style="margin-left:0cm;">  </p> <p style="margin-left:0cm;"><u>Jsonp，把请求路径转成jsonp的格式，再进行请求</u></p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;">在Contoller中加：</p> <p style="margin-left:0cm;">       <span style="color:#3f7f5f;">// </span><span style="color:#3f7f5f;">设置：</span><span style="color:#3f7f5f;">Access-Control-Allow-Origin</span><span style="color:#3f7f5f;">头，处理</span><span style="color:#3f7f5f;">Session</span><span style="color:#3f7f5f;">问题</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">               response.setHeader(</span><span style="color:#2a00ff;">"Access-Control-Allow-Origin"</span><span style="color:#000000;">, request.getHeader(</span><span style="color:#2a00ff;">"Origin"</span><span style="color:#000000;">));</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">               response.setHeader(</span><span style="color:#2a00ff;">"Access-Control-Allow-Credentials"</span><span style="color:#000000;">, </span><span style="color:#2a00ff;">"true"</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">               response.setHeader(</span><span style="color:#2a00ff;">"P3P"</span><span style="color:#000000;">, </span><span style="color:#2a00ff;">"CP=CAO PSA OUR"</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;">               <strong><span style="color:#7f0055;">if</span></strong><span style="color:#000000;"> (request.getHeader(</span><span style="color:#2a00ff;">"Access-Control-Request-Method"</span><span style="color:#000000;">) != </span><strong><span style="color:#7f0055;">null</span></strong><span style="color:#000000;"> &amp;&amp; </span><span style="color:#2a00ff;">"OPTIONS"</span><span style="color:#000000;">.equals(request.getMethod())) {<!-- --></span></p> <p style="margin-left:0cm;"><span style="color:#000000;">                   response.addHeader(</span><span style="color:#2a00ff;">"Access-Control-Allow-Methods"</span><span style="color:#000000;">, </span><span style="color:#2a00ff;">"POST,GET,TRACE,OPTIONS"</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">                   response.addHeader(</span><span style="color:#2a00ff;">"Access-Control-Allow-Headers"</span><span style="color:#000000;">, </span><span style="color:#2a00ff;">"Content-Type,Origin,Accept"</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">                   response.addHeader(</span><span style="color:#2a00ff;">"Access-Control-Max-Age"</span><span style="color:#000000;">, </span><span style="color:#2a00ff;">"120"</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">               }</span></p> </td></tr><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><strong>SpringBoot跨域解决方案:</strong></p> </td></tr><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">在Controller上加@CrossOrigin</p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>13.GC回收垃圾的时候System.gc()和 finalize()的区别</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#FF0000;">收集并删除未引用的对象。</span>可以通过调用"<span style="color:#FF0000;">System.gc()</span>"来触发垃圾回收，但并不保证会确实进行垃圾回收。</p> <p style="margin-left:0cm;">JVM的垃圾回收只收集哪些由new关键字创建的对象。所以，如果<span style="color:#FF0000;">不是用new创建的对象</span>，你可以使用<span style="color:#FF0000;">finalize</span><span style="color:#FF0000;">函数</span>来执行清理。</p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>14.MyBatis中的$和#有什么区别？</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">1 #</span><span style="color:#000000;">是将传入的值当做字符串的形式，</span><span style="color:#000000;">eg:select id,name,age from student where id =</span><span style="color:#FF0000;">#{id}</span><span style="color:#000000;">,</span><span style="color:#000000;">当前端把</span><span style="color:#000000;">id</span><span style="color:#000000;">值</span><span style="color:#000000;">1</span><span style="color:#000000;">，传入到后台的时候，就相当于</span><span style="color:#000000;"> select id,name,age from student where id =</span><span style="color:#FF0000;">'1'</span><span style="color:#000000;">.</span></p> <p style="margin-left:0cm;"><span style="color:#000000;"> 2 $</span><span style="color:#000000;">是将传入的数据直接显示生成</span><span style="color:#000000;">sql</span><span style="color:#000000;">语句，</span><span style="color:#000000;">eg:select id,name,age from student where id =</span><span style="color:#FF0000;">${id}</span><span style="color:#000000;">,</span><span style="color:#000000;">当前端把</span><span style="color:#000000;">id</span><span style="color:#000000;">值</span><span style="color:#000000;">1</span><span style="color:#000000;">，传入到后台的时候，就相当于</span><span style="color:#000000;"> select id,name,age from student where id = </span><span style="color:#FF0000;">1</span><span style="color:#000000;">.</span></p> <p style="margin-left:0cm;"><span style="color:#000000;"> 3 </span><span style="color:#000000;">使用</span><span style="color:#000000;">#</span><span style="color:#000000;">可以很大程度上防止</span><span style="color:#000000;">sql</span><span style="color:#000000;">注入。</span><span style="color:#000000;">(</span><span style="color:#000000;">语句的拼接</span><span style="color:#000000;">)</span></p> <p style="margin-left:0cm;"><span style="color:#000000;"> 4 </span><span style="color:#000000;">但是如果使用在</span><span style="color:#000000;">order by </span><span style="color:#000000;">中就需要使用</span><span style="color:#000000;"> $.</span></p> <p style="margin-left:0cm;"><span style="color:#000000;"> 5 </span><span style="color:#000000;">在大多数情况下还是经常使用</span><span style="color:#000000;">#</span><span style="color:#000000;">，但在不同情况下必须使用</span><span style="color:#000000;">$. </span></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>15.SpringBean的生命周期</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>16.List中如何去重</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">方式一，利用HashSet不能添加重复数据的特性 由于HashSet不能保证添加顺序，所以只能作为判断条件：</p> <p style="margin-left:0cm;">private static void removeDuplicate(List&lt;String&gt; list) {<!-- --></p> <p style="margin-left:0cm;">    HashSet&lt;String&gt; set = new HashSet&lt;String&gt;(list.size());</p> <p style="margin-left:0cm;">    List&lt;String&gt; result = new ArrayList&lt;String&gt;(list.size());</p> <p style="margin-left:0cm;">    for (String str : list) {<!-- --></p> <p style="margin-left:0cm;">        if (set.add(str)) {<!-- --></p> <p style="margin-left:0cm;">            result.add(str);</p> <p style="margin-left:0cm;">        }</p> <p style="margin-left:0cm;">    }</p> <p style="margin-left:0cm;">    list.clear();</p> <p style="margin-left:0cm;">    list.addAll(result);</p> <p style="margin-left:0cm;">}</p> 
     <ul><li><span style="color:#999999;">1</span></li><li><span style="color:#999999;">2</span></li><li><span style="color:#999999;">3</span></li><li><span style="color:#999999;">4</span></li><li><span style="color:#999999;">5</span></li><li><span style="color:#999999;">6</span></li><li><span style="color:#999999;">7</span></li><li><span style="color:#999999;">8</span></li><li><span style="color:#999999;">9</span></li><li><span style="color:#999999;">10</span></li><li><span style="color:#999999;">11</span></li></ul><p style="margin-left:0cm;">方式二，利用LinkedHashSet不能添加重复数据并能保证添加顺序的特性 ：</p> <p style="margin-left:0cm;">private static void removeDuplicate(List&lt;String&gt; list) {<!-- --></p> <p style="margin-left:0cm;">    LinkedHashSet&lt;String&gt; set = new LinkedHashSet&lt;String&gt;(list.size());</p> <p style="margin-left:0cm;">    set.addAll(list);</p> <p style="margin-left:0cm;">    list.clear();</p> <p style="margin-left:0cm;">    list.addAll(set);</p> <p style="margin-left:0cm;">}</p> 
     <ul><li><span style="color:#999999;">1</span></li><li><span style="color:#999999;">2</span></li><li><span style="color:#999999;">3</span></li><li><span style="color:#999999;">4</span></li><li><span style="color:#999999;">5</span></li><li><span style="color:#999999;">6</span></li></ul><p style="margin-left:0cm;">方式三，利用List的contains方法循环遍历：</p> <p style="margin-left:0cm;">private static void removeDuplicate(List&lt;String&gt; list) {<!-- --></p> <p style="margin-left:0cm;">    List&lt;String&gt; result = new ArrayList&lt;String&gt;(list.size());</p> <p style="margin-left:0cm;">    for (String str : list) {<!-- --></p> <p style="margin-left:0cm;">        if (!result.contains(str)) {<!-- --></p> <p style="margin-left:0cm;">            result.add(str);</p> <p style="margin-left:0cm;">        }</p> <p style="margin-left:0cm;">    }</p> <p style="margin-left:0cm;">    list.clear();</p> <p style="margin-left:0cm;">    list.addAll(result);</p> <p style="margin-left:0cm;">}</p> <p style="margin-left:0cm;">--------------------- 作者：灰色流连 来源：CSDN 原文：https://blog.csdn.net/u012156163/article/details/78338574?utm_source=copy 版权声明：本文为博主原创文章，转载请附上博文链接！</p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>17.Redis存储机制</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">Redis</span><span style="color:#000000;">存储机制分成两种</span><span style="color:#000000;">Snapshot</span><span style="color:#000000;">和</span><span style="color:#000000;">AOF</span><span style="color:#000000;">。无论是那种机制</span><span style="color:#000000;">,Redis</span><span style="color:#000000;">都是将数据存储在内存中。</span></p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;"></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <ol><li><strong>WebService实现方式</strong></li></ol> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#555555;">方式</span><span style="color:#555555;">1</span><span style="color:#555555;">：</span></p> <p style="margin-left:0cm;"><span style="color:#555555;">HttpClient</span><span style="color:#555555;">：可以用来调用</span><span style="color:#555555;">webservie</span><span style="color:#555555;">服务，也可以抓取网页数据</span></p> <p style="margin-left:0cm;"><span style="color:#555555;">版本</span><span style="color:#555555;">1</span><span style="color:#555555;">：</span><span style="color:#555555;">HttpClient3.0.x</span></p> <p style="margin-left:0cm;"><span style="color:#555555;">版本</span><span style="color:#555555;">2</span><span style="color:#555555;">：</span><span style="color:#555555;">HttpClient4.x.x(</span><span style="color:#555555;">目前最新</span><span style="color:#555555;">4.5.2)</span></p> <p style="margin-left:0cm;"><span style="color:#555555;">这</span><span style="color:#555555;">2</span><span style="color:#555555;">个版本的使用方式不一样；变动较大</span></p> <p style="margin-left:0cm;"><span style="color:#555555;">方式</span><span style="color:#555555;">2</span><span style="color:#555555;">：纯</span><a href="http://lib.csdn.net/base/java" rel="nofollow"><strong><span style="color:#df3434;">Java</span></strong></a><span style="color:#555555;">(</span><span style="color:#555555;">自带</span><span style="color:#555555;">API)      jws</span></p> <p style="margin-left:0cm;"><span style="color:#555555;">方式</span><span style="color:#555555;">3</span><span style="color:#555555;">：</span><span style="color:#555555;">cxf</span><span style="color:#555555;">框架</span></p> <p style="margin-left:0cm;"><span style="color:#555555;">方式</span><span style="color:#555555;">4</span><span style="color:#555555;">：</span><span style="color:#555555;">axis2</span><span style="color:#555555;">框架</span></p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;"><span style="color:#555555;">准备工作</span><span style="color:#555555;">:</span></p> <p style="margin-left:0cm;"><span style="color:#555555;">1.</span><span style="color:#555555;">了解</span><span style="color:#555555;">wsimport        java</span><span style="color:#555555;">自带的一个命令（建议使用</span><span style="color:#555555;">jdk7</span><span style="color:#555555;">，稳定支持）</span></p> <p style="margin-left:0cm;"><span style="color:#555555;">作用：将</span><span style="color:#555555;">wsdl</span><span style="color:#555555;">文件生成本地代理（</span><span style="color:#555555;">java</span><span style="color:#555555;">代码），方便调用</span></p> <p style="margin-left:0cm;"><span style="color:#555555;">语法</span><span style="color:#555555;">  wsimport [opations] &lt;wsdl_uri&gt;<br>     - wsdl_uri:wsdl </span><span style="color:#555555;">的统一资源标识符</span><br><span style="color:#555555;">    - d  </span><span style="color:#555555;">：指定要输出的文件的位置</span><br><span style="color:#555555;">    - s  </span><span style="color:#555555;">：表示要解析</span><span style="color:#555555;">java</span><span style="color:#555555;">的源码</span> <span style="color:#555555;">，默认解析出的是</span><span style="color:#555555;">class</span><span style="color:#555555;">字节码</span><span style="color:#555555;"> <br>     - p  </span><span style="color:#555555;">：</span> <span style="color:#555555;">指定输出的包名</span><br><span style="color:#555555;"> <br> 1. </span><span style="color:#555555;">获取服务路径</span><span style="color:#555555;">:</span><span style="color:#555555;">比如</span><br><span style="color:#555555;">  http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?WSDL<br><br><br> 2. </span><span style="color:#555555;">获取</span><span style="color:#555555;">wsdl</span><span style="color:#555555;">文件</span><span style="color:#555555;">.</span><span style="color:#555555;">建议使用</span><span style="color:#555555;">JDK1.6</span><span style="color:#555555;">以上的版本的</span><span style="color:#555555;">wsimport</span><span style="color:#555555;">命令</span><br><br><br><span style="color:#555555;">进入</span><span style="color:#555555;">dos</span><span style="color:#555555;">的桌面：</span><br><span style="color:#555555;">方式</span><span style="color:#555555;">1</span><span style="color:#555555;">：</span><span style="color:#555555;">wsimport http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?WSDL</span><br><span style="color:#555555;">这种默认只会生成</span><span style="color:#555555;">class</span><span style="color:#555555;">，且会生成默认的包</span><br><span style="color:#555555;">方式</span><span style="color:#555555;">2</span><span style="color:#555555;">：生成源码，指定包和路径</span><br><span style="color:#555555;">wsimport -s ./ -p cn.aa http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?WSDL<br><br><br> 3.</span><span style="color:#555555;">可以把</span><span style="color:#555555;">class</span><span style="color:#555555;">文件打成</span><span style="color:#555555;">jar</span><span style="color:#555555;">包</span><span style="color:#555555;"> jar cvf  test.jar  </span><span style="color:#555555;">打包目录</span></p> <p style="margin-left:0cm;"><span style="color:#555555;">4.</span><span style="color:#555555;">放在你的项目中进行调用：</span></p> <p style="margin-left:0cm;"><strong><span style="color:#C0C0C0;">[html]</span></strong> <a href="http://blog.csdn.net/u011165335/article/details/51345224"><span style="color:#0c89cf;">view plain</span></a> <a href="http://blog.csdn.net/u011165335/article/details/51345224"><span style="color:#0c89cf;">copy</span></a></p> 
     <ol><li><span style="color:#000000;">public static void main(String[] args) {  </span></li><li><span style="color:#000000;">        MobileCodeWS </span><span style="color:#FF0000;">mobileCodeWs</span><span style="color:#000000;">=</span><span style="color:#0000FF;">new</span><span style="color:#000000;"> MobileCodeWS();  </span></li><li><span style="color:#000000;">        MobileCodeWSSoap </span><span style="color:#FF0000;">mobileCodeWSSoap</span><span style="color:#000000;">=</span><span style="color:#0000FF;">mobileCodeWs</span><span style="color:#000000;">.getMobileCodeWSSoap();  </span></li><li><span style="color:#000000;">        String </span><span style="color:#FF0000;">tel</span><span style="color:#000000;">=</span><span style="color:#0000FF;">mobileCodeWSSoap</span><span style="color:#000000;">.getMobileCodeInfo("183735xxxx",null);  </span></li><li><span style="color:#000000;">        System.out.println(tel);  </span></li><li><span style="color:#000000;">    }  </span></li></ol><p style="margin-left:0cm;"> </p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p> </p> 
 <p style="margin-left:0cm;"> </p> 
 <ol><li><strong>如何实现线程通信</strong></li></ol> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> 
     <ol><li>用volatile关键字</li><li>用redis实现</li></ol></td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <ol><li><strong>volatile和synchronized</strong></li></ol> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> 
     <ol><li>volatile主要用在多个线程感知实例变量被更改了场合，从而使得各个线程获得最新的值。它强制线程每次从主内存中讲到变量，而不是从线程的私有内存中读取变量，从而保证了数据的可见性。</li><li> </li><li>关于synchronized，可参考：JAVA多线程之Synchronized关键字--对象锁的特点</li><li> </li><li>比较：</li><li> </li><li>①volatile轻量级，只能修饰变量。synchronized重量级，还可修饰方法</li><li> </li><li>②volatile只能保证数据的可见性，不能用来同步，因为多个线程并发访问volatile修饰的变量不会阻塞。</li><li> </li><li>synchronized不仅保证可见性，而且还保证原子性，因为，只有获得了锁的线程才能进入临界区，从而保证临界区中的所有语句都全部执行。多个线程争抢synchronized锁对象时，会出现阻塞。</li><li> </li><li> </li><li> </li><li>四，线程安全性</li><li> </li><li>线程安全性包括两个方面，①可见性。②原子性。</li><li> </li><li>从上面自增的例子中可以看出：仅仅使用volatile并不能保证线程安全性。而synchronized则可实现线程的安全性。</li></ol></td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>21.QuartZ如何实现</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">scheduler</span><span style="color:#000000;">（调度器）：将</span><span style="color:#000000;">job</span><span style="color:#000000;">和</span><span style="color:#000000;">trigger</span><span style="color:#000000;">绑定在一起</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">job</span><span style="color:#000000;">（任务）</span>              <span style="color:#000000;">：配置具体哪个类实现定时任务</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">trigger</span><span style="color:#000000;">（触发器）</span>     <span style="color:#000000;">：配置定时器参数，如：多久执行一次，执行多上次等</span></p> <p style="margin-left:0cm;"></p> <p style="margin-left:0cm;"> </p> </td></tr><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">开启注解</span></p> </td></tr><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"></p> <p style="margin-left:0cm;"></p> <p style="margin-left:0cm;"></p> <p style="margin-left:0cm;"> </p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>22.HashMap的底层原理</strong></h2> 
 <p style="margin-left:0cm;"><a href="https://blog.csdn.net/a2524289/article/details/78888480">https://blog.csdn.net/a2524289/article/details/78888480</a></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>23.Dubbo的配置文件</strong></h2> 
 <table border="1" cellspacing="0" style="width:644px;"><tbody><tr><td style="vertical-align:top;width:483.15pt;"> <p style="margin-left:0cm;"></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>24.Dubbo底层协议是什么</strong></h2> 
 <p style="margin-left:0cm;">NIO方式的TCP协议</p> 
 <p> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>25.redis底层协议是什么</strong></h2> 
 <p style="margin-left:0cm;">TCP</p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>26.线程的活锁和死锁</strong></h2> 
 <p style="margin-left:0cm;"><a href="https://blog.csdn.net/qq_29924795/article/details/72772251">https://blog.csdn.net/qq_29924795/article/details/72772251</a></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>27.MQ消息的丢失和中途宕机解决</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><strong><em>服务端丢失</em></strong></p> </td></tr><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">把内存中的消息持久化，重启mq的时候进行从持久化文件中读取</p> </td></tr><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><strong><em>客户端丢失</em></strong></p> </td></tr><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">用户发出的消息还依旧在缓存中，mq可以重新进行read</p> </td></tr><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><strong><em>消息确认</em></strong></p> </td></tr><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">RabbitMQ</span><span style="color:#000000;">引入了消息确认机制，当消息处理完成后，给Server端发送一个确认消息，来告诉服务端可以删除该消息了，如果连接断开的时候，Server端没有收到消费者发出的确认信息，则会把消息转发给其他保持在线的消费者。</span></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>28.MQ一般用在哪里</strong></h2> 
 <p style="margin-left:0cm;"></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>29.Shiro实现方法</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#4f4f4f;">1</span><span style="color:#4f4f4f;">、</span> <span style="color:#4f4f4f;">配置</span><span style="color:#4f4f4f;"> applicationContext-shiro.xml </span><span style="color:#4f4f4f;">激活注解</span></p> <p style="margin-left:0cm;"><span style="color:#4f4f4f;">&lt;!-- </span><span style="color:#4f4f4f;">开启</span><span style="color:#4f4f4f;">shiro</span><span style="color:#4f4f4f;">注解模式</span><span style="color:#4f4f4f;">  --&gt;<br>     &lt;bean<br>         class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"<br>         depends-on="lifecycleBeanPostProcessor" &gt;<br>         &lt;property name="proxyTargetClass" value="true" /&gt;<br>     &lt;/bean&gt;<br>         <br>     &lt;bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"&gt;<br>          &lt;property name="securityManager" ref="securityManager"/&gt;<br>     &lt;/bean&gt;</span></p> <p style="margin-left:0cm;"><span style="color:#4f4f4f;">2.</span><span style="color:#4f4f4f;">业务层使用</span><span style="color:#4f4f4f;"> shiro </span><span style="color:#4f4f4f;">注解</span></p> <p style="margin-left:0cm;"><span style="color:#4f4f4f;">@RequiresPermissions("")</span></p> <p style="margin-left:0cm;"></p> <p style="margin-left:0cm;"><span style="color:#4f4f4f;">3.</span><span style="color:#4f4f4f;">使用方法注解进行权限控制，</span> <span style="color:#4f4f4f;">当权限不足时，代理对象抛出一个异常</span><br><span style="color:#4f4f4f;">org.apache.shiro.authz.UnauthorizedException: Subject does not<br> have permission [courier_add]</span></p> <p style="margin-left:0cm;"> </p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>30.Shiro数据库表设计</strong></h2> 
 <p style="margin-left:0cm;"></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>31.请求类型方式有几种</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#333333;">GET</span><span style="color:#333333;">：</span> <span style="color:#333333;">请求指定的页面信息，并返回实体主体。</span> <br><span style="color:#333333;">HEAD</span><span style="color:#333333;">：</span> <span style="color:#333333;">只请求页面的首部。</span> <br><span style="color:#333333;">POST</span><span style="color:#333333;">：</span> <span style="color:#333333;">请求服务器接受所指定的文档作为对所标识的</span><span style="color:#333333;">URI</span><span style="color:#333333;">的新的从属实体。</span> <br><span style="color:#333333;">PUT</span><span style="color:#333333;">：</span> <span style="color:#333333;">从客户端向服务器传送的数据取代指定的文档的内容。</span> <br><span style="color:#333333;">DELETE</span><span style="color:#333333;">：</span> <span style="color:#333333;">请求服务器删除指定的页面。</span> <br><span style="color:#333333;">OPTIONS</span><span style="color:#333333;">：</span> <span style="color:#333333;">允许客户端查看服务器的性能。</span> <br><span style="color:#333333;">TRACE</span><span style="color:#333333;">：</span> <span style="color:#333333;">请求服务器在响应中的实体主体部分返回所得到的内容。</span> <br><span style="color:#333333;">PATCH</span><span style="color:#333333;">：</span> <span style="color:#333333;">实体中包含一个表，表中说明与该</span><span style="color:#333333;">URI</span><span style="color:#333333;">所表示的原内容的区别。</span> <br><span style="color:#333333;">MOVE</span><span style="color:#333333;">：</span> <span style="color:#333333;">请求服务器将指定的页面移至另一个网络地址。</span> <br><span style="color:#333333;">COPY</span><span style="color:#333333;">：</span> <span style="color:#333333;">请求服务器将指定的页面拷贝至另一个网络地址。</span> <br><span style="color:#333333;">LINK</span><span style="color:#333333;">：</span> <span style="color:#333333;">请求服务器建立链接关系。</span> <br><span style="color:#333333;">UNLINK</span><span style="color:#333333;">：</span> <span style="color:#333333;">断开链接关系。</span> <br><span style="color:#333333;">WRAPPED</span><span style="color:#333333;">：</span> <span style="color:#333333;">允许客户端发送经过封装的请求。</span> </p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>32.线程池如何实现</strong></h2> 
 <p style="margin-left:0cm;"><a href="https://blog.csdn.net/douunderstand/article/details/72190330">https://blog.csdn.net/douunderstand/article/details/72190330</a></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>33.redis持久化如何实现</strong></h2> 
 <p style="margin-left:0cm;">RDB持久化</p> 
 <p style="margin-left:0cm;">AOF持久化</p> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p><strong><span style="color:#000000;">3</span><span style="color:#000000;">、二者优缺点</span></strong></p> <p><strong><span style="color:#000000;">RDB</span><span style="color:#000000;">存在哪些优势呢？</span></strong></p> <p style="margin-left:0cm;"><span style="color:#333333;">1). </span><span style="color:#333333;">一旦采用该方式，那么你的整个</span><span style="color:#333333;">Redis</span><span style="color:#333333;">数据库将只包含一个文件，这对于文件备份而言是非常完美的。比如，你可能打算每个小时归档一次最近</span><span style="color:#333333;">24</span><span style="color:#333333;">小时的数</span> <span style="color:#333333;">据，同时还要每天归档一次最近</span><span style="color:#333333;">30</span><span style="color:#333333;">天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复。</span></p> <p style="margin-left:0cm;"><span style="color:#333333;">2). </span><span style="color:#333333;">对于灾难恢复而言，</span><span style="color:#333333;">RDB</span><span style="color:#333333;">是非常不错的选择。因为我们可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上。</span></p> <p style="margin-left:0cm;"><span style="color:#333333;">3). </span><span style="color:#333333;">性能最大化。对于</span><span style="color:#333333;">Redis</span><span style="color:#333333;">的服务进程而言，在开始持久化时，它唯一需要做的只是</span><span style="color:#333333;">fork</span><span style="color:#333333;">出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行</span><span style="color:#333333;">IO</span><span style="color:#333333;">操作了。</span></p> <p style="margin-left:0cm;"><span style="color:#333333;">4). </span><span style="color:#333333;">相比于</span><span style="color:#333333;">AOF</span><span style="color:#333333;">机制，如果数据集很大，</span><span style="color:#333333;">RDB</span><span style="color:#333333;">的启动效率会更高。</span></p> <p style="margin-left:0cm;"><span style="color:#333333;">RDB</span><span style="color:#333333;">又存在哪些劣势呢？</span></p> <p style="margin-left:0cm;"><span style="color:#333333;">1). </span><span style="color:#333333;">如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么</span><span style="color:#333333;">RDB</span><span style="color:#333333;">将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</span></p> <p style="margin-left:0cm;"><span style="color:#333333;">2). </span><span style="color:#333333;">由于</span><span style="color:#333333;">RDB</span><span style="color:#333333;">是通过</span><span style="color:#333333;">fork</span><span style="color:#333333;">子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是</span><span style="color:#333333;">1</span><span style="color:#333333;">秒钟。</span></p> <p><strong><span style="color:#000000;">AOF</span><span style="color:#000000;">的优势有哪些呢？</span></strong></p> <p style="margin-left:0cm;"><span style="color:#333333;">1). </span><span style="color:#333333;">该机制可以带来更高的数据安全性，即数据持久性。</span><span style="color:#333333;">Redis</span><span style="color:#333333;">中提供了</span><span style="color:#333333;">3</span><span style="color:#333333;">中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其</span> <span style="color:#333333;">效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，我们可以将其视为同步持久化，即每次发生的数据变</span> <span style="color:#333333;">化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言，我想大家都能正确的理解它。</span></p> <p style="margin-left:0cm;"><span style="color:#333333;">2). </span><span style="color:#333333;">由于该机制对日志文件的写入操作采用的是</span><span style="color:#333333;">append</span><span style="color:#333333;">模式，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果我们本次操</span> <span style="color:#333333;">作只是写入了一半数据就出现了系统崩溃问题，不用担心，在</span><span style="color:#333333;">Redis</span><span style="color:#333333;">下一次启动之前，我们可以通过</span><span style="color:#333333;">redis-check-aof</span><span style="color:#333333;">工具来帮助我们解决数据</span> <span style="color:#333333;">一致性的问题。</span></p> <p style="margin-left:0cm;"><span style="color:#333333;">3). </span><span style="color:#333333;">如果日志过大，</span><span style="color:#333333;">Redis</span><span style="color:#333333;">可以自动启用</span><span style="color:#333333;">rewrite</span><span style="color:#333333;">机制。即</span><span style="color:#333333;">Redis</span><span style="color:#333333;">以</span><span style="color:#333333;">append</span><span style="color:#333333;">模式不断的将修改数据写入到老的磁盘文件中，同时</span><span style="color:#333333;">Redis</span><span style="color:#333333;">还会创</span> <span style="color:#333333;">建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行</span><span style="color:#333333;">rewrite</span><span style="color:#333333;">切换时可以更好的保证数据安全性。</span></p> <p style="margin-left:0cm;"><span style="color:#333333;">4). AOF</span><span style="color:#333333;">包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</span></p> <p style="margin-left:0cm;"><span style="color:#333333;">AOF</span><span style="color:#333333;">的劣势有哪些呢？</span></p> <p style="margin-left:0cm;"><span style="color:#333333;">1). </span><span style="color:#333333;">对于相同数量的数据集而言，</span><span style="color:#333333;">AOF</span><span style="color:#333333;">文件通常要大于</span><span style="color:#333333;">RDB</span><span style="color:#333333;">文件。</span><span style="color:#333333;">RDB </span><span style="color:#333333;">在恢复大数据集时的速度比</span><span style="color:#333333;"> AOF </span><span style="color:#333333;">的恢复速度要快。</span></p> <p style="margin-left:0cm;"><span style="color:#333333;">2). </span><span style="color:#333333;">根据同步策略的不同，</span><span style="color:#333333;">AOF</span><span style="color:#333333;">在运行效率上往往会慢于</span><span style="color:#333333;">RDB</span><span style="color:#333333;">。总之，每秒同步策略的效率是比较高的，同步禁用策略的效率和</span><span style="color:#333333;">RDB</span><span style="color:#333333;">一样高效。</span></p> <p style="margin-left:0cm;"><span style="color:#333333;">二者选择的标准，就是看系统是愿意牺牲一些性能，换取更高的缓存一致性（</span><span style="color:#333333;">aof</span><span style="color:#333333;">），还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行</span><span style="color:#333333;">save</span><span style="color:#333333;">的时候，再做备份（</span><span style="color:#333333;">rdb</span><span style="color:#333333;">）。</span><span style="color:#333333;">rdb</span><span style="color:#333333;">这个就更有些</span><span style="color:#333333;"> eventually consistent</span><span style="color:#333333;">的意思了。</span></p> <p><strong><span style="color:#000000;">4</span><span style="color:#000000;">、常用配置</span></strong></p> <p><strong><span style="color:#000000;">RDB</span><span style="color:#000000;">持久化配置</span></strong></p> <p style="margin-left:0cm;"><span style="color:#333333;">Redis</span><span style="color:#333333;">会将数据集的快照</span><span style="color:#333333;">dump</span><span style="color:#333333;">到</span><span style="color:#333333;">dump.rdb</span><span style="color:#333333;">文件中。此外，我们也可以通过配置文件来修改</span><span style="color:#333333;">Redis</span><span style="color:#333333;">服务器</span><span style="color:#333333;">dump</span><span style="color:#333333;">快照的频率，在打开</span><span style="color:#333333;">6379.conf</span><span style="color:#333333;">文件之后，我们搜索</span><span style="color:#333333;">save</span><span style="color:#333333;">，可以看到下面的配置信息：</span></p> <p style="margin-left:0cm;"><span style="color:#333333;">save 900 1              #</span><span style="color:#333333;">在</span><span style="color:#333333;">900</span><span style="color:#333333;">秒</span><span style="color:#333333;">(15</span><span style="color:#333333;">分钟</span><span style="color:#333333;">)</span><span style="color:#333333;">之后，如果至少有</span><span style="color:#333333;">1</span><span style="color:#333333;">个</span><span style="color:#333333;">key</span><span style="color:#333333;">发生变化，则</span><span style="color:#333333;">dump</span><span style="color:#333333;">内存快照。</span></p> <p style="margin-left:0cm;"><span style="color:#333333;">save 300 10            #</span><span style="color:#333333;">在</span><span style="color:#333333;">300</span><span style="color:#333333;">秒</span><span style="color:#333333;">(5</span><span style="color:#333333;">分钟</span><span style="color:#333333;">)</span><span style="color:#333333;">之后，如果至少有</span><span style="color:#333333;">10</span><span style="color:#333333;">个</span><span style="color:#333333;">key</span><span style="color:#333333;">发生变化，则</span><span style="color:#333333;">dump</span><span style="color:#333333;">内存快照。</span></p> <p style="margin-left:0cm;"><span style="color:#333333;">save 60 10000        #</span><span style="color:#333333;">在</span><span style="color:#333333;">60</span><span style="color:#333333;">秒</span><span style="color:#333333;">(1</span><span style="color:#333333;">分钟</span><span style="color:#333333;">)</span><span style="color:#333333;">之后，如果至少有</span><span style="color:#333333;">10000</span><span style="color:#333333;">个</span><span style="color:#333333;">key</span><span style="color:#333333;">发生变化，则</span><span style="color:#333333;">dump</span><span style="color:#333333;">内存快照。</span></p> <p><strong><span style="color:#000000;">AOF</span><span style="color:#000000;">持久化配置</span></strong></p> <p style="margin-left:0cm;"><span style="color:#333333;">在</span><span style="color:#333333;">Redis</span><span style="color:#333333;">的配置文件中存在三种同步方式，它们分别是：</span></p> <p style="margin-left:0cm;"><span style="color:#333333;">appendfsync always     #</span><span style="color:#333333;">每次有数据修改发生时都会写入</span><span style="color:#333333;">AOF</span><span style="color:#333333;">文件。</span></p> <p style="margin-left:0cm;"><span style="color:#333333;">appendfsync everysec  #</span><span style="color:#333333;">每秒钟同步一次，该策略为</span><span style="color:#333333;">AOF</span><span style="color:#333333;">的缺省策略。</span></p> <p style="margin-left:0cm;"><span style="color:#333333;">appendfsync no          #</span><span style="color:#333333;">从不同步。高效但是数据不会被持久化。</span></p> <p style="margin-left:0cm;"> </p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>34.Spring传播机制是如何实现的</strong></h2> 
 <p style="margin-left:0cm;"><a href="https://www.cnblogs.com/softidea/p/5962612.html" rel="nofollow">https://www.cnblogs.com/softidea/p/5962612.html</a></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><a href="https://blog.csdn.net/weixin_38070406/article/details/78157603">https://blog.csdn.net/weixin_38070406/article/details/78157603</a></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>35.打印菱形</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">Scanner input = </span><strong><span style="color:#7f0055;">new</span></strong><span style="color:#000000;"> Scanner(System.in);</span></p> <p style="margin-left:0cm;">        <span style="color:#3f7f5f;">// </span><strong><span style="color:#7f9fbf;">TODO</span></strong> <span style="color:#3f7f5f;">自动生成的方法存根</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">       System.out.println(</span><span style="color:#2a00ff;">"</span><span style="color:#2a00ff;">请输入行数</span><span style="color:#2a00ff;">:"</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;">       <strong><span style="color:#7f0055;">int</span></strong><span style="color:#000000;"> m=input.nextInt();</span></p> <p style="margin-left:0cm;">       <span style="color:#3f7f5f;">//</span><span style="color:#3f7f5f;">确定打印菱形的行数，可以自行设置</span></p> <p style="margin-left:0cm;">       <strong><span style="color:#7f0055;">int</span></strong><span style="color:#000000;"> n=m/2+1;</span></p> <p style="margin-left:0cm;">       <strong><span style="color:#7f0055;">int</span></strong><span style="color:#000000;"> t=m/2;</span></p> <p style="margin-left:0cm;">       <strong><span style="color:#7f0055;">for</span></strong><span style="color:#000000;">(</span><strong><span style="color:#7f0055;">int</span></strong><span style="color:#000000;"> i=1;i&lt;=n;i++)</span><span style="color:#3f7f5f;">//</span><span style="color:#3f7f5f;">打印菱形的上半部分</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">       {<!-- --></span></p> <p style="margin-left:0cm;">           <strong><span style="color:#7f0055;">for</span></strong><span style="color:#000000;">(</span><strong><span style="color:#7f0055;">int</span></strong><span style="color:#000000;"> j=(n-i);j&gt;0;j--)</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">               System.out.print(</span><span style="color:#2a00ff;">" "</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;">             <span style="color:#3f7f5f;">//</span><span style="color:#3f7f5f;">打印空格数</span> </p> <p style="margin-left:0cm;">           <strong><span style="color:#7f0055;">for</span></strong><span style="color:#000000;">(</span><strong><span style="color:#7f0055;">int</span></strong><span style="color:#000000;"> k=2*i-1;k&gt;0;k--)</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">               System.out.print(</span><span style="color:#2a00ff;">"*"</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;">              <span style="color:#3f7f5f;">//</span><span style="color:#3f7f5f;">打印</span><span style="color:#3f7f5f;">*</span><span style="color:#3f7f5f;">号</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">           System.out.println();</span></p> <p style="margin-left:0cm;">           <span style="color:#3f7f5f;">//</span><span style="color:#3f7f5f;">一行打印结束，换行</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">       }</span></p> <p style="margin-left:0cm;">       <strong><span style="color:#7f0055;">for</span></strong><span style="color:#000000;">(</span><strong><span style="color:#7f0055;">int</span></strong><span style="color:#000000;"> i=t;i&gt;0;i--)</span><span style="color:#3f7f5f;">//</span><span style="color:#3f7f5f;">打印菱形的下半部分</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">       {<!-- --></span></p> <p style="margin-left:0cm;">           <strong><span style="color:#7f0055;">for</span></strong><span style="color:#000000;"> (</span><strong><span style="color:#7f0055;">int</span></strong><span style="color:#000000;"> b=(n-i);b&gt;0;b--)</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">               System.out.print(</span><span style="color:#2a00ff;">" "</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;">               <span style="color:#3f7f5f;">//</span><span style="color:#3f7f5f;">打印空格数</span></p> <p style="margin-left:0cm;">           <strong><span style="color:#7f0055;">for</span></strong><span style="color:#000000;"> (</span><strong><span style="color:#7f0055;">int</span></strong><span style="color:#000000;"> a=(2*i-1);a&gt;0;a--)</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">               System.out.print(</span><span style="color:#2a00ff;">"*"</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;">               <span style="color:#3f7f5f;">//</span><span style="color:#3f7f5f;">打印</span><span style="color:#3f7f5f;">*</span><span style="color:#3f7f5f;">号</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">           System.out.println();</span></p> <p style="margin-left:0cm;">           <span style="color:#3f7f5f;">//</span><span style="color:#3f7f5f;">一行打印结束，换行</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">       }</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">        }</span></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>36.编写程序，对输入的年、月、日，给出该天是该年的第多少天？</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">      <span style="color:#000000;"> System.</span><strong><em><span style="color:#0000c0;">out</span></em></strong><span style="color:#000000;">.println(</span><span style="color:#2a00ff;">"43 </span><span style="color:#2a00ff;">编写程序，对输入的年、月、日，给出该天是该年的第多少天？</span><span style="color:#2a00ff;">"</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;">             <span style="color:#3f7f5f;">// </span><span style="color:#3f7f5f;">编写程序，对输入的年、月、日，给出该天是该年的第多少天？</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">             SimpleDateFormat </span><span style="color:#6a3e3e;">format</span><span style="color:#000000;"> = </span><strong><span style="color:#7f0055;">new</span></strong><span style="color:#000000;"> SimpleDateFormat(</span><span style="color:#2a00ff;">"yyyy-MM-dd"</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">             Date </span><span style="color:#6a3e3e;">date</span><span style="color:#000000;">;</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">             Date </span><span style="color:#6a3e3e;">date1</span><span style="color:#000000;">;</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">             Scanner </span><u><span style="color:#6a3e3e;">sc</span></u><span style="color:#000000;"> = </span><strong><span style="color:#7f0055;">new</span></strong><span style="color:#000000;"> Scanner(System.</span><strong><em><span style="color:#0000c0;">in</span></em></strong><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;">             <strong><span style="color:#7f0055;">while</span></strong><span style="color:#000000;"> (</span><strong><span style="color:#7f0055;">true</span></strong><span style="color:#000000;">){<!-- --></span></p> <p style="margin-left:0cm;"><span style="color:#000000;">                 System.</span><strong><em><span style="color:#0000c0;">out</span></em></strong><span style="color:#000000;">.print(</span><span style="color:#2a00ff;">"</span><span style="color:#2a00ff;">请输入一个日期</span><span style="color:#2a00ff;">\n</span><span style="color:#2a00ff;">【格式】</span><span style="color:#2a00ff;">yyyy-MM-dd\n</span><span style="color:#2a00ff;">请输入</span><span style="color:#2a00ff;">:"</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">                 String </span><span style="color:#6a3e3e;">temp</span><span style="color:#000000;"> = </span><span style="color:#6a3e3e;">sc</span><span style="color:#000000;">.next();</span></p> <p style="margin-left:0cm;">                 <strong><span style="color:#7f0055;">try</span></strong><span style="color:#000000;"> {<!-- --></span></p> <p style="margin-left:0cm;">                     <span style="color:#6a3e3e;">date</span><span style="color:#000000;"> = </span><span style="color:#6a3e3e;">format</span><span style="color:#000000;">.parse(</span><span style="color:#6a3e3e;">temp</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;">                     <span style="color:#6a3e3e;">date1</span><span style="color:#000000;"> = </span><span style="color:#6a3e3e;">format</span><span style="color:#000000;">.parse(</span><span style="color:#6a3e3e;">temp</span><span style="color:#000000;">.split(</span><span style="color:#2a00ff;">"-"</span><span style="color:#000000;">)[0]+</span><span style="color:#2a00ff;">"-01-01"</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;">                     <strong><span style="color:#7f0055;">break</span></strong><span style="color:#000000;">;</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">                 } </span><strong><span style="color:#7f0055;">catch</span></strong><span style="color:#000000;"> (ParseException </span><span style="color:#6a3e3e;">e</span><span style="color:#000000;">) {<!-- --></span></p> <p style="margin-left:0cm;"><span style="color:#3f7f5f;">//                       e.printStackTrace();</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">                     System.</span><strong><em><span style="color:#0000c0;">out</span></em></strong><span style="color:#000000;">.println(</span><span style="color:#2a00ff;">"</span><span style="color:#2a00ff;">输入有误</span><span style="color:#2a00ff;">!"</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">                 }</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">             }</span><span style="color:#3f7f5f;">//getTime() </span><span style="color:#3f7f5f;">方法可返回距</span><span style="color:#3f7f5f;"> 1970 </span><span style="color:#3f7f5f;">年</span><span style="color:#3f7f5f;"> 1 </span><span style="color:#3f7f5f;">月</span><span style="color:#3f7f5f;"> 1 </span><span style="color:#3f7f5f;">日之间的毫秒数。</span></p> <p style="margin-left:0cm;">             <strong><span style="color:#7f0055;">long</span></strong> <span style="color:#6a3e3e;">l</span><span style="color:#000000;"> = </span><span style="color:#6a3e3e;">date</span><span style="color:#000000;">.getTime() - </span><span style="color:#6a3e3e;">date1</span><span style="color:#000000;">.getTime();</span></p> <p style="margin-left:0cm;">             <span style="color:#3f7f5f;">//</span><span style="color:#3f7f5f;">毫秒</span><span style="color:#3f7f5f;"> / 1000 = </span><span style="color:#3f7f5f;">秒</span><span style="color:#3f7f5f;"> / 60 = </span><span style="color:#3f7f5f;">分钟</span><span style="color:#3f7f5f;"> / 60 = </span><span style="color:#3f7f5f;">小时</span><span style="color:#3f7f5f;"> / 24 = </span><span style="color:#3f7f5f;">天</span><span style="color:#3f7f5f;"> + 1 = </span><span style="color:#3f7f5f;">第几天</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">             System.</span><strong><em><span style="color:#0000c0;">out</span></em></strong><span style="color:#000000;">.println(</span><span style="color:#2a00ff;">"</span><span style="color:#2a00ff;">该天是该年的第</span><span style="color:#2a00ff;">"</span><span style="color:#000000;">+((</span><span style="color:#6a3e3e;">l</span><span style="color:#000000;">)/1000/60/60/24+1)+</span><span style="color:#2a00ff;">"</span><span style="color:#2a00ff;">天</span><span style="color:#2a00ff;">"</span><span style="color:#000000;">);</span></p> <p style="margin-left:0cm;">        </p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>37.原生JDBC实现CRUD</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"></p> <p style="margin-left:0cm;"></p> <p style="margin-left:0cm;"></p> <p style="margin-left:0cm;"></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>38.GC垃圾回收算法</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">　1.<strong>标记</strong></span><strong><span style="color:#000000;">-</span></strong><strong><span style="color:#000000;">清除算法</span></strong></p> <p style="margin-left:0cm;"><span style="color:#000000;">　　等待被回收对象的</span><span style="color:#000000;">“</span><span style="color:#000000;">标记</span><span style="color:#000000;">”</span><span style="color:#000000;">过程在上文已经提到过，如果在被标记后直接对对象进行清除，会带来另一个新的问题</span><span style="color:#000000;">——</span><span style="color:#000000;">内存碎片化。如果下次有比较大的对象实例需要在堆上分配较大的内存空间时，可能会出现无法找到足够的连续内存而不得不再次触发垃圾回收。</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">　　2.<strong>复制算法（</strong></span><strong><span style="color:#000000;">Java</span></strong><strong><span style="color:#000000;">堆中新生代的垃圾回收算法）</span></strong></p> <p style="margin-left:0cm;"><span style="color:#000000;">此</span><span style="color:#000000;">GC</span><span style="color:#000000;">算法实际上解决了标记</span><span style="color:#000000;">-</span><span style="color:#000000;">清除算法带来的</span><span style="color:#000000;">“</span><span style="color:#000000;">内存碎片化</span><span style="color:#000000;">”</span><span style="color:#000000;">问题</span><span style="color:#000000;">。首先还是先标记处待回收内存和不用回收的内存，下一步将不用回收的内存复制到新的内存区域，这样旧的内存区域就可以全部回收，而新的内存区域则是连续的。它的缺点就是会损失掉部分系统内存，因为你总要腾出一部分内存用于复制。</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">　　在上文</span><a href="http://www.cnblogs.com/yulinfeng/p/7153391.html" rel="nofollow"><span style="color:#000000;">《</span><span style="color:#000000;">JVM</span></a><a href="http://www.cnblogs.com/yulinfeng/p/7153391.html" rel="nofollow"><span style="color:#000000;">入门——运行时数据区》</span></a><span style="color:#000000;">提到过在</span><span style="color:#000000;">Java</span><span style="color:#000000;">堆中被分为了新生代和老年代，这样的划分是方便</span><span style="color:#000000;">GC</span><span style="color:#000000;">。</span><span style="color:#000000;">Java</span><span style="color:#000000;">堆中的新生代就使用了</span><span style="color:#000000;">GC</span><span style="color:#000000;">复制算法。在新生代中又分为了三个区域：</span><span style="color:#000000;">Eden </span><span style="color:#000000;">空间、To Survivor</span><span style="color:#000000;">空间</span><span style="color:#000000;">、From Survivor</span><span style="color:#000000;">空间</span><span style="color:#000000;">。不妨将注意力回到这张图的左边新生代部分：</span></p> <p style="margin-left:0cm;"><span style="color:#000000;"><img alt="https://img-blog.csdnimg.cn/20181229001921440" class="has" id="图片_x0020_17" src="https://images2.imgbox.com/4a/3b/KRhnXrGR_o.png"></span></p> <p style="margin-left:0cm;"><span style="color:#000000;">　　新的对象实例被创建的时候通常在</span><span style="color:#000000;">Eden</span><span style="color:#000000;">空间</span><span style="color:#000000;">，发生在</span><span style="color:#000000;">Eden</span><span style="color:#000000;">空间上的</span><span style="color:#000000;">GC</span><span style="color:#000000;">称为</span><span style="color:#000000;">Minor GC</span><span style="color:#000000;">，<strong>当在新生代发生一次</strong></span><strong><span style="color:#000000;">GC</span></strong><strong><span style="color:#000000;">后</span></strong><strong><span style="color:#000000;">，会将</span></strong><strong><span style="color:#000000;">Eden</span></strong><strong><span style="color:#000000;">和其中一个</span></strong><strong><span style="color:#000000;">Survivor</span></strong><strong><span style="color:#000000;">空间的内存复制到另外一个</span></strong><strong><span style="color:#000000;">Survivor</span></strong><strong><span style="color:#000000;">中</span></strong><span style="color:#000000;">，如果反复几次有对象一直存活，此时内存对象将会被移至老年代。可以看到新生代中</span><span style="color:#000000;">Eden</span><span style="color:#000000;">占了大部分，而两个</span><span style="color:#000000;">Survivor</span><span style="color:#000000;">实际上占了很小一部分。这是因为大部分的对象被创建过后很快就会被</span><span style="color:#000000;">GC</span><span style="color:#000000;">（这里也许运用了是二八原则）。</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">　　3.<strong>标记-压缩算法（或称为标记-整理算法，</strong></span><strong><span style="color:#000000;">Java</span></strong><strong><span style="color:#000000;">堆中老年代的垃圾回收算法）</span></strong></p> <p style="margin-left:0cm;"><span style="color:#000000;">　　对于新生代，大部分对象都不会存活，所以在新生代中使用复制算法较为高效，而对于老年代来讲，大部分对象可能会继续存活下去，如果此时还是利用复制算法，效率则会降低。<strong>标记</strong></span><strong><span style="color:#000000;">-</span></strong><strong><span style="color:#000000;">压缩算法首先还是“标记”，标记过后，将不用回收的内存对象压缩到内存一端，此时即可直接清除边界处的内存</span></strong><span style="color:#000000;">，这样就能避免复制算法带来的效率问题，同时也能避免内存碎片化的问题。老年代的垃圾回收称为“</span><span style="color:#000000;">Major</span><span style="color:#000000;"> GC</span><span style="color:#000000;">”。</span></p> <p style="margin-left:0cm;"> </p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>39.Maven和Git的常用命令</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">开发中常用的git命令：</p> <p style="margin-left:0cm;">    查看有变动的文件</p> <p style="margin-left:0cm;">    git status</p> <p style="margin-left:0cm;">    将当前目录下所有有变化目录进行添加</p> <p style="margin-left:0cm;">    git add .</p> <p style="margin-left:0cm;">    将添加的变动提交到本地仓库，提交后git status将看不到有变化文件啦</p> <p style="margin-left:0cm;">    git commit  -m 'mengshanshan update'</p> <p style="margin-left:0cm;">    将git上最新代码拉到本地</p> <p style="margin-left:0cm;">    git pull origin master</p> <p style="margin-left:0cm;">    将本地仓库代码提交到master</p> <p style="margin-left:0cm;">    git push origin master</p> <p style="margin-left:0cm;">    将本地仓库代码提交到master的streaming分支，页面可以替交merge</p> <p style="margin-left:0cm;">    git push origin master:streaming</p> <p style="margin-left:0cm;">    退回到上一版本</p> <p style="margin-left:0cm;">    git reset —hard  </p> <p style="margin-left:0cm;">5. maven命令：</p> <p style="margin-left:0cm;">    下载本地依赖:</p> <p style="margin-left:0cm;">    mvn -DskipTests clean package install</p> <p style="margin-left:0cm;">    下载缺失包：</p> <p style="margin-left:0cm;">     mvn compile</p> <p style="margin-left:0cm;">    下载编译项目</p> <p style="margin-left:0cm;">    mvn clean &amp;&amp; mvn install -U</p> <p style="margin-left:0cm;">    生成lib目录，将相关包移进lib下</p> <p style="margin-left:0cm;">    mvn dependency:copy-dependencies -DoutputDirectory=lib</p> <p style="margin-left:0cm;">    tar包:</p> <p style="margin-left:0cm;">    mvn assembly:assembly -DskipTests -P{p}</p> <p style="margin-left:0cm;">    class包，产生class等，部署项目使用~</p> <p style="margin-left:0cm;">    mvn -DskipTests -Pcdn_online clean package</p> <p style="margin-left:0cm;">    查找依赖</p> <p style="margin-left:0cm;">    mvn dependency:tree</p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>40.java如何实现秒杀商品</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">把商品数量存入redis中，当某一个用户购买成功后，同步缓存，数量就为0，别的用户就不能购买。</p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>41.redis缓存同步的方法</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#4f4f4f;">1</span><span style="color:#4f4f4f;">：读取数据的时候先从</span><span style="color:#4f4f4f;">redis</span><span style="color:#4f4f4f;">里面查，若没有，再去数据库查，同时写到</span><span style="color:#4f4f4f;">redis</span><span style="color:#4f4f4f;">里面，并且要设置失效时间。</span><br><span style="color:#4f4f4f;">2</span><span style="color:#4f4f4f;">：存数据的时候要具体情况具体分析，可以选择同时插到数据库和</span><span style="color:#4f4f4f;">redis</span><span style="color:#4f4f4f;">（要是存放到</span><span style="color:#4f4f4f;">redis</span><span style="color:#4f4f4f;">中，最好设置失效时间），也可以选择直接插到数据库里面，少考虑一些问题。</span></p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>42.单元测试，性能测试方法</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">Junit</p> <p style="margin-left:0cm;">·@Before</p> <p style="margin-left:0cm;">       public void befores(){<!-- --></p> <p style="margin-left:0cm;">              System.out.println("前--");</p> <p style="margin-left:0cm;">       }</p> <p style="margin-left:0cm;">      </p> <p style="margin-left:0cm;">       @Test</p> <p style="margin-left:0cm;">       public void test1(){<!-- --></p> <p style="margin-left:0cm;">              System.out.println("中间--");</p> <p style="margin-left:0cm;">       }</p> <p style="margin-left:0cm;">      </p> <p style="margin-left:0cm;">       @After</p> <p style="margin-left:0cm;">       public void afters(){<!-- --></p> <p style="margin-left:0cm;">              System.out.println("后--");</p> <p style="margin-left:0cm;">       }</p> <p style="margin-left:0cm;">jMeter详解：</p> <p style="margin-left:0cm;">https://blog.csdn.net/jek123456/article/details/79027037</p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>43.ajax传递对象，controller如何接收</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">requestBody详解</p> <p style="margin-left:0cm;">https://www.cnblogs.com/qiankun-site/p/5774300.html</p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>44.事务是如何实现的，项目中怎么使用的事务</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">实现方式共有两种：编码方式；声明式事务管理方式。</p> <p style="margin-left:0cm;">基于<span style="color:#333333;">AOP</span>技术实现的声明式事务管理，实质就是：在方法执行前后进行拦截，然后在目标方法开始之前创建并加入事务，执行完目标方法后根据执行情况提交或回滚事务。</p> <p style="margin-left:0cm;">声明式事务管理又有两种方式：基于<span style="color:#333333;">XML</span>配置文件的方式；另一个是在业务方法上进行<span style="color:#333333;">@Transactional</span>注解，将事务规则应用到业务逻辑中。</p> <p style="margin-left:0cm;">事务的<span style="color:#333333;">4</span>个特性：</p> 
     <ul><li>原子性：一个事务中所有对数据库的操作是一个不可分割的操作序列，要么全做，要么全部做。</li><li>一致性：数据不会因为事务的执行而遭到破坏。</li><li>隔离性：一个事务的执行，不受其他事务（进程）的干扰。既并发执行的个事务之间互不干扰。</li><li>持久性：一个事务一旦提交，它对数据库的改变将是永久的。</li></ul><p style="margin-left:0cm;"> </p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>45.java队列</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">https://www.cnblogs.com/Dylansuns/archive/2017/04/30/6789161.html</p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>46.java内存</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">http://www.cnblogs.com/xwdreamer/archive/2012/04/01/2428857.html</p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>47.序列化框架</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">https://blog.csdn.net/zlfprogram/article/details/74066841</p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>48.jdk1.8新特性</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#4f4f4f;">1. </span><span style="color:#4f4f4f;">速度更快</span><span style="color:#4f4f4f;"> – </span><strong><span style="color:#4f4f4f;">红黑树</span></strong><br><span style="color:#4f4f4f;">2. </span><span style="color:#4f4f4f;">代码更少</span><span style="color:#4f4f4f;"> – <strong>Lambda</strong><br> 3. </span><span style="color:#4f4f4f;">强大的</span><span style="color:#4f4f4f;">Stream API – <strong>Stream</strong><br> 4. </span><span style="color:#4f4f4f;">便于并行</span><span style="color:#4f4f4f;"> – <strong>Parallel</strong><br> 5. </span><span style="color:#4f4f4f;">最大化减少空指针异常</span><span style="color:#4f4f4f;"> – <strong>Optional</strong></span></p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>49.concurrentHashMap底层原理</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">在ConcurrentHashMap中，无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。特别地，在理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设为16），及任意数量线程的读操作。</p> <p style="margin-left:0cm;">ConcurrentHashMap本质上是一个Segment数组，而一个Segment实例又包含若干个桶，每个桶中都包含一条由若干个 HashEntry 对象链接起来的链表。总的来说，ConcurrentHashMap的高效并发机制是通过以下三方面来保证的(具体细节见后文阐述)：</p> <p style="margin-left:0cm;">通过锁分段技术保证并发环境下的写操作；</p> <p style="margin-left:0cm;">通过 HashEntry的不变性、Volatile变量的内存可见性和加锁重读机制保证高效、安全的读操作；</p> <p style="margin-left:0cm;">通过不加锁和加锁两种方案控制跨段操作的的安全性。</p> <p style="margin-left:0cm;"> </p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>50.springAop、springIoc的实现原理</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">springAop：</p> <p style="margin-left:0cm;"><span style="color:#4f4f4f;">实现</span><span style="color:#4f4f4f;">AOP</span><span style="color:#4f4f4f;">的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建</span><span style="color:#4f4f4f;">“</span><span style="color:#4f4f4f;">方面</span><span style="color:#4f4f4f;">”</span><span style="color:#4f4f4f;">，从而使得编译器可以在编译期间织入有关</span><span style="color:#4f4f4f;">“</span><span style="color:#4f4f4f;">方面</span><span style="color:#4f4f4f;">”</span><span style="color:#4f4f4f;">的代码。</span></p> <p style="margin-left:0cm;">springIoc的实现原理：</p> <p style="margin-left:0cm;">反射与工厂模式</p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>51.mybatis与hibernate中的区别</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><strong><span style="color:#000000;">2.1 </span></strong><strong><span style="color:#000000;">开发方面</span></strong></p> <p style="margin-left:0cm;">        <span style="color:#000000;">在项目开发过程当中，就速度而言：</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">            hibernate</span><span style="color:#000000;">开发中，</span><span style="color:#000000;">sql</span><span style="color:#000000;">语句已经被封装，直接可以使用，加快系统开发；</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">            Mybatis </span><span style="color:#000000;">属于半自动化，</span><span style="color:#000000;">sql</span><span style="color:#000000;">需要手工完成，稍微繁琐；</span></p> <p style="margin-left:0cm;">        <span style="color:#000000;">但是，凡事都不是绝对的，如果对于庞大复杂的系统项目来说，发杂语句较多，选择</span><span style="color:#000000;">hibernate </span><span style="color:#000000;">就不是一个好方案。</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">    <strong>2.2 sql</strong></span><strong><span style="color:#000000;">优化方面</span></strong></p> <p style="margin-left:0cm;"><span style="color:#000000;">        Hibernate </span><span style="color:#000000;">自动生成</span><span style="color:#000000;">sql,</span><span style="color:#000000;">有些语句较为繁琐，会多消耗一些性能；</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">        Mybatis </span><span style="color:#000000;">手动编写</span><span style="color:#000000;">sql</span><span style="color:#000000;">，可以避免不需要的查询，提高系统性能；</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">   <strong> 2.3 </strong></span><strong><span style="color:#000000;">对象管理比对</span></strong></p> <p style="margin-left:0cm;"><span style="color:#000000;">        Hibernate </span><span style="color:#000000;">是完整的对象</span><span style="color:#000000;">-</span><span style="color:#000000;">关系映射的框架，开发工程中，无需过多关注底层实现，只要去管理对象即可；</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">        Mybatis </span><span style="color:#000000;">需要自行管理</span> <span style="color:#000000;">映射关系；</span></p> <p style="margin-left:0cm;"><strong><span style="color:#000000;">    2.4 </span></strong><strong><span style="color:#000000;">缓存方面</span></strong><strong>    </strong></p> 
     <table align="left" border="1" cellspacing="0" style="width:538px;"><tbody><tr><td style="border-color:#C0C0C0;width:403.2pt;"> <p style="margin-left:0cm;"><strong>相同点：</strong></p> <p style="margin-left:0cm;">Hibernate和Mybatis的二级缓存除了采用系统默认的缓存机制外，都可以通过实现你自己的缓存或为其他第三方缓    存方案，创建适配器来完全覆盖缓存行为。</p> <p style="margin-left:0cm;"><strong>不同点：</strong></p> <p style="margin-left:0cm;"><strong>Hibernate</strong><strong>的二级缓存配置在SessionFactory生成的配置文件中进行详细配置，然后再在具体的表-对象映射中配置是那种缓存。</strong></p> <p style="margin-left:0cm;">MyBatis的二级缓存配置都是在每个具体的表-对象映射中进行详细配置，这样针对不同的表可以自定义不同的缓存机制。并且Mybatis可以在命名空间中共享相同的缓存配置和实例，通过Cache-ref来实现。</p> </td></tr></tbody></table><p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;"><strong><span style="color:#000000;">比较：</span></strong></p> <p style="margin-left:0cm;"><strong><span style="color:#000000;">          Hibernate </span></strong><span style="color:#000000;">具有良好的管理机制，用户不需要关注</span><span style="color:#000000;">SQL</span><span style="color:#000000;">，如果二级缓存出现脏数据，系统会保存，；</span></p> <p style="margin-left:0cm;"><span style="color:#000000;">           Mybatis </span><span style="color:#000000;">在使用的时候要谨慎，避免缓存</span><span style="color:#000000;">CAche </span><span style="color:#000000;">的使用。</span></p> <p style="margin-left:0cm;"> </p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>52.struts2与springmvc的区别</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">区别1：</p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;">Struts2 的核心是基于一个Filter即StrutsPreparedAndExcuteFilter</p> <p style="margin-left:0cm;">SpringMvc的核心是基于一个Servlet即DispatcherServlet(前端控制器)</p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;">区别2：</p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;">Struts2是基于类开发的，传递的参数是通过类的属性传递(属性驱动和模型驱动),所以只能设计成多例prototype</p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;">SpringMvc是基于类中的方法开发的，也就是一个url对应一个方法，传递参数是传到方法的形参上面，所以既可以是单例模式也可以是多例模式singiton</p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;">区别3：</p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;">Struts2采用的是值栈存储请求以及响应数据，OGNL存取数据</p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;">SpringMvc采用request来解析请求内容，然后由其内部的getParameter给方法中形参赋值，再把后台处理过的数据通过ModelAndView对象存储，Model存储数据，View存储返回的页面，再把对象通过request传输到页面去。</p> <p style="margin-left:0cm;">---------------------</p> <p style="margin-left:0cm;">作者：爪哇小明</p> <p style="margin-left:0cm;">来源：CSDN</p> <p style="margin-left:0cm;">原文：https://blog.csdn.net/weixin_38429587/article/details/79050550?utm_source=copy</p> <p style="margin-left:0cm;">版权声明：本文为博主原创文章，转载请附上博文链接！</p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>53.jsp的内置对象的作用</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#333333;">1</span><span style="color:#333333;">、pageContext 表示页容器 –&gt;EL、标签、上传</span><br><span style="color:#333333;">2</span><span style="color:#333333;">、request 服务器端取得客户端的信息：头信息、Cookie、请求参数、MVC设计模式</span><br><span style="color:#333333;">3</span><span style="color:#333333;">、response 服务器端回应给客户端信息：Cookie、重定向</span><br><span style="color:#333333;">4</span><span style="color:#333333;">、session 表示每一个用户，用于登录验证上</span><br><span style="color:#333333;">5</span><span style="color:#333333;">、application 表示整个服务器，getRealPath()</span><br><span style="color:#333333;">6</span><span style="color:#333333;">、config 去的初始化参数，初始化参数在web.xml中配置</span><br><span style="color:#333333;">7</span><span style="color:#333333;">、exception 表示的是错误页的处理操作</span><br><span style="color:#333333;">8</span><span style="color:#333333;">、page 如同this一样，表示整个JSP页面</span><br><span style="color:#333333;">9</span><span style="color:#333333;">、out 输出，但是尽量使用表达式输出</span></p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>54.简述uml中include跟extend的区别</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">https://www.cnblogs.com/wangyaning/p/3740899.html</p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>55.简述软件复用与重用的区别</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#000000;">软件复用是指在构造新的软件系统的过程中，对已存在的软件人工制品的使用技术。</span><br><span style="color:#000000;">如果是在一个系统中多次使用一个相同的软件成分，这叫软件共享。</span><br><span style="color:#000000;">对一个软件进行修改，使它能运行于新的软、硬件平台这称作软件移植。</span></p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>56.servlet的五个加载方法</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;"><span style="color:#494949;">init()</span><span style="color:#494949;">：在Servlet实例化后，Servlet容器会调用init()方法，来初始化该对象，主要是为了让Servlet对象在处理客户请求前可以完成一些初始化的工作。例如：建立数据库连接，获取配置信息等。对于每一个Servlet实例，init()方法只能被调用一次。init()方法有一个类型为ServletConfig的参数，Servlet容器通过这个参数向Servlet传递配置信息。Servlet使用ServletConfig对象从Web应用程序的配置信息中获取以名-值对形式提供的初始化参数。另外，在Servlet中，还可以通过ServletConfig对象获取描述Servlet运行环境的ServletContext对象，使用该对象，Servlet可以和它的Servlet容器进行通信。</span></p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;"><span style="color:#494949;">service():</span><span style="color:#494949;">容器调用service()方法来处理客户端的请求。要注意的是，在service()方法被容器调用之前，必须确保init()方法正确完成。容器会构造一个表示客户端请求信息的请求对象(类型为ServletRequest)和一个用于对客户端进行响应的响应对象(类型为ServletResponse)作为参数传递给service()方法。在service()方法中，Servlet对象通过ServletRequest对象得到客户端的相关信息和请求信息，在对请求进行处理后，调用ServletResponse对象的方法设置响应信息。</span></p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;"><span style="color:#494949;">destroy():</span><span style="color:#494949;">当容器检测到一个Servlet对象应该从服务中被移除的时候，容器会调用该对象的destroy()方法，以便让Servlet对象可以释放它所使用的资源，保存数据到持久存储设备中。例如：将内存中的数据保存到数据库中，关闭数据库的连接等。当需要释放内存或容器关闭时，容器就会调用Servlet对象的destroy()方法。在Servlet容器调用destroy()方法前，如果还有其他的线程正在service()方法中执行，容器会等待这些线程执行完毕或等待服务器设定的超时值到达。一旦Servlet对象的destroy()方法被调用，容器不会再把其他的请求发送给该对象。如果需要该Servlet再次为客户端服务，容器会重新产生一个Servlet对象来处理客户端的请求。在destroy()方法调用后，容器会释放这个Servlet对象，在随后的时候内，该对象会被Java的垃圾收集器所回收。</span></p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;"><span style="color:#494949;">getServletConfig():</span><span style="color:#494949;">该方法返回容器调用init()方法时传递给Servlet对象的ServletConfig对象，ServletConfig对象包含了Servlet的初始化参数。</span></p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;"><span style="color:#494949;">getServletInfo():</span><span style="color:#494949;">返回一个String类型的字符串，其中包括了关于Servlet的信息，例如，作者、版本和版权。该方法返回的应该是纯文本字符串，而不是任何类型的标记(HTML,XML等)。</span></p> <p style="margin-left:0cm;"> </p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>57.Oracle常用函数</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> 
     <table border="1" cellspacing="0" style="width:538px;"><tbody><tr><td style="border-color:#C0C0C0;vertical-align:top;width:147.2pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">ASCII(X)</span></p> </td><td style="border-color:#C0C0C0;vertical-align:top;width:256pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">返回字符</span><span style="color:#000066;">X</span><span style="color:#000066;">的</span><span style="color:#000066;">ASCII</span><span style="color:#000066;">码</span></p> </td></tr><tr><td style="border-color:#C0C0C0;vertical-align:top;width:147.2pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">CONCAT(X,Y)</span></p> </td><td style="vertical-align:top;width:256pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">连接字符串</span><span style="color:#000066;">X</span><span style="color:#000066;">和</span><span style="color:#000066;">Y</span></p> </td></tr><tr><td style="border-color:#C0C0C0;vertical-align:top;width:147.2pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">INSTR(X,STR[,START][,N)</span></p> </td><td style="vertical-align:top;width:256pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">从</span><span style="color:#000066;">X</span><span style="color:#000066;">中查找</span><span style="color:#000066;">str</span><span style="color:#000066;">，可以指定从</span><span style="color:#000066;">start</span><span style="color:#000066;">开始，也可以指定从</span><span style="color:#000066;">n</span><span style="color:#000066;">开始</span></p> </td></tr><tr><td style="border-color:#C0C0C0;vertical-align:top;width:147.2pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">LENGTH(X)</span></p> </td><td style="vertical-align:top;width:256pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">返回</span><span style="color:#000066;">X</span><span style="color:#000066;">的长度</span></p> </td></tr><tr><td style="border-color:#C0C0C0;vertical-align:top;width:147.2pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">LOWER(X)</span></p> </td><td style="vertical-align:top;width:256pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">X</span><span style="color:#000066;">转换成小写</span></p> </td></tr><tr><td style="border-color:#C0C0C0;vertical-align:top;width:147.2pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">UPPER(X)</span></p> </td><td style="vertical-align:top;width:256pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">X</span><span style="color:#000066;">转换成大写</span></p> </td></tr><tr><td style="border-color:#C0C0C0;vertical-align:top;width:147.2pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">LTRIM(X[,TRIM_STR])</span></p> </td><td style="vertical-align:top;width:256pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">把</span><span style="color:#000066;">X</span><span style="color:#000066;">的左边截去</span><span style="color:#000066;">trim_str</span><span style="color:#000066;">字符串，缺省截去空格</span></p> </td></tr><tr><td style="border-color:#C0C0C0;vertical-align:top;width:147.2pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">RTRIM(X[,TRIM_STR])</span></p> </td><td style="vertical-align:top;width:256pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">把</span><span style="color:#000066;">X</span><span style="color:#000066;">的右边截去</span><span style="color:#000066;">trim_str</span><span style="color:#000066;">字符串，缺省截去空格</span></p> </td></tr><tr><td style="border-color:#C0C0C0;vertical-align:top;width:147.2pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">TRIM([TRIM_STR  FROM]X)</span></p> </td><td style="vertical-align:top;width:256pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">把</span><span style="color:#000066;">X</span><span style="color:#000066;">的两边截去</span><span style="color:#000066;">trim_str</span><span style="color:#000066;">字符串，缺省截去空格</span></p> </td></tr><tr><td style="border-color:#C0C0C0;vertical-align:top;width:147.2pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">REPLACE(X,old,new)</span></p> </td><td style="vertical-align:top;width:256pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">在</span><span style="color:#000066;">X</span><span style="color:#000066;">中查找</span><span style="color:#000066;">old</span><span style="color:#000066;">，并替换成</span><span style="color:#000066;">new</span></p> </td></tr><tr><td style="border-color:#C0C0C0;vertical-align:top;width:147.2pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">SUBSTR(X,start[,length])</span></p> </td><td style="vertical-align:top;width:256pt;"> <p style="margin-left:0cm;"><span style="color:#000066;">返回</span><span style="color:#000066;">X</span><span style="color:#000066;">的字串，从</span><span style="color:#000066;">start</span><span style="color:#000066;">处开始，截取</span><span style="color:#000066;">length</span><span style="color:#000066;">个字符，缺省</span><span style="color:#000066;">length</span><span style="color:#000066;">，默认到结尾</span></p> </td></tr></tbody></table><p style="margin-left:0cm;"> </p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>58.springmvc的加载顺序</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">1、客户端发起请求、前端控制器统一（org.springframework.web.servlet.DispatcherServlet）进行拦截。调用其中的doService(..)方法。再调用其中的doDispatch(..)方法</p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;">2、根据请求查询请求的处理器映射器。返回HandlerExecutionChain处理器执行链。</p> <p style="margin-left:0cm;">mappedHandler = getHandler(processedRequest, false);</p> <p style="margin-left:0cm;">3、获取处理器适配器。</p> <p style="margin-left:0cm;">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</p> <p style="margin-left:0cm;">4、由获取到的处理器适配器执行处理器方法。</p> <p style="margin-left:0cm;">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</p> <p style="margin-left:0cm;">5、处理器执行完成后返回modelAndView</p> <p style="margin-left:0cm;">6、将modelandview 传递给视图解析器。进行数据绑定。</p> <p style="margin-left:0cm;">7、响应给客户端</p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>59.解析json数据的方式</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">https://www.cnblogs.com/zhujiabin/p/5498272.html</p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>60.ajax的数据类型</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">"xml": 返回 XML 文档，可用 jQuery 处理。"html": 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行。"script": 返回纯文本 JavaScript 代码。不会自动缓存结果。除非设置了 "cache" 参数。注意：在远程请求时(不在同一个域下)，所有 POST 请求都将转为 GET 请求。（因为将使用 DOM 的 script标签来加载）"json": 返回 JSON 数据 。"jsonp": JSONP 格式。使用 JSONP 形式调用函数时，如 "myurl?callback=?" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数。"text": 返回纯文本字符串</p> <p style="margin-left:0cm;"> </p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>61.springAop一般用在那些地方</strong></h2> 
 <table border="1" cellspacing="0" style="width:553px;"><tbody><tr><td style="vertical-align:top;width:414.8pt;"> <p style="margin-left:0cm;">事务</p> <p style="margin-left:0cm;">缓存</p> <p style="margin-left:0cm;">异常</p> <p style="margin-left:0cm;">日志</p> </td></tr></tbody></table> 
 <h2 style="margin-left:0cm;"><strong>62List Set Map 的区别</strong></h2> 
 <p style="margin-left:0cm;">       <a href="https://www.cnblogs.com/IvesHe/p/6108933.html" rel="nofollow">https://www.cnblogs.com/IvesHe/p/6108933.html</a></p> 
 <h2 style="margin-left:0cm;"><strong>63 MySql 事务的原理</strong></h2> 
 <p style="margin-left:0cm;">    <span style="color:#333333;">一个事务会涉及到大量的</span><span style="color:#333333;">cpu</span><span style="color:#333333;">计算和</span><span style="color:#333333;">IO</span><span style="color:#333333;">操作</span><span style="color:#333333;">,</span><span style="color:#333333;">这些操作被打包成一个执行单元</span><span style="color:#333333;">,</span><span style="color:#333333;">要么同时都完成</span><span style="color:#333333;">,</span><span style="color:#333333;">要么同时都不完成</span><span style="color:#333333;">.</span></p> 
 <p style="margin-left:0cm;">     <span style="color:#333333;">事务是一组原子性的</span><span style="color:#333333;">sql</span><span style="color:#333333;">命令或者说是一个独立的工作单元</span><span style="color:#333333;">,</span><span style="color:#333333;">如果数据库引擎能够成功的对数据库应用该组的全部</span><span style="color:#333333;">sql</span><span style="color:#333333;">语句</span><span style="color:#333333;">,</span><span style="color:#333333;">那么就执行该组命令</span></p> 
 <p style="margin-left:0cm;">     <span style="color:#333333;">如果其中有任何一条语句因为崩溃或者其它原因无法执行</span><span style="color:#333333;">,</span><span style="color:#333333;">那么该组中所有的</span><span style="color:#333333;">sql</span><span style="color:#333333;">语句都不会执行</span></p> 
 <p style="margin-left:0cm;">     <span style="color:#333333;">如果没有显示启动事务</span><span style="color:#333333;">,</span><span style="color:#333333;">数据库会根据</span><span style="color:#333333;">autocommit</span><span style="color:#333333;">的值</span><span style="color:#333333;">.</span><span style="color:#333333;">默认每条</span><span style="color:#333333;">sql</span><span style="color:#333333;">操作都会自动提交</span><span style="color:#333333;">.</span></p> 
 <p><strong>   <span style="color:#399ab2;">原子性</span></strong></p> 
 <p style="margin-left:0cm;">        <span style="color:#333333;">一个事务中的所有操作</span><span style="color:#333333;">,</span><span style="color:#333333;">要么都完成</span><span style="color:#333333;">,</span><span style="color:#333333;">要么都不执行</span><span style="color:#333333;">.</span><span style="color:#333333;">对于一个事务来说</span><span style="color:#333333;">,</span><span style="color:#333333;">不可能只执行其中的一部分</span><span style="color:#333333;">.</span></p> 
 <p><strong>   <span style="color:#399ab2;">一致性</span></strong></p> 
 <p style="margin-left:0cm;">       <span style="color:#333333;">数据库总是从一个一致性的状态转换到另外一个一致性状态</span><span style="color:#333333;">.</span></p> 
 <p><strong>   <span style="color:#399ab2;">隔离性</span></strong></p> 
 <p style="margin-left:0cm;">       <span style="color:#333333;">一个事务所做的修改在最终提交以前</span><span style="color:#333333;">,</span><span style="color:#333333;">对其它事务是不可见的</span><span style="color:#333333;">.</span><span style="color:#333333;">多个事务之间的操作相互不影响</span><span style="color:#333333;">. </span><span style="color:#333333;">每降低一个事务隔离级别都能提高数据库的并发</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">       1.</span><span style="color:#333333;">读未提交</span>          <span style="color:#333333;">其它事务未提交就可以读</span><br><span style="color:#333333;">       2.</span><span style="color:#333333;">读已提交</span>          <span style="color:#333333;">其它事务只有提交了才能读</span><br><span style="color:#333333;">       3.</span><span style="color:#333333;">可重复读</span>          <span style="color:#333333;">只管自己启动事务时候的状态</span><span style="color:#333333;">,</span><span style="color:#333333;">不受其它事务的影响</span><span style="color:#333333;">(mysql</span><span style="color:#333333;">默认</span><span style="color:#333333;">)<br>        4.</span><span style="color:#333333;">事务串行</span>          <span style="color:#333333;">按照顺序提交事务保证了数据的安全性</span><span style="color:#333333;">,</span><span style="color:#333333;">但无法实现并发</span></p> 
 <p><strong>   <span style="color:#399ab2;">持久性</span></strong></p> 
 <p style="margin-left:0cm;">          <span style="color:#333333;">一旦一个事务已经提交了</span><span style="color:#333333;">,</span><span style="color:#333333;">就算服务器崩溃</span><span style="color:#333333;">,</span><span style="color:#333333;">仍然需要在下次启动的时候自动恢复</span><span style="color:#333333;">.</span></p> 
 <p style="margin-left:0cm;">         <span style="color:#333333;">结合事务日志完成</span><span style="color:#333333;">:</span></p> 
 <p style="margin-left:0cm;">                <span style="color:#333333;">事务日志写入磁盘的时候是顺序</span><span style="color:#333333;">IO,</span><span style="color:#333333;">写数据文件的时候是随机</span><span style="color:#333333;">IO</span></p> 
 <p style="margin-left:0cm;">         <span style="color:#333333;">一旦事务提交了</span><span style="color:#333333;">,</span><span style="color:#333333;">必须立即执行一个</span><span style="color:#333333;">IO</span><span style="color:#333333;">操作</span><span style="color:#333333;">,</span><span style="color:#333333;">确保此事务立即写入磁盘</span><span style="color:#333333;">.</span></p> 
 <p style="margin-left:0cm;">                </p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">事务的状态</span></p> 
 <p style="margin-left:0cm;">      <span style="color:#333333;">活动</span></p> 
 <p style="margin-left:0cm;">      <span style="color:#333333;">部分提交</span></p> 
 <p style="margin-left:0cm;">      <span style="color:#333333;">失败</span></p> 
 <p style="margin-left:0cm;">      <span style="color:#333333;">中止</span></p> 
 <p style="margin-left:0cm;">      <span style="color:#333333;">提交</span></p> 
 <p style="margin-left:0cm;">            <span style="color:#333333;">事务一旦成功提交</span><span style="color:#333333;">,</span><span style="color:#333333;">便无法再撤销</span><span style="color:#333333;">.</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">事务并发访问控制方式</span><span style="color:#333333;">:</span></p> 
 <p style="margin-left:0cm;">    <span style="color:#333333;">锁</span></p> 
 <p style="margin-left:0cm;">    <span style="color:#333333;">时间</span></p> 
 <p style="margin-left:0cm;">    <span style="color:#333333;">多版本和快照隔离</span><span style="color:#333333;">(mvcc)</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">    MVCC</span><span style="color:#333333;">是行级锁的一个变种</span><span style="color:#333333;">,</span><span style="color:#333333;">但是它在很多情况下避免了加锁操作</span><span style="color:#333333;">,</span><span style="color:#333333;">因此开销更低</span><span style="color:#333333;">,</span><span style="color:#333333;">虽然实现机制有所不同</span><span style="color:#333333;">,</span><span style="color:#333333;">但大都实现了非阻塞的读操作</span><span style="color:#333333;">,</span><span style="color:#333333;">写操作也只锁定必要的行</span><span style="color:#333333;">.</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">    MVCC</span><span style="color:#333333;">的实现是通过保存数据在某个时间点的快照来实现的</span><span style="color:#333333;">,</span><span style="color:#333333;">也就是说</span><span style="color:#333333;">,</span><span style="color:#333333;">不管需要执行多长时间</span><span style="color:#333333;">,</span><span style="color:#333333;">只要事务开始时间相同</span><span style="color:#333333;">,</span><span style="color:#333333;">每个事务看到的数据都是一致的</span><span style="color:#333333;">,</span><span style="color:#333333;">事务开始的时间不同时</span><span style="color:#333333;">,</span><span style="color:#333333;">每个事务对同一张表</span><span style="color:#333333;">,</span><span style="color:#333333;">同一时刻看到的数据可能是不一样的</span><span style="color:#333333;">(</span><span style="color:#333333;">因为不同的时间点可能数据就已经产生了不同的快照版本，而每个事务在默认的</span><span style="color:#333333;">RR</span><span style="color:#333333;">隔离级别下只能看到事务开始时的数据快照</span><span style="color:#333333;">)</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;"> innodd</span><span style="color:#333333;">的</span><span style="color:#333333;">mvcc</span><span style="color:#333333;">是通过在每行记录后面保存两个隐藏列来实现的</span><span style="color:#333333;">.</span><span style="color:#333333;">这两个列</span><span style="color:#333333;">,</span><span style="color:#333333;">一个保存了行的创建时间</span><span style="color:#333333;">.</span><span style="color:#333333;">一个保存了行的过期时间</span><span style="color:#333333;">(</span><span style="color:#333333;">删除时间</span><span style="color:#333333;">).</span><span style="color:#333333;">列里面存储的并不是实际的时间值</span><span style="color:#333333;">.</span><span style="color:#333333;">而是系统版本号</span><span style="color:#333333;">.</span><span style="color:#333333;">每开启一个新的事务</span><span style="color:#333333;">,</span><span style="color:#333333;">系统版本号都会自动递增</span><span style="color:#333333;">.</span></p> 
 <p style="margin-left:0cm;">  <span style="color:#333333;">一个事务在开启的时刻的系统版本号作为当前事务的版本号</span><span style="color:#333333;">,</span><span style="color:#333333;">用来和查询到的每行记录的版本号做对比</span><span style="color:#333333;">.mvcc</span><span style="color:#333333;">具体操作如下</span><span style="color:#333333;">:</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">  select:</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">   A:</span><span style="color:#333333;">过滤创建版本</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">      innodb</span><span style="color:#333333;">只查找版本早于当前事务版本的数据行</span><span style="color:#333333;">(</span><span style="color:#333333;">也就是</span><span style="color:#333333;">,</span><span style="color:#333333;">行的系统版本号小于或等于事务的系统版本号</span><span style="color:#333333;">),</span><span style="color:#333333;">这样可以确保事务读取的行</span><span style="color:#333333;">,</span><span style="color:#333333;">要么是在事务开始之前已经存在</span><span style="color:#333333;">,</span><span style="color:#333333;">要么是事务自身插入或修改的数据</span><span style="color:#333333;">.</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">  B: </span><span style="color:#333333;">过滤删除版本</span></p> 
 <p style="margin-left:0cm;">       <span style="color:#333333;">行的删除版本要么未定义</span><span style="color:#333333;">,</span><span style="color:#333333;">要么大于当前事务版本号</span><span style="color:#333333;">,</span><span style="color:#333333;">这可以确保事务读取到的行</span><span style="color:#333333;">,</span><span style="color:#333333;">在事务开始之前未被删除（即</span><span style="color:#333333;">,</span><span style="color:#333333;">这样做的目的是为了事务不会读取到被真正删除的行</span><span style="color:#333333;">,</span><span style="color:#333333;">删除版本号小于当前事务版本号的表示操作删除记录的事务已经提交</span><span style="color:#333333;">--</span><span style="color:#333333;">数据已经被删除，删除版本号大于当前事务版本号的表示这个事务是在当前事务之后开始的</span><span style="color:#333333;">--</span><span style="color:#333333;">当前事务开始时这些记录是还存在的</span><span style="color:#333333;">,</span><span style="color:#333333;">根据事务的隔离性</span><span style="color:#333333;">,</span><span style="color:#333333;">一致性要求</span><span style="color:#333333;">,</span><span style="color:#333333;">之后开始的事务操作的记录并提交</span><span style="color:#333333;">,</span><span style="color:#333333;">对当前事务不可见</span><span style="color:#333333;">,</span><span style="color:#333333;">所以还需要当前事务能够查询这些记录</span><span style="color:#333333;">--</span><span style="color:#333333;">只能够查询</span><span style="color:#333333;">,</span><span style="color:#333333;">不能够修改和删除）</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">只有满足以上两个条件的才可以返回作为查询结果</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">insert</span><span style="color:#333333;">：</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">      innodb</span><span style="color:#333333;">为新插入的每一行保存当前系统版本号作为行版本号</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">delete</span><span style="color:#333333;">：</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">      innodb</span><span style="color:#333333;">为删除的每一行保存当前系统版本号作为行删除标识</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">update</span><span style="color:#333333;">：</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">     innodb</span><span style="color:#333333;">为插入一行新记录</span><span style="color:#333333;">,</span><span style="color:#333333;">保存当前系统版本号作为行版本号</span></p> 
 <p style="margin-left:0cm;">     <span style="color:#333333;">修改表中原来行把当前系统版本号更新到原来的行作为行删除版本号</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">保存这两个额外的系统版本号，使大多数读操作都可以不用加锁，这样设计使得读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，不足之处是每行记录都需要额外的存储空间，需要做更多的行检查工作，以及一些额外的维护工作。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">MVCC</span><span style="color:#333333;">只在</span><span style="color:#333333;">repeatable-read</span><span style="color:#333333;">和</span><span style="color:#333333;">read-committed</span><span style="color:#333333;">两个隔离级别下才工作，其他两个隔离级别都和</span><span style="color:#333333;">MVCC</span><span style="color:#333333;">不兼容，因为</span><span style="color:#333333;">read uncommitted</span><span style="color:#333333;">总是读取最新的数据行，而不是符合当前事务版本的数据行，而</span><span style="color:#333333;">serializeble</span><span style="color:#333333;">则会对所有读取的行都加锁。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">另外要注意：</span><span style="color:#333333;">MVCC</span><span style="color:#333333;">在</span><span style="color:#333333;">RR</span><span style="color:#333333;">和</span><span style="color:#333333;">RC</span><span style="color:#333333;">隔离级别下的区别，在</span><span style="color:#333333;">RR</span><span style="color:#333333;">隔离级别下，一个事务只能读取到事务开始的那个时刻的数据快照，即，别的事务修改并提交的数据在自身没有提交之前一般读取不到（加</span><span style="color:#333333;">for update</span><span style="color:#333333;">语句的</span><span style="color:#333333;">select</span><span style="color:#333333;">除外，因为这个语句要对数据加</span><span style="color:#333333;">X</span><span style="color:#333333;">锁必须读取最新的数据快照），在</span><span style="color:#333333;">RC</span><span style="color:#333333;">隔离级别下，事务总是读取数据行的最新快照，即会产生不可重复读的问题。</span></p> 
 <p style="margin-left:0cm;">      </p> 
 <h4 style="margin-left:0cm;"><strong><span style="color:#FFFFFF;">死锁</span></strong></h4> 
 <p style="margin-left:0cm;">    <span style="color:#333333;">两个或者多个事务在同一资源上相互占用</span><span style="color:#333333;">,</span><span style="color:#333333;">并请求锁定对方占用的资源的状态</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h4 style="margin-left:0cm;"><strong><span style="color:#FFFFFF;">事务提交</span></strong></h4> 
 <p><strong>    <span style="color:#399ab2;">自动提交</span></strong></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">     mysql</span><span style="color:#333333;">默认采用自动提交</span><span style="color:#333333;">(AUTOCOMMIT)</span><span style="color:#333333;">模式</span><span style="color:#333333;">.</span><span style="color:#333333;">如果没有显示的开始一个事务</span><span style="color:#333333;">,</span><span style="color:#333333;">那么每条</span><span style="color:#333333;">sql</span><span style="color:#333333;">语句都会被当作一个事务执行提交的操作</span></p> 
 <p style="margin-left:0cm;">     <span style="color:#333333;">当</span><span style="color:#333333;">AUTOCOMMIT=0</span><span style="color:#333333;">的时候所有的</span><span style="color:#333333;">sql</span><span style="color:#333333;">语句都是在一个事务中</span><span style="color:#333333;">,</span><span style="color:#333333;">直到显示的执行</span><span style="color:#333333;">COMMIT</span><span style="color:#333333;">和</span><span style="color:#333333;">ROLLBACK</span><span style="color:#333333;">回滚该事务结束</span><span style="color:#333333;">.</span><span style="color:#333333;">同时又开始了另外一个新的事务</span><span style="color:#333333;">.</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p><strong>    <span style="color:#399ab2;">显式提交</span></strong></p> 
 <p style="margin-left:0cm;">     <span style="color:#333333;">开启事务</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">            START TRANSACTION </span></p> 
 <p style="margin-left:0cm;">     <span style="color:#333333;">结束事务</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">          (1)  COMMIT:         </span><span style="color:#333333;">提交</span> </p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">          (2)  ROLLBACK:    </span><span style="color:#333333;">回滚</span> </p> 
 <p style="margin-left:0cm;">   </p> 
 <p style="margin-left:0cm;">     <span style="color:#333333;">注意：一旦一个事务成功提交</span><span style="color:#333333;">,</span><span style="color:#333333;">将无法回滚</span><span style="color:#333333;">.</span><span style="color:#333333;">一个事务要想回滚</span><span style="color:#333333;">,</span><span style="color:#333333;">只能在没有提交成功之前执行回滚</span></p> 
 <p style="margin-left:0cm;">                <span style="color:#333333;">只有事务型存储引擎中的</span><span style="color:#333333;">DML</span><span style="color:#333333;">语句方能支持此类操作</span></p> 
 <p style="margin-left:0cm;">     <span style="color:#333333;">建议：显式请求和提交事务</span><span style="color:#333333;">,</span><span style="color:#333333;">而不要使用</span><span style="color:#333333;">“</span><span style="color:#333333;">自动提交</span><span style="color:#333333;">”</span><span style="color:#333333;">功能</span><span style="color:#333333;"> set autocommit={1|0}</span></p> 
 <p style="margin-left:0cm;">     <span style="color:#333333;">事务支持保存点</span><span style="color:#333333;"> savepoint</span><span style="color:#333333;">：</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">            SAVEPOINT identifier</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">            ROLLBACK [WORK] TO [SAVEPOINT]  identifier</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">            RELEASE SAVEPOINT identifier </span></p> 
 <p style="margin-left:0cm;"> </p> 
 <h4 style="margin-left:0cm;"><strong><span style="color:#FFFFFF;">事务日志</span></strong></h4> 
 <p style="margin-left:0cm;">     <span style="color:#333333;">事务要保证</span><span style="color:#333333;">ACID</span><span style="color:#333333;">的完整性必须依靠事务日志做跟踪</span><span style="color:#333333;">,</span><span style="color:#333333;">每一个操作在真正写入数据数据库之前</span><span style="color:#333333;">,</span><span style="color:#333333;">先写入到日志文件中</span><br>      <span style="color:#333333;">如要删除一行数据会先在日志文件中将此行标记为删除</span><span style="color:#333333;">,</span><span style="color:#333333;">但是数据库中的数据文件并没有发生变化</span><span style="color:#333333;">.</span></p> 
 <p style="margin-left:0cm;">     <span style="color:#333333;">只有在</span><span style="color:#333333;">(</span><span style="color:#333333;">包含多个</span><span style="color:#333333;">sql</span><span style="color:#333333;">语句</span><span style="color:#333333;">)</span><span style="color:#333333;">整个事务提交后</span><span style="color:#333333;">,</span><span style="color:#333333;">再把整个事务中的</span><span style="color:#333333;">sql</span><span style="color:#333333;">语句批量同步到磁盘上的数据库文件</span></p> 
 <p style="margin-left:0cm;">     <span style="color:#333333;">在事务引擎上的每一次写操作都需要执行两遍</span><span style="color:#333333;">:<br>         1.</span><span style="color:#333333;">先写入日志文件中</span><br>                 <span style="color:#333333;">写入日志文件中的仅仅是操作过程</span><span style="color:#333333;">,</span><span style="color:#333333;">而不是操作数据本身</span><span style="color:#333333;">,</span><span style="color:#333333;">所以速度比写数据库文件速度要快很多</span><span style="color:#333333;">.<br>         2.</span><span style="color:#333333;">然后再写入数据库文件中</span></p> 
 <p style="margin-left:0cm;">                <span style="color:#333333;">写入数据库文件的操作是重做事务日志中已提交的事务操作的记录</span><span style="color:#333333;">.</span></p> 
 <p style="margin-left:0cm;">    <span style="color:#333333;">日志组</span><br>          <span style="color:#333333;">一般不止设置一个日志文件</span><span style="color:#333333;">,</span><span style="color:#333333;">一个文件写满之后使用另外一个日志文件提高服务器效率</span><span style="color:#333333;">.</span></p> 
 <p style="margin-left:0cm;">    <span style="color:#333333;">日志文件的日志同步到磁盘后空间会自动释放</span><span style="color:#333333;">,</span><span style="color:#333333;">单个日志文件不宜设置过大</span>     <span style="color:#333333;">如果日志文件过大</span><span style="color:#333333;">mysql</span><span style="color:#333333;">进程在把日志同步到数据文件的时候可能会崩溃</span></p> 
 <p><strong>  <span style="color:#399ab2;">事务日志的用途</span></strong></p> 
 <p style="margin-left:0cm;">      <span style="color:#333333;">事务日志可以帮助提高事务的效率</span><span style="color:#333333;">,</span><span style="color:#333333;">使用事务日志</span><span style="color:#333333;">,</span><span style="color:#333333;">存储引擎在修改表的数据的时候只需要修改其内存拷贝</span><span style="color:#333333;">,</span><span style="color:#333333;">再把该行为记录到持久在磁盘的事务日志中</span><span style="color:#333333;">.</span><span style="color:#333333;">而不用每次都将修改的数据本身持久到磁盘</span><span style="color:#333333;">.</span><span style="color:#333333;">事务日志采用的是追加方式</span><span style="color:#333333;">,</span><span style="color:#333333;">因此写日志的操作是磁盘上一小块区域的顺序</span><span style="color:#333333;">IO,</span><span style="color:#333333;">而不像随机</span><span style="color:#333333;">IO</span><span style="color:#333333;">需要磁盘在多个地方移动</span><span style="color:#333333;">.</span><span style="color:#333333;">所以采用事务日志的方式相对来说要快的多</span><span style="color:#333333;">,</span><span style="color:#333333;">事务日志持久后</span><span style="color:#333333;">,</span><span style="color:#333333;">内存中的修改在后台慢慢的刷回磁盘</span><span style="color:#333333;">.</span><span style="color:#333333;">期间如果系统发生崩溃</span><span style="color:#333333;">,</span><span style="color:#333333;">存储引擎在重启的时候依靠事务日志自动恢复这部分被修改数据</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>64 一个方法里面 有一个String参数 这个参数里有符号字符汉字数字  要求将参数里的数字挑选出来  进行相加  求和</strong></h2> 
 <p style="margin-left:0cm;">       答: <span style="color:#333333;">需要使用</span><span style="color:#333333;"> String </span><span style="color:#333333;">类中提供的</span><span style="color:#333333;"> toCharArray() </span><em><span style="color:#cc0000;">方法</span></em><span style="color:#333333;">进行</span> <span style="color:#333333;">分割操作</span> <span style="color:#333333;">分割成单个字符</span>  <span style="color:#333333;">将每个字符进行</span><span style="color:#333333;">int</span><span style="color:#333333;">转换</span>  <span style="color:#333333;">转换成功</span> <span style="color:#333333;">就相加</span>  <span style="color:#333333;">否则不相加</span></p> 
 <p style="margin-left:0cm;"></p> 
 <h2 style="margin-left:0cm;"><strong>65 一个方法里面 有一个Object参数  这个参数可能是  List,Map,Set  这三种类型如何判断该方法传入的参数是何种类型</strong></h2> 
 <p style="margin-left:0cm;">使用Java 反射   Object   obj.getClass().getTypeName()  即可判断</p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>66 说出你使用的第三方API 如:支付宝,微信</strong></h2> 
 <p style="margin-left:0cm;">微信支付,微信登录,支付宝支付,支付宝登录,QQ登录,微博登录,百度地图,高的地图,腾讯短信,阿里云短信,</p> 
 <h2 style="margin-left:0cm;"><strong>67 redis 的常用方法  </strong></h2> 
 <p style="margin-left:0cm;">get</p> 
 <p style="margin-left:0cm;">set</p> 
 <p style="margin-left:0cm;">hset</p> 
 <p style="margin-left:0cm;">hget</p> 
 <p style="margin-left:0cm;">lset</p> 
 <p style="margin-left:0cm;">lget</p> 
 <p style="margin-left:0cm;">ldel</p> 
 <p style="margin-left:0cm;">hdel</p> 
 <p style="margin-left:0cm;">del</p> 
 <p style="margin-left:0cm;">exist</p> 
 <p style="margin-left:0cm;">hxistes</p> 
 <ol><li>EXPIRE 将key的生存时间设置为ttl秒</li><li>PEXPIRE 将key的生成时间设置为ttl毫秒</li><li>EXPIREAT 将key的过期时间设置为timestamp所代表的的秒数的时间戳</li><li>PEXPIREAT 将key的过期时间设置为timestamp所代表的的毫秒数的时间戳</li></ol> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>68 Mybatis Mapper配置文件里的常用标签</strong></h2> 
 <p style="margin-left:0cm;"></p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>69 Spring 运行流程(tomcat启动时Spring在干什么)</strong></h2> 
 <h2 style="margin-left:0cm;"><strong>70 zookeeper节点类型</strong></h2> 
 <p style="margin-left:0cm;">PERSISTENT                持久化节点</p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;">PERSISTENT_SEQUENTIAL     顺序自动编号持久化节点，这种节点会根据当前已存在的节点数自动加 1</p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;">EPHEMERAL                 临时节点， 客户端session超时这类节点就会被自动删除</p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;">EPHEMERAL_SEQUENTIAL      临时自动编号节点</p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>71 Redis   缓存雪崩,穿透</strong></h2> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#111111;">缓存雪崩：由于原有的缓存过期失效，新的缓存还没有缓存进来，有一只请求缓存请求不到，导致所有请求都跑去了数据库，导致数据库</span><span style="color:#111111;">IO</span><span style="color:#111111;">、内存和</span><span style="color:#111111;">CPU</span><span style="color:#111111;">眼里过大，甚至导致宕机，使得整个系统崩溃。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#111111;">解决思路：</span><br><span style="color:#111111;">1</span><span style="color:#111111;">，采用加锁计数，或者使用合理的队列数量来避免缓存失效时对数据库造成太大的压力。这种办法虽然能缓解数据库的压力，但是同时又降低了系统的吞吐量。</span><br><span style="color:#111111;">2</span><span style="color:#111111;">，分析用户行为，尽量让失效时间点均匀分布。避免缓存雪崩的出现。</span><br><span style="color:#111111;">3</span><span style="color:#111111;">，如果是因为某台缓存服务器宕机，可以考虑做主备，比如：</span><span style="color:#111111;">redis</span><span style="color:#111111;">主备，但是双缓存涉及到更新事务的问题，</span><span style="color:#111111;">update</span><span style="color:#111111;">可能读到脏数据，需要好好解决。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#111111;">加锁：加锁排队只是为了减轻数据库的压力，并没有提高系统吞吐量。假设在高并发下，缓存重建期间</span><span style="color:#111111;">key</span><span style="color:#111111;">是锁着的，这是过来</span><span style="color:#111111;">1000</span><span style="color:#111111;">个请求</span><span style="color:#111111;">999</span><span style="color:#111111;">个都在阻塞的。同样会导致用户等待超时，这是个治标不治本的方法。</span></p> 
 <table border="1" cellspacing="0"><tbody><tr><td style="border-color:#C0C0C0;width:19.25pt;"> <p style="margin-left:0cm;">1</p> <p style="margin-left:0cm;">2</p> <p style="margin-left:0cm;">3</p> <p style="margin-left:0cm;">4</p> <p style="margin-left:0cm;">5</p> <p style="margin-left:0cm;">6</p> <p style="margin-left:0cm;">7</p> <p style="margin-left:0cm;">8</p> <p style="margin-left:0cm;">9</p> <p style="margin-left:0cm;">10</p> <p style="margin-left:0cm;">11</p> <p style="margin-left:0cm;">12</p> <p style="margin-left:0cm;">13</p> <p style="margin-left:0cm;">14</p> <p style="margin-left:0cm;">15</p> <p style="margin-left:0cm;">16</p> <p style="margin-left:0cm;">17</p> <p style="margin-left:0cm;">18</p> <p style="margin-left:0cm;">19</p> <p style="margin-left:0cm;">20</p> <p style="margin-left:0cm;">21</p> <p style="margin-left:0cm;">22</p> <p style="margin-left:0cm;">23</p> <p style="margin-left:0cm;">24</p> <p style="margin-left:0cm;">25</p> <p style="margin-left:0cm;">26</p> <p style="margin-left:0cm;">27</p> <p style="margin-left:0cm;">28</p> <p style="margin-left:0cm;">29</p> <p style="margin-left:0cm;">30</p> <p style="margin-left:0cm;">31</p> </td><td style="border-color:#C0C0C0;"> <p style="margin-left:0cm;"><code>public</code> <code>class</code> <code>CacheDemo</code></p> <p style="margin-left:0cm;"><code>{<!-- --></code></p> <p style="margin-left:0cm;"><code>    public</code> <code>object</code> <code>GetCacheDataList()</code></p> <p style="margin-left:0cm;"><code>        {<!-- --></code></p> <p style="margin-left:0cm;"><code>            const</code> <code>int</code> <code>cacheTime = 60;   </code></p> <p style="margin-left:0cm;"><code>            const</code> <code>string</code> <code>lockKey = cacheKey;</code></p> <p style="margin-left:0cm;"><code>            const</code> <code>string</code> <code>cacheKey = "datainfolist";      </code></p> <p style="margin-left:0cm;"><code>            var</code> <code>cacheValue = CacheHelper.Get(cacheKey);</code></p> <p style="margin-left:0cm;"><code>            if</code> <code>(cacheValue != null)</code></p> <p style="margin-left:0cm;"><code>            {<!-- --></code></p> <p style="margin-left:0cm;"><code>                return</code> <code>cacheValue;</code></p> <p style="margin-left:0cm;"><code>            }</code></p> <p style="margin-left:0cm;"><code>            else</code></p> <p style="margin-left:0cm;"><code>            {<!-- --></code></p> <p style="margin-left:0cm;"><code>                lock</code> <code>(lockKey)</code></p> <p style="margin-left:0cm;"><code>                {<!-- --></code></p> <p style="margin-left:0cm;"><code>                    cacheValue = CacheHelper.Get(cacheKey);</code></p> <p style="margin-left:0cm;"><code>                    if</code> <code>(cacheValue != null)</code></p> <p style="margin-left:0cm;"><code>                    {<!-- --></code></p> <p style="margin-left:0cm;"><code>                        return</code> <code>cacheValue;</code></p> <p style="margin-left:0cm;"><code>                    }</code></p> <p style="margin-left:0cm;"><code>                    else</code></p> <p style="margin-left:0cm;"><code>                    {<!-- --></code></p> <p style="margin-left:0cm;"><code>                        cacheValue = GetDataBaseInfo();              </code></p> <p style="margin-left:0cm;"><code>                        CacheHelper.Add(cacheKey, cacheValue, cacheTime);</code></p> <p style="margin-left:0cm;"><code>                    }                   </code></p> <p style="margin-left:0cm;"><code>                }</code></p> <p style="margin-left:0cm;"><code>                return</code> <code>cacheValue;</code></p> <p style="margin-left:0cm;"><code>            }</code></p> <p style="margin-left:0cm;"><code>        }</code></p> <p style="margin-left:0cm;"><code>}</code></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"><span style="color:#111111;">　　标记失效缓存：</span></p> 
 <p style="margin-left:0cm;"><span style="color:#111111;">缓存标记：记录缓存数据是否过期，如果过期会触发通知另外的线程在后台去更新实际</span><span style="color:#111111;">key</span><span style="color:#111111;">的缓存。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#111111;">　　缓存数据：它的过期时间比缓存标记的时间延长</span><span style="color:#111111;">1</span><span style="color:#111111;">倍，例：标记缓存时间</span><span style="color:#111111;">30</span><span style="color:#111111;">分钟，数据缓存设置为</span><span style="color:#111111;">60</span><span style="color:#111111;">分钟。</span> <span style="color:#111111;">这样，当缓存标记</span><span style="color:#111111;">key</span><span style="color:#111111;">过期后，实际缓存还能把旧数据返回给调用端，直到另外的线程在后台更新完成后，才会返回新缓存。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#111111;">　　这样做后，就可以一定程度上提高系统吞吐量。</span></p> 
 <table border="1" cellspacing="0"><tbody><tr><td style="border-color:#C0C0C0;width:15.6pt;"> <p style="margin-left:0cm;">1</p> <p style="margin-left:0cm;">2</p> <p style="margin-left:0cm;">3</p> <p style="margin-left:0cm;">4</p> <p style="margin-left:0cm;">5</p> <p style="margin-left:0cm;">6</p> <p style="margin-left:0cm;">7</p> <p style="margin-left:0cm;">8</p> <p style="margin-left:0cm;">9</p> <p style="margin-left:0cm;">10</p> <p style="margin-left:0cm;">11</p> <p style="margin-left:0cm;">12</p> <p style="margin-left:0cm;">13</p> <p style="margin-left:0cm;">14</p> <p style="margin-left:0cm;">15</p> <p style="margin-left:0cm;">16</p> <p style="margin-left:0cm;">17</p> <p style="margin-left:0cm;">18</p> <p style="margin-left:0cm;">19</p> <p style="margin-left:0cm;">20</p> <p style="margin-left:0cm;">21</p> <p style="margin-left:0cm;">22</p> <p style="margin-left:0cm;">23</p> <p style="margin-left:0cm;">24</p> <p style="margin-left:0cm;">25</p> <p style="margin-left:0cm;">26</p> </td><td style="border-color:#C0C0C0;"> <p style="margin-left:0cm;"><code>public</code> <code>object</code> <code>GetProductListNew()</code></p> <p style="margin-left:0cm;"><code>        {<!-- --></code></p> <p style="margin-left:0cm;"><code>            const</code> <code>int</code> <code>cacheTime = 30;</code></p> <p style="margin-left:0cm;"><code>            const</code> <code>string</code> <code>cacheKey = "product_list";</code></p> <p style="margin-left:0cm;"><code>            //</code><code>缓存标记。</code></p> <p style="margin-left:0cm;"><code>            const</code> <code>string</code> <code>cacheSign = cacheKey + "_sign";</code></p> <p style="margin-left:0cm;"><code>            </code> </p> <p style="margin-left:0cm;"><code>            var</code> <code>sign = CacheHelper.Get(cacheSign);</code></p> <p style="margin-left:0cm;"><code>            //</code><code>获取缓存值</code></p> <p style="margin-left:0cm;"><code>            var</code> <code>cacheValue = CacheHelper.Get(cacheKey);</code></p> <p style="margin-left:0cm;"><code>            if</code> <code>(sign != null)</code></p> <p style="margin-left:0cm;"><code>            {<!-- --></code></p> <p style="margin-left:0cm;"><code>                return</code> <code>cacheValue; //</code><code>未过期，直接返回。</code></p> <p style="margin-left:0cm;"><code>            }</code></p> <p style="margin-left:0cm;"><code>            else</code></p> <p style="margin-left:0cm;"><code>            {<!-- --></code></p> <p style="margin-left:0cm;"><code>                CacheHelper.Add(cacheSign, "1", cacheTime);</code></p> <p style="margin-left:0cm;"><code>                ThreadPool.QueueUserWorkItem((arg) =&gt;</code></p> <p style="margin-left:0cm;"><code>                {<!-- --></code></p> <p style="margin-left:0cm;"><code>                    cacheValue = GetProductListFromDB(); //</code><code>这里一般是 sql查询数据。</code></p> <p style="margin-left:0cm;"><code>                    CacheHelper.Add(cacheKey, cacheValue, cacheTime*2); //</code><code>日期设缓存时间的2倍，用于脏读。               </code></p> <p style="margin-left:0cm;"><code>                });</code></p> <p style="margin-left:0cm;"><code>                </code> </p> <p style="margin-left:0cm;"><code>                return</code> <code>cacheValue;</code></p> <p style="margin-left:0cm;"><code>            }</code></p> <p style="margin-left:0cm;"><code>        }</code></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"><span style="color:#111111;">　　<strong>缓存穿透：</strong></span></p> 
 <p style="margin-left:0cm;"><span style="color:#111111;">缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库再查询一遍，然后返回空。这样请求就绕过缓存直接查数据库，这也是经常提的缓存命中率问题。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#111111;">　　解决的办法就是：如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#111111;">缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到，每次都要去数据库中查询。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#111111;">解决思路：</span></p> 
 <p style="margin-left:0cm;"><span style="color:#111111;">1</span><span style="color:#111111;">，如果查询数据库也为空，直接设置一个默认值存放到缓存，这样第二次到缓冲中获取就有值了，而不会继续访问数据库，这种办法最简单粗暴。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#111111;">2</span><span style="color:#111111;">，根据缓存数据</span><span style="color:#111111;">Key</span><span style="color:#111111;">的规则。例如我们公司是做机顶盒的，缓存数据以</span><span style="color:#111111;">Mac</span><span style="color:#111111;">为</span><span style="color:#111111;">Key</span><span style="color:#111111;">，</span><span style="color:#111111;">Mac</span><span style="color:#111111;">是有规则，如果不符合规则就过滤掉，这样可以过滤一部分查询。在做缓存规划的时候，</span><span style="color:#111111;">Key</span><span style="color:#111111;">有一定规则的话，可以采取这种办法。这种办法只能缓解一部分的压力，过滤和系统无关的查询，但是无法根治。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#111111;">3</span><span style="color:#111111;">，采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的</span><span style="color:#111111;">BitSet</span><span style="color:#111111;">中，不存在的数据将会被拦截掉，从而避免了对底层存储系统的查询压力。关于布隆过滤器，详情查看：基于</span><span style="color:#111111;">BitSet</span><span style="color:#111111;">的布隆过滤器</span><span style="color:#111111;">(Bloom Filter) </span></p> 
 <p style="margin-left:0cm;"><span style="color:#111111;">大并发的缓存穿透会导致缓存雪崩。</span></p> 
 <table border="1" cellspacing="0"><tbody><tr><td style="border-color:#C0C0C0;width:15.6pt;"> <p style="margin-left:0cm;">1</p> <p style="margin-left:0cm;">2</p> <p style="margin-left:0cm;">3</p> <p style="margin-left:0cm;">4</p> <p style="margin-left:0cm;">5</p> <p style="margin-left:0cm;">6</p> <p style="margin-left:0cm;">7</p> <p style="margin-left:0cm;">8</p> <p style="margin-left:0cm;">9</p> <p style="margin-left:0cm;">10</p> <p style="margin-left:0cm;">11</p> <p style="margin-left:0cm;">12</p> <p style="margin-left:0cm;">13</p> <p style="margin-left:0cm;">14</p> <p style="margin-left:0cm;">15</p> <p style="margin-left:0cm;">16</p> <p style="margin-left:0cm;">17</p> <p style="margin-left:0cm;">18</p> <p style="margin-left:0cm;">19</p> <p style="margin-left:0cm;">20</p> <p style="margin-left:0cm;">21</p> <p style="margin-left:0cm;">22</p> <p style="margin-left:0cm;">23</p> <p style="margin-left:0cm;">24</p> <p style="margin-left:0cm;">25</p> <p style="margin-left:0cm;">26</p> <p style="margin-left:0cm;">27</p> </td><td style="border-color:#C0C0C0;"> <p style="margin-left:0cm;"><code>public</code> <code>object</code> <code>GetProductListNew()</code></p> <p style="margin-left:0cm;"><code>        {<!-- --></code></p> <p style="margin-left:0cm;"><code>            const</code> <code>int</code> <code>cacheTime = 30;</code></p> <p style="margin-left:0cm;"><code>            const</code> <code>string</code> <code>cacheKey = "product_list";</code></p> <p style="margin-left:0cm;"> </p> <p style="margin-left:0cm;"><code>            var</code> <code>cacheValue = CacheHelper.Get(cacheKey);</code></p> <p style="margin-left:0cm;"><code>            if</code> <code>(cacheValue != null)</code></p> <p style="margin-left:0cm;"><code>                return</code> <code>cacheValue;</code></p> <p style="margin-left:0cm;"><code>                </code> </p> <p style="margin-left:0cm;"><code>            cacheValue = CacheHelper.Get(cacheKey);</code></p> <p style="margin-left:0cm;"><code>            if</code> <code>(cacheValue != null)</code></p> <p style="margin-left:0cm;"><code>            {<!-- --></code></p> <p style="margin-left:0cm;"><code>                return</code> <code>cacheValue;</code></p> <p style="margin-left:0cm;"><code>            }</code></p> <p style="margin-left:0cm;"><code>            else</code></p> <p style="margin-left:0cm;"><code>            {<!-- --></code></p> <p style="margin-left:0cm;"><code>                cacheValue = GetProductListFromDB(); //</code><code>数据库查询不到，为空。</code></p> <p style="margin-left:0cm;"><code>                </code> </p> <p style="margin-left:0cm;"><code>                if</code> <code>(cacheValue == null)</code></p> <p style="margin-left:0cm;"><code>                {<!-- --></code></p> <p style="margin-left:0cm;"><code>                    cacheValue = string.Empty; //</code><code>如果发现为空，设置个默认值，也缓存起来。               </code></p> <p style="margin-left:0cm;"><code>                }</code></p> <p style="margin-left:0cm;"><code>                CacheHelper.Add(cacheKey, cacheValue, cacheTime);</code></p> <p style="margin-left:0cm;"><code>                </code> </p> <p style="margin-left:0cm;"><code>                return</code> <code>cacheValue;</code></p> <p style="margin-left:0cm;"><code>            }</code></p> <p style="margin-left:0cm;"><code>        }</code></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"><span style="color:#111111;">　　把空结果，也给缓存起来，这样下次同样的请求就可以直接返回空了，即可以避免当查询的值为空时引起的缓存穿透。同时也可以单独设置个缓存区域存储空值，对要查询的</span><span style="color:#111111;">key</span><span style="color:#111111;">进行预先校验，然后再放行给后面的正常缓存处理逻辑。</span></p> 
 <p style="margin-left:0cm;"><strong><span style="color:#111111;">缓存预热</span></strong></p> 
 <p style="margin-left:0cm;"><span style="color:#111111;">　　缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。这样避免，用户请求的时候，再去加载相关的数据。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#111111;">　　解决思路：</span></p> 
 <p style="margin-left:0cm;">　　　　<span style="color:#111111;">1</span><span style="color:#111111;">，直接写个缓存刷新页面，上线时手工操作下。</span></p> 
 <p style="margin-left:0cm;">　　　　<span style="color:#111111;">2</span><span style="color:#111111;">，数据量不大，可以在</span><span style="color:#111111;">WEB</span><span style="color:#111111;">系统启动的时候加载。</span></p> 
 <p style="margin-left:0cm;">　　　　<span style="color:#111111;">3</span><span style="color:#111111;">，定时刷新缓存，</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <h4 style="margin-left:0cm;"><strong><strong><span style="color:#000000;">缓存更新</span></strong></strong></h4> 
 <p style="margin-left:0cm;"><span style="color:#111111;">　　缓存淘汰的策略有两种：</span></p> 
 <p style="margin-left:0cm;">　　　　<span style="color:#111111;">(1) </span><span style="color:#111111;">定时去清理过期的缓存。</span></p> 
 <p style="margin-left:0cm;">　　　　<span style="color:#111111;">(2)</span><span style="color:#111111;">当有用户请求过来时，再判断这个请求所用到的缓存是否过期，过期的话就去底层系统得到新数据并更新缓存。</span> </p> 
 <p style="margin-left:0cm;"><span style="color:#111111;">　　两者各有优劣，第一种的缺点是维护大量缓存的</span><span style="color:#111111;">key</span><span style="color:#111111;">是比较麻烦的，第二种的缺点就是每次用户请求过来都要判断缓存失效，逻辑相对比较复杂，具体用哪种方案，大家可以根据自己的应用场景来权衡。</span><span style="color:#111111;">1. </span><span style="color:#111111;">预估失效时间</span><span style="color:#111111;"> 2. </span><span style="color:#111111;">版本号（必须单调递增，时间戳是最好的选择）</span><span style="color:#111111;">3. </span><span style="color:#111111;">提供手动清理缓存的接口。</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>72  jst</strong></h2> 
 <h3 style="margin-left:0cm;"><strong><span style="color:#000000;">理解</span><span style="color:#000000;">JWT</span><span style="color:#000000;">的使用场景和优劣</span></strong></h3> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#3388ff;">淘楼小能手</span></p> 
 <p style="margin-left:0cm;"><span style="color:#999999;">百家号</span><span style="color:#999999;">04-28</span><span style="color:#999999;">16:20</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">经过前面两篇文章《</span><span style="color:#333333;">JSON Web Token - </span><span style="color:#333333;">在</span><span style="color:#333333;">Web</span><span style="color:#333333;">应用间安全地传递信息》《八幅漫画理解使用</span><span style="color:#333333;">JSON Web Token</span><span style="color:#333333;">设计单点登录系统》的科普，相信大家应该已经知道了</span><span style="color:#333333;"> JWT </span><span style="color:#333333;">协议是什么了。至少看到</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">1</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJxaWFubWlJZCI6InFtMTAzNTNzaEQiLCJpc3MiOiJhcHBfcW0xMDM1M3NoRCIsInBsYXRmb3JtIjoiYXBwIn0.cMNwyDTFVYMLL4e7ts50GFHTvlSJLDpePtHXzu7z9j4</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">这样形如</span><span style="color:#333333;"> A.B.C </span><span style="color:#333333;">的字符串时能敏感地认出这是使用了</span><span style="color:#333333;"> jwt</span><span style="color:#333333;">。发了这两篇文章后，有不少读者在文末留言，表达了对</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">使用方式的一些疑惑，以及到底哪些场景适合使用</span><span style="color:#333333;"> jwt</span><span style="color:#333333;">。我并不是</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">方面的专家，和不少读者一样，起初研究时我也存在相同疑惑，甚至在逐渐接触后产生了更大的疑惑，经过这段时间项目中的使用和一些自己思考，把个人的总结整理成此文。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">编码，签名，加密</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">这些基础知识简单地介绍下，千万别搞混了三个概念。在</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">中恰好同时涉及了这三个概念，笔者用大白话来做下通俗的讲解（非严谨定义，供个人理解）</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">编码</span><span style="color:#333333;">(encode)</span><span style="color:#333333;">和解码</span><span style="color:#333333;">(decode)</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">一般是编码解码是为了方便以字节的方式表示数据，便于存储和网络传输。整个</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">串会被置于</span><span style="color:#333333;"> http </span><span style="color:#333333;">的</span><span style="color:#333333;"> Header </span><span style="color:#333333;">或者</span><span style="color:#333333;"> url </span><span style="color:#333333;">中，为了不出现乱码解析错误等意外，编码是有必要的。在</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">中以</span><span style="color:#333333;">.</span><span style="color:#333333;">分割的三个部分都经过</span><span style="color:#333333;"> base64 </span><span style="color:#333333;">编码</span><span style="color:#333333;">(secret </span><span style="color:#333333;">部分是否进行</span><span style="color:#333333;"> base64 </span><span style="color:#333333;">编码是可选的，</span><span style="color:#333333;">header </span><span style="color:#333333;">和</span><span style="color:#333333;"> payload </span><span style="color:#333333;">则是必须进行</span><span style="color:#333333;"> base64 </span><span style="color:#333333;">编码</span><span style="color:#333333;">)</span><span style="color:#333333;">。注意，编码的一个特点：编码和解码的整个过程是可逆的。得知编码方式后，整个</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">串便是明文了，随意找个网站验证下解码后的内容：</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">base64</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">所以注意一点，</span><span style="color:#333333;">payload </span><span style="color:#333333;">是一定不能够携带敏感数据如密码等信息的。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">签名</span><span style="color:#333333;">(signature)</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">签名的目的主要是为了验证我是</span><span style="color:#333333;">“</span><span style="color:#333333;">我</span><span style="color:#333333;">”</span><span style="color:#333333;">。</span><span style="color:#333333;">jwt </span><span style="color:#333333;">中常用的签名算法是</span><span style="color:#333333;"> HS256</span><span style="color:#333333;">，可能大多数人对这个签名算法不熟悉，但</span><span style="color:#333333;"> md5,sha </span><span style="color:#333333;">这样的签名算法肯定是为人熟知的，签名算法共同的特点是整个过程是不可逆的。由于签名之前的主体内容</span><span style="color:#333333;">(header,payload)</span><span style="color:#333333;">会携带在</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">字符串中，所以需要使用带有密钥</span><span style="color:#333333;">(yuè)</span><span style="color:#333333;">的签名算法，密钥是服务器和签发者共享的。</span><span style="color:#333333;">header </span><span style="color:#333333;">部分和</span><span style="color:#333333;"> payload </span><span style="color:#333333;">部分如果被篡改，由于篡改者不知道密钥是什么，也无法生成新的</span><span style="color:#333333;"> signature </span><span style="color:#333333;">部分，服务端也就无法通过，在</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">中，消息体是透明的，使用签名可以保证消息不被篡改。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">前面转载的文章中，原作者将</span><span style="color:#333333;"> HS256 </span><span style="color:#333333;">称之为加密算法，不太严谨。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">加密</span><span style="color:#333333;">(encryption)</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">加密是将明文信息改变为难以读取的密文内容，使之不可读。只有拥有解密方法的对象，经由解密过程，才能将密文还原为正常可读的内容。加密算法通常按照加密方式的不同分为对称加密</span><span style="color:#333333;">(</span><span style="color:#333333;">如</span><span style="color:#333333;"> AES)</span><span style="color:#333333;">和非对称加密</span><span style="color:#333333;">(</span><span style="color:#333333;">如</span><span style="color:#333333;"> RSA)</span><span style="color:#333333;">。你可能会疑惑：</span><span style="color:#333333;">“jwt </span><span style="color:#333333;">中哪儿涉及加密算法了？</span><span style="color:#333333;">”</span><span style="color:#333333;">，其实</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">的</span> <span style="color:#333333;">第一部分</span><span style="color:#333333;">(header) </span><span style="color:#333333;">中的</span><span style="color:#333333;"> alg </span><span style="color:#333333;">参数便可以指定不同的算法来生成第三部分</span><span style="color:#333333;">(signature)</span><span style="color:#333333;">，大部分支持</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">的框架至少都内置</span><span style="color:#333333;"> rsa </span><span style="color:#333333;">这种非对称加密方式。这里诞生了第一个疑问</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">疑问：一提到</span><span style="color:#333333;"> rsa</span><span style="color:#333333;">，大多数人第一想到的是非对称加密算法，而</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">的第三部分明确的英文定义是</span><span style="color:#333333;"> signature</span><span style="color:#333333;">，这不是矛盾吗？</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">划重点！</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">rsa </span><span style="color:#333333;">加密和</span><span style="color:#333333;">rsa </span><span style="color:#333333;">签名是两个概念！</span><span style="color:#333333;">(</span><span style="color:#333333;">吓得我都换行了</span><span style="color:#333333;">)</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">这两个用法很好理解：</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">既然是加密，自然是不希望别人知道我的消息，只有我自己才能解密，所以公钥负责加密，私钥负责解密。这是大多数的使用场景，使用</span><span style="color:#333333;"> rsa </span><span style="color:#333333;">来加密。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">既然是签名，自然是希望别人不能冒充我发消息，只有我才能发布签名，所以私钥负责签名，公钥负责验证。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">所以，在客户端使用</span><span style="color:#333333;"> rsa </span><span style="color:#333333;">算法生成</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">串时，是使用私钥来</span><span style="color:#333333;">“</span><span style="color:#333333;">加密</span><span style="color:#333333;">”</span><span style="color:#333333;">的，而公钥是公开的，谁都可以解密，内容也无法变更（篡改者无法得知私钥）。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">所以，在</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">中并没有纯粹的加密过程，而是使加密之虚，行签名之实。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">什么场景该适合使用</span><span style="color:#333333;">jwt</span><span style="color:#333333;">？</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">来聊聊几个场景，注意，以下的几个场景不是都和</span><span style="color:#333333;">jwt</span><span style="color:#333333;">贴合。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">一次性验证</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">比如用户注册后需要发一封邮件让其激活账户，通常邮件中需要有一个链接，这个链接需要具备以下的特性：能够标识用户，该链接具有时效性（通常只允许几小时之内激活），不能被篡改以激活其他可能的账户</span><span style="color:#333333;">…</span><span style="color:#333333;">这种场景就和</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">的特性非常贴近，</span><span style="color:#333333;">jwt </span><span style="color:#333333;">的</span><span style="color:#333333;"> payload </span><span style="color:#333333;">中固定的参数：</span><span style="color:#333333;">iss </span><span style="color:#333333;">签发者和</span><span style="color:#333333;"> exp </span><span style="color:#333333;">过期时间正是为其做准备的。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">restful api</span><span style="color:#333333;">的无状态认证</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">使用</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">来做</span><span style="color:#333333;"> restful api </span><span style="color:#333333;">的身份认证也是值得推崇的一种使用方案。客户端和服务端共享</span><span style="color:#333333;"> secret</span><span style="color:#333333;">；过期时间由服务端校验，客户端定时刷新；签名信息不可被修改</span><span style="color:#333333;">…spring security oauth jwt </span><span style="color:#333333;">提供了一套完整的</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">认证体系，以笔者的经验来看：使用</span><span style="color:#333333;"> oauth2 </span><span style="color:#333333;">或</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">来做</span><span style="color:#333333;"> restful api </span><span style="color:#333333;">的认证都没有大问题，</span><span style="color:#333333;">oauth2 </span><span style="color:#333333;">功能更多，支持的场景更丰富，后者实现简单。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">使用</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">做单点登录</span><span style="color:#333333;">+</span><span style="color:#333333;">会话管理</span><span style="color:#333333;">(</span><span style="color:#333333;">不推荐</span><span style="color:#333333;">)</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">在《八幅漫画理解使用</span><span style="color:#333333;">JSON Web Token</span><span style="color:#333333;">设计单点登录系统》一文中提及了使用</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">来完成单点登录，本文接下来的内容主要就是围绕这一点来进行讨论。如果你正在考虑使用</span><span style="color:#333333;"> jwt+cookie </span><span style="color:#333333;">代替</span><span style="color:#333333;"> session+cookie </span><span style="color:#333333;">，我强力不推荐你这么做。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">首先明确一点：使用</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">来设计单点登录系统是一个不太严谨的说法。首先</span><span style="color:#333333;"> cookie+jwt </span><span style="color:#333333;">的方案前提是非跨域的单点登录</span><span style="color:#333333;">(cookie </span><span style="color:#333333;">无法被自动携带至其他域名</span><span style="color:#333333;">)</span><span style="color:#333333;">，其次单点登录系统包含了很多技术细节，至少包含了身份认证和会话管理，这还不涉及到权限管理。如果觉得比较抽象，不妨用传统的</span><span style="color:#333333;"> session+cookie </span><span style="color:#333333;">单点登录方案来做类比，通常我们可以选择</span><span style="color:#333333;"> spring security</span><span style="color:#333333;">（身份认证和权限管理的安全框架）和</span><span style="color:#333333;"> spring session</span><span style="color:#333333;">（</span><span style="color:#333333;">session </span><span style="color:#333333;">共享）来构建，而选择用</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">设计单点登录系统需要解决很多传统方案中同样存在和本不存在的问题，以下一一详细罗列。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">jwt token</span><span style="color:#333333;">泄露了怎么办？</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">前面的文章下有不少人留言提到这个问题，我则认为这不是问题。传统的</span><span style="color:#333333;"> session+cookie </span><span style="color:#333333;">方案，如果泄露了</span><span style="color:#333333;"> sessionId</span><span style="color:#333333;">，别人同样可以盗用你的身份。扬汤止沸不如釜底抽薪，不妨来追根溯源一下，什么场景会导致你的</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">泄露。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">遵循如下的实践可以尽可能保护你的</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">不被泄露：使用</span><span style="color:#333333;"> https </span><span style="color:#333333;">加密你的应用，返回</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">给客户端时设置</span><span style="color:#333333;"> httpOnly=true </span><span style="color:#333333;">并且使用</span><span style="color:#333333;"> cookie </span><span style="color:#333333;">而不是</span><span style="color:#333333;"> LocalStorage </span><span style="color:#333333;">存储</span><span style="color:#333333;"> jwt</span><span style="color:#333333;">，这样可以防止</span><span style="color:#333333;"> XSS </span><span style="color:#333333;">攻击和</span><span style="color:#333333;"> CSRF </span><span style="color:#333333;">攻击（对这两种攻击感兴趣的童鞋可以看下</span><span style="color:#333333;"> spring security </span><span style="color:#333333;">中对他们的介绍</span><span style="color:#333333;">CSRF,XSS</span><span style="color:#333333;">）</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">你要是正在使用</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">访问一个接口，这个时候你的同事跑过来把你的</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">抄走了，这种泄露，恕在下无力</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">secret</span><span style="color:#333333;">如何设计</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">jwt </span><span style="color:#333333;">唯一存储在服务端的只有一个</span><span style="color:#333333;"> secret</span><span style="color:#333333;">，个人认为这个</span><span style="color:#333333;"> secret </span><span style="color:#333333;">应该设计成和用户相关的，而不是一个所有用户公用的统一值。这样可以有效的避免一些注销和修改密码时遇到的窘境。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">注销和修改密码</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">传统的</span><span style="color:#333333;"> session+cookie </span><span style="color:#333333;">方案用户点击注销，服务端清空</span><span style="color:#333333;"> session </span><span style="color:#333333;">即可，因为状态保存在服务端。但</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">的方案就比较难办了，因为</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">是无状态的，服务端通过计算来校验有效性。没有存储起来，所以即使客户端删除了</span><span style="color:#333333;"> jwt</span><span style="color:#333333;">，但是该</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">还是在有效期内，只不过处于一个游离状态。分析下痛点：注销变得复杂的原因在于</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">的无状态。我提供几个方案，视具体的业务来决定能不能接受。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">仅仅清空客户端的</span><span style="color:#333333;"> cookie</span><span style="color:#333333;">，这样用户访问时就不会携带</span><span style="color:#333333;"> jwt</span><span style="color:#333333;">，服务端就认为用户需要重新登录。这是一个典型的假注销，对于用户表现出退出的行为，实际上这个时候携带对应的</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">依旧可以访问系统。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">清空或修改服务端的用户对应的</span><span style="color:#333333;"> secret</span><span style="color:#333333;">，这样在用户注销后，</span><span style="color:#333333;">jwt </span><span style="color:#333333;">本身不变，但是由于</span><span style="color:#333333;"> secret </span><span style="color:#333333;">不存在或改变，则无法完成校验。这也是为什么将</span><span style="color:#333333;"> secret </span><span style="color:#333333;">设计成和用户相关的原因。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">借助第三方存储自己管理</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">的状态，可以以</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">为</span><span style="color:#333333;"> key</span><span style="color:#333333;">，实现去</span><span style="color:#333333;"> redis </span><span style="color:#333333;">一类的缓存中间件中去校验存在性。方案设计并不难，但是引入</span><span style="color:#333333;"> redis </span><span style="color:#333333;">之后，就把无状态的</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">硬生生变成了有状态了，违背了</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">的初衷。实际上这个方案和</span><span style="color:#333333;"> session </span><span style="color:#333333;">都差不多了。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">修改密码则略微有些不同，假设号被到了，修改密码（是用户密码，不是</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">的</span><span style="color:#333333;"> secret</span><span style="color:#333333;">）之后，盗号者在原</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">有效期之内依旧可以继续访问系统，所以仅仅清空</span><span style="color:#333333;"> cookie </span><span style="color:#333333;">自然是不够的，这时，需要强制性的修改</span><span style="color:#333333;"> secret</span><span style="color:#333333;">。在我的实践中就是这样做的。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">续签问题</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">续签问题可以说是我抵制使用</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">来代替传统</span><span style="color:#333333;"> session </span><span style="color:#333333;">的最大原因，因为</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">的设计中我就没有发现它将续签认为是自身的一个特性。传统的</span><span style="color:#333333;"> cookie </span><span style="color:#333333;">续签方案一般都是框架自带的，</span><span style="color:#333333;">session </span><span style="color:#333333;">有效期</span><span style="color:#333333;"> 30 </span><span style="color:#333333;">分钟，</span><span style="color:#333333;">30 </span><span style="color:#333333;">分钟内如果有访问，</span><span style="color:#333333;">session </span><span style="color:#333333;">有效期被刷新至</span><span style="color:#333333;"> 30 </span><span style="color:#333333;">分钟。而</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">本身的</span><span style="color:#333333;"> payload </span><span style="color:#333333;">之中也有一个</span><span style="color:#333333;"> exp </span><span style="color:#333333;">过期时间参数，来代表一个</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">的时效性，而</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">想延期这个</span><span style="color:#333333;"> exp </span><span style="color:#333333;">就有点身不由己了，因为</span><span style="color:#333333;"> payload </span><span style="color:#333333;">是参与签名的，一旦过期时间被修改，整个</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">串就变了，</span><span style="color:#333333;">jwt </span><span style="color:#333333;">的特性天然不支持续签！</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">如果你一定要使用</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">做会话管理（</span><span style="color:#333333;">payload </span><span style="color:#333333;">中存储会话信息），也不是没有解决方案，但个人认为都不是很令人满意</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">每次请求刷新</span><span style="color:#333333;"> jwt</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">jwt </span><span style="color:#333333;">修改</span><span style="color:#333333;"> payload </span><span style="color:#333333;">中的</span><span style="color:#333333;"> exp </span><span style="color:#333333;">后整个</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">串就会发生改变，那</span><span style="color:#333333;">…</span><span style="color:#333333;">就让它变好了，每次请求都返回一个新的</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">给客户端。太暴力了，不用我赘述这样做是多么的不优雅，以及带来的性能问题。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">但，至少这是最简单的解决方案。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">只要快要过期的时候刷新</span><span style="color:#333333;"> jwt</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">一个上述方案的改造点是，只在最后的几分钟返回给客户端一个新的</span><span style="color:#333333;"> jwt</span><span style="color:#333333;">。这样做，触发刷新</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">基本就要看运气了，如果用户恰巧在最后几分钟访问了服务器，触发了刷新，万事大吉；如果用户连续操作了</span><span style="color:#333333;"> 27 </span><span style="color:#333333;">分钟，只有最后的</span><span style="color:#333333;"> 3 </span><span style="color:#333333;">分钟没有操作，导致未刷新</span><span style="color:#333333;"> jwt</span><span style="color:#333333;">，无疑会令用户抓狂。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">完善</span><span style="color:#333333;"> refreshToken</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">借鉴</span><span style="color:#333333;"> oauth2 </span><span style="color:#333333;">的设计，返回给客户端一个</span><span style="color:#333333;"> refreshToken</span><span style="color:#333333;">，允许客户端主动刷新</span><span style="color:#333333;"> jwt</span><span style="color:#333333;">。一般而言，</span><span style="color:#333333;">jwt </span><span style="color:#333333;">的过期时间可以设置为数小时，而</span><span style="color:#333333;"> refreshToken </span><span style="color:#333333;">的过期时间设置为数天。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">我认为该方案并可行性是存在的，但是为了解决</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">的续签把整个流程改变了，为什么不考虑下</span><span style="color:#333333;"> oauth2 </span><span style="color:#333333;">的</span><span style="color:#333333;"> password </span><span style="color:#333333;">模式和</span><span style="color:#333333;"> client </span><span style="color:#333333;">模式呢？</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">使用</span><span style="color:#333333;"> redis </span><span style="color:#333333;">记录独立的过期时间</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">实际上我的项目中由于历史遗留问题，就是使用</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">来做登录和会话管理的，为了解决续签问题，我们在</span><span style="color:#333333;"> redis </span><span style="color:#333333;">中单独会每个</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">设置了过期时间，每次访问时刷新</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">的过期时间，若</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">不存在与</span><span style="color:#333333;"> redis </span><span style="color:#333333;">中则认为过期。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">tips:</span><span style="color:#333333;">精确控制</span><span style="color:#333333;"> redis </span><span style="color:#333333;">的过期时间不是件容易的事，可以参考我最近的一篇借助于</span><span style="color:#333333;"> spring session </span><span style="color:#333333;">讲解</span><span style="color:#333333;"> redis </span><span style="color:#333333;">过期时间的排坑记录。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">同样改变了</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">的流程，不过嘛，世间安得两全法。我只能奉劝各位还未使用</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">做会话管理的朋友，尽量还是选用传统的</span><span style="color:#333333;"> session+cookie </span><span style="color:#333333;">方案，有很多成熟的分布式</span><span style="color:#333333;"> session </span><span style="color:#333333;">框架和安全框架供你开箱即用。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">jwt,oauth2,session</span><span style="color:#333333;">千丝万缕的联系</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">具体的对比不在此文介绍，就一位读者的留言回复下它的提问</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">这么长一个字符串，还不如我把数据存到数据库，给一个长的很难碰撞的</span><span style="color:#333333;">key</span><span style="color:#333333;">来映射，也就是专用</span><span style="color:#333333;">token</span><span style="color:#333333;">。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">这位兄弟认为</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">太长了，是不是可以考虑使用和</span><span style="color:#333333;"> oauth2 </span><span style="color:#333333;">一样的</span><span style="color:#333333;"> uuid </span><span style="color:#333333;">来映射。这里面自然是有问题的，</span><span style="color:#333333;">jwt </span><span style="color:#333333;">不仅仅是作为身份的认证（验证签名是否正确，签发者是否存在，有限期是否过期），还在其</span><span style="color:#333333;"> payload </span><span style="color:#333333;">中存储着会话信息，这是</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">和</span><span style="color:#333333;"> session </span><span style="color:#333333;">的最大区别，一个在客户端携带会话信息，一个在服务端存储会话信息。如果真的是要将</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">的信息置于在共享存储中，那再找不到任何使用</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">的意义了。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">jwt </span><span style="color:#333333;">和</span><span style="color:#333333;"> oauth2 </span><span style="color:#333333;">都可以用于</span><span style="color:#333333;"> restful </span><span style="color:#333333;">的认证，就我个人的使用经验来看，</span><span style="color:#333333;">spring security oauth2 </span><span style="color:#333333;">可以很好的使用多种认证模式：</span><span style="color:#333333;">client </span><span style="color:#333333;">模式，</span><span style="color:#333333;">password </span><span style="color:#333333;">模式，</span><span style="color:#333333;">implicit </span><span style="color:#333333;">模式（</span><span style="color:#333333;">authorization code </span><span style="color:#333333;">模式不算单纯的接口认证模式），也可以很方便的实现权限控制，什么样的</span><span style="color:#333333;"> api </span><span style="color:#333333;">需要什么样的权限，什么样的资源需要什么样的</span><span style="color:#333333;"> scope…</span><span style="color:#333333;">而</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">我只用它来实现过身份认证，功能较为单一（可能是我没发现更多用法）。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">总结</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">在</span><span style="color:#333333;"> web </span><span style="color:#333333;">应用中，使用</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">代替</span><span style="color:#333333;"> session </span><span style="color:#333333;">存在不小的风险，你至少得解决本文中提及的那些问题，绝大多数情况下，传统的</span><span style="color:#333333;"> cookie-session </span><span style="color:#333333;">机制工作得更好。</span><span style="color:#333333;">jwt </span><span style="color:#333333;">适合做简单的</span><span style="color:#333333;"> restful api </span><span style="color:#333333;">认证，颁发一个固定有效期的</span><span style="color:#333333;"> jwt</span><span style="color:#333333;">，降低</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">暴露的风险，不要对</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">做服务端的状态管理，这样才能体现出</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">无状态的优势。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">可能对</span><span style="color:#333333;"> jwt </span><span style="color:#333333;">的使用场景还有一些地方未被我察觉，后续会研究下</span><span style="color:#333333;"> spring security oauth jwt </span><span style="color:#333333;">的源码，不知到时会不会有新发现。</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>73 前后端  分离</strong></h2> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;">前端页面  和后台数据处理  分割开  </p> 
 <p style="margin-left:0cm;">好处</p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;">前端可以使用任意框架 最终使用Ajax和Json进行交互</p> 
 <p style="margin-left:0cm;">后端只需要注意实现 并且后期可以进行优化</p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>74 jQuery 和JavaScript  获取标签元素的区别</strong></h2> 
 <p style="margin-left:0cm;"><span style="color:#333333;">一个是</span><strong><span style="color:#333333;">DOM</span></strong><strong><span style="color:#333333;">对象</span></strong><span style="color:#333333;">一个是</span><strong><span style="color:#333333;">jQuery</span></strong><strong><span style="color:#333333;">对象</span></strong><span style="color:#333333;">。对于所有的浏览器，最最最底层都支持</span><span style="color:#333333;">javascript</span><span style="color:#333333;">，可能在某些浏览器支持一些对象和属性，一些浏览器不支持，所以才会出现了</span><span style="color:#333333;">jQuery</span><span style="color:#333333;">，解决了浏览器各个兼容的问题。</span><br><span style="color:#333333;">如果是</span><span style="color:#333333;">DOM</span><span style="color:#333333;">对象，可能可以使用浏览器底层的方法来使用，比如</span><span style="color:#333333;">document.getElementById('A').src='aaa.png';</span><br><span style="color:#333333;">如果是</span><span style="color:#333333;">jQuery</span><span style="color:#333333;">对象，就只能使用</span><span style="color:#333333;">jQuery</span><span style="color:#333333;">自己提供的方法和属性了；</span><br><span style="color:#333333;">所以问题来了，有使用需要使用</span><span style="color:#333333;">DOM</span><span style="color:#333333;">，有时候需要使用</span><span style="color:#333333;">jQuery</span><span style="color:#333333;">对象，两者可能会相互转换的。</span><br><span style="color:#333333;">使用</span><span style="color:#333333;">jQuery</span><span style="color:#333333;">选取的对象一般都是数组，你只要使用</span><span style="color:#333333;">[0]</span><span style="color:#333333;">选取第一个元素，就是</span><span style="color:#333333;">DOM</span><span style="color:#333333;">对象了，</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>75 SQL语句优化</strong></h2> 
 <h2 style="margin-left:0cm;"><strong>76开发中遇到内存溢出怎么办</strong></h2> 
 <p style="margin-left:0cm;"><span style="color:#333333;">引起内存溢出的<strong>原因</strong>有很多种，常见的有以下几种：</span><br> 　　<span style="color:#333333;">1.</span><span style="color:#333333;">内存中加载的数据量过于庞大，如一次从数据库取出过多数据；</span><br> 　　<span style="color:#333333;">2.</span><span style="color:#333333;">集合类中有对对象的引用，使用完后未清空，使得</span><span style="color:#333333;">JVM</span><span style="color:#333333;">不能回收；</span><br> 　　<span style="color:#333333;">3.</span><span style="color:#333333;">代码中存在死循环或循环产生过多重复的对象实体；</span><br> 　　<span style="color:#333333;">4.</span><span style="color:#333333;">使用的第三方软件中的</span><span style="color:#333333;">BUG</span><span style="color:#333333;">；</span><br> 　　<span style="color:#333333;">5.</span><span style="color:#333333;">启动参数内存值设定的过小；</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">内存溢出的<strong>解决方案</strong>：</span><br><span style="color:#333333;"><strong>      </strong></span><strong><span style="color:#333333;">第一步</span></strong><span style="color:#333333;">，修改</span><span style="color:#333333;">JVM</span><span style="color:#333333;">启动参数，直接增加内存。</span><span style="color:#333333;">(-Xms</span><span style="color:#333333;">，</span><span style="color:#333333;">-Xmx</span><span style="color:#333333;">参数一定不要忘记加。</span><span style="color:#333333;">)</span></p> 
 <p style="margin-left:0cm;"><strong><span style="color:#333333;">　　第二步</span></strong><span style="color:#333333;">，检查错误日志，查看</span><span style="color:#333333;">“OutOfMemory”</span><span style="color:#333333;">错误前是否有其它异常或错误。</span></p> 
 <p style="margin-left:0cm;"><strong><span style="color:#333333;">　　第三步</span></strong><span style="color:#333333;">，对代码进行走查和分析，找出可能发生内存溢出的位置。</span></p> 
 <h2 style="margin-left:0cm;"><strong>77String、StringBuffer、StringBuilder的区别</strong></h2> 
 <ol><li><span style="color:#000000;">可变与不可变</span></li></ol> 
 <p style="margin-left:0cm;"><span style="color:#000000;">String</span><span style="color:#000000;">类中使用字符数组保存字符串，因为String类是final类型的，所以String对象是不可变的</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">StringBuffer</span><span style="color:#000000;">和StringBuilder都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，这两种对象都是可变的</span></p> 
 <ol><li><span style="color:#000000;">线程安全性</span></li></ol> 
 <p style="margin-left:0cm;"><span style="color:#000000;">String</span><span style="color:#000000;">中的对象是不可变的，也就可以理解为常量，显然线程安全</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">StringBuffer</span><span style="color:#000000;">对方法加了同步锁或者调用的方法加了同步锁，所以是线程安全的</span></p> 
 <h2 style="margin-left:0cm;"><strong><span style="color:#000000;">StringBuilder</span><span style="color:#000000;">并没有对方法加同步锁，所以是非线程安全的</span></strong></h2> 
 <h2 style="margin-left:0cm;"><strong>78ArrayList和LinkedList的区别</strong></h2> 
 <ol><li><span style="color:#000000;">ArrayList</span><span style="color:#000000;">是基于数组开发的，查询效率很高，但是修改数据的效率会低一些</span></li><li>LinkedList是基于链表开发的，两端插入的时候效率很高，但是查询效率会低一些</li></ol> 
 <h2 style="margin-left:0cm;"><strong>79Java中如何遍历Map对象，至少写出两种方法</strong></h2> 
 <p style="margin-left:0cm;"><span style="color:#0000FF;">方式一</span> <span style="color:#0000FF;">这是最常见的并且在大多数情况下也是最可取的遍历方式。在键值都需要时使用。</span></p> 
 <table border="1" cellspacing="0" style="width:206px;"><tbody><tr><td style="border-color:#C0C0C0;vertical-align:top;width:26.25pt;"> <p style="margin-left:0cm;"><span style="color:#afafaf;">1</span></p> <p style="margin-left:0cm;"><span style="color:#afafaf;">2</span></p> <p style="margin-left:0cm;"><span style="color:#afafaf;">3</span></p> <p style="margin-left:0cm;"><span style="color:#afafaf;">4</span></p> </td><td style="border-color:#C0C0C0;vertical-align:top;width:128.3pt;"> <p style="margin-left:0cm;"><code><span style="color:#000000;">Map&lt;Integer, Integer&gt; map = </span></code><code><span style="color:#0000FF;">new</span></code> <code><span style="color:#000000;">HashMap&lt;Integer, Integer&gt;(); </span></code></p> <p style="margin-left:0cm;"><code><span style="color:#0000FF;">for</span></code> <code><span style="color:#000000;">(Map.Entry&lt;Integer, Integer&gt; entry : map.entrySet()) { </span></code></p> <p style="margin-left:0cm;"><code>  <span style="color:#000000;">System.out.println(</span><span style="color:#0000FF;">"Key = "</span></code> <code><span style="color:#000000;">+ entry.getKey() + </span></code><code><span style="color:#0000FF;">", Value = "</span></code> <code><span style="color:#000000;">+ entry.getValue()); </span></code></p> <p style="margin-left:0cm;"><code><span style="color:#000000;">}</span></code></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"><span style="color:#0000FF;">方法二</span> <span style="color:#0000FF;">在</span><span style="color:#0000FF;">for-each</span><span style="color:#0000FF;">循环中遍历</span><span style="color:#0000FF;">keys</span><span style="color:#0000FF;">或</span><span style="color:#0000FF;">values</span><span style="color:#0000FF;">。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">如果只需要</span><span style="color:#000000;">map</span><span style="color:#000000;">中的键或者值，你可以通过</span><span style="color:#000000;">keySet</span><span style="color:#000000;">或</span><span style="color:#000000;">values</span><span style="color:#000000;">来实现遍历，而不是用</span><span style="color:#000000;">entrySet</span><span style="color:#000000;">。</span></p> 
 <table border="1" cellspacing="0" style="width:219px;"><tbody><tr><td style="border-color:#C0C0C0;vertical-align:top;width:26.25pt;"> <p style="margin-left:0cm;"><span style="color:#afafaf;">1</span></p> <p style="margin-left:0cm;"><span style="color:#afafaf;">2</span></p> <p style="margin-left:0cm;"><span style="color:#afafaf;">3</span></p> <p style="margin-left:0cm;"><span style="color:#afafaf;">4</span></p> <p style="margin-left:0cm;"><span style="color:#afafaf;">5</span></p> <p style="margin-left:0cm;"><span style="color:#afafaf;">6</span></p> <p style="margin-left:0cm;"><span style="color:#afafaf;">7</span></p> <p style="margin-left:0cm;"><span style="color:#afafaf;">8</span></p> <p style="margin-left:0cm;"><span style="color:#afafaf;">9</span></p> </td><td style="border-color:#C0C0C0;vertical-align:top;width:138.2pt;"> <p style="margin-left:0cm;"><code><span style="color:#000000;">Map&lt;Integer, Integer&gt; map = </span></code><code><span style="color:#0000FF;">new</span></code> <code><span style="color:#000000;">HashMap&lt;Integer, Integer&gt;(); </span></code></p> <p style="margin-left:0cm;"><code><span style="color:#008200;">//</span></code><code><span style="color:#008200;">遍历map中的键 </span></code></p> <p style="margin-left:0cm;"><code><span style="color:#0000FF;">for</span></code> <code><span style="color:#000000;">(Integer key : map.keySet()) { </span></code></p> <p style="margin-left:0cm;"><code>  <span style="color:#000000;">System.out.println(</span><span style="color:#0000FF;">"Key = "</span></code> <code><span style="color:#000000;">+ key); </span></code></p> <p style="margin-left:0cm;"><code><span style="color:#000000;">} </span></code></p> <p style="margin-left:0cm;"><code><span style="color:#008200;">//</span></code><code><span style="color:#008200;">遍历map中的值 </span></code></p> <p style="margin-left:0cm;"><code><span style="color:#0000FF;">for</span></code> <code><span style="color:#000000;">(Integer value : map.values()) { </span></code></p> <p style="margin-left:0cm;"><code>  <span style="color:#000000;">System.out.println(</span><span style="color:#0000FF;">"Value = "</span></code> <code><span style="color:#000000;">+ value); </span></code></p> <p style="margin-left:0cm;"><code><span style="color:#000000;">}</span></code></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"><span style="color:#000000;">该方法比</span><span style="color:#000000;">entrySet</span><span style="color:#000000;">遍历在性能上稍好（快了</span><span style="color:#000000;">10%</span><span style="color:#000000;">），而且代码更加干净。</span></p> 
 <h2 style="margin-left:0cm;"><strong>80.Map接口的实现类是否存在有序存储值的，它们是如何保证有序的【LinkedHashMap】</strong></h2> 
 <pre style="margin-left:0cm;"><span style="color:#0000FF;">package</span><span style="color:#000000;"> cn.itcast_03;</span></pre> 
 <pre style="margin-left:0cm;"><span style="color:#0000FF;">import</span><span style="color:#000000;"> java.util.LinkedHashMap;</span><span style="color:#0000FF;">import</span><span style="color:#000000;"> java.util.Set;</span></pre> 
 <pre style="margin-left:0cm;"><span style="color:#008000;">/*</span></pre> 
 <pre style="margin-left:0cm;"><span style="color:#008000;"> * LinkedHashMap:</span><span style="color:#008000;">是</span><span style="color:#008000;">Map</span><span style="color:#008000;">接口的哈希表和链接列表实现，具有可预知的迭代顺序。</span></pre> 
 <pre style="margin-left:0cm;"><span style="color:#008000;"> * </span><span style="color:#008000;">由哈希表保证键的唯一性</span></pre> 
 <pre style="margin-left:0cm;"><span style="color:#008000;"> * </span><span style="color:#008000;">由链表保证键盘的有序</span><span style="color:#008000;">(</span><span style="color:#008000;">存储和取出的顺序一致</span><span style="color:#008000;">)</span></pre> 
 <pre style="margin-left:0cm;"><span style="color:#008000;"> */</span><span style="color:#0000FF;">public</span> <span style="color:#0000FF;">class</span><span style="color:#000000;"> LinkedHashMapDemo {<!-- --></span></pre> 
 <pre style="margin-left:0cm;">    <span style="color:#0000FF;">public</span> <span style="color:#0000FF;">static</span> <span style="color:#0000FF;">void</span><span style="color:#000000;"> main(String[] args) {<!-- --></span></pre> 
 <pre style="margin-left:0cm;">        <span style="color:#008000;">// </span><span style="color:#008000;">创建集合对象</span></pre> 
 <pre style="margin-left:0cm;"><span style="color:#000000;">        LinkedHashMap&lt;String, String&gt; hm = </span><span style="color:#0000FF;">new</span><span style="color:#000000;"> LinkedHashMap&lt;String, String&gt;();</span></pre> 
 <pre style="margin-left:0cm;"> </pre> 
 <pre style="margin-left:0cm;">        <span style="color:#008000;">// </span><span style="color:#008000;">创建并添加元素</span></pre> 
 <pre style="margin-left:0cm;"><span style="color:#000000;">        hm.put("2345", "hello");</span></pre> 
 <pre style="margin-left:0cm;"><span style="color:#000000;">        hm.put("1234", "world");</span></pre> 
 <pre style="margin-left:0cm;"><span style="color:#000000;">        hm.put("3456", "java");</span></pre> 
 <pre style="margin-left:0cm;"><span style="color:#000000;">        hm.put("1234", "javaee");</span></pre> 
 <pre style="margin-left:0cm;"><span style="color:#000000;">        hm.put("3456", "android");</span></pre> 
 <pre style="margin-left:0cm;"> </pre> 
 <pre style="margin-left:0cm;">        <span style="color:#008000;">// </span><span style="color:#008000;">遍历</span></pre> 
 <pre style="margin-left:0cm;"><span style="color:#000000;">        Set&lt;String&gt; set = hm.keySet();</span></pre> 
 <pre style="margin-left:0cm;">        <span style="color:#0000FF;">for</span><span style="color:#000000;"> (String key : set) {<!-- --></span></pre> 
 <pre style="margin-left:0cm;"><span style="color:#000000;">            String value = hm.get(key);</span></pre> 
 <pre style="margin-left:0cm;"><span style="color:#000000;">            System.out.println(key + "---" + value);</span></pre> 
 <pre style="margin-left:0cm;"><span style="color:#000000;">        }</span></pre> 
 <pre style="margin-left:0cm;"><span style="color:#000000;">    }</span></pre> 
 <pre style="margin-left:0cm;"><span style="color:#000000;">}</span></pre> 
 <ol><li><strong>讲讲Java的反射机制</strong></li></ol> 
 <p style="margin-left:0cm;"><span style="color:#444444;"> Java</span><span style="color:#444444;">反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制</span></p> 
 <ol><li><strong>缓存溢出</strong></li></ol> 
 <p style="margin-left:0cm;"><a href="https://blog.csdn.net/penglaozi/article/details/53147302">https://blog.csdn.net/penglaozi/article/details/53147302</a></p> 
 <ol><li><strong>log4j日志的级别</strong></li></ol> 
 <p style="margin-left:0cm;"><span style="color:#000000;">OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; ALL</span></p> 
 <h2 style="margin-left:0cm;"><strong>84.Servlet的生命周期</strong></h2> 
 <p style="margin-left:0cm;"><span style="color:#333333;">加载和实例化、初始化、处理请求、服务结束</span></p> 
 <p style="margin-left:0cm;"><span style="color:#333333;">初始化的方法init()、处理客户请求的方法service()、服务结束的方法destory()</span></p> 
 <h2 style="margin-left:0cm;"><strong>85.jsp与servlet的区别</strong></h2> 
 <p style="margin-left:0cm;"><span style="color:#333333;">jsp</span><span style="color:#333333;">是html中内嵌java代码；servlet把html代码和JAVA代码分离开；<br> jsp侧重与显示；servlet侧重与控制逻辑</span></p> 
 <h2 style="margin-left:0cm;"><strong>86左连接，右连接 内连接，外连接 区别</strong></h2> 
 <p style="margin-left:0cm;"><span style="color:#333333;">左外连接是返回主表的所有信息,如果从表没有主表信息显示为空</span><br><span style="color:#333333;">而内连接是以从表为主如没数据那么就不显示</span><br><span style="color:#333333;">举个例子</span><br><span style="color:#333333;">如有2张表 student grade</span><br><span style="color:#333333;">student</span><br><span style="color:#333333;">有</span><a href="https://www.baidu.com/s?wd=sid&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" rel="nofollow"><span style="color:#3f88bf;">sid</span></a><span style="color:#333333;">,sname</span><span style="color:#333333;">两列</span><br><span style="color:#333333;">有3条数据 1,呵呵 2,嘿嘿 3,嘻嘻</span><br><span style="color:#333333;">grade</span><br><span style="color:#333333;">有score,</span><a href="https://www.baidu.com/s?wd=sid&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" rel="nofollow"><span style="color:#3f88bf;">sid</span></a><br><span style="color:#333333;">有2条数据 90,1 80,2</span><br><span style="color:#333333;">比如我们要查哪个人考了多少分呢么左连接就是</span><br><span style="color:#333333;">呵呵 90</span><br><span style="color:#333333;">嘿嘿 80</span><br><span style="color:#333333;">嘻嘻 null</span><br><span style="color:#333333;">内连接就是</span><br><span style="color:#333333;">呵呵 90</span><br><span style="color:#333333;">嘿嘿 80</span></p> 
 <h2 style="margin-left:0cm;"><strong>87 什么情况下使用子查询，左连接，右连接</strong></h2> 
 <p style="margin-left:0cm;">当一个查询是另一个查询的条件时使用子查询。</p> 
 <p style="margin-left:0cm;">当两张表只需要获取左边表的数据时，使用左连接查询</p> 
 <p style="margin-left:0cm;">当两张表只需要获取右边表的数据时，使用右连接查询</p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>88 怎么使用jquery提交表单</strong></h2> 
 <p style="margin-left:0cm;">获取表单的id 使用.submit()方法</p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>89 springCloud怎么配置网关</strong></h2> 
 <p style="margin-left:0cm;">@RestController</p> 
 <p style="margin-left:0cm;">public class NewsController {<!-- --></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;">    private static final String REST_URL_PREFIX = "http://TOMCATGO-PROVIDE-NEWS";</p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;">    /**</p> 
 <p style="margin-left:0cm;">     * 提供了多种便捷访问的http模板</p> 
 <p style="margin-left:0cm;">     */</p> 
 <p style="margin-left:0cm;">    @Autowired</p> 
 <p style="margin-left:0cm;">    private RestTemplate restTemplate;</p> 
 <p style="margin-left:0cm;">    //(url,requestMap,ResponseBean.class)</p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;">    @GetMapping(value="/news/list")</p> 
 <p style="margin-left:0cm;">    public Object index(HttpServletResponse response){<!-- --></p> 
 <p style="margin-left:0cm;">        response.setHeader("Access-Control-Allow-Origin", "*");</p> 
 <p style="margin-left:0cm;">        System.out.println("1111111111111111111111");</p> 
 <p style="margin-left:0cm;">        return restTemplate.getForObject(REST_URL_PREFIX+"/listAll",Object.class);</p> 
 <p style="margin-left:0cm;">    }</p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;">    @GetMapping(value="/news/{id}")</p> 
 <p style="margin-left:0cm;">    public Object getNewsInfo(HttpServletResponse response,@PathVariable("id") Integer id){<!-- --></p> 
 <p style="margin-left:0cm;">        response.setHeader("Access-Control-Allow-Origin", "*");</p> 
 <p style="margin-left:0cm;">        return restTemplate.getForObject(REST_URL_PREFIX+"/news/"+id,Object.class);</p> 
 <p style="margin-left:0cm;">    }</p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;">    @RequestMapping(value="/index",method = RequestMethod.GET)</p> 
 <p style="margin-left:0cm;">    public Object indexx(HttpServletResponse response){<!-- --></p> 
 <p style="margin-left:0cm;">        response.setHeader("Access-Control-Allow-Origin", "*");</p> 
 <p style="margin-left:0cm;">        return restTemplate.getForObject(REST_URL_PREFIX+"/index",Object.class);</p> 
 <p style="margin-left:0cm;">    }</p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;">}</p> 
 <p style="margin-left:0cm;"></p> 
 <h2 style="margin-left:0cm;"><strong>90 redis怎么设置过期时间</strong></h2> 
 <p style="margin-left:0cm;">Jedis调用expire方法设置过期时间</p> 
 <h2 style="margin-left:0cm;"><strong>91 数据库触发器</strong></h2> 
 <p style="margin-left:0cm;"><span style="color:#0000FF;">触发器</span></p> 
 <p style="margin-left:0cm;"><span style="color:#393939;">　　其是一种特殊的存储过程。一般的存储过程是通过存储过程名直接调用，而触发器主要是</span></p> 
 <p style="margin-left:0cm;"><span style="color:#393939;">　　通过事件</span><span style="color:#393939;">(</span><span style="color:#393939;">增、删、改</span><span style="color:#393939;">)</span><span style="color:#393939;">进行触发而被执行的。其在表中数据发生变化时自动强制执行。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#393939;">　　常见的触发器有两种：</span><span style="color:#393939;">after(for)</span><span style="color:#393939;">、</span><span style="color:#393939;">instead of,</span><span style="color:#393939;">用于</span><span style="color:#393939;">insert</span><span style="color:#393939;">、</span><span style="color:#393939;">update</span><span style="color:#393939;">、</span><span style="color:#393939;">delete</span><span style="color:#393939;">事件。</span></p> 
 <p style="margin-left:0cm;">　　<span style="color:#393939;">after(for)        </span><span style="color:#393939;">表示执行代码后，执行触发器</span></p> 
 <p style="margin-left:0cm;">　　<span style="color:#393939;">instead of        </span><span style="color:#393939;">表示执行代码前，用已经写好的触发器代替你的操作</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#0000FF;">触发器语法：</span></p> 
 <p style="margin-left:0cm;">　　<span style="color:#393939;">create trigger </span><span style="color:#393939;">触发器的名字</span><span style="color:#393939;">   on </span><span style="color:#393939;">操作表</span></p> 
 <p style="margin-left:0cm;">　　<span style="color:#393939;">for|after         instead of</span></p> 
 <p style="margin-left:0cm;">　　<span style="color:#393939;">update|insert|delete</span></p> 
 <p style="margin-left:0cm;">　　<span style="color:#393939;">as</span></p> 
 <p style="margin-left:0cm;">　　<span style="color:#393939;">SQL</span><span style="color:#393939;">语句</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#0000FF;">触发器实现原理图</span></p> 
 <p style="margin-left:0cm;"><span style="color:#393939;"><img alt="https://img-blog.csdnimg.cn/20181229001921494" class="has" id="图片_x0020_23" src="https://images2.imgbox.com/30/94/fcOoT6AB_o.png"></span></p> 
 <h2 style="margin-left:0cm;"><strong>92 redis和其他缓存技术有啥区别</strong></h2> 
 <p style="margin-left:0cm;"><span style="color:#000000;">1</span><span style="color:#000000;">、</span><span style="color:#000000;">Redis</span><span style="color:#000000;">和</span><span style="color:#000000;">Memcache</span><span style="color:#000000;">都是将数据存放在内存中，都是内存数据库。不过</span><span style="color:#000000;">memcache</span><span style="color:#000000;">还可用于缓存其他东西，例如图片、视频等等；</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">2</span><span style="color:#000000;">、</span><span style="color:#000000;">Redis</span><span style="color:#000000;">不仅仅支持简单的</span><span style="color:#000000;">k/v</span><span style="color:#000000;">类型的数据，同时还提供</span><span style="color:#000000;">list</span><span style="color:#000000;">，</span><span style="color:#000000;">set</span><span style="color:#000000;">，</span><span style="color:#000000;">hash</span><span style="color:#000000;">等数据结构的存储；</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">3</span><span style="color:#000000;">、</span><a href="https://www.baidu.com/s?wd=%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHcvrjTdrH00T1Y4rjDYnju-njb1nycLmW-b0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnHbzPHfYP10LPjDznWnkn1T3Ps" rel="nofollow"><span style="color:#336699;">虚拟内存</span></a><span style="color:#000000;">--Redis</span><span style="color:#000000;">当物理内存用完时，可以将一些很久没用到的</span><span style="color:#000000;">value </span><span style="color:#000000;">交换到磁盘；</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">4</span><span style="color:#000000;">、过期策略</span><span style="color:#000000;">--memcache</span><span style="color:#000000;">在</span><span style="color:#000000;">set</span><span style="color:#000000;">时就指定，例如</span><span style="color:#000000;">set key1 0 0 8,</span><span style="color:#000000;">即永不过期。</span><span style="color:#000000;">Redis</span><span style="color:#000000;">可以通过例如</span><span style="color:#000000;">expire </span><span style="color:#000000;">设定，例如</span><span style="color:#000000;">expire name 10</span><span style="color:#000000;">；</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">5</span><span style="color:#000000;">、分布式</span><span style="color:#000000;">--</span><span style="color:#000000;">设定</span><span style="color:#000000;">memcache</span><span style="color:#000000;">集群，利用</span><span style="color:#000000;">magent</span><span style="color:#000000;">做一主多从</span><span style="color:#000000;">;redis</span><span style="color:#000000;">可以做一主多从。都可以一主一从；</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">6</span><span style="color:#000000;">、存储数据安全</span><span style="color:#000000;">--memcache</span><span style="color:#000000;">挂掉后，数据没了；</span><span style="color:#000000;">redis</span><span style="color:#000000;">可以定期保存到磁盘（持久化）；</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">7</span><span style="color:#000000;">、</span><a href="https://www.baidu.com/s?wd=%E7%81%BE%E9%9A%BE%E6%81%A2%E5%A4%8D&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHcvrjTdrH00T1Y4rjDYnju-njb1nycLmW-b0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnHbzPHfYP10LPjDznWnkn1T3Ps" rel="nofollow"><span style="color:#336699;">灾难恢复</span></a><span style="color:#000000;">--memcache</span><span style="color:#000000;">挂掉后，数据不可恢复</span><span style="color:#000000;">; redis</span><span style="color:#000000;">数据丢失后可以通过</span><span style="color:#000000;">aof</span><span style="color:#000000;">恢复；</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">8</span><span style="color:#000000;">、</span><span style="color:#000000;">Redis</span><span style="color:#000000;">支持数据的备份，即</span><span style="color:#000000;">master-slave</span><span style="color:#000000;">模式的数据备份；</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <h2 style="margin-left:0cm;"><strong>93 autowired和 resource的区别</strong></h2> 
 <p style="margin-left:0cm;"><span style="color:#000000;">@Resource</span><span style="color:#000000;">装配顺序</span><br> 　　<span style="color:#000000;">1. </span><span style="color:#000000;">如果同时指定了</span><span style="color:#000000;">name</span><span style="color:#000000;">和</span><span style="color:#000000;">type</span><span style="color:#000000;">，则从</span><span style="color:#000000;">Spring</span><span style="color:#000000;">上下文中找到唯一匹配的</span><span style="color:#000000;">bean</span><span style="color:#000000;">进行装配，找不到则抛出异常</span><br> 　　<span style="color:#000000;">2. </span><span style="color:#000000;">如果指定了</span><span style="color:#000000;">name</span><span style="color:#000000;">，则从上下文中查找名称（</span><span style="color:#000000;">id</span><span style="color:#000000;">）匹配的</span><span style="color:#000000;">bean</span><span style="color:#000000;">进行装配，找不到则抛出异常</span><br> 　　<span style="color:#000000;">3. </span><span style="color:#000000;">如果指定了</span><span style="color:#000000;">type</span><span style="color:#000000;">，则从上下文中找到类型匹配的唯一</span><span style="color:#000000;">bean</span><span style="color:#000000;">进行装配，找不到或者找到多个，都会抛出异常</span><br> 　　<span style="color:#000000;">4. </span><span style="color:#000000;">如果既没有指定</span><span style="color:#000000;">name</span><span style="color:#000000;">，又没有指定</span><span style="color:#000000;">type</span><span style="color:#000000;">，则自动按照</span><span style="color:#000000;">byName</span><span style="color:#000000;">方式进行装配；如果没有匹配，则回退为一个原始类型进行匹配，如果匹配则自动装配；</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">@Autowired </span><span style="color:#000000;">与</span><span style="color:#000000;">@Resource</span><span style="color:#000000;">的区别：</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">1</span><span style="color:#000000;">、</span><span style="color:#000000;"> @Autowired</span><span style="color:#000000;">与</span><span style="color:#000000;">@Resource</span><span style="color:#000000;">都可以用来装配</span><span style="color:#000000;">bean. </span><span style="color:#000000;">都可以写在字段上</span><span style="color:#000000;">,</span><span style="color:#000000;">或写在</span><span style="color:#000000;">setter</span><span style="color:#000000;">方法上。</span></p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">2</span><span style="color:#000000;">、</span><span style="color:#000000;"> @Autowired</span><span style="color:#000000;">默认按类型装配（这个注解是属业</span><span style="color:#000000;">spring</span><span style="color:#000000;">的），默认情况下必须要求依赖对象必须存在，如果要允许</span><span style="color:#000000;">null</span><span style="color:#000000;">值，可以设置它的</span><span style="color:#000000;">required</span><span style="color:#000000;">属性为</span><span style="color:#000000;">false</span><span style="color:#000000;">，如：</span><span style="color:#000000;">@Autowired(required=false) </span><span style="color:#000000;">，如果我们想使用名称装配可以结合</span><span style="color:#000000;">@Qualifier</span><span style="color:#000000;">注解进行使用，如下：</span></p> 
 <table border="1" cellspacing="0"><tbody><tr><td style="border-color:#C0C0C0;vertical-align:bottom;width:26.25pt;"> <p style="margin-left:0cm;"><span style="color:#afafaf;">1</span></p> <p style="margin-left:0cm;"><span style="color:#afafaf;">2</span></p> </td><td style="border-color:#C0C0C0;vertical-align:bottom;"> <p style="margin-left:0cm;"><code><span style="color:#808080;">@Autowired</span></code><code><span style="color:#000000;">()</span></code><code><span style="color:#808080;">@Qualifier</span></code><code><span style="color:#000000;">(</span></code><code><span style="color:#0000FF;">"baseDao"</span></code><code><span style="color:#000000;">)</span></code></p> <p style="margin-left:0cm;"><code><span style="color:#0000FF;">private</span></code><code><span style="color:#000000;">BaseDao baseDao;</span></code></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"><span style="color:#000000;">3</span><span style="color:#000000;">、</span><span style="color:#000000;">@Resource</span><span style="color:#000000;">（这个注解属于</span><span style="color:#000000;">J2EE</span><span style="color:#000000;">的），默认按照名称进行装配，名称可以通过</span><span style="color:#000000;">name</span><span style="color:#000000;">属性进行指定，如果没有指定</span><span style="color:#000000;">name</span><span style="color:#000000;">属性，当注解写在字段上时，默认取字段名进行安装名称查找，如果注解写在</span><span style="color:#000000;">setter</span><span style="color:#000000;">方法上默认取属性名进行装配。当找不到与名称匹配的</span><span style="color:#000000;">bean</span><span style="color:#000000;">时才按照类型进行装配。但是需要注意的是，如果</span><span style="color:#000000;">name</span><span style="color:#000000;">属性一旦指定，就只会按照名称进行装配。</span></p> 
 <table border="1" cellspacing="0"><tbody><tr><td style="border-color:#C0C0C0;vertical-align:bottom;width:26.25pt;"> <p style="margin-left:0cm;"><span style="color:#afafaf;">1</span></p> <p style="margin-left:0cm;"><span style="color:#afafaf;">2</span></p> </td><td style="border-color:#C0C0C0;vertical-align:bottom;"> <p style="margin-left:0cm;"><code><span style="color:#808080;">@Resource</span></code><code><span style="color:#000000;">(name=</span></code><code><span style="color:#0000FF;">"baseDao"</span></code><code><span style="color:#000000;">)</span></code></p> <p style="margin-left:0cm;"><code><span style="color:#0000FF;">private</span></code><code><span style="color:#000000;">BaseDao baseDao;</span></code></p> </td></tr></tbody></table> 
 <p style="margin-left:0cm;"><span style="color:#000000;">推荐使用：</span><span style="color:#000000;">@Resource</span><span style="color:#000000;">注解在字段上，这样就不用写</span><span style="color:#000000;">setter</span><span style="color:#000000;">方法了，并且这个注解是属于</span><span style="color:#000000;">J2EE</span><span style="color:#000000;">的，减少了与</span><span style="color:#000000;">spring</span><span style="color:#000000;">的耦合。这样代码看起就比较优雅。</span></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><a href="http://blog.csdn.net/clerk0324/article/details/25198457"><span style="color:#000000;">spring @Qualifier</span><span style="color:#000000;">注解</span></a></p> 
 <p style="margin-left:0cm;"> </p> 
 <p style="margin-left:0cm;"><span style="color:#000000;">@Autowired</span><span style="color:#000000;">是根据类型进行自动装配的。如果当</span><span style="color:#000000;">Spring</span><span style="color:#000000;">上下文中存在不止一个</span><span style="color:#000000;">UserDao</span><span style="color:#000000;">类型的</span><span style="color:#000000;">bean</span><span style="color:#000000;">时，就会抛出</span><span style="color:#000000;">BeanCreationException</span><span style="color:#000000;">异常</span><span style="color:#000000;">;</span><span style="color:#000000;">如果</span><span style="color:#000000;">Spring</span><span style="color:#000000;">上下文中不存在</span><span style="color:#000000;">UserDao</span><span style="color:#000000;">类型的</span><span style="color:#000000;">bean</span><span style="color:#000000;">，也会抛出</span><span style="color:#000000;">BeanCreationException</span><span style="color:#000000;">异常。我们可以使用</span><span style="color:#000000;">@Qualifier</span><span style="color:#000000;">配合</span><span style="color:#000000;">@Autowired</span><span style="color:#000000;">来解决这些问题</span><span style="color:#000000;">.</span></p> 
 <h2 style="margin-left:0cm;"><strong>94responseBody作用</strong></h2> 
 <p style="margin-left:0cm;"><span style="color:#333333;">@ResponseBody</span><span style="color:#333333;">是作用在方法上的，</span><span style="color:#333333;">@ResponseBody </span><span style="color:#333333;">表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据。@RequestBody 将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。</span></p> 
 <p style="margin-left:0cm;"> </p> 
</div> 
<p>转载于:https://www.cnblogs.com/chengxiaolong/p/10194905.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/71e4535c5ebf7908e1faae9665b14a28/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">音频信息隐藏算法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bc97da51517761317ba08272a101baae/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何在Linux中安装nasm最新版本</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>