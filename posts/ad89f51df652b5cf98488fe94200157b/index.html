<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Go-语言容器1 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Go-语言容器1" />
<meta property="og:description" content="一.Go语言数组 数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，所以在Go语言中很少直接使用数组。
和数组对应的类型是 Slice（切片），Slice 是可以增长和收缩的动态序列，功能也更灵活，但是想要理解 slice 工作原理的话需要先理解数组。
Go语言数组的声明 数组的声明语法如下：
var 数组变量名 [元素数量]Type 语法说明如下所示：
数组变量名：数组声明及使用时的变量名。元素数量：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整型数值，元素数量不能含有到运行时才能确认大小的数值。Type：可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组。 数组的每个元素都可以通过索引下标来访问，索引下标的范围是从 0 开始到数组长度减 1 的位置，内置函数 len() 可以返回数组中元素的个数。
var a [3]int // 定义三个整数的数组 fmt.Println(a[0]) // 打印第一个元素 fmt.Println(a[len(a)-1]) // 打印最后一个元素 // 打印索引和元素 for i, v := range a { fmt.Printf(&#34;%d %d\n&#34;, i, v) } // 仅打印元素 for _, v := range a { fmt.Printf(&#34;%d\n&#34;, v) } 默认情况下，数组的每个元素都会被初始化为元素类型对应的零值，对于数字类型来说就是 0，同时也可以使用数组字面值语法，用一组值来初始化数组：
var q [3]int = [3]int{1, 2, 3} var r [3]int = [3]int{1, 2} fmt." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ad89f51df652b5cf98488fe94200157b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-19T17:35:42+08:00" />
<meta property="article:modified_time" content="2023-12-19T17:35:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Go-语言容器1</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一.Go语言数组</h2> 
<p>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，所以在Go语言中很少直接使用数组。</p> 
<p></p> 
<p>和数组对应的类型是 Slice（切片），Slice 是可以增长和收缩的动态序列，功能也更灵活，但是想要理解 slice 工作原理的话需要先理解数组。</p> 
<h3>Go语言数组的声明</h3> 
<p><strong>数组的声明语法如下：</strong></p> 
<pre><code class="hljs">var 数组变量名 [元素数量]Type</code></pre> 
<p><strong>语法说明如下所示：</strong></p> 
<ul><li>数组变量名：数组声明及使用时的变量名。</li><li>元素数量：数组的元素数量，可以是一个表达式，但最终通过编译期计算的结果必须是整型数值，元素数量不能含有到运行时才能确认大小的数值。</li><li>Type：可以是任意基本类型，包括数组本身，类型为数组本身时，可以实现多维数组。</li></ul> 
<p></p> 
<p>数组的每个元素都可以通过索引下标来访问，索引下标的范围是从 0 开始到数组长度减 1 的位置，内置函数 len() 可以返回数组中元素的个数。</p> 
<pre><code class="language-Go">var a [3]int             // 定义三个整数的数组
fmt.Println(a[0])        // 打印第一个元素
fmt.Println(a[len(a)-1]) // 打印最后一个元素
// 打印索引和元素
for i, v := range a {
    fmt.Printf("%d %d\n", i, v)
}
// 仅打印元素
for _, v := range a {
    fmt.Printf("%d\n", v)
}</code></pre> 
<p>默认情况下，数组的每个元素都会被初始化为元素类型对应的零值，对于数字类型来说就是 0，同时也可以使用数组字面值语法，用一组值来初始化数组：</p> 
<pre><code class="language-Go">var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 2}
fmt.Println(r[2]) // "0"</code></pre> 
<p>在数组的定义中，如果在数组长度的位置出现“...”省略号，则表示数组的长度是根据初始化值的个数来计算，因此，上面数组 q 的定义可以简化为：</p> 
<pre><code class="language-Go">q := [...]int{1, 2, 3}
fmt.Printf("%T\n", q) // "[3]int"</code></pre> 
<p>数组的长度是数组类型的一个组成部分，因此 [3]int 和 [4]int 是两种不同的数组类型，数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。</p> 
<pre><code class="language-Go">q := [3]int{1, 2, 3}
q = [4]int{1, 2, 3, 4} // 编译错误：无法将 [4]int 赋给 [3]int</code></pre> 
<h3>比较两个数组是否相等</h3> 
<p>如果两个数组类型相同（包括数组的长度，数组中元素的类型）的情况下，我们可以直接通过较运算符（==和!=）来判断两个数组是否相等，只有当两个数组的所有元素都是<span style="background-color:#ffd900;">相等的时候数组才是相等的，不能比较两个类型不同的数组</span>，否则程序将无法完成编译。</p> 
<pre><code class="language-Go">a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b, a == c, b == c) // "true false false"
d := [3]int{1, 2}
fmt.Println(a == d) // 编译错误：无法比较 [2]int == [3]int</code></pre> 
<h3>遍历数组——访问每一个数组元素</h3> 
<p>遍历数组也和遍历切片类似，代码如下所示：</p> 
<pre><code class="language-Go">var team [3]string
team[0] = "hammer"
team[1] = "soldier"
team[2] = "mum"
for k, v := range team {
    fmt.Println(k, v)
}
代码输出结果：
0 hammer
1 soldier
2 mum</code></pre> 
<p></p> 
<p>代码说明如下：</p> 
<ul><li>第 6 行，使用 for 循环，遍历 team 数组，遍历出的键 k 为数组的索引，值 v 为数组的每个元素值。</li><li>第 7 行，将每个键值打印出来。</li></ul> 
<h2>二.多维数组</h2> 
<p>Go语言中允许使用多维数组，因为数组属于值类型，所以多维数组的所有维度都会在创建时自动初始化零值，多维数组尤其适合管理具有父子关系或者与坐标系相关联的数据。</p> 
<p><strong>声明多维数组的语法如下所示：</strong></p> 
<pre><code class="language-Go">var array_name [size1][size2]...[sizen] array_type</code></pre> 
<p>其中，array_name 为数组的名字，array_type 为数组的类型，size1、size2 等等为数组每一维度的长度。</p> 
<p>二维数组是最简单的多维数组，二维数组本质上是由多个一维数组组成的。</p> 
<p></p> 
<h3>【示例 1】声明二维数组</h3> 
<pre><code class="language-Go">// 声明一个二维整型数组，两个维度的长度分别是 4 和 2
var array [4][2]int
// 使用数组字面量来声明并初始化一个二维整型数组
array = [4][2]int{<!-- -->{10, 11}, {20, 21}, {30, 31}, {40, 41}}
// 声明并初始化数组中索引为 1 和 3 的元素
array = [4][2]int{1: {20, 21}, 3: {40, 41}}
// 声明并初始化数组中指定的元素
array = [4][2]int{1: {0: 20}, 3: {1: 41}}</code></pre> 
<p>下图展示了上面示例中声明的二维数组在每次声明并初始化后包含的值。</p> 
<p><img alt="" height="474" src="https://images2.imgbox.com/18/4e/grAsFrDb_o.png" width="637"></p> 
<p>为了访问单个元素，需要反复组合使用[ ]方括号，如下所示。</p> 
<p></p> 
<h3>【示例 2】为二维数组的每个元素赋值</h3> 
<pre><code class="language-Go">// 声明一个 2×2 的二维整型数组
var array [2][2]int
// 设置每个元素的整型值
array[0][0] = 10
array[0][1] = 20
array[1][0] = 30
array[1][1] = 40</code></pre> 
<p>只要类型一致，就可以将多维数组互相赋值，如下所示，多维数组的类型包括每一维度的长度以及存储在元素中数据的类型。</p> 
<p></p> 
<h3>【示例 3】同样类型的多维数组赋值</h3> 
<pre><code class="language-Go">// 声明两个二维整型数组
var array1 [2][2]int
var array2 [2][2]int
// 为array2的每个元素赋值
array2[0][0] = 10
array2[0][1] = 20
array2[1][0] = 30
array2[1][1] = 40
// 将 array2 的值复制给 array1
array1 = array2</code></pre> 
<p>因为数组中每个元素都是一个值，所以可以独立复制某个维度，如下所示。</p> 
<p></p> 
<h3>【示例 4】使用索引为多维数组赋值</h3> 
<pre><code class="language-Go">// 将 array1 的索引为 1 的维度复制到一个同类型的新数组里
var array3 [2]int = array1[1]
// 将数组中指定的整型值复制到新的整型变量里
var value int = array1[1][0]</code></pre> 
<h2>三.Go语言切片</h2> 
<p>切片（slice）是对数组的一个连续片段的引用，所以切片是一个引用类型（因此更类似于 C/<a href="https://c.biancheng.net/cplus/" rel="nofollow" title="C++">C++</a> 中的数组类型，或者 <a href="https://c.biancheng.net/python/" rel="nofollow" title="Python">Python</a> 中的 list 类型），这个片段可以是整个数组，也可以是由起始和终止索引标识的一些项的子集，需要注意的是，终止索引标识的项不包括在切片内。</p> 
<p></p> 
<p>Go语言中切片的内部结构包含地址、大小和容量，切片一般用于快速地操作一块数据集合，如果将数据集合比作切糕的话，切片就是你要的“那一块”，切的过程包含从哪里开始（切片的起始位置）及切多大（切片的大小），容量可以理解为装切片的口袋大小，如下图所示。</p> 
<p><img alt="" height="255" src="https://images2.imgbox.com/74/92/fSPDZKTS_o.png" width="765"></p> 
<p></p> 
<h3>从数组或切片生成新的切片</h3> 
<p>切片默认指向一段连续内存区域，可以是数组，也可以是切片本身。</p> 
<p>从连续内存区域生成切片是常见的操作，格式如下：</p> 
<pre><code class="language-Go">slice [开始位置 : 结束位置]</code></pre> 
<p>语法说明如下：</p> 
<ul><li>slice：表示目标切片对象；</li><li>开始位置：对应目标切片对象的索引；</li><li>结束位置：对应目标切片的结束索引。</li></ul> 
<p></p> 
<p>从数组生成切片，代码如下：</p> 
<pre><code class="language-Go">var a  = [3]int{1, 2, 3}
fmt.Println(a, a[1:2])</code></pre> 
<p>其中 a 是一个拥有 3 个整型元素的数组，被初始化为数值 1 到 3，使用 a[1:2] 可以生成一个新的切片，代码运行结果如下：</p> 
<pre><code class="language-Go">[1 2 3]  [2]</code></pre> 
<p>其中 [2] 就是 a[1:2] 切片操作的结果。</p> 
<p></p> 
<p>从数组或切片生成新的切片拥有如下特性：</p> 
<ul><li>取出的元素数量为：结束位置 - 开始位置；</li><li>取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取；</li><li>当缺省开始位置时，表示从连续区域开头到结束位置；</li><li>当缺省结束位置时，表示从开始位置到整个连续区域末尾；</li><li>两者同时缺省时，与切片本身等效；</li><li>两者同时为 0 时，等效于空切片，一般用于切片复位。</li></ul> 
<p></p> 
<p>根据索引位置取切片 slice 元素值时，取值范围是（0～len(slice)-1），超界会报运行时错误，生成切片时，结束位置可以填写 len(slice) 但不会报错。</p> 
<p></p> 
<p>下面通过实例来熟悉切片的特性。</p> 
<h4>1) 从指定范围中生成切片</h4> 
<p>切片和数组密不可分，如果将数组理解为一栋办公楼，那么切片就是把不同的连续楼层出租给使用者，出租的过程需要选择开始楼层和结束楼层，这个过程就会生成切片，示例代码如下：</p> 
<pre><code class="language-Go">var highRiseBuilding [30]int
for i := 0; i &lt; 30; i++ {
        highRiseBuilding[i] = i + 1
}
// 区间
fmt.Println(highRiseBuilding[10:15])
// 中间到尾部的所有元素
fmt.Println(highRiseBuilding[20:])
// 开头到中间指定位置的所有元素
fmt.Println(highRiseBuilding[:2])
代码输出如下：
[11 12 13 14 15]
[21 22 23 24 25 26 27 28 29 30]
[1 2]</code></pre> 
<p>代码中构建了一个 30 层的高层建筑，数组的元素值从 1 到 30，分别代表不同的独立楼层，输出的结果是不同的租售方案。</p> 
<p></p> 
<p>代码说明如下：</p> 
<ul><li>第 8 行，尝试出租一个区间楼层。</li><li>第 11 行，出租 20 层以上。</li><li>第 14 行，出租 2 层以下，一般是商用铺面。</li></ul> 
<p></p> 
<p>切片有点像C语言里的指针，指针可以做运算，但代价是内存操作越界，切片在指针的基础上增加了大小，约束了切片对应的内存区域，切片使用中无法对切片内部的地址和大小进行手动调整，因此切片比指针更安全、强大。</p> 
<h4>2) 表示原有的切片</h4> 
<p>生成切片的格式中，当开始和结束位置都被忽略时，生成的切片将表示和原切片一致的切片，并且生成的切片与原切片在数据内容上也是一致的，代码如下：</p> 
<pre><code class="language-Go">a := []int{1, 2, 3}
fmt.Println(a[:])
a 是一个拥有 3 个元素的切片，将 a 切片使用 a[:] 进行操作后，得到的切片与 a 切片一致，代码输出如下：
[1 2 3]</code></pre> 
<h4>3) 重置切片，清空拥有的元素</h4> 
<p>把切片的开始和结束位置都设为 0 时，生成的切片将变空，代码如下：</p> 
<pre><code class="language-Go">a := []int{1, 2, 3}
fmt.Println(a[0:0])
代码输出如下：
[]</code></pre> 
<h3>直接声明新的切片</h3> 
<p>除了可以从原有的数组或者切片中生成切片外，也可以声明一个新的切片，每一种类型都可以拥有其切片类型，表示多个相同类型元素的连续集合，因此切片类型也可以被声明，切片类型声明格式如下：</p> 
<pre><code class="language-Go">var name []Type</code></pre> 
<p>其中 name 表示切片的变量名，Type 表示切片对应的元素类型。</p> 
<p></p> 
<p>下面代码展示了切片声明的使用过程：</p> 
<pre><code class="language-Go">// 声明字符串切片
var strList []string
// 声明整型切片
var numList []int
// 声明一个空切片
var numListEmpty = []int{}
// 输出3个切片
fmt.Println(strList, numList, numListEmpty)
// 输出3个切片大小
fmt.Println(len(strList), len(numList), len(numListEmpty))
// 切片判定空的结果
fmt.Println(strList == nil)
fmt.Println(numList == nil)
fmt.Println(numListEmpty == nil)
代码输出结果：
[] [] []
0 0 0
true
true
false</code></pre> 
<p>代码说明如下：</p> 
<ul><li>第 2 行，声明一个字符串切片，切片中拥有多个字符串。</li><li>第 5 行，声明一个整型切片，切片中拥有多个整型数值。</li><li>第 8 行，将 numListEmpty 声明为一个整型切片，本来会在{}中填充切片的初始化元素，这里没有填充，所以切片是空的，但是此时的 numListEmpty 已经被分配了内存，只是还没有元素。</li><li>第 11 行，切片均没有任何元素，3 个切片输出元素内容均为空。</li><li>第 14 行，没有对切片进行任何操作，strList 和 numList 没有指向任何数组或者其他切片。</li><li>第 17 行和第 18 行，声明但未使用的切片的默认值是 nil，strList 和 numList 也是 nil，所以和 nil 比较的结果是 true。</li><li><span style="background-color:#ffd900;">第 19 行，numListEmpty 已经被分配到了内存，但没有元素，因此和 nil 比较时是 false。</span></li></ul> 
<p></p> 
<p>切片是动态结构，只能与 nil 判定相等，不能互相判定相等。声明新的切片后，可以使用 <a href="https://c.biancheng.net/view/28.html" rel="nofollow" title="append()">append()</a> 函数向切片中添加元素。</p> 
<h3>使用 make() 函数构造切片</h3> 
<p>如果需要动态地创建一个切片，可以使用 make() 内建函数，格式如下：</p> 
<pre><code class="language-Go">make( []Type, size, cap )</code></pre> 
<p>其中 Type 是指切片的元素类型，size 指的是为这个类型分配多少个元素，cap 为预分配的元素数量，这个值设定后不影响 size，只是能提前分配空间，降低多次分配空间造成的性能问题。</p> 
<p></p> 
<p>示例如下：</p> 
<pre><code class="language-Go">a := make([]int, 2)
b := make([]int, 2, 10)
fmt.Println(a, b)
fmt.Println(len(a), len(b))
代码输出如下：
[0 0] [0 0]
2 2</code></pre> 
<p>其中 a 和 b 均是预分配 2 个元素的切片，只是 b 的内部存储空间已经分配了 10 个，但实际使用了 2 个元素。</p> 
<p>容量不会影响当前的元素个数，因此 a 和 b 取 len 都是 2。</p> 
<p><strong>温馨提示</strong></p> 
<p>使用 make() 函数生成的切片一定发生了内存分配操作，但给定开始与结束位置（包括切片复位）的切片只是将新的切片结构指向已经分配好的内存区域，设定开始与结束位置，不会发生内存分配操作。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/13776e581132190cb2c35fc7da844cea/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【MATLAB/Simulink】控制系统中常用的函数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e812bf84a08117d83f7cbbd9a1eb2f20/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2023 软考信息安全工程师 知识点</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>