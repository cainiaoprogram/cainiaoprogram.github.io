<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ESP32CAM与安卓端进行配合控制灯光简述(含有4G网查看方法) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ESP32CAM与安卓端进行配合控制灯光简述(含有4G网查看方法)" />
<meta property="og:description" content="ESP32CAM 前言： 最近很忙，很久没更新了，因为之前倒腾了ESP32CAM模块发了一个B站的视频后，很多小伙伴都来找我问一下这个配合是如何进行的，因此写个简述，供大家有所参考。
视频效果： ESP32CAM实战效果！值得用来DIY的摄像头！
ESP32CAM： 我也有一个项目，名字叫做智能控制家居控制，因为控制需要有反馈的效果，如果不在家里又控制了家电，不亲眼看到总觉得不太好，看到控制的效果心里面总归要放心一点，因此我开始去网上选择摄像头模块。无意间看到了这款摄像头，当时就是被价格所吸引了，我是31入手的，拿到手后烧录了安信可官方的固件后，效果还不错。因此就开始了对这个模块的探寻之路。这个模块我倒没有深入去具体查看它的代码那些，我就想使用它的视频功能就行了，也不需要人脸识别(人脸识别太差了)，需要的就是能够流畅的观察到视频就行了。最开始的时候代码用的是arduino的官方ESP32中的camera那个例程，这个例程中功能很多，可以改变视频质量，视频格式，人脸识别等等。不过这个显得有点鸡肋了。因此最后我在社区找到了一个精简版的，就是直接观看摄像头的，很流畅，也很好用，地址为https://randomnerdtutorials.com/esp32-cam-video-streaming-web-server-camera-home-assistant/ ，在这里感谢作者了。关于烧录这些跟着教程走是没有一点问题的。在最后得到视频的播放地址后
就能够在局域网下通过浏览器来进行观看了(后面会说通过4G网来查看)，很遗憾的是这个视频同时只能有一个人观看，在增加客户端去用浏览器观看是看不到的。还有就是浏览器也有要求，最好是用火狐或者谷歌的浏览器。这一步完成了，这个ESP32CAM端就算完成了。接下来说一下安卓端。
安卓端： 大多数同学都对这个比较感兴趣，楼主呢对安卓的编程也不太会，这个成了一个大问题，很多做联动的都没办法实现。学习Java编安卓的时候效率很慢，也没有时间。后来偶然解除了易安卓，发现上手挺快的，很多的项目我都是用易安卓去完成的，因此，我给的方法就是易安卓，Java编应该也是类似的。这里请见谅！我们可以发现ESP32CAM是通过浏览器来进行查看的，因此编程的时候通过加入浏览器类库就能够实现了。需要类库的同学可以将邮箱留下，我发给你。下面看一下界面
思路也很简单 ，首先在ESP32CAM端建立一个UDP的服务器，然后自己规定协议，比如这里我规定1是打开灯光，0是关闭灯光，然后在浏览器的类库上写上转到ESP32CAM的视频地址上，只要安卓端按下按钮后，会发送对应的数据，CAM收到后作出控制就行了。
程序的思路就是这样，也很简单，至于UDP的建立这个就根据arduino上面自带的例程改一下就行了。我也是根据此，写完了自己的一个项目文件
后来又经过了一次修改，配合舵机后完成的效果很棒。我的项目的源码就不公开了，不过万变不离其宗，都是这个原理的。最后说一下4G的查看。
4G远程查看 先上效果
这里用到了内网穿透的效果，首先要确保自己家里面是公网的ip，大多数的同学都不是，最好就打电话给运行商说一下将自己家里面改为公网ip，然后将家里的光猫改为桥接模式，意思就是光猫只负责将光信号转化为电信号，而不做拨号路由的功能，这样路由器端就能够通过拨号获取到公网的ip，后面的工作就好做多了。
首先光猫的LAN口接入路由器的wan口，一旦光猫改为桥接模式后，路由器就需要拨号上网了(注意打电话给客服获取上网的账号和密码),然后路由器wan口模式改为拨号上网 ，然后你的wan口就会获取一个公网的ip地址
然后在路由器高级功能里面找到端口映射或者叫做虚拟服务器
先说一下访问的方式，比如你要访问ip为192.168.3.1，然后在浏览器输入这个ip访问的时候默认你访问的是80端口，而80端口大多数都被运营商给屏蔽了，因此最好选择其他的端口，我这里选择100端口，那么就应该在浏览器输入192.168.3.1:100。好的接下来说这个虚拟服务器的设置，外部端口号意思就是我们访问的端口号，我们选择的用100端口来访问，则外部端口号输入100
而这个内部端口号指的是你需要访问的局域网IP所用到的端口。我们的cam用的浏览器web访问用的就是80端口，因此内部端口号设置为80.而这个ip地址自然填的就是esp32cam的局域网ip。协议选择all，然后保存后就完成了设置。
比如现在我获取到的公网IP是110.189.213.3，那么在4G网下，我访问浏览器输入110.189.213.3:100则这个请求首先会转发到路由器端，然后路由器一看，寻思这个端口是设置转发了的嘛，所以他会将这个请求直接转到局域网cam的IP且访问的端口是80.那么就无形之间在局域网和远程建立了一个连接。就能够实现cam的远程查看，而不局限于局域网了。
结束语： 其实还有很多有意思的东西我都还想写，最近因为忙着考试也没时间去写,比如：ESP8266和天猫精灵的配合控制，基于云端的智能控制，ESP8266做为云端服务器，蓝桥杯的设计模板，还有关于路由器的设置，软路由的使用，笔记本做软路由等等很多有意思的我都想后面有空和大家分享。希望有兴趣的朋友可以关注，点赞，转发，哈哈，毕竟有了人看，才会有更新的动力啊。如果有什么问题不懂可以在评论下面讨论
-------------------------2020/4/10
ESP32CAM电路
附录 esp_camera.h /* * Example Use * static camera_config_t camera_example_config = { .pin_pwdn = PIN_PWDN, .pin_reset = PIN_RESET, .pin_xclk = PIN_XCLK, .pin_sscb_sda = PIN_SIOD, .pin_sscb_scl = PIN_SIOC, .pin_d7 = PIN_D7, .pin_d6 = PIN_D6, .pin_d5 = PIN_D5, .pin_d4 = PIN_D4, .pin_d3 = PIN_D3, ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/43753ea20ff5ead83f3ddeb8a3e54846/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-10T16:12:54+08:00" />
<meta property="article:modified_time" content="2020-04-10T16:12:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ESP32CAM与安卓端进行配合控制灯光简述(含有4G网查看方法)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><strong>                                                 ESP32CAM</strong></h2> 
<h3>前言：</h3> 
<p>       最近很忙，很久没更新了，因为之前倒腾了ESP32CAM模块发了一个B站的视频后，很多小伙伴都来找我问一下这个配合是如何进行的，因此写个简述，供大家有所参考。</p> 
<h3>视频效果：</h3> 
<div class="csdn-video-box"> 
 <iframe id="AtAVTZfE-1586503941893" frameborder="0" src="https://player.bilibili.com/player.html?aid=98946982" allowfullscreen="true" data-mediaembed="bilibili"></iframe> 
 <p>ESP32CAM实战效果！值得用来DIY的摄像头！</p> 
</div> 
<h3>ESP32CAM：</h3> 
<p>    我也有一个项目，名字叫做智能控制家居控制，因为控制需要有反馈的效果，如果不在家里又控制了家电，不亲眼看到总觉得不太好，看到控制的效果心里面总归要放心一点，因此我开始去网上选择摄像头模块。无意间看到了这款摄像头，当时就是被价格所吸引了，我是31入手的，拿到手后烧录了安信可官方的固件后，效果还不错。因此就开始了对这个模块的探寻之路。这个模块我倒没有深入去具体查看它的代码那些，我就想使用它的视频功能就行了，也不需要人脸识别(人脸识别太差了)，需要的就是能够流畅的观察到视频就行了。最开始的时候代码用的是arduino的官方ESP32中的camera那个例程，这个例程中功能很多，可以改变视频质量，视频格式，人脸识别等等。不过这个显得有点鸡肋了。因此最后我在社区找到了一个精简版的，就是直接观看摄像头的，很流畅，也很好用，地址为<a href="https://randomnerdtutorials.com/esp32-cam-video-streaming-web-server-camera-home-assistant/" rel="nofollow">https://randomnerdtutorials.com/esp32-cam-video-streaming-web-server-camera-home-assistant/</a> ，在这里感谢作者了。关于烧录这些跟着教程走是没有一点问题的。在最后得到视频的播放地址后</p> 
<p style="text-align:center;"><img alt="" height="74" src="https://images2.imgbox.com/0d/57/ZKQdjs6K_o.png" width="536"></p> 
<p>就能够在局域网下通过浏览器来进行观看了(后面会说通过4G网来查看)，很遗憾的是这个视频同时只能有一个人观看，在增加客户端去用浏览器观看是看不到的。还有就是浏览器也有要求，最好是用火狐或者谷歌的浏览器。这一步完成了，这个ESP32CAM端就算完成了。接下来说一下安卓端。</p> 
<h3>安卓端： </h3> 
<p>大多数同学都对这个比较感兴趣，楼主呢对安卓的编程也不太会，这个成了一个大问题，很多做联动的都没办法实现。学习Java编安卓的时候效率很慢，也没有时间。后来偶然解除了易安卓，发现上手挺快的，很多的项目我都是用易安卓去完成的，因此，我给的方法就是易安卓，Java编应该也是类似的。这里请见谅！我们可以发现ESP32CAM是通过浏览器来进行查看的，因此编程的时候通过加入浏览器类库就能够实现了。需要类库的同学可以将邮箱留下，我发给你。下面看一下界面</p> 
<p style="text-align:center;"><img alt="" height="615" src="https://images2.imgbox.com/12/94/QcAQuyeD_o.png" width="1200"></p> 
<p>思路也很简单 ，首先在ESP32CAM端建立一个UDP的服务器，然后自己规定协议，比如这里我规定1是打开灯光，0是关闭灯光，然后在浏览器的类库上写上转到ESP32CAM的视频地址上，只要安卓端按下按钮后，会发送对应的数据，CAM收到后作出控制就行了。</p> 
<p style="text-align:center;"><img alt="" height="631" src="https://images2.imgbox.com/80/84/YD8dU5ID_o.png" width="1090"></p> 
<p> 程序的思路就是这样，也很简单，至于UDP的建立这个就根据arduino上面自带的例程改一下就行了。我也是根据此，写完了自己的一个项目文件</p> 
<p style="text-align:center;"><img alt="" height="600" src="https://images2.imgbox.com/e0/26/VvTelgcg_o.png" width="300"></p> 
<p>后来又经过了一次修改，配合舵机后完成的效果很棒。我的项目的源码就不公开了，不过万变不离其宗，都是这个原理的。最后说一下4G的查看。</p> 
<h3>4G远程查看 </h3> 
<p>先上效果</p> 
<p style="text-align:center;"><img alt="" height="600" src="https://images2.imgbox.com/67/66/lmn15kkX_o.png" width="300"></p> 
<p>这里用到了内网穿透的效果，首先要确保自己家里面是公网的ip，大多数的同学都不是，最好就打电话给运行商说一下将自己家里面改为公网ip，然后将家里的光猫改为桥接模式，意思就是光猫只负责将光信号转化为电信号，而不做拨号路由的功能，这样路由器端就能够通过拨号获取到公网的ip，后面的工作就好做多了。</p> 
<p>首先光猫的LAN口接入路由器的wan口，一旦光猫改为桥接模式后，路由器就需要拨号上网了(注意打电话给客服获取上网的账号和密码),然后路由器wan口模式改为拨号上网 ，然后你的wan口就会获取一个公网的ip地址</p> 
<p style="text-align:center;"><img alt="" height="439" src="https://images2.imgbox.com/d7/39/MRaDq4ej_o.png" width="794"></p> 
<p>然后在路由器高级功能里面找到端口映射或者叫做虚拟服务器</p> 
<p></p> 
<p style="text-align:center;"><img alt="" height="329" src="https://images2.imgbox.com/85/67/0DYz1Kaw_o.png" width="526"></p> 
<p>先说一下访问的方式，比如你要访问ip为192.168.3.1，然后在浏览器输入这个ip访问的时候默认你访问的是80端口，而80端口大多数都被运营商给屏蔽了，因此最好选择其他的端口，我这里选择100端口，那么就应该在浏览器输入192.168.3.1:100。好的接下来说这个虚拟服务器的设置，外部端口号意思就是我们访问的端口号，我们选择的用100端口来访问，则外部端口号输入100</p> 
<p>而这个内部端口号指的是你需要访问的局域网IP所用到的端口。我们的cam用的浏览器web访问用的就是80端口，因此内部端口号设置为80.而这个ip地址自然填的就是esp32cam的局域网ip。协议选择all，然后保存后就完成了设置。</p> 
<p>比如现在我获取到的公网IP是110.189.213.3，那么在4G网下，我访问浏览器输入110.189.213.3:100则这个请求首先会转发到路由器端，然后路由器一看，寻思这个端口是设置转发了的嘛，所以他会将这个请求直接转到局域网cam的IP且访问的端口是80.那么就无形之间在局域网和远程建立了一个连接。就能够实现cam的远程查看，而不局限于局域网了。</p> 
<h3>结束语：</h3> 
<p>其实还有很多有意思的东西我都还想写，最近因为忙着考试也没时间去写,比如：ESP8266和天猫精灵的配合控制，基于云端的智能控制，ESP8266做为云端服务器，蓝桥杯的设计模板，还有关于路由器的设置，软路由的使用，笔记本做软路由等等很多有意思的我都想后面有空和大家分享。希望有兴趣的朋友可以关注，点赞，转发，哈哈，毕竟有了人看，才会有更新的动力啊。如果有什么问题不懂可以在评论下面讨论</p> 
<p>-------------------------2020/4/10</p> 
<p></p> 
<p></p> 
<p><strong>ESP32CAM电路</strong></p> 
<p><img alt="" height="963" src="https://images2.imgbox.com/5b/ad/Dr9YTMN8_o.png" width="1200"></p> 
<p></p> 
<h2>附录</h2> 
<h3>esp_camera.h</h3> 
<pre><code class="language-cpp">/*
 * Example Use
 *
    static camera_config_t camera_example_config = {
        .pin_pwdn       = PIN_PWDN,
        .pin_reset      = PIN_RESET,
        .pin_xclk       = PIN_XCLK,
        .pin_sscb_sda   = PIN_SIOD,
        .pin_sscb_scl   = PIN_SIOC,
        .pin_d7         = PIN_D7,
        .pin_d6         = PIN_D6,
        .pin_d5         = PIN_D5,
        .pin_d4         = PIN_D4,
        .pin_d3         = PIN_D3,
        .pin_d2         = PIN_D2,
        .pin_d1         = PIN_D1,
        .pin_d0         = PIN_D0,
        .pin_vsync      = PIN_VSYNC,
        .pin_href       = PIN_HREF,
        .pin_pclk       = PIN_PCLK,
        .xclk_freq_hz   = 20000000,
        .ledc_timer     = LEDC_TIMER_0,
        .ledc_channel   = LEDC_CHANNEL_0,
        .pixel_format   = PIXFORMAT_JPEG,
        .frame_size     = FRAMESIZE_SVGA,
        .jpeg_quality   = 10,
        .fb_count       = 2,
        .grab_mode      = CAMERA_GRAB_WHEN_EMPTY
    };
    esp_err_t camera_example_init(){
        return esp_camera_init(&amp;camera_example_config);
    }
    esp_err_t camera_example_capture(){
        //capture a frame
        camera_fb_t * fb = esp_camera_fb_get();
        if (!fb) {
            ESP_LOGE(TAG, "Frame buffer could not be acquired");
            return ESP_FAIL;
        }
        //replace this with your own function
        display_image(fb-&gt;width, fb-&gt;height, fb-&gt;pixformat, fb-&gt;buf, fb-&gt;len);
        //return the frame buffer back to be reused
        esp_camera_fb_return(fb);
        return ESP_OK;
    }
*/

#pragma once

#include "esp_err.h"
#include "driver/ledc.h"
#include "sensor.h"
#include "sys/time.h"

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Configuration structure for camera initialization
 */
typedef enum {
    CAMERA_GRAB_WHEN_EMPTY,         /*!&lt; Fills buffers when they are empty. Less resources but first 'fb_count' frames might be old */
    CAMERA_GRAB_LATEST              /*!&lt; Except when 1 frame buffer is used, queue will always contain the last 'fb_count' frames */
} camera_grab_mode_t;

/**
 * @brief Configuration structure for camera initialization
 */
typedef struct {
    int pin_pwdn;                   /*!&lt; GPIO pin for camera power down line */
    int pin_reset;                  /*!&lt; GPIO pin for camera reset line */
    int pin_xclk;                   /*!&lt; GPIO pin for camera XCLK line */
    int pin_sscb_sda;               /*!&lt; GPIO pin for camera SDA line */
    int pin_sscb_scl;               /*!&lt; GPIO pin for camera SCL line */
    int pin_d7;                     /*!&lt; GPIO pin for camera D7 line */
    int pin_d6;                     /*!&lt; GPIO pin for camera D6 line */
    int pin_d5;                     /*!&lt; GPIO pin for camera D5 line */
    int pin_d4;                     /*!&lt; GPIO pin for camera D4 line */
    int pin_d3;                     /*!&lt; GPIO pin for camera D3 line */
    int pin_d2;                     /*!&lt; GPIO pin for camera D2 line */
    int pin_d1;                     /*!&lt; GPIO pin for camera D1 line */
    int pin_d0;                     /*!&lt; GPIO pin for camera D0 line */
    int pin_vsync;                  /*!&lt; GPIO pin for camera VSYNC line */
    int pin_href;                   /*!&lt; GPIO pin for camera HREF line */
    int pin_pclk;                   /*!&lt; GPIO pin for camera PCLK line */

    int xclk_freq_hz;               /*!&lt; Frequency of XCLK signal, in Hz. EXPERIMENTAL: Set to 16MHz on ESP32-S2 or ESP32-S3 to enable EDMA mode */

    ledc_timer_t ledc_timer;        /*!&lt; LEDC timer to be used for generating XCLK  */
    ledc_channel_t ledc_channel;    /*!&lt; LEDC channel to be used for generating XCLK  */

    pixformat_t pixel_format;       /*!&lt; Format of the pixel data: PIXFORMAT_ + YUV422|GRAYSCALE|RGB565|JPEG  */
    framesize_t frame_size;         /*!&lt; Size of the output image: FRAMESIZE_ + QVGA|CIF|VGA|SVGA|XGA|SXGA|UXGA  */

    int jpeg_quality;               /*!&lt; Quality of JPEG output. 0-63 lower means higher quality  */
    size_t fb_count;                /*!&lt; Number of frame buffers to be allocated. If more than one, then each frame will be acquired (double speed)  */
    camera_grab_mode_t grab_mode;   /*!&lt; When buffers should be filled */
} camera_config_t;

/**
 * @brief Data structure of camera frame buffer
 */
typedef struct {
    uint8_t * buf;              /*!&lt; Pointer to the pixel data */
    size_t len;                 /*!&lt; Length of the buffer in bytes */
    size_t width;               /*!&lt; Width of the buffer in pixels */
    size_t height;              /*!&lt; Height of the buffer in pixels */
    pixformat_t format;         /*!&lt; Format of the pixel data */
    struct timeval timestamp;   /*!&lt; Timestamp since boot of the first DMA buffer of the frame */
} camera_fb_t;

#define ESP_ERR_CAMERA_BASE 0x20000
#define ESP_ERR_CAMERA_NOT_DETECTED             (ESP_ERR_CAMERA_BASE + 1)
#define ESP_ERR_CAMERA_FAILED_TO_SET_FRAME_SIZE (ESP_ERR_CAMERA_BASE + 2)
#define ESP_ERR_CAMERA_FAILED_TO_SET_OUT_FORMAT (ESP_ERR_CAMERA_BASE + 3)
#define ESP_ERR_CAMERA_NOT_SUPPORTED            (ESP_ERR_CAMERA_BASE + 4)

/**
 * @brief Initialize the camera driver
 *
 * @note call camera_probe before calling this function
 *
 * This function detects and configures camera over I2C interface,
 * allocates framebuffer and DMA buffers,
 * initializes parallel I2S input, and sets up DMA descriptors.
 *
 * Currently this function can only be called once and there is
 * no way to de-initialize this module.
 *
 * @param config  Camera configuration parameters
 *
 * @return ESP_OK on success
 */
esp_err_t esp_camera_init(const camera_config_t* config);

/**
 * @brief Deinitialize the camera driver
 *
 * @return
 *      - ESP_OK on success
 *      - ESP_ERR_INVALID_STATE if the driver hasn't been initialized yet
 */
esp_err_t esp_camera_deinit();

/**
 * @brief Obtain pointer to a frame buffer.
 *
 * @return pointer to the frame buffer
 */
camera_fb_t* esp_camera_fb_get();

/**
 * @brief Return the frame buffer to be reused again.
 *
 * @param fb    Pointer to the frame buffer
 */
void esp_camera_fb_return(camera_fb_t * fb);

/**
 * @brief Get a pointer to the image sensor control structure
 *
 * @return pointer to the sensor
 */
sensor_t * esp_camera_sensor_get();

/**
 * @brief Save camera settings to non-volatile-storage (NVS)
 * 
 * @param key   A unique nvs key name for the camera settings 
 */
esp_err_t esp_camera_save_to_nvs(const char *key);

/**
 * @brief Load camera settings from non-volatile-storage (NVS)
 * 
 * @param key   A unique nvs key name for the camera settings 
 */
esp_err_t esp_camera_load_from_nvs(const char *key);

#ifdef __cplusplus
}
#endif

#include "img_converters.h"</code></pre> 
<p><a href="https://randomnerdtutorials.com/projects-esp32-cam/3/" rel="nofollow">ESP32项目</a></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a062d2a3c361f4fc66a51757c169f0dd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Oracle Help</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/da15092e37cfa8ccfa241ee77018c183/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Charles iOS抓https包</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>