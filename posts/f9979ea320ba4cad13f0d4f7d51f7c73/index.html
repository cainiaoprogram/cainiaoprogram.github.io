<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>简单并全面地了解目标检测之fast RCNN(ROI Pooling、ROI Align和Precise ROI Pooling) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="简单并全面地了解目标检测之fast RCNN(ROI Pooling、ROI Align和Precise ROI Pooling)" />
<meta property="og:description" content="目标检测之fast RCNN[2015 Ross]
ROI： region of interest(类似region proposal)
B0.Region Proposal:和RCNN一样
2k每张图ROI，为每个ROI记录下坐标 B1 &amp; 2.卷积Convolution &amp; 投影Projection
对一张图只做一次卷积，每个ROI记录下的坐标投射到特征图上比如使用backbone网络结构为VGG，4 max pooling, 即坐标 /16得到2k个feature map zone特征图区域块 B3.ROI pooling layer
参考了SSP(Spatial pyramid pooling) Net 空间金字塔池化，把不同尺寸的图片resize到相同尺寸，并且保留他的空间位置信息处理方式类似于resize，把不同大小特征图变成同样大小特征图原理 每个特征图中大小不一样的ROI做一个网格划分，网格划分(grid)固定大小,并且在每个grid上面做一个max pooling所以不同大小的特征图(feature map)可以转换到相同大小的特征图RoI为7×5，输出为2×2尺寸的ROI Pooling举例
训练细节 batchsize = 2;64RoIs/image -&gt; 128 proposals(从2k个region proposal中按一定方式选出来(比如按大于指定阈值…));1/4 pos(正样本) &amp; 3/4 neg(负样本)IOU&gt;0.5 pos, [0.1, 0.5] neg, [0,0.1]hard neg训练时正负样本按1:3比例，测试用负难样本，如果有错误情况，用负难样本重新训练 问题 cnn中和ROI pooling中加起来pooling(取整)较多，损失像素点较多，当ROI较小时，相对损失的特征就更多了，fast rcnn对小目标检测不太友好 B4 FC layers
FC层中参数较多，可考虑SVD加速(一般不会,矩阵乘法加速效果更好)
B5 Multi-task Loss多任务损失函数
分类：n&#43;1(需考虑背景), softmax &#43; cross entropy, L(cls)定位：offset(用偏置项做预测), smoothL1, L(loc) 注意: Smoooth L2会使得小的更小，大的更大 损失函数为分类损失函数与定位损失函数总和" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f9979ea320ba4cad13f0d4f7d51f7c73/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-08T08:56:00+08:00" />
<meta property="article:modified_time" content="2020-05-08T08:56:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">简单并全面地了解目标检测之fast RCNN(ROI Pooling、ROI Align和Precise ROI Pooling)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>目标检测之<a href="https://arxiv.org/pdf/1504.08083.pdf" rel="nofollow">fast RCNN</a>[2015 Ross]</p> 
<p><img src="https://images2.imgbox.com/c6/a7/3D00ftnx_o.png" alt="faster-rcnn_kaikeba.md.png"><br></p> 
<p>ROI： region of interest(类似region proposal)</p> 
<p><em><strong>B0.Region Proposal:和RCNN一样</strong></em></p> 
<ul><li>2k每张图ROI，为每个ROI记录下坐标</li></ul> 
<p><em><strong>B1 &amp; 2.卷积Convolution &amp; 投影Projection</strong></em></p> 
<ul><li>对一张图只做一次卷积，每个ROI记录下的坐标投射到特征图上</li><li>比如使用backbone网络结构为VGG，4 max pooling, 即坐标 /16</li><li>得到2k个feature map zone特征图区域块</li></ul> 
<p><em><strong><a href="https://blog.csdn.net/weixin_38056657/article/details/80399727">B3.ROI pooling layer</a></strong></em></p> 
<ul><li>参考了SSP(Spatial pyramid pooling) Net 空间金字塔池化，把不同尺寸的图片resize到相同尺寸，并且保留他的空间位置信息</li><li>处理方式类似于resize，把不同大小特征图变成同样大小特征图</li><li>原理 
  <ul><li>每个特征图中大小不一样的ROI做一个网格划分，网格划分(grid)固定大小,并且在每个grid上面做一个max pooling</li><li>所以不同大小的特征图(feature map)可以转换到相同大小的特征图</li><li><a href="https://deepsense.ai/region-of-interest-pooling-explained/" rel="nofollow">RoI为7×5，输出为2×2尺寸的ROI Pooling举例</a><br><br> <img src="https://images2.imgbox.com/51/e0/YawETUML_o.gif" alt="roi_pooling-1.gif"><br></li></ul> </li><li>训练细节 
  <ul><li>batchsize = 2;64RoIs/image -&gt; 128 proposals(从2k个region proposal中按一定方式选出来(比如按大于指定阈值…));</li><li>1/4 pos(正样本) &amp; 3/4 neg(负样本)</li><li>IOU&gt;0.5 pos, [0.1, 0.5] neg, [0,0.1]hard neg</li><li>训练时正负样本按1:3比例，测试用负难样本，如果有错误情况，用负难样本重新训练</li></ul> </li><li>问题 
  <ul><li>cnn中和ROI pooling中加起来pooling(取整)较多，损失像素点较多，当ROI较小时，相对损失的特征就更多了，fast rcnn对小目标检测不太友好</li></ul> </li></ul> 
<p><em><strong>B4 FC layers</strong></em></p> 
<p>FC层中参数较多，可考虑SVD加速(一般不会,矩阵乘法加速效果更好)</p> 
<p><em><strong>B5 Multi-task Loss多任务损失函数</strong></em></p> 
<ul><li>分类：n+1(需考虑背景), softmax + cross entropy, L(cls)</li><li>定位：offset(用偏置项做预测), smoothL1, L(loc) 
  <ul><li>注意: Smoooth L2会使得小的更小，大的更大</li></ul> </li><li>损失函数为分类损失函数与定位损失函数总和<br> <img src="https://images2.imgbox.com/99/34/MYGArOFP_o.png" alt="faster-rcnn_loss.md.png"><br> 
  <ul><li>其中p：预测类别得分，u：真实类别，t^u:生成边界框， t^v:真实标记边界框</li></ul> </li></ul> 
<p><em><strong>ROI Pooling重新思考</strong></em></p> 
<p><img src="https://images2.imgbox.com/f7/03/wcAsfEdL_o.png" alt="roi_pooling.md.png"></p> 
<ol><li> <p>针对上图, <a href="https://www.cnblogs.com/codehome/p/10910180.html" rel="nofollow"><em><strong>两次量化</strong></em></a>的解释</p> 
  <ul><li>Conv layers使用的是VGG16，feat_stride=32(即表示，经过网络层后图片缩小为原图的1/32),原图800 * 800,最后一层特征图feature map大小:25 * 25</li><li>假定原图中有一region proposal，大小为665 * 665，这样，映射到特征图中的大小：665/32=20.78,即20.78 * 20.78，Caffe的Roi Pooling的C++源码，在计算的时候会进行取整操作，于是，进行所谓的<font color="red">第一次量化</font>，即映射的特征图大小为20 * 20，该层特征图上0.1个像素的偏差，缩放到原图就是3.2个像素；那么0.8的偏差，在原图上就是接近30个像素点的差别。</li><li>假定pooled_w =7, pooled_h=7,即pooling后固定成7 * 7大小的特征图，所以，将上面在 feature map上映射的20 * 20的 region proposal划分成49个同等大小的小区域，每个小区域的大小20/7=2.86,即2.86 * 2.86，此时，进行<font color="red">第二次量化</font>，故小区域大小变成2 * 2</li><li>每个2 * 2的小区域里，取出其中最大的像素值，作为这一个区域的‘代表’，这样，49个小区域就输出49个像素值，组成7 * 7大小的feature map</li><li>总结，所以，通过上面可以看出，经过两次量化，即将浮点数取整，原本在特征图上映射的20 * 20大小的region proposal，偏差成大小为7 * 7的，这样的像素偏差势必会对后层的回归定位产生影响</li></ul> </li><li> <p>扩展性思考：</p> 
  <ul><li>投影坐标方面：可采用padding, 向上取整</li><li>ROI pooling：</li></ul> </li></ol> 
<p><em><strong><a href="https://arxiv.org/abs/1703.06870v3" rel="nofollow">ROI Align</a>[2017 Kaiming]</strong></em></p> 
<blockquote> 
 <p>思路，完成下图2 * 2采样举例</p> 
</blockquote> 
<ol><li> <p>坐标投射出现小数，保留小数，不取整</p> </li><li> <p>网格划分(比如变成2 * 2）,把RoI换成2 * 2的网格，如下图一</p> </li><li> <p>设置超参数N为4，则每个bin内部在划分为4个小矩形，如下图二</p> 
  <ul><li>bin指的是RoI网格划分之后的区域，如下图一中红框别绿线划分为4个bin</li><li>需要求得每个bin的max值，即求得每个小矩形的max值中最大的max值</li></ul> </li><li> <p>求得bin中每个小矩形取中心点位置的特征点，代表该小矩形，如图三的粉红色的点；具体取值规则为将正中间附近的***四个点***利用<a href="https://www.cnblogs.com/codehome/p/10910180.html" rel="nofollow"><em><strong>双线性差值</strong></em></a>求得</p> </li><li> <p>每个bin中所有小矩形取最值，代表该bin的值，如图四的黄色的点；黄色的点构成了图中2 * 2的采样结果,完成了ROI Align Pooling的实现</p> </li></ol> 
<p><img src="https://images2.imgbox.com/c4/8d/uYnYBh66_o.png" alt="ROI-align-Pooling.png"></p> 
<p><a href="https://zhuanlan.zhihu.com/p/59692298" rel="nofollow">ROI pooling反向传播</a><br> <img src="https://images2.imgbox.com/a5/e5/HwW5Xx2Q_o.png" alt="roi-align-bp.png"></p> 
<blockquote> 
 <p>虽然解决了两次量化的问题，解决了小目标的像素损失问题，但也引来了以下问题：</p> 
</blockquote> 
<ol><li>需要提前指定超参数N</li><li>并不是所有的特征点都贡献进来了，每个bin的取每个区块的值只和周围四个点有关系，如果bin比较大，特征点比较多，特征图的信息没有用全</li></ol> 
<p><em><strong><a href="https://arxiv.org/pdf/1807.11590.pdf" rel="nofollow">Precise ROI Pooling</a>[2018 IoU-Net]</strong></em></p> 
<blockquote> 
 <p>思路，完成下图2 * 2采样举例</p> 
</blockquote> 
<ol><li>坐标投射出现小数，保留小数，不取整</li><li>网格划分(比如变成2 * 2）,把RoI换成2 * 2的网格，如下图一第一张图</li><li>通过周围四个点利用<a href="https://www.cnblogs.com/codehome/p/10910180.html" rel="nofollow"><em><strong>双线性差值</strong></em></a>求得每个偏移的特征点的值，如下图一第二张图的红色的点</li><li>对每个bin里面的值做PrPool,如图三，其实就是Average Pooling, f(x,y)中x,y由双线性差值求得，如图二所示</li></ol> 
<p>图一<br><br> <img src="https://images2.imgbox.com/ff/96/0Zivos9b_o.png" alt="Precise-ROI-Pooling.png"></p> 
<p>图二<br></p> 
<p><img src="https://images2.imgbox.com/cf/f9/N8AHOMuM_o.png" alt="Precise-ROI-fxy.png"></p> 
<p>图三 <br><br> <img src="https://images2.imgbox.com/a4/99/Dz6smar2_o.png" alt="Precise-ROI-Pooling-math.png"></p> 
<blockquote> 
 <p>Precise-ROI-Pooling反向传播<br></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/f5/06/Q8Z84NgF_o.png" alt="Precise-ROI-Pooling-bp.png"></p> 
<h4><a id="_113"></a>最后</h4> 
<p><a href="http://www.yubajin.cn/2020/05/03/%E7%9B%AE%E6%A0%87%E6%A3%80%E6%B5%8B%EF%BC%88%E4%B8%8A%EF%BC%89/" rel="nofollow">原文链接</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5db849380df71fb85a905592855e24b5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Github 上传和删除文件夹</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9fc5cb1c1130ce77fbe622f14db716ae/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Redis的跳跃表底层原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>