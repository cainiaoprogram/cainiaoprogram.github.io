<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>推荐一个开源的AT命令解析模块 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="推荐一个开源的AT命令解析模块" />
<meta property="og:description" content="介绍 一种AT命令通信解析模块,支持裸机(at_chat)和OS版本(at)。适用于modem、WIFI模块、蓝牙通信。
软件架构 • at_chat.c at_chat.h list.h
用于无OS版本，使用链式队列及异步回调方式处理AT命令收发，支持URC处理、自定义命令发送与解析作业。
• at.c at.h at_util.h comdef.h
用于OS版本, 使用前需要根据at_util.h规定的操作系统相关的接口进行移植,如提供信号量操作、任务延时等操作。
使用说明 at_chat 模块(无OS) 基本概念 at_chat 模块使用链式队列进行管理，包含2条链表，空闲链表和就绪链表。它们的每一个基本工作单元称为一个作业项，对于将要执行的命令都会放到就绪链表中，命令执行完成之后由空闲链表来进行回收，作业项的定义如下：
/*AT作业项*/ typedef struct { unsigned int state : 3; unsigned int type : 3; /* 作业类型*/ unsigned int abort : 1; void *param; /* 通用参数*/ void *info; /* 通用信息指针*/ struct list_head node; /* 链表结点*/ }at_item_t; 作业是AT控制器定义时固定分配的，没有使用动态内存，默认支持10个作业项，即同时可以允许10个AT命令排队等待处理。
基本接口与描述 • at_send_singlline, 发送单行命令，默认等待OK响应，超时3S
• at_send_multiline, 多行命令，默认等待OK响应，超时3S
• at_do_cmd，支持自定义发送格式与接收匹配串
• at_do_work，支持自定义发送与接收解析
效果演示 详细使用可以参考Demo程序wifi_task." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2ff940bb53ed73251cb8b3b9f2439b3c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-08T12:00:54+08:00" />
<meta property="article:modified_time" content="2024-01-08T12:00:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">推荐一个开源的AT命令解析模块</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <h3>介绍</h3> 
 <p style="text-align:justify;">一种AT命令通信解析模块,支持裸机(at_chat)和OS版本(at)。适用于modem、WIFI模块、蓝牙通信。</p> 
 <h3>软件架构</h3> 
 <h3></h3> 
 <ul><li><p style="text-align:justify;">• at_chat.c at_chat.h list.h</p></li></ul> 
 <p style="text-align:justify;">用于无OS版本，使用链式队列及异步回调方式处理AT命令收发，支持URC处理、自定义命令发送与解析作业。</p> 
 <ul><li><p style="text-align:justify;">• at.c at.h at_util.h comdef.h</p></li></ul> 
 <p style="text-align:justify;">用于OS版本, 使用前需要根据at_util.h规定的操作系统相关的接口进行移植,如提供信号量操作、任务延时等操作。</p> 
 <h3>使用说明</h3> 
 <h4>at_chat 模块(无OS)</h4> 
 <h5>基本概念</h5> 
 <p style="text-align:justify;">at_chat 模块使用链式队列进行管理，包含2条链表，空闲链表和就绪链表。它们的每一个基本工作单元称为一个作业项，对于将要执行的命令都会放到就绪链表中，命令执行完成之后由空闲链表来进行回收，作业项的定义如下：</p> 
 <pre class="has"><code class="language-go">/*AT作业项*/
typedef struct {
    unsigned int  state : 3;
    unsigned int  type  : 3;                                 /* 作业类型*/
    unsigned int  abort : 1; 
    void          *param;                                    /* 通用参数*/
    void          *info;                                     /* 通用信息指针*/
    struct list_head node;                                   /* 链表结点*/
}at_item_t;</code></pre> 
 <p style="text-align:justify;">作业是AT控制器定义时固定分配的，没有使用动态内存，默认支持10个作业项，即同时可以允许10个AT命令排队等待处理。</p> 
 <h5>基本接口与描述</h5> 
 <ul><li><p style="text-align:justify;">• at_send_singlline, 发送单行命令，默认等待OK响应，超时3S</p></li><li><p style="text-align:justify;">• at_send_multiline, 多行命令，默认等待OK响应，超时3S</p></li><li><p style="text-align:justify;">• at_do_cmd，支持自定义发送格式与接收匹配串</p></li><li><p style="text-align:justify;">• at_do_work，支持自定义发送与接收解析</p></li></ul> 
 <h5>效果演示</h5> 
 <p style="text-align:justify;">详细使用可以参考Demo程序wifi_task.c模块</p> 
 <img title="null" src="https://images2.imgbox.com/9c/1c/LGPmslXg_o.jpg" alt="0bf42e1db45cb20a26ba3caf0e4317c0.jpeg"> 
 <figcaption>
   m169 wifi模组通信效果图 
 </figcaption> 
 <h5>使用步骤</h5> 
 <p style="text-align:justify;">1.定义AT控制器及通信适配器接口</p> 
 <pre class="has"><code class="language-go">/* 
 * @brief   定义AT控制器
 */
static at_obj_t at;

const at_adapter_t adap = {  //AT适配器接口
    //适配GPRS模块的串口读写接口
    .write       = uart_write,
    .read        = uart_read
    ...
};</code></pre> 
 <ol><li><p style="text-align:justify;">1. 初始化AT控制器并放入任务中轮询（考虑到处理实时性，建议20ms以下）</p></li></ol> 
 <pre class="has"><code class="language-go">/* 
 * @brief    wifi初始化
 */
void wifi_init(void)
{
    at_obj_init(&amp;at, &amp;adap);
    /*...*/
}driver_init("wifi", wifi_init); 

/* 
 * @brief    wifi任务(10ms 轮询1次)
 */
void wifi_task(void)
{
    at_poll_task(&amp;at);
}task_register("wifi", wifi_task, 10);</code></pre> 
 <h5>例子演示</h5> 
 <pre class="has"><code class="language-go">//WIFI IO配置命令
=&gt; AT+GPIO_TEST_EN=1\r\n

&lt;= OK\r\n</code></pre> 
 <pre class="has"><code class="language-go">/**
 * @brief AT执行回调处理程序
 */
static void test_gpio_callback(at_response_t *r)
{
    if (r-&gt;ret == AT_RET_OK ) {
        printf("Execute successfully\r\n");
    } else {
        printf("Execute failure\r\n");
    }
}
at_send_singlline(&amp;at, test_gpio_callback, "AT+GPIO_TEST_EN=1");</code></pre> 
 <h4>at 模块(OS版本)</h4> 
 <p style="text-align:justify;">由于AT命令通信是一个比较复杂的过程，对于没有OS的环境下处理难度比较大，也很绕,对于不允许阻塞程序，除了使用状态与+回调没有其它更好的办法，所以推荐使用这个模块</p> 
 <h5>基本接口与描述</h5> 
 <ul><li><p style="text-align:justify;">• at_do_cmd，执行AT命令，可以通过这个接口进一步封装出一常用的单行命令、多行命令。</p></li><li><p style="text-align:justify;">• at_split_respond_lines，命令响应分割器。</p></li><li><p style="text-align:justify;">• at_do_work，适用于发送组合命令，如GPRS模组发送短信或者发送socket数据需要等待"&lt;"或者"CONNECT"提示符，可以通过这个接口自定义收发。</p></li></ul> 
 <h5>使用步骤</h5> 
 <p style="text-align:justify;">1.定义AT控制器、通信适配器接口(包含URC回调函数表，接口缓冲区URC)</p> 
 <pre class="has"><code class="language-go">static at_obj_t at;          //定义AT控制器对象

static char urc_buf[128];    //URC主动上报缓冲区

utc_item_t utc_tbl[] = {     //定义URC表
    "+CSQ: ", csq_updated_handler
}

const at_adapter_t adap = {  //AT适配器接口
    .urc_buf     = urc_buf,
    .urc_bufsize = sizeof(urc_buf),
    .utc_tbl     = utc_tbl,
    .urc_tbl_count = sizeof(utc_tbl) / sizeof(utc_item_t), 
    //debug调试接口
    .debug       = at_debug, 
    //适配GPRS模块的串口读写接口
    .write       = uart_write,
    .read        = uart_read
};</code></pre> 
 <p style="text-align:justify;">2.创建AT控制器并创建轮询处理线程</p> 
 <pre class="has"><code class="language-go">void at_thread(void)
{
    at_obj_create(&amp;at, &amp;adap);
    while (1) {        
        at_process(&amp;at);
    }
}</code></pre> 
 <h5>例子演示</h5> 
 <h5>例子1(查询无线模组信号质量)</h5> 
 <pre class="has"><code class="language-go">/** at_do_cmd 接口使用演示
    查询GPRS模组信号质量命令
    =&gt; AT+CSQ
    
    &lt;= +CSQ: 24, 0
    &lt;= OK
*/

/* 
 * @brief    获取csq值
 */ 
bool read_csq_value(at_obj_t *at, int *rssi, int *error_rate)
{
    //接收缓冲区
    unsigned char recvbuf[32];
    //AT应答
    at_respond_t r = {"OK", recvbuf, sizeof(recvbuf), 3000};
    //
    if (at_do_cmd(at, &amp;r, "AT+CSQ") != AT_RET_OK)
        return false;
    //提取出响应数据
    return (sscanf(recv, "%*[^+]+CSQ: %d,%d", rssi, error_rate) == 2);

}</code></pre> 
 <h5>例子2(发送TCP数据)</h5> 
 <pre class="has"><code class="language-go">/** at_do_work 接口使用演示
    参考自hl8518模组Socket 数据发送命令
    =&gt; AT+KTCPSND=&lt;session_id&gt;,&lt;ndata&gt;
    
    &lt;= CONNECT
    
    =&gt; &lt;data&gt;
    
    &lt;= OK
*/

/*
 * @brief       数据发送处理
 * @retval      none
 */
static bool socket_send_handler(at_work_ctx_t *e)
{
    struct socket_info *i = (struct socket_info *)e-&gt;params;
    struct ril_sock *s    = i-&gt;s;
    
    if (s-&gt;type == SOCK_TYPE_TCP)
        e-&gt;printf(e, "AT+KTCPSND=%d,%d", s-&gt;session, i-&gt;bufsize);
    else
        e-&gt;printf(e, "AT+KUDPSND=%d,%s,%d,%d",s-&gt;session, s-&gt;host, 
        s-&gt;port, i-&gt;bufsize);        

    if (e-&gt;wait_resp(e, "CONNECT", 5000) != AT_RET_OK) {      //等待提示符
       goto Error;
    }         
    e-&gt;write(i-&gt;buf, i-&gt;bufsize);                             //发送数据
    
    e-&gt;write("--EOF--Pattern--", strlen("--EOF--Pattern--")); //发送结束符

    if (e-&gt;wait_resp(e, "OK", 5000) == AT_RET_OK)
        return true;
    else {   
Error:
        e-&gt;write("--EOF--Pattern--", strlen("--EOF--Pattern--"));
        return false;
    }
}

/**
 * @brief       socket 数据发送
 * @param[in]   s   - socket
 * @param[in]   buf - 数据缓冲区
 * @param[in]   len - 缓冲区长度
 */
static bool hl8518_sock_send(ril_obj_t *r, struct ril_sock *s, const void *buf, 
                       unsigned int len)
{
    struct socket_info info = {s, (unsigned char *)buf, len, 0};
    if (len == 0)
        return false;       
    return at_do_work(&amp;r-&gt;at, (at_work)socket_send_handler, &amp;info);
}</code></pre> 
 <p style="text-align:justify;"><em>来源：https://toscode.gitee.com/smtian/AT-Command</em></p> 
 <p style="text-align:left;"><em>文章来源于网络，版权归原作者所有，如有侵权，请联系删除。</em></p> 
 <p style="text-align:center;"><strong><strong>-END-</strong></strong></p> 
 <hr> 
 <p style="text-align:center;"><strong><strong>往期推荐：点击链接即可跳转阅读</strong></strong></p> 
 <p style="text-align:center;"><strong><strong><a href="" rel="nofollow">科普 | 什么是DSP技术？</a><br></strong></strong></p> 
 <p style="text-align:center;"><strong><strong><a href="" rel="nofollow">30年前的IDE，堪称上古神器</a><br></strong></strong></p> 
 <p></p> 
 <p><strong><strong>↓↓<strong>↓点击关注</strong></strong>↓↓↓</strong></p> 
 <p><img src="https://images2.imgbox.com/d3/e3/ITgavleI_o.png" alt="17cf55865c3f50df338e20d703098be0.png"></p> 
 <p>你点的每个<strong>好看</strong>，我都认真当成了<strong>喜欢</strong></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a31beb291395b4b1f21365282faf4594/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">protobuf 学习笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b5393fcb1e684f9aa2854bc76bd3d93a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL8.0.18通过data文件夹进行数据库迁移（直接复制文件）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>