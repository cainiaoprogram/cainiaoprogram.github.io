<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Frida-API之Java层Hook - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Frida-API之Java层Hook" />
<meta property="og:description" content="参考文章 FRIDA-API使用篇：Java、Interceptor、NativePointer(Function/Callback)使用方法及示例-安全客 - 安全资讯平台 (anquanke.com)
JavaScript API | Frida • A world-class dynamic instrumentation toolkit
文章目录 参考文章1、Java.available2、Java.androidVersion3、附加调用Java.perform4、获取类Java.use5、Hook静态方法和实例方法、修改函数参数和返回值6、Hook构造方法：$init7、Hook重载方法8、扫描实例类Java.choose9、主动调用10、获取和修改类的字段11、Hook内部类与匿名类12、Hook枚举类13、枚举所有类14、枚举类的所有方法15、Hook类的所有方法16、枚举所有类加载器17、类型转换器Java.cast18、定义任意数组类型Java.array19、注册类Java.registerClass(spec)20、注入dex21、写文件22、全局上下文环境获取23、打印函数堆栈24、Hook只在指定函数内生效25、Hook定位接口/抽象类的实现类26、Hook动态加载的Dex27、注意事项 1、Java.available 判断当前进程是否加载了JavaVM，Dalvik或ART虚拟机
function frida_Java() { Java.perform(function () { if(Java.available) { console.log(&#34;hello java vm&#34;); }else{ console.log(&#34;error&#34;); } }); } setImmediate(frida_Java);//setImmediate(回调方法, 参数1,参数2,...) 异步任务，立即执行 输出如下： hello java vm 2、Java.androidVersion 显示android系统版本号
function frida_Java() { Java.perform(function () { if(Java.available) { console.log(&#34;&#34;,Java.androidVersion); }else{ console.log(&#34;error&#34;); } }); } setImmediate(frida_Java); 输出如下： 10 3、附加调用Java.perform 主要用于当前线程附加到Java VM并且调用fn方法它也有一个好兄弟：Java.performNow(fn)
4、获取类Java.use 构造实例：$new实例的一些属性 .$class == .getClass().$className == ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9e7a96e8382cd25eb0354caa6b7af095/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-13T19:12:11+08:00" />
<meta property="article:modified_time" content="2023-08-13T19:12:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Frida-API之Java层Hook</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>参考文章</h3> 
<blockquote> 
 <p><a href="https://www.anquanke.com/post/id/195869#h3-7" rel="nofollow">FRIDA-API使用篇：Java、Interceptor、NativePointer(Function/Callback)使用方法及示例-安全客 - 安全资讯平台 (anquanke.com)</a></p> 
 <p><a href="https://frida.re/docs/javascript-api/" rel="nofollow">JavaScript API | Frida • A world-class dynamic instrumentation toolkit</a></p> 
</blockquote> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_0" rel="nofollow">参考文章</a></li><li><ul><li><a href="#1Javaavailable_7" rel="nofollow">1、Java.available</a></li><li><a href="#2JavaandroidVersion_28" rel="nofollow">2、Java.androidVersion</a></li><li><a href="#3Javaperform_49" rel="nofollow">3、附加调用Java.perform</a></li><li><a href="#4Javause_53" rel="nofollow">4、获取类Java.use</a></li><li><a href="#5Hook_62" rel="nofollow">5、Hook静态方法和实例方法、修改函数参数和返回值</a></li><li><a href="#6Hookinit_72" rel="nofollow">6、Hook构造方法：$init</a></li><li><a href="#7Hook_81" rel="nofollow">7、Hook重载方法</a></li><li><a href="#8Javachoose_91" rel="nofollow">8、扫描实例类Java.choose</a></li><li><a href="#9_112" rel="nofollow">9、主动调用</a></li><li><a href="#10_119" rel="nofollow">10、获取和修改类的字段</a></li><li><a href="#11Hook_128" rel="nofollow">11、Hook内部类与匿名类</a></li><li><a href="#12Hook_137" rel="nofollow">12、Hook枚举类</a></li><li><a href="#13_165" rel="nofollow">13、枚举所有类</a></li><li><a href="#14_202" rel="nofollow">14、枚举类的所有方法</a></li><li><a href="#15Hook_220" rel="nofollow">15、Hook类的所有方法</a></li><li><a href="#16_244" rel="nofollow">16、枚举所有类加载器</a></li><li><a href="#17Javacast_293" rel="nofollow">17、类型转换器Java.cast</a></li><li><a href="#18Javaarray_302" rel="nofollow">18、定义任意数组类型Java.array</a></li><li><a href="#19JavaregisterClassspec_323" rel="nofollow">19、注册类Java.registerClass(spec)</a></li><li><a href="#20dex_353" rel="nofollow">20、注入dex</a></li><li><a href="#21_362" rel="nofollow">21、写文件</a></li><li><a href="#22_375" rel="nofollow">22、全局上下文环境获取</a></li><li><a href="#23_389" rel="nofollow">23、打印函数堆栈</a></li><li><a href="#24Hook_402" rel="nofollow">24、Hook只在指定函数内生效</a></li><li><a href="#25Hook_437" rel="nofollow">25、Hook定位接口/抽象类的实现类</a></li><li><a href="#26HookDex_507" rel="nofollow">26、Hook动态加载的Dex</a></li><li><a href="#27_551" rel="nofollow">27、注意事项</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="1Javaavailable_7"></a>1、Java.available</h4> 
<p><strong>判断当前进程是否加载了<code>JavaVM，Dalvik</code>或<code>ART</code>虚拟机</strong></p> 
<pre><code class="prism language-JS">function frida_Java() {
    Java.perform(function () {
        if(Java.available)
        {
            console.log("hello java vm");
        }else{
            console.log("error");
        }
    });
}       
setImmediate(frida_Java);//setImmediate(回调方法, 参数1,参数2,...) 异步任务，立即执行

输出如下：
hello java vm
</code></pre> 
<h4><a id="2JavaandroidVersion_28"></a>2、Java.androidVersion</h4> 
<p><strong>显示android系统版本号</strong></p> 
<pre><code class="prism language-JS">function frida_Java() {
    Java.perform(function () {
        if(Java.available)
        {
            console.log("",Java.androidVersion);
        }else{
            console.log("error");
        }
    });
}       
setImmediate(frida_Java);

输出如下：
10
</code></pre> 
<h4><a id="3Javaperform_49"></a>3、附加调用Java.perform</h4> 
<p><strong>主要用于当前线程附加到<code>Java VM</code>并且调用<code>fn</code>方法它也有一个好兄弟：<code>Java.performNow(fn)</code></strong></p> 
<h4><a id="4Javause_53"></a>4、获取类Java.use</h4> 
<ol><li><strong>构造实例：$new</strong></li><li><strong>实例的一些属性</strong> 
  <ul><li><strong>.$class == .getClass()</strong></li><li><strong>.$className == .getClass().getName()</strong></li><li><strong>.$superClass == .getClass().getSuperclass()</strong></li><li>.$dispose 回收类</li></ul> </li></ol> 
<h4><a id="5Hook_62"></a>5、Hook静态方法和实例方法、修改函数参数和返回值</h4> 
<pre><code class="prism language-JS">let str=Java.use("java.lang.String");
str.toString.implementation=function () {
    console.log("HooktoString")
    return "修改值"
}
</code></pre> 
<h4><a id="6Hookinit_72"></a>6、Hook构造方法：$init</h4> 
<pre><code class="prism language-JS">Java.use("java.io.File").$init.overload("java.lang.String").implementation = function (path) {
    console.log("",path)
    return this.$init(path);
}
</code></pre> 
<h4><a id="7Hook_81"></a>7、Hook重载方法</h4> 
<ol><li> <p><strong>overload</strong></p> <p><strong>Java.use(className).方法名.overload(参数类型1,…).implementation</strong></p> </li><li> <p><strong>overloads</strong></p> <p><strong>Java.use(className).方法名.overloads返回重载函数数组</strong></p> </li></ol> 
<h4><a id="8Javachoose_91"></a>8、扫描实例类Java.choose</h4> 
<p><strong>用法Java.choose(“全类名”,回调对象)，在堆上查找实例化的对象</strong></p> 
<pre><code class="prism language-JS">function frida_Java(className) {
    Java.perform(function () {
        Java.choose(className,{
            onMatch:function (instance) {
                console.log("搜索到实例对象：",instance);
                return instance;
            },
            onComplete:function () {
                console.log("内存搜索完毕！");
            }
        });
    });
}
setImmediate(frida_Java,"com.android.settingslib.utils.PowerUtil");
</code></pre> 
<h4><a id="9_112"></a>9、主动调用</h4> 
<ol><li>静态方法：直接调用</li><li>实例方法 
  <ul><li>使用$new新建实例调用方法</li><li>使用<strong>Java.choose</strong>在内存中寻找实例，使用找到的实例调用方法</li></ul> </li></ol> 
<h4><a id="10_119"></a>10、获取和修改类的字段</h4> 
<p><strong>设置/获取字段的值需要"字段.value"</strong></p> 
<ol><li>静态字段：直接获取/修改</li><li>实例字段 
  <ul><li>使用$new新建实例获取/修改字段</li><li>使用<strong>Java.choose</strong>在内存中寻找实例，使用找到的实例获取/修改字段</li></ul> </li></ol> 
<h4><a id="11Hook_128"></a>11、Hook内部类与匿名类</h4> 
<ol><li>内部类 
  <ul><li>Java.use(“全类名$内部类名”)</li><li>Java.choose(“全类名$内部类名”,JSON对象)</li></ul> </li><li>匿名内部类 
  <ul><li>Java.use(’全类名$1‘)</li><li>Java.choose(“全类名$1”,JSON对象)</li></ul> </li></ol> 
<h4><a id="12Hook_137"></a>12、Hook枚举类</h4> 
<ol><li> <p>Java.use(‘枚举类路径’)</p> <p><strong>枚举类.values()：返回枚举类中所有的值</strong></p> <pre><code class="prism language-JS">let protocol=Java.use('okhttp3.Protolcol')
console.sole(protocol.values())
</code></pre> </li><li> <p>Java.choose(“枚举类路径”,JSON对象)</p> <p><strong>枚举对象.ordinal()：返回该枚举常量的索引</strong></p> <pre><code class="prism language-JS">Java.choose("okhttp3.Protolcol", {
    //枚举时调用
    onMatch:function(instance){
        //打印实例
        console.log(instance.ordinal());
    },
    //枚举完成后调用
    onComplete:function() {
        console.log("end")
    }});
</code></pre> </li></ol> 
<h4><a id="13_165"></a>13、枚举所有类</h4> 
<ol><li> <p>Java.enumerateLoadedClassesSync()</p> <p><strong>枚举当前加载的所有类，并返回string数组</strong></p> <pre><code class="prism language-JS">console.log(Java.enumerateLoadedClassesSync().join("\n"));
</code></pre> </li><li> <p>Java.enumerateLoadedClasses(callbacks)</p> <p>枚举当前加载的所有类信息，它有一个回调函数分别是<code>onMatch(每找到一次，执行一次)、onComplete(只执行一次，在搜索完成内存后)</code>函数</p> <pre><code class="prism language-JS">function frida_Java() {
    Java.perform(function () {
        //枚举当前加载的所有类
        Java.enumerateLoadedClasses({
            //每一次回调此函数时其参数className就是类的信息
            onMatch: function (className)
            {
                //输出类字符串
                console.log("",className);
            },
            //枚举完毕所有类之后的回调函数
            onComplete: function ()
            {
                //输出类字符串
                console.log("输出完毕");
            }
        });
    });
}
setImmediate(frida_Java);
</code></pre> </li></ol> 
<h4><a id="14_202"></a>14、枚举类的所有方法</h4> 
<p><strong>通过Java反射</strong></p> 
<pre><code class="prism language-JS">function frida_Java(className) {
    Java.perform(function () {
        let cn=Java.use(className);
        let methods=cn.class.getDeclaredMethods();
        for (let i = 0; i &lt; methods.length; i++) {//循环遍历所有方法
            let methodName = methods[i].getName();
            console.log("",methodName)
        }
    });
}
setImmediate(frida_Java,"com.android.settingslib.utils.PowerUtil");
</code></pre> 
<h4><a id="15Hook_220"></a>15、Hook类的所有方法</h4> 
<pre><code class="prism language-JS">function frida_Java(className) {
    Java.perform(function () {
        let cn=Java.use(className);
        let methods=cn.class.getDeclaredMethods();//cn.class：相当于Object.class   获取所有方法
        for (let i = 0; i &lt; methods.length; i++){//循环遍历所有方法
            let methodName=methods[i].getName();//获取方法名
            let loads=cn[methodName].overloads;//获取该方法的所有重载
            for (let j = 0; j &lt; loads.length; j++) {//遍历该方法的所有重载
                loads[j].implementation=function () {//Hook方法
                    let result=this[methodName].apply(this,arguments);
                    console.log('参数：'+JSON.stringify(arguments));
                    console.log('返回值：'+JSON.stringify(result));
                    return result;
                }
            }
        }
    });
}
setImmediate(frida_Java,"com.android.settingslib.utils.PowerUtil");
</code></pre> 
<h4><a id="16_244"></a>16、枚举所有类加载器</h4> 
<ol><li> <p>Java.enumerateClassLoadersSync()</p> <p><strong>枚举所有的ClassLoader，并返回Wrapper数组</strong></p> <pre><code class="prism language-JS">let loaders=Java.enumerateClassLoadersSync();
for (let i = 0; i &lt; loaders.length; i++) {
    try {
        Java.classFactory.loader = classloader;
        //Hook代码
    }catch (e) {
    }
}
</code></pre> </li><li> <p><strong>替换默认ClassLoader</strong></p> <pre><code class="prism language-JS">Java.classFactory.loader = classloader;
</code></pre> </li><li> <p>Java.enumerateClassLoaders(callbacks)</p> <p>举<code>Java VM</code>中存在的类加载器，它有一个回调函数分别是<code>onMatch(每找到一次，执行一次)、onComplete(只执行一次，在搜索完成内存后)</code>函数</p> <pre><code class="prism language-JS">function frida_Java() {
    Java.perform(function () {
        Java.enumerateClassLoaders({
            onMatch: function (classloader) {
                console.log(JSON.stringify(classloader));
                try {
                    //替换默认classLoader
                    Java.classFactory.loader = classloader;
                    //Hook代码
                } catch (e) {
                }
            },
            onComplete: function () {
                console.log("内存搜索完毕！");
            }
        });
    });
}
setImmediate(frida_Java);
</code></pre> </li></ol> 
<h4><a id="17Javacast_293"></a>17、类型转换器Java.cast</h4> 
<p><strong><code>Java.cast(handle, klass)</code>，handle即对象实例，klass是要强转成的句柄，从Java.use获取。</strong></p> 
<pre><code class="prism language-JS">//此类包装器还具有用于获取其类的包装器的类属性，以及用于获取其类名的字符串表示的$className属性，通常在拦截so层时会使用此函数将jstring、jarray等等转换之后查看其值。
Java.cast(map,Java.use("java.util.HashMap"))//将map实例对象强转成HashMap对象
</code></pre> 
<h4><a id="18Javaarray_302"></a>18、定义任意数组类型Java.array</h4> 
<p><strong>使用Java.array(“类型”,[实例对象,实例对象])</strong></p> 
<pre><code class="prism language-JS">function frida_Java() {
    Java.perform(function () {
        let name=Java.use('java.lang.String').$new('Jack')
        let age=Java.use('java.lang.Integer').$new(18)
        Java.array('java.lang.Object',[name,age])
        /**
         * 可省略描述符 [name,age] == Java.array('java.lang.Object',[name,age])
         * 可变参数本质上就是数组，按数组处理即可
         * 基本数据类型数据要使用其包装类构造 Java.use('java.lang.Integer').$new(18)
         * 类型可以是"java.lang.Object"，也可以是"Ljava/lang/Object;"
         */
    });
}
setImmediate(frida_Java);
</code></pre> 
<h4><a id="19JavaregisterClassspec_323"></a>19、注册类Java.registerClass(spec)</h4> 
<ol><li> <p><code>Java.registerClass</code>：创建一个新的<code>Java</code>类并返回一个包装器</p> 
  <ul><li><code>name</code>：指定类名称的字符串。</li><li><code>superClass</code>：（可选）父类。要从 <code>java.lang.Objec</code>t 继承的省略。</li><li><code>implements</code>：（可选）由此类实现的接口数组。</li><li><code>fields</code>：（可选）对象，指定要公开的每个字段的名称和类型。</li><li><code>methods</code>：（可选）对象，指定要实现的方法。</li></ul> <pre><code class="prism language-JS">function frida_Java() {
    Java.perform(function () {
        //注册一个目标进程中的类，返回的是一个类对象
        var r0ysue = Java.registerClass({
            name: 'com.roysue.roysueapplication',
            implements:[Java.use('java.lang.Runnable')],
            methods:{
                run:function () {
                    console.log('Thread Starting...')
                }
            }
        });
        Java.use('java.lang.Thread').$new(r0ysue.$new()).start()//开启一个线程
    });
}

setImmediate(frida_Java);
</code></pre> </li></ol> 
<h4><a id="20dex_353"></a>20、注入dex</h4> 
<p><strong>使用Java.openClassFile(“dex路径”).load()</strong></p> 
<pre><code class="prism language-JS">//加载Dex文件，相当于new DexClassLoader(...)
Java.openClassFile("/data/local/tmp/classes.dex").load()
</code></pre> 
<h4><a id="21_362"></a>21、写文件</h4> 
<pre><code class="prism language-JS">function writeToFile(filePath,data) {
    Java.perform(function () {
        let ios=new File(filePath,'w');
        ios.write(data);
        ios.flush();
        ios.close();
    });
}
</code></pre> 
<h4><a id="22_375"></a>22、全局上下文环境获取</h4> 
<pre><code class="prism language-JS">function getApplicationContext() {
    //获取Application实例对象
    let activityThread=Java.use("android.app.ActivityThread");
    let application=activityThread.currentApplication();
    //获取context
    // let context=application.getBaseContext();
    let context=application.getApplicationContext();
    return context;
}
</code></pre> 
<h4><a id="23_389"></a>23、打印函数堆栈</h4> 
<pre><code class="prism language-JS">function showStacks() {
    console.log(
        Java.use("android.util.Log")
            .getStackTraceString(
                Java.use("java.lang.Throwable").$new()
            )
    );
}
</code></pre> 
<h4><a id="24Hook_402"></a>24、Hook只在指定函数内生效</h4> 
<ol><li> <p>步骤</p> 
  <ol><li> <p>Hook指定函数</p> </li><li> <p>在指定函数内Hook要生效的函数</p> </li><li> <p>在指定函数结束前，将要生效的函数Hook赋值null</p> <p><strong>类名.方法名.implementation=null</strong></p> </li></ol> </li><li> <p>代码</p> <pre><code class="prism language-JS">function makeHookMethodInSpecifiedFunction(specifiedClass,specifiedMethod,className,methodName) {
    Java.perform(function () {
        //Hook指定函数
        let specifiedClazz=Java.use(specifiedClass);
        specifiedClazz[specifiedMethod].implementation=function () {
            console.log("指定的Hook函数生效");
            //Hook 要Hook的函数
            let clazz=Java.use(className);
            clazz[methodName].implementation=function () {
                console.log("要Hook的函数生效");
                return this[methodName](arguments);
            }
            //关闭要Hook的函数
            clazz[methodName].implementation=null;
            return this[specifiedMethod](arguments);
        }
    });
}
</code></pre> </li></ol> 
<h4><a id="25Hook_437"></a>25、Hook定位接口/抽象类的实现类</h4> 
<ol><li> <p>定位接口的实现类</p> 
  <ol><li>枚举所有类</li><li>获取类的所有接口</li><li>遍历接口过滤符合条件的类</li></ol> </li><li> <p>定位抽象类的实现类</p> 
  <ol><li>枚举所有类</li><li>获取类的父类</li><li>遍历父类过滤符合条件的类</li></ol> </li><li> <p>代码</p> <pre><code class="prism language-JS">//Hook定位接口/抽象类的实现类：className是接口全路径或抽象类全路径   type:0表示接口、1表示抽象类
function HookLocateInterfaceOrAbstract(superClassName,type) {
    Java.perform(function () {
        if (type===0){//接口
            try {
                //1.遍历类
                let classes=Java.enumerateLoadedClassesSync();
                for (let i = 0; i &lt; classes.length; i++) {
                    //2.获取类的所有接口
                    let name=classes[i];
                    let clazz=Java.use(name);
                    let interfaces=clazz.class.getInterfaces();
                    //3.遍历接口
                    for (let j = 0; j &lt; interfaces.length; j++) {
                        //4.获取接口类名
                        let interClass=interfaces[j];
                        let interName=interClass.getName();
                        //5.过滤
                        if (interName==superClassName){
                            //输出实现类名
                            console.log(clazz.class.getName());
                        }
                    }
                }
            }catch (e) {
            }
        }else if (type===1){//抽象类
            //1.遍历类
            Java.enumerateLoadedClasses({
                onMatch:function (className) {
                    try {
                        //2.获取类的父类
                        let clazz=Java.use(className);
                        let superClass=clazz.class.getSuperclass();
                        //3.获取父类名
                        let superName=superClass.getName();
                        //4.过滤
                        if (superName==superClassName){
                            //输出实现类名
                            console.log(className);
                        }
                    }catch (e){
                    }
                },
                onComplete:function () {
                    console.log("内存搜索完毕！");
                }
            });
        }
    });
}
</code></pre> </li></ol> 
<h4><a id="26HookDex_507"></a>26、Hook动态加载的Dex</h4> 
<ol><li> <p>Java.enumerateClassLoaders</p> <pre><code class="prism language-JS">onMatch:function (classloader) {
    try {
        Java.classFactory.loader=classloader;
        //Hook 代码
    }catch (e) {
    }
}
</code></pre> </li><li> <p>Java.enumerateClassLoadersSync()</p> <pre><code class="prism language-JS">for (let i = 0; i &lt; loaders.length; i++) {
    try {
        Java.classFactory.loader = classloader;
        //Hook代码
    }catch (e) {
    }
}
</code></pre> </li><li> <p>Hook DexClassLoader.loadClass</p> <pre><code class="prism language-JS">function HookDexClassLoaderLoadClass() {
    Java.perform(function () {
        let loader=Java.use("dalvik.system.DexClassLoader");
        loader.loadClass.overload("java.lang.String").implementation=function (className) {
            try {
                Java.classFactory.loader=this;
                //Hook代码   
            }catch (e) {
            }
            return this.loadClass(className);
        }
    });
}
</code></pre> </li></ol> 
<h4><a id="27_551"></a>27、注意事项</h4> 
<ul><li> <p>Java类型对象调用Java方法，js类型对象调用js方法</p> </li><li> <p>frida会自动处理Java和js字符串的相互转换</p> </li><li> <p><strong>Hook属性字段时，设置/获取字段的值需要"字段.value"</strong></p> </li><li> <p><strong>定义变量时，尽量使用let而非var</strong></p> <p>var是全局变量，在遍历Hook函数时，很容易导致最后返回方法时，方法名与变量名对不上，导致Hook出错</p> </li><li> <p><strong>Hook函数中的"this"指的是Java.use获取的对象</strong></p> </li><li> <p><strong>this.方法名.apply(this,arguments)</strong></p> <p>遍历重载函数时，可用此返回</p> </li><li> <p><strong>Java.use获得的只是句柄，若需要对象，则使用句柄.$new()。若需要class字节码，则使用句柄.class</strong></p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/52f21addc0548c630838bb1a1f356bf5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">并查集的原理与实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/44b9f57bbd71731d083b743482bb3f5e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">两个数组的交集-C语言/Java</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>