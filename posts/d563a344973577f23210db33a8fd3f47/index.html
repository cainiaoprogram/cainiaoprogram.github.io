<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Seata分布式事务管理框架 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Seata分布式事务管理框架" />
<meta property="og:description" content="目录
什么是分布式事务问题
CAP定理
BASE理论
解决分布式事务问题的思路
Seata框架 -- 介绍
Seata框架 -- TC事务协调者的部署
Seata框架 -- XA模式
Seata框架 -- AT模式
Seata框架 -- AT模式 -- 脏读解决方案
Seata框架 -- TCC模式
Seata框架 -- SAGA模式
四种模式的对比
什么是分布式事务问题 在分布式架构中,一般会有很多微服务与数据源,当程序对不同的微服务或数据源进行业务操作的时候,就需要所有的操作保证业务的原子性, 而不同的微服务有可能会出现问题而导致事务问题出现
CAP定理 CAP定理是1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。
而这三个指标不可能同时做到。这个结论就叫做 CAP 定理。 Consistency（一致性）:
用户访问分布式系统中的任意节点，得到的数据必须一致。
Availability（可用性）:
用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝。
Partition tolerance （分区容错性）:
因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。在集群出现分区时，整个系统也要持续对外提供服务
为什么说CAP定理不能同时满足:
分布式系统中,微服务一定会有概率出现单点故障, 此时就会出现 分区问题 ,而我们如果要保证 一致性 , 就要等待微服务修复,再让分布式系统对外提供服务,此时就导致 可用性 无法满足, 如果要保证 可用性 ,就会导致单点故障的那台微服务与其他微服务出现 一致性 问题. BASE理论 BASE理论是对CAP的一种解决思路，包含三个思想：
Basically Available （基本可用）：
分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d563a344973577f23210db33a8fd3f47/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-04T11:38:36+08:00" />
<meta property="article:modified_time" content="2022-03-04T11:38:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Seata分布式事务管理框架</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98" rel="nofollow">什么是分布式事务问题</a></p> 
<p id="CAP%E5%AE%9A%E7%90%86-toc" style="margin-left:80px;"><a href="#CAP%E5%AE%9A%E7%90%86" rel="nofollow">CAP定理</a></p> 
<p id="BASE%E7%90%86%E8%AE%BA-toc" style="margin-left:80px;"><a href="#BASE%E7%90%86%E8%AE%BA" rel="nofollow">BASE理论</a></p> 
<p id="%E8%A7%A3%E5%86%B3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF-toc" style="margin-left:80px;"><a href="#%E8%A7%A3%E5%86%B3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF" rel="nofollow">解决分布式事务问题的思路</a></p> 
<p id="Seata%E6%A1%86%E6%9E%B6%20--%20%E4%BB%8B%E7%BB%8D-toc" style="margin-left:80px;"><a href="#Seata%E6%A1%86%E6%9E%B6%20--%20%E4%BB%8B%E7%BB%8D" rel="nofollow">Seata框架 -- 介绍</a></p> 
<p id="Seata%E6%A1%86%E6%9E%B6%20--%20TC%E4%BA%8B%E5%8A%A1%E5%8D%8F%E8%B0%83%E8%80%85%E7%9A%84%E9%83%A8%E7%BD%B2-toc" style="margin-left:80px;"><a href="#Seata%E6%A1%86%E6%9E%B6%20--%20TC%E4%BA%8B%E5%8A%A1%E5%8D%8F%E8%B0%83%E8%80%85%E7%9A%84%E9%83%A8%E7%BD%B2" rel="nofollow">Seata框架 -- TC事务协调者的部署</a></p> 
<p id="Seata%E6%A1%86%E6%9E%B6%20--%20XA%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#Seata%E6%A1%86%E6%9E%B6%20--%20XA%E6%A8%A1%E5%BC%8F" rel="nofollow">Seata框架 -- XA模式</a></p> 
<p id="Seata%E6%A1%86%E6%9E%B6%20--%20AT%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#Seata%E6%A1%86%E6%9E%B6%20--%20AT%E6%A8%A1%E5%BC%8F" rel="nofollow">Seata框架 -- AT模式</a></p> 
<p id="Seata%E6%A1%86%E6%9E%B6%20--%20AT%E6%A8%A1%E5%BC%8F%C2%A0%20--%20%E8%84%8F%E8%AF%BB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-toc" style="margin-left:80px;"><a href="#Seata%E6%A1%86%E6%9E%B6%20--%20AT%E6%A8%A1%E5%BC%8F%C2%A0%20--%20%E8%84%8F%E8%AF%BB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88" rel="nofollow">Seata框架 -- AT模式  -- 脏读解决方案</a></p> 
<p id="Seata%E6%A1%86%E6%9E%B6%20--%20TCC%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#Seata%E6%A1%86%E6%9E%B6%20--%20TCC%E6%A8%A1%E5%BC%8F" rel="nofollow">Seata框架 -- TCC模式</a></p> 
<p id="Seata%E6%A1%86%E6%9E%B6%20--%20SAGA%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#Seata%E6%A1%86%E6%9E%B6%20--%20SAGA%E6%A8%A1%E5%BC%8F" rel="nofollow">Seata框架 -- SAGA模式</a></p> 
<p id="%E5%9B%9B%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94-toc" style="margin-left:80px;"><a href="#%E5%9B%9B%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94" rel="nofollow">四种模式的对比</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h4 id="%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98">什么是分布式事务问题</h4> 
<blockquote> 
 <p>在分布式架构中,一般会有很多微服务与数据源,当程序对不同的微服务或数据源进行业务操作的时候,就需要所有的操作保证业务的原子性, 而不同的微服务有可能会出现问题而导致事务问题出现</p> 
</blockquote> 
<h4 id="CAP%E5%AE%9A%E7%90%86">CAP定理</h4> 
<blockquote> 
 <p>CAP定理是1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。</p> 
 <p><span style="color:#4da8ee;"><strong>而这三个指标不可能同时做到。这个结论就叫做 CAP 定理。 </strong></span></p> 
 <p><strong>Consistency（一致性）:</strong></p> 
 <p>        用户访问分布式系统中的任意节点，得到的数据必须一致。</p> 
 <p><strong>Availability（可用性）:</strong></p> 
 <p>        用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝。</p> 
 <p><strong>Partition tolerance （分区容错性）:</strong></p> 
 <p>        因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。在集群出现分区时，整个系统也要持续对外提供服务</p> 
 <p><strong>为什么说CAP定理不能同时满足:</strong></p> 
 <p>        分布式系统中,微服务一定会有概率出现单点故障, 此时就会出现 <span style="color:#4da8ee;"><strong>分区问题</strong></span> ,而我们如果要保证 <span style="color:#4da8ee;"><strong>一致性</strong></span> , 就要等待微服务修复,再让分布式系统对外提供服务,此时就导致 <span style="color:#4da8ee;"><strong>可用性 </strong></span>无法满足, 如果要保证 <span style="color:#4da8ee;"><strong>可用性 </strong></span>,就会导致单点故障的那台微服务与其他微服务出现 <span style="color:#4da8ee;"><strong>一致性 </strong></span>问题. </p> 
</blockquote> 
<h4 id="BASE%E7%90%86%E8%AE%BA">BASE理论</h4> 
<blockquote> 
 <p>BASE理论是对CAP的一种解决思路，包含三个思想：</p> 
 <p><strong>Basically Available （基本可用）：</strong></p> 
 <p>        分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</p> 
 <p><strong>Soft State（软状态）：</strong></p> 
 <p>        在一定时间内，允许出现中间状态，比如临时的不一致状态。</p> 
 <p><strong>Eventually Consistent（最终一致性）：</strong></p> 
 <p>        虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。</p> 
</blockquote> 
<h4 id="%E8%A7%A3%E5%86%B3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF">解决分布式事务问题的思路</h4> 
<blockquote> 
 <p>根据CAP定理和BASE理论我们可以用两种模式解决问题</p> 
 <p><strong>AP模式(高可用,低一致):</strong></p> 
 <p><strong>        </strong>各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致,可以保证服务的高可用</p> 
 <p><strong>CP模式(高一致,低可用):</strong></p> 
 <p><strong>       </strong> 各子事务执行后互相等待,同时提交,同时回滚,达到数据的高一致性,但会牺牲服务的可用性</p> 
 <p><span style="color:#4da8ee;"><strong>两种模式都需要在子事务之间互相通信,才能实现事务的协调,所以需要一个事务协调器(TC),每个子事务被称为分支事务,它们在一起被称为全局事务;</strong></span></p> 
</blockquote> 
<h4 id="Seata%E6%A1%86%E6%9E%B6%20--%20%E4%BB%8B%E7%BB%8D">Seata框架 -- 介绍</h4> 
<blockquote> 
 <p>Seata框架是阿里巴巴开源出的一款分布式事务管理的组件 <a class="link-info" href="http://seata.io/" rel="nofollow" title="Seata官网">Seata官网</a></p> 
 <p><strong>它的事务管理是由这三个角色配合工作实现的:</strong></p> 
 <p><strong>TC (Transaction Coordinator) -</strong> <strong>事务协调者：</strong>维护全局和分支事务的状态，协调全局事务提交或回滚。</p> 
 <p><strong>TM (Transaction Manager) -</strong> <strong>事务管理器：</strong>定义全局事务的范围、开始全局事务、提交或回滚全局事务。</p> 
 <p><strong>RM (Resource Manager) -</strong> <strong>资源管理器：</strong>管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。</p> 
 <p><img alt="" height="468" src="https://images2.imgbox.com/8d/e8/jbOrioLT_o.png" width="1067"></p> 
 <p><strong>Seata基于上述架构提供了四种不同的分布式事务解决方案：</strong></p> 
 <p><strong>XA模式</strong>：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入</p> 
 <p><strong>AT模式</strong>：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式</p> 
 <p><strong>TCC模式</strong>：最终一致的分阶段事务模式，有业务侵入</p> 
 <p><strong>SAGA模式</strong>：长事务模式，有业务侵入</p> 
</blockquote> 
<h4 id="Seata%E6%A1%86%E6%9E%B6%20--%20TC%E4%BA%8B%E5%8A%A1%E5%8D%8F%E8%B0%83%E8%80%85%E7%9A%84%E9%83%A8%E7%BD%B2">Seata框架 -- TC事务协调者的部署</h4> 
<blockquote> 
 <p>详见<a class="link-info" href="http://ww/" rel="nofollow" title="TC事务协调者的部署与集成">TC事务协调者的部署与集成</a></p> 
</blockquote> 
<h4 id="Seata%E6%A1%86%E6%9E%B6%20--%20XA%E6%A8%A1%E5%BC%8F">Seata框架 -- XA模式</h4> 
<blockquote> 
 <p>XA 规范 是 X/Open 组织定义的分布式事务处理（DTP，Distributed Transaction Processing）标准，XA 规范 描述了全局的TM与局部的RM之间的接口，几乎所有主流的数据库都对 XA 规范 提供了支持, XA分为两个阶段:</p> 
 <p><strong>一阶段</strong>： 事务协调者通知每个事物参与者执行本地事务 ,本地事务执行完成后报告事务执行状态给事务协调者，此时事务不提交，继续持有数据库锁</p> 
 <p><strong>二阶段</strong>： 事务协调者基于一阶段的报告来判断下一步操作 如果一阶段都成功，则通知所有事务参与者，提交事务 如果一阶段任意一个参与者失败，则通知所有事务参与者回滚事务</p> 
 <p>正常情况:</p> 
 <p><img alt="" height="446" src="https://images2.imgbox.com/8b/b9/wrSZappL_o.png" width="1147"></p> 
 <p> 异常情况:</p> 
 <p><img alt="" height="446" src="https://images2.imgbox.com/72/dd/5IVtlBEr_o.png" width="1181"></p> 
 <p>Seata框架对AT模式进行了封装以适应自己的架构模型</p> 
 <p><img alt="" height="632" src="https://images2.imgbox.com/1f/f5/nuifhTmx_o.png" width="1165"></p> 
 <p><strong>RM一阶段的工作：</strong></p> 
 <p>         注册分支事务到TC , 执行分支业务sql但不提交 , 报告执行状态到TC</p> 
 <p><strong>TC二阶段的工作：</strong></p> 
 <p>        TC检测各分支事务执行状态 .如果都成功，通知所有RM提交事务 如果有失败，通知所有RM回滚事务</p> 
 <p><strong>RM二阶段的工作：</strong></p> 
 <p>        接收TC指令，提交或回滚事务</p> 
 <p><span style="color:#4da8ee;"><strong>XT模式的优缺点:</strong></span></p> 
 <p><span style="color:#0d0016;">优点: </span></p> 
 <p><span style="color:#0d0016;">        业务是高一致性,满足原子性, 常用数据库都支持,使用简单,没有代码侵入</span></p> 
 <p><span style="color:#0d0016;">缺点: </span></p> 
 <p><span style="color:#0d0016;">        一阶段事务挟持数据库锁,只有到二阶段才会释放,效率较低,依赖数据库的事务支持,一些数据库不支持的话,就没法用,比如redis,mongoDB(4.0版本之前)</span></p> 
 <p><strong>如何实现:</strong></p> 
 <p>Seata的starter已经完成了XA模式的自动装配，有两种方式实现:</p> 
 <p>1) 修改application.yml文件（每个参与事务的微服务），开启XA模式：</p> 
 <pre><code class="language-XML">seata:
  data-source-proxy-mode: XA</code></pre> 
 <p>2) 给发起全局事务的入口方法添加<span style="color:#4da8ee;"><strong>@GlobalTransactional</strong></span>注解</p> 
</blockquote> 
<h4 id="Seata%E6%A1%86%E6%9E%B6%20--%20AT%E6%A8%A1%E5%BC%8F">Seata框架 -- AT模式</h4> 
<blockquote> 
 <p>AT模式(<span style="color:#4da8ee;"><strong>Seata框架默认为AT模式</strong></span>)同样是分阶段提交的事务模型，不过缺弥补了XA模型中资源锁定周期过长的缺陷, 增加一个快照功能. </p> 
 <p><img alt="" height="643" src="https://images2.imgbox.com/cd/95/LG2ZHZ9f_o.png" width="1185"></p> 
 <p><strong>阶段一RM的工作：</strong></p> 
 <p>        注册分支事务 记录undo-log（数据快照） 执行业务sql并提交 向TC报告事务状态</p> 
 <p><strong>( 业务成功 )阶段二进行提交时RM的工作：</strong></p> 
 <p>        删除undo-log(数据快照)</p> 
 <p><strong>( 业务失败 )阶段二回滚时RM的工作：</strong></p> 
 <p>        根据undo-log恢复数据到更新前</p> 
 <p><strong>流程图:</strong></p> 
 <p><img alt="" height="802" src="https://images2.imgbox.com/55/78/81DbVwRm_o.png" width="747"></p> 
 <p><strong>AT模式与XT模式的区别:</strong></p> 
 <p>XT模式是在一阶段不提交事务, 锁定资源,而AT模式是在一阶段提交事务,释放资源</p> 
 <p>XT模式依赖数据库机制进行数据回滚,AT模式是根据数据快照(undo-log)进行数据回滚</p> 
 <p>XT模式是强一致性,而AT模式是最终一致性</p> 
 <p><span style="color:#4da8ee;"><strong>AT模式的优缺点:</strong></span></p> 
 <p><strong>优点:</strong></p> 
 <p>        在一阶段就会提交事务而不锁定资源, 性能有所提升</p> 
 <p>        没有代码侵入,框架会自动化执行</p> 
 <p><strong>缺点:</strong></p> 
 <p>        两阶段之间是软状态,属于最终一致性</p> 
 <p>        额外需要记录数据快照(undo-log),对性能有所损耗</p> 
 <p><strong>实现AT模式:</strong></p> 
 <p> 需要在数据库创建一个undo_log数据快照表</p> 
 <p><img alt="" height="291" src="https://images2.imgbox.com/44/c3/LSTrAjJx_o.png" width="909"></p> 
 <p>修改application.yml文件（每个参与事务的微服务），开启AT模式：</p> 
 <pre><code class="language-XML">seata:
  data-source-proxy-mode: AT</code></pre> 
</blockquote> 
<h4 id="Seata%E6%A1%86%E6%9E%B6%20--%20AT%E6%A8%A1%E5%BC%8F%C2%A0%20--%20%E8%84%8F%E8%AF%BB%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">Seata框架 -- AT模式  -- 脏读解决方案</h4> 
<blockquote> 
 <p>AT模式在一阶段就会提交事务,但如果在高并发场景下,就会出现脏读现象</p> 
 <p><img alt="" height="572" src="https://images2.imgbox.com/6d/48/nKh5Vygh_o.png" width="1154"></p> 
 <p> 解决思路就是引入了全局锁的概念。在释放DB锁之前，先拿到全局锁。避免同一时刻有另外一个事务来操作当前数据。</p> 
 <p><img alt="" height="580" src="https://images2.imgbox.com/b4/47/JjiRDe8u_o.png" width="1162"></p> 
</blockquote> 
<h4 id="Seata%E6%A1%86%E6%9E%B6%20--%20TCC%E6%A8%A1%E5%BC%8F">Seata框架 -- TCC模式</h4> 
<blockquote> 
 <p>TCC模式与AT模式非常相似，每阶段都是独立事务，不同的是TCC通过人工编码来实现数据恢复。需要实现三个方法：</p> 
 <p>Try：资源的检测和预留；</p> 
 <p>Confirm：完成资源操作业务( 提交 )；要求 Try 成功 Confirm 一定要能成功。</p> 
 <p>Cancel：预留资源释放( 回滚 )，可以理解为try的反向操作。</p> 
 <p><img alt="" height="601" src="https://images2.imgbox.com/0e/c9/VGEN8uli_o.png" width="1123"></p> 
 <p><strong>TCC的优点:</strong></p> 
 <p>        一阶段完成直接提交事务，释放数据库资源，性能好 相比AT模型，无需生成快照，无需使用全局锁，性能最强 不依赖数据库事务，而是依赖补偿操作，可以用于非事务型数据库</p> 
 <p><strong>TCC的缺点:</strong></p> 
 <p>         有代码侵入，需要人为编写try、Confirm和Cancel接口，太麻烦 而且是软状态，事务是最终一致 需要考虑Confirm和Cancel的失败情况，需要做幂等性处理</p> 
 <p><strong>空回滚:</strong></p> 
 <p>        当某分支事务的try阶段<strong>阻塞</strong>时，可能导致全局事务超时而触发二阶段的cancel操作。在未执行try操作时先执行了cancel操作，这时cancel就要<strong>空回滚</strong>。代码实现时,我们应该在执行cancel的时候对try进行判断,若try还未执行就要执行空回滚</p> 
 <p><strong>业务悬挂:</strong></p> 
 <p>        对于已经空回滚的业务，之前被阻塞的try操作恢复，继续执行try，就永远不可能confirm或cancel ，事务一直处于中间状态，这就是<strong>业务悬挂</strong>。执行try操作时，应当判断cancel是否已经执行过了，如果已经执行，应当阻止空回滚后的try操作，避免悬挂</p> 
 <p>TCC实现:</p> 
 <p>        TCC的Try、Confirm、Cancel方法都需要在接口中基于注解来声明，</p> 
 <pre><code class="language-java">@LocalTCC
public interface AccountTCCService {

    //@TwoPhaseBusinessAction注解用来标注try 
    //name属性 : try
    //commitMethod属性 : Confirm
    //rollbackMethod属性 : cancel
    @TwoPhaseBusinessAction(name = "deduct", commitMethod = "confirm", rollbackMethod = "cancel")
    void deduct(@BusinessActionContextParameter(paramName = "userId") String userId,
                @BusinessActionContextParameter(paramName = "money")int money);
    //@BusinessActionContextParameter注解用于将参数封装到上下文对象中

    boolean confirm(BusinessActionContext ctx);

    boolean cancel(BusinessActionContext ctx);
}</code></pre> 
</blockquote> 
<h4 id="Seata%E6%A1%86%E6%9E%B6%20--%20SAGA%E6%A8%A1%E5%BC%8F">Seata框架 -- SAGA模式</h4> 
<blockquote> 
 <p><strong>介绍:</strong></p> 
 <p>        Saga 模式是 Seata 即将开源的长事务解决方案，将由蚂蚁金服主要贡献。其理论基础是Hector &amp; Kenneth 在1987年发表的论文<a href="https://microservices.io/patterns/data/saga.html" rel="nofollow" title="Sagas">Sagas</a>。</p> 
 <p>Seata官网对于Saga的指南：<a href="https://seata.io/zh-cn/docs/user/saga.html" rel="nofollow" title="Seata Saga 模式">Seata Saga 模式</a></p> 
 <p><strong>原理:</strong></p> 
 <p>        在 Saga 模式下，分布式事务内有多个参与者，每一个参与者都是一个冲正补偿服务，需要用户根据业务场景实现其正向操作和逆向回滚操作。</p> 
 <p>        分布式事务执行过程中，依次执行各参与者的正向操作，如果所有正向操作均执行成功，那么分布式事务提交。如果任何一个正向操作执行失败，那么分布式事务会去退回去执行前面各参与者的逆向回滚操作，回滚已提交的参与者，使分布式事务回到初始状态。</p> 
 <p><img alt="" height="667" src="https://images2.imgbox.com/63/0f/vm67WqZD_o.png" width="643"></p> 
 <p><strong>Saga也分为两个阶段：</strong></p> 
 <p>一阶段：直接提交本地事务</p> 
 <p>二阶段：成功则什么都不做；失败则通过编写补偿业务来回滚</p> 
 <p><strong>优点：</strong></p> 
 <p>        事务参与者可以基于事件驱动实现异步调用，吞吐高 一阶段直接提交事务，无锁，性能好 不用编写TCC中的三个阶段，实现简单</p> 
 <p><strong>缺点：</strong></p> 
 <p>        软状态持续时间不确定，时效性差 没有锁，没有事务隔离，会有脏写</p> 
 <p><span style="color:#4da8ee;"><strong>适用于微服务调用链路较长,业务较复杂,或者跨公司的业务,比如银行的转账</strong></span></p> 
</blockquote> 
<h4 id="%E5%9B%9B%E7%A7%8D%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AF%B9%E6%AF%94">四种模式的对比</h4> 
<blockquote> 
 <p>我们从以下几个方面来对比四种实现：</p> 
 <p><strong>一致性</strong>：能否保证事务的一致性？强一致还是最终一致？</p> 
 <p><strong>隔离性</strong>：事务之间的隔离性如何？</p> 
 <p><strong>代码侵入</strong>：是否需要对业务代码改造？</p> 
 <p><strong>性能</strong>：有无性能损耗？</p> 
 <p><strong>场景</strong>：常见的业务场景</p> 
 <p><img alt="" height="480" src="https://images2.imgbox.com/24/1a/V4Ds8SaV_o.png" width="1195"></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a0c069fd7ea857dcc1d06878b92081d3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">部署web服务器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2be0214b6af0b5e2ad1af1f9100bb015/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">org.apache.catalina.connector.ClientAbortException: java.io.IOException: 您的主机中的软件中止了一个已建立的连接。的解决方案之一</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>