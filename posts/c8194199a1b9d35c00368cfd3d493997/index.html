<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浅谈 Spring 如何解决 Bean 的循环依赖问题(转载) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浅谈 Spring 如何解决 Bean 的循环依赖问题(转载)" />
<meta property="og:description" content="1. 什么是循环依赖？ 通俗来讲，循环依赖指的是一个实例或多个实例存在相互依赖的关系（类之间循环嵌套引用）。
举个例子
public class AService { private BService bService; } public class BService { private AService aService; } 上述例子中 AService 依赖了 BService，BService 也依赖了 AService，这就是两个对象之间的相互依赖。当然循环依赖还包括 自身依赖、多个实例之间相互依赖。
正常运行上面的代码调用 AService 对象并不会出现问题，也就是说普通对象就算出现循环依赖也不会存在问题，因为对象之间存在依赖关系是很常见的，那么为什么被 Spring 容器管理后的对象会出现循环依赖问题呢？
2. Spring Bean 的循环依赖问题 被 Spring 容器管理的对象叫做 Bean，为什么 Bean 会存在循环依赖问题呢？
想要了解 Bean 的循环依赖问题，首先需要了解 Bean 是如何创建的。
2.1 Bean 的创建步骤 为了能更好的展示出现循环依赖问题的环节，所以这里的 Bean 创建步骤做了简化：
1、在创建 Bean 之前，Spring 会通过扫描获取 BeanDefinition。
2、BeanDefinition就绪后会读取 BeanDefinition 中所对应的 class 来加载类。
3、实例化阶段：根据构造函数来完成实例化 （未属性注入以及初始化的对象 这里简称为 原始对象）
4、属性注入阶段：对 Bean 的属性进行依赖注入 （这里就是发生循环依赖问题的环节）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c8194199a1b9d35c00368cfd3d493997/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-01T15:54:48+08:00" />
<meta property="article:modified_time" content="2023-07-01T15:54:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浅谈 Spring 如何解决 Bean 的循环依赖问题(转载)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1__0"></a>1. 什么是循环依赖？</h3> 
<p>通俗来讲，循环依赖指的是<strong>一个实例或多个实例存在相互依赖的关系</strong>（类之间循环嵌套引用）。</p> 
<p>举个例子</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AService</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">BService</span> bService<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BService</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">AService</span> aService<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上述例子中 <code>AService</code> 依赖了 <code>BService</code>，<code>BService</code> 也依赖了 <code>AService</code>，这就是两个对象之间的相互依赖。当然循环依赖还包括 <strong>自身依赖、多个实例之间相互依赖</strong>。</p> 
 
<p><img src="https://images2.imgbox.com/50/fa/QorjPzxo_o.png" alt="在这里插入图片描述"></p> 
<p>正常运行上面的代码调用 <code>AService</code> 对象并不会出现问题，也就是说普通对象就算出现循环依赖也不会存在问题，因为对象之间存在依赖关系是很常见的，那么为什么被 Spring 容器管理后的对象会出现循环依赖问题呢？</p> 
<h3><a id="2_Spring_Bean__23"></a>2. Spring Bean 的循环依赖问题</h3> 
<p>被 Spring 容器管理的对象叫做 Bean，为什么 Bean 会存在循环依赖问题呢？</p> 
<p>想要了解 Bean 的循环依赖问题，首先需要了解 Bean 是如何创建的。</p> 
<h4><a id="21_Bean__29"></a>2.1 Bean 的创建步骤</h4> 
<p>为了能更好的展示出现循环依赖问题的环节，所以这里的 Bean 创建步骤做了简化：</p> 
<p>1、在创建 Bean 之前，Spring 会通过扫描获取 BeanDefinition。</p> 
<p>2、BeanDefinition就绪后会读取 BeanDefinition 中所对应的 class 来加载类。</p> 
<p>3、实例化阶段：根据构造函数来完成实例化 （<strong>未属性注入以及初始化的对象</strong> 这里简称为 <strong>原始对象</strong>）</p> 
<p>4、属性注入阶段：对 Bean 的属性进行依赖注入 （这里就是<strong>发生循环依赖问题的环节</strong>）</p> 
<p>5、如果 Bean 的某个方法有AOP操作，则需要根据原始对象生成<strong>代理对象</strong>。</p> 
<p>6、最后把代理对象放入单例池（一级缓存<code>singletonObjects</code>）中。</p> 
<p><strong>两点说明：</strong></p> 
<p>上面的 Bean 创建步骤是对于 <strong>单例（singleton）</strong> 作用域的 Bean。</p> 
<p>Spring 的 AOP 代理就是作为 <code>BeanPostProcessor</code> 实现的，而 <code>BeanPostProcessor</code> 是发生在属性注入阶段后的，所以 <strong>AOP</strong> 是在 <strong>属性注入</strong> 后执行的。</p> 
<h4><a id="22__Spring_Bean__51"></a>2.2 为什么 Spring Bean 会产生循环依赖问题？</h4> 
<p>通过上面的 Bean 创建步骤可知：实例化 Bean 后会进行 属性注入（依赖注入）</p> 
<p>如上面的 <code>AService</code> 和 <code>BService</code> 的依赖关系，当 <code>AService</code> 创建时，会先对 <code>AService</code> 进行实例化生成一个原始对象，然后在进行属性注入时发现了需要 <code>BService</code> 对应的 Bean，此时就会去为 <code>BService</code> 进行创建，在 <code>BService</code> 实例化后生成一个原始对象后进行属性注入，此时会发现也需要 <code>AService</code> 对应的 Bean。<br> <img src="https://images2.imgbox.com/ed/bd/EvwQzTS5_o.png" alt="在这里插入图片描述"></p> 
<p>这样就会造成 <code>AService</code> 和 <code>BService</code> 的 Bean 都无法创建，就会产生 <strong>循环依赖</strong> 问题。</p> 
<h4><a id="23__61"></a>2.3 三大循环依赖问题场景</h4> 
<p>Spring 并不能解决所有 Bean 的循环依赖问题，接下来通过例子来看看哪些场景下的循环依赖问题是不能被解决的。循环依赖是指在应用程序中存在相互引用的对象，导致无法正确地初始化这些对象。以下是三个常见的循环依赖问题场景：</p> 
<ol><li>构造函数循环依赖： 当两个或多个类在它们的构造函数中相互依赖时，可能会引发构造函数循环依赖问题。例如，类A依赖于类B的实例，而同时类B也依赖于类A的实例。这种情况下，如果使用传统的依赖注入方式，很可能会导致无限循环，无法正确完成实例化。</li><li>属性循环依赖： 当两个或多个类之间存在相互依赖的属性关系时，可能会引发属性循环依赖问题。例如，类A有一个属性引用类型为类B的实例，而类B又有一个属性引用类型为类A的实例。如果没有正确处理循环依赖，可能会导致无法正确初始化属性。</li><li>静态成员变量循环依赖： 当两个或多个类之间存在相互依赖的静态成员变量时，可能会引发静态成员变量循环依赖问题。例如，类A的静态成员变量引用类型为类B的实例，而类B的静态成员变量又引用类型为类A的实例。这种情况下，无法解决循环依赖，可能导致应用程序加载和初始化时出现问题。</li></ol> 
<p>以上是三个常见的循环依赖问题场景。在实际开发中，为了避免循环依赖问题，可以采取一些解决方案，例如使用延迟初始化、Setter注入替代构造函数注入、引入第三方容器管理依赖关系等。具体的解决方法可以根据具体的情况和框架选择。</p> 
<p>对应的解决方法：</p> 
<ol><li>构造函数循环依赖： 
  <ul><li>通过构造函数注入改为使用Setter注入：将类的依赖关系改为通过Setter方法来注入，从而打破循环依赖。</li><li>使用延迟初始化：延迟初始化一个或多个循环依赖的对象，可以通过懒加载或者使用代理对象实现。</li></ul> </li><li>属性循环依赖： 
  <ul><li>使用懒加载（<strong>@Lazy</strong>）：将循环依赖的属性设置为延迟加载，只有在需要的时候才进行初始化。</li><li>使用中间对象：引入一个中间对象，它的责任是处理循环依赖的属性，并且在合适的时候进行初始化。</li></ul> </li><li>静态成员变量循环依赖： 
  <ul><li>使用静态工厂方法：将实例的创建和初始化放在静态工厂方法中，由工厂方法控制依赖关系的初始化顺序。</li><li>使用第三方容器：使用像Spring这样的依赖注入容器，容器可以解决循环依赖问题并正确地管理对象的生命周期。</li></ul> </li></ol> 
<h3><a id="3_Spring__83"></a>3. Spring 如何解决循环依赖问题？</h3> 
<p>通过上文的内容能了解到 <strong>Spring 为什么会产生循环依赖问题</strong> 以及 <strong>Spring 能解决什么场景下的循环依赖问题</strong>。</p> 
<p>上文中也有提到过 Spring 是靠 <strong>三级缓存</strong> 来解决循环依赖问题的，接下来了解一下 <strong>什么是三级缓存</strong> 以及 <strong>解决循环依赖问题的具体流程</strong>。</p> 
<h4><a id="31__89"></a>3.1 三级缓存是什么？</h4> 
<pre><code class="prism language-java"><span class="token comment">/** Cache of singleton objects: bean name to bean instance. */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> singletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcurrentHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">256</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/** Cache of singleton factories: bean name to ObjectFactory. */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">ObjectFactory</span><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> singletonFactories <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/** Cache of early singleton objects: bean name to bean instance. */</span>
<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> earlySingletonObjects <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>三级缓存分为：</p> 
<ul><li>一级缓存（<code>singletonObjects</code>）：缓存的是<strong>已经实例化、属性注入、初始化后</strong>的 Bean 对象。</li><li>二级缓存（<code>earlySingletonObjects</code>）：缓存的是<strong>实例化后，但未属性注入、初始化</strong>的 Bean对象（用于提前暴露 Bean）。</li><li>三级缓存（<code>singletonFactories</code>）：缓存的是一个 <code>ObjectFactory</code>，主要作用是生成原始对象进行 AOP 操作后的<strong>代理对象</strong>（这一级缓存主要用于解决 AOP 问题，后续文章中讲解）。</li></ul> 
<h4><a id="32__108"></a>3.2 为什么缓存可以解决循环依赖问题？</h4> 
<p><strong>（注意这里只是为了说明缓存可以解决循环依赖问题，但是 Spring 实际上并不是这样做的）</strong></p> 
<p>上文中可以看到 <code>AService</code> 和 <code>BService</code> 的循环依赖问题是因为 <code>AService的创建</code> 需要 <code>BService的注入</code>，<code>BService的注入</code> 需要 <code>BService的创建</code>，<code>BService的创建</code> 需要 <code>AService的注入</code>，<code>AService的注入</code> 需要 <code>AService的创建</code>，从而形成的环形调用。</p> 
<p>想要打破这一环形，只需要增加一个 <strong>缓存</strong> 来存放 <strong>原始对象</strong> 即可。</p> 
<p>在创建 <code>AService</code> 时，实例化后将 <strong>原始对象</strong> 存放到缓存中（提早暴露），然后依赖注入时发现需要 <code>BService</code>，便会去创建 <code>BService</code>，实例化后同样将 <strong>原始对象</strong> 存放到缓存中，然后依赖注入时发现需要 <code>AService</code> 便会从缓存中取出并注入，这样 <code>BService</code> 就完成了创建，随后 <code>AService</code> 也就能完成属性注入，最后也完成创建。这样就打破了环形调用，避免循环依赖问题。<br> <img src="https://images2.imgbox.com/82/cd/Jemfd5U6_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="33__119"></a>3.3 为什么还需要第三级缓存？</h4> 
<p>通过上面的分析可以发现只需要一个存放 <strong>原始对象</strong> 的缓存就可以解决循环依赖问题，也就是说只要二级缓存（<code>earlySingletonObjects</code>）就够了，那么为什么 Spring 还设置了三级缓存（<code>singletonFactories</code>）呢？</p> 
<p>其实 <strong>第三级缓存（<code>singletonFactories</code>）</strong> 是为了处理 Spring 的 AOP的。</p> 
<p>如上面的例子如果 <code>AService</code> 中方法没有使用 AOP 操作，会发现 <code>BService</code> 注入的 <strong>原始对象</strong> 与最后 <code>AService</code> 完成创建后的最终对象是<strong>同一个对象</strong>。</p> 
<p>如果 <code>AService</code> 方法中有 AOP 操作，Bean 的创建会如下图：<br> <img src="https://images2.imgbox.com/f1/fc/cCqzUyMw_o.png" alt="在这里插入图片描述"></p> 
<p>所以如果 <code>AService</code> 方法中有 AOP 操作时，当 <code>AService</code> 的原始对象赋值（注入）给 <code>BService</code>，<code>AService</code> 会进行 AOP 操作产生一个 <strong>代理对象</strong>，这个代理对象最后会被放入单例池（一级缓存）中，也就是说此时 <code>BService</code> 中注入的对象是原始对象，而 <code>AService</code> 最终创建的完成后是代理对象，这样就会<strong>导致 <code>BService</code> 依赖的 <code>AService</code> 和 最终的 <code>AService</code> 不是同一个对象</strong>。</p> 
<p>出现这个问题主要是上文提到过的 AOP 是通过 <code>BeanPostProcessor</code> 实现的，而 <code>BeanPostProcessor</code> 是在 <strong>属性注入阶段后</strong> 才执行的，所以会导致<strong>注入的对象有可能和最终的对象不一致</strong>。</p> 
<hr> 
<h4><a id="34_Spring__AOP__137"></a>3.4 Spring 是如何通过第三级缓存来避免 AOP 问题的？</h4> 
<p>三级缓存中存放的是 <code>ObjectFactory</code> 对象，那 <code>ObjectFactory</code> 是什么呢？</p> 
<p><strong><code>ObjectFactory</code> 是什么？</strong></p> 
<p>深入源码会发现 Spring 在 <code>doCreateBean()</code> 方法中的 <code>addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean))</code> 加入缓存。<br> <img src="https://images2.imgbox.com/68/69/RmoEJ5XT_o.png" alt="在这里插入图片描述"></p> 
<p>深入 <code>addSingletonFactory</code> 方法：可以看到方法中的第二个参数就是 <code>ObjectFactory</code> 类型，并且将其添加进 <strong>三级缓存（<code>singletonFactories</code>）</strong> 中。<br> <img src="https://images2.imgbox.com/63/87/TOzZnGI3_o.png" alt="在这里插入图片描述"></p> 
<p>这里放一下 <code>ObjectFactory</code> 类：</p> 
<p><img src="https://images2.imgbox.com/46/e8/oxZO5s8M_o.png" alt="在这里插入图片描述"></p> 
<p>也就是说 Spring 在加入缓存时，会将 <strong>实例化后生成的原始对象</strong> 通过 <strong>lambda 表达式调用 <code>getObject()</code> 方法，<code>getObject()</code> 方法里调用 <code>getEarlyBeanReference()</code> 方法</strong> 来封装成 <code>ObjectFactory</code> 对象。</p> 
<p><strong><code>getEarlyBeanReference()</code> 方法的作用</strong></p> 
<p>进入 <code>getEarlyBeanReference()</code> 中，会发现调用了 <code>SmartInstantiationAwareBeanPostProcessor</code> 的 <code>getEarlyBeanReference()</code> 方法。<br> <img src="https://images2.imgbox.com/b7/05/qrBmZAxb_o.png" alt="在这里插入图片描述"></p> 
<p>找到 <code>SmartInstantiationAwareBeanPostProcessor</code> 的实现类 <code>AbstractAutoProxyCreator</code> 实现的 <code>getEarlyBeanReference()</code> 方法就可以看到其作用了。</p> 
<p><img src="https://images2.imgbox.com/a0/5d/tMamttbH_o.png" alt="在这里插入图片描述"></p> 
<ul><li><code>earlyProxyReferences</code> 存储的是 <code>(beanName, bean)</code> 键值对，这里的 bean 指的是原始对象（刚实例化后的对象）。</li><li><code>wrapIfNecessary()</code> 方法用于执行 AOP 操作，生成一个<strong>代理对象</strong>（也就是说<strong>如果有 AOP 操作最后返回的是代理对象，否则返回的还是原始对象</strong>）。</li></ul> 
<blockquote> 
 <p><strong>Spring 真正意义上地创建 Bean 的流程</strong></p> 
</blockquote> 
<p>先放具体流程图：<br> <img src="https://images2.imgbox.com/11/f8/TKqVPiHG_o.png" alt="在这里插入图片描述"></p> 
<p>要点说明：</p> 
<ol><li>并不是马上就执行 <code>ObjectFactory</code> 的 <code>getEarlyBeanReference()</code> 方法（有循环依赖时才执行）。 
  <ul><li>实例化后的 Bean 会生成原始对象，然后经过 lambda 表达式封装为 <code>ObjectFactory</code> 对象，并且通过 <code>addSingletonFactory()</code> 方法将其放入 三级缓存（<code>singletonFactories</code>）中。</li><li>但是这里执不执行 lambda 表达式中的 <code>getEarlyBeanReference()</code> 方法是看程序有没有调用 <code>singletonFactories.get(beanName)</code>，只有调用了该方法（其实也就是看<strong>是否存在循环依赖</strong>需要提前获得该 Bean），才会触发执行 <code>getEarlyBeanReference()</code> 方法。</li><li>而 <code>getEarlyBeanReference()</code> 方法会根据 Bean 中是否有 AOP 操作来决定返回的是 <strong>原始对象</strong> 还是 <strong>代理对象</strong>，并且会将其上移到二级缓存中（也就是提前暴露出来让别的 Bean 使用）。</li></ul> </li><li>如果 Bean 中有 AOP 操作，而 AOP 操作又是在属性注入之后执行的，那么之前的 <code>getEarlyBeanReference()</code> 方法中执行的 AOP 操作<strong>会不会重复</strong>？ 
  <ul><li><strong>答案是不会</strong>，还记得 <code>getEarlyBeanReference()</code> 方法中的 <strong><code>earlyProxyReferences</code></strong> 吗，这个就是用来记录当前 Bean 是否已经执行 AOP 操作。</li><li>当属性注入后需要执行 AOP 操作时，会先判断当前的 Bean 是否在 <code>earlyProxyReferences</code> 中，如果在则说明已经提前执行了 AOP 了，不用再执行了，否则就执行当前 AOP 操作。</li></ul> </li><li>二级缓存中的对象什么时候会上移到一级缓存？ 
  <ul><li>二级缓存是为了提前暴露 Bean 来解决循环依赖问题，此时的 Bean 可能还没有进行属性注入，只有等完成了属性注入、初始化后的 Bean 才会上移到一级缓存（单例池）中。</li></ul> </li><li>为什么可以解决 AOP 的问题？ 
  <ul><li>三级缓存通过利用 <code>ObjectFactory</code> 和 <code>getEarlyBeanReference()</code> 做到了提前执行 AOP 操作从而生成代理对象。</li><li>这样在上移到二级缓存时，可以做到如果 Bean 中有 AOP 操作，那么提前暴露的对象会是 AOP 操作后返回的代理对象；如果没有 AOP 操作，那么提前暴露的对象会是原始对象。</li><li>这样就能做到出现循环依赖问题时，注入依赖的对象和最终生成的对象是同一个对象。（相当于 AOP 提前在属性注入前完成，这样就不会导致后面生成的代理对象与属性注入时的对象的不一致）</li></ul> </li></ol> 
<p>所以 Spring 利用 <strong>三级缓存</strong> 巧妙地将出现 <strong>循环依赖</strong> 时的 <strong>AOP 操作</strong> 提前到了 <strong>属性注入</strong> 之前，避免了对象不一致问题。</p> 
<h3><a id="4__Spring__Bean__195"></a>4. 梳理 Spring 解决 Bean 的循环依赖的整个流程</h3> 
<p>还是以 <code>AService</code> 和 <code>BService</code> 的循环依赖为例，完整地看看 Spring 是如何解决 Bean 的循环依赖问题。</p> 
<blockquote> 
 <p><strong>源码分析整个流程</strong></p> 
</blockquote> 
<p>由于前面的内容过于繁琐，这里就以文字概括，只关注几个主要的方法：</p> 
<p>以 <code>AbstractApplicationContext</code> 的 <code>refresh()</code> 方法出发，进入 <code>finishBeanFactoryInitialization()</code> 方法再进入 <code>preInstantiateSingletons()</code> 方法再进入 <code>getBean()</code> 方法再进入 <code>doGetBean()</code> 方法。</p> 
<p>看看 <code>doGetBean()</code> 方法：<br> <img src="https://images2.imgbox.com/d8/83/XnwvkKhf_o.png" alt="在这里插入图片描述"></p> 
<p>其中的第一个 <code>getSingleton(beanName)</code> 是判断 <strong>三级缓存</strong> 中是否有创建好的 Bean 对象，看看源码：<br> <img src="https://images2.imgbox.com/92/aa/po1xclKH_o.png" alt="在这里插入图片描述"></p> 
<p>可以看到这里分别去每一级的缓存中取数据，依次从第一级开始取数据，如果取得到则直接返回，取不到则往下一级查找。</p> 
<p>可以看到在<strong>第三级缓存</strong>中调用了 <code>singletonFactories.get(beanName)</code> 按照上文所说的会触发执行有 AOP 操作返回代理对象，没有返回原始对象，并且在这里会判断取出的数据是否存在，存在则上移到二级缓存中并删除三级缓存的数据。</p> 
<p>如果都没有的话就会执行第二个 <code>getSingleton()</code> 也就是去执行 <code>createBean()</code> 创建一个 Bean 对象出来。</p> 
<p>会执行 <code>createBean()</code> 方法中的 <code>doCreateBean()</code> 方法，看看源码：<br> <img src="https://images2.imgbox.com/2a/b4/PkQeouul_o.png" alt="在这里插入图片描述"></p> 
<p>到这里应该就一目了然了。</p> 
<blockquote> 
 <p><strong>梳理整个流程</strong></p> 
</blockquote> 
<ol><li>首先会获取 <code>AService</code> 对应的 Bean 对象。</li><li>先是调用 <code>doGetBean()</code> 中的第一个 <code>getSingleton(beanName)</code> 判断是否有该 Bean 的实例，有就直接返回了。（显然这里没有）</li><li>然后调用 <code>doGetBean()</code> 中的第二个 <code>getSingleton()</code> 方法来执行 <code>doCreateBean()</code> 方法。</li><li>先进行实例化操作（也就是利用构造函数实例化），此时实例化后生成的是原始对象。</li><li>将原始对象通过 lambda表达式 进行封装成 <code>ObjectFactory</code> 对象，通过 <code>addSingletonFactory</code> 加入三级缓存中。</li><li>然后再进行属性注入，此时发现需要注入 <code>BService</code> 的 Bean，会通过 <code>doGetBean()</code> 去获取 <code>BService</code> 对应的 Bean。</li><li>同样调用 <code>doGetBean()</code> 中的第一个 <code>getSingleton(beanName)</code> 判断是否有该 Bean 的实例，显然这里也是不会有 <code>BService</code> 的 Bean 的。</li><li>然后只能调用 <code>doGetBean()</code> 中的第二个 <code>getSingleton()</code> 方法来执行 <code>doCreateBean()</code> 方法来创建一个 <code>BService</code> 的 Bean。</li><li>同样地先进行实例化操作，生成原始对象后封装成 <code>ObjectFactory</code> 对象放入三级缓存中。</li><li>然后进行属性注入，此时发现需要注入 <code>AService</code> 的 Bean，此时调用调用 <code>doGetBean()</code> 中的第一个 <code>getSingleton(beanName)</code> 查找是否有 <code>AService</code> 的 Bean。此时会触发三级缓存，也就是调用 <code>singletonFactories.get(beanName)</code>。</li><li>因为三级缓存中有 <code>AService</code> 的原始对象封装的 <code>ObjectFactory</code> 对象，所以可以获取到的代理对象或原始对象，并且上移到二级缓存中，提前暴露给 <code>BService</code> 调用。</li><li>所以 <code>BService</code> 可以完成属性注入，然后进行初始化后，将 Bean 放入一级缓存，这样 <code>AService</code> 也可以完成创建。</li></ol> 
<p>以上就是 Spring 解决 Bean 的循环依赖问题的整个流程了。</p> 
<h3><a id="5_244"></a>5.疑问</h3> 
<h4><a id="aopaop_246"></a>为啥不只用两层缓存解决问题，从第二层缓存取对象时，如果该对象需要aop，则进行aop处理</h4> 
<p>解答：</p> 
<p>这个问题太经典了，这里我说一下我的看法：首先呢，如果使用二级缓存的话，那么我可以理解为相当于提前判断Bean是否需要AOP，需要的话直接生成代理对象放入二级缓存，等Bean创建完成后再升到一级缓存中。大概是这个思路吧，但是为什么Spring不这么设计呢，我认为有两点原因：① 由于Spring对AOP的设计思想是AOP的创建时机是在初始化后为Bean生成代理对象的，如果采用上述的设计，那么不管Bean是否存在循环依赖，都会提早生成代理对象，这样其实已经违背了Bean的设计理念。② 使用ObjectFactory对象每次触发调用lambda表达式中的 <code>getEarlyBeanReference()</code>生成的代理对象其实都是新创建的，也就是说如果存在两个以上的Bean循环依赖，例如 A 依赖 B 和 C，而 B 也依赖 A，C 也依赖A，并且A需要AOP，那么此时在创建 B 时触发 A 的ObjectFactory对象生成的代理对象和创建 C 时触发 A 的ObjectFactory对象生成的代理对象是不一样的，因为两次触发生成的都是新对象。这也就是为什么需要在中间设置一个二级缓存存放第一次调用创建的代理对象，这样还需要属性注入 A 的Bean就可以直接在二级缓存中拿，而不需要再次触发ObjectFactory对象。</p> 
<p>作者：单程车票<br> 链接：https://juejin.cn/post/7218080360403615804<br> 来源：稀土掘金<br> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/af13e1cbf29c726be6de36cba7fed236/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【实操记录】vm配置网络</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c76b4b2b4cbf39f424f923a8e617f748/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IDEA中删除某个模块后在创建同名模块显示已存在 的解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>