<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构之堆——学习笔记 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构之堆——学习笔记" />
<meta property="og:description" content="1.堆的简介：
接下来看一下堆的建立；
接下来是如何在堆中插入数据以及删除数据：
大根堆的插入操作类似只是改变了一下大于和小于符号，同时插入操作的时间复杂度为O（logn）。
来看几个问题：
答案当然是不可以：
这样的话就能根据原堆的末尾数字的大小来判断是应该尝试将它往上还是下进行移动。
来看看STL里面的优先队列：
值得注意的是 用优先队列是没有clear操作的。
接下来看几道例题：
1.堆排序：
#include&lt;bits/stdc&#43;&#43;.h&gt; using namespace std; const int N=1e5&#43;100; int n,heap[N],x,len=0; inline void up(int x){ while(x&gt;1 &amp;&amp; heap[x]&lt;heap[x/2]){ swap(heap[x],heap[x/2]); x/=2; } } inline void down(int k){ while(k&#43;k&lt;=len){ int j=k&#43;k; if(j&#43;1&lt;=len &amp;&amp; heap[j&#43;1]&lt;heap[j]) &#43;&#43;j; if(heap[j]&gt;=heap[k]) break; swap(heap[k],heap[j]); k=j; } } int main(){ cin&gt;&gt;n; for(int i=1;i&lt;=n;i&#43;&#43;){ cin&gt;&gt;x; heap[&#43;&#43;len]=x; up(len); } for(int i=1;i&lt;=n;i&#43;&#43;){ cout&lt;&lt;heap[1]&lt;&lt;&#39; &#39;; swap(heap[1],heap[len]); --len; down(1); } return 0; } 事实上用优先队列来做会非常的简单：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9785f238a192f015f5e158bd4210d37b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-07T14:19:37+08:00" />
<meta property="article:modified_time" content="2024-01-07T14:19:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构之堆——学习笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>1.堆的简介：</p> 
<p><img alt="" height="951" src="https://images2.imgbox.com/7e/8a/a66PwS1f_o.png" width="1200"></p> 
<p><img alt="" height="878" src="https://images2.imgbox.com/36/6b/gXVRwACh_o.png" width="1200"></p> 
<p>接下来看一下堆的建立；</p> 
<p><img alt="" height="873" src="https://images2.imgbox.com/8d/7d/mdEfXX8z_o.png" width="1200"></p> 
<p>接下来是如何在堆中插入数据以及删除数据：</p> 
<p><img alt="" height="829" src="https://images2.imgbox.com/f9/c8/wuPCPH6K_o.png" width="1200"> <img alt="" height="975" src="https://images2.imgbox.com/02/af/6FoZqiZk_o.png" width="1200"></p> 
<p><img alt="" height="927" src="https://images2.imgbox.com/4d/d5/RcMT05Ul_o.png" width="1200"></p> 
<p><img alt="" height="270" src="https://images2.imgbox.com/fc/1d/d1oIpZlb_o.png" width="767"></p> 
<p>大根堆的插入操作类似只是改变了一下大于和小于符号，同时插入操作的时间复杂度为O（logn）。</p> 
<p><img alt="" height="875" src="https://images2.imgbox.com/f4/7b/fWF67A4s_o.png" width="1200"></p> 
<p><img alt="" height="322" src="https://images2.imgbox.com/ce/b1/SMg9AQBO_o.png" width="836"></p> 
<p><img alt="" height="368" src="https://images2.imgbox.com/d8/50/9ZyRPdae_o.png" width="842"></p> 
<p> 来看几个问题：</p> 
<p><img alt="" height="253" src="https://images2.imgbox.com/65/20/ibSvOmGg_o.png" width="1200"></p> 
<p>答案当然是不可以：</p> 
<p><img alt="" height="604" src="https://images2.imgbox.com/b9/40/dlc92Ljo_o.png" width="1200"> <img alt="" height="707" src="https://images2.imgbox.com/73/4b/8d87QUmj_o.png" width="1039"></p> 
<p>这样的话就能根据原堆的末尾数字的大小来判断是应该尝试将它往上还是下进行移动。</p> 
<p> 来看看STL里面的优先队列：</p> 
<p><img alt="" height="502" src="https://images2.imgbox.com/dc/aa/DAudwT1B_o.png" width="1200"></p> 
<p> <img alt="" height="71" src="https://images2.imgbox.com/3f/e5/yKwc8YtP_o.png" width="1200"></p> 
<p><img alt="" height="59" src="https://images2.imgbox.com/0d/60/sDDUjCOG_o.png" width="1200"></p> 
<p> 值得注意的是 用优先队列是没有clear操作的。</p> 
<p>接下来看几道例题：</p> 
<p>1.堆排序：</p> 
<p><img alt="" height="646" src="https://images2.imgbox.com/e6/98/10UgBJB1_o.png" width="1200"></p> 
<p></p> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1e5+100;
int n,heap[N],x,len=0;
inline void up(int x){
	while(x&gt;1 &amp;&amp; heap[x]&lt;heap[x/2]){
	swap(heap[x],heap[x/2]);
	x/=2;
	}
}
inline void down(int k){
	while(k+k&lt;=len){
		int j=k+k;
		if(j+1&lt;=len &amp;&amp; heap[j+1]&lt;heap[j]) ++j;
		if(heap[j]&gt;=heap[k]) break;
		swap(heap[k],heap[j]);
		k=j;
	}
} 
int main(){
	cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++){
		cin&gt;&gt;x;
		heap[++len]=x;
		up(len);
	}
	for(int i=1;i&lt;=n;i++){
		cout&lt;&lt;heap[1]&lt;&lt;' ';
		swap(heap[1],heap[len]);
		--len;
		down(1);
	}
	return 0;
}</code></pre> 
<p>事实上用优先队列来做会非常的简单：</p> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;q;
const int N=1e5+100;
int n;
/*inline void up(int x){
	while(x&gt;1 &amp;&amp; heap[x]&lt;=heap[x/2]){
		swap(heap[x],heap[x/2]);
		x/=2;
	}
}
inline void down(int x){
	while(x+x&lt;=len){
		int y=x+x;
		if(y+1&lt;=len &amp;&amp; heap[y+1]&lt;heap[y])  ++y;
		if(heap[y]&gt;=heap[x]) break;
		swap(heap[y],heap[x]);
		x=y;
	}
}*/
int main(){
    cin&gt;&gt;n;
	for(int i=1;i&lt;=n;i++){
		int x;
		cin&gt;&gt;x;
		q.push(x);
	}	
	for(int i=1;i&lt;=n;i++){
		cout&lt;&lt;q.top()&lt;&lt;' ';
		q.pop();
	}
	return 0;
}</code></pre> 
<p>使用小根堆的话是需要背一下优先队列的写法，有一点长。</p> 
<p>接下来看一下第二题：</p> 
<p>合并数列：</p> 
<p><img alt="" height="898" src="https://images2.imgbox.com/f2/ee/FVK8P7PL_o.png" width="1200"></p> 
<p> 这道题目的数据范围如果给的很小的话其实可以直接考虑模拟做法，但是实际上这道题目并没有那么的简单，接下来看代码，我在上面给了注释。</p> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=2e5+100;//这里的N要比序列的个数上限设置的更大
int n,len,m;//n个序列，len代表当前读入的堆的序列的个数，m是最后要输出的数字个数
struct xulie{
	int v,delta;//v代表某一序列当前的堆顶元素，delta代表对应序列的k值
}heap[N];
//对新读入的序列试着将他往上面排的函数
inline void up(int x){
	while(x&gt;1 &amp;&amp; heap[x].v&lt;=heap[x/2].v){
		swap(heap[x],heap[x/2]);
		x/=2;
	}
}
//将堆首的元素试着往下排
inline void down(int x){
	while(x+x&lt;=len){
		int y=x+x;
		if(y+1&lt;=len &amp;&amp; heap[y+1].v&lt;heap[y].v)  ++y;
		if(heap[y].v&gt;=heap[x].v) break;
		swap(heap[y],heap[x]);
		x=y;
	}
}
int main(){
   cin&gt;&gt;n;
   for(int i=1;i&lt;=n;i++){
       int k,b;
       cin&gt;&gt;k&gt;&gt;b;
       heap[++len].v=b;
       heap[len].delta=k;
       up(len);
   }
   cin&gt;&gt;m;
   for(int i=1;i&lt;=m;i++){
   	cout&lt;&lt;heap[1].v&lt;&lt;' ';
   	heap[1].v+=heap[1].delta;
   	//输出堆顶序列这时候的值之后，对该序列的v值加一个delta并将加了之后的堆顶序列试着往下排
   	down(1);
   }
   return 0;
}</code></pre> 
<p>这道题的做法还是很有意思的。</p> 
<p>接下来看一下第三个题：</p> 
<p>大富翁游戏：</p> 
<p><img alt="" height="943" src="https://images2.imgbox.com/64/f5/GGpQxnIG_o.png" width="1200"></p> 
<p> 费了九牛二虎之力，可算是搞明白了。。。</p> 
<p>代码如下：</p> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
struct Info{
	int v,pos;
}heap1[100001],heap2[100001];
int n,m,len1,len2,s1[100001],s2[100001];
inline void up1(int k){
	while(k&gt;1 &amp;&amp; heap1[k].v&lt;heap1[k/2].v){
		swap(heap1[k],heap1[k/2]);
		s1[heap1[k].pos]=k;
		s1[heap1[k/2].pos]=k/2;
		k/=2;
	}
}
inline void down1(int k){
	while(k+k&lt;=len1){
		int j=k+k;
		if(j+1&lt;=len1 &amp;&amp; heap1[j+1].v&lt;heap1[j].v)
		++j;
		if(heap1[k].v&lt;=heap1[j].v) break;
		swap(heap1[k],heap1[j]);
		s1[heap1[k].pos]=k;
		s1[heap1[j].pos]=j;
		k=j;
	}
}
inline void up2(int k){
	while(k&gt;1 &amp;&amp; heap2[k].v&gt;heap2[k/2].v){
		swap(heap2[k],heap2[k/2]);
		s2[heap2[k].pos]=k;
		s2[heap2[k/2].pos]=k/2;
		k/=2;
	}
}
inline void down2(int k){
	while(k+k&lt;=len2){
		int j=k+k;
		if(j+1&lt;=len2 &amp;&amp; heap2[j+1].v&gt;heap2[j].v)
		++j;
		if(heap2[k].v&gt;=heap2[j].v) break;
		swap(heap2[k],heap2[j]);
		s2[heap2[k].pos]=k;
		s2[heap2[j].pos]=j;
		k=j;
	}
}
int main(){
	cin&gt;&gt;n;
	len1=len2=0;
	for(int i=1;i&lt;=n;i++){
		heap1[++len1].v=100;
		heap1[len1].pos=i;
		s1[i]=len1;
		up1(len1);
		heap2[++len2].v=100;
		heap2[len2].pos=i;
		s2[i]=len2;
		up2(len2);
	}
	cin&gt;&gt;m;
	for(int i=1;i&lt;=m;i++){
		int x;
		cin&gt;&gt;x;
		if(x==1){
			int y,z;
			cin&gt;&gt;y&gt;&gt;z;
			heap1[s1[y]].v+=z;
			up1(s1[y]);
			down1(s1[y]);
			heap2[s2[y]].v+=z;
			up2(s2[y]);
			down2(s2[y]);
		}
		else{
			cout&lt;&lt;heap2[1].v&lt;&lt;' '&lt;&lt;heap1[1].v&lt;&lt;endl;
		}
	}
	return 0;
}</code></pre> 
<p>这里代码中使用了两个堆，<code>heap1</code> 和 <code>heap2</code>，分别用来维护最小堆和最大堆。<code>s1</code> 和 <code>s2</code> 数组用来记录每个人在堆中的位置。代码中的堆结构的使用主要是为了在O(log n)的时间复杂度内找到当前最高和最低资金，以提高效率。在每次资金变动后，通过调整堆，保证堆顶元素分别是当前最小和最大资金。</p> 
<p>最后一个题：动态中位数</p> 
<p><img alt="" height="707" src="https://images2.imgbox.com/f2/72/N0YM2uqi_o.png" width="1200"></p> 
<p>这里是代码：</p> 
<pre><code class="language-cpp">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
priority_queue&lt;int&gt;a,b;//这样设置的默认为大根堆不过我们只需要将大根堆中所有的元素加上一个负号就可以将大根堆变成小根堆
/*如果要直接表示为小根堆可以这么写： priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt;*/
int main(){
	cin&gt;&gt;n;
	int x;
	cin&gt;&gt;x;
	a.push(x);
	cout&lt;&lt;a.top()&lt;&lt;' ';
	for(int i=1;i&lt;=n/2;i++){
		int x,y,z=a.top();
		cin&gt;&gt;x&gt;&gt;y;
		if(x&lt;z)
		a.push(x);
		else 
		b.push(-x);
		if(y&lt;z)
		a.push(y);
		else 
		b.push(-y);
		/*接下来之所以特判3还有1两个值 是因为每次我们插入是以两个数字组成的数对进行插入到大根堆a和小根堆b之中的，请仔细理解*/
		/*其实是这样的原理：我们将两个数字插入两个堆里面那么只有三种可能，第一种就是两个堆各自插入一个进去这也是我们想看到的，再者就是两个进入一个堆里面
		这也就对应了以下特判的情况，我们将当前的i个数字的（i+1）/2插入a中将（i-1）/2插入到b中，a的堆顶就是当前我们要输出的动态中位数*/
		if(a.size()-b.size()==3){
			b.push(-a.top());
			a.pop();
		} else 
		if(b.size()-a.size()==1){
			a.push(-b.top());
			b.pop();
		}
		cout&lt;&lt;a.top()&lt;&lt;' ';
	}
	return 0;
}</code></pre> 
<p></p> 
<ol><li> <p><code>priority_queue</code> 的使用：定义了两个优先队列（堆），<code>a</code> 和 <code>b</code>。它们用于存储输入数字，其中 <code>a</code> 是最大堆，<code>b</code> 是最小堆。</p> </li><li> <p>第一个数字的处理：从输入中读取第一个数字 <code>x</code>，将其压入最大堆 <code>a</code> 中，然后输出当前中位数（即最大堆的堆顶元素）。</p> </li><li> <p>循环处理每个数字对（x，y）：</p> 
  <ul><li>如果 <code>x</code> 小于当前中位数（即最大堆的堆顶元素 <code>a.top()</code>），则将 <code>x</code> 压入最大堆 <code>a</code>。</li><li>否则，将 <code>-x</code>（<code>x</code> 的相反数）压入最小堆 <code>b</code>。</li><li>如果 <code>y</code> 小于当前中位数，则将 <code>y</code> 压入最大堆 <code>a</code>。</li><li>否则，将 <code>-y</code>（<code>y</code> 的相反数）压入最小堆 <code>b</code>。</li></ul></li><li> <p>调整堆大小：在每次插入后，检查两个堆的大小关系：</p> 
  <ul><li>如果最大堆 <code>a</code> 的大小比最小堆 <code>b</code> 大 3，将最大堆的堆顶元素弹出并压入最小堆 <code>b</code>。</li><li>如果最小堆 <code>b</code> 的大小比最大堆 <code>a</code> 大 1，将最小堆的堆顶元素弹出并取其相反数压入最大堆 <code>a</code>。</li></ul></li><li> <p>输出中位数：每次插入后，输出当前中位数（即最大堆的堆顶元素 <code>a.top()</code>）。</p> </li><li> <p>这段代码通过维护最大堆和最小堆，根据输入的数字实时调整堆，以便高效地计算中位数。在中位数的计算过程中，通过在两个堆之间调整元素，确保了两个堆的大小差距在一个合理的范围内。这样做的目的是为了避免在求中位数时需要对所有数据进行排序的开销，从而实现更加高效的中位数计算</p> </li></ol> 
<p>希望这一篇学习笔记对读者有所帮助，让我们共同进步。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cd5b10402b1fffc9182dc224573c314c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">信息检索领域的基本了解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/aff9988c118244e5c9089d7ac33580ed/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">20240107 SQL基础50题打卡</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>