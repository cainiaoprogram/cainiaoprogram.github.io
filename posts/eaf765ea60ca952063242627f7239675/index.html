<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python 之数据类型 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python 之数据类型" />
<meta property="og:description" content="文章收集于网络，如有版权，请联系作者
一、引子 1 什么是数据？
x=10，10是我们要存储的数据
2 为何数据要分不同的类型
数据是用来表示状态的，不同的状态就应该用不同的类型的数据去表示
3 数据类型
数字、字符串、列表、元组、字典、集合
二、基础数据类型 2.1 数字 int 数字主要是用于计算用的，使用方法并不是很多，就记住一种就可以：
int() 可以把其他类型转化为数字类型，并自动除去空格，但是前提是转化的数字
# bit_length() 当十进制用二进制表示时，最少使用的位数 v = 11 data = v.bit_length() print(data) 2.2 布尔值bool 布尔值就两种：True，False
真 1 True 假 0 False int:0 list:[] tuple:{} str:&#39;&#39; 转化为布尔值是False，其他的都是True 2.3 字符串str 2.3.1 字符串的索引与切片。 索引即下标，就是字符串组成的元素从第一个开始，初始索引为0，以此类推。
a = &#39;ABCDEFGHIJK&#39; print(a[0]) # A print(a[3]) # D print(a[-1]) # K 切片就是通过索引（索引：索引：步长）截取字符串的一段，形成新的字符串（原则就是顾头不顾腚）。
a = &#39;ABCDEFGHIJK&#39; print(a[0:3]) print(a[2:5]) print(a[0:]) # 默认到最后 ABCDEFGHIJK print(a[0:-1]) # -1 是列表中最后一个元素的索引，但是要满足顾头不顾腚的原则，所以取不到K元素 print(a[0:5:2]) # 加步长 ACE print(a[5:0:-2]) # 反向加步长 FDB 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/eaf765ea60ca952063242627f7239675/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-18T23:23:12+08:00" />
<meta property="article:modified_time" content="2023-01-18T23:23:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python 之数据类型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin-left:0cm;">文章收集于网络，如有版权，请联系作者</p> 
<h2 style="margin-left:0cm;">一、引子</h2> 
<p style="margin-left:0cm;">1 什么是数据？</p> 
<blockquote> 
 <p style="margin-left:0cm;">x=10，10是我们要存储的数据</p> 
</blockquote> 
<p style="margin-left:0cm;">2 为何数据要分不同的类型</p> 
<blockquote> 
 <p style="margin-left:0cm;">数据是用来表示状态的，不同的状态就应该用不同的类型的数据去表示</p> 
</blockquote> 
<p style="margin-left:0cm;">3 数据类型</p> 
<blockquote> 
 <p style="margin-left:0cm;">数字、字符串、列表、元组、字典、集合</p> 
</blockquote> 
<h2 style="margin-left:0cm;">二、基础数据类型</h2> 
<h3 style="margin-left:0cm;"><strong>2.1 </strong><strong>数字 int</strong></h3> 
<p style="margin-left:0cm;">数字主要是用于计算用的，使用方法并不是很多，就记住一种就可以：<br><strong>int() 可以把其他类型转化为数字类型，并自动除去空格，但是前提是转化的数字</strong></p> 
<pre class="has"><code># bit_length() 当十进制用二进制表示时，最少使用的位数
v = 11
data = v.bit_length()
print(data)</code></pre> 
<h3 style="margin-left:0cm;"><strong>2.2 </strong><strong>布尔值bool</strong></h3> 
<p>布尔值就两种：True，False</p> 
<pre class="has"><code>真   1   True
假   0   False

int:0   list:[]   tuple:{}   str:'' 转化为布尔值是False，其他的都是True</code></pre> 
<h3 style="margin-left:0cm;"><strong>2.3 </strong><strong>字符串str</strong></h3> 
<h4 style="margin-left:0cm;"><strong>2.3.1 </strong><strong>字符串的索引与切片。</strong></h4> 
<p><strong>索引</strong>即下标，就是字符串组成的元素从第一个开始，初始索引为0，以此类推。</p> 
<pre class="has"><code>a = 'ABCDEFGHIJK'
print(a[0])   # A
print(a[3])   # D
print(a[-1])  # K</code></pre> 
<p><strong>切片</strong>就是通过索引（索引：索引：步长）截取字符串的一段，形成新的字符串（原则就是顾头不顾腚）。</p> 
<pre class="has"><code>a = 'ABCDEFGHIJK'
print(a[0:3])
print(a[2:5])
print(a[0:])      # 默认到最后  ABCDEFGHIJK
print(a[0:-1])    # -1 是列表中最后一个元素的索引，但是要满足顾头不顾腚的原则，所以取不到K元素 
print(a[0:5:2])   # 加步长  ACE
print(a[5:0:-2])  # 反向加步长  FDB</code></pre> 
<p style="margin-left:0cm;"><strong>2.3.2</strong><strong>、字符串常用方法。</strong></p> 
<pre class="has"><code># 大小写转化 captalize,swapcase,title
name = 'flp'
print(name.capitalize())  # 首字母大写
print(name.swapcase())    # 大小写翻转
msg='i love china'
print(msg.title())        # 每个单词的首字母大写


# 内容居中 center
a1 = 'abcdefgabcd'
ret2 = a1.center(20,"*")  # 内容居中（总长度，空白处填充）
print(ret2)


# 统计字符串出现元素个数 count
ret3 = a1.count("a",0,4)  # 字符串中的元素出现的个数，可切片(元素，开始位置，结束位置)
print(ret3)


# \t补全
a2 = "hqw\t"
ret4 = a2.expandtabs()  # 默认将一个tab键变成8个空格，如果tab前面的字符长度不足8个，则补全8个，如果tab键前面的字符长度超过8个不足16个则补全16个，以此类推每次补全8个
print(ret4)


# 判断字符串开头结尾 可切片startswith，endswith
a4 = "dkfjdkfasf54"
ret4 = a4.startswith('jdk',3,6)  # 判断是否以...开头，顾头不顾腚，返回的是布尔值
print(ret4)
ret5 = a4.endswith("kfj",1,4)    # 判断是否以...结尾，顾头不顾腚，返回的是布尔值
print(ret5)


# 判断字符串中的元素是否存在 可切片find index
ret6 = a4.find("fjdk",1,6)      # 返回的找到的元素的索引，如果找不到返回-1
print(ret6)
ret61 = a4.index("fjdk",4,6)    # 返回的找到的元素的索引，找不到报错
print(ret61)
# 注：在用find判断字符不存在时，用下列的方式，因为不存在返回值是-1。
# if a4.find("fjdk",1,6) == -1


# split 分割，最终形成一个列表此列表不含有这个分割的元素。
a5 = 'title,Tilte,atre,'
ret9 = a5.split('t')
print(ret9)     # 结果['', 'i', 'le,Til', 'e,a', 're,']
ret91 = a5.rsplit('t',1)
print(ret91)    # 结果['title,Tilte,a', 're,']
ret92 = a5.rsplit('t',2)
print(ret92)    # 结果['title,Til', 'e,a', 're,']


# format的三种玩法 格式化输出
res='{} {} {}'.format('egon',18,'male')      # 结果 egon,18,male
res='{1} {0} {1}'.format('egon',18,'male')   # 结果 18,egon,18
res='{name} {age} {sex}'.format(sex='male',name='egon',age=18)


# strip切除字符串开头或结尾的字符
name='*egon**'
print(name.strip('*'))   # 切除字符串开头和结尾包含的*
print(name.lstrip('*'))  # 切除字符串开头包含的*
print(name.rstrip('*'))  # 切除字符串结尾包含的*


# replace字符串替换
name='flp China name is flp'
print(name.replace('flp','shuai',1))  #（要替换的字符串，替换成的字符串，替换的个数）


# is系列
name='flp123'
print(name.isalnum())  # 字符串由字母或数字组成，返回布尔值
print(name.isalpha())  # 字符串只由字母组成，返回布尔值
print(name.isdigit())  # 字符串只由数字组成，返回布尔值


# 判断字符串是否为空
s=' '
if s.strip()=='':
    print('s is null')
# 或者
if not s.strip():
    print('s is null')</code></pre> 
<h3 style="margin-left:0cm;"><strong> 2.4 </strong><strong>元祖tuple</strong></h3> 
<p>元组被称为只读列表，即数据可以被查询，但不能被修改，所以，字符串的切片操作同样适用于元组。例：（1，2，3）（"a","b","c"）</p> 
<h3 style="margin-left:0cm;"><strong> 2.5 </strong><strong>列表list</strong></h3> 
<p>列表是python中的基础数据类型之一，其他语言中也有类似于列表的数据类型，比如js中叫数组，他是以[]括起来，每个元素以逗号隔开，而且他里面可以存放各种数据类型比如：</p> 
<pre class="has"><code>li = [123,Ture,(1,2,3,’abc’),[1,2,3,’小明’,],{‘name’:’abc’}]</code></pre> 
<p>列表相比于字符串，不仅可以储存不同的数据类型，而且可以储存大量数据，32位python的限制是 536870912 个元素,64位python的限制是 1152921504606846975 个元素。而且列表是有序的，有索引值，可切片，方便取值。</p> 
<h4 style="margin-left:0cm;"><strong>2.5.1</strong><strong>、增</strong></h4> 
<pre class="has"><code>li = [1,'a','b',2,3,'a']
li.insert(0,55)          # 按照索引去增加
print(li)                # [55, 1, 'a', 'b', 2, 3, 'a']

li.append('aaa')         # 增加到最后
li.append([1,2,3])
print(li)                # [55, 1, 'a', 'b', 2, 3, 'a', 'aaa', [1, 2, 3]]

li.extend(['q,a,w'])     # 迭代的去增
li.extend(['q,a,w','aaa'])
li.extend('a')
li.extend('abc')
li.extend('a,b,c')
print(li)
# [55, 1, 'a', 'b', 2, 3, 'a', 'aaa', [1, 2, 3], 'q,a,w', 'q,a,w', 'aaa', 'a', 'a', 'b', 'c', 'a', ',', 'b', ',', 'c']
</code></pre> 
<h4 style="margin-left:0cm;"><strong>2.5.2</strong><strong>、删</strong></h4> 
<pre class="has"><code>li = [1,'a','b',2,3,'a']
l1 = li.pop(1)         # 按照位置去删除，有返回值，返回被删除的元素
print(l1,li)           # a [1, 'b', 2, 3, 'a']

del li[1:3]            # 按照位置去删除，也可切片删除没有返回值。
print(li)              # [1, 3, 'a']

li.remove('a')         # 按照元素去删除
print(li)              # [1, 3]

li.clear()             # 清空列表
</code></pre> 
<h4 style="margin-left:0cm;"><strong>2.5.3</strong><strong>、改</strong></h4> 
<pre class="has"><code>li = [1,'a','b',2,3,'a']
li[1] = 'dfasdfas'
print(li)             # [1, 'dfasdfas', 'b', 2, 3, 'a']

li[1:3] = ['a','b']
print(li)             # [1, 'a', 'b', 2, 3, 'a']
</code></pre> 
<h4 style="margin-left:0cm;"><strong>2.5.4</strong><strong>、查</strong></h4> 
<p>切片去查，或者循环去查。</p> 
<h4 style="margin-left:0cm;"><strong>2.5.5</strong><strong>、其他操作</strong></h4> 
<pre class="has"><code># count 统计某个元素在列表中出现的次数
a = ["q","w","q","r","t","y"] print(a.count("q"))
# index 用于从列表中找出某个值第一个匹配项的索引位置
a = ["q","w","r","t","y"] print(a.index("r")) 

# sort 用于在原位置对列表进行排序，没有返回值
a = [2,1,3,4,5] 
a.sort()        # 他没有返回值，所以只能打印排序后的a 
print(a)

# reverse 将列表中的元素反向存放，也没有返回值
a.reverse()    # 他也没有返回值，所以只能打印排序后的a 
print(a)
</code></pre> 
<h3 style="margin-left:0cm;"><strong> 2.6</strong><strong>字典dict</strong></h3> 
<p>字典是python中唯一的映射类型，采用键值对（key-value）的形式存储数据。python对key进行哈希函数运算，根据计算的结果决定value的存储地址，所以字典是<strong>无序存储</strong>的，且key必须是<strong>可哈希</strong>的。可哈希表示key必须是不可变类型，如：数字、字符串、元组。</p> 
<p>字典(dictionary)是除列表外，python之中最灵活的内置数据结构类型。列表是有序的对象结合，字典是无序的对象集合。两者之间的区别在于：字典当中的元素是通过键来存取的，而不是通过偏移存取。</p> 
<h4 style="margin-left:0cm;"><strong>2.6.1</strong><strong>、增</strong></h4> 
<pre class="has"><code>dic = {}
dic['li'] = ["a","b","c"]
print(dic)        # {'li': ['a', 'b', 'c']}
# setdefault 在字典中添加键值对，如果键对应的值是none,则添加；如果值不为空，则不会更改覆盖。
dic.setdefault('k','v')
print(dic)        # {'age': 18, 'name': 'jin', 'sex': 'male', 'k': 'v'}
dic.setdefault('k','v1')  
print(dic)        # {'age': 18, 'name': 'jin', 'sex': 'male', 'k': 'v'}
</code></pre> 
<h4 style="margin-left:0cm;"><strong>2.6.2</strong><strong>、删</strong></h4> 
<pre class="has"><code>dic_pop = dic.pop("a",'无key默认返回值') # pop根据key删除键值对，并返回对应的值，如果没有key则返回默认返回值
print(dic_pop)

del dic["name"]                         # 没有返回值。
print(dic)

dic_pop1 = dic.popitem()                # 随机删除字典中的某个键值对，将删除的键值对以元祖的形式返回
print(dic_pop1)  

dic_clear = dic.clear()                 # 清空字典
print(dic,dic_clear)                    # {} None
</code></pre> 
<p style="margin-left:0cm;"><span style="color:#f33b45;"><strong>注：在循环字典本身的时候，不能删除字典的键值对</strong></span></p> 
<h4 style="margin-left:0cm;"><strong>2.6.3</strong><strong>、改</strong></h4> 
<pre class="has"><code>dic = {"name":"jin","age":18,"sex":"male"}
dic2 = {"name":"alex","weight":75}
dic2.update(dic)      # 将dic所有的键值对覆盖添加（相同的覆盖，没有的添加）到dic2中
print(dic2)           # {'name': 'jin', 'weight': 75, 'age': 18, 'sex': 'male'}
</code></pre> 
<h4 style="margin-left:0cm;"><strong>2.6.4</strong><strong>、查</strong></h4> 
<pre class="has"><code>value1 = dic["name"]  # 没有会报错
print(value1)

value2 = dic.get("djffdsafg","默认返回值")  # 没有可以返回设定的返回值
print(value2)
</code></pre> 
<h4 style="margin-left:0cm;"><strong>2.6.5</strong><strong>、其他操作</strong></h4> 
<pre class="has"><code>item = dic.items()
print(item,type(item))  
# dict_items([('age', '18'), ('sex', 'male')) &lt;class 'dict_items'&gt;这个类型就是dict_items类型，可迭代的

keys = dic.keys()
print(keys,type(keys))      # dic的所有k

values = dic.values()
print(values,type(values))  # dic的所有值

# 字典的循环。
dic = {"age":18,"sex":"male"}
for key in dic:
    print(key)
for item in dic.items():
    print(item)
for key,value in dic.items():
    print(key,value)

# 判断值是否在字典中
if 'age' in dic.keys: 
if 'age' in dic:


# fromkeys(seq[, value]) 函数用于创建一个新字典，以序列 seq 中元素做字典的键，value 为字典所有键对应的初始值。
dict.fromkeys(seq[, value])
    seq -- 字典键值列表。
    value -- 可选参数, 设置键序列（seq）的值。

seq = ('Google', 'Runoob', 'Taobao')
dict = dict.fromkeys(seq)
print "新字典为 : %s" %  str(dict)
# 新字典为 : {'Google': None, 'Taobao': None, 'Runoob': None}

dict = dict.fromkeys(seq, 10)
print "新字典为 : %s" %  str(dict)
# 新字典为 : {'Google': 10, 'Taobao': 10, 'Runoob': 10}
</code></pre> 
<h3 style="margin-left:0cm;"><strong> 2.7 </strong><strong>集合set</strong></h3> 
<p>集合：可变的数据类型，他里面的元素必须是<span style="color:#f33b45;"><strong>不可变(可哈希)的数据类型，无序，不重复</strong></span></p> 
<p>去重：<strong>把一个列表变成集合会自动去重</strong></p> 
<p>关系测试是，测试两组数据之前的交集，差集，并集等关系</p> 
<p style="margin-left:0cm;"><strong>创建</strong></p> 
<pre class="has"><code>set1 = set(1,2,abc)</code></pre> 
<p style="margin-left:0cm;"><strong>增</strong></p> 
<pre class="has"><code>set1.add('dong')
set1.update([1,2,3])</code></pre> 
<p style="margin-left:0cm;"><strong>删</strong></p> 
<pre class="has"><code>set1.remove('a') # 删除一个元素
set1.pop('b')    # 随机删除一个，有返回值，返回值为删除的元素
set1.clear()     # 清除set
del set1         # 删除set1
</code></pre> 
<p style="margin-left:0cm;"><strong>查</strong></p> 
<pre class="has"><code>for i in set1 :
    print(i)</code></pre> 
<p style="margin-left:0cm;"><strong>关系测试</strong></p> 
<pre class="has"><code>set1 = {1,2,3,4,'a'}
set2 = {'a','b','c','d',1}
print(set1 &amp; set2)    
print(set1.intersection(set2)) # 交集{1, 'a'}

print(set1 | set2)    
print(set2.union(set1))        # 并集{1, 2, 3, 4, 'd', 'b', 'c', 'a'}

print(set1 - set2)    
print(set1.symmetric_difference(set2)) # 差集，set1独有的{2, 3, 4}
 
print(set1 ^ set2)    
print(set1.difference(set2))   # 反交集{2, 3, 4, 'c', 'd', 'b'}

print(set1 &gt; set2)    
print(set1.issubset(set2))     # 这两个相同，都是说明set1是set2子集。

print(set2 &lt; set2)
print(set2.issuperset(set1))   # 这两个相同，都是说明set2是set1超集。
</code></pre> 
<h2 style="margin-left:0cm;"><strong>三丶基础数据类型的总结</strong></h2> 
<p style="margin-left:0cm;"><strong>按存储空间的占用分（从低到高）</strong></p> 
<blockquote> 
 <p style="margin-left:0cm;">数字</p> 
 <p style="margin-left:0cm;">字符串</p> 
 <p style="margin-left:0cm;">集合：无序，即无序存索引相关信息</p> 
 <p style="margin-left:0cm;">元组：有序，需要存索引相关信息，不可变</p> 
 <p style="margin-left:0cm;">列表：有序，需要存索引相关信息，可变，需要处理数据的增删改</p> 
 <p style="margin-left:0cm;">字典：无序，需要存key与value映射的相关信息，可变，需要处理数据的增删改</p> 
</blockquote> 
<p style="margin-left:0cm;"><strong>按存值个数区分</strong></p> 
<table><tbody><tr><td> <p style="margin-left:0cm;">标量／原子类型</p> </td><td> <p style="margin-left:0cm;">数字，字符串</p> </td></tr><tr><td> <p style="margin-left:0cm;">容器类型</p> </td><td> <p style="margin-left:0cm;">列表，元组，字典</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"><strong>按可变不可变区分</strong></p> 
<table><tbody><tr><td> <p style="margin-left:0cm;">可变</p> </td><td> <p style="margin-left:0cm;">列表，字典</p> </td></tr><tr><td> <p style="margin-left:0cm;">不可变</p> </td><td> <p style="margin-left:0cm;">数字，字符串，元组，布尔值</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"><strong>按访问顺序区分</strong></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td> <p style="margin-left:0cm;">直接访问</p> </td><td> <p style="margin-left:0cm;">数字</p> </td></tr><tr><td> <p style="margin-left:0cm;">顺序访问（序列类型）</p> </td><td> <p style="margin-left:0cm;">字符串，列表，元组</p> </td></tr><tr><td> <p style="margin-left:0cm;">key值访问（映射类型）</p> </td><td> <p style="margin-left:0cm;">字典</p> </td></tr></tbody></table> 
<h2 style="margin-left:0cm;"><strong>四丶其他（for，enumerate，range）</strong></h2> 
<p style="margin-left:0cm;"><strong>for</strong><strong>循环</strong>：用户按照顺序循环可迭代对象的内容。</p> 
<pre class="has"><code>msg = 'Lepeng最帅'
for item in msg:
    print(item)

li = ['赵','钱','孙','李']
for i in li:
    print(i)

dic = {'name':'Lepeng','age':18,'sex':'man'}
for k,v in dic.items():
    print(k,v)
</code></pre> 
<p style="margin-left:0cm;"><strong>enumerate</strong>：枚举，对于一个可迭代的（iterable）/可遍历的对象（如列表、字符串），enumerate将其组成一个索引序列，利用它可以同时获得索引和值。</p> 
<pre class="has"><code>li = ['赵','钱','孙','李']
for i in enumerate(li):
    print(i)
for index, name in enumerate(li, 100):  # 起始位置默认是0，可更改
    print(index, name)
# 100 赵
# 101 钱
# 102 孙
# 103 李
</code></pre> 
<p style="margin-left:0cm;"><strong>range</strong>：指定范围，生成指定数字。</p> 
<pre class="has"><code>for i in range(1,10):
    print(i)

for i in range(1,10,2):  # 步长
    print(i)
</code></pre> 
<p style="margin-left:0cm;"><strong>join</strong><strong>：</strong>用于将序列中的元素以指定的字符连接生成一个新的字符串。</p> 
<blockquote> 
 <p style="margin-left:0cm;">语法：  'sep'.join(seq)</p> 
 <p style="margin-left:0cm;">参数说明</p> 
 <p style="margin-left:0cm;">sep：分隔符，可以为空</p> 
 <p style="margin-left:0cm;">seq：要连接的元素序列、字符串、元组、字典</p> 
 <p style="margin-left:0cm;">上面的语法即：以sep作为分隔符，将seq所有的元素合并成一个新的字符串,然后返回</p> 
</blockquote> 
<pre class="has"><code>示例
s1 = "-"
s2 = ""
seq = ("r", "u", "n", "o", "o", "b") # 字符串序列
print (s1.join( seq ))    # r-u-n-o-o-b
print (s2.join( seq ))    # runoob
</code></pre> 
<h2 style="margin-left:0cm;"><strong>五，判断是否是字符串，字典等（isinstance）</strong></h2> 
<p style="margin-left:0cm;">在实际写程序中，经常要对变量类型进行判断，除了用type(变量)这种方法外，还可以用isinstance方法判断：</p> 
<pre class="has"><code>#!/usr/bin/env python
a = 1
b = [1,2,3,4]
c = (1,2,3,4)
d = {'a':1,'b':2,'c':3}
e = "abc"
if isinstance(a,int):
    print "a is int"
else:
    print "a is not int"
if isinstance(b,list):
    print "b is list"
else:
    print "b is not list"
if isinstance(c,tuple):
    print "c is tuple"
else:
    print "c is not tuple"
if isinstance(d,dict):
    print "d is dict"
else:
    print "d is not dict"
if isinstance(e,str):
    print "d is str"
else:
    print "d is not str"
</code></pre> 
<h2 style="margin-left:0cm;"><strong>六丶相互转化</strong></h2> 
<pre class="has"><code># 1、字典
dict1 = {'name': 'Zara', 'age': 7, 'class': 'First'}
# 字典转为字符串，返回：&lt;type 'str'&gt; {'age': 7, 'name': 'Zara', 'class': 'First'}
print(type(str(dict1)), str(dict1))
# 字典可以转为元组，返回：('age', 'name', 'class')
print(tuple(dict1))
# 字典可以转为元组，返回：(7, 'Zara', 'First')
print(tuple(dict1.values()))
# 字典转为列表，返回：['age', 'name', 'class']
print(list(dict1))
# 字典转为列表，返回：['Zara', 7, 'First']
print(list(dict1.values()))

# 2、元组
tup=(1, 2, 3, 4, 5)
# 元组转为字符串，返回：(1, 2, 3, 4, 5)
print(tup.__str__())
# 元组转为列表，返回：[1, 2, 3, 4, 5]
print(list(tup))
# 元组不可以转为字典

# 3、列表
nums=[1, 3, 5, 7, 8, 13, 20];
# 列表转为字符串，返回：[1, 3, 5, 7, 8, 13, 20]
print(str(nums))
# 列表转为元组，返回：(1, 3, 5, 7, 8, 13, 20)
print(tuple(nums))
# 列表不可以转为字典

# 4.1、字符串之eval函数，此函数有风险，需慎用，此函数的参数可以是系统命令，所以会存在风险
# 字符串转为元组，前提是字符串像元组,返回：(1, 2, 3)
print(eval("(1,2,3)"))
# 字符串转为列表，前提是字符串像列表,返回：[1, 2, 3]
print(eval("[1,2,3]"))
# 字符串转为字典，前提是字符串像字典,返回：{'name': 'ljq', 'age': 24}
print(eval("{'name':'ljq', 'age':24}"))

# 4.2、字符串转换其他方式
# 字符串转为列表，结果['', 'i', 'le,Til', 'e,a', 're,']
a5 = 'title,Tilte,atre,'
print(a5.split('t'))

# 字符串转为字典
s = "Name1=Value1;Name2=Value2;Name3=Value3"
d = dict(item.split("=") for item in s.split(";"))
print(d)
# 结果为dict = { "Name1": "Value1", "Name2": "Value2", "Name3": "Value3" }，
# 注意s结尾不能是;如果是，用s.rstrip(';')</code></pre> 
<h2 style="margin-left:0cm;">七，注意事项</h2> 
<p>如果元组只有一个元素，如果不加逗号，此元素是什么类型，则就是什么类型，如果元组只用（）表示，也不存在此情况；list，字典不存在此情况</p> 
<pre class="has"><code>tu1 = ()             # &lt;class ''tuple'&gt;
tu2 = (1)            # &lt;class 'int'&gt;
tu3 = (1,)           # &lt;class 'tuple'&gt;

list1 = ['a']        # &lt;class 'list'&gt;
list2 = []           # &lt;class 'list'&gt;</code></pre> 
<h2 style="margin-left:0cm;">八丶深浅copy</h2> 
<h4 style="margin-left:0cm;">1，先看赋值运算</h4> 
<pre class="has"><code>l1 = [1,2,3,['AB','ab']]
l2 = l1

l1[0] = 111
print(l1)    # [111, 2, 3, ['AB', 'ab']]
print(l2)    # [111, 2, 3, ['AB, 'ab']]

l1[3][0] = 'EEE'
print(l1)    # [111, 2, 3, ['EEE', 'ab']]
print(l2)    # [111, 2, 3, ['EEE', 'ab']]</code></pre> 
<p>对于赋值运算来说，l1与l2指向的是同一个<span style="color:#f33b45;"><strong>内存地址</strong>，所以他们是完全一样的。</span></p> 
<h4 style="margin-left:0cm;">2，浅拷贝copy</h4> 
<pre class="has"><code># 同一代码块下：
l1 = [1, 'abc', True, (1,2,3), [22, 33]]
l2 = l1.copy()
print(id(l1), id(l2))          # 2713214468360 2713214524680 不同
print(id(l1[-2]), id(l2[-2]))  # 2547618888008 2547618888008 相同
print(id(l1[-1]),id(l2[-1]))   # 2547620322952 2547620322952 相同

# 不同代码块下：
l1 = [1, 'abc', True, (1, 2, 3), [22, 33]]
l2 = l1.copy()
print(id(l1), id(l2))         # 1477183162120 1477183162696 不同
print(id(l1[-2]), id(l2[-2])) # 1477181814032 1477181814032 相同
print(id(l1[-1]), id(l2[-1])) # 1477183162504 1477183162504 相同</code></pre> 
<p>对于浅copy来说，只是在内存中重新创建了开辟了一个空间存放一个新列表，但是<span style="color:#f33b45;"><strong>新列表中的元素与原列表中的元素是公用的</strong></span><span style="color:#0000ff;">。</span></p> 
<h4 style="margin-left:0cm;">3，深拷贝deepcopy。</h4> 
<pre class="has"><code># 同一代码块下
import copy
l1 = [1, 'abc', True, (1,2,3), [22, 33]]
l2 = copy.deepcopy(l1)
print(id(l1), id(l2))         # 2788324482440 2788324483016 不同
print(id(l1[0]),id(l2[0]))    # 1470562768 1470562768 相同
print(id(l1[-1]),id(l2[-1]))  # 2788324482632 2788324482696 不同
print(id(l1[-2]),id(l2[-2]))  # 2788323047752 2788323047752 相同

# 不同代码块下
import copy
l1 = [1, 'abc', True, (1, 2, 3), [22, 33]]
l2 = copy.deepcopy(l1)
print(id(l1), id(l2))         # 1477183162824 1477183162632 不同
print(id(0), id(0))           # 1470562736 1470562736 相同
print(id(-2), id(-2))         # 1470562672 1470562672 相同
print(id(l1[-1]), id(l2[-1])) # 1477183162120 1477183162312 不同</code></pre> 
<p>对于深copy来说，列表是在内存中重新创建的，列表中<span style="color:#f33b45;"><strong>可变的数据类型是重新创建的，列表中的不可变的数据类型是公用的</strong></span><span style="color:#0000ff;">。</span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/961f9fea417679de6a8afa96f2f8e648/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">sklearn的mnist_784数据集可视化代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0ad74403e9b6f7208ccb4f5c784012f8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">微服务循环依赖调用引发的血案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>