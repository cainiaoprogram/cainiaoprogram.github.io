<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RBMQ消息的消费,确认,防丢失 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RBMQ消息的消费,确认,防丢失" />
<meta property="og:description" content="RBMQ消息的消费,确认,防丢失 参考翻译自: RabbitMQ官网
向多消费者分发消息 当有多个消费者时:
使用Round-robin方法,也就是循环发送,一个消息发送给一个消费者,下一条消息发送给下一个消费者,依次循环.每个消息只发送给一个消费者 消息确认机制 每个消费者消费后,需要反馈给MQ,确认消息已经被消费,MQ可以删除掉如果一个消费者挂掉(channel关闭,connection 关闭,或者TCP连接丢失),MQ便会得知消费者挂掉,如果此时还有别的消费者,MQ将消息发给存活的消费者消费者消费消息没有超时的概念,消费者处理一条消息不管都长时间只要没有挂掉,MQ都不会重发消息确认消息必须和接收消息是同一个channel,如果使用不同的channel确认消息,会引发channel-level protocol exception 如果忘记确认消息,MQ将会吃掉很大的内存来维持未确认的消息,而且一旦一个消费者挂掉,那么它没有确认的消息会再次发给其他消费者.
可以通过使用rabbitmqctl打印为确认的消息:
sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged 消息防丢 当MQ宕机时,内存中的消息队列和消息会丢失,为了避免可以通过设置避免队列和消息丢失
避免队列丢失 声明队列时,设置durable为true
boolean durable = true; channel.queueDeclare(&#34;hello&#34;, durable, false, false, null); 一个队列只有在第一次声明的时候,设置的参数才起作用,当对一个已经存在的消息队列再次声明,设置参数的时候,不会起作用.
避免消息丢失 通过设置MessageProperties的值为PERSISTENT_TEXT_PLAIN将消息持久化:
channel.basicPublish(&#34;&#34;, &#34;task_queue&#34;, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes()); 消息持久化到磁盘,并不能完全避免消息丢失,因为在写到磁盘时也有缓存.
均匀分发消息(Fair dispatch) 当MQ中消息有的容易处理,有的处理慢,会导致个别的消费者的压力大,比如第一个,第三个等消息处理起来慢,如果有两个消费者,这样会导致第一个消费者压力大,为了避免这样情况,可以通过设置参数,只有消费者消费完一个消息才会给它再分发消息:
int prefetchCount = 1; channel.basicQos(prefetchCount); 队列大小
如果所有消费者都慢,会导致队列消息满了,此时需要增加消费者或者使用其他策略" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1dafb629c430b911c38a64e89686361c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-19T17:49:30+08:00" />
<meta property="article:modified_time" content="2018-10-19T17:49:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RBMQ消息的消费,确认,防丢失</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="RBMQ_0"></a>RBMQ消息的消费,确认,防丢失</h2> 
<p>参考翻译自: <a href="https://www.rabbitmq.com/tutorials/tutorial-three-java.html" rel="nofollow">RabbitMQ官网</a></p> 
<hr> 
<h3><a id="_4"></a>向多消费者分发消息</h3> 
<p>当有多个消费者时:</p> 
<ol><li>使用Round-robin方法,也就是循环发送,一个消息发送给一个消费者,下一条消息发送给下一个消费者,依次循环.</li><li>每个消息只发送给一个消费者</li></ol> 
<h3><a id="_9"></a>消息确认机制</h3> 
<ol><li>每个消费者消费后,需要反馈给MQ,确认消息已经被消费,MQ可以删除掉</li><li>如果一个消费者挂掉(channel关闭,connection 关闭,或者TCP连接丢失),MQ便会得知消费者挂掉,如果此时还有别的消费者,MQ将消息发给存活的消费者</li><li>消费者消费消息没有超时的概念,消费者处理一条消息不管都长时间只要没有挂掉,MQ都不会重发消息</li><li>确认消息必须和接收消息是同一个channel,如果使用不同的channel确认消息,会引发channel-level protocol exception</li></ol> 
<blockquote> 
 <p>如果忘记确认消息,MQ将会吃掉很大的内存来维持未确认的消息,而且一旦一个消费者挂掉,那么它没有确认的消息会再次发给其他消费者.</p> 
</blockquote> 
<blockquote> 
 <p>可以通过使用<code>rabbitmqctl</code>打印为确认的消息:</p> 
</blockquote> 
<pre><code>sudo rabbitmqctl list_queues name messages_ready messages_unacknowledged
</code></pre> 
<h3><a id="_21"></a>消息防丢</h3> 
<p>当MQ宕机时,内存中的消息队列和消息会丢失,为了避免可以通过设置避免队列和消息丢失</p> 
<h4><a id="_23"></a>避免队列丢失</h4> 
<p>声明队列时,设置<code>durable</code>为<code>true</code></p> 
<pre><code>boolean durable = true;
channel.queueDeclare("hello", durable, false, false, null);
</code></pre> 
<blockquote> 
 <p>一个队列只有在第一次声明的时候,设置的参数才起作用,当对一个已经存在的消息队列再次声明,设置参数的时候,不会起作用.</p> 
</blockquote> 
<h4><a id="_31"></a>避免消息丢失</h4> 
<p>通过设置<code>MessageProperties</code>的值为<code>PERSISTENT_TEXT_PLAIN</code>将消息持久化:</p> 
<pre><code>channel.basicPublish("", "task_queue",
            MessageProperties.PERSISTENT_TEXT_PLAIN,
            message.getBytes());
</code></pre> 
<blockquote> 
 <p>消息持久化到磁盘,并不能完全避免消息丢失,因为在写到磁盘时也有缓存.</p> 
</blockquote> 
<h3><a id="Fair_dispatch_39"></a>均匀分发消息(Fair dispatch)</h3> 
<p>当MQ中消息有的容易处理,有的处理慢,会导致个别的消费者的压力大,比如第一个,第三个等消息处理起来慢,如果有两个消费者,这样会导致第一个消费者压力大,为了避免这样情况,可以通过设置参数,只有消费者消费完一个消息才会给它再分发消息:</p> 
<pre><code>int prefetchCount = 1;
channel.basicQos(prefetchCount);
</code></pre> 
<blockquote> 
 <p>队列大小<br> 如果所有消费者都慢,会导致队列消息满了,此时需要增加消费者或者使用其他策略</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/37569f2bded5e02f97a163fac4d176f8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">RBMQ发布和订阅消息</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1d91add302fe676391e410941ba6e0e9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">influxDB的端口和配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>