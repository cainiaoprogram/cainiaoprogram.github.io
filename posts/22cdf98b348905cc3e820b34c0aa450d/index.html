<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>用可视化案例讲Rust编程2. 编码的核心组成：函数 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="用可视化案例讲Rust编程2. 编码的核心组成：函数" />
<meta property="og:description" content="从第一天学习编程，可能大家就听说这样的组成公式：
程序=算法&#43;数据结构
——该公式出自著名计算机科学家沃思(Nikiklaus Wirth)
实际上，程序除了以上两个主要要素之外，还应当采用结构化程序设计方法进行程序设计，并且用某一种计算机语言表示。因此，算法、数据结构、程序设计方法和语言工具4个方面是一个程序设计人员所应具备的知识。
所以，要学习组成程序的最重要的具现化方式，就是计算机语言。计算机语言则以是语句 &#43; 表达式为原子所组成逻辑集合体；最基础的逻辑集合体，就是函数。
官方的说法：
计算机是一个固定的一个程序段，或称其为一个子程序，它在可以实现固定运算功能的同时，还带有一个入口和一个出口，所谓的入口，就是函数所带的各个参数，我们可以通过这个入口，把函数的参数值代入子程序，供计算机处理；所谓出口，就是指函数的函数值，在计算机求得之后，由此口带回给调用它的程序。
所以，我们在学习Rust的时候，不要被哪些天花乱坠的特性、泛型、生命周期给弄傻，要学习，先去翻函数，学习怎么写函数，一个函数解决一个问题。
同样，去读大神代码的时候，也别一爬起来就去读整体架构设计，安心去读他最底层的实现，如果读不懂，可以借助GPT一类的工具，让它给你讲讲，如下所示：
效果那是极好的。
下面针对我们上篇文章那个可视化的需求，我们来写个简单函数来实现一下：
需求：读取一个shapefile文件，把这个shapefile文件中的几何信息绘制到地图上。
初学版设计思路：
函数名：draw_shp输入参数：shapefile的路径输出：直接显示地图。需要用的到的包： shapefile：读取shp文件plotly：绘图geo_types：序列化几何对象 编码实现设计： ###在Cargo.toml文件里面，导入需要的包： //Cargo.toml //后面的features特性，暂时不用去管，这是一种Rust特有的编译特性 plotly = { version = &#34;0.8.4&#34;, features = [&#34;kaleido&#34;] } shapefile = {version = &#34;0.5.0&#34;, features = [&#34;geo-types&#34;]} geo-types = &#34;0.7.12&#34; 读取一个shapefile，并且把几何信息给获取出来。 在Rust中，可以通过shapefile包来读取shapefile，实现如下：
let shp = shapefile::read_as::&lt;_, shapefile::Polygon, shapefile::dbase::Record&gt;( &#34;./data/shp/北京行政区划.shp&#34;, ).expect(&amp;format!(&#34;Could not open polygon-shapefile: &#39;./data/shp/北京行政区划.shp&#39;&#34;)); 接下去，需要把里面的geometry信息给取出来：
//定义一个集合，通过文件迭代器，把geometry部分转换成polygon，然后加入到这个几何里面去。 let mut polygons:Vec&lt;Polygon&gt; = Vec::new(); for (polygon, polygon_record) in shp { let geo_mpolygon: geo_types::MultiPolygon&lt;f64&gt; = polygon." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/22cdf98b348905cc3e820b34c0aa450d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-10T17:08:18+08:00" />
<meta property="article:modified_time" content="2024-01-10T17:08:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">用可视化案例讲Rust编程2. 编码的核心组成：函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>从第一天学习编程，可能大家就听说这样的组成公式：</p> 
<p><strong>程序=算法+数据结构</strong></p> 
<p>——该公式出自著名计算机科学家沃思(Nikiklaus Wirth)</p> 
<p>实际上，程序除了以上两个主要要素之外，还应当采用结构化程序设计方法进行程序设计，并且用某一种计算机语言表示。因此，算法、数据结构、程序设计方法和语言工具4个方面是一个程序设计人员所应具备的知识。</p> 
<p>所以，要学习组成程序的最重要的具现化方式，就是计算机语言。计算机语言则以是<code>语句</code> + <code>表达式</code>为原子所组成逻辑集合体；最基础的逻辑集合体，就是函数。</p> 
<p>官方的说法：</p> 
<blockquote> 
 <p>计算机是一个固定的一个程序段，或称其为一个子程序，它在可以实现固定运算功能的同时，还带有一个入口和一个出口，所谓的入口，就是函数所带的各个参数，我们可以通过这个入口，把函数的参数值代入子程序，供计算机处理；所谓出口，就是指函数的函数值，在计算机求得之后，由此口带回给调用它的程序。</p> 
</blockquote> 
<p>所以，我们在学习Rust的时候，不要被哪些天花乱坠的特性、泛型、生命周期给弄傻，要学习，先去翻函数，学习怎么写函数，一个函数解决一个问题。</p> 
<p>同样，去读大神代码的时候，也别一爬起来就去读整体架构设计，安心去读他最底层的实现，如果读不懂，可以借助GPT一类的工具，让它给你讲讲，如下所示：</p> 
<p></p> 
<p class="img-center"><img alt="img" height="719" src="https://images2.imgbox.com/ae/85/T2c5oTqV_o.png" width="1133"></p> 
<p>效果那是极好的。</p> 
<p></p> 
<p class="img-center"><img alt="img" height="198" src="https://images2.imgbox.com/50/4a/HbSi3v7c_o.jpg" width="183"></p> 
<p>下面针对我们上篇文章那个可视化的需求，我们来写个简单函数来实现一下：</p> 
<p>需求：读取一个shapefile文件，把这个shapefile文件中的几何信息绘制到地图上。</p> 
<p>初学版设计思路：</p> 
<ul><li>函数名：draw_shp</li><li>输入参数：shapefile的路径</li><li>输出：直接显示地图。</li><li>需要用的到的包： 
  <ul><li>shapefile：读取shp文件</li><li>plotly：绘图</li><li>geo_types：序列化几何对象 编码实现设计： ###在Cargo.toml文件里面，导入需要的包：</li></ul></li></ul> 
<pre>//Cargo.toml
//后面的features特性，暂时不用去管，这是一种Rust特有的编译特性
plotly = { version = "0.8.4", features = ["kaleido"] }
shapefile = {version = "0.5.0", features = ["geo-types"]}
geo-types = "0.7.12"</pre> 
<h4>读取一个shapefile，并且把几何信息给获取出来。</h4> 
<p>在Rust中，可以通过shapefile包来读取shapefile，实现如下：</p> 
<pre>let shp = shapefile::read_as::&lt;_,
        shapefile::Polygon, shapefile::dbase::Record&gt;(
            "./data/shp/北京行政区划.shp",
    ).expect(&amp;format!("Could not open polygon-shapefile: './data/shp/北京行政区划.shp'"));</pre> 
<p>接下去，需要把里面的geometry信息给取出来：</p> 
<pre>//定义一个集合，通过文件迭代器，把geometry部分转换成polygon，然后加入到这个几何里面去。
let mut polygons:Vec&lt;Polygon&gt; = Vec::new();
for (polygon, polygon_record) in shp {
    let geo_mpolygon: geo_types::MultiPolygon&lt;f64&gt; = polygon.into();
    for poly in geo_mpolygon.iter(){
        polygons.push(poly.to_owned());
    }
}</pre> 
<h4>把这个polygon集合，绘制到plotly上去</h4> 
<p>首先plotly绘制几何图形，是按照坐标来的，一系列坐标组成一个绘图元素，代码如下：</p> 
<ul><li>注1：plotly的地图绘制用的是mapbox的api，所以是先维度lat，再经度lon，得反过来。</li><li>注2：trace是plotly绘图的基本元素，这里每个几何要素（如一个面），就可以构建一个trace，如果可以设置为一个颜色，也可以绘制为不同的颜色。</li></ul> 
<pre>let mut trace_vec = Vec::new();
    for ps in polygons{
        let mut lon:Vec&lt;f64&gt; = Vec::new();
        let mut lat:Vec&lt;f64&gt; = Vec::new();
        for p in ps.exterior(){
            lon.push(p.x);
            lat.push(p.y);
        }
        let trace = ScatterMapbox::new(lat, lon).mode(Mode::None)
        .fill(plotly::scatter_mapbox::Fill::ToSelf)
        .fill_color(Rgba::new(0,0,255,0.5));
        trace_vec.push(trace);
    }</pre> 
<h4>获得基本地图的配置</h4> 
<ul><li>可以看见这里用的是mapbox的地图，默认的风格为无背景的白板，默认的中心位置是东经116.3,北纬39.9，默认地图放大等级是9级。这些信息都是地图的初始化的默认配置。</li></ul> 
<pre>let layout = Layout::new()
    .drag_mode(DragMode::Zoom)
    .margin(Margin::new().top(10).left(10).bottom(10).right(10))
    .width(1024)
    .height(700)
    .mapbox(
        Mapbox::new()
            .style(MapboxStyle::WhiteBg)
            .center(Center::new(39.9, 116.3))
            .zoom(9),
    )</pre> 
<h4>最后绘制显示地图</h4> 
<pre>let mut plot = Plot::new();
plot.set_layout(layout);
for t in trace_vec.iter(){
    plot.add_trace(t.to_owned());
}
plot.show();</pre> 
<p>全部代码，放到一个function里面，如下所示：</p> 
<p></p> 
<p class="img-center"><img alt="img" height="1159" src="https://images2.imgbox.com/f9/59/gTdvyUlR_o.png" width="1200"></p> 
<p>然后写个测试方法运行一下：</p> 
<p></p> 
<p class="img-center"><img alt="img" height="448" src="https://images2.imgbox.com/af/09/fVTamPXE_o.png" width="768"></p> 
<p>运行结果：</p> 
<p></p> 
<p class="img-center"><img alt="img" height="858" src="https://images2.imgbox.com/c6/e8/7C5y9ntt_o.png" width="1126"></p> 
<p>现在看起来，是不是很简单了，对比Python实际上也没有多出几行代码，直接阅读过去，除了一些定义类型和转换类型的时候，比Python更加严格以外，会Python的同学，几乎可以完全能够看懂。</p> 
<p>——所以说，你完全可以把Rust当成一个类型严格版本的Python就阔以了……</p> 
<p></p> 
<p class="img-center"><img alt="img" height="223" src="https://images2.imgbox.com/b5/16/7yi7P42U_o.jpg" width="230"></p> 
<p>不过，对于写过工程性质代码的同学看完，肯定会觉得这个代码写的太粗糙了，所有步骤都混在一起，内容全部写死，而且无法复用……</p> 
<p>没错，初学者该有的毛病，这里都有，虽然功能实现了，但是根本只是一个demo，无法达到工程级的应用，所以从下一节开始，我们就会针对这个功能，按Rust的编码风格，去抽象和重构，最后完成一个工程级的可视化应用模块。</p> 
<p>待续未完……</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/51b3b23a8a9687e670579d20d6a267b6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【操作系统进程树变化】</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/97f4f67071939df289041f96e11cdfcb/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MentionElement是什么</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>