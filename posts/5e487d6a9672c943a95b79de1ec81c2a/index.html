<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>go 进阶 go-zero相关: 二. 服务启动与路由,中间件注册,请求接收底层原理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="go 进阶 go-zero相关: 二. 服务启动与路由,中间件注册,请求接收底层原理" />
<meta property="og:description" content="目录 一. 问题概述二. 底层源码分析涉及到的一些结构体简介初始化中间件的预设置路由注册与中间件的处理启动服务到触发net/http接收请求的处理 三. 总结 一. 问题概述 了解go-zero底层也是基于net/http标准库实现http的,是怎么实现的,怎么触发到net/http的go-zero也是基于前缀树进行路由注册的,是怎么注册的,注册过程中有哪些注意点go-zero中支持中间件, 在服务启动时,中间件,路由是如何保存的,接收请求时是如何执行的先看一下基础go-zero服务示例 package main import ( &#34;fmt&#34; &#34;github.com/zeromicro/go-zero/rest/chain&#34; &#34;github.com/zeromicro/go-zero/rest/httpx&#34; &#34;github.com/zeromicro/go-zero/core/logx&#34; &#34;github.com/zeromicro/go-zero/core/service&#34; &#34;github.com/zeromicro/go-zero/rest&#34; &#34;log&#34; &#34;net/http&#34; ) func main() { //1.创建服务句柄 //此处也可以替换为通过conf/MustLoad()加载yaml,通过rest/MustNewServer()创建服务 srv, err := rest.NewServer(rest.RestConf{ Port: 8080, // 侦听端口 ServiceConf: service.ServiceConf{ Log: logx.LogConf{Path: &#34;./logs&#34;}, // 日志路径 }, }) if err != nil { log.Fatal(err) } defer srv.Stop() //2.使用server上的Use()方法添加全局中间件 srv.Use(func(next http.HandlerFunc) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { // 在请求处理前执行一些逻辑 fmt.Println(&#34;before request&#34;) // 调用下一个处理函数 next(w, r) // 在请求处理后执行一些逻辑 fmt." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5e487d6a9672c943a95b79de1ec81c2a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-30T15:02:45+08:00" />
<meta property="article:modified_time" content="2023-06-30T15:02:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">go 进阶 go-zero相关: 二. 服务启动与路由,中间件注册,请求接收底层原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#__1" rel="nofollow">一. 问题概述</a></li><li><a href="#__126" rel="nofollow">二. 底层源码分析</a></li><li><ul><li><a href="#_127" rel="nofollow">涉及到的一些结构体简介</a></li><li><a href="#_207" rel="nofollow">初始化</a></li><li><a href="#_230" rel="nofollow">中间件的预设置</a></li><li><a href="#_265" rel="nofollow">路由注册与中间件的处理</a></li><li><a href="#nethttp_592" rel="nofollow">启动服务到触发net/http</a></li><li><a href="#_677" rel="nofollow">接收请求的处理</a></li></ul> 
  </li><li><a href="#__726" rel="nofollow">三. 总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="__1"></a>一. 问题概述</h2> 
<ol><li>了解go-zero底层也是基于net/http标准库实现http的,是怎么实现的,怎么触发到net/http的</li><li>go-zero也是基于前缀树进行路由注册的,是怎么注册的,注册过程中有哪些注意点</li><li>go-zero中支持中间件, 在服务启动时,中间件,路由是如何保存的,接收请求时是如何执行的</li><li>先看一下基础go-zero服务示例</li></ol> 
<pre><code class="prism language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token punctuation">(</span>
	<span class="token string">"fmt"</span>
	<span class="token string">"github.com/zeromicro/go-zero/rest/chain"</span>
	<span class="token string">"github.com/zeromicro/go-zero/rest/httpx"</span>
	<span class="token string">"github.com/zeromicro/go-zero/core/logx"</span>
	<span class="token string">"github.com/zeromicro/go-zero/core/service"</span>
	<span class="token string">"github.com/zeromicro/go-zero/rest"</span>
	<span class="token string">"log"</span>
	<span class="token string">"net/http"</span>
<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//1.创建服务句柄</span>
	<span class="token comment">//此处也可以替换为通过conf/MustLoad()加载yaml,通过rest/MustNewServer()创建服务</span>
	srv<span class="token punctuation">,</span> err <span class="token operator">:=</span> rest<span class="token punctuation">.</span><span class="token function">NewServer</span><span class="token punctuation">(</span>rest<span class="token punctuation">.</span>RestConf<span class="token punctuation">{<!-- --></span>
		Port<span class="token punctuation">:</span> <span class="token number">8080</span><span class="token punctuation">,</span> <span class="token comment">// 侦听端口</span>
		ServiceConf<span class="token punctuation">:</span> service<span class="token punctuation">.</span>ServiceConf<span class="token punctuation">{<!-- --></span>
			Log<span class="token punctuation">:</span> logx<span class="token punctuation">.</span>LogConf<span class="token punctuation">{<!-- --></span>Path<span class="token punctuation">:</span> <span class="token string">"./logs"</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token comment">// 日志路径</span>
		<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">defer</span> srv<span class="token punctuation">.</span><span class="token function">Stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">//2.使用server上的Use()方法添加全局中间件</span>
	srv<span class="token punctuation">.</span><span class="token function">Use</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>next http<span class="token punctuation">.</span>HandlerFunc<span class="token punctuation">)</span> http<span class="token punctuation">.</span>HandlerFunc <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 在请求处理前执行一些逻辑</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"before request"</span><span class="token punctuation">)</span>
			<span class="token comment">// 调用下一个处理函数</span>
			<span class="token function">next</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
			<span class="token comment">// 在请求处理后执行一些逻辑</span>
			fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"after request"</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>

	<span class="token comment">//2.注册路由</span>
	srv<span class="token punctuation">.</span><span class="token function">AddRoutes</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>rest<span class="token punctuation">.</span>Route<span class="token punctuation">{<!-- --></span>
		<span class="token punctuation">{<!-- --></span>
			Method<span class="token punctuation">:</span>  http<span class="token punctuation">.</span>MethodGet<span class="token punctuation">,</span>
			Path<span class="token punctuation">:</span>    <span class="token string">"/user/info"</span><span class="token punctuation">,</span>
			Handler<span class="token punctuation">:</span> userInfo<span class="token punctuation">,</span>
		<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>

	<span class="token comment">//===================下方是一些路由分组,中间件注册,拦截器注册的示例,不是真实代码会报错,使用时直接删除即可===============================</span>
	<span class="token comment">//3.路由分组示例只是示例会报错</span>
	srv<span class="token punctuation">.</span><span class="token function">AddRoutes</span><span class="token punctuation">(</span>
		<span class="token punctuation">[</span><span class="token punctuation">]</span>rest<span class="token punctuation">.</span>Route<span class="token punctuation">{<!-- --></span>
			<span class="token punctuation">{<!-- --></span>
				Method<span class="token punctuation">:</span>  http<span class="token punctuation">.</span>MethodPost<span class="token punctuation">,</span>
				Path<span class="token punctuation">:</span>    <span class="token string">"/afsdfa"</span><span class="token punctuation">,</span>
				Handler<span class="token punctuation">:</span> thirdPayment<span class="token punctuation">.</span><span class="token function">ThirdPaymentWxPayCallbackHandler</span><span class="token punctuation">(</span>serverCtx<span class="token punctuation">)</span><span class="token punctuation">,</span>
			<span class="token punctuation">}</span><span class="token punctuation">,</span>
		<span class="token punctuation">}</span><span class="token punctuation">,</span>
		<span class="token comment">//为一组路由开启jwt验证功能，并指定密钥</span>
		rest<span class="token punctuation">.</span><span class="token function">WithJwt</span><span class="token punctuation">(</span>serverCtx<span class="token punctuation">.</span>Config<span class="token punctuation">.</span>JwtAuth<span class="token punctuation">.</span>AccessSecret<span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token comment">//为一组路由添加一个公共的前缀</span>
		rest<span class="token punctuation">.</span><span class="token function">WithPrefix</span><span class="token punctuation">(</span><span class="token string">"/afas/v1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">)</span>

	srv<span class="token punctuation">.</span><span class="token function">AddRoutes</span><span class="token punctuation">(</span>
		rest<span class="token punctuation">.</span><span class="token function">WithMiddlewares</span><span class="token punctuation">(</span>
			<span class="token punctuation">[</span><span class="token punctuation">]</span>rest<span class="token punctuation">.</span>Middleware<span class="token punctuation">{<!-- --></span>
				<span class="token keyword">func</span><span class="token punctuation">(</span>next http<span class="token punctuation">.</span>HandlerFunc<span class="token punctuation">)</span> http<span class="token punctuation">.</span>HandlerFunc <span class="token punctuation">{<!-- --></span>
					<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span><span class="token punctuation">,</span>
				<span class="token keyword">func</span><span class="token punctuation">(</span>next http<span class="token punctuation">.</span>HandlerFunc<span class="token punctuation">)</span> http<span class="token punctuation">.</span>HandlerFunc <span class="token punctuation">{<!-- --></span>
					<span class="token keyword">return</span> <span class="token keyword">func</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
					<span class="token punctuation">}</span>
				<span class="token punctuation">}</span><span class="token punctuation">,</span>
				<span class="token comment">//ToMiddleware()用于将一个接收和返回http.Handler的函数转换为一个Middleware类型的函数</span>
				rest<span class="token punctuation">.</span><span class="token function">ToMiddleware</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>next http<span class="token punctuation">.</span>Handler<span class="token punctuation">)</span> http<span class="token punctuation">.</span>Handler <span class="token punctuation">{<!-- --></span>
					<span class="token keyword">return</span> next
				<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
			<span class="token punctuation">}</span><span class="token punctuation">,</span>
			rest<span class="token punctuation">.</span>Route<span class="token punctuation">{<!-- --></span>
				Method<span class="token punctuation">:</span>  http<span class="token punctuation">.</span>MethodGet<span class="token punctuation">,</span>
				Path<span class="token punctuation">:</span>    <span class="token string">"/user/info2"</span><span class="token punctuation">,</span>
				Handler<span class="token punctuation">:</span> userInfo<span class="token punctuation">,</span>
			<span class="token punctuation">}</span><span class="token punctuation">,</span>
			rest<span class="token punctuation">.</span>Route<span class="token punctuation">{<!-- --></span>
				Method<span class="token punctuation">:</span>  http<span class="token punctuation">.</span>MethodGet<span class="token punctuation">,</span>
				Path<span class="token punctuation">:</span>    <span class="token string">"/user/info3"</span><span class="token punctuation">,</span>
				Handler<span class="token punctuation">:</span> userInfo<span class="token punctuation">,</span>
			<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
		rest<span class="token punctuation">.</span><span class="token function">WithPrefix</span><span class="token punctuation">(</span><span class="token string">"/afas/v2"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">)</span>
	<span class="token comment">//====================================================================</span>

	srv<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 启动服务</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> User <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	Name  <span class="token builtin">string</span> <span class="token string">`json:"name"`</span>
	Addr  <span class="token builtin">string</span> <span class="token string">`json:"addr"`</span>
	Level <span class="token builtin">int</span>    <span class="token string">`json:"level"`</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">userInfo</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">var</span> req <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
		UserId <span class="token builtin">int64</span> <span class="token string">`form:"user_id"`</span> <span class="token comment">// 定义参数</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">if</span> err <span class="token operator">:=</span> httpx<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> <span class="token operator">&amp;</span>req<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 解析参数</span>
		httpx<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> err<span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	users <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int64</span><span class="token punctuation">]</span><span class="token operator">*</span>User<span class="token punctuation">{<!-- --></span>
		<span class="token number">1</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span>User<span class="token punctuation">{<!-- --></span><span class="token string">"go-zero"</span><span class="token punctuation">,</span> <span class="token string">"shanghai"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
		<span class="token number">2</span><span class="token punctuation">:</span> <span class="token operator">&amp;</span>User<span class="token punctuation">{<!-- --></span><span class="token string">"go-queue"</span><span class="token punctuation">,</span> <span class="token string">"beijing"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
	httpx<span class="token punctuation">.</span><span class="token function">WriteJson</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> http<span class="token punctuation">.</span>StatusOK<span class="token punctuation">,</span> users<span class="token punctuation">[</span>req<span class="token punctuation">.</span>UserId<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// 返回结果</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="__126"></a>二. 底层源码分析</h2> 
<h3><a id="_127"></a>涉及到的一些结构体简介</h3> 
<ol><li>了解go-zero服务的启动与路由注册,首先要了解几个结构体比如: engine,patRouter,featuredRoutes,Route</li><li>engine: 服务引擎,构建go-zero服务时首先要创建这个引擎</li></ol> 
<blockquote> 
 <ol><li>服务其中时会将服务的配置相关信息存储到engine的conf 属性中</li><li>在路由注册时会先将路由保存到engine的routes属性中,后续再通过这个属性获取所有路由构建前缀树</li><li>会将通过Server的Use()或rest下WithMiddleware()/WithMiddlewares()函数主动注册中间件存储到middlewares属性中</li><li>在后续处理时会获取middlewares属性中保存的中间件,engine的chain处理器链中</li><li>…</li></ol> 
</blockquote> 
<pre><code class="prism language-go"><span class="token keyword">type</span> engine <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//RestConf结构体变量,内部存储了服务需要的配置信息,,比如监听地址,超时时间,鉴权等</span>
	conf   RestConf
	<span class="token comment">//一个featuredRoutes切片,用于存储rest服务的路由信息,每个路由包含了请求方法,路径,处理函数和特征值</span>
	routes <span class="token punctuation">[</span><span class="token punctuation">]</span>featuredRoutes
	<span class="token comment">//表示rest服务的最大超时时间，它是根据所有路由的超时时间计算得到的</span>
	timeout              time<span class="token punctuation">.</span>Duration
	<span class="token comment">//用于处理未授权的请求，比如返回401状态码或者重定向到登录页面</span>
	unauthorizedCallback handler<span class="token punctuation">.</span>UnauthorizedCallback
	<span class="token comment">//用于处理未签名的请求，比如返回403状态码或者提示用户签名</span>
	unsignedCallback     handler<span class="token punctuation">.</span>UnsignedCallback
	<span class="token comment">//用于管理rest服务的中间件链,可以在请求处理前后执行一些逻辑，比如日志、监控、限流等</span>
	chain                chain<span class="token punctuation">.</span>Chain
	<span class="token comment">//用于存储rest服务的中间件</span>
	middlewares          <span class="token punctuation">[</span><span class="token punctuation">]</span>Middleware
	<span class="token comment">//用于实现自适应限流功能，根据CPU负载和请求数动态调整限流阈值</span>
	shedder              load<span class="token punctuation">.</span>Shedder
	<span class="token comment">//用于实现优先级限流功能，根据请求的优先级和请求数动态调整限流阈值</span>
	priorityShedder      load<span class="token punctuation">.</span>Shedder
	<span class="token comment">//用于配置rest服务的TLS加密通信参数，比如证书、密钥等</span>
	tlsConfig            <span class="token operator">*</span>tls<span class="token punctuation">.</span>Config
<span class="token punctuation">}</span>
</code></pre> 
<ol start="3"><li>patRouter: 通过NewServer()函数创建go-zero服务时内部会调用NewRouter()先初始化这个结构体变量,初始化内部的trees属性,这个trees属性就是多个以路由method为key的前缀树,patRouter是路由注册与请求执行的核心,该结构体实现了ServeHTTP()方法,会通过这个方法处理用户的请求</li></ol> 
<pre><code class="prism language-go"><span class="token keyword">type</span> patRouter <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//键是请求方法,值是一个search.Tree类型的对象</span>
	trees      <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">*</span>search<span class="token punctuation">.</span>Tree
	<span class="token comment">//用于处理未找到匹配路由的请求，比如返回404状态码或者自定义的错误页面</span>
	notFound   http<span class="token punctuation">.</span>Handler
	<span class="token comment">//用于处理不允许的请求方法，比如返回405状态码或者自定义的错误页面</span>
	notAllowed http<span class="token punctuation">.</span>Handler
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Tree <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	root <span class="token operator">*</span>node
<span class="token punctuation">}</span>

<span class="token keyword">type</span> node <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	item     any
	children <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token operator">*</span>node
<span class="token punctuation">}</span>
</code></pre> 
<ol start="3"><li>featuredRoutes</li></ol> 
<pre><code class="prism language-go"><span class="token keyword">type</span> featuredRoutes <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//表示这组路由的超时时间，如果请求处理超过这个时间，会返回超时错误</span>
	timeout   time<span class="token punctuation">.</span>Duration
	<span class="token comment">//表示这组路由是否具有优先级，如果为true，这组路由会使用优先级限流器进行限流，否则使用普通限流器</span>
	priority  <span class="token builtin">bool</span>
	<span class="token comment">//包含了jwt验证相关的配置信息，比如是否开启jwt验证、密钥等</span>
	jwt       jwtSetting
	<span class="token comment">//包含了签名验证相关的配置信息，比如是否开启签名验证、签名算法等</span>
	signature signatureSetting
	<span class="token comment">//用于存储这组路由的具体信息，每个Route包含了请求方法、路径和处理函数</span>
	routes    <span class="token punctuation">[</span><span class="token punctuation">]</span>Route
	<span class="token comment">//表示这组路由允许的最大请求体大小，如果请求体超过这个大小，会返回错误</span>
	maxBytes  <span class="token builtin">int64</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="4"><li>Route</li></ol> 
<pre><code class="prism language-go"><span class="token keyword">type</span> Route <span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//请求方法，比如GET、POST、PUT等</span>
	Method  <span class="token builtin">string</span>
	<span class="token comment">//请求路径，可以包含模式匹配的参数，比如/user/:id</span>
	Path    <span class="token builtin">string</span>
	<span class="token comment">//处理请求的函数,用于处理匹配到该路由的请求，并返回响应</span>
	Handler http<span class="token punctuation">.</span>HandlerFunc
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_207"></a>初始化</h3> 
<ol><li>在编写go-zero服务时,可以编写yaml,通过conf/MustLoad()读取yaml配置,通过rest/MustNewServer()创建服务,也可以直接封装rest.RestConf配置变量,调用rest/NewServer()创建服务(实际MustLoad()内部也会调用这个NewServer()),查看NewServer()</li></ol> 
<blockquote> 
 <ol><li>首先调用调用newEngine()创建Engine服务引擎</li><li>调用NewRouter()函数,初始化patRouter,初始化patRouter中的trees路由前缀树</li></ol> 
</blockquote> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">NewServer</span><span class="token punctuation">(</span>c RestConf<span class="token punctuation">,</span> opts <span class="token operator">...</span>RunOption<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>Server<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">SetUp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> err
	<span class="token punctuation">}</span>

	server <span class="token operator">:=</span> <span class="token operator">&amp;</span>Server<span class="token punctuation">{<!-- --></span>
		ngin<span class="token punctuation">:</span>   <span class="token function">newEngine</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">,</span>
		router<span class="token punctuation">:</span> router<span class="token punctuation">.</span><span class="token function">NewRouter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span>

	opts <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>RunOption<span class="token punctuation">{<!-- --></span><span class="token function">WithNotFoundHandler</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> opts<span class="token operator">...</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> opt <span class="token operator">:=</span> <span class="token keyword">range</span> opts <span class="token punctuation">{<!-- --></span>
		<span class="token function">opt</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> server<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_230"></a>中间件的预设置</h3> 
<ol><li>有两种方式注册中间件:</li></ol> 
<blockquote> 
 <ol><li>通过Server的use方法注册全局中间件,</li><li>通过github.com\zeromicro\go-zero\rest\server.go中的WithMiddlewares/WithMiddleware()函数注册针对一组路由的中间件</li></ol> 
</blockquote> 
<ol start="2"><li>Server.Use()注册全局中间件,很简单,会调用engine的use()方法,将中间件函数保存到engine引擎的中间件切片属性middlewares中</li></ol> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">Use</span><span class="token punctuation">(</span>middleware Middleware<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//调用engine的user()方法</span>
	s<span class="token punctuation">.</span>ngin<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>middleware<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>ng <span class="token operator">*</span>engine<span class="token punctuation">)</span> <span class="token function">use</span><span class="token punctuation">(</span>middleware Middleware<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	ng<span class="token punctuation">.</span>middlewares <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>ng<span class="token punctuation">.</span>middlewares<span class="token punctuation">,</span> middleware<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="3"><li>查看WithMiddlewares/WithMiddleware()函数针对一组路由注册中间件函数源码,最终会将中间件封装到每个路由的Handler属性中</li></ol> 
<pre><code class="prism language-go"><span class="token comment">//WithMiddlewares内部实际就是调用的WithMiddleware()只关注这一个即可</span>
<span class="token keyword">func</span> <span class="token function">WithMiddleware</span><span class="token punctuation">(</span>middleware Middleware<span class="token punctuation">,</span> rs <span class="token operator">...</span>Route<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>Route <span class="token punctuation">{<!-- --></span>
	routes <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>Route<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>rs<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> rs <span class="token punctuation">{<!-- --></span>
		route <span class="token operator">:=</span> rs<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
		routes<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Route<span class="token punctuation">{<!-- --></span>
			Method<span class="token punctuation">:</span>  route<span class="token punctuation">.</span>Method<span class="token punctuation">,</span>
			Path<span class="token punctuation">:</span>    route<span class="token punctuation">.</span>Path<span class="token punctuation">,</span>
			Handler<span class="token punctuation">:</span> <span class="token function">middleware</span><span class="token punctuation">(</span>route<span class="token punctuation">.</span>Handler<span class="token punctuation">)</span><span class="token punctuation">,</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> routes
<span class="token punctuation">}</span>
</code></pre> 
<ol start="4"><li>另外rest下有一个WithChain()函数,直接将中间件添加到chain处理器链中(可以看为将中间件又封装了一层),如下,在创建Server时添加两个拦截器</li></ol> 
<pre><code class="prism language-go">server <span class="token operator">:=</span> <span class="token function">MustNewServer</span><span class="token punctuation">(</span>RestConf<span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">,</span> rest<span class="token punctuation">.</span><span class="token function">WithChain</span><span class="token punctuation">(</span>chain<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span>中间件函数<span class="token number">1</span><span class="token punctuation">,</span> 中间件函数<span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="_265"></a>路由注册与中间件的处理</h3> 
<ol><li>在通过go-zero提供服务时,首先执行rest下的NewServer()函数,读取配置,创建服务端Server, 提供对外的接口时,需要将接口Method,接口函数,接口路径封装为Route结构体变量,调用Server的AddRoutes()方法将这个结构体变量添加到engine引擎的routes路由切片属性中</li></ol> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">AddRoutes</span><span class="token punctuation">(</span>rs <span class="token punctuation">[</span><span class="token punctuation">]</span>Route<span class="token punctuation">,</span> opts <span class="token operator">...</span>RouteOption<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	r <span class="token operator">:=</span> featuredRoutes<span class="token punctuation">{<!-- --></span>
		routes<span class="token punctuation">:</span> rs<span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> opt <span class="token operator">:=</span> <span class="token keyword">range</span> opts <span class="token punctuation">{<!-- --></span>
		<span class="token function">opt</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>r<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	s<span class="token punctuation">.</span>ngin<span class="token punctuation">.</span><span class="token function">addRoutes</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>ng <span class="token operator">*</span>engine<span class="token punctuation">)</span> <span class="token function">addRoutes</span><span class="token punctuation">(</span>r featuredRoutes<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	ng<span class="token punctuation">.</span>routes <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>ng<span class="token punctuation">.</span>routes<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="2"><li>路由添加完成后,会调用Server的Start()方法启动服务,查看源码.会调用engine的start()方法–&gt;调用bindRoutes()</li></ol> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">handleError</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>ngin<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>router<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义一个 start 方法，接收一个 router 参数和可变数量的 StartOption 参数，返回一个 error 类型的值</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>ng <span class="token operator">*</span>engine<span class="token punctuation">)</span> <span class="token function">start</span><span class="token punctuation">(</span>router httpx<span class="token punctuation">.</span>Router<span class="token punctuation">,</span> opts <span class="token operator">...</span>StartOption<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 调用 bindRoutes 方法，将路由绑定到 ng 上，如果出错则返回错误</span>
	<span class="token keyword">if</span> err <span class="token operator">:=</span> ng<span class="token punctuation">.</span><span class="token function">bindRoutes</span><span class="token punctuation">(</span>router<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">}</span>

	<span class="token comment">// 将 ng.withTimeout 方法作为一个 StartOption 参数添加到 opts 切片的开头</span>
	opts <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>StartOption<span class="token punctuation">{<!-- --></span>ng<span class="token punctuation">.</span><span class="token function">withTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> opts<span class="token operator">...</span><span class="token punctuation">)</span>

	<span class="token comment">// 如果配置文件中没有证书文件和密钥文件，则调用 internal 包中的 StartHttp 方法，启动一个 http 服务</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>CertFile<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">len</span><span class="token punctuation">(</span>ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>KeyFile<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> internal<span class="token punctuation">.</span><span class="token function">StartHttp</span><span class="token punctuation">(</span>ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Host<span class="token punctuation">,</span> ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Port<span class="token punctuation">,</span> router<span class="token punctuation">,</span> opts<span class="token operator">...</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 如果配置文件中有证书文件和密钥文件，则创建一个匿名函数，将 ng 的 tlsConfig 属性赋值给 svr 的 TLSConfig 属性，然后将这个匿名函数作为一个 StartOption 参数添加到 opts 切片的末尾</span>
	opts <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>StartOption<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">func</span><span class="token punctuation">(</span>svr <span class="token operator">*</span>http<span class="token punctuation">.</span>Server<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> ng<span class="token punctuation">.</span>tlsConfig <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
				svr<span class="token punctuation">.</span>TLSConfig <span class="token operator">=</span> ng<span class="token punctuation">.</span>tlsConfig
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span> opts<span class="token operator">...</span><span class="token punctuation">)</span>

	<span class="token comment">// 调用 internal 包中的 StartHttps 方法，启动一个 https 服务</span>
	<span class="token keyword">return</span> internal<span class="token punctuation">.</span><span class="token function">StartHttps</span><span class="token punctuation">(</span>ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Host<span class="token punctuation">,</span> ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Port<span class="token punctuation">,</span> ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>CertFile<span class="token punctuation">,</span>
		ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>KeyFile<span class="token punctuation">,</span> router<span class="token punctuation">,</span> opts<span class="token operator">...</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="3"><li>查看engine的bindRoutes()方法,获取engine的routes属性中保存的每一个路由,遍历调用bindFeaturedRoutes()–&gt;调用bindRoute()方法在该方法中重点完成了:</li></ol> 
<blockquote> 
 <ol><li>获取engine的chain属性,如果为空调用buildChainWithNativeMiddlewares()新建一个chain链,获取配置信息,根据配置判断添加中间件,比如判断是否配置了追踪请求的Trace中间件, 记录请求日志的Log中间件,收集请求指标数据Prometheus中间件,限制最大并发连接数的MaxConns中间件,实现熔断机制Breaker中间件 ,实现流量控制Shedding中间件,设置请求超时时间的Timeout中间件,恢复异常请求的Recover中间件…如果有配置则将这些中间件添加到chain中</li><li>获取engine的middlewares中间件,遍历添加到chain中,也就是我们通过Server的Use()方法,或rest下WithMiddleware()/WithMiddlewares()函数主动注册中间件,将这些中间件添加到chain中</li><li>调用chain的ThenFunc()方法,遍历所有中间件,调用中间件的Handle()方法,将中间件包装为Handler形成中间件Handler链,并将接口的处理Handler添加到了链条的末尾,在执行时匹配到handler后会基于这个链条向下调用到最终的接口处理函数</li><li>调用Router的Handle()方法,将路由注册到路由树上,也就是前缀树的构建</li></ol> 
</blockquote> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>ng <span class="token operator">*</span>engine<span class="token punctuation">)</span> <span class="token function">bindRoutes</span><span class="token punctuation">(</span>router httpx<span class="token punctuation">.</span>Router<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//创建 metrics 对象，用于记录请求的统计信息</span>
	metrics <span class="token operator">:=</span> ng<span class="token punctuation">.</span><span class="token function">createMetrics</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">//遍历 engine.routes属性中的每一个路由</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> fr <span class="token operator">:=</span> <span class="token keyword">range</span> ng<span class="token punctuation">.</span>routes <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//调用 bindFeaturedRoutes方法进行绑定</span>
		<span class="token keyword">if</span> err <span class="token operator">:=</span> ng<span class="token punctuation">.</span><span class="token function">bindFeaturedRoutes</span><span class="token punctuation">(</span>router<span class="token punctuation">,</span> fr<span class="token punctuation">,</span> metrics<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> err
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>ng <span class="token operator">*</span>engine<span class="token punctuation">)</span> <span class="token function">bindFeaturedRoutes</span><span class="token punctuation">(</span>router httpx<span class="token punctuation">.</span>Router<span class="token punctuation">,</span> fr featuredRoutes<span class="token punctuation">,</span> metrics <span class="token operator">*</span>stat<span class="token punctuation">.</span>Metrics<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 调用 signatureVerifier 方法，根据 fr.signature 的值创建一个签名验证器</span>
	verifier<span class="token punctuation">,</span> err <span class="token operator">:=</span> ng<span class="token punctuation">.</span><span class="token function">signatureVerifier</span><span class="token punctuation">(</span>fr<span class="token punctuation">.</span>signature<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">}</span>
	<span class="token comment">//遍历 fr.routes 中的每一个路由</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> route <span class="token operator">:=</span> <span class="token keyword">range</span> fr<span class="token punctuation">.</span>routes <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//调用 bindRoute 方法进行绑定</span>
		<span class="token keyword">if</span> err <span class="token operator">:=</span> ng<span class="token punctuation">.</span><span class="token function">bindRoute</span><span class="token punctuation">(</span>fr<span class="token punctuation">,</span> router<span class="token punctuation">,</span> metrics<span class="token punctuation">,</span> route<span class="token punctuation">,</span> verifier<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> err
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>

<span class="token comment">//bindRoute()接收参数中: metrics是统计相关的,verifier 是一个签名验证器</span>
<span class="token comment">//重点做了如下动作: </span>
<span class="token comment">//1.获取engine的chain属性,如果为空调用buildChainWithNativeMiddlewares()根据配置判断添加中间件</span>
<span class="token comment">//2.获取engine的middlewares中间件,遍历添加到chain中</span>
<span class="token comment">//3.调用chain的ThenFunc()方法将路由接口添加到chain中</span>
<span class="token comment">//4.调用Router的Handle()方法,将路由注册到路由树上,也就是前缀树的构建</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>ng <span class="token operator">*</span>engine<span class="token punctuation">)</span> <span class="token function">bindRoute</span><span class="token punctuation">(</span>fr featuredRoutes<span class="token punctuation">,</span> router httpx<span class="token punctuation">.</span>Router<span class="token punctuation">,</span> metrics <span class="token operator">*</span>stat<span class="token punctuation">.</span>Metrics<span class="token punctuation">,</span>
	route Route<span class="token punctuation">,</span> verifier <span class="token keyword">func</span><span class="token punctuation">(</span>chain<span class="token punctuation">.</span>Chain<span class="token punctuation">)</span> chain<span class="token punctuation">.</span>Chain<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//1.获取 engine的chain属性(也就是通过rest下的withChain()注册的连接器又封装了一层的中间件)</span>
	chn <span class="token operator">:=</span> ng<span class="token punctuation">.</span>chain
	<span class="token keyword">if</span> chn <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//如果为空调用 buildChainWithNativeMiddlewares()根据 fr, route, metrics 构建一个 chain 对象</span>
		chn <span class="token operator">=</span> ng<span class="token punctuation">.</span><span class="token function">buildChainWithNativeMiddlewares</span><span class="token punctuation">(</span>fr<span class="token punctuation">,</span> route<span class="token punctuation">,</span> metrics<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//2.调用appendAuthHandler()根据 fr, chn, verifier 在 chain 对象后面追加一个认证处理器</span>
	chn <span class="token operator">=</span> ng<span class="token punctuation">.</span><span class="token function">appendAuthHandler</span><span class="token punctuation">(</span>fr<span class="token punctuation">,</span> chn<span class="token punctuation">,</span> verifier<span class="token punctuation">)</span>

	<span class="token comment">//3.遍历 engine.middlewares属性中保存的每一个中间件</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> middleware <span class="token operator">:=</span> <span class="token keyword">range</span> ng<span class="token punctuation">.</span>middlewares <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//调用 convertMiddleware()函数,将中间件转换为 chain.Handler 类型，</span>
		<span class="token comment">//并追加到 chain 对象后面</span>
		chn <span class="token operator">=</span> chn<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span><span class="token function">convertMiddleware</span><span class="token punctuation">(</span>middleware<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//4.调用chain的ThenFunc()将route.Handler也就是接口函数作为最后一个处理器,添加到chain中</span>
	<span class="token comment">//该函数中会遍历c.middlewares中的每个中间件,将每个中间件包装为handle,形成一个handler链</span>
	<span class="token comment">//最后返回这个handler链的入口,也就是第一个中间件包装的handler对象</span>
	handle <span class="token operator">:=</span> chn<span class="token punctuation">.</span><span class="token function">ThenFunc</span><span class="token punctuation">(</span>route<span class="token punctuation">.</span>Handler<span class="token punctuation">)</span>
	
	<span class="token comment">//调用 router 的 Handle 方法，将 route.Method, route.Path 和 handle 作为参数,注册到路由树上</span>
	<span class="token keyword">return</span> router<span class="token punctuation">.</span><span class="token function">Handle</span><span class="token punctuation">(</span>route<span class="token punctuation">.</span>Method<span class="token punctuation">,</span> route<span class="token punctuation">.</span>Path<span class="token punctuation">,</span> handle<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>ng <span class="token operator">*</span>engine<span class="token punctuation">)</span> <span class="token function">buildChainWithNativeMiddlewares</span><span class="token punctuation">(</span>fr featuredRoutes<span class="token punctuation">,</span> route Route<span class="token punctuation">,</span>
	metrics <span class="token operator">*</span>stat<span class="token punctuation">.</span>Metrics<span class="token punctuation">)</span> chain<span class="token punctuation">.</span>Chain <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//创建一个空的链式处理器</span>
	chn <span class="token operator">:=</span> chain<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	<span class="token comment">//如果配置了Trace中间件，在链式处理器中添加TraceHandler，用于追踪请求的路径和忽略的路径</span>
	<span class="token keyword">if</span> ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Middlewares<span class="token punctuation">.</span>Trace <span class="token punctuation">{<!-- --></span>
		chn <span class="token operator">=</span> chn<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>handler<span class="token punctuation">.</span><span class="token function">TraceHandler</span><span class="token punctuation">(</span>ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Name<span class="token punctuation">,</span>
			route<span class="token punctuation">.</span>Path<span class="token punctuation">,</span>
			handler<span class="token punctuation">.</span><span class="token function">WithTraceIgnorePaths</span><span class="token punctuation">(</span>ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>TraceIgnorePaths<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//如果配置了Log中间件，在链式处理器中添加getLogHandler，用于记录请求的日志</span>
	<span class="token keyword">if</span> ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Middlewares<span class="token punctuation">.</span>Log <span class="token punctuation">{<!-- --></span>
		chn <span class="token operator">=</span> chn<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>ng<span class="token punctuation">.</span><span class="token function">getLogHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//如果配置了Prometheus中间件，在链式处理器中添加PrometheusHandler，用于收集请求的指标数据</span>
	<span class="token keyword">if</span> ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Middlewares<span class="token punctuation">.</span>Prometheus <span class="token punctuation">{<!-- --></span>
		chn <span class="token operator">=</span> chn<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>handler<span class="token punctuation">.</span><span class="token function">PrometheusHandler</span><span class="token punctuation">(</span>route<span class="token punctuation">.</span>Path<span class="token punctuation">,</span> route<span class="token punctuation">.</span>Method<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//如果配置了MaxConns中间件，在链式处理器中添加MaxConnsHandler，用于限制最大并发连接数</span>
	<span class="token keyword">if</span> ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Middlewares<span class="token punctuation">.</span>MaxConns <span class="token punctuation">{<!-- --></span>
		chn <span class="token operator">=</span> chn<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>handler<span class="token punctuation">.</span><span class="token function">MaxConnsHandler</span><span class="token punctuation">(</span>ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>MaxConns<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">// 如果配置了Breaker中间件，在链式处理器中添加BreakerHandler，用于实现熔断机制</span>
	<span class="token keyword">if</span> ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Middlewares<span class="token punctuation">.</span>Breaker <span class="token punctuation">{<!-- --></span>
		chn <span class="token operator">=</span> chn<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>handler<span class="token punctuation">.</span><span class="token function">BreakerHandler</span><span class="token punctuation">(</span>route<span class="token punctuation">.</span>Method<span class="token punctuation">,</span> route<span class="token punctuation">.</span>Path<span class="token punctuation">,</span> metrics<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//如果配置了Shedding中间件，在链式处理器中添加SheddingHandler，用于实现流量控制</span>
	<span class="token keyword">if</span> ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Middlewares<span class="token punctuation">.</span>Shedding <span class="token punctuation">{<!-- --></span>
		chn <span class="token operator">=</span> chn<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>handler<span class="token punctuation">.</span><span class="token function">SheddingHandler</span><span class="token punctuation">(</span>ng<span class="token punctuation">.</span><span class="token function">getShedder</span><span class="token punctuation">(</span>fr<span class="token punctuation">.</span>priority<span class="token punctuation">)</span><span class="token punctuation">,</span> metrics<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//如果配置了Timeout中间件，在链式处理器中添加TimeoutHandler，用于设置请求的超时时间</span>
	<span class="token keyword">if</span> ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Middlewares<span class="token punctuation">.</span>Timeout <span class="token punctuation">{<!-- --></span>
		chn <span class="token operator">=</span> chn<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>handler<span class="token punctuation">.</span><span class="token function">TimeoutHandler</span><span class="token punctuation">(</span>ng<span class="token punctuation">.</span><span class="token function">checkedTimeout</span><span class="token punctuation">(</span>fr<span class="token punctuation">.</span>timeout<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//如果配置了Recover中间件，在链式处理器中添加RecoverHandler，用于恢复请求的异常</span>
	<span class="token keyword">if</span> ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Middlewares<span class="token punctuation">.</span>Recover <span class="token punctuation">{<!-- --></span>
		chn <span class="token operator">=</span> chn<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>handler<span class="token punctuation">.</span>RecoverHandler<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//如果配置了Metrics中间件，在链式处理器中添加MetricHandler，用于记录请求的统计数据</span>
	<span class="token keyword">if</span> ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Middlewares<span class="token punctuation">.</span>Metrics <span class="token punctuation">{<!-- --></span>
		chn <span class="token operator">=</span> chn<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>handler<span class="token punctuation">.</span><span class="token function">MetricHandler</span><span class="token punctuation">(</span>metrics<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//如果配置了MaxBytes中间件，在链式处理器中添加MaxBytesHandler，用于限制请求的最大字节数</span>
	<span class="token keyword">if</span> ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Middlewares<span class="token punctuation">.</span>MaxBytes <span class="token punctuation">{<!-- --></span>
		chn <span class="token operator">=</span> chn<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>handler<span class="token punctuation">.</span><span class="token function">MaxBytesHandler</span><span class="token punctuation">(</span>ng<span class="token punctuation">.</span><span class="token function">checkedMaxBytes</span><span class="token punctuation">(</span>fr<span class="token punctuation">.</span>maxBytes<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//如果配置了Gunzip中间件，在链式处理器中添加GunzipHandler，用于解压缩请求的数据</span>
	<span class="token keyword">if</span> ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Middlewares<span class="token punctuation">.</span>Gunzip <span class="token punctuation">{<!-- --></span>
		chn <span class="token operator">=</span> chn<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>handler<span class="token punctuation">.</span>GunzipHandler<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> chn
<span class="token punctuation">}</span>

<span class="token comment">//添加一个授权验证的中间件</span>
<span class="token comment">//入参verifier是一个函数类型，表示一个验证器，它接受一个链式处理器作为参数，并返回一个链式处理器作为结果</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>ng <span class="token operator">*</span>engine<span class="token punctuation">)</span> <span class="token function">appendAuthHandler</span><span class="token punctuation">(</span>fr featuredRoutes<span class="token punctuation">,</span> chn chain<span class="token punctuation">.</span>Chain<span class="token punctuation">,</span>
	verifier <span class="token keyword">func</span><span class="token punctuation">(</span>chain<span class="token punctuation">.</span>Chain<span class="token punctuation">)</span> chain<span class="token punctuation">.</span>Chain<span class="token punctuation">)</span> chain<span class="token punctuation">.</span>Chain <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//1.判断是否启用了jwt</span>
	<span class="token keyword">if</span> fr<span class="token punctuation">.</span>jwt<span class="token punctuation">.</span>enabled <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>fr<span class="token punctuation">.</span>jwt<span class="token punctuation">.</span>prevSecret<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//如果没有设置前一个密钥，就使用当前的密钥进行授权验证，并在验证失败时调用unauthorizedCallback函数</span>
			chn <span class="token operator">=</span> chn<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>handler<span class="token punctuation">.</span><span class="token function">Authorize</span><span class="token punctuation">(</span>fr<span class="token punctuation">.</span>jwt<span class="token punctuation">.</span>secret<span class="token punctuation">,</span>
				handler<span class="token punctuation">.</span><span class="token function">WithUnauthorizedCallback</span><span class="token punctuation">(</span>ng<span class="token punctuation">.</span>unauthorizedCallback<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">//如果设置了前一个密钥，就使用当前的密钥和前一个密钥进行授权验证，并在验证失败时调用unauthorizedCallback函数</span>
			chn <span class="token operator">=</span> chn<span class="token punctuation">.</span><span class="token function">Append</span><span class="token punctuation">(</span>handler<span class="token punctuation">.</span><span class="token function">Authorize</span><span class="token punctuation">(</span>fr<span class="token punctuation">.</span>jwt<span class="token punctuation">.</span>secret<span class="token punctuation">,</span>
				handler<span class="token punctuation">.</span><span class="token function">WithPrevSecret</span><span class="token punctuation">(</span>fr<span class="token punctuation">.</span>jwt<span class="token punctuation">.</span>prevSecret<span class="token punctuation">)</span><span class="token punctuation">,</span>
				handler<span class="token punctuation">.</span><span class="token function">WithUnauthorizedCallback</span><span class="token punctuation">(</span>ng<span class="token punctuation">.</span>unauthorizedCallback<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//返回经过验证器处理后的链式处理器</span>
	<span class="token keyword">return</span> <span class="token function">verifier</span><span class="token punctuation">(</span>chn<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">//这个方法在执行角度看还是比较重要的</span>
<span class="token comment">//遍历所有中间件,调用中间件的Handle()方法,将中间件包装为一个新的handler对象,</span>
<span class="token comment">//最终形成一个中间件的handler链,并将传入的h添加到了这个链条的末尾</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c chain<span class="token punctuation">)</span> <span class="token function">Then</span><span class="token punctuation">(</span>h http<span class="token punctuation">.</span>Handler<span class="token punctuation">)</span> http<span class="token punctuation">.</span>Handler <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> h <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		h <span class="token operator">=</span> http<span class="token punctuation">.</span>DefaultServeMux
	<span class="token punctuation">}</span>
	
	<span class="token comment">//遍历注册的所有中间件</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> c<span class="token punctuation">.</span>middlewares <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//对每个中间件调用它的Handle(next http.HandlerFunc) http.HandlerFunc方法,</span>
		<span class="token comment">//传入当前的h作为参数,会返回一个新的handler对象,最终形成一个handler链</span>
		h <span class="token operator">=</span> c<span class="token punctuation">.</span>middlewares<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>middlewares<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">return</span> h
<span class="token punctuation">}</span>
</code></pre> 
<ol start="4"><li>查看patRouter的Handle()方法添加路由构建前缀树的源码,内部会</li></ol> 
<blockquote> 
 <ol><li>patRouter是在NewServer()函数创建服务Server内部通过NewRouter()初始化的,内部有个trees属性,保存了以Method为维度的多个前缀树</li><li>在Handle()方法中会根据当前路由的Method判断是否存在该类型的前缀树,如果存在则调用Tree的Add()方法添加,如果不存在,则先调用调用一个NewTree()新建一个前缀树,然后调用Tree的Add()方法添加</li><li>Tree的Add()方法中会调用一个add()函数,该函数中,会根据"/“截取路由path中的每一段,作为token标识判断当前前缀树中是否已经存在该节点,如果存在则递归调用根据”/"继续截取当当前节点作为子节点判断添加前缀树中,</li><li>如果不存在则调用newNode()函数新建node节点,.以当前路由截取到的token标识为key添加到前缀树中</li></ol> 
</blockquote> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>pr <span class="token operator">*</span>patRouter<span class="token punctuation">)</span> <span class="token function">Handle</span><span class="token punctuation">(</span>method<span class="token punctuation">,</span> reqPath <span class="token builtin">string</span><span class="token punctuation">,</span> handler http<span class="token punctuation">.</span>Handler<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">validMethod</span><span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> ErrInvalidMethod
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>reqPath<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> reqPath<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token char">'/'</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> ErrInvalidPath
	<span class="token punctuation">}</span>

	cleanPath <span class="token operator">:=</span> path<span class="token punctuation">.</span><span class="token function">Clean</span><span class="token punctuation">(</span>reqPath<span class="token punctuation">)</span>
	<span class="token comment">//根据method在patRouter的trees树中获取指定前缀树</span>
	tree<span class="token punctuation">,</span> ok <span class="token operator">:=</span> pr<span class="token punctuation">.</span>trees<span class="token punctuation">[</span>method<span class="token punctuation">]</span>
	<span class="token keyword">if</span> ok <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//如果存在调用Tree的Add()方法注册路由</span>
		<span class="token keyword">return</span> tree<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>cleanPath<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//如果patRouter的trees中不存在当前method前缀树则创建</span>
	tree <span class="token operator">=</span> search<span class="token punctuation">.</span><span class="token function">NewTree</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	pr<span class="token punctuation">.</span>trees<span class="token punctuation">[</span>method<span class="token punctuation">]</span> <span class="token operator">=</span> tree
	<span class="token comment">//然后调用Tree的Add()方法注册路由</span>
	<span class="token keyword">return</span> tree<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>cleanPath<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>Tree<span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>route <span class="token builtin">string</span><span class="token punctuation">,</span> item <span class="token keyword">interface</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>route<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> route<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> slash <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> errNotFromRoot
	<span class="token punctuation">}</span>

	<span class="token keyword">if</span> item <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> errEmptyItem
	<span class="token punctuation">}</span>
	<span class="token comment">//注册路由</span>
	err <span class="token operator">:=</span> <span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>root<span class="token punctuation">,</span> route<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span>
	<span class="token comment">//异常判断</span>
	<span class="token keyword">switch</span> err <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">case</span> errDupItem<span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token function">duplicatedItem</span><span class="token punctuation">(</span>route<span class="token punctuation">)</span>
	<span class="token keyword">case</span> errDupSlash<span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token function">duplicatedSlash</span><span class="token punctuation">(</span>route<span class="token punctuation">)</span>
	<span class="token keyword">default</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span>nd <span class="token operator">*</span>node<span class="token punctuation">,</span> route <span class="token builtin">string</span><span class="token punctuation">,</span> item <span class="token keyword">interface</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//如果路由为空，表示已经到达最后一个节点</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>route<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">if</span> nd<span class="token punctuation">.</span>item <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			<span class="token comment">// 如果当前节点已经有了项，就返回errDupItem错误</span>
			<span class="token keyword">return</span> errDupItem
		<span class="token punctuation">}</span>
		<span class="token comment">//否则，就把项赋值给当前节点，并返回nil</span>
		nd<span class="token punctuation">.</span>item <span class="token operator">=</span> item
		<span class="token keyword">return</span> <span class="token boolean">nil</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">//如果路由以斜杠开头，就返回errDupSlash错误</span>
	<span class="token comment">//slash是"/"</span>
	<span class="token keyword">if</span> route<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> slash <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> errDupSlash
	<span class="token punctuation">}</span>

	<span class="token comment">//遍历路由中的每个字符</span>
	<span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> route <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//如果不是斜杠,continue跳过</span>
		<span class="token keyword">if</span> route<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> slash <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">continue</span>
		<span class="token punctuation">}</span>
		<span class="token comment">//截取路由中第一个斜杠之前的部分作为token(也就是当前写过之前的)</span>
		token <span class="token operator">:=</span> route<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span>
		<span class="token comment">//获取当前节点对应token的子节点集合(可能是静态子节点或者动态子节点)</span>
		<span class="token comment">//返回的是一个 map[string]*node 变量</span>
		children <span class="token operator">:=</span> nd<span class="token punctuation">.</span><span class="token function">getChildren</span><span class="token punctuation">(</span>token<span class="token punctuation">)</span>
		<span class="token comment">//如果子节点集合中存在当前token对应的子节点对象</span>
		<span class="token keyword">if</span> child<span class="token punctuation">,</span> ok <span class="token operator">:=</span> children<span class="token punctuation">[</span>token<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> child <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
				<span class="token comment">//并且子节点对象不为nil,递归调用add函数,在子节点上继续添加剩余的路由并返回结果</span>
				<span class="token keyword">return</span> <span class="token function">add</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> route<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//子节点对象为nil,返回errInvalidState错误(这种情况不应该发生)</span>
			<span class="token keyword">return</span> errInvalidState
		<span class="token punctuation">}</span>

		<span class="token comment">//如果子节点集合中不存在当前token对应的子节点对象,创建一个新的空节点对象作为子节点</span>
		child <span class="token operator">:=</span> <span class="token function">newNode</span><span class="token punctuation">(</span><span class="token boolean">nil</span><span class="token punctuation">)</span>
		<span class="token comment">//把新创建的子节点对象添加到子节点集合中</span>
		children<span class="token punctuation">[</span>token<span class="token punctuation">]</span> <span class="token operator">=</span> child
		<span class="token comment">//递归调用add函数,在新创建的子节点上继续添加剩余的路由</span>
		<span class="token keyword">return</span> <span class="token function">add</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> route<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">//如果路由中没有斜杠了,表示已经到达最后一个token也就是路由的最后一个节点,获取当前节点对应token的子节点集合</span>
	children <span class="token operator">:=</span> nd<span class="token punctuation">.</span><span class="token function">getChildren</span><span class="token punctuation">(</span>route<span class="token punctuation">)</span>
	<span class="token comment">//如果子节点集合中存在token对应的子节点对象</span>
	<span class="token keyword">if</span> child<span class="token punctuation">,</span> ok <span class="token operator">:=</span> children<span class="token punctuation">[</span>route<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//如果子节点对象已经有了当前项,返回errDupItem错误</span>
		<span class="token keyword">if</span> child<span class="token punctuation">.</span>item <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">return</span> errDupItem
		<span class="token punctuation">}</span>
		<span class="token comment">//没有,就把当前节点添加到子节点中</span>
		child<span class="token punctuation">.</span>item <span class="token operator">=</span> item
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//如果子节点集合中不存在当前token对应的子节点对象</span>
		<span class="token comment">//创建一个新的节点对象作为子节点,然后添加到子节点集合中</span>
		children<span class="token punctuation">[</span>route<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="nethttp_592"></a>启动服务到触发net/http</h3> 
<ol><li>在调用Start()方法启动服务时,内部会有一个判断:如果配置文件中没有证书文件和密钥文件,调用 internal 包中的 StartHttp()方法,如果有则调用StartHttps()启动一个 http 服务</li></ol> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token function">handleError</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>ngin<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>router<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 定义一个 start 方法，接收一个 router 参数和可变数量的 StartOption 参数，返回一个 error 类型的值</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>ng <span class="token operator">*</span>engine<span class="token punctuation">)</span> <span class="token function">start</span><span class="token punctuation">(</span>router httpx<span class="token punctuation">.</span>Router<span class="token punctuation">,</span> opts <span class="token operator">...</span>StartOption<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 调用 bindRoutes 方法，将路由绑定到 ng 上，如果出错则返回错误</span>
	<span class="token keyword">if</span> err <span class="token operator">:=</span> ng<span class="token punctuation">.</span><span class="token function">bindRoutes</span><span class="token punctuation">(</span>router<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">}</span>

	<span class="token comment">// 将 ng.withTimeout 方法作为一个 StartOption 参数添加到 opts 切片的开头</span>
	opts <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>StartOption<span class="token punctuation">{<!-- --></span>ng<span class="token punctuation">.</span><span class="token function">withTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> opts<span class="token operator">...</span><span class="token punctuation">)</span>

	<span class="token comment">// 如果配置文件中没有证书文件和密钥文件，则调用 internal 包中的 StartHttp 方法，启动一个 http 服务</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>CertFile<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">len</span><span class="token punctuation">(</span>ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>KeyFile<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span>
		<span class="token keyword">return</span> internal<span class="token punctuation">.</span><span class="token function">StartHttp</span><span class="token punctuation">(</span>ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Host<span class="token punctuation">,</span> ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Port<span class="token punctuation">,</span> router<span class="token punctuation">,</span> opts<span class="token operator">...</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span>

	<span class="token comment">// 如果配置文件中有证书文件和密钥文件，则创建一个匿名函数，将 ng 的 tlsConfig 属性赋值给 svr 的 TLSConfig 属性，然后将这个匿名函数作为一个 StartOption 参数添加到 opts 切片的末尾</span>
	opts <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>StartOption<span class="token punctuation">{<!-- --></span>
		<span class="token keyword">func</span><span class="token punctuation">(</span>svr <span class="token operator">*</span>http<span class="token punctuation">.</span>Server<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
			<span class="token keyword">if</span> ng<span class="token punctuation">.</span>tlsConfig <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
				svr<span class="token punctuation">.</span>TLSConfig <span class="token operator">=</span> ng<span class="token punctuation">.</span>tlsConfig
			<span class="token punctuation">}</span>
		<span class="token punctuation">}</span><span class="token punctuation">,</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span> opts<span class="token operator">...</span><span class="token punctuation">)</span>

	<span class="token comment">// 调用 internal 包中的 StartHttps 方法，启动一个 https 服务</span>
	<span class="token keyword">return</span> internal<span class="token punctuation">.</span><span class="token function">StartHttps</span><span class="token punctuation">(</span>ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Host<span class="token punctuation">,</span> ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>Port<span class="token punctuation">,</span> ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>CertFile<span class="token punctuation">,</span>
		ng<span class="token punctuation">.</span>conf<span class="token punctuation">.</span>KeyFile<span class="token punctuation">,</span> router<span class="token punctuation">,</span> opts<span class="token operator">...</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="2"><li>以StartHttp()为例,查看该函数,内部调用了net/http下的ListenAndServe()</li></ol> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token function">StartHttp</span><span class="token punctuation">(</span>host <span class="token builtin">string</span><span class="token punctuation">,</span> port <span class="token builtin">int</span><span class="token punctuation">,</span> handler http<span class="token punctuation">.</span>Handler<span class="token punctuation">,</span> opts <span class="token operator">...</span>StartOption<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//start()源码在下方</span>
	<span class="token keyword">return</span> <span class="token function">start</span><span class="token punctuation">(</span>host<span class="token punctuation">,</span> port<span class="token punctuation">,</span> handler<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>svr <span class="token operator">*</span>http<span class="token punctuation">.</span>Server<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//封装了net/http下的ListenAndServe()</span>
		<span class="token keyword">return</span> svr<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">,</span> opts<span class="token operator">...</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">//函数类型的run入参就是net/http下的ListenAndServe()</span>
<span class="token keyword">func</span> <span class="token function">start</span><span class="token punctuation">(</span>host <span class="token builtin">string</span><span class="token punctuation">,</span> port <span class="token builtin">int</span><span class="token punctuation">,</span> handler http<span class="token punctuation">.</span>Handler<span class="token punctuation">,</span> run <span class="token keyword">func</span><span class="token punctuation">(</span>svr <span class="token operator">*</span>http<span class="token punctuation">.</span>Server<span class="token punctuation">)</span> <span class="token builtin">error</span><span class="token punctuation">,</span>
	opts <span class="token operator">...</span>StartOption<span class="token punctuation">)</span> <span class="token punctuation">(</span>err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//创建一个*http.Server类型的对象,并设置其地址和处理器属性</span>
	server <span class="token operator">:=</span> <span class="token operator">&amp;</span>http<span class="token punctuation">.</span>Server<span class="token punctuation">{<!-- --></span>
		Addr<span class="token punctuation">:</span>    fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s:%d"</span><span class="token punctuation">,</span> host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">,</span>
		Handler<span class="token punctuation">:</span> handler<span class="token punctuation">,</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> opt <span class="token operator">:=</span> <span class="token keyword">range</span> opts <span class="token punctuation">{<!-- --></span>
		<span class="token function">opt</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//创建一个健康管理器对象,用于检测服务器的健康状态</span>
	healthManager <span class="token operator">:=</span> health<span class="token punctuation">.</span><span class="token function">NewHealthManager</span><span class="token punctuation">(</span>fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s-%s:%d"</span><span class="token punctuation">,</span> probeNamePrefix<span class="token punctuation">,</span> host<span class="token punctuation">,</span> port<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token comment">//添加一个进程结束时的监听器函数,用于关闭服务器和标记健康状态为不可用</span>
	waitForCalled <span class="token operator">:=</span> proc<span class="token punctuation">.</span><span class="token function">AddWrapUpListener</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		healthManager<span class="token punctuation">.</span><span class="token function">MarkNotReady</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token keyword">if</span> e <span class="token operator">:=</span> server<span class="token punctuation">.</span><span class="token function">Shutdown</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">Background</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
			logx<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">)</span>
	<span class="token comment">//使用延迟函数,在函数返回时执行以下逻辑</span>
	<span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//如果返回的错误是http.ErrServerClosed,表示服务器已经关闭,就调用waitForCalled函数等待监听器函数执行完毕</span>
		<span class="token keyword">if</span> err <span class="token operator">==</span> http<span class="token punctuation">.</span>ErrServerClosed <span class="token punctuation">{<!-- --></span>
			<span class="token function">waitForCalled</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">//标记健康状态为可用</span>
	healthManager<span class="token punctuation">.</span><span class="token function">MarkReady</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token comment">//添加健康管理器对象到健康检测模块中</span>
	health<span class="token punctuation">.</span><span class="token function">AddProbe</span><span class="token punctuation">(</span>healthManager<span class="token punctuation">)</span>
	<span class="token comment">//调用run函数,启动服务器,并返回结果</span>
	<span class="token keyword">return</span> <span class="token function">run</span><span class="token punctuation">(</span>server<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="2"><li>到这里就来到了go的net/http标准库,具体参考<a href="https://blog.csdn.net/qq_29799655/article/details/128149375">go 进阶 http标准库相关: 三. HttpServer 服务启动到Accept等待接收连接</a>,简单复习一下net/http提供服务的流程:</li></ol> 
<blockquote> 
 <ol><li>在通过net/http编写服务端时, 首先调用NewServeMux()创建多路复用器,编写对外接收请求的接口函数也就是处理器,然后调用多路复用器上的HandleFunc()方法,将接口与接口路径进行绑定,注册路由, 最后调用ListenAndServe()函数在指定端口开启监听,启动服务</li><li>ListenAndServe()方法内部重点调用了"net.Listen(“tcp”, addr)"多路复用相关初始化,初始化socket,端口连接绑定,开启监听,调用"srv.Serve(ln)”:等待接收客户端连接Accept(),与接收到连接后的处理流程</li><li>服务相关的我们先关注"srv.Serve(ln)",方法内通过for开启了一个死循环,在循环内部,调用Listener的Accept()方法,假设当前是TCP连接调用的就是TCPListener下的Accept(),监听客户端连接,当接收到客户端连接后,通过开启协程执行serve()方法处理请求,每一个连接开启一个goroutine来处理</li></ol> 
</blockquote> 
<h3><a id="_677"></a>接收请求的处理</h3> 
<ol><li>go-zero底层是基于net/http实现的,再看一下net/http接收请求时底层是如何执行的<a href="https://blog.csdn.net/qq_29799655/article/details/128149402">go 进阶 http标准库相关: 五. HttpServer 接收请求路由发现原理</a>,</li><li>简单复习一下,基于net/http搭建服务时,底层会执行ListenAndServe()方法,最终会执行到Listener的Accept()方法,假设当前是TCP连接调用的就是TCPListener下的Accept(),阻塞监听客户端连接,当有接收到连接请求后Accept()方法返回,拿到一个新的net.Conn连接实例,然后开启协程调用Conn连接实例上的serve()方法处理客户端请求,查看这个serve()方法:</li></ol> 
<blockquote> 
 <ol><li>首先调用newBufioReader() 封装了一个bufio.Reader</li><li>开启了一个无限for循环,循环内</li><li>调用conn的readRequest(ctx)方法读取请求的内容,比如解析HTTP请求协议,读取请求头,请求参数,封装Request和response,在解析时会读取请求头的 Content-Length,不为 0会通过TCPConn.Read() 方法读取指定长度的数据并存入请求体中,如果 Content-Length 为 0 或者没有设置，则请求体为空</li><li>封装serverHandler调用serverHandler上的ServeHTTP(w, w.req)方法进行路由匹配,找到对应的处理函数，执行我们写的业务逻辑</li><li>调用response的finishRequest()方法进行最后处理工作,当底层 bufio.Writer 缓冲区的大小达到阈值或者Flush() 被显式调用时，就会将缓冲区内的数据写入到底层连接中，并触发 Conn 的 Write() 方法将数据发送到客户端,另外finishRequest()方法还会进行一些比如异常处理，资源回收，状态更新等操作</li><li>最后调用conn的setState()设置连接状态为StateIdle,方便后续重用连接</li></ol> 
</blockquote> 
<ol start="3"><li>这里执行的ServeHTTP()就是匹配路由触发业务接口的函数,ServeHTTP是一个接口,绝大多数Web框架都是通过实现该接口,从而替换掉Golang默认的路由,这里执行的就是patRouter实现的ServeHTTP(),查看该函数源码</li></ol> 
<blockquote> 
 <ol><li>首先根据请求的method在trees中获取到指定前缀树，如果存在则根据请求的reqPath路径在前缀树中查找对应的handler对象,如果找到,则调用这个handler对象的ServeHTTP()方法</li><li>在服务启动时会将添加的中间件添加到chain处理器链中,然后遍历所有中间件转换为handler链,并将接口处理函数添加到handler链的末尾,这个过程是在chain类型的Then()方法中完成的。</li><li>在路由匹配时拿到第一个中间件handler开始执行,如果执行通过,中间件中会继续调用ServeHTTP(),也就是继续执行下一个中间件,一直执行到接口处理函数</li></ol> 
</blockquote> 
<pre><code class="prism language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>pr <span class="token operator">*</span>patRouter<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token comment">//对请求的路径进行清理.去除多余的斜杠和点</span>
	reqPath <span class="token operator">:=</span> path<span class="token punctuation">.</span><span class="token function">Clean</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span>Path<span class="token punctuation">)</span> 
	<span class="token comment">//先通过请求的method获取到指定的前缀树</span>
	<span class="token keyword">if</span> tree<span class="token punctuation">,</span> ok <span class="token operator">:=</span> pr<span class="token punctuation">.</span>trees<span class="token punctuation">[</span>r<span class="token punctuation">.</span>Method<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//如果前缀树存在,则开始匹配路由</span>
		<span class="token keyword">if</span> result<span class="token punctuation">,</span> ok <span class="token operator">:=</span> tree<span class="token punctuation">.</span><span class="token function">Search</span><span class="token punctuation">(</span>reqPath<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{<!-- --></span> 
			<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>Params<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{<!-- --></span> 
				<span class="token comment">//如果结果对象中有参数,就把参数添加到请求的上下文中</span>
				r <span class="token operator">=</span> pathvar<span class="token punctuation">.</span><span class="token function">WithVars</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> result<span class="token punctuation">.</span>Params<span class="token punctuation">)</span>
			<span class="token punctuation">}</span>
			<span class="token comment">//匹配到指定路由后转换为http.Handler类型,并调用它的ServeHTTP方法处理请求</span>
			result<span class="token punctuation">.</span>Item<span class="token punctuation">.</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>Handler<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span> 
			<span class="token keyword">return</span>
		<span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	
	<span class="token comment">//如果未找到对应的前缀树调用pr.methodsAllowed方法,获取请求的路径允许的方法列表,并判断请求的方法是否在其中</span>
	allows<span class="token punctuation">,</span> ok <span class="token operator">:=</span> pr<span class="token punctuation">.</span><span class="token function">methodsAllowed</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>Method<span class="token punctuation">,</span> reqPath<span class="token punctuation">)</span> 
	<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">{<!-- --></span> <span class="token comment">// 如果请求的方法不在允许的方法列表中</span>
		<span class="token comment">//调用pr.handleNotFound方法，处理未找到的情况，并返回</span>
		pr<span class="token punctuation">.</span><span class="token function">handleNotFound</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span> 
		<span class="token keyword">return</span>
	<span class="token punctuation">}</span>
	<span class="token comment">//如果pr.notAllowed不为nil，表示有自定义的处理器对象用于处理不允许的方法的情况</span>
	<span class="token keyword">if</span> pr<span class="token punctuation">.</span>notAllowed <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//调用pr.notAllowed的ServeHTTP方法，处理请求，并返回</span>
		pr<span class="token punctuation">.</span>notAllowed<span class="token punctuation">.</span><span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
	<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span> 
		<span class="token comment">// 否则，就使用默认的处理逻辑</span>
		w<span class="token punctuation">.</span><span class="token function">Header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span>allowHeader<span class="token punctuation">,</span> allows<span class="token punctuation">)</span> <span class="token comment">//设置响应头中的Allow字段为允许的方法列表</span>
		w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusMethodNotAllowed<span class="token punctuation">)</span> <span class="token comment">//设置响应状态码为405 Method Not Allowed，并返回</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h2><a id="__726"></a>三. 总结</h2> 
<ol><li>go-zero http服务是怎么启动的, 是怎么整合net/http的, 前缀树是怎么构建的,路由,中间件是怎么注册的,当接收到请求后是怎么匹配路由执行的,当问到这些问题都可以由rest下的NewServer()函数创建服务Server开始说,下面总结一下</li><li>了解go-zero http服务首先要了解几个结构体,比如engine服务引擎,首先要创建这个引擎,内部有几个比较重要的属性比如</li></ol> 
<blockquote> 
 <ol><li>RestConf类型的conf属性: 存储了服务启动运行所需的配置信息</li><li>featuredRoutes类型的切片routes属性,在执行AddRoutes()注册接口时会将将接口封装为Router,然后将Router通过AddRoutes()保存到这个切片属性中,服务启动时会通过这个切片获取到所有路由,构建前缀树进行路由注册</li><li>Middleware类型切片的middlewares属性,会将通过Server的Use()方法注册的全局中间件保存到这个切片属性中,后续会通过这个属性获取到注册的中间件,加上局部中间件,接口handler转换为chain执行链,转换为Handler处理器链</li></ol> 
</blockquote> 
<ol start="3"><li>还有一个比较重要的结构体patRouter, 内部存在一个trees属性,内部存储了以路由的method为key的前缀树,patRouter是路由注册与请求执行的核心,该结构体实现了ServeHTTP()方法,会通过这个方法处理用户的请求</li><li>说一下服务启动的执行过程,在构建go-zero http服务时,首先需要将配置设置到RestConf结构体变量上,通过执行rest下的NewServer()函数,读取配置创建服务端的Server,查看这个NewServer()源码</li></ol> 
<blockquote> 
 <ol><li>首先调用调用newEngine()创建Engine服务引擎</li><li>调用NewRouter()函数,初始化patRouter,初始化patRouter中的trees路由前缀树</li><li>将这两个属性封装到了一个Server结构体变量,并返回,然后通过Server结构体变量调用Use()方法注册中间件,调用AddRoutes()方法注册路由,调用Start()方法启动服务</li></ol> 
</blockquote> 
<ol start="5"><li>中间件的注册: 在go-zero中可以通过Server的Use()方法注册全局中间件,可以通过WithMiddlewares/WithMiddleware()函数注册针对一组路由的局部中间件</li></ol> 
<blockquote> 
 <ol><li>通过Use()方法注册的中间件会保存到Engine的middlewares属性中</li><li>通过WithMiddlewares/WithMiddleware()函数注册的局部中间,查看源码发现,中间件函数会封装到Route的Handler中,跟随Route路由一块注册</li><li>另外go-zero的rest包下还有一个WithChain()也可以用来注册中举中间件,但是通过该函数注册的中间件会保存到Engine的chain属性中,是一个中间件链条</li></ol> 
</blockquote> 
<ol start="6"><li>路由的保存: 当通过NewServer()拿到服务Server以后,调用Server的AddRoutes()方法,将对外的接口封装为Route进行路由后注册,在AddRoutes()方法中,将路由封装为featuredRoutes,保存到了engine的routes 属性中,这是保存,后续构建前缀树的逻辑在Server的Start()启动服务方法中</li><li>当拿到服务Server以后,查看Server的Start()启动服务方法,内部会调用engine的start()方法,内部重点执行了:</li></ol> 
<blockquote> 
 <ol><li>bindRoutes(): 注册路由中间件,构建前缀树</li><li>判断如果没有配置证书,执行StartHttp()启动http服务,有配置执行StartHttps()启动https服务,触发到net/http</li></ol> 
</blockquote> 
<ol start="8"><li>bindRoutes()中间件,路由的注册与前缀树的构建,通过engine的routes属性获取到所有路由,遍历调用engine的bindFeaturedRoutes()方法开始注册路由,内部会调用engine的bindRoute(),在该方法中</li></ol> 
<blockquote> 
 <ol start="2"><li>首先获取engine的chain属性,如果为空,会调用buildChainWithNativeMiddlewares()在该方法中根据配置信息判断添加一下默认的中间件,比如判断是否配置了追踪请求的Trace中间件, 记录请求日志的Log中间件,收集请求指标数据Prometheus中间件,限制最大并发连接数的MaxConns中间件,实现熔断机制Breaker中间件 ,实现流量控制Shedding中间件,设置请求超时时间的Timeout中间件,恢复异常请求的Recover中间件…如果有配置则将这些中间件添加到chain中</li><li>遍历engine的middlewares也就是拿到全局中间件,将这些中间件也添加到到engine的chain属性中整个中间件链条封装完毕</li><li>比较重要的一个步骤,拿到路由接口的处理器Handler,执行chain的ThenFunc()方法,将保存了中间件链条的chain转换为Handler链,并将接口的处理器Handler添加到Handler链的末尾(在接收请求时根据路由匹配拿到指定的Handler后会基于这个链条向下调用到最终的接口处理函数)</li><li>调用Router的Handle()方法,将路由注册到路由树上,也就是前缀树的构建,实际执行的是patRouter的Handle(),方法中:</li><li>根据当前路由的Method判断是否存在该类型的前缀树,如果存在则调用Tree的Add()方法添加,如果不存在,则先调用调用一个NewTree()新建一个前缀树,然后调用Tree的Add()方法添加</li><li>Tree的Add()方法中会调用一个add()函数,该函数中,会根据"/“截取路由path中的每一段,作为token标识判断当前前缀树中是否已经存在该节点,如果存在则递归调用根据”/"继续截取当当前节点作为子节点判断添加前缀树中,</li><li>如果不存在则调用newNode()函数新建node节点,.以当前路由截取到的token标识为key添加到前缀树中</li></ol> 
</blockquote> 
<ol start="9"><li>Server的Start()方法服务的启动, 查看源码内部会根据是否配置了证书选择调用StartHttp()/StartHttps()启动http或https服务,以http为例,查看StartHttp()源码内最终封装调用了net/http标准库中的ListenAndServe()</li><li>了解go-zero http服务怎么接收请求执行的,要先了解net/http是怎么请求,路由匹配的,在net/http处理请求时会调用路由的ServeHTTP()方法,这里调用的就是patRouter上的这个方法,查看源码:</li></ol> 
<blockquote> 
 <ol><li>首先根据请求的method在trees中获取到指定前缀树，如果存在则根据请求的reqPath路径在前缀树中查找对应的handler对象,如果找到,则调用这个handler对象的ServeHTTP()方法</li><li>在服务启动时会将添加的中间件添加到chain处理器链中,然后遍历所有中间件转换为handler链,并将接口处理函数添加到handler链的末尾,这个过程是在chain类型的Then()方法中完成的。</li><li>在路由匹配时拿到第一个中间件handler开始执行,如果执行通过,中间件中会继续调用ServeHTTP(),也就是继续执行下一个中间件,一直执行到接口处理函数</li></ol> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/140853a03cb28ec8913ba2806d8f114a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Pytorch和CUDA版本对应关系</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b877b5d7bd28bb564e3a179bb37a5f04/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;第一节课堂内容：初识C&#43;&#43;</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>