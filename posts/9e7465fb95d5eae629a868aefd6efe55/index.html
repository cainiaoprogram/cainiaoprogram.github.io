<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker Swarm集群搭建及弹性部署 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker Swarm集群搭建及弹性部署" />
<meta property="og:description" content="本文主要演示如何通过swarm构建一个集群环境，以及服务的弹性部署。
核心概念 Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排工具，但不同的是，Docker Compose 是一个在单个服务器或主机上创建多个容器的工具，而 Docker Swarm 则可以在多个服务器或主机上创建容器集群服务，对于微服务的部署，显然 Docker Swarm 会更加适合。
Swarm 由多个 Docker 主机组成，它们以 Swarm 集群模式运行，主要包含 Manager 节点（管理者角色，管理成员和委托任务）和 Worker 节点（工作者角色，运行 Swarm 服务）。这些 Docker 主机有些是 Manager 节点，有些是 Worker 节点，或者同时扮演这两种角色。
Node节点 Swarm 集群由 Manager 节点（管理者角色，管理成员和委托任务）和 Worker 节点（工作者角色，运行 Swarm 服务）组成，每个节点对应着 Swarm 集群中的一个实例。在生产环境进行部署时，会将节点交叉分布式部署在多台物理机或云主机上，而每个节点的名称默认为机器的 hostname。
Manager：负责整个集群的管理工作包括集群配置、服务管理、容器编排等所有跟集群有关的工作，它会选举出一个 leader 来指挥编排任务；Worker：工作节点接收和执行从管理节点分派的任务（Tasks）运行在相应的服务（Services）上。 服务&amp;任务 服务（Service）是一个抽象的概念，是对集群环境中同一类型的任务的集合的统称，是集群系统的中心结构。Swarm 创建服务时，可以为服务定义以下信息等：
服务名称；使用哪个镜像来创建容器；要运行多少个副本；服务的容器要连接到哪个网络上；要映射哪些端口。 任务（Task）包括一个 Docker 容器和在容器中运行的命令，是一个集群的最小单元。
任务与容器是一对一的关系。管理节点根据服务规模中设置的副本数量将任务分配给工作节点。一旦任务被分配到一个节点，便无法移动到另一个节点。它只能在分配的节点上运行或失败。
全局服务（GlobalService）&amp;副本服务（ReplicatedService） Swarm 不只是提供了优秀的高可用性，同时也提供了节点的弹性扩容和缩容的功能。可以通过以下两种类型的 Services 部署实现：
Replicated Services：当服务需要动态扩缩容时，只需通过 scale 参数或者 --replicas n 参数指定运行相同任务的数量，即可复制出新的副本，将一系列复制任务分发至各节点当中，这种操作便称之为副本服务（Replicate）。Global Services：我们也可以通过 --mode global 参数将服务分发至全部节点之上，这种操作我们称之为全局服务（Global）。在每个节点上运行一个相同的任务，不需要预先指定任务的数量，每增加一个节点到 Swarm 中，协调器就会创建一个任务，然后调度器把任务分配给新节点。 下图用黄色表示拥有三个副本服务 Replicated Service，用灰色表示拥有一个全局服务 Global Service。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9e7465fb95d5eae629a868aefd6efe55/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-23T11:42:37+08:00" />
<meta property="article:modified_time" content="2022-03-23T11:42:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker Swarm集群搭建及弹性部署</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本文主要演示如何通过swarm构建一个集群环境，以及服务的弹性部署。</p> 
<p></p> 
<h2>核心概念</h2> 
<p>Docker Swarm 和 Docker Compose 一样，都是 Docker 官方容器编排工具，但不同的是，<strong>Docker Compose</strong> 是一个在<strong>单个服务器或主机上创建多个容器的工具</strong>，而 <strong>Docker Swarm</strong> 则可以在<strong>多个服务器或主机上创建容器集群服务</strong>，对于微服务的部署，显然 Docker Swarm 会更加适合。</p> 
<p>Swarm 由多个 Docker 主机组成，它们以 Swarm 集群模式运行，主要包含 <strong>Manager 节点</strong>（管理者角色，管理成员和委托任务）和 <strong>Worker 节点</strong>（工作者角色，运行 Swarm 服务）。这些 Docker 主机有些是 Manager 节点，有些是 Worker 节点，或者同时扮演这两种角色。</p> 
<p></p> 
<h3>Node节点</h3> 
<p>Swarm 集群由 <strong>Manager 节点</strong>（管理者角色，管理成员和委托任务）和 <strong>Worker 节点</strong>（工作者角色，运行 Swarm 服务）组成，每个节点对应着 Swarm 集群中的一个实例。在生产环境进行部署时，会将节点交叉分布式部署在多台物理机或云主机上，而<strong>每个节点的名称默认为机器的 hostname</strong>。</p> 
<ul><li><strong>Manager</strong>：负责整个集群的管理工作包括集群配置、服务管理、容器编排等所有跟集群有关的工作，它会选举出一个 leader 来指挥编排任务；</li><li><strong>Worker</strong>：工作节点接收和执行从管理节点分派的任务（Tasks）运行在相应的服务（Services）上。</li></ul> 
<p><img alt="" height="445" src="https://images2.imgbox.com/17/fd/UJTceNek_o.png" width="977"></p> 
<h3> 服务&amp;任务</h3> 
<p>　<strong>服务</strong>（Service）是一个抽象的概念，是对集群环境中同一类型的任务的集合的统称，是集群系统的中心结构。Swarm 创建服务时，可以为服务定义以下信息等：</p> 
<ul><li>服务名称；</li><li>使用哪个镜像来创建容器；</li><li>要运行多少个副本；</li><li>服务的容器要连接到哪个网络上；</li><li>要映射哪些端口。</li><li><img alt="" height="620" src="https://images2.imgbox.com/5f/f1/zpzJRwzG_o.png" width="865"></li></ul> 
<p>         <strong>任务</strong>（Task）包括<strong>一个 Docker 容器</strong>和<strong>在容器中运行的命令，</strong>是一个集群的最小单元。</p> 
<p>        任务与容器是一对一的关系。管理节点根据服务规模中设置的副本数量将任务分配给工作节点。一旦任务被分配到一个节点，便无法移动到另一个节点。它只能在分配的节点上运行或失败。</p> 
<h3>全局服务（GlobalService）&amp;副本服务（ReplicatedService）</h3> 
<p>Swarm 不只是提供了优秀的高可用性，同时也提供了节点的<strong>弹性扩容和缩容</strong>的功能。可以通过以下两种类型的 Services 部署实现：</p> 
<ul><li><strong>Replicated Services</strong>：当服务需要动态扩缩容时，只需通过 <strong><code>scale</code> </strong>参数或者<strong> <code>--replicas n</code> </strong>参数指定运行相同任务的数量，即可复制出新的副本，将一系列复制任务分发至各节点当中，这种操作便称之为<strong>副本服务</strong>（Replicate）。</li><li><strong>Global Services</strong>：我们也可以通过 <strong><code>--mode global</code> </strong>参数将服务分发至全部节点之上，这种操作我们称之为<strong>全局服务</strong>（Global）。在每个节点上运行一个相同的任务，不需要预先指定任务的数量，每增加一个节点到 Swarm 中，协调器就会创建一个任务，然后调度器把任务分配给新节点。</li></ul> 
<p>　　下图用黄色表示拥有三个副本服务 Replicated Service，用灰色表示拥有一个全局服务 Global Service。</p> 
<p><img alt="" height="690" src="https://images2.imgbox.com/ae/ba/h9uPeKns_o.png" width="942"></p> 
<h3> 工作流程</h3> 
<p><img alt="" height="848" src="https://images2.imgbox.com/22/d8/eCITjDKp_o.png" width="964"></p> 
<p></p> 
<p>Swarm Manager：</p> 
<ol><li>API：接受命令并创建 service 对象（创建对象）</li><li>orchestrator：为 service 对象创建的 task 进行编排工作（服务编排）</li><li>allocater：为各个 task 分配 IP 地址（分配 IP）</li><li>dispatcher：将 task 分发到 nodes（分发任务）</li><li>scheduler：安排一个 worker 节点运行 task（运行任务）</li></ol> 
<p>Worker Node：</p> 
<ol><li>worker：连接到调度器，检查分配的 task（检查任务）</li><li>executor：执行分配给 worker 节点的 task（执行任务）</li></ol> 
<h2>集群搭建</h2> 
<p>主要搭建由一个manager和两个worker构成的集群环境</p> 
<p>docker 版本1.12以上</p> 
<p>防火墙开启以下端口或者关闭防火墙：</p> 
<ul><li>TCP 端口 2377，用于集群管理通信；</li><li>TCP 和 UDP 端口 7946，用于节点之间通信；</li><li>UDP 端口 4789，用于覆盖网络。</li></ul> 
<table><thead><tr><th>角色</th><th>IP</th><th>HOSTNAME</th><th></th></tr></thead><tbody><tr><td>Manager</td><td>192.168.174.159</td><td>docker1</td><td></td></tr><tr><td>Worker</td><td>192.168.174.162</td><td>worker1</td><td></td></tr><tr><td>Worker</td><td>192.168.174.163</td><td>worker2</td><td></td></tr></tbody></table> 
<p> 由于每个节点名默认为主机名hostname，因此，这里需要修改每台虚拟机的主机名，修改方式如下：</p> 
<blockquote> 
 <ul><li>可以通过<strong> <code>hostname 主机名</code></strong> 修改机器的主机名（立即生效，重启后失效）；</li><li>或者 <strong><code>hostnamectl set-hostname 主机名</code></strong> 修改机器的主机名（立即生效，重启也生效）；</li><li>或者 <strong><code>vi /etc/hosts</code></strong> 编辑 hosts 文件，给 127.0.0.1 添加主机名（重启生效）。 </li></ul> 
</blockquote> 
<hr> 
<h4>创建集群</h4> 
<p>在192.168.174.159机器上执行<strong>docker swarm init</strong>指令，初始化一个新的swarm集群，该节点会默认初始化为一个<strong>manager</strong>节点。</p> 
<p>通常，第一个加入集群的管理节点将成为<strong>Leader</strong>，后来加入的管理节点都是<strong>Reachable</strong>。当前的<strong>Leader</strong>如果挂掉，所有的<strong>Reachable</strong>将重新选举一个新的<strong>Leader</strong>。</p> 
<pre><code class="language-bash">[root@docker01 ~]# docker swarm init --advertise-addr=192.168.174.159
Swarm initialized: current node (ntc6ylh1tbw5m17w19ptswfo8) is now a manager.

To add a worker to this swarm, run the following command:

    docker swarm join --token SWMTKN-1-2bzts7ixfjma7fg4d81etljp0i7tls299975t6x7xq2wgn5wph-82jgyj6xv4h4cuqnv3vujbmew 192.168.174.159:2377

To add a manager to this swarm, run 'docker swarm join-token manager' and follow the instructions.</code></pre> 
<p><img alt="" height="191" src="https://images2.imgbox.com/1b/54/ORv8Rpow_o.png" width="1200"></p> 
<p> 这里可以看到，我们以159节点为leader建立了一个swarm集群，且仅存在159一个manager节点</p> 
<hr> 
<h4>加入集群</h4> 
<p>        Docker 中内置的集群模式自带了公钥基础设施(PKI)系统，使得安全部署容器变得简单。集群中的节点使用传输层安全协议(TLS)对集群中其他节点的通信进行身份验证、授权和加密。</p> 
<p>        Manager 节点会生成两个令牌，供其他节点加入集群时使用：一个 Worker 令牌，一个 Manager 令牌。每个令牌都包括根 CA 证书的摘要和随机生成的密钥。当节点加入群集时，加入的节点使用摘要来验证来自远程管理节点的根 CA 证书。远程管理节点使用密钥来确保加入的节点是批准的节点。</p> 
<p><strong>Manager</strong></p> 
<p><img alt="" height="208" src="https://images2.imgbox.com/6d/43/hcDc98ei_o.png" width="1200"></p> 
<p>        若要向该集群添加 Manager 节点，管理节点先运行 <strong><code>docker swarm join-token manager</code></strong> 命令查看管理节点的令牌信息。</p> 
<p><img alt="" height="122" src="https://images2.imgbox.com/e4/f4/20bRMKXE_o.png" width="1200"></p> 
<p>        由于机器原因，只提供了一台机器作为manager节点，因此，不做演示，只需按照上述方式，获取加入manager集群的token令牌，然后在需要加入的机器上执行上述指令，即可作为从节点加入到manager集群中</p> 
<p><strong>Worker</strong></p> 
<p><img alt="" height="204" src="https://images2.imgbox.com/a0/18/auK3QGRG_o.png" width="1200"></p> 
<p>在初始化集群后，在其返回的结果中，会提供如何加入worker节点的指令，用户只需在对应机器上执行上述指令即可。</p> 
<p>或者，通过docker swarm join-token worker来获取相应的token令牌。</p> 
<p><img alt="" height="108" src="https://images2.imgbox.com/60/c2/z5rvDKdn_o.png" width="1200"></p> 
<p> 紧接着，在worker1和worker2节点上分比执行上述命令</p> 
<p><img alt="" height="53" src="https://images2.imgbox.com/59/eb/TPFJ70ig_o.png" width="1200"></p> 
<h4><img alt="" height="56" src="https://images2.imgbox.com/61/03/BKu13fZR_o.png" width="1200"></h4> 
<hr> 
<h4>查看集群节点信息</h4> 
<p>通过<strong>docker info</strong>可以看到每个节点的docker相关信息(服务、网络、镜像等)和swarm集群信息等</p> 
<p><img alt="" height="926" src="https://images2.imgbox.com/f2/21/5PUlOFZR_o.png" width="977"></p> 
<blockquote> 
 <p><strong> docker node ls</strong></p> 
 <p>可以在manager节点通过上述指令查看集群环境下各个节点的信息</p> 
</blockquote> 
<p><img alt="" height="124" src="https://images2.imgbox.com/43/91/LA2eKo7y_o.png" width="1200"></p> 
<p><strong> Manager status解析</strong></p> 
<p>表示节点是属于 Manager 还是 Worker，没有值则属于 Worker 节点。</p> 
<ul><li><code>Leader</code>：该节点是管理节点中的主节点，负责该集群的集群管理和编排决策；</li><li><code>Reachable</code>：该节点是管理节点中的从节点，如果 Leader 节点不可用，该节点有资格被选为新的 Leader；</li><li><code>Unavailable</code>：该管理节点已不能与其他管理节点通信。如果管理节点不可用，应该将新的管理节点加入群集，或者将工作节点升级为管理节点。</li></ul> 
<p><strong>Availability解析</strong></p> 
<p>表示调度程序是否可以将任务分配给该节点。</p> 
<ul><li><code>Active</code>：调度程序可以将任务分配给该节点；</li><li><code>Pause</code>：调度程序不会将新任务分配给该节点，但现有任务仍可以运行；</li><li><code>Drain</code>：调度程序不会将新任务分配给该节点，并且会关闭该节点所有现有任务，并将它们调度在可用的节点上。</li></ul> 
<hr> 
<h4> 删除节点</h4> 
<p><strong>Manager</strong></p> 
<p>        删除节点之前需要先将该节点的 <span style="color:#fe2c24;"><strong><code>AVAILABILITY</code> </strong></span>改为 <span style="color:#fe2c24;"><strong><code>Drain</code></strong></span>。其目的是为了将该节点的服务迁移到其他可用节点上，确保服务正常。</p> 
<pre><code>docker node update --availability drain 节点名称|节点ID</code></pre> 
<p><img alt="" height="165" src="https://images2.imgbox.com/95/2f/LpFHAqe6_o.png" width="1200"></p> 
<p>　　然后，将该 Manager 节点进行降级处理，降级为 Worker 节点。</p> 
<pre><code>docker node demote 节点名称|节点ID</code></pre> 
<p>        由于我们这里只创建了一个manager节点，如果降级为worker节点的话，就没有manager节点了，会导致swarm集群不可用，因此，执行上述命令时，会抛出以下异常</p> 
<p><img alt="" height="54" src="https://images2.imgbox.com/8b/65/B48crzPv_o.png" width="1200"></p> 
<p>         然后，在已经降级为 Worker 的节点中运行以下命令，离开集群。（在移除worker节点中演示执行过程）</p> 
<pre><code>docker swarm leave</code></pre> 
<p>　　最后，在管理节点中对刚才离开的节点进行删除。</p> 
<pre><code>docker node rm 节点名称|节点ID</code></pre> 
<p><strong>Worker</strong></p> 
<p><strong>        </strong>同理，worker节点也需要将Availability改为Drain</p> 
<pre><code>docker node update --availability drain 节点名称|节点ID</code></pre> 
<p>需要注意在manager节点上才能进行管理功能，否则就会出现以下报错</p> 
<p><img alt="" height="74" src="https://images2.imgbox.com/bd/ef/MvZLB08V_o.png" width="1200"><img alt="" height="164" src="https://images2.imgbox.com/49/a9/8Bus4Fow_o.png" width="1200"></p> 
<p>  然后，在已经降级为 Worker 的节点中运行以下命令，离开集群。(需切换到worker节点)</p> 
<pre><code>docker swarm leave</code></pre> 
<p><img alt="" height="51" src="https://images2.imgbox.com/2e/64/E2psRvq7_o.png" width="431">　　 </p> 
<p>最后，在管理节点中对刚才离开的节点进行删除。(需切换到manager节点)</p> 
<pre><code>docker node rm 节点名称|节点ID</code></pre> 
<p><img alt="" height="150" src="https://images2.imgbox.com/49/e4/1LePdkGN_o.png" width="1200"></p> 
<p>至此，swarm集群的基础操作就完成了，接下来介绍如何在当前集群中部署服务</p> 
<hr> 
<h3> 服务部署</h3> 
<blockquote> 
 <p>注意：跟集群管理有关的任何操作，都是在 Manager 节点上操作的。</p> 
</blockquote> 
<h4> 服务创建</h4> 
<p><strong>注意事项：该操作均只能在manager节点执行</strong></p> 
<p>        接下来，我们创建一个nginx的服务，改服务会由manager随机分配到某个集群的节点上进行部署启动</p> 
<pre><code>docker service create --replicas 1 --name mynginx -p 80:80 nginx</code></pre> 
<p><img alt="" height="196" src="https://images2.imgbox.com/eb/34/Nb7opi6r_o.png" width="1154"></p> 
<h4> 查看服务</h4> 
<p>可以通过<span style="color:#0d0016;"><strong>docker service ls</strong></span>查看运行的服务。</p> 
<p><img alt="" height="74" src="https://images2.imgbox.com/b4/27/qjSTLa8l_o.png" width="1194"></p> 
<p>可以通过<strong> docker service inspect 服务名称|服务id </strong>查看服务详细信息</p> 
<p><img alt="" height="961" src="https://images2.imgbox.com/7e/10/9mjzQW1A_o.png" width="1200"></p> 
<p> 可以通过<strong>docker service ps 服务名|服务id </strong>查看服务运行在哪些节点上。</p> 
<p><img alt="" height="78" src="https://images2.imgbox.com/8b/3d/axy1WKh2_o.png" width="1200"> 在对应的任务节点上运行<strong>docker ps </strong>可以查看该服务对应容器的相关信息。</p> 
<p><img alt="" height="97" src="https://images2.imgbox.com/61/0d/bdB1bXuR_o.png" width="1200"></p> 
<hr> 
<h3> 服务调用</h3> 
<p>接下来我们测试一下服务是否能被正常访问，并且该集群下任意节点的 IP 地址都要能访问到该服务才行。</p> 
<p><img alt="" height="395" src="https://images2.imgbox.com/24/25/qiTuLgV4_o.png" width="1200"></p> 
<p> 有关集群下为何任意节点都能访问该服务请参见：</p> 
<p><a href="https://blog.csdn.net/weixin_43762303/article/details/123618916" title="https://blog.csdn.net/weixin_43762303/article/details/123618916">https://blog.csdn.net/weixin_43762303/article/details/123618916</a></p> 
<hr> 
<h3>弹性扩缩容</h3> 
<p><strong>注意事项：该操作均只能在manager节点执行</strong></p> 
<p>        将 service 部署到集群以后，可以通过命令弹性扩缩容 service 中的容器数量。在 service 中运行的容器被称为 task（任务）。</p> 
<p>        通过 <span style="color:#fe2c24;"><strong><code>docker service scale 服务名称|服务ID=n</code> </strong></span>可以将 service 运行的任务扩缩容为 n 个。</p> 
<p>　　通过 <span style="color:#fe2c24;"><strong><code>docker service update --replicas n 服务名称|服务ID</code> </strong></span>也可以达到扩缩容的效果。</p> 
<p><img alt="" height="239" src="https://images2.imgbox.com/e1/77/FCW7PSbA_o.png" width="1200"></p> 
<p> 接下来，演示一波缩容的操作</p> 
<p><img alt="" height="192" src="https://images2.imgbox.com/35/55/wKkXWqMk_o.png" width="1200"></p> 
<hr> 
<h3>删除服务</h3> 
<p><strong>注意事项：该操作均只能在manager节点执行</strong></p> 
<p>通过<strong>docker service rm 服务名|服务id</strong>即可删除服务。(需在manager节点上执行)</p> 
<p><img alt="" height="100" src="https://images2.imgbox.com/7b/08/LLAVnn2o_o.png" width="472"></p> 
<hr> 
<h3>服务滚动更新以及回滚</h3> 
<p><strong>注意事项：该操作均只能在manager节点执行</strong></p> 
<p>这里我们已redis版本更迭，以及版本回滚为例，来讲解服务的滚动更新以及回滚</p> 
<p>首先，创建一个单个实例的redis服务</p> 
<pre><code>#docker service create --name 服务名 --replicas 1 -p &lt;hosts_port&gt;:&lt;container_port&gt; &lt;image&gt;
[root@docker01 ~]# docker service create --name myredis --replicas 1 -p 6379:6379 redis:latest
dfhac6ddsvdpet3l2g5qvmp3z
overall progress: 1 out of 1 tasks 
1/1: running   [==================================================&gt;] 
verify: Service converged</code></pre> 
<p>然后，扩容服务实例数到两个</p> 
<pre><code>#扩容服务个数
#docker service update --replicas 2 服务名
#docker service scale 服务名|服务id=2
[root@docker01 ~]# docker service update --replicas 2 myredis 
myredis
overall progress: 2 out of 2 tasks 
1/2: running   [==================================================&gt;] 
2/2: running   [==================================================&gt;] 
verify: Service converged </code></pre> 
<p>查看服务部署详情</p> 
<pre><code>[root@docker01 ~]# docker service ps myredis
ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE                ERROR               PORTS
6oh52ojs6iml        myredis.1           redis:latest        worker1             Running             Running about a minute ago                       
inldebtlhvw6        myredis.2           redis:latest        worker2             Running             Running 15 seconds ago  </code></pre> 
<p>接下来，我们将redis服务版本由latest更新到6</p> 
<pre><code>#滚动更新服务使用镜像
#docker service update --image 镜像名:版本 服务名

[root@docker01 ~]# docker service update --image redis:6 myredis 
myredis
overall progress: 2 out of 2 tasks 
1/2: running   [==================================================&gt;] 
2/2: running   [==================================================&gt;] 
verify: Service converged </code></pre> 
<p>这里我们可以看到部署的redis服务版本已经更新到6</p> 
<pre><code>[root@docker01 ~]# docker service ps myredis 
ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE            ERROR               PORTS
ktz1dpmgx9t4        myredis.1           redis:6             worker1             Running             Running 2 minutes ago                        
6oh52ojs6iml         \_ myredis.1       redis:latest        worker1             Shutdown            Shutdown 2 minutes ago                       
b33btvotf83w        myredis.2           redis:6             worker2             Running             Running 2 minutes ago                        
inldebtlhvw6         \_ myredis.2       redis:latest        worker2             Shutdown            Shutdown 2 minutes ago   </code></pre> 
<p>此时，我们再讲解如何进行服务的回滚</p> 
<p><strong>注意：回滚仅能回滚至最近一次的操作，无法连续回滚到指定操作（回滚两次只会取消当前的回滚操作）</strong></p> 
<pre><code>#服务回滚（仅能回滚到最近一次的操作，无法连续回滚）
#方法一：docker service rollback &lt;option&gt; 服务名
#option: -d 强制回退，不会等待停顿    -q 回退不输出相应结果日志
#方法二：docker service update --rollback 服务名

#第一次回滚
[root@docker01 ~]# docker service rollback myredis 
myredis
rollback: manually requested rollback 
overall progress: rolling back update: 2 out of 2 tasks 
1/2: running   [&gt;                                                  ] 
2/2: running   [&gt;                                                  ] 
verify: Service converged 
[root@docker01 ~]# docker service ps myredis
ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE             ERROR               PORTS
dir8apxqg0oy        myredis.1           redis:latest        worker1             Running             Running 20 seconds ago                        
ktz1dpmgx9t4         \_ myredis.1       redis:6             worker1             Shutdown            Shutdown 21 seconds ago                       
6oh52ojs6iml         \_ myredis.1       redis:latest        worker1             Shutdown            Shutdown 4 minutes ago                        
00snavmvkqvq        myredis.2           redis:latest        worker2             Running             Running 16 seconds ago                        
b33btvotf83w         \_ myredis.2       redis:6             worker2             Shutdown            Shutdown 16 seconds ago                       
inldebtlhvw6         \_ myredis.2       redis:latest        worker2             Shutdown            Shutdown 4 minutes ago  

#第二次回滚
[root@docker01 ~]# docker service update --rollback myredis
myredis
rollback: manually requested rollback 
overall progress: rolling back update: 2 out of 2 tasks 
1/2: running   [&gt;                                                  ] 
2/2: running   [&gt;                                                  ] 
verify: Service converged 
[root@docker01 ~]# docker service ps myredis 
ID                  NAME                IMAGE               NODE                DESIRED STATE       CURRENT STATE             ERROR               PORTS
vn1afbqmgqy5        myredis.1           redis:6             worker1             Running             Running 11 seconds ago                        
dir8apxqg0oy         \_ myredis.1       redis:latest        worker1             Shutdown            Shutdown 11 seconds ago                       
ktz1dpmgx9t4         \_ myredis.1       redis:6             worker1             Shutdown            Shutdown 16 minutes ago                       
6oh52ojs6iml         \_ myredis.1       redis:latest        worker1             Shutdown            Shutdown 21 minutes ago                       
7smj124onw40        myredis.2           redis:6             worker2             Running             Running 15 seconds ago                        
00snavmvkqvq         \_ myredis.2       redis:latest        worker2             Shutdown            Shutdown 15 seconds ago                       
b33btvotf83w         \_ myredis.2       redis:6             worker2             Shutdown            Shutdown 16 minutes ago                       
inldebtlhvw6         \_ myredis.2       redis:latest        worker2             Shutdown            Shutdown 21 minutes ago  
  </code></pre> 
<hr> 
<h3>Swarm常用指令总结</h3> 
<h4 id="docker-swarm"><strong>docker swarm</strong></h4> 
<table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker swarm init</td><td>初始化集群</td></tr><tr><td>docker swarm join-token worker</td><td>查看工作节点的 token</td></tr><tr><td>docker swarm join-token manager</td><td>查看管理节点的 token</td></tr><tr><td>docker swarm join</td><td>加入集群</td></tr></tbody></table> 
<h4><strong>docker node</strong>　</h4> 
<table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker node ls</td><td>查看集群所有节点</td></tr><tr><td>docker node ps</td><td>查看当前节点所有任务</td></tr><tr><td>docker node rm 节点名称|节点ID</td><td>删除节点（<code>-f</code>强制删除）</td></tr><tr><td>docker node inspect 节点名称|节点ID</td><td>查看节点详情</td></tr><tr><td>docker node demote 节点名称|节点ID</td><td>节点降级，由管理节点降级为工作节点</td></tr><tr><td>docker node promote 节点名称|节点ID</td><td>节点升级，由工作节点升级为管理节点</td></tr><tr><td>docker node update 节点名称|节点ID</td><td>更新节点</td></tr></tbody></table> 
<h4 id="docker-service"><strong>docker service</strong></h4> 
<table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker service create</td><td>创建服务</td></tr><tr><td>docker service ls</td><td>查看所有服务</td></tr><tr><td>docker service inspect 服务名称|服务ID</td><td>查看服务详情</td></tr><tr><td>docker service logs 服务名称|服务ID</td><td>查看服务日志</td></tr><tr><td>docker service rm 服务名称|服务ID</td><td>删除服务（<code>-f</code>强制删除）</td></tr><tr><td>docker service scale 服务名称|服务ID=n</td><td>设置服务数量</td></tr><tr><td>docker service rollback 服务名称|服务ID</td><td>服务回滚</td></tr><tr><td>docker service update 服务名称|服务ID</td><td> <p>更新服务，其中可以支持包含扩缩容，回滚，滚动更新等等功能</p> <p>详细请通过docker service update --help查看</p> </td></tr></tbody></table> 
<p>　　</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/59a8b717837a508b88a78730a9fd09cd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">全面&amp;详细的面试指南：计算机网络篇 (附答案)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4e8b4cbd187e04531854b7868e35d8c3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring Cloud Alibaba 之 Sentinel 集成限流</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>