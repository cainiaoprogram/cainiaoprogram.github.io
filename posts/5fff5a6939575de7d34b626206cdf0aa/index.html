<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>自己实现一个spring-AOP思路 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="自己实现一个spring-AOP思路" />
<meta property="og:description" content="aop的加载顺序要在IOC加载的前面，即是要实例完代理类之后才在这个实例上注入属性。
实现一个基于注解的aop：
1、定义一个切面注解 Aspect
/** * 切面注解 */ @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Aspect { Class&lt;? extends Annotation&gt; value(); } 2、定义一个代理接口Proxy,定义一个实现这个接口的抽象类（切面代理 AspectProxy）
/** * 代理接口 */ public interface Proxy { /** * 执行链式代理 * @param proxyChain * @return * @throws Throwable */ Object doProxy(ProxyChain proxyChain) throws Throwable; } /** * 切面代理 */ public abstract class AspectProxy implements Proxy { private static final Logger logger = LoggerFactory.getLogger(AspectProxy.class); @Override public final Object doProxy(ProxyChain proxyChain) throws Throwable { Object result = null; Class&lt;?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5fff5a6939575de7d34b626206cdf0aa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-10-14T19:35:35+08:00" />
<meta property="article:modified_time" content="2019-10-14T19:35:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">自己实现一个spring-AOP思路</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>aop的加载顺序要在IOC加载的前面，即是要实例完代理类之后才在这个实例上注入属性。</p> 
<p> 实现一个基于注解的aop：</p> 
<p><strong>  1、定义一个切面注解 Aspect</strong></p> 
<pre>/**
 * 切面注解
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Aspect {

    Class&lt;? extends Annotation&gt;  value();
}
</pre> 
<p><strong>  2、定义一个代理接口Proxy,定义一个实现这个接口的抽象类（切面代理  AspectProxy）</strong></p> 
<pre>/**
 * 代理接口
 */
public interface Proxy {
    /**
     * 执行链式代理
     * @param proxyChain
     * @return
     * @throws Throwable
     */
    Object doProxy(ProxyChain proxyChain) throws Throwable;
}
</pre> 
<pre>/**
 * 切面代理
 */
public abstract class AspectProxy implements Proxy {

    private static final Logger logger = LoggerFactory.getLogger(AspectProxy.class);

    @Override
    public final Object doProxy(ProxyChain proxyChain) throws Throwable {
        Object result = null;

        Class&lt;?&gt; cls = proxyChain.getTargetClass();
        Method method = proxyChain.getTargetMethod();
        Object[] params = proxyChain.getMethodParams();

        begin();
        try {
            if (intercept(cls, method, params)) {
               boolean flag = before(cls, method, params);
                if(!flag){
                   return "...";
                }
                  result = proxyChain.doProxyChain();
                after(cls, method, params, result);
            } else {
                result = proxyChain.doProxyChain();
            }
        } catch (Exception e) {
            logger.error("proxy failure", e);
            error(cls, method, params, e);
            throw e;
        } finally {
            end();
        }

        return result;
    }

    public void begin() {
    }

    public boolean intercept(Class&lt;?&gt; cls, Method method, Object[] params) throws Throwable {
        return true;
    }

    public boolean before(Class&lt;?&gt; cls, Method method, Object[] params) throws Throwable {
        return true;
    }

    public boolean after(Class&lt;?&gt; cls, Method method, Object[] params, Object result) throws Throwable {
        return true;
    }

    public void error(Class&lt;?&gt; cls, Method method, Object[] params, Throwable e) {
    }

    public void end() {
    }
}</pre> 
<p><strong> 3、定义一个代理链ProxyChain</strong></p> 
<pre>/**
 * 代理链
 *
 */
public class ProxyChain {

    private final Class&lt;?&gt; targetClass;//目标类
    private final Object targetObject;//目标对象
    private final Method targetMethod;//目标方法
    private final MethodProxy methodProxy;//方法代理
    private final Object[] methodParams;//方法参数

    private List&lt;Proxy&gt; proxyList = new ArrayList&lt;Proxy&gt;();//代理列表
    private int proxyIndex = 0;//代理索引

    public ProxyChain(Class&lt;?&gt; targetClass, Object targetObject, Method targetMethod, MethodProxy methodProxy, Object[] methodParams, List&lt;Proxy&gt; proxyList) {
        this.targetClass = targetClass;
        this.targetObject = targetObject;
        this.targetMethod = targetMethod;
        this.methodProxy = methodProxy;
        this.methodParams = methodParams;
        this.proxyList = proxyList;
    }

    public Object[] getMethodParams() {
        return methodParams;
    }

    public Class&lt;?&gt; getTargetClass() {
        return targetClass;
    }

    public Method getTargetMethod() {
        return targetMethod;
    }

    public Object doProxyChain() throws Throwable {
        Object methodResult;
        if (proxyIndex &lt; proxyList.size()) {//如果链还没调用完
            methodResult = proxyList.get(proxyIndex++).doProxy(this);//调用切面代理类，切面代理类会回调
        } else {//调用完成，执行目标对象的业务逻辑
            methodResult = methodProxy.invokeSuper(targetObject, methodParams);
        }
        return methodResult;
    }
}</pre> 
<p> 4、定义一个代理管理器 ProxyManager，该类会在项目启动的时候就被调用，用来实例化目标类</p> 
<p>  </p> 
<pre> * 代理管理器
 *
 */
public class ProxyManager {

    @SuppressWarnings("unchecked")
    public static &lt;T&gt; T createProxy(final Class&lt;?&gt; targetClass, final List&lt;Proxy&gt; proxyList) {
        return (T) Enhancer.create(targetClass, new MethodInterceptor() {
            @Override
            public Object intercept(Object targetObject, Method targetMethod, Object[] methodParams, MethodProxy methodProxy) throws Throwable {
                return new ProxyChain(targetClass, targetObject, targetMethod, methodProxy, methodParams, proxyList).doProxyChain();//生成完整的代理链职责实例
            }
        });
    }
}</pre> 
<p>5、AOPHelper,负责项目启动时，获取需要生成代理的类，调用ProxyManager,实例化好这些类后保存实例在beans中，后续访问调用将拥有aop功能。</p> 
<p>  </p> 
<pre>static {
    try {
        Map&lt;Class&lt;?&gt;, Set&lt;Class&lt;?&gt;&gt;&gt; proxyMap = createProxyMap();//获取AspectProxy的子类，如果子类有Aspect注解，获取注解中的值，这个值也是个注解类，根据这个注解类去获取所有含有这个注解类的类（这个是基于注解的aop的关键）
        Map&lt;Class&lt;?&gt;, List&lt;Proxy&gt;&gt; targetMap = createTargetMap(proxyMap);//根据上一步组装将要被代理的目标类的代理链
        for (Map.Entry&lt;Class&lt;?&gt;, List&lt;Proxy&gt;&gt; targetEntry : targetMap.entrySet()) {//变量每个需要被代理的类
            Class&lt;?&gt; targetClass = targetEntry.getKey();
            List&lt;Proxy&gt; proxyList = targetEntry.getValue();
            System.out.println("targetClass:"+targetClass.getName());
            System.out.println("proxyList:"+proxyList.get(0).toString());
            Object proxy = ProxyManager.createProxy(targetClass, proxyList);//实例化
            BeanHelper.setBean(targetClass, proxy);//将实例化好的代理类保存到Beans中

        }
    } catch (Exception e) {
        LOGGER.error("aop failure", e);
    }
}</pre> 
<p>------------------------------------------------------至此，一个简单的aop开发完成-----------------------------------------</p> 
<p>调用：</p> 
<p>   </p> 
<pre>/**
 * 拦截 Controller 所有方法,这里可以做权限控制，日志记录，性能监控等等
 */
@Aspect(Controller.class)
public class ControllerAspect extends AspectProxy {

    private static final Logger LOGGER = LoggerFactory.getLogger(ControllerAspect.class);

    private long begin;

    @Override
    public boolean before(Class&lt;?&gt; cls, Method method, Object[] params) throws Throwable {
        LOGGER.debug("---------- begin ControllerAspect ----------");

        if(true){
            return true;
        }
        return false;
    }

    @Override
    public boolean after(Class&lt;?&gt; cls, Method method, Object[] params, Object result) throws Throwable {

        LOGGER.debug("----------- end ControllerAspect-----------");
        if(true){
            return true;
        }
        return false;
    }
}</pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9204910f99e563faa9ca83822ce2ad34/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Npm的作用及其与Node.js的关系</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e65ac7aff598ab862d2f2092f5bb3104/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数学分析教学：第一章</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>