<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>PTA习题7-4 堆栈模拟队列 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="PTA习题7-4 堆栈模拟队列" />
<meta property="og:description" content="设已知有两个堆栈S1和S2，请用这两个堆栈模拟出一个队列Q。
所谓用堆栈模拟队列，实际上就是通过调用堆栈的下列操作函数:
int IsFull(Stack S)：判断堆栈S是否已满，返回1或0；int IsEmpty (Stack S )：判断堆栈S是否为空，返回1或0；void Push(Stack S, ElementType item )：将元素item压入堆栈S；ElementType Pop(Stack S )：删除并返回S的栈顶元素。 实现队列的操作，即入队void AddQ(ElementType item)和出队ElementType DeleteQ()。
输入格式: 输入首先给出两个正整数N1和N2，表示堆栈S1和S2的最大容量。随后给出一系列的队列操作：A item表示将item入列（这里假设item为整型数字）；D表示出队操作；T表示输入结束。
输出格式: 对输入中的每个D操作，输出相应出队的数字，或者错误信息ERROR:Empty。如果入队操作无法执行，也需要输出ERROR:Full。每个输出占1行。
输入样例: 3 2 A 1 A 2 A 3 A 4 A 5 D A 6 D A 7 D A 8 D D D D T 输出样例: ERROR:Full 1 ERROR:Full 2 3 4 7 8 ERROR:Empty 给大家讲一个乐子事儿，这是我原始的代码，在第一个测试点屡屡碰壁：
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #define ERROR -1 typedef int ElementType; typedef int Pos; typedef struct SNode *Stack; struct SNode { ElementType *Data; Pos Top; int MaxSize; }; Stack Creastack(int size) { Stack S=(Stack)malloc(sizeof(struct SNode)); S-&gt;Data=(ElementType*)malloc(size*sizeof(ElementType)); S-&gt;Top=-1; S-&gt;MaxSize=size; return S; } int IsFull(Stack S) { return S-&gt;Top==(S-&gt;MaxSize-1); } int IsEmpty(Stack S) { return S-&gt;Top==-1; } void Push(Stack S,ElementType item) { if(IsFull(S)) { printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c2c541a6cb90a9dbd27157a3a1bdde44/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-07T16:16:22+08:00" />
<meta property="article:modified_time" content="2023-04-07T16:16:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">PTA习题7-4 堆栈模拟队列</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>设已知有两个堆栈S1和S2，请用这两个堆栈模拟出一个队列Q。</p> 
<p>所谓用堆栈模拟队列，实际上就是通过调用堆栈的下列操作函数:</p> 
<ul><li><code>int IsFull(Stack S)</code>：判断堆栈<code>S</code>是否已满，返回1或0；</li><li><code>int IsEmpty (Stack S )</code>：判断堆栈<code>S</code>是否为空，返回1或0；</li><li><code>void Push(Stack S, ElementType item )</code>：将元素<code>item</code>压入堆栈<code>S</code>；</li><li><code>ElementType Pop(Stack S )</code>：删除并返回<code>S</code>的栈顶元素。</li></ul> 
<p>实现队列的操作，即入队<code>void AddQ(ElementType item)</code>和出队<code>ElementType DeleteQ()</code>。</p> 
<h4 id="输入格式">输入格式:</h4> 
<p>输入首先给出两个正整数<code>N1</code>和<code>N2</code>，表示堆栈<code>S1</code>和<code>S2</code>的最大容量。随后给出一系列的队列操作：<code>A item</code>表示将<code>item</code>入列（这里假设<code>item</code>为整型数字）；<code>D</code>表示出队操作；<code>T</code>表示输入结束。</p> 
<h4 id="输出格式">输出格式:</h4> 
<p>对输入中的每个<code>D</code>操作，输出相应出队的数字，或者错误信息<code>ERROR:Empty</code>。如果入队操作无法执行，也需要输出<code>ERROR:Full</code>。每个输出占1行。</p> 
<h4 id="输入样例">输入样例:</h4> 
<pre><code>3 2
A 1 A 2 A 3 A 4 A 5 D A 6 D A 7 D A 8 D D D D T
</code></pre> 
<h4 id="输出样例">输出样例:</h4> 
<pre><code>ERROR:Full
1
ERROR:Full
2
3
4
7
8
ERROR:Empty</code></pre> 
<p>给大家讲一个乐子事儿，这是我原始的代码，在第一个测试点屡屡碰壁：</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define ERROR -1
typedef int ElementType;
typedef int Pos;
typedef struct SNode *Stack;
struct SNode
{
    ElementType *Data;
    Pos Top;
    int MaxSize;
};
Stack Creastack(int size)
{
    Stack S=(Stack)malloc(sizeof(struct SNode));
    S-&gt;Data=(ElementType*)malloc(size*sizeof(ElementType));
    S-&gt;Top=-1;
    S-&gt;MaxSize=size;
    return S;
}
int IsFull(Stack S)
{
    return S-&gt;Top==(S-&gt;MaxSize-1);
}
int IsEmpty(Stack S)
{
    return S-&gt;Top==-1;
}
void Push(Stack S,ElementType item)
{
    if(IsFull(S))
    {
        printf("ERROR:Full\n");
    }
    else
        S-&gt;Data[++S-&gt;Top]=item;
}
ElementType Pop(Stack S)
{
    if(IsEmpty(S))
    {
        return ERROR;
    }
    else
    {
        return S-&gt;Data[S-&gt;Top--];
    }
}
void AddQ(ElementType item,Stack S1,Stack S2)
{
    if (IsFull(S1) &amp;&amp; !IsEmpty(S2))
    {
        printf("ERROR:Full\n");
        return;
    }
    if (IsFull(S1)&amp;&amp;IsEmpty(S2))
        {
            while(!IsEmpty(S1))
            {
                Push(S2,Pop(S1));
            }
        }
    Push(S1, item);
}
ElementType DeleteQ(Stack S1,Stack S2)
{
      if (IsEmpty(S1) &amp;&amp; IsEmpty(S2))
      {
        printf("ERROR:Empty\n");
        return ERROR;
      }
    if (IsEmpty(S2))
    {
        while (!IsEmpty(S1))
        {
            Push(S2, Pop(S1));
        }
    }
    return Pop(S2);
}
int main()
{
    int N1,N2,item;
    char chao;
    Stack S1,S2;
    scanf("%d %d",&amp;N1,&amp;N2);
    S1=Creastack(N2);
    S2=Creastack(N1);
    while(scanf(" %c",&amp;chao)!= EOF &amp;&amp;chao!='T')
    {
        if(chao=='A')
        {
            scanf(" %d",&amp;item);
            AddQ(item,S1,S2);
        }
        else if(chao=='D')
        {
           ElementType ele=DeleteQ(S1,S2);
            if(ele!=ERROR)
                printf("%d\n",ele);
        }
    }
    return 0;
}</code></pre> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/a0/58/yf3mTpwS_o.png" width="1200"></p> 
<p> 但是实在没办法了，交换生成S1和S2时的预设大小，就可以过了，实在没搞懂......</p> 
<pre><code class="language-cs">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#define ERROR -1
typedef int ElementType;
typedef int Pos;
typedef struct SNode *Stack;
struct SNode
{
    ElementType *Data;
    Pos Top;
    int MaxSize;
};
Stack Creastack(int size)
{
    Stack S=(Stack)malloc(sizeof(struct SNode));
    S-&gt;Data=(ElementType*)malloc(size*sizeof(ElementType));
    S-&gt;Top=-1;
    S-&gt;MaxSize=size;
    return S;
}
int IsFull(Stack S)
{
    return S-&gt;Top==(S-&gt;MaxSize-1);
}
int IsEmpty(Stack S)
{
    return S-&gt;Top==-1;
}
void Push(Stack S,ElementType item)
{
    if(IsFull(S))
    {
        printf("ERROR:Full\n");
    }
    else
        S-&gt;Data[++S-&gt;Top]=item;
}
ElementType Pop(Stack S)
{
    if(IsEmpty(S))
    {
        return ERROR;
    }
    else
    {
        return S-&gt;Data[S-&gt;Top--];
    }
}
void AddQ(ElementType item,Stack S1,Stack S2)
{
    if (IsFull(S1) &amp;&amp; !IsEmpty(S2))
    {
        printf("ERROR:Full\n");
        return;
    }
    if (IsFull(S1)&amp;&amp;IsEmpty(S2))
        {
            while(!IsEmpty(S1))
            {
                Push(S2,Pop(S1));
            }
        }
    Push(S1, item);
}
ElementType DeleteQ(Stack S1,Stack S2)
{
      if (IsEmpty(S1) &amp;&amp; IsEmpty(S2))
      {
        printf("ERROR:Empty\n");
        return ERROR;
      }
    if (IsEmpty(S2))
    {
        while (!IsEmpty(S1))
        {
            Push(S2, Pop(S1));
        }
    }
    return Pop(S2);
}
int main()
{
    int N1,N2,item;
    char chao;
    Stack S1,S2;
    scanf("%d %d",&amp;N1,&amp;N2);
    S1=Creastack(N2);
    S2=Creastack(N1);
    while(scanf(" %c",&amp;chao)!= EOF &amp;&amp;chao!='T')
    {
        if(chao=='A')
        {
            scanf(" %d",&amp;item);
            AddQ(item,S1,S2);
        }
        else if(chao=='D')
        {
           ElementType ele=DeleteQ(S1,S2);
            if(ele!=ERROR)
                printf("%d\n",ele);
        }
    }
    return 0;
}</code></pre> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/0e/2b/cSwHJVh7_o.png" width="1200"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/72f6ccb82a77d68cc7fc6690e3e8f9e1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python中float(“inf“)、float(“-inf“)用法，以及递归函数和DFS中巧妙利用正负无穷大每次返回值</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b33dec1ffd65c1437613441c2643314d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CTF（Capture The Flag ）环境搭建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>