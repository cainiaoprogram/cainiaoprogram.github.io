<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android事件分发机制之dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android事件分发机制之dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent" />
<meta property="og:description" content="前言
Android事件分发机制可以说是我们android工程师面试中必考题，弄懂它的原理是我们避不开的任务，随意长痛不如短痛，花点时间干掉他，我们开始吧
Android事件分发机制简介
Android事件分发机制的发生在View与View之间或者ViewGroup与View之间具有镶嵌的视图上，而且视图上必须为点击可用。当一个点击事件产生后，它的传递过程遵循如下顺序：Activity -&gt; Window-&gt;View,即事件先传递给Activity,再到Window,再到顶级View,才开始我们的事件分发；
Android事件分发相关概念
Android事件分发机制主要由三个重要的方法共同完成的
1. dispatchTouchEvent:用于点击事件的分发
2. onInterceptTouchEvent：用于点击事件的拦截
3. onTouchEvent:用于处理点击事件
主要注意View中是没有onInterceptTouchEvent()方法的
Android事件分发机制的分发例子
这里两个ViewGroup嵌套View来演示，
一、MyView
继承View并覆写其三个构造方法，覆写dispatchTouchEvent和onTouchEvent
public class MyView extends View {
public MyView(Context context) {
super(context);
}
public MyView(Context context, AttributeSet attrs, int defStyleAttr) {
super(context, attrs, defStyleAttr);
}
public MyView(Context context, AttributeSet attrs) {
super(context, attrs);
}
@Override
public boolean dispatchTouchEvent(MotionEvent event) {
System.out.println(&#34;MyView dispatchTouchEvent&#34;);
return super.dispatchTouchEvent(event);
}
@Override
public boolean onTouchEvent(MotionEvent event) {" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/54b66823a0e9a03e583fec1fe62b29e8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-15T17:02:53+08:00" />
<meta property="article:modified_time" content="2022-12-15T17:02:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android事件分发机制之dispatchTouchEvent、onInterceptTouchEvent、onTouchEvent</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>前言</strong></p> 
<p>Android事件分发机制可以说是我们android工程师面试中必考题，弄懂它的原理是我们避不开的任务，随意长痛不如短痛，花点时间干掉他，我们开始吧</p> 
<p><strong>Android事件分发机制简介</strong></p> 
<p>Android事件分发机制的发生在View与View之间或者ViewGroup与View之间具有镶嵌的视图上，而且视图上必须为点击可用。当一个点击事件产生后，它的传递过程遵循如下顺序：Activity -&gt; Window-&gt;View,即事件先传递给Activity,再到Window,再到顶级View,才开始我们的事件分发；</p> 
<p>Android事件分发相关概念</p> 
<p>Android事件分发机制主要由三个重要的方法共同完成的</p> 
<p>1. dispatchTouchEvent:用于点击事件的分发</p> 
<p>2. onInterceptTouchEvent：用于点击事件的拦截</p> 
<p>3. onTouchEvent:用于处理点击事件</p> 
<p>主要注意View中是没有onInterceptTouchEvent()方法的</p> 
<p>Android事件分发机制的分发例子</p> 
<p>这里两个ViewGroup嵌套View来演示，</p> 
<p>一、MyView</p> 
<p>继承View并覆写其三个构造方法，覆写dispatchTouchEvent和onTouchEvent</p> 
<p>public class MyView extends View {<!-- --><br>     public MyView(Context context) {<!-- --><br>         super(context);<br>     }</p> 
<p>    public MyView(Context context, AttributeSet attrs, int defStyleAttr) {<!-- --><br>         super(context, attrs, defStyleAttr);<br>     }</p> 
<p>    public MyView(Context context, AttributeSet attrs) {<!-- --><br>         super(context, attrs);<br>     }</p> 
<p>    @Override<br>     public boolean dispatchTouchEvent(MotionEvent event) {<!-- --><br>         System.out.println("MyView dispatchTouchEvent");<br>         return super.dispatchTouchEvent(event);<br>     }</p> 
<p>    @Override<br>     public boolean onTouchEvent(MotionEvent event) {<!-- --><br>         System.out.println("MyView onTouchEvent");<br>         return super.onTouchEvent(event);<br>     }<br> }</p> 
<p>二、MyViewGroup01和MyViewGroup02</p> 
<p>MyViewGroup01和MyViewGroup02是一样的代码，这里以01为例，继承ViewGroup并覆写其三个构造方法，覆写dispatchTouchEvent和onTouchEvent和onInterceptTouchEvent方法</p> 
<p>public class MyViewGroup01 extends LinearLayout {<!-- --></p> 
<p>    public MyViewGroup01(Context context) {<!-- --><br>         super(context);<br>     }</p> 
<p>    public MyViewGroup01(Context context, AttributeSet attrs, int defStyleAttr) {<!-- --><br>         super(context, attrs, defStyleAttr);<br>     }</p> 
<p>    public MyViewGroup01(Context context, AttributeSet attrs) {<!-- --><br>         super(context, attrs);<br>     }</p> 
<p>    @Override<br>     public boolean dispatchTouchEvent(MotionEvent ev) {<!-- --><br>         System.out.println("MyViewGroup01 dispatchTouchEvent");<br>         return super.dispatchTouchEvent(ev);<br>     }</p> 
<p>    @Override<br>     public boolean onInterceptTouchEvent(MotionEvent ev) {<!-- --><br>         System.out.println("MyViewGroup01 onInterceptTouchEvent");<br>         return super.onInterceptTouchEvent(ev);<br>     }</p> 
<p>    @Override<br>     public boolean onTouchEvent(MotionEvent event) {<!-- --><br>         System.out.println("MyViewGroup01 onTouchEvent");<br>         return super.onTouchEvent(event);<br>     }<br> }<br>  </p> 
<p>三、MyView和MyViewGroup布局文件</p> 
<p>这里以ViewGroup和Group嵌套，由上面可以知道事件最后分配到布局的顶级View，这里的顶级View是MyViewGroup02，然后开始事件的传递</p> 
<p>&lt;?xml version="1.0" encoding="utf-8"?&gt;<br> &lt;com.handsome.boke2.TouchEvent.MyViewGroup02 xmlns:android="http://schemas.android.com/apk/res/android"<br>     android:layout_width="200dp"<br>     android:layout_height="200dp"<br>     android:background="#0f0"&gt;</p> 
<p>    &lt;com.handsome.boke2.TouchEvent.MyViewGroup01<br>         android:layout_width="100dp"<br>         android:layout_height="100dp"<br>         android:background="#f00"&gt;</p> 
<p>        &lt;com.handsome.boke2.TouchEvent.MyView<br>             android:layout_width="50dp"<br>             android:layout_height="50dp"<br>             android:background="#00f" /&gt;<br>     &lt;/com.handsome.boke2.TouchEvent.MyViewGroup01&gt;<br> &lt;/com.handsome.boke2.TouchEvent.MyViewGroup02&gt;</p> 
<h3>分析事件传递</h3> 
<p>点击MyView（即蓝色部分）：先接收事件的是父容器（MyViewGroup02）往下分发，而事件的分发过程中分为两步骤</p> 
<p>分发过程<br> 处理过程<br> 其正常的分发事件结果为</p> 
<p>//分发过程<br> MyViewGroup02 dispatchTouchEvent<br> MyViewGroup02 onInterceptTouchEvent<br> MyViewGroup01 dispatchTouchEvent<br> MyViewGroup01 onInterceptTouchEvent<br> MyView dispatchTouchEvent<br> //处理过程<br> MyView onTouchEvent<br> MyViewGroup01 onTouchEvent<br> MyViewGroup02 onTouchEvent<br><br><strong>1、dispatchTouchEvent（分发事件）</strong><br> 如果在MyViewGroup01中的dispatchTouchEvent方法中返回true，表示需要在MyViewGroup01消费了整个事件，即不会再分发，也不会再处理。dispatchTouchEvent方法中返回true的打印信息</p> 
<p> //分发过程</p> 
<p>MyViewGroup02 ： dispatchTouchEvent</p> 
<p>MyViewGroup02:   onIntetceptTouchEvent</p> 
<p>MyViewGroup01： dispatchTouchEvent</p> 
<p>如果在MyViewGroup01中disPatchTouchEvent返回false,表示在MyViewGroup01点击事件在本层不再进行分发，并交由上层控件OnTouchEvent方法进行处理。dispatchTouchEvent方法中返回false的打印信息</p> 
<p>//分发过程</p> 
<p>MyViewGroup02: dispatchTouchEvent</p> 
<p>MyViewGroup02: onInterceptTouchEvent</p> 
<p>MyViewGroup02: dispatchTouchEvent</p> 
<p>//处理过程</p> 
<p>MyViewGroup02: onTouchEnvent</p> 
<p><strong>2. OnInterceptTouchEvent （ 拦截事件）</strong></p> 
<p>如果在MyViewGroup01中的onInterceptTouchEvent中返回true，表示需要在MyViewGroup01拦截这个点击事件，不再继续下发，即MyView不再执行dispatchTouchEvent方法。但是只是分发结束而已，接着开始处理事件。下面是onInterceptTouchEvent方法中返回True的打印信息</p> 
<p>//分发事件</p> 
<p>MyViewGroup02 : dispatchTouchEvent</p> 
<p>MyViewGroup02: onInterceptTouchEvent</p> 
<p>MyViewGroup01: dispthTouchEvent</p> 
<p>MyViewGroup01: onInterceptTouchEvent</p> 
<p>//处理事件</p> 
<p>MyViewGroup01： onTouchEvent</p> 
<p>MyViewGroup02:   onTouchEvent</p> 
<p>如果在MyViewGroup01的onInterceptTouchEvent中返回false，表示MyViewGroup01不会拦截这个点击事件，继续往下分发。下面是OnInterceptTouchEvent方法中返回false的打印信息</p> 
<p>//分发事件</p> 
<p>MyViewGroup02 : disptchTouchEvent</p> 
<p>MyViewGroup02: onInterceptTouchEvent</p> 
<p>MyViewGroup01：dispatchTouchEvent</p> 
<p>MyViewGroup01: onInterceptTouchEvent</p> 
<p>//处理过程</p> 
<p>MyView : dispatchTouchEvent</p> 
<p>MyView:  onTouchEvent</p> 
<p>MyViewGroup01: onTouchEvent</p> 
<p>MyViewGroup02: onTouchEvent</p> 
<p><strong>3. onTouchEvent (消费事件)</strong></p> 
<p>如果MyViewGroup01中的onTouchEvent方法中返回true, 表示MyViewGroup01可以将该事件直接消费掉了，即分发结束后，处理事件的时候，直接处理MyGroup01就可以结束了。下面是onTouchEvent方法中的打印信息</p> 
<p>//分发过程</p> 
<p>MyViewGroup02： dispatchTouchEvent</p> 
<p>MyViewGroup02:  onInterceptTouchEvent</p> 
<p>MyViewGroup01: dispatchTouchEvent</p> 
<p>MyViewGroup01: onInterceptTouchEvent</p> 
<p>MyView: dispatchTouchEvent</p> 
<p>MyView：onInterceptTouchEvent</p> 
<p>//事件处理</p> 
<p>MyView: onTouchEvent</p> 
<p>MyViewGroup01：onTouchEvent </p> 
<p>如果MyViewGroup01中的onTouchEvent方法中返回false,表示MyViewGroup01不可以将该事件直接消费掉，即事件继续往上处理。下面是OnTouchEvent方法中返回false的打印信息</p> 
<p>//分发事件</p> 
<p>MyViewGroup02: dispatchTouchEvent</p> 
<p>MyViewGroup02: onIntercepterTouchEvent</p> 
<p>MyViewGroup01: dispatchTouchEvent </p> 
<p>MyViewGroup01: onInterceptTouchEvent</p> 
<p>MyView  ondisptchTouchEvent</p> 
<p>//处理事件</p> 
<p>MyView  onTouchEvent</p> 
<p>MyViewGroup01 ： onTouchEvent</p> 
<p>MyViewGroup02： onTouchEvent</p> 
<p><strong>总结起来</strong></p> 
<p>1. <strong>dispatchTouchEvent</strong></p> 
<p>return true; 表示该view内部消化掉了所有事件</p> 
<p>return false: 表示事件在本层不再继续分发，并交由上层控件的onTouchEvent方法进行消费</p> 
<p>return super.dispatchTouchEvent(ev) 默认事件将分发给本层事件拦截onInterceptTouchEvent</p> 
<p><strong>2. onInterceptTouchEvent</strong></p> 
<p>return true: 表示将事件进行拦截，并将拦截到的事件交由本层的 onTouchEvent进行处理</p> 
<p>return false: 表示不进行事件拦截处理，事件得以分发到子View</p> 
<p>return super.onInterceptTouchEvent(ev) 默认表示不拦截该事件，并将事件传递给下一层的view的dispatchTouchEvent;</p> 
<p>3. onTouchEvent</p> 
<p>return true: 表示onTouchEvent处理完事件后消费了此事件</p> 
<p>return false : 表示不响应事件，那么该事件将不断的向上层view的onTouchEvent方法传递；</p> 
<p>return super.onTouchEvent(ev) 表示不响应事件，与return false一样；</p> 
<p></p> 
<p>Android事件分发机制的分发流程</p> 
<p>ViewGroup事件分发源码分析</p> 
<p>我们这里以ViewGroup的dispatchTouchEvent()开始讲解，这里主要讲两件事情：</p> 
<p>询问是否拦截事件</p> 
<p>遍历子View并分发事件</p> 
<p>一： dispatchTouchEvent源码询问拦截事件</p> 
<p>@Override<br> public boolean dispatchTouchEvent(MotionEvent ev) {<!-- --><br>       ......<br>     <br>     // Check for interception.<br>     final boolean intercepted;<br>     //这里检查是否拦截事件<br>     if (actionMasked == MotionEvent.ACTION_DOWN<br>             || mFirstTouchTarget != null) {<!-- --><br>         final boolean disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0;<br>         if (!disallowIntercept) {<!-- --><br>             intercepted = onInterceptTouchEvent(ev);<br>             ev.setAction(action); // restore action in case it was changed<br>         } else {<!-- --><br>             intercepted = false;<br>         }<br>     } else {<!-- --><br>         // There are no touch targets and this action is not an initial down<br>         // so this view group continues to intercept touches.<br>         intercepted = true;<br>     }</p> 
<p>    ......<br> }<br> ViewGroup在两种情况下都会判断是否要拦截当前事件</p> 
<p>事件类型为Action_down: 当我们触发的点击事件，也就是说Action_move和Action_up事件来时，则不触发拦截事件；</p> 
<p> mFirstTouchTarget !=null: 当ViewGroup不拦截事件并将事件交给自View的时候该不等式成立；反过来，事件被ViewGroup拦截时，该不等式不成立；</p> 
<p>二，dispatchTouchEvent源码遍历子View并分发事件</p> 
<p>@Override<br> public boolean dispatchTouchEvent(MotionEvent ev) {<!-- --><br>         <br>     ......<br>     <br>     final View[] children = mChildren;<br>     //遍历所有子View<br>     for (int i = childrenCount - 1; i &gt;= 0; i--) {<!-- --><br>         final int childIndex = getAndVerifyPreorderedIndex(<br>                 childrenCount, i, customOrder);<br>         final View child = getAndVerifyPreorderedView(<br>                 preorderedList, children, childIndex);<br>     <br>         //判断子View是否能接收点击事件<br>         if (childWithAccessibilityFocus != null) {<!-- --><br>             if (childWithAccessibilityFocus != child) {<!-- --><br>                 continue;<br>             }<br>             childWithAccessibilityFocus = null;<br>             i = childrenCount - 1;<br>         }<br>     <br>         //判断子元素在播放动画时落在子元素的区域内<br>         if (!canViewReceivePointerEvents(child)<br>                 || !isTransformedTouchPointInView(x, y, child, null)) {<!-- --><br>             ev.setTargetAccessibilityFocus(false);<br>             continue;<br>         }<br>         <br>         //判断子元素点击事件是否落在子元素的区域内<br>         newTouchTarget = getTouchTarget(child);<br>         if (newTouchTarget != null) {<!-- --><br>             // Child is already receiving touch within its bounds.<br>             // Give it the new pointer in addition to the ones it is handling.<br>             newTouchTarget.pointerIdBits |= idBitsToAssign;<br>             break;<br>         }<br>     <br>         resetCancelNextUpFlag(child);<br>         //事件传递到子View，下面追踪该方法<br>         if (dispatchTransformedTouchEvent(ev, false, child, idBitsToAssign)) {<!-- --><br>             // Child wants to receive touch within its bounds.<br>             mLastTouchDownTime = ev.getDownTime();<br>             if (preorderedList != null) {<!-- --><br>                 // childIndex points into presorted list, find original index<br>                 for (int j = 0; j &lt; childrenCount; j++) {<!-- --><br>                     if (children[childIndex] == mChildren[j]) {<!-- --><br>                         mLastTouchDownIndex = j;<br>                         break;<br>                     }<br>                 }<br>             } else {<!-- --><br>                 mLastTouchDownIndex = childIndex;<br>             }<br>             mLastTouchDownX = ev.getX();<br>             mLastTouchDownY = ev.getY();<br>             newTouchTarget = addTouchTarget(child, idBitsToAssign);<br>             alreadyDispatchedToNewTouchTarget = true;<br>             break;<br>         }<br>     <br>         // The accessibility focus didn't handle the event, so clear<br>         // the flag and do a normal dispatch to all children.<br>         ev.setTargetAccessibilityFocus(false);<br>     }</p> 
<p>    ......<br> }<br> ViewGroup直接使用for遍历所有子View，对子View的各种状态进行判断，最好调用dispatchTransformTouchEvent(ev,false,child,idBitsToAssign)将事件传递给子View，下面是dispatchTransformedTouchEvent()方法部分源码</p> 
<p>if (child == null) {<!-- --></p> 
<p>handled = super.dispatchTouchEvent(event);</p> 
<p>} else {<!-- --></p> 
<p>handled = child.dispatchTouchEvent(event);</p> 
<p>}</p> 
<p>其最后就是分发给子View的dispatchTouch()方法，那么事件就分发到子View中去了</p> 
<p><strong>View事件分发源码分析</strong></p> 
<p>view对点击事件处理过程主要有：</p> 
<p>view的dispatchTouchEvent() 判断分发事件</p> 
<p>view的onTouchEvent:处理事件的具体做法</p> 
<p><strong>一、dispatchTouchEvent源码判断分发事件部分</strong></p> 
<p>public boolean dispatchTouchEvent(MotionEvent event) {<!-- --></p> 
<p>    boolean result = false;<br>     ......<br>     if (onFilterTouchEventForSecurity(event)) {<!-- --><br>         if ((mViewFlags &amp; ENABLED_MASK) == ENABLED &amp;&amp; handleScrollBarDragging(event)) {<!-- --><br>             result = true;<br>         }<br>         //noinspection SimplifiableIfStatement<br>         ListenerInfo li = mListenerInfo;<br>         //这里开始判断<br>         if (li != null &amp;&amp; li.mOnTouchListener != null<br>                 &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED<br>                 &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {<!-- --><br>             result = true;<br>         }<br>     <br>         if (!result &amp;&amp; onTouchEvent(event)) {<!-- --><br>             result = true;<br>         }<br>     }<br>     <br>     ......<br>     return result;<br> }<br> 从源码判断处看出，首先会判断有没有设置mOnTouchListener，如果mOnTouchListener不为空，那么onTouchEvent就不会被调用，这里可以得到一个结论，若在View中设置了OnTouchListener，那么它的优先级是高于onTouchEvent的，这样可以更好的让我们自己setOnTouchEventListener()处理点击事件</p> 
<p><br><strong>二、onTouchEvent源码处理事件的具体做法部分</strong></p> 
<p>public boolean onTouchEvent(MotionEvent event) {<!-- --><br>     ......<br>     //当View处于不可用状态下，也会消耗点击事件<br>     if ((viewFlags &amp; ENABLED_MASK) == DISABLED) {<!-- --><br>         if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) {<!-- --><br>             setPressed(false);<br>         }<br>         // A disabled view that is clickable still consumes the touch<br>         // events, it just doesn't respond to them.<br>         return (((viewFlags &amp; CLICKABLE) == CLICKABLE<br>                 || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)<br>                 || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);<br>     }</p> 
<p>    ......<br>     //对点击事件的具体处理<br>     if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||<br>             (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||<br>             (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {<!-- --><br>         switch (action) {<!-- --><br>             case MotionEvent.ACTION_UP:<br>                 boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;<br>                 if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) {<!-- --><br>                     ......<br>                     if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) {<!-- --><br>                         // This is a tap, so remove the longpress check<br>                         removeLongPressCallback();</p> 
<p>                        // Only perform take click actions if we were in the pressed state<br>                         if (!focusTaken) {<!-- --><br>                             // Use a Runnable and post this rather than calling<br>                             // performClick directly. This lets other visual state<br>                             // of the view update before click actions start.<br>                             if (mPerformClick == null) {<!-- --><br>                                 mPerformClick = new PerformClick();<br>                             }<br>                             if (!post(mPerformClick)) {<!-- --><br>                                 performClick();<br>                             }<br>                         }<br>                     }<br>                     ......<br>                 }<br>         }</p> 
<p>        return true;<br>     }<br>     ......<br> }<br> 从对点击事件的具体处理可以看出，只要View的CLICKABLE和LONG_CLICKABLE有一个为true，那么它就会消耗这个事件，即OnTouchEvent方法返回true。在Action_UP事件中，会触发PerformClick()方法，如果View设置了OnClickListener,那么PerformClick方法内部会调用它的OnClick()方法，这里就不分析它的点击事件了</p> 
<h3>View事件方法执行顺序</h3> 
<p>onTouchListener &gt; onTouchEvent &gt; onLongClickListener &gt; onClickListener</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/20f0ec485c9420b81b02d8542dd7d718/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">linux tc流量控制（一）：classless qdisc</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/88cb285ee0e5b88c55c3a4fc2ba58a70/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">A&#43;B Problem C语言</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>