<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【转载】C&#43;&#43; 宏定义 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【转载】C&#43;&#43; 宏定义" />
<meta property="og:description" content="一、#define的基本用法
#define是C语言中提供的宏定义命令，其主要目的是为程序员在编程时提供一定的方便，并能在一定程度上提高程序的运行效率，但学生在学习时往往不能 理解该命令的本质，总是在此处产生一些困惑，在编程时误用该命令，使得程序的运行与预期的目的不一致，或者在读别人写的程序时，把运行结果理解错误，这对 C语言的学习很不利。
1　#define命令剖析
1.1 #define的概念
#define命令是C语言中的一个宏定义命令，它用来将一个标识符定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本。 该命令有两种格式：一种是简单的宏定义，另一种是带参数的宏定义。
(1)简单的宏定义：
#define &lt;宏名&gt; &lt;字符串&gt; 例： #define PI 3.1415926 (2) 带参数的宏定义
#define &lt;宏名&gt;(&lt;参数列表&gt;) &lt;宏体&gt; 例： #define A(x) x 一个标识符被宏定义后，该标识符便是一个宏名。这时，在程序中出现的是宏名，在该程序被编译前，先将宏名用被定义的字符串替换，这称为宏替换，替换后才进行编译，宏替换是简单的替换。
1.2 宏替换发生的时机
为了能够真正理解#define的作用，让我们来了解一下对C语言源程序的处理过程。当我们在一个集成的开发环境如Turbo C中将编写好的源程序进行编译时，实际经过了预处理、编译、汇编和连接几个过程。其中预处理器产生编译器的输出，它实现以下的功能： （1）文件包含 可以把源程序中的#include 扩展为文件正文，即把包含的.h文件找到并展开到#include 所在处。 （2）条件编译 预处理器根据#if和#ifdef等编译命令及其后的条件，将源程序中的某部分包含进来或排除在外，通常把排除在外的语句转换成空行。 （3）宏展开 预处理器将源程序文件中出现的对宏的引用展开成相应的宏 定义，即本文所说的#define的功能，由预处理器来完成。 经过预处理器处理的源程序与之前的源程序有所有不同，在这个阶段所进行的工作只是纯粹的替换与展开，没有任何计算功能，所以在学习#define命令时只要能真正理解这一点，这样才不会对此命令引起误解并误用。
2　#define使用中的常见问题解析
2.1 简单宏定义使用中出现的问题
在简单宏定义的使用中，当替换文本所表示的字符串为一个表达式时，容易引起误解和误用。如下例：
#define N 2&#43;2 void main() { int a=N*N; printf(“%d”,a); } (1) 出现问题： 在此程序中存在着宏定义命令，宏N代表的字符串是2&#43;2，在程序中有对宏N的使用，一般同学在读该程序时，容易产生的问题是先求解N为2＋2＝4，然后在程序中计算a时使用乘法，即N*N=4*4=16,其实该题的结果为8，为什么结果有这么大的偏差? (2) 问题解析： 如1节所述，宏展开是在预处理阶段完成的，这个阶段把替换文本只是看作一个字符串，并不会有任何的计算发生，在展开时是在宏N出现的地方 只是简单地使用串2＋2来代替N，并不会增添任何的符号，所以对该程序展开后的结果是a=2&#43;2*2&#43;2，计算后=8，这就是宏替换的实质，如何写程序才能完成结果为16的运算呢？ (3)解决办法： 将宏定义写成如下形式
#define N (2&#43;2) 这样就可替换成(2&#43;2)*(2&#43;2)=16" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/04c178e6047c68b1f0cfead409062452/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-09-28T21:35:34+08:00" />
<meta property="article:modified_time" content="2016-09-28T21:35:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【转载】C&#43;&#43; 宏定义</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>一、#define的基本用法</p> 
<p>#define是C语言中提供的宏定义命令，其主要目的是为程序员在编程时提供一定的方便，并能在一定程度上提高程序的运行效率，但学生在学习时往往不能 理解该命令的本质，总是在此处产生一些困惑，在编程时误用该命令，使得程序的运行与预期的目的不一致，或者在读别人写的程序时，把运行结果理解错误，这对 C语言的学习很不利。</p> 
<p>1　#define命令剖析</p> 
<p>1.1 #define的概念</p> 
<p>#define命令是C语言中的一个宏定义命令，它用来将一个标识符定义为一个字符串，该标识符被称为宏名，被定义的字符串称为替换文本。 <br> 该命令有两种格式：一种是简单的宏定义，另一种是带参数的宏定义。</p> 
<p>(1)简单的宏定义：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> &lt;宏名&gt; &lt;字符串&gt;</span>
例： <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> PI 3.1415926</span></code></pre> 
<p>(2) 带参数的宏定义</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> &lt;宏名&gt;(&lt;参数列表&gt;) &lt;宏体&gt;</span>
例： <span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> A(x) x</span></code></pre> 
<p>一个标识符被宏定义后，该标识符便是一个宏名。这时，在程序中出现的是宏名，在该程序被编译前，先将宏名用被定义的字符串替换，这称为宏替换，替换后才进行编译，宏替换是简单的替换。</p> 
<p>1.2 宏替换发生的时机</p> 
<p>为了能够真正理解#define的作用，让我们来了解一下对C语言源程序的处理过程。当我们在一个集成的开发环境如Turbo C中将编写好的源程序进行编译时，实际经过了预处理、编译、汇编和连接几个过程。其中预处理器产生编译器的输出，它实现以下的功能： <br> （1）文件包含 <br> 可以把源程序中的#include 扩展为文件正文，即把包含的.h文件找到并展开到#include 所在处。 <br> （2）条件编译 <br> 预处理器根据#if和#ifdef等编译命令及其后的条件，将源程序中的某部分包含进来或排除在外，通常把排除在外的语句转换成空行。 <br> （3）宏展开 <br> 预处理器将源程序文件中出现的对宏的引用展开成相应的宏 定义，即本文所说的#define的功能，由预处理器来完成。 <br> 经过预处理器处理的源程序与之前的源程序有所有不同，在这个阶段所进行的工作只是纯粹的替换与展开，没有任何计算功能，所以在学习#define命令时只要能真正理解这一点，这样才不会对此命令引起误解并误用。</p> 
<p>2　#define使用中的常见问题解析</p> 
<p>2.1 简单宏定义使用中出现的问题</p> 
<p>在简单宏定义的使用中，当替换文本所表示的字符串为一个表达式时，容易引起误解和误用。如下例：</p> 
<pre class="prettyprint"><code class=" hljs perl"><span class="hljs-comment">#define N 2+2</span>
void main()
{
   <span class="hljs-keyword">int</span> a=N<span class="hljs-variable">*N</span>;
   <span class="hljs-keyword">printf</span>(“<span class="hljs-variable">%d</span>”,a);
}</code></pre> 
<p>(1) 出现问题： <br> 在此程序中存在着宏定义命令，宏N代表的字符串是2+2，在程序中有对宏N的使用，一般同学在读该程序时，容易产生的问题是先求解N为2＋2＝4，然后在程序中计算a时使用乘法，即N*N=4*4=16,其实该题的结果为8，为什么结果有这么大的偏差? <br> (2) 问题解析： <br> 如1节所述，宏展开是在预处理阶段完成的，这个阶段把替换文本只是看作一个字符串，并不会有任何的计算发生，在展开时是在宏N出现的地方 只是简单地使用串2＋2来代替N，并不会增添任何的符号，所以对该程序展开后的结果是a=2+2*2+2，计算后=8，这就是宏替换的实质，如何写程序才能完成结果为16的运算呢？ <br> (3)解决办法： <br> 将宏定义写成如下形式</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> N (2+2)</span></code></pre> 
<p>这样就可替换成(2+2)*(2+2)=16</p> 
<p>2.2 带参数的宏定义出现的问题</p> 
<p>在带参数的宏定义的使用中，极易引起误解。例如我们需要做个宏替换能求任何数的平方，这就需要使用参数，以便在程序中用实际参数来替换宏定义中的参数。一般学生容易写成如下形式：</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> area(x) x*x</span></code></pre> 
<p>这在使用中是很容易出现问题的，看如下的程序</p> 
<pre class="prettyprint"><code class=" hljs perl">void main()
{
    <span class="hljs-keyword">int</span> <span class="hljs-keyword">y</span> = area(<span class="hljs-number">2</span>+<span class="hljs-number">2</span>);
    <span class="hljs-keyword">printf</span>(“<span class="hljs-variable">%d</span>”,<span class="hljs-keyword">y</span>);
}</code></pre> 
<p>按理说给的参数是2+2，所得的结果应该为4*4=16，但是错了，因为该程序的实际结果为8，仍然是没能遵循纯粹的简单替换的规则，又是先计算再替换 了，在这道程序里，2+2即为area宏中的参数，应该由它来替换宏定义中的x，即替换成2+2*2+2=8了。那如果遵循(1)中的解决办法，把2+2 括起来，即把宏体中的x括起来，是否可以呢？#define area(x) (x)<em>(x)，对于area(2+2)，替换为(2+2)</em>(2+2)=16，可以解决，但是对于area(2+2)/area(2+2)又会怎么样呢，有的学生一看到这道题马上给出结果，因为分子分母一样，又错了，还是忘了遵循先替换再计算的规则了，这道题替换后会变为 (2+2)<em>(2+2)/(2+2)</em>(2+2)即4*4/4*4按照乘除运算规则，结果为16/4*4=4*4=16，那应该怎么呢？解决方法是在整个宏体上再加一个括号，即#define area(x) ((x)*(x))，不要觉得这没必要，没有它，是不行的。 <br> 要想能够真正使用好宏定义，那么在读别人的程序时，一定要记住先将程序中对宏的使用全部替换成它所代表的字符串，不要自作主张地添加任何其他符号，完全展开后再进行相应的计算，就不会写错运行结果。 <br> 如果是自己编程使用宏替换，则在使用简单宏定义时，当字符串中不只一个符号时，加上括号表现出优先级，如果是带参数的宏定义，则要给宏体中的每个参数加上括号，并在整个宏体上再加一个括号。看到这里，不禁要问，用宏定义这么麻烦，这么容易出错，可不可以摒弃它， 那让我们来看一下在C语言中用宏定义的好处吧。 <br> 如：</p> 
<pre class="prettyprint"><code class=" hljs cpp">include &lt;iostream.h&gt;
define product(x)    x*x
<span class="hljs-keyword">int</span> main()
{
    <span class="hljs-keyword">int</span> i=<span class="hljs-number">3</span>;
    <span class="hljs-keyword">int</span> j,k;
    j = product(i++);
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"j="</span>&lt;&lt;j&lt;&lt;endl;
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"i="</span>&lt;&lt;i&lt;&lt;endl;
    k = product(++i);
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"k="</span>&lt;&lt;k&lt;&lt;endl;
    <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"i="</span>&lt;&lt;i&lt;&lt;endl;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>依次输出结果： j=9;i=5;k=49;i=7 i = 5 而不等于 4 是因为将宏定义替换掉 j = i++ * i++ ; 这里i++运行了两次</p> 
<p>3 宏定义的优点</p> 
<p>(1) 方便程序的修改</p> 
<p>使用简单宏定义可用宏代替一个在程序中经常使用的常量，这样在将该常量改变时，不用对整个程序进行修改，只修改宏定义的字符串即可，而且当常量比较长时， 我们可以用较短的有意义的标识符来写程序，这样更方便一些。我们所说的常量改变不是在程序运行期间改变，而是在编程期间的修改，举一个大家比较熟悉的例子，圆周率π是在数学上常用的一个值，有时我们会用3.14来表示，有时也会用3.1415926等，这要看计算所需要的精度，如果我们编制的一个程序中 要多次使用它，那么需要确定一个数值，在本次运行中不改变，但也许后来发现程序所表现的精度有变化，需要改变它的值， 这就需要修改程序中所有的相关数值，这会给我们带来一定的不便，但如果使用宏定义，使用一个标识符来代替，则在修改时只修改宏定义即可，还可以减少输入 3.1415926这样长的数值多次的情况，我们可以如此定义 #define pi 3.1415926，既减少了输入又便于修改，何乐而不为呢？</p> 
<p>(2) 提高程序的运行效率</p> 
<p>使用带参数的宏定义可完成函数调用的功能，又能减少系统开销，提高运行效率。正如C语言中所讲，函数的使用可以使程序更加模块化，便于组织，而且可重复利用，但在发生函数调用时，需要保留调用函数的现场，以便子 函数执行结束后能返回继续执行，同样在子函数执行完后要恢复调用函数的现场，这都需要一定的时间，如果子函数执行的操作比较多，这种转换时间开销可以忽 略，但如果子函数完成的功能比较少，甚至于只完成一点操作，如一个乘法语句的操作，则这部分转换开销就相对较大了，但使用带参数的宏定义就不会出现这个问 题，因为它是在预处理阶段即进行了宏展开，在执行时不需要转换，即在当地执行。宏定义可完成简单的操作，但复杂的操作还是要由函数调用来完成，而且宏定义所占用的目标代码空间相对较大。所以在使用时要依据具体情况来决定是否使用宏定义。</p> 
<p>4 结语</p> 
<p>本文对C语言中宏定义#define在使用时容易出现的问题进行了解析，并从C源程序处理过程的角度对#define的处理进行了分析，也对它的优点进行 了阐述。只要能够理解宏展开的规则，掌握使用宏定义时，是在预处理阶段对源程序进行替换，只是用对应的字符串替换程序中出现的宏名，这样就可在正确使用的 基础上充分享受使用宏定义带来的方便和效率了</p> 
<p>二、define中的三个特殊符号：#，##，#@</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> Conn(x,y) x##y</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> ToChar(x) #@x</span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> ToString(x) #x</span></code></pre> 
<p>(1)x##y表示什么？表示x连接y，举例说： <br> int n = Conn(123,456); <br> 结果就是n=123456; <br> char* str = Conn(“asdf”, “adf”); <br> 结果就是 str = “asdfadf”; <br> （2）再来看#@x，其实就是给x加上单引号，结果返回是一个const char。举例说： <br> char a = ToChar(1);结果就是a=’1’; <br> 做个越界试验char a = ToChar(123);结果就错了; <br> 但是如果你的参数超过四个字符，编译器就给给你报错了！ <br> error C2015: too many characters in constant ：P <br> (3）最后看看#x,估计你也明白了，他是给x加双引号 <br> char* str = ToString(123132);就成了str=”123132”;</p> 
<p>三、常用的一些宏定义</p> 
<p>1 防止一个头文件被重复包含 </p> 
<pre class="prettyprint"><code class=" hljs vala"><span class="hljs-preprocessor">#ifndef BODYDEF_H </span>
<span class="hljs-preprocessor">#define BODYDEF_H</span>
 <span class="hljs-comment">//头文件内容 </span>
<span class="hljs-preprocessor">#endif</span></code></pre> 
<p>2 得到指定地址上的一个字节或字</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MEM_B( x ) ( *( (byte *) (x) ) ) </span>
<span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MEM_W( x ) ( *( (word *) (x) ) )</span></code></pre> 
<p>用法如下：</p> 
<pre class="prettyprint"><code class=" hljs delphi">#include &lt;iostream&gt;
#include &lt;windows.h&gt;

#define MEM_B(x) <span class="hljs-comment">(*((byte*)</span>(x)))
#define MEM_W(x) <span class="hljs-comment">(*((WORD*)</span>(x)))

int main()
<span class="hljs-comment">{
    int bTest = 0x123456;

    byte m = MEM_B((&amp;bTest));/*m=0x56*/
    int n = MEM_W((&amp;bTest));/*n=0x3456*/

    return 0;
}</span>
</code></pre> 
<p>3 得到一个field在结构体(struct)中的偏移量</p> 
<pre class="prettyprint"><code class=" hljs fsharp">#define OFFSETOF( <span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">field</span> ) (</span> (size_t) &amp;(( <span class="hljs-class"><span class="hljs-keyword">type</span> *) 0)-&gt; <span class="hljs-title">field</span> )</span></code></pre> 
<p>4 得到一个结构体中field所占用的字节数 </p> 
<pre class="prettyprint"><code class=" hljs fsharp">#define FSIZ( <span class="hljs-class"><span class="hljs-keyword">type</span>, <span class="hljs-title">field</span> ) <span class="hljs-title">sizeof</span>(</span> ((<span class="hljs-class"><span class="hljs-keyword">type</span> *) 0)-&gt;<span class="hljs-title">field</span> )</span></code></pre> 
<p>5 得到一个变量的地址（word宽度） </p> 
<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-variable">#define</span> B_PTR( <span class="hljs-built_in">var</span> ) ( (byte <span class="hljs-subst">*</span>) (<span class="hljs-literal">void</span> <span class="hljs-subst">*</span>) <span class="hljs-subst">&amp;</span>(<span class="hljs-built_in">var</span>) ) 
<span class="hljs-variable">#define</span> W_PTR( <span class="hljs-built_in">var</span> ) ( (word <span class="hljs-subst">*</span>) (<span class="hljs-literal">void</span> <span class="hljs-subst">*</span>) <span class="hljs-subst">&amp;</span>(<span class="hljs-built_in">var</span>) )</code></pre> 
<p>6 将一个字母转换为大写</p> 
<pre class="prettyprint"><code class=" hljs ruleslanguage"><span class="hljs-array">#define UPCASE</span>( c ) ( ((c) &gt;= <span class="hljs-string">''</span>a<span class="hljs-string">''</span> &amp;&amp; (c) &lt;= <span class="hljs-string">''</span>z<span class="hljs-string">''</span>) ? ((c) - <span class="hljs-number">0x20</span>) : (c) )</code></pre> 
<p>7 判断字符是不是10进值的数字</p> 
<pre class="prettyprint"><code class=" hljs ruleslanguage"><span class="hljs-array">#define DECCHK</span>( c ) ((c) &gt;= <span class="hljs-string">''</span><span class="hljs-number">0</span><span class="hljs-string">''</span> &amp;&amp; (c) &lt;= <span class="hljs-string">''</span><span class="hljs-number">9</span><span class="hljs-string">''</span>)</code></pre> 
<p>8 判断字符是不是16进值的数字 </p> 
<pre class="prettyprint"><code class=" hljs ruleslanguage"><span class="hljs-array">#define HEXCHK</span>( c ) ( ((c) &gt;= <span class="hljs-string">''</span><span class="hljs-number">0</span><span class="hljs-string">''</span> &amp;&amp; (c) &lt;= <span class="hljs-string">''</span><span class="hljs-number">9</span><span class="hljs-string">''</span>) ||((c) &gt;= <span class="hljs-string">''</span>A<span class="hljs-string">''</span> &amp;&amp; (c) &lt;= <span class="hljs-string">''</span>F<span class="hljs-string">''</span>) ||((c) &gt;= <span class="hljs-string">''</span>a<span class="hljs-string">''</span> &amp;&amp; (c) &lt;= <span class="hljs-string">''</span>f<span class="hljs-string">''</span>) )</code></pre> 
<p>9 防止溢出的一个方法</p> 
<pre class="prettyprint"><code class=" hljs fsharp">#define INC_SAT( <span class="hljs-keyword">val</span> ) (<span class="hljs-keyword">val</span> = ((<span class="hljs-keyword">val</span>)+<span class="hljs-number">1</span> &gt; (<span class="hljs-keyword">val</span>)) ? (<span class="hljs-keyword">val</span>)+<span class="hljs-number">1</span> : (<span class="hljs-keyword">val</span>))</code></pre> 
<p>10 返回数组元素的个数 </p> 
<pre class="prettyprint"><code class=" hljs autohotkey">#define ARR_SIZE( <span class="hljs-literal">a</span> ) ( sizeof( (<span class="hljs-literal">a</span>) ) / sizeof( (<span class="hljs-literal">a</span>[<span class="hljs-number">0</span>]) ) )</code></pre> 
<p>11 比较大小</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#<span class="hljs-keyword">define</span> MIN(a,b) ((a)&gt;(b)?(a):(b))</span></code></pre> 
<p>12 使用一些宏跟踪调试</p> 
<pre class="prettyprint"><code class=" hljs cs">ANSI标准说明了五个预定义的宏名。它们是： 
_LINE_ <span class="hljs-comment">/*(两个下划线)，对应%d*/</span>
_FILE_ <span class="hljs-comment">/*对应%s*/</span>
_DATE_ <span class="hljs-comment">/*对应%s*/</span>
_TIME_ <span class="hljs-comment">/*对应%s*/</span></code></pre> 
<p><a href="http://blog.chinaunix.net/uid-21372424-id-119797.html" rel="nofollow">原文出处</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/05094834446e7f4ba95003db84d65e9a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java 去除数组空元素</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bfee2f3c8fbebb70e194bfcc826e20fc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">如何创建只读权限oracle账户</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>