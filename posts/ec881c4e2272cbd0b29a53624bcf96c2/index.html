<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何在 Kubernetes Pod 中构建 Docker 镜像 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何在 Kubernetes Pod 中构建 Docker 镜像" />
<meta property="og:description" content="本指南重点介绍了使用 Kaniko 镜像生成器在 Kubernetes pod 中设置 Docker 映像构建的分步过程。
当涉及到CI / CD时，可能会有基于VM和容器的应用程序。理想情况下，应使用现有的 VM 基础结构来构建 Docker 映像。但是，如果您有容器化基础结构，最好将其用于 CI/CD 工作流。
在 Docker 中构建 Docker 在 CI 中，其中一个主要阶段是构建 Docker 镜像。在容器化构建中，您可以在 Docker 工作流中使用 Docker。
但这种方法有以下缺点。
Docker 生成容器在特权模式下运行。这是一个很大的安全问题，它为恶意攻击打开了一扇门。Kubernetes 从其核心中删除了 Docker。因此，除非您将 docker 添加到所有 Kubernetes 节点，否则将来无法装载到主机。docker.sock 这些问题可以使用 Kaniko 解决。
还有一个名为 podman 的实用程序，它可以在没有 root 权限的情况下运行和创建容器。
使用 Kaniko 在 Kubernetes 中构建 Docker 镜像 kaniko 是 Google 创建的开源容器镜像构建工具。
它不需要对主机进行特权访问即可生成容器映像。
Kaniko的工作原理，
有一个专用的 Kaniko 执行器镜像用于构建容器镜像。建议使用 gcr.io/kaniko-project/executor 镜像以避免任何可能的问题。因为此镜像仅包含静态 go 二进制文件和从注册表推送/拉取映像的逻辑。Kaniko 接受了三个参数。Dockerfile、生成上下文和远程 Docker 注册表。部署 kaniko 镜像时，它会读取 Dockerfile 并使用 FROM 指令提取基本镜像文件系统。然后，它执行 Dockerfile 中的每条指令，并在用户空间中拍摄快照。每次快照后，kaniko 仅将更改的镜像图层附加到基础镜像并更新镜像元数据。Dockerfile 中的所有指令都会发生这种情况。最后，它将镜像推送到给定的注册表。 如您所见，所有镜像构建操作都发生在 Kaniko 容器的用户空间内，并且不需要对主机进行任何特权访问。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ec881c4e2272cbd0b29a53624bcf96c2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-19T13:14:03+08:00" />
<meta property="article:modified_time" content="2023-12-19T13:14:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何在 Kubernetes Pod 中构建 Docker 镜像</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">本指南重点介绍了使用 Kaniko 镜像生成器在 <a href="https://devopscube.com/kubernetes-tutorials-beginners/" rel="nofollow" title="Kubernetes">Kubernetes</a> pod 中设置 <a href="https://devopscube.com/build-docker-image/" rel="nofollow" title="Docker 映像构建">Docker 映像构建</a>的分步过程。</span></span></p> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">当涉及到CI / CD时，可能会有基于VM和容器的应用程序。理想情况下，应使用现有的 VM 基础结构来构建 Docker 映像。但是，如果您有容器化基础结构，最好将其用于 CI/CD 工作流。</span></span></p> 
<h3 id="building-docker-in-docker" style="text-align:center;"><strong><span style="color:#231f20;"><span style="background-color:#ffffff;">在 Docker 中构建 Docker</span></span></strong></h3> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">在 CI 中，其中一个主要阶段是<strong>构建 Docker 镜像</strong>。在容器化构建中，您可以在 Docker 工作流中使用 Docker。</span></span></p> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">但这种方法有以下缺点。</span></span></p> 
<ol><li>Docker 生成容器在特权模式下运行。这是一个很大的安全问题，它为恶意攻击打开了一扇门。</li><li>Kubernetes 从其核心中删除<a href="https://devopscube.com/what-is-docker/" rel="nofollow" title="了 Docker">了 Docker</a>。因此，除非您将 docker 添加到所有 Kubernetes 节点，否则将来无法装载到主机。<code>docker.sock</code></li></ol> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">这些问题可以使用 Kaniko 解决。</span></span></p> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">还有一个名为 podman 的实用程序，它可以在没有 root 权限的情况下运行和创建容器。</span></span></p> 
<h3 id="build-docker-image-in-kubernetes-using-kaniko" style="text-align:center;"><strong><span style="color:#231f20;"><span style="background-color:#ffffff;">使用 Kaniko 在 Kubernetes 中构建 Docker 镜像</span></span></strong></h3> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;"><a href="https://github.com/GoogleContainerTools/kaniko" title="kaniko">kaniko</a> 是 Google 创建的开源容器镜像构建工具。</span></span></p> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">它不需要对主机进行特权访问即可生成容器映像。</span></span></p> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">Kaniko的工作原理，</span></span></p> 
<ol><li>有一个专用的 Kaniko 执行器镜像用于构建容器镜像。建议使用 gcr.io/kaniko-project/executor 镜像以避免任何可能的问题。因为此镜像仅包含静态 go 二进制文件和从注册表推送/拉取映像的逻辑。</li><li>Kaniko 接受了三个参数。Dockerfile、生成上下文和远程 Docker 注册表。</li><li>部署 kaniko 镜像时，它会读取 Dockerfile 并使用 FROM 指令提取基本镜像文件系统。</li><li>然后，它执行 Dockerfile 中的每条指令，并在用户空间中拍摄快照。</li><li>每次快照后，kaniko 仅将更改的镜像图层附加到基础镜像并更新镜像元数据。Dockerfile 中的所有指令都会发生这种情况。</li><li>最后，它将镜像推送到给定的注册表。</li></ol> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">如您所见，所有镜像构建操作都发生在 Kaniko 容器的用户空间内，并且不需要对主机进行任何特权访问。</span></span></p> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">Kaniko 支持以下类型的构建上下文。</span></span></p> 
<ol><li>GCS 桶</li><li>S3 存储桶</li><li>Azure Blob 存储</li><li>本地目录</li><li>本地 Tar</li><li>标准输入</li><li>Git 存储库</li></ol> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">对于这篇博客，我将使用 Github 存储库作为上下文。</span></span></p> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">此外，还可以推送到任何容器注册表。</span></span></p> 
<h3 id="building-docker-image-with-kaniko-github-docker-registry-kubernetes" style="text-align:center;"><strong><span style="color:#231f20;"><span style="background-color:#ffffff;">使用 Kaniko、Github、Docker 注册表和 Kubernetes 构建 Docker 镜像</span></span></strong></h3> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">为了演示 Kaniko 工作流，我将使用开源可用的工具，使用 Kaniko 在 Kubernetes 上构建 Docker 镜像。</span></span></p> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">这是你需要的</span></span></p> 
<ol><li>带有 Dockerfile 的<strong>有效 Github 存储库：</strong>kaniko 将使用存储库 URL 路径作为 Dockerfile 上下文</li><li><strong>有效的 docker hub 帐户</strong>：用于 kaniko pod 进行身份验证并推送构建的 Docker 映像。</li><li><strong>访问 Kubernetes 集群</strong>：部署 kaniko pod 并创建 docker 注册表密钥。</li></ol> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">下图显示了我们将要构建的工作流。</span></span></p> 
<p><a href="https://devopscube.com/wp-content/uploads/2021/07/image-37.png" rel="nofollow" title="​编辑">​编辑</a></p> 
<h4 id="create-dockerhub-kubernetes-secret" style="text-align:left;"><span style="color:#000000;"><span style="background-color:#ffffff;">创建 Dockerhub Kubernetes 密钥</span></span></h4> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">我们必须为 kaniko pod 创建一个类型的 <strong>kubernetes 密钥</strong>，以验证 Docker hub 注册表并推送镜像。<code>docker-registry</code></span></span></p> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">使用以下命令格式创建 docker 注册表密钥。替换以粗体标记的参数。</span></span></p> 
<pre class="has" style="text-align:left;"><code class="language-bash language-wp-block-code">kubectl create secret docker-registry dockercred \
    --docker-server=https://index.docker.io/v1/ \
    --docker-username=&lt;dockerhub-username&gt; \
    --docker-password=&lt;dockerhub-password&gt;\
    --docker-email=&lt;dockerhub-email&gt;</code></pre> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">此密钥<strong>被装载到 kaniko pod 中</strong>，以便它对 Docker 注册表进行身份验证以推送构建的镜像。</span></span></p> 
<blockquote> 
 <p><span style="color:#404953;"><strong>注意：</strong>如果您有自托管的 docker 注册表，则可以将服务器 URL 替换为 docker 注册表 API 端点。</span></p> 
</blockquote> 
<h4 id="deploy-kaniko-pod-to-build-docker-image" style="text-align:left;"><span style="color:#000000;"><span style="background-color:#ffffff;">部署 Kaniko Pod 构建 Docker 镜像</span></span></h4> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">现在，让我们使用 pod 部署来测试 kaniko 映像生成器。</span></span></p> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">我已将清单和 Dockerfile 托管在公共 GitHub 存储库中。这是一个带有说明的简单 Dockerfile。<code>update</code></span></span></p> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">我将使用该存储库进行演示。您可以 </span></span>fork <span style="color:#404953;"><span style="background-color:#ffffff;">或使用类似的配置创建自己的存储库。</span></span></p> 
<pre class="has" style="text-align:left;"><code class="language-bash language-wp-block-code">https://github.com/scriptcamp/kubernetes-kaniko</code></pre> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">将以下清单另存为 <code>pod.yaml</code></span></span></p> 
<pre class="has" style="text-align:left;"><code class="language-css language-wp-block-code">apiVersion: v1
kind: Pod
metadata:
  name: kaniko
spec:
  containers:
  - name: kaniko
    image: gcr.io/kaniko-project/executor:latest
    args:
    - "--context=git://github.com/scriptcamp/kubernetes-kaniko"
    - "--destination=&lt;dockerhub-username&gt;/kaniko-demo-image:1.0"
    volumeMounts:
    - name: kaniko-secret
      mountPath: /kaniko/.docker
  restartPolicy: Never
  volumes:
  - name: kaniko-secret
    secret:
      secretName: dockercred
      items:
        - key: .dockerconfigjson
          path: config.json</code></pre> 
<ol><li><strong>–context：</strong>这是 Dockerfile 的位置。在我们的例子中，Dockerfile 位于存储库的根目录中。所以我给出了存储库的 git URL。如果您使用的是私有 git 存储库，则可以使用 and（API 令牌）变量来验证 git 存储库。<code>GIT_USERNAME </code><code>GIT_PASSWORD</code></li><li><strong>–destination：</strong>在这里，您需要将 docker hub 用户名替换为 dockerhub 用户名，以便 kaniko 将映像推送到 dockerhub 注册表。例如，就我而言，<code>&lt;dockerhub-username&gt;</code><code>bibinwilson/kaniko-test-image:1.0</code></li></ol> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">所有其他配置保持不变。</span></span></p> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">现在部署 Pod。</span></span></p> 
<pre class="has" style="text-align:left;"><code class="language-bash language-wp-block-code">kubectl apply -f pod.yaml</code></pre> 
<p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">若要验证 docker 映像生成和推送，请检查 pod 日志。</span></span></p> 
<pre class="has" style="text-align:left;"><code class="language-bash language-wp-block-code">kubectl logs kaniko --follow</code></pre> 
<div style="text-align:left;"> 
 <p><span style="color:#000000;"><span style="background-color:#ffffff;"><a href="https://devopscube.com/wp-content/uploads/2021/07/image-36.png" rel="nofollow" title="​编辑">​编辑</a></span></span></p> 
 <blockquote> 
  <p><span style="color:#404953;"><strong>注意：</strong>这里我们使用了一个静态的 pod 名称。所以要再次部署;首先，您必须删除 Kaniko Pod。当您将 kaniko 用于 CI/CD 管道时，Pod 会根据您使用的 CI 工具获取一个随机名称，并负责删除 Pod。</span></p> 
 </blockquote> 
 <h3 id="docker-build-pipeline-using-jenkins-kaniko-on-kubernetes" style="text-align:center;"><strong><span style="color:#231f20;"><span style="background-color:#ffffff;">在 Kubernetes 上使用 Jenkins 和 kaniko 的 Docker 构建管道</span></span></strong></h3> 
 <p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">如果使用 <strong>Kubernetes 扩展 Jenkins 生成代理</strong>，则可以使用 Kaniko docker 生成 Pod 在 CI 管道中生成 docker 镜像。</span></span></p> 
 <p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">若要将 Kaniko 用于生成管道，应将 Dockerfile 与应用程序一起使用。</span></span></p> 
 <p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">此外，您应该将多容器 Pod 模板与 build 和 kaniko 容器一起使用。例如，用于 Java 构建的 maven 容器和 kaniko 容器使用存储库中存在的 Dockerfile 获取 jar 并构建 docker 映像。</span></span></p> 
 <p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">这是一个基于多容器 pod 模板的 Jenkinsfile，您可以在其中构建应用程序并使用 kaniko 容器与应用程序一起构建 docker 镜像并将其推送到 Docker 注册表。</span></span></p> 
 <blockquote> 
  <p><span style="color:#404953;"><strong>重要提示： </strong>您应该在 pod 模板中使用带有 debug 标签的 kaniko 映像，因为我们将使用 bash 显式运行 kaniko 执行器。最新的标记图像没有 bash。</span></p> 
 </blockquote> 
 <pre class="has" style="text-align:left;"><code class="language-css language-wp-block-code">podTemplate(yaml: '''
    apiVersion: v1
    kind: Pod
    spec:
      containers:
      - name: maven
        image: maven:3.8.1-jdk-8
        command:
        - sleep
        args:
        - 99d
      - name: kaniko
        image: gcr.io/kaniko-project/executor:debug
        command:
        - sleep
        args:
        - 9999999
        volumeMounts:
        - name: kaniko-secret
          mountPath: /kaniko/.docker
      restartPolicy: Never
      volumes:
      - name: kaniko-secret
        secret:
            secretName: dockercred
            items:
            - key: .dockerconfigjson
              path: config.json
''') {
  node(POD_LABEL) {
    stage('Get a Maven project') {
      git url: 'https://github.com/scriptcamp/kubernetes-kaniko.git', branch: 'main'
      container('maven') {
        stage('Build a Maven project') {
          sh '''
          echo pwd
          '''
        }
      }
    }

    stage('Build Java Image') {
      container('kaniko') {
        stage('Build a Go project') {
          sh '''
            /kaniko/executor --context `pwd` --destination bibinwilson/hello-kaniko:1.0
          '''
        }
      }
    }

  }
}</code></pre> 
 <p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">您可以直接在流水线作业上使用上述 Jenkinsfile 并对其进行测试。它只是一个入门模板。您需要将存储库替换为代码存储库，并根据应用程序的需要编写生成逻辑。</span></span></p> 
 <h3 id="conclusion" style="text-align:left;"><strong><span style="color:#231f20;"><span style="background-color:#ffffff;">结论</span></span></strong></h3> 
 <p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">使用 kaniko 构建 Docker 镜像是<a href="https://devopscube.com/docker-containers-as-build-slaves-jenkins/" rel="nofollow" title="容器化 Docker 构建">容器化 Docker 构建</a>的安全方法。</span></span></p> 
 <p style="text-align:left;"><span style="color:#404953;"><span style="background-color:#ffffff;">您可以尝试在不影响安全性的情况下将 kaniko 整合到您的 pipline 中。</span></span></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/102c50401e5b4bef6e2c2ccff2b7d17a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Qt/C&#43;&#43;开发经验小技巧291-295</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ba61ad06141467b234602cb3cc1c33b1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SCS【37】hdWGCNA在空间转录组学中的作用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>