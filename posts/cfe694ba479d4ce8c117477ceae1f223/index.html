<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;学习笔记-提高篇-STL-常用六大算法（遍历、查找、排序、拷贝和替换、算术生成、集合算法） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43;学习笔记-提高篇-STL-常用六大算法（遍历、查找、排序、拷贝和替换、算术生成、集合算法）" />
<meta property="og:description" content="目录
概述
一、常用遍历算法
（1）for_each
（2）transform 二、常用查找算法
（1）find
（2）find_if
（3）adjacent_find
（4）binary_search
（5）count
（6）count_if
三、常用排序算法
（1）sort
（2）random_shuffle
（3）reverse
（4）merge 四、常用拷贝和替换算法
（1）copy
（2）replace
（3）replace_if
（4）swap
五、常用算数生成算法
（1）accumulate
（2）fill
六、常用集合算法
（1）set_intersection （2）set_union （3）set_difference 概述 算法主要由头文件&lt;algorithm&gt;&lt;functional&gt;&lt;numeric&gt;组成&lt;algorithm&gt;是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等&lt;numeric&gt;体积很小，只包括几个在序列上面简单数学运算的函数模版&lt;functional&gt;定义了一下模版类，用以声明函数对象 一、常用遍历算法 1、学习目标：掌握常用的遍历算法
2、算法简介：
for_each //遍历容器transform //搬运容器到另一个容器 3、常用遍历算法
（1）for_each 功能描述：实现遍历容器函数原型： for_each(iterator beg, iterator end, _func);
//beg 开始迭代器
//end 结束迭代器
//_func 函数或者函数对象
示例： #include&lt;iostream&gt; #include&lt;algorithm&gt; #include&lt;vector&gt; using namespace std; //普通函数 void print01(int val) { cout &lt;&lt; val &lt;&lt; &#34; &#34;; } //仿函数 class print02 { public: void operator()(int val) { cout &lt;&lt; val &lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/cfe694ba479d4ce8c117477ceae1f223/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-04T16:11:29+08:00" />
<meta property="article:modified_time" content="2024-01-04T16:11:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;学习笔记-提高篇-STL-常用六大算法（遍历、查找、排序、拷贝和替换、算术生成、集合算法）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%E6%A6%82%E8%BF%B0" rel="nofollow">概述</a></p> 
<p id="%E4%B8%80%E3%80%81%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95" rel="nofollow">一、常用遍历算法</a></p> 
<p id="%EF%BC%881%EF%BC%89for_each-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89for_each" rel="nofollow">（1）for_each</a></p> 
<p id="%EF%BC%882%EF%BC%89transform%C2%A0-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89transform%C2%A0" rel="nofollow">（2）transform </a></p> 
<p id="%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95" rel="nofollow">二、常用查找算法</a></p> 
<p id="%EF%BC%881%EF%BC%89find-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89find" rel="nofollow">（1）find</a></p> 
<p id="%EF%BC%882%EF%BC%89find_if-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89find_if" rel="nofollow">（2）find_if</a></p> 
<p id="%EF%BC%883%EF%BC%89adjacent_find-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89adjacent_find" rel="nofollow">（3）adjacent_find</a></p> 
<p id="%EF%BC%884%EF%BC%89binary_search-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89binary_search" rel="nofollow">（4）binary_search</a></p> 
<p id="%EF%BC%885%EF%BC%89count-toc" style="margin-left:80px;"><a href="#%EF%BC%885%EF%BC%89count" rel="nofollow">（5）count</a></p> 
<p id="%EF%BC%886%EF%BC%89count_if-toc" style="margin-left:80px;"><a href="#%EF%BC%886%EF%BC%89count_if" rel="nofollow">（6）count_if</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95" rel="nofollow">三、常用排序算法</a></p> 
<p id="%EF%BC%881%EF%BC%89sort-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89sort" rel="nofollow">（1）sort</a></p> 
<p id="%C2%A0%EF%BC%882%EF%BC%89random_shuffle-toc" style="margin-left:80px;"><a href="#%C2%A0%EF%BC%882%EF%BC%89random_shuffle" rel="nofollow"> （2）random_shuffle</a></p> 
<p id="%EF%BC%883%EF%BC%89reverse-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89reverse" rel="nofollow">（3）reverse</a></p> 
<p id="%EF%BC%884%EF%BC%89merge%C2%A0-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89merge%C2%A0" rel="nofollow">（4）merge </a></p> 
<p id="%E5%9B%9B%E3%80%81%E5%B8%B8%E7%94%A8%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E5%B8%B8%E7%94%A8%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95" rel="nofollow">四、常用拷贝和替换算法</a></p> 
<p id="%EF%BC%881%EF%BC%89copy-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89copy" rel="nofollow">（1）copy</a></p> 
<p id="%EF%BC%882%EF%BC%89replace-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89replace" rel="nofollow">（2）replace</a></p> 
<p id="%EF%BC%883%EF%BC%89replace_if-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89replace_if" rel="nofollow">（3）replace_if</a></p> 
<p id="%EF%BC%884%EF%BC%89swap-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89swap" rel="nofollow">（4）swap</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%B8%B8%E7%94%A8%E7%AE%97%E6%95%B0%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E5%B8%B8%E7%94%A8%E7%AE%97%E6%95%B0%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95" rel="nofollow">五、常用算数生成算法</a></p> 
<p id="%EF%BC%881%EF%BC%89accumulate-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89accumulate" rel="nofollow">（1）accumulate</a></p> 
<p id="%EF%BC%882%EF%BC%89fill-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89fill" rel="nofollow">（2）fill</a></p> 
<p id="%E5%85%AD%E3%80%81%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95" rel="nofollow">六、常用集合算法</a></p> 
<p id="%EF%BC%881%EF%BC%89set_intersection%C2%A0-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89set_intersection%C2%A0" rel="nofollow">（1）set_intersection </a></p> 
<p id="%EF%BC%882%EF%BC%89set_union%C2%A0-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89set_union%C2%A0" rel="nofollow">（2）set_union </a></p> 
<p id="%EF%BC%883%EF%BC%89set_difference%C2%A0-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89set_difference%C2%A0" rel="nofollow">（3）set_difference </a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E6%A6%82%E8%BF%B0">概述</h2> 
<ul><li>算法主要由头文件&lt;algorithm&gt;&lt;functional&gt;&lt;numeric&gt;组成</li><li>&lt;algorithm&gt;是所有STL头文件中最大的一个，范围涉及到比较、交换、查找、遍历操作、复制、修改等</li><li>&lt;numeric&gt;体积很小，只包括几个在序列上面简单数学运算的函数模版</li><li>&lt;functional&gt;定义了一下模版类，用以声明函数对象</li></ul> 
<h2 id="%E4%B8%80%E3%80%81%E5%B8%B8%E7%94%A8%E9%81%8D%E5%8E%86%E7%AE%97%E6%B3%95">一、常用遍历算法</h2> 
<p>1、学习目标：掌握常用的遍历算法</p> 
<p>2、算法简介：</p> 
<ul><li>for_each   //遍历容器</li><li>transform  //搬运容器到另一个容器</li></ul> 
<p>3、常用遍历算法</p> 
<h4 id="%EF%BC%881%EF%BC%89for_each">（1）for_each</h4> 
<ul><li>功能描述：实现遍历容器</li><li>函数原型：</li></ul> 
<p>for_each(iterator beg, iterator end, _func);</p> 
<p>//beg 开始迭代器</p> 
<p>//end 结束迭代器</p> 
<p>//_func 函数或者函数对象</p> 
<ul><li>示例：</li></ul> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;

//普通函数
void print01(int val)
{
	cout &lt;&lt; val &lt;&lt; "  ";
}

//仿函数
class print02
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt;"  ";
	}
};

//常用遍历算法  for_each
void test01()
{
	vector&lt;int&gt;v;
	for (int i = 0; i &lt; 10; i++)
	{
		v.push_back(i);
	}

	for_each(v.begin(), v.end(), print01);
	cout &lt;&lt; endl;

	for_each(v.begin(), v.end(), print02());
	cout &lt;&lt; endl;
}

int main()
{
	test01();
	system("pause");
	return 0;
}</code></pre> 
<h4 id="%EF%BC%882%EF%BC%89transform%C2%A0">（2）transform </h4> 
<ul><li>功能描述：搬运容器到另一个容器中</li><li>函数原型：</li></ul> 
<p>transform(iterator beg1, iterator end1, iterator beg2, _func);</p> 
<p>//beg1 源容器开始迭代器</p> 
<p>//end1 源容器结束迭代器</p> 
<p>//beg2 目标容器开始迭代器</p> 
<p>//_func 函数或者函数对象   </p> 
<p><strong>可以在搬运的时候进行逻辑运算，也可以不进行逻辑运算（不进行逻辑运算时return v  就行）</strong></p> 
<ul><li>示例：</li></ul> 
<pre><code class="language-cs">#include&lt;iostream&gt;
#include&lt;algorithm&gt;
#include&lt;vector&gt;
using namespace std;

//常用的遍历算法  transform

class Transform
{
public:
	int operator()(int v)
	{
		return v + 100;
	}
};

class myPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; "  ";
	}
	
};
void test01()
{
	vector&lt;int&gt;v;
	for (int i = 0; i &lt; 10; i++)
	{
		v.push_back(i);
	}

	vector&lt;int&gt; vTarget;//目标容器
	vTarget.resize(v.size());
	transform(v.begin(), v.end(), vTarget.begin(), Transform());
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;
	for_each(vTarget.begin(), vTarget.end(), myPrint());
	cout &lt;&lt; endl;
}

int main()
{
	test01();
	system("pause");
	return 0;
}</code></pre> 
<p><span style="color:#fe2c24;"><strong>注意：目标容器需要提前开辟空间</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>vTargrt.resize(v.size());</strong></span></p> 
<h2 id="%E4%BA%8C%E3%80%81%E5%B8%B8%E7%94%A8%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95">二、常用查找算法</h2> 
<p>1.学习目标：掌握常用的查找算法</p> 
<p>2.算法介绍：</p> 
<ul><li>find                 //查找元素是否存在</li><li>find_if             //按条件查找元素</li><li>adjacent_find     //查找相邻重复元素</li><li>binary_search    //二分查找法</li><li>count                  //统计元素个数</li><li>count_if              //按条件统计元素个数</li></ul> 
<p>3.算法示例</p> 
<h4 id="%EF%BC%881%EF%BC%89find">（1）find</h4> 
<ul><li>功能描述：查找指定元素，找到<strong>返回</strong>指定元素的<strong>迭代器</strong>，找不到返回结束迭代器end()</li><li>函数原型：</li></ul> 
<p>find(iterator beg,iterator end,value)</p> 
<p>//beg开始迭代器</p> 
<p>//end结束迭代器</p> 
<p>//value查找的元素</p> 
<ul><li>示例：查找  内置数据类型  和  自定义数据类型</li></ul> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
#include&lt;algorithm&gt;
#include&lt;vector&gt;

//查找  内置数据类型
void test01()
{
	vector&lt;int&gt;v;
	for (int i = 0; i &lt; 10; i++)
	{
		v.push_back(i);
	}

	//查找容器中  是否有50 这个元素
	vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 50);
	if (it == v.end())
	{
		cout &lt;&lt; "没有找到" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "找到：" &lt;&lt; *it &lt;&lt; endl;;
	}
}

class Person
{
public:
	Person(string name, int age)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	}

	//重载  ==  底层find知道如何对比person数据类型
	bool operator==(const Person&amp; p)
	{
		if (this-&gt;m_Name == p.m_Name &amp;&amp; this -&gt;m_Age == p.m_Age)
		{
			return true;
		}
		else
		{
			return false;
		}
	}
	string m_Name;
	int m_Age;

};

//查找  自定义数据类型
void test02()
{
	vector&lt;Person&gt;v;
	//创建数据
	Person p1("aaa", 1);
	Person p2("bbb", 2);
	Person p3("ccc", 3);
	Person p4("aaa", 4);

	//放入容器中
	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);

	Person pp("bbb", 2);

	vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), pp);
	if (it == v.end())
	{
		cout &lt;&lt; "没有找到" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "找到：  姓名：" &lt;&lt; it-&gt;m_Name&lt;&lt;"   年龄"&lt;&lt;it-&gt;m_Age &lt;&lt; endl;;
	}
}

int main()
{
	test01();

	system("pause");
	return 0;
}</code></pre> 
<p>总结：利用find可以在容器中找指定元素，<strong>返回值是迭代器</strong></p> 
<h4 id="%EF%BC%882%EF%BC%89find_if">（2）find_if</h4> 
<ul><li>功能描述：按照条件查找元素</li><li>函数原型：</li></ul> 
<p>find_if(iterator beg, iterator end, _Pred);</p> 
<p>//beg开始迭代器</p> 
<p>//end结束迭代器</p> 
<p>//_Pred函数或者谓词（返回bool类型的仿函数）</p> 
<ul><li>示例：</li></ul> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
using namespace std;
#include&lt;vector&gt;
#include&lt;algorithm&gt;

//find_if查找 内置数据类型

class GreatFive
{
public:
	bool operator()(int val)
	{
		return val &gt; 5;
	}
};
void test01()
{
	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 10; i++)
	{
		v.push_back(i);
	}

	vector&lt;int&gt;::iterator it = find_if(v.begin(), v.end(), GreatFive());
	if (it == v.end())
	{
		cout &lt;&lt; "没有找到" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "找到大于五的数为：" &lt;&lt; *it &lt;&lt; endl;

	}
}

//find_if查找 自定义数据类型
class Person
{
public:
	Person(string name, int age)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	}
	string m_Name;
	int m_Age;
};

class Great20
{
public:
	bool operator()(Person &amp;p)
	{
		return p.m_Age &gt; 20;
	}
};
void test02()
{
	vector&lt;Person&gt; v;

	//创建数据
	Person p1("aaa", 10);
	Person p2("bbb", 20);
	Person p3("ccc", 30);
	Person p4("ddd", 40);

	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);

	//找年龄大于20的人
	vector&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Great20());
	if (it == v.end())
	{
		cout &lt;&lt; "没有找到" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "找到年龄大于20 ：    姓名：" &lt;&lt; it-&gt;m_Name &lt;&lt; "  年龄：" &lt;&lt; it-&gt;m_Age &lt;&lt; endl;;
	}
}

int main()
{
	//test01();
	test02();
	system("pause");
	return 0;

}</code></pre> 
<h4 id="%EF%BC%883%EF%BC%89adjacent_find">（3）adjacent_find</h4> 
<ul><li>功能描述：查找相邻元素，<strong>返回相邻元素的第一个位置的迭代器</strong></li><li>函数原型：</li></ul> 
<p>adjacent_find(iterator beg, iterator end);</p> 
<p>//beg开始迭代器</p> 
<p>//end结束迭代器</p> 
<ul><li>示例：</li></ul> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

void test01()
{
	vector&lt;int&gt; v;
	v.push_back(0);
	v.push_back(2);
	v.push_back(0);
	v.push_back(4);
	v.push_back(1);
	v.push_back(4);
	v.push_back(1);
	v.push_back(3);

	vector&lt;int&gt;::iterator pos = adjacent_find(v.begin(), v.end());

	if (pos == v.end())
	{
		cout &lt;&lt; "未找到相邻元素" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "找到相邻元素: "&lt;&lt;*pos &lt;&lt; endl;
	}
}


int main()
{
	test01();
	system("pause");
	return 0;
}</code></pre> 
<h4 id="%EF%BC%884%EF%BC%89binary_search">（4）binary_search</h4> 
<ul><li>功能描述：查找指定元素是否存在,<strong>返回bool值（查到返回true,否则false)</strong></li><li>函数原型：</li></ul> 
<p>bool binary_search(iterator beg, iterator end, value)</p> 
<p>//注意：在<span style="color:#fe2c24;"><strong>无序序列中不可用</strong></span></p> 
<p>//beg开始迭代器</p> 
<p>//end结束迭代器</p> 
<p>//value查找的元素</p> 
<ul><li>示例：</li></ul> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

void test01()
{
	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 10; i++)
	{
		v.push_back(i);
	}
	//查找容器中是否有9  元素
	//v.push_back(2);//如果加入2后变无序序列，结果未知
	//注意：容器必须是有序序列
    bool ret = binary_search(v.begin(), v.end(), 9);
	if (ret)
	{
		cout &lt;&lt; "找到元素" &lt;&lt; endl;
	}
	else
	{

		cout &lt;&lt; "未找到元素" &lt;&lt; endl;
	}

	

}

int main()
{
	test01();
	system("pause");
	return 0;
}</code></pre> 
<h4 id="%EF%BC%885%EF%BC%89count">（5）count</h4> 
<ul><li>功能描述：统计元素出现次数</li><li>函数原型：</li></ul> 
<p>count(iterator beg, iterator end, value)</p> 
<p>//beg开始迭代器</p> 
<p>//end结束迭代器</p> 
<p>//value统计的元素</p> 
<ul><li>示例：</li></ul> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
#include&lt;algorithm&gt;

//统计  内置数据类型
void test01()
{
	vector&lt;int&gt;v;
	v.push_back(10);
	v.push_back(40);
	v.push_back(30);
	v.push_back(40);
	v.push_back(20);
	v.push_back(40);

	int num = count(v.begin(), v.end(), 40);

	cout &lt;&lt; "40的元素个数为： " &lt;&lt; num &lt;&lt; endl;
}


//统计  自定义数据类型
class Person
{
public:
	Person(string name, int age)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	}

	bool operator==(const Person&amp; p)//重载了“==”
	{
		if (this-&gt;m_Age == p.m_Age)  //这里可以更改条件
		{
			return true;
	 	}
		else
		{
			return false;
		}
	}

	string m_Name;
	int m_Age;    
};



void test02()
{
	vector&lt;Person&gt; v;
	Person p1("a", 10);
	Person p2("b", 20);
	Person p3("c", 30);
	Person p4("d", 40);
	Person p5("d", 30);

	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);
	v.push_back(p5);

	Person p("e", 50);//查找和p相同30岁的人
	int num = count(v.begin(), v.end(), p);
	if (num)
	{
		cout &lt;&lt; "和e同岁的人有：" &lt;&lt; num &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "无和e同岁的人" &lt;&lt; endl;
	}


}

int main()
{
	//test01();
	test02();
	system("pause");
	return 0;
}</code></pre> 
<h4 id="%EF%BC%886%EF%BC%89count_if">（6）count_if</h4> 
<ul><li>功能描述：按照条件统计元素个数</li><li>函数原型：</li></ul> 
<p>coynt_if(iterator beg, iterator end, _Pred)</p> 
<p>//beg开始迭代器</p> 
<p>//end结束迭代器</p> 
<p>//_Pred谓词</p> 
<ul><li>示例：</li></ul> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
#include&lt;algorithm&gt;

//常用查找算法 count_if
//统计  内置数据类型
class Great30
{
public:
	bool operator()(int val)
	{
		return val &gt; 30;
	}
};

void test01()
{
	vector&lt;int&gt; v;
	v.push_back(10);	
	v.push_back(40);
	v.push_back(30);
	v.push_back(40);
	v.push_back(40);

	int num = count_if(v.begin(), v.end(), Great30());
	if (num)
	{
		cout &lt;&lt; "大于30的数有：" &lt;&lt; num &lt;&lt; "个" &lt;&lt; endl;
	}
	else
	{
		cout &lt;&lt; "无大于30的数" &lt;&lt; endl;
	}

}

//统计  自定义数据类型
class Person
{
public:
	Person(string name, int age)
	{
		this-&gt;m_Name = name;
		this-&gt;m_Age = age;
	}

	string m_Name;
	int m_Age;
};

class AgeGreat20
{
public:
	bool operator()(const Person &amp;p1)
	{
		return p1.m_Age &gt; 20;
	}
};

void test02()
{
	vector&lt;Person&gt;v;

	Person p1("aaa", 10);
	Person p2("bbb", 20);
	Person p3("ccc", 30);
	Person p4("ddd", 40);
	Person p5("eee", 30);

	v.push_back(p1);
	v.push_back(p2);
	v.push_back(p3);
	v.push_back(p4);
	v.push_back(p5);

	int num = count_if(v.begin(), v.end(), AgeGreat20());

	cout &lt;&lt; "大于20人员的个数为：" &lt;&lt; num &lt;&lt; endl;
}

int main()
{
	//test01();
	test02();
	system("pause");
	return 0;
}</code></pre> 
<h2 id="%E4%B8%89%E3%80%81%E5%B8%B8%E7%94%A8%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">三、常用排序算法</h2> 
<p>常用的排序算法</p> 
<ul><li>sort                          //对容器内元素进行排序</li><li>random_shuffle       //洗牌，指定范围内的元素随机调整次序</li><li>merge                     //容器元素合并，并存储到另一容器</li><li>reverse                   //反转指定范围的元素</li></ul> 
<h4 id="%EF%BC%881%EF%BC%89sort">（1）sort</h4> 
<ul><li>功能描述：对容器内元素进行排序</li><li>函数原型：</li></ul> 
<p>sort(iterator beg, iterator end, _Pred)</p> 
<p>//beg开始迭代器</p> 
<p>//end结束迭代器</p> 
<p>//_Pred谓词，默认从小到大，可以改变排序规则</p> 
<ul><li>示例：</li></ul> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

//常用排序算法 sort
void myPrint(int val)
{
	cout &lt;&lt; val &lt;&lt; "  ";
}

void test01()
{
	vector&lt;int&gt; v;
	v.push_back(10);
	v.push_back(30);
	v.push_back(20);
	v.push_back(50);
	v.push_back(40);

	//利用sort进行升序排序
	sort(v.begin(), v.end());
	for_each(v.begin(), v.end(),myPrint);
	cout &lt;&lt; endl;

	//改变  降序排序
	sort(v.begin(), v.end(), greater&lt;int&gt;());//greater&lt;int&gt;()是内置函数
	for_each(v.begin(), v.end(), myPrint);
	cout &lt;&lt; endl;
}


int main()
{
	test01();
	system("pause");
	return 0;
}</code></pre> 
<h4 id="%C2%A0%EF%BC%882%EF%BC%89random_shuffle"> （2）random_shuffle</h4> 
<ul><li>功能描述：洗牌，指定范围内的元素随机调整次序</li><li>函数原型：</li></ul> 
<p>random_shuffle（iterator beg, iterator end）</p> 
<p>//beg开始迭代器</p> 
<p>//end结束迭代器</p> 
<ul><li>示例：</li></ul> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;
#include&lt;ctime&gt;

void myPrint(int val)
{
	cout&lt;&lt;val&lt;&lt;" ";
}
void test01()
{
	srand((unsigned)time(NULL));//随机数种子
	vector&lt;int&gt; v;
	for (int i = 0; i &lt; 10; i++)
	{
		v.push_back(i);
	}

	//利用洗牌算法  打乱顺序
	random_shuffle(v.begin(), v.end());
	for_each( v.begin(), v.end(), myPrint);
	cout &lt;&lt; endl;
}

int main()
{
	test01();
	system("pause");
	return 0;
}
</code></pre> 
<p> 总结：记得加上随机数种子<span style="color:#fe2c24;"><strong>srand((unsigned)time(NULL))</strong></span>，才能模拟真实的随机</p> 
<h4 id="%EF%BC%883%EF%BC%89reverse">（3）reverse</h4> 
<ul><li>功能描述：将容器内元素进行反转</li><li>函数原型：</li></ul> 
<p>reverse(iterator beg, iterator end);</p> 
<p>//beg开始迭代器</p> 
<p>//end结束迭代器</p> 
<ul><li>示例：</li></ul> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

//常用排序算法 reverse

void myPrint(int val)
{
	cout &lt;&lt; val &lt;&lt; "  ";
}
void test01()
{
	vector&lt;int&gt;v;
	v.push_back(10);
	v.push_back(20);
	v.push_back(40);
	v.push_back(30);
	v.push_back(50);
	v.push_back(80);
	cout &lt;&lt; "反转前：" &lt;&lt; endl;
	for_each(v.begin(), v.end(), myPrint);
	cout &lt;&lt; endl;

	cout &lt;&lt; "反转后：" &lt;&lt; endl;
	reverse(v.begin(),v.end());
	for_each(v.begin(), v.end(), myPrint);
	cout &lt;&lt; endl;
}

int main()
{
	test01();
	system("pause");
	return 0;
}</code></pre> 
<h4 id="%EF%BC%884%EF%BC%89merge%C2%A0">（4）merge </h4> 
<ul><li>功能描述： 两个容器元素合并，并存储到另一容器中 两个容器元素必须是有序的，都是同样顺序的，不能一个升序一个降序，而且合并之后的新容器也是有序的</li><li>函数原型： <strong>merge (iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</strong></li><li>示例：</li></ul> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

void myPrint(int val)
{
	cout &lt;&lt; val &lt;&lt; "  ";
}

void test01()
{
	//first 和 second 数组中各存有 1 个有序序列
	int first[] = { 5,10,15,20,25 };
	int second[] = { 7,17,27,37,47,57 };
	//用于存储新的有序序列
	vector&lt;int&gt; myvector(11);
	//将 [first,first+5) 和 [second,second+6) 合并为 1 个有序序列，并存储到myvector容器中。
	merge(first, first + 5, second, second + 6, myvector.begin());
	//输出 myvector 容器中存储的元素
	for_each(myvector.begin(), myvector.end(), myPrint);
	cout &lt;&lt; endl;	
}

int main()
{
	test01();
	system("pause");
	return 0;
}</code></pre> 
<h2 id="%E5%9B%9B%E3%80%81%E5%B8%B8%E7%94%A8%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95">四、常用拷贝和替换算法</h2> 
<p>常用拷贝和替换算法</p> 
<ul><li>copy()             //容器内指定范围的元素拷贝到另一个容器中</li><li>replace()         //容器内指定范围的旧元素修改为新元素</li><li>replace_if()     //容器内指定范围满足条件的元素替换为新元素</li><li>swap()            //互换两个容器元素</li></ul> 
<h4 id="%EF%BC%881%EF%BC%89copy">（1）copy</h4> 
<ul><li>功能描述：容器内指定范围的元素拷贝到另一个容器中</li><li>函数原型：</li></ul> 
<p>copy（iterator beg, iterator end, iterator dest）</p> 
<p>//beg开始迭代器</p> 
<p>//end结束迭代器</p> 
<p>//dest目标起始迭代器</p> 
<ul><li>示例：</li></ul> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

//常用的拷贝和替换算法 copy
void myPrint(int val)
{
	cout &lt;&lt; val &lt;&lt; "  ";
}
void test01()
{
	vector&lt;int&gt; v1;
	for (int i = 0; i &lt; 10; i++)
	{
		v1.push_back(i);
	}

	vector&lt;int&gt; v2;
	v2.resize(v1.size());
	copy(v1.begin(), v1.end(), v2.begin());//等价于使用  v2=v1

	for_each(v2.begin(), v2.end(), myPrint);
	cout &lt;&lt; endl;
}

int main()
{
	test01();
	system("pause");
	return 0;
}</code></pre> 
<p>总结：在利用copy算法进行拷贝时，目标容器记得提前开辟空间 </p> 
<h4 id="%EF%BC%882%EF%BC%89replace">（2）replace</h4> 
<ul><li>功能描述：容器内指定范围的旧元素修改为新元素</li><li>函数原型：</li></ul> 
<p>replace（iterator beg, iterator end, oldvalue,newvalue）</p> 
<p>//beg开始迭代器</p> 
<p>//end结束迭代器</p> 
<p>//oldvalue旧元素</p> 
<p>//newvalue新元素</p> 
<ul><li>示例：</li></ul> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

//常用的拷贝和替换算法 replace

//仿函数
class myPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; "  ";
	}
};

void test01()
{
	vector&lt;int&gt; v;
	v.push_back(20);
	v.push_back(30);
	v.push_back(20);
	v.push_back(50);
	v.push_back(10);
	v.push_back(30); 
	v.push_back(100);
	v.push_back(30);
	
	cout &lt;&lt; "替换前：" &lt;&lt; endl;
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;
	cout &lt;&lt; "替换后：" &lt;&lt; endl;
	//将20替换为2000
	replace(v.begin(), v.end(), 20, 2000);
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;
}

int main()
{
	test01();
	system("pause");
	return 0;
}</code></pre> 
<p>总结：replace会替换区间内索引满足条件的元素</p> 
<h4 id="%EF%BC%883%EF%BC%89replace_if">（3）replace_if</h4> 
<ul><li>功能描述：容器内指定范围满足条件的元素替换为新元素</li><li>函数原型：</li></ul> 
<p>replace（iterator beg, iterator end, _Pred, newvalue）</p> 
<p>//beg开始迭代器</p> 
<p>//end结束迭代器</p> 
<p>//_Pred谓词</p> 
<p>//newvalue旧元素</p> 
<ul><li>示例：</li></ul> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

//常用的拷贝和替换算法 replace_if
class myPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; "  ";
	}
};

class great30 //仿函数
{
public:
	bool operator()(int val)
	{
		return val &gt;= 30;
	}
};

void test01()
{
	vector&lt;int&gt; v;
	v.push_back(20);
	v.push_back(30);
	v.push_back(50);
	v.push_back(50);
	v.push_back(30);
	v.push_back(10);
	v.push_back(10);
	v.push_back(60);
	v.push_back(10);
	v.push_back(30);

	cout &lt;&lt; "替换前：" &lt;&lt; endl;
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;
	//将大于等于30  替换为3000
	replace_if(v.begin(), v.end(), great30(), 3000);
	cout &lt;&lt; "替换后：" &lt;&lt; endl;
	for_each(v.begin(), v.end(), myPrint());
	cout &lt;&lt; endl;

}

int main()
{
	test01();
	system("pause");
	return 0;
}</code></pre> 
<h4 id="%EF%BC%884%EF%BC%89swap">（4）swap</h4> 
<ul><li>功能描述：互换两个容器元素</li><li>函数原型：</li></ul> 
<p>swap（container c1,container c2);</p> 
<p>//c1容器</p> 
<p>//c2容器</p> 
<ul><li>示例：</li></ul> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
using namespace std;

//常用拷贝和替换算法  swap
class myPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; "  ";
	}
};
void test01()
{
	vector&lt;int&gt; v1;
	vector&lt;int&gt; v2;
	for (int i = 0; i &lt; 10; i++)
	{
		v1.push_back(i);
		v2.push_back(100 + i);
	}
	cout &lt;&lt; "交换前：" &lt;&lt; endl;
	for_each(v1.begin(), v1.end(), myPrint());
	cout &lt;&lt; endl;
	for_each(v2.begin(), v2.end(), myPrint());
	cout &lt;&lt; endl;

	cout &lt;&lt; "----------------------------" &lt;&lt; endl;
	cout &lt;&lt; "交换后：" &lt;&lt; endl;
	swap(v1, v2);
	for_each(v1.begin(), v1.end(), myPrint());
	cout &lt;&lt; endl;
	for_each(v2.begin(), v2.end(), myPrint());
	cout &lt;&lt; endl;
	
}

int main()
{
	test01();
	system("pause");
	return 0;
}</code></pre> 
<p> 总结：swap交换容器时，注意交换的容器要同种类型</p> 
<h2 id="%E4%BA%94%E3%80%81%E5%B8%B8%E7%94%A8%E7%AE%97%E6%95%B0%E7%94%9F%E6%88%90%E7%AE%97%E6%B3%95">五、常用算数生成算法</h2> 
<p>常用的算数生成算法</p> 
<ul><li>accumulate            //计算容器元素累计总和</li><li>fill                           //向容器中添加元素</li></ul> 
<p>注意：算术生成算法属于小型算法，使用时包含头文件为<strong>#include&lt;numeric&gt;</strong></p> 
<h4 id="%EF%BC%881%EF%BC%89accumulate"><strong>（1）</strong><strong>accumulate</strong></h4> 
<ul><li>功能描述：计算区间内 容器元素累计和</li><li>函数原型：</li></ul> 
<p>accumulate（iterator beg, iterator end, value）</p> 
<p>//beg开始迭代器</p> 
<p>//end结束迭代器</p> 
<p>//起始的累加值</p> 
<ul><li>示例：</li></ul> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;numeric&gt;
using namespace std;

//常用算术生成算法

int main()
{
	vector&lt;int&gt;v;
	for (int i = 0; i &lt; 101; i++)
	{
		v.push_back(i);
	}

	int total = accumulate(v.begin(), v.end(), 0);//参数3是起始的累加值
	
	cout &lt;&lt; "total = " &lt;&lt; total &lt;&lt; endl;
	system("pause");
	return 0;
}</code></pre> 
<h4 id="%EF%BC%882%EF%BC%89fill"><strong>（2）fill</strong></h4> 
<ul><li>功能描述：向容器中填充指定的元素</li><li>函数原型：</li></ul> 
<p>fill（iterator beg, iterator end, value）</p> 
<p>//beg开始迭代器</p> 
<p>//end结束迭代器</p> 
<p>//起始的累加值</p> 
<ul><li>示例：</li></ul> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;numeric&gt;
#include&lt;algorithm&gt;
using namespace std;

void myPrint(int val)
{
	cout &lt;&lt; val &lt;&lt; "   ";
}

//常用算术生成算法  fill
void test01()
{
	vector&lt;int&gt; v;
	v.resize(10);

	//后期重新填充
	fill(v.begin(), v.end(), 100);
	for_each(v.begin(), v.end(), myPrint);
	cout &lt;&lt; endl;
}

int main()
{
	test01();
	system("pause");
	return 0;
}</code></pre> 
<h2 id="%E5%85%AD%E3%80%81%E5%B8%B8%E7%94%A8%E9%9B%86%E5%90%88%E7%AE%97%E6%B3%95">六、常用集合算法</h2> 
<p>常用的集合算法：</p> 
<ul><li>set_intersection          //求两个容器的交集</li><li>set_union                   //求两个容器的并集 </li><li>set_difference            //求两个容器的差集</li></ul> 
<h4 id="%EF%BC%881%EF%BC%89set_intersection%C2%A0">（1）set_intersection </h4> 
<p>功能描述：求两个容器的交集</p> 
<p>函数原型：</p> 
<p>set_intersection（iterator beg1, iterator end1,iterator beg2, iterator end2, iterator dest）</p> 
<p>//beg1容器1开始迭代器</p> 
<p>//end1容器1结束迭代器</p> 
<p>//beg2容器2开始迭代器</p> 
<p>//end2容器2结束迭代器</p> 
<p>//dest目标容器<strong>起始</strong>迭代器</p> 
<p><span style="color:#fe2c24;"><strong>注意：两个集合必须是有序序列</strong></span></p> 
<p>示例：</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;numeric&gt;
#include&lt;algorithm&gt;
using namespace std;

void myPrint(int val)
{
	cout &lt;&lt; val &lt;&lt; "  ";
}

void test01()
{
	vector&lt;int&gt; v1;
	vector&lt;int&gt; v2;
	for (int i = 0; i &lt; 10; i++)
	{
		v1.push_back(i);//0~9
		v2.push_back(i+5);//5~14
	}

	vector&lt;int&gt; vTarget;
	//目标容器需要提前开辟空间
	//最特殊的情况   大容器包含小容器
	//开辟空间  取小容器的size即可
	vTarget.resize(min(v1.size(), v2.size()));
	vector&lt;int&gt;::iterator itEnd = set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());
	for_each(vTarget.begin(), itEnd , myPrint);
	cout &lt;&lt; endl;

}

int main()
{
	test01();

	system("pause");
	return 0;
}</code></pre> 
<p>总结：</p> 
<ul><li>求交集的两个集合必须是有序序列</li><li>目标容器开辟空间需要从两个容器中取较小size </li><li>set_intersection返回值是交集中最后一个元素的位置</li></ul> 
<h4 id="%EF%BC%882%EF%BC%89set_union%C2%A0">（2）set_union </h4> 
<ul><li>功能描述：求两个容器的并集</li><li>函数原型：</li></ul> 
<p>set_union（iterator beg1, iterator end1,iterator beg2, iterator end2, iterator dest）</p> 
<p><span style="color:#fe2c24;"><strong>注意：两个集合必须是有序序列</strong></span></p> 
<p>//beg1容器1开始迭代器</p> 
<p>//end1容器1结束迭代器</p> 
<p>//beg2容器2开始迭代器</p> 
<p>//end2容器2结束迭代器</p> 
<p>//dest目标容器<strong>起始</strong>迭代器</p> 
<ul><li>示例：</li></ul> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;numeric&gt;
#include&lt;algorithm&gt;
using namespace std;

class myPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; "  ";
	}
};

//常用集合算法  set_union
void test01()
{
	vector&lt;int&gt; v1;
	vector&lt;int&gt; v2;
	for (int i = 0; i &lt; 10; i++)
	{
		v1.push_back(i);
		v2.push_back(i + 5);
	}
	vector&lt;int&gt;vTarget;
	//目标容器要提前开辟空间
	//最特殊的情况  两个容器没有交集，并集就是两个容器size相加
	vTarget.resize(v1.size() + v2.size());

	vector&lt;int&gt;::iterator itEnd = set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());
	for_each(vTarget.begin(), itEnd , myPrint());
	cout &lt;&lt; endl;
}


int main()
{
	test01();
	system("pause");
	return 0;
}</code></pre> 
<ul><li>求并集的两个集合必须是有序序列</li><li>目标容器开辟空间需要从两个容器相加</li><li>set_union返回值是并集中最后一个元素的位置</li></ul> 
<h4 id="%EF%BC%883%EF%BC%89set_difference%C2%A0">（3）set_difference </h4> 
<ul><li>功能描述：求两个集合的差集</li><li>函数原型：</li></ul> 
<p>set_difference（iterator beg1, iterator end1,iterator beg2, iterator end2, terator dest）</p> 
<p><span style="color:#fe2c24;"><strong>注意：两个集合必须是有序序列</strong></span></p> 
<p>//beg1容器1开始迭代器</p> 
<p>//end1容器1结束迭代器</p> 
<p>//beg2容器2开始迭代器</p> 
<p>//end2容器2结束迭代器</p> 
<p>//dest目标容器<strong>起始</strong>迭代器</p> 
<ul><li>示例：</li></ul> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;numeric&gt;
#include &lt;algorithm&gt;
using namespace std;

class myPrint
{
public:
	void operator()(int val)
	{
		cout &lt;&lt; val &lt;&lt; "  ";
	}
};

//常用集合算法  set_difference
void test01()
{
	vector&lt;int&gt;v1;
	vector&lt;int&gt;v2;
	for (int i = 0; i &lt; 10; i++)
	{
		v1.push_back(i);
		v2.push_back(i + 5);
	}

	//创建目标容器
	vector&lt;int&gt;vTarget;
	//给目标容器开辟空间
	//最特殊情况  两个容器没有交集，取两个容器中大的size作为目标容器开辟空间
	vTarget.resize(max(v1.size(), v2.size()));
	cout &lt;&lt; "v1与v2的差集为：" &lt;&lt; endl;

	vector&lt;int&gt;::iterator itEnd = set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());
	for_each(vTarget.begin(), itEnd, myPrint());
	cout &lt;&lt; endl;
	cout &lt;&lt; "———————————————————————————" &lt;&lt; endl;
	cout &lt;&lt; "v2与v1的差集为：" &lt;&lt; endl;
	vector&lt;int&gt;::iterator itEnd1 = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());
	for_each(vTarget.begin(), itEnd1, myPrint());
	cout &lt;&lt; endl;
}

int main()
{
	test01();
	system("pause");
	return 0;

}</code></pre> 
<ul><li>求差集的两个集合必须是有序序列</li><li>目标容器开辟空间需要从两个容器取较大</li><li>set_union返回值是差集中最后一个元素的位置</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a72a074588728e26a4334c2fa8e137ab/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">yolov8人脸识别-脸部关键点检测（代码&#43;原理）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7f008cc8eae2d7735f103c1642af5663/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">FFMPEG结构体分析：AVPacket</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>