<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>sqlite3学习之触发器（Trigger）的定义和使用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="sqlite3学习之触发器（Trigger）的定义和使用" />
<meta property="og:description" content="SQLite 触发器（Trigger）是数据库的回调函数，它会在指定的数据库事件发生时自动执行/调用，我们来看下关于 SQLite 的触发器（Trigger）的要点：
SQLite 的触发器（Trigger）可以指定在特定的数据库表发生 DELETE、INSERT 或 UPDATE 时触发，或在一个或多个指定表的列发生更新时触发。
SQLite 只支持 FOR EACH ROW 触发器（Trigger），没有 FOR EACH STATEMENT 触发器（Trigger）。因此，明确指定 FOR EACH ROW 是可选的。
WHEN 子句和触发器（Trigger）动作可能访问使用表单 NEW.column-name 和 OLD.column-name 的引用插入、删除或更新的行元素，其中 column-name 是从与触发器关联的表的列的名称。
如果提供 WHEN 子句，则只针对 WHEN 子句为真的指定行执行 SQL 语句。如果没有提供 WHEN 子句，则针对所有行执行 SQL 语句。
BEFORE 或 AFTER 关键字决定何时执行触发器动作，决定是在关联行的插入、修改或删除之前或者之后执行触发器动作。
当触发器相关联的表删除时，自动删除触发器（Trigger）。
要修改的表必须存在于同一数据库中，作为触发器被附加的表或视图，且必须只使用 tablename，而不是 database.tablename。
一个特殊的 SQL 函数 RAISE() 可用于触发器程序内抛出异常。
创建 触发器（Trigger） 的基本语法如下：
CREATE TRIGGER trigger_name [BEFORE|AFTER] event_name ON table_name BEGIN -- Trigger logic goes here." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9523dd103251d4b951035e79b582bd4a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-11T15:10:31+08:00" />
<meta property="article:modified_time" content="2019-01-11T15:10:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">sqlite3学习之触发器（Trigger）的定义和使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>SQLite <strong>触发器（Trigger）</strong>是数据库的回调函数，它会在指定的数据库事件发生时自动执行/调用，我们来看下关于 SQLite 的触发器（Trigger）的要点：</p> 
<ul><li> <p>SQLite 的触发器（Trigger）可以指定在特定的数据库表发生 DELETE、INSERT 或 UPDATE 时触发，或在一个或多个指定表的列发生更新时触发。</p> </li><li> <p>SQLite 只支持 FOR EACH ROW 触发器（Trigger），没有 FOR EACH STATEMENT 触发器（Trigger）。因此，明确指定 FOR EACH ROW 是可选的。</p> </li><li> <p>WHEN 子句和触发器（Trigger）动作可能访问使用表单 <strong>NEW.column-name</strong> 和 <strong>OLD.column-name</strong> 的引用插入、删除或更新的行元素，其中 column-name 是从与触发器关联的表的列的名称。</p> </li><li> <p>如果提供 WHEN 子句，则只针对 WHEN 子句为真的指定行执行 SQL 语句。如果没有提供 WHEN 子句，则针对所有行执行 SQL 语句。</p> </li><li> <p>BEFORE 或 AFTER 关键字决定何时执行触发器动作，决定是在关联行的插入、修改或删除之前或者之后执行触发器动作。</p> </li><li> <p>当触发器相关联的表删除时，自动删除触发器（Trigger）。</p> </li><li> <p>要修改的表必须存在于同一数据库中，作为触发器被附加的表或视图，且必须只使用 <strong>tablename</strong>，而不是 <strong>database.tablename</strong>。</p> </li><li> <p>一个特殊的 SQL 函数 RAISE() 可用于触发器程序内抛出异常。</p> </li></ul> 
<p>创建 <strong>触发器（Trigger）</strong> 的基本语法如下：</p> 
<pre>CREATE  TRIGGER trigger_name [BEFORE|AFTER] event_name 
ON table_name
BEGIN
 -- Trigger logic goes here....
END;</pre> 
<p>上述代码中，<strong>event_name</strong> 可以是在所提到的表 <strong>table_name</strong> 上的 <em>INSERT、DELETE 和 UPDATE</em> 数据库操作，我们可以在表名后选择指定 FOR EACH ROW 。</p> 
<p>我们来看下在 UPDATE 操作上在表的一个或多个指定列上创建触发器（Trigger）的语法：</p> 
<pre class="has"><code>CREATE  TRIGGER trigger_name [BEFORE|AFTER] UPDATE OF column_name 
ON table_name
BEGIN
 -- Trigger logic goes here....
END;</code></pre> 
<p>假设，我们要为被插入到新创建的 COMPANY 表（如果已经存在，则删除重新创建）中的每一个记录保持审计试验，表结构如下：</p> 
<pre class="has"><code>CREATE TABLE COMPANY(
   ID INT PRIMARY KEY     NOT NULL,
   NAME           TEXT    NOT NULL,
   AGE            INT     NOT NULL,
   ADDRESS        CHAR(50),
   SALARY         REAL
);</code></pre> 
<p>为了保持审计试验，我们将创建一个名为 AUDIT 的新表。每当 COMPANY 表中有一个新的记录项时，日志消息将被插入其中，AUDIT表结构如下：</p> 
<pre class="has"><code>CREATE TABLE AUDIT(
    EMP_ID INT NOT NULL,
    ENTRY_DATE TEXT NOT NULL
);</code></pre> 
<p>上述代码中，，ID 是 AUDIT 记录的 ID，EMP_ID 是来自 COMPANY 表的 ID，DATE 将保持 COMPANY 中记录被创建时的时间戳。所以，现在让我们在 COMPANY 表上创建一个触发器，如下：</p> 
<pre class="has"><code>CREATE TRIGGER audit_log AFTER INSERT 
ON COMPANY
BEGIN
   INSERT INTO AUDIT(EMP_ID, ENTRY_DATE) VALUES (new.ID, datetime('now'));
END;</code></pre> 
<p>现在，我们将开始在 COMPANY 表中插入记录，这将导致在 AUDIT 表中创建一个审计日志记录。因此，让我们在 COMPANY 表中创建一个记录，如下：</p> 
<pre class="has"><code>INSERT INTO COMPANY (ID,NAME,AGE,ADDRESS,SALARY) VALUES (1, 'Paul', 32, 'California', 20000.00 );</code></pre> 
<p>上述sql会在 COMPANY 表中创建一个记录，同时，将在 AUDIT 表中创建一个记录。这个纪录是触发器的结果，这是我们在 COMPANY 表上的 INSERT 操作上创建的触发器（Trigger）。类似的，可以根据需要在 UPDATE 和 DELETE 操作上创建触发器（Trigger）。</p> 
<p>我们可以从 <strong>sqlite_master</strong> 表中列出所有触发器，如下：</p> 
<pre class="has"><code>SELECT name FROM sqlite_master WHERE type = 'trigger';</code></pre> 
<p>如果我们想要列出特定表上的触发器，则使用 AND 子句连接表名，如下：</p> 
<pre class="has"><code>SELECT name FROM sqlite_master WHERE type = 'trigger' AND tbl_name = 'COMPANY';</code></pre> 
<p>我们可以使用 DROP 命令来删除已有的触发器，如下：</p> 
<pre class="has"><code>DROP TRIGGER trigger_name;</code></pre> 
<p>for each row 是操作语句每影响到一行的时候就触发一次，也就是删了 10 行就触发 10 次，而 for each state 一条操作语句就触发一次，有时没有被影响的行也执行，sqlite 只实现了 for each row 的触发，when 和 for each row 用法如下：</p> 
<pre class="has"><code>CREATE TRIGGER trigger_name 
AFTER UPDATE OF id ON table_1 
FOR EACH ROW 
WHEN new.id&gt;30 
BEGIN 
UPDATE table_2 SET id=new.id WHERE table_2.id=old.id;
END;</code></pre> 
<p>上述代码定义的触发器在 table_1 改 id 的时候如果新的 id&gt;30 就把 表table_2 中和表table_1 id 相等的行一起改为新的 id。</p> 
<p>好啦，本次记录就到这里了。</p> 
<p>如果感觉不错的话，请多多点赞支持哦。。。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1a712db1f78eb0ecae4dad3ebf70731b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">dataTables--保留相关操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4d9ab1519953807aa4dfad53430451bc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">sqlite3学习之索引（Index）的使用&amp;Indexed By子句&amp;Alter 命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>