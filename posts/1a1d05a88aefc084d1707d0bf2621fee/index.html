<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>箭头函数与普通函数 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="箭头函数与普通函数" />
<meta property="og:description" content="一，js中的this指向 1.方法是谁调用的,那么在方法中this就指向谁(.前面是谁, this就是谁)
2.如果没有调用 this始终指向window
3.构造函数中的this, 指向实例本身
4.强制改变this call apply bind
//call和apply和bind都是改变this指向的方法
//语法
//call(新的this指向, pram1, pram2 ...) //apply(新的this指向, [pram1, pram2 ...])
//bind方法 返回一个改变this指向之后的新的方法,需要手动调用
{//1.方法是谁调用的,那么在方法中this就指向谁(.前面是谁, this就是谁) let obj = { name: &#34;obj&#34;, fn: function () { console.log(this);//obj } }; obj.fn(); } {//2.如果没有调用 this始终指向window function fn() { console.log(this);//window } fn(); } {//3.构造函数中的this, 指向实例本身 function Fn(name){ this.name = name; this.age = 18; console.log(&#34;Fn中的this==&gt;&#34;,this); //new Fn() } Fn.prototype.sayName = function(){ console.log(this.name); //new Fn() console." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1a1d05a88aefc084d1707d0bf2621fee/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-30T14:21:15+08:00" />
<meta property="article:modified_time" content="2021-09-30T14:21:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">箭头函数与普通函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一，js中的this指向</h2> 
<p>1.方法是谁调用的,那么在方法中this就指向谁(.前面是谁, this就是谁)</p> 
<p>2.如果没有调用 this始终指向window</p> 
<p>3.构造函数中的this, 指向实例本身</p> 
<p>4.强制改变this   call apply bind<br>     //call和apply和bind都是改变this指向的方法<br>     //语法<br>     //call(新的this指向, pram1, pram2 ...) <br>     //apply(新的this指向, [pram1, pram2 ...])<br>     //bind方法 返回一个改变this指向之后的新的方法,需要手动调用</p> 
<pre><code class="language-javascript">{//1.方法是谁调用的,那么在方法中this就指向谁(.前面是谁, this就是谁)
    let obj = {
        name: "obj",
        fn: function () {
            console.log(this);//obj
        }
    };
    obj.fn();
}
{//2.如果没有调用 this始终指向window
    function fn() {
        console.log(this);//window
    }
    fn();
}
{//3.构造函数中的this, 指向实例本身
    function Fn(name){
        this.name = name;
        this.age = 18;
        console.log("Fn中的this==&gt;",this); //new Fn()
    }
    Fn.prototype.sayName = function(){
        console.log(this.name); //new Fn()
        console.log("sayName中的this==&gt;",this)
    }
    let fn = new Fn("哈哈");
    fn.sayName()
    console.log(fn);
}
{//4.强制改变this   call apply bind
    //call和apply和bind都是改变this指向的方法
    //语法
    //call(新的this指向, pram1, pram2 ...) 
    //apply(新的this指向, [pram1, pram2 ...])
    //bind方法 返回一个改变this指向之后的新的方法,需要手动调用
    let obj = {
        name: "obj",
        birth: 1990,
        year: 2021,
        age: function(arg1, arg2){
            // console.log(this);//obj2
            console.log(arg1, arg2);//obj2
            // console.log("my age =", this.year - this.birth)
        }
    }
    // obj.age("参数1","参数2");
    let obj2 = {
        name: "obj2",
        birth: 2000,
        year: 2020,
    };
    // obj.age.call()  //不传参值为undefined
    // obj.age.call(obj2,"参数1","参数2")
    // obj.age.apply(obj2,["参数1","参数2"])// Create List From Array Like called on non-object
    //bind
    let changeThisAge = obj.age.bind(obj2);
    changeThisAge("参数1","参数2")
}</code></pre> 
<h2>二，箭头函数中的this指向</h2> 
<p>1.箭头函数是匿名函数 箭头函数不能作为构造函数使用 不能使用new</p> 
<p>2.箭头函数的this,始终指向父级上下文</p> 
<p>3.箭头函数不能通过call apply bind改变this指向,但是可以通过这些方法传递参数</p> 
<p>4.箭头函数没有原型属性</p> 
<p>5.箭头函数没有arguments属性,可以用...展开运算符来接受所有的参数集合</p> 
<pre><code class="language-javascript">//1.箭头函数是匿名函数 箭头函数不能作为构造函数使用 不能使用new
{
    /*function Fn(name){
        this.name = name;
        this.age = 18;
        console.log("Fn中的this==&gt;",this); //new Fn()
    }
    let fn = new Fn("哈哈");*/
    /*let Fn = ()=&gt;{
        this.name = name;
        this.age = 18;
    }
    let fn = new Fn(); //Fn is not a constructor*/
}
//2.箭头函数的this,始终指向父级上下文
{
    let obj = {
        a: 100,
        fn: function(){
            console.log(this);//obj
        },
        fn2: ()=&gt;{
            console.log("fn2====&gt;",this);//window
        }
    };
    obj.fn();
    obj.fn2();
}
//3.箭头函数不能通过call apply bind改变this指向,但是可以通过这些方法传递参数
{
    let obj = {
        name: "obj",
        birth: 1990,
        year: 2021,
        age: (arg1, arg2)=&gt;{
            console.log(this);//window
            console.log(arg1, arg2);//obj2
            console.log("my age =", this.year - this.birth)
        }
    }
    let obj2 = {
        name: "obj2",
        birth: 2000,
        year: 2020,
    };
    obj.age.call(obj2,"参数1","参数2")
}
//4.箭头函数没有原型属性
{
    // function fn(){}
    let fn = ()=&gt;{};
    console.dir(fn);
}
//5.箭头函数没有arguments属性,可以用...展开运算符来接受所有的参数集合
{
   /* function fn(){
        console.log(arguments);
        // fn.caller 谁在调用当前的方法 会返回这个方法本身
        // arguments.callee ===&gt; 当前这个方法本身;
        // arguments 参数集合 是一个类数组 不能调用数组的方法
    }
    fn(1,2,3)*/
    let fn = (...args)=&gt;{ //使用展开运算符接受参数集合
        // console.log(arguments);// arguments is not defined
        console.log(args); //是一个数组
    }
    fn(1,2,3)
}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b4f11c3ca9ce4e3453a5b63a85635ad8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">href 与 src 的区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a5d7681dcd6d3175465f4532d93cdc8d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">首届长三角青少年人工智能擂台赛全记录（YOLOv5&#43;Win10&#43;Anaconda&#43;Pycharm&#43;ModelArts）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>