<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浅谈服务治理与微服务 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浅谈服务治理与微服务" />
<meta property="og:description" content="近期都在谈微服务，本人也正在做相关的工作，应领导要求做了一个微服务的分享，本篇文章主要来源于分享的PPT，所以有些简单，有问题可以在下面留言，大家 一起讨论。
本篇文章先简单介绍了互联网架构的演变，进而介绍了服务化，最后再介绍微服务，微服务是服务治理的升级也是互联网架构的进一步延伸。
互联网架构演变 一体架构 在计算机软件发展早期，一般桌面软件都是采用这种架构，不管是界面还是业务处理还是数据处理都放到一个包中。这种其实谈不上架构，但也可以说是很好的架构，因为它足够简单。
mvc架构 但随着浏览器的出现便产生了web应用，web应用的特点是界面部分是显示在浏览器中，服务处理是在服务容器中的，页面显示一般用css&#43;js&#43;html技术来处理，而后端可以用java、php等语言，这就产生了前后端分离。对于web系统，一体架构难以满足前后端分离的开发需求，因而便产生了MVC架构。
MVC才算的上真正意义上的架构，因为它除了解决了前后端分离问题，还引入了一种全新的开发模式，用一种业务逻辑、数据、界面显示分离的方法组织代码，使得整个应用层次更加分明，而且各个层次之间不但减低了耦合性，还提高了各个层次的可重用性。
但随着应用规模的不断扩大，应用模块不断增加，整个应用也显得越来越臃肿，维护起来也更加困难，因此便又产生了多应用架构。
多应用架构 多应用架构很简单，就是把原来的应用按照业务特点拆分成多个应用。比如一个大型电商系统可能包含用户系统、商品系统、订单系统、评价系统等等，我们可以把他们独立出来形成一个个单独的应用。多应用架构的特点是应用之间各自独立 ，不相互调用。
多应用虽然解决了应用臃肿问题，但应用之间相互独立，有些共同的业务或代码无法复用。
分布式架构 对于一个大型的互联网系统，一般会包含多个应用，而且应用之间往往还存在共同的业务，并且应用之间还存在调用关系。除此之外 ，对于大型的互联网系统还有一些其它的挑战，比如如何应对急剧增长的用户，如何管理好研发团队快速迭代产品研发，如何保持产品升级更加稳定等等 。
因此，为了使业务得到很好的复用，模块更加容易拓展和维护，我们希望业务与应用分离，某个业务不再属于一个应用，而是作为一个独立的服务单独进行维护。应用本身不再是一个臃肿的模块堆积，而是由一个个模块化的服务组件组合而成。
服务化 服务化的特点 上面介绍的分布式架构即服务化。我们再总结一下，服务化主要有如下特点：
应用按业务拆分成服务各个服务均可独立部署服务可被多个应用共享服务之间可以通信 服务化的好处 那么企业采用服务化有哪些好处呢？
架构上系统更加清晰核心模块稳定，以服务组件为单位进行升级，避免了频繁发布带来的风险开发管理方便单独团队维护、工作分明，职责清晰业务复用、代码复用非常容易拓展 服务化实现方式 如果要实现服务化的话，最常用的方式就是利用RPC框架。因为服务组件一般分布在不同的服务器上，所以要实现服务化需要解决的第一个问题就是RPC**远程服务调用**。类似于RPC方案有很多，比如：
Java RMIWebServiceHessianHttpThrift… … 服务化面临的挑战 上面提到要实现服务化首先需要解决远程服务调用问题，除此之外，还有很多其他问题需要解决。
服务越来越多，配置管理复杂服务间依赖关系复杂服务之间的负载均衡服务的拓展服务监控服务降级服务鉴权服务上线与下线服务文档… … 服务治理 上面提到了服务化，其实要想服务化，服务治理是关键。那么有没有好的服务治理方案呢？答案是有的，而且很多人都在用这个框架，他就是-dubbo。dubbo就是一个带有服务治理功能的RPC框架。
dubbo提供了一套较为完整的服务治理方案，所以企业如果要实现服务化的话，dubbo 是很好的一个选择。这里简单介绍一下dubbo服务治理相关方案。
服务发现注册 服务治理领域最重要的问题就是服务发现与注册。dubbo中引入了一个注册中心的概念，服务的注册与发现主要就依赖这个服务中心。
dubbo注册中心服务注册发现的具体过程：
服务提供者启动，向注册中心注册自己提供的服务消费者启动，向注册中心订阅自己需要的服务注册中心返回服务提供者的列表给消费者消费者从服务提供者列表中，按照软负载均衡算法，选择一台发起请求 服务监控 集群容错 负载均衡 Random LoadbalanceRoundRobin LeastActive ConsistentHash dubbo服务治理优势 注册中心只负责注册查找，不负责请求转发，压力小注册中心宕机影响消费者，消费者本地缓存服务地址列表注册中心对等集群，宕掉一台自动切换到另外 一台服务提供者无状态，可动态部署，注册中心负责推送统计无压力，本地内存中累计次数，每分钟发送注册中心消费者调用服务者，自动软负载均衡通过服务中心可追踪依赖关系监控中心为扩容和降级提供依据可启用acl机制进行鉴权与Spring整合，接入简单松耦合多种序列化协议支持 dubbo的不足 消费者仍需要依赖配置中心消费者仍需要依赖jar包配置provider提供者文档管理功能缺失无统一入口不支持OAuth2.0内部鉴权不方便管理无外部应用鉴权接口基本裸奔，无法直接对外暴露服务IT治理不方便 微服务 现在很多人都在谈微服务，那么到底什么是微服务呢？这里谈谈我对微服务的理解。
微服务有两个核心：
微：服务的粒度要细，即服务要细化到API服务：提供好服务，要让用户感到好用(要做到这一点很不容易) 上面两个核心总结起来，可以用下面这幅图表示：
从上面这幅图看出，微服务特别简单（好的架构就应该简单），我们把服务再拆分成一个个API，API是一个完整的功能。然后我们把API扔到一个“云上”，然后用户就可以到“云上”获取所有API的服务，这个“云”保证能提供好的服务。
我们可以看到，有了微服务之后，服务对用户来说变得特别简单，而且上面dubbo的不足之处在微服务这里都解决了。使用者不再需要依赖任何jar包，不再需要去注册中心查找服务，不再去做鉴权处理，不用担心服务挂掉，不用担心不会使用服务，所有的问题这个“云”都解决了。这也是微服务的核心之一，提供好服务。
说到这里，大家就应该大体知道该怎么做微服务了，图中的“云”是关键。下面我们就慢慢拨开这朵云。
微服务的实现 微服务的关键是服务网关，所以，上面提到的“云”就是服务网关。要做微服务，我们先定义一下微服务需要具备的特点。
微服务的特点 服务需要再细化成API（服务接口——&gt;服务API）
每个服务由一组API组成以API形式对外提供统一格式的服务使用者无需任何配置，直接调用（http）完整的API文档API服务安全可靠稳定 微服务要解决的问题 上面提到了，dubbo还存在一些问题 ，其实dubbo存在的问题 就是 微服务要解决的问题，这里 再总结一下。当然，dubbo和微服务的侧重点不一样，dubbo侧重于内部接口之间的RPC，而微服务则侧重于对外提供服务。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/50db37f80300d9143b3f8bd02cb90339/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-01-03T15:29:28+08:00" />
<meta property="article:modified_time" content="2017-01-03T15:29:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浅谈服务治理与微服务</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>近期都在谈微服务，本人也正在做相关的工作，应领导要求做了一个微服务的分享，本篇文章主要来源于分享的PPT，所以有些简单，有问题可以在下面留言，大家 一起讨论。</p> 
<p>本篇文章先简单介绍了互联网架构的演变，进而介绍了服务化，最后再介绍微服务，微服务是服务治理的升级也是互联网架构的进一步延伸。</p> 
<h3 id="互联网架构演变">互联网架构演变</h3> 
<h4 id="一体架构">一体架构</h4> 
<p>在计算机软件发展早期，一般桌面软件都是采用这种架构，不管是界面还是业务处理还是数据处理都放到一个包中。这种其实谈不上架构，但也可以说是很好的架构，因为它足够简单。</p> 
<p><img src="https://images2.imgbox.com/ce/1f/i1J2dr2s_o.png" alt="这里写图片描述" title=""></p> 
<h4 id="mvc架构">mvc架构</h4> 
<p>但随着浏览器的出现便产生了web应用，web应用的特点是界面部分是显示在浏览器中，服务处理是在服务容器中的，页面显示一般用css+js+html技术来处理，而后端可以用java、php等语言，这就产生了前后端分离。对于web系统，一体架构难以满足前后端分离的开发需求，因而便产生了MVC架构。</p> 
<p><img src="https://images2.imgbox.com/12/8e/kZwKwLXt_o.png" alt="这里写图片描述" title=""></p> 
<p>MVC才算的上真正意义上的架构，因为它除了解决了前后端分离问题，还引入了一种全新的开发模式，用一种业务逻辑、数据、界面显示分离的方法组织代码，使得整个应用层次更加分明，而且各个层次之间不但减低了耦合性，还提高了各个层次的可重用性。</p> 
<p>但随着应用规模的不断扩大，应用模块不断增加，整个应用也显得越来越臃肿，维护起来也更加困难，因此便又产生了多应用架构。</p> 
<h4 id="多应用架构">多应用架构</h4> 
<p>多应用架构很简单，就是把原来的应用按照业务特点拆分成多个应用。比如一个大型电商系统可能包含用户系统、商品系统、订单系统、评价系统等等，我们可以把他们独立出来形成一个个单独的应用。多应用架构的特点是应用之间各自独立 ，不相互调用。</p> 
<p><img src="https://images2.imgbox.com/98/75/Ayo4YcNP_o.png" alt="这里写图片描述" title=""></p> 
<p>多应用虽然解决了应用臃肿问题，但应用之间相互独立，有些共同的业务或代码无法复用。</p> 
<h4 id="分布式架构">分布式架构</h4> 
<p>对于一个大型的互联网系统，一般会包含多个应用，而且应用之间往往还存在共同的业务，并且应用之间还存在调用关系。除此之外 ，对于大型的互联网系统还有一些其它的挑战，比如如何应对急剧增长的用户，如何管理好研发团队快速迭代产品研发，如何保持产品升级更加稳定等等 。</p> 
<p>因此，为了使业务得到很好的复用，模块更加容易拓展和维护，我们希望业务与应用分离，某个业务不再属于一个应用，而是作为一个独立的服务单独进行维护。应用本身不再是一个臃肿的模块堆积，而是由一个个模块化的服务组件组合而成。</p> 
<p><img src="https://images2.imgbox.com/f5/14/MnUZ5Skq_o.png" alt="这里写图片描述" title=""></p> 
<h3 id="服务化">服务化</h3> 
<h4 id="服务化的特点">服务化的特点</h4> 
<p>上面介绍的分布式架构即服务化。我们再总结一下，服务化主要有如下特点：</p> 
<ul><li>应用按业务拆分成服务</li><li>各个服务均可独立部署</li><li>服务可被多个应用共享</li><li>服务之间可以通信</li></ul> 
<h4 id="服务化的好处">服务化的好处</h4> 
<p>那么企业采用服务化有哪些好处呢？</p> 
<ul><li>架构上系统更加清晰</li><li>核心模块稳定，以服务组件为单位进行升级，避免了频繁发布带来的风险</li><li>开发管理方便</li><li>单独团队维护、工作分明，职责清晰</li><li>业务复用、代码复用</li><li>非常容易拓展</li></ul> 
<h4 id="服务化实现方式">服务化实现方式</h4> 
<p>如果要实现服务化的话，最常用的方式就是利用RPC框架。因为服务组件一般分布在不同的服务器上，所以要实现服务化需要解决的第一个问题就是RPC**远程服务调用**。类似于RPC方案有很多，比如：</p> 
<ul><li>Java RMI</li><li>WebService</li><li>Hessian</li><li>Http</li><li>Thrift</li><li>… …</li></ul> 
<h4 id="服务化面临的挑战">服务化面临的挑战</h4> 
<p>上面提到要实现服务化首先需要解决远程服务调用问题，除此之外，还有很多其他问题需要解决。</p> 
<ul><li>服务越来越多，配置管理复杂</li><li>服务间依赖关系复杂</li><li>服务之间的负载均衡</li><li>服务的拓展</li><li>服务监控</li><li>服务降级</li><li>服务鉴权</li><li>服务上线与下线</li><li>服务文档</li><li>… …</li></ul> 
<h3 id="服务治理">服务治理</h3> 
<p>上面提到了服务化，其实要想服务化，<strong>服务治理</strong>是关键。那么有没有好的服务治理方案呢？答案是有的，而且很多人都在用这个框架，他就是-dubbo。dubbo就是一个<strong>带有服务治理功能的RPC框架</strong>。</p> 
<p><img src="https://images2.imgbox.com/c3/14/qQNVPou6_o.png" alt="这里写图片描述" title=""></p> 
<p>dubbo提供了一套较为完整的服务治理方案，所以企业如果要实现服务化的话，dubbo 是很好的一个选择。这里简单介绍一下dubbo服务治理相关方案。</p> 
<h5 id="服务发现注册">服务发现注册</h5> 
<p>服务治理领域最重要的问题就是服务发现与注册。dubbo中引入了一个注册中心的概念，服务的注册与发现主要就依赖这个服务中心。</p> 
<p><img src="https://images2.imgbox.com/77/ed/uiyI2TYx_o.png" alt="这里写图片描述" title=""></p> 
<p>dubbo注册中心服务注册发现的具体过程：</p> 
<ul><li>服务提供者启动，向注册中心注册自己提供的服务</li><li>消费者启动，向注册中心订阅自己需要的服务</li><li>注册中心返回服务提供者的列表给消费者</li><li>消费者从服务提供者列表中，按照软负载均衡算法，选择一台发起请求</li></ul> 
<h5 id="服务监控">服务监控</h5> 
<p><img src="https://images2.imgbox.com/3e/f5/NBSMbVMa_o.png" alt="这里写图片描述" title=""></p> 
<h5 id="集群容错">集群容错</h5> 
<p><img src="https://images2.imgbox.com/0b/45/cK7KwLst_o.png" alt="这里写图片描述" title=""></p> 
<h5 id="负载均衡">负载均衡</h5> 
<ul><li>Random Loadbalance</li><li>RoundRobin </li><li>LeastActive </li><li>ConsistentHash </li></ul> 
<h5 id="dubbo服务治理优势">dubbo服务治理优势</h5> 
<ul><li>注册中心只负责注册查找，不负责请求转发，压力小</li><li>注册中心宕机影响消费者，消费者本地缓存服务地址列表</li><li>注册中心对等集群，宕掉一台自动切换到另外 一台</li><li>服务提供者无状态，可动态部署，注册中心负责推送</li><li>统计无压力，本地内存中累计次数，每分钟发送注册中心</li><li>消费者调用服务者，自动软负载均衡</li><li>通过服务中心可追踪依赖关系</li><li>监控中心为扩容和降级提供依据</li><li>可启用acl机制进行鉴权</li><li>与Spring整合，接入简单松耦合</li><li>多种序列化协议支持</li></ul> 
<h5 id="dubbo的不足">dubbo的不足</h5> 
<ul><li>消费者仍需要依赖配置中心</li><li>消费者仍需要依赖jar包配置provider</li><li>提供者文档管理功能缺失</li><li>无统一入口</li><li>不支持OAuth2.0</li><li>内部鉴权不方便管理</li><li>无外部应用鉴权</li><li>接口基本裸奔，无法直接对外暴露服务</li><li>IT治理不方便</li></ul> 
<h3 id="微服务">微服务</h3> 
<p>现在很多人都在谈微服务，那么到底什么是微服务呢？这里谈谈我对微服务的理解。</p> 
<p>微服务有两个核心：</p> 
<ul><li>微：服务的粒度要细，即服务要细化到API</li><li>服务：提供好服务，要让用户感到好用(要做到这一点很不容易)</li></ul> 
<p>上面两个核心总结起来，可以用下面这幅图表示：</p> 
<p><img src="https://images2.imgbox.com/07/62/lYT0mDDV_o.png" alt="这里写图片描述" title=""></p> 
<p>从上面这幅图看出，微服务特别简单（好的架构就应该简单），我们把服务再拆分成一个个API，API是一个完整的功能。然后我们把API扔到一个“云上”，然后用户就可以到“云上”获取所有API的服务，这个“云”保证能提供好的服务。</p> 
<p>我们可以看到，有了微服务之后，服务对用户来说变得特别简单，而且上面dubbo的不足之处在微服务这里都解决了。使用者不再需要依赖任何jar包，不再需要去注册中心查找服务，不再去做鉴权处理，不用担心服务挂掉，不用担心不会使用服务，所有的问题这个“云”都解决了。这也是微服务的核心之一，提供好服务。</p> 
<p>说到这里，大家就应该大体知道该怎么做微服务了，图中的“云”是关键。下面我们就慢慢拨开这朵云。</p> 
<h4 id="微服务的实现">微服务的实现</h4> 
<p><img src="https://images2.imgbox.com/d1/c1/PwC5dz73_o.png" alt="这里写图片描述" title=""></p> 
<p>微服务的关键是<strong>服务网关</strong>，所以，上面提到的“云”就是服务网关。要做微服务，我们先定义一下微服务需要具备的特点。</p> 
<h5 id="微服务的特点">微服务的特点</h5> 
<p>服务需要再细化成API（服务接口——&gt;服务API）</p> 
<ul><li>每个服务由一组API组成</li><li>以API形式对外提供统一格式的服务</li><li>使用者无需任何配置，直接调用（http）</li><li>完整的API文档</li><li>API服务安全可靠稳定</li></ul> 
<h5 id="微服务要解决的问题">微服务要解决的问题</h5> 
<p>上面提到了，dubbo还存在一些问题 ，其实dubbo存在的问题 就是 微服务要解决的问题，这里 再总结一下。当然，dubbo和微服务的侧重点不一样，dubbo侧重于内部接口之间的RPC，而微服务则侧重于对外提供服务。</p> 
<ul><li>统一入口</li><li>安全控制：防刷限流</li><li>统一鉴权：应用鉴权、用户鉴权、OAuth鉴权、ACL</li><li>协议转换：http、dubbo、Protobuf</li><li>API配置管理</li><li>API上线、下线</li><li>API与服务接口映射</li><li>监控与报警</li><li>整体架构的可拓展、高并发、分布式 </li><li>服务容器自动收缩、扩容</li></ul> 
<h5 id="实现方案">实现方案</h5> 
<p><img src="https://images2.imgbox.com/1c/67/KHikSJ0Z_o.png" alt="这里写图片描述" title=""></p> 
<ul><li>负载均衡层：nginx/lvs/F5</li><li>微服务层 <br> 
  <ul><li>高性能服务网关</li><li>统一入口、API配置管理、分流鉴权、服务监控、协议转换</li><li>API映射、OAuth2.0、API文档管理</li><li>分布式、可拓展</li></ul></li><li>服务治理层 <br> 
  <ul><li>成熟的服务治理框架dubbo</li><li>MQ服务之间解耦</li></ul></li><li>弹性云 <br> 
  <ul><li>服务docker化</li><li>基于访问压力的实时集群调度与管理</li></ul></li></ul> 
<h5 id="弹性云">弹性云</h5> 
<p>这里简单介绍一下弹性云的概念，微服务要想提供好服务，保证API不能挂掉并且有好的性能，需要很高的运维要求。这里的弹性云便是自动化运维解决方案，对访问压力进行监控，根据监控解决调度应用的发布和回收。</p> 
<p><img src="https://images2.imgbox.com/67/1d/8yCAaYWj_o.png" alt="这里写图片描述" title=""></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8300e75e44e08d49992598bd6b051b18/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python-获取当前工作路径</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1854e7532c7f6a9cdb2d7034f8389cd1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">邮件：事务失败。 服务器响应为:DT:SPM 163 smtp</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>