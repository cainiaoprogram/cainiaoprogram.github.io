<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【vue】关于路由的使用&#43;vite跨域 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【vue】关于路由的使用&#43;vite跨域" />
<meta property="og:description" content="（1）路由步骤 根据官方的文档，我们的路由大概需要以下的几种构成
（1）首先引入组件
（2）创建routes布局
（3）创建router对象
（4）抛出
（5）挂载
在我们使用的组件化开发的情况下，我们具体的步骤是这样的
首先我们创建一个index.js的文件，我们习惯性地放在router的文件夹下面
然后构建routes数组，里面都是各种路由，基础属性就是path和componet 然后赋予历史属性，创建路由示例
最后进行抛出的话，为了让外界能读取到
最后，我们把这个东西use在vue示例上，注意要先使用再挂载
（2）最基本的显示方法 &lt;router-link&gt;这个标签很像是超链接，但是具体的url用的是to
&lt;router-view&gt;就会展示我们需要的东西 ，在实际的应用中对应路由会展示对应组件的内容
如果想展示嵌套路由，就在展示的组件下面，再挂上一个&lt;router-view&gt;组件
我们仍然是举个例子，最简单的管理系统项目里面，我们的组件有侧边导航，顶部框，还有展示的不同内容。最常见的处理方法为：
创建一个主界面组件homeView：里面包含三个组件navi header 以及子路由router
比如路由/father展示的是整个homeView组件，不展示子组件的时候，紫色区域是空的，当调用某个子路由的时候比如/father/son1，son1的内容就会展示在紫色区域，相当于顺次进行展开
在构建组件化开发的时候，我们一般会在主启动页面（根组件）放个路由展示标签，表示路由展示会从这里开始展开 （App.vue里面的东西）
最简单的是这种东西
（3）关于路由的一些语法 1.动态路由参数，绑定一个参数，传入到子组件里面
例如这样绑定一个id参数，类似bind语法
2.这个参数也可以写成很多的形式
3.绑定元素后面加上括号，括号里可以放置一些正则表达式
4.在元素后面加个&#43;符号，代表这里开始可以接受多个元素，形成一个数组
5.元素后面加个*符号，代表这个参数可有可无 （4）关于子路由的写法 写在chirdren数组里面
并且子路由的路径前面不需要加入/符号了，其余的仍然是组件对象
(5) 关于路由守卫 每次进入一个路由的时候，路由守卫会先进行判断，然后再确认是否放行
放任放行的方式有两个，一个是return true，另一个是执行第三个参数--next方法
（1）全局路由守卫beforeEach，每次打开一个新的路由都都会走一次这个方法，这个方法写在router对象创建之后
（2）单个路由的路由守卫beforeEnter，每次打开这个路由就会触发一次路由首位，写在每个路由对象里面
（3）组件内路由首位，只要使用了这个组件就会调用，其实也算是生命周期函数，通过路由规则修改成当前组件时调用beforeRouteEnter，通过路由规则把当前组件修改成其他组件的时候会调用beforeRouteLeave，还有检测到组件内属性更新时候的beforeRouteUpdate
这些东西触发的条件是组件通过路由发生改变，目前来看跳转一般不会影响这些，通过路由规则指的是手动修改url地址 这样子才会触发对应的守卫函数，不然可能触发不全
6.路由之间的跳转 （1）第一种方式：直接修改url，这是可行的，并且会直接触发组件守卫
（2）第二种方式：通过&lt;router-link to=&#34;目标地址&#34;&gt;跳转
（3）第三种方式，通过$router引用
补充：vite跨域文件如下 import { fileURLToPath, URL } from &#39;node:url&#39; import { defineConfig } from &#39;vite&#39; import vue from &#39;@vitejs/plugin-vue&#39; // https://vitejs." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/707f4a98814e3fbfd6ceb601235d3449/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-11T22:38:47+08:00" />
<meta property="article:modified_time" content="2023-01-11T22:38:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【vue】关于路由的使用&#43;vite跨域</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>（1）路由步骤</h2> 
<p></p> 
<p>根据官方的文档，我们的路由大概需要以下的几种构成</p> 
<p>（1）首先引入组件</p> 
<p>（2）创建routes布局</p> 
<p>（3）创建router对象</p> 
<p>（4）抛出</p> 
<p>（5）挂载</p> 
<p>在我们使用的组件化开发的情况下，我们具体的步骤是这样的</p> 
<p>首先我们创建一个index.js的文件，我们习惯性地放在router的文件夹下面</p> 
<p><img alt="" height="141" src="https://images2.imgbox.com/1a/b5/mbAglYqk_o.png" width="849"></p> 
<p> 然后构建routes数组，里面都是各种路由，基础属性就是path和componet </p> 
<p><img alt="" height="335" src="https://images2.imgbox.com/34/f3/D3F4ld00_o.png" width="768">然后赋予历史属性，创建路由示例</p> 
<p><img alt="" height="278" src="https://images2.imgbox.com/cb/74/ltFjei55_o.png" width="999"></p> 
<p>最后进行抛出的话，为了让外界能读取到</p> 
<p><img alt="" height="68" src="https://images2.imgbox.com/35/ec/z2K6iFor_o.png" width="333"></p> 
<p> 最后，我们把这个东西use在vue示例上，注意要先使用再挂载</p> 
<p><img alt="" height="196" src="https://images2.imgbox.com/04/63/828UWP16_o.png" width="725"></p> 
<h2>（2）最基本的显示方法 </h2> 
<p><img alt="" height="69" src="https://images2.imgbox.com/76/a0/1isF2uLA_o.png" width="964"></p> 
<p>&lt;router-link&gt;这个标签很像是超链接，但是具体的url用的是to</p> 
<p>&lt;router-view&gt;就会展示我们需要的东西 ，在实际的应用中对应路由会展示对应组件的内容</p> 
<p>如果想展示嵌套路由，就在展示的组件下面，再挂上一个&lt;router-view&gt;组件</p> 
<p>我们仍然是举个例子，最简单的管理系统项目里面，我们的组件有侧边导航，顶部框，还有展示的不同内容。最常见的处理方法为：</p> 
<p>创建一个主界面组件homeView：里面包含三个组件navi header 以及子路由router</p> 
<p><img alt="" height="670" src="https://images2.imgbox.com/df/3b/qn9PLCle_o.png" width="1143"></p> 
<p>比如路由/father展示的是整个homeView组件，不展示子组件的时候，紫色区域是空的，当调用某个子路由的时候比如/father/son1，son1的内容就会展示在紫色区域，相当于顺次进行展开</p> 
<p>在构建组件化开发的时候，我们一般会在主启动页面（<span style="color:#fe2c24;"><strong>根组件</strong></span>）放个路由展示标签，表示路由展示会从这里开始展开 </p> 
<p>（App.vue里面的东西）</p> 
<p><img alt="" height="128" src="https://images2.imgbox.com/2a/13/jfeVmMZF_o.png" width="488"></p> 
<p></p> 
<p>最简单的是这种东西</p> 
<p><img alt="" height="60" src="https://images2.imgbox.com/d8/63/7LQJLaq5_o.png" width="387"></p> 
<h2> （3）关于路由的一些语法</h2> 
<p>1.动态路由参数，绑定一个参数，传入到子组件里面</p> 
<p><img alt="" height="43" src="https://images2.imgbox.com/e9/b9/df2c42hW_o.png" width="574"></p> 
<p>例如这样绑定一个id参数，类似bind语法</p> 
<p>2.这个参数也可以写成很多的形式</p> 
<p><img alt="" height="73" src="https://images2.imgbox.com/47/23/BzeP70gJ_o.png" width="631"></p> 
<p>3.绑定元素后面加上括号，括号里可以放置一些正则表达式</p> 
<p>4.在元素后面加个+符号，代表这里开始可以接受多个元素，形成一个数组</p> 
<p>5.元素后面加个*符号，代表这个参数可有可无 </p> 
<h2>（4）关于子路由的写法</h2> 
<p>写在chirdren数组里面</p> 
<p><img alt="" height="276" src="https://images2.imgbox.com/6c/86/3A8VNndW_o.png" width="803"></p> 
<p>并且子路由的路径前面不需要加入/符号了，其余的仍然是组件对象</p> 
<h2>(5) 关于路由守卫</h2> 
<p>每次进入一个路由的时候，路由守卫会先进行判断，然后再确认是否放行</p> 
<p>放任放行的方式有两个，一个是return true，另一个是执行第三个参数--next方法</p> 
<p>（1）全局路由守卫<span style="color:#956fe7;"><strong>beforeEach</strong></span>，每次打开一个新的路由都都会走一次这个方法，这个方法写在router对象创建之后</p> 
<p><img alt="" height="250" src="https://images2.imgbox.com/c8/99/Fzc7wQTR_o.png" width="1200"></p> 
<p>（2）单个路由的路由守卫<span style="color:#956fe7;"><strong>beforeEnter</strong></span>，每次打开这个路由就会触发一次路由首位，写在每个路由对象里面<img alt="" height="172" src="https://images2.imgbox.com/22/f0/Oxe2qxJA_o.png" width="777"></p> 
<p> （3）组件内路由首位，只要使用了这个组件就会调用，其实也算是生命周期函数，通过路由规则修改成当前组件时调用<span style="color:#956fe7;"><strong>beforeRouteEnter</strong></span>，通过路由规则把当前组件修改成其他组件的时候会调用<span style="color:#956fe7;"><strong>beforeRouteLeave，</strong></span><span style="color:#0d0016;">还有检测到组件内属性更新时候的</span><span style="color:#956fe7;"><strong>beforeRouteUpdate</strong></span></p> 
<p><img alt="" height="121" src="https://images2.imgbox.com/2c/7a/53e8rClf_o.png" width="980"></p> 
<p>这些东西触发的条件是组件通过路由发生改变，目前来看跳转一般不会影响这些，通过路由规则指的是手动修改url地址 <img alt="" height="32" src="https://images2.imgbox.com/68/80/T1OQaaCJ_o.png" width="348"></p> 
<p> 这样子才会触发对应的守卫函数，不然可能触发不全</p> 
<h2><strong>6.路由之间的跳转</strong></h2> 
<p><strong>（1）</strong>第一种方式：直接修改url，这是可行的，并且会直接触发组件守卫</p> 
<p>（2）第二种方式：通过&lt;router-link to="目标地址"&gt;跳转</p> 
<p>（3）第三种方式，通过$router引用</p> 
<p><img alt="" height="292" src="https://images2.imgbox.com/bd/67/Dn8nsVD3_o.png" width="1041"></p> 
<p></p> 
<h2>补充：vite跨域文件如下</h2> 
<pre><code class="language-javascript">import { fileURLToPath, URL } from 'node:url'

import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()],
  server:{//服务器
    proxy:{//代理
      '/api':{
        target:"这个后续再进行设计吧",
        changeOrigin:true,//允许跨域，这里一定要设置为true
        rewrite:path=&gt;path.replace('/\^/api','')
        //忽略这部分的内容(其实就是我们手写的这个/api，这部分会多余出来)
        //最终访问的东西为target+path，target就是我们写的那些，path就是整体的请求”/api/xx“
        //一般来说，检测到/api/xxx的字样，就会启动代理，但是如果我们不重写path，合并结果就是target/api/xx
        //多出一个api字段，这个是我们想要替换掉的，所以我们在rewrite里面调用一个函数，把path前面的api字段去掉再弄
      },
    }
  },
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  }
})
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1bbbd63da1236fa10ebd5deec19dbc1f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SQL注入绕过安全狗的五种方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/616bfb1cd8cce5afa175f4aed1d25def/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue2&#43;VantUI移动端项目框架搭建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>