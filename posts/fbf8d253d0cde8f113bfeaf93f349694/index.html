<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GRASP设计原则 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GRASP设计原则" />
<meta property="og:description" content="GRASP设计原则 介绍9种基本原则创建者 Creator问题解决方法何时不使用?好处 信息专家 Information Expert问题解决方法信息怎么做优点 低耦合 Low Coupling耦合问题解决方法原则何时不使用? 控制器 Controller问题解决方法外观控制器会话控制器 优点臃肿控制器的解决方法 高内聚 High Cohesion问题解决办法用法衡量概念之间相关度的两个指标内聚的最佳实践类低内聚 多态 Polymorphism问题解决办法推论 纯虚构 Pure Fabrication问题解决办法推论原则风险 间接 Indirection问题解决办法 隔离变化问题解决办法变化点的分类 介绍 GRASP(General Responsibility Assignment Software Pattern)是通用职责分配软件设计模式，它可以帮助设计人员理解面向对象设计的本质，并以一种有条理的、理性的、可解释的方式来运用这些原则。由《UML和模式应用》(Applying UML and Patterns)一书作者Craig Larman提出。
在面向对象设计的过程中一般的通用方式是构思对象的职责、角色和协作。通常来说，我们在编码过程中先分析问题域，从中抽象出对象解决问题。简单的面向对象和优秀的面向对象设计的区别在于如何更合理的划分对象的角色，给对象赋予合理的职责以及对象之间的交互关系。
GRASP是对象职责分配的基本原则，其核心思想是职责分配，用职责设计对象。
9种基本原则 创建者（Creator）信息专家（Information Expert）低耦合（Low coupling）控制器（Controller）高内聚（High Cohesion）多态性（Polymorphism）纯虚构（Pure Fabrication）间接性（Indirection）隔离变化（Protected Variations） 这些模式都是针对软件开发上的一些问题进行解决。发明这些技巧不是为了要创造新的工作方式，而是为在面向对象设计上，对经过测试的程序设计方式创建文档并且标准化。
Craig Larman提到：“软件开发最关键的设计工具不是UML或其他的技术，是明了设计原则的心智。”。因此，GRASP原则是心理层面的工具集，是面向对象软件设计学习的辅助工具。
创建者 Creator 问题 谁负责创建类的实例？
解决方法 满足下面一个选项，则由B来创建A：
B包含，聚集AB记录AB紧密使用 AB拥有A的初始化数据 若有一个以上的选项适用，则首选包含或聚集A的类。
注意：A和B都是软件对象，而不是领域对象。
何时不使用? 出于性能目的（缓存）而重用类的实例有些情况下要基于某些外部属性值从一个相似类的家族创建一个实例（抽象工厂模式）委托职责向下传递其他复杂情况 好处 使用方便高内聚低耦合 信息专家 Information Expert 问题 为一个对象分配职责的一般性原则是什么？
解决方法 若这个类拥有完成这个职责所需要的数据，则把这个职责分配给这个类。
信息 一个对象拥有的状态和一个对象相关的其他对象一个对象派生的信息等等 怎么做 明确地表达职责在设计模型中查看相关的类在领域模型中查看并创建设计类 优点 封装性：对象充分利用自身的信息，低耦合" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fbf8d253d0cde8f113bfeaf93f349694/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-15T09:21:44+08:00" />
<meta property="article:modified_time" content="2023-02-15T09:21:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GRASP设计原则</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>GRASP设计原则</h4> 
 <ul><li><a href="#_1" rel="nofollow">介绍</a></li><li><a href="#9_7" rel="nofollow">9种基本原则</a></li><li><a href="#_Creator_21" rel="nofollow">创建者 Creator</a></li><li><ul><li><a href="#_22" rel="nofollow">问题</a></li><li><a href="#_24" rel="nofollow">解决方法</a></li><li><a href="#_33" rel="nofollow">何时不使用?</a></li><li><a href="#_38" rel="nofollow">好处</a></li></ul> 
  </li><li><a href="#_Information_Expert_42" rel="nofollow">信息专家 Information Expert</a></li><li><ul><li><a href="#_43" rel="nofollow">问题</a></li><li><a href="#_45" rel="nofollow">解决方法</a></li><li><a href="#_47" rel="nofollow">信息</a></li><li><a href="#_52" rel="nofollow">怎么做</a></li><li><a href="#_56" rel="nofollow">优点</a></li></ul> 
  </li><li><a href="#_Low_Coupling_59" rel="nofollow">低耦合 Low Coupling</a></li><li><ul><li><a href="#_60" rel="nofollow">耦合</a></li><li><a href="#_81" rel="nofollow">问题</a></li><li><a href="#_83" rel="nofollow">解决方法</a></li><li><a href="#_85" rel="nofollow">原则</a></li><li><a href="#_90" rel="nofollow">何时不使用?</a></li></ul> 
  </li><li><a href="#_Controller_92" rel="nofollow">控制器 Controller</a></li><li><ul><li><a href="#_93" rel="nofollow">问题</a></li><li><a href="#_95" rel="nofollow">解决方法</a></li><li><ul><li><a href="#_98" rel="nofollow">外观控制器</a></li><li><a href="#_103" rel="nofollow">会话控制器</a></li></ul> 
   </li><li><a href="#_110" rel="nofollow">优点</a></li><li><a href="#_115" rel="nofollow">臃肿控制器的解决方法</a></li></ul> 
  </li><li><a href="#_High_Cohesion_121" rel="nofollow">高内聚 High Cohesion</a></li><li><ul><li><a href="#_122" rel="nofollow">问题</a></li><li><a href="#_124" rel="nofollow">解决办法</a></li><li><a href="#_126" rel="nofollow">用法</a></li><li><a href="#_129" rel="nofollow">衡量概念之间相关度的两个指标</a></li><li><a href="#_132" rel="nofollow">内聚的最佳实践</a></li><li><a href="#_137" rel="nofollow">类低内聚</a></li></ul> 
  </li><li><a href="#_Polymorphism_149" rel="nofollow">多态 Polymorphism</a></li><li><ul><li><a href="#_150" rel="nofollow">问题</a></li><li><a href="#_152" rel="nofollow">解决办法</a></li><li><a href="#_154" rel="nofollow">推论</a></li></ul> 
  </li><li><a href="#_Pure_Fabrication_158" rel="nofollow">纯虚构 Pure Fabrication</a></li><li><ul><li><a href="#_159" rel="nofollow">问题</a></li><li><a href="#_161" rel="nofollow">解决办法</a></li><li><a href="#_163" rel="nofollow">推论</a></li><li><a href="#_165" rel="nofollow">原则</a></li><li><a href="#_168" rel="nofollow">风险</a></li></ul> 
  </li><li><a href="#_Indirection_170" rel="nofollow">间接 Indirection</a></li><li><ul><li><a href="#_171" rel="nofollow">问题</a></li><li><a href="#_175" rel="nofollow">解决办法</a></li></ul> 
  </li><li><a href="#_181" rel="nofollow">隔离变化</a></li><li><ul><li><a href="#_182" rel="nofollow">问题</a></li><li><a href="#_186" rel="nofollow">解决办法</a></li><li><a href="#_190" rel="nofollow">变化点的分类</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>介绍</h2> 
<p>GRASP(General Responsibility Assignment Software Pattern)是通用职责分配软件设计模式，它可以帮助设计人员理解面向对象设计的本质，并以一种有条理的、理性的、可解释的方式来运用这些原则。由《UML和模式应用》(Applying UML and Patterns)一书作者Craig Larman提出。</p> 
<p>在面向对象设计的过程中一般的通用方式是构思对象的职责、角色和协作。通常来说，我们在编码过程中先分析问题域，从中抽象出对象解决问题。简单的面向对象和优秀的面向对象设计的区别在于如何更合理的划分对象的角色，给对象赋予合理的职责以及对象之间的交互关系。</p> 
<p>GRASP是对象职责分配的基本原则，其核心思想是职责分配，用职责设计对象。</p> 
<h2><a id="9_7"></a>9种基本原则</h2> 
<ul><li>创建者（Creator）</li><li>信息专家（Information Expert）</li><li>低耦合（Low coupling）</li><li>控制器（Controller）</li><li>高内聚（High Cohesion）</li><li>多态性（Polymorphism）</li><li>纯虚构（Pure Fabrication）</li><li>间接性（Indirection）</li><li>隔离变化（Protected Variations）</li></ul> 
<p>这些模式都是针对软件开发上的一些问题进行解决。发明这些技巧不是为了要创造新的工作方式，而是为在面向对象设计上，对经过测试的程序设计方式创建文档并且标准化。</p> 
<p>Craig Larman提到：“软件开发最关键的设计工具不是UML或其他的技术，是明了设计原则的心智。”。因此，GRASP原则是心理层面的工具集，是面向对象软件设计学习的辅助工具。</p> 
<h2><a id="_Creator_21"></a>创建者 Creator</h2> 
<h3><a id="_22"></a>问题</h3> 
<p>谁负责创建类的实例？</p> 
<h3><a id="_24"></a>解决方法</h3> 
<p>满足下面一个选项，则由B来创建A：</p> 
<ol><li>B包含，聚集A</li><li>B记录A</li><li>B紧密使用 A</li><li>B拥有A的初始化数据</li></ol> 
<p>若有一个以上的选项适用，则首选包含或聚集A的类。</p> 
<blockquote> 
 <p>注意：A和B都是软件对象，而不是领域对象。</p> 
</blockquote> 
<h3><a id="_33"></a>何时不使用?</h3> 
<ol><li>出于性能目的（缓存）而重用类的实例</li><li>有些情况下要基于某些外部属性值从一个相似类的家族创建一个实例（抽象工厂模式）</li><li>委托职责向下传递</li><li>其他复杂情况</li></ol> 
<h3><a id="_38"></a>好处</h3> 
<ul><li>使用方便</li><li>高内聚</li><li>低耦合</li></ul> 
<h2><a id="_Information_Expert_42"></a>信息专家 Information Expert</h2> 
<h3><a id="_43"></a>问题</h3> 
<p>为一个对象分配职责的一般性原则是什么？</p> 
<h3><a id="_45"></a>解决方法</h3> 
<p>若这个类拥有完成这个职责所需要的数据，则把这个职责分配给这个类。</p> 
<h3><a id="_47"></a>信息</h3> 
<ul><li>一个对象拥有的状态</li><li>和一个对象相关的其他对象</li><li>一个对象派生的信息</li><li>等等</li></ul> 
<h3><a id="_52"></a>怎么做</h3> 
<ol><li>明确地表达职责</li><li>在设计模型中查看相关的类</li><li>在领域模型中查看并创建设计类</li></ol> 
<h3><a id="_56"></a>优点</h3> 
<p>封装性：对象充分利用自身的信息，低耦合<br> 系统行为分布到不同的类：高内聚</p> 
<h2><a id="_Low_Coupling_59"></a>低耦合 Low Coupling</h2> 
<h3><a id="_60"></a>耦合</h3> 
<ol><li>耦合的定义</li></ol> 
<p>一个元素和另一个元素的连接，感知和依赖程度。</p> 
<ol start="2"><li>比较</li></ol> 
<p>内聚：模块内的元素之间紧密程度，如一个类内部操作之间。</p> 
<p>耦合：两个子模块之间的紧密程度，如两个类之间的操作。</p> 
<ol start="3"><li>高耦合带来的问题</li></ol> 
<ul><li>牵一发动全身</li><li>元素孤立是无法理解</li><li>元素很难重用</li></ul> 
<ol start="4"><li>X与Y存在耦合的情况，例如：</li></ol> 
<ul><li>X拥有Y的属性</li><li>X调用Y的服务</li><li>X有Y的成员变量，方法参数和局部变量</li><li>X是Y的子类</li><li>Y是接口，X实现接口</li></ul> 
<h3><a id="_81"></a>问题</h3> 
<p>如何保证设计方案支持低依赖性，低变化影响度和增加可重用性？</p> 
<h3><a id="_83"></a>解决方法</h3> 
<p>分配职责后仍然保持低耦合。</p> 
<h3><a id="_85"></a>原则</h3> 
<ol><li>低耦合不具备可操作性，是一个评估原则，如：若两个方案都可以的，倾向于选择低耦合的方案。继承关系中，子类与父类的耦合非常紧密，如：能用组合的不要用继承。</li><li>类之间存在适当的耦合是必须的，正常的。因为只有这样才产生面向对象系统，任务才能通过对象间的相互协作来完成。</li><li>不能单独考虑低耦合，极端情况：类之间没有耦合。这样会形成一个很差的设计，一个类来完成全部的工作。</li><li>低耦合与其他原则，如信息专家、高内聚必须综合考虑。</li></ol> 
<h3><a id="_90"></a>何时不使用?</h3> 
<p>若是稳定的或广为流传的，可以有高耦合，如Java的jdk，软件系统可以和jdk高耦合。</p> 
<h2><a id="_Controller_92"></a>控制器 Controller</h2> 
<h3><a id="_93"></a>问题</h3> 
<p>在领域层，由谁负责首先接收并协调来自UI层的系统操作？</p> 
<h3><a id="_95"></a>解决方法</h3> 
<ol><li>Facade(外观) Controller：代表整个系统的对象，如一个根对象，一个系统运行的设备或一个主要的子系统。</li><li>Use Case or Session Controller（用例控制器、会话控制器）：代表一类系统事件产生的用例场景。</li></ol> 
<h4><a id="_98"></a>外观控制器</h4> 
<p>相当于领域层对外部世界的“脸”。适用于：</p> 
<ul><li>相对较小的系统</li><li>有限数量的系统操作</li><li>在消息处理系统中，不能转发消息到可选的控制器时</li></ul> 
<h4><a id="_103"></a>会话控制器</h4> 
<p>处理系统某个明确的功能集，比如相关的一组系统事件。适用于：</p> 
<ul><li>当采用外观控制器会导致高耦合、低内聚时</li><li>很多系统事件跨越多个不同的处理过程</li><li>概念上容易理解和构建</li></ul> 
<p>其命名习惯： Handler 、 CoOrdinator、Session</p> 
<h3><a id="_110"></a>优点</h3> 
<ul><li>容易适应UI层的变化</li><li>领域层代码易于重用（因为UI层一般与应用关系密切）</li><li>有助于保证应用所需要的操作顺序</li><li>可以对系统的状态进行推理（UI层不保存系统状态）</li></ul> 
<h3><a id="_115"></a>臃肿控制器的解决方法</h3> 
<p>当一个控制器处理了大部分系统事件时，控制器掌握了太多的系统信息，就会形成臃肿的控制器，导致低内聚。解决方法是：</p> 
<ul><li>增加更多的控制器</li><li>采用会话控制器替换外观控制器</li><li>控制器委托任务给别的对象，而不是自己做</li><li>高内聚的理念</li></ul> 
<h2><a id="_High_Cohesion_121"></a>高内聚 High Cohesion</h2> 
<h3><a id="_122"></a>问题</h3> 
<p>如何使对象功能专注、可理解、可管理，同时又支持低耦合。</p> 
<h3><a id="_124"></a>解决办法</h3> 
<p>分配职责时保证高内聚。</p> 
<h3><a id="_126"></a>用法</h3> 
<ul><li>用作评价工具</li><li>更多的是一种理念，没有具体的可操作原则。</li></ul> 
<h3><a id="_129"></a>衡量概念之间相关度的两个指标</h3> 
<ul><li>Cohension，内聚：模块内元素之间联系紧密的程度，例如，一个类内部的操作之间。</li><li>Coupling，耦合：两个模块之间联系的强度。</li></ul> 
<h3><a id="_132"></a>内聚的最佳实践</h3> 
<p>1 一个类完成的功能不要太多，且这些功能都是同级别的。例如：教授的主要功能是教学，研究员的主要工作是科研。<br> 2 如果同类别的工作太多，则会定义新的类分担任务，相互间合作。</p> 
<p>例如：”不是一家人，不进一家门”，“人”指的是操作，职责，”门”指的是模块，类。</p> 
<h3><a id="_137"></a>类低内聚</h3> 
<ol><li>症状</li></ol> 
<ul><li>做了太多相互无关的工作：不是你的职责你做了。</li><li>做了太多工作：是你的职责，但做的事情太多了，需要把职责在细分。</li></ul> 
<ol start="2"><li>原因</li></ol> 
<ul><li>大粒度的抽象：如打扫卫生可以分为扫地，擦黑板等。</li><li>做了太多本应该委托给其他类去做的工作。</li></ul> 
<ol start="3"><li>缺点</li></ol> 
<ul><li>难以理解：因为职责太多，太复杂。</li><li>难以重用：耦合度太高。</li><li>难以维护：很难修改。</li><li>没有稳定的时刻，总是在修改 (通常都会高耦合)。</li></ul> 
<h2><a id="_Polymorphism_149"></a>多态 Polymorphism</h2> 
<h3><a id="_150"></a>问题</h3> 
<p>如何处理因类型不同而导致行为不同的一类需求？</p> 
<h3><a id="_152"></a>解决办法</h3> 
<p>使用多态操作为依据类型变化的行为来分配职责。</p> 
<h3><a id="_154"></a>推论</h3> 
<ul><li>不要测试对象的类型或条件逻辑，并以此选择相应的行为。</li><li>即，不要使用条件逻辑，而是为不同的类定义相同名字的方法。</li><li>不同的类实现相同的接口，或有一个共同的父类（继承）。</li></ul> 
<h2><a id="_Pure_Fabrication_158"></a>纯虚构 Pure Fabrication</h2> 
<h3><a id="_159"></a>问题</h3> 
<p>依据一些原则（比如，信息专家）获得的解决方案不合适的情况下，既不想违反低耦合、高内聚，也不想违反其他的原则，如何把职责分配给对象？</p> 
<h3><a id="_161"></a>解决办法</h3> 
<p>把高度内聚的职责分配给虚构出来的一个类，这个类在领域模型里没有对应的概念。</p> 
<h3><a id="_163"></a>推论</h3> 
<p>这种方式在有的场合能起到支持低耦合、高内聚、重用的效果。</p> 
<h3><a id="_165"></a>原则</h3> 
<ol><li>使用虚构类仍然保持低耦合、高内聚，但可重用性要增加。</li><li>多数情况下是按照功能来定义新的类，是一种“功能为中心”的对象，如果功能相关性比较高，则满足高内聚的特性。</li></ol> 
<h3><a id="_168"></a>风险</h3> 
<p>宽泛地说，虚构对象分为两类，代表性概念为主的分解和行为性概念为主的分解，可能导致面向功能或者面向过程的分析/设计，然后用OO语言去实现。</p> 
<h2><a id="_Indirection_170"></a>间接 Indirection</h2> 
<h3><a id="_171"></a>问题</h3> 
<p>若两个对象直接连接，导致耦合太紧，如何解决？</p> 
<p>即，把职责分配到哪里可以避免两个或多个对象之间的直接耦合？如何解耦对象以保持较高的可重用性？</p> 
<h3><a id="_175"></a>解决办法</h3> 
<p>把职责分配给一个中介对象，隔离对象，使两个对象、构件或服务之间不产生直接耦合。</p> 
<p>因为中介对象有一种特殊的作用，一般对象与中间对象之间直接耦合，相对比较简单。</p> 
<p>与纯虚构类似，但目的不同。</p> 
<h2><a id="_181"></a>隔离变化</h2> 
<h3><a id="_182"></a>问题</h3> 
<p>如何设计对象、系统和子系统，使得这些成分里面的变化因素、不稳定因素不会对系统的其余部分造成意想不到的影响？</p> 
<p>即，需求一定会变化的！如何做到以系统的局部变化为代价就可以应对这一点？</p> 
<h3><a id="_186"></a>解决办法</h3> 
<p>标识出能够已知或预计的变化点或者不稳定点，职责分配的时候创建一个稳定的接口，把它们与系统的其余部分隔离开来。</p> 
<blockquote> 
 <p>注意：“隔离可能的变化”是一个设计原则，如下技巧都使用隔离变化：数据封装、多态、数据驱动设计、 服务查询、配置文件、接口等都是这种机制的不同体现。</p> 
</blockquote> 
<h3><a id="_190"></a>变化点的分类</h3> 
<ul><li>变化点：当前系统已经存在。</li><li>演化点：当前系统不存在，未来可能存在的变化。</li></ul> 
<p>GRASP原则是一种理念，要时刻牢记，随时使用，就会造成潜移默化地加深理解，从而得到更好的设计！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ed7afdbc8ebe8bb10e73f36a8a9eb4ba/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在Linux安装Tomcat和JDK</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6fc27ca751c095546f1d107a52b1f317/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python linux 获取本机ip</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>