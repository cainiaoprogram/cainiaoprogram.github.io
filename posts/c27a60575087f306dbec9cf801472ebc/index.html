<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>19.Linux Shell任务控制 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="19.Linux Shell任务控制" />
<meta property="og:description" content="文章目录 Linux Shell任务控制1)信号通过键盘生成信号trap 命令捕获信号 2)在后台运行脚本命令后加 &amp; 符使用nohub命令 3)作业控制4)调度优先级nice命令renice 命令 5)定时运行作业at定期执行命令reference 欢迎访问个人网络日志🌹🌹知行空间🌹🌹
Linux Shell任务控制 通常情况下运行脚本的方式就是以实时模式在命令行界面上直接运行，除此之外还有很多其他的运行脚本的方式，如后台运行，定时运行等等。除运行方式外，还可以对脚本程序的运行进行控制，包括向脚本发送信号、修改脚本的优先级以及在脚本运行时从暂停切换到运行模式。
1)信号 Linux利用信号与运行在系统中的进程进行通信，可以通过对脚本进行编程，使其在收到特定信号时执行特定命令。
信号值描述1SIGHUP挂起进程2SIGINT终止进程3SIGQUIT停止进程9SIGKILL无条件终止进程15SIGTERM尽可能终止进程17SIGSTOP无条件停止进程，但不是终止进程18SIGTSTP停止或暂停进程，但不终止进程19SIGCONT继续运行停止的进程 默认情况下，交互式shell终端本身的进程会忽略收到的任何 SIGQUIT (3) 和 SIGTERM (5) 信号，因此其不会被意外终止。
如果bash shell收到了 SIGHUP 信号，比如当要离开一个交互式shell时，它就会退出。但在退出之前，它会将 SIGHUP 信号传给所有由该shell所启动的进程。
通过键盘生成信号 Ctrl&#43;C组合键会生成 SIGINT 信号，并将其发送给当前在shell中运行的所有进程。
Ctrl&#43;Z组合键会生成一个 SIGTSTP 信号，停止shell中运行的任何进程。这样可以在进程运行期间暂停进程，而无需终止它。这样可以在不终止进程的情况下使用户深入脚本内部一窥究竟。
停止进程会让程序继续保留在内存中，并能从上次停止的位置继续运行。
要想启动停止的进程可以使用fg或bg在前台和后台启动。
$ sleep 100 # ^Z # [1]&#43; 已停止 sleep 100 方括号中的数字是shell分配的作业号 （job number）。
可以用 ps 命令来查看已停止的作业。
$ ps -l # F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD # 0 T 1001 116014 113239 0 80 0 - 2791 do_sig pts/0 00:00:00 sleep 在 S 列中（进程状态）， ps 命令将已停止作业的状态为显示为 T 。这说明命令要么被跟踪，要么被停止了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c27a60575087f306dbec9cf801472ebc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-08T22:04:09+08:00" />
<meta property="article:modified_time" content="2024-01-08T22:04:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">19.Linux Shell任务控制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-kimbie-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Linux_Shell_7" rel="nofollow">Linux Shell任务控制</a></li><li><ul><li><a href="#1_11" rel="nofollow">1)信号</a></li><li><ul><li><a href="#_31" rel="nofollow">通过键盘生成信号</a></li><li><a href="#trap__61" rel="nofollow">trap 命令捕获信号</a></li></ul> 
   </li><li><a href="#2_178" rel="nofollow">2)在后台运行脚本</a></li><li><ul><li><a href="#___184" rel="nofollow">命令后加 &amp; 符</a></li><li><a href="#nohub_217" rel="nofollow">使用nohub命令</a></li></ul> 
   </li><li><a href="#3_235" rel="nofollow">3)作业控制</a></li><li><a href="#4_259" rel="nofollow">4)调度优先级</a></li><li><ul><li><a href="#nice_265" rel="nofollow">nice命令</a></li><li><a href="#renice__281" rel="nofollow">renice 命令</a></li></ul> 
   </li><li><a href="#5_290" rel="nofollow">5)定时运行作业</a></li><li><ul><li><a href="#at_294" rel="nofollow">at</a></li><li><a href="#_353" rel="nofollow">定期执行命令</a></li><li><a href="#reference_417" rel="nofollow">reference</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<p>欢迎访问个人网络日志🌹🌹<a href="https://foobarweb.net/" rel="nofollow">知行空间</a>🌹🌹</p> 
<hr> 
<h2><a id="Linux_Shell_7"></a>Linux Shell任务控制</h2> 
<p>通常情况下运行脚本的方式就是以实时模式在命令行界面上直接运行，除此之外还有很多其他的运行脚本的方式，如后台运行，定时运行等等。除运行方式外，还可以对脚本程序的运行进行控制，包括向脚本发送信号、修改脚本的优先级以及在脚本运行时从暂停切换到运行模式。</p> 
<h3><a id="1_11"></a>1)信号</h3> 
<p><code>Linux</code>利用信号与运行在系统中的进程进行通信，可以通过对脚本进行编程，使其在收到特定信号时执行特定命令。</p> 
<table><thead><tr><th align="left">信号</th><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">SIGHUP</td><td align="left">挂起进程</td></tr><tr><td align="left">2</td><td align="left">SIGINT</td><td align="left">终止进程</td></tr><tr><td align="left">3</td><td align="left">SIGQUIT</td><td align="left">停止进程</td></tr><tr><td align="left">9</td><td align="left">SIGKILL</td><td align="left">无条件终止进程</td></tr><tr><td align="left">15</td><td align="left">SIGTERM</td><td align="left">尽可能终止进程</td></tr><tr><td align="left">17</td><td align="left">SIGSTOP</td><td align="left">无条件停止进程，但不是终止进程</td></tr><tr><td align="left">18</td><td align="left">SIGTSTP</td><td align="left">停止或暂停进程，但不终止进程</td></tr><tr><td align="left">19</td><td align="left">SIGCONT</td><td align="left">继续运行停止的进程</td></tr></tbody></table> 
<p>默认情况下，交互式<code>shell</code>终端本身的进程会忽略收到的任何 <code>SIGQUIT (3)</code> 和 <code>SIGTERM (5)</code> 信号，因此其不会被意外终止。</p> 
<p>如果<code>bash shell</code>收到了 <code>SIGHUP</code> 信号，比如当要离开一个交互式<code>shell</code>时，它就会退出。但在退出之前，它会将 <code>SIGHUP</code> 信号传给所有由该<code>shell</code>所启动的进程。</p> 
<h4><a id="_31"></a>通过键盘生成信号</h4> 
<p><strong><code>Ctrl+C</code>组合键会生成 <code>SIGINT</code> 信号，并将其发送给当前在<code>shell</code>中运行的所有进程</strong>。</p> 
<p><code>Ctrl+Z</code>组合键会生成一个 <code>SIGTSTP</code> 信号，停止<code>shell</code>中运行的任何进程。这样可以在进程运行期间暂停进程，而无需终止它。这样可以在不终止进程的情况下使用户深入脚本内部一窥究竟。</p> 
<p>停止进程会让程序继续保留在内存中，并能从上次停止的位置继续运行。</p> 
<p><strong>要想启动停止的进程可以使用<code>fg</code>或<code>bg</code>在前台和后台启动</strong>。</p> 
<pre><code class="prism language-sh">$ <span class="token function">sleep</span> <span class="token number">100</span>
<span class="token comment"># ^Z</span>
<span class="token comment"># [1]+  已停止               sleep 100</span>
</code></pre> 
<p>方括号中的数字是<code>shell</code>分配的作业号 <code>（job number）</code>。</p> 
<p>可以用 <code>ps</code> 命令来查看已停止的作业。</p> 
<pre><code class="prism language-sh">$ <span class="token function">ps</span> <span class="token parameter variable">-l</span>
<span class="token comment"># F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span>
<span class="token comment"># 0 T  1001  116014  113239  0  80   0 -  2791 do_sig pts/0    00:00:00 sleep</span>
</code></pre> 
<p>在 <code>S</code> 列中（进程状态）， <code>ps</code> 命令将已停止作业的状态为显示为 <code>T</code> 。这说明命令要么被跟踪，要么被停止了。</p> 
<p>在有已停止作业存在的情况下退出<code>shell</code>会终止已停止作业。</p> 
<h4><a id="trap__61"></a>trap 命令捕获信号</h4> 
<p><code>trap</code>命令允许用户来指定<code>shell</code>脚本要监视并从<code>shell</code>中拦截的<code>Linux</code>信号。当脚本收到了 <code>trap</code> 命令中列出的信号，会执行用户指定的操作。</p> 
<p><code>trap</code>命令的格式：</p> 
<pre><code class="prism language-sh"><span class="token builtin class-name">trap</span> commands signals
</code></pre> 
<p>示例，</p> 
<pre><code class="prism language-sh"><span class="token shebang important">#!/bin/bash</span>

<span class="token builtin class-name">trap</span> <span class="token string">"echo 'Ctrl-C Pressed'"</span> SIGINT

<span class="token builtin class-name">echo</span> This is a <span class="token builtin class-name">test</span>

<span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$c</span> <span class="token parameter variable">-le</span> <span class="token number">5</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"Loop #<span class="token variable">$c</span>"</span>
    <span class="token function">sleep</span> <span class="token number">1</span>
    <span class="token assign-left variable">c</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$c</span> + <span class="token number">1</span> <span class="token punctuation">]</span>
<span class="token keyword">done</span>
</code></pre> 
<p>执行，</p> 
<pre><code class="prism language-sh">$ ./test.sh 
<span class="token comment"># This is a test</span>
<span class="token comment"># Loop #1</span>
<span class="token comment"># Loop #2</span>
<span class="token comment"># ^CCtrl-C Pressed</span>
<span class="token comment"># Loop #3</span>
<span class="token comment"># Loop #4</span>
<span class="token comment"># Loop #5</span>
</code></pre> 
<p>上面脚本中<code>trap</code> 命令会在每次检测到 <code>SIGINT</code> 信号时捕获这些信号，阻止用户用<code>bash shell</code>组合键<code>Ctrl+C</code>来停止程序。</p> 
<p><strong>除了在<code>shell</code>脚本中捕获中断信号，也可以在<code>shell</code>脚本退出时捕获退出信号<code>EXIT</code></strong>。以在<code>shell</code>完成任务时执行特定的命令。</p> 
<pre><code class="prism language-sh"><span class="token shebang important">#!/bin/bash</span>

<span class="token builtin class-name">trap</span> <span class="token string">"echo 'Running Finished.'"</span> EXIT

<span class="token builtin class-name">echo</span> This is a <span class="token builtin class-name">test</span>

<span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$c</span> <span class="token parameter variable">-le</span> <span class="token number">5</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"Loop #<span class="token variable">$c</span>"</span>
    <span class="token function">sleep</span> <span class="token number">1</span>
    <span class="token assign-left variable">c</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$c</span> + <span class="token number">1</span> <span class="token punctuation">]</span>
<span class="token keyword">done</span>
</code></pre> 
<p>执行，</p> 
<pre><code class="prism language-sh">$ ./test.sh 
<span class="token comment"># This is a test</span>
<span class="token comment"># Loop #1</span>
<span class="token comment"># Loop #2</span>
<span class="token comment"># Loop #3</span>
<span class="token comment"># Loop #4</span>
<span class="token comment"># Loop #5</span>
<span class="token comment"># Running Finished.</span>
</code></pre> 
<p><strong>要修改移除捕获，在脚本中的不同位置进行不同的捕获处理，只需重新使用带有新选项的 <code>trap</code> 命令</strong>。</p> 
<pre><code class="prism language-sh"><span class="token shebang important">#!/bin/bash</span>

<span class="token builtin class-name">trap</span> <span class="token string">"echo 'Caught SIGINT'"</span> SIGINT

<span class="token builtin class-name">echo</span> <span class="token string">"This is first caughtion of SIGINT"</span>

<span class="token assign-left variable">c</span><span class="token operator">=</span><span class="token number">1</span>
<span class="token keyword">while</span> <span class="token punctuation">[</span> <span class="token variable">$c</span> <span class="token parameter variable">-le</span> <span class="token number">3</span> <span class="token punctuation">]</span>
<span class="token keyword">do</span>
    <span class="token builtin class-name">echo</span> <span class="token string">"Loop #<span class="token variable">$c</span>"</span>
    <span class="token function">sleep</span> <span class="token number">1</span>
    <span class="token assign-left variable">c</span><span class="token operator">=</span>$<span class="token punctuation">[</span> <span class="token variable">$c</span> + <span class="token number">1</span> <span class="token punctuation">]</span>
<span class="token keyword">done</span>

<span class="token builtin class-name">trap</span> <span class="token string">"echo 'Redefine SIGINT '"</span> SIGINT
<span class="token builtin class-name">echo</span> <span class="token string">"This is Mutated caughtion of SIGINT"</span>
<span class="token function">sleep</span> <span class="token number">10</span>
</code></pre> 
<p>执行，</p> 
<pre><code class="prism language-sh">$ ./test.sh
<span class="token comment"># This is first caughtion of SIGINT</span>
<span class="token comment"># Loop #1</span>
<span class="token comment"># ^CCaught SIGINT</span>
<span class="token comment"># Loop #2</span>
<span class="token comment"># Loop #3</span>
<span class="token comment"># This is Mutated caughtion of SIGINT</span>
<span class="token comment"># ^CRedefine SIGINT</span>
</code></pre> 
<p>修改了信号捕获之后，脚本处理信号的方式就会发生变化。如果一个信号是在捕获被修改前接收到的，那么脚本仍然会根据最初的 <code>trap</code> 命令进行处理。</p> 
<p><strong>想删除已设置好的捕获，只需要在 <code>trap</code> 命令与希望恢复默认行为的信号列表之间加上两个破折号即可</strong>。</p> 
<pre><code class="prism language-sh"><span class="token builtin class-name">trap</span> -- SIGINT
</code></pre> 
<h3><a id="2_178"></a>2)在后台运行脚本</h3> 
<p>直接在命令行界面运行<code>shell</code>脚本，脚本在运行时，没法在终端会话里做别的事情。</p> 
<p>在用 <code>ps</code> 命令时，会看到运行在<code>Linux</code>系统上的一系列不同进程。这些进程显然都不是运行在当前的终端显示器上的，这种模式称为在后台运行进程。在后台模式中，进程运行时不会和终端会话上的 <code>STDIN</code> 、 <code>STDOUT</code> 以及 <code>STDERR</code> 关联。</p> 
<h4><a id="___184"></a>命令后加 &amp; 符</h4> 
<p>前面介绍过，<strong>以后台模式运行<code>shell</code>脚本，只要在命令后加个 &amp; 符就行</strong>。</p> 
<pre><code class="prism language-sh">$ ./test.sh <span class="token operator">&amp;</span>
<span class="token comment"># [1] 118347</span>
</code></pre> 
<p>方括号中的数字是<code>shell</code>分配给后台进程的作业号。下一个数是<code>Linux</code>系统分配给进程的进程<code>ID（PID）</code>。当后台进程结束时，它会在终端上显示出一条消息：</p> 
<pre><code class="prism language-sh"><span class="token comment"># [1]+  已完成               ./test.sh</span>
</code></pre> 
<p><strong>通过<code>./test.sh &amp;</code>命令将脚本放在后台运行还存在两个问题，一个是当前<code>bash shell</code>终端关闭时后台运行中的进程仍然会被终止，第二个时放入后台的脚本输出仍然会显示在显示器上，会与新输入命令的输入混淆在一起</strong>。</p> 
<p>运行多个后台作业时，通过 <code>ps</code> 命令，可以看到<br> 所有脚本处于运行状态。</p> 
<pre><code class="prism language-sh"> ./test.sh <span class="token operator">&amp;</span>
 ./test.sh <span class="token operator">&amp;</span>
</code></pre> 
<pre><code class="prism language-sh">$ <span class="token function">ps</span>
<span class="token comment"># F S   UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span>
<span class="token comment"># 0 S  1001  118703  118697  0  80   0 -  3178 do_wai pts/3    00:00:00 test.sh</span>
<span class="token comment"># 0 S  1001  118707  118703  0  80   0 -  2791 hrtime pts/3    00:00:00 sleep</span>
<span class="token comment"># 0 S  1001  118714  118697  0  80   0 -  3178 do_wai pts/3    00:00:00 test.sh</span>
<span class="token comment"># 0 S  1001  118718  118714  0  80   0 -  2791 hrtime pts/3    00:00:00 sleep</span>
</code></pre> 
<h4><a id="nohub_217"></a>使用nohub命令</h4> 
<p>当需要在终端会话中启动<code>shell</code>脚本，然后让脚本一直以后台模式运行到结束，且终端会话退出仍不影响脚本运行时，前面介绍的<code>&amp;</code>符号的方式就不适合了，这时需要使用<code>nohub</code>命令。</p> 
<p><code>nohup</code> 命令运行的后台任务会阻断所有发送给该进程的 <code>SIGHUP</code>信号，这可以在退出终端会话时阻止进程退出。</p> 
<p><code>nohup</code> 命令的格式:</p> 
<pre><code class="prism language-sh">$ <span class="token function">nohup</span> ./test.sh <span class="token operator">&amp;</span>
<span class="token comment"># [1] 119226</span>
<span class="token comment"># nohup: 忽略输入并把输出追加到'nohup.out'</span>
</code></pre> 
<p>由于 <code>nohup</code> 命令会解除终端与进程的关联，进程也就不再同 <code>STDOUT</code> 和 <code>STDERR</code> 联系在一起。<br> 为了保存该命令产生的输出， <code>nohup</code> 命令会自动将 <code>STDOUT</code> 和 <code>STDERR</code> 的消息重定向到一个名为<br> <code>nohup.out</code>的文件中。<strong>值得注意的是，当在同个目录同时启动多个<code>nohub</code>命令时，会输出到同一个<code>nohub.out</code>文件中</strong>。</p> 
<h3><a id="3_235"></a>3)作业控制</h3> 
<p><code>jobs</code> 命令可以查看分配给<code>shell</code>的作业。</p> 
<p>通过<code>test.sh</code>启动两个作业，</p> 
<pre><code class="prism language-sh">$ ./test.sh
<span class="token comment"># This is first caughtion of SIGINT</span>
<span class="token comment"># Loop #1</span>
<span class="token comment"># ^Z</span>
<span class="token comment"># [1]+  已停止</span>
$ ./test.sh <span class="token operator">&gt;</span> test.out <span class="token operator">&amp;</span>
<span class="token comment"># [2] 119480</span>
$ <span class="token function">jobs</span>
<span class="token comment"># [1]+  已停止               ./test.sh</span>
<span class="token comment"># [2]-  运行中               ./test.sh &gt; test.out &amp;</span>
</code></pre> 
<p>要想查看作业的<code>PID</code>，可以在 <code>jobs</code> 命令中加入 <code>-l</code> 选项。<strong><code>jobs</code> 命令输出中的加号和减号的含义是带加号的作业会被当做默认作业，在使用作业控制命令时，如果未在命令行指定任何作业号，该作业会被当成作业控制命令的操作对象</strong>。当前的默认作业完成处理后，带减号的作业成为下一个默认作业。任何时候都只有一个带加<br> 号的作业和一个带减号的作业。在前面介绍的重新启动停止的作业的命令<code>fg/bg</code>不带参数时，启动的就是<code>+</code>号对应的作业。</p> 
<p>更多<code>jobs</code>命令的选项参数，可以通过命令<code>jobs --help</code>查看。</p> 
<h3><a id="4_259"></a>4)调度优先级</h3> 
<p>调度优先级决定了内核分配给进程的CPU时间。在<code>Linux</code>系统中，由<code>shell</code>启动的所有进程的调度优先级默认都是相同的，都是<code>0</code>。调度优先级是个整数值，从<code>-20</code>（最高优先级）到<code>+19</code>（最低优先级）。</p> 
<p>要改变一个<code>shell</code>脚本的优先级，可以通过 <code>nice</code> 命令做到。</p> 
<h4><a id="nice_265"></a>nice命令</h4> 
<p><code>nice</code> 命令允许你设置命令启动时的调度优先级。要让命令以更低的优先级运行，只要用 <code>nice</code>的 <code>-n</code> 命令行来指定新的优先级即可。</p> 
<pre><code class="prism language-sh">$ <span class="token function">nice</span> <span class="token parameter variable">-n</span> <span class="token number">10</span> ./test.sh <span class="token operator">&gt;</span> test.out <span class="token operator">&amp;</span>
<span class="token comment"># [2] 120413</span>
$ <span class="token function">ps</span> <span class="token parameter variable">-p</span> <span class="token number">120413</span> <span class="token parameter variable">-o</span> pid,ppid,ni,cmd
<span class="token comment">#     PID    PPID  NI CMD</span>
<span class="token comment">#  120413  118697  10 /bin/bash ./test.sh</span>
</code></pre> 
<p>通过<code>ps</code>命令可以看到调度优先级已经被调整到了<code>10</code>。</p> 
<p><strong><code>nice</code> 命令阻止普通系统用户来提高命令的优先级</strong>，需要使用<code>root</code>权限。</p> 
<h4><a id="renice__281"></a>renice 命令</h4> 
<p><code>renice</code>命令用来改变系统上已运行命令的优先级。通过指定运行进程的PID来改变它的优先级。</p> 
<pre><code class="prism language-sh">$ <span class="token function">renice</span> <span class="token parameter variable">-n</span> <span class="token number">10</span> <span class="token parameter variable">-p</span> <span class="token number">120756</span>
<span class="token comment"># 120756 (process ID) 旧优先级为 0，新优先级为 10</span>
</code></pre> 
<h3><a id="5_290"></a>5)定时运行作业</h3> 
<p><code>Linux</code>系统提供了多个在预选时间运行脚本的方法： <code>at</code> 命令和 <code>cron</code> 表。</p> 
<h4><a id="at_294"></a>at</h4> 
<p><strong><code>at</code> 命令允许指定<code>Linux</code>系统何时运行脚本，相当于是预约执行任务</strong>。</p> 
<p><strong><code>at</code> 的守护进程 <code>atd</code> 会以后台模式运行，检查作业队列来运行作业。大多数<code>Linux</code>发行版会在启动时运行此守护进程</strong>。</p> 
<p><code>atd</code> 守护进程会检查系统上的一个特殊目录（通常位于<code>/var/spool/at</code>）来获取用 <code>at</code> 命令提交的作业。默认情况下， <code>atd</code> 守护进程会每60秒检查一下这个目录。有作业时， <code>atd</code> 守护进程会检查作业设置运行的时间。如果时间跟当前时间匹配， atd` 守护进程就会运行此作业。</p> 
<p><code>at</code> 命令的基本格式:</p> 
<pre><code class="prism language-sh">at <span class="token punctuation">[</span>-f filename<span class="token punctuation">]</span> <span class="token function">time</span>
</code></pre> 
<ul><li><code>-f</code> 参数来指定用于读取命令（脚本文件）的文件名。</li><li><code>time</code> 参数指定了Linux系统何时运行该作业。</li></ul> 
<p><code>at</code> 命令能识别多种不同的时间格式:</p> 
<ul><li>标准的小时和分钟格式，比如<code>22:15</code></li><li><code>AM/PM</code>指示符，比如<code>10:15 PM</code></li><li>特定可命名时间，比如<code>now</code>、<code>noon</code>、<code>midnight</code>或者<code>teatime（4 PM）</code></li><li>通过不同的日期格式指定特定的日期 
  <ul><li>标准日期格式，比如MMDDYY、MM/DD/YY或DD.MM.YY</li><li>文本日期，比如Jul 4或Dec 25，加不加年份均可</li><li>指定时间增量:当前时间+25 min。</li></ul> </li></ul> 
<pre><code class="prism language-sh">$ at <span class="token parameter variable">-f</span> test.sh  <span class="token number">21</span>:23
<span class="token comment"># warning: commands will be executed using /bin/sh</span>
<span class="token comment"># job 3 at Mon Jan  8 21:23:00 2024</span>
</code></pre> 
<p><strong>作业队列的字母排序越高，作业运行的优先级就越低，<code>nice</code>值更高</strong>。默认情况下， <code>at</code> 的作业会被提交到 <code>a</code> 作业队列。如果想以更高优先级运行作业，可以用 <code>-q</code> 参数指定不同的队列字母。</p> 
<p><strong>在使用 <code>at</code> 命令时，最好在脚本中对 <code>STDOUT</code> 和 <code>STDERR</code> 进行重定向</strong>。</p> 
<p><strong><code>atq</code> 命令可以查看系统中有哪些作业在等待</strong>。</p> 
<pre><code class="prism language-sh">$ atq
<span class="token comment"># 1	Mon Jan  8 21:17:00 2024 = rob</span>
<span class="token comment"># 6	Tue Jan  9 20:24:00 2024 a rob</span>
<span class="token comment"># 3	Mon Jan  8 21:23:00 2024 = rob</span>
<span class="token comment"># 4	Tue Jan  9 20:24:00 2024 a rob</span>
<span class="token comment"># 5	Tue Jan  9 20:24:00 2024 a rob</span>
</code></pre> 
<p>可以用 <code>atrm</code> 命令来删除等待中的作业。</p> 
<pre><code class="prism language-sh">$ atrm <span class="token number">6</span>
$ atq
<span class="token comment"># 1	Mon Jan  8 21:17:00 2024 = rob</span>
<span class="token comment"># 3	Mon Jan  8 21:23:00 2024 = rob</span>
<span class="token comment"># 4	Tue Jan  9 20:24:00 2024 a rob</span>
<span class="token comment"># 5	Tue Jan  9 20:24:00 2024 a rob</span>
</code></pre> 
<h4><a id="_353"></a>定期执行命令</h4> 
<p><code>at</code> 命令可以在预设时间安排脚本执行，但如果需要脚本在每天的同一时间运行或是每周一次、每月一次就需要使用新方法。</p> 
<p><code>Linux</code>系统使用<code>cron</code>程序来安排要定期执行的作业。 <code>cron</code>程序会在后台运行并检查<code>cron</code>时间表，以获知已安排执行的作业。</p> 
<p>可以使用<code>crontab -e</code>来编辑<code>cron</code>时间表：</p> 
<pre><code class="prism language-sh">$ <span class="token function">crontab</span> <span class="token parameter variable">-e</span>
<span class="token comment"># GNU nano 4.8                                 /tmp/crontab.hABXZo/crontab                                         </span>
<span class="token comment"># # Edit this file to introduce tasks to be run by cron.</span>
<span class="token comment"># # </span>
<span class="token comment"># # Each task to run has to be defined through a single line</span>
<span class="token comment"># # indicating with different fields when the task will be run</span>
<span class="token comment"># # and what command to run for the task</span>

</code></pre> 
<p>表中每一行表示一个定期执行的任务，其格式为：</p> 
<pre><code class="prism language-sh"><span class="token comment"># m h  dom mon dow   command</span>
</code></pre> 
<p><code>m</code>表示<code>分钟，</code>h<code>表示小时，</code>dom<code>表示几号，</code>mon<code>表示月份，</code>dow<code>表示星期几，</code>*`表示任意日期。</p> 
<p>分别是：<code>minute (m), hour (h), day of month (dom), month (mon),# and day of week (dow) or use '*' in these fields (for 'any')</code></p> 
<p>示例：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 0 5 * * 1 tar -zcf /var/backups/home.tgz /home/</span>
</code></pre> 
<p>表示每周一凌晨5点将<code>home.tgz</code>解压到<code>/home</code>路径中。</p> 
<p>每月最后一天执行的任务设置方式，</p> 
<pre><code class="prism language-sh"><span class="token comment"># 00 12 * * * if [ ` date +%d -d tomorrow ` = 01 ] ; then ; command</span>
</code></pre> 
<p><strong>列出<code>crontab</code>中的任务</strong>：</p> 
<pre><code class="prism language-sh"><span class="token function">crontab</span> <span class="token parameter variable">-l</span>
</code></pre> 
<p><strong>如果待执行的脚本对精确的执行时间要求不高，用预配置的cron脚本目录会更方便</strong>。在<code>/etc/</code>路径下有4个基本目录：<code>cron.hourly、daily、monthly</code>和<code>weekly</code>。譬如，如果脚本需要每天运行一次，只要将脚本复制到<code>daily</code>目录，<code>cron</code>就会每天执行它。</p> 
<p><strong><code>cron</code>程序的唯一问题是它假定Linux系统是7×24小时运行的，如果系统存在关机重启，有可能会错误定时任务，处理这种情况最好是能在开机时检查是否有错过的定时任务，而<code>cron</code>并不会去检查，很多<code>Linux</code>发行版还包含了<code>anacron</code>程序可以解决这个问题</strong>。</p> 
<p><code>anacron</code>程序只会处理位于<code>cron</code>目录的程序，比如<code>/etc/cron.monthly</code>。它用时间戳来决定作业是否在正确的计划间隔内运行了。每个<code>cron</code>目录都有个时间戳文件，该文件位于<code>/var/spool/anacron</code>。</p> 
<pre><code class="prism language-sh">$ <span class="token function">sudo</span> <span class="token function">cat</span> /var/spool/anacron/cron.monthly
<span class="token comment"># 20240104</span>
</code></pre> 
<hr> 
<p>欢迎访问个人网络日志🌹🌹<a href="https://foobarweb.net/" rel="nofollow">知行空间</a>🌹🌹</p> 
<hr> 
<h4><a id="reference_417"></a>reference</h4> 
<blockquote> 
 <p>1.<a href="" rel="nofollow">《Linux命令行与shell脚本编程大全》</a></p> 
</blockquote> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f0c18426756230e34c38e1f0312e0498/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ubuntu常用命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4ac7ecf10244f5ba6b6071d39e1ed4ce/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">程序猿的时间管理和生产力</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>