<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>js 函数防抖（debounce）函数节流（throttle） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="js 函数防抖（debounce）函数节流（throttle）" />
<meta property="og:description" content="一、什么是函数节流（throttle） 概念：限制一个函数在一定时间内只能执行一次。
举个栗子，坐火车或地铁，过安检的时候，在一定时间（例如10秒）内，只允许一个乘客通过安检入口，以配合安检人员完成安检工作。上例中，每10秒内，仅允许一位乘客通过，分析可知，“函数节流”的要点在于，在 一定时间 之内，限制 一个动作 只 执行一次 。 上图中绿色块表示触发一次事件，持续触发事件时，throttle会合并一定时间内的事件，并在该时间结束时真正去触发一次事件
二、为什么需要函数节流 前端开发过程中，有一些事件或者函数，会被频繁地触发（短时间按内多次触发），最常见的例如，onresize，scroll，mousemove ,mousehover 等，这些事件的触发频率很高，不做限制的话，有可能一秒之内执行几十次、几百次，如果在这些函数内部执行了其他函数，尤其是执行了操作 DOM 的函数（浏览器操作 DOM 是很耗费性能的），那不仅会造成计算机资源的浪费，还会降低程序运行速度，甚至造成浏览器卡死、崩溃。这种问题显然是致命的。
除此之外，重复的 ajax 调用不仅可能会造成请求数据的混乱，还会造成网络拥塞，占用服务器带宽，增加服务器压力，显然这个问题也是需要解决的。 三、函数节流如何解决上述问题 根据上面对问题的分析，细细思索，问题的解决方案就呼之欲出了。
主要实现思路就是通过 setTimeout 定时器，通过设置延时时间，在第一次调用时，创建定时器，先设定一个变量true，写入需要执行的函数。第二次执行这个函数时，会判断变量是否true，是则返回。当第一次的定时器执行完函数最后会设定变量为false。那么下次判断变量时则为false，函数会依次运行。目的在于在一定的时间内，保证多次函数的请求只执行最后一次调用。 四、函数节流的代码实现 根据以上分析，我们对“函数节流”进行代码实现，如下：
（1）方法一：时间戳方案
// 时间戳方案 function throttle(fn,wait){ var pre = Date.now(); return function(){ var context = this; var args = arguments; var now = Date.now(); if( now - pre &gt;= wait){ fn.apply(context,args); pre = Date.now(); } } } function handle(){ console.log(Math.random()); } window.addEventListener(&#34;mousemove&#34;,throttle(handle,1000)); （2）方法二：定时器方案" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/bbb2cd2e3003e9182ee51af623b8f20a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-01T11:15:34+08:00" />
<meta property="article:modified_time" content="2021-07-01T11:15:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">js 函数防抖（debounce）函数节流（throttle）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4><strong>一、什么是函数节流（throttle）</strong></h4> 
<p><strong>概念</strong>：限制一个函数在一定时间内只能执行一次。</p> 
<blockquote>
  举个栗子，坐火车或地铁，过安检的时候，在一定时间（例如10秒）内，只允许一个乘客通过安检入口，以配合安检人员完成安检工作。上例中，每10秒内，仅允许一位乘客通过，分析可知，“函数节流”的要点在于，在  
 <strong>一定时间</strong> 之内，限制  
 <strong>一个动作</strong> 只  
 <strong>执行一次</strong> 。 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/40/c4/86LLY9vu_o.png"></p> 
<p> 上图中绿色块表示触发一次事件，持续触发事件时，<strong>throttle</strong>会合并一定时间内的事件，并在该时间结束时真正去触发一次事件</p> 
<h4><strong>二、为什么需要函数节流</strong></h4> 
<p>　　前端开发过程中，有一些事件或者函数，会被频繁地触发（短时间按内多次触发），最常见的例如，<strong>onresize</strong>，<strong>scroll</strong>，<strong>mousemove</strong> ,<strong>mousehover</strong> 等，这些事件的触发频率很高，不做限制的话，有可能一秒之内执行几十次、几百次，如果在这些函数内部执行了其他函数，尤其是执行了操作 DOM 的函数（浏览器操作 DOM 是很耗费性能的），那不仅会造成计算机资源的浪费，还会降低程序运行速度，甚至造成浏览器卡死、崩溃。这种问题显然是致命的。</p> 
<blockquote>
  除此之外，重复的 ajax 调用不仅可能会造成请求数据的混乱，还会造成网络拥塞，占用服务器带宽，增加服务器压力，显然这个问题也是需要解决的。 
</blockquote> 
<h4><strong>三、函数节流如何解决上述问题</strong></h4> 
<p>根据上面对问题的分析，细细思索，问题的解决方案就呼之欲出了。</p> 
<blockquote>
  主要实现思路就是通过  
 <strong>setTimeout</strong> 定时器，通过设置延时时间，在第一次调用时，创建定时器，先设定一个变量true，写入需要执行的函数。第二次执行这个函数时，会判断变量是否true，是则返回。当第一次的定时器执行完函数最后会设定变量为false。那么下次判断变量时则为false，函数会依次运行。目的在于在一定的时间内，保证多次函数的请求只执行最后一次调用。 
</blockquote> 
<h4><strong>四、函数节流的代码实现</strong></h4> 
<p>根据以上分析，我们对“函数节流”进行代码实现，如下：</p> 
<p>（1）<strong>方法一：时间戳方案</strong></p> 
<pre><code>// 时间戳方案
function throttle(fn,wait){
    var pre = Date.now();
    return function(){
        var context = this;
        var args = arguments;
        var now = Date.now();
        if( now - pre &gt;= wait){
            fn.apply(context,args);
            pre = Date.now();
        }
    }
}

function handle(){
    console.log(Math.random());
}
    
window.addEventListener("mousemove",throttle(handle,1000));</code></pre> 
<p>（2）<strong>方法二：定时器方案</strong></p> 
<pre><code>// 定时器方案
function throttle(fn,wait){
    var timer = null;
    return function(){
        var context = this;
        var args = arguments;
        if(!timer){
            timer = setTimeout(function(){
                fn.apply(context,args);
                timer = null;
            },wait)
        }
    }
}
    
function handle(){
    console.log(Math.random());
}
    
window.addEventListener("mousemove",throttle(handle,1000));</code></pre> 
<blockquote>
  以上两种方法本人都亲自测试过，小伙伴们可以放心食用（注意，例子中函数触发方式为“ mousemove ”，鼠标在页面上移动，观察浏览器控制台的变化），自己运行代码体验后，自然会更深刻的理解 “函数节流” 。 
</blockquote> 
<pre><code class="language-javascript">function throttle(fn, delay) {
  var ctx;
  var args;
  // 记录上次触发事件
  var previous = Date.now();

  var later = function () {
    fn.apply(ctx, args);
  };

  return function () {
    ctx = this;
    args = arguments;
    var now = Date.now();
    // 本次事件触发与上一次的时间比较
    var diff = now - previous - delay;

    // 如果隔间时间超过设定时间，即再次设置事件触发的定时器
    if (diff &gt;= 0) {
      // 更新最近事件触发的时间
      previous = now;
      setTimeout(later, delay);
    }
  };
}</code></pre> 
<p><img alt="" src="https://images2.imgbox.com/83/d8/NzJHqBiE_o.gif"></p> 
<p></p> 
<h4><strong>五、函数节流的使用场景</strong></h4> 
<p>到此为止，相信各位应该对函数节流有了一个比较详细的了解，那函数节流一般用在什么情况之下呢？</p> 
<ol><li>懒加载、滚动加载、加载更多或监听滚动条位置；</li><li>百度搜索框，搜索联想功能；</li><li>防止高频点击提交，防止表单重复提交；</li></ol> 
<p>目前遇到过的使用场景就是这些了，不过理解了原理，小伙伴可以把它运用在需要用到它的任何场合，提高代码质量。</p> 
<h4><strong>总结</strong></h4> 
<p>使用“函数节流”的主要目的，是为了优化程序性能，提高用户体验，不过最主要的为了节约计算机资源，推荐在合适的场合使用它，才能达到它应有的效果，切忌滥用哦！</p> 
<p><a href="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000019577510" rel="nofollow">转载自：​segmentfault.com</a></p> 
<p></p> 
<h3><strong>JS中的函数防抖</strong></h3> 
<h4><strong>一、什么是函数防抖</strong></h4> 
<p><strong>概念</strong>：函数防抖（debounce），就是指触发事件后，在 n 秒内函数只能执行一次，如果触发事件后在 n 秒内又触发了事件，则会重新计算函数延执行时间。</p> 
<blockquote>
  举个栗子，坐电梯的时候，如果电梯检测到有人进来（触发事件），就会多等待 10 秒，此时如果又有人进来（10秒之内重复触发事件），那么电梯就会再多等待 10 秒。在上述例子中，电梯在检测到有人进入 10 秒钟之后，才会关闭电梯门开始运行，因此，“函数防抖”的关键在于，在  
 <strong>一个事件</strong> 发生  
 <strong>一定时间</strong> 之后，才执行  
 <strong>特定动作</strong>。 
</blockquote> 
<p> <img alt="" src="https://images2.imgbox.com/e3/24/xzUvZIRK_o.png"></p> 
<h4><strong>二、为什么需要函数防抖</strong></h4> 
<p>　　前端开发过程中，有一些事件，常见的例如，<strong>onresize</strong>，<strong>scroll</strong>，<strong>mousemove</strong> ,<strong>mousehover</strong> 等，会被频繁触发（短时间内多次触发），不做限制的话，有可能一秒之内执行几十次、几百次，如果在这些函数内部执行了其他函数，尤其是执行了操作 DOM 的函数（浏览器操作 DOM 是很耗费性能的），那不仅会浪费计算机资源，还会降低程序运行速度，甚至造成浏览器卡死、崩溃。这种问题显然是致命的。</p> 
<blockquote>
  除此之外，短时间内重复的 ajax 调用不仅会造成数据关系的混乱，还会造成网络拥塞，增加服务器压力，显然这个问题也是需要解决的。 
</blockquote> 
<h4><strong>三、函数防抖如何解决上述问题</strong></h4> 
<p>根据上面对问题的分析，细细思索，可以想到如下解决方案。</p> 
<blockquote>
  函数防抖的要点，是需要一个  
 <strong>setTimeout</strong> 来辅助实现，延迟运行需要执行的代码。如果方法多次触发，则把上次记录的延迟执行代码用  
 <strong>clearTimeout</strong> 清掉，重新开始计时。若计时期间事件没有被重新触发，等延迟时间计时完毕，则执行目标代码。 
</blockquote> 
<h4><strong>四、函数防抖的代码实现</strong></h4> 
<p>根据以上分析，我们对 “函数防抖” 来进行简单的代码实现，如下：</p> 
<pre><code>function debounce(fn,wait){
    var timer = null;
    return function(){
        if(timer !== null){
            clearTimeout(timer);
        }
        timer = setTimeout(fn,wait);
    }
}
    
function handle(){
    console.log(Math.random());
}
    
window.addEventListener("resize",debounce(handle,1000));</code></pre> 
<blockquote>
  以上代码本人亲测有效，小伙伴们可放心食用（注意，函数触发方式为 “resize”，改变窗口大小，观察浏览器控制台的变化）。 
</blockquote> 
<pre><code class="language-javascript">function debounce(fn, delay) {
  var ctx;
  var args;
  var timer = null;

  var later = function () {
    fn.apply(ctx, args);
    // 当事件真正执行后，清空定时器
    timer = null;
  };

  return function () {
    ctx = this;
    args = arguments;
    // 当持续触发事件时，若发现事件触发的定时器已设置时，则清除之前的定时器
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }

    // 重新设置事件触发的定时器
    timer = setTimeout(later, delay);
  };
}</code></pre> 
<p><img alt="" src="https://images2.imgbox.com/ab/6b/5BmcxWhu_o.gif"></p> 
<p>例子：</p> 
<pre><code class="language-html">/**
 * 防反跳。fn函数在最后一次调用时刻的delay毫秒之后执行！
 * @param fn 执行函数
 * @param delay 时间间隔
 * @param isImmediate 为true，debounce会在delay时间间隔的开始时立即调用这个函数
 * @returns {Function}
 */
function debounce(fn, delay, isImmediate) {
  var timer = null;  //初始化timer，作为计时清除依据
  return function() {
    var context = this;  //获取函数所在作用域this
    var args = arguments;  //取得传入参数
    clearTimeout(timer);
    if(isImmediate &amp;&amp; timer === null) {
        //时间间隔外立即执行
        fn.apply(context,args);
      timer = 0;
      return;
    }
    timer = setTimeout(function() {
      fn.apply(context,args);
      timer = null;
    }, delay);
  }
}

/* 方法执行e.g. */
var btn = document.getElementById('btn');
var el = document.getElementById('display');
var init = 0;
btn.addEventListener('click', debounce(function() {
  init++;
  el.innerText = init;
}, 1000,true));</code></pre> 
<p>虽然是事件发生后的一段时间执行事件，但是中间还是会执行一些点击事件</p> 
<p></p> 
<h4><strong>五、函数节流的使用场景</strong></h4> 
<p>函数防抖一般用在什么情况之下呢？一般用在，连续的事件只需触发一次回调的场合。具体有：</p> 
<ol><li>搜索框搜索输入。只需用户最后一次输入完，再发送请求；</li><li>用户名、手机号、邮箱输入验证；</li><li>浏览器窗口大小改变后，只需窗口调整完后，再执行 <strong>resize</strong> 事件中的代码，防止重复渲染。</li></ol> 
<p>目前遇到过的用处就是这些，理解了原理与实现思路，小伙伴可以把它运用在任何需要的场合，提高代码质量。</p> 
<h4><strong>总结</strong></h4> 
<p>函数防抖其实是分为 “立即执行版” 和 “非立即执行版” 的，根据字面意思就可以发现他们的差别，所谓立即执行版就是 <strong>触发事件后函数不会立即执行，而是在 n 秒后执行，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。</strong> 而 “非立即执行版” 指的是 <strong>触发事件后函数会立即执行，然后 n 秒内不触发事件才能继续执行函数的效果。</strong>。</p> 
<p>在开发过程中，我们需要根据不同的场景来决定我们需要使用哪一个版本的防抖函数，一般来讲上述的防抖函数都能满足大部分的场景需求。但我们也可以将非立即执行版和立即执行版的防抖函数结合起来，实现最终的双剑合璧版本的防抖函数，以下为小伙伴们做了简单的实现：</p> 
<pre><code>/**
 * @desc  函数防抖---“立即执行版本” 和 “非立即执行版本” 的组合版本
 * @param  func 需要执行的函数
 * @param  wait 延迟执行时间（毫秒）
 * @param  immediate---true 表立即执行，false 表非立即执行
 **/
function debounce(func,wait,immediate) {
    let timer;

    return function () {
        let context = this;
        let args = arguments;

        if (timer) clearTimeout(timer);
        if (immediate) {
            var callNow = !timer;
            timer = setTimeout(() =&gt; {
                timer = null;
            }, wait)
            if (callNow) func.apply(context, args)
        } else {
            timer = setTimeout(function(){
                func.apply(context, args)
            }, wait);
        }
    }</code></pre> 
<p><a href="https://link.zhihu.com/?target=https%3A//segmentfault.com/a/1190000019591549" rel="nofollow">转载：​segmentfault.com</a></p> 
<p>reference:</p> 
<p><a href="https://segmentfault.com/a/1190000005926579" rel="nofollow">https://segmentfault.com/a/1190000005926579</a></p> 
<p></p> 
<p>其他实现：</p> 
<h3 id="b-附lodash实现">Lodash Underscore</h3> 
<p><a href="https://blog.csdn.net/tedsz1025/article/details/80527416">https://blog.csdn.net/tedsz1025/article/details/80527416</a></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aef009e886afc34c23824533895368c1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Wireshark 的使用以及网络包分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6730d305575259ef92dec4b130a6024a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Halcon 在 C# WPF中的用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>