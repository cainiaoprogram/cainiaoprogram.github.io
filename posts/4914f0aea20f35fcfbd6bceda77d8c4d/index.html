<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Mybatis二级缓存详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Mybatis二级缓存详解" />
<meta property="og:description" content="Mybatis二级缓存 Mybatis相关全览一、简介二、一级缓存1.入口2.演示案例一：案例二： 3.总结 三、二级缓存1.入口2.如何开启二级缓存cache-ref配置cache配置 3.针对某查询禁用二级缓存4.控制二级缓存刷新5.自定义缓存 四、缓存执行顺序案例一：案例二： 五、总结 本文用的是3.5.10版本
源码地址：https://github.com/mybatis/mybatis-3/releases
文档地址：https://mybatis.org/mybatis-3/zh/sqlmap-xml.html
Mybatis相关全览 一. Mybatis源码详解
二. Mybatis二级缓存详解
三. Mybatis三大执行器介绍
四. Mybatis拦截器源码详解
一、简介 我们平时开发中为了减轻数据库的访问压力都会用到缓存，在写少读多的场景下能有效的改善程序性能以及减少数据库的压力，Mybatis的缓存自然也是出于这个目的，在读数据库后将结果放入缓存中，下一次读取缓存命中了就直接返回不需要再读库了，在修改操作的时候清空掉缓存
什么是二级缓存？
顾名思义就是有两层缓存，缓存的范围不一样：
一级缓存是针对SqlSession，可以理解为是一个连接（同一个数据库连接下执行的查询共用一块缓存）二级缓存是针对namespace，也就是一个Mapper.xml文件，一个文件内的查询共用一块缓存，多个namespace缓存之间相互不受影响 一级缓存默认开启，二级缓存默认是关闭的
为什么要搞二级缓存？
从上述可以明显的看到二级缓存是对一级缓存的一个优化，毕竟一个连接的作用域有啥用，连接用完就关了，缓存时效性太差，而采用二级缓存后缓存能在多个连接之间共享，这命中率不大大提升
为什么不采用全局缓存？
虽然全局缓存在命中率方面比二级缓存更有优势，但是数据库有那么多的表，假设我已经缓存很多查询了，就因为你某个表要修改，就全删除吗？这合理吗？那是不是只需要删除跟这个被修改的表有关的缓存数据就可以了，仔细想想这不就是二级缓存？平时开发习惯一个namespace不就是针对一个表的？
二、一级缓存 1.入口 既然是跟查询有关那肯定是在执行器里面，所以是在最底层的BaseExecutor里面
BaseExecutor.query
这个localCache就是一级缓存，针对SqlSession所做的缓存
一级缓存的缓存类是PerpetualCache(也就是上述的localCache)，如下：
内部有一个HashMap来存储结果
2.演示 我们先在上述缓存前后加上一些输出来观察缓存的变化：
案例一： 我们在同一个SqlSession整两个一样的查询，并用分隔符分开，执行查看结果
结果：
看分割线上是第一次查询，所以开始缓存数量为0，之后缓存数量为1，并缓存了一条数据，第二次查询直接就命中了缓存并返回了结果
案例二： 我们两个查询分别用了不同的SqlSession，再看看结果
结果：
两次查询的缓存是相互隔离的
3.总结 由此可见，一级缓存仅在SqlSession中，不同的SqlSession缓存是互不干扰的，所以效果微乎及微
什么时候删除？
同样在BaseExecutor中做新增、修改、删除操作的时候就会清空当前SqlSession中的缓存，如：
三、二级缓存 1.入口 与上述一样，一样是在执行器里面，但是这个执行器有点特殊，专门用来做二级缓存用的，那就是CachingExecutor.query
而且这个执行器在默认情况下一定会走，因为在开始选择执行器的时候判断了，默认的参数为true
如下：
既然一定会走，为什么又说二级缓存默认关闭呢？
在上述执行过程中可以看到，会先从MapperStatement中获取一个Cache对象，该对象不为空才会走缓存，该对象为null ，就会走数据库查询了，所以在二级缓存没开启的情况下是获取不到这个对象的，所以自然会走数据库了
2.如何开启二级缓存 在我们解析的过程中可以发现有个关于cache的配置加载，这两个是干嘛的？
cache-ref配置 我们之前说过二级缓存的作用域是namespace，每个namespace之间是独立的，但有的时候我就是想共享怎么办？总不能全写到一个namespace中吧，所以cache-ref的作用就是可以指定和某个namespace共享缓存
&lt;cache-ref namespace=&#34;com.xxxx.xxxx.XxxxxMapper&#34;/&gt; cache配置 既然二级缓存在每个namespace之间是独立的，所以每个namespace是可以独立选择开启或者关闭的，开关就是cache配置，同时还附带有几种属性可以来配置缓存，如下：
&lt;cache eviction=&#34;LRU&#34; flushInterval=&#34;60000&#34; size=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4914f0aea20f35fcfbd6bceda77d8c4d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-17T22:41:05+08:00" />
<meta property="article:modified_time" content="2022-11-17T22:41:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Mybatis二级缓存详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Mybatis二级缓存</h4> 
 <ul><li><a href="#Mybatis_5" rel="nofollow">Mybatis相关全览</a></li><li><a href="#_11" rel="nofollow">一、简介</a></li><li><a href="#_32" rel="nofollow">二、一级缓存</a></li><li><ul><li><a href="#1_34" rel="nofollow">1.入口</a></li><li><a href="#2_52" rel="nofollow">2.演示</a></li><li><ul><li><a href="#_59" rel="nofollow">案例一：</a></li><li><a href="#_73" rel="nofollow">案例二：</a></li></ul> 
   </li><li><a href="#3_87" rel="nofollow">3.总结</a></li></ul> 
  </li><li><a href="#_98" rel="nofollow">三、二级缓存</a></li><li><ul><li><a href="#1_100" rel="nofollow">1.入口</a></li><li><a href="#2_118" rel="nofollow">2.如何开启二级缓存</a></li><li><ul><li><a href="#cacheref_125" rel="nofollow">cache-ref配置</a></li><li><a href="#cache_133" rel="nofollow">cache配置</a></li></ul> 
   </li><li><a href="#3_156" rel="nofollow">3.针对某查询禁用二级缓存</a></li><li><a href="#4_169" rel="nofollow">4.控制二级缓存刷新</a></li><li><a href="#5_181" rel="nofollow">5.自定义缓存</a></li></ul> 
  </li><li><a href="#_189" rel="nofollow">四、缓存执行顺序</a></li><li><ul><li><a href="#_195" rel="nofollow">案例一：</a></li><li><a href="#_212" rel="nofollow">案例二：</a></li></ul> 
  </li><li><a href="#_230" rel="nofollow">五、总结</a></li></ul> 
</div> 
<p></p> 
<blockquote> 
 <p>本文用的是3.5.10版本<br> 源码地址：<a href="https://github.com/mybatis/mybatis-3/releases">https://github.com/mybatis/mybatis-3/releases</a><br> 文档地址：<a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html" rel="nofollow">https://mybatis.org/mybatis-3/zh/sqlmap-xml.html</a></p> 
</blockquote> 
<h2><a id="Mybatis_5"></a>Mybatis相关全览</h2> 
<p>一. <a href="https://blog.csdn.net/weixin_44102992/article/details/127893787?spm=1001.2014.3001.5501">Mybatis源码详解</a><br> 二. <a href="https://blog.csdn.net/weixin_44102992/article/details/127913052?spm=1001.2014.3001.5501">Mybatis二级缓存详解</a><br> 三. <a href="https://blog.csdn.net/weixin_44102992/article/details/127913263?spm=1001.2014.3001.5501">Mybatis三大执行器介绍</a><br> 四. <a href="https://blog.csdn.net/weixin_44102992/article/details/127913360?csdn_share_tail=%7B%22type%22%3A%22blog%22%2C%22rType%22%3A%22article%22%2C%22rId%22%3A%22127913360%22%2C%22source%22%3A%22weixin_44102992%22%7D">Mybatis拦截器源码详解</a></p> 
<h2><a id="_11"></a>一、简介</h2> 
<blockquote> 
 <p>我们平时开发中为了减轻数据库的访问压力都会用到缓存，在写少读多的场景下能有效的改善程序性能以及减少数据库的压力，Mybatis的缓存自然也是出于这个目的，在读数据库后将结果放入缓存中，下一次读取缓存命中了就直接返回不需要再读库了，在修改操作的时候清空掉缓存</p> 
</blockquote> 
<p><strong>什么是二级缓存？</strong></p> 
<p>顾名思义就是有两层缓存，缓存的范围不一样：</p> 
<ul><li>一级缓存是针对SqlSession，可以理解为是一个连接（同一个数据库连接下执行的查询共用一块缓存）</li><li>二级缓存是针对namespace，也就是一个Mapper.xml文件，一个文件内的查询共用一块缓存，多个namespace缓存之间相互不受影响</li></ul> 
<p>一级缓存默认开启，二级缓存默认是关闭的</p> 
<p><strong>为什么要搞二级缓存？</strong></p> 
<blockquote> 
 <p>从上述可以明显的看到二级缓存是对一级缓存的一个优化，毕竟一个连接的作用域有啥用，连接用完就关了，缓存时效性太差，而采用二级缓存后缓存能在多个连接之间共享，这命中率不大大提升</p> 
</blockquote> 
<p><strong>为什么不采用全局缓存？</strong></p> 
<blockquote> 
 <p>虽然全局缓存在命中率方面比二级缓存更有优势，但是数据库有那么多的表，假设我已经缓存很多查询了，就因为你某个表要修改，就全删除吗？这合理吗？那是不是只需要删除跟这个被修改的表有关的缓存数据就可以了，仔细想想这不就是二级缓存？平时开发习惯一个namespace不就是针对一个表的？</p> 
</blockquote> 
<h2><a id="_32"></a>二、一级缓存</h2> 
<h3><a id="1_34"></a>1.入口</h3> 
<p>既然是跟查询有关那肯定是在执行器里面，所以是在最底层的<strong>BaseExecutor</strong>里面</p> 
<p><strong>BaseExecutor.query</strong></p> 
<blockquote> 
 <p>这个localCache就是一级缓存，针对SqlSession所做的缓存</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/31/cc/zOHj5azO_o.png" alt="在这里插入图片描述"></p> 
<p>一级缓存的缓存类是<strong>PerpetualCache</strong>(也就是上述的localCache)，如下：</p> 
<blockquote> 
 <p>内部有一个HashMap来存储结果</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/8f/c5/qyqHp1MC_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2_52"></a>2.演示</h3> 
<p>我们先在上述缓存前后加上一些输出来观察缓存的变化：</p> 
<p><img src="https://images2.imgbox.com/0f/69/kuZWAdL4_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_59"></a>案例一：</h4> 
<p>我们在同一个SqlSession整两个一样的查询，并用分隔符分开，执行查看结果</p> 
<p><img src="https://images2.imgbox.com/85/de/79lOZrem_o.png" alt="在这里插入图片描述"></p> 
<p><strong>结果：</strong></p> 
<p>看分割线上是第一次查询，所以开始缓存数量为0，之后缓存数量为1，并缓存了一条数据，第二次查询直接就命中了缓存并返回了结果</p> 
<p><img src="https://images2.imgbox.com/b8/11/oJvJANv7_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_73"></a>案例二：</h4> 
<p>我们两个查询分别用了不同的SqlSession，再看看结果</p> 
<p><img src="https://images2.imgbox.com/77/9a/R3qzzDv0_o.png" alt="在这里插入图片描述"></p> 
<p><strong>结果：</strong></p> 
<p>两次查询的缓存是相互隔离的</p> 
<p><img src="https://images2.imgbox.com/3f/09/qjTbgy2f_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3_87"></a>3.总结</h3> 
<p>由此可见，一级缓存仅在SqlSession中，不同的SqlSession缓存是互不干扰的，所以效果微乎及微</p> 
<p><strong>什么时候删除？</strong></p> 
<p>同样在<strong>BaseExecutor</strong>中做新增、修改、删除操作的时候就会清空当前SqlSession中的缓存，如：</p> 
<p><img src="https://images2.imgbox.com/40/41/1pQ1T6mw_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_98"></a>三、二级缓存</h2> 
<h3><a id="1_100"></a>1.入口</h3> 
<p>与上述一样，一样是在执行器里面，但是这个执行器有点特殊，专门用来做二级缓存用的，那就是<strong>CachingExecutor.query</strong></p> 
<p><img src="https://images2.imgbox.com/61/0c/UEzas9Qi_o.png" alt="在这里插入图片描述"></p> 
<p><strong>而且这个执行器在默认情况下一定会走，因为在开始选择执行器的时候判断了，默认的参数为true</strong></p> 
<p><strong>如下：</strong></p> 
<p><img src="https://images2.imgbox.com/bc/2f/KL9q21cq_o.png" alt="在这里插入图片描述"></p> 
<p><strong>既然一定会走，为什么又说二级缓存默认关闭呢？</strong></p> 
<blockquote> 
 <p>在上述执行过程中可以看到，会先从MapperStatement中获取一个Cache对象，该对象不为空才会走缓存，该对象为null ，就会走数据库查询了，所以在二级缓存没开启的情况下是获取不到这个对象的，所以自然会走数据库了</p> 
</blockquote> 
<h3><a id="2_118"></a>2.如何开启二级缓存</h3> 
<p>在我们解析的过程中可以发现有个关于cache的配置加载，这两个是干嘛的？</p> 
<p><img src="https://images2.imgbox.com/e3/2e/RLOqj2Av_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="cacheref_125"></a>cache-ref配置</h4> 
<p>我们之前说过二级缓存的作用域是namespace，每个namespace之间是独立的，但有的时候我就是想共享怎么办？总不能全写到一个namespace中吧，所以cache-ref的作用就是可以指定和某个namespace共享缓存</p> 
<pre><code class="prism language-Java">&lt;cache-ref namespace="com.xxxx.xxxx.XxxxxMapper"/&gt;
</code></pre> 
<h4><a id="cache_133"></a>cache配置</h4> 
<p>既然二级缓存在每个namespace之间是独立的，所以每个namespace是可以独立选择开启或者关闭的，开关就是cache配置，同时还附带有几种属性可以来配置缓存，如下：</p> 
<pre><code class="prism language-Java">&lt;cache
 eviction="LRU"
 flushInterval="60000"
 size="1024"
 readOnly="true"/&gt;
</code></pre> 
<p><strong>cache标签</strong>代表为这个namespace开启二级缓存。其他属性分别有其作用，可自由组合配置：</p> 
<ul><li><strong>eviction：</strong> 缓存清除策略，有以下几种，默认是LRU 
  <ol><li>LRU – 最近最少使用：移除最长时间不被使用的对象。</li><li>FIFO – 先进先出：按对象进入缓存的顺序来移除它们。</li><li>SOFT – 软引用：基于垃圾回收器状态和软引用规则移除对象。</li><li>WEAK – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</li></ol> </li><li><strong>flushInterval：</strong> 刷新间隔，以毫秒为单位，时间到了就会在调用语句的时候清空缓存。默认不刷新</li><li><strong>size：</strong> 缓存的数量（默认1024）</li><li><strong>readOnly：</strong> 只能设置成true或者false。true的情况下缓存返回的数据对象不能被修改，false的情况下会返回缓存对象的拷贝。默认值是false</li></ul> 
<h3><a id="3_156"></a>3.针对某查询禁用二级缓存</h3> 
<p>开启二级缓存后，namespace下的查询语句默认都会缓存，要是某个查询我不想缓存呢？</p> 
<p><strong>可以设置该查询useCache属性为false，默认是true</strong></p> 
<pre><code class="prism language-Java">&lt;select id="findUserById" ...... useCache="false"&gt;
    SELECT * FROM user WHERE id = #{id}
&lt;/select&gt;

</code></pre> 
<h3><a id="4_169"></a>4.控制二级缓存刷新</h3> 
<p>在不设置缓存刷新时间，默认情况下查询不会刷新缓存，新增、删除、更新都是刷新缓存</p> 
<p><strong>可以设置flushCache属性，true是刷新缓存，false是不刷新缓存</strong></p> 
<pre><code class="prism language-Java">&lt;select id="findUserById" ...... flushCache="true"&gt;
    SELECT * FROM user WHERE id = #{id}
&lt;/select&gt;
</code></pre> 
<h3><a id="5_181"></a>5.自定义缓存</h3> 
<p>我们所使用的缓存都是某个缓存类，我也可以自定义实现自己的一个缓存类，或者采用第三方的缓存方案，要实现我们自己的缓存类，我们只需要实现org.apache.ibatis.cache.Cache 接口，且提供一个接受 String 参数作为 id 的构造器，并在cache标签中指定自己的缓存类，如下：</p> 
<pre><code class="prism language-Java">&lt;cache type="com.xxxx.xxxx.MyCache"/&gt;
</code></pre> 
<h2><a id="_189"></a>四、缓存执行顺序</h2> 
<p>同样的我们在二级缓存处也做一些输出处理<br> <img src="https://images2.imgbox.com/99/59/7ZYfhtxM_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_195"></a>案例一：</h3> 
<p>我们在一个SqlSession中放了三个一样的查询</p> 
<p><img src="https://images2.imgbox.com/d2/f1/f8GRebiM_o.png" alt="在这里插入图片描述"></p> 
<p><strong>结果：</strong></p> 
<p>执行顺序是先二级再一级没错，但是你会发现之后的查询依旧没走二级缓存而是走了一级缓存，表示二级缓存中没查到<br> <img src="https://images2.imgbox.com/10/9e/W16uzeG2_o.png" alt="在这里插入图片描述"></p> 
<p><strong>为啥会这样？不是都放进缓存了吗？</strong></p> 
<p>二级缓存不是有结果后立刻存储的，而是在事务commit之后才会存储，所以查不到</p> 
<h3><a id="_212"></a>案例二：</h3> 
<p>与上面相反用了两个SqlSession</p> 
<p><img src="https://images2.imgbox.com/7e/14/TmJ26Htb_o.png" alt="在这里插入图片描述"></p> 
<p><strong>结果：</strong></p> 
<p>很明显第二个查询走了二级缓存，这也正好印证了上面我们说的</p> 
<p><img src="https://images2.imgbox.com/79/67/KeQufgxR_o.png" alt="在这里插入图片描述"></p> 
<p><strong>缓存执行顺序：</strong></p> 
<p>二级缓存→一级缓存→数据库</p> 
<h2><a id="_230"></a>五、总结</h2> 
<ul><li>一级缓存在BaseExecutor中，作用域是SqlSession</li><li>二级缓存在CachingExecutor中，作用域是namespace</li><li>两者都会在修改操作时删除缓存，事务回滚时清除缓存</li><li>执行顺序为：二级缓存→一级缓存→数据库</li><li>一级缓存默认开启，二级缓存默认关闭</li></ul> 
<p>缓存虽好，但也有利有弊，有什么坏处？</p> 
<blockquote> 
 <p>一级缓存我们可能平时不会在意，反正即用即删了，但二级缓存一旦开启就得注意了，因为namespace之间是独立的，然后平时使用多服务下，服务之间又是独立的，用不好就会导致数据不一致，建议慎用！</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fe8da322641ccb3dd5ba9578a0844c17/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ajax调用文件下载接口出现跨域问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/64447f2a9b98151ba730917e1407a248/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">OpenCV中图像的运算</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>