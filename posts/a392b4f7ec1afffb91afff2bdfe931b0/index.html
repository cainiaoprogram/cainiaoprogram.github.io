<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【深入理解计算机系统 第三版 导读】第三章 程序的机器级表示 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【深入理解计算机系统 第三版 导读】第三章 程序的机器级表示" />
<meta property="og:description" content="第三章 程序的机器级表示 文章目录 第三章 程序的机器级表示1. 程序编码1.1. 编码过程1.2. 不同级别优化1.3. 寄存器的基本知识1.4. 简单的汇编代码1.5. 反汇编 2. 数据格式3. 信息访问3.1. 操作数指示符3.3. 代码中的操作数3.4. 数据传输指令3.5. 数据传输扩展示例3.6. 前面的补充一下3.6.1. 对于movq和movabsq3.6.2. 指令mov后缀3.6.3. movl 3.7. 数据传输扩展3.8. 数据传输在C与汇编间的转换 4. 栈与数据传送指令4.1. 压入弹出栈数据 5. 算术与逻辑操作5.1. 加载有效地址及示例5.2. 一元操作和二元操作5.3. 二元操作示例5.4. 移位操作5.5. 移位操作示例5.6. 算数运算函数转换示例5.7. 特殊算术操作 6. 条件码6.1. 条件码6.2. 条件码例子6.3. 访问条件码6.4. 访问条件码例子 7. 控制7.1. 无条件跳转7.2. 条件跳转7.3. 条件控制例题7.4. 跳转指令的编码7.5. 条件传送实现分支7.6. 条件传送例题7.7. while循环7.8. for循环7.9. switch语句 8. 过程8.1. 通过栈来传递参数8.2. 运行时栈8.3. 引用的案例8.4. 调用者保存和被调用者保存8.5. 递归调用 9. 数组9.1. 数组示例9.2. 多维数组9.3. 定长数组9.4. 变长数组 10. 异质的数据结构10.1. 结构体及其访问10." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a392b4f7ec1afffb91afff2bdfe931b0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-09T22:08:02+08:00" />
<meta property="article:modified_time" content="2024-01-09T22:08:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【深入理解计算机系统 第三版 导读】第三章 程序的机器级表示</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="__0"></a>第三章 程序的机器级表示</h2> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#__0" rel="nofollow">第三章 程序的机器级表示</a></li><li><ul><li><a href="#1__4" rel="nofollow">1. 程序编码</a></li><li><ul><li><a href="#11__6" rel="nofollow">1.1. 编码过程</a></li><li><a href="#12__20" rel="nofollow">1.2. 不同级别优化</a></li><li><a href="#13__32" rel="nofollow">1.3. 寄存器的基本知识</a></li><li><a href="#14__51" rel="nofollow">1.4. 简单的汇编代码</a></li><li><a href="#15__81" rel="nofollow">1.5. 反汇编</a></li></ul> 
   </li><li><a href="#2__88" rel="nofollow">2. 数据格式</a></li><li><a href="#3__108" rel="nofollow">3. 信息访问</a></li><li><ul><li><a href="#31__119" rel="nofollow">3.1. 操作数指示符</a></li><li><a href="#33__148" rel="nofollow">3.3. 代码中的操作数</a></li><li><a href="#34__155" rel="nofollow">3.4. 数据传输指令</a></li><li><a href="#35__183" rel="nofollow">3.5. 数据传输扩展示例</a></li><li><a href="#36__204" rel="nofollow">3.6. 前面的补充一下</a></li><li><ul><li><a href="#361_movqmovabsq_206" rel="nofollow">3.6.1. 对于movq和movabsq</a></li><li><a href="#362_mov_214" rel="nofollow">3.6.2. 指令mov后缀</a></li><li><a href="#363_movl_218" rel="nofollow">3.6.3. movl</a></li></ul> 
    </li><li><a href="#37__222" rel="nofollow">3.7. 数据传输扩展</a></li><li><a href="#38_C_230" rel="nofollow">3.8. 数据传输在C与汇编间的转换</a></li></ul> 
   </li><li><a href="#4__250" rel="nofollow">4. 栈与数据传送指令</a></li><li><ul><li><a href="#41__252" rel="nofollow">4.1. 压入弹出栈数据</a></li></ul> 
   </li><li><a href="#5__289" rel="nofollow">5. 算术与逻辑操作</a></li><li><ul><li><a href="#51__291" rel="nofollow">5.1. 加载有效地址及示例</a></li><li><a href="#52__310" rel="nofollow">5.2. 一元操作和二元操作</a></li><li><a href="#53__318" rel="nofollow">5.3. 二元操作示例</a></li><li><a href="#54__327" rel="nofollow">5.4. 移位操作</a></li><li><a href="#55__336" rel="nofollow">5.5. 移位操作示例</a></li><li><a href="#56__348" rel="nofollow">5.6. 算数运算函数转换示例</a></li><li><a href="#57__354" rel="nofollow">5.7. 特殊算术操作</a></li></ul> 
   </li><li><a href="#6__359" rel="nofollow">6. 条件码</a></li><li><ul><li><a href="#61__361" rel="nofollow">6.1. 条件码</a></li><li><a href="#62__383" rel="nofollow">6.2. 条件码例子</a></li><li><a href="#63__388" rel="nofollow">6.3. 访问条件码</a></li><li><a href="#64__395" rel="nofollow">6.4. 访问条件码例子</a></li></ul> 
   </li><li><a href="#7__403" rel="nofollow">7. 控制</a></li><li><ul><li><a href="#71__405" rel="nofollow">7.1. 无条件跳转</a></li><li><a href="#72__412" rel="nofollow">7.2. 条件跳转</a></li><li><a href="#73__417" rel="nofollow">7.3. 条件控制例题</a></li><li><a href="#74__422" rel="nofollow">7.4. 跳转指令的编码</a></li><li><a href="#75__434" rel="nofollow">7.5. 条件传送实现分支</a></li><li><a href="#76__447" rel="nofollow">7.6. 条件传送例题</a></li><li><a href="#77_while_452" rel="nofollow">7.7. while循环</a></li><li><a href="#78_for_467" rel="nofollow">7.8. for循环</a></li><li><a href="#79_switch_475" rel="nofollow">7.9. switch语句</a></li></ul> 
   </li><li><a href="#8__531" rel="nofollow">8. 过程</a></li><li><ul><li><a href="#81__533" rel="nofollow">8.1. 通过栈来传递参数</a></li><li><a href="#82__545" rel="nofollow">8.2. 运行时栈</a></li><li><a href="#83__565" rel="nofollow">8.3. 引用的案例</a></li><li><a href="#84__572" rel="nofollow">8.4. 调用者保存和被调用者保存</a></li><li><a href="#85__579" rel="nofollow">8.5. 递归调用</a></li></ul> 
   </li><li><a href="#9__585" rel="nofollow">9. 数组</a></li><li><ul><li><a href="#91__587" rel="nofollow">9.1. 数组示例</a></li><li><a href="#92__595" rel="nofollow">9.2. 多维数组</a></li><li><a href="#93__603" rel="nofollow">9.3. 定长数组</a></li><li><a href="#94__644" rel="nofollow">9.4. 变长数组</a></li></ul> 
   </li><li><a href="#10__666" rel="nofollow">10. 异质的数据结构</a></li><li><ul><li><a href="#101__668" rel="nofollow">10.1. 结构体及其访问</a></li><li><a href="#102__674" rel="nofollow">10.2. 数据对齐</a></li></ul> 
   </li><li><a href="#11__679" rel="nofollow">11. 理解指针</a></li><li><a href="#12__686" rel="nofollow">12. 内存越界引用和缓冲区溢出</a></li><li><ul><li><a href="#121__697" rel="nofollow">12.1. 对抗缓冲区溢出攻击</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<br> 本章节为《深入理解计算机系统》第三版的个人导读，参考视频B站up主-九曲阑干，少量图片来自 
<a href="http://t.csdnimg.cn/Ituif" rel="nofollow">深入理解计算机系统03——程序的机器级表示</a> 
<br> 
<a href="http://t.csdnimg.cn/GqdL4" rel="nofollow">【深入理解计算机系统 第三版 导读】第二章 信息的表示和处理</a> 
<p></p> 
<h3><a id="1__4"></a>1. 程序编码</h3> 
<h4><a id="11__6"></a>1.1. 编码过程</h4> 
<p><img src="https://images2.imgbox.com/e1/9c/30v8jf3R_o.png" alt="在这里插入图片描述"></p> 
<ol><li> <p><code>$ gcc -S -o hello.s hello.i</code><br> 这个命令告诉GCC编译器将预处理后的文件（hello.i）编译成汇编代码（hello.s）。<code>-S</code>选项指示编译器停止在汇编阶段，不要进行汇编和链接。<code>-o</code>选项后面跟着的是输出文件的名称。</p> </li><li> <p><code>$ gcc -c -o hello.o hello.s</code><br> 这个命令用于将汇编代码文件（hello.s）编译成目标代码文件（hello.o）。<code>-c</code>选项告诉GCC只进行编译和汇编，不进行链接。输出文件名由<code>-o</code>选项指定。hello.o是无法直接查看的，这里要借助反汇编工具objdump -d hello.o</p> </li><li> <p><code>gcc -o hello hello.o</code><br> 最后这个命令将目标代码文件（hello.o）链接成最终的可执行文件（hello）。没有选项指示编译器停止，所以GCC会完成链接步骤。<code>-o</code>选项后面指定的是最终生成的可执行文件的名称。</p> </li></ol> 
<h4><a id="12__20"></a>1.2. 不同级别优化</h4> 
<table><thead><tr><th>-O参数</th><th>含义</th></tr></thead><tbody><tr><td>-O0</td><td>关闭所有优化选项</td></tr><tr><td>-O1</td><td>基本优化，编译器会生成更快的代码</td></tr><tr><td>-O2</td><td>O1的升级版</td></tr><tr><td>-O3</td><td>目前最高的优化级别，更多的编译时间，更大的二进制文件，占用更大的内存，稍快一点</td></tr><tr><td>-Os</td><td>优化代码大小，当CPU缓存或磁盘空间较小时</td></tr></tbody></table> 
<p>采用高级别的优化会使得代码难以理解。</p> 
<h4><a id="13__32"></a>1.3. 寄存器的基本知识</h4> 
<p>在Intel x86-64的处理器中包含了16个通用目的寄存器（%rax,%rbx,%rcx,%rdi,%r11…），这些寄存器用来存放整数数据和指针，这16个寄存器都是以%r开头的。在了解他们功能之前，先来讲清楚调用者保存寄存器和被调用这保存寄存器，如下由于A调用了B所以A叫做调用者B为被调用者：</p> 
<p><img src="https://images2.imgbox.com/45/cc/cTOWKT4i_o.png" alt="在这里插入图片描述"></p> 
<p>由B中addq可以知道寄存器%rbx被修改了，但是在逻辑上函数A在调用B前后寄存器%rbx应该保持一致，解决这个问题由两个策略，一个是调用者保存，另一个是被调用者保存。</p> 
<p><img src="https://images2.imgbox.com/14/d9/ybMdfEy1_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/cd/c6/xdmyCfBG_o.png" alt="在这里插入图片描述"></p> 
<p>对于具体使用哪一种策略，不同寄存器被定义成不同的策略：<br> <img src="https://images2.imgbox.com/fb/04/HhqwgR39_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="14__51"></a>1.4. 简单的汇编代码</h4> 
<p><img src="https://images2.imgbox.com/be/cf/dojusaTR_o.png" alt="在这里插入图片描述"></p> 
<p>这段C语言代码定义了一个名为 <code>mulstore</code> 的函数，该函数调用另一个名为 <code>mult2</code> 的函数，<code>mult2</code> 函数接收两个 <code>long</code> 类型的参数并返回一个 <code>long</code> 类型的结果。对应的汇编代码段说明了 <code>mulstore</code> 函数的操作。汇编代码的每一步作用如下：</p> 
<ol><li> <p><code>pushq %rbx</code><br> 这条指令将 <code>%rbx</code> 寄存器的值压栈。这是因为 <code>%rbx</code> 是一个被调用者保存寄存器（callee-saved register），函数在使用这个寄存器前需要保存它的原始值，以便在函数返回前能恢复它，保证调用函数的上下文不被更改。</p> </li><li> <p><code>movq %rdx, %rbx</code><br> 将 <code>%rdx</code> 寄存器的值（即 <code>dest</code> 参数，指向要存储结果的地址）移动到 <code>%rbx</code> 寄存器。这样做可能是为了在调用 <code>mult2</code> 之后，能够使用 <code>%rbx</code> 来间接寻址和存储 <code>mult2</code> 的结果。</p> </li><li> <p><code>call mult2</code><br> 调用 <code>mult2</code> 函数。在 x86-64 的调用约定中，调用函数前，第一个和第二个参数分别通过 <code>%rdi</code> 和 <code>%rsi</code> 寄存器传递。在这里，<code>mult2</code> 函数的返回值将会存放在 <code>%rax</code> 寄存器中。</p> </li><li> <p><code>movq %rax, (%rbx)</code><br> 将 <code>%rax</code> 寄存器的值（<code>mult2</code> 函数的返回值）存储到 <code>%rbx</code> 寄存器指向的内存位置（即 <code>*dest</code> 的原始位置）。</p> </li><li> <p><code>popq %rbx</code><br> 将之前压栈的 <code>%rbx</code> 寄存器的值出栈，恢复 <code>%rbx</code> 的原始值。这是函数结束前的清理步骤，保证了 <code>mulstore</code> 函数不会影响 <code>%rbx</code> 寄存器的值。</p> </li><li> <p><code>ret</code><br> 返回指令，用于从函数调用返回。它将从堆栈中弹出返回地址并跳转回调用者的代码。</p> </li></ol> 
<p>关于第一次看到这个会有的疑问：</p> 
<ul><li>为什么函数的参数是rdi、rsi、rdx这样？前六个整数或指针参数按顺序分别通过 <code>%rdi</code>、<code>%rsi</code>、<code>%rdx</code>、<code>%rcx</code>、<code>%r8</code> 和 <code>%r9</code> 寄存器传递。如果有更多的参数，它们将通过堆栈传递。</li><li>为什么返回值是存在rax中？<code>%rax</code> 寄存器通常用来存储函数的返回值。如果函数返回的是整数或指针类型的值，那么这个值会被放置在 <code>%rax</code> 寄存器中以便于调用者可以从这里取得它。</li></ul> 
<h4><a id="15__81"></a>1.5. 反汇编</h4> 
<p>目标代码文件xxx.o是一个二进制文件是无法直接查看的，我们就需要借助反汇编工具objdump，将目标代码文件xxx.o反汇编成xxx.s，得到的结果大致为如下所示，通过对比反汇编得到的汇编代码与汇编器直接产生的汇编代码，我们可以发现一些细小的差异，反汇编代码省略了很多的指令的后缀，但在ret、call指令添加后缀，由于后缀是大小指示符，通常情况下是可以省略的。</p> 
<p><img src="https://images2.imgbox.com/50/79/TGxKRsZ6_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="2__88"></a>2. 数据格式</h3> 
<p>后缀b、w、l、q。</p> 
<p>单位：字节/byte/8bit，字/word/16bit，双字/long word/32bit，四字/quad words/64bits</p> 
<p>注意：这里的“字”不是32位和64位计算机中的“字”，32位计算机：1字=32位=4字节，64位计算机：1字=64位=8字节</p> 
<table><thead><tr><th>C声明</th><th>Inter数据类型</th><th>汇编代码后缀</th><th>大小(字节)</th></tr></thead><tbody><tr><td>char</td><td>字节</td><td>b</td><td>1</td></tr><tr><td>short</td><td>字</td><td>w</td><td>2</td></tr><tr><td>int</td><td>双字</td><td>l</td><td>4</td></tr><tr><td>long</td><td>四字</td><td>q</td><td>8</td></tr><tr><td>char*</td><td>四字</td><td>q</td><td>8</td></tr><tr><td>float</td><td>单精度</td><td>s</td><td>4</td></tr><tr><td>double</td><td>双精度</td><td>l</td><td>8</td></tr></tbody></table> 
<p>有这一些后缀，mov指令可能为movb、mobw、movl、movq</p> 
<h3><a id="3__108"></a>3. 信息访问</h3> 
<p>从左到右分别为64、32、16、8位，每一部分都有不同的功能，如右边一列所示。</p> 
<p><img src="https://images2.imgbox.com/69/45/sqllJMn5_o.png" alt="在这里插入图片描述"></p> 
<p>寄存器中，1、2字节赋值，剩余字节不变。4字节赋值，高位4字节清零。后面半段意思就是，寄存器8个字节嘛，然后你要将四个赋值给寄存器假如原本值为0x98765432，我想赋值0x6666，那么最终寄存器值为0x00006666.</p> 
<p>Tips：1、2字节赋值为低字节赋值，r8~r15为64位系统新增。</p> 
<h4><a id="31__119"></a>3.1. 操作数指示符</h4> 
<p>大多数指令包含两部分——操作码和操作数</p> 
<p>在汇编语言中，大多数指令都会涉及一或多个操作数，但是像ret指令是没有操作数的。操作数可以是具体的数据值（如数字、字符等），也可以是数据存储的位置（如寄存器或内存地址）。</p> 
<ul><li>寻址方式：</li></ul> 
<p><strong>立即数寻址</strong>: 立即数寻址方式指的是操作数被直接编码在指令中。这个数是一个常数，它在指令执行时不会改变。例如，在指令 <code>mov $0x1, %eax</code> 中，<code>$0x1</code> 就是一个立即数，它将被直接移动到 <code>%eax</code> 寄存器中。</p> 
<p><strong>寄存器寻址</strong>: 寄存器寻址是最快的寻址方式，因为它不涉及内存访问。操作数是寄存器中的值。例如，指令 <code>add %ebx, %eax</code> 将 <code>%ebx</code> 寄存器的值加到 <code>%eax</code> 寄存器的值上。在这里，<code>%ebx</code> 和 <code>%eax</code> 都是使用寄存器寻址方式的操作数。</p> 
<p><strong>内存引用寻址（Memory Addressing）</strong>: 内存引用寻址方式涉及从内存中读取数据或向内存中写入数据。这种寻址方式可以通过多种形式表达：</p> 
<ul><li><strong>直接寻址（Direct Addressing）</strong>: 指令直接包含内存位置的地址。例如，<code>mov 0x8049a04, %eax</code> 将地址 <code>0x8049a04</code> 处的值加载到 <code>%eax</code> 中。</li><li><strong>间接寻址（Indirect Addressing）</strong>: 使用寄存器来存储内存地址，然后从该地址读取或向该地址写入数据。例如，<code>mov (%ebx), %eax</code> 会将 <code>%ebx</code> 寄存器中的地址对应的内存内容加载到 <code>%eax</code> 寄存器中。</li><li><strong>基址寻址（Base Addressing）</strong>: 使用基址寄存器和一个偏移量来确定内存地址。例如，<code>mov 4(%ebx), %eax</code> 将地址 <code>%ebx+4</code> 处的内存内容加载到 <code>%eax</code> 中。</li><li><strong>变址寻址（Indexed Addressing）</strong>: 使用基址寄存器、变址寄存器、缩放因子和偏移量。例如，<code>mov 4(%ebx, %ecx, 2), %eax</code> 表示将地址 <code>%ebx + %ecx*2 + 4</code> 处的内存内容加载到 <code>%eax</code> 中。</li></ul> 
<p><img src="https://images2.imgbox.com/66/98/TpSCCynV_o.png" alt="在这里插入图片描述"></p> 
<p>注意点就是，4(%rax)是0x100+0x4，9(%rax,%rdx)为%rax和%rdx的值相加，并加上一个偏移量来计算得出的，0xFC(,%rcx,4)取 <code>%rcx</code> 寄存器的值，将 %rcx的值乘以缩放因子4偏移量 0xFC。最后一个就是%rax+4*%rdx。</p> 
<p><img src="https://images2.imgbox.com/be/09/NYQQ7mFm_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="33__148"></a>3.3. 代码中的操作数</h4> 
<ul><li>一维数组寻址：a[n]=a[0]+n*i(数据类型所占字节)</li><li>二维数组寻址：b[i][j] = b[0][0] + i * n * m + j * n</li></ul> 
<p>上面那些就是C/C++里面数组中地址的加减问题嘛。</p> 
<h4><a id="34__155"></a>3.4. 数据传输指令</h4> 
<p>数据传输的意思就是字面上的，不要纠结。下面来看汇编的数据传输的指令：</p> 
<p>(注释：大小不等)</p> 
<table><thead><tr><th>(等大小传输)指令</th><th>关键后缀与大小(bit)</th><th>注释</th></tr></thead><tbody><tr><td>movb</td><td>b(8bit)</td><td>传输一个“半个字”大小的数据</td></tr><tr><td>movw</td><td>w(16bit)</td><td>传输一个字大小的数据</td></tr><tr><td>movl</td><td>l(32bit)</td><td>传输一个长字大小的数据</td></tr><tr><td>movq</td><td>q(64bit)</td><td>传输一个四字大小的数据</td></tr></tbody></table> 
<table><thead><tr><th>(大小不等且符号位扩展)指令</th><th>注释</th></tr></thead><tbody><tr><td>movsbw</td><td>注意点就是mov后面是s，代表的就是符号位扩展，bw就是两个的后缀代表的就是“半个字”到一个字</td></tr><tr><td>movsbl</td><td>略</td></tr><tr><td>movswl</td><td>略</td></tr></tbody></table> 
<table><thead><tr><th>(大小不等且用零号扩展)指令</th><th>注释</th></tr></thead><tbody><tr><td>movzbw</td><td>为了好看加了这一列</td></tr><tr><td>movzbl</td><td>无</td></tr></tbody></table> 
<p>movabsq传送绝对的4字：立即数按64位；</p> 
<p>以上指令不止这些，理解就行了。</p> 
<h4><a id="35__183"></a>3.5. 数据传输扩展示例</h4> 
<p><img src="https://images2.imgbox.com/85/83/uSl2Bm6G_o.png" alt="在这里插入图片描述"></p> 
<p>注意点，mov类型由寄存器大小决定，不可以单独用mov进行不同大小寄存器互传(内存可以)；内存之间不可以对拷，即不能movq (%rdi) (%rsi)，应该使用中介寄存器：</p> 
<pre><code>movq (%rdi), %rax
movq %rax, (%rsi)
</code></pre> 
<pre><code class="prism language-C">// 假设rdi和rsi是指向64位整型（long long int）的指针
long long int *src = (long long int *)rdi; // 假设rdi是源指针的地址
long long int *dst = (long long int *)rsi; // 假设rsi是目标指针的地址

// 进行解引用拷贝
*dst = *src;
</code></pre> 
<h4><a id="36__204"></a>3.6. 前面的补充一下</h4> 
<h5><a id="361_movqmovabsq_206"></a>3.6.1. 对于movq和movabsq</h5> 
<p>在 x86-64 架构的汇编语言中，<code>movq</code> 和 <code>movabsq</code> 是用来移动数据的指令，它们的功能是将数据从一个地方传送到另一个地方，但它们在使用上有细微的差别。</p> 
<ol><li> <p><strong>movq</strong>: 这条指令用于将64位的值移动到寄存器或内存中。<code>movq</code>可以用于各种寻址模式，包括直接寻址、寄存器寻址、基址变址寻址等。它通常用于操作较小的立即数值或当源和目标都是寄存器时。当<code>movq</code>用于立即数时，它将32位的立即数值符号扩展到64位(算术扩展即看符号位)，然后存入目标寄存器。例如，<code>movq $0x12345678, %rax</code> 会将32位数 <code>0x12345678</code> 扩展为64位，然后存入 <code>%rax</code>。</p> </li><li> <p><strong>movabsq</strong>: 这条指令是 <code>movq</code> 的一个特殊变种，它允许直接操作64位的立即数或绝对地址。这是当你需要将一个完整的64位立即数值加载到寄存器，或者你需要引用一个具体的64位内存地址时使用的。<code>movabsq</code> 可以确保你能够将任意的64位值直接移动到寄存器中，而不进行符号扩展。例如，<code>movabsq $0x123456789abcdef0, %rax</code> 会将64位的立即数 <code>0x123456789abcdef0</code> 直接加载到 <code>%rax</code> 寄存器中。</p> </li></ol> 
<h5><a id="362_mov_214"></a>3.6.2. 指令mov后缀</h5> 
<p><code>mov</code>指令的后缀通常指示操作数的大小，也就是要传输的数据的大小。这个后缀与第二个操作数（目标操作数）的大小一致，因为<code>mov</code>指令的作用是将数据从源操作数移动到目标操作数。</p> 
<h5><a id="363_movl_218"></a>3.6.3. movl</h5> 
<p>使用movl时候，即4字节赋值，则高位32位清零，如上面那一张图片所示，其中eax被包含于rax。</p> 
<h4><a id="37__222"></a>3.7. 数据传输扩展</h4> 
<p><img src="https://images2.imgbox.com/fc/8d/iCHHgegb_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/a1/a4/lcN0MZZx_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="38_C_230"></a>3.8. 数据传输在C与汇编间的转换</h4> 
<pre><code class="prism language-c"><span class="token keyword">long</span> <span class="token function">exchange</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token operator">*</span> xp<span class="token punctuation">,</span> <span class="token keyword">long</span> y<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">long</span> x <span class="token operator">=</span> <span class="token operator">*</span>xp<span class="token punctuation">;</span>
    <span class="token operator">*</span>xp <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code>exchange:
    movq (%rdi), %rax    # 将第一个参数xp指向的值加载到寄存器rax中，即long x = *xp;
    movq %rsi, (%rdi)    # 将第二个参数y的值存储到xp指向的内存位置中，即*xp = y;
    ret                   # 返回rax寄存器中的值，即return x;
</code></pre> 
<p>Tips：一般默认函数的第一参数存入rdi寄存器（与位有关 edi、di、dil），第二个参数存入rsi寄存器（esi、si、sil） ，第三个放入rdx寄存器（edx、dx、dl）</p> 
<h3><a id="4__250"></a>4. 栈与数据传送指令</h3> 
<h4><a id="41__252"></a>4.1. 压入弹出栈数据</h4> 
<p>压入栈图示：</p> 
<p><img src="https://images2.imgbox.com/10/86/CzuFqXqA_o.png" alt="在这里插入图片描述"></p> 
<p>压栈（<code>push</code> 指令）</p> 
<ul><li><code>pushq %rax</code>：这条指令将 <code>%rax</code> 寄存器中的64位值压入栈中。</li><li>执行 <code>push</code> 指令时，栈指针 <code>%rsp</code> 首先减去操作数大小（在64位系统中通常是8字节）。</li><li>然后，<code>%rax</code> 寄存器中的值被存储在新的 <code>%rsp</code> 指向的地址处。</li></ul> 
<p>出栈（<code>pop</code> 指令）</p> 
<ul><li><code>popq %rdx</code>：这条指令将栈顶的64位值弹出，并存入 <code>%rdx</code> 寄存器中。</li><li>执行 <code>pop</code> 指令时，首先从 <code>%rsp</code> 指向的地址读取数据到目标寄存器 <code>%rdx</code>。</li><li>然后，栈指针 <code>%rsp</code> 增加操作数大小，即向上移动8字节。</li></ul> 
<p>栈的增长方向</p> 
<ul><li>在 x86-64 架构中，<strong>栈向下增长，即向更低的地址扩展</strong>。因此，<code>push</code> 操作会减少 <code>%rsp</code> 的值，而 <code>pop</code> 操作会增加 <code>%rsp</code> 的值。</li></ul> 
<p>栈操作等效汇编指令</p> 
<ul><li><code>push</code> 和 <code>pop</code> 指令的操作可以用更基本的汇编指令序列来模拟。例如，<code>pushq %rax</code> 可以分解为两个步骤： 
  <ul><li><code>subq $8, %rsp</code>：将栈指针减去8字节（64位）。</li><li><code>movq %rax, (%rsp)</code>：将 <code>%rax</code> 寄存器的值移动到 <code>%rsp</code> 指向的新栈顶地址。</li></ul> </li><li>相似地，<code>popq %rdx</code> 也可以分解为： 
  <ul><li><code>movq (%rsp), %rdx</code>：将 <code>%rsp</code> 指向的栈顶地址的值移动到 <code>%rdx</code> 寄存器。</li><li><code>addq $8, %rsp</code>：将栈指针增加8字节。</li></ul> </li></ul> 
<p>栈顶和栈底</p> 
<ul><li>栈顶（<code>top of the stack</code>）是栈中最后压入的元素，是下一个将要被弹出的元素。在 x86-64 架构中，栈顶由 <code>%rsp</code> 寄存器指向。</li><li>栈底（<code>bottom of the stack</code>）是栈中第一个元素的位置，通常是程序开始运行时栈的初始位置。</li></ul> 
<h3><a id="5__289"></a>5. 算术与逻辑操作</h3> 
<h4><a id="51__291"></a>5.1. 加载有效地址及示例</h4> 
<p>加载有效地址的操作码：leal/leaq，作用：将内存地址加载到一个寄存器中。</p> 
<pre><code>leal disp(%base,%index,scale),%dest
leaq disp(%base,%index,scale),%dest
</code></pre> 
<p><img src="https://images2.imgbox.com/f3/91/EW4LoaON_o.png" alt="在这里插入图片描述"></p> 
<p>注意，对于leaq指令所执行的操作并不是去内存地址(5x+7)处读取数据，而是将有效值(5x+7)这个值直接写入到目的寄存器rax</p> 
<p>leal/leaq还可以进行算术操作：</p> 
<p><img src="https://images2.imgbox.com/4f/29/1nz0ovSs_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="52__310"></a>5.2. 一元操作和二元操作</h4> 
<p><img src="https://images2.imgbox.com/63/d0/g1hicAFH_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/a0/df/gbu3b9E9_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="53__318"></a>5.3. 二元操作示例</h4> 
<p>一开始的数据：<br> <img src="https://images2.imgbox.com/93/2c/2y4dO81a_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/51/64/xcGIqBQC_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="54__327"></a>5.4. 移位操作</h4> 
<p><img src="https://images2.imgbox.com/65/75/6p7VxMiw_o.png" alt="在这里插入图片描述"></p> 
<p>移位k可以是一个立即数也可以是一个放在%rcx的%cl中的数，其他的寄存器不行。移位规则：<br> <img src="https://images2.imgbox.com/4d/f1/azyY91bi_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="55__336"></a>5.5. 移位操作示例</h4> 
<pre><code>long shift_left4_rightn(long x,long n)
x in %rdi,n in %rsi
shift_left4_rightn:
movq %rdi,%rax   ---Get x
salq $4,%rax     ---x&lt;&lt;=4
movl %esi,%ecx   ---Get n (4 bytes)
sarq %cl,%rax    ---x&gt;&gt;=n
</code></pre> 
<h4><a id="56__348"></a>5.6. 算数运算函数转换示例</h4> 
<p><img src="https://images2.imgbox.com/b4/5d/GpbX9Sb0_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/ed/c8/hl55vBz3_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="57__354"></a>5.7. 特殊算术操作</h4> 
<p><img src="https://images2.imgbox.com/d0/de/XE0aKMxL_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="6__359"></a>6. 条件码</h3> 
<h4><a id="61__361"></a>6.1. 条件码</h4> 
<p>在我们执行运算的时候，ALU除了执行算术运算和逻辑运算之外，还会根据运算的结果去设置条件码寄存器：</p> 
<p><img src="https://images2.imgbox.com/48/30/I8iStV8n_o.png" alt="在这里插入图片描述"></p> 
<p>下面是条件寄存器的相关知识，条件码寄存器是由CPU来维护的，长度是单个比特位，它描述了最近执行操作的属性</p> 
<p><img src="https://images2.imgbox.com/db/39/QOlsDN2I_o.png" alt="在这里插入图片描述"></p> 
<p>影响标志位的指令总结：</p> 
<p><img src="https://images2.imgbox.com/8b/7f/IrWnXNbg_o.png" alt="在这里插入图片描述"></p> 
<p>对于以下指令只设置条件码，不改变其他寄存器</p> 
<p><img src="https://images2.imgbox.com/d4/1d/AXlQuVqz_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="62__383"></a>6.2. 条件码例子</h4> 
<p><img src="https://images2.imgbox.com/97/ea/Yhc7GBCn_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="63__388"></a>6.3. 访问条件码</h4> 
<p>条件码一般不会直接读取，会利用条件码状态设置某个字节（低位单字节存储器、一个字节的内存地址），指令的不同后缀指明了相关条件码的组合</p> 
<p><img src="https://images2.imgbox.com/c9/73/QHtwMHGN_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="64__395"></a>6.4. 访问条件码例子</h4> 
<p><img src="https://images2.imgbox.com/81/dd/zcdMt57T_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/77/ab/xkkFRStl_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="7__403"></a>7. 控制</h3> 
<h4><a id="71__405"></a>7.1. 无条件跳转</h4> 
<p>jmp + 标号直接跳转或jmp + 寄存器或内存目标中读出的的跳转目标</p> 
<p><img src="https://images2.imgbox.com/80/0a/D9rhauCM_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="72__412"></a>7.2. 条件跳转</h4> 
<p><img src="https://images2.imgbox.com/c4/0c/3HCHqFJv_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="73__417"></a>7.3. 条件控制例题</h4> 
<p><img src="https://images2.imgbox.com/1b/2f/AEh2yRm3_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="74__422"></a>7.4. 跳转指令的编码</h4> 
<p>虽然我们不关心机器代码格式，但是理解跳转指令的目标如何编码，这对第七章研究链接非常重要。此外他也能帮助理解反汇编的输出。在汇编代码中，跳转目标用符号来书写。汇编器、链接器会产生跳转目标的适当编码。跳转指令有几种不同的编码，但是<strong>最常用的就是它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码</strong>，这些地址偏移量可以编码为1，2或4字节。其次的编码方式就是给出绝对地址，用4个字节直接指定目标。</p> 
<p><img src="https://images2.imgbox.com/b8/c7/JSqtZbZA_o.png" alt="在这里插入图片描述"></p> 
<p>jmp跳转过程为，3（当前地址）+ 2（指令长度）+ 3（偏移量）= 8（目标地址）；jg跳转过程为：b（当前地址）+ 2（指令长度）- 8（偏移量）= b - 6 = 5（十六进制的目标地址，十进制是11 - 6 = 5）</p> 
<p><img src="https://images2.imgbox.com/d0/94/86RAfc66_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="75__434"></a>7.5. 条件传送实现分支</h4> 
<p>条件控制来实现条件分支简单但也低效，数据的条件转移在一些受限的情况下可行，更符合现代处理器的特点</p> 
<p><img src="https://images2.imgbox.com/3a/7d/KZFgWjtB_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/ec/1f/eNFIUDlR_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/b5/08/Eq13X9ZD_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="76__447"></a>7.6. 条件传送例题</h4> 
<p><img src="https://images2.imgbox.com/1c/c4/E9Jzd1qA_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="77_while_452"></a>7.7. while循环</h4> 
<ul><li>do-while</li></ul> 
<p><img src="https://images2.imgbox.com/32/6c/KE5QmVhR_o.png" alt="在这里插入图片描述"></p> 
<ul><li>while</li></ul> 
<p><img src="https://images2.imgbox.com/f6/44/h3hgKsth_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/d3/7f/x3oAjFL3_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="78_for_467"></a>7.8. for循环</h4> 
<p><img src="https://images2.imgbox.com/a2/80/u6jNq6tC_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/0f/15/C07WV0hL_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="79_switch_475"></a>7.9. switch语句</h4> 
<p>在针对一个测试有多种可能的结果时，switch语句很有用，它通过跳转表这种数据结构，使得实现更加高效</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">switch_eg</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> <span class="token keyword">long</span> n<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token operator">*</span>dest<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">long</span> val <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">case</span> <span class="token number">100</span><span class="token operator">:</span>
            val <span class="token operator">*=</span> <span class="token number">13</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">102</span><span class="token operator">:</span>
            val <span class="token operator">+=</span> <span class="token number">10</span><span class="token punctuation">;</span>
            <span class="token comment">/* Fall through */</span>
        <span class="token keyword">case</span> <span class="token number">103</span><span class="token operator">:</span>
            val <span class="token operator">+=</span> <span class="token number">11</span><span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">case</span> <span class="token number">104</span><span class="token operator">:</span>
        <span class="token keyword">case</span> <span class="token number">106</span><span class="token operator">:</span>
            val <span class="token operator">*=</span> val<span class="token punctuation">;</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token keyword">default</span><span class="token operator">:</span>
            val <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">*</span>dest <span class="token operator">=</span> val<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/b7/49/XZJzjZ98_o.png" alt="在这里插入图片描述"></p> 
<ol><li> <p><code>subq $100, %rsi</code>：从<code>n</code>中减去100，计算出偏移量（<code>n-100</code>），结果存回<code>%rsi</code>。</p> </li><li> <p><code>cmpq $6, %rsi</code>：将计算后的偏移量与6比较。</p> </li><li> <p><code>ja .L8</code>：如果偏移量大于6（即<code>n &gt; 106</code>），跳转到<code>.L8</code>标签（<code>default</code>情况）。</p> </li><li> <p><code>jmp *.L4(,%rsi,8)</code>：基于偏移量进行间接跳转，<code>%rsi</code>乘以8（因为是64位系统，地址是8字节对齐的），加上<code>.L4</code>的地址，跳转到对应的<code>case</code>标签。</p> </li><li> <p><code>.L3</code>标签下的两行指令：</p> 
  <ul><li><code>leaq (%rdi,%rdi,2), %rax</code>：计算<code>3 * x</code>，等价于<code>x + x*2</code>，结果存入<code>%rax</code>。</li><li><code>leaq (%rdi,%rax,4), %rdi</code>：计算<code>x + 4*(3*x)</code>，结果是<code>13 * x</code>，存回<code>%rdi</code>。</li></ul> </li><li> <p><code>.L5</code>标签：<code>addq $10, %rdi</code>将<code>x</code>加上10。</p> </li><li> <p><code>.L6</code>标签：<code>addq $11, %rdi</code>将<code>x</code>加上11。</p> </li><li> <p><code>.L7</code>标签：<code>imulq %rdi, %rdi</code>将<code>x</code>自乘。</p> </li><li> <p><code>.L8</code>标签：<code>movl $0, %edi</code>将<code>0</code>移动到<code>%edi</code>，即设置<code>val</code>为0。</p> </li><li> <p><code>.L2</code>标签：最终的结果从<code>%rdi</code>移动到通过<code>%rdx</code>指定的内存地址（即<code>*dest = val</code>）。</p> </li><li> <p><code>ret</code>指令将控制权返回给函数的调用者。</p> </li></ol> 
<h3><a id="8__531"></a>8. 过程</h3> 
<h4><a id="81__533"></a>8.1. 通过栈来传递参数</h4> 
<p>前六个参数是通过相应的寄存器来传递的，超过6个参数的部分就是通过栈来传递的，如下图所示：</p> 
<p><img src="https://images2.imgbox.com/34/5f/NL2qOpaa_o.png" alt="在这里插入图片描述"></p> 
<p>这里有两点要注意的是，第一通过栈来<strong>传输数据</strong>时，所以数据的大小都是向8的倍数对齐(如上图中的a4)，而<strong>局部变量是不需要对齐的</strong>，虽然变量a4只占一个字节，但是仍然为其分配了8个字节的存储空间。另外一点需要注意，就是使用寄存器进行参数传递时，寄存器的使用是有特殊顺序规定的，此外寄存器的名字使用取决于传递参数的大小，例如如果第一个参数的大小是4字节，那么需要用寄存器%edi来保存，总结如下：</p> 
<p><img src="https://images2.imgbox.com/da/6c/5Puil15o_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="82__545"></a>8.2. 运行时栈</h4> 
<p><img src="https://images2.imgbox.com/97/d8/eLBnuW3U_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/3a/15/2ikT5dAs_o.png" alt="在这里插入图片描述"></p> 
<p>下面来解释一下栈的过程：</p> 
<ol><li><code>subq $16, %rsp</code>：这条指令从栈指针寄存器<code>%rsp</code>中减去16。这实际上在栈上分配了16字节的空间，通常用于局部变量或维持对齐。</li><li><code>movq $534, (%rsp)</code>：这条指令将数值534移动（存储）到栈指针<code>%rsp</code>所指向的地址上。因为刚才已经通过<code>subq</code>指令在栈上预留了空间，这个值就被存储在栈的最顶端。</li><li><code>movq $1057, 8(%rsp)</code>：这条指令将数值1057移动到栈指针<code>%rsp</code>当前指向地址的上面8个字节的位置。在64位系统中，<code>movq</code>指令操作的是8字节，所以这条指令实际上是在栈上第一个8字节存储的值（534）之上再存储一个8字节的值（1057）。</li></ol> 
<p>经过这三条指令后，栈的情况如下：</p> 
<ul><li>栈顶（<code>%rsp</code>）: 534存储的位置。</li><li><code>%rsp+8</code>: 1057存储的位置。</li><li><code>%rsp+16</code>: 栈指令执行前的栈顶位置。</li></ul> 
<h4><a id="83__565"></a>8.3. 引用的案例</h4> 
<p><img src="https://images2.imgbox.com/76/3c/DbcV0o2d_o.png" alt="在这里插入图片描述"></p> 
<p>在上面图片中，前六个参数是通过寄存器传递的(栈上出现它们身影是因为这是调用前的状态，保证程序的正确性防止值的覆盖，对于某些值需要在过程中开空间保存，也不需要8倍数对齐)，后两个参数是通过栈来传递的，由于&amp;x4是一个地址，所以刚好是8字节。</p> 
<h4><a id="84__572"></a>8.4. 调用者保存和被调用者保存</h4> 
<p>在程序执行的过程中，寄存器是被所有函数共享的一种资源，为了避免寄存器的使用过程中出现数据覆盖的问题，处理器规定了寄存器的使用惯例，所有的函数调用都必须遵守这个惯例，即调用者保存和被调用者保存，在1.3中已经简单讲过这个知识点了。</p> 
<p><img src="https://images2.imgbox.com/7d/99/nXurzH02_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="85__579"></a>8.5. 递归调用</h4> 
<p>下面是一个递归调用的例子，递归调用和调用其他函数是一样的，每次函数调用都有他自己私有的状态信息：<br> <img src="https://images2.imgbox.com/1b/40/lLuP4jHY_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="9__585"></a>9. 数组</h3> 
<h4><a id="91__587"></a>9.1. 数组示例</h4> 
<p><img src="https://images2.imgbox.com/60/14/hokFtVlg_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/7d/01/BKBFqRrG_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="92__595"></a>9.2. 多维数组</h4> 
<p><img src="https://images2.imgbox.com/6d/de/suKysLZx_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/84/c5/rKXE6IbA_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="93__603"></a>9.3. 定长数组</h4> 
<p><img src="https://images2.imgbox.com/25/94/8M9GYKYt_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/d9/59/jH5EWICM_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/21/f6/XnFypeKq_o.png" alt="在这里插入图片描述"></p> 
<p>汇编代码如下：</p> 
<ol><li> <p><code>salq $6, %rdx</code>：这是一个左移指令，将 <code>%rdx</code>（存储变量 <code>i</code>）左移6位，相当于乘以64。在这里，因为矩阵是16x16的，所以每行有16个整数，每个整数4字节，16x4等于64。这条指令用于计算行 <code>i</code> 在矩阵A中的起始位置。</p> </li><li> <p><code>addq %rdx, %rdi</code>：将 <code>%rdx</code> 加到 <code>%rdi</code>，其中 <code>%rdi</code> 存储了矩阵A的起始地址，这样 <code>%rdi</code> 就指向了A[i][0]。</p> </li><li> <p><code>leaq (%rsi, %rcx, 4), %rcx</code>：这条指令加载B矩阵中第k列的起始地址到 <code>%rcx</code>。<code>%rsi</code> 存储了矩阵B的起始地址，<code>%rcx</code> 存储了变量 <code>k</code>。因为矩阵以行为单位存储，所以每一列的元素间隔是矩阵宽度（16个整数）乘以整数大小（4字节）。</p> </li><li> <p><code>leaq 1024(%rcx), %rsi</code>：这条指令设置一个界限，它计算了B矩阵中第k列的结束地址。因为一行有64字节（16个整数 x 4字节/整数），所以整个矩阵有16行，即1024字节。</p> </li><li> <p><code>movl $0, %eax</code>：这条指令把0移动到 <code>%eax</code>，初始化累加器 <code>result</code>。</p> </li></ol> 
<p>接下来是循环部分，对应C代码中的 <code>for</code> 循环：</p> 
<ol start="6"><li> <p><code>movl (%rdi), %edx</code>：从内存地址 <code>%rdi</code>（当前A[i][j]）读取值到 <code>%edx</code>。</p> </li><li> <p><code>imull (%rcx), %edx</code>：将 <code>%edx</code>（A[i][j]的值）与内存地址 <code>%rcx</code>（当前B[j][k]）的值相乘，并将结果存储回 <code>%edx</code>。</p> </li><li> <p><code>addl %edx, %eax</code>：将 <code>%edx</code>（乘积结果）加到 <code>%eax</code>（累加器 <code>result</code>）。</p> </li><li> <p><code>addq $4, %rdi</code>：将 <code>%rdi</code> 加4，移动到下一个A矩阵元素。</p> </li><li> <p><code>addq $64, %rcx</code>：将 <code>%rcx</code> 加64，移动到下一行的B矩阵元素。</p> </li><li> <p><code>cmpq %rsi, %rcx</code>：比较 <code>%rcx</code> 和 <code>%rsi</code>（B矩阵k列的结束地址）。</p> </li><li> <p><code>jne .L7</code>：如果 <code>%rcx</code> 不等于 <code>%rsi</code>，则跳转回循环开始（标签 <code>.L7</code>）继续执行。</p> </li></ol> 
<p>最后的指令 <code>rep; ret</code> 是一个返回序列。<code>rep</code> 前缀通常用于字符串操作指令，用于重复操作直到某个条件不满足。但在这里它似乎是多余的，因为它没有与之配合的字符串操作指令。<code>ret</code> 是函数返回指令，它将控制权交还给函数的调用者，并将累加结果（在 <code>%eax</code> 中）作为返回值。</p> 
<h4><a id="94__644"></a>9.4. 变长数组</h4> 
<p><img src="https://images2.imgbox.com/5b/19/nNq9kCAA_o.png" alt="在这里插入图片描述"></p> 
<p>在C代码中：</p> 
<ul><li><code>int A[expr1][expr2];</code> 定义了一个二维变长数组，其中 <code>expr1</code> 和 <code>expr2</code> 是在运行时确定的表达式。</li><li><code>long var_ele(long n, int A[n][n], long i, long k)</code> 函数接受四个参数：一个长整型的 <code>n</code>，它表示数组的大小，一个类型为 <code>int</code>、大小为 <code>n</code>x<code>n</code> 的二维数组 <code>A</code>，以及两个长整型的索引 <code>i</code> 和 <code>k</code>，函数返回数组在 <code>i</code> 行 <code>k</code> 列的元素。</li></ul> 
<p>在汇编代码中：</p> 
<ul><li><code>%rdi</code> 寄存器存储 <code>n</code> 的值。</li><li><code>%rsi</code> 寄存器存储数组 <code>A</code> 的地址。</li><li><code>%rdx</code> 寄存器存储 <code>i</code> 的值。</li><li><code>%rcx</code> 寄存器存储 <code>j</code> 的值。</li></ul> 
<p>汇编指令做了以下操作：</p> 
<ol><li><code>imulq %rdx, %rdi</code>：将 <code>i</code> 和 <code>n</code> 相乘，结果存回 <code>%rdi</code>。这计算了二维数组中第 <code>i</code> 行的起始位置的偏移量（因为每行有 <code>n</code> 个元素，每个元素占4字节）。</li><li><code>leaq (%rsi, %rdi, 4), %rax</code>：基于 <code>%rsi</code>（数组 <code>A</code> 的地址）和 <code>%rdi</code>（行偏移量）计算元素 <code>A[i][0]</code> 的地址，并将这个地址存入 <code>%rax</code>。</li><li><code>movl (%rax, %rcx, 4), %eax</code>：读取位于 <code>%rax</code> + <code>4*k</code> 的内存内容，即元素 <code>A[i][k]</code> 的值，并将其存入 <code>%eax</code>。这里 <code>%rcx</code> 存储 <code>k</code>，所以 <code>%rcx * 4</code> 给出了列 <code>k</code> 的偏移量。</li></ol> 
<p><code>ret</code> 指令结束函数，返回时 <code>%eax</code> 寄存器中的值就是函数的返回值，即 <code>A[i][k]</code>。这就是如何在汇编层面处理C语言中的变长数组访问。</p> 
<h3><a id="10__666"></a>10. 异质的数据结构</h3> 
<h4><a id="101__668"></a>10.1. 结构体及其访问</h4> 
<p>下面是简单的结构体示例：<br> <img src="https://images2.imgbox.com/f0/67/KEiIVET2_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="102__674"></a>10.2. 数据对齐</h4> 
<p><img src="https://images2.imgbox.com/b6/55/DE6tTvzE_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="11__679"></a>11. 理解指针</h3> 
<ul><li>每一个指针对应一个类型，这个类型表明指针指向的是哪一类对象，但是指针的大小是不变的，它不依赖于它指向的数据类型的大小，它随着操作系统的架构而改变，32位系统位4个字节，64位系统为8个字节。</li><li>数组和指针的联系，一个数组的名字可以像一个指针变量一样应用，但是不可以修改，数组引用a[3]和*(a+3)是一样的效果。当我们写表达式P+1的时候，这里的指针P的值为p，得到的地址计算为p+L*i，这里的L是与p相关联的数据类型。</li><li>将指针从一种类型强制转换为另一种类型时候，只改变它的类型，而不改变它的值，强制转换的一个效果就是改变指针运算的伸缩。</li><li>指针指向函数</li></ul> 
<h3><a id="12__686"></a>12. 内存越界引用和缓冲区溢出</h3> 
<p>C语言对于数组引用不进行任何边界检查，而且局部变量信息和状态信息(例如保存的寄存器的值和返回地址)都存放在栈中。下面来看一个代码例子：<br> <img src="https://images2.imgbox.com/d7/82/VyYKEwva_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/15/da/YBZuQGK2_o.png" alt="在这里插入图片描述"></p> 
<p>在上面的C代码例子以及它的汇编代码例子中，展示了一个很好的缓冲区溢出的例子，由于gets函数没有办法确定是否分配了足够的空间，所以任何超过7个字符的字符串都会导致越界。随着字符串变长，0-7字符不会造成破坏，9-23会导致未使用的栈空间遭到破坏，24-31会导致返回地址遭到破坏，32往后会导致caller中保存的状态遭到破坏。</p> 
<h4><a id="121__697"></a>12.1. 对抗缓冲区溢出攻击</h4> 
<ul><li>栈随机化：</li></ul> 
<p><img src="https://images2.imgbox.com/71/b3/CGcAotmL_o.png" alt="在这里插入图片描述"></p> 
<p>这种技术叫做地址空间布局随机化ASLR，每次运行时程序的不同部分，包括程序代码、库代码、栈、全局变量和堆数据都会被加载到内存的不同区域。</p> 
<ul><li> <p>栈破坏检测：最近的GCC版本在产生代码中加入了一种栈保护者机制来检测缓冲区越界，其思想是在栈帧中任意布局缓冲区与栈状态之间存储一个特殊的值(金丝雀值canary)，这个值是随机产生的，程序会检测金丝雀前后变化来判定。</p> </li><li> <p>限制可执行代码区域：消除攻击者向系统中插入可执行代码的能力。</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/49b5114363f9a2998a4602cfcf59a788/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">语言栏中的半角和全角</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0cd49a83e544202c8dd4e29dc4c62c61/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">洛谷 P8682 [蓝桥杯 2019 省 B] 等差数列</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>