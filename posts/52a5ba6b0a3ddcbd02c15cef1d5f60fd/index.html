<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【常用模块】ESP8266 WIFI串口通信模块使用详解（实例：附STM32详细代码） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【常用模块】ESP8266 WIFI串口通信模块使用详解（实例：附STM32详细代码）" />
<meta property="og:description" content="物联网，万物互联。这里涉及到的最基本的东西就是如何将所有的物联网设备连接在一起。最简单、最广泛使用的就是互联网。
ESP8266 WIFI串口通信模块应该是使用最广泛的一种WIFI模块之一了。为什么呢？
因为ESP8266模块是一款高性能的WIFI串口模块，可以不用知道太多WIFI相关知识就可以很好的上手。说白了，只是个WIFI转串口的设备，你只要知道串口怎么编程使用，就可以了，实现了所谓的透明传输。
但是就是这么一个很常见的模块，网上很多的博客写的都是错的，或者都是很不详细的。
模块名称：ESP8266 WIFI串口通信模块
参考资料：ESP8266 WIFI串口通信模块官方资源、ATK-ESP8266资源包（提取码: nhsh）
知识储备：【STM32】串口通信基本原理（超基础、详细版）
其他模块：USB转TTL模块
项目下载链接：见本文文末
WIFI模块的调试 准备工作 USB转TTL模块与ESP8266 WIFI模块的接线：
现在市面上使用比较的ESP8266有两个版本，分别是官方的ESP8266（两排8引脚）、ATK-ESP8266（一排6引脚）。其实并没有太大的区别，只是将其中的一些引脚进行额外布局而已。
如果是官方的ESP8266模块，接线方式如下：
如果是ATK-ESP8266（正点原子）模块，接线方式如下：
这六个引脚只需要4个就行了：RXD、TXD、GND、VCC，分别和USB转TTL模块的TXD、RXD、GND、VCC相连接就行了。
需要注意两点：
1、ESP8266的RXD（数据的接收端）需要连接USB转TTL模块的TXD，TXD（数据的发送端）需要连接USB转TTL模块的RXD，这是基本的；
2、关于VCC的选取，在USB转TTL模块上有3.3V和5V两个引脚可以作为VCC，但是一般选取5V作为VCC。如果选取3.3V，可能会因为供电不足而引起不断的重启，从而不停的复位。
AT指令 在使用USB转TTL模块与电脑连接之后，就可以使用串口调试助手进行WIFI模块的调试了。首先有一点，AT指令不区分大小写，均以回车、换行结尾。下面介绍常用的AT指令：
常用AT指令 指令名响应含义ATOK测试指令AT&#43;CWMODE=&lt;mode&gt;OK设置应用模式（需重启生效）AT&#43;CWMODE?&#43;CWMODE:&lt;mode&gt;获得当前应用模式AT&#43;CWLAP&#43;CWLAP:&lt;ecn&gt;,&lt;ssid&gt;,&lt;rssi&gt;返回目前的AP列表AT&#43;CWJAP=&lt;ssid&gt;,&lt;pwd&gt;OK加入某一APAT&#43;CWJAP?&#43;CWJAP:&lt;ssid&gt;返回当前加入的APAT&#43;CWQAPOK退出当前加入的APAT&#43;CIPSTART=&lt;type&gt;,&lt;addr&gt;,&lt;port&gt;OK建立TCP/UDP连接AT&#43;CIPMUX=&lt;mode&gt;OK是否启用多连接AT&#43;CIPSEND=&lt;param&gt;OK发送数据AT&#43;CIPMODE=&lt;mode&gt;OK是否进入透传模式 需要补充几点：
1、ESP8266的应用模式：ESP266支撑单AP模式、单STA模式和混合模式。简单的来说就是：
AP：可以将ESP8266作为热点，可以让其他的设备连接上它；STA：可以连接上当前环境下的WIFI热点。 2、什么是透传模式？
透传就是指不需要关心wifi协议是如何实现的。所需要做的就是A通过串口发数据，B通过串口收数据，整个过程中A串口和B串口就像是用导线直接连接起来了一样。则对于开发人员来看，就是完全透明的。
更简单地理解就是：
如果不开启透传模式，我们怎么发送数据呢？在每次发送数据前都必须先发送指令AT&#43;CIPSEND=&lt;param&gt;，例如：
AT&#43;CIPSEND=4 OK &gt; //在 &gt; 后面输入要上传的数据 但是一旦开启了透传模式，我们就不需要在每次发送数据前都发送指令AT&#43;CIPSEND=&lt;param&gt;了，只需要发送一次AT&#43;CIPSEND，之后发送的所有内容全部当成是数据了！
但是这也存在一个问题，要是我后来又想发送命令了，但是却也当成是数据发送过去了。这可怎么办？
这就要退出透传模式了。怎么退出，发送数据&#34;&#43;&#43;&#43;&#34;就可以了。注意：此时“&#43;&#43;&#43;”后面，不接“发送新行”！
WIFI模块的使用 ESP8266的一般使用顺序 这里的“一般”指的是：ESP8266连接当前环境的热点，与服务器建立TCP连接，传输数据。
AT&#43;CWMODE=1：设置工作模式（STA模式）AT&#43;RST：模块重启（生效工作模式）AT&#43;CWJAP=&#34;111&#34;,&#34;11111111&#34;：连接当前环境的WIFI热点（热点名，密码）AT&#43;CIPMUX=0：设置单路连接模式AT&#43;CIPSTART=&#34;TCP&#34;,&#34;xxx.xxx.xxx.xxx&#34;,xxxx：建立TCP连接AT&#43;CIPMODE=1：开启透传模式AT&#43;CIPSEND：透传模式下，传输数据&#43;&#43;&#43;：退出透传模式 ESP8266的封装代码 关于与单片机的引脚连接：ESP8266与USART3（引脚PB10、PB11）连接。
首先是USART的配置：
#include &#34;delay.h&#34; #include &#34;usart3.h&#34; #include &#34;stdarg.h&#34;	#include &#34;stdio.h&#34;	#include &#34;string.h&#34;	#include &#34;timer.h&#34; //串口接收缓存区 u8 USART3_RX_BUF[USART3_MAX_RECV_LEN]; //接收缓冲,最大USART3_MAX_RECV_LEN个字节. u8 USART3_TX_BUF[USART3_MAX_SEND_LEN]; //发送缓冲,最大USART3_MAX_SEND_LEN字节 //通过判断接收连续2个字符之间的时间差不大于10ms来决定是不是一次连续的数据." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/52a5ba6b0a3ddcbd02c15cef1d5f60fd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-01-27T19:06:57+08:00" />
<meta property="article:modified_time" content="2019-01-27T19:06:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【常用模块】ESP8266 WIFI串口通信模块使用详解（实例：附STM32详细代码）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>物联网，万物互联。这里涉及到的最基本的东西就是如何将所有的物联网设备连接在一起。最简单、最广泛使用的就是互联网。</p> 
<p>ESP8266 WIFI串口通信模块应该是使用最广泛的一种WIFI模块之一了。为什么呢？</p> 
<p><strong>因为ESP8266模块是一款高性能的WIFI串口模块，可以不用知道太多WIFI相关知识就可以很好的上手。说白了，只是个WIFI转串口的设备，你只要知道串口怎么编程使用，就可以了，实现了所谓的透明传输。</strong></p> 
<p>但是就是这么一个很常见的模块，网上很多的博客写的都是错的，或者都是很不详细的。</p> 
<p> </p> 
<p>模块名称：ESP8266 WIFI串口通信模块</p> 
<p>参考资料：<a href="https://www.espressif.com/zh-hans/products/hardware/esp8266ex/resources" rel="nofollow">ESP8266 WIFI串口通信模块官方资源</a>、<a href="https://pan.baidu.com/share/init?surl=C7MEsBdq58ADNJGKNqD0dQ" rel="nofollow">ATK-ESP8266资源包（提取码: nhsh）</a></p> 
<p>知识储备：<a href="https://blog.csdn.net/qq_38410730/article/details/79887200">【STM32】串口通信基本原理（超基础、详细版）</a></p> 
<p>其他模块：USB转TTL模块</p> 
<p><strong>项目下载链接：见本文文末</strong></p> 
<p> </p> 
<h3>WIFI模块的调试</h3> 
<h4>准备工作</h4> 
<p>USB转TTL模块与ESP8266 WIFI模块的接线：</p> 
<p>现在市面上使用比较的ESP8266有两个版本，分别是官方的ESP8266（两排8引脚）、ATK-ESP8266（一排6引脚）。其实并没有太大的区别，只是将其中的一些引脚进行额外布局而已。</p> 
<p><strong>如果是官方的ESP8266模块，接线方式如下：</strong></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/33/9d/kvm6VciH_o.jpg"></p> 
<p><strong>如果是ATK-ESP8266（正点原子）模块，接线方式如下：</strong></p> 
<p style="text-align:center;"><img alt="" class="has" height="396" src="https://images2.imgbox.com/db/2f/jGrD2k2P_o.jpg" width="600"></p> 
<p>这六个引脚只需要4个就行了：RXD、TXD、GND、VCC，分别和USB转TTL模块的TXD、RXD、GND、VCC相连接就行了。</p> 
<p>需要注意两点：</p> 
<p>1、ESP8266的RXD（数据的接收端）需要连接USB转TTL模块的TXD，TXD（数据的发送端）需要连接USB转TTL模块的RXD，这是基本的；</p> 
<p>2、<strong>关于VCC的选取，在USB转TTL模块上有3.3V和5V两个引脚可以作为VCC，但是一般选取5V作为VCC。</strong>如果选取3.3V，可能会因为供电不足而引起不断的重启，从而不停的复位。</p> 
<h4>AT指令</h4> 
<p>在使用USB转TTL模块与电脑连接之后，就可以使用串口调试助手进行WIFI模块的调试了。首先有一点，<strong>AT指令不区分大小写，均以回车、换行结尾。</strong>下面介绍常用的AT指令：</p> 
<table align="center" border="1" cellpadding="1" cellspacing="1"><caption>
   常用AT指令 
 </caption><tbody><tr><td style="text-align:center;">指令名</td><td style="text-align:center;">响应</td><td style="text-align:center;">含义</td></tr><tr><td>AT</td><td>OK</td><td>测试指令</td></tr><tr><td>AT+CWMODE=&lt;mode&gt;</td><td>OK</td><td>设置应用模式（需重启生效）</td></tr><tr><td>AT+CWMODE?</td><td>+CWMODE:&lt;mode&gt;</td><td>获得当前应用模式</td></tr><tr><td>AT+CWLAP</td><td>+CWLAP:&lt;ecn&gt;,&lt;ssid&gt;,&lt;rssi&gt;</td><td>返回目前的AP列表</td></tr><tr><td>AT+CWJAP=&lt;ssid&gt;,&lt;pwd&gt;</td><td>OK</td><td>加入某一AP</td></tr><tr><td>AT+CWJAP?</td><td>+CWJAP:&lt;ssid&gt;</td><td>返回当前加入的AP</td></tr><tr><td>AT+CWQAP</td><td>OK</td><td>退出当前加入的AP</td></tr><tr><td>AT+CIPSTART=&lt;type&gt;,&lt;addr&gt;,&lt;port&gt;</td><td>OK</td><td>建立TCP/UDP连接</td></tr><tr><td>AT+CIPMUX=&lt;mode&gt;</td><td>OK</td><td>是否启用多连接</td></tr><tr><td>AT+CIPSEND=&lt;param&gt;</td><td>OK</td><td>发送数据</td></tr><tr><td>AT+CIPMODE=&lt;mode&gt;</td><td>OK</td><td>是否进入透传模式</td></tr></tbody></table> 
<p>需要补充几点：</p> 
<p>1、ESP8266的应用模式：ESP266支撑单AP模式、单STA模式和混合模式。简单的来说就是：</p> 
<ul><li><strong>AP：可以将ESP8266作为热点，可以让其他的设备连接上它；</strong></li><li><strong>STA：可以连接上当前环境下的WIFI热点。</strong></li></ul> 
<p>2、什么是透传模式？</p> 
<p>透传就是指不需要关心wifi协议是如何实现的。所需要做的就是A通过串口发数据，B通过串口收数据，整个过程中A串口和B串口就像是用导线直接连接起来了一样。则对于开发人员来看，就是完全透明的。</p> 
<p>更简单地理解就是：</p> 
<p>如果不开启透传模式，我们怎么发送数据呢？在每次发送数据前都必须先发送指令AT+CIPSEND=&lt;param&gt;，例如：</p> 
<pre class="has"><code>AT+CIPSEND=4

OK
&gt;                //在 &gt; 后面输入要上传的数据</code></pre> 
<p>但是一旦开启了透传模式，我们就不需要在每次发送数据前都发送指令AT+CIPSEND=&lt;param&gt;了，只需要发送一次AT+CIPSEND，之后发送的所有内容全部当成是数据了！</p> 
<p>但是这也存在一个问题，要是我后来又想发送命令了，但是却也当成是数据发送过去了。这可怎么办？</p> 
<p>这就要退出透传模式了。<strong>怎么退出，发送数据"+++"就可以了。注意：此时“+++”后面，不接“发送新行”！</strong></p> 
<p> </p> 
<h3>WIFI模块的使用</h3> 
<h4>ESP8266的一般使用顺序</h4> 
<p>这里的“一般”指的是：ESP8266连接当前环境的热点，与服务器建立TCP连接，传输数据。</p> 
<ol><li><strong>AT+CWMODE=1：设置工作模式（STA模式）</strong></li><li><strong>AT+RST：模块重启（生效工作模式）</strong></li><li><strong>AT+CWJAP="111","11111111"：连接当前环境的WIFI热点（热点名，密码）</strong></li><li><strong>AT+CIPMUX=0：设置单路连接模式</strong></li><li><strong>AT+CIPSTART="TCP","xxx.xxx.xxx.xxx",xxxx：建立TCP连接</strong></li><li><strong>AT+CIPMODE=1：开启透传模式</strong></li><li><strong>AT+CIPSEND：透传模式下，传输数据</strong></li><li><strong>+++：退出透传模式</strong></li></ol> 
<h4>ESP8266的封装代码</h4> 
<p>关于与单片机的引脚连接：ESP8266与USART3（引脚PB10、PB11）连接。</p> 
<p>首先是USART的配置：</p> 
<pre class="has"><code class="language-cpp">#include "delay.h"
#include "usart3.h"
#include "stdarg.h"	 	 
#include "stdio.h"	 	 
#include "string.h"	 
#include "timer.h" 

//串口接收缓存区 	
u8 USART3_RX_BUF[USART3_MAX_RECV_LEN]; 				//接收缓冲,最大USART3_MAX_RECV_LEN个字节.
u8  USART3_TX_BUF[USART3_MAX_SEND_LEN]; 			//发送缓冲,最大USART3_MAX_SEND_LEN字节

//通过判断接收连续2个字符之间的时间差不大于10ms来决定是不是一次连续的数据.
//如果2个字符接收间隔超过10ms,则认为不是1次连续数据.也就是超过10ms没有接收到
//任何数据,则表示此次接收完毕.
//接收到的数据状态
//[15]:0,没有接收到数据;1,接收到了一批数据.
//[14:0]:接收到的数据长度
vu16 USART3_RX_STA=0;   	


void USART3_IRQHandler(void)
{
	u8 res;	      
	if(USART_GetITStatus(USART3, USART_IT_RXNE) != RESET)//接收到数据
	{	 
		res =USART_ReceiveData(USART3);		 
		if((USART3_RX_STA&amp;(1&lt;&lt;15))==0)//接收完的一批数据,还没有被处理,则不再接收其他数据
		{ 
			if(USART3_RX_STA&lt;USART3_MAX_RECV_LEN)	//还可以接收数据
			{
				TIM_SetCounter(TIM7,0);//计数器清空          				//计数器清空
				if(USART3_RX_STA==0) 				//使能定时器7的中断 
				{
					TIM_Cmd(TIM7,ENABLE);//使能定时器7
				}
				USART3_RX_BUF[USART3_RX_STA++]=res;	//记录接收到的值	 
			}else 
			{
				USART3_RX_STA|=1&lt;&lt;15;				//强制标记接收完成
			} 
		}
	}  				 											 
}   


//初始化IO 串口3
//pclk1:PCLK1时钟频率(Mhz)
//bound:波特率	  
void usart3_init(u32 bound)
{  

	NVIC_InitTypeDef NVIC_InitStructure;
	GPIO_InitTypeDef GPIO_InitStructure;
	USART_InitTypeDef USART_InitStructure;

	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);	// GPIOB时钟
	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3,ENABLE); //串口3时钟使能

 	USART_DeInit(USART3);  //复位串口3
		 //USART3_TX   PB10
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10; //PB10
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;	//复用推挽输出
  GPIO_Init(GPIOB, &amp;GPIO_InitStructure); //初始化PB10
   
    //USART3_RX	  PB11
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
  GPIO_Init(GPIOB, &amp;GPIO_InitStructure);  //初始化PB11
	
	USART_InitStructure.USART_BaudRate = bound;//波特率一般设置为9600;
	USART_InitStructure.USART_WordLength = USART_WordLength_8b;//字长为8位数据格式
	USART_InitStructure.USART_StopBits = USART_StopBits_1;//一个停止位
	USART_InitStructure.USART_Parity = USART_Parity_No;//无奇偶校验位
	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;//无硬件数据流控制
	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;	//收发模式
  
	USART_Init(USART3, &amp;USART_InitStructure); //初始化串口	3
  

	USART_Cmd(USART3, ENABLE);                    //使能串口 
	
	//使能接收中断
  USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);//开启中断   
	
	//设置中断优先级
	NVIC_InitStructure.NVIC_IRQChannel = USART3_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=2 ;//抢占优先级3
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;		//子优先级3
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
	NVIC_Init(&amp;NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
	
	
	TIM7_Int_Init(1000-1,7200-1);		//10ms中断
	USART3_RX_STA=0;		//清零
	TIM_Cmd(TIM7,DISABLE);			//关闭定时器7

}

//串口3,printf 函数
//确保一次发送数据不超过USART3_MAX_SEND_LEN字节
void u3_printf(char* fmt,...)  
{  
	u16 i,j; 
	va_list ap; 
	va_start(ap,fmt);
	vsprintf((char*)USART3_TX_BUF,fmt,ap);
	va_end(ap);
	i=strlen((const char*)USART3_TX_BUF);		//此次发送数据的长度
	for(j=0;j&lt;i;j++)							//循环发送数据
	{
	  while(USART_GetFlagStatus(USART3,USART_FLAG_TC)==RESET); //循环发送,直到发送完毕   
		USART_SendData(USART3,USART3_TX_BUF[j]); 
	} 
}</code></pre> 
<p>由于在USART3中是通过判断接收连续2个字符之间的时间差不大于10ms来决定是不是一次连续的数据，而10ms怎么定呢？通过定时器来的，所以我们需要开启定时器：</p> 
<pre class="has"><code class="language-cpp">#include "timer.h"

extern vu16 USART3_RX_STA;

//定时器7中断服务程序		    
void TIM7_IRQHandler(void)
{ 	
	if (TIM_GetITStatus(TIM7, TIM_IT_Update) != RESET)//是更新中断
	{	 			   
		USART3_RX_STA|=1&lt;&lt;15;	//标记接收完成
		TIM_ClearITPendingBit(TIM7, TIM_IT_Update  );  //清除TIM7更新中断标志    
		TIM_Cmd(TIM7, DISABLE);  //关闭TIM7 
	}	    
}
 
//通用定时器7中断初始化，这里时钟选择为APB1的2倍
//arr：自动重装值 psc：时钟预分频数
//定时器溢出时间计算方法:Tout=((arr+1)*(psc+1))/Ft us.
//Ft=定时器工作频率,单位:Mhz 
//通用定时器中断初始化 
void TIM7_Int_Init(u16 arr,u16 psc)
{	
	NVIC_InitTypeDef NVIC_InitStructure;
	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;

	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM7, ENABLE);//TIM7时钟使能    
	
	//定时器TIM7初始化
	TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值	
	TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值
	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1; //设置时钟分割:TDTS = Tck_tim
	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式
	TIM_TimeBaseInit(TIM7, &amp;TIM_TimeBaseStructure); //根据指定的参数初始化TIMx的时间基数单位
 
	TIM_ITConfig(TIM7,TIM_IT_Update,ENABLE ); //使能指定的TIM7中断,允许更新中断
	
	TIM_Cmd(TIM7,ENABLE);//开启定时器7
	
	NVIC_InitStructure.NVIC_IRQChannel = TIM7_IRQn;
	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=0 ;//抢占优先级0
	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;		//子优先级2
	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;			//IRQ通道使能
	NVIC_Init(&amp;NVIC_InitStructure);	//根据指定的参数初始化VIC寄存器
	
}</code></pre> 
<p>这两个都完成了之后，就可以向ESP8266传输数据了：</p> 
<pre class="has"><code class="language-cpp">#include "esp8266.h"
#include "string.h"
#include "usart.h"
#include "usart3.h"
#include "stm32f10x.h"
#include "sys.h" 
#include "delay.h"

//ESP8266模块和PC进入透传模式
void esp8266_start_trans(void)
{
	//设置工作模式 1：station模式   2：AP模式  3：兼容 AP+station模式
	esp8266_send_cmd("AT+CWMODE=1","OK",50);
	
	//让Wifi模块重启的命令
	esp8266_send_cmd("AT+RST","ready",20);
	
	delay_ms(1000);         //延时3S等待重启成功
	delay_ms(1000);
	delay_ms(1000);
	delay_ms(1000);
	
	//让模块连接上自己的路由
	while(esp8266_send_cmd("AT+CWJAP=\"111\",\"11111111\"","WIFI GOT IP",600));
	
	//=0：单路连接模式     =1：多路连接模式
	esp8266_send_cmd("AT+CIPMUX=0","OK",20);
	
	//建立TCP连接  这四项分别代表了 要连接的ID号0~4   连接类型  远程服务器IP地址   远程服务器端口号
	while(esp8266_send_cmd("AT+CIPSTART=\"TCP\",\"xxx.xxx.xxx.xxx\",xxxx","CONNECT",200));
	
	//是否开启透传模式  0：表示关闭 1：表示开启透传
	esp8266_send_cmd("AT+CIPMODE=1","OK",200);
	
	//透传模式下 开始发送数据的指令 这个指令之后就可以直接发数据了
	esp8266_send_cmd("AT+CIPSEND","OK",50);
}

//ESP8266退出透传模式   返回值:0,退出成功;1,退出失败
//配置wifi模块，通过想wifi模块连续发送3个+（每个+号之间 超过10ms,这样认为是连续三次发送+）
u8 esp8266_quit_trans(void)
{
	u8 result=1;
	u3_printf("+++");
	delay_ms(1000);					//等待500ms太少 要1000ms才可以退出
	result=esp8266_send_cmd("AT","OK",20);//退出透传判断.
	if(result)
		printf("quit_trans failed!");
	else
		printf("quit_trans success!");
	return result;
}


//向ESP8266发送命令
//cmd:发送的命令字符串;ack:期待的应答结果,如果为空,则表示不需要等待应答;waittime:等待时间(单位:10ms)
//返回值:0,发送成功(得到了期待的应答结果);1,发送失败
u8 esp8266_send_cmd(u8 *cmd,u8 *ack,u16 waittime)
{
	u8 res=0; 
	USART3_RX_STA=0;
	u3_printf("%s\r\n",cmd);	//发送命令
	if(ack&amp;&amp;waittime)		//需要等待应答
	{
		while(--waittime)	//等待倒计时
		{
			delay_ms(10);
			if(USART3_RX_STA&amp;0X8000)//接收到期待的应答结果
			{
				if(esp8266_check_cmd(ack))
				{
					printf("ack:%s\r\n",(u8*)ack);
					break;//得到有效数据 
				}
					USART3_RX_STA=0;
			} 
		}
		if(waittime==0)res=1; 
	}
	return res;
} 


//ESP8266发送命令后,检测接收到的应答
//str:期待的应答结果
//返回值:0,没有得到期待的应答结果;其他,期待应答结果的位置(str的位置)
u8* esp8266_check_cmd(u8 *str)
{
	char *strx=0;
	if(USART3_RX_STA&amp;0X8000)		//接收到一次数据了
	{ 
		USART3_RX_BUF[USART3_RX_STA&amp;0X7FFF]=0;//添加结束符
		strx=strstr((const char*)USART3_RX_BUF,(const char*)str);
	} 
	return (u8*)strx;
}

//向ESP8266发送数据
//cmd:发送的命令字符串;waittime:等待时间(单位:10ms)
//返回值:发送数据后，服务器的返回验证码
u8* esp8266_send_data(u8 *cmd,u16 waittime)
{
	char temp[5];
	char *ack=temp;
	USART3_RX_STA=0;
	u3_printf("%s",cmd);	//发送命令
	if(waittime)		//需要等待应答
	{
		while(--waittime)	//等待倒计时
		{
			delay_ms(10);
			if(USART3_RX_STA&amp;0X8000)//接收到期待的应答结果
			{
				USART3_RX_BUF[USART3_RX_STA&amp;0X7FFF]=0;//添加结束符
				ack=(char*)USART3_RX_BUF;
				printf("ack:%s\r\n",(u8*)ack);
				USART3_RX_STA=0;
				break;//得到有效数据 
			} 
		}
	}
	return (u8*)ack;
} </code></pre> 
<p>最后是主程序：</p> 
<pre class="has"><code class="language-cpp">#include "delay.h"
#include "sys.h"
#include "usart.h"
#include "usart3.h"
#include "esp8266.h"
#include "string.h"
#include "timer.h"
 
/*
项目的主要内容：STM32配合ESP8266模块与服务器数据交互

ESP8266的连接：USART3（PB10、PB11）

如何判断数据接收完全？
1、出现了换行符；
2、如果超过10ms了都没有下一条数据（TIM7来进行10ms的定时）。
*/


 int main(void)
 {		
	delay_init();	    	 			//延时函数初始化	  
	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2); 			//设置NVIC中断分组2:2位抢占优先级，2位响应优先级
	uart_init(115200);	 				//串口初始化为115200
	usart3_init(115200);	 				//串口初始化为115200

	esp8266_start_trans();							//esp8266进行初始化
	 
	esp8266_send_data("12",50);
	 
	esp8266_quit_trans();

 	while(1)
	{
		
	}
 }</code></pre> 
<p><strong>完整项目链接：</strong></p> 
<p>百度云盘链接: https://pan.baidu.com/s/1LKjJL06fHyt1O5p9Jxmbig 提取码: p8yn </p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/e2/52/RLp4fFAD_o.jpg"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f8d49212f1ad4d31275efb1264e8eb5f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kafka SASL/SCRAM&#43;ACL实现动态创建用户及权限控制</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2e969c0e540d2635f9afd273e200a1f7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">155、最小栈</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>