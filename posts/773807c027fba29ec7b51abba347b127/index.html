<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#线程详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#线程详解" />
<meta property="og:description" content="每个正在操作系统中运行的应用程序都是一个进程，一个进程可以包括一个或多个线程。线程是操作系统分配处理器时间的基本单元。进程就好像是一个公司，公司中的每个员工就相当于线程，公司想要运行就必须得有负责人，负责人就相当于主线程。
单线程 单线程就是只有一个线程。默认情况下，系统为应用程序分配一个主线程，该线程执行程序中以Main方法开始和结束的代码。
多线程 需要用户交互的软件都必须尽可能的对用户的活动做出反应，以便提供更丰富的用户体验。但同时它又必须执行必要的计算，以便尽可能快的将数据呈现给用户，这时就要使用多线程。
优点：要提供对用户的响应速度并且处理所需数据，以便同时完成工作，使用多线程是一种强大的技术。多线程可以通过利用用户事件之间很小的时间段在后台处理数据来达到这种效果。
Thread类 Thread类位于System.Threading命名空间下，System.Threading命名空间提供一些可以进行多线程编程的类和接口。Thread类主要用于创建并控制线程、设置线程优先级并获取其状态。
Thread类的常用属性及说明 属性说明ApartmentState获取或设置该线程的单元状态CurrentContext获取线程正在其中执行的当前上下文CurrentThread获取当前线程正在运行的线程IsAlive获取一个值，该值指示当前线程的执行状态ManagedThreadld获取当前托管线程的唯一标识符Name获取或设置线程的名称Priority获取或设置一个值，改制指示线程的调度优先级ThreadState获取一个值，该值包含当前线程的状态 Thread类的常用属性及说明 方法说明Abort在调用该方法的线程上引发ThreadAbortException，以开始终止该线程的过程。调用该方法通常会终止线程GetApartmentState返回一个ApartmentState值，该值指示单元状态GetDomain返回当前线程正在其中运行的当前域GetDomainID返回唯一的应用程序标识符Interrupt中断处于WaitSleepJoin线程状态的线程Join阻止调用线程，直到某个线程终止时为止ResetAbort取消为当前线程请求的AbortResume继续已挂起的线程SetpartmentState在线程启动前设置其单元状态Sleep将当前线程阻止指定的毫秒数SpainWait导致线程等待由iterations参数定义的时间量Start使线程被安排进行执行Suapent挂起线程，或者如果线程已挂起，则不起作用VolatileRead读取字段值。无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值VolatileWrite立即向字段写入一个值，一边该值对计算机中的所有处理器都可见 演示使用Thread类的相关方法：
namespace Thread3 { public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void Form1_Load(object sender, EventArgs e) { string strInfo = string.Empty;//定义一个空字符串，用来记录线程相关信息 Thread myThread = new Thread(new ThreadStart(threadOut));//实例化Thread线程类对象 myThread.Start(); //启动主线程 //获取线程相关信息 strInfo &#43;= &#34;线程唯一标识符：&#34; &#43; myThread.ManagedThreadId; strInfo &#43;= &#34;\n线程名称：&#34; &#43; myThread.Name; strInfo &#43;= &#34;\n线程状态：&#34; &#43; myThread.ThreadState.ToString(); strInfo &#43;= &#34;\n线程优先级;&#34; &#43; myThread.Priority.ToString(); strInfo &#43;= &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/773807c027fba29ec7b51abba347b127/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-23T14:57:59+08:00" />
<meta property="article:modified_time" content="2023-09-23T14:57:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#线程详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="color:#0d0016;">每个正在操作系统中运行的应用程序都是一个进程，一个进程可以包括一个或多个线程。线程是操作系统分配处理器时间的基本单元。</span><span style="color:#0d0016;">进程就好像是一个公司，公司中的每个员工就相当于线程，公司想要运行就必须得有负责人，负责人就相当于主线程。</span></p> 
<h3 id="%E5%8D%95%E7%BA%BF%E7%A8%8B%C2%A0"><span style="color:#0d0016;">单线程 </span></h3> 
<p><span style="color:#0d0016;">单线程就是只有一个线程。默认情况下，系统为应用程序分配一个主线程，该线程执行程序中以Main方法开始和结束的代码。</span></p> 
<h3 id="%E5%A4%9A%E7%BA%BF%E7%A8%8B%C2%A0"><span style="color:#0d0016;">多线程  </span></h3> 
<p><span style="color:#0d0016;">需要用户交互的软件都必须尽可能的对用户的活动做出反应，以便提供更丰富的用户体验。但同时它又必须执行必要的计算，以便尽可能快的将数据呈现给用户，这时就要使用多线程。</span></p> 
<p>优点：要提供对用户的响应速度并且处理所需数据，以便同时完成工作，使用多线程是一种强大的技术。多线程可以通过利用用户事件之间很小的时间段在后台处理数据来达到这种效果。</p> 
<h3 id="Thread%E7%B1%BB"><span style="color:#0d0016;">Thread类</span></h3> 
<p><span style="color:#0d0016;">Thread类位于System.Threading命名空间下，System.Threading命名空间提供一些可以进行多线程编程的类和接口。Thread类主要用于创建并控制线程、设置线程优先级并获取其状态。</span></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:700px;"><caption> 
  <span style="color:#0d0016;">Thread类的常用属性及说明</span> 
 </caption><tbody><tr><td><span style="color:#0d0016;">属性</span></td><td><span style="color:#0d0016;">说明</span></td></tr><tr><td><span style="color:#0d0016;">ApartmentState</span></td><td><span style="color:#0d0016;">获取或设置该线程的单元状态</span></td></tr><tr><td><span style="color:#0d0016;">CurrentContext</span></td><td><span style="color:#0d0016;">获取线程正在其中执行的当前上下文</span></td></tr><tr><td><span style="color:#0d0016;">CurrentThread</span></td><td><span style="color:#0d0016;">获取当前线程正在运行的线程</span></td></tr><tr><td><span style="color:#0d0016;">IsAlive</span></td><td><span style="color:#0d0016;">获取一个值，该值指示当前线程的执行状态</span></td></tr><tr><td><span style="color:#0d0016;">ManagedThreadld</span></td><td><span style="color:#0d0016;">获取当前托管线程的唯一标识符</span></td></tr><tr><td><span style="color:#0d0016;">Name</span></td><td><span style="color:#0d0016;">获取或设置线程的名称</span></td></tr><tr><td><span style="color:#0d0016;">Priority</span></td><td><span style="color:#0d0016;">获取或设置一个值，改制指示线程的调度优先级</span></td></tr><tr><td><span style="color:#0d0016;">ThreadState</span></td><td><span style="color:#0d0016;">获取一个值，该值包含当前线程的状态</span></td></tr></tbody></table> 
<table border="1" cellpadding="1" cellspacing="1" style="width:700px;"><caption> 
  <span style="color:#0d0016;">Thread类的常用属性及说明</span> 
 </caption><tbody><tr><td><span style="color:#0d0016;">方法</span></td><td><span style="color:#0d0016;">说明</span></td></tr><tr><td><span style="color:#0d0016;">Abort</span></td><td><span style="color:#0d0016;">在调用该方法的线程上引发ThreadAbortException，以开始终止该线程的过程。调用该方法通常会终止线程</span></td></tr><tr><td><span style="color:#0d0016;">GetApartmentState</span></td><td><span style="color:#0d0016;">返回一个ApartmentState值，该值指示单元状态</span></td></tr><tr><td><span style="color:#0d0016;">GetDomain</span></td><td><span style="color:#0d0016;">返回当前线程正在其中运行的当前域</span></td></tr><tr><td><span style="color:#0d0016;">GetDomainID</span></td><td><span style="color:#0d0016;">返回唯一的应用程序标识符</span></td></tr><tr><td><span style="color:#0d0016;">Interrupt</span></td><td><span style="color:#0d0016;">中断处于WaitSleepJoin线程状态的线程</span></td></tr><tr><td><span style="color:#0d0016;">Join</span></td><td><span style="color:#0d0016;">阻止调用线程，直到某个线程终止时为止</span></td></tr><tr><td><span style="color:#0d0016;">ResetAbort</span></td><td><span style="color:#0d0016;">取消为当前线程请求的Abort</span></td></tr><tr><td><span style="color:#0d0016;">Resume</span></td><td><span style="color:#0d0016;">继续已挂起的线程</span></td></tr><tr><td><span style="color:#0d0016;">SetpartmentState</span></td><td><span style="color:#0d0016;">在线程启动前设置其单元状态</span></td></tr><tr><td><span style="color:#0d0016;">Sleep</span></td><td><span style="color:#0d0016;">将当前线程阻止指定的毫秒数</span></td></tr><tr><td><span style="color:#0d0016;">SpainWait</span></td><td><span style="color:#0d0016;">导致线程等待由iterations参数定义的时间量</span></td></tr><tr><td><span style="color:#0d0016;">Start</span></td><td><span style="color:#0d0016;">使线程被安排进行执行</span></td></tr><tr><td><span style="color:#0d0016;">Suapent</span></td><td><span style="color:#0d0016;">挂起线程，或者如果线程已挂起，则不起作用</span></td></tr><tr><td><span style="color:#0d0016;">VolatileRead</span></td><td><span style="color:#0d0016;">读取字段值。无论处理器的数目或处理器缓存的状态如何，该值都是由计算机的任何处理器写入的最新值</span></td></tr><tr><td><span style="color:#0d0016;">VolatileWrite</span></td><td><span style="color:#0d0016;">立即向字段写入一个值，一边该值对计算机中的所有处理器都可见</span></td></tr></tbody></table> 
<p><span style="color:#0d0016;"><strong>演示使用Thread类的相关方法：</strong></span></p> 
<pre><code class="language-cs">namespace Thread3
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            string strInfo = string.Empty;//定义一个空字符串，用来记录线程相关信息
            Thread myThread = new Thread(new ThreadStart(threadOut));//实例化Thread线程类对象
            myThread.Start();      //启动主线程
            //获取线程相关信息
            strInfo += "线程唯一标识符：" + myThread.ManagedThreadId;
            strInfo += "\n线程名称：" + myThread.Name;
            strInfo += "\n线程状态：" + myThread.ThreadState.ToString();
            strInfo += "\n线程优先级;" + myThread.Priority.ToString();
            strInfo += "\n是否为后台线程：" + myThread.IsBackground;
            Thread.Sleep(1000);                                       //使主线程休眠1秒
            myThread.Abort("退出");                                   //通过主线程阻止新开线程
            myThread.Join();                                          //等待新开线程结束
            MessageBox.Show("线程运行结束");
            richTextBox1.Text = strInfo;
        }
        public void threadOut()
        {
            MessageBox.Show("主线程开始运行");
        }
    }
}</code></pre> 
<p><span style="color:#0d0016;">运行结果：</span></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><img alt="" class="left" height="22" src="https://images2.imgbox.com/77/fd/c3ZHm9Ys_o.jpg" width="100"><img alt="" class="left" height="111" src="https://images2.imgbox.com/e8/2b/WAhmAXtQ_o.jpg" width="100"> <img alt="" class="left" height="300" src="https://images2.imgbox.com/9e/c5/GMsckkEP_o.jpg" width="200"> </span></p> 
<p style="text-align:center;"></p> 
<h3 id="%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B"><span style="color:#0d0016;">创建线程</span></h3> 
<p style="margin-left:.0001pt;"><span style="color:#0d0016;">创建一个线程非常简单，只需要将其声明并为其提供线程起始点处的委托即可。创建新的线程时，需要使用Thread类，该类具有接受一个ThreadStart委托或ParameterizedThreadStart委托的构造函数。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">线程中为什么要使用委托ThreatStart：<a class="link-info" href="http://www.cnblogs.com/lvdongjie/p/5469274.html" rel="nofollow" title="http://www.cnblogs.com/lvdongjie/p/5469274.html">http://www.cnblogs.com/lvdongjie/p/5469274.html</a></span></p> 
<h4 id="ThreadStart%EF%BC%9A%E7%94%A8%E4%BA%8E%E6%97%A0%E8%BF%94%E5%9B%9E%E5%80%BC%E3%80%81%E6%97%A0%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95" style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">ThreadStart：用于无返回值、无参数的方法</span></h4> 
<pre><code class="language-cs">namespace Thread1
{
    class Program
    {
        static void Main(string[] args)
        {
            //创建ThreadStart委托实例
            ThreadStart TS = new ThreadStart(MyThread);
            Console.WriteLine("Create the main thread");
            //创建Thread类的实例
            Thread thread = new Thread(TS);
            thread.Start();
        }

        //线程函数
        static void MyThread()
        {
            Console.WriteLine("Child start Thread...");
            Thread.Sleep(1000);
            Console.WriteLine("Thread is over...");
        }
    }
}</code></pre> 
<p><span style="color:#0d0016;">运行结果：</span></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/26/d4/o7MU7FBz_o.jpg"></p> 
<h4 id="%C2%A0ParameterizedThreadStart%3A%E7%94%A8%E4%BA%8E%E5%B8%A6%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E6%B3%95"> <span style="color:#000000;">ParameterizedThreadStart:用于带参数的方法</span></h4> 
<pre><code class="language-cs">namespace Thread1
{
    class Program
    {
        static void Main(string[] args)
        {
            //创建线程委托实例
            ParameterizedThreadStart pts = new ParameterizedThreadStart(MyThread);
            Console.WriteLine(" Creating the Child thread");

            //创建线程对象
            Thread thread = new Thread(pts);
            thread.Start(10);
            Console.ReadKey();
        }
        private static void MyThread(object n)
        {
            Console.WriteLine("Thread started ...");
            for(int i = 0;i &lt;= (int)n; i+=2)
            {
                Console.WriteLine(i);
            }
        }
    }
}</code></pre> 
<p>运行结果：</p> 
<p style="text-align:center;"><img alt="" height="184" src="https://images2.imgbox.com/dd/1d/FbNy4WoB_o.jpg" width="200"></p> 
<p style="text-align:center;"></p> 
<h3 id="%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8C%82%E8%B5%B7%E5%92%8C%E6%81%A2%E5%A4%8D"><span style="color:#0d0016;">线程的挂起和恢复</span></h3> 
<p style="margin-left:.0001pt;"><span style="color:#000000;">创建完一个线程并启动后，还可以挂起、恢复、休眠或终止它。线程的挂起与恢复可以通过调用Thread类的Suspend方法和Resume方法实现。</span></p> 
<ol><li><span style="color:#000000;">Suspend方法</span></li></ol> 
<p style="margin-left:.0001pt;"><span style="color:#000000;">public void Suspend();</span></p> 
<p style="margin-left:.0001pt;"><span style="color:#000000;">该方法用来挂起线程,如果线程已挂起，则不起作用。调用Suspend方法挂起线程时，.NET允许挂起的线程再执行几个指令，目的是为了到达.NET认为线程可以安全挂起的状态。</span></p> 
<ol><li><span style="color:#000000;">Resume方法</span></li></ol> 
<p style="margin-left:.0001pt;"><span style="color:#000000;">public void Resume();</span></p> 
<p style="margin-left:.0001pt;"><span style="color:#000000;">该方法用来继续已挂起的线程。通过Resume方法来恢复被暂停的线程时，无论调用多少次Suspend方法，调用Resume方法均会使另一个线程脱离挂起状态。</span></p> 
<pre><code class="language-cs">namespace Thread1
{
    class Program
    {
        static void Main(string[] args)
        {
            Thread myThread;                            //声明线程
            //用线程起始点的ThreadStart委托创建该线程的实例
            myThread = new Thread(new ThreadStart(createThread));
            myThread.Start();                            //启动线程
            myThread.Suspend();                          //挂起线程
            myThread.Resume();                           //恢复挂起的线程
           
        }
        private static void createThread()
        {
            Console.WriteLine("创建线程");
        }
    }
}</code></pre> 
<p></p> 
<h3 id="%E7%BA%BF%E7%A8%8B%E4%BC%91%E7%9C%A0"><span style="color:#0d0016;">线程休眠</span></h3> 
<p><span style="color:#000000;">线程休眠主要通过Thread类的Sleep方法实现。该方法用来将线程阻止指定的时间。</span></p> 
<pre><code class="language-cs">namespace Thread4
{
    class Program
    {
        static void Main(string[] args)
        {
            ThreadStart ts = new ThreadStart(ChildThread);//创建一个线程的委托
            Console.WriteLine("创建子线程");
            Thread thread = new Thread(ts);
            thread.Start();
            Console.ReadKey();
        }
        public  static void ChildThread()
        {
            Console.WriteLine("子线程启动");
            int SleepTime = 2000;
            Console.WriteLine("子线程休眠{0}秒", SleepTime / 1000);
            Thread.Sleep(SleepTime);
            Console.WriteLine("子线程恢复");
        }
    }
}</code></pre> 
<p>运行结果：</p> 
<p class="img-center"><img alt="" height="144" src="https://images2.imgbox.com/f1/8c/Dxp3tyGn_o.jpg" width="150"></p> 
<h3 id="%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span style="color:#0d0016;">终止线程</span></h3> 
<p><span style="color:#000000;">1. Abort方法</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">Abort方法用来终止线程，它有两种重载形式：</span></p> 
<p style="text-align:justify;"><span style="color:#000000;">               （1）终止线程，在调用该方法的线程上引发ThreadAbortException异常，以开始终止该线程：             public void Abort();</span></p> 
<p style="text-align:justify;"><span style="color:#000000;">               （2）终止线程，在调用该方法的线程上引发ThreadAbortException异常，以开始终止该线程并提供有关线程终止的异常信息的过程：</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#000000;">                public void Abort(Object stateInfo)</span></p> 
<pre><code class="language-cs">namespace Thread5
{
    class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("主线程启动");
            //创建一个线程委托实例
            ThreadStart ts = new ThreadStart(ChildThread);
            Console.WriteLine("创建子线程");

            Thread thread = new Thread(ts);//创建线程对象
            thread.Start();//启动线程
            Thread.Sleep(2000);//主线程休眠

            Console.WriteLine("终止子线程");
            thread.Abort();//线程终止
            Console.ReadKey();
        }
        public static void ChildThread()
        {
            try
            {
                Console.WriteLine("子线程启动");
                //打印20以内的偶数
                for (int i = 0; i &lt;= 20; i += 2)
                {
                    Thread.Sleep(500);//线程休眠1s
                    Console.WriteLine(i);
                }
                Console.WriteLine("子线程完成");
            }
            catch
            {
                Console.WriteLine("线程中止异常");
            }
            finally
            {
                Console.WriteLine("捕获异常信息");
            }
        }
    }
}</code></pre> 
<p>运行结果：</p> 
<p class="img-center"><img alt="" height="116" src="https://images2.imgbox.com/61/76/y1d5jAuD_o.jpg" width="150"></p> 
<p>2<span style="color:#0d0016;">. Join  方法</span></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:700px;"><tbody><tr><td><span style="color:#0d0016;">Join()</span></td><td style="width:396px;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;"><span style="background-color:#ffffff;">在继续执行标准的 COM 和 </span>SendMessage<span style="background-color:#ffffff;"> 消息泵处理期间，阻止调用线程，直到由该实例表示的线程终止。</span></span></p> </td></tr><tr><td><span style="color:#0d0016;">Join(int 32)</span></td><td style="width:396px;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">在继续执行标准的 COM 和 SendMessage 消息泵处理期间，阻止调用线程，直到由该实例表示的线程终止或经过了指定时间为止</span></p> </td></tr><tr><td><span style="color:#0d0016;">Join(TimeSpan)</span></td><td style="width:396px;"> <p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;"><span style="background-color:#ffffff;">在继续执行标准的 COM 和 SendMessage 消息泵处理期间，阻止调用线程，直到由该实例表示的线程终止或经过了指定时间为止。</span></span></p> </td></tr></tbody></table> 
<p><span style="color:#0d0016;"><strong>Join():</strong></span></p> 
<pre><code class="language-cs">public class Example
{
    static Thread thread1, thread2;

    public static void Main()
    {
        thread1 = new Thread(ThreadProc);
        thread1.Name = "Thread1";
        thread1.Start();

        thread2 = new Thread(ThreadProc);
        thread2.Name = "Thread2";
        thread2.Start();
    }

    private static void ThreadProc()
    {
        Console.WriteLine("\nCurrent thread: {0}", Thread.CurrentThread.Name);
        if (Thread.CurrentThread.Name == "Thread1" &amp;&amp;
            thread2.ThreadState != ThreadState.Unstarted)
            thread2.Join();

        Thread.Sleep(4000);
        Console.WriteLine("\nCurrent thread: {0}", Thread.CurrentThread.Name);
        Console.WriteLine("Thread1: {0}", thread1.ThreadState);
        Console.WriteLine("Thread2: {0}\n", thread2.ThreadState);
    }
}</code></pre> 
<p><span style="color:#0d0016;">运行结果:</span></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><img alt="" height="189" src="https://images2.imgbox.com/31/df/AyVQCik2_o.jpg" width="200"></span></p> 
<p><span style="color:#0d0016;"> 建议去官网看对join（）方法的详细解释：<a class="link-info" href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.thread.join?view=netframework-4.8" rel="nofollow" title="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.thread.join?view=netframework-4.8">https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.thread.join?view=netframework-4.8</a></span></p> 
<h3 id="%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span style="color:#0d0016;">线程优先级</span></h3> 
<p><span style="color:#0d0016;">线程的优先级指定一个线程相对于另一个线程的相对优先级。每个线程都有一个分配的优先级。线程是根据其优先级而调度执行的。</span></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:700px;"><caption> 
  <span style="color:#0d0016;">线程的优先级值及说明</span> 
 </caption><tbody><tr><td><span style="color:#0d0016;">优先级值</span></td><td><span style="color:#0d0016;">说明</span></td></tr><tr><td><span style="color:#0d0016;">AboveNormal</span></td><td><span style="color:#0d0016;">可以将Thread安排在具有Highest优先级的线程之后，在具有Normal优先级的线程之前</span></td></tr><tr><td><span style="color:#0d0016;">BelowNormal</span></td><td><span style="color:#0d0016;">可以将Thread安排在具有Normal优先级的线程之后，在具有Lowest优先级的线程之前</span></td></tr><tr><td><span style="color:#0d0016;">Highest</span></td><td><span style="color:#0d0016;">可以将Thread安排在任何其他优先级的线程之前</span></td></tr><tr><td><span style="color:#0d0016;">Lowest</span></td><td><span style="color:#0d0016;">可以将Thread安排在任何其他优先级的线程之后</span></td></tr><tr><td><span style="color:#0d0016;">Normal</span></td><td><span style="color:#0d0016;">可以将Thread安排在具有AboveNormal优先级的线程之后，在具有Below Normal优先级的线程之前。默认情况下，线程具有Normal优先级</span></td></tr></tbody></table> 
<pre><code class="language-cs">
//线程优先级
namespace Thread2
{
    class Program
    {
        static void Main(string[] args)
        {
            //因为下面要用到program类中的非静态函数，所以先创建该类对象
            Program program = new Program();
            //创建线程委托1
            ThreadStart ts1 = new ThreadStart(program.even);
            Console.WriteLine("In Main: Creating the thread1 thread.");

            //创建线程1的实例
            Thread thread1 = new Thread(ts1);

            //设置打印偶数优先级为最低
            thread1.Priority = ThreadPriority.Lowest;


            //创建线程委托2
            ThreadStart ts2 = new ThreadStart(program.odd);
            Console.WriteLine("In Main: Creating the thread2 thread.");

            //创建线程2的实例
            Thread thread2 = new Thread(ts2);

            //设置打印奇数优先级为最高
            thread2.Priority = ThreadPriority.Highest;

            thread1.Start();//偶数  低
            thread2.Start();//奇数  高

            Console.ReadKey();
        }

        //打印奇数
        public void odd()
        {
            
                Console.WriteLine("List of odd numbers: ");
                for (int i = 1; i &lt; 100; i += 2)
                {
                    Console.Write(i + " ");
                }
                Console.WriteLine();
            
        }
        //打印偶数
        public void even()
        {
           
                Console.WriteLine("List of even numbers: ");
                for (int i = 0; i &lt; 100; i += 2)
                {
                    Console.Write(i + " ");

                }
                Console.WriteLine();
            }
        
    }
}
</code></pre> 
<p><span style="color:#0d0016;">运行结果：</span></p> 
<p><span style="color:#0d0016;">第一次：</span></p> 
<p><span style="color:#0d0016;"><img alt="" class="left" height="150" src="https://images2.imgbox.com/9a/b3/bQSTNLm1_o.jpg" width="500"></span></p> 
<p><span style="color:#0d0016;">第二次：</span></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><img alt="" src="https://images2.imgbox.com/da/7e/zznkyZcp_o.jpg"></span></p> 
<p><span style="color:#0d0016;">第三次： </span></p> 
<p style="text-align:center;"><span style="color:#0d0016;"> <img alt="" class="left" height="150" src="https://images2.imgbox.com/26/6f/3CYLMCRq_o.jpg" width="828"></span></p> 
<p><span style="color:#0d0016;"> 从上面的运行效果可以看出，由于输岀奇数的线程的优先级高于输出偶数的线程，所以在输出结果中优先输出奇数的次数会更多。</span></p> 
<h3 id="%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5"><span style="color:#0d0016;">线程同步</span></h3> 
<h4 id="lock%3A"><span style="color:#0d0016;">lock:</span></h4> 
<p><span style="color:#0d0016;">        lock关键字可以用来确保代码块完整运行，而不会被其他线程中断，它是通过在代码块运行期间为给定对象获取互斥锁来实现。</span></p> 
<pre><code class="language-cs">using System;
using System.Threading;

//线程优先级
namespace Thread2
{
    class Program
    {
        static void Main(string[] args)
        {
            //因为下面要用到program类中的非静态函数，所以先创建该类对象
            Program program = new Program();
            //创建线程委托1
            ThreadStart ts1 = new ThreadStart(program.even);
            Console.WriteLine("In Main: Creating the thread1 thread.");

            //创建线程1的实例
            Thread thread1 = new Thread(ts1);

            //设置打印偶数优先级为最低
            thread1.Priority = ThreadPriority.Lowest;


            //创建线程委托2
            ThreadStart ts2 = new ThreadStart(program.odd);
            Console.WriteLine("In Main: Creating the thread2 thread.");

            //创建线程2的实例
            Thread thread2 = new Thread(ts2);

            //设置打印奇数优先级为最高
            thread2.Priority = ThreadPriority.Highest;

            thread1.Start();//偶数  低
            thread2.Start();//奇数  高

            Console.ReadKey();
        }

        //打印奇数
        public void odd()
        {
            lock (this)
            {
                Console.WriteLine("List of odd numbers: ");
                for (int i = 1; i &lt; 100; i += 2)
                {
                    Console.Write(i + " ");
                }
                Console.WriteLine();
            }
        }
        //打印偶数
        public void even()
        {
            lock (this)
            {
                Console.WriteLine("List of even numbers: ");
                for (int i = 0; i &lt; 100; i += 2)
                {
                    Console.Write(i + " ");

                }
                Console.WriteLine();
            }
        }
    }
}
</code></pre> 
<p><span style="color:#0d0016;">运行结果：</span></p> 
<p style="text-align:center;"><span style="color:#0d0016;"><img alt="" height="126" src="https://images2.imgbox.com/0a/3e/opdmrltY_o.jpg" width="300"></span></p> 
<h4 id="%C2%A0Monitor%EF%BC%9A"><span style="color:#0d0016;"> Monitor：</span></h4> 
<p><span style="color:#0d0016;">                Monitor类提供了同步对象的访问机制，他通过向单个线程授予对象锁来控制对象的访问，对象锁提供限制访问代码块的能力。当一个线程拥有对象锁时，其他线程都不能获取该锁。</span></p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">Monitor类的主要功能：</span></p> 
<ol><li style="text-align:justify;"><span style="color:#0d0016;">它根据需要与某个对象相关联</span></li><li style="text-align:justify;"><span style="color:#0d0016;">他是未绑定的，可以直接从任何上下文调用它</span></li><li style="text-align:justify;"><span style="color:#0d0016;">不能创建Monitor类的实例</span></li></ol> 
<table border="1" cellpadding="1" cellspacing="1" style="width:700px;"><caption> 
  <span style="color:#0d0016;">Monitor类的常用方法及说明</span> 
 </caption><tbody><tr><td><span style="color:#0d0016;">方法</span></td><td><span style="color:#0d0016;">说明</span></td></tr><tr><td><span style="color:#0d0016;">Enter</span></td><td><span style="color:#0d0016;">在指定对象上获取排他锁</span></td></tr><tr><td><span style="color:#0d0016;">Exit</span></td><td><span style="color:#0d0016;">释放指定对象上的排他锁</span></td></tr><tr><td><span style="color:#0d0016;">Pulse</span></td><td><span style="color:#0d0016;">通知等待队列上的线程锁定对象状态的更改</span></td></tr><tr><td><span style="color:#0d0016;">PulseAll</span></td><td><span style="color:#0d0016;">通过所有的等待线程对象状态的更改</span></td></tr><tr><td><span style="color:#0d0016;">TryEnter</span></td><td><span style="color:#0d0016;">试图获取指定对象的排他锁</span></td></tr><tr><td><span style="color:#0d0016;">Wait</span></td><td><span style="color:#0d0016;">释放对象上的锁并阻止当前线程，直到它重新获取该锁</span></td></tr></tbody></table> 
<pre><code class="language-cs">namespace Thread4
{
    class Program
    {
        static void Main(string[] args)
        {
            Program myProgarm = new Program();//实例化对象
            myProgarm.LockThread();           //调用锁定线程方法
         
        }
        void LockThread()
        {
            Monitor.Enter(this);             //锁定当前线程
            Console.WriteLine("锁定当前线程以实现线程同步");
            Monitor.Exit(this);              //释放当前线程
        }
       
    }
}</code></pre> 
<h4 id="Mutex%EF%BC%9A"><span style="color:#0d0016;">Mutex：</span></h4> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#0d0016;">当两个或更多线程同时访问一个共享资源时，系统需要使用同步机制来确保一次只有一个线程使用该资源。Mutex类是同步基元，他向一个线程授予对共享资源的独占访问权。如果一个线程获取了互斥体，则要获取该互斥体的第二个线程将被挂起，知道第一个线程释放该互斥体。</span></p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:700px;"><caption> 
  <span style="color:#0d0016;">Mutex类的常用方法及说明</span> 
 </caption><tbody><tr><td><span style="color:#0d0016;">方法</span></td><td><span style="color:#0d0016;">说明</span></td></tr><tr><td><span style="color:#0d0016;">Close</span></td><td><span style="color:#0d0016;">在派生类中被重写时，释放当前Waithandle持有的所有资源</span></td></tr><tr><td><span style="color:#0d0016;">OpenExisting</span></td><td><span style="color:#0d0016;">打开现有的已命名互斥体</span></td></tr><tr><td><span style="color:#0d0016;">ReleaseMutex</span></td><td><span style="color:#0d0016;">释放Mutex一次</span></td></tr><tr><td><span style="color:#0d0016;">SignalAndWait</span></td><td><span style="color:#0d0016;">原子操作的形式，向一个WaitHandle发出信号并等待另一个</span></td></tr><tr><td><span style="color:#0d0016;">WaitAll</span></td><td><span style="color:#0d0016;">等待指定数组中的所有元素都收到信号</span></td></tr><tr><td><span style="color:#0d0016;">WaitAny</span></td><td><span style="color:#0d0016;">等待指定数组中的任一元素收到信号</span></td></tr><tr><td><span style="color:#0d0016;">WaitOne</span></td><td><span style="color:#0d0016;">当在派生类中重写时，阻止当前线程，直到当前的WaitHandle收到信号</span></td></tr></tbody></table> 
<pre><code class="language-cs">namespace Thread4
{
    class Program
    {
        static void Main(string[] args)
        {
            Program myProgarm = new Program();//实例化对象
            myProgarm.LockThread();           //调用锁定线程方法
         
        }
        void LockThread()
        {
            Mutex myMutex = new Mutex(false); //实例化mutex类对象
            myMutex.WaitOne();                //阻止当前线程
            Console.WriteLine("锁定线程以实现线程同步");
            myMutex.ReleaseMutex();           //释放Mutex类
        }
       
    }
}</code></pre> 
<h3>前台线程和后台线程</h3> 
<p>只有一个前台线程在运行，应用程序的进程就在运行，如果多个前台线程在运行，但是Main方法结束了，应用程序的进程仍然是运行的，直到所有的前台线程完成其任务为止。</p> 
<p>在默认情况下，用Thread类创建的线程是前台线程。线程池中的线程总是后台线程。在用Thread类创建线程的时候，可以设置IsBackground属性，表示它是一个前台线程还是一个后台线程。</p> 
<p>看下面例子中前台线程和后台线程的区别：</p> 
<pre><code class="language-cs">class Progrem{
    static void Main(){
        var t1 = new Thread(ThreadMain){IsBackground=false};
        t1.Start();
        Console.WriteLine("Main thread ending now.");
    }
    static void ThreadMain(){
        Console.WriteLine("Thread +" + Thread.CurrentThread.Name + "started");
        Thread.Sleep(3000);
        Console.WriteLine("Thread +" + Thread.CurrentThread.Name + "started");
    }
}

</code></pre> 
<p>后台线程用的地方: 如果关闭Word应用程序，拼写检查器继续运行就没有意义了，在关闭应用程序</p> 
<p>的时候，拼写检查线程就可以关闭。</p> 
<p></p> 
<h3>线程池</h3> 
<p>创建线程需要时间。 如果有不同的小任务要完成,就可以事先创建许多线程 ，在应完成这些任务时发出请求。 这个线程数最好在需要更多的线程时增加，在需要释放资源时减少，不需要自己创建线程池，系统已经有一个ThreadPool类管理线程。</p> 
<p>这个类会在需要时增减池中线程的线程数，直到达到最大的线程数。 池中的最大线程数是可配置的。</p> 
<p>在双核 CPU中，默认设置为1023个工作线程和 1000个I/O线程。也可以指定在创建线程池时应立即启动的最小线程数，以及线程池中可用的最大线程数。 如果有更多的作业要处理，线程池中线程的个数也到了极限，最新的作业就要排队，且必须等待线程完成其任务。</p> 
<p></p> 
<h4 style="background-color:transparent;">线程池示例</h4> 
<pre><code class="language-cs">static void Main(){
    int nWorkerThreads;
    int nCompletionThreads;
    ThreadPool.GetMaxThreads(out nWorkerThreads,out nCompletionPortThreads);
    Conslole.WriteLine("Max worker threads : "+ nWorkerThreads+
" I/O completion threads: "+ CompletionPortThreads);
    for(int i = 0;i&lt;5;i++){
        ThreadPool.QueueUserWorkItem(JobForAThrea);
    }
    Thread.Sleep(3000);
}

static void JobForAThread(object state){
    for(int i = 0;i &lt; 3; i++){
        Console.WriteLine("Loop"+ i +", running in pooled thread"
+Thread.CurrentThread.ManagedThreadld);
        Thread.Sleep(50);
    } 
}</code></pre> 
<p>示例应用程序首先要读取工作线程和I/O线程的最大线程数，把这些信息写入控制台中。</p> 
<p>接着在for循环中调用ThreadPool.QueueUserWorkItem方法，传递一个WaitCallBack类型的委托，把JobForThread方法赋予线程池中的线程。线程池收到这些请求后，就会从池中选择一个线程来调用该方法。</p> 
<p>如果线程池还没有运行，就会创建一个线程池，并启动第一个线程。如果线程池已经在运行，且有一个空闲线程来完成该任务，就把作业传递给这个线程。</p> 
<p></p> 
<h4>使用线程池需要注意的事项：</h4> 
<ul><li>线程池中的所有线程都是后台线程。如果进程的所有前台线程都结束了，所有的后台线程就会停止。不能把入池的线程改为前台线程。</li><li>不能给入池的线程设置优先级或名称</li><li>入池的线程只能用于时间较短的任务。如果线程要一直运行就应使用Thread类创建一个线程。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3948ab96e611d093e43c45d2fbcfb646/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">maya_mel语言中多边形点的提取和遍历操作方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2ea3079224c79de3e71bb6509f6b5fc7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android中的View的事件分发机制</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>