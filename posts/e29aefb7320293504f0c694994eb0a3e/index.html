<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《嵌入式Linux系统开发：基于 Yocto Project》笔记 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《嵌入式Linux系统开发：基于 Yocto Project》笔记" />
<meta property="og:description" content="写在前面 这本书的“译者序”里面有这么一句话：
市面上不缺乏适用于各种开发语言的开发、编译和打包工具，但在Yocto项目出现前，这些零散的工作需要嵌入式开发者自己串起来以交付最终的嵌入式系统。
我之前MCU做的多，Linux做的少。
最近研究Linux裁剪移植，很多芯片厂商都是适用Yocto。这个工具需要会。
但是从上面的这句话我理解到：
对Yocto的使用是一个层面Linux 系统的整体发布是另一个层面Yocto是一个工具，如果不知道这个工具要解决的问题的话，学习起来会很迷茫 这本书有英文原版，可以在网上找一下。中文版翻译的一般情况，墙裂推荐英文原版。
关于构建和Yocto工作流 红色的 Metadata/Input 是 Yocto 工程重点关注项，控制配置及工作流程。
金色的 Process Steps 是 Yocto 的固定的工作流。
草绿色？的Local Storage 是工程的源代码等资源。
两个步骤 构建环境配置
一般通过 shell 脚本完成该任务。构建环境相关的配置（主要是若干环境变量）可以在此时（此处）实例化。执行构建命令 $ bitbake [options] [recipename/target …] 这是 Yocto 的追求：一条命令完成构建。
bitbake 命令 Bitbake：一个任务执行引擎，用来解析并执行Metadata；类似于一个脚本解释器
需要完成构建环境配置后，才能在命令行里使用该命令。
$ bitbake —help Usage: bitbake [options] [recipename/target …] Executes the specified task (default is ‘build’) for a given set of target recipes (.bb files). It is assumed there is a conf/bblayers." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e29aefb7320293504f0c694994eb0a3e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-17T17:36:54+08:00" />
<meta property="article:modified_time" content="2023-02-17T17:36:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《嵌入式Linux系统开发：基于 Yocto Project》笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>写在前面</h2> 
<p>这本书的“译者序”里面有这么一句话：</p> 
<blockquote> 
 <p>市面上不缺乏适用于各种开发语言的开发、编译和打包工具，但在Yocto项目出现前，这些零散的工作需要嵌入式开发者自己串起来以交付最终的嵌入式系统。</p> 
</blockquote> 
<p>我之前MCU做的多，Linux做的少。<br> 最近研究Linux裁剪移植，很多芯片厂商都是适用Yocto。这个工具需要会。<br> 但是从上面的这句话我理解到：</p> 
<ul><li>对Yocto的使用是一个层面</li><li>Linux 系统的整体发布是另一个层面</li><li>Yocto是一个工具，如果不知道这个工具要解决的问题的话，学习起来会很迷茫</li></ul> 
<p>这本书有英文原版，可以在网上找一下。中文版翻译的一般情况，墙裂推荐英文原版。</p> 
<h2><a id="Yocto_14"></a>关于构建和Yocto工作流</h2> 
<p><img src="https://images2.imgbox.com/be/87/EnGHBAb3_o.png" alt="在这里插入图片描述"></p> 
<p>红色的 Metadata/Input 是 Yocto 工程重点关注项，控制配置及工作流程。<br> 金色的 Process Steps 是 Yocto 的固定的工作流。<br> 草绿色？的Local Storage 是工程的源代码等资源。</p> 
<h2><a id="_20"></a>两个步骤</h2> 
<ol><li>构建环境配置<br> 一般通过 shell 脚本完成该任务。构建环境相关的配置（主要是若干环境变量）可以在此时（此处）实例化。</li><li>执行构建命令</li></ol> 
<pre><code class="prism language-bash">$ bitbake <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token punctuation">[</span>recipename/target …<span class="token punctuation">]</span>
</code></pre> 
<p>这是 Yocto 的追求：一条命令完成构建。</p> 
<h2><a id="bitbake__28"></a>bitbake 命令</h2> 
<p>Bitbake：一个任务执行引擎，用来解析并执行Metadata；类似于一个脚本解释器<br> 需要完成构建环境配置后，才能在命令行里使用该命令。</p> 
<pre><code class="prism language-bash">$ bitbake —help 
Usage: bitbake <span class="token punctuation">[</span>options<span class="token punctuation">]</span> <span class="token punctuation">[</span>recipename/target …<span class="token punctuation">]</span> 

    Executes the specified task <span class="token punctuation">(</span>default is ‘build’<span class="token punctuation">)</span> <span class="token keyword">for</span> a given <span class="token builtin class-name">set</span> of 
target recipes <span class="token punctuation">(</span>.bb files<span class="token punctuation">)</span>. It is assumed there is a conf/bblayers.conf 
available <span class="token keyword">in</span> cwd or <span class="token keyword">in</span> BBPATH <span class="token function">which</span> will provide the layer, BBFILES and 
other configuration information. 

Options:
    <span class="token punctuation">..</span>.
</code></pre> 
<p>Options 可以被分为几类：</p> 
<ul><li>显示程序版本和帮助</li><li>执行带依赖处理的构建（重要）<br> Calling BitBake with a target, the base name of the recipe file without the .bb extension, runs the default task as defined by the variable BB_DEFAULT_TASK, typically build:</li></ul> 
<pre><code class="prism language-bash">$ bitbake core-image-minimal
</code></pre> 
<p>会处理相关的依赖，特点是将 recipe 的后缀 . bb 取掉<br> 如果加上 -k 的话，即使出错，也会继续构建</p> 
<ul><li> <p>执行不带依赖处理的构建<br> 加上 -b 并指定 recipe file</p> </li><li> <p>执行特定任务（重要，可以单独clean、配置、编译等）<br> 所以说一条 bitbake 命令可以跟两个变量：recipe 和 task<br> 加上 -c &lt;task&gt;</p> </li></ul> 
<pre><code class="prism language-bash">$ bitbake editor <span class="token parameter variable">-c</span> compile
</code></pre> 
<p>listtasks 是一个有用的 task，可以列出一个定制套餐的待执行任务：</p> 
<pre><code class="prism language-bash">$ bitbake core-image-minimal <span class="token parameter variable">-c</span> listtasks
</code></pre> 
<p>&lt;task&gt; 是可以自主定制的。</p> 
<ul><li>强制执行<br> 通过 -C （大写）或者 -f 来控制，类似于重新编译</li></ul> 
<blockquote> 
 <p>If, on subsequent runs of a task, the task’s time stamp is current or later then the time stamps of all the tasks that task depends on BitBake does not run the task.</p> 
</blockquote> 
<ul><li> <p>展示元数据（重要，调试相关）<br> 经过一系列的脚本解释，Yocto 执行了一个类似于编译和链接的操作。会形成一个整体的输出。<br> 通过 -e，可以将这个输出展示出来。</p> </li><li> <p>创建 Dependency Graphs</p> </li><li> <p>提供和覆盖配置数据</p> </li></ul> 
<h2><a id="Yocto_85"></a>Yocto工程的文件组织</h2> 
<h3><a id="Poky_86"></a>Poky</h3> 
<blockquote> 
 <p>Poky is the Yocto Project’s reference distribution. It includes the<br> OpenEmbedded build system. It provides all the necessary tools,<br> recipes, and configuration data required to build a Linux OS stack. As<br> we saw in the previous chapter, Poky is a mostly self- contained<br> system bundled as a simple archive.</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/c5/21/s9TiyKLD_o.png" alt="在这里插入图片描述"></p> 
<p>Poky 既是 Yocto 的一个参考发行版，又包含了构建一个 Yocto 工程的必要工具。<br> 所以，所有的 Yocto 项目都会包含一个 Poky 文件夹；并且基本上只需要一个 Poky 文件夹就可以做 Yocto 工程了，还是很简洁的。</p> 
<h3><a id="Build_System_Structure_97"></a>Build System Structure</h3> 
<p>构建系统（这是个偏正短语，不是动宾短语），一般指的是 Poky 这个文件夹。</p> 
<pre><code class="prism language-bash">xxx@xxx:poky$ tree <span class="token parameter variable">-L</span> <span class="token number">1</span>
<span class="token builtin class-name">.</span>
├── bitbake
├── contrib
├── documentation
├── LICENSE
├── LICENSE.GPL-2.0-only
├── LICENSE.MIT
├── Makefile
├── MEMORIAM
├── meta
├── meta-poky
├── meta-selftest
├── meta-skeleton
├── meta-yocto-bsp
├── oe-init-build-env
├── README.hardware -<span class="token operator">&gt;</span> meta-yocto-bsp/README.hardware
├── README.OE-Core
├── README.poky -<span class="token operator">&gt;</span> meta-poky/README.poky
├── README.qemu
└── scripts
</code></pre> 
<p>这个文件夹里的内容，原则上是不应该去修改的，并且在开发过程中应该锁定某个版本，而不是跟随社区进行更新。<br> 文件夹的内容基本上是和上图对应的。</p> 
<h4><a id="bitbakeconf_126"></a>bitbake.conf</h4> 
<p>这是 BitBake 的主配置文件，比较重要的几个 .conf 之一。<br> 位置：poky/meta/conf/bitbake.conf</p> 
<blockquote> 
 <p>BitBake’s master or main configuration file is named bitbake.conf.<br> BitBake expects this file to be present in all of the directories<br> listed in its metadata search path. This file contains all the default<br> configuration settings. Other configuration files and recipes commonly<br> override some of the variable settings in this file according to their<br> specific requirements.</p> 
</blockquote> 
<h4><a id="oeinitbuildenv_137"></a>oe-init-build-env</h4> 
<p>这是是一个非常重要的脚本，它是生成构建环境的核心。<br> 不应该去修改它，但是可以通过：</p> 
<ol><li>传参</li><li>修改其生成文件<br> 的方式完成对“构建环境”的差异化和定制化。</li></ol> 
<h4><a id="meta_144"></a>meta目录</h4> 
<p>poky/meta/classes下面有大量的 .bbclass 文件，提供了丰富的操作函数，可以直接被 .bb 文件引用。</p> 
<h4><a id="scripts__146"></a>scripts 目录</h4> 
<p>Yocto 一个的脚本集，大量的脚本会在实际的 Yocto 工程中被引用。</p> 
<h3><a id="Build_Environment_Structure_148"></a>Build Environment Structure</h3> 
<p>构建环境。<br> 这个文件夹是被生成的。</p> 
<h4><a id="_151"></a>原生的构建环境</h4> 
<p>仅执行 oe-init-build-env 脚本，便可得到一个原生的构建环境。</p> 
<pre><code class="prism language-bash">xxx@xxx:imx-yocto-bsp$ tree <span class="token parameter variable">-L</span> <span class="token number">2</span> ./build
./build
└── conf
    ├── bblayers.conf
    ├── bblayers.conf.org
    ├── local.conf
    ├── local.conf.org
    ├── local.conf.sample
    └── templateconf.cfg
</code></pre> 
<p>原生的构建环境，只有两个有效文件：</p> 
<ol><li>bblayers.conf，构建环境层配置文件</li></ol> 
<blockquote> 
 <p>A build environment needs to tell BitBake what layers it requires for its build process. The file bblayers.conf provides BitBake with information on what layers to include with the build process and the filesystem paths where they are found. Each build environment has its own bblayers.conf file, which can be found in the conf subdirectory of the build environment.</p> 
</blockquote> 
<ol start="2"><li>local.conf，构建环境本地配置文件</li></ol> 
<blockquote> 
 <p>Local configuration of a build environment is provided through a configuration file named local.conf. The local.conf file contains settings that apply to the particular build environment, such as paths to download locations, build outputs, and other files; configuration settings for the target system such as the target machine, package management system, and distribution policy; and many other settings.</p> 
</blockquote> 
<p>上面的这两个文件，只会在构建环境的目录中存在。</p> 
<h4><a id="_176"></a>对构建环境进行定制</h4> 
<p>可以通过一系列的脚本对上文提到的两个 .conf 文件进行修改和定制。</p> 
<h4><a id="machinedistro_image_179"></a>machine、distro、和 image</h4> 
<p>执行整体构建的时候，bitbake 后面接的参数是按 image 来的。<br> image 的主要作用是说明依赖的模块。每个 &lt;module&gt; 由 &lt;module.bb&gt; 来代表。</p> 
<p>暂时还没有搞明白 distro 的作用。<br> 总感觉一个 image 就决定了 distro 了。应该是还有一个领域暂时不清楚。<br> 也许比如说，一个 Ubuntu1604 是一个distro，但是这个发型版里预装的软件可以有差别。</p> 
<p>machine 是比较好理解的，同样的上层有可能会跑着不同的底层上。<br> 在 NXP 的脚本里，构建环境是按 machine 来命名区分的。</p> 
<h3><a id="_191"></a>元数据层结构</h3> 
<p>元数据层的文件命名是比较结构化的。下表中，斜体代表目录。</p> 
<pre><code class="prism language-bash">meta-<span class="token operator">&lt;</span>layername<span class="token operator">&gt;</span>
├── classes
│   ├── class<span class="token operator">&lt;</span><span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>.bbclass
│   ├── class<span class="token operator">&lt;</span><span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>.bbclass
│   ├── <span class="token punctuation">..</span>.
│   └── class<span class="token operator">&lt;</span>l<span class="token operator">&gt;</span>.bbclass
├── conf
│   ├── layer.conf
│   ├── machine
│   │   ├── <span class="token operator">&lt;</span>machine <span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>.conf
│   │   ├── <span class="token operator">&lt;</span>machine <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>.conf
│   │   ├── <span class="token punctuation">..</span>.
│   │   └── <span class="token operator">&lt;</span>machine m<span class="token operator">&gt;</span>.conf
│   └── distro
│       ├── <span class="token operator">&lt;</span>distro <span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>.conf
│       ├── <span class="token operator">&lt;</span>distro <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>.conf
│       ├── <span class="token punctuation">..</span>.
│       └── <span class="token operator">&lt;</span>distro r<span class="token operator">&gt;</span>.conf
├── recipes-<span class="token operator">&lt;</span>category <span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>
│   ├── <span class="token operator">&lt;</span>package a<span class="token operator">&gt;</span>
│   │   ├── <span class="token operator">&lt;</span>package a<span class="token operator">&gt;</span>_<span class="token operator">&lt;</span>version <span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>.bb
│   │   └── <span class="token operator">&lt;</span>package a<span class="token operator">&gt;</span>_<span class="token operator">&lt;</span>version <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>.bb
│   ├── <span class="token operator">&lt;</span>package b<span class="token operator">&gt;</span>
│   │   ├── <span class="token operator">&lt;</span>package b<span class="token operator">&gt;</span>_<span class="token operator">&lt;</span>version <span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span>.bb
│   │   └── <span class="token operator">&lt;</span>package b<span class="token operator">&gt;</span>_<span class="token operator">&lt;</span>version <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>.bb
│   ├── <span class="token punctuation">..</span>.
│   └── <span class="token operator">&lt;</span>package z<span class="token operator">&gt;</span>
├── recipes-<span class="token operator">&lt;</span>category <span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span>
│   └── <span class="token punctuation">..</span>.
└── recipes-<span class="token operator">&lt;</span>category n<span class="token operator">&gt;</span>
    └── <span class="token punctuation">..</span>.
</code></pre> 
<p>在一个层中，conf/layer.conf 是必选的（相应的 conf 目录也是必选的）。BitBake requires this file to set up paths and search patterns for metadata files.<br> conf/machine/和conf/distro/是可选的，可以通过这两个文件夹里的配置文件，对不同的板卡和发布版本做出差异化设置。<br> recipes-&lt;category 1&gt;原则上也是可选的。但是没有 recipes 的 layer 是没有意义的。<br> 可以使用yocto-layer脚本来自动化的创建一个自己的层（但是测试没有成功）。</p> 
<h3><a id="_232"></a>调试</h3> 
<h4><a id="_233"></a>日志系统</h4> 
<p>Yocto 的日志系统也是比较全（复）面（杂）的。具体细节这里不说了。<br> 每次任务运行，bitbake 都会创建一个任务脚本文件：run.do_&lt;taskname&gt;.&lt;pid&gt;<br> bitbake 的每个任务都会有其对应的日志文件：log.do_&lt;taskname&gt;.&lt;pid&gt;，如果任务被运行多次，会有多个日志被生成。</p> 
<h4><a id="bitbakelayers_237"></a>bitbake-layers</h4> 
<p>进入到构建环境中，可以执行 bitbake-layers 命令。具体细节参考附件一的第5.6节。<br> $bitbake-layers show-layers</p> 
<h2><a id="Yocto__243"></a>Yocto 的一些语法策略</h2> 
<h3><a id="_244"></a>散点</h3> 
<ul><li> <p>Append file：An append file extends an existing recipe. BitBake verbatim appends the contents of an append file to the corresponding recipe, creating a single file before parsing it. Variables in an append file can override the same veriables defined in the corresponding recipe. Append files use the bbappend extension.<br> 就是说，除了包含和继承之外，还有另外一种方式扩展菜谱，就是新写一个 .bbappend 的文件做目标菜谱的扩展。</p> </li><li> <p>Recipe：A recipe is a metadata file containing directives for BitBake on how to build a particular software package. Through its directives, a recipe describes from where to obtain the source code, what patches to apply and how to apply them, how to build the binaries and associated files, how to install the build results on a target system, how to create the packaged software bundle, and much more. Recipes also describe dependencies during build and runtime on other software packages, hence creating a logical hierarchy of the pieces required for the build process. Recipes use the bb file extension.<br> 所以，菜谱做的事情，大概就是，获取资源、配置、编译、安装、打包，以及各模块间的依赖性。</p> </li><li> <p>Configuration Files：A variable can be set in one configuration file and overwritten in another. <strong>Recipes can also set and overwrite variables, but the assignments made in recipes remain local to the recipe.</strong><br> .conf 文件是用来配置的，里面没有函数和任务，.bbclass 里面主要是放函数，.bb 是主干，里面有任务的编排。<br> The configuration file bitbake.conf has the lowest priority, and the local configuration file of the build environment local.conf has the highest.</p> </li><li> <p>bblayers.conf：Each build environment has its own bblayers.conf file, which can be found in the conf subdirectory of the build environment.<br> 这为不同的 image 构建提供了支持，每个 image 构建都有它自己的 build environment，然后在它自己的 build environment 里指定不同的 layers.</p> </li><li> <p>Priority：Each layer is assigned a priority by setting the variable BBFILE_PRIORITY. Layer priorities range from 1 to 10 with 1 being the lowest and 10 being the highest priority. If two layers use the same priority, then their order in the BBLAYERS veriable of the file bblayers.conf file determines the priority.<br> The priority also determines in what order BitBake appends append files to the recipes. An append file from a layer with higher priority is added after an append file from a layer with lower priority.</p> </li><li> <p>BitBake automatically sets the variable LAYERDIR to the path to the top-level directory of a layer when it begins parsing the files in that layer.</p> </li><li> <p>BBFILE_COLLECTIONS：Contains a list of the names of configured layers. This list is used by BitBake to find other BBFILE_* variables in its data directory. Each layer <strong>typically</strong> adds its own name to the list.</p> </li><li> <p>.bbclass：Recipes can include class files by simply referencing them by their name using the <strong>inherit</strong> directive. Classes are global, meaning that recipes located in a layer can inherit classes from any other layer the build environment includes.</p> </li><li> <p>A metadata file can include any other metadata file; however, files containing executable metadata may be included only by recipes, append files, and classes.</p> </li></ul> 
<h3><a id="_270"></a>变量</h3> 
<ul><li>变量作用域： .conf 中的变量范围是全局的，.bb 中的变量是局部的；如果有同名，在局部范围内，全局范围的值会被覆盖。</li><li>默认赋值 (?=)：多个默认赋值中，较早的那个有效；直接赋值无条件覆盖默认赋值。</li><li>Weak Default Value Assignment (??=)：直到解析使用时，赋值才生效，所以较晚的赋值语句有效；直接赋值和默认赋值无条件覆盖弱默认赋值。</li><li>Immediate Variable Expansion (:=)：普通的是到用的时候才展开，这个是赋值的时候就展开，遇到了要好好注意。</li><li>Python Variable Expansion：The @ operator tells BitBake to treat the expression following it as Python code.</li></ul> 
<h3><a id="_277"></a>变量追加和删减</h3> 
<ul><li>Appending (+=) and Prepending (=+) with Space：前者把字符加到后面，后者把字符加到前面。这两个操作会相应的增加空格。</li><li>Appending (.=) and Prepending (=.) without Space：这个和前面类似，不过会拼接起来，中间不加空格。</li><li>Appending and Prepending Using the _append and _prepend Operators：这个和 (.=) 与 (=.) 一样，拼接不加空格。</li></ul> 
<h3><a id="_282"></a>复用</h3> 
<h4><a id="include__requried_283"></a>include 和 requried</h4> 
<p>后面可以跟 .inc 和 .bb 的文件。<br> include 是 optional inclusion；required 是 required inclusion.<br> The include and required directives can be used with relative and absolute path.<br> when relative paths are used, BitBake tries to locate the file using the list of file paths specified by the BBPATH variable.<br> BitBake uses the first file it finds that has the correct path segment and filename. 想想也对，使用遇到的第一个，可减少搜索的时间。<br> include 文件里的设置会覆盖 including file 里的设置，这个要注意。</p> 
<h4><a id="Inheriance__class_291"></a>Inheriance 和 class</h4> 
<p>后面只能跟 .bbclass 的文件。<br> .inc 文件中无法使用 inheriance.</p> 
<ul><li>BitBake identifies classes by their class name and not by their filename and path, which means class names must be unique across all metadata layers included by a build environment.</li></ul> 
<h3><a id="Executable_Metadata_297"></a>Executable Metadata</h3> 
<p>BitBake treats executable metadata exactly the same as variables: the function name is stored in the data dictionary together with the function code that represents the assigned value. Consequently, functions can be appended and prepended like regular variables and may also have metadata attributes.<br> The scope of metadata functions defined in recipes and append files is local to the particular file, whereas functions defined in classes are global.</p> 
<p>也就是说，可以把可执行函数写在 .bbclass 里，也可以写在 .bb 里。但是在 .bb 里的是局部的，在 .bbclass 里的是全局的。函数可以像变量那边被补充，可以补充追加到函数的前面，也可以补充追加到函数的后面。<br> 函数可以使用 shell 语法，也可以使用 python 语法。python 语法：</p> 
<pre><code class="prism language-python">python printdate <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">import</span> time
	<span class="token keyword">print</span> time strftime<span class="token punctuation">(</span>‘<span class="token operator">%</span>Y<span class="token operator">%</span>m<span class="token operator">%</span>d’<span class="token punctuation">,</span> time<span class="token punctuation">.</span>gettime<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>前面需要加关键字 python.</p> 
<hr> 
<h2><a id="_314"></a>一些事情</h2> 
<p>&lt;build_env&gt;/tmp/log/…/ 下面，会有一个总的 log.<br> 这个 log 会列出构建所输入的一些信息，还有<br> 主体：都运行了哪些任务，还有任务执行时的一些消息打印。</p> 
<h3><a id="_318"></a>任务</h3> 
<p>task 都是挂到 recipes 下面的；换句话说，每个配方下面会有若干个任务。<br> 任务的执行函数是可以通过文件的继承来获得的。<br> 不同的 recipes 下命名空间是独立的。</p> 
<p>基于 NXP 的开发板进行构建测试的命令：<br> DISTRO=fsl-imx-wayland MACHINE=imx6ull14x14evk source imx-setup-release.sh -b build_6w<br> bitbake fsl-image-machine-test</p> 
<h2><a id="_332"></a>一些其他的事情</h2> 
<h3><a id="_333"></a>关于名字</h3> 
<p>Yocto，发音 幺[科托]<br> 与国际单位制的词头（也就是大小）中最小的那一个同源。<br> 1um = 10^-6m；微米<br> 1nm = 10^-9m；纳米<br> 1pm = 10^-12m；皮米<br> 1ym = 10^-24m；幺米</p> 
<h3><a id="_341"></a>构建发行版所需要做的事情</h3> 
<ul><li>创建交叉编译的工具链 
  <ul><li>uClibc VS glibc、X.org、GStreamer</li></ul> </li><li>引导加载程序</li><li>内核镜像</li><li>设备驱动</li><li>根文件系统</li><li>应用软件和库</li></ul> 
<h3><a id="Buildroot__OpenEmbedded__Yocto__Poky_350"></a>Buildroot / OpenEmbedded / Yocto / Poky</h3> 
<p>Poky 是 Yocto 项目的参考发行版，Poky 包括了 OpenEmbedded 构建系统和一整套元数据。</p> 
<h3><a id="Linux___353"></a>Linux &amp; 大量的开源软件包</h3> 
<blockquote> 
 <p>搞清楚不同包之间的依赖、不兼容性和冲突是一个艰巨的任务。</p> 
</blockquote> 
<h3><a id="Linux__356"></a>Linux 标准基</h3> 
<p>Linux Standard Base，LSB<br> 为 Linux 发行版确立的一套通用标准——应用开发者在 Linux 发行版上开发的代码将可以不加额外修改地运行在其他 Linux 发行版上。<br> 并且也会解决 Linux 发行版的连续性问题：约定哪些（包括未来的）版本和特定的 Linux 标准基的版本保持兼容。<br> LSB 会有一整套规格说明、文档和工具，来检测兼容性。</p> 
<p><em>LSB 可以作为自己的 OS 平台的产品战略。</em><br> <a href="https://wiki.linuxfoundation.org/lsb/start" rel="nofollow">Linux 标准基官网</a></p> 
<h2><a id="Poky__367"></a>Poky 实践</h2> 
<p><a href="https://docs.yoctoproject.org/brief-yoctoprojectqs/index.html" rel="nofollow">Yocto Project Quick Build</a><br> 按照链接的指引去操作，当执行完：</p> 
<pre><code class="prism language-bash">$ bitbake core-image-sato
</code></pre> 
<p>以后，就能生成 core-image-sato，然后运行：</p> 
<pre><code class="prism language-bash">$ runqemu qemux86-64
</code></pre> 
<p>就能跑了。<br> <strong>但是</strong>，这并没有什么用。<br> 因为现在还不知道 bitbake 是怎么接收并差异化 core-image-sato 这个参数的。<br> 执行 bitbake 的时候到底发生了什么，也不知道。<br> 链接后面还有很多内容，但是没有发现太多又有信息，唯一练习了的，就是打字和英文阅读。<br> 不过，这是分析 Yocto 工程的一个比较合适的例程。</p> 
<h3><a id="_385"></a>需要了解“构建系统结构”和“构建环境结构”</h3> 
<h3><a id="_386"></a>需要了解“元数据层结构”</h3> 
<h3><a id="bb___bbappend___inc__387"></a>.bb 文件 / .bbappend 文件 / .inc 文件是相辅相成的</h3> 
<h3><a id="_390"></a>元数据的组织</h3> 
<p>变量 &amp; 可执行元数据</p> 
<ul><li>.conf，变量，底层会覆盖顶层</li><li>.bb，描述特定软件包以及如何构建该软件包：下载、解压、打补丁、编译、打包、安装指令</li><li>.bbclass，可以理解为函数集，里面的函数被 .bb 调用，通过 inherit 指令</li><li></ul> 
<h2><a id="coreimage__Linux__398"></a>core-image —— Linux 发行版蓝图</h2> 
<p>通过这个命令，可以找到当前的构建系统所支持的发布镜像<br> find ./meta*/recipes*/images -name “*.bb”</p> 
<p>所有核心镜像菜谱都继承自 core-image 类；core-image 类继承自 image 类。<br> <img src="https://images2.imgbox.com/1c/a7/bQdRToqF_o.png" alt="page115"><br> <img src="https://images2.imgbox.com/77/d5/w2VIafiN_o.png" alt="page117"><br> ~<br> 最后附上 Yocto 的主页：<a href="https://www.yoctoproject.org" rel="nofollow">Yocto 官网</a><br> 以下内容都不重要：</p> 
<hr> 
<h2><a id="_410"></a>参考文档及若干概念</h2> 
<p><a href="https://blog.csdn.net/yangteng0210/article/details/81566950">Yocto的介绍</a></p> 
<blockquote> 
 <p>Poky：Poky有两个含义。第一个含义是用来构建Linux的构建系统，值得注意的该Poky仅仅是一个概念，而非一个实体：它包含了 BitBake工具、编译工具链、BSP、诸多程序包或层，可以认为Poky即是Yocto的本质；此外Poky还有另外一层意思，使用Poky系统得到的默认参考 Linux 发行版也叫Poky（当然，我们可以对此发行版随意命名）。</p> 
</blockquote> 
<p>Metadata 相关概念：</p> 
<blockquote> 
 <p>Recipes：.bb/.bbappend文件，配方文件，描述了从哪获取软件源码，如何配置，如何编译。<br> Class：.bbclass文件，包含在配方文件之间共享的有用信息。<br> Configuration：.conf文件，即配置文件，我们可以用它来改变构建方式。conf/bblayers.conf中可以添加用到的layer层路径，从而在编译时将他们添加进去。</p> 
</blockquote> 
<blockquote> 
 <p>Bitbake：一个任务执行引擎，用来解析并执行Metadata</p> 
</blockquote> 
<h2><a id="install__424"></a>install 命令</h2> 
<p>讲到构建，install 的命令一定是少不了的。<br> <a href="https://blog.csdn.net/weixin_44162346/article/details/89531650">Linux 中的 Install命令</a></p> 
<p>编译完了，需要把需要的东西打包。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/757c8d66e153b045259853e413d7c44f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">就是这么简单！Pyecharts绘制可视化地图专辑</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6bbea3dc9937ba7b958edcf01d17e394/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">labelme生成的标注数据转换成yolov5格式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>