<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HIT 软件构造2019春 Lab2 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HIT 软件构造2019春 Lab2" />
<meta property="og:description" content="update: 3/13/2019 未考虑checkRep，RI，AF
update：3/17/2019 改一下MyExp继承RuntimeException
update：3/23/2019 修改P1 poet题目理解，更新poem的stream写法
update：3/24/2019 Edge Immutable条件
Trick： 使用Collection.stream处理满足map-filter-reduce的序列。
DEF： 关于checkRep，RI，AF
QA： 如何检查输入合法？
自定义类继承RuntimeException，如果继承自Exception则需要明确对抛出的Exception进行声明，这里选择RuntimeException，与直接继承Exception相比不需要显示抛出（函数声明throws...），同时也不强制使用try catch捕获（ArrayIndexOutOfBoundsException是一个例子），可以直接在catch中打印错误信息。
MyExp示例：
package P3; public class MyExp extends RuntimeException { //错误信息 private String expMsg=&#34;MyException&#34;; public MyExp(String msg) { this.expMsg = msg; } public String getExpMsg() { return expMsg; } public void setExpMsg(String expMsg) { this.expMsg = expMsg; } @Override public String toString() { return this.expMsg&#43;&#34;\t 请重新输入&#34;; } //实现assertTrue的断言功能，如果cond为假则抛出异常，使用该函数进行输入合法判断 public static void assertTrue(boolean cond,String msg) throws MyExp { if(!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a63dd00269da03b4fe52c22929ac389e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-03-13T17:14:11+08:00" />
<meta property="article:modified_time" content="2019-03-13T17:14:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HIT 软件构造2019春 Lab2</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>update: 3/13/2019 未考虑checkRep，RI，AF</p> 
 <p>update：3/17/2019 改一下MyExp继承RuntimeException</p> 
 <p>update：3/23/2019 修改P1 poet题目理解，更新poem的stream写法</p> 
 <p>update：3/24/2019 Edge Immutable条件</p> 
</blockquote> 
<h2>Trick：</h2> 
<p>    使用Collection.stream处理满足map-filter-reduce的序列。</p> 
<h3>DEF：</h3> 
<p>    <a href="https://zbqtesla.top/2018/03/19/AF-RI/" rel="nofollow">关于checkRep，RI，AF</a></p> 
<h3>QA：</h3> 
<p>    如何检查输入合法？</p> 
<p>    自定义类继承RuntimeException，如果继承自Exception则需要明确对抛出的Exception进行声明，这里选择RuntimeException，与直接继承Exception相比不需要显示抛出（函数声明throws...），同时也不强制使用try catch捕获（ArrayIndexOutOfBoundsException是一个例子），可以直接在catch中打印错误信息。</p> 
<p>    MyExp示例：</p> 
<pre class="has"><code class="language-java">package P3;

public class MyExp extends RuntimeException {
    //错误信息
	private String expMsg="MyException";
	
	public MyExp(String msg) {
		this.expMsg = msg;
	}
	
	public String getExpMsg() {
		return expMsg;
	}

	public void setExpMsg(String expMsg) {
		this.expMsg = expMsg;
	}
	
	@Override public String toString() {
		return this.expMsg+"\t 请重新输入";
	}
	//实现assertTrue的断言功能，如果cond为假则抛出异常，使用该函数进行输入合法判断
	public static void assertTrue(boolean cond,String msg) throws MyExp {
		if(!cond) throw new MyExp(msg);
	}
}
</code></pre> 
<h3> </h3> 
<p>捕获：</p> 
<p><img alt="" class="has" height="21" src="https://images2.imgbox.com/be/a6/KC4jLUoF_o.png" width="706"></p> 
<p>//"输入位置需合法" 为需要打印的错误提示信息</p> 
<p>打印：</p> 
<p><img alt="" class="has" height="115" src="https://images2.imgbox.com/2f/84/pljxdejH_o.png" width="408"></p> 
<p>//在game.getPieceAtCord中使用了MyExp.assertTrue，如果想要捕获错误打印错误，需要try catch</p> 
<p> </p> 
<h3>实验报告：</h3> 
<p> </p> 
<p> </p> 
<h3><strong><a name="_Toc1988217">Poetic Walks</a></strong></h3> 
<p> </p> 
<p style="margin-left:0cm;">分别新建两个类ConcreteEdgesGraph，ConcreteVerticesGraph 实现Graph接口。</p> 
<p style="margin-left:0cm;">Graph接口要求实现add（添加新节点），set（添加新边），remove（移除节点），vertices（获得所有的节点集合），sources（target）获得以target为目标节点的边的起始节点，targes(source)获得以source为起始节点的边的目标节点。</p> 
<p style="margin-left:0cm;">Poet：给定一组单词（文件输入），对于两个相邻的单词a和b，认为存在一条由a到b的有向边，通过Graph接口构造有向图。再给定一由单词组成的句子，如果句子中两个相邻单词之间在Graph图中有一个中间单词则将中间单词插入到两单词之间（如果有多个则插入权重最大的那个）。</p> 
<p style="margin-left:0cm;"> </p> 
<ol><li> 
  <ol><li> 
    <ol><li><strong><a name="_Toc1988218">Get the code and prepare Git repository</a></strong></li></ol></li></ol></li></ol> 
<p style="margin-left:0cm;">自 <a href="https://github.com/rainywang/Spring2019_HITCS_SC_Lab2/tree/master/P1">https://github.com/rainywang/Spring2019_HITCS_SC_Lab2/tree/master/P1</a> 获得实验代码。</p> 
<p style="margin-left:0cm;">Git init</p> 
<p style="margin-left:0cm;">Git remote add origin <a href="mailto:git@github.com:ComputerScienceHIT/Lab2-1170300825.git" rel="nofollow">git@github.com:ComputerScienceHIT/Lab2-1170300825.git</a></p> 
<p style="margin-left:0cm;">在远程仓库新建Master分支</p> 
<p style="margin-left:0cm;">Git pull origin master</p> 
<p style="margin-left:0cm;">Git add .</p> 
<p style="margin-left:0cm;">Git commit -m “init”</p> 
<p style="margin-left:0cm;">Git push origin master</p> 
<p style="margin-left:0cm;">--git已经初始化</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<ol><li> 
  <ol><li> 
    <ol><li><strong><a name="_Toc1988219">Problem 1: Test</a> Graph &lt;String&gt;</strong></li></ol></li></ol></li></ol> 
<p style="margin-left:0cm;">如果需要测试，默认ConcreteEdgesGraph implements Graph&lt;String&gt;，修改empty为：</p> 
<p style="margin-left:0cm;">Public Graph&lt;String&gt; empty() {<!-- --></p> 
<p style="margin-left:0cm;">       return new ConcreteEdgesGraph();</p> 
<p style="margin-left:0cm;">}</p> 
<p style="margin-left:0cm;">此时可以运行GraphStaticTest进行测试。</p> 
<ul><li> 
  <ol><li> 
    <ol><li><strong><a name="_Toc1988220">Problem 2: Implement</a> Graph &lt;String&gt;</strong> 
      <ol><li><strong><a name="_Toc1988221">Implement </a>ConcreteEdgesGraph</strong></li></ol></li></ol></li></ol></li><li>实现(generic) Edge&lt;L&gt;类</li></ul> 
<table border="1" cellspacing="0" style="margin-left:13.95pt;"><tbody><tr><td style="vertical-align:top;width:215.8pt;"> <p style="margin-left:0cm;">域</p> </td><td style="vertical-align:top;width:185.05pt;"> <p style="margin-left:0cm;">声明</p> </td></tr><tr><td style="vertical-align:top;width:215.8pt;"> <p style="margin-left:0cm;">Private L source</p> </td><td style="vertical-align:top;width:185.05pt;"> <p style="margin-left:0cm;">起始节点</p> </td></tr><tr><td style="vertical-align:top;width:215.8pt;"> <p style="margin-left:0cm;">Private L target</p> </td><td style="vertical-align:top;width:185.05pt;"> <p style="margin-left:0cm;">目标节点</p> </td></tr><tr><td style="vertical-align:top;width:215.8pt;"> <p style="margin-left:0cm;">Private int weight</p> </td><td style="vertical-align:top;width:185.05pt;"> <p style="margin-left:0cm;">边的权值</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"> </p> 
<table border="1" cellspacing="0" style="margin-left:13.95pt;"><tbody><tr><td style="vertical-align:top;width:216.55pt;"> <p style="margin-left:0cm;">接口</p> </td><td style="vertical-align:top;width:184.3pt;"> <p style="margin-left:0cm;">说明</p> </td></tr><tr><td style="vertical-align:top;width:216.55pt;"> <p style="margin-left:0cm;">Getter （Immutable木有setter）</p> </td><td style="vertical-align:top;width:184.3pt;"> <p style="margin-left:0cm;">三个域的getter</p> </td></tr><tr><td style="vertical-align:top;width:216.55pt;"> <p style="margin-left:0cm;">judgeVertex</p> </td><td style="vertical-align:top;width:184.3pt;"> <p style="margin-left:0cm;">便利函数，判断一个节点是否为这条边的端点之一</p> </td></tr><tr><td style="vertical-align:top;width:216.55pt;"> <p style="margin-left:0cm;">@Override equas</p> </td><td style="vertical-align:top;width:184.3pt;"> <p style="margin-left:0cm;">比较函数</p> </td></tr><tr><td style="vertical-align:top;width:216.55pt;"> <p style="margin-left:0cm;">@Override hashCode</p> </td><td style="vertical-align:top;width:184.3pt;"> <p style="margin-left:0cm;">生成hash值</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<ul><li>实现ConcreteEdgesGraph类</li></ul> 
<table border="1" cellspacing="0" style="margin-left:13.95pt;"><tbody><tr><td style="vertical-align:top;width:203.65pt;"> <p style="margin-left:0cm;">函数</p> </td><td style="vertical-align:top;width:197.2pt;"> <p style="margin-left:0cm;">实现思路</p> </td></tr><tr><td style="vertical-align:top;width:203.65pt;"> <p style="margin-left:0cm;">add(L vertex)</p> </td><td style="vertical-align:top;width:197.2pt;"> <p style="margin-left:0cm;">调用List.add，其返回结果为boolean且满足spec定义。</p> </td></tr><tr><td style="vertical-align:top;width:203.65pt;"> <p style="margin-left:0cm;">set(L source,L target,int weight)</p> </td><td style="vertical-align:top;width:197.2pt;"> <p style="margin-left:0cm;">检查输入满足weight&gt;=0。当weight&gt;0时，如果当前没有该edge，则直接添加，返回值为0，如果已经有该edge，则记录旧值，修改为新值。如果weight==0，当删除的边不存在时返回0，当存在时，删除该节点，该边，如果此时两端点之中没有边与之相连了则删除节点。</p> </td></tr><tr><td style="vertical-align:top;width:203.65pt;"> <p style="margin-left:0cm;">remove(L vertex)</p> </td><td style="vertical-align:top;width:197.2pt;"> <p style="margin-left:0cm;">检查输入满足vertex存在vertices中，当存在时，删除该节点，同时删除所有与之相连的边，此时检查vertices中是否有点 没有连边，如果有则删除。</p> </td></tr><tr><td style="vertical-align:top;width:203.65pt;"> <p style="margin-left:0cm;">Set&lt;L&gt; vertices</p> </td><td style="vertical-align:top;width:197.2pt;"> <p style="margin-left:0cm;">返回vertices</p> </td></tr><tr><td style="vertical-align:top;width:203.65pt;"> <p style="margin-left:0cm;">Sources(L target)</p> </td><td style="vertical-align:top;width:197.2pt;"> <p style="margin-left:0cm;">在edges中寻找所有目标点是target的初始节点（加权），符合Map-filter-reduce的处理流程，Stream写法：</p> <p style="margin-left:0cm;"><img alt="" class="has" height="104" src="https://images2.imgbox.com/70/cc/jWZG0wAA_o.png" width="342"></p> <p style="margin-left:0cm;"> </p> </td></tr><tr><td style="vertical-align:top;width:203.65pt;"> <p style="margin-left:0cm;">Targets(L source)</p> </td><td style="vertical-align:top;width:197.2pt;"> <p style="margin-left:0cm;">符合Map-filter-reduce的处理流程，Stream写法：</p> <p style="margin-left:0cm;"><img alt="" class="has" height="98" src="https://images2.imgbox.com/8c/88/Oa6txOs8_o.png" width="351"></p> <p style="margin-left:0cm;"> </p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"> </p> 
<ol><li> 
  <ol><li> 
    <ol><li> 
      <ol><li><strong><a name="_Toc1988222">Implement </a>ConcreteVerticesGraph</strong></li></ol></li></ol></li></ol></li></ol> 
<p style="margin-left:0cm;">一、实现(generic) Vertex&lt;L&gt;类</p> 
<table border="1" cellspacing="0" style="margin-left:13.95pt;"><tbody><tr><td style="vertical-align:top;width:215.8pt;"> <p style="margin-left:0cm;">域</p> </td><td style="vertical-align:top;width:185.05pt;"> <p style="margin-left:0cm;">声明</p> </td></tr><tr><td style="vertical-align:top;width:215.8pt;"> <p style="margin-left:0cm;">Private L label</p> </td><td style="vertical-align:top;width:185.05pt;"> <p style="margin-left:0cm;">Label</p> </td></tr><tr><td style="vertical-align:top;width:215.8pt;"> <p style="margin-left:0cm;">Private Map&lt;L,Integer&gt; sources</p> </td><td style="vertical-align:top;width:185.05pt;"> <p style="margin-left:0cm;">所有以label为目标节点的边，&lt;起始节点lable,边的权重&gt;.</p> </td></tr><tr><td style="vertical-align:top;width:215.8pt;"> <p style="margin-left:0cm;">Private Map&lt;L,Integer&gt; targets</p> </td><td style="vertical-align:top;width:185.05pt;"> <p style="margin-left:0cm;">所有以label为其实节点的边，&lt;目标节点label,边的权重&gt;</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"> </p> 
<table border="1" cellspacing="0" style="margin-left:13.95pt;"><tbody><tr><td style="vertical-align:top;width:216.55pt;"> <p style="margin-left:0cm;">接口</p> </td><td style="vertical-align:top;width:184.3pt;"> <p style="margin-left:0cm;">说明</p> </td></tr><tr><td style="vertical-align:top;width:216.55pt;"> <p style="margin-left:0cm;">Getter and Setter</p> </td><td style="vertical-align:top;width:184.3pt;"> <p style="margin-left:0cm;">三个域的getter and setter</p> </td></tr><tr><td style="vertical-align:top;width:216.55pt;"> <p style="margin-left:0cm;">setSource(L source,int weight)</p> </td><td style="vertical-align:top;width:184.3pt;"> <p style="margin-left:0cm;">检查输入满足source!=null，weight&gt;=0。当weight==0时，调用this.removeSource，当weight&gt;0时，调用Map.put修改source并且记录初始值。</p> </td></tr><tr><td style="vertical-align:top;width:216.55pt;"> <p style="margin-left:0cm;">removeSource(L source)</p> </td><td style="vertical-align:top;width:184.3pt;"> <p style="margin-left:0cm;">检查输入满足source!=null，调用sources.remove，并返回旧值（不存在则返回0）。</p> </td></tr><tr><td style="vertical-align:top;width:216.55pt;"> <p style="margin-left:0cm;">setTarget(L target,int weight)</p> </td><td style="vertical-align:top;width:184.3pt;"> <p style="margin-left:0cm;">检查输入满足target!=null,weight&gt;=0，当weight=0时，调用this.removeTarget，当weight&gt;0时，调用targets.put并返回旧值（不存在则返回0）。</p> </td></tr><tr><td style="vertical-align:top;width:216.55pt;"> <p style="margin-left:0cm;">removeTarget(L target)</p> </td><td style="vertical-align:top;width:184.3pt;"> <p style="margin-left:0cm;">检查满足target!=null。调用targets.remove()，返回旧值。</p> </td></tr><tr><td style="vertical-align:top;width:216.55pt;"> <p style="margin-left:0cm;">remove(final L vertex)</p> </td><td style="vertical-align:top;width:184.3pt;"> <p style="margin-left:0cm;">调用removeSource和removeTarget</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"> </p> 
<ul><li>实现ConcreteVertices类</li></ul> 
<table border="1" cellspacing="0" style="margin-left:13.95pt;"><tbody><tr><td style="vertical-align:top;width:203.65pt;"> <p style="margin-left:0cm;">函数</p> </td><td style="vertical-align:top;width:197.2pt;"> <p style="margin-left:0cm;">实现思路</p> </td></tr><tr><td style="vertical-align:top;width:203.65pt;"> <p style="margin-left:0cm;">add(L vertex)</p> </td><td style="vertical-align:top;width:197.2pt;"> <p style="margin-left:0cm;">检查输入满足vertex!=null。调用vertices.add，并返回结果</p> </td></tr><tr><td style="vertical-align:top;width:203.65pt;"> <p style="margin-left:0cm;">set(L source,L target,int weight)</p> </td><td style="vertical-align:top;width:197.2pt;"> <p style="margin-left:0cm;">检查输入满足weight&gt;=0。如果source或者target不存在与vertices中则新建Vertex加入到vertices中，调用sourceVertex.setTarget，targetVertex.setSource。检查删除没有连边的节点。</p> </td></tr><tr><td style="vertical-align:top;width:203.65pt;"> <p style="margin-left:0cm;">remove(L vertex)</p> </td><td style="vertical-align:top;width:197.2pt;"> <p style="margin-left:0cm;">检查输入满足vertex!=null。如果输入节点不存在则返回false，否则，遍历vertices中的每一个节点调用v.remove在targes和sources中删除该节点，在vertices中删除该节点，检查删除没有连边的节点。</p> </td></tr><tr><td style="vertical-align:top;width:203.65pt;"> <p style="margin-left:0cm;">Set&lt;L&gt; vertices</p> </td><td style="vertical-align:top;width:197.2pt;"> <p style="margin-left:0cm;">符合Map-filter-reduce的处理流程，Stream写法：</p> <p style="margin-left:0cm;"><img alt="" class="has" height="128" src="https://images2.imgbox.com/64/7e/slrSHLcn_o.png" width="378"></p> <p style="margin-left:0cm;"> </p> </td></tr><tr><td style="vertical-align:top;width:203.65pt;"> <p style="margin-left:0cm;">Sources(L target)</p> </td><td style="vertical-align:top;width:197.2pt;"> <p style="margin-left:0cm;">如果没有target则返回空集合，否则调用targetVertex.getSources(getter)</p> </td></tr><tr><td style="vertical-align:top;width:203.65pt;"> <p style="margin-left:0cm;">Targets(L source)</p> </td><td style="vertical-align:top;width:197.2pt;"> <p style="margin-left:0cm;">如果没有source则返回空集合，否则调用targetVertex.getTargets(getter)</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<ol><li> 
  <ol><li> 
    <ol><li><strong><a name="_Toc1988223">Problem 3: Implement generic </a>Graph&lt;L&gt;</strong> 
      <ol><li><strong><a name="_Toc1988224">Make the implementations generic</a></strong></li></ol></li></ol></li></ol></li></ol> 
<p style="margin-left:0cm;">将类声明修改为：</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="203" src="https://images2.imgbox.com/da/9e/Se02UTQ4_o.png" width="554"></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">将类的内部函数参数、返回值、域修改为L。</p> 
<ol><li> 
  <ol><li> 
    <ol><li> 
      <ol><li><strong><a name="_Toc1988225">Implement </a>Graph.empty()</strong></li></ol></li></ol></li></ol></li></ol> 
<p style="margin-left:0cm;">修改Graph.empty为：</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="74" src="https://images2.imgbox.com/df/6b/UoWUhF7T_o.png" width="507"></p> 
<p style="margin-left:0cm;"> </p> 
<ol><li> 
  <ol><li> 
    <ol><li><strong><a name="_Toc1988226">Problem 4: Poetic walks</a></strong> 
      <ol><li><strong><a name="_Toc1988227">Test </a>GraphPoet</strong></li></ol></li></ol></li></ol></li></ol> 
<p style="margin-left:0cm;">配置文件为：new File(“src/P1/poet/mugar-omni-theater.txt”)</p> 
<p style="margin-left:0cm;">测试代码如下：</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="125" src="https://images2.imgbox.com/93/78/onxi2C40_o.png" width="554"></p> 
<p style="margin-left:0cm;"> </p> 
<ol><li> 
  <ol><li> 
    <ol><li> 
      <ol><li><strong><a name="_Toc1988228">Implement </a>GraphPoet</strong></li></ol></li></ol></li></ol></li></ol> 
<table border="1" cellspacing="0" style="width:453.35pt;"><tbody><tr><td style="vertical-align:top;width:219.5pt;"> <p style="margin-left:0cm;">域</p> </td><td style="vertical-align:top;width:233.85pt;"> <p style="margin-left:0cm;">说明</p> </td></tr><tr><td style="vertical-align:top;width:219.5pt;"> <p style="margin-left:0cm;">Private final Graph&lt;String&gt; affinityGraph</p> </td><td style="vertical-align:top;width:233.85pt;"> <p style="margin-left:0cm;">配置文件生成的Graph</p> </td></tr><tr><td style="vertical-align:top;width:219.5pt;"> <p style="margin-left:0cm;">Private final List&lt;String&gt; corpusWord</p> </td><td style="vertical-align:top;width:233.85pt;"> <p style="margin-left:0cm;">文集包含的单词</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"> </p> 
<ul><li>extractWordsFromFile(File corpus)</li></ul> 
<p style="margin-left:0cm;">读取corpus配置文件，并从中提取中所有的单词。</p> 
<p style="margin-left:0cm;">使用split进行字符串分割</p> 
<ul><li>Graph&lt;String&gt; generateAffinityGraph</li></ul> 
<p style="margin-left:0cm;">根据单词序列构造一个Graph，按照题目中对于图的定义，我们将前后两个相邻的单词之间添加一条从前向后的有向边。</p> 
<p style="margin-left:0cm;"> </p> 
<ul><li>public String poem(String input)</li></ul> 
<p style="margin-left:0cm;">首先将input切割为单词序列inputWords，对于每两个相邻的节点v1和v2，如果v1.targets()与v2.sources()存在交集，则说明两个单词之间可以添加一个bridge，自交集中选择去权重最大的一个添加到两单词之间。</p> 
<p style="margin-left:0cm;">//stream+lambda 使用实例：</p> 
<pre class="has"><code class="language-java">    public String poem(String input) {
//    	匹配任何空格
        String[] inputWords = input.split("\\s");
        StringBuilder poem = new StringBuilder();
        
        for (int i = 0; i &lt; inputWords.length; i++) {
        	poem.append(inputWords[i]+" ");
            if (i + 1 &gt;= inputWords.length) {
                break;
            }
//			获得i的出边
            Map&lt;String, Integer&gt; word1Targets = 
                    affinityGraph.targets(inputWords[i].toLowerCase());
            
//			获得i+1的入边
            Map&lt;String, Integer&gt; word2Sources =
                    affinityGraph.sources(inputWords[i+1].toLowerCase());
            Set&lt;String&gt; probableBridges = word1Targets.keySet();
            
//			stream流程：取交集 -&gt;根据权值进行排序-&gt;toList
            List&lt;String&gt; sortedBridges = probableBridges.stream()
                    .filter(possibleBridge -&gt; word2Sources.containsKey(possibleBridge))
                    .sorted((String s1,String s2)-&gt;
        			{return word1Targets.get(s2)+word2Sources.get(s2)-
        					word1Targets.get(s1)-word2Sources.get(s1);})
                    .collect(Collectors.toList());
            
            if(!sortedBridges.isEmpty()) {
            	poem.append(sortedBridges.get(0)+" ");
            }
        }
        checkRep();
        return poem.toString().trim();
    }</code></pre> 
<ol><li> 
  <ol><li> 
    <ol><li> 
      <ol><li> </li><li><strong><a name="_Toc1988229">Graph poetry slam</a></strong></li></ol></li></ol></li></ol></li></ol> 
<p style="margin-left:0cm;">Main函数实现如下：</p> 
<p style="margin-left:0cm;"> </p> 
<ol><li> 
  <ol><li> 
    <ol><li><strong><a name="_Toc1988230">Before you’re done</a></strong></li></ol></li></ol></li></ol> 
<p style="margin-left:0cm;">项目的目录结构树状示意图：</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<h3><strong><a name="_Toc1988231">Re-implement the Social Network in Lab1</a></strong></h3> 
<p> </p> 
<p style="margin-left:0cm;">继承P1中ConcreteEdgesGraph&lt;Person&gt;或者ConcreteVerticesGraph&lt;Person&gt;类 实现FriendshipGraph，通过基本操作实现FriendshipGraph中addVertex，addEdge和getDistance三个接口，要求不能修改父类rep。</p> 
<ol><li> 
  <ol><li> 
    <ol><li><strong><a name="_Toc1988232">FriendshipGraph</a>类</strong></li></ol></li></ol></li></ol> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">函数</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">实现思路</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">addVertex(Person newPerson)</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">调用父类接口this.add(newPerson)</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">addEdge(Person pa,Person pb)</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">调用父类接口this.set(pa,pb,1)</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">getDistance(Person stPerson,Person edPerson)</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">使用BFS算法求得图中stPerson与edPerson之间的最短距离，BFS中需要遍历邻居节点，这时候只需要调用父类接口this.targets(topPerson)就可以获得topPerson的所有邻居节点。</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"> </p> 
<ol><li> 
  <ol><li> 
    <ol><li><strong><a name="_Toc1988233">Person</a>类</strong></li></ol></li></ol></li></ol> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">域</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">作用</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">Private String nameString</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">记录人名</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">Private static Set&lt;String&gt; nameSet</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">记录所有出现过的人名，在构造方法中如果出现重名情况则抛出SamNameException (extends Exception)</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"> </p> 
<ol><li> 
  <ol><li> 
    <ol><li><strong><a name="_Toc1988234">客户端</a>main()</strong></li></ol></li></ol></li></ol> 
<p style="margin-left:0cm;">测试代码如下：</p> 
<p style="margin-left:0cm;"> </p> 
<ol><li> 
  <ol><li> 
    <ol><li><strong><a name="_Toc1988235">测试用例</a></strong></li></ol></li></ol></li></ol> 
<p style="margin-left:0cm;">测试普通操作：包括addVertex，addEdge，包括重名情况</p> 
<p style="margin-left:0cm;">测试getDistance：测试不能达到目的地、有多条路径达到目的地的情况。</p> 
<ol><li> 
  <ol><li> 
    <ol><li><strong><a name="_Toc1988236">提交至</a>Git仓库</strong></li></ol></li></ol></li></ol> 
<p style="margin-left:0cm;">Git add .</p> 
<p style="margin-left:0cm;">Git commit -m “P2 is DONE”</p> 
<p style="margin-left:0cm;">Git push origin master</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">项目的目录结构树状示意图如下：</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<h3><strong><a name="_Toc1988237">Playing Chess</a></strong></h3> 
<p> </p> 
<ol><li> <p><strong><strong><a name="_Toc1988238">ADT</a>设计/实现方案</strong></strong></p> </li></ol> 
<p style="margin-left:0cm;">设计了哪些ADT（接口、类），各自的rep和实现，各自的mutability/ immutability说明、AF、RI、safety from rep exposure。</p> 
<p style="margin-left:0cm;">必要时请使用UML class diagram（请自学）描述你设计的各ADT间的关系。</p> 
<ul><li>MyExp类</li></ul> 
<p style="margin-left:0cm;">自定义异常类，继承自Exception，提供的接口有：</p> 
<table border="1" cellspacing="0" style="margin-left:45pt;"><tbody><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">接口</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">作用</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">Public String getExpMsg</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">获得expMsg</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">Public void setExpMsg</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">设置expMsg</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">@Override public String toString</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">根据expMsg构造错误信息</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">Public static void assertTrue(Boolean cond,String msg) throws MyExp</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">检查cond是否正确，如果为false则抛出MyExp</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;">之所以自定义异常类，是因为使用Assert进行断言判断不合法情况的时候，AssertError只能在Junit下捕获到，当程序运行时则不能捕获，所以需要新建异常，使用MyExp来传递错误信息并进行回显。</p> 
<p style="margin-left:0cm;"> </p> 
<ul><li>Position 类</li></ul> 
<table border="1" cellspacing="0" style="margin-left:45pt;"><tbody><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">接口</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">作用</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">Public int x()</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">获得x</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">Public int y()</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">设置y</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">Override public boolean equals(Oject that)</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">判断两个Postion是否相等</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;">坐标类，承载坐标信息x,y</p> 
<p style="margin-left:0cm;"> </p> 
<ul><li>Piece类</li></ul> 
<table border="1" cellspacing="0" style="margin-left:45pt;"><tbody><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">域</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">解释</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">pieceState</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">棋子状态，0为未放置，1为已经放置，2为放置之后被拿出棋盘且不可用</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">pName</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">棋子种类名称</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">Px,py</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">棋子在棋盘中所处的坐标</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"> </p> 
<table border="1" cellspacing="0" style="margin-left:45pt;"><tbody><tr><td style="vertical-align:top;width:187.85pt;"> <p style="margin-left:0cm;">接口</p> </td><td style="vertical-align:top;width:181.95pt;"> <p style="margin-left:0cm;">作用</p> </td></tr><tr><td style="vertical-align:top;width:187.85pt;"> <p style="margin-left:0cm;">Getter for (pName, px, py,pieceState)</p> </td><td style="vertical-align:top;width:181.95pt;"> <p style="margin-left:0cm;">Getter</p> </td></tr><tr><td style="vertical-align:top;width:187.85pt;"> <p style="margin-left:0cm;">Setter for (pName,pxy)</p> </td><td style="vertical-align:top;width:181.95pt;"> <p style="margin-left:0cm;">Setter</p> </td></tr><tr><td style="vertical-align:top;width:187.85pt;"> <p style="margin-left:0cm;">Public void rmFromBoard</p> </td><td style="vertical-align:top;width:181.95pt;"> <p style="margin-left:0cm;">将该棋子从棋盘中移出，意味着不能再放入</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;">棋子类，包含棋子基本信息，提供pieceState记录棋子状态。</p> 
<p style="margin-left:0cm;"> </p> 
<ul><li>Player类</li></ul> 
<p style="margin-left:0cm;"> </p> 
<table border="1" cellspacing="0" style="margin-left:45pt;"><tbody><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">域</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">解释</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">Private String playerName</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">玩家名称</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">Private StringBuilder gameHistorySB</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">玩家操作历史</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">Private Set&lt;Piece&gt; playerPieces</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">玩家所拥有的所有棋子</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"> </p> 
<table border="1" cellspacing="0" style="margin-left:45pt;"><tbody><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">接口</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">作用</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Getter for (playerName,playerPieces,GameHistorySB)</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">Getter</p> <p style="margin-left:0cm;"> </p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public Boolean addPiece(Piece)</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">玩家添加棋子，如果玩家已有该棋子，则返回false。否则向playerPieces添加后返回true</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public Piece getAnyPieceByFilter(Predicate&lt;? Super Piece&gt; predicate)</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">获取该玩家所有满足功能函数predicate要求的棋子之中的任意一个。如果没有，则返回null</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public Boolean isContainPiece(Piece)</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">判断该玩家是否包含指定棋子</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public void addHistory(String gameStep)</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">向gameHistorySB中添加一步的操作</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;">玩家类，注意一个玩家所拥有的棋子中包含许多相同类型名称的棋子，使用对象的引用来区别不同的对象，以下相同。</p> 
<p style="margin-left:0cm;"> </p> 
<ul><li>Board类</li></ul> 
<table border="1" cellspacing="0" style="margin-left:45pt;"><tbody><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">域</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">解释</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">Private int boardType</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">棋盘类型，0为放在格子里，1为放在交点上</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">Private int boardSize</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">棋盘大小，指的是棋盘上行或列所有的格子数目</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">Private Piece boardPieces[][]</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">存放棋盘上对应位置所放的棋子</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"> </p> 
<table border="1" cellspacing="0" style="margin-left:45pt;"><tbody><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">接口</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">作用</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public Piece getPieceAtCord(px,py) throws MyExp</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">获取处于(px,py)位置的棋子，如果位置不合法抛出MyExp</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public void setPieceAtCord(int px,int py,Piece piece)</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">将棋子piece放置在棋盘的(px,py)位置处。如果位置不合法则抛出MyExp</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public isCordAvailable(int cx,int cy)</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">判断坐标(cx,cy)是否是一个合法坐标。棋盘最终的横纵可以放置的棋子数目为boardSize+boardType</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public isPieceInBoard(Piece piece)</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">判断棋子piece是否处于棋盘之内。</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public int getNumOfPlayerPiecesInBoard(Player player)</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">获得player在棋盘中的棋子数目（也可以将接口交给Player实现）</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;">棋盘类。提供操作棋盘上棋子的接口。</p> 
<p style="margin-left:0cm;">这里除了检查坐标是否合法之外不进行操作的正确性检查，将检查放到Action。</p> 
<p style="margin-left:0cm;"> </p> 
<ul><li>Action类</li></ul> 
<table border="1" cellspacing="0" style="margin-left:45pt;"><tbody><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">域</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">解释</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">Private Board gameBoard</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">游戏中棋盘对象的引用</p> </td></tr><tr><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">Private Player playerA,playerB</p> </td><td style="vertical-align:top;width:207.4pt;"> <p style="margin-left:0cm;">游戏中玩家对象AB的引用</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">//以下接口作用省略检查坐标越界的说明</p> 
<p style="margin-left:0cm;">//省略getter and setter的作用说明</p> 
<p style="margin-left:0cm;"> </p> 
<table border="1" cellspacing="0" style="margin-left:45pt;"><tbody><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">接口</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">作用</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public void putPiece(Player player,Piece piece,Position pos)</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">将玩家player的未处于棋盘的piece棋子落到pos处。修改棋子piece位置，修改棋盘gameBoard上pos位置的棋子为piece，添加玩家历史。</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public void movePiece(Player player,Position st,Position ed)</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">将玩家player的已经处于棋盘上的位于st的棋子移动到空地址ed。将棋盘上st位置设置为null，ed位置设置为piece，修改piece的位置为ed。添加玩家历史</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public void removePiece(Player player,Position pos)</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">将用户player的位于棋盘上pos的棋子移出棋盘。调用piece.rmFromBoard，将棋盘上pos位置设置为null。添加玩家历史。</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public void eatPiece(Player player,Position st.Position ed)</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">使用用户player的位于棋盘st位置的棋子吃掉到对手的ed位置的棋子。调用edPiece.rmFromBoard，将棋盘ed位置设置为stPiece，将棋盘st位置设置为null，将stPiece坐标设置为ed。添加用户历史。</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">下棋动作类。</p> 
<p style="margin-left:0cm;">异常捕捉：对于每种下棋动作，使用MyExp.assertTrue()进行异常测试，使用try catch捕捉异常，并抛出异常。</p> 
<p style="margin-left:0cm;">下棋动作的操作对象为player，gameBoard，和piece。其中playerA、playerB和gameBoard对象是Game传入的引用，因为每种操作都是建立在这两类对象的基础上的。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<ul><li>Game类</li></ul> 
<p style="margin-left:0cm;"> </p> 
<table border="1" cellspacing="0" style="margin-left:45pt;"><tbody><tr><td style="vertical-align:top;width:188.4pt;"> <p style="margin-left:0cm;">域</p> </td><td style="vertical-align:top;width:181.4pt;"> <p style="margin-left:0cm;">解释</p> </td></tr><tr><td style="vertical-align:top;width:188.4pt;"> <p style="margin-left:0cm;">Private String gameType</p> </td><td style="vertical-align:top;width:181.4pt;"> <p style="margin-left:0cm;">游戏类型</p> </td></tr><tr><td style="vertical-align:top;width:188.4pt;"> <p style="margin-left:0cm;">Private Board gameBoard</p> </td><td style="vertical-align:top;width:181.4pt;"> <p style="margin-left:0cm;">游戏棋盘</p> </td></tr><tr><td style="vertical-align:top;width:188.4pt;"> <p style="margin-left:0cm;">Private Action gameAction</p> </td><td style="vertical-align:top;width:181.4pt;"> <p style="margin-left:0cm;">游戏动作</p> </td></tr><tr><td style="vertical-align:top;width:188.4pt;"> <p style="margin-left:0cm;">Private PlayerA,PlayerB</p> </td><td style="vertical-align:top;width:181.4pt;"> <p style="margin-left:0cm;">游戏玩家，playerA为先手</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">//以下接口作用省略检查边界的说明</p> 
<p style="margin-left:0cm;">//省略getter and setter的作用说明</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<table border="1" cellspacing="0" style="margin-left:45pt;"><tbody><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">接口</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">作用</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public void iniGameWithPlayerName(String paName,String pbName)</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">通过传入的两个玩家的名字初始化Game中的各类对象。初始化：从gameType_config.txt文件中读取游戏配置，初始化player，添加拥有的棋子，初始化棋盘，设置大小和类型。将gameBoard,playerA,playerB的引用传入Action新建gameAction对象。</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public void pubPiece throws MyExp</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">调用gameAction</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public void movePiece throws MyExp</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">调用gameAction</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public void removePiece throws MyExp</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">调用gameAction</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public void eatPiece throws MyExp</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">调用gameAction</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public Player getOwnerAtCord(Positon pos) throws MyExp</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">获得处于pos位置的棋子的所有者，获得pos位置的棋子piece，然后调用Player.isContainPiece判断属于playerA还是playerB。</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public Piece getPieceAtCord(Position pos) throws MyExp</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">获取处于pos位置的棋子piece，如果没有棋子则返回null。</p> </td></tr><tr><td style="vertical-align:top;width:223.4pt;"> <p style="margin-left:0cm;">Public int getNumOfPlayerPiecesInBoard(Player player)</p> </td><td style="vertical-align:top;width:146.4pt;"> <p style="margin-left:0cm;">获取用户在棋盘上的所有棋子数目，调用gameBoard. getNumOfPlayerPiecesInBoard</p> </td></tr></tbody></table> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">游戏配置文件规范：</p> 
<p style="margin-left:0cm;"><img alt="" class="has" height="153" src="https://images2.imgbox.com/f3/e0/qNWJy0rG_o.png" width="547"></p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">游戏类。</p> 
<p style="margin-left:0cm;">主要功能为：读取文件配置，初始化Player，Board，Piece对象，为调用类提供下棋动作的接口。实现读取文件配置，将其他操作下放到具体对象。</p> 
<ol><li> 
  <ol><li> 
    <ol><li><strong><a name="_Toc1988239">主程序</a>MyChessAndGoGame设计/实现方案</strong></li></ol></li></ol></li></ol> 
<p style="margin-left:0cm;">直接贴代码：</p> 
<pre class="has"><code class="language-java">package P3;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

public class MyChessAndGoGame {

	public Set&lt;String&gt; supportGameType=new HashSet&lt;String&gt;() { {
		add("chess"); add("go");
	}};
	public Game game;
	public String playerANameString,playerBNameString;
	public ArrayList&lt;Player&gt; players = new ArrayList&lt;Player&gt;();
	
	public void printMenu() {
		System.out.println("1.\t将尚未在棋盘上的一颗棋子放在棋盘上的指定位置");
		System.out.println("2.\t移动棋盘上的某个位置的棋子至新的位置");
		System.out.println("3.\t提子（移除对手棋子）");
		System.out.println("4.\t吃子（使用己方棋子吃掉对手棋子）");
		System.out.println("5.\t查询某个位置的占用情况");
		System.out.println("6.\t计算两个玩家分别在棋盘上的棋子总数");
		System.out.println("7.\t跳过");
		System.out.println("end.\t 结束操作");
	}
	
	public void gameMain() {
		BufferedReader reader =null;
		String[] splitItems;
		try {
			reader = new BufferedReader(new InputStreamReader(System.in));
			while(true) {
				System.out.println(String.format("输入游戏类型\t%s:",
						supportGameType.stream().reduce((a,b)-&gt;a+",\t"+b)));
				String strLine= reader.readLine().trim();
				if(supportGameType.contains(strLine)) {
					game = new Game(strLine);
					break;
				} else {
					System.out.println("输入错误，请重新输入");
				}
			}
			System.out.println("[用户A]\t请输入您的名称");
			playerANameString = reader.readLine().trim();
			System.out.println("[用户B]\t请输入您的名称");
			playerBNameString = reader.readLine().trim();
			game.iniGameWithPlayerName(playerANameString, playerBNameString);
			players.add(game.getPlayerA());
			players.add(game.getPlayerB());
			System.out.println(String.format("%s，%s，游戏开始，请依次操作", 
					playerANameString,playerBNameString));
			
			int pNI=0;
			while(true) {
				System.out.println();
				System.out.println(String.format("-&gt;[%s]", players.get(pNI).getPlayerName()));
				printMenu();
				String strLine=reader.readLine().trim();
				boolean exitFlag =false;
				switch(strLine) {
					case "1":
//						将尚未在棋盘上的一颗棋子放在棋盘上的指定位置
						System.out.println("输入(pieceName,edX edY)：");
						strLine=reader.readLine().trim();
						splitItems = strLine.split("\\s");
						if(splitItems.length==3) {
							try {
								int px=Integer.valueOf(splitItems[1]);
								int py=Integer.valueOf(splitItems[2]);
								String pName=splitItems[0];
								Player player=players.get(pNI);
								Piece piece = player.getAnyPieceByFilter(
										(p)-&gt;p.getPieceState()==0 &amp;&amp; p.getpName().equals(pName));
								if(piece==null) {
									System.out.println(String.format("%s 没有未放置的 %s 棋子", player.getPlayerName(),pName));
									continue;
								}
								game.putPiece(player,
										piece, 
										new Position(px,py));
								pNI = (pNI+1)%2;
								System.out.println("[SUCCESS]");
							} catch (MyExp e) {
								System.out.println(e.toString());
								continue;
								// TODO: handle exception
							} catch(NumberFormatException e) {
								System.out.println("输入类型错误，重新输入");
								continue;
							}
						} else {
							System.out.println("输入错误，请重新输入");
							continue;
						}
						break;
					case "2":
//						移动棋盘上的某个位置的棋子至新的位置
						System.out.println("输入(stX stY edX edY)：");
						strLine=reader.readLine().trim();
						splitItems = strLine.split("\\s");
						if(splitItems.length==4) {
							try {
								int stX=Integer.valueOf(splitItems[0]),
								stY=Integer.valueOf(splitItems[1]),
								edX=Integer.valueOf(splitItems[2]),
								edY=Integer.valueOf(splitItems[3]);
								Player player=players.get(pNI);
								game.movePiece(player, 
										new Position(stX,stY), new Position(edX, edY));
								pNI = (pNI+1)%2;
								System.out.println("[SUCCESS]");
							} catch (MyExp e) {
								System.out.println(e.toString());
								continue;
								// TODO: handle exception
							} catch(NumberFormatException e) {
								System.out.println("输入类型错误，重新输入");
								continue;
							}
						} else {
							System.out.println("输入错误，请重新输入");
							continue;
						}
						break;
					case "3":
//						提子
						System.out.println("输入(edX edY)：");
						strLine=reader.readLine().trim();
						splitItems = strLine.split("\\s");
						if(splitItems.length==2) {
							try {
								int px=Integer.valueOf(splitItems[0]);
								int py=Integer.valueOf(splitItems[1]);
								Player player=players.get(pNI);
								game.removePiece(player, 
										new Position(px,py));
								pNI = (pNI+1)%2;
								System.out.println("[SUCCESS]");
								
							} catch (MyExp e) {
								System.out.println(e.toString());
								continue;
								// TODO: handle exception
							} catch(NumberFormatException e) {
								System.out.println("输入类型错误，重新输入");
								continue;
							}
						} else {
							System.out.println("输入错误，请重新输入");
							continue;
						}
						break;
					case "4":
//						吃子
						System.out.println("输入(stX stY edX edY)：");
						strLine=reader.readLine().trim();
						splitItems = strLine.split("\\s");
						if(splitItems.length==4) {
							try {
								int stX=Integer.valueOf(splitItems[0]),
								stY=Integer.valueOf(splitItems[1]),
								edX=Integer.valueOf(splitItems[2]),
								edY=Integer.valueOf(splitItems[3]);
								Player player=players.get(pNI);
								game.eatPiece(player, 
										new Position(stX,stY), new Position(edX, edY));
								pNI = (pNI+1)%2;
								System.out.println("[SUCCESS]");
							} catch (MyExp e) {
								System.out.println(e.toString());
								continue;
								// TODO: handle exception
							} catch(NumberFormatException e) {
								System.out.println("输入类型错误，重新输入");
								continue;
							}
						} else {
							System.out.println("输入错误，请重新输入");
							continue;
						}
						break;
					case "5":
//						查询某个位置的占用情况
						System.out.println("输入(edX edY)：");
						strLine=reader.readLine().trim();
						splitItems = strLine.split("\\s");
						if(splitItems.length==2) {
							try {
								int px=Integer.valueOf(splitItems[0]);
								int py=Integer.valueOf(splitItems[1]);
								Piece piece =game.getPieceAtCord(new Position(px, py));
								Player player=game.getOwnerAtCord(new Position(px,py));
								
								if(player==null) {
									System.out.println("该位置没有棋子");
								} else {
									System.out.println(String.format("该位置为 %s 的 %s 棋子",
											player.getPlayerName(),piece.getpName()));
								}
								
							} catch (MyExp e) {
								System.out.println(e.toString());
								continue;
								// TODO: handle exception
							} catch(NumberFormatException e) {
								System.out.println("输入类型错误，重新输入");
								continue;
							}
						} else {
							System.out.println("输入错误，请重新输入");
							continue;
						}
						break;
					case "6":
//						计算两个玩家分别在棋盘上的棋子总数
						System.out.println(String.format("玩家\t%s\t在棋盘上的棋子总数为%d", 
								players.get(0).getPlayerName(),game.getNumOfPlayerPiecesInBoard(players.get(0))));
						System.out.println(String.format("玩家\t%s\t在棋盘上的棋子总数为%d", 
								players.get(1).getPlayerName(),game.getNumOfPlayerPiecesInBoard(players.get(1))));
						break;
					case "7":
//						跳过
						System.out.println("[跳过]");
						pNI=(pNI+1)%2;
						break;
					case "end":
//						结束游戏操作
						System.out.println("--------&gt;&gt;&gt; END GAME &lt;&lt;&lt;--------");
						exitFlag = true;
						break;
					default:
						System.out.println("输入错误，请重新输入");
						break;
				}
				if(exitFlag) break;
			}
			
//			询问是否查看本次比赛的走棋历史
			pNI = 0;
			for(pNI=0;pNI&lt;2;pNI++) {
				while(true) {
					System.out.println();
					System.out.println(String.format("-&gt;[%s]", players.get(pNI).getPlayerName()));
					System.out.println("是否需要查看本次游戏操作历史？[yes,no]");
					boolean exitFlag = true;
					switch(reader.readLine().trim()) {
						case "yes":
							System.out.println(players.get(pNI).getGameHistoryString());
							break;
						case "no":
							break;
						default:
							exitFlag = false;
							break;
					}
					if(exitFlag) break;
				}	
			}
			System.out.println("游戏结束，再见！");
		} catch (IOException e) {
			e.printStackTrace();
		} finally {
			try {
				reader.close();
			} catch (IOException e) {
				e.printStackTrace();
				// TODO: handle exception
			}
		}
	}
	
	public static void main(String[] args) {
		new MyChessAndGoGame().gameMain();
	}

}

</code></pre> 
<p style="margin-left:0cm;"> </p> 
<ol><li> 
  <ol><li> 
    <ol><li><strong><a name="_Toc1988240">ADT</a>和主程序的测试方案</strong></li></ol></li></ol></li></ol> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">测试主要针对重要ADT，测试方案如下：</p> 
<ol><li>testGame（包含测试Action）</li></ol> 
<p style="margin-left:0cm;">测试主要包括测试Game 的配置文件载入，Game提供的各类操作接口，如putPiece，eatPiece等。</p> 
<p style="margin-left:0cm;">对于操作接口的测试，设计测试用例满足题目文档中所给出的各类边界条件。</p> 
<p style="margin-left:0cm;"> </p> 
<ol><li>testBoard</li></ol> 
<p style="margin-left:0cm;">测试主要包括测试Board的越界情况处理以及getNumOfPlayerPiecesInBoard的函数测试。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;"> </p> 
<h3><strong><a name="_Toc1988241">Multi-Startup Set (MIT)</a></strong></h3> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">//未自定义异常捕获错误。</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">RepListIntervalSet:</p> 
<pre class="has"><code class="language-java">package P4.interval;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * An implementation of IntervalSet.
 * 
 * &lt;p&gt;PS2 instructions: you MUST use the provided rep.
 */

public class RepListIntervalSet&lt;L&gt; implements IntervalSet&lt;L&gt; {
	
	/**
	 * e.g., { "A"=[0,10), "B"=[20,30) } is represented by
	 * 	labelList = &lt;"A", "B"&gt;
	 *  valueList = &lt;0, 10, 20, 30&gt;
	 */
	
	private final List&lt;L&gt; labelList = new ArrayList&lt;&gt;();
	private final List&lt;Long&gt; valueList = new ArrayList&lt;&gt;();
	
    // Abstraction function:
    //   AF(labelList,valueList)={label[i]=[valueList[2*i],valueList[2*i+1]),0&lt;=i&lt;=labellist.size()}
    // Representation invariant:
    //   RI(labelList,valueList) = sizeOfLabel*2==sizeOfValue &amp;&amp; value[2k]&lt;value[2k+1]
    // Safety from rep exposure:
	//  需要避免直接暴露接口-使用private+getter&amp;setter
    //   返回结果 避免返回类的内部域引用(包括private)
    //	   接收参数 避免接收外部对象的引用  
    //	 Collections.unmodifiableList() 将list转化为不可变 set,add,remove（mutators）会throw Exception(At Runtime)

    
    // TODO constructor
	public RepListIntervalSet() {
		// TODO Auto-generated constructor stub
	}
    
    // TODO checkRep
	private void checkRep() {
		assert labelList.size()*2 == valueList.size() : "sizeOfLabel*2==sizeOfValue";
		for(int i=0;i&lt;labelList.size();i++) {
			assert valueList.get(2*i)&lt;valueList.get(2*i+1) : "value[2k]&lt;value[2k+1]";
		}
	}
	
	/**
	 * 判断value是否处于 [start,end)区间内部
	 * 
	 * @param value
	 * @param start
	 * @param end
	 * @return 判断value是否处于 [start,end) 区间内部
	 */
	private boolean ifValueAtRange(long value,long start,long end) {
		return value&gt;=start &amp;&amp; value&lt;end;
	}
	
	@Override
	public void insert(long start, long end, L label) throws IntervalConflictException  {
		assert start&lt;end : "start&lt;end";
		boolean existFlag=false;
		for(int i=0;i&lt;labelList.size();i++) {
			if(labelList.get(i).equals(label)) {
				if(valueList.get(2*i)!=start || valueList.get(2*i+1)!=end) {
					throw new IntervalConflictException("[Exception] label冲突：但是[start,end)不同");
				} else {
					existFlag = true;
				}
			} else {
				if(ifValueAtRange(start, valueList.get(2*i), valueList.get(2*i+1))
						|| ifValueAtRange(valueList.get(2*i), start, end)) {
					throw new IntervalConflictException("[Exception] 区间冲突：包括两个重叠的区间");
				}
			}
		}
		if(!existFlag) {
			labelList.add(label);
			valueList.add(start);
			valueList.add(end);
		}
		checkRep();
//        throw new RuntimeException("not implemented");
	}
	
	@Override
	public Set&lt;L&gt; labels() {
		return labelList.stream().collect(Collectors.toSet());
//        throw new RuntimeException("not implemented");
    }
	
	@Override
	public boolean remove(L label) {
		if(!labelList.contains(label)) {
			return false;
		}
		int indexOfLabel=labelList.indexOf(label);
		labelList.remove(indexOfLabel);
		valueList.removeAll(Arrays.asList(valueList.get(2*indexOfLabel),valueList.get(2*indexOfLabel+1)));
		checkRep();
		return true;
		
//        throw new RuntimeException("not implemented");
    }
	
	@Override
	public long start(L label) throws NoSuchElementException {
		if(!labelList.contains(label))
			throw new NoSuchElementException();
		return valueList.get(2*labelList.indexOf(label));
//        throw new RuntimeException("not implemented");
    }
	
	@Override
	public long end(L label) throws NoSuchElementException {
		if(!labelList.contains(label))
			throw new NoSuchElementException();
		return valueList.get(2*labelList.indexOf(label)+1);
//        throw new RuntimeException("not implemented");
    }
	
	@Override
	public String toString() {
		return String.format("RepListIntervalSet with %d labels", labelList.size());
//        throw new RuntimeException("not implemented");
	}
}
</code></pre> 
<p style="margin-left:0cm;">RepMapIntervalSet:</p> 
<pre class="has"><code class="language-java">package P4.interval;

import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.NoSuchElementException;
import java.util.Set;

public class RepMapIntervalSet&lt;L&gt; implements IntervalSet&lt;L&gt; {

	/**
	 * e.g., { "A"=[0,10), "B"=[20,30) } is represented by
	 * 	startMap = { &lt;"A", 0&gt;, &lt;"B", 20&gt; }
	 *  endMap = { &lt;"A", 10&gt;, &lt;"B", 30&gt; }
	 */
	private final Map&lt;L, Long&gt; startMap = new HashMap&lt;&gt;();
	private final Map&lt;L, Long&gt; endMap = new HashMap&lt;&gt;();
	
    // Abstraction function:
    //   AF(startMap,endMap)={key=[startMap[key],endMap[key]) | key in startMap.keySet()}
    // Representation invariant:
    //   startMap.size()==endMap.size() &amp;&amp; startMap[key]&lt;endMap[key]
    // Safety from rep exposure:
	// Safety from rep exposure:
		//	需要避免直接暴露接口-使用private+getter&amp;setter
	    //	返回结果 避免返回类的内部域引用(包括private)
	    //	   接收参数 避免接收外部对象的引用  
	    //	 Collections.unmodifiableList() 将list转化为不可变 set,add,remove（mutators）会throw Exception(At Runtime)
    
    // TODO constructor
	public RepMapIntervalSet() {
		// TODO Auto-generated constructor stub
	}
    
    // TODO checkRep
	public void checkRep() {
		assert startMap.size()==endMap.size() :"startMap.size==endMap.size";
		for(L label :startMap.keySet()) {
			assert endMap.containsKey(label):"endMap.containsKey in startMap";
			assert startMap.get(label)&lt;endMap.get(label):"start&lt;end";
		}
	}
	
	/**
	 * 判断value是否处于 [start,end)区间内部
	 * 
	 * @param value
	 * @param start
	 * @param end
	 * @return 判断value是否处于 [start,end) 区间内部
	 */
	private boolean isValueAtRange(long value,long start,long end) {
		return value&gt;=start &amp;&amp; value&lt;end;
	}
	
	@Override
	public void insert(long start, long end, L label) throws IntervalConflictException  {
		assert start&lt;end:"start&lt;end";
		boolean insertFlag=true;
	
		for(Entry&lt;L, Long&gt; entry:startMap.entrySet()) {
			L entry_key = entry.getKey();
			Long entry_start= entry.getValue();
			Long entry_end = endMap.get(entry_key);
			if(entry_key.equals(label)) {
				if(start!=entry_start || end!=entry_end) {
					throw new IntervalConflictException("[Exception] label冲突：但是[start,end)不同");
				} else {
					insertFlag=false;
				}
			} else {
				if(isValueAtRange(start, entry_start, entry_end) 
						|| isValueAtRange(entry_start, start, end)) {
					throw new IntervalConflictException("[Exception] 区间冲突：包括两个重叠的区间");
				}
			}
		}
		if(insertFlag) {
			startMap.put(label, start);
			endMap.put(label, end);
		}
		checkRep();
//        throw new RuntimeException("not implemented");
	}
	
	@Override
	public Set&lt;L&gt; labels() {
		return startMap.keySet();
//        throw new RuntimeException("not implemented");
    }
	
	@Override
	public boolean remove(L label) {
		if(!startMap.containsKey(label)) {
			return false;
		} else {
			startMap.remove(label);
			endMap.remove(label);
			return true;
		}
//        throw new RuntimeException("not implemented");
    }
	
	@Override
	public long start(L label) throws NoSuchElementException {
		if(!startMap.containsKey(label)) {
			throw new NoSuchElementException();
		}
		return startMap.get(label);
//        throw new RuntimeException("not implemented");
    }
	
	@Override
	public long end(L label) throws NoSuchElementException {
		if(!endMap.containsKey(label)) {
			throw new NoSuchElementException();
		}
		return endMap.get(label);
//        throw new RuntimeException("not implemented");
    }
	
	@Override
	public String toString() {
		return String.format("RepMapIntervalSet with %d labels", endMap.size());
//        throw new RuntimeException("not implemented");
	}
}
</code></pre> 
<p style="margin-left:0cm;">MutiIntervalSet:</p> 
<pre class="has"><code class="language-java">package P4.interval;

import static org.junit.Assert.assertTrue;
import static org.junit.jupiter.api.Assertions.assertAll;

import java.awt.List;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Comparator;
import java.util.HashSet;
import java.util.NoSuchElementException;
import java.util.Set;

import javax.print.attribute.HashAttributeSet;

/**
 * A mutable set of labeled intervals, where each label is associated with one
 * or more non-overlapping half-open intervals [start, end). Neither intervals
 * with the same label nor with different labels may overlap. 
 * 
 * Labels are of immutable type L and must implement the Object contract: they are 
 * compared for equality using Object.equals(java.lang.Object). 
 * 
 * For example, { * "A"=[[0,10)], "B"=[[20,30)] } is a multi-interval set where 
 * the labels are Strings "A" and "B". We could add "A"=[10,20) to that set to obtain 
 * {"A"=[[0,10),[10,20)], "B"=[[20,30)] }.
 * 
 * PS2 instructions: this is a required ADT class. You may not change the
 * specifications or add new public methods. You must use IntervalSet in your
 * rep, but otherwise the implementation of this class is up to you.
 * 
 * @param &lt;L&gt; type of labels in this set, must be immutable
 */

public class MultiIntervalSet&lt;L&gt; {
	
//	将重叠集合划分为若干个不重叠集合
	private ArrayList&lt;IntervalSet&lt;L&gt;&gt; intervalSetList;
	
	/**
	 * Create an empty multi-interval set.
	 */
	public MultiIntervalSet() {
		this.intervalSetList = new ArrayList&lt;IntervalSet&lt;L&gt;&gt;();
//		throw new RuntimeException("not implemented");
	}

	/**
	 * Create a new multi-interval set containing the given labeled intervals.
	 * 
	 * @param initial initial contents of the new set
	 */
	public MultiIntervalSet(IntervalSet&lt;L&gt; initial) {
		intervalSetList = new ArrayList&lt;&gt;(Arrays.asList(initial));
//		throw new RuntimeException("not implemented");
	}
	
	/**
	 * 判断value是否处于 [start,end)区间内部
	 * 
	 * @param value
	 * @param start
	 * @param end
	 * @return 判断value是否处于 [start,end) 区间内部
	 */
	private boolean valueAtRange(long value,long start,long end) {
		return value&gt;=start &amp;&amp; value&lt;end;
	}
	

	/**
	 * Add a labeled interval (if not present) to this set, if it does not conflict with existing intervals.
	 * 
	 * Labeled intervals conflict if:
	 * 		they have the same label with different, overlapping intervals, or
	 *		they have different labels with overlapping intervals.
	 * 
	 * For example, if this set is { "A"=[[0,10),[20,30)] },
	 *		insert("A"=[0,10)) has no effect
	 *		insert("B"=[10,20)) adds "B"=[[10,20)]
	 *		insert("C"=[20,30)) throws IntervalConflictException
	 *
	 *
	 * @param start low end of the interval, inclusive
	 * @param end high end of the interval, exclusive, must be greater than start
	 * @param label label to add
	 * @throws IntervalConflictException if label is already in this set and associated 
	 * 									 with an interval other than [start,end) that 
	 * 									 overlaps [start,end), or if an interval in this 
	 * 									 set with a different label overlaps [start,end)
	 */
	public void insert(long start, long end, L label) throws IntervalConflictException {
		assert start&lt;end:"start&lt;end";
		
		int indexOfInsertLabel = -1;
		boolean existEqRangeFlag=false;
		for(int i=0;i&lt;intervalSetList.size();i++) {
			IntervalSet&lt;L&gt; itSet = intervalSetList.get(i);
			if(!itSet.labels().contains(label)) {
				indexOfInsertLabel = i;
			}
			
			for(L edLabel:itSet.labels()) {
				Long edStart = itSet.start(edLabel);
				Long edEnd = itSet.end(edLabel);
				
//				不论Label是否相同 检查区间是否重叠
				if(valueAtRange(start, edStart, edEnd)
						||valueAtRange(edStart, start, end)) {
					throw new IntervalConflictException("[EXCEPTION] label不同且区间重叠");
				}
				
				if(label.equals(edLabel) 
						&amp;&amp; edStart==start &amp;&amp;edEnd==end) {
					existEqRangeFlag = true;
				}
			}
		}
		
		if(!existEqRangeFlag) {
//			如果不存在 Label相同且区间相同 则可以插入
			if(indexOfInsertLabel==-1) {
//				此时需要新建IntervalSet进行插入
				IntervalSet&lt;L&gt; newSet=IntervalSet.empty();
				newSet.insert(start, end, label);
				intervalSetList.add(newSet);
			} else {
				intervalSetList.get(indexOfInsertLabel).insert(start, end, label);
			}
		}
		
//		throw new RuntimeException("not implemented");
	}
	
	/**
	 * Remove all intervals of the given label from this set, if any.
	 * 
	 * @param label label to remove
	 * @return true if this set contained label, and false otherwise
	 */
	public boolean removeAll(L label) {
		boolean ansFlag = false;
		for(IntervalSet&lt;L&gt; itSet:intervalSetList) {
			ansFlag = ansFlag | itSet.remove(label);
		}
		return ansFlag;
//		throw new RuntimeException("not implemented");
	}
	
	/**
	 * Get the labels in this set.
	 * 
	 * @return the labels in this set
	 */
	public Set&lt;L&gt; labels() {
		Set&lt;L&gt; ansSet = new HashSet&lt;&gt;();
		for(IntervalSet&lt;L&gt; itSet:intervalSetList) {
			ansSet.addAll(itSet.labels());
		}
		return ansSet;
//		throw new RuntimeException("not implemented");
	}
	
	/**
	 * Get all the intervals in this set associated with a given label. The returned set has 
	 * Integer labels that act as indices: label 0 is associated with the lowest interval, 
	 * 1 the next, and so on, for all the intervals in this set that have the provided label.
	 * 
	 * For example, if this set is { "A"=[[0,10),[20,30)], "B"=[[10,20)] },
	 * 		intervals("A") returns { 0=[0,10), 1=[20,30) }

	 * @param label the label
	 * @return a new interval set that associates integer indices with the in-order intervals 
	 * 		   of label in this set
	 * @throws NoSuchElementException if label is not in this set
	 */

	public IntervalSet&lt;Integer&gt; intervals(L label) throws NoSuchElementException{
		
		IntervalSet&lt;Integer&gt; ansIntervalSet = IntervalSet.empty();
		ArrayList&lt;Turple&gt; itList = new ArrayList&lt;&gt;();
		for(IntervalSet&lt;L&gt; itSet:intervalSetList) {
			if(itSet.labels().contains(label)) {
				itList.add(new Turple(itSet.start(label),itSet.end(label)));
			}
		}
		if(itList.size()==0) 
			throw new NoSuchElementException();
		
		itList.sort( (Object o1,Object o2)-&gt;{
			Turple a = (Turple)o1; 
			Turple b=(Turple)o2;
			if(a.getStart()&lt;b.getStart()) {
				return -1;
			} else if(a.getStart()&gt;b.getStart()) {
				return 1;
			}
			return 0;
		});
		
		try {
			for(int i=0;i&lt;itList.size();i++) {
				ansIntervalSet.insert(itList.get(i).getStart(), itList.get(i).getEnd(), i);
			}
		} catch (IntervalConflictException e) {
			e.printStackTrace();
		}
		return ansIntervalSet;
		
//		throw new RuntimeException("not implemented");
	}

	@Override
	public String toString() {
		return String.format("MutiIntervalSet with %d IntervalSets", intervalSetList.size());
//		throw new RuntimeException("not implemented");
	}
}


class Turple {
	private long start,end;
	
	 public Turple(long start,long end) {
		this.setStart(start);
		this.setEnd(end);
	}

	public long getStart() {
		return start;
	}

	public void setStart(long start) {
		this.start = start;
	}

	public long getEnd() {
		return end;
	}

	public void setEnd(long end) {
		this.end = end;
	}

}
</code></pre> 
<p style="margin-left:0cm;">Similarity:</p> 
<pre class="has"><code class="language-java">package P4.startup;

import java.awt.List;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.NoSuchElementException;
import java.util.Set;

import P4.interval.IntervalConflictException;
import P4.interval.IntervalSet;
import P4.interval.MultiIntervalSet;

/**
 * A [TODO mutable?] measure of similarity between multi-interval sets of
 * Strings. 
 * 
 * An instance of Similarity uses a client-provided definition of label
 * similarities, where 0 is least similar and 1 is most similar.
 * 
 * Given two multi-interval sets, let min be the minimum start of any of their
 * intervals, and let max be the maximum end. The similarity between the two
 * sets is the ratio: 
 * 		(sum of piecewise-matching between the sets) / (max - min)
 * 
 * The amount of piecewise-matching for any unit interval [i, i+1) is:
 * 		0 if neither set has a label on that interval 
 * 		0 if only one set has a label on that interval 
 * 		otherwise, the similarity between the labels as defined for this Similarity instance 
 * 
 * For example, suppose you have multi-interval sets that use labels "happy", "sad", and "meh"; 
 * and similarity between labels is defined as:
 * 
 * 		1 if both are "happy", both "sad", or both "meh" 
 * 		0.5 if one is "meh" and the other is "happy" or "sad" 
 * 		0 otherwise 
 * 
 * Then the similarity between these two sets: 
 * 		{ "happy" = [[0, 1), [2,4)], "sad" = [[1,2)] } 
 * 		{ "sad" = [[1, 2)], "meh" = [[2,3)], "happy" = [[3,4)] } 
 * 
 * would be: (0 + 1 + 0.5 + 1) / (4 - 0) = 0.625
 * 
 * PS2 instructions: this is a required ADT class, and you MUST NOT weaken the
 * required specifications. However you MAY strengthen the specifications and
 * you MAY add additional methods.
 */

public class Similarity {
	
	private ArrayList&lt;Triple&gt; simRulesArrayList;
	
	/**
	 * Create a new Similarity where similarity between labels is defined in the given file. 
	 * Each line of similarities must contain exactly three pieces, separated by one or more spaces. 
	 * The first two pieces give a pair of strings, and the third piece gives the decimal similarity 
	 * between them, in a format allowed by Double.valueOf(String), between 0 and 1 inclusive. 
	 * 
	 * Similarity between labels is symmetric, so the order of strings in the pair is irrelevant. 
	 * A pair may not appear more than once. The similarity between all other pairs of strings is 0. 
	 * This format cannot define non-zero similarity for strings that contain newlines or spaces, 
	 * or for the empty string.
	 * 
	 * For example, the following file defines the similarity function used in the example at the top of this class:

 	 * happy happy 1
 	 * sad   sad   1
 	 * meh   meh   1
 	 * meh   happy 0.5
 	 * meh   sad   0.5

	 * @param similarities label similarity definition as described above
	 * @throws IOException if the similarity file cannot be found or read
	 */
	public Similarity(File similarities) throws IOException {
		simRulesArrayList = new ArrayList&lt;&gt;();
		BufferedReader reader = new BufferedReader(new FileReader(similarities));
		String stringLine=reader.readLine();
		while(stringLine!=null) {
			String[] splitLine=stringLine.split("\\s");
//			System.out.println(splitLine[0]+splitLine[1]+splitLine[2]);
			simRulesArrayList.add(new Triple(splitLine[0], splitLine[1], Double.valueOf(splitLine[2])));
			if(!splitLine[0].equals(splitLine[1])) {
				simRulesArrayList.add(new Triple(splitLine[1], splitLine[0], Double.valueOf(splitLine[2])));
			}
			stringLine = reader.readLine();
		}
//		throw new RuntimeException("not implemented");
	}
	
	/**
	 * 判断value是否处于 [start,end)区间内部
	 * 
	 * @param value
	 * @param start
	 * @param end
	 * @return 判断value是否处于 [start,end) 区间内部
	 */
	public static boolean valueAtRange(long value,long start,long end) {
		return value&gt;=start &amp;&amp; value&lt;end;
	}
	
	public static int rangeContain(long stA,long edA,long stB,long edB) {
		if(valueAtRange(stA, stB, edB) &amp;&amp; edA&gt;=stB &amp;&amp; edA&lt;=edB) {
//			A被B包含
			return 1;
		}
		if(valueAtRange(stB, stA, edA) &amp;&amp; edB&gt;=stA &amp;&amp; edB&lt;=edA) {
//			B被A包含
			return 2;
		}
//		不存在包含关系
		return 0;
	}
	
	/**
	 * 	计算两个MutilIntervalSet的交集长度
	 * @param itA
	 * @param itB
	 * @return 交集长度
	 */
	public static Double caculatePieceWiseMatching(IntervalSet&lt;Integer&gt; itA,IntervalSet&lt;Integer&gt; itB) {
		int pa=0,pb=0;
		int paLen=itA.labels().size(),pbLen=itB.labels().size();
		Double matchingLenDouble = 0.0;
		while(true) {
			if(pa&gt;=paLen || pb&gt;=pbLen) {
				break;
			}
			long startA = itA.start(pa),startB = itB.start(pb);
			long endA = itA.end(pa),endB = itB.end(pb);
			int containType=rangeContain(startA, endA, startB, endB);
			if(containType==1) {
//				A被B包含
				matchingLenDouble += endA-startA;  
				pa++;
			} else if(containType==2) {
//				B被A包含
				matchingLenDouble += endB-startB;
				pb++;
			} else {
				if(valueAtRange(startA, startB, endB)) {
//					交集：startA位于B区间
					matchingLenDouble += endB-startA;
					pb++;
				} else if(valueAtRange(startB, startA, endA)) {
//					交集：startB位于A区间
					matchingLenDouble += endA-startB;
					pa++;
				} else {
					if(startA&lt;startB) pa++;
					else pb++;
				}
			}
		}
		return matchingLenDouble;
	}
	
	/**
	 * Compute similarity between two multi-interval sets. Returns a value between 0 and 1 inclusive.
	 * 
	 * @param a non-empty multi-interval set of strings
	 * @param b non-empty multi-interval set of strings
	 * @return similarity between a and b as defined above
	 */
	public double similarity​(MultiIntervalSet&lt;String&gt; a, MultiIntervalSet&lt;String&gt; b) {
		Set&lt;String&gt; labelListA = a.labels();
		Set&lt;String&gt; labelListB = b.labels();
		Double ansDouble = 0.0;
		long minDouble=Long.MAX_VALUE,maxDouble=Long.MIN_VALUE;
		
		try {
			for(String label:labelListA) {
				IntervalSet&lt;Integer&gt; itSet=a.intervals(label);
				for(int i=0;i&lt;itSet.labels().size();i++) {
					long st=itSet.start(i);
					long ed=itSet.end(i);
					if(st&lt;minDouble) minDouble=st;
					if(ed&gt;maxDouble) maxDouble=ed;
				}
			}
			for(String label:labelListB) {
				IntervalSet&lt;Integer&gt; itSet=b.intervals(label);
				for(int i=0;i&lt;itSet.labels().size();i++) {
					long st=itSet.start(i);
					long ed=itSet.end(i);
					if(st&lt;minDouble) minDouble=st;
					if(ed&gt;maxDouble) maxDouble=ed;
				}
			}
		} catch (NoSuchElementException e) {
			// TODO: handle exception
			e.printStackTrace();
		}
		for(Triple triple:simRulesArrayList) {
			String labelStart=triple.getStart();
			String labelEnd=triple.getEnd();
			Double labelValue=triple.getValue();
			if(labelListA.contains(labelStart)&amp;&amp;labelListB.contains(labelEnd)) {
				ansDouble += labelValue*caculatePieceWiseMatching(a.intervals(labelStart), b.intervals(labelEnd));
			}
		}
		
		return ansDouble/(maxDouble-minDouble);
//		throw new RuntimeException("not implemented");
	}
}

class Triple {
	private String start,end;
	private Double value;
	
	 public Triple(String start,String end,Double value) {
		this.setStart(start);
		this.setEnd(end);
		this.setValue(value);
	}

	public String getStart() {
		return start;
	}


	public void setStart(String start) {
		this.start = start;
	}


	public String getEnd() {
		return end;
	}


	public void setEnd(String end) {
		this.end = end;
	}


	public Double getValue() {
		return value;
	}

	public void setValue(Double value) {
		this.value = value;
	}
	

}
</code></pre> 
<p> </p> 
<p> </p> 
<p> </p> 
<p>                                                                           <strong>我是迷人的小尾巴</strong></p> 
<hr> 
<p>以下外链，利益相关，欢迎浏览ε≡٩(๑&gt;₃&lt;)۶ ：</p> 
<p><a href="http://www.jnjiangpeng.com/" rel="nofollow">济南江鹏工贸有限公司</a>（<a href="http://www.jnjiangpeng.com/" rel="nofollow">山东济南机械加工</a>），<a href="http://www.jntcjx.cn/index.html" rel="nofollow">济南彤昌机械科技有限公司</a>（<a href="http://www.jntcjx.cn/index.html" rel="nofollow">山东济南机械加工</a>）</p> 
<p style="margin-left:0cm;"> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fcf26a1140da7705535e8b689b9ea46f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux下关闭防火墙与NetworkManager（转载）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/446305152988d68304aa698b6a43c38a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AriaNg 无法连接 aria</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>