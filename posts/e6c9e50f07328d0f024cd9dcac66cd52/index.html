<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【C&#43;&#43;核心编程(四)】 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【C&#43;&#43;核心编程(四)】" />
<meta property="og:description" content="一、继承 继承是面向对象三大特性之一。
有些类与类之间存在特殊的关系，例如下图中:
我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。
这个时候我们就可以考虑利用继承的技术，减少重复代码。
1.1、继承的基本语法 例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同，接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处。
//普通实现页面 //Java class Java { public: void header() { cout &lt;&lt; &#34;首页、公开课、登陆、注册...(公共头部)&#34; &lt;&lt; endl; } void footer() { cout &lt;&lt; &#34;帮助中心、交流合作、站内地图...(公共底部)&#34; &lt;&lt; endl; } void left() { cout &lt;&lt; &#34;Java、C&#43;&#43;、Python...(公共分类列表)&#34; &lt;&lt; endl; } void content() { cout &lt;&lt; &#34;Java学科视频&#34; &lt;&lt; endl; } }; //Python class Python { public: void header() { cout &lt;&lt; &#34;首页、公开课、登陆、注册...(公共头部)&#34; &lt;&lt; endl; } void footer() { cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e6c9e50f07328d0f024cd9dcac66cd52/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-07T14:48:42+08:00" />
<meta property="article:modified_time" content="2024-01-07T14:48:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【C&#43;&#43;核心编程(四)】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>一、继承</h3> 
<p><strong>继承是面向对象三大特性之一。</strong></p> 
<p>有些类与类之间存在特殊的关系，例如下图中:</p> 
<p><img alt="" height="414" src="https://images2.imgbox.com/d9/86/HKJgjcyi_o.png" width="1200"></p> 
<p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p> 
<p>这个时候我们就可以考虑利用继承的技术，减少重复代码。</p> 
<h4>1.1、继承的基本语法</h4> 
<p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同，接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处。</p> 
<pre><code>//普通实现页面
//Java
class Java
{
public:
	void header()
	{
		cout &lt;&lt; "首页、公开课、登陆、注册...(公共头部)" &lt;&lt; endl;
	}

	void footer()
	{
		cout &lt;&lt; "帮助中心、交流合作、站内地图...(公共底部)" &lt;&lt; endl;
	}

	void left()
	{
		cout &lt;&lt; "Java、C++、Python...(公共分类列表)" &lt;&lt; endl;
	}

	void content()
	{
		cout &lt;&lt; "Java学科视频" &lt;&lt; endl;
	}
};

//Python
class Python
{
public:
	void header()
	{
		cout &lt;&lt; "首页、公开课、登陆、注册...(公共头部)" &lt;&lt; endl;
	}

	void footer()
	{
		cout &lt;&lt; "帮助中心、交流合作、站内地图...(公共底部)" &lt;&lt; endl;
	}

	void left()
	{
		cout &lt;&lt; "Java、C++、Python...(公共分类列表)" &lt;&lt; endl;
	}

	void content()
	{
		cout &lt;&lt; "Python学科视频" &lt;&lt; endl;
	}
};

//C++
class CPlusPlus
{
public:
	void header()
	{
		cout &lt;&lt; "首页、公开课、登陆、注册...(公共头部)" &lt;&lt; endl;
	}

	void footer()
	{
		cout &lt;&lt; "帮助中心、交流合作、站内地图...(公共底部)" &lt;&lt; endl;
	}

	void left()
	{
		cout &lt;&lt; "Java、C++、Python...(公共分类列表)" &lt;&lt; endl;
	}

	void content()
	{
		cout &lt;&lt; "C++学科视频" &lt;&lt; endl;
	}
};

//继承实现上述代码 - 好处:减少重复的代码
//语法:class 子类(派生类) : 继承方式 父类(基类)

//公共页面类
class BasePage
{
public:
	void header()
	{
		cout &lt;&lt; "首页、公开课、登陆、注册...(公共头部)" &lt;&lt; endl;
	}

	void footer()
	{
		cout &lt;&lt; "帮助中心、交流合作、站内地图...(公共底部)" &lt;&lt; endl;
	}

	void left()
	{
		cout &lt;&lt; "Java、C++、Python...(公共分类列表)" &lt;&lt; endl;
	}
};

//Java页面
class Java :public BasePage
{
public:
	void content()
	{
		cout &lt;&lt; "Java学科视频" &lt;&lt; endl;
	}
};

//Python页面
class Python :public BasePage
{
public:
	void content()
	{
		cout &lt;&lt; "Python学科视频" &lt;&lt; endl;
	}
};

//C++页面
class CPlusPlus :public BasePage
{
public:
	void content()
	{
		cout &lt;&lt; "C++学科视频" &lt;&lt; endl;
	}
};

void test01()
{
	cout &lt;&lt; "Java页面如下：" &lt;&lt; endl;
	Java java;
	java.header();
	java.footer();
	java.left();
	java.content();

	cout &lt;&lt; "---------------------" &lt;&lt; endl;
	cout &lt;&lt; "Python页面如下：" &lt;&lt; endl;
	Python python;
	python.header();
	python.footer();
	python.left();
	python.content();

	cout &lt;&lt; "---------------------" &lt;&lt; endl;
	cout &lt;&lt; "C++页面如下：" &lt;&lt; endl;
	CPlusPlus c;
	c.header();
	c.footer();
	c.left();
	c.content();
}

int main()
{
	test01();

	system("pause");
	return 0;
}</code></pre> 
<p><strong>总结:</strong></p> 
<p>继承的好处:<span style="color:#fe2c24;"><strong>可以减少重复的代码</strong></span></p> 
<p>class A : public B;</p> 
<p>A 类称为子类或派生类；B 称为父类或基类。</p> 
<p><strong>派生类中的成员，包含两大部分:</strong></p> 
<p>一类是从基类继承过来的，一类是自己增加的成员。</p> 
<p>从基类继承过来的表现其共性，而新增的成员体现了其个性。 </p> 
<h4>1.2、继承方式</h4> 
<p>继承的语法: class 子类 : 继承方式 父类</p> 
<p><strong>继承方式一共有三种: </strong></p> 
<p><strong>·</strong>公共继承</p> 
<p><strong>·</strong>保护继承</p> 
<p><strong>·</strong>私有继承</p> 
<p><img alt="" height="478" src="https://images2.imgbox.com/6c/dc/eIpmuIOf_o.png" width="692"></p> 
<h4>1.3、继承中的对象模型</h4> 
<p><strong>问题:</strong> 从父类继承过来的成员，哪些属于子类对象中?</p> 
<pre><code>class Base
{
public:
	int m_A;
protected:
	int m_B;
private:
	int m_C;
};

class Son :public Base
{
public:
	int m_D;
};

void test01()
{
	//父类中所有非静态成员属性都会被子类继承下去
	//父类中的私有成员属性是被编译器给隐藏了,因此访问不到但是确实是被继承下去了
	cout &lt;&lt; "size of Son = " &lt;&lt; sizeof(Son) &lt;&lt; endl;
}

int main()
{
	test01();

	system("pause");
	return 0;
}</code></pre> 
<p><img alt="" height="116" src="https://images2.imgbox.com/5e/2c/XGwpNi22_o.png" width="627"></p> 
<p><img alt="" height="497" src="https://images2.imgbox.com/7f/21/gDVhhRxE_o.png" width="366"><img alt="" height="400" src="https://images2.imgbox.com/c6/85/fVlCLFq1_o.png" width="522"><img alt="" height="609" src="https://images2.imgbox.com/89/aa/kWWzMBdu_o.png" width="1187"></p> 
<p><img alt="" height="449" src="https://images2.imgbox.com/e6/22/WXotFFzF_o.png" width="1200"><img alt="" height="610" src="https://images2.imgbox.com/21/56/UGfNEWDv_o.png" width="978"></p> 
<p><img alt="" height="639" src="https://images2.imgbox.com/65/eb/RoMkwkCk_o.png" width="1200">利用开发人员命令提示工具查看对象模型：</p> 
<p>①跳转盘符 - C:</p> 
<p>②跳转文件路径 - cd 具体路径下</p> 
<p>③查看命名</p> 
<p>④cl(l - 小写L) /d1 reportSingleClassLayout类名 文件名(按tab键自动补齐)</p> 
<p>结论:父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到。</p> 
<h4>1.4、继承中构造和析构顺序</h4> 
<p>子类继承父类后，当创建子类对象，也会调用父类的构造函数。</p> 
<p>问题: 父类和子类的构造和析构顺序是谁先谁后?</p> 
<pre><code>class Base
{
public:
	Base()
	{
		cout &lt;&lt; "Base的构造函数!" &lt;&lt; endl;
	}

	~Base()
	{
		cout &lt;&lt; "Base的析构函数!" &lt;&lt; endl;
	}
};

class Son :public Base
{
public:
	Son()
	{
		cout &lt;&lt; "Son的构造函数!" &lt;&lt; endl;
	}

	~Son()
	{
		cout &lt;&lt; "Son的析构函数!" &lt;&lt; endl;
	}
};

void test01()
{
	//Base b;

	//继承中的构造和析构的顺序:先构造父类,再构造子类,析构的顺序与构造的顺序相反
	Son s;
}

int main()
{
	test01();

	system("pause");
	return 0;
}</code></pre> 
<p><img alt="" height="168" src="https://images2.imgbox.com/29/df/zFp51w3p_o.png" width="624"></p> 
<p>总结: 继承中先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反。</p> 
<h4>1.5、继承同名成员处理方式</h4> 
<p>问题:当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢?</p> 
<p><strong>·</strong>访问子类同名成员 - 直接访问即可。</p> 
<p><strong>·</strong>访问父类同名成员 - 需要加作用域。</p> 
<pre><code>class Base
{
public:
	Base()
	{
		m_A = 100;
	}

	void func()
	{
		cout &lt;&lt; "Base - func()" &lt;&lt; endl;
	}
	void func(int a)
	{
		cout &lt;&lt; "Base - func(int a)" &lt;&lt; endl;
	}

	int m_A;
};

class Son :public Base
{
public:
	Son()
	{
		m_A = 200;
	}

	void func()
	{
		cout &lt;&lt; "Son - func()" &lt;&lt; endl;
	}

	int m_A;
};

//同名成员属性处理方式
void test01()
{
	Son s;
	cout &lt;&lt; "Son.m_A = " &lt;&lt; s.m_A &lt;&lt; endl;
	//如果通过子类对象访问到父类同名成员,需要加作用域
	cout &lt;&lt; "Base.m_A = " &lt;&lt; s.Base::m_A &lt;&lt; endl;
}

//同名成员函数处理方式
void test02()
{
	Son s;
	s.func();//直接调用 - 调用的是子类的同名成员
	//如何调用父类中的同名成员函数?
	s.Base::func();

	//如果子类中出现和父类同名的成员函数,子类的同名成员会隐藏掉父类中所有的同名成员函数
	//如果想访问到父类中被隐藏的同名成员函数,需要加作用域
	s.Base::func(100);
}

int main()
{
	test01();
	test02();

	system("pause");
	return 0;
}</code></pre> 
<p><img alt="" height="171" src="https://images2.imgbox.com/ac/f7/7Jn4NOgV_o.png" width="619"></p> 
<p>总结:<br> 1.子类对象可以直接访问到子类中同名成员。<br> 2.子类对象加作用域可以访问到父类同名成员。<br> 3.当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数。</p> 
<h4>1.6、继承同名静态成员处理方式</h4> 
<p>问题: 继承中同名的静态成员在子类对象上如何进行访问?</p> 
<p>静态成员和非静态成员出现同名，处理方式一致 </p> 
<p><strong>·</strong>访问子类同名成员 - 直接访问即可</p> 
<p><strong>·</strong>访问父类同名成员 - 需要加作用域</p> 
<pre><code>class Base
{
public:
	static int m_A;

	static void func()
	{
		cout &lt;&lt; "Base.static.func()" &lt;&lt; endl;
	}

	static void func(int a)
	{
		cout &lt;&lt; "Base.static.func(int a)" &lt;&lt; endl;
	}
};
int Base::m_A = 200;

class Son :public Base
{
public:
	static int m_A;

	static void func()
	{
		cout &lt;&lt; "Son.static.func()" &lt;&lt; endl;
	}
};
int Son::m_A = 100;

//同名静态成员属性
void test01()
{
	//1.通过对象访问
	cout &lt;&lt; "通过对象访问:" &lt;&lt; endl;
	Son s;
	cout &lt;&lt; "Son.m_A = " &lt;&lt; s.m_A &lt;&lt; endl;
	cout &lt;&lt; "Base.m_A = " &lt;&lt; s.Base::m_A &lt;&lt; endl;

	//2.通过类名访问
	cout &lt;&lt; "通过类名方式访问:"&lt;&lt; endl;
	cout &lt;&lt; "Son.m_A = " &lt;&lt; Son::m_A &lt;&lt; endl;
	//第一个::代表通过类名的方式访问 - 第二个::代表访问父类的作用域下
	cout &lt;&lt; "Base.m_A = " &lt;&lt; Son::Base::m_A &lt;&lt; endl;
}

//同名静态成员函数
void test02()
{
	//1.通过对象访问
	cout &lt;&lt; "通过对象访问:" &lt;&lt; endl;
	Son s;
	s.func();
	s.Base::func();

	//2.通过类名访问
	cout &lt;&lt; "通过类名方式访问:" &lt;&lt; endl;
	Son::func();
	Son::Base::func();

	//子类出现和父类同名的静态成员函数,也会隐藏父类中所有同名的静态成员函数
	//如果想访问父类中被隐藏的同名成员,需要加作用域
	Son::Base::func(100);
}

int main()
{
	test01();
	test02();

	system("pause");
	return 0;
}</code></pre> 
<p><img alt="" height="337" src="https://images2.imgbox.com/f1/09/YloWfAF4_o.png" width="628"></p> 
<p>总结:同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式(通过对象和通过类名)</p> 
<h4>1.7、多继承语法</h4> 
<p>C++允许<strong>一个类继承多个类</strong></p> 
<p>语法: class 子类 : 继承方式 父类1 ， 继承方式 父类2...</p> 
<p>多继承可能会引发父类中有同名成员出现，需要加作用域区分。</p> 
<p><strong>C++实际开发中不建议用多继承</strong></p> 
<pre><code>class Base1
{
public:
	Base1()
	{
		m_A = 100;
	}

	int m_A;
};

class Base2
{
public:
	Base2()
	{
		m_A = 200;
	}

	int m_A;
};

//子类继承Base1和Base2
//语法: class 子类 : 继承方式 父类1 , 继承方式 父类2 ...
class Son :public Base1 , public Base2
{
public:
	int m_C;
	int m_D;

	Son()
	{
		m_C = 300;
		m_D = 400;
	}
};

void test01()
{
	Son s;
	cout &lt;&lt; "size of (Son) = " &lt;&lt; sizeof(s) &lt;&lt; endl;

	//当父类中出现同名的成员,需要加作用域区分
	cout &lt;&lt; "Base1.m_A = " &lt;&lt; s.Base1::m_A &lt;&lt; endl;
	cout &lt;&lt; "Base2.m_A = " &lt;&lt; s.Base2::m_A &lt;&lt; endl;
}


int main()
{
	test01();

	system("pause");
	return 0;
}</code></pre> 
<p><img alt="" height="149" src="https://images2.imgbox.com/3d/b7/T6I9m8UI_o.png" width="628"></p> 
<p>总结: 多继承中如果父类中出现了同名情况，子类使用时候要加作用域。</p> 
<h4>1.8、菱形继承</h4> 
<p><strong>菱形继承概念:</strong></p> 
<p>两个派生类继承同一个基类；<br> 又有某个类同时继承着两个派生类；<br> 这种继承被称为菱形继承，或者钻石继承。</p> 
<p><strong>典型的菱形继承案例:</strong></p> 
<p><img alt="" height="542" src="https://images2.imgbox.com/c9/31/svY2Elfz_o.png" width="675"></p> 
<p><strong>菱形继承问题:</strong></p> 
<p>1.羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</p> 
<p>2. 草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。 </p> 
<pre><code>//动物类
class Animal
{
public:
	int m_Age;
};

//利用虚继承可以解决菱形继承带来的问题
//在继承之前加上关键字virtual变为虚继承
//Animal类称为虚基类
//羊类
class Sheep :virtual public Animal
{
public:
	
};

//驼类
class Tuo :virtual public Animal
{
public:

};

//羊驼类
class SheepTuo :public Sheep , public Tuo
{
public:

};

void test01()
{
	SheepTuo st;

	st.Sheep::m_Age = 18;
	st.Tuo::m_Age = 28;

	//当菱形继承时,两个父类拥有相同数据,需要加以作用域区分
	cout &lt;&lt; "Sheep::m_Age = " &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;
	cout &lt;&lt; "Tuo::m_Age = " &lt;&lt; st.Tuo::m_Age &lt;&lt; endl;
	cout &lt;&lt; "st.m_Age = " &lt;&lt; st.m_Age &lt;&lt; endl;

	//这份数据我们明确只需要有一份即可,菱形继承导致数据有两份,资源浪费
}


int main()
{
	test01();

	system("pause");
	return 0;
}</code></pre> 
<p><img alt="" height="133" src="https://images2.imgbox.com/74/19/ocSzrwst_o.png" width="619"></p> 
<p><img alt="" height="358" src="https://images2.imgbox.com/a5/a6/2c0rNAZ2_o.png" width="627"></p> 
<p><img alt="" height="112" src="https://images2.imgbox.com/dc/1e/aXLfURhV_o.png" width="613"></p> 
<p><img alt="" height="162" src="https://images2.imgbox.com/f5/ab/mGs00OtE_o.png" width="777"><img alt="" height="114" src="https://images2.imgbox.com/e8/ce/SgJSo2kP_o.png" width="750"></p> 
<p><img alt="" height="639" src="https://images2.imgbox.com/a2/c4/yu1w80Ok_o.png" width="1200"></p> 
<p><img alt="" height="332" src="https://images2.imgbox.com/73/f6/WkUllYgn_o.png" width="645"></p> 
<p><img alt="" height="639" src="https://images2.imgbox.com/07/6c/PXV4PRQ1_o.png" width="1200"></p> 
<p>总结:</p> 
<p><strong>·</strong>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义。</p> 
<p><strong>·</strong>利用虚继承可以解决菱形继承问题。</p> 
<h3>二、多态 </h3> 
<h4 style="background-color:transparent;">2.1、多态的基本概念</h4> 
<p><strong>多态是C++面向对象三大特性之一</strong></p> 
<p>多态分为两类：<br><strong>·</strong>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</p> 
<p><strong>·</strong>动态多态: 派生类和虚函数实现运行时多态</p> 
<p>静态多态和动态多态区别:<br><strong>·</strong>静态多态的函数地址早绑定 - 编译阶段确定函数地址<br><strong>·</strong>动态多态的函数地址晚绑定 - 运行阶段确定函数地址 </p> 
<p>下面通过案例进行讲解多态：</p> 
<pre><code>//动物类
class Animal
{
public:
	//虚函数
	virtual void speak()
	{
		cout &lt;&lt; "动物叫唤!" &lt;&lt; endl;
	}
};

//猫类
class Cat :public Animal
{
public:
	void speak()
	{
		cout &lt;&lt; "喵喵喵!" &lt;&lt; endl;
	}
};

//狗类
class Dog :public Animal
{
public:
	//重写 - 函数返回值类型、函数名、参数列表完全相同
	//子类重写的函数前面的virtual可写可不写
	virtual void speak()
	{
		cout &lt;&lt; "旺旺旺!" &lt;&lt; endl;
	}
};

//执行说话的函数
//地址早绑定 - 在编译阶段确定函数的地址
//如果想执行让猫说话,那么这个函数地址就不能提前绑定,需要在运行阶段进行绑定 - 地址晚绑定
void DoSpeak(Animal &amp;animal)//Animal&amp; animal = cat;
{
	animal.speak();
}
//动态多态满足条件:
//1.有继承关系
//2.子类重写父类的虚函数
//动态多态的使用:父类的指针或者引用指向子类对象

void test01()
{
	Cat cat;
	DoSpeak(cat);

	Dog dog;
	DoSpeak(dog);
}

int main()
{
	test01();

	system("pause");
	return 0;
}</code></pre> 
<p><img alt="" height="136" src="https://images2.imgbox.com/dc/37/2HfzKuDt_o.png" width="600"></p> 
<p><img alt="" height="626" src="https://images2.imgbox.com/26/03/i3SIIXAU_o.png" width="1200"><img alt="" height="339" src="https://images2.imgbox.com/eb/31/usUdd2Kc_o.png" width="588"></p> 
<p><img alt="" height="299" src="https://images2.imgbox.com/85/57/gBaH7w1r_o.png" width="540"></p> 
<p><img alt="" height="639" src="https://images2.imgbox.com/59/fa/B1FGL5FI_o.png" width="988"></p> 
<p><img alt="" height="135" src="https://images2.imgbox.com/fb/ed/kj4tiQd7_o.png" width="613"></p> 
<p><img alt="" height="323" src="https://images2.imgbox.com/5e/2f/ZQnvVgFN_o.png" width="551"></p> 
<p><img alt="" height="368" src="https://images2.imgbox.com/df/29/UPTB952C_o.png" width="747"></p> 
<p><img alt="" height="639" src="https://images2.imgbox.com/fb/5d/71GccTGo_o.png" width="1200"></p> 
<p>总结：</p> 
<p>多态满足条件：<br><strong>·</strong>有继承关系<br><strong>·</strong>子类重写父类中的虚函数</p> 
<p>多态使用条件：<br><strong>·</strong>父类指针或引用指向子类对象<br> 重写: 函数返回值类型、函数名、参数列表完全一致称为重写。</p> 
<h4>2.2、多态案例一 - 计算器类</h4> 
<p>案例描述:<br> 分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类。</p> 
<p>多态的优点:<br><strong>·</strong>代码组织结构清晰<br><strong>·</strong>可读性强<br><strong>·</strong>利于前期和后期的扩展以及维护</p> 
<pre><code class="hljs">class Calculator
{
public:
	int m_Num1;
	int m_Num2;

	int getResult(string oper)
	{
		if (oper == "+")
		{
			return m_Num1 + m_Num2;
		}
		else if (oper == "-")
		{
			return m_Num1 - m_Num2;
		}
		else if (oper == "*")
		{
			return m_Num1 * m_Num2;
		}
		//如果想要扩展新的功能需要修改源码
		//在真正的开发中提倡:开闭原则 - 对扩展进行开放,对修改进行关闭
	}
};

void test01()
{
	//创建计算器对象
	Calculator cal;
	cal.m_Num1 = 10;
	cal.m_Num2 = 10;

	cout &lt;&lt; cal.m_Num1 &lt;&lt; " + " &lt;&lt; cal.m_Num2 &lt;&lt; " = " &lt;&lt; cal.getResult("+") &lt;&lt; endl;
	cout &lt;&lt; cal.m_Num1 &lt;&lt; " - " &lt;&lt; cal.m_Num2 &lt;&lt; " = " &lt;&lt; cal.getResult("-") &lt;&lt; endl;
	cout &lt;&lt; cal.m_Num1 &lt;&lt; " * " &lt;&lt; cal.m_Num2 &lt;&lt; " = " &lt;&lt; cal.getResult("*") &lt;&lt; endl;
}

//利用多态实现计算器
//实现计算器的抽象类
class AbstractCalculator
{
public:
	int m_Num1;
	int m_Num2;

	virtual int getResult()
	{
		return 0;
	}
};

//加法计算器类
class AddCalculator :public AbstractCalculator
{
	int getResult()
	{
		return m_Num1 + m_Num2;
	 }

};

//减法计算器类
class SubCalculator :public AbstractCalculator
{
	int getResult()
	{
		return m_Num1 - m_Num2;
	}

};

//乘法计算器类
class MulCalculator :public AbstractCalculator
{
	int getResult()
	{
		return m_Num1 * m_Num2;
	}

};

void test02()
{
	//多态使用条件 - 父类指针或者引用指向子类对象

	//加法运算
	AbstractCalculator* abs = new AddCalculator;
	abs-&gt;m_Num1 = 100;
	abs-&gt;m_Num2 = 100;

	cout &lt;&lt; abs-&gt;m_Num1 &lt;&lt; " + " &lt;&lt; abs-&gt;m_Num2 &lt;&lt; " = " &lt;&lt; abs-&gt;getResult() &lt;&lt; endl;
	//用完后记得销毁
	delete abs;

	//减法运算
	abs = new SubCalculator;
	abs-&gt;m_Num1 = 100;
	abs-&gt;m_Num2 = 100;	
	cout &lt;&lt; abs-&gt;m_Num1 &lt;&lt; " - " &lt;&lt; abs-&gt;m_Num2 &lt;&lt; " = " &lt;&lt; abs-&gt;getResult() &lt;&lt; endl;
	delete abs;

	//乘法运算
	abs = new MulCalculator;
	abs-&gt;m_Num1 = 100;
	abs-&gt;m_Num2 = 100;
	cout &lt;&lt; abs-&gt;m_Num1 &lt;&lt; " * " &lt;&lt; abs-&gt;m_Num2 &lt;&lt; " = " &lt;&lt; abs-&gt;getResult() &lt;&lt; endl;
	delete abs;
}

int main()
{
	//test01();
	test02();

	system("pause");
	return 0;
}</code></pre> 
<p><img alt="" height="139" src="https://images2.imgbox.com/56/fe/lsFOQAJy_o.png" width="626"></p> 
<p>总结: C++开发提倡利用多态设计程序架构，因为多态优点很多。 </p> 
<h4>2.3、纯虚函数和抽象类</h4> 
<p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容。</p> 
<p>因此可以将虚函数改为<strong>纯虚函数！</strong></p> 
<p>纯虚函数语法: virtual 返回值类型 函数名(数列表) = 0;</p> 
<p>当类中有了纯虚函数，这个类也称为抽象类。</p> 
<p><strong>抽象类特点:</strong></p> 
<p><strong>·</strong>无法实例化对象<br><strong>·</strong>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</p> 
<h4>2.4、多态案例二 - 制作饮品</h4> 
<p><strong>案例描述:</strong><br> 制作饮品的大致流程为: 煮水 - 冲泡 - 倒入杯中 - 加入辅料</p> 
<p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶。</p> 
<p><img alt="" height="423" src="https://images2.imgbox.com/1e/be/14zSpmtU_o.png" width="1180"></p> 
<pre><code class="hljs">class AbstractDrinking
{
public:
	//煮水
	virtual void Boil() = 0;

	//冲泡
	virtual void Brew() = 0;

	//倒入杯中
	virtual void PourInCup() = 0;

	//加入辅助佐料
	virtual void PutSomthing() = 0;

	//制作饮品
	void makeDrink()
	{
		Boil();
		Brew();
		PourInCup();
		PutSomthing();
	}
};

//制作咖啡
class Coffee : public AbstractDrinking
{
public:
	//煮水
	 void Boil()
	{
		 cout &lt;&lt; "煮农夫山泉水" &lt;&lt; endl;
	}

	//冲泡
	 void Brew()
	{
		 cout &lt;&lt; "冲泡咖啡" &lt;&lt; endl;
	}

	//倒入杯中
	 void PourInCup()
	{
		 cout &lt;&lt; "倒入咖啡杯中" &lt;&lt; endl;
	}

	//加入辅助佐料
	 void PutSomthing()
	{
		 cout &lt;&lt; "加入糖和牛奶" &lt;&lt; endl;
	}
};

//制作茶叶
class Tea : public AbstractDrinking
{
public:
	//煮水
	void Boil()
	{
		cout &lt;&lt; "煮冰露矿泉水" &lt;&lt; endl;
	}

	//冲泡
	void Brew()
	{
		cout &lt;&lt; "冲泡茶叶" &lt;&lt; endl;
	}

	//倒入杯中
	void PourInCup()
	{
		cout &lt;&lt; "倒入茶壶中" &lt;&lt; endl;
	}

	//加入辅助佐料
	void PutSomthing()
	{
		cout &lt;&lt; "加入柠檬和枸杞" &lt;&lt; endl;
	}
};

//制作函数
void doDrink(AbstractDrinking* abs)//AbstractDrinking* abs = new Coffee;
{
	abs-&gt;makeDrink();
	delete abs;//释放堆区数据
}

void test01()
{
	//制作咖啡
	doDrink(new Coffee);
	cout &lt;&lt; "--------------" &lt;&lt; endl;
	//制作茶
	doDrink(new Tea);
}

int main()
{
	test01();

	system("pause");
	return 0;
}</code></pre> 
<p><img alt="" height="240" src="https://images2.imgbox.com/58/2e/lvm31j6Z_o.png" width="628"></p> 
<h4>2.5、虚析构和纯虚析构</h4> 
<p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码。</p> 
<p>解决方式: 将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构。</strong></p> 
<p>虚析构和纯虚析构共性:</p> 
<p><strong>·</strong>可以解决父类指针释放子类对象<br><strong>·</strong>都需要有具体的函数实现</p> 
<p>虚析构和纯虚析构区别: </p> 
<p><strong>·</strong>如果是纯虚析构，该类属于抽象类，无法实例化对象</p> 
<p>虚析构语法: virtual ~类名(){}</p> 
<p>纯虚析构语法: virtual ~类名() = 0;</p> 
<p>类名::~类名(){}</p> 
<pre><code class="hljs">class Animal
{
public:
	//纯虚函数
	virtual void speak() = 0;

	Animal()
	{
		cout &lt;&lt; "Animal的构造函数" &lt;&lt; endl;
	}

	//利用虚析构可以解决父类指针释放子类对象时不干净的问题
	//virtual ~Animal()
	//{
	//	cout &lt;&lt; "Animal的虚析构函数!" &lt;&lt; endl;
	//}

	//纯虚析构 - 需要声明也需要实现
	//有了纯虚析构之后,这个类也属于抽象类,无法实例化对象
	virtual ~Animal() = 0;
};

Animal::~Animal()
{
		cout &lt;&lt; "Animal的纯虚析构函数!" &lt;&lt; endl;
}

class Cat :public Animal
{
public:
	Cat(string name)
	{
		cout &lt;&lt; "Cat的构造函数" &lt;&lt; endl;
		m_Name = new string(name);
	}

	~Cat()
	{
		cout &lt;&lt; "Cat的析构函数" &lt;&lt; endl;
		if (m_Name != NULL)
		{
			delete m_Name;
			m_Name = NULL;
		}
	}

	virtual void speak()
	{
		cout &lt;&lt; *m_Name &lt;&lt; "小猫喵喵喵!" &lt;&lt; endl;
	}

	string *m_Name;
};

void test01()
{
	Animal* animal = new Cat("Tom");
	animal-&gt;speak();
	//父类指针在析构的时候,不会调用子类中析构函数,导致子类如果有堆区属性,出现内存泄漏
	delete animal;
}

int main()
{
	test01();

	system("pause");
	return 0;
}</code></pre> 
<p><img alt="" height="575" src="https://images2.imgbox.com/4d/ef/i3hh7DN7_o.png" width="645"></p> 
<p><img alt="" height="151" src="https://images2.imgbox.com/66/00/IrKYZ3hR_o.png" width="717"><img alt="" height="182" src="https://images2.imgbox.com/68/c7/jHwPx3Ms_o.png" width="638"></p> 
<p>可以看到上述代码如若按照图片来写的结果是，Cat类在堆区创建了数据理应在析构函数中释放，但是Animal类的指针在析构时并不会调用子类对象的析构函数，所以我们要用虚析构来解决问题，如下:</p> 
<p><img alt="" height="144" src="https://images2.imgbox.com/54/b7/yZ2SwhOv_o.png" width="775"></p> 
<p><img alt="" height="160" src="https://images2.imgbox.com/67/7e/ug7s08KI_o.png" width="627"> </p> 
<p>这样我们就可以把在子类创建的堆区数据释放干净了。</p> 
<p>总结:</p> 
<p>1.虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p> 
<p>2.如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p> 
<p>3.拥有纯虚析构函数的类也属于抽象类 </p> 
<h4>2.6、多态案例三 - 电脑组装</h4> 
<p><strong>案例描述:</strong></p> 
<p>电脑主要组成部件为 CPU(用于计算) ，显卡(用于显示) ，内存条(用于存储)；</p> 
<p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如lntel厂商和Lenovo厂商；</p> 
<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口；</p> 
<p>测试时组装三台不同的电脑进行工作。</p> 
<pre><code class="hljs">//抽象不同零件类
//抽象CPU类
class CPU
{
public:
	//抽象计算函数
	virtual void calculate() = 0;
};

//抽象显卡类
class VideoCard
{
public:
	//抽象显示函数
	virtual void display() = 0;
};

//抽象内存条类
class Memory
{
public:
	//抽象存储函数
	virtual void storage() = 0;
};

//电脑类
class Computer
{
public:
	Computer(CPU* cpu, VideoCard* vc, Memory* mem)
	{
		m_cpu = cpu;
		m_vc = vc;
		m_mem = mem;
	}

	//提供工作函数
	void work()
	{
		//让零件工作,调用接口
		m_cpu-&gt;calculate();
		m_vc-&gt;display();
		m_mem-&gt;storage();
	}

	//提供析构函数来释放3个电脑零件
	~Computer()
	{
		//释放cpu零件
		if (m_cpu != NULL)
		{
			delete m_cpu;
			m_cpu = NULL;
		}

		//释放显卡零件
		if (m_vc != NULL)
		{
			delete m_vc;
			m_vc = NULL;
		}

		//释放内存条零件
		if (m_mem != NULL)
		{
			delete m_mem;
			m_mem = NULL;
		}
	}

private:
	CPU* m_cpu;//CPU零件指针
	VideoCard* m_vc;//显卡零件指针
	Memory* m_mem;//内存条零件指针
};

//具体厂商
//Intel厂商
class IntelCPU :public CPU
{
public:
	virtual void calculate()
	{
		cout &lt;&lt; "Intel的CPU开始计算!" &lt;&lt; endl;
	}
};

class IntelVideoCard :public VideoCard
{
public:
	virtual void display()
	{
		cout &lt;&lt; "Intel的显卡开始显示!" &lt;&lt; endl;
	}

};

class IntelMemory :public Memory
{
public:
	virtual void storage()
	{
		cout &lt;&lt; "Intel的内存条开始存储!" &lt;&lt; endl;
	}

};

//Lenovo厂商
class LenovoCPU :public CPU
{
public:
	virtual void calculate()
	{
		cout &lt;&lt; "Lenovo的CPU开始计算!" &lt;&lt; endl;
	}
};

class LenovoVideoCard :public VideoCard
{
public:
	virtual void display()
	{
		cout &lt;&lt; "Lenovo的显卡开始显示!" &lt;&lt; endl;
	}

};

class LenovoMemory :public Memory
{
public:
	virtual void storage()
	{
		cout &lt;&lt; "Lenovo的内存条开始存储!" &lt;&lt; endl;
	}

};

void test01()
{
	cout &lt;&lt; "------第一台电脑-------" &lt;&lt; endl;
	//第一台电脑零件
	CPU* intelCPU = new IntelCPU;
	VideoCard* intelCard = new IntelVideoCard;
	Memory* intelMem = new IntelMemory;

	//创建第一台电脑
	Computer* computer1 = new Computer(intelCPU, intelCard, intelMem);
	computer1-&gt;work();
	delete computer1;

	cout &lt;&lt; "------第二台电脑-------" &lt;&lt; endl;
	//第二台电脑组装
	Computer* computer2 = new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);
	computer2-&gt;work();
	delete computer2;

	cout &lt;&lt; "------第三台电脑-------" &lt;&lt; endl;
	Computer* computer3 = new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);
	computer3-&gt;work();
	delete computer3;
}

int main()
{
	test01();

	system("pause");
	return 0;
}</code></pre> 
<p><img alt="" height="300" src="https://images2.imgbox.com/58/e8/QhQQRAKI_o.png" width="631"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aff9988c118244e5c9089d7ac33580ed/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">20240107 SQL基础50题打卡</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2fde46faf4b15fccb8b8d5ec013500ef/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【大数据】Flink CDC 的概览和使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>