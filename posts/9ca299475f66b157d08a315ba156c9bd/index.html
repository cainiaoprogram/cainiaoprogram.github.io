<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;学习笔记——从面试题出发学习C&#43;&#43; - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;学习笔记——从面试题出发学习C&#43;&#43;" />
<meta property="og:description" content="C&#43;&#43;学习笔记——从面试题出发学习C&#43;&#43; C&#43;&#43;学习笔记——从面试题出发学习C&#43;&#43;1. 成员函数的重写、重载和隐藏的区别？2. 构造函数可以是虚函数吗？内联函数可以是虚函数吗？析构函数为什么一定要是虚函数？3. 解释左值/右值、左值/右值引用、std::move、移动语义、完美转发等相关的概念？3.1 左值/右值的概念3.2 左值引用/右值引用的概念3.3 std::move的作用3.3 移动语义的概念3.4 完美转发的概念 4. decltype、volatile、explicit、override、mutable关键字的作用？4.1 decltype4.2 volatile4.3 explicit4.4 override4.5 mutable 5. 构造函数相关的default和delete关键字的作用？6 . extern C的作用？7. 解释动态多态和静态多态的区别？8. 菱形继承有什么问题，如何解决？9. 段错误有哪些类型？10. 如何定义一个只能在堆上（栈上）生成对象的类？11. delete this 合法吗？12. 不同类型智能指针的区别？12.1 auto_ptr12.2 shared_ptr12.3 weak_ptr12.4 unique_ptr 13. 不同强制类型转换运算符的区别？13.1 static_cast13.2 dynamic_cast13.3 reinterpret_cast13.4 const_cast 14. 如何重载操作符？重载操作符的返回值？流运算符为什么不能通过成员函数重载？16. 如何理解函数指针、类成员函数指针？ C&#43;&#43;学习笔记——从面试题出发学习C&#43;&#43; C&#43;&#43;博大精深，在学习过程中我也有看过《Effective C&#43;&#43;》、《Efficient C&#43;&#43;》、《C&#43;&#43; Prime》这样一些C&#43;&#43;的经典大作，但是个人感觉是由于语法太多，很难抓住重点，在工作中如果不很经常用到某个语法，即使在书籍上有看过也会很快忘记。而刷面试题是一个很好的查漏补缺的方式，本博客将以面试题为切入点，将面试题中涉及的语法展开学习以彻底搞懂，进而达到在平常的工作中能够灵活运用目的，下面就逐个开始语法的学习：
1. 成员函数的重写、重载和隐藏的区别？ 这里我们直接给出三种不同概念的定义：
重载指的是同一作用域内（例如同为某一个类的成员函数），函数名相同，入参不同的情况；
隐藏指的是不同作用域内（例如两个函数分别位于父类和子类中），函数名相同，入参不同则直接构成隐藏，入参相同且非虚函数，否则为重写；
重写特指两个函数分别位于父类和子类中，函数名相同，入参相同且为虚函数的情况（注意和隐藏做区别）；
我们要知道：
重载是静态多态的表达形式，重写是动态多态的表达形式。
除此之外，下面这种情况注意隐藏和重写输出的区别：
如下是隐藏，调用的是Base类中的func函数
#include&lt;iostream&gt; using namespace std; class Base { public: void fun(int i){ cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9ca299475f66b157d08a315ba156c9bd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-31T09:38:19+08:00" />
<meta property="article:modified_time" content="2023-08-31T09:38:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;学习笔记——从面试题出发学习C&#43;&#43;</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>C++学习笔记——从面试题出发学习C++</h4> 
 <ul><li><a href="#CC_1" rel="nofollow">C++学习笔记——从面试题出发学习C++</a></li><li><ul><li><a href="#1___4" rel="nofollow">1. 成员函数的重写、重载和隐藏的区别？</a></li><li><a href="#2__69" rel="nofollow">2. 构造函数可以是虚函数吗？内联函数可以是虚函数吗？析构函数为什么一定要是虚函数？</a></li><li><a href="#3_stdmove_91" rel="nofollow">3. 解释左值/右值、左值/右值引用、std::move、移动语义、完美转发等相关的概念？</a></li><li><ul><li><a href="#31__92" rel="nofollow">3.1 左值/右值的概念</a></li><li><a href="#32__97" rel="nofollow">3.2 左值引用/右值引用的概念</a></li><li><a href="#33_stdmove_104" rel="nofollow">3.3 std::move的作用</a></li><li><a href="#33__138" rel="nofollow">3.3 移动语义的概念</a></li><li><a href="#34__248" rel="nofollow">3.4 完美转发的概念</a></li></ul> 
   </li><li><a href="#4_decltypevolatileexplicitoverridemutable_295" rel="nofollow">4. decltype、volatile、explicit、override、mutable关键字的作用？</a></li><li><ul><li><a href="#41_decltype_296" rel="nofollow">4.1 decltype</a></li><li><a href="#42_volatile_319" rel="nofollow">4.2 volatile</a></li><li><a href="#43_explicit_324" rel="nofollow">4.3 explicit</a></li><li><a href="#44_override_345" rel="nofollow">4.4 override</a></li><li><a href="#45_mutable_363" rel="nofollow">4.5 mutable</a></li></ul> 
   </li><li><a href="#5_defaultdelete_374" rel="nofollow">5. 构造函数相关的default和delete关键字的作用？</a></li><li><a href="#6__extern_C_387" rel="nofollow">6 . extern C的作用？</a></li><li><a href="#7___413" rel="nofollow">7. 解释动态多态和静态多态的区别？</a></li><li><a href="#8__423" rel="nofollow">8. 菱形继承有什么问题，如何解决？</a></li><li><a href="#9__444" rel="nofollow">9. 段错误有哪些类型？</a></li><li><a href="#10__455" rel="nofollow">10. 如何定义一个只能在堆上（栈上）生成对象的类？</a></li><li><a href="#11_delete_this__495" rel="nofollow">11. delete this 合法吗？</a></li><li><a href="#12__532" rel="nofollow">12. 不同类型智能指针的区别？</a></li><li><ul><li><a href="#121_auto_ptr_535" rel="nofollow">12.1 auto_ptr</a></li><li><a href="#122_shared_ptr_552" rel="nofollow">12.2 shared_ptr</a></li><li><a href="#123_weak_ptr_557" rel="nofollow">12.3 weak_ptr</a></li><li><a href="#124_unique_ptr_592" rel="nofollow">12.4 unique_ptr</a></li></ul> 
   </li><li><a href="#13__612" rel="nofollow">13. 不同强制类型转换运算符的区别？</a></li><li><ul><li><a href="#131_static_cast_615" rel="nofollow">13.1 static_cast</a></li><li><a href="#132_dynamic_cast_622" rel="nofollow">13.2 dynamic_cast</a></li><li><a href="#133_reinterpret_cast_629" rel="nofollow">13.3 reinterpret_cast</a></li><li><a href="#134_const_cast_632" rel="nofollow">13.4 const_cast</a></li></ul> 
   </li><li><a href="#14__635" rel="nofollow">14. 如何重载操作符？重载操作符的返回值？流运算符为什么不能通过成员函数重载？</a></li><li><a href="#16__735" rel="nofollow">16. 如何理解函数指针、类成员函数指针？</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="CC_1"></a>C++学习笔记——从面试题出发学习C++</h2> 
<p>C++博大精深，在学习过程中我也有看过《Effective C++》、《Efficient C++》、《C++ Prime》这样一些C++的经典大作，但是个人感觉是由于语法太多，很难抓住重点，在工作中如果不很经常用到某个语法，即使在书籍上有看过也会很快忘记。而刷面试题是一个很好的查漏补缺的方式，本博客将以面试题为切入点，将面试题中涉及的语法展开学习以彻底搞懂，进而达到在平常的工作中能够灵活运用目的，下面就逐个开始语法的学习：</p> 
<h3><a id="1___4"></a>1. 成员函数的重写、重载和隐藏的区别？</h3> 
<p>这里我们直接给出三种不同概念的定义：<br> <strong>重载</strong>指的是<strong>同一作用域内</strong>（例如同为某一个类的成员函数），函数名相同，<strong>入参不同</strong>的情况；<br> <strong>隐藏</strong>指的是<strong>不同作用域内</strong>（例如两个函数分别位于父类和子类中），函数名相同，<strong>入参不同</strong>则直接构成隐藏，<strong>入参相同</strong>且<strong>非虚函数</strong>，否则为重写；<br> <strong>重写</strong>特指两个函数分别位于父类和子类中，函数名相同，<strong>入参相同且为虚函数</strong>的情况（注意和隐藏做区别）；</p> 
<p>我们要知道：<br> <strong>重载</strong>是静态多态的表达形式，<strong>重写</strong>是动态多态的表达形式。</p> 
<p>除此之外，下面这种情况注意<strong>隐藏</strong>和<strong>重写</strong>输出的区别：<br> 如下是<strong>隐藏</strong>，调用的是Base类中的func函数</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base::fun(int) : "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derived::fun(int) : "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    Base b<span class="token punctuation">;</span>
    Base <span class="token operator">*</span> pb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pb<span class="token operator">-&gt;</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Base::fun(int)</span>

    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如下是<strong>重写</strong>，调用的是Derived类中的func函数:</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base::fun(int) : "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derived::fun(int) : "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    Base b<span class="token punctuation">;</span>
    Base <span class="token operator">*</span> pb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pb<span class="token operator">-&gt;</span><span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Derived::fun(int)</span>

    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="2__69"></a>2. 构造函数可以是虚函数吗？内联函数可以是虚函数吗？析构函数为什么一定要是虚函数？</h3> 
<p>首先我们要了解虚函数的基本实现原理，虚函数的基本结构是虚表：<br> （1）虚表是一个指针数组，每个元素对应一个虚函数的函数指针；普通函数的调用并不需要经过虚表，所以虚表的元素并不包括普通函数的函数指针；<br> （2）虚表内的虚函数的函数指针的赋值发生在编译器的编译阶段，也就是说<strong>在代码的编译阶段，虚表就已经完成构造</strong>；<br> （3）虚表是属于类的，而不是属于某个具体的对象，一个类只需要一个虚表即可。同一个类的所有对象都使用同一个虚表（父类和子类属于不同的类）。为了指定对象的虚表，<strong>对象内部包含一个虚表的指针，来指向自己所使用的虚表</strong>。从下图我们可以理解类对象、虚表和虚函数的区别：<br> <img src="https://images2.imgbox.com/39/99/y67sWgvI_o.jpg" alt="请添加图片描述" width="550"></p> 
<p>其中，类B继承类A，类C继承类B。类A有两个虚函数A::vfunc1()和A::vfunc2()，类B重写了B::vfunc1()，类C重写了C::vfunc2()。当我们使用指针调用虚函数，且满足指针向上转型条件时就可以触发动态绑定，如下代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
    B bObject<span class="token punctuation">;</span>
    A <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span> bObject<span class="token punctuation">;</span>
    p<span class="token operator">-&gt;</span><span class="token function">vfunc1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 最终调用的时B::vfunc1()这个函数</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>了解了虚函数的基本实现原理后我们来回答下上面相关的问题：<br> （1）<strong>构造函数不可以是虚函数</strong>，因为每个对象中的虚函数的实现依赖虚函数表指针_vptr指向的虚函数表来确定，在执行构造函数前对象尚未完成创建，虚函数表指针_vptr还不存在，也就无法通过虚函数表确定构造函数的具体实现。<br> （2）<strong>虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联</strong>。 内联是在发生在编译期间，编译器会自主选择内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。<br> （3）<strong>将可能会被继承的父类的析构函数设置为虚函数</strong>，可以保证当我们创建一个子类，然后使用基类指针指向该子类对象，释放基类指针时可以释放掉子类的空间，防止内存泄漏。<strong>而对于不会被继承的类来说，其析构函数如果是虚函数，就会浪费内存</strong>。</p> 
<h3><a id="3_stdmove_91"></a>3. 解释左值/右值、左值/右值引用、std::move、移动语义、完美转发等相关的概念？</h3> 
<h4><a id="31__92"></a>3.1 左值/右值的概念</h4> 
<p>左值是可寻址的变量，有持久性（例如变量名、返回引用的函数调用、前置自增自减、解引用等）；<br> 右值是不可寻址的常量，或在表达式求值过程中创建的无名临时对象，短暂性的（例如字面值、返回非引用类型的函数调用、后置自增自减、算数表达式等）；<br> 左值和右值主要的区别之一是<strong>左值可以被修改，而右值不能。</strong></p> 
<h4><a id="32__97"></a>3.2 左值引用/右值引用的概念</h4> 
<p>左值引用：引用一个对象，其通常用在函数传参或者返回值来避免对象拷贝；<br> 右值引用：就是必须绑定到右值的引用，通过 &amp;&amp; 获得右值引用，其主要作用是实现<strong>移动语义</strong>和<strong>完美转发</strong>（两个概念见下文）</p> 
<p>这里补充很重要的一点，<strong>常量左值引用也可以引用右值</strong>，通常用于入参或者类拷贝构造函数中，更全面的关系如下表所示：<br> <img src="https://images2.imgbox.com/6b/e6/tfYYlvjn_o.png" alt="在这里插入图片描述" width="650"></p> 
<h4><a id="33_stdmove_104"></a>3.3 std::move的作用</h4> 
<p>std::move的作用是将一个左值变成右值，换一个角度讲就是可以将一个右值引用指向左值。如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>b <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a = "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"b = "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>输出结果如下：</p> 
<pre><code class="prism language-cpp">a <span class="token operator">=</span> <span class="token number">1</span>
b <span class="token operator">=</span> <span class="token number">1</span>
</code></pre> 
<p>更具体地，std::move的定义如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">_Tp</span><span class="token operator">&gt;</span>
<span class="token keyword">constexpr</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>remove_reference<span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span> <span class="token function">move</span><span class="token punctuation">(</span>_Tp<span class="token operator">&amp;&amp;</span> __t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{<!-- --></span> 
    <span class="token keyword">return</span> <span class="token keyword">static_cast</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>remove_reference<span class="token operator">&lt;</span>_Tp<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span>__t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>其中remove_reference的含义是获得去掉引用的参数类型，从上面定义可以看出，std::move()并不是什么黑魔法，而只是进行了简单的类型转换：<br> （1）如果传递的是左值，则推导为左值引用，然后由static_cast转换为右值引用<br> （2）如果传递的是右值，则推导为右值引用，然后由static_cast转换为右值引用<br> 使用std::move之后，就意味着两点：<br> （1）原对象不再被使用，如果对其使用会造成不可预知的后果（对int等基础类型进行move()操作，不会改变其原值）<br> （2）所有权转移，资源的所有权被转移给新的对象</p> 
<h4><a id="33__138"></a>3.3 移动语义的概念</h4> 
<p>移动语义是通过<strong>移动构造函数</strong>和<strong>移动赋值构造函数</strong>实现的，其主要目的是<strong>为了避免资源的重新分配</strong>。如下面分别定义拷贝构造函数、赋值构造函数、移动构造函数、移动赋值构造函数四种构造函数：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">BigObj</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">explicit</span> <span class="token function">BigObj</span><span class="token punctuation">(</span>size_t length<span class="token punctuation">)</span>
        <span class="token operator">:</span> <span class="token function">length_</span><span class="token punctuation">(</span>length<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">data_</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>length<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 析构函数</span>
    <span class="token operator">~</span><span class="token function">BigObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>data_ <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
       <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data_<span class="token punctuation">;</span>
        length_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 拷贝构造函数</span>
    <span class="token function">BigObj</span><span class="token punctuation">(</span><span class="token keyword">const</span> BigObj<span class="token operator">&amp;</span> other<span class="token punctuation">)</span>
     <span class="token operator">:</span> <span class="token function">length_</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>length_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">data</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>other<span class="token punctuation">.</span>length_<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   std<span class="token double-colon punctuation">::</span><span class="token function">copy</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>mData<span class="token punctuation">,</span> other<span class="token punctuation">.</span>mData <span class="token operator">+</span> mLength<span class="token punctuation">,</span> mData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 赋值构造函数</span>
    BigObj<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> BigObj<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>other<span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data_<span class="token punctuation">;</span>  
      length_ <span class="token operator">=</span> other<span class="token punctuation">.</span>length_<span class="token punctuation">;</span>
        data_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>length_<span class="token punctuation">]</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span><span class="token function">copy</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>data_<span class="token punctuation">,</span> other<span class="token punctuation">.</span>data_ <span class="token operator">+</span> length_<span class="token punctuation">,</span> data_<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 移动构造函数</span>
    <span class="token function">BigObj</span><span class="token punctuation">(</span>BigObj<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">data_</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">length_</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        data_ <span class="token operator">=</span> other<span class="token punctuation">.</span>data_<span class="token punctuation">;</span>
        length_ <span class="token operator">=</span> other<span class="token punctuation">.</span>length_<span class="token punctuation">;</span>

        other<span class="token punctuation">.</span>data_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
        other<span class="token punctuation">.</span>length_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 移动赋值构造函数</span>
    BigObj<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>BigObj<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token operator">&amp;</span>other<span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data_<span class="token punctuation">;</span>

          data_ <span class="token operator">=</span> other<span class="token punctuation">.</span>data_<span class="token punctuation">;</span>
          length_ <span class="token operator">=</span> other<span class="token punctuation">.</span>length_<span class="token punctuation">;</span>

          other<span class="token punctuation">.</span>data_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
          other<span class="token punctuation">.</span>length_ <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>
       <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token keyword">private</span><span class="token operator">:</span>
    size_t length_<span class="token punctuation">;</span>
    <span class="token keyword">int</span><span class="token operator">*</span> data_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>在移动构造函数和移动赋值构造函数中，没有分配任何新资源，也没有复制其它资源，仅仅是将other的资源进行了移动，占为己用，而other中的内存被移动到新成员后，other中原有的内容则消失，因此需要进行重置。<strong>当data_大到百万个元素时，如果使用原来拷贝构造函数的话，就需要将该数百万元素逐个进行复制，性能可想而知。而如果使用该移动构造函数，因为不涉及到新资源的创建，不仅可以节省很多资源，而且性能也有很大的提升</strong>。</p> 
<p>那么我们如何触发移动构造函数和移动赋值构造函数呢？也就是触发移动语义呢？可以有如下几种场景：<br> <strong>场景一</strong>：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>BigObj<span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
  v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">BigObj</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span><span class="token function">BigObj</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上述代码中，两个push_back()调用都将解析为push_back(T&amp;&amp;)，push_back(T&amp;&amp;)使用BigObj的移动构造函数将资源从参数移动到vector的内部BigObj对象中。而在C++11之前，上述代码则生成参数的拷贝，然后调用BigObj的拷贝构造函数。</p> 
<p>如果参数是左值，则将调用push_back(T&amp;)：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>BigObj<span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
  BigObj <span class="token function">obj</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 此处调用push_back(T&amp;)</span>
  
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如果希望调用push_back(T&amp;&amp;)，则需要使用std::move函数：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>BigObj<span class="token operator">&gt;</span> v<span class="token punctuation">;</span>
  BigObj <span class="token function">obj</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 此处调用push_back(T&amp;&amp;)</span>
  
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里需要注意的是，<strong>因为调用了std::move，因此下文要避免对obj对象做进一步操作，否则可能会导致内存越界等问题</strong>。</p> 
<p><strong>场景二</strong>：</p> 
<pre><code class="prism language-cpp">BigObj <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">return</span> <span class="token function">BigObj</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
BigObj obj <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// C++11以前</span>
BigObj <span class="token operator">&amp;&amp;</span>obj <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// C++11</span>
</code></pre> 
<p>上述代码中，在C++11之前，我们只能通过编译器优化(N)RVO的方式来提升性能，如果不满足编译器的优化条件，则只能通过拷贝等方式进行操作。<strong>自C++11引入右值引用后，对于不满足(N)RVO条件，也可以通过移动语义避免拷贝，进而达到优化的目的。</strong></p> 
<h4><a id="34__248"></a>3.4 完美转发的概念</h4> 
<p>完美转发的定义指的是函数模板可以将自己的参数“完美”地转发给内部调用的其他函数。这里注意，首先一定是模板函数，其次完美指的是不仅能准确转发参数的值，还能保证转发参数的左、右值属性不变。这个为什么重要呢？<strong>因为在很多场景中是否完美转发，直接决定了该参数的传递过程使用的是调用拷贝构造函数还是调用移动构造函数</strong>，结合上面移动语义的概念我们应该就很好理解这个对于性能的提升是非常重要的。</p> 
<p>首先我们定义一个没有完美转发的functoin函数：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">vfun</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里首先需要解释下T&amp;&amp;的含义，C++ 11规定，在模板函数中使用右值引用语法定义的参数来说，它表示“<strong>万能引用</strong>”，满足"<strong>引用折叠规则</strong>"（T&amp; &amp; –&gt; T&amp;，T&amp;&amp; &amp; –&gt; T&amp;，T&amp; &amp;&amp; –&gt;T&amp;，T&amp;&amp; &amp;&amp; –&gt; T&amp;&amp;），因此左值参数最终转换后仍为左值，右值参数最终转成右值。尽管如此，因为形参t是有名字且可取地址的，因此其传递到内部后仍然是左值，仍然满足不了完美转发的定义。</p> 
<p>因此在C++ 11中就引入了std::forward函数，std::forward的定义如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;</span> param<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span><span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>第一个是左值引用模板函数，第二个是右值引用模板函数，其中remove_reference的含义是获得去掉引用的参数类型（左右值属性不变），根据“万能应用”的定义，因此左值参数最终转换后仍为左值，右值参数最终转成右值。因此如下实现就完成了完美转发：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">vfun</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里补充下，在C++ 11之前是否可以实现完美转发的效果呢？上面我们介绍了右值是通过常量左值引用传递的，因此通过重载函数模板是可以实现同样功能的，如下：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//接收右值参数</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">otherdef</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//接收左值参数</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">function</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">otherdef</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>但是相较之下这种实现方式会更麻烦些，因此我们通常还是使用std::forward函数实现完美转发。</p> 
<h3><a id="4_decltypevolatileexplicitoverridemutable_295"></a>4. decltype、volatile、explicit、override、mutable关键字的作用？</h3> 
<h4><a id="41_decltype_296"></a>4.1 decltype</h4> 
<ol><li>decltype和auto都是用于推导变量类型，但用法不同，如下：<pre><code class="prism language-cpp"><span class="token keyword">auto</span> varname <span class="token operator">=</span> value<span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>exp<span class="token punctuation">)</span> varname <span class="token operator">=</span> value<span class="token punctuation">;</span>
</code></pre> 其中auto要求变量必须初始化，deltype不要求</li><li>decltype要求推导的对象一定是有类型的，但对象可以使一个普通的变量、表达式或者其他任意复杂的形式</li><li>decltype的经典用法是和priority_queue结合，当我们需要对一个自定义类进行堆排序时，如果不使用decltype的话写法如下：<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">cmp</span> <span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> lhs <span class="token operator">&gt;</span> rhs<span class="token punctuation">;</span> <span class="token punctuation">}</span>

priority_queue<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">pq</span><span class="token punctuation">(</span>cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 如果换成deltype进行类型推导的话代码会显得更加简洁：<pre><code class="prism language-cpp"><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">const</span> T lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> T rhs<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span> <span class="token keyword">return</span> rhs <span class="token operator">&lt;</span> lhs<span class="token punctuation">;</span> <span class="token punctuation">}</span>

priority_queue<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">,</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>cmp<span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">pq</span><span class="token punctuation">(</span>cmp<span class="token punctuation">)</span>
</code></pre> </li></ol> 
<h4><a id="42_volatile_319"></a>4.2 volatile</h4> 
<ol><li>volatile的含义是让编译器每次操作变量时一定是内存中取出，而不是使用已经存在寄存器中的值，主要使用在（1）中断服务中修改供其他程序检测的变量；（2）多任务环境下各任务间共享的标志应该加volatile（注意<strong>不是多线程</strong>）；（3）存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义。</li><li>volatile可以使修饰指针，用法和const类似；</li><li><strong>volatile并不能解决多线程中的问题</strong>，具体原因可以参考<a href="https://liam.page/2018/01/18/volatile-in-C-and-Cpp/" rel="nofollow">谈谈 C/C++ 中的 volatile</a></li></ol> 
<h4><a id="43_explicit_324"></a>4.3 explicit</h4> 
<ol><li> <p>explicit修饰单参构造函数，用于说明该构造函数不能进行隐式转换（无参或者多参构造函数无隐式转换），如下</p> <pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">People</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">int</span> age<span class="token punctuation">;</span>
	<span class="token keyword">explicit</span> <span class="token function">People</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
		age<span class="token operator">=</span>a<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	People <span class="token function">p1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//方式一，正确</span>
	People<span class="token operator">*</span> p_p2<span class="token operator">=</span><span class="token keyword">new</span> <span class="token function">People</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//方式二，正确</span>
	People p3<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>         <span class="token comment">//方式三，这个会报错，如果去掉explicit的话就不会报错。</span>

<span class="token punctuation">}</span>
</code></pre> <p>上述代码中如果没有explicit修饰的话方式三会正确运行，此时类成员age会被赋值为10，这就是C++对单参构造函数规定的一种隐式转换，这会导致一些很难被发现的bug，因此对于explicit关键字应该是能用则用。</p> </li></ol> 
<h4><a id="44_override_345"></a>4.4 override</h4> 
<ol><li> <p>如果父类在虚函数声明时使用了override关键字，那么该函数必须重载其子类中的同名函数，否则代码将无法通过编译。</p> </li><li> <p>override存在的目的是为了避免在重载子类同名函数过程中意外创建新的虚函数的情况，如下所示：</p> <pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Show</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 虚函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Sh0w</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// o 写成了 0，新的虚函数 </span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Show</span><span class="token punctuation">(</span><span class="token keyword">double</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 参数列表不一样，新的虚函数 </span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Show</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span> <span class="token comment">// const 属性不一样，新的虚函数 </span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> </li></ol> 
<h4><a id="45_mutable_363"></a>4.5 mutable</h4> 
<ol><li> <p>mutable 只能用来修饰类的非静态和非常量数据成员，而被 mutable 修饰的数据成员，可以在 const 成员函数中修改。</p> </li><li> <p>在 lambda 表达式的设计中按值捕获的方式不允许程序员在 lambda 函数的函数体中修改捕获的变量。而以 mutable 修饰 lambda 函数，则可以打破这种限制，如下：</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> x<span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> f1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">mutable</span> <span class="token punctuation">{<!-- --></span>x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// okay, 创建了一个函数类型的实例</span>
<span class="token keyword">auto</span> f2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token punctuation">{<!-- --></span>x <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// error, 不允许修改按值捕获的外部变量的值</span>
</code></pre> </li><li> <p>在一个类中，应尽量或者不用mutable，大量使用mutable表示程序设计存在缺陷</p> </li></ol> 
<h3><a id="5_defaultdelete_374"></a>5. 构造函数相关的default和delete关键字的作用？</h3> 
<p>要了解default和delete关键字的作用首先要知道C++对于默认构造函数的定义，在C++中，如果用户没有定义构造函数，那么编译器会自动生成一系列默认构造函数，包括拷贝构造，赋值构造，移动构造，移动赋值构造。<strong>delete的用处禁止默认构造函数的生成</strong>，如下：</p> 
<pre><code class="prism language-cpp"><span class="token function">myClass</span><span class="token punctuation">(</span><span class="token keyword">const</span> myClass<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token comment">//表示删除默认拷贝构造函数，即不能进行默认拷贝</span>
myClass <span class="token operator">&amp;</span> operatir<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> myClass<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token comment">//表示删除默认拷贝构造函数，即不能进行默认拷贝</span>
</code></pre> 
<p><strong>但是一旦用户定义了带参数的构造函数，那么编译器就不会再自动生成默认构造函数</strong>，此时其他构造函数都需要用户来定义。此时可以通过<strong>default关键字要求编译器来生成一个默认构造函数</strong></p> 
<pre><code class="prism language-cpp"><span class="token function">myClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span><span class="token comment">//表示默认存在构造函数</span>
</code></pre> 
<h3><a id="6__extern_C_387"></a>6 . extern C的作用？</h3> 
<p>extern “C”的作用主要是为了能够正确实现C++代码调用其他C语言代码。加上extern C后，会指示编译器这部分代码按C语言而不是C++的方式进行编译。C++和C语言在编译期一个典型的不同是，<strong>C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中</strong>，例如函数 void fun(int, int) 编译后的可能是 _fun_int_in，而C语言并不支持函数重载，因此编译<strong>C语言代码的函数时不会带上函数的参数类型</strong>，因此，如果不加 extern “C”，在链接阶段，链接器会从 moduleA 生成的目标文件 moduleA.obj 中找 _fun_int_int 这样的符号，显然这是不可能找到的</p> 
<p>在C++出现之前，很多底层的库是C语言写的，extern “C”的存在就是为了更好的支持原来的C代码和C语言库。extern “C”的使用方法如下：</p> 
<ol><li> <p>使用单一语句</p> <pre><code class="prism language-cpp"><span class="token keyword">extern</span> “C” <span class="token keyword">double</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p>使用复合语句，相当于复合语句中的申明都加了extern “C”</p> <pre><code class="prism language-cpp"><span class="token keyword">extern</span> “C”
<span class="token punctuation">{<!-- --></span>
      <span class="token keyword">double</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">int</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>包含头文件，相当于头文件中的申明都加了extern “C”</p> <pre><code class="prism language-cpp"><span class="token keyword">extern</span> “C”
<span class="token punctuation">{<!-- --></span>
      ＃include <span class="token operator">&lt;</span>cmath<span class="token operator">&gt;</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>不可以将extern “C”添加在函数内部，如果函数有多个申明，可以都加extern “C”，也可以只出现在第一次申明中，后面的申明会接受第一个链接指示符的规则。</p> </li></ol> 
<h3><a id="7___413"></a>7. 解释动态多态和静态多态的区别？</h3> 
<p><strong>动态多态</strong>的设计思想是：对于相关的对象类型，确定他们之间的一个共同功能集，然后<strong>在父类中，将这些共同的功能声明为多个公共的虚函数结构</strong>。各个子类重写这些虚函数，以完成具体的功能。用户代码<strong>通过指向父类指针来操作这些对象，对虚函数的调用会自动绑定到实际提供的子类对象上去</strong>。因此，我们可以总结出来动态多态的三个条件：</p> 
<ol><li>通过指针来调用函数；</li><li><strong>指针向上转型（即定义一个父类指针指向子类对象）；</strong></li><li>调用的是虚函数；</li></ol> 
<p><strong>静态多态</strong>的设计思想是：对于相关的对象类型，直接实现他们各自的定义，不需要共有基类，甚至可以没有任何关系。只需要各个具体类的实现中要求相同的接口声明。用户把<strong>操作这些对象的函数定义为模板</strong>，当需要操作什么类型的对象时，直接对模板制定该类型实参即可。</p> 
<p>相较之下，动态多态更加灵活，适合更复杂的应用场景。静态多态<strong>是编译期实现的多态，效果更高，适用于对性能要求高的场景</strong>，如UI渲染等。</p> 
<h3><a id="8__423"></a>8. 菱形继承有什么问题，如何解决？</h3> 
<p>当Father 类和 Mother 类分别从 GrandParent 继承而来，GrandSon 从 Father 类和 Mother 类多继承而来，类似于这样的继承方式就会形成菱形结构。菱形结构主要问题是：</p> 
<ol><li> <p>数据二义性，当GrandParent中存在类成员变量m是，GrandSon是无法直接调用的m，而必须通过域运算符(::)进行区分，例如</p> <pre><code class="prism language-cpp">GrandSon grandSon<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> grandSon<span class="token punctuation">.</span>Mother<span class="token double-colon punctuation">::</span>m <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> grandSon<span class="token punctuation">.</span>Father<span class="token double-colon punctuation">::</span>m <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
</code></pre> </li><li> <p>空间浪费，GrandSon中会存在两份积累GrandParent的数据；</p> </li></ol> 
<p>解决菱形继承的方法是虚继承，即</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Father</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">GrandParent</span></span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Mother</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">GrandParent</span></span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>使用虚继承的基类属于虚基类，可以看到，虚基类并不是在声明基类时声明的，而是在声明派生类时，指定继承方式声明的。程序运行时，只有最后的派生类执行对基类的构造函数调用，而忽略其他派生类对虚基类的构造函数调用。从而避免对基类数据成员重复初始化。因此，<strong>虚基类只会构造一次</strong>。</p> 
<h3><a id="9__444"></a>9. 段错误有哪些类型？</h3> 
<p>所谓的段错误 就是指访问的内存超出了系统所给这个程序的内存空间，这里我们粗略的进行一下分类：</p> 
<ol><li>往受到系统保护的内存地址写数据；</li><li>内存越界(数组越界，变量类型不一致等)；</li></ol> 
<p>我们还可以列举一些需要注意的经常导致段错误的场景：</p> 
<ol><li>定义了指针后记得初始化，在使用的时候记得判断是否为NULL；</li><li>在使用数组的时候是否被初始化，数组下标是否越界，数组元素是否存在等；</li><li>在变量处理的时候变量的格式控制是否合理等；</li></ol> 
<p>定位段错误的工具通常时GDB，具体定位方式就不在此展开了。</p> 
<h3><a id="10__455"></a>10. 如何定义一个只能在堆上（栈上）生成对象的类？</h3> 
<p>解答这个问题我们首先要知道，生成类对象的方式一共就两种：第一种是<strong>静态建立</strong>，即通过<strong>构造函数</strong>构建栈或者静态对象；第二种是<strong>动态建立</strong>，即通过<strong>new运算符</strong>对象构建堆对象。其中new运算符是先执行operator new()函数在堆空间中搜索合适的内存，第二步是调用构造函数使用该内存进行初始化。因此<strong>new运算符其实也是间接调用了类的构造函数</strong>。</p> 
<p>对象只能在堆上建立的类，最佳的实现方式如下：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span>  <span class="token class-name">A</span>  
<span class="token punctuation">{<!-- --></span>  
<span class="token keyword">protected</span> <span class="token operator">:</span>  
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  
    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  
<span class="token keyword">public</span> <span class="token operator">:</span>  
    <span class="token keyword">static</span>  A<span class="token operator">*</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
    <span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">return</span>   <span class="token keyword">new</span>  <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
    <span class="token keyword">void</span>  <span class="token function">destory</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  
    <span class="token punctuation">{<!-- --></span>  
        <span class="token keyword">delete</span>   <span class="token keyword">this</span> <span class="token punctuation">;</span>  
    <span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
</code></pre> 
<p>对于这种实现方式，有几点需要解释：</p> 
<ol><li>对象只能在堆上建立最直接的想法是将构造函数设置私有，但是上文也提到new运算符其实也是间接调用了构造函数，因此该方法不可取。</li><li>当对象在栈上建立时，编译器会析构函数来确定如何释放内存，当析构函数时私有时，编译器就无法调用析构函数来释放内存，也就不会在栈空间上为对象分配内存，<strong>因此将析构函数设置为私有即可得到一个只能在堆上建立的类</strong>。</li><li>考虑到类的可继承性，因此我们可以将析构函数设置为保护变量，这样这个类还是可继承的，且只能在堆上初始化。</li></ol> 
<p>对象只能在栈上建立的类，其实只需要将operator new()设置为私有即可：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span>  <span class="token class-name">A</span>  
<span class="token punctuation">{<!-- --></span>  
<span class="token keyword">private</span> <span class="token operator">:</span>  
    <span class="token keyword">void</span> <span class="token operator">*</span> <span class="token keyword">operator</span>  <span class="token keyword">new</span> <span class="token punctuation">(</span> size_t  t<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>      <span class="token comment">// 注意函数的第一个参数和返回值都是固定的   </span>
    <span class="token keyword">void</span>  <span class="token keyword">operator</span>  <span class="token keyword">delete</span> <span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span> ptr<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  <span class="token comment">// 重载了new就需要重载delete   </span>
<span class="token keyword">public</span> <span class="token operator">:</span>  
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  
    <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>  
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
</code></pre> 
<h3><a id="11_delete_this__495"></a>11. delete this 合法吗？</h3> 
<p>是合法的，但是需要注意如下几点：</p> 
<ol><li><strong>this指向的对象必须是new出来的</strong>，不能是new[] 、placement new、栈、全局或者其他方式分配的对象，只能是简单的new出来的；</li><li><strong>delete this 一旦被调用相当于该对象不复存在</strong>，对象下的其他成员函数或者成员对象不得再被调用，也不得以任何形式操作该对象，包括比较、打印、类型转换；</li><li><strong>不能在析构函数中调用delete this</strong>，因为delete this会出发析构函数进而造成无限递归。</li></ol> 
<p>为了更好理解以上几点，这里我们对delete关键字功能进一步拓展，delete的过程分为如下两步：</p> 
<pre><code class="prism language-cpp">p<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token operator">-&gt;</span><span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>其中<br> 第一步是调用p指向的Object对象的析构函数，这一步通常由用户自己定义，在<strong>析构函数中并不会对当前对象进行内存释放</strong>；<br> 第二步是调用p对象的内存释放语句，如果用户没有实现该方法，将<strong>调用系统内存释放原语operator delete§左释放该对象内存的动作</strong>。指示这个对象消亡前最后的动作。通常用户是不需要override这个函数的，如果需要，一定要在最后调用系统的operate delete操作释放该对象所占用的内存。下面这段代码就很好地说明了这个问题：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">x</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token operator">:</span>
        <span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">}</span>
        <span class="token operator">~</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"~x()/n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">//delete p; //这里若进行此操作则会陷入嵌套</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">void</span> <span class="token keyword">operator</span> <span class="token keyword">delete</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x::delete()/n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        x<span class="token operator">*</span> p<span class="token operator">=</span><span class="token keyword">new</span> x<span class="token punctuation">;</span>
        <span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token comment">//依次调用p的~x()和operator delete</span>
        <span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token comment">//不会报错，因为"operator delete" override了系统函数，没有进行::operator delete(this)操作。</span>
        <span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token comment">//同理依然不会报错</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="12__532"></a>12. 不同类型智能指针的区别？</h3> 
<p>这是一个老生常谈的问题了，这里我们再总结下：c++中一共有四个只能指针：<strong>auto_ptr，shared_ptr，weak_ptr，unique_ptr，其中后三个是c++ 11支持的，auto_ptr已经被c++ 11弃用。</strong></p> 
<h4><a id="121_auto_ptr_535"></a>12.1 auto_ptr</h4> 
<ol><li>c++98的方案**，c++11已经弃用**；</li><li>auto_ptr采用所有权模式，因此<strong>两个auto_ptr不能同时拥有一个对象</strong>。如下做法是错误的，会造成多次析构：<pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">*</span>p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
auto_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token function">ap1</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
auto_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token function">ap2</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li><li>auto_ptr的析构函数中删除指针用得是delete，而不是delete[]，因<strong>此auto_ptr不能管理数组指针</strong>；</li><li><strong>auto_ptr被剥夺所有权时，再次使用会报错</strong>：，如下做法是错误的：<pre><code class="prism language-cpp"><span class="token keyword">int</span><span class="token operator">*</span>p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
auto_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token function">ap1</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
auto_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span>ap2<span class="token operator">=</span>ap1<span class="token punctuation">;</span>
cout<span class="token operator">&lt;&lt;</span><span class="token operator">*</span>ap1<span class="token punctuation">;</span><span class="token comment">//错误，此时ap1只剩一个null指针在手了</span>
</code></pre> </li></ol> 
<h4><a id="122_shared_ptr_552"></a>12.2 shared_ptr</h4> 
<ol><li><strong>shared_ptr是用来解决所有权共享的问题</strong>，多个shared_ptr可以指向相同对象，对象的资源会在最后一个指针销毁时释放；</li><li>shared拥有成员函数：use_count（返回引用计数个数 ），unique（返回是否独占所有权），swap（交换所拥有的对象），reset（放弃对象所有权，会引起原有对象计数减少），get（返回对象指针）；</li><li>可以通过make_shared构造shared_ptr；</li></ol> 
<h4><a id="123_weak_ptr_557"></a>12.3 weak_ptr</h4> 
<ol><li> <p><strong>weak_ptr是用来解决shared_ptr相互引用时的死锁问题</strong>，如果两个shared_ptr相互引用，即那么这两个指针的引用计数永远不会变为零，资源永远不会被释放。</p> </li><li> <p>weak_ptr解决上述问题的原理是weak_ptr只可以从另一个shared_ptr或者weak_ptr对象构造，且<strong>weak_ptr的构造和析构不会引起引用计数的增加或者减少</strong>。</p> </li><li> <p>weak_ptr不可以直接访问对象的方法，要将weak_ptr转化为shared_ptr。如下是weak_ptr应用的典型场景：</p> <pre><code class="prism language-cpp"><span class="token comment">/*修改，将share_ptr互相引用换成weak_ptr,避免死锁问题*/</span>
<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">public</span><span class="token operator">:</span>
  weak_ptr<span class="token operator">&lt;</span>B<span class="token operator">&gt;</span> pb_<span class="token punctuation">;</span>
  <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"A delete\n"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{<!-- --></span>
  <span class="token keyword">public</span><span class="token operator">:</span>
  weak_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> pa_<span class="token punctuation">;</span>
  <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    cout<span class="token operator">&lt;&lt;</span><span class="token string">"B delete\n"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">&gt;</span> <span class="token function">pb</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">pa</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  pb<span class="token operator">-&gt;</span>pa_ <span class="token operator">=</span> pa<span class="token punctuation">;</span>
  pa<span class="token operator">-&gt;</span>pb_ <span class="token operator">=</span> pb<span class="token punctuation">;</span>
  cout<span class="token operator">&lt;&lt;</span>pb<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
  cout<span class="token operator">&lt;&lt;</span>pa<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">fun</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ol> 
<h4><a id="124_unique_ptr_592"></a>12.4 unique_ptr</h4> 
<ol><li> <p><strong>unique_ptr实现了独有所有权的语义</strong>。unique_ptr是仅能移动的类型，拷贝是不被允许的。当unique_ptr被移动时，资源的所有权也从源指针转移给目标指针，而源指针将被置空。如下是一些基本操作：</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 创建一个unique_ptr实例</span>
    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">pInt</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">pInt2</span><span class="token punctuation">(</span>pInt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 报错</span>
    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> pInt3 <span class="token operator">=</span> pInt<span class="token punctuation">;</span>   <span class="token comment">// 报错</span>
    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> pInt4 <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>pInt<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 转移所有权</span>
    <span class="token comment">//cout &lt;&lt; *pInt &lt;&lt; endl; // 报错，pInt为空</span>
    cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>pInt4 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">pInt5</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>pInt4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 转移所有权</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>可以通过make_unique构造unique_ptr；</p> </li></ol> 
<h3><a id="13__612"></a>13. 不同强制类型转换运算符的区别？</h3> 
<p>这也是C++中非常基本的一个知识点，主要有<strong>四种强制转换类型运算符：const_cast，reinterpret_cast，static_cast，dynamic_cast</strong></p> 
<h4><a id="131_static_cast_615"></a>13.1 static_cast</h4> 
<p>static_cast执行非动态转换，<strong>没有运行时类型检查来保证转换的安全性</strong>，通常有如下几种用法：</p> 
<ol><li><strong>用于类层次结构中父类和子类之间指针或引用的转换</strong>，进行上行转换（把子类指针转换成父类指针）是安全的；进行下行转换（把父类指针转换成子类指针）时，由于没有动态类型检查，所以是不安全的。</li><li><strong>用于基本数据类型之间的转换</strong>，如把int转换成char，把int转换成enum。这种转换的安全性也要开发人员来保证。</li><li><strong>把void指针转换成目标类型的指针</strong>，这种转换是不安全的。</li><li><strong>把任何类型的表达式转换成void类型</strong>。</li></ol> 
<h4><a id="132_dynamic_cast_622"></a>13.2 dynamic_cast</h4> 
<p>dynamic_cast是唯一一个在运行时进行类型检测的转换，可以使用它来检验多个动态对象，该转换一般用于含有虚函数的基类和派生类之间。dynamic_cast使用的注意事项如下：</p> 
<ol><li>dynamic_cast转换符<strong>只能用于指针或者引用</strong>。</li><li>dynamic_cast转换符<strong>只能用于含有虚函数的类</strong>。</li><li>dynamic_cast转换操作符在执行类型转换时首先将检查能否成功转换，如果能成功转换则转换之，如果转换失败，如果是指针则反回一个0值，如果是转换的是引用，则抛出一个bad_cast异常，所以<strong>在使用dynamic_cast转换之间应使用if语句对其转换成功与否进行测试。</strong></li></ol> 
<h4><a id="133_reinterpret_cast_629"></a>13.3 reinterpret_cast</h4> 
<p>reinterpret_cast可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，再把该整数转换成原类型的指针），使用该操作符的危险性较高，一般不应使用该操作符。</p> 
<h4><a id="134_const_cast_632"></a>13.4 const_cast</h4> 
<p>const_cast用来修改类型的const/volatile属性，这种类型的转换主要是用来操作所传对象的 const 属性，可以加上 const 属性，也可以去掉 const 属性。</p> 
<h3><a id="14__635"></a>14. 如何重载操作符？重载操作符的返回值？流运算符为什么不能通过成员函数重载？</h3> 
<p>如下是最经典的复数运算的重载操作：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Complex</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Complex</span><span class="token punctuation">(</span><span class="token keyword">double</span> r <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token keyword">double</span> i <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">real</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">imag</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token punctuation">}</span>
    <span class="token comment">//运算符+重载成员函数</span>
  Complex <span class="token keyword">operator</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Complex <span class="token operator">&amp;</span>c2<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token comment">//运算符-重载成员函数</span>
  Complex <span class="token keyword">operator</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Complex <span class="token operator">&amp;</span>c2<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>   <span class="token comment">//输出复数</span>
<span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token keyword">double</span> real<span class="token punctuation">;</span>    <span class="token comment">//复数实部</span>
    <span class="token keyword">double</span> imag<span class="token punctuation">;</span>    <span class="token comment">//复数虚部</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
例 复数类加减法运算重载为成员函数
Complex Complex<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">+</span><span class="token punctuation">(</span><span class="token keyword">const</span> Complex <span class="token operator">&amp;</span>c2<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{<!-- --></span>
  <span class="token comment">//创建一个临时无名对象作为返回值 </span>
  <span class="token keyword">return</span> <span class="token function">Complex</span><span class="token punctuation">(</span>real<span class="token operator">+</span>c2<span class="token punctuation">.</span>real<span class="token punctuation">,</span> imag<span class="token operator">+</span>c2<span class="token punctuation">.</span>imag<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
 
Complex Complex<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token keyword">const</span> Complex <span class="token operator">&amp;</span>c2<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">{<!-- --></span>
 <span class="token comment">//创建一个临时无名对象作为返回值</span>
    <span class="token keyword">return</span> <span class="token function">Complex</span><span class="token punctuation">(</span>real<span class="token operator">-</span>c2<span class="token punctuation">.</span>real<span class="token punctuation">,</span> imag<span class="token operator">-</span>c2<span class="token punctuation">.</span>imag<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p>具体说来：</p> 
<ol><li> <p>重载前缀一元运算符：<br> 如果为非静态成员函数，声明如下：</p> <pre><code class="prism language-cpp"><span class="token keyword">return</span><span class="token operator">-</span>type <span class="token keyword">operator</span> <span class="token function">op</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <p>如果为非成员函数，声明如下：</p> <pre><code class="prism language-cpp"><span class="token keyword">return</span><span class="token operator">-</span>type <span class="token keyword">operator</span> <span class="token function">op</span> <span class="token punctuation">(</span> <span class="token keyword">class</span><span class="token operator">-</span>type <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p>重载后缀一元运算符（递增、递减）：<br> 当为递增或递减运算符的后缀形式指定重载运算符时，<strong>其参数的类型必须是 int</strong>；指定任何其他类型都将产生错误。</p> </li><li> <p>重载二元运算符：<br> 如果为非静态成员函数，声明如下</p> <pre><code class="prism language-cpp"><span class="token keyword">return</span><span class="token operator">-</span>type <span class="token keyword">operator</span> <span class="token function">op</span><span class="token punctuation">(</span> <span class="token keyword">class</span><span class="token operator">-</span>type <span class="token punctuation">)</span>
</code></pre> <p>如果为非成员函数（全局函数、友元函数），声明如下：</p> <pre><code class="prism language-cpp"><span class="token keyword">return</span><span class="token operator">-</span>type <span class="token keyword">operator</span> <span class="token function">op</span><span class="token punctuation">(</span><span class="token keyword">class</span><span class="token operator">-</span>type<span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token operator">-</span>type<span class="token punctuation">)</span>
</code></pre> <p>关于如果要重载 B 为类成员函数，使之能够实现表达式 class-type1 OP class-type2，其中 class-type1为A 类对象，则 OP 应被重载为 A 类的成员函数，形参类型应该是 class-type2所属的类型。经重载后，<strong>表达式 class-type1 OP class-type2相当于 class-type1.operator OP(class-type2)</strong></p> </li></ol> 
<p><strong>重载操作符可以以void，对象的值或者引用的形式进行返回</strong>，注意这里的对象指向的是调用对象本身（对于全局的二元运算符函数就是左侧实参，否则就是*this），以下几种情况需要返回调用对象的引用：</p> 
<ol><li>等号连续赋值</li><li>+=，-=，*=，/=</li><li>&lt;&lt;，&gt;&gt;</li></ol> 
<p>原因是：</p> 
<ol><li>允许进行连续赋值；</li><li>防止返回对象的时候调用拷贝构造函数和析构函数导致不必要的开销，降低赋值运算符的效率；</li><li>和所有内置类型和标准程序库提供的类型遵循相同的协议；</li></ol> 
<p><strong>流运算符为什么不能通过成员函数重载</strong>的原因是因为通过类的成员函数重载必须是运算符的第一个是自己，<strong>对流运算的重载要求第一个参数是流对象</strong>，因此我们通常使用友元来解决问题，例如如果我们实现：</p> 
<pre><code class="prism language-cpp">ostream <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>output<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
　　<span class="token keyword">return</span> output<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这样我们只能使用data&lt;&lt;cout的形式调用进行调用，而如果要实现cout &lt;&lt; data的形式，就需要以如下形式实现：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span><span class="token operator">:</span>
        <span class="token function">Person</span><span class="token punctuation">(</span>string name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">name</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">age</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

        <span class="token comment">// 重载输出运算符</span>
        <span class="token keyword">friend</span> ostream <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span><span class="token punctuation">(</span>ostream <span class="token operator">&amp;</span>out<span class="token punctuation">,</span> <span class="token keyword">const</span> Person <span class="token operator">&amp;</span>p<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            out <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>name <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">.</span>age<span class="token punctuation">;</span>
            <span class="token keyword">return</span> out<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

    <span class="token keyword">private</span><span class="token operator">:</span>
        string name<span class="token punctuation">;</span>
        <span class="token keyword">int</span> age<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    Person <span class="token function">p</span><span class="token punctuation">(</span><span class="token string">"John"</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> p <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="16__735"></a>16. 如何理解函数指针、类成员函数指针？</h3> 
<p>函数指针和函数名的区别在于，他们虽然都指向了函数在内存的入口地址，但函数指针本身是个指针变量，对他做&amp;取地址的话会拿到这个变量本身的地址去，而对函数名做&amp;取址，得到的还是函数的入口地址。</p> 
<ol><li> <p>函数指针的定义方式如下：</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    
    <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    fp <span class="token operator">=</span> test<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token function">fp</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>函数指针所指向的函数一定要报纸函数的返回值类型、函数参数个数和类型一致，我们还可以使用typedef来可以简化函数指针的定义：</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    
    <span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    fp f <span class="token operator">=</span> test<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li><li> <p>函数指针同样可以作为参数传递给函数，还可以构建函数指针数组，这些是我们<strong>实现回调函数的基础</strong>：</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> a<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">test2</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>fun<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">int</span> b<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    
    <span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token function">fun</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator">+</span>b<span class="token punctuation">;</span>
    <span class="token keyword">return</span> c<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    
    <span class="token keyword">typedef</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    fp f <span class="token operator">=</span> test<span class="token punctuation">;</span>
    cout<span class="token operator">&lt;&lt;</span><span class="token function">test2</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span> <span class="token comment">// 调用 test2 的时候，把test函数的地址作为参数传递给了 test2</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>构成函数指针数字的方式如下：</p> <pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">t1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"test1"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">t2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"test2"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">t3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>cout<span class="token operator">&lt;&lt;</span><span class="token string">"test3"</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token punctuation">}</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    
    <span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>fp<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    fp b<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>t1<span class="token punctuation">,</span>t2<span class="token punctuation">,</span>t3<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// b[] 为一个指向函数的指针数组</span>
    b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 利用指向函数的指针数组进行下标操作就可以进行函数的间接调用了</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> </li></ol> 
<p>对于类成员函数指针，和函数指针的区别主要如下：</p> 
<ol><li> <p>对于指向类成员函数的函数指针，引用时必须传入一个类对象的this指针，所以必须由类实体调用，<em><em>即使用 .</em> (实例对象)或者 -&gt;*（实例对象指针）调用类成员函数指针所指向的函数</em>*。</p> </li><li> <p>对于虚函数, 其地址在编译时期是未知的，所以对于虚成员函数取其地址（子类父类都是如此），所能获得的只是一个索引值，即其在虚函数表的偏移位置。</p> </li><li> <p>对于静态成员函数，和非静态成员函数的变脸的赋值方式是一样的，都是&amp;ClassName::memberVariable形式，但是其声明方式不同：</p> <pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    
    <span class="token comment">//p1是一个指向非static成员函数的函数指针</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span>A<span class="token double-colon punctuation">::</span><span class="token operator">*</span>p1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//p2是一个指向static成员函数的函数指针</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>p2<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        p1 <span class="token operator">=</span><span class="token operator">&amp;</span>A<span class="token double-colon punctuation">::</span>funa<span class="token punctuation">;</span> <span class="token comment">//函数指针赋值一定要使用 &amp;</span>
        p2 <span class="token operator">=</span><span class="token operator">&amp;</span>A<span class="token double-colon punctuation">::</span>funb<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">void</span> <span class="token function">funa</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">funb</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <p>类成员函数指针就不仅仅是类成员函数的内存起始地址，还需要能解决因为 C++ 的多重继承、虚继承而带来的类实例地址的调整问题，所以<strong>类成员函数指针在调用的时候一定要传入类实例对象</strong>。因此上面类的调用方法如下：</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>    
	<span class="token comment">// 非静态和静态类成员函数指针调用方式对比</span>
	A a<span class="token punctuation">;</span>
	<span class="token keyword">void</span> <span class="token punctuation">(</span>A<span class="token double-colon punctuation">::</span><span class="token operator">*</span>pa<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	pa <span class="token operator">=</span> <span class="token operator">&amp;</span>A<span class="token double-colon punctuation">::</span>funa<span class="token punctuation">;</span>		
    <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token operator">*</span>pa<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印 A</span>
    
    A <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
    <span class="token punctuation">(</span>b<span class="token operator">-&gt;</span><span class="token operator">*</span>pa<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印 A</span>

    <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>pb<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pb <span class="token operator">=</span> <span class="token operator">&amp;</span>A<span class="token double-colon punctuation">::</span>funb<span class="token punctuation">;</span>
    <span class="token function">pb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印 B</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <p>我们也可以使用在类中定义好的类成员变量调用：</p> <pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    A a<span class="token punctuation">;</span>
    <span class="token comment">// p是指向A中非static成员函数的函数指针</span>
    <span class="token keyword">void</span> <span class="token punctuation">(</span>A<span class="token double-colon punctuation">::</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token operator">*</span>a<span class="token punctuation">.</span>p1<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印 A，这个看起来或许有些奇怪</span>
    
    <span class="token comment">// 使用.*(实例对象)或者-&gt;*（实例对象指针）调用类成员函数指针所指向的函数</span>
    p <span class="token operator">=</span> a<span class="token punctuation">.</span>p1<span class="token punctuation">;</span>
    <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印 A</span>
    
    A <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
    <span class="token punctuation">(</span>b<span class="token operator">-&gt;</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//打印 A</span>

	p <span class="token operator">=</span> a<span class="token punctuation">.</span>p2<span class="token punctuation">;</span> <span class="token comment">//error，尽管a.p2本身是个非static变量,但是a.p2是指向static函数的函数指针</span>
<span class="token punctuation">}</span>
</code></pre> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/83218ac34c1834c26781fe4bde918ee4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Welcome</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6eccdfbf0aac54ea9df83fbbf91843f7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Pytorch查看GPU是否可用、模型参数量numel统计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>