<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java 调用其他线程_java 后台接口另起一个线程执行其他业务 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java 调用其他线程_java 后台接口另起一个线程执行其他业务" />
<meta property="og:description" content="直接post代码，然后在详细介绍为什么：
packagecom.xxx.testset.service.impl;import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;/***
* @function xxx接口实现类
*@authorLiangjw
* @date 2019-9-18 下午02:09:33
*@version*@sinceJDK 1.7*/
public class TestSetServiceImpl extends BizServiceImpl implementsTestSetService {ExecutorService executorService= Executors.newSingleThreadExecutor();...
@OverridepublicString startTest(String testId) {final String test_Id =testId;
Connection con=DBConnectUtil.getConnection();
PreparedStatement pstmt= null,pstmt2 = null;
ResultSet resultSet= null;try{
Date nowDate= newDate();final String nowDateStr =DateUtil.dateTransformStr(nowDate, DATE_FORMAT);
Map map = new HashMap();
map.put(&#34;TEST_ID&#34;, testId);//获取检测装置集---2020年7月10日16:40:44 ljw
final List deviceList = this.getDao().queryForDataSet(STATEMENT_KEY &#43; &#34;selectPdDetectionDevice&#34;, map).getResults();
map.put(&#34;TEST_STATE&#34;, &#34;检测中&#34;);
map.put(&#34;BEGIN_TIME&#34;, nowDateStr);//获取当前机具表中第一条数据，补充到检测任务中---2020/07/02 ljw" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8ac9bb6b04d392921de574dc3a1149ca/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-13T06:01:41+08:00" />
<meta property="article:modified_time" content="2021-02-13T06:01:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java 调用其他线程_java 后台接口另起一个线程执行其他业务</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>直接post代码，然后在详细介绍为什么：</p> 
 <p>packagecom.xxx.testset.service.impl;import java.util.concurrent.ExecutorService;</p> 
 <p>import java.util.concurrent.Executors;/***</p> 
 <p>* @function xxx接口实现类</p> 
 <p>*@authorLiangjw</p> 
 <p>* @date 2019-9-18 下午02:09:33</p> 
 <p>*@version*@sinceJDK 1.7*/</p> 
 <p>public class TestSetServiceImpl extends BizServiceImpl implementsTestSetService {ExecutorService executorService= Executors.newSingleThreadExecutor();...</p> 
 <p>@OverridepublicString startTest(String testId) {final String test_Id =testId;</p> 
 <p>Connection con=DBConnectUtil.getConnection();</p> 
 <p>PreparedStatement pstmt= null,pstmt2 = null;</p> 
 <p>ResultSet resultSet= null;try{<!-- --></p> 
 <p>Date nowDate= newDate();final String nowDateStr =DateUtil.dateTransformStr(nowDate, DATE_FORMAT);</p> 
 <p>Map map = new HashMap();</p> 
 <p>map.put("TEST_ID", testId);//获取检测装置集---2020年7月10日16:40:44 ljw</p> 
 <p>final List deviceList = this.getDao().queryForDataSet(STATEMENT_KEY + "selectPdDetectionDevice", map).getResults();</p> 
 <p>map.put("TEST_STATE", "检测中");</p> 
 <p>map.put("BEGIN_TIME", nowDateStr);//获取当前机具表中第一条数据，补充到检测任务中---2020/07/02 ljw</p> 
 <p>Map parameters = new HashMap();</p> 
 <p>parameters.put("TYPE_NAME", "检测车");</p> 
 <p>List mechanicsList = this.getDao().queryForDataSet(STATEMENT_KEY + "selectMechanics", parameters).getResults();...//启动一个单线程(其实是创建线程池，只不过是单线程化的线程池)，单独调用算法分析检测结果</p> 
 <p>executorService.execute(newRunnable() {<!-- --></p> 
 <p>@Overridepublic voidrun() { //实现Runnable接口中的run方法，此处写入自己想要执行的内容！</p> 
 <p>Boolean test_flag= true;//判断任务检测状态，“检测中”为true，“已完成”为false</p> 
 <p>Connection con =DBConnectUtil.getConnection();</p> 
 <p>PreparedStatement pstmt= null;</p> 
 <p>ResultSet resultSet= null;</p> 
 <p>String cmdIds= "";for (int x = 0; x &lt; deviceList.size(); x++) {<!-- --></p> 
 <p>cmdIds+=deviceList.get(x).getString("CMD_ID") + ",";</p> 
 <p>}</p> 
 <p>cmdIds= cmdIds.substring(0, cmdIds.length() - 1);</p> 
 <p>String sql= "select qp.GUID, qp.PhaseDataA, qp.PDDataA, qp.PhaseDataB, qp.PDDataB, qp.PhaseDataC, qp.PDDataC, tf.TimeFieldDataA, tf.TimeFieldDataB, tf.TimeFieldDataC, qp.ReceiveTime , qp.DeviceID " +</p> 
 <p>"from tb_QPhiData qp left join tb_TimeFieldData tf on qp.GUID = tf.GUID_QPhi where qp.DeviceID in ("+cmdIds+") and qp.ReceiveTime &gt; ? order by qp.ReceiveTime";int flag = 0;//标识调用算法次数</p> 
 <p>String startTime = nowDateStr;//开始检测时间</p> 
 <p>String lastTime = null;//上次查询结果的最新时间</p> 
 <p>...</p> 
 <p>if(!test_flag) {<!-- --></p> 
 <p>executorService.shutdown(); //关闭线程</p> 
 <p>}</p> 
 <p>} // run()方法执行代码部分，到此为止！</p> 
 <p>}); //涉及线程代码部分，到此为止！</p> 
 <p>}catch(Exception e) {<!-- --></p> 
 <p>e.printStackTrace();return "检测失败";</p> 
 <p>}finally{try{if(resultSet != null){<!-- --></p> 
 <p>resultSet.close();</p> 
 <p>}if(pstmt != null){<!-- --></p> 
 <p>pstmt.close();</p> 
 <p>}if(pstmt2 != null){<!-- --></p> 
 <p>pstmt2.close();</p> 
 <p>}if(con != null){<!-- --></p> 
 <p>con.close();</p> 
 <p>}</p> 
 <p>}catch(SQLException e) {<!-- --></p> 
 <p>e.printStackTrace();</p> 
 <p>}</p> 
 <p>}return "检测成功";</p> 
 <p>}}</p> 
 <p>我这里使用了ExecutorService创建线程池，线程执行时调用execute(Runnable)，关闭线程时调用ExecutorService.shutdown()方法。</p> 
 <p>一、ExecutorService介绍</p> 
 <p>ExecutorService是Java中对线程池定义的一个接口，它在java.util.concurrent包中，在这个接口中定义了和后台任务执行相关的方法：</p> 
 <p align="center"><img src="https://images2.imgbox.com/19/23/mYAvqdke_o.png" alt="fe2594b8e7f4c1237d504bae1f7a773a.png"></p> 
 <p>Java API对ExecutorService接口的实现有两个，所以这两个即是Java线程池具体实现类(详细了解这两个实现类，点击这里)：</p> 
 <p>1. ThreadPoolExecutor2. ScheduledThreadPoolExecutor</p> 
 <p>除此之外，ExecutorService还继承了Executor接口(注意区分Executor接口和Executors工厂类)，这个接口只有一个execute()方法，最后我们看一下整个继承树：</p> 
 <p align="center"><img src="https://images2.imgbox.com/98/86/NKQtw7fE_o.png" alt="c3d254843c58a0026e20eefdbc146d95.png"></p> 
 <p>二、ExecutorService的创建</p> 
 <p>创建一个什么样的ExecutorService的实例(即线程池)需要根据具体应用场景而定，不过Java给我们提供了一个Executors工厂类，它可以帮助我们很方便的创建各种类型ExecutorService线程池，Executors一共可以创建下面这四类线程池：</p> 
 <p>1. newCachedThreadPool 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p> 
 <p>2. newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p> 
 <p>3. newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p> 
 <p>4. newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</p> 
 <p>备注：Executors只是一个工厂类，它所有的方法返回的都是ThreadPoolExecutor、ScheduledThreadPoolExecutor这两个类的实例。</p> 
 <p>三、ExecutorService的使用</p> 
 <p>ExecutorService executorService = Executors.newFixedThreadPool(10);</p> 
 <p>executorService.execute(newRunnable() {public voidrun() {<!-- --></p> 
 <p>System.out.println("Asynchronous task");</p> 
 <p>}</p> 
 <p>});</p> 
 <p>executorService.shutdown();</p> 
 <p>四、ExecutorService的执行</p> 
 <p>ExecutorService有如下几个执行方法：</p> 
 <p>-execute(Runnable)-submit(Runnable)-submit(Callable)-invokeAny(...)- invokeAll(...)</p> 
 <p>4.1 execute(Runnable)</p> 
 <p>这个方法接收一个Runnable实例，并且异步的执行，请看下面的实例：</p> 
 <p>ExecutorService executorService =Executors.newSingleThreadExecutor();</p> 
 <p>executorService.execute(newRunnable() {public voidrun() {<!-- --></p> 
 <p>System.out.println("Asynchronous task");</p> 
 <p>}</p> 
 <p>});</p> 
 <p>executorService.shutdown();</p> 
 <p>这个方法有个问题，就是没有办法获知task的执行结果。如果我们想获得task的执行结果，我们可以传入一个Callable的实例(下面会介绍)。</p> 
 <p>4.2 submit(Runnable)</p> 
 <p>submit(Runnable)和execute(Runnable)区别是前者可以返回一个Future对象，通过返回的Future对象，我们可以检查提交的任务是否执行完毕，请看下面执行的例子：</p> 
 <p>ExecutorService executorService =Executors.newSingleThreadExecutor();</p> 
 <p>Future future= executorService.submit(newRunnable() {public voidrun() {<!-- --></p> 
 <p>System.out.println("Asynchronous task");</p> 
 <p>}</p> 
 <p>});</p> 
 <p>future.get();//returns null if the task has finished correctly.</p> 
 <p>如果任务执行完成，future.get()方法会返回一个null。注意，future.get()方法会产生阻塞。</p> 
 <p>4.3 submit(Callable)</p> 
 <p>submit(Callable)和submit(Runnable)类似，也会返回一个Future对象，但是除此之外，submit(Callable)接收的是一个Callable的实现，Callable接口中的call()方法有一个返回值，可以返回任务的执行结果，而Runnable接口中的run()方法是void的，没有返回值。请看下面实例：</p> 
 <p>ExecutorService executorService =Executors.newSingleThreadExecutor();</p> 
 <p>Future future= executorService.submit(newCallable(){public Object call() throwsException {<!-- --></p> 
 <p>System.out.println("Asynchronous Callable");return "Callable Result";</p> 
 <p>}</p> 
 <p>});</p> 
 <p>System.out.println("future.get() = " + future.get());</p> 
 <p>如果任务执行完成，future.get()方法会返回Callable任务的执行结果。注意，future.get()方法会产生阻塞。</p> 
 <p>4.4 invokeAny(…)</p> 
 <p>invokeAny(...)方法接收的是一个Callable的集合，执行这个方法不会返回Future，但是会返回所有Callable任务中其中一个任务的执行结果。这个方法也无法保证返回的是哪个任务的执行结果，反正是其中的某一个。请看下面实例：</p> 
 <p>ExecutorService executorService =Executors.newSingleThreadExecutor();</p> 
 <p>Set&gt; callables = new HashSet&gt;();</p> 
 <p>callables.add(new Callable() {public String call() throwsException {return "Task 1";</p> 
 <p>}</p> 
 <p>});</p> 
 <p>callables.add(new Callable() {public String call() throwsException {return "Task 2";</p> 
 <p>}</p> 
 <p>});</p> 
 <p>callables.add(new Callable() {public String call() throwsException {return "Task 3";</p> 
 <p>}</p> 
 <p>});</p> 
 <p>String result=executorService.invokeAny(callables);</p> 
 <p>System.out.println("result = " +result);</p> 
 <p>executorService.shutdown();</p> 
 <p>大家可以尝试执行上面代码，每次执行都会返回一个结果，并且返回的结果是变化的，可能会返回“Task2”也可是“Task1”或者其它。</p> 
 <p>4.5 invokeAll(…)</p> 
 <p>invokeAll(...)与 invokeAny(...)类似也是接收一个Callable集合，但是前者执行之后会返回一个Future的List，其中对应着每个Callable任务执行后的Future对象。情况下面这个实例：</p> 
 <p>ExecutorService executorService =Executors.newSingleThreadExecutor();</p> 
 <p>Set&gt; callables = new HashSet&gt;();</p> 
 <p>callables.add(new Callable() {public String call() throwsException {return "Task 1";</p> 
 <p>}</p> 
 <p>});</p> 
 <p>callables.add(new Callable() {public String call() throwsException {return "Task 2";</p> 
 <p>}</p> 
 <p>});</p> 
 <p>callables.add(new Callable() {public String call() throwsException {return "Task 3";</p> 
 <p>}</p> 
 <p>});</p> 
 <p>List&gt; futures =executorService.invokeAll(callables);for(Futurefuture : futures){<!-- --></p> 
 <p>System.out.println("future.get = " +future.get());</p> 
 <p>}</p> 
 <p>executorService.shutdown();</p> 
 <p>五、ExecutorService的关闭</p> 
 <p>当我们使用完成ExecutorService之后应该关闭它，否则它里面的线程会一直处于运行状态。</p> 
 <p>举个例子，如果的应用程序是通过main()方法启动的，在这个main()退出之后，如果应用程序中的ExecutorService没有关闭，这个应用将一直运行。之所以会出现这种情况，是因为ExecutorService中运行的线程会阻止JVM关闭。</p> 
 <p>如果要关闭ExecutorService中执行的线程，我们可以调用ExecutorService.shutdown()方法。在调用shutdown()方法之后，ExecutorService不会立即关闭，但是它不再接收新的任务，直到当前所有线程执行完成才会关闭，所有在shutdown()执行之前提交的任务都会被执行。</p> 
 <p>如果我们想立即关闭ExecutorService，我们可以调用ExecutorService.shutdownNow()方法。这个动作将跳过所有正在执行的任务和被提交还没有执行的任务。但是它并不对正在执行的任务做任何保证，有可能它们都会停止，也有可能执行完成。</p> 
 <p>注：关于Java线程池类ThreadPoolExecutor、ScheduledThreadPoolExecutor及Executors工厂类更详细介绍，点击这里</p> 
 <p>参考来源，点击这里</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cb8dcd4dc793050657cc1c0fe6257931/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java迭代器删除元素_java迭代器中删除元素的操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/932ba2d0a5a9e27ab7d14952efe3430d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java heap space怎么解决_java heap space错误的解决方法是什么</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>