<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于QT实现发送http的get和post请求（post还可以实现上传文件），同时实现接收返回json数据，并对其进行解析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于QT实现发送http的get和post请求（post还可以实现上传文件），同时实现接收返回json数据，并对其进行解析" />
<meta property="og:description" content="使用到中重要的类，做个简单的介绍
QNetworkAccessManager：这个类是QT帮我们封装好的工具类，主要可以用来发送Http请求 QNetworkReply：这个类主要用来监听发送的请求，并得到请求的响应结果 QHttpMultiPart：这个类主要用于封装post请求的二进制参数的数据 QEventLoop：这个类是一个控制事件 QJsonDocument：这个类用于解析JSON 头文件：
#ifndef HTTPTEST_H #define HTTPTEST_H #include &lt;QObject&gt; #include &lt;QDebug&gt; #include &lt;QHttpMultiPart&gt; #include &lt;QNetworkAccessManager&gt; #include &lt;QNetworkReply&gt; #include &lt;QMetaObject&gt; #include &lt;QEventLoop&gt; #include &lt;QJsonDocument&gt; //以下是json数据传送所需头文件 #include &lt;QJsonParseError&gt; #include &lt;QJsonObject&gt; #include &lt;QJsonValue&gt; #include &lt;QJsonArray&gt; #include &lt;QFile&gt; class myHttp : public QObject { Q_OBJECT public: explicit myHttp(QObject *parent = nullptr); void sendGetRequest(); void sendPostRequest(); QString resultGet; QString resultPost; public slots: void receiveReplyGet(QNetworkReply *reply); void receiveReplyPost(QNetworkReply *reply); }; #endif // HTTPTEST_H cpp文件" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/91e4b8c37d2ce5da3d2607e3a0ddfd03/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-23T17:24:59+08:00" />
<meta property="article:modified_time" content="2023-09-23T17:24:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于QT实现发送http的get和post请求（post还可以实现上传文件），同时实现接收返回json数据，并对其进行解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>使用到中重要的类，做个简单的介绍</p> 
<blockquote> 
 <pre>QNetworkAccessManager：这个类是QT帮我们封装好的工具类，主要可以用来发送Http请求</pre> 
 <pre>QNetworkReply：这个类主要用来监听发送的请求，并得到请求的响应结果</pre> 
 <pre>QHttpMultiPart：这个类主要用于封装post请求的二进制参数的数据</pre> 
 <pre>QEventLoop：这个类是一个控制事件</pre> 
 <pre>QJsonDocument：这个类用于解析JSON</pre> 
 <p></p> 
</blockquote> 
<p>头文件：</p> 
<pre><code class="language-cpp">#ifndef HTTPTEST_H
#define HTTPTEST_H

#include &lt;QObject&gt;
#include &lt;QDebug&gt;
#include &lt;QHttpMultiPart&gt;
#include &lt;QNetworkAccessManager&gt;
#include &lt;QNetworkReply&gt;
#include &lt;QMetaObject&gt;
#include &lt;QEventLoop&gt;
#include &lt;QJsonDocument&gt;            //以下是json数据传送所需头文件
#include &lt;QJsonParseError&gt;
#include &lt;QJsonObject&gt;
#include &lt;QJsonValue&gt;
#include &lt;QJsonArray&gt;
#include &lt;QFile&gt;




class myHttp : public QObject
{
    Q_OBJECT

public:
    explicit myHttp(QObject *parent = nullptr);
    void sendGetRequest();
    void sendPostRequest();
    QString resultGet;
    QString resultPost;




public slots:
    void receiveReplyGet(QNetworkReply *reply);
    void receiveReplyPost(QNetworkReply *reply);


};



#endif // HTTPTEST_H
</code></pre> 
<p>cpp文件</p> 
<pre><code class="language-cpp">#include "myHttp.h"

myHttp::myHttp(QObject *parent) : QObject(parent)
{

}

void myHttp::sendGetRequest()
{

    qDebug()&lt;&lt;"get方法被执行";
    QNetworkRequest request1;
    QNetworkAccessManager nam;
    connect(&amp;nam, &amp;QNetworkAccessManager::finished, this, &amp;myHttp::receiveReplyGet);

    //get与post的请求方式有所不同，get是在接口名后添加 ? 和传输的数据(type)
    request1.setUrl(QUrl("http://localhost:8080/dish/page?hello=666&amp;name=hjl&amp;age=18"));
    request1.setHeader(QNetworkRequest::ContentTypeHeader,QVariant("application/json;charset=utf-8"));
    QString token = "xxxxxxxxxxxxxxxxxxxxxxxx";
    QString token_headerData = token;
    request1.setRawHeader("token",token_headerData.toLocal8Bit());
    QNetworkReply *reply = nam.get(request1);    //get请求头

    //开启事件循环，直到请求完成
    QEventLoop loop;
    connect(reply,&amp;QNetworkReply::finished,&amp;loop,&amp;QEventLoop::quit);
    loop.exec();

}

void myHttp::receiveReplyGet(QNetworkReply *reply)
{
    qDebug()&lt;&lt;"得到get方法的返回值";
    // 获取状态码
    int status_code = reply-&gt;attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
    // 获取响应数据
    QString reply_data = reply-&gt;readAll();
    qDebug()&lt;&lt;reply_data&lt;&lt;status_code;
    resultGet=reply_data;


    //解析json字符串
    QJsonDocument jsonDoc = QJsonDocument::fromJson(reply_data.toUtf8());
    QJsonObject jsonObj = jsonDoc.object();

    QString date = jsonObj["date"].toString();
    int code = jsonObj["code"].toInt();
    QString msg = jsonObj["mes"].toString();

    qDebug()&lt;&lt;reply_data&lt;&lt;status_code&lt;&lt;date&lt;&lt;msg&lt;&lt;code;


}



void myHttp::sendPostRequest()
{
        qDebug()&lt;&lt;"post方法被执行";

        QHttpMultiPart *multiPart = new QHttpMultiPart(QHttpMultiPart::FormDataType);
        //封装文本参数
         QHttpPart textPart;
         textPart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=text"));
         textPart.setBody("text");


         //封装文件参数
         QHttpPart filePart;
         filePart.setHeader(QNetworkRequest::ContentDispositionHeader, QVariant("form-data; name=file; filename=output.wav"));
         QString filename="F:\\output.wav";
         QFile file(filename);
         QByteArray bytes;

         if (!file.exists()) {
             qDebug() &lt;&lt; "文件不存在";
             return;
         }

         if (file.open(QFile::ReadOnly)) {
             bytes = file.readAll();
              qDebug() &lt;&lt; "状态：读取文件成功";
         }
         file.close();
         filePart.setBody(bytes);
         qDebug()&lt;&lt;bytes.size();


        //将封装到的参数加入到这个对象中
         multiPart-&gt;append(textPart);
         multiPart-&gt;append(filePart);



         QUrl url("http://localhost:8080/common/upload?age=18&amp;hobby=football");
         QNetworkRequest request(url);
         request.setHeader(QNetworkRequest::ContentTypeHeader, QVariant("multipart/form-data; boundary="+multiPart-&gt;boundary()));

         QNetworkAccessManager manager;

         connect(&amp;manager, &amp;QNetworkAccessManager::finished, this, &amp;myHttp::receiveReplyPost);
         QNetworkReply *reply = manager.post(request, multiPart);



        //开启事件循环，直到请求完成
        QEventLoop loop;
        connect(reply,&amp;QNetworkReply::finished,&amp;loop,&amp;QEventLoop::quit);
        loop.exec();


}

void myHttp::receiveReplyPost(QNetworkReply *reply)
{
        qDebug()&lt;&lt;"post方法返回";
        // 获取状态码
        int status_code = reply-&gt;attribute(QNetworkRequest::HttpStatusCodeAttribute).toInt();
        // 获取响应数据
        QString reply_data = reply-&gt;readAll();
        resultPost=reply_data;


        //解析json字符串
        QJsonDocument jsonDoc = QJsonDocument::fromJson(reply_data.toUtf8());
        QJsonObject jsonObj = jsonDoc.object();

        QString date = jsonObj["data"].toString();
        int code = jsonObj["code"].toInt();
        QString msg = jsonObj["msg"].toString();

        qDebug()&lt;&lt;reply_data&lt;&lt;status_code&lt;&lt;date&lt;&lt;msg&lt;&lt;code;

}




</code></pre> 
<p></p> 
<p>效果：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/60/e7/56qZZLfr_o.png"></p> 
<p></p> 
<p>最后，如有不足欢迎指正，如有疑问，欢迎评论</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4736c0858f289933275eaeb16307ecdc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android 时区使用和总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/31a98066675a785656fb141950d96261/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">建立一张表： 表里面有多个字段，每一个字段对应一种数据类</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>