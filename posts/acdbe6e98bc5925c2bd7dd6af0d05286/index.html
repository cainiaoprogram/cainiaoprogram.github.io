<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[数据结构]----链表(无头单向非循环链表的实现) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[数据结构]----链表(无头单向非循环链表的实现)" />
<meta property="og:description" content="目录
1. 顺序表的缺陷
2. 链表
2.1 链表的概念
2.2.链表的结构
2.3 链表的分类
3. 无头单向非循环链表
3.1 链表的结构体定义
3.2 动态创建一个链表新结点
3.3 打印链表
3.4 尾插和尾删
3.5 头插和头删
3.6 找到x值的地址
3.7 在pos前面/后面插入一个数
3.8 删除某个位置/删除某个位置的后一个位置
3.9 销毁链表
1. 顺序表的缺陷 1. 中间/头部的插入删除，时间复杂度为O(N)
2. 增容需要申请新空间，拷贝数据，释放旧空间。会有不小的消耗。
3. 增容一般是呈2倍的增长，势必会有一定的空间浪费。
2. 链表 2.1 链表的概念 概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的
2.2. 链表的结构 链表结构是有一个Data存储值/数据，有一个结构体指针存放下一个结点的地址
2.3 链表的分类 1.单向链表或双向链表
2.带头（哨兵位）链表或不带头（哨兵位）链表
3.循环链表或不循环链表
每种类型都有两种不同的结构，所以一共能出8种（2*2*2）不同的结构
虽然链表的种类众多，但是我们主要用两种链表
无头单向非循环链表和带头双向循环链表
1. 无头单向非循环链表：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构
2. 带头双向循环链表：结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都是带头双向循环链表。这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势
3. 无头单向非循环链表 注：为什么有的函数传递二级指针
因为当链表的头结点需要被改变时，需要传递头结点的地址，以此才能改变头结点 3.1 链表的结构体定义 typedef int DataType; typedef struct Slist { DataType data; struct Slist* next; }SL; 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/acdbe6e98bc5925c2bd7dd6af0d05286/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-12T12:15:19+08:00" />
<meta property="article:modified_time" content="2022-11-12T12:15:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[数据结构]----链表(无头单向非循环链表的实现)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%BC%BA%E9%99%B7-toc" style="margin-left:0px;"><a href="#1.%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%BC%BA%E9%99%B7" rel="nofollow">1. 顺序表的缺陷</a></p> 
<p id="2.%C2%A0%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#2.%C2%A0%E9%93%BE%E8%A1%A8" rel="nofollow">2. 链表</a></p> 
<p id="2.1%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#2.1%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5" rel="nofollow">2.1 链表的概念</a></p> 
<p id="2.2.%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84-toc" style="margin-left:40px;"><a href="#2.2.%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84" rel="nofollow">2.2.链表的结构</a></p> 
<p id="2.3%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:40px;"><a href="#2.3%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB" rel="nofollow">2.3 链表的分类</a></p> 
<p id="3.%20%E6%97%A0%E5%A4%B4%E5%8D%95%E5%90%91%E9%9D%9E%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#3.%20%E6%97%A0%E5%A4%B4%E5%8D%95%E5%90%91%E9%9D%9E%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8" rel="nofollow">3. 无头单向非循环链表</a></p> 
<p id="3.1%20%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89-toc" style="margin-left:40px;"><a href="#3.1%20%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89" rel="nofollow">3.1 链表的结构体定义</a></p> 
<p id="3.2%20%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%96%B0%E7%BB%93%E7%82%B9-toc" style="margin-left:40px;"><a href="#3.2%20%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%96%B0%E7%BB%93%E7%82%B9" rel="nofollow">3.2 动态创建一个链表新结点</a></p> 
<p id="3.3%20%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#3.3%20%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8" rel="nofollow">3.3 打印链表</a></p> 
<p id="3.4%20%E5%B0%BE%E6%8F%92%E5%92%8C%E5%B0%BE%E5%88%A0-toc" style="margin-left:40px;"><a href="#3.4%20%E5%B0%BE%E6%8F%92%E5%92%8C%E5%B0%BE%E5%88%A0" rel="nofollow">3.4 尾插和尾删</a></p> 
<p id="3.5%20%E5%A4%B4%E6%8F%92%E5%92%8C%E5%A4%B4%E5%88%A0-toc" style="margin-left:40px;"><a href="#3.5%20%E5%A4%B4%E6%8F%92%E5%92%8C%E5%A4%B4%E5%88%A0" rel="nofollow">3.5 头插和头删</a></p> 
<p id="3.6%20%E6%89%BE%E5%88%B0x%E5%80%BC%E7%9A%84%E5%9C%B0%E5%9D%80-toc" style="margin-left:40px;"><a href="#3.6%20%E6%89%BE%E5%88%B0x%E5%80%BC%E7%9A%84%E5%9C%B0%E5%9D%80" rel="nofollow">3.6 找到x值的地址</a></p> 
<p id="3.7%20%E5%9C%A8pos%E5%89%8D%E9%9D%A2%2F%E5%90%8E%E9%9D%A2%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B0-toc" style="margin-left:40px;"><a href="#3.7%20%E5%9C%A8pos%E5%89%8D%E9%9D%A2%2F%E5%90%8E%E9%9D%A2%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B0" rel="nofollow">3.7 在pos前面/后面插入一个数</a></p> 
<p id="3.8%20%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AA%E4%BD%8D%E7%BD%AE%2F%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AA%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE-toc" style="margin-left:40px;"><a href="#3.8%20%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AA%E4%BD%8D%E7%BD%AE%2F%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AA%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE" rel="nofollow">3.8 删除某个位置/删除某个位置的后一个位置</a></p> 
<p id="3.9%C2%A0%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#3.9%C2%A0%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8" rel="nofollow">3.9 销毁链表</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p></p> 
<h2 id="1.%C2%A0%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E7%BC%BA%E9%99%B7"><strong>1. <span style="color:#fe2c24;"><span style="background-color:#f9eda6;">顺序表的缺陷</span></span></strong></h2> 
<blockquote> 
 <p><strong>1. 中间/头部的插入删除，时间复杂度为<span style="color:#fe2c24;">O(N)</span></strong></p> 
 <p><br><strong>2.<span style="color:#fe2c24;"><span style="background-color:#f9eda6;"> 增容需要申请新空间</span></span>，拷贝数据，释放旧空间。会有不小的消耗。</strong></p> 
 <p><br><strong>3. <span style="color:#fe2c24;"><span style="background-color:#f9eda6;">增容一般是呈2倍的增长，势必会有一定的空间浪费</span></span>。</strong></p> 
</blockquote> 
<h2 id="2.%C2%A0%E9%93%BE%E8%A1%A8"><strong>2. <span style="color:#fe2c24;"><span style="background-color:#f9eda6;">链表</span></span></strong></h2> 
<h3 id="2.1%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E6%A6%82%E5%BF%B5"><strong>2.1 <span style="color:#fe2c24;"><span style="background-color:#f9eda6;">链表的概念</span></span></strong></h3> 
<blockquote> 
 <p><strong>概念：链表是一种物理存储结构上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的</strong></p> 
</blockquote> 
<h3 id="2.2.%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84"><strong>2.2. <span style="color:#fe2c24;"><span style="background-color:#f9eda6;">链表的结构</span></span></strong></h3> 
<p> <img alt="" height="540" src="https://images2.imgbox.com/6c/31/O7zj3Ikr_o.png" width="1188"></p> 
<blockquote> 
 <p><strong> 链表结构是有一个<span style="color:#fe2c24;">Data存储值/数据</span>，有一个<span style="color:#956fe7;">结构体指针</span>存放下一个结点的地址</strong></p> 
</blockquote> 
<h3 id="2.3%C2%A0%E9%93%BE%E8%A1%A8%E7%9A%84%E5%88%86%E7%B1%BB"><strong>2.3 <span style="color:#fe2c24;"><span style="background-color:#f9eda6;">链表的分类</span></span></strong></h3> 
<p><strong>1.单向链表或双向链表</strong></p> 
<p class="img-center"><img alt="" height="148" src="https://images2.imgbox.com/cd/d2/RfnfmNRo_o.png" width="516"></p> 
<p><strong> 2.带头（哨兵位）链表或不带头（哨兵位）链表</strong></p> 
<p class="img-center"><img alt="" height="147" src="https://images2.imgbox.com/e2/92/DSCCokaW_o.png" width="479"></p> 
<p><strong> 3.循环链表或不循环链表</strong></p> 
<p class="img-center"><img alt="" height="163" src="https://images2.imgbox.com/ee/83/VBUsneHd_o.png" width="391"></p> 
<p><strong> 每种类型都有两种不同的结构，所以一共能出<span style="color:#fe2c24;">8种（2*2*2）不同的结构</span></strong></p> 
<p></p> 
<p><strong>虽然链表的种类众多，但是我们主要用两种链表</strong></p> 
<p><strong><span style="color:#38d8f0;">无头单向非循环链表</span>和<span style="color:#956fe7;">带头双向循环链表</span></strong></p> 
<p class="img-center"><img alt="" height="290" src="https://images2.imgbox.com/75/03/0xGQCInC_o.png" width="688"></p> 
<blockquote> 
 <p><strong>1. <span style="color:#fe2c24;"><span style="background-color:#f9eda6;">无头单向非循环链表</span></span>：结构简单，一般不会单独用来存数据。实际中更多是作为其他数据结构的子结构</strong></p> 
 <p><br><strong>2. <span style="color:#fe2c24;"><span style="background-color:#f9eda6;">带头双向循环链表</span></span>：结构最复杂，一般用在单独存储数据。实际中使用的链表数据结构，都是带头双向循环链表。这个结构虽然结构复杂，但是使用代码实现以后会发现结构会带来很多优势</strong></p> 
</blockquote> 
<h2 id="3.%20%E6%97%A0%E5%A4%B4%E5%8D%95%E5%90%91%E9%9D%9E%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><strong>3. <span style="color:#fe2c24;"><span style="background-color:#f9eda6;">无头单向非循环链表</span></span></strong></h2> 
<p> </p> 
<blockquote> 
 <p><strong> <span style="color:#fe2c24;">注：为什么有的函数传递二级指针</span></strong></p> 
 <p></p> 
 <p><strong><span style="color:#fe2c24;">        因为当链表的</span><span style="color:#956fe7;">头结点需要被改变时</span><span style="color:#fe2c24;">，需要传递头结点的地址，以此才能改变头结点 </span></strong></p> 
</blockquote> 
<p> </p> 
<h3 id="3.1%20%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9A%E4%B9%89"><strong>3.1 <span style="color:#fe2c24;"><span style="background-color:#f9eda6;">链表的结构体定义</span></span></strong></h3> 
<pre><code class="language-cpp">typedef int DataType;

typedef struct Slist
{
	DataType data;
	struct Slist* next;
}SL;</code></pre> 
<h3 id="3.2%20%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8%E6%96%B0%E7%BB%93%E7%82%B9"><strong>3.2 <span style="color:#fe2c24;"><span style="background-color:#f9eda6;">动态创建一个链表新结点</span></span></strong></h3> 
<p>函数声明：</p> 
<pre><code class="language-cpp">SL* BuyListNode(DataType x);</code></pre> 
<blockquote> 
 <p><span style="color:#fe2c24;"><strong> 在VS中malloc一个内存块时，注意检查一下malloc是否成功，最后返回malloc出来的结点地址</strong></span></p> 
</blockquote> 
<p>函数定义：  </p> 
<pre><code class="language-cpp">SL* BuyListNode(DataType x)
{
	SL* newnode = (SL*)malloc(sizeof(SL));
	if (newnode == NULL)
	{
		printf("malloc errno\n");
		exit(-1);
	}

	newnode-&gt;data = x;
	newnode-&gt;next = NULL;

	return newnode; 
}</code></pre> 
<h3 id="3.3%20%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><strong>3.3 <span style="color:#fe2c24;"><span style="background-color:#f9eda6;">打印链表</span></span></strong></h3> 
<p>函数声明：</p> 
<pre><code class="language-cpp">void SlPrint(SL* phead);
</code></pre> 
<blockquote> 
 <p><strong>注：当while循环中是<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">cur != NULL</span></span>时，最后cur会指向链表最后一个元素存储的NULL</strong></p> 
 <p class="img-center"><img alt="" height="216" src="https://images2.imgbox.com/1e/8f/fGdGdTdL_o.png" width="668"></p> 
 <p></p> 
 <p><strong>       当while循环中是<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">cur-&gt;next !=NULL</span></span>时，最后cur会指向链表的最后一个元素</strong></p> 
 <p class="img-center"><img alt="" height="239" src="https://images2.imgbox.com/d3/c0/rjJC6f7f_o.png" width="534"></p> 
 <p></p> 
</blockquote> 
<p>函数定义：  </p> 
<pre><code class="language-cpp">void SlPrint(SL* ps)
{
	SL* cur = ps;
	//while (cur)
	while (cur != NULL)
	{
		printf("%d-&gt;",cur-&gt;data);
		cur = cur-&gt;next;
	}

	printf("NULL\n");
}</code></pre> 
<h3 id="3.4%20%E5%B0%BE%E6%8F%92%E5%92%8C%E5%B0%BE%E5%88%A0"><strong>3.4 <span style="color:#fe2c24;"><span style="background-color:#f9eda6;">尾插和尾删</span></span></strong></h3> 
<p></p> 
<p><strong> <span style="color:#fe2c24;">尾插</span>：</strong></p> 
<p>函数声明： </p> 
<pre><code class="language-cpp">void SlPushBack(SL** pphead, DataType x);</code></pre> 
<blockquote> 
 <strong>无头单向非循环链表尾插需要通过遍历才能找到链表的尾，有些麻烦</strong> 
</blockquote> 
<blockquote> 
 <strong>尾插时，分两种情况：<br><br> 1.<span style="color:#fe2c24;">链表中还没有存储数据</span>，此时链表的头结点是NULL<br>    此时直接将malloc出来的结点给头结点<br><br> 2.<span style="color:#fe2c24;">链表中已经有数据</span>，此时链表的头结点不是NULL<br>     此时需要先找到尾结点，然后再把malloc出来的结点给tail-&gt;next </strong> 
</blockquote> 
<p>函数定义：  </p> 
<pre><code class="language-cpp">void SlPushBack(SL** pphead, DataType x)
{
	assert(pphead);
	SL* newnode = BuyListNode(x);

	if (*pphead == NULL)//1
	{
		*pphead = newnode;
	}
	else
	{
		//找尾
		SL* tail = *pphead;//2

		while (tail-&gt;next != NULL)
		{
			tail = tail-&gt;next;
		}

		tail-&gt;next = newnode;
	}
}</code></pre> 
<p><strong><span style="color:#fe2c24;">尾删</span>：</strong></p> 
<p>函数声明： </p> 
<pre><code class="language-cpp">void SlPopBack(SL** pphead);
</code></pre> 
<blockquote> 
 <p><strong>首先需要检查传进函数的指针不为空</strong></p> 
 <p><strong>尾删时，分两种情况：</strong><br><strong>1.<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">链表中只有一个结点</span></span>：</strong></p> 
 <p><strong>  此时直接free掉这个结点，然后再让它为空</strong></p> 
 <p></p> 
 <p><strong>2.<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">链表中不只有一个结点</span></span>：</strong></p> 
 <p><strong>  此时需要找到尾结点，同时也需要记录尾结点的前一个结点，最后让前一个节点的指向NULL</strong></p> 
 <p><strong>（原因：若只找到尾结点并释放掉的话，尾结点的前一个结点还指向原来的尾结点地址，如果打印时此时会造成指针的非法访问）</strong></p> 
 <p><strong>  </strong></p> 
</blockquote> 
<p>函数定义： </p> 
<pre><code class="language-cpp">void SlPopBack(SL** pphead)
{
	assert(*pphead);

	if ((*pphead)-&gt;next == NULL)
	{
		free(*pphead);
		*pphead = NULL;
	}
	else
	{
		SL* end = *pphead;
		SL* prve = NULL;
		while (end-&gt;next)
		{
			prve = end;
			end = end-&gt;next;
		}

		free(end);
		end = NULL;

		prve-&gt;next = NULL;
	}

}</code></pre> 
<h3 id="3.5%20%E5%A4%B4%E6%8F%92%E5%92%8C%E5%A4%B4%E5%88%A0"><strong>3.5 <span style="color:#fe2c24;"><span style="background-color:#f9eda6;">头插和头删</span></span></strong></h3> 
<p><strong><span style="color:#fe2c24;">头插</span>：</strong></p> 
<p>函数声明： </p> 
<pre><code class="language-cpp">void SlPushFront(SL** pphead, DataType x);
</code></pre> 
<blockquote> 
 <p><strong> 只需要检查一下指针不为NULL，然后将malloc出来的结点直接插入</strong></p> 
</blockquote> 
<p>函数定义：  </p> 
<pre><code class="language-cpp">void SlPushFront(SL** pphead, DataType x)
{
	assert(pphead);

	SL* newnode = BuyListNode(x);
	newnode-&gt;next = *pphead;
	*pphead = newnode;
}</code></pre> 
<p><strong><span style="color:#fe2c24;">头删</span>：</strong></p> 
<p>函数声明：</p> 
<pre><code class="language-cpp">void SlPopFront(SL** pphead);
</code></pre> 
<blockquote> 
 <p><strong>需要检查一下指针不为NULL，记录第二个结点地址，释放第一个结点，将第二个结点地址给头结点</strong></p> 
</blockquote> 
<p>函数定义：  </p> 
<pre><code class="language-cpp">void SlPopFront(SL** pphead)
{
	assert(*pphead != NULL);
	assert(pphead);

	SL* next = (*pphead)-&gt;next;
	free(*pphead);
	
	*pphead = next;

}</code></pre> 
<h3 id="3.6%20%E6%89%BE%E5%88%B0x%E5%80%BC%E7%9A%84%E5%9C%B0%E5%9D%80"><strong>3.6 <span style="color:#fe2c24;"><span style="background-color:#f9eda6;">找到x值的地址</span></span></strong></h3> 
<p>函数声明： </p> 
<pre><code class="language-cpp">SL* SlFind(SL* phead, DataType x);
</code></pre> 
<blockquote> 
 <p><strong>遍历链表，找到返回结点地址，找不到返回NULL </strong></p> 
</blockquote> 
<p>函数定义：  </p> 
<pre><code class="language-cpp">SL* SlFind(SL* phead, DataType x)
{
	assert(phead);

	while (phead)
	{
		if (phead-&gt;data == x)
		{
			return phead;
		}
		else
		{
			phead = phead-&gt;next;
		}
	}
	return NULL;
}</code></pre> 
<h3 id="3.7%20%E5%9C%A8pos%E5%89%8D%E9%9D%A2%2F%E5%90%8E%E9%9D%A2%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E6%95%B0"><strong>3.7 <span style="color:#fe2c24;"><span style="background-color:#f9eda6;">在pos前面/后面插入一个数</span></span></strong></h3> 
<p><strong><span style="color:#fe2c24;">在pos前面插入一个数</span>：</strong></p> 
<p>函数声明：</p> 
<pre><code class="language-cpp">void SlInsertBefore(SL** pphead, SL* pos, DataType x);
</code></pre> 
<blockquote> 
 <p><strong> 1.pos是头结点，此时就是头结点的前插</strong></p> 
 <p></p> 
 <p><strong> 2.在其他位置前插一个数，需要记录pos位置的前一个结点的位置</strong></p> 
</blockquote> 
<p>函数定义：  </p> 
<pre><code class="language-cpp">void SlInsertBefore(SL** pphead, SL* pos, DataType x)
{
	assert(*pphead);
	assert(pos);

	if (*pphead == pos)
	{
		SlPushFront(pphead,x);
	}
	else
	{
		SL* prev = *pphead;
		while (prev-&gt;next != pos)
		{
			prev = (*pphead)-&gt;next;
		}

		SL* newnode = BuyListNode(x);
		newnode-&gt;next = pos;
		prev-&gt;next = newnode;
	}
}</code></pre> 
<p><strong><span style="color:#fe2c24;">在pos后面插入一个数</span>：</strong></p> 
<p>函数声明：</p> 
<pre><code class="language-cpp">void SlInsertAfter(SL* pos, DataType x);
</code></pre> 
<blockquote> 
 <p><strong> 只直接改变两个结点的next指针即可</strong></p> 
</blockquote> 
<p>函数定义：  </p> 
<pre><code class="language-cpp">void SlInsertAfter(SL* pos, DataType x)
{
	SL* newnode = BuyListNode(x);
	newnode-&gt;next = pos-&gt;next;
	pos-&gt;next = newnode;
}</code></pre> 
<h3 id="3.8%20%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AA%E4%BD%8D%E7%BD%AE%2F%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AA%E4%BD%8D%E7%BD%AE%E7%9A%84%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><strong><span style="color:#0d0016;">3.8</span><span style="color:#fe2c24;"> <span style="background-color:#f9eda6;">删除某个位置/删除某个位置的后一个位置</span></span></strong></h3> 
<p><span style="color:#fe2c24;"><strong>删除某个位置 ：</strong></span></p> 
<p>函数声明：</p> 
<pre><code class="language-cpp">void SlErase(SL** pphead, SL* pos);
</code></pre> 
<blockquote> 
 <p><strong>1. pos是头结点时，调用头删函数</strong></p> 
 <p></p> 
 <p><strong>2. pos是其他结点，通过遍历找到pos的前一个结点，将pos前一个结点的next指向pos的下一个结点，最后free掉pos</strong></p> 
</blockquote> 
<p>函数定义：  </p> 
<pre><code class="language-cpp">void SlErase(SL** pphead, SL* pos)
{
	assert(*pphead);
	assert(pos);
	if(*pphead == pos)
	{
		SlPopFront(pphead);
	}
	else
	{
		SL* cur = *pphead;
		while (cur-&gt;next != pos)
		{
			cur = cur-&gt;next;
		}
		cur-&gt;next = pos-&gt;next;
		free(pos);
		pos = NULL;
	}
</code></pre> 
<p><span style="color:#fe2c24;"><strong>删除某个位置的后一个位置</strong></span>：</p> 
<p>函数声明：</p> 
<pre><code class="language-cpp">void SListEraseAfter(SL* pos);
</code></pre> 
<blockquote> 
 <p><strong>记录pos下两个结点的地址</strong></p> 
 <p><strong>将pos下两个结点的地址给pos-&gt;next </strong></p> 
</blockquote> 
<p>函数定义：  </p> 
<pre><code class="language-cpp">void SListEraseAfter(SL* pos)
{
	assert(pos);
	assert(pos-&gt;next);

	SL* next = pos-&gt;next;
	pos-&gt;next = next-&gt;next;

	free(next);
	next = NULL;
}</code></pre> 
<h3 id="3.9%C2%A0%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8"><strong>3.9 <span style="color:#fe2c24;"><span style="background-color:#f9eda6;">销毁链表</span></span></strong></h3> 
<p>函数声明：</p> 
<pre><code class="language-cpp">void SlDestory(SL** pphead);</code></pre> 
<blockquote> 
 <p><strong>通过遍历链表释放每个结点</strong></p> 
</blockquote> 
<p>函数定义： </p> 
<pre><code class="language-cpp">void SlDestory(SL** pphead)
{
	assert(pphead);

	SL* cur = *pphead;
	while (cur)
	{
		SL* next = cur-&gt;next;
		free(cur);
		cur = next;
	}
	*pphead = NULL;
}</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5f45933156a3f37c8b407ce6124535e9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">函数的传递方式</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b2b9f3787be3f978811641cd0f3a626b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Intel Trust Domain Extensions(TDX)介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>