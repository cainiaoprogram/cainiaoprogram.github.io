<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>19.系统知识-数字证书 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="19.系统知识-数字证书" />
<meta property="og:description" content="密码学相关概念 明文(plain text)：发送人、接受人和任何访问消息的人都能理解的消息。
密文(cipher text)：明文消息经过某种编码后，得到密文消息。
加密(encryption)：将明文消息变成密文消息。
解密(decryption)：将密文消息变成明文消息。
算法：取一个输入文本，产生一个输出文本。
加密算法：发送方进行加密的算法。
解密算法：接收方进行解密的算法。
密钥(key)：只有发送方和接收方掌握的消息
对称密钥加密(Symmetric Key Cryptography)：加密与解密使用相同密钥。
非对称密钥加密(Asymmetric Key Cryptography)：加密与解密使用不同密钥，分为公钥和私钥
非对称密钥加密(Asymmetric Key Cryptography)：加密与解密使用不同密钥，分为公钥和私钥
对称加密算法 • 在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的，加密和解密都是使用同一个密钥。
• 通信双方采用相同的密钥来加解密会话内容，即一段待加密内容，经过同一个密钥的两次对称加密后，与原
来的结果一样。
• 举例说明：
根据异或性质：
(A ⊕ B) ⊕ B = A A
得到如下加密方法，其中C为密文，P为明文，K是双方约定的常量，
C = P ⊕ K K
对应的解密方法则为：
P = C ⊕ K K
这就是一种简单的对称密钥算法的过程，其中异或操作是对称加密、解密算法，K则是密钥
非对称加密算法 • 非对称加解密算法的密钥是成对出现的，公钥加密过的密文只有对应的私钥能解密；私钥签名过的密文可以
通过对应的公钥验签。原则上私钥是不能在网络中传递的。
• 双方通信时，首先要将密钥对中的公钥传给对方，这个密钥可以在不安全的信道中传输；传输数据时，先使
用自己持有的密钥做加密，对方只能用自己传输过去的密钥解密。
• 举例说明：
其中C表示密文，P表示明文，x是公钥，y是私钥，
并假设 xy= 1，则有下加解密方法
加密小游戏-第一回合 “小客”-&gt;“小服”：你好
“小服”-&gt;“小客”：你好，我是小服
因为消息是在网络上传输的，有人可以冒充自己是“小服”来向小客发送信息。所以会出现下面的情况：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/71b16d3bca6baa1b528507a8e044760d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-18T17:35:27+08:00" />
<meta property="article:modified_time" content="2022-04-18T17:35:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">19.系统知识-数字证书</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>密码学相关概念</h2> 
<p><br> 明文(plain text)：发送人、接受人和任何访问消息的人都能理解的消息。<br> 密文(cipher text)：明文消息经过某种编码后，得到密文消息。<br> 加密(encryption)：将明文消息变成密文消息。<br> 解密(decryption)：将密文消息变成明文消息。<br> 算法：取一个输入文本，产生一个输出文本。<br> 加密算法：发送方进行加密的算法。<br> 解密算法：接收方进行解密的算法。<br> 密钥(key)：只有发送方和接收方掌握的消息<br> 对称密钥加密(Symmetric Key Cryptography)：加密与解密使用相同密钥。<br> 非对称密钥加密(Asymmetric Key Cryptography)：加密与解密使用不同密钥，分为公钥和私钥</p> 
<h2>非对称密钥加密(Asymmetric Key Cryptography)：加密与解密使用不同密钥，分为公钥和私钥<br><br> 对称加密算法</h2> 
<p><br> • 在对称加密算法中，加密使用的密钥和解密使用的密钥是相同的，加密和解密都是使用同一个密钥。<br> • 通信双方采用相同的密钥来加解密会话内容，即一段待加密内容，经过同一个密钥的两次对称加密后，与原<br> 来的结果一样。<br> • 举例说明：<br> 根据异或性质：<br> (A ⊕ B) ⊕ B = A A<br> 得到如下加密方法，其中C为密文，P为明文，K是双方约定的常量，<br> C = P ⊕ K K<br> 对应的解密方法则为：<br> P = C ⊕ K K<br> 这就是一种简单的对称密钥算法的过程，其中异或操作是对称加密、解密算法，K则是密钥</p> 
<h2>非对称加密算法</h2> 
<p><br> • 非对称加解密算法的密钥是成对出现的，公钥加密过的密文只有对应的私钥能解密；私钥签名过的密文可以<br> 通过对应的公钥验签。原则上私钥是不能在网络中传递的。<br> • 双方通信时，首先要将密钥对中的公钥传给对方，这个密钥可以在不安全的信道中传输；传输数据时，先使<br> 用自己持有的密钥做加密，对方只能用自己传输过去的密钥解密。<br> • 举例说明：<br> 其中C表示密文，P表示明文，x是公钥，y是私钥，<br> 并假设 xy= 1，则有下加解密方法<br><img alt="" src="https://images2.imgbox.com/c5/bc/0oF31ZWe_o.png"></p> 
<p style="text-align:center;"> <img alt="" src="https://images2.imgbox.com/ae/30/ym1yiwmt_o.png"></p> 
<h2><br> 加密小游戏-第一回合</h2> 
<p><br> “小客”-&gt;“小服”：你好<br> “小服”-&gt;“小客”：你好，我是小服<br> 因为消息是在网络上传输的，有人可以冒充自己是“小服”来向小客发送信息。所以会出现下面的情况：<br> “小客”-&gt;“黑客”：你好 // 黑客在“小客”和“小服”之间的某个路由器上截获“小客”发给小服的信<br> 息，然后自己冒充“小服”<br> “黑客”-&gt;“小客”：你好，我是小服<br> “小客”在接到消息后，并不能肯定这个消息就是由“小服”发出的，某些“黑客”也可以冒充“小服”发出<br> 这个消息。<br> 那么如何确定信息是由“小服”发过来的呢？ </p> 
<h2>加密小游戏-第二回合</h2> 
<p>“小客”-&gt;“小服”：你好<br> “小服”-&gt;“小客”：你好，我是小服<br> “小客”-&gt;“小服”：向我证明你就是小服<br> “小服”-&gt;“小客”：你好，我是小服 {你好，我是小服}[私钥|RSA]<br> //{你好，我是小服}[私钥|RSA] 表示用私钥对“你好，我是小服”进行加密后的结果。<br> 为了向“小客”证明自己是“小服”，“小服”把一个字符串用自己的私钥加密，然后发送明文+加密后的密文一<br> 起发给“小客”。<br> “小客”收到信息后，用自己持有的公钥把 {你好，我是小服}[私钥|RSA] 这个内容用公钥进行解密，然后将解密的<br> 内容和“你好，我是小服”对比。<br> 因为“小服”用私钥加密后的内容，只能由公钥进行解密，私钥只有“小服”持有，所以如果解密出来的内容是能<br> 够对得上的，那说明信息一定是从“小服”发过来的。</p> 
<h2>加密小游戏-第三回合</h2> 
<p>“小客”-&gt;“小服”：你好<br> “小服”-&gt;“小客”：你好，我是小服<br> “小客”-&gt;“小服”：向我证明你就是小服<br> “小服”-&gt;“小客”：你好，我是小服 {你好，我是小服}[私钥|RSA]<br> “小客”-&gt;“小服”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[公钥|RSA]<br> “小服”-&gt;“小客”：{你的余额是100元}[私钥|RSA]<br> 注意上面的的信息 {你的余额是100元}[私钥|RSA]，这个是“小服”用私钥加密后的内容。<br> 我们之前说了，公钥是发布出去的，因此所有的人都知道公钥。所以除了“小客”，其它的人也可以用公钥对<br> {你的余额是100元}[私钥|RSA]进行解密。因此这个信息是无法保密的；<br> 在实际的应用过程，一般是通过引入对称加密来解决这个问题，看下面的演示：</p> 
<h2>加密小游戏-第四回合</h2> 
<p>“小客”-&gt;“小服”：你好<br> “小服”-&gt;“小客”：你好，我是小服<br> “小客”-&gt;“小服”：向我证明你就是小服<br> “小服”-&gt;“小客”：你好，我是小服 {你好，我是小服}[私钥|RSA]<br> “小客”-&gt;“小服”：{我们后面的通信过程，用对称加密来进行，这里是对称加密算法和密钥}[公钥|RSA] //红色字<br> 体的部分是对称加密的算法和密钥的具体内容，小客把它们发送给小服。<br> “小服”-&gt;“小客”：{OK，收到！}[密钥|对称加密算法]<br> “小客”-&gt;“小服”：{我的帐号是aaa，密码是123，把我的余额的信息发给我看看}[密钥|对称加密算法]<br> “小服”-&gt;“小客”：{你的余额是100元}[密钥|对称加密算法]<br> “小客”在确认了“小服”的身份后，“小客”自己选择一个对称加密算法和一个密钥，把这个对称加密算法和密钥<br> 一起用公钥加密后发送给“小服”。<br> 对称加密算法和密钥是用公钥加密的，因此就算这个加密后的内容被“黑客”截获了，由于没有私钥，“黑客”也无<br> 从知道对称加密算法和密钥的内容，这样可以保证只有小服可以知道对称加密算法和密钥。“小服”和“小客”就可<br> 以用对称加密算法和密钥来加密通信的内容了。</p> 
<h2>加密小游戏-遗留问题</h2> 
<p>“小服”要对外发布公钥，那“小服”如何把公钥发送给“小客”呢？我们可能会想到以下两个方法：<br> a)把公钥放到互联网的某个地方的一个下载地址，事先给“小客”去下载<br> b)每次和“小客”开始通信时，“小服”把公钥发给“小客”<br> 但是这个两个方法都有一定的问题：<br> 对于a)方法，“小客”无法确定这个下载地址是不是“小服”发布的；另外要所有的“小客”都在通信前事先去下载<br> 公钥也很不现实。<br> 对于b)方法，也有问题，因为任何人都可以自己生成一对公钥和私钥，他只要向“小客”发送他自己的公钥就可以冒<br> 充“小服”了。</p> 
<h2>证书概念</h2> 
<p>• 数字证书（”digital certificate”或“public key certificate”)是指在互联网通讯中标志通讯各方身份信息的一个数字认证，在网上用它来识别对方的身份。从本质上来说是一种电子文档，它的作用是证明某某东西确实是某某东西。<br> • CA（ Certificate Authority ）也叫“证书授权中心”。负责发放和管理数字证书的权威机构。一般来说，CA必须是所有行业和所有公众都信任的、认可的，因此它必须具有足够的权威性。</p> 
<h2>证书分类</h2> 
<p>按持有者分类 ：<br> • 个人证书：CA中心给个人颁发的证书，仅代表个人身份，证书包含个人信息和个人公钥。<br> • 单位证书：CA中心给组织机构颁发的证书，代表机构的身份，包含机构单位的信息和单位公钥。<br> • 系统证书：CA中心给应用系统或者设备颁发的证书，代表系统的身份，包含系统的信息和系统的公钥。<br> 按证书用途分类：<br> • 签名证书：签名证书只能用于签名和验证签名，为了密钥的安全，密钥对一般在小客端产生和保存。<br> • 加密证书：加密证书只能用于加密，其中密钥对由CA产生，通过保护算法和协议发送给用户保存，同时CA<br> 中心也保存该密钥对，以备管理和恢复。</p> 
<h2>证书格式</h2> 
<p>证书有PEM和DER编码格式，其中PEM是采用Base64编码字符保存，DER格式采用二进制保存。<br> 一张证书包含公钥与私钥，对应着非对称加密算法中用到的公私钥。通常用.crt后缀标识公钥，用.key标识私钥。<br> 还有一种将公钥与私钥捆绑在一起的保存方法，后缀通常为.pfx(微软用)或者.p12。</p> 
<h2>证书内容</h2> 
<p>证书公钥中除了保存公钥内容以外，通常还有颁发者、<br> 使用者、有效期、签名等信息。<br> 证书私钥中有公私钥信息，全部的RSA算法参数</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/3c/da/aUQKTnRe_o.png"></p> 
<h2>证书信任链</h2> 
<p><br> CA(Certificate Authority):数字证书认证中心的简称<br> 根CA:处在信任链的顶端，其证书公钥默认导入各种操作<br> 系统与浏览器中<br> 中级CA:处于信任链中间，根CA或其他中级CA颁发的证<br> 书，还能继续颁发子证书<br> 个人:处在信任链末端，中级CA或根CA颁发的证书 </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/42/fe/JrJHevj7_o.png"></p> 
<p>证书之间的信任关系，是可以嵌套的。<br> 比如，C 信任 A1，A1 信任 A2，A2<br> 信任 A3......这个叫做证书的信任链。<br> 只要你信任链上的头一个证书，那后<br> 续的证书，都是可以信任的。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/88/6f/t8nyQj3B_o.png"> </p> 
<h2>证书吊销列表</h2> 
<p>如果证书持有者一个不小心，将证书私钥给泄露了，这个时候他人就可以冒用其身份。<br> 为了防止这种情况发生，各大CA都维护着一张CRL列表，里面标记了虽然还未过有效期，但已不能再使用的证书。 </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1b/9d/1GR5zUR9_o.png"></p> 
<h2>证书工作原理 </h2> 
<p>“小服”在给“小客”发公钥的过程中，会把公钥以及<br> 小服的个人信息通过Hash算法生成消息摘要；<br> 为了防止摘要被人调换， “小服”还会用CA提供的私<br> 钥对消息摘要进行加密来形成数字签名；<br> 并且，最后还会把原来没Hash算法之前的信息和数字签<br> 名合并在一起，形成数字证书。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/05/6b/Zh4T5Bcg_o.png"></p> 
<p>当“小客”拿到这份数字证书之后，就会用CA提供的公钥来对数字证书里面的数字签名进行解密得到消息摘要，然后对数字证书里面“小服” 的公钥和个人信息进行Hash得到另一份消息摘要，然后把两份消息摘要进行对比，如果一样，则证明这些东西确实是“小服” 的，否则就不是 </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2f/10/YLvzrJ6K_o.png"></p> 
<p>SSL概念</p> 
<p><br> SSL(Secure Sockets Layer 安全套接层)基于HTTPS下的一个协议加密层，它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能。SSL协议分为以下两层：<br> SSL记录协议层的作用是为高层协议提供基本的安全服务。SSL记录协议针对HTTP协议进行了特别的设计，使得超文本的传输协议HTTP能够在SSL运行。记录封装各种高层协议，具体实施压缩解压缩、加密解密、计算和校验MAC等与安全有关的操作。<br> SSL握手协议层包括SSL握手协议（SSL HandShake Protocol）、SSL密码参数修改协议（SSL<br> Change Cipher Spec Protocol）、应用数据协议（Application Data Protocol）和SSL告警协议<br> （SSL Alert Protocol）。握手层的这些协议用于SSL管理信息的交换，允许应用协议传送数据之前<br> 相互验证，协商加密算法和生成密钥等。SSL握手协议的作用是协调小客和小服的状态，使双方能够达到状态的同步。 </p> 
<p>SSL单向认证</p> 
<p>客户端验证服务器的过程</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b3/e3/UknhOko9_o.png"></p> 
<p>SSL双向认证</p> 
<p> 客户端和服务器相互认证的过程</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/38/2e/iqh2QKc8_o.png"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/70c4a589d234ab3e4e86d4e1de7ca223/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Win10版本太低更新不了怎么办</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/88c8ffc57a23b174ef77617210db5a23/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">数组中01，可以将数组的一段翻转（0 变 1, 1 变 0），求翻转后数组最多1的个数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>