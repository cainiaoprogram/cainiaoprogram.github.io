<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RabbitMq 消息确认机制详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RabbitMq 消息确认机制详解" />
<meta property="og:description" content="目录
1.消息可靠性
1.1.生产者消息确认
1.1.1.修改配置
1.1.2.定义Return回调
1.1.3.定义ConfirmCallback
1.2.消息持久化
1.2.1.交换机持久化
1.2.2.队列持久化
1.2.3.消息持久化
1.3.消费者消息确认
1.3.1.演示none模式
1.3.2.演示auto模式
1.4.消费失败重试机制
1.4.1.本地重试
1.4.2.失败策略
1.5.总结
1.消息可靠性 消息从发送，到消费者接收，会经理多个过程：
其中的每一步都可能导致消息丢失，常见的丢失原因包括：
发送时丢失：
生产者发送的消息未送达exchange消息到达exchange后未到达queue MQ宕机，queue将消息丢失
consumer接收到消息后未消费就宕机
针对这些问题，RabbitMQ分别给出了解决方案：
生产者确认机制mq持久化消费者确认机制失败重试机制 1.1.生产者消息确认 RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。这种机制必须给每个消息指定一个唯一ID。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功。
返回结果有两种方式：
publisher-confirm，发送者确认
消息成功投递到交换机，返回ack消息未投递到交换机，返回nack publisher-return，发送者回执
消息投递到交换机了，但是没有路由到队列。返回ACK，及路由失败原因。 注意：
1.1.1.修改配置
首先，修改publisher服务中的application.yml文件，添加下面的内容：
spring: rabbitmq: publisher-confirm-type: correlated publisher-returns: true template: mandatory: true 说明：
publish-confirm-type：开启publisher-confirm，这里支持两种类型：
simple：同步等待confirm结果，直到超时correlated：异步回调，定义ConfirmCallback，MQ返回结果时会回调这个ConfirmCallback publish-returns：开启publish-return功能，同样是基于callback机制，不过是定义ReturnCallback
template.mandatory：定义消息路由失败时的策略。true，则调用ReturnCallback；false：则直接丢弃消息
1.1.2.定义Return回调 每个RabbitTemplate只能配置一个ReturnCallback，因此需要在项目加载时配置：
修改publisher服务，添加一个：
package cn.itcast.mq.config; import lombok.extern.slf4j.Slf4j; import org.springframework.amqp.rabbit.core.RabbitTemplate; import org.springframework.beans.BeansException; import org.springframework.context.ApplicationContext; import org.springframework.context.ApplicationContextAware; import org.springframework.context.annotation.Configuration; @Slf4j @Configuration public class CommonConfig implements ApplicationContextAware { @Override public void setApplicationContext(ApplicationContext applicationContext) throws BeansException { // 获取RabbitTemplate RabbitTemplate rabbitTemplate = applicationContext." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2deb8c2c2930ad06dfcc4b490db08c92/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-02-01T22:12:09+08:00" />
<meta property="article:modified_time" content="2023-02-01T22:12:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RabbitMq 消息确认机制详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="1.%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7-toc" style="margin-left:0px;"><a href="#1.%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7" rel="nofollow">1.消息可靠性</a></p> 
<p id="1.1.%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4-toc" style="margin-left:40px;"><a href="#1.1.%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4" rel="nofollow">1.1.生产者消息确认</a></p> 
<p id="1.1.1.%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE-toc" style="margin-left:80px;"><a href="#1.1.1.%E4%BF%AE%E6%94%B9%E9%85%8D%E7%BD%AE" rel="nofollow">1.1.1.修改配置</a></p> 
<p id="1.1.2.%E5%AE%9A%E4%B9%89Return%E5%9B%9E%E8%B0%83-toc" style="margin-left:80px;"><a href="#1.1.2.%E5%AE%9A%E4%B9%89Return%E5%9B%9E%E8%B0%83" rel="nofollow">1.1.2.定义Return回调</a></p> 
<p id="1.1.3.%E5%AE%9A%E4%B9%89ConfirmCallback-toc" style="margin-left:80px;"><a href="#1.1.3.%E5%AE%9A%E4%B9%89ConfirmCallback" rel="nofollow">1.1.3.定义ConfirmCallback</a></p> 
<p id="1.2.%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96-toc" style="margin-left:40px;"><a href="#1.2.%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96" rel="nofollow">1.2.消息持久化</a></p> 
<p id="1.2.1.%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%8C%81%E4%B9%85%E5%8C%96-toc" style="margin-left:80px;"><a href="#1.2.1.%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%8C%81%E4%B9%85%E5%8C%96" rel="nofollow">1.2.1.交换机持久化</a></p> 
<p id="1.2.2.%E9%98%9F%E5%88%97%E6%8C%81%E4%B9%85%E5%8C%96-toc" style="margin-left:80px;"><a href="#1.2.2.%E9%98%9F%E5%88%97%E6%8C%81%E4%B9%85%E5%8C%96" rel="nofollow">1.2.2.队列持久化</a></p> 
<p id="1.2.3.%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96-toc" style="margin-left:80px;"><a href="#1.2.3.%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96" rel="nofollow">1.2.3.消息持久化</a></p> 
<p id="1.3.%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4-toc" style="margin-left:40px;"><a href="#1.3.%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4" rel="nofollow">1.3.消费者消息确认</a></p> 
<p id="1.3.1.%E6%BC%94%E7%A4%BAnone%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#1.3.1.%E6%BC%94%E7%A4%BAnone%E6%A8%A1%E5%BC%8F" rel="nofollow">1.3.1.演示none模式</a></p> 
<p id="1.3.2.%E6%BC%94%E7%A4%BAauto%E6%A8%A1%E5%BC%8F-toc" style="margin-left:80px;"><a href="#1.3.2.%E6%BC%94%E7%A4%BAauto%E6%A8%A1%E5%BC%8F" rel="nofollow">1.3.2.演示auto模式</a></p> 
<p id="1.4.%E6%B6%88%E8%B4%B9%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6-toc" style="margin-left:40px;"><a href="#1.4.%E6%B6%88%E8%B4%B9%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6" rel="nofollow">1.4.消费失败重试机制</a></p> 
<p id="1.4.1.%E6%9C%AC%E5%9C%B0%E9%87%8D%E8%AF%95-toc" style="margin-left:80px;"><a href="#1.4.1.%E6%9C%AC%E5%9C%B0%E9%87%8D%E8%AF%95" rel="nofollow">1.4.1.本地重试</a></p> 
<p id="1.4.2.%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5-toc" style="margin-left:80px;"><a href="#1.4.2.%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5" rel="nofollow">1.4.2.失败策略</a></p> 
<p id="1.5.%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#1.5.%E6%80%BB%E7%BB%93" rel="nofollow">1.5.总结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="1.%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7">1.消息可靠性</h2> 
<p>消息从发送，到消费者接收，会经理多个过程：</p> 
<p><img alt="" height="423" src="https://images2.imgbox.com/da/2c/S044qvl7_o.png" width="1200"></p> 
<p> </p> 
<p></p> 
<p>其中的每一步都可能导致消息丢失，常见的丢失原因包括：</p> 
<ul><li> <p><strong>发送时丢失：</strong></p> 
  <ol><li>生产者发送的消息未送达exchange</li><li>消息到达exchange后未到达queue</li></ol></li><li> <p><strong>MQ宕机，queue将消息丢失</strong></p> </li><li> <p><strong>consumer接收到消息后未消费就宕机</strong></p> </li></ul> 
<p>针对这些问题，RabbitMQ分别给出了解决方案：</p> 
<ul><li><strong>生产者确认机制</strong></li><li><strong>mq持久化</strong></li><li><strong>消费者确认机制</strong></li><li><strong>失败重试机制</strong></li></ul> 
<h3 id="1.1.%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4">1.1.生产者消息确认</h3> 
<p>RabbitMQ提供了publisher confirm机制来避免消息发送到MQ过程中丢失。这种机制必须给每个消息指定一个唯一ID。消息发送到MQ以后，会返回一个结果给发送者，表示消息是否处理成功。</p> 
<p>返回结果有两种方式：</p> 
<ul><li> <p>publisher-confirm，发送者确认</p> 
  <ul><li><strong>消息成功投递到交换机，返回ack</strong></li><li><strong>消息未投递到交换机，返回nack</strong></li></ul></li><li> <p>publisher-return，发送者回执</p> 
  <ul><li><strong>消息投递到交换机了，但是没有路由到队列。返回ACK，及路由失败原因。</strong></li></ul></li></ul> 
<p><img alt="" height="281" src="https://images2.imgbox.com/75/f5/52FyRq7z_o.png" width="1200"></p> 
<p>注意：</p> 
<p><img alt="" height="180" src="https://images2.imgbox.com/af/dc/wSX9Ohga_o.png" width="630"></p> 
<p><strong>1.1.1.修改配置</strong></p> 
<p>首先，修改publisher服务中的application.yml文件，添加下面的内容：</p> 
<pre><code class="language-java">spring:
  rabbitmq:
    publisher-confirm-type: correlated
    publisher-returns: true
    template:
      mandatory: true
   
</code></pre> 
<p>说明：</p> 
<ul><li> <p><code>publish-confirm-type</code>：开启publisher-confirm，这里支持两种类型：</p> 
  <ul><li><code>simple</code>：同步等待confirm结果，直到超时</li><li><code>correlated</code>：异步回调，定义ConfirmCallback，MQ返回结果时会回调这个ConfirmCallback</li></ul></li><li> <p><code>publish-returns</code>：开启publish-return功能，同样是基于callback机制，不过是定义ReturnCallback</p> </li><li> <p><code>template.mandatory</code>：定义消息路由失败时的策略。true，则调用ReturnCallback；false：则直接丢弃消息</p> </li></ul> 
<p></p> 
<h4 id="1.1.2.%E5%AE%9A%E4%B9%89Return%E5%9B%9E%E8%B0%83">1.1.2.定义Return回调</h4> 
<p>每个RabbitTemplate只能配置一个ReturnCallback，因此需要在项目加载时配置：</p> 
<p>修改publisher服务，添加一个：</p> 
<pre><code class="language-java">package cn.itcast.mq.config;

import lombok.extern.slf4j.Slf4j;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.annotation.Configuration;

@Slf4j
@Configuration
public class CommonConfig implements ApplicationContextAware {
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        // 获取RabbitTemplate
        RabbitTemplate rabbitTemplate = applicationContext.getBean(RabbitTemplate.class);
        // 设置ReturnCallback
        rabbitTemplate.setReturnCallback((message, replyCode, replyText, exchange, routingKey) -&gt; {
            // 投递失败，记录日志
            log.info("消息发送失败，应答码{}，原因{}，交换机{}，路由键{},消息{}",
                     replyCode, replyText, exchange, routingKey, message.toString());
            // 如果有业务需要，可以重发消息
        });
    }
}
</code></pre> 
<p></p> 
<h4 id="1.1.3.%E5%AE%9A%E4%B9%89ConfirmCallback">1.1.3.定义ConfirmCallback</h4> 
<p>ConfirmCallback可以在发送消息时指定，因为每个业务处理confirm成功或失败的逻辑不一定相同。</p> 
<p>在publisher服务的cn.itcast.mq.spring.SpringAmqpTest类中，定义一个单元测试方法：</p> 
<pre><code class="language-java">public void testSendMessage2SimpleQueue() throws InterruptedException {
    // 1.消息体
    String message = "hello, spring amqp!";
    // 2.全局唯一的消息ID，需要封装到CorrelationData中
    CorrelationData correlationData = new CorrelationData(UUID.randomUUID().toString());
    // 3.添加callback
    correlationData.getFuture().addCallback(
        result -&gt; {
            if(result.isAck()){
                // 3.1.ack，消息成功
                log.debug("消息发送成功, ID:{}", correlationData.getId());
            }else{
                // 3.2.nack，消息失败
                log.error("消息发送失败, ID:{}, 原因{}",correlationData.getId(), result.getReason());
            }
        },
        ex -&gt; log.error("消息发送异常, ID:{}, 原因{}",correlationData.getId(),ex.getMessage())
    );
    // 4.发送消息
    rabbitTemplate.convertAndSend("task.direct", "task", message, correlationData);

    // 休眠一会儿，等待ack回执
    Thread.sleep(2000);
}
</code></pre> 
<h3 id="1.2.%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96">1.2.消息持久化</h3> 
<p>生产者确认可以确保消息投递到RabbitMQ的队列中，但是消息发送到RabbitMQ以后，如果突然宕机，也可能导致消息丢失。</p> 
<p>要想确保消息在RabbitMQ中安全保存，必须开启消息持久化机制。</p> 
<ul><li><strong>交换机持久化</strong></li><li><strong>队列持久化</strong></li><li><strong>消息持久化</strong></li></ul> 
<h4 id="1.2.1.%E4%BA%A4%E6%8D%A2%E6%9C%BA%E6%8C%81%E4%B9%85%E5%8C%96">1.2.1.交换机持久化</h4> 
<p>RabbitMQ中交换机默认是非持久化的，mq重启后就丢失。</p> 
<p>SpringAMQP中可以通过代码指定交换机持久化：</p> 
<pre><code class="language-java">@Bean
public DirectExchange simpleExchange(){
    // 三个参数：交换机名称、是否持久化、当没有queue与其绑定时是否自动删除
    return new DirectExchange("simple.direct", true, false);
}
</code></pre> 
<p>事实上，默认情况下，由SpringAMQP声明的交换机都是持久化的。</p> 
<h4 id="1.2.2.%E9%98%9F%E5%88%97%E6%8C%81%E4%B9%85%E5%8C%96">1.2.2.队列持久化</h4> 
<p>RabbitMQ中队列默认是非持久化的，mq重启后就丢失。</p> 
<p>SpringAMQP中可以通过代码指定交换机持久化：</p> 
<pre><code class="language-java">@Bean
public Queue simpleQueue(){
    // 使用QueueBuilder构建队列，durable就是持久化的
    return QueueBuilder.durable("simple.queue").build();
}
</code></pre> 
<p>事实上，默认情况下，由SpringAMQP声明的队列都是持久化的。</p> 
<p></p> 
<h4 id="1.2.3.%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96">1.2.3.消息持久化</h4> 
<p>利用SpringAMQP发送消息时，可以设置消息的属性（MessageProperties），指定delivery-mode：</p> 
<ul><li>1：非持久化</li><li>2：持久化</li></ul> 
<p>用java代码指定：</p> 
<p></p> 
<p></p> 
<p>默认情况下，SpringAMQP发出的任何消息都是持久化的，不用特意指定。</p> 
<h3 id="1.3.%E6%B6%88%E8%B4%B9%E8%80%85%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4">1.3.消费者消息确认</h3> 
<p>RabbitMQ是<strong>阅后即焚</strong>机制，RabbitMQ确认消息被消费者消费后会立刻删除。</p> 
<p>而RabbitMQ是通过消费者回执来确认消费者是否成功处理消息的：消费者获取消息后，应该向RabbitMQ发送ACK回执，表明自己已经处理消息。</p> 
<p>设想这样的场景：</p> 
<ul><li><strong>1）RabbitMQ投递消息给消费者</strong></li><li><strong>2）消费者获取消息后，返回ACK给RabbitMQ</strong></li><li><strong>3）RabbitMQ删除消息</strong></li><li><strong>4）消费者宕机，消息尚未处理</strong></li></ul> 
<p>这样，消息就丢失了。因此消费者返回ACK的时机非常重要。</p> 
<p>而SpringAMQP则允许配置三种确认模式：</p> 
<p><strong>•manual：手动ack，需要在业务代码结束后，调用api发送ack。</strong></p> 
<p><strong>•auto：自动ack，由spring监测listener代码是否出现异常，没有异常则返回ack；抛出异常则返回nack</strong></p> 
<p><strong>•none：关闭ack，MQ假定消费者获取消息后会成功处理，因此消息投递后立即被删除</strong></p> 
<p>由此可知：</p> 
<ul><li><strong>none模式下，消息投递是不可靠的，可能丢失</strong></li><li><strong>auto模式类似事务机制，出现异常时返回nack，消息回滚到mq；没有异常，返回ack</strong></li><li><strong>manual：自己根据业务情况，判断什么时候该ack</strong></li></ul> 
<p>一般，我们都是使用默认的auto即可。</p> 
<p></p> 
<h4 id="1.3.1.%E6%BC%94%E7%A4%BAnone%E6%A8%A1%E5%BC%8F">1.3.1.演示none模式</h4> 
<p>修改consumer服务的application.yml文件，添加下面内容：</p> 
<pre><code>spring:
  rabbitmq:
    listener:
      simple:
        acknowledge-mode: none # 关闭ack
</code></pre> 
<p>修改consumer服务的SpringRabbitListener类中的方法，模拟一个消息处理异常：</p> 
<pre><code class="language-java">@RabbitListener(queues = "simple.queue")
public void listenSimpleQueue(String msg) {
    log.info("消费者接收到simple.queue的消息：【{}】", msg);
    // 模拟异常
    System.out.println(1 / 0);
    log.debug("消息处理完成！");
}
</code></pre> 
<p>测试可以发现，当消息处理抛异常时，消息依然被RabbitMQ删除了。</p> 
<p></p> 
<h4 id="1.3.2.%E6%BC%94%E7%A4%BAauto%E6%A8%A1%E5%BC%8F">1.3.2.演示auto模式</h4> 
<p>再次把确认机制修改为auto:</p> 
<pre><code>spring:
  rabbitmq:
    listener:
      simple:
        acknowledge-mode: auto # 关闭ack
</code></pre> 
<p>在异常位置打断点，再次发送消息，程序卡在断点时，可以发现此时消息状态为unack（未确定状态）：</p> 
<p><img alt="" height="212" src="https://images2.imgbox.com/da/18/4v8fZ0re_o.png" width="1200"></p> 
<p> </p> 
<p></p> 
<p>抛出异常后，因为Spring会自动返回nack，所以消息恢复至Ready状态，并且没有被RabbitMQ删除：</p> 
<p><img alt="" height="209" src="https://images2.imgbox.com/22/70/iTqI1ecT_o.png" width="1200"></p> 
<p> </p> 
<p></p> 
<h3 id="1.4.%E6%B6%88%E8%B4%B9%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6">1.4.消费失败重试机制</h3> 
<p>当消费者出现异常后，消息会不断requeue（重入队）到队列，再重新发送给消费者，然后再次异常，再次requeue，无限循环，导致mq的消息处理飙升，带来不必要的压力：</p> 
<p></p> 
<h4 id="1.4.1.%E6%9C%AC%E5%9C%B0%E9%87%8D%E8%AF%95">1.4.1.本地重试</h4> 
<p>我们可以利用Spring的retry机制，在消费者出现异常时利用本地重试，而不是无限制的requeue到mq队列。</p> 
<p>修改consumer服务的application.yml文件，添加内容：</p> 
<pre><code class="language-java">spring:
  rabbitmq:
    listener:
      simple:
        retry:
          enabled: true # 开启消费者失败重试
          initial-interval: 1000 # 初识的失败等待时长为1秒
          multiplier: 1 # 失败的等待时长倍数，下次等待时长 = multiplier * last-interval
          max-attempts: 3 # 最大重试次数
          stateless: true # true无状态；false有状态。如果业务中包含事务，这里改为false
</code></pre> 
<p></p> 
<p>重启consumer服务，重复之前的测试。可以发现：</p> 
<ul><li>在重试3次后，SpringAMQP会抛出异常AmqpRejectAndDontRequeueException，说明本地重试触发了</li><li>查看RabbitMQ控制台，发现消息被删除了，说明最后SpringAMQP返回的是ack，mq删除消息了</li></ul> 
<p></p> 
<p>结论：</p> 
<ul><li>开启本地重试时，消息处理过程中抛出异常，不会requeue到队列，而是在消费者本地重试</li><li>重试达到最大次数后，Spring会返回ack，消息会被丢弃</li></ul> 
<p></p> 
<h4 id="1.4.2.%E5%A4%B1%E8%B4%A5%E7%AD%96%E7%95%A5">1.4.2.失败策略</h4> 
<p>在之前的测试中，达到最大重试次数后，消息会被丢弃，这是由Spring内部机制决定的。</p> 
<p>在开启重试模式后，重试次数耗尽，如果消息依然失败，则需要有MessageRecovery接口来处理，它包含三种不同的实现：</p> 
<ul><li><strong>RejectAndDontRequeueRecoverer：重试耗尽后，直接reject，丢弃消息。默认就是这种方式</strong></li><li><strong>ImmediateRequeueMessageRecoverer：重试耗尽后，返回nack，消息重新入队</strong></li><li><strong>RepublishMessageRecoverer：重试耗尽后，将失败消息投递到指定的交换机</strong></li></ul> 
<p></p> 
<p>比较优雅的一种处理方案是RepublishMessageRecoverer，失败后将消息投递到一个指定的，专门存放异常消息的队列，后续由人工集中处理。</p> 
<p></p> 
<p>1）在consumer服务中定义处理失败消息的交换机和队列</p> 
<pre><code class="language-java">@Bean
public DirectExchange errorMessageExchange(){
    return new DirectExchange("error.direct");
}
@Bean
public Queue errorQueue(){
    return new Queue("error.queue", true);
}
@Bean
public Binding errorBinding(Queue errorQueue, DirectExchange errorMessageExchange){
    return BindingBuilder.bind(errorQueue).to(errorMessageExchange).with("error");
}
</code></pre> 
<p></p> 
<p>2）定义一个RepublishMessageRecoverer，关联队列和交换机</p> 
<pre><code class="language-java">@Bean
public MessageRecoverer republishMessageRecoverer(RabbitTemplate rabbitTemplate){
    return new RepublishMessageRecoverer(rabbitTemplate, "error.direct", "error");
}
</code></pre> 
<p></p> 
<p>完整代码：</p> 
<pre><code class="language-java">package cn.itcast.mq.config;

import org.springframework.amqp.core.Binding;
import org.springframework.amqp.core.BindingBuilder;
import org.springframework.amqp.core.DirectExchange;
import org.springframework.amqp.core.Queue;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.amqp.rabbit.retry.MessageRecoverer;
import org.springframework.amqp.rabbit.retry.RepublishMessageRecoverer;
import org.springframework.context.annotation.Bean;

@Configuration
public class ErrorMessageConfig {
    @Bean
    public DirectExchange errorMessageExchange(){
        return new DirectExchange("error.direct");
    }
    @Bean
    public Queue errorQueue(){
        return new Queue("error.queue", true);
    }
    @Bean
    public Binding errorBinding(Queue errorQueue, DirectExchange errorMessageExchange){
        return BindingBuilder.bind(errorQueue).to(errorMessageExchange).with("error");
    }

    @Bean
    public MessageRecoverer republishMessageRecoverer(RabbitTemplate rabbitTemplate){
        return new RepublishMessageRecoverer(rabbitTemplate, "error.direct", "error");
    }
}
</code></pre> 
<p></p> 
<p></p> 
<h3 id="1.5.%E6%80%BB%E7%BB%93">1.5.总结</h3> 
<p>如何确保RabbitMQ消息的可靠性？</p> 
<ul><li><strong>开启生产者确认机制，确保生产者的消息能到达队列</strong></li><li><strong>开启持久化功能，确保消息未消费前在队列中不会丢失</strong></li><li><strong>开启消费者确认机制为auto，由spring确认消息处理成功后完成ack</strong></li><li><strong>开启消费者失败重试机制，并设置MessageRecoverer，多次重试失败后将消息投递到异常交换机，交由人工处理</strong></li></ul> 
<p>原文来源:黑马springcloud笔记</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/097ecb4a93a75d58b90b9237bdb346f4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LVM管理，扩容和挂载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cfe8c14b4fff9a901c682c2efd9f3fde/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python-can库基于PCAN-USB使用方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>