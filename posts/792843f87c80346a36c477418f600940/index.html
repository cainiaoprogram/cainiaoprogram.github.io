<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis 核心技术与实战-实践篇读书笔记 20～终结 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis 核心技术与实战-实践篇读书笔记 20～终结" />
<meta property="og:description" content="文章目录 20 | 删除数据后，为什么内存占用率还是很高？如何判断是否有内存碎片？如何清理内存碎片呐？ 21 | 缓冲区：一个可能引发“惨案”的地方（暂略）23 | 旁路缓存：Redis 是如何工作的？只读缓存与读写缓存 24 | 替换策略：缓存满了怎么办？（即内存淘汰策略）如何处理被淘汰的数据？ 25 | 缓存异常（上）：如何解决缓存和数据库的数据不一致问题？只读缓存不一致的几种情况及解决方法 读写缓存同步直写时不一致的几种情况及解决方法 如何解决数据不一致问题？先操作 缓存，后操作 数据库解决：缓存延时双删 先操作 数据库，后操作 缓存 总结 26 | 缓存异常（下）：如何解决缓存雪崩、击穿、穿透难题？27 | 缓存被污染了，该怎么办？29 | 无锁的原子操作：Redis如何应对并发访问？如何解决？（两种方式） 30 | 如何使用Redis实现分布式锁？基于单个 Redis 节点实现分布式锁使用 SETNX 和 DEL 时存在的两个风险 基于多个 Redis 节点实现高可靠的分布式锁 31 | 事务机制：Redis能实现ACID属性吗？（暂略）32 | Redis主从同步与故障切换，有哪些坑？（暂略）33 | 脑裂：一次奇怪的数据丢失如何解决？ 36 | Redis 支撑秒杀场景的关键技术和实践都有哪些？37 | 数据分布优化：如何应对数据倾斜？数据量倾斜的成因和应对方法数据访问倾斜的成因和应对方法 39 | Redis 6.0的新特性：多线程、客户端缓存与安全 20 | 删除数据后，为什么内存占用率还是很高？ 主要原因：内存碎片引起的
内存碎片的产生主要是：（1）分配机制 （2）键值对大小不一样和删改操作
如何判断是否有内存碎片？ 看 INFO memory 命令中的 mem_fragmentation_ratio Redis 当前的内存碎片率指标。 mem_fragmentation_ratio 大于 1 但小于 1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/792843f87c80346a36c477418f600940/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-09T22:33:38+08:00" />
<meta property="article:modified_time" content="2022-06-09T22:33:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis 核心技术与实战-实践篇读书笔记 20～终结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#20___1" rel="nofollow">20 | 删除数据后，为什么内存占用率还是很高？</a></li><li><ul><li><a href="#_5" rel="nofollow">如何判断是否有内存碎片？</a></li><li><a href="#_7" rel="nofollow">如何清理内存碎片呐？</a></li></ul> 
  </li><li><a href="#21___12" rel="nofollow">21 | 缓冲区：一个可能引发“惨案”的地方（暂略）</a></li><li><a href="#23__Redis__13" rel="nofollow">23 | 旁路缓存：Redis 是如何工作的？</a></li><li><ul><li><a href="#_14" rel="nofollow">只读缓存与读写缓存</a></li></ul> 
  </li><li><a href="#24___18" rel="nofollow">24 | 替换策略：缓存满了怎么办？（即内存淘汰策略）</a></li><li><ul><li><a href="#_24" rel="nofollow">如何处理被淘汰的数据？</a></li></ul> 
  </li><li><a href="#25___26" rel="nofollow">25 | 缓存异常（上）：如何解决缓存和数据库的数据不一致问题？</a></li><li><ul><li><a href="#_27" rel="nofollow">只读缓存</a></li><li><ul><li><a href="#_28" rel="nofollow">不一致的几种情况及解决方法</a></li></ul> 
   </li><li><a href="#_34" rel="nofollow">读写缓存</a></li><li><ul><li><a href="#_35" rel="nofollow">同步直写时不一致的几种情况及解决方法</a></li></ul> 
   </li><li><a href="#_37" rel="nofollow">如何解决数据不一致问题？</a></li><li><ul><li><a href="#___41" rel="nofollow">先操作 缓存，后操作 数据库</a></li><li><ul><li><a href="#_44" rel="nofollow">解决：缓存延时双删</a></li></ul> 
    </li><li><a href="#___46" rel="nofollow">先操作 数据库，后操作 缓存</a></li></ul> 
   </li><li><a href="#_49" rel="nofollow">总结</a></li></ul> 
  </li><li><a href="#26___51" rel="nofollow">26 | 缓存异常（下）：如何解决缓存雪崩、击穿、穿透难题？</a></li><li><a href="#27___53" rel="nofollow">27 | 缓存被污染了，该怎么办？</a></li><li><a href="#29__Redis_54" rel="nofollow">29 | 无锁的原子操作：Redis如何应对并发访问？</a></li><li><ul><li><a href="#_62" rel="nofollow">如何解决？（两种方式）</a></li></ul> 
  </li><li><a href="#30__Redis_65" rel="nofollow">30 | 如何使用Redis实现分布式锁？</a></li><li><ul><li><a href="#_Redis__66" rel="nofollow">基于单个 Redis 节点实现分布式锁</a></li><li><ul><li><ul><li><a href="#_SETNX__DEL__82" rel="nofollow">使用 SETNX 和 DEL 时存在的两个风险</a></li></ul> 
   </li></ul> 
   </li><li><a href="#_Redis__117" rel="nofollow">基于多个 Redis 节点实现高可靠的分布式锁</a></li></ul> 
  </li><li><a href="#31__RedisACID_128" rel="nofollow">31 | 事务机制：Redis能实现ACID属性吗？（暂略）</a></li><li><a href="#32__Redis_129" rel="nofollow">32 | Redis主从同步与故障切换，有哪些坑？（暂略）</a></li><li><a href="#33___130" rel="nofollow">33 | 脑裂：一次奇怪的数据丢失</a></li><li><ul><li><a href="#_139" rel="nofollow">如何解决？</a></li></ul> 
  </li><li><a href="#36__Redis__149" rel="nofollow">36 | Redis 支撑秒杀场景的关键技术和实践都有哪些？</a></li><li><a href="#37___156" rel="nofollow">37 | 数据分布优化：如何应对数据倾斜？</a></li><li><ul><li><a href="#_160" rel="nofollow">数据量倾斜的成因和应对方法</a></li><li><a href="#_164" rel="nofollow">数据访问倾斜的成因和应对方法</a></li></ul> 
  </li><li><a href="#39__Redis_60_171" rel="nofollow">39 | Redis 6.0的新特性：多线程、客户端缓存与安全</a></li></ul> 
</div> 
<p></p> 
<h2><a id="20___1"></a>20 | 删除数据后，为什么内存占用率还是很高？</h2> 
<p>主要原因：<strong>内存碎片引起的</strong></p> 
<p>内存碎片的产生主要是：（1）分配机制 （2）键值对大小不一样和删改操作</p> 
<h3><a id="_5"></a>如何判断是否有内存碎片？</h3> 
<p>看 INFO memory 命令中的 <code>mem_fragmentation_ratio</code> Redis 当前的内存碎片率指标。 <strong>mem_fragmentation_ratio 大于 1 但小于 1.5。这种情况是合理的。而大于 1.5 后则认为不是合理的范畴。</strong></p> 
<h3><a id="_7"></a>如何清理内存碎片呐？</h3> 
<p><strong>启动碎片清理即可。</strong><br> <code>config set activedefrag yes</code><br> 这个命令只是启用了自动清理功能，但是，具体什么时候清理，<strong>会受到下面这两个参数的控制</strong>。这两个参数分别设置了触发内存清理的一个条件，<strong>如果同时满足这两个条件，就开始清理。在清理的过程中，只要有一个条件不满足了，就停止自动清理。</strong><br> <img src="https://images2.imgbox.com/ae/20/3UH8HIm2_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="21___12"></a>21 | 缓冲区：一个可能引发“惨案”的地方（暂略）</h2> 
<h2><a id="23__Redis__13"></a>23 | 旁路缓存：Redis 是如何工作的？</h2> 
<h3><a id="_14"></a>只读缓存与读写缓存</h3> 
<ul><li>只读缓存：缓存只处理读，<strong>所有的写请求，会直接发往后端的数据库</strong>，在数据库中增删改。对于删改的数据来说，如果 Redis 已经缓存了相应的数据，应用 <strong>需要把这些缓存的数据删除</strong> ，Redis 中就没有这些数据了。当应用<strong>再次读取这些数据时，会发生缓存缺失，应用会把这些数据从数据库中读出来，并写到缓存中</strong>。这样一来，这些数据后续再被读取时，就可以直接从缓存中获取了，能起到加速访问的效果。</li><li>读写缓存：<strong>缓存会被写</strong>。写的策略有两种，如图：<br> <img src="https://images2.imgbox.com/1d/b5/1OoU6LRu_o.png" alt="在这里插入图片描述"></li></ul> 
<h2><a id="24___18"></a>24 | 替换策略：缓存满了怎么办？（即内存淘汰策略）</h2> 
<p><img src="https://images2.imgbox.com/1c/d4/j6jcI1NM_o.png" alt="在这里插入图片描述"><br> 具体在使用上有什么经验呐？</p> 
<ol><li><strong>优先使用 allkeys-lru 策略</strong>。这样，可以充分利用 LRU 这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。如果你的业务数据中有明显的冷热数据区分，我建议你使用 allkeys-lru 策略。</li><li>如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用 allkeys-random 策略，随机选择淘汰的数据就行。</li><li><strong>如果你的业务中有置顶的需求</strong>，比如置顶新闻、置顶视频，那么，可以使用 volatile-lru 策略，同时不给这些置顶数据设置过期时间。这样一来，这些需要置顶的数据一直不会被删除，而其他数据会在过期时根据 LRU 规则进行筛选。</li></ol> 
<h3><a id="_24"></a>如何处理被淘汰的数据？</h3> 
<blockquote> 
 <p>一旦被淘汰的数据选定后，如果这个数据是没被修改过数据，那么我们就直接删除；如果这个数据被修改过，我们需要把它写回数据库。</p> 
</blockquote> 
<h2><a id="25___26"></a>25 | 缓存异常（上）：如何解决缓存和数据库的数据不一致问题？</h2> 
<h3><a id="_27"></a>只读缓存</h3> 
<h4><a id="_28"></a>不一致的几种情况及解决方法</h4> 
<p>首先回忆下只读缓存的处理流程：</p> 
<ol><li><strong>增删改</strong> 请求先到达数据库进行处理</li><li>针对 <strong>删改</strong> 操作需要单独删除缓存中已缓存的数据</li></ol> 
<p>针对上述情况还是会出现 两者操作上的不一致性，那么就还是<code>需要保证同时更新缓存和数据库。</code></p> 
<h3><a id="_34"></a>读写缓存</h3> 
<h4><a id="_35"></a>同步直写时不一致的几种情况及解决方法</h4> 
<ol><li><code>同步直写需要保证同时更新缓存和数据库</code>。所以，我们要在业务应用中使用事务机制，来<code>保证缓存和数据库的更新具有原子性</code>，也就是说，两者要不一起更新，要不都不更新，返回错误信息，进行重试。否则，我们就无法实现同步直写。</li></ol> 
<h3><a id="_37"></a>如何解决数据不一致问题？</h3> 
<blockquote> 
 <p>因为是 保证同时更新缓存和数据库。所以总的排列组合只有两种。<br> （1）先 操作 缓存 ， 后操作 数据库<br> （2）先 操作 数据库 ，后操作 缓存</p> 
</blockquote> 
<h4><a id="___41"></a>先操作 缓存，后操作 数据库</h4> 
<p>可能会出现的异常情况是：<br> <img src="https://images2.imgbox.com/79/dd/eALQxXRu_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="_44"></a>解决：缓存延时双删</h5> 
<blockquote> 
 <p>在线程 A 更新完数据库值以后，我们可以让它先 sleep 一小段时间，再进行一次缓存删除操作。</p> 
</blockquote> 
<h4><a id="___46"></a>先操作 数据库，后操作 缓存</h4> 
<p><img src="https://images2.imgbox.com/4e/f1/oHZ8EE2h_o.png" alt="在这里插入图片描述"><br> 此类问题，一般影响不大，可以忽略~，后续工作中遇到了再说。</p> 
<h3><a id="_49"></a>总结</h3> 
<p><img src="https://images2.imgbox.com/bf/de/dn9Zvxfv_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="26___51"></a>26 | 缓存异常（下）：如何解决缓存雪崩、击穿、穿透难题？</h2> 
<p><img src="https://images2.imgbox.com/2a/09/4GppqxZo_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="27___53"></a>27 | 缓存被污染了，该怎么办？</h2> 
<h2><a id="29__Redis_54"></a>29 | 无锁的原子操作：Redis如何应对并发访问？</h2> 
<p>客户端对数据的修改操作步骤主要有：</p> 
<ol><li>客户端先把数据读取到本地</li><li>在本地进行修改；</li><li>再写回 Redis</li></ol> 
<p>把这个流程叫做“<strong>读取 - 修改 - 写回</strong>”操作（Read-Modify-Write，简称为 <strong>RMW</strong> 操作）。当有多个客户端对同一份数据执行 RMW 操作的话，我们就需要让 RMW 操作涉及的代码以原子性方式执行。<strong>访问同一份数据</strong>的 RMW 操作代码，就叫做临界区代码。</p> 
<h3><a id="_62"></a>如何解决？（两种方式）</h3> 
<ul><li>原子操作命令 <strong>INCR 和 DECR</strong></li><li><strong>Lua 脚本</strong></li></ul> 
<h2><a id="30__Redis_65"></a>30 | 如何使用Redis实现分布式锁？</h2> 
<h3><a id="_Redis__66"></a>基于单个 Redis 节点实现分布式锁</h3> 
<p>其实就是在 Redis 中保存一个 key:value 就行了。</p> 
<p><strong>加锁包含了三个操作</strong>（<code>读取锁变量、判断锁变量值以及把锁变量值设置为 1</code>），而这三个操作在执行时需要保证原子性。那怎么保证原子性呢？</p> 
<p>原子性有两种实现方式：</p> 
<ul><li>单命令实现</li><li>使用 Lua 脚本</li></ul> 
<p>在这里可以直接使用 <strong><code>SETNX 和 DEL 命令组合来实现加锁和释放锁操作</code></strong></p> 
<ul><li>SETNX：在执行时会<strong>判断键值对是否存在，如果不存在，就设置键值对的值，如果存在，就不做任何设置。</strong></li><li>DEL：删除锁变量</li></ul> 
<p>那么这样做会存在什么问题呐？</p> 
<h5><a id="_SETNX__DEL__82"></a>使用 SETNX 和 DEL 时存在的两个风险</h5> 
<ol><li>假如某个客户端在执行了 SETNX 命令、加锁之后，紧接着却在操作共享数据时发生了异常，结果<strong>一直没有执行最后的 DEL 命令释放锁</strong>。因此，锁就一直被这个客户端持有，其它客户端无法拿到锁，也无法访问共享数据和执行后续操作，这会给业务应用带来影响。</li></ol> 
<p>针对这个问题，一个有效的解决方法是，<strong>给锁变量设置一个过期时间</strong>。这样一来，即使持有锁的客户端发生了异常，无法主动地释放锁，Redis 也会根据锁变量的过期时间，在锁变量过期后，把它删除。其它客户端在锁变量过期后，就可以重新请求加锁，这就不会出现无法加锁的问题了。</p> 
<ol start="2"><li><strong>假设客户端 A 执行完 SETNX 命令成功加锁，并且给锁设置了超时时间 10s，然后开始执行业务逻辑，但是由于其他原因导致执行业务逻辑时间超出了 10s ，锁自动释放了，注意客户端 A 的业务逻辑仍然在执行中，此时客户端 B 成功加锁并且设置锁超时时间，而后开始执行业务逻辑，但是在客户端 B 执行业务逻辑期间，客户端 A 执行完毕，然后开始调用 DEL 指令释放锁，这就有可能导致将客户端 B 加的锁释放掉</strong>。</li></ol> 
<p>本质上来讲，其实就是<strong>要能区分来自不同客户端的锁操作</strong>。</p> 
<p>SETNX 命令，对于不存在的键值对，它会先创建再设置值（也就是“不存在即设置”），为了能达到和 SETNX 命令一样的效果，<strong>Redis 给 SET 命令提供了类似的选项 NX，用来实现“不存在即设置”</strong>。如果使用了 NX 选项，SET 命令只有在键值对不存在时，才会进行设置，否则不做赋值操作。此外，SET 命令在执行时还可以带上 EX 或 PX 选项，用来设置键值对的过期时间。</p> 
<p>举个例子，执行下面的命令时，只有 key 不存在时，SET 才会创建 key，并对 key 进行赋值。另外，<strong>key 的存活时间由 seconds 或者 milliseconds 选项值来决定。</strong></p> 
<p><code>SET key value [EX seconds | PX milliseconds] [NX]</code></p> 
<p>因此，加锁操作可以：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// 加锁, unique_value作为客户端唯一性的标识</span>
SET lock_key unique_value NX PX <span class="token number">10000</span>
</code></pre> 
<p>解锁操作可以：</p> 
<pre><code class="prism language-cpp"><span class="token comment">// KEYS[1]表示 lock_key，ARGV[1]是当前客户端的唯一标识，</span>
<span class="token comment">// 这两个值都是我们在执行 Lua 脚本时作为参数传入的。</span>

<span class="token comment">//释放锁 比较 unique_value 是否相等，避免误释放</span>
<span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> then
    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"del"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">else</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
end
</code></pre> 
<p>因为，释放锁操作的逻辑也包含了读取锁变量、判断值、删除锁变量的多个操作。所以需要使用 Lua 脚本（unlock.script）实现的释放锁操作的伪代码。<br> <code>redis-cli --eval unlock.script lock_key , unique_value </code></p> 
<h3><a id="_Redis__117"></a>基于多个 Redis 节点实现高可靠的分布式锁</h3> 
<p>为了避免 Redis 实例故障而导致的锁无法工作的问题，Redis 的开发者 Antirez 提出了分布式锁算法 <strong>Redlock</strong>。</p> 
<p>Redlock 算法的基本思路，是让客户端和多个独立的 Redis 实例依次请求加锁，<strong>如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁了，否则加锁失败</strong>。这样一来，即使有单个 Redis 实例发生故障，因为锁变量在其它实例上也有保存，所以，客户端仍然可以正常地进行锁操作，锁变量并不会丢失。</p> 
<p>分为三步：</p> 
<ol><li>客户端获取当前时间。</li><li>客户端按顺序依次向 N 个 Redis 实例执行加锁操作。</li><li>一旦客户端完成了和所有 Redis 实例的加锁操作，客户端就要计算整个加锁过程的总耗时。<br> <img src="https://images2.imgbox.com/3d/4a/ADB85aqk_o.png" alt="在这里插入图片描述"></li></ol> 
<h2><a id="31__RedisACID_128"></a>31 | 事务机制：Redis能实现ACID属性吗？（暂略）</h2> 
<h2><a id="32__Redis_129"></a>32 | Redis主从同步与故障切换，有哪些坑？（暂略）</h2> 
<h2><a id="33___130"></a>33 | 脑裂：一次奇怪的数据丢失</h2> 
<p><strong>所谓的脑裂，就是指在主从集群中，同时有两个主节点，它们都能接收写请求</strong>。而脑裂最直接的影响，就是客户端不知道应该往哪个主节点写入数据，结果就是不同的客户端会往不同的主节点上写入数据。而且，严重的话，脑裂会进一步导致数据丢失。<br> <img src="https://images2.imgbox.com/10/c6/xiQQQqTO_o.png" alt="在这里插入图片描述"><br> 那么为什么脑裂会导致数据丢失呐？</p> 
<p>主从切换后，从库一旦升级为新主库，哨兵就会让原主库执行 slave of 命令，和新主库重新进行全量同步。而在 <strong>全量同步</strong> 执行的最后阶段，<strong>原主库需要清空本地的数据，加载新主库发送的 RDB 文件</strong>，这样一来，原主库在主从切换期间保存的新写数据就丢失了。</p> 
<p><strong>所以原主库会丢失切换期间保存的数据！</strong></p> 
<h3><a id="_139"></a>如何解决？</h3> 
<p>既然问题是出在原主库发生假故障后仍然能接收请求上，我们就开始在主从集群机制的配置项中查找是否有限制主库接收请求的设置。</p> 
<p>通过查找，我们发现，Redis 已经提供了两个配置项来限制主库的请求处理，分别是 min-slaves-to-write 和 min-slaves-max-lag。</p> 
<ul><li><strong>min-slaves-to-write：这个配置项设置了主库能进行数据同步的最少从库数量</strong>；</li><li><strong>min-slaves-max-lag：这个配置项设置了主从库间进行数据复制时，从库给主库发送 ACK 消息的最大延迟（以秒为单位）</strong>。<br> <img src="https://images2.imgbox.com/fa/02/6bcZGvQs_o.png" alt="在这里插入图片描述"></li></ul> 
<p><strong>设置的建议</strong>：假设从库有 K 个，可以将 min-slaves-to-write 设置为 K/2+1（如果 K 等于 1，就设为 1），将 min-slaves-max-lag 设置为十几秒（例如 10～20s），在这个配置下，如果有一半以上的从库和主库进行的 ACK 消息延迟超过十几秒，我们就禁止主库接收客户端写请求。</p> 
<h2><a id="36__Redis__149"></a>36 | Redis 支撑秒杀场景的关键技术和实践都有哪些？</h2> 
<ul><li>秒杀前：用户会<strong>不断刷新商品详情页</strong>。把商品详情页的页面元素静态化，然后使用 <strong>CDN 或是浏览器</strong>把这些静态化的元素缓存起来。</li><li>秒杀中：用户点击商品详情页上的秒杀按钮，所以具体的操作就是：<strong>库存查验、库存扣减和订单处理</strong>，这个时候的压力全都在 <strong>库存查验</strong> 操作上，因此这里就 <strong>需要 Redis 来提升性能</strong>。</li></ul> 
<p>订单处理可以在数据库中执行，但<strong>库存扣减</strong>操作，不能交给后端数据库处理。当库存查验完成后，一旦库存有余量，我们就立即在 Redis 中扣减库存。而且，为了避免请求查询到旧的库存值，<strong>库存查验和库存扣减这两个操作需要保证原子性</strong>。</p> 
<ul><li>秒杀后：在这个阶段，可能还会有部分用户刷新商品详情页，尝试等待有其他用户退单。而已经成功下单的用户会刷新订单详情，跟踪订单的进展。不过，这个阶段中的用户请求量已经下降很多了，服务器端一般都能支撑，直接忽略即可。</li></ul> 
<h2><a id="37___156"></a>37 | 数据分布优化：如何应对数据倾斜？</h2> 
<p>数据倾斜有两类。</p> 
<ul><li><strong>数据量倾斜</strong>：在某些情况下，实例上的数据分布不均衡，某个实例上的数据特别多。</li><li><strong>数据访问倾斜</strong>：虽然每个集群实例上的数据量相差不大，但是某个实例上的数据是热点数据，被访问得非常频繁。</li></ul> 
<h3><a id="_160"></a>数据量倾斜的成因和应对方法</h3> 
<ol><li><strong>bigkey 导致倾斜</strong>：我们在业务层生成数据时，要<strong>尽量避免把过多的数据保存在同一个键值对中</strong>。此外，如果 bigkey 正好是集合类型，我们还有一个方法，就是把 bigkey 拆分成很多个小的集合类型数据，分散保存在不同的实例上。</li><li>Slot 分配不均衡导致倾斜：迁移 slot</li><li>Hash Tag 导致倾斜：（@TODO 暂时忽略）</li></ol> 
<h3><a id="_164"></a>数据访问倾斜的成因和应对方法</h3> 
<ul><li>通常来说，热点数据以服务读操作为主，在这种情况下，我们可以采用<strong>热点数据多副本</strong>的方法来应对。</li></ul> 
<blockquote> 
 <p>这个方法的具体做法是，我们把热点数据复制多份，在每一个数据副本的 key 中增加一个随机前缀，让它和其它副本数据不会被映射到同一个 Slot 中。这样一来，热点数据既有多个副本可以同时服务请求，同时，这些副本数据的 key 又不一样，会被映射到不同的 Slot 中。在给这些 Slot 分配实例时，我们也要注意把它们分配到不同的实例上，那么，热点数据的访问压力就被分散到不同的实例上了。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/7a/ec/CV1grVuM_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="39__Redis_60_171"></a>39 | Redis 6.0的新特性：多线程、客户端缓存与安全</h2> 
<p><img src="https://images2.imgbox.com/dd/4b/z7qGCPS9_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4b1b06ad4cc1bdf6104bdeeb56fb7c5c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CC2530实现ADC采集电池电压并通过串口发送</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d52971b06dafbd4aa2e8777a6da0f377/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">对DT的理解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>