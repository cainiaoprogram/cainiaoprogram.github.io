<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>现代 CSS 你知道多少 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="现代 CSS 你知道多少" />
<meta property="og:description" content="写在前面 现代 CSS （Modern CSS）应该是 2023 年前端圈热门话题之一，在最近的 CSS Day 活动上也有这个话题。另外在社区中也不乏现代 CSS 的讨论以及如何使用现代 CSS 特性来编写和组织 CSS 代码，以及如何使用现代 CSS 技术更好的构建出可扩展，未来更友好的 Web 项目。
我在还没有完成《现代 Web 布局》和 《防御式 CSS》小册的时候，就已经准备编写一本有关于 CSS 最新特性方面的小册，我将其命名为《现代 CSS》。
《现代 Web 布局》：可用于 Web 布局的 CSS 特性，比如 Flexbox，Grid，多语言布局等；
《防御式 CSS》：Web 开发者应该具有“万一”的思想准备，在编写代码的时候就需要考虑其所存在的“风险”，使自己编写出来的代码更健壮
《现代 CSS》：CSS 中最新的 CSS 特性理论与实践
开始我们今天的话题，接下来的内容篇幅较长，大约有 10000 字的阅读量！
无论以何种标准衡量，在过去的几年里，CSS 都有很大的进步。它有了更多有用的新特性和改进，其中许多最新的特性都是我们渴望已久的。比如，CSS :has() 选择器、CSS 逻辑属性和逻辑值、视窗动态单位、容器查询单位、容器查询、级联层、相对颜色、混合颜色、CSS 作用域、CSS 嵌套、三角函数、滚动驱动动画、视图过渡和瀑布流布局等。
那么，在项目开发的过程中，我们可以使用现代 CSS 哪些特性？或者说，这些新特性将给我们的 Web 开发带来哪些变化？欲知答案，请继续往下阅读。
现代 CSS 选择器：关系型选择器 虽然 CSS 中已经有很多种不同类型的选择器存在了，但现有的选择器总是不能满足 Web 开发者的需求，例如 Web 开发者也一直期望有一个父选择器，使 Web 开发者能通过子元素选择到父元素。而这一期望，也是随着 CSS 的 :has() 选择器的到来才使得 CSS 中有了所谓的“父选择器”。与此同时，现代 CSS 还新增了不少新的 CSS 选择器，例如 :is() 、:where() 、:not() 、:focus-visible 、:focus-within 、:modal 和 :target 等。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2578f4b740551a7f8a1cfd89c67746e8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-09T17:01:04+08:00" />
<meta property="article:modified_time" content="2023-08-09T17:01:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">现代 CSS 你知道多少</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <h3>写在前面</h3> 
 <p>现代 CSS （Modern CSS）应该是 2023 年前端圈热门话题之一，在最近的 CSS Day 活动上也有这个话题。另外在社区中也不乏现代 CSS 的讨论以及如何使用现代 CSS 特性来编写和组织 CSS 代码，以及如何使用现代 CSS 技术更好的构建出可扩展，未来更友好的 Web 项目。</p> 
 <p>我在还没有完成《现代 Web 布局》和 《防御式 CSS》小册的时候，就已经准备编写一本有关于 CSS 最新特性方面的小册，我将其命名为《现代 CSS》。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/52/8a/ATbQdH51_o.jpg" alt="761f533ee79fb547ab894fd6939b43cf.jpeg"></p> 
 <ul><li><p>《现代 Web 布局》：可用于 Web 布局的 CSS 特性，比如 Flexbox，Grid，多语言布局等；</p></li><li><p>《防御式 CSS》：Web 开发者应该具有“万一”的思想准备，在编写代码的时候就需要考虑其所存在的“风险”，使自己编写出来的代码更健壮</p></li><li><p>《现代 CSS》：CSS 中最新的 CSS 特性理论与实践</p></li></ul> 
 <blockquote> 
  <p><strong>开始我们今天的话题，接下来的内容篇幅较长，大约有 10000 字的阅读量！</strong></p> 
 </blockquote> 
 <p>无论以何种标准衡量，在过去的几年里，CSS 都有很大的进步。它有了更多有用的新特性和改进，其中许多最新的特性都是我们渴望已久的。比如，CSS <code>:has()</code> 选择器、CSS 逻辑属性和逻辑值、视窗动态单位、容器查询单位、容器查询、级联层、相对颜色、混合颜色、CSS 作用域、CSS 嵌套、三角函数、滚动驱动动画、视图过渡和瀑布流布局等。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/dc/c0/H4xxbofw_o.jpg" alt="ae42e55e38cbe8d6b9bcde3f47021c24.jpeg"></p> 
 <p>那么，在项目开发的过程中，我们可以使用现代 CSS 哪些特性？或者说，这些新特性将给我们的 Web 开发带来哪些变化？欲知答案，请继续往下阅读。</p> 
 <h3>现代 CSS 选择器：关系型选择器</h3> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/03/e8/M2zqE5AD_o.jpg" alt="17e8100be00dd2b64cc7a4e4f02b0fc6.jpeg"></p> 
 <p>虽然 CSS 中已经有很多种不同类型的选择器存在了，但现有的选择器总是不能满足 Web 开发者的需求，例如 Web 开发者也一直期望有一个父选择器，使 Web 开发者能通过子元素选择到父元素。而这一期望，也是随着 CSS 的 <code>:has()</code> 选择器的到来才使得 CSS 中有了所谓的“父选择器”。与此同时，现代 CSS  还新增了不少新的 CSS 选择器，例如 <code>:is()</code> 、<code>:where()</code> 、<code>:not()</code> 、<code>:focus-visible</code> 、<code>:focus-within</code> 、<code>:modal</code> 和 <code>:target</code> 等。</p> 
 <p>在最新的重置 CSS 样式表中可以看到现代 CSS 选择器的一些身影。比如，我现在在我的重置 CSS 样式表中就会利用现代 CSS 特性，放置一些方便的规则。这些规则的奇妙之处在于，它们也是渐进式增强，并不严格要求回退。如果它们在浏览器中得到支持并被应用，那就太棒了！如果没有，对用户体验没有或只有很小的影响。</p> 
 <p>例如，我为默认链接设置了一个公用的下划线，其作用域为那些没有类的链接。这是一个假设，无类链接旨在保持常规的下划线外观。更新是将下划线设置为使用相对厚度并增加下划线偏移量。视觉效果可能很小，但它可以提高链接易读性，特别是在列表或其他近距离上下文中呈现时。</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">/* 链接默认样式 */</code></code></pre> 
  <pre class="has"><code class="language-go">a:not([class]) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">/* 相对厚度并增加下划线偏移量 */</code></pre> 
  <pre class="has"><code class="language-go">text-decoration-thickness: max(0.08em, 1px);</code></pre> 
  <pre class="has"><code class="language-go">text-underline-offset: 0.15em;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <code>max()</code> 
  函数要求浏览器选择参数列表中较大的那个，这有效地确保了在该规则中，下划线不能比  
 <code>1px</code> 
  细。 
 <p>另一个令人感到兴奋的是，浏览更新了交互元素（可聚焦元素）使用的默认焦点行为的切换：<strong>默认为</strong> <strong><code>:focus-visible</code></strong> 。尽管元素元素如何接收焦点都可以使用 <code>:focus</code> ，但 <code>:focus-visible</code> 仅根据用户输入模式产生可见焦点状态。实际上，这意味着通常鼠标用户不会看到链接或按钮等元素的可见焦点（焦点环样式），但通过键盘的 <code>Tab</code> 键访问这些元素的键盘用户将看到可见焦点样式。也就是说，我们的可见焦点样式将只附加到 <code>:focus-visible</code> 状态：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">:focus-visible {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">--outline-size: max(2px, 0.15em);</code></pre> 
  <pre class="has"><code class="language-go">outline: var(--outline-width, var(--outline-size)) var(--outline-style, solid) var(--outline-color, currentColor);</code></pre> 
  <pre class="has"><code class="language-go">outline-offset: var(--outline-offset, var(--outline-size));</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>在这些规则中，CSS 自定义属性用于设置 <code>outline</code> 属性样式。这允许为我们的应用程序的焦点样式创建一个公共的样式，同时允许 Web 开发者根据需要重写组件。<br></p> 
 <p>你可能也不太熟悉 <code>outline-offset</code> 属性，它定义了元素和轮廓之间的距离。此属性可以使用负值并将其放置在元素中。我经常对按钮组件样式进行这种重写，以确保轮廓与元素保持可访问的对比。</p> 
 <p>在我的重置 CSS 样式表中，我还使用了 <code>:where()</code> 与 <code>:not()</code> 选择器组合在一起：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">*:where(:not(iframe, canvas, img, svg, video):not(svg *, symbol *)) {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">all: unset;</code></pre> 
  <pre class="has"><code class="language-go">display: revert;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>主要使用 CSS 的选择器 <code>:where()</code> 来降低选择器权重的。简单地说，<strong>带有</strong> <strong><code>:where()</code></strong> <strong>选择器，权重都是</strong> <strong><code>0</code></strong> 。与其相反的是，<strong><code>:is()</code></strong> <strong>选择器可以用来增加选择器权重</strong>。</p> 
 <p>另外，规则中的 <code>all</code> 属性允许你一次性重置多个属性，而 <code>unset</code> 值会执行与 <code>initial</code> 或 <code>inherit</code> 相同的操作。换句话说，<code>unset</code> 关键词可以重置可继承和不可继承的属性。</p> 
 <p><code>revert</code> 和 <code>unset</code> 非常像，唯一的区别在于 <code>revert</code> 会把 CSS 属性值重置为 User-agent-stylesheet （浏览器加载的默认 CSS 文件）中对应的值。</p> 
 <p>除此之外，我重置的最后两项内容涉及改善目标或焦点元素的滚动位置。</p> 
 <p>使用 <code>scroll-padding</code> 属性，你可以根据元素调整滚动位置。<code>scroll-padding</code> 不会影响 Web 布局，只影响滚动位置的偏移量。<br></p> 
 <p>在此规则中，当元素是锚点链接（也称为“文档片段”，即 URI）的目标时，将匹配 <code>:target</code> 选择器。<code>scroll-padding-bock-start</code> 将允许目标元素和视窗顶部之间的空间是 <code>2rem</code>：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">:target {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">scroll-padding-block-start: 2rem;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>在下一条规则中使用 <code>scroll-padding-block-end</code> 允许在焦点元素和视窗底部之间留出空间，这有助于跟踪可见焦点位置：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">:focus{<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">scroll-padding-block-end: 8vh;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>可以调整这两个规则的值，使其最适合你的应用程序布局。<br></p> 
 <p><code>:has()</code> 选择器虽然是 Web 开发者最为期待的选择器之一，它的出现除了使得 Web 开发者能更好地选中目标元素之外，在部分场景之下可以替代 JavaScript 脚本，实现可动态交互的组件。拿 <code>:has()</code> 选择器为例，它和表单状态元素的结合，就可以改变按钮状态。</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">form .button {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">--button-color: hsl(0, 0%, 90%);</code></pre> 
  <pre class="has"><code class="language-go">--button-text-color: hsl(0, 0%, 50%);</code></pre> 
  <pre class="has"><code class="language-go">cursor: not-allowed;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">form:has(input[type="email"]:valid):has(input[type="checkbox"]:checked) .button {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">--button-color: var(--color-primary);</code></pre> 
  <pre class="has"><code class="language-go">--button-text-color: rgb(0, 25, 80);</code></pre> 
  <pre class="has"><code class="language-go">cursor: pointer;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">form:has(input[type="email"]):has(input[type="checkbox"]:checked) .button:hover {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">--button-text-color: rgb(0, 25, 80);</code></pre> 
  <pre class="has"><code class="language-go">--button-color: #2eec96e3;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/58/92/L1mH47Bh_o.gif" alt="a7a2439d0d783dfcc33bf179b9302076.gif"></p> 
 <p>但它却还没有得到 Firefox 的支持。如果你现在就要使用 <code>:has()</code> 选择器的话，你就需要一些降级处理。不过，其特性是很优秀的，在未来，它也将会改变我们编写 CSS 的方式，因为基于它所包含的子元素来选择父元素总是一件好事，对吧！</p> 
 <h3>CSS 逻辑属性和逻辑值</h3> 
 <p>众所周知，现在市场上很多 Web 应用或网站都是支持多语的。例如 CNN 新闻网站就是一个典型的案例。我们随意打开网站中的一个页面：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/31/e8/1HKk2Xf4_o.jpg" alt="992e911f3874eb498d40a54c9dde72b0.jpeg"></p> 
 <blockquote> 
  <p>上图截自：https://edition.cnn.com/interactive/2022/10/us/black-women-nonbinary-surfers-cec-cnnphotos/</p> 
 </blockquote> 
 <p>正如你所看到的，在桌面端（大屏幕），使用 CSS 将内容区域限制在中间的某个地方。这也意味着容器水平居中。稍微了解 CSS 的同学都知道，在 CSS 中有很多方法可以做到这一点，但这里有一个常见的方法：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">header {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">max-width: 64rem;</code></pre> 
  <pre class="has"><code class="language-go">margin-left: auto;</code></pre> 
  <pre class="has"><code class="language-go">margin-right: auto;</code></pre> 
  <pre class="has"><code class="language-go">height: 100vh;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>其实，我们还可以用另一个版本做同样的事情，即使用 CSS 中所谓的逻辑属性替换物理属性：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">header {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">max-inline-size: 64rem;</code></pre> 
  <pre class="has"><code class="language-go">margin-inline: auto;</code></pre> 
  <pre class="has"><code class="language-go">block-size: 100dvh;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>最终结果是一样的。其中我们需要明确的一点是：</p> 
 <ul><li><p><code>inline</code> 等于文本流动的方向</p></li><li><p><code>block</code> 等于文本流动的垂直方向</p></li></ul> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/b3/8c/g5GIv090_o.jpg" alt="24f42c4a0c1430cc08dcfda7604f8f80.jpeg"></p> 
 <p>对于所有从左到右的语言（LTR），如英语、西班牙语、法语、德语等，以及从右到左的语言（RTL），如阿拉伯语，关键词 <code>inline</code> 指的是水平轴（即 <code>x</code> 轴），关键词 <code>block</code> 指的是垂直轴（即 <code>y</code> 轴），垂直于 <code>inline</code> 关键词所在轴。</p> 
 <p>我们在这里讨论的是布局，用网站上的矩形来描述，蓝框上的蓝色箭头表示内联方向的布局，红框上的红色箭头表示块方向的布局。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/65/12/PqysrRjh_o.jpg" alt="f1bbc7439fcab4e9e335d632cafd5e7d.jpeg"></p> 
 <p>使用 <code>inline</code> 和 <code>block</code> 术语的逻辑属性适用于 CSS 盒模型和布局相关的 CSS 属性。不过，你还需要知道的是 <code>start</code> 和 <code>end</code> 关键词，其中：</p> 
 <ul><li><p><code>start</code> 指的是文本从哪里开始流动，在 LTR 中是向左，在 RTL 中是向右</p></li><li><p><code>end</code> 指的是文本流动结束位置，在 LTR 中是向右，在 RTL 中是向左</p></li></ul> 
 <p><img src="https://images2.imgbox.com/b6/6a/nq6jxMxv_o.jpg" alt="65b6a1f37426ff33e76db6e0ad0f59c8.jpeg"></p> 
 <p>如果你写 CSS 已经有一段时间了，但还没有使用过 CSS 逻辑属性，那么它们可能会让你觉得有点奇怪，不过你可以学习。只不过，我们需要换过一种方式重新审视和学习 CSS 。正如 @Rachel Andrew 所言：</p> 
 <blockquote> 
  <p>CSS 已经重构到一定程度，要真正解释 CSS 是如何工作的，我们需要改变我们教授和讨论 CSS 语言的方式。我们需要重新审视学习 CSS 是什么。同时，我们也需要抛弃旧观念。只有当我们这样做的时候，我们才不会觉得 CSS 是脆弱的、易碎的、古怪的语言。</p> 
 </blockquote> 
 <p>重新回到我们的话题中来。使用 CSS 逻辑属性还有一个更大、更重要的原因：构建多语言 Web 应用或网站。比如下面这个示例：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/ed/39/5oZa0uYN_o.jpg" alt="ff71f92c4740f84ed964faf56d738a22.jpeg"></p> 
 <p>我们继续回到 CNN 的 “我只想冲浪”这个页面，如果使用 CSS 逻辑属性的话，将会获得更多的好处。当前放置文章标题的 CSS 是这样的：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">header {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">max-width: 540px;</code></pre> 
  <pre class="has"><code class="language-go">margin: 10px  auto 0 0;</code></pre> 
  <pre class="has"><code class="language-go">position: absolute;</code></pre> 
  <pre class="has"><code class="language-go">bottom: 0;</code></pre> 
  <pre class="has"><code class="language-go">left: 0;</code></pre> 
  <pre class="has"><code class="language-go">right: 0;</code></pre> 
  <pre class="has"><code class="language-go">text-align: left;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/b6/f3/Wiyp6pTp_o.jpg" alt="155206ac49f1b5184ba66ee9d149d8ae.jpeg"></p> 
 <p>这并没有错。它只是没有使用 CSS 逻辑属性。</p> 
 <p>如果我们使用谷歌翻译将这个页面翻译成阿位伯语言（即从右向左的语言），其结果是这样的：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/e9/d4/7oG99vtL_o.jpg" alt="db952f5caae96d5ad68424422a233390.jpeg"></p> 
 <p>翻译之后的阿拉伯文，<code>header</code> 区块依旧位于左下角，并且文本仍然是左对齐。实际上，这并不符合阿拉伯文（RTL）的阅读模式。我们可以使用 CSS 逻辑属性，使其得到更好的结果：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">header {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">max-inline-size: 540px;</code></pre> 
  <pre class="has"><code class="language-go">margin-block-start: 10px;</code></pre> 
  <pre class="has"><code class="language-go">margin-inline-end:  auto;</code></pre> 
  <pre class="has"><code class="language-go">margin-block-end: 0;</code></pre> 
  <pre class="has"><code class="language-go">margin-inline-start: 0;</code></pre> 
  <pre class="has"><code class="language-go">position: absolute;</code></pre> 
  <pre class="has"><code class="language-go">inset-block-end: 0;</code></pre> 
  <pre class="has"><code class="language-go">inset-inline-start: 0;</code></pre> 
  <pre class="has"><code class="language-go">inset-inline-end: 0;</code></pre> 
  <pre class="has"><code class="language-go">text-align: start;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/0e/f2/aV0jB7gv_o.jpg" alt="4b5711dcc1a3257ea101a58ee6c23ce1.jpeg"></p> 
 <p>如果你足够仔细的话，你可能发现了，图片上的渐变效果并没有同时调整，正确的效果应该是这样：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/07/69/P5kqYiLk_o.jpg" alt="fb6f036f6efec3b2c3b4eddac606b2ab.jpeg"></p> 
 <p>不幸的是，目前为止在渐变中还没有相关的逻辑属性，比如，还没有像下面这样的逻辑值来根据语言阅读模式自动调整渐变方向：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">.gradient {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">background-image: linear-gradient(</code></pre> 
  <pre class="has"><code class="language-go">to inline end,</code></pre> 
  <pre class="has"><code class="language-go">#000,</code></pre> 
  <pre class="has"><code class="language-go">transparent 50%</code></pre> 
  <pre class="has"><code class="language-go">);</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>不过我们可以使用其他的方式来处理：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">.gradient {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">background-image: linear-gradient(</code></pre> 
  <pre class="has"><code class="language-go">90deg,</code></pre> 
  <pre class="has"><code class="language-go">#000,</code></pre> 
  <pre class="has"><code class="language-go">transparent 50%</code></pre> 
  <pre class="has"><code class="language-go">);</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">[dir="rtl"] .gradient {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">background-image: linear-gradient(</code></pre> 
  <pre class="has"><code class="language-go">270deg,</code></pre> 
  <pre class="has"><code class="language-go">#000,</code></pre> 
  <pre class="has"><code class="language-go">transparent 50%</code></pre> 
  <pre class="has"><code class="language-go">);</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <h3>CSS 相对单位</h3> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/e6/ef/rCPbAp23_o.jpg" alt="f94fd6776db9e5fa8ef5047561613cf5.jpeg"></p> 
 <p>CSS 中的相对单位有很多种类型，比如字体相对单位、视窗相对单位等。尤其是视窗相对单位，它在构建全屏布局时非常实用。例如，在 <code>header</code> 中设置了 <code>height</code> （或 <code>block-size</code>）的值为 <code>100vh</code> ，使 <code>header</code> 的高度和浏览器视窗的高度一样，达到了设计师想要的效果。</p> 
 <p>这样做在桌面端一点问题都没有，但在移动端，它就不一定完美了。在手机浏览器上，原本的 <code>vh</code> 视窗单位并不会考虑浏览器工具栏、状态栏和地址栏所占的高度。换句话说，<code>100vh</code> 的高度可能会有不同的情况：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/99/31/BtZ76V3Y_o.jpg" alt="f2f84e4108aba703239b5d21e51c4ea1.jpeg"></p> 
 <p>虽然有一些 Hack 手段可以解决这方面的问题，但它不是最优解。</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">header {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">height: 100vh;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">@supports (-webkit-touch-callout: none) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">header {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">height: -webkit-fill-available;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>庆幸的是，CSS 新增的动态视窗单位 <code>dvh</code> 可以很好的帮助我们解决。CSS 的 <code>dvh</code> 单位相当于 <code>svh</code> 和 <code>lvh</code> ：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/ba/41/3VylXIHn_o.jpg" alt="387e91ec9b510a0b397f91f078541f29.jpeg"></p> 
 <p>也就是说，<code>dvh</code> 完全解决了这个问题，并且到处都支持，所以我们基本上可以使用它们。这是最近几年最受欢迎的 CSS 改进之一。</p> 
 <h3>容器查询</h3> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/f5/b8/cVvnv7qQ_o.jpg" alt="4e967b5daee86c664f275166e6c706d0.jpeg"></p> 
 <p>容器查询主要分为容器尺寸查询和容器样式查询两种，它们都非常棒。在今天的组件驱动世界中，它们是完全有意义的。这是一件大事，因为我们的行业有一个广泛的共识，那就是 Web 应用或网站应该用 Web 组件来构建。Web 设计师们一致认为，用大大小小的组件构建设计系统是可行的。目前所有的 JavaScript 框架都认为，应该构建组件并将它们组合在一起，以使其最适合你的项目。事实上，Web 开发者也喜欢这种思维模式，大家似乎也理解它。</p> 
 <p>所以，你有了这些组件，它们的部分意义在于你可以在任何需要的地方使用它们。这些组件并不知道自己会放置页面中的哪个位置，同时 Web 开发者也不知道组件在页面不同位置上会占据多少空间（屏幕空间）。因此，容器查询特性的出现，可以使得 Web 开发者更好的构建 Web 组件，做到一次构建，随地布署。</p> 
 <p>以容器查询中的尺寸查询为例。首先，你要有一个容器，并且显式使用 <code>container</code> (或 <code>container-type</code>) 告诉浏览器，该容器是一个查询容器。如此一来，浏览器就可以根据容器尺寸变化来调整其子元素的样式。</p> 
 <pre></pre> 
 <div> 
  <pre class="has"><code class="language-go">&lt;div class="component--container"&gt;&lt;!-- 查询容器 --&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;div class="component"&gt;&lt;!-- Web 组件 --&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;/div&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;/div&gt;</code></pre> 
  <pre class="has"><code class="language-go">.component--container {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">container-type: inline-size;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">.component {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">padding: 10cqmin;</code></pre> 
  <pre class="has"><code class="language-go">font-size: 5cqi;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>当你调整容器尺寸时，组件的内距和字号也会随着调整：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/9c/63/ObLzQuH1_o.png" alt="85dbc009cd14f3f587a974bbd14759a8.png"></p> 
 <blockquote> 
  <p>Demo 地址：https://codepen.io/airen/full/qBQKQOJ</p> 
 </blockquote> 
 <p>这是非常实用的。当然，你可能会说，使用视窗单位 <code>vw</code> 同样可以实现。这样说似乎也是对的，但这只是偶然。你可以看看下面这个示例，视窗尺寸没有做过任何调整，只是 Web 组件放在不同位置，它的容器尺寸也相应会自动调整。你会看到卡片组件的标题字大小会随着组件容器尺寸调整：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/36/d4/Dt3aNiwU_o.jpg" alt="64b035e2c8a16db14ef3593fbe9e14a2.jpeg"></p> 
 <blockquote> 
  <p>Demo 地址：https://codepen.io/airen/full/LYXrXjv</p> 
 </blockquote> 
 <p>对于流体排版这还不是最佳的方案，更好的方案是使用 <code>clamp()</code> 对组件标题大小做一个约束，例如：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">.card h3 {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">font-size: clamp(1.25rem, 5cqi, 1.5rem);</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>这样一来，卡片组件标题最小不会小于 <code>1.25rem</code> ，最大不会大于 <code>1.5rem</code> 。</p> 
 <p>上面这两个示例向大家演示了容器查询是如何实现流体排版。其实，它对于 Web 组件布局也是非常实用的，比如下面这个日历示例：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/2b/40/lKDPw1e0_o.gif" alt="b8366b84f42099c78f9d76a32f3cb3c1.gif"></p> 
 <blockquote> 
  <p>Demo 地址：https://codepen.io/airen/full/wvQXQOe</p> 
 </blockquote> 
 <p>同样，你需要一个实际的“容器”来实现这一点，并且你不能为容器本身设置样式。结果是这样的：</p> 
 <pre></pre> 
 <div> 
  <pre class="has"><code class="language-go">&lt;div class="calendar-wrap"&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;div class="calendar"&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;!-- 日历组件所需的 HTML 结构 --&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;/div&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;/div&gt;</code></pre> 
  <pre class="has"><code class="language-go">.calendar-wrap {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">container: Calendar / inline-size;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">.calendar {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">/* 日历所需的样式 */</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">@container Calendar (width &lt; 690px) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">.calendar {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">/* 容器尺寸小于 690px, 日历布局所需样式 */</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">@container Calendar (width &lt; 360px) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">.calendar {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">/* 容器尺寸小于 360px, 日历布局所需样式 */</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>我们再来看一个 CSS 容器查询中的样式查询相关的案例。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/64/8b/EA36ySj3_o.jpg" alt="aad418a61bde77ba644acd90670853a2.jpeg"></p> 
 <blockquote> 
  <p>Demo 地址：https://codepen.io/airen/full/QWJxJeQ</p> 
 </blockquote> 
 <p>这是一个典型的多语言版本的 Web 组件，该组件排版和尺寸大小都易于解决，使用前面介绍的逻辑属性和逻辑值即可。但卡片渐变背景的方向是逻辑属性和逻辑值还无法做到的。就此而言，CSS 样式查询就可以很好的解决：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">.card {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">--bg-angle: to right;</code></pre> 
  <pre class="has"><code class="language-go">--bg: linear-gradient(var(--bg-angle), #5521c3, #5893eb);</code></pre> 
  <pre class="has"><code class="language-go">background: var(--bg, lightgrey);</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">.card__container[dir="rtl"] {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">--dir: rtl;</code></pre> 
  <pre class="has"><code class="language-go">direction: var(--dir);</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">@container style(--dir: rtl) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">.card {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">--bg-angle: to left;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">svg {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">transform: scaleX(-1);</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>请注意，容器查询和样式查询的主要区别在于，<strong>容器查询用于查询容器尺寸大小，样式查询用于查询容器样式</strong> 。</p> 
 <p>更为有意思的是，Chromium 团队正在试验一种新的查询类型，称为<strong>状态查询</strong>。同样拿多语言的 Web 组件为例：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/c0/dc/wNJJU6E2_o.jpg" alt="e962933349b2d3ddfc4021fa5f253104.jpeg"></p> 
 <p>我们知道，在阿拉伯语言（RTL）排版中，箭头图标要做一个镜向处理。要是使用状态查询的话，我们可以这样写 CSS：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">@container state(dir: rtl) {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">.icon--arrow {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">transform: scaleX(-1);</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>也就是说，在未来的 CSS 中，容器查询将包含<strong>尺寸查询</strong>、<strong>样式查询</strong>和<strong>状态查询</strong>三种类型：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/71/73/rjdFInBa_o.jpg" alt="a9c31817ff82b8269471208c162cec56.jpeg"></p> 
 <h3>级联层（@layer）</h3> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/a4/5b/vYh1Yiqr_o.jpg" alt="d217a4cce3a5ca8d5039b6064cc95c31.jpeg"></p> 
 <p>在 CSS 中，权重一直以来都令 Web 开发者感到困惑和头疼，这也是 Web 开发者不太喜欢 CSS 的主要原因之一。</p> 
 <p>庆幸的是，随着 CSS 级联层特性的出现，它将颠覆如何解决样式冲突以及什么胜出的想法，这是非常疯狂的。突然间，权重较低的选择器可能会“胜出”，因为它在一个更高的级联层中。</p> 
 <p>这是一个不争的事实。例如：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">body.home nav#main-navigation.top {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">background-color: blue;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">nav {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">background-color: white;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>就上面这两个选择器而言，<code>body.home nav#main-navigation.top</code> 选择器权重要比 <code>nav</code> 高得多：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/42/8e/nKq0JhOT_o.jpg" alt="c1ea3b6f6988bff11e7305a8b8f1539c.jpeg"></p> 
 <p>如果它们都匹配相同的 DOM 元素，那么导航的背景肯定是蓝色的。</p> 
 <p>在 CSS 级联层（<code>@layer</code>）还没有出现之前，这样的认知是正确的。换句话说，自 CSS 级联层出现后，<code>body.home nav#main-navigation.top</code> 与 <code>nav</code> 选择器相比，就不一定更高了（胜出）。例如，<code>nav</code> 选择器放在更高有级联层中，它就会胜出：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">@layer reset, ds, pages, overrides;</code></code></pre> 
  <pre class="has"><code class="language-go">@layer overrides {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">nav {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">background-color: white;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">@layer pages {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">body.home nav#main-navigation.top {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">background-color: blue;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/0d/c0/iZrI0d8r_o.jpg" alt="950a4758a7e4c091d45c606b6a577c83.jpeg"></p> 
 <p>在上面的示例中，在没有第一行声明之下，<code>pages</code> 层将是最高的层，因为它在源顺序中位于后面，但在第一行中，我们声明了我们想要的确切层顺序，因此 <code>overrides</code> 层是最高的层，因此 <code>nav</code> 选择器将获胜。在示例中导航的背景颜色是 <code>white</code> ：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/83/18/sVjHFbdJ_o.jpg" alt="e0ce1efd57014f48bfc179ba44a6b2b6.jpeg"></p> 
 <blockquote> 
  <p>Demo 地址：https://codepen.io/airen/full/oNQymEd</p> 
 </blockquote> 
 <p>是不是觉得很奇怪！CSS 级联层特性完全逆转 CSS 中的重要工作方式，这使得高层中的低权重选择器胜于低层中的高权重选择器。</p> 
 <p>从示例结果来看，CSS 级联层确实增加了 CSS 的特性，也使得 Web 开发者有更多的东西需要学习和了解。甚至说，它会使 CSS 的使用变得更加复杂，但从另一个角度来看，它也是 CSS 的一个解决方案，能帮助 Web 开发者更好的管理冲突和 CSS 权重的问题。</p> 
 <p>这意味着可以更精细地控制何时应用你的样式。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/cd/ba/P3iw6FH6_o.jpg" alt="9891376af228e109b729988cb0a6f8f6.jpeg"></p> 
 <p>比如：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">/* 层结构 */</code></code></pre> 
  <pre class="has"><code class="language-go">/* 最佳实践是将 @layer 放在导入文件的顶部，以便更好的组织层 */</code></pre> 
  <pre class="has"><code class="language-go">@layer base, theme, layouts, components, utilities;</code></pre> 
  <pre class="has"><code class="language-go">/* Base */</code></pre> 
  <pre class="has"><code class="language-go">@import '../styles/base/normalize.css' layer(base);</code></pre> 
  <pre class="has"><code class="language-go">@import '../styles/base/base.css' layer(base);</code></pre> 
  <pre class="has"><code class="language-go">@import '../styles/base/theme.css' layer(theme);</code></pre> 
  <pre class="has"><code class="language-go">/* theme variables */</code></pre> 
  <pre class="has"><code class="language-go">@import '../styles/base/typography.css' layer(theme);</code></pre> 
  <pre class="has"><code class="language-go">/* theme typography */</code></pre> 
  <pre class="has"><code class="language-go">@import '../styles/base/utilities.css' layer(utilities);</code></pre> 
  <pre class="has"><code class="language-go">/* Layouts */</code></pre> 
  <pre class="has"><code class="language-go">@import '../styles/components/post.css' layer(layouts);</code></pre> 
  <pre class="has"><code class="language-go">/ Components */</code></pre> 
  <pre class="has"><code class="language-go">@import '../styles/components/cards.css' layer(components);</code></pre> 
  <pre class="has"><code class="language-go">@import '../styles/components/footer.css' layer(components);</code></pre> 
 </div> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/d8/76/sEAXgHG6_o.jpg" alt="c5fe3ad55346990c840cbae99c7ef703.jpeg"></p> 
 <blockquote> 
  <p>Demo 地址：https://codepen.io/web-dot-dev/project/editor/ZGQLkq </p> 
 </blockquote> 
 <h3>CSS 中的新颜色</h3> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/28/bb/oCnHtKRi_o.jpg" alt="7ebf9f8218042a719c3a2ff55b1f5b76.jpeg"></p> 
 <p>Web 平台上的另一个重要新功能是广色域色彩空间。在广色域色彩在 Web 平台上可用之前，你可以用现代设备查看具有生动色彩的照片，但你无法获得与这些生动值相匹配的按钮、文本颜色或背景。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/77/72/69AXCAUM_o.png" alt="2b6f62cc55e5ad5bfd906650b0b78390.png"></p> 
 <p>我们展示了一系列的图像，这些图像在广色域和窄色域之间进行了转换，以说明颜色的生动性及其效果。但现在，Web 平台上有一系列新的颜色空间，包括 REC2020、P3、XYZ、LAB、OKLAB、LCH 和 OKLCH。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/b3/2d/sjC63As1_o.jpg" alt="b955746c0241234ffa0815d8bb19769e.jpeg"></p> 
 <p>同时，你可以立刻在 DevTools 中看到颜色范围如何扩展，那条白色线条代表 sRGB 范围结束的位置，宽色域颜色范围的开始位置。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/f9/b9/hJS6EHja_o.jpg" alt="0d4517987d40406d22b12cd350a84141.jpeg"></p> 
 <p>还有很多可用于颜色的工具！也别错过所有精彩的渐变改进。甚至有一个全新的工具，@Adam Argyle 构建的用于帮助你尝试新的 Web 色彩选择器和渐变构建器，可以在 gradient.style 上试用。</p> 
 <p>更进一步，与扩展的颜色空间有关的是 <code>color-mix()</code> 函数。该函数支持混合两种颜色值，以根据被混合的颜色通道创建新值。混合颜色的颜色空间会影响结果。使用更感知色彩空间（例如 <code>oklch</code> ）进行工作，将会在比 <code>srgb</code> 更不同的颜色范围内运行。</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">color-mix(in srgb, blue, white);</code></code></pre> 
  <pre class="has"><code class="language-go">color-mix(in srgb-linear, blue, white);</code></pre> 
  <pre class="has"><code class="language-go">color-mix(in lch, blue, white);</code></pre> 
  <pre class="has"><code class="language-go">color-mix(in oklch, blue, white);</code></pre> 
  <pre class="has"><code class="language-go">color-mix(in lab, blue, white);</code></pre> 
  <pre class="has"><code class="language-go">color-mix(in oklab, blue, white);</code></pre> 
  <pre class="has"><code class="language-go">color-mix(in xyz, blue, white);</code></pre> 
 </div> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/47/13/TyDyn0lY_o.jpg" alt="a25a990615a4da6d581efb17bbd87dbd.jpeg"></p> 
 <p><code>color-mix()</code> 函数提供了一个长期请求的功能：在保留不透明颜色值的同时，添加一些透明度。现在，你可以在创建具有不同不透明度变化的颜色时使用你的品牌颜色变量。其中的一种方式是将颜色与透明混合。当你将品牌颜色混合到 <code>10％</code> 的透明度时，你将获得 <code>90％</code> 不透明的品牌颜色。你可以看到这如何帮助你快速构建颜色系统。</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">:root {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">--colorPrimary: hotpink;</code></pre> 
  <pre class="has"><code class="language-go">--colorPrimary-a10: color-mix(in srgb, var(--colorPrimary), transparent 90%);</code></pre> 
  <pre class="has"><code class="language-go">--colorPrimary-a20: color-mix(in srgb, var(--colorPrimary), transparent 80%);</code></pre> 
  <pre class="has"><code class="language-go">--colorPrimary-a30: color-mix(in srgb, var(--colorPrimary), transparent 70%);</code></pre> 
  <pre class="has"><code class="language-go">--colorPrimary-a40: color-mix(in srgb, var(--colorPrimary), transparent 60%);</code></pre> 
  <pre class="has"><code class="language-go">--colorPrimary-a50: color-mix(in srgb, var(--colorPrimary), transparent 50%);</code></pre> 
  <pre class="has"><code class="language-go">--colorPrimary-a60: color-mix(in srgb, var(--colorPrimary), transparent 40%);</code></pre> 
  <pre class="has"><code class="language-go">--colorPrimary-a70: color-mix(in srgb, var(--colorPrimary), transparent 30%);</code></pre> 
  <pre class="has"><code class="language-go">--colorPrimary-a80: color-mix(in srgb, var(--colorPrimary), transparent 20%);</code></pre> 
  <pre class="has"><code class="language-go">--colorPrimary-a90: color-mix(in srgb, var(--colorPrimary), transparent 10%);</code></pre> 
  <pre class="has"><code class="language-go">--colorSecondary: lime;</code></pre> 
  <pre class="has"><code class="language-go">--colorSecondary-a10: color-mix( in srgb, var(--colorSecondary), transparent 90% );</code></pre> 
  <pre class="has"><code class="language-go">--colorSecondary-a20: color-mix( in srgb, var(--colorSecondary), transparent 80% );</code></pre> 
  <pre class="has"><code class="language-go">--colorSecondary-a30: color-mix( in srgb, var(--colorSecondary), transparent 70% );</code></pre> 
  <pre class="has"><code class="language-go">--colorSecondary-a40: color-mix( in srgb, var(--colorSecondary), transparent 60% );</code></pre> 
  <pre class="has"><code class="language-go">--colorSecondary-a50: color-mix( in srgb, var(--colorSecondary), transparent 50% );</code></pre> 
  <pre class="has"><code class="language-go">--colorSecondary-a60: color-mix( in srgb, var(--colorSecondary), transparent 40% );</code></pre> 
  <pre class="has"><code class="language-go">--colorSecondary-a70: color-mix( in srgb, var(--colorSecondary), transparent 30% );</code></pre> 
  <pre class="has"><code class="language-go">--colorSecondary-a80: color-mix( in srgb, var(--colorSecondary), transparent 20% );</code></pre> 
  <pre class="has"><code class="language-go">--colorSecondary-a90: color-mix( in srgb, var(--colorSecondary), transparent 10% );</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/3d/e8/UjbgEMtf_o.jpg" alt="402571d17ab0909721d034cebf860e29.jpeg"></p> 
 <h3>CSS 的嵌套</h3> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/01/ff/veI6FCSK_o.jpg" alt="f5a240b5ae9fd4122acf21a050005752.jpeg"></p> 
 <p>CSS 嵌套是 Sass 中受欢迎的功能之一，也是多年来 CSS 开发者最重要的需求之一，现在它终于加入到了 Web 平台。嵌套允许开发者以更简洁的、分组的格式书写 CSS，从而减少冗余。</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">.card {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">.card:hover {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">/* CSS 嵌套可以这样写 */</code></pre> 
  <pre class="has"><code class="language-go">.card {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">&amp;:hover {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>你还可以嵌套媒体查询，这也意味着您可以嵌套容器查询。在下面的示例中，当容器有足够的宽度时，将从纵向布局更改为横向布局：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">.card {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">display: grid;</code></pre> 
  <pre class="has"><code class="language-go">gap: 1rem;</code></pre> 
  <pre class="has"><code class="language-go">@container (width &gt;= 480px) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">display: flex;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>当容器宽度有超过或等于 <code>480px</code> 时，布局调整为 <code>flex</code>。浏览器将在满足条件时，<code>display</code> 将应用新的值。</p> 
 <h3>CSS 作用域</h3> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/55/6a/VUqQgr0s_o.jpg" alt="0e85596ef5baf6b22eba13d384b0100c.jpeg"></p> 
 <p>CSS 作用域样式允许开发者指定特定样式应用的边界，从而在 CSS 中创建本地命名空间。在此之前，开发者依靠第三方脚本来重命名类，或者采用特定的命名约定来防止样式冲突，但现在你可以使用 <code>@scope</code>。</p> 
 <p>在这里，我们将 <code>.title</code> 元素的作用域限定为 <code>.card</code>。这将防止该标题元素与页面上的任何其他 <code>.title</code> 元素冲突，例如博客文章标题或其他标题。</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">@scope (.card) {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">.title {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">font-weight: bold;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>你可以在此实时演示中查看将 <code>@scope</code> 与作用域限制和 <code>@layer</code> 一起使用的情况。</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">@layer demo, images, cards;</code></code></pre> 
  <pre class="has"><code class="language-go">@layer cards {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">@scope (.card) to (&gt; header &gt; *, &gt; figure &gt; *, &gt; footer &gt; *) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">:scope {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">display: grid;</code></pre> 
  <pre class="has"><code class="language-go">background: oklch(50% none none / 20%);</code></pre> 
  <pre class="has"><code class="language-go">border-radius: 10px;</code></pre> 
  <pre class="has"><code class="language-go">border: 1px solid oklch(50% none none / 20%);</code></pre> 
  <pre class="has"><code class="language-go">@media (prefers-color-scheme: light) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">background: white;</code></pre> 
  <pre class="has"><code class="language-go">box-shadow: 0 30px 10px -20px oklch(0% none none / 25%);</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">&gt; header {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">display: grid;</code></pre> 
  <pre class="has"><code class="language-go">gap: .5ch;</code></pre> 
  <pre class="has"><code class="language-go">padding: 2ch;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">&gt; article {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">max-inline-size: 50ch;</code></pre> 
  <pre class="has"><code class="language-go">line-height: 1.5;</code></pre> 
  <pre class="has"><code class="language-go">padding: 2ch 2ch 1ch;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">&gt; footer {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">display: flex;</code></pre> 
  <pre class="has"><code class="language-go">justify-content: flex-end;</code></pre> 
  <pre class="has"><code class="language-go">padding: 1ch 2ch;</code></pre> 
  <pre class="has"><code class="language-go">gap: 1ch;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/8a/a4/X5oEJC33_o.jpg" alt="065433a39098fd172a2d991cc1288d1e.jpeg"></p> 
 <blockquote> 
  <p>Demo 地址：https://codepen.io/web-dot-dev/full/MWPVGPL</p> 
 </blockquote> 
 <h3>三角函数</h3> 
 <p>CSS 中新增的三角函数是 CSS 数学函数的一部分。这些函数现在在所有现代浏览器中都已稳定，使你能够在 Web 平台上创建更有机的布局。一个很好的例子是这个径向菜单布局，现在可以使用 <code>sin()</code> 和 <code>cos()</code> 函数进行设计和动画制作。在下面的演示中，点围绕中心点旋转。与其让每个点绕自己的中心旋转然后向外移动，不如在 <code>X</code> 和 <code>Y</code> 轴上转换每个点。在 <code>X</code> 和 <code>Y</code> 轴上的距离是通过考虑 <code>--angle</code> 的 <code>cos()</code> 和 <code>sin()</code> 分别确定的。</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">@property --angle {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">syntax: '&lt;angle&gt;';</code></pre> 
  <pre class="has"><code class="language-go">initial-value: 0deg;</code></pre> 
  <pre class="has"><code class="language-go">inherits: true;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">:root {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">--angle: 0deg;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">@keyframes adjust-angle {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">to {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">--angle: 360deg;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">:root {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">animation: adjust-angle linear 20s infinite paused;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">:root:has(#enable_animation:checked) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">animation-play-state: running;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">.dot {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">--offset-per-child: calc(360deg / (var(--nth-siblings) + 1));</code></pre> 
  <pre class="has"><code class="language-go">--angle-offset: calc(var(--nth-child) * var(--offset-per-child));</code></pre> 
  <pre class="has"><code class="language-go">display: block;</code></pre> 
  <pre class="has"><code class="language-go">width: var(--tracksize);</code></pre> 
  <pre class="has"><code class="language-go">aspect-ratio: 1;</code></pre> 
  <pre class="has"><code class="language-go">border-radius: 50%;</code></pre> 
  <pre class="has"><code class="language-go">background: hsl(var(--angle-offset) 100% 50%);</code></pre> 
  <pre class="has"><code class="language-go">border: 1px solid #333;</code></pre> 
  <pre class="has"><code class="language-go">position: absolute;</code></pre> 
  <pre class="has"><code class="language-go">left: calc(50% - (var(--tracksize) / 2));</code></pre> 
  <pre class="has"><code class="language-go">top: calc(50% - (var(--tracksize) / 2));</code></pre> 
  <pre class="has"><code class="language-go">translate: calc(cos((var(--angle) + var(--angle-offset))) * var(--radius)) calc(sin((var(--angle) + var(--angle-offset))) * var(--radius) * -1);</code></pre> 
  <pre class="has"><code class="language-go">pointer-events: none;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/63/f3/MmZ2nydM_o.gif" alt="21123e926d3c5d960409854243c2a055.gif"></p> 
 <blockquote> 
  <p>Demo 地址：https://codepen.io/web-dot-dev/full/ExePgOg</p> 
 </blockquote> 
 <h3>滚动驱动动画</h3> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/fd/35/wnia51uE_o.jpg" alt="51c175e35b5ec3a275fab5c06caa9b4e.jpeg"></p> 
 <p>滚动驱动动画允许你根据滚动容器的滚动位置控制动画的播放。这意味着当你向上或向下滚动时，动画会前进或后退。此外，通过滚动驱动动画，你还可以根据元素在其滚动容器中的位置来控制动画。这使你可以创建有趣的效果，例如视差背景图像、滚动进度条以及随着视图进入而显示的图像。</p> 
 <p>该 API 支持一组 JavaScript 类和 CSS 属性，允许你轻松创建声明性的滚动驱动动画。</p> 
 <p>要通过滚动驱动 CSS 动画，请使用新的 <code>scroll-timeline</code>、<code>view-timeline</code> 和 <code>animation-timeline</code> 属性。要驱动 JavaScript Web Animations API，请将 <code>ScrollTimeline</code> 或 <code>ViewTimeline</code> 实例作为 <code>timeline</code> 选项传递给 <code>Element.animate()</code>。</p> 
 <p>这些新 API 与现有的 Web Animations 和 CSS Animations API 协同工作，这意味着它们可以受益于这些 API 的优势。其中包括能够在主线程以外运行这些动画。是的，你现在可以通过一些额外的代码轻松地驱动滚动，使其在主线程以外流畅运行。有什么不喜欢的呢？！</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/aa/8e/ifeceLcr_o.png" alt="a057c49293933947060cedc4ef312288.png"></p> 
 <p>使用 <code>animation-timeline</code> 构建类似上面的效果：</p> 
 <pre class="has"><code class="language-css">@keyframes adjust-progressbar {
from {
transform: scaleX(0);
}
to {
transform: scaleX(1);
}
}




#progressbar {
animation: 1s linear forwards adjust-progressbar;
animation-timeline: scroll(block);
}</code></pre> 
 <p>视图过渡</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/59/83/kT7LzETd_o.jpg" alt="2afe9c38120abec0fbffca678340b415.jpeg"></p> 
 <p>我们现在使用的手机应用和操作系统中有很多动画效果：</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/09/2e/RvphFZS3_o.gif" alt="e335f4c623597073f9007c086c44d1ee.gif"></p> 
 <p>你打开和关闭的每一个应用程序，每个应用程序的每个屏幕、每个菜单，所有的一切都在动，但在 Web 上却不是这样。我们在 Web 上有很好的动画工具，但它们的使用方式不同。我们只是不像手机那样制作动画。我并不是说我们应该这么做。</p> 
 <p>但是，我们也没有所有需要的工具，在页面加载之间制作动画。直到现在，我们有了视图过渡 API。</p> 
 <p>视图过渡 API 使单步更改 DOM 变得容易，同时在两个状态之间创建动画过渡。这些可以是视图之间的简单淡出，但你还可以控制页面的各个部分如何过渡。</p> 
 <p>视图过渡可以用作渐进增强：将更新 DOM 的代码按任何方法进行分解，并使用视图过渡 API 包装它，以便在不支持该功能的浏览器中提供回退。</p> 
 <pre></pre> 
 <div> 
  <pre class="has"><code class="language-go">function spaNavigate(data) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">// Fallback for browsers that don't support this API:</code></pre> 
  <pre class="has"><code class="language-go">if (!document.startViewTransition) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">updateTheDOMSomehow(data); return;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">// With a transition:</code></pre> 
  <pre class="has"><code class="language-go">document.startViewTransition(() =&gt; updateTheDOMSomehow(data));</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>Web 开发者可以使用 <code>::view-transition-old()</code> 和 <code>::view-transition-new()</code> 来控制过渡的外观。</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">@keyframes slide-from-right {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">from {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">opacity: 0;</code></pre> 
  <pre class="has"><code class="language-go">transform: translateX(75px);</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">@keyframes slide-to-left {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">to {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">opacity: 0;</code></pre> 
  <pre class="has"><code class="language-go">transform: translateX(-75px);</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">::view-transition-old(root) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">animation: 350ms both slide-to-left ease;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">::view-transition-new(root) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">animation: 350ms both slide-from-right ease;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>正如 @Maxi Ferreira 的这个精彩演示所展示的那样，其他页面交互，例如正在播放的视频，在进行视图过渡时仍然可以继续工作。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/78/c3/YY6EAYel_o.gif" alt="3f0e1e51e7dfe16a3ba5f432873195d5.gif"></p> 
 <h3>瀑布流布局</h3> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/56/3f/CwHnpylb_o.jpg" alt="7ef00d808873f5aaef06de61fb33db49.jpeg"></p> 
 <p>你知道 Pinterest 吗？它是 Web 上最著名的布局之一，即<strong>瀑布流布局</strong>。虽然在 CSS 使用多列布局和 CSS Flexbox 可以模拟出瀑布流布局效果，但更多的时候还是依赖于 JavaScript 库来构建瀑布流布局效果。</p> 
 <p>好消息是，CSS 网格布局新增了原生的瀑布流布局相关特性，你只需要用一个 CSS，就可以实现瀑布流布局效果:</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/46/81/KVtMyArB_o.jpg" alt="7efe0d2b1e7fa62b83c470acf2fa07a3.jpeg"></p> 
 <h3>案例：使用现代 CSS 构建按钮组件</h3> 
 <p>接下来，我们将以按钮组件为例，来展示现代 CSS 特性给 Web 开发者带来的变化。</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/b4/3e/6m5q3jdW_o.jpg" alt="e74fb5656a7489dd1e3e1e2b318cb72d.jpeg"></p> 
 <p>正如上图所示，按钮组件有多种不同的变体：</p> 
 <ul><li><p>按钮元素（<code>&lt;button&gt;</code>）</p></li><li><p>链接元素（<code>&lt;a&gt;</code>）</p></li><li><p>文字加图标的按钮</p></li><li><p>图标加文字的按钮</p></li><li><p>纯图标的按钮</p></li></ul> 
 <p>这些按钮组件变体，所对应的 HTML 结构如下：</p> 
 <pre></pre> 
 <div> 
  <pre class="has"><code class="language-go">&lt;!-- button 元素 --&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;button type="button" class="button"&gt;Button&lt;/button&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;!-- a 元素 --&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;a href="" class="button"&gt;Link&lt;/a&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;!-- 文字加图标 --&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;button type="button" class="button"&gt;</code></pre> 
  <pre class="has"><code class="language-go">Text + Icon Button</code></pre> 
  <pre class="has"><code class="language-go">&lt;svg class="button__icon" aria-hidden="true" width="24" height="24"&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;use href="#star"&gt;&lt;/use&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;/svg&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;/button&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;!-- 图标加文字 --&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;button type="button" class="button"&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;svg class="button__icon" aria-hidden="true" width="24" height="24"&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;use href="#star"&gt;&lt;/use&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;/svg&gt;</code></pre> 
  <pre class="has"><code class="language-go">Icon + Text button</code></pre> 
  <pre class="has"><code class="language-go">&lt;/button&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;!-- 纯图标 --&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;button type="button" class="button"&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;svg class="button__icon" aria-hidden="true" width="24" height="24"&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;use href="#star"&gt;&lt;/use&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;/svg&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;span class="inclusively-hidden"&gt;Icon only button&lt;/span&gt;</code></pre> 
  <pre class="has"><code class="language-go">&lt;/button&gt;</code></pre> 
 </div> 
 <p>构建按钮组件，需要一些重置样式。只不过有一些重置属性超出了本文的范围。我们在定制按钮组件时，首先起作用的第一个属性与颜色有关。例如文本颜色和背景颜色。</p> 
 <p>我们将使用 CSS 的自定义属性来创建按钮的文本颜色（<code>color</code>）和背景颜色（<code>background-color</code>）。稍后，我们可以利用 CSS 自定义属性轻松创建按钮组件的变体，包括按钮不同状态下的颜色，如 <code>:hover</code> 或 <code>:disabled</code> 。</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">@layer components {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">.button {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">color: var(--button-color, var(--primary));</code></pre> 
  <pre class="has"><code class="language-go">background-color: var(--button-bg, var(--accent));</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>在这个示例中，按钮的 <code>color</code> 和 <code>background-color</code> 都使用的是一个未定义的自定义属性，并且使用第二个值（也是自定义属性）作为未定义属性的回退值。</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">@layer theme {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">:root {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">--primary: hsl(265 38% 13%);</code></pre> 
  <pre class="has"><code class="language-go">--accent: hsl(278 100% 92%);</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>注意，我们把组件所需的颜色放置在 <code>theme</code> 的层中，这样我们更易于维护 CSS 代码。即：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">@layer reset, theme, components;</code></code></pre> 
  <pre class="has"><code class="language-go">@layer theme {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">:root {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">--primary: hsl(265 38% 13%);</code></pre> 
  <pre class="has"><code class="language-go">--accent: hsl(278 100% 92%);</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">@layer components {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">.button {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">color: var(--button-color, var(--primary));</code></pre> 
  <pre class="has"><code class="language-go">background-color: var(--button-bg, var(--accent));</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>接下来，使用 <code>:has()</code> 选择给按钮组件创建变体。因为 <code>:has()</code> 选择器可以检测出按钮是否包含了图标：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">@layer components {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">.button:where(:has(.button__icon)) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">display: flex;</code></pre> 
  <pre class="has"><code class="language-go">gap: 0.5em;</code></pre> 
  <pre class="has"><code class="language-go">align-items: center;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>上面代码中，使用 <code>:has()</code> 选择器来查看 <code>.button</code> 是否包含 <code>.button__icon</code> 图标。如果有，设置 <code>display</code> 属性的值为 <code>flex</code> ，并且设置 <code>align-items</code> 的值为 <code>center</code> ，同时使用 <code>gap</code> 设置文本和图标之间的间距。因为使用 <code>:has()</code> 选择器会增加基类选择器的权重，所以我们将 <code>:has()</code> 放在 <code>:where()</code> 选择器中，这样可以将其权重降至为 <code>0</code> 。也就是说，选择器只保留类名（<code>.button</code>）的权重。</p> 
 <p>在仅有图标按钮的情况下，我们的 HTML 标记提供了一个带有 <code>.inclusively-hidden</code> 类名的 <code>&lt;span&gt;</code> 元素，这样做是为了让屏幕阅读器能更好的理解是什么按钮。只不过，我们需要使用相关技术手段，在视觉上不呈现该元素中的文本内容。同样的，我们使用<code>:has()</code> 和 <code>:where()</code> 组合，来查询 <code>.button</code> 是否包含 <code>.inclusively-hidden</code> ，如果包含，按钮只显示图标，并且按钮是一个圆形：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">@layer components {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">.button:where(:has(.inclusively-hidden)) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">border-radius: 50%;</code></pre> 
  <pre class="has"><code class="language-go">padding: 0.5em;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>接下来，对于没有图标的按钮，我们要设置最小的内联轴尺寸（<code>min-inline-size</code>），并且让文本居中。我们可以通过组合 <code>:has()</code> 和 <code>:not()</code> 来实现：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">@layer components {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">.button:where(:not(:has(.button__icon))) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">text-align: center;</code></pre> 
  <pre class="has"><code class="language-go">min-inline-size: 10ch;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>我们最后一个重要的按钮变体是不只有图标的按钮（文本加图标的按钮和图标加文本的按钮）。因此，我们的选择器将再次组合 <code>:has()</code> 和 <code>:not()</code> 来查询没有 <code>.inclusively-hidden</code> 类的按钮：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">@layer components {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">.button:where(:not(:has(.inclusively-hidden))) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">padding: var(--button-padding, 0.75em 1em);</code></pre> 
  <pre class="has"><code class="language-go">border-radius: 0;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>按钮初始状态的外观完成之后，我们南非要处理按钮的另外两个状态的外观，即 <code>:hover</code> 和 <code>:focus-visible</code> 。在这里，我们依旧使用 CSS 自定义属性，而且不需要添加额外的属性。</p> 
 <p>对于悬停状态（<code>:hover</code>），我们只需更新颜色：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">@layer theme {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">:root {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">--primary: hsl(265 38% 13%);</code></pre> 
  <pre class="has"><code class="language-go">--accent: hsl(278 100% 92%);</code></pre> 
  <pre class="has"><code class="language-go">--accent--alt: hsl(279 100% 97%);</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">@layer components {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">.button:hover {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">--button-bg: var(--accent--alt);</code></pre> 
  <pre class="has"><code class="language-go">--button-color: var(--primary);</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>对于 <code>:focus-visible</code>，我们只需要重新调整 <code>outline</code> 属性的值：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">@layer components {<!-- --></code></code></pre> 
  <pre class="has"><code class="language-go">.button:focus-visible {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">--outline-style: dashed;</code></pre> 
  <pre class="has"><code class="language-go">--outline-offset: -0.35em;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p>最终所有 CSS 代码如下：</p> 
 <pre><code class="language-css"></code></pre> 
 <div lang="css"> 
  <pre class="has"><code class="language-css"><code class="language-go">@layer reset, base, theme, components;</code></code></pre> 
  <pre class="has"><code class="language-go">@layer reset {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">*,</code></pre> 
  <pre class="has"><code class="language-go">*::before,</code></pre> 
  <pre class="has"><code class="language-go">*::after {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">margin: 0;</code></pre> 
  <pre class="has"><code class="language-go">padding: 0;</code></pre> 
  <pre class="has"><code class="language-go">box-sizing: border-box;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">button {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">font: inherit;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">svg {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">fill: currentColor;</code></pre> 
  <pre class="has"><code class="language-go">pointer-events: none;</code></pre> 
  <pre class="has"><code class="language-go">display: block;</code></pre> 
  <pre class="has"><code class="language-go">width: 1em;</code></pre> 
  <pre class="has"><code class="language-go">height: 1em;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">@layer base {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">.button {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">font-size: 1rem;</code></pre> 
  <pre class="has"><code class="language-go">text-decoration: none;</code></pre> 
  <pre class="has"><code class="language-go">font-family: inherit;</code></pre> 
  <pre class="has"><code class="language-go">cursor: pointer;</code></pre> 
  <pre class="has"><code class="language-go">align-self: start;</code></pre> 
  <pre class="has"><code class="language-go">justify-self: start;</code></pre> 
  <pre class="has"><code class="language-go">border: 2px solid currentColor;</code></pre> 
  <pre class="has"><code class="language-go">font-weight: 600;</code></pre> 
  <pre class="has"><code class="language-go">letter-spacing: 0.04em;</code></pre> 
  <pre class="has"><code class="language-go">transition: background-color 180ms ease-in-out;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">.button:focus-visible {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">outline: var(--outline-width, 1px) var(--outline-style, solid) var(--outline-color, var(--outline));</code></pre> 
  <pre class="has"><code class="language-go">outline-offset: var(--outline-offset, 1px);</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">.inclusively-hidden {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">clip-path: inset(50%);</code></pre> 
  <pre class="has"><code class="language-go">height: 1px;</code></pre> 
  <pre class="has"><code class="language-go">width: 1px;</code></pre> 
  <pre class="has"><code class="language-go">overflow: hidden;</code></pre> 
  <pre class="has"><code class="language-go">position: absolute;</code></pre> 
  <pre class="has"><code class="language-go">white-space: nowrap;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">@layer theme {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">:root {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">--primary: hsl(265 38% 13%);</code></pre> 
  <pre class="has"><code class="language-go">--accent: hsl(278 100% 92%);</code></pre> 
  <pre class="has"><code class="language-go">--accent--alt: hsl(279 100% 97%);</code></pre> 
  <pre class="has"><code class="language-go">--outline: #351d4a;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">@layer components {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">.button {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">color: var(--button-color, var(--primary));</code></pre> 
  <pre class="has"><code class="language-go">background-color: var(--button-bg, var(--accent));</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">.button:where(:has(.button__icon)) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">display: flex;</code></pre> 
  <pre class="has"><code class="language-go">gap: 0.5em;</code></pre> 
  <pre class="has"><code class="language-go">align-items: center;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">.button:where(:has(.inclusively-hidden)) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">border-radius: 50%;</code></pre> 
  <pre class="has"><code class="language-go">padding: 0.5em;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">.button:where(:not(:has(.button__icon))) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">text-align: center;</code></pre> 
  <pre class="has"><code class="language-go">min-inline-size: 10ch;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">.button:where(:not(:has(.inclusively-hidden))) {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">padding: var(--button-padding, 0.75em 1em);</code></pre> 
  <pre class="has"><code class="language-go">border-radius: 0;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">.button:hover {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">--button-bg: var(--accent--alt);</code></pre> 
  <pre class="has"><code class="language-go">--button-color: var(--primary);</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">.button:focus-visible {<!-- --></code></pre> 
  <pre class="has"><code class="language-go">--outline-style: dashed;</code></pre> 
  <pre class="has"><code class="language-go">--outline-offset: -0.35em;</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
  <pre class="has"><code class="language-go">}</code></pre> 
 </div> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/96/27/ZxGP7d5B_o.gif" alt="f710dccdaa29e255a6ebc7c15f284528.gif"></p> 
 <blockquote> 
  <p>Demo 地址：https://codepen.io/airen/full/KKreYJY</p> 
 </blockquote> 
 <h3>小结</h3> 
 <p>总体来说，现代 CSS 除了可以利用这些新特性解决老的 CSS 问题之外，它（现代 CSS）更加注重灵活性、响应式设计、可访问性和可维护性，可以帮助开发者更加轻松地实现各种复杂的设计需求，并提高网站的用户体验和可维护性。</p> 
 <ul><li><p><strong>强大的选择器</strong> ：现代 CSS 支持多种复杂的选择器，例如 <code>:has()</code> 、<code>:not()</code> 、<code>:is()</code> 和 <code>:where()</code> 等伪类函数；<code>:modal</code> 和 <code>::backdrop</code> 伪类选择器；<code>:focus-visible</code> 和 <code>:focus-within</code> 伪类选择器等，这使得开发者除了可以更精确的选择和控制页面中的元素之外，在部分场景之下可以替代 JavaScript 脚本，实现可动态交互的组件。</p></li><li><p><strong>灵活的布局</strong> ：现代 CSS 提供了多种灵活的布局方式，例如 Flexbox 和 Grid 布局，这些布局方式可以帮助开发者更加轻松地实现响应式设计和复杂的页面布局。</p></li><li><p><strong>响应式设计</strong> ：现代 CSS 的新特性，比如 CSS 的比较函数、CSS 容器查询、样式查询、CSS 作用域等，可以使得 Web 开发者可以基于 Web 组件驱动方式来开发组件。除了使页面可以根据不同设备屏幕尺寸来适应调整宏观布局之外，还可以使组件根据容器尺寸和样式来调整微观布局，以提高用户体验</p></li><li><p><strong>高清颜色</strong> ：现代 CSS 提供了更多支持广色域的 CSS 函数，可以为 Web 元素的颜色提供更高清的色彩，使得 Web 页面不会在高清屏幕下失真。</p></li><li><p><strong>动画效果</strong> ：现代 CSS 提供了多种实现动画效果的特性，比如路径动画、动画合成、滚动驱动动画、离散属性过渡和视图过渡等，可以帮助开发者实现各种动态效果，使网页更加生动和有趣。</p></li><li><p><strong>动态单位</strong> ：现代 CSS 提供了更多的动态单位，比如动态视窗单位、容器单位，新增相对单位，可以帮助开发者更好的控制元素尺寸</p></li><li><p><strong>逻辑属性</strong> ：现代 CSS 提供了一些逻辑属性，可以使 Web 开发者开发的页面布局根据书写模式、阅读模式自动匹配，这为开发一个多语言应用或网站带来极大的灵活性。</p></li><li><p><strong>排版特性</strong> ：现代 CSS 新增了彩色字体、可变字体、文本装饰、文本断行、首字下沉等各种新特性，可以帮助开发者更加方便地为文本提供一个更好的排版样式，提高网站的用户体验。</p></li><li><p><strong>可访问性</strong> ：现代 CSS 注重可访问性，可以通过使用适当的语义化标签和属性，以及提供良好的键盘导航和屏幕阅读器支持等方式，帮助开发者创建更加易于访问的网站。</p></li><li><p><strong>可维护性</strong> ：现代 CSS 提供了多种模块化和组件化的方式，例如CSS 变量、CSS 嵌套、CSS 作用域、CSS 级联层等，可以帮助开发者更加方便地维护和更新网站的样式。</p></li></ul> 
 <h3>写在最后</h3> 
 <p>我为什么要写一本关于现代 CSS 方面的小册呢？除了现有书籍很少有这些新特性介绍之外，还有几个主要原因：</p> 
 <ul><li><p><strong>现代 CSS 技术不断发展</strong>：随着前端技术的不断发展，现代 CSS 技术也在不断更新和演进，出现了越来越多的新特性和新技术。一本关于现代 CSS 技术的书籍可以帮助开发者更好地了解这些新技术，掌握最新的前端开发技能。</p></li><li><p><strong>现代 CSS 技术应用广泛</strong>：现代 CSS 技术已经成为前端开发中不可或缺的一部分，应用广泛。一本关于现代 CSS 技术的书籍可以帮助开发者更好地掌握这些技术，提高自己的开发水平和竞争力。</p></li><li><p><strong>现代 CSS 技术复杂度高</strong>：现代 CSS 技术相对于旧的 CSS 技术来说，更加复杂。一本关于现代 CSS 技术的书籍可以帮助开发者更好地理解这些复杂的技术，并提供实际的应用案例和最佳实践。</p></li><li><p><strong>现代 CSS 技术提高开发效率</strong>：现代 CSS 技术提供了更多便捷的方式，例如使用 CSS 变量、CSS 嵌套、CSS 作用域等，可以帮助开发者更加快速地实现各种设计需求，提高开发效率。一本关于现代 CSS 技术的书籍可以帮助开发者更好地掌握这些技术，提高开发效率。</p></li></ul> 
 <p>综上所述，写一本关于现代 CSS 技术的书籍可以帮助开发者更好地了解和掌握这些技术，提高自己的开发水平和竞争力。</p> 
 <p>那么，作为一名 Web 开发者，尤其是 Web 前端开发者，你有没有必要学习现代 CSS 相关的技术呢？我的回答是需要的，因为：</p> 
 <ul><li><p><strong>提高工作效率</strong>：掌握现代 CSS 技术可以帮助你更加快速地实现各种复杂的设计需求，从而提高工作效率。</p></li><li><p><strong>提高职业竞争力</strong>：现代 CSS 技术是前端开发中必不可少的一部分，掌握这些技术可以提高你的职业竞争力，让你在求职和升职方面更具优势。</p></li><li><p><strong>跟上时代潮流</strong>：随着互联网技术的不断发展，现代 CSS 技术也在不断更新和完善，学习这些技术可以让你跟上时代潮流，保持前沿的技术水平。</p></li><li><p><strong>提高用户体验</strong>：现代 CSS 技术支持响应式设计和可访问性，可以根据不同的设备和屏幕尺寸来自适应地调整网页布局和样式，以提高用户体验。</p></li><li><p><strong>提高网站可维护性</strong>：现代 CSS 技术提供了多种模块化和组件化的方式，可以帮助开发者更加方便地维护和更新网站的样式，从而提高网站的可维护性。</p></li></ul> 
 <p>总体来说，学习现代 CSS 相关的技术可以帮助你提高工作效率、职业竞争力和用户体验，跟上时代潮流，并提高网站的可维护性。</p> 
 <p><strong>如果你喜欢这本小册的内容，请点击这里直达！(https://s.juejin.cn/ds/iJrTure4/)。详细大纲如下：</strong></p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/0a/1e/QFvSm1F0_o.jpg" alt="a7cc0dd8368798cb159fcad1977a54ad.jpeg"></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a73595622a42745dd3180bad51d3e518/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NVIDIA Jetson Orin Nano性能跃升80倍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7f803f01cedcae6c290193992d7620df/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">QFontDialog</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>