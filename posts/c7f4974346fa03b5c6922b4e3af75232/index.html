<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C#中base关键字的几种用法:base() - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C#中base关键字的几种用法:base()" />
<meta property="og:description" content="base其实最大的使用地方在面相对象开发的多态性上，base可以完成创建派生类实例时调用其基类构造函数或者调用基类上已被其他方法重写的方法。
例如：
2.1关于base调用基类构造函数
public class A { public A() { Console.WriteLine(&#34;Build A&#34;); } } public class B:A { public B():base() { Console.WriteLine(&#34;Build B&#34;); } static void Main() { B b = new B(); Console.ReadLine(); } } 创建一个B的实例对象，获得结果是同时打印Build A和Build B．
2.2关于base在派生类中调用基类的方法。
public class A { public virtual void Hello() { Console.WiriteLine(&#34;Hello&#34;); } } public class B : A { public override void Hello() { base.Hello();//调用基类的方法,显示Hello Console.WiriteLine(&#34;World&#34;); } } 这样如果程序调用B.Hello()获得的效果将会使Hello World." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c7f4974346fa03b5c6922b4e3af75232/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-09T15:20:46+08:00" />
<meta property="article:modified_time" content="2018-10-09T15:20:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C#中base关键字的几种用法:base()</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>base其实最大的使用地方在面相对象开发的多态性上，base可以完成创建派生类实例时调用其基类构造函数或者调用基类上已被其他方法重写的方法。</strong><br> 例如：</p> 
<p><br><strong>2.1关于base调用基类构造函数</strong></p> 
<pre class="has"><code class="language-cs">public class A
{
        public A()
        {
                Console.WriteLine("Build A");
        }
}
public class B:A
{
        public B():base()
        {
                Console.WriteLine("Build B");
        }
        static void Main()
        {
                B b = new B();
                Console.ReadLine();
        }
}</code></pre> 
<p><strong>创建一个B的实例对象，获得结果是同时打印Build A和Build B．</strong></p> 
<p> </p> 
<p><strong>2.2关于base在派生类中调用基类的方法。</strong></p> 
<pre class="has"><code class="language-cs">public class A
{
        public virtual void Hello()
        {
                Console.WiriteLine("Hello");
        }
}
public class B : A
{
        public override void Hello()
        {               
                base.Hello();//调用基类的方法,显示Hello
                Console.WiriteLine("World");
        }
}</code></pre> 
<p><strong>这样如果程序调用B.Hello()获得的效果将会使Hello World.</strong></p> 
<p><br><strong>最后补充下，根据MSDN Library介绍来看这两个关键字都是属于[访问关键字]类型</strong></p> 
<p><strong> </strong></p> 
<p><strong>+++++++++++++++++++++++++++++ 无敌分割线 +++++++++++++++++++++++++++++</strong></p> 
<p><strong>+++++++++++++++++++++++++++++ 文章二 +++++++++++++++++++++++++++++</strong></p> 
<p><strong> </strong></p> 
<p><strong>关于base</strong></p> 
<p><strong>base 关键字用于从派生类中访问基类的成员：<br> 调用基类上已被其他方法重写的方法。<br> 指定创建派生类实例时应调用的基类构造函数。<br> 基类访问只能在构造函数、实例方法或实例属性访问器中进行。</strong></p> 
<p><br><strong>示例：<br> 1. 在派生类中调用基类方法。</strong></p> 
<pre class="has"><code class="language-cs">using System;
public class BaseClass
{
    protected string _className = "BaseClass";
    public virtual void PrintName()
    {
        Console.WriteLine("Class Name: {0}", _className);
    }
}
class DerivedClass : BaseClass
{
    public string _className = "DerivedClass";
    public override void PrintName()
    {
        Console.Write("The BaseClass Name is {0}");
        //调用基类方法
        base.PrintName();
        Console.WriteLine("This DerivedClass is {0}", _className);
    }
}
class TestApp
{
    public static void Main()
    {
        DerivedClass dc = new DerivedClass();
        dc.PrintName();
    }
}</code></pre> 
<p><strong>2. 在派生类中调用基类构造函数。</strong></p> 
<pre class="has"><code class="language-cs">// keywords_base2.cs
using System;
public class BaseClass
{
    int num;
    public BaseClass()
    {
        Console.WriteLine("in BaseClass()");
    }
    public BaseClass(int i)
    {
        num = i;
        Console.WriteLine("in BaseClass(int {0})", num);
    }
}
public class DerivedClass : BaseClass
{
    // 该构造器调用  BaseClass.BaseClass()
    public DerivedClass()
        : base()
    {
    }
    // 该构造器调用 BaseClass.BaseClass(int i)
    public DerivedClass(int i)
        : base(i)
    {
    }
    static void Main()
    {
        DerivedClass dc = new DerivedClass();
        DerivedClass dc1 = new DerivedClass(1)();
        Console.ReadLine();
    }
}</code></pre> 
<p><strong>注意：<br> 从静态方法中使用 base 关键字是错误的。<br> base 主要用于面向对象开发的对态这方面，在示例2中有体现。</strong></p> 
<p><strong> </strong></p> 
<p><strong>关于this</strong></p> 
<p><strong>this 关键字引用类的当前实例。<br> 以下是 this 的常用用途：<br> 限定被相似的名称隐藏的成员<br> 将对象作为参数传递到其他方法<br> 声明索引器</strong></p> 
<p><br><strong>示例：</strong></p> 
<pre class="has"><code class="language-cs">// this 关键字
// keywords_this.cs
using System;
class Employee
{
    private string _name;
    private int _age;
    private string[] _arr = new string[5];
    public Employee(string name, int age)
    {
        // 使用this限定字段，name与age
        this._name = name;
        this._age = age;
    }
    public string Name
    {
        get { return this._name; }
    }
    public int Age
    {
        get { return this._age; }
    }
    // 打印雇员资料
    public void PrintEmployee()
    {
        // 将Employee对象作为参数传递到DoPrint方法
        Print.DoPrint(this);
    }
    // 声明索引器
    public string this[int param]
    {
        get { return _arr[param]; }
        set { _arr[param] = value; }
    }
}
class Print
{
    public static void DoPrint(Employee e)
    {
        Console.WriteLine("Name: {0}\nAge: {1}", e.Name, e.Age);
    }
}
class TestApp
{
    static void Main()
    {
        Employee E = new Employee("Hunts", 21);
        E[0] = "Scott";
        E[1] = "Leigh";
        E[4] = "Kiwis";
        E.PrintEmployee();
        for (int i = 0; i &lt; 5; i++)
        {
            Console.WriteLine("Friends Name: {0}", E[i]);
        }
        Console.ReadLine();
    }
}</code></pre> 
<p> </p> 
<p>转：<a href="https://www.cnblogs.com/eedc/p/6343201.html" rel="nofollow">https://www.cnblogs.com/eedc/p/6343201.html</a></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ff9f665cb43f96a32e265a332ee5116a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LAMMPS命令行-partition选项的理解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/44daa03ebcefd385e0ef0e3626e1dd42/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java - 获取PDF文档的总页数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>