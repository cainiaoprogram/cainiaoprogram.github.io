<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>初探AFL-Fuzz - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="初探AFL-Fuzz" />
<meta property="og:description" content="AFL-Fuzz介绍 Fuzzing是指通过构造测试输入，对软件进行大量测试来发现软件中的漏洞的一种模糊测试方法。在CTF中，fuzzing可能不常用，但在现实的漏洞挖掘中，fuzzing因其简单高效的优势，成为非常主流的漏洞挖掘方法。
AFL则是fuzzing的一个很好用的工具，全称是American Fuzzy Lop，由Google安全工程师Michał Zalewski开发的一款开源fuzzing测试工具，可以高效地对二进制程序进行fuzzing，挖掘可能存在的内存安全漏洞，如栈溢出、堆溢出、UAF、double free等。由于需要在相关代码处插桩，因此AFL主要用于对开源软件进行测试。当然配合QEMU等工具，也可对闭源二进制代码进行fuzzing，但执行效率会受到影响
工作原理：
通过对源码进行重新编译时进行插桩（简称编译时插桩）的方式自动产生测试用例来探索二进制程序内部新的执行路径。AFL也支持直接对没有源码的二进制程序进行测试，但需要QEMU的支持。
安装 直接去官网下载压缩包，解压后在目录中打开终端输入：
makesudo make install 输入以上命令后基本就能安装成功了，在终端输入afl-后tab，就能出现以下这些命令了
说明安装成功
使用AFL插桩程序（有源码） 这里就以一个简单的c语言的程序作为例子来试试
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;signal.h&gt; int vuln(char *str) { int len = strlen(str); if(str[0] == &#39;A&#39; &amp;&amp; len == 66) { raise(SIGSEGV); //如果输入的字符串的首字符为A并且长度为66，则异常退出 } else if(str[0] == &#39;F&#39; &amp;&amp; len == 6) { raise(SIGSEGV); //如果输入的字符串的首字符为F并且长度为6，则异常退出 } else { printf(&#34;it is good!\n&#34;); } return 0; } int main(int argc, char *argv[]) { char buf[100]={0}; gets(buf);//存在栈溢出漏洞 printf(buf);//存在格式化字符串漏洞 vuln(buf); return 0; } 总的流程概述：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3b7b7e1cacba4d7c10ff8dab175413a9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-27T14:29:55+08:00" />
<meta property="article:modified_time" content="2020-09-27T14:29:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">初探AFL-Fuzz</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 id="toc-0">AFL-Fuzz介绍</h2> 
<p>Fuzzing是指通过构造测试输入，对软件进行大量测试来发现软件中的漏洞的一种模糊测试方法。在CTF中，fuzzing可能不常用，但在现实的漏洞挖掘中，fuzzing因其简单高效的优势，成为非常主流的漏洞挖掘方法。</p> 
<p>AFL则是fuzzing的一个很好用的工具，全称是American Fuzzy Lop，由Google安全工程师Michał Zalewski开发的一款开源fuzzing测试工具，可以高效地对二进制程序进行fuzzing，挖掘可能存在的内存安全漏洞，如栈溢出、堆溢出、UAF、double free等。由于需要在相关代码处插桩，因此AFL主要用于对开源软件进行测试。当然配合QEMU等工具，也可对闭源二进制代码进行fuzzing，但执行效率会受到影响</p> 
<p>工作原理：</p> 
<p>通过对源码进行重新编译时进行插桩（简称编译时插桩）的方式自动产生测试用例来探索二进制程序内部新的执行路径。AFL也支持直接对没有源码的二进制程序进行测试，但需要QEMU的支持。</p> 
<h2 id="toc-1">安装</h2> 
<p>直接去<a href="http://lcamtuf.coredump.cx/afl/" rel="nofollow">官网</a>下载压缩包，解压后在目录中打开终端输入：</p> 
<ul><li>make</li><li>sudo make install</li></ul> 
<p>输入以上命令后基本就能安装成功了，在终端输入afl-后tab，就能出现以下这些命令了</p> 
<p><img alt="" height="66" src="https://images2.imgbox.com/5b/76/gZnV7ZMH_o.png" width="702"></p> 
<p>说明安装成功</p> 
<h2 id="toc-2">使用AFL插桩程序（有源码）</h2> 
<p>这里就以一个简单的c语言的程序作为例子来试试</p> 
<pre>#include &lt;stdio.h&gt; 
#include &lt;stdlib.h&gt; 
#include &lt;unistd.h&gt; 
#include &lt;string.h&gt; 
#include &lt;signal.h&gt; 

int vuln(char *str)
{
    int len = strlen(str);
    if(str[0] == 'A' &amp;&amp; len == 66)
    {
        raise(SIGSEGV);
        //如果输入的字符串的首字符为A并且长度为66，则异常退出
    }
    else if(str[0] == 'F' &amp;&amp; len == 6)
    {
        raise(SIGSEGV);
        //如果输入的字符串的首字符为F并且长度为6，则异常退出
    }
    else
    {
        printf("it is good!\n");
    }
    return 0;
}

int main(int argc, char *argv[])
{
    char buf[100]={0};
    gets(buf);//存在栈溢出漏洞
    printf(buf);//存在格式化字符串漏洞
    vuln(buf);

    return 0;
}
</pre> 
<p>总的流程概述：</p> 
<p>首先是用afl-gcc编译源代码，然后以文件(最好小于1K)为输入，然后启动afl-fuzz程序，将testcase(输入的测试文件)作为程序的输入执行程序，afl会在这个testcase的基础上进行自动变异输入，使得程序产生crash，产生了crash就会被记录起来</p> 
<h3 id="toc-3">插桩编译</h3> 
<p>首先把上面的afl_test.c进行编译：</p> 
<p><strong>afl-gcc -g -o afl_test afl_test.c</strong></p> 
<p>同样的，如果是编译一个c++的源码，那就需要用afl-g++</p> 
<p>接着建立两个文件夹：fuzz_in和fuzz_out，用来存放程序的输入和fuzz的输出结果</p> 
<p>在fuzz_in中还需要创建一个testcase文件，在这个程序的例子里，只需要随便输入一点东西就行了，那么testcase中就写aaa就可以了</p> 
<p><strong>注意</strong></p> 
<p>在编译项目时，通常有Makefile，这时就需要在Makefile中添加内容</p> 
<p>gcc/g++重新编译目标程序的方法是：<br> CC=/path/to/afl/afl-gcc ./configure<br> make clean all<br> 对于一个C++程序，要设置:<br> CXX=/path/to/afl/afl-g++.</p> 
<p>afl-clang和afl-clang++的使用方法类似。</p> 
<h3 id="toc-4">开始fuzz</h3> 
<p>对那些可以直接从stdin读取输入的目标程序来说，语法如下：<br> $ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program […params…]<br> 对从文件读取输入的目标程序来说，要用“@@”，语法如下：<br> $ ./afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@</p> 
<p>输入命令：<strong>afl-fuzz -i fuzz_in -o fuzz_out ./afl_test</strong></p> 
<p>表示，从fuzz_in中读取输入，输出放入fuzz_out中，afl_test是我们要进行fuzz的程序，-f参数表示：testcase的内容会作为afl_test的stdin</p> 
<p>接下来一般都会报错：</p> 
<p><img alt="" height="356" src="https://images2.imgbox.com/aa/4d/UfiJ0yPw_o.png" width="694"></p> 
<p>需要根据提示设置一波core_pattern</p> 
<ul><li>sudo su</li><li>echo core &gt;/proc/sys/kernel/core_pattern</li></ul> 
<p>再次执行<strong>afl-fuzz -i fuzz_in -o fuzz_out ./afl_test</strong></p> 
<h3 id="toc-5">AFL界面</h3> 
<p>进入fuzz后，就会出现这样的界面</p> 
<p><img alt="" height="442" src="https://images2.imgbox.com/e8/30/gNrDsPHb_o.png" width="696"></p> 
<p>下面对界面进行一波介绍：</p> 
<p><code>process timing</code></p> 
<p>这里展示了当前fuzzer的运行时间、最近一次发现新执行路径的时间、最近一次崩溃的时间、最近一次超时的时间。</p> 
<p>值得注意的是第2项，最近一次发现新路径的时间。如果由于目标二进制文件或者命令行参数出错，那么其执行路径应该是一直不变的，所以如果从fuzzing开始一直没有发现新的执行路径，那么就要考虑是否有二进制或者命令行参数错误的问题了。对于此状况，AFL也会智能地进行提醒</p> 
<p><code>overall results</code></p> 
<p>这里包括运行的总周期数、总路径数、崩溃次数、超时次数。</p> 
<p>其中，总周期数可以用来作为何时停止fuzzing的参考。随着不断地fuzzing，周期数会不断增大，其颜色也会由洋红色，逐步变为黄色、蓝色、绿色。一般来说，当其变为绿色时，代表可执行的内容已经很少了，继续fuzzing下去也不会有什么新的发现了。此时，我们便可以通过Ctrl-C，中止当前的fuzzing</p> 
<p><code>stage progress</code></p> 
<p>这里包括正在测试的fuzzing策略、进度、目标的执行总次数、目标的执行速度</p> 
<p>执行速度可以直观地反映当前跑的快不快，如果速度过慢，比如低于500次每秒，那么测试时间就会变得非常漫长。如果发生了这种情况，那么我们需要进一步调整优化我们的fuzzing</p> 
<p>以上是简单的介绍，如果要看完整的可以查看<a href="http://lcamtuf.coredump.cx/afl/status_screen.txt" rel="nofollow">官方的文档</a></p> 
<h3 id="toc-6">分析crash</h3> 
<p>通过上图，我们发现跑了五分钟以后就发现了6个crash</p> 
<p>这时，可以去我们先前建立的fuzz_out目录看看产生了啥东西：</p> 
<p><img alt="" height="245" src="https://images2.imgbox.com/d9/87/X5Qo8E0k_o.png" width="662"></p> 
<p>crashes文件夹里面是我们产生crash的样例，hangs里面是产生超时的样例，queue里面是每个不同执行路径的测试用例</p> 
<p>我们来看看crash的6个样例：</p> 
<p>第一个样例，发现符合栈溢出漏洞的crash情况</p> 
<p><img alt="" height="203" src="https://images2.imgbox.com/50/eb/mTCTmiVq_o.png" width="697"></p> 
<p>第二个样例，发现符合首字符为F且字符串长度为6的异常退出情况</p> 
<p><img alt="" height="62" src="https://images2.imgbox.com/65/d0/k3CjMnmz_o.png" width="699"></p> 
<p>第三个样例，发现符合格式化字符串的%n任意地址写的漏洞情况</p> 
<p><img alt="" height="76" src="https://images2.imgbox.com/4a/ba/B6nxunHH_o.png" width="695"></p> 
<p>第四个样例，发现符合栈溢出漏洞的crash情况</p> 
<p><img alt="" height="164" src="https://images2.imgbox.com/90/0e/6AeUni1z_o.png" width="697"></p> 
<p>第五个样例，发现符合栈溢出漏洞的crash情况</p> 
<p><img alt="" height="191" src="https://images2.imgbox.com/e8/de/rVvJnOIz_o.png" width="696"></p> 
<p>第六个样例，发现符合首字符为A且字符串长度为66的异常退出情况</p> 
<p><img alt="" height="130" src="https://images2.imgbox.com/88/96/Q248a88t_o.png" width="701"></p> 
<p>至此，我们自己编写的简单程序的所有漏洞都被检测出来了，这个过程只用了5分钟，afl可以说是很强大的</p> 
<h2 id="toc-7">无源码AFL测试</h2> 
<p>上面是对进简单的有源码的程序进行测试的，但是实际情况下不可能每次都有源码进行插桩编译测试，afl使用了qemu模式进行测试，只要在之前的命令的基础上加上-Q的参数即可</p> 
<p>但是要先进行安装,在afl的根目录打开终端执行以下命令</p> 
<ul><li> <p>cd qemu_mode</p> </li><li> <p>./build_qemu_support.sh</p> </li><li>cd ..</li><li>make install</li></ul> 
<h3 id="toc-8">简单无源码fuzz</h3> 
<p>接着还是用上面的简单c代码进行测试，但是这次采用gcc进行编译，不再用afl-gcc</p> 
<ul><li>gcc -g -o afl_test2 afl_test.c</li></ul> 
<p>得到afl_test2程序后，就可以进行fuzz了</p> 
<p>同样的要在开始fuzz前创建fuzz_in 、fuzz_out两个文件夹</p> 
<p>执行命令：</p> 
<ul><li>afl-fuzz -i fuzz_in -o fuzz_out -Q ./afl_test2</li></ul> 
<p>结果我们可以看到;</p> 
<p><img alt="" height="458" src="https://images2.imgbox.com/f8/df/w49lmqV6_o.png" width="699"></p> 
<p>同样的程序，在qemu 模式下比在源码编译插桩的模式下慢了很多，同样五分钟的时间，只爆了4个crash，执行速度也只有600+/s，和之前的4700+/s形成鲜明对比</p> 
<h3 id="toc-9">fuzz readelf</h3> 
<p>这里再用一个例子来fuzz一下，测试readelf</p> 
<p>由于readelf的输入其实就elf文件，因此需要在in目录中放一个输入elf</p> 
<p>按照流程创建文件夹和测试用的elf</p> 
<ul><li>mkdir in out</li><li>cd in</li><li>cp afl-2.52b/testcases/others/elf/small_exec.elf . #afl目录中自带一些常用文件的testcase</li><li>cd ..</li><li>sudo cp /usr/bin/readelf . #把readelf复制到当前目录中来</li><li>afl-fuzz -i in -o out -Q ./readelf -a @@ #开始fuzz，@@表示从in文件夹中找elf作为输入，实际上就是在执行：readelf -a 文件名</li></ul> 
<p><img alt="" height="411" src="https://images2.imgbox.com/02/6c/IoGN1rae_o.png" width="699"></p> 
<p>可以看到，这里我跑了51分钟，硬是第一轮都没跑完</p> 
<p><img alt="" height="441" src="https://images2.imgbox.com/36/35/nXXtzjzD_o.png" width="698"></p> 
<h2 id="toc-10">参考资料</h2> 
<p><a href="http://galaxylab.org/afl%E4%BD%BF%E7%94%A8101/" rel="nofollow">http://galaxylab.org/afl%E4%BD%BF%E7%94%A8101/</a></p> 
<p><a href="https://www.freebuf.com/articles/system/191536.html" rel="nofollow">https://www.freebuf.com/articles/system/191536.html</a></p> 
<p><a href="https://blog.csdn.net/abcdyzhang/article/details/53727221">https://blog.csdn.net/abcdyzhang/article/details/53727221</a></p> 
<p><a href="https://stfpeak.github.io/2017/06/11/Finding-bugs-using-AFL/#afl%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" rel="nofollow">https://stfpeak.github.io/2017/06/11/Finding-bugs-using-AFL/#afl%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B</a></p> 
<p><a href="https://blog.csdn.net/qq_36779888/article/details/79998920">https://blog.csdn.net/qq_36779888/article/details/79998920</a></p> 
<p><a href="https://www.cnblogs.com/WangAoBo/p/8280352.html#_label4" rel="nofollow">https://www.cnblogs.com/WangAoBo/p/8280352.html#_label4</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/deebe00d3e3454a8a3e79f95da625052/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">CHERRY 键盘 alt 组合键失灵或开始菜单键失灵</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d7258e45a56e404f7ea3588114a393b5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">springboot Json序列化时如何忽略部分字段</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>