<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>动态内存开辟  malloc  calloc  realloc  free  函数 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="动态内存开辟  malloc  calloc  realloc  free  函数" />
<meta property="og:description" content="一、malloc和free
malloc和free都是c语言的库函数，一般在stdlib.h中，主要用来进行一段动态内存的分配，包括申请和释放。
malloc的函数原型为Void *malloc(size_t size)，主要用于从堆上进行一段内存的申请，返回无类型的指针，需要将返回的指针转换为数据的类型，同时对申请的数据不进行初始化。
free用于将一段指针所指向的内存进行释放，free(p);由于通过malloc申请的内存在系统中记录了长度，因此不需要传入内存的长度。
二、malloc、calloc和realloc的比较
malloc的功能如上所述，calloc是用来进行堆空间的内存申请， 函数原型为void *calloc(size_t numElements，size_t sizeOfElement)；参数为申请内存元数的个数，以及类型的长度，因此不必计算所要分配的内存的总字节数，同时alloc会对申请的内存进行初始化为0；
malloc和calloc所申请的内存均位于堆空间。malloc由于不需要对所申请的内存进行初始化，因此比calloc的效率要高。
realloc相当于改变指向动态内存区的指针的指向，让它指向新的动态内存地址；函数原型为extern void *realloc(void *mem_address, unsigned int newsize);一般分配了内存之后，如果重新分配内存，当之前分配的内存够用时指针不变，但要分配更大的内存空间时，采用尾部扩展的方式和新开辟一块内存（数据移动了），并返回内存首地址的指针。
#define MEM_BLOCK_SIZE 4096 #define MEM_LARGE_BLOCK_THRESHOLD 40960 //&gt;MEM_LARGE_BLOCK_THRESHOLD :requested size is large block #define MEM_BASE_ADDRESS (0x90000000) #define MEM_ALLOC_TABLE_FIRST_ENTRY 0 #define MAX_MEM_SIZE 7*1024*1024 #define MEM_ALLOC_TABLE_SIZE (MAX_MEM_SIZE/MEM_BLOCK_SIZE) static INT16 memory_map[MEM_ALLOC_TABLE_SIZE]; static char isMemoryManagementReady=0; void *memset(void *s, int c, size_t count) { char *xs = s; while (count--) *xs&#43;&#43; = c; return s; } INT32 ssd_mem_init(void) { memset(memory_map, 0, sizeof(memory_map)); isMemoryManagementReady=1; } INT16 ssd_mem_percentage_used() { int used=0; int i; for(i=0;i&lt;MEM_ALLOC_TABLE_SIZE;i&#43;&#43;) { if(memory_map[i]) { used&#43;&#43;; } } return used*100/MEM_ALLOC_TABLE_SIZE; } //return -1:FAIL //&gt;=0: return allocated address offset INT32 ssd_mem_malloc(UINT32 size) { int offset=0; int startEntry=MEM_ALLOC_TABLE_FIRST_ENTRY; int nmemb; int i; if(!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2d2a46a946bc16dc276e4ef0185b7eeb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-11-28T17:13:30+08:00" />
<meta property="article:modified_time" content="2017-11-28T17:13:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">动态内存开辟  malloc  calloc  realloc  free  函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style='margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; word-wrap:break-word; word-break:normal; color:rgb(69,69,69); font-family:"PingFang SC","Microsoft YaHei",SimHei,Arial,SimSun'> <span style="margin:0px; padding:0px"><span style="font-size:14px">一、malloc和free</span></span></p> 
<p style='margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; word-wrap:break-word; word-break:normal; color:rgb(69,69,69); font-family:"PingFang SC","Microsoft YaHei",SimHei,Arial,SimSun'> <span style="margin:0px; padding:0px; font-family:KaiTi_GB2312"><span style="font-size:12px">malloc和free都是c语言的库函数，一般在stdlib.h中，主要用来进行一段动态内存的分配，包括申请和释放。</span></span></p> 
<p style='margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; word-wrap:break-word; word-break:normal; color:rgb(69,69,69); font-family:"PingFang SC","Microsoft YaHei",SimHei,Arial,SimSun'> <span style="margin:0px; padding:0px; font-family:KaiTi_GB2312"><span style="font-size:12px">malloc的函数原型为Void *malloc(size_t size)，主要用于从堆上进行一段内存的申请，返回无类型的指针，需要将返回的指针转换为数据的类型，同时对申请的数据不进行初始化。</span></span></p> 
<p style='margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; word-wrap:break-word; word-break:normal; color:rgb(69,69,69); font-family:"PingFang SC","Microsoft YaHei",SimHei,Arial,SimSun'> <span style="margin:0px; padding:0px; font-family:KaiTi_GB2312; color:rgb(51,51,51)"><span style="font-size:12px">free用于将一段指针所指向的内存进行释放，free(p);由于通过malloc申请的内存在系统中记录了长度，因此不需要传入内存的长度。</span></span></p> 
<p style='margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; word-wrap:break-word; word-break:normal; color:rgb(69,69,69); font-family:"PingFang SC","Microsoft YaHei",SimHei,Arial,SimSun'> <span style="font-size:14px"><span style="margin:0px; padding:0px; font-family:Georgia; color:rgb(51,51,51)"></span><span style="margin:0px; padding:0px"> </span></span></p> 
<p style='margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; word-wrap:break-word; word-break:normal; color:rgb(69,69,69); font-family:"PingFang SC","Microsoft YaHei",SimHei,Arial,SimSun'> <span style="margin:0px; padding:0px; font-family:SimHei; color:rgb(51,51,51)"><span style="font-size:14px">二、malloc、calloc和realloc的比较</span></span></p> 
<p style='margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; word-wrap:break-word; word-break:normal; color:rgb(69,69,69); font-family:"PingFang SC","Microsoft YaHei",SimHei,Arial,SimSun'> <span style="margin:0px; padding:0px; font-family:Georgia; color:rgb(51,51,51)"><span style="font-size:12px">malloc的功能如上所述，calloc是用来进行堆空间的内存申请，<span style="margin:0px; padding:0px"><span style="margin:0px; padding:0px"> 函数原型为</span>void *calloc(size_t numElements</span><span style="margin:0px; padding:0px">，</span><span style="margin:0px; padding:0px">size_t sizeOfElement)；参数为申请内存元数的个数，以及类型的长度，因此不必计算所要分配的内存的总字节数，同时alloc会对申请的内存进行初始化为0；</span></span></span></p> 
<p style='margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; word-wrap:break-word; word-break:normal; color:rgb(69,69,69); font-family:"PingFang SC","Microsoft YaHei",SimHei,Arial,SimSun'> <span style="margin:0px; padding:0px; font-family:Georgia; color:rgb(51,51,51)"><span style="font-size:12px">malloc和calloc所申请的内存均位于堆空间。malloc由于不需要对所申请的内存进行初始化，因此比calloc的效率要高。</span></span></p> 
<p style='margin-top:0px; margin-bottom:0px; padding-top:0px; padding-bottom:0px; word-wrap:break-word; word-break:normal; color:rgb(69,69,69); font-family:"PingFang SC","Microsoft YaHei",SimHei,Arial,SimSun'> <span style="margin:0px; padding:0px; font-family:Georgia; color:rgb(51,51,51)"><span style="font-size:12px">realloc相当于改变指向动态内存区的指针的指向，让它指向新的动态内存地址；函数原型为</span><span style="margin:0px; padding:0px"><span style="font-size:12px">extern void *realloc(void *mem_address, unsigned int newsize);</span><span style="margin:0px; padding:0px"><span style="font-size:12px">一般分配了内存之后，如果重新分配内存，当之前分配的内存够用时指针不变，但要分配更大的内存空间时，采用尾部扩展的方式和新开辟一块内存（数据移动了），并返回内存首地址的指针。</span></span></span></span></p> 
<pre><code class="language-cpp">#define MEM_BLOCK_SIZE 4096  
#define MEM_LARGE_BLOCK_THRESHOLD       40960       //&gt;MEM_LARGE_BLOCK_THRESHOLD :requested size is large block   
#define MEM_BASE_ADDRESS                (0x90000000)  
#define MEM_ALLOC_TABLE_FIRST_ENTRY 0  
#define MAX_MEM_SIZE 7*1024*1024  
#define MEM_ALLOC_TABLE_SIZE    (MAX_MEM_SIZE/MEM_BLOCK_SIZE)  
static INT16 memory_map[MEM_ALLOC_TABLE_SIZE];  
static char isMemoryManagementReady=0;  
void *memset(void *s, int c, size_t count)  
{  
    char *xs = s;  
    while (count--)  
        *xs++ = c;  
    return s;  
}  
  
INT32 ssd_mem_init(void)  
{  
    memset(memory_map, 0, sizeof(memory_map));  
    isMemoryManagementReady=1;  
}  
INT16   ssd_mem_percentage_used()  
{  
    int used=0;  
    int i;  
    for(i=0;i&lt;MEM_ALLOC_TABLE_SIZE;i++)  
    {  
        if(memory_map[i])  
        {  
            used++;  
        }  
    }  
    return used*100/MEM_ALLOC_TABLE_SIZE;  
}  
//return -1:FAIL  
//&gt;=0:   return allocated address offset  
INT32 ssd_mem_malloc(UINT32 size)  
{  
    int offset=0;  
    int startEntry=MEM_ALLOC_TABLE_FIRST_ENTRY;  
    int nmemb;  
    int i;  
    if(!isMemoryManagementReady)  
    {  
           ssd_mem_init();  
    }  
      
    if(size==0)  
    {  
        return -1;  
    }  
    nmemb=size/MEM_BLOCK_SIZE;  
    if(size%MEM_BLOCK_SIZE)  
    {  
        nmemb++;  
    }  
          
    if(size &gt; MEM_LARGE_BLOCK_THRESHOLD)  
    {  
        for(offset=startEntry;offset&lt;MEM_ALLOC_TABLE_SIZE-nmemb;offset++)  
        {  
            if(!memory_map[offset])   
            {  
                int vacantSize=0;  
                for(vacantSize=0;vacantSize&lt;nmemb &amp;&amp; !memory_map[offset+vacantSize];vacantSize++);  
                if(vacantSize==nmemb)  
                {  
                    for(i=0;i&lt;nmemb;i++)  
                    {  
                        memory_map[offset+i]=nmemb;  
                    }  
                    return (offset*MEM_BLOCK_SIZE);  
                }  
            }  
        }  
    }  
    else  
    {  
        for(offset=MEM_ALLOC_TABLE_SIZE-1;offset&gt;=0;offset--)  
        {     
            if(!memory_map[offset] &amp;&amp; ((offset+nmemb)&lt;=MEM_ALLOC_TABLE_SIZE))//search start of vacant block  
            {  
                
                int vacantSize=0;  
                for(vacantSize=0;vacantSize&lt;nmemb &amp;&amp; !memory_map[offset+vacantSize];vacantSize++);  
                if(vacantSize==nmemb)  
                {  
                    for(i=0;i&lt;nmemb;i++)  
                    {  
                        memory_map[offset+i]=nmemb;  
                    }  
                    return (offset*MEM_BLOCK_SIZE);  
                }  
            }  
        }  
    }  
    puts("malloc size erorr=");  
    putInt32(size);  
    return -1;  
}  
//return 0:OK  
//return 1:Out of bound  
INT32 ssd_mem_free(INT32 offset)  
{  
    int i;  
    if(!isMemoryManagementReady)  
    {  
        ssd_mem_init();  
        return 1;  
    }  
    if(offset&lt;MAX_MEM_SIZE)  
    {  
        int index=offset/MEM_BLOCK_SIZE;  
        int nmemb=memory_map[index];  
        for(i=0;i&lt;nmemb;i++)  
        {  
            memory_map[index+i]=0;  
        }  
        return 0;  
    }  
    else  
    {  
       return 1;//out of bound  
    }  
}  
void free(void *ptr)  
{  
    if(ptr==NULL)  
        return;  
    INT32 offset;  
    offset=ptr-MEM_BASE_ADDRESS;  
    ssd_mem_free(offset);     
}  
void * malloc(UINT32 size)  
{  
    INT32 offset;  
    offset=ssd_mem_malloc(size);  
    if(offset==-1)  
        {  
        return NULL;  
        }  
    else  
        return MEM_BASE_ADDRESS+offset;  
      
}  
  
void *realloc(void *ptr,UINT32 size)  
{  
    INT32 offset;  
    offset=ssd_mem_malloc(size);  
    if(offset==-1)  
        {  
        puts("realloc error/n");  
        return NULL;  
        }  
    else  
        {  
            memcpy((void*)(MEM_BASE_ADDRESS+offset),ptr,size);  
            free(ptr);  
            return MEM_BASE_ADDRESS+offset;       
        }  
}  </code></pre> 
<br> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7e1c9f4d3ebb45caee4db19be7f60036/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">算法题：直方图和0-1矩阵中最大矩形</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/05df516bb9f6ac8db3ef7c84f1a04901/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">groovy闭包</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>