<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>并发模拟的四种方式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="并发模拟的四种方式" />
<meta property="og:description" content="一、Postman
Postman 是一个款 HTTP 请求模拟工具
首先演示一下 Postman 最基本的使用，创建一个 Spring Boot 项目，测试的代码如下：
import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(&#34;test&#34;) public class TestConrtoller { @GetMapping(&#34;demo&#34;) public String testDemo() { return &#34;result~&#34;; } } 为了便于操作，一般会将
http://127.0.0.1:8080 是经常使用的地址&#43;端口号，可以设置为环境，点击右上角的设置图标
选择 global
输入信息
以后再进行测试就能这样搞简写了
知道基本使用之后，我们来看一下如何模拟并发测试
填写基本信息后，创建：
这个时候会创建出Concurrency的文件夹，我们可以把刚才测试的demo的例子放进这个文件夹下：
这个时候就可以在Concurrency下看到这个接口测试了
选择并发测试：
这个时候弹出我们想要的框了
点击 Run Concurrency
你可以立马感觉到 CPU 在“燃烧”，因为要记录并打印日志，显示的话是一条一条来的，其实测试的速度，要比你看到的打印的日志的速度快，绿色表示正常
二、Apache Bench（AB）
ApacheBench 是 Apache 服务器自带的一个web压力测试工具，简称ab。
ab又是一个命令行工具，对发起负载的本机要求很低，根据ab命令可以创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问，因此可以用来测试目标服务器的负载压力。总的来说ab工具小巧简单，上手学习较快，可以提供需要的基本性能指标，但是没有图形化结果，不能监控。
使用的话，首先需要安装 Apache 服务器
网站：传送门 http://httpd.apache.org/download.cgi
因为我的操作系统是 windows10， 这里选择 File for Microsoft Windows" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/395d0c042e561d2c9d105658dc943033/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-12-11T13:49:00+08:00" />
<meta property="article:modified_time" content="2021-12-11T13:49:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">并发模拟的四种方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p><strong>一、Postman</strong></p> 
 <p>Postman 是一个款 HTTP 请求模拟工具<br></p> 
 <p><img src="https://images2.imgbox.com/a8/14/z0t5D79a_o.png" alt="460951885762dcab034892b16487d0f5.png"></p> 
 <p> 首先演示一下 Postman 最基本的使用，创建一个 Spring Boot 项目，测试的代码如下：</p> 
 <pre class="has"><code class="language-go">import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("test")
public class TestConrtoller {

    @GetMapping("demo")
    public String testDemo() {
        return "result~";
    }
}</code></pre> 
 <p><img src="https://images2.imgbox.com/80/61/Eryj5Cr7_o.png" alt="8cfebed37fc429395e7782429a0b6ef2.png"></p> 
 <p>为了便于操作，一般会将</p> 
 <p>http://127.0.0.1:8080 是经常使用的地址+端口号，可以设置为环境，点击右上角的设置图标</p> 
 <p><img src="https://images2.imgbox.com/0a/95/bXKUyA17_o.png" alt="6c3db959d1c01816ac7d49ccde5047bf.png"></p> 
 <p> 选择 global<br></p> 
 <p><img src="https://images2.imgbox.com/8e/b3/8JEMLfMy_o.png" alt="89f55c289c77bc83963ff95aae9c93da.png"></p> 
 <p>输入信息<br></p> 
 <p><img src="https://images2.imgbox.com/20/46/khyMymzn_o.png" alt="7ebbd1d311684185c976eacb200f4d28.png"></p> 
 <p> 以后再进行测试就能这样搞简写了<br></p> 
 <p><img src="https://images2.imgbox.com/a9/43/g2olZUtL_o.png" alt="22974c3b7f468d63ee8661119e1e7c05.png"></p> 
 <p>知道基本使用之后，我们来看一下如何模拟并发测试</p> 
 <p><img src="https://images2.imgbox.com/8c/79/HpbycgMa_o.png" alt="0b8b67b635892f4828fce3a03ef05696.png"></p> 
 <p> 填写基本信息后，创建：<br></p> 
 <p><img src="https://images2.imgbox.com/42/61/2j40iLbB_o.png" alt="0fcff5876271c65ed9bb340641bc3805.png"></p> 
 <p> 这个时候会创建出Concurrency的文件夹，我们可以把刚才测试的demo的例子放进这个文件夹下：</p> 
 <p><img src="https://images2.imgbox.com/90/78/RAMjjTrI_o.png" alt="f2665383e0a83309e463339b0b76d40e.png"></p> 
 <p><img src="https://images2.imgbox.com/9f/10/dHqIR1Cq_o.png" alt="f6920dcf755d1e9d8282cf74a36b8111.png"></p> 
 <p> 这个时候就可以在Concurrency下看到这个接口测试了<br></p> 
 <p><img src="https://images2.imgbox.com/c5/e3/lWk1kTYR_o.png" alt="180d2e85bbb2f77549f1eca2c655423c.png"></p> 
 <p> 选择并发测试：<br></p> 
 <p><img src="https://images2.imgbox.com/81/5d/b1J5NawI_o.png" alt="e7ad9e3c6f65a4387780e519f5996b9d.png"></p> 
 <p>这个时候弹出我们想要的框了<br></p> 
 <p><img src="https://images2.imgbox.com/58/a4/dPBnmoN9_o.png" alt="5f25adab40b7d77d2cf48f156a24a8b1.png"></p> 
 <p>点击 Run Concurrency</p> 
 <p>你可以立马感觉到 CPU 在“燃烧”，因为要记录并打印日志，显示的话是一条一条来的，其实测试的速度，要比你看到的打印的日志的速度快，绿色表示正常</p> 
 <p><img src="https://images2.imgbox.com/61/7c/CSDQ33RM_o.png" alt="e927ce432bc2e909d546ea3dc8c6fa39.png"></p> 
 <p>二、Apache Bench（AB）</p> 
 <p>ApacheBench 是 Apache 服务器自带的一个web压力测试工具，简称ab。</p> 
 <p>ab又是一个命令行工具，对发起负载的本机要求很低，根据ab命令可以创建很多的并发访问线程，模拟多个访问者同时对某一URL地址进行访问，因此可以用来测试目标服务器的负载压力。总的来说ab工具小巧简单，上手学习较快，可以提供需要的基本性能指标，但是没有图形化结果，不能监控。</p> 
 <p>使用的话，首先需要安装 Apache 服务器</p> 
 <p>网站：传送门 http://httpd.apache.org/download.cgi</p> 
 <p>因为我的操作系统是 windows10， 这里选择 File for Microsoft Windows</p> 
 <p>Linux下的安装是非常简单的，这里不再演示</p> 
 <p><img src="https://images2.imgbox.com/1c/d3/zPhqo9QE_o.png" alt="ebee25a61ff2f70681372c01f1f5eedf.png"></p> 
 <p>选择 ApacheHaus<br></p> 
 <p><img src="https://images2.imgbox.com/63/1f/7lfkltC4_o.png" alt="4bc0d78f26bcdfa260da3708acef3968.png"></p> 
 <p><br> 进入下载页面 选择适合自己电脑的版本<br></p> 
 <p><img src="https://images2.imgbox.com/7f/1b/3q9U2yKT_o.png" alt="8e2d09acd33e63cbe647e856a14501ba.png"></p> 
 <p>文件解压到本地文件夹下，如果不是解压在c盘，需要设置参数，注意文件路径最好都是英文，关于需要设置参数，conf-&gt;httpd.conf 使用文本编辑器打开，需要修改的有三个地方：</p> 
 <p><img src="https://images2.imgbox.com/22/a3/FtlSF1Qi_o.png" alt="c3addc388f388da9706cfc33ff5da02b.png"></p> 
 <p><img src="https://images2.imgbox.com/c4/c4/eI4M6ll7_o.png" alt="85b4842dd82448336b31349f851f6da1.png"></p> 
 <p>运行根目录，修改成自己解压到本地的路径<br></p> 
 <p><img src="https://images2.imgbox.com/59/1c/owwbcARq_o.png" alt="625eea6148ed9e18fb391de743db950e.png"></p> 
 <p>监听端口，默认监听端口是80，如果已被使用会报错需要修改，如果80端口未被使用，可不修改；如果修改了监听端口，则需要把ServerName localhost也相应改成同样的端 口号<br></p> 
 <p><img src="https://images2.imgbox.com/25/42/0Te0wHuD_o.png" alt="40f2f8b0badcff8a70281bf7adc3df89.png"></p> 
 <p><img src="https://images2.imgbox.com/9f/be/zqgsThxO_o.png" alt="fcedae323212244718059bf39fbf3439.png"></p> 
 <p>DocumentRoot 测试文件存放地，且该目录必须存在<br></p> 
 <p><img src="https://images2.imgbox.com/ae/cd/p1PXh9Kq_o.png" alt="2c8893507d1a4ec265bcf99b35454680.png"></p> 
 <p>配置完成后，命令行cmd进入 D:\softUtil\Apache24\bin 目录下</p> 
 <pre class="has"><code class="language-go">httpd.exe -k install</code></pre> 
 <p><img src="https://images2.imgbox.com/cf/59/o6h1oWQi_o.png" alt="22fbb48d7d4db3ec43db5ae9a039a162.png"></p> 
 <p>启动：<br></p> 
 <pre class="has"><code class="language-go">httpd.exe -k start</code></pre> 
 <p>测试:</p> 
 <p>-n :请求数<br> -c: 并发数</p> 
 <p><img src="https://images2.imgbox.com/7f/6a/oONj60KR_o.png" alt="e48c1ab7eba6836785cb3ec9e3a92194.png"></p> 
 <p>三、并发模拟工具JMeter</p> 
 <p>JMeter也是一款性能测试工具，是图形化的。下载地址：传送门 http://jmeter.apache.org/</p> 
 <p><img src="https://images2.imgbox.com/ab/ff/KNVbUJGS_o.png" alt="857404860947cbab92a67defcce023e2.png"></p> 
 <p>需要 Java8+ 的环境<br></p> 
 <p><img src="https://images2.imgbox.com/95/54/o6wv4DOc_o.png" alt="5c403b1e6052a6c32bb514296c48bb38.png"></p> 
 <p>解压到你觉得合适的目录下（注意最好是英文路径），进入它的 bin 目录下 启动 jmeter.bat 即可。<br></p> 
 <p><img src="https://images2.imgbox.com/79/07/KhVv7HCp_o.png" alt="a6301d582872b0bffe788a6c9f4b9b40.png"></p> 
 <p> 使用很简单，首先在测试计划部分新建一个线程组<br></p> 
 <p><img src="https://images2.imgbox.com/56/4a/qXy91x7Z_o.png" alt="29c6fe10b4db0eaafb53efa22db9fbf2.png"></p> 
 <p><img src="https://images2.imgbox.com/ab/67/bH0jDGdx_o.png" alt="c32ffef5a30f7478465e3ebb090b99d1.png"></p> 
 <p><img src="https://images2.imgbox.com/ba/90/SFAT59Hu_o.png" alt="6182d13d02204b993071f9b064be0421.png"></p> 
 <p>设置好基础信息后添加HTTP请求（基本信息设置好没有OK哈，直接添加HTTP请求）<br></p> 
 <p><img src="https://images2.imgbox.com/08/b4/qFMfpPax_o.png" alt="c94d85e303e262f65d29ac493df2980b.png"></p> 
 <p>填写HTTP请求相关的内容<br></p> 
 <p><img src="https://images2.imgbox.com/3f/51/3mEkyA94_o.png" alt="c783a883d5c90c25835f8bfc0701111e.png"></p> 
 <p>之后还要添加监听器，这里选择是图形结果<br></p> 
 <p><img src="https://images2.imgbox.com/e8/4e/3bmCX83z_o.png" alt="ef36cf20290fea49b32d4e9146aef8c4.png"></p> 
 <p>再添加一个查看结果树吧<br></p> 
 <p><img src="https://images2.imgbox.com/f9/9f/dm2MX5Ej_o.png" alt="66f1cff5944dcd7b8bbb0717f7920ed4.png"></p> 
 <p>在运行之前打开log Viewer<br></p> 
 <p><img src="https://images2.imgbox.com/d7/4f/a6fKmkEQ_o.png" alt="2767365055f1107046eac82c55b153cb.png"></p> 
 <p>下面开始运行：<br></p> 
 <p><img src="https://images2.imgbox.com/c4/fa/rf2UbU9L_o.png" alt="c64a79f054f23f36c048498cf8312041.png"></p> 
 <p>执行成功，来感受一下结果：<br></p> 
 <p><img src="https://images2.imgbox.com/e4/ff/DYUK9CDv_o.png" alt="25966fdc5e25189f206188bd11842ff5.png"></p> 
 <p>点进去<br></p> 
 <p><img src="https://images2.imgbox.com/25/73/LctvzvXC_o.png" alt="85ab9202150e8ba01940bbfb51a5b7bf.png"></p> 
 <p>查看结果树<br></p> 
 <p><img src="https://images2.imgbox.com/8d/15/tdAqRJm4_o.png" alt="91b20efa47e727ffa3ceaa015e71c1e7.png"></p> 
 <p>四、代码模拟</p> 
 <p>这里需要用到一个类，就是 CountDownLatch。CountDownLatch 是一个计数器闭锁，通过它可以完成类似于阻塞当前线程的功能，即：一个线程或多个线程一直等待，直到其他线程执行的操作完成。</p> 
 <p>CountDownLatch 用一个给定的计数器来初始化，该计数器的操作是原子操作，即同时只能有一个线程去操作该计数器。调用该类await方法的线程会一直处于阻塞状态，直到其他线程调用 countDown 方法使当前计数器的值变为零，每次调用 countDown 计数器的值减1。</p> 
 <p>当计数器值减至零时，所有因调用await()方法而处于等待状态的线程就会继续往下执行。这种现象只会出现一次，因为计数器不能被重置。下图和它的方法可以体现出来：</p> 
 <p><img height="400" width="400" src="https://images2.imgbox.com/10/33/US2h3lJW_o.png" alt="71e91596ece5dd464a5d0581d9d82f83.png"></p> 
 <p> CountDownLatch类只提供了一个构造器：</p> 
 <pre class="has"><code class="language-go">public CountDownLatch(int count) { };</code></pre> 
 <p>然后下面这 3 个方法是 CountDownLatch 类中最重要的方法(上图能够反映出来）</p> 
 <pre class="has"><code class="language-go">public void await() throws InterruptedException { }; 
public boolean await(long timeout, TimeUnit unit) throws InterruptedException { }; 
public void countDown() { };</code></pre> 
 <p>下面还需要看一个类 Semaphore</p> 
 <p>Semaphore 与 CountDownLatch 相似，不同的地方在于 Semaphore 的值被获取到后是可以释放的，并不像 CountDownLatch 那样一直减到底。</p> 
 <p>它也被更多地用来限制流量，类似阀门的 功能。如果限定某些资源最多有N个线程可以访问，那么超过N个主不允许再有线程来访问，同时当现有线程结束后，就会释放，然后允许新的线程进来。有点类似于锁的lock与 unlock过程。相对来说他也有两个主要的方法：</p> 
 <p>用于获取权限的acquire(),其底层实现与CountDownLatch.countdown()类似;用于释放权限的release()，其底层实现与acquire()是一个互逆的过程。</p> 
 <p>通过这两个类可以进行并发的模拟：</p> 
 <p>测试一下：</p> 
 <pre class="has"><code class="language-go">import lombok.extern.slf4j.Slf4j;
import java.util.concurrent.*;

@Slf4j
public class CuncurrencyTest {

    public static int clientTotal = 5000;
    public static int threadTotal = 200;
    public static int count = 0;
    public static void main(String[] args) throws InterruptedException {
        
        ExecutorService executorService = Executors.newCachedThreadPool();
        
        final Semaphore semaphore = new Semaphore(threadTotal);
        final CountDownLatch countDownLatch = new CountDownLatch(clientTotal);

        for (int i = 0; i &lt; clientTotal; i++) {
            executorService.execute(() -&gt; {
                try {
                    semaphore.acquire();
                    add();
                    semaphore.release();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                    log.error("exception",e);
                }
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        executorService.shutdown();
        log.info("count:{}",count);

    }

    private static void  add() {
        count++;
    }
}</code></pre> 
 <p>因为 count 不是线程安全的，且没有作防护措施，结果是错的<br></p> 
 <p><img src="https://images2.imgbox.com/a8/d8/dFVpgp4A_o.png" alt="99f7be564b3c591f0dbc57934733d1d9.png">上面是对代码的并发模拟的简单形式，值得注意的是，这里提到的两个类不是专门做并发模拟，它们的用途很广泛，等之后更新Java网络编程的东西的时候，还会详细介绍它们。</p> 
 <hr> 
 <p style="text-align:center;">【END】<br></p> 
 <p>如果看到这里，说明你喜欢这篇文章，请转发、点赞。微信搜索「web_resource」，关注后回复「进群」或者扫描下方二维码即可进入无广告交流群。</p> 
 <p style="text-align:center;">↓扫描二维码进群↓</p> 
 <p style="text-align:center;"><img src="https://images2.imgbox.com/bc/1a/2sA5rcCU_o.png" alt="4b6c5498533e71865549d70909ef2129.png"></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6e11fbc4bf7f30a4914ceac285aa47ef/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">推荐算法之隐语义模型(LFM)矩阵分解梯度下降算法实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d819152f296e3eff404f482f72471f52/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CTFhub【彩蛋】部分技能树解题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>