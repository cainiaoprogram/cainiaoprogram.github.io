<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MyBatis--03-- 一级缓存和二级缓存 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MyBatis--03-- 一级缓存和二级缓存" />
<meta property="og:description" content="什么叫缓存 将数据存放在程序内存中，用于减轻数据查询的压力，提升读取数据的速度，提高性能。
对于任何一个持久层框架，都有缓存机制；缓存在电脑中有一块真实的存储空间
Mybatis缓存 mybaits提供一级缓存，和二级缓存。
一级缓存（本地缓存）
sqlSession级别的缓存。（相当于一个方法内的缓存）二级缓存（全局缓存）
基于namespace名称空间级别的缓存.即一个mapper.xml对应一个缓存 一级缓存（本地缓存） 一级缓存基于sqlSession默认开启,在操作数据库时需要构造SqlSession对象，在对象中有一个HashMap用于存储缓存数据。不同的SqlSession之间的缓存数据区域是互相不影响的。
一级缓存的作用域是SqlSession范围的，当在同一个sqlSession中执行两次相同的sql语句时，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次查询时会从缓存中获取数据，不再去底层数据库查询，从而提高查询效率。
Mybatis的内部缓存使用一个HashMap，key为hashcode&#43;statementId&#43;sql语句。Value为查询出来的结果集映射成的java对象。
SqlSession执行insert、update、delete等操作commit后会清空该SQLSession缓存。
需要注意的是，如果SqlSession执行了DML操作（增删改），并且提交到数据库，MyBatis则会清空SqlSession中的一级缓存，这样做的目的是为了保证缓存中存储的是最新的信息，避免出现脏读现象。
当一个SqlSession结束后该SqlSession中的一级缓存也就不存在了。
关闭一级缓存后，再次访问，需要再次获取一级缓存，然后才能查找数据，否则会抛出异常。
案例: 第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。
如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。
第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。
二级缓存（全局缓存） Mybatis的二级缓存是指mapper映射文件。二级缓存的作用域是同一个namespace下的mapper映射文件内容，多个SqlSession共享。
Mybatis需要手动设置启动二级缓存。
二级缓存的作用域是mapper的同一个namespace。不同的sqlSession两次执行相同的namespace下的sql语句，且向sql中传递的参数也相同，即最终执行相同的sql语句，则第一次执行完毕会将数据库中查询的数据写到缓存，第二次查询会从缓存中获取数据，不再去底层数据库查询，从而提高效率。
案例: 基于namespace名称空间级别的缓存：一个namespace对应一个二级缓存即一个mapper.xml对应一个缓存： 1、工作机制： 一个会话，查询一条数据，这个数据就会被放在当前会话的一级缓存中；如果会话关闭；一级缓存中的数据会被保存到二级缓存中；新的会话查询信息，就可以参照二级缓存中的内容；sqlSession=EmployeeMapper&gt;Employee
DepartmentMapper===&gt;Department
不同namespace查出的数据会放在自己对应的缓存中（map）
效果：数据会从二级缓存中获取
查出的数据都会被默认先放在一级缓存中。
只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中 2、 使用： 1）、开启全局二级缓存配置：
2）、去mapper.xml中配置使用二级缓存：
&lt; cache&gt;&lt; /cache&gt;
3）、我们的POJO需要实现序列化接口
1）在mybatis全局配置文件中开启全局二级缓存配置：&lt; setting name=“cacheEnabled” value=“true”/&gt;
2）在mapper.xml中配置使用二级缓存
直接加上： &lt; cache&gt;
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34; ?&gt; &lt;!DOCTYPE mapper PUBLIC &#34;-//mybatis.org//DTD Mapper 3.0//EN&#34; &#34;http://mybatis.org/dtd/mybatis-3-mapper.dtd&#34;&gt; &lt;mapper namespace=&#34;com.atguigu.mybatis.dao.EmployeeMapper&#34;&gt; &lt;cache&gt;&lt;cache/&gt; &lt;!--public Map&lt;Integer, Employee&gt; getEmpByLastNameLikeReturnMap(String lastName); --&gt; &lt;select id=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/22480fa30c5ab9a04a3404c216b52fed/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-25T16:51:49+08:00" />
<meta property="article:modified_time" content="2023-11-25T16:51:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MyBatis--03-- 一级缓存和二级缓存</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>什么叫缓存</h2> 
<ul><li> <p>将数据存放在程序内存中，用于减轻数据查询的压力，提升读取数据的速度，提高性能。</p> </li><li> <p>对于任何一个持久层框架，都有缓存机制；缓存在电脑中有一块真实的存储空间</p> </li></ul> 
<h2><a id="Mybatis_6"></a>Mybatis缓存</h2> 
<p>mybaits提供一级缓存，和二级缓存。</p> 
<ul><li>一级缓存（本地缓存）<br> sqlSession级别的缓存。（相当于一个方法内的缓存）</li><li>二级缓存（全局缓存）<br> 基于namespace名称空间级别的缓存.即一个mapper.xml对应一个缓存</li></ul> 
<p><img src="https://images2.imgbox.com/88/fd/I2vV6gtV_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1f/6c/VMLrSLY9_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0a/09/W4QI4ANm_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_19"></a>一级缓存（本地缓存）</h2> 
<p>一级缓存基于<mark>sqlSession默认开启</mark>,在操作数据库时需要构造SqlSession对象，在对象中有一个<mark>HashMap</mark>用于存储缓存数据。不同的SqlSession之间的缓存数据区域是互相不影响的。</p> 
<p>一级缓存的作用域是SqlSession范围的，当在同一个sqlSession中执行两次相同的sql语句时，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次查询时会从缓存中获取数据，不再去底层数据库查询，从而提高查询效率。</p> 
<blockquote> 
 <p><strong>Mybatis的内部缓存使用一个HashMap，key为hashcode+statementId+sql语句。Value为查询出来的结果集映射成的java对象。<br> SqlSession执行insert、update、delete等操作commit后会清空该SQLSession缓存</strong>。</p> 
</blockquote> 
<p>需要注意的是，如果SqlSession执行了DML操作（增删改），并且提交到数据库，MyBatis则会清空SqlSession中的一级缓存，这样做的目的是为了保证缓存中存储的是最新的信息，避免出现脏读现象。</p> 
<p>当一个SqlSession结束后该SqlSession中的一级缓存也就不存在了。</p> 
<p>关闭一级缓存后，再次访问，需要再次获取一级缓存，然后才能查找数据，否则会抛出异常。</p> 
<h3><a id="_37"></a>案例:</h3> 
<p><img src="https://images2.imgbox.com/20/31/aEHX1BBd_o.png" alt="在这里插入图片描述"><br> 第一次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，如果没有，从数据库查询用户信息。得到用户信息，将用户信息存储到一级缓存中。</p> 
<p><strong>如果sqlSession去执行commit操作（执行插入、更新、删除），清空SqlSession中的一级缓存</strong>，这样做的目的为了让缓存中存储的是最新的信息，避免脏读。</p> 
<p>第二次发起查询用户id为1的用户信息，先去找缓存中是否有id为1的用户信息，缓存中有，直接从缓存中获取用户信息。</p> 
<h2><a id="_48"></a>二级缓存（全局缓存）</h2> 
<p>Mybatis的二级缓存是指mapper映射文件。二级缓存的作用域是<mark>同一个namespace下的mapper映射文件内容</mark>，多个SqlSession共享。</p> 
<p><strong>Mybatis需要手动设置启动二级缓存。</strong></p> 
<p>二级缓存的作用域是mapper的同一个namespace。不同的sqlSession两次执行相同的namespace下的sql语句，且向sql中传递的参数也相同，即最终执行相同的sql语句，则第一次执行完毕会将数据库中查询的数据写到缓存，第二次查询会从缓存中获取数据，不再去底层数据库查询，从而提高效率。</p> 
<h3><a id="_58"></a>案例:</h3> 
<ol><li>基于namespace名称空间级别的缓存：一个namespace对应一个二级缓存即一个mapper.xml对应一个缓存：</li></ol> 
<p><img src="https://images2.imgbox.com/f1/43/futphh3W_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="1_63"></a>1、工作机制：</h4> 
<ol><li>一个会话，查询一条数据，这个数据就会被放在当前会话的一级缓存中；</li><li>如果会话关闭；一级缓存中的数据会被保存到二级缓存中；新的会话查询信息，就可以参照二级缓存中的内容；</li><li>sqlSession=<mark>EmployeeMapper</mark>&gt;Employee<br> DepartmentMapper===&gt;Department<br> 不同namespace查出的数据会放在自己对应的缓存中（map）<br> 效果：数据会从二级缓存中获取<br> 查出的数据都会被默认先放在一级缓存中。<br> 只有会话提交或者关闭以后，一级缓存中的数据才会转移到二级缓存中</li></ol> 
<h4><a id="2__72"></a>2、 使用：</h4> 
<p>1）、开启全局二级缓存配置：<br> 2）、去mapper.xml中配置使用二级缓存：<br> <strong>&lt; cache&gt;&lt; /cache&gt;</strong><br> 3）、我们的POJO需要实现序列化接口</p> 
<p>1）在mybatis全局配置文件中开启全局二级缓存配置：&lt; setting name=“cacheEnabled” value=“true”/&gt;</p> 
<p><img src="https://images2.imgbox.com/5a/36/N2PfqNX7_o.png" alt="在这里插入图片描述"><br> 2）在mapper.xml中配置使用二级缓存</p> 
<p>直接加上： &lt; cache&gt;</p> 
<pre><code class="prism language-cpp"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span> encoding<span class="token operator">=</span><span class="token string">"UTF-8"</span> <span class="token operator">?</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">!</span>DOCTYPE mapper
 PUBLIC <span class="token string">"-//mybatis.org//DTD Mapper 3.0//EN"</span>
 <span class="token string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span><span class="token operator">&gt;</span>
<span class="token operator">&lt;</span>mapper <span class="token keyword">namespace</span><span class="token operator">=</span><span class="token string">"com.atguigu.mybatis.dao.EmployeeMapper"</span><span class="token operator">&gt;</span>
	
	 <span class="token operator">&lt;</span>cache<span class="token operator">&gt;</span><span class="token operator">&lt;</span>cache<span class="token operator">/</span><span class="token operator">&gt;</span>
 
 	<span class="token operator">&lt;</span><span class="token operator">!</span><span class="token operator">--</span><span class="token keyword">public</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Employee<span class="token operator">&gt;</span> <span class="token function">getEmpByLastNameLikeReturnMap</span><span class="token punctuation">(</span>String lastName<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">--</span><span class="token operator">&gt;</span>
 	<span class="token operator">&lt;</span>select id<span class="token operator">=</span><span class="token string">"getEmpByLastNameLikeReturnMap"</span> resultType<span class="token operator">=</span><span class="token string">"com.atguigu.mybatis.bean.Employee"</span><span class="token operator">&gt;</span>
 		select <span class="token operator">*</span> from tbl_employee where last_name like #<span class="token punctuation">{<!-- --></span>lastName<span class="token punctuation">}</span>
 	<span class="token operator">&lt;</span><span class="token operator">/</span>select<span class="token operator">&gt;</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>mapper<span class="token operator">&gt;</span>
</code></pre> 
<h3><a id="cache_101"></a>中配置一些参数：</h3> 
<h4><a id="eviction_102"></a>eviction:缓存的回收策略：</h4> 
<pre><code>• LRU – 最近最少使用的：移除最长时间不被使用的对象。
• FIFO – 先进先出：按对象进入缓存的顺序来移除它们。
• SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。
• WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象。
• 默认的是 LRU。
</code></pre> 
<ul><li><strong>evicition收回策略，默认是LRU</strong></li></ul> 
<p>（1）LRU最近最少使用策略，一处做长时间不被使用的对象。<br> （2）FIFO先进先出策略，按对象进入缓存的顺序来移除它们。<br> （3）SOFT软引用策略，移除基于垃圾回收器状态和软引用规则的对象。<br> （4）WEAK弱引用策略，更积极地移除基于垃圾收集器状态和弱引用规则的对象</p> 
<h4><a id="flushInterval_117"></a>flushInterval：缓存刷新间隔</h4> 
<p>缓存多长时间清空一次，默认不清空，设置一个毫秒值</p> 
<h4><a id="readOnly_119"></a>readOnly:是否只读：</h4> 
<ul><li> <p><strong>true：只读</strong>；mybatis认为所有从缓存中获取数据的操作都是只读操作，不会修改数据。<br> mybatis为了加快获取速度，直接就会将数据在缓存中的引用交给用户。不安全，速度快</p> </li><li> <p><strong>false：非只读</strong>：mybatis觉得获取的数据可能会被修改。<br> mybatis会利用序列化&amp;反序列的技术克隆一份新的数据给你。安全，速度慢</p> </li></ul> 
<h4><a id="size_130"></a>size：</h4> 
<p>缓存存放多少元素；</p> 
<h4><a id="type_132"></a>type=“”：</h4> 
<p>指定自定义缓存的全类名；<br> 实现Cache接口即可；</p> 
<p><img src="https://images2.imgbox.com/cf/50/wwXNIhF2_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_140"></a>缓存的顺序:</h3> 
<ol><li>二级缓存</li><li>一级缓存</li><li>数据库</li></ol> 
<h3><a id="_147"></a>二级缓存的使用原则</h3> 
<ol><li> <p><strong>只能在一个命名空间下使用二级缓存</strong><br> 由于二级缓存中的数据是基于namespace的，即不同namespace中的数据互不干扰。在多个namespace中若均存在对同一个表的操作，那么这多个namespace中的数据可能就会出现不一致现象。</p> </li><li> <p><strong>在单表上使用二级缓存</strong><br> 如果一个表与其它表有关联关系，那么久非常有可能存在多个namespace对同一数据的操作。而不同namespace中的数据互补干扰，所以就有可能出现多个namespace中的数据不一致现象。</p> </li><li> <p><strong>查询多于修改时使用二级缓存</strong><br> 在查询操作远远多于增删改操作的情况下可以使用二级缓存。因为任何增删改操作都将刷新二级缓存，对二级缓存的频繁刷新将降低系统性能</p> </li></ol> 
<p>。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d29a97e86d9904724f6ea0650dec758a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Paper】PDFormer</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/165f1816c3995139d02f979d93f90eff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Bootstrap table插件 隐藏复选框，被选中的行颜色改变</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>