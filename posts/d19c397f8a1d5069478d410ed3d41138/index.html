<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【图像处理】windows 10 &#43; vs2015&#43; opencv3.0.0 &#43;附加模块opencv_contrib编译和配置 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【图像处理】windows 10 &#43; vs2015&#43; opencv3.0.0 &#43;附加模块opencv_contrib编译和配置" />
<meta property="og:description" content="0.前言 将基于低版本opencv（比如2.3.1）的程序，在vs2015&#43;opencv3.0的环境下编译会报错： “未声明的标识符:SiftFeatureDetector ” “未声明的标识符BruteForceMatcher” 查阅才知，sift、surf等等已经被移到opencv_contrib模块，如果需要在高版本opencv中使用到opencv_contrib模块，则需要自己进行编译。其编译和配置流程，在github.com:opencv/opencv_contrib的README里写了： 那么现在开始自行编译和配置吧。根据本文内容，成功率应该是99.99%，中途可能会遇到很多问题，我也会再总结一篇。 通过不懈努力，最终成果如下： 一.准备：系统环境和工具 1）系统：win 10 64位 2）opencv：3.0.0 3）opencv_contrib：3.0.0 4）visual studio:2015 5）CMake：3.8.0
1.安装CMake3.8.0 根据使用的操作系统选择相应的版本进行下载和安装即可（点击下载）： 2.下载opencv3.0.0 点击到官网下载
3.安装opencv3.0.0 将opencv安装到指定目录，比如：H:\opencv
4.下载opencv_contrib3.0.0 附加模块opencv_contrib最好下载与opencv为同一版本的。 5.解压opencv_contrib 3.0.0 将下载好的附加模块 opencv_contrib-3.0.0.zip 解压到指定位置，比如：C:\Users\september\Desktop\opencv_contrib-3.0.0 解压后，opencv_contrib-3.0.0的结构目录如下：
二.编译 1.打开cmake 2.输入opencv源文件路径 在where is the source code输入opencv地址/sources地址， 比如：H:/opencv/sources
3.输入保存编译结果的路径 在where to build the libraries输入保存编译结果的地址， 比如：H:/opencv/mybuild 比如下图：
4.第一次编译 （1）点击configure，选择本机的编译器，最后四位数字才代表vs的版本，比如图中的2015，代表的是visual studio 2015。 （2）点击finish，开始第一次编译。 如果编译器的版本选错，第一次编译时会出错： no cmake_c_compiler could be found. no cmake_cxx_compiler could be found. 第一次编译完成后会显示编译opencv所需要的参数，如图： 5.第二次编译 （1）在参数列表中，将Name为OPENCV_EXTRA_MODULES_PATH的Value设置为opencv_contrib-3.0.0的路径/modules，例如：C:/Users/september/Desktop/opencv_contrib-3.0.0/modules 可以在search栏中搜索OPENCV_EXTRA_MODULES_PATH变量，如下图。 （2）点击configure，直到configure done。 重点：configure done后，一定要检查一下参数列表，如果参数列表还有红色标记的条目，就再尝试几次configure，直到所有条目都是白色为止。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d19c397f8a1d5069478d410ed3d41138/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-03-02T20:52:35+08:00" />
<meta property="article:modified_time" content="2017-03-02T20:52:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【图像处理】windows 10 &#43; vs2015&#43; opencv3.0.0 &#43;附加模块opencv_contrib编译和配置</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="0前言">0.前言</h2> 
<p>将基于低版本opencv（比如2.3.1）的程序，在vs2015+opencv3.0的环境下编译会报错： <br> <font color="red">“未声明的标识符:SiftFeatureDetector ” <br> “未声明的标识符BruteForceMatcher” </font> <br> 查阅才知，sift、surf等等已经被移到<strong>opencv_contrib</strong>模块，如果需要在高版本opencv中使用到opencv_contrib模块，则需要自己进行编译。其编译和配置流程，在github.com:opencv/opencv_contrib的README里写了： <br> <img src="https://images2.imgbox.com/5f/5f/QaaOMyGB_o.jpg" alt="这里写图片描述" title=""> <br> 那么现在开始自行编译和配置吧。根据本文内容，成功率应该是99.99%，中途可能会遇到很多问题，我也会再总结一篇。 <br> 通过不懈努力，最终成果如下： <br> <img src="https://images2.imgbox.com/c0/a8/c5wYLgn8_o.jpg" alt="这里写图片描述" title=""></p> 
<h2 id="一准备系统环境和工具">一.准备：系统环境和工具</h2> 
<p>1）系统：win 10 64位 <br> 2）<a href="http://opencv.org/downloads.html" rel="nofollow">opencv：3.0.0</a> <br> 3）<a href="https://github.com/opencv/opencv_contrib/tree/3.0.0">opencv_contrib：3.0.0</a> <br> 4）visual studio:2015 <br> 5）<a href="https://cmake.org/download/" rel="nofollow">CMake：3.8.0</a></p> 
<h3 id="1安装cmake380"><font color="GREEN"><strong>1.安装CMake3.8.0</strong></font></h3> 
<p><a href="https://cmake.org/download/" rel="nofollow">根据使用的操作系统选择相应的版本进行下载和安装即可（点击下载）：</a> <br> <img src="https://images2.imgbox.com/03/cc/KWBkEIph_o.jpg" alt="这里写图片描述" title=""></p> 
<h3 id="2下载opencv300"><font color="GREEN">2.下载opencv3.0.0</font></h3> 
<p><a href="http://opencv.org/downloads.html" rel="nofollow">点击到官网下载</a></p> 
<h3 id="3安装opencv300"><font color="GREEN">3.安装opencv3.0.0</font></h3> 
<p>将opencv安装到指定目录，比如：H:\opencv</p> 
<h3 id="4下载opencvcontrib300"><font color="GREEN">4.下载opencv_contrib3.0.0</font></h3> 
<p><strong>附加模块opencv_contrib最好下载与opencv为同一版本的。</strong> <br> <img src="https://images2.imgbox.com/c6/a4/TuqEbBO9_o.jpg" alt="这里写图片描述" title=""></p> 
<h3 id="5解压opencvcontrib-300"><font color="GREEN">5.解压opencv_contrib 3.0.0</font></h3> 
<p>将下载好的附加模块 opencv_contrib-3.0.0.zip 解压到指定位置，比如：C:\Users\september\Desktop\opencv_contrib-3.0.0 <br> 解压后，opencv_contrib-3.0.0的结构目录如下：</p> 
<p><img src="https://images2.imgbox.com/62/5d/k886vnqQ_o.jpg" alt="这里写图片描述" title=""></p> 
<h2 id="二编译">二.编译</h2> 
<h3 id="1打开cmake"><font color="GREEN">1.打开cmake</font></h3> 
<h3 id="2输入opencv源文件路径"><font color="GREEN">2.输入opencv源文件路径</font></h3> 
<p>在where is the source code输入opencv地址/sources地址， 比如：H:/opencv/sources</p> 
<h3 id="3输入保存编译结果的路径"><font color="GREEN">3.输入保存编译结果的路径</font></h3> 
<p>在where to build the libraries输入保存编译结果的地址， 比如：H:/opencv/mybuild <br> 比如下图：</p> 
<p><img src="https://images2.imgbox.com/89/3e/Fm2URAxv_o.jpg" alt="这里写图片描述" title=""></p> 
<h3 id="4第一次编译"><font color="GREEN">4.第一次编译</font></h3> 
<p>（1）<strong>点击configure，选择本机的编译器</strong>，最后四位数字才代表vs的版本，比如图中的2015，代表的是visual studio 2015。 <br> <img src="https://images2.imgbox.com/e0/3d/G4taHHuw_o.jpg" alt="这里写图片描述" title=""> <br> <strong>（2）点击finish，开始第一次编译。</strong> <br> 如果编译器的版本选错，第一次编译时会出错： <br> <font color="red">no cmake_c_compiler could be found. <br> no cmake_cxx_compiler could be found.</font> <br> 第一次编译完成后会显示编译opencv所需要的参数，如图： <br> <img src="https://images2.imgbox.com/2b/8f/3Si5j7QK_o.jpg" alt="这里写图片描述" title=""></p> 
<h3 id="5第二次编译"><font color="GREEN">5.第二次编译</font></h3> 
<p><strong>（1）在参数列表中，将Name为OPENCV_EXTRA_MODULES_PATH的Value设置为opencv_contrib-3.0.0的路径/modules</strong>，例如：C:/Users/september/Desktop/opencv_contrib-3.0.0/modules <br> 可以在search栏中搜索OPENCV_EXTRA_MODULES_PATH变量，如下图。 <br> <img src="https://images2.imgbox.com/64/32/FDhTv2QB_o.jpg" alt="这里写图片描述" title=""> <br> <strong>（2）点击configure，直到configure done。</strong> <br> <font color="red">重点：configure done后，一定要检查一下参数列表，如果参数列表还有红色标记的条目，就再尝试几次configure，直到所有条目都是白色为止。</font></p> 
<pre><code>可能错误1:unknown cmake command "ocv_define_module"之类的，即存在未知的命令。
原因：可能是opencv版本和opencv_contrib版本不一致，换成一致的就行（本人遇到这个问题的时候，是这样解决的）

可能错误2：在ICV: Downloading ippicv_windows_20141027.zip...时报错
    CMake Error at 3rdparty/ippicv/downloader.cmake:97 (message):
    Call Stack (most recent call first):
    3rdparty/ippicv/downloader.cmake:108 (_icv_downloader)cmake/OpenCVFindIPP.cmake:212 (include)cmake/OpenCVFindLibsPerf.cmake:12 (include)
    CMakeLists.txt:454 (include)
    解决：手动下载ippicv_windows_20141027.zip，保存在opencv/sources/3rdparty/ippicv/downloads/windows-b59f865d1ba16e8c84124e19d78eec57
</code></pre> 
<p> <br> <strong>（3）点击generate，直到generate done</strong> <br> generate done后，会在where to build the binaries中设置的目录中生成编译结果。 <br> <img src="https://images2.imgbox.com/2c/d3/95OMRpfp_o.jpg" alt="这里写图片描述" title=""></p> 
<p><font color="red">（4）【该步骤是个人建议】检查一下附加模版是否成功编译并加入到opencv中</font>。如果附加模块opencv_contrib并未成功编译到opencv中，那后面再忙活都是白干。因为后面的步骤都比较费时，而且最终到了使用SIFT的时候才会发现附加模块增加失败，而且难以锁定原因，必须返回来逐步检查。所以个人建议不要跳过这一步，很简单。 <br> <strong>如下图，进入where to build the binaries中设置的目录，然后进入modules，查看一下是否有xfeatures2d这类的文件。</strong>这类文件是属于附加模版opencv_contrib的，如果没有，请检查一下CMake中参数列表里，OPENCV_EXTRA_MODULES_PATH的Value是否为opencv_contrib-3.0.0的路径/modules，如果不是，请重新设置OPENCV_EXTRA_MODULES_PATH的Value为opencv_contrib-3.0.0的路径/modules，然后重新configure、generate。如果附加模块opencv_contrib并未成功编译到opencv中，那后面就够忙活的了，后面更费时，而且最终会配置失败，还难以想到 <br> <img src="https://images2.imgbox.com/b1/df/eGcdnVPG_o.jpg" alt="这里写图片描述" title=""></p> 
<h2 id="三生成库文件">三.生成库文件</h2> 
<h3 id="1打开opencvsln"><font color="GREEN">1.打开OpenCV.sln</font></h3> 
<p>方式1：在CMake界面点击open project <br> 方式2：进入where to build the binaries中设置的路径下找到OpenCV.sln，并点击即可，此时本机的vs会打开OpenCV项目方案。</p> 
<h3 id="2生成dll和lib文件"><font color="GREEN">2.生成.dll和.lib文件</font></h3> 
<p>OpenCV.sln项目加载完后（项目个数应该在130~140左右），右键点击<strong>CMakeTargets</strong>，然后选择<strong>生成</strong>。这步完成后，在where to build the binaries中设置的路径下会多一个install文件，其中就是我们需要的配置文件了。</p> 
<p><img src="https://images2.imgbox.com/24/53/fCLFtnFc_o.jpg" alt="这里写图片描述" title=""></p> 
<h2 id="四配置">四.配置</h2> 
<p>接下来的配置，就和以往配置opencv的流程一样，只是现在是使用自己编译的包含了附加模块的opencv。</p> 
<h3 id="1系统环境变量"><font color="GREEN">1.系统环境变量</font></h3> 
<p>在<strong>计算机-环境变量-path</strong>中增加：where to build the binaries中设置的路径\install\x86\vc14\bin <br> <img src="https://images2.imgbox.com/d0/43/Ne4hJ0Tt_o.jpg" alt="这里写图片描述" title=""></p> 
<h3 id="2配置新建的工程"><font color="GREEN">2.配置新建的工程</font></h3> 
<p><strong>（1）VC++目录-包含目录</strong>：</p> 
<pre class="prettyprint"><code class=" hljs livecodeserver">&lt;where <span class="hljs-built_in">to</span> build <span class="hljs-operator">the</span> binaries中设置的路径&gt;\install\<span class="hljs-built_in">include</span>
&lt;where <span class="hljs-built_in">to</span> build <span class="hljs-operator">the</span> binaries中设置的路径&gt;\install\<span class="hljs-built_in">include</span>\opencv
&lt;where <span class="hljs-built_in">to</span> build <span class="hljs-operator">the</span> binaries中设置的路径&gt;\install\<span class="hljs-built_in">include</span>\opencv2</code></pre> 
<p>如下图： <br> <img src="https://images2.imgbox.com/25/4a/CyRnpf40_o.jpg" alt="这里写图片描述" title=""> <br> <strong>（2）VC++目录-库目录</strong>：</p> 
<pre class="prettyprint"><code class=" hljs tex">&lt;where to build the binaries中设置的路径&gt;<span class="hljs-command">\install</span><span class="hljs-command">\x</span>86<span class="hljs-command">\vc</span>14<span class="hljs-command">\lib</span>
&lt;where to build the binaries中设置的路径&gt;<span class="hljs-command">\install</span><span class="hljs-command">\x</span>86<span class="hljs-command">\vc</span>14<span class="hljs-command">\staticlib</span></code></pre> 
<p>如下图：</p> 
<p><img src="https://images2.imgbox.com/4c/1c/liLuVoGA_o.jpg" alt="这里写图片描述" title=""> <br> <strong>（3）链接器-输入-附加依赖项：</strong> <br> 可能因为不同的人编译时添加的附加模块不一样而造成最终的.lib不一样，所以附加依赖项里添加的.lib文件都需要出现在：&lt; where to build the binaries中设置的路径&gt;\install\x86\vc14\lib中，否则在编译程序的时候会出现XXX.lib加载失败、丢失、找不到之类的错误，因为这个.lib根本不存在，但是可能被添加在附加依赖项里了。比如我的： <br> opencv_bgsegm300d.lib <br> opencv_calib3d300d.lib <br> opencv_ccalib300d.lib <br> opencv_core300d.lib <br> opencv_datasets300d.lib <br> opencv_face300d.lib <br> opencv_features2d300d.lib <br> opencv_flann300d.lib <br> opencv_hal300d.lib <br> opencv_highgui300d.lib <br> opencv_imgcodecs300d.lib <br> opencv_imgproc300d.lib <br> opencv_line_descriptor300d.lib <br> opencv_ml300d.lib <br> opencv_objdetect300d.lib <br> opencv_optflow300d.lib <br> opencv_photo300d.lib <br> opencv_reg300d.lib <br> opencv_rgbd300d.lib <br> opencv_saliency300d.lib <br> opencv_shape300d.lib <br> opencv_stitching300d.lib <br> opencv_superres300d.lib <br> opencv_surface_matching300d.lib <br> opencv_text300d.lib <br> opencv_tracking300d.lib <br> opencv_ts300d.lib <br> opencv_video300d.lib <br> opencv_videoio300d.lib <br> opencv_videostab300d.lib <br> opencv_xfeatures2d300d.lib <br> opencv_ximgproc300d.lib <br> opencv_xobjdetect300d.lib <br> opencv_xphoto300d.lib</p> 
<h2 id="五测试">五.测试</h2> 
<p>前面的四大部分完成了opencv和opencv_contrib的编译和配置，也完成了项目的配置，现在就是检验的时候了。</p> 
<h3 id="1添加源码"><font color="GREEN">1.添加源码</font></h3> 
<p>在项目源文件中新建main.cpp:</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-preprocessor">#include &lt;iostream&gt;  </span>
<span class="hljs-preprocessor">#include &lt;opencv2\opencv.hpp&gt;  </span>
<span class="hljs-preprocessor">#include &lt;opencv2\xfeatures2d.hpp&gt;</span>
<span class="hljs-keyword">using</span> namespace std;
<span class="hljs-keyword">using</span> namespace cv;
<span class="hljs-keyword">using</span> namespace cv::xfeatures2d;


<span class="hljs-keyword">int</span> main()
{
    Mat firstImage = imread(<span class="hljs-string">"26.jpg"</span>);
    Mat secondImage = imread(<span class="hljs-string">"27.jpg"</span>);
    <span class="hljs-keyword">if</span> (firstImage.empty() || secondImage.empty())
    {
        cout &lt;&lt; <span class="hljs-string">"error"</span> &lt;&lt; endl;
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
    }

    <span class="hljs-comment">//resize(firstImage,firstImage,Size(800,1000),0,0,1);  </span>
    <span class="hljs-comment">//resize(secondImage,secondImage,Size(800,1000),0,0,1);  </span>

    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span>//  </span>
    <span class="hljs-comment">//第一步:获取SIFT特征  </span>
<span class="hljs-comment"><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span>//  </span>
    <span class="hljs-comment">//difine a sift detector  </span>
    Ptr&lt;SIFT&gt; sift = SIFT::create();
    <span class="hljs-comment">//sift-&gt;detect();</span>
    <span class="hljs-comment">//SiftFeatureDetector siftDetector;</span>
    <span class="hljs-comment">//store key points  </span>
    vector&lt;KeyPoint&gt; firstKeypoint, secondKeypoint;
    <span class="hljs-comment">//detect image with SIFT,get key points  </span>
    sift-&gt;detect(firstImage, firstKeypoint);
    sift-&gt;detect(secondImage, secondKeypoint);
    Mat firstOutImage, secondOutImage;
    <span class="hljs-comment">//draw key points at the out image and show to the user  </span>
    drawKeypoints(firstImage, firstKeypoint, firstOutImage, Scalar(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));
    drawKeypoints(secondImage, secondKeypoint, secondOutImage, Scalar(<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>));
    imshow(<span class="hljs-string">"first"</span>, firstOutImage);
    imshow(<span class="hljs-string">"second"</span>, secondOutImage);
    Mat firstDescriptor, secondDescriptor;
    sift-&gt;compute(firstImage,firstKeypoint,firstDescriptor);
    sift-&gt;compute(secondImage,secondKeypoint,secondDescriptor);
    Ptr&lt;DescriptorMatcher &gt; matcher = DescriptorMatcher::create(<span class="hljs-string">"BruteForce"</span>);
    Mat masks;
    vector&lt;DMatch&gt; matches;
    matcher-&gt;match(firstDescriptor, secondDescriptor, matches, masks);


    <span class="hljs-comment"><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span>//  </span>
    <span class="hljs-comment">//第二步:RANSAC方法剔除outliner  </span>
<span class="hljs-comment"><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span><span class="hljs-xmlDocTag">///</span>//  </span>
    Mat matcheImage;
    <span class="hljs-comment">//将vector转化成Mat  </span>
    Mat firstKeypointMat(matches.size(), <span class="hljs-number">2</span>, CV_32F), secondKeypointMat(matches.size(), <span class="hljs-number">2</span>, CV_32F);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;matches.size(); i++)
    {
        firstKeypointMat.at&lt;<span class="hljs-keyword">float</span>&gt;(i, <span class="hljs-number">0</span>) = firstKeypoint[matches[i].queryIdx].pt.x;
        firstKeypointMat.at&lt;<span class="hljs-keyword">float</span>&gt;(i, <span class="hljs-number">1</span>) = firstKeypoint[matches[i].queryIdx].pt.y;
        secondKeypointMat.at&lt;<span class="hljs-keyword">float</span>&gt;(i, <span class="hljs-number">0</span>) = secondKeypoint[matches[i].trainIdx].pt.x;
        secondKeypointMat.at&lt;<span class="hljs-keyword">float</span>&gt;(i, <span class="hljs-number">1</span>) = secondKeypoint[matches[i].trainIdx].pt.y;
    }
    <span class="hljs-comment">//Calculate the fundamental Mat;  </span>
    vector&lt;uchar&gt; ransacStatus;
    Mat fundamentalMat = findFundamentalMat(firstKeypointMat, secondKeypointMat, ransacStatus, FM_RANSAC);
    cout &lt;&lt; fundamentalMat &lt;&lt; endl;
    <span class="hljs-comment">//Calculate the number of outliner points;  </span>
    <span class="hljs-keyword">int</span> outlinerCount = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;matches.size(); i++)
    {
        <span class="hljs-keyword">if</span> (ransacStatus[i] == <span class="hljs-number">0</span>)
        {
            outlinerCount++;
        }
    }
    <span class="hljs-comment">//Calculate inliner points;  </span>
    vector&lt;Point2f&gt; firstInliner;
    vector&lt;Point2f&gt; secondInliner;
    vector&lt;DMatch&gt; inlinerMatches;
    <span class="hljs-keyword">int</span> inlinerCount = matches.size() - outlinerCount;
    firstInliner.resize(inlinerCount);
    secondInliner.resize(inlinerCount);
    inlinerMatches.resize(inlinerCount);
    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;matches.size(); i++)
    {
        <span class="hljs-keyword">if</span> (ransacStatus[i] != <span class="hljs-number">0</span>)
        {
            firstInliner[index].x = firstKeypointMat.at&lt;<span class="hljs-keyword">float</span>&gt;(i, <span class="hljs-number">0</span>);
            firstInliner[index].y = firstKeypointMat.at&lt;<span class="hljs-keyword">float</span>&gt;(i, <span class="hljs-number">1</span>);
            secondInliner[index].x = secondKeypointMat.at&lt;<span class="hljs-keyword">float</span>&gt;(i, <span class="hljs-number">0</span>);
            secondInliner[index].y = secondKeypointMat.at&lt;<span class="hljs-keyword">float</span>&gt;(i, <span class="hljs-number">1</span>);
            inlinerMatches[index].queryIdx = index;
            inlinerMatches[index].trainIdx = index;
            index++;
        }
    }
    vector&lt;KeyPoint&gt; inlinerFirstKeypoint(inlinerCount);
    vector&lt;KeyPoint&gt; inlinerSecondKeypoint(inlinerCount);
    KeyPoint::convert(firstInliner, inlinerFirstKeypoint);
    KeyPoint::convert(secondInliner, inlinerSecondKeypoint);
    <span class="hljs-comment">//cout&lt;&lt;fundamentalMat&lt;&lt;endl;  </span>
    <span class="hljs-comment">//select 50 keypoints  </span>
    <span class="hljs-comment">//matches.erase(matches.begin()+50,matches.end());  </span>
    <span class="hljs-comment">//inlinerMatches.erase(inlinerMatches.begin()+50,inlinerMatches.end());  </span>
    drawMatches(firstImage, inlinerFirstKeypoint, secondImage, inlinerSecondKeypoint, inlinerMatches, matcheImage);
    imshow(<span class="hljs-string">"ransacMatches"</span>, matcheImage);
    drawMatches(firstImage, firstKeypoint, secondImage, secondKeypoint, matches, matcheImage);
    imshow(<span class="hljs-string">"matches"</span>, matcheImage);
    waitKey(<span class="hljs-number">0</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<h3 id="2运行"><font color="GREEN">2.运行</font></h3> 
<p><img src="https://images2.imgbox.com/ff/8e/3gZmKohi_o.jpg" alt="这里写图片描述" title=""></p> 
<p>到此，windows 10 + vs2015+ opencv3.0.0 的环境下，使用opencv_contrib附加模块就完美解决了，SIFT、SURF也能正常使用了。整个编译、配置过程，会遇到各种各样的问题，总之，坚持不懈吧~谁让opencv不是咱自己写的呢~</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a16654379cb97d085f3a00a55ffb579a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python WebDriver如何处理右键菜单</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a69eb63cb291258ecc5d092212cc5666/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MDK常见错误记录</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>