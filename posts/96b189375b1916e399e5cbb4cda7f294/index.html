<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>展讯平台lcd频率计算 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="展讯平台lcd频率计算" />
<meta property="og:description" content="展讯平台点屏时要配置两个时钟(phy_freq和pixel_clk),那这两个参数要怎么配置呢，我们可以找到展讯的这份文档，输入屏的参数,即可计算出相应的时钟。如
然后将相应的参数填到屏的配置文件中，如
Android9.0以前,
uboot配置
.phy_freq = 1105000 .pixel_clk = 153600000 kernel配置
pixel_clk:由uboot传参到cmdline(在uboot) clock-frequency = &lt;1105000&gt;;对应uboot的phy_freq Android10.0
uboot配置
.phy_freq = 1105000 .pixel_clk = 153600000 kernel配置
sprd,phy-bit-clock = &lt;1105000&gt;;//phy-freq clock-frequency = &lt;153600000&gt;;//pixel_clk 当然，这不是重点，之前一直不了解其中的运算规则，excel隐藏了其中的运算规则，今天看代码有了一些了解，分享下
pixel_clk计算
从下面的程序中可以窥见一二，如果配置是时钟源是dpi_clk_src中一个，直接使用，然后根据ROUND(a, b)计算分配分配系数
static const u32 dpi_clk_src[] = { 96000000, 128000000, 153600000, 192000000 }; static u32 calc_dpi_clk_src(u32 pclk) { int i; for (i = 0; i &lt; ARRAY_SIZE(dpi_clk_src); i&#43;&#43;) { if ((dpi_clk_src[i] % pclk) == 0) return dpi_clk_src[i]; } pr_err(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/96b189375b1916e399e5cbb4cda7f294/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-07T00:14:37+08:00" />
<meta property="article:modified_time" content="2020-05-07T00:14:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">展讯平台lcd频率计算</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> 展讯平台点屏时要配置两个时钟(phy_freq和pixel_clk),那这两个参数要怎么配置呢，我们可以找到展讯的这份文档，输入屏的参数,即可计算出相应的时钟。如</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2f/03/exsS7u8S_o.png"></p> 
<p> 然后将相应的参数填到屏的配置文件中，如</p> 
<p>Android9.0以前,<br> uboot配置</p> 
<pre><code class="language-cpp">.phy_freq = 1105000
.pixel_clk = 153600000</code></pre> 
<p>kernel配置</p> 
<pre><code>pixel_clk:由uboot传参到cmdline(在uboot)
clock-frequency = &lt;1105000&gt;;对应uboot的phy_freq</code></pre> 
<p>Android10.0<br> uboot配置</p> 
<pre><code class="language-cpp">.phy_freq = 1105000
.pixel_clk = 153600000</code></pre> 
<p><br> kernel配置</p> 
<pre><code class="language-cpp">sprd,phy-bit-clock = &lt;1105000&gt;;//phy-freq
clock-frequency = &lt;153600000&gt;;//pixel_clk</code></pre> 
<p>当然，这不是重点，之前一直不了解其中的运算规则，excel隐藏了其中的运算规则，今天看代码有了一些了解，分享下</p> 
<p><span style="color:#3399ea;"><strong>pixel_clk计算</strong></span></p> 
<p>从下面的程序中可以窥见一二，如果配置是时钟源是dpi_clk_src中一个，直接使用，然后根据ROUND(a, b)计算分配分配系数</p> 
<pre><code class="language-cpp">static const u32 dpi_clk_src[] = {
	96000000,
	128000000,
	153600000,
	192000000
};

static u32 calc_dpi_clk_src(u32 pclk)
{
	int i;

	for (i = 0; i &lt; ARRAY_SIZE(dpi_clk_src); i++) {
		if ((dpi_clk_src[i] % pclk) == 0)
			return dpi_clk_src[i];
	}

	pr_err("calc DPI_CLK_SRC failed, use default\n");
	return 96000000;
}
#define ROUND(a, b) (((a) + (b) / 2) / (b))  

static int calc_dpi_clk(struct sprd_dispc *dispc,
			       u32 *new_pclk, u32 pclk_src,
			       u32 new_val, int type)
{
	switch (type) {
	case SPRD_FORCE_FPS:
	case SPRD_DYNAMIC_FPS:
		if (new_val &lt; LCD_MIN_FPS || new_val &gt; LCD_MAX_FPS) {
			pr_err
			    ("Unsupported FPS. fps range should be [%d, %d]\n",
			     LCD_MIN_FPS, LCD_MAX_FPS);
			return -EINVAL;
		}
		pclk = hpixels * vlines * new_val;
		divider = ROUND(pclk_src, pclk);
		*new_pclk = pclk_src / divider;
		if (pclk_src % divider)
			*new_pclk += 1;
		panel-&gt;fps = new_val;
		break;

}</code></pre> 
<p><span style="color:#3399ea;"><strong> fps计算 </strong></span></p> 
<pre><code class="language-cpp">static ssize_t actual_fps_show(struct device *dev,
                        struct device_attribute *attr,
                        char *buf)
{
        struct sprd_dpu *dpu = dev_get_drvdata(dev);
        struct videomode vm = dpu-&gt;ctx.vm;
        uint32_t act_fps_int, act_fps_frac;
        uint32_t total_pixels;
        int ret;

        total_pixels = (vm.hsync_len + vm.hback_porch +
                        vm.hfront_porch + vm.hactive) *
                        (vm.vsync_len + vm.vback_porch +
                        vm.vfront_porch + vm.vactive);

        act_fps_int = vm.pixelclock / total_pixels;
        act_fps_frac = vm.pixelclock % total_pixels;
        act_fps_frac = act_fps_frac * 100 / total_pixels;

        ret = snprintf(buf, PAGE_SIZE, "%u.%u\n", act_fps_int, act_fps_frac);

        return ret;
}
static DEVICE_ATTR_RO(actual_fps);
</code></pre> 
<p>kernel4.14/drivers/gpu/drm/sprd/dpu/dpu_r3p0.c </p> 
<pre><code class="language-cpp">static void dpu_dpi_init(struct dpu_context *ctx)
{
	if (ctx-&gt;vm.vsync_len + ctx-&gt;vm.vback_porch &lt; 32)
		pr_warn("Warning: (vsync + vbp) &lt; 32, ""underflow risk!\n");
}</code></pre> 
<p>如上面的那组参数</p> 
<p>1206*2138*60=154705680<br> ROUND(a, b)=1,分频系数为1,那时钟就是153600000</p> 
<p>fps≈153600000/(1206*2138)≈60,满足要求</p> 
<p> 如这组参数,</p> 
<p>1547*688*60=63860160</p> 
<p>ROUND(a, b)=2,频率就是153600000/2=76800000，</p> 
<p>fps≈76800000/(1547*688)≈72fps，,不满足要求</p> 
<p>但更换64000000时钟源，</p> 
<p>ROUND(a, b)=2,频率就是128000000/2=64000000，</p> 
<p>fps≈64000000/(1547*688)≈60fps,满足要求</p> 
<p>展讯给的公式为</p> 
<pre><code class="language-cpp">1.need_clock = (width+hfp+hbp+hsync)*(height+vfp+vbp+vsync)*fps  
2.dividor = dpi_clock_src/need_clock;
3.if((dpi_clock_src - dividor*need_clock) &gt; (need_clock/2)){
    dividor += 1;
}</code></pre> 
<p> </p> 
<p><img alt="" height="561" src="https://images2.imgbox.com/5f/e8/Gm09Reqf_o.png" width="831"></p> 
<p><span style="color:#3399ea;"><strong>phy_freq的计算</strong></span></p> 
<p>展讯给的公式为</p> 
<p>(DPI_CLK_SRC/DIVIDOR)x 3x 8 bit &lt; phy_feq x lane_num x 0.9<br> 考虑到MIPI传输过程中可能会出现传输错误，实际设置的值可以再加大10%</p> 
<p>对于下面屏的配置算出来的是<br> (153600000*3*8)/(4*0.9)*1.1=1126400000,表格算处理的是1105*1000kbs，差不多。</p> 
<p><img alt="" src="https://images2.imgbox.com/35/f1/rLtFBvSb_o.png"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e7fb13afad93b65d1994ebce62b6adf9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【控制理论】【Matlab】利用System identification App辨识对象模型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/934f533a1805a6e2df7941e4105bba77/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【GDAL】解决获取S57图层数异常</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>