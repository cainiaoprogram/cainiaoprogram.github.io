<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Fuzz-AFL入门 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Fuzz-AFL入门" />
<meta property="og:description" content="Fuzz-AFL入门 工具 AFL 则是fuzzing的一个很好用的工具，全称是American Fuzzy Lop，由Google安全工程师Michał Zalewski开发的一款开源fuzzing测试工具，可以高效地对二进制程序进行fuzzing，挖掘可能存在的内存安全漏洞，如栈溢出、堆溢出、UAF、double free等。原理是通过对源码进行重新编译时进行插桩（简称编译时插桩）的方式自动产生测试用例来探索二进制程序内部新的执行路径。AFL也支持直接对没有源码的二进制程序进行测试，但需要QEMU的支持。
安装使用 从 http://lcamtuf.coredump.cx/afl/ 下载源码，然后解压之后安装
make sudo make install 安装成功
安装目录
afl-gcc 和afl-g&#43;&#43; 分别对应的是gcc 和g&#43;&#43; 的封装
afl-clang 和afl-clang&#43;&#43; 分别对应clang 的c 和c&#43;&#43; 编译器封装À。
afl-fuzz 是AFL 的主体，用于对目标程序进行fuzz。
afl-analyze 可以对用例进行分析，通过分析给定的用例，看能否发现用例中有意义的字段。
afl-qemu-trace 用于qemu-mode，默认不安装，需要手工执行qemu-mode 的编译脚本进行编译，后面会介绍。
afl-plot 生成测试任务的状态图
afl-tmin 和afl-cmin 对用例进行简化
afl-whatsup 用于查看fuzz 任务的状态
afl-gotcpu 用于查看当前CPU 状态
afl-showmap 用于对单个用例进行执行路径跟踪
图片为我们使用AFL进行测试时的运行截图
整体来说，运行状态主要包括8个部分
process timing 这里展示了fuzz的运行时间、最近一次发现新执行路径的时间、最近一次崩溃的时间、最近一次超时的时间。
值得注意的是第2项，最近一次发现新路径的时间。如果由于目标二进制文件或者命令行参数出错，那么其执行路径应该是一直不变的，所以如果从fuzzing开始一直没有发现新的执行路径，那么就要考虑是否有二进制或者命令行参数错误的问题了。
cycle progress 主要记录了当前正在处理的fuzz进程和由于超时放弃的路径数
stage progress 这里记录了包括正在测试的fuzzing策略、进度、目标的执行总次数、目标的执行速度
执行速度可以直观地反映当前跑的快不快，如果速度过慢，比如低于500次每秒，那么测试时间就会变得非常漫长。如果发生了这种情况，那么我们需要进一步调整优化我们的fuzzing
fuzzing strategy yieldsoverrall results 这里包括运行的总周期数、总路径数、崩溃次数、超时次数。
其中，总周期数可以用来作为何时停止fuzzing的参考。随着不断地fuzzing，周期数会不断增大，其颜色也会由紫色，逐步变为黄色、蓝色、绿色。一般来说，当其变为绿色时，代表可执行的内容已经很少了，继续fuzzing下去也不会有什么新的发现了。此时，我们便可以通过Ctrl-C，中止当前的fuzzing" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/55850cf2d1b551a42c3277ebc9371eaa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-29T15:18:42+08:00" />
<meta property="article:modified_time" content="2022-12-29T15:18:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Fuzz-AFL入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="FuzzAFL_0"></a>Fuzz-AFL入门</h2> 
<h3><a id="_2"></a>工具</h3> 
<p><strong>AFL</strong> 则是fuzzing的一个很好用的工具，全称是<strong>American Fuzzy Lop</strong>，由Google安全工程师Michał Zalewski开发的一款开源fuzzing测试工具，可以高效地对二进制程序进行fuzzing，挖掘可能存在的内存安全漏洞，如栈溢出、堆溢出、UAF、double free等。原理是通过对源码进行重新编译时进行插桩（简称编译时插桩）的方式自动产生测试用例来探索二进制程序内部新的执行路径。AFL也支持直接对没有源码的二进制程序进行测试，但需要QEMU的支持。</p> 
<h4><a id="_5"></a>安装使用</h4> 
<p>从 http://lcamtuf.coredump.cx/afl/ 下载源码，然后解压之后安装</p> 
<pre><code class="prism language-shell"><span class="token function">make</span>
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>
</code></pre> 
<p>安装成功<br> <img src="https://images2.imgbox.com/a8/b1/cDsiEBtj_o.png" alt="在这里插入图片描述"></p> 
<p>安装目录<br> <img src="https://images2.imgbox.com/94/a6/shwSJl6U_o.png" alt=""></p> 
<blockquote> 
 <p>afl-gcc 和afl-g++ 分别对应的是gcc 和g++ 的封装<br> afl-clang 和afl-clang++ 分别对应clang 的c 和c++ 编译器封装À。<br> afl-fuzz 是AFL 的主体，用于对目标程序进行fuzz。<br> afl-analyze 可以对用例进行分析，通过分析给定的用例，看能否发现用例中有意义的字段。<br> afl-qemu-trace 用于qemu-mode，默认不安装，需要手工执行qemu-mode 的编译脚本进行编译，后面会介绍。<br> afl-plot 生成测试任务的状态图<br> afl-tmin 和afl-cmin 对用例进行简化<br> afl-whatsup 用于查看fuzz 任务的状态<br> afl-gotcpu 用于查看当前CPU 状态<br> afl-showmap 用于对单个用例进行执行路径跟踪</p> 
</blockquote> 
<p>图片为我们使用AFL进行测试时的运行截图<br> <img src="https://images2.imgbox.com/12/5a/ErJCUuaG_o.png" alt="在这里插入图片描述"></p> 
<p>整体来说，运行状态主要包括8个部分</p> 
<ul><li>process timing</li></ul> 
<p>这里展示了fuzz的运行时间、最近一次发现新执行路径的时间、最近一次崩溃的时间、最近一次超时的时间。<br> 值得注意的是第2项，最近一次发现新路径的时间。如果由于目标二进制文件或者命令行参数出错，那么其执行路径应该是一直不变的，所以如果从fuzzing开始一直没有发现新的执行路径，那么就要考虑是否有二进制或者命令行参数错误的问题了。</p> 
<ul><li>cycle progress</li></ul> 
<p>主要记录了当前正在处理的fuzz进程和由于超时放弃的路径数</p> 
<ul><li>stage progress</li></ul> 
<p>这里记录了包括正在测试的fuzzing策略、进度、目标的执行总次数、目标的执行速度</p> 
<p>执行速度可以直观地反映当前跑的快不快，如果速度过慢，比如低于500次每秒，那么测试时间就会变得非常漫长。如果发生了这种情况，那么我们需要进一步调整优化我们的fuzzing</p> 
<ul><li>fuzzing strategy yields</li><li>overrall results</li></ul> 
<p>这里包括运行的总周期数、总路径数、崩溃次数、超时次数。</p> 
<p>其中，总周期数可以用来作为何时停止fuzzing的参考。随着不断地fuzzing，周期数会不断增大，其颜色也会由紫色，逐步变为黄色、蓝色、绿色。一般来说，当其变为绿色时，代表可执行的内容已经很少了，继续fuzzing下去也不会有什么新的发现了。此时，我们便可以通过Ctrl-C，中止当前的fuzzing</p> 
<ul><li> <p>map coverage</p> </li><li> <p>findings in depth</p> </li><li> <p>path geometry</p> </li></ul> 
<p><strong>levels</strong>表示测试等级，<strong>pending</strong>表示还没有经过fuzzing的输入数量，<strong>pend fav</strong>表明fuzzer感兴趣的输入数量，<strong>own finds</strong>表示在fuzzing过程中新找到的，或者是并行测试从另一个实例导入的，imported中的n/a表明不可用，即没有导入。最后说明一下stability，表明相同输入是否产生了相同的行为，一般结果都是100%，如果低于100%并且变红，则需要查阅官方文档寻找解决步骤。</p> 
<p>使用方法分为<strong>有源码</strong>和<strong>无源码有二进制应用程序</strong></p> 
<h3><a id="Fuzz_65"></a>有源码-Fuzz</h3> 
<p>对于有源码的fuzz，使用AFL自带的编译器对源码进行插桩编译，然后利用Afl-fuzz对编译好的二进制应用进行fuzz<br> 编译c程序使用<strong>afl-gcc</strong>，编译c++程序使用<strong>afl-g++</strong></p> 
<pre><code class="prism language-shell">$ afl-gcc test.c <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span>
$ afl-g++ test.cpp <span class="token parameter variable">-o</span> <span class="token builtin class-name">test</span>
</code></pre> 
<p>然后使用afl-fuzz进行测试，命令行如下，-i指明测试用例的目录，-o指明测试结果的存放目录。对于直接从终端获取输入的程序来说，我们需要在testcase_dir目录下新建一个文件，文件的内容就是程序的输入，文件命名不唯一，后面会给一个示例</p> 
<pre><code class="prism language-shell">$ ./afl-fuzz <span class="token parameter variable">-i</span> testcase_dir <span class="token parameter variable">-o</span> findings_dir /path/to/program <span class="token punctuation">[</span><span class="token punctuation">..</span>.params<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>对于从文件中获取输入的程序，请使用“@@”标记，AFL将会自动将其替换为测试用例中的文件名</p> 
<pre><code class="prism language-shell">$ ./afl-fuzz <span class="token parameter variable">-i</span> testcase_dir <span class="token parameter variable">-o</span> findings_dir /path/to/program @@
</code></pre> 
<p><img src="https://images2.imgbox.com/d5/16/NSrUAjbH_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="Fuzz_87"></a>无源码二进制应用Fuzz</h3> 
<p>AFL对于缺少源码的二进制程序fuzz，利用qemu_mode</p> 
<p>安装</p> 
<pre><code class="prism language-shell"><span class="token builtin class-name">cd</span>  qemu_mode
./ build_qemu_support.sh
</code></pre> 
<p>中途会遇到报错，记录一下解决方案<br> 报错1：<br> <img src="https://images2.imgbox.com/c4/eb/WGAYeaVS_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libtool
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libtool-bin
</code></pre> 
<p>报错2：<br> <img src="https://images2.imgbox.com/26/99/SGNpsKae_o.png" alt="在这里插入图片描述"></p> 
<p>编译qemu的时候报错，这是因为memfd_create和glibc中的同名函数冲突了，所以需要给安装包打patche</p> 
<pre><code class="prism language-shell"><span class="token builtin class-name">cd</span> ./qemu_mode/patches
<span class="token function">vim</span> memfd_create.diff
//添加以下patche 并保存
<span class="token function">diff</span> <span class="token parameter variable">-ru</span> qemu-2.10.0-clean/util/memfd.c qemu-2.10.0/util/memfd.c
--- qemu-2.10.0-clean/util/memfd.c      <span class="token number">2018</span>-11-20 <span class="token number">18</span>:11:00.170271506 +0100
+++ qemu-2.10.0/util/memfd.c    <span class="token number">2018</span>-11-20 <span class="token number">18</span>:11:13.398423613 +0100
@@ -37,7 +37,7 @@
 <span class="token comment">#include &lt;sys/syscall.h&gt;</span>
 <span class="token comment">#include &lt;asm/unistd.h&gt;</span>
 
<span class="token parameter variable">-static</span> int memfd_create<span class="token punctuation">(</span>const char *name, unsigned int flags<span class="token punctuation">)</span>
+int memfd_create<span class="token punctuation">(</span>const char *name, unsigned int flags<span class="token punctuation">)</span>
 <span class="token punctuation">{<!-- --></span>
 <span class="token comment">#ifdef __NR_memfd_create</span>
     <span class="token builtin class-name">return</span> syscall<span class="token punctuation">(</span>__NR_memfd_create, name, flags<span class="token punctuation">)</span><span class="token punctuation">;</span>

//修改 build_qemu_support.sh安装添加的patch
 patch <span class="token parameter variable">-p1</span> <span class="token operator">&lt;</span><span class="token punctuation">..</span>/patches/elfload.diff <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>
 patch <span class="token parameter variable">-p1</span> <span class="token operator">&lt;</span><span class="token punctuation">..</span>/patches/cpu-exec.diff <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>
 patch <span class="token parameter variable">-p1</span> <span class="token operator">&lt;</span><span class="token punctuation">..</span>/patches/syscall.diff <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>
 patch <span class="token parameter variable">-p1</span> <span class="token operator">&lt;</span><span class="token punctuation">..</span>/patches/memfd_create.diff <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>
</code></pre> 
<p>报错3：<br> <img src="https://images2.imgbox.com/8d/2d/YSryQFgB_o.png" alt="在这里插入图片描述"><br> 解决方案：<br> 加上一个syscall1.diff文件，将其放在patches文件夹下，然后再改build_qemu_support.sh的patch就可以了</p> 
<pre><code class="prism language-shell">--- qemu-2.10.0-clean/linux-user/syscall.c	<span class="token number">2020</span>-03-12 <span class="token number">18</span>:47:47.898592169 +0100
+++ qemu-2.10.0/linux-user/syscall.c	<span class="token number">2020</span>-03-12 <span class="token number">19</span>:16:41.563074307 +0100
@@ -34,6 +34,7 @@
 <span class="token comment">#include &lt;sys/resource.h&gt;</span>
 <span class="token comment">#include &lt;sys/swap.h&gt;</span>
 <span class="token comment">#include &lt;linux/capability.h&gt;</span>
+<span class="token comment">#include &lt;linux/sockios.h&gt; // https://lkml.org/lkml/2019/6/3/988</span>
 <span class="token comment">#include &lt;sched.h&gt;</span>
 <span class="token comment">#include &lt;sys/timex.h&gt;</span>
 <span class="token comment">#ifdef __ia64__</span>
@@ -116,6 +117,8 @@ int __clone2<span class="token punctuation">(</span>int <span class="token punctuation">(</span>*fn<span class="token punctuation">)</span><span class="token punctuation">(</span>void *<span class="token punctuation">)</span>, void *ch
 <span class="token comment">#include "qemu.h"</span>
 
+extern unsigned int afl_forksrv_pid<span class="token punctuation">;</span>
+
 <span class="token comment">#ifndef CLONE_IO</span>
 <span class="token comment">#define CLONE_IO                0x80000000      /* Clone io context */</span>
 <span class="token comment">#endif</span>
 
@@ -256,7 +259,9 @@ static <span class="token builtin class-name">type</span> name <span class="token punctuation">(</span>type1 arg1,type2 arg2,
 <span class="token comment">#endif</span>
 
 <span class="token comment">#ifdef __NR_gettid</span>
-_syscall0<span class="token punctuation">(</span>int, gettid<span class="token punctuation">)</span>
+// taken from https://patchwork.kernel.org/patch/10862231/
+<span class="token comment">#define __NR_sys_gettid __NR_gettid</span>
+_syscall0<span class="token punctuation">(</span>int, sys_gettid<span class="token punctuation">)</span>
 <span class="token comment">#else</span>
 /* This is a replacement <span class="token keyword">for</span> the <span class="token function">host</span> gettid<span class="token punctuation">(</span><span class="token punctuation">)</span> and must <span class="token builtin class-name">return</span> a <span class="token function">host</span>
    errno. */
@@ -6219,7 +6224,8 @@ static void *clone_func<span class="token punctuation">(</span>void *arg<span class="token punctuation">)</span>
     cpu <span class="token operator">=</span> ENV_GET_CPU<span class="token punctuation">(</span>env<span class="token punctuation">)</span><span class="token punctuation">;</span>
     thread_cpu <span class="token operator">=</span> cpu<span class="token punctuation">;</span>
     ts <span class="token operator">=</span> <span class="token punctuation">(</span>TaskState *<span class="token punctuation">)</span>cpu-<span class="token operator">&gt;</span>opaque<span class="token punctuation">;</span>
-    info-<span class="token operator">&gt;</span>tid <span class="token operator">=</span> gettid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
+    // taken from https://patchwork.kernel.org/patch/10862231/
+    info-<span class="token operator">&gt;</span>tid <span class="token operator">=</span> sys_gettid<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     task_settid<span class="token punctuation">(</span>ts<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>info-<span class="token operator">&gt;</span>child_tidptr<span class="token punctuation">)</span>
         put_user_u32<span class="token punctuation">(</span>info-<span class="token operator">&gt;</span>tid, info-<span class="token operator">&gt;</span>child_tidptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
@@ -6363,9 +6369,11 @@ static int do_fork<span class="token punctuation">(</span>CPUArchState *env, un
                mapping.  We can't repeat the spinlock hack used above because
                the child process gets its own copy of the lock.  */
             <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> CLONE_CHILD_SETTID<span class="token punctuation">)</span>
-                put_user_u32<span class="token punctuation">(</span>gettid<span class="token punctuation">(</span><span class="token punctuation">)</span>, child_tidptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
+                // taken from https://patchwork.kernel.org/patch/10862231/
+                put_user_u32<span class="token punctuation">(</span>sys_gettid<span class="token punctuation">(</span><span class="token punctuation">)</span>, child_tidptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
             <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> CLONE_PARENT_SETTID<span class="token punctuation">)</span>
-                put_user_u32<span class="token punctuation">(</span>gettid<span class="token punctuation">(</span><span class="token punctuation">)</span>, parent_tidptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
+                // taken from https://patchwork.kernel.org/patch/10862231/
+                put_user_u32<span class="token punctuation">(</span>sys_gettid<span class="token punctuation">(</span><span class="token punctuation">)</span>, parent_tidptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
             ts <span class="token operator">=</span> <span class="token punctuation">(</span>TaskState *<span class="token punctuation">)</span>cpu-<span class="token operator">&gt;</span>opaque<span class="token punctuation">;</span>
             <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> CLONE_SETTLS<span class="token punctuation">)</span>
                 cpu_set_tls <span class="token punctuation">(</span>env, newtls<span class="token punctuation">)</span><span class="token punctuation">;</span>
@@ -11402,7 +11410,8 @@ abi_long do_syscall<span class="token punctuation">(</span>void *cpu_env, int n
         <span class="token builtin class-name">break</span><span class="token punctuation">;</span>
 <span class="token comment">#endif</span>
     <span class="token keyword">case</span> TARGET_NR_gettid:
-        ret <span class="token operator">=</span> get_errno<span class="token punctuation">(</span>gettid<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
+        // taken from https://patchwork.kernel.org/patch/10862231/
+        ret <span class="token operator">=</span> get_errno<span class="token punctuation">(</span>sys_gettid<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span>
         <span class="token builtin class-name">break</span><span class="token punctuation">;</span>
 <span class="token comment">#ifdef TARGET_NR_readahead</span>
     <span class="token keyword">case</span> TARGET_NR_readahead:
</code></pre> 
<p>完成安装后：<br> <img src="https://images2.imgbox.com/a2/96/9XdaiscL_o.png" alt="在这里插入图片描述"><br> 使用Qemu模式来fuzz缺少源代码的二进制程序，使用-Q参数</p> 
<p>如果提示出现Failed to locate afl-qemu-trace的问题<br> 在qemu-2.10.0目录下执行</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/00/61/MsiKZqkz_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/1e/bf/r5WfN3mj_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-gAXowIjs-1672297678087)(images/0ddd64b9f4395aa5a88365027715927c4c0269a69eaa26794f2159de99f6693e.png)]"></p> 
<p>执行速度比起源码fuzz有显著下降</p> 
<p>关于ARM这部分，看到Qemu的Readme里描述说在调用之前设置CPU_TARGET/build_qemu_support.sh，可以得到一个能够运行非本机二进制文件的构建（例如可以尝试CPU_TARGET=arm）</p> 
<p>关于ARM架构的二进制FUZZ后面有待尝试，UU们有什么推荐的好工具嘛？</p> 
<p>参考:<br> https://xz.aliyun.com/t/4314<br> https://blog.csdn.net/A951860555/article/details/119666269<br> https://blog.csdn.net/qq_42931917/article/details/112801073<br> https://blog.csdn.net/qysh123/article/details/114792891</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a040a07803446942ab72a707ecdada6d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">关于GIT的常用命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4a7c26cd7fba5f80d02278783cb896f4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java实现多线程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>