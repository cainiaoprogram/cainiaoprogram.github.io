<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【数字IC基础】跨时钟域（CDC，Clock Domain Crossing） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【数字IC基础】跨时钟域（CDC，Clock Domain Crossing）" />
<meta property="og:description" content="文章目录 一、什么是跨时钟域？二、跨时钟域传输的问题？2、1 亚稳态（单bit：两级D触发器（双DFF））2、2 数据收敛（多bit亚稳态）（格雷码编码、握手协议、异步FIFO、DMUX）2、3 多路扇出：（先同步后扇出）2、4 数据丢失（延长输入数据信号）：类似脉冲展宽2、5 异步复位（同步释放） 三、跨时钟域传输问题的解决方法？3、1 单比特信号3、1、1 单比特脉冲信号（慢时钟域到快时钟域）：两级D触发器同步处理3、1、2 单比特脉冲信号（快时钟域到慢时钟域）：脉冲展宽 3、2 多比特信号3、2、1 格雷码&#43;双DFF（异步FIFO）3、2、2 握手协议3、2、3 DMUX（D触发器加二选一选择器）数据使能选通设计 一、什么是跨时钟域？ 1、同步设计：在同步设计中，整个设计都是使用同一个时钟源，所有时钟的频率和相位都可以事先预知
2、异步设计：在设计中有两个或以上的时钟， 且时钟之间是同频不同相或不同频的关系，异步时序设计的关键就是把数据或控制信号正确地进行跨时钟域传输。
3、跨时钟域（CDC，Clock Domain Crossing）：数据从一个时钟域传输到另一个时钟域 4、跨时钟域是如何产生的呢？ 现在的芯片（比如SOC，片上系统）集成度和复杂度越来越高，通常一颗芯片上会有许多不同的信号工作在不同的时钟频率下。比如SOC芯片中的CPU通常会工作在一个频率上，总线信号（比如DRAM BUS）会工作在另一个时钟频率下，而普通的信号又会工作在另外的时钟频率下。这3个不同时钟频率下工作的信号往往需要相互沟通和传递信号。不同时钟域下的信号传递就涉及到跨时钟域信号处理。
二、跨时钟域传输的问题？ 跨时钟域问题的本质是：亚稳态，根据传输的数据大小，分为单比特亚稳态、多比特亚稳态
组合逻辑竞争冒险、时序逻辑亚稳态 2、1 亚稳态（单bit：两级D触发器（双DFF）） 亚稳态：数据无法在规定的时间段内达到一个稳定的状态
亚稳态的发生原因：
1、数据：数据传输中不满足D触发器的建立时间Tsu和保持时间Th要求2、复位：复位过程中复位信号的释放相对于有效时钟沿的恢复时间（recovery time）和移除时间（removal time）不满足 亚稳态主要发生在异步信号采集、跨时钟域信号传输以及异步复位电路等常用设计中
亚稳态输出不确定，但是会传给后一级触发器，这会导致后级电路出错，所以亚稳态危害很大
1、单bit信号的跨时钟域传输：用两级D触发器做同步处理 2、常见错误：时钟域A的组合逻辑信号（即时钟域A发出的信号先经过组合逻辑再传输到时钟域B）直接敲两级DFF同步到时钟域B
解决方案：时钟域A的组合逻辑信号必须先经过一级DFF，等数据稳定后，再传输到B时钟域
2、2 数据收敛（多bit亚稳态）（格雷码编码、握手协议、异步FIFO、DMUX） 1、数据收敛：如何确保一组相关联的同步信号在经过不同的路径之后可以在某一个相同的时钟周期正确地到达另一个时钟域。2、对于多bit信号跨时钟域传输时，虽然可以对每一个信号使用Double FF来进行信号同步，但是信号的准确性和关联性却会出现问题，这就是数据的收敛问题，也就是多bit信号的亚稳态。3、比如有两个相关联的信号X，Y要从时钟域clk_A向时钟域clk_B传播，这里分别对两个信号进行两级DFF同步处理，最终同步信号就可以满足后续电路的时序要求，但是可能会出现如下的情况：
4、多bit信号的跨时钟域传输：格雷码编码、握手协议、FIFO 2、3 多路扇出：（先同步后扇出） 1、有些情况下，一个信号在跨越时钟域之后又分为了多个分支。比如：一个使能的控制信号分别使能后续的多个模块
①、同一个信号源经过不同的路径跨越时钟域之后，多路扇出的值不一定相同
2、解决方法：将信号同步之后再多路扇出（即先在时钟域B过两级DFF同步，再将信号扇出，不要在各自的分支上同步）
2、4 数据丢失（延长输入数据信号）：类似脉冲展宽 1、输入端信号不能保持足够的时间使得接收端不能采样到数据，导致数据丢失
2、解决方案：延长输入信号
2、5 异步复位（同步释放） 1、在亚稳态一节中，我们讲到：异步复位信号在释放时不满足恢复recovery时间和移除removal时间要求，会导致亚稳态 异步复位信号引起的触发器亚稳态并不是在复位的时候出现的，而是在复位信号释放时出现的 2、虽然异步信号没有固定的时钟，但我们还是把它看作一个CDC问题
3、解决方法：在异步复位信号释放时对其进行同步处理（即设计要求中，常讲的：“复位信号——异步复位同步释放） ①、异步复位信号之所以会导致触发器出现亚稳态，原因在于：复位信号释放时不能够与触发器的时钟保持同步②、因此可以通过对复位信号同步处理来解决
//Synchronized Asynchronous Reset //异步复位、同步释放：只适用于没有PLL的系统复位信号的设置 module sync_async_reset(clock,reset_n,rst_n); input clock, reset_n; output rst_n; reg rst_nr1;//打一拍 reg rst_nr2;//打两拍 always @(posedge clock or negedge reset_n) begin if(!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/96980e87e601ed404be43f9b9c7887f8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-16T11:16:49+08:00" />
<meta property="article:modified_time" content="2023-05-16T11:16:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【数字IC基础】跨时钟域（CDC，Clock Domain Crossing）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#_1" rel="nofollow">一、什么是跨时钟域？</a></li><li><a href="#_16" rel="nofollow">二、跨时钟域传输的问题？</a></li><li><ul><li><a href="#21_bitDDFF_21" rel="nofollow">2、1 亚稳态（单bit：两级D触发器（双DFF））</a></li><li><a href="#22_bitFIFODMUX_41" rel="nofollow">2、2 数据收敛（多bit亚稳态）（格雷码编码、握手协议、异步FIFO、DMUX）</a></li><li><a href="#23__47" rel="nofollow">2、3 多路扇出：（先同步后扇出）</a></li><li><a href="#24__54" rel="nofollow">2、4 数据丢失（延长输入数据信号）：类似脉冲展宽</a></li><li><a href="#25__59" rel="nofollow">2、5 异步复位（同步释放）</a></li></ul> 
   </li><li><a href="#_99" rel="nofollow">三、跨时钟域传输问题的解决方法？</a></li><li><ul><li><a href="#31__104" rel="nofollow">3、1 单比特信号</a></li><li><ul><li><a href="#311_D_110" rel="nofollow">3、1、1 单比特脉冲信号（慢时钟域到快时钟域）：两级D触发器同步处理</a></li><li><a href="#312__207" rel="nofollow">3、1、2 单比特脉冲信号（快时钟域到慢时钟域）：脉冲展宽</a></li></ul> 
    </li><li><a href="#32__341" rel="nofollow">3、2 多比特信号</a></li><li><ul><li><a href="#321_DFFFIFO_342" rel="nofollow">3、2、1 格雷码+双DFF（异步FIFO）</a></li><li><a href="#322__363" rel="nofollow">3、2、2 握手协议</a></li><li><a href="#323_DMUXD_449" rel="nofollow">3、2、3 DMUX（D触发器加二选一选择器）数据使能选通设计</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_1"></a>一、什么是跨时钟域？</h3> 
<ul><li>1、<strong>同步设计</strong>：<font face="楷体" color="#FF0000" size="3"><strong>在同步设计中，整个设计都是使用同一个时钟源，所有时钟的频率和相位都可以事先预知</strong></font><br> <img src="https://images2.imgbox.com/98/32/hZ0ZU3ts_o.png" alt="在这里插入图片描述"></li><li>2、<strong>异步设计</strong>：在设计中有<strong>两个或以上的时钟</strong>， 且时钟之间是<mark>同频不同相</mark>或<mark>不同频</mark>的关系，异步时序设计的关键就是把数据或控制信号正确地进行<strong>跨时钟域传输</strong>。<br> <img src="https://images2.imgbox.com/95/e7/COKcUm9v_o.png" alt="在这里插入图片描述"></li><li>3、<strong>跨时钟域（CDC，Clock Domain Crossing）</strong>：<strong>数据从一个时钟域传输到另一个时钟域</strong></li></ul> 
<p><img src="https://images2.imgbox.com/66/f0/KQs8D7fp_o.png" alt="在这里插入图片描述"></p> 
<ul><li>4、<strong>跨时钟域是如何产生的呢</strong>？</li></ul> 
<blockquote> 
 <p>现在的芯片（比如SOC，片上系统）集成度和复杂度越来越高，通常一颗芯片上会有许多<font color="red"><strong>不同的信号工作在不同的时钟频率下</strong></font>。比如SOC芯片中的CPU通常会工作在一个频率上，总线信号（比如DRAM BUS）会工作在另一个时钟频率下，而普通的信号又会工作在另外的时钟频率下。这3个<font color="red"><strong>不同时钟频率下工作的信号往往需要相互沟通和传递信号</strong></font>。<font color="red"><strong>不同时钟域下的信号传递就涉及到跨时钟域信号处理</strong></font>。</p> 
</blockquote> 
<h3><a id="_16"></a>二、跨时钟域传输的问题？</h3> 
<ul><li>跨时钟域问题的本质是：<font color="red"><strong>亚稳态</strong></font>，根据传输的数据大小，分为<mark>单比特亚稳态、多比特亚稳态</mark><br> <a href="https://blog.csdn.net/claylovetoo/article/details/128067474?spm=1001.2014.3001.5501">组合逻辑竞争冒险、时序逻辑亚稳态</a></li></ul> 
<h4><a id="21_bitDDFF_21"></a>2、1 亚稳态（单bit：两级D触发器（双DFF））</h4> 
<blockquote> 
 <p><mark>亚稳态：数据无法在规定的时间段内达到一个稳定的状态</mark><br> 亚稳态的发生原因：</p> 
 <ul><li>1、数据：<strong>数据传输</strong>中不满足D触发器的<code>建立时间Tsu</code>和<code>保持时间Th</code>要求</li><li>2、复位：<strong>复位过程中</strong>复位信号的释放相对于有效时钟沿的<code>恢复时间（recovery time）</code>和<code>移除时间（removal time）</code>不满足</li></ul> 
 <p><code>亚稳态</code>主要发生在<font color="red"><strong>异步信号采集</strong></font>、<font color="red"><strong>跨时钟域信号传输</strong></font>以及<font color="red"><strong>异步复位电路</strong></font>等常用设计中<br> 亚稳态<strong>输出不确定</strong>，但是<strong>会传给后一级触发器</strong>，这会导致后级电路出错，所以亚稳态危害很大<br> <img src="https://images2.imgbox.com/1a/0d/OGGZRLK8_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<ul><li>1、<mark>单bit信号的跨时钟域传输：用两级D触发器做同步处理</mark></li></ul> 
<p><img src="https://images2.imgbox.com/a8/b6/TV3qFqjI_o.png" alt="在这里插入图片描述"></p> 
<ul><li>2、<font color="red"><strong>常见错误</strong></font>：<mark>时钟域A的组合逻辑信号</mark><font color="blue"><strong>（即时钟域A发出的信号先经过组合逻辑再传输到时钟域B）</strong></font><mark>直接敲两级DFF同步到时钟域B</mark><br> <img src="https://images2.imgbox.com/38/fa/DOo7Hr1C_o.png" alt="在这里插入图片描述"> 
  <ul><li>解决方案：<mark>时钟域A的组合逻辑信号</mark>必须<strong>先经过一级DFF，等数据稳定后</strong>，再传输到B时钟域<br> <img src="https://images2.imgbox.com/8d/d7/xnBvN7r3_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<h4><a id="22_bitFIFODMUX_41"></a>2、2 数据收敛（多bit亚稳态）（格雷码编码、握手协议、异步FIFO、DMUX）</h4> 
<ul><li>1、<strong>数据收敛</strong>：如何确保<font color="red"><strong>一组相关联的同步信号</strong></font>在<font color="red"><strong>经过不同的路径</strong></font>之后可以<font color="red"><strong>在某一个相同的时钟周期正确地到达另一个时钟域</strong></font>。</li><li>2、对于多bit信号跨时钟域传输时，虽然可以对每一个信号使用Double FF来进行信号同步，<font face="楷体" color="#FF0000" size="3"><strong>但是信号的准确性和关联性却会出现问题，这就是数据的收敛问题，也就是多bit信号的亚稳态</strong></font>。</li><li>3、比如有两个相关联的信号X，Y要从时钟域clk_A向时钟域clk_B传播，这里分别对两个信号进行两级DFF同步处理，最终同步信号就可以满足后续电路的时序要求，但是可能会出现如下的情况：<br> <img src="https://images2.imgbox.com/b0/ab/xPDZOWxj_o.png" alt="在这里插入图片描述"></li><li>4、<mark>多bit信号的跨时钟域传输：格雷码编码、握手协议、FIFO</mark></li></ul> 
<h4><a id="23__47"></a>2、3 多路扇出：（先同步后扇出）</h4> 
<ul><li> <p>1、有些情况下，<strong>一个信号在跨越时钟域之后又分为了多个分支</strong>。比如：<code>一个使能的控制信号分别使能后续的多个模块</code></p> 
  <ul><li>①、<font color="red"><strong>同一个信号源经过不同的路径跨越时钟域之后，多路扇出的值不一定相同</strong></font><br> <img src="https://images2.imgbox.com/47/80/MOi8cwKT_o.png" alt="在这里插入图片描述"></li></ul> </li><li> <p>2、解决方法：<strong>将信号同步之后再多路扇出（即先在时钟域B过两级DFF同步，再将信号扇出，不要在各自的分支上同步）</strong><br> <img src="https://images2.imgbox.com/fc/1d/2hQgpq58_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<h4><a id="24__54"></a>2、4 数据丢失（延长输入数据信号）：类似脉冲展宽</h4> 
<ul><li>1、<strong>输入端信号不能保持足够的时间使得接收端不能采样到数据，导致数据丢失</strong><br> <img src="https://images2.imgbox.com/3e/47/t6rOYte2_o.png" alt="在这里插入图片描述"></li><li>2、解决方案：<strong>延长输入信号</strong><br> <img src="https://images2.imgbox.com/f6/33/Nhdrt3An_o.png" alt="在这里插入图片描述"></li></ul> 
<h4><a id="25__59"></a>2、5 异步复位（同步释放）</h4> 
<ul><li>1、在<strong>亚稳态</strong>一节中，我们讲到：<strong>异步复位信号在</strong><font color="red"><strong>释放</strong></font><strong>时不满足</strong><code>恢复recovery时间</code><strong>和</strong><code>移除removal时间</code><strong>要求</strong>，<strong>会导致亚稳态</strong> 
  <ul><li>异步复位信号引起的触发器亚稳态并不是在复位的时候出现的，而是<font color="red"><strong>在复位信号释放时出现的</strong></font></li></ul> </li><li>2、虽然异步信号没有固定的时钟，但我们还是把它看作一个CDC问题<br> <img src="https://images2.imgbox.com/5e/d7/MIqAeGPe_o.png" alt="在这里插入图片描述"></li><li>3、解决方法：<font color="red"><strong>在异步复位信号释放时对其进行同步处理</strong></font>（<mark>即设计要求中，常讲的：“复位信号——异步复位同步释放</mark>） 
  <ul><li>①、异步复位信号之所以会导致触发器出现亚稳态，原因在于：<strong>复位信号释放时不能够与触发器的时钟保持同步</strong></li><li>②、因此可以通过<strong>对复位信号同步处理来解决</strong><br> <img src="https://images2.imgbox.com/92/5d/D6IwC8EZ_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> 
<pre><code class="prism language-c"><span class="token comment">//Synchronized Asynchronous Reset</span>
<span class="token comment">//异步复位、同步释放：只适用于没有PLL的系统复位信号的设置</span>
module <span class="token function">sync_async_reset</span><span class="token punctuation">(</span>clock<span class="token punctuation">,</span>reset_n<span class="token punctuation">,</span>rst_n<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
    input clock<span class="token punctuation">,</span> reset_n<span class="token punctuation">;</span>
    output rst_n<span class="token punctuation">;</span>
 
    reg rst_nr1<span class="token punctuation">;</span><span class="token comment">//打一拍</span>
    reg rst_nr2<span class="token punctuation">;</span><span class="token comment">//打两拍</span>
 
    always @<span class="token punctuation">(</span>posedge clock or negedge reset_n<span class="token punctuation">)</span> begin
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>reset_n<span class="token punctuation">)</span> begin
			rst_nr1 <span class="token operator">&lt;=</span> <span class="token number">1</span>'b0<span class="token punctuation">;</span>
            rst_nr2 <span class="token operator">&lt;=</span> <span class="token number">1</span>'b0<span class="token punctuation">;</span>		<span class="token comment">//异步复位（一旦复位信号有效，就拉低）</span>
        end
        <span class="token keyword">else</span> begin
			rst_nr1 <span class="token operator">&lt;=</span> <span class="token number">1</span>'b1<span class="token punctuation">;</span>
			rst_nr2 <span class="token operator">&lt;=</span> rst_nr1<span class="token punctuation">;</span>		<span class="token comment">//同步释放（打两拍，再拉高（释放））</span>
		end
    end
	
	assign rst_n <span class="token operator">=</span> rst_nr2<span class="token punctuation">;</span>			<span class="token comment">//新的系统复位信号rst_n</span>
    <span class="token comment">//信号rst_n作为新的系统复位信号，后续可以用来直接“异步复位”</span>
	
endmodule							<span class="token comment">// sync_async_reset</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/74/bd/sBbYLlk6_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_99"></a>三、跨时钟域传输问题的解决方法？</h3> 
<ul><li>1、跨时钟域信号传输分为：<font color="red"><strong>单比特信号、多比特信号</strong></font> 
  <ul><li><mark>单比特脉冲信号跨时钟域传输</mark>又分为：<font color="red"><strong>慢时钟域到快时钟域、快时钟域到慢时钟域</strong></font></li></ul> </li></ul> 
<h4><a id="31__104"></a>3、1 单比特信号</h4> 
<ul><li>1、如果是<font color="red"><strong>电平信号</strong></font>：可以用<font color="red"><strong>两级D触发器同步</strong></font>来实现跨时钟域传输</li><li>2、如果是<font color="red"><strong>脉冲信号（数据稳定一个时钟周期）</strong></font>： 
  <ul><li>①、<mark>慢到快</mark>：先用<strong>两级D触发器实现同步</strong>，再用<strong>边沿检测电路得到脉冲信号</strong></li><li>②、<mark>快到慢</mark>：先将<strong>脉冲信号展宽</strong>，再<strong>同步到慢时钟域</strong>，最后用<strong>边沿检测电路得到脉冲信号</strong></li></ul> </li></ul> 
<h5><a id="311_D_110"></a>3、1、1 单比特脉冲信号（慢时钟域到快时钟域）：两级D触发器同步处理</h5> 
<p><img src="https://images2.imgbox.com/be/ca/rwQajmd3_o.png" alt="在这里插入图片描述"></p> 
<ul><li>1、<strong>单比特电平信号：</strong></li></ul> 
<pre><code class="prism language-c"><span class="token comment">//单比特电平信号</span>
module <span class="token function">single_cdc</span><span class="token punctuation">(</span>
	input clk1<span class="token punctuation">,</span>
	input clk2<span class="token punctuation">,</span>
	input rst_n<span class="token punctuation">,</span>
	input signal_in<span class="token punctuation">,</span>
	
	output signal_out

<span class="token punctuation">)</span><span class="token punctuation">;</span>

reg signal_out_r<span class="token punctuation">;</span>  <span class="token comment">//打一拍</span>
reg signal_out_rr<span class="token punctuation">;</span>  <span class="token comment">//打两拍</span>

always @<span class="token punctuation">(</span>posedge clk2 or negedge rst_n<span class="token punctuation">)</span> begin
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span> begin
		signal_out_r  <span class="token operator">&lt;=</span> <span class="token number">1</span>'b0<span class="token punctuation">;</span>
		signal_out_rr <span class="token operator">&lt;=</span> <span class="token number">1</span>'b0<span class="token punctuation">;</span>
	end
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>signal_in <span class="token operator">==</span> <span class="token number">1</span>'b1<span class="token punctuation">)</span> begin
		signal_out_r <span class="token operator">&lt;=</span> signal_in<span class="token punctuation">;</span>
		signal_out_rr <span class="token operator">&lt;=</span> signal_out_r<span class="token punctuation">;</span>
	end
	<span class="token keyword">else</span> begin
		signal_out_r <span class="token operator">&lt;=</span> <span class="token number">1</span>'b0<span class="token punctuation">;</span>
		signal_out_rr <span class="token operator">&lt;=</span> <span class="token number">1</span>'b0<span class="token punctuation">;</span>
	end
end

assign signal_out <span class="token operator">=</span> signal_out_rr<span class="token punctuation">;</span>

endmodule

</code></pre> 
<ul><li>2、<strong>单比特脉冲信号：慢到快</strong></li></ul> 
<pre><code class="prism language-c"><span class="token comment">//单比特脉冲信号:慢到快</span>
module <span class="token function">single_cdc</span><span class="token punctuation">(</span>
	input clk1<span class="token punctuation">,</span>
	input clk2<span class="token punctuation">,</span>
	input rst_n<span class="token punctuation">,</span>
	input signal_in<span class="token punctuation">,</span>
	
	output reg signal_out

<span class="token punctuation">)</span><span class="token punctuation">;</span>

reg signal_out_r<span class="token punctuation">;</span>  <span class="token comment">//打一拍</span>
reg signal_out_rr<span class="token punctuation">;</span>  <span class="token comment">//打两拍</span>

reg signal_out_rrr<span class="token punctuation">;</span>  <span class="token comment">//边沿检测电路</span>

always @<span class="token punctuation">(</span>posedge clk2 or negedge rst_n<span class="token punctuation">)</span> begin
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span> begin
		signal_out_r  <span class="token operator">&lt;=</span> <span class="token number">1</span>'b0<span class="token punctuation">;</span>
		signal_out_rr <span class="token operator">&lt;=</span> <span class="token number">1</span>'b0<span class="token punctuation">;</span>
	end
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>signal_in <span class="token operator">==</span> <span class="token number">1</span>'b1<span class="token punctuation">)</span> begin
		signal_out_r <span class="token operator">&lt;=</span> signal_in<span class="token punctuation">;</span>
		signal_out_rr <span class="token operator">&lt;=</span> signal_out_r<span class="token punctuation">;</span>
		signal_out_rrr <span class="token operator">&lt;=</span> signal_out_rr<span class="token punctuation">;</span>
	end
	<span class="token keyword">else</span> begin
		signal_out_r <span class="token operator">&lt;=</span> <span class="token number">1</span>'b0<span class="token punctuation">;</span>
		signal_out_rr <span class="token operator">&lt;=</span> <span class="token number">1</span>'b0<span class="token punctuation">;</span>
		signal_out_rrr <span class="token operator">&lt;=</span> <span class="token number">1</span>'b0<span class="token punctuation">;</span>
	end
end

<span class="token comment">//组合逻辑（与逻辑）输出脉冲</span>
assign signal_out <span class="token operator">=</span> signal_out_rr <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>signal_out_rrr<span class="token punctuation">;</span>

endmodule
</code></pre> 
<ul><li>3、<strong>为啥是两级D触发器呢（一级或三级行不行）？</strong></li></ul> 
<blockquote> 
 <p>这里有一个平均失效间隔时间MTBF(Mean Time Between Failure)的考虑。<font color="red"> <strong>MTBF即触发器采样失败的时间间隔，MTBF时间越长，出现亚稳态的概率就越小，但是也不能完全避免亚稳态</strong></font>。过一级DFF，相当于乘了一个MTBF，也就是说，每过一级DFF，MTBF就会变大，亚稳态概率就会变小。<br> <img src="https://images2.imgbox.com/8f/1d/PNddtLwI_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<ul><li>各参数含义：</li></ul> 
<p><img src="https://images2.imgbox.com/30/eb/9rhwj1ok_o.png" alt="在这里插入图片描述"></p> 
<ul><li>如果在时钟频率 和数据变化率固定的情况下，<strong>要增大MTBF，设计者要做的只能是增大Tmet的值</strong></li><li>为了<strong>增加Tmet</strong>：可以<mark>增加同步链的寄存器个数</mark>，因为<mark>寄存器到寄存器之间的时间余量会累加到Tmet上</mark></li><li>有文献给出的数据：对于一个采样频率为200Mhz的系统，如果不做同步MTBF是2.5us，一级DFF同步的MTBF大概是23年，两级DFF同步的大约MTBF大概是640年，<font color="red"><strong>MTBF越长出错的概率越小。所以一级看上去不太稳，二级差不多够用了，至于三级可能会影响到系统的性能，而且增加面积，所以看上去没什么必要</strong></font>。</li></ul> 
<h5><a id="312__207"></a>3、1、2 单比特脉冲信号（快时钟域到慢时钟域）：脉冲展宽</h5> 
<ul><li> <p>1、从慢时钟域到快时钟域的单比特数据传输，用两级D触发器同步的方法就可以解决； 但从快时钟域到慢时钟域呢？用两级DFF同步的方法已经无法满足了（慢时钟域仍然无法采集到信号），此时我们就引入了脉冲展宽信号，<font color="red"><strong>把快时钟域的信号多稳定一段时间，等到慢时钟域采到了，再拉低，如此便能保证数据的跨时钟域传输</strong></font>。</p> </li><li> <p>2、具体实现：</p> 
  <ul><li>①、快时钟域，当采样到输入信号为高时，拉高脉冲展宽信号； 
    <ul><li><mark>脉冲展宽信号也可以理解为一个比clk_slow慢的多的时钟，那么从慢时钟域（脉冲展宽信号）到快时钟域（clk_slow）的信号只要过两级DFF，就一定能被快时钟域采样到</mark></li></ul> </li><li>②、<font color="red"><strong>脉冲展宽信号在慢时钟域过两级DFF</strong></font>，确保慢时钟域采样到脉冲展宽信号，随后将信息返回到快时钟域==（慢到快：信号在快时钟域过两级D触发器）==</li><li>③、快时钟域采样到慢时钟域返回的高电平（表示慢时钟域已经成功采样到输入信号），将脉冲展宽信号拉低；慢时钟域采样到脉冲展宽信号为低，则拉低慢时钟域信号</li><li>④、慢时钟域用<strong>边沿检测电路</strong>得到脉冲信号<br> <img src="https://images2.imgbox.com/bc/17/ZWo0Kj38_o.png" alt="在这里插入图片描述"></li></ul> </li><li> <p>3、在快时钟域的一个单脉冲信号<code>signal_in</code>，当快时钟域时钟采集到该信号为<code>1</code>时拉高<code>singal_a</code>，以展宽该脉冲，方便慢时钟域采样；展宽后的脉冲通过慢时钟域进行采集(过两级DFF)得到<code>singal_b_r</code>。紧接着利用<code>singal_b_r</code>进行两个操作：①、<strong>拉低快时钟域的展宽信号</strong><code>singal_a</code>，表示慢时钟域已经采集到该脉冲；②、再次打拍后进行<strong>边沿检测</strong>，<strong>在慢时钟域输出该单脉冲</strong>。</p> </li><li> <p>4、代码：</p> </li></ul> 
<pre><code class="prism language-c">module <span class="token function">led</span><span class="token punctuation">(</span>
	input clk_fast<span class="token punctuation">,</span>
	input clk_slow<span class="token punctuation">,</span>
	input rst_n<span class="token punctuation">,</span>
	input signal_in<span class="token punctuation">,</span>
	
	output signal_out

<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//快时钟域脉冲展宽</span>
reg signal_a<span class="token punctuation">;</span>
always @<span class="token punctuation">(</span>posedge clk_fast or negedge rst_n<span class="token punctuation">)</span> begin
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>
		signal_a <span class="token operator">&lt;=</span> <span class="token number">1</span>'b0<span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>signal_in <span class="token operator">==</span> <span class="token number">1</span>'b1<span class="token punctuation">)</span><span class="token comment">//拉高</span>
		signal_a <span class="token operator">&lt;=</span> signal_in<span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>signal_a_rr <span class="token operator">==</span> <span class="token number">1</span>'b1<span class="token punctuation">)</span><span class="token comment">//拉低</span>
		signal_a <span class="token operator">&lt;=</span> <span class="token number">1</span>'b0<span class="token punctuation">;</span>
	<span class="token comment">//其它情况，保持上一时刻的值，这里可以省略</span>
end


<span class="token comment">//慢时钟域采集脉冲展宽信号</span>
<span class="token comment">//信号同步不用加判断条件</span>
reg signal_b<span class="token punctuation">;</span>  <span class="token comment">//打一拍</span>
reg signal_b_r<span class="token punctuation">;</span>  <span class="token comment">//打两拍</span>
always @<span class="token punctuation">(</span>posedge clk_slow or negedge rst_n<span class="token punctuation">)</span> begin
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span> begin
		signal_b  <span class="token operator">&lt;=</span> <span class="token number">1</span>'b0<span class="token punctuation">;</span>
		signal_b_r <span class="token operator">&lt;=</span> <span class="token number">1</span>'b0<span class="token punctuation">;</span>
	end
	<span class="token keyword">else</span>  begin
		signal_b <span class="token operator">&lt;=</span> signal_a<span class="token punctuation">;</span>
		signal_b_r <span class="token operator">&lt;=</span> signal_b<span class="token punctuation">;</span>
	end
end


<span class="token comment">//快时钟域采集慢时钟域返回信息：signal_b_r</span>
reg signal_a_r<span class="token punctuation">;</span>  <span class="token comment">//打一拍</span>
reg signal_a_rr<span class="token punctuation">;</span>  <span class="token comment">//打两拍</span>
always @<span class="token punctuation">(</span>posedge clk_fast or negedge rst_n<span class="token punctuation">)</span> begin
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>signal_a_rr<span class="token punctuation">,</span>signal_a_r<span class="token punctuation">}</span> <span class="token operator">&lt;=</span> <span class="token punctuation">{<!-- --></span><span class="token number">2</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span>'b0<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>signal_a_rr<span class="token punctuation">,</span>signal_a_r<span class="token punctuation">}</span> <span class="token operator">&lt;=</span> <span class="token punctuation">{<!-- --></span>signal_a_r<span class="token punctuation">,</span>signal_b_r<span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//左边给左边，右边给右边</span>
end

<span class="token comment">//慢时钟域边沿检测，得到脉冲信号</span>
<span class="token comment">//与逻辑检测上升沿：signal_b_r为1，且signal_b_rr为0</span>
reg signal_b_rr<span class="token punctuation">;</span> <span class="token comment">//上升沿检测,将signal_b_r打一拍</span>
always @<span class="token punctuation">(</span>posedge clk_slow or negedge rst_n<span class="token punctuation">)</span> begin
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>
		signal_b_rr  <span class="token operator">&lt;=</span> <span class="token number">1</span>'b0<span class="token punctuation">;</span>
	<span class="token keyword">else</span> 
		signal_b_rr <span class="token operator">&lt;=</span> signal_b_r<span class="token punctuation">;</span>
end	

assign signal_out <span class="token operator">=</span> signal_b_r <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>signal_b_rr<span class="token punctuation">)</span><span class="token punctuation">;</span>

endmodule
</code></pre> 
<ul><li>5、TestBench：</li></ul> 
<pre><code class="prism language-c">`timescale  <span class="token number">1</span>ns<span class="token operator">/</span><span class="token number">1</span>ns

module <span class="token function">tb_led</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

reg		rst_n<span class="token punctuation">;</span>
reg		clk_fast<span class="token punctuation">;</span>
reg		clk_slow<span class="token punctuation">;</span>
reg		pulse_in<span class="token punctuation">;</span>
wire	pulse_out<span class="token punctuation">;</span>


led	<span class="token function">u1</span>
<span class="token punctuation">(</span>
	<span class="token punctuation">.</span><span class="token function">rst_n</span>    <span class="token punctuation">(</span>rst_n    <span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">.</span><span class="token function">clk_fast</span> <span class="token punctuation">(</span>clk_fast <span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">.</span><span class="token function">clk_slow</span> <span class="token punctuation">(</span>clk_slow <span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token punctuation">.</span><span class="token function">signal_in</span> <span class="token punctuation">(</span>pulse_in <span class="token punctuation">)</span><span class="token punctuation">,</span>
			   		 
	<span class="token punctuation">.</span><span class="token function">signal_out</span><span class="token punctuation">(</span>pulse_out<span class="token punctuation">)</span>
	
<span class="token punctuation">)</span><span class="token punctuation">;</span>


initial
begin
	clk_fast 	 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	clk_slow 	 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	rst_n	 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	pulse_in <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	
	<span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>@<span class="token punctuation">(</span>posedge clk_slow<span class="token punctuation">)</span><span class="token punctuation">;</span>
	rst_n	 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>@<span class="token punctuation">(</span>posedge clk_slow<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">pulse_gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	
end


task pulse_gen<span class="token punctuation">;</span>
begin
	pulse_in <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">;</span>
	@<span class="token punctuation">(</span>posedge clk_slow<span class="token punctuation">)</span><span class="token punctuation">;</span>
	pulse_in <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
end
endtask

always #<span class="token number">10</span> clk_slow <span class="token operator">=</span> <span class="token operator">~</span>clk_slow<span class="token punctuation">;</span>
always #<span class="token number">5</span>  clk_fast <span class="token operator">=</span> <span class="token operator">~</span>clk_fast<span class="token punctuation">;</span>

endmodule
</code></pre> 
<h4><a id="32__341"></a>3、2 多比特信号</h4> 
<h5><a id="321_DFFFIFO_342"></a>3、2、1 格雷码+双DFF（异步FIFO）</h5> 
<blockquote> 
 <p><strong>常用于异步FIFO中读写地址的跨时钟域传递！</strong></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/84/f5/gndZfqzD_o.png" alt="在这里插入图片描述"></p> 
<ul><li>1、多比特信号<strong>为啥要转换成格雷码再同步</strong>，不直接同步呢？ 
  <ul><li>①、<font color="red"><strong>异步FIFO采用格雷码的最大原因是</strong>：<strong>即使发生了亚稳态，也不会发生错误的读写操作（即在写满的情况下，仍写数据；读空的情况下，仍读数据）</strong></font></li><li>②、注意！！！<font color="blue"><strong>可以在写满、读空之前判断成写满、读空</strong></font>，但是，<font color="blue"><strong>不能在已经写满、读空之后没有及时判断成写满、读空</strong></font></li><li>③、那格雷码是怎么办到的呢？ 
    <ul><li><strong>不同信号路径延时不同，导致它们无法被在同一个时钟沿被采样，信号打两拍之后可能出现不同状态</strong>： 
      <ul><li>假如是<strong>二进制码</strong>：地址从<code>0111变成1000</code>，直接打拍，如果发生亚稳态，则可能变成<code>1111、1001、1100</code>等<font color="red"><strong>中间态</strong></font>（因为<font color="blue"><strong>每个比特都会发生改变</strong></font>），这些<strong>中间态，很有可能造成已经写满、读空的状态下没有及时判断成写满、读空</strong>，发生<strong>数据的覆盖或者重复读出</strong>；</li><li>而<strong>格雷码相邻状态只有1bit不同</strong>，二进制的<code>0111变成1000</code>，转换成<strong>格雷码</strong>是<code>从0100变成1100（注意只有最高位发生了改变）</code>，如果发生亚稳态，也只会变成<code>0111</code>（因为<font color="blue"><strong>每次只改变一位信号：本例中是最高位发生变化（可以变成0或1）</strong></font>），这只会<strong>导致在写满、读空之前判断成写满、读空</strong>，而<strong>不会造成该空满而未报空满的情况</strong>。</li><li>具体来讲，假如是<strong>读地址同步到写时钟域（判断写满）</strong>，读指针<code>从0100变成1100</code>，如果写时钟域采到的是<code>0100</code>，则<code>1100</code>是实际的读指针，<code>0100</code>是同步到写时钟域的读指针，数据安全写入的标准是：<strong>同步到写时钟域的读指针应该小于等于实际的读指针（这样当写指针追了一圈，又追上读指针时，写满标志才是安全的）</strong>，而此时<code>0100</code>显然比<code>1100</code>要小，因此数据写入是安全的；</li><li>假如是<strong>写地址同步到读时钟域（判断读空）</strong>，写指针<code>从0100变成1100</code>，如果读时钟域采到的是<code>0100</code>，则<code>1100</code>是实际的写指针，<code>0100</code>是同步到读时钟域的写指针，数据安全读出的标准是：<strong>同步到读时钟域的写指针应该小于等于实际的写指针（这样当读指针追上写指针时，读空标志才是安全的）</strong>，而此时<code>0100</code>显然比<code>1100</code>要小，因此数据读出是安全的。</li></ul> </li></ul> </li></ul> </li><li>2、<font color="red"><strong>格雷码应用时一定要保证：首尾数据也只有1bit不同，也就是数据个数必须是</strong></font><code>2^n</code>，否则就不能用格雷码加双DFF的方式跨时钟域传输 
  <ul><li>①、例如：<strong>0到3的4个格雷码</strong>：<code>0000、0001、0011、0010</code>，则<code>首0000</code>和<code>尾0010</code>之间，<strong>只有1bit不同</strong>；<br> <strong>0到2的3个格雷码</strong>：<code>0000、0001、0011</code>，则<code>首0000</code>和<code>尾0011</code>之间，<strong>有2bit不同</strong>，因此不能用双DFF方式</li><li>对于那些<font color="red"><strong>无法用格雷码编码的多bit信号</strong></font>，可使用<font color="red"><strong>握手协议</strong></font>来处理跨时钟域的问题</li></ul> </li><li>3、二进制码转格雷码一般是通过组合电路实现的，由于组合电路不同的路径延时不同，因此<strong>转换后的格雷码</strong>必须在过两级DFF之前，<strong>先过一级DFF</strong>，<strong>保证输出稳定的数据</strong></li></ul> 
<h5><a id="322__363"></a>3、2、2 握手协议</h5> 
<ul><li> <p>1、握手协议<strong>将多比特数据的传输问题</strong>转换成<strong>单个信号的跨时钟域问题（只对请求信号REQ和应答信号ACK进行同步）</strong>；</p> </li><li> <p>2、握手协议可以<strong>只对请求信号REQ和应答信号ACK进行同步</strong>，在<strong>请求信号REQ有效期间，发送端的数据保持不变</strong>，因此握手协议可以<strong>满足并行数据传输安全的需要</strong><code>假设发送端：clk_a；接收端：clk_b</code></p> 
  <ul><li>①、类似于AXI的vaild和ready信号，<strong>发送端先将多比特数据驱动到总线上（先将数据准备好）</strong>，<strong>然后发送请求信号REQ</strong> `；</li><li>②、接收端识别到REQ有效，接收这组数据（<strong>这里只需要将REQ同步到接收端时钟域</strong>）<code>两个clk_b同步</code>；</li><li>③、接收完毕之后，接收端返回一个应答信号ACK<code>1个clk_b拉高应答ACK</code>；</li><li>④、发送端识别到ACK有效，则将REQ拉低（<strong>这里只需要将ACK同步到发送端时钟域</strong>）<code>两个clk_a同步+1个clk_a拉低REQ</code>；<br> <img src="https://images2.imgbox.com/e3/7b/kfzWICCY_o.png" alt="请添加图片描述"></li></ul> </li><li> <p>3、握手机制相关信号：</p> 
  <ul><li>①、时钟、复位：clk_a、clk_b、rst_n</li><li>②、a_en，data_in（这两者作为输入，可以当成一种协议，检测到a_en有效（下降沿）的时候，输入数据就更新，更新数据一直持续到a_en的下一个下降沿）</li><li>③、b_en：检测到a时钟域发出的请求信号的上升沿，则b时钟域可以接收数据</li></ul> </li><li> <p>代码：</p> </li></ul> 
<pre><code class="prism language-c">module <span class="token function">led</span><span class="token punctuation">(</span>
	input clk_a<span class="token punctuation">,</span>
	input clk_b<span class="token punctuation">,</span>
	input rst_n<span class="token punctuation">,</span>
	input a_en<span class="token punctuation">,</span>
	input <span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_in<span class="token punctuation">,</span>
	
	output b_en<span class="token punctuation">,</span> 
	output reg <span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_out
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//a_en下降沿检测（与逻辑）</span>
reg a_en_d1<span class="token punctuation">;</span>
wire a_en_neg<span class="token punctuation">;</span>

always @<span class="token punctuation">(</span>posedge clk_a or negedge rst_n<span class="token punctuation">)</span> begin
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>a_en_neg<span class="token punctuation">,</span>a_en_d1<span class="token punctuation">}</span> <span class="token operator">&lt;=</span> <span class="token punctuation">{<!-- --></span><span class="token number">2</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span>'b0<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> 
		a_en_d1 <span class="token operator">&lt;=</span> a_en<span class="token punctuation">;</span>
end

assign a_en_neg <span class="token operator">=</span> a_en_d1 <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>a_en<span class="token punctuation">;</span>

<span class="token comment">//a时钟域发出请求信号</span>
reg req_a<span class="token punctuation">;</span>
<span class="token comment">//ack信号打两拍同步到a时钟域</span>
reg ack_a_r<span class="token punctuation">;</span>
reg ack_a_rr<span class="token punctuation">;</span>

always @<span class="token punctuation">(</span>posedge clk_a or negedge rst_n<span class="token punctuation">)</span> begin
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>
		req_a <span class="token operator">&lt;=</span> <span class="token number">1</span>'b0<span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a_en_neg<span class="token punctuation">)</span>
		req_a <span class="token operator">&lt;=</span> <span class="token number">1</span>'b1<span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ack_a_rr<span class="token punctuation">)</span><span class="token comment">//拉低</span>
		req_a <span class="token operator">&lt;=</span> <span class="token number">1</span>'b0<span class="token punctuation">;</span>
	<span class="token comment">//其它情况，保持上一时刻的值，这里可以省略</span>
end

<span class="token comment">//请求信号打两拍同步到b时钟域</span>
reg req_b_r<span class="token punctuation">;</span>
reg req_b_rr<span class="token punctuation">;</span>
always @<span class="token punctuation">(</span>posedge clk_b or negedge rst_n<span class="token punctuation">)</span> begin
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>req_b_rr<span class="token punctuation">,</span>req_b_r<span class="token punctuation">}</span> <span class="token operator">&lt;=</span> <span class="token punctuation">{<!-- --></span><span class="token number">2</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span>'b0<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>req_b_rr<span class="token punctuation">,</span>req_b_r<span class="token punctuation">}</span> <span class="token operator">&lt;=</span> <span class="token punctuation">{<!-- --></span>req_b_r<span class="token punctuation">,</span>req_a<span class="token punctuation">}</span><span class="token punctuation">;</span>
end
<span class="token comment">//检测到a时钟域发出的请求信号的上升沿，则b时钟域可以接收数据</span>
assign b_en <span class="token operator">=</span> req_b_r <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>req_b_rr<span class="token punctuation">;</span>
<span class="token comment">//b时钟域接收数据</span>
always @<span class="token punctuation">(</span>posedge clk_b or negedge rst_n<span class="token punctuation">)</span> begin
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span> 
		data_out <span class="token operator">&lt;=</span> 'b0<span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>b_en<span class="token punctuation">)</span>
		data_out <span class="token operator">&lt;=</span>  data_in<span class="token punctuation">;</span>
end

<span class="token comment">//b时钟域接收完数据，发送ack信号,打两拍同步到a时钟域</span>
always @<span class="token punctuation">(</span>posedge clk_a or negedge rst_n<span class="token punctuation">)</span> begin
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>ack_a_rr<span class="token punctuation">,</span>ack_a_r<span class="token punctuation">}</span> <span class="token operator">&lt;=</span> <span class="token punctuation">{<!-- --></span><span class="token number">2</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span>'b0<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span>
		<span class="token punctuation">{<!-- --></span>ack_a_rr<span class="token punctuation">,</span>ack_a_r<span class="token punctuation">}</span> <span class="token operator">&lt;=</span> <span class="token punctuation">{<!-- --></span>ack_a_r <span class="token punctuation">,</span> req_b_rr<span class="token punctuation">}</span><span class="token punctuation">;</span>
end

endmodule
</code></pre> 
<h5><a id="323_DMUXD_449"></a>3、2、3 DMUX（D触发器加二选一选择器）数据使能选通设计</h5> 
<ul><li>1、通过一个<strong>使能信号来判断data信号是否已经稳定</strong>，当使能信号有效的时候说明data处于稳定状态，在这种情况下终点寄存器才对信号进行采样，可以保证没有setup/hold违例，相当于<mark>把多比特信号的CDC问题转换成了单比特信号的CDC问题</mark> 
  <ul><li>①、<code>慢时钟域到快时钟域</code>：只需要<strong>将使能信号过两级DFF，同步到接收时钟域</strong> ；</li><li>②、<code>快时钟域到慢时钟域</code>：需要<strong>将使能信号用脉冲展宽的方法同步到接收时钟域</strong> ；</li><li>②、<strong>使能信号接MUX的sel端口</strong>，若使能信号有效，则发送端数据选通，传输到接收端</li><li>③、若使能信号无效，则MUX的另一输入端选通，<strong>另一输入端与MUX的输出端（数据接收端）相连</strong>，相当于接收端数据保持不变 
    <ul><li>注意！！！<mark>MUX的输出端无法直接与输入端相连，需要先将输出数据保存在DFF中，再和输入端相连</mark><br> <img src="https://images2.imgbox.com/dc/e8/hpsIvoeK_o.png" alt="在这里插入图片描述"></li></ul> </li></ul> </li><li>2、代码：</li></ul> 
<pre><code class="prism language-c"><span class="token comment">//DMUX</span>
module <span class="token function">led</span><span class="token punctuation">(</span>
	input clk_a<span class="token punctuation">,</span>
	input clk_b<span class="token punctuation">,</span>
	input rst_n<span class="token punctuation">,</span>
	input a_en<span class="token punctuation">,</span>
	input <span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_in<span class="token punctuation">,</span>
	
	output reg <span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">]</span> data_out
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//a时钟域使能信号同步到b时钟域,作为MUX的sel</span>
reg a_en_r<span class="token punctuation">;</span>
reg a_en_rr<span class="token punctuation">;</span>

always @<span class="token punctuation">(</span>posedge clk_b or negedge rst_n<span class="token punctuation">)</span> begin
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>
		<span class="token punctuation">{<!-- --></span>a_en_rr<span class="token punctuation">,</span>a_en_r<span class="token punctuation">}</span> <span class="token operator">&lt;=</span> <span class="token punctuation">{<!-- --></span><span class="token number">2</span><span class="token punctuation">{<!-- --></span><span class="token number">1</span>'b0<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	<span class="token keyword">else</span> 
		<span class="token punctuation">{<!-- --></span>a_en_rr<span class="token punctuation">,</span>a_en_r<span class="token punctuation">}</span> <span class="token operator">&lt;=</span> <span class="token punctuation">{<!-- --></span>a_en_r<span class="token punctuation">,</span>a_en<span class="token punctuation">}</span><span class="token punctuation">;</span>
end


<span class="token comment">//二选一MUX</span>
always @<span class="token punctuation">(</span>posedge clk_b or negedge rst_n<span class="token punctuation">)</span> begin
	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>rst_n<span class="token punctuation">)</span>
		data_out <span class="token operator">&lt;=</span> 'b0<span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>a_en_rr <span class="token operator">==</span> <span class="token number">1</span>'b1<span class="token punctuation">)</span><span class="token comment">//如果使能信号有效</span>
		data_out <span class="token operator">&lt;=</span> data_in<span class="token punctuation">;</span>
	<span class="token keyword">else</span> <span class="token comment">//如果使能信号无效</span>
		data_out <span class="token operator">&lt;=</span> data_out<span class="token punctuation">;</span>
		
end

endmodule
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1eb5d45439785a5060e3ec6d68d9f124/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android Glide简单使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/dcabe4150519d4a945b5937186e3346f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Fork/Join 框架详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>