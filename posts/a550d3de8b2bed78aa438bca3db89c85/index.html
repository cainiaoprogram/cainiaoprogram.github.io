<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Vue开发者必备！手把手教你实现类似Element Plus的全局提示组件！ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Vue开发者必备！手把手教你实现类似Element Plus的全局提示组件！" />
<meta property="og:description" content="前言 在Web开发中，用户体验至关重要。有效的信息提示和错误消息对于确保用户更好地理解和操作至关重要。在这个背景下，全局弹框提示组件成为了一个非常有用的工具。Vue.js，作为当前最受欢迎的前端框架之一，为创建灵活、可复用的弹框组件提供了强大的支持。本文将介绍一个简单而强大的全局弹框提示组件，并探讨它是如何实现的。
组件示例 ​​
​
代码展示 Message.vue 首先，让我们看看这个全局弹框提示组件的Vue文件。
// Message.vue &lt;template&gt; &lt;div class=&#34;message&#34; v-if=&#34;visible&#34;&gt; &lt;img :src=&#34;imgSrc&#34; /&gt; &lt;span class=&#34;text&#34;&gt;{{ text }}&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;script setup lang=&#34;ts&#34;&gt; import { onMounted, PropType, ref } from &#39;vue&#39;; const props = defineProps({ text: { type: String, default: &#39;&#39;, }, type: { type: String as PropType&lt;&#39;warn&#39; | &#39;error&#39; | &#39;success&#39;&gt;, default: &#39;warn&#39;, }, }); const visible = ref(false); const imgSrc = ref(&#39;@/assets/img/warn.svg&#39;); onMounted(() =&gt; { switch (props." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a550d3de8b2bed78aa438bca3db89c85/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-02T14:36:36+08:00" />
<meta property="article:modified_time" content="2024-01-02T14:36:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Vue开发者必备！手把手教你实现类似Element Plus的全局提示组件！</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>前言</h2> 
<blockquote> 
 <p>在Web开发中，用户体验至关重要。有效的信息提示和错误消息对于确保用户更好地理解和操作至关重要。在这个背景下，全局弹框提示组件成为了一个非常有用的工具。Vue.js，作为当前最受欢迎的前端框架之一，为创建灵活、可复用的弹框组件提供了强大的支持。本文将介绍一个简单而强大的全局弹框提示组件，并探讨它是如何实现的。</p> 
</blockquote> 
<h2><a id="_4"></a>组件示例</h2> 
<p>​​<img src="https://images2.imgbox.com/62/55/wohsnQl9_o.png" alt="在这里插入图片描述"><br> ​<img src="https://images2.imgbox.com/5a/e4/9xgGzcRR_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b9/d2/gnRgvMJG_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_11"></a>代码展示</h2> 
<h3><a id="Messagevue_13"></a>Message.vue</h3> 
<p>首先，让我们看看这个全局弹框提示组件的Vue文件。</p> 
<pre><code>// Message.vue
&lt;template&gt;
  &lt;div class="message" v-if="visible"&gt;
    &lt;img :src="imgSrc" /&gt;
    &lt;span class="text"&gt;{<!-- -->{ text }}&lt;/span&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script setup lang="ts"&gt;
  import { onMounted, PropType, ref } from 'vue';
  const props = defineProps({
    text: {
      type: String,
      default: '',
    },
    type: {
      type: String as PropType&lt;'warn' | 'error' | 'success'&gt;,
      default: 'warn',
    },
  });
  const visible = ref(false);
  const imgSrc = ref('@/assets/img/warn.svg');
  onMounted(() =&gt; {
    switch (props.type) {
      case 'warn':
        imgSrc.value = require('@/assets/img/warn.svg');
        break;
      case 'error':
        imgSrc.value = require('@/assets/img/error.svg');
        break;
      case 'success':
        imgSrc.value = require('@/assets/img/success.svg');
        break;
      default:
        break;
    }
    console.log(imgSrc.value);
    visible.value = true;
  });
&lt;/script&gt;
&lt;style&gt;
  .message {
    position: fixed;
    z-index: 88888;
    top: 0;
    color: black;
    left: 50%;
    height: 40px;
    line-height: 40px;
    top: 80px;
    transform: translate(-50%);
    padding: 12px;
    background-color: white;
    border: 1px solid rgba(0, 0, 0, 0.1);
    display: flex;
    align-items: center;
    animation: downed 100ms ease;
    border-radius: 4px;
    box-sizing: border-box;
  }
  @keyframes downed {
    0% {
      top: 60px;
    }
    100% {
      top: 80px;
    }
  }
  .text {
    margin-left: 5px;
    max-width: 400px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
&lt;/style&gt;
</code></pre> 
<p>整个组件的作用是，根据传入的 text 和 type 显示一个带有图片和文本的弹框。其中 type 有三个可能的值：warn、error 和 success，分别表示警告、错误和成功。根据 type 的值，弹框的图片和文本也会有所不同。组件使用了 Vue.js 的响应式系统，使 visible、text 和 imgSrc 成为响应式引用，从而方便地与父组件共享数据。</p> 
<h3><a id="configts_95"></a>config.ts</h3> 
<p>有两种配置方式，根据个人爱好选择即可</p> 
<pre><code>第一种
// 实现使用函数调用message组件的逻辑
//   引入 创建虚拟节点 和渲染方法
import { createVNode, render } from 'vue';
// 引入信息提示组件
import message from './Message.vue';

// 准备dom容器
const div = document.createElement('div');
// 添加类名
div.setAttribute('class', 'message-container');
// 添加到body上
document.body.appendChild(div);

// 定时器标识
let timer = null;

export default ({ type, text }) =&gt; {
  const divs: any = document.getElementsByClassName('message');
  if (divs.length &gt; 0) {
    clearTimeout(timer);
    render(null, div);
  }
  // 创建虚拟节点   第一个参数为要创建的虚拟节点  第二个参数为props的参数
  const vNode = createVNode(message, { type, text });
  // 把虚拟节点渲染DOM容器中
  render(vNode, div);
  // 开启定时器，移出DOM容器内容
  clearTimeout(timer);
  timer = setTimeout(() =&gt; {
    render(null, div);
  }, 3000);
};


第二种
// 实现使用函数调用message组件的逻辑
//   引入 创建虚拟节点 和渲染方法
import { createVNode, render } from 'vue';
// 引入信息提示组件
import message from './Message.vue';

// 准备dom容器
const div = document.createElement('div');
// 添加类名
div.setAttribute('class', 'message-container');
// 添加到body上
document.body.appendChild(div);

// 定时器标识
let timer = null;

function sendInfo(type, text) {
  const divs: any = document.getElementsByClassName('message');
  if (divs.length &gt; 0) {
    clearTimeout(timer);
    render(null, div);
  }
  // 创建虚拟节点   第一个参数为要创建的虚拟节点  第二个参数为props的参数
  const vNode = createVNode(message, { type, text });
  // 把虚拟节点渲染DOM容器中
  render(vNode, div);
  // 开启定时器，移出DOM容器内容
  clearTimeout(timer);
  timer = setTimeout(() =&gt; {
    render(null, div);
  }, 3000);
}
export default {
  success(text) {
    sendInfo('success', text);
  },
  warn(text) {
    sendInfo('warn', text);
  },
  error(text) {
    sendInfo('error', text);
  },
};
</code></pre> 
<p>第一种方法，我们创建了一个函数message，该函数接受type和text两个参数。我们使用createVNode和render函数从创建一个Message组件的虚拟节点，并将其渲染到div元素中。我们还使用了一个定时器来在3秒后移除弹框。</p> 
<p>第二种最大的改变是省去了传入的type，用户调用时直接传入text即可。</p> 
<h2><a id="_183"></a>使用</h2> 
<p>最后，我们可以通过调用message函数来显示弹框。例如：</p> 
<pre><code>第一种
message({ type: 'error', text: '测试弹框fun' });

第二种
message.error('测试弹框fun')
</code></pre> 
<h2><a id="_193"></a>图片</h2> 
<p>error.svg</p> 
<pre><code>&lt;svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 20 20"&gt;&lt;path fill="red" d="M2.93 17.07A10 10 0 1 1 17.07 2.93A10 10 0 0 1 2.93 17.07zM11.4 10l2.83-2.83l-1.41-1.41L10 8.59L7.17 5.76L5.76 7.17L8.59 10l-2.83 2.83l1.41 1.41L10 11.41l2.83 2.83l1.41-1.41L11.41 10z"/&gt;&lt;/svg&gt;
</code></pre> 
<p>warn.svg</p> 
<pre><code>&lt;svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 20 20"&gt;&lt;path fill="#faad14" d="M2.93 17.07A10 10 0 1 1 17.07 2.93A10 10 0 0 1 2.93 17.07zM9 5v6h2V5H9zm0 8v2h2v-2H9z"/&gt;&lt;/svg&gt;
</code></pre> 
<p>success.svg</p> 
<pre><code>&lt;svg xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 48 48"&gt;&lt;path fill="#52c41a" fill-rule="evenodd" d="M24 44c11.046 0 20-8.954 20-20S35.046 4 24 4S4 12.954 4 24s8.954 20 20 20Zm10.742-26.33a1 1 0 1 0-1.483-1.34L21.28 29.567l-6.59-6.291a1 1 0 0 0-1.382 1.446l7.334 7l.743.71l.689-.762l12.667-14Z" clip-rule="evenodd"/&gt;&lt;/svg&gt;
</code></pre> 
<h2><a id="_207"></a>总结</h2> 
<p>虽然这个组件的实现原理很简单，但是它在用户体验和功能上却非常强大。它使用了Vue.js的响应式系统和动画效果，使得弹框在显示和隐藏时都能给用户带来良好的视觉体验。</p> 
<p>完整附件：<a href="https://pan.baidu.com/s/14G-bpVthImHD4eosZUNSFA?pwd=yu27" rel="nofollow">点此下载</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6140dfcbc5cf2a99b645897ca081f608/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">前缀和算法 -- [模版]二维前缀和</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eb02d0512006172fc19b72cf465e8b14/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大创项目推荐 深度学习人体语义分割在弹幕防遮挡上的实现 - python</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>