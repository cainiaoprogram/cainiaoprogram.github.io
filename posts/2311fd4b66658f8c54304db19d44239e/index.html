<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>拿offer必须掌握的最全SpringCloud面试题（含答案） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="拿offer必须掌握的最全SpringCloud面试题（含答案）" />
<meta property="og:description" content="今天公司的项目比较忙，远程开会和办公的沟通效率总是差那么一点，为了节约点时间，就不介绍SpringCloud了，我想只要是一名Java开发程序员，提到微服务，一定对SpringCloud的大名如雷贯耳，我们直接来看它的高频面试题吧。
1、什么是Spring Cloud？
Spring cloud 流应用程序启动器是基于 Spring Boot 的 Spring 集成应用程序，提供与外部系统的集成，更专注于服务治理。Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序。
2、Spring Cloud和Dubbo的区别
Dubbo关注的领域是Spring Cloud的一个子集。Dubbo专注于服务治理，其在服务治理、灰度发布、流量分发方面比Spring Cloud更全面。Spring Cloud覆盖整个微服务架构领域。
Dubbo使用RPC调用效率高一些，Spring Cloud使用HTTP调用效率低，使用更简单。
3、REST和RPC的区别
REST风格的系统交互更方便，RPC调用服务提供方和调用方式之间依赖太强。
REST调用系统性能较低，RPC调用效率比REST高。
REST的灵活性可以跨系统跨语言调用，RPC只能在同语言内调用。
REST可以和Swagger等工具整合，自动输出接口API文档。
4、SpringCloud如何实现服务的注册和发现
服务在发布时 指定对应的服务名（服务名包括了IP地址和端口） 将服务注册到注册中心（eureka或者zookeeper）。
这一过程是springcloud自动实现 只需要在main方法添加@EnableDisscoveryClient 同一个服务修改端口就可以启动多个实例。
调用方法：传递服务名称通过注册中心获取所有的可用实例 通过负载均衡策略调用（ribbon和feign）对应的服务。
5、什么是服务熔断和服务降级？
熔断机制是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现，Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内调用20次，如果失败，就会启动熔断机制。
服务降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。这样做，虽然会出现局部的错误，但可以避免因为一个服务挂机，而影响到整个架构的稳定性。
Hystrix相关注解：
@EnableHystrix：开启熔断
@HystrixCommand(fallbackMethod=”XXX”)：声明一个失败回滚处理函数XXX，当被注解的方法执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。
6、什么是Hystrix？它如何实现容错？
Hystrix是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。
通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协作。 思考以下微服务
假设如果上图中的微服务9失败了，那么使用传统方法我们将传播一个异常。但这仍然会导致整个系统崩溃。 随着微服务数量的增加，这个问题变得更加复杂。微服务的数量可以高达1000.这是hystrix出现的地方 我们将使用Hystrix在这种情况下的Fallback方法功能。我们有两个服务employee-consumer使用由employee-consumer公开的服务。 简化图如下所示
现在假设由于某种原因，employee-producer公开的服务会抛出异常。我们在这种情况下使用Hystrix定义了一个回退方法。这种后备方法应该具有与公开服务相同的返回类型。如果暴露服务中出现异常，则回退方法将返回一些值。
7、什么是Hystrix断路器？我们需要它吗？
由于某些原因，employee-consumer公开服务会引发异常。在这种情况下使用Hystrix我们定义了一个回退方法。如果在公开服务中发生异常，则回退方法返回一些默认值。
如果firstPage method() 中的异常继续发生，则Hystrix电路将中断，并且员工使用者将一起跳过firtsPage方法，并直接调用回退方法。断路器的目的是给第一页方法或第一页方法可能调用的其他方法留出时间，并导致异常恢复。可能发生的情况是，在负载较小的情况下，导致异常的问题有更好的恢复机会 。
8、项目中zuul常用的功能 提供动态路由 提供安全、鉴权处理 跨域处理 全局动态路由的hystrix(熔断、降级、限流)处理 9、服务网关的作用
简化客户端调用复杂度，统一处理外部请求。
数据裁剪以及聚合，根据不同的接口需求，对数据加工后对外。
多渠道支持，针对不同的客户端提供不同的网关支持。
遗留系统的微服务化改造，可以作为新老系统的中转组件。
统一处理调用过程中的安全、权限问题。
Spring Cloud中的网关有：Zuul和Spring Cloud Gateway，最新版本中推荐使用后者。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2311fd4b66658f8c54304db19d44239e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-21T21:50:43+08:00" />
<meta property="article:modified_time" content="2020-04-21T21:50:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">拿offer必须掌握的最全SpringCloud面试题（含答案）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>今天公司的项目比较忙，远程开会和办公的沟通效率总是差那么一点，为了节约点时间，就不介绍SpringCloud了，我想只要是一名Java开发程序员，提到微服务，一定对SpringCloud的大名如雷贯耳，我们直接来看它的高频面试题吧。</p> 
<p> </p> 
<p> </p> 
<p><strong>1、什么是Spring Cloud？</strong></p> 
<p>Spring cloud 流应用程序启动器是基于 Spring Boot 的 Spring 集成应用程序，提供与外部系统的集成，更专注于服务治理。Spring cloud Task，一个生命周期短暂的微服务框架，用于快速构建执行有限数据处理的应用程序。</p> 
<p> </p> 
<p><strong>2、Spring Cloud和Dubbo的区别</strong></p> 
<ul><li> <p>Dubbo关注的领域是Spring Cloud的一个子集。Dubbo专注于服务治理，其在服务治理、灰度发布、流量分发方面比Spring Cloud更全面。Spring Cloud覆盖整个微服务架构领域。</p> </li><li> <p>Dubbo使用RPC调用效率高一些，Spring Cloud使用HTTP调用效率低，使用更简单。</p> </li></ul> 
<p> </p> 
<p><strong>3、REST和RPC的区别</strong></p> 
<ul><li> <p>REST风格的系统交互更方便，RPC调用服务提供方和调用方式之间依赖太强。</p> </li><li> <p>REST调用系统性能较低，RPC调用效率比REST高。</p> </li><li> <p>REST的灵活性可以跨系统跨语言调用，RPC只能在同语言内调用。</p> </li><li> <p>REST可以和Swagger等工具整合，自动输出接口API文档。</p> </li></ul> 
<p> </p> 
<p><strong>4、SpringCloud如何实现服务的注册和发现</strong></p> 
<ol><li> <p>服务在发布时 指定对应的服务名（服务名包括了IP地址和端口） 将服务注册到注册中心（eureka或者zookeeper）。</p> </li><li> <p>这一过程是springcloud自动实现 只需要在main方法添加@EnableDisscoveryClient  同一个服务修改端口就可以启动多个实例。</p> </li><li> <p>调用方法：传递服务名称通过注册中心获取所有的可用实例 通过负载均衡策略调用（ribbon和feign）对应的服务。</p> </li></ol> 
<p> </p> 
<p><strong>5、什么是服务熔断和服务降级？</strong></p> 
<ul><li> <p>熔断机制是应对雪崩效应的一种微服务链路保护机制。当某个微服务不可用或者响应时间太长时，会进行服务降级，进而熔断该节点微服务的调用，快速返回“错误”的响应信息。当检测到该节点微服务调用响应正常后恢复调用链路。<strong>在SpringCloud框架里熔断机制通过Hystrix实现，</strong>Hystrix会监控微服务间调用的状况，当失败的调用到一定阈值，缺省是5秒内调用20次，如果失败，就会启动熔断机制。</p> </li><li> <p>服务降级，一般是从整体负荷考虑。就是当某个服务熔断之后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值。这样做，虽然会出现局部的错误，但可以避免因为一个服务挂机，而影响到整个架构的稳定性。</p> </li></ul> 
<p><strong>Hystrix相关注解：</strong></p> 
<ul><li> <p>@EnableHystrix：开启熔断</p> </li><li> <p>@HystrixCommand(fallbackMethod=”XXX”)：声明一个失败回滚处理函数XXX，当被注解的方法执行超时（默认是1000毫秒），就会执行fallback函数，返回错误提示。</p> </li></ul> 
<p> </p> 
<p><strong>6、什么是Hystrix？</strong><strong>它如何实现容错？</strong></p> 
<p>        Hystrix是一个延迟和容错库，旨在隔离远程系统，服务和第三方库的访问点，当出现故障是不可避免的故障时，停止级联故障并在复杂的分布式系统中实现弹性。</p> 
<p>通常对于使用微服务架构开发的系统，涉及到许多微服务。这些微服务彼此协作。 </p> 
<p>思考以下微服务</p> 
<p><img alt="" src="https://images2.imgbox.com/9e/ff/iiDEVK5W_o.png"></p> 
<p>假设如果上图中的微服务9失败了，那么使用传统方法我们将传播一个异常。但这仍然会导致整个系统崩溃。 </p> 
<p>随着微服务数量的增加，这个问题变得更加复杂。微服务的数量可以高达1000.这是hystrix出现的地方 我们将使用Hystrix在这种情况下的Fallback方法功能。我们有两个服务employee-consumer使用由employee-consumer公开的服务。 </p> 
<p>简化图如下所示</p> 
<p><img alt="" src="https://images2.imgbox.com/cd/61/YjDTlrWB_o.png"></p> 
<p>现在假设由于某种原因，employee-producer公开的服务会抛出异常。我们在这种情况下使用Hystrix定义了一个回退方法。这种后备方法应该具有与公开服务相同的返回类型。如果暴露服务中出现异常，则回退方法将返回一些值。</p> 
<p><strong>7、什么是Hystrix断路器？</strong><strong>我们需要它吗？</strong></p> 
<p>由于某些原因，employee-consumer公开服务会引发异常。在这种情况下使用Hystrix我们定义了一个回退方法。如果在公开服务中发生异常，则回退方法返回一些默认值。</p> 
<p><img alt="" src="https://images2.imgbox.com/66/7e/BMPvUm2n_o.png"></p> 
<p>如果firstPage method() 中的异常继续发生，则Hystrix电路将中断，并且员工使用者将一起跳过firtsPage方法，并直接调用回退方法。断路器的目的是给第一页方法或第一页方法可能调用的其他方法留出时间，并导致异常恢复。可能发生的情况是，在负载较小的情况下，导致异常的问题有更好的恢复机会 。<img alt="" src="https://images2.imgbox.com/ec/ea/RP9wx1mH_o.png"></p> 
<h4><strong>8、项目中zuul常用的功能</strong></h4> 
<ul><li> <h4>提供动态路由</h4> </li><li> <h4>提供安全、鉴权处理</h4> </li><li> <h4>跨域处理</h4> </li><li> <h4>全局动态路由的hystrix(熔断、降级、限流)处理</h4> </li></ul> 
<p> </p> 
<p><strong>9、服务网关的作用</strong></p> 
<ul><li> <p>简化客户端调用复杂度，统一处理外部请求。</p> </li><li> <p>数据裁剪以及聚合，根据不同的接口需求，对数据加工后对外。</p> </li><li> <p>多渠道支持，针对不同的客户端提供不同的网关支持。</p> </li><li> <p>遗留系统的微服务化改造，可以作为新老系统的中转组件。</p> </li><li> <p>统一处理调用过程中的安全、权限问题。</p> </li></ul> 
<p><strong>Spring Cloud中的网关有：Zuul和Spring Cloud Gateway</strong>，最新版本中推荐使用后者。</p> 
<p> </p> 
<p><strong>10、ribbon和feign区别</strong></p> 
<ul><li> <p>Ribbon添加maven依赖 spring-starter-ribbon 使用@RibbonClient(value="服务名称") 使用RestTemplate调用远程服务对应的方法。</p> </li><li> <p>feign添加maven依赖 spring-starter-feign 服务提供方提供对外接口 调用方使用 在接口上使用@FeignClient("指定服务名")</p> </li></ul> 
<p>Ribbon和Feign的区别：</p> 
<p>Ribbon和Feign都是用于调用其他服务的，不过方式不同。</p> 
<ol><li> <p>启动类使用的注解不同，Ribbon用的是@RibbonClient，Feign用的@EnableFeignClients。</p> </li><li> <p>服务的指定位置不同，Ribbon是在@RibbonClient注解上声明，Feign则是在定义抽象方法的接口中使用@FeignClient声明。</p> </li><li> <p>调用方式不同，Ribbon需要自己构建http请求，模拟http请求然后使用RestTemplate发送给其他服务，步骤相当繁琐。</p> </li></ol> 
<p>        Feign则是在Ribbon的基础上进行了一次改进，采用接口的方式，将需要调用的其他服务的方法定义成抽象方法即可，</p> 
<p>        不需要自己构建http请求。不过要注意的是抽象方法的注解、方法签名要和提供服务的方法完全一致。</p> 
<p> </p> 
<h4><strong>11、ribbon的负载均衡策略</strong></h4> 
<ol><li> <h4>RoundRobinRule: 轮询策略，Ribbon以轮询的方式选择服务器，这个是默认值。所以示例中所启动的两个服务会被循环访问;</h4> </li><li> <h4>RandomRule: 随机策略，也就是说Ribbon会随机从服务器列表中选择一个进行访问;</h4> </li><li> <h4>BestAvailableRule: 最大可用策略，即先过滤出故障服务器后，选择一个当前并发请求数最小的;</h4> </li><li> <h4>WeightedResponseTimeRule: 带有加权的轮询策略，对各个服务器响应时间进行加权处理，然后在采用轮询的方式来获取相应的服务器;</h4> </li><li> <h4>AvailabilityFilteringRule: 可用过滤策略，先过滤出故障的或并发请求大于阈值的一部分服务实例，然后再以线性轮询的方式从过滤后的实例清单中选出一个;</h4> </li><li> <h4>ZoneAvoidanceRule: 区域感知策略，先使用主过滤条件（区域负载器，选择最优区域）对所有实例过滤并返回过滤后的实例清单，依次使用次过滤条件列表中的过滤条件对主过滤条件的结果进行过滤，判断最小过滤数（默认1）和最小过滤百分比（默认0），最后对满足条件的服务器则使用RoundRobinRule(轮询方式)选择一个服务器实例。</h4> </li></ol> 
<p> </p> 
<p><strong>12、简述什么是CAP,并说明Eureka包含CAP中的哪些?</strong></p> 
<p><strong>CAP理论：</strong>一个分布式系统不可能同时满足C (一致性),A(可用性),P(分区容错性).由于分区容错性P在分布式系统中是必须要保证的,因此我们只能从A和C中进行权衡.</p> 
<p><strong>Eureka 遵守 AP</strong></p> 
<ul><li> <p>Eureka各个节点都是平等的,几个节点挂掉不会影响正常节点的工作,神域的节点依然可以提供注册和查询服务。</p> </li><li> <p>而Eureka的客户端在向某个Eureka 注册或查询是如果发现连接失败,则会自动切换至其他节点，只要有一台Eureka还在,就能保证注册服务可用(保证可用性),只不过查的信息可能不最新的不保证强一致性)。</p> </li></ul> 
<p> </p> 
<p><strong>13、Eureka和zookeeper都可以提供服务注册与发现的功能，请说说两个的区别？</strong> </p> 
<ul><li> <p><strong>Zookeeper保证了CP（C：</strong><strong>一致性，P：</strong><strong>分区容错性）</strong></p> </li><li> <p><strong>Eureka保证了AP（A：高可用）</strong> </p> </li></ul> 
<ol><li> <p>当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的信息，但不能容忍直接down掉不可用。也就是说，服务注册功能对高可用性要求比较高，但zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新选leader。问题在于，选取leader时间过长，30 ~ 120s，且选取期间zk集群都不可用，这样就会导致选取期间注册服务瘫痪。在云部署的环境下，因网络问题使得zk集群失去master节点是较大概率会发生的事，虽然服务能够恢复，但是漫长的选取时间导致的注册长期不可用是不能容忍的。</p> </li><li> <p>Eureka保证了可用性，Eureka各个节点是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点仍然可以提供注册和查询服务。而Eureka的客户端向某个Eureka注册或发现时发生连接失败，则会自动切换到其他节点，只要有一台Eureka还在，就能保证注册服务可用，只是查到的信息可能不是最新的。除此之外，Eureka还有自我保护机制，如果在15分钟内超过85%的节点没有正常的心跳，那么Eureka就认为客户端与注册中心发生了网络故障，此时会出现以下几种情况： </p> </li></ol> 
<ul><li> <p>Eureka不在从注册列表中移除因为长时间没有收到心跳而应该过期的服务。 </p> </li><li> <p>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上（即保证当前节点仍然可用）。</p> </li><li> <p>当网络稳定时，当前实例新的注册信息会被同步到其他节点。 </p> </li></ul> 
<p>因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像Zookeeper那样使整个微服务瘫痪。</p> 
<p> </p> 
<p><strong>14、什么是 Spring Cloud Bus?我们需要它吗?</strong></p> 
<p><strong>Spring Cloud Bus通过轻量消息代理连接各个分布的节点。</strong><strong>这会用在广播状态的变化（例如配置变化）或者其他的消息指令。Spring Cloud Bus的一个核心思想是通过分布式的启动器对Spring Boot应用进行扩展，也可以用来建立一个多个应用之间的通信频道。</strong></p> 
<p>考虑以下情况:我们有多个应用程序使用 Spring Cloud Config 读取属性，而 Spring Cloud Config 从GIT 读取这些属性。</p> 
<p>下面的例子中多个员工生产者模块从 Employee Config Module 获取 Eureka 注册的财产。</p> 
<p> </p> 
<p> </p> 
<p><img alt="" src="https://images2.imgbox.com/6e/f9/yyLe6GQN_o.png"></p> 
<p>如果假设 GIT 中的 Eureka 注册属性更改为指向另一台 Eureka 服务器，会发生什么情况。在这种情况 下，我们将不得不重新启动服务以获取更新的属性。</p> 
<p>还有另一种使用执行器端点/刷新的方式。但是我们将不得不为每个模块单独调用这个 url。例如，如果Employee Producer1 部署在端口 8080 上，则调用 http:// localhost:8080 / refresh。同样对于Employee Producer2 http:// localhost:8081 / refresh 等等。这又很麻烦。这就是 Spring Cloud Bus 发挥作用的地方。</p> 
<p> </p> 
<p> </p> 
<p><strong>15、链路跟踪Sleuth</strong></p> 
<p>当我们项目中引入Spring Cloud Sleuth后，每次链路请求都会添加一串追踪信息，格式是[server-name, main-traceId,sub-spanId,boolean]：</p> 
<ul><li> <p>server-name：服务结点名称。</p> </li><li> <p>main-traceId：一条链路唯一的ID，为TraceID。</p> </li><li> <p>sub-spanId：链路中每一环的ID，为SpanID。</p> </li><li> <p>boolean：是否将信息输出到Zipkin等服务收集和展示。</p> </li></ul> 
<p>Sleuth的实现是基于HTTP的，为了在数据的收集过程中不能影响到正常业务，Sleuth会在每个请求的Header上添加跟踪需求的重要信息。这样在数据收集时，只需要将Header上的相关信息发送给对应的图像工具即可，图像工具根据上传的数据，按照Span对应的逻辑进行分析、展示。</p> 
<blockquote> 
 <p>参考文章：https://my.oschina.net/langwanghuangshifu/blog/3005195</p> 
 <p>参考文章：https://blog.csdn.net/weixin_30342639/article/details/99436321</p> 
</blockquote> 
<hr> 
<p> </p> 
<p>好了，SpringCloud的面试题就到这儿结束，但是要精通SpringCloud，任重而道远，需要乡亲们自己不断的去学习和总结经验。</p> 
<p> </p> 
<p>更多面试题见我的个人公众号【码之初】，真心的希望能给你的面试之路助一臂之力。加油！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bf4313a1fd8550cd2c46ad0c3bdffdce/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vant的Uploader 上传问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3305a5f5a26b9bcba7de99994540aca5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vue-cli3.0(@vue/cli)设置网站标题时找不到index.html问题解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>