<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>golang 对字符串进行base64编解码、md5 编码 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="golang 对字符串进行base64编解码、md5 编码" />
<meta property="og:description" content="内容来自对 chagpt 的咨询
一、对字符串进行 base64 编解码 base64 编码 要在Go语言中对字符串进行base64编码，你可以使用标准库中的encoding/base64包。以下是一个简单的示例：
package main import ( &#34;encoding/base64&#34; &#34;fmt&#34; ) func main() { data := &#34;Hello, World!&#34; encoded := base64.StdEncoding.EncodeToString([]byte(data)) fmt.Println(&#34;Encoded:&#34;, encoded) } 在Base64编码中，所有的字母数字都是安全的(&#39;A&#39;到&#39;Z&#39;，&#39;a&#39;到&#39;z&#39;和&#39;0&#39;到&#39;9&#39;)。但是，Base64有两个额外的字符：&#39;&#43;&#39;和&#39;/&#39;，它们在某些系统(例如URL)中可能并不安全。
因此，Base64提供了一个&#34;URL和文件名安全&#34;的变体Base64url(也称为URL安全的Base64)，它使用&#34;-&#34;和&#34;_&#34;替换&#34;&#43;&#34;和&#34;/&#34;，消除了需要URL编码的需要。
这主要是在URL，Cookie，文件名等场景中使用Base64编码的时候需要考虑的问题，因为&#34;&#43;&#34;，&#34;/&#34;和&#34;=&#34;在这些环境中可能有特殊含义(例如URL中的路径分隔，查询字符串开始等)。
在Go语言中，可以使用base64.URLEncoding代替base64.StdEncoding达到URL安全的Base64编码，例如：
encodedURLSafe := base64.URLEncoding.EncodeToString([]byte(data)) 或者先用 base64.StdEncoding 编码后，手动将 &#34;&#43;&#34;，&#34;/&#34; 替换成 &#34;-&#34;和&#34;_&#34;
data := &#34;Hello, World!&#34; encoded := base64.StdEncoding.EncodeToString([]byte(data)) fmt.Println(&#34;Encoded:&#34;, encoded) encoded = strings.ReplaceAll(encoded, &#34;/&#34;, &#34;_&#34;) encoded = strings.ReplaceAll(encoded, &#34;&#43;&#34;, &#34;-&#34;) fmt.Println(&#34;Encoded:&#34;, encoded) base64 解码 如果使用 base64.StdEncoding.EncodeToString 进行编码，那么使用 base64.StdEncoding. DecodeString 进行解码；同理，如果使用 base64." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d064438b494aa7e05f11185fee44ed7d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-24T17:04:00+08:00" />
<meta property="article:modified_time" content="2023-09-24T17:04:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">golang 对字符串进行base64编解码、md5 编码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body cnblogs-markdown" style="font-size: 16px;"> 
 <blockquote> 
  <p>内容来自对 chagpt 的咨询</p> 
 </blockquote> 
 <h3 id="一对字符串进行-base64-编解码">一、对字符串进行 base64 编解码</h3> 
 <h4 id="base64-编码">base64 编码</h4> 
 <p>要在Go语言中对字符串进行base64编码，你可以使用标准库中的encoding/base64包。以下是一个简单的示例：</p> 
 <pre class="has"><code class="language-golang">package main

import (
	"encoding/base64"
	"fmt"
)

func main() {
	data := "Hello, World!"
	encoded := base64.StdEncoding.EncodeToString([]byte(data))
	fmt.Println("Encoded:", encoded)
}</code></pre> 
 <p>在Base64编码中，所有的字母数字都是安全的('A'到'Z'，'a'到'z'和'0'到'9')。但是，Base64有两个额外的字符：'+'和'/'，它们在某些系统(例如URL)中可能并不安全。</p> 
 <p>因此，Base64提供了一个"URL和文件名安全"的变体Base64url(也称为URL安全的Base64)，它使用"-"和"_"替换"+"和"/"，消除了需要URL编码的需要。</p> 
 <p>这主要是在URL，Cookie，文件名等场景中使用Base64编码的时候需要考虑的问题，因为"+"，"/"和"="在这些环境中可能有特殊含义(例如URL中的路径分隔，查询字符串开始等)。</p> 
 <p>在Go语言中，可以使用base64.URLEncoding代替base64.StdEncoding达到URL安全的Base64编码，例如：</p> 
 <pre class="has"><code class="language-golang">encodedURLSafe := base64.URLEncoding.EncodeToString([]byte(data))</code></pre> 
 <p>或者先用 base64.StdEncoding 编码后，手动将 "+"，"/" 替换成 "-"和"_"</p> 
 <pre class="has"><code class="language-golang">data := "Hello, World!"
	encoded := base64.StdEncoding.EncodeToString([]byte(data))
	fmt.Println("Encoded:", encoded)
	encoded = strings.ReplaceAll(encoded, "/", "_")
	encoded = strings.ReplaceAll(encoded, "+", "-")
    fmt.Println("Encoded:", encoded)</code></pre> 
 <h4 id="base64-解码">base64 解码</h4> 
 <p>如果使用 <code>base64.StdEncoding.EncodeToString</code> 进行编码，那么使用 <code>base64.StdEncoding. DecodeString</code> 进行解码；同理，如果使用 <code>base64.URLEncoding.EncodeToString</code> 进行编码，那么使用 <code>base64.URLEncoding. DecodeString</code> 进行解码；</p> 
 <pre class="has"><code class="language-golang">package main

import (
	"encoding/base64"
	"fmt"
)

func main() {
    // 需要进行编码的字符串
	data := "hello world"

	// 使用 base64.URLEncoding 对字符串进行 base64 编码
	encoded := base64.URLEncoding.EncodeToString([]byte(data))

	fmt.Println("Original String: ", data)
	fmt.Println("Base64 Encoded String: ", encoded)

	// 使用 base64.URLEncoding 进行解码
	decodedByte, err := base64.URLEncoding.DecodeString(encoded)
	if err != nil {
		log.Fatal("Decode Error:", err)
	}
	
	// 将字节切片转换为字符串
	decoded := string(decodedByte)
	fmt.Println("Base64 Decoded String: ", decoded)
}</code></pre> 
 <h3 id="二md5-编码">二、md5 编码</h3> 
 <p>在 Go 语言中，我们可以使用 crypto/md5 库来对字符串或其他数据进行 MD5 编码。以下是一个示例代码段：</p> 
 <pre class="has"><code class="language-golang">package main

import (
	"crypto/md5"
	"fmt"
	"io"
)

func main() {
	data := "Hello, World"
	hash := md5.New()
	io.WriteString(hash, data)

	md5Code := fmt.Sprintf("%x", hash.Sum(nil))
	fmt.Println(md5Code)
}</code></pre> 
 <p>在上面的代码中，我们首先导入了 crypto/md5 和 fmt 库。我们创建了一个新的 MD5 hash，并将要进行编码的数据(在这种情况下是字符串 "Hello, World")写入 hash 中。然后我们使用 Sum 函数得到编码后的数据，并将其转化为十六进制的字符串形式打印出来。</p> 
 <h4 id="另一种简单形式">另一种简单形式</h4> 
 <pre class="has"><code class="language-golang">package main

import (
	"crypto/md5"
	"fmt"
	"io"
)

func main() {
	data := "Hello, World"
    fmt.Sprintf("%x", md5.Sum([]byte(data)))
}</code></pre> 
 <h4 id="使用md5编码后有可能重复吗">使用md5编码后有可能重复吗</h4> 
 <p>在入内容没有任何改变，每次生成的MD5值都是一样的。但是如果输入内容发生变化，那么发生编码后发生碰撞的概率非常低，但是有可能存在。</p> 
 <p>MD5编码算法生成的结果是固定的32位十六进制数。理论上，有大约340万亿亿亿亿的可能结果(16的32次方)。</p> 
 <p>然而，由于这个结果空间是有限的，而可能的输入是无限的，所以理论上讲，可能会存在两个不同的输入有相同的MD5编码。这被称为"碰撞"。</p> 
 <p>实际上，已经存在一些已知的MD5碰撞示例。<strong>(这些找到 MD5 碰撞的示例并非自然产生，而是通过密集计算和某些已知的 MD5 弱点才找出来的。)</strong>因此，虽然MD5通常适用于检查数据完整性(例如，验证文件下载是否成功)，但已经不推荐用于需要高安全性的环境，如SSL证书和密码存储等。</p> 
 <p>如果你需要一个更安全的哈希算法，你或许应该使用SHA-256或SHA-3。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/781007f669cf87a636a7a5b34c239707/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Java毕设项目】基于SpringBoot&#43;Vue教务管理系统的开发与实现</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a6f9cc09fcbf86b9ecf6b3ce91ea42c1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">fabric合约部署问题小记</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>