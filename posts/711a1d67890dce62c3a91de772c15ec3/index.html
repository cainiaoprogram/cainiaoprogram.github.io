<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux（Shell命令脚本） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux（Shell命令脚本）" />
<meta property="og:description" content="1、编写Shell脚本 可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。
交互式（Interactive）：用户每输入一条命令就立即执行。
批处理（Batch）：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。
在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。
通过查看SHELL变量可以发现，当前系统已经默认使用Bash作为命令行终端解释器了：
[root@localhost ~]# echo $SHELL /bin/bash 1、编写简单的脚本 估计读者在看完上文中有关Shell脚本的复杂描述后，会累觉不爱吧。但是，上文指的是一个高级Shell脚本的编写原则，其实使用Vim编辑器把Linux命令按照顺序依次写入到一个文件中，就是一个简单的脚本了。
例如，如果想查看当前所在工作路径并列出当前目录下所有的文件及属性信息，实现这个功能的脚本应该类似于下面这样：
[root@localhost ~]# vim example.sh #!/bin/bash # 这是一句注释 pwd ls -al Shell脚本文件的名称可以任意，但为了避免被误以为是普通文件，建议将.sh后缀加上，以表示是一个脚本文件。
在上面的这个example.sh脚本中实际上出现了3种不同的元素：第一行的脚本声明（#!）用来告诉系统使用哪种Shell解释器来执行该脚本；第二行的注释信息（#）是对脚本功能和某些命令的介绍信息，使得自己或他人在日后看到这个脚本内容时，可以快速知道该脚本的作用或一些警告信息；第三、四行的可执行语句也就是我们平时执行的Linux命令了。你们不相信这么简单就编写出来了一个脚本程序？！那我们来执行一下看看结果：
[root@localhost ~]# bash example.sh /root total 60 dr-xr-x---. 15 root root 4096 Oct 12 00:41 . dr-xr-xr-x. 17 root root 224 Jul 21 05:04 .. -rw-------. 1 root root 1407 Jul 21 05:09 anaconda-ks.cfg -rw-------. 1 root root 335 Jul 24 06:33 .bash_history -rw-r--r--." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/711a1d67890dce62c3a91de772c15ec3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-01T10:18:34+08:00" />
<meta property="article:modified_time" content="2023-12-01T10:18:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux（Shell命令脚本）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>1、编写Shell脚本</h3> 
<p>可以将Shell终端解释器当作人与计算机硬件之间的“翻译官”，它作为用户与Linux系统内部的通信媒介，除了能够支持各种变量与参数外，还提供了诸如循环、分支等高级编程语言才有的控制结构特性。要想正确使用Shell中的这些功能特性，准确下达命令尤为重要。Shell脚本命令的工作方式有下面两种。</p> 
<blockquote> 
 <p><strong>交互式（Interactive）</strong>：用户每输入一条命令就立即执行。</p> 
 <p><strong>批处理（Batch）</strong>：由用户事先编写好一个完整的Shell脚本，Shell会一次性执行脚本中诸多的命令。</p> 
</blockquote> 
<p>在Shell脚本中不仅会用到前面学习过的很多Linux命令以及正则表达式、管道符、数据流重定向等语法规则，还需要把内部功能模块化后通过逻辑语句进行处理，最终形成日常所见的Shell脚本。</p> 
<p>通过查看SHELL变量可以发现，当前系统已经默认使用Bash作为命令行终端解释器了：</p> 
<pre>[root@localhost ~]# echo $SHELL
/bin/bash</pre> 
<h4>1、编写简单的脚本</h4> 
<p>估计读者在看完上文中有关Shell脚本的复杂描述后，会累觉不爱吧。但是，上文指的是一个高级Shell脚本的编写原则，其实使用Vim编辑器把Linux命令按照顺序依次写入到一个文件中，就是一个简单的脚本了。</p> 
<p>例如，如果想查看当前所在工作路径并列出当前目录下所有的文件及属性信息，实现这个功能的脚本应该类似于下面这样：</p> 
<pre>[root@localhost ~]# vim example.sh
#!/bin/bash 
# 这是一句注释
pwd 
ls -al</pre> 
<p>Shell脚本文件的名称可以任意，但为了避免被误以为是普通文件，建议将.sh后缀加上，以表示是一个脚本文件。</p> 
<p>在上面的这个example.sh脚本中实际上出现了3种不同的元素：第一行的脚本声明（#!）用来告诉系统使用哪种Shell解释器来执行该脚本；第二行的注释信息（#）是对脚本功能和某些命令的介绍信息，使得自己或他人在日后看到这个脚本内容时，可以快速知道该脚本的作用或一些警告信息；第三、四行的可执行语句也就是我们平时执行的Linux命令了。你们不相信这么简单就编写出来了一个脚本程序？！那我们来执行一下看看结果：</p> 
<pre>[root@localhost ~]# bash example.sh
/root
total 60
dr-xr-x---. 15 root root  4096 Oct 12 00:41 .
dr-xr-xr-x. 17 root root   224 Jul 21 05:04 ..
-rw-------.  1 root root  1407 Jul 21 05:09 anaconda-ks.cfg
-rw-------.  1 root root   335 Jul 24 06:33 .bash_history
-rw-r--r--.  1 root root    18 Aug 13  2018 .bash_logout
-rw-r--r--.  1 root root   176 Aug 13  2018 .bash_profile
………………省略部分输出信息………………</pre> 
<p>除了上面用Bash解释器命令直接运行Shell脚本文件外，第二种运行脚本程序的方法是通过输入完整路径的方式来执行。但默认会因为权限不足而提示报错信息，此时只需要为脚本文件增加执行权限即可（详见第5章）。初次学习Linux系统的读者不用心急，等下一章学完用户身份和权限后再来做这个实验也不迟：</p> 
<pre>[root@localhost ~]# ./example.sh
bash: ./Example.sh: Permission denied
[root@localhost ~]# chmod u+x example.sh
[root@localhost ~]# ./example.sh
/root
total 60
dr-xr-x---. 15 root root  4096 Oct 12 00:41 .
dr-xr-xr-x. 17 root root   224 Jul 21 05:04 ..
-rw-------.  1 root root  1407 Jul 21 05:09 anaconda-ks.cfg
-rw-------.  1 root root   335 Jul 24 06:33 .bash_history
-rw-r--r--.  1 root root    18 Aug 13  2018 .bash_logout
-rw-r--r--.  1 root root   176 Aug 13  2018 .bash_profile
………………省略部分输出信息………………</pre> 
<h4>2、接收用户的参数</h4> 
<p>但是，像上面这样的脚本程序只能执行一些预先定义好的功能，未免太过死板。为了让Shell脚本程序更好地满足用户的一些实时需求，以便灵活完成工作，必须要让脚本程序能够像之前执行命令时那样，接收用户输入的参数。</p> 
<p>比如，当用户执行某一个命令时，加或不加参数的输出结果是不同的：</p> 
<pre>[root@localhost ~]# wc -l anaconda-ks.cfg 
44 anaconda-ks.cfg
[root@localhost ~]# wc -c anaconda-ks.cfg 
1407 anaconda-ks.cfg
[root@localhost ~]# wc -w anaconda-ks.cfg 
121 anaconda-ks.cfg</pre> 
<p>这意味着命令不仅要能接收用户输入的内容，还要有能力进行判断区别，根据不同的输入调用不同的功能。</p> 
<p>其实，Linux系统中的Shell脚本语言早就考虑到了这些，已经内设了用于接收参数的变量，变量之间使用空格间隔。例如，$0对应的是当前Shell脚本程序的名称，$#对应的是总共有几个参数，$<em>对应的是所有位置的参数值，$?对应的是显示上一次命令的执行返回值，而$1、$2、$3……则分别对应着第</em>N*个位置的参数值，如图所示。</p> 
<p><img alt="" height="385" src="https://images2.imgbox.com/36/16/KLMiNwyJ_o.png" width="1200"></p> 
<p></p> 
<p>理论过后再来练习一下。尝试编写一个脚本程序示例，通过引用上面的变量参数来看一下真实效果：</p> 
<pre>[root@localhost ~]# vim example.sh
#!/bin/bash
echo "当前脚本名称为$0"
echo "总共有$#个参数，分别是$*。"
echo "第1个参数为$1，第5个为$5。"
[root@localhost ~]# bash example.sh one two three four five six
当前脚本名称为example.sh
总共有6个参数，分别是one two three four five six。
第1个参数为one，第5个为five。</pre> 
<h4>3、判断用户的参数</h4> 
<p>学习是一个登堂入室、由浅入深的过程。在学习完Linux命令，掌握Shell脚本语法变量和接收用户输入的信息之后，就要踏上新的高度—能够进一步处理接收到的用户参数。</p> 
<p>本书在前面章节中讲到，系统在执行mkdir命令时会判断用户输入的信息，即判断用户指定的文件夹名称是否已经存在，如果存在则提示报错；反之则自动创建。Shell脚本中的条件测试语法可以判断表达式是否成立，若条件成立则返回数字0，否则便返回非零值。条件测试语法的执行格式如图4-16所示。切记，条件表达式两边均应有一个空格。</p> 
<p><img alt="" height="148" src="https://images2.imgbox.com/c6/ec/BVE4eL4K_o.png" width="867"></p> 
<p>按照测试对象来划分，条件测试语句可以分为4种：</p> 
<blockquote> 
 <p>文件测试语句；</p> 
 <p>逻辑测试语句；</p> 
 <p>整数值比较语句；</p> 
 <p>字符串比较语句。</p> 
</blockquote> 
<p>文件测试即使用指定条件来判断文件是否存在或权限是否满足等情况的运算符，具体的参数如表所示。</p> 
<table><thead><tr><th>操作符</th><th>作用</th></tr></thead><tbody><tr><td>-d</td><td>测试文件是否为目录类型</td></tr><tr><td>-e</td><td>测试文件或文件夹是否存在</td></tr><tr><td>-f</td><td>判断是否为一般文件</td></tr><tr><td>-r</td><td>测试当前用户是否有权限读取</td></tr><tr><td>-w</td><td>测试当前用户是否有权限写入</td></tr><tr><td>-x</td><td>测试当前用户是否有权限执行</td></tr></tbody></table> 
<p>下面使用文件测试语句来判断/etc/fstab是否为一个目录类型的文件，然后通过Shell解释器的内设$?变量显示上一条命令执行后的返回值。如果返回值为0，则目录存在；如果返回值为非零的值，则意味着它不是目录，或这个目录不存在：</p> 
<pre>[root@localhost ~]# [ -d /etc/fstab ]
[root@localhost ~]# echo $?
1</pre> 
<p>再使用文件测试语句来判断/etc/fstab是否为一般文件，如果返回值为0，则代表文件存在，且为一般文件：</p> 
<pre>[root@localhost ~]# [ -f /etc/fstab ]
[root@localhost ~]# echo $?
0</pre> 
<p>判断与查询一定要敲两次命令吗？其实可以一次搞定。</p> 
<p>逻辑语句用于对测试结果进行逻辑分析，根据测试结果可实现不同的效果。例如在Shell终端中逻辑“与”的运算符号是&amp;&amp;，它表示当前面的命令执行成功后才会执行它后面的命令，因此可以用来判断/dev/cdrom文件是否存在，若存在则输出Exist字样。</p> 
<pre>[root@localhost ~]# [ -e /dev/cdrom ] &amp;&amp; echo "Exist"
Exist</pre> 
<p>除了逻辑“与”外，还有逻辑“或”，它在Linux系统中的运算符号为||，表示当前面的命令执行失败后才会执行它后面的命令，因此可以用来结合系统环境变量USER来判断当前登录的用户是否为非管理员身份：</p> 
<pre>[root@localhost ~]# echo $USER
root
[root@localhost ~]# [ $USER = root ] || echo "user"
[root@localhost ~]# su - yaoge 
[yaoge@localhost ~]$ [ $USER = root ] || echo "user"
user</pre> 
<p>第三种逻辑语句是“非”，在Linux系统中的运算符号是一个叹号（！），它表示把条件测试中的判断结果取相反值。也就是说，如果原本测试的结果是正确的，则将其变成错误的；原本测试错误的结果，则将其变成正确的。</p> 
<p>我们现在切换回到root管理员身份，再判断当前用户是否为一个非管理员的用户。由于判断结果因为两次否定而变成正确，因此会正常地输出预设信息：</p> 
<pre>[yaoge@localhost ~]$ exit
logout
[root@localhost ~]# [ ! $USER = root ] || echo "administrator"
administrator</pre> 
<p>叹号应该放到判断语句的前面，代表对整个的测试语句进行取反值操作，而不应该写成“$USER != root”，因为“!=”代表的是不等于符号（≠），尽管执行效果一样，但缺少了逻辑关系，这一点还请多加注意。</p> 
<blockquote> 
 <p>&amp;&amp;是逻辑“与”，只有当前面的语句执行成功的时候才会执行后面的语句。 ||是逻辑“或”，只有当前面的语句执行失败的时候才会执行后面的语句。 !是逻辑“非”，代表对逻辑测试结果取反值；之前若为正确则变成错误，若为错误则变成正确。</p> 
</blockquote> 
<p>当前我们正在登录的即为管理员用户—root。下面这个示例的执行顺序是，先判断当前登录用户的USER变量名称是否等于root，然后用逻辑“非”运算符进行取反操作，效果就变成了判断当前登录的用户是否为非管理员用户。最后若条件成立，则会根据逻辑“与”运算符输出user字样；若条件不满足，则会通过逻辑“或”运算符输出root字样，而只有在前面的&amp;&amp;不成立时才会执行后面的||符号。</p> 
<pre>[root@localhost ~]# [ ! $USER = root ] &amp;&amp; echo "user" || echo "root"
root</pre> 
<p>整数比较运算符仅是对数字的操作，不能将数字与字符串、文件等内容一起操作，而且不能想当然地使用日常生活中的等号、大于号、小于号等来判断。因为等号与赋值命令符冲突，大于号和小于号分别与输出重定向命令符和输入重定向命令符冲突。因此一定要使用规范的整数比较运算符来进行操作。可用的整数比较运算符如表所示。</p> 
<table><thead><tr><th>操作符</th><th>作用</th></tr></thead><tbody><tr><td>-eq</td><td>是否等于</td></tr><tr><td>-ne</td><td>是否不等于</td></tr><tr><td>-gt</td><td>是否大于</td></tr><tr><td>-lt</td><td>是否小于</td></tr><tr><td>-le</td><td>是否等于或小于</td></tr><tr><td>-ge</td><td>是否大于或等于</td></tr></tbody></table> 
<p>接下来小试牛刀。先测试一下10是否大于10以及10是否等于10（通过输出的返回值内容来判断）：</p> 
<pre>[root@localhost ~]# [ 10 -gt 10 ]
[root@localhost ~]# echo $?
1
[root@localhost ~]# [ 10 -eq 10 ]
[root@localhost ~]# echo $?
0</pre> 
<p>曾经讲过free命令，它能够用来获取当前系统正在使用及可用的内存量信息。接下来先使用free -m命令查看内存使用量情况（单位为MB），然后通过“grep Mem:”命令过滤出剩余内存量的行，再用awk '{print $4}'命令只保留第4列。这个演示确实有些难度，但看懂后会觉得很有意思，没准在运维工作中也会用得上。</p> 
<pre>[root@localhost ~]# free -m
              total        used        free      shared  buff/cache   available
Mem:           1966        1374         128          16         463         397
Swap:          2047          66        1981
[root@localhost ~]# free -m | grep Mem:
Mem:           1966        1374         128          16         463         397
[root@localhost ~]# free -m | grep Mem: | awk '{print $4}'
128</pre> 
<p>如果想把这个命令写入到Shell脚本中，那么建议把输出结果赋值给一个变量，以方便其他命令进行调用：</p> 
<pre>[root@localhost ~]# FreeMem=`free -m | grep Mem: | awk '{print $4}'`
[root@localhost ~]# echo $FreeMem 
128</pre> 
<p>上面用于获取内存可用量的命令以及步骤可能有些“超纲”了，如果不能理解领会也不用担心，接下来才是重点。我们使用整数运算符来判断内存可用量的值是否小于1024，若小于则会提示“Insufficient Memory”（内存不足）的字样：</p> 
<pre>[root@localhost ~]# [ $FreeMem -lt 1024 ] &amp;&amp; echo "Insufficient Memory"
Insufficient Memory</pre> 
<p>字符串比较语句用于判断测试字符串是否为空值，或两个字符串是否相同。它经常用来判断某个变量是否未被定义（即内容为空值），理解起来也比较简单。字符串比较中常见的运算符如表所示。</p> 
<table><thead><tr><th>操作符</th><th>作用</th></tr></thead><tbody><tr><td>=</td><td>比较字符串内容是否相同</td></tr><tr><td>!=</td><td>比较字符串内容是否不同</td></tr><tr><td>-z</td><td>判断字符串内容是否为空</td></tr></tbody></table> 
<p>接下来通过判断String变量是否为空值，进而判断是否定义了这个变量：</p> 
<pre>[root@localhost ~]# [ -z $String ]
[root@localhost ~]# echo $?
0</pre> 
<p>再次尝试引入逻辑运算符来试一下。当用于保存当前语系的环境变量值LANG不是英语（en.US）时，则会满足逻辑测试条件并输出“Not en.US”（非英语）的字样：</p> 
<pre>[root@localhost ~]# echo $LANG
en_US.UTF-8
[root@localhost ~]# [ ! $LANG = "en.US" ] &amp;&amp; echo "Not en.US"
Not en.US</pre> 
<h3 style="background-color:transparent;">2、流程控制语句</h3> 
<p>尽管此时可以通过使用Linux命令、管道符、重定向以及条件测试语句来编写最基本的Shell脚本，但是这种脚本并不适用于生产环境。原因是它不能根据真实的工作需求来调整具体的执行命令，也不能根据某些条件实现自动循环执行。通俗来讲，就是不能根据实际情况做出调整。</p> 
<p>通常脚本都是从上到下一股脑儿地执行，效率是很高，但一旦某条命令执行失败了，则后面的功能全都会受到影响。假如大家有一天遇到了心仪的他（她），心中默默地进行如下规划。</p> 
<p><img alt="" height="615" src="https://images2.imgbox.com/44/37/GJmRzzgr_o.png" width="827"></p> 
<p></p> 
<p>结果可能是见面聊天后就觉得不合适了，后续的“要手机号码”“一起吃晚饭”和“一起看电影”就要终止了，就需要转而去做其他事情，因此需要判断语句来帮助完成。</p> 
<p>接下来我们通过if、for、while、case这4种流程控制语句来学习编写难度更大、功能更强的Shell脚本。为了保证下文的实用性和趣味性，做到寓教于乐，我会尽可能多地讲解各种不同功能的Shell脚本示例，而不是逮住一个脚本不放，在它原有内容的基础上修修补补。尽管这种修补式的示例教学也可以让读者明白理论知识，但是却无法开放思路，不利于日后的工作。</p> 
<h4>1、if 条件测试语句</h4> 
<p>if条件测试语句可以让脚本根据实际情况自动执行相应的命令。从技术角度来讲，if语句分为单分支结构、双分支结构、多分支结构；其复杂度随着灵活度一起逐级上升。</p> 
<p>if条件语句的单分支结构由if、then、fi关键词组成，而且只在条件成立后才执行预设的命令，相当于口语的“如果……那么……”。单分支的if语句属于最简单的一种条件判断结构，语法格式如图所示。</p> 
<p><img alt="" height="165" src="https://images2.imgbox.com/06/70/h3P2E4hz_o.png" width="751"></p> 
<p>下面使用单分支的if条件语句来判断/media/cdrom目录是否存在，若不存在就创建这个目录，反之则结束条件判断和整个Shell脚本的执行。</p> 
<pre>[root@localhost ~]# vim mkcdrom.sh
#!/bin/bash
DIR="/media/cdrom"
if [ ! -d $DIR ]
then    
        mkdir -p $DIR
fi </pre> 
<p>由于第5章才讲解用户身份与权限，因此这里继续用“bash脚本名称”的方式来执行脚本。在正常情况下，顺利执行完脚本文件后没有任何输出信息，但是可以使用ls命令验证/media/cdrom目录是否已经成功创建：</p> 
<pre>[root@localhost ~]# bash mkcdrom.sh
[root@localhost ~]# ls -ld /media/cdrom
drwxr-xr-x. 2 root root 6 Oct 13 21:34 /media/cdrom</pre> 
<hr> 
<p>if条件语句的双分支结构由if、then、else、fi关键词组成，它进行一次条件匹配判断，如果与条件匹配，则去执行相应的预设命令；反之则去执行不匹配时的预设命令，相当于口语的“如果……那么……或者……那么……”。if条件语句的双分支结构也是一种很简单的判断结构，语法格式如图所示。</p> 
<p><img alt="" height="196" src="https://images2.imgbox.com/bf/ba/G9dhRclG_o.png" width="770"></p> 
<p>下面使用双分支的if条件语句来验证某台主机是否在线，然后根据返回值的结果，要么显示主机在线信息，要么显示主机不在线信息。这里的脚本主要使用ping命令来测试与对方主机的网络连通性，而Linux系统中的ping命令不像Windows一样尝试4次就结束，因此为了避免用户等待时间过长，需要通过-c参数来规定尝试的次数，并使用-i参数定义每个数据包的发送间隔，以及使用-W参数定义等待超时时间。</p> 
<pre>[root@localhost ~]# vim chkhost.sh
#!/bin/bash
ping -c 3 -i 0.2 -W 3 $1 &amp;&gt; /dev/null
if [ $? -eq 0 ]
then
        echo "Host $1 is On-line."
else
        echo "Host $1 is Off-line."
fi</pre> 
<p>我们用过$?变量，作用是显示上一次命令的执行返回值。若前面的那条语句成功执行，则$?变量会显示数字0，反之则显示一个非零的数字（可能为1，也可能为2，取决于系统版本）。因此可以使用整数比较运算符来判断$?变量是否为0，从而获知那条语句的最终判断情况。这里的服务器IP地址为192.168.10.10，我们来验证一下脚本的效果：</p> 
<pre>[root@localhost ~]# bash chkhost.sh 192.168.10.10
Host 192.168.10.10 is On-line.
[root@localhost ~]# bash chkhost.sh 192.168.10.20
Host 192.168.10.20 is Off-line.</pre> 
<p>if条件语句的多分支结构由if、then、else、elif、fi关键词组成，它进行多次条件匹配判断，这多次判断中的任何一项在匹配成功后都会执行相应的预设命令，相当于口语的“如果……那么……如果……那么……”。if条件语句的多分支结构是工作中最常使用的一种条件判断结构，尽管相对复杂但是更加灵活，语法格式如图4-20所示。</p> 
<p>下面使用多分支的if条件语句来判断用户输入的分数在哪个成绩区间内，然后输出如Excellent、Pass、Fail等提示信息。在Linux系统中，read是用来读取用户输入信息的命令，能够把接收到的用户输入信息赋值给后面的指定变量，-p参数用于向用户显示一些提示信息。</p> 
<p><img alt="" height="331" src="https://images2.imgbox.com/2b/80/ktQnIHea_o.png" width="819"></p> 
<p>在下面的脚本示例中，只有当用户输入的分数大于等于85分且小于等于100分时，才输出Excellent字样；若分数不满足该条件（即匹配不成功），则继续判断分数是否大于等于70分且小于等于84分，如果是，则输出Pass字样；若两次都落空（即两次的匹配操作都失败了），则输出Fail字样：</p> 
<pre>[root@localhost ~]# vim chkscore.sh
#!/bin/bash
read -p "Enter your score（0-100）：" GRADE
if [ $GRADE -ge 85 ] &amp;&amp; [ $GRADE -le 100 ] ; then
        echo "$GRADE is Excellent"
elif [ $GRADE -ge 70 ] &amp;&amp; [ $GRADE -le 84 ] ; then
        echo "$GRADE is Pass"
else
        echo "$GRADE is Fail" 
fi
[root@localhost ~]# bash chkscore.sh
Enter your score（0-100）：88
88 is Excellent
[root@localhost ~]# bash chkscore.sh 
Enter your score（0-100）：80
80 is Pass</pre> 
<p>下面执行该脚本。当用户输入的分数分别为30和200时，其结果如下：</p> 
<pre>[root@localhost ~]# bash chkscore.sh  
Enter your score（0-100）：30
30 is Fail
[root@localhost ~]# bash chkscore.sh
Enter your score（0-100）：200 
200 is Fail</pre> 
<p>为什么输入的分数为200时，依然显示Fail呢？原因很简单—没有成功匹配脚本中的两个条件判断语句，因此自动执行了最终的兜底策略。可见，这个脚本还不是很完美，建议读者自行完善这个脚本，使得用户在输入大于100或小于0的分数时，给予Error报错字样的提示。</p> 
<h4>2、for 条件循环语句</h4> 
<p>for循环语句允许脚本一次性读取多个信息，然后逐一对信息进行操作处理。当要处理的数据有范围时，使用for循环语句就再适合不过了。for循环语句的语法格式如图所示。</p> 
<p><img alt="" height="175" src="https://images2.imgbox.com/4d/64/UjS2xxs3_o.png" width="754"></p> 
<p>下面使用for循环语句从列表文件中读取多个用户名，然后为其逐一创建用户账户并设置密码。首先创建用户名称的列表文件users.txt，每个用户名称单独一行。读者可以自行决定具体的用户名称和个数：</p> 
<pre>[root@localhost ~]# vim users.txt
andy
barry
carl
duke
eric
george</pre> 
<p>接下来编写Shell脚本addusers.sh。在脚本中使用read命令读取用户输入的密码值，然后赋值给PASSWD变量，并通过-p参数向用户显示一段提示信息，告诉用户正在输入的内容即将作为账户密码。在执行该脚本后，会自动使用从列表文件users.txt中获取到所有的用户名称，然后逐一使用“id用户名”命令查看用户的信息，并使用$?判断这条命令是否执行成功，也就是判断该用户是否已经存在。</p> 
<pre>[root@localhost ~]# vim addusers.sh
#!/bin/bash
read -p "Enter The Users Password : " PASSWD
for UNAME in `cat users.txt`
do
        id $UNAME &amp;&gt; /dev/null
        if [ $? -eq 0 ]
        then
                echo "$UNAME , Already exists"
        else
                useradd $UNAME
                echo "$PASSWD" | passwd --stdin $UNAME &amp;&gt; /dev/null
                echo "$UNAME , Create success"
        fi
done</pre> 
<blockquote> 
 <p>/dev/null是一个被称作Linux黑洞的文件，把输出信息重定向到这个文件等同于删除数据（类似于没有回收功能的垃圾箱），可以让用户的屏幕窗口保持简洁。</p> 
</blockquote> 
<p>执行批量创建用户的Shell脚本addusers.sh，在输入为账户设定的密码后将由脚本自动检查并创建这些账户。由于已经将多余的信息通过输出重定向符转移到了/dev/null黑洞文件中，因此在正常情况下屏幕窗口除了“用户账户创建成功”（Create success）的提示后不会有其他内容。</p> 
<p>在Linux系统中，/etc/passwd是用来保存用户账户信息的文件。如果想确认这个脚本是否成功创建了用户账户，可以打开这个文件，看其中是否有这些新创建的用户信息。</p> 
<pre>[root@localhost ~]# bash addusers.sh
Enter The Users Password : xxxxxxxx
andy , Create success
barry , Create success
carl , Create success
duke , Create success
eric , Create success
george , Create success
[root@localhost ~]# tail -6 /etc/passwd
andy:x:1001:1001::/home/andy:/bin/bash
barry:x:1002:1002::/home/barry:/bin/bash
carl:x:1003:1003::/home/carl:/bin/bash
duke:x:1004:1004::/home/duke:/bin/bash
eric:x:1005:1005::/home/eric:/bin/bash
george:x:1006:1006::/home/george:/bin/bash</pre> 
<p>大家还记得在学习双分支if条件语句时，用到的那个测试主机是否在线的脚本么？既然我们现在已经掌握了for循环语句，不妨做些更酷的事情，比如尝试让脚本从文本中自动读取主机列表，然后自动逐个测试这些主机是否在线。</p> 
<p>首先创建一个主机列表文件ipaddrs.txt：</p> 
<pre>[root@localhost ~]# vim ipaddrs.txt
192.168.10.10
192.168.10.11
192.168.10.12</pre> 
<p>然后将前面的双分支if条件语句与for循环语句相结合，让脚本从主机列表文件ipaddrs.txt中自动读取IP地址（用来表示主机）并将其赋值给HLIST变量，从而通过判断ping命令执行后的返回值来逐个测试主机是否在线。脚本中出现的“$（命令）”是一种完全类似于第3章的转义字符中反引号<code>命令</code>的Shell操作符，效果同样是执行括号或双引号括起来的字符串中的命令。大家在编写脚本时，多学习几种类似的新方法，可在工作中大显身手：</p> 
<pre>[root@localhost ~]# vim CheckHosts.sh
#!/bin/bash
HLIST=$(cat ~/ipaddrs.txt)
for IP in $HLIST
do
        ping -c 3 -i 0.2 -W 3 $IP &amp;&gt; /dev/null
        if [ $? -eq 0 ]  
        then
                echo "Host $IP is On-line."
        else
                echo "Host $IP is Off-line."
        fi
done
[root@localhost ~]# ./CheckHosts.sh
Host 192.168.10.10 is On-line.
Host 192.168.10.11 is Off-line.
Host 192.168.10.12 is Off-line.</pre> 
<p>细心的读者应该发现了，Shell脚本中的代码缩进格式会根据不同的语句而改变。这是由Vim编辑器自动完成的，用户无须进行额外操作。但是，如果您使用的是RHEL 7以前的版本，则没有这个自动缩进功能，不过功能不受影响，只是会影响阅读体验而已。</p> 
<h4>3、while 条件循环语句</h4> 
<p>while条件循环语句是一种让脚本根据某些条件来重复执行命令的语句，它的循环结构往往在执行前并不确定最终执行的次数，完全不同于for循环语句中有目标、有范围的使用场景。while循环语句通过判断条件测试的真假来决定是否继续执行命令，若条件为真就继续执行，为假就结束循环。while语句的语法格式如图所示。</p> 
<p><img alt="" height="148" src="https://images2.imgbox.com/12/92/9qjgSJ4w_o.png" width="726"></p> 
<p>接下来结合使用多分支的if条件测试语句与while条件循环语句，编写一个用来猜测数值大小的脚本Guess.sh。该脚本使用$RANDOM变量来调取出一个随机的数值（范围为0～32767），然后将这个随机数对1000进行取余操作，并使用expr命令取得其结果，再用这个数值与用户通过read命令输入的数值进行比较判断。这个判断语句分为3种情况，分别是判断用户输入的数值是等于、大于还是小于使用expr命令取得的数值。当前，现在这些内容不是重点，我们要关注的是while条件循环语句中的条件测试始终为true，因此判断语句会无限执行下去，直到用户输入的数值等于expr命令取得的数值后，才运行exit 0命令，终止脚本的执行。</p> 
<pre>[root@localhost ~]# vim Guess.sh
#!/bin/bash
PRICE=$(expr $RANDOM % 1000)
TIMES=0
echo "商品实际价格为0-999之间，猜猜看是多少？"
while true
do
        read -p "请输入您猜测的价格数目：" INT
        let TIMES++
        if [ $INT -eq $PRICE ] ; then
                echo "恭喜您答对了，实际价格是 $PRICE"
                echo "您总共猜测了 $TIMES 次"
                exit
        elif [ $INT -gt $PRICE ] ; then
                echo "太高了！"
        else
                echo "太低了！"
        fi
done</pre> 
<p>在这个Guess.sh脚本中，我们添加了一些交互式的信息，从而使得用户与系统的互动性得以增强。而且每当循环到let TIMES++命令时都会让TIMES变量内的数值加1，用来统计循环总计执行了多少次。这可以让用户得知在总共猜测了多少次之后，才猜对价格。</p> 
<pre>[root@localhost ~]# bash Guess.sh
商品实际价格为0-999之间，猜猜看是多少？
请输入您猜测的价格数目：500
太低了！
请输入您猜测的价格数目：800
太高了！
请输入您猜测的价格数目：650
太低了！
请输入您猜测的价格数目：720
太高了！
请输入您猜测的价格数目：690
太低了！
请输入您猜测的价格数目：700
太高了！
请输入您猜测的价格数目：695
太高了！
请输入您猜测的价格数目：692
太高了！
请输入您猜测的价格数目：691
恭喜您答对了，实际价格是 691
您总共猜测了 9 次</pre> 
<p>当条件为true（真）的时候，while语句会一直循环下去，只有碰到exit才会结束，所以同学们一定要记得加上exit哦。</p> 
<h4>4、case 条件测试语句</h4> 
<p>如果您之前学习过C语言，看到这一小节的标题肯定会会心一笑：“这不就是switch语句嘛！”是的，case条件测试语句和switch语句的功能非常相似！case语句是在多个范围内匹配数据，若匹配成功则执行相关命令并结束整个条件测试；如果数据不在所列出的范围内，则会去执行星号（*）中所定义的默认命令。case语句的语法结构如图4-23所示。</p> 
<p><img alt="" height="365" src="https://images2.imgbox.com/63/f5/iKP9VR0A_o.png" width="762"></p> 
<p>在前文介绍的Guess.sh脚本中有一个致命的弱点—只能接受数字！您可以尝试输入一个字母，会发现脚本立即就崩溃了。原因是字母无法与数字进行大小比较，例如，“a是否大于等于3”这样的命题是完全错误的。必须有一定的措施来判断用户输入的内容，当用户输入的内容不是数字时，脚本能予以提示，从而免于崩溃。</p> 
<p>通过在脚本中组合使用case条件测试语句和通配符（详见第3章），完全可以满足这里的需求。接下来我们编写脚本Checkkeys.sh，提示用户输入一个字符并将其赋值给变量KEY，然后根据变量KEY的值向用户显示其值是字母、数字还是其他字符。</p> 
<pre>[root@localhost ~]# vim Checkkeys.sh
#!/bin/bash
read -p "请输入一个字符，并按Enter键确认：" KEY
case "$KEY" in
        [a-z]|[A-Z])
                echo "您输入的是 字母。"
                ;;
        [0-9])
                echo "您输入的是 数字。"
                ;;
        *)
                echo "您输入的是 空格、功能键或其他控制字符。"
esac
[root@localhost ~]# bash Checkkeys.sh
请输入一个字符，并按Enter键确认：6
您输入的是 数字。
[root@localhost ~]# bash Checkkeys.sh
请输入一个字符，并按Enter键确认：p
您输入的是 字母。
[root@localhost ~]# bash Checkkeys.sh
请输入一个字符，并按Enter键确认：^[[15~
您输入的是 空格、功能键或其他控制字符。</pre> 
<h3>3、函数</h3> 
<pre>[ function ] your_function_name()
{
    your_shell_commands;
    [return int;]
}</pre> 
<p>shell函数定义格式，各部分说明如下：</p> 
<ul><li> <p>[ function ]等中括号括起来部分----表示可选（即可有可无）</p> </li><li> <p>your_function_name部分----为函数名</p> </li><li> <p>your_shell_commands部分----为函数代码；shell一般以行为单位，但可以使用“\”换行，也可以在单行内使用“;”作为分隔符</p> </li><li> <p>return int部分----shell函数只能返回<strong>整数</strong>不能返回字符串; return后跟数值n(0-255)</p> <p>注意调用函数是不要使用括号（即如testFun()是不对的），代码如下：</p> </li></ul> 
<pre>testFun{
    echo "helloworld!"
}
​
testFun</pre> 
<p>$0是运行该脚本的shell, 传递的参数从$1开始、传递多个参数是以空格分隔，代码如下：</p> 
<pre>testFun(){
    echo $1
}
​
param="helloworld!"
testFun $param</pre> 
<p>除了可以通过$n形式获取第n个参数外，还可以使用以下几个写法：</p> 
<table><thead><tr><th><strong>形式</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>$#</td><td>传递到脚本的参数个数</td></tr><tr><td>$*</td><td>以一个单字符串显示所有向脚本传递的参数</td></tr><tr><td>$$</td><td>脚本运行的当前进程ID号</td></tr><tr><td>$!</td><td>后台运行的最后一个进程的ID号</td></tr><tr><td>$@</td><td>与$*相同，但是使用时加引号，并在引号中返回每个参数。</td></tr><tr><td>$-</td><td>显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td>$?</td><td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table> 
<p>要传递有空格的参数也简单，在传递时加上双引号即可</p> 
<p>返回整形</p> 
<pre>testFun(){
    echo "helloworld!"
    return 99
}
​
# 千万要注意shell并不像其他语言直接返回返回值，其返回值放到$?中，这也是为什么只能返回整型的原因
# 所以这种承接方法是错误的，获取到的值是echo打印的内容
# return_value=`testFun`
# 以下才是正确获取通过return返回的返回值的正确写法
testFunecho "the return value is: $?"</pre> 
<p>返回字符串</p> 
<p>通过return返回字符串是没戏的，我们有两个变通的方法，第一种是通过$()获取函数的所有打印，代码如下：</p> 
<pre>testFun(){
    echo "helloworld!"
    echo "success"
}
​
return_value=$(testFun)
echo "$return_value"</pre> 
<p>另外的一种做法是直接用一个变量，shell的变量都是全局的在被调用函数中赋值的变量在调用函数处也可获取，代码如下：</p> 
<pre>testFun(){
    echo "helloworld!"
    return_value="success"
}
​
testFunecho $return_value
</pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8546a926bb05b67d74d0e6de0873f0ed/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL实现（免密登录）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d9611fe9181d6377fa8eacc4abcc37ab/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LinuxCrontab（定时任务）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>