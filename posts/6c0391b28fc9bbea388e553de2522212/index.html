<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Matlab实现：图像边缘提取 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Matlab实现：图像边缘提取" />
<meta property="og:description" content="1、 边缘提取算法 方法一：一阶微分算子 Sobel算子 Sobel算子检测方法对灰度渐变和噪声较多的图像处理效果较好，Sobel算子对边缘定位不是很准确，图像的边缘不止一个像素。
Roberts算子 Roberts算子检测方法对具有陡峭的低噪声的图像处理效果较好，但是利用roberts算子提取边缘的结果是边缘比较粗，因此边缘的定位不是很准确。
Prewitt算子 Prewitt算子检测方法对灰度渐变和噪声较多的图像处理效果较好。但边缘较宽，而且间断点多。
Canny算子 Canny算子是目前边缘检测最常用的算法，效果也是最理想的。
Canny边缘检测算法不是简单的模板卷积而已，通过梯度方向和双阈值法来检测边缘点，具体算法可以参考：计算机视觉之一：特征检测 - AndyJee - 博客园；
图像边缘检测及图像区域分割、目标检测、目标识别
Canny方法不容易受噪声干扰，能够检测到真正的弱边缘。优点在于，使用两种不同的阈值分别检测强边缘和弱边缘，并且当弱边缘和强边缘相连时，才将弱边缘包含在输出图像中。
方法二：二阶微分算子 Laplacian算子 Laplacian算子法对噪声比较敏感，所以很少用该算子检测边缘，而是用来判断边缘像素视为与图像的明区还是暗区。
2、 实验结果分析 一、边缘提取： Sobel算子检测方法对灰度渐变和噪声较多的图像处理效果较好，sobel算子对边缘定位不是很准确，图像的边缘不止一个像素；Roberts算子检测方法对具有陡峭的低噪声的图像处理效果较好，但是利用roberts算子提取边缘的结果是边缘比较粗，因此边缘的定位不是很准确；Prewitt算子检测方法对灰度渐变和噪声较多的图像处理效果较好。但边缘较宽，而且间断点多；Laplacian算子法对噪声比较敏感，所以很少用该算子检测边缘，而是用来判断边缘像素视为与图像的明区还是暗区；Canny方法不容易受噪声干扰，能够检测到真正的弱边缘。优点在于，使用两种不同的阈值分别检测强边缘和弱边缘，并且当弱边缘和强边缘相连时，才将弱边缘包含在输出图像中。 二、边缘复合增强 Sobel、Robert、Prewitt算子的增强效果并不是很明显，尤其是Robert算子，因为它提取的边缘点过于稀疏和离散；Laplacian算子和canny算子的增强效果都比较理想， 将边缘叠加上去后，整个手的轮廓和边缘都很清晰，直观上看，canny算子实现的效果比Laplacian算子好，最明显的地方就是手指尖的边缘。基于蚁群算法的图像边缘检测 3、程序实现 下面的程序就实现上面效果的完整Matlab代码：
clear;clc; I=imread(&#39;x1.tif&#39;); % I=rgb2gray(I); % gray transform J=imadjust(I,[0.1 0.9],[0 1],1); % Edge detection % Sobel BW1=edge(I,&#39;sobel&#39;); sobelBW1=im2uint8(BW1)&#43;J; figure; %imshow(BW1); subplot(1,2,1); imshow(J); title(&#39;original image&#39;); subplot(1,2,2); imshow(sobelBW1); title(&#39;Sobel augmented image&#39;); % Roberts BW2=edge(I,&#39;roberts&#39;); robertBW2=im2uint8(BW2)&#43;J; figure; %imshow(BW2); subplot(1,2,1); imshow(J); title(&#39;original image&#39;); subplot(1,2,2); imshow(robertBW2); title(&#39;robert augmented image&#39;); % prewitt BW3=edge(I,&#39;prewitt&#39;); prewittBW3=im2uint8(BW3)&#43;J; figure; %imshow(BW3); subplot(1,2,1); imshow(J); title(&#39;original image&#39;); subplot(1,2,2); imshow(prewittBW3); title(&#39;Prewitt augmented image&#39;); % log BW4=edge(I,&#39;log&#39;); logBW4=im2uint8(BW4)&#43;J; figure; %imshow(BW4); subplot(1,2,1); imshow(J); title(&#39;original image&#39;); subplot(1,2,2); imshow(logBW4); title(&#39;Laplacian augmented image&#39;); % canny BW5=edge(I,&#39;canny&#39;); cannyBW5=im2uint8(BW5)&#43;J; figure; %imshow(BW5); subplot(1,2,1); imshow(J); title(&#39;original image&#39;); subplot(1,2,2); imshow(cannyBW5); title(&#39;Canny augmented image&#39;); % gaussian &amp; canny % h=fspecial(&#39;gaussian&#39;,5); % fI=imfilter(I,h,&#39;replicate&#39;); % BW6=edge(fI,&#39;canny&#39;); % figure; % imshow(BW6); figure; subplot(2,3,1), imshow(BW1); title(&#39;sobel edge detect&#39;); subplot(2,3,2), imshow(BW2); title(&#39;roberts edge detect&#39;); subplot(2,3,3), imshow(BW3); title(&#39;prewitt edge detect&#39;); subplot(2,3,4), imshow(BW4); title(&#39;log edge detect&#39;); subplot(2,3,5), imshow(BW5); title(&#39;canny edge detect&#39;); % subplot(2,3,6), imshow(BW6); % title(&#39;gasussian&amp;canny edge detect&#39;); figure; subplot(2,3,1), imshow(sobelBW1); title(&#39;sobel edge detect&#39;); subplot(2,3,2), imshow(robertBW2); title(&#39;roberts edge detect&#39;); subplot(2,3,3), imshow(prewittBW3); title(&#39;prewitt edge detect&#39;); subplot(2,3,4), imshow(logBW4); title(&#39;laplacian edge detect&#39;); subplot(2,3,5), imshow(cannyBW5); title(&#39;canny edge detect&#39;); 下面的Matlab程序是精简的边缘提取实现：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6c0391b28fc9bbea388e553de2522212/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-09T16:20:28+08:00" />
<meta property="article:modified_time" content="2023-11-09T16:20:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Matlab实现：图像边缘提取</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<h3>1、 边缘提取算法</h3> 
<blockquote> 
 <h4>方法一：一阶微分算子</h4> 
</blockquote> 
<ul><li> <h5>Sobel算子</h5> </li></ul> 
<blockquote> 
 <p></p> 
 <p class="img-center"><a href="https://images0.cnblogs.com/blog/585228/201405/191744367152350.png" rel="nofollow"><img alt="clip_image001" height="67" src="https://images2.imgbox.com/71/2d/8EJ9Yqsp_o.png" width="240"></a></p> 
</blockquote> 
<blockquote> 
 <p>Sobel算子检测方法对灰度渐变和噪声较多的图像处理效果较好，Sobel算子对边缘定位不是很准确，图像的边缘不止一个像素。</p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p class="img-center"><a href="https://images0.cnblogs.com/blog/585228/201405/191744404817266.jpg" rel="nofollow"><img alt="clip_image003" height="240" src="https://images2.imgbox.com/1b/84/shU1Rf5a_o.jpg" width="239"></a></p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p class="img-center"><a href="https://images0.cnblogs.com/blog/585228/201405/191744424652840.jpg" rel="nofollow"><img alt="clip_image005" height="236" src="https://images2.imgbox.com/b7/4c/k4JtLxnM_o.jpg" width="515"></a></p> 
</blockquote> 
<ul><li> <h5>Roberts算子</h5> </li></ul> 
<blockquote> 
 <p></p> 
 <p class="img-center"><a href="https://images0.cnblogs.com/blog/585228/201405/191744433093497.png" rel="nofollow"><img alt="clip_image006" height="57" src="https://images2.imgbox.com/72/35/YFcEd1It_o.png" width="240"></a></p> 
</blockquote> 
<blockquote> 
 <p>Roberts算子检测方法对具有陡峭的低噪声的图像处理效果较好，但是利用roberts算子提取边缘的结果是边缘比较粗，因此边缘的定位不是很准确。</p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p class="img-center"><a href="https://images0.cnblogs.com/blog/585228/201405/191744440438355.jpg" rel="nofollow"><img alt="clip_image008" height="239" src="https://images2.imgbox.com/25/29/igr3SNfB_o.jpg" width="240"></a></p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p class="img-center"><a href="https://images0.cnblogs.com/blog/585228/201405/191744451847570.jpg" rel="nofollow"><img alt="clip_image009" height="239" src="https://images2.imgbox.com/59/70/FzT2ygEC_o.jpg" width="521"></a></p> 
</blockquote> 
<ul><li> <h5>Prewitt算子</h5> </li></ul> 
<blockquote> 
 <p></p> 
 <p class="img-center"><a href="https://images0.cnblogs.com/blog/585228/201405/191744465746029.png" rel="nofollow"><img alt="clip_image010" height="114" src="https://images2.imgbox.com/10/fc/PCNj50Cb_o.png" width="217"></a></p> 
</blockquote> 
<blockquote> 
 <p>Prewitt算子检测方法对灰度渐变和噪声较多的图像处理效果较好。但边缘较宽，而且间断点多。</p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p class="img-center"><a href="https://images0.cnblogs.com/blog/585228/201405/191744475125715.jpg" rel="nofollow"><img alt="clip_image012" height="240" src="https://images2.imgbox.com/8e/11/QFDMhiUU_o.jpg" width="239"></a></p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p class="img-center"><a href="https://images0.cnblogs.com/blog/585228/201405/191744482461573.jpg" rel="nofollow"><img alt="clip_image014" height="241" src="https://images2.imgbox.com/3d/3d/0O6Pbs93_o.jpg" width="530"></a></p> 
</blockquote> 
<ul><li> <h5>Canny算子</h5> </li></ul> 
<blockquote> 
 <p>Canny算子是目前边缘检测最常用的算法，效果也是最理想的。</p> 
</blockquote> 
<blockquote> 
 <p>Canny边缘检测算法不是简单的模板卷积而已，通过梯度方向和双阈值法来检测边缘点，具体算法可以参考：<a href="http://www.cnblogs.com/AndyJee/p/3734805.html" rel="nofollow" title="计算机视觉之一：特征检测 - AndyJee - 博客园">计算机视觉之一：特征检测 - AndyJee - 博客园</a>；</p> 
 <p><a class="link-info" href="https://www.3dddown.com/12898.html" rel="nofollow" title="图像边缘检测及图像区域分割、目标检测、目标识别">图像边缘检测及图像区域分割、目标检测、目标识别</a></p> 
</blockquote> 
<blockquote> 
 <p>Canny方法不容易受噪声干扰，能够检测到真正的弱边缘。优点在于，使用两种不同的阈值分别检测强边缘和弱边缘，并且当弱边缘和强边缘相连时，才将弱边缘包含在输出图像中。</p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p class="img-center"><a href="https://images0.cnblogs.com/blog/585228/201405/191744491684488.jpg" rel="nofollow"><img alt="clip_image016" height="240" src="https://images2.imgbox.com/15/fa/qzn3nuYh_o.jpg" width="239"></a></p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p class="img-center"><a href="https://images0.cnblogs.com/blog/585228/201405/191744500433389.jpg" rel="nofollow"><img alt="clip_image018" height="240" src="https://images2.imgbox.com/cb/24/XSbCeO2F_o.jpg" width="533"></a></p> 
</blockquote> 
<blockquote> 
 <h4>方法二：二阶微分算子</h4> 
</blockquote> 
<ul><li> <h5>Laplacian算子</h5> </li></ul> 
<blockquote> 
 <p></p> 
 <p class="img-center"><a href="https://images0.cnblogs.com/blog/585228/201405/191744508565802.png" rel="nofollow"><img alt="clip_image019" height="96" src="https://images2.imgbox.com/a6/22/wi4660XM_o.png" width="151"></a></p> 
 <p> </p> 
 <p class="img-center"><a href="https://images0.cnblogs.com/blog/585228/201405/191744512776333.png" rel="nofollow"><img alt="clip_image020" height="94" src="https://images2.imgbox.com/61/f1/jPkdFoWy_o.png" width="149"></a></p> 
</blockquote> 
<blockquote> 
 <p>Laplacian算子法对噪声比较敏感，所以很少用该算子检测边缘，而是用来判断边缘像素视为与图像的明区还是暗区。</p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p class="img-center"><a href="https://images0.cnblogs.com/blog/585228/201405/191744519818246.jpg" rel="nofollow"><img alt="clip_image022" height="240" src="https://images2.imgbox.com/b6/ba/ueKdyPoL_o.jpg" width="239"></a></p> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p class="img-center"><a href="https://images0.cnblogs.com/blog/585228/201405/191744536528491.jpg" rel="nofollow"><img alt="clip_image024" height="247" src="https://images2.imgbox.com/62/1b/BviXUayp_o.jpg" width="542"></a></p> 
</blockquote> 
<h3>2、 实验结果分析</h3> 
<blockquote> 
 <h4>一、边缘提取：</h4> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p class="img-center"><a href="https://images0.cnblogs.com/blog/585228/201405/191744544817676.jpg" rel="nofollow"><img alt="clip_image026" height="438" src="https://images2.imgbox.com/f5/5d/NVIu3y3X_o.jpg" width="766"></a></p> 
</blockquote> 
<ul><li>Sobel算子检测方法对灰度渐变和噪声较多的图像处理效果较好，sobel算子对边缘定位不是很准确，图像的边缘不止一个像素；</li><li>Roberts算子检测方法对具有陡峭的低噪声的图像处理效果较好，但是利用roberts算子提取边缘的结果是边缘比较粗，因此边缘的定位不是很准确；</li><li>Prewitt算子检测方法对灰度渐变和噪声较多的图像处理效果较好。但边缘较宽，而且间断点多；</li><li>Laplacian算子法对噪声比较敏感，所以很少用该算子检测边缘，而是用来判断边缘像素视为与图像的明区还是暗区；</li><li>Canny方法不容易受噪声干扰，能够检测到真正的弱边缘。优点在于，使用两种不同的阈值分别检测强边缘和弱边缘，并且当弱边缘和强边缘相连时，才将弱边缘包含在输出图像中。</li></ul> 
<blockquote> 
 <h4>二、边缘复合增强</h4> 
</blockquote> 
<blockquote> 
 <p></p> 
 <p class="img-center"><a href="https://images0.cnblogs.com/blog/585228/201405/191744555904349.jpg" rel="nofollow"><img alt="clip_image028" height="435" src="https://images2.imgbox.com/13/99/udwH919c_o.jpg" width="772"></a></p> 
</blockquote> 
<ul><li>Sobel、Robert、Prewitt算子的增强效果并不是很明显，尤其是Robert算子，因为它提取的边缘点过于稀疏和离散；</li><li>Laplacian算子和canny算子的增强效果都比较理想， 将边缘叠加上去后，整个手的轮廓和边缘都很清晰，直观上看，canny算子实现的效果比Laplacian算子好，最明显的地方就是手指尖的边缘。</li><li><a class="link-info" href="https://www.codedown123.com/99976.html" rel="nofollow" title="基于蚁群算法的图像边缘检测">基于蚁群算法的图像边缘检测</a></li></ul> 
<h3>3、程序实现</h3> 
<blockquote> 
 <p>下面的程序就实现上面效果的完整Matlab代码：</p> 
</blockquote> 
<pre><code>clear;clc;
I=imread('x1.tif');
% I=rgb2gray(I);
% gray transform

J=imadjust(I,[0.1 0.9],[0 1],1);

% Edge detection
% Sobel
BW1=edge(I,'sobel');
sobelBW1=im2uint8(BW1)+J;
figure;
%imshow(BW1);
subplot(1,2,1);
imshow(J);
title('original image');
subplot(1,2,2);
imshow(sobelBW1);
title('Sobel augmented image');
% Roberts
BW2=edge(I,'roberts');
robertBW2=im2uint8(BW2)+J;
figure;
%imshow(BW2);
subplot(1,2,1);
imshow(J);
title('original image');
subplot(1,2,2);
imshow(robertBW2);
title('robert augmented image');
% prewitt
BW3=edge(I,'prewitt');
prewittBW3=im2uint8(BW3)+J;
figure;
%imshow(BW3);
subplot(1,2,1);
imshow(J);
title('original image');
subplot(1,2,2);
imshow(prewittBW3);
title('Prewitt augmented image');
% log
BW4=edge(I,'log');
logBW4=im2uint8(BW4)+J;
figure;
%imshow(BW4);
subplot(1,2,1);
imshow(J);
title('original image');
subplot(1,2,2);
imshow(logBW4);
title('Laplacian augmented image');
% canny
BW5=edge(I,'canny');
cannyBW5=im2uint8(BW5)+J;
figure;
%imshow(BW5);
subplot(1,2,1);
imshow(J);
title('original image');
subplot(1,2,2);
imshow(cannyBW5);
title('Canny augmented image');
% gaussian &amp; canny
% h=fspecial('gaussian',5); 
% fI=imfilter(I,h,'replicate');
% BW6=edge(fI,'canny');
% figure;
% imshow(BW6);

figure;
subplot(2,3,1), imshow(BW1); 
title('sobel edge detect'); 
subplot(2,3,2), imshow(BW2); 
title('roberts edge detect'); 
subplot(2,3,3), imshow(BW3); 
title('prewitt edge detect'); 
subplot(2,3,4), imshow(BW4); 
title('log edge detect'); 
subplot(2,3,5), imshow(BW5); 
title('canny edge detect'); 
% subplot(2,3,6), imshow(BW6); 
% title('gasussian&amp;canny edge detect');

figure;
subplot(2,3,1), imshow(sobelBW1); 
title('sobel edge detect'); 
subplot(2,3,2), imshow(robertBW2); 
title('roberts edge detect'); 
subplot(2,3,3), imshow(prewittBW3); 
title('prewitt edge detect'); 
subplot(2,3,4), imshow(logBW4); 
title('laplacian edge detect'); 
subplot(2,3,5), imshow(cannyBW5); 
title('canny edge detect');</code></pre> 
<blockquote> 
 <p>下面的Matlab程序是精简的边缘提取实现：</p> 
</blockquote> 
<pre><code>clear;clc;

I=imread('lena.bmp');
I=rgb2gray(I);
imshow(I,[]);
title('Original Image');

sobelBW=edge(I,'sobel');
figure;
imshow(sobelBW);
title('Sobel Edge');

robertsBW=edge(I,'roberts');
figure;
imshow(robertsBW);
title('Roberts Edge');

prewittBW=edge(I,'prewitt');
figure;
imshow(prewittBW);
title('Prewitt Edge');

logBW=edge(I,'log');
figure;
imshow(logBW);
title('Laplasian of Gaussian Edge');

cannyBW=edge(I,'canny');
figure;
imshow(cannyBW);
title('Canny Edge');</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/29efc1bfa611c7a24aab4ce2d8aa1f5d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">面了一个工作4年的JAVA程序员，这些个面试题一个都答不上来</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1a30b7854436ffda868f83b43dcbfec2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大数据之LibrA数据库系统告警处理（ALM-12033 慢盘故障）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>