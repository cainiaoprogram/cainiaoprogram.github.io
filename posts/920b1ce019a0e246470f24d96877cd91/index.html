<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>JPA简介及其使用详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="JPA简介及其使用详解" />
<meta property="og:description" content="一、Spring data JPA简介 Spring data JPA是Spring在ORM框架，以及JPA规范的基础上，封装的一套JPA应用框架，并提供了一整套的数据访问层解决方案。
二、Spring data JPA的功能 Spring data JPA的功能非常的强大，这里我们先跳过环境搭建这一步，来一睹Spring data JPA的“芳容”。
Spring data JPA提供给用户使用的，主要有以下几个接口：
Repository：仅仅是一个标识，表明任何继承它的均为仓库接口类，方便Spring自动扫描识别CrudRepository：继承Repository，实现了一组CRUD相关的方法PagingAndSortingRepository：继承CrudRepository，实现了一组分页排序相关的方法JpaRepository：继承PagingAndSortingRepository，实现一组JPA规范相关的方法JpaSpecificationExecutor：比较特殊，不属于Repository体系，实现一组JPA Criteria查询相关的方法。 三、Spring data JPA的接口 1、CrudRepository接口 该接口的定义如下，总共提供了11个方法，基本上可以满足简单的CRUD操作以及批量操作：
@NoRepositoryBean public interface CrudRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; { &lt;S extends T&gt; S save(S entity);//保存 &lt;S extends T&gt; Iterable&lt;S&gt; save(Iterable&lt;S&gt; entities);//批量保存 T findOne(ID id);//根据id查询一个对象 boolean exists(ID id);//判断对象是否存在 Iterable&lt;T&gt; findAll();//查询所有的对象 Iterable&lt;T&gt; findAll(Iterable&lt;ID&gt; ids);//根据id列表查询所有的对象 long count();//计算对象的总个数 void delete(ID id);//根据id删除 void delete(T entity);//删除对象 void delete(Iterable&lt;? extends T&gt; entities);//批量删除 void deleteAll();//删除所有 } 2、PagingAndSortingRepository接口 PagingAndSortingRepository接口继承了CrudRepository接口。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/920b1ce019a0e246470f24d96877cd91/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-15T16:08:00+08:00" />
<meta property="article:modified_time" content="2019-04-15T16:08:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">JPA简介及其使用详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><strong>一、Spring data JPA简介</strong></h3> 
<p>Spring data JPA是Spring在ORM框架，以及JPA规范的基础上，封装的一套JPA应用框架，并提供了一整套的数据访问层解决方案。</p> 
<h3><strong>二、Spring data JPA的功能</strong></h3> 
<p>Spring data JPA的功能非常的强大，这里我们先跳过环境搭建这一步，来一睹Spring data JPA的“芳容”。</p> 
<p>Spring data JPA提供给用户使用的，主要有以下几个接口：</p> 
<ol><li>Repository：仅仅是一个标识，表明任何继承它的均为仓库接口类，方便Spring自动扫描识别</li><li>CrudRepository：继承Repository，实现了一组CRUD相关的方法</li><li>PagingAndSortingRepository：继承CrudRepository，实现了一组分页排序相关的方法</li><li>JpaRepository：继承PagingAndSortingRepository，实现一组JPA规范相关的方法</li><li>JpaSpecificationExecutor：比较特殊，不属于Repository体系，实现一组JPA Criteria查询相关的方法。</li></ol> 
<h3><strong>三、Spring data JPA的接口</strong></h3> 
<h4><strong>1、CrudRepository接口</strong></h4> 
<p>该接口的定义如下，总共提供了11个方法，基本上可以满足简单的CRUD操作以及批量操作：</p> 
<pre class="has"><code>@NoRepositoryBean
public interface CrudRepository&lt;T, ID extends Serializable&gt; extends Repository&lt;T, ID&gt; {

  &lt;S extends T&gt; S save(S entity);//保存

  &lt;S extends T&gt; Iterable&lt;S&gt; save(Iterable&lt;S&gt; entities);//批量保存

  T findOne(ID id);//根据id查询一个对象

  boolean exists(ID id);//判断对象是否存在

  Iterable&lt;T&gt; findAll();//查询所有的对象

  Iterable&lt;T&gt; findAll(Iterable&lt;ID&gt; ids);//根据id列表查询所有的对象

  long count();//计算对象的总个数

  void delete(ID id);//根据id删除

  void delete(T entity);//删除对象

  void delete(Iterable&lt;? extends T&gt; entities);//批量删除

  void deleteAll();//删除所有

}</code></pre> 
<h4><strong>2、PagingAndSortingRepository接口</strong></h4> 
<p>PagingAndSortingRepository接口继承了CrudRepository接口。</p> 
<p>只要继承了这个接口，Spring data JPA就已经为你提供了分页和排序的功能了。该接口的定义如下，主要提供了两个方法，供使用，其中T是要操作的实体类，ID是实体类主键的类型：</p> 
<pre class="has"><code>@NoRepositoryBean
public interface PagingAndSortingRepository&lt;T, ID extends Serializable&gt; extends CrudRepository&lt;T, ID&gt; {

  Iterable&lt;T&gt; findAll(Sort sort);// 不带分页的排序

  Page&lt;T&gt; findAll(Pageable pageable);// 带分页的排序

}</code></pre> 
<h4><strong>3、JpaRepository接口</strong></h4> 
<p>如果业务需要即提供CRUD操作，又需要提供分页以及排序功能，那么就可以直接继承这个接口。该接口继承了PagingAndSortingRepository接口。</p> 
<p>接口定义如下：</p> 
<pre class="has"><code>public interface JpaRepository&lt;T, ID extends Serializable&gt; extends PagingAndSortingRepository&lt;T, ID&gt; {

  List&lt;T&gt; findAll();//查询所有对象，不排序

  List&lt;T&gt; findAll(Sort sort);//查询所有对象，并排序

  &lt;S extends T&gt; List&lt;S&gt; save(Iterable&lt;S&gt; entities);//批量保存

  void flush();//强制缓存与数据库同步

  T saveAndFlush(T entity);//保存并强制同步

  void deleteInBatch(Iterable&lt;T&gt; entities);//批量删除

  void deleteAllInBatch();//删除所有

}</code></pre> 
<h4><strong>4、JpaSpecificationExecutor接口</strong></h4> 
<p>该接口提供了对JPA Criteria查询的支持。注意，这个接口很特殊，不属于Repository体系，而Spring data JPA不会自动扫描识别，所以会报找不到对应的Bean，我们只需要继承任意一个继承了Repository的子接口或直接继承Repository接口，Spring data JPA就会自动扫描识别，进行统一的管理。</p> 
<p>编写接口如下：</p> 
<pre class="has"><code>public interface SpecificationExecutorRepository extends CrudRepository&lt;User, Integer&gt;,

    JpaSpecificationExecutor&lt;User&gt; { 

}</code></pre> 
<p>Service类：</p> 
<pre class="has"><code>@Service

public class SpecificationExecutorRepositoryManager {

  @Autowired
  private SpecificationExecutorRepository dao;

  /**
   * 描述：根据name来查询用户
   */
  public User findUserByName(final String name){
    return dao.findOne(new Specification&lt;User&gt;() {
      @Override
      public Predicate toPredicate(Root&lt;User&gt; root, CriteriaQuery&lt;?&gt; query,
          CriteriaBuilder cb) {
        Predicate predicate = cb.equal(root.get("name"), name);
        return predicate;
      }
    });
  }

    
  /**
   * 描述：根据name和email来查询用户
   */
  public User findUserByNameAndEmail(final String name, final String email){
    return dao.findOne(new Specification&lt;User&gt;() {
      @Override
      public Predicate toPredicate(Root&lt;User&gt; root,
          CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) {
        List&lt;Predicate&gt; list = new ArrayList&lt;Predicate&gt;();
        Predicate predicate1 = cb.equal(root.get("name"), name);
        Predicate predicate2 = cb.equal(root.get("email"), email);
        list.add(predicate1);
        list.add(predicate2);
        // 注意此处的处理
        Predicate[] p = new Predicate[list.size()];
        return cb.and(list.toArray(p));
      }
    });
  }
    

  /**
   * 描述：组合查询
   */
  public User findUserByUser(final User userVo){
    return dao.findOne(new Specification&lt;User&gt;() {
      @Override
      public Predicate toPredicate(Root&lt;User&gt; root,
          CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) {
        Predicate predicate = cb.equal(root.get("name"), userVo.getName());
        cb.and(predicate, cb.equal(root.get("email"), userVo.getEmail()));
        cb.and(predicate, cb.equal(root.get("password"), userVo.getPassword()));
        return predicate;
      }
    });
  }

    
  /**
   * 描述：范围查询in方法，例如查询用户id在[2,10]中的用户
   */
  public List&lt;User&gt; findUserByIds(final List&lt;Integer&gt; ids){
    return dao.findAll(new Specification&lt;User&gt;() {
      @Override
      public Predicate toPredicate(Root&lt;User&gt; root,
          CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) {
        return root.in(ids);
      }
    });
  }

   
  /**
   * 描述：范围查询gt方法，例如查询用户id大于9的所有用户
   */
  public List&lt;User&gt; findUserByGtId(final int id){
    return dao.findAll(new Specification&lt;User&gt;() {
      @Override
      public Predicate toPredicate(Root&lt;User&gt; root,
          CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) {
        return cb.gt(root.get("id").as(Integer.class), id);
      }
    });
  }

    
  /**
   * 描述：范围查询lt方法，例如查询用户id小于10的用户
   */
  public List&lt;User&gt; findUserByLtId(final int id){
    return dao.findAll(new Specification&lt;User&gt;() {
      @Override
      public Predicate toPredicate(Root&lt;User&gt; root,
          CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) {
        return cb.lt(root.get("id").as(Integer.class), id);
      }

    });

  }

    
  /**
   * 描述：范围查询between方法，例如查询id在3和10之间的用户
   */
  public List&lt;User&gt; findUserBetweenId(final int start, final int end){
    return dao.findAll(new Specification&lt;User&gt;() {
      @Override
      public Predicate toPredicate(Root&lt;User&gt; root,
          CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) {
        return cb.between(root.get("id").as(Integer.class), start, end);
      }
    });
  }
    

  /**
   * 描述：排序和分页操作
   */
  public Page&lt;User&gt; findUserAndOrder(final int id){
    Sort sort = new Sort(Direction.DESC, "id");
    return dao.findAll(new Specification&lt;User&gt;() {
      @Override
      public Predicate toPredicate(Root&lt;User&gt; root,
          CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) {
        return cb.gt(root.get("id").as(Integer.class), id);
      }
    }, new PageRequest(0, 5, sort));
  }

    

  /**
   * 描述：只有排序操作
   */
  public List&lt;User&gt; findUserAndOrderSecondMethod(final int id){
    return dao.findAll(new Specification&lt;User&gt;() {
      @Override
      public Predicate toPredicate(Root&lt;User&gt; root,
          CriteriaQuery&lt;?&gt; query, CriteriaBuilder cb) {
        cb.gt(root.get("id").as(Integer.class), id);
        query.orderBy(cb.desc(root.get("id").as(Integer.class)));
        return query.getRestriction();
      }
    });
  }

}</code></pre> 
<h4><strong>5、Repository接口</strong></h4> 
<p>这个接口是最基础的接口，只是一个标志性的接口，没有定义任何的方法，那这个接口有什么用了？既然Spring data JPA提供了这个接口，自然是有它的用处，例如，我们有一部分方法是不想对外提供的，比如我们只想提供增加和修改方法，不提供删除方法，那么前面的几个接口都是做不到的，这个时候，我们就可以继承这个接口，然后将CrudRepository接口里面相应的方法拷贝到Repository接口就可以了。</p> 
<p>总结：上述五个接口，开发者到底该如何选择？其实依据很简单，根据具体的业务需求，选择其中之一。因为各个接口之间并不存在功能强弱的问题。</p> 
<h3><strong>四、Spring data JPA的查询</strong></h3> 
<h4><strong>1、使用 @Query 创建查询</strong></h4> 
<p>@Query 注解的使用非常简单，只需在声明的方法上面标注该注解，同时提供一个 JP QL 查询语句即可。很多开发者在创建 JP QL 时喜欢使用命名参数来代替位置编号，@Query 也对此提供了支持。JP QL 语句中通过": 变量"的格式来指定参数，同时在方法的参数前面使用 @Param 将方法参数与 JP QL 中的命名参数对应。此外，开发者也可以通过使用 @Query 来执行一个更新操作，为此，我们需要在使用 @Query 的同时，用 @Modifying 来将该操作标识为修改查询，这样框架最终会生成一个更新的操作，而非查询操作。</p> 
<p>编写接口，如下：</p> 
<pre class="has"><code>/**
 * 描述：自定义查询，当Spring Data JPA无法提供时，需要自定义接口，此时可以使用这种方式
 */
public interface UserDefineBySelf extends JpaRepository&lt;User, Integer&gt; {

  /**
   * 命名参数
   * 描述：推荐使用这种方法，可以不用管参数的位置
   */
  @Query("select u from User u where u.name = :name")
  User findUserByName(@Param("name") String name);

    
  /**
   * 索引参数
   * 描述：使用?占位符
   */
  @Query("select u from User u where u.email = ?1")// 1表示第一个参数
  User findUserByEmail(String email);
    
  /**
   * 描述：可以通过@Modifying和@Query来实现更新
   * 注意：Modifying queries的返回值只能为void或者是int/Integer
   * 新版本update/delete必须使用@Transactional注解
   */
  @Transactional
  @Modifying
  @Query("update User u set u.name = :name where u.id = :id")
  int updateUserById(@Param("name") String name, @Param("id") int id);

}</code></pre> 
<p>注：@Modifying注解里面有一个配置clearAutomatically</p> 
<p>它说的是可以清除底层持久化上下文，就是entityManager这个类，我们知道jpa底层实现会有二级缓存，也就是在更新完数据库后，如果后面去用这个对象，你再去查这个对象，这个对象是在一级缓存，但是并没有跟数据库同步，这个时候用clearAutomatically=true,就会刷新hibernate的一级缓存了， 不然你在同一接口中，更新一个对象，接着查询这个对象，那么你查出来的这个对象还是之前的没有更新之前的状态</p> 
<h4><strong>2、使用@NamedQueries创建查询</strong></h4> 
<p>命名查询是 JPA 提供的一种将查询语句从方法体中独立出来，以供多个方法共用的功能。Spring Data JPA 对命名查询也提供了很好的支持。用户只需要按照 JPA 规范在 orm.xml 文件或者在代码中使用 @NamedQuery（或 @NamedNativeQuery）定义好查询语句，唯一要做的就是为该语句命名时，需要满足”DomainClass.methodName()”的 命名规则。</p> 
<p>编写接口：</p> 
<pre class="has"><code>public interface FindUserByNamedQueryRepository extends JpaRepository&lt;User, Integer&gt; {

  User findUserWithName(@Param("name") String name);

}</code></pre> 
<p>编写类：</p> 
<pre class="has"><code>@Entity
@NamedQueries(value={
    @NamedQuery(name="User.findUserWithName",query="select u from User u where u.name = :name")
})

// 注意：此处如果是多个方法，那么需要使用@NamedQueries，如果只有一个方法，则可以使用@NamedQuery，写法如下：@NamedQuery(name="User.findUserWithName",query="select u from User u where u.name = :name")
public class FindUserByNamedQuery {

  /**
   * 注意：此处必须要给这个实体类定义一个唯一标识，否则会报异常
   */
  @Id
  @GeneratedValue
  private Integer id;

}</code></pre> 
<p>注意：文中标记为红色的部分，需要一一对应，否则不满足JPA 的规范。</p> 
<p>测试类：</p> 
<pre class="has"><code>@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = { "classpath:applicationContext-config.xml" })
@TransactionConfiguration(defaultRollback = false)
@Transactional
public class FindUserByNamedQueryRepositoryTest {

  @Autowired
  private FindUserByNamedQueryRepository dao;

    
  @Test
  public void testFindUserByName(){
    User user = dao.findUserWithName("caican");
    System.out.println(JSON.toJSONString(user));
  }

}</code></pre> 
<h4><strong>3、通过解析方法名创建查询</strong></h4> 
<p>顾名思义，就是根据方法的名字，就能创建查询，也许初听起来，感觉很不可思议，等测试后才发现，原来一切皆有可能。</p> 
<p>编写接口：</p> 
<pre class="has"><code>public interface SimpleConditionQueryRepository extends JpaRepository&lt;User, Integer&gt; {

  /**
   * 说明：按照Spring data 定义的规则，查询方法以find|read|get开头
   * 涉及条件查询时，条件的属性用条件关键字连接，要注意的是：条件属性首字母需大写
   */   
  /**
   * 注：此处这个接口相当于发送了一条SQL:select u from User u where u.name = :name and u.email = :email
   * 参数名大写，条件名首字母大写，并且接口名中参数出现的顺序必须和参数列表中的参数顺序一致
   */
  User findByNameAndEmail(String name, String email);
    

  /**
   * 注：此处这个接口相当于发送了一条SQL:select u from User u where u.name = ?1 or u.password = ?2
   */
  List&lt;User&gt; findByNameOrPassword(String name, String password);
    

  /**
   * 注：此处这个接口相当于发送了一条SQL:select u from User u where u.id between ?1 and ?2
   */
  List&lt;User&gt; findByIdBetween(Integer start, Integer end);

    
  /**
   * 注：此处这个接口相当于发送了一条SQL:select u from User u where u.id &lt; ?1
   */
  List&lt;User&gt; findByIdLessThan(Integer end);

    
  /**
   * 注：此处这个接口相当于发送了一条SQL:select u from User u where u.id &gt; ?1
   */
  List&lt;User&gt; findByIdGreaterThan(Integer start);

    
  /**
   * 注：此处这个接口相当于发送了一条SQL:select u from User u where u.name is null
   */
  List&lt;User&gt; findByNameIsNull();

    
  /**
   * 注：此处这个接口相当于发送了一条SQL:select u from User u where u.name is not null
   */
  List&lt;User&gt; findByNameIsNotNull();

    
  /**
   * 注：此处这个接口相当于发送了一条SQL:select u from User u where u.name like ?1
   */
  List&lt;User&gt; findByNameLike(String name);

    
  /**
   * 注：此处这个接口相当于发送了一条SQL:select u from User u where u.name not like ?1
   */
  List&lt;User&gt; findByNameNotLike(String name);

    
  /**
   * 注：此处这个接口相当于发送了一条SQL:select u from User u where u.password = ?1 order by u.id desc
   */
  List&lt;User&gt; findByPasswordOrderByIdDesc(String password);

    
  /**
   * 注：此处这个接口相当于发送了一条SQL:select u from User u where u.name &lt;&gt; ?1
   */
  List&lt;User&gt; findByNameNot(String name);

    
  /**
   * 注：此处这个接口相当于发送了一条SQL:select u from User u where u.id in ?1
   */
  List&lt;User&gt; findByIdIn(List&lt;Integer&gt; ids);

    
  /**
   * 注：此处这个接口相当于发送了一条SQL:select u from User u where u.id not in ?1
   */
  List&lt;User&gt; findByIdNotIn(List&lt;Integer&gt; ids);

}</code></pre> 
<p>框架在进行方法名解析时，会先把方法名多余的前缀截取掉，比如 find、findBy、read、readBy、get、getBy，然后对剩下部分进行解析。并且如果方法的最后一个参数是 Sort 或者 Pageable 类型，也会提取相关的信息，以便按规则进行排序或者分页查询。在创建查询时，我们通过在方法名中使用属性名称来表达，比如 findByIdIn()。框架在解析该方法时，首先剔除 findBy，然后对剩下的属性进行解析。</p> 
<p>在查询时，通常需要同时根据多个属性进行查询，且查询的条件也格式各样（大于某个值、在某个范围等等），Spring Data JPA 为此提供了一些表达条件查询的关键字，大致如下：</p> 
<table><thead><tr><th> <p>Keyword</p> </th><th> <p>Sample</p> </th><th> <p>JPQL snippet</p> </th></tr></thead><tbody><tr><td> <p><code>And</code></p> </td><td> <p><code>findByLastnameAndFirstname</code></p> </td><td> <p><code>… where x.lastname = ?1 and x.firstname = ?2</code></p> </td></tr><tr><td> <p><code>Or</code></p> </td><td> <p><code>findByLastnameOrFirstname</code></p> </td><td> <p><code>… where x.lastname = ?1 or x.firstname = ?2</code></p> </td></tr><tr><td> <p><code>Is,Equals</code></p> </td><td> <p><code>findByFirstname</code>,<code>findByFirstnameIs</code>,<code>findByFirstnameEquals</code></p> </td><td> <p><code>… where x.firstname = ?1</code></p> </td></tr><tr><td> <p><code>Between</code></p> </td><td> <p><code>findByStartDateBetween</code></p> </td><td> <p><code>… where x.startDate between ?1 and ?2</code></p> </td></tr><tr><td> <p><code>LessThan</code></p> </td><td> <p><code>findByAgeLessThan</code></p> </td><td> <p><code>… where x.age &lt; ?1</code></p> </td></tr><tr><td> <p><code>LessThanEqual</code></p> </td><td> <p><code>findByAgeLessThanEqual</code></p> </td><td> <p><code>… where x.age ⇐ ?1</code></p> </td></tr><tr><td> <p><code>GreaterThan</code></p> </td><td> <p><code>findByAgeGreaterThan</code></p> </td><td> <p><code>… where x.age &gt; ?1</code></p> </td></tr><tr><td> <p><code>GreaterThanEqual</code></p> </td><td> <p><code>findByAgeGreaterThanEqual</code></p> </td><td> <p><code>… where x.age &gt;= ?1</code></p> </td></tr><tr><td> <p><code>After</code></p> </td><td> <p><code>findByStartDateAfter</code></p> </td><td> <p><code>… where x.startDate &gt; ?1</code></p> </td></tr><tr><td> <p><code>Before</code></p> </td><td> <p><code>findByStartDateBefore</code></p> </td><td> <p><code>… where x.startDate &lt; ?1</code></p> </td></tr><tr><td> <p><code>IsNull</code></p> </td><td> <p><code>findByAgeIsNull</code></p> </td><td> <p><code>… where x.age is null</code></p> </td></tr><tr><td> <p><code>IsNotNull,NotNull</code></p> </td><td> <p><code>findByAge(Is)NotNull</code></p> </td><td> <p><code>… where x.age not null</code></p> </td></tr><tr><td> <p><code>Like</code></p> </td><td> <p><code>findByFirstnameLike</code></p> </td><td> <p><code>… where x.firstname like ?1</code></p> </td></tr><tr><td> <p><code>NotLike</code></p> </td><td> <p><code>findByFirstnameNotLike</code></p> </td><td> <p><code>… where x.firstname not like ?1</code></p> </td></tr><tr><td> <p><code>StartingWith</code></p> </td><td> <p><code>findByFirstnameStartingWith</code></p> </td><td> <p><code>… where x.firstname like ?1</code>(parameter bound with appended <code>%</code>)</p> </td></tr><tr><td> <p><code>EndingWith</code></p> </td><td> <p><code>findByFirstnameEndingWith</code></p> </td><td> <p><code>… where x.firstname like ?1</code>(parameter bound with prepended <code>%</code>)</p> </td></tr><tr><td> <p><code>Containing</code></p> </td><td> <p><code>findByFirstnameContaining</code></p> </td><td> <p><code>… where x.firstname like ?1</code>(parameter bound wrapped in<code>%</code>)</p> </td></tr><tr><td> <p><code>OrderBy</code></p> </td><td> <p><code>findByAgeOrderByLastnameDesc</code></p> </td><td> <p><code>… where x.age = ?1 order by x.lastname desc</code></p> </td></tr><tr><td> <p><code>Not</code></p> </td><td> <p><code>findByLastnameNot</code></p> </td><td> <p><code>… where x.lastname &lt;&gt; ?1</code></p> </td></tr><tr><td> <p><code>In</code></p> </td><td> <p><code>findByAgeIn(Collection&lt;Age&gt; ages)</code></p> </td><td> <p><code>… where x.age in ?1</code></p> </td></tr><tr><td> <p><code>NotIn</code></p> </td><td> <p><code>findByAgeNotIn(Collection&lt;Age&gt; age)</code></p> </td><td> <p><code>… where x.age not in ?1</code></p> </td></tr><tr><td> <p><code>True</code></p> </td><td> <p><code>findByActiveTrue()</code></p> </td><td> <p><code>… where x.active = true</code></p> </td></tr><tr><td> <p><code>False</code></p> </td><td> <p><code>findByActiveFalse()</code></p> </td><td> <p><code>… where x.active = false</code></p> </td></tr><tr><td> <p><code>IgnoreCase</code></p> </td><td> <p><code>findByFirstnameIgnoreCase</code></p> </td><td> <p><code>… where UPPER(x.firstame) = UPPER(?1)</code></p> </td></tr></tbody></table> 
<h3><strong>五、创建查询的顺序</strong></h3> 
<p>Spring Data JPA 在为接口创建代理对象时，如果发现同时存在多种上述情况可用，它该优先采用哪种策略呢？为此，&lt;jpa:repositories&gt; 提供了 query-lookup-strategy 属性，用以指定查找的顺序。它有如下三个取值：</p> 
<p>create --- 通过解析方法名字来创建查询。即使有符合的命名查询，或者方法通过 @Query 指定的查询语句，都将会被忽略。</p> 
<p>create-if-not-found --- 如果方法通过 @Query 指定了查询语句，则使用该语句实现查询；如果没有，则查找是否定义了符合条件的命名查询，如果找到，则使用该命名查询；如果两者都没有找到，则通过解析方 法名字来创建查询。这是 query-lookup-strategy 属性的默认值。</p> 
<p>use-declared-query --- 如果方法通过 @Query 指定了查询语句，则使用该语句实现查询；如果没有，则查找是否定义了符合条件的命名查询，如果找到，则使用该命名查询；如果两者都没有找到，则抛出异常。</p> 
<h3><strong>六、Spring Data JPA 对事务的支持</strong></h3> 
<p>默认情况下，Spring Data JPA 实现的方法都是使用事务的。针对查询类型的方法，其等价于 @Transactional(readOnly=true)；增删改类型的方法，等价于 @Transactional。可以看出，除了将查询的方法设为只读事务外，其他事务属性均采用默认值。</p> 
<p>如果用户觉得有必要，可以在接口方法上使用 @Transactional 显式指定事务属性，该值覆盖 Spring Data JPA 提供的默认值。同时，开发者也可以在业务层方法上使用 @Transactional 指定事务属性，这主要针对一个业务层方法多次调用持久层方法的情况。持久层的事务会根据设置的事务传播行为来决定是挂起业务层事务还是加入业务层的事务。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8400d3ffeb4867c477af1edf1d7c46c3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java 高频面试题 208 道</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7c3eff5ceb1678246c9c167cbf5ee9d8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">android 开机优化（类和资源预加载优化）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>