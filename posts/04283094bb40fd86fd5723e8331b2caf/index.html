<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>c&#43;&#43;学习笔记（9）多态 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="c&#43;&#43;学习笔记（9）多态" />
<meta property="og:description" content="目录
基本概念
分为两类：
区别：
动态多态满足条件
动态多态使用：
多态的优点：
案例一：利用多态实现计算器
纯虚函数和抽象类
案例二：制作饮品
虚析构和纯虚析构
虚析构和纯虚析构共性：
区别：
虚析构语法：
纯虚析构语法：
总结：
案例三 电脑组装
基本概念 c&#43;&#43;面向对象三大特性之一
分为两类： 静态多态：函数重载和运算符重载属于静态多态，复用函数名
动态多态：派生类和虚函数实现运行时多态
区别： 静态多态的函数地址早绑定 编译阶段确定函数地址
动态多态的函数地址晚绑定，运行阶段确定函数地址
动态多态满足条件 1、有继承关系
2、子类重写父类的虚函数
动态多态使用： 父类的指针或者引用 执行子类对象
重写：函数返回值类型 函数名 参数列表 完全一致称为重写
#include &lt;iostream&gt; using namespace std; #include&lt;string&gt; //多态 //动物类 class Animal { public: //虚函数 virtual void speak() { cout &lt;&lt; &#34;小动物在说话&#34; &lt;&lt; endl; } }; //重写：函数返回值类型 函数名 参数列表 完全一致称为重写 class Cat:public Animal { public: void speak() { cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/04283094bb40fd86fd5723e8331b2caf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-01T12:25:10+08:00" />
<meta property="article:modified_time" content="2023-06-01T12:25:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">c&#43;&#43;学习笔记（9）多态</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">基本概念</a></p> 
<p id="%E5%88%86%E4%B8%BA%E4%B8%A4%E7%B1%BB%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%88%86%E4%B8%BA%E4%B8%A4%E7%B1%BB%EF%BC%9A" rel="nofollow">分为两类：</a></p> 
<p id="%E5%8C%BA%E5%88%AB%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%8C%BA%E5%88%AB%EF%BC%9A" rel="nofollow">区别：</a></p> 
<p id="%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6" rel="nofollow">动态多态满足条件</a></p> 
<p id="%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E4%BD%BF%E7%94%A8%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E4%BD%BF%E7%94%A8%EF%BC%9A" rel="nofollow">动态多态使用：</a></p> 
<p id="%C2%A0%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%C2%A0%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A" rel="nofollow"> 多态的优点：</a></p> 
<p id="%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E5%88%A9%E7%94%A8%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8-toc" style="margin-left:0px;"><a href="#%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E5%88%A9%E7%94%A8%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8" rel="nofollow">案例一：利用多态实现计算器</a></p> 
<p id="%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB" rel="nofollow">纯虚函数和抽象类</a></p> 
<p id="%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%88%B6%E4%BD%9C%E9%A5%AE%E5%93%81-toc" style="margin-left:0px;"><a href="#%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%88%B6%E4%BD%9C%E9%A5%AE%E5%93%81" rel="nofollow">案例二：制作饮品</a></p> 
<p id="%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84-toc" style="margin-left:0px;"><a href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84" rel="nofollow">虚析构和纯虚析构</a></p> 
<p id="%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84%E5%85%B1%E6%80%A7%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84%E5%85%B1%E6%80%A7%EF%BC%9A" rel="nofollow">虚析构和纯虚析构共性：</a></p> 
<p id="%E5%8C%BA%E5%88%AB%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E5%8C%BA%E5%88%AB%EF%BC%9A" rel="nofollow">区别：</a></p> 
<p id="%E8%99%9A%E6%9E%90%E6%9E%84%E8%AF%AD%E6%B3%95%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E8%99%9A%E6%9E%90%E6%9E%84%E8%AF%AD%E6%B3%95%EF%BC%9A" rel="nofollow">虚析构语法：</a></p> 
<p id="%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84%E8%AF%AD%E6%B3%95%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84%E8%AF%AD%E6%B3%95%EF%BC%9A" rel="nofollow">纯虚析构语法：</a></p> 
<p id="%E6%80%BB%E7%BB%93%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%E6%80%BB%E7%BB%93%EF%BC%9A" rel="nofollow">总结：</a></p> 
<p id="%E6%A1%88%E4%BE%8B%E4%B8%89%20%E7%94%B5%E8%84%91%E7%BB%84%E8%A3%85-toc" style="margin-left:0px;"><a href="#%E6%A1%88%E4%BE%8B%E4%B8%89%20%E7%94%B5%E8%84%91%E7%BB%84%E8%A3%85" rel="nofollow">案例三 电脑组装</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</h2> 
<p>c++面向对象三大特性之一</p> 
<h3 id="%E5%88%86%E4%B8%BA%E4%B8%A4%E7%B1%BB%EF%BC%9A">分为两类：</h3> 
<p>静态多态：函数重载和运算符重载属于静态多态，复用函数名</p> 
<p>动态多态：派生类和虚函数实现运行时多态</p> 
<h3 id="%E5%8C%BA%E5%88%AB%EF%BC%9A">区别：</h3> 
<p>静态多态的函数地址早绑定 编译阶段确定函数地址</p> 
<p>动态多态的函数地址晚绑定，运行阶段确定函数地址</p> 
<h3 id="%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E6%BB%A1%E8%B6%B3%E6%9D%A1%E4%BB%B6">动态多态满足条件</h3> 
<p>1、有继承关系</p> 
<p>2、子类重写父类的虚函数</p> 
<h3 id="%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81%E4%BD%BF%E7%94%A8%EF%BC%9A">动态多态使用：</h3> 
<p>父类的指针或者引用 执行子类对象</p> 
<p>重写：函数返回值类型 函数名 参数列表 完全一致称为重写</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
//多态
//动物类
class Animal {
public:
	//虚函数
	virtual void speak() {
		cout &lt;&lt; "小动物在说话" &lt;&lt; endl;
	}
};
//重写：函数返回值类型 函数名 参数列表 完全一致称为重写
class Cat:public Animal {
public:

	void speak() {
		cout &lt;&lt; "小猫在说话" &lt;&lt; endl;
	}
};
//地址早绑定，在编译阶段就确定函数地址
//动态多态满足条件

//1、有继承关系

//2、子类重写父类的虚函数
//动态多态使用：父类的指针或者引用 执行子类对象
void dospeak(Animal &amp;animal) {
	animal.speak();
}
//如果想执行猫说话，地址就不能早绑定，需要在运行阶段进行绑定，在父类中加入virtual，改为虚函数
void test() {
	Cat cat;
	dospeak(cat);
}
int main() {
	test();
	system("pause");
	
	return 0;
}</code></pre> 
<p>复习，只有非静态成员变量存储于类，静态函数和成员，非静态函数都不存储于类</p> 
<p><img alt="" height="612" src="https://images2.imgbox.com/56/19/DRmcXguo_o.png" width="1200"></p> 
<h2 id="%C2%A0%E5%A4%9A%E6%80%81%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"> 多态的优点：</h2> 
<p>1 代码组织结构清晰</p> 
<p>2 可读性强</p> 
<p>3 利于前期和后期的扩展以及维护</p> 
<p> 在真实开发中，提倡开闭原则：对扩展进行开放，对修改进行关闭</p> 
<p>c++开发提倡利用多态设计程序架构</p> 
<h2 id="%E6%A1%88%E4%BE%8B%E4%B8%80%EF%BC%9A%E5%88%A9%E7%94%A8%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E8%AE%A1%E7%AE%97%E5%99%A8">案例一：利用多态实现计算器</h2> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
//利用多态实现计算器
//抽象计算器基类
class AbstractCaculator {
public:
	virtual int getResult() {
		return 0;
	}
	int m_a;
	int m_b;
};
class Addcaculator :public AbstractCaculator {
	int getResult() {
		return m_a + m_b;
	}
};
class Subcaculator :public AbstractCaculator {
	int getResult() {
		return m_a - m_b;
	}
};
class Mulcaculator :public AbstractCaculator {
	int getResult() {
		return m_a * m_b;
	}
};
void test01() {
	AbstractCaculator* abc = new Addcaculator;
	abc-&gt;m_a = 100;
	abc-&gt;m_b = 20;
	int result = abc-&gt;getResult();
	cout &lt;&lt; result &lt;&lt; endl;
}
int main() {
	test01();
	system("pause");
	
	return 0;
}</code></pre> 
<h2 id="%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB">纯虚函数和抽象类</h2> 
<p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容，因此可以将虚函数改为纯虚函数</p> 
<p>纯虚函数语法： virtual 返回值类型 函数名 （参数列表）=0；</p> 
<p>当类中有了纯虚函数，这个类也成为抽象类</p> 
<p>抽象类特点：</p> 
<p>无法实例化对象</p> 
<p>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
// 抽象类 无法实例化对象
class Base {
public:
	virtual void func() = 0;
};
class Son :public Base {
public:
	virtual void func() {
		cout &lt;&lt; "func函数的调用" &lt;&lt; endl;
	}
};
void test01() {
	//Base a; 报错，抽象类 无法实例化对象
	//new Base;报错，抽象类 无法实例化对象
	Base* son = new Son;
	son-&gt;func();
	delete son;
}
int main() {
	test01();
	system("pause");
	
	return 0;
}</code></pre> 
<h2 id="%E6%A1%88%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%88%B6%E4%BD%9C%E9%A5%AE%E5%93%81">案例二：制作饮品</h2> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
//多态案例2 制作饮品
class AbstractDrink {
public:
	//煮水
	virtual void Boil() = 0;
	//冲泡
	virtual void Brew() = 0;
	//倒入杯中
	virtual void PourInCup() = 0;
	//加入辅料
	virtual void PutSomething() = 0;
	void makeDrink() {
		Boil();
		Brew();
		PourInCup();
		PutSomething();

	}
};
class Coffee:public AbstractDrink {
public:
	//煮水
	virtual void Boil() {
		cout &lt;&lt; "煮农夫山泉" &lt;&lt; endl;
	}
	//冲泡
	virtual void Brew() {
		cout &lt;&lt; "冲咖啡" &lt;&lt; endl;
	}
	//倒入杯中
	virtual void PourInCup() {
		cout &lt;&lt; "倒入咖啡杯" &lt;&lt; endl;
	}
	//加入辅料
	virtual void PutSomething() {
		cout &lt;&lt; "倒入糖和牛奶" &lt;&lt; endl;
	}
};
class Tea :public AbstractDrink {
public:
	//煮水
	virtual void Boil() {
		cout &lt;&lt; "煮矿泉水" &lt;&lt; endl;
	}
	//冲泡
	virtual void Brew() {
		cout &lt;&lt; "冲茶叶" &lt;&lt; endl;
	}
	//倒入杯中
	virtual void PourInCup() {
		cout &lt;&lt; "倒入茶杯" &lt;&lt; endl;
	}
	//加入辅料
	virtual void PutSomething() {
		cout &lt;&lt; "放入柠檬片" &lt;&lt; endl;
	}
};
//制作函数
void dowork(AbstractDrink * abs) {

	abs-&gt;makeDrink();
	delete abs;
}
void test01() {
	//制作咖啡
	dowork(new Coffee);
	cout &lt;&lt; "-----------------------" &lt;&lt; endl;
	//制作茶
	dowork(new Tea);

}
int main() {
	test01();
	system("pause");
	
	return 0;
}</code></pre> 
<h2 id="%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84">虚析构和纯虚析构</h2> 
<p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码，导致子类如果有堆区属性，出现内存泄漏现象</p> 
<p>解决方式：将父类中的析构函数改为虚析构或纯虚析构</p> 
<h3 id="%E8%99%9A%E6%9E%90%E6%9E%84%E5%92%8C%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84%E5%85%B1%E6%80%A7%EF%BC%9A">虚析构和纯虚析构共性：</h3> 
<p>可以解决父类指针释放子类对象</p> 
<p>都需要有具体的函数实现</p> 
<h3>区别：</h3> 
<p>如果是纯虚析构，该类属于抽象类，无法实例化对象</p> 
<h3 id="%E8%99%9A%E6%9E%90%E6%9E%84%E8%AF%AD%E6%B3%95%EF%BC%9A">虚析构语法：</h3> 
<p>virtual ~类名（）{}</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
class Animal {
public:
	Animal() {
		cout &lt;&lt; "animal构造函数调用" &lt;&lt; endl;
	}
	//利用虚析构解决父类指针释放子类对象释放不干净的问题
	virtual~Animal() {
		cout &lt;&lt; "animal虚析构函数调用" &lt;&lt; endl;
	}
	//纯虚函数
	virtual void speak() = 0;

};
class Cat :public Animal {
public:
	Cat(string name) {
		cout &lt;&lt; "cat构造函数调用" &lt;&lt; endl;
		m_name = new string(name); // new，返回的是指针
	}
	 ~Cat() {
		cout &lt;&lt; "cat析构函数调用" &lt;&lt; endl;
		if (m_name != NULL) {
			delete m_name;
			m_name = NULL;
		}
	}
	virtual void speak() {
		cout &lt;&lt;*m_name&lt;&lt; "小猫在说话" &lt;&lt; endl;
	}
	string* m_name;
};
void test01() {

	Animal* animal = new Cat("tom");
	animal-&gt;speak();
	delete animal;
}
int main() {
	test01();
	system("pause");
	
	return 0;
}</code></pre> 
<h3 id="%E7%BA%AF%E8%99%9A%E6%9E%90%E6%9E%84%E8%AF%AD%E6%B3%95%EF%BC%9A">纯虚析构语法：</h3> 
<p>virtual ~类名（）=0；</p> 
<p>类名：：~类名（）{}</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
class Animal {
public:
	Animal() {
		cout &lt;&lt; "animal构造函数调用" &lt;&lt; endl;
	}
	利用虚析构解决父类指针释放子类对象释放不干净的问题
	//virtual~Animal() {
	//	cout &lt;&lt; "animal虚析构函数调用" &lt;&lt; endl;
	//}
	//纯虚析构  需要声明也需要实现
	virtual ~Animal() = 0;
	//纯虚函数
	virtual void speak() = 0;

};
//具体实现
Animal::~Animal() {
	cout &lt;&lt; "animal纯虚析构函数调用" &lt;&lt; endl;
}
class Cat :public Animal {
public:
	Cat(string name) {
		cout &lt;&lt; "cat构造函数调用" &lt;&lt; endl;
		m_name = new string(name); // new，返回的是指针
	}
	 ~Cat() {
		cout &lt;&lt; "cat析构函数调用" &lt;&lt; endl;
		if (m_name != NULL) {
			delete m_name;
			m_name = NULL;
		}
	}
	virtual void speak() {
		cout &lt;&lt;*m_name&lt;&lt; "小猫在说话" &lt;&lt; endl;
	}
	string* m_name;
};
void test01() {

	Animal* animal = new Cat("tom");
	animal-&gt;speak();
	delete animal;
}
int main() {
	test01();
	system("pause");
	
	return 0;
}</code></pre> 
<h3 id="%E6%80%BB%E7%BB%93%EF%BC%9A">总结：</h3> 
<p>虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p> 
<p>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p> 
<p>拥有纯虚析构函数的类也属于抽象类，不能实例化对象</p> 
<h2 id="%E6%A1%88%E4%BE%8B%E4%B8%89%20%E7%94%B5%E8%84%91%E7%BB%84%E8%A3%85">案例三 电脑组装</h2> 
<p>案例描述：组成部件：CPU 显卡 内存条</p> 
<p>将每个零件封装抽象基类，并提供不同厂商生产不同的零件</p> 
<p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p> 
<p>测试时组装三台不同的电脑进行工作</p> 
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
#include&lt;string&gt;
//案例 电脑组装
//抽象不同零件类
///CPU
class CPU{
public:
	virtual void caculate() = 0;
};
//显卡
class VideoCard{
public:
	virtual void display() = 0;
};
//内存条
class Memory {
public:
	virtual void storage() = 0;
};
//抽象类不能实例化，但是可以创建指针
class Computer {
public:
	Computer(CPU* cpu,VideoCard*vc,Memory*memory) {
		m_cpu = cpu;
		m_videocard = vc;
		m_memory = memory;
	}
	//提供让零件工作的接口
	void dowork() {
		m_cpu-&gt;caculate();
		m_videocard-&gt;display();
		m_memory-&gt;storage();

	}
	~Computer() {
		if (m_cpu != NULL) {
			delete m_cpu;
			m_cpu = NULL;

		}
		if (m_videocard != NULL) {
			delete m_videocard;
			m_videocard = NULL;

		}
		if (m_memory != NULL) {
			delete m_memory;
			m_memory = NULL;

		}
	}
private:
	CPU* m_cpu;
	VideoCard* m_videocard;
	Memory* m_memory;

};
//具体厂商
class IntelCpu:public CPU{
public:
	virtual void caculate() {
		cout &lt;&lt; "Intel的cpu开始计算了" &lt;&lt; endl;
	}
};
class IntelVideoCard :public VideoCard {
public:
	virtual void display() {
		cout &lt;&lt; "Intel的VideoCard开始显示了" &lt;&lt; endl;
	}
};
class InteMemory :public Memory {
public:
	virtual void storage() {
		cout &lt;&lt; "lenovo的Memory开始存储了" &lt;&lt; endl;
	}
};

class lenovoCpu :public CPU {
public:
	virtual void caculate() {
		cout &lt;&lt; "lenovo的cpu开始计算了" &lt;&lt; endl;
	}
};
class lenovoVideoCard :public VideoCard {
public:
	virtual void display() {
		cout &lt;&lt; "lenovo的VideoCard开始显示了" &lt;&lt; endl;
	}
};
class lenovoMemory :public Memory {
public:
	virtual void storage() {
		cout &lt;&lt; "lenovo的Memory开始存储了" &lt;&lt; endl;
	}
};
void test01() {
	//创建3电脑
	//第一台电脑
	CPU* intelCpu = new IntelCpu;
	VideoCard* intelVedioCard = new IntelVideoCard;
	Memory* intelMemory = new InteMemory;
	Computer* computer1 = new Computer(intelCpu,intelVedioCard,intelMemory);
	computer1-&gt;dowork();
	delete computer1;
	//第二台电脑
	cout &lt;&lt; "第二台电脑" &lt;&lt; endl;
	Computer* computer2 = new Computer(new lenovoCpu,new lenovoVideoCard,new lenovoMemory);
	computer2-&gt;dowork();
	delete computer2;
	//第三台电脑
	cout &lt;&lt; "第三台电脑" &lt;&lt; endl;
	Computer* computer3 = new Computer(new IntelCpu, new lenovoVideoCard, new lenovoMemory);
	computer3-&gt;dowork();
	delete computer3;
}
int main() {
	test01();
	system("pause");
	
	return 0;
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0f6b4a2302901ec15faa2d42261cb836/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android Studio Flamingo编译项目问题记录</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d6a1f340fff3e1528da0f692d575d5f9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql和oracle的区别有什么</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>