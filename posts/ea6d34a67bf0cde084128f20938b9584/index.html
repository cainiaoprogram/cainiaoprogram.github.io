<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>2018第九届蓝桥杯Java b组总结 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="2018第九届蓝桥杯Java b组总结" />
<meta property="og:description" content="2018年4月1日愚人节，我第一次参加了有关计算机算法类比赛“蓝桥杯”，这篇算是经验总结和题目回顾，水平有限，有不妥之处欢迎留言批评指正，也可以加QQ891465170交流~ 下面进入正题： 第一题：第几天 2000年的1月1日，是那一年的第1天。 那么，2000年的5月4日，是那一年的第几天？ 注意：需要提交的是一个整数，不要填写任何多余内容。
哈哈这激动的啊，太简单直接脑算，结果坑爹了，我把闰年二月记成28天普通年29天，直接错了，送分题都没拿到。
解法：2000年是闰年二月有29天，一月和三月有31天，四月有30天，所以： 31&#43;29&#43;31&#43;30&#43;4=125 第二题：方格记数 如图p1.png所示，在二维平面上有无数个1x1的小方格。 我们以某个小方格的一个顶点为圆心画一个半径为1000的圆。 你能计算出这个圆里有多少个完整的小方格吗？ 注意：需要提交的是一个整数，不要填写任何多余内容。
这个题不太会做，计算出这个圆的内接正方形编成为1000sqrt(2)=1414,正方形中方格个数为14141414，关键在于正方形外不会计算。
第三题：复数幂 设i为虚数单位。对于任意正整数n，(2&#43;3i)^n 的实部和虚部都是整数。 求 (2&#43;3i)^123456 等于多少？ 即(2&#43;3i)的123456次幂，这个数字很大，要求精确表示。 答案写成 &#34;实部±虚部i&#34;
的形式，实部和虚部都是整数（不能用科学计数法表示），中间任何地方都不加空格，实部为正时前面不加正号。(2&#43;3i)^2 写成: -5&#43;12i，
(2&#43;3i)^5 的写成: 122-597i
注意：需要提交的是一个很庞大的复数，不要填写任何多余内容。
这个好办，写段程序，把实部和虚部存储，连乘123456次，即循环123456次。
public class T3 { public static void main(String[] args) { int a = 2, b = 3; for(int i = 1; i&lt;123456; i&#43;&#43;){ int temp = 2*a-3*b; b = 3*a&#43;2*b; a = temp; } System.out.println(a&#43;&#34;&#43;&#34;&#43;b&#43;&#34;i&#34;); } } 答案：13483137&#43;1100011648i 这题更正一下，由于是大数运算使用int类型当然是不行的，哎，第一次遇到这么大数运算也是无奈，使用BigInteger类型。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ea6d34a67bf0cde084128f20938b9584/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-02T12:28:41+08:00" />
<meta property="article:modified_time" content="2018-04-02T12:28:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">2018第九届蓝桥杯Java b组总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="article fmt article__content"> 
 <blockquote>
   2018年4月1日愚人节，我第一次参加了有关计算机算法类比赛“蓝桥杯”，这篇算是经验总结和题目回顾，水平有限，有不妥之处欢迎留言批评指正，也可以加QQ891465170交流~ 
  <br>下面进入正题： 
 </blockquote> 
 <hr> 
 <h3>第一题：第几天</h3> 
 <blockquote>
   2000年的1月1日，是那一年的第1天。 那么，2000年的5月4日，是那一年的第几天？ 
  <p>注意：需要提交的是一个整数，不要填写任何多余内容。</p> 
 </blockquote> 
 <p>哈哈这激动的啊，太简单直接脑算，结果坑爹了，我把闰年二月记成28天普通年29天，直接错了，送分题都没拿到。</p> 
 <blockquote>
   解法：2000年是闰年二月有29天，一月和三月有31天，四月有30天，所以： 
  <br>31+29+31+30+4=125 
 </blockquote> 
 <hr> 
 <h3>第二题：方格记数</h3> 
 <blockquote>
   如图p1.png所示，在二维平面上有无数个1x1的小方格。 
  <p>我们以某个小方格的一个顶点为圆心画一个半径为1000的圆。 你能计算出这个圆里有多少个完整的小方格吗？ </p> 
  <p>注意：需要提交的是一个整数，不要填写任何多余内容。<br><span class="img-wrap"><img src="https://images2.imgbox.com/e2/69/wneYHiq0_o.png" alt="图片描述" title="图片描述"></span></p> 
 </blockquote> 
 <p>这个题不太会做，计算出这个圆的内接正方形编成为1000<em>sqrt(2)=1414,正方形中方格个数为1414</em>1414，关键在于正方形外不会计算。</p> 
 <h3>第三题：复数幂</h3> 
 <blockquote>
   设i为虚数单位。对于任意正整数n，(2+3i)^n 的实部和虚部都是整数。 求 (2+3i)^123456 等于多少？ 
  <br>即(2+3i)的123456次幂，这个数字很大，要求精确表示。 
  <p>答案写成 "实部±虚部i"<br>的形式，实部和虚部都是整数（不能用科学计数法表示），中间任何地方都不加空格，实部为正时前面不加正号。(2+3i)^2 写成: -5+12i，<br>(2+3i)^5 的写成: 122-597i</p> 
  <p>注意：需要提交的是一个很庞大的复数，不要填写任何多余内容。</p> 
 </blockquote> 
 <p>这个好办，写段程序，<strong>把实部和虚部存储，连乘123456次，即循环123456次</strong>。</p> 
 <pre><code>public class T3 {

    public static void main(String[] args) {
        int a = 2, b = 3;
        
        for(int i = 1; i&lt;123456; i++){
            int temp = 2*a-3*b;
            b = 3*a+2*b;
            a = temp;
        }
        System.out.println(a+"+"+b+"i");
    }

}
</code></pre> 
 <blockquote>
   答案：13483137+1100011648i 
 </blockquote> 
 <hr> 
 <p>这题更正一下，由于是大数运算使用int类型当然是不行的，哎，第一次遇到这么大数运算也是无奈，使用BigInteger类型。</p> 
 <pre><code>import java.math.BigInteger;

public class T3 {

    public static void main(String[] args) {
         BigInteger a = new BigInteger("2");
         BigInteger b = new BigInteger("3");
         BigInteger a1 = new BigInteger("2");
         BigInteger b1 = new BigInteger("3");
         BigInteger temp;
        for(int i = 1; i&lt;123456; i++){
            temp = a.multiply(a1).subtract(b.multiply(b1));
            b = a.multiply(b1).add(b.multiply(a1));
            a = temp;
        }
        if(b.compareTo(BigInteger.valueOf(0))&gt;0){
            System.out.println(a+"+"+b+"i");
        }else{
        System.out.println(a+""+b+"i");
        }
    }

}

</code></pre> 
 <hr> 
 <p>如果在eclipse中输出会得到一个--i的东西，是一个 超长字符串，使用cmd控制台输出结果为：感受一下吧~<br><span class="img-wrap"><img src="https://images2.imgbox.com/ea/4e/qDwfASdB_o.png" alt="图片描述" title="图片描述"></span></p> 
 <hr> 
 <h3>第四题：测试次数</h3> 
 <blockquote>
   x星球的居民脾气不太好，但好在他们生气的时候唯一的异常举动是：摔手机。 
  <br>各大厂商也就纷纷推出各种耐摔型手机。x星球的质监局规定了手机必须经过耐摔测试，并且评定出一个耐摔指数来，之后才允许上市流通。 
  <p>x星球有很多高耸入云的高塔，刚好可以用来做耐摔测试。塔的每一层高度都是一样的，与地球上稍有不同的是，他们的第一层不是地面，而是相当于我们的2楼。</p> 
  <p>如果手机从第7层扔下去没摔坏，但第8层摔坏了，则手机耐摔指数=7。 特别地，如果手机从第1层扔下去就坏了，则耐摔指数=0。<br>如果到了塔的最高层第n层扔没摔坏，则耐摔指数=n</p> 
  <p>为了减少测试次数，从每个厂家抽样3部手机参加测试。</p> 
  <p>某次测试的塔高为1000层，如果我们总是采用最佳策略，在最坏的运气下最多需要测试多少次才能确定手机的耐摔指数呢？</p> 
  <p>请填写这个最多测试次数。</p> 
  <p>注意：需要填写的是一个整数，不要填写任何多余内容。</p> 
 </blockquote> 
 <p>这个也简单，使用二分查找，最坏情况是1000层也不坏<br>二分查找算法代码如下：</p> 
 <pre><code>public class T4 {

    public static void main(String[] args) {
        
        int x = 0, y=1000;
        int m = 0,count=0;
        while(y-x&gt;1){
            m = x+(y-x)/2;
            if(m&lt;1000) x = m;
            else y = m;
            count++;
        }
        System.out.println(count);
    }

}
</code></pre> 
 <blockquote>
   答案：10 
 </blockquote> 
 <hr> 
 <h3>第五题：快速排序</h3> 
 <blockquote>
   以下代码可以从数组a[]中找出第k小的元素。 
  <p>它使用了类似快速排序中的分治算法，期望时间复杂度是O(N)的。</p> 
  <p>请仔细阅读分析源码，填写划线部分缺失的内容。</p> 
  <p>注意：只提交划线部分缺少的代码，不要抄写任何已经存在的代码或符号。</p> 
 </blockquote> 
 <pre><code>import java.util.Random;
public class Main{
    public static int quickSelect(int a[], int l, int r, int k) {
        Random rand = new Random();
        int p = rand.nextInt(r - l + 1) + l;
        int x = a[p];
        int tmp = a[p]; a[p] = a[r]; a[r] = tmp;
        int i = l, j = r;
        while(i &lt; j) {
                    while(i &lt; j &amp;&amp; a[i] &lt; x) i++;
                    if(i &lt; j) {
                            a[j] = a[i];
                            j--;
                    }
                    while(i &lt; j &amp;&amp; a[j] &gt; x) j--;
                    if(i &lt; j) {
                            a[i] = a[j];
                            i++;
                    }
            }
            a[i] = x;
            p = i;
            if(i - l + 1 == k) return a[i];
            if(i - l + 1 &lt; k) return quickSelect( _________________________________ ); //填空
            else return quickSelect(a, l, i - 1, k);    
    }
    public static void main(String args[]) {
        int [] a = {1, 4, 2, 8, 5, 7};
        System.out.println(quickSelect(a, 0, 5, 4));
    }
}
</code></pre> 
 <blockquote>
   一个分治法进行快速排序 分治法三步 
  <br>1.将问题分成尽量左右相等的左右两半 
  <br>2.递归求解左右两半 
  <br>3.合并左右两半问题和当前问题比较 熟悉的话一眼看出，这个也简单 
  <p>答案：a,i,r,k</p> 
 </blockquote> 
 <hr> 
 <h3>第六题：递增三元组</h3> 
 <blockquote> 
  <p>给定三个整数数组 A = [A1, A2, ... AN], B = [B1, B2, ... BN], C = [C1, C2,<br>... CN]， 请你统计有多少个三元组(i, j, k) 满足：</p> 
  <ol><li>1 &lt;= i, j, k &lt;= N</li><li>Ai &lt; Bj &lt; Ck</li></ol> 
  <p>【输入格式】 第一行包含一个整数N。 第二行包含N个整数A1, A2, ... AN。 第三行包含N个整数B1, B2, ... BN。<br>第四行包含N个整数C1, C2, ... CN。</p> 
  <p>对于30%的数据，1 &lt;= N &lt;= 100 <br>对于60%的数据，1 &lt;= N &lt;= 1000 <br>对于100%的数据，1 &lt;= N &lt;=<br>100000 0 &lt;= Ai, Bi, Ci &lt;= 100000 </p> 
  <p>【输出格式】 一个整数表示答案</p> 
  <p>【输入样例】 <br>3<br>1 1 1<br>2 2 2<br>3 3 3</p> 
  <p>【输出样例】<br>27 </p> 
  <p>资源约定： 峰值内存消耗（含虚拟机） &lt; 256M CPU消耗 &lt; 1000ms</p> 
  <p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。 所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。<br>不要使用package语句。不要使用jdk1.7及以上版本的特性。 主类的名字必须是：Main，否则按无效代码处理。</p> 
 </blockquote> 
 <p>这个题我就比较坑了，程序设计</p> 
 <p><strong>暴力求解做法</strong></p> 
 <pre><code>int count = 0;
for(int i = 0; i&lt;n; i++){
    for(int j = 0; j&lt;n; j++){
        for(int k = 0; k&lt;n; k++){
            if(a[i]&lt;b[j] &amp;&amp; b[j]&lt;c[k]) count++;
        }
    }
}
</code></pre> 
 <p><strong>时间复杂度为O(n^3),必定超时!</strong><br>我的思路使用<strong>子列生成算法</strong>，<strong>使用增量法生成长度为3的子列</strong>。<br>假设数组A,B,C已经构造完成</p> 
 <pre><code>public class Main{
    public void static main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int tlength = 0;
        int[] tuple = new int[n*3];
        int[] temp = new int[n*3];
        int[] count = {0};  //记录有多设个满足条件的三元组
        
        //根据输入构造ABC
        ...
        //构造一个下标数组{0，0，0，1，1，1，2，2，2,...,n-1,n-1,n-1}
        for(int i = 0; i&lt;n; i++){
            for(int j = 0; j&lt;3; j++){
                tuple[count++] = i;
            }
        }
        printSet(A,B,C,tuple,temp,count,0,n*3);
    }
    //增量法枚举长度为3的子列并判断条件
    public static void printSet(int[]a, int[]b, int[]c, int[]tuple,int[]temp,int[]count,int cur, int n){
        if(cur&gt;3) return;
        if(cur==3){
            if(a[tuple[[temp[0]]]&lt;b[tuple[[temp[1]]]&amp;&amp;b[tuple[[temp[1]]]&lt;c[tuple[temp[2]]]) count[0]++;
        }
        int s = cur!=0?temp[cur-1]+1:0;
        for(int i = s; s&lt;n; i++){
            temp[cur] = i;
            printSet(a,b,c,tuple,temp,count,cur+1,n);
        }                       
    }
}</code></pre> 
 <p>时间复杂度：O(nlogn)<br>悲剧的是debug好久答案不正确，经验不足，时间比较紧张，导致后面几道题时间不够。</p> 
 <hr> 
 <h3>第七题：螺旋折线</h3> 
 <blockquote>
   如图所示的螺旋折线经过平面上所有整点恰好一次。 对于整点(X, Y)，我们定义它到原点的距离dis(X, 
  <br>Y)是从原点到(X, Y)的螺旋折线段的长度。 
  <p>例如dis(0, 1)=3, dis(-2, -1)=9 </p> 
  <p>给出整点坐标(X, Y)，你能计算出dis(X, Y)吗？</p> 
  <p>【输入格式】 X和Y </p> 
  <p>对于40%的数据，-1000 &lt;= X, Y &lt;= 1000<br>对于70%的数据，-100000 &lt;= X， Y &lt;= 100000 <br>对于100%的数据, -1000000000 &lt;= X, Y &lt;= 1000000000 </p> 
  <p>【输出格式】 输出dis(X, Y) </p> 
  <p>【输入样例】 0 1</p> 
  <p>【输出样例】 3</p> 
  <p>资源约定： 峰值内存消耗（含虚拟机） &lt; 256M CPU消耗 &lt; 1000ms</p> 
  <p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。</p> 
  <p>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。 不要使用&gt; package语句。不要使用jdk1.7及以上版本的特性。<br>主类的名字必须是：Main，否则按无效代码处理。<br><span class="img-wrap"><img src="https://images2.imgbox.com/1c/08/77JC4wbL_o.png" alt="图片描述" title="图片描述"></span></p> 
 </blockquote> 
 <p>观察后不难发现，可以看成每一步走一个折线，奇数步左上（x-n,y）(x-n,y+n),偶数步右下（x+n,y）(x+n,y-n),n为步数，在走的过程中判断最后加一个统计变量即可</p> 
 <pre><code>import java.util.Scanner;

public class T7 {

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int x = sc.nextInt();
        int y = sc.nextInt();
        boolean ok = false;
        int x1 = 0, y1 = 0,m=0,count=0;
        
        while(!ok){
            if(x1==x&amp;&amp;y1==y){
                ok = true;
                break;
            }
            m++;
            if(m%2==1){//奇数步
                for(int i = 0; i&lt;m; i++){
                    if(x1==x&amp;&amp;y1==y){
                        ok = true;
                        break;
                    }
                    x1-=1;
                    count++;
                }
                for(int i = 0;i&lt;m;i++){
                    if(x1==x&amp;&amp;y1==y){
                        ok = true;
                        break;
                    }
                    y1+=1;
                    count++;
                }
            }else if(m%2==0){//偶数步
                for(int i = 0; i&lt;m; i++){
                    if(x1==x&amp;&amp;y1==y){
                        ok = true;
                        break;
                    }
                    x1+=1;
                    count++;
                }
                for(int i = 0;i&lt;m;i++){
                    if(x1==x&amp;&amp;y1==y){
                        ok = true;
                        break;
                    }
                    y1-=1;
                    count++;
                }
            }
        }
        System.out.println(count);
        
    }

}

</code></pre> 
 <hr> 
 <h3>第八题：日志统计</h3> 
 <blockquote>
   小明维护着一个程序员论坛。现在他收集了一份"点赞"日志，日志共有N行。其中每一行的格式是： 
  <p>ts id </p> 
  <p>表示在ts时刻编号id的帖子收到一个"赞"。 </p> 
  <p>现在小明想统计有哪些帖子曾经是"热帖"。如果一个帖子曾在任意一个长度为D的时间段内收到不少于K个赞，小明就认为这个帖子曾是"热帖"。 </p> 
  <p>具体来说，如果存在某个时刻T满足该帖在[T, T+D)这段时间内(注意是左闭右开区间)收到不少于K个赞，该帖就曾是"热帖"。 </p> 
  <p>给定日志，请你帮助小明统计出所有曾是"热帖"的帖子编号。 </p> 
  <p>【输入格式】 第一行包含三个整数N、D和K。 以下N行每行一条日志，包含两个整数ts和id。 </p> 
  <p>对于50%的数据，1 &lt;= K &lt;= N &lt;= 1000 <br>对于100%的数据，1 &lt;= K &lt;= N &lt;= 100000<br>0 &lt;= ts&lt;= 100000 0 &lt;= id &lt;= 100000 </p> 
  <p>【输出格式】 按从小到大的顺序输出热帖id。每个id一行。 </p> 
  <p>【输入样例】 7 10 2<br> 0 1 <br> 0 10 <br> 10 10 <br> 10 1 <br> 9 1 <br> 100 3 <br> 100 3 </p> 
  <p>【输出样例】 1 3 </p> 
  <p>资源约定： 峰值内存消耗（含虚拟机） &lt; 256M CPU消耗 &lt; 1000ms</p> 
  <p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。</p> 
  <p>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。 不要使用package语句。不要使用jdk1.7及以上版本的特性。<br>主类的名字必须是：Main，否则按无效代码处理。</p> 
 </blockquote> 
 <p>也不难,获取日志数组，构造HashMap统计最后判断满足k输出即可.<br>这里代码不在贴出。</p> 
 <hr> 
 <h3>第九题：全球变暖</h3> 
 <blockquote>
   你有一张某海域NxN像素的照片，"."表示海洋、"#"表示陆地，如下所示： 
  <p>....... .##.... .##.... ....##. ..####. ...###. .......</p> 
  <p>其中"上下左右"四个方向上连在一起的一片陆地组成一座岛屿。例如上图就有2座岛屿。 </p> 
  <p>由于全球变暖导致了海面上升，科学家预测未来几十年，岛屿边缘一个像素的范围会被海水淹没。具体来说如果一块陆地像素与海洋相邻(上下左右四个相邻像素中有海洋)，它就会被淹没。</p> 
  <p>例如上图中的海域未来会变成如下样子：</p> 
  <p>....... ....... ....... ....... ....#.. ....... .......</p> 
  <p>请你计算：依照科学家的预测，照片中有多少岛屿会被完全淹没。 </p> 
  <p>【输入格式】 第一行包含一个整数N。 (1 &lt;= N &lt;= 1000) 以下N行N列代表一张海域照片。 </p> 
  <p>照片保证第1行、第1列、第N行、第N列的像素都是海洋。 </p> 
  <p>【输出格式】 一个整数表示答案。</p> 
  <p>【输入样例】 7 <br>.......<br>.##.... <br>.##.... <br>....##.<br>..####.<br>...###.<br>....... </p> 
  <p>【输出样例】 1 </p> 
  <p>资源约定： 峰值内存消耗（含虚拟机） &lt; 256M CPU消耗 &lt; 1000ms</p> 
  <p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。</p> 
  <p>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。 不要使用package语句。不要使用jdk1.7及以上版本的特性。<br>主类的名字必须是：Main，否则按无效代码处理。</p> 
 </blockquote> 
 <p>不太会，主要基础不好，是一个图问题，对图不太熟悉，dfs算法不会写，算是基本功不行</p> 
 <hr> 
 <h3>第十题：堆的记数</h3> 
 <blockquote>
   我们知道包含N个元素的堆可以看成是一棵包含N个节点的完全二叉树。 
  <br>每个节点有一个权值。对于小根堆来说，父节点的权值一定小于其子节点的权值。 
  <p>假设N个节点的权值分别是1~N，你能求出一共有多少种不同的小根堆吗？ </p> 
  <p>例如对于N=4有如下3种：</p> 
  <p>1<br> / \<br> 2 3<br>/<br>4</p> 
  <p>1<br> / \<br> 3 2<br>/<br>4</p> 
  <p>1<br> / \<br> 2 4<br>/<br>3<br>由于数量可能超过整型范围，你只需要输出结果除以1000000009的余数。</p> 
  <p>【输入格式】 一个整数N。<br>对于40%的数据，1 &lt;= N &lt;= 1000 <br>对于70%的数据，1 &lt;= N &lt;= 10000 <br>对于100%的数据，1 &lt;= N &lt;= 100000</p> 
  <p>【输出格式】 一个整数表示答案。 </p> 
  <p>【输入样例】 4 </p> 
  <p>【输出样例】 3</p> 
  <p>资源约定： 峰值内存消耗（含虚拟机） &lt; 256M CPU消耗 &lt; 1000ms</p> 
  <p>请严格按要求输出，不要画蛇添足地打印类似：“请您输入...” 的多余内容。</p> 
  <p>所有代码放在同一个源文件中，调试通过后，拷贝提交该源码。 不要使用package语句。不要使用jdk1.7及以上版本的特性。<br>主类的名字必须是：Main，否则按无效代码处理。</p> 
 </blockquote> 
 <p>估计涉及到动态规划，没什么思路。<br><strong>后续继续跟新！</strong></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/07b90173e97f95f45342f7467db34e76/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Kotlin伴生对象与静态成员</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/be5ee712023b9edd5b633350c420e13e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">线性代数笔记8：矩阵的对角化</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>