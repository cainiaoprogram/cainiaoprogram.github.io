<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux命令详解及软件安装(全) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux命令详解及软件安装(全)" />
<meta property="og:description" content="环境搭建
环境搭建(Vmware)
账号管理
开机关机
目录管理
文件颜色
文件权限
文件操作(touch、cat、tac、more、less、grep、wc、vim)
压缩操作
磁盘管理(iostat、sar、df、du)
内存管理(free)
CPU管理(top)
进程管理(ps)
开发管理(nohup)
防火墙管理
进阶小故事之CPU深夜狂飙
进阶小故事之轻松分析定位JVM问题
交互工具
环境安装
环境搭建
第一种方式：直接安装Linux操作系统 (会替换掉现有系统)
第二种方式：本机电脑安装成双系统 (windos linux)
第三种方式：虚拟机(VMware下载(360一键安装))
[注]虚拟机搭建环境有两种方式：
a. 下载镜像进行安装
b. 可以使用他人已制作好的镜像
安装VMware虚拟机软件好后打开镜像即可使用
第四种方式：购买云服务器 (有经济来源的话可以购买阿里云服务器，因为这才是最接近公司中原生环境的)
环境搭建(Vmware)
安装Vmware
创建虚拟机
创建新的虚拟机
选择自定义（高级）
VMware建立虚拟机分为典型（快速）和自定义（高级）两种方式
选择硬件的兼容性
选择安装创建的虚拟机的操作系统
选择你所要安装的客户机操作系统
选择操作系统的版本
更改虚拟机的名称和存放的位置
选择虚拟机具备的引导设备类型
指定处理器数量
为虚拟机预设多少内存
选择虚拟机的网络类型
配置本机网络适配器环境
进入 “控制面板”——“网络和Internet”——“更改适配器设置”
选择VMnet8是配置器，右键选择“属性”，选择“Ipv4”，如下图：
配置Vm网络连接
进入虚拟网络编辑器
由于安装VMware虚拟机后是没有网络的，因此我们还需要手动对VMware虚拟机配置网络，选择虚拟机左上方的“编辑–&gt;虚拟网络编辑器”
配置虚拟网络地址
VMnet信息 （虚拟机网络信息）
桥接模式
需要依赖外部网络环境，VMware 虚拟出来的操作系统就像是局域网中的一台独立的主机，需要手工为虚拟系统配置IP地址，虚拟机的ip必须和宿主机(Windows)的ip是同一个网段。相当于虚拟机和主机就好比插在同一台交换机上的两台电脑，虚拟机需要占用一个真实ip
NAT模式
使用 NAT 模式，就是让虚拟系统借助 NAT（网络地址转换）功能，通过宿主机器所在的网络来访问公网，如果主机能够正常上网，那么虚拟机也能够直接上网。此时虚拟机处于一个新的网段内，由VMware提供的DHCP服务自动分配IP地址，然后通过VMware提供的NAT服务，共享主机实现上网, 不依赖外部网络环境
仅主机模式" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/64872eb452a158cf34c55336406ba6d7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-25T14:45:20+08:00" />
<meta property="article:modified_time" content="2023-12-25T14:45:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux命令详解及软件安装(全)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><a href="#hjdj" rel="nofollow"><font size="2" color="grey" face="宋体">环境搭建</font></a></p> 
<p><a href="#vminstallls" rel="nofollow"><font size="2" color="grey" face="宋体">环境搭建(Vmware)</font></a></p> 
<p><a href="#zhgl" rel="nofollow"><font size="2" color="grey" face="宋体">账号管理</font></a></p> 
<p><a href="#four" rel="nofollow"><font size="2" color="grey" face="宋体">开机关机</font></a></p> 
<p><a href="#ningt" rel="nofollow"><font size="2" color="grey" face="宋体">目录管理</font></a></p> 
<p><a href="#shuxingss" rel="nofollow"><font size="2" color="grey" face="宋体">文件颜色</font></a></p> 
<p><a href="#ningtt" rel="nofollow"><font size="2" color="grey" face="宋体">文件权限</font></a></p> 
<p><a href="#fivecaozuo" rel="nofollow"><font size="2" color="grey" face="宋体">文件操作(touch、cat、tac、more、less、grep、wc、vim)</font></a></p> 
<p><a href="#yasduocaozuo" rel="nofollow"><font size="2" color="grey" face="宋体">压缩操作</font></a></p> 
<p><a href="#cpgl" rel="nofollow"><font size="2" color="grey" face="宋体">磁盘管理(iostat、sar、df、du)</font></a></p> 
<p><a href="#cncpgl" rel="nofollow"><font size="2" color="grey" face="宋体">内存管理(free)</font></a></p> 
<p><a href="#cncpucpgl" rel="nofollow"><font size="2" color="grey" face="宋体">CPU管理(top)</font></a></p> 
<p><a href="#two" rel="nofollow"><font size="2" color="grey" face="宋体">进程管理(ps)</font></a></p> 
<p><a href="#kaifdaguanli" rel="nofollow"><font size="2" color="grey" face="宋体">开发管理(nohup)</font></a></p> 
<p><a href="#fhq" rel="nofollow"><font size="2" color="grey" face="宋体">防火墙管理</font></a></p> 
<p><a href="#sybg" rel="nofollow"><font size="2" color="grey" face="宋体">进阶小故事之CPU深夜狂飙</font></a></p> 
<p><a href="#jvmwt" rel="nofollow"><font size="2" color="grey" face="宋体">进阶小故事之轻松分析定位JVM问题</font></a></p> 
<p><a href="#seween" rel="nofollow"><font size="2" color="grey" face="宋体">交互工具</font></a></p> 
<p><a href="#six" rel="nofollow"><font size="2" color="grey" face="宋体">环境安装</font></a></p> 
<blockquote> 
 <p><font color="black" size="3" face="宋体"><span id="hjdj">环境搭建</span></font></p> 
</blockquote> 
<p><font face="宋体" size="2">第一种方式：直接安装Linux操作系统 (会替换掉现有系统)</font></p> 
<p><font face="宋体" size="2">第二种方式：本机电脑安装成双系统 (windos linux)</font></p> 
<p><font face="宋体" size="2">第三种方式：虚拟机(VMware下载(360一键安装))</font></p> 
<p><font face="宋体" size="2" color="grey">[注]虚拟机搭建环境有两种方式：<br> a. 下载镜像进行安装<br> b. 可以使用他人已制作好的镜像<br> 安装VMware虚拟机软件好后打开镜像即可使用</font></p> 
<p><font face="宋体" size="2">第四种方式：购买云服务器 (有经济来源的话可以购买阿里云服务器，因为这才是最接近公司中原生环境的)</font></p> 
<blockquote> 
 <p><font color="black" size="3" face="宋体"><span id="vminstallls">环境搭建(Vmware)</span></font></p> 
</blockquote> 
<ol><li> <p><font face="宋体" size="2" color="黑体">安装Vmware</font></p> <p><img src="https://images2.imgbox.com/2a/69/6HjC5iAE_o.png" alt="在这里插入图片描述"></p> </li><li> <p><font face="宋体" size="2" color="黑体">创建虚拟机</font></p> 
  <ol><li> <p><font face="宋体" size="2" color="黑体">创建新的虚拟机</font></p> </li><li> <p><font face="宋体" size="2" color="黑体">选择自定义（高级）</font></p> <p><font face="宋体" size="2">VMware建立虚拟机分为典型（快速）和自定义（高级）两种方式</font></p> </li><li> <p><font face="宋体" size="2" color="黑体">选择硬件的兼容性</font></p> </li><li> <p><font face="宋体" size="2" color="黑体">选择安装创建的虚拟机的操作系统</font></p> </li><li> <p><font face="宋体" size="2" color="黑体">选择你所要安装的客户机操作系统</font></p> </li><li> <p><font face="宋体" size="2" color="黑体">选择操作系统的版本</font></p> </li><li> <p><font face="宋体" size="2" color="黑体">更改虚拟机的名称和存放的位置</font></p> </li><li> <p><font face="宋体" size="2" color="黑体">选择虚拟机具备的引导设备类型</font></p> </li><li> <p><font face="宋体" size="2" color="黑体">指定处理器数量</font></p> </li><li> <p><font face="宋体" size="2" color="黑体">为虚拟机预设多少内存</font></p> </li><li> <p><font face="宋体" size="2" color="黑体">选择虚拟机的网络类型</font></p> </li></ol> </li><li> <p><font face="宋体" size="2" color="黑体">配置本机网络适配器环境</font></p> <p><font face="宋体" size="2">进入 “控制面板”——“网络和Internet”——“更改适配器设置”</font></p> <p><img src="https://images2.imgbox.com/b8/3d/MHQlkV6z_o.png" alt="在这里插入图片描述"></p> <p><font face="宋体" size="2">选择VMnet8是配置器，右键选择“属性”，选择“Ipv4”，如下图：</font></p> <p><img src="https://images2.imgbox.com/b2/c7/vuxynI3m_o.png" alt="在这里插入图片描述"><br> <font face="宋体" size="2"></font></p> </li><li> <p><font face="宋体" size="2" color="黑体">配置Vm网络连接</font></p> 
  <ol><li> <p><font face="宋体" size="2" color="黑体">进入虚拟网络编辑器</font></p> <p><font face="宋体" size="2">由于安装VMware虚拟机后是没有网络的，因此我们还需要手动对VMware虚拟机配置网络，选择虚拟机左上方的“编辑–&gt;虚拟网络编辑器”</font></p> <p><img src="https://images2.imgbox.com/77/93/bZJy1ePX_o.png" alt="在这里插入图片描述"></p> </li><li> <p><font face="宋体" size="2" color="黑体">配置虚拟网络地址</font></p> <p><img src="https://images2.imgbox.com/52/97/672swn5y_o.png" alt="在这里插入图片描述"></p> <p><font face="宋体" size="2" color="黑体">VMnet信息 （虚拟机网络信息）</font></p> 
    <ol><li> <p><font face="宋体" size="2">桥接模式</font></p> <p><font face="宋体" size="2">需要依赖外部网络环境，VMware 虚拟出来的操作系统就像是局域网中的一台独立的主机，需要手工为虚拟系统配置IP地址，虚拟机的ip必须和宿主机(Windows)的ip是同一个网段。相当于虚拟机和主机就好比插在同一台交换机上的两台电脑，虚拟机需要占用一个真实ip</font></p> </li><li> <p><font face="宋体" size="2">NAT模式</font></p> <p><font face="宋体" size="2">使用 NAT 模式，就是让虚拟系统借助 NAT（网络地址转换）功能，通过宿主机器所在的网络来访问公网，如果主机能够正常上网，那么虚拟机也能够直接上网。此时虚拟机处于一个新的网段内，由VMware提供的DHCP服务自动分配IP地址，然后通过VMware提供的NAT服务，共享主机实现上网, 不依赖外部网络环境</font></p> </li><li> <p><font face="宋体" size="2">仅主机模式</font></p> <p><font face="宋体" size="2">该模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机，当然多个虚拟机之间也可以互相访问， 但是仅主机模式虚拟机是无法上外网的</font></p> </li></ol> </li><li> <p><font face="宋体" size="2" color="黑体">修改对应的虚拟机镜像的网络环境</font></p> <p><font face="宋体" size="2">找到你需要修改的虚拟机，右键找到“设置”选项，将虚拟机的网络适配器修改为NAT模式，然后保存</font></p> <p><img src="https://images2.imgbox.com/d1/d0/mBKBedYt_o.png" alt="在这里插入图片描述"></p> </li><li> <p><font face="宋体" size="2" color="黑体">修改centos7里边配置网络环境</font></p> </li></ol> <font face="宋体" size="2"> </font></li></ol> 
<blockquote> 
 <p><font color="black" size="3" face="宋体"><span id="zhgl">账号管理</span></font></p> 
</blockquote> 
<p><font face="宋体" size="2">Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</font></p> 
<p><font face="宋体" size="2">用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。每个用户账号都拥有一个唯一的用户名和各自的口令。</font></p> 
<p><font face="宋体" size="2">用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</font></p> 
<p><font face="宋体" size="3">实现用户账号的管理，要完成的工作主要有如下三个方面：</font></p> 
<ol><li> <p><font face="宋体" size="3" color="黑体">用户账号的添加、删除、修改</font></p> 
  <ol><li> <p><font face="宋体" size="3" color="黑体">用户账号的添加(useradd)</font></p> <p><font face="宋体" size="3">添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户名、用户组、主目录和登录 Shell等资源</font></p> <pre><code class="prism language-bash"><span class="token comment">#添加账号 	</span>
<span class="token function">useradd</span> 选项 用户名
</code></pre> </li><li> <p><font face="宋体" size="3" color="黑体">用户账号的删除(userdel)</font></p> <p><font face="宋体" size="3">删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。删除命令删除用户在系统文件中（主要是/etc、/etc/shadow…）</font></p> <pre><code class="prism language-bash"><span class="token comment">#删除已有用户的时候将它的目录页一并删除</span>
<span class="token function">userdel</span> <span class="token parameter variable">-r</span> <span class="token punctuation">[</span>文件名<span class="token punctuation">]</span>						
</code></pre> </li><li> <p><font face="宋体" size="3" color="黑体">用户账号的修改(usermod)</font></p> <pre><code class="prism language-bash"><span class="token comment">#常用选项-c/d/m/g/G/s/u/o</span>
<span class="token function">usermod</span> <span class="token parameter variable">-d</span>  <span class="token punctuation">[</span>文件名<span class="token punctuation">]</span>						
</code></pre> </li></ol> </li><li> <p><font face="宋体" size="3" color="黑体">用户口令的管理(su)</font></p> <pre><code class="prism language-bash"><span class="token comment">#切换用户</span>
<span class="token function">su</span> 用户名									

<span class="token comment">#切换用户后使用新用户的工作环境</span>
<span class="token function">su</span> - 用户名									
	
<span class="token comment">#切换到root用户</span>
<span class="token function">sudo</span> <span class="token function">su</span> 									

<span class="token comment">#退回原来用户</span>
<span class="token builtin class-name">exit</span>										

<span class="token comment">#退回原来用户</span>
<span class="token builtin class-name">logout</span>										

<span class="token comment">#退回原来用户，其实也是执行的eixt命令</span>
ctrl + d										
</code></pre> </li><li> <p><font face="宋体" size="3" color="黑体">用户组的管理</font></p> <p><font face="宋体" size="3">将用户分组是Linux系统对用户进行管理及控制访问的一种手段。用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于/etc/passwd文件，由冒号(:)隔开若干个字段，这些字段有(组名：口令：组标识号：组内成员用户列表)</font></p> <p><font face="宋体" size="3">a. 组名是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样,组名不应重复</font></p> <p><font face="宋体" size="3">b. 口令字段存放的是用户组加密后的口令字。一般linux系统的用户组都没有口令，即这个字段一般为空，或者是*</font></p> <p><font face="宋体" size="3">c. 组标识号与用户标识号类似，也是一个整数，被系统内部用来标识组</font></p> <p><font face="宋体" size="3">d. 组内用户列表是属于这个组的所有用户的列表，不同用户之间用(,)分隔。这个用户组可能是用户的主组，也可能是附加组</font></p> <p><img src="https://images2.imgbox.com/88/f9/J5dbsxqj_o.png" alt="在这里插入图片描述"></p> <p><font face="宋体" size="3">每个用户都属于某个用户组，一个组中可以有多个用户，一个用户可以属于不同的组</font></p> <p><font face="宋体" size="3">当一个用户同时是多个组中成员时，在etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组，用户要访问附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员</font></p> <p><font face="宋体" size="3">完成用户的管理工作有许多办法，但是每种办法实际都是对有关系统文件进行修改</font></p> <pre><code class="prism language-bash"><span class="token comment">#创建一个用户组</span>
<span class="token function">groupadd</span> <span class="token punctuation">[</span>用户组<span class="token punctuation">]</span>							

<span class="token comment">#创建一个用户组并设置id</span>
<span class="token function">groupadd</span>  <span class="token parameter variable">-g</span> <span class="token punctuation">[</span>数字<span class="token punctuation">]</span>	<span class="token punctuation">[</span>用户组<span class="token punctuation">]</span>					

<span class="token comment">#修改旧用户名为新用户名且设置id </span>
group <span class="token parameter variable">-g</span> <span class="token punctuation">[</span>数字<span class="token punctuation">]</span> <span class="token parameter variable">-n</span> <span class="token punctuation">[</span>新用户组<span class="token punctuation">]</span> <span class="token punctuation">[</span>旧用户组<span class="token punctuation">]</span>		

<span class="token comment">#删除用户组</span>
<span class="token function">groupdel</span> <span class="token punctuation">[</span>用户组<span class="token punctuation">]</span>							

<span class="token comment">#修改用户组的组标识号</span>
<span class="token function">groupmod</span> <span class="token parameter variable">-g</span> <span class="token punctuation">[</span>数字<span class="token punctuation">]</span> 用户组						

<span class="token comment">#将旧用户组名修改为新的，并标识号改1000</span>
<span class="token function">groupmod</span> <span class="token parameter variable">-g</span> <span class="token number">1000</span> <span class="token parameter variable">-n</span> 新用户组名 旧用户组名		

<span class="token comment">#切换[root]用户组</span>
newgrp root									

<span class="token comment">#查看group文件中组信息</span>
<span class="token function">cat</span> /etc/group								

<span class="token comment">#查看所有用户信息</span>
<span class="token function">cat</span> /etc/passwd								
</code></pre> </li><li> <p><font face="宋体" size="3" color="黑体">查看系统用户信息</font></p> <p><font face="宋体" size="3">作为系统管理员，你可能经常会（在某个时候）需要查看系统中有哪些用户正在活动。有些时候，你甚至需要知道他（她）们正在做什么。本文为我们总结了4种查看系统用户信息（通过编号（ID））的方法。</font></p> 
  <ol><li> <p><font face="宋体" size="3" color="黑体">查看登录用户正在使用的进程信息(w)</font></p> <p><font face="宋体" size="3">w命令用于显示已经登录系统的用户的名称，以及他们正在做的事。该命令所使用的信息来源于/var/run/utmp文件。w命令输出的信息包括：</font></p> <p><font face="宋体" size="2">• 用户名称<br> <font face="宋体" size="2">• 用户的机器名称或tty号<br> <font face="宋体" size="2">• 远程主机地址<br> <font face="宋体" size="2">• 用户登录系统的时间<br> <font face="宋体" size="2">• 空闲时间（作用不大）<br> <font face="宋体" size="2">• 附加到tty（终端）的进程所用的时间（JCPU时间）<br> <font face="宋体" size="2">• 当前进程所用时间（PCPU时间）<br> <font face="宋体" size="2">• 用户当前正在使用的命令</font></font></font></font></font></font></font></font></p> <p><font face="宋体" size="3">w命令还可以使用以下选项</font></p> <p><font face="宋体" size="2">• -h忽略头文件信息<br> <font face="宋体" size="2">• -u显示结果的加载时间<br> <font face="宋体" size="2">• -s不显示JCPU， PCPU， 登录时间</font></font></font></p> <p><img src="https://images2.imgbox.com/5e/ea/LbStDOi4_o.png" alt="在这里插入图片描述"></p> </li><li> <p><font face="宋体" size="3" color="黑体">查看登录用户信息(who)</font></p> <p><font face="宋体" size="3">who命令用于列举出当前已登录系统的用户名称。其输出为：用户名、tty号、时间日期、主机地址。</font></p> <p><img src="https://images2.imgbox.com/57/fc/LvTuAJFT_o.png" alt="在这里插入图片描述"></p> <p><font face="宋体" size="2" color="grey">[注]使用whoami命令查看你所使用的登录名称</font></p> </li><li> <p><font face="宋体" size="3" color="黑体">查看曾经使用过系统的历史用户信息(who)</font></p> <p><font face="宋体" size="3">last命令可用于显示特定用户登录系统的历史记录。如果没有指定任何参数，则显示所有用户的历史信息。在默认情况下，这些信息（所显示的信息）将来源于/var/log/wtmp文件。该命令的输出结果包含以下几列信息：</font></p> <p><font face="宋体" size="2">• 用户名称<br> <font face="宋体" size="2">• tty设备号<br> <font face="宋体" size="2">• 历史登录时间日期<br> <font face="宋体" size="2">• 登出时间日期<br> <font face="宋体" size="2">• 总工作时间</font></font></font></font></font></p> <p><img src="https://images2.imgbox.com/99/29/dH2PxBqV_o.png" alt="在这里插入图片描述"></p> </li></ol> </li><li> <p><font face="宋体" size="3" color="黑体">用户账号授权(sudo)</font></p> <p><font face="宋体" size="3">简单的说，sudo 是一种权限管理机制，管理员可以授权于一些普通用户去执行一些 root 执行的操作，而不需要知道 root 的密码。</font></p> <p><font face="宋体" size="3">严谨些说，sudo 允许一个已授权用户以超级用户或者其它用户的角色运行一个命令。当然，能做什么不能做什么都是通过安全策略来指定的。sudo 支持插件架构的安全策略，并能把输入输出写入日志。第三方可以开发并发布自己的安全策略和输入输出日志插件，并让它们无缝的和 sudo 一起工作。默认的安全策略记录在 /etc/sudoers 文件中。而安全策略可能需要用户通过密码来验证他们自己。也就是在用户执行 sudo 命令时要求用户输入自己账号的密码。如果验证失败，sudo 命令将会退出。(注意，本文介绍的 sudo 命令运行在 ubuntu 14.04中。)</font></p> <p><font face="宋体" size="3">sudo命令还可以使用以下选项</font></p> <p><font face="宋体" size="2">• -b 在后台执行指令<br> <font face="宋体" size="2">• -h 显示帮助<br> <font face="宋体" size="2">• -H 将HOME环境变量设为新身份的HOME环境变量<br> <font face="宋体" size="2">• -k 结束密码的有效期限，也就是下次再执行sudo时便需要输入密码<br> <font face="宋体" size="2">• -l 列出目前用户可执行与无法执行的指令<br> <font face="宋体" size="2">• -p 改变询问密码的提示符号<br> <font face="宋体" size="2">• -s 执行指定的shell<br> <font face="宋体" size="2">• -u &lt;用户&gt; 以指定的用户作为新的身份。若不加上此参数，则预设以root作为新的身份<br> <font face="宋体" size="2">• -v 延长密码有效期限5分钟<br> <font face="宋体" size="2">• -V 显示版本信息<br> <font face="宋体" size="2">• -S 从标准输入流替代终端来获取密码</font></font></font></font></font></font></font></font></font></font></font></p> <p><font face="宋体" size="3">sudo 程序相关文件如下</font></p> <p><font face="宋体" size="2">• /etc/sudoers<br> <font face="宋体" size="2">• /etc/init.d/sudo<br> <font face="宋体" size="2">• /etc/pam.d/sudo<br> <font face="宋体" size="2">• /var/lib/sudo<br> <font face="宋体" size="2">• /usr/share/doc/sudo<br> <font face="宋体" size="2">• /usr/share/lintian/overrides/sudo<br> <font face="宋体" size="2">• /usr/share/bash-completion/completions/sudo<br> <font face="宋体" size="2">• /usr/bin/sudo<br> <font face="宋体" size="2">• /usr/lib/sudo</font></font></font></font></font></font></font></font></font></p> <p><font face="宋体" size="3">现在了解了这些概念后下一步是进行基本配置：</font></p> <p><font face="宋体" size="3">系统默认创建了一个名为 sudo 的组。只要把用户加入这个组，用户就具有了 sudo 的权限。<br> 至于如何把用户加入 sudo 组，您可以直接编辑 /etc/group 文件，当然您得使用一个有 sudo 权限的用户来干这件事：</font></p> <pre><code class="prism language-bash">$ <span class="token function">sudo</span> <span class="token function">vim</span> /etc/group
</code></pre> <p><font face="宋体" size="3">在 sudo 组中加入新的用户，要使用逗号分隔多个用户。</font></p> <p><img src="https://images2.imgbox.com/8d/24/R0HX7W7t_o.png" alt="在这里插入图片描述"><br> <font face="宋体" size="3">或者您可以使用 usermod 命令把用户添加到一个组中：</font></p> <pre><code class="prism language-bash">$ <span class="token function">sudo</span> <span class="token function">usermod</span> <span class="token parameter variable">-a</span> <span class="token parameter variable">-G</span> <span class="token function">sudo</span> jack
</code></pre> <p><font face="宋体" size="3">上面的设置中我们把用户 jack 添加到了 sudo 组中，所以当用户 jack 登录后就可以通过 sudo 命令以 root 权限执行命令了！</font></p> <p><font face="宋体" size="3" color="#8bb5c8">[拓展]详细配置</font></p> <p><font face="宋体" size="2">在前面的配置中我们只是把用户 jack 加入了 sudo 组，他就具有了通过 root 权限执行命令的能力。<br> 现在我们想问一下，这是怎么发生的？是时候介绍如何配置 sudo 命令了！<br> sudo 命令的配置文件为 /etc/sudoers。<br> 编辑这个文件是有单独的命令的 visudo(这个文件我们最好不要使用 vim 命令来打开)，是因为一旦你的语法写错会造成严重的后果，这个工具会替你检查你写的语法，这个文件的语法遵循以下格式：<br> who where whom command<br> 说白了就是哪个用户在哪个主机以谁的身份执行那些命令，那么这个 where, 是指允许在那台主机 ssh 连接进来才能执行后面的命令，文件里面默认给 root 用户定义了一条规则：</font></p> <pre><code class="prism language-bash">root    <span class="token assign-left variable">ALL</span><span class="token operator">=</span><span class="token punctuation">(</span>ALL:ALL<span class="token punctuation">)</span>       ALL
</code></pre> <p><font face="宋体" size="2">• root　　　　表示 root 用户<br> <font face="宋体" size="2">• ALL　　 　　表示从任何的主机上都可以执行，也可以这样 192.168.100.0/24<br> <font face="宋体" size="2">• (ALL:ALL) 　 是以谁的身份来执行，ALL:ALL 就代表 root 可以任何人的身份来执行命令<br> <font face="宋体" size="2">• ALL 　　　　表示任何命令</font></font></font></font></p> <p><font face="宋体" size="2">那么整条规则就是 root 用户可以在任何主机以任何人的身份来执行所有的命令。</font></p> <p><font face="宋体" size="2">现在我们可以回答 jack 为什么具有通过 root 权限执行命令的能力了。打开 /etc/sudoers 文件：</font></p> <p><img src="https://images2.imgbox.com/70/e8/9uMzlhHk_o.png" alt="在这里插入图片描述"></p> <p><font face="宋体" size="2">sudo 组中的所有用户都具有通过 root 权限执行命令的能力！</font></p> <p><font face="宋体" size="2">再看个例子</font></p> <pre><code class="prism language-bash">nick   <span class="token number">192.168</span>.10.0/24<span class="token operator">=</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> /usr/sbin/useradd
</code></pre> <p><font face="宋体" size="2">上面的配置只允许 nick 在 192.168.10.0/24 网段上连接主机并且以 root 权限执行 useradd 命令。</font></p> <p><font face="宋体" size="2">现在设置 sudo 时不需要输入密码</font></p> <p><font face="宋体" size="2">执行 sudo 命令时总是需要输入密码事件很不爽的事情(抛开安全性)。有些应用场景也需要在执行 sudo 时避开输入密码的交互过程。<br> 那么需要如何设置呢？其实很简单，只需要在配置行中添加 NOPASSWD: 就可以了：</font></p> <pre><code class="prism language-bash">******    <span class="token assign-left variable">ALL</span><span class="token operator">=</span><span class="token punctuation">(</span>ALL<span class="token punctuation">)</span> NOPASSWD: ALL
</code></pre> <p><font face="宋体" size="2">再试试看，是不是已经不需要输入密码了？</font></p> <p><font face="宋体" size="2">在 ubuntu 中，sudo 的日志默认被记录在 /var/log/auth.log 文件中。当我们执行 sudo 命令时，相关日志都是会被记录下来的。比如下图中显示的就是一次执行 sudo　命令的日志：</font></p> <p><img src="https://images2.imgbox.com/37/93/3VjN0tno_o.png" alt="在这里插入图片描述"></p> </li></ol> 
<blockquote> 
 <p><font color="black" size="3" face="宋体"><span id="four">开机关机</span></font></p> 
</blockquote> 
<ol><li> <p><font face="宋体" size="2" color="黑体">开机登录</font></p> <p><font face="宋体" size="2"> 方式一 : 命令行登录</font></p> <p><font face="宋体" size="2">方式二 : ssh登录</font></p> <p><font face="宋体" size="2">方式三 : 图形界面登录</font></p> <p><font size="2" color="grey">[注]开机会启动许多程序。它们在windows中叫"服务"(service),在linux中叫"守护进程"(daemon)</font></p> </li><li> <p><font face="宋体" size="2" color="黑体">关机（shutdown）</font></p> <p><font face="宋体" size="2">在Linux领域内大多用在服务器上，很少遇到关机的操作，不管是重启还是关闭系统，首先要运行sync命令，把内存中的数据同步到磁盘中.<br> 使用关机指令，可以man shutdown 来看一下帮助文档。</font></p> <pre><code class="prism language-bash"><span class="token comment">#立即关机</span>
<span class="token function">shutdown</span> <span class="token parameter variable">-h</span> now		

<span class="token comment">#计算机将在10分钟后关机</span>
<span class="token function">shutdown</span> <span class="token parameter variable">-h</span> <span class="token number">10</span>		

<span class="token comment">#10分钟后关机</span>
<span class="token function">shutdown</span> <span class="token parameter variable">-h</span> +10		

<span class="token comment">#系统会在今天20:25关机</span>
<span class="token function">shutdown</span> <span class="token parameter variable">-h</span> <span class="token number">20</span>:25	

<span class="token comment">#关机，等同于 shutdown -h now 和 poweroff</span>
<span class="token function">halt</span>	
</code></pre> </li><li> <p><font face="宋体" size="3" color="黑体">重启</font></p> <pre><code class="prism language-bash"><span class="token comment">#系统立即重启</span>
<span class="token function">shutdown</span> <span class="token parameter variable">-r</span> now		

<span class="token comment">#系统10分钟后重启</span>
<span class="token function">shutdown</span> <span class="token parameter variable">-r</span> +10		

<span class="token comment">#重启，等同于 shutdown -r now</span>
<span class="token function">reboot</span>				
</code></pre> </li></ol> 
<blockquote> 
 <p><font color="black" size="3" face="宋体"><span id="ningt">目录管理</span></font></p> 
</blockquote> 
<ol><li> <p><font size="2" face="宋体" color="黑体">目录结构</font></p> <p><font face="宋体" size="2">根目录<code>/</code>，所有的文件都挂载在这个节点下，根目录里的结构如下</font></p> <p><img src="https://images2.imgbox.com/07/b8/7PpEGBku_o.png" alt="在这里插入图片描述"></p> <p><font face="宋体" size="2"><code>ls</code>是系统目录查看命令，通过<code>ls /</code>命令查看根目录里的内容，各子目录所代表的内容如下：</font></p> <pre><code class="prism language-bash"><span class="token comment">#binshi Binary的缩写，表示二进制文件，bin目录包含了会被所有用户使用的可执行程序</span>
<span class="token builtin class-name">cd</span> /bin				

<span class="token comment">#包含于linux启动密切相关的文件</span>
<span class="token builtin class-name">cd</span> /boot				
					
<span class="token comment">#dev是Device(设备)的缩写，表示设备，它里面的子目录每一个对应一个外设，比如我们的光盘驱动器的文件就在这里面</span>
<span class="token builtin class-name">cd</span> /dev				
		
<span class="token comment">#包含系统的配置文件	</span>
<span class="token builtin class-name">cd</span> /etc
		
<span class="token comment">#用户的主目录，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的</span>
<span class="token builtin class-name">cd</span> /home				
					
<span class="token comment">#lib是Library的缩写，表示库，包含被程序所调用的库文件</span>
<span class="token builtin class-name">cd</span> /lib				
					
<span class="token comment">#这个目录一般情况下是空的，当系统非法关机后，这里就存放一些文件</span>
<span class="token builtin class-name">cd</span> /lost+found			

<span class="token comment">#媒体，可移动的外设（USB盘、SD卡）插入电脑时，Linux可以让我们通过media的子目录来访问这些外设的内容</span>
<span class="token builtin class-name">cd</span> /media				
					
<span class="token comment">#Mount的缩写，表示挂载，类似media，一般表示临时挂载一些装置</span>
<span class="token builtin class-name">cd</span> /mnt				

<span class="token comment">#这里给主机额外安装软件所摆放的目录。比如开发者安装一个ORALCE数据库则就可以放到这个目录下。默认是空的			</span>
<span class="token builtin class-name">cd</span> /opt				
					
<span class="token comment">#这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息</span>
<span class="token builtin class-name">cd</span> /proc				
					
<span class="token comment">#超级用户，root的家目录</span>
<span class="token builtin class-name">cd</span> /root				

<span class="token comment">#s就是super user的意思，这里存放的是系统管理员使用的系统管理程序</span>
<span class="token builtin class-name">cd</span> /sbin				

<span class="token comment">#service的缩写，该目录存放一些服务启动之后需要提取的数据</span>
<span class="token builtin class-name">cd</span> /srv				

<span class="token comment">#这是Linux2.6内核的一个很大的变化，该目录下安装2.6内核中新出现的一个文件系统sysfs</span>
<span class="token builtin class-name">cd</span> /sys				
					
<span class="token comment">#这个目录是用来存放一些临时文件的。用完即丢的文件</span>
<span class="token builtin class-name">cd</span> /tmp				

<span class="token comment">#这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录</span>
<span class="token builtin class-name">cd</span> /usr		

<span class="token comment">#variable的缩写，表示动态的，通常包含程序的数据，比如Log文件</span>
<span class="token builtin class-name">cd</span> /var							
</code></pre> <p><font face="宋体" size="2">这里要注意，“<code>/</code>“是根目录，”<code>~</code>“是家目录。linux存储是以挂载的方式，相当于树状的，源头就是”<code>/</code>”，也就是根目录，而每个用户都有"家"目录，也就是用户的个人目录，比如root用户的"家"目录就是<code>/root</code>，普通用户a的"家"目录就是<code>/home/a</code>。</font></p> <p><font size="2" color="grey">[注]<br> 8./etc/passwd文件是用户管理工作涉及的最重要的文件<br> 9.linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录着用户的一些基本信息，这个文件对所有用户都是可读的<br> 10./etc/passwd中每行记录用(:)分隔为7个字段，其格式和含义是<br> (用户名：口令：用户账号标识号：组标识号：注释性描述：主目录：登录xshell)<br> 11.口令中一些系统中，存放着加密后的用户口令字<br> <img src="https://images2.imgbox.com/f6/49/S0kMblCY_o.png" alt="在这里插入图片描述"></font></p> </li><li> <p><font size="2" face="宋体" color="黑体">目录增删移查命令(mkdir、rmdir、rm、mv、cp)</font></p> 
  <table><thead><tr><th><font size="2" face="宋体">命令</font></th><th><font size="2" face="宋体">描述</font></th></tr></thead><tbody><tr><td><font size="2" face="宋体">pwd</font></td><td><font size="2" face="宋体">显示当前所在的目录</font></td></tr><tr><td><font size="2" face="宋体">mkdir [new_folder]</font></td><td><font size="2" face="宋体">创建一个目录</font></td></tr><tr><td><font size="2" face="宋体">mkdir -p one/two/three</font></td><td><font size="2" face="宋体">创建多个目录</font></td></tr><tr><td><font size="2" face="宋体">rmdir dir1</font></td><td><font size="2" face="宋体">删除指定空目录，如果目录不是空的，会提示错误</font></td></tr><tr><td><font size="2" face="宋体">rm -rf dir1</font></td><td><font size="2" face="宋体">rm命令通常用于删除Linux中的文件。可以添加参数用来删除目录； <code>-f</code> 强制删除而不提示；<code>-r</code> 递归删除文件夹； <code>-i</code>向用户确认是否删除</font></td></tr><tr><td><font size="2" face="宋体">mv file one</font></td><td><font size="2" face="宋体">移动目录，file 文件移动到 one 目录下； <code>-f</code> 强制移动； <code>-u</code> 只替换已经更新过的文件</font></td></tr><tr><td><font size="2" face="宋体">cp file file_copy</font></td><td><font size="2" face="宋体">复制目录；file 是目标文件，file_copy 是拷贝出来的文件； <code>-r</code>递归拷贝</font></td></tr></tbody></table></li><li> <p><font size="2" face="宋体" color="黑体">列出命令(ls)</font></p> <pre><code class="prism language-bash"><span class="token comment">#列出目录</span>
<span class="token function">ls</span>							

<span class="token comment">#和ls -l效果一样，查看文件属性、权限，没有隐藏文件</span>
ll							

<span class="token comment">#-a参数即all，查看全部的文件，包括隐藏文件</span>
<span class="token function">ls</span> <span class="token parameter variable">-a</span>						

<span class="token comment">#-l参数,列出所有的文件，包括文件的属性和权限，没有隐藏文件</span>
<span class="token function">ls</span> <span class="token parameter variable">-l</span>						

<span class="token comment">#-a和-l的组合,列出所有文件的属性和权限，包括隐藏文件</span>
<span class="token function">ls</span> <span class="token parameter variable">-al</span>						
</code></pre> </li><li> <p><font size="2" face="宋体" color="黑体">查找命令(find)</font></p> <p><font size="2" face="宋体">find 命令用来在指定目录下查找文件，命令格式：<code>find 目录 参数 文件名称</code></font></p> <pre><code class="prism language-bash"><span class="token comment">#列出当前目录及子目录下的所有文件和文件夹，其中. 代表当前文件夹，会递归查找子文件夹</span>
<span class="token function">find</span> <span class="token builtin class-name">.</span> 		

<span class="token comment">#在/usr目录下查找FeraoRedisConfig文件夹</span>
<span class="token function">find</span> /usr <span class="token parameter variable">-name</span> <span class="token string">"FeraoRedisConfig"</span>	

<span class="token comment">#在/usr目录下查找以.txt结尾的文件名,文件名 可用文件全名或*代表不确定部分，如*.sh</span>
<span class="token function">find</span> /usr <span class="token parameter variable">-name</span> <span class="token string">"*.txt"</span>			
</code></pre> </li></ol> 
<blockquote> 
 <p><font color="black" size="3" face="宋体"><span id="shuxingss">文件颜色</span></font></p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/a7/fb/5BWtGX4r_o.png" alt="在这里插入图片描述"><br> <font size="2" face="宋体">在上图中每类颜色代表不同含义，含义如下：</font></p> 
<p><font size="2" face="宋体">• 绿色文件：执行文件，可执行的程序<br> <font size="2" face="宋体">• 红色文件：压缩文件或者包文件<br> <font size="2" face="宋体">• 蓝色文件：目录<br> <font size="2" face="宋体">• 白色文件：普通,如文本文件、配置文件、源码文件等<br> <font size="2" face="宋体">• 浅蓝色文件：链接文件，主要是使用ln命令建立的文件<br> <font size="2" face="宋体">• 红色闪烁：表示链接的文件有问题<br> <font size="2" face="宋体">• 黄色文件：表示设备文件<br> <font size="2" face="宋体">• 灰色文件：表示其他文件</font></font></font></font></font></font></font></font></p> 
<blockquote> 
 <p><font color="black" size="3" face="宋体"><span id="ningtt">文件权限</span></font></p> 
</blockquote> 
<p><font size="2" face="宋体">用户有三种不同类型的：文件所有者，同组用户、其他用户。所有者一般是文件或目录的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。</font></p> 
<p><font size="2" face="宋体">文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。</font></p> 
<p><font size="2" face="宋体">每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用<code>ls -l</code>命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。 例如：</font></p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@localhost test<span class="token punctuation">]</span><span class="token comment"># ll -al</span>

总计 316lrwxrwxrwx <span class="token number">1</span> root root     <span class="token number">11</span> <span class="token number">11</span>-22 06:58 linklog.log -<span class="token operator">&gt;</span> log2012.log
-rw-r--r-- <span class="token number">1</span> root root <span class="token number">302108</span> <span class="token number">11</span>-13 06:03 log2012.log
-rw-r--r-- <span class="token number">1</span> root root     <span class="token number">61</span> <span class="token number">11</span>-13 06:03 log2013.log
-rw-r--r-- <span class="token number">1</span> root root      <span class="token number">0</span> <span class="token number">11</span>-13 06:03 log2014.log
-rw-r--r-- <span class="token number">1</span> root root      <span class="token number">0</span> <span class="token number">11</span>-13 06:06 log2015.log
-rw-r--r-- <span class="token number">1</span> root root      <span class="token number">0</span> <span class="token number">11</span>-16 <span class="token number">14</span>:41 log2016.log
-rw-r--r-- <span class="token number">1</span> root root      <span class="token number">0</span> <span class="token number">11</span>-16 <span class="token number">14</span>:43 log2017.log

</code></pre> 
<p><font size="3" face="宋体">我们以log2012.log为例：</font></p> 
<pre><code class="prism language-bash">-rw-r--r-- <span class="token number">1</span> root root 296K <span class="token number">11</span>-13 06:03 log2012.log

</code></pre> 
<p><font size="3" face="宋体">第一列共有10个位置，第一个字符指定了文件类型(目录、文件或链接文件等等)。在通常意义上，一个目录也是一个文件。换句话说，该列为类型列。</font></p> 
<pre><code class="prism language-java">类型列				含义
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span>
<span class="token punctuation">[</span>d<span class="token punctuation">]</span>					目录

<span class="token punctuation">[</span><span class="token operator">-</span><span class="token punctuation">]</span>					非目录的文件

<span class="token punctuation">[</span>l<span class="token punctuation">]</span>					链接文档<span class="token punctuation">[</span>link file<span class="token punctuation">]</span>

<span class="token punctuation">[</span>b<span class="token punctuation">]</span>					装置文件内可供存储的接口设备<span class="token punctuation">(</span>可随机存取装置<span class="token punctuation">)</span>

<span class="token punctuation">[</span>c<span class="token punctuation">]</span>					装置文件内串行端口设备<span class="token punctuation">,</span>如键盘<span class="token punctuation">(</span>一次性读取装置<span class="token punctuation">)</span>
	
</code></pre> 
<p><font size="3" face="宋体">从第二个字符开始到第十个共9个字符，3个字符一组，分别表示了3组用户对文件或者目录的权限。</font></p> 
<p><font size="3" face="宋体">第一组[rwx]：属主权限，代表该文件的所有者拥有该文件的权限</font></p> 
<p><font size="3" face="宋体">第二组[rwx]：属组权限，代表所有者的同组用户拥有该文件的权限</font></p> 
<p><font size="3" face="宋体">第三组[rwx]：其他用户权限，代表其他用户所拥有该文件的权限</font></p> 
<p><font size="3" face="宋体">权限字符用[-]代表空许可(没有权限)、[r]代表只读(read)、[w]代表写(write)、[x]代表可执行(execute)</font></p> 
<p><font size="3" face="宋体">示例中：<code>- rw- r-- r--</code>，表示log2012.log是一个普通文件；log2012.log的属主有读写权限；与log2012.log属主同组的用户只有读权限；其他用户也只有读权限。</font></p> 
<p><font size="3" face="宋体">确定了一个文件的访问权限后，用户可以利用Linux系统提供的命令对访问权限、所有者、用户组进行变更。<br> <code>chmod</code>命令：重新设定不同的访问权限。<br> <code>chown</code>命令：更改某个文件或目录的所有者。<br> <code>chgrp</code>命令：来更改某个文件或目录的用户组。</font></p> 
<p><font size="3" face="宋体">chmod命令是非常重要的，用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。详细情况如下。</font></p> 
<p><font size="3" face="宋体" color="黑体">两种用法：</font></p> 
<p><font size="3" face="宋体">一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。</font></p> 
<p><font size="3" face="宋体">1）文字设定法:</font></p> 
<p><code>chmod [-cfvR] ［who］ ［+ | - | =］ ［mode］ 文件名</code></p> 
<p><font size="3" face="宋体">①格式：<br> chmod &lt;参数&gt; &lt;权限范围&gt;+&lt;权限设置&gt; 使权限范围内的目录或者文件具有指定的权限<br> <font size="3" face="宋体">chmod &lt;参数&gt; &lt;权限范围&gt;-&lt;权限设置&gt; 删除权限范围的目录或者文件的指定权限<br> <font size="3" face="宋体">chmod &lt;参数&gt; &lt;权限范围&gt;=&lt;权限设置&gt; 设置权限范围内的目录或者文件的权限为指定的值</font></font></font></p> 
<p><font size="3" face="宋体">②&lt;参数&gt;内容：<br> -c 当发生改变时，报告处理信息<br> -f 错误信息不输出<br> -R 处理指定目录以及其子目录下的所有文件<br> -v 运行时显示详细处理信息</font></p> 
<p><font size="3" face="宋体">③&lt;权限范围&gt;内容：<br> u ：代表用户<br> g ：代表用户组<br> o ：代表其他<br> a ：代表所有</font></p> 
<p><font size="3" face="宋体">④&lt;权限设置&gt;内容：<br> r ：读权限，用数字4表示<br> w ：写权限，用数字2表示<br> x ：执行权限，用数字1表示<br> - ：删除权限，用数字0表示<br> s ：特殊权限</font></p> 
<pre><code class="prism language-bash"><span class="token comment">#增加授予这个文件的所属者执行的权限 </span>
<span class="token comment">#chmod &lt;权限范围&gt;+&lt;权限设置&gt; file</span>
<span class="token function">chmod</span> u+x somefile

<span class="token comment">#授予所有用户这个文件的执行权</span>
<span class="token comment">#chmod &lt;权限范围&gt;+&lt;权限设置&gt; file</span>
<span class="token function">chmod</span> +x somefile
<span class="token function">chmod</span> a+x somefile

<span class="token comment">#为所有用户分配读权限</span>
<span class="token function">chmod</span> <span class="token operator">=</span>r <span class="token function">file</span>      

<span class="token comment"># 递归地给directory目录下所有文件和子目录的属主分配读的权限</span>
<span class="token function">chmod</span> <span class="token parameter variable">-R</span> u+r directory
</code></pre> 
<p><font size="3" face="宋体">2）数字设定法<br> <font size="3" face="宋体"><br> 我们必须首先了解用数字表示的属性的含义：<br> 0 表示没有权限，<br> 1 表示可执行权限，<br> 2 表示可写权限，<br> 4 表示可读权限，<br> 每种身份(owner/group/others)各自的三个权限(r/w/x)分数是需要累加的，数字设定法的一般形式为：<br> <code>chmod ［mode］ 文件名</code></font></font></p> 
<pre><code class="prism language-bash"><span class="token comment">#权限为 [rwxrwx---]</span>
<span class="token comment">#owner = r w x = 4 + 2 + 1 =7</span>
<span class="token comment">#group = r w x = 4 + 2 + 1 =7</span>
<span class="token comment">#others = - - - = 0 + 0 + 0 =0</span>
<span class="token function">chmod</span> <span class="token number">770</span> filename	

<span class="token comment">#权限为 [rwxrwxrwx]</span>
<span class="token comment">#owner = r w x = 4 + 2 + 1 =7</span>
<span class="token comment">#group = r w x = 4 + 2 + 1 =7</span>
<span class="token comment">#others = r w x = 4 + 2 + 1 =0</span>
<span class="token function">chmod</span> <span class="token number">777</span> filename	
</code></pre> 
<ol start="4"><li><font size="3" color="red">组分类</font></li></ol> 
<p><img src="https://images2.imgbox.com/8c/86/tgSU1rrg_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p><font color="black" size="3" face="宋体"><span id="fivecaozuo">文件操作</span></font></p> 
</blockquote> 
<ol><li> <p><font size="2" face="宋体" color="黑体">创建文件命令(touch)</font></p> <p><font size="2" face="宋体">命令：touch [文件名称]<br> <img src="https://images2.imgbox.com/d1/4d/QuGU6r1N_o.png" alt="在这里插入图片描述"></font></p> </li><li> <p><font size="2" face="宋体" color="黑体">浏览文件(cat、tac、more、less)</font></p> 
  <table><thead><tr><th><font size="2" face="宋体">命令</font></th><th><font size="2" face="宋体">描述</font></th><th><font size="2" face="宋体">示例</font></th></tr></thead><tbody><tr><td><font size="2" face="宋体">cat [文件名称] [辅助指令]</font></td><td><font size="2" face="宋体">一次性显示文件所有内容，更适合查看小的文件，常用辅助指令 -n，用来显示行号</font></td><td></td></tr><tr><td><font size="2" face="宋体">tac [文件名称]</font></td><td><font size="2" face="宋体">由最后一行开始显示文件内容</font></td><td></td></tr><tr><td><font size="2" face="宋体">more [文件名称]</font></td><td><font size="2" face="宋体">一页一页的显示文件内容</font></td><td></td></tr><tr><td><font size="2" face="宋体">less [文件名称]</font></td><td><font size="2" face="宋体">一页一页的显示文件内容，更适合查看大的文件，空格下翻页，pageDown、pageUp键代表翻动页面</font></td><td></td></tr><tr><td><font size="2" face="宋体">head [辅助指令] [数量] [文件名称]</font></td><td><font size="2" face="宋体">查看文件开头内容,默认文件的10行，常用辅助指令 -n，后跟数量指定展示行数</font></td><td></td></tr><tr><td><font size="2" face="宋体">tail [辅助指令] [文件名称]</font></td><td><font size="2" face="宋体">查看文件末尾内容,默认文件的结尾10行，并实时监控文件，常用辅助命令 -f 会每秒检查文件是否有更新</font></td><td><font size="2" face="宋体">tail -100f cloud-init.log</font></td></tr></tbody></table><pre><code class="prism language-bash"><span class="token comment">#【常用指令】</span>
<span class="token comment">#/ 键：进入搜索模式，此时按n键跳到下一个符合位置，按N键跳到上一个符合位置，同时也可以输入正则表达式匹配</span>
<span class="token comment">#d 键：前进半页；</span>
<span class="token comment">#u 键：后退半页；</span>
<span class="token comment">#q 键：停止读取文件，中止 less 命令；</span>
<span class="token comment">#空格键：前进一页（一个屏幕）；</span>
<span class="token comment">#b 键：后退一页；</span>
</code></pre> </li><li> <p><font size="2" face="宋体" color="黑体">快速查看文件指定内容(grep-过滤文本)</font></p> <p><font size="2" face="宋体">grep 全称是Global Regular Expression Print(全局正则表达式版本)，它的使用权限是所有用户。</font></p> <p><font size="2" face="宋体">命令：grep [指定内容] [文件名称] -[辅助指令] [–color]</font></p> <p><font size="2" face="宋体">辅助指令包含：</font></p> <p><font size="2" face="宋体">• A20 ：显示匹配行的前20行<br> <font size="2" face="宋体">• B20 ：显示匹配行的后20行<br> <font size="2" face="宋体">• C20 ：显示匹配行前后20行</font></font></font></p> </li><li> <p><font size="2" face="宋体" color="黑体">文本数据处理(sed-修改文本)</font></p> </li><li> <p><font size="2" face="宋体" color="黑体">文本数据处理(awk-处理文本)</font></p> <p><font size="2" face="宋体">awk 命令是逐行扫描文件（从第 1 行到最后一行），寻找含有目标文本的行，如果匹配成功，则会在该行上执行用户想要的操作；反之，则不对行做任何处理。</font></p> <p><font size="2" face="宋体">awk 命令的基本格式为： <code>awk [选项] '脚本命令' 文件名</code></font></p> 
  <ol><li> <p><font size="2" face="宋体" color="黑体">选项内容</font></p> 
    <table><thead><tr><th><font size="2" face="宋体">选项</font></th><th><font size="2" face="宋体">作用</font></th></tr></thead><tbody><tr><td><font size="2" face="宋体">-F fs</font></td><td><font size="2" face="宋体">指定以 fs 作为输入行的分隔符，awk 命令默认分隔符为空格或制表符</font></td></tr><tr><td><font size="2" face="宋体">-f file</font></td><td><font size="2" face="宋体">从脚本文件中读取 awk 脚本指令，以取代直接在命令行中输入指令</font></td></tr><tr><td><font size="2" face="宋体">-v var=val</font></td><td><font size="2" face="宋体">在执行处理过程之前，设置一个变量 var，并给其设备初始值为 val</font></td></tr></tbody></table></li><li> <p><font size="2" face="宋体" color="黑体">脚本命令</font></p> <p><font size="2" face="宋体">awk 的强大之处在于脚本命令，它由 2 部分组成，分别为匹配规则和执行命令，如下所示：</font></p> <p><font size="2" face="宋体"><code>'匹配规则{执行命令}'</code></font></p> <p><font size="2" face="宋体">匹配规则用来指定脚本命令可以作用到文本内容中的具体行，可以使用字符串（比如 /demo/，表示查看含有 demo 字符串的行）或者正则表达式指定。</font></p> <p><font size="2" face="宋体">另外需要注意的是，整个脚本命令是用单引号（‘’）括起，而其中的执行命令部分需要用大括号（{}）括起来。</font></p> <p><font size="2" face="宋体">在 awk 程序执行时，如果没有指定执行命令，则默认会把匹配的行输出；如果不指定匹配规则，则默认匹配文本中所有的行。</font></p> <p><font size="2" face="宋体">举个简单的例子：</font></p> <p><font size="2" face="宋体"><code>awk '/^$/ {print "Blank line"}' test.txt</code></font></p> <p><font size="2" face="宋体">在此命令中，/^$/ 是一个正则表达式，功能是匹配文本中的空白行，同时可以看到，执行命令使用的是 print 命令，此命令经常会使用，它的作用很简单，就是将指定的文本进行输出。因此，整个命令的功能是，如果 test.txt 有 N 个空白行，那么执行此命令会输出 N 个 Blank line。</font></p> </li><li> <p><font size="2" face="宋体" color="黑体">数据字段变量</font></p> <p><font size="2" face="宋体">awk 的主要特性之一是其处理文本文件中数据的能力，它会自动给一行中的每个数据元素分配一个变量。</font></p> <p><font size="2" face="宋体">默认情况下，awk 会将如下变量分配给它在文本行中发现的数据字段：</font></p> <p><font size="2" face="宋体">• $0 代表整个文本行；<br> • $1 代表文本行中的第 1 个数据字段；<br> • $2 代表文本行中的第 2 个数据字段；<br> • $n 代表文本行中的第 n 个数据字段。</font></p> <p><font size="2" face="宋体">前面说过，在 awk 中，默认的字段分隔符是任意的空白字符（例如空格或制表符）。 在文本行中，每个数据字段都是通过字段分隔符划分的。awk 在读取一行文本时，会用预定义的字段分隔符划分每个数据字段。例如：</font></p> <pre><code class="prism language-bash"><span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># cat data2.txt</span>
One line of <span class="token builtin class-name">test</span> text.
Two lines of <span class="token builtin class-name">test</span> text.
Three lines of <span class="token builtin class-name">test</span> text.
<span class="token punctuation">[</span>root@localhost ~<span class="token punctuation">]</span><span class="token comment"># awk '{print $1}' data2.txt</span>
One
Two
Three
</code></pre> <p><font size="2" face="宋体">该程序用 $1 字段变量来表示“仅显示每行文本的第 1 个数据字段”。当然，如果你要读取采用了其他字段分隔符的文件，可以用 -F 选项手动指定。</font></p> <font size="2" face="宋体"> <font size="2" face="宋体"> <font size="2" face="宋体"> <font size="2" face="宋体"> </font></font></font></font></li></ol> </li><li> <p><font size="2" face="宋体" color="黑体">文件内容信息汇总(wc)</font></p> <p><font size="2" face="宋体">该命令统计给定文件中的字节数，字数，行数。如果没有给出文件名，则从标准输入读取.<br> <code>wc</code>同时也给出所有指定文件的总统计数。字由空格字符区分开的最大字符串。</font></p> <pre><code class="prism language-bash"><span class="token comment">#查看文件里有多少字节(统计字节数)</span>
<span class="token function">wc</span> <span class="token parameter variable">-c</span> filename	

<span class="token comment">#查看文件里有多少行(统计行数)</span>
<span class="token function">wc</span> <span class="token parameter variable">-l</span> filename	

<span class="token comment">#查看文件里有多少个word(统计字数)</span>
<span class="token function">wc</span> <span class="token parameter variable">-w</span> filename	

<span class="token comment">#文件里最长的哪一行是有多少个字</span>
<span class="token function">wc</span> <span class="token parameter variable">-L</span> filename	
</code></pre> </li><li> <p><font size="2" face="宋体" color="黑体">修改文件(vim)</font></p> <p><font size="2" face="宋体">用户刚启动vi/vim，便进入了命令模式，此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。<br> 命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</font></p> <p><font size="2" face="宋体">底线模式的启动方式是在命令模式下按<code>:</code>，底线命令模式可以输入单个或多个字符的命令，基本命令有（w）保存文件，（q）退出程序</font></p> 
  <table><thead><tr><th><font size="2" face="宋体">模式</font></th><th><font size="2" face="宋体">描述</font></th><th><font size="2" face="宋体">命令</font></th></tr></thead><tbody><tr><td><font size="2" face="宋体">命令模式</font></td><td><font size="2" face="宋体">不管用户处于何种模式，只要按下Esc键就可使进入命令行模式。</font></td><td><font size="2" face="宋体"><code>Esc</code> 进入模式； <code>i</code> 切换到输入模式;<code>:</code> 切换到底线命令模式，以在最底一行输入命令</font></td></tr><tr><td><font size="2" face="宋体">输入模式</font></td><td><font size="2" face="宋体">只有在vim编辑模式下，才能将键盘键入的内容输入到当前打开的文件中</font></td><td><font size="2" face="宋体">进入模式： <code>i</code>、<code>a</code>、<code>o</code> ；退出模式：<code>Esc</code></font></td></tr><tr><td><font size="2" face="宋体">底线命令</font></td><td><font size="2" face="宋体">同时也可以设置编辑环境和一些编译工作，如列出行号(set nu)、寻找字符串(/target)等。</font></td><td><font size="2" face="宋体">进入模式： <code>:</code>;保存并退出：<code>:wq </code>；强制退出并忽略所有更改：<code>:q!</code> ;放弃所有修改，并打开原来文件：<code>:e!</code></font></td></tr></tbody></table></li><li> <p><font size="2" face="宋体" color="黑体">文件内查找</font></p> <pre><code class="prism language-bash"><span class="token comment">#向下查找字符串 </span>
<span class="token comment">#n : 继续搜寻下一个</span>
<span class="token comment">#N : 上寻找</span>
/<span class="token punctuation">[</span>要查找的字符<span class="token punctuation">]</span>

<span class="token comment">#向上查找字符串 </span>
?<span class="token punctuation">[</span>要查找的字符<span class="token punctuation">]</span>
</code></pre> <p><font size="2" color="grey">[注]可以使用man[命令]来查看各个命令的使用文档，如 man cp网络配置目录：cd /etc/sysconfig/network-scripts (CentOS7)ifconfig查看网络配置</font></p> </li></ol> 
<blockquote> 
 <p><font size="4" color="red">软链接与硬链接</font></p> 
</blockquote> 
<ol><li> <p><font size="3" color="red">分类</font></p> <pre><code class="prism language-java">硬链接

	<span class="token class-name">A</span><span class="token operator">--</span><span class="token operator">-</span><span class="token class-name">B</span>，假设<span class="token class-name">B</span>是<span class="token class-name">A</span>的硬链接，那么他们两个指向了同一个文件，允许一个文件拥有多个路径，用户
	可以通过这种机制建立硬链接到一些重要的文件上，防止误删

软链接

	类似windows下的快捷方式，删除源文件，快捷方式也访问不了了
</code></pre> </li><li> <p><font size="3" color="red">命令</font></p> <pre><code class="prism language-java">ln	原文件 链接新文件					创建硬链接

ln	<span class="token operator">-</span>s 原文件 链接新文件				创建一个软链接<span class="token punctuation">(</span>符号链接<span class="token punctuation">)</span>

touch 新文件							创建文件

echo “字符串” <span class="token operator">&gt;&gt;</span> 文件						输入字符串
</code></pre> </li></ol> 
<blockquote> 
 <p><font color="black" size="3" face="宋体"><span id="yasduocaozuo">压缩操作</span></font></p> 
</blockquote> 
<p><font face="宋体" size="2">打包、压缩、解压常用后缀有：</font></p> 
<table><thead><tr><th><font face="宋体" size="2">文件</font></th><th><font face="宋体" size="2">扩展名</font></th></tr></thead><tbody><tr><td><font face="宋体" size="2">Windows压缩文件</font></td><td><font face="宋体" size="2">.zip/.rar</font></td></tr><tr><td><font face="宋体" size="2">linux打包文件</font></td><td><font face="宋体" size="2"> aa.tar</font></td></tr><tr><td><font face="宋体" size="2">linux压缩文件</font></td><td><font face="宋体" size="2">bb.gz</font></td></tr><tr><td><font face="宋体" size="2">linux打包并压缩文件</font></td><td><font face="宋体" size="2"> .tar.gz</font></td></tr></tbody></table> 
<ol start="6"><li> <p><font size="2" face="宋体" color="黑体">文件压缩/解压缩</font></p> <p><font size="2" face="宋体">压缩命令：tar -zcvf 压缩文件名.tar.gz 被压缩文件名<br> <font size="2" face="宋体">解压缩命令：tar -zxvf 压缩文件名.tar.gz</font></font></p> </li></ol> 
<blockquote> 
 <p><font color="black" size="3" face="宋体"><span id="cpgl">磁盘管理(iostat、sar、df、du)</span></font></p> 
</blockquote> 
<ol><li> <p><font face="宋体" size="2"><code>iostat</code>命令</font></p> <p><font face="宋体" size="2">iostat命令可以用来显示系统的磁盘和CPU使用情况。使用以下命令来查看磁盘的读写情况：<code>iostat -d</code></font></p> <p><font face="宋体" size="2">这将显示每个磁盘的平均读写速度、I/O等待时间以及CPU使用情况</font></p> </li><li> <p><font face="宋体" size="2"><code>sar</code>命令</font></p> <p><font face="宋体" size="2">sar命令是系统活动报告（System Activity Reporter）的缩写，可以用来收集和报告系统的性能数据。使用以下命令来查看磁盘的读写情况：<code>sar -d</code></font></p> <p><font face="宋体" size="2">这将显示每个磁盘的平均读写速度、I/O等待时间以及I/O请求的队列长度。</font></p> </li><li> <p><font face="宋体" size="2"><code>df</code>命令</font></p> <p><font face="宋体" size="2"> 该命令查看磁盘各个分区的空间大小、占用、可用等信息。在任意一个目录下输入df：</font></p> <p><img src="https://images2.imgbox.com/ac/64/Z6oto5SY_o.png" alt="在这里插入图片描述"></p> <p><font face="宋体" size="2">• Filesystem：表示该文件系统位于哪个分区，因此该列显示的是设备名称；<br> <font face="宋体" size="2">• Used：已用<br> <font face="宋体" size="2">• Available：可用<br> <font face="宋体" size="2">• Use%：已用百分比<br> <font face="宋体" size="2">• Mounted on：所在分区（挂载点）</font></font></font></font></font></p> <p><font face="宋体" size="2"><code>df</code>命令后可跟相关辅助指令，格式如：df [选项] [文件]</font></p> <p><font face="宋体" size="2">常用的有 <code>df -h</code>可以把内存大小单位换算为G，让信息更可读一些。-h代表human - 人类可读。</font></p> <p><img src="https://images2.imgbox.com/3a/d0/ZOYRbiyI_o.png" alt="在这里插入图片描述"></p> <p><font face="宋体" size="2">“df -i” 以inode模式来显示磁盘使用情况。</font></p> <p><font face="宋体" size="2">那么df -h 和df -i的区别是什么？同样是显示磁盘使用情况，为什么显示占用百分比相差甚远？</font></p> <p><font face="宋体" size="2">df -h的比较好解释，就是查看磁盘容量的使用情况。<br> <font face="宋体" size="2">至于df -i，先需要去理解一下inode<br> <font face="宋体" size="2">最简单的说法，inode包含的信息：文件的字节数，拥有者id，组id，权限，改动时间，链接数，数据block的位置。相反是不表示文件大小。这就是为什么df -h和df -i 显示的结果是不一样的原因。</font></font></font></p> <p><font face="宋体" size="2">ps：在df -h 和df -i 显示使用率100%，基本解决方法都是删除文件。</font></p> <p><font face="宋体" size="2">df -h 是去删除比较大无用的文件-----------大文件占用大量的磁盘容量。<br> <font face="宋体" size="2">df -i 则去删除数量过多的小文件-----------过多的文件占用了大量的inode号。</font></font></p> </li><li> <p><font face="宋体" size="2"><code>du</code>命令</font></p> <p><font face="宋体" size="2">该命令可查看该文件夹的空间占用大小，du是disk usage。要在当前目录下使用，意思就是你要查看什么文件夹就在什么文件夹上输入命令。du会展示各个目录下的占用情况，最后再给出一个总的占用情况。</font></p> <p><img src="https://images2.imgbox.com/1b/e7/DQpWZTBm_o.png" alt="在这里插入图片描述"></p> <p><font face="宋体" size="2">同理，-h转化为更可读的模式：</font></p> <p><img src="https://images2.imgbox.com/26/71/oArvInaA_o.png" alt="在这里插入图片描述"></p> <p><font face="宋体" size="2">这样一来就清楚地知道这个文件夹总共占了36G，以及各个文件夹的占用。</font></p> <p><font face="宋体" size="2">如果不想查看各个文件夹占用，直接输入du -sh：</font></p> </li></ol> 
<blockquote> 
 <p><font color="black" size="3" face="宋体"><span id="cncpgl">内存管理(free)</span></font></p> 
</blockquote> 
<ol><li> <p><font face="宋体" size="2"><code>free</code>命令</font></p> <p><font face="宋体" size="2">free命令是对 /proc/meminfo 收集到的信息的一个概述。它可以显示系统中的内存使用情况，包括总内存、已用内存、空闲内存等信息。在任意一个目录下输入<code>free</code>，通常命令后跟辅助指令 -h，表示以人类可读的方式显示内存使用情况，例如使用GB或MB的单位。</font></p> </li><li> <p><font face="宋体" size="2">cat /proc/meminfo 方式</font></p> <p><font face="宋体" size="2">查看RAM使用情况最简单的方法是通过 /proc/meminfo。这个动态更新的虚拟文件实际上是许多其他内存相关工具(如：free / ps / top)等的组合显示。/proc/meminfo列出了所有你想了解的内存的使用情况。进程的内存使用信息也可以通过 /proc//statm 和 /proc//status 来查看。</font></p> </li></ol> 
<blockquote> 
 <p><font color="black" size="3" face="宋体"><span id="cncpucpgl">CPU管理(top)</span></font></p> 
</blockquote> 
<p><font face="宋体" size="2">所有程序都共享CPU的有限资源，而由于某种原因的影响，系统应用程序就会变得缓慢或无响应，在这种情况下，我们就需要查看CPU使用率，并对其进行排查、处理，那么Linux中如何查看CPU使用率?在Linux中，可以通过以下方法查看CPU使用率。</font></p> 
<ol><li> <p><font face="宋体" size="2"><code>top</code>命令</font></p> <p><font face="宋体" size="2">实时显示process的动态，默认每隔5秒刷新，实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。</font></p> <p><font face="宋体" size="2">语法：top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]</font></p> 
  <table><thead><tr><th><font face="宋体" size="2">参数</font></th><th><font face="宋体" size="2">说明</font></th><th><font face="宋体" size="2">示例</font></th></tr></thead><tbody><tr><td><font face="宋体" size="2">-d &lt;秒数&gt;</font></td><td><font face="宋体" size="2">指定 top 命令的刷新时间间隔，单位为秒</font></td><td><font face="宋体" size="2">top -d 2</font></td></tr><tr><td><font face="宋体" size="2">-n &lt;次数&gt;</font></td><td><font face="宋体" size="2">指定 top 命令运行的次数后自动退出</font></td><td><font face="宋体" size="2"></font></td></tr><tr><td><font face="宋体" size="2">-p &lt;进程ID&gt;</font></td><td><font face="宋体" size="2">仅显示指定进程ID的信息</font></td><td><font face="宋体" size="2"> top -p 1234</font></td></tr><tr><td><font face="宋体" size="2">-u &lt;用户名&gt;</font></td><td><font face="宋体" size="2">仅显示指定用户名的进程信息</font></td><td></td></tr><tr><td><font face="宋体" size="2">-H</font></td><td><font face="宋体" size="2">在进程信息中显示线程详细信息</font></td><td></td></tr><tr><td><font face="宋体" size="2">-i</font></td><td><font face="宋体" size="2">不显示闲置（idle）或无用的进程</font></td><td></td></tr><tr><td><font face="宋体" size="2">-b</font></td><td><font face="宋体" size="2">以批处理（batch）模式运行，直接将结果输出到文件</font></td><td></td></tr><tr><td><font face="宋体" size="2">-c</font></td><td><font face="宋体" size="2">显示完整的命令行而不截断</font></td><td><font face="宋体" size="2">top -c</font></td></tr><tr><td><font face="宋体" size="2">-S</font></td><td><font face="宋体" size="2">累计显示进程的 CPU 使用时间</font></td><td></td></tr></tbody></table><p><img src="https://images2.imgbox.com/ea/fb/foOEuM6g_o.png" alt="在这里插入图片描述"></p> <p><font face="宋体" size="2">参数解释：</font></p> <p><font face="宋体" size="2">top - 00:32:08 up 150 days, 21:35, 2 users, load average: 0.91, 1.19, 1.48</font></p> 
  <table><thead><tr><th><font face="宋体" size="2">23:10:41</font></th><th><font face="宋体" size="2">系统当前时间</font></th></tr></thead><tbody><tr><td><font face="宋体" size="2">days</font></td><td><font face="宋体" size="2">系统启动后到现在的运行时间</font></td></tr><tr><td><font face="宋体" size="2">users</font></td><td><font face="宋体" size="2">当前登录到系统的用户（终端数）</font></td></tr><tr><td><font face="宋体" size="2">load average</font></td><td><font face="宋体" size="2">当前系统负载的平均值，系统在最近1分钟、5分钟、15分钟内，CPU的平均负载情况</font></td></tr></tbody></table><p><font face="宋体" size="2">Tasks: 101 total, 1 running, 97 sleeping, 3 stopped, 0 zombi</font></p> 
  <table><thead><tr><th><font face="宋体" size="2">total</font></th><th><font face="宋体" size="2">当前系统进程总数量</font></th></tr></thead><tbody><tr><td><font face="宋体" size="2">running</font></td><td><font face="宋体" size="2">当前运行中的进程数量</font></td></tr><tr><td><font face="宋体" size="2">sleeping</font></td><td><font face="宋体" size="2">当前处于等待状态中的进程数量</font></td></tr><tr><td><font face="宋体" size="2">stopped</font></td><td><font face="宋体" size="2">停止的系统进程数量</font></td></tr><tr><td><font face="宋体" size="2">zombie</font></td><td><font face="宋体" size="2">僵尸进程数量</font></td></tr></tbody></table><p><font face="宋体" size="2">%Cpu(s): 13.4 us, 1.0 sy, 0.0 ni, 84.6 id, 0.0 wa, 0.7 hi, 0.3 si, 0.0 st</font></p> 
  <table><thead><tr><th><font face="宋体" size="2">us</font></th><th><font face="宋体" size="2">用户空间占用CPU百分比，表示用户空间程序的cpu使用率，没有通过nice调度</font></th></tr></thead><tbody><tr><td><font face="宋体" size="2">sy</font></td><td><font face="宋体" size="2">内核空间占用CPU百分比，系统空间的cpu使用率，主要是内核程序</font></td></tr><tr><td><font face="宋体" size="2">ni</font></td><td><font face="宋体" size="2">用户进程空间内改变过优先级的进程占用CPU百分比，用户空间且通过nice调度过的程序的cpu使用率</font></td></tr><tr><td><font face="宋体" size="2">id</font></td><td><font face="宋体" size="2">空闲cpu，空闲CPU百分比</font></td></tr><tr><td><font face="宋体" size="2">wa</font></td><td><font face="宋体" size="2">等待输入输出的CPU时间百分比</font></td></tr><tr><td><font face="宋体" size="2">hi</font></td><td><font face="宋体" size="2">cpu处理硬中断的数量</font></td></tr><tr><td><font face="宋体" size="2">si</font></td><td><font face="宋体" size="2">cpu处理软中断的数量</font></td></tr><tr><td><font face="宋体" size="2">st</font></td><td><font face="宋体" size="2">被虚拟机偷走的cpu</font></td></tr></tbody></table><p><font face="宋体" size="2">MiB Mem : 1826.7 total, 85.9 free, 1477.8 used, 263.1 buff/cache</font></p> 
  <table><thead><tr><th><font face="宋体" size="2">total</font></th><th><font face="宋体" size="2">物理内存总量</font></th></tr></thead><tbody><tr><td><font face="宋体" size="2">free</font></td><td><font face="宋体" size="2">空闲内存总量</font></td></tr><tr><td><font face="宋体" size="2">used</font></td><td><font face="宋体" size="2">使用的物理内存总量</font></td></tr><tr><td><font face="宋体" size="2">buff/cache</font></td><td><font face="宋体" size="2">缓存，用作内核缓存的内存量</font></td></tr></tbody></table></li><li> <p><font face="宋体" size="2"><code>mpstat</code>命令</font></p> <p><font face="宋体" size="2">该命令是一个Linux系统监控命令，可以实时显示CPU使用率和其他CPU统计数据。mpstat命令默认显示所有CPU的使用情况</font></p> <p><font face="宋体" size="2">例如：<br> 02:40:01 AM CPU %user %nice %sys %iowait %irq %soft %steal %guest %idle</font></p> <p><font face="宋体" size="2">02:40:01 AM all 5.42 0.02 2.09 0.04 0.00 0.01 0.00 0.00 92.42</font></p> <p><font face="宋体" size="2">其中，%user表示用户空间程序的CPU使用率，%sys表示系统内核的CPU使用率，%idle表示CPU空闲的时间。</font></p> </li></ol> 
<blockquote> 
 <p><font color="black" size="3" face="宋体"><span id="two">进程管理(ps)</span></font></p> 
</blockquote> 
<p><font face="宋体" size="2">在Linux中，每一个正在运行的程序都有一个进程，每一个进程都有一个id号，并且每一个进程都会有一个父进程。进程的存在方式有两种：前台、后台，一般的服务都是后台进行的，基本的程序都是前台运行的。</font></p> 
<p><font face="宋体" size="2">进程管理的命令是 <code>ps</code> (进程状态的缩写)，<code>ps</code>可以显示当前运行进程的详细信息，如用户名、用户 ID、CPU 使用率、内存使用、进程启动日期时间、命令名等等。</font></p> 
<p><font face="宋体" size="2">在<code>ps</code>命令使用时通常会用到 <code>|</code> (管道符)，如 <code>A|B</code>，在A的基础上通过B过滤进程信息。比如：<br> <font face="宋体" size="2">在所有进程中查找java进程：<code>ps -aux | grep java</code> 或 <code>ps -ef | grep java</code></font></font></p> 
<p><font face="宋体" size="2">下面列出ps进程管理命令常见用法：</font></p> 
<table><thead><tr><th><font face="宋体" size="2">参数</font></th><th><font face="宋体" size="2"> 作用</font></th></tr></thead><tbody><tr><td><font face="宋体" size="2">-a</font></td><td><font face="宋体" size="2">显示当前终端运行的所有的进程信息</font></td></tr><tr><td><font face="宋体" size="2"> -u</font></td><td><font face="宋体" size="2">以用户的信息显示进程</font></td></tr><tr><td><font face="宋体" size="2"> -x</font></td><td><font face="宋体" size="2">显示后台运行的进程参数</font></td></tr><tr><td><font face="宋体" size="2">-aux</font></td><td><font face="宋体" size="2">以用户的信息显示所有进程信息，并包含进程参数</font></td></tr><tr><td><font face="宋体" size="2">-e</font></td><td><font face="宋体" size="2">显示所有进程,环境变量</font></td></tr><tr><td><font face="宋体" size="2">-f</font></td><td><font face="宋体" size="2"> 全格式</font></td></tr><tr><td><font face="宋体" size="2"> -ef</font></td><td><font face="宋体" size="2">查看全部进程且完整格式，包括命令行</font></td></tr></tbody></table> 
<p><font face="宋体" size="2">grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来</font></p> 
<pre><code class="prism language-powershell"><span class="token comment">#查看当前系统中正在执行的各种进程信息</span>
<span class="token function">ps</span>

<span class="token comment">#在所有进程中匹配符合条件的字符并列出</span>
<span class="token function">ps</span> <span class="token operator">-</span>aux<span class="token punctuation">|</span>grep mysql

<span class="token comment">#通过目录树结构查看</span>
<span class="token function">ps</span> <span class="token operator">-</span>ef<span class="token punctuation">|</span>grep mysql 

<span class="token comment">#显示进程树-p 显示父ID、-u显示用户组</span>
<span class="token function">ps</span> <span class="token operator">-</span>pu
</code></pre> 
<p><font face="宋体" size="3">杀死进程使用kill命令：</font></p> 
<pre><code class="prism language-powershell"><span class="token comment">#杀死进程，等于windows结束任务</span>
<span class="token function">kill</span> <span class="token operator">-</span>9 <span class="token punctuation">[</span>进程ID<span class="token punctuation">]</span>
</code></pre> 
<p><font size="2" color="grey">[注]1.grep 查找文件中符合条件的字符串</font></p> 
<p><font size="3" face="宋体" color="黑体">[拓展]管道命令</font></p> 
<p><font size="3" face="宋体">管道是一种通信机制，通常用于进程间的通信(也可通过socket进行网络通信)，它表现出来的形式将前面每一个进程的输出(stdout)直接作为下一个进程的输入(stdin)</font></p> 
<p><font size="3" face="宋体">管道命令使用<code>|</code>作为界定符号，管道命令与上面说的连续执行命令不一样。<br> 管道命令必须要能够接受来自前一个命令的数据成为standard input继续处理才行。且管道命令仅能处理standard output,对于standard error output会予以忽略。</font></p> 
<p><font size="3" face="宋体">管道命令有：<code>less</code>,<code>more</code>,<code>head</code>,<code>tail</code>…等等都是可以接受standard input的命令。<br> 而例如 <code>ls</code>,<code>cp</code>,<code>mv</code>并不会接受standard input的命令，所以他们就不是管道命令了。</font></p> 
<p><font size="3" face="宋体" color="黑体">[拓展]命令执行顺序控制</font></p> 
<p><font size="3" face="宋体">通常情况下，开发者在终端只能执行一条命令，然后按下回车执行，那么执行多条命令的方法怎么样的? 示例如下：</font></p> 
<pre><code class="prism language-powershell"><span class="token comment">#顺序执行多条(简单的顺序指令可以通过 ;来实现)</span>
command1<span class="token punctuation">;</span>command2<span class="token punctuation">;</span>command3<span class="token punctuation">;</span>

<span class="token comment">#有条件的执行多条命令</span>
which command1 &amp;&amp; command2 <span class="token punctuation">|</span><span class="token punctuation">|</span> command3
</code></pre> 
<p><font size="3" face="宋体">有条件的执行多条命令中符号含义：</font></p> 
<p><font size="3" face="宋体"><code>&amp;&amp;</code> : 如果前一条命令执行成功则执行下一条命令，如果command1执行成功（返回0）,则执行command2</font></p> 
<p><font size="3" face="宋体"><code>||</code> :与&amp;&amp;命令相反，执行不成功时执行这个命令</font></p> 
<p><font size="3" face="宋体"><code>$?</code>: 存储上一次命令的返回结果</font></p> 
<blockquote> 
 <p><font color="black" size="3" face="宋体"><span id="kaifdaguanli">开发管理(nohup)</span></font></p> 
</blockquote> 
<ol><li> <p><font size="2" face="宋体" color="黑体">后台运行命令(nohup)</font></p> <p><font size="2" face="宋体">该命令可以在你关闭终端之后继续运行相应的进程，nohup就是不挂起的意思( n ohang up)。</font></p> <p><font size="2" face="宋体">该命令的一般形式为：<code>nohup Command [ Arg … ] &amp; </code></font></p> <p><font size="2" face="宋体">后台程序在执行期间一般会有输出文件，在输出文件未指定即缺省情况下，后台运行的程序的所有输出都被重定向到一个名为nohup.out的文件中，除非另外指定了输出文件：</font></p> <p><font size="2" face="宋体"><code>nohup java -jar xxx.jar &gt; output1.log 2&gt;&amp;1 &amp;</code></font></p> <p><font size="2" face="宋体">在上例中有三部分结构：<code>java -jar xxx.jar</code> 、 <code>&gt; output1.log </code> 、<code>2&gt;&amp;1</code>，分别代表 Command 和 Arg组合 结构；</font></p> <p><font size="2" face="宋体">在操作系统中有三个常用的流：<br> <font size="2" face="宋体">▶0：标准输入流 stdin<br> <font size="2" face="宋体">▶1：标准输出流 stdout<br> <font size="2" face="宋体">▶2：标准错误流 stderr</font></font></font></font></p> <p><font size="2" face="宋体"> <code>&gt; output1.log</code> 是省略方式，全写为<code>1&gt;output1.log</code>，我们一般用省略方式，又或者 <code>&lt; output1.log</code> ，实际是 <code>0 &lt; output1.log</code>的省略方式</font></p> <p><font size="2" face="宋体"><code>2&gt;&amp;1</code>的意思是把标准错误流（2）重定向到标准输出流（1）中，而标准输出又导入文件output里面，所以结果是标准错误和标准输出都导入文件output里面了。</font></p> <p><font size="2" face="宋体">【注】无论是否将 <code>nohup</code> 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。如果当前目录的 nohup.out 文件不可写，输出重定向到 $HOME/nohup.out 文件中。如果没有文件能创建或打开以用于追加，那么 Command 参数指定的命令不可调用。如果标准错误是一个终端，那么把指定的命令写给标准错误的所有输出作为标准输出重定向到相同的文件描述符。</font></p> <p><font size="2" face="宋体">最后谈一下/dev/null文件的作用，这是一个无底洞，任何东西都可以定向到这里，但是却无法打开。 所以一般很大的stdou和stderr当你不关心的时候可以利用stdout和stderr定向到这里<code>&gt;./command.sh &gt;/dev/null 2&gt;&amp;1</code></font></p> </li></ol> 
<blockquote> 
 <p><font color="black" size="3" face="宋体"><span id="fhq">防火墙管理</span></font></p> 
</blockquote> 
<ol><li> <p><font size="3" face="宋体" color="黑体">防火墙-端口</font></p> <pre><code class="prism language-java">systemctl status firewalld					查看firewall服务状态

systemctl restart firewalld<span class="token punctuation">.</span>service			开放端口重启防火墙才能生效

firewall<span class="token operator">-</span>cmd <span class="token operator">--</span>list<span class="token operator">-</span>ports					查看所有开启的端口，如果是阿里云，还需配置安全
											组规则

firewall<span class="token operator">-</span>cmd <span class="token operator">--</span>list<span class="token operator">-</span>all						查看防火墙所有信息

firewall<span class="token operator">-</span>cmd <span class="token operator">--</span>reload						更新防火墙规则

firewall<span class="token operator">-</span>cmd <span class="token operator">--</span>zone<span class="token operator">=</span><span class="token keyword">public</span> <span class="token operator">--</span>add<span class="token operator">-</span>port<span class="token operator">=</span><span class="token number">8080</span><span class="token operator">/</span>tcp <span class="token operator">--</span>permanent
											永久开放<span class="token number">9000</span>端口
											
firewall<span class="token operator">-</span>cmd <span class="token operator">--</span>zone<span class="token operator">=</span><span class="token keyword">public</span> <span class="token operator">--</span>add<span class="token operator">-</span>port<span class="token operator">=</span><span class="token number">80</span><span class="token operator">-</span><span class="token number">90</span><span class="token operator">/</span>tcp <span class="token operator">--</span>permanent
											多端口永久开放

firewall<span class="token operator">-</span>cmd <span class="token operator">--</span>zone<span class="token operator">=</span><span class="token keyword">public</span> <span class="token operator">--</span>remove<span class="token operator">-</span>port<span class="token operator">=</span><span class="token number">80</span><span class="token operator">/</span>tcp	<span class="token operator">--</span>permanent
											移除<span class="token number">80</span>端口号

【注】
<span class="token operator">--</span>zone					作用域

<span class="token operator">--</span>add<span class="token operator">-</span>port<span class="token operator">=</span><span class="token number">80</span><span class="token operator">/</span>tcp		添加端口，格式为端口和通讯协议

<span class="token operator">--</span>permanent				永久生效，没有此参数重启后失效
</code></pre> </li></ol> 
<blockquote> 
 <p><font color="black" size="4"><span id="sybg">进阶小故事之CPU深夜狂飙</span></font></p> 
</blockquote> 
<p><font size="3" face="宋体">傍晚时分，警报声乍起，整个Linux帝国都陷入了惊恐之中。</font></p> 
<p><font size="3" face="宋体">安全部长迅速召集大家商讨应对之策。</font></p> 
<p><font size="3" face="宋体">“诸位，突发情况，CPU占用率突然飙升，并且长时间没有降下来的趋势，CPU工厂的阿Q向我们表达了强烈抗议”</font></p> 
<p><font size="3" face="宋体">这时，一旁的kill命令说到：“部长莫急，叫top老哥看一下谁在占用CPU，拿到进程号pid，我把他干掉就好了”</font></p> 
<p><font size="3" face="宋体">此言一出，在座的大伙都点头赞许，惊恐之色稍解。</font></p> 
<p><font size="3" face="宋体">top命令站了起来，面露得意之色，说到：“大家请看好了”，说完，打印出了当前的进程列表：</font></p> 
<p><img src="https://images2.imgbox.com/23/8c/drE7kL1A_o.png" alt="在这里插入图片描述"></p> 
<p><font size="3" face="宋体">众人瞪大了眼睛，瞅了半天，也没看出哪个进程在疯狂占用CPU，top老哥这下尴尬了。</font></p> 
<p><font size="3" face="宋体">这时，一旁的ps命令凑了上来，“让我来试试”</font></p> 
<p><font size="3" face="宋体">ps命令深吸了一口气，也打印出了进程列表。</font></p> 
<p><font size="3" face="宋体">然而，依旧没有任何可疑的进程。</font></p> 
<p><font size="3" face="宋体">“你俩怎么回事，为什么没有？”，安全部长有些不悦。</font></p> 
<p><font size="3" face="宋体">“部长，我俩都是遍历的 /proc/ 目录下的内容，按理说，所有的进程都会在这里啊，我也想不通为什么找不到···”，top老哥委屈的说到。</font></p> 
<p><font size="3" face="宋体">“遍历，怎么遍历的？”</font></p> 
<p><font size="3" face="宋体">“就是通过opendir/readdir这些系统调用函数来遍历的，这都是帝国提供的标准接口，应该不会出错，除非···”，说到这，top打住了。</font></p> 
<p><font size="3" face="宋体">“除非什么？”</font></p> 
<p><font size="3" face="宋体">“除非这些系统调用把那个进程给过滤掉了，那样的话我就看不到了，难道有人潜入帝国内核，篡改了系统调用？”</font></p> 
<p><font size="3" face="宋体">安全部长瞪大了眼睛，真要如此，那可是大事啊！</font></p> 
<p><font size="3" face="宋体">眼看部长急的团团转，一旁的netstat起身说到：“部长，我之前结识一好友，名叫unhide，捉拿隐藏进程是他的拿手好戏，要不请他来试试？”</font></p> 
<p><font size="3" face="宋体">部长大喜，“还犹豫什么，赶紧去请啊！”</font></p> 
<p><font size="3" face="宋体">“已经联系了，随后就到”</font></p> 
<p><font size="3" face="宋体">部长看着netstat，说到：“正好，趁着这个功夫，你先来看看现在有没有对外可疑的连接”</font></p> 
<p><font size="3" face="宋体">netstat点了点头，随后打印出了所有的网络连接信息：</font></p> 
<p><img src="https://images2.imgbox.com/5a/d6/6NHamX2m_o.png" alt="在这里插入图片描述"><br> <font size="3" face="宋体">“来来来，你们挨个来认领，看看都是谁的”，部长说到。</font></p> 
<p><font size="3" face="宋体">“这个80端口的服务是我的”，nginx站了出来。</font></p> 
<p><font size="3" face="宋体">“这个6379端口服务是我的”，redis也站了出来。</font></p> 
<p><font size="3" face="宋体">“这个，9200是我的”，elasticsearch说到。</font></p> 
<p><font size="3" face="宋体">“3306那个是我的”</font></p> 
<p><font size="3" face="宋体">“8182是我的”</font></p> 
<p><font size="3" face="宋体">······</font></p> 
<p><font size="3" face="宋体">一阵嘈杂后，只剩下一个连接无人认领：</font></p> 
<p><img src="https://images2.imgbox.com/1f/7f/Aobc73k1_o.png" alt="在这里插入图片描述"></p> 
<p><font size="3" face="宋体">“部长，这八成就是躲在暗处那家伙的连接”，netstat说到。</font></p> 
<p><font size="3" face="宋体">安全部长思考片刻问到：“curl何在？来访问下这个IP地址，探探对方虚实”</font></p> 
<p><font size="3" face="宋体">curl站了出来，“来了来了”</font></p> 
<p><font size="3" face="宋体">curl小心翼翼的发送了一个HTTP请求过去，对方竟然回信了：</font></p> 
<p><img src="https://images2.imgbox.com/51/ca/kt8w8819_o.png" alt="在这里插入图片描述"></p> 
<p><font size="3" face="宋体">一行醒目的mining poll出现在大家面前。</font></p> 
<p><font size="3" face="宋体">“挖，挖矿病毒！”，top老哥叫了出来。</font></p> 
<p><font size="3" face="宋体">这一下，在场所有的人都倒吸了一口凉气。</font></p> 
<p><font size="3" face="宋体">部长赶紧叫防火墙firewall配置了一条规则，将这条连接掐断。</font></p> 
<p><font size="3" face="宋体">就在这时，unhide走了进来。</font></p> 
<p><font size="3" face="宋体">简单了解了情况后，unhide拍拍胸脯说到：“这事交给我了，一定把这家伙给揪出来”</font></p> 
<p><font size="3" face="宋体">随后，unhide一阵操作猛如虎，输出了几行信息：</font></p> 
<p><img src="https://images2.imgbox.com/d5/61/6sNfmaa2_o.png" alt="在这里插入图片描述"><br> <font size="3" face="宋体">众人皆凑了过来，瞪大了眼睛，unhide老哥果然不是盖的，果真发现了几个可疑分子。</font></p> 
<p><font size="3" face="宋体">top有点表示怀疑，问到：“敢问兄台用的什么路数，为何我等都看不到这几个进程的存在？”</font></p> 
<p><font size="3" face="宋体">unhide笑道：“没什么神秘的，其实我也是遍历 /proc/ 目录，和你们不同的是，我不用readdir，而是从进程id最小到最大，挨个访问 /proc/$pid 目录，一旦发现目录存在而且不在ps老哥的输出结果中，那这就是一个隐藏进程。”</font></p> 
<p><font size="3" face="宋体">一旁的ps笑道：“原来还有我的功劳呐”</font></p> 
<p><font size="3" face="宋体">“找到了，就是这家伙！”，netstat大声说到。</font></p> 
<p><img src="https://images2.imgbox.com/ac/55/NyDZtOWf_o.png" alt="在这里插入图片描述"></p> 
<p><font size="3" face="宋体">“你怎么这么肯定？”部长问到。</font></p> 
<p><font size="3" face="宋体">“大家请看，进程打开的文件都会在 /proc/pid/fd 目录下，socket也是文件，我刚看了一下，这个进程刚好有一个socket。再结合/proc/tcp信息，可以确定这个socket就是目标端口号7777的那一条！”</font></p> 
<p><font size="3" face="宋体">“好家伙！好家伙”，众人皆啧啧称赞。</font></p> 
<p><font size="3" face="宋体">“还等什么，快让我来干掉它吧！”，kill老哥已经按捺不住了。</font></p> 
<p><font size="3" face="宋体">“让我来把它删掉”，rm小弟也磨刀霍霍了。</font></p> 
<p><font size="3" face="宋体">部长摇头说到：“且慢，cp何在，把这家伙先备份到隔离目录去，以待秋后算账”</font></p> 
<p><font size="3" face="宋体">cp拷贝完成，kill和rm两位一起上，把背后这家伙就地正法了。</font></p> 
<p><font size="3" face="宋体">top赶紧查看了最新的资源使用情况，惊喜的欢呼：“好了好了，CPU占用率总算降下去了，真是大快人心”</font></p> 
<p><font size="3" face="宋体">天色已然不早，没多久，众人先后离开，帝国恢复了往日的平静。</font></p> 
<p><font size="3" face="宋体">不过，安全部长的脸上，仍然是一脸愁容。</font></p> 
<p><font size="3" face="宋体">“部长，病毒已经被清除，为何还是闷闷不乐呢？”，助理问到。</font></p> 
<p><font size="3" face="宋体">“病毒虽已清除，但却不知这家伙是如何闯入的，还有背后暗中保护隐藏它的人又是谁，这实让我在很忧心啊”</font></p> 
<blockquote> 
 <p><font face="宋体" color="black" size="3"><span id="jvmwt">进阶小故事之轻松分析定位JVM问题</span></font></p> 
</blockquote> 
<p><font size="2" face="宋体">你可能一开始会比较畏惧使用复杂的工具去排查问题，又或者是打开了工具感觉无从下手，但是随着实践越来越多，对Java程序和各种框架的运作越来越熟悉，你会发现使用这些工具越来越顺手。</font></p> 
<p><font size="2" face="宋体">接下来测试使用<a href="#jdk" rel="nofollow">JDK自带工具</a>来分析和定位Java程序问题。</font></p> 
<p><font size="2" face="宋体">为了测试这些工具我们先来写一段代码：启动 10 个死循环的线程，每个线程分配一个 10MB 左右的字符串，然后休眠 10 秒。可以想象到，这个程序会对 GC 造成压力：</font></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> main <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">rangeClosed</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">mapToObj</span><span class="token punctuation">(</span>i <span class="token operator">-&gt;</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//每一个线程都是一个死循环，休眠10秒，打印10M数据</span>
            <span class="token class-name">String</span> payload <span class="token operator">=</span> <span class="token class-name">IntStream</span><span class="token punctuation">.</span><span class="token function">rangeClosed</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">mapToObj</span><span class="token punctuation">(</span>__ <span class="token operator">-&gt;</span> <span class="token string">"a"</span><span class="token punctuation">)</span>
                    <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span><span class="token class-name">Collectors</span><span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>payload<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token operator">::</span><span class="token function">start</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


    <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">HOURS</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><font size="2" face="宋体">将该程序进行打包放置到虚拟机下，然后使用 java -jar 启动进程，设置 JVM 参数，让堆最小最大都是 1GB：</font></p> 
<p><img src="https://images2.imgbox.com/46/c8/9U9hAu0O_o.png" alt="在这里插入图片描述"></p> 
<p><font size="2" face="宋体">完成这些准备工作后，我们就可以使用 JDK 提供的工具，来观察分析这个测试程序了。</font></p> 
<p><font size="2" face="宋体">首先使用<code>jps</code>命令得到Java进程列表(这会比使用ps来的方便)</font></p> 
<p><img src="https://images2.imgbox.com/03/8e/xx3sQZFH_o.png" alt="在这里插入图片描述"></p> 
<p><font size="2" face="宋体">然后根据jps所获取到的Pid(1556)，使用<code>jinfo</code>命令打印JVM的各个参数：</font></p> 
<p><img src="https://images2.imgbox.com/91/21/cnSJ1iS7_o.png" alt="在这里插入图片描述"></p> 
<p><font size="2" face="宋体">检查后发现如下图所示，我们设置 JVM 参数的方式不对，-Xms1g 和 -Xmx1g 这两个参数被当成了 Java 程序的启动参数，整个 JVM 目前最大内存是 4GB 左右，而不是 1GB。</font></p> 
<p><img src="https://images2.imgbox.com/52/ba/x0cXhs5J_o.png" alt="在这里插入图片描述"></p> 
<p><font size="2" face="宋体">把 JVM 参数放到 -jar 之前，重新启动程序，可以看到如下输出：</font></p> 
<p><img src="https://images2.imgbox.com/f2/bd/eljJLKni_o.png" alt="在这里插入图片描述"><br> <font size="2" face="宋体">此时可以确认这次 JVM 参数的配置正确了</font></p> 
<p><img src="https://images2.imgbox.com/2c/61/zPPUImw4_o.png" alt="在这里插入图片描述"><br> <font size="2" face="宋体">接着使用jstat命令查看GC趋势，<code>jstat</code>命令允许以固定的监控频次输出JVM的各种监控指标，比如使用-gcutil 输出GC和内存占用汇总信息，每个5秒输出一次，输出100次。</font></p> 
<p><img src="https://images2.imgbox.com/8b/7b/L6xQaldy_o.png" alt="在这里插入图片描述"></p> 
<p><font size="2" face="宋体">可以看到 Young GC 比较频繁，而 Full GC 基本 10 秒一次;</font></p> 
<p><font size="2" face="宋体">其中，S0 表示 Survivor0 区占用百分比，S1 表示 Survivor1 区占用百分比，E 表示 Eden 区占用百分比，O 表示老年代占用百分比，M 表示元数据区占用百分比，YGC 表示年轻代回收次数，YGCT 表示年轻代回收耗时，FGC 表示老年代回收次数，FGCT 表示老年代回收耗时。</font></p> 
<font size="3" face="宋体"> </font> 
<blockquote> 
 <p><font face="宋体" color="black" size="3"><span id="seween">交互工具</span></font></p> 
</blockquote> 
<p><a href="#seweenone" rel="nofollow"><font size="2" color="grey" face="宋体">secureCRT</font></a></p> 
<ol><li><font size="2" face="宋体" color="黑体">secureCRT</font></li></ol> 
<p><font size="2" face="宋体" color="黑体">（1）本地与远程传输文件方式</font></p> 
<p><font size="2" face="宋体">①通过SFTP标签页</font></p> 
<p><font size="2" face="宋体">secureCRT按下ALT+P 或[文件]–[连接SFTP标签页] 开启新的会话 进行ftp操作。<br> 查看本地和远程对接目录可以通过：[选项]–[会话选项]–[SFTP标签页]</font></p> 
<p><font size="2" face="宋体">输入:help命令，显示该FTP提供的所有命令</font></p> 
<p><font size="2" face="宋体">pwd ：查询linux主机所在目录(也就是远程主机目录)</font></p> 
<p><font size="2" face="宋体">lpwd：查询本地目录（一般指windows上传文件的目录：我们可以通过查看”选项“下拉框中的”会话选项“知道本地上传目录为：D:/我的文档）</font></p> 
<p><font size="3" face="宋体"> ls：查询连接到当前linux主机所在目录有哪些文件</font></p> 
<p><font size="3" face="宋体">lls： 查询当前本地上传目录有哪些文件</font></p> 
<p><font size="3" face="宋体">lcd：改变本地上传目录的路径</font></p> 
<p><font size="3" face="宋体">cd: 改变远程上传目录</font></p> 
<p><font size="3" face="宋体">get 文件名称：将远程目录中文件下载到本地目录</font></p> 
<p><font size="3" face="宋体">put 文件名称：将本地目录中文件上传到远程主机(linux)</font></p> 
<p><font size="3" face="宋体">quit：断开FTP连接</font></p> 
<p><font size="3" face="宋体">②通过rz命令与sz命令</font></p> 
<p><font size="3" face="宋体">rz命令（Receive ZMODEM），使用ZMODEM协议，将本地文件批量上传到远程Linux/Unix服务器，注意不能上传文件夹。</font></p> 
<p><font size="3" face="宋体">当我们使用虚拟终端软件，如Xshell、SecureCRT或PuTTY来连接远程服务器后，使用rz命令可以上传本地文件到远程服务器。输入rz回车后，会出现文件选择对话框，选择需要上传文件，一次可以指定多个文件，上传到服务器的路径为当前执行rz命令的目录。</font></p> 
<p><font size="3" face="宋体">此外，可以在虚拟终端软件设置上传时默认加载的本地路径和下载的路径。如SecureCRT软件 -&gt; Options -&gt; session options -&gt; X/Y/Zmodem 下可以设置上传和下载的目录。</font></p> 
<p><font size="3" face="宋体">命令格式：rz [选项]</font></p> 
<table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>ascii:以文本方式传输</td></tr><tr><td>-b</td><td>binary:以二进制方式传输，推荐使用</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table> 
<blockquote> 
 <p><font color="black" size="3" face="宋体"><span id="six">环境安装</span></font></p> 
</blockquote> 
<p><a href="#sixone" rel="nofollow"><font size="2" color="grey" face="宋体">JDK安装</font></a></p> 
<p><a href="#sixtwo" rel="nofollow"><font size="2" color="grey" face="宋体">MYSQL安装</font></a></p> 
<p><a href="#elasticsearch" rel="nofollow"><font size="2" color="grey" face="宋体">elasticsearch安装</font></a></p> 
<ol><li> <p><font size="2" face="宋体" color="黑体"><span id="sixone">JDK安装</span></font></p> 
  <table><thead><tr><th><font size="2" face="宋体">步骤</font></th><th><font size="2" face="宋体">相关命令</font></th></tr></thead><tbody><tr><td><font size="2" face="宋体">windows 上传安装包至linux</font></td><td><font size="2" face="宋体">rz -b</font></td></tr><tr><td><font size="2" face="宋体">检测linux原先是否存在JDK环境</font></td><td><font size="2" face="宋体">java -version</font></td></tr><tr><td><font size="2" face="宋体">检测JDK版本信息</font></td><td><font size="2" face="宋体">rpm -qa</font></td></tr><tr><td><font size="2" face="宋体">删除JDK环境</font></td><td><font size="2" face="宋体"> rpm -e --nodeps jdk_*</font></td></tr><tr><td><font size="2" face="宋体">安装JDK rpm</font></td><td><font size="2" face="宋体">rpm -ivh jdk包名</font></td></tr><tr><td><font size="2" face="宋体">添加环境变量配置</font></td><td><font size="2" face="宋体">vim /etc/profile</font></td></tr></tbody></table><p><font size="2" face="宋体"><span id="jdk">[拓展] JDK自带工具</span></font></p> <p><font size="2" face="宋体">JDK自带了很多命令行甚至是图形界面工具，帮助我们查看JVM的一些信息。<br> <img src="https://images2.imgbox.com/03/72/Re9Y1N8O_o.png" alt="在这里插入图片描述"><br> <font size="2" face="宋体">通过下面这张图可了解各个工具的基本作用：</font></font></p> <p><img src="https://images2.imgbox.com/72/48/nHHwWjjo_o.png" alt="在这里插入图片描述"></p> <p><font size="2" face="宋体">关键命令辅助参数：</font></p> 
  <table><thead><tr><th><font size="2" face="宋体">jps辅助参数</font></th><th><font size="2" face="宋体">作用</font></th></tr></thead><tbody><tr><td><font size="2" face="宋体">-l</font></td><td><font size="2" face="宋体">额外输出完全的包名</font></td></tr><tr><td><font size="2" face="宋体">-v</font></td><td><font size="2" face="宋体">输出jvm参数</font></td></tr><tr><td><font size="2" face="宋体">-V</font></td><td><font size="2" face="宋体">输出通过flag文件传递到JVM中的参数(.hotspotrc文件或-XX:Flags=所指定的文件</font></td></tr><tr><td><font size="2" face="宋体">-m</font></td><td><font size="2" face="宋体">输出main method的参数</font></td></tr><tr><td><font size="2" face="宋体">-q</font></td><td><font size="2" face="宋体">仅输出VM标识符，不包括classname,jar name,arguments in main method</font></td></tr><tr><td><font size="2" face="宋体">-Joption</font></td><td><font size="2" face="宋体">传递参数到vm,例如:-J-Xms512m</font></td></tr></tbody></table></li><li> <p><font size="2" face="宋体" color="黑体"><span id="sixone">MYSQL安装</span></font></p> <p><font size="3" face="宋体">（5）检查MYSQL相关配置状态</font></p> <p><font size="3" face="宋体">在mysql内执行状态命令:<code>status</code><br> <img src="https://images2.imgbox.com/5c/af/2pCH3cC1_o.png" alt="在这里插入图片描述"></font></p> </li><li> <p><font size="2" face="宋体" color="黑体">tomcat安装</font></p> <pre><code class="prism language-java">		步骤一 <span class="token operator">:</span> 官网下载tomcat9即可 <span class="token punctuation">,</span>apache<span class="token operator">-</span>tomcat<span class="token operator">-</span><span class="token number">9.0</span><span class="token number">.22</span><span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz

		步骤二 <span class="token operator">:</span> linux命令

			tar <span class="token operator">-</span>zxvf apche<span class="token operator">-</span>tomcat<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>						解压压缩包
	
			<span class="token punctuation">.</span>/startup<span class="token punctuation">.</span>sh									执行tomcat
	
			<span class="token punctuation">.</span>/shutdown<span class="token punctuation">.</span>sh									停止tomcat
</code></pre> <p><font size="2" color="grey">[注]<br> 1.上传完毕的项目直接购买自己的域名，备案解析过去即可。<br> 2.域名解析后如果端口是80，http或者443-https 可以直接访问，如果是9000 8080，就需要通过apache或者niginx做一下反向代理即可，配置文件即可</font></p> </li><li> <p><font size="2" face="宋体" color="黑体">docker安装</font></p> <pre><code class="prism language-java">		cat <span class="token operator">/</span>etc<span class="token operator">/</span>redhat<span class="token operator">-</span>release						检测<span class="token class-name">CentOS</span> 版本
	
		yum <span class="token operator">-</span>y install gcc							编译<span class="token class-name">C</span>工具
	
		yum <span class="token operator">-</span>y install gcc<span class="token operator">-</span>c<span class="token operator">++</span> 						编译<span class="token class-name">C</span><span class="token operator">++</span>工具
	
		yum remove docker \												
	          docker<span class="token operator">-</span>client \
	          docker<span class="token operator">-</span>client<span class="token operator">-</span>latest \
	          docker<span class="token operator">-</span>common \
	          docker<span class="token operator">-</span>latest \
	          docker<span class="token operator">-</span>latest<span class="token operator">-</span>logrotate \
	          docker<span class="token operator">-</span>logrotate \
	          docker<span class="token operator">-</span>engine							官网版卸载旧版本
	
		yum install <span class="token operator">-</span>y yum<span class="token operator">-</span>utils device<span class="token operator">-</span>mapper<span class="token operator">-</span>persistent<span class="token operator">-</span>data lvm2
													安装必须的软件包 
	
		yum<span class="token operator">-</span>config<span class="token operator">-</span>manager <span class="token operator">--</span>add<span class="token operator">-</span>repo http<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>mirrors<span class="token punctuation">.</span>
		aliyun<span class="token punctuation">.</span>com<span class="token operator">/</span>docker<span class="token operator">-</span>ce<span class="token operator">/</span>linux<span class="token operator">/</span>centos<span class="token operator">/</span>docker<span class="token operator">-</span>ce<span class="token punctuation">.</span>repo
													设置stable镜像仓库（这里使用的是国内的）
	
		yum makecache fast							更新<span class="token class-name">Yum</span>软件包索引
	
		yum <span class="token operator">-</span>y install docker<span class="token operator">-</span>ce docker<span class="token operator">-</span>ce<span class="token operator">-</span>cli containerd<span class="token punctuation">.</span>io
													安装<span class="token class-name">Docker</span> <span class="token constant">CE</span>
	
		systemctl start docker						启动docker
	
		docker version								查看docker版本					
	
		docker pull hello<span class="token operator">-</span>world						从docker镜像仓库中拉去hello<span class="token operator">-</span>world镜像
		
		docker images								查看下载好了的情况
	
		docker run hello<span class="token operator">-</span>world			　			运行helloworld
	
		ps <span class="token operator">-</span>ef<span class="token operator">|</span>grep docker							查看docker进程
</code></pre> <p><font size="2" color="grey">[注]<br> 1.gcc是拿来编译各种源代码的软件 所谓GCC包，就相当于安装GCC的安装包啦，类似WIN下的setup.exe<br> 2.RPM是不需要GCC就可以装的,不过TAR包里都是源代码，你得自己编译才能装，所以一定要装GCC，不然无法装<br> 3./usr/bin查看是否有gcc包<br> 4.安装yum-utils，它提供一个yum-config-manager单元，同时安装的device-mapper-persistent-data和lvm2用于储存设备映射（devicemapper）必须的两个软件包。</font></p> </li><li> <p><font size="3" face="宋体" color="黑体"><span id="elasticsearch">elasticsearch安装</span></font></p> <p><font size="2" face="宋体">下载安装包：<a href="https://www.elastic.co/cn/downloads/elasticsearch" rel="nofollow">https://www.elastic.co/cn/downloads/elasticsearch</a></font></p> <p><font size="2" face="宋体">将下载的安装包上传至linux里，然后进行接下来的配置环节：</font></p> <p><font size="2" face="宋体">①创建elasticsearch数据文件和日志文件</font></p> <p><font size="2" face="宋体">–&gt;在linux根路径下创建一个path文件夹:<code>mkdir /path</code><br> <font size="2" face="宋体">–&gt;将该文件夹更改为elsearch用户下且elsearch组:<code>chown -R elsearch:elsearch /path/</code> <br> <font size="2" face="宋体">–&gt;进入elsearch用户中:<code>su -elsearch</code> <br> <font size="2" face="宋体">–&gt;创建多级目录也就是创建to目录和data目录:<code>mkdir -p to/data</code> <br> <font size="2" face="宋体">–&gt;创建多级目录也就是logs目录:<code>mkdir -p to/logs</code></font></font></font></font></font></p> <p><font size="2" face="宋体">②更改elasticsearch配置文件</font></p> <p><font size="2" face="宋体">–&gt;进入elasticsearch的配置文件:<code>vim elasticsearch.yml</code></font></p> <p><img src="https://images2.imgbox.com/13/1f/QTxneIBP_o.png" alt="在这里插入图片描述"> <img src="https://images2.imgbox.com/de/45/HL2kmhav_o.png" alt="在这里插入图片描述"> <font size="2" face="宋体">此处进行设置跨域访问支持，默认为false，跨域访问允许的域名地址，(允许所有域名)以上使用正则http.cors.allow-origin: /.*/</font></p> <p><font size="2" face="宋体">③</font></p> <p><font size="2" face="宋体">④运行elasticsearch</font></p> <p><font size="2" face="宋体">–&gt;进入es文件夹下的bin目录<br> <font size="2" face="宋体">–&gt;开始执行elastcsearch服务:<code>./elasticsearch</code> <br> <font size="2" face="宋体">–&gt;若上面没有报错，可后台执行elasticsearch:<code>./elasticsearch -d</code><br> <font size="2" face="宋体">–&gt;测试elasticsearch:<code>curl 'http://自己配置的IP地址:9200/'</code></font></font></font></font></p> <p><font size="2" face="宋体">⑤windows安装elasticsearch head</font></p> <p><font size="2" face="宋体">参考：<a href="https://blog.csdn.net/Zereao/article/details/89362105">https://blog.csdn.net/Zereao/article/details/89362105</a><br> <font size="2" face="宋体">参考：<a href="https://blog.csdn.net/Sunshine_liang1/article/details/96328301">https://blog.csdn.net/Sunshine_liang1/article/details/96328301</a><br> <font size="2" face="宋体">cmd进入elasticsearch-head 执行cnpm run start</font></font></font></p> <p><font size="2" face="宋体">⑥</font></p> <p><font size="2" face="宋体">⑦⑧⑨</font></p> 
  <ol start="2"><li> <p>linux操作</p> <p><font size="4" color="gre">Liniux下配置elasticsearch文件夹</font></p> <pre><code class="prism language-java">getconf <span class="token constant">LONG_BIT</span>							查看<span class="token class-name">Linux</span>是<span class="token number">32</span>位还是<span class="token number">64</span>位

groupadd elsearch							创建一个elsearch用户组

useradd elsearch <span class="token operator">-</span>g elsearch				创建一个elsearch用户并放入elsearch用户组

chown <span class="token operator">-</span><span class="token class-name">R</span> elsearch<span class="token operator">:</span>elsearch <span class="token punctuation">[</span>解压后文件名<span class="token punctuation">]</span> 	将该elasticsearch文件更改为elsearch用户下
</code></pre> <p><font size="4" color="gre">Liniux下更改用户空间</font></p> <pre><code class="prism language-java">su <span class="token operator">-</span>root 										切换到root用户下

sysctl <span class="token operator">-</span>w vm<span class="token punctuation">.</span>max_map_count<span class="token operator">=</span><span class="token number">262144</span>				将内存设置为<span class="token number">262144</span>

sysctl <span class="token operator">-</span>a<span class="token operator">|</span>grep vm<span class="token punctuation">.</span>max_map_count					查看内存设置结果

vim <span class="token operator">/</span>etc<span class="token operator">/</span>sysctl<span class="token punctuation">.</span>conf							进入系统设置文件内
												加一行：vm<span class="token punctuation">.</span>max_map_count<span class="token operator">=</span><span class="token number">262144</span>	
</code></pre> </li></ol> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bd3caa0f4461d393c3971823c10c20ea/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OSPF部分</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9118617041781322352290e1ff61a64f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL运维实战（1.3）安装部署：源码编译安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>