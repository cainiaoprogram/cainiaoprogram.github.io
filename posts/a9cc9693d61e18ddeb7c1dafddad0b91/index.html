<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>yocto 使用技巧 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="yocto 使用技巧" />
<meta property="og:description" content="相当详细的文章就是转运一下，方便大家阅读，原版文章可以看原链接。
对于大家使用Yocto中的一些疑问，使用寥寥数语进行解答，让大家快速高效地使用Yocto。
(1): Yocto 编译后文件放在了哪里 输出文件位置 编译完成后内核以及rootfs，内核，uboot以及dtb会放在相对于build目录的tmp/deploy/images/MACHINE/下面,这里MACHINE需要可能为空（对于老版本的poky/yocto），也可能是你的板子名字，例如sabresd。
对于toolchain，那么放在mp/deploy/sdk/MACHINE/下。
图片示例：
编译完成后内核以及rootfs以及dtb会放在相对于build目录的tmp/deploy/images/imx6qsabresd/下面
各个文件都有一个软连接来指向最新编译产生的文件，因此如果需要看到最新的文件，可以直接使用软链接即可：
(2): Yocto Linux内核编译目录在哪？ 内核放在了哪里？ 这个是放在了如下位置，我们可以用下面命令来确定：
bitbake -e linux-imx | grep ^S=
图示：
(3): Yocto 如何重新编译Linux内核与dtb，并放到deploy目录？ 编译内核，并生成uImage&#43;dtb，编译的命令如下：
bitbake linux-imx -C compile
注意这里的-C的C是大写，和小写的c是有区别的。
注意这里的linux-imx是针对imx的内核，你的内核名字可能不一样，关于如何确定一个包的名字，请看：Yocto tips (4): Yocto 如何确定(找到)
(4): Yocto 如何确定(找到)一个包的名字 使用下面命令来却确定：
bitbake -s | grep XXX
其中XXX为包的关键字，例如linux或者uboot，这样就可以看到所有带有关键字的包了，如下图，就是为了找到内核：
(5): Yocto如何更改source code的下载与git clone地址 现象 Yocto中在fetch一些软件包的时候经常出现一天也下载不下来，这种情况极大浪费了我们的时间。
例如，下面有三个Package下载了一天也没有完成：
解决方法 确定下载的地址，手动下载 先确定软件包的下载地址，例如对于opencv与opencv-samples软件包：
可以看到他们的git地址都是一样的，因此，我们可以手动来git clone：
可以看到我们只使用了几十分钟而已。clone下来以后，我们就可以让软件包使用我们本地的这个repo了，而不需要忙忙的去远程repo去clone。
让package克隆时使用本地的git
找到软件包对应的bb文件 我们可以使用find命令来查找
更改bb文件 注意里面添加了一个protocol指定。
再一次获取 bitbake opencv -c fetch" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a9cc9693d61e18ddeb7c1dafddad0b91/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-22T18:39:34+08:00" />
<meta property="article:modified_time" content="2022-07-22T18:39:34+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">yocto 使用技巧</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>相当详细的文章就是转运一下，方便大家阅读，原版文章可以看原链接。</p> 
<p>对于大家使用<a href="https://so.csdn.net/so/search?q=Yocto&amp;spm=1001.2101.3001.7020" title="Yocto">Yocto</a>中的一些疑问，使用寥寥数语进行解答，让大家快速高效地使用Yocto。</p> 
<h2><a name="t0"></a>(1): Yocto 编译后文件放在了哪里 输出文件位置</h2> 
<p>编译完成后内核以及rootfs，内核，uboot以及dtb会放在相对于build目录的tmp/deploy/images/MACHINE/下面,这里MACHINE需要可能为空（对于老版本的poky/yocto），也可能是你的板子名字，例如sabresd。</p> 
<p>对于toolchain，那么放在mp/deploy/sdk/MACHINE/下。</p> 
<p>图片示例：</p> 
<p>编译完成后内核以及rootfs以及dtb会放在相对于build目录的tmp/deploy/images/imx6qsabresd/下面</p> 
<p><img alt="" src="https://images2.imgbox.com/27/84/rIUIO1Qq_o.png"></p> 
<p>各个文件都有一个软连接来指向最新编译产生的文件，因此如果需要看到最新的文件，可以直接使用软链接即可：</p> 
<p><img alt="" src="https://images2.imgbox.com/51/5f/jcSa9k1t_o.png"></p> 
<h2><a name="t1"></a>(2): Yocto Linux内核编译目录在哪？</h2> 
<p>内核放在了哪里？ 这个是放在了如下位置，我们可以用下面命令来确定：</p> 
<p><code>bitbake -e linux-imx  | grep ^S=</code></p> 
<p>图示：</p> 
<p></p> 
<p><img alt="" src="https://images2.imgbox.com/a4/5d/039jGmG8_o.png"></p> 
<h2><a name="t2"></a>(3): Yocto 如何重新编译Linux内核与dtb，并放到deploy目录？</h2> 
<p>编译内核，并生成uImage+dtb，编译的命令如下：</p> 
<p><code>bitbake linux-imx -C compile</code></p> 
<p>注意这里的-C的C是大写，和小写的c是有区别的。</p> 
<p>注意这里的linux-imx是针对imx的内核，你的内核名字可能不一样，关于如何确定一个包的名字，请看：<a href="http://blog.csdn.net/sy373466062/article/details/50360804" title="Yocto tips (4): Yocto 如何确定(找到)">Yocto tips (4): Yocto 如何确定(找到)</a></p> 
<h2><a name="t3"></a>(4): Yocto 如何确定(找到)一个包的名字</h2> 
<p>使用下面命令来却确定：</p> 
<p><code>bitbake -s | grep XXX</code></p> 
<p>其中XXX为包的关键字，例如linux或者uboot，这样就可以看到所有带有关键字的包了，如下图，就是为了找到内核：</p> 
<p><img alt="" src="https://images2.imgbox.com/e1/43/eYARSE02_o.png"></p> 
<h2><a name="t4"></a>(5): Yocto如何更改source code的下载与git clone地址</h2> 
<h3><a name="t5"></a><a id="_0"></a><br> 现象</h3> 
<p>Yocto中在fetch一些软件包的时候经常出现一天也下载不下来，这种情况极大浪费了我们的时间。</p> 
<p>例如，下面有三个Package下载了一天也没有完成：</p> 
<p><img alt="" src="https://images2.imgbox.com/83/c6/IbEALCAT_o.png"></p> 
<h3><a name="t6"></a><a id="_11"></a><br> 解决方法</h3> 
<h4><a name="t7"></a><a id="_13"></a><br> 确定下载的地址，手动下载</h4> 
<p>先确定软件包的下载地址，例如对于opencv与opencv-samples软件包：</p> 
<p><img alt="" src="https://images2.imgbox.com/bf/53/iJwyvGT3_o.png"></p> 
<p>可以看到他们的git地址都是一样的，因此，我们可以手动来git clone：</p> 
<p><img alt="" src="https://images2.imgbox.com/35/bd/4uZKKNvY_o.png"></p> 
<p>可以看到我们只使用了几十分钟而已。clone下来以后，我们就可以让软件包使用我们本地的这个repo了，而不需要忙忙的去远程repo去clone。</p> 
<p>让package克隆时使用本地的git</p> 
<h4><a name="t8"></a><a id="bb_31"></a><br> 找到软件包对应的bb文件</h4> 
<p>我们可以使用find命令来查找</p> 
<p><img alt="" src="https://images2.imgbox.com/4e/70/TKGNCKJW_o.png"></p> 
<h4><a name="t9"></a><a id="bb_40"></a><br> 更改bb文件</h4> 
<p><img alt="" src="https://images2.imgbox.com/43/69/bPHDE1md_o.png"></p> 
<p>注意里面添加了一个protocol指定。</p> 
<h4><a name="t10"></a><a id="_49"></a><br> 再一次获取</h4> 
<p>bitbake opencv -c fetch</p> 
<p>结果如下：</p> 
<p><img alt="" src="https://images2.imgbox.com/dd/1f/YqL45EHC_o.png"></p> 
<p>提示找不到branch，于是我们到我们本地的repo中将此branch切出来，也可以将其制作成bare repo：</p> 
<p><img alt="" src="https://images2.imgbox.com/3c/2d/gbW9pOmc_o.png"></p> 
<p>然后再一次进行fetch就可以了：</p> 
<p><img alt="" src="https://images2.imgbox.com/90/5b/NqB1FrUb_o.png"></p> 
<p>对于其他软件也是类似的。</p> 
<p></p> 
<h2><a name="t11"></a>(6): Yocto中如何共享已经下载的文件</h2> 
<p>Yocto的下载耗时可能会超过编译的时间，因此大家都希望下载一次后大家都用共用下载好了的文件，而不要再去下载。</p> 
<p>Yocto中所有下载了的以及git clone的文件都放在环境变量DL_DIR指示的目录下，这个目录默认在machine build directory下面。</p> 
<p>因此要共享下载文件只需要指定此变量到下载好了的目录即可，可以在local.conf中指定即可：</p> 
<p><img alt="" src="https://images2.imgbox.com/3d/1c/tRHGcdUX_o.png"></p> 
<p></p> 
<h2><a name="t12"></a>(7): Yocto Bitbake的clean与cleanall以及cleansstate的区别</h2> 
<p>Yocto中对于不同的Package，有不同的task，即可以执行不同的操作，有一些是所有包共通的，例如clean，build等。</p> 
<p>我们可以使用下面命令来查看一个包都有哪些可执行的task：</p> 
<pre><code>bitbake Package -c listtasks
</code></pre> 
<p>图示：</p> 
<p><img alt="" src="https://images2.imgbox.com/1d/5a/kBt5uWJS_o.png"></p> 
<p>我们可以从里面看到clean与cleanall以及cleansstate的区别。</p> 
<p></p> 
<h2><a name="t13"></a>(8): Yocto 如何加快软件包的下载 如何只下载所有需要的软件包而不编译</h2> 
<h3><a name="t14"></a>加快下载</h3> 
<p>Yocto中下载是最耗时的，因此我们可以尽可能的开启最多的并行数量。</p> 
<p>对此，我们可以在local.conf中将并行数目调大，例如我的CPU 是E3-1230 v2, 8核，所以我可以开启16个线程来下载，因为我们的网速慢，所以其实这些下载操作并非CPU密集型任务，很多包也很小，所以同时IO也不密集，因此可以适当调大：</p> 
<p><img alt="" src="https://images2.imgbox.com/be/59/8BAxIC7i_o.png"></p> 
<p>效果如下：</p> 
<p><img alt="" src="https://images2.imgbox.com/3c/6c/cSLMjVGY_o.png"></p> 
<h3><a name="t15"></a><a id="_14"></a><br> 下载所有需要的软件包而不编译</h3> 
<p>有的时候我们可能需要先将所有需要的软件包下载下来，等离线回家或者其他时机再编译，对此我们可以使用如下命令来完成：</p> 
<pre><code>bitbake fsl-image-qt5 -c fetchall
</code></pre> 
<p>对于不同的目标，需要替换fsl-image-qt5为其他的，例如可能是core-image-minimal，我们可以看到fetchall的意义：</p> 
<pre><code>do_fetchall                    Fetches all remote sources required to build a target</code></pre> 
<p></p> 
<h2><a name="t16"></a>(9): Yocto 软件包的下载地址在哪</h2> 
<p>一般而言，可以使用<a href="http://blog.csdn.net/sy373466062/article/details/50363537" title="Yocto tips (5): Yocto如何更改source code的下载与git clone地址">Yocto tips (5): Yocto如何更改source code的下载与git clone地址</a>中提到的方法，但是有的时候一些地址是在bb文件include的文件中，而inc文件又可能层层包含，查找比较繁琐，因此直接到env中查找比较快。</p> 
<p>例如要找到imx kenrel的fetch地址可以使用下面命令：</p> 
<pre><code>bitbake -e linux-imx | grep ^SRC_URI=
</code></pre> 
<p>效果如下：<br><img alt="" src="https://images2.imgbox.com/d8/45/VX4rxrbm_o.png"></p> 
<p></p> 
<h2><a name="t17"></a>(10): Yocto hellworld 添加一个软件包</h2> 
<p>Yocto中一个软件包是放在bb文件中的，然后很多的bb文件集成一个recipe（配方），然后许多的recipe又组成一个meta layer，因此，要添加一个包其实就是在recipe下面添加一个bb（bitbake配置文件）。下面使用helloworld作为一个例子。</p> 
<h4><a name="t18"></a><a id="clone_bb_2"></a><br> clone bb文件</h4> 
<p>首先是进入到一个recipe目录下，例如下面就是到了recipes-graphics：</p> 
<pre></pre> 
<ol><li> <p><code>$ pwd</code></p> </li><li> <p><code>/media/work/iMX6/Yocto/sources/meta-fsl-arm/recipes-graphics</code></p> </li></ol> 
<p>然后clone Package配置与source目录的repo：</p> 
<pre><code>git clone https://github.com/tonyho/helloYocto.git
</code></pre> 
<h4><a name="t19"></a><a id="Yocto_18"></a><br> 查看软件包是否已经在Yocto中</h4> 
<pre></pre> 
<ol><li> <p><code>09:25 hexiongjun:imx6qsabresd_build $ bitbake -s | grep hello</code></p> </li><li> <p><code>hello :3-r0</code></p> </li><li></ol> 
<p>确认在了以后，就可以执行编译等task了，如果有需要也可以deploy到rootfs中，这些操作可以参考我以前的一些博客。</p> 
<h4><a name="t20"></a><a id="_26"></a><br> 一个软件包的结构</h4> 
<p>使用tree可以看到，其有一个bb文件，然后其中还有一个目录放着Makefile与source code：</p> 
<p><img alt="" src="https://images2.imgbox.com/b7/10/N36kr6Ts_o.png"></p> 
<p>其中的bb文件内容如下：</p> 
<pre></pre> 
<ol><li> <p><code>DESCRIPTION = "Hello World and Zlib test"</code></p> </li><li> <p><code>DEPENDS = "zlib"</code></p> </li><li> <p><code>SECTION = "libs"</code></p> </li><li> <p><code>LICENSE = "MIT"</code></p> </li><li> <p><code>PV = "3"</code></p> </li><li> <p><code>PR = "r0"</code></p> </li><li><li> <p><code>SRC_URI = " \</code></p> </li><li> <p><code>file://helloYocto.c \</code></p> </li><li> <p><code>file://zlibtest.c \</code></p> </li><li> <p><code>file://makefile \</code></p> </li><li> <p><code>"</code></p> </li><li><li> <p><code>LIC_FILES_CHKSUM = "file://helloYocto.c;md5=2dac018fa193620dc085aa1402e0b346"</code></p> </li><li> <p><code>S = "${WORKDIR}"</code></p> </li><li> <p><code>do_compile () {<!-- --></code></p> </li><li> <p><code>make</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>do_install () {<!-- --></code></p> </li><li> <p><code>install -d ${D}${bindir}/</code></p> </li><li> <p><code>install -m 0755 ${S}/helloYocto ${D}${bindir}/</code></p> </li><li> <p><code>install -m 0755 ${S}/zlibtest ${D}${bindir}/</code></p> </li><li> <p><code>}</code></p> </li><li><li> <p><code>FILES_${PN} = "${bindir}/helloYocto \</code></p> </li><li> <p><code>${bindir}/zlibtest "</code></p> </li><li></ol> 
<p>可以看到，bb文件中指定了下面几个变量的值：</p> 
<ol><li>SRC_URI</li><li>LIC_FILES_CHKSUM：这个是checksum，如果是基于版本管理的source，那么不需要，例如git与svn</li><li>FILES_$(PN)：PN是Package number，指代软件版本使用的PV与PR结合表示，即前面bitbake -s中看到的3-r0</li></ol> 
<p>还有两个方法，这2个方法重载了bitbake中默认方法：</p> 
<ol><li>do_compile</li><li>do_install</li></ol> 
<p>这两个方法，对应了Package中的compile与install task。</p> 
<h2><a name="t21"></a>(11): Yocto如何往最终的rootfs中添加软件</h2> 
<p>在Yocto中如果我们期望在rootfs中添加一些软件，例如可能是bash，可能是lsusb等，那么，我们可以有两种方法：</p> 
<ol><li>手动添加，一个个文件的拷贝</li><li>在bb文件中添加安装项目，让Yocto自动帮助我们添加</li></ol> 
<p>第一种方法需要手动将软件包的所有文件以及依赖都一个个添加进去，耗时耗力且易错，因此使用第二中方法比较合适。</p> 
<h3><a name="t22"></a><a id="YoctoRootfs_11"></a><br> Yocto中Rootfs中添加软件包的步骤</h3> 
<h4><a name="t23"></a><a id="rootfsbb_13"></a><br> 找到打包rootfs的最终bb</h4> 
<p>如果我们使用的是下面命令：</p> 
<pre><code>bitbake fsl-image-qt5
</code></pre> 
<p>那么，我们可以按照如下来搜索fsl-image-qt5这个软件包（任务），使用的是哪个bb文件：</p> 
<p><img alt="" src="https://images2.imgbox.com/95/dc/zbnWMvz3_o.png"></p> 
<h4><a name="t24"></a><a id="rootfs_30"></a><br> 添加需要安装到rootfs的软件包</h4> 
<p>然后打开，并添加需要添加的包即可，例如下面添加的是linux-firmware：</p> 
<p><img alt="" src="https://images2.imgbox.com/71/d0/9rB6JLTh_o.png"></p> 
<p>保存，然后我们再一次使用bitbake构建系统，然后就可以看到rootfs中有对应的文件了：</p> 
<p><img alt="" src="https://images2.imgbox.com/06/50/oNInCzZq_o.png"></p> 
<h2><a name="t25"></a>(12): 使用Yocto帮组我们寻找难找的固件与固件放置路径</h2> 
<p>有很多的硬件需要firmware才能工作，而这些firmware需要不仅仅需要找到，还需要放置到正确的位置，一般这个位置是/lib/firmware下面，但是很多也不尽然。</p> 
<p>手动去查找这些固件，容易出现遗漏或者混淆，也有可能是年久不匹配了的固件，例如在我前面的博客中：<a href="http://blog.csdn.net/sy373466062/article/details/50370190" title="Yocto i.MX6 (TQIMX6) (02) : USB Wifi （TP-Link WN821N等设备）AR9170的Linux内核支持与固件使用l">Yocto i.MX6 (TQIMX6) (02) : USB Wifi （TP-Link WN821N等设备）AR9170的Linux内核支持与固件使用l</a>，就出现了自己按照wiki与help去查找firmware，结果却花了大量时间也没有解决，而使用yocto中的linux-firmware软件包，非法快速的解决了这个问题。</p> 
<p>对于firmware放置的path也是类似，例如有些驱动放置的path为非标准的path，例如下面这些都是放在各自的目录中的：</p> 
<p><img alt="" src="https://images2.imgbox.com/b8/c6/qCJbYgUm_o.png"></p> 
<p>因此，直接将linux-firmware添加到打包rootfs，或者直接查看linux-firmware中的image文件夹就可以知道path了，例如前面的ar9170：</p> 
<p><img alt="" src="https://images2.imgbox.com/b4/bf/NkGr7Hgj_o.png"></p> 
<h2><a name="t26"></a>(13): Yocto 查看软件包的依赖关系</h2> 
<p>查看一个文件包的依赖，我们可以使用图形化来查看，下面是一些官方说明：</p> 
<p><img alt="" src="https://images2.imgbox.com/ea/a9/ain58el6_o.png"></p> 
<p>例如我们要查看weston的依赖：</p> 
<pre><code>bitbake --ui=depexp -g weston或者 bitbake -g  -u depexp  weston
</code></pre> 
<p>这个会列出不同的依赖，例如中间的是编译时候需要依赖的东西，结果如下：</p> 
<p><img alt="" src="https://images2.imgbox.com/38/28/AdDfAKIC_o.png"></p> 
<p></p> 
<h2><a name="t27"></a>(14): Yocto中编译链的配置变更(tuning)</h2> 
<p>这个在我们自己编译toolchain以及针对不同的硬件自己调整toolchain的时候用得多。变更方法也很简单，只需要在poky对应的配置查找一个合适的即可。</p> 
<p>例如针对armv7而言，我们可以到下面文件查找一个合适的来使用：</p> 
<p><img alt="" src="https://images2.imgbox.com/3b/7b/YcB8UVXe_o.png"></p> 
<p>将自己选择好的写入到local.conf中：</p> 
<p><img alt="" src="https://images2.imgbox.com/76/1b/g6AvzZjL_o.png"></p> 
<p></p> 
<h2><a name="t28"></a>(15): Yocto中的包管理器</h2> 
<p>使用包管理器</p> 
<p>在local.conf中使能即可：</p> 
<p><img alt="" src="https://images2.imgbox.com/b3/63/iAJVyH05_o.png"></p> 
<p>然后编译后就会有rpm包了：</p> 
<p><img alt="" src="https://images2.imgbox.com/98/24/DhFLZPTD_o.png"></p> 
<p>配置文件服务器</p> 
<p>可以使用ngix和apache，但是我们也可以只用使用python：</p> 
<pre><code>python -m SimpleHTTPServer
</code></pre> 
<p><img alt="" src="https://images2.imgbox.com/41/4e/AEGVGjBZ_o.png"></p> 
<p>打开浏览器可以看到：</p> 
<p><img alt="" src="https://images2.imgbox.com/11/59/SSnsgspj_o.png"></p> 
<p>在机器上面查看包的status</p> 
<p>smart status</p> 
<p><br><img alt="" src="https://images2.imgbox.com/fd/cf/IjZYavbo_o.png"></p> 
<p>在机器上面配置channel</p> 
<p>对于rpm使用的smart工具，添加channel：</p> 
<pre></pre> 
<ol><li> <p><code>smart channel --add all type=rpm-md baseurl=http://192.168.2.100:8000/all</code></p> </li><li> <p><code>smart channel --add cortexa9hf_vfp_neon type=rpm-md baseurl=http://192.168.2.100:8000/cortexa9hf_vfp_neon </code></p> </li><li> <p><code>smart channel --add cortexa9hf_vfp_neon_mx6qdl type=rpm-md baseurl=http://192.168.2.100:8000/cortexa9hf_vfp_neon_mx6qdl</code></p> </li><li> <p><code>smart channel --add imx6qsabresd type=rpm-md baseurl=http://192.168.2.100:8000/imx6qsabresd</code></p> </li></ol> 
<p>添加参数之后，就可以update了：</p> 
<p>smart update</p> 
<p>正确的是下面命令的情形：</p> 
<p><img alt="" src="https://images2.imgbox.com/21/03/wE9ZIpK7_o.png"></p> 
<p>如果配置参数不对，那么就会出错，如果出错，那么检查IP与格式是否正确，例如下面的http少了两个//：</p> 
<p><img alt="" src="https://images2.imgbox.com/0e/f2/vk6oT0rx_o.png"></p> 
<p>如果弄错了，那么可以先移除掉：</p> 
<pre><code>smart channel --remove all cortexa9hf_vfp_neon_mx6qdl imx6qsabresd cortexa9hf_vfp_neon
</code></pre> 
<p>然后重新添加。</p> 
<p>再看包的数量，可以看到变多了：</p> 
<p><img alt="" src="https://images2.imgbox.com/8e/a2/383d2Gc5_o.png"></p> 
<p>使用包管理器安装软件</p> 
<p>使用smart install Package即可安装：</p> 
<p><img alt="" src="https://images2.imgbox.com/7d/b4/4a0Rz5KP_o.png"></p> 
<p>如果在PC中使用bitbake新编译了程序，那么需要使用下面命令重建index，否则客服端找不到新的软件包：</p> 
<pre><code>bitbake package-index
</code></pre> 
<p>参考：</p> 
<p><a href="http://www.jumpnowtek.com/yocto/Using-your-build-workstation-as-a-remote-package-repository.html" rel="nofollow" title="Using a Yocto build workstation as a remote opkg repository">Using a Yocto build workstation as a remote opkg repository</a></p> 
<p><a href="https://www.kancloud.cn/digest/yocto/138638#" rel="nofollow" title="package-manager-white-paper.pdf">package-manager-white-paper.pdf</a></p> 
<h2><a name="t29"></a>(16): Yocto 制作SDK分发Toolchain 脱离Yocto环境开发</h2> 
<p>Yocto中SDK有两种：</p> 
<ol><li>只有Toolchain，或者Toolchain+某类GUI特性</li><li>有针对某个Distribution的SDK，即含有Toolchian也含有这个Distrbutition特殊的文件</li></ol> 
<p>下面分别说明。</p> 
<h3><a name="t30"></a><a id="_7"></a><br> 第一类</h3> 
<p>这类的软件包有如下这些：</p> 
<p><img alt="" src="https://images2.imgbox.com/15/ea/mlCE7bco_o.png"></p> 
<p>其实就是两类：</p> 
<ol><li>meta-toolchain</li><li>meta-toolchain-qt/qte/qt5</li></ol> 
<p>后者包含了qt相关的东西，qte是面向embed的，如果需要做qt相关的application开发，那么包含qt的是合适的选择，否则仅仅开发普通application，那么使用meta-toolchian即可。</p> 
<h3><a name="t31"></a><a id="_23"></a><br> 第二类</h3> 
<p>这类SDK才是推荐使用的，这个在distribution的task中有一个特别的任务，专门用来制作这个SDK，叫做populate_sdk，例如对应要制作一个fsl-image-qt5 目标的Distribution（也叫做image），那么可以这样子：</p> 
<pre><code>bitbake fsl-image-qt5 -c populate_sdk
</code></pre> 
<p>这两类制作完成后，可以在deploy中看到了：<br><img alt="" src="https://images2.imgbox.com/37/33/JMky7wJE_o.png"></p> 
<p>其中xml文件是SDK包含了的文件列表。</p> 
<h3><a name="t32"></a><a id="SDK_41"></a><br> SDK的安装</h3> 
<p>因为SDK文件是sh脚本+压缩的文件内容组成的，所以直接运行即可，例如：</p> 
<p><img alt="" src="https://images2.imgbox.com/b5/dc/NXJU6BKT_o.png"></p> 
<p>在prompt提示中，输入安装的路径。</p> 
<h2><a name="t33"></a>(17): Yocto License问题:restricted license not whitelisted in LICENSE_FLAGS_WHITELIST</h2> 
<p>Yocto中可以配置一个Distrbution的License，然后所有的软件包，都需要符合这个license才可以被shipped到image中，如果我们需要使用违反此license的软件包，那么就需要额外配置。</p> 
<p>例如，在bitbake编译vlc的时候出现下面的错误log：</p> 
<pre></pre> 
<ol><li> <p><code>$ bitbake vlc</code></p> </li><li> <p><code>Parsing recipes: 100% |###################################################################################################################################| Time: 00:00:26</code></p> </li><li> <p><code>Parsing of 2029 .bb files complete (0 cached, 2029 parsed). 2524 targets, 210 skipped, 1 masked, 0 errors.</code></p> </li><li> <p><code>NOTE: Resolving any missing task queue dependencies</code></p> </li><li> <p><code>ERROR: Nothing PROVIDES 'ffmpeg' (but /media/work/iMX6/Yocto/sources/meta-openembedded/meta-multimedia/recipes-multimedia/vlc/vlc_2.1.4.bb DEPENDS on or otherwise requires it)</code></p> </li><li> <p><code>ERROR: libav PROVIDES ffmpeg but was skipped: because it has a restricted license not whitelisted in LICENSE_FLAGS_WHITELIST</code></p> </li><li> <p><code>ERROR: libav PROVIDES ffmpeg but was skipped: because it has a restricted license not whitelisted in LICENSE_FLAGS_WHITELIST</code></p> </li><li> <p><code>ERROR: Required build target 'vlc' has no buildable providers.</code></p> </li><li> <p><code>Missing or unbuildable dependency chain was: ['vlc', 'ffmpeg']</code></p> </li><li></ol> 
<p>那么就是因为vlc依赖libav，但是libav，的license不符合Distribution的License而无法编译。在libav中的bb文件配置中，可以看到其license flag为commercial：<br><img alt="" src="https://images2.imgbox.com/1a/2e/ypBDLnOT_o.png"></p> 
<h3><a name="t34"></a><a id="commercial_license_22"></a><br> 开启接受所有的commercial license软件包</h3> 
<p>因此如果我们需要添加一些commercial Lincense的软件包，就需要添加对commercial的支持，只需要在local.conf中添加一行即可：</p> 
<pre><code>LICENSE_FLAGS_WHITELIST="commercial"
</code></pre> 
<h3><a name="t35"></a><a id="commercial_license_31"></a><br> 只接受特定的commercial license软件包</h3> 
<p>但是如果我们只期望某些特殊的commercial软件包可以被编译放入到rootfs中，那么我们就需要逐个指定，例如指定libav等包可以被编译：</p> 
<p><img alt="" src="https://images2.imgbox.com/50/07/25eIZC0i_o.png"></p> 
<h2><a name="t36"></a>(18): Yocto SDK Toolchian中静态库的添加</h2> 
<h3><a name="t37"></a><a id="Toolchian_0"></a><br> Toolchian中静态库的添加</h3> 
<p>没有静态库，是无法静态编译应用程序的，因此，为了方便，还需要在SDK中添加静态库，例如libc。</p> 
<p>这个特性在只需要开启即可，在local.conf中添加一行：</p> 
<p>SDKIMAGE_FEATURES_append = "staticdev-pkgs"</p> 
<p><img alt="" src="https://images2.imgbox.com/e1/b0/DtAMLwNS_o.png"></p> 
<h3><a name="t38"></a><a id="Toolchian_11"></a><br> Toolchian中静态库的验证</h3> 
<p>然后重新build SDK，并安装SDK之后，我们可以验证其是否存在。</p> 
<p>首先source env，导入各种bash变量：</p> 
<p>source ../qt5_sdk/environment-setup-cortexa9hf-vfp-neon-poky-linux-gnueabi</p> 
<p>然后确认libgcc.a是否exist：</p> 
<p>$CC -print-file-name=libgcc.a</p> 
<p>如果输出的存在，那么就有了，例如：</p> 
<p><img alt="" src="https://images2.imgbox.com/a7/c9/hCJ2lhwn_o.png"></p> 
<h2><a name="t39"></a>(19): Yocto SDK Toolchian的使用</h2> 
<p>在使用之前需要先source env，导入各种环境变量(注意将路径变更成你自己的)：</p> 
<pre><code>source ../qt5_sdk/environment-setup-cortexa9hf-vfp-neon-poky-linux-gnueabi
</code></pre> 
<p>然后我们可以查看一下bash的env了，下面是多出来的一些env，直接在bash中输入export即可看到：</p> 
<pre><code class="language-cpp">    declare -x AR="arm-poky-linux-gnueabi-ar"

    declare -x ARCH="arm"

    declare -x AS="arm-poky-linux-gnueabi-as "

    declare -x CC="arm-poky-linux-gnueabi-gcc -march=armv7-a -mthumb-interwork -mfloat-abi=hard -mfpu=neon -mtune=cortex-a9 --sysroot=/media/work/iMX6/Yocto/qt5_sdk/sysroots

    /cortexa9hf-vfp-neon-poky-linux-gnueabi"

    declare -x CFLAGS=" -O2 -pipe -g -feliminate-unused-debug-types"

    declare -x CONFIGURE_FLAGS="--target=arm-poky-linux-gnueabi --host=arm-poky-linux-gnueabi --build=x86_64-linux --with-libtool-sysroot=/media/work/iMX6/Yocto/qt5_sdk/sysro

    ots/cortexa9hf-vfp-neon-poky-linux-gnueabi"

    declare -x CONFIG_SITE="/media/work/iMX6/Yocto/qt5_sdk/site-config-cortexa9hf-vfp-neon-poky-linux-gnueabi"

    declare -x CPP="arm-poky-linux-gnueabi-gcc -E -march=armv7-a -mthumb-interwork -mfloat-abi=hard -mfpu=neon -mtune=cortex-a9 --sysroot=/media/work/iMX6/Yocto/qt5_sdk/sysr

    oots/cortexa9hf-vfp-neon-poky-linux-gnueabi"

    declare -x CPPFLAGS=""

    declare -x CROSS_COMPILE="arm-poky-linux-gnueabi-"

    declare -x CXX="arm-poky-linux-gnueabi-g++ -march=armv7-a -mthumb-interwork -mfloat-abi=hard -mfpu=neon -mtune=cortex-a9 --sysroot=/media/work/iMX6/Yocto/qt5_sdk/sysroot

    s/cortexa9hf-vfp-neon-poky-linux-gnueabi"

    declare -x CXXFLAGS=" -O2 -pipe -g -feliminate-unused-debug-types"

    declare -x M4="m4"

    declare -x MANDATORY_PATH="/usr/share/gconf/kde-plasma.mandatory.path"

    declare -x NM="arm-poky-linux-gnueabi-nm"

    declare -x OBJCOPY="arm-poky-linux-gnueabi-objcopy"

    declare -x OBJDUMP="arm-poky-linux-gnueabi-objdump"

    declare -x OECORE_ACLOCAL_OPTS="-I /media/work/iMX6/Yocto/qt5_sdk/sysroots/x86_64-pokysdk-linux/usr/share/aclocal"

    declare -x OECORE_DISTRO_VERSION="1.7"

    declare -x OECORE_NATIVE_SYSROOT="/media/work/iMX6/Yocto/qt5_sdk/sysroots/x86_64-pokysdk-linux"

    declare -x OECORE_SDK_VERSION="1.7"

    declare -x OECORE_TARGET_SYSROOT="/media/work/iMX6/Yocto/qt5_sdk/sysroots/cortexa9hf-vfp-neon-poky-linux-gnueabi"

    declare -x OLDPWD="/media/work/iMX6/Yocto/video2lcd_arm/test"

    declare -x PATH="/media/work/iMX6/Yocto/qt5_sdk/sysroots/x86_64-pokysdk-linux/usr/bin:/media/work/iMX6/Yocto/qt5_sdk/sysroots/x86_64-pokysdk-linux/usr/bin/arm-poky-linux-gnueabi:/home/hexiongjun/bin:/usr/lib/lightdm/lightdm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/home/hexiongjun/010editor:/home/hexiongjun/010editor"

    declare -x PKG_CONFIG_PATH="/media/work/iMX6/Yocto/qt5_sdk/sysroots/cortexa9hf-vfp-neon-poky-linux-gnueabi/usr/lib/pkgconfig"

    declare -x PKG_CONFIG_SYSROOT_DIR="/media/work/iMX6/Yocto/qt5_sdk/sysroots/cortexa9hf-vfp-neon-poky-linux-gnueabi"

    declare -x PWD="/media/work/iMX6/Yocto/video2lcd_arm"

    declare -x PYTHONHOME="/media/work/iMX6/Yocto/qt5_sdk/sysroots/x86_64-pokysdk-linux/usr"

    declare -x QMAKESPEC="/home/hexiongjun/github/BBB/SDK/ti-sdk-am335x-evm-05.07.00.00/linux-devkit/arm-arago-linux-gnueabi/usr/share/qtopia/mkspecs/linux-g++"

    declare -x QT_IM_MODULE="fcitx"

    declare -x QT_PLUGIN_PATH="/home/hexiongjun/.kde/lib/kde4/plugins/:/usr/lib/kde4/plugins/"

    declare -x RANLIB="arm-poky-linux-gnueabi-ranlib"

    declare -x SDKTARGETSYSROOT="/media/work/iMX6/Yocto/qt5_sdk/sysroots/cortexa9hf-vfp-neon-poky-linux-gnueabi"

    declare -x SESSION_MANAGER="local/hexiongjun-pc:@/tmp/.ICE-unix/3595,unix/hexiongjun-pc:/tmp/.ICE-unix/3595"

</code></pre> 
<p></p> 
<h3><a name="t40"></a><a id="_51"></a><br> 注意点</h3> 
<p>其中我们重点需要关注的是与编译相关的变量：</p> 
<ol><li>CC/LD等编译相关</li><li>ARCH/CROSS_COMPILE等croos编译相关</li></ol> 
<p>可以看到CC已经被重定义为cross toolchain了，而ARCH和CROSS_COMPILE也悉心的帮我们配置成了对应的。</p> 
<p>因此，其实如果我们需要交叉编译一个app，那么很多变量将不再需要自己手动设定了。</p> 
<p>同时因为各种tuning的指定，我们必须注意和硬件的匹配。例如这里指定了为cortex-a9而优化。</p> 
<h3><a name="t41"></a><a id="_66"></a><br> 如何使用</h3> 
<p>最好的方法就是使用变量来使用Toolchian，例如使用$CC而不是使用arm-poky-XXX-gcc，因为我们可以看到CC其实是对arm-xxx-gcc添加了一些配置：</p> 
<pre></pre> 
<ol><li> <p><code>CC="arm-poky-linux-gnueabi-gcc -march=armv7-a -mthumb-interwork -mfloat-abi=hard -mfpu=neon -mtune=cortex-a9 --sysroot=/media/work/iMX6/Yocto/qt5_sdk/sysroots</code></p> </li><li> <p><code>/cortexa9hf-vfp-neon-poky-linux-gnueabi"</code></p> </li></ol> 
<p>其中最为核心的是sysroot这个选项，这个选项将告诉toolchian去哪里查找库与头文件，而如果不指定这个，那么就会出现问题，例如，我们直接使用arm-poky-gnueabi-gcc来编译：</p> 
<pre></pre> 
<ol><li> <p><code>$ make</code></p> </li><li> <p><code>make -C ./ -f /media/work/iMX6/Yocto/video2lcd_arm/Makefile.build</code></p> </li><li> <p><code>make[1]: Entering directory `/media/work/iMX6/Yocto/video2lcd_arm'</code></p> </li><li> <p><code>make -C convert -f /media/work/iMX6/Yocto/video2lcd_arm/Makefile.build</code></p> </li><li> <p><code>make[2]: Entering directory `/media/work/iMX6/Yocto/video2lcd_arm/convert'</code></p> </li><li> <p><code>arm-poky-linux-gnueabi-gcc -Wall -Werror -O2 -g -I /media/work/iMX6/Yocto/video2lcd_arm/include -I /media/work/iMX6/Yocto/imx6qsabresd_build/tmp/work/imx6qsabresd-poky-linux-gnueabi/fsl-image-qt5/1.0-r0/rootfs/usr/include/ -Wp,-MD,.convert_manager.o.d -c -o convert_manager.o convert_manager.c</code></p> </li><li> <p><code>In file included from /media/work/iMX6/Yocto/imx6qsabresd_build/tmp/work/imx6qsabresd-poky-linux-gnueabi/fsl-image-qt5/1.0-r0/rootfs/usr/include/features.h:389:0,</code></p> </li><li> <p><code>from /media/work/iMX6/Yocto/imx6qsabresd_build/tmp/work/imx6qsabresd-poky-linux-gnueabi/fsl-image-qt5/1.0-r0/rootfs/usr/include/stdio.h:27,</code></p> </li><li> <p><code>from /media/work/iMX6/Yocto/video2lcd_arm/include/config.h:5,</code></p> </li><li> <p><code>from convert_manager.c:2:</code></p> </li><li> <p><code>/media/work/iMX6/Yocto/imx6qsabresd_build/tmp/work/imx6qsabresd-poky-linux-gnueabi/fsl-image-qt5/1.0-r0/rootfs/usr/include/gnu/stubs.h:7:29: fatal error: gnu/stubs-soft.h: No such file or directory</code></p> </li><li> <p><code># include &lt;gnu/stubs-soft.h&gt;</code></p> </li><li> <p><code>^</code></p> </li><li> <p><code>compilation terminated.</code></p> </li><li> <p><code>make[2]: *** [convert_manager.o] Error 1</code></p> </li><li> <p><code>make[2]: Leaving directory `/media/work/iMX6/Yocto/video2lcd_arm/convert'</code></p> </li><li> <p><code>make[1]: *** [convert] Error 2</code></p> </li><li> <p><code>make[1]: Leaving directory `/media/work/iMX6/Yocto/video2lcd_arm'</code></p> </li><li> <p><code>make: *** [all] Error 2</code></p> </li></ol> 
<p></p> 
<p>可以看到提示说找不到一些标准的头文件，其实这个是因为我们没有添加一些指定的选择来告诉其使用stubs-hard.h，所以默认的去查找stubs-soft.h。</p> 
<p>例如我们编译一个helloworld，那么可以按照如下编译：</p> 
<pre><code>$CC hello.c -o hello
</code></pre> 
<p>这样将省去了诸多选项的手动指定，也不会出问题。</p> 
<p>转自：<a class="link-info has-card" href="https://www.kancloud.cn/digest/yocto/138623" rel="nofollow" title="yocto使用技巧"><span class="link-card-box"><span class="link-title">yocto使用技巧</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/04/8f/Aw6xiD60_o.png" alt="icon-default.png?t=M666">https://www.kancloud.cn/digest/yocto/138623</span></span></a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6e22dde7f80e1056a674ce02a0294f86/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java多线程Future.cancel(true)取消线程，线程还是会执行catch与finally里面的代码，只要资源回收的代码没有乱写，不必担心资源回收问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8bea5ff68e4041feaa6e8b6f1ed54969/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【测试】 FIO：ceph/磁盘IO测试工具 fio（iodepth深度）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>