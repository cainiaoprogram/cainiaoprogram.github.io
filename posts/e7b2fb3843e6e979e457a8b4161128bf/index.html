<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python机器学习——模型评估与选择 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python机器学习——模型评估与选择" />
<meta property="og:description" content="Python机器学习——模型评估与选择 第6关：准确度的陷阱与混淆矩阵任务描述相关知识准确度的缺陷混淆矩阵 编程要求 第7关：精准率与召回率任务描述相关知识精准率召回率精准率与召回率之间的关系应该选精准率还是召回率作为性能指标？ 编程要求 第8关：F1 Score任务描述相关知识F1 Score 编程要求 第9关：ROC曲线与AUC任务描述相关知识ROC曲线AUC 编程要求 第10关：sklearn中的分类性能指标任务描述相关知识accu\fracy_scoreprecision_scorerecall_scoref1_scoreroc_auc_score 编程要求测试说明 第6关：准确度的陷阱与混淆矩阵 任务描述 本关任务:填写 python 代码，完成 confusion_matrix 函数实现二分类混淆矩阵的构建。
相关知识 准确度的缺陷 准确度这个概念相信对于大家来说肯定并不陌生，就是正确率。例如模型的预测结果与数据真实结果如下表所示：
编号预测结果真实结果112222333411523 很明显，连小朋友都能算出来该模型的准确度为 3/5。
那么准确对越高就能说明模型的分类性能越好吗？非也！举个例子，现在我开发了一套癌症检测系统，只要输入你的一些基本健康信息，就能预测出你现在是否患有癌症，并且分类的准确度为 0.999。您认为这样的系统的预测性能好不好呢？
您可能会觉得，哇，这么高的准确度！这个系统肯定很牛逼！但是我们知道，一般年轻人患癌症的概率非常低，假设患癌症的概率为 0.001，那么其实我这个癌症检测系统只要一直输出您没有患癌症，准确度也可能能够达到 0.999。
假如现在有一个人本身已经患有癌症，但是他自己不知道自己患有癌症。这个时候用我的癌症检测系统检测发现他没有得癌症，那很显然我这个系统已经把他给坑了（耽误了治疗）。看到这里您应该已经体会到了，一个分类模型如果光看准确度是不够的，尤其是对这种样本极度不平衡的情况（ 10000 条健康信息数据中，只有 1 条的类别是患有癌症，其他的类别都是健康）。
混淆矩阵 想进一步的考量分类模型的性能如何，可以使用其他的一些性能指标，例如精准率和召回率。但这些指标计算的基础是混淆矩阵。
继续以癌症检测系统为例，癌症检测系统的输出不是有癌症就是健康，这里为了方便，就用 1 表示患有癌症，0 表示健康。假设现在拿 10000 条数据来进行测试，其中有 9978 条数据的真实类别是 0，系统预测的类别也是 0，有 2 条数据的真实类别是 1 却预测成了 0，有 12 条数据的真实类别是 0 但预测成了 1，有 8 条数据的真实类别是 1，预测结果也是 1。
如果我们把这些结果组成如下矩阵，则该矩阵就成为混淆矩阵。
真实预测010997812128 混淆矩阵中每个格子所代表的的意义也很明显，意义如下：
真实预测010预测0正确的数量预测1错误的数量1预测0错误的数量预测1正确的数量 如果将正确看成是 True，错误看成是 False， 0 看成是 Negtive， 1 看成是 Positive。然后将上表中的文字替换掉，混淆矩阵如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e7b2fb3843e6e979e457a8b4161128bf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-04-03T12:58:44+08:00" />
<meta property="article:modified_time" content="2020-04-03T12:58:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python机器学习——模型评估与选择</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Python机器学习——模型评估与选择</h4> 
 <ul><li><a href="#6_1" rel="nofollow">第6关：准确度的陷阱与混淆矩阵</a></li><li><ul><li><a href="#_2" rel="nofollow">任务描述</a></li><li><a href="#_4" rel="nofollow">相关知识</a></li><li><ul><li><a href="#_5" rel="nofollow">准确度的缺陷</a></li><li><a href="#_23" rel="nofollow">混淆矩阵</a></li></ul> 
   </li><li><a href="#_83" rel="nofollow">编程要求</a></li></ul> 
  </li><li><a href="#7_121" rel="nofollow">第7关：精准率与召回率</a></li><li><ul><li><a href="#_122" rel="nofollow">任务描述</a></li><li><a href="#_124" rel="nofollow">相关知识</a></li><li><ul><li><a href="#_125" rel="nofollow">精准率</a></li><li><a href="#_140" rel="nofollow">召回率</a></li><li><a href="#_155" rel="nofollow">精准率与召回率之间的关系</a></li><li><a href="#_164" rel="nofollow">应该选精准率还是召回率作为性能指标？</a></li></ul> 
   </li><li><a href="#_171" rel="nofollow">编程要求</a></li></ul> 
  </li><li><a href="#8F1_Score_223" rel="nofollow">第8关：F1 Score</a></li><li><ul><li><a href="#_224" rel="nofollow">任务描述</a></li><li><a href="#_226" rel="nofollow">相关知识</a></li><li><ul><li><a href="#F1_Score_227" rel="nofollow">F1 Score</a></li></ul> 
   </li><li><a href="#_244" rel="nofollow">编程要求</a></li></ul> 
  </li><li><a href="#9ROCAUC_273" rel="nofollow">第9关：ROC曲线与AUC</a></li><li><ul><li><a href="#_274" rel="nofollow">任务描述</a></li><li><a href="#_276" rel="nofollow">相关知识</a></li><li><ul><li><a href="#ROC_277" rel="nofollow">ROC曲线</a></li><li><a href="#AUC_314" rel="nofollow">AUC</a></li></ul> 
   </li><li><a href="#_343" rel="nofollow">编程要求</a></li></ul> 
  </li><li><a href="#10sklearn_383" rel="nofollow">第10关：sklearn中的分类性能指标</a></li><li><ul><li><a href="#_384" rel="nofollow">任务描述</a></li><li><a href="#_386" rel="nofollow">相关知识</a></li><li><ul><li><a href="#accufracy_score_387" rel="nofollow">accu\fracy_score</a></li><li><a href="#precision_score_400" rel="nofollow">precision_score</a></li><li><a href="#recall_score_414" rel="nofollow">recall_score</a></li><li><a href="#f1_score_428" rel="nofollow">f1_score</a></li><li><a href="#roc_auc_score_442" rel="nofollow">roc_auc_score</a></li></ul> 
   </li><li><a href="#_462" rel="nofollow">编程要求</a></li><li><a href="#_469" rel="nofollow">测试说明</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="6_1"></a>第6关：准确度的陷阱与混淆矩阵</h2> 
<h3><a id="_2"></a>任务描述</h3> 
<p>本关任务:填写 python 代码，完成 confusion_matrix 函数实现二分类混淆矩阵的构建。</p> 
<h3><a id="_4"></a>相关知识</h3> 
<h4><a id="_5"></a>准确度的缺陷</h4> 
<p>准确度这个概念相信对于大家来说肯定并不陌生，就是正确率。例如模型的预测结果与数据真实结果如下表所示：</p> 
<table><thead><tr><th>编号</th><th>预测结果</th><th>真实结果</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>2</td></tr><tr><td>2</td><td>2</td><td>2</td></tr><tr><td>3</td><td>3</td><td>3</td></tr><tr><td>4</td><td>1</td><td>1</td></tr><tr><td>5</td><td>2</td><td>3</td></tr></tbody></table> 
<p>很明显，连小朋友都能算出来该模型的准确度为 3/5。</p> 
<p>那么准确对越高就能说明模型的分类性能越好吗？非也！举个例子，现在我开发了一套癌症检测系统，只要输入你的一些基本健康信息，就能预测出你现在是否患有癌症，并且分类的准确度为 0.999。您认为这样的系统的预测性能好不好呢？</p> 
<p>您可能会觉得，哇，这么高的准确度！这个系统肯定很牛逼！但是我们知道，一般年轻人患癌症的概率非常低，假设患癌症的概率为 0.001，那么其实我这个癌症检测系统只要一直输出您没有患癌症，准确度也可能能够达到 0.999。</p> 
<p>假如现在有一个人本身已经患有癌症，但是他自己不知道自己患有癌症。这个时候用我的癌症检测系统检测发现他没有得癌症，那很显然我这个系统已经把他给坑了（耽误了治疗）。看到这里您应该已经体会到了，一个分类模型如果光看准确度是不够的，尤其是对这种样本极度不平衡的情况（ 10000 条健康信息数据中，只有 1 条的类别是患有癌症，其他的类别都是健康）。</p> 
<h4><a id="_23"></a>混淆矩阵</h4> 
<p>想进一步的考量分类模型的性能如何，可以使用其他的一些性能指标，例如精准率和召回率。但这些指标计算的基础是<strong>混淆矩阵</strong>。</p> 
<p>继续以癌症检测系统为例，癌症检测系统的输出不是有癌症就是健康，这里为了方便，就用 1 表示患有癌症，0 表示健康。假设现在拿 10000 条数据来进行测试，其中有 9978 条数据的真实类别是 0，系统预测的类别也是 0，有 2 条数据的真实类别是 1 却预测成了 0，有 12 条数据的真实类别是 0 但预测成了 1，有 8 条数据的真实类别是 1，预测结果也是 1。</p> 
<p>如果我们把这些结果组成如下矩阵，则该矩阵就成为<strong>混淆矩阵</strong>。</p> 
<table><thead><tr><th>真实预测</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>9978</td><td>12</td></tr><tr><td>1</td><td>2</td><td>8</td></tr></tbody></table> 
<p>混淆矩阵中每个格子所代表的的意义也很明显，意义如下：</p> 
<table><thead><tr><th>真实预测</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>预测0正确的数量</td><td>预测1错误的数量</td></tr><tr><td>1</td><td>预测0错误的数量</td><td>预测1正确的数量</td></tr></tbody></table> 
<p>如果将正确看成是 True，错误看成是 False， 0 看成是 Negtive， 1 看成是 Positive。然后将上表中的文字替换掉，混淆矩阵如下：</p> 
<table><thead><tr><th>真实预测</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>TN</td><td>FP</td></tr><tr><td>1</td><td>FN</td><td>TP</td></tr></tbody></table> 
<p>因此 TN 表示真实类别是 Negtive，预测结果也是 Negtive 的数量； FP 表示真实类别是 Negtive，预测结果是 Positive 的数量； FN 表示真实类别是 Positive，预测结果是 Negtive 的数量；TP 表示真实类别是 Positive，预测结果也是 Positive 的数量。</p> 
<p>很明显，当 FN 和 FP 都等于 0 时，模型的性能应该是最好的，因为模型并没有在预测的时候犯错误。即如下混淆矩阵：</p> 
<table><thead><tr><th>真实预测</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>9978</td><td>0</td></tr><tr><td>1</td><td>0</td><td>22</td></tr></tbody></table> 
<p><strong>所以模型分类性能越好，混淆矩阵中非对角线上的数值越小。</strong></p> 
<p>代码示例：</p> 
<pre><code class="prism language-python"><span class="token keyword">def</span> <span class="token function">confusion_matrix</span><span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_predict<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token keyword">def</span> <span class="token function">TN</span><span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_predict<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y_true <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>y_predict <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	
	<span class="token keyword">def</span> <span class="token function">FP</span><span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_predict<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y_true <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>y_predict <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token keyword">def</span> <span class="token function">FN</span><span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_predict<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y_true <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>y_predict <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token keyword">def</span> <span class="token function">TP</span><span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_predict<span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y_true <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>y_predict <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token keyword">return</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>
		<span class="token punctuation">[</span>TN<span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_predict<span class="token punctuation">)</span><span class="token punctuation">,</span> FP<span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_predict<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
		<span class="token punctuation">[</span>FN<span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_predict<span class="token punctuation">)</span><span class="token punctuation">,</span> TP<span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_predict<span class="token punctuation">)</span><span class="token punctuation">]</span>
	<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="_83"></a>编程要求</h3> 
<p>根据提示，在 Begin-End 区域填写 python 代码，完成 confusion_matrix 函数实现二分类混淆矩阵的构建。<br> confusion_matrix 函数中的参数：</p> 
<ul><li>y_true：数据的真实类别，类型为 ndarray；</li><li>y_predict：模型预测的类别，类型为 ndarray。</li></ul> 
<p>测试输入：<br> {‘y_true’:[1, 0, 0, 1, 0, 1, 0], ‘y_predict’:[0, 1, 0, 1, 0, 1, 0]}<br> 预期输出：<br> [[3 1]<br> [1 2]]</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

<span class="token keyword">def</span> <span class="token function">confusion_matrix</span><span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_predict<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token triple-quoted-string string">'''
	构建二分类的混淆矩阵，并将其返回
	:param y_true: 真实类别，类型为ndarray
	:param y_predict: 预测类别，类型为ndarray
	:return: shape为(2, 2)的ndarray

	'''</span>
	<span class="token comment">#********* Begin *********#</span>
	TN <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y_true <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>y_predict <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	FP <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y_true <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>y_predict <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	FN <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y_true <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>y_predict <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	TP <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y_true <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>y_predict <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token keyword">return</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span>
		<span class="token punctuation">[</span>TN<span class="token punctuation">,</span> FP<span class="token punctuation">]</span><span class="token punctuation">,</span>
		<span class="token punctuation">[</span>FN<span class="token punctuation">,</span> TP<span class="token punctuation">]</span>
	<span class="token punctuation">]</span><span class="token punctuation">)</span>
	<span class="token comment">#********* End *********#</span>
</code></pre> 
<h2><a id="7_121"></a>第7关：精准率与召回率</h2> 
<h3><a id="_122"></a>任务描述</h3> 
<p>本关任务:填写 python 代码，完成 precision_score 函数和 recall_score 函数分别实现计算精准率和召回率。</p> 
<h3><a id="_124"></a>相关知识</h3> 
<h4><a id="_125"></a>精准率</h4> 
<p><strong>精准率(Precision)</strong> 指的是模型预测为 Positive 时的预测准确度，其计算公式如下：</p> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          P 
         
        
          r 
         
        
          e 
         
        
          c 
         
        
          i 
         
        
          s 
         
        
          i 
         
        
          o 
         
        
          n 
         
        
          = 
         
         
          
          
            T 
           
          
            P 
           
          
          
          
            T 
           
          
            P 
           
          
            + 
           
          
            F 
           
          
            P 
           
          
         
        
       
         Precision = \frac{TP}{TP+FP} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.13em;">P</span><span class="mord mathdefault" style="margin-right: 0.02em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.27em;"></span></span><span class="base"><span class="strut" style="height: 2.12em; vertical-align: -0.76em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.36em;"><span style="top: -2.31em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13em;">T</span><span class="mord mathdefault" style="margin-right: 0.13em;">P</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mord mathdefault" style="margin-right: 0.13em;">F</span><span class="mord mathdefault" style="margin-right: 0.13em;">P</span></span></span><span style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span style="top: -3.67em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13em;">T</span><span class="mord mathdefault" style="margin-right: 0.13em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.76em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p> 
<p>假如癌症检测系统的混淆矩阵如下：</p> 
<table><thead><tr><th>真实预测</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>9978</td><td>12</td></tr><tr><td>1</td><td>2</td><td>8</td></tr></tbody></table> 
<p>则该系统的精准率 = 8/(8+12) = 0.4。<br> 0.4 这个值表示癌症检测系统的预测结果中如果有 100 个人被预测成患有癌症，那么其中有 40 人是真的患有癌症。<strong>也就是说，精准率越高，那么癌症检测系统预测某人患有癌症的可信度就越高。</strong></p> 
<h4><a id="_140"></a>召回率</h4> 
<p><strong>召回率(Recall)</strong> 指的是我们关注的事件发生了，并且模型预测正确了的比值，其计算公式如下：</p> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          R 
         
        
          e 
         
        
          c 
         
        
          a 
         
        
          l 
         
        
          l 
         
        
          = 
         
         
          
          
            T 
           
          
            P 
           
          
          
          
            F 
           
          
            N 
           
          
            + 
           
          
            T 
           
          
            P 
           
          
         
        
       
         Recall = \frac{TP}{FN+TP} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0em;">R</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right: 0.01em;">l</span><span class="mord mathdefault" style="margin-right: 0.01em;">l</span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.27em;"></span></span><span class="base"><span class="strut" style="height: 2.12em; vertical-align: -0.76em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.36em;"><span style="top: -2.31em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13em;">F</span><span class="mord mathdefault" style="margin-right: 0.1em;">N</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mord mathdefault" style="margin-right: 0.13em;">T</span><span class="mord mathdefault" style="margin-right: 0.13em;">P</span></span></span><span style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span style="top: -3.67em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13em;">T</span><span class="mord mathdefault" style="margin-right: 0.13em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.76em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p> 
<p>假如癌症检测系统的混淆矩阵如下：</p> 
<table><thead><tr><th>真实预测</th><th>0</th><th>1</th></tr></thead><tbody><tr><td>0</td><td>9978</td><td>12</td></tr><tr><td>1</td><td>2</td><td>8</td></tr></tbody></table> 
<p>则该系统的召回率 = 8/(8+2) = 0.8。<br> 从计算出的召回率可以看出，假设有 100 个患有癌症的病人使用这个系统进行癌症检测，系统能够检测出 80 人是患有癌症的。<strong>也就是说，召回率越高，那么我们感兴趣的对象成为漏网之鱼的可能性越低。</strong></p> 
<h4><a id="_155"></a>精准率与召回率之间的关系</h4> 
<p>假设有这么一组数据，菱形代表 Positive，圆形代表 Negtive 。</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/91/7c/Kqs1Tbn8_o.png"><br> 现在需要训练一个模型对数据进行分类，假如该模型非常简单，就是在数据上画一条线作为分类边界。模型认为边界的左边是 Negtive，右边是 Positive。如果该模型的分类边界向左或者向右移动的话，模型所对应的精准率和召回率如下图所示：</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/a6/b4/BHUCNL5e_o.png"><br> 从上图可知，<strong>模型的精准率变高，召回率会变低，精准率变低，召回率会变高</strong>。</p> 
<h4><a id="_164"></a>应该选精准率还是召回率作为性能指标？</h4> 
<p>到底应该使用精准率还是召回率作为性能指标，其实是<strong>根据具体业务来决定的</strong>。</p> 
<p>比如我现在想要训练一个模型来预测我关心的股票是涨( Positive )还是跌( Negtive )，那么<strong>我们应该主要使用精准率作为性能指标</strong>。因为精准率高的话，则模型预测该股票要涨的可信度就高（很有可能赚钱！）。</p> 
<p>比如现在需要训练一个模型来预测人是( Positive )否( Negtive )患有艾滋病，那么<strong>我们应该主要使用召回率作为性能指标</strong>。因为召回率太低的话，很有可能存在漏网之鱼（可能一个人本身患有艾滋病，但预测成了健康），这样就很可能导致病人错过了最佳的治疗时间，这是非常致命的。</p> 
<h3><a id="_171"></a>编程要求</h3> 
<p>根据提示，在 Begin-End 区域填写 python 代码，完成 precision_score 函数和 recall_score 函数分别实现计算精准率和召回率。</p> 
<p><code>precision_score</code> 函数中的参数:</p> 
<ul><li>y_true ：数据的真实类别，类型为 ndarray；</li><li>y_predict ：模型预测的类别，类型为 ndarray。</li></ul> 
<p><code>recall_score</code> 函数中的参数:</p> 
<ul><li>y_true：数据的真实类别，类型为 ndarray；</li><li>y_predict：模型预测的类别，类型为 ndarray。</li></ul> 
<p>测试输入：<br> {‘y_true’:[1, 0, 0, 1, 0, 1, 0], ‘y_predict’:[0, 1, 0, 1, 0, 1, 0]}</p> 
<p>预期输出：<br> 0.666667, 0.666667</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

<span class="token keyword">def</span> <span class="token function">precision_score</span><span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_predict<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token triple-quoted-string string">'''
	计算精准率并返回
	:param y_true: 真实类别，类型为ndarray
	:param y_predict: 预测类别，类型为ndarray
	:return: 精准率，类型为float
	'''</span>
	<span class="token comment">#********* Begin *********#</span>
	TP <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y_true <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>y_predict <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	FP <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y_true <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>y_predict <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	Precision <span class="token operator">=</span> TP<span class="token operator">/</span><span class="token punctuation">(</span>TP<span class="token operator">+</span>FP<span class="token punctuation">)</span>
	<span class="token keyword">return</span> Precision
	<span class="token comment">#********* End *********#</span>

<span class="token keyword">def</span> <span class="token function">recall_score</span><span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_predict<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token triple-quoted-string string">'''
	计算召回率并召回
	:param y_true: 真实类别，类型为ndarray
	:param y_predict: 预测类别，类型为ndarray
	:return: 召回率，类型为float
	'''</span>
	<span class="token comment">#********* Begin *********#</span>
	TP <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y_true <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>y_predict <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	FN <span class="token operator">=</span> np<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y_true <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token punctuation">(</span>y_predict <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	Recall <span class="token operator">=</span> TP<span class="token operator">/</span><span class="token punctuation">(</span>TP<span class="token operator">+</span>FN<span class="token punctuation">)</span>
	<span class="token keyword">return</span> Recall
	<span class="token comment">#********* End *********#</span>
</code></pre> 
<h2><a id="8F1_Score_223"></a>第8关：F1 Score</h2> 
<h3><a id="_224"></a>任务描述</h3> 
<p>本关任务:填写 python 代码，完成 f1_score 函数实现计算 F1 Score。</p> 
<h3><a id="_226"></a>相关知识</h3> 
<h4><a id="F1_Score_227"></a>F1 Score</h4> 
<p>上一关中提到了精准率变高，召回率会变低，精准率变低，召回率会变高。那如果想要同时兼顾精准率和召回率，这个时候就可以使用 F1 Score 来作为性能度量指标了。</p> 
<p>F1 Score 是统计学中用来衡量二分类模型精确度的一种指标。它同时兼顾了分类模型的准确率和召回率。 F1 Score 可以看作是模型准确率和召回率的一种加权平均，它的最大值是 1，最小值是 0。其公式如下：</p> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          F 
         
        
          1 
         
        
          = 
         
         
          
          
            2 
           
          
            ∗ 
           
          
            p 
           
          
            r 
           
          
            e 
           
          
            c 
           
          
            i 
           
          
            s 
           
          
            i 
           
          
            o 
           
          
            n 
           
          
            ∗ 
           
          
            r 
           
          
            e 
           
          
            c 
           
          
            a 
           
          
            l 
           
          
            l 
           
          
          
          
            p 
           
          
            r 
           
          
            e 
           
          
            c 
           
          
            i 
           
          
            s 
           
          
            i 
           
          
            o 
           
          
            n 
           
          
            + 
           
          
            r 
           
          
            e 
           
          
            c 
           
          
            a 
           
          
            l 
           
          
            l 
           
          
         
        
       
         F1 = \frac{2*precision*recall}{precision+recall} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.13em;">F</span><span class="mord">1</span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.27em;"></span></span><span class="base"><span class="strut" style="height: 2.25em; vertical-align: -0.88em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.37em;"><span style="top: -2.31em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right: 0.02em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mord mathdefault" style="margin-right: 0.02em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right: 0.01em;">l</span><span class="mord mathdefault" style="margin-right: 0.01em;">l</span></span></span><span style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span style="top: -3.67em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord">2</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right: 0.02em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mord mathdefault" style="margin-right: 0.02em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">c</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right: 0.01em;">l</span><span class="mord mathdefault" style="margin-right: 0.01em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.88em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p> 
<ul><li>假设模型 A 的精准率为 0.2，召回率为 0.7，那么模型 A 的 F1 Score 为 0.31111。</li><li>假设模型 B 的精准率为 0.7，召回率为 0.2，那么模型 B 的 F1 Score 为 0.31111。</li><li>假设模型 C 的精准率为 0.8，召回率为 0.7，那么模型 C 的 F1 Score 为 0.74667。</li><li>假设模型 D 的精准率为 0.2，召回率为 0.3，那么模型 D 的 F1 Score 为 0.24。</li></ul> 
<p>从上述 4 个模型的各种性能可以看出，模型C的精准率和召回率都比较高，因此它的 F1 Score 也比较高。而其他模型的精准率和召回率要么都比较低，要么一个低一个高，所以它们的 F1 Score 比较低。</p> 
<p>这也说明了只有当模型的精准率和召回率都比较高时 F1 Score 才会比较高。这也是 F1 Score 能够同时兼顾精准率和召回率的原因。</p> 
<h3><a id="_244"></a>编程要求</h3> 
<p>根据提示，在 Begin-End 区域填写 python 代码，完成 f1_score 函数实现计算 F1 Score。</p> 
<p>f1_score 函数中的参数:</p> 
<ul><li>precision：模型的精准率，类型为 float；</li><li>recall：模型的召回率，类型为 float。</li></ul> 
<p>一个测试用例（列表中的第一个数字表示精准率，第二个数字表示召回率）：<br> 测试输入：[0.7, 0.2]<br> 预期输出：0.311111</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

<span class="token keyword">def</span> <span class="token function">f1_score</span><span class="token punctuation">(</span>precision<span class="token punctuation">,</span> recall<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token triple-quoted-string string">'''
	计算f1 score并返回
	:param precision: 模型的精准率，类型为float
	:param recall: 模型的召回率，类型为float
	:return: 模型的f1 score，类型为float
	'''</span>
	<span class="token comment">#********* Begin *********#</span>
	f1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>precision<span class="token operator">*</span>recall<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span>precision<span class="token operator">+</span>recall<span class="token punctuation">)</span>
	<span class="token keyword">return</span> f1
	<span class="token comment">#********* End ***********#</span>
</code></pre> 
<h2><a id="9ROCAUC_273"></a>第9关：ROC曲线与AUC</h2> 
<h3><a id="_274"></a>任务描述</h3> 
<p>本关任务:填写 python 代码，完成 AUC 函数实现计算 AUC。</p> 
<h3><a id="_276"></a>相关知识</h3> 
<h4><a id="ROC_277"></a>ROC曲线</h4> 
<p>ROC曲线( Receiver Operating Cha\fracteristic Curve )描述的 TPR （ True Positive Rate ）与 FPR （ False Positive Rate ）之间关系的曲线。</p> 
<p>TPR 与 FPR 的计算公式如下：</p> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          T 
         
        
          P 
         
        
          R 
         
        
          = 
         
         
          
          
            T 
           
          
            P 
           
          
          
          
            T 
           
          
            P 
           
          
            + 
           
          
            F 
           
          
            N 
           
          
         
        
       
         TPR = \frac{TP}{TP+FN} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.13em;">T</span><span class="mord mathdefault" style="margin-right: 0.13em;">P</span><span class="mord mathdefault" style="margin-right: 0em;">R</span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.27em;"></span></span><span class="base"><span class="strut" style="height: 2.12em; vertical-align: -0.76em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.36em;"><span style="top: -2.31em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13em;">T</span><span class="mord mathdefault" style="margin-right: 0.13em;">P</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mord mathdefault" style="margin-right: 0.13em;">F</span><span class="mord mathdefault" style="margin-right: 0.1em;">N</span></span></span><span style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span style="top: -3.67em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13em;">T</span><span class="mord mathdefault" style="margin-right: 0.13em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.76em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          F 
         
        
          P 
         
        
          R 
         
        
          = 
         
         
          
          
            F 
           
          
            P 
           
          
          
          
            F 
           
          
            P 
           
          
            + 
           
          
            T 
           
          
            N 
           
          
         
        
       
         FPR = \frac{FP}{FP+TN} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.13em;">F</span><span class="mord mathdefault" style="margin-right: 0.13em;">P</span><span class="mord mathdefault" style="margin-right: 0em;">R</span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.27em;"></span></span><span class="base"><span class="strut" style="height: 2.12em; vertical-align: -0.76em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.36em;"><span style="top: -2.31em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13em;">F</span><span class="mord mathdefault" style="margin-right: 0.13em;">P</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mord mathdefault" style="margin-right: 0.13em;">T</span><span class="mord mathdefault" style="margin-right: 0.1em;">N</span></span></span><span style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span style="top: -3.67em;"><span class="pstrut" style="height: 3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13em;">F</span><span class="mord mathdefault" style="margin-right: 0.13em;">P</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.76em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p> 
<p>其中 TPR 的计算公式您可能有点眼熟，没错！就是召回率的计算公式。<strong>也就是说 TPR 就是召回率。所以 TPR 描述的是模型预测 Positive 并且预测正确的数量占真实类别为 Positive 样本的比例。而 FPR 描述的模型预测 Positive 并且预测错了的数量占真实类别为 Negtive 样本的比例。</strong></p> 
<p>和精准率与召回率一样， TPR 与 FPR 之间也存在关系。假设有这么一组数据，菱形代表 Positive，圆形代表 Negtive。<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/51/fd/Fh5DG3nV_o.png"><br> 现在需要训练一个逻辑回归的模型对数据进行分类，假如将从 0 到 1 中的一些值作为模型的分类阈值。若模型认为当前数据是 Positive 的概率<strong>小于</strong>分类阈值则分类为 Negtive ，<strong>否则</strong>就分类为 Positive （<em>假设分类阈值为 0.8，模型认为这条数据是 Positive 的概率为 0.7， 0.7 小于 0.8，那么模型就认为这条数据是 Negtive</em>）。在不同的分类阈值下，模型所对应的 TPR 与 FPR 如下图所示（竖线代表分类阈值，模型会将竖线左边的数据分类成 Negtive，竖线右边的分类成 Positive ）：<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/bf/0c/rQy7S8vi_o.png"><br> 从图中可以看出，<strong>当模型的 TPR 越高 FPR 也会越高， TPR 越低 FPR 也会越低。这与精准率和召回率之间的关系刚好相反。</strong> 并且，模型的分类阈值一但改变，就有一组对应的 TPR 与 FPR 。<br> 假设该模型在不同的分类阈值下其对应的 TPR 与 FPR 如下表所示：</p> 
<table><thead><tr><th>TPR</th><th>FPR</th></tr></thead><tbody><tr><td>0.2</td><td>0.08</td></tr><tr><td>0.35</td><td>0.1</td></tr><tr><td>0.37</td><td>0.111</td></tr><tr><td>0.51</td><td>0.12</td></tr><tr><td>0.53</td><td>0.13</td></tr><tr><td>0.56</td><td>0.14</td></tr><tr><td>0.71</td><td>0.21</td></tr><tr><td>0.82</td><td>0.26</td></tr><tr><td>0.92</td><td>0.41</td></tr><tr><td>0.93</td><td>0.42</td></tr></tbody></table> 
<p>若将 FPR 作为横轴， TPR 作为纵轴，将上面的表格以折线图的形式画出来就是 ROC曲线 。<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/e2/94/ci4jrWCS_o.png"><br> 假设现在有模型 A 和模型 B ，它们的 ROC 曲线如下图所示(其中模型 A 的 ROC曲线 为黄色，模型 B 的 ROC 曲线 为蓝色)：<br> <img alt="在这里插入图片描述" src="https://images2.imgbox.com/c9/a9/fJWvrogK_o.png"><br> **那么模型 A 的性能比模型 B 的性能好，因为模型 A 当 FPR 较低时所对应的 TPR 比模型 B 的低 FPR 所对应的 TPR 更高。**由于随着 FPR 的增大， TPR 也会增大。<strong>所以 ROC 曲线与横轴所围成的面积越大，模型的分类性能就越高。<strong>而 ROC曲线 的面积称为</strong>AUC</strong>。</p> 
<h4><a id="AUC_314"></a>AUC</h4> 
<p>很明显模型的 AUC 越高，模型的二分类性能就越强。AUC 的计算公式如下：</p> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          A 
         
        
          U 
         
        
          C 
         
        
          = 
         
         
          
           
           
             ∑ 
            
            
            
              i 
             
            
              ∈ 
             
            
              p 
             
            
              o 
             
            
              s 
             
            
              i 
             
            
              t 
             
            
              i 
             
            
              v 
             
            
              e 
             
            
              c 
             
            
              l 
             
            
              a 
             
            
              s 
             
            
              s 
             
            
           
          
            r 
           
          
            a 
           
          
            n 
           
           
           
             k 
            
           
             i 
            
           
          
            − 
           
           
            
            
              M 
             
            
              ( 
             
            
              M 
             
            
              + 
             
            
              1 
             
            
              ) 
             
            
           
             2 
            
           
          
          
          
            M 
           
          
            ∗ 
           
          
            N 
           
          
         
        
       
         AUC = \frac{ \sum_{i \in positiveclass} rank_i - \frac{M(M+1)}{2} }{M*N} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right: 0.1em;">U</span><span class="mord mathdefault" style="margin-right: 0.07em;">C</span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.27em;"></span></span><span class="base"><span class="strut" style="height: 2.52em; vertical-align: -0.68em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.83em;"><span style="top: -2.32em;"><span class="pstrut" style="height: 3.01em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.1em;">M</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mord mathdefault" style="margin-right: 0.1em;">N</span></span></span><span style="top: -3.24em;"><span class="pstrut" style="height: 3.01em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span style="top: -3.83em;"><span class="pstrut" style="height: 3.01em;"></span><span class="mord"><span class="mop"><span class="mop op-symbol small-op" style="top: 0em; position: relative;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.18em;"><span style="top: -2.4em; margin-right: 0.05em; margin-left: 0em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">∈</span><span class="mord mathdefault mtight">p</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight">t</span><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right: 0.03em;">v</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight">c</span><span class="mord mathdefault mtight" style="margin-right: 0.01em;">l</span><span class="mord mathdefault mtight">a</span><span class="mord mathdefault mtight">s</span><span class="mord mathdefault mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.43em;"></span></span></span></span></span><span class="mspace" style="margin-right: 0.16em;"></span><span class="mord mathdefault" style="margin-right: 0.02em;">r</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03em;">k</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.31em;"><span style="top: -2.55em; margin-right: 0.05em; margin-left: -0.03em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"></span></span></span></span></span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.01em;"><span style="top: -2.65em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span style="top: -3.48em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.1em;">M</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right: 0.1em;">M</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.34em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.68em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p> 
<p>其中 M 为真实类别为 Positive 的样本数量，N 为真实类别为 Negtive 的样本数量。ranki 代表了真实类别为 Positive 的样本点额预测概率从小到大排序后，该预测概率排在第几。</p> 
<p>举个例子，现有预测概率与真实类别的表格如下所示（其中 0 表示 Negtive， 1 表示 Positive ）：</p> 
<table><thead><tr><th>编号</th><th>预测概率</th><th>真实类别</th></tr></thead><tbody><tr><td>1</td><td>0.1</td><td>0</td></tr><tr><td>2</td><td>0.4</td><td>0</td></tr><tr><td>3</td><td>0.3</td><td>1</td></tr><tr><td>4</td><td>0.8</td><td>1</td></tr></tbody></table> 
<p>想要得到公式中的 rank，就需要将预测概率从小到大排序，排序后如下：</p> 
<table><thead><tr><th>编号</th><th>预测概率</th><th>真实类别</th></tr></thead><tbody><tr><td>1</td><td>0.1</td><td>0</td></tr><tr><td>3</td><td>0.3</td><td>1</td></tr><tr><td>2</td><td>0.4</td><td>0</td></tr><tr><td>4</td><td>0.8</td><td>1</td></tr></tbody></table> 
<p>排序后的表格中，真实类别为 Positive 只有编号为 3 和编号为 4 的数据，并且编号为 3 的数据排在第 2 ，编号为 4 的数据排在第 4。所以 rank=[2, 4] 。又因表格中真是类别为 Positive 的数据有 2 条， Negtive 的数据有 2 条。因此 M 为2， N 为2。所以根据 AUC 的计算公式可知：</p> 
<p><span class="katex--display"><span class="katex-display"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          A 
         
        
          U 
         
        
          C 
         
        
          = 
         
         
          
          
            ( 
           
          
            2 
           
          
            + 
           
          
            4 
           
          
            ) 
           
          
            − 
           
           
            
            
              2 
             
            
              ( 
             
            
              2 
             
            
              + 
             
            
              1 
             
            
              ) 
             
            
           
             2 
            
           
          
          
          
            2 
           
          
            ∗ 
           
          
            2 
           
          
         
        
       
         AUC = \frac{(2 + 4) - \frac{2(2+1)}{2}} {2*2} 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68em; vertical-align: 0em;"></span><span class="mord mathdefault">A</span><span class="mord mathdefault" style="margin-right: 0.1em;">U</span><span class="mord mathdefault" style="margin-right: 0.07em;">C</span><span class="mspace" style="margin-right: 0.27em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.27em;"></span></span><span class="base"><span class="strut" style="height: 2.43em; vertical-align: -0.68em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.74em;"><span style="top: -2.32em;"><span class="pstrut" style="height: 3.01em;"></span><span class="mord"><span class="mord">2</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mord">2</span></span></span><span style="top: -3.24em;"><span class="pstrut" style="height: 3.01em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span style="top: -3.74em;"><span class="pstrut" style="height: 3.01em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mord">4</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right: 0.22em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 1.01em;"><span style="top: -2.65em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top: -3.23em;"><span class="pstrut" style="height: 3em;"></span><span class="frac-line" style="border-bottom-width: 0.04em;"></span></span><span style="top: -3.48em;"><span class="pstrut" style="height: 3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.34em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.68em;"></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></span></p> 
<h3><a id="_343"></a>编程要求</h3> 
<p>根据提示，在 Begin-End 区域填写 python 代码，完成 calAUC 函数实现计算 AUC 并返回。</p> 
<p>calAUC 函数中的参数:</p> 
<ul><li>prob：模型预测样本为 Positive 的概率列表，类型为 ndarray；</li><li>labels：样本的真实类别列表，其中 1 表示 Positive ，0 表示 Negtive ，类型为 ndarray 。</li></ul> 
<p>一个测试用例(字典中的 probs 部分代表模型认为样本是 Positive 的概率，labels 部分代表样本的真实类别，1 表示 Positive， 0 表示 Negtive )：<br> 测试输入： {‘probs’:[0.1, 0.4, 0.3, 0.8], ‘labels’:[0, 0, 1, 1]}<br> 预期输出： 0.75</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

<span class="token keyword">def</span> <span class="token function">calAUC</span><span class="token punctuation">(</span>prob<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token triple-quoted-string string">'''
	计算AUC并返回
	:param prob: 模型预测样本为Positive的概率列表，类型为ndarray
	:param labels: 样本的真实类别列表，其中1表示Positive，0表示Negtive，类型为ndarray
	:return: AUC，类型为float
	'''</span>
	<span class="token comment">#********* Begin *********#</span>
	f <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">zip</span><span class="token punctuation">(</span>prob<span class="token punctuation">,</span> labels<span class="token punctuation">)</span><span class="token punctuation">)</span>
	rank <span class="token operator">=</span> <span class="token punctuation">[</span>values2 <span class="token keyword">for</span> values1<span class="token punctuation">,</span> values2 <span class="token keyword">in</span> <span class="token builtin">sorted</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
	rankList <span class="token operator">=</span> <span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span> <span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>rank<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">if</span> rank<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">]</span>
	
	posNum <span class="token operator">=</span> <span class="token number">0</span>
	negNum <span class="token operator">=</span> <span class="token number">0</span>
	<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token builtin">len</span><span class="token punctuation">(</span>labels<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
		<span class="token keyword">if</span><span class="token punctuation">(</span>labels<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
			posNum <span class="token operator">+=</span> <span class="token number">1</span>
		<span class="token keyword">else</span><span class="token punctuation">:</span>
			negNum <span class="token operator">+=</span> <span class="token number">1</span>
	auc <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">sum</span><span class="token punctuation">(</span>rankList<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token punctuation">(</span>posNum<span class="token operator">*</span><span class="token punctuation">(</span>posNum<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span>posNum<span class="token operator">*</span>negNum<span class="token punctuation">)</span>
	<span class="token keyword">return</span> auc
	<span class="token comment">#********* End *********#</span>
</code></pre> 
<h2><a id="10sklearn_383"></a>第10关：sklearn中的分类性能指标</h2> 
<h3><a id="_384"></a>任务描述</h3> 
<p>本关任务：使用 sklearn 完成对模型分类性能的评估。</p> 
<h3><a id="_386"></a>相关知识</h3> 
<h4><a id="accufracy_score_387"></a>accu\fracy_score</h4> 
<p>sklearn 提供了计算准确度的接口 accu\fracy_score。其中参数如下：</p> 
<ul><li>y_true：为样本真实标签，类型为一维的 ndarray 或者 list；</li><li>y_pred：为模型预测标签，类型为一维的 ndarray 或者 list。</li></ul> 
<p>示例代码如下：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> accu\fracy_score
</code></pre> 
<h4><a id="precision_score_400"></a>precision_score</h4> 
<p>sklearn 提供了计算精准率的接口 precision_score 。其中参数如下：</p> 
<ul><li>y_true：为样本真实标签，类型为一维的 ndarray 或者 list；</li><li>y_pred：为模型预测标签，类型为一维的 ndarray 或者 list；</li><li>pos_label：用什么值表示 Positive，默认为 1。</li></ul> 
<p>示例代码如下：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> precision_score
</code></pre> 
<h4><a id="recall_score_414"></a>recall_score</h4> 
<p>sklearn 提供了计算召回率的接口 recall_score 。其中参数如下：</p> 
<ul><li>y_true：为样本真实标签，类型为一维的 ndarray 或者 list；</li><li>y_pred：为模型预测标签，类型为一维的 ndarray 或者 list；</li><li>pos_label：用什么值表示 Positive ，默认为 1。</li></ul> 
<p>示例代码如下：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> recall_score
</code></pre> 
<h4><a id="f1_score_428"></a>f1_score</h4> 
<p>sklearn 提供了计算 F1 Score 的接口 f1_score 。其中参数如下：</p> 
<ul><li>y_true：为样本真实标签，类型为一维的 ndarray 或者 list；</li><li>y_pred：为模型预测标签，类型为一维的 ndarray 或者 list；</li><li>pos_label：用什么值表示 Positive ，默认为 1。</li></ul> 
<p>示例代码如下：</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> f1_score
</code></pre> 
<h4><a id="roc_auc_score_442"></a>roc_auc_score</h4> 
<p>sklearn 提供了计算 AUC 的接口 roc_auc_score 。其中参数如下：</p> 
<ul><li>y_true：为样本真实标签，类型为一维的 ndarray 或者 list；</li><li>y_score：为模型预测样本为 Positive 的概率，类型为一维的 ndarray 或者 list。</li></ul> 
<p>示例代码如下：</p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> roc_auc_score

<span class="token comment">#y_true为真实标签，y_predict为预测标签</span>
y_true <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">]</span>
y_predict <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span>

<span class="token keyword">print</span><span class="token punctuation">(</span>accu\fracy_score<span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_predict<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<h3><a id="_462"></a>编程要求</h3> 
<p>在 Begin-End 区域填写 <code>classification_performance(y_true, y_pred, y_prob)</code> 函数分别计算模型的准确度、精准率、召回率、F1-Score 和 AUC 并将其返回，其中：</p> 
<ul><li>y_true ：样本的真实类别，类型为 ndarray；</li><li>y_pred ：模型预测出的类别，类型为 ndarray；</li><li>y_prob ：模型预测样本为 Positive 的概率，类型为 ndarray。</li></ul> 
<h3><a id="_469"></a>测试说明</h3> 
<p>代码根据输入来<strong>按顺序返回</strong>正确的准确度、精准率、召回率、 F1-Score 和 AUC。<br> 以下为其中一个测试用例(字典中的 y_prob 部分代表模型认为样本是 Positive 的概率；y_true 部分代表样本的真实类别，1 表示 Positive， 0 表示 Negtive；y_pred 部分代表模型预测的类别)：<br> 测试输入：<br> {‘y_prob’:[0.7, 0.2, 0.9, 0.8],’y_true’:[0, 0, 1, 1],’y_pred’:[1, 0, 1, 1]}<br> 预期输出：<br> 0.750000, 0.666667, 1.000000, 0.800000, 1.000000</p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>metrics <span class="token keyword">import</span> accuracy_score<span class="token punctuation">,</span> precision_score<span class="token punctuation">,</span> recall_score<span class="token punctuation">,</span> f1_score<span class="token punctuation">,</span> roc_auc_score

<span class="token keyword">def</span> <span class="token function">classification_performance</span><span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_pred<span class="token punctuation">,</span> y_prob<span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token triple-quoted-string string">'''
	返回准确度、精准率、召回率、f1 Score和AUC
	:param y_true:样本的真实类别，类型为`ndarray`
	:param y_pred:模型预测出的类别，类型为`ndarray`
	:param y_prob:模型预测样本为`Positive`的概率，类型为`ndarray`
	:return:
	'''</span>
	<span class="token comment">#********* Begin *********#</span>
	<span class="token keyword">return</span> accuracy_score<span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_pred<span class="token punctuation">)</span><span class="token punctuation">,</span> precision_score<span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_pred<span class="token punctuation">)</span><span class="token punctuation">,</span> recall_score<span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_pred<span class="token punctuation">)</span><span class="token punctuation">,</span> f1_score<span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_pred<span class="token punctuation">,</span>y_prob<span class="token punctuation">)</span><span class="token punctuation">,</span> roc_auc_score<span class="token punctuation">(</span>y_true<span class="token punctuation">,</span> y_prob<span class="token punctuation">)</span>
	<span class="token comment">#********* End *********#</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7d4f524899568f7219e2d66790392377/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">kettle输出步骤</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/55d3a27359733e8956dd8d8bdb780a38/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">（记录）PaddleHub创意赛：AI人像抠图及图像合成</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>