<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux后台运行的几种方式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux后台运行的几种方式" />
<meta property="og:description" content="linux 如何让进程后台运行?
1、nohup
将程序以忽略挂起信号的方式运行起来
补充说明
nohup命令 可以将程序以忽略挂起信号的方式运行起来，被运行的程序的输出信息将不会显示到终端。
无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。
如果当前目录的 nohup.out 文件不可写，输出重定向到$HOME/nohup.out文件中。
如果没有文件能创建或打开以用于追加，那么 command 参数指定的命令不可调用。
如果标准错误是一个终端，那么把指定的命令写给标准错误的所有输出作为标准输出重定向到相同的文件描述符。
简单实例：
nohup command &amp;
指定输出实例
nohup command &gt; myout.file 2&gt;&amp;1 &amp;
其他相关命令
ctrl &#43; z #可以将一个正在前台执行的命令放到后台，并且处于暂停状态。
fg #将后台任务切换到前台执行
bg #将一个在后台暂停的命令，变成在后台继续执行。如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出
jobs #查看后台运行的状态，jobs -l选项可显示所有任务的PID
ps -ef | grep command 或者 ps aux | grep command #查看进程
kill -9 进程id #杀掉对应的进程，
更高级的用法如下：
ps aux | grep command | grep -v grep | awk &#39;{print $1}&#39; | xargs kill -9 #这个表示直接通过command获取进程id并直接kill掉" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6c602ce77def20253b1fb72afc106a36/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-08T19:29:50+08:00" />
<meta property="article:modified_time" content="2019-11-08T19:29:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux后台运行的几种方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>linux 如何让进程后台运行?</p> 
<p>1、nohup<br> 将程序以忽略挂起信号的方式运行起来</p> 
<p><strong>补充说明</strong><br> nohup命令 可以将程序以忽略挂起信号的方式运行起来，被运行的程序的输出信息将不会显示到终端。<br> 无论是否将 nohup 命令的输出重定向到终端，输出都将附加到当前目录的 nohup.out 文件中。<br> 如果当前目录的 nohup.out 文件不可写，输出重定向到$HOME/nohup.out文件中。<br> 如果没有文件能创建或打开以用于追加，那么 command 参数指定的命令不可调用。<br> 如果标准错误是一个终端，那么把指定的命令写给标准错误的所有输出作为标准输出重定向到相同的文件描述符。</p> 
<p><strong>简单实例</strong>：<br> nohup command &amp;</p> 
<p>指定输出实例<br> nohup command &gt; myout.file 2&gt;&amp;1 &amp;</p> 
<p>其他相关命令<br> ctrl + z #可以将一个正在前台执行的命令放到后台，并且处于暂停状态。<br> fg #将后台任务切换到前台执行<br> bg #将一个在后台暂停的命令，变成在后台继续执行。如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出<br> jobs #查看后台运行的状态，jobs -l选项可显示所有任务的PID<br> ps -ef | grep command 或者 ps aux | grep command #查看进程<br> kill -9 进程id #杀掉对应的进程，<br> 更高级的用法如下：<br> ps aux | grep command | grep -v grep | awk '{print $1}' | xargs kill -9 #这个表示直接通过command获取进程id并直接kill掉</p> 
<p><br> 2、screen<br> 用于命令行终端切换</p> 
<p>a、会话恢复<br> 只要Screen本身没有终止，在其内部运行的会话都可以恢复。这一点对于远程登录的用户特别有用——即使网络连接中断，<br> 用户也不会失去对已经打开的命令行会话的控制。只要再次登录到主机上执行screen -r就可以恢复会话的运行。<br> 同样在暂时离开的时候，也可以执行分离命令detach，在保证里面的程序正常运行的情况下让Screen挂起（切换到后台）</p> 
<p>b、多窗口<br> 在Screen环境下，所有的会话都独立的运行，并拥有各自的编号、输入、输出和窗口缓存。用户可以通过快捷键在不同的窗口下切换，<br> 并可以自由的重定向各个窗口的输入和输出。Screen实现了基本的文本操作，如复制粘贴等；还提供了类似滚动条的功能，<br> 可以查看窗口状况的历史记录。窗口还可以被分区和命名，还可以监视后台窗口的活动。 会话共享 Screen可以让一个或多个用户<br> 从不同终端多次登录一个会话，并共享会话的所有特性（比如可以看到完全相同的输出）。它同时提供了窗口访问权限的机制，<br> 可以对窗口进行密码保护。</p> 
<p>c、screen的安装<br> yum install -y screen</p> 
<p>基本语法<br> screen -AmRvx -[ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s ][-S &lt;作业名称&gt;]</p> 
<p>选项<br> -A 　将所有的视窗都调整为目前终端机的大小。<br> -d &lt;作业名称&gt; 　将指定的screen作业离线。<br> -h &lt;行数&gt; 　指定视窗的缓冲区行数。<br> -m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。<br> -r &lt;作业名称&gt; 　恢复离线的screen作业。<br> -R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。<br> -s 　指定建立新视窗时，所要执行的shell。<br> -S &lt;作业名称&gt; 　指定screen作业的名称。<br> -v 　显示版本信息。<br> -x 　恢复之前离线的screen作业。<br> -ls或--list 　显示目前所有的screen作业。<br> -wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业。</p> 
<p>常用screen参数<br> screen -S yourname -&gt; 新建一个叫yourname的session<br> screen -ls -&gt; 列出当前所有的session<br> screen -r yourname -&gt; 回到yourname这个session<br> screen -d yourname -&gt; 远程detach某个session<br> screen -d -r yourname -&gt; 结束当前session并回到yourname这个session</p> 
<p>在每个screen session 下，所有命令都以 ctrl+a(Ctrl + a) 开始。</p> 
<p>Ctrl + a ? -&gt; 显示所有键绑定信息<br> Ctrl + a c -&gt; 创建一个新的运行shell的窗口并切换到该窗口<br> Ctrl + a n -&gt; Next，切换到下一个 window <br> Ctrl + a p -&gt; Previous，切换到前一个 window <br> Ctrl + a 0..9 -&gt; 切换到第 0..9 个 window<br> Ctrl+a [Space] -&gt; 由视窗0循序切换到视窗9<br> Ctrl + a Ctrl + a -&gt; 在两个最近使用的 window 间切换 <br> Ctrl + a x -&gt; 锁住当前的 window，需用用户密码解锁<br> Ctrl + a d -&gt; detach，暂时离开当前session，将目前的 screen session (可能含有多个 windows) 丢到后台执行，并会回到还没进 screen 时的状态，此时在 screen session 里，每个 window 内运行的 process (无论是前台/后台)都在继续执行，即使 logout 也不影响。 <br> Ctrl + a z -&gt; 把当前session放到后台执行，用 shell 的 fg 命令则可回去。<br> Ctrl + a w -&gt; 显示所有窗口列表<br> Ctrl + a t -&gt; time，显示当前时间，和系统的 load <br> Ctrl + a k -&gt; kill window，强行关闭当前的 window<br> Ctrl + a -&gt; 进入 copy mode，在 copy mode 下可以回滚、搜索、复制就像用使用 [vi 一样<br> C-b Backward，PageUp <br> C-f Forward，PageDown <br> H(大写) High，将光标移至左上角 <br> L Low，将光标移至左下角 <br> 0 移到行首 <br> $ 行末 <br> w forward one word，以字为单位往前移 <br> b backward one word，以字为单位往后移 <br> Space 第一次按为标记区起点，第二次按为终点 <br> Esc 结束 copy mode <br> Ctrl + a ] -&gt; paste，把刚刚在 copy mode 选定的内容贴上</p> 
<p>操作示例见：https://wangchujiang.com/linux-command/c/screen.html</p> 
<p>3、daemonize工具</p> 
<p>##安装<br> git clone git://github.com/bmc/daemonize.git<br> sh configure &amp;&amp; make &amp;&amp; sudo make install</p> 
<p>-a #挂载到输出文件，而不是冲掉默认值。只有应用了-e and/or -o 被指定的情况。<br> -e #重定向输出标准错误到指定的文件中，替代/dev/null<br> -o #重定向输出标准到指定的文件中，替代/dev/null<br> -E name=value #增加环境变量给给后台程序。这个这个参数类型一定要是name=value格式。参数可以设置多次。<br> -c directory #定制运行命令前的目录。<br> -p pidfile #定制自己的pid存放位置。<br> -l lockfile #单实例启动时将会检查这个文件。<br> -u user #定制程序以谁的身份运行的。</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a461f790a7342025d6fc0b70b9e8dfb4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">js取数组中的最大值</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/59881248eff36dee9009d2cd8ae0ef37/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">eclipse pom.xml 第一行报错 Failure to transfer *这种错误 解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>