<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ef core 批量update 非id_使用EF.Core将同一模型映射到多个表 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ef core 批量update 非id_使用EF.Core将同一模型映射到多个表" />
<meta property="og:description" content="在 EntityFramework Core 中，我们可以使用属性或Fluent API来配置模型映射。有一天，我遇到了一个新的需求，有一个系统每天会生成大量数据，每天生成一个新的表存储数据。例如，数据库如下所示：
所有表都具有相同的结构。那么，如何更改映射以避免创建多个模型呢？
在本文中，我将向您展示如何更改映射以处理这种情况。您也可以使用此方法扩展出更多的用法。
创建 .NET Core 3.1 项目 现在，我们可以使用.NET Core 3.1，它是.NET Core的LTS版本，将来可以轻松将其升级到.NET 5。
假设您已经在计算机上安装了最新的.NET Core SDK。如果没有，则可以从https://dotnet.microsoft.com/download下载。然后，您可以使用dotnet CLI创建项目。对于此示例，我将使用.NET Core 3.1。
让我们创建一个名为DynamicModelDemo的新.NET Core Console项目:
dotnet new console --name DynamicModelDemo
然后用以下命令创建一个新的解决方案:
dotnet new sln --name DynamicModelDemo
接下来使用以下命令把刚才创建的项目添加到解决方案：
dotnet sln add &#34;DynamicModelDemo/DynamicModelDemo.csproj&#34;
接下来可以用Visual Studio打开解决方案了。
创建模型 该模型非常简单。在项目中添加一个名为ConfigurableEntity.cs的新文件：
using System;
namespace DynamicModelDemo
{
public class ConfigurableEntity
{
public int Id { get; set; }
public string Title { get; set; }" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/42cc1216276f84b29f12bfee31cecaa1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-11-25T11:06:56+08:00" />
<meta property="article:modified_time" content="2020-11-25T11:06:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ef core 批量update 非id_使用EF.Core将同一模型映射到多个表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="._5ce-wx-style" style="font-size:16px;"> 
 <div class="rich_media_content" id="js_content"> 
  <p>在 EntityFramework Core 中，我们可以使用属性或Fluent API来配置模型映射。有一天，我遇到了一个新的需求，有一个系统每天会生成大量数据，每天生成一个新的表存储数据。例如，数据库如下所示：<img src="https://images2.imgbox.com/5a/43/I5ru2Myl_o.png" alt="914fbe49862fa9e6738b671f6a71aa1d.png"></p> 
  <p>所有表都具有相同的结构。那么，如何更改映射以避免创建多个模型呢？</p> 
  <p>在本文中，我将向您展示如何更改映射以处理这种情况。您也可以使用此方法扩展出更多的用法。</p> 
  <h3><span style="font-weight:bold;"></span><span style="font-weight:bold;">创建 .NET Core 3.1 项目</span><span style="font-weight:bold;"> </span></h3> 
  <p>现在，我们可以使用.NET Core 3.1，它是.NET Core的LTS版本，将来可以轻松将其升级到.NET 5。</p> 
  <p>假设您已经在计算机上安装了最新的.NET Core SDK。如果没有，则可以从https://dotnet.microsoft.com/download下载。然后，您可以使用<code>dotnet CLI</code>创建项目。对于此示例，我将使用.NET Core 3.1。</p> 
  <p>让我们创建一个名为<code>DynamicModelDemo</code>的新.NET Core Console项目:</p> 
  <pre class="has"><code>dotnet new console --name DynamicModelDemo<br></code></pre> 
  <p>然后用以下命令创建一个新的解决方案:</p> 
  <pre class="has"><code>dotnet new sln --name DynamicModelDemo<br></code></pre> 
  <p>接下来使用以下命令把刚才创建的项目添加到解决方案：</p> 
  <pre class="has"><code>dotnet sln add "DynamicModelDemo/DynamicModelDemo.csproj"<br></code></pre> 
  <p>接下来可以用Visual Studio打开解决方案了。</p> 
  <h3><span style="font-weight:bold;"></span><span style="font-weight:bold;">创建模型</span><span style="font-weight:bold;"> </span></h3> 
  <p>该模型非常简单。在项目中添加一个名为<code>ConfigurableEntity.cs</code>的新文件：</p> 
  <pre class="has"><code>using System;<br><br>namespace DynamicModelDemo<br>{<!-- --><br>public class ConfigurableEntity<br>    {<!-- --><br>public int Id { get; set; }<br>public string Title { get; set; }<br>public string Content { get; set; }<br>public DateTime CreateDateTime { get; set; }<br>    }<br>}<br></code></pre> 
  <p>我们将使用<code>CreateDateTime</code>属性来确定模型应该映射到哪个表。</p> 
  <h3><span style="font-weight:bold;"></span><span style="font-weight:bold;">添加 EntityFramework Core</span><span style="font-weight:bold;"> </span></h3> 
  <p>导航到项目目录并使用以下命令添加所需的EF.Core packages:</p> 
  <pre class="has"><code>dotnet add package Microsoft.EntityFrameworkCore.SqlSever<br>dotnet add package Microsoft.EntityFrameworkCore.Design<br></code></pre> 
  <p>如果您还没有安装 ef tool，请运行以下命令来安装：</p> 
  <pre class="has"><code>dotnet tool install --global dotnet-ef<br></code></pre> 
  <p>这样您就可以使用 dotnet ef 工具创建迁移或通过应用迁移来更新数据库。</p> 
  <h3><span style="font-weight:bold;"></span><span style="font-weight:bold;">创建 DbContext</span><span style="font-weight:bold;"> </span></h3> 
  <p>向项目添加一个名为<code>DynamicContext.cs</code>的新类文件。内容如下所示：</p> 
  <pre class="has"><code>using Microsoft.EntityFrameworkCore;<br>using Microsoft.EntityFrameworkCore.Infrastructure;<br>using System;<br><br>namespace DynamicModelDemo<br>{<!-- --><br>public class DynamicContext : DbContext<br>    {<!-- --><br>public DbSet Entities { get; set; }#region OnConfiguringprotected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)<br>            =&gt; optionsBuilder<br>                .UseSqlServer("Server=(localdb)\\mssqllocaldb;Database=DynamicContext;Trusted_Connection=True;");#endregion#region OnModelCreatingprotected override void OnModelCreating(ModelBuilder modelBuilder)<br>        {<!-- --><br>            modelBuilder.Entity(b =&gt;<br>            {<!-- --><br>                b.HasKey(p =&gt; p.Id);<br>            });<br>        }#endregion<br>    }<br>}</code></pre> 
  <p>目前，这只是EF.Core的基本配置。它使用默认映射，这意味着模型将映射到名为<code>Entities</code>的表。那么，如果我们想基于其<code>CreateDateTime</code>属性将模型映射到不同的表，该怎么办呢？</p> 
  <p>您可能知道我们可以使用<code>ToTable()</code>方法来更改表名，但是如何在<code>OnModelCreating</code>方法中更改所有模型的表名呢？EF建立模型时，只会执行一次OnModelCreating。所以这种方式是无法实现的。</p> 
  <p>对于这种情况，我们需要使用<code>IModelCacheKeyFactory</code>来更改默认映射，通过这个接口我们可以定制模型缓存机制，以便EF能够根据其属性创建不同的模型。</p> 
  <h3><span style="font-weight:bold;"></span><span style="font-weight:bold;"><code>IModelCacheKeyFactory</code>是什么？</span><span style="font-weight:bold;"> </span></h3> 
  <p>这是微软官方的文档解释：</p> 
  <blockquote> 
   <p>EF uses <code>IModelCacheKeyFactory</code> to generate cache keys for models.</p> 
  </blockquote> 
  <p>默认情况下，EF假定对于任何给定的上下文类型，模型都是相同的。但是对于我们的方案，模型将有所不同，因为它映射到了不同的表。因此，我们需要用我们的实现替换<code>IModelCacheKeyFactory</code>服务，该实现会比较缓存键以将模型映射到正确的表。</p> 
  <p>请注意，该接口通常由数据库提供程序和其他扩展使用，一般不在应用程序代码中使用。但是对于我们的场景来说，这是一种可行的方法。</p> 
  <h3><span style="font-weight:bold;"></span><span style="font-weight:bold;">实现<code>IModelCacheKeyFactory</code></span><span style="font-weight:bold;"> </span></h3> 
  <p>我们需要使用<code>CreateDateTime</code>来区分表。在<code>DynamicContext</code>类中添加一个属性：</p> 
  <pre class="has"><code>public DateTime CreateDateTime { get; set; }<br></code></pre> 
  <p>在项目中添加一个名为<code>DynamicModelCacheKeyFactory.cs</code>的新类文件。代码如下所示：</p> 
  <pre class="has"><code>using Microsoft.EntityFrameworkCore;<br>using Microsoft.EntityFrameworkCore.Infrastructure;<br><br>namespace DynamicModelDemo<br>{<!-- --><br>public class DynamicModelCacheKeyFactory : IModelCacheKeyFactory<br>    {<!-- --><br>public object Create(DbContext context)<br>            =&gt; context is DynamicContext dynamicContext<br>                ? (context.GetType(), dynamicContext.CreateDateTime)<br>                : (object)context.GetType();<br>    }<br>}<br></code></pre> 
  <p>在生成模型缓存键时，此实现将考虑<code>CreateDateTime</code>属性。</p> 
  <h3><span style="font-weight:bold;"></span><span style="font-weight:bold;">应用<code>IModelCacheKeyFactory</code></span><span style="font-weight:bold;"> </span></h3> 
  <p>接下来，我们可以在上下文中注册新的<code>IModelCacheKeyFactory</code>：</p> 
  <pre class="has"><code>#region OnConfiguring<br>protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)<br>            =&gt; optionsBuilder<br>                .UseSqlServer("Server=(localdb)\\mssqllocaldb;Database=DynamicContext;Trusted_Connection=True;")<br>                .ReplaceService();#endregion</code></pre> 
  <p>这样我们就可以在<code>OnModelCreating</code>方法中分别映射表名了：</p> 
  <pre class="has"><code>#region OnModelCreating<br>protected override void OnModelCreating(ModelBuilder modelBuilder)<br>{<!-- --><br>      modelBuilder.Entity(b =&gt;<br>            {<!-- --><br>                b.ToTable(CreateDateTime.ToString("yyyyMMdd"));<br>                b.HasKey(p =&gt; p.Id);<br>            });<br>}#endregion</code></pre> 
  <p><code>CreateDateTime</code>来自<code>DynamicContext</code>的属性。</p> 
  <p>我们可以在创建<code>DynamicContext</code>时指定<code>CreateDateTime</code>属性：</p> 
  <pre class="has"><code>var context = new DynamicContext { CreateDateTime = datetime };<br></code></pre> 
  <p>如果<code>datetime</code>为<code>2020/03/27</code>，则<code>context</code>的模型将映射到名为<code>20200327</code>的表。</p> 
  <h3><span style="font-weight:bold;"></span><span style="font-weight:bold;">创建数据库</span><span style="font-weight:bold;"> </span></h3> 
  <p>在验证代码之前，我们需要首先创建数据库。但是，EF迁移并不是这种情况的最佳解决方案，因为随着时间的流逝，系统将生成更多表。我们只是使用它来创建一些示例表来验证映射。实际上，系统应该具有另一种每天动态生成表的方式。</p> 
  <p>运行以下命令以创建第一个迁移：</p> 
  <pre class="has"><code>dotnet ef migrations add InitialCreate<br></code></pre> 
  <p>您会看到在<code>Migrations</code>文件夹中生成了两个文件。打开<code>xxx_InitialCreate.cs</code>文件，并通过以下代码更新Up方法：</p> 
  <pre class="has"><code>protected override void Up(MigrationBuilder migrationBuilder)<br>{<!-- --><br>for (int i = 0; i &lt; 30; i++)<br>      {<!-- --><br>var index = i;<br>           migrationBuilder.CreateTable(<br>               name: DateTime.Now.AddDays(-index).ToString("yyyyMMdd"),<br>               columns: table =&gt; new<br>               {<!-- --><br>                    Id = table.Column&lt;int&gt;(nullable: false)<br>                            .Annotation("SqlServer:Identity", "1, 1"),<br>                    Title = table.Column&lt;string&gt;(nullable: true),<br>                    Content = table.Column&lt;string&gt;(nullable: true),<br>                    CreateDateTime = table.Column(nullable: false)<br>               },<br>               constraints: table =&gt;<br>               {<!-- --><br>                    table.PrimaryKey($"PK_{DateTime.Now.AddDays(-index):yyyyMMdd}", x =&gt; x.Id);<br>               });<br>        }<br>    }</code></pre> 
  <p>所做的更改是为了确保数据库中可以有足够的表进行测试。请注意，<strong>我们不应该在生产环境中使用这种方式</strong>。</p> 
  <p>接下来，我们可以使用此命令来创建和更新数据库：</p> 
  <pre class="has"><code>dotnet ef database update<br></code></pre> 
  <p>您会看到它在数据库中生成了最近30天的表。</p> 
  <h3><span style="font-weight:bold;"></span><span style="font-weight:bold;">验证映射</span><span style="font-weight:bold;"> </span></h3> 
  <p>现在该验证新映射了。通过以下代码更新<code>Program.cs</code>中的<code>Main</code>方法：</p> 
  <pre class="has"><code>static void Main(string[] args)<br>{<!-- --><br>    DateTime datetime1 = DateTime.Now;<br>using (var context = new DynamicContext { CreateDateTime = datetime1 })<br>    {<!-- --><br>        context.Entities.Add(new ConfigurableEntity { Title = "Great News One", Content = $"Hello World! I am the news of {datetime1}", CreateDateTime = datetime1 });<br>        context.SaveChanges();<br>    }<br>    DateTime datetime2 = DateTime.Now.AddDays(-1);<br>using (var context = new DynamicContext { CreateDateTime = datetime2 })<br>    {<!-- --><br>        context.Entities.Add(new ConfigurableEntity { Title = "Great News Two", Content = $"Hello World! I am the news of {datetime2}", CreateDateTime = datetime2 });<br>        context.SaveChanges();<br>    }<br><br>using (var context = new DynamicContext { CreateDateTime = datetime1 })<br>    {<!-- --><br>var entity = context.Entities.Single();<br>// Writes news of today<br>        Console.WriteLine($"{entity.Title} {entity.Content} {entity.CreateDateTime}");<br>    }<br><br>using (var context = new DynamicContext { CreateDateTime = datetime2 })<br>    {<!-- --><br>var entity = context.Entities.Single();<br>// Writes news of yesterday<br>        Console.WriteLine($"{entity.Title} {entity.Content} {entity.CreateDateTime}");<br>    }<br>}<br></code></pre> 
  <p>您将会看到如下输出：<img src="https://images2.imgbox.com/7d/88/bhahOPR5_o.png" alt="fa3b6a51ce14a1c9663c362953cc2193.png"></p> 
  <p>现在，我们可以通过传递<code>CreateDateTime</code>属性来使用相同的<code>DbContext</code>来表示不同的模型了。</p> 
  <h3><span style="font-weight:bold;"></span><span style="font-weight:bold;">小结</span><span style="font-weight:bold;"> </span></h3> 
  <p>该演示旨在演示如何使用<code>IModelCacheKeyFactory</code>更改默认模型映射。请注意，您仍然需要实现分别生成表的方法。托管服务是一种实现方式。有关更多信息，请访问Background tasks in ASP.NET Core<sup>[1]</sup>。</p> 
  <h4><span style="font-weight:bold;">参考资料</span></h4> 
  [1] 
  <p>Background tasks in ASP.NET Core: <em>https://docs.microsoft.com/en-us/aspnet/core/fundamentals/host/hosted-services?view=aspnetcore-3.1&amp;tabs=visual-studio</em></p> 
  <p><img src="https://images2.imgbox.com/10/00/akcg9dFz_o.png" alt="d64b5c14a8a765392f12fa031f49adb8.png"></p> 
  <p><img src="https://images2.imgbox.com/7a/a7/pCMyk1EM_o.png" alt="925bced6145d80d213f893850406be90.png"></p> 
  <p>求赞赏</p> 
  <p>???</p> 
  <h5>推荐阅读</h5> 
  <ul><li>【手把手教程】如何让你的求职简历敲开新西兰雇主的大门(文末送福利)</li><li>【手把手教程】新西兰求职，如何写好Cover Letter?</li><li>再不拼老命我们就真老了——大龄码农DIY新西兰技术移民全记录</li><li>移民路上为什么别人总能得到更多的信息，今天知道真相还不算太晚</li><li>还在愁纽村的面试吗？安啦~史上最靠谱的面试题借你看两眼！</li><li>雅思之路——只有绝境没有捷径</li><li>身在中国，如何应对海外公司的电话面试？</li><li>大龄码农来新西兰三个月拿到两个offer，真的只是运气好？</li><li>找工作的本命年——从国内大厂到NZ大厂</li><li>苦中有甜、笑中含泪的新移民生活——多的是你不知道的事</li></ul> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a2da19c9741a4776627d891dbc1f8e30/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">elementUI 学习入门之 Button 按钮</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ad27146aa00edfb4be158f6eba5bf38c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">zabbix安装和配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>