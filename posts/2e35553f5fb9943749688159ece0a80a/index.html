<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Monocle3 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Monocle3" />
<meta property="og:description" content="一、monocle3介绍 monocle3可以执行的3个主要的功能
对细胞进行聚类、分类和计数。Monocle 3 可识别新的（可能是罕见的）亚型细胞
构建单细胞轨迹。通过拟时序分析帮助大家解析生物体发育、疾病等过程中细胞发生的变化。这是最主要的功能。
差异表达分析。Monocle 3 包括一个复杂但易于使用的差分表达系统，可以表征新的细胞类型和状态始于与其他更好理解的细胞进行比较。
主要流程
1.读取数据，创建cell_data_set对象。
2.数据预处理：标准化，去除批次效应
3.降维
4.聚类
5.进行差异基因表达分析
6.拟时序分析
二、关于不同数据的读取办法 （一）Bioconductor的ExpressionSet对象： monocle3读取的数据要包含3个部分：
expression_matrix：表达式值的数字矩阵，其中行是gene，列是cellcell_metadata:数据框，其中行是cell，列是细胞属性（如细胞类型、培养条件、获取日期等）gene_metadata :数据框，其中行是特征（例如基因），列是基因属性，例如生物型，GC含量等。 输入前应该确保几个“等式”
expression_matrix 列数= cell_metadata 行数 并且两者要相匹配 expression_matrix 行数= gene_metadata 列数 并且两者要相匹配 gene_metadata的其中一列应为“gene_short_name”,表示每个基因的基因符号或简要名称 创建对象示例 # Load the data expression_matrix &lt;- readRDS(url(&#34;https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/cao_l2_expression.rds&#34;)) cell_metadata &lt;- readRDS(url(&#34;https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/cao_l2_colData.rds&#34;)) gene_annotation &lt;- readRDS(url(&#34;https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/cao_l2_rowData.rds&#34;)) # Make the CDS object cds &lt;- new_cell_data_set(expression_matrix, cell_metadata = cell_metadata, gene_metadata = gene_annotation) （二）从 10X 输出生成cell_data_set 要找到正确的文件，必须提供包含未修改的Cell Ranger“outs”文件夹的文件夹的路径。文件结构应如下所示：10x_data/outs/filtered_feature_bc_matrix/，其中filtered_feature_bc_matrix包含 files features.tsv.gz、barcodes.tsv.gz 和 matrix." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2e35553f5fb9943749688159ece0a80a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-22T10:31:19+08:00" />
<meta property="article:modified_time" content="2022-07-22T10:31:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Monocle3</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、monocle3介绍</h2> 
<p>monocle3可以执行的3个主要的功能</p> 
<p><strong>对细胞进行聚类、分类和计数。</strong>Monocle 3 可识别新的（可能是罕见的）亚型细胞</p> 
<p><u><strong>构建单细胞轨迹。</strong></u>通过<strong>拟时序分析</strong>帮助大家解析生物体发育、疾病等过程中细胞发生的变化。这是最主要的功能。</p> 
<p><strong>差异表达分析。</strong>Monocle 3 包括一个复杂但易于使用的差分表达系统，可以表征新的细胞类型和状态始于与其他更好理解的细胞进行比较。</p> 
<p><img alt="" height="382" src="https://images2.imgbox.com/94/4e/zPBXnL8w_o.png" width="1200"></p> 
<p><strong> 主要流程</strong></p> 
<p>1.读取数据，创建cell_data_set对象。</p> 
<p>2.数据预处理：标准化，去除批次效应</p> 
<p>3.降维</p> 
<p>4.聚类</p> 
<p>5.进行差异基因表达分析</p> 
<p>6.拟时序分析</p> 
<h2>二、关于不同数据的读取办法</h2> 
<h3>（一）Bioconductor的ExpressionSet对象：</h3> 
<p>monocle3读取的数据要包含3个部分：</p> 
<ul><li><span style="background-color:#fbd4d0;">expression_matrix</span>：表达式值的数字矩阵，其中行是gene，列是cell</li><li><span style="background-color:#fbd4d0;">cell_metadata</span><code>:</code>数据框，其中行是cell，列是细胞属性（如细胞类型、培养条件、获取日期等）</li><li><span style="background-color:#fbd4d0;">gene_metadata </span><code>:</code>数据框，其中行是特征（例如基因），列是基因属性，例如生物型，GC含量等。</li></ul> 
<p>输入前应该确保几个“等式”</p> 
<ul><li><u> expression_matrix 列数= cell_metadata 行数 并且两者要相匹配</u></li><li><u> expression_matrix 行数= gene_metadata 列数 并且两者要相匹配</u></li><li><u> gene_metadata的其中一列应为“gene_short_name”,表示每个基因的基因符号或简要名称</u></li></ul> 
<p>创建对象示例 </p> 
<pre><code class="language-R"># Load the data
expression_matrix &lt;- readRDS(url("https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/cao_l2_expression.rds"))
cell_metadata &lt;- readRDS(url("https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/cao_l2_colData.rds"))
gene_annotation &lt;- readRDS(url("https://depts.washington.edu:/trapnell-lab/software/monocle3/celegans/data/cao_l2_rowData.rds"))


# Make the CDS object
cds &lt;- new_cell_data_set(expression_matrix,
                         cell_metadata = cell_metadata,
                         gene_metadata = gene_annotation)</code></pre> 
<p></p> 
<h3>（二）从 10X 输出生成cell_data_set</h3> 
<p>要找到正确的文件，必须提供包含未修改的Cell Ranger“outs”文件夹的文件夹的路径。文件结构应如下所示：10x_data/outs/filtered_feature_bc_matrix/，其中<span style="color:#1a439c;"><u><span style="background-color:#79c6cd;">filtered_feature_bc_matrix包含 files features.tsv.gz、barcodes.tsv.gz 和 matrix.mtx.gz</span></u></span>。（还可以处理Cell Ranger V2数据，其中<u>“feature”被替换为“gene”</u>，并且文件未被gz压缩。(这个读取起来很容易报错)</p> 
<p>读取示例:注意使用函数是<span style="color:#fe2c24;"><span style="background-color:#fbd4d0;">load_cellranger_data</span></span></p> 
<pre><code class="language-R"># Provide the path to the Cell Ranger output.
cds &lt;- load_cellranger_data("~/Downloads/10x_data")</code></pre> 
<p>或者如果有以下3个文件，也可直接读取：注意使用函数是<span style="color:#be191c;"><span style="background-color:#fbd4d0;">load_mm_data</span></span></p> 
<h3><span style="color:#1a439c;"><u><span style="background-color:#c7e6ea;">matrix.mtx,       feature.tsv             和barcodes.tsv</span></u></span></h3> 
<pre><code class="language-R">cds &lt;- load_mm_data(mat_path = "~/Downloads/matrix.mtx", 
                    feature_anno_path = "~/Downloads/features.tsv", 
                    cell_anno_path = "~/Downloads/barcodes.tsv")</code></pre> 
<h3>（三）处理大量数据</h3> 
<p>当细胞量或基因量比较大的话，可以使用稀疏矩阵的方法读取 </p> 
<pre><code class="language-R">cds &lt;- new_cell_data_set(as(umi_matrix, "sparseMatrix"),
cell_metadata = cell_metadata,
gene_metadata = gene_metadata)</code></pre> 
<h3>（四）多个cds对象组合</h3> 
<pre><code class="language-R"># make a fake second cds object for demonstration
cds2 &lt;- cds[1:100,]

big_cds &lt;- combine_cds(list(cds, cds2))</code></pre> 
<h2>二、数据预处理</h2> 
<h3>（一）数据标准化</h3> 
<pre><code class="language-R">cds &lt;- preprocess_cds(cds, num_dim = 100)#主要是完成数据的标准化＋PCA
plot_pc_variance_explained(cds)#查看的是每个维度的变异分数
cds &lt;- align_cds(cds, alignment_group = "plate")#去除批次效应</code></pre> 
<p>查看每个PC的变异分数：<code>plot_pc_variance_explained()</code> </p> 
<p><img alt="" height="977" src="https://images2.imgbox.com/a8/d2/Cwfj8s06_o.png" width="1200"></p> 
<h3> （二）降维分析并可视化</h3> 
<p>   Monocle 3默认使用UMAP降维，降维方法有两种可以选择：PCA和LSI，RNA-seq数据选择         PCA，如果是ATAC-seq则使用LSI</p> 
<pre><code class="language-R">cds &lt;- reduce_dimension(cds,preprocess_method = 'PCA')</code></pre> 
<ul><li>降维方法<code>method = c("PCA", "LSI")</code>，默认是PCA</li><li>默认维度<code>num_dim</code>是50</li><li>初步降维前归一化<code>norm_method</code> 默认是log处理</li><li>设置降维方法是PCA时，自动进行标准化处理</li></ul> 
<p></p> 
<p>可视化：</p> 
<pre><code class="language-R">plot_cells(cds)</code></pre> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/30/fa/c76NJGT5_o.png" width="1200"></p> 
<p></p> 
<p> 对分群进行着色</p> 
<pre><code class="language-R">colnames(colData(cds))#可以选任意一个进行着色
#[1] "plate"         "cao_cluster"   "cao_cell_type" "cao_tissue"   
#[5] "Size_Factor" 
plot_cells(cds, color_cells_by="cao_cell_type")</code></pre> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/3f/a1/MSLiJaw9_o.png" width="1200"></p> 
<p></p> 
<p> 查看某些基因的表达分布</p> 
<pre><code class="language-R">ciliated_genes &lt;- c("che-1",
                    "hlh-17",
                    "nhr-6",
                    "dmd-6",
                    "ceh-36",
                    "ham-1")

plot_cells(cds,
           genes=ciliated_genes,
           label_cell_groups=FALSE,
           show_trajectory_graph=FALSE)</code></pre> 
<p></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/81/29/9ouCMOzS_o.png" width="1200"></p> 
<p></p> 
<p>tsne降维</p> 
<p>可以看到效果不是很好</p> 
<pre><code class="language-R">#也可以用tsne的方法进行降维，但是效果不好
cds &lt;- reduce_dimension(cds, reduction_method="tSNE")
plot_cells(cds, color_cells_by="cao_cell_type", reduction_method="tSNE")
plot_cells(cds, reduction_method="tSNE", 
           color_cells_by="cao_cell_type",
           cell_size = 2,
           group_label_size = 3)</code></pre> 
<p><img alt="" height="1045" src="https://images2.imgbox.com/3f/fa/ay4agMcC_o.png" width="1143"></p> 
<h2>三、细胞聚类（cluster your cells）</h2> 
<p>这是细胞分群过程中非常重要的一步。Monocle利用Louvain community detection 这个非监督聚类方法（它是<code>phenoGraph</code>算法的一部分），它和我们常见的Kmeans、hclust层次聚类等还不太一样，这个方法<strong>更倾向于找到一个网络中联系紧密的部</strong>分，而经常忽略节点的特性；而我们<strong>常见的聚类</strong>呢，它<strong>一般会忽视整体中各个部分的联系，</strong>而通过<strong>计算两个节点(目标)之间的距离（如欧式距离、曼哈顿距离、余弦相似度等）</strong> 找到相似的特性</p> 
<h3>（一）聚类</h3> 
<p>这里的聚类已经不再是单单的聚类，按照作者的说法，是把细胞进行分区，后去的轨迹分析都会针对这个分区来进行。partition是一些小的cluster的聚合，如果根据cluster进行着色的话会显得比较乱。</p> 
<pre><code class="language-R">cds &lt;- cluster_cells(cds)#聚类之后，每一个cluster会自成一个”拟时序轨迹“
plot_cells(cds, color_cells_by = "partition")</code></pre> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/b4/01/DLHwM04c_o.png" width="1200"></p> 
<p></p> 
<h3>（二）利用learn graph在每个partition中寻找主路径 </h3> 
<p>识别轨迹：对每个cluster进行主成分分析，这步以后拟时序图谱就已经初步产生了</p> 
<pre><code class="language-R">cds &lt;- learn_graph(cds)#对每个cluster进行主成分分析，这步以后拟时序图谱就已经初步产生了
plot_cells(cds,
           color_cells_by = "cao_cell_type",
           label_groups_by_cluster=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE)
plot_cells(cds,
           color_cells_by = "cao_cell_type",
           label_cell_groups=FALSE,
           label_leaves=TRUE,#展示分支
           label_branch_points=TRUE,#展示分支节点
           graph_label_size=1.5)</code></pre> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/09/10/TJzOJZUb_o.png" width="1200"></p> 
<p> <img alt="" height="1200" src="https://images2.imgbox.com/be/c5/c8Y5IVuN_o.png" width="1200"></p> 
<ul><li>图中的<strong>黑线</strong>就是整个架构（注意到整个图并非完全连接的，毕竟是按照partition聚类，每个partition中的细胞差异有点大）；</li><li><strong>浅灰色的圆圈</strong>表示”叶片“表示发育轨迹中的不同结局（可以认为拟时序分析的图是一个”根-茎-叶“结构），用参数<code>label_leaves</code>控制；</li><li><strong>黑色的圆圈</strong>表示分支节点，预示着其中的细胞会有不同发展方向，用参数<code>label_branch_points</code>控制；</li><li>圈中数字大小表示出现时间的先后</li></ul> 
<p></p> 
<h2>四、拟时序分析</h2> 
<h3>（一）首先告诉monocle3，哪个是轨迹分析的起点</h3> 
<h4>1.手动点击添加</h4> 
<pre><code class="language-R">cds &lt;- order_cells(cds)
plot_cells(cds,
           color_cells_by = "pseudotime",
           label_cell_groups=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE,
           graph_label_size=1.5)</code></pre> 
<p></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/fc/a8/AOwr2SZe_o.png" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/e6/30/fKWImmI9_o.png" width="1200"> 展示某些基因在时间轨迹中的表达情况</p> 
<pre><code class="language-R">#某个基因的展示
plot_genes_in_pseudotime(cds[1:5,],
                         color_cells_by="cao_cell_type",
                         min_expr=0.5)</code></pre> 
<p> <img alt="" height="987" src="https://images2.imgbox.com/23/0d/66V6FgbG_o.png" width="1130"></p> 
<p></p> 
<p></p> 
<h4> 2.代码添加，get_earliest_principal_node()函数可以指定起点的名称，在这里指定Am/PH sheath cells这个细胞类型附近作为起点</h4> 
<pre><code class="language-R">#方法一
get_earliest_principal_node &lt;- function(cds, my_select="Am/PH sheath cells"){
  cell_ids &lt;- which(colData(cds)[, "cao_cell_type"] == my_select)
  closest_vertex &lt;-
    cds@principal_graph_aux[["UMAP"]]$pr_graph_cell_proj_closest_vertex
  closest_vertex &lt;- as.matrix(closest_vertex[colnames(cds), ])
  root_pr_nodes &lt;-
    igraph::V(principal_graph(cds)[["UMAP"]])$name[as.numeric(names
                                                              (which.max(table(closest_vertex[cell_ids,]))))]
  
  root_pr_nodes
}#选择想要定义为起点的细胞类型
cds &lt;- order_cells(cds, root_pr_nodes=get_earliest_principal_node(cds))#定义起点
#另一种方法
myselect &lt;- function(cds,select.classify,my_select){
  cell_ids &lt;- which(colData(cds)[,select.classify] == my_select)
  closest_vertex &lt;-
    cds@principal_graph_aux[["UMAP"]]$pr_graph_cell_proj_closest_vertex
  closest_vertex &lt;- as.matrix(closest_vertex[colnames(cds), ])
  root_pr_nodes &lt;-
    igraph::V(principal_graph(cds)[["UMAP"]])$name[as.numeric(names
                                                              (which.max(table(closest_vertex[cell_ids,]))))]
  
  root_pr_nodes
}
cds &lt;- order_cells(cds, 
                   root_pr_nodes=myselect(cds,select.classify = 'cao_cell_type',
                                          my_select = "Body wall muscle")
#绘图
plot_cells(cds,
           color_cells_by = "pseudotime",
           label_cell_groups=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE,
           graph_label_size=1.5)|plot_cells(cds,
           color_cells_by = "cao_cell_type",
           label_cell_groups=FALSE,
           label_leaves=FALSE,
           label_branch_points=FALSE,
           graph_label_size=1.5)#两种着色方式</code></pre> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/4b/60/LOlPe0Uf_o.png" width="1200"></p> 
<p>可以看到以pseudotime为依据着色的话，就是以Body wall muscle为起点的紫色区域，序号1就是这个细胞所在区域。</p> 
<p></p> 
<h3>（二）3D版拟时序分析</h3> 
<p>3D轨迹实际上就是降维时选前3个主成分 =&gt; <code>max_components = 3</code>，后续都和2D保持类似</p> 
<pre><code class="language-R">cds_3d &lt;- reduce_dimension(cds, max_components = 3)#降维
cds_3d &lt;- cluster_cells(cds_3d)#聚类
cds_3d &lt;- learn_graph(cds_3d)#轨迹学习
cds &lt;- order_cells(cds, 
                   root_pr_nodes=myselect(cds,select.classify = 'cao_cell_type',
                                          my_select = "Body wall muscle")
)#选择拟时序分析的起点，和前面2D一样，用代码选择起点
cds_3d_plot_obj &lt;- plot_cells_3d(cds_3d, color_cells_by="cao_cell_type")#绘图</code></pre> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/4e/fe/qH1FK9cJ_o.png" width="1200"></p> 
<p></p> 
<h2>五、差异基因分析</h2> 
<p>差异表达分析，进行基因的轨迹分析，找出哪一些基因在这个轨迹中变化最大，<strong><code>graph_test()</code>这个函数可以进行一个叫做Moran's I 的spatial autocorrelation分析方法</strong></p> 
<pre><code class="language-R">subset_pr_test_res &lt;- graph_test(cds, neighbor_graph="principal_graph", cores=4)#cores是指定核心数</code></pre> 
<p>运行好之后会得到一个表格，</p> 
<p><code>Moran's I</code>这个指标叫：莫兰指数，澳大利亚统计学家莫兰于1950年提出。它是用来<strong>度量空间相关性</strong>的一个指标，数据经过方差归一化之后，会落在-1.0和1.0之间。这个值大于0表示空间正相关，值越大空间相关性越强；等于0时空间是随机性分布；小于0时表示空间负相关，值越小空间差异越大<br> morans_I（空间共表达）,其数值越靠近1代表这个基因在空间距离相近的细胞中表达值越相似，0则代表没有空间共表达效应 </p> 
<p><img alt="" height="492" src="https://images2.imgbox.com/dd/68/WjqUZNJ9_o.png" width="1200"></p> 
<p></p> 
<h4>基因特征图</h4> 
<pre><code class="language-R">#我们这里就按照morans_I的大小来选择前十个基因
top10 &lt;- subset_pr_test_res %&gt;% top_n(n=10, morans_I) %&gt;%
  pull(gene_short_name) %&gt;% as.character()

#基因表达趋势图，绘图,画不出来，一直报错。
p &lt;- plot_genes_in_pseudotime(cds[top10,],
                              color_cells_by="cao_cell_type", 
                              min_expr=0.5, 
                              ncol = 4)
#基因特征图
plot_cells(cds, genes=top10, show_trajectory_graph=FALSE,
           label_cell_groups=FALSE,  label_leaves=FALSE)</code></pre> 
<p><img alt="" height="996" src="https://images2.imgbox.com/a0/28/d2197pt9_o.png" width="1140"></p> 
<h4> 寻找共表达基因模块</h4> 
<p>这个是寻找module与细胞/cluster/partition的相关性，module是指协同表达的基因模块，每个模块的基因可能有相似的表达趋势。</p> 
<pre><code class="language-R">##寻找共表达模块
genelist &lt;- pull(subset_pr_test_res, gene_short_name) %&gt;% as.character()
gene_module &lt;- find_gene_modules(cds[genelist,], resolution=1e-2, cores = 5)
cell_group &lt;- tibble::tibble(cell=row.names(colData(cds)), 
                             cell_group=colData(cds)$celltype)
agg_mat &lt;- aggregate_gene_expression(cds, gene_module, cell_group)
row.names(agg_mat) &lt;- stringr::str_c("Module ", row.names(agg_mat))
pheatmap::pheatmap(agg_mat, scale="column", clustering_method="ward.D2")</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/aa9dece43029afd8dfb90a4a8e290552/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring 框架(声明式)事务学习总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ad53680bdd766e62b1fa5d5c96f4d699/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">H5, 遇到的 ios 兼容性问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>