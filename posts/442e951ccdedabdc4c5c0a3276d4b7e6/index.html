<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>FreeRTOS深入教程（软件定时器源码分析） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="FreeRTOS深入教程（软件定时器源码分析）" />
<meta property="og:description" content="文章目录 前言一、软件定时器结构体二、软件定时器的工作机制三、创建软件定时器四、启动软件定时器五、软件定时器如何知道什么时候被调用总结 前言 除了有硬件定时器，还有软件定时器，那么这篇文章将带大家学习一下软件定时器是如何工作的，以及分析软件定时器的内部源码。
一、软件定时器结构体 软件定时器的本质其实也是一个结构体，在FreeRTOS中会使用一个结构体来管理软件定时器。
软件定时器结构体：
typedef struct tmrTimerControl /* The old naming convention is used to prevent breaking kernel aware debuggers. */ { const char * pcTimerName; /*&lt;&lt; Text name. This is not used by the kernel, it is included simply to make debugging easier. */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */ ListItem_t xTimerListItem; /*&lt;&lt; Standard linked list item as used by all kernel features for event management." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/442e951ccdedabdc4c5c0a3276d4b7e6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-27T10:23:54+08:00" />
<meta property="article:modified_time" content="2023-11-27T10:23:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">FreeRTOS深入教程（软件定时器源码分析）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_7" rel="nofollow">前言</a></li><li><a href="#_10" rel="nofollow">一、软件定时器结构体</a></li><li><a href="#_67" rel="nofollow">二、软件定时器的工作机制</a></li><li><a href="#_122" rel="nofollow">三、创建软件定时器</a></li><li><a href="#_146" rel="nofollow">四、启动软件定时器</a></li><li><a href="#_189" rel="nofollow">五、软件定时器如何知道什么时候被调用</a></li><li><a href="#_205" rel="nofollow">总结</a></li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_7"></a>前言</h2> 
<p>除了有硬件定时器，还有软件定时器，那么这篇文章将带大家学习一下软件定时器是如何工作的，以及分析软件定时器的内部源码。</p> 
<h2><a id="_10"></a>一、软件定时器结构体</h2> 
<p>软件定时器的本质其实也是一个结构体，在FreeRTOS中会使用一个结构体来管理软件定时器。</p> 
<p><code>软件定时器结构体：</code></p> 
<pre><code class="prism language-c">    <span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">tmrTimerControl</span>                  <span class="token comment">/* The old naming convention is used to prevent breaking kernel aware debuggers. */</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> pcTimerName<span class="token punctuation">;</span>                   <span class="token comment">/*&lt;&lt; Text name.  This is not used by the kernel, it is included simply to make debugging easier. */</span> <span class="token comment">/*lint !e971 Unqualified char types are allowed for strings and single characters only. */</span>
        ListItem_t xTimerListItem<span class="token punctuation">;</span>                  <span class="token comment">/*&lt;&lt; Standard linked list item as used by all kernel features for event management. */</span>
        TickType_t xTimerPeriodInTicks<span class="token punctuation">;</span>             <span class="token comment">/*&lt;&lt; How quickly and often the timer expires. */</span>
        <span class="token keyword">void</span> <span class="token operator">*</span> pvTimerID<span class="token punctuation">;</span>                           <span class="token comment">/*&lt;&lt; An ID to identify the timer.  This allows the timer to be identified when the same callback is used for multiple timers. */</span>
        TimerCallbackFunction_t pxCallbackFunction<span class="token punctuation">;</span> <span class="token comment">/*&lt;&lt; The function that will be called when the timer expires. */</span>
        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span> configUSE_TRACE_FACILITY <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span></span></span>
            UBaseType_t uxTimerNumber<span class="token punctuation">;</span>              <span class="token comment">/*&lt;&lt; An ID assigned by trace tools such as FreeRTOS+Trace */</span>
        <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
        <span class="token class-name">uint8_t</span> ucStatus<span class="token punctuation">;</span>                           <span class="token comment">/*&lt;&lt; Holds bits to say if the timer was statically allocated or not, and if it is active or not. */</span>
    <span class="token punctuation">}</span> xTIMER<span class="token punctuation">;</span>
</code></pre> 
<p><code>参数解释：</code></p> 
<p>pcTimerName (const char)：*</p> 
<p>用途：文本名称，主要用于调试目的，不被内核使用。<br> 说明：该成员是一个指向常量字符的指针，表示定时器的文本名称。在调试过程中，可以使用这个名称来标识定时器，但它对于内核本身并没有实际的功能。</p> 
<p>xTimerListItem (ListItem_t)：</p> 
<p>用途：链表项，用于事件管理。<br> 说明：这是一个用于链接定时器的标准链表项。它被用于将定时器链接到一个链表中，以进行事件管理。链表通常由RTOS内核用于跟踪定时器。</p> 
<p>xTimerPeriodInTicks (TickType_t)：</p> 
<p>用途：定时器的周期，以时钟节拍为单位。<br> 说明：表示定时器的周期，即定时器多久触发一次，以时钟节拍（Tick）为单位。时钟节拍是RTOS中的基本时间单位。</p> 
<p>pvTimerID (void)：*</p> 
<p>用途：用于标识定时器的ID。<br> 说明：这是一个指向void类型的指针，用于标识定时器。当相同的回调函数用于多个定时器时，通过这个ID可以唯一标识定时器。</p> 
<p>pxCallbackFunction (TimerCallbackFunction_t)：</p> 
<p>用途：定时器到期时调用的回调函数。<br> 说明：这是一个指向定时器到期时将被调用的回调函数的指针。当定时器到期时，RTOS将调用此函数执行相应的操作。</p> 
<p>uxTimerNumber (UBaseType_t)：</p> 
<p>用途：由跟踪工具分配的定时器ID。<br> 说明：在启用了跟踪工具（如FreeRTOS+Trace）的情况下，该成员表示由这些工具分配的定时器ID。</p> 
<p>ucStatus (uint8_t)：</p> 
<p>用途：包含位信息，指示定时器的静态分配状态和活动状态。<br> 说明：这是一个包含位信息的字节，用于表示定时器的状态。其中的位可能包括指示定时器是否静态分配、定时器是否活动等信息。</p> 
<h2><a id="_67"></a>二、软件定时器的工作机制</h2> 
<p>使用软件定时器的这些API其实就是在给一个队列发送消息，那么谁来接收这些消息并执行呢？</p> 
<p><code>答案就是守护任务来接收消息并执行。</code></p> 
<p>在xTimerCreateTimerTask函数中会调用prvCheckForValidListAndQueue函数创建出队列和两个链表用于管理软件定时器。<br> <img src="https://images2.imgbox.com/89/02/wKRUEghk_o.png" alt="在这里插入图片描述"><br> <code>创建链表和队列代码：</code><br> <img src="https://images2.imgbox.com/d5/6d/48oWbn3Y_o.png" alt="在这里插入图片描述"><br> 这里会创建两个链表：pxCurrentTimerList链表和pxOverflowTimerList链表。</p> 
<p><code>当前定时器列表 pxCurrentTimerList：</code></p> 
<p>插入新定时器： 当系统创建并激活新的定时器时，该定时器会以超时时间升序的方式插入到 pxCurrentTimerList 列表中。这样的设计可以使得链表中的定时器按照即将到期的顺序排列。</p> 
<p>扫描与处理： 定时器任务在系统运行中会扫描 pxCurrentTimerList 中的第一个定时器，检查是否已经超时。如果已经超时，就会调用与该定时器关联的回调函数进行相应的处理。如果还未超时，可能会将定时器任务挂起等待，直到下一次扫描。</p> 
<p><code>溢出定时器列表 pxOverflowTimerList：</code></p> 
<p>与 pxCurrentTimerList 相似： pxOverflowTimerList 的作用与 pxCurrentTimerList 类似，用于存储那些因为系统计数器溢出而暂时不活动的定时器。</p> 
<p>处理溢出情况： 当系统的节拍计数器溢出时，说明经过了很长一段时间，此时原本在 pxCurrentTimerList 中的定时器可能已经到期。这时，这些到期的定时器将会被移动到 pxOverflowTimerList 中。</p> 
<p><code>列表交换：</code></p> 
<p>溢出后的交换： 当系统节拍计数器发生溢出时，两个列表的功能会进行交换。也就是说，pxOverflowTimerList 变为当前列表，而 pxCurrentTimerList 变为溢出列表。这样交换后，之前在 pxCurrentTimerList 中因为溢出而移动到 pxOverflowTimerList 的定时器将成为下一轮的活动定时器，而 pxCurrentTimerList 将被重新用于新的定时器的插入。</p> 
<p><code>这样的设计使得系统在处理定时器时能够更高效地管理和利用定时器，特别是在考虑到系统计数器溢出的情况下。通过不断地在两个列表之间交换，系统能够有效地处理长时间运行和定时器溢出的情况，确保定时器功能的可靠性。</code></p> 
<p><code>消息队列xTimerQueue，这个队列会存储接收到的消息，守护任务可以读取这个队列中的消息并进行处理。</code></p> 
<p><code>守护任务在启动调度器时会自动被创建：</code></p> 
<pre><code class="prism language-c"> <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token punctuation">(</span> configUSE_TIMERS <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">)</span></span></span>
     <span class="token punctuation">{<!-- --></span>
         <span class="token keyword">if</span><span class="token punctuation">(</span> xReturn <span class="token operator">==</span> pdPASS <span class="token punctuation">)</span>
         <span class="token punctuation">{<!-- --></span>
             xReturn <span class="token operator">=</span> <span class="token function">xTimerCreateTimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
         <span class="token keyword">else</span>
         <span class="token punctuation">{<!-- --></span>
             <span class="token function">mtCOVERAGE_TEST_MARKER</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
</code></pre> 
<p><code>守护任务的优先级通常需要设置为最高，可以通过配置这个configTIMER_TASK_PRIORITY宏来改变优先级。</code></p> 
<p><img src="https://images2.imgbox.com/0a/a3/nqCdgp3r_o.png" alt="在这里插入图片描述"><br> <code>在守护任务内部会处理队列中的消息：</code></p> 
<p><img src="https://images2.imgbox.com/70/43/iiHt28j3_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/47/4e/8a6PRplp_o.png" alt="在这里插入图片描述"><br> <code>软件定时器工作机制：</code><br> <img src="https://images2.imgbox.com/42/c5/dLDs9Shj_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_122"></a>三、创建软件定时器</h2> 
<p><code>重要代码分析：</code></p> 
<p>首先需要使用pvPortMalloc申请一个软件定时器结构体。</p> 
<pre><code class="prism language-c">Timer_t <span class="token operator">*</span> pxNewTimer<span class="token punctuation">;</span>

pxNewTimer <span class="token operator">=</span> <span class="token punctuation">(</span> Timer_t <span class="token operator">*</span> <span class="token punctuation">)</span> <span class="token function">pvPortMalloc</span><span class="token punctuation">(</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span> Timer_t <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>初始化创建出来的软件定时器：</p> 
<pre><code class="prism language-c"><span class="token function">prvInitialiseNewTimer</span><span class="token punctuation">(</span> pcTimerName<span class="token punctuation">,</span> xTimerPeriodInTicks<span class="token punctuation">,</span> uxAutoReload<span class="token punctuation">,</span> pvTimerID<span class="token punctuation">,</span> pxCallbackFunction<span class="token punctuation">,</span> pxNewTimer <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>对软件定时器中的成员进行赋值，并且初始化链表项。</p> 
<pre><code class="prism language-c">pxNewTimer<span class="token operator">-&gt;</span>pcTimerName <span class="token operator">=</span> pcTimerName<span class="token punctuation">;</span>
pxNewTimer<span class="token operator">-&gt;</span>xTimerPeriodInTicks <span class="token operator">=</span> xTimerPeriodInTicks<span class="token punctuation">;</span>
pxNewTimer<span class="token operator">-&gt;</span>pvTimerID <span class="token operator">=</span> pvTimerID<span class="token punctuation">;</span>
pxNewTimer<span class="token operator">-&gt;</span>pxCallbackFunction <span class="token operator">=</span> pxCallbackFunction<span class="token punctuation">;</span>
<span class="token function">vListInitialiseItem</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span><span class="token punctuation">(</span> pxNewTimer<span class="token operator">-&gt;</span>xTimerListItem <span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_146"></a>四、启动软件定时器</h2> 
<p><code>启动软件定时器其实就是调用xTimerGenericCommand函数向队列发送消息。</code></p> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">xTimerStart</span><span class="token expression"><span class="token punctuation">(</span> xTimer<span class="token punctuation">,</span> xTicksToWait <span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">xTimerGenericCommand</span><span class="token punctuation">(</span> <span class="token punctuation">(</span> xTimer <span class="token punctuation">)</span><span class="token punctuation">,</span> tmrCOMMAND_START<span class="token punctuation">,</span> <span class="token punctuation">(</span> <span class="token function">xTaskGetTickCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token punctuation">(</span> xTicksToWait <span class="token punctuation">)</span> <span class="token punctuation">)</span></span></span>
</code></pre> 
<p><code>构造消息：</code></p> 
<pre><code class="prism language-c">DaemonTaskMessage_t xMessage<span class="token punctuation">;</span>
xMessage<span class="token punctuation">.</span>xMessageID <span class="token operator">=</span> xCommandID<span class="token punctuation">;</span>
xMessage<span class="token punctuation">.</span>u<span class="token punctuation">.</span>xTimerParameters<span class="token punctuation">.</span>xMessageValue <span class="token operator">=</span> xOptionalValue<span class="token punctuation">;</span>
xMessage<span class="token punctuation">.</span>u<span class="token punctuation">.</span>xTimerParameters<span class="token punctuation">.</span>pxTimer <span class="token operator">=</span> xTimer<span class="token punctuation">;</span>
</code></pre> 
<p><code>发送消息：</code></p> 
<pre><code class="prism language-c"><span class="token keyword">if</span><span class="token punctuation">(</span> xCommandID <span class="token operator">&lt;</span> tmrFIRST_FROM_ISR_COMMAND <span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span> <span class="token function">xTaskGetSchedulerState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> taskSCHEDULER_RUNNING <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        xReturn <span class="token operator">=</span> <span class="token function">xQueueSendToBack</span><span class="token punctuation">(</span> xTimerQueue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>xMessage<span class="token punctuation">,</span> xTicksToWait <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{<!-- --></span>
        xReturn <span class="token operator">=</span> <span class="token function">xQueueSendToBack</span><span class="token punctuation">(</span> xTimerQueue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>xMessage<span class="token punctuation">,</span> tmrNO_DELAY <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span>
<span class="token punctuation">{<!-- --></span>
    xReturn <span class="token operator">=</span> <span class="token function">xQueueSendToBackFromISR</span><span class="token punctuation">(</span> xTimerQueue<span class="token punctuation">,</span> <span class="token operator">&amp;</span>xMessage<span class="token punctuation">,</span> pxHigherPriorityTaskWoken <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>启动软件定时器后会将软件定时器挂入pxCurrentTimerList链表中。</code></p> 
<p>启动软件定时器其实就是给队列发送了命令，那么守护任务接收到命令后就会进行处理：</p> 
<p><img src="https://images2.imgbox.com/2a/9d/2oNjudmV_o.png" alt="在这里插入图片描述"><br> <code>根据超时时间的长短挂入pxCurrentTimerList链表中。</code></p> 
<p><img src="https://images2.imgbox.com/7f/31/WGz9znYw_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_189"></a>五、软件定时器如何知道什么时候被调用</h2> 
<p><code>在守护任务中有一个无限循环会一直判断是否有软件定时器超时。</code></p> 
<p><img src="https://images2.imgbox.com/8c/82/AyPL9bbp_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-c"><span class="token comment">/* 获取最近一次定时器超时时间 */</span>
xNextExpireTime <span class="token operator">=</span> <span class="token function">prvGetNextExpireTime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>xListWasEmpty<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* 处理超时的定时器或者让队列阻塞 */</span>
<span class="token function">prvProcessTimerOrBlockTask</span><span class="token punctuation">(</span>xNextExpireTime<span class="token punctuation">,</span> xListWasEmpty<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* 处理队列接收到的命令 */</span>
<span class="token function">prvProcessReceivedCommands</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="_205"></a>总结</h2> 
<p>本篇文章就讲解到这里，下篇文章继续给大家讲解。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/88da325480d0a8db969f0ee9582e6913/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">芯课堂 | SWM341 I2C 接口应用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9bda16ae9b52db38f36bb66d26e0d6e7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CentOS用nginx搭建文件下载服务器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>