<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【笔记】构建docker镜像 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【笔记】构建docker镜像" />
<meta property="og:description" content="什么是Dockerfile Dockerfile是一个纯文本文件，里面记录了一系列构建命令，每个指令都会生成一个Layer，Docker顺序执行这个文件里的步骤最终就会创建出一个新的镜像。
编写Dockerfile FROM 构建镜像的第一条指令必须是FROM，FROM作用是用于选择基础镜像。
eg:
FROM alpine:3.15 #选择Alpine镜像 FROM ubuntu:bionic #选择Ubuntu镜像 COPY 如果需要将一些文件打包到镜像中（例如一些源码、配置）。可以使用COPY命令，用法类似Linux cp命令，但是复制的源文件必须是“构建上下文”的路径，不能随意指定文件。“构建上下文”是指docker build执行时所在的目录。
eg:
COPY ./aa.xml /tmp/aa.xml #将上下文中aa.xml复制到镜像的/tmp目录下 COPY /etc/host /tmp #错误，不能使用上下文之外的文件 RUN RUN指令包含很多shell指令。Dockerfile里一条指令只能是一行，因此RUN指令每行末尾使用续行符 \，命令之间需要使用 &amp;&amp; 来连接。如果shell命令过长，可以将这些命令集中到一个脚本文件中，用COPY命令复制到镜像中使用RUN来执行
eg:
COPY ./setup.sh /tmp/ # 复制脚本到tmp目录 RUN cd /tmp &amp;&amp; chmod &#43;x setup.sh \ #到tmp目录，添加执行权限 &amp;&amp; ./setup.sh &amp;&amp; rm setup.sh # 执行脚本并在执行后删除 ARG 和 ENV 这两条指令都可以用来创建变量，实现参数化运行。它们的区别在于ARG创建的变量在镜像构建过程中可见，容器运行是不可见。ENV 镜像构建以及容器运行时都可见。
eg:
ARG USER=&#34;root&#34; ENV USER=&#34;root&#34; EXPOSE EXPOSE 指令用来暴露对外服务的端口号
EXPOSE 443 # 默认tcp协议 EXPOST 53/udp # 指定udp协议 每条指令都会生产一个镜像层，Dockerfile中不要滥用指令，尽量精简合并，避免镜像臃肿不堪。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ad1e93d5dba2e37fa04c0bb12e8218d6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-22T15:37:54+08:00" />
<meta property="article:modified_time" content="2023-09-22T15:37:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【笔记】构建docker镜像</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>什么是Dockerfile</h2> 
<p>Dockerfile是一个纯文本文件，里面记录了一系列构建命令，每个指令都会生成一个Layer，Docker顺序执行这个文件里的步骤最终就会创建出一个新的镜像。</p> 
<h2>编写Dockerfile</h2> 
<h3>FROM</h3> 
<p>构建镜像的第一条指令必须是FROM，FROM作用是用于选择基础镜像。</p> 
<p>eg:</p> 
<pre><code class="language-bash">FROM alpine:3.15 #选择Alpine镜像
FROM ubuntu:bionic #选择Ubuntu镜像</code></pre> 
<h3>COPY</h3> 
<p>如果需要将一些文件打包到镜像中（例如一些源码、配置）。可以使用COPY命令，用法类似Linux cp命令，但是复制的源文件必须是“<strong>构建上下文</strong>”的路径，不能随意指定文件。“构建上下文”是指docker build执行时所在的目录。</p> 
<p>eg:</p> 
<pre><code class="language-bash">COPY ./aa.xml /tmp/aa.xml #将上下文中aa.xml复制到镜像的/tmp目录下
COPY /etc/host /tmp #错误，不能使用上下文之外的文件</code></pre> 
<p></p> 
<h3>RUN</h3> 
<p>RUN指令包含很多shell指令。Dockerfile里一条指令只能是一行，因此RUN指令每行末尾使用续行符 \，命令之间需要使用 &amp;&amp; 来连接。如果shell命令过长，可以将这些命令集中到一个脚本文件中，用COPY命令复制到镜像中使用RUN来执行</p> 
<p>eg:</p> 
<pre><code class="language-bash">COPY ./setup.sh /tmp/ # 复制脚本到tmp目录
RUN cd /tmp &amp;&amp; chmod +x setup.sh \  #到tmp目录，添加执行权限
    &amp;&amp; ./setup.sh &amp;&amp; rm setup.sh # 执行脚本并在执行后删除</code></pre> 
<h3>ARG 和 ENV</h3> 
<p>这两条指令都可以用来创建变量，实现参数化运行。它们的区别在于ARG创建的变量在镜像构建过程中可见，容器运行是不可见。ENV 镜像构建以及容器运行时都可见。</p> 
<p>eg:</p> 
<pre><code class="language-bash">ARG USER="root"
ENV USER="root"</code></pre> 
<h3>EXPOSE</h3> 
<p>EXPOSE 指令用来暴露对外服务的端口号</p> 
<pre><code class="language-bash">EXPOSE 443 # 默认tcp协议
EXPOST 53/udp # 指定udp协议</code></pre> 
<p><strong> 每条指令都会生产一个镜像层，Dockerfile中不要滥用指令，尽量精简合并，避免镜像臃肿不堪。</strong></p> 
<h2 style="background-color:transparent;">docker build</h2> 
<p>Dockerfile 必须经过docker build 才能生效。</p> 
<p>docker打包时会将上下文中所有文件都进行打包，为了避免不必要的文件上次打包影响打包效率，可以在“构建上下文”中创建 .dockerignore文件，排除不需要的文件。该文件语法与.gitignore类似。</p> 
<p> eg:</p> 
<pre><code class="language-bash">#docker ignore
*.swp
*.sh</code></pre> 
<p></p> 
<p>docker build 可以使用 -f 显式指定Dockerfile文件，如果不指定这个参数会默认找到当前目录下Dockerfile文件。</p> 
<p>docker build 使用 -t 指定镜像标签，这样构建完成后会自动为镜像添加名字。</p> 
<p>eg:</p> 
<pre><code class="language-bash">docker build -f ./Dockerfile -t my_image:1.0.0</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d86188bfb1122cab49cf9fedd71682ec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL5.7对json的支持</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/08f80a7a6aa3fbe62b059676a84e8c78/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">SpringMVC(二) -- HandlerAdapter</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>