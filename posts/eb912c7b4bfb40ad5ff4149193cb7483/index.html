<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis 7.0 核心技术、实战应用、面试题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis 7.0 核心技术、实战应用、面试题" />
<meta property="og:description" content="Redis 7.0 核心技术与实战应用 🌈 Redis 入门概述 01、Redis 是什么 Redis：REmote Dictionary Server（远程字典服务器）
官网介绍：https://redis.io/docs/about
官网定义：Remote Dictionary Server（远程字典服务）是完全开源的，使用 ANSIC 语言编写遵守 BSD 协议，是一个高性能的 Key-Value 数据库提供了丰富的数据结构，例如 String、Hash、List、Set、SortedSet 等。数据是存在内存中的，同时支持 事务、持久化、LUA脚本、发布/订阅、缓存淘汰、流技术 等多种功能特性。提供了 主从模式、Redis Sentinel 和 Redis Cluster 集群架构方案。
02、Redis 使用场景 🅰️ 1、主流功能与应用
1）分布式缓存，挡在 MySQL 数据库之前的带刀护卫
与传统数据库（MySQL）关系：
Redis 是 key-value 数据库（NoSQL 一种），MySQL 是关系数据库；Redis 数据操作主要在内存，而 MySQL 主要存储在磁盘；Redis 在某一些场景使用中要明显优于 MySQL，比如计数器、排行榜等方面；Redis 通常用于一些特定场景，需要与 MySQL 一起配合使用；两者并不是相互替换和竞争关系，而是共用和配合使用。 2）内存存储和持久化（RDB &#43; AOF）
Redis 支持 异步 将内存中的数据写到硬盘上，同时不影响继续服务。
3）高可用架构搭配
支持 单机、主从、哨兵、集群 架构模式。
4）缓存穿透、击穿、雪崩
5）分布式锁
6）队列
Reids 提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列平台来使用。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/eb912c7b4bfb40ad5ff4149193cb7483/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-24T18:45:11+08:00" />
<meta property="article:modified_time" content="2023-07-24T18:45:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis 7.0 核心技术、实战应用、面试题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Redis_70__0"></a>Redis 7.0 核心技术与实战应用</h2> 
<h2><a id="rainbow_Redis__2"></a>🌈 Redis 入门概述</h2> 
<h3><a id="01Redis__4"></a>01、Redis 是什么</h3> 
<p><code>Redis</code>：REmote Dictionary Server（远程字典服务器）</p> 
<p>官网介绍：https://redis.io/docs/about</p> 
<p>官网定义：Remote Dictionary Server（远程字典服务）是完全开源的，使用 ANSIC 语言编写遵守 BSD 协议，是一个高性能的 Key-Value 数据库提供了丰富的数据结构，例如 <code>String</code>、<code>Hash</code>、<code>List</code>、<code>Set</code>、<code>SortedSet</code> 等。数据是存在内存中的，同时支持 <code>事务</code>、<code>持久化</code>、<code>LUA脚本</code>、<code>发布/订阅</code>、<code>缓存淘汰</code>、<code>流技术</code> 等多种功能特性。提供了 <code>主从模式</code>、<code>Redis Sentinel</code> 和 <code>Redis Cluster</code> 集群架构方案。</p> 
<h3><a id="02Redis__12"></a>02、Redis 使用场景</h3> 
<p>🅰️ 1、主流功能与应用</p> 
<p>1）<code>分布式缓存</code>，挡在 MySQL 数据库之前的带刀护卫</p> 
<p><img src="https://images2.imgbox.com/16/9b/FK3fDPtV_o.png" alt="在这里插入图片描述"></p> 
<p>与传统数据库（MySQL）关系：</p> 
<ul><li>Redis 是 key-value 数据库（NoSQL 一种），MySQL 是关系数据库；</li><li>Redis 数据操作主要在内存，而 MySQL 主要存储在磁盘；</li><li>Redis 在某一些场景使用中要明显优于 MySQL，比如计数器、排行榜等方面；</li><li>Redis 通常用于一些特定场景，需要与 MySQL 一起配合使用；</li><li>两者并不是相互替换和竞争关系，而是共用和配合使用。</li></ul> 
<p>2）内存存储和持久化（<code>RDB</code> + <code>AOF</code>）</p> 
<p>Redis 支持 <code>异步</code> 将内存中的数据写到硬盘上，同时不影响继续服务。</p> 
<p>3）高可用架构搭配</p> 
<p>支持 <code>单机</code>、<code>主从</code>、<code>哨兵</code>、<code>集群</code> 架构模式。</p> 
<p>4）缓存穿透、击穿、雪崩</p> 
<p>5）分布式锁</p> 
<p>6）队列</p> 
<p>Reids 提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列平台来使用。</p> 
<p>可通过 Reids 的 <code>队列</code> 功能做购买限制。比如到节假日或者推广期间，进行一些活动，对用户购买行为进行限制，限制今天只能购买几次商品或者一段时间内只能购买一次。</p> 
<p>7）排行版+点赞</p> 
<p>在互联网应用中，有各种各样的排行榜，如电商网站的月度销量排行榜、社交APP的礼物排行榜、小程序的投票排行榜等等。Redis 提供的 <code>zset</code> 数据类型能够快速实现这些复杂的排行榜。</p> 
<p>比如小说网站对小说进行排名，根据排名，将排名靠前的小说推荐给用户。</p> 
<p>🅰️ 2、总体功能概述</p> 
<p><img src="https://images2.imgbox.com/41/74/1fbC8201_o.png" alt="在这里插入图片描述"></p> 
<p>🅰️ 3、优势</p> 
<p>1）<code>性能极高</code> ：Redis 能读的速度是 110000次/秒，写的速度是 81000次/秒。</p> 
<p>2）<code>数据类型丰富</code> ：支持简单的 key-value 类型数据，还提供 <code>list</code>，<code>set</code>，<code>zset</code>，<code>hash</code> 等数据结构的存储。</p> 
<p>3）<code>数据的持久化</code> ：可以将内存中的数据保持在磁盘中，重启的时候可以再次加载数据进行使用。</p> 
<p>4）<code>数据的备份</code> ：即 <code>master-slave</code> 模式的数据备份。</p> 
<p>🅰️ 4、小结</p> 
<p><img src="https://images2.imgbox.com/5e/5b/mqZluuzh_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="03Redis__72"></a>03、Redis 下载使用</h3> 
<p>🅰️ 1、地址</p> 
<p>文档：https://redis.io</p> 
<p>源码：https://github.com/redis/redis</p> 
<p>在线测试：https://try.redis.io</p> 
<p>命令参考：http://doc.redisfans.com</p> 
<p>中文资料：</p> 
<ul><li>http://www.redis.cn</li><li>https://redis.com.cn/documentation.html</li></ul> 
<p>下载地址：https://redis.io/download</p> 
<p>🅰️ 2、使用</p> 
<p>官网：https://redis.io/docs/about</p> 
<ul><li>Transactions</li><li>Pub/Sub</li><li>Lua scripting</li><li>Keys with a limited time-to-live</li><li>LRU eviction of keys</li><li>Automatic failover</li></ul> 
<h3><a id="04Redis__102"></a>04、Redis 迭代演化</h3> 
<p>🅰️ 1、版本迭代推演介绍</p> 
<p>1）里程碑式的重要版本</p> 
<p><img src="https://images2.imgbox.com/b8/30/xhJDzWbK_o.png" alt="在这里插入图片描述"></p> 
<p>Redis 3.0 中的 cluster 解决了 Redis 的单机瓶颈，将其从主从架构变成了分布式集群架构；4.0 版本的 lazy-free 彻底解决了大 KEY 删除阻塞的运维痛点， modules 则将 Redis 的功能进行了进一步拓展，使其能够实现更多能力，比如 RedisSearch 带来了全文搜索能力； 5.0 版本的 Stream 使 Redis 真正意义上成为了轻量级的消息队列； 6.0 版本的多 IO 和 SSL 提高了 Redis 的性能和安全性。</p> 
<p>所有核心特性都在保持 Redis 稳定性的前提下，围绕着性能、扩展性、安全场景和拓展四个方面不断增强。</p> 
<p>2）命名规则</p> 
<p>Redis 从发布至今，一直遵循着自己的命名规则：</p> 
<ul><li>版本号第二位如果是奇数，则为非稳定版本，如 2.7、2.9、3.1</li><li>版本号第二位如果是偶数，则为稳定版本，如 2.6、2.8、3.0、3.2</li><li>当前奇数版本就是下一个稳定版本的开发版本，如 2.9 版本是 3.0 版本的开发版本</li></ul> 
<p>可以通过官网来下载自己感兴趣的版本进行源码阅读：</p> 
<p>历史发布版本的源码：https://download.redis.io/releases</p> 
<p>🅰️ 2、Redis 7 新特性概述</p> 
<p>地址：<a href="https://github.com/redis/redis/releases">https://github.com/redis/redis/releases</a></p> 
<p>1）部分新特性总览</p> 
<p>2022 年 4 月正式发布的 Redis 7.0 是目前 Redis 历史版本中变化最大的版本。</p> 
<p>首先，它有超过 50 个以上新增命令；其次，它有大量核心特性的新增和改进。</p> 
<p><img src="https://images2.imgbox.com/78/fe/H8n0uIFy_o.png" alt="在这里插入图片描述"></p> 
<ul><li>Redis Functions （了解）</li></ul> 
<p><img src="https://images2.imgbox.com/ba/94/XQjncYke_o.png" alt="在这里插入图片描述"></p> 
<p>Functions 彻底解决了过去 Lua 脚本在持久化上含糊不清的问题，安全性也得到了大幅度提高，通过使用 Functions 即可完全避免 Lua 脚本丢失的问题了，极大减轻了运维压力。</p> 
<ul><li>Client-eviction</li></ul> 
<p><img src="https://images2.imgbox.com/a5/29/QkaSAbs0_o.png" alt="在这里插入图片描述"></p> 
<p>Redis 7.0 新增了 client-invocation 参数，能够从全局的角度对 Redis 连接总内存占用进行控制。举个例子，如果连接总内存占用超过配置上限， Redis 会优先清理内存占用较大的连接，在一定程度上实现了对内存占用和数据内存占用的隔离控制，能够更好地管理 Redis 内存，节约内存使用成本，无须再预留过多内存。</p> 
<ul><li>Multi-part AOF</li></ul> 
<p><img src="https://images2.imgbox.com/48/25/vicYEHJv_o.png" alt="在这里插入图片描述"></p> 
<p>AOF 触发 Rewrite 的时候，Redis 会先将全量数据做内存快照，然后落盘。落盘的漫长过程中会产生增量数据，此时 Redis 会开辟一块新的内存空间来记录这些增量数据，这就带来了额外的内存开销。在极端情况下，AOF Rewrite 过程中的额外内存占用会与 Redis 的数据内存几乎相等，极易发生 OOM ,因此也被迫需要在操作系统中预留更多内存来避免 Redis OOM 的发生，这也是 Redis 内存资源浪费的重要原因。</p> 
<p>此外，在 AOF Rewrite 的最后，Redis 会将全量数据与增量数据做一次合并操作，导致一份数据带来两次磁盘 IO。 同时在 AOF 的合并过程中，主进程和子进程之间的数据交互也会占用 CPU 资源。</p> 
<p>所以在 AOF Rewrite 过程中，内存、IO、CPU 都会被占用，而这些都是额外的负担，非常影响业务。因此，通常需要将 AOF 自动 Rewrite 改在业务低峰期，通过脚本触发，甚至关闭 AOF。</p> 
<p>Multi-part AOF 是对 AOF 的彻底改造。它将 AOF 分为三个部分，分别是 base AOF、incr AOF 和 History AOF 。其中 base AOF 用来记录 AOF Rewrite 时刻的全量内存数据，incr AOF 用来记录 rewrite 过程中所有增量数据。incr AOF 的出现，使 Redis 不需要再开辟新的内存空间来记录增量数据。而多文件设计的理念也使得新版 AOF 无需做数据合并，因为它的全量和增量被放在不同文件中，天然隔离。在 AOF React 的最后，此前的历史 AOF 文件都会成为 history AOF 被直接删除，因而也不存在合并。</p> 
<ul><li>ACL V2</li></ul> 
<p><img src="https://images2.imgbox.com/f0/f4/xkrw4aho_o.png" alt="在这里插入图片描述"></p> 
<p>Redis 6.0 大版本中引入了 ACL v1，虽然能够实现一定程度的权限控制，但实用性并不强，比如无法支持粒度至 KEY 的权限访问控制，所有 KEY 的权限必须一致。而在 Redis 7.0 中， ACL v2 正式支持粒度至 KEY 的权限访问控制，可以轻松实现账户对不同 KEY 有不同的权限访问控制。</p> 
<p>基于 ACL v2，过去 Redis 常被诟病的业务权限难以维护管理的问题也将得到彻底解决。</p> 
<ul><li>新增命令（了解）</li></ul> 
<p>新增 ZMPOP，BZMPOP，LMPOP，BLMPOP 等新命令，对于 EXPIRE 和 SET 命令，新增了更多的命令参数选项。</p> 
<p>例如，ZMPOP 的格式如下：<code>ZMPOP numkeys key [key ...] MIN|MAX [COUNT count]</code>，而 BZMPOP 是 ZMPOP 的阻塞版本。</p> 
<ul><li>listpack 替代 ziplist</li></ul> 
<p>listpack 是用来替代 ziplist 的新数据结构，在 7.0 版本已经没有 ziplist 的配置了（6.0 版本仅部分数据类型作为过渡阶段在使用）</p> 
<p>🅰️ 3、部分新特性说明</p> 
<p>大体和之前的 Redis 版本保持一致和稳定，主要是自身底层性能和资源利用率上的 <code>优化和提高</code>，如果你生产上系统稳定，不用着急升级到最新的 Redis 7 版本，当然，如果你是从零开始的新系统，可以直接上 Redis 7。</p> 
<p>1）多 AOF 文件支持</p> 
<p>7.0 版本中一个比较大的变化就是 AOF 文件由一个变成了多个，主要分为两种类型：基本文件（base files）、增量文件（incr files），请注意这些文件名称是复数形式说明每一类文件不仅仅只有一个。在此之外还引入了一个清单文件（manifest）用于跟踪文件以及文件的创建和应用顺序（恢复）。</p> 
<p>2）config 命令增强</p> 
<p>对于 Config Set 和 Get 命令，支持在一次调用过程中传递多个配置参数。例如，现在我们可以在执行一次 Config Set 命令中更改多个参数： <code>config set maxmemory 10000001 maxmemory-clients 50% port 6399</code>。</p> 
<p>3）限制客户端内存使用 Client-eviction</p> 
<p>当 Redis 连接较多，再加上每个连接的内存占用都比较大的时候， Redis 总连接内存占用可能会达到 <code>maxmemory</code> 的上限，可以增加允许限制所有客户端的总内存使用量配置项，redis.config 中对应的配置项，两种配置形式：指定内存大小、基于 maxmemory 的百分比。</p> 
<ul><li>maxmemory-clients 1g</li><li>maxmemory-clients 10%</li></ul> 
<p>4）listpack 紧凑列表调整</p> 
<p>listpack 是用来替代 ziplist 的新数据结构，在 7.0 版本已经没有 ziplist 的配置了（6.0 版本仅部分数据类型作为过渡阶段在使用）listpack 已经替换了 ziplist 类似 hash-max-ziplist-entries 的配置。</p> 
<p>5）访问安全性增强 ACLV2</p> 
<p>在 redis.conf 配置文件中，<code>protected-mode</code> 默认为 <code>yes</code>，只有当你希望你的客户端在没有授权的情况下可以连接到 Redis server 的时候可以将 protected-mode 设置为 no。</p> 
<p>6）Redis Functions</p> 
<p>Redis 函数，一种新的通过服务端脚本扩展 Redis 的方式，函数与数据本身一起存储。</p> 
<p>7）RDB 保存时间调整</p> 
<p>将持久化文件 RDB 的保存规则发生了改变，尤其是时间记录频度变化。</p> 
<p>8）命令新增和变动</p> 
<p>Zset（有序集合）增加 ZMPOP、BZMPOP、ZINTERCARD 等命令；<br> Set（集合）增加 SINTERCARD 命令；<br> List（列表）增加 LMPOP、BLMPOP ，从提供的键名列表中的第一个非空列表键中弹出一个或多个元素。</p> 
<p>9）性能资源利用率、安全等改进</p> 
<p>自身底层部分优化改动，Redis 核心在许多方面进行了重构和改进。</p> 
<p>主动碎片整理 V2：增强版主动碎片整理，配合 Jemalloc 版本更新，更快更智能，延时更低。</p> 
<p>HyperLogLog 改进：在 Redis5.0 中，HyperLogLog 算法得到改进，优化了计数统计时的内存使用效率，7 更加优秀。</p> 
<p>更好的内存统计报告。</p> 
<h2><a id="rainbow_Redis__236"></a>🌈 Redis 安装配置</h2> 
<h3><a id="01_238"></a>01、环境准备</h3> 
<p>🅰️ 1、环境准备</p> 
<p>如何查看自己的 Linux 是 32 位还是 64 位？准备 64 位的</p> 
<pre><code class="prism language-sh">getconf LONG_BIT
<span class="token comment"># 返回是多少就是几位</span>
</code></pre> 
<p>1）Linux 环境安装 Redis 必须先具备 gcc 编译环境</p> 
<ul><li>什么是 gcc</li></ul> 
<p>GCC 是 Linux 下的一个编译程序，是 C 程序的编译工具。</p> 
<p>GCC（GNU Compiler Collection）是 GNU（GNU’s Not Unix）计划提供的编译器家族，它能够支持 C，C++，Objective-C，Fortran，Java 和 Ada 等等程序设计语言前端，同时能够运行在 x86，x86-64，IA-64，PowerPC，SPARC 和 Alpha 等等几乎目前所有的硬件平台上。鉴于这些特征，以及 GCC 编译代码的高效性，使得 GCC 成为绝大多数自由软件开发编译的首选工具。虽然对于程序员们来说，编译器只是一个工具，除了开发和维护人员，很少有人关注编译器的发展，但是 GCC 的影响力是如此之大，它的性能提升甚至有望改善所有的自由软件的运行效率，同时它的内部结构的变化也体现出现代编译器发展的新特征。</p> 
<ul><li>查看是否安装 gcc</li></ul> 
<pre><code class="prism language-sh">gcc <span class="token parameter variable">-v</span>
</code></pre> 
<ul><li>安装 gcc</li></ul> 
<p>安装 Redis 之前需要具备 c++ 库环境</p> 
<pre><code class="prism language-sh">yum <span class="token parameter variable">-y</span> <span class="token function">install</span> gcc- c++
</code></pre> 
<p>🅰️ 2、版本选择</p> 
<p>1）查看自己 Redis 版本的命令</p> 
<pre><code class="prism language-sh">redis-server <span class="token parameter variable">-v</span>
</code></pre> 
<p>安全 Bug 按照官网提示，升级成为 6.0.8 及以上。</p> 
<p>本次使用 Redis 7.0。</p> 
<h3><a id="02Redis__283"></a>02、Redis 安装</h3> 
<p>🅰️ 1、安装操作</p> 
<p>1）下载获得 <code>redis-7.0.0.tar.gz</code> 后将它放入 Linux 目录 <code>/opt</code></p> 
<pre><code class="prism language-sh"><span class="token function">wget</span> https://download.redis.io/releases/redis-7.0.0.tar.gz

<span class="token function">ls</span> <span class="token parameter variable">-l</span> redis-7.0.0.tar.gz
</code></pre> 
<p>2）解压</p> 
<pre><code class="prism language-sh"><span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> redis-7.0.0.tar.gz
</code></pre> 
<p>3）编译安装</p> 
<pre><code class="prism language-sh"><span class="token comment"># 进入目录</span>
<span class="token builtin class-name">cd</span> redis-7.0.0

<span class="token comment"># 在redis-7.0.0目录下执行make命令编译安装</span>
<span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span>

<span class="token punctuation">..</span><span class="token punctuation">..</span>
<span class="token comment"># 安装成功</span>
Hint: It<span class="token string">'s a good idea to run '</span><span class="token function">make</span> test' <span class="token punctuation">;</span><span class="token punctuation">)</span>
</code></pre> 
<p>4）查看默认安装目录：<code>usr/local/bin</code></p> 
<p>Linux 下的 <code>/usr/local</code> 类似 Windows 系统的 <code>C:\Program Files</code></p> 
<p>在安装目录下有以下几个工具：</p> 
<ul><li><code>redis-benchmark</code>：性能测试工具，服务启动后运行该命令，看看性能如何</li><li><code>redis-check-aof</code>：修复有问题的 AOF 文件</li><li><code>redis-check-dump</code>：修复有问题的 dump.rdb 文件</li><li><code>redis-cli</code>：Redis 客户端连接工具</li><li><code>redis-sentinel</code>：Redis 集群使用</li><li><code>redis-server</code>：Redis 服务器启动命令</li></ul> 
<p>🅰️ 2、运行操作</p> 
<p>1）配置文件</p> 
<p>将默认的配置文件 <code>redis.conf</code> 拷贝到自己定义好的一个路径下，比如 <code>/myredis</code></p> 
<pre><code class="prism language-sh"><span class="token builtin class-name">cd</span> redis-7.0.0

<span class="token function">mkdir</span> /myredis

<span class="token function">cp</span> redis.conf /myredis/redis7.conf
</code></pre> 
<p>2）修改 /myredis 目录下 redis7.conf 配置文件做初始化设置</p> 
<blockquote> 
 <p>redis.conf 配置文件，改完后确保生效，记得重启</p> 
</blockquote> 
<p>基础配置：</p> 
<ul><li>后台启动</li></ul> 
<p>默认 <code>daemonize no</code>，修改为 <code>daemonize yes</code> 。</p> 
<ul><li>关闭保护模式，保证应用服务可连接</li></ul> 
<p>默认 <code>protected-mode yes</code>，修改为 <code>protected-mode no</code> 。</p> 
<ul><li>配置连接 IP</li></ul> 
<p>默认 <code>bind 127.0.0.1</code> 改为 直接注释掉（默认 bind 127.0.0.1 只能本机访问）或改成本机 IP 地址，否则影响远程 IP 连接。</p> 
<ul><li>配置密码</li></ul> 
<p>添加 Redis 连接密码，改为 <code>requirepass 123456</code>（密码）</p> 
<p>3）启动服务</p> 
<p>在 /usr/local/bin 目录下运行 <code>redis-server</code>，启用 /myredis 目录下的 redis.conf 配置文件。</p> 
<pre><code class="prism language-sh">redis-server /myredis/redis7.conf

<span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> redis <span class="token operator">|</span> <span class="token function">grep</span> <span class="token parameter variable">-v</span> <span class="token function">grep</span>
</code></pre> 
<p>4）连接服务</p> 
<pre><code>redis-cli -a 123456 -p 6379
</code></pre> 
<p>查看服务端和客服端运行：</p> 
<pre><code class="prism language-sh"><span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> redis
</code></pre> 
<p>5）关闭</p> 
<p>单实例关闭：</p> 
<pre><code class="prism language-sh">redis-cli <span class="token parameter variable">-a</span> <span class="token number">123456</span> <span class="token function">shutdown</span>
</code></pre> 
<p>多实例关闭，指定端口关闭：</p> 
<pre><code class="prism language-sh">redis-cli <span class="token parameter variable">-p</span> <span class="token number">6379</span> <span class="token function">shutdown</span>
</code></pre> 
<h3><a id="03Redis__400"></a>03、Redis 卸载</h3> 
<p>1）停止 redis-server 服务</p> 
<pre><code class="prism language-sh">redis-cli <span class="token parameter variable">-p</span> <span class="token number">6379</span> <span class="token function">shutdown</span>

<span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> redis
</code></pre> 
<p>2）删除 /usr/local/lib 目录下与 redis 相关的文件</p> 
<pre><code class="prism language-sh"><span class="token comment"># 查看</span>
<span class="token function">ls</span> <span class="token parameter variable">-l</span> /usr/local/bin/redis-*
<span class="token comment"># 删除</span>
<span class="token function">rm</span> <span class="token parameter variable">-rf</span> /usr/local/bin/redis-*

<span class="token function">ls</span> <span class="token parameter variable">-l</span> /usr/local/bin/redis-*
</code></pre> 
<h2><a id="rainbow_Redis__421"></a>🌈 Redis 数据类型与命令</h2> 
<h3><a id="01Redis__423"></a>01、Redis 支持的数据类型概述</h3> 
<p>官网：https://redis.io/docs/data-types</p> 
<p><code>Strings</code>、<code>Lists</code>、<code>Sets</code>、<code>Hashes</code>、<code>Sorted sets</code>、<code>Streams</code>、<code>Geospatial</code>、<code>Bitmaps</code>、<code>Bitfields</code>、<code>HyperLogLog</code></p> 
<p><img src="https://images2.imgbox.com/2f/f9/U56iTWyN_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>这里说的数据类型是 value 的数据类型，key 的类型都是字符串</p> 
</blockquote> 
<p>🅰️ 1、字符串 String</p> 
<p>String 是 Redis 最基本的类型，一个 key 对应一个 value。</p> 
<p>String 类型是<code>二进制安全的</code>，意思是 Redis 的 String 可以包含任何数据，比如图片或者序列化的对象 。</p> 
<p>String 类型是 Redis 最基本的数据类型，一个 Redis 中字符串 value 最大可以是 <code>512M</code>。</p> 
<p>🅰️ 2、列表 List</p> 
<p>Redis 列表是简单的字符串列表，按照插入顺序排序。可以添加一个元素到列表的 <code>头部</code>（左边）或 <code>尾部</code>（右边）。</p> 
<p>它的底层实际是个 <code>双端链表</code>，最多可以包含 <code>2^32 - 1</code> 个元素 （4294967295 每个列表超过 40 亿个元素）。</p> 
<p>🅰️ 3、哈希表 Hash</p> 
<p>Redis Hash 是一个 String 类型的 field（字段）和 value（值）的映射表，Hash 特别适合用于存储对象。</p> 
<p>Redis 中每个 Hash 可以存储 <code>2^32 - 1</code> 键值对。</p> 
<p>🅰️ 4、集合 Set</p> 
<p>Redis 的 Set 是 String 类型的 <code>无序集合</code>。集合成员是唯一的，这就意味着集合中不能出现重复的数据，集合对象的编码可以是 intset 或者 hashtable。</p> 
<p>Redis 中 Set 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p> 
<p>集合中最大的成员数为 <code>2^32 - 1</code> （4294967295，每个集合可存储40多亿个成员）。</p> 
<p>🅰️ 5、有序集合 ZSet</p> 
<p>ZSet（sorted set：有序集合）</p> 
<p>Redis ZSet 和 Set 一样也是 String 类型元素的集合，且不允许重复的成员。<code>不同的是每个元素都会关联一个 double 类型的分数</code>，Redis 正是通过分数来为集合中的成员进行从小到大的排序。</p> 
<p>ZSet 的成员是唯一的，但分数（score）却可以重复。</p> 
<p>ZSet 集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。 集合中最大的成员数为 <code>2^32 - 1</code>。</p> 
<p>🅰️ 6、地理空间 GEO</p> 
<p>Redis GEO 主要用于存储 <code>地理位置</code> 信息，并对存储的信息进行操作，包括：</p> 
<ul><li>添加地理位置的坐标；</li><li>获取地理位置的坐标；</li><li>计算两个位置之间的距离；</li><li>根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</li></ul> 
<p>🅰️ 7、基数统计 HyperLogLog</p> 
<p>HyperLogLog 是用来做 <code>基数统计</code> 的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定且是很小的。</p> 
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p> 
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素数据。</p> 
<p>🅰️ 8、位图 Bitmap</p> 
<p>Bit arrays（or simply bitmaps，可以称之为 <code>位图</code>）</p> 
<p><img src="https://images2.imgbox.com/3d/bb/c2XQLrq4_o.png" alt="在这里插入图片描述"></p> 
<p>上图由许许多多的小格子组成，每一个格子里面只能放 1 或者 0，用它来判断 Y/N 状态。说的专业点，每一个小格子就是一个个 bit。</p> 
<p>由 0 和 1 状态表现的二进制位的 bit 数组。</p> 
<p>🅰️ 9、位域 Bitfield</p> 
<p>通过 Bitfield 命令可以一次性操作多个 <code>比特位域</code>（指的是连续的多个比特位），它会执行一系列操作并返回一个响应数组，这个数组中的元素对应参数列表中的相应操作的执行结果。</p> 
<p>即通过 Bitfield 命令可以一次性对多个比特位域进行操作。</p> 
<p>🅰️ 10、流 Stream</p> 
<p>Redis Stream 是 Redis 5.0 版本新增加的数据结构。</p> 
<p>Redis Stream 主要用于消息队列（MQ，Message Queue）。Redis 本身是有一个 Redis 发布订阅（pub/sub）来实现消息队列的功能，但它有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</p> 
<p>简单来说发布订阅（pub/sub）可以分发消息，但无法记录历史消息。</p> 
<p>而 Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p> 
<h3><a id="02Redis_key__516"></a>02、Redis key 的操作命令</h3> 
<p>🅰️ ​1、命令查询</p> 
<p>官网：https://redis.io/commands</p> 
<p>中文参考：http://www.redis.cn/commands.html、http://doc.redisfans.com</p> 
<p>🅰️ 2、与 Redis 键相关的基本命令</p> 
<ul><li><code>KEYS *</code> ：查看当前库所有的 key，会阻塞。</li><li><code>KEYS pattern</code> ：查找所有符合给定模式（pattern）的 key 。</li><li><code>DEL key</code> ：用于在 key 存在时删除 key。</li><li>⭕️ <code>unlink key</code> ：非阻塞删除，仅仅将 key 从 keyspace 元数据中删除，真正的删除会在后续异步中操作。</li><li><code>DUMP key</code> ：序列化给定 key ，并返回被序列化的值。</li><li><code>TYPE key</code> ：返回 key 所储存的值的数据类型。</li><li><code>EXISTS key</code> ：检查给定 key 是否存在。</li><li><code>EXPIRE key seconds</code> ：为给定 key 设置过期时间，以秒计。</li><li><code>EXPIREAT key timestamp</code> ：EXPIREAT 的作用和 EXPIRE 类似，都用于为 key 设置过期时间。 不同在于 EXPIREAT 命令接受的时间参数是 UNIX 时间戳。</li><li><code>PEXPIRE key milliseconds</code> ：设置 key 的过期时间以毫秒计。</li><li><code>PEXPIREAT key milliseconds-timestamp</code> ：设置 key 过期时间的时间戳（unix timestamp）以毫秒计。</li><li><code>MOVE key dbindex[0-15]</code> ：将当前数据库的 key 移动到给定的数据库 db 当中。</li><li><code>SELECT dbindex</code> ：切换数据库【0-15】，默认为 0 号库。</li><li><code>PERSIST key</code> ：移除 key 的过期时间，key 将持久保持不过期。</li><li><code>PTTL key</code> ：以毫秒为单位返回 key 的剩余的过期时间。</li><li><code>TTL key</code> ：以秒为单位，返回 key 的剩余生存时间（TTL，time to live）-1 表示永不过期，-2 表示已过期。</li><li><code>RANDOMKEY</code> ：从当前数据库中随机返回一个 key 。</li><li><code>RENAME key newkey</code> ：修改 key 的名称。</li><li><code>RENAMENX key newkey</code> ：仅当 newkey 不存在时，将 key 改名为 newkey 。</li><li><code>dbsize</code> ：查看当前数据库 key 的数量。</li><li>❌ <code>flushdb</code> ：清空当前库。</li><li>❌ <code>flushall</code> ：清空全部库。</li></ul> 
<blockquote> 
 <p>命令不区分大小写，而 key 是区分大小写的。</p> 
 <p>帮助命令：<code>help @类型</code> ：<code>help @string</code>、<code>help @list</code>、<code>help @hyperloglog</code>、…</p> 
</blockquote> 
<h3><a id="03Redis_String_553"></a>03、Redis 字符串（String）</h3> 
<p>文档介绍：https://redis.io/docs/data-types/strings</p> 
<p>相关命令：https://redis.io/commands/?group=string</p> 
<p>🅰️ 1、最常用</p> 
<pre><code class="prism language-sh">SET key value <span class="token punctuation">[</span>NX <span class="token operator">|</span> XX<span class="token punctuation">]</span> <span class="token punctuation">[</span>GET<span class="token punctuation">]</span> <span class="token punctuation">[</span>EX seconds <span class="token operator">|</span> PX milliseconds <span class="token operator">|</span> EXAT unix-time-seconds <span class="token operator">|</span> PXAT unix-time-milliseconds <span class="token operator">|</span> KEEPTTL<span class="token punctuation">]</span>
</code></pre> 
<p>1）SET 命令有 EX、PX、NX、XX 以及 KEEPTTL 五个可选参数，其中 KEEPTTL 为 6.0 版本添加的可选参数，其它为 2.6.12 版本添加的可选参数。</p> 
<ul><li><code>EX seconds</code>：以秒为单位设置过期时间；</li><li><code>PX milliseconds</code>：以毫秒为单位设置过期时间；</li><li><code>EXAT timestamp</code>：设置以秒为单位的 UNIX 时间戳所对应的时间为过期时间；</li><li><code>PXAT milliseconds-timestamp</code>：设置以毫秒为单位的 UNIX 时间戳所对应的时间为过期时间；</li><li><code>NX</code>：键不存在的时候设置键值；</li><li><code>XX</code>：键存在的时候设置键值；</li><li><code>KEEPTTL</code>：保留设置前指定键的生存时间；</li><li><code>GET</code>：返回指定键原本的值，若键不存在时返回 nil 。</li></ul> 
<p>SET 命令使用 EX、PX、NX 参数，其效果等同于 SETEX、PSETEX、SETNX 命令。根据官方文档的描述，未来版本中SETEX、PSETEX、SETNX 命令可能会被淘汰。</p> 
<p>EXAT、PXAT 以及 GET 为 Redis 6.2 新增的可选参数。</p> 
<p>2）返回值：</p> 
<ul><li> <p>设置成功则返回 OK；返回 nil 为未执行 SET 命令，如不满足 NX、XX 条件等情况。</p> </li><li> <p>若使用 GET 参数，则返回该键原来的值，该键不存在时返回 nil 。</p> </li></ul> 
<p>🅰️ ​2、同时设置/获取多个键值</p> 
<p>语法：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 同时设置一个或多个 key-value 对; 返回值 OK </span>
MSET key value <span class="token punctuation">[</span>key value <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 获取所有(一个或多个)给定 key 的值; 返回 list of values</span>
MGET key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 同时设置一个或多个 key-value 对，当且仅当所有给定 key 都不存在; 返回值 1 or 0</span>
MSETNX key value <span class="token punctuation">[</span>key value <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>案例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> MSET key1 <span class="token string">"Hello"</span> key2 <span class="token string">"World"</span>
<span class="token string">"OK"</span>
redis<span class="token operator">&gt;</span> GET key1
<span class="token string">"Hello"</span>
redis<span class="token operator">&gt;</span> GET key2
<span class="token string">"World"</span>
</code></pre> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> MGET key1 key2 nonexisting
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"Hello"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"World"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> MSETNX key1 <span class="token string">"Hello"</span> key2 <span class="token string">"World"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> MSETNX key2 <span class="token string">"new"</span> key3 <span class="token string">"msetnx"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> MGET key1 key2 key3
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"Hello"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"World"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
</code></pre> 
<p>🅰️ 3、获取指定区间范围内的值</p> 
<p>语法：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 获取指定区间范围内的值，类似 between...and 的关系，从零到负一表示全部</span>
GETRANGE key start end

<span class="token comment"># 设置指定区间范围内的值</span>
SETRANGE key offset value
</code></pre> 
<p>案例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SET mykey <span class="token string">"This is a string"</span>
<span class="token string">"OK"</span>
redis<span class="token operator">&gt;</span> GETRANGE mykey <span class="token number">0</span> <span class="token number">3</span>
<span class="token string">"This"</span>
redis<span class="token operator">&gt;</span> GETRANGE mykey <span class="token parameter variable">-3</span> <span class="token parameter variable">-1</span>
<span class="token string">"ing"</span>
redis<span class="token operator">&gt;</span> GETRANGE mykey <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token string">"This is a string"</span>
</code></pre> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SET key1 <span class="token string">"Hello World"</span>
<span class="token string">"OK"</span>
redis<span class="token operator">&gt;</span> SETRANGE key1 <span class="token number">6</span> <span class="token string">"Redis"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">11</span>
redis<span class="token operator">&gt;</span> GET key1
<span class="token string">"Hello Redis"</span>
</code></pre> 
<p>🅰️ 4、数值增减</p> 
<p>语法：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 递增 1</span>
INCR key

<span class="token comment"># 递增指定步数</span>
INCRBY key increment
</code></pre> 
<p>举例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SET key1 <span class="token string">"10"</span>
<span class="token string">"OK"</span>
redis<span class="token operator">&gt;</span> INCR key1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">11</span>
redis<span class="token operator">&gt;</span> GET key1
<span class="token string">"11"</span>
redis<span class="token operator">&gt;</span> INCRBY key1 <span class="token number">5</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">16</span>
redis<span class="token operator">&gt;</span> GET key1 
<span class="token string">"16"</span>
</code></pre> 
<p>语法：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 递减 1</span>
DECR key

<span class="token comment"># 递减指定步数</span>
DECRBY key decrement
</code></pre> 
<p>举例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SET mykey <span class="token string">"10"</span>
<span class="token string">"OK"</span>
redis<span class="token operator">&gt;</span> DECR mykey
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">9</span>
redis<span class="token operator">&gt;</span> DECRBY mykey <span class="token number">3</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">6</span>
</code></pre> 
<p>一定要是数字才能进行加减：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SET mykey <span class="token string">"1234293482390480948029348230948"</span>
<span class="token string">"OK"</span>
redis<span class="token operator">&gt;</span> DECR mykey
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> value is not an integer or out of range
</code></pre> 
<p>🅰️ ​5、获取字符串长度和内容追加</p> 
<p>语法：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 获取字符串长度</span>
STRLEN key
<span class="token comment"># 内容追加</span>
APPEND key value
</code></pre> 
<p>如果键已经存在并且是字符串，则此命令将在字符串末尾附加值。若键不存在，则创建该键并将其设置为空字符串，所以在这种特殊情况下，APPEND 将类似于 SET。</p> 
<p>举例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SET mykey <span class="token string">"Hello world"</span>
<span class="token string">"OK"</span>
redis<span class="token operator">&gt;</span> STRLEN mykey
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">11</span>
redis<span class="token operator">&gt;</span> STRLEN nonexisting
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> EXISTS mykey
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> APPEND mykey <span class="token string">"Hello"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
redis<span class="token operator">&gt;</span> APPEND mykey <span class="token string">" World"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">11</span>
redis<span class="token operator">&gt;</span> GET mykey
<span class="token string">"Hello World"</span>
</code></pre> 
<p>🅰️ 6、GETSET</p> 
<pre><code class="prism language-sh">GETSET key value
</code></pre> 
<p>原子地将 key 设置为 value，并返回存储在 key 中的旧值。成功 SET 操作后，将放弃与密钥相关的任何先前生存时间。</p> 
<p>举例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SET mykey <span class="token string">"Hello"</span>
<span class="token string">"OK"</span>
redis<span class="token operator">&gt;</span> GETSET mykey <span class="token string">"World"</span>
<span class="token string">"Hello"</span>
redis<span class="token operator">&gt;</span> GET mykey
<span class="token string">"World"</span>
</code></pre> 
<p>🅰️ 7、应用场景</p> 
<p>比如抖音无限点赞某个视频或者商品，点一下加一次：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> INCR items:1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> INCR items:1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
redis<span class="token operator">&gt;</span> INCR items:1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
</code></pre> 
<p>分布式锁：</p> 
<pre><code class="prism language-sh">SET key value <span class="token punctuation">[</span>NX <span class="token operator">|</span> XX<span class="token punctuation">]</span> <span class="token punctuation">[</span>EX seconds <span class="token operator">|</span> PX milliseconds<span class="token punctuation">]</span>
</code></pre> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SET lock:item:1 <span class="token number">1</span> EX <span class="token number">10</span> NX
<span class="token string">"OK"</span>
redis<span class="token operator">&gt;</span> SET lock:item:1 <span class="token number">1</span> EX <span class="token number">10</span> NX
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
</code></pre> 
<h3><a id="04Redis_List_801"></a>04、Redis 列表（List）</h3> 
<p>文档介绍：https://redis.io/docs/data-types/lists</p> 
<p>相关命令：https://redis.io/commands/?group=list</p> 
<p>Redis 列表是字符串值的双端链表。容量是 2^32 - 1（4,294,967,295）个元素，大概 40 多亿。</p> 
<p>Redis 列表通常用于：</p> 
<ul><li>实现堆栈和队列；</li><li>为后台工作系统构建队列管理。</li></ul> 
<p>在 left、right 都可以插入添加，如果键不存在，创建新的链表；如果键已存在，新增内容；如果值全移除，对应的键也就消失了。</p> 
<p>底层实际是个 <code>双向链表</code>，对两端的操作性能很高，通过索引下标的操作中间的节点性能会较差。</p> 
<p>🅰️ 1、最常用 <code>lpush</code>、 <code>rpush</code>、 <code>lrange</code></p> 
<pre><code class="prism language-sh"><span class="token comment"># 在列表的开头插入所有指定值。如果键不存在，则在执行操作之前将其创建为空列表</span>
LPUSH key element <span class="token punctuation">[</span>element <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

RPUSH key element <span class="token punctuation">[</span>element <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

LRANGE key start stop
</code></pre> 
<p>LRANGE 返回存储在键处的列表的指定元素。偏移量 start 和 stop 是从零开始的索引，0 是列表的第一个元素（列表的开头），1 是下一个元素，依此类推。</p> 
<p>这些偏移也可以是负数，表示从列表末尾开始的偏移。例如，-1 是列表的最后一个元素，-2 是倒数第二个元素，依此类推。</p> 
<p>举例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> LPUSH list1 <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
redis<span class="token operator">&gt;</span> LRANGE list1 <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"3"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"2"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"1"</span>
redis<span class="token operator">&gt;</span> RPUSH list2 <span class="token number">10</span> <span class="token number">11</span> <span class="token number">12</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
redis<span class="token operator">&gt;</span> LRANGE list2 <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"10"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"11"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"12"</span>
</code></pre> 
<p>🅰️ 2、最常用 <code>lpop</code>、 <code>rpop</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">LPOP key <span class="token punctuation">[</span>count<span class="token punctuation">]</span>
</code></pre> 
<p>删除并返回存储在列表的第一个元素。默认情况下，该命令从列表的开头弹出一个元素。当提供可选的 count 参数时，根据列表的长度，取出包含最多 count 个元素。</p> 
<pre><code class="prism language-sh">RPOP key <span class="token punctuation">[</span>count<span class="token punctuation">]</span>
</code></pre> 
<p>删除并返回存储在列表的最后一个元素。默认情况下，该命令从列表末尾弹出一个元素。当提供可选的 count 参数时，根据列表的长度，取出包含最多 count 个元素。</p> 
<p>举例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> RPUSH list1 <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span> <span class="token number">6</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">6</span>
redis<span class="token operator">&gt;</span> LPOP list1
<span class="token string">"1"</span>
redis<span class="token operator">&gt;</span> RPOP list1
<span class="token string">"6"</span>
redis<span class="token operator">&gt;</span> RPOP list1 <span class="token number">2</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"5"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"4"</span>
redis<span class="token operator">&gt;</span> LRANGE list1 <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"2"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"3"</span>
</code></pre> 
<p>🅰️ 3、命令 <code>LINDEX</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">LINDEX key index
</code></pre> 
<p>返回列表中索引下标的元素。索引从 0 开始，因此 0 表示第一个元素，1 表示第二个元素，依此类推。可以使用负索引来指定从列表尾部开始的元素。-1 表示最后一个元素，-2 表示倒数第二个元素，依此类推。</p> 
<p>如果键处的值不是列表，则返回错误。</p> 
<p>举例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> LPUSH list1 <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>
redis<span class="token operator">&gt;</span> LINDEX list1 <span class="token number">0</span>
<span class="token string">"4"</span>
redis<span class="token operator">&gt;</span> LINDEX list1 <span class="token parameter variable">-1</span>
<span class="token string">"1"</span>
</code></pre> 
<p>🅰️ 4、命令 <code>LLEN</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">LLEN key
</code></pre> 
<p>返回键列表的长度。若键不存在，则将其解释为空列表，并返回 0。当键中存储的值不是列表时，将返回错误。</p> 
<p>🅰️ 5、命令 <code>LREM</code></p> 
<p>语法：</p> 
<pre><code>LREM key count element
</code></pre> 
<p>从 left 往 right 删除 count 个值等于 element 的元素首次计数，返回的值为实际删除的数量。</p> 
<ul><li>count &gt; 0 ：移除等于元素从头部移动到尾部的元素。</li><li>count &lt; 0 ：删除等于元素从尾部移动到头部的元素。</li><li>count = 0 ：删除等于元素的所有元素。</li></ul> 
<p>注意，不存在的键被视为空列表，所以当键不存在时，命令将始终返回 0。</p> 
<p>举例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> LPUSH list1 <span class="token number">1</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">3</span> <span class="token number">3</span> <span class="token number">4</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">8</span>
redis<span class="token operator">&gt;</span> LREM list1 <span class="token number">2</span> <span class="token number">3</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
redis<span class="token operator">&gt;</span> LRANGE list1 <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"4"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"3"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"2"</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"2"</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">"1"</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">"1"</span>
redis<span class="token operator">&gt;</span> LREM list1 <span class="token number">0</span> <span class="token number">2</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
redis<span class="token operator">&gt;</span> LRANGE list1 <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"4"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"3"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"1"</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"1"</span>
</code></pre> 
<p>🅰️ 6、命令 <code>LTRIM</code></p> 
<pre><code class="prism language-sh">LTRIM key start stop
</code></pre> 
<p>截取指定范围的值后再赋值给 key。</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> RPUSH list1 <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
redis<span class="token operator">&gt;</span> LTRIM list1 <span class="token number">1</span> <span class="token number">3</span>
<span class="token string">"OK"</span>
redis<span class="token operator">&gt;</span> LRANGE list1 <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"2"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"3"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"4"</span>
</code></pre> 
<p>🅰️ 7、命令 <code>RPOPLPUSH</code></p> 
<pre><code class="prism language-sh">RPOPLPUSH <span class="token builtin class-name">source</span> destination
</code></pre> 
<p>原子的返回并删除存储在源位置的列表的最后一个元素（尾部），并将该元素推送到存储在目标位置的列表中的第一个元素（头部）。</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> RPUSH list1 <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>
redis<span class="token operator">&gt;</span> RPOPLPUSH list1 list2
<span class="token string">"4"</span>
redis<span class="token operator">&gt;</span> LRANGE list1 <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"2"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"3"</span>
redis<span class="token operator">&gt;</span> LRANGE list2 <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"4"</span>
</code></pre> 
<p>🅰️ 8、命令 <code>LSET</code></p> 
<pre><code class="prism language-sh">LSET key index element
</code></pre> 
<p>将索引处的列表元素设置为元素。超出范围的索引返回错误。</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> LPUSH list1 <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
redis<span class="token operator">&gt;</span> LSET list1 <span class="token number">1</span> <span class="token number">0</span>
<span class="token string">"OK"</span>
redis<span class="token operator">&gt;</span> LRANGE list1 <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"3"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"0"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"1"</span>
</code></pre> 
<p>🅰️ 9、命令 <code>LINSERT</code></p> 
<pre><code class="prism language-sh">LINSERT key <span class="token operator">&lt;</span>BEFORE <span class="token operator">|</span> AFTER<span class="token operator">&gt;</span> pivot element
</code></pre> 
<p>在列表某个已有值的前后再添加具体值。当键不存在时，它被视为空列表，不执行任何操作。当键存在但不是列表值时，将返回错误。</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> LPUSH list1 r e d i s r
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">6</span>
redis<span class="token operator">&gt;</span> LINSERT list1 BEFORE r a
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">7</span>
redis<span class="token operator">&gt;</span> LRANGE list1 <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"a"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"r"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"s"</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"i"</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">"d"</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">"e"</span>
<span class="token number">7</span><span class="token punctuation">)</span> <span class="token string">"r"</span>
</code></pre> 
<p>🅰️ 10、应用场景</p> 
<p>例如微信公众号订阅的消息：</p> 
<ul><li>关注的公众号发布了新文章（文章编号 10，11），就会安装进我的 List</li></ul> 
<pre><code class="prism language-sh">LPUSH subscribe:wuid <span class="token number">10</span> <span class="token number">11</span>
</code></pre> 
<ul><li>查看自己订阅的全部文章，类似分页，下面 0~10 就是一次显示 10 条</li></ul> 
<pre><code class="prism language-sh">LRANGE subscribe:wuid <span class="token number">0</span> <span class="token number">9</span>
</code></pre> 
<h3><a id="05Redis_Hash_1053"></a>05、Redis 哈希（Hash）</h3> 
<p>文档介绍：https://redis.io/docs/data-types/hashes</p> 
<p>相关命令：https://redis.io/commands/?group=hash</p> 
<p>每个 Hash 最多可以存储 4294967295（2^32-1）个字段值对。</p> 
<p>大多数 Redis Hash 命令都是 O(1)。一些命令（如 HKEYS、HVALS 和 HGETALL）是 O(n)，其中 n 是字段值对的数量。</p> 
<p>🅰️ 1、常用的 <code>hset</code>、 <code>hget</code>、 <code>hmset</code>、 <code>hmget</code>、 <code>hgetall</code>、 <code>hdel</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 存储</span>
HSET key field value <span class="token punctuation">[</span>field value <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 获取单个</span>
HGET key field

<span class="token comment"># 已标记过期</span>
HMSET key field value <span class="token punctuation">[</span>field value <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 获取多个</span>
HMGET key field <span class="token punctuation">[</span>field <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 获取所有</span>
HGETALL key

<span class="token comment"># 删除</span>
HDEL key field <span class="token punctuation">[</span>field <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>举例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> HSET hash1 f1 v1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> HGET hash1 f1
<span class="token string">"v1"</span>
redis<span class="token operator">&gt;</span> HMSET hash1 f2 v2 f3 v3
<span class="token string">"OK"</span>
redis<span class="token operator">&gt;</span> HMGET hash1 f2 f3
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"v2"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"v3"</span>
redis<span class="token operator">&gt;</span> HGETALL hash1
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"f1"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"v1"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"f2"</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"v2"</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">"f3"</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">"v3"</span>
redis<span class="token operator">&gt;</span> HDEL hash1 f1 f2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
redis<span class="token operator">&gt;</span> HGETALL hash1
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"f3"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"v3"</span>
</code></pre> 
<p>🅰️ 2、命令 <code>HLEN</code></p> 
<pre><code class="prism language-sh"><span class="token comment"># 返回存储键的哈希中包含的字段数</span>
HLEN key
</code></pre> 
<p>🅰️ 3、命令 <code>HEXISTS</code></p> 
<pre><code class="prism language-sh"><span class="token comment"># 判断hash是否存在field键</span>
HEXISTS key field
</code></pre> 
<p>如果哈希包含字段，则返回 1 。如果哈希不包含字段或键不存在，则返回 0 。</p> 
<p>🅰️ 4、常用的 <code>HKEYS</code>、 <code>HVALS</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh"><span class="token comment"># 返回 hash 所有的 field </span>
HKEYS key

<span class="token comment"># 返回 hash 所有的 values</span>
HVALS key
</code></pre> 
<p>举栗：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> HSET myhash field1 <span class="token string">"Hello"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> HSET myhash field2 <span class="token string">"World"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> HVALS myhash
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"Hello"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"World"</span>
redis<span class="token operator">&gt;</span> HKEYS myhash
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"field1"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"field2"</span>
</code></pre> 
<p>🅰️ 5、命令 <code>HINCRBY</code>、 <code>HINCRBYFLOAT</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">HINCRBY key field increment

HINCRBYFLOAT key field increment
</code></pre> 
<p>将存储在 key 中的哈希的字段的数字递增。如果密钥不存在，则创建一个保存哈希的新密钥。如果字段不存在，则在执行操作之前将值设置为 0 。</p> 
<p>举栗：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> HSET myhash field <span class="token number">5</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> HINCRBY myhash field <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">6</span>
redis<span class="token operator">&gt;</span> HINCRBY myhash field <span class="token parameter variable">-1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
</code></pre> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> HSET mykey field <span class="token number">10.50</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> HINCRBYFLOAT mykey field <span class="token number">0.1</span>
<span class="token string">"10.6"</span>
redis<span class="token operator">&gt;</span> HINCRBYFLOAT mykey field <span class="token parameter variable">-5</span>
<span class="token string">"5.6"</span>
</code></pre> 
<p>🅰️ 6、命令 <code>HSETNX</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">HSETNX key field value
</code></pre> 
<p>仅当 field 字段还不存在时，才将存储在 key 的哈希中的字段设置为值。如果 key 不存在，则创建一个保存哈希的新 key。如果字段已存在，则此操作无效。</p> 
<p>举栗：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> HSETNX myhash field <span class="token string">"Hello"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> HSETNX myhash field <span class="token string">"World"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> HGET myhash field
<span class="token string">"Hello"</span>
</code></pre> 
<p>🅰️ 7、应用场景</p> 
<p>小型商城购物车可用方案：</p> 
<ul><li>新增商品：<code>hset shopcar:uid1024 334488 1</code></li><li>新增商品：<code>hset shopcar:uid1024 334477 1</code></li><li>增加商品数量：<code>hincrby shopcar:uid1024 334477 1</code></li><li>商品总数：<code>hlen shopcar:uid1024</code></li><li>全部选择：<code>hgetall shopcar:uid1024</code></li></ul> 
<h3><a id="06Redis_Set_1219"></a>06、Redis 集合（Set）</h3> 
<p>文档介绍：https://redis.io/docs/data-types/sets</p> 
<p>相关命令：https://redis.io/commands/?group=set</p> 
<p>最多可以存储 4294967295（2^32-1）个元素。</p> 
<p>Redis 集合是唯一字符串（成员）的无序集合。</p> 
<ul><li>跟踪唯一项目（例如，跟踪访问给定博客文章的所有唯一 IP 地址）。</li><li>表示关系（例如，具有给定角色的所有用户的集合）。</li><li>执行常见的集合操作，如交集、并集和差集。</li></ul> 
<p>🅰️ 1、添加元素 <code>SADD</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">SADD key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>将指定的成员添加到集合。已存在此集合成员的将被忽略。如果键不存在，则在添加指定成员之前创建一个新集。</p> 
<p>当键中存储的值不是集合时，将返回错误。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SADD set1 <span class="token string">"HELLO"</span> <span class="token string">"WORLD"</span> <span class="token string">"REDIS"</span> <span class="token string">"HELLO"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
redis<span class="token operator">&gt;</span> SMEMBERS set1
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"REDIS"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"WORLD"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"HELLO"</span>
</code></pre> 
<p>🅰️ 2、遍历集合 <code>SMEMBERS</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">SMEMBERS key
</code></pre> 
<p>返回键的集合值的所有元素。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SADD set1 <span class="token string">"HELLO"</span> <span class="token string">"WORLD"</span> <span class="token string">"REDIS"</span> <span class="token string">"HELLO"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
redis<span class="token operator">&gt;</span> SMEMBERS set1
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"REDIS"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"WORLD"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"HELLO"</span>
</code></pre> 
<p>🅰️ 3、判断元素是否在集合 <code>SISMEMBER</code>/<code>SMISMEMBER</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">SISMEMBER key member

SMISMEMBER key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>成员是集合的元素返回 1，否则返回 0。</p> 
<p>判断每个成员是否是集合的元素。对于每个成员，如果值是集合的元素，返回 1；如果不是集合的元素或键不存在，则返回 0。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SADD myset <span class="token string">"one"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> SISMEMBER myset <span class="token string">"one"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> SISMEMBER myset <span class="token string">"two"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> SMISMEMBER myset <span class="token string">"one"</span> <span class="token string">"two"</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre> 
<p>🅰️ 4、删除元素 <code>SREM</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">SREM key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>从集合中删除指定的元素。将忽略不是此集合元素的指定成员。如果键不存在，则将其视为空集，此命令返回 0。</p> 
<p>当键存储的值不是集合时，将返回错误。</p> 
<p>返回值为整数，从集合中删除的成员数量，不包括不存在的成员。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SADD myset <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>
redis<span class="token operator">&gt;</span> SREM myset <span class="token number">1</span> <span class="token number">3</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
redis<span class="token operator">&gt;</span> SMEMBERS myset
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"2"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"4"</span>
</code></pre> 
<p>🅰️ 5、获取集合的元素个数 <code>SCARD</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">SCARD key
</code></pre> 
<p>返回集合的集合基数（元素数量）。如果键不存在则返回 0。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SADD set1 <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
redis<span class="token operator">&gt;</span> SCARD set1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
</code></pre> 
<p>🅰️ 6、随机展现集合的元素 <code>SRANDMEMBER</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">SRANDMEMBER key <span class="token punctuation">[</span>count<span class="token punctuation">]</span>
</code></pre> 
<p>当只使用 key 参数时，从 key 集合中返回一个随机元素。<code>集合内元素不会删除</code>。</p> 
<p>如果使用 count 参数为正数，则返回一个不同元素的数组。数组的长度是 count 或集合的基数（SCARD），以较低者为准。</p> 
<p>如果使用 count 参数为负数，则允许命令多次返回同一元素。返回的元素数是指定计数的绝对值。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SADD myset one two three
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
redis<span class="token operator">&gt;</span> SRANDMEMBER myset
<span class="token string">"two"</span>
redis<span class="token operator">&gt;</span> SRANDMEMBER myset <span class="token number">2</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"two"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"one"</span>
redis<span class="token operator">&gt;</span> SRANDMEMBER myset <span class="token parameter variable">-5</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"one"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"two"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"two"</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"one"</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">"one"</span>
</code></pre> 
<p>🅰️ 7、随机弹出集合的元素 <code>SPOP</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">SPOP key <span class="token punctuation">[</span>count<span class="token punctuation">]</span>
</code></pre> 
<p>从集合中删除并返回一个或多个随机元素。</p> 
<p>默认情况下，该命令从集合中弹出一个元素。当提供可选的 count 参数时，弹出最多 count 个元素或集合的基数个元素。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SADD set1 <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">5</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
redis<span class="token operator">&gt;</span> SPOP set1
<span class="token string">"3"</span>
redis<span class="token operator">&gt;</span> SPOP set1 <span class="token number">3</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"2"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"1"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"5"</span>
redis<span class="token operator">&gt;</span> SMEMBERS set1
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"4"</span>
redis<span class="token operator">&gt;</span> SPOP set1 <span class="token number">3</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"4"</span>
redis<span class="token operator">&gt;</span> SMEMBERS set1
<span class="token punctuation">(</span>empty array<span class="token punctuation">)</span>
</code></pre> 
<p>🅰️ 8、将成员从源集合移动到目标集合 <code>SMOVE</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">SMOVE <span class="token builtin class-name">source</span> destination member
</code></pre> 
<p>将成员从源集合移动到目标集合。此操作是原子操作。</p> 
<p>如果源集合不存在或不包含指定的元素，则不执行任何操作，并返回 0。否则，元素将从源集中删除并添加到目标集中。如果指定的元素已存在于目标集中，则仅从源集中删除该元素。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SADD set1 <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
redis<span class="token operator">&gt;</span> SADD set2 <span class="token number">3</span> <span class="token number">4</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
redis<span class="token operator">&gt;</span> SMOVE set1 set2 <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> SMOVE set1 set2 <span class="token number">3</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> SMEMBERS set1
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"2"</span>
redis<span class="token operator">&gt;</span> SMEMBERS set2
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"3"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"4"</span>
</code></pre> 
<p>🅰️ 9、集合运算</p> 
<p>现存在集合 A（元素 a b c 1 2）、集合 B（元素 1 2 3 a z）。</p> 
<p>1）集合的差集运算 A - B，即属于 A 但不属于 B 的元素构成的集合</p> 
<pre><code class="prism language-sh">SDIFF key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>返回由第一个集合和所有连续集合之间的差异产生的集合的元素。不存在的键被认为是空集。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> SADD KEYA a b c <span class="token number">1</span> <span class="token number">2</span>
<span class="token number">5</span>
<span class="token operator">&gt;</span> SADD KEYB <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> a z
<span class="token number">5</span>
<span class="token operator">&gt;</span> SDIFF KEYA KEYB
b
c
<span class="token operator">&gt;</span> SDIFF KEYB KEYA
<span class="token number">3</span>
z
</code></pre> 
<p>2）集合的并集运算 A ∪ B，属于 A 或者属于 B 的元素合并后的集合</p> 
<pre><code class="prism language-sh">SUNION key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>返回由所有给定集合的并集产生的集合的元素。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> SADD KEYA a b c <span class="token number">1</span> <span class="token number">2</span>
<span class="token number">5</span>
<span class="token operator">&gt;</span> SADD KEYB <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> a z
<span class="token number">5</span>
<span class="token operator">&gt;</span> SUNION KEYA KEYB
a
b
c
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">3</span>
z
</code></pre> 
<p>3）集合的交集运算 A ∩ B，属于 A 同时也属于 B 的共同拥有的元素构成的集合</p> 
<pre><code class="prism language-sh">SINTER key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>返回由所有给定集合的交集产生的集合的元素。</p> 
<p>不存在的键被视为空集。如果其中一个键是空集，则生成的集也是空的（因为与空集相交的集总是导致空集）。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SADD KEYA a b c <span class="token number">1</span> <span class="token number">2</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
redis<span class="token operator">&gt;</span> SADD KEYB <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> a z
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
redis<span class="token operator">&gt;</span> SINTER KEYA KEYB
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"a"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"2"</span>
redis<span class="token operator">&gt;</span> SINTER KEYA KEYB KEYC
<span class="token punctuation">(</span>empty array<span class="token punctuation">)</span>
</code></pre> 
<p>4）<code>SDIFFSTORE</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">SDIFFSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>该命令等于 SDIFF，但不返回结果集，而是存储在 destination 集合。如果 destination 集合已经存在，则会覆盖。</p> 
<p>返回值为结果集中的元素数量。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> SADD k1 A B C
<span class="token number">3</span>
<span class="token operator">&gt;</span> SADD k2 C D E
<span class="token number">3</span>
<span class="token operator">&gt;</span> SDIFFSTORE key k1 k2
<span class="token number">2</span>
<span class="token operator">&gt;</span> SMEMBERS key
A
B
</code></pre> 
<p>5）<code>SUNIONSTORE</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">SUNIONSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>该命令等于 SUNION，但不返回结果集，而是存储在 destination 集合。如果 destination 集合已经存在，则会覆盖。</p> 
<p>返回值为结果集中的元素数量。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> SADD k1 A B C
<span class="token number">3</span>
<span class="token operator">&gt;</span> SADD k2 C D E
<span class="token number">3</span>
<span class="token operator">&gt;</span> SUNIONSTORE key k1 k2
<span class="token number">5</span>
<span class="token operator">&gt;</span> SMEMBERS key
A
B
C
D
E
</code></pre> 
<p>6）<code>SINTERSTORE</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">SINTERSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>该命令等于 SINTER，但不返回结果集，而是存储在 destination 集合。如果 destination 集合已经存在，则会覆盖。</p> 
<p>返回值为结果集中的元素数量。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> SINTERSTORE key k1 k2
<span class="token number">1</span>
<span class="token operator">&gt;</span> SMEMBERS key
C
</code></pre> 
<p>7）Redis 7 新命令 <code>SINTERCARD</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">SINTERCARD numkeys key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token punctuation">[</span>LIMIT limit<span class="token punctuation">]</span>
</code></pre> 
<p>该命令类似于 SINTER，但它只返回结果的基数，而不是返回结果集。返回所有给定集合的交集所产生的集合的基数。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SADD KEYA a b c <span class="token number">1</span> <span class="token number">2</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
redis<span class="token operator">&gt;</span> SADD KEYB <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> a z
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
redis<span class="token operator">&gt;</span> SINTERCARD <span class="token number">2</span> KEYA KEYB 
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
redis<span class="token operator">&gt;</span> SINTERCARD <span class="token number">2</span> KEYA KEYB LIMIT <span class="token number">2</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
</code></pre> 
<p>🅰️ 10、应用场景</p> 
<p>1）微信抽奖小程序</p> 
<ul><li>用户参与抽奖</li></ul> 
<pre><code class="prism language-sh">SADD key uid
</code></pre> 
<ul><li>显示多少人参与抽奖</li></ul> 
<pre><code class="prism language-sh">SCARD key
</code></pre> 
<ul><li>随机抽奖 N 人</li></ul> 
<pre><code class="prism language-sh">SRANDMEMBER key <span class="token number">2</span>  <span class="token comment"># 随机抽奖2个人，元素不删除</span>

SPOP key <span class="token number">3</span>  <span class="token comment"># 随机抽奖3个人，元素会删除</span>
</code></pre> 
<p>2）微信朋友圈点赞查看点赞朋友</p> 
<ul><li>新增点赞</li></ul> 
<pre><code class="prism language-sh">SADD pub:msgid uid
</code></pre> 
<ul><li>取消点赞</li></ul> 
<pre><code class="prism language-sh">SREM pub:msgid uid
</code></pre> 
<ul><li>显示点赞的朋友</li></ul> 
<pre><code class="prism language-sh">SMEMBERS pub:msgid
</code></pre> 
<ul><li>点赞数</li></ul> 
<pre><code class="prism language-sh">SCARD pub:msgid
</code></pre> 
<ul><li>判断是否点赞过</li></ul> 
<pre><code class="prism language-sh">SISMEMBER pub:msgid uid
</code></pre> 
<p>3）可能认识的人</p> 
<ul><li>用户 A 的好友，用户 B 可能认识</li></ul> 
<pre><code class="prism language-sh">SDIFF ua ub
</code></pre> 
<ul><li>用户 B 的好友，用户 A 可能认识</li></ul> 
<pre><code class="prism language-sh">SDIFF ub ua
</code></pre> 
<h3><a id="07Redis_Sorted_sets_1690"></a>07、Redis 有序集合（Sorted sets）</h3> 
<p>文档介绍：https://redis.io/docs/data-types/sorted-sets</p> 
<p>相关命令：https://redis.io/commands/?group=sorted-set</p> 
<p>Redis 有序集合是按关联分数排序的唯一字符串（元素）的集合。当多个字符串具有相同的分数时，这些字符串按字典顺序排列。</p> 
<p>有序集合是通过包含跳表和哈希表的双端数据结构实现的，因此每次添加元素时，Redis 都会执行 O(log(N)) 操作。</p> 
<p>有序集合的一些用例包括：</p> 
<ul><li>排行榜。例如，可以使用排序集轻松维护在线游戏中最高分数的有序列表。</li><li>速率限制器。例如，可以使用排序集构建滑动窗口速率限制器，以防止过多的 API 请求。</li></ul> 
<p>🅰️ 1、添加元素 <code>ZADD</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">ZADD key <span class="token punctuation">[</span>NX <span class="token operator">|</span> XX<span class="token punctuation">]</span> <span class="token punctuation">[</span>GT <span class="token operator">|</span> LT<span class="token punctuation">]</span> <span class="token punctuation">[</span>CH<span class="token punctuation">]</span> <span class="token punctuation">[</span>INCR<span class="token punctuation">]</span> score member <span class="token punctuation">[</span>score member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>将具有指定分数的所有指定成员添加到排序集。可以指定多个分数/成员对。如果指定的成员已经是排序集的成员，则会更新分数并将元素重新插入到正确的位置，以确保正确排序。</p> 
<p>如果 key 不存在，则创建一个以指定成员作为唯一成员的新排序集。如果键存在但不是有序集，则返回错误。</p> 
<p>可选参数：</p> 
<ul><li><code>NX</code>：仅添加新元素。不更新已存在的元素。</li><li><code>XX</code>：只更新已存在的元素。不添加新元素。</li><li><code>GT</code>：仅当新分数大于当前分数时才更新现有元素。该参数不会阻止添加新元素。</li><li><code>LT</code>：仅当新分数小于当前分数时才更新现有元素。该参数不会阻止添加新元素。</li><li><code>INCR</code>：ZADD 其行为类似于 ZINCRBY。在此参数下只能指定一对分数元素。</li></ul> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> ZADD zset1 <span class="token number">60</span> a <span class="token number">70</span> b <span class="token number">80</span> c <span class="token number">90</span> d
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>
</code></pre> 
<p>🅰️ 2、获取元素 <code>ZRANGE</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">ZRANGE key start stop <span class="token punctuation">[</span>BYSCORE <span class="token operator">|</span> BYLEX<span class="token punctuation">]</span> <span class="token punctuation">[</span>REV<span class="token punctuation">]</span> <span class="token punctuation">[</span>LIMIT offset count<span class="token punctuation">]</span> <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span>
</code></pre> 
<p>按照元素分数从小到大的顺序返回索引从 start 到 stop 之间的所有元素。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> ZADD zset1 <span class="token number">60</span> a <span class="token number">70</span> b <span class="token number">80</span> c <span class="token number">90</span> d
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>
redis<span class="token operator">&gt;</span> ZRANGE zset1 <span class="token number">0</span> <span class="token parameter variable">-1</span> WITHSCORES
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"a"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"60"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"b"</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"70"</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">"c"</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">"80"</span>
<span class="token number">7</span><span class="token punctuation">)</span> <span class="token string">"d"</span>
<span class="token number">8</span><span class="token punctuation">)</span> <span class="token string">"90"</span>
redis<span class="token operator">&gt;</span> ZRANGE zset1 <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"a"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"b"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"c"</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"d"</span>
</code></pre> 
<p>🅰️ 3、获取元素 <code>ZREVRANGE</code></p> 
<blockquote> 
 <p>从 Redis 6.2.0 版开始，此命令被视为已弃用。使用带 REV 参数的 ZRANGE 替换它。</p> 
</blockquote> 
<p>语法：</p> 
<pre><code class="prism language-sh">ZREVRANGE key start stop <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span>
</code></pre> 
<p>返回排序集合中指定的元素范围。元素被认为是从最高到最低的顺序。对于分数相等的元素，使用降序词典顺序。</p> 
<p>除了相反的顺序，ZREVRANGE 与 ZRANGE 类似。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> ZADD zset1 <span class="token number">60</span> a <span class="token number">70</span> b <span class="token number">80</span> c <span class="token number">90</span> d
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>
redis<span class="token operator">&gt;</span> ZRANGE zset1 <span class="token number">0</span> <span class="token parameter variable">-1</span> WITHSCORES
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"a"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"60"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"b"</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"70"</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">"c"</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">"80"</span>
<span class="token number">7</span><span class="token punctuation">)</span> <span class="token string">"d"</span>
<span class="token number">8</span><span class="token punctuation">)</span> <span class="token string">"90"</span>
redis<span class="token operator">&gt;</span> ZREVRANGE zset1 <span class="token number">0</span> <span class="token parameter variable">-1</span> WITHSCORES
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"d"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"90"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"c"</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"80"</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">"b"</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">"70"</span>
<span class="token number">7</span><span class="token punctuation">)</span> <span class="token string">"a"</span>
<span class="token number">8</span><span class="token punctuation">)</span> <span class="token string">"60"</span>
</code></pre> 
<p>🅰️ 4、获取元素 <code>ZRANGEBYSCORE</code></p> 
<blockquote> 
 <p>从 Redis 6.2.0 版开始，此命令被视为已弃用。使用带 BYSCORE 参数的 ZRANGE 替换它。</p> 
</blockquote> 
<p>语法：</p> 
<pre><code class="prism language-sh">ZRANGEBYSCORE key min max <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span> <span class="token punctuation">[</span>LIMIT offset count<span class="token punctuation">]</span>
</code></pre> 
<p>返回排序集合中 SCORE 介于 min 和 max 之间的所有元素（包括 SCORE 等于 min 或 max 的元素）。元素被认为是从低到高分排序的。</p> 
<p>具有相同分数的元素按字典顺序返回（这是从 Redis 中的排序集实现的属性得出的，不涉及进一步的计算）。</p> 
<p>可选的 LIMIT 参数只能用于获取匹配元素的范围（类似于 SQL 中的 SELECT LIMIT 偏移量，count）。负计数返回偏移量中的所有元素。如果偏移量很大，则在返回元素之前，需要遍历已排序集合中的偏移元素，这可能会增加 O(N) 时间复杂性。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> ZADD zset1 <span class="token number">60</span> a <span class="token number">70</span> b <span class="token number">80</span> c <span class="token number">90</span> d
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>
redis<span class="token operator">&gt;</span> ZRANGEBYSCORE zset1 <span class="token number">60</span> <span class="token number">70</span> <span class="token comment"># 60&lt;= SCORE &lt;=70</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"a"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"b"</span>
redis<span class="token operator">&gt;</span> ZRANGEBYSCORE zset1 <span class="token number">60</span> <span class="token number">70</span> WITHSCORES
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"a"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"60"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"b"</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"70"</span>
redis<span class="token operator">&gt;</span> ZRANGEBYSCORE zset1 <span class="token punctuation">(</span><span class="token number">60</span> <span class="token number">70</span> <span class="token comment"># 60&lt; SCORE &lt;=70</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"b"</span>
redis<span class="token operator">&gt;</span> ZRANGEBYSCORE zset1 <span class="token punctuation">(</span><span class="token number">60</span> <span class="token punctuation">(</span><span class="token number">80</span> <span class="token comment"># 60&lt; SCORE &lt;80</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"b"</span>
redis<span class="token operator">&gt;</span> ZRANGEBYSCORE zset1 <span class="token punctuation">(</span><span class="token number">60</span> <span class="token punctuation">(</span><span class="token number">90</span> LIMIT <span class="token number">1</span> <span class="token number">1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"c"</span>
redis<span class="token operator">&gt;</span> ZRANGEBYSCORE zset1 <span class="token punctuation">(</span><span class="token number">60</span> <span class="token punctuation">(</span><span class="token number">90</span> LIMIT <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"b"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"c"</span>
</code></pre> 
<p>🅰️ 5、<code>ZSCORE</code></p> 
<pre><code class="prism language-sh">ZSCORE key member
</code></pre> 
<p>返回排序集合中元素的得分。如果排序集合中不存在成员，或者键不存在，则返回 nil 。</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> ZADD myzset <span class="token number">1</span> <span class="token string">"one"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> ZSCORE myzset <span class="token string">"one"</span>
<span class="token string">"1"</span>
redis<span class="token operator">&gt;</span> ZSCORE myset <span class="token string">"two"</span>
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
</code></pre> 
<p>🅰️ 6、<code>ZCARD</code></p> 
<pre><code class="prism language-sh">ZCARD key
</code></pre> 
<p>返回排序集合基数（元素数）。</p> 
<p>举例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> ZADD myzset <span class="token number">1</span> <span class="token string">"one"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> ZADD myzset <span class="token number">2</span> <span class="token string">"two"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> ZCARD myzset
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
</code></pre> 
<p>🅰️ 7、<code>ZCOUNT</code></p> 
<pre><code class="prism language-sh">ZCOUNT key min max
</code></pre> 
<p>返回排序集中得分介于最小值和最大值之间的元素个数。</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> ZADD myzset1 <span class="token number">1</span> <span class="token string">"one"</span> <span class="token number">2</span> <span class="token string">"two"</span> <span class="token number">3</span> <span class="token string">"three"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
redis<span class="token operator">&gt;</span> ZCOUNT myzset1 <span class="token number">1</span> <span class="token number">3</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
redis<span class="token operator">&gt;</span> ZCOUNT myzset1 <span class="token punctuation">(</span><span class="token number">1</span> <span class="token number">3</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
</code></pre> 
<p>🅰️ 8、<code>ZINCRBY</code></p> 
<pre><code class="prism language-sh">ZINCRBY key increment member
</code></pre> 
<p>按增量递增排序集合中元素的分数。如果成员在排序集中不存在，则将以增量作为其分数。如果键不存在，将创建一个新的排序集，其中指定成员作为其唯一成员。</p> 
<p>分数值应为数值的字符串表示形式，并接受双精度浮点数。可以提供负值来减少分数。</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> ZADD myzset <span class="token number">1</span> <span class="token string">"one"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> ZINCRBY myzset <span class="token number">2</span> <span class="token string">"one"</span>
<span class="token string">"3"</span>
redis<span class="token operator">&gt;</span> ZRANGE myzset <span class="token number">0</span> <span class="token parameter variable">-1</span> WITHSCORES
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"one"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"3"</span>
redis<span class="token operator">&gt;</span> ZINCRBY myzset <span class="token parameter variable">-1</span> <span class="token string">"one"</span>
<span class="token string">"2"</span>
redis<span class="token operator">&gt;</span> ZRANGE myzset <span class="token number">0</span> <span class="token parameter variable">-1</span> WITHSCORES
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"one"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"2"</span>
</code></pre> 
<p>🅰️ 9、删除元素 <code>ZREM</code></p> 
<pre><code class="prism language-sh">ZREM key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>删除集合中指定的元素。</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> ZADD myzset1 <span class="token number">1</span> <span class="token string">"one"</span> <span class="token number">2</span> <span class="token string">"two"</span> <span class="token number">3</span> <span class="token string">"three"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
redis<span class="token operator">&gt;</span> ZREM myzset1 <span class="token string">"one"</span> <span class="token string">"two"</span> <span class="token string">"redis"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
redis<span class="token operator">&gt;</span> ZRANGE myzset1 <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"three"</span>
</code></pre> 
<p>🅰️ 10、<code>ZMPOP</code></p> 
<pre><code class="prism language-sh">ZMPOP numkeys key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token operator">&lt;</span>MIN <span class="token operator">|</span> MAX<span class="token operator">&gt;</span> <span class="token punctuation">[</span>COUNT count<span class="token punctuation">]</span>
</code></pre> 
<p>从键名列表中的第一个非空排序集合中弹出一个或多个元素（即成员分数对）。</p> 
<p>当使用 MIN 修饰符时，弹出的元素是第一个非空排序集中得分最低的元素。MAX 修饰符时会弹出得分最高的元素。可选 COUNT 参数可用于指定要弹出的元素数，默认设置为 1。弹出元素的数量是排序集的基数或 COUNT 值。</p> 
<p>举例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> ZADD myzset <span class="token number">1</span> <span class="token string">"one"</span> <span class="token number">2</span> <span class="token string">"two"</span> <span class="token number">3</span> <span class="token string">"three"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
redis<span class="token operator">&gt;</span> ZMPOP <span class="token number">1</span> myzset MIN
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"myzset"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"one"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"1"</span>
redis<span class="token operator">&gt;</span> ZRANGE myzset <span class="token number">0</span> <span class="token parameter variable">-1</span> WITHSCORES
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"two"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"2"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"three"</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"3"</span>
redis<span class="token operator">&gt;</span> ZMPOP <span class="token number">1</span> myzset MAX COUNT <span class="token number">10</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"myzset"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"three"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"3"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"two"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"2"</span>
redis<span class="token operator">&gt;</span> ZADD myzset2 <span class="token number">4</span> <span class="token string">"four"</span> <span class="token number">5</span> <span class="token string">"five"</span> <span class="token number">6</span> <span class="token string">"six"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
redis<span class="token operator">&gt;</span> ZMPOP <span class="token number">2</span> myzset myzset2 MIN COUNT <span class="token number">10</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"myzset2"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"four"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"4"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"five"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"5"</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"six"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"6"</span>
redis<span class="token operator">&gt;</span> ZRANGE myzset <span class="token number">0</span> <span class="token parameter variable">-1</span> WITHSCORES
<span class="token punctuation">(</span>empty array<span class="token punctuation">)</span>
redis<span class="token operator">&gt;</span> ZMPOP <span class="token number">2</span> myzset myzset2 MAX COUNT <span class="token number">10</span>
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> object of <span class="token builtin class-name">type</span> <span class="token string">'NoneType'</span> has no len<span class="token punctuation">(</span><span class="token punctuation">)</span>
redis<span class="token operator">&gt;</span> ZRANGE myzset2 <span class="token number">0</span> <span class="token parameter variable">-1</span> WITHSCORES
<span class="token punctuation">(</span>empty array<span class="token punctuation">)</span>
</code></pre> 
<p>🅰️ 11、<code>ZRANK</code>/<code>ZREVRANK</code></p> 
<pre><code class="prism language-sh">ZRANK key member <span class="token punctuation">[</span>WITHSCORE<span class="token punctuation">]</span>

ZREVRANK key member <span class="token punctuation">[</span>WITHSCORE<span class="token punctuation">]</span>
</code></pre> 
<p>ZRANK 返回排序集合中元素的排名，分数从低到高排序。</p> 
<p>ZREVRANK 返回排序集合中元素的排名，分数从高到低排序。（逆序）</p> 
<p>举例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> ZADD myzset <span class="token number">1</span> <span class="token string">"one"</span> <span class="token number">2</span> <span class="token string">"two"</span> <span class="token number">3</span> <span class="token string">"three"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
redis<span class="token operator">&gt;</span> ZRANK myzset <span class="token string">"one"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> ZRANK myzset <span class="token string">"three"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
redis<span class="token operator">&gt;</span> ZREVRANK myzset <span class="token string">"one"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
redis<span class="token operator">&gt;</span> ZREVRANK myzset <span class="token string">"three"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre> 
<p>🅰️ 12、应用场景</p> 
<p>根据商品销售对商品进行排序显示。</p> 
<p>定义商品销售排行榜（sorted set 集合），key 为 goods:sellsort，分数为商品销售数量，值为商品编号。</p> 
<p>销售 2 件商品 1001：</p> 
<pre><code class="prism language-sh">ZINCRBY goods:sellsort <span class="token number">2</span> <span class="token number">1001</span>
</code></pre> 
<p>销售 10 件商品 1002：</p> 
<pre><code>ZINCRBY goods:sellsort 10 1002
</code></pre> 
<p>查看商品销量前 10 名：</p> 
<pre><code class="prism language-sh">ZRANGE goods:sellsort <span class="token number">0</span> <span class="token number">9</span> REV WITHSCORES
</code></pre> 
<h3><a id="08Redis_bitmap_2038"></a>08、Redis 位图（bitmap）</h3> 
<p>文档介绍：https://redis.io/docs/data-types/bitmaps</p> 
<p>相关命令：https://redis.io/commands/?group=bitmap</p> 
<p>Redis 位图是字符串数据类型的扩展，可以将字符串视为位向量。</p> 
<p>Bit arrays（or simply bitmaps，可以称之为位图），<code>由 0 和 1 状态表现的二进制位的 bit 数组</code>。</p> 
<p><img src="https://images2.imgbox.com/74/7f/F0FzCDA0_o.png" alt="在这里插入图片描述"></p> 
<p>说明：用 String 类型作为底层数据结构实现的一种统计二值状态的数据类型。</p> 
<p>位图本质是数组，它是基于 String 数据类型的按位的操作。该数组由多个二进制位组成，每个二进制位都对应一个偏移量（称之为一个索引）。</p> 
<p>Bitmap 支持的最大位数是 2^32 位，它可以极大的节约存储空间，使用 512M 内存就可以存储多达 42.9 亿的字节信息（2^32 = 4294967296）。最大长度为 512 MB。</p> 
<p>Bitmap 的偏移量是从 0 开始算的。</p> 
<p>主要用于状态统计场景：</p> 
<ul><li>用户是否登陆过 Y / N，每日签到状态</li><li>钉钉打卡上下班，签到状态统计</li></ul> 
<p>🅰️ 1、设置位值 <code>SETBIT</code></p> 
<pre><code class="prism language-sh">SETBIT key offset value
</code></pre> 
<p>设置或清除存储在键的字符串值中偏移处的位。该值可以是 0 或 1。</p> 
<p>当键不存在时，将创建一个新的字符串值。偏移量参数必须大于或等于 0，并且小于 2^32（位图限制为512MB）。当键的字符串增长时，添加的位被设置为 0。</p> 
<p>设置的返回值是存储在 key 的原始位的值。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SETBIT key <span class="token number">7</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> SETBIT key <span class="token number">7</span> <span class="token number">0</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> GET key
<span class="token string">""</span>
</code></pre> 
<p>🅰️ 2、获取位值 <code>GETBIT</code></p> 
<pre><code class="prism language-sh">GETBIT key offset
</code></pre> 
<p>返回存储在 key 的字符串值中偏移量处的位值。</p> 
<p>当偏移量超出字符串长度时，字符串被假定为具有 0 位的连续空间。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SETBIT mykey <span class="token number">7</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> GETBIT mykey <span class="token number">0</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> GETBIT mykey <span class="token number">7</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> GETBIT mykey <span class="token number">100</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre> 
<p>🅰️ 3、<code>STRLEN</code></p> 
<p>统计字节数占用多少。不是字符串长度而是占据几个字节，超过 8 位后自己按照 8 位一组一 byte 再扩容。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SETBIT K2 <span class="token number">0</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> SETBIT K2 <span class="token number">7</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> STRLEN K2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> SETBIT K2 <span class="token number">8</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> STRLEN K2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
</code></pre> 
<p>0-7 位一组；8-15 位一组。</p> 
<p>🅰️ 4、<code>BITCOUNT</code></p> 
<pre><code class="prism language-sh">BITCOUNT key <span class="token punctuation">[</span>start end <span class="token punctuation">[</span>BYTE <span class="token operator">|</span> BIT<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<p>计算字符串中设置位的数量（总体计数）。全部键里面含有 1 的有多少个。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SETBIT login:u1:202303 <span class="token number">0</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> SETBIT login:u1:202303 <span class="token number">1</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> SETBIT login:u1:202303 <span class="token number">2</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> SETBIT login:u1:202303 <span class="token number">3</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> SETBIT login:u1:202303 <span class="token number">6</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> BITCOUNT login:u1:202303
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
redis<span class="token operator">&gt;</span> BITCOUNT login:u1:202303 <span class="token number">0</span> <span class="token number">31</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
redis<span class="token operator">&gt;</span> BITCOUNT login:u1:202303 <span class="token number">0</span> <span class="token number">31</span> BYTE
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
redis<span class="token operator">&gt;</span> BITCOUNT login:u1:202303 <span class="token number">0</span> <span class="token number">31</span> BIT
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
</code></pre> 
<p>🅰️ 5、<code>BITOP</code></p> 
<pre><code class="prism language-sh">BITOP <span class="token operator">&lt;</span>AND <span class="token operator">|</span> OR <span class="token operator">|</span> XOR <span class="token operator">|</span> NOT<span class="token operator">&gt;</span> destkey key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>在多个键（包含字符串值）之间执行逐位操作，并将结果存储在目标键中。</p> 
<p>BITOP 命令支持四种按位操作：<code>AND</code>、<code>OR</code>、<code>XOR</code> 和 <code>NOT</code>，因此调用该命令的有效形式为：</p> 
<pre><code class="prism language-sh">BITOP AND destkey srckey1 srckey2 srckey3 <span class="token punctuation">..</span>. srckeyN

BITOP OR destkey srckey1 srckey2 srckey3 <span class="token punctuation">..</span>. srckeyN

BITOP XOR destkey srckey1 srckey2 srckey3 <span class="token punctuation">..</span>. srckeyN

BITOP NOT destkey srckey
</code></pre> 
<p>NOT 是特殊的，它只接受一个输入键，因为它执行位的反转，所以它只作为一元运算符有意义。</p> 
<p>操作结果始终存储在 destkey 键中。</p> 
<p>示例：</p> 
<p>一系统的用户有 1000W，做个用户 id 和位置的映射：比如 0 号位对应用户 id：uid-230101-don；比如 1 号位对应用户 id：uid-230101-xxx；…</p> 
<p>现在需要计算2023年3月8日/9日两天都签到的用户数。</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SETBIT <span class="token number">20230308</span> <span class="token number">0</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> SETBIT <span class="token number">20230308</span> <span class="token number">1</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> SETBIT <span class="token number">20230308</span> <span class="token number">2</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> SETBIT <span class="token number">20230308</span> <span class="token number">3</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> SETBIT <span class="token number">20230309</span> <span class="token number">0</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> SETBIT <span class="token number">20230309</span> <span class="token number">2</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> BITCOUNT <span class="token number">20230308</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4</span>
redis<span class="token operator">&gt;</span> BITCOUNT <span class="token number">20230309</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
redis<span class="token operator">&gt;</span> BITOP AND destkey <span class="token number">20230308</span> <span class="token number">20230309</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> BITCOUNT destkey
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
</code></pre> 
<p>得出 8日/9日 两天都签到的用户数 2 人。</p> 
<p>🅰️ 6、应用场景</p> 
<ul><li>一年365天，全年天天登陆占用多少字节？</li></ul> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> SETBIT UID1 <span class="token number">0</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> SETBIT UID1 <span class="token number">100</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> SETBIT UID1 <span class="token number">364</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
redis<span class="token operator">&gt;</span> BITCOUNT UID1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
redis<span class="token operator">&gt;</span> STRLEN UID1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">46</span>
</code></pre> 
<p>按年去存储一个用户的签到情况，365 天只需要 365 / 8 ≈ 46 Byte，1000W 用户量一年也只需要 44 MB 就足够了。</p> 
<p>假如是亿级的系统，每天使用1个1亿位的 Bitmap 约占 12 MB 的内存（10^8 / 8 / 1024 / 1024），10天的 Bitmap 的内存开销约为 120 MB，内存压力不算太高。</p> 
<p>此外，在实际使用时，最好对 Bitmap 设置过期时间，让 Redis 自动删除不再需要的签到记录以节省内存开销。</p> 
<h3><a id="09Redis_HyperLogLog_2240"></a>09、Redis 基数统计（HyperLogLog）</h3> 
<p>🅰️ ​1、场景需求</p> 
<ul><li>统计某个网站的 UV、统计某个文章的 UV；</li><li>搜索网站用户搜索关键词的数量；</li><li>统计用户每天搜索不同词条个数；</li></ul> 
<blockquote> 
 <p>UV：Unique Visitor，独立访客，一般理解为客户端 IP。需要去重考虑。</p> 
</blockquote> 
<p>🅰️ 2、是什么</p> 
<p>文档介绍：https://redis.io/docs/data-types/probabilistic/hyperloglogs</p> 
<p>相关命令：https://redis.io/commands/?group=hyperloglog</p> 
<p>Redis 在 2.8.9 版本添加了 HyperLogLog 结构。</p> 
<p>Redis HyperLogLog 是用来做 <code>基数统计</code> 的算法，HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。</p> 
<p>在 Redis 里面，每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 2^64 个不同元素的基数。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p> 
<p>但是，因为 HyperLogLog 只会根据输入元素来计算基数，而不会储存输入元素本身，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p> 
<blockquote> 
 <p>去重复统计功能的基数估计算法 —— HyperLogLog</p> 
</blockquote> 
<p>基数：是一种数据集，去重复后的真实个数。</p> 
<p>基数统计：用于统计一个集合中不重复的元素个数，就是对集合去重复后剩余元素的计算。</p> 
<p>🅰️ 3、基本命令</p> 
<p>1）添加</p> 
<pre><code class="prism language-sh">PFADD key <span class="token punctuation">[</span>element <span class="token punctuation">[</span>element <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<p>将所有元素添加到存储在指定为第一个参数的变量名称处的 HyperLogLog 数据结构中。如果键不存在，则创建该键。</p> 
<p>返回：如果至少 1 个 HyperLogLog 内部寄存器被更改，则为 1。否则为 0。</p> 
<p>2）获取基数</p> 
<pre><code class="prism language-sh">PFCOUNT key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>使用单个键调用时，返回由存储在指定键的 HyperLogLog 数据结构计算的近似基数，如果键不存在，则返回 0。</p> 
<p>当使用多个键调用时，通过将存储在键的 HyperLogLogs 内部合并为临时 HyperLogLog，返回传递的 HyperLogLog 并集的近似基数。</p> 
<p>返回的基数并不精确，而是近似值，标准误差为 0.81%。</p> 
<p>3）合并一个或多个 HyperLogLog</p> 
<pre><code class="prism language-sh">PFMERGE destkey <span class="token punctuation">[</span>sourcekey <span class="token punctuation">[</span>sourcekey <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<p>将多个 HyperLogLog 值合并为一个唯一值，该值将近似于源 HyperLogLog 结构的观察集的并集的基数。</p> 
<p>举例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> PFADD hll1 foo bar zap a
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> PFADD hll2 a b c foo
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> PFMERGE hll3 hll1 hll2
<span class="token string">"OK"</span>
redis<span class="token operator">&gt;</span> PFCOUNT hll3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">6</span>
</code></pre> 
<h3><a id="10Redis_GEO_2315"></a>10、Redis 地理空间（GEO）</h3> 
<p>文档介绍：https://redis.io/docs/data-types/geospatial</p> 
<p>相关命令：https://redis.io/commands/?group=geo</p> 
<p>Redis 在 3.2 版本以后增加了地理位置 GEO 的处理。</p> 
<p>🅰️ ​1、场景需求</p> 
<p>移动应用程序，可以查找当前位置最近的电动汽车充电站、美食店铺、附近的人等。</p> 
<p>地球上的地理位置是使用二维的经纬度表示，经度范围 (-180, 180]，纬度范围 (-90, 90]，只要确定一个点的经纬度就可以名取得他在地球的位置。</p> 
<p>举例：滴滴打车，最直观的操作就是实时记录更新各个车的位置，然后当要找车时，在数据库中查找距离我们（坐标 x0，y0）附近 R 公里范围内部的车辆。</p> 
<p>使用如下伪 SQL：</p> 
<pre><code class="prism language-mysql">select taxi from position where x0-r &lt; x &lt; x0 + r and y0-r &lt; y &lt; y0+r;
</code></pre> 
<p>❌ 但是这样会有什么问题呢？</p> 
<ol><li>查询性能问题，如果并发高，数据量大这种查询是要搞垮数据库。</li><li>这个查询的是一个矩形访问，而不是以我为中心 R 公里为半径的圆形访问。</li><li>精准度的问题，地球不是平面坐标系，而是一个圆球，这种矩形计算在长距离计算时会有很大误差。</li></ol> 
<p>Redis 地理空间（GEO）数据类型对于查找给定半径或边界框内的附近点非常有用。</p> 
<p>🅰️ 2、添加坐标 <code>GEOADD</code></p> 
<pre><code class="prism language-sh">GEOADD key <span class="token punctuation">[</span>NX <span class="token operator">|</span> XX<span class="token punctuation">]</span> <span class="token punctuation">[</span>CH<span class="token punctuation">]</span> longitude latitude member <span class="token punctuation">[</span>longitude latitude member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>将指定的地理空间元素（经度、纬度、名称）添加到指定的键。数据以排序集的形式存储在键中，从而可以使用 GEOSEARCH 命令查询项目。</p> 
<p>该命令采用标准格式 x，y 的参数，因此必须在纬度之前指定经度。可以索引的坐标是有限制的：非常靠近极点的区域是不可索引的。</p> 
<p>注意：没有 GEODEL 命令，因为可以使用 ZREM 删除元素。GEO 索引结构只是一个排序集。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> GEOADD city <span class="token number">116.403963</span> <span class="token number">39.915119</span> <span class="token string">"天安门"</span> <span class="token number">116.403414</span> <span class="token number">39.924091</span> <span class="token string">"故宫"</span> <span class="token number">116.024067</span> <span class="token number">40.362639</span> <span class="token string">"长城"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
redis<span class="token operator">&gt;</span> TYPE city  <span class="token comment">## GEO 索引结构只是一个排序集</span>
<span class="token string">"zset"</span>
redis<span class="token operator">&gt;</span> ZRANGE city <span class="token number">0</span> <span class="token parameter variable">-1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"天安门"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"故宫"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"长城"</span>
redis<span class="token operator">&gt;</span> 
</code></pre> 
<p>🅰️ 3、获取坐标 <code>GEOPOS</code></p> 
<pre><code class="prism language-sh">GEOPOS key <span class="token punctuation">[</span>member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<p>从键里面返回所有给定位置元素的位置（经度和纬度）。</p> 
<p>当通过坐标填充地理空间索引时，GEOADD 坐标会转换为 52 位 geohash，因此返回的坐标可能不完全是用于添加元素的坐标，但可能会引入小错误。</p> 
<p>该命令返回一个数组，其中每个元素都是一个两元素数组，表示作为参数传递给命令的每个成员名称的经度和纬度 (x,y)。不存在的元素将返回 NULL。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> GEOADD city <span class="token number">116.403963</span> <span class="token number">39.915119</span> <span class="token string">"天安门"</span> <span class="token number">116.403414</span> <span class="token number">39.924091</span> <span class="token string">"故宫"</span> <span class="token number">116.024067</span> <span class="token number">40.362639</span> <span class="token string">"长城"</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
redis<span class="token operator">&gt;</span> GEOPOS city 天安门 故宫 长城
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"116.40396326780319214"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"39.91511970338637383"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"116.40341609716415405"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"39.92409008156928252"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"116.02406591176986694"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"40.36263993239462167"</span>
redis<span class="token operator">&gt;</span>
</code></pre> 
<p>🅰️ 4、<code>GEOHASH</code></p> 
<pre><code class="prism language-sh">GEOHASH key <span class="token punctuation">[</span>member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<p>返回一个或多个元素在地理空间索引的排序集值中的位置的有效 Geohash 字符串。GEOHASH 算法生成的 base32 编码值。</p> 
<p>该命令返回 11 个字符的 Geohash 字符串，因此与 Redis 内部 52 位表示相比，精度不会丢失。</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> GEOHASH city 天安门 故宫 长城
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"wx4g0f6f2v0"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"wx4g0gfqsj0"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"wx4t85y1kt0"</span>
redis<span class="token operator">&gt;</span>
</code></pre> 
<p>🅰️ 5、获取两个坐标的距离 <code>GEODIST</code></p> 
<pre><code class="prism language-sh">GEODIST key member1 member2 <span class="token punctuation">[</span>M <span class="token operator">|</span> KM <span class="token operator">|</span> FT <span class="token operator">|</span> MI<span class="token punctuation">]</span>
</code></pre> 
<p>返回两个给定位置之间的距离。</p> 
<p>计算距离时假设地球是一个完美的球体，因此在边缘情况下可能存在高达 0.5% 的误差。</p> 
<p>参数：</p> 
<ul><li>M：米</li><li>KM：千米</li><li>FT：英尺</li><li>MI：英里</li></ul> 
<p>该命令以指定单位的双精度型（表示为字符串）形式返回距离，如果缺少一个或两个元素，则返回 NULL。</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> GEODIST city 天安门 故宫 km
<span class="token string">"0.9988"</span>
redis<span class="token operator">&gt;</span> GEODIST city 天安门 故宫 m
<span class="token string">"998.8332"</span>
redis<span class="token operator">&gt;</span> 
</code></pre> 
<p>🅰️ 6、查找范围内的坐标 <code>GEORADIUS</code></p> 
<blockquote> 
 <p>从 Redis 6.2.0 版开始，此命令被视为已弃用。</p> 
 <p>使用 BYRADIUS 参数将其替换为 GEOSEARCH 和 GEOSEARCHSTORE 命令。</p> 
</blockquote> 
<pre><code class="prism language-sh">GEORADIUS key longitude latitude radius <span class="token operator">&lt;</span>M <span class="token operator">|</span> KM <span class="token operator">|</span> FT <span class="token operator">|</span> MI<span class="token operator">&gt;</span>
  <span class="token punctuation">[</span>WITHCOORD<span class="token punctuation">]</span> <span class="token punctuation">[</span>WITHDIST<span class="token punctuation">]</span> <span class="token punctuation">[</span>WITHHASH<span class="token punctuation">]</span> <span class="token punctuation">[</span>COUNT count <span class="token punctuation">[</span>ANY<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>ASC <span class="token operator">|</span> DESC<span class="token punctuation">]</span>
  <span class="token punctuation">[</span>STORE key<span class="token punctuation">]</span> <span class="token punctuation">[</span>STOREDIST key<span class="token punctuation">]</span>
</code></pre> 
<p>以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。</p> 
<pre><code class="prism language-sh">GEORADIUS city <span class="token number">116.418017</span> <span class="token number">39.914402</span> <span class="token number">10</span> km WITHDIST WITHCOORD COUNT <span class="token number">10</span> WITHHASH DESC
GEORADIUS city <span class="token number">116.418017</span> <span class="token number">39.914402</span> <span class="token number">10</span> km WITHDIST WITHCOORD WITHHASH COUNT <span class="token number">10</span> DESC
</code></pre> 
<p>参数：</p> 
<ul><li><code>WITHDIST</code>：在返回位置元素的同时， 将位置元素与中心之间的距离也一并返回。 距离的单位和用户给定的范围单位保持一致。</li><li><code>WITHCOORD</code>：将位置元素的经度和维度也一并返回。</li><li><code>WITHHASH</code>：以 52 位有符号整数的形式， 返回位置元素经过原始 geohash 编码的有序集合分值。 这个选项主要用于底层应用或者调试， 实际中的作用并不大。</li><li><code>COUNT</code>：限定返回的记录数。</li></ul> 
<p>举例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> GEORADIUS city <span class="token number">116.418017</span> <span class="token number">39.914402</span> <span class="token number">10</span> km WITHDIST WITHCOORD WITHHASH COUNT <span class="token number">10</span> DESC
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"故宫"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"1.6470"</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4069885568908290</span>
   <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"116.40341609716415405"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"39.92409008156928252"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"天安门"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"1.2016"</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4069885555089531</span>
   <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"116.40396326780319214"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"39.91511970338637383"</span>
redis<span class="token operator">&gt;</span> 
</code></pre> 
<p>🅰️ 7、查找范围内的坐标 <code>GEORADIUSBYMEMBER</code></p> 
<blockquote> 
 <p>从 Redis 6.2.0 版开始，此命令被视为已弃用。</p> 
 <p>使用 BYRADIUS 和 FROMMEMBER 参数将其替换为 GEOSEARCH 和GEOSEARCHSTORE 命令。</p> 
</blockquote> 
<pre><code class="prism language-sh">GEORADIUSBYMEMBER key member radius <span class="token operator">&lt;</span>M <span class="token operator">|</span> KM <span class="token operator">|</span> FT <span class="token operator">|</span> MI<span class="token operator">&gt;</span> <span class="token punctuation">[</span>WITHCOORD<span class="token punctuation">]</span>
  <span class="token punctuation">[</span>WITHDIST<span class="token punctuation">]</span> <span class="token punctuation">[</span>WITHHASH<span class="token punctuation">]</span> <span class="token punctuation">[</span>COUNT count <span class="token punctuation">[</span>ANY<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>ASC <span class="token operator">|</span> DESC<span class="token punctuation">]</span> <span class="token punctuation">[</span>STORE key<span class="token punctuation">]</span>
  <span class="token punctuation">[</span>STOREDIST key<span class="token punctuation">]</span>
</code></pre> 
<p>此命令与 GEORADIUS 完全相同，唯一的区别是，它不采用经度和纬度值作为要查询区域的中心，而是采用已存在于由排序集表示的地理空间索引中的成员的名称。</p> 
<p>以指定成员的位置作为查询的中心。</p> 
<p>举例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> GEORADIUSBYMEMBER city 天安门 <span class="token number">10</span> km WITHDIST WITHCOORD WITHHASH COUNT <span class="token number">10</span> DESC
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"故宫"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"0.9988"</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4069885568908290</span>
   <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"116.40341609716415405"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"39.92409008156928252"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"天安门"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"0.0000"</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4069885555089531</span>
   <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"116.40396326780319214"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"39.91511970338637383"</span>
redis<span class="token operator">&gt;</span> 
</code></pre> 
<p>🅰️ 8、查找范围内的坐标 <code>GEOSEARCH</code></p> 
<p>版本 6.2.0 新增命令，用于替换上边两个命令。</p> 
<pre><code class="prism language-sh">GEOSEARCH key <span class="token operator">&lt;</span>FROMMEMBER member <span class="token operator">|</span> FROMLONLAT longitude latitude<span class="token operator">&gt;</span>
  <span class="token operator">&lt;</span>BYRADIUS radius <span class="token operator">&lt;</span>M <span class="token operator">|</span> KM <span class="token operator">|</span> FT <span class="token operator">|</span> MI<span class="token operator">&gt;</span> <span class="token operator">|</span> BYBOX width height <span class="token operator">&lt;</span>M <span class="token operator">|</span> KM <span class="token operator">|</span>
  FT <span class="token operator">|</span> MI<span class="token operator">&gt;&gt;</span> <span class="token punctuation">[</span>ASC <span class="token operator">|</span> DESC<span class="token punctuation">]</span> <span class="token punctuation">[</span>COUNT count <span class="token punctuation">[</span>ANY<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>WITHCOORD<span class="token punctuation">]</span> <span class="token punctuation">[</span>WITHDIST<span class="token punctuation">]</span>
  <span class="token punctuation">[</span>WITHHASH<span class="token punctuation">]</span>
</code></pre> 
<p>返回地理空间信息的排序集的成员，这些成员位于给定形状指定的区域边界内。此命令扩展了 GEORADIUS 命令，因此除了在圆形区域内搜索外，它还支持在矩形区域内搜索。</p> 
<p>使用此命令代替已弃用的 GEORADIUS 和 GEORADIUSBYMEMBER 命令。</p> 
<p>查询的中心点由以下强制选项之一提供：</p> 
<ul><li>FROMMEMBER：使用排序集合中给定的现有 <code>member</code> 的位置。</li><li>FROMLONLAT：使用给定的 <code>经度</code> 和 <code>纬度</code> 位置。</li></ul> 
<p>查询的形状由以下强制选项之一提供：</p> 
<ul><li>BYRADIUS：类似于 GEORADIUS，根据给定的 <code>radius</code> 在圆形区域内搜索。</li><li>BYBOX：在轴对齐的矩形内搜索，由 <code>height</code> 和 <code>width</code> 确定。</li></ul> 
<p>默认情况下，匹配项返回时未排序。要对它们进行排序，请使用以下两个选项之一：</p> 
<ul><li>ASC：相对于中心点，从最近到最远对返回的项目进行排序。</li><li>DESC：相对于中心点，从最远到最近对返回的项目进行排序。</li></ul> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> GEOSEARCH city FROMLONLAT <span class="token number">116.418017</span> <span class="token number">39.914402</span> BYRADIUS <span class="token number">10</span> km
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"天安门"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"故宫"</span>
redis<span class="token operator">&gt;</span> GEOSEARCH city FROMLONLAT <span class="token number">116.418017</span> <span class="token number">39.914402</span> BYRADIUS <span class="token number">10</span> km WITHDIST WITHCOORD WITHHASH
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"天安门"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"1.2016"</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4069885555089531</span>
   <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"116.40396326780319214"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"39.91511970338637383"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"故宫"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"1.6470"</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4069885568908290</span>
   <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"116.40341609716415405"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"39.92409008156928252"</span>
redis<span class="token operator">&gt;</span>
</code></pre> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> GEOSEARCH city FROMMEMBER 天安门 BYBOX <span class="token number">10</span> <span class="token number">10</span> km WITHDIST WITHCOORD WITHHASH
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"天安门"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"0.0000"</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4069885555089531</span>
   <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"116.40396326780319214"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"39.91511970338637383"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"故宫"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"0.9988"</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">4069885568908290</span>
   <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"116.40341609716415405"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"39.92409008156928252"</span>
redis<span class="token operator">&gt;</span> 
</code></pre> 
<h3><a id="11Redis_Stream_2584"></a>11、Redis 流（Stream）</h3> 
<p>文档介绍：https://redis.io/docs/data-types/streams</p> 
<p>相关命令：https://redis.io/commands/?group=stream</p> 
<p>🅰️ 1、是什么</p> 
<p>Redis 5.0 之前，Redis 消息队列的2种方案：</p> 
<p>1）List 实现消息队列</p> 
<p>按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p> 
<p>所以常用来做 <code>异步队列使用</code>，将需要延后处理的任务结构体序列化成字符串塞进 Redis 的列表，另一个线程从这个列表中轮询数据进行处理。</p> 
<p><img src="https://images2.imgbox.com/c1/1b/4OO8XLEq_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>List 实现方式其实就是点对点的模式。</p> 
</blockquote> 
<p>2）发布订阅模式（Pub/Sub）</p> 
<p>Redis 发布订阅（pub/sub）有个缺点就是消息无法持久化，如果出现网络断开、Redis 宕机等，消息就会被丢弃。而且也没有 ACK 机制来保证数据的可靠性，假设一个消费者都没有，那消息就直接被丢弃了。</p> 
<p>简单来说发布订阅（pub/sub）可以分发消息，但无法记录历史消息。</p> 
<p><img src="https://images2.imgbox.com/58/33/hoyXQaUq_o.png" alt="在这里插入图片描述"></p> 
<p>Redis 5.0 版本新增了一个更强大的数据结构 —— <code>Stream</code>。即 Redis 版的 MQ 消息中间件 + 阻塞队列。</p> 
<p>Redis Stream 提供了消息的持久化和主备复制功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p> 
<p>🅰️ 2、能干嘛</p> 
<p>实现消息队列，它支持消息的持久化、支持自动生成全局唯一 ID、支持 ACK 确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。</p> 
<p>🅰️ 3、底层结构和原理说明</p> 
<p>Redis Stream 的结构如下所示，它有一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容：</p> 
<p><img src="https://images2.imgbox.com/32/d4/MkJo1Wce_o.png" alt="在这里插入图片描述"></p> 
<p>每个 Stream 都有唯一的名称，它就是 Redis 的 key，在我们首次使用 <code>xadd</code> 命令追加消息时自动创建。</p> 
<p>1）<code>Message Content</code> ：消息内容。</p> 
<p>2）<code>Consumer Group</code> ：消费组，通过 <code>XGROUP CREATE</code> 命令创建，同一个消费组可以有多个消费者。</p> 
<p>3）<code>Last_delivered_id</code> ：游标，每个消费组会有个游标 <code>last_delivered_id</code>，任意一个消费者读取了消息都会使游标 <code>last_delivered_id</code> 往前移动。</p> 
<p>4）<code>Consumer</code> ：消费者，消费组中的消费者。</p> 
<p>5）<code>Pending_ids</code> ：消费者会有一个状态变量，用于记录被当前消费已读取但未 ACK 的消息 ID，如果客户端没有 ACK，这个变量里面的消息 ID 会越来越多，一旦某个消息被 ACK 它就开始减少。这个 <code>pending_ids</code> 变量在 Redis 官方被称之为 PEL（Pending Entries List），记录了当前已经被客户端读取的消息，但是还没有 ACK（Acknowledge character：确认字符），它用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理。</p> 
<p>🅰️ 4、基本命令理论简介</p> 
<p>1）队列相关指令</p> 
<ul><li><code>XADD</code> ：添加消息到队列末尾；</li><li><code>XTRIM</code> ：限制 Stream 的长度，如果已经超长会进行截取；</li><li><code>XDEL</code> ：删除消息；</li><li><code>XLEN</code> ：获取 Stream 中的消息长度；</li><li><code>XRANGE</code> ：获取消息列表（可以指定范围），忽略已经删除的消息；</li><li><code>XREVRANGE</code> ：和 XRANGE 相比区别在于反向获取，ID 从大到小；</li><li><code>XREAD</code> ：获取消息（阻塞/非阻塞），返回大于指定 ID 的消息。</li></ul> 
<p>2）消费组相关指令</p> 
<ul><li><code>XGROUP CREATE</code> ：创建消费者组；</li><li><code>XREADGROUP GROUP</code> ：读取消费者组中的消息；</li><li><code>XACK</code> ：将消息标记为"已处理"；</li><li><code>XGROUP SETID</code> ：为消费者组设置新的最后递送消息 ID；</li><li><code>XGROUP DELCONSUMER</code> ：删除消费者；</li><li><code>XGROUP DESTROY</code> ：删除消费者组；</li><li><code>XPENDING</code> ：打印待处理消息的详细信息；</li><li><code>XCLAIM</code> ：转移消息的归属权（长期未被处理/无法处理的消息，转交给其他消费者组进行处理）；</li><li><code>XINFO</code> ：打印 Stream \ Consumer \ Group 的详细信息； 
  <ul><li><code>XINFO GROUPS</code> ：打印消费者组的详细信息；</li><li><code>XINFO STREAM</code> ：打印 Stream 详细信息；</li><li><code>XINFO CONSUMERS</code> ：打印消费者的详细信息。</li></ul> </li></ul> 
<p>3）四个特殊符号</p> 
<ul><li><code>- +</code> ：最小和最大可能出现的 ID；</li><li><code>$</code> ：表示只消费新的消息，当前流中最大的 ID，可用于将要到来的信息；</li><li><code>&gt;</code> ：用于 XREADGROUP 命令，表示迄今还没有发送给组中使用者的信息，会更新消费者组的最后 ID；</li><li><code>*</code> ：用于 XADD 命令中，让系统自动生成 ID。</li></ul> 
<h4><a id="1_2675"></a>1、队列相关指令操作</h4> 
<p>🅱️ 1、添加消息到队列末尾 <code>XADD</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">XADD key <span class="token punctuation">[</span>NOMKSTREAM<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token operator">&lt;</span>MAXLEN <span class="token operator">|</span> MINID<span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token operator">=</span> <span class="token operator">|</span> ~<span class="token punctuation">]</span> threshold
  <span class="token punctuation">[</span>LIMIT count<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span>* <span class="token operator">|</span> id<span class="token operator">&gt;</span> field value <span class="token punctuation">[</span>field value <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p><code>XADD</code> 用于向 Stream 队列中添加消息，如果指定的 Stream 队列不存在，则该命令执行时会新建一个 Stream 队列。<code>*</code> 号表示服务器自动生成 MessageID，后面顺序跟着一堆 业务 field / value。</p> 
<p>生成的消息 ID，有两部分组成，<code>毫秒时间戳-该毫秒内产生的第1条消息</code>：</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> XADD mystream * field1 value1 field2 value2 field3 value3
<span class="token string">"1678430091999-1"</span>
</code></pre> 
<p>信息条目指的是序列号，在相同的毫秒下序列号从 <code>0</code> 开始递增，序列号是 64 位长度，理论上在同一毫秒内生成的数据量无法到达这个级别，因此不用担心序列号会不够用。millisecondsTime 指的是 Redis 节点服务器的本地时间，如果存在当前的毫秒时间戳比以前已经存在的数据的时间戳小的话（本地时间钟后跳），那么系统将会采用以前相同的毫秒创建新的 ID，也即 Redis 在增加信息条目时会检查当前 ID 与上一条目的 ID， 自动纠正错误的情况，一定要保证后面的 ID 比前面大，一个流中信息条目的 ID <code>必须是单调增的</code>，这是流的基础。</p> 
<p>客户端显示传入规则：</p> 
<p>Redis 对于 ID 有强制要求，格式必须是 <code>时间戳-自增ID</code> 这样的方式，且后续 ID 大于前一个 ID。</p> 
<p>Stream 的消息内容，也就是图中的 Message Content 它的结构类似 Hash 结构，以 field-value 的形式存在。</p> 
<ul><li><code>key</code> ：队列名称，如果不存在就创建。</li><li><code>id</code> ：消息 id，使用 <code>*</code> 表示由 Redis 生成；可以自定义，但是要自己保证递增性。</li><li><code>field value</code> ： 记录项。</li></ul> 
<p>🅱️ 2、获取消息列表 <code>XRANGE</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">XRANGE key start end <span class="token punctuation">[</span>COUNT count<span class="token punctuation">]</span>
</code></pre> 
<p>用于获取消息列表（可以指定范围），忽略删除的消息。</p> 
<ul><li><code>start</code> ：表示开始值，<code>-</code> 代表最小值。</li><li><code>end</code> ：表示结束值，<code>+</code> 代表最大值。</li><li><code>count</code> ：表示最多获取多少个值。</li></ul> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> XADD stream1 * k1 v1 k2 v2
<span class="token string">"1678431243920-0"</span>
redis<span class="token operator">&gt;</span> XADD stream1 * k3 v3 k4 v4
<span class="token string">"1678431257954-0"</span>
redis<span class="token operator">&gt;</span> XRANGE stream1 - +
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1678431243920-0"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"k1"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"v1"</span>
      <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"k2"</span>
      <span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"v2"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1678431257954-0"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"k3"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"v3"</span>
      <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"k4"</span>
      <span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"v4"</span>
</code></pre> 
<p>🅱️ 3、反向获取消息列表 <code>XREVRANGE</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">XREVRANGE key end start <span class="token punctuation">[</span>COUNT count<span class="token punctuation">]</span>
</code></pre> 
<p>与 XRANGE 的区别在于，获取消息列表元素的方向是相反的，end 在前，start 在后。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> XADD stream1 * k1 v1 k2 v2
<span class="token string">"1678431405813-0"</span>
redis<span class="token operator">&gt;</span> XADD stream1 * k3 v3 k4 v4
<span class="token string">"1678431409400-0"</span>
redis<span class="token operator">&gt;</span> XREVRANGE stream1 + -
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1678431409400-0"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"k3"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"v3"</span>
      <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"k4"</span>
      <span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"v4"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1678431405813-0"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"k1"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"v1"</span>
      <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"k2"</span>
      <span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"v2"</span>
redis<span class="token operator">&gt;</span> 
</code></pre> 
<p>🅱️ 4、删除消息 <code>XDEL</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">XDEL key <span class="token function">id</span> <span class="token punctuation">[</span>id <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>使用 XDEL 删除消息（ID）。从流中删除指定的条目，并返回实际删除的条目数。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> XADD stream1 * k1 v1
<span class="token string">"1678431756796-0"</span>
redis<span class="token operator">&gt;</span> XADD stream1 * k2 v2
<span class="token string">"1678431763476-0"</span>
redis<span class="token operator">&gt;</span> XRANGE stream1 - +
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1678431756796-0"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"k1"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"v1"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1678431763476-0"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"k2"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"v2"</span>
redis<span class="token operator">&gt;</span> XDEL stream1 <span class="token number">1678431756796</span>-0
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> XRANGE stream1 - +
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1678431763476-0"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"k2"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"v2"</span>
redis<span class="token operator">&gt;</span> 
</code></pre> 
<p>🅱️ 5、获取消息长度 <code>XLEN</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">XLEN key
</code></pre> 
<p>用于获取 Stream 队列的消息的长度。</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> XLEN stream1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre> 
<p>🅱️ 6、截取消息长度 <code>XTRIM</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">XTRIM key <span class="token operator">&lt;</span>MAXLEN <span class="token operator">|</span> MINID<span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token operator">=</span> <span class="token operator">|</span> ~<span class="token punctuation">]</span> threshold <span class="token punctuation">[</span>LIMIT count<span class="token punctuation">]</span>
</code></pre> 
<p>用于对 Stream 的长度进行截取，如超长会进行截取。</p> 
<p>1）<code>MAXLEN</code></p> 
<p>允许的最大长度，只要流的长度超过指定的 threshold，就移除条目，其中 threshold 是正整数。</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> XADD stream1 * k1 v1
<span class="token string">"1678435003936-0"</span>
redis<span class="token operator">&gt;</span> XADD stream1 * k2 v2
<span class="token string">"1678435010172-0"</span>
redis<span class="token operator">&gt;</span> XADD stream1 * k3 v3
<span class="token string">"1678435015141-0"</span>
redis<span class="token operator">&gt;</span> XRANGE stream1 - +
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1678435003936-0"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"k1"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"v1"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1678435010172-0"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"k2"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"v2"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1678435015141-0"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"k3"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"v3"</span>
redis<span class="token operator">&gt;</span> XTRIM stream1 MAXLEN <span class="token number">2</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
redis<span class="token operator">&gt;</span> XRANGE stream1 - +
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1678435010172-0"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"k2"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"v2"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1678435015141-0"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"k3"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"v3"</span>
redis<span class="token operator">&gt;</span> 
</code></pre> 
<p>2）<code>MINID</code></p> 
<p>允许的最小 ID，从某个 ID 值开始比该 ID 值小的将会被移除。其中 threshold 是流 ID。</p> 
<pre><code class="prism language-sh">redis<span class="token operator">&gt;</span> XADD stream1 * k1 v1
<span class="token string">"1678436286856-0"</span>
redis<span class="token operator">&gt;</span> XADD stream1 * k2 v2
<span class="token string">"1678436291292-0"</span>
redis<span class="token operator">&gt;</span> XADD stream1 * k3 v3
<span class="token string">"1678436296114-0"</span>
redis<span class="token operator">&gt;</span> XRANGE stream1 - +
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1678436286856-0"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"k1"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"v1"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1678436291292-0"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"k2"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"v2"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1678436296114-0"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"k3"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"v3"</span>
redis<span class="token operator">&gt;</span> XTRIM stream1 MINID <span class="token number">1678436296114</span>-0
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
redis<span class="token operator">&gt;</span> XRANGE stream1 - +
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1678436296114-0"</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"k3"</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"v3"</span>
redis<span class="token operator">&gt;</span> 
</code></pre> 
<p>🅱️ 7、获取消息（阻塞/非阻塞） <code>XREAD</code></p> 
<p>语法：https://redis.io/commands/xread</p> 
<pre><code class="prism language-sh">XREAD <span class="token punctuation">[</span>COUNT count<span class="token punctuation">]</span> <span class="token punctuation">[</span>BLOCK milliseconds<span class="token punctuation">]</span> STREAMS key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token function">id</span> <span class="token punctuation">[</span>id <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>用于获取消息（阻塞/非阻塞），只会返回大于指定 ID 的消息。从一个或多个流中读取数据，仅返回 ID 大于调用者给定的最后接收到的 ID 的条目。</p> 
<p><code>COUNT</code> ：对于每个流，最多读取每个流多少条消息。</p> 
<p><code>BLOCK</code> ：是否已阻塞的方式读取消息，默认不阻塞，如果 <code>milliseconds</code> 设置为 0，表示永远阻塞。</p> 
<p>1）非阻塞</p> 
<p><code>$</code> ：代表特殊 ID，表示以当前 Stream 已经存储的最大的 ID 作为最后一个 ID，当前 Stream 中不存在大于当前最大 ID 的消息，因此此时返回 nil。</p> 
<p><code>0-0</code> ：代表从最小的 ID 开始获取 Stream 中的消息，当不指定 count，将会返回 Stream 中的所有消息，注意也可以使用 0 / 00 / 000 同等效果。</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> XADD stream1 * k1 v1
<span class="token number">1678438374296</span>-0
<span class="token operator">&gt;</span> XADD stream1 * k2 v2
<span class="token number">1678438380663</span>-0
<span class="token operator">&gt;</span> XRANGE stream1 - +
<span class="token number">1678438374296</span>-0
k1
v1
<span class="token number">1678438380663</span>-0
k2
v2
<span class="token operator">&gt;</span> XREAD COUNT <span class="token number">1</span> STREAMS stream1 $
null
<span class="token operator">&gt;</span> XREAD COUNT <span class="token number">1</span> STREAMS stream1 <span class="token number">0</span>-0
stream1
<span class="token number">1678438374296</span>-0
k1
v1
<span class="token operator">&gt;</span> XREAD COUNT <span class="token number">3</span> STREAMS stream1 00
stream1
<span class="token number">1678438374296</span>-0
k1
v1
<span class="token number">1678438380663</span>-0
k2
v2
</code></pre> 
<p>2）阻塞</p> 
<p>客户端 B：<code>BLOCK 0</code> 此时会永久阻塞</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> XREAD COUNT <span class="token number">1</span> BLOCK <span class="token number">0</span> STREAMS stream1 $
</code></pre> 
<p>客户端 A：添加消息</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> XADD stream1 * k3 v3
<span class="token number">1678438810766</span>-0
</code></pre> 
<p>客户端 A 添加消息后，客户端 B 则会取出最新消息：</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> XREAD COUNT <span class="token number">1</span> BLOCK <span class="token number">0</span> STREAMS stream1 $
stream1
<span class="token number">1678438810766</span>-0
k3
v3
</code></pre> 
<p>3）小总结（类似 Java 中的阻塞队列）</p> 
<p>Stream 的基础方法，使用 <code>xadd</code> 存入消息和 <code>xread</code> 循环阻塞读取消息的方式可以实现简易版的消息队列，交互流程如下：</p> 
<p><img src="https://images2.imgbox.com/6d/bc/WPpWDIvK_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="2_2976"></a>2、消费组相关指令操作</h4> 
<p>🅱️ 1、创建消费者组 <code>XGROUP CREATE</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">XGROUP CREATE key group <span class="token operator">&lt;</span>id <span class="token operator">|</span> $<span class="token operator">&gt;</span> <span class="token punctuation">[</span>MKSTREAM<span class="token punctuation">]</span> <span class="token punctuation">[</span>ENTRIESREAD entries-read<span class="token punctuation">]</span>
</code></pre> 
<p>创建消费者组的时候必须指定 ID。</p> 
<p>ID 为 <code>0</code> 表示从头开始消费。为 <code>$</code> 表示只消费新的消息，当前 Stream 内消息会全部忽略。</p> 
<p>当同名消费者组已存在时，该命令返回错误 BUSYGROUP。默认情况下，创建消费组的目标 key 流是需要存在，如果不存在则返回错误。如果流不存在，可以使用可选参数 MKSTREAM 来自动创建长度为 0 的流。</p> 
<ul><li><code>0</code> ：表示从 Stream 头部开始消费；</li><li><code>$</code> ：表示从 Stream 尾部开始消费；</li></ul> 
<p>示例：</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> XGROUP CREATE mystream mygroupA <span class="token number">0</span>
OK
<span class="token operator">&gt;</span> XGROUP CREATE mystream mygroupB $
OK
</code></pre> 
<p>🅱️ 2、读取消息 <code>XREADGROUP GROUP</code></p> 
<p>语法：</p> 
<pre><code class="prism language-sh">XREADGROUP GROUP group consumer <span class="token punctuation">[</span>COUNT count<span class="token punctuation">]</span> <span class="token punctuation">[</span>BLOCK milliseconds<span class="token punctuation">]</span>
  <span class="token punctuation">[</span>NOACK<span class="token punctuation">]</span> STREAMS key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token function">id</span> <span class="token punctuation">[</span>id <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>读取消费组中的消息。</p> 
<ul><li><code>&gt;</code> ：表示从第一条尚未被消费的消息开始读取。</li></ul> 
<p>示例：</p> 
<p>消费组 mygroupA 内的消费者 consumer1 从 stream1 消息队列中读取所有消息。</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> XGROUP CREATE stream1 mygroupA <span class="token number">0</span>
OK
<span class="token operator">&gt;</span> XGROUP CREATE stream1 mygroupB $
OK
<span class="token operator">&gt;</span> XREADGROUP GROUP mygroupA consumer1 STREAMS stream1 <span class="token operator">&gt;</span>
stream1
<span class="token number">1678438374296</span>-0
k1
v1
<span class="token number">1678438380663</span>-0
k2
v2
<span class="token operator">&gt;</span> XREADGROUP GROUP mygroupA consumer1 STREAMS stream1 <span class="token operator">&gt;</span>
null
<span class="token operator">&gt;</span> XREADGROUP GROUP mygroupA consumer2 STREAMS stream1 <span class="token operator">&gt;</span>
null
</code></pre> 
<p>Stream 中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了，即同一个消费组里的消费者不能消费同一条消息。上述例子的 <code>XREADGROUP</code> 命今再执行一次，此时读到的就是空值。</p> 
<p>❓ 2）不同消费组的消费者可以消费同一条消息吗？</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> XGROUP CREATE stream1 mygroupC <span class="token number">0</span>
OK
<span class="token operator">&gt;</span> XREADGROUP GROUP mygroupC consumer1 STREAMS stream1 <span class="token operator">&gt;</span>
stream1
<span class="token number">1678438374296</span>-0
k1
v1
<span class="token number">1678438380663</span>-0
k2
v2
<span class="token operator">&gt;</span> XREADGROUP GROUP mygroupC consumer1 STREAMS stream1 <span class="token operator">&gt;</span>
null
</code></pre> 
<p>可见，不同消费组的消费者可以消费同一条消息。</p> 
<p>❓ 3）消费组的目的？</p> 
<p>让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的。</p> 
<p>举例：</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> XGROUP CREATE stream1 mygroupD <span class="token number">0</span>
OK
<span class="token operator">&gt;</span> XREADGROUP GROUP mygroupD consumer1 COUNT <span class="token number">1</span> STREAMS stream1 <span class="token operator">&gt;</span>
stream1
<span class="token number">1678438374296</span>-0
k1
v1
<span class="token operator">&gt;</span> XREADGROUP GROUP mygroupD consumer2 COUNT <span class="token number">1</span> STREAMS stream1 <span class="token operator">&gt;</span>
stream1
<span class="token number">1678438380663</span>-0
k2
v2
<span class="token operator">&gt;</span> XREADGROUP GROUP mygroupD consumer3 COUNT <span class="token number">1</span> STREAMS stream1 <span class="token operator">&gt;</span>
null
</code></pre> 
<p>❓ 4）基于 Stream 实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息？</p> 
<p>解答：</p> 
<p>Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息保底措施，直到消费者使用 <code>XACK</code> 命令通知 Streams “消息已经处理完成”。</p> 
<p>消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行 XACK 命令确认消息已经被消费完成。</p> 
<p><img src="https://images2.imgbox.com/5f/76/dD3UFBqG_o.png" alt="在这里插入图片描述"></p> 
<p>🅱️ 3、查询消费者消费的信息 <code>XPENDING</code></p> 
<pre><code class="prism language-sh">XPENDING key group <span class="token punctuation">[</span><span class="token punctuation">[</span>IDLE min-idle-time<span class="token punctuation">]</span> start end count <span class="token punctuation">[</span>consumer<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<p>查询每个消费组内所有消费者（已读取、但尚未确认）的消息。</p> 
<p>举例：</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> XPENDING stream1 mygroupA
<span class="token number">3</span>
<span class="token number">1678438374296</span>-0    <span class="token comment">#所有消费者读取的消息最小ID</span>
<span class="token number">1678438810766</span>-0    <span class="token comment">#所有消费者读取的消息最大ID</span>
consumer1     <span class="token comment">#一个消费者一次性读3条</span>
<span class="token number">3</span>
<span class="token operator">&gt;</span> XPENDING stream1 mygroupD
<span class="token number">3</span>
<span class="token number">1678438374296</span>-0
<span class="token number">1678438810766</span>-0
consumer1    <span class="token comment">#以下3个消费者分别读取1条</span>
<span class="token number">1</span>
consumer2
<span class="token number">1</span>
consumer3
<span class="token number">1</span>
</code></pre> 
<p>查看某个消费者具体读取了哪些数据。</p> 
<p>返回 4 个属性：</p> 
<ul><li>消息的 ID；</li><li>获取消息且仍需确认的消费者的名称。我们称其为消息的当前所有者；</li><li>自上次将此消息传递给此消费者以来经过的毫秒数；</li><li>该消息被传送的次数。</li></ul> 
<p>举例：</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> XPENDING stream1 mygroupD - + <span class="token number">10</span> consumer1
<span class="token number">1678438374296</span>-0
consumer1
<span class="token number">815248</span>
<span class="token number">1</span>
</code></pre> 
<p>消费者 consumer1 已读取的消息的 ID 是 1678438374296-0。一旦消息 1678438374296-0 被 consumer1 处理了 consumer1 就可以使用 <code>XACK</code> 命令通知 Streams，然后这条消息就会被删除。</p> 
<p>🅱️ 4、消息处理完成确认 <code>XACK</code></p> 
<pre><code class="prism language-sh">XACK key group <span class="token function">id</span> <span class="token punctuation">[</span>id <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>向消息队列确认消息处理已完成。</p> 
<p>举例：</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> XPENDING stream1 mygroupC - + <span class="token number">10</span> consumer1    <span class="token comment">#没有ack之前有3条记录读取过</span>
<span class="token number">1678438374296</span>-0
consumer1
<span class="token number">1150855</span>
<span class="token number">1</span>
<span class="token number">1678438380663</span>-0
consumer1
<span class="token number">1150855</span>
<span class="token number">1</span>
<span class="token number">1678438810766</span>-0
consumer1
<span class="token number">1150855</span>
<span class="token number">1</span>
<span class="token operator">&gt;</span> XACK stream1 mygroupC <span class="token number">1678438374296</span>-0    <span class="token comment">#ack成功确认一条，返回1</span>
<span class="token number">1</span>
<span class="token operator">&gt;</span> XPENDING stream1 mygroupC - + <span class="token number">10</span> consumer1    <span class="token comment">#ack签收了1条，剩2条没有ack</span>
<span class="token number">1678438380663</span>-0
consumer1
<span class="token number">1176623</span>
<span class="token number">1</span>
<span class="token number">1678438810766</span>-0
consumer1
<span class="token number">1176623</span>
<span class="token number">1</span>
</code></pre> 
<p>🅱️ 5、查询信息 <code>XINFO</code></p> 
<p>XINFO 用于信息 Stream \ Consumer \ Group 的详细信息。</p> 
<p>1）获取消费者组中的消费者信息</p> 
<pre><code class="prism language-sh">XINFO CONSUMERS key group
</code></pre> 
<p>返回消费者列表，属性：</p> 
<ul><li>name：消费者的名</li><li>pending：PEL 中的条目数：消费者的待处理消息，这些消息是已发送但尚未确认的消息</li><li>idle：自消费者上次尝试交互以来经过的毫秒数（例如：XREADGROUP、XCLAIM、XAUTOLAIM）</li><li>inactive：自消费者上次成功交互以来经过的毫秒数（例如：实际将某些条目读取到 PEL 中的 XREADGROUP，实际声明某些条目的 XCLAIM / XAUTOCLAIM）</li></ul> 
<p>示例：</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> XINFO CONSUMERS mystream mygroup
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> name
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"Alice"</span>
   <span class="token number">3</span><span class="token punctuation">)</span> pending
   <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
   <span class="token number">5</span><span class="token punctuation">)</span> idle
   <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">9104628</span>
   <span class="token number">7</span><span class="token punctuation">)</span> inactive
   <span class="token number">8</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">18104698</span>
</code></pre> 
<p>2）获取消费者组的信息</p> 
<pre><code>XINFO GROUPS key
</code></pre> 
<p>返回消费者组列表，属性：</p> 
<ul><li>name : 消费者组的名称</li><li>consumers : 组中消费者的数量</li><li>pending ：组待处理条目列表（PEL）的长度，这些消息已发送但尚未确认</li><li>last-delivered-id：最后交付给该组消费者的消息的 ID</li><li>entries-read ：传递给组消费者的最后一个消息的逻辑“读取计数器”</li><li>lag ：流中仍在等待传递给组消费者的消息数，或者当无法确定该数字时为 NULL。</li></ul> 
<p>示例：</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> XINFO <span class="token environment constant">GROUPS</span> mystream
<span class="token number">1</span><span class="token punctuation">)</span>  <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"name"</span>
    <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"mygroup"</span>
    <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"consumers"</span>
    <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
    <span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">"pending"</span>
    <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
    <span class="token number">7</span><span class="token punctuation">)</span> <span class="token string">"last-delivered-id"</span>
    <span class="token number">8</span><span class="token punctuation">)</span> <span class="token string">"1638126030001-0"</span>
    <span class="token number">9</span><span class="token punctuation">)</span> <span class="token string">"entries-read"</span>
   <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
   <span class="token number">11</span><span class="token punctuation">)</span> <span class="token string">"lag"</span>
   <span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre> 
<p>3）获取流的信息</p> 
<pre><code class="prism language-sh">XINFO STREAM key <span class="token punctuation">[</span>FULL <span class="token punctuation">[</span>COUNT count<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<p>示例：</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> XINFO STREAM mystream
 <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"length"</span>
 <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
 <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"radix-tree-keys"</span>
 <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
 <span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">"radix-tree-nodes"</span>
 <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
 <span class="token number">7</span><span class="token punctuation">)</span> <span class="token string">"last-generated-id"</span>
 <span class="token number">8</span><span class="token punctuation">)</span> <span class="token string">"1638125141232-0"</span>
 <span class="token number">9</span><span class="token punctuation">)</span> <span class="token string">"max-deleted-entry-id"</span>
<span class="token number">10</span><span class="token punctuation">)</span> <span class="token string">"0-0"</span>
<span class="token number">11</span><span class="token punctuation">)</span> <span class="token string">"entries-added"</span>
<span class="token number">12</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
<span class="token number">13</span><span class="token punctuation">)</span> <span class="token string">"groups"</span>
<span class="token number">14</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">15</span><span class="token punctuation">)</span> <span class="token string">"first-entry"</span>
<span class="token number">16</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1638125133432-0"</span>
    <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"message"</span>
       <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"apple"</span>
<span class="token number">17</span><span class="token punctuation">)</span> <span class="token string">"last-entry"</span>
<span class="token number">18</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"1638125141232-0"</span>
    <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"message"</span>
       <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"banana"</span>
</code></pre> 
<h3><a id="12Redis_bitfield_3280"></a>12、Redis 位域（bitfield）</h3> 
<p>了解即可。</p> 
<p>文档介绍：https://redis.io/docs/data-types/bitfields</p> 
<p>🅰️ 1、是什么</p> 
<p>Redis 位域允许设置、递增和获取任意位长度的整数值。例如，可以操作从无符号 1 位整数到有符号 63 位整数的任何值。</p> 
<p>这些值使用二进制编码的 Redis 字符串存储。位域支持原子读、写和增量操作，使它们成为管理计数器和类似数值的不错选择。</p> 
<p>BITFIELD 命令可以将一个 Redis 字符串看作是一个由二进制位组成的数组，并对这个数组中任意偏移进行访问 。 可以使用该命令对一个有符号的 5 位整型数的第 1234 位设置指定值，也可以对一个 31 位无符号整型数的第 4567 位进行取值。类似地，本命令可以对指定的整数进行自增和自减操作，可配置的上溢和下溢处理操作。</p> 
<p>BITFIELD 命今可以在一次调用中同时对多个位范围进行操作作：它接受一系列待执行的操作作为参数，并返回一个数组，数组中的每个元素就是对应操作的执行结果。</p> 
<p>🅰️ 2、能干嘛</p> 
<ul><li>位域修改</li><li>溢出控制</li></ul> 
<p>BITFIELD 命令的作用在于它能够将很多小的整数储存到一个长度较大的位图中，又或者将一个非常庞大的键分割为多个较小的键来进行储存，从而非常高效地使用内存，使得 Redis 能够得到更多不同的应用一特别是在实时分析领域 BITFIELD 能够以指定的方式对计算溢出进行控制的能力，使得它可以被应用于这一领域。</p> 
<p>大白话讲就是：</p> 
<p>将一个 Redis 字符串看作是一个由二进制位组成的数组。并能对变长位宽和任意没有字节对齐的指定整型位域进行寻址和修改。</p> 
<p>hello 等价于 01101000 01100101 01101100 01101100 01101111</p> 
<p>🅰️ 3、基本命令语法</p> 
<p>以原子方式设置、递增和读取一个或多个值。</p> 
<pre><code class="prism language-sh">BITFIELD key <span class="token punctuation">[</span>GET encoding offset <span class="token operator">|</span> <span class="token punctuation">[</span>OVERFLOW <span class="token operator">&lt;</span>WRAP <span class="token operator">|</span> SAT <span class="token operator">|</span> FAIL<span class="token operator">&gt;</span><span class="token punctuation">]</span>
  <span class="token operator">&lt;</span>SET encoding offset value <span class="token operator">|</span> INCRBY encoding offset increment<span class="token operator">&gt;</span>
  <span class="token punctuation">[</span>GET encoding offset <span class="token operator">|</span> <span class="token punctuation">[</span>OVERFLOW <span class="token operator">&lt;</span>WRAP <span class="token operator">|</span> SAT <span class="token operator">|</span> FAIL<span class="token operator">&gt;</span><span class="token punctuation">]</span>
  <span class="token operator">&lt;</span>SET encoding offset value <span class="token operator">|</span> INCRBY encoding offset increment<span class="token operator">&gt;</span>
  <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<ul><li><code>GET encoding offset</code> ：返回指定的位域；</li><li><code>SET encoding offset value</code> ：设置指定位域的值并返回它的原值；</li><li><code>INCRBY encoding offset increment</code> ：自增或自减（increment 为负数）指定位域的值并返回它的新值；</li><li><code>OVERFLOW &lt;WRAP | SAT | FAIL&gt;</code> ：设置溢出行为来改变调用 INCRBY 指令的后序操作；</li></ul> 
<p>当需要一个整型时，有符号整型需在位数前加 <code>i</code>，无符号在位数前加 <code>u</code>。例如，<code>u8</code> 是一个 8 位的无符号整型， <code>i16</code> 是一个 16 位的有符号整型。</p> 
<p>🅰️ 4、基本命令操作</p> 
<p>Ascii 码表：https://ascii.org.cn</p> 
<p>1）返回指定的位域：<code>GET encoding offset</code></p> 
<p>对照表：</p> 
<p><img src="https://images2.imgbox.com/07/98/j8skdiCJ_o.png" alt="在这里插入图片描述"></p> 
<p>hello 等价于 01101000 01100101 01101100 01101100 01101111</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> SET fieldkey hello
OK
<span class="token operator">&gt;</span> BITFIELD fieldkey GET i8 <span class="token number">0</span>
<span class="token number">104</span>
<span class="token operator">&gt;</span> BITFIELD fieldkey GET i8 <span class="token number">8</span>
<span class="token number">101</span>
<span class="token operator">&gt;</span> BITFIELD fieldkey GET i8 <span class="token number">16</span>
<span class="token number">108</span>
<span class="token operator">&gt;</span> BITFIELD fieldkey GET i8 <span class="token number">24</span>
<span class="token number">108</span>
<span class="token operator">&gt;</span> BITFIELD fieldkey GET i8 <span class="token number">32</span>
<span class="token number">111</span>
</code></pre> 
<p>BITFIELD 命令可以将一个 Redis 字符串看作是一个由二进制位组成的数组，并对这个数组中任意偏移进行访问 。可以使用该命令对一个有符号的 5 位整型数的第 1234 位设置指定值，也可以对一个 31 位无符号整型数的第 4567 位进行取值。类似地，本命令可以对指定的整数进行自增和自减操作，可配置的上溢和下溢处理操作。</p> 
<p>2）设置指定位域的值并返回它的原值：<code>SET encoding offset value</code></p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> SET fieldkey hello
OK
<span class="token operator">&gt;</span> BITFIELD fieldkey GET i8 <span class="token number">0</span>
<span class="token number">104</span>
<span class="token operator">&gt;</span> BITFIELD fieldkey GET i8 <span class="token number">8</span>
<span class="token number">101</span>
<span class="token operator">&gt;</span> BITFIELD fieldkey GET i8 <span class="token number">16</span>
<span class="token number">108</span>
<span class="token operator">&gt;</span> BITFIELD fieldkey GET i8 <span class="token number">24</span>
<span class="token number">108</span>
<span class="token operator">&gt;</span> BITFIELD fieldkey GET i8 <span class="token number">32</span>
<span class="token number">111</span>
<span class="token operator">&gt;</span> BITFIELD fieldkey SET i8 <span class="token number">8</span> <span class="token number">120</span>   <span class="token comment">#从第9个位开始，将接下来8个位用有符号数120(字母x)替换</span>
<span class="token number">101</span>
<span class="token operator">&gt;</span> GET fieldkey
hxllo
</code></pre> 
<p>3）自增或自减（increment 为负数）指定位域的值并返回它的新值：<code>INCRBY encoding offset increment</code></p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> SET fieldkey hello
OK
<span class="token operator">&gt;</span> BITFIELD fieldkey INCRBY u4 <span class="token number">2</span> <span class="token number">1</span>   <span class="token comment">#从第3个位开始，对接下来的4位无符号数+1</span>
<span class="token number">11</span>
<span class="token operator">&gt;</span> BITFIELD fieldkey INCRBY u4 <span class="token number">2</span> <span class="token number">1</span>
<span class="token number">12</span>
<span class="token operator">&gt;</span> BITFIELD fieldkey INCRBY u4 <span class="token number">2</span> <span class="token number">1</span>
<span class="token number">13</span>
<span class="token operator">&gt;</span> BITFIELD fieldkey INCRBY u4 <span class="token number">2</span> <span class="token number">1</span>
<span class="token number">14</span>
<span class="token operator">&gt;</span> BITFIELD fieldkey INCRBY u4 <span class="token number">2</span> <span class="token number">1</span>
<span class="token number">15</span>
<span class="token operator">&gt;</span> BITFIELD fieldkey INCRBY u4 <span class="token number">2</span> <span class="token number">1</span>   <span class="token comment">#默认overflow为wrap,即循环溢出</span>
<span class="token number">0</span>
</code></pre> 
<p>4）溢出控制 <code>OVERFLOW &lt;WRAP | SAT | FAIL&gt;</code></p> 
<p><code>WRAP</code> ：使用回绕（wrap around）方法处理有符号整数和无符号整数的溢出情况。</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> SET k1 a
OK
<span class="token operator">&gt;</span> BITFIELD k1 GET i8 <span class="token number">0</span>  <span class="token comment">#a对应的ascII码值97</span>
<span class="token number">97</span>
<span class="token operator">&gt;</span> BITFIELD k1 SET i8 <span class="token number">0</span> <span class="token number">128</span>  <span class="token comment">#i8表示有符号8位二进制，范围 (-128-127)</span>
<span class="token number">97</span>
<span class="token operator">&gt;</span> BITFIELD k1 GET i8 <span class="token number">0</span>  <span class="token comment">#默认overflow为wrap,即循环溢出</span>
<span class="token parameter variable">-128</span>
</code></pre> 
<p><code>SAT</code> ：使用饱和计算（saturation arithmetic）方法处理溢出，下溢计算的结果为最小的整数值，而上溢计算的结果为最大的整数值。</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> SET k1 a
OK
<span class="token operator">&gt;</span> BITFIELD k1 GET i8 <span class="token number">0</span>
<span class="token parameter variable">-128</span>
<span class="token operator">&gt;</span> BITFIELD k1 OVERFLOW SAT SET i8 <span class="token number">0</span> <span class="token number">128</span>
<span class="token parameter variable">-128</span>
<span class="token operator">&gt;</span> BITFIELD k1 GET i8 <span class="token number">0</span>  <span class="token comment">#上溢 最大的整数值</span>
<span class="token number">127</span>
</code></pre> 
<p><code>FAIL</code> ：命令将拒绝执行那些会导致上溢或者下溢情况出现的计算，并向用户返回空值表示计算未被执行。</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> BITFIELD k1 OVERFLOW FAIL SET i8 <span class="token number">0</span> <span class="token number">222</span>
null
</code></pre> 
<h2><a id="rainbow_Redis__3433"></a>🌈 Redis 持久化</h2> 
<h3><a id="01_3435"></a>01、总体介绍</h3> 
<p>官网介绍：https://redis.io/docs/management/persistence</p> 
<p>持久性是指将数据写入持久存储，如固态磁盘（SSD）。Redis 提供了一系列持久性选项。其中包括：</p> 
<ul><li><code>RDB</code>（Redis Database）：RDB 持久性以指定的时间间隔执行数据集的时间点快照。</li><li><code>AOF</code>（Append Only File）：AOF 持久性记录服务器接收到的每个写入操作。然后可以在服务器启动时再次回放这些操作，重建原始数据集。使用与 Redis 协议本身相同的格式记录命令。</li><li>无持久性（No persistence）：可以完全禁用持久性。在纯缓存时使用。</li><li>RDB + AOF：也可以在同一实例中组合使用 AOF 和 RDB。</li></ul> 
<p><img src="https://images2.imgbox.com/32/91/7axnSLNu_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="02_RDBRedis_Database_3449"></a>02、持久化 RDB（Redis Database）</h3> 
<p>🅰️ 1、是什么</p> 
<p>RDB（Redis 数据库）：RDB 持久性以指定的时间间隔执行数据集的时间点快照。</p> 
<p>把某一时刻的数据和状态以文件的形式写到磁盘上，也就是快照。这样一来即使故障宕机，快照文件也不会丢失，数据的可靠性也就得到了保证。这个快照文件就称为 RDB 文件（dump.rdb）。RDB 就是 Redis DataBase 的缩写。</p> 
<p>🅰️ 2、能干嘛</p> 
<p>在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是 Snapshot 内存快照，它恢复时再将硬盘快照文件直接读回到内存里。</p> 
<p>Redis 的数据都在内存中，保存备份时它执行的是<code>全量快照</code>，也就是说，把内存中的所有数据都记录到磁盘中。</p> 
<p>RDB 保存的是 <code>dump.rdb</code> 文件。</p> 
<h4><a id="1RDB__3465"></a>1、RDB 使用案例</h4> 
<p>文档说明：https://redis.io/docs/management/persistence/#snapshotting</p> 
<p>工作原理：https://redis.io/docs/management/persistence/#how-it-works</p> 
<p>默认情况下，Redis 将数据集的快照保存在磁盘上，保存在一个名为 <code>dump.rdb</code> 的二进制文件中。如果数据集中至少有 M 个更改，可以配置 Redis，使其每隔 N 秒保存一次数据集，也可以手动调用 <code>SAVE</code> 或 <code>BGSAVE</code> 命令。</p> 
<p>🅱️ 1、配置文件的改变</p> 
<p>自动触发。</p> 
<p>1）Redis 6.2 之前的版本</p> 
<p>在 <code>redis.conf</code> 配置文件中的 <code>SNAPSHOTTING</code> 下配置 <code>save</code> 参数，来触发 Redis 的 RDB 持久化条件，比如 <code>save m n</code> ：表示 m 秒内数据集存在 n 次修改时，自动触发 <code>bgsave</code>。</p> 
<ul><li>save 900 1 ：每隔 900s (15min)，如果有超过 1 个 key 发生了变化，就写一份新的 RDB 文件；</li><li>save 300 10 ：每隔 300s (5min)，如果有超过 10 个 key 发生了变化，就写一份新的 RDB 文件；</li><li>save 60 10000 ：每隔 60s (1min)，如果有超过 10000 个 key 发生了变化，就写一份新的 RDB 文件；</li></ul> 
<pre><code class="prism language-properties">################################ SNAPSHOTTING  ################################
#
# Save the DB on disk:
#
#   save &lt;seconds&gt; &lt;changes&gt;
#
#   Will save the DB if both the given number of seconds and the given
#   number of write operations against the DB occurred.
#
#   In the example below the behaviour will be to save:
#   after 900 sec (15 min) if at least 1 key changed
#   after 300 sec (5 min) if at least 10 keys changed
#   after 60 sec if at least 10000 keys changed
#
#   Note: you can disable saving completely by commenting out all "save" lines.
#
#   It is also possible to remove all the previously configured save
#   points by adding a save directive with a single empty string argument
#   like in the following example:
#
#   save ""

save 900 1
save 300 10
save 60 10000
</code></pre> 
<p>2）Redis 6.2 以及 Redis 7.0 之后的版本</p> 
<pre><code class="prism language-properties">################################ SNAPSHOTTING  ################################

# Save the DB to disk.
#
# save &lt;seconds&gt; &lt;changes&gt; [&lt;seconds&gt; &lt;changes&gt; ...]
#
# Redis will save the DB if the given number of seconds elapsed and it
# surpassed the given number of write operations against the DB.
#
# Snapshotting can be completely disabled with a single empty string argument
# as in following example:
#
# save ""
#
# Unless specified otherwise, by default Redis will save the DB:
#   * After 3600 seconds (an hour) if at least 1 change was performed
#   * After 300 seconds (5 minutes) if at least 100 changes were performed
#   * After 60 seconds if at least 10000 changes were performed
#
# You can set these explicitly by uncommenting the following line.
#
save 3600 1 300 100 60 10000
</code></pre> 
<p>🅱️ ​2、自动触发演示</p> 
<p>1）修改默认配置</p> 
<p>Redis 7.0 版本，按照 <code>redis.conf</code> 里配置的规则：</p> 
<pre><code class="prism language-properties">save &lt;seconds&gt; &lt;changes&gt; [&lt;seconds&gt; &lt;changes&gt; ...]
</code></pre> 
<p>本次案例配置为 5 秒 2 次修改：</p> 
<pre><code class="prism language-properties">save 5 2
</code></pre> 
<p>2）修改 dump 文件保存路径</p> 
<p>默认：</p> 
<pre><code class="prism language-properties"># The filename where to dump the DB
dbfilename dump.rdb

# The working directory.
#
# The DB will be written inside this directory, with the filename specified
# above using the 'dbfilename' configuration directive.
#
# The Append Only File will also be created inside this directory.
#
# Note that you must specify a directory here, not a file name.
dir ./
</code></pre> 
<p>自定义修改的路径：</p> 
<pre><code class="prism language-properties">dir ./db
</code></pre> 
<p>可以进入 Redis 里用 <code>CONFIG GET dir</code> 获取已配置的路径：</p> 
<pre><code class="prism language-sh">CONFIG GET <span class="token function">dir</span>
</code></pre> 
<p>3）修改 dump 文件名称：</p> 
<pre><code class="prism language-properties"># The filename where to dump the DB
dbfilename dump6379.rdb
</code></pre> 
<p>4）触发备份。当 5 秒 2 次修改时触发</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> SET K1 V1
OK
<span class="token operator">&gt;</span> SET K2 V2
OK
</code></pre> 
<p>路径 db 文件下，生成文件：<code>dump6379.rdb</code></p> 
<p>5）如何恢复</p> 
<p>🌵 物理恢复，服务和备份分机隔离</p> 
<p>将备份文件 dump.rdb 移动到 Redis 安装目录并启动服务即可。</p> 
<p>将 dump6379_bak.rdb 备份文件修改为 dump6379.rdb，启动 Redis 服务：</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> KEYS *
K2
K1
</code></pre> 
<blockquote> 
 <p>不可以把备份文件 dump.rdb 和生产 Redis 服务器放在同一台机器，必须分开各自存储，以防生产机物理损坏后备份文件也挂了。</p> 
</blockquote> 
<p>❌ 备份成功后故意用命令 <code>flushdb</code> 清空 Redis，看看是否可以恢复数据？不能！！！</p> 
<p>将 dump6379.rdb 备份成 dump6379_bak.rdb，然后 flushdb 执行后会默认自动生成 rdb 文件。</p> 
<blockquote> 
 <p>执行 <code>flushall</code> / <code>flushdb</code> 命令也会产生 dump.rdb 文件，但里面是空的，无数据。</p> 
</blockquote> 
<p>🅱️ 3、手动触发演示</p> 
<p>Redis 提供了两个命令来手动⽣成 RDB ⽂件，分别是 <code>SAVE</code> 和 <code>BGSAVE</code> 命令。</p> 
<p>1）命令 <code>SAVE</code></p> 
<p>文档介绍：https://redis.io/commands/save</p> 
<p>在主程序中执⾏会 <code>阻塞</code> 当前 Redis 服务器，直到持久化工作完成执行 <code>save</code> 命令期间，Redis 不能处理其他命令，<code>线上禁止使用</code>。</p> 
<p><img src="https://images2.imgbox.com/cc/85/4OwBkPdH_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> SAVE
OK
</code></pre> 
<p>2）命令 <code>BGSAVE</code>（默认）</p> 
<p>文档介绍：https://redis.io/commands/bgsave</p> 
<p>语法：</p> 
<pre><code class="prism language-sh">BGSAVE <span class="token punctuation">[</span>SCHEDULE<span class="token punctuation">]</span>
</code></pre> 
<p>Redis 会在后台异步进行快照操作，<code>不阻塞</code> ，快照同时还可以响应客户端请求，该触发方式会 fork 一个子进程由子进程复制持久化过程。</p> 
<p>执行 BGSAVE，正常情况下，会立即返回 OK。Redis forks ，父进程继续为客户端提供服务，子进程将数据保存在磁盘上，然后退出。</p> 
<p>如果已经有后台保存在运行，或者有另一个非后台保存进程在运行，特别是正在进行的 AOF 重写，则会返回错误。</p> 
<p>如果使用 BGSAVE SCHEDULE，则当 AOF 重写正在进行时，该命令将立即返回 OK，并计划在下一次机会运行后台保存。</p> 
<p>客户端可以使用 LASTSAVE 命令来检查操作是否成功。</p> 
<p>返回值：</p> 
<p>如果 BGSAVE 启动正确，则启动后台保存，或者与 SCHEDULE 子命令一起使用时安排后台保存。</p> 
<blockquote> 
 <p>在 Linux 程序中，fork() 会产生一个和父进程完全相同的子进程，但子进程在此后多会 exec 系统调用，出于效率考虑，尽量避免膨胀。</p> 
</blockquote> 
<p>Redis 会使用 BGSAVE 对当前内存中的所有数据做快照，这个操作是子进程在后台完成的，这就允许主进程同时可以修改数据。</p> 
<p><img src="https://images2.imgbox.com/c8/14/hrNX5B5U_o.png" alt="在这里插入图片描述"></p> 
<pre><code>&gt; BGSAVE
Background saving started
</code></pre> 
<p>3）命令 <code>LASTSAVE</code></p> 
<p>可以通过 LASTSAVE 命令获取最后一次成功执行快照的时间。</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> LASTSAVE
<span class="token number">1678960442</span>
</code></pre> 
<p>Linux 查看：</p> 
<pre><code class="prism language-sh"><span class="token function">date</span> <span class="token parameter variable">-d</span> @1678960442
</code></pre> 
<h4><a id="2RDB__3696"></a>2、RDB 优缺点</h4> 
<p>🅱️ 1、优点</p> 
<p>文档介绍：https://redis.io/docs/management/persistence/#rdb-advantages</p> 
<ul><li>RDB 是 Redis 数据的一个非常紧凑的单文件时间点表示。RDB 文件非常适合备份。例如，可能在最近的 24 小时内每小时归档一次 RDB 文件，并在 30 天内每天保存一个 RDB 快照。这可以在发生灾难时轻松恢复不同版本的数据集。</li><li>RDB 非常适合灾难恢复，它是一个可以传输到远程数据中心或 Amazon S3（可能已加密）的压缩文件。</li><li>RDB 最大限度地提高了 Redis 的性能，因为 Redis 父进程为了持久化而需要做的唯一工作就是派生一个将完成所有其余工作的子进程。父进程永远不会执行磁盘 I/O 或类似操作。</li><li>与 AOF 相比，RDB 允许使用大数据集更快地重启。</li><li>在副本上，RDB 支持重启和故障转移后的部分重新同步。</li></ul> 
<p>总结：</p> 
<ol><li>适合大规模的数据恢复；</li><li>按照业务定时备份；</li><li>对数据完整性和一致性要求不高； ⭕️</li><li>RDB 文件在内存中的加载速度要比 AOF 快得多。</li></ol> 
<p>🅱️ 2、缺点</p> 
<p>文档介绍：https://redis.io/docs/management/persistence/#rdb-disadvantages</p> 
<ul><li>如果需要在 Redis 停止工作时（例如断电后）将数据丢失的可能性降到最低，那么 RDB 并不好。您可以配置生成 RDB 的不同保存点（例如，在对数据集至少 5 分钟和 100 次写入之后，可以有多个保存点）。但是，通常会每五分钟或更长时间创建一次 RDB 快照，因此，如果 Redis 由于任何原因在没有正确关闭的情况下停止工作，您应该准备好丢失最新分钟的数据。</li><li>RDB 需要经常 <code>fork()</code> 以便使用子进程在磁盘上持久化。如果数据集很大，<code>fork()</code>可能会很耗时，并且如果数据集很大并且 CPU 性能不是很好，可能会导致 Redis 停止为客户端服务几毫秒甚至一秒钟。AOF 也需要 <code>fork()</code> 但频率较低，您可以调整要<code>重写日志</code>的频率，而不需要对持久性进行任何权衡。</li></ul> 
<p>总结：</p> 
<ol><li>在一定间隔时间做一次备份，所以如果 Redis 意外 down 掉的话，就会丢失从当前至最近一次快照期间的数据，快照之间的数据会丢失；</li><li>内存数据的全量同步，如果数据量太大会导致 I/O 严重影响服务器性能；</li><li>RDB 依赖于主进程的 fork，在更大的数据集中，这可能会导致服务请求的瞬间延迟。fork 的时候内存中的数据被克隆了一份，大致 2 倍的膨胀性。</li></ol> 
<p>🅱️ 3、数据丢失案例</p> 
<p>Redis 意外宕机将丢失从当前至最近一次快照期间的数据。</p> 
<pre><code class="prism language-sh"><span class="token comment"># 正常录入数据</span>
<span class="token operator">&gt;</span> SET K1 V2
OK
<span class="token operator">&gt;</span> SET K2 V2
OK
<span class="token comment"># 此时满足 5秒修改2次 生成 dump 文件</span>
<span class="token operator">&gt;</span> SET K3 V3  
OK
<span class="token comment"># 服务出故障（kill -9 故意模拟意外 down 机）</span>

<span class="token comment"># Redis 重启恢复，查看数据</span>
<span class="token operator">&gt;</span> KEYS *
K2
K1
<span class="token comment"># 数据K3丢失了，证明RDB数据丢失缺点</span>
</code></pre> 
<p>🅰️ 3、如何检查修复 dump.rdb 文件</p> 
<p>如何检查修复损坏的 dump.rdb 文件呢？</p> 
<p>当服务出故障造成 dump.rdb 文件数据不完整，可以使用 Redis 自带的 <code>redis-check-rdb</code> 工具进行修复。</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span>redis-check-rdb dumpfile/dump6379.rdb
<span class="token punctuation">[</span>offset <span class="token number">0</span><span class="token punctuation">]</span> Checking RDB <span class="token function">file</span> dumpfile/dump6379.rdb
<span class="token punctuation">[</span>offset <span class="token number">27</span><span class="token punctuation">]</span> AUX FIELD redis-ver <span class="token operator">=</span> <span class="token string">'7.0.9'</span>
<span class="token punctuation">[</span>offset <span class="token number">41</span><span class="token punctuation">]</span> AUX FIELD redis-bits <span class="token operator">=</span> <span class="token string">'64'</span>
<span class="token punctuation">[</span>offset <span class="token number">53</span><span class="token punctuation">]</span> AUX FIELD ctime <span class="token operator">=</span> <span class="token string">'1679033301'</span>
<span class="token punctuation">[</span>offset <span class="token number">65</span><span class="token punctuation">]</span> AUX FIELD used-mem <span class="token operator">=</span> <span class="token string">'0'</span>
<span class="token punctuation">[</span>offset <span class="token number">81</span><span class="token punctuation">]</span> AUX FIELD aof-preamble <span class="token operator">=</span> <span class="token string">'0'</span>
<span class="token punctuation">[</span>offset <span class="token number">83</span><span class="token punctuation">]</span> Selecting DB ID <span class="token number">0</span>
<span class="token punctuation">[</span>offset <span class="token number">109</span><span class="token punctuation">]</span> Checksum OK
<span class="token punctuation">[</span>offset <span class="token number">109</span><span class="token punctuation">]</span> <span class="token punctuation">\</span>o/ RDB looks OK<span class="token operator">!</span> <span class="token punctuation">\</span>o/
<span class="token punctuation">[</span>info<span class="token punctuation">]</span> <span class="token number">2</span> keys <span class="token builtin class-name">read</span>
<span class="token punctuation">[</span>info<span class="token punctuation">]</span> <span class="token number">0</span> expires
<span class="token punctuation">[</span>info<span class="token punctuation">]</span> <span class="token number">0</span> already expired
<span class="token operator">&gt;</span>
</code></pre> 
<p>🅰️ 4、哪些情况会触发 RDB 快照</p> 
<ul><li>配置文件中默认的快照配置；</li><li>手动 <code>SAVE</code> 、 <code>BGSAVE</code> 命令；</li><li>执行 <code>FLUSHALL</code> 、 <code>FLUSHDB</code> 命令也会产生 dump.rdb 文件，但数据是空的；</li><li>执行 <code>SHUTDOWN</code> 且没有设置开启 AOF 持久化；</li><li>主从复制时，主节点自动触发；</li></ul> 
<p>🅰️ 5、如何禁用快照</p> 
<p>1）动态所有停止 RDB 保存规则的方法，执行命令：</p> 
<pre><code class="prism language-sh">redis-cli config <span class="token builtin class-name">set</span> save <span class="token string">""</span>
</code></pre> 
<p>2）配置文件快照禁用：</p> 
<pre><code class="prism language-properties"># Snapshotting can be completely disabled with a single empty string argument
# as in following example:
#
save ""
</code></pre> 
<h4><a id="3RDB__3798"></a>3、RDB 优化配置项详解</h4> 
<p>配置文件 SNAPSHOTTING 模块：</p> 
<p>🅱️ 1、​保存数据到磁盘</p> 
<pre><code class="prism language-properties">################################ SNAPSHOTTING  ################################

# Save the DB to disk.
#
# save &lt;seconds&gt; &lt;changes&gt; [&lt;seconds&gt; &lt;changes&gt; ...]
#
# Redis will save the DB if the given number of seconds elapsed and it
# surpassed the given number of write operations against the DB.
#
# Snapshotting can be completely disabled with a single empty string argument
# as in following example:
#
# save ""
#
# Unless specified otherwise, by default Redis will save the DB:
#   * After 3600 seconds (an hour) if at least 1 change was performed
#   * After 300 seconds (5 minutes) if at least 100 changes were performed
#   * After 60 seconds if at least 10000 changes were performed
#
# You can set these explicitly by uncommenting the following line.
#
save 3600 1 300 100 60 10000
</code></pre> 
<p>🅱️ 2、后台保存出错时停止继续写入</p> 
<p>默认 yes。如果配置成 no，表示不在乎数据不一致或者有其他的手段发现和控制这种不一致，那么在快照写入失败时，也能确保 Redis 继续接受新的写请求。</p> 
<pre><code class="prism language-properties"># By default Redis will stop accepting writes if RDB snapshots are enabled
# (at least one save point) and the latest background save failed.
# This will make the user aware (in a hard way) that data is not persisting
# on disk properly, otherwise chances are that no one will notice and some
# disaster will happen.
#
# If the background saving process will start working again Redis will
# automatically allow writes again.
#
# However if you have setup your proper monitoring of the Redis server
# and persistence, you may want to disable this feature so that Redis will
# continue to work as usual even if there are problems with disk,
# permissions, and so forth.
stop-writes-on-bgsave-error yes
</code></pre> 
<p>🅱️ 3、是否压缩 RDB 文件</p> 
<p>默认 yes。对于存储到磁盘中的快照，可以设置是否进行压缩存储。如果是的话，Redis 会采用 LZF 算法进行压缩。如果你不想消耗 CPU 来进行压缩的话，可以设置为关闭此功能。</p> 
<pre><code class="prism language-properties"># Compress string objects using LZF when dump .rdb databases?
# By default compression is enabled as it's almost always a win.
# If you want to save some CPU in the saving child set it to 'no' but
# the dataset will likely be bigger if you have compressible values or keys.
rdbcompression yes
</code></pre> 
<p>🅱️ 4、RDB 文件合法性的校验</p> 
<p>默认 yes。在存储快照后，还可以让 Redis 使用 CRC64 算法来进行数据校验，但是这样做会增加大约 10% 的性能消耗，如果希望获取到最大的性能提升，可以关闭此功能。</p> 
<pre><code class="prism language-properties"># Since version 5 of RDB a CRC64 checksum is placed at the end of the file.
# This makes the format more resistant to corruption but there is a performance
# hit to pay (around 10%) when saving and loading RDB files, so you can disable it
# for maximum performances.
#
# RDB files created with checksum disabled have a checksum of zero that will
# tell the loading code to skip the check.
rdbchecksum yes
</code></pre> 
<p>🅱️ 5、RDB 文件名</p> 
<pre><code class="prism language-properties"># The filename where to dump the DB
dbfilename dump.rdb
</code></pre> 
<p>🅱️ 6、是否删除主从复制时产生 RDB 文件</p> 
<p>在没有持久性的情况下删除复制中使用的 RDB 文件启用。默认情况下 no，此选项是禁用的。</p> 
<pre><code class="prism language-properties"># Remove RDB files used by replication in instances without persistence
# enabled. By default this option is disabled, however there are environments
# where for regulations or other security concerns, RDB files persisted on
# disk by masters in order to feed replicas, or stored on disk by replicas
# in order to load them for the initial synchronization, should be deleted
# ASAP. Note that this option ONLY WORKS in instances that have both AOF
# and RDB persistence disabled, otherwise is completely ignored.
#
# An alternative (and sometimes better) way to obtain the same effect is
# to use diskless replication on both master and replicas instances. However
# in the case of replicas, diskless is not always an option.
rdb-del-sync-files no
</code></pre> 
<p>🅱️ 7、工作目录</p> 
<p>RDB 文件的写入目录。AOF 文件也使用此目录。此目录必须是存在的。</p> 
<pre><code class="prism language-properties"># The working directory.
#
# The DB will be written inside this directory, with the filename specified
# above using the 'dbfilename' configuration directive.
#
# The Append Only File will also be created inside this directory.
#
# Note that you must specify a directory here, not a file name.
dir ./
</code></pre> 
<h3><a id="03_AOFAppend_Only_File_3919"></a>03、持久化 AOF（Append Only File）</h3> 
<p>文档介绍：https://redis.io/docs/management/persistence</p> 
<p>🅰️ 1、是什么</p> 
<p>Redis <code>以日志的形式来记录每个写操作</code>，将 Redis 执行过的所有写指令记录下来（读操作不记录），只许追加文件但不可以改写文件，Redis 启动之初会读取该文件重新构建数据，换言之，Redis 重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。</p> 
<p>默认情况下，Redis 是没有开启 AOF 的。开启 AOF 功能需要设置配置：<code>appendonly yes</code> 。</p> 
<p>AOF 保存的是 <code>appendonly.aof</code> 文件。</p> 
<p>🅰️ 2、能干嘛</p> 
<p>文档介绍：https://redis.io/docs/management/persistence/#append-only-file</p> 
<p>RDB 模式不是完美的。如果运行 Redis 的计算机停止运行，电源线故障，或者不小心 kill -9 关闭实例，那么写入 Redis 的最新数据将丢失。虽然这对某些应用程序来说可以接受，但对于需要完全持久性的应用，这些情况，单独使用 Redis 快照是不可行的。</p> 
<p>AOF 是 Redis 的一种替代、完全持久的策略。它在 1.1 版中提供。</p> 
<p>开启 AOF，每当 Redis 收到更改数据集的命令（例如 SET）时，它都会将其附加到 AOF 中。当重新启动 Redis 时，它将重新读取 AOF 中命令以重建数据。</p> 
<p>自 Redis 7.0.0，Redis 使用了多部分 AOF 机制。也就是说，原始的单个 AOF 文件被拆分为<code>基本文件</code>（最多一个）和<code>增量文件</code>（可能有多个）。基本文件表示重写 AOF 时存在的数据的初始快照（RDB 或 AOF 格式）。增量文件包含自上一个基本 AOF 文件创建以来的增量更改。所有这些文件都放在一个单独的目录中，并由<code>清单文件</code>跟踪。</p> 
<p>🅰️ 3、AOF 持久化工作流程</p> 
<p><img src="https://images2.imgbox.com/c2/48/jsPJeO8f_o.png" alt="在这里插入图片描述"></p> 
<ol><li>Client 作为命令的来源，会有多个源头以及源源不断的请求命令。</li><li>在这些命令到达 Redis Server 以后并不是直接写入 AOF 文件，会将这些命令先放入 AOF 缓存区中进行保存。这里的 AOF 缓冲区实际上是内存中的一片区域，存在的目的是当这些命令达到一定量以后再写入磁盘，避免频繁的磁盘 IO 操作。</li><li>AOF 缓冲会根据 AOF 缓冲区 <code>同步文件的三种写回策略</code>，将命令写入磁盘上的 AOF 文件。</li><li>随着写入 AOF 内容的增加为避免文件膨胀，会根据规则进行命令的合并（又称 <code>AOF 重写</code>），从而起到 AOF 文件压缩的目的。</li><li>当 Redis Server 服务器重启的时候会从 AOF 文件加载数据。</li></ol> 
<p>🅰️ 4、AOF 缓冲区三种写回策略</p> 
<p>文档介绍：https://redis.io/docs/management/persistence/#how-durable-is-the-append-only-file</p> 
<p>配置文件 <code>redis.conf</code> 在 APPEND ONLY MODE 模块：</p> 
<pre><code class="prism language-properties"># The fsync() call tells the Operating System to actually write data on disk
# instead of waiting for more data in the output buffer. Some OS will really flush
# data on disk, some other OS will just try to do it ASAP.
#
# Redis supports three different modes:
#
# no: don't fsync, just let the OS flush the data when it wants. Faster.
# always: fsync after every write to the append only log. Slow, Safest.
# everysec: fsync only one time every second. Compromise.
#
# The default is "everysec", as that's usually the right compromise between
# speed and data safety. It's up to you to understand if you can relax this to
# "no" that will let the operating system flush the output buffer when
# it wants, for better performances (but if you can live with the idea of
# some data loss consider the default persistence mode that's snapshotting),
# or on the contrary, use "always" that's very slow but a bit safer than
# everysec.
#
# More details please check the following article:
# http://antirez.com/post/redis-persistence-demystified.html
#
# If unsure, use "everysec".

# appendfsync always
appendfsync everysec
# appendfsync no
</code></pre> 
<ul><li><code>always</code> ：同步写回，每个写命令执行完立刻同步地将日志写回磁盘；</li><li><code>everysec</code> ：每秒写回，每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔 1 秒把缓冲区中的内容写入磁盘；</li><li><code>no</code> ：操作系统控制的写回，每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</li></ul> 
<table><thead><tr><th></th><th>写回机制</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>always</td><td>同步写回</td><td>可靠性高，基本不丢失数据</td><td>每个写命令都要落盘，性能影响较大</td></tr><tr><td>everysec</td><td>每秒写回</td><td>性能中</td><td>宕机时丢失 1 秒内的数据</td></tr><tr><td>no</td><td>操作系统控制的写回</td><td>性能高</td><td>宕机时丢失数据较多</td></tr></tbody></table> 
<h4><a id="1AOF__3999"></a>1、AOF 启动/恢复/修复</h4> 
<p>🅱️ 1、配置文件说明（6 VS 7）</p> 
<p>1）开启 AOF</p> 
<p>默认是 no 关闭，设置为 yes 就标识开启 AOF 持久化支持。</p> 
<pre><code class="prism language-properties">############################## APPEND ONLY MODE ###############################

# By default Redis asynchronously dumps the dataset on disk. This mode is
# good enough in many applications, but an issue with the Redis process or
# a power outage may result into a few minutes of writes lost (depending on
# the configured save points).
#
# The Append Only File is an alternative persistence mode that provides
# much better durability. For instance using the default data fsync policy
# (see later in the config file) Redis can lose just one second of writes in a
# dramatic event like a server power outage, or a single write if something
# wrong with the Redis process itself happens, but the operating system is
# still running correctly.
#
# AOF and RDB persistence can be enabled at the same time without problems.
# If the AOF is enabled on startup Redis will load the AOF, that is the file
# with the better durability guarantees.
#
# Please check http://redis.io/topics/persistence for more information.

appendonly yes
</code></pre> 
<p>2）使用默认写回策略，每秒钟</p> 
<pre><code class="prism language-properties"># The fsync() call tells the Operating System to actually write data on disk
# instead of waiting for more data in the output buffer. Some OS will really flush
# data on disk, some other OS will just try to do it ASAP.
#
# Redis supports three different modes:
#
# no: don't fsync, just let the OS flush the data when it wants. Faster.
# always: fsync after every write to the append only log. Slow, Safest.
# everysec: fsync only one time every second. Compromise.
#
# The default is "everysec", as that's usually the right compromise between
# speed and data safety. It's up to you to understand if you can relax this to
# "no" that will let the operating system flush the output buffer when
# it wants, for better performances (but if you can live with the idea of
# some data loss consider the default persistence mode that's snapshotting),
# or on the contrary, use "always" that's very slow but a bit safer than
# everysec.
#
# More details please check the following article:
# http://antirez.com/post/redis-persistence-demystified.html
#
# If unsure, use "everysec".

# appendfsync always
appendfsync everysec
# appendfsync no
</code></pre> 
<p>3）AOF 文件的保存路径</p> 
<ul><li>Redis 6 版本</li></ul> 
<p>AOF 保存文件的位置和 RDB 保存文件的位置一样，都是通过 redis.conf 配置文件的 <code>dir</code> 配置项。</p> 
<ul><li>Redis 7 版本</li></ul> 
<p>新增 appenddirname 配置项。</p> 
<pre><code class="prism language-properties"># For convenience, Redis stores all persistent append-only files in a dedicated
# directory. The name of the directory is determined by the appenddirname
# configuration parameter.

appenddirname "appendonlydir"
</code></pre> 
<p>最终 AOF 保存的路径为：<code>dir + appenddirname</code></p> 
<p>4）AOF 文件的保存名称</p> 
<ul><li>Redis 6 版本</li></ul> 
<p>有且仅有一个 AOF 文件</p> 
<pre><code class="prism language-properties"># The name of the append only file (default: "appendonly.aof")
appendfilename "appendonly.aof"
</code></pre> 
<ul><li>Redis 7 版本</li></ul> 
<p>Redis7.0 Multi Part AOF 的设计，官网说明：https://redis.io/docs/management/persistence/#append-only-file</p> 
<pre><code class="prism language-properties"># The base name of the append only file.
#
# Redis 7 and newer use a set of append-only files to persist the dataset
# and changes applied to it. There are two basic types of files in use:
#
# - Base files, which are a snapshot representing the complete state of the
#   dataset at the time the file was created. Base files can be either in
#   the form of RDB (binary serialized) or AOF (textual commands).
# - Incremental files, which contain additional commands that were applied
#   to the dataset following the previous file.
#
# In addition, manifest files are used to track the files and the order in
# which they were created and should be applied.
#
# Append-only file names are created by Redis following a specific pattern.
# The file name's prefix is based on the 'appendfilename' configuration
# parameter, followed by additional information about the sequence and type.
#
# For example, if appendfilename is set to appendonly.aof, the following file
# names could be derived:
#
# - appendonly.aof.1.base.rdb as a base file.
# - appendonly.aof.1.incr.aof, appendonly.aof.2.incr.aof as incremental files.
# - appendonly.aof.manifest as a manifest file.

appendfilename "appendonly.aof"
</code></pre> 
<ul><li> <p>base ：表示基础 AOF，它一般由子进程通过重写产生，该文件最多只有一个。<code>基本文件</code></p> </li><li> <p>incr ：表示增量 AOF，它一般会在 AOFRW 开始执行时被创建，该文件可能存在多个。<code>增量文件</code></p> </li><li> <p>HISTORY ：表示历史 AOF，它由 BASE和 INCR AOF 变化而来，每次 AOFRW 成功完成时，本次 AOFRW 之前对应的 BASE 和 INCR AOF 都将变为 HISTORY，HISTORY 类型的 AOF 会被 Redis <code>自动删除</code>。</p> </li><li> <p>manifest ：为了管理这些 AOF 文件，引入了一个 manifest （清单）文件来跟踪、管理这些 AOF。同时，为了便于 AOF 备份和拷贝，将所有的 AOF 文件和 manifest 文件放入一个单独的文件目录中，目录名由 appenddirname 配置。<code>清单文件</code></p> </li></ul> 
<p>🅱️ 2、正常恢复</p> 
<p>正常写操作，可以见到生成 AOF 文件到指定的目录（appendonlydir）：</p> 
<pre><code class="prism language-properties">appendonly.aof.1.base.rdb
appendonly.aof.1.incr.aof
appendonly.aof.manifest
</code></pre> 
<p>1）示例：写入数据，重启 Redis 然后重新加载。</p> 
<p>写入数据，关闭 Redis：</p> 
<pre><code class="prism language-sh">* Server initialized
* Creating AOF base <span class="token function">file</span> appendonly.aof.1.base.rdb on server start
* Creating AOF incr <span class="token function">file</span> appendonly.aof.1.incr.aof on server start
* Ready to accept connections tcp
* User requested shutdown<span class="token punctuation">..</span>.
<span class="token comment"># There is a child rewriting the AOF. Killing it!</span>
* Calling fsync<span class="token punctuation">(</span><span class="token punctuation">)</span> on the AOF file.
* Saving the final RDB snapshot before exiting.
* DB saved on disk
* Removing the pid file.
<span class="token comment"># Redis is now ready to exit, bye bye...</span>
</code></pre> 
<p>重新启动 Redis：</p> 
<pre><code class="prism language-sh">* Server initialized
* Reading RDB base <span class="token function">file</span> on AOF loading<span class="token punctuation">..</span>.
* Loading RDB produced by version <span class="token number">7.0</span>.9
* RDB age <span class="token number">321</span> seconds
* RDB memory usage when created <span class="token number">0.44</span> Mb
* RDB is base AOF
* Done loading RDB, keys loaded: <span class="token number">0</span>, keys expired: <span class="token number">0</span>.
* DB loaded from base <span class="token function">file</span> appendonly.aof.1.base.rdb: <span class="token number">0.001</span> seconds
* DB loaded from incr <span class="token function">file</span> appendonly.aof.1.incr.aof: <span class="token number">0.000</span> seconds
* DB loaded from append only file: <span class="token number">0.001</span> seconds
* Opening AOF incr <span class="token function">file</span> appendonly.aof.1.incr.aof on server start
* Ready to accept connections tcp
</code></pre> 
<p>成功从 AOF 文件恢复数据：</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> KEYS *
K1
</code></pre> 
<p>🅱️ 3、异常恢复</p> 
<p>1）故意在正常的 AOF 文件追加写入一些数据，模拟网络闪断，AOF 文件写入出错：</p> 
<pre><code class="prism language-sh"><span class="token function">vim</span> /myredis/appendonlydir/appendonly.aof.1.incr.aof
</code></pre> 
<p>2）重启 Redis ，就会进行 AOF 文件的载入，但是此时发现 Redis 启动失败</p> 
<pre><code class="prism language-sh"><span class="token comment"># Bad file format reading the append only file appendonly.aof.3.incr.aof: make a backup of your AOF file, then use ./redis-check-aof --fix &lt;filename.manifest&gt;</span>
</code></pre> 
<p>3）AOF 文件异常修复命令：<code>redis-check-aof --fix</code> 进行修复</p> 
<pre><code class="prism language-sh">redis-check-aof <span class="token parameter variable">--fix</span> /myredis/appendonlydir/appendonly.aof.1.incr.aof
</code></pre> 
<pre><code class="prism language-sh">Start checking Old-Style AOF
AOF /myredis/appendonlydir/appendonly.aof.1.incr.aof <span class="token function">format</span> error
AOF analyzed: <span class="token assign-left variable">filename</span><span class="token operator">=</span>/myredis/appendonlydir/appendonly.aof.1.incr.aof, <span class="token assign-left variable">size</span><span class="token operator">=</span><span class="token number">93550</span>, <span class="token assign-left variable">ok_up_to</span><span class="token operator">=</span><span class="token number">93530</span>, <span class="token assign-left variable">ok_up_to_line</span><span class="token operator">=</span><span class="token number">1566</span>, <span class="token assign-left variable">diff</span><span class="token operator">=</span><span class="token number">20</span>
This will shrink the AOF /myredis/appendonlydir/appendonly.aof.1.incr.aof from <span class="token number">93550</span> bytes, with <span class="token number">20</span> bytes, to <span class="token number">93530</span> bytes
Continue? <span class="token punctuation">[</span>y/N<span class="token punctuation">]</span>: y
Successfully truncated AOF /myredis/appendonlydir/appendonly.aof.1.incr.aof
</code></pre> 
<p>4）重启 Redis 正常，数据也正常</p> 
<p>🅰️ 5、AOF 的优缺点</p> 
<p>1）优点</p> 
<p>文档介绍：https://redis.io/docs/management/persistence/#aof-advantages</p> 
<ul><li>使用 AOF Redis 更加持久：可以有不同的 fsync 策略：根本不 sync、每秒 fsync、每次查询时 fsync。使用每秒 fsync 的默认策略，写入性能仍然很棒。fsync 是使用后台线程执行的，当没有 fsync 正在进行时，主线程将努力执行写入，因此只会丢失一秒钟的写入。</li><li>AOF 日志是一个仅附加日志，因此不会出现寻道问题，也不会在断电时出现损坏问题。即使由于某种原因（磁盘已满或其他原因）日志以写一半的命令结尾，<code>redis-check-aof</code> 工具也能够轻松修复它。</li><li>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。重写是完全安全的，因为当 Redis 继续附加到旧文件时，会使用创建当前数据集所需的最少操作集生成一个全新的文件，一旦第二个文件准备就绪，Redis 就会切换两者并开始附加到新的那一个。</li><li>AOF 以易于理解和解析的格式依次包含所有操作的日志。您甚至可以轻松导出 AOF 文件。例如，即使不小心使用 FLUSHALL 命令刷新了所有内容，只要在此期间没有执行日志重写，仍然可以通过停止服务器、删除最新命令并重新启动 Redis 来加载保存的数据集。</li></ul> 
<p>2）缺点</p> 
<p>文档介绍：https://redis.io/docs/management/persistence/#aof-disadvantages</p> 
<ul><li>AOF 文件通常比相同数据集的等效 RDB 文件大。</li><li>根据确切的 fsync 策略，AOF 可能比 RDB 慢。一般来说，将 fsync 设置为每秒性能仍然非常高。在禁用 fsync 的情况下，即使在高负载下，它也应该与 RDB 一样快。即使在巨大的写入负载的情况下，RDB 仍然能够提供关于最大延迟的更多保证。</li></ul> 
<h4><a id="2AOF__4233"></a>2、AOF 重写机制</h4> 
<p>文档介绍：https://redis.io/docs/management/persistence/#log-rewriting</p> 
<p>🅱️ 1、是什么</p> 
<p>由于 AOF 持久化是 Redis 不断将写命令记录到 AOF 文件中，随着 Redis 不断的进行，AOF 的文件会越来越大，文件越大，占用服务器内存越大以及 AOF 恢复要求时间越长。</p> 
<p>为了解决这个问题，Redis 新增了重写机制，当 AOF 文件的大小超过所设定的峰值时，Redis 就会 <code>自动</code> 启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集或者可以 <code>手动</code> 使用命令 <code>bgrewriteaof</code> 来重新。</p> 
<p>🅱️ 2、触发机制</p> 
<p>1）官网默认配置</p> 
<pre><code class="prism language-properties"># Automatic rewrite of the append only file.
# Redis is able to automatically rewrite the log file implicitly calling
# BGREWRITEAOF when the AOF log size grows by the specified percentage.
#
# This is how it works: Redis remembers the size of the AOF file after the
# latest rewrite (if no rewrite has happened since the restart, the size of
# the AOF at startup is used).
#
# This base size is compared to the current size. If the current size is
# bigger than the specified percentage, the rewrite is triggered. Also
# you need to specify a minimal size for the AOF file to be rewritten, this
# is useful to avoid rewriting the AOF file even if the percentage increase
# is reached but it is still pretty small.
#
# Specify a percentage of zero in order to disable the automatic AOF
# rewrite feature.

auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
</code></pre> 
<p>注意 ，同时满足，且的关系才会触发：<br> 1、根据上次重写后的 aof 大小，判断当前 aof 大小是不是增长了 100% （1 倍）；<br> 2、需要重写的 AOF 满足文件的大小（64mb）。</p> 
<p>2）自动触发</p> 
<p>满足配置文件中的选项后，Redis 会记录上次重写时的 AOF 大小。</p> 
<p>默认配置是当 AOF 文件大小是上次 rewrite 后大小的一倍且文件大于 64M 时自动触发重写机制。</p> 
<p>3）手动触发</p> 
<p>客户端向服务器发送 <code>bgrewriteaof</code> 命令。</p> 
<p>🅱️ 3、案例说明</p> 
<p>1）需求说明</p> 
<p>举个例子：比如有个 key</p> 
<p>一开始 set k1 v1</p> 
<p>然后改成 set k1 v2</p> 
<p>最后改成 set k1 v3</p> 
<p>如果不重写，那么这 3 条语句都在 aof 文件中，内容占空间不说启动的时候都要执行一遍，共计 3 条命令。</p> 
<p>但是，我们实际效果只需要 set k1 v3 这一条，所以，开启重写后，只需要保存 set k1 v3 就可以只需要保留最后一次修改值，相当于给 aof 文件瘦身减肥，性能更好。</p> 
<p>AOF 重写不仅降低了文件的占用空间，同时更小的 AOF 也可以更快地被 Redis 启动加载。</p> 
<p>2）需求验证</p> 
<p>启动 AOF 文件的内容压缩，只保留可以恢复数据的最小指令集。</p> 
<p>3）步骤</p> 
<ul><li>前期配置准备</li></ul> 
<p>1、开启 aof，默认是 no 关闭，设置为 yes 就打开 aof 持久化支持</p> 
<pre><code class="prism language-properties">appendonly yes
</code></pre> 
<p>2、重写峰值修改为 1k</p> 
<pre><code class="prism language-properties">auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 1k
</code></pre> 
<p>3、关闭混合，设置为 no</p> 
<pre><code class="prism language-properties"># Redis can create append-only base files in either RDB or AOF formats. Using
# the RDB format is always faster and more efficient, and disabling it is only
# supported for backward compatibility purposes.
aof-use-rdb-preamble no
</code></pre> 
<p>4、删除之前的全部 aof 和 rdb 文件，清除干扰项</p> 
<ul><li>自动触发案例</li></ul> 
<p>1、完成上述正确配置，重启 Redis 服务器，执行 set k1 v1 查看 aof 文件是否正常</p> 
<pre><code class="prism language-properties">appendonly.aof.1.base.rdb
appendonly.aof.1.incr.aof
appendonly.aof.manifest
</code></pre> 
<p>2、查看三大配置文件</p> 
<pre><code class="prism language-java"><span class="token comment">// 几种类型文件的前缀,后跟有关序列和类型的附加信息</span>
appendfilename "appendonly<span class="token punctuation">.</span>aof
<span class="token comment">// 新版本增加的目录配置项目</span>
appenddirname <span class="token string">"appendonlydir"</span>
<span class="token comment">// 有如下的aof文件存在</span>
<span class="token comment">// 1.基本文件(一个)</span>
appendonly<span class="token punctuation">.</span>aof<span class="token punctuation">.</span><span class="token number">1.</span>base<span class="token punctuation">.</span>rdb
<span class="token comment">// 2.增量文件(一个或多个)</span>
appendonly<span class="token punctuation">.</span>aof<span class="token punctuation">.</span><span class="token number">1.</span>incr<span class="token punctuation">.</span>aof
appendonly<span class="token punctuation">.</span>aof<span class="token punctuation">.</span><span class="token number">2.</span>incr<span class="token punctuation">.</span>aof
<span class="token comment">// 3.清单文件(一个)</span>
appendonly<span class="token punctuation">.</span>aof<span class="token punctuation">.</span>manifest
</code></pre> 
<p>3、对同一个 k1，不停的重复值 set 值，aof 文件慢慢变大，到峰值后启动重写机制</p> 
<pre><code class="prism language-sh"><span class="token punctuation">[</span>001956<span class="token punctuation">]</span> <span class="token number">22</span> Apr <span class="token number">15</span>:05:04.133 * Starting automatic rewriting of AOF on <span class="token number">107400</span>% growth
<span class="token punctuation">[</span>001956<span class="token punctuation">]</span> <span class="token number">22</span> Apr <span class="token number">15</span>:05:04.138 * Creating AOF incr <span class="token function">file</span> appendonly.aof.2.incr.aof on background rewrite
<span class="token punctuation">[</span>001956<span class="token punctuation">]</span> <span class="token number">22</span> Apr <span class="token number">15</span>:05:04.145 * Background append only <span class="token function">file</span> rewriting started by pid <span class="token number">13544</span>
<span class="token punctuation">[</span>001956<span class="token punctuation">]</span> <span class="token number">22</span> Apr <span class="token number">15</span>:05:04.356 <span class="token comment"># fork operation complete</span>
<span class="token punctuation">[</span>001956<span class="token punctuation">]</span> <span class="token number">22</span> Apr <span class="token number">15</span>:05:04.366 * Background AOF rewrite terminated with success
<span class="token punctuation">[</span>001956<span class="token punctuation">]</span> <span class="token number">22</span> Apr <span class="token number">15</span>:05:04.367 * Successfully renamed the temporary AOF base <span class="token function">file</span> temp-rewriteaof-bg-1956.aof into appendonly.aof.2.base.rdb
<span class="token punctuation">[</span>001956<span class="token punctuation">]</span> <span class="token number">22</span> Apr <span class="token number">15</span>:05:04.370 * Removing the <span class="token function">history</span> <span class="token function">file</span> appendonly.aof.1.incr.aof <span class="token keyword">in</span> the background
<span class="token punctuation">[</span>001956<span class="token punctuation">]</span> <span class="token number">22</span> Apr <span class="token number">15</span>:05:04.370 * Removing the <span class="token function">history</span> <span class="token function">file</span> appendonly.aof.1.base.rdb <span class="token keyword">in</span> the background
<span class="token punctuation">[</span>001956<span class="token punctuation">]</span> <span class="token number">22</span> Apr <span class="token number">15</span>:05:04.372 * Background AOF rewrite finished successfully
</code></pre> 
<p>查看 aof 文件：</p> 
<pre><code class="prism language-properties">appendonly.aof.2.base.rdb
appendonly.aof.2.incr.aof
appendonly.aof.manifest
</code></pre> 
<ul><li>手动触发案例</li></ul> 
<p>客户端向服务器发送 <code>bgrewriteaof</code> 命令：</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> BGREWRITEAOF
Background append only <span class="token function">file</span> rewriting started
</code></pre> 
<p>Redis 立马重写 aof 文件：</p> 
<pre><code class="prism language-sh"><span class="token punctuation">[</span>001956<span class="token punctuation">]</span> <span class="token number">22</span> Apr <span class="token number">15</span>:10:08.835 * Creating AOF incr <span class="token function">file</span> appendonly.aof.3.incr.aof on background rewrite
<span class="token punctuation">[</span>001956<span class="token punctuation">]</span> <span class="token number">22</span> Apr <span class="token number">15</span>:10:08.844 * Background append only <span class="token function">file</span> rewriting started by pid <span class="token number">5048</span>
<span class="token punctuation">[</span>001956<span class="token punctuation">]</span> <span class="token number">22</span> Apr <span class="token number">15</span>:10:09.036 <span class="token comment"># fork operation complete</span>
<span class="token punctuation">[</span>001956<span class="token punctuation">]</span> <span class="token number">22</span> Apr <span class="token number">15</span>:10:09.044 * Background AOF rewrite terminated with success
<span class="token punctuation">[</span>001956<span class="token punctuation">]</span> <span class="token number">22</span> Apr <span class="token number">15</span>:10:09.045 * Successfully renamed the temporary AOF base <span class="token function">file</span> temp-rewriteaof-bg-1956.aof into appendonly.aof.3.base.rdb
<span class="token punctuation">[</span>001956<span class="token punctuation">]</span> <span class="token number">22</span> Apr <span class="token number">15</span>:10:09.048 * Removing the <span class="token function">history</span> <span class="token function">file</span> appendonly.aof.2.incr.aof <span class="token keyword">in</span> the background
<span class="token punctuation">[</span>001956<span class="token punctuation">]</span> <span class="token number">22</span> Apr <span class="token number">15</span>:10:09.048 * Removing the <span class="token function">history</span> <span class="token function">file</span> appendonly.aof.2.base.rdb <span class="token keyword">in</span> the background
<span class="token punctuation">[</span>001956<span class="token punctuation">]</span> <span class="token number">22</span> Apr <span class="token number">15</span>:10:09.050 * Background AOF rewrite finished successfully
</code></pre> 
<p>查看 aof 文件：</p> 
<pre><code class="prism language-properties">appendonly.aof.3.base.rdb
appendonly.aof.3.incr.aof
appendonly.aof.manifest
</code></pre> 
<p>4）结论</p> 
<p>也就是说 AOF 文件重写并不是对原文件进行重新整理，而是直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令，生成一个新的文件后去替换原来的 AOF 文件。</p> 
<p>AOF 文件重写触发机制：通过 redis.conf 配置文件中的 <code>auto-aof-rewrite-percentage</code> 默认值为 100，以及 <code>auto-aof-rewrite-min-size 64mb</code> 配置，也就是说默认 Redis 会记录上次重写时的 AOF 大小，默认配置是当 AOF 文件大小是上次 rewrite 后大小的一倍且文件大于 64M 时触发 AOF 重写。</p> 
<p>🅱️ 4、重写原理</p> 
<p>文档介绍：https://redis.io/docs/management/persistence/#how-it-works-1</p> 
<p>1、在重写开始前，Redis 会创建一个“重写子进程”，这个子进程会读取现有的 AOF 文件，并将其包含的指令进行分析压缩并写入到一个临时文件中。</p> 
<p>2、与此同时，主进程会将新接收到的写指令一边累积到内存缓冲区中，一边继续写入到原有的 AOF 文件中，这样做是保证原有的 AOF 文件的可用性，避免在重写过程中出现意外。</p> 
<p>3、当“重写子进程”完成重写工作后，它会给父进程发一个信号，父进程收到信号后就会将内存中缓存的写指令追加到新 AOF 文件中。</p> 
<p>4、当追加结束后，Redis 就会用新 AOF 文件来代替旧 AOF 文件，之后再有新的写指令，就都会追加到新的 AOF 文件中。</p> 
<p>5、重写 AOF 文件的操作，并没有读取旧的 AOF 文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的 AOF 文件，这点和快照有点类似。</p> 
<p>🅰️ 6、AOF 优化配置项详解</p> 
<p>配置文件 APPEND ONLY MODE 模块：</p> 
<table><thead><tr><th>配置指令</th><th>配置含义</th><th>配置示例</th></tr></thead><tbody><tr><td>appendonly</td><td>是否开启 AOF</td><td>appendonly yes</td></tr><tr><td>appendfilename</td><td>文件名称</td><td>appendfilename “appendonly.aof”</td></tr><tr><td>appendfsync</td><td>同步方式</td><td>appendfsync always<br>appendfsync everysec<br>appendfsync no</td></tr><tr><td>no-appendfsync-on-rewrite</td><td>AOF 重写期间是否同步</td><td>no-appendfsync-on-rewrite no</td></tr><tr><td>auto-aof-rewrite-percentage <br>auto-aof-rewrite-min-size</td><td>重写触发配置、文件重写策略</td><td>auto-aof-rewrite-percentage 100<br>auto-aof-rewrite-min-size 64mb</td></tr></tbody></table> 
<h3><a id="04RDBAOF__4444"></a>04、RDB+AOF 混合持久化</h3> 
<p>🅰️ 1、官网建议</p> 
<p>文档介绍：https://redis.io/docs/management/persistence/#ok-so-what-should-i-use</p> 
<p>如果想要数据安全性，则应该使用这两种持久性方法。</p> 
<p>如果非常关心数据，但仍然可以接受发生故障发生时几分钟的数据丢失，那么可以简单地单独使用 RDB。</p> 
<p>🅰️ 2、RDB vs AOF</p> 
<p>1）问题</p> 
<ol><li>可否共存？</li><li>如果共存，启动恢复谁的？</li></ol> 
<p>2）默认配置</p> 
<pre><code class="prism language-nginx"># By default Redis asynchronously dumps the dataset on disk. This mode is
# good enough in many applications, but an issue with the Redis process or
# a power outage may result into a few minutes of writes lost (depending on
# the configured save points).
#
# The Append Only File is an alternative persistence mode that provides
# much better durability. For instance using the default data fsync policy
# (see later in the config file) Redis can lose just one second of writes in a
# dramatic event like a server power outage, or a single write if something
# wrong with the Redis process itself happens, but the operating system is
# still running correctly.
# 
# 可以同时启用 AOF 和 RDB 持久性，而不会出现问题。如果在启动时启用了 AOF，Redis 将加载 AOF，即文件具有更好的耐用性保证。
# AOF and RDB persistence can be enabled at the same time without problems.
# If the AOF is enabled on startup Redis will load the AOF, that is the file
# with the better durability guarantees.
#
# Please check https://redis.io/topics/persistence for more information.

appendonly yes
</code></pre> 
<p>3）数据恢复顺序和加载流程</p> 
<p>在同时开启 AOF 和 RDB 持久化时，重启时只会加载 AOF 文件，不会加载 RDB 文件。</p> 
<p><img src="https://images2.imgbox.com/9c/80/rgkH8m1F_o.png" alt="在这里插入图片描述"></p> 
<p>🅰️ 3、怎么选？用那个？</p> 
<p>RDB 持久化方式能够在指定的时间间隔能对数据进行快照存储。</p> 
<p>AOF 持久化方式记录每次对服务器写的操作，当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF 命令以 Redis 协议追加保存每次写的操作到文件末尾。</p> 
<p>同时开启两种持久化方式：</p> 
<p>在这种情况下，当 Redis 重启的时候会优先载入 AOF 文件来恢复原始的数据，因为在通常情况下 AOF 文件保存的数据集要比 RDB 文件保存的数据集要完整。</p> 
<p>RDB 的数据不实时，同时使用两者时服务器重启也只会找 AOF 文件。那要不要只使用 AOF 呢？<br> 建议不要，因为 RDB 更适合用于备份数据库（AOF 在不断变化不好备份），留着 RDB 作为一个保障。</p> 
<p>🅰️ 4、RDB+AOF 混合方式</p> 
<p>结合了 RDB 和 AOF 的优点，既能快速加载又能避免丢失过多的数据。</p> 
<p>1、开启混合方式设置</p> 
<p>设置 <code>aof-use-rdb-preamble</code> 的值为 yes。yes 表示开启，设置为 no 表示禁用。</p> 
<pre><code class="prism language-properties"># Redis can create append-only base files in either RDB or AOF formats. Using
# the RDB format is always faster and more efficient, and disabling it is only
# supported for backward compatibility purposes.
aof-use-rdb-preamble yes
</code></pre> 
<p>2、RDB+AOF 的混合方式</p> 
<blockquote> 
 <p>结论：RDB 镜像做全量持久化，AOF 做增量持久化</p> 
</blockquote> 
<p>先使用 RDB 进行快照存储，然后使用 AOF 持久化记录所有的写操作，当重写策略满足或手动触发重写的时候，将最新的数据存储为新的 RDB 记录。这样的话，重启服务的时候会从 RDB 和 AOF 两部分恢复数据，既保证了数据完整性，又提高了恢复数据的性能。简单来说：混合持久化方式产生的文件一部分是 RDB 格式，一部分是 AOF 格式。AOF 包括了 RDB 头部 + AOF 混写</p> 
<h3><a id="05_4527"></a>05、纯缓存模式</h3> 
<p>同时关闭 RDB、AOF 持久化机制。</p> 
<p>1、禁用 RDB</p> 
<pre><code class="prism language-properties">save ""
</code></pre> 
<p>禁用 RDB 持久化模式下，仍然可以使用命令 <code>save</code>、<code>bgsave</code> 生成 rdb 文件。</p> 
<p>2、禁用 AOF</p> 
<pre><code class="prism language-properties">appendonly no
</code></pre> 
<p>禁用 AOF 持久化模式下，仍然可以使用命令 <code>bgrewriteaof</code> 生成 aof 文件。</p> 
<h2><a id="rainbow_Redis__4547"></a>🌈 Redis 事务</h2> 
<p>🅰️ 1、是什么</p> 
<p>文档介绍：https://redis.io/docs/interact/transactions</p> 
<p>可以一次执行多个命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞。</p> 
<p>🅰️ 2、能干嘛</p> 
<p>在一个队列中，一次性、顺序性、排他性的执行一系列命令。</p> 
<p>Redis 事务可以一次执行多个命令， 并且带有以下三个重要的保证：</p> 
<ul><li>批量操作在发送 EXEC 命令前被放入队列缓存；</li><li>收到 EXEC 命令后进入事务执行，事务中任意命令执行失败，其余的命令依然被执行；</li><li>在事务执行过程，其他客户端提交的命令请求不会插入到事务执行命令序列中。</li></ul> 
<p>一个事务从开始到执行会经历以下三个阶段：</p> 
<ul><li>开始事务；</li><li>命令入队；</li><li>执行事务。</li></ul> 
<p>🅰️ 3、Redis 事务 VS 关系型数据库事务</p> 
<p>1、单独的隔离操作</p> 
<p>Redis 的事务仅仅是保证事务里的操作会被连续独占的执行，Redis 命令执行是单线程架构，在执行完事务内所有指令前是不可能再去同时执行其他客户端的请求的。</p> 
<p>2、没有隔离级别的概念</p> 
<p>因为事务提交前任何指令都不会被实际执行，也就不存在“事务内的查询要看到事务里的更新，在事务外查询不能看到”这种问题了。</p> 
<p>3、不保证原子性</p> 
<p>Redis 的事务不保证原子性，也就是不保证所有指令同时成功或同时失败，只有决定是否开始执行全部指令的能力，没有执行到一半进行回滚的能力。</p> 
<p>4、排它性</p> 
<p>Redis 会保证一个事务内的命令依次执行，而不会被其它命令插入。</p> 
<h3><a id="01_4589"></a>01、使用案例</h3> 
<p>文档介绍：https://redis.io/docs/interact/transactions</p> 
<p>Redis 事务是使用 MULTI 命令开启的。命令总是以“OK”作为回复。此时，用户可以发出多个命令。Redis 不会立即执行这些命令，而是将它们放入一个队列。当调用 EXEC 命令后，将执行队列的所有命令。</p> 
<p>调用 DISCARD 将清空事务队列并退出事务。</p> 
<p>🅰️ 1、Redis 事务相关的常用命令</p> 
<ul><li><code>MULTI</code> ：标记一个事务块的开始。</li><li><code>EXEC</code> ：执行所有事务块内的命令。</li><li><code>DISCARD</code> ：取消事务，放弃执行事务块内的所有命令。</li><li><code>WATCH key [key ...]</code> ：监视一个（或多个）key ，如果在事务执行之前这个（或这些）key 被其他命令所改动，那么事务将被打断。</li><li><code>UNWATCH</code> ：取消 WATCH 命令对所有 key 的监视。</li></ul> 
<p>🅰️ 2、案例一：正常执行</p> 
<p>文档介绍：https://redis.io/docs/interact/transactions/#usage</p> 
<p>使用命令 <code>MULTI</code>、<code>EXEC</code></p> 
<pre><code class="prism language-sh"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> MULTI
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> k1 v1
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> k2 v2
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> k3 v3
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> INCR age
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> EXEC
<span class="token number">1</span><span class="token punctuation">)</span> OK
<span class="token number">2</span><span class="token punctuation">)</span> OK
<span class="token number">3</span><span class="token punctuation">)</span> OK
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get age
<span class="token string">"1"</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span>
</code></pre> 
<blockquote> 
 <p>单个 Redis 命令的执行是原子性的，但 Redis 没有在事务上增加任何维持原子性的机制，所以 Redis 事务的执行并不是原子性的。</p> 
 <p>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做。</p> 
</blockquote> 
<p>🅰️ 3、案例二：放弃事务</p> 
<p>文档介绍：https://redis.io/docs/interact/transactions/#discarding-the-command-queue</p> 
<p>使用命令 <code>MULTI</code>、<code>DISCARD</code></p> 
<pre><code class="prism language-sh"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> MULTI
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> k1 v11
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> k2 v22
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> INCR age
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> DISCARD
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get age
<span class="token string">"1"</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span>
</code></pre> 
<p>🅰️ 4、案例三：命令放入队列时错误，全体失败</p> 
<p>文档介绍：https://redis.io/docs/interact/transactions/#errors-inside-a-transaction</p> 
<pre><code class="prism language-sh"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> MULTI
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> k1 v11
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> k2 v22
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> k3
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR wrong number of arguments <span class="token keyword">for</span> <span class="token string">'set'</span> <span class="token builtin class-name">command</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> EXEC
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> EXECABORT Transaction discarded because of previous errors.
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get k2
<span class="token string">"v2"</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span>
</code></pre> 
<p>一个命令语法出错，全体连坐。如果任何一个命令语法有错 Redis 会直接返回错误，所有的命今都不会执行。</p> 
<p>🅰️ 5、案例四：命令执行时错误，自身命令失败，不影响其他命令执行</p> 
<p>文档介绍：https://redis.io/docs/interact/transactions/#errors-inside-a-transaction</p> 
<pre><code class="prism language-sh"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> name don
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> MULTI
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> k1 v111
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> incr name
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> age <span class="token number">6</span>
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> EXEC
<span class="token number">1</span><span class="token punctuation">)</span> OK
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR value is not an integer or out of range
<span class="token number">3</span><span class="token punctuation">)</span> OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get k1
<span class="token string">"v111"</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get age
<span class="token string">"6"</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get name
<span class="token string">"don"</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span>
</code></pre> 
<p>Redis 不提供事务回滚的功能，开发者必须在事务执行出错后，自行恢复数据库状态。</p> 
<ul><li>不会回滚的解释</li></ul> 
<p>文档介绍：https://redis.io/docs/interact/transactions/#what-about-rollbacks</p> 
<p>Redis 不支持事务回滚，因为支持回滚会对 Redis 的简单性和性能产生重大影响。</p> 
<blockquote> 
 <p>注意和传统数据库事务区别，不一定要么一起成功要么一起失败。</p> 
</blockquote> 
<p>🅰️ 6、案例五：<code>watch</code> 监控</p> 
<p>Redis 使用 Watch 来提供乐观锁定，类似于 CAS（Check-and-Set）</p> 
<p>文档介绍：https://redis.io/docs/interact/transactions/#optimistic-locking-using-check-and-set</p> 
<p>示例：初始化 k1 和 balance 两个 key，先监控再开启 multi，保证两个 key 变动在同一个事务内。</p> 
<pre><code class="prism language-sh"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> k1 abc
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> balance <span class="token number">100</span>
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token function">watch</span> balance
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> multi
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> k1 abc2
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> balance <span class="token number">200</span>
QUEUED
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">exec</span>
<span class="token number">1</span><span class="token punctuation">)</span> OK
<span class="token number">2</span><span class="token punctuation">)</span> OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get k1
<span class="token string">"abc2"</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get balance
<span class="token string">"200"</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span>
</code></pre> 
<p><code>watch</code> 命令是一种乐观锁的实现，Redis 在修改的时候会检测数据是否被更改，如果更改了，则执行失败。</p> 
<p>第一个第5步执行结果返回为空（监控的数据已被其他用户修改），也就是相当于是失败。</p> 
<p><img src="https://images2.imgbox.com/98/68/k2yz2SvU_o.png" alt="在这里插入图片描述"></p> 
<p><code>unwatch</code> 放弃监控，即使在事务中的数据被其他用户修改了，也不影响。</p> 
<p><img src="https://images2.imgbox.com/b7/b2/W21I6BQQ_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>一旦执行了 exec ，之前加的监控锁都会被取消掉了。</p> 
 <p>当客户端连接丢失的时候（比如退出链接），所有的监控锁都会被取消监视。</p> 
</blockquote> 
<p>🅰️ 4、小总结</p> 
<p>开启事务：以 MULTI 开始一个事务。</p> 
<p>入队：将多个命令入队到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里面。</p> 
<p>执行事务：由 EXEC 命令触发事务。</p> 
<p>放弃事务：使用 DISCARD 命令放弃事务。</p> 
<h2><a id="rainbow_Redis__4775"></a>🌈 Redis 管道</h2> 
<p>🅰️ 1、目前的问题</p> 
<p>面试题：如何优化频繁命令往返造成的 Redis 性能瓶颈？</p> 
<p>⭕️ 问题由来：</p> 
<p>Redis 是一种基于 <code>客户端-服务端模型</code> 以及请求/响应协议的 TCP 服务。一个请求会遵循以下步骤：</p> 
<p>1、客户端向服务端发送命令分四步（发送命令→命令排队→命令执行→返回结果），并监听 Socket 返回，通常以阻塞模式等待服务端响应。</p> 
<p>2、服务端处理命令，并将结果返回给客户端。</p> 
<blockquote> 
 <p>上述两步称为：Round Trip Time（简称 RTT，数据包往返于两端的时间）</p> 
</blockquote> 
<p>如果同时需要执行大量的命令，那么就要等待上一条命令应答后再执行，这中间不仅仅多了 RTT（Round Time Trip），而且还频繁调用系统 IO，发送网络请求，同时需要 Redis 调用多次 <code>read()</code> 和 <code>write()</code> 系统方法，系统方法会将数据从用户态转移到内核态，这样就会对进程上下文有比较大的影响了，性能不太好。</p> 
<p>✅ 解决思路：引出管道这个概念</p> 
<p>管道（pipeline）可以一次性发送多条命令给服务端，服务端依次处理完毕后，通过一条响应一次性将结果返回，通过减少客户端与 Redis 的通信次数来实现降低往返延时时间。pipeline 实现的原理是 <code>队列</code>，先进先出特性就保证数据的顺序性。</p> 
<p><img src="https://images2.imgbox.com/6b/1f/qXrwIA9S_o.png" alt="在这里插入图片描述"></p> 
<p>🅰️ 2、是什么</p> 
<p>文档介绍：https://redis.io/docs/manual/pipelining</p> 
<p>定义：Pipeline 是为了解决 RTT 往返回时间，仅仅是将命令打包一次性发送，对整个 Redis 的执行不造成其它任何影响。</p> 
<p>批处理命令变种优化措施，类似 Redis 的原生批命令（mget 和 mset）。</p> 
<p>🅰️ 3、使用案例</p> 
<pre><code class="prism language-sh"><span class="token variable"><span class="token variable">$(</span><span class="token builtin class-name">echo</span> <span class="token parameter variable">-en</span> <span class="token string">"PING<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span> SET mykey redis7<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>GET mykey<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>INCR visitor<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>INCR visitor<span class="token entity" title="\r">\r</span><span class="token entity" title="\n">\n</span>"</span><span class="token punctuation">;</span> <span class="token function">sleep</span> <span class="token number">10</span><span class="token variable">)</span></span> <span class="token operator">|</span> <span class="token function">nc</span> localhost <span class="token number">6379</span>
</code></pre> 
<p>通过使用 PING 命令查看 Redis 服务是否可用；之后设置 mykey 的值为 redis7，然后获取 mykey 的值；最后执行 visitor 自增 2 次。</p> 
<p>在返回的结果中可以看到这些命令一次性向 Redis 服务提交，并最终一次性读取所有服务端的响应。</p> 
<p>命令写在文件中，一次执行：</p> 
<pre><code class="prism language-sh"><span class="token punctuation">[</span>xxx<span class="token punctuation">]</span><span class="token comment"># cat test.txt </span>
<span class="token builtin class-name">set</span> mykey redis7
incr visitor
<span class="token punctuation">[</span>xxx<span class="token punctuation">]</span><span class="token comment"># cat test.txt | redis-cli --pipe</span>
All data transferred. Waiting <span class="token keyword">for</span> the last reply<span class="token punctuation">..</span>.
Last reply received from server.
errors: <span class="token number">0</span>, replies: <span class="token number">2</span>
<span class="token punctuation">[</span>xxx<span class="token punctuation">]</span><span class="token comment"># redis-cli</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get mykey
<span class="token string">"redis7"</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> get visitor
<span class="token string">"1"</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> 
</code></pre> 
<p>🅰️ 4、小总结</p> 
<p>1、Pipeline 与原生批量命令对比</p> 
<ul><li>原生批量命令是原子性（例如：mset，mget），pipeline 是非原子性。</li><li>原生批量命令一次只能执行一种命令，pipeline 支持批量执行不同命令。</li><li>原生批命令是服务端实现，而 pipeline 需要服务端与客户端共同完成。</li></ul> 
<p>2、Pipeline 与事务对比</p> 
<ul><li>事务具有原子性，管道不具有原子性。</li><li>管道一次性将多条命令发送到服务器，事务是一条一条的发，事务只有在接收到 exec 命令后才会执行，管道不会。</li><li>执行事务时会阻塞其他命令的执行，而执行管道中的命令时不会。</li></ul> 
<p>3、使用 Pipeline 的注意事项</p> 
<ul><li>pipeline 缓冲的指令只是会依次执行，不保证原子性，如果执行中指令发生异常，将会继续执行后续的指令。</li><li>使用 pipeline 组装的命令个数不能太多，不然数据量过大客户端阻塞的时间可能过久，同时服务端此时也被迫回复一个队列答复，占用很多内存。</li></ul> 
<h2><a id="rainbow_Redis__4855"></a>🌈 Redis 发布订阅</h2> 
<p>🅰️ 1、是什么</p> 
<p>文档介绍：https://redis.io/docs/interact/pubsub</p> 
<p>定义：是一种消息通信模式。发送者（PUBLISH）发送消息，订阅者（SUBSCRIBE）接收消息，可以实现进程间的消息传递。</p> 
<p>Redis 可以实现消息中间件 MQ 的功能，通过发布订阅实现消息的引导和分流。项目中不推荐使用该功能。</p> 
<p>🅰️ 2、能干嘛</p> 
<p>Redis 客户端可以订阅任意数量的频道，类似于微信关注多个公众号。</p> 
<p><img src="https://images2.imgbox.com/0e/dd/zOSnYi0N_o.png" alt="在这里插入图片描述"></p> 
<p>当有新消息通过 PUBLISH 命令发送给频道 channel 时：</p> 
<p><img src="https://images2.imgbox.com/6e/5f/Ty8bC4Lp_o.png" alt="在这里插入图片描述"></p> 
<p><code>发布/订阅</code> 其实是一个轻量的队列，只不过数据不会被持久化，一般用来处理 <code>实时性较高的异步消息</code>。</p> 
<p>🅰️ 3、相关命令</p> 
<p>1）命令 1</p> 
<pre><code class="prism language-sh">SUBSCRIBE channel <span class="token punctuation">[</span>channel <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>订阅给定的一个或多个频道的信息。</p> 
<p>推荐先执行订阅后再发布消息，订阅成功之前发布的消息是收不到的。</p> 
<p>订阅的客户端每次可以收到一个含有 3 个参数的消息：</p> 
<ul><li>消息的种类</li><li>始发频道的名称</li><li>实际的消息内容</li></ul> 
<p>2）命令 2</p> 
<pre><code class="prism language-sh">PUBLISH channel message
</code></pre> 
<p>发布消息到指定的频道。</p> 
<p>示例：开启 3 个客户端，演示客户端 A、B 订阅消息，客户端 C 发布消息</p> 
<p>客户端 A：</p> 
<pre><code class="prism language-sh"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> SUBSCRIBE ch1
Reading messages<span class="token punctuation">..</span>. <span class="token punctuation">(</span>press Ctrl-C to quit<span class="token punctuation">)</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"subscribe"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"ch1"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre> 
<p>客户端 B：</p> 
<pre><code class="prism language-sh"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> SUBSCRIBE ch2
Reading messages<span class="token punctuation">..</span>. <span class="token punctuation">(</span>press Ctrl-C to quit<span class="token punctuation">)</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"subscribe"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"ch2"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre> 
<p>客户端 C：</p> 
<pre><code class="prism language-sh"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> PUBLISH ch1 helloch1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> PUBLISH ch2 helloch2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span>
</code></pre> 
<p>客户端 A 接收到消息：</p> 
<pre><code class="prism language-sh"><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"message"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"ch1"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"helloch1"</span>
</code></pre> 
<p>客户端 B 接收到消息：</p> 
<pre><code class="prism language-sh"><span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"message"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"ch2"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"helloch2"</span>
</code></pre> 
<p>3）命令 3</p> 
<pre><code class="prism language-sh">PSUBSCRIBE pattern <span class="token punctuation">[</span>pattern <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>按照模式批量订阅，订阅一个或多个符合给定模式（支持 <code>*</code> 号 <code>?</code> 号之类的）的频道。</p> 
<p>示例：</p> 
<pre><code class="prism language-sh"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> PSUBSCRIBE ch*
Reading messages<span class="token punctuation">..</span>. <span class="token punctuation">(</span>press Ctrl-C to quit<span class="token punctuation">)</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"psubscribe"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"ch*"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"pmessage"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"ch*"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"ch1"</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"helloch1"</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"pmessage"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"ch*"</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"ch2"</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">"helloch2"</span>
</code></pre> 
<p>4）命令 4</p> 
<p>查看订阅与发布系统状态</p> 
<pre><code class="prism language-sh">PUBSUB subcommand <span class="token punctuation">[</span>argument <span class="token punctuation">[</span>argument <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<ul><li>由活跃频道组成的列表</li></ul> 
<pre><code class="prism language-sh">PUBSUB CHANNELS
</code></pre> 
<ul><li>某个频道有几个订阅者</li></ul> 
<pre><code class="prism language-sh">PUBSUB NUMSUB <span class="token punctuation">[</span>channel <span class="token punctuation">[</span>channel <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<ul><li>只统计使用 PSUBSCRIBE 命令执行的，返回客户端订阅的唯一 <code>模式的数量</code></li></ul> 
<pre><code class="prism language-sh">PUBSUB NUMPAT
</code></pre> 
<p>示例：</p> 
<pre><code class="prism language-sh"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> PUBSUB NUMPAT
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> PUBSUB CHANNELS
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"ch2"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">"ch1"</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> PUBSUB NUMSUB ch1 ch2
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">"ch1"</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"ch2"</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span>
</code></pre> 
<p>5）命令 5</p> 
<p>取消订阅</p> 
<pre><code class="prism language-sh">UNSUBSCRIBE <span class="token punctuation">[</span>channel <span class="token punctuation">[</span>channel <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<p>6）命令 6</p> 
<p>退订所有给定模式的频道</p> 
<pre><code class="prism language-sh">PUNSUBSCRIBE <span class="token punctuation">[</span>pattern <span class="token punctuation">[</span>pattern <span class="token punctuation">..</span>.<span class="token punctuation">]</span><span class="token punctuation">]</span>
</code></pre> 
<p>🅰️ 4、总结</p> 
<p>Redis 可以实现消息中间件 MQ 的功能，通过发布订阅实现消息的引导和分流。不推荐项目中使用。</p> 
<p>Pub/Sub 缺点：</p> 
<ul><li>发布的消息在 Redis 系统中不能持久化，因此，必须先执行订阅，再等待消息发布。如果先发布了消息，那么该消息由于没有订阅者，消息将被直接丢弃。</li><li>消息只管发送，对于发布者而言消息是即发即失的，不管接收，也没有 ACK 机制，无法保证消息的消费成功。</li></ul> 
<p>以上的缺点导致 Redis 的 Pub/Sub 模式就像个小玩具，在生产环境中几乎无用武之地，为此 Redis 5.0 版本新增了 Stream 数据结构，不但支持多播，还支持数据持久化，相比 Pub/Sub 更加的强大。</p> 
<h2><a id="rainbow_Redis_replication_5048"></a>🌈 Redis 复制（replication）</h2> 
<h3><a id="01Redis__5050"></a>01、Redis 复制的介绍</h3> 
<p>Redis 如何通过复制支持高可用性和故障切换。</p> 
<p>🅰️ 1、是什么</p> 
<p>文档介绍：https://redis.io/docs/management/replication</p> 
<p>Redis 复制，即主从复制，Master 以写为主，Slave 以读为主。</p> 
<p>当 Master 数据变化的时候，自动将新的数据异步同步到其链接的 Slave 数据库。</p> 
<p>🅰️ 2、能干嘛</p> 
<ul><li>读写分离</li><li>容灾恢复</li><li>数据备份</li><li>水平扩容支撑高并发</li></ul> 
<h3><a id="02Redis__5069"></a>02、Redis 复制操作案例</h3> 
<blockquote> 
 <p>配从库不配主库</p> 
</blockquote> 
<p>🅰️ 1、权限问题</p> 
<p>master 如果配置了 requirepass 参数，需要密码登陆。</p> 
<p>那么 slave 就要配置 masterauth 来设置校验密码，否则的话 master 会拒绝 slave 的访问请求。</p> 
<p>Redis 配置文件的 REPLICATION 模块可以看到：</p> 
<pre><code class="prism language-properties"># If the master is password protected (using the "requirepass" configuration
# directive below) it is possible to tell the replica to authenticate before
# starting the replication synchronization process, otherwise the master will
# refuse the replica request.
#
# masterauth &lt;master-password&gt;
</code></pre> 
<p>🅰️ 2、基本操作命令</p> 
<p>1）命令：<code>info replication</code></p> 
<p>可以查看复制节点的主从关系和配置信息。</p> 
<p>2）命令：<code>replicaof 主库IP 主库端口</code></p> 
<p>一般写入进 redis.conf 配置文件内。</p> 
<pre><code class="prism language-properties">################################# REPLICATION #################################

# Master-Replica replication. Use replicaof to make a Redis instance a copy of
# another Redis server. A few things to understand ASAP about Redis replication.
#
#   +------------------+      +---------------+
#   |      Master      | ---&gt; |    Replica    |
#   | (receive writes) |      |  (exact copy) |
#   +------------------+      +---------------+
#
# 1) Redis replication is asynchronous, but you can configure a master to
#    stop accepting writes if it appears to be not connected with at least
#    a given number of replicas.
# 2) Redis replicas are able to perform a partial resynchronization with the
#    master if the replication link is lost for a relatively small amount of
#    time. You may want to configure the replication backlog size (see the next
#    sections of this file) with a sensible value depending on your needs.
# 3) Replication is automatic and does not need user intervention. After a
#    network partition replicas automatically try to reconnect to masters
#    and resynchronize with them.
#
# replicaof &lt;masterip&gt; &lt;masterport&gt;
</code></pre> 
<p>3）命令：<code>slaveof 主库IP 主库端口</code></p> 
<p>每次与 master 断开之后，都需要重新连接，除非你配置进 redis.conf 文件。</p> 
<p>在运行期间修改 slave 节点的信息，如果该数据库已经是某个主数据库的从数据库，那么会停止和原主数据库的同步关系转而和新的主数据库同步，重新拜码头。</p> 
<p>4）命令：<code>slaveof no one</code></p> 
<p>使当前数据库停止与其他数据库的同步关系，转成主数据库。</p> 
<p>🅰️ 3、操作案例前置说明与准备</p> 
<p>1）环境准备</p> 
<p>准备 3 台 Redis，一个 Master 两个 Slave，配置文件分别命名为 redis6380.conf、redis6390.conf、redis6391.conf，且三边网络相互 ping 通且注意防火墙配置。</p> 
<p>2）涉及三大命令</p> 
<ul><li>主从复制：<code>replicaof 主库IP 主库端口</code></li><li>改换门庭：<code>slaveof 新主库IP 新主库端口</code></li><li>自立为王：<code>slaveof no one</code></li></ul> 
<p>3）修改配置文件，分别修改 6380、6390、6391 配置</p> 
<p>3.1）配置 Redis 为后台运行</p> 
<pre><code class="prism language-properties">################################# GENERAL #####################################

# By default Redis does not run as a daemon. Use 'yes' if you need it.
# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
# When Redis is supervised by upstart or systemd, this parameter has no impact.
daemonize yes
</code></pre> 
<p>3.2）移除绑定 IP</p> 
<pre><code class="prism language-properties"># bind 127.0.0.1 -::1
</code></pre> 
<p>3.3）关闭保护模式</p> 
<pre><code class="prism language-properties"># protected-mode no
</code></pre> 
<p>3.4）指定端口</p> 
<pre><code class="prism language-properties">port 6380
</code></pre> 
<p>3.5）指定当前工作目录 dir</p> 
<pre><code class="prism language-properties"># The working directory.
#
# The DB will be written inside this directory, with the filename specified
# above using the 'dbfilename' configuration directive.
#
# The Append Only File will also be created inside this directory.
#
# Note that you must specify a directory here, not a file name.
dir ./replication_db
</code></pre> 
<p>3.6）指定 pid 文件名字 pidfile</p> 
<pre><code class="prism language-properties"># If a pid file is specified, Redis writes it where specified at startup
# and removes it at exit.
#
# When the server runs non daemonized, no pid file is created if none is
# specified in the configuration. When the server is daemonized, the pid file
# is used even if not specified, defaulting to "/var/run/redis.pid".
#
# Creating a pid file is best effort: if Redis is not able to create it
# nothing bad happens, the server will start and run normally.
#
# Note that on modern Linux systems "/run/redis.pid" is more conforming
# and should be used instead.
pidfile /var/run/redis_6380.pid
</code></pre> 
<p>3.7）指定 log 文件名字 logfile</p> 
<pre><code class="prism language-properties"># Specify the log file name. Also the empty string can be used to force
# Redis to log on the standard output. Note that if you use standard
# output for logging but daemonize, logs will be sent to /dev/null
logfile "redis_6380.log"
</code></pre> 
<p>3.8）设置密码 requirepass</p> 
<pre><code class="prism language-properties">requirepass 123456
</code></pre> 
<p>3.9）配置 dump.rdb 名字</p> 
<pre><code class="prism language-properties"># The filename where to dump the DB
dbfilename dump6380.rdb
</code></pre> 
<p>3.10）配置 aof 文件 appendfilename（本步骤可选，非必须）</p> 
<pre><code class="prism language-properties">appenddirname "appendonlydir"
</code></pre> 
<p>3.11）从机访问主机的通行密码 masterauth，必须配置（从机需要配置，主机不用）</p> 
<pre><code class="prism language-properties">replicaof 192.168.10.10 6380

masterauth 123456
</code></pre> 
<p>🅰️ 4、主从复制模式 1 ：一主多仆</p> 
<p>1）方案1：配置文件固定配置</p> 
<p>配从(库)不配主(库)。配置文件执行：<code>replicaof 主库IP 主库端口</code></p> 
<p>1、从库 6390/6391 分别配置</p> 
<pre><code class="prism language-properties">replicaof 192.168.10.10 6380

masterauth 123456
</code></pre> 
<p>2、先 master 后 slave 依次启动</p> 
<pre><code class="prism language-sh">redis-server redis_6380.conf
redis-server redis_6390.conf
redis-server redis_6391.conf
</code></pre> 
<p>3、主从关系查看</p> 
<p>查看主机日志：</p> 
<pre><code class="prism language-properties">Synchronization with replica 127.0.0.1:6390 succeeded
//...
Synchronization with replica 127.0.0.1:6391 succeeded
</code></pre> 
<p>查看从机日志：</p> 
<pre><code class="prism language-properties">Connecting to MASTER 127.0.0.1:6380
//...
Master replied to PING, replication can continue...
</code></pre> 
<p>4、使用命令查看 <code>info replication</code></p> 
<p>主机 6380：</p> 
<pre><code class="prism language-properties">&gt; info replication
# Replication
role:master
connected_slaves:2
slave0:ip=127.0.0.1,port=6390,state=online,offset=910,lag=1
slave1:ip=127.0.0.1,port=6391,state=online,offset=910,lag=1
master_failover_state:no-failover
master_replid:96594b73268e78fc974cba842d21820ccb7accbd
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:910
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:910
</code></pre> 
<p>从机 6390：</p> 
<pre><code class="prism language-properties">&gt; info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6380
master_link_status:up
master_last_io_seconds_ago:3
master_sync_in_progress:0
slave_read_repl_offset:980
slave_repl_offset:980
slave_priority:100
slave_read_only:1
replica_announced:1
connected_slaves:0
master_failover_state:no-failover
master_replid:96594b73268e78fc974cba842d21820ccb7accbd
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:980
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:980
</code></pre> 
<p>看出成功实现主从关系绑定。</p> 
<p>2）方案2：命令操作手动指定</p> 
<p>可以使用命令：<code>slaveof 主库IP 主库端口</code> 将一个主机关联到另一台主机上当从机。</p> 
<p>1、准备一台 Redis 6392 ，配置文件中不配置 <code>replicaof</code> 配置项，启动后查看信息标注为 master。</p> 
<pre><code class="prism language-properties">&gt; 127.0.0.1@6392 connected!
&gt; info replication
# Replication
role:master
connected_slaves:0
master_failover_state:no-failover
master_replid:2a64b6440bad02f011281082fa9c263bb724d7fa
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
</code></pre> 
<p>2、输入命令 <code>slaveof 127.0.0.1 6380</code> 绑定主从关系，角色变成 slave</p> 
<pre><code class="prism language-properties">&gt; slaveof 127.0.0.1 6380
OK
&gt; info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6380
master_link_status:up
master_last_io_seconds_ago:0
master_sync_in_progress:0
slave_read_repl_offset:14970
slave_repl_offset:14970
slave_priority:100
slave_read_only:1
replica_announced:1
connected_slaves:0
master_failover_state:no-failover
master_replid:0c1e89fbd5de7a6f6d3346f9cf9a692bd9aeb67a
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:14970
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:14971
repl_backlog_histlen:0
</code></pre> 
<p>3、此时查看主机关系，标明有三个从机</p> 
<pre><code class="prism language-properties">&gt; info replication
# Replication
role:master
connected_slaves:3
slave0:ip=127.0.0.1,port=6390,state=online,offset=15026,lag=1
slave1:ip=127.0.0.1,port=6391,state=online,offset=15026,lag=1
slave2:ip=127.0.0.1,port=6392,state=online,offset=15026,lag=1
master_failover_state:no-failover
master_replid:0c1e89fbd5de7a6f6d3346f9cf9a692bd9aeb67a
master_replid2:96594b73268e78fc974cba842d21820ccb7accbd
master_repl_offset:15026
second_repl_offset:12479
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:12479
repl_backlog_histlen:2548
</code></pre> 
<p>🅰️ 5、主从的常见问题</p> 
<p>1）从机可以执行写命令吗？ 不能</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> k2 v2
READONLY You can't <span class="token function">write</span> against a <span class="token builtin class-name">read</span> only replica.
</code></pre> 
<p>2）slave 是从头开始复制还是从切入点开始复制？</p> 
<p>从机在启动后，会一次性复制主机上的数据，之后增量复制主机上的数据。</p> 
<p>3）主机宕机后，从机会变成主机吗？</p> 
<p>不会，从机保持不变化，从机数据可以正常查询使用；等待主机重新启动，继续完成工作。</p> 
<pre><code class="prism language-properties">Successful partial resynchronization with master.
MASTER &lt;-&gt; REPLICA sync: Master accepted a Partial Resynchronization.
</code></pre> 
<p>4）主机宕机后，重启后主从关系还在吗？从机还能否顺利复制？</p> 
<p>主从关系还在，从机也正常复制。</p> 
<pre><code class="prism language-properties">&gt; info replication
# Replication
role:master
connected_slaves:2
slave0:ip=127.0.0.1,port=6390,state=online,offset=13021,lag=0
slave1:ip=127.0.0.1,port=6391,state=online,offset=13021,lag=0
master_failover_state:no-failover
master_replid:0c1e89fbd5de7a6f6d3346f9cf9a692bd9aeb67a
master_replid2:96594b73268e78fc974cba842d21820ccb7accbd
master_repl_offset:13021
second_repl_offset:12479
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:12479
repl_backlog_histlen:543
</code></pre> 
<p>5）某台从机宕机后，主机继续写操作，从机重启后他的数据能保证完整吗？</p> 
<p>完整的，从机重启后会同步</p> 
<pre><code class="prism language-properties">Successful partial resynchronization with master.
MASTER &lt;-&gt; REPLICA sync: Master accepted a Partial Resynchronization.
</code></pre> 
<p>🅰️ 6、主从复制模式 2 ：薪火相传</p> 
<p>一个 slave 可以是下一个 slave 的 master，slave 同样可以接收其他 slave 的连接和同步请求，那么该 slave 作为了链条中下一个的 master。可以有效减轻主 master 的写压力。</p> 
<p>中途变更关系转向：会清除现有同步的数据，重新建立关系后，同步 master 最新的数据。</p> 
<p>使用命令：<code>slaveof 新主库IP 新主库端口</code></p> 
<p>从机 6391 执行，关联到 6390 从机上，关系如下：</p> 
<pre><code class="prism language-properties">&gt; 127.0.0.1@6391 connected!
&gt; slaveof 127.0.0.1 6390
OK
&gt; info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6390
master_link_status:up
master_last_io_seconds_ago:11
master_sync_in_progress:0
slave_read_repl_offset:17094
slave_repl_offset:17094
slave_priority:100
slave_read_only:1
replica_announced:1
connected_slaves:0
master_failover_state:no-failover
master_replid:0c1e89fbd5de7a6f6d3346f9cf9a692bd9aeb67a
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:17094
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:13330
repl_backlog_histlen:3765
</code></pre> 
<p>此时主机 6380 的关系如下，只带着一个从机 6390：</p> 
<pre><code class="prism language-properties">&gt; 127.0.0.1@6380 connected!
&gt; info replication
# Replication
role:master
connected_slaves:1
slave0:ip=127.0.0.1,port=6390,state=online,offset=17220,lag=1
master_failover_state:no-failover
master_replid:0c1e89fbd5de7a6f6d3346f9cf9a692bd9aeb67a
master_replid2:96594b73268e78fc974cba842d21820ccb7accbd
master_repl_offset:17220
second_repl_offset:12479
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:12479
repl_backlog_histlen:4742
</code></pre> 
<p>此时从机 6390 的关系如下，角色还是 slave，其下挂着 slave0 6391：</p> 
<pre><code class="prism language-properties">&gt; 127.0.0.1@6390 connected!
&gt; info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6380
master_link_status:up
master_last_io_seconds_ago:3
master_sync_in_progress:0
slave_read_repl_offset:17290
slave_repl_offset:17290
slave_priority:100
slave_read_only:1
replica_announced:1
connected_slaves:1
slave0:ip=127.0.0.1,port=6391,state=online,offset=17290,lag=0
master_failover_state:no-failover
master_replid:0c1e89fbd5de7a6f6d3346f9cf9a692bd9aeb67a
master_replid2:96594b73268e78fc974cba842d21820ccb7accbd
master_repl_offset:17290
second_repl_offset:12479
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:17290
</code></pre> 
<p>此时主机 6380 写入数据，会同步到从机 6390，从机 6391 也会从从机 6390 同步更新的数据。</p> 
<p>🅰️ 7、主从复制模式 3 ：反客为主</p> 
<p>当前数据库停止与其他数据库的同步关系，转成主数据库。</p> 
<p>使用命令：<code>slaveof no one</code></p> 
<pre><code class="prism language-properties">&gt; 127.0.0.1@6391 connected!
&gt; slaveof no one
OK
&gt; info replication
# Replication
role:master
connected_slaves:0
master_failover_state:no-failover
master_replid:c327d18094230018430868f062b510d31338f36c
master_replid2:0c1e89fbd5de7a6f6d3346f9cf9a692bd9aeb67a
master_repl_offset:17739
second_repl_offset:17740
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:13330
repl_backlog_histlen:4410
&gt; set k10 v10
OK
</code></pre> 
<p>解除同步关系后，角色变成了 master，也即可以写入数据了。</p> 
<h3><a id="03Redis__5585"></a>03、Redis 复制工作原理</h3> 
<p>文档介绍：https://redis.io/docs/management/replication/#how-redis-replication-works</p> 
<p>🅰️ 1、从机启动，发起初次同步请求</p> 
<p>slave 启动成功连接到 master 后会发送一个 sync 命令。</p> 
<p>slave 首次全新连接 master，一次完全同步（全量复制）将被自动执行，slave 自身原有数据会被 master 数据覆盖清除。</p> 
<p>🅰️ 2、首次连接，全量复制</p> 
<p>master 节点收到 sync 命令后，会开始在后台保存快照（即 RDB 持久化，主从复制时会触发 RDB），同时收集所有接收到的用于修改数据集命令缓存起来，master 节点执行 RDB 持久化完后，master 将 rdb 快照文件和所有缓存的命令发送到所有 slave，以完成一次完全同步。</p> 
<p>slave 节点在接收到数据库文件数据后，将其存盘并加载到内存中，从而完成复制初始化。</p> 
<p>🅰️ 3、心跳持续，保持通信</p> 
<p>master 节点会定期向 slave 节点发出 PING 包，周期默认是 10 秒。</p> 
<pre><code class="prism language-properties"># Master send PINGs to its replicas in a predefined interval. It's possible to
# change this interval with the repl_ping_replica_period option. The default
# value is 10 seconds.
#
# repl-ping-replica-period 10
</code></pre> 
<p>🅰️ 4、进入平稳，增量复制</p> 
<p>master 继续将新的所有收集到的修改命令自动依次传给 slave 完成增量同步。</p> 
<p>🅰️ 5、从机下线，重连续传</p> 
<p>master 会检查 backlog 里面的 offset，master 和 slave 都会保存一个复制的 offset 还有一个 masterId，offset 是保存在 backlog 中的。master 只会把已经复制的 offset 后面的数据复制给 slave，类似断点续传。</p> 
<p>🅰️ 1、复制的缺点</p> 
<p>1）复制延时，信号衰减</p> 
<p>由于所有的写操作都是先在 Master 上操作，然后同步更新到 Slave 上，所以从 Master 同步到 Slave 机器有一定的延迟，当系统很繁忙的时候，延迟问题会更加严重，Slave 机器数量的增加也会使这个问题更加严重。</p> 
<p>2）主机宕机了怎么办？</p> 
<p>主机宕机了，从机保持不变，在 slave 节点当中不会自动重选一个 master ，需要人工手动干预。麻烦。</p> 
<h2><a id="rainbow_Redis_sentinel_5631"></a>🌈 Redis 哨兵（sentinel）</h2> 
<p>非集群 Redis 的高可用性。</p> 
<p>Redis Sentinel 在不使用 Redis Cluster 时为 Redis 提供高可用性。</p> 
<p>Redis Sentinel 还提供其他附带任务，例如监控、通知，并充当客户端的配置提供者。</p> 
<p>🅰️ 1、是什么</p> 
<p>文档介绍：https://redis.io/docs/management/sentinel</p> 
<p>哨兵巡查监控后台 master 主机是否故障，如果故障了根据<code>投票数</code>自动将某一个从库转换为新主库，继续对外提供服务。</p> 
<p>哨兵的作用：</p> 
<p>1）监控 Redis 运行状态，包括 master 和 slave</p> 
<p>2）当 master down 机，能自动将 slave 切换成新 master</p> 
<p><img src="https://images2.imgbox.com/7e/6d/VOHup0KR_o.png" alt="在这里插入图片描述"></p> 
<p>🅰️ 2、能干嘛，即 Sentinel 功能</p> 
<ul><li>主从监控：监控主从 Redis 库运行是否正常</li><li>消息通知：哨兵可以将故障转移的结果发送给客户端</li><li>故障转移：如果 Master 异常，则会进行主从切换，将其中一个 Slave 作为新 Master</li><li>配置中心：客户端通过连接哨兵来获得当前 Redis 服务的主节点地址</li></ul> 
<p>Redis Sentinel 是一个分布式系统。</p> 
<p>Sentinel 本身设计为在多个 Sentinel 进程一起协作的配置中运行。多个 Sentinel 进程协作的优点如下：</p> 
<p>1）当多个 Sentinel 一致认为给定的 master 不再可用时，就会执行故障检测。这降低了误报的可能性。</p> 
<p>2）即使并非所有 Sentinel 进程都在工作，Sentinel 也会工作，从而使系统能够抵御故障。</p> 
<p>文档介绍：https://redis.io/docs/management/sentinel/#sentinel-as-a-distributed-system</p> 
<h3><a id="01Redis_Sentinel__5672"></a>01、Redis Sentinel 操作案例</h3> 
<p>文档介绍：https://redis.io/docs/management/sentinel/#sentinel-quick-start</p> 
<p>🅰️ 1、Redis Sentinel 架构说明</p> 
<p><img src="https://images2.imgbox.com/ac/93/D7er9Jd4_o.png" alt="在这里插入图片描述"></p> 
<ul><li>3 个哨兵：自动监控和维护集群，不存放数据，只是吹哨人</li><li>1 主 2 从 Redis 服务：用于数据的存储与查询</li></ul> 
<p>🅰️ 2、Redis Sentinel 配置文件说明</p> 
<p>新建 <code>sentinel.conf</code> 配置文件文件，名字固定。</p> 
<p>文档参考：https://redis.io/docs/management/sentinel/#configuring-sentinel</p> 
<p>重点参数项说明：</p> 
<p>1）<code>protected-mode</code> ：安全保护模式</p> 
<p>2）<code>port</code> ：端口</p> 
<p>3）<code>daemonize</code> ：是否以后台 daemon 方式运行</p> 
<p>4）<code>pidfile</code> ：pid 文件路径</p> 
<p>5）<code>logfile</code> ：日志文件路径</p> 
<p>6）<code>dir</code> ：工作目录</p> 
<p>7）<code>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</code> ：设置要监控的 master 服务器</p> 
<p>quorum 表示最少有几个哨兵认可客观下线，同意故障迁移的法定票数。</p> 
<pre><code class="prism language-properties"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;
#
# Tells Sentinel to monitor this master, and to consider it in O_DOWN
# (Objectively Down) state only if at least &lt;quorum&gt; sentinels agree.
#
# Note that whatever is the ODOWN quorum, a Sentinel will require to
# be elected by the majority of the known Sentinels in order to
# start a failover, so no failover can be performed in minority.
#
# Replicas are auto-discovered, so you don't need to specify replicas in
# any way. Sentinel itself will rewrite this configuration file adding
# the replicas using additional configuration options.
# Also note that the configuration file is rewritten when a
# replica is promoted to master.
#
# Note: master name should not include special characters or spaces.
# The valid charset is A-z 0-9 and the three characters ".-_".
sentinel monitor mymaster 127.0.0.1 6379 2
</code></pre> 
<ul><li>quorum 是指需要就主机不可访问这一事实达成一致的 Sentinel 数量，以便真正将主机标记为失败，并在可能的情况下最终启动故障转移过程。</li><li>quorum 仅用于检测故障。为了实际执行故障转移，其中一名 Sentinel 需要被选为故障转移的领导者，并获得继续进行故障转移的授权。只有大多数 Sentinel 进程投票时才会发生这种情况。</li></ul> 
<p>例如，如果有 5 个 Sentinel 进程，并且给定主进程的法定人数设置为 2，则会发生以下情况：</p> 
<ul><li>如果两个 Sentinel 同时同意主节点无法访问，则两个 Sentinel 之一将尝试启动故障转移。</li><li>如果总共至少有 3 个 Sentinel 可达，则故障转移将获得授权并实际启动。</li></ul> 
<p>8）<code>sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</code> ：master 设置了密码，连接 master 服务的密码</p> 
<pre><code class="prism language-properties"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;
#
# Set the password to use to authenticate with the master and replicas.
# Useful if there is a password set in the Redis instances to monitor.
#
# Note that the master password is also used for replicas, so it is not
# possible to set a different password in masters and replicas instances
# if you want to be able to monitor these instances with Sentinel.
#
# However you can have Redis instances without the authentication enabled
# mixed with Redis instances requiring the authentication (as long as the
# password set is the same for all the instances requiring the password) as
# the AUTH command will have no effect in Redis instances with authentication
# switched off.
#
# Example:
#
# sentinel auth-pass mymaster MySUPER--secret-0123passw0rd
</code></pre> 
<p>9）<code>sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;</code> ：指定多少毫秒之后，主节点没有应答哨兵，此时哨兵主观上认为主节点下线。</p> 
<pre><code class="prism language-properties"># sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt;
#
# Number of milliseconds the master (or any attached replica or sentinel) should
# be unreachable (as in, not acceptable reply to PING, continuously, for the
# specified period) in order to consider it in S_DOWN state (Subjectively
# Down).
#
# Default is 30 seconds.
sentinel down-after-milliseconds mymaster 30000
</code></pre> 
<p>10）<code>sentinel parallel-syncs &lt;master-name&gt; &lt;numreplicas&gt;</code> ：表示允许并行同步的 slave 个数，当 master 挂了后，哨兵会选出新的 master，此时，剩余的 slave 会向新的 master 发起同步数据。</p> 
<pre><code class="prism language-properties"># sentinel parallel-syncs &lt;master-name&gt; &lt;numreplicas&gt;
#
# How many replicas we can reconfigure to point to the new replica simultaneously
# during the failover. Use a low number if you use the replicas to serve query
# to avoid that all the replicas will be unreachable at about the same
# time while performing the synchronization with the master.
sentinel parallel-syncs mymaster 1
</code></pre> 
<p>11）<code>sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</code> ：故障转移的超时时间，进行故障转移时，如果超过设置的毫秒，表示故障转移失败。</p> 
<pre><code class="prism language-properties"># sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;
#
# Default is 3 minutes.
sentinel failover-timeout mymaster 180000
</code></pre> 
<p>12）<code>sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;</code> ：配置当某一事件发生时所需要执行的脚本</p> 
<pre><code class="prism language-properties"># NOTIFICATION SCRIPT
#
# sentinel notification-script &lt;master-name&gt; &lt;script-path&gt;
#
# Example:
#
# sentinel notification-script mymaster /var/redis/notify.sh
</code></pre> 
<p>13）<code>sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</code> ：客户端重新配置主节点参数脚本</p> 
<pre><code class="prism language-properties"># CLIENTS RECONFIGURATION SCRIPT
#
# sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;
#
# Example:
#
# sentinel client-reconfig-script mymaster /var/redis/reconfig.sh
</code></pre> 
<p>🅰️ 3、本案例 Sentinel 配置文件</p> 
<p>因成本问题，本案例中采用的 3 个哨兵都配置在同一台机器中。</p> 
<p>分别创建配置文件 sentinel_26380.conf、sentinel_26381.conf、sentinel_26382.conf。内容如下：</p> 
<pre><code class="prism language-properties">protected-mode no
port 26380
daemonize yes
pidfile /var/run/redis-sentinel-26380.pid
logfile "sentinel-26380.log"
dir /tmp
sentinel monitor mymaster 127.0.0.1 6380 2
sentinel auth-pass mymaster 123456
</code></pre> 
<p>🅰️ 4、启动运行测试</p> 
<p>1）先启动一主二从 3 个 Redis 实例，测试正常的主从复制。</p> 
<p>注意：</p> 
<p>主机 6380 后续可能会变成从机，需要设置访问新主机的密码，设置 masterauth 项访问密码，不然后续可能报错 <code>master_link_status:down</code>。</p> 
<pre><code class="prism language-properties">masterauth 123456
</code></pre> 
<p>分别启动 3 个 Redis 实例，确保一主二从正常运行。</p> 
<p>2）再启动 3 个哨兵，完成监控。</p> 
<p>文档介绍：https://redis.io/docs/management/sentinel/#running-sentinel</p> 
<pre><code class="prism language-sh">redis-server sentinel_6380.conf <span class="token parameter variable">--sentinel</span>
redis-server sentinel_6381.conf <span class="token parameter variable">--sentinel</span>
redis-server sentinel_6382.conf <span class="token parameter variable">--sentinel</span>
</code></pre> 
<p>sentinel_6380.conf 启动日志如下：</p> 
<pre><code class="prism language-properties">* Running mode=sentinel, port=26380.
* Sentinel new configuration saved on disk
# Sentinel ID is d950c6551aa09c371009651a14eef3d806d8b1b3
# +monitor master mymaster 127.0.0.1 6380 quorum 2
* +slave slave 127.0.0.1:6390 127.0.0.1 6390 @ mymaster 127.0.0.1 6380
* Sentinel new configuration saved on disk
* +slave slave 127.0.0.1:6391 127.0.0.1 6391 @ mymaster 127.0.0.1 6380
* Sentinel new configuration saved on disk
* +sentinel sentinel ef9a8ead3e48f38610d4e6a417f6c46872b52c4e 127.0.0.1 26381 @ mymaster 127.0.0.1 6380
* Sentinel new configuration saved on disk
* +sentinel sentinel fc07a99f9485786d7ae0517d30ef6f479ad3a62a 127.0.0.1 26382 @ mymaster 127.0.0.1 6380
* Sentinel new configuration saved on disk
</code></pre> 
<p>根据打印的日志：<code>Sentinel new configuration saved on disk</code>，再次查看配置文件 sentinel_6380.conf 多了如下内容：</p> 
<pre><code class="prism language-properties"># Generated by CONFIG REWRITE
latency-tracking-info-percentiles 50 99 99.9
user default on nopass sanitize-payload ~* &amp;* +@all
sentinel myid d950c6551aa09c371009651a14eef3d806d8b1b3
sentinel config-epoch mymaster 0
sentinel leader-epoch mymaster 0
sentinel current-epoch 0

sentinel known-replica mymaster 127.0.0.1 6391

sentinel known-replica mymaster 127.0.0.1 6390

sentinel known-sentinel mymaster 127.0.0.1 26382 fc07a99f9485786d7ae0517d30ef6f479ad3a62a

sentinel known-sentinel mymaster 127.0.0.1 26381 ef9a8ead3e48f38610d4e6a417f6c46872b52c4e

</code></pre> 
<p>3）启动 3 个哨兵监控后再测试一次主从复制</p> 
<p>一切正常：</p> 
<pre><code class="prism language-properties">&gt; 127.0.0.1@6380 connected!
&gt; set k9 v9
OK
&gt; info replication
# Replication
role:master
connected_slaves:2
slave0:ip=127.0.0.1,port=6390,state=online,offset=62276,lag=0
slave1:ip=127.0.0.1,port=6391,state=online,offset=62290,lag=0
master_failover_state:no-failover
master_replid:6e7c680cf396cfc21ea90fd4919924287e66d684
master_replid2:0c1e89fbd5de7a6f6d3346f9cf9a692bd9aeb67a
master_repl_offset:62290
second_repl_offset:17249
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:17249
repl_backlog_histlen:45042
</code></pre> 
<p>4）手动关闭 6380 主服务器，模拟 master 宕机</p> 
<pre><code class="prism language-sh">SHUTDOWN
</code></pre> 
<p>🅰️ 5、 问题思考❓</p> 
<ol><li>两台从机数据是否 OK ？</li><li>是否会从剩下的 2 台从机选出新的 master ？</li><li>之前 down 机的 master 机器重启回来，谁将会是新老大？会不会双 master 冲突？</li></ol> 
<p>1）问题一</p> 
<p>从机数据正常查询：</p> 
<pre><code class="prism language-sh"><span class="token operator">&gt;</span> <span class="token number">127.0</span>.0.1@6390 connected<span class="token operator">!</span>
<span class="token operator">&gt;</span> get key
hello

<span class="token operator">&gt;</span> <span class="token number">127.0</span>.0.1@6391 connected<span class="token operator">!</span>
<span class="token operator">&gt;</span> get key
hello
</code></pre> 
<p>2）问题二/三</p> 
<p>选出新的 master：</p> 
<pre><code class="prism language-properties">&gt; 127.0.0.1@6390 connected!
&gt; info replication
# Replication
role:master
connected_slaves:1
slave0:ip=127.0.0.1,port=6391,state=online,offset=365903,lag=1
master_failover_state:no-failover
master_replid:da5603777a8fcbeff561d8bcb79054c85bbb13fb
master_replid2:6e7c680cf396cfc21ea90fd4919924287e66d684
master_repl_offset:366302
second_repl_offset:294663
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:17249
repl_backlog_histlen:349054
&gt; set k10 v10
OK
</code></pre> 
<p>可见现在 6390 被选为主机，从机一个 6391。主机 6390 可以写入数据，且同步到从机 6391。</p> 
<p>也可以查看 sentinel-26380.log 日志：</p> 
<pre><code class="prism language-properties"># +sdown master mymaster 127.0.0.1 6380
# +odown master mymaster 127.0.0.1 6380 #quorum 2/2
# +new-epoch 1
# +try-failover master mymaster 127.0.0.1 6380
* Sentinel new configuration saved on disk
# +vote-for-leader d950c6551aa09c371009651a14eef3d806d8b1b3 1
# fc07a99f9485786d7ae0517d30ef6f479ad3a62a voted for d950c6551aa09c371009651a14eef3d806d8b1b3 1
# ef9a8ead3e48f38610d4e6a417f6c46872b52c4e voted for d950c6551aa09c371009651a14eef3d806d8b1b3 1
* Sentinel new configuration saved on disk
# +new-epoch 2
* Sentinel new configuration saved on disk
# +vote-for-leader ef9a8ead3e48f38610d4e6a417f6c46872b52c4e 2
# +config-update-from sentinel ef9a8ead3e48f38610d4e6a417f6c46872b52c4e 127.0.0.1 26381 @ mymaster 127.0.0.1 6380
# +switch-master mymaster 127.0.0.1 6380 127.0.0.1 6390
* +slave slave 127.0.0.1:6391 127.0.0.1 6391 @ mymaster 127.0.0.1 6390
* +slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6390
* Sentinel new configuration saved on disk
# +sdown slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6390
</code></pre> 
<p>重启 6380 ，可以看到日志又追加：</p> 
<pre><code class="prism language-properties">* +convert-to-slave slave 127.0.0.1:6380 127.0.0.1 6380 @ mymaster 127.0.0.1 6390
</code></pre> 
<p>6380 重启后是降级变成从机角色了：不能写入数据，能查询</p> 
<pre><code class="prism language-properties">&gt; 127.0.0.1@6380 connected!
&gt; info replication
# Replication
role:slave
master_host:127.0.0.1
master_port:6390
master_link_status:up
master_last_io_seconds_ago:1
master_sync_in_progress:0
slave_read_repl_offset:510388
slave_repl_offset:510388
slave_priority:100
slave_read_only:1
replica_announced:1
connected_slaves:0
master_failover_state:no-failover
master_replid:da5603777a8fcbeff561d8bcb79054c85bbb13fb
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:510388
second_repl_offset:-1
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:491354
repl_backlog_histlen:19035
&gt; set k11 v11
READONLY You can't write against a read only replica.
&gt; get k10
v10
</code></pre> 
<p>🅰️ 6、 经过上边的过程，现在查看配置文件的变化</p> 
<p>查看旧的 master 6380 的配置文件。在文件最后追加了配置，挂载到 6390 当从机</p> 
<pre><code class="prism language-properties"># Generated by CONFIG REWRITE
replicaof 127.0.0.1 6390
latency-tracking-info-percentiles 50 99 99.9
save 300 100
save 60 10000
user default on sanitize-payload #8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 ~* &amp;* +@all
</code></pre> 
<p>查看新的 master 6390 的配置文件。最初的配置项 <code>replicaof</code> 被删除，并在文件追加：</p> 
<pre><code class="prism language-properties"># Generated by CONFIG REWRITE
save 300 100
save 60 10000
latency-tracking-info-percentiles 50 99 99.9
user default on sanitize-payload #8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92 ~* &amp;* +@all
</code></pre> 
<p>查看从机 6391 的配置文件。最初的配置项 <code>replicaof</code> 被修改为 <code>replicaof 127.0.0.1 6390</code>。</p> 
<p>结论：</p> 
<p>文件的内容，在运行期间会被 sentinel 动态进行更改。</p> 
<p>master - slave 切换后，master 的配置、slave 的配置和 sentinel 的配置内容都会发生改变，即 master 配置中会多了 replicaof 的配置，sentinel.conf 的监控目标会随之调换。</p> 
<pre><code class="prism language-properties">sentinel known-replica mymaster 127.0.0.1 6380

sentinel known-replica mymaster 127.0.0.1 6391
</code></pre> 
<h3><a id="02_6074"></a>02、哨兵运行流程和选举原理</h3> 
<p>当一个主从配置中的 master 失效之后，sentinel 可以选举出一个新的 master 用于自动接替原 master 的工作，主从配置中的其他 Redis 服务器自动指向新的 master 同步数据。一般建议 sentinel 采取奇数台，防止某一台 sentinel 无法连接到 master 导致误切换。</p> 
<p>🅰️ 1、SDown 主观下线（Subjectively Down）</p> 
<p>SDown（主观不可用）是<code>单个 sentinel</code> 自己主观上检测到的关于 master 的状态，从 sentinel 的角度来看，如果发送了 PING 心跳后，在一定时间内没有收到合法的回复，就达到了 SDown 的条件。</p> 
<p>sentinel 配置文件中的 <code>down-after-milliseconds</code> 设置了判断主观下线的时间长度。</p> 
<pre><code class="prism language-properties"># Number of milliseconds the master (or any attached replica or sentinel) should
# be unreachable (as in, not acceptable reply to PING, continuously, for the
# specified period) in order to consider it in S_DOWN state (Subjectively
# Down).
#
# Default is 30 seconds.
sentinel down-after-milliseconds mymaster 30000
</code></pre> 
<p>sentinel down-after-milliseconds 表示 master 被当前 sentinel 实例认定为失效的间隔时间，这个配置其实就是进行主观下线的一个依据。</p> 
<p>master 在多长时间内一直没有给 sentine 返回有效信息，则认定该 master 主观下线。也就是说如果多久没联系上redis-servevr，认为这个 redis-server 进入到失效（SDOWN）状态。</p> 
<p>🅰️ 2、ODown 客观下线（Objectively Down）</p> 
<p>ODown 需要一定数量的 sentinel，多个哨兵达成一致意见才能认为一个 master 客观上已经挂了。</p> 
<pre><code class="prism language-properties"># sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;
#
# Tells Sentinel to monitor this master, and to consider it in O_DOWN
# (Objectively Down) state only if at least &lt;quorum&gt; sentinels agree.
#
# Note that whatever is the ODOWN quorum, a Sentinel will require to
# be elected by the majority of the known Sentinels in order to
# start a failover, so no failover can be performed in minority.
#
# Replicas are auto-discovered, so you don't need to specify replicas in
# any way. Sentinel itself will rewrite this configuration file adding
# the replicas using additional configuration options.
# Also note that the configuration file is rewritten when a
# replica is promoted to master.
#
# Note: master name should not include special characters or spaces.
# The valid charset is A-z 0-9 and the three characters ".-_".
sentinel monitor mymaster 127.0.0.1 6379 2
</code></pre> 
<ul><li><code>&lt;master-name&gt;</code> 是对某个 master+slave 组合的一个区分标识（一套 sentinel 可以监听多组 master+slave 这样的组合）</li><li><code>&lt;quorum&gt;</code> 这个参数是进行客观下线的一个依据，法定人数/法定票数</li></ul> 
<p>意思是至少有 quorum 个 sentinel 认为这个 master 有故障才会对这个 master 进行下线以及故障转移。因为有的时候，某个 sentinel 节点可能因为自身网络原因导致无法连接 master，而此时 master 并没有出现故障，所以这就需要多个 sentinel 都一致认为该 master 有问题，才可以进行下一步操作，这就保证了公平性和高可用。</p> 
<p>🅰️ 3、选举出领导者哨兵（哨兵中选出兵王）</p> 
<p>当主节点被判断客观下线以后，各个哨兵节点会进行协商，先选举出一个领导者哨兵节点（leader）并由该领导者节点，也即被选举出的兵王进行 failover（故障迁移）。</p> 
<p>1）哨兵日志文件解读分析</p> 
<p><img src="https://images2.imgbox.com/81/23/IdalHxTz_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/63/01/0sGWvHGc_o.png" alt="在这里插入图片描述"></p> 
<p>2）哨兵领导者，兵王如何选出来的？</p> 
<p>Raft 算法</p> 
<p><img src="https://images2.imgbox.com/56/ba/V8Ev7B6N_o.png" alt="在这里插入图片描述"></p> 
<p>监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是 Raft 算法；Raft 算法的基本思路是先到先得：即在一轮选举中，哨兵 A 向 B 发送成为领导者的申请，如果 B 没有同意过其他哨兵，则会同意 A 成为领导者。</p> 
<p>🅰️ 4、由哨兵 leader 开始推动故障切换流程并选出一个新 master</p> 
<p>3 步骤：</p> 
<p>1）选出新主</p> 
<p>选出新 master 的规则，剩余 slave 节点健康前提下。</p> 
<p><img src="https://images2.imgbox.com/23/ec/zw0CnnN6_o.png" alt="在这里插入图片描述"></p> 
<p>redis.conf 文件中，优先级 slave-priority 或者 replica-priority 最高的从节点（数字越小优先级越高）</p> 
<pre><code class="prism language-properties"># The replica priority is an integer number published by Redis in the INFO
# output. It is used by Redis Sentinel in order to select a replica to promote
# into a master if the master is no longer working correctly.
#
# A replica with a low priority number is considered better for promotion, so
# for instance if there are three replicas with priority 10, 100, 25 Sentinel
# will pick the one with priority 10, that is the lowest.
#
# However a special priority of 0 marks the replica as not able to perform the
# role of master, so a replica with priority of 0 will never be selected by
# Redis Sentinel for promotion.
#
# By default the priority is 100.
replica-priority 100
</code></pre> 
<p>复制偏移位置 offset 最大的从节点。（选择从节点中数据完整度高的）</p> 
<p>最小 Run ID 的从节点。（每个 Redis 实例启动后都会随机生成一个 40 位的 Run ID）</p> 
<p>2）重新绑定关系</p> 
<p>会执行 <code>slaveof no one</code> 命令让选出来的从节点成为新的主节点，并通过 <code>slaveof</code> 命令让其他节点成为其从节点。</p> 
<ol><li>Sentinel leader 会对选举出的新 master 执行 <code>slaveof no one</code> 操作，将其提升为 master 节点。</li><li>Sentinel leader 向其它 slave 发送 <code>slaveof</code> 命令，让剩余的 slave 成为新的 master 节点的 slave。</li></ol> 
<p>3）旧主回来当 slave</p> 
<p>将之前已下线的旧 master 设置为新选出的新 master 的从节点，当旧 master 重新上线后，它会成为新 master 的从节点。</p> 
<p>Sentinel leader 会让原来的 master 降级为 slave 并恢复正常工作。</p> 
<p>总结：</p> 
<p>上述的 failover 操作均由 sentinel 自己独自完成，完全无需人工干预。</p> 
<p><img src="https://images2.imgbox.com/0d/60/zqiN6T7E_o.png" alt="在这里插入图片描述"></p> 
<p>🅰️ 3、哨兵使用建议</p> 
<ul><li>哨兵节点的数量应为多个，哨兵本身应该集群，保证高可用</li><li>哨兵节点的数量应该是奇数</li><li>各个哨兵节点的配置应一致</li><li>如果哨兵节点部署在 Docker 等容器里面，尤其要注意端口的正确映射</li><li>哨兵集群+主从复制，并不能保证数据零丢失 ❗️（见 Redis 集群篇）</li></ul> 
<h2><a id="rainbow_Redis_cluster_6211"></a>🌈 Redis 集群（cluster）</h2> 
<p>使用 Redis 集群进行扩展：https://redis.io/docs/management/scaling</p> 
<p>🍉 Redis 集群规范（算法和设计原理）：https://redis.io/docs/reference/cluster-spec</p> 
<h3><a id="01Redis_Cluster__6217"></a>01、Redis Cluster 介绍</h3> 
<p>编辑中。。。</p> 
<h2><a id="rainbow_Spring_Boot__Redis_6221"></a>🌈 Spring Boot 集成 Redis</h2> 
<p>🅰️ 1、使用 Jedis 客户端集成</p> 
<p>Jedis Client 是 Redis 官网推荐的一个面向 Java 客户端，库文件实现了对各类 API 进行封装调用。</p> 
<p>文档：https://github.com/redis/jedis</p> 
<p>1）引入依赖</p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>redis.clients<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>jedis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>4.4.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>2）基础操作</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">Jedis</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span></span><span class="token class-name">JedisPool</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">redis<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>jedis<span class="token punctuation">.</span>resps<span class="token punctuation">.</span></span><span class="token class-name">Tuple</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Map</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Set</span></span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Jedis 客户端测试
 *
 * @author Don
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JedisClientTest</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">JedisPool</span> pool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisPool</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Jedis</span> jedis <span class="token operator">=</span> pool<span class="token punctuation">.</span><span class="token function">getResource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">ping</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// key</span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> keys <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        keys<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// String</span>
        <span class="token class-name">String</span> setString <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"jedis"</span><span class="token punctuation">,</span> <span class="token string">"Hello Jedis"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> getString <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"jedis"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>setString <span class="token operator">+</span> <span class="token string">" \t"</span> <span class="token operator">+</span> getString<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Hash</span>
        <span class="token keyword">long</span> hashSet <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"jedis-hash"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Don"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> hashSet2 <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"jedis-hash"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token string">"18"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> hashGetAll <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">hgetAll</span><span class="token punctuation">(</span><span class="token string">"jedis-hash"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hashSet <span class="token operator">+</span> <span class="token string">" \t"</span> <span class="token operator">+</span> hashSet2 <span class="token operator">+</span> <span class="token string">" \t"</span> <span class="token operator">+</span> hashGetAll<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// List</span>
        <span class="token keyword">long</span> listPush <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">lpush</span><span class="token punctuation">(</span><span class="token string">"jedis-list"</span><span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"Redis"</span><span class="token punctuation">,</span> <span class="token string">"Jedis"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> listRange <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">lrange</span><span class="token punctuation">(</span><span class="token string">"jedis-list"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>listPush <span class="token operator">+</span> <span class="token string">" \t"</span> <span class="token operator">+</span> listRange<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Set</span>
        <span class="token keyword">long</span> setAdd <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">sadd</span><span class="token punctuation">(</span><span class="token string">"jedis-set-game"</span><span class="token punctuation">,</span> <span class="token string">"u1"</span><span class="token punctuation">,</span> <span class="token string">"u2"</span><span class="token punctuation">,</span> <span class="token string">"u3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>setAdd <span class="token operator">+</span> <span class="token string">" \t"</span> <span class="token operator">+</span> jedis<span class="token punctuation">.</span><span class="token function">scard</span><span class="token punctuation">(</span><span class="token string">"jedis-set-game"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">srandmember</span><span class="token punctuation">(</span><span class="token string">"jedis-set-game"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">srandmember</span><span class="token punctuation">(</span><span class="token string">"jedis-set-game"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">srandmember</span><span class="token punctuation">(</span><span class="token string">"jedis-set-game"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// ZSet</span>
        jedis<span class="token punctuation">.</span><span class="token function">zadd</span><span class="token punctuation">(</span><span class="token string">"jedis-set-rank"</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token string">"m1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jedis<span class="token punctuation">.</span><span class="token function">zadd</span><span class="token punctuation">(</span><span class="token string">"jedis-set-rank"</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token string">"m2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jedis<span class="token punctuation">.</span><span class="token function">zadd</span><span class="token punctuation">(</span><span class="token string">"jedis-set-rank"</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token string">"m3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Tuple</span><span class="token punctuation">&gt;</span></span> zSetRange <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">zrangeWithScores</span><span class="token punctuation">(</span><span class="token string">"jedis-set-rank"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zSetRange<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>🅰️ 2、使用 Lettuce 客户端集成</p> 
<p>Lettuce 是一个线程安全的 Redis Java 客户端。Lettuce 是一个完全非阻塞的 Redis 客户端，使用 Netty 构建，提供反应式、异步和同步数据访问。</p> 
<p>文档：https://lettuce.io</p> 
<p>1）Lettuce VS Jedis</p> 
<p>都是 Redis 的客户端，在 Spring Boot 2 之后默认使用的 Letuce 客户端连接 Redis 服务器。因为当使用 Jedis 客户端连接 Redis 服务器的时候，每个线程都要拿自己创建的 Jedis 实例去连接 Redis 客户端，当有很多个线程的时候，不仅开销大需要反复的创建关闭一个 Jedis 连接，而且也是线程不安全的，一个线程通过 Jedis 实例更改 Redis 服务器中的数据之后会影响另一个线程。</p> 
<p>使用 Lettuce 这个客户端连接 Redis 服务器的时候，就不会出现上面的情况，Lettuce 底层使用的是 Netty，多个线程都需要连接 Redis 服务器的时候，可以保证只创建一个 Letluce 连接，使所有的线程共享这一个 Lettuce 连接，这样可以减少创建关闭一个 Letuce 连接时候的开销。而这种方式也是线程安全的，不会出现一个线程通过 Lettuce 更改 Redis 服务器中的数据之后而影响另一个线程的情况。</p> 
<p>2）引入依赖</p> 
<pre><code class="prism language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>io.lettuce<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>lettuce-core<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>6.2.5.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>3）基础操作</p> 
<pre><code class="prism language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">RedisClient</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">RedisURI</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>core<span class="token punctuation">.</span></span><span class="token class-name">ScoredValue</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>core<span class="token punctuation">.</span>api<span class="token punctuation">.</span></span><span class="token class-name">StatefulRedisConnection</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">io<span class="token punctuation">.</span>lettuce<span class="token punctuation">.</span>core<span class="token punctuation">.</span>api<span class="token punctuation">.</span>sync<span class="token punctuation">.</span></span><span class="token class-name">RedisCommands</span></span><span class="token punctuation">;</span>

<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">Map</span></span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Lettuce 客户端测试
 *
 * @author Don
 */</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LettuceClientTest</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token class-name">RedisURI</span> redisURI <span class="token operator">=</span> <span class="token class-name">RedisURI</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token string">"127.0.0.1"</span><span class="token punctuation">,</span> <span class="token number">6379</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">RedisClient</span> redisClient <span class="token operator">=</span> <span class="token class-name">RedisClient</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>redisURI<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">StatefulRedisConnection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> connection <span class="token operator">=</span> redisClient<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">RedisCommands</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stringRedisCommand <span class="token operator">=</span> connection<span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// key</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> keys <span class="token operator">=</span> stringRedisCommand<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        keys<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token operator">::</span><span class="token function">println</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// String</span>
        <span class="token class-name">String</span> setString <span class="token operator">=</span> stringRedisCommand<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">"lettuce"</span><span class="token punctuation">,</span> <span class="token string">"Hello Lettuce"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> getString <span class="token operator">=</span> stringRedisCommand<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"lettuce"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>setString <span class="token operator">+</span> <span class="token string">" \t"</span> <span class="token operator">+</span> getString <span class="token operator">+</span> <span class="token string">" \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Hash</span>
        <span class="token class-name">Boolean</span> hashSet <span class="token operator">=</span> stringRedisCommand<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"lettuce-hash"</span><span class="token punctuation">,</span> <span class="token string">"name"</span><span class="token punctuation">,</span> <span class="token string">"Don"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Boolean</span> hashSet2 <span class="token operator">=</span> stringRedisCommand<span class="token punctuation">.</span><span class="token function">hset</span><span class="token punctuation">(</span><span class="token string">"lettuce-hash"</span><span class="token punctuation">,</span> <span class="token string">"age"</span><span class="token punctuation">,</span> <span class="token string">"18"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> hashGetAll <span class="token operator">=</span> stringRedisCommand<span class="token punctuation">.</span><span class="token function">hgetall</span><span class="token punctuation">(</span><span class="token string">"lettuce-hash"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>hashSet <span class="token operator">+</span> <span class="token string">" \t"</span> <span class="token operator">+</span> hashSet2 <span class="token operator">+</span> <span class="token string">" \t"</span> <span class="token operator">+</span> hashGetAll <span class="token operator">+</span> <span class="token string">" \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// List</span>
        <span class="token keyword">long</span> listPush <span class="token operator">=</span> stringRedisCommand<span class="token punctuation">.</span><span class="token function">lpush</span><span class="token punctuation">(</span><span class="token string">"lettuce-list"</span><span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"Redis"</span><span class="token punctuation">,</span> <span class="token string">"Lettuce"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> listRange <span class="token operator">=</span> stringRedisCommand<span class="token punctuation">.</span><span class="token function">lrange</span><span class="token punctuation">(</span><span class="token string">"lettuce-list"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>listPush <span class="token operator">+</span> <span class="token string">" \t"</span> <span class="token operator">+</span> listRange <span class="token operator">+</span> <span class="token string">" \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Set</span>
        <span class="token keyword">long</span> setAdd <span class="token operator">=</span> stringRedisCommand<span class="token punctuation">.</span><span class="token function">sadd</span><span class="token punctuation">(</span><span class="token string">"lettuce-set-game"</span><span class="token punctuation">,</span> <span class="token string">"u1"</span><span class="token punctuation">,</span> <span class="token string">"u2"</span><span class="token punctuation">,</span> <span class="token string">"u3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>setAdd <span class="token operator">+</span> <span class="token string">" \t"</span> <span class="token operator">+</span> stringRedisCommand<span class="token punctuation">.</span><span class="token function">scard</span><span class="token punctuation">(</span><span class="token string">"lettuce-set-game"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stringRedisCommand<span class="token punctuation">.</span><span class="token function">srandmember</span><span class="token punctuation">(</span><span class="token string">"lettuce-set-game"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stringRedisCommand<span class="token punctuation">.</span><span class="token function">srandmember</span><span class="token punctuation">(</span><span class="token string">"lettuce-set-game"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>stringRedisCommand<span class="token punctuation">.</span><span class="token function">srandmember</span><span class="token punctuation">(</span><span class="token string">"lettuce-set-game"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// ZSet</span>
        stringRedisCommand<span class="token punctuation">.</span><span class="token function">zadd</span><span class="token punctuation">(</span><span class="token string">"lettuce-set-rank"</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token string">"m1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stringRedisCommand<span class="token punctuation">.</span><span class="token function">zadd</span><span class="token punctuation">(</span><span class="token string">"lettuce-set-rank"</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token string">"m2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        stringRedisCommand<span class="token punctuation">.</span><span class="token function">zadd</span><span class="token punctuation">(</span><span class="token string">"lettuce-set-rank"</span><span class="token punctuation">,</span> <span class="token number">90</span><span class="token punctuation">,</span> <span class="token string">"m3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ScoredValue</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> zRangeWithScores <span class="token operator">=</span> stringRedisCommand<span class="token punctuation">.</span><span class="token function">zrangeWithScores</span><span class="token punctuation">(</span><span class="token string">"lettuce-set-rank"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zRangeWithScores<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// GEO</span>
        <span class="token class-name">Long</span> geoAdd <span class="token operator">=</span> stringRedisCommand<span class="token punctuation">.</span><span class="token function">geoadd</span><span class="token punctuation">(</span><span class="token string">"lettuce-geo"</span><span class="token punctuation">,</span> <span class="token number">116.403963</span><span class="token punctuation">,</span> <span class="token number">39.915119</span><span class="token punctuation">,</span> <span class="token string">"天安门"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>geoAdd <span class="token operator">+</span> <span class="token string">" \t"</span> <span class="token operator">+</span> stringRedisCommand<span class="token punctuation">.</span><span class="token function">geopos</span><span class="token punctuation">(</span><span class="token string">"lettuce-geo"</span><span class="token punctuation">,</span> <span class="token string">"天安门"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        connection<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        redisClient<span class="token punctuation">.</span><span class="token function">shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>🅰️ 3、集成 RedisTemplate</p> 
<p>文档：https://docs.spring.io/spring-boot/docs/2.7.14/reference/html/data.html#data.nosql.redis</p> 
<p>文档：https://spring.io/projects/spring-data-redis</p> 
<p>1）引入依赖</p> 
<pre><code class="prism language-xml"><span class="token comment">&lt;!-- Spring Data Redis --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
<span class="token comment">&lt;!-- Lettuce 需要使用的连接池 --&gt;</span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.apache.commons<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>commons-pool2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.11.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>
</code></pre> 
<p>spring-boot-starter-data-redis 默认使用 lettuce 作为连接 Redis 的客户端。</p> 
<p>2）配置 YML</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> springboot<span class="token punctuation">-</span>redis
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">database</span><span class="token punctuation">:</span> <span class="token number">0</span>
    <span class="token key atrule">host</span><span class="token punctuation">:</span> 127.0.0.1
    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">6379</span>
    <span class="token key atrule">client-name</span><span class="token punctuation">:</span> springboot<span class="token punctuation">-</span>redis
    <span class="token key atrule">client-type</span><span class="token punctuation">:</span> lettuce
    <span class="token key atrule">lettuce</span><span class="token punctuation">:</span>
      <span class="token key atrule">pool</span><span class="token punctuation">:</span>
        <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
        <span class="token comment"># 连接池最大连接数（默认为8, 使用负值表示没有限制）</span>
        <span class="token key atrule">max-active</span><span class="token punctuation">:</span> <span class="token number">8</span>
        <span class="token comment"># 连接池中的最大空闲连接（默认为8）</span>
        <span class="token key atrule">max-idle</span><span class="token punctuation">:</span> <span class="token number">8</span>
        <span class="token comment"># 连接池中的最小空闲连接（默认为0）</span>
        <span class="token key atrule">min-idle</span><span class="token punctuation">:</span> <span class="token number">0</span>
        <span class="token comment"># 连接池最大阻塞等待时间（默认为-1, 使用负值表示没有限制）</span>
        <span class="token key atrule">max-wait</span><span class="token punctuation">:</span> 3000ms
        <span class="token comment"># 空闲对象逐出器线程的运行间隔时间. 空闲连接线程释放周期时间.</span>
        <span class="token key atrule">time-between-eviction-runs</span><span class="token punctuation">:</span> 3000ms
</code></pre> 
<p>3）编写业务</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderService</span> <span class="token punctuation">{<!-- --></span>

    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">ORDER_KEY</span> <span class="token operator">=</span> <span class="token string">"order:"</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> redisTemplate<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> keyId <span class="token operator">=</span> <span class="token class-name">ThreadLocalRandom</span><span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> orderNo <span class="token operator">=</span> <span class="token constant">UUID</span><span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token constant">ORDER_KEY</span> <span class="token operator">+</span> keyId<span class="token punctuation">,</span> <span class="token string">"订单"</span> <span class="token operator">+</span> orderNo<span class="token punctuation">)</span><span class="token punctuation">;</span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"编号: {} 的订单流水: {}"</span><span class="token punctuation">,</span> keyId<span class="token punctuation">,</span> orderNo<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> keyId<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token constant">ORDER_KEY</span> <span class="token operator">+</span> keyId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OrderController</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">OrderService</span> orderService<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@PostMapping</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        orderService<span class="token punctuation">.</span><span class="token function">addOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"/{id}"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">findUserById</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> <span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> orderService<span class="token punctuation">.</span><span class="token function">getOrder</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>4）测试</p> 
<pre><code class="prism language-properties">OrderService    : 编号: 548 的订单流水: f36dd085-ba21-4520-bd8c-fde5f75172fa
</code></pre> 
<p>成功存储与查看。</p> 
<p>现在通过客户端查看 Redis 数据：</p> 
<p><img src="https://images2.imgbox.com/77/5b/kXmJ6HSL_o.png" alt="在这里插入图片描述"></p> 
<p>发现出现乱码了。。。</p> 
<p>5）序列化问题</p> 
<p>键（key）和值（value）都是通过 Spring 提供的 Serializer 序列化到数据库的。</p> 
<p>RedisTemplate 默认使用的是 JDK 序列化方式 （JdkSerializationRedisSerializer）。</p> 
<p><code>org.springframework.data.redis.serializer.JdkSerializationRedisSerializer</code> 。</p> 
<p>默认情况下，RedisTemplate 使用该数据列化方式，可以看下源码 <code>RedisTemplate#afterPropertiesSet()</code></p> 
<pre><code class="prism language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">boolean</span> defaultUsed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>defaultSerializer <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>defaultSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JdkSerializationRedisSerializer</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>classLoader <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>classLoader <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">// ....</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>StringRedisTemplate 默认使用的是 StringRedisSerializer。</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StringRedisTemplate</span> <span class="token keyword">extends</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token class-name">StringRedisTemplate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span><span class="token class-name">RedisSerializer</span><span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setValueSerializer</span><span class="token punctuation">(</span><span class="token class-name">RedisSerializer</span><span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setHashKeySerializer</span><span class="token punctuation">(</span><span class="token class-name">RedisSerializer</span><span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setHashValueSerializer</span><span class="token punctuation">(</span><span class="token class-name">RedisSerializer</span><span class="token punctuation">.</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">StringRedisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> connectionFactory<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>connectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">afterPropertiesSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">protected</span> <span class="token class-name">RedisConnection</span> <span class="token function">preProcessConnection</span><span class="token punctuation">(</span><span class="token class-name">RedisConnection</span> connection<span class="token punctuation">,</span> <span class="token keyword">boolean</span> existingConnection<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">DefaultStringRedisConnection</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>6）自定义序列化</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RedisConfig</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">/**
     * 自定义序列化规则
     */</span>
    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">redisTemplate</span><span class="token punctuation">(</span><span class="token class-name">RedisConnectionFactory</span> redisConnectionFactory<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token comment">// 创建 RedisTemplate 对象</span>
        <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> redisTemplate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisTemplate</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// 设置 RedisConnection 工厂（实现多种 Java Redis 客户端接入的工厂）</span>
        redisTemplate<span class="token punctuation">.</span><span class="token function">setConnectionFactory</span><span class="token punctuation">(</span>redisConnectionFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Key 的序列化</span>
        redisTemplate<span class="token punctuation">.</span><span class="token function">setKeySerializer</span><span class="token punctuation">(</span><span class="token class-name">StringRedisSerializer</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        redisTemplate<span class="token punctuation">.</span><span class="token function">setHashKeySerializer</span><span class="token punctuation">(</span><span class="token class-name">StringRedisSerializer</span><span class="token punctuation">.</span><span class="token constant">UTF_8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">// Value 的序列化</span>

        <span class="token comment">// 使用 Jackson2JsonRedisSerialize 替换默认序列化</span>
        <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> jackson2JsonRedisSerializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Jackson2JsonRedisSerializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">ObjectMapper</span> mapper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectMapper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        mapper<span class="token punctuation">.</span><span class="token function">setVisibility</span><span class="token punctuation">(</span><span class="token class-name">PropertyAccessor</span><span class="token punctuation">.</span><span class="token constant">ALL</span><span class="token punctuation">,</span> <span class="token class-name">JsonAutoDetect<span class="token punctuation">.</span>Visibility</span><span class="token punctuation">.</span><span class="token constant">ANY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        mapper<span class="token punctuation">.</span><span class="token function">activateDefaultTyping</span><span class="token punctuation">(</span>mapper<span class="token punctuation">.</span><span class="token function">getPolymorphicTypeValidator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">ObjectMapper<span class="token punctuation">.</span>DefaultTyping</span><span class="token punctuation">.</span><span class="token constant">NON_FINAL</span><span class="token punctuation">,</span> <span class="token class-name">JsonTypeInfo<span class="token punctuation">.</span>As</span><span class="token punctuation">.</span><span class="token constant">PROPERTY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        jackson2JsonRedisSerializer<span class="token punctuation">.</span><span class="token function">setObjectMapper</span><span class="token punctuation">(</span>mapper<span class="token punctuation">)</span><span class="token punctuation">;</span>

        redisTemplate<span class="token punctuation">.</span><span class="token function">setDefaultSerializer</span><span class="token punctuation">(</span>jackson2JsonRedisSerializer<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> redisTemplate<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre> 
<p>再次测试，成功解决。</p> 
<p><img src="https://images2.imgbox.com/9a/2d/6z3YyiPh_o.png" alt="在这里插入图片描述"></p> 
<p>🅰️ 4、集成 Redis 集群</p> 
<p>1）启动 Redis 集群 6 个实例</p> 
<pre><code class="prism language-properties">127.0.0.1:6381&gt; cluster nodes
f3f9e80fe1186a3a85f54052a9b8a1546283b377 127.0.0.1:6381@16381,,shard-id=3a9b035f1594f61360e9003daa61ff05e78c44fe myself,master - 0 1690183401000 10 connected 0-6826 10923-12287
481f2585f911cbe0be70f038df13b771a1d7066a 127.0.0.1:6382@16382,,shard-id=ce67000eb0122d4015af9ea99a32c25f37a8b5e3 master - 0 1690183401846 2 connected 6827-10922
87611964f51a161e1c2d21da3b52f3397344fcbb 127.0.0.1:6383@16383,,shard-id=d70b6fd1b6296a17040bff38e93b31bfd186835f master - 0 1690183402000 3 connected 12288-16383
186eeae11f01c64266e28bb35aa7f8dec4662c0e 127.0.0.1:6384@16384,,shard-id=3a9b035f1594f61360e9003daa61ff05e78c44fe slave f3f9e80fe1186a3a85f54052a9b8a1546283b377 0 1690183402506 10 connected
3f966ff72fea5dcb091bb584f1c0987f080502c8 127.0.0.1:6385@16385,,shard-id=ce67000eb0122d4015af9ea99a32c25f37a8b5e3 slave 481f2585f911cbe0be70f038df13b771a1d7066a 0 1690183403057 2 connected
329ef5e839a9a1ecc697812fdaad0ddd658ba12f 127.0.0.1:6386@16386,,shard-id=d70b6fd1b6296a17040bff38e93b31bfd186835f slave 87611964f51a161e1c2d21da3b52f3397344fcbb 0 1690183402506 3 connected
127.0.0.1:6381&gt;
</code></pre> 
<p>2）修改 YML 配置</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">application</span><span class="token punctuation">:</span>
    <span class="token key atrule">name</span><span class="token punctuation">:</span> springboot<span class="token punctuation">-</span>redis
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">database</span><span class="token punctuation">:</span> <span class="token number">0</span>
    <span class="token key atrule">password</span><span class="token punctuation">:</span> <span class="token number">123456</span>
    <span class="token key atrule">client-name</span><span class="token punctuation">:</span> springboot<span class="token punctuation">-</span>redis
    <span class="token key atrule">client-type</span><span class="token punctuation">:</span> lettuce
    <span class="token key atrule">lettuce</span><span class="token punctuation">:</span>
      <span class="token key atrule">pool</span><span class="token punctuation">:</span>
        <span class="token key atrule">enabled</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
        <span class="token comment"># 连接池最大连接数（默认为8, 使用负值表示没有限制）</span>
        <span class="token key atrule">max-active</span><span class="token punctuation">:</span> <span class="token number">8</span>
        <span class="token comment"># 连接池中的最大空闲连接（默认为8）</span>
        <span class="token key atrule">max-idle</span><span class="token punctuation">:</span> <span class="token number">8</span>
        <span class="token comment"># 连接池中的最小空闲连接（默认为0）</span>
        <span class="token key atrule">min-idle</span><span class="token punctuation">:</span> <span class="token number">0</span>
        <span class="token comment"># 连接池最大阻塞等待时间（默认为-1, 使用负值表示没有限制）</span>
        <span class="token key atrule">max-wait</span><span class="token punctuation">:</span> 3000ms
        <span class="token comment"># 空闲对象逐出器线程的运行间隔时间. 空闲连接线程释放周期时间.</span>
        <span class="token key atrule">time-between-eviction-runs</span><span class="token punctuation">:</span> 3000ms
    <span class="token key atrule">cluster</span><span class="token punctuation">:</span>
      <span class="token comment"># 集群节点的“初始”列表</span>
      <span class="token key atrule">nodes</span><span class="token punctuation">:</span> 127.0.0.1<span class="token punctuation">:</span><span class="token number">6381</span><span class="token punctuation">,</span>127.0.0.1<span class="token punctuation">:</span><span class="token number">6382</span><span class="token punctuation">,</span>127.0.0.1<span class="token punctuation">:</span><span class="token number">6383</span><span class="token punctuation">,</span>127.0.0.1<span class="token punctuation">:</span><span class="token number">6384</span><span class="token punctuation">,</span>127.0.0.1<span class="token punctuation">:</span><span class="token number">6385</span><span class="token punctuation">,</span>127.0.0.1<span class="token punctuation">:</span><span class="token number">6386</span>
      <span class="token comment"># 在集群中执行命令时要遵循的最大重定向数</span>
      <span class="token key atrule">max-redirects</span><span class="token punctuation">:</span> <span class="token number">3</span>
</code></pre> 
<p>3）直接通过微服务访问 Redis 集群操作数据，成功存取数据</p> 
<p>4）手动模拟宕机</p> 
<p>手动模拟宕机，master-6381 机器意外宕机，手动 shutdown。</p> 
<p>先对 Redis 集群以命令方式，手动验证各种读写命令，看看 6384 从机是否正常切换到 master。</p> 
<p>一切正常，Redis Cluster 集群能自动感知并自动完成主备切换，对应的 slave-6384 会被选举为新的 master 节点。</p> 
<pre><code class="prism language-properties">&gt;redis-cli -a 123456 -p 6384
Warning: Using a password with '-a' or '-u' option on the command line interface may not be safe.
127.0.0.1:6384&gt; info replication
# Replication
role:master
connected_slaves:0
master_failover_state:no-failover
master_replid:4a8cfe2459f8617c34b01b7bb16f790a6bd48d2c
master_replid2:12e53068f3fd7c908020f437e8532ce98864b1d6
master_repl_offset:1292
second_repl_offset:1293
repl_backlog_active:1
repl_backlog_size:1048576
repl_backlog_first_byte_offset:1
repl_backlog_histlen:1292
127.0.0.1:6384&gt; set k3 v3
OK
127.0.0.1:6384&gt; set k4 v5
-&gt; Redirected to slot [8455] located at 127.0.0.1:6382
OK
127.0.0.1:6382&gt;
</code></pre> 
<p>5）微服务客户端再次读写访问试试</p> 
<p>此时出现问题了，故障现象：<strong><code>SpringBoot 客户端没有动态感知到 RedisCluster 的最新集群信息</code></strong></p> 
<p>❌ 经典 2 个故障：</p> 
<pre><code class="prism language-properties">io.lettuce.core.RedisCommandTimeoutException: Command timed out after 1 minute(s)
</code></pre> 
<pre><code class="prism language-properties">Reconnecting, last destination was 127.0.0.1:6381
Cannot reconnect to [127.0.0.1:6381]: Connection refused: no further information: /127.0.0.1:6381
</code></pre> 
<p>导致原因：</p> 
<p>SpringBoot 2 版本，Redis 默认的连接池采用 Lettuce，当 Redis 集群节点发生变化后，Letture 默认是不会刷新节点拓扑关系。</p> 
<p>♻️ 解决方案：</p> 
<p>1、排除 lettuce 采用 jedis 客户端（不推荐）</p> 
<p>2、重写连接工厂实例（极度不推荐）</p> 
<pre><code class="prism language-java">    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">DefaultClientResources</span> <span class="token function">lettuceClientResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token class-name">DefaultClientResources</span><span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Bean</span>
    <span class="token keyword">public</span> <span class="token class-name">LettuceConnectionFactory</span> <span class="token function">lettuceConnectionFactory</span><span class="token punctuation">(</span><span class="token class-name">RedisProperties</span> redisProperties<span class="token punctuation">,</span> <span class="token class-name">ClientResources</span> clientResources<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token class-name">ClusterTopologyRefreshOptions</span> topologyRefreshOptions <span class="token operator">=</span> <span class="token class-name">ClusterTopologyRefreshOptions</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">enablePeriodicRefresh</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">//按照周期刷新拓扑</span>
                <span class="token punctuation">.</span><span class="token function">enableAllAdaptiveRefreshTriggers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//根据事件刷新拓扑</span>
                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">ClusterClientOptions</span> clusterClientOptions <span class="token operator">=</span> <span class="token class-name">ClusterClientOptions</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token comment">//Redis命令超时时间,超时后才会使用新的拓扑信息重新建立连接</span>
                <span class="token punctuation">.</span><span class="token function">timeoutOptions</span><span class="token punctuation">(</span><span class="token class-name">TimeoutOptions</span><span class="token punctuation">.</span><span class="token function">enabled</span><span class="token punctuation">(</span><span class="token class-name">Duration</span><span class="token punctuation">.</span><span class="token function">ofSeconds</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">topologyRefreshOptions</span><span class="token punctuation">(</span>topologyRefreshOptions<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">LettuceClientConfiguration</span> clientConfiguration <span class="token operator">=</span> <span class="token class-name">LettuceClientConfiguration</span><span class="token punctuation">.</span><span class="token function">builder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">clientResources</span><span class="token punctuation">(</span>clientResources<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">clientOptions</span><span class="token punctuation">(</span>clusterClientOptions<span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">RedisClusterConfiguration</span> clusterConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RedisClusterConfiguration</span><span class="token punctuation">(</span>redisProperties<span class="token punctuation">.</span><span class="token function">getCluster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getNodes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        clusterConfig<span class="token punctuation">.</span><span class="token function">setMaxRedirects</span><span class="token punctuation">(</span>redisProperties<span class="token punctuation">.</span><span class="token function">getCluster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getMaxRedirects</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        clusterConfig<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token class-name">RedisPassword</span><span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>redisProperties<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">LettuceConnectionFactory</span><span class="token punctuation">(</span>clusterConfig<span class="token punctuation">,</span> clientConfiguration<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>3、<strong><code>刷新节点集群拓扑动态感应</code></strong></p> 
<p>文档：https://github.com/lettuce-io/lettuce-core/wiki/Redis-Cluster#refreshing-the-cluster-topology-view</p> 
<p>添加 YML 配置：</p> 
<pre><code class="prism language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">lettuce</span><span class="token punctuation">:</span>
      <span class="token key atrule">cluster</span><span class="token punctuation">:</span>
        <span class="token key atrule">refresh</span><span class="token punctuation">:</span>
          <span class="token key atrule">dynamic-refresh-sources</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
          <span class="token comment"># 支持集群拓扑动态感应刷新,自适应拓扑刷新是否使用所有可用的更新,默认false关闭</span>
          <span class="token key atrule">adaptive</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>
          <span class="token comment"># 群集拓扑刷新周期</span>
          <span class="token key atrule">period</span><span class="token punctuation">:</span> 2000ms
</code></pre> 
<p>再次启动测试，发现第一次访问会出现 1s 左右成功返回，之后完全正常使用。</p> 
<h2><a id="Redis___6757"></a>Redis 高阶篇 生产落地与面试解析</h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eb9df3fe20d582990cdb4bfb6e8330de/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java基础——一文读懂Fork/Join框架</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f9e1de869f3dd03df174c6c2633f6baf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【计算机编程语言】HTML-前端基础知识</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>