<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Linux】Linux进程简介及其五种状态 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Linux】Linux进程简介及其五种状态" />
<meta property="og:description" content="由操作系统定义，并由操作系统所操控的一个特殊的数据结构实例叫做进程。它连接了用户代码，拥有代码运行所需的独立内存空间，在调度器的调度下使用分配给它的处理器时间片来运行。
进程及其私有内存空间 进程类似于UCOSIII中的任务，它也是用户应用程序可执行代码在系统中的一个运行过程。系统中用来表示进程身份和存在的也是控制块，只不过叫做进程控制块。进程与UCOSIII任务之间最重要的一个区别就是：进程具有自己的内存空间，进程的程序代码就运行在这个归自己所有的内存空间之中。当然，进程的控制块记录了进程的这个私有内存空间。
在UCOSIII中提到，一个任务的组成部分：任务堆栈、任务控制块、任务代码。同样Linux的进程除了这三块，同时还需要进程自己的内存空间。一个典型的进程控制块如下图所示：
进程控制块的成员mm就是指向进程内存控制块的指针，而这个进程内存控制块则关联了进程的虚拟空间结构和表示了它所占用的物理内存空间结构。
所谓进程私有内存空间，就是系统使程序运行为程序分配的程序空间。保证程序具有私有空间的基础就是虚拟内存技术。系统把程序运行所需的物理内存页框地址映射成虚拟地址，并以页表的形式提供给了程序，从而使得程序只能通过页表运行于自己的物理空间而不会干扰到系统中的其它进程。
结合前面关于Linux内存管理的讲解可知，Linux进程控制块中的mm成员如下图所示：
文章参考：【Linux】Linux虚拟内存空间描述。
另外，由于Linux进程分为用户空间和内核空间两个部分，它有时运行于用户空间，有时运行于内核空间，因此为了保护各自的现场数据，一个进程还需要两个堆栈：用户堆栈和系统堆栈，如下图所示：
最后区分一下进程和线程：在多任务系统中具有私有内存空间的正在运行的程序叫做进程，而没有私有内存空间的叫做线程。如此说来，其实UCOSIII的任务是划分到线程的。
Linux进程的状态 在Linux系统中，一个进程被创建之后，在系统中可以有下面5种状态。进程的当前状态记录在进程控制块的state成员中。
就绪状态和运行状态 就绪状态的状态标志state的值为TASK_RUNNING。此时，程序已被挂入运行队列，处于准备运行状态。一旦获得处理器使用权，即可进入运行状态。
当进程获得处理器而运行时 ，state的值仍然为TASK_RUNNING，并不发生改变；但Linux会把一个专门用来指向当前运行任务的指针current指向它，以表示它是一个正在运行的进程。
可中断等待状态 状态标志state的值为TASK_INTERRUPTIBL。此时，由于进程未获得它所申请的资源而处在等待状态。一旦资源有效或者有唤醒信号，进程会立即结束等待而进入就绪状态。
不可中断等待状态 状态标志state的值为TASK_UNINTERRUPTIBL。此时，进程也处于等待资源状态。一旦资源有效，进程会立即进入就绪状态。这个等待状态与可中断等待状态的区别在于：处于TASK_UNINTERRUPTIBL状态的进程不能被信号量或者中断所唤醒，只有当它申请的资源有效时才能被唤醒。
这个状态被应用在内核中某些场景中，比如当进程需要对磁盘进行读写，而此刻正在DMA中进行着数据到内存的拷贝，如果这时进程休眠被打断（比如强制退出信号）那么很可能会出现问题，所以这时进程就会处于不可被打断的状态下。
停止状态 状态标志state的值为TASK_STOPPED。当进程收到一个SIGSTOP信号后，就由运行状态进入停止状态，当受到一个SIGCONT信号时，又会恢复运行状态。这种状态主要用于程序的调试，又被叫做“暂停状态”、“挂起状态”。
中止状态 状态标志state的值为TASK_DEAD。进程因某种原因而中止运行，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外，并且系统对它不再予以理睬，所以这种状态也叫做“僵死状态”，进程成为僵尸进程。
在进程的整个生命周期中，它可在5种状态之间转换。Linux进程5种状态之间的转换关系如下图所示：
文章参考：Linux进程状态解析 之 R、S、D、T、Z、X (主要有三个状态)。
Linux有两类进程：一类是普通用户进程，它既可以在用户空间运行，又可通过系统调用进入内核空间，并在内核空间运行；另一类叫做内核进程，这种进程只能在内核空间运行。
Linux的进程控制块 在Linux中，线程、进程使用的是相同的核心数据结构。可以说，在Linux2.4的内核里只有进程，其中包含轻量进程（线程）。一个进程在核心中使用一个task_struct结构来表示，包含了大量描述该进程的信息。
Linux系统中作为进程控制块（PCB）的数据结构叫做task_struct。这个进程控制块要负责记录和跟踪进程在系统中的全部信息。
尽管task_struct数据结构庞大而复杂，但其成员可按功能分成一些组成部分。task_struct的数据结构应包含如下信息：
进程的当前状态；调度信息：调度器需要知道这些信息，以便判断系统中进程的迫切度；进程标识：系统中每个进程都有一个进程标识pid；进程的通信信息：Linux支持经典的Unix IPC机制，如信号、管道和信号灯；支持系统V中的IPC机制，包括共享内存、信号灯和消息队列；进程与其他进程之间关系的信息：Linux中所有进程都是相互关联的。除了根进程外，所有进程都有一个父进程，也可能有子进程或者兄弟进程，所以每个进程的task_struct结构中要包含有指向其父进程、兄弟进程或子进程的指针；使用文件的信息：进程可自由地打开或关闭文件。进程的task_struct结构中包含一个指向文件系统及它所打开文件的指针；虚拟内存与物理内存关系的信息：所有进程都有自己的内存空间；计时器：核心需要记录进程的创建时间及其在其生命周期中消耗的CPU的时间；处理器中与进程有关的信息。 Linux可以管理512个进程，每个进程的进程控制块指针都存放在一个数组中。为了使系统可快速访问正在运行的进程，Linux系统把当前运行进程的指针存放在指针变量current中。
进程控制块task_struct的部分定义如下：
struct task_struct { volatile long state;	/* 进程的状态 */ unsigned long flags;	/* 与管理有关的状态信息 */ int prio, static_prio, normal_prio; //优先级，静态优先级 struct list_head tasks; //进程链表 struct list_head ptrace_children; struct list_head ptrace_list; struct mm_struct *mm, *active_mm; //指向进程存储空间的指针 pid_t pid; //进程的pid pid_t tgid; struct task_struct *real_parent; /* 真父进程指针 */ struct task_struct *parent; /* 父进程指针 */ struct list_head children;	/* 子进程链表 */ struct list_head sibling;	/* 兄弟进程链表 */ struct task_struct *group_leader;	/* threadgroup leader */ struct timespec start_time; /* monotonic time */ struct timespec real_start_time;	/* boot based time */ struct thread_struct thread; unsigned long rt_priority; //实时优先级 struct fs_struct *fs; //进程所在文件目录 struct files_struct *files; //进程打开文件信息 struct dentry *proc_dentry; //proc文件的dentry struct backing_dev_info *backing_dev_info; struct signal_struct *signal; //信号 struct sighand_struct *sighand; ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0b17b5ab6a5a8d94121c875170a4f6f9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-24T21:42:36+08:00" />
<meta property="article:modified_time" content="2018-07-24T21:42:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Linux】Linux进程简介及其五种状态</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>由操作系统定义，并由操作系统所操控的一个特殊的数据结构实例叫做进程。它连接了用户代码，拥有代码运行所需的独立内存空间，在调度器的调度下使用分配给它的处理器时间片来运行。</strong></p> 
<p> </p> 
<h3>进程及其私有内存空间</h3> 
<p>进程类似于UCOSIII中的任务，它也是用户应用程序可执行代码在系统中的一个运行过程。系统中用来表示进程身份和存在的也是控制块，只不过叫做进程控制块。<strong>进程与UCOSIII任务之间最重要的一个区别就是：进程具有自己的内存空间，进程的程序代码就运行在这个归自己所有的内存空间之中。当然，进程的控制块记录了进程的这个私有内存空间。</strong></p> 
<p>在UCOSIII中提到，一个任务的组成部分：任务堆栈、任务控制块、任务代码。同样Linux的进程除了这三块，同时还需要进程自己的内存空间。一个典型的进程控制块如下图所示：</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/a4/a3/jBtpLjpO_o.png"></p> 
<p><strong>进程控制块的成员mm就是指向进程内存控制块的指针，而这个进程内存控制块则关联了进程的虚拟空间结构和表示了它所占用的物理内存空间结构。</strong></p> 
<p>所谓<strong>进程私有内存空间，就是系统使程序运行为程序分配的程序空间。保证程序具有私有空间的基础就是虚拟内存技术。系统把程序运行所需的物理内存页框地址映射成虚拟地址，并以页表的形式提供给了程序，</strong>从而使得程序只能通过页表运行于自己的物理空间而不会干扰到系统中的其它进程。</p> 
<p>结合前面关于Linux内存管理的讲解可知，Linux进程控制块中的mm成员如下图所示：</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/8a/80/WzpDzuu6_o.png"></p> 
<p>文章参考：<a href="https://blog.csdn.net/qq_38410730/article/details/81104079">【Linux】Linux虚拟内存空间描述</a>。</p> 
<p>另外，<strong>由于Linux进程分为用户空间和内核空间两个部分，它有时运行于用户空间，有时运行于内核空间，因此为了保护各自的现场数据，一个进程还需要两个堆栈：用户堆栈和系统堆栈，</strong>如下图所示：</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/e8/b7/jCoGGWMN_o.png"></p> 
<p>最后区分一下进程和线程：在多任务系统中具有私有内存空间的正在运行的程序叫做进程，而没有私有内存空间的叫做线程。如此说来，其实UCOSIII的任务是划分到线程的。</p> 
<p> </p> 
<h3>Linux进程的状态</h3> 
<p>在Linux系统中，一个进程被创建之后，在系统中可以有下面5种状态。进程的当前状态记录在进程控制块的state成员中。</p> 
<h4>就绪状态和运行状态</h4> 
<p><strong>就绪状态的状态标志state的值为TASK_RUNNING。</strong>此时，程序已被挂入运行队列，处于准备运行状态。一旦获得处理器使用权，即可进入运行状态。</p> 
<p><strong>当进程获得处理器而运行时 ，state的值仍然为TASK_RUNNING</strong>，并不发生改变；但Linux会把一个专门用来指向当前运行任务的指针current指向它，以表示它是一个正在运行的进程。</p> 
<h4>可中断等待状态</h4> 
<p><strong>状态标志state的值为TASK_INTERRUPTIBL。此时，由于进程未获得它所申请的资源而处在等待状态。一旦资源有效或者有唤醒信号，进程会立即结束等待而进入就绪状态。</strong></p> 
<h4>不可中断等待状态</h4> 
<p><strong>状态标志state的值为TASK_UNINTERRUPTIBL。此时，进程也处于等待资源状态。一旦资源有效，进程会立即进入就绪状态。这个等待状态与可中断等待状态的区别在于：处于TASK_UNINTERRUPTIBL状态的进程不能被信号量或者中断所唤醒，只有当它申请的资源有效时才能被唤醒。</strong></p> 
<p><strong>这个状态被应用在内核中某些场景中，比如当进程需要对磁盘进行读写，而此刻正在DMA中进行着数据到内存的拷贝，如果这时进程休眠被打断（比如强制退出信号）那么很可能会出现问题，所以这时进程就会处于不可被打断的状态下。</strong></p> 
<h4>停止状态</h4> 
<p><strong>状态标志state的值为TASK_STOPPED。</strong>当进程收到一个SIGSTOP信号后，就由运行状态进入停止状态，当受到一个SIGCONT信号时，又会恢复运行状态。这种状态主要用于程序的调试，<strong>又被叫做“暂停状态”、“挂起状态”。</strong></p> 
<h4>中止状态</h4> 
<p><strong>状态标志state的值为TASK_DEAD。进程因某种原因而中止运行，进程占有的所有资源将被回收，除了task_struct结构（以及少数资源）以外，并且系统对它不再予以理睬，所以这种状态也叫做“僵死状态”，进程成为僵尸进程。</strong></p> 
<p>在进程的整个生命周期中，它可在5种状态之间转换。Linux进程5种状态之间的转换关系如下图所示：</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/28/f0/pdSwjSbq_o.png"></p> 
<p>文章参考：<a href="https://blog.csdn.net/sdkdlwk/article/details/65938204">Linux进程状态解析 之 R、S、D、T、Z、X (主要有三个状态)</a>。</p> 
<p>Linux有两类进程：<strong>一类是普通用户进程，它既可以在用户空间运行，又可通过系统调用进入内核空间，并在内核空间运行；另一类叫做内核进程，这种进程只能在内核空间运行。</strong></p> 
<p> </p> 
<h4>Linux的进程控制块</h4> 
<p><strong>在Linux中，线程、进程使用的是相同的核心数据结构。</strong>可以说，在Linux2.4的内核里只有进程，其中包含轻量进程（线程）。一个进程在核心中使用一个task_struct结构来表示，包含了大量描述该进程的信息。</p> 
<p>Linux系统中作为<strong>进程控制块（PCB）的数据结构叫做task_struct</strong>。这个进程控制块要负责记录和跟踪进程在系统中的全部信息。</p> 
<p>尽管task_struct数据结构庞大而复杂，但其成员可按功能分成一些组成部分。task_struct的数据结构应包含如下信息：</p> 
<ul><li><strong>进程的当前状态；</strong></li><li><strong>调度信息：调度器需要知道这些信息，以便判断系统中进程的迫切度；</strong></li><li><strong>进程标识：系统中每个进程都有一个进程标识pid；</strong></li><li><strong>进程的通信信息：Linux支持经典的Unix IPC机制，如信号、管道和信号灯；支持系统V中的IPC机制，包括共享内存、信号灯和消息队列；</strong></li><li><strong>进程与其他进程之间关系的信息：Linux中所有进程都是相互关联的。除了根进程外，所有进程都有一个父进程，也可能有子进程或者兄弟进程，所以每个进程的task_struct结构中要包含有指向其父进程、兄弟进程或子进程的指针；</strong></li><li>使用文件的信息：进程可自由地打开或关闭文件。进程的task_struct结构中包含一个指向文件系统及它所打开文件的指针；</li><li><strong>虚拟内存与物理内存关系的信息：所有进程都有自己的内存空间；</strong></li><li><strong>计时器：核心需要记录进程的创建时间及其在其生命周期中消耗的CPU的时间；</strong></li><li>处理器中与进程有关的信息。</li></ul> 
<p>Linux可以管理512个进程，每个进程的进程控制块指针都存放在一个数组中。<strong>为了使系统可快速访问正在运行的进程，Linux系统把当前运行进程的指针存放在指针变量current中。</strong></p> 
<p>进程控制块task_struct的部分定义如下：</p> 
<pre class="has"><code class="language-cpp">struct task_struct {
	volatile long state;	/* 进程的状态 */

	unsigned long flags;	/* 与管理有关的状态信息 */

	int prio, static_prio, normal_prio;        //优先级，静态优先级

	struct list_head tasks;            //进程链表

	struct list_head ptrace_children;
	struct list_head ptrace_list;

	struct mm_struct *mm, *active_mm;        //指向进程存储空间的指针

	pid_t pid;                     //进程的pid
	pid_t tgid;

	struct task_struct *real_parent;     /* 真父进程指针 */
	struct task_struct *parent;         /* 父进程指针 */

	struct list_head children;	        /* 子进程链表 */
	struct list_head sibling;	        /* 兄弟进程链表 */
	struct task_struct *group_leader;	        /* threadgroup leader */

	struct timespec start_time; 		/* monotonic time */
	struct timespec real_start_time;	/* boot based time */

	struct thread_struct thread;

        unsigned long rt_priority;            //实时优先级

	struct fs_struct *fs;                //进程所在文件目录
	struct files_struct *files;            //进程打开文件信息
    
        struct dentry *proc_dentry;            //proc文件的dentry
        struct backing_dev_info *backing_dev_info;

	struct signal_struct *signal;                //信号
	struct sighand_struct *sighand;

        ...

};</code></pre> 
<p>系统中把所有进程控制块组织为如下图所示的双向链表：</p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/08/41/yBe37SFY_o.png"></p> 
<p style="text-align:center;"><img alt="" class="has" src="https://images2.imgbox.com/94/16/JnV02JH6_o.png"></p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e136665402a32de755e771156d7e0122/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux 系统使用总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f7aba0fbc2b27ed2f0b86bd64b6b2853/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">DDR地址和容量计算、Bank理解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>