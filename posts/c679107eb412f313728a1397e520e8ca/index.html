<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>三废的日常--Nginx实现负载均衡 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="三废的日常--Nginx实现负载均衡" />
<meta property="og:description" content="第二天。。小废给大废买了杯奶茶。。
大废：这才差不多，讲了这么多早就应该给我奶茶了，吧唧吧唧。。
大废：那今天就来讲讲Nginx是如何实现负载均衡吧。
二废：这个我知道，我看过Nginx的配置，nginx通过upstream下的配置，对配置的服务器进行负载均衡，具体配置如下*。
http { listen 80; server_name localhost; upstream webservers { ip_hash; server 192.168.0.1:8080; server 192.168.0.2:8080; }...} 其中，listen是访问nginx的端口，server_name是访问路径，这里默认是 localhost，端口默认是80。server是两台应用服务器，由Nginx通过负载均衡策略来选择访问应用服务器，做到了应用负载。
大废：二废看来昨天偷偷做功课了呀。这样的架构设计看起来是可以支撑业务的快速增长，但所有的访问都会直接请求服务器，这显然是不太安全，因此一般也会在软负载均衡后面，增加一个网关。这样所有流量经过Server时都要先去网关进行鉴权，除了鉴权外，网关还可以起到协议转换、流量控制等功能。
小废：我看书上介绍Nginx还可以对静态资源进行处理，这是怎么做到的呀
大废：没错，如果应用服务器有一些静态资源，后端服务器每次都要从磁盘加载文件会比较影响性能，而Nginx的proxy cache功能能够提升对静态资源的处理能力。​​​​​​​
location /static/images/ { root /home/www/; charset utf-8;} 注：实际上静态资源在服务器上的位置为：/home/www/static/images/hello.png
这样配置后，如此访问便可以访问到对应的静态资源 http://localhost:8080/static/images/hello.png 此时Nginx作为了一台静态资源服务器。​​​​​​​
location /static/images/ { alias /home/www; charset utf-8;} 注：这样访问的服务器上的位置为：/home/www/hello.png
小废：这样是不是就做到了动静分离。那Nginx如何保证高可用呢？
大废：由于Nginx在上面整个架构中作为流量的入口，如果Nginx不能正常工作或服务器宕机，将导致整个服务不可用。因此可以通过keepalived的机制来保证Nginx双活。
大废：架构一定要根据实际业务来设计，脱离业务的设计是没有意义的，对于业务量不大的系统，用Nginx作为负载均衡是完全够用的。当然，对于大型互联网企业则需要调整一些设计，比如静态资源应该部署在CDN上， CDN 会自动选择离用户最近的节点返回给用户，同时，流量很大时可以选择DNS负载均衡解析域名，大概如下图。
总结：
轮询策略配置：
在配置文件upstream中，ip_hash是指定负载均衡器按照基于客户端IP的分配方式，这个方法确保了相同的客户端的请求一直发送到相同的服务器，可以解决session不能跨服务器的问题。同时，还有以下其他几种轮询策略，依次介绍如下。
轮询，默认策略，不需要加任何配置，是upstream模块默认的负载均衡策略，会将每个请求顺序分发到不同的后端服务器上。
权重（weight）：指定轮询的访问权重，用于后端服务器性能不均时的策略。
upstream webservers { server 192.168.0.1:8080 weight=7; server 192.168.0.2:8080 weight=3;} ip_hash（依据ip分配）：指定负载均衡器按照基于客户端IP的分配方式，这个方法确保了相同的客户端的请求一直发送到相同的服务器，可以解决session不能跨服务器的问题。
least_conn（最少连接）：将请求转发给连接数较少的服务器。
upstream webservers { least_conn; server 192." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c679107eb412f313728a1397e520e8ca/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-13T11:04:28+08:00" />
<meta property="article:modified_time" content="2022-09-13T11:04:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">三废的日常--Nginx实现负载均衡</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>第二天。。小废给大废买了杯奶茶。。</p> 
<p>大废：这才差不多，讲了这么多早就应该给我奶茶了，吧唧吧唧。。</p> 
<p>大废：那今天就来讲讲Nginx是如何实现负载均衡吧。</p> 
<p>二废：这个我知道，我看过Nginx的配置，nginx通过upstream下的配置，对配置的服务器进行负载均衡，具体配置如下*。</p> 
<pre><code>http {<!-- --></code><code>  listen 80;</code><code>  server_name localhost;</code><code>  </code><code>  upstream webservers {  </code><code>    ip_hash;  </code><code>    server 192.168.0.1:8080;  </code><code>    server 192.168.0.2:8080; </code><code>  }</code><code>...</code><code>}</code></pre> 
<p></p> 
<p>其中，listen是访问nginx的端口，server_name是访问路径，这里默认是 localhost，端口默认是80。server是两台应用服务器，由Nginx通过<strong>负载均衡策略</strong>来选择访问应用服务器，做到了应用负载。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/46/ad/570YiOZU_o.png"></p> 
<p>大废：二废看来昨天偷偷做功课了呀。这样的架构设计看起来是可以支撑业务的快速增长，但所有的访问都会直接请求服务器，这显然是不太安全，因此一般也会在软负载均衡后面，增加一个网关。这样所有流量经过Server时都要先去网关进行鉴权，除了鉴权外，网关还可以起到<strong>协议转换、流量控制</strong>等功能。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f7/bc/n3RjYPUR_o.png"></p> 
<p></p> 
<p>小废：我看书上介绍Nginx还可以对静态资源进行处理，这是怎么做到的呀</p> 
<p>大废：没错，如果应用服务器有一些静态资源，后端服务器每次都要从磁盘加载文件会比较影响性能，而Nginx的proxy cache功能能够提升对静态资源的处理能力。​​​​​​​</p> 
<pre><code>location /static/images/ {<!-- --></code><code>  root /home/www/;</code><code>  charset utf-8;</code><code>}</code>
</pre> 
<p><em>注：实际上静态资源在服务器上的位置为：/home/www/static/images/hello.png</em></p> 
<p>这样配置后，如此访问便可以访问到对应的静态资源 http://localhost:8080/static/images/hello.png 此时Nginx作为了一台静态资源服务器。​​​​​​​</p> 
<pre><code>location /static/images/ {<!-- --></code><code>  alias /home/www;</code><code>  charset utf-8;</code><code>}</code></pre> 
<p></p> 
<p><em>注：这样访问的服务器上的位置为：/home/www/hello.png</em></p> 
<p>小废：这样是不是就做到了<strong>动静分离</strong>。那Nginx如何保证高可用呢？</p> 
<p>大废：由于Nginx在上面整个架构中作为<strong>流量的入口</strong>，如果Nginx不能正常工作或服务器宕机，将导致整个服务不可用。因此可以通过keepalived的机制来保证Nginx双活。</p> 
<p>大废：架构一定要根据实际业务来设计，脱离业务的设计是没有意义的，对于业务量不大的系统，用Nginx作为负载均衡是完全够用的。当然，对于大型互联网企业则需要调整一些设计，比如静态资源应该部署在CDN上， CDN 会自动选择离用户最近的节点返回给用户，同时，流量很大时可以选择DNS负载均衡解析域名，大概如下图。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/50/8a/UgqUsu5c_o.png"></p> 
<p>总结：</p> 
<p>轮询策略配置：</p> 
<p>在配置文件upstream中，ip_hash是指定负载均衡器按照基于客户端IP的分配方式，这个方法确保了相同的客户端的请求一直发送到相同的服务器，可以解决session不能跨服务器的问题。同时，还有以下其他几种轮询策略，依次介绍如下。</p> 
<ol><li> <p>轮询，默认策略，不需要加任何配置，是upstream模块默认的负载均衡策略，会将每个请求顺序分发到不同的后端服务器上。</p> </li><li> <p>权重（weight）：指定轮询的访问权重，用于后端服务器性能不均时的策略。</p> </li><li> <pre><code>upstream webservers {<!-- --></code><code>  server 192.168.0.1:8080 weight=7;  </code><code>  server 192.168.0.2:8080 weight=3;</code><code>}</code></pre> </li><li> <p>ip_hash（依据ip分配）：指定负载均衡器按照基于客户端IP的分配方式，这个方法确保了相同的客户端的请求一直发送到相同的服务器，可以解决session不能跨服务器的问题。</p> </li><li> <p>least_conn（最少连接）：将请求转发给连接数较少的服务器。</p> </li></ol> 
<pre><code>upstream webservers {  </code><code>  least_conn;  </code><code>  server 192.168.0.1:8080 weight=7;  </code><code>  server 192.168.0.2:8080 weight=3;</code><code>}</code></pre> 
<p>    6. fair：按照服务器端的响应时间来分配请求，响应时间短的优先分配。</p> 
<p>​​​​​​​</p> 
<pre><code>upstream webservers {  </code><code>  fair;  </code><code>  server 192.168.0.1:8080 weight=7;  </code><code>  server 192.168.0.2:8080 weight=3;</code><code>}</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/773c28eeb6a49bca97b0ee26ff164fb4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">实例分割计算指标TP,FP,FN,F1（附代码）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/20f02d8d422580afae4e872a8044408e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">调用系统相机、相册、剪裁图片，适配Android 12</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>