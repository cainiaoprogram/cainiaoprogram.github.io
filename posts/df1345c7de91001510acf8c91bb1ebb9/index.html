<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Jetson Nano 入坑之路 ---- （10）C/C&#43;&#43;语言读写UART或USB串口数据 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Jetson Nano 入坑之路 ---- （10）C/C&#43;&#43;语言读写UART或USB串口数据" />
<meta property="og:description" content="在上一篇“Jetson Nano 入坑之路 ”系列博客中笔者讲到笔者封装的一个串口函数，本篇博客，笔者会简单易懂的讲解C语言读写串口的方法。
优化：其他博主的博客在这个串口部分大部分都有个问题，就是十六进制读取的时候，会发现，0x7F以上后，第八位被吃了。你发0xFF，但是程序始终读出来的是0x7F。因为最高位“被吃”了。本博客的程序是博主亲测实用程序。
环境准备 Jetson自带了ch34x的驱动，所以可以直接使用CH34x系列的USB-TTL作为USB串口与Jetson进行交互。在SYN6288语言播报模块笔者也用USB-TTL尝试过。
为了测试，可以安装个mincom，然后把TX和RX短接一下。
代码实现 就不吊胃口了，直接上正菜。
#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;errno.h&gt; #include &lt;unistd.h&gt; #include &lt;termios.h&gt; #include &lt;fcntl.h&gt; #include &lt;iconv.h&gt; #include &lt;string&gt; #include &lt;iostream&gt; // 函数声明部分 int open_port(int com_port); int set_uart_config(int fd, int baud_rate, int data_bits, char parity, int stop_bits); // 使用实例 int main() { // begin::第一步，串口初始化 int UART_fd = open_port(0); if (set_uart_config(UART_fd, 115200, 8, &#39;N&#39;, 1) &lt; 0) { perror(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/df1345c7de91001510acf8c91bb1ebb9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-25T02:51:12+08:00" />
<meta property="article:modified_time" content="2022-01-25T02:51:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Jetson Nano 入坑之路 ---- （10）C/C&#43;&#43;语言读写UART或USB串口数据</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在上一篇“Jetson Nano 入坑之路 ”系列博客中笔者讲到笔者封装的一个串口函数，本篇博客，笔者会简单易懂的讲解C语言读写串口的方法。</p> 
<p><strong>优化：</strong>其他博主的博客在这个串口部分大部分都有个问题，就是十六进制读取的时候，会发现，0x7F以上后，第八位被吃了。你发0xFF，但是程序始终读出来的是0x7F。因为最高位“被吃”了。<strong>本博客的程序是博主亲测实用程序。</strong></p> 
<hr> 
<h2>环境准备</h2> 
<p>Jetson自带了ch34x的驱动，所以可以直接使用CH34x系列的USB-TTL作为USB串口与Jetson进行交互。在SYN6288语言播报模块笔者也用USB-TTL尝试过。</p> 
<p>为了测试，可以安装个mincom，然后把TX和RX短接一下。</p> 
<hr> 
<h2>代码实现</h2> 
<p>就不吊胃口了，直接上正菜。</p> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;errno.h&gt;
#include &lt;unistd.h&gt;
#include &lt;termios.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;iconv.h&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

// 函数声明部分
int open_port(int com_port);
int set_uart_config(int fd, int baud_rate, int data_bits, char parity, int stop_bits);

// 使用实例
int main()
{
    // begin::第一步，串口初始化
    int UART_fd = open_port(0);
	if (set_uart_config(UART_fd, 115200, 8, 'N', 1) &lt; 0)
	{
		perror("set_com_config");
		exit(1);
	}
    // end::串口初始化
    
    // begin::第二步，读下位机上发的一行数据
    char str[128];
	char buff[1];
	int len = 0;
	while (1)
	{
		if (read(UART_fd, buff, 1)) {
			if (buff[0] == '\n') {
				break;
			}else {
				str[len++] = buff[0];
			}
		}
	}
    printf("content:%s\n",str);
    // end::读下位机上发的一行数据

    // begin::第三步，向下位机发送数据
    write(UART_fd, str, len);
    // end::向下位机发送数据

    return 0;
}

/*
* 打开串口
*/
int open_port(int com_port)
{
    int fd;
    /* 使用普通串口 */
    // TODO::在此处添加串口列表
    char* dev[] = { "/dev/ttyTHS1", "/dev/ttyUSB0" };

    //O_NDELAY 同 O_NONBLOCK。
    fd = open(dev[com_port], O_RDWR | O_NOCTTY);
    if (fd &lt; 0)
    {
        perror("open serial port");
        return(-1);
    }

    //恢复串口为阻塞状态 
    //非阻塞：fcntl(fd,F_SETFL,FNDELAY)  
    //阻塞：fcntl(fd,F_SETFL,0) 
    if (fcntl(fd, F_SETFL, 0) &lt; 0)
    {
        perror("fcntl F_SETFL\n");
    }
    /*测试是否为终端设备*/
    if (isatty(STDIN_FILENO) == 0)
    {
        perror("standard input is not a terminal device");
    }

    return fd;
}

/*
* 串口设置
*/
int set_uart_config(int fd, int baud_rate, int data_bits, char parity, int stop_bits)
{
    struct termios opt;
    int speed;
    if (tcgetattr(fd, &amp;opt) != 0)
    {
        perror("tcgetattr");
        return -1;
    }

    /*设置波特率*/
    switch (baud_rate)
    {
    case 2400:  speed = B2400;  break;
    case 4800:  speed = B4800;  break;
    case 9600:  speed = B9600;  break;
    case 19200: speed = B19200; break;
    case 38400: speed = B38400; break;
    default:    speed = B115200; break;
    }
    cfsetispeed(&amp;opt, speed);
    cfsetospeed(&amp;opt, speed);
    tcsetattr(fd, TCSANOW, &amp;opt);

    opt.c_cflag &amp;= ~CSIZE;

    /*设置数据位*/
    switch (data_bits)
    {
    case 7: {opt.c_cflag |= CS7; }break;//7个数据位  
    default: {opt.c_cflag |= CS8; }break;//8个数据位 
    }

    /*设置奇偶校验位*/
    switch (parity) //N
    {
    case 'n':case 'N':
    {
        opt.c_cflag &amp;= ~PARENB;//校验位使能     
        opt.c_iflag &amp;= ~INPCK; //奇偶校验使能  
    }break;
    case 'o':case 'O':
    {
        opt.c_cflag |= (PARODD | PARENB);//PARODD使用奇校验而不使用偶校验 
        opt.c_iflag |= INPCK;
    }break;
    case 'e':case 'E':
    {
        opt.c_cflag |= PARENB;
        opt.c_cflag &amp;= ~PARODD;
        opt.c_iflag |= INPCK;
    }break;
    case 's':case 'S': /*as no parity*/
    {
        opt.c_cflag &amp;= ~PARENB;
        opt.c_cflag &amp;= ~CSTOPB;
    }break;
    default:
    {
        opt.c_cflag &amp;= ~PARENB;//校验位使能     
        opt.c_iflag &amp;= ~INPCK; //奇偶校验使能          	
    }break;
    }

    /*设置停止位*/
    switch (stop_bits)
    {
    case 1: {opt.c_cflag &amp;= ~CSTOPB; } break;
    case 2: {opt.c_cflag |= CSTOPB; }   break;
    default: {opt.c_cflag &amp;= ~CSTOPB; } break;
    }

    /*处理未接收字符*/
    tcflush(fd, TCIFLUSH);

    /*设置等待时间和最小接收字符*/
    opt.c_cc[VTIME] = 1000;
    opt.c_cc[VMIN] = 0;

    /*关闭串口回显*/
    opt.c_lflag &amp;= ~(ICANON | ECHO | ECHOE | ECHOK | ECHONL | NOFLSH);

    /*禁止将输入中的回车翻译为新行 (除非设置了 IGNCR)*/
    opt.c_iflag &amp;= ~ICRNL;
    /*禁止将所有接收的字符裁减为7比特*/
    opt.c_iflag &amp;= ~ISTRIP;

    /*激活新配置*/
    if ((tcsetattr(fd, TCSANOW, &amp;opt)) != 0)
    {
        perror("tcsetattr");
        return -1;
    }

    return 0;
}
</code></pre> 
<hr> 
<h2>简单讲解</h2> 
<p>将头文件和两个串口初始化和配置函数封装到uart.c或cpp里后，就可以随意使用write和read方法进行串口读写了。</p> 
<p>第一步的串口配置方法很重要哦！！！建议也将其封装到uart库里。方便日后使用。</p> 
<hr> 
<p>建议结合<a class="link-info" href="https://blog.csdn.net/qq_25662827/article/details/122481695" title="minicom教程">minicom教程</a>和<a class="link-info" href="https://blog.csdn.net/qq_25662827/article/details/122246024" title="SYN6288语音合成模块">SYN6288语音合成模块</a>一起看看，这样会有更牢固的理解。</p> 
<p>结语：喜欢本系列博客的朋友一键三连支持一下吧。想要了解相关的内容可以评论文章或私信，笔者有空就写。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d1d15f7d32e3c67d483096e6301d3cd1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MOV格式视频转MP4</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/af13762d2f333547cb87d9e37a2354ea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">HashMap底层源码与数据结构分析(JDK1.8)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>