<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[开发语言][c&#43;&#43;]：左值、右值、左值引用、右值引用和std::move() - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[开发语言][c&#43;&#43;]：左值、右值、左值引用、右值引用和std::move()" />
<meta property="og:description" content="左值、右值、左值引用、右值引用和std::move 1. 什么是左值、右值2. 什么是左值引用、右值引用3. **右值引用和std::move的应用场景**3.1 实现移动语义3.2 **实例：vector::push_back使用std::move提高性能** **4. 完美转发 std::forward**5. Reference 写在前面： 如果你也被左值、右值、左值引用、右值引用和std::move搞得焦头烂额，相关概念和理解不够深入，或者认识模棱两可，那么这篇文章将非常的适合你，耐心阅读，相信一定会有所收获～～
1. 什么是左值、右值 左值： 可以取地址、位于等号左边 – 表达式结束后依然存在的持久对象(代表一个在内存中占有确定位置的对象)
右值： 没法取地址、位于等号右边 – 表达式结束时不再存在的临时对象(不在内存中占有确定位置的表达式）
便携方法：对表达式取地址，如果能，则为左值，否则为右值
int val; val = 4; // 正确 ① 4 = val; // 错误 ② 上述例子中，由于在之前已经对变量val进行了定义，故在栈上会给val分配内存地址，运算符=要求等号左边是可修改的左值，4是临时参与运算的值，一般在寄存器上暂存，运算结束后在寄存器上移除该值，故①是对的，②是错的
2. 什么是左值引用、右值引用 引用本质是别名，可以通过引用修改变量的值，传参时传引用可以避免拷贝，其实现原理和指针类似。
左值引用：指向左值的引用，称为左值引用
int a = 5; int &amp;ref_a = a; // 左值引用指向左值，编译通过 int &amp;ref_a = 5; // 左值引用指向了右值，会编译失败 引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值。
那么const左值引用可不可以指向右值呢？
​ 可以！！！
const int &amp;ref_a = 5; const左值引用不会修改指向值，因此可以指向左值和右值，这也是为什么要使用const &amp;作为函数参数的原因之一，如std::vector的push_back函数原型：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/730cf832698a4ddb3c793d48f26df433/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-11T16:41:51+08:00" />
<meta property="article:modified_time" content="2024-01-11T16:41:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[开发语言][c&#43;&#43;]：左值、右值、左值引用、右值引用和std::move()</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>左值、右值、左值引用、右值引用和std::move</h4> 
 <ul><li><ul><li><a href="#1__5" rel="nofollow">1. 什么是左值、右值</a></li><li><a href="#2__23" rel="nofollow">2. 什么是左值引用、右值引用</a></li><li><a href="#3_stdmove_93" rel="nofollow">3. **右值引用和std::move的应用场景**</a></li><li><ul><li><a href="#31__97" rel="nofollow">3.1 实现移动语义</a></li><li><a href="#32_vectorpush_backstdmove_242" rel="nofollow">3.2 **实例：vector::push_back使用std::move提高性能**</a></li></ul> 
   </li><li><a href="#4__stdforward_283" rel="nofollow">**4. 完美转发 std::forward**</a></li><li><a href="#5_Reference_345" rel="nofollow">5. Reference</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<blockquote> 
 <p><strong>写在前面：</strong> 如果你也被<em><strong>左值、右值、左值引用、右值引用和std::move</strong></em>搞得焦头烂额，相关概念和理解不够深入，或者认识模棱两可，那么这篇文章将非常的适合你，耐心阅读，相信一定会有所收获～～</p> 
</blockquote> 
<hr> 
<h3><a id="1__5"></a>1. 什么是左值、右值</h3> 
<p><mark><strong>左值：</strong></mark> 可以取地址、位于等号左边 – 表达式结束后依然存在的持久对象(代表一个在内存中占有确定位置的对象)</p> 
<p><mark><strong>右值：</strong></mark> 没法取地址、位于等号右边 – 表达式结束时不再存在的临时对象(不在内存中占有确定位置的表达式）</p> 
<blockquote> 
 <p>便携方法：对表达式取地址，如果能，则为左值，否则为右值</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> val<span class="token punctuation">;</span>
val <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment">// 正确 ①</span>
<span class="token number">4</span> <span class="token operator">=</span> val<span class="token punctuation">;</span> <span class="token comment">// 错误 ②</span>
</code></pre> 
<p>上述例子中，由于在之前已经对变量val进行了定义，故在<strong>栈上会给val分配内存地址</strong>，运算符=要求等号左边是可修改的左值，4是临时参与运算的值，一般<strong>在寄存器上暂存</strong>，运算结束后在寄存器上移除该值，故①是对的，②是错的</p> 
<h3><a id="2__23"></a>2. 什么是左值引用、右值引用</h3> 
<p>引用本质是别名，可以通过引用修改变量的值，传参时传引用可以<strong>避免拷贝</strong>，其实现原理和指针类似。</p> 
<p><strong>左值引用</strong>：指向左值的引用，称为左值引用</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>ref_a <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 左值引用指向左值，编译通过</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>ref_a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 左值引用指向了右值，会编译失败</span>
</code></pre> 
<blockquote> 
 <p><strong><mark>引用是变量的别名，由于右值没有地址，没法被修改，所以左值引用无法指向右值</mark>。</strong></p> 
 <p>那么const左值引用可不可以指向右值呢？</p> 
 <p>​ 可以！！！</p> 
 <pre><code>const int &amp;ref_a = 5;
</code></pre> 
 <p>const左值引用不会修改指向值，因此可以指向左值和右值，这也是<strong>为什么要使用<code>const &amp;</code>作为函数参数的原因之一</strong>，如<code>std::vector</code>的<code>push_back</code>函数原型：</p> 
 <pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">push_back</span> <span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">//如果没有const，vec.push_back(5)这样的代码就无法编译通过了。</span>
<span class="token comment">//因为5是右值</span>
</code></pre> 
</blockquote> 
<p><strong><mark>右值引用</mark></strong>：右值引用的标志是<code>&amp;&amp;</code>，可以指向右值，不可以指向左值。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>ref_a_right <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// ok</span>
 
<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>ref_a_left <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// 编译不过，右值引用不可以指向左值</span>
 
ref_a_right <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> <span class="token comment">// 右值引用的用途：可以修改右值</span>
</code></pre> 
<blockquote> 
 <p>自然而然就会出现这样一个问题：<mark><strong>右值引用有办法指向左值吗？右值引用有啥作用？</strong></mark></p> 
 <p>有办法，<code>std::move()</code></p> 
 <pre><code class="prism language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// left value</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>ref_a_l <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment">// left reference.</span>
<span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span>ref_a_r <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//rvalue reference.</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> ref_a_r <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
</code></pre> 
 <p>左值a通过std::move移动到了右值ref_a_right中，那是不是a里边就没有值了？并不是，打印出a的值仍然是5.</p> 
 <p><code>std::move</code>是一个非常有迷惑性的函数，不理解左右值概念的人往往以为它能把一个变量里的内容移动到另一个变量，<strong>但事实上std::move移动不了什么，唯一的功能是把左值强制转化为右值</strong>，让右值引用可以指向左值。其实现等同于一个类型转换：<code>static_cast&lt;T&amp;&amp;&gt;(lvalue)</code>。 所以，<strong>单纯的std::move(xxx)不会有性能提升</strong>！！！！</p> 
</blockquote> 
<p><strong>那么左值引用、右值引用本身是左值还是右值？</strong></p> 
<p>被声明出来的左值引用和右值引用都是左值，因为他们都是有地址的，也位于等号左边，这符合我们刚刚的定义。</p> 
<p><strong>右值引用既可以是左值也可以是右值，如果有名称则为左值，否则是右值</strong>。<strong>作为函数返回值的 &amp;&amp; 是右值，直接声明出来的 &amp;&amp; 是左值</strong></p> 
<p><strong><mark>左右值引用的区别</mark>：</strong></p> 
<ol><li><strong>从性能上讲，左右值引用没有区别，传参使用左右值引用都可以避免拷贝。</strong></li><li><strong>右值引用可以直接指向右值，也可以通过std::move指向左值；而左值引用只能指向左值(const左值引用也能指向右值)。</strong></li><li><strong>作为函数形参时，右值引用更灵活。虽然const左值引用也可以做到左右值都接受，但它无法修改，有一定局限性。</strong></li></ol> 
<h3><a id="3_stdmove_93"></a>3. <strong>右值引用和std::move的应用场景</strong></h3> 
<p>按上文分析，<code>std::move</code>只是类型转换工具，不会对性能有好处；右值引用在作为函数形参时更具灵活性，看上去还是挺鸡肋的。他们有什么实际应用场景吗？</p> 
<h4><a id="31__97"></a>3.1 实现移动语义</h4> 
<p>在实际场景中，右值引用和std::move被广泛用于在STL和自定义类中<strong>实现移动语义，避免拷贝，从而提升程序性能</strong>。 在没有右值引用之前，一个简单的数组类通常实现如下，有<code>构造函数</code>、<code>拷贝构造函数</code>、<code>赋值运算符重载</code>、<code>析构函数</code>等。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Array</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Array</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">size_</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        data_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>size_<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
     
    <span class="token comment">// 深拷贝构造-&gt;当代码中有指针开辟堆内存时，</span>
    <span class="token comment">// 		必须显式定义拷贝构造函数，开辟新的堆内存，存储拷贝后的指针数据，</span>
    <span class="token comment">// 		否则两个对象的指针会指向同一个堆内存地址，当某一个对象析构后，</span>
    <span class="token comment">// 		相应的堆内存就会释放掉，导致另一个对象内的指针成为悬浮指针！！！</span>
  	<span class="token comment">// 浅拷贝-&gt;不涉及指针的拷贝</span>
    <span class="token function">Array</span><span class="token punctuation">(</span><span class="token keyword">const</span> Array<span class="token operator">&amp;</span> temp_array<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        size_ <span class="token operator">=</span> temp_array<span class="token punctuation">.</span>size_<span class="token punctuation">;</span>
        data_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>size_<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size_<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            data_<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp_array<span class="token punctuation">.</span>data_<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
     
    <span class="token comment">// 深拷贝赋值 const引用避免了传参拷贝，但是堆内存仍然需要深拷贝，所以需要用到std::move实现移动赋值</span>
    Array<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Array<span class="token operator">&amp;</span> temp_array<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data_<span class="token punctuation">;</span>
 
        size_ <span class="token operator">=</span> temp_array<span class="token punctuation">.</span>size_<span class="token punctuation">;</span>
        data_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>size_<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size_<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            data_<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp_array<span class="token punctuation">.</span>data_<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
 
    <span class="token operator">~</span><span class="token function">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> data_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>data_<span class="token punctuation">;</span>
    <span class="token keyword">int</span> size_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>该类的拷贝构造函数、赋值运算符重载函数已经通过使用左值引用传参来避免一次多余拷贝了，但是内部实现要深拷贝，无法避免。 这时，有人提出一个想法：是不是可以提供一个<code>移动构造函数</code>，把被拷贝者的数据移动过来，被拷贝者后边就不要了，这样就可以避免 <mark><strong>深拷贝</strong></mark> 了，</p> 
<blockquote> 
 <p>关于深拷贝和浅拷贝的区别和联系，后续也会出一篇文章，链接在：<a href="" rel="nofollow">深拷贝与浅拷贝</a><br> <strong>深拷贝构造-</strong>&gt;当代码中有指针开辟堆内存时，必须显式定义拷贝构造函数，开辟新的堆内存，存储拷贝后的指针数据，否则两个对象的指针会指向同一个堆内存地址，当某一个对象析构后，相应的堆内存就会释放掉，导致另一个对象内的指针成为悬浮指针！！！<br> <strong>浅拷贝</strong>-&gt;不涉及指针的拷贝</p> 
</blockquote> 
<p>如：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Array</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Array</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">size_</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        data_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>size_<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
     
    <span class="token comment">// 深拷贝构造</span>
    <span class="token function">Array</span><span class="token punctuation">(</span><span class="token keyword">const</span> Array<span class="token operator">&amp;</span> temp_array<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
     
    <span class="token comment">// 深拷贝赋值</span>
    Array<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Array<span class="token operator">&amp;</span> temp_array<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
 
    <span class="token comment">// 移动构造函数（重载深拷贝构造函数），可以浅拷贝-&gt; 形参是const&amp; 构造函数内，对temp_array赋值，编译不通过～</span>
    <span class="token function">Array</span><span class="token punctuation">(</span><span class="token keyword">const</span> Array<span class="token operator">&amp;</span> temp_array<span class="token punctuation">,</span> <span class="token keyword">bool</span> move<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        data_ <span class="token operator">=</span> temp_array<span class="token punctuation">.</span>data_<span class="token punctuation">;</span>
        size_ <span class="token operator">=</span> temp_array<span class="token punctuation">.</span>size_<span class="token punctuation">;</span>
        <span class="token comment">// 为防止temp_array析构时delete data，提前置空其data_      </span>
        temp_array<span class="token punctuation">.</span>data_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
     
 
    <span class="token operator">~</span><span class="token function">Array</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">delete</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> data_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>data_<span class="token punctuation">;</span>
    <span class="token keyword">int</span> size_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>这么做有2个问题：</p> 
<ul><li>不优雅，表示移动语义还需要一个额外的参数(或者其他方式)。-&gt; 重载拷贝构造函数</li><li>无法实现！<code>temp_array</code>是个const左值引用，无法被修改，所以<code>temp_array.data_ = nullptr;</code>这行会编译不过。当然函数参数可以改成非const：<code>Array(Array&amp; temp_array, bool move){...}</code>，这样也有问题，由于左值引用不能接右值，<code>Array a = Array(Array(), true);</code>这种调用方式就没法用了。</li></ul> 
<p>可以发现<strong>左值引用真是用的很不爽</strong>，<strong>右值引用的出现解决了这个问题</strong>，在STL的很多容器中，都实现了以 <mark><strong>右值引用为参数</strong>的<code>移动构造函数</code>和<code>移动赋值重载函数</code></mark>，或者其他函数，最常见的如<strong>std::vector的<code>push_back</code>和<code>emplace_back</code></strong>。参数为左值引用意味着拷贝，为右值引用意味着移动。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">Array</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
 
    <span class="token comment">// 优雅</span>
    <span class="token function">Array</span><span class="token punctuation">(</span>Array<span class="token operator">&amp;&amp;</span> temp_array<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        data_ <span class="token operator">=</span> temp_array<span class="token punctuation">.</span>data_<span class="token punctuation">;</span>
        size_ <span class="token operator">=</span> temp_array<span class="token punctuation">.</span>size_<span class="token punctuation">;</span>
        <span class="token comment">// 为防止temp_array析构时delete data，提前置空其data_      </span>
        temp_array<span class="token punctuation">.</span>data_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
     
 
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> <span class="token operator">*</span>data_<span class="token punctuation">;</span>
    <span class="token keyword">int</span> size_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<blockquote> 
 <p>如何判断一个对象是否是可以移动的？</p> 
 <p><strong>在C++中，是否可以移动一个对象，取决于该对象的类是否定义了移动构造函数或移动赋值运算符。</strong> 以下是一些判断一个对象是否可以被移动的方法：</p> 
 <ol><li> <p><strong><mark>检查类的定义</mark></strong>：如果一个类定义了移动构造函数或移动赋值运算符，那么这个类的对象就可以被移动。移动构造函数和移动赋值运算符的声明通常如下：</p> <pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">MyClass</span><span class="token punctuation">(</span>MyClass<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 移动构造函数</span>
    MyClass<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>MyClass<span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 移动赋值运算符</span>
    <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> <p>注意，这两个函数的参数都是右值引用。</p> </li><li> <p>使用<code>std::is_move_constructible</code>和<code>std::is_move_assignable</code>：这两个模板在<code>&lt;type_traits&gt;</code>头文件中定义，可以用来检查一个类型是否有可用的移动构造函数或移动赋值运算符：</p> <pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>is_move_constructible<span class="token operator">&lt;</span>MyClass<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 如果MyClass可移动，输出1，否则输出0</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>is_move_assignable<span class="token operator">&lt;</span>MyClass<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token comment">// 如果MyClass可移动赋值，输出1，否则输出0</span>
</code></pre> </li><li> <p>使用<code>std::move_if_noexcept</code>：这个模板函数可以用来判断是否可以无异常地移动一个对象。如果移动操作可能抛出异常，它会选择拷贝操作。这在一些容器操作中非常有用，例如<code>std::vector</code>的重新分配。</p> </li></ol> 
 <p>需要注意的是，即使一个对象可以被移动，也不意味着应该总是移动它。在某些情况下，例如当你知道一个对象将在移动操作后立即被销毁，或者你想避免昂贵的拷贝操作时，移动是有意义的。在其他情况下，移动可能会导致难以追踪的错误，例如，如果你错误地移动了一个仍然需要使用的对象。</p> 
</blockquote> 
<h4><a id="32_vectorpush_backstdmove_242"></a>3.2 <strong>实例：vector::push_back使用std::move提高性能</strong></h4> 
<pre><code class="prism language-cpp"><span class="token comment">// std::move会调用到移动语义函数，避免了深拷贝。</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>string str1 <span class="token operator">=</span> <span class="token string">"aacasxs"</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> vec<span class="token punctuation">;</span>
     
    vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 传统方法，copy</span>
    vec<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用移动语义的push_back方法，避免拷贝，str1会失去原有值，变成空字符串</span>
    vec<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>str1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// emplace_back效果相同，str1会失去原有值</span>
    vec<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token string">"axcsddcas"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 当然可以直接接右值</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// std::vector方法定义</span>
<span class="token keyword">void</span> <span class="token function">push_back</span> <span class="token punctuation">(</span><span class="token keyword">const</span> value_type<span class="token operator">&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">push_back</span> <span class="token punctuation">(</span>value_type<span class="token operator">&amp;&amp;</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 内部调用了emplace_back</span>
 
<span class="token keyword">void</span> <span class="token function">emplace_back</span> <span class="token punctuation">(</span>Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong>可移动对象在&lt;需要拷贝且被拷贝者之后不再被需要&gt;的场景，建议使用</strong><code>std::move</code><strong>触发移动语义，提升性能。</strong></p> 
<pre><code class="prism language-cpp">moveable_objecta <span class="token operator">=</span> moveable_objectb<span class="token punctuation">;</span> 
改为： 
moveable_objecta <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>moveable_objectb<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>还有些STL类是<code>move-only</code>的，比如<code>unique_ptr</code>，这种类只有移动构造函数，因此只能移动(转移内部对象所有权，或者叫浅拷贝)，不能拷贝(深拷贝):</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> ptr_a <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_unique</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> ptr_b <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr_a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// unique_ptr只有‘移动赋值重载函数‘，参数是&amp;&amp; ，只能接右值，因此必须用std::move转换类型</span>

std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> ptr_b <span class="token operator">=</span> ptr_a<span class="token punctuation">;</span> <span class="token comment">// 编译不通过</span>
</code></pre> 
<p><strong>std::move本身只做类型转换，对性能无影响。</strong> <strong>我们可以在自己的类中实现移动语义，避免深拷贝，充分利用右值引用和std::move的语言特性。</strong></p> 
<h3><a id="4__stdforward_283"></a><strong>4. 完美转发 std::forward</strong></h3> 
<p>和<code>std::move</code>一样，它的兄弟<code>std::forward</code>也充满了迷惑性，虽然名字含义是转发，但他并不会做转发，同样也是做类型转换.</p> 
<p>与move相比，forward更强大，move只能转出来右值，forward都可以。</p> 
<blockquote> 
 <p>std::forward(u)有两个参数：T与 u。 a. 当T为左值引用类型时，u将被转换为T类型的左值； b. 否则u将被转换为T类型右值。</p> 
</blockquote> 
<p>举个例子，有main，A，B三个函数，调用关系为：<code>main-&gt;A-&gt;B</code>，建议先看懂<em>2.3节对左右值引用本身是左值还是右值的讨论</em>再看这里：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> ref_r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    ref_r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// A、B的入参是右值引用</span>
<span class="token comment">// 有名字的右值引用是左值，因此ref_r是左值</span>
<span class="token keyword">void</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> ref_r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">B</span><span class="token punctuation">(</span>ref_r<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 错误，B的入参是右值引用，需要接右值，ref_r是左值，编译失败</span>
     
    <span class="token function">B</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ref_r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok，std::move把左值转为右值，编译通过</span>
    <span class="token function">B</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>ref_r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ok，std::forward的T是int类型，属于条件b，因此会把ref_r转为右值</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token function">A</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>例2：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">change2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> ref_r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    ref_r <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">void</span> <span class="token function">change3</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;</span> ref_l<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    ref_l <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token comment">// change的入参是右值引用</span>
<span class="token comment">// 有名字的右值引用是 左值，因此ref_r是左值</span>
<span class="token keyword">void</span> <span class="token function">change</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> ref_r<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token function">change2</span><span class="token punctuation">(</span>ref_r<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 错误，change2的入参是右值引用，需要接右值，ref_r是左值，编译失败</span>
     
    <span class="token function">change2</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ref_r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok，std::move把左值转为右值，编译通过</span>
    <span class="token function">change2</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>ref_r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ok，std::forward的T是右值引用类型(int &amp;&amp;)，符合条件b，因此u(ref_r)会被转换为右值，编译通过</span>
     
    <span class="token function">change3</span><span class="token punctuation">(</span>ref_r<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok，change3的入参是左值引用，需要接左值，ref_r是左值，编译通过</span>
    <span class="token function">change3</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span> <span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>ref_r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ok，std::forward的T是左值引用类型(int &amp;)，符合条件a，因此u(ref_r)会被转换为左值，编译通过</span>
    <span class="token comment">// 可见，forward可以把值转换为左值或者右值</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token function">change</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上边的示例在日常编程中基本不会用到，<code>std::forward</code>最主要运于模版编程的参数转发中，想深入了解需要学习<code>万能引用(T &amp;&amp;)</code>和<code>引用折叠(eg:&amp; &amp;&amp; → ?)</code>等知识，本文就不详细介绍这些了。</p> 
<h3><a id="5_Reference_345"></a>5. Reference</h3> 
<p>https://zhuanlan.zhihu.com/p/374392832</p> 
<p>https://zhuanlan.zhihu.com/p/335994370</p> 
<p>https://www.cnblogs.com/shadow-lr/p/Introduce_Std-move.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/58a728d5da8a6de2cb29e2225b4785e8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[开发语言][c&#43;&#43;]：Static关键字和全局变量</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5638634567fcb7b9b7cf25c26fc26d6c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">[开发语言][python][c&#43;&#43;]：C&#43;&#43;中的this指针和Python中的Self -- 26岁生日</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>