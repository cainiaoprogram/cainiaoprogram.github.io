<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>YOLOV3详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="YOLOV3详解" />
<meta property="og:description" content="1. YOLOV3引入 图来自于江大白的CSDN博客
2. 为什么学习YOLOV3？ YOLOV3跟V2/V1相比采用了残差的思想，可以说是基于ResNet的思想上重新设计了backbone(DarkNet53)。V1/V2的backbone采用的是VGG类型的结构, 借着学习V3, 复习ResNet以及为什么DarkNet会有更好的精度和速度在YOLOV3中加入了FPN层, 这是为什么相比于(V1/V2采用的图像金字塔), V3能够涨点的那么多最重要的原因, 学习图像金字塔的发展到FPN层再手写一个FPN层出来YOLOv3采用了一种基于聚类的正负样本匹配方法，相比于基于IoU的方法，可以更好地适应各种目标尺度和宽高比，并提高模型的精度和稳定性。后续的YOLO也沿用了这种思想，很有学习的必要性。 3. Backbone的改进: DarkNet53 上图
3.1 Plain Model对比 下面这张图是简单模型(Plain Model)的对比, 看一下DarkNet19 vs VGG16, DarkNet53 vs ResNet101
DarkNet19相比于VGG16具有更少的参数量(7.29Bn VS 30.94Bn), 更快的GPU推理速度（6.2ms vs 9.4ms）同样是残差结构的ResNet101和Dark53, 也是同样拥有更少的参数量(18.57Bn vs 19.70Bn)和更高的GPU推理速度 （13.7ms vs 20.0ms） 3.2 DarkNet19(YOLOV2) VS VGG16 较少的参数量: DarkNet19是一个FCN(全卷积的神经网络), 而且还使用了1x1的卷积进行通道数的缩减, VGG系列使用的都是3x3的卷积核而且通道数没有缩减。在网络设计中1x1的卷积核通常是功能性的, 例如减少参数和通道数较快的速度: 也是因为FC层, VGG16最后三个FC层有太多参数, 同样是在ImageNet上做预训练, DarkNet19直接最后一个1x1 1000通道 softmax解决。精度的保持 DarkNet19在后期通道也是增长了，而VGG系列最后一个Block的通道数是没有变化的，这也只是可能的一个因素，这也说明了另一件事VGG系列可能出现了过拟合的现象（个人见解）DarkNet19中使用了批量归一化（Batch Normalization）来加速训练和提高模型的准确性，批量归一化在训练过程中可以加速梯度的传播和收敛，同时也提高了模型的泛化能力，这对于推理速度的提高也有积极的影响。 3.3 残差网络 重点:为什么当时网络深度较浅？DarkNet19, VGG19? 这个疑惑在何凯明大神的ResNet论文中得到了答案，就是对于Plain模型，网络越深，训练误差和测试误差越大，精度可能相较于浅层网络还会有所下降。因为随着网络的加深，会出现梯度的弥散，很多特征会消失在深层网络，导致结果没办法呈现到最佳的效果。
什么是残差连接？为什么对梯度消失有效？带来了什么效果？ 原理主要是把卷积层前后的特征进行元素相加求和，如果特征是在这其中的某一个卷积后消失的，那么残差结构便可以找回丢失的特征。左图为没有使用残差结构的plain模型，右图是使用了残差结构的残差网络ResNet，可以看到使用了残差结构的模型，随着模型深度的增加，误差随着训练的迭代进行也是降低的。
3.4 为什么作者不直接使用精度类似的ResNet101而是重新设计了DarkNet59? 首先他们在block中都用conv3x3代替了(VGG16, DarkNet19)的MaxPooling但是通过对比, ResNet中Block是三层卷积而DarkNet的block是2层卷积, DarkNet53在最后分类前是1024通道而ResNet是2048通道ResNet101中的Stage是3, 4, 23, 3, DarkNet中的Stage是1， 2， 8， 4。可以发现DarkNet的设计更加均衡, 而且最后的通道数其实1024是足够的, FC层之前采用较高的通道数是为了能够提取更加丰富的特征信息, 高通道数的卷积层也有利于模型的泛化能力。 这里也是说明其实1024通道是够的不用上到2048通道所以可以看出来精度高了1个点但是推理速度快乐1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9f7709365a07bc31e140403f261df67c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-21T21:12:46+08:00" />
<meta property="article:modified_time" content="2023-03-21T21:12:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">YOLOV3详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_YOLOV3_0"></a>1. YOLOV3引入</h2> 
<p><strong>图来自于江大白的CSDN博客</strong><br> <img src="https://images2.imgbox.com/72/04/7HuzvaRj_o.png" alt="在这里插入图片描述
sb"></p> 
<h2><a id="2_YOLOV3_5"></a>2. 为什么学习YOLOV3？</h2> 
<ol><li>YOLOV3跟V2/V1相比采用了残差的思想，可以说是基于ResNet的思想上重新设计了backbone(DarkNet53)。</li><li>V1/V2的backbone采用的是VGG类型的结构, 借着学习V3, 复习ResNet以及为什么DarkNet会有更好的精度和速度</li><li>在YOLOV3中加入了FPN层, 这是为什么相比于(V1/V2采用的图像金字塔), V3能够涨点的那么多最重要的原因, 学习图像金字塔的发展到FPN层再手写一个FPN层出来</li><li>YOLOv3采用了一种基于聚类的正负样本匹配方法，相比于基于IoU的方法，可以更好地适应各种目标尺度和宽高比，并提高模型的精度和稳定性。后续的YOLO也沿用了这种思想，很有学习的必要性。</li></ol> 
<h2><a id="3_Backbone_DarkNet53_11"></a>3. Backbone的改进: DarkNet53</h2> 
<p><strong>上图</strong></p> 
<p><img src="https://images2.imgbox.com/6d/fc/73IHfGeU_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="31_Plain_Model_18"></a>3.1 Plain Model对比</h3> 
<p><strong>下面这张图是简单模型(Plain Model)的对比, 看一下DarkNet19 vs VGG16, DarkNet53 vs ResNet101</strong><br> <img src="https://images2.imgbox.com/a8/c7/L4LsSCeD_o.png" alt="在这里插入图片描述"></p> 
<ol><li>DarkNet19相比于VGG16具有更少的参数量(7.29Bn VS 30.94Bn), 更快的GPU推理速度（6.2ms vs 9.4ms）</li><li>同样是残差结构的ResNet101和Dark53, 也是同样拥有更少的参数量(18.57Bn vs 19.70Bn)和更高的GPU推理速度 （13.7ms vs 20.0ms）</li></ol> 
<h3><a id="32_DarkNet19YOLOV2_VS_VGG16_25"></a>3.2 DarkNet19(YOLOV2) VS VGG16</h3> 
<ol><li>较少的参数量: DarkNet19是一个FCN(全卷积的神经网络), 而且还使用了1x1的卷积进行通道数的缩减, VGG系列使用的都是3x3的卷积核而且通道数没有缩减。</li><li>在网络设计中1x1的卷积核通常是功能性的, 例如减少参数和通道数</li><li>较快的速度: 也是因为FC层, VGG16最后三个FC层有太多参数, 同样是在ImageNet上做预训练, DarkNet19直接最后一个1x1 1000通道 softmax解决。</li><li>精度的保持</li></ol> 
<ul><li>DarkNet19在后期通道也是增长了，而VGG系列最后一个Block的通道数是没有变化的，这也只是可能的一个因素，这也说明了另一件事VGG系列可能出现了过拟合的现象（个人见解）</li><li>DarkNet19中使用了批量归一化（Batch Normalization）来加速训练和提高模型的准确性，批量归一化在训练过程中可以加速梯度的传播和收敛，同时也提高了模型的泛化能力，这对于推理速度的提高也有积极的影响。</li></ul> 
<h3><a id="33__36"></a>3.3 残差网络</h3> 
<ol><li><strong>重点:为什么当时网络深度较浅？DarkNet19, VGG19?</strong></li></ol> 
<ul><li>这个疑惑在何凯明大神的ResNet论文中得到了答案，就是对于Plain模型，网络越深，训练误差和测试误差越大，精度可能相较于浅层网络还会有所下降。</li><li>因为随着网络的加深，会出现梯度的弥散，很多特征会消失在深层网络，导致结果没办法呈现到最佳的效果。<br> <img src="https://images2.imgbox.com/0f/0d/ARGTmPB7_o.png" alt="在这里插入图片描述"></li></ul> 
<ol start="2"><li>什么是残差连接？为什么对梯度消失有效？带来了什么效果？</li></ol> 
<ul><li>原理主要是把卷积层前后的特征进行元素相加求和，如果特征是在这其中的某一个卷积后消失的，那么残差结构便可以找回丢失的特征。</li><li><img src="https://images2.imgbox.com/c1/25/yIh4UjbS_o.png" alt="image"></li><li>左图为没有使用残差结构的plain模型，右图是使用了残差结构的残差网络ResNet，可以看到使用了残差结构的模型，随着模型深度的增加，误差随着训练的迭代进行也是降低的。<br> <img src="https://images2.imgbox.com/8e/48/IdqlQaHo_o.png" alt="image"></li></ul> 
<h3><a id="34_ResNet101DarkNet59_48"></a>3.4 为什么作者不直接使用精度类似的ResNet101而是重新设计了DarkNet59?</h3> 
<ol><li>首先他们在block中都用conv3x3代替了(VGG16, DarkNet19)的MaxPooling</li><li>但是通过对比, ResNet中Block是三层卷积而DarkNet的block是2层卷积, DarkNet53在最后分类前是1024通道而ResNet是2048通道</li><li>ResNet101中的Stage是3, 4, 23, 3, DarkNet中的Stage是1， 2， 8， 4。可以发现DarkNet的设计更加均衡</li><li>, 而且最后的通道数其实1024是足够的, FC层之前采用较高的通道数是为了能够提取更加丰富的特征信息, 高通道数的卷积层也有利于模型的泛化能力。 这里也是说明其实1024通道是够的不用上到2048通道</li><li>所以可以看出来精度高了1个点但是推理速度快乐1.5倍还多</li></ol> 
<h2><a id="4__55"></a>4. 图像金字塔发展史</h2> 
<p><strong>YOLOV3很重要的一个改进点就是增加了FPN层进来</strong><br> <img src="https://images2.imgbox.com/58/4c/lVRTHhI5_o.png" alt="image"></p> 
<p>(a). Featurized image pyramid</p> 
<ul><li>可以看成不同下采样stride提取特征, 每一次下采样提取特征就会输出一个Feature Map, 通过这个Feaeture Map做一个predict</li><li>注意对于Feature Map的输出, 并不是直接进行全连接层或卷积层+softmax的操作，因为这样会破坏特征的空间结构信息。如卷积或者空间池化等，来提取目标的位置和特征信息，并生成检测框和类别预测。</li><li>例如DarkNet53用conv + avgpool + softmax VGG用maxpool + fc + fc + fc + softmax。</li></ul> 
<p>(b). Single Feature Map</p> 
<ul><li>只有一个特征图的输出, 就像是我们平时用的resnet等等, 最后的predict头其实是有比较高的语义, 对于尺度的变化也是有更好的鲁棒性</li><li>但是缺点是每层金字塔仍然需要获得最准确的结果, 有研究表明, 图像金字塔每个level都有主要的特点</li><li>任何BackBone都会产生不同大小的特征图, 由于不同深度导致了较大的语义差距。高分辨率特征图具有低层次的特征，这也损害了其对目标识别的表征能力。对于分类不友好，但是对于定位是友好的</li><li>对于上面这句话的解释就是, 举例: 在第一个特征图有一个类别占了1/4的区间, 再往上提特征, 不好分类,但是对于定位友好的</li></ul> 
<p>©. Pyramidal feature hierarchy</p> 
<ul><li>这是SSD的金字塔特征层, 跟(a)有点像但是不同, (a)是对一张图用不同的卷积核操作, 而这个是对一张图不停的下采样</li><li>这样看起确实是很理想的, 但是SSD放弃了使用已有的特征，而是从网络的高层开始构建金字塔，可以理解为他在最上面那个Feature Map的基础上又新增了几个新层(CONV)，从这个地方开始构建的金字塔</li><li><strong>跟图c不一样</strong></li><li>因此，SSD错过了重用特征层次结构的更高分辨率特征的机会。</li></ul> 
<p>(d) Feature Pyramid Network(FPN)</p> 
<ul><li>他在SSD理想的情况下, 每一个Feature Map上采样成跟上一个Feature Map一样大小的然后相加</li><li>YOLOV3是32倍的下采样</li><li>上采样的方法之一反卷积: https://blog.csdn.net/bobchen1017/article/details/128607544</li><li>给ResNet 增加FPN和Focal Loss: https://blog.csdn.net/bobchen1017/article/details/128607709</li></ul> 
<h2><a id="5_YOLOV3FPN_84"></a>5. YOLOV3的图像金字塔(FPN)</h2> 
<p><strong>看图</strong></p> 
<p><img src="https://images2.imgbox.com/b5/8f/h92j7f5X_o.png" alt="image"><br> <img src="https://images2.imgbox.com/20/bb/qZL2bBN7_o.png" alt="image"></p> 
<ol><li>简单点说就是上采样完了之后拼接在一起而不是直接Add在一起，这样拼接出来的Feature Map比较大</li><li>拼接之后的Feature Map会比单个Feature Map大。但是由于上采样后的Feature Map分辨率较低，而下采样后的Feature Map分辨率较高，拼接之后可以保留更多高分辨率的信息，从而提高检测精度。</li><li>同时，由于拼接之后的Feature Map通道数增加，需要更多的计算和存储资源。因此在设计模型时需要权衡精度和效率之间的关系。</li></ol> 
<h2><a id="6_YOLOV3Anchor_94"></a>6. YOLOV3中的Anchor机制</h2> 
<p><img src="https://images2.imgbox.com/ae/76/9NNdj6KR_o.png" alt="image"></p> 
<p><img src="https://images2.imgbox.com/a4/38/j5lZNogv_o.png" alt="image"></p> 
<p>如果输入的是416×416的3通道图像，YOLOv3会产生3个尺度的特征图，分别为：13×13、26×26、52×52，也对应着Grid Cell个数，即总共产生13×13+26×26+52×52个Grid Cell。对于每个Grid Cell，对应3个Anchor Box，于是，最终产生了(13×13+26×26+52×52)×3=10647个预测框。仍然是每个cell输出三个bounding box<br> 其中不同尺度特征图对应的预测框相对预测的目标大小规模也不一样，具体如下：</p> 
<ul><li>13×13预测大目标</li><li>26×26预测中目标</li><li>52×52预测小目标</li></ul> 
<p>yolov3只有这个cell是包含了整个目标才会负责预测和训练</p> 
<p>YOLOv3中的每个cell只有当其负责的区域（即anchor box所覆盖的区域）包含了整个目标时，才会负责预测和训练。这是为了避免同一个目标被多个cell预测，导致重复计算和低效。如果一个cell负责的区域中包含了多个目标，那么该cell会选择覆盖面积最大的目标进行预测和训练。</p> 
<h2><a id="7_YOLOV3cell_111"></a>7. YOLOV3中每一个cell预测的信息</h2> 
<ol><li>输出85 （80 classes + 4(坐标) + 1(label)）</li></ol> 
<p><img src="https://images2.imgbox.com/bf/65/xcfeekvF_o.png" alt="image"></p> 
<h2><a id="8_YOLOV3_116"></a>8. YOLOV3中的坐标表示</h2> 
<ol><li>YOLOv3采用直接预测相对位置的方法预测出bbox中心点相对于Grid Cell左上角的相对坐标。直接预测出(tx,ty,tw,th,t0)，然后通过以下坐标偏移公式计算得到bbox的位置大小和置信度:</li></ol> 
<p><img src="https://images2.imgbox.com/0e/8b/CiuKPHH8_o.png" alt="image"></p> 
<p><img src="https://images2.imgbox.com/81/80/gvFsaA1J_o.png" alt="image"><br> tx、ty、tw、th就是模型的预测输出。cx和cy表示Grid Cell的坐标；</p> 
<p>比如某层的特征图大小是13×13，那么Grid Cell就有13×13个，第0行第1列的Grid Cell的坐标cx就是0，cy就是1。pw和ph表示预测前bbox的size。bx、by、bw和bh就是预测得到的bbox的中心的坐标和宽高。</p> 
<p>在训练这几个坐标值的时候采用了平方和损失，因为这种方式的误差可以很快的计算出来。</p> 
<p>注：这里confidence = P(Object)×IoU 表示框中含有object的置信度和这个box预测的有多准。也就是说，如果这个框对应的是背景，那么这个值应该是 0，如果这个框对应的是前景，那么这个值应该是与对应前景GT的IoU。</p> 
<h2><a id="8__130"></a>8. 正负样本匹配</h2> 
<h3><a id="81__131"></a>8.1 基础补充</h3> 
<p>在目标检测任务中，GT（Ground Truth）指的是数据集中标注的真实目标位置和类别。正样本是指与 GT 匹配的预测框，即预测框与 GT 的 IoU 大于设定阈值的框。负样本是指与 GT 不匹配的预测框，即预测框与 GT 的 IoU 小于设定阈值的框。在一些目标检测算法中，还会引入中立样本（neutral sample），即预测框与 GT 的 IoU 在两个阈值之间的框。正样本和负样本在训练过程中有不同的处理方式，例如计算损失函数时的权重或者是否进行梯度更新等。</p> 
<h3><a id="82__YOLOv3__134"></a>8.2 在 YOLOv3 中，正负样本匹配的过程如下：</h3> 
<ol><li> <p>对于每个 ground truth bbox，找到与其 IoU 最大的 anchor bbox，称之为 positive anchor，标记其为正样本。</p> </li><li> <p>对于剩下的 anchor bboxes，如果其与任意 ground truth bbox 的 IoU 大于一定阈值（默认为 0.5），则标记为正样本；否则标记为负样本。</p> </li></ol> 
<p>其中，正样本是指 anchor bbox 与 ground truth bbox 有显著的重叠，即存在目标物体；负样本是指 anchor bbox 与 ground truth bbox 重叠较少或者不重叠，即不存在目标物体。</p> 
<p>在训练过程中，正样本的损失函数包括分类损失和坐标损失，而负样本仅包括分类损失。这样可以让模型更加关注正样本，提高检测的精度。</p> 
<h3><a id="83__144"></a>8.3 正负样本下的目标检测训练流程</h3> 
<ol><li>首先对标注数据进行正负样本匹配，确定每个样本的类别和对应的先验框（anchor box），然后将匹配出来的正样本送入训练，通过反向传播更新网络参数，不断迭代直至模型收敛。同时，还需要注意正负样本的平衡，即需要保证正样本和负样本的数量比例适当，否则会影响训练效果。</li><li>负样本也会被送去训练。在YOLOv3中，对于一个anchor box，如果它与ground truth box的IoU小于阈值（通常为0.5），那么就被视为负样本。这些负样本也会被用于训练模型，以帮助模型更好地区分正负样本。</li></ol> 
<h3><a id="84_YOLOV3_148"></a>8.4 YOLOV3中正负样本匹配的缺点</h3> 
<p><img src="https://images2.imgbox.com/b8/88/ypfq4WjX_o.png" alt="image"></p> 
<p>在YOLOv3论文中提到正负样本的匹配规则是给每一个GT分配一个正样本，这个正样本是所有bbox中找一个与GT的重叠区域最大的一个预测框，也就是和该GT的IOU最大的预测框。</p> 
<p>如果一个样本不是正样本，那么它既没有定位损失，也没有类别损失，只有置信度损失，在YOLOv3的论文中作者尝试用Focal Loss来缓解正负样本不均匀的问题，但是并没有取得很好的效果，原因就在于负样本值参与了置信度损失，对Loss的影响占比很小。</p> 
<p>但是这么做也有一个缺点，就是用这个匹配规则去寻找正样本，正样本的数量是很少的，这将使得网络难以训练。</p> 
<h2><a id="9_YOLOV3Loss_158"></a>9. YOLOV3的Loss</h2> 
<p>YOLOv3使用的损失函数主要包括三部分：物体置信度损失、分类损失和坐标损失。</p> 
<p>物体置信度损失部分由两部分组成：对于存在物体的Anchor Box，计算其预测框和真实框之间的IOU，并将其作为物体置信度的预测值，使用二元交叉熵损失函数计算其误差；对于不存在物体的Anchor Box，直接将物体置信度预测值设为0，也使用二元交叉熵损失函数计算其误差。</p> 
<p>分类损失部分主要是针对存在物体的Anchor Box，将其预测的物体类别与真实类别之间的交叉熵损失相加。</p> 
<p>坐标损失部分主要是针对存在物体的Anchor Box，计算其预测框和真实框之间的坐标误差，并使用平方误差损失函数计算其误差。</p> 
<p>最终的总损失函数是由上述三部分损失函数加权求和得到的，其中物体置信度损失、分类损失和坐标损失的权重分别为1、1和5。通过训练模型最小化总损失函数，模型可以学习到对物体的位置、类别和置信度进行预测。</p> 
<p><img src="https://images2.imgbox.com/39/f7/C2x6YHnC_o.png" alt="image"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/67ceaa459468cdac69f7aae8cfa3bde5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">keil5中文乱码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f5935734925b3a160501d4a68ca570ff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">axios封装—vue3项目</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>