<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言关于链表的代码看不懂?一篇文章让你拿捏二级指针并深入理解函数参数列表中传参的多种形式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言关于链表的代码看不懂?一篇文章让你拿捏二级指针并深入理解函数参数列表中传参的多种形式" />
<meta property="og:description" content="✅作者简介：别人以梦为马，而我要以码为梦。我是叶落秋白，努力学后端中
✨个人主页：叶落秋白的主页
🔥系列专栏：数据结构干货分享
📃推荐一款模拟面试、刷题神器👉进入刷题的世界
🔥前言
这篇博客即将解决你看不懂或者不会写链表的基本操作的问题，对于初学者而言，有很多地方肯定是费解的。比如函数的参数列表的多样化，动态分配内存空间函数malloc等，其实这些知识和指针联系紧密，尤其是二级指针。那么开始好好的学习这篇博客吧！
📃目录
二级指针讲解
链表的应用 定义双链表的结构体
创建双链表
传入一级指针
传入指针的引用
传入二级指针
✨刷题网推荐
二级指针讲解 简述：其实就是一个指针指向另一个指针的地址。
我们都知道指针指向地址，但是指针自身也是一个变量，当然也可以被二级指针所指向。
语法：形如 int x = 10; int *q = &amp;x; int **p = &amp; q;
那么这里的q指针指向x的地址，p指针指向指针q的地址，*q可以得到x的值，*p可以得到q指针本身，**p也可以得到x的值。
代码示例：
int main(void) { int x = 10; int* q = &amp;x; int** p = &amp;q;	printf(&#34;x 的地址为： %d\n&#34;, &amp;x); printf(&#34;q 指向的地址为：%d\n&#34;, q); printf(&#34;*p的值为： %d\n&#34;, *p); //p指向指针q的地址，那么*p是解引用操作， //就等于了q本身 printf(&#34;x 的值为： %d\n&#34;, x); printf(&#34;q 存取的值为： %d\n&#34;, *q); printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6afcf97dd5eb2df483f9c4c578af39dc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-11T07:13:57+08:00" />
<meta property="article:modified_time" content="2022-07-11T07:13:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言关于链表的代码看不懂?一篇文章让你拿捏二级指针并深入理解函数参数列表中传参的多种形式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>✅作者简介：别人以梦为马，而我要以码为梦。我是叶落秋白，努力学后端中</p> 
 <p>✨个人主页：<a class="link-info" href="https://blog.csdn.net/m0_58618795" title="叶落秋白的主页">叶落秋白的主页</a></p> 
 <p>🔥系列专栏：<a class="link-info" href="https://blog.csdn.net/m0_58618795/category_11806237" title="数据结构干货分享">数据结构干货分享</a></p> 
 <p>📃推荐一款模拟面试、刷题神器👉<a class="link-info" href="https://www.nowcoder.com/link/pc_csdncpt_ylqb_c" rel="nofollow" title="进入刷题的世界">进入刷题的世界</a></p> 
</blockquote> 
<p>🔥<strong>前言</strong></p> 
<blockquote> 
 <p>        这篇博客即将解决你看不懂或者不会写链表的基本操作的问题，对于初学者而言，有很多地方肯定是费解的。比如函数的<span style="color:#38d8f0;"><strong>参数列表</strong></span>的多样化，动态分配内存空间函数<strong><span style="color:#38d8f0;">mallo</span></strong>c等，其实这些知识和<span style="color:#38d8f0;"><strong>指针</strong></span>联系紧密，尤其是二级指针。那么开始好好的学习这篇博客吧！</p> 
</blockquote> 
<p id="main-toc">📃<strong>目录</strong></p> 
<p id="%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E8%AE%B2%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E8%AE%B2%E8%A7%A3" rel="nofollow">二级指针讲解</a></p> 
<p id="%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8%C2%A0-toc" style="margin-left:0px;"><a href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8%C2%A0" rel="nofollow">链表的应用 </a></p> 
<p id="%E5%AE%9A%E4%B9%89%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93-toc" style="margin-left:40px;"><a href="#%E5%AE%9A%E4%B9%89%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93" rel="nofollow">定义双链表的结构体</a></p> 
<p id="%E5%88%9B%E5%BB%BA%E5%8F%8C%E9%93%BE%E8%A1%A8-toc" style="margin-left:40px;"><a href="#%E5%88%9B%E5%BB%BA%E5%8F%8C%E9%93%BE%E8%A1%A8" rel="nofollow">创建双链表</a></p> 
<p id="%E4%BC%A0%E5%85%A5%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88-toc" style="margin-left:80px;"><a href="#%E4%BC%A0%E5%85%A5%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88" rel="nofollow">传入一级指针</a></p> 
<p id="%E4%BC%A0%E5%85%A5%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8-toc" style="margin-left:80px;"><a href="#%E4%BC%A0%E5%85%A5%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8" rel="nofollow">传入指针的引用</a></p> 
<p id="%E4%BC%A0%E5%85%A5%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88-toc" style="margin-left:80px;"><a href="#%E4%BC%A0%E5%85%A5%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88" rel="nofollow">传入二级指针</a></p> 
<p id="%F0%9F%8E%89%E6%80%BB%E7%BB%93%C2%A0-toc" style="margin-left:0px;"><a href="#%F0%9F%8E%89%E6%80%BB%E7%BB%93%C2%A0" rel="nofollow">✨刷题网推荐</a></p> 
<hr> 
<h2 id="%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88%E8%AE%B2%E8%A7%A3">二级指针讲解</h2> 
<blockquote> 
 <p>简述：其实就是一个指针指向另一个指针的<strong><span style="color:#38d8f0;">地址</span>。</strong></p> 
 <p>我们都知道指针指向地址，但是指针自身也是一个<span style="color:#38d8f0;"><strong>变量</strong></span>，当然也可以被二级指针所指向。</p> 
 <p>语法：形如 int x = 10; int *q = &amp;x; int **p = &amp; q;</p> 
 <p>那么这里的q指针指向x的地址，p指针指向指针q的地址，*q可以得到x的值，*p可以得到q指针本身，**p也可以得到x的值。</p> 
</blockquote> 
<p>代码示例：</p> 
<pre><code class="language-cs">int main(void)
{
	int x = 10; 
	int* q = &amp;x;
	int** p = &amp;q;	
	printf("x 的地址为：    %d\n", &amp;x);
	printf("q 指向的地址为：%d\n", q);
	printf("*p的值为：      %d\n", *p);   //p指向指针q的地址，那么*p是解引用操作，
                                          //就等于了q本身
	printf("x 的值为：     %d\n", x);
	printf("q 存取的值为： %d\n", *q);
	printf("**p的值为：    %d\n", **p);    //**p相当于解引用解了两次，第一次先得到q本身，
                                          //第二次得到q指向地址的值
	return 0;
}</code></pre> 
<p>运行结果：</p> 
<p class="img-center"><img alt="" height="219" src="https://images2.imgbox.com/b9/a2/qw1mkTRc_o.png" width="569"></p> 
<h2 id="%E9%93%BE%E8%A1%A8%E7%9A%84%E5%BA%94%E7%94%A8%C2%A0">链表的应用 </h2> 
<p>       <strong> 这里以带头结点的双链表为例</strong></p> 
<h3 id="%E5%AE%9A%E4%B9%89%E5%8F%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93">定义双链表的结构体</h3> 
<pre><code class="language-cs">typedef int ElemType;//将整型数据重命名为int
typedef int Status;//整型重命名为Status

//双链表的数据结构定义
typedef struct DouNode {
    ElemType data;               //数据域
    struct DouNode* head;        //前驱指针
    struct DouNode* next;        //后继指针
}DousList, * LinkList;// 结点指针</code></pre> 
<p>代码解释：</p> 
<blockquote> 
 <p>        利用<span style="color:#38d8f0;"><strong>typedef</strong></span>对数据类型进行重命名，只要在后面遇到的 <span style="color:#38d8f0;"><strong>ElemType</strong></span>和 <span style="color:#38d8f0;"><strong>Status</strong></span>都是整型就够了。双链表结构体包含三个部分：数据域、前驱指针、后继指针，与单链表的区别就是多了一个前驱指针。然后大括号结束部分也是重命名，此时<span style="color:#38d8f0;"><strong>DousList</strong></span>和<span style="color:#38d8f0;"><strong>DouNode</strong></span>效果一样，都是结构体名，然后<span style="color:#38d8f0;"><strong>LinkList</strong></span>是指向结点的指针。</p> 
 <p>具体使用：</p> 
 <p>        LinkList L，L是一个指针，DousList *P，P也是一个指针，属于两种创建方式。</p> 
</blockquote> 
<h3 id="%E5%88%9B%E5%BB%BA%E5%8F%8C%E9%93%BE%E8%A1%A8">创建双链表</h3> 
<p>       <strong> 使用两种正确的创建链表形式和一种错误的形式，对比着记忆创建方法</strong></p> 
<h4 id="%E4%BC%A0%E5%85%A5%E4%B8%80%E7%BA%A7%E6%8C%87%E9%92%88">传入一级指针</h4> 
<p><strong>        这种方式并不能成功创建</strong></p> 
<p>代码演示：</p> 
<pre><code class="language-cpp">void CreateDouList(LinkList L, int n)
{
    LinkList  ptr;
    int i;
    L = (LinkList)malloc(sizeof(DousList));    //为头结点申请空间
    L-&gt;next = NULL;
    L-&gt;head = NULL;
    L-&gt;data = n;//L-&gt;data记录结点的个数
    ptr = L;
    for (i = 0; i &lt; n; i++)
    {
        int value = 0;
        scanf("%d",&amp;value);
        LinkList me = (LinkList)malloc(sizeof(DouNode));
        me-&gt;data = value;    //节点数据域
        me-&gt;next = NULL;
        me-&gt;head = NULL;
        ptr-&gt;next = me;     
        me-&gt;head = ptr;
        ptr = ptr-&gt;next;     //尾插法建表
    }
}</code></pre> 
<p>代码解析： </p> 
<blockquote> 
 <p>         这里的参数列表是 LinkList L 和 整型数据 n，L是传入的链表头结点指针，n是用来记录插入数据的个数的，在下面的for循环用做循环的次数。接下来使用<strong><span style="color:#38d8f0;">malloc</span></strong>函数为L链表分配内存空间，malloc需要用<span style="color:#38d8f0;"><strong>指针</strong></span>来接收，左边的括号是分配的<span style="color:#38d8f0;"><strong>指针类型</strong></span>，右边的括号是分配的内存<span style="color:#38d8f0;"><strong>空间大小</strong></span>。分配空间完成之后初始化前驱和后继指针为空，数据域data记录数据的个数。ptr指针初始等于L指针，接下来进入n次循环，创建待插入结点指针me并进行分配内存空间和初始化，最后三行代码进行尾插法建立链表：</p> 
 <p>尾插法：</p> 
 <p>        先让ptr的后继指针指向me，然后me的head指针指向ptr，这就相当于在链表头把me结点插入链表，然后ptr指向这个插入的新结点，这就保证了每次插入的结点都在上一个插入的结点之后。</p> 
</blockquote> 
<p><strong>但是这样真的在链表中插入数据了吗 ，来看看调试结果：</strong></p> 
<p class="img-center"><img alt="" height="636" src="https://images2.imgbox.com/5e/03/bSfu46KE_o.png" width="1200"></p> 
<p>        <strong>进入遍历的程序时，让创建的ptr指针指向L链表的后继，立马就出现了空指针异常，但是上面明明插入数据了，原因是什么呢? 很明显，这里的链表L并未完成插入数据。这是因为我们在创建链表的函数里传入的只是链表的指针L，那么在函数里这个指针只是一个副本，在这里给他增大内存空间并不会影响到实参链表，这和普通数据类型的值传递和地址传递的情况一致。</strong></p> 
<p><strong>        我们利用传入指针地址来解决这个问题，两个方法：指针的<span style="color:#38d8f0;">引用</span>和<span style="color:#38d8f0;">二级指针</span></strong></p> 
<h4 id="%E4%BC%A0%E5%85%A5%E6%8C%87%E9%92%88%E7%9A%84%E5%BC%95%E7%94%A8">传入指针的引用</h4> 
<p>       <strong> 函数的实现部分完全不用修改，只要形参列表加上一个引用符"&amp;"即可。</strong></p> 
<pre><code class="language-cs">void CreateDouList(LinkList &amp;L, int n);</code></pre> 
<p><strong> 查看调试结果：</strong></p> 
<p class="img-center"><img alt="" height="802" src="https://images2.imgbox.com/8a/41/QXKB0cT4_o.png" width="1035"></p> 
<blockquote> 
 <p>        同样的调试方法，传入指针的引用之后可以清晰的看到L的<span style="color:#38d8f0;"><strong>data</strong></span>等于5，也就是存了五个数据，然后对于的后继结点的值都和尾插的结果一致，最后一个结点的后继指针正好指向NULL，完全<span style="color:#38d8f0;"><strong>符合</strong></span>我们的设计的代码。</p> 
</blockquote> 
<p>       <strong> 传入指针的引用之后，函数里链表的空间变化会导致实参里的链表空间变化，这样做才能使插入操作完成，将结点插入到链表内。</strong></p> 
<h4 id="%E4%BC%A0%E5%85%A5%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88">传入二级指针</h4> 
<p>       <strong> 这个和指针的引用原理一样，我主要分享给你们使用的形式</strong></p> 
<blockquote> 
 <p>    注意调用的时候实参要加“&amp;”符，例：<span style="color:#38d8f0;"><strong>CreateDouList(&amp;L,n)</strong></span>;</p> 
</blockquote> 
<pre><code class="language-cs">void CreateDouList(LinkList *L, int n)
{
    LinkList  ptr;
    int i;
     *L = (LinkList)malloc(sizeof(DousList));    //为头结点申请空间
    (*L)-&gt;next = NULL;
    (*L)-&gt;head = NULL;
    (*L)-&gt;data = n;//L-&gt;data记录结点的个数
    ptr = (*L);
    printf("开始插入数据：\n");
    for (i = 0; i &lt; n; i++)
    {
        int value = 0;
        scanf("%d",&amp;value);
        LinkList me = (LinkList)malloc(sizeof(DouNode));
        me-&gt;data = value;    //节点数据域
        me-&gt;next = NULL;
        me-&gt;head = NULL;
        ptr-&gt;next = me;     
        me-&gt;head = ptr;
        ptr = ptr-&gt;next;     //尾插法建表
    }
}</code></pre> 
<blockquote> 
 <p>        这里形参列表的参数是 LinkList *L，和DousLIst **L效果一样，是一个<span style="color:#38d8f0;"><strong>二级指针</strong></span>。如果用到指向链表的指针就需要一次接引用操作，写成(*L)的形式。然后再去分配空间、进行初始化、赋值给链表指针ptr等操作，这样链表二级指针L的改变也会使实参的链表发生改变，可以查看调试结果。</p> 
</blockquote> 
<p><strong>调试结果：</strong></p> 
<p class="img-center"><img alt="" height="630" src="https://images2.imgbox.com/29/5e/warN9CcK_o.png" width="1200"></p> 
<h2 id="%F0%9F%8E%89%E6%80%BB%E7%BB%93%C2%A0"><strong>✨刷题网推荐</strong></h2> 
<div> 
 <div> 
  <p style="text-align:left;"><span style="color:#333333;">       <strong> 数据结构对于小白来说并不是特别友好，好多知识几天不看就会抛之脑后一定要多巩固学到的知识，因此刷题必不可少。在这里我给大家介绍一个我认为对小白比较友好的刷题平台—</strong></span><span style="background-color:#ffff00;"><span style="color:#333333;"><a class="link-info" href="https://www.nowcoder.com/link/pc_csdncpt_ylqb_c" rel="nofollow" title="牛客网">牛客网</a></span></span></p> 
 </div> 
</div> 
<p class="img-center"><img alt="" height="705" src="https://images2.imgbox.com/2e/38/GaiYuimd_o.png" width="1113"></p> 
<div> 
 <p style="text-align:left;"><span style="color:#333333;"><strong>这些都是经典的链表题，多加练习一定可以巩固知识，拿捏个链表还会是问题吗。</strong></span></p> 
 <p style="text-align:left;"><strong><span style="color:#333333;">        </span>希望大家可以充分利用时间，巩固所学，冲击大厂，让我们共同进步！</strong></p> 
</div> 
<p>    </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/77b17a89ef54c582ddce585fc3f4051d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Apache Httpd报错：AH00558</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a079313f3154962822828dd1ee75b76d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43; AFX_MANAGE_STATE(AfxGetStaticModuleState())的作用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>