<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何将新浪博客备份（使用beautiful soap） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何将新浪博客备份（使用beautiful soap）" />
<meta property="og:description" content="感觉javaeye还不错，很喜欢他能制作电子书的功能。以前在新浪写过一阵博客，不过是技术无关的东西，就想转到这里来，找了找，有些程序，发现也有python的，那么自己肯定也能写点代码导出来。
本来用的正则，这两天调试了几次，发现可以了。中间试验了下，发现新浪的博客有两种，一种是旧版的，一种可能是升级过的，所以改了改，改成可以导出新版的博客。另外大家建议用beautiful soap来弄，就改成用soap来弄的了。
最后试验的时候抓取的是新浪里面的徐静蕾的博客，所有的博客都保存了起来。
下面给出代码，示例当然以老徐的博客为例。
第一步找到博客的uid
#! /usr/bin/env python #coding=utf-8 import urllib2 import sqlite3 as sqlite import time import re from BeautifulSoup import BeautifulSoup #socket.setdefaulttimeout(30) blog=&#34;http://blog.sina.com.cn/xujinglei&#34; req = urllib2.Request(blog) f = urllib2.urlopen(req) #print f.msg #blog1=f.read() soup1 = BeautifulSoup(f) uid=soup1.find(&#34;link&#34;,{&#34;id&#34;:&#34;uid_link_css&#34;}) raw_input(&#34;Press ENTER to exit&#34;) print uid print uid print len(uid) a=str(uid) uida=re.findall(re.compile(r&#39;(\d&#43;).css&#39;),a) len(uida) print uida print uida[0] 后续文章的链接都与这个id有关
下面就是生成页面的链接，现在新版的博客都是js的分页按钮，弄个httpfox直接可以看到链接，链接生成的样式如下。
def urlexit1(a): urllist={} for i in range(1,77): url=&#34;http://blog.sina.com.cn/s/article_sort_&#34;&#43;str(a)&#43;&#34;_10001_&#34;&#43;str(i)&#43;&#34;.html&#34; #print url urllist[i]=url return urllist aa=urlexit1(uida[0]) 因为我还没有仔细看分页的函数在那里，所以就简单的数下，看看他的主页上分了多少个分页，她的是76，这里填上77就可以了。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/66de1f5019408342849ed6acd4c0bb79/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2010-03-03T17:04:29+08:00" />
<meta property="article:modified_time" content="2010-03-03T17:04:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何将新浪博客备份（使用beautiful soap）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>感觉javaeye还不错，很喜欢他能制作电子书的功能。以前在新浪写过一阵博客，不过是技术无关的东西，就想转到这里来，找了找，有些程序，发现也有python的，那么自己肯定也能写点代码导出来。</p> 
<p>本来用的正则，这两天调试了几次，发现可以了。中间试验了下，发现新浪的博客有两种，一种是旧版的，一种可能是升级过的，所以改了改，改成可以导出新版的博客。另外大家建议用beautiful soap来弄，就改成用soap来弄的了。</p> 
<p>最后试验的时候抓取的是新浪里面的徐静蕾的博客，所有的博客都保存了起来。</p> 
<p>下面给出代码，示例当然以老徐的博客为例。</p> 
<p>第一步找到博客的uid</p> 
<pre><code class="language-python">#! /usr/bin/env python
#coding=utf-8
import urllib2
import sqlite3 as sqlite
import time
import re
from BeautifulSoup import BeautifulSoup
#socket.setdefaulttimeout(30) 
blog="http://blog.sina.com.cn/xujinglei"
req = urllib2.Request(blog)
f = urllib2.urlopen(req) 
#print f.msg
#blog1=f.read() 
soup1 = BeautifulSoup(f)
uid=soup1.find("link",{"id":"uid_link_css"})
raw_input("Press ENTER to exit")
print uid
print uid
print len(uid)
a=str(uid)
uida=re.findall(re.compile(r'(\d+).css'),a)
len(uida)
print uida
print uida[0]</code></pre> 
<p>后续文章的链接都与这个id有关</p> 
<p>下面就是生成页面的链接，现在新版的博客都是js的分页按钮，弄个httpfox直接可以看到链接，链接生成的样式如下。</p> 
<pre><code class="language-python">def urlexit1(a):
    urllist={}
    for i in range(1,77):
        url="http://blog.sina.com.cn/s/article_sort_"+str(a)+"_10001_"+str(i)+".html"
        #print url
        urllist[i]=url
        
            
    return urllist
aa=urlexit1(uida[0])
</code></pre> 
<p> 因为我还没有仔细看分页的函数在那里，所以就简单的数下，看看他的主页上分了多少个分页，她的是76，这里填上77就可以了。</p> 
<p>最初我的代码针对我自己的博客，文章不是很多，没有考虑出错、超时等问题，后来去抓老徐的博客的时候文章比较多，超时情况出现的很多，所以就先生成了每篇文章的链接。</p> 
<pre><code class="language-python">cx = sqlite.connect('sina.sqlite')
cu = cx.cursor()
cu.execute('''create table if not exists sina(
        url text primary key,
        title text,
        content text,
        time text
        )''')
cu.execute('''create table if not exists urls(
        url text primary key,
        mainurl text
        )''')
cu.execute('''create table if not exists signal(
        id text primary key
        
        )''')

for i in aa.keys():
    print aa[i]
    #raw_input("Press ENTER to exit")
    req = urllib2.Request(aa[i])
    #print i
    pp = urllib2.urlopen(req) 
    if pp.code==200:
        
        #print entry
        #raw_input("Press ENTER to exitsoup2")#urltitle=re.findall(re.compile(r'href="(.*)" target="_blank" &gt;点击此处查看全文'),entry)
        soup2=BeautifulSoup(pp)
        urlt=soup2.findAll("span",{"class":"SG_more"})
        print pp.msg
        #print "ok"
        #len(str(urlt))
        #print urlt
        #for k in urlt:
        #    urlt1=re.find()
        print "-------------------"
        for ii in urlt:
            urlt1=re.findall(re.compile(r'href="(.+?)"&gt;'),str(ii))
            len(urlt1)
            j=urlt1[0]
            a1=str(j)
            ru='replace into  urls  values("'+a1+'","'+aa[i]+'")'
            print ru
            cu.execute(ru)
            cx.commit()
    rs='replace into  signal  values("'+str(i)+'")'        
    cu.execute(rs)
    cx.commit()
    time.sleep(1)
            
</code></pre> 
<p> </p> 
<p>剩下的事情就简单了，根据每篇文章的地址去抓标题、时间以及文章内容。下面需要考虑的是超时问题，因为文章太多，所以超时停掉重新开始工作太费时间，而且抓的时候还需要设置延时，否则服务器会断开连接。这东西再考虑把</p> 
<p> </p> 
<p>想了想，建了3个sqlite的表，sina存储文章标题、时间、文章内容，urls是每篇文章的地址，signal是用来判断是否完成的。最后写出来的代码，首先进行循环，从第一个分页到第76个分页，循环抓取没分页里面具体每篇文章的地址，然后存储到urls里面，分页全部抓取完后，写入signal一个数字标示。如果中间超时，重启程序，读取signal里面最大值，在rang的地方进行修改，直到全部urls写入完毕后，开始抓取文章，首先select地址库，然后比对，如果已经抓去过的话跳过，没有的话进行抓取，这样即使超时或者拒绝连接，重启程序就可以了，仍然可以继续抓取直到完毕。</p> 
<p>折腾了半天，总算把老徐的博客全抓下来了，一共是754篇，可真不少，现在问题是连接图片还没有抓下来，博客里面的链接还是新浪的，而且文章、标题都在数据库里面，导出成什么样的格式，还需要再考虑考虑。</p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7e4aff56b1dee53f876dfee1b22a1986/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[DnD]Swing Drag And Drop 分析笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a22e1261968c78e4190933d3cfa20762/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VC|MFC学习笔记（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>