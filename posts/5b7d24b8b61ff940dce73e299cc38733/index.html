<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Ubuntu下Qt使用QProcess执行shell脚本并实时输出的标准方法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Ubuntu下Qt使用QProcess执行shell脚本并实时输出的标准方法" />
<meta property="og:description" content="Ubuntu下Qt使用QProcess执行shell脚本并实时输出的标准方法 Qt中执行终端命令和执行shell脚本文件是一个常见需求，一般可以在c&#43;&#43;中直接调用system()实现执行终端命令，shell脚本同样也可以，但是会阻塞程序。实际上更推荐使用Qt中提供的QProcess，高度封装好的功能，拥有非阻塞的优点。
但是我在网上看了很多博客，内容大多数互相转载搬运甚至抄袭，如果跟着大多数博客去使用QProcess的话，分分钟踩坑和浪费时间调试。
常见踩坑，见到避开 很多方法都是教人这么用QProcess，基本会程序阻塞，而且得不到想要的输出结果。
QProcess process; process.start(bash); process.write(&#34;hello.sh&#34;); process.waitForFinished();	//或者用waitForStarted()函数 QByteArray output = process.readAllStandardOutput(); qDebug()&lt;&lt;output; ui-&gt;paintText-&gt;appendPlainText(output); 看到这种直接使用waitForFinished的或者waitForStarted函数的方法的，请及时避雷。
有的方法会使用lambda去写connect连接信号和槽，同样不好用，不是标准的使用方法。
QProcess标准使用方法就是老老实实连接信号与槽 想真正非阻塞地使用QProcess，老老实实按照连接信号与槽的方法去使用。下面介绍标准使用流程：
首先在MainWindow类里创建QProcess； class MainWindow : public QMainWindow { public: ... private: QProcess* process;	//创建私有Qprocess变量，供MainWindow内部调用 } 并且记得在构造函数中new QPrcess； MainWindow::MainWindow { ... process = new QProcess(); ... } 在MainWindow中声明槽函数; class MainWindow : public QMainWindow { public: ... public slots: void processOuptutSlot(); private: ... } 实现槽函数(想要执行命令后有什么功能就在此实现)； void MainWindow::processOuptutSlot() { //输出终端信息 qDebug()&lt;&lt;process-&gt;readAllStandardOutput(); } 在构造函数中连接信号与槽 MainWindow::MainWindow { ." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5b7d24b8b61ff940dce73e299cc38733/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-23T14:42:29+08:00" />
<meta property="article:modified_time" content="2023-10-23T14:42:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Ubuntu下Qt使用QProcess执行shell脚本并实时输出的标准方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="UbuntuQtQProcessshell_0"></a>Ubuntu下Qt使用QProcess执行shell脚本并实时输出的标准方法</h2> 
<p>Qt中执行终端命令和执行shell脚本文件是一个常见需求，一般可以在c++中直接调用system()实现执行终端命令，shell脚本同样也可以，但是会阻塞程序。实际上更推荐使用Qt中提供的QProcess，高度封装好的功能，拥有非阻塞的优点。</p> 
<p>但是我在网上看了很多博客，内容大多数互相转载搬运甚至抄袭，如果跟着大多数博客去使用QProcess的话，分分钟踩坑和浪费时间调试。</p> 
<hr> 
<h3><a id="_7"></a>常见踩坑，见到避开</h3> 
<p>很多方法都是教人这么用QProcess，基本会程序阻塞，而且得不到想要的输出结果。</p> 
<pre><code class="prism language-cpp"> 	QProcess process<span class="token punctuation">;</span>
    process<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span>bash<span class="token punctuation">)</span><span class="token punctuation">;</span>
    process<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"hello.sh"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    process<span class="token punctuation">.</span><span class="token function">waitForFinished</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>		<span class="token comment">//或者用waitForStarted()函数</span>
    QByteArray output <span class="token operator">=</span> process<span class="token punctuation">.</span><span class="token function">readAllStandardOutput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>output<span class="token punctuation">;</span>
    ui<span class="token operator">-&gt;</span>paintText<span class="token operator">-&gt;</span><span class="token function">appendPlainText</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>看到这种直接使用waitForFinished的或者waitForStarted函数的方法的，请及时避雷。</p> 
<p>有的方法会使用lambda去写connect连接信号和槽，同样不好用，不是标准的使用方法。</p> 
<hr> 
<h3><a id="QProcess_25"></a>QProcess标准使用方法就是老老实实连接信号与槽</h3> 
<p>想真正非阻塞地使用QProcess，<strong>老老实实按照连接信号与槽的方法去使用</strong>。下面介绍标准使用流程：</p> 
<ol><li>首先在MainWindow类里创建QProcess；</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">MainWindow</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">QMainWindow</span></span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		QProcess<span class="token operator">*</span> process<span class="token punctuation">;</span>		<span class="token comment">//创建私有Qprocess变量，供MainWindow内部调用</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="2"><li>并且记得在构造函数中new QPrcess；</li></ol> 
<pre><code class="prism language-cpp">MainWindow<span class="token double-colon punctuation">::</span>MainWindow
<span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	process <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">QProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="3"><li>在MainWindow中声明槽函数;</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">MainWindow</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">QMainWindow</span></span>
<span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token keyword">public</span> slots<span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token function">processOuptutSlot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="4"><li>实现槽函数(想要执行命令后有什么功能就在此实现)；</li></ol> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token class-name">MainWindow</span><span class="token double-colon punctuation">::</span><span class="token function">processOuptutSlot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token comment">//输出终端信息</span>
	<span class="token function">qDebug</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span>process<span class="token operator">-&gt;</span><span class="token function">readAllStandardOutput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="5"><li>在构造函数中连接信号与槽</li></ol> 
<pre><code class="prism language-cpp">MainWindow<span class="token double-colon punctuation">::</span>MainWindow
<span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	<span class="token comment">//readyReadStandardOutput是QProcess提供的信息，具体查阅QT助手</span>
	<span class="token class-name">QObject</span><span class="token double-colon punctuation">::</span><span class="token function">connect</span><span class="token punctuation">(</span>process<span class="token punctuation">,</span> <span class="token function">SIGNAL</span><span class="token punctuation">(</span><span class="token function">readyReadStandardOutput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token function">SLOT</span><span class="token punctuation">(</span><span class="token function">processOutputSlot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="6"><li>使用QProcess然后触发readyReadStandardOutput信号</li></ol> 
<pre><code class="prism language-cpp"><span class="token comment">//通常在某个按钮的槽函数或者某个函数中调用process执行命令</span>
<span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
	process<span class="token operator">-&gt;</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token string">"bash"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    process<span class="token operator">-&gt;</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"./home/hello.sh\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//使用sh脚本的路径，结尾必须加上\n，代表回车</span>
    <span class="token comment">//或者尝试使用别的命令</span>
    <span class="token comment">//prcess-&gt;write("ls\n");</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>只要命令有输出，就会不断激活readyReadStandardOutput信号(通常不止一次)，然后执行槽函数输出信息，输出信息完结了就不会激活readyReadStandardOutput信号了。<strong>整个过程非阻塞</strong>。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2cd502deba74580cfa329c314abac945/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">windows server backup 无法使用或wbadmin.msc致命错误解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c42676fb831ce4ab6a23d32a68ef95cf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Qt使用一行代码轻松改变按钮图标颜色</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>