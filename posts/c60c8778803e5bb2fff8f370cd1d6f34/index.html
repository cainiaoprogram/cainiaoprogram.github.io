<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>React Native安卓源码学习（一 ） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="React Native安卓源码学习（一 ）" />
<meta property="og:description" content="原文地址：http://blog.csdn.net/BingHongChaZuoAn/article/details/53011923
Android加载jsbundle详解。
前段时间做了个 React Native的项目，也没时间好好研究下React Native 安卓端的代码。现在闲下来了，看了看Android端的源码，感受颇深。做下总结，也方便自己以后回顾学习。
首先看主Activity
public class MainActivity extends ReactActivity { /** * Returns the name of the main component registered from JavaScript. * This is used to schedule rendering of the component. */ @Override protected String getMainComponentName() { return &#34;xxx&#34;; } } 这里只有一个方法 getMainComponentName，获取的是jsbundle加载的首组件名字。也可以叫做启动页吧，这里必须和jsbundle里面设置的一致。
既然 MainActivity 继承ReactActivity ，那么接下来我们来看 ReactActivity 吧。
private final ReactActivityDelegate mDelegate; protected ReactActivity() { mDelegate = createReactActivityDelegate(); } @Override protected void onCreate(Bundle savedInstanceState) { super." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c60c8778803e5bb2fff8f370cd1d6f34/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-11-02T20:30:27+08:00" />
<meta property="article:modified_time" content="2016-11-02T20:30:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">React Native安卓源码学习（一 ）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>原文地址：<a href="http://blog.csdn.net/BingHongChaZuoAn/article/details/53011923">http://blog.csdn.net/BingHongChaZuoAn/article/details/53011923</a></p> 
<p>Android加载jsbundle详解。</p> 
<p>前段时间做了个 React Native的项目，也没时间好好研究下React Native 安卓端的代码。现在闲下来了，看了看Android端的源码，感受颇深。做下总结，也方便自己以后回顾学习。</p> 
<p>首先看主Activity</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReactActivity</span> {<!-- --></span>

    <span class="hljs-javadoc">/**
     * Returns the name of the main component registered from JavaScript.
     * This is used to schedule rendering of the component.
     */</span>
    <span class="hljs-annotation">@Override</span>
    <span class="hljs-keyword">protected</span> String <span class="hljs-title">getMainComponentName</span>() {
        <span class="hljs-keyword">return</span> <span class="hljs-string">"xxx"</span>;
    }
}</code></pre> 
<p>这里只有一个方法 getMainComponentName，获取的是jsbundle加载的首组件名字。也可以叫做启动页吧，这里必须和jsbundle里面设置的一致。</p> 
<p>既然 MainActivity 继承ReactActivity ，那么接下来我们来看 ReactActivity 吧。</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReactActivityDelegate mDelegate;

<span class="hljs-keyword">protected</span> <span class="hljs-title">ReactActivity</span>() {
    mDelegate = createReactActivityDelegate();
  }

 <span class="hljs-annotation">@Override</span>
  <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span>(Bundle savedInstanceState) {
    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);
    mDelegate.onCreate(savedInstanceState);
  }
</code></pre> 
<p>看到这，其实这里面也没啥东西 ，对我们游泳的代码都 在ReactActivityDelegate 里面。那么好吧，看下ReactActivityDelegate。</p> 
<pre class="prettyprint"><code class=" hljs avrasm"> protected void onCreate(Bundle savedInstanceState) {
    if (getReactNativeHost()<span class="hljs-preprocessor">.getUseDeveloperSupport</span>() &amp;&amp; Build<span class="hljs-preprocessor">.VERSION</span><span class="hljs-preprocessor">.SDK</span>_INT &gt;= <span class="hljs-number">23</span>) {
      // Get permission to show redbox <span class="hljs-keyword">in</span> dev builds.
      if (!Settings<span class="hljs-preprocessor">.canDrawOverlays</span>(getContext())) {
        Intent serviceIntent = new Intent(Settings<span class="hljs-preprocessor">.ACTION</span>_MANAGE_OVERLAY_PERMISSION)<span class="hljs-comment">;</span>
        getContext()<span class="hljs-preprocessor">.startActivity</span>(serviceIntent)<span class="hljs-comment">;</span>
        FLog<span class="hljs-preprocessor">.w</span>(ReactConstants<span class="hljs-preprocessor">.TAG</span>, REDBOX_PERMISSION_MESSAGE)<span class="hljs-comment">;</span>
        Toast<span class="hljs-preprocessor">.makeText</span>(getContext(), REDBOX_PERMISSION_MESSAGE, Toast<span class="hljs-preprocessor">.LENGTH</span>_LONG)<span class="hljs-preprocessor">.show</span>()<span class="hljs-comment">;</span>
      }
    }

    if (mMainComponentName != null) {
      loadApp(mMainComponentName)<span class="hljs-comment">;</span>
    }
    mDoubleTapReloadRecognizer = new DoubleTapReloadRecognizer()<span class="hljs-comment">;</span>
  }</code></pre> 
<p>意思是说如果安卓版本大于23并且支持ReactNativeHost ，如果不可以弹窗口，就会去调用弹窗口的权限，这是Android6.0特有的调用权限方式，还是没啥用，往下看，终于看到有用的了 loadApp(mMainComponentName)。</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadApp</span>(String appKey) {
    <span class="hljs-keyword">if</span> (mReactRootView != <span class="hljs-keyword">null</span>) {
      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Cannot loadApp while app is already running."</span>);
    }
    mReactRootView = createRootView();
    mReactRootView.startReactApplication(
      getReactNativeHost().getReactInstanceManager(),
      appKey,
      getLaunchOptions());
    getPlainActivity().setContentView(mReactRootView);
  }</code></pre> 
<p>if (mReactRootView != null)说明 启动的时候mReactRootView必须为空 ，然后去创建一个新的ReactRootView。然后在ReactRootView上绘制组件。最后绑定ReactRootView到窗体。 <br> ReactRootView的内容先不看了，看下如何绘制吧。</p> 
<pre class="prettyprint"><code class=" hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startReactApplication</span>(
      ReactInstanceManager reactInstanceManager,
      String moduleName,
      @Nullable Bundle launchOptions) {
    UiThreadUtil.assertOnUiThread();

    <span class="hljs-comment">// TODO(6788889): Use POJO instead of bundle here, apparently we can't just use WritableMap</span>
    <span class="hljs-comment">// here as it may be deallocated in native after passing via JNI bridge, but we want to reuse</span>
    <span class="hljs-comment">// it in the case of re-creating the catalyst instance</span>
    Assertions.assertCondition(
        mReactInstanceManager == <span class="hljs-keyword">null</span>,
        <span class="hljs-string">"This root view has already been attached to a catalyst instance manager"</span>);

    mReactInstanceManager = reactInstanceManager;
    mJSModuleName = moduleName;
    mLaunchOptions = launchOptions;

    <span class="hljs-keyword">if</span> (!mReactInstanceManager.hasStartedCreatingInitialContext()) {
      mReactInstanceManager.createReactContextInBackground();
    }

    <span class="hljs-comment">// We need to wait for the initial onMeasure, if this view has not yet been measured, we set which</span>
    <span class="hljs-comment">// will make this view startReactApplication itself to instance manager once onMeasure is called.</span>
    <span class="hljs-keyword">if</span> (mWasMeasured) {
      attachToReactInstanceManager();
    }
  }</code></pre> 
<p>还是没有看到根源，看到里面最重要的一句 mReactInstanceManager.createReactContextInBackground(); <br> 那么看下createReactContextInBackground()。</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-annotation">@Override</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createReactContextInBackground</span>() {
    Assertions.assertCondition(
        !mHasStartedCreatingInitialContext,
        <span class="hljs-string">"createReactContextInBackground should only be called when creating the react "</span> +
            <span class="hljs-string">"application for the first time. When reloading JS, e.g. from a new file, explicitly"</span> +
            <span class="hljs-string">"use recreateReactContextInBackground"</span>);

    mHasStartedCreatingInitialContext = <span class="hljs-keyword">true</span>;
    recreateReactContextInBackgroundInner();
  }
</code></pre> 
<p>好吧，代码藏的好深，继续看 recreateReactContextInBackgroundInner();</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recreateReactContextInBackgroundInner</span>() {
    UiThreadUtil.assertOnUiThread();

    <span class="hljs-keyword">if</span> (mUseDeveloperSupport &amp;&amp; mJSMainModuleName != <span class="hljs-keyword">null</span>) {
      <span class="hljs-keyword">final</span> DeveloperSettings devSettings = mDevSupportManager.getDevSettings();

      <span class="hljs-comment">// If remote JS debugging is enabled, load from dev server.</span>
      <span class="hljs-keyword">if</span> (mDevSupportManager.hasUpToDateJSBundleInCache() &amp;&amp;
          !devSettings.isRemoteJSDebugEnabled()) {
        <span class="hljs-comment">// If there is a up-to-date bundle downloaded from server,</span>
        <span class="hljs-comment">// with remote JS debugging disabled, always use that.</span>
        onJSBundleLoadedFromServer();
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (mBundleLoader == <span class="hljs-keyword">null</span>) {
        mDevSupportManager.handleReloadJS();
      } <span class="hljs-keyword">else</span> {
        mDevSupportManager.isPackagerRunning(
            <span class="hljs-keyword">new</span> DevServerHelper.PackagerStatusCallback() {
              <span class="hljs-annotation">@Override</span>
              <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPackagerStatusFetched</span>(<span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> packagerIsRunning) {
                UiThreadUtil.runOnUiThread(
                    <span class="hljs-keyword">new</span> Runnable() {
                      <span class="hljs-annotation">@Override</span>
                      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>() {
                        <span class="hljs-keyword">if</span> (packagerIsRunning) {
                          mDevSupportManager.handleReloadJS();
                        } <span class="hljs-keyword">else</span> {
                          <span class="hljs-comment">// If dev server is down, disable the remote JS debugging.</span>
                          devSettings.setRemoteJSDebugEnabled(<span class="hljs-keyword">false</span>);
                          recreateReactContextInBackgroundFromBundleLoader();
                        }
                      }
                    });
              }
            });
      }
      <span class="hljs-keyword">return</span>;
    }

    recreateReactContextInBackgroundFromBundleLoader();
  }
</code></pre> 
<p>意思是如果更新缓存jsBundle，并且远程调试可以用，那么从jsBundle服务器加载jsBundle。如果mBundleLoader不为空，就用mBundleLoader加载jsBundle。其他的就是加载本地缓存的jsBundle，先把devSettings.setRemoteJSDebugEnabled设置为false，然后去加载jsBundle。动态更新用的就是第二种，后面再说。接着看 <br> recreateReactContextInBackgroundFromBundleLoader()吧。</p> 
<pre class="prettyprint"><code class=" hljs cs"> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recreateReactContextInBackgroundFromBundleLoader</span>() {
    recreateReactContextInBackground(
        <span class="hljs-keyword">new</span> JSCJavaScriptExecutor.Factory(mJSCConfig.getConfigMap()),
        mBundleLoader);
  }

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recreateReactContextInBackground</span>(
      JavaScriptExecutor.Factory jsExecutorFactory,
      JSBundleLoader jsBundleLoader) {
    UiThreadUtil.assertOnUiThread();

    ReactContextInitParams initParams =
        <span class="hljs-keyword">new</span> ReactContextInitParams(jsExecutorFactory, jsBundleLoader);
    <span class="hljs-keyword">if</span> (mReactContextInitAsyncTask == <span class="hljs-keyword">null</span>) {
      <span class="hljs-comment">// No background task to create react context is currently running, create and execute one.</span>
      mReactContextInitAsyncTask = <span class="hljs-keyword">new</span> ReactContextInitAsyncTask();
      mReactContextInitAsyncTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, initParams);
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// Background task is currently running, queue up most recent init params to recreate context</span>
      <span class="hljs-comment">// once task completes.</span>
      mPendingReactContextInitParams = initParams;
    }
  }
</code></pre> 
<p>看来重点是ReactContextInitAsyncTask了。</p> 
<pre class="prettyprint"><code class=" hljs cs"> <span class="hljs-keyword">private</span> final <span class="hljs-keyword">class</span> ReactContextInitAsyncTask extends
      AsyncTask&lt;ReactContextInitParams, Void, Result&lt;ReactApplicationContext&gt;&gt; {
    @Override
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPreExecute</span>() {
      <span class="hljs-keyword">if</span> (mCurrentReactContext != <span class="hljs-keyword">null</span>) {
        tearDownReactContext(mCurrentReactContext);
        mCurrentReactContext = <span class="hljs-keyword">null</span>;
      }
    }

    @Override
    <span class="hljs-keyword">protected</span> Result&lt;ReactApplicationContext&gt; <span class="hljs-title">doInBackground</span>(ReactContextInitParams... <span class="hljs-keyword">params</span>) {
      <span class="hljs-comment">// TODO(t11687218): Look over all threading</span>
      <span class="hljs-comment">// Default priority is Process.THREAD_PRIORITY_BACKGROUND which means we'll be put in a cgroup</span>
      <span class="hljs-comment">// that only has access to a small fraction of CPU time. The priority will be reset after</span>
      <span class="hljs-comment">// this task finishes: https://android.googlesource.com/platform/frameworks/base/+/d630f105e8bc0021541aacb4dc6498a49048ecea/core/java/android/os/AsyncTask.java#256</span>
      Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);

      Assertions.assertCondition(<span class="hljs-keyword">params</span> != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-keyword">params</span>.length &gt; <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-keyword">params</span>[<span class="hljs-number">0</span>] != <span class="hljs-keyword">null</span>);
      <span class="hljs-keyword">try</span> {
        JavaScriptExecutor jsExecutor = <span class="hljs-keyword">params</span>[<span class="hljs-number">0</span>].getJsExecutorFactory().create();
        <span class="hljs-keyword">return</span> Result.of(createReactContext(jsExecutor, <span class="hljs-keyword">params</span>[<span class="hljs-number">0</span>].getJsBundleLoader()));
      } <span class="hljs-keyword">catch</span> (Exception e) {
        <span class="hljs-comment">// Pass exception to onPostExecute() so it can be handled on the main thread</span>
        <span class="hljs-keyword">return</span> Result.of(e);
      }
    }

    @Override
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPostExecute</span>(Result&lt;ReactApplicationContext&gt; result) {
      <span class="hljs-keyword">try</span> {
        setupReactContext(result.<span class="hljs-keyword">get</span>());
      } <span class="hljs-keyword">catch</span> (Exception e) {
        mDevSupportManager.handleException(e);
      } <span class="hljs-keyword">finally</span> {
        mReactContextInitAsyncTask = <span class="hljs-keyword">null</span>;
      }

      <span class="hljs-comment">// Handle enqueued request to re-initialize react context.</span>
      <span class="hljs-keyword">if</span> (mPendingReactContextInitParams != <span class="hljs-keyword">null</span>) {
        recreateReactContextInBackground(
            mPendingReactContextInitParams.getJsExecutorFactory(),
            mPendingReactContextInitParams.getJsBundleLoader());
        mPendingReactContextInitParams = <span class="hljs-keyword">null</span>;
      }
    }

    @Override
    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCancelled</span>(Result&lt;ReactApplicationContext&gt; reactApplicationContextResult) {
      <span class="hljs-keyword">try</span> {
        mMemoryPressureRouter.destroy(reactApplicationContextResult.<span class="hljs-keyword">get</span>());
      } <span class="hljs-keyword">catch</span> (Exception e) {
        FLog.w(ReactConstants.TAG, <span class="hljs-string">"Caught exception after cancelling react context init"</span>, e);
      } <span class="hljs-keyword">finally</span> {
        mReactContextInitAsyncTask = <span class="hljs-keyword">null</span>;
      }
    }
  }</code></pre> 
<p>恩 ，看到这差不多了，我们看到一个异步js解析器JavaScriptExecutor，它会异步解析jsBundle，然后把解析好的jsBundle给到前端页面。</p> 
<p>好了 整个jsBundle的加载过程我们基本大致了解了，如果想详细看的话，还需要仔细钻研下代码。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1e4f23c6c9708995df2d913db9c231a4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL数据类型介绍</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ab77cd533601a69b6f15f480b349a0f6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">TCP/IP、Http、Socket的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>