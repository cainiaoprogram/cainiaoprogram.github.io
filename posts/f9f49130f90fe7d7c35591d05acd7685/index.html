<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Marching Cubes算法再回顾 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Marching Cubes算法再回顾" />
<meta property="og:description" content="1,确定包含等值面的体元 首先介绍一下 体元的概念，体元是三维图像中由相邻的八个体素点组成的正方体方格，英语也叫 Cube，体元中角点函数值分为两种情况，一种是大于等于给定等值面的值 C0 ,则将角点设为 1 称该角点在等值面内部，否则设为0，在等值面之外，
一般来说，会出现一个角点在内，一个角点在外，则角点之间的连线(也就是体元的边)必然与等值面相交，根据这个原理就能判断等值面与哪些体元相交。
——————————————————————————————————————
三维空间中，平行且相邻的两个二维图像（每个图像中的正方形四个像素顶点组成一个基本的像素图像单元）组成一个基本的三维图像单元。，下图中由6个这样的基本三维图像单元：
vtkImageData结构由尺寸、间距和原点来定义。尺寸标注是沿着每个主轴的体素或像素的数量。原点是数据的第一个切片的左下角的世界坐标位置。间距是沿三个主要轴的像素之间的距离。
原点是数据集左下角的世界坐标位置。
尺寸是沿着三个主要轴的体素或像素的数量。
间距是体素的高度、长度和宽度，或相邻像素之间的距离，这取决于是将数据视为相同的方框还是连续函数中的样本点。
——————————————————————————————————————————
Marching Cubes算法根据一个立方体的8个顶点，判断这8个顶点的每个顶点在等值面的内部还是外部（每个顶点只有“在等值面内”和“在等值面外”这两种状态，设为0和1）从而根据这8个顶点的状态，建立一个包含共256种状态的查找表（根据平面对称性、中心对称性，256种最终降到15种）。
顶点值高于等值在表面的内部，等于等值在表面上，低于等值在表面外。
体元的每个顶点有两种状态，总共有256种，可以制作一个查找表(look up table)
但由于反转状态不变，所以可以减少一半，为128种。
再根据旋转不变形，又可以减少到15种情况。
可以认为这15种情况类似于基，经过旋转，反转可以得到256种状态对应的结果Triangulated Cubes：
根据每个顶点的状态，我们可以为每类制作一个8位索引Cube Numbering：
索引指向边表，给出了边的交叉情况。
相交边的编码——通过编码记录对应的cube，相交边的编号
二进制：00000010
十进制：2
Table[256]表示哪些边有交点
Table[2]=0x103=0000 0010 0000 0011
表示0,1,9号边上有交点
为了避免每次转化成二进制进行解码，可以直接记录与哪些边有交点，之后直接查表即可。
Table2[256][16]
Table2[2]=(0, 1, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
因为每个正方体中最多有1个或4个三角形，所以线性插值就足够了。
2，确定等值面与体元边界的交点 找到含有等值面的体元之后，接下来就是确定等值面与体元边界的交点，体元间的数值都是呈线性变化，求交点时一般采用的是线性插值，如 Case0 中等值面的两个端点 一个在外为( 标记0) ，一个在内 ( 标记为1 ) 则交点为0.5；
3，求等值面的法向量 以上步骤 1，2，3 为实现 MC 算法步骤流程，但利用 VTK ，不需要这么繁琐，主要算法步骤都已经封装到 vtkMarchingCube 类中，使用 vtkMarchingCube 时，需要设置三个参数：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f9f49130f90fe7d7c35591d05acd7685/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-08T12:57:26+08:00" />
<meta property="article:modified_time" content="2024-01-08T12:57:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Marching Cubes算法再回顾</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h5><strong>1,确定包含等值面的体元</strong></h5> 
<p>首先介绍一下 <code>体元</code>的概念，体元是三维图像中由相邻的八个体素点组成的正方体方格，英语也叫 <code>Cube</code>，体元中角点函数值分为两种情况，一种是大于等于给定等值面的值 <code>C0</code> ,则将角点设为 <code>1</code> 称该角点在等值面内部，否则设为<code>0</code>，在等值面之外，</p> 
<p>一般来说，会出现一个角点在内，一个角点在外，则角点之间的连线(也就是体元的边)必然与等值面相交，根据这个原理就能判断等值面与哪些体元相交。</p> 
<p>——————————————————————————————————————</p> 
<p>三维空间中，平行且相邻的两个二维图像（每个图像中的正方形四个像素顶点组成一个基本的像素图像单元）组成一个基本的三维图像单元。，下图中由6个这样的基本三维图像单元：</p> 
<p><img alt="" height="335" src="https://images2.imgbox.com/0e/23/PUWZvi0z_o.png" width="483"></p> 
<p>vtkImageData结构由尺寸、间距和原点来定义。尺寸标注是沿着每个主轴的体素或像素的数量。原点是数据的第一个切片的左下角的世界坐标位置。间距是沿三个主要轴的像素之间的距离。</p> 
<p>原点是数据集左下角的世界坐标位置。</p> 
<p>尺寸是沿着三个主要轴的体素或像素的数量。</p> 
<p>间距是体素的高度、长度和宽度，或相邻像素之间的距离，这取决于是将数据视为相同的方框还是连续函数中的样本点。<br> ——————————————————————————————————————————</p> 
<p><strong>Marching Cubes算法根据一个立方体的8个顶点，判断这8个顶点的每个顶点在等值面的内部还是外部（每个顶点只有“在等值面内”和“在等值面外”这两种状态，设为</strong>0和1<strong>）从而根据这8个顶点的状态，建立一个包含共256种状态的查找表（</strong>根据平面对称性、中心对称性，256种最终降到15种<strong>）。</strong></p> 
<p></p> 
<p>顶点值高于等值在表面的内部，等于等值在表面上，低于等值在表面外。</p> 
<p></p> 
<p class="img-center"><img alt="" height="262" src="https://images2.imgbox.com/f9/6e/NdcqGbPg_o.jpg" width="426"></p> 
<p>体元的每个顶点有两种状态，总共有256种，可以制作一个查找表(look up table)</p> 
<p>但由于反转状态不变，所以可以减少一半，为128种。</p> 
<p>再根据旋转不变形，又可以减少到15种情况。</p> 
<p></p> 
<p>可以认为这15种情况类似于基，经过旋转，反转可以得到256种状态对应的结果Triangulated Cubes：</p> 
<p></p> 
<p class="img-center"><img alt="" height="440" src="https://images2.imgbox.com/8e/94/5JS16t5o_o.png" width="318"></p> 
<p>根据每个顶点的状态，我们可以为每类制作一个8位索引Cube Numbering：</p> 
<p></p> 
<p class="img-center"><img alt="" height="357" src="https://images2.imgbox.com/e2/4b/IipnQyIM_o.png" width="427"></p> 
<p>索引指向边表，给出了边的交叉情况。</p> 
<p>相交边的编码——通过编码记录对应的cube，相交边的编号</p> 
<p>二进制：00000010</p> 
<p>十进制：2</p> 
<p>Table[256]表示哪些边有交点</p> 
<p>Table[2]=0x103=0000 0010 0000 0011</p> 
<p>表示0,1,9号边上有交点</p> 
<p>为了避免每次转化成二进制进行解码，可以直接记录与哪些边有交点，之后直接查表即可。</p> 
<p>Table2[256][16]</p> 
<p>Table2[2]=(0, 1, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)</p> 
<p>因为<strong>每个正方体中最多有1个或4个三角形</strong>，所以线性插值就足够了。</p> 
<p></p> 
<h5><strong>2，确定等值面与体元边界的交点</strong></h5> 
<p>找到含有等值面的体元之后，接下来就是确定等值面与体元边界的交点，体元间的数值都是呈线性变化，求交点时一般采用的是线性插值，如 <strong>Case0</strong> 中<strong>等值面的两个端点 一个在外为( 标记<code>0</code>) ，一个在内 ( 标记为<code>1</code> ) 则交点为0.5；</strong></p> 
<p></p> 
<h5><a name="t5"></a><strong>3，求等值面的法向量</strong></h5> 
<p>以上步骤 <code>1，2，3</code> 为实现 <code>MC</code> 算法步骤流程，但利用 VTK ，不需要这么繁琐，主要算法步骤都已经封装到 <code>vtkMarchingCube</code> 类中，使用 <code>vtkMarchingCube</code> 时，需要设置三个参数：</p> 
<ul><li><code>SetValue(int i,double value)</code> 设置第i 个等值面的值<code>b</code>，(提醒一下，医学图像中的灰度值范围不是 <code>0-256</code> 而是<code>0-65326</code>，但大部分取值范围都在<code>0-1000</code>）。</li><li><code>SetNumberofContours(int number)</code>，设置等值面的个数</li><li><code>ComputerNormalsOn()</code> 设置计算等值面的法向量，提高渲染质量；</li></ul> 
<p></p> 
<p><img alt="dab9fdfd6e307b681d5c9054c536065e.png" src="https://images2.imgbox.com/29/62/Sybpx0Si_o.png"></p> 
<p>上面这张图显示的就是 vtk 呈像的基本流程，下面是仿照官网写的用面绘制来对图像重建的代码部分：</p> 
<pre><code>#include&lt;vtkRenderWindow.h&gt;
#include&lt;vtkRenderWindowInteractor.h&gt;
#include&lt;vtkDICOMImageReader.h&gt;
#include&lt;vtkMarchingCubes.h&gt;
#include&lt;vtkPolyDataMapper.h&gt;
#include&lt;vtkStripper.h&gt;
#include&lt;vtkActor.h&gt;
#include&lt;vtkProperty.h&gt;
#include&lt;vtkCamera.h&gt;
#include&lt;vtkOutlineFilter.h&gt;
#include&lt;vtkOBJExporter.h&gt;
#include&lt;vtkRenderer.h&gt;
#include&lt;vtkMetaImageReader.h&gt;
#include&lt;vtkInteractorStyleTrackballCamera.h&gt;
 
 
#include&lt;iostream&gt;
#include&lt;string.h&gt;
//需要进行初始化，否则会报错
#include &lt;vtkAutoInit.h&gt; 
#include&lt;vtkRenderingVolumeOpenGL2ObjectFactory.h&gt;
#include&lt;vtkRenderingOpenGL2ObjectFactory.h&gt;
 
using namespace std;
int main()
{
    ///Marching Cube; 
 
    vtkObjectFactory::RegisterFactory(vtkRenderingOpenGL2ObjectFactory::New());
    vtkObjectFactory::RegisterFactory(vtkRenderingVolumeOpenGL2ObjectFactory::New());
 
    vtkSmartPointer&lt;vtkRenderer&gt; ren = vtkSmartPointer&lt;vtkRenderer&gt;::New();
    vtkSmartPointer&lt;vtkRenderWindow&gt; renWin = vtkSmartPointer&lt;vtkRenderWindow&gt;::New();//WINDOW；
 
    renWin-&gt;AddRenderer(ren);
 
    vtkSmartPointer&lt;vtkRenderWindowInteractor&gt; iren = vtkSmartPointer&lt;vtkRenderWindowInteractor&gt;::New();//wininteratcor;
    iren-&gt;SetRenderWindow(renWin);
 
    vtkSmartPointer&lt;vtkDICOMImageReader&gt; reader = vtkSmartPointer&lt;vtkDICOMImageReader&gt;::New();
    reader-&gt;SetDirectoryName("E:/DIcom_Data/DICOM");
    reader-&gt;SetDataByteOrderToLittleEndian();
    reader-&gt;Update();
 
 
    /*vtkDICOMImageReader *reader = vtkDICOMImageReader::New();
    reader-&gt;SetDirectoryName("E:/Coding Pra/VTK/VTK_Examples_StandardFormats_Input_DicomTestImages/DICOM");
    reader-&gt;SetDataByteOrderToLittleEndian();
    reader-&gt;Update();*/
 
    cout &lt;&lt; "读取数据完毕" &lt;&lt; endl;
    cout &lt;&lt; "The width is" &lt;&lt; reader-&gt;GetWidth() &lt;&lt; endl;
    cout &lt;&lt; "The height is" &lt;&lt; reader-&gt;GetHeight() &lt;&lt; endl;
    cout &lt;&lt; "The depth is" &lt;&lt; reader-&gt;GetPixelSpacing() &lt;&lt; endl;
    cout &lt;&lt; "The Output port is" &lt;&lt; reader-&gt;GetOutputPort() &lt;&lt; endl;
 
    
    vtkSmartPointer&lt;vtkMarchingCubes&gt; marchingcube = vtkSmartPointer&lt;vtkMarchingCubes&gt;::New();
    marchingcube-&gt;SetInputConnection(reader-&gt;GetOutputPort());//获得读取的数据的点集；
    marchingcube-&gt;SetValue(0, 200);//Setting the threshold;
    marchingcube-&gt;ComputeNormalsOn();//计算表面法向量;
 
    vtkSmartPointer&lt;vtkStripper&gt; Stripper = vtkSmartPointer&lt;vtkStripper&gt;::New();
    Stripper-&gt;SetInputConnection(marchingcube-&gt;GetOutputPort());//获取三角片
 
    vtkSmartPointer&lt;vtkPolyDataMapper&gt; Mapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();//将三角片映射为几何数据；
    Mapper-&gt;SetInputConnection(Stripper-&gt;GetOutputPort());
    Mapper-&gt;ScalarVisibilityOff();//
 
 
    vtkSmartPointer&lt;vtkActor&gt; actor = vtkSmartPointer&lt;vtkActor&gt;::New();//Created a actor;
    actor-&gt;SetMapper(Mapper);//获得皮肤几何数据
    actor-&gt;GetProperty()-&gt;SetDiffuseColor(1, .49, .25);//设置皮肤颜色；
    actor-&gt;GetProperty()-&gt;SetSpecular(0.3);//反射率；
    actor-&gt;GetProperty()-&gt;SetOpacity(1.0);//透明度；
    actor-&gt;GetProperty()-&gt;SetSpecularPower(20);//反射光强度；
    actor-&gt;GetProperty()-&gt;SetColor(1, 0, 0);//设置角的颜色；
    actor-&gt;GetProperty()-&gt;SetRepresentationToWireframe();//线框；
 
    //vtkSmartPointer&lt;vtkCamera&gt; camera = vtkSmartPointer&lt;vtkCamera&gt;::New();//Setting the Camera;
    //camera-&gt;SetViewUp(0, 0, -1);//设置相机向上方向；
    //camera-&gt;SetPosition(0, 1, 0);//位置：世界坐标系，相机位置；
    //camera-&gt;SetFocalPoint(0, 0, 0);//焦点，世界坐标系，控制相机方向；
    //camera-&gt;ComputeViewPlaneNormal();//重置视平面方向，基于当前的位置和焦点；
 
    vtkSmartPointer&lt;vtkOutlineFilter&gt; outfilterline = vtkSmartPointer&lt;vtkOutlineFilter&gt;::New();
    outfilterline-&gt;SetInputConnection(reader-&gt;GetOutputPort());
    vtkSmartPointer&lt;vtkPolyDataMapper&gt; outmapper = vtkSmartPointer&lt;vtkPolyDataMapper&gt;::New();
    outmapper-&gt;SetInputConnection(outfilterline-&gt;GetOutputPort());
    vtkSmartPointer&lt;vtkActor&gt; OutlineActor = vtkSmartPointer&lt;vtkActor&gt;::New();
    OutlineActor-&gt;SetMapper(outmapper);
    OutlineActor-&gt;GetProperty()-&gt;SetColor(0, 0, 0);//线框颜色
 
    ren-&gt;AddActor(actor);
    ren-&gt;AddActor(OutlineActor);
    //ren-&gt;SetActiveCamera(camera);//设置渲染器的相机；
    ren-&gt;ResetCamera();
    ren-&gt;ResetCameraClippingRange();
 
    //camera-&gt;Dolly(1.5);//使用Dolly()方法延伸着视平面法向移动相机；
    ren-&gt;SetBackground(1, 1, 1);//设置背景颜色；
    renWin-&gt;SetSize(1000, 600);
 
 
    vtkInteractorStyleTrackballCamera *style = vtkInteractorStyleTrackballCamera::New();
    iren-&gt;SetInteractorStyle(style);
 
    renWin-&gt;Render();
    iren-&gt;Initialize();
    iren-&gt;Start();
 
    vtkSmartPointer&lt;vtkOBJExporter&gt; porter = vtkSmartPointer&lt;vtkOBJExporter&gt;::New();
    porter-&gt;SetFilePrefix("E:/ceshi/aaa/regist_after/polywrite.obj");//重建图像输出
    porter-&gt;SetInput(renWin);
    porter-&gt;Write();
 
 
    return EXIT_SUCCESS;
}</code></pre> 
<p></p> 
<p class="img-center"><img alt="" height="32" src="https://images2.imgbox.com/a5/bd/kU3sbpzk_o.png" width="44"></p> 
<p></p> 
<p><img alt="33a9534cf4e61f81f4d5a1ff644aa7f5.png" src="https://images2.imgbox.com/2f/16/t9Y0iuR7_o.png"></p> 
<p>上面就是 VTK 基于 <code>Marching Cube算法</code>实现的重建效果：</p> 
<h5><a name="t6"></a><strong>体绘制重建</strong></h5> 
<p>体绘制时分为两部分：</p> 
<h5><a name="t7"></a><strong>1，定义 vtkVoluemRayCastMapper 对象</strong></h5> 
<p>体绘制中最常用的方法 ；<code>vtkVolumeRayCastMapper()</code> 光线投影，体绘制时，首先定义一个<code>Mapper</code> 然后接受两个输入：</p> 
<ul><li><code>SetInput(vtkImageDate *)</code> 用于设置输入图像数据；</li><li><code>SetVolumeRayCastFunction(vtkVolumeRayCastFunction *)</code> 用于设置光线投影函数类型；</li></ul> 
<h5><a name="t8"></a><strong>2，利用 vtkVolumeProperty 定义体绘制属性；</strong></h5> 
<ul><li><code>SetScalarOpacity()</code> 设置灰度不透明函数；</li><li><code>SetColor()</code> 颜色传输函数；</li></ul> 
<h5><a name="t9"></a><strong>3， 定义 vtkVolume 对象接收 Mapper对象和 Property 对象</strong></h5> 
<ul><li><code>SetMapper()</code>接受 Mapper 对象；</li><li><code>SetProperty()</code> 接受 Property 对象；</li></ul> 
<p>vtk 中体绘制 核心就是改变 <code>Mapper</code> 和 <code>vtkVolumeRayCastFunction()</code> ，上面中<code>vtkColumeRayCastMapper</code> 只是 <code>VolumeMapper</code> 其中的一种，且投影函数类 <code>vtkVolumeRayCastFunction</code> 一共有三个子类：</p> 
<ul><li><code>vtkVolumeRayCastCompositeFunction</code></li><li><code>vtkVolumeRayCasMIPFunction、</code></li><li><code>vtkVolumeRayCastIsosurfaceFunction</code>，</li><li>因此，其细分的话vtk中的体绘制也不止一种</li></ul> 
<p>而下面这个是最常用到的（<code>`vtkVolumeRayCastMapper</code> + <code>vtkVolumeRayCastCompositeFunction</code>）</p> 
<pre><code>//体绘制
 
#include&lt;vtkRenderWindowInteractor.h&gt;
#include&lt;vtkDICOMImageReader.h&gt;
#include&lt;vtkCamera.h&gt;
#include&lt;vtkActor.h&gt;
#include&lt;vtkRenderer.h&gt;
#include&lt;vtkVolumeProperty.h&gt;
#include&lt;vtkProperty.h&gt;
#include&lt;vtkPolyDataNormals.h&gt;
#include&lt;vtkImageShiftScale.h&gt;
#include "vtkVolumeRayCastMapper.h"
#include&lt;vtkPiecewiseFunction.h&gt;
#include&lt;vtkColorTransferFunction.h&gt;
#include&lt;vtkVolumeRayCastCompositeFunction.h&gt;
#include&lt;vtkRenderWindow.h&gt;
#include&lt;vtkImageCast.h&gt;
#include&lt;vtkVolumeRayCastCompositeFunction.h&gt;
#include&lt;vtkOBJExporter.h&gt;
#include&lt;vtkOutlineFilter.h&gt;
#include&lt;vtkPolyDataMapper.h&gt;
 
 
 
#include&lt;vtkInteractorStyleTrackballCamera.h&gt;
#include&lt;vtkRenderingVolumeOpenGL2ObjectFactory.h&gt;
#include&lt;vtkRenderingOpenGL2ObjectFactory.h&gt;
#include&lt;vtkMetaImageReader.h&gt;
 
#include&lt;vtkLODProp3D.h&gt;
 
 
//体绘制加速
 
//Gpu光照映射
#include&lt;vtkGPUVolumeRayCastMapper.h&gt;
 
#include&lt;iostream&gt;
 
int main()
{
 
    vtkObjectFactory::RegisterFactory(vtkRenderingOpenGL2ObjectFactory::New());
    vtkObjectFactory::RegisterFactory(vtkRenderingVolumeOpenGL2ObjectFactory::New());
 
 
    //定义绘制器；
    vtkRenderer *aRenderer = vtkRenderer::New();//指向指针；
    vtkSmartPointer&lt;vtkRenderWindow&gt; renWin = vtkSmartPointer&lt;vtkRenderWindow&gt;::New();
    renWin-&gt;AddRenderer(aRenderer);
 
    vtkRenderWindowInteractor *iren = vtkRenderWindowInteractor::New();
    iren-&gt;SetRenderWindow(renWin);
 
    //读取数据；
    /*vtkDICOMImageReader *reader = vtkDICOMImageReader::New();
    reader-&gt;SetDirectoryName("E:/Coding Pra/VTK/VTK_Examples_StandardFormats_Input_DicomTestImages/DICOM");
    reader-&gt;SetDataByteOrderToLittleEndian();*/
 
 
    vtkSmartPointer&lt;vtkDICOMImageReader&gt; reader = vtkSmartPointer&lt;vtkDICOMImageReader&gt;::New();
    reader-&gt;SetDirectoryName("E:/DIcom_Data/DICOM");
    reader-&gt;SetDataByteOrderToLittleEndian();
 
 
 
 
    //图像数据预处理，类型转换:通过 vtkimageCast 将不同类型数据集转化为 vtk 可以处理的数据集；
    vtkImageCast *cast_file = vtkImageCast::New();
    cast_file-&gt;SetInputConnection(reader-&gt;GetOutputPort());
    cast_file-&gt;SetOutputScalarTypeToUnsignedShort();
    cast_file-&gt;Update();
 
 
    //透明度映射函数定义；
    vtkPiecewiseFunction *opacityTransform = vtkPiecewiseFunction::New();
    opacityTransform-&gt;AddPoint(0, 0.0);
    opacityTransform-&gt;AddPoint(20, 0.0);
    opacityTransform-&gt;AddPoint(200, 1.0);
    opacityTransform-&gt;AddPoint(300, 1.0);
 
    //颜色映射函数定义,梯度上升的
    vtkColorTransferFunction *colorTransformFunction = vtkColorTransferFunction::New();
    colorTransformFunction-&gt;AddRGBPoint(0.0, 0.0, 0.0, 0.0);
    colorTransformFunction-&gt;AddRGBPoint(64.0, 0.0, 0.0, 0.0);
    colorTransformFunction-&gt;AddRGBPoint(128.0, 1.0, 0.0, 0.0);
    colorTransformFunction-&gt;AddRGBPoint(192.0, 1.0, 0.0, 0.0);
    colorTransformFunction-&gt;AddRGBPoint(255.0, 1.0, 0.0, 0.0);
 
    vtkPiecewiseFunction *gradientTransform = vtkPiecewiseFunction::New();
    gradientTransform-&gt;AddPoint(0, 0.0);
 
    gradientTransform-&gt;AddPoint(20, 2.0);
    gradientTransform-&gt;AddPoint(200, 0.1);
    gradientTransform-&gt;AddPoint(300, 0.1);
 
 
 
    //体数据属性；
    vtkVolumeProperty *volumeProperty = vtkVolumeProperty::New();
    volumeProperty-&gt;SetColor(colorTransformFunction);
    volumeProperty-&gt;SetScalarOpacity(opacityTransform);
    volumeProperty-&gt;SetGradientOpacity(gradientTransform);
    volumeProperty-&gt;ShadeOn();//应用
    volumeProperty-&gt;SetInterpolationTypeToLinear();//直线间样条插值；
    volumeProperty-&gt;SetAmbient(0.4);//环境光系数；
    volumeProperty-&gt;SetDiffuse(0.6);//漫反射；
    volumeProperty-&gt;SetSpecular(0.2);
    volumeProperty-&gt;SetSpecularPower(10);//高光强度；
 
 
    计算光照效应；利用 vtkBolumeRayCaseMapper进行计算；
    //vtkVolumeRayCastMapper *volunemapper = vtkVolumeRayCastMapper::New();
    //vtkVolumeRayCastCompositeFunction *compositeFunction = vtkVolumeRayCastCompositeFunction::New();
 
 
    //光纤映射类型定义：
    vtkSmartPointer&lt;vtkVolumeRayCastCompositeFunction&gt; compositecast =
        vtkSmartPointer&lt;vtkVolumeRayCastCompositeFunction&gt;::New();
 
    //Mapper定义,
    vtkSmartPointer&lt;vtkVolumeRayCastMapper&gt; hiresMapper = 
        vtkSmartPointer&lt;vtkVolumeRayCastMapper&gt;::New();
    hiresMapper-&gt;SetInputData(cast_file-&gt;GetOutput());
    hiresMapper-&gt;SetVolumeRayCastFunction(compositecast);
 
 
    vtkSmartPointer&lt;vtkLODProp3D&gt; prop = vtkSmartPointer&lt;vtkLODProp3D&gt;::New();
    prop-&gt;AddLOD(hiresMapper,volumeProperty,0.0);
 
    //
    //volunemapper-&gt;SetVolumeRayCastFunction(compositeFunction);//载入体绘制方法；
    //volunemapper-&gt;SetInputConnection(cast_file-&gt;GetOutputPort());
 
    //vtkFixedPointVolumeRayCastMapper *fixedPointVolumeMapper = vtkFixedPointVolumeRayCastMapper::New()
    //fixedPointVolumeMapper-&gt;SetInput()
 
 
 
    vtkVolume *volume = vtkVolume::New();
    volume-&gt;SetMapper(hiresMapper);
    volume-&gt;SetProperty(volumeProperty);//设置体属性；
 
    double volumeView[4] = { 0,0,0.5,1 };
 
    vtkOutlineFilter *outlineData = vtkOutlineFilter::New();//线框；
    outlineData-&gt;SetInputConnection(reader-&gt;GetOutputPort());
    vtkPolyDataMapper *mapOutline = vtkPolyDataMapper::New();
    mapOutline-&gt;SetInputConnection(outlineData-&gt;GetOutputPort());
    vtkActor *outline = vtkActor::New();
    outline-&gt;SetMapper(mapOutline);
    outline-&gt;GetProperty()-&gt;SetColor(0, 0, 0);//背景纯黑色；
 
    aRenderer-&gt;AddVolume(volume);
    aRenderer-&gt;AddActor(outline);
    aRenderer-&gt;SetBackground(1, 1, 1);
    aRenderer-&gt;ResetCamera();
 
 
    //重设相机的剪切范围；
    aRenderer-&gt;ResetCameraClippingRange();
    renWin-&gt;SetSize(800, 800);
    renWin-&gt;SetWindowName("测试");
 
    vtkRenderWindowInteractor *iren2 = vtkRenderWindowInteractor::New();
    iren2-&gt;SetRenderWindow(renWin);
 
    //设置相机跟踪模式
    vtkInteractorStyleTrackballCamera *style = vtkInteractorStyleTrackballCamera::New();
    iren2-&gt;SetInteractorStyle(style);
 
    renWin-&gt;Render();
    iren2-&gt;Initialize();
 
    iren2-&gt;Start();
 
    vtkOBJExporter *porter = vtkOBJExporter::New();
    porter-&gt;SetFilePrefix("E:/ceshi/aaa/regist_after/esho.obj");
    porter-&gt;SetInput(renWin);
    porter-&gt;Write();
    porter-&gt;Update();
 
 
    return EXIT_SUCCESS;
 
}</code></pre> 
<p></p> 
<p class="img-center"><img alt="" height="32" src="https://images2.imgbox.com/9f/4c/4M6HrPT5_o.png" width="44"></p> 
<p></p> 
<p><img alt="0c8404965dbab9c8abcab0cd04762657.png" src="https://images2.imgbox.com/18/5e/zghrjP4B_o.png"></p> 
<p>上面是体绘制的结果，相对来说体绘制需要计算资源更大些， vtk 在这方面有所考虑，提供了<code>vtKGPUVolumeRayCastMapper</code> GUP 加速的光线投射算法。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9bec7614598680d19484d38d8e49846e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">2023 年开始写 CSS 会与众不同（Part1）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d8f1b0286a721c1e2431a82ea9e7035d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">中国肺癌情形</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>