<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>ps 命令详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="ps 命令详解" />
<meta property="og:description" content="From：http://blog.chinaunix.net/uid-25681671-id-3201927.html
进程和作业管理命令：http://man.linuxde.net/sub/进程和作业管理
Linux 关于 进程/线程 的命令
kill 和 pgrep 和 pidof 和 awk 和 pkill 和 killall：https://blog.csdn.net/freeking101/article/details/53445749
简介 Linux 中的 ps 命令是 Process Status 的缩写。ps 命令用来列出系统中 当前正在运行 的那些进程，就是执行 ps 命令的那个时刻的那些进程的快照。使用该命令可以确定有哪些进程 正在运行 和 运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。
ps 查看的结果不是动态连续的，如果想要动态的显示进程信息，就可以使用 top、htop 命令。
kill 命令用于杀死进程。
ps 命令支持的 3 种语法格式 三种语法格式：
1. UNIX 风格。 选项可以组合在一起，并且选项前必须有 &#34;-&#34; 连字符2. BSD 风格。 选项可以组合在一起，但是选项前不能有 &#34;-&#34; 连字符3. GNU 风格的长选项。 选项前有 两个 &#34;-&#34; 连字符 可以混用这几种风格，但是可能会发生冲突。较多使用 UNIX 风格 的 ps 命令。
十二 个经典 Linux 进程管理命令介绍 ps、pstree、top、htop、nice、renice、kill、ulimit、w 和 who 和 whoami、pgrep、fg 和 bg、ipcs" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b4b4c30984e3d3d95aba907a6822f5b0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-11T07:38:00+08:00" />
<meta property="article:modified_time" content="2022-07-11T07:38:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">ps 命令详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html" style="font-size: 16px;"> 
 <p>From：<a href="http://blog.chinaunix.net/uid-25681671-id-3201927.html" rel="noopener">http://blog.chinaunix.net/uid-25681671-id-3201927.html</a></p> 
 <p>进程和作业管理命令：<a href="http://man.linuxde.net/sub/%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E7%AE%A1%E7%90%86" rel="noopener">http://man.linuxde.net/sub/进程和作业管理</a></p> 
 <p><a href="https://www.baidu.com/s?wd=Linux%20%E5%85%B3%E4%BA%8E%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%91%BD%E4%BB%A4" rel="noopener">Linux 关于 进程/线程 的命令</a></p> 
 <p>kill 和 pgrep 和 pidof 和 awk 和 pkill 和 killall：<a href="https://blog.csdn.net/freeking101/article/details/53445749" rel="noopener">https://blog.csdn.net/freeking101/article/details/53445749</a></p> 
 <h2>简介</h2> 
 <p>Linux 中的 <strong>ps </strong>命令是 <strong>Process Status</strong> 的缩写。ps 命令用来列出系统中 <strong>当前</strong><strong>正在</strong><strong>运行</strong> 的那些进程，<strong>就是执行 ps 命令的那个时刻的那些进程</strong><strong>的快照</strong><strong>。</strong>使用该命令可以确定有哪些进程 正在运行 和 运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p> 
 <p>ps 查看的结果不是动态连续的，如果想要动态的显示进程信息，就可以使用 top、htop 命令。</p> 
 <p>kill 命令用于杀死进程。</p> 
 <h2>ps 命令支持的 3 种语法格式</h2> 
 <p>三种语法格式：</p> 
 <ul><li>1. UNIX 风格。         选项可以组合在一起，并且选项前必须有 "-" 连字符</li><li>2. BSD  风格。         选项可以组合在一起，但是选项前不能有 "-" 连字符</li><li>3. GNU  风格的长选项。 选项前有 两个 "-" 连字符</li></ul> 
 <blockquote> 
  <p>可以混用这几种风格，但是可能会发生冲突。较多使用 <strong>UNIX</strong> <strong>风格 </strong>的 <strong>ps 命令</strong>。</p> 
 </blockquote> 
 <h2><strong>十二 个经典 Linux 进程管理命令介绍</strong></h2> 
 <p><strong>ps、pstree、top、htop、nice、renice、kill、ulimit、w 和 who 和 whoami、pgrep、fg 和 bg、ipcs</strong></p> 
 <ul><li><strong>ps</strong>：查看 Linux 中当前运行的进程的命令。能列出系统中运行的进程，包括进程号、命令、CPU使用量、内存使用量等<br>     示例：<br>         ps -a                - 列出所有运行中/激活进程<br>         ps -ef |grep      - 列出需要进程<br>         ps -aux            - 显示进程信息，包括无终端的(x)<br>                                   和针对用户(u)的进程：如USER, PID, %CPU, %MEM等</li><li><strong>pstree </strong>：linux中每一个进程都是由其父进程创建的。pstree以可视化方式显示进程，通过显示进程的树状图来展示进程间关系。如果指定了pid了，那么树的根是该pid，不然将会是init(pid： 1)。</li><li><strong>top</strong>：实时的监控系统状态信息和进程所使用的资源。显示进程的数据包括 PID、进程属主、优先级、%CPU、%memory等。可以使用这些显示指示出资源使用量。</li><li><strong>htop</strong>：htop 与 top 很类似，但是 htop 是交互式的文本模式的进程查看器。它通过文字图形化地显示每一个进程的CPU和内存使用量、swap使用量。使用上下光标键选择进程，F7和F8改变优先级，F9杀死进程。Htop不是系统默认安装的，所以需要额外安装。</li><li><strong>nice</strong>：通过 nice 命令的帮助，用户可以设置和改变进程的优先级。提高一个进程的优先级，内核会分配更多CPU时间片给这个进程。默认情况下，进程以 0 的优先级启动。进程优先级可以通过 top 命令显示的 NI(nice value)列查看。<br> 进程优先级值的范围从-20到19。值越低，优先级越高。nice &lt;优先值&gt; &lt;进程名&gt;  -  通过给定的优先值启动一个程序</li><li><strong>renice</strong>：renice 命令类似 nice 命令。使用这个命令可以改变正在运行的进程优先值。<br>         注意，用户只能改变属于他们自己的进程的优先值。<br>         renice -n -p - 改变指定进程的优先值<br>         renice -u -g - 通过指定用户和组来改变进程优先值</li><li><strong>kill</strong> ：用来发送信号给进程，并结束进程。如果一个进程没有响应杀死命令，这也许就需要强制杀死，使用 -9 参数来执行。<br>           注意：使用强制杀死的时候一定要小心，因为进程没有时机清理现场，也许写入文件没有完成。<br>           如果 不知道进程PID 或者 用名字杀死 进程时候，killall 就能派上用场。<br>                   kill &lt;pid&gt;                  --- 使用 kill 时候，需要知道进程ID号，可以通过 ps 命令得到 进程号<br>                   kill -9 &lt;pid&gt;              --- 杀死进程<br>                   killall -9 &lt;进程名&gt;    --- 杀死所有拥有同样名字的进程<br>                   pkill &lt;进程名&gt;          --- pkill 是类似的命令，但使用模式匹配，如进程名，进程拥有者等。</li><li><strong>ulimit </strong>：控制系统资源在shell和进程上的分配量。对于系统管理员是最有用的，可以管理重度使用和存在性能问题的系统。<br> 限制资源大小可以确保重要进程持续运行，其他进程不会占用过多资源。<br>         -f - 最大文件尺寸大小<br>         -v - 最大虚拟内存大小(KB)<br>         -n - 增加最大文件描述符数量<br>         -H : 改变和报告硬限制<br>         -S : 改变和报告软限制<br>     ulimit -a - 显示当前用户关联的资源限制</li><li><strong>w</strong> ：显示当前登录的用户及其正在执行的进程的信息。<br>         显示信息头包含信息，如当前时间、系统运行时长、登录用户总数、过去的1，5，15分钟内的负载均衡数。<br>         基于这些用户信息，用户在终止不属于他们的进程时要小心。</li><li><strong>who</strong>： 和 w 类似的命令，提供当前登录用户列表、系统启动时间、运行级别等。</li><li><strong>whoami </strong>： 输出当前用户ID。</li><li><strong>pgrep </strong>：pgrep 的意思是 " <strong>进程号全局正则匹配输出</strong> "。该命令扫描当前运行进程，然后按照命令匹配条件列出匹配结果到标准输出。对于通过名字检索进程号是很有用。<br>         示例：pgrep -u mint sh           // 显示用户为 "mint" 和进程名为 "sh" 的进程ID。</li><li><strong>fg 、bg</strong>：fg 即 frontgroud，表示 前台。 bg 即 background，表示 后台。<br>     有时命令需要很长时间才能执行完成。对于这种情况，<br>     使用 "bg" 命令可以将任务放在后台执行。使用 "fg" 命令可以将任务调到前台执行。<br>     可以通过 &amp; 在后台启动一个程序: find . -name *iso &gt; /tmp/res.txt &amp;<br>     一个正在运行的程序也可以通过 "CTRL+Z" 和 "bg" 命令组合放到后台运行。<br>         find . -name *iso &gt; /tmp/res.txt &amp;     // 启动一个程序<br>         ctrl+z                                 // 挂起当前执行程序<br>         bg                                     // 将程序放到后台运行<br>     可以使用 "jobs" 命令列出所有后台进程。<br>         jobs<br>     使用 "fg" 命令可以将后台程序调到前台执行。<br>         fg %进程id</li><li><strong>ipcs </strong>：ipcs 命令报告进程间通信设施状态。(共享内存，信号量和消息队列)<br>         用 -p 参数联合 -m、-s 或 -q 使用，可以获得相关的进程间通信的进程ID。<br>         示例：ipcs -p -m</li></ul> 
 <h2>linux上进程有5种状态</h2> 
 <p>5 种进程状态</p> 
 <pre class="has"><code class="language-plain">1.  运行        ( 正在运行或在运行队列中等待 ) 
2.  中断        ( 休眠中, 受阻, 在等待某个条件的形成或接受到信号 ) 
3.  不可中断    ( 收到信号不唤醒和不可运行, 进程必须等待直到有中断发生 ) 
4.  僵死        ( 进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放 ) 
5.  停止        ( 进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行 )</code></pre> 
 <p>ps 工具标识进程的 5 种状态码: </p> 
 <pre class="has"><code class="language-plain">D    不可中断    uninterruptible sleep (usually IO) 
R    运行        runnable (on run queue) 
S    中断        sleeping 
T    停止        traced or stopped 
Z    僵死        a defunct (”zombie”) process</code></pre> 
 <h2>一些参数和使用示例</h2> 
 <p>ps 命令帮助：</p> 
 <p><img alt="" src="https://images2.imgbox.com/6a/6e/cCM9Yhaa_o.png" style="outline: none;"></p> 
 <p>一些参数：</p> 
 <pre class="has"><code class="language-plain">############################################################

常用参数：
-A    显示所有进程(等价于-e)(utility)
-a    显示一个终端的所有进程，除了会话引线
-N    忽略选择。
-d    显示所有进程，但省略所有的会话引线(utility)
-x    显示没有控制终端的进程，同时显示各个命令的具体路径。dx不可合用。(utility)
-p    pid 进程使用cpu的时间
-u    uid or username 选择有效的用户id或者是用户名
-g    gid or groupname 显示组的所有进程。
U     username 显示该用户下的所有进程，且显示各个命令的详细路径。如:ps U zhang;(utility)
-f    全部列出，通常和其他选项联用。如：ps -fa or ps -fx and so on.
-l    长格式(有F,wchan,C 等字段)
-j    作业格式
-o    用户自定义格式。
v     以虚拟存储器格式显示
s     以信号格式显示
-m    显示所有的线程
-H    显示进程的层次(和其它的命令合用，如：ps -Ha)(utility)
e     命令之后显示环境(如：ps -d e; ps -a e)(utility)
h     不显示第一行

===================================ps 的参数说明=============================
l     长格式输出；
u     按用户名和启动时间的顺序来显示进程；
j     用任务格式来显示进程；
f     用树形格式来显示进程；
a     显示所有用户的所有进程(包括其它用户)。显示所有进程
-a    显示同一终端下的所有程序
x     显示无控制终端的进程；
r     显示运行中的进程；
ww    避免详细参数被截断；
-A    列出所有的进程
-w    显示加宽可以显示较多的资讯
-au   显示较详细的资讯
-aux  显示所有包含其他使用者的进程
-e    显示所有进程,环境变量
-f    全格式
-h    不显示标题
-l    长格式
-w    宽输出
a     显示终端上地所有进程,包括其他用户地进程
r     只显示正在运行地进程
x     显示没有控制终端地进程

常用的选项是组合是 aux 或 lax，还有参数 f 的应用。
pids 只列出进程标识符,之间运用逗号分隔，
该进程列表必须在命令行参数地最后一个选项后面紧接着给出,
中间不能插入空格。比如：ps -f1,4,5 显示的是进程ID为1,4,5的进程

下面介绍长命令行选项,这些选项都运用“--”开头：
--sort X[+|-] key [,[+|-] key [,…]] 从SORT KEYS段中选一个多字母键.“+”字符是可选地,
因为默认地方向就是按数字升序或者词典顺序，“-”字符是逆序排序(即降序).
比如： ps -jax -sort=uid,-ppid,+pid.
--help 显示帮助信息.
--version 显示该命令地版本信息.
在前面地选项说明中提到了排序键,接下来对排序键作进一步说明.
需要注意的是排序中运用的值是ps运用地内部值,并非仅用于某些输出格式地伪值.
排序键列表见下表.
============排序键列表==========================
c cmd   可执行地简单名称 
C cmdline   完整命令行 
f flags   长模式标志 
g pgrp   进程地组ID 
G tpgid   控制tty进程组ID 
j cutime   累计用户时间 
J cstime   累计系统时间 
k utime   用户时间 
K stime   系统时间 
m min_flt   次要页错误地数量 
M maj_flt   重点页错误地数量 
n cmin_flt 累计次要页错误 
N cmaj_flt 累计重点页错误 
o session   对话ID 
p pid   进程ID 
P ppid   父进程ID 
r rss   驻留大小 
R resident 驻留页 
s size   内存大小(千字节) 
S share   共享页地数量 
t tty   tty次要设备号 
T start_time 进程启动地时间 
U uid   UID
u user   用户名
v vsize   总地虚拟内存数量(字节) 
y priority 内核调度优先级</code></pre> 
 <p>日常生活中使用的 ps 命令的例子( UNIX 风格 )。</p> 
 <pre class="has"><code class="language-plain">1. ps    // 不加参数执行 ps 命令. 这是一个基本的 ps 使用    
        PID    TTY     TIME      COMMAND
        5800   ttyp0   00:00:00  bash
        5835   ttyp0   00:00:00  ps
        可以看到显示共分为四项：
            依次为PID(进程ID)、
            TTY(终端名称)、
            TIME(进程执行时 间)、
            COMMAND(该进程地命令行输入)。

2. ps -ax | less   // 显示所有当前进程。-a 代表 all。同时加上 x参数会显示没有控制终端的进程。
   ps -aux | less  // 默认的结果集是未排序的。    

3. ps -u pungki   // 根据用户过滤进程。查看特定用户的进程。示例是查看用户'pungki'的进程
   
4. ps -aux --sort -pcpu | less  // --sort命令来排序。 示例是根据 CPU 使用来升序排序。
   ps -aux --sort -pmem | less  // 根据 内存使用 来升序排序。    
   ps -aux --sort -pcpu,+pmem | head -n 10

5. $ ps -C getty  // 使用 -C 参数，后面跟你要找的进程的名字。示例名为getty的进程的信息。
   $ ps -f -C getty  // 使用-f参数来查看格式化的信息列表：
   
6. $ ps -L 1213  // 根据线程来过滤进程. 
                 // 如果我们想知道特定进程的线程，可以使用-L 参数，后面加上特定的PID。
7. $ps -axjf  // 树形显示进程， 有时候我们希望以树形结构显示进程，可以使用 -axjf 参数。
              // 或者 使用另一个命令:pstree
  
8. 显示安全信息. 
   如果想要查看现在有谁登入了你的服务器。可以使用ps命令加上相关参数:$ ps -eo pid,user,args
       参数 
          -e 显示所有进程信息
          -o 参数控制输出。
          Pid, User 和 Args 参数显示 PID，运行应用的用户 和 该应用。

9. 格式化输出root用户(真实的或有效的UID)创建的进程
   系统管理员想要查看由root用户运行的进程和这个进程的其他相关信息时，可以通过下面的命令:
   $ ps -U root -u root u
       -U 参数按真实用户ID(RUID)筛选进程，它会从用户列表中选择真实用户名或 ID。
           真实用户即实际创建该进程的用户。
       -u 参数用来筛选有效用户ID(EUID)。 最后的u参数用来决定以针对用户的格式输出，
          由User, PID, %CPU, %MEM, VSZ, RSS, TTY, STAT, START, TIME和COMMAND这几列组成。

    $ ps u     // 可以运用 u 选项来查看进程所有者及其他少许详细信息，如下所示：
    USER    PID    %CPU    %MEM    USZ    RSS    TTY    STAT    START    TIME    COMMAND
    test    5800   0.0     0.4     1892   1040   ttyp0  S       Nov27    0:00    -bash
    test    5836   0.0     0.3     2528   856    ttyp0  R       Nov27    0:00    ps u
    在 bash 进程前面有条横线，意味着该进程便是用户地登录shell，
    所以对于一个登录用户来说带短横线的进程只有一个。


10. 使用 PS 实时监控进程状态。
    ps 命令会显示你系统当前的进程状态，但是这个结果是静态的。当有一种情况，
    我们需要像上面第四点中提到的通过CPU和内存的使用率来筛选进程，
    并且我们希望结果能够每秒刷新一次。为此，我们可以将 ps命令 和 watch命令 结合起来。
    $ watch -n 1 ‘ps -aux --sort -pmem, -pcpu’
    如果输出太长，我们也可以限制它，比如前20条，我们可以使用head命令来做到。
    $ watch -n 1 ‘ps -aux --sort -pmem, -pcpu | head 20’
    这里的动态查看并不像top或者htop命令一样。但是使用ps的好处
    是你能够定义显示的字段，你能够选择你想查看的字段。
    举个例子，如果你只需要看名为'pungki'用户的信息，你可以使用下面的命令：
    $ watch -n 1 ‘ps -aux -U pungki u --sort -pmem, -pcpu | head 20’</code></pre> 
 <p>示例：</p> 
 <pre class="has"><code class="language-plain">############################################################

ps 命令常用用法(方便查看系统进程)
1)ps a   显示现行终端机下的所有程序，包括其他用户的程序。
2)ps -A  显示所有进程。
3)ps c   列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。
4)ps -e  此参数的效果和指定"A"参数相同。
5)ps e   列出程序时，显示每个程序所使用的环境变量。
6)ps f   用 ASCII 字符显示树状结构，表达程序间的相互关系。
7)ps -H  显示树状结构，表示程序间的相互关系。
8)ps -N  显示所有的程序，除了执行ps指令终端机下的程序之外。
9)ps s   采用程序信号的格式显示程序状况。
10)ps S  列出程序时，包括已中断的子程序资料。
11)ps -t&lt;终端机编号&gt; 　指定终端机编号，并列出属于该终端机的程序的状况。
12)ps -u root 　显示root用户信息
13)ps x 　      显示所有程序，不以终端机来区分。

ps -aux   最常用的方法，然后再利用一个管道符号导向到 grep 去查找特定的进程,
          然后再对特定的进程进行操作。
ps aux    列出目前所有的正在内存当中的程序    
	说明：
        USER：该 process 属于那个使用者账号的
        PID ：该 process 的号码
        %CPU：该 process 使用掉的 CPU 资源百分比
        %MEM：该 process 所占用的物理内存百分比
        VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)
        RSS ：该 process 占用的固定的内存量 (Kbytes)
        TTY ：该 process 是在那个终端机上面运作，若与终端机无关则显示 ?，另外，tty1-tty6 
              是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。
        STAT：该程序目前的状态，主要的状态有
        R ：该程序目前正在运作，或者是可被运作
        S ：该程序目前正在睡眠当中 (可说是 idle 状态)，但可被某些讯号 (signal) 唤醒。
        T ：该程序目前正在侦测或者是停止了
        Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态
        START：该 process 被触发启动的时间
        TIME ：该 process 实际使用 CPU 运作的时间
        COMMAND：该程序的实际指令

ps -ef               显示所有进程信息，连同命令行
ps -ef | grep ssh    ps 与grep 常用组合用法，查找特定进程

ps -l   将目前属于您自己这次登入的 PID 与相关信息列示出来
        说明：
           	各相关信息的意义：
           	F      代表这个程序的旗标 (flag)， 4 代表使用者为 super user
           	S      代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍
           	UID    程序被该 UID 所拥有
           	PID    就是这个程序的 ID ！
           	PPID   则是其上级父程序的ID
           	C CPU  使用的资源百分比
           	PRI    这个是 Priority (优先执行序) 的缩写，详细后面介绍
           	NI     这个是 Nice 值，在下一小节我们会持续介绍
           	ADDR    这个是 kernel function，指出该程序在内存的那个部分。
                                         如果是个 running的程序，一般就是 "-"
           	SZ      使用掉的内存大小
           	WCHAN   目前这个程序是否正在运作当中，若为 - 表示正在运作
           	TTY     登入者的终端机位置
           	TIME    使用掉的 CPU 时间。
           	CMD     所下达的指令为何
        在预设的情况下， ps 仅会列出与目前所在的 bash shell 有关的 PID 而已，
        所以， 当我使用 ps -l 的时候，只有三个 PID。

ps -axjf    列出类似程序树的程序显示
ps aux | egrep '(cron|syslog)'    找出与 cron 与 syslog 这两个服务有关的 PID 号码
ps -o pid,ppid,pgrp,session,tpgid,comm    输出指定的字段

############################################################
 
注意："ps aux" 和 "ps -aux" 不相同。
      例如："-u" 用来显示该用户的进程。但是 "u" 则是显示详细的信息。
      BSD风格: 在 BSD 风格的语法选项前不带连字符。例如: ps aux 
      UNIX/LINUX的风格：在 linux 风格的语法选项前面有一个 "-"。例如: ps -ef 
      混合使用两种 Linux 系统上的语法风格是好事儿。例如：ps ax -f

1、显示所有进程：
    $ ps ax 
    $ ps -ef
    "u"或者"-f"参数来显示所有进程的详细信息
    $ ps aux 
    $ ps -ef -f 
    注意:为什么用户列不显示我的用户名，但显示其他用户，如root、www等，对于所有的用户名(包括你)
         如果长度大于8个字符，然后ps将只显示UID，而不是用户名。

2、根据用户显示进程：
    由进程的所属用户使用“-u”选项后跟用户名来显示。多个用户名可以提供以逗号分隔。
    $ ps -f -u www-data 

3、通过名字和进程ID显示进程：
    通过名字或命令搜索进程，使用 “-C” 选项后面加搜索词。
    $ ps -C apache2 

4、根据CPU或者内存进行排序：
    “–sort” 选项由逗号分隔的多个字段可以用指定。此外，该字段可以带有前缀“-”或“”符号，
    表示降序或升序分别排序。通过进程列表进行排序有很多参数，你可以检查手册页的完整列表。
    $ ps aux --sort=-pcpu,+pmem 
    $ ps aux --sort=-pcpu | head -5

5、用树的风格显示进程的层次关系：
    许多进程实际上是一些父进程分的分支，知道这父子进程关系往往是有用的。
    在'–forest'选项将建立ASCII艺术风格层次的树视图。
    下面的命令将搜索进程名字为Apache2，形成一个树结构来显示详细的信息。
    $ ps -f --forest -C apache2 

6、显示一个父进程的子进程：
    这里有一个例子显示所有apache进程的分支
    $ ps -o pid,uname,comm -C apache2 

7、显示一个进程的线程：
    “-L”选项将显示进程的线程。它可以用来显示特定进程的所有线程或者所有进程。
    下面的命令将显示所有id为3150的进程所拥有的线程。
    $ ps -p 3150 -L 

8、改变要显示的列：
    ps命令可以配置为只显示选中的列表。为了显示完整列表可以查看手册。
    下面的命令只显示PID，用户名，CPU，内存和命令的列。
    $ ps -e -o pid,uname,pcpu,pmem,comm 
    可以重命名列标签，相当的灵活。
    $ ps -e -o pid,uname=USERNAME,pcpu=CPU_USAGE,pmem,comm 

9、显示进程运行的时间：
    表示进程的运行时间。对于运行的时间，列默认情况下是不显示的，可以使用“-O”选项查看。
    $ ps -e -o pid,comm,etime 

10、把ps命令变成一个实时查看器：
    像往常一样，watch命令可以用来实时捕捉ps显示进程。简单的例子如下:
    $ watch -n 1 'ps -e -o pid,uname,cmd,pmem,pcpu --sort=-pmem,-pcpu | head -15'</code></pre> 
 <h2><span style="font-weight: bold;"><strong>ps aux</strong></span> 或 <span style="font-weight: bold;">lax </span>输出的解释</h2> 
 <p>说明：</p> 
 <pre class="has"><code class="language-plain">==================ps aux 或 lax 输出的解释============

au(x) 输出格式 : 

USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND

USER:     进程所有者
PID:      进程ID
%CPU:     占用的 CPU 使用率
%MEM:     占用的内存使用率
VSZ:      占用的虚拟内存大小
RSS:      占用的内存大小
TTY:      终端的次要装置号码 (minor device number of tty)
STAT:     进程状态:
START:    启动进程的时间； 
TIME:     进程消耗CPU的时间；
COMMAND:  命令的名称和参数；</code></pre> 
 <h2>进程 stat 状态</h2> 
 <p>说明：</p> 
 <pre class="has"><code class="language-plain">=========================================进程STAT状态==================================
D     无法中断的休眠状态(通常 IO 的进程)； 
R     正在运行，在可中断队列中； 
S     处于休眠状态，静止状态； 
T     停止或被追踪，暂停执行； 
W     进入内存交换(从内核2.6开始无效)； 
X     死掉的进程； 
Z     僵尸进程不存在但暂时无法消除；
W:    没有足够的记忆体分页可分配
WCHAN 正在等待的进程资源；
&lt;:    高优先级进程
N:    低优先序进程
L:    有记忆体分页分配并锁在记忆体内 (即时系统或捱A I/O)，即,有些页被锁进内存

s     进程的领导者(在它之下有子进程)； 
l     多进程的(使用 CLONE_THREAD, 类似 NPTL pthreads)； 
+     位于后台的进程组；</code></pre> 
 <h2>kill 终止进程</h2> 
 <p>说明：</p> 
 <pre class="has"><code class="language-plain">有十几种控制进程的方法，下面是一些常用的方法:
kill -STOP [pid]
        发送 SIGSTOP (17,19,23)停止一个进程，而并不消灭这个进程。
kill -CONT [pid] 
        发送 SIGCONT (19,18,25)重新开始一个停止的进程。
kill -KILL [pid] 
        发送 SIGKILL (9)强迫进程立即停止，并且不实施清理操作。
kill -9 -1 
        终止你拥有的全部进程。

SIGKILL 和 SIGSTOP 信号不能被捕捉、封锁或者忽略，
但是，其它的信号可以。所以这是你的终极武器。</code></pre> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8b348040aad646ee5dab1f4c7ecc255d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">pyppeteer：比 selenium 更高效的爬虫利器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/676f586a2261c96ef059f27699bf4193/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu18.04&#43;ROS melodic &#43;RealSense D435i的使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>