<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker（六）--Docker网络--单机、跨主机容器通信 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker（六）--Docker网络--单机、跨主机容器通信" />
<meta property="og:description" content="文章目录 一、本地节点通信1.DNS2.joined容器3.端口映射4.不同网段的容器通信5.双冗余机制 二、跨主机容器通信1.相同网段进行通信2.补充 一、本地节点通信 1.DNS 容器之间除了使用ip通信外，还可以使用容器名称通信。docker 1.10开始，内嵌了一个DNS server。dns解析功能必须在自定义网络中使用。启动容器时使用 --name 参数指定容器名称。 2.joined容器 Joined容器一种较为特别的网络模式。在容器创建时使用- -network=container:vm1指定。（vm1指定的是运行的容器名）处于这个模式下的 Docker 容器会共享一个网络栈，这样两个容器之间可以使用localhost高效快速通信。 两个容器共享一个网络栈
[root@server7 ~]# docker run -d --name web1 --network my_net1 nginx
[root@server7 ~]# docker run -it --rm --network container:web1 --name web2 busybox
web1容器的ip为 172.17.0.2 ，我们使用joined网络模型再新建容器：
发现和web1容器一模一样，即指定的容器使用相同网络栈。需要注意的点是：这两个容器监听的端口不能是一样的。
3.端口映射 外部主机访问容器可以通过DNAT规则和docker-proxy，只要有一种正常就能通信
SNAT是源地址转换、DNAT是目标地址转换。
区分这两个功能可以简单的由服务的发起者是谁来区分，内部地址要访问公网上的服务时，内部地址会主动发起连接，将内部地址转换成公有ip。网关这个地址转换称为SNAT;当内部需要对外提供服务时，外部发起主动连接。路由器或着防火墙的网关接收到这个连接，然后把连接转换到内部，此过程是由带公有ip的网关代替内部服务来接收外部的连接，然后在内部做地址转换，此转换称为DNAT主要用于内部服务对外发布。
我们可以看到一条DNAT中重定向的策略：即外部访问本机的80端口时，会重定向到172.17.0.2 的80端口。这就是端口重定向机制，而docker中使用的是一种双冗余机制；
重启容器后，DNAT规则和docker-proxy策略会自动恢复
4.不同网段的容器通信 见上一篇总结！
5.双冗余机制 容器访问外网是通过iptables的SNAT(源地址转换)实现的
docker proxy:
外网访问容器用到了docker-proxy和iptables的DNAT（目标地址转换）
宿主机访问本机容器使用的是iptables DNAT
外部主机访问容器或容器之间的访问是docker-proxy实现
我们来进行双冗余测试：
我们先将iptables中的端口映射删掉：
但是此时外部仍然是可以访问的：
我们再把进程中的docker-proxy删掉：
在外部继续访问：已不能访问
这就是双冗余机制，只要有一种机制存在，就能运行。
本地容器之间的通信是通过网桥转发的，容器都连接的是docker0网桥：
重启后均会恢复
二、跨主机容器通信 跨主机网络解决方案
docker原生的overlay和macvlan" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ef9064520efbdfaf91a3f835dc8aed7c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-12T12:37:50+08:00" />
<meta property="article:modified_time" content="2023-08-12T12:37:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker（六）--Docker网络--单机、跨主机容器通信</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_13" rel="nofollow">一、本地节点通信</a></li><li><ul><li><a href="#1DNS_15" rel="nofollow">1.DNS</a></li><li><a href="#2joined_22" rel="nofollow">2.joined容器</a></li><li><a href="#3_36" rel="nofollow">3.端口映射</a></li><li><a href="#4_44" rel="nofollow">4.不同网段的容器通信</a></li><li><a href="#5_47" rel="nofollow">5.双冗余机制</a></li></ul> 
  </li><li><a href="#_68" rel="nofollow">二、跨主机容器通信</a></li><li><ul><li><a href="#1_98" rel="nofollow">1.相同网段进行通信</a></li><li><a href="#2_115" rel="nofollow">2.补充</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<h2><a id="_13"></a>一、本地节点通信</h2> 
<h3><a id="1DNS_15"></a>1.DNS</h3> 
<blockquote> 
 <ul><li>容器之间除了使用ip通信外，还可以使用容器名称通信。</li><li>docker 1.10开始，内嵌了一个DNS server。</li><li><mark>dns解析功能必须在自定义网络中使用。</mark></li><li>启动容器时使用 --name 参数指定容器名称。</li></ul> 
</blockquote> 
<h3><a id="2joined_22"></a>2.joined容器</h3> 
<blockquote> 
 <ul><li>Joined容器一种较为特别的网络模式。</li><li>在容器创建时使用- -network=container:vm1指定。（vm1指定的是运行的容器名）</li><li>处于这个模式下的 Docker 容器会共享一个网络栈，这样两个容器之间可以使用localhost高效快速通信。</li></ul> 
</blockquote> 
<p>两个容器共享一个网络栈<br> [root@server7 ~]# docker run -d --name web1 --network my_net1 nginx<br> [root@server7 ~]# docker run -it --rm --network container:web1 --name web2 busybox<br> <img src="https://images2.imgbox.com/91/28/sUuWfXWd_o.png" alt="在这里插入图片描述"><br> web1容器的ip为 172.17.0.2 ，我们使用joined网络模型再新建容器：<br> 发现和web1容器一模一样，即指定的容器使用相同网络栈。需要注意的点是：这两个容器监听的端口不能是一样的。<br> <img src="https://images2.imgbox.com/b6/2f/K6xBdCjW_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="3_36"></a>3.端口映射</h3> 
<p>外部主机访问容器可以通过DNAT规则和docker-proxy，只要有一种正常就能通信</p> 
<blockquote> 
 <p><mark>SNAT是源地址转换、DNAT是目标地址转换</mark>。<br> 区分这两个功能可以简单的由服务的发起者是谁来区分，内部地址要访问公网上的服务时，内部地址会主动发起连接，将内部地址转换成公有ip。网关这个地址转换称为SNAT;当内部需要对外提供服务时，外部发起主动连接。路由器或着防火墙的网关接收到这个连接，然后把连接转换到内部，此过程是由带公有ip的网关代替内部服务来接收外部的连接，然后在内部做地址转换，此转换称为DNAT主要用于内部服务对外发布。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/9b/2d/oj6I7031_o.png" alt="在这里插入图片描述"><br> 我们可以看到一条DNAT中重定向的策略：即外部访问本机的80端口时，会重定向到172.17.0.2 的80端口。这就是端口重定向机制，而docker中使用的是一种双冗余机制；<br> 重启容器后，DNAT规则和docker-proxy策略会自动恢复</p> 
<h3><a id="4_44"></a>4.不同网段的容器通信</h3> 
<p>见上一篇总结！</p> 
<h3><a id="5_47"></a>5.双冗余机制</h3> 
<p>容器访问外网是通过iptables的SNAT(源地址转换)实现的<br> <img src="https://images2.imgbox.com/e1/62/YTohI2HU_o.png" alt="在这里插入图片描述"><br> docker proxy:<br> 外网访问容器用到了docker-proxy和iptables的DNAT（目标地址转换）<br> 宿主机访问本机容器使用的是iptables DNAT<br> 外部主机访问容器或容器之间的访问是docker-proxy实现<br> <img src="https://images2.imgbox.com/38/8e/nb7GpvaP_o.jpg" alt="在这里插入图片描述"><br> 我们来进行双冗余测试：<br> 我们先将iptables中的端口映射删掉：<br> <img src="https://images2.imgbox.com/af/bf/kDWHjdX4_o.png" alt="在这里插入图片描述"><br> 但是此时外部仍然是可以访问的：<br> <img src="https://images2.imgbox.com/9b/dd/aSn0xtQ1_o.png" alt="在这里插入图片描述"><br> 我们再把进程中的docker-proxy删掉：<br> <img src="https://images2.imgbox.com/7a/f0/z3bmB7N4_o.png" alt="在这里插入图片描述"><br> 在外部继续访问：已不能访问<br> <img src="https://images2.imgbox.com/85/20/aiZDw3PR_o.png" alt="在这里插入图片描述"><br> 这就是双冗余机制，只要有一种机制存在，就能运行。<br> 本地容器之间的通信是通过网桥转发的，容器都连接的是docker0网桥：<br> <strong>重启后均会恢复</strong><img src="https://images2.imgbox.com/3f/07/2ZbuO74g_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c5/83/TSJ8BCiv_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/d2/ec/jChHC1Up_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_68"></a>二、跨主机容器通信</h2> 
<blockquote> 
 <ul><li>跨主机网络解决方案<br> docker原生的overlay和macvlan<br> 第三方的flannel、weave、calico</li><li>众多网络方案是如何与docker集成在一起的<br> libnetwork docker容器网络库<br> CNM （Container Network Model）这个模型对容器网络进行了抽象</li></ul> 
</blockquote> 
<blockquote> 
 <p>CNM分三类组件<br> Sandbox：容器网络栈，包含容器接口、dns、路由表。（namespace）<br> Endpoint：作用是将sandbox接入network （veth pair）<br> Network：包含一组endpoint，同一network的endpoint可以通信。<br> <img src="https://images2.imgbox.com/a5/07/Mvz7ilRE_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p>macvlan网络方案实现</p> 
 <ul><li>Linux kernel提供的一种网卡虚拟化技术。</li><li>无需Linux bridge，直接使用物理接口，性能极好。</li></ul> 
</blockquote> 
<blockquote> 
 <p>macvlan网络结构分析</p> 
 <ul><li>没有新建linux bridge</li><li>容器的接口直接与主机网卡连接，无需NAT或端口映射。</li><li>macvlan会独占主机网卡，但可以使用vlan子接口实现多macvlan网络</li><li>vlan可以将物理二层网络划分为4094个逻辑网络，彼此隔离，vlan id取值为1~4094</li></ul> 
</blockquote> 
<p>macvlan网络间的隔离和连通<br> macvlan网络在二层上是隔离的，所以不同macvlan网络的容器是不能通信的。<br> 可以在三层上通过网关将macvlan网络连通起来。<br> docker本身不做任何限制，像传统vlan网络那样管理即可。</p> 
<h3><a id="1_98"></a>1.相同网段进行通信</h3> 
<p>清除不要的网络<br> <img src="https://images2.imgbox.com/d0/00/EPvSqPDY_o.png" alt="在这里插入图片描述">两台虚拟机各添加一块虚拟网卡<br> <img src="https://images2.imgbox.com/1c/a5/ANE3Meli_o.png" alt="在这里插入图片描述"></p> 
<p>开启混杂模式并激活:<mark>混杂模式就是接收所有经过网卡的数据包，包括不是发给本机的包</mark><br> server7：<br> <img src="https://images2.imgbox.com/4c/2f/39OQ98Xe_o.png" alt="在这里插入图片描述"><br> 创建私有网络，指定macvlan驱动，指定直接使用物理网卡通信：<br> 使用macvlan模式最好手动设置ip，因为此模式下自动设置的ip与本机没有关系：<br> <img src="https://images2.imgbox.com/26/08/g5pDfUq2_o.png" alt="在这里插入图片描述"><br> server8以上类推<br> <strong>注：网段必须和server7上的私有网络的网段相同才能通信。</strong><br> <img src="https://images2.imgbox.com/28/85/IxMTZ2d6_o.png" alt="在这里插入图片描述"><br> 测试已通</p> 
<h3><a id="2_115"></a>2.补充</h3> 
<p>在实际生产环境中，大量的用户需要私有网络，我们如果不断的增加网卡其实不太合理，因为硬件有限制，所以我们就可以使用----vlan可以将物理二层网络划分为4094个逻辑网络，彼此隔离，vlan id取值为1~4094，我们就可以通过这种方式来进行创建。</p> 
<p>我们在server1上进行操作：<br> <img src="https://images2.imgbox.com/d0/90/uD1q094X_o.png" alt="在这里插入图片描述"><br> 我们可以通过这种方式来增加子网的数量。我们现在用的就是通过物理网卡子接口的方式来创建不一样的虚拟网络：<br> <img src="https://images2.imgbox.com/58/96/VomEd88M_o.png" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>macvlan网络间的隔离和连通<br> macvlan网络在二层上是隔离的，所以不同macvlan网络的容器是不能通信的。<br> 可以在三层上通过网关将macvlan网络连通起来。<br> docker本身不做任何限制，像传统vlan网络那样管理即可。</p> 
</blockquote> 
<p><mark>建议在使用时指定ip地址，防止ip递增冲突。</mark></p> 
<hr>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e96922435a305ac4afa0dd2a0e6b5378/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">哥德巴赫猜想（C&#43;&#43;）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a98c9e5704838b91d33d01805134a993/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Uncaught ReferenceError: require is not defined</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>