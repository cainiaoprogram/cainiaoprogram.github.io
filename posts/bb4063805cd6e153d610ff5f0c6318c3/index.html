<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>sqlite3_bind - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="sqlite3_bind" />
<meta property="og:description" content="sqlite3_bind_text 中绑定的指针，在sqlite3_step 时必须存在，不能释放，否则会是乱码
sqlite3_bind_blob中绑定的指针，在sqlite3_step 时必须存在，不能释放，否则会是乱码
sqlite3_bind_int 、sqlite3_bind_double 绑定临时变量是可以的，因为传的是值
void test_parameter_binding() {
//1. 不带参数绑定的情况下插入多条数据。
char strSQL[128]; for (int i = 0; i &lt; MAX_ROWS; &#43;&#43;i) { sprintf(strSQL,”insert into testtable values(%d)”,i); sqlite3_prepare_v2(…, strSQL); sqlite3_step(prepared_stmt); sqlite3_finalize(prepared_stmt); } //2. 参数绑定的情况下插入多条数据。
string strSQLWithParameter = “insert into testtable values(?)”; sqlite3_prepare_v2(…, strSQL); for (int i = 0; i &lt; MAX_ROWS; &#43;&#43;i) { sqlite3_bind(…,i); sqlite3_step(prepared_stmt); sqlite3_reset(prepared_stmt); } sqlite3_finalize(prepared_stmt); } 这里首先需要说明的是，SQL语句”insert into testtable values(?)”中的问号(?)表示参数变量的
占位符，该规则在很多关系型数据库中都是一致的，因此这对于数据库移植操作还是比较方便
的。
通过上面的示例代码可以显而易见的看出，参数绑定写法的执行效率要高于每次生成不同的
SQL语句的写法，即2)在效率上要明显优于1)，下面是针对这两种写法的具体比较：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/bb4063805cd6e153d610ff5f0c6318c3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-21T14:29:55+08:00" />
<meta property="article:modified_time" content="2020-12-21T14:29:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">sqlite3_bind</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>sqlite3_bind_text 中绑定的指针，在sqlite3_step 时必须存在，不能释放，否则会是乱码</p> 
<p>sqlite3_bind_blob中绑定的指针，在sqlite3_step 时必须存在，不能释放，否则会是乱码</p> 
<p> </p> 
<p>sqlite3_bind_int 、sqlite3_bind_double 绑定临时变量是可以的，因为传的是值</p> 
<p> </p> 
<p><br> void test_parameter_binding() {<!-- --><br> //1. 不带参数绑定的情况下插入多条数据。</p> 
<pre><code>char strSQL[128];
for (int i = 0; i &lt; MAX_ROWS; ++i) {
    sprintf(strSQL,”insert into testtable values(%d)”,i);
    sqlite3_prepare_v2(…, strSQL);
    sqlite3_step(prepared_stmt);
    sqlite3_finalize(prepared_stmt);
}</code></pre> 
<p><br> //2. 参数绑定的情况下插入多条数据。</p> 
<pre><code class="language-cpp">string strSQLWithParameter = “insert into testtable values(?)”;
    sqlite3_prepare_v2(…, strSQL);
    for (int i = 0; i &lt; MAX_ROWS; ++i) {
        sqlite3_bind(…,i);
        sqlite3_step(prepared_stmt);
        sqlite3_reset(prepared_stmt);
    }
    sqlite3_finalize(prepared_stmt);
}</code></pre> 
<p><br> 这里首先需要说明的是，SQL语句”insert into testtable values(?)”中的问号(?)表示参数变量的<br> 占位符，该规则在很多关系型数据库中都是一致的，因此这对于数据库移植操作还是比较方便<br> 的。<br> 通过上面的示例代码可以显而易见的看出，参数绑定写法的执行效率要高于每次生成不同的<br> SQL语句的写法，即2)在效率上要明显优于1)，下面是针对这两种写法的具体比较：<br> 1. 单单从程序表面来看，前者在for循环中执行了更多的任务，比如字符串的填充、SQL语句<br> 的prepare，以及prepared_statement对象的释放。<br><span style="color:#f33b45;">2. 在SQLite的官方文档中明确的指出，sqlite3_prepare_v2的执行效率往往要低于<br> sqlite3_step的效率。</span><br> 3. 当插入的数据量较大时，后者带来的效率提升还是相当可观的。</p> 
<p> </p> 
<p> </p> 
<p>sqlite3_get_table,效率低下，而且官方推荐使用sqlite3_prepare_v2替代</p> 
<p> </p> 
<p>SQLite插入数据效率最快的方式就是：<strong>开启事务  +   insert语句  +  关闭事务(提交)</strong></p> 
<p><strong>利用事务的互斥性，如果在批量的插入操作前显式地开启一次事务，在插入操作结束后，提交事务，那么所有的操作将只执行一次事务，大大地提高IO效率</strong></p> 
<p>开启事务和提交事务时缺省的，如果不显式写出来，将在每次insert语句前开启事务，insert语句后提交，如果执行insert语句1000万次，那么将自动开启并提交1000万次！！</p> 
<h3>事务的属性</h3> 
<p>事务（Transaction）具有以下四个标准属性，通常根据首字母缩写为 ACID：</p> 
<ul><li> <p><strong>原子性（Atomicity）：</strong>确保工作单位内的所有操作都成功完成，否则，事务会在出现故障时终止，之前的操作也会回滚到以前的状态。</p> </li><li> <p><strong>一致性（Consistency)：</strong>确保数据库在成功提交的事务上正确地改变状态。</p> </li><li> <p><strong>隔离性（Isolation）：</strong>使事务操作相互独立和透明。</p> </li><li> <p><strong>持久性（Durability）：</strong>确保已提交事务的结果或效果在系统发生故障的情况下仍然存在。</p> </li></ul> 
<table border="1" cellpadding="0" cellspacing="0"><tbody><tr><td> <h3>事务控制</h3> <p>使用下面的命令来控制事务：</p> 
    <ul><li> <p><strong>BEGIN TRANSACTION</strong>：开始事务处理。</p> </li><li> <p><strong>COMMIT</strong>：保存更改，或者可以使用 <strong>END TRANSACTION</strong> 命令。</p> </li><li> <p><strong>ROLLBACK</strong>：回滚所做的更改。</p> </li></ul><p>事务控制命令只与 DML 命令 INSERT、UPDATE 和 DELETE 一起使用。他们不能在创建表或删除表时使用，因为这些操作在数据库中是自动提交的。</p> <p> </p> <p>sqlite3_exec可以执行任何sql语句，包括事务( "BEGIN TRANSACTION" )、回滚( "ROLLBACK")和提交("COMMIT")等等。 </p> </td></tr></tbody></table> 
<p> </p> 
<h2><a href="https://www.cnblogs.com/youjianjiangnan/p/9603673.html" rel="nofollow" id="cb_post_title_url">SQLite3命令操作大全</a></h2> 
<p><a href="https://www.cnblogs.com/youjianjiangnan/p/9603673.html" rel="nofollow">https://www.cnblogs.com/youjianjiangnan/p/9603673.html</a></p> 
<h2 id="articleContentId"> BLOB数据的插入与查询</h2> 
<p><a href="https://blog.csdn.net/u014337397/article/details/80603510">https://blog.csdn.net/u014337397/article/details/80603510</a></p> 
<h2>sqlite插入数据效率提升解决方案  对比</h2> 
<p><a href="https://blog.csdn.net/aflyeaglenku/article/details/50946641?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control">https://blog.csdn.net/aflyeaglenku/article/details/50946641?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.control</a></p> 
<p>菜鸟教程 sqlite</p> 
<p><a href="https://www.runoob.com/sqlite/sqlite-transaction.html" rel="nofollow">https://www.runoob.com/sqlite/sqlite-transaction.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c737bd43ef8e09c76778684f8cfef560/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">心电图心电轴怎么计算_心电轴度数计算表</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fe0dc2c545ec3ea75b516f609fecbada/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">LTE 测量过程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>