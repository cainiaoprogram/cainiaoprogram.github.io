<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>尚硅谷Docker笔记-基础篇 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="尚硅谷Docker笔记-基础篇" />
<meta property="og:description" content="B站视频：https://www.bilibili.com/video/BV1gr4y1U7CY
1.Docker简介 解决了运行环境和配置问题的软件容器
方便做持续集成并有助于整体发布的容器虚拟化技术
容器与虚拟机比较 Docker 容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统虚拟机则是在硬件层面实现虚拟化。与传统的虚拟机相比，Docker 优势体现为启动速度快、占用体积小。
比较 Docker 和传统虚拟化方式的不同之处:
传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程
容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便
每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。
比较类型Docker容器虚拟机（VM）操作系统与宿主机共享OS宿主机OS上运行虚拟机OS存储大小镜像小，便于存储与传输镜像庞大（vmdk、vdi等）运行性能几乎无额外性能损失操作系统额外的CPU、内存消耗移植性轻便、灵活，适应于Linux笨重，与虚拟化技术耦合度高硬件亲和性面向软件开发者面向硬件运维者部署速度快速，秒级较慢，10s以上 DevOps 开发/运维 【一次构建、随处运行】
更快速的应用交付和部署
更便捷的升级和扩缩容
更简单的系统运维
更高效的计算资源利用
官网和仓库 docker官网 http://www.docker.com
Docker Hub仓库官网 https://hub.docker.com
2.Docker安装 前提 Centos Docker 安装
Docker 并非是一个通用的容器工具，它依赖于已存在并运行的 Linux 内核环境。
Docker 实质上是在已经运行的 Linux 下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的 Linux 主机。
因此，Docker 必须部署在 Linux 内核的系统上。如果其他系统想部署 Docker 就必须安装一个虚拟 Linux 环境。
（Docker也可以在windows平台上部署，这个原理是利用 win10 自带的虚拟化技术Hyper-V，在虚拟机中安装 Linux内核 ，并在安装 Linux 系统中运行 Docker）
基本组成 镜像 容器 仓库
需要正确的理解仓库/镜像/容器这几个概念：
Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器实例（类似Java中new出来一个对象）。
image文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a7461664bd6a8162df2aa407b29bfc8c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-18T18:02:39+08:00" />
<meta property="article:modified_time" content="2023-12-18T18:02:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">尚硅谷Docker笔记-基础篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>B站视频：<a href="https://www.bilibili.com/video/BV1gr4y1U7CY" rel="nofollow">https://www.bilibili.com/video/BV1gr4y1U7CY</a></p> 
<h2><a id="1Docker_2"></a>1.Docker简介</h2> 
<p>解决了运行环境和配置问题的软件容器<br> 方便做持续集成并有助于整体发布的容器虚拟化技术</p> 
<h3><a id="_9"></a>容器与虚拟机比较</h3> 
<p>Docker 容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统虚拟机则是在硬件层面实现虚拟化。与传统的虚拟机相比，Docker 优势体现为启动速度快、占用体积小。</p> 
<p>比较 Docker 和传统虚拟化方式的不同之处:<br> 传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程<br> 容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便<br> 每个容器之间互相隔离，每个容器有自己的文件系统，容器之间进程不会相互影响，能区分计算资源。</p> 
<table><thead><tr><th>比较类型</th><th>Docker容器</th><th>虚拟机（VM）</th></tr></thead><tbody><tr><td>操作系统</td><td>与宿主机共享OS</td><td>宿主机OS上运行虚拟机OS</td></tr><tr><td>存储大小</td><td>镜像小，便于存储与传输</td><td>镜像庞大（vmdk、vdi等）</td></tr><tr><td>运行性能</td><td>几乎无额外性能损失</td><td>操作系统额外的CPU、内存消耗</td></tr><tr><td>移植性</td><td>轻便、灵活，适应于Linux</td><td>笨重，与虚拟化技术耦合度高</td></tr><tr><td>硬件亲和性</td><td>面向软件开发者</td><td>面向硬件运维者</td></tr><tr><td>部署速度</td><td>快速，秒级</td><td>较慢，10s以上</td></tr></tbody></table> 
<h3><a id="DevOps__27"></a>DevOps 开发/运维</h3> 
<p>【一次构建、随处运行】</p> 
<p>更快速的应用交付和部署<br> 更便捷的升级和扩缩容<br> 更简单的系统运维<br> 更高效的计算资源利用</p> 
<h3><a id="_36"></a>官网和仓库</h3> 
<p><a href="http://www.docker.com" rel="nofollow">docker官网 http://www.docker.com</a><br> <a href="https://hub.docker.com" rel="nofollow">Docker Hub仓库官网 https://hub.docker.com</a></p> 
<h2><a id="2Docker_41"></a>2.Docker安装</h2> 
<h3><a id="_43"></a>前提</h3> 
<p>Centos Docker 安装<br> Docker 并非是一个通用的容器工具，它依赖于已存在并运行的 Linux 内核环境。<br> Docker 实质上是在已经运行的 Linux 下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的 Linux 主机。<br> 因此，Docker 必须部署在 Linux 内核的系统上。如果其他系统想部署 Docker 就必须安装一个虚拟 Linux 环境。</p> 
<p>（Docker也可以在windows平台上部署，这个原理是利用 win10 自带的虚拟化技术Hyper-V，在虚拟机中安装 Linux内核 ，并在安装 Linux 系统中运行 Docker）</p> 
<h3><a id="_52"></a>基本组成</h3> 
<p>镜像 容器 仓库</p> 
<p><strong>需要正确的理解仓库/镜像/容器这几个概念：</strong></p> 
<p>Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就是image镜像文件。只有通过这个镜像文件才能生成Docker容器实例（类似Java中new出来一个对象）。</p> 
<p>image文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p> 
<p><strong>镜像文件</strong></p> 
<p>image 文件生成的容器实例，本身也是一个文件，称为镜像文件。</p> 
<p><strong>容器实例</strong></p> 
<p>一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器</p> 
<p><strong>仓库</strong></p> 
<p>就是放一堆镜像的地方，我们可以把镜像发布到仓库中，需要的时候再从仓库中拉下来就可以了。</p> 
<p><strong>Docker平台架构图解（入门版）</strong><br> <img src="https://images2.imgbox.com/3a/bc/pxAofNK4_o.png" alt="请添加图片描述" width="500"><img src="https://images2.imgbox.com/f9/b0/fNYjlSbR_o.png" alt="请添加图片描述" width="800"></p> 
<p><strong>Docker工作原理</strong></p> 
<p>Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上，然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。容器，是一个运行时环境，就是我们前面说到的集装箱。<br> <img src="https://images2.imgbox.com/f2/0b/gUfcTCB8_o.png" alt="请添加图片描述" width="300"></p> 
<h3><a id="Docker_82"></a>Docker平台架构图解（架构版）</h3> 
<p>Docker是一个 C/S 模式的架构，后端是一个松耦合架构，众多模块各司其职。<br> Docker 运行的基本流程为:</p> 
<ol><li> <p>用户是使用 Docker Client与 Docker Daemon 建立通信，并发送请求给后者</p> </li><li> <p>Docker Daemon作为 Docker 架构中的主体部分，首先提供 Docker Sever 的功能使其可以接受 Docker Cient的请求。</p> </li><li> <p>Docker Engine 执行 Docker内部的一系列工作，每一项工作都是以一个 Job 的形式的存在。</p> </li><li> <p>Job 的运行过程中，当需要容器镜像时，则从 Docker Registy 中下载像，并通过镜像管理驱动 Graph diver将下载像以Graph的形式存储。</p> </li><li> <p>当需要为 Docker创建网络环境时，通过网络管理驱动 Network driver 创建并配置 Docker 容器网络环境。</p> </li><li> <p>当需要限制 Docker容器运行资源或执行用户指令等操作时，则通过 Exec driver 来完成。</p> </li><li> <p>Libcontainer是一项独立的容器管理包，Network driver以及Exec driver都是通过Libcontainer来实现具体对容器进行的操作</p> </li></ol> 
<p><img src="https://images2.imgbox.com/c2/ed/1SoNeFFQ_o.png" alt="请添加图片描述" width="500"></p> 
<h3><a id="CentOS7Docker_104"></a>CentOS7安装Docker步骤</h3> 
<p><a href="https://docs.docker.com/engine/install/centos/" rel="nofollow">官网安装文档 Install Docker Engine on CentOS | Docker Docs</a></p> 
<p>1.确定是centos7及以上版本<code>cat /etc/redhat-release</code></p> 
<p>2.<a href="https://docs.docker.com/engine/install/centos/#uninstall-old-versions" rel="nofollow">卸载旧版本</a></p> 
<p>3.yum安装gcc相关</p> 
<p>centOS7网络正常</p> 
<p><code>yum -y install gcc</code></p> 
<p><code>yum -y install gcc-c++</code></p> 
<p>4.安装需要的软件包</p> 
<p>官网介绍了三种方式</p> 
<p><a href="https://docs.docker.com/engine/install/centos/#installation-methods" rel="nofollow">Install Docker Engine on CentOS | Docker Docs</a></p> 
<p>使用第一种</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> yum <span class="token function">install</span> <span class="token parameter variable">-y</span> yum-utils
</code></pre> 
<p>5.设置stable镜像仓库</p> 
<pre><code class="prism language-shell"><span class="token comment"># 官网下面这句设置stable镜像库不是必须的，而且这个是国外的地址，设置了后经常容易遇到超时的问题</span>
<span class="token function">sudo</span> yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
<span class="token comment"># 可以将仓库设置为阿里云的</span>
<span class="token function">sudo</span> yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
</code></pre> 
<p><img src="https://images2.imgbox.com/0c/31/f3UtJdaU_o.png" alt="请添加图片描述" width="800"></p> 
<p>6.更新yum软件包索引</p> 
<pre><code class="prism language-shell">yum makecache fast
</code></pre> 
<p>这一步官网上没有，执行后是将软件包信息提前在本地索引缓存，用来提高搜索安装软件的速度，以后yum安装会稍快一些</p> 
<p>Metadata Cache Created 元数据缓存已建立<br> <img src="https://images2.imgbox.com/40/81/86jFr2G3_o.png" alt="请添加图片描述" width="800"></p> 
<p>7.安装DOCKER CE</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> yum <span class="token function">install</span> docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
</code></pre> 
<p>8.启动docker</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> systemctl start <span class="token function">docker</span>
</code></pre> 
<p>9.测试</p> 
<pre><code class="prism language-shell"><span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> <span class="token function">docker</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/02/c1/qXYdGAUp_o.png" alt="请添加图片描述" width="800"></p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> version
</code></pre> 
<p><img src="https://images2.imgbox.com/cd/f6/wRCiflrx_o.png" alt="请添加图片描述" width="350"></p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run hello-world
</code></pre> 
<p><img src="https://images2.imgbox.com/98/b0/sO7I80GR_o.png" alt="请添加图片描述" width="400"></p> 
<p>docker进程要执行一个镜像，</p> 
<p>如果本地有 则直接转化成容器实例运行；</p> 
<p>若本地没有 则从远程库拉到本地 再转化成容器实例运行。</p> 
<p>10.卸载</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> systemctl stop <span class="token function">docker</span>
<span class="token function">sudo</span> yum remove docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin docker-ce-rootless-extras
<span class="token function">sudo</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> /var/lib/docker
<span class="token function">sudo</span> <span class="token function">rm</span> <span class="token parameter variable">-rf</span> /var/lib/containerd
</code></pre> 
<h3><a id="_206"></a>阿里云镜像加速</h3> 
<p>https://promotion.aliyun.com/ntms/act/kubernetes.html<br> 1.注册一个属于自己的阿里云账户（可复用淘宝账号）<br> 2.获得加速器地址连接：【控制台/容器镜像服务/实例列表】创建个人版实例后，在【控制台/容器镜像服务/镜像工具/镜像加速器】查看自己的加速器地址<br> 3.粘贴脚本直接执行<br> 只配置<code>registry-mirrors</code>和<code>insecure-registries</code>就行，其他的是课程https://www.bilibili.com/video/BV13Q4y1C7hS?p=32配置的</p> 
<blockquote> 
 <p>“registry-mirrors”：用于配置镜像加速器，指定Docker拉取镜像时使用的镜像仓库地址。将"自己的地址.mirror.aliyuncs.com"替换为阿里云加速器提供的镜像仓库地址。</p> 
 <p>“exec-opts”：用于配置Docker中容器的执行选项，其中<code>native.cgroupdriver=systemd</code>表示使用systemd作为容器的cgroup驱动。</p> 
 <p>“log-driver”：用于指定Docker容器的日志驱动程序，"json-file"表示使用json文件作为驱动程序。</p> 
 <p>“log-opts”：用于设置日志驱动程序的选项，这里的<code>"max-size":"100m"</code>表示设置日志文件大小上限为100MB。</p> 
 <p>“storage-driver”：用于指定Docker容器的存储驱动程序，"overlay2"表示使用overlay2作为存储驱动程序。</p> 
 <p>“insecure-registries”：用于配置不安全的镜像仓库地址，可以指定允许不使用HTTPS协议访问的镜像仓库地址。将"ip:5000"替换为实际的仓库地址和端口。</p> 
</blockquote> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> <span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /etc/docker
<span class="token function">sudo</span> <span class="token function">tee</span> /etc/docker/daemon.json <span class="token operator">&lt;&lt;-</span><span class="token string">'EOF'
{
  "registry-mirrors": ["https://自己的地址.mirror.aliyuncs.com"],
  "exec-opts": ["native.cgroupdriver=systemd"],
  "log-driver": "json-file",
  "log-opts":{
    "max-size":"100m"
  },
  "storage-driver": "overlay2",
  "insecure-registries": ["ip:5000"]
}
EOF</span>
<span class="token function">sudo</span> systemctl daemon-reload
<span class="token function">sudo</span> systemctl restart <span class="token function">docker</span>
</code></pre> 
<p>4.重启服务器<br> <img src="https://images2.imgbox.com/4a/f0/4FQYBtWc_o.png" alt="请添加图片描述" width="400"></p> 
<h2><a id="3Docker_247"></a>3.Docker命令</h2> 
<h3><a id="_249"></a>帮助启动类命令</h3> 
<pre><code class="prism language-shell">systemctl start <span class="token function">docker</span>    <span class="token comment"># 启动docker</span>
systemctl stop <span class="token function">docker</span>    <span class="token comment"># 停止docker</span>
systemctl restart <span class="token function">docker</span>    <span class="token comment"># 重启docker</span>
systemctl status <span class="token function">docker</span>    <span class="token comment"># 查看docker状态</span>
systemctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span>    <span class="token comment"># 开机启动</span>
systemctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span> <span class="token parameter variable">--now</span>    <span class="token comment"># 现在启动，同时配置开机启动</span>
<span class="token function">docker</span> info    <span class="token comment"># 查看docker概要信息</span>
<span class="token function">docker</span> <span class="token parameter variable">--help</span>    <span class="token comment"># 查看docker总体帮助文档</span>
<span class="token function">docker</span> 具体命令 <span class="token parameter variable">--help</span>    <span class="token comment"># 查看docker命令帮助文档</span>
<span class="token function">man</span> docker-具体命令    <span class="token comment"># 帮助文档</span>
</code></pre> 
<h3><a id="_264"></a>镜像命令</h3> 
<pre><code class="prism language-shell"><span class="token function">docker</span> images    <span class="token comment"># 列出本地主机上的镜像。OPTIONS说明：-a 列出本地所有的镜像（含历史映像层) -q 只显示镜像ID。</span>
<span class="token function">docker</span> search <span class="token punctuation">[</span>OPTIONS<span class="token punctuation">]</span> 某个xxx镜像名字
<span class="token function">docker</span> pull 某个xxx镜像名字
<span class="token function">docker</span> system <span class="token function">df</span>    <span class="token comment"># 查看镜像/容器/数据卷所占的空间</span>
<span class="token function">docker</span> rmi 某个xxx镜像名字ID    <span class="token comment"># -f参数 是强制删除</span>
</code></pre> 
<h4><a id="docker_images_274"></a>docker images</h4> 
<p>显示的表头说明</p> 
<p>REPOSITORY：镜像的仓库源<br> TAG：镜像的标签版本号<br> IMAGE ID：镜像ID<br> CREATED：镜像创建时间<br> SIZE：镜像大小<br> 同一仓库源可以有多个TAG版本，代表这个仓库源的不同个版本，我们使用<code>REPOSITORY:TAG</code>来定义不同的镜像。<br> 若不指定一个镜像的版本标签，例如你只使用ubuntu，docker将默认使用ubuntu:latest 镜像</p> 
<h4><a id="docker_search_OPTIONS__286"></a>docker search [OPTIONS] 镜像名字</h4> 
<table><thead><tr><th>NAME</th><th>镜像名称</th></tr></thead><tbody><tr><td>DESCRIPTION</td><td>镜像说明</td></tr><tr><td>STARS</td><td>点赞数量</td></tr><tr><td>OFFICIAL</td><td>是否是官方的</td></tr><tr><td>AUTOMATED</td><td>是否是自动构建的</td></tr></tbody></table> 
<p>使用limit指定只列出N个镜像，默认是25个<code>docker search --limit 5 redis</code></p> 
<h4><a id="docker_pull_TAG_297"></a>docker pull 镜像名字[:TAG]</h4> 
<p>下载镜像。</p> 
<p><code>docker pull 镜像名字[:TAG]</code>是指定版本，若下载不到则报错。</p> 
<p><code>docker pull 镜像名字</code>等价于<code>docker pull 镜像名字:latest</code>，是下载最新版。</p> 
<h4><a id="docker_system_df_305"></a>docker system df</h4> 
<p>查看镜像/容器/数据卷所占的空间</p> 
<p>查看Linux硬盘空间<code>df -h</code></p> 
<h4><a id="docker_rmi_ID_311"></a>docker rmi 镜像名字ID</h4> 
<p>删除镜像。</p> 
<p>删除单个<code>docker rmi -f 镜像名字或ID</code></p> 
<p>删除多个<code>docker rmi -f 镜像名1:TAG 镜像名2:TAG</code></p> 
<p>删除全部<code>docker rmi -f $(docker images -qa)</code></p> 
<h4><a id="docker_savedocker_load_320"></a>docker save和docker load</h4> 
<pre><code class="prism language-shell"><span class="token comment"># 将镜像保存成压缩包</span>
<span class="token function">docker</span> save <span class="token parameter variable">-o</span> abc.tar guignginx:v1.8
<span class="token comment"># 别的机器加载这个镜像</span>
<span class="token function">docker</span> load <span class="token parameter variable">-i</span> abc.tar
</code></pre> 
<h4><a id="_329"></a>虚悬镜像</h4> 
<p>仓库名、标签都是<code>&lt;none&gt;</code>的镜像，俗称虚悬镜像dangling image</p> 
<p><img src="https://images2.imgbox.com/85/da/mzCTp8Dk_o.png" alt="在这里插入图片描述" width="500"></p> 
<h3><a id="_336"></a>容器命令</h3> 
<h4><a id="_338"></a>有镜像才能创建容器</h4> 
<p>有镜像才能创建容器，这是根本前提（下载一个centos或者ubuntu镜像演示）</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> pull ubuntu
<span class="token function">docker</span> images
</code></pre> 
<p><img src="https://images2.imgbox.com/bb/0c/cGNubut5_o.png" alt="请添加图片描述" width="500"></p> 
<h4><a id="docker_run_350"></a>docker run</h4> 
<p><code>docker run [OPTIONS] IMAGE [COMMAND] [ARG...]</code></p> 
<p>新建 + 启动容器</p> 
<p>OPTIONS说明（常用）：有些是一个减号，有些是两个减号</p> 
<blockquote> 
 <p>–name=“容器新名字” 为容器指定一个名称；<br> -d 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)；<br> -i 以交互模式运行容器，通常与-t同时使用；<br> -t 为容器重新分配一个伪输入终端，通常与-i同时使用；<br> 也即启动交互式容器(前台有伪终端，等待交互)；<br> -P 随机端口映射，大写P<br> -p 指定端口映射，小写p</p> 
</blockquote> 
<p>启动交互式容器（前台命令行）</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> ubuntu /bin/bash
<span class="token comment"># 可以写/bin/bash 也可以写bash</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span><span class="token operator">=</span>myubuntu01 ubuntu <span class="token function">bash</span>
</code></pre> 
<p>要退出终端，直接输入exit</p> 
<p><img src="https://images2.imgbox.com/82/98/hpJJ94et_o.png" alt="请添加图片描述" width="700"></p> 
<h4><a id="docker_ps_380"></a>docker ps</h4> 
<p><code>docker ps [OPTIONS]</code></p> 
<p>列出当前所有正在运行的容器</p> 
<p>[OPTIONS]说明（常用）</p> 
<blockquote> 
 <p>-a 列出当前所有正在运行的容器+历史上运行过的<br> -l 显示最近创建的容器。<br> -n 显示最近n个创建的容器。<code>docker ps -n 2</code><br> -q 静默模式，只显示容器编号。</p> 
</blockquote> 
<h4><a id="_393"></a>退出容器</h4> 
<p><code>exit</code> run进去容器，exit退出，容器停止<br> <code>ctrl+p+q</code> run进去容器，<code>ctrl+p+q</code>退出，容器不停止</p> 
<h4><a id="_398"></a>启动/重启/停止/强制停止容器</h4> 
<pre><code class="prism language-shell"><span class="token function">docker</span> start 容器ID或者容器名    <span class="token comment"># 启动已停止运行的容器</span>
<span class="token function">docker</span> restart 容器ID或者容器名    <span class="token comment"># 重启容器</span>
<span class="token function">docker</span> stop 容器ID或者容器名    <span class="token comment"># 停止容器</span>
<span class="token function">docker</span> <span class="token function">kill</span> 容器ID或者容器名    <span class="token comment"># 强制停止容器</span>
</code></pre> 
<h4><a id="_407"></a>删除已停止的容器</h4> 
<pre><code class="prism language-shell"><span class="token function">docker</span> <span class="token function">rm</span> 容器ID或者容器名
<span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> 容器ID或者容器名    <span class="token comment"># 强制删除，不管容器是否正在运行</span>
</code></pre> 
<p><code>docker rmi xxx</code>是删镜像，<code>docker rm xxx</code>是删容器。</p> 
<pre><code class="prism language-shell"><span class="token comment"># 一次性删除多个容器实例 两种写法</span>
<span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span> <span class="token parameter variable">-q</span><span class="token variable">)</span></span>
<span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span> <span class="token parameter variable">-q</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token function">docker</span> <span class="token function">rm</span>
</code></pre> 
<h4><a id="_422"></a>重要</h4> 
<p>下载一个Redis6.0.8镜像演示</p> 
<h5><a id="_426"></a>启动守护式容器（后台服务器）</h5> 
<p>在大部分的场景下，我们希望docker的服务是在后台运行的，可以用<code>-d</code>指定容器的后台运行模式。<br> <code>docker run -d 容器名</code></p> 
<blockquote> 
 <p>#使用镜像ubuntu:latest以后台模式启动一个容器<br> docker run -d ubuntu</p> 
 <p>【问题】<code>docker ps -a</code>进行查看时会发现容器已经退出<br> 【重要】Docker容器后台运行，就必须有一个前台进程。</p> 
 <pre><code>容器运行的命令，若不是那些一直挂起的命令（比如运行top，tail），就是会自动退出的。
这个是docker的机制问题，比如你的web容器，我们以nginx为例，正常情况下，配置启动服务只需启动响应的service即可。例如`service nginx start`。

但这样做，nginx为后台进程模式运行，就导致docker前台没有运行的应用，这样的容器后台启动后，会立即自杀因为它觉得它没事可做了。
所以，最佳的解决方案是，将要运行的程序以前台进程的形式运行，常见就是命令行模式，表示我还有交互操作，别中断。
</code></pre> 
</blockquote> 
<p><strong>redis前后台启动具体示例</strong></p> 
<p>前台交互式启动：<code>docker run -it redis:6.0.8</code>，但是对于Redis不要用这个前台交互式启动，关了终端（不是ctrl+p+q的方式退出的）后容器也不运行了。</p> 
<p>后台守护式启动：<code>docker run -d redis:6.0.8</code>，再执行<code>docker ps</code>能看到运行中的Redis容器实例。Redis容器启动后会在后台运行Redis服务器进程，该进程会持续监听网络请求并提供服务，是一个持久运行的服务进程，所以不会像Ubuntu那样退出，容器会一直运行。</p> 
<h5><a id="docker_logs_ID_449"></a>docker logs 容器ID</h5> 
<p>查看容器日志</p> 
<h5><a id="docker_top_ID_453"></a>docker top 容器ID</h5> 
<p>查看容器内运行的进程</p> 
<h5><a id="docker_inspect_ID_457"></a>docker inspect 容器ID</h5> 
<p>查看容器内部细节</p> 
<h5><a id="docker_exec_it_ID_bashShell_461"></a>docker exec -it 容器ID bashShell</h5> 
<p>进入正在运行的容器并以命令行交互</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> ubuntu /bin/bash
ctrl+p+q退出
<span class="token function">docker</span> <span class="token function">ps</span>    <span class="token comment"># 此时ubuntu容器仍在运行中</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> 容器ID /bin/bash    <span class="token comment"># 重新进入ubuntu容器的终端</span>

<span class="token function">docker</span> attach 容器ID    <span class="token comment"># 也可以用这种方式重新进入</span>

<span class="token comment"># 换成拿Redis试验</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> Redis容器ID /bin/bash
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> Redis容器ID redis-cli
</code></pre> 
<p>exec 和 attach 两种用法的区别</p> 
<blockquote> 
 <p>exec是在容器中打开新的终端，并且可以启动新的进程。用exit退出时，不会导致容器的停止。</p> 
 <p>attach直接进入容器启动命令的终端，不会启动新的进程。用exit退出时，会导致容器的停止。</p> 
</blockquote> 
<p>推荐使用<code>docker exec</code>命令，因为退出容器终端，不会导致容器的停止。</p> 
<p>一般用-d后台启动的程序，再用exec进入对应的容器实例</p> 
<h5><a id="docker_cp__489"></a>docker cp 拷贝文件</h5> 
<pre><code class="prism language-shell"><span class="token comment"># 从容器内拷贝文件到主机上</span>
<span class="token function">docker</span> <span class="token function">cp</span> 容器ID:容器内路径 主机路径
<span class="token comment"># 从主机拷贝文件到容器里</span>
<span class="token function">docker</span> <span class="token function">cp</span> 主机路径 容器ID:容器内路径
</code></pre> 
<h5><a id="_499"></a>导入和导出容器</h5> 
<p>export 导出容器的内容流作为一个tar归档文件[对应import命令]<br> import 从tar包中的内容创建一个新的文件系统再导入为镜像[对应export]</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> <span class="token builtin class-name">export</span> 容器ID <span class="token operator">&gt;</span> 文件名.tar
<span class="token function">cat</span> 文件名.tar <span class="token operator">|</span> <span class="token function">docker</span> <span class="token function">import</span> - 镜像用户/镜像名:镜像版本号
</code></pre> 
<h3><a id="_509"></a>总结</h3> 
<p><img src="https://images2.imgbox.com/f2/4e/x0myDjgV_o.png" alt="请添加图片描述" width="600"></p> 
<blockquote> 
 <p><code>attach</code> Attach to a running container #当前 shell 下attach连接指定运行镜像</p> 
 <p><code>build</code> Build an image from a Dockerfile #通过 Dockerfile 定制镜像</p> 
 <p><code>commit</code> Create a new image from a container changes #提交当前容器为新的镜像</p> 
 <p><code>cp</code> Copy files/folders from the containers filesystem to the host path #从容器中拷贝指定文件或者目录到宿主机中</p> 
 <p><code>create</code> Create a new container #创建一个新的容器，同run，但不启动容器</p> 
 <p><code>diff</code> Inspect changes on a container’s filesystem #查看docker容器变化</p> 
 <p><code>events</code> Get real time events from the server #从 docker服务获取容器实时事件</p> 
 <p><code>exec</code> Run a command in an existing container #在已存在的容器上运行命令</p> 
 <p><code>export</code> Stream the contents of a container as a tar archive #导出容器的内容流作为一个tar归档文件[对应 import]</p> 
 <p><code>history</code> Show the history of an image #展示一个镜像形成历史</p> 
 <p><code>images</code> List images #列出系统当前镜像</p> 
 <p><code>import</code> Create a new filesystem image from the contents of a tarball #从tar包中的内容创建一个新的文件系统映像[对应export]</p> 
 <p><code>info</code> Display system-wide information #显示系统相关信息</p> 
 <p><code>inspect</code> Return low-level information on a container #查看容器详细信息</p> 
 <p><code>kill</code> Kill a running container #kill 指定 docker 容器</p> 
 <p><code>load</code> Load an image from a tar archive #从一个tar包中加载一个镜像[对应save]</p> 
 <p><code>login</code> Register or Login to the docker registry server #注册或者登陆一个docker 源服务器</p> 
 <p><code>logout</code> Log out from a Docker registry server #从当前Docker registry 退出</p> 
 <p><code>logs</code> Fetch the logs of a container #输出当前容器日志信息</p> 
 <p><code>port</code> Lookup the public-facing port which is NAT-ed to PRIVATE_PORT #查看映射端口对应的容器内部源端口</p> 
 <p><code>pause</code> Pause all processes within a container ＃暂停容器</p> 
 <p><code>ps</code> List containers #列出容器列表</p> 
 <p><code>pull</code> Pull an image or a repository from the docker registry server #从docker镜像源服务器拉取指定镜像或者库镜像</p> 
 <p><code>push</code> Push an image or a repository to the docker registry server #推送指定镜像或者库镜像至docker源服务器</p> 
 <p><code>restart</code> Restart a running container #重启运行的容器</p> 
 <p><code>rm</code> Remove one or more containers #移除一个或者多个容器</p> 
 <p><code>rmi</code> Remove one or more images #移除一个或多个镜像[无容器使用该镜像才可删除，否则需删除相关容器才可继续或f强制删除]</p> 
 <p><code>run</code> Run a command in a new container #创建一个新的容器并运行一个命令</p> 
 <p><code>save</code> Save an image to a tar archive #保存一个镜像为一个tar包[对应load]</p> 
 <p><code>search</code> Search for an image on the Docker Hub #在docker hub中搜索镜像</p> 
 <p><code>start</code> Start a stopped containers #启动容器</p> 
 <p><code>stop</code> Stop a running containers ＃停止容器</p> 
 <p><code>tag</code> Tag an image into a repository #给源中镜像打标签</p> 
 <p><code>top</code> Lookup the running processes of a container #查看容器中运行的进程信息</p> 
 <p><code>unpause</code> Unpause a paused container #取消暂停容器</p> 
 <p><code>version</code> Show the docker version information #查看 docker版本号</p> 
 <p><code>wait</code> Block until a container stops,then print its exit code #截取容器停止时的退出状态值</p> 
</blockquote> 
<h2><a id="4Docker_589"></a>4.Docker镜像</h2> 
<p>镜像是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。<br> 只有通过这个镜像文件才能生成Docker容器实例（类似Java中new出来一个对象）。</p> 
<h3><a id="_595"></a>分层的镜像</h3> 
<p>像是一层一层地下载</p> 
<p><img src="https://images2.imgbox.com/4c/92/XGovPn1x_o.png" alt="在这里插入图片描述" width="500"></p> 
<p>Docker中的镜像分层，支持通过扩展现有镜像创建新的镜像。类似Java继承于一个Base基础类，自己再按需扩展。<br> 新镜像是从base镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层。</p> 
<p><img src="https://images2.imgbox.com/e5/98/Oia1Jg4r_o.png" alt="在这里插入图片描述" width="500"></p> 
<h4><a id="UnionFS_608"></a>UnionFS（联合文件系统）</h4> 
<p>UnionFS(联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持<u><strong>对文件系统的修改作为一次提交来一层层的叠加</strong></u>，同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual<br> filesystem)。Union文件系统是Docker镜像的基础。<strong>镜像可以通过分层来进行继承</strong>，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p> 
<p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</p> 
<h4><a id="Docker_615"></a>Docker镜像加载原理</h4> 
<p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p> 
<p>bootfs(boot file system)主要包含bootloader和kernel，bootloader主要是引导加载kernel,Linux刚启动时会加载bootfs文件系统，<strong>在Docker镜像的最底层是引导文件系统bootfs</strong>。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。</p> 
<p>rootfs(root file system)，在bootfs之上。包含的就是典型Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p> 
<p><img src="https://images2.imgbox.com/2b/a9/liyloDwc_o.png" alt="在这里插入图片描述" width="300"></p> 
<p>对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就行了。由此可见对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同的发行版可以公用<br> bootfs。</p> 
<h4><a id="Docker_629"></a>Docker镜像采用分层结构的原因</h4> 
<p>镜像分层最大的一个好处就是共享资源，方便复制迁移，就是为了复用。<br> 比如说有多个镜像都从相同的base镜像构建而来，那么Docker Host只需在磁盘上保存一份base镜像；<br> 同时内存中也只需加载一份base镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。</p> 
<h3><a id="_635"></a>重点理解</h3> 
<p>Docker镜像层都是只读的，容器层是可写的。</p> 
<p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p> 
<p>所有对容器的改动，无论添加、删除还是修改文件都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p> 
<p><img src="https://images2.imgbox.com/fd/d9/k19j8Bmx_o.png" alt="在这里插入图片描述" width="300"></p> 
<h3><a id="Dockercommit_646"></a>Docker镜像commit操作案例</h3> 
<p>docker commit 提交容器副本使之成为一个新的镜像</p> 
<pre><code class="prism language-shell"><span class="token comment"># 命令</span>
<span class="token function">docker</span> commit <span class="token parameter variable">-m</span><span class="token operator">=</span><span class="token string">"提交的描述信息"</span> <span class="token parameter variable">-a</span><span class="token operator">=</span><span class="token string">"作者"</span> 容器ID 要创建的目标镜像名:<span class="token punctuation">[</span>标签名<span class="token punctuation">]</span>
</code></pre> 
<p>案例演示ubuntu安装vim</p> 
<blockquote> 
 <p>1.从Hub上下载ubuntu镜像到本地并成功运行<br> 2.原始的默认Ubuntu镜像是不带着vim命令的<br> 3.外网连通的情况下，安装vim</p> 
 <pre><code class="prism language-shell"><span class="token comment"># 先更新包管理工具</span>
<span class="token function">apt-get</span> update
<span class="token comment"># 然后安装需要的vim</span>
<span class="token function">apt-get</span> <span class="token parameter variable">-y</span> <span class="token function">install</span> <span class="token function">vim</span>
</code></pre> 
 <p>4.安装完成后，commit我们自己的新镜像</p> 
 <pre><code class="prism language-shell"><span class="token function">docker</span> commit <span class="token parameter variable">-m</span><span class="token operator">=</span><span class="token string">"add vim cmd"</span> <span class="token parameter variable">-a</span><span class="token operator">=</span><span class="token string">"Shinka"</span> 5fa45c3687b7 test/myubuntu:1.1
</code></pre> 
 <p>5.启动我们的新镜像并和原来的对比</p> 
 <pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> 镜像ID /bin/bash
</code></pre> 
</blockquote> 
<h2><a id="5_680"></a>5.本地镜像发布到阿里云</h2> 
<h3><a id="_682"></a>本地镜像发布到阿里云流程</h3> 
<p><img src="https://images2.imgbox.com/6c/1b/PjzykOMD_o.png" alt="在这里插入图片描述" width="500"></p> 
<h3><a id="_687"></a>镜像的生成方法</h3> 
<p>有两种</p> 
<p>1.docker commit。基于当前容器创建一个新的镜像，新功能增强。<code>docker commit [OPTIONS]容器ID[REPOSITORY[:TAG]]</code></p> 
<p>2.Dockerfile手工编写。后面的DockerFile章节</p> 
<h3><a id="_695"></a>将本地镜像推送到阿里云</h3> 
<p>本地镜像素材原型</p> 
<p>阿里云开发者平台创建仓库镜像：控制台 - 容器镜像服务 - 个人实例 - 命名空间 - 镜像仓库名称 - 进入管理界面获得脚本</p> 
<p>将镜像推送到阿里云：个人实例 - 镜像仓库 - 管理，可看到具体的命令</p> 
<p><img src="https://images2.imgbox.com/f2/1c/BKR6u6qn_o.png" alt="请添加图片描述" width="800"></p> 
<h3><a id="_707"></a>将阿里云上的镜像下载到本地</h3> 
<p><img src="https://images2.imgbox.com/e7/fc/4ULTrQO1_o.png" alt="请添加图片描述" width="800"></p> 
<h2><a id="6_712"></a>6.本地镜像发布到私有库</h2> 
<p>Docker Registry</p> 
<p>官方Docker Hub地址：https://hub.docker.com/，中国大陆访问太慢了目准备被阿里云取代的趋势，不太主流。<br> Dockerhub、阿里云这样的公共镜像仓库可能不太方便，涉及机密的公司不可能提供镜像给公网，所以需要创建一个本地私人仓库供给团队使用，基于公司内部项目构建镜像。<br> Docker Registry是官方提供的工具，可以用于构建私有镜像仓库</p> 
<p>6.1 下载镜像Docker Registry</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> pull registry
</code></pre> 
<p>6.2 运行私有库Registry，相当于本地有个私有Docker hub</p> 
<p>默认情况，仓库被创建在容器的/var/lib/registry目录下，建议自行用容器卷映射，方便于宿主机联调</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">5000</span>:5000 <span class="token parameter variable">-v</span> /shinka/myregistry/:/tmp/registry <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true registry
</code></pre> 
<p><img src="https://images2.imgbox.com/c9/de/hLwvRJRN_o.png" alt="请添加图片描述" width="800"></p> 
<p>6.3 案例演示创建一个新镜像，ubuntu安装ifconfig命令</p> 
<p>从Hub上下载ubuntu镜像到本地并成功运行<code>docker run -it ubuntu /bin/bash</code><br> 原始的Ubuntu镜像是不带着ifconfig命令的<br> 外网连通的情况下，安装ifconfig命令并测试通过<code>apt-get install net-tools</code><br> 安装完成后，commit我们自己的新镜像<code>docker commit -m="add ifconfig cmd" -a="Shinka" 5fa45c3687b7 test/myubuntu:1.2</code><br> 启动我们的新镜像并和原来的对比</p> 
<p>6.4 curl验证私服库上有什么镜像</p> 
<pre><code class="prism language-shell"><span class="token function">curl</span> <span class="token parameter variable">-XGET</span> http://ip:5000/v2/_catalog
</code></pre> 
<p>可以看到，目前私服库没有任何镜像上传过</p> 
<p><img src="https://images2.imgbox.com/62/6d/qoznh5Du_o.png" alt="请添加图片描述" width="600"></p> 
<p>6.5 将新镜像zzyyubuntu:1.2修改符合私服规范的Tag</p> 
<p>按照公式<code>docker tag 镜像:Tag Host:Port/Repository:Tag</code><br> Host是自己host主机IP地址<br> 使用命令<code>docker tag</code>将zzyyubuntu:1.2这个镜像修改为ip:5000/zzyyubuntu:1.2</p> 
<p>docker tag zzyyubuntu:1.2 ip:5000/zzyyubuntu:1.2</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> tag hello-world:latest ip:5000/my-hello-world:1.2
</code></pre> 
<p>6.6 修改配置文件使之支持http</p> 
<p>Docker的私服库做了安全加固，默认不允许http方式推送镜像，可以修改配置项取消该限制<br> （在【2.Docker安装/阿里云镜像加速】中已添加该配置）</p> 
<pre><code class="prism language-shell"><span class="token function">vim</span> /etc/docker/daemon.json
</code></pre> 
<pre><code class="prism language-json"><span class="token punctuation">{<!-- --></span>
    <span class="token string-property property">"reqistry-mirrors"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"https://xxxxxxxx.mirror.aliyuncs.com"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token string-property property">"insecure-registries"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"ip:5000"</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>reqistry-mirrors是前面配置过的阿里云的加速器，</p> 
<p>insecure-registries是安全注册，表示所配置的ip:port是安全的。</p> 
<p>该配置是json格式的，逗号不要漏掉。</p> 
<p>若不生效，建议重启Docker，重启Docker后registry私库容器也要再启动一下</p> 
<pre><code class="prism language-shell">systemctl restart <span class="token function">docker</span>
systemctl status <span class="token function">docker</span>
<span class="token function">docker</span> start 私库容器ID <span class="token comment"># 使用6.2的命令重新启动一个私库容器也可以</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/d7/d5/gzaRDIdh_o.png" alt="请添加图片描述" width="600"></p> 
<p><img src="https://images2.imgbox.com/b2/21/ATO9MusA_o.png" alt="请添加图片描述" width="600"></p> 
<p>6.7 push推送到私服库</p> 
<p><img src="https://images2.imgbox.com/f2/58/2HAnLkGn_o.png" alt="请添加图片描述" width="500"></p> 
<p>6.8 curl验证私服库上有什么镜像2</p> 
<p>6.9 pull到本地并运行</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> pull ip:5000/my-hello-world:1.2
</code></pre> 
<h2><a id="7Docker_822"></a>7.Docker容器数据卷</h2> 
<h3><a id="privilegedtrue_824"></a>坑：容器卷记得加入<code>--privileged=true</code></h3> 
<blockquote> 
 <p>Docker挂载主机目录访问如果出现cannot open directory.:Permission denied<br> 解决办法：在挂载目录后多加一个<code>--privileged=true</code>参数即可。</p> 
 <p>如果是CentOS7安全模块会比之前系统版本加强，不安全的会先禁止，所以目录挂载的情况被默认为不安全的行为，<br> 在SELinux里面挂载目录被禁止了，如果要开启，一般使用<code>--privileged=true</code>命令，扩大容器的权限解决挂载目录没有权限的问题，也即：使用该参数，container内的root拥有真正的root权限，否则，container内的root只是外部的一个普通用户权限。</p> 
</blockquote> 
<p>前面【6.2 运行私有库Registry】的参数v</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">5000</span>:5000 <span class="token parameter variable">-v</span> /shinka/myregistry/:/tmp/registry <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true registry
</code></pre> 
<p>-d 后台运行该容器实例</p> 
<p>-p 端口映射 宿主机:容器内</p> 
<p>-v volumes添加自定义的容器卷 宿主机绝对路径:容器内路径</p> 
<p>默认情况，仓库被创建在容器的/var/lib/registry目录下，建议自行用容器卷映射，方便于宿主机联调（应该挂载容器的<code>/var/lib/registry</code>目录才能将私库映射到宿主机来）</p> 
<h3><a id="_846"></a>是什么</h3> 
<blockquote> 
 <p>卷就是目录或文件，存在于一个或多个容器中，由docker挂载到容器，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性：<br> 卷的设计目的就是<u><strong>数据的持久化</strong></u>，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷</p> 
</blockquote> 
<p>一句话：有点类似Redis里面的rdb和aof文件<br> 将docker容器内的数据保存进宿主机的磁盘中</p> 
<p>运行一个带有容器卷存储功能的容器实例：</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /宿主机绝对路径:/容器内路径 镜像名
</code></pre> 
<h3><a id="_860"></a>能干嘛</h3> 
<p>将运用与运行的环境打包镜像，run后形成容器实例运行，但是我们对数据的要求希望是持久化的。<br> Docker容器产生的数据，如果不备份，那么当容器实例删除后，容器内的数据自然也就没有了。<br> 为了能保存数据在docker中，我们使用卷。</p> 
<p>特点：</p> 
<ul><li> <p>数据卷可在容器之间共享或重用数据</p> </li><li> <p>卷中的更改可以直接实时生效</p> </li><li> <p>数据卷中的更改不会包含在镜像的更新中</p> </li><li> <p>数据卷的生命周期一直持续到没有容器使用它为止</p> </li></ul> 
<h3><a id="_876"></a>数据卷案例</h3> 
<h4><a id="vs_878"></a>宿主vs容器之间映射添加容器卷</h4> 
<p>【/宿主机绝对路径】若不存在，会自动创建。【-v】可以挂载多个路径</p> 
<pre><code class="prism language-shell"><span class="token comment"># 模板</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /宿主机绝对路径:/容器内路径 镜像名
<span class="token comment"># 示例</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--name</span> u1 <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /tmp/myHostData:/tmp/myDockerData ubuntu /bin/bash
</code></pre> 
<p><strong>查看数据卷是否挂载成功</strong></p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> inspect 容器ID    <span class="token comment"># 查看容器内部细节</span>
</code></pre> 
<p>Mounts里显示的就是挂载信息</p> 
<p><img src="https://images2.imgbox.com/e6/cb/UJwP8b9K_o.png" alt="在这里插入图片描述" width="500"></p> 
<p><strong>容器和宿主机之间数据共享</strong></p> 
<p>docker修改，主机同步获得：在容器内进入路径/tmp/myDockerData，并创建文件dockerin.txt，回到宿主机的/tmp/myHostData，发现也有dockerin.txt文件，修改文件同理。</p> 
<p><img src="https://images2.imgbox.com/c5/65/wKHDfo1y_o.png" alt="请添加图片描述" width="800"></p> 
<p>主机修改，docker同步获得：在宿主机的/tmp/myHostData路径下添加hostin.txt文件，容器内的路径/tmp/myDockerData也会有该文件的，修改文件同理。</p> 
<p><img src="https://images2.imgbox.com/fa/06/HKvdiSyP_o.png" alt="请添加图片描述" width="800"></p> 
<p>docker容器stop，主机修改，docker容器重启后，数据依然会是与宿主机一样的。</p> 
<h4><a id="_916"></a>读写规则映射添加说明</h4> 
<p>1.读写rw（默认）</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /宿主机绝对路径:/容器内路径:rw 镜像名
</code></pre> 
<p>默认就是rw，同前面的案例</p> 
<p>2.只读read only</p> 
<p>容器实例内部被限制，只能读取不能写</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /宿主机绝对路径:/容器内路径:ro 镜像名
</code></pre> 
<p>此时若在容器内的路径进行写操作，会报错【read-only file system】；</p> 
<p>若宿主机写入内容，容器中可以读取到。</p> 
<h4><a id="_938"></a>卷的继承和共享</h4> 
<p>容器1（前面的u1容器）完成和宿主机的映射</p> 
<p>容器2（创建容器u2）继承容器1的卷规则</p> 
<pre><code class="prism language-shell"><span class="token comment"># 模板</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true --volumes-from 父类 <span class="token parameter variable">--name</span> u2 ubuntu
<span class="token comment"># 示例</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true --volumes-from u1 <span class="token parameter variable">--name</span> u2 ubuntu
</code></pre> 
<p>此处u2继承u1的卷规则之后，与u1是否停止运行无关，宿主机、u1、u2都有路径下的数据。</p> 
<h2><a id="8Docker_953"></a>8.Docker常规安装简介</h2> 
<h3><a id="_955"></a>总体步骤</h3> 
<p>搜索镜像</p> 
<p>拉取镜像</p> 
<p>查看镜像</p> 
<p>启动镜像-服务端口映射</p> 
<p>停止容器</p> 
<p>移除容器</p> 
<h3><a id="tomcat_969"></a>安装tomcat</h3> 
<p>docker hub页面上查找tomcat镜像（或者使用命令<code>docker search tomcat</code>）</p> 
<p>从docker hub上拉取tomcat镜像到本地<code>docker pull tomcat</code></p> 
<p>docker images查看是否有拉取到的tomcat<code>docker images tomcat</code></p> 
<p>使用tomcat镜像创建容器实例(也叫运行镜像）</p> 
<pre><code class="prism language-shell"><span class="token comment"># tomcat有常驻进程，不需要写-it参数也能持久运行</span>
<span class="token function">docker</span> run <span class="token parameter variable">-it</span> <span class="token parameter variable">-p</span> <span class="token number">8080</span>:8080 tomcat
<span class="token comment"># -p 小写，主机端口:docker容器端口</span>
<span class="token comment"># -P 大写，随机分配端口</span>
<span class="token comment"># -i 交互</span>
<span class="token comment"># -t 终端</span>
<span class="token comment"># -d 后台</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8080</span>:8080 <span class="token parameter variable">--name</span> t1 tomcat
</code></pre> 
<p><strong>localhost:8080访问猫首页</strong></p> 
<p>如果访问首页遇到404错误，解决方案：</p> 
<p><strong>可能没有映射端口或者没有关闭防火墙</strong>。使用<code>docker ps</code>看到Tomcat的端口号，在浏览器访问时请求【ip:port】</p> 
<p><strong>把webapps.dist目录换成webapps</strong>。</p> 
<pre><code class="prism language-shell"><span class="token comment"># 先成功启动tomcat，再进入容器</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> 容器ID /bin/bash
<span class="token comment"># 在 usr/local/tomcat 路径下</span>
<span class="token function">ls</span> <span class="token parameter variable">-l</span>
<span class="token comment"># 发现有webapps和webapps.dist，删掉前者（因为是空），重命名后者</span>
<span class="token function">rm</span> <span class="token parameter variable">-r</span> webapps
<span class="token function">mv</span> webapps.dist webapps
<span class="token comment"># 此时再在浏览器中访问localhost:8080就可以看到Tomcat首页了</span>
</code></pre> 
<p><strong>免修改版说明</strong></p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> pull billygoo/tomcat8-jdk8
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">8080</span>:8080 <span class="token parameter variable">--name</span> mytomcat8 billygoo/tomcat8-jdk8
</code></pre> 
<h3><a id="mysql_1016"></a>安装mysql</h3> 
<p>1.docker hub页面上查找mysql镜像（或者使用命令<code>docker search mysql</code>）</p> 
<p>2.从docker hub上（阿里云加速器）拉取mysql镜像到本地标签为5.7<code>docker pull mysql:5.7</code></p> 
<p>3.<strong>使用mysql5.7镜像创建容器(也叫运行镜像）</strong></p> 
<p>① 简单版（不要这样操作）</p> 
<pre><code class="prism language-shell"><span class="token comment"># 最好看下宿主机是否有MySQL已经占用了3306端口</span>
<span class="token function">ps</span> <span class="token parameter variable">-ef</span> <span class="token operator">|</span> <span class="token function">grep</span> mysql
<span class="token comment"># 使用mysql镜像</span>
<span class="token function">docker</span> run <span class="token parameter variable">-p</span> <span class="token number">3306</span>:3306 <span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> <span class="token parameter variable">-d</span> mysql:5.7
<span class="token function">docker</span> <span class="token function">ps</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> 容器ID /bin/bash
mysql <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-p</span>
</code></pre> 
<pre><code class="prism language-sql"><span class="token comment"># 建库建表插入数据</span>
<span class="token keyword">show</span> <span class="token keyword">databases</span><span class="token punctuation">;</span>
creat <span class="token keyword">database</span> db01<span class="token punctuation">;</span>
<span class="token keyword">use</span> db01<span class="token punctuation">;</span>
<span class="token keyword">create</span> <span class="token keyword">table</span> t1<span class="token punctuation">(</span>id <span class="token keyword">int</span><span class="token punctuation">,</span> name <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> t1 <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'z3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t1<span class="token punctuation">;</span>
</code></pre> 
<p>外部Win10工具也可以连接运行在dokcer上的mysql容器实例服务</p> 
<p>问题：插入中文数据时会报错</p> 
<p>docker上默认字符集编码隐患</p> 
<pre><code class="prism language-sql"><span class="token comment"># 在docker的MySQL容器内部执行，而不是Win10的客户端工具（客户端工具有些编码默认是utf-8）</span>
<span class="token keyword">show</span> variables <span class="token operator">like</span> <span class="token string">'character%'</span>
<span class="token comment"># 显示结果中字符编码大部分都是latin1，而不是utf-8</span>
</code></pre> 
<p>重点：要做数据卷，否则删除容器后MySQL中的数据就不存在了。</p> 
<p>② 实战版</p> 
<pre><code class="prism language-shell"><span class="token comment"># 新建mysql容器实例</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">3306</span>:3306 <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /zzyyuse/mysql/log:/var/log/mysql <span class="token parameter variable">-v</span> zzyyuse/mysql/data:/var/lib/mysql <span class="token parameter variable">-v</span> /zzyyuse/mysql/conf:/etc/mysql/conf.d <span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_RO0T_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> <span class="token parameter variable">--name</span> mysql mylsql:5.7
<span class="token comment"># 上面的命令换行显示</span>
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">3306</span>:3306 <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true 
<span class="token parameter variable">-v</span> /zzyyuse/mysql/log:/var/log/mysql 
<span class="token parameter variable">-v</span> zzyyuse/mysql/data:/var/lib/mysql 
<span class="token parameter variable">-v</span> /zzyyuse/mysql/conf:/etc/mysql/conf.d 
<span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_RO0T_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> 
<span class="token parameter variable">--name</span> mysql 
mylsql:5.7

<span class="token comment"># 新建my.cnf，通过容器卷同步给mysql容器实例</span>
<span class="token builtin class-name">cd</span> /zzyyuse/mysql/conf
<span class="token function">ls</span> <span class="token parameter variable">-l</span>    <span class="token comment"># 目前是什么都没有</span>
<span class="token function">vim</span> my.cnf
<span class="token comment"># 粘贴配置</span>
<span class="token function">cat</span> my.cnf
<span class="token comment"># 重启mysql容器实例再重新进入并查看字符编码</span>
<span class="token function">docker</span> restart mysql
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mysql /bin/bash
mysql <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-p</span>
show variables like <span class="token string">'character%'</span>
<span class="token comment"># 再新建库新建表再插入中文测试</span>
</code></pre> 
<p><code>vim my.cnf</code>时要粘贴的配置文件</p> 
<pre><code class="prism language-properties">[client]
default_character_set=utf8
[mysqld]
collation_server = utf8_general_ci
character_set_server = utf8
</code></pre> 
<p>结论：docker安装完MySQL并run出容器后，建议先修改完字符集编码，再新建mysql库-表-插数据</p> 
<p>假如将当前容器实例删除，再重新来一次，之前建的db01实例还有。</p> 
<h3><a id="redis_1102"></a>安装redis</h3> 
<p>以下简单操作没有数据卷</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> images redis:6.0.8
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">6379</span>:6379 redis:6.0.8
<span class="token function">docker</span> <span class="token function">ps</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> 容器id /bin/bash
redis-cli
<span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> k1 v1
<span class="token operator">&gt;</span> get k1 v1
<span class="token function">docker</span> <span class="token function">rm</span> <span class="token parameter variable">-f</span> 容器id
</code></pre> 
<p>正确步骤：</p> 
<p>从docker hub上（阿里云加速器）拉取redis镜像到本地标签为6.0.8，run并进入</p> 
<pre><code class="prism language-shell"><span class="token function">docker</span> pull redis:6.0.8
<span class="token function">docker</span> run <span class="token parameter variable">-d</span> <span class="token parameter variable">-p</span> <span class="token number">6379</span>:6379 redis:6.0.8
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> 容器id /bin/bash
</code></pre> 
<p>在Centos宿主机下新建目录/app/redis，将一个redis.conf文件模板拷贝进该目录下</p> 
<pre><code class="prism language-shell"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /app/redis
<span class="token function">cp</span> /myredis/redis.conf /app/redis
</code></pre> 
<p>/app/redis目录下修改redis.conf文件（修改默认出厂的原始redis.conf的配置）</p> 
<pre><code class="prism language-shell"><span class="token comment"># 开启redis验证 可选</span>
requirepass <span class="token number">123</span>
<span class="token comment"># 允许redis外地连接 必须注释掉</span>
<span class="token comment"># bind 127.0.0.1</span>
<span class="token comment"># 将daemonize yes注释掉，或者设置为daemonize no，因为该配置和docker run中-d参数冲突，会导致容器一直启动失败</span>
daemonize no
<span class="token comment"># 开启redis数据持久化 可选</span>
appendonly <span class="token function">yes</span>
</code></pre> 
<p>使用redis6.0.8镜像创建容器（也叫运行镜像）</p> 
<pre><code class="prism language-shell"><span class="token comment"># 命令提醒：容器卷记得加入`--privileged=true`</span>
<span class="token function">docker</span> run <span class="token parameter variable">-p</span> <span class="token number">6379</span>:6379 <span class="token parameter variable">--name</span> myr3 <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token parameter variable">-v</span> /app/redis/redis.conf:/etc/redis/redis.conf <span class="token parameter variable">-v</span> /app/redis/data:/data <span class="token parameter variable">-d</span> redis:6.0.8 redis-server /etc/redis/redis.conf
<span class="token comment"># 换行显示后</span>
<span class="token function">docker</span> run <span class="token parameter variable">-p</span> <span class="token number">6379</span>:6379 <span class="token parameter variable">--name</span> myr3 <span class="token parameter variable">--privileged</span><span class="token operator">=</span>true <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> /app/redis/redis.conf:/etc/redis/redis.conf <span class="token punctuation">\</span>
<span class="token parameter variable">-v</span> /app/redis/data:/data <span class="token punctuation">\</span>
<span class="token parameter variable">-d</span> redis:6.0.8 redis-server /etc/redis/redis.conf
<span class="token comment"># 闪退解决方法：把启动redis命令中的redis-server替换成绝对路径即可</span>
</code></pre> 
<p>证明docker启动使用了我们自己指定的配置文件</p> 
<blockquote> 
 <p>修改前，配置文件数据库默认是16个，在redis-cli中执行<code>select 15</code>，能成功切换到15号库。</p> 
 <p>修改宿主机/app/redis路径下的配置文件（记得重启），将<code>databases 15</code>改为<code>databases 10</code>，宿主机的修改会同步给docker容器里的配置。</p> 
 <p>docker restart myr3</p> 
 <p>docker exec -it myr3 /bin/bash</p> 
 <p>docker ps</p> 
 <p>测试redis-cli连接，select 15会报错</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5f523147664c3c61324da7c493950395/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Ubuntu上重装Python2（强烈建议在不删除数据情况下，直接重装系统，不要动原本的Python，用anaconda做环境隔离）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/25b82299f7df3ee3518fd5d40fbdb2f8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小白看得懂的 Transformer (图解)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>