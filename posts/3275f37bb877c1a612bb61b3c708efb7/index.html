<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式怎样解决设计问题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式怎样解决设计问题" />
<meta property="og:description" content="设计模式采用多种方法解决面向对象设计者经常碰到的问题，这里给出几个问题以及使用设计模式解决他们的方法。
1.寻找合适的对象
面向对象程序由对象组成，对象包括数据和对数据进行操作的过程，过程通常称为方法或操作，对象在收到客户的请求（或）消息后，执行相应的操作。
客户请求是使对象执行操作的唯一方法，操作又是对象改变内部数据的唯一方法。由于这些限制，对象的内部状态是被封装的，它不能被直接访问，它的表示对于对象外部是不可见的。
面向对象设计最困难的部分是将系统分解成对象集合。因为要考虑许多因素：封装、粒度、依赖关系、灵活性、性能、演化、复用、扩展等等，它们都是影响着系统的分解，并且这些因素通常还是相互冲突的。
面向对象设计方法学支持许多设计方法。你可以写出一个问题的描述，挑出名词和动词，进而创建相应的类和操作；或者，你可以关注系统的协作和指责关系；或者，你可以对现实世界建模，再将分析时发现的对象转化至设计中，至于哪一种方法最好，并无定论。
设计的许多对象来源于现实世界的分析建模。但是，设计结果所得到的类通常在现实世界中并不存在，有些是像数组之类的低层类，而另一些层次较高。例如，Composite模式引入了统一对待现实世界中并不存在的对象的抽象方法。严格反映当前现实世界的模型并不能产生反映将来世界的系统。设计中的抽象对于生产灵活的设计是至关重要的。
设计模式帮你确定并不明显的抽象和描述这些抽象的对象。例如，描述过程或算法的对象现实中并不存在，但他们却是设计的关键部分。Strategy模式描述了怎样实现可互换的算法族。State模式将实体的每一个状态描述为一个对象。这些对象在分析阶段，甚至在设计阶段的早期都并不存在，后来为使设计更灵活，复用性更好才将它们发掘出来。
2.决定对象的粒度
对象在大小和数目上变化极大，它们能表示下至硬件或上至整个应用的任何事物。那么我们怎样决定一个对象应该使什么呢？
设计模式很好的讲述了这个问题。 Facade模式描述了怎样用对象表示完整的子系统，Flyweight模式描述了如何支持大量最小粒度的对象。其他一些设计模式描述了将一个对象分解成许多小对象的特定方法。 Abstract Factory和Builder产生那些专门负责生成其他对象的对象。Visitor和Command生成的对象专门负责实现对其他对象或对象组的请求。
3.指定对象接口
对象声明的每一个操作指定操作名，作为参数的对象和返回值，这就是所谓的操作的型构（signature） 。对象操作所定义的所有操作型构的集合被称为该对象的接口（interface）。对象接口描述了该对象所能接受的全部请求的集合，任何匹配对象接口中型构的请求都可以发送给该对象。
类型（Type）是用来标识特定接口的一个名字。 如果一个对象接受 “window”接口所定义的所有操作请求，那么我们就说该对象具有“window”类型。一个对象可以有恀类型，并且不同的对象可以共享同一个类型。对象接口的某部分可以用某个类型来刻画，而其他部分可以用其他类型刻画。两个类型相同的对象只需要共享他们的部分接口。接口可以包含其他接口作为子集。当一个类型的接口包含另一个类型的接口时，我们就说他是另一个类型的子类型（subtype）另一个类型称之为它的超类型（supertype） 我们常说子类型继承了它的超类型的接口。
在面向对象系统中，接口是基本的组成部分。对象只有通过它们的接口才能于外部交流，如果不通过对象的接口就无法知道对象的任何事情，也无法请求对象做任何事情。对象接口与其功能实现是分离的，不同对象可以对请求做不同的实现，也就是说，两个有相同接口的对象可以有完全不同的实现。
当给对象发送该请求时，所引起的具体操作既与请求本身有感又与接受对象有关。支持相同请求的 不同对象可能对请求激发的操作又不同的实现。发送给对象的请求和它的相应操作在运行时刻的连接就称之为动态绑定（dynamic binding）。
动态绑定是指发送的请求直到运行时刻才受你的具体实现的约束。因而，在知道任何有正确接口的对象都将接受此请求时，你可以写一个一般的程序，它期待着那些具有该特定接口的对象。进一步讲，动态绑定允许你在运行时刻彼此替换有相同接口的对象。这种可替换性就称为多态（polymorphism），它是面向对象系统中的核心概念之一。多态允许客户对像仅要求其他对象支持特定接口，除此之外对其假设几乎近于无。多态简化了客户的定义，使得对象间彼此独立，并可以在于运行时刻改变它们相互的关系。
设计模式通过确定接口的主要组成成分及经接口发送的数据类型，来帮助你定义接口。设计模式也许还会告诉你接口中不应该包括哪些东西，Memento模式是一个很好的例子，它描述了怎样封装和保存对象内部的状态，以便一段时间后对象能够恢复到这一状态。它规定了Memento对象必须定义两个接口：一个允许客户保持和复制Memento的限制接口，和一个只有原对象才能使用的用来存储和提取memento中状态的特权接口。
设计模式也制定了接口之间的关系，例如，Decorator和Proxy模式要求Decorator和Proxy对象的接口与被修饰的对象和受委托的对象一致，而Visitor模式中，Visitor接口必须反映出visitor能访问的对象的所有的类。 2019-04-12：0点。
4.描述对象的实现
我们很少提及到实际上怎么定义一个对象。对象的实现是由它的类决定的，类指定了对象内部的数据和表示，也定义了对象所能完成的操作。
对象通过实例化类来创建，此对象被称为该类的实例。当实例化类时，摇滚i对象的内部数据（由实例变量组成）分配存储空间，并将操作与这些数据联系起来。对象的许多类似实例是由实例化同一个类来实现的。
新的类可以由已存在的类通过继承（class inheritance）来定义，当子类（subclass）继承父类（parentclass）时，子类包含了父类定义的所有的数据和操作。 子类的实例对象包含所有子类和父类定义的数据，且它们能够完成子类和父类定义的所有操作。
抽象类（abstract class）的主要目的是为它的子类定义公共接口。 一个抽象类将把它的部分或全部擦偶哦真的实现延迟到子类中。因此，一个抽象类不能被实例化。在抽象类中定义却没有实现的擦欧总被成为抽象操作（abstract operation），非抽象类被称为具体类（concrete class）。
子类能够改进和重更新定义它们父类的操作。更具体地说，类能够重定义（override）父类定义的操作，重定义使得子类能接管父类对请求的处理操作。 类继承允许你只需简单的扩展其他类就可以定义新类，从而可以很容易地定义具有相近功能地对象族。
混入类（mixin class）是给其他类提供可选择的接口或功能地类，它与抽象类一样不能被实例化，混入类要求多继承。
1.类继承与接口继承的比较：
理解对象的类（class）与对象的类型（type）之间的差别非常重要。
一个对象的类定义了对象是怎样实现的，同时也定义了对象的内部状态和操作的实现。但是对象的类型只与它的接口有关，接口即对象能够响应的请求的集合。一个对象可以有多个类型，不同类的对象可以有相同的类型。
当然，对象的类和类型是有紧密关系的。因为类定义了对象所能执行的操作，也定义了对象的类型。当我们说一个对象是一个类的实例时，即指该对象支持类所定义的接口。
理解类继承和接口继承（或子类型化）之间的差别也十分重要。类继承根据一个对象的实现定义了另一个对象的实现。简而言之，它是代码和标识的共享机制。然而接口继承（或子类型化）描述了一个对象什么时候能被用来替代另一个对象。
2.对接口编程，而不是对实现编程。
类继承是一个通过复用父类功能而扩展应用功能的基本机制。它允许你根据旧对象款苏定义新对象。它允许你从已存在的类中继承所需要的绝大部分功能，从而几乎无需任何代价就可以获得新的实现。
然而，实现的复用只是成功的一半，继承所拥有的定义具有相同接口的对象组的能力也是很重要的（通常可以从抽象类来继承）。为什么，因为多态依赖于这种能力。
当继承被恰当的使用时，所有从抽象类到处的类将共享该抽象类的接口。这意味着子类仅仅添加或重定义操作，而没有隐藏父类的操作。这时，所有的子类都能响应抽象类接口中的请求，从而子类的类型都是抽象类的子类型。
只根据抽象类中定义的接口来操作对象有一下两个好处：
1）客户无需知道它们使用对象的特定类型，只须对象有客户所期望的接口。
2）客户无需知道它们使用的对象是什么类来实现的，它们只须知道定义接口的抽象类。
这将极大的减少子系统实现之间的相互依赖关系，也产生了可复用的面向对象设计的如下原则：
针对接口编程，而不是针对实现编程。
不将变量声明为偶个特定聚类的实例对象，而是让它遵从抽象类所定义的接口。这是本书设计模式的一个常见主题。
当你不得不在系统的某个地方实例化具体的类（即指定一个特定的实现时），创建型模式 （Abstract factory ，Builder，Factory Method，Prototype，Singlenton）可以帮你。通过抽象对象的创建过程，这些模式提供不同方式以在实例化时建立接口和实现的透明连接。创建型模式确保你的系统是采用针对接口方式书写的，而不是针对实现书写的。 2019-04-15：23：00
5.运用复用机制
6.关联运行时刻和编译时刻的结构
7.设计应支持变化
待续。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3275f37bb877c1a612bb61b3c708efb7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-12T00:21:00+08:00" />
<meta property="article:modified_time" content="2019-04-12T00:21:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式怎样解决设计问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　设计模式采用多种方法解决面向对象设计者经常碰到的问题，这里给出几个问题以及使用设计模式解决他们的方法。</span></p> 
 <p> </p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">1.寻找合适的对象</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　面向对象程序由对象组成，对象包括数据和对数据进行操作的过程，过程通常称为方法或操作，对象在收到客户的请求（或）消息后，执行相应的操作。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　客户请求是使对象执行操作的唯一方法，操作又是对象改变内部数据的唯一方法。由于这些限制，对象的内部状态是被封装的，它不能被直接访问，它的表示对于对象外部是不可见的。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　面向对象设计最困难的部分是将系统分解成对象集合。因为要考虑许多因素：<strong>封装、粒度、依赖关系、灵活性、性能、演化、复用、扩展</strong>等等，它们都是影响着系统的分解，并且这些因素通常还是相互冲突的。<br></span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　面向对象设计方法学支持许多设计方法。<strong>你可以写出一个问题的描述，挑出名词和动词，进而创建相应的类和操作；</strong>或者，你可以关注系统的协作和指责关系；或者，<strong>你可以对现实世界建模，再将分析时发现的对象转化至设计中</strong>，至于哪一种方法最好，并无定论。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　设计的许多对象来源于现实世界的分析建模。但是，设计结果所得到的类通常在现实世界中并不存在，有些是像数组之类的低层类，而另一些层次较高。例如，Composite模式引入了统一对待现实世界中并不存在的对象的抽象方法。严格反映当前现实世界的模型并不能产生反映将来世界的系统。设计中的抽象对于生产灵活的设计是至关重要的。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　设计模式帮你确定并不明显的抽象和描述这些抽象的对象。例如，描述过程或算法的对象现实中并不存在，但他们却是设计的关键部分。Strategy模式描述了怎样实现可互换的算法族。State模式将实体的每一个状态描述为一个对象。这些对象在分析阶段，甚至在设计阶段的早期都并不存在，后来为使设计更灵活，复用性更好才将它们发掘出来。</span></p> 
 <p> </p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">2.决定对象的粒度</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　对象在大小和数目上变化极大，<strong>它们能表示下<span style="color:#ff0000;">至</span>硬件或上<span style="color:#ff0000;">至</span>整个应用的任何事物。</strong>那么我们怎样决定一个对象应该使什么呢？</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　设计模式很好的讲述了这个问题。 Facade模式描述了怎样用对象表示完整的子系统，Flyweight模式描述了如何支持大量最小粒度的对象。其他一些设计模式描述了将一个对象分解成许多小对象的特定方法。 Abstract Factory和Builder产生那些专门负责生成其他对象的对象。Visitor和Command生成的对象专门负责实现对其他对象或对象组的请求。</span></p> 
 <p> </p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">3.指定对象接口</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　对象声明的每一个操作指定操作名，作为参数的对象和返回值，这就是所谓的操作的<strong>型构（signature） 。对象操作所定义的所有操作型构的集合被称为该对象的接口（interface）</strong>。对象接口描述了该对象所能接受的全部请求的集合，任何匹配对象接口中型构的请求都可以发送给该对象。</span></p> 
 <p><strong><span style="font-size:16px;font-family:'Microsoft YaHei';">　　类型（Type）是用来标识特定接口的一个名字。 </span></strong><span style="font-size:16px;font-family:'Microsoft YaHei';">如果一个对象接受 “window”接口所定义的所有操作请求，那么我们就说该对象具有“window”类型。一个对象可以有恀类型，并且不同的对象可以共享同一个类型。对象接口的某部分可以用某个类型来刻画，而其他部分可以用其他类型刻画。两个类型相同的对象只需要共享他们的部分接口。接口可以包含其他接口作为子集。当一个类型的接口包含另一个类型的接口时，我们就说他是另一个类型的<strong>子类型（subtype）</strong>另一个类型称之为它的<strong>超类型（supertype）</strong> 我们常说子类型继承了它的超类型的接口。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　在面向对象系统中，接口是基本的组成部分。对象只有通过它们的接口才能于外部交流，如果不通过对象的接口就无法知道对象的任何事情，也无法请求对象做任何事情。对象接口与其功能实现是分离的，不同对象可以对请求做不同的实现，也就是说，两个有相同接口的对象可以有完全不同的实现。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　当给对象发送该请求时，所引起的具体操作既与请求本身有感又与接受对象有关。支持相同请求的 不同对象可能对请求激发的操作又不同的实现。<strong>发送给对象的请求和它的相应操作在运行时刻的连接就称之为动态绑定（dynamic binding）。</strong></span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　动态绑定是指发送的请求直到运行时刻才受你的具体实现的约束。因而，在知道任何有正确接口的对象都将接受此请求时，你可以写一个一般的程序，它期待着那些具有该特定接口的对象。进一步讲，动态绑定允许你在运行时刻彼此替换有相同接口的对象。这种可替换性就称为<strong>多态（polymorphism）</strong>，它是面向对象系统中的核心概念之一。多态允许客户对像仅要求其他对象支持特定接口，除此之外对其假设几乎近于无。多态简化了客户的定义，使得对象间彼此独立，并可以在于运行时刻改变它们相互的关系。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　设计模式通过确定接口的主要组成成分及经接口发送的数据类型，来帮助你定义接口。设计模式也许还会告诉你接口中不应该包括哪些东西，Memento模式是一个很好的例子，它描述了怎样封装和保存对象内部的状态，以便一段时间后对象能够恢复到这一状态。它规定了Memento对象必须定义两个接口：一个允许客户保持和复制Memento的限制接口，和一个只有原对象才能使用的用来存储和提取memento中状态的特权接口。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　设计模式也制定了接口之间的关系，例如，Decorator和Proxy模式要求Decorator和Proxy对象的接口与被修饰的对象和受委托的对象一致，而Visitor模式中，Visitor接口必须反映出visitor能访问的对象的所有的类。  2019-04-12：0点。</span></p> 
 <p> </p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">4.描述对象的实现</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　我们很少提及到实际上怎么定义一个对象。对象的实现是由它的类决定的，类指定了对象内部的数据和表示，也定义了对象所能完成的操作。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　对象通过实例化类来创建，此对象被称为该类的实例。当实例化类时，摇滚i对象的内部数据（由实例变量组成）分配存储空间，并将操作与这些数据联系起来。对象的许多类似实例是由实例化同一个类来实现的。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　新的类可以由已存在的类通过继承（class inheritance）来定义，当子类（subclass）继承父类（parentclass）时，子类包含了父类定义的所有的数据和操作。 子类的实例对象包含所有子类和父类定义的数据，且它们能够完成子类和父类定义的所有操作。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　抽象类（abstract class）的主要目的是为它的子类定义公共接口。 一个抽象类将把它的部分或全部擦偶哦真的实现延迟到子类中。因此，一个抽象类不能被实例化。在抽象类中定义却没有实现的擦欧总被成为抽象操作（abstract operation），非抽象类被称为具体类（concrete class）。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　子类能够改进和重更新定义它们父类的操作。更具体地说，类能够重定义（override）父类定义的操作，重定义使得子类能接管父类对请求的处理操作。 类继承允许你只需简单的扩展其他类就可以定义新类，从而可以很容易地定义具有相近功能地对象族。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　混入类（mixin class）是给其他类提供可选择的接口或功能地类，它与抽象类一样不能被实例化，混入类要求多继承。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　1.类继承与接口继承的比较：</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　理解对象的类（class）与对象的类型（type）之间的差别非常重要。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　一个对象的类定义了对象是怎样实现的，同时也定义了对象的内部状态和操作的实现。但是对象的类型只与它的接口有关，接口即对象能够响应的请求的集合。一个对象可以有多个类型，不同类的对象可以有相同的类型。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　当然，对象的类和类型是有紧密关系的。因为类定义了对象所能执行的操作，也定义了对象的类型。当我们说一个对象是一个类的实例时，即指该对象支持类所定义的接口。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　理解类继承和接口继承（或子类型化）之间的差别也十分重要。类继承根据一个对象的实现定义了另一个对象的实现。简而言之，它是代码和标识的共享机制。然而接口继承（或子类型化）描述了一个对象什么时候能被用来替代另一个对象。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　2.对接口编程，而不是对实现编程。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　类继承是一个通过复用父类功能而扩展应用功能的基本机制。它允许你根据旧对象款苏定义新对象。它允许你从已存在的类中继承所需要的绝大部分功能，从而几乎无需任何代价就可以获得新的实现。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　然而，实现的复用只是成功的一半，继承所拥有的定义具有相同接口的对象组的能力也是很重要的（通常可以从抽象类来继承）。为什么，因为多态依赖于这种能力。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　当继承被恰当的使用时，所有从抽象类到处的类将共享该抽象类的接口。这意味着子类仅仅添加或重定义操作，而没有隐藏父类的操作。这时，所有的子类都能响应抽象类接口中的请求，从而子类的类型都是抽象类的子类型。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　只根据抽象类中定义的接口来操作对象有一下两个好处：</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　1）客户无需知道它们使用对象的特定类型，只须对象有客户所期望的接口。<br></span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　2）客户无需知道它们使用的对象是什么类来实现的，它们只须知道定义接口的抽象类。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　这将极大的减少子系统实现之间的相互依赖关系，也产生了可复用的面向对象设计的如下原则：</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　针对接口编程，而不是针对实现编程。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　不将变量声明为偶个特定聚类的实例对象，而是让它遵从抽象类所定义的接口。这是本书设计模式的一个常见主题。</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">　　当你不得不在系统的某个地方实例化具体的类（即指定一个特定的实现时），创建型模式 （Abstract factory ，Builder，Factory Method，Prototype，Singlenton）可以帮你。通过抽象对象的创建过程，这些模式提供不同方式以在实例化时建立接口和实现的透明连接。创建型模式确保你的系统是采用针对接口方式书写的，而不是针对实现书写的。  2019-04-15：23：00</span></p> 
 <p> </p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">5.运用复用机制</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">6.关联运行时刻和编译时刻的结构</span></p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">7.设计应支持变化</span></p> 
 <p> </p> 
 <p><span style="font-size:16px;font-family:'Microsoft YaHei';">待续。</span></p> 
</div> 
<p>转载于:https://www.cnblogs.com/planheaven/p/10693547.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bad5d752418518738380ae9e9969f4e4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Excel-宏、VBA</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1ab00a11e607bddd2eb82db0c058bda5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">TextView限制行数，每行限制字符数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>