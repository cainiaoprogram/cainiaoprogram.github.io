<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>K-means聚类算法的三种改进(K-means&#43;&#43;,ISODATA,Kernel K-means)介绍与对比 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="K-means聚类算法的三种改进(K-means&#43;&#43;,ISODATA,Kernel K-means)介绍与对比" />
<meta property="og:description" content="目录
一、概述
二、经典K-means算法
三、K-means&#43;&#43;算法
四、ISODATA算法
六、数据集测试
一、概述 在本篇文章中将对四种聚类算法(K-means,K-means&#43;&#43;,ISODATA和Kernel K-means)进行详细介绍，并利用数据集来真实地反映这四种算法之间的区别。
首先需要明确的是上述四种算法都属于&#34;硬聚类”算法，即数据集中每一个样本都是被100%确定得分到某一个类别中。与之相对的&#34;软聚类”可以理解为每个样本是以一定的概率被分到某一个类别中。
先简要阐述下上述四种算法之间的关系，已经了解过经典K-means算法的读者应该会有所体会。没有了解过K-means的读者可以先看下面的经典K-means算法介绍再回来看这部分。
(1) K-means与K-means&#43;&#43;：原始K-means算法最开始随机选取数据集中K个点作为聚类中心，而K-means&#43;&#43;按照如下的思想选取K个聚类中心：假设已经选取了n个初始聚类中心(0&lt;n&lt;K)，则在选取第n&#43;1个聚类中心时：距离当前n个聚类中心越远的点会有更高的概率被选为第n&#43;1个聚类中心。在选取第一个聚类中心(n=1)时同样通过随机的方法。可以说这也符合我们的直觉：聚类中心当然是互相离得越远越好。这个改进虽然直观简单，但是却非常得有效。
(2) K-means与ISODATA：ISODATA的全称是迭代自组织数据分析法。在K-means中，K的值需要预先人为地确定，并且在整个算法过程中无法更改。而当遇到高维度、海量的数据集时，人们往往很难准确地估计出K的大小。ISODATA就是针对这个问题进行了改进，它的思想也很直观：当属于某个类别的样本数过少时把这个类别去除，当属于某个类别的样本数过多、分散程度较大时把这个类别分为两个子类别。
(3) K-means与Kernel K-means：传统K-means采用欧式距离进行样本间的相似度度量，显然并不是所有的数据集都适用于这种度量方式。参照支持向量机中核函数的思想，将所有样本映射到另外一个特征空间中再进行聚类，就有可能改善聚类效果。本文不对Kernel K-means进行详细介绍。
可以看到，上述三种针对K-means的改进分别是从不同的角度出发的，因此都非常具有代表意义。目前应用广泛的应该还是K-means&#43;&#43;算法（例如2016年底的NIPS上也有针对K-means&#43;&#43;的改进，感兴趣的读者可以进一步学习https://papers.nips.cc/paper/6478-fast-and-provably-good-seedings-for-k-means）。
二、经典K-means算法 算法描述如下，非常清晰易懂。经典K-means算法应该是每个无监督学习教程开头都会讲的内容，故不再多费口舌说一遍了。
图1. 经典K-means算法
值得一提的是关于聚类中心数目（K值）的选取，的确存在一种可行的方法，叫做Elbow Method：通过绘制K-means代价函数与聚类数目K的关系图，选取直线拐点处的K值作为最佳的聚类中心数目。但在这边不做过多的介绍，因为上述方法中的拐点在实际情况中是很少出现的。比较提倡的做法还是从实际问题出发，人工指定比较合理的K值，通过多次随机初始化聚类中心选取比较满意的结果。
三、K-means&#43;&#43;算法 2007年由D. Arthur等人提出的K-means&#43;&#43;针对图1中的第一步做了改进。可以直观地将这改进理解成这K个初始聚类中心相互之间应该分得越开越好。整个算法的描述如下图所示：
图2. K-means&#43;&#43;算法
下面结合一个简单的例子说明K-means&#43;&#43;是如何选取初始聚类中心的。数据集中共有8个样本，分布以及对应序号如下图所示：
图3. K-means&#43;&#43;示例
假设经过图2的步骤一后6号点被选择为第一个初始聚类中心，那在进行步骤二时每个样本的D(x)和被选择为第二个聚类中心的概率如下表所示：
其中的P(x)就是每个样本被选为下一个聚类中心的概率。最后一行的Sum是概率P(x)的累加和，用于轮盘法选择出第二个聚类中心。方法是随机产生出一个0~1之间的随机数，判断它属于哪个区间，那么该区间对应的序号就是被选择出来的第二个聚类中心了。例如1号点的区间为[0,0.2)，2号点的区间为[0.2, 0.525)。
从上表可以直观的看到第二个初始聚类中心是1号，2号，3号，4号中的一个的概率为0.9。而这4个点正好是离第一个初始聚类中心6号点较远的四个点。这也验证了K-means的改进思想：即离当前已有聚类中心较远的点有更大的概率被选为下一个聚类中心。可以看到，该例的K值取2是比较合适的。当K值大于2时，每个样本会有多个距离，需要取最小的那个距离作为D(x)。
四、ISODATA算法 放在最后也是最复杂的就是ISODATA算法。正如之前所述，K-means和K-means&#43;&#43;的聚类中心数K是固定不变的。而ISODATA算法在运行过程中能够根据各个类别的实际情况进行两种操作来调整聚类中心数K：(1)分裂操作，对应着增加聚类中心数；(2)合并操作，对应着减少聚类中心数。
下面首先给出ISODATA算法的输入（输入的数据和迭代次数不再单独介绍）：
[1] 预期的聚类中心数目Ko：虽然在ISODATA运行过程中聚类中心数目是可变的，但还是需要由用户指定一个参考标准。事实上，该算法的聚类中心数目变动范围也由Ko决定。具体地，最终输出的聚类中心数目范围是 [Ko/2, 2Ko]。
[2] 每个类所要求的最少样本数目Nmin：用于判断当某个类别所包含样本分散程度较大时是否可以进行分裂操作。如果分裂后会导致某个子类别所包含样本数目小于Nmin，就不会对该类别进行分裂操作。
[3] 最大方差Sigma：用于衡量某个类别中样本的分散程度。当样本的分散程度超过这个值时，则有可能进行分裂操作（注意同时需要满足[2]中所述的条件）。
[4] 两个类别对应聚类中心之间所允许最小距离dmin：如果两个类别靠得非常近（即这两个类别对应聚类中心之间的距离非常小），则需要对这两个类别进行合并操作。是否进行合并的阈值就是由dmin决定。
相信很多人看完上述输入的介绍后对ISODATA算法的流程已经有所猜测了。的确，ISODATA算法的原理非常直观，不过由于它和其他两个方法相比需要额外指定较多的参数，并且某些参数同样很难准确指定出一个较合理的值，因此ISODATA算法在实际过程中并没有K-means&#43;&#43;受欢迎。
首先给出ISODATA算法主体部分的描述，如下图所示：
图4. ISODATA算法的主体部分
上面描述中没有说明清楚的是第5步中的分裂操作和第6步中的合并操作。下面首先介绍合并操作：
图5. ISODATA算法的合并操作
最后是ISODATA算法中的分裂操作。
图6. ISODATA算法的分裂操作
最后，针对ISODATA算法总结一下：该算法能够在聚类过程中根据各个类所包含样本的实际情况动态调整聚类中心的数目。如果某个类中样本分散程度较大（通过方差进行衡量）并且样本数量较大，则对其进行分裂操作；如果某两个类别靠得比较近（通过聚类中心的距离衡量），则对它们进行合并操作。
可能没有表述清楚的地方是ISODATA-分裂操作的第1步和第2步。同样地以图三所示数据集为例，假设最初1，2，3，4，5，6，8号被分到了同一个类中，执行第1步和第2步结果如下所示：
而在正确分类情况下（即1，2，3，4为一类；5，6，7，8为一类），方差为0.33。因此，目前的方差远大于理想的方差，ISODATA算法就很有可能对其进行分裂操作。
五、聚类算法源代码
我已经将上述三种算法整合成一个Matlab函数Clustering.m。读者可以直接使用该函数对数据集进行聚类。由于代码比较长，而且代码插件还不怎么会用，就不在文中介绍了。需要使用的读者可以点击下面的链接下载使用（欢迎Star和Fork，之后会不定期补充新的算法和优化的）：
GitHub - xuyxu/Clustering: Clustering / Subspace Clustering Algorithms on MATLAB" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d68c82235ebee1a84d27c81442da9f4d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-25T22:22:25+08:00" />
<meta property="article:modified_time" content="2023-03-25T22:22:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">K-means聚类算法的三种改进(K-means&#43;&#43;,ISODATA,Kernel K-means)介绍与对比</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%C2%A0%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0-toc" style="margin-left:0px;"><a href="#%C2%A0%E4%B8%80%E3%80%81%E6%A6%82%E8%BF%B0" rel="nofollow"> 一、概述</a></p> 
<p id="%E4%BA%8C%E3%80%81%E7%BB%8F%E5%85%B8K-means%E7%AE%97%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E7%BB%8F%E5%85%B8K-means%E7%AE%97%E6%B3%95" rel="nofollow">二、经典K-means算法</a></p> 
<p id="%E4%B8%89%E3%80%81K-means%2B%2B%E7%AE%97%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81K-means%2B%2B%E7%AE%97%E6%B3%95" rel="nofollow">三、K-means++算法</a></p> 
<p id="%E5%9B%9B%E3%80%81ISODATA%E7%AE%97%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81ISODATA%E7%AE%97%E6%B3%95" rel="nofollow">四、ISODATA算法</a></p> 
<p id="%E5%85%AD%E3%80%81%E6%95%B0%E6%8D%AE%E9%9B%86%E6%B5%8B%E8%AF%95-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E6%95%B0%E6%8D%AE%E9%9B%86%E6%B5%8B%E8%AF%95" rel="nofollow">六、数据集测试</a></p> 
<hr id="hr-toc"> 
<h2><strong> 一、概述</strong></h2> 
<p>      在本篇文章中将对四种聚类算法(K-means,K-means++,ISODATA和Kernel K-means)进行详细介绍，并利用数据集来真实地反映这四种算法之间的区别。</p> 
<p>      首先需要明确的是上述四种算法都属于"<strong>硬聚类</strong>”算法，即数据集中每一个样本都是被100%确定得分到某一个类别中。与之相对的"<strong>软聚类</strong>”可以理解为每个样本是以一定的概率被分到某一个类别中。</p> 
<p>      先简要阐述下上述四种算法之间的关系，已经了解过经典K-means算法的读者应该会有所体会。没有了解过K-means的读者可以先看下面的经典K-means算法介绍再回来看这部分。</p> 
<p>     (1) <strong>K-means与K-means++：</strong>原始K-means算法最开始随机选取数据集中K个点作为聚类中心，而K-means++按照如下的思想选取K个聚类中心：假设已经选取了n个初始聚类中心(0&lt;n&lt;K)，则在选取第n+1个聚类中心时：距离当前n个聚类中心越远的点会有更高的概率被选为第n+1个聚类中心。在选取第一个聚类中心(n=1)时同样通过随机的方法。可以说这也符合我们的直觉：聚类中心当然是互相离得越远越好。这个改进虽然直观简单，但是却非常得有效。</p> 
<p>      (2) <strong>K-means与ISODATA：</strong>ISODATA的全称是迭代自组织数据分析法。在K-means中，K的值需要预先人为地确定，并且在整个算法过程中无法更改。而当遇到高维度、海量的数据集时，人们往往很难准确地估计出K的大小。ISODATA就是针对这个问题进行了改进，它的思想也很直观：当属于某个类别的样本数过少时把这个类别去除，当属于某个类别的样本数过多、分散程度较大时把这个类别分为两个子类别。</p> 
<p>      (3) <strong>K-means与Kernel K-means：</strong>传统K-means采用欧式距离进行样本间的相似度度量，显然并不是所有的数据集都适用于这种度量方式。参照支持向量机中核函数的思想，将所有样本映射到另外一个特征空间中再进行聚类，就有可能改善聚类效果。本文不对Kernel K-means进行详细介绍。</p> 
<p>      可以看到，上述三种针对K-means的改进分别是从不同的角度出发的，因此都非常具有代表意义。目前应用广泛的应该还是K-means++算法（<a class="has-card" href="https://papers.nips.cc/paper/6478-fast-and-provably-good-seedings-for-k-means" rel="nofollow" title="例如2016年底的NIPS上也有针对K-means++的改进，感兴趣的读者可以进一步学习"><span class="link-card-box"><span class="link-title">例如2016年底的NIPS上也有针对K-means++的改进，感兴趣的读者可以进一步学习</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/57/35/rlJHEGmd_o.png" alt="icon-default.png?t=N2N8">https://papers.nips.cc/paper/6478-fast-and-provably-good-seedings-for-k-means</span></span></a>）。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E7%BB%8F%E5%85%B8K-means%E7%AE%97%E6%B3%95"><strong>二、经典K-means算法</strong></h2> 
<p><strong>    </strong>算法描述如下，非常清晰易懂。经典K-means算法应该是每个无监督学习教程开头都会讲的内容，故不再多费口舌说一遍了。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/78/d1/vqgaS798_o.png"></p> 
<p style="text-align:center;"><strong>图1. 经典K-means算法</strong></p> 
<p>      值得一提的是关于聚类中心数目（K值）的选取，的确存在一种可行的方法，叫做Elbow Method：通过绘制K-means代价函数与聚类数目K的关系图，选取直线拐点处的K值作为最佳的聚类中心数目。但在这边不做过多的介绍，因为上述方法中的拐点在实际情况中是很少出现的。<strong>比较提倡的做法还是从实际问题出发，人工指定比较合理的K值，通过多次随机初始化聚类中心选取比较满意的结果。</strong></p> 
<h2 id="%E4%B8%89%E3%80%81K-means%2B%2B%E7%AE%97%E6%B3%95"><strong>三、K-means++算法</strong></h2> 
<p>      <a href="http://ilpubs.stanford.edu:8090/778/1/2006-13.pdf" rel="nofollow" title="2007年由D. Arthur等人提出的K-means++针对图1中的第一步做了改进">2007年由D. Arthur等人提出的K-means++针对图1中的第一步做了改进</a>。可以直观地将这改进理解成这K个初始聚类中心相互之间应该分得越开越好。整个算法的描述如下图所示：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/45/f3/yKxktaIS_o.png"></p> 
<p style="text-align:center;">    <strong>图2. K-means++算法</strong></p> 
<p>      下面结合一个简单的例子说明K-means++是如何选取初始聚类中心的。数据集中共有8个样本，分布以及对应序号如下图所示：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f7/44/F6Gq5JQO_o.png"></p> 
<p style="text-align:center;"><strong>图3. K-means++示例</strong></p> 
<p>      假设经过图2的步骤一后6号点被选择为第一个初始聚类中心，那在进行步骤二时每个样本的<em><strong>D(x)</strong></em>和被选择为第二个聚类中心的概率如下表所示：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/95/97/WqWf4iU5_o.png"></p> 
<p>    其中的<strong><em>P(x)</em></strong>就是每个样本被选为下一个聚类中心的概率。最后一行的<strong><em>Sum</em></strong>是概率<strong><em>P(x)</em></strong>的累加和，用于轮盘法选择出第二个聚类中心。方法是随机产生出一个0~1之间的随机数，判断它属于哪个区间，那么该区间对应的序号就是被选择出来的第二个聚类中心了。例如1号点的区间为[0,0.2)，2号点的区间为[0.2, 0.525)。</p> 
<p>      从上表可以直观的看到第二个初始聚类中心是1号，2号，3号，4号中的一个的概率为0.9。而这4个点正好是离第一个初始聚类中心6号点较远的四个点。这也验证了K-means的改进思想：即离当前已有聚类中心较远的点有更大的概率被选为下一个聚类中心。可以看到，该例的K值取2是比较合适的。当K值大于2时，每个样本会有多个距离，需要取最小的那个距离作为<strong><em>D(x)</em></strong>。</p> 
<h2 id="%E5%9B%9B%E3%80%81ISODATA%E7%AE%97%E6%B3%95"><strong>四、ISODATA算法</strong></h2> 
<p>     放在最后也是最复杂的就是ISODATA算法。正如之前所述，K-means和K-means++的聚类中心数K是固定不变的。而ISODATA算法在运行过程中能够根据各个类别的实际情况进行两种操作来调整聚类中心数K：(1)<strong>分裂操作</strong>，对应着增加聚类中心数；(2)<strong>合并操作</strong>，对应着减少聚类中心数。</p> 
<p>    下面首先给出ISODATA算法的输入（输入的数据和迭代次数不再单独介绍）：</p> 
<p>      <strong>[1] 预期的聚类中心数目<em>Ko</em></strong>：虽然在ISODATA运行过程中聚类中心数目是可变的，但还是需要由用户指定一个参考标准。事实上，该算法的聚类中心数目变动范围也由<strong><em>Ko</em></strong>决定。具体地，最终输出的聚类中心数目范围是 [<strong><em>Ko/2</em></strong>,<em><strong> 2Ko</strong></em>]。</p> 
<p>      <strong>[2] 每个类所要求的最少样本数目<em>Nmin</em></strong>：用于判断当某个类别所包含样本分散程度较大时是否可以进行分裂操作。如果分裂后会导致某个子类别所包含样本数目小于<em><strong>Nmin</strong></em>，就不会对该类别进行分裂操作。</p> 
<p>      <strong>[3] 最大方差<em>Sigma</em></strong>：用于衡量某个类别中样本的分散程度。当样本的分散程度超过这个值时，则有可能进行分裂操作（注意同时需要满足<strong>[2]</strong>中所述的条件）。</p> 
<p>      <strong>[4] 两个类别对应聚类中心之间所允许最小距离<em>dmin</em></strong>：如果两个类别靠得非常近（即这两个类别对应聚类中心之间的距离非常小），则需要对这两个类别进行合并操作。是否进行合并的阈值就是由<em><strong>dmin</strong></em>决定。</p> 
<p>      相信很多人看完上述输入的介绍后对ISODATA算法的流程已经有所猜测了。的确，ISODATA算法的原理非常直观，不过由于它和其他两个方法相比需要额外指定较多的参数，并且某些参数同样很难准确指定出一个较合理的值，因此ISODATA算法在实际过程中并没有K-means++受欢迎。</p> 
<p>      首先给出ISODATA算法主体部分的描述，如下图所示：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/49/72/ddj4TEKn_o.png"></p> 
<p style="text-align:center;"><strong>图4. ISODATA算法的主体部分</strong></p> 
<p>     上面描述中没有说明清楚的是第5步中的分裂操作和第6步中的合并操作。下面首先介绍合并操作：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/88/8b/1ptk2eaK_o.png"></p> 
<p style="text-align:center;"><strong>图5. ISODATA算法的合并操作</strong></p> 
<p>     最后是ISODATA算法中的分裂操作。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/4a/78/d2tuFQ1y_o.png"></p> 
<p style="text-align:center;"><strong>图6. ISODATA算法的分裂操作</strong></p> 
<p>      最后，针对ISODATA算法总结一下：<strong>该算法能够在聚类过程中根据各个类所包含样本的实际情况动态调整聚类中心的数目。如果某个类中样本分散程度较大（通过方差进行衡量）并且样本数量较大，则对其进行分裂操作；如果某两个类别靠得比较近（通过聚类中心的距离衡量），则对它们进行合并操作。</strong></p> 
<p><strong>       </strong>可能没有表述清楚的地方是ISODATA-分裂操作的第1步和第2步。同样地以图三所示数据集为例，假设最初1，2，3，4，5，6，8号被分到了同一个类中，执行第1步和第2步结果如下所示：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/56/87/ZqWgj0gr_o.png"></p> 
<p>      而在正确分类情况下（即1，2，3，4为一类；5，6，7，8为一类），方差为0.33。因此，目前的方差远大于理想的方差，ISODATA算法就很有可能对其进行分裂操作。</p> 
<p></p> 
<p><strong>五、聚类算法源代码</strong></p> 
<p>      我已经将上述三种算法整合成一个Matlab函数Clustering.m。读者可以直接使用该函数对数据集进行聚类。由于代码比较长，而且代码插件还不怎么会用，就不在文中介绍了。需要使用的读者可以点击下面的链接下载使用（欢迎Star和Fork，之后会不定期补充新的算法和优化的）：</p> 
<p><a href="https://github.com/AaronX121/Unsupervised-Learning-Clustering" title="GitHub - xuyxu/Clustering: Clustering / Subspace Clustering Algorithms on MATLAB">GitHub - xuyxu/Clustering: Clustering / Subspace Clustering Algorithms on MATLAB</a></p> 
<p>     使用方式非常简单，目前支持三种形式的输入，分别对应着上面的三种算法：</p> 
<p>     [centroid, result] = <strong>Clustering</strong>(data, ‘kmeans’, k , iteration);</p> 
<p>     [centroid, result] = <strong>Clustering</strong>(data, ‘kmeans++’, k , iteration);</p> 
<p>     [centroid, result] =</p> 
<p>   <strong>Clustering</strong>(data, ‘isodata’, desired_k , iteration, minimum_n, maximum_variance, minimum_d);</p> 
<p>      其中的输入data是一个矩阵，每一行代表数据集中的一个样本。其他输入的意义与上面的算法描述中一一对应。输出的centroid是聚类中心的位置，result是每个样本所对应的类别索引。</p> 
<h2 id="%E5%85%AD%E3%80%81%E6%95%B0%E6%8D%AE%E9%9B%86%E6%B5%8B%E8%AF%95"><strong>六、数据集测试</strong></h2> 
<p>      最后以一个简单的满足二维高斯分布的数据集为例，展示上述三种算法的聚类结果，如下图所示。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d1/46/q6iOrJns_o.png"></p> 
<p style="text-align:center;"><strong>图7. 一个简单数据集上三种算法的聚类效果（绿色加号代表聚类中心位置）</strong></p> 
<p>引用参考：</p> 
<p><a class="has-card" href="https://www.cnblogs.com/yixuan-xu/p/6272208.html" rel="nofollow" title="K-means聚类算法的三种改进(K-means++,ISODATA,Kernel K-means)介绍与对比"><span class="link-card-box"><span class="link-title">K-means聚类算法的三种改进(K-means++,ISODATA,Kernel K-means)介绍与对比</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/8d/f5/guQPFV2K_o.png" alt="icon-default.png?t=N2N8">https://www.cnblogs.com/yixuan-xu/p/6272208.html</span></span></a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b7db796f4b23a5163e9fc97f9c0a9ef5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用opencv将多帧图片合成为视频并保存</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/35642083d467ee37199a541977ae9649/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c&#43;&#43;语法入门</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>