<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java8函数式接口思考之异步委托 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java8函数式接口思考之异步委托" />
<meta property="og:description" content="什么是函数式接口 仅有一个抽象方法,可以拥有多个非抽象方法的的接口。
为什么java8有函数式接口 首先，我们需要明白函数是什么，在数学中函数通俗的意思就是由自变量和因变量所确定的一种关系。而在计算机中，函数则是是一个固定的一个程序段，它在可以实现固定运算功能，并且提供入参和结果出参(入参和出参非必须),可以通俗的理解为Java中的方法。
public int sum(int a, int b){ return a &#43; b; } 复制代码 在java这个面向对象的语言里，什么都可以被当作一个对象来描述，甚至是一个简单的用户名username，在需要的适合也可以封装成一个UserName对象，拥有自己的构造方法和逻辑方法，甚至可以在构造方法中完成构造我(UserName)需要的参数以及校验（例如&#34;我&#34;不能包含敏感字符）。
那么对于一个函数(方法)也不例外，它也可以被描述成一个对象
public class Sum{ public int sum(int a, int b){ return a &#43; b; } } 复制代码 在函数的基础上，为了多态扩展，函数会当作函数式接口来做不同实现
public interface Sum{ /** * 外部自己实现不同的sum逻辑 * / int sum(int a, int b); } 复制代码 一般情况下，接口实现都是通过创建一个类文件，并implements接口的方式来实现的，而这种方式在函数过多的情况下，如果都去实现一遍，往往会造成存在大量的类，造成管理上的混乱和使用上的不便。
所以在java8之前，Java的做法是接口的匿名实现，在代码中快速实现一个接口的匿名（临时的实现变量，没用具体继承自接口的类）实现。
例如我们在创建线程Thread时常用的参数 Runnable接口，在Thread构造方法中，有一个参数 Runnable , 这个Runnable赋值给了Thread的一个成员变量，最终在调用Thread的run方法时（也可以通过start()方法，但是start()方法是调用了native方法去启动的）方法时，run()里调用了runnable的run方法。
源码示例，具体源码可以自行阅读Thread源码：
使用方法：
public void testTheadRunnable() { new Thread(new Runnable() { @Override public void run() { System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/bbb9aa7731264bc808112491348d16b7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-30T14:24:33+08:00" />
<meta property="article:modified_time" content="2022-11-30T14:24:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java8函数式接口思考之异步委托</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>什么是函数式接口</h2> 
<p>仅有一个抽象方法,可以拥有多个非抽象方法的的接口。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/92/06/F4OUdCTj_o.png"></p> 
<h3>为什么java8有函数式接口</h3> 
<p>首先，我们需要明白函数是什么，在数学中函数通俗的意思就是由自变量和因变量所确定的一种关系。而在计算机中，函数则是是一个固定的一个程序段，它在可以实现固定运算功能，并且提供入参和结果出参(入参和出参非必须),可以通俗的理解为Java中的方法。</p> 
<pre><code>public int sum(int a, int b){
    return a + b;
}
复制代码</code></pre> 
<p>在java这个面向对象的语言里，什么都可以被当作一个对象来描述，甚至是一个简单的用户名username，在需要的适合也可以封装成一个UserName对象，拥有自己的构造方法和逻辑方法，甚至可以在构造方法中完成构造我(UserName)需要的参数以及校验（例如"我"不能包含敏感字符）。</p> 
<p>那么对于一个函数(方法)也不例外，它也可以被描述成一个对象</p> 
<pre><code>public class Sum{
  
    public int sum(int a, int b){
        return a + b;
    }
}
复制代码</code></pre> 
<p>在函数的基础上，为了多态扩展，函数会当作函数式接口来做不同实现</p> 
<pre><code>public interface Sum{
    /**
     * 外部自己实现不同的sum逻辑
     * /
    int sum(int a, int b);
}
复制代码</code></pre> 
<p>一般情况下，接口实现都是通过创建一个类文件，并implements接口的方式来实现的，而这种方式在函数过多的情况下，如果都去实现一遍，往往会造成存在大量的类，造成管理上的混乱和使用上的不便。</p> 
<p>所以在java8之前，Java的做法是接口的匿名实现，在代码中快速实现一个接口的匿名（临时的实现变量，没用具体继承自接口的类）实现。</p> 
<p>例如我们在创建线程Thread时常用的参数 Runnable接口，在Thread构造方法中，有一个参数 Runnable , 这个Runnable赋值给了Thread的一个成员变量，最终在调用Thread的run方法时（也可以通过start()方法，但是start()方法是调用了native方法去启动的）方法时，run()里调用了runnable的run方法。</p> 
<p>源码示例，具体源码可以自行阅读Thread源码：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/7a/d2/XmkVPo0E_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/65/bd/gPdEJsII_o.png"></p> 
<p>使用方法：</p> 
<pre><code>    public void testTheadRunnable() {
        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("匿名实现了一个runnable接口");
            }
        }).start();
        //等同于
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("匿名实现了一个runnable接口");
            }
        };
        new Thread(runnable).start();
    }
复制代码</code></pre> 
<p>但是！ 对于这样的实现方式，虽然说没有问题，但是代码冗长，写法难看(很容易被其它语言开发者鄙视)，于是乎，java8对这种场景做了语法糖优化，这种语法糖优化在java8中被称为lambda (此处简单介绍，向后阅读详细介绍)。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/97/7a/QLeHTK7f_o.png"></p> 
<p>lambda语法其实就是匿名实现了一个函数式接口：</p> 
<pre><code>
    public void testTheadRunnable1() {
        new Thread(() -&gt; System.out.println("Lambda 实现了一个Runnable函数式接口")).start();
        //等同于
        Runnable runnable = () -&gt; System.out.println("Lambda 实现了一个Runnable函数式接口");
        new Thread(runnable).start();
    }
复制代码</code></pre> 
<p>重点来了！！</p> 
<p>一个接口可以拥有多个抽象方法，如果拥有了多个抽象方法，那么它就不满足于计算机中函数"一个固定的一个程序段"的定义。</p> 
<p>基于编译语言和复杂度的问题上，为了满足语法糖的推导，于是乎java8中引入了</p> 
<p>@FunctionalInterface 注解标识一个函数式接口，该注解会在编译期对接口是否满足函数式接口进行检查：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/77/81/MLamC6Ex_o.png"></p> 
<p>所以，函数式接口的概念也并非从java8开始的，只不过为了方便lambda语法糖的推导，由是更加强调这个概念，并且给予规范。</p> 
<h3>函数式接口和lambda的使用</h3> 
<p>Lambda 表达式可以通过 <strong>匿名实现</strong> 和 <strong>方法引用</strong> 的语法糖进行匿名传递。</p> 
<h4>匿名实现</h4> 
<p>匿名实现，可以分为单行实现和多行实现。</p> 
<pre><code>//单行实现
new Thread(() -&gt; System.out.println("Lambda 实现了一个Runnable函数式接口")).start();
//多行实现
new Thread(() -&gt; {
  System.out.println("Lambda 实现了一个Runnable函数式接口");
  System.out.println("Lambda 实现了一个Runnable函数式接口");
  System.out.println("Lambda 实现了一个Runnable函数式接口");
}).start();
复制代码</code></pre> 
<p>在单行实现下，不需要方法体大括号，也不需要语句结束的";"号结尾。</p> 
<p>且如果匿名实现的是一个有返回值的函数式接口，会隐式的添加上 return语句。</p> 
<pre><code>@FunctionalInterface
public interface Supplier&lt;T&gt; {

    /**
     * Gets a result.
     *
     * @return a result
     */
    T get();
}
复制代码</code></pre> 
<pre><code>    public void testReturn() {
        Supplier&lt;Integer&gt; supplier1 = () -&gt; new Integer(666);
        Integer result1 = supplier1.get();
        //等同于
        Supplier&lt;Integer&gt; supplier2 = () -&gt; {return new Integer(999);};
        Integer result2 = supplier2.get();
    }
复制代码</code></pre> 
<p>无论是单行匿名实现或者是多行匿名实现，lambda表达式前面的() 括号则代表你要匿名实现的函数式接口的抽象方法的入参，如果是无参数抽象方法则是"()-&gt;",有参数则是"(参数)-&gt;"，单参数可被简化为 var -&gt; 的方式。 示例：</p> 
<blockquote> 
 <p>无参数示例</p> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8d/ee/XlYV6Hkx_o.png"></p> 
<p>对应</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/48/07/VluaUltd_o.png"></p> 
<blockquote> 
 <p>有参数示例</p> 
</blockquote> 
<pre><code>@FunctionalInterface
public interface Sum {
    int sum(int a, int b);
}
复制代码</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/dd/d5/vqqcmFNZ_o.png"></p> 
<blockquote> 
 <p>单参数</p> 
</blockquote> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9b/5c/UsCrJlk9_o.png"></p> 
<p>对应</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/9a/83/7cm5XCPd_o.png"></p> 
<h4>方法引用</h4> 
<p>可以通过方法引用来匿名实现一个函数式接口，语法</p> 
<pre><code>对象::方法  或  静态类::静态方法
复制代码</code></pre> 
<pre><code>    @FunctionalInterface
    public interface Requester {
        void request();
    }
    
    public void testRefVar() {
        //引用runMethod方法，匿名实现了executeMethod 形参的Requester函数式接口
        this.executeMethod(this::runMethod);
    }

    public void executeMethod(Requester requester) {
        requester.request();
    }

    public void runMethod() {
        System.out.println("请求中...");
        System.out.println("请求完成！");
    }
复制代码</code></pre> 
<p>被引用的方法需要和匿名实现的函数式接口的抽象方法具有相同的入参出参。</p> 
<pre><code>    @FunctionalInterface
    public interface Sum {
        int sum(int a, int b);
    }

    public void testRefVar() {
        //引用runMethod方法，匿名实现了executeMethod 形参的Sum函数式接口
        this.executeMethod(this::runMethod);
    }

    public void executeMethod(Sum sum) {
        int x = 6;
        int y = 9;
        sum.sum(x, y);
    }

    public int runMethod(int a, int b) {
        return a + b;
    }
复制代码</code></pre> 
<h3>函数式编程的思维提升 委托与异步编程</h3> 
<p>到此为止，我们需要思考一个问题，函数式接口能为我们带来哪些编程思维上提升呢？从我个人的理解上，可以总结为两点</p> 
<ol><li>委托</li><li>异步编程</li></ol> 
<p>委托：如其名意，在java中可以理解为，某个对象A将某个逻辑委托给调用其方法的B对象来实现。</p> 
<p>异步编程：这里的异步并非开启一个编程异步执行的意思，而是指你在现实编码方式的异步，指的是不必按照一连串代码的串行编码。在写某段逻辑触发的代码时，这段代码片段已经提前被写好了，还没有被执行，只是在需要的时候执行调用。</p> 
<p>举个例子，类似前端编程语言中常见的回调方法，B对象调用A对象的A1方法，并且在方法参数中传递了一个回调方法，A对象A1方法中在某种场景下执行了B对象传递的回调方法，这个场景在前端语言中非常常见。而在Java中语言编程过程中，其实也有常见的写法，类似设计模式中的观察者模式等。</p> 
<p>然而一个逻辑就要通过设计模式的方式来做，无疑有点大炮打小鸟的意味。而利用函数式接口，则可以快速清晰的实现，举例上述场景：</p> 
<pre><code>    public static class A {
        public void a1(Runnable call) {
            //do something
            System.out.println("只因泥太煤");
            if (Boolean.TRUE) {
                call.run();
            }
        }
    }

    public static class B {
        public void b1() {
            A a = new A();
            a.a1(() -&gt; System.out.println("小黑子真虾头"));
        }
    }
复制代码</code></pre> 
<p>在这个简单的例子当中，委托和异步编程体现在哪里呢？</p> 
<p>委托：A对象的a1方法将一个回调方法的实现委托给调用其的对象自己实现，A对象的a1方法中，仅有自己的逻辑，不包含调用其方法的其他方法的业务逻辑，职责分明。</p> 
<p>异步编程：回调方法由B对象已经提前写好了，在写这段代码时，这个回调方法并未被执行，而是A对象的a1调用时，才真正被执行。对于A对象和B对象来说，在编码上这无疑都是异步的。</p> 
<p>在Java8提供的一些开发工具类中，我们能很频繁的见到这种使用方式，相信大家在日常开发过程中肯定也是高频使用，举例我们在java8常用的Optional</p> 
<blockquote> 
 <p>Optional</p> 
</blockquote> 
<p>ifPresent方法，Optional只完成存在则执行的职责，具体的执行逻辑通过Consumer函数式接口参数委托给调用者自己实现。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/5e/c3/ekIzt4Jb_o.png"></p> 
<p>orElseGet方法,Optional只完成"获取和不存在则获取"的职责，将不存在的获取方式通过Supplier函数式接口参数委托给调用者自己实现。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fe/ae/s0vxm5mH_o.png"></p> 
<p>orElseThrow方法,Optional只完成"获取和不存在则抛出异常"的职责，将不存在需要抛出的异常通过Supplier函数式接口参数委托给调用者自己来生成。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b0/6f/VMP8QeEq_o.png"></p> 
<p>使用示例：</p> 
<pre><code>    public void testOptional(Object obj) {
        Optional&lt;Object&gt; objOptional = Optional.ofNullable(obj);
        //如果存在执行
        objOptional.ifPresent(o -&gt; System.out.println(o.toString()));
        //如果不存在调用supplier获取
        Object o = objOptional.orElseGet(Object::new);
        //如果不存在,调用supplier获取异常抛出
        Object o1 = objOptional.orElseThrow(() -&gt; new RuntimeException("空空如也"));
    }
复制代码</code></pre> 
<p>代码简洁干净，言简意骇，举个"反例":</p> 
<pre><code>    public void testOptional1(Object obj) {
        //如果存在执行
        if (obj != null) {
            System.out.println("666");
        }
        //如果不存在获取
        Object object = null;
        if (obj != null) {
            object = obj;
        } else {
            object = new Object();
        }
        //如果不存在,则抛出异常抛出
        Object object1 = null;
        if (obj != null) {
            object1 = obj;
        } else {
            throw new RuntimeException("空空如也");
        }
    }
复制代码</code></pre> 
<p>甚至，你还可以利用这些玩一些"花活"，我们经常在代码的碰到过同类方法调用时，如果被调用的方法是利用spring的aop来做代理实现的情况时，例如@Transactional 或 @Cacheable，往往会因为同类调用无法代理导致失效（虽然这种情况往往是因为自己层级职责划分错误导致）,一旦遭遇这种问题，大部分人的做法是，将方法拆到另一个类中或者手动从ioc容器中获取或者注入bean来完成代理。而在这里，我们其实通过函数式接口委托的方式，来做一个统一的代理类。</p> 
<p>示例:</p> 
<pre><code>@Component
public class TransactionalManager {
    @Transactional
    public void runTransaction(Runnable runnable){
        runnable.run();
    }
}
复制代码</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/d0/6a/CQJZqvUT_o.png"></p> 
<p>改为增加一个TransactionalManager</p> 
<pre><code>@Component
public class Test {
    @Autowired
    private TransactionalManager transactionalManager;
    
    public void a(){
        //代理失败,因为spring是通过aop代理实现的。
        this.b();
        //事务代理成功
        transactionalManager.runTransaction(this::b);
    }

    @Transactional
    public void b(){
        System.out.println("事务");
    }
}
复制代码</code></pre> 
<p>通过实现一个事务的Manager类，职责就是帮助完成事务代理，这样b方法就可以不用拆到别的类当中去了。</p> 
<p>题外话，如果跳出Java这个编程文化圈来看，如果是写过前端JavaScript的小伙伴, 其实对这种函数编程其实是如同吃饭喝水一样习惯了，因为前端js为了用户体验，渲染速度等，一定是经常使用异步的，而异步回调上经常也是通过传递函数实现的，写过js的同学一定使用过非常好用的东西：Promise， Promise可以很好的解决异步回调的问题，例如：</p> 
<pre><code> var promise = new Promise(function(resolve, reject){
        //异步
        setTimeout(function(){
            resolve('异步完成，执行回调');
        }, 2000);
    });
promise.then(res=&gt; console.log(res))

//输出'异步完成，执行回调'
复制代码</code></pre> 
<p>你不理解JavaScript其实也没关系，也不Promise工作原理，但是你从共通代码其实不难看出，其就是基于函数委托给Promise执行回调来工作的，不能的语言，其实思想上很多都是相通的。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0dff9bf628dee58c7d48d41d0e2c9345/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Navicat备份恢复数据表及表结构</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/308c8ea1fa1b781d329b8f2a01cade68/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">YUV数据格式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>