<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>小猫爪：S32K3学习笔记05-S32K3之ADC - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="小猫爪：S32K3学习笔记05-S32K3之ADC" />
<meta property="og:description" content="小猫爪：S32K3学习笔记05-S32K3之ADC 1 前言2 资源简介3 ADC功能详解3.1 ADC mux-mode channels3.2 ADC内部框架3.3 时钟源3.4 通道类型3.5 触发信号3.5.1 标准触发3.5.2 注入触发3.5.3 BCTU触发 3.6 校准和自检3.6.1 校准3.6.2 自检 3.7 模拟门狗3.8 DMA和中断3.9 转换时间的计算 4 使用注意事项4.1 CDR寄存器 5 MCAL配置待续。。。。。 1 前言 今天学习了一下S32K3的ADC模块，接下来做个总结。
2 资源简介 下表是S32K3各型号拥有的ADC模块。
下表是三个ADC模块拥有的体征：
可以看到对于ADC的通道有Precision channels,Standard channels,Special Internal channels,External channels之分，至于这些类型的通道都有什么不同，还有这个图上的信息有点问题，后面会详细说到。
表中还有一个BCTU trigger，这个就是一个硬件触发模块，可以通过配置BCTU去触发ADC转换，之后ADC转换的结果会传递到BCTU模块，一般在电力电子，电机控制应用中比较常见，后面会专抽一章来介绍BCTU。
3 ADC功能详解 3.1 ADC mux-mode channels 这个指的就是一个pad可能会对应多个ADC通道，可以通过DCM寄存器中每个通道对应的GPR位来设置。下图例举了几个例子：
所以说如果配置了一些PAD复用成AI后，还得观察一下这个PAD是否为ADC通道的默认引脚，如果不是的话，还得需要配置一下DCM寄存器。
3.2 ADC内部框架 下图是ADC模块的内部框架图。
乍一看上去巨复杂，但是要是仔细稍微那么一看，其实这个ADC模块也就是个纸老虎，非常简单。
说得简单点就是当ADC接收到触发信号后，就会开始启动转换，转换完成后就会生成转换结果，DMA请求信号以及中断信号，如果使能了看门狗功能，还会输出看门狗的信号。
说得复杂细致点，步骤如下：
当ADC接收到三种不同类型的触发器（BCTU、注入或正常）中的一种时，优先级多路复用器启动转换。根据触发器类型和自检得配置，被选择的通道输入被转换状态机（FSM）从空闲状态转换为转换状态。如果下一次要转换的通道为外部通道，那么转换在DSDR[DSD]配置的延迟后开始。转换开始后，转换控制块将保持内部电容网络CDAC保持相同的CTRi[INPSAMP]的时间。在比较阶段，CALBISTREG[RESN]定义了用于执行逐次逼近算法的步数。校准期间确定的误差校正值将添加到原始结果中。如果平均值被启用（MCR[AVGEN]=1），最多32个（通过MCR[AVGS]指定）转换结果被平均以获得后果。当转换完成且所有平均步骤均已完成时：
A. 转换完成信号置位。
B. 转换_数据[14:0]写入数据结果寄存器。
C. FSM状态机切换为完成状态。通道选择块中的下一个输入被选择，FSM状态机切换到转换状态，第二次转换开始。这将持续进行，直到所有选定的通道输入都已转换。如果启用了模拟看门狗，则将转换结果与配置的阈值进行比较。如果满足条件，可以触发中断。自检可以检查ADC的完整性，可以与正常转换交错进行，也可以作为独立检查。如果正在进行的转换被中止（通过将1写入MCR[ABORT]），或一组输入通道的转换被中止（通过将1写入MCR[ABORTCHAIN]），FSM将转换为空闲状态。如果MCR[ABORT]写1，则转换控制块停止当前转换；如果MCR[ABORTCHAIN]写1，则完成当前转换再中止转换。在这两种情况下，转换控制块的转换完成输出信号都会被置1。 3.3 时钟源 ADC模块最高可支持的时钟频率到达80MHz，如果选择的时钟源超过80MHz的话，那么就需要设置ADC时钟分频器系数，是最后的ADC时钟在80MHz以内。下图显示在各个时钟源区间的分频设置，其中MCR[ADCLKSEL]设置分频系数，AMSIO[17]使能高速转换模式。
3.4 通道类型 在一开始就说了由4种输入通道类型，分别是Precision channels,standard channels,special internal channels，那么这4种分别代表什么呢？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/484827e69f872a3075d16d712a7e44f6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-10-27T15:51:46+08:00" />
<meta property="article:modified_time" content="2021-10-27T15:51:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">小猫爪：S32K3学习笔记05-S32K3之ADC</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>小猫爪：S32K3学习笔记05-S32K3之ADC</h4> 
 <ul><li><a href="#1__1" rel="nofollow">1 前言</a></li><li><a href="#2__4" rel="nofollow">2 资源简介</a></li><li><a href="#3_ADC_13" rel="nofollow">3 ADC功能详解</a></li><li><ul><li><a href="#31_ADC_muxmode_channels_14" rel="nofollow">3.1 ADC mux-mode channels</a></li><li><a href="#32_ADC_18" rel="nofollow">3.2 ADC内部框架</a></li><li><a href="#33__41" rel="nofollow">3.3 时钟源</a></li><li><a href="#34__45" rel="nofollow">3.4 通道类型</a></li><li><a href="#35__59" rel="nofollow">3.5 触发信号</a></li><li><ul><li><a href="#351__61" rel="nofollow">3.5.1 标准触发</a></li><li><a href="#352__68" rel="nofollow">3.5.2 注入触发</a></li><li><a href="#353_BCTU_75" rel="nofollow">3.5.3 BCTU触发</a></li></ul> 
   </li><li><a href="#36__89" rel="nofollow">3.6 校准和自检</a></li><li><ul><li><a href="#361__90" rel="nofollow">3.6.1 校准</a></li><li><a href="#362__92" rel="nofollow">3.6.2 自检</a></li></ul> 
   </li><li><a href="#37__94" rel="nofollow">3.7 模拟门狗</a></li><li><a href="#38_DMA_98" rel="nofollow">3.8 DMA和中断</a></li><li><a href="#39__104" rel="nofollow">3.9 转换时间的计算</a></li></ul> 
  </li><li><a href="#4__131" rel="nofollow">4 使用注意事项</a></li><li><ul><li><a href="#41_CDR_132" rel="nofollow">4.1 CDR寄存器</a></li></ul> 
  </li><li><a href="#5_MCAL_143" rel="nofollow">5 MCAL配置</a></li><li><a href="#_146" rel="nofollow">待续。。。。。</a></li></ul> 
</div> 
<p></p> 
<h2><a id="1__1"></a>1 前言</h2> 
<p>  今天学习了一下S32K3的ADC模块，接下来做个总结。</p> 
<h2><a id="2__4"></a>2 资源简介</h2> 
<p>  下表是S32K3各型号拥有的ADC模块。<br> <img src="https://images2.imgbox.com/a4/21/y4xHOhIV_o.png" alt="在这里插入图片描述"><br>   下表是三个ADC模块拥有的体征：<br> <img src="https://images2.imgbox.com/c4/80/SDN6cWj5_o.png" alt="在这里插入图片描述"><br>   可以看到对于ADC的通道有Precision channels,Standard channels,Special Internal channels,External channels之分，至于这些类型的通道都有什么不同，还有这个图上的信息有点问题，后面会详细说到。</p> 
<p>  表中还有一个BCTU trigger，这个就是一个硬件触发模块，可以通过配置BCTU去触发ADC转换，之后ADC转换的结果会传递到BCTU模块，一般在电力电子，电机控制应用中比较常见，后面会专抽一章来介绍BCTU。</p> 
<h2><a id="3_ADC_13"></a>3 ADC功能详解</h2> 
<h3><a id="31_ADC_muxmode_channels_14"></a>3.1 ADC mux-mode channels</h3> 
<p>  这个指的就是一个pad可能会对应多个ADC通道，可以通过DCM寄存器中每个通道对应的GPR位来设置。下图例举了几个例子：<br> <img src="https://images2.imgbox.com/2a/85/RKHxVHcT_o.png" alt="在这里插入图片描述"><br>   所以说如果配置了一些PAD复用成AI后，还得观察一下这个PAD是否为ADC通道的默认引脚，如果不是的话，还得需要配置一下DCM寄存器。</p> 
<h3><a id="32_ADC_18"></a>3.2 ADC内部框架</h3> 
<p>  下图是ADC模块的内部框架图。<br> <img src="https://images2.imgbox.com/9a/bf/TcwKvMzk_o.png" alt="在这里插入图片描述"></p> 
<p>  乍一看上去巨复杂，但是要是仔细稍微那么一看，其实这个ADC模块也就是个纸老虎，非常简单。</p> 
<p>  说得简单点就是当ADC接收到触发信号后，就会开始启动转换，转换完成后就会生成转换结果，DMA请求信号以及中断信号，如果使能了看门狗功能，还会输出看门狗的信号。</p> 
<p>  说得复杂细致点，步骤如下：</p> 
<ol><li>当ADC接收到三种不同类型的触发器（BCTU、注入或正常）中的一种时，优先级多路复用器启动转换。</li><li>根据触发器类型和自检得配置，被选择的通道输入被转换</li><li>状态机（FSM）从空闲状态转换为转换状态。如果下一次要转换的通道为外部通道，那么转换在DSDR[DSD]配置的延迟后开始。</li><li>转换开始后，转换控制块将保持内部电容网络CDAC保持相同的CTRi[INPSAMP]的时间。</li><li>在比较阶段，CALBISTREG[RESN]定义了用于执行逐次逼近算法的步数。校准期间确定的误差校正值将添加到原始结果中。如果平均值被启用（MCR[AVGEN]=1），最多32个（通过MCR[AVGS]指定）转换结果被平均以获得后果。</li><li>当转换完成且所有平均步骤均已完成时：<br> A. 转换完成信号置位。<br> B. 转换_数据[14:0]写入数据结果寄存器。<br> C. FSM状态机切换为完成状态。</li><li>通道选择块中的下一个输入被选择，FSM状态机切换到转换状态，第二次转换开始。这将持续进行，直到所有选定的通道输入都已转换。</li><li>如果启用了模拟看门狗，则将转换结果与配置的阈值进行比较。如果满足条件，可以触发中断。</li><li>自检可以检查ADC的完整性，可以与正常转换交错进行，也可以作为独立检查。</li><li>如果正在进行的转换被中止（通过将1写入MCR[ABORT]），或一组输入通道的转换被中止（通过将1写入MCR[ABORTCHAIN]），FSM将转换为空闲状态。如果MCR[ABORT]写1，则转换控制块停止当前转换；如果MCR[ABORTCHAIN]写1，则完成当前转换再中止转换。在这两种情况下，转换控制块的转换完成输出信号都会被置1。</li></ol> 
<h3><a id="33__41"></a>3.3 时钟源</h3> 
<p>  ADC模块最高可支持的时钟频率到达80MHz，如果选择的时钟源超过80MHz的话，那么就需要设置ADC时钟分频器系数，是最后的ADC时钟在80MHz以内。下图显示在各个时钟源区间的分频设置，其中MCR[ADCLKSEL]设置分频系数，AMSIO[17]使能高速转换模式。<br> <img src="https://images2.imgbox.com/ac/ad/LHNm0S8Q_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="34__45"></a>3.4 通道类型</h3> 
<p>  在一开始就说了由4种输入通道类型，分别是Precision channels,standard channels,special internal channels，那么这4种分别代表什么呢？</p> 
<ol><li>Precision channels<br> 精确通道，转换结果分辨率能达到12bit。</li><li>Standard channels<br> 标准通道，转换结果分辨率能达到10bit。</li><li>Special internal channels<br>   这种就是通道的输入源在芯片内部，比如什么温度传感，REF等。在上面资源介绍中，表格上面显示有问题，其实真实情况应该是ADC0有5个，ADC1有4个，ADC2有4个。具体情况如下：<br> <img src="https://images2.imgbox.com/25/82/VFnBQoxb_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/ae/85/xpAlHTVU_o.png" alt="在这里插入图片描述"><br> 其中ANAMUX_OUT的输入源就是芯片内部的一些电压点，可以通过DCMRWF1[SUPPLY_MON_SEL]字段来配置。</li><li>External channels<br>   ADC提供三个外部解码信号，用于从外部模拟多路复用器的八个通道中选择一个通道。最多可以有四个这样的多路复用器用于连接32个外部通道。ADC根据选择用于转换的当前通道，自动设置解码信号以控制这些外部模拟多路复用器。</li></ol> 
<h3><a id="35__59"></a>3.5 触发信号</h3> 
<p>  从ADC工作流程来看，其实S32K3的ADC模块非常的纯粹，一旦有触发信号过来，ADC模块就开始安装原先的配置转换当前被使能的通道。所以想要实现一些复杂的转换完完全全取决于触发信号的产生。下面就来一一来看ADC模块的三大类型的触发信号，分别是标准触发，注入触发，BCTU触发。</p> 
<h4><a id="351__61"></a>3.5.1 标准触发</h4> 
<p>  标准触发指的就是传统意思上的ADC触发，就是由软件或者硬件来启动一次DMA转换，转换模式可以是单次转换模式和连续扫描模式，单次转换模式就是把所有使能的<strong>标准通道</strong>（由<strong>NCMR</strong>寄存器使能）转换完成后就自动停止转换，而连续扫描模式就是连续循环转换。</p> 
<p>  其中软件触发模式就是给<strong>MCR[NSTART]<strong>写1，而硬件触发就是通过</strong>TRGMUX模块</strong>来配置其他外设信号触发标准通道转换。</p> 
<p>  转换的顺序为Precision—&gt;standard—&gt;external，同类型通道则从小往大。当所有使能的标准通道转换完成后<strong>ECH</strong>中断置位。</p> 
<h4><a id="352__68"></a>3.5.2 注入触发</h4> 
<p>  注入触发指的就是当一次注入触发信号来了，ADC模块就会立即去转换使能的<strong>注入通道</strong>（由<strong>JCMR</strong>寄存器使能），如果当前ADC模块正在转换标准通道，那么此时ADC会中断转换并开始转换注入通道，等注入通道转换完成后再恢复标准通道的转换。流程示意图如下：<br> <img src="https://images2.imgbox.com/f5/12/v7LGULLM_o.png" alt="在这里插入图片描述"><br>   注入触发方式也是有软件触发和硬件触发两种，软件触发就是对<strong>MCR[JTRGEN]<strong>写1，而硬件触发就是通过</strong>TRGMUX模块</strong>来配置其他外设信号触发ADC注入通道转换。</p> 
<p>  不同类型通道的转换顺利同上，当使能的注入通道全部转换完成后，<strong>JECH</strong>中断置位。</p> 
<h4><a id="353_BCTU_75"></a>3.5.3 BCTU触发</h4> 
<p>  BCTU触发就是用外部模块BCTU发起信号去触发ADC模块。下图是两个模块之间的连接：<br> <img src="https://images2.imgbox.com/c4/53/yzIecFyJ_o.png" alt="在这里插入图片描述"><br>   其中BCTU发送给ADC触发信号<em>Tregger</em>和通道号<em>Channel</em>，而ADC模块则返回三个信号，分别是<em>Nextcmd</em>，<em>Endcov</em>和<em>data</em>, 其中<em>Nextcmd</em>表示ADC模块已经准备好接受下一次的触发信号了，<em>Endcov</em>表示当前转换完成，数据可用，至于<em>data</em>就是转换的结果数据。</p> 
<p>  其中BCTU有两种模式去控制ADC，分别是BCTU Trigger mode和BCTU Control mode。</p> 
<ol><li>BCTU Trigger mode<br> 这个模式其实就是增强型注入触发，处于该种模式下，当ADC模块接收到来自BCTU的触发信号时，ADC模块就会终止当前转换，立即响应BCTU的触发，原理和注入触发是一致的。也就是说三者的优先级关系为BCTU触发&gt;注入触发&gt;标准触发。所以当ADC处于响应BCTU的状态时，注入触发信号是无效的。</li><li>BCTU Control mode<br> 这种模式就比较简单了，就是BCTU一家独大，完全接手ADC的控制权，此时只有BCTU可以启动转换，另外两种触发信号无效。</li></ol> 
<p>  另外值得注意的点就是BCTU触发信号一定在ADC校准成功后才能发出，不然会导致ADC校准失败，BCTU触发转换完成后，<strong>EOBCTU</strong>中断置位。</p> 
<h3><a id="36__89"></a>3.6 校准和自检</h3> 
<h4><a id="361__90"></a>3.6.1 校准</h4> 
<p>  在介绍BCTU触发时，讲到了校准，校准就是ADC模块会在受控条件下对已知参考电压进行采样和转换，以确定偏移、增益和电容失配的校正值（校准值）。校准期间必须禁止一切触发信号。</p> 
<h4><a id="362__92"></a>3.6.2 自检</h4> 
<p>  对应安全应用，定期验证操作是否正确非常重要。因为S32K3是可以达到ASIL-D的MCU，为此，ADC具有自检功能。启用自检后，ADC会自动检查其组件，并在发现错误时标记错误。这里的自检功能非常复杂，在这里就不多介绍了，感兴趣的可以自行参考RM手册的Analog-to-Digital Converter (ADC)–&gt;Functional description-&gt;Calibration and self-test章节。</p> 
<h3><a id="37__94"></a>3.7 模拟门狗</h3> 
<p>  模拟看门狗就是可以设置两个值<strong>THRH</strong>和<strong>THRL</strong>，当满足以下条件的一种时会产生中断信号，非常简单。<br> <img src="https://images2.imgbox.com/da/f3/NTX1SNfo_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="38_DMA_98"></a>3.8 DMA和中断</h3> 
<p>  任何通道转换完成后都可以产生一个DMA请求信号，一旦启用，片上DMA控制器可以在每个通道转换后获取DMA请求并搬运结果。 可以在DMA Request Enable For Precision Inputs (DMAR0),DMA Request Enable For Standard Inputs (DMAR1), DMA Request Enable For Precision Inputs (DMAR0)寄存器中设置相应的屏蔽字段来激活和屏蔽相应通道的DMA。DMA屏蔽寄存器必须在开始任何转换之前进行编程。</p> 
<p>  整个ADC模块有以下几种中断信号：<br> <img src="https://images2.imgbox.com/bb/6d/2e3QFpPs_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="39__104"></a>3.9 转换时间的计算</h3> 
<p>  转换时间当然是由ADC时钟来确定的了，至于ADC的时钟源配置在前面已经介绍过了，接下来就直接说计算方式了。</p> 
<ol><li>预采样时间（PST，等于ST并延时1个AD_clk周期，一般预采样不使能，所以一般等于0）</li><li>采样时间（ST，可配置，最小值为8个AD_clk周期）</li><li>比较时间（CT，固定，每bit 4个AD_clk周期）</li><li>数据处理时间（DP，固定，2个AD_clk周期）</li><li>触发处理时间（TPT，固定，1个AD_clk周期）</li></ol> 
<p>  所以，总转换时间=（[(PST+ST+CT+DP)*通道数]+TPT)*AD_clk周期。</p> 
<p>  举个例子：</p> 
<ol><li>转换时钟频率（AD_clk）为80 MHz（T=12.5 ns）</li><li>ADC分辨率12位+1位用于特殊电容器（CS）</li><li>3个通道在NCMRx寄存器中编程（通道数=3）</li><li>未使能预采样（PST，0个周期）</li><li>采样时间保持默认（ST，22个周期）</li><li>转换时间（CT，每位4个周期）</li><li>数据处理时间固定（DP，2个周期）</li><li>触发处理时间是固定的（TPT，1个周期）</li></ol> 
<p>  所以，总转换时间=[（ 0 + 22 +（4*13）+2）*3 ] + 1 = 229个周期~=2.862μs。</p> 
<h2><a id="4__131"></a>4 使用注意事项</h2> 
<h3><a id="41_CDR_132"></a>4.1 CDR寄存器</h3> 
<p>  CDR寄存器是用来存储ADC转换结果的寄存器，每一个通道都对应一个CDR，其中低16位用来存储转换结果，但是只有其中15位有效，可以配置为是左对齐(即**CDR[15:1]<strong>有效)还是右对齐(即</strong>CDR[14:0]**有效)。</p> 
<p>  另外不管你配置的ADC分别是多少位，最后CDR中存储的转换结果数据都是15bit，这个时候就需要通过软件移位来得到有效数据了，当然了这些SDK驱动都会帮做了。</p> 
<p>  说到这里我们不得不提一下ADC的分辨率问题，虽然在ADC介绍中，提到ADC模块支持8/10/12/14bit分辨率，举个例子，如果说配置ADC模块为14bit分辨率，其实并不是说最后转换结果的精度为14bit，这里的意思指的是ADC模块在转换的时候会将最后结果比较到第14bit，至于结果是达不到14bit精度的，ADC的precision channel最高支持的精度为12bit，Standard channel最高支持的精度为10bit。</p> 
<h2><a id="5_MCAL_143"></a>5 MCAL配置</h2> 
<p>待续。。。。。。</p> 
<h2><a id="_146"></a>待续。。。。。</h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/892830a368536aaecfae487455821bdb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">毛星云opencv之5.5傅里叶变换原理介绍（关于图像高频--代表细节和低频--代表轮廓）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4d2890ea28d54e486389c28a04a7e1ff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">字符数组入门（Java）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>