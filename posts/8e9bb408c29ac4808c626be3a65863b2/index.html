<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>oracle和mysql语法区别大吗 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="oracle和mysql语法区别大吗" />
<meta property="og:description" content="一、数据类型 1. Number类型 MySQL中是没有Number类型的，但有int/decimal 类型，Oracle中的Number(5,1)对应MySQL中的decimal(5,1)，Number(5) 对应 int(5)。MySQL中的数字型类型比较多，分的也比较细，还有tinyint、smallint、mediumint、bigint等类型 2. Varchar2(n)类型 MySQL中对应Oracle Varchar2(n)类型的替代类型是varchar(n)类型。 3. Date 类型 MySQL 中的日期时间类型有Date、Time、Datetime等类型，MySQL中Date类型仅表示日期(年-月-日)，Time类型仅表示时间（时:分:秒），而Datetime类型表示日期时间(年-月-日 时:分:秒)，Oracle中的Date类型和MySQL中的Datetime类型一致。 二、函数 1. length(str)函数 Oracle中的length(str)是获取字符串长度的函数，MySQL 中对应的函数为char_length(str)。 2. sys_guid()函数 Oracle中可通过sys_guid()函数是生成随机序列，MySQL通过UUID()生成随机序列。 3. 时间格式化函数 将时间转换为字符串型时间 MySQL date_format(NOW(),’%Y-%m-%d’) 对应Oracle的 Oracle中的 to_char(sysdate, ‘YYYY-MM-DD’); 将字符串型时间转换为时间类型 MySQL str_to_date(‘2019-01-01′,’%Y-%m-%d’) 对应Oracle中的 to_date(‘2019-01-01’, ‘YYYY-MM-DD’); 包括时分秒的函数转换：DATE_FORMAT(NOW(),’%Y-%m-%d %H:%i:%s’)，str_to_date(‘2019-01-01′,’%Y-%m-%d %H:%i:%s’)。 4. 条件函数（nvl()、nvl2()、decode()） nvl(tab.columnName, 0)：如果tab.columnName值为空，则返回值取0，否则取tab.columnName；对应的MySQL函数为：ifnull(tab.columnName, 0)。 nvl2(expr1,expr2,expr3)：如果expr1不为null，则返回expr2，否则返回expr3；对应的MySQL函数为：if(expr1,expr2,expr3)。 DECODE(value, val1, val2, val3)：如果value等于val1，则返回val2，否则返回val3；MySQL可用IF函数表示：if(value=val1, val2, val3)； DECODE(value, if1, val1, if2,val2,…,ifn, valn, val)：如果value等于if1，则返回val1，如果value等于if2，则返回value2…如果value等于ifn，则返回valn，否则返回val；MySQL对于这种判断可以通过case when then else end;l来判断，即：case when value=if1 then val1 when value=if2 then val2,,,when value=ifn then valn else val end; 5." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8e9bb408c29ac4808c626be3a65863b2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-01T12:55:04+08:00" />
<meta property="article:modified_time" content="2023-06-01T12:55:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">oracle和mysql语法区别大吗</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>一、数据类型</strong> <strong>1. Number类型</strong> MySQL中是没有Number类型的，但有int/decimal 类型，Oracle中的Number(5,1)对应MySQL中的decimal(5,1)，Number(5) 对应 int(5)。MySQL中的数字型类型比较多，分的也比较细，还有tinyint、smallint、mediumint、bigint等类型 <strong>2. Varchar2(n)类型</strong> MySQL中对应Oracle Varchar2(n)类型的替代类型是varchar(n)类型。 <strong>3. Date 类型</strong> MySQL 中的日期时间类型有Date、Time、Datetime等类型，MySQL中Date类型仅表示日期(年-月-日)，Time类型仅表示时间（时:分:秒），而Datetime类型表示日期时间(年-月-日 时:分:秒)，Oracle中的Date类型和MySQL中的Datetime类型一致。 <strong>二、函数</strong> <strong> 1. length(str)函数</strong> Oracle中的length(str)是获取字符串长度的函数，MySQL 中对应的函数为char_length(str)。 <strong>2. sys_guid()函数</strong> Oracle中可通过sys_guid()函数是生成随机序列，MySQL通过UUID()生成随机序列。 <strong>3. 时间格式化函数</strong> 将时间转换为字符串型时间 MySQL date_format(NOW(),’%Y-%m-%d’) 对应Oracle的 Oracle中的 to_char(sysdate, ‘YYYY-MM-DD’); 将字符串型时间转换为时间类型 MySQL str_to_date(‘2019-01-01′,’%Y-%m-%d’) 对应Oracle中的 to_date(‘2019-01-01’, ‘YYYY-MM-DD’); 包括时分秒的函数转换：DATE_FORMAT(NOW(),’%Y-%m-%d %H:%i:%s’)，str_to_date(‘2019-01-01′,’%Y-%m-%d %H:%i:%s’)。 <strong>4. 条件函数（nvl()、nvl2()、decode()）</strong> nvl(tab.columnName, 0)：如果tab.columnName值为空，则返回值取0，否则取tab.columnName；对应的MySQL函数为：ifnull(tab.columnName, 0)。 nvl2(expr1,expr2,expr3)：如果expr1不为null，则返回expr2，否则返回expr3；对应的MySQL函数为：if(expr1,expr2,expr3)。 DECODE(value, val1, val2, val3)：如果value等于val1，则返回val2，否则返回val3；MySQL可用IF函数表示：if(value=val1, val2, val3)； DECODE(value, if1, val1, if2,val2,…,ifn, valn, val)：如果value等于if1，则返回val1，如果value等于if2，则返回value2…如果value等于ifn，则返回valn，否则返回val；MySQL对于这种判断可以通过case when then else end;l来判断，即：case when value=if1 then val1 when value=if2 then val2,,,when value=ifn then valn else val end; <strong>5. trunc()函数</strong> TRUNC(12.123)：返回整数(12)；MySQL对应的函数：truncate(12.123, 0)； TRUNC(12.123, 2)：返回值保留2为小数(12.12)；MySQL对应的函数：truncate(12.123, 2)； TRUNC(SYSDATE)：返回值为(2019-07-26 00:00:00)；MySQL对应的为cast(now() as datetime)：返回值为(2019-07-26 14:11:38)； MySQL的cast函数语法为：CAST(xxx AS 类型) （可用类型为：二进制,同带binary前缀的效果:BINARY；字符型,可带参数:CHAR()；日期:DATE；时间:TIME；日期时间型: DATETIME；浮点数: DECIMAL；整数:SIGNED；无符号整数:UNSIGNED） <strong>6. to_char() to_number()</strong> to_char(123)：将数字123转换为字符串123；MySQL对应的函数为CAST(123 AS CHAR(3))； to_number(‘123’)：将字符串数字123转换为数字类型；MySQL对应的函数为cast(‘123’ as SIGNED)； <strong>7. sysdate 当前时间</strong> sysdate：返回当前日期+时间； MySQL对应的函数为 now()； <strong>三、其他</strong> <strong>1. 引号</strong> MySQL可识别双引号和单引号，Oracle只能识别单引号。 <strong> 2. 字符串连接符 || </strong> Oracle 可用’||’来连接字符串，但MySQL不支持’||’连接，MySQL可通过concat()函数链接字符串。 Oracle的 a.studentname||’【’||a.studentno||’】’ 相当于 MySQL的 concat(a.studentname, ‘【’, a.studentno, ‘】’) <strong>3. ROWNUM</strong> Oracle可通过rownum获取前n条记录，MySQL通过limit来获取前n条记录，但二者的写法略有不同，在Oracle中rownum作为where条件的一部分，而MySQL中limit不是where条件的一部分。</p> 
<pre><code>-- rownum语法如下：
SELECT * FROM XJ_STUDENT WHERE ROWNUM = 1; -- 查询第一条数据
SELECT * FROM XJ_STUDENT WHERE ROWNUM &lt;= 10; -- 获取前10条数据
-- 但rownum不支持查询后几条或第n(n&gt;1)条数据，例如以下sql是不支持的
SELECT * FROM XJ_STUDENT WHERE ROWNUM &gt; 2;
SELECT * FROM XJ_STUDENT WHERE ROWNUM = 3;
-- limit 语法如下：
SELECT * from fw_department limit 3; -- 查询前3条数据
SELECT * from fw_department limit 2, 4; -- 从第2(序号从0开始)条开始，查4条记录</code></pre> 
<p>复制</p> 
<p><strong>4. 空数据排序(nulls first 和nulls last)</strong></p> 
<pre><code>-- null值排在最前
SELECT * FROM FW_DEPARTMENT A ORDER BY A.REMARK DESC NULLS FIRST
-- null值排在最后
SELECT * FROM FW_DEPARTMENT A ORDER BY A.REMARK DESC NULLS LAST

-- MySQL 可通过IF和ISNULL函数达到相同的效果
-- null值排在最后
select * from FW_DEPARTMENT A order by IF(ISNULL(A.REMARK),1,0),A.REMARK desc
-- null值排在最前
select * from FW_DEPARTMENT A order by IF(ISNULL(A.REMARK),0,1),A.REMARK desc</code></pre> 
<p>复制</p> 
<p><strong>5. 表(左/右)关联(+)</strong> Oracle左连接,右连接可以使用(+)来实现. MySQL只能使用left join ,right join等关键字。</p> 
<pre><code>-- Oracle 左关联
select * from taba, tabb where taba.id = tabb.id(+);
-- Oracle 右关联
select * from taba, tabb where taba.id(+) = tabb.id;
-- MySQL 左关联
select * from taba left join tabb on taba.id=tabb.id;
-- MySQL 右关联
select * from taba right join tabb on taba.id=tabb.id;</code></pre> 
<p>复制</p> 
<p><strong>6. 删除语法</strong> MySQL的删除语法没有Oracle那么随意，例如下面的sql在Oracle中可以执行，但在MySQL中就不可以。</p> 
<pre><code>-- Oracle 可执行，但MySQL中不能执行
DELETE FROM FW_DEPARTMENT A WHERE A.DEPID = '111';
DELETE FW_DEPARTMENT WHERE DEPID = '111';
-- MySQL中删除语句格式如下：
DELETE FROM FW_DEPARTMENT WHERE DEPID = '111';</code></pre> 
<p>复制</p> 
<p><strong>7. 递归查询(start with connect by prior)</strong> MySQL不支持(start with connect by prior)的这种递归查询，但可以通过自定义函数来实现。</p> 
<pre><code>-- Oracle 递归查询 查询部门ID为‘1111’的所有子部门（包含自身）
SELECT *
FROM FW_DEPARTMENT
START WITH DEPID='1111'
CONNECT BY PRIOR DEPID = PARENTDEPID;
-- Oracle 递归查询 查询部门ID为‘1111’的所有父部门（包含自身）
SELECT *
FROM FW_DEPARTMENT
START WITH DEPID='1111'
CONNECT BY PRIOR PARENTDEPID = DEPID;

-- MySQL 先创建fun_getDepIDList函数，用于查询部门ID字符串
CREATE FUNCTION fun_getDepIDList(rootId VARCHAR(32))
RETURNS VARCHAR(6000)
BEGIN 
	DECLARE pTemp VARCHAR(6000);
	DECLARE cTemp VARCHAR(6000);
	SET pTemp='$';
	SET cTemp=rootId;
	WHILE cTemp is not null DO
		set pTemp=CONCAT(pTemp,',',cTemp);
		SELECT GROUP_CONCAT(depid) INTO cTemp from fw_department
		WHERE FIND_IN_SET(PARENTDEPID,cTemp)&gt;0;
	END WHILE;
	RETURN pTemp;
END;

-- 查询部门ID为‘1111’的所有子部门（包含自己）
select * from fw_department
where FIND_IN_SET(DEPID, fun_getDepIDList('1111'));

-- 查询部门ID为‘1111’的所有父部门(包含自己)
select * from fw_department
where FIND_IN_SET('1111', fun_getDepIDList(DEPID));</code></pre> 
<p>复制</p> 
<p><strong>8. merge into</strong> MySQL不支持（merge into），但提供的replace into 和on duplicate key update可实现相似的功能。</p> 
<pre><code>-- Oracle merge into (有则修改，无则新增)
MERGE INTO TMPDEPTAB A
USING (SELECT '1111' DEPID, '哈哈' DEPNAME FROM DUAL) B
ON (A.DEPID = B.DEPID)
WHEN MATCHED THEN 
	UPDATE SET A.DEPNAME = B.DEPNAME
WHEN NOT MATCHED THEN 
	INSERT(DEPID, DEPNAME) VALUES(B.DEPID, B.DEPNAME);

-- MySQL replace into (特点：1、先删后增； 2、插入/更新的表必须有主键或唯一索引；
-- 3、未修改/新增的数据项，如果必填，则必须有默认值)
-- 1、由于是先删后增，所以需要满足以下2个条件之一：
--      1.要么必填项有默认值； 
--      2.要么插入/更新时为没有默认值的必填项赋值， 否则新增时会报错。
-- 2、表中需要有主键或唯一索引，否则下面语句如果执行多次，表中会出现重复数据。
replace into fw_department(DEPID,PARENTDEPID,DEPNO,DEPNAME) 
values('1111111', '1234','123', '哈哈');

-- MySQL on duplicate key update (特点：1、插入/更新的表必须有主键或唯一索引；
-- 2、未修改/新增的数据项，如果必填，则必须有默认值)
insert into fw_department(depid,parentdepid,depno,depname)
select '1111111' depid, '123' parentdepid, 'e12' depno, '哈哈哈哈' depname
from fw_department
on duplicate key 
update parentdepid = values(parentdepid),
	depno=values(depno),
	depname=values(depname);</code></pre> 
<p>复制</p> 
<p><strong>9. with</strong></p> 
<p>Oracle 中可用with来构建一个临时表，但MySQL不支持with，对应临时表，MySQL可通过小括号的方式来处理，但构建的临时表必须设置临时表名。</p> 
<pre><code>-- Oracle with使用
WITH TMPTAB AS (
	SELECT A.DEPID FROM FW_DEPARTMENT A
)
SELECT DEPID
FROM TMPTAB

-- MySQL 构建临时表使用(此处必须给括号中的临时表设置表名)
select b.depid
from (
	select depid
	from fw_department
) b</code></pre> 
<p>复制</p> 
<p><strong>总结：</strong></p> 
<p>本文主要描述了Oracle和MySQL的语法区别，主要包括类型，函数和其他三部分。当然它们之间的语法区别不仅仅是这些，此处就不再描述了，有兴趣的可以自己查查。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1445f01a386fbc2b34ecb24fb69031d6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">项目遇到的实际需求: java从信任所有证书到对server证书进行校验</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c3b03d0a3acb270bb6e6fe555c532cc3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">int *p[] 与 int (*p)[]</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>