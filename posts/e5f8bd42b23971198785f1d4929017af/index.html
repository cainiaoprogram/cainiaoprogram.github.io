<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>git 回退操作 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="git 回退操作" />
<meta property="og:description" content="git在版本管理方面非常优秀，提供了一个分布式管理结构，在提交和撤销回退方面也很方便。
在git的概念里，在本地有一个工作区，本地还有一个仓库，远程也有一个仓库。通常来说在工作区进行工作，工作完成后，将需要保存的内容交给git管理：
git add file git是直接对整个文件进行管理，将文件交给git后，需要提交到本地仓库中：
git commit -m &#34;message&#34; 提交到本地仓库，git便建立起了一个追踪变化的树，其中一个分支会有自己的记录，当前所在的变化会有一个HEAD来标识，每提交一次，HEAD都会指向最新的变化，此时若想后退，只需要将HEAD指针回退到相应版本即可。
git 提供了三个撤销回退的概念：
reset：git reset 能将当前工作区加入git管理的文件全部清空： 此时git已经追踪到test.txt的变化，等待提交本地仓库，如果发现出错了，可以进行撤销：
撤销后，不删除文件本身的变化，只是将它从git管理中去除。
revert：git revert 纸面意思就是反转，即将提交到本地仓库的内容进行反转，它会自动产生一次新的提交，可以用-n参数来指定不产生新的提交。 假如提交到本地仓库是错误的，此时需要将错误改正过来，可以使用revert，进行反转。
反转即是将添加的删除掉，删除的添加回来。
rebase：git rebase 对每次的提交进行处理，例如将多次提交合并为一次提交，在git revert时，将会产生一个提交，可以用rebase将这两次提交合并为一次提交： 使用-i进入交互式界面，rebase时，可以指定版本号，注意，如果指定的是版本号，那么rebase是不包括这个版本的，也可以用head指针来指定，例如指向前两次提交：HEAD~2，此时进入交互式界面，从上向下列着每次的提交记录，由旧到新的顺序排列。下面有很多选项：p(pick) 挑选哪一个作为基础提交，s(squash)将选中的提交合并到pick的提交上。所以，我可以pick最早的一个提交，即第一行的提交，squash其他提交，合并为一个提交。保存退出，然后再执行git rebase --continue，将提交的信息进行修改。若不修改，rebase将会保存之前所有的提交信息，并按由新到旧的顺序排列。保存后 退出，查看记录，已经成功合并。
但某些情况下，事实比上面的情况要复杂，例如与同事合作，git记录信息如下：
可以看到文件的改变和每一次的提交是对应的，方便显示效果。
第一次和第四次是要保留的提交，中间的二三次是需要撤回的提交。
如果不需要保存原始的提交记录，那么直接进行rebase &#43; revert操作。 由于第四次提交不在我要操作的范围内，所有rebase的时候保持pick就好，这样rebase还是会保留这一次提交，将第三次合并到第二次上，所以要squash第三次提交，也可以用fixup，直接去除第三次的提交信息。
有一点需要注意的是，如果第四次改动与要反转的提交改动冲突，需要手动解决冲突。示例如下：
将需要撤回的提交利用rebase合并为一次提交，然后对这个提交进行revert即可。
若需要保存完整的原始提交记录，可以采用下面的办法： 先在当前分支基础上切出一个分支test-bak来操作，对bak分支进行rebase操作，然后将原分支test合并到当前分支，由于git识别修改相同自动合并，所以实际文件内容并没有变化，只是test-bak分支多了test分支上的提交记录，即完整的四次提交记录。示意图如下：
然后将原分支test删除，将test-bak分支改名为test，然后和远程的test分支建立联系即可。如果觉得合并后的分支提交记录仍然不整齐，可以将不需要的rebase掉。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e5f8bd42b23971198785f1d4929017af/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-02-05T20:52:11+08:00" />
<meta property="article:modified_time" content="2020-02-05T20:52:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">git 回退操作</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>git在版本管理方面非常优秀，提供了一个分布式管理结构，在提交和撤销回退方面也很方便。</p> 
<p>在git的概念里，在本地有一个工作区，本地还有一个仓库，远程也有一个仓库。通常来说在工作区进行工作，工作完成后，将需要保存的内容交给git管理：</p> 
<pre class="has"><code class="language-bash">git add file</code></pre> 
<p>git是直接对整个文件进行管理，将文件交给git后，需要提交到本地仓库中：</p> 
<pre class="has"><code class="language-bash">git commit -m "message"</code></pre> 
<p>提交到本地仓库，git便建立起了一个追踪变化的树，其中一个分支会有自己的记录，当前所在的变化会有一个<strong>HEAD</strong>来标识，每提交一次，HEAD都会指向最新的变化，此时若想后退，只需要将HEAD指针回退到相应版本即可。</p> 
<p>git 提供了三个撤销回退的概念：</p> 
<ul><li>reset：git reset 能将当前工作区加入git管理的文件全部清空：</li></ul> 
<p><img alt="" class="has" height="637" src="https://images2.imgbox.com/b7/0b/ODqE0ako_o.png" width="776"></p> 
<p>此时git已经追踪到test.txt的变化，等待提交本地仓库，如果发现出错了，可以进行撤销：</p> 
<p><img alt="" class="has" height="406" src="https://images2.imgbox.com/b8/10/4N1lEAdO_o.png" width="794"></p> 
<p>撤销后，不删除文件本身的变化，只是将它从git管理中去除。</p> 
<ul><li>revert：git revert 纸面意思就是反转，即将提交到本地仓库的内容进行反转，它会自动产生一次新的提交，可以用-n参数来指定不产生新的提交。</li></ul> 
<p><img alt="" class="has" height="686" src="https://images2.imgbox.com/15/bc/QsWgYjep_o.png" width="770"></p> 
<p>假如提交到本地仓库是错误的，此时需要将错误改正过来，可以使用revert，进行反转。</p> 
<p><img alt="" class="has" height="553" src="https://images2.imgbox.com/fa/e0/fl4WHvKF_o.gif" width="800"></p> 
<p>反转即是将添加的删除掉，删除的添加回来。</p> 
<ul><li>rebase：git rebase 对每次的提交进行处理，例如将多次提交合并为一次提交，在git revert时，将会产生一个提交，可以用rebase将这两次提交合并为一次提交：</li></ul> 
<p><img alt="" class="has" height="553" src="https://images2.imgbox.com/75/e3/eCfeDSSY_o.gif" width="800"></p> 
<p>使用-i进入交互式界面，rebase时，可以指定版本号，<strong>注意，</strong>如果指定的是版本号，那么rebase是不包括这个版本的，也可以用head指针来指定，例如指向前两次提交：<strong>HEAD~2</strong>，此时进入交互式界面，从上向下列着每次的提交记录，由旧到新的顺序排列。下面有很多选项：p(pick) 挑选哪一个作为基础提交，s(squash)将选中的提交合并到pick的提交上。所以，我可以pick最早的一个提交，即第一行的提交，squash其他提交，合并为一个提交。保存退出，然后再执行git rebase --continue，将提交的信息进行修改。若不修改，rebase将会保存之前所有的提交信息，并按由新到旧的顺序排列。保存后 退出，查看记录，已经成功合并。</p> 
<hr> 
<p>但某些情况下，事实比上面的情况要复杂，例如与同事合作，git记录信息如下：</p> 
<p><img alt="" class="has" height="553" src="https://images2.imgbox.com/9f/39/YLVBk6Fc_o.gif" width="800"></p> 
<p>可以看到文件的改变和每一次的提交是对应的，方便显示效果。</p> 
<p>第一次和第四次是要保留的提交，中间的二三次是需要撤回的提交。</p> 
<ul><li>如果不需要保存原始的提交记录，那么直接进行rebase + revert操作。</li></ul> 
<p>由于第四次提交不在我要操作的范围内，所有rebase的时候保持pick就好，这样rebase还是会保留这一次提交，将第三次合并到第二次上，所以要squash第三次提交，也可以用fixup，直接去除第三次的提交信息。</p> 
<p>有一点需要注意的是，如果第四次改动与要反转的提交改动冲突，需要手动解决冲突。示例如下：</p> 
<p><img alt="" class="has" height="553" src="https://images2.imgbox.com/f7/3d/idXM1I1i_o.gif" width="800"></p> 
<p>将需要撤回的提交利用rebase合并为一次提交，然后对这个提交进行revert即可。</p> 
<ul><li>若需要保存完整的原始提交记录，可以采用下面的办法：</li></ul> 
<p><img alt="" class="has" src="https://images2.imgbox.com/ad/78/rEgHKsKI_o.gif"></p> 
<p>先在当前分支基础上切出一个分支<strong>test-bak</strong>来操作，对bak分支进行rebase操作，然后将原分支<strong>test</strong>合并到当前分支，由于git识别修改相同自动合并，所以实际文件内容并没有变化，只是<strong>test-bak</strong>分支多了test分支上的提交记录，即完整的四次提交记录。示意图如下：</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/27/d3/EmAVJaFc_o.png"></p> 
<p>然后将原分支test删除，将test-bak分支改名为test，然后和远程的test分支建立联系即可。如果觉得合并后的分支提交记录仍然不整齐，可以将不需要的rebase掉。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/272e12d27d9b524e725852edb7d15096/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">第三章第十五题（游戏：彩票）(Game: lottery)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ddbccb050aa27813ce4a7cb9a72fcb3d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第三章第十七题（游戏：剪刀、石头、布）(Game: scissor, rock, paper)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>