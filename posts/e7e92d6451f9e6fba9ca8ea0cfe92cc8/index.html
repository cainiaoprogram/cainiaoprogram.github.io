<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>android蓝牙包,Android Bluetooth蓝牙技术初体验 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="android蓝牙包,Android Bluetooth蓝牙技术初体验" />
<meta property="og:description" content="一：Bluetooth包简介
Android平台提供了一个android.bluetooth的包，里面实现蓝牙设备之间通信的蓝牙API。总共有8个类，常用的四个类如下:
BluetoothAdapter类
代表了一个本地的蓝牙适配器。它是所有蓝牙交互的入口点。利用它你可以发现其他蓝牙设备，查询绑定了的设备，使用已知的MAC地址实例化一个蓝牙设备和建立一个BluetoothServerSocket(作为服务器端)来监听来自其他设备的连接。
BluetoothDevice类
代表了一个远端的蓝牙设备，使用它请求远端蓝牙设备连接或者获取远端蓝牙设备的名称、地址、种类和绑定状态(其信息是封装在BluetoothSocket中)。
BluetoothSocket类
代表了一个蓝牙套接字的接口(类似于TCP中的套接字)，它是应用程序通过输入、输出流与其他蓝牙设备通信的连接点。
BlueboothServerSocket类
代表打开服务连接来监听可能到来的连接请求(属于server端)，为了连接两个蓝牙设备必须有一个设备作为服务器打开一个服务套接字。当远端设备发起连接连接请求的时候，并且已经连接到了的时候，BlueboothServerSocket类将会返回一个BluetoothSocket。
二：常用类的使用
BluetoothAdapter：蓝牙适配器
cancelDiscovery()取消探索，当我们正在搜索设备的时候调用这个方法将不再继续搜索
disable()关闭蓝牙
enable()打开蓝牙，这个方法打开蓝牙不会弹出提示，更多的时候我们需要问下用户是否打开，以下两行代码同样是打开蓝牙，但会提示用户：
Intentenabler = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);
startActivity(enabler);
getAddress()获取本地蓝牙地址
getDefaultAdapter()获取默认BluetoothAdapter，实际上，也只有这一种方法获取BluetoothAdapter
getName()获取本地蓝牙名称
getRemoteDevice(String address)根据蓝牙地址获取远程蓝牙设备
getState()获取本地蓝牙适配器当前状态
isDiscovering()判断当前是否正在查找设备，是则返回true
isEnabled()判断蓝牙是否打开，已打开返回true，否则返回false
listenUsingRfcommWithServiceRecord(String name,UUID uuid)根据名称，UUID创建并返回BluetoothServerSocket，这是创建BluetoothSocket服务器端的第一步
startDiscovery()开始搜索，这是搜索的第一步
BluetoothDevice：远程蓝牙设备
createRfcommSocketToServiceRecord(UUIDuuid)根据UUID创建并返回一个BluetoothSocket，这个方法也是我们获取BluetoothDevice
的目的——创建BluetoothSocket
这个类其他的方法，如getAddress()、getName()等，同BluetoothAdapter。
BluetoothSocket：客户端
//这个类一共有6个方法
close()关闭
connect()连接
isConnected()判断是否连接
getInptuStream()获取输入流
getOutputStream()获取输出流
getRemoteDevice()获取BluetoothSocket指定连接的远程蓝牙设备
BluetoothServerSocket：服务端
//这个类一共有4个方法
accept()
accept(int timeout)
close()关闭
getChannel()返回这个套接字绑定的通道
两者的区别在于后面的方法指定了过时时间，需要注意的是，执行这两个方法的时候，直到接收到了客户端的请求(或是过期之后)，都会阻塞线程，应该放在新线程里运行。还有一点需要注意的是，这两个方法都返回一个BluetoothSocket，最后的连接也是服务器端与客户端的两个BluetoothSocket的连接
三：数据传输
蓝牙数据传输——服务器端
1、获得BluetoothAdapter。
2、通过BluetoothAdapter.listenUsingRfcommWithServiceRecord(name,UUID uuid)方法创建BluetoothServerSocket对象。
3、通过luetoothServerSocket.accept()方法返回一个BluetoothSocket对象。由于该方法处于阻塞状态，需要开启线程来处理。
4、通过BluetoothSocket.getInputStream()和BluetoothSocket.getOutputStream()方法获得读写数据的InputStream和OutputStream对象。
5、通过InputStream.read()方法来读数据。通过OutputStream.write()方法来写数据。
蓝牙数据传输——客户端
1、获得BluetoothAdapter。
2、通过BluetoothAdapter.getRemoteDevice(String address)获得指定地址的BluetoothDevice对象。
3、通过BluetoothDevice.createRfcommSocketToServiceRecord (UUID uuid)方法创建BluetoothSocket对象。
4、通过BluetoothSocket.connect()方法来连接蓝牙设备。
5、通过BluetoothSocket.getInputStream()和BluetoothSocket.getOutputStream()方法获得读写数据的InputStream和OutputStream对象。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e7e92d6451f9e6fba9ca8ea0cfe92cc8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-27T08:58:11+08:00" />
<meta property="article:modified_time" content="2021-05-27T08:58:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">android蓝牙包,Android Bluetooth蓝牙技术初体验</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>一：Bluetooth包简介</p> 
 <p>Android平台提供了一个android.bluetooth的包，里面实现蓝牙设备之间通信的蓝牙API。总共有8个类，常用的四个类如下:</p> 
 <p>BluetoothAdapter类</p> 
 <p>代表了一个本地的蓝牙适配器。它是所有蓝牙交互的入口点。利用它你可以发现其他蓝牙设备，查询绑定了的设备，使用已知的MAC地址实例化一个蓝牙设备和建立一个BluetoothServerSocket(作为服务器端)来监听来自其他设备的连接。</p> 
 <p>BluetoothDevice类</p> 
 <p>代表了一个远端的蓝牙设备，使用它请求远端蓝牙设备连接或者获取远端蓝牙设备的名称、地址、种类和绑定状态(其信息是封装在BluetoothSocket中)。</p> 
 <p>BluetoothSocket类</p> 
 <p>代表了一个蓝牙套接字的接口(类似于TCP中的套接字)，它是应用程序通过输入、输出流与其他蓝牙设备通信的连接点。</p> 
 <p>BlueboothServerSocket类</p> 
 <p>代表打开服务连接来监听可能到来的连接请求(属于server端)，为了连接两个蓝牙设备必须有一个设备作为服务器打开一个服务套接字。当远端设备发起连接连接请求的时候，并且已经连接到了的时候，BlueboothServerSocket类将会返回一个BluetoothSocket。</p> 
 <p>二：常用类的使用</p> 
 <p>BluetoothAdapter：蓝牙适配器</p> 
 <p>cancelDiscovery()取消探索，当我们正在搜索设备的时候调用这个方法将不再继续搜索</p> 
 <p>disable()关闭蓝牙</p> 
 <p>enable()打开蓝牙，这个方法打开蓝牙不会弹出提示，更多的时候我们需要问下用户是否打开，以下两行代码同样是打开蓝牙，但会提示用户：</p> 
 <p>Intentenabler = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);</p> 
 <p>startActivity(enabler);</p> 
 <p>getAddress()获取本地蓝牙地址</p> 
 <p>getDefaultAdapter()获取默认BluetoothAdapter，实际上，也只有这一种方法获取BluetoothAdapter</p> 
 <p>getName()获取本地蓝牙名称</p> 
 <p>getRemoteDevice(String address)根据蓝牙地址获取远程蓝牙设备</p> 
 <p>getState()获取本地蓝牙适配器当前状态</p> 
 <p>isDiscovering()判断当前是否正在查找设备，是则返回true</p> 
 <p>isEnabled()判断蓝牙是否打开，已打开返回true，否则返回false</p> 
 <p>listenUsingRfcommWithServiceRecord(String name,UUID uuid)根据名称，UUID创建并返回BluetoothServerSocket，这是创建BluetoothSocket服务器端的第一步</p> 
 <p>startDiscovery()开始搜索，这是搜索的第一步</p> 
 <p>BluetoothDevice：远程蓝牙设备</p> 
 <p>createRfcommSocketToServiceRecord(UUIDuuid)根据UUID创建并返回一个BluetoothSocket，这个方法也是我们获取BluetoothDevice</p> 
 <p>的目的——创建BluetoothSocket</p> 
 <p>这个类其他的方法，如getAddress()、getName()等，同BluetoothAdapter。</p> 
 <p>BluetoothSocket：客户端</p> 
 <p>//这个类一共有6个方法</p> 
 <p>close()关闭</p> 
 <p>connect()连接</p> 
 <p>isConnected()判断是否连接</p> 
 <p>getInptuStream()获取输入流</p> 
 <p>getOutputStream()获取输出流</p> 
 <p>getRemoteDevice()获取BluetoothSocket指定连接的远程蓝牙设备</p> 
 <p>BluetoothServerSocket：服务端</p> 
 <p>//这个类一共有4个方法</p> 
 <p>accept()</p> 
 <p>accept(int timeout)</p> 
 <p>close()关闭</p> 
 <p>getChannel()返回这个套接字绑定的通道</p> 
 <p>两者的区别在于后面的方法指定了过时时间，需要注意的是，执行这两个方法的时候，直到接收到了客户端的请求(或是过期之后)，都会阻塞线程，应该放在新线程里运行。还有一点需要注意的是，这两个方法都返回一个BluetoothSocket，最后的连接也是服务器端与客户端的两个BluetoothSocket的连接</p> 
 <p>三：数据传输</p> 
 <p>蓝牙数据传输——服务器端</p> 
 <p>1、获得BluetoothAdapter。</p> 
 <p>2、通过BluetoothAdapter.listenUsingRfcommWithServiceRecord(name,UUID uuid)方法创建BluetoothServerSocket对象。</p> 
 <p>3、通过luetoothServerSocket.accept()方法返回一个BluetoothSocket对象。由于该方法处于阻塞状态，需要开启线程来处理。</p> 
 <p>4、通过BluetoothSocket.getInputStream()和BluetoothSocket.getOutputStream()方法获得读写数据的InputStream和OutputStream对象。</p> 
 <p>5、通过InputStream.read()方法来读数据。通过OutputStream.write()方法来写数据。</p> 
 <p>蓝牙数据传输——客户端</p> 
 <p>1、获得BluetoothAdapter。</p> 
 <p>2、通过BluetoothAdapter.getRemoteDevice(String address)获得指定地址的BluetoothDevice对象。</p> 
 <p>3、通过BluetoothDevice.createRfcommSocketToServiceRecord (UUID uuid)方法创建BluetoothSocket对象。</p> 
 <p>4、通过BluetoothSocket.connect()方法来连接蓝牙设备。</p> 
 <p>5、通过BluetoothSocket.getInputStream()和BluetoothSocket.getOutputStream()方法获得读写数据的InputStream和OutputStream对象。</p> 
 <p>6、通过InputStream.read()方法来读数据。通过OutputStream.write()方法来写数据。</p> 
 <p>四：Tip</p> 
 <p>UUID</p> 
 <p>// UUID：全局唯一标识符，格式为：8-4-4-4-12</p> 
 <p>// 两个蓝牙设备进行连接需要使用同一个UUID</p> 
 <p>以上所述是小编给大家分享的Android Bluetooth蓝牙技术初体验的相关内容，下篇将给大家介绍Android Bluetooth蓝牙技术使用流程详解，感兴趣的朋友可以点击了解详情。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/cc8700ae42be8023241ad6eae4c8455c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">android 检查是否安装成功,android开发中,判断是否安装了qq</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7dfb7283598510073b7de8b76a4230ea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">sqlite删除一条记录android,android  – 在SQLite表中检索最后一条记录(再次)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>