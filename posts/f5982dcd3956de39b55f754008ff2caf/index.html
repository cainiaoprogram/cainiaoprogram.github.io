<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>GRE VPN 通用路由封装协议 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="GRE VPN 通用路由封装协议" />
<meta property="og:description" content="GRE VPN GRE Generic Routing Encapsulation，通用路由封装
提供了一种协议的报文封装在另一种协议报文的机制，是一种隧道封装技术；
GRE的优点
1. 支持组播和动态路由协议(多种协议) 2. 基于IP层工作，是一种三层VPN封装技术 3. 配置简单，部署容易 GRE的缺点
1. 点到点隧道 2. 没有安全性可言，不提供加密 3. 不能分隔地址空间 4. 部署复杂连接关系时代价巨大 GRE的IP协议号：47
GRE载荷协议：0x0800：表示上层协议为IPv4
乘客协议(passenger)：(IPv4/IPv6/MPLS)乘客，货物，携带的上层数据；
封装协议：(GRE)货车的车厢，用于装载货物的载体；
运输协议：(IPv4)：负责传输协议，比如货车车头，在传输过程当中，只检测此部分，不会检测乘客协议
GRE VPN路由宣告注意事项：使用动态路由协议宣告接口时千万不能宣告公网接口
会出现递归死循环，当配置了GRE并宣告了公网路由时，会从隧道接口(Tunnel)同时学习到对端的公网路由和对端的隧道路由，这时，如果本局域网访问对端PC，根据本端的PC的IP地址查询路由表，出接口为本端Tunnel接口，进入并执行GRE封装，对封装后的公网IP地址再次查询本端路由表，这一查看本端的公网IP地址的出接口还是Tunnel接口，则又进入了Tunnel口，解封装了，出来之后再次根据第一次的本局域网私有IP地址查询路由表，则再次进入Tunnel接口封装公网IP地址，出来后再次根据公网IP地址查询路由表，无限循环，根本出不去，也称为：递归死循环；
GRE VPN隧道口虚假状态问题：只要有到达隧道目标的路由，隧道口的协议字段即可Up；
但是如果对端或者去往对端设备的路由不存在或者故障(不可达)，隧道口是感知不到，还是Up状态；
解决办法：开启GRE的Keeplive，用于检测隧道对端是否可达； Keeplive缺省情况下未开启；
可以只在一端开启周期性发送Keeplive报文即可，对端会回显响应KeepliveReply报文；
如果只在一端开启的话，另一端则无法进行主动检测，只是在配合本端的检测而已；
Keeplive报文默认周期性5s发送，重传3次如果对端未回应，则认为此隧道Down掉；
关于Tunnel接口的IP地址配置
此接口地址可随意配置，不会影响GRE隧道的建立；
在封装GRE隧道时，会直接将原始数据的二层直接干掉，使用本地公网接口的二层MAC地址进行发送，当对端进行解封装后，就直接展现了三层数据(类似P2P链路)无关乎二层通讯，因此，通过GRE隧道，即使Tunnel接口的IP地址与对端Tunnel接口的IP地址不在相同网段，也是可以通讯的，也可以建立OSPF邻居和互访以及学习路由；
拓展补充：
在OSPF的P2P链路上，双端IP地址不在同网段时，是可以建立Full邻居并可以学习到路由以及可以互访的；
在OSPF的广播链路上，修改ospf network-type p2p时，可以建立Full邻居和学习路由，但是不能互访；
因为，在ping对端设备时，ARP会发送广播FFFF帧，对端收到后判断不是找自己的，则不会做出响应，无法通讯；
虽然修改了ospf链路类型，但是底层仍然是以太网链路，依然需要二层MAC通讯；
[R1]interface tunnel 0/0/0 //创建隧道口 最大支持512个隧道口 范围0~511 Tunnel-protocol gre //指定协议 华为默认无协议，思科默认GRE协议 Source 12.0.0.2 //指定隧道源 Destination 13.0.0.3 //指定隧道目标 Ip address x.x.x.x //Tunnel接口的IP，随意 Gre key dazhen //设置关键字key 类似密码，如果两端不相同，则丢弃 display interface tunnel 0/0/0 //查看隧道接口状态 Keepalive period 5 retry-times 3 //开启keepalive检测避免数据黑洞 ip route-static x." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f5982dcd3956de39b55f754008ff2caf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-22T20:45:32+08:00" />
<meta property="article:modified_time" content="2023-09-22T20:45:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">GRE VPN 通用路由封装协议</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="GRE_VPN_0"></a>GRE VPN</h4> 
<p><strong>GRE Generic Routing Encapsulation，通用路由封装</strong></p> 
<p>提供了一种协议的报文封装在另一种协议报文的机制，是一种隧道封装技术；</p> 
<p><strong>GRE的优点</strong></p> 
<pre><code>1. 支持组播和动态路由协议(多种协议)
2. 基于IP层工作，是一种三层VPN封装技术
3. 配置简单，部署容易
</code></pre> 
<p><strong>GRE的缺点</strong></p> 
<pre><code>1. 点到点隧道
2. 没有安全性可言，不提供加密
3. 不能分隔地址空间
4. 部署复杂连接关系时代价巨大
</code></pre> 
<p>GRE的IP协议号：<code>47</code><br> GRE载荷协议：<code>0x0800</code>：表示上层协议为<code>IPv4</code><br> <strong>乘客协议(passenger)：</strong>(IPv4/IPv6/MPLS)乘客，货物，携带的上层数据；<br> <strong>封装协议：</strong>(GRE)货车的车厢，用于装载货物的载体；<br> <strong>运输协议：</strong>(IPv4)：负责传输协议，比如货车车头，在传输过程当中，只检测此部分，不会检测乘客协议</p> 
<p><strong>GRE VPN</strong>路由宣告注意事项：<code>使用动态路由协议宣告接口时千万不能宣告公网接口</code></p> 
<p>会出现递归死循环，当配置了GRE并宣告了公网路由时，会从隧道接口(Tunnel)同时学习到对端的公网路由和对端的隧道路由，这时，如果本局域网访问对端PC，根据本端的PC的IP地址查询路由表，出接口为本端Tunnel接口，进入并执行GRE封装，对封装后的公网IP地址再次查询本端路由表，这一查看本端的公网IP地址的出接口还是Tunnel接口，则又进入了Tunnel口，解封装了，出来之后再次根据第一次的本局域网私有IP地址查询路由表，则再次进入Tunnel接口封装公网IP地址，出来后再次根据公网IP地址查询路由表，无限循环，根本出不去，也称为：递归死循环；</p> 
<p><strong>GRE VPN隧道口虚假状态问题</strong>：只要有到达隧道目标的路由，隧道口的协议字段即可Up；<br> 但是如果对端或者去往对端设备的路由不存在或者故障(不可达)，隧道口是感知不到，还是Up状态；<br> <strong>解决办法</strong>：开启GRE的Keeplive，用于检测隧道对端是否可达； Keeplive缺省情况下未开启；<br> 可以只在一端开启周期性发送Keeplive报文即可，对端会回显响应KeepliveReply报文；<br> 如果只在一端开启的话，另一端则无法进行主动检测，只是在配合本端的检测而已；<br> Keeplive报文<code>默认周期性5s</code>发送，<code>重传3次</code>如果对端未回应，则认为此隧道Down掉；</p> 
<p><strong>关于Tunnel接口的IP地址配置</strong><br> 此接口地址可随意配置，不会影响GRE隧道的建立；</p> 
<p>在封装GRE隧道时，会直接将原始数据的二层直接干掉，使用本地公网接口的二层MAC地址进行发送，当对端进行解封装后，就直接展现了三层数据(类似P2P链路)无关乎二层通讯，因此，通过GRE隧道，即使Tunnel接口的IP地址与对端Tunnel接口的IP地址不在相同网段，也是可以通讯的，也可以建立OSPF邻居和互访以及学习路由；</p> 
<p><strong>拓展补充：</strong><br> 在OSPF的P2P链路上，双端IP地址不在同网段时，是可以建立Full邻居并可以学习到路由以及可以互访的；</p> 
<p>在OSPF的广播链路上，修改ospf network-type p2p时，可以建立Full邻居和学习路由，但是不能互访；<br> 因为，在ping对端设备时，ARP会发送广播FFFF帧，对端收到后判断不是找自己的，则不会做出响应，无法通讯；<br> 虽然修改了ospf链路类型，但是底层仍然是以太网链路，<code>依然需要二层MAC通讯</code>；</p> 
<pre><code class="prism language-shell"><span class="token punctuation">[</span>R1<span class="token punctuation">]</span>interface tunnel <span class="token number">0</span>/0/0      	 //创建隧道口  最大支持512个隧道口   范围0~511 
	Tunnel-protocol gre     	     //指定协议   华为默认无协议，思科默认GRE协议
	Source <span class="token number">12.0</span>.0.2                 //指定隧道源
	Destination <span class="token number">13.0</span>.0.3            //指定隧道目标
	Ip address x.x.x.x              //Tunnel接口的IP，随意
	Gre key  dazhen                 //设置关键字key  类似密码，如果两端不相同，则丢弃
  display interface tunnel <span class="token number">0</span>/0/0   //查看隧道接口状态
Keepalive period <span class="token number">5</span> retry-times <span class="token number">3</span>   //开启keepalive检测避免数据黑洞
<span class="token function">ip</span> route-static x.x.x.x <span class="token number">0</span> tunnel0/0/0   //配置静态路由,或者使用动态路由协议
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/803ac4f041a75250d1a7e1344ad542b7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringMVC(三) -- HandlerMapping</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c385c60b060265caa1dcd782b1d87c53/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Anaconda3安装好后jupyter、pip、python以及ipython不是内部或外部命令，也不是可运行的程序或批处理文件”的问题解决</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>