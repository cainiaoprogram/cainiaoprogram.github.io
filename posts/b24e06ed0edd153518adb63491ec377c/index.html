<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[C语言学习]----函数递归（超详细！！！） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[C语言学习]----函数递归（超详细！！！）" />
<meta property="og:description" content="本篇介绍的是C语言函数递归的详细知识
程序的艺术来源于生活
目录
7. 函数递归
7.1递归是什么
7.2 递归的两个必要条件
7.2.1练习1（详细讲解）
7.2.2练习2（详细讲解）
7.3 递归与迭代
7.3.1练习3（详细讲解）
7.3.2 练习4（详细讲解）
7.4练习3,4中出现的问题
7. 函数递归 7.1递归是什么 程序调用自身的编程技巧称为递归
（函数自己调用自己）
递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解
递归策略
只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。
递归的主要思想在于：把大事化小
例（史上最简单的递归）：
#include&lt;stdio.h&gt; int main() { printf(&#34;Hello World\n&#34;); main(); } 先一直打印 Hello World，最终程序挂掉
7.2 递归的两个必要条件 存在限制条件，当满足这个限制条件的时候，递归便不再继续。每次递归调用之后越来越接近这个限制条件 7.2.1练习1（详细讲解） 接受一个整型值（无符号），按照顺序打印它的每一位。
例如：
输入：1234，输出 1 2 3 4
我们的第一想法是先让
1234%10 = 4 1234/10=123 123%10=3 123/10=12 12%10=2 12/10=1 1%10=1 1/10=0 这样能够得到数字的每一位，然后我们再打印出来
#include&lt;stdio.h&gt; int main() { unsigned int num = 0; scanf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b24e06ed0edd153518adb63491ec377c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-22T18:58:50+08:00" />
<meta property="article:modified_time" content="2022-08-22T18:58:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[C语言学习]----函数递归（超详细！！！）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p style="text-align:center;"><span style="color:#511b78;"><strong>本篇介绍的是C语言函数递归的详细知识</strong></span></p> 
 <p style="text-align:center;"></p> 
 <p style="text-align:center;"><img alt="" height="815" src="https://images2.imgbox.com/59/88/JeDzslwZ_o.png" width="1200"></p> 
 <p></p> 
 <p style="text-align:center;"><span style="color:#38d8f0;"><strong>程序的艺术来源于生活</strong></span></p> 
</blockquote> 
<p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="7.%20%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92-toc" style="margin-left:0px;"><a href="#7.%20%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92" rel="nofollow">7. 函数递归</a></p> 
<p id="7.1%E9%80%92%E5%BD%92%E6%98%AF%E4%BB%80%E4%B9%88-toc" style="margin-left:40px;"><a href="#7.1%E9%80%92%E5%BD%92%E6%98%AF%E4%BB%80%E4%B9%88" rel="nofollow">7.1递归是什么</a></p> 
<p id="%C2%A07.2%20%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6-toc" style="margin-left:40px;"><a href="#%C2%A07.2%20%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6" rel="nofollow">7.2 递归的两个必要条件</a></p> 
<p id="7.2.1%E7%BB%83%E4%B9%A01-toc" style="margin-left:80px;"><a href="#7.2.1%E7%BB%83%E4%B9%A01" rel="nofollow">7.2.1练习1（详细讲解）</a></p> 
<p id="7.2.2%E7%BB%83%E4%B9%A02-toc" style="margin-left:80px;"><a href="#7.2.2%E7%BB%83%E4%B9%A02" rel="nofollow">7.2.2练习2（详细讲解）</a></p> 
<p id="7.3%20%E9%80%92%E5%BD%92%E4%B8%8E%E8%BF%AD%E4%BB%A3-toc" style="margin-left:40px;"><a href="#7.3%20%E9%80%92%E5%BD%92%E4%B8%8E%E8%BF%AD%E4%BB%A3" rel="nofollow">7.3 递归与迭代</a></p> 
<p id="%C2%A07.3.1%E7%BB%83%E4%B9%A03-toc" style="margin-left:80px;"><a href="#%C2%A07.3.1%E7%BB%83%E4%B9%A03" rel="nofollow"> 7.3.1练习3（详细讲解）</a></p> 
<p id="7.3.2%20%E7%BB%83%E4%B9%A04-toc" style="margin-left:80px;"><a href="#7.3.2%20%E7%BB%83%E4%B9%A04" rel="nofollow">7.3.2 练习4（详细讲解）</a></p> 
<p id="7.4%E7%BB%83%E4%B9%A03%2C4%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98-toc" style="margin-left:40px;"><a href="#7.4%E7%BB%83%E4%B9%A03%2C4%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98" rel="nofollow">7.4练习3,4中出现的问题</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="7.%20%E5%87%BD%E6%95%B0%E9%80%92%E5%BD%92">7.<span style="color:#fe2c24;"><span style="background-color:#f9eda6;"> 函数递归</span></span></h2> 
<p></p> 
<h3 id="7.1%E9%80%92%E5%BD%92%E6%98%AF%E4%BB%80%E4%B9%88">7.1<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">递归是什么</span></span></h3> 
<blockquote> 
 <p><strong>程序调用自身的编程技巧称为递归</strong></p> 
 <p><strong>（<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">函数自己调用自己</span></span>）</strong></p> 
 <p><br><strong>递归做为一种算法在程序设计语言中广泛应用。 一个过程或函数在其定义或说明中有直接或间接调用自身的一种方法，它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解</strong></p> 
 <p></p> 
 <p><strong>递归策略</strong></p> 
 <p><strong>只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。</strong></p> 
 <p><br><strong>递归的主要思想在于：<span style="color:#fe2c24;">把大事化小</span></strong></p> 
</blockquote> 
<p><strong>例（史上最简单的递归）：</strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int main()
{
	printf("Hello World\n");
	main();
}</code></pre> 
<p><strong>先一直打印 Hello World，最终程序挂掉</strong></p> 
<h3 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="1077" src="https://images2.imgbox.com/84/ac/oE420pWk_o.png" width="1200"></h3> 
<h3 id="%C2%A07.2%20%E9%80%92%E5%BD%92%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><strong>7.2 <span style="color:#fe2c24;"><span style="background-color:#f9eda6;">递归的两个必要条件</span></span></strong></h3> 
<blockquote> 
 <ul><li><span style="color:#fe2c24;"><strong>存在限制条件，当满足这个限制条件的时候，递归便不再继续。</strong></span></li><li><span style="color:#fe2c24;"><strong>每次递归调用之后越来越接近这个限制条件</strong></span></li></ul> 
</blockquote> 
<h4 id="7.2.1%E7%BB%83%E4%B9%A01"><strong>7.2.1<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">练习1（详细讲解）</span></span></strong></h4> 
<blockquote> 
 <p><br><strong>接受一个整型值（无符号），按照顺序打印它的每一位。<br> 例如：<br> 输入：1234，输出 1 2 3 4</strong><br>  </p> 
</blockquote> 
<p><strong>我们的第一想法是先让</strong></p> 
<pre><code class="language-cpp">	1234%10 = 4
	1234/10=123
	123%10=3
	123/10=12
	12%10=2
	12/10=1
	1%10=1
	1/10=0</code></pre> 
<p><strong>这样能够得到数字的每一位，然后我们再打印出来</strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int main()
{
	unsigned int num = 0;
	scanf("%u", &amp;num);
	while (num)
	{
		printf("%d ", num % 10);
		num = num / 10;
	}
	return 0;
}</code></pre> 
<p class="img-center"><img alt="" height="99" src="https://images2.imgbox.com/a4/55/HOu4B6e7_o.png" width="176"></p> 
<p><span style="color:#fe2c24;"><strong>程序一进行我们发现输出的结果与题目中的不同，需要我们用递归来进行</strong></span></p> 
<p><strong>递归的思想是将大事化小</strong></p> 
<p><strong>我们定义一个print（）函数，它的功能是按照顺序打印num的每一位</strong></p> 
<blockquote> 
 <p><strong>打印1234的每一位：print（1234）</strong></p> 
 <p><strong>打印1234的每一位，我们<span style="color:#fe2c24;">可以先打印123的每一位再打印4</span></strong></p> 
 <p><strong>打印123的每一位：我们<span style="color:#fe2c24;">可以先打印12的每一位print（12）再打印3 </span></strong></p> 
 <p><strong>打印12的每一位：我们<span style="color:#fe2c24;">可以先打印1的每一位print（1）再打印2 </span></strong></p> 
 <p><strong>最后输出打印1 2 3 4</strong></p> 
 <p></p> 
 <p><strong>程序：</strong></p> 
 <p><strong>print(1234)<br> print(123) 4<br> print(12) 3 4<br> print(1) 2 3 4<br> 最终输出：1 2 3 4</strong></p> 
</blockquote> 
<p class="img-center"><img alt="" height="373" src="https://images2.imgbox.com/d2/a0/nVDUUfB6_o.png" width="380"></p> 
<p></p> 
<p></p> 
<blockquote> 
 <p><strong>当<span style="color:#fe2c24;">num&lt;10</span>的时候我们只需要直接打印就行</strong></p> 
 <p><strong>当<span style="color:#fe2c24;">num&gt;=10</span>.我们就需要分着打印 </strong></p> 
</blockquote> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/c8/36/fZyGQzpD_o.png" width="1104"></p> 
<p></p> 
<p><span style="color:#fe2c24;"><strong>代码实现：</strong></span></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
void print(unsigned int n)
{
	if (n &lt; 10)//限制条件
		printf("%d ", n);
	else
	{
		print(n / 10);//每次递归调用之后越来越接近这个限制条件
		printf("%d ", n%10);
	}
}
int main()
{
	unsigned int num = 0;
	scanf("%u", &amp;num);
	print(num);
	return 0;
}
</code></pre> 
<p class="img-center"><img alt="" height="94" src="https://images2.imgbox.com/25/5f/TdeEULDR_o.png" width="116"></p> 
<p><br><strong>当然也有更简单不冗余的写法：</strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
void print(unsigned int n)
{
	if (n &gt; 9)限制条件
	{
		print(n / 10);每次递归调用之后越来越接近这个限制条件
	}
	printf("%d ", n % 10);
}
int main()
{
	unsigned int num = 0;
	scanf("%u", &amp;num);
	print(num);
	return 0;
}
</code></pre> 
<h4 id="7.2.2%E7%BB%83%E4%B9%A02"><span style="color:#0d0016;">7.2.<strong>2</strong></span><strong><span style="color:#fe2c24;"><span style="background-color:#f9eda6;">练习2（详细讲解）</span></span></strong></h4> 
<blockquote> 
 <p><strong>编写函数(<span style="color:#fe2c24;">不允许创建临时变量</span>)，求字符串的长度</strong></p> 
</blockquote> 
<p><strong><span style="background-color:#f9eda6;">铺垫（编写函数(</span><span style="color:#fe2c24;"><span style="background-color:#f9eda6;">允许创建临时变量</span></span><span style="background-color:#f9eda6;">)，求字符串的长度）：</span></strong></p> 
<p><strong>我们有一个专门求字符串长度的库函数：strlen</strong></p> 
<p><img alt="" height="384" src="https://images2.imgbox.com/2e/b5/hjffzbHH_o.png" width="1200"></p> 
<p><strong> 首先我们先创建一个字符数组</strong></p> 
<pre><code class="language-cpp">char arr[] = "abc";
</code></pre> 
<p><strong>再用strlen</strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
#include&lt;string.h&gt;
int main()
{
	char arr[] = "abc";
	int len = strlen(arr);//传递的首元素地址
	printf("%d", len);
	return 0;
}</code></pre> 
<p><span style="color:#fe2c24;"><strong>这题是让我们创建一个函数my_strlen，<span style="background-color:#f9eda6;">模仿写一个strlen函数</span></strong></span></p> 
<p><img alt="" height="320" src="https://images2.imgbox.com/7f/b3/PVpPfvML_o.png" width="703"></p> 
<p><strong><span style="color:#fe2c24;">非递归方式：</span></strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int my_strlen(char* str)
{
	int count = 0;
	while (*str != '\0')
	{
		count++;
		str++;
	}
	return count;
}
int main()
{
	char arr[] = "abc";
	int len = my_strlen(arr);
	printf("%d", len);
	return 0;
}</code></pre> 
<p><strong><span style="color:#fe2c24;"><span style="background-color:#f9eda6;"> 编写函数(不允许创建临时变量)，求字符串的长度（递归方式）：</span></span></strong></p> 
<p><strong>如果第一个字符不是'\0'，说明字符串里面至少包含一个字符</strong></p> 
<blockquote> 
 <p><strong>所以当第一个元素不是'\0'的话</strong></p> 
 <p><strong>求my_strlen("abc")就可以看成求1+my_strlen("bc")的长度</strong></p> 
 <p><strong>求1+my_strlen("bc")的长度就可以看成 求1+1+my_strlen("c")的长度</strong></p> 
 <p><strong>求1+1+my_strlen("c")的长度就可以看成 求1+1+1+my_strlen(" ")的长度</strong></p> 
 <p><strong>最后算出来等于3</strong></p> 
</blockquote> 
<p><img alt="" height="1086" src="https://images2.imgbox.com/11/ae/l67HCGjr_o.png" width="1200"></p> 
<p><strong><span style="color:#fe2c24;"> 代码实现：</span></strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int my_strlen(char* str)
{
	if (*str != '\0')
		return 1 + my_strlen(str + 1);//传递下一个字符的地址
	else
		return 0;
}
int main()
{
	char arr[] = "abc";
	int len = my_strlen(arr);
	printf("%d", len);
	return 0;
}</code></pre> 
<h3 id="7.3%20%E9%80%92%E5%BD%92%E4%B8%8E%E8%BF%AD%E4%BB%A3">7.3 <span style="color:#fe2c24;"><strong><span style="background-color:#f9eda6;">递归与迭代</span></strong></span></h3> 
<h4 id="%C2%A07.3.1%E7%BB%83%E4%B9%A03"><strong> 7.3.1<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">练习3（详细讲解）</span></span></strong></h4> 
<blockquote> 
 <p><strong>求n的阶乘。（<span style="color:#fe2c24;">不考虑溢出</span>）</strong></p> 
</blockquote> 
<p></p> 
<p><span style="color:#fe2c24;"><span style="background-color:#f9eda6;">递归：</span></span></p> 
<p><img alt="" height="565" src="https://images2.imgbox.com/5c/3e/NejI4mpG_o.png" width="556"></p> 
<p></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int Fac(int n)
{
	if (n &lt;= 1)
		return 1;
	else
		return n * Fac(n - 1);
}
int main()
{
	int n = 0;
	scanf("%d",&amp;n);
	printf("%d",Fac(n));
	return 0;
}</code></pre> 
<p><span style="color:#fe2c24;"><strong>但当我们输入大的数字时，递归会算不出结果</strong></span></p> 
<p><img alt="" height="284" src="https://images2.imgbox.com/75/22/egwg7pVl_o.png" width="648"></p> 
<p><strong>所以这道题最好用非递归的方式(<span style="color:#fe2c24;"><span style="background-color:#f9eda6;">迭代</span></span>)计算：<br><span style="color:#fe2c24;"><span style="background-color:#f9eda6;">（循环是一种迭代）</span></span></strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int Fac1(int n)
{
	int i = 0;
	int ret = 1;
	for (i = 1; i &lt;= n; i++)
	{
		ret = ret*i;
	}
	return ret;
}
int main()
{
	int n = 0;
	scanf("%d",&amp;n);
	printf("%d",Fac1(n));
	return 0;
}</code></pre> 
<p></p> 
<h4 id="7.3.2%20%E7%BB%83%E4%B9%A04"><strong>7.3.2 <span style="color:#fe2c24;"><span style="background-color:#f9eda6;">练习4（详细讲解）</span></span></strong></h4> 
<blockquote> 
 <p id="%E6%B1%82%E7%AC%ACn%E4%B8%AA%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E3%80%82%EF%BC%88%E4%B8%8D%E8%80%83%E8%99%91%E6%BA%A2%E5%87%BA%EF%BC%89">求第n个斐波那契数。（不考虑溢出）</p> 
</blockquote> 
<p><strong> 什么是斐波那契数列</strong><img alt="" height="163" src="https://images2.imgbox.com/ff/a7/ORZb0lwB_o.png" width="1060"></p> 
<p><strong>分为两部分</strong> </p> 
<p> <img alt="" height="262" src="https://images2.imgbox.com/ee/05/jI91BSEj_o.png" width="499"></p> 
<p><strong> 按照公式写代码</strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int Fib(int n)
{
	if (n &lt;= 2)
		return 1;
	else
		return Fib(n - 1) + Fib(n - 2);
}
int main()
{
	int n = 0;
	scanf("%d",&amp;n);
	printf("%d",Fib(n));
	return 0;
}</code></pre> 
<h3 id="7.4%E7%BB%83%E4%B9%A03%2C4%E4%B8%AD%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><strong><span style="color:#0d0016;">7.4</span><span style="color:#fe2c24;"><span style="background-color:#f9eda6;">练习3,4中出现的问题</span></span></strong></h3> 
<p><span style="color:#fe2c24;"><strong>但是我们发现这样会有问题：</strong></span><br>  </p> 
<blockquote> 
 <ul><li><strong>在使用 Fib 这个函数的时候如果我们要计算第50个斐波那契数字的时候特别耗费时间。</strong></li><li><strong>使用Fac函数求10000的阶乘（不考虑结果的正确性），程序会崩溃。</strong></li></ul> 
</blockquote> 
<p><strong>原因是因为</strong></p> 
<p><strong>Fib 函数在调用的过程中很多计算其实在一直重复</strong><br><img alt="" height="378" src="https://images2.imgbox.com/ff/45/zYNBj15g_o.png" width="1124"><strong>那我们如何改进呢？</strong></p> 
<p></p> 
<blockquote> 
 <p></p> 
 <ul><li><strong>在调试 Fac函数的时候，如果你的参数比较大，那就会报错： stack overflow（栈溢出）这样的信息。</strong></li><li><li><span style="color:#fe2c24;"><strong><span style="background-color:#f9eda6;">系统分配给程序的栈空间是有限的，但是如果出现了死循环，或者（死递归），这样有可能导致一直开辟栈空间，最终产生栈空间耗尽的情况，这样的现象我们称为</span><span style="background-color:#38d8f0;">栈溢出</span></strong></span></li></ul> 
</blockquote> 
<p><strong>如何解决上述问题</strong></p> 
<blockquote> 
 <p><strong>1. <span style="color:#fe2c24;">将递归改写成非递归。</span><br> 2. 使用static对象替代 nonstatic 局部对象。在递归函数设计中，可以使用 static 对象替代<br> nonstatic 局部对象（即栈对象），这不仅可以减少每次递归调用和返回时产生和释放 nonstatic 对象的开销，而且 static 对象还可以保存递归调用的中间状态，并且可为各个调用层所访问</strong></p> 
</blockquote> 
<p></p> 
<p><strong>用<span style="color:#fe2c24;">非递归方式</span>解决斐波那契数列</strong></p> 
<pre><code class="language-cpp">#include&lt;stdio.h&gt;
int Fib(int n)
{
	int a = 1;
	int b = 1;
	int c = 1;

	while (n&gt;2)
	{
		c = a + b;
		a = b;
		b = c;
		n--;
	}
	return c;
}

int main()
{
	int n = 0;
	scanf("%d", &amp;n);
	int ret = Fib(n);
	printf("%d\n", ret);
	return 0;
}</code></pre> 
<p></p> 
<p><strong>提示：</strong></p> 
<blockquote> 
 <p><br><strong>1. 许多问题是以递归的形式进行解释的，这只是因为它比非递归的形式更为清晰。<br> 2. 但是这些问题的迭代实现往往比递归实现效率更高，虽然代码的可读性稍微差些。<br> 3. 当一个问题相当复杂，难以用迭代实现时，此时递归实现的简洁性便可以补偿它所带来的运行时开销</strong><br>  </p> 
</blockquote> 
<p><span style="color:#fe2c24;"><strong><span style="background-color:#f9eda6;">结语：本篇是函数递归的知识，如果本篇对你有用，请大家点赞关注！！！</span></strong></span></p> 
<p><span style="color:#fe2c24;"><strong><span style="background-color:#f9eda6;">现在关注是新粉，以后就是老粉了</span></strong><img alt="" height="46" src="https://images2.imgbox.com/d6/88/fRK4b9QX_o.png" width="62"></span></p> 
<p></p> 
<p><strong>下期预告：<span style="color:#fe2c24;">数组</span></strong></p> 
<p></p> 
<p><strong>感谢你的观看，我们下期再见</strong></p> 
<p></p> 
<p><img alt="" height="1173" src="https://images2.imgbox.com/e0/14/uXakN3Ku_o.png" width="865"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8820db705a2a135b08e9e166675049c0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Gitlab内存占用过高的解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b9edbe023318f7937020b83b54bb40ec/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java学习----数据结构</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>