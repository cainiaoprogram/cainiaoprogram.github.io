<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Shell编程-awk - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Shell编程-awk" />
<meta property="og:description" content="简介 awk 是一种对立的编程语言，集成于所有UNIX/Linux中，这个名字是它创建者的名字首字母组成的 Alfred Aho,Peter Weinberger, and Brian Kernighan。
awk的基本语法 普通模式 awk &#39;/pattern/{action}&#39; files 其中patter是一个正则表达式，action又是一系列命令，对于满足匹配的文本执行一些动作，files表示待操作的文件，如果不指定，则输入是STDIN。如果不指定pattern，则对所有文件的每一行都执行action。
表达式模式 当在awk中使用比较操作符时，使用下面的语法模式，详见后面。
awk &#39;(expression){action}&#39; files 有如下一个示例文件
zdd.txt包含如下内容
Fruit Price/lbs Banana 0.89 Paech 0.79 Kiwi 1.50 Pineapple 1.29 Apple 0.99 显示一个文件的所有行 awk &#39;{ print ; }&#39; zdd.txt 分号表示命令结束，这个例子没有pattern，只有action
域编辑 awk自动将读入的行分割成域（field），域是由一个或多个分隔符分割开的字符集，缺省的分隔符是tab和空格，访问域可以用$1，$2, ... $n的形式，域都是从1开始的，而$0表示整个行（以行本来的面目呈现）
格式化输出水果及价格
awk &#39;{ printf &#34;%-15s %s\n&#34;, $1, $2 ;}&#39; zdd.txt 输出如下
Fruit Price/lbs Banana 0.89 Paech 0.79 Kiwi 1.50 Pineapple 1.29 Apple 0.99 使用其他的域分隔符 awk的-F参数可以制定其他的域分隔符，比如下面的代码将打印D" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a5672f3e3edd9e3ea069cec4f87e6fe1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-06-20T17:04:08+08:00" />
<meta property="article:modified_time" content="2017-06-20T17:04:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Shell编程-awk</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3></h3> 
<div class="postbody"> 
 <div id="cnblogs_post_body"> 
  <h2>简介</h2> 
  <p>awk 是一种对立的编程语言，集成于所有UNIX/Linux中，这个名字是它创建者的名字首字母组成的 Alfred Aho,Peter Weinberger, and Brian Kernighan。</p> 
  <h2>awk的基本语法</h2> 
  <h3>普通模式</h3> 
  <p></p> 
  <pre><code class="language-html">awk '/pattern/{action}' files</code></pre> 
  <br> 
  <br> 
  <p></p> 
  <p>其中patter是一个正则表达式，action又是一系列命令，对于满足匹配的文本执行一些动作，files表示待操作的文件，如果不指定，则输入是STDIN。如果不指定pattern，则对所有文件的每一行都执行action。</p> 
  <h3>表达式模式</h3> 
  <p>当在awk中使用比较操作符时，使用下面的语法模式，详见后面。</p> 
  <p></p> 
  <pre><code class="language-html">awk '(expression){action}' files</code></pre> 
  <br> 
  <p></p> 
  <p>有如下一个示例文件</p> 
  <p>zdd.txt包含如下内容<br> </p> 
  <pre><code class="language-html">Fruit Price/lbs
Banana 0.89
Paech 0.79
Kiwi 1.50
Pineapple 1.29
Apple 0.99</code></pre> 
  <br> 
  <p></p> 
  <h3>显示一个文件的所有行</h3> 
  <p></p> 
  <pre><code class="language-html">awk '{ print ; }' zdd.txt </code></pre> 
  <br> 
  <p></p> 
  <p>分号表示命令结束，这个例子没有pattern，只有action</p> 
  <h3>域编辑</h3> 
  <p>awk自动将读入的行分割成域（field），域是由一个或多个分隔符分割开的字符集，缺省的分隔符是tab和空格，访问域可以用$1，$2, ... $n的形式，域都是从1开始的，而$0表示整个行（以行本来的面目呈现）</p> 
  <p>格式化输出水果及价格</p> 
  <p></p> 
  <pre><code class="language-html">awk '{ printf "%-15s %s\n", $1, $2 ;}' zdd.txt</code></pre> 
  <br> 
  <p></p> 
  <p>输出如下</p> 
  <p></p> 
  <pre><code class="language-html">Fruit           Price/lbs
Banana          0.89
Paech            0.79
Kiwi              1.50
Pineapple      1.29
Apple            0.99</code></pre> 
  <br> 
  <p></p> 
  <h3>使用其他的域分隔符</h3> 
  <p>awk的-F参数可以制定其他的域分隔符，比如下面的代码将打印D</p> 
  <p></p> 
  <pre><code class="language-html">echo A:B:C:D | awk -F: '{print $4}'</code></pre> 
  <br> 
  <p></p> 
  <h3>多个命令同时执行</h3> 
  <p>在价格高于1美元的水果后面加* 以引起注意，这里包含了两个模式和动作对，直接书写即可，不必像sed那样加-e参数</p> 
  <p></p> 
  <pre><code class="language-html">awk '/[1-9]\.[0-9][0-9]$/ { print $0, "*"} /0\.[1-9][1-9]/ {print ;}' zdd.txt</code></pre> 
  <br> 
  <p></p> 
  <p>输出如下</p> 
  <p></p> 
  <pre><code class="language-html">Banana 0.89
Paech 0.79
Kiwi 1.50 *
Pineapple 1.29 *
Apple 0.99
bash-3.2$</code></pre> 
  <br> 
  <p></p> 
  <h3>比较操作</h3> 
  <p>awk中可以执行的比较操作有<br> </p> 
  <pre><code class="language-html">&lt;
&gt;
&lt;=
&gt;=
!=
value ~ /pattern/
value !~ /pattern/</code></pre> 
  <br> 
  <p></p> 
  <h3>比较操作基本语法</h3> 
  <p></p> 
  <pre><code class="language-html">awk '(expression){action}' files</code></pre> 
  <br> 
  <p></p> 
  <p>其中expression是一个比较表达式，通常将其用括弧括起来。<br> <br> 在价格大于1美元的水果后面打印expensive</p> 
  <p></p> 
  <pre><code class="language-html">awk '$2 &gt;= 1.0 { printf "%s\t%s\n", $0, "Expensive" ; }' zdd.txt</code></pre> 
  <br> 
  <p></p> 
  <p>输出</p> 
  <p></p> 
  <pre><code class="language-html">Fruit Price/lbs Expensive
Kiwi 1.50       Expensive
Pineapple 1.29  Expensive</code></pre> 
  <br> 
  <p></p> 
  <h3>复合表达式</h3> 
  <p>可以使用&amp;&amp;或||连接多个表达式，表达式用()扩起<br> </p> 
  <pre><code class="language-html">(expr1) &amp;&amp; (expr2)
(expr1) ||(expr)</code></pre> 
  <br> 
  <br> next命令 
  <br> 看一个例子 
  <br> 
  <pre><code class="language-html">awk '
$3 &lt;= 75 { printf "%s\t%s\n",$0,"REORDER" ; }
$3 &gt; 75 { print $0 ; }
' zdd.txt</code></pre> 
  <br> 这个命令的执行过程如下 
  <br> (1) 读入一行，检查价格是否小于等于75，如果为真，则打印出REORDER 
  <br> (2) 检查该行是否大于75，如果大于则直接打印 
  <br> (3) 处理下一行 
  <br> 可见如果条件(1)满足，则不必再判断条件(2)了，如果避免这个多余的操作呢？使用next即可 
  <br> 
  <pre><code class="language-html">awk '
$3 &lt;= 75 { printf "%s\t%s\n",$0,"REORDER" ; next ; }
$3 &gt; 75 { print $0 ; }
' zdd.txt</code></pre> 
  <br> 
  <p></p> 
  <h3>BEGIN和END</h3> 
  <p>基本与法</p> 
  <p></p> 
  <pre><code class="language-html">awk '
    BEGIN { actions }
    /pattern/ { actions }
    /pattern/ { actions }
    END { actions }
' files</code></pre> 
  <br> 
  <p></p> 
  <p>注意BEGIN对应的模式必须是第一个模式，而END对应的模式必须是最后一个模式。这两者都不参与文本行的处理，只是做一些初始化及善后工作。</p> 
  <p>BEGIN可以用来打印表头或者列名等，如下</p> 
  <p></p> 
  <pre><code class="language-html">BEGIN{
-F":"
printf "----------------------------------------------------------------\n"
printf "%-20s%-16s  Jan  |  Feb  |  Mar  |Total Donated\n ","NAME","PHONE"
printf "----------------------------------------------------------------\n"
}</code></pre> 
  <br> 
  <p></p> 
  <p>7 以STDIN作为输入<br> 打印文件名及大小，在ls命令的输出中，文件名位于第9列，而大小位于第5列<br> </p> 
  <pre><code class="language-html">ls -l | awk '{ printf "%15s%15s\n", $9, $5}'
          ipck           1853
     ipcrm.exe           5632
      ipcs.exe          14336
      join.exe          52224
      kill.exe          10240
      less.exe         168960
  lessecho.exe           6144
   lesskey.exe           9728
      link.exe          42496
     lkbib.exe          52224
        ln.exe         114688
    locate.exe         122880
     login.exe          20992
   logname.exe          41472
   lookbib.exe          51712
       lpr.exe         299008
        ls.exe         122368
  makeinfo.exe         191488
       man.exe          37376
       man2dvi            409
  man2html.exe          45568
       manlint           7098</code></pre> 
  <br> 
  <p></p> 
  <h2>流控制</h2> 
  <h3>if</h3> 
  <p>基本格式</p> 
  <p></p> 
  <pre><code class="language-html">if (expression1) {
    action1
} else if (expression2) {
    action2
} else {
    action3
}</code></pre> 
  <br> 
  <p></p> 
  <p>一个例子，根据每行的特征字，在行末加注释。</p> 
  <div class="cnblogs_code"> 
   <div class="cnblogs_code_toolbar"> 
    <span class="cnblogs_code_copy"></span> 
    <pre><code class="language-html">awk '{ 
    print "%s\t", $0;
    if ($1 ~ /d/) {
        print "Directory\n";
    }
    else if ($NF ~ /\.pl/){
        print "Perl script\n";
    }
    else if ($NF ~ /\.bcp/) {
        print "BCP file\n";
    }
    else {
        print "\n";
    }
}'</code></pre> 
    <br> 
   </div> 
  </div> 
  <h3>while</h3> 
  <h3>for</h3> 
  <p>awk中的for与C语言中的for类似。</p> 
  <p></p> 
  <pre><code class="language-html">awk '{ 
    for (x = 1; x &lt;= NF; x++){
        printf "%s ", $x;
    }
    print "\n";
}' input_file ;</code></pre> 
  <p></p> 
  <h2>特殊技巧</h2> 
  <h3>NR==FNR</h3> 
  <p>这条语句只有在输入是多个文件的时候才有意义，用来判断当前正在处理第一个文件。</p> 
  <p>NR    处理过的文件行数，多个文件累加。</p> 
  <p>FNR  处理过的文件行数，仅限当前文件。</p> 
  <p>所以，NR &gt;= FNR。看一个例子</p> 
  <pre><code class="language-html">#cat a
张三|000001
李四|000002

#cat b
000001|10
000001|20
000002|30
000002|15</code></pre> 
  <p><span style="font-size:14px"> <br> 想要得到的结果是将用户名，帐号和金额在同一行打印出来,如下:</span></p> 
  <p><span style="font-size:14px">张三|000001|10<br> 张三|000001|20<br> 李四|000002|30<br> 李四|000002|15</span></p> 
  <p><span style="font-size:14px"></span></p> 
  <pre><code class="language-html">awk -F'|' 'NR==FNR{a[$2]=$0;next}{print a[$1] FS $2}' a b
awk -F'|' '{a[$2]=$0}NR&gt;FNR{print a[$1] FS $2}' a b</code></pre> 
  <p></p> 
  <p><span style="font-size:14px">[解析]<br> 由NR=FNR成立,判断当前读入的是第一个文件a,然后使用{a[$2]=$0;next}循环将a文件的每行记录都存入数组a,并使用$2作为下标引用.next,不在执行后面的语句.<br> 由NR=FNR不成立,判断当前读入了第二个文件b,然后跳过{a[$2]=$0;next},对第二个文件b的每一行都无条件执行{print a[$1]FS$2},此时变量$1为第二个文件的第一个字段,与读入第一个文件时,采用第一个文件的$2为数组下标相同.因此可以在此输出该数组的值。下面那种写法是不是更短呢？</span></p> 
  <h2>awk应用</h2> 
  <h3>按条件打印文件</h3> 
  <p>awk配合ls命令可以打印文件指定的某一列，ls -l的输出入下</p> 
  <p></p> 
  <pre><code class="language-html">-rwxr-xr-x   1 user1     staff       1805 Dec  4 22:59 abc.sh
drwxr-xr-x   3 user2     staff        512 Dec  4 22:59 test_report
-rwxr-xr-x   1 user3     staff      12526 Feb  1 03:12 test.pl
drwxr-xr-x   3 user1     staff        512 Feb  1 03:19 xyz</code></pre> 
  <p></p> 
  <p>如果只想打印文件名（第九列），那么可以使用下面的方法，$9表示文本行的第九列。</p> 
  <p></p> 
  <pre><code class="language-html">ls -l | awk '{print $9;}'</code></pre> 
  <br> 
  <p></p> 
  <p>如果只想打印user1创建的文件名，可以使用下面的方法，这里/user1/是一个pattern，表示只处理包含user1的文本行。</p> 
  <p></p> 
  <pre><code class="language-html">ls -l | awk '/user1/{print $9;}'</code></pre> 
  <br> 
  <p></p> 
  <h3>格式化打印</h3> 
  <p>awk支持printf格式化打印。</p> 
  <p>只打印文件名和文件大小（文件名位于第9列，文件大小位于第5列）</p> 
  <div class="cnblogs_code"> 
   <pre>ls -l | awk <span style="color:#000000; font-weight:bold">'</span><span style="color:#000000; font-weight:bold">{print $9, $5;}</span><span style="color:#000000; font-weight:bold">'</span></pre> 
  </div> 
  <p>上面的代码虽然能打印，但是格式很乱，可以使用printf格式化一下。</p> 
  <p>%s参数，用来打印字符串，可以指定宽度，不足的补空格，正数表示右对齐，负数表示左对齐。%3s表示字符串宽度为3列，右边对齐，如果字符串实际宽度大于3，那么取实际宽度。</p> 
  <p>文件名左对齐，大小左对齐</p> 
  <div class="cnblogs_code"> 
   <pre>ls -l | awk <span style="color:#000000; font-weight:bold">'</span><span style="color:#000000; font-weight:bold">{printf "%-16s%\t%-16s\n", $9, $5;}</span><span style="color:#000000; font-weight:bold">'</span></pre> 
  </div> 
  <p>文件名左对齐，大小右对齐</p> 
  <div class="cnblogs_code"> 
   <pre>ls -l | awk <span style="color:#000000; font-weight:bold">'</span><span style="color:#000000; font-weight:bold">{printf "%-16s%\t%16s\n", $9, $5;}</span><span style="color:#000000; font-weight:bold">'</span></pre> 
  </div> 
  <p>文件名右对齐，大小左对齐</p> 
  <div class="cnblogs_code"> 
   <pre>ls -l | awk <span style="color:#000000; font-weight:bold">'</span><span style="color:#000000; font-weight:bold">{printf "%16s%\t%-16s\n", $9, $5;}</span><span style="color:#000000; font-weight:bold">'</span></pre> 
  </div> 
  <p>文件名右对齐，大右左对齐</p> 
  <div class="cnblogs_code"> 
   <pre>ls -l | awk <span style="color:#000000; font-weight:bold">'</span><span style="color:#000000; font-weight:bold">{printf "%16s%\t%16s\n", $9, $5;}</span><span style="color:#000000; font-weight:bold">'</span></pre> 
  </div> 
  <h3>按行打印环境变量PATH</h3> 
  <p></p> 
  <pre><code class="language-html">echo $PATH | awk -F: ' {
    for (i = 1; i &lt;=NF; i++) {
        printf "%s\n", $i;
    }
}'</code></pre> 
  <p></p> 
  <h3>删除某个用户的所有文件</h3> 
  <p>删除用户zdd的所有文件，注意-rf后面有一个空格。</p> 
  <p></p> 
  <pre><code class="language-html">ls -l | awk '/zdd/{print "rm -rf " $9} | sh</code></pre> 
  <p></p> 
 </div> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c13b13511cba22143dd2c75b069840a4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">&#34;Your device isn&#39;t compatible with this version&#34; 部分设备无法从google play下载</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c0e43b883e034e7c611d19bf49817da3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">第一次接触单片机ADC 都会有这些问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>