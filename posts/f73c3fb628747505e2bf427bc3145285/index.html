<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>面试官问我：如何设计 QQ、微信等第三方账号登陆 ？还要我说出数据库表设计！ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="面试官问我：如何设计 QQ、微信等第三方账号登陆 ？还要我说出数据库表设计！" />
<meta property="og:description" content="面试官问我：如何设计 QQ、微信等第三方账号登陆 ？还要我说出数据库表设计！ 多账户的统一登录名称解释内容架构演进创业初期用户名密码注册登陆手机号注册登陆数据库设计引入第三方账户方案数据库设计 总结 多账户的统一登录 名称解释 这里的多账户区别于系统级别的，我们讲的多账户系统是指，在我们互联网应用当中，我们的应用会使用多个第三方账号进行登录，比如现在常用的APP：网易、微信、QQ等等。
内容 通过这一篇文章：
1.可以学到：多用户下面的技术方案细节，以及相应的表设计，流程设计。
2.不可以学到：与其他文章一样，我这里不会有具体代码实现细节，方案做的对，代码咋写都不会太烂。
架构演进 创业初期 归结为创业初期是因为这个时候用户量比较少，甚至还没有接入上面所说的其他第三方的账户系统，只是自建的体系就可以满足，自建体系的话，目前常用的有
用户名密码注册登陆 这种方式在很多初期网站建设会使用，先注册，再进行登录，在老一点的cms中都能找到这个影子。
流程图：
流程说明：
1.前端将用户名、密码发送到服务器，服务器进行常规的判断，判断用户名、密码长度是否满足，用户名是否重复等条件，条件不通过直接返回对应错误码给到前端，这里密码字段，为了防止传输过程中被截胡，建议加密再上传，我们的传输密码默认都是会进行一个md5加密，然后记录到数据库再进行一层加密，就算是脱库也没事，密码不要明文存储。
2.校验通过后，就将用户名密码写入数据库，并进行后面积分发放等操作，这里不展开。
3.现在进行登录，前端将用户名，密码发送给到服务端，服务端首先会校验登录次数是否超过设置的阈值，如果超过只能继续等待被关小黑屋。
4.如果未超过继续登录逻辑，判断用户名、密码是否正确，不正确密码则进行阈值的判断，如果超过则关小黑屋，记住小黑屋必须设置过期时间，要不然就会永久关上了，这个可以用redis的过期来做。
5.登录成功后进行后续的一切后置逻辑，比如加积分。。。等操作。
手机号注册登陆 流程图：
流程说明：
1.首先输入手机号，然后发送到服务端，服务端将手机号记录在我们数据库中，然后生成随机验证码，并将手机号和验证码绑定到一个redis里面，然后记录过期时间，这个过期时间一般是10分钟左右，这就是我们一般手机验证码的有效期。
2.手机接收到手机短信后，那么就在界面填写验证码发送服务端，服务端收到验证码后就会在redis里面查询到这个手机号对应的验证码，失败就返回错误码。
3.成功后就进行登录操作。
这里看起来没有明确的注册登录操作，其实在发送手机号码就可以认为是一个常规的注册，然后后面的验证码输入就是一个登陆操作，
问： 那我要密码咋办？
答： 在后续产品里面增加一个 手机号码密码补录的功能 即可，这也是现在很常规的手法，但是现在移动互联网大爆炸时代，密码已经显得不是那么重要了，反正我从来记不住密码，如果手机号码能操作的app，绝对不用密码来操作。
数据库设计 表结构 ：
自增id用户名密码手机错误次数1user17fef6171469e80d32c0559f88b3772451345678901202user27fef6171469e80d32c0559f88b377245134567890120 说明 ：
这里只是单纯说明需要用到的数据，没有扩展具体场景,这个表结构能够满足上面两个方案的设计。
引入第三方账户方案 这里是以QQ-SDK的登录逻辑， 我们先来一波时序图
说明：
1.客户端自己调起登录的界面，进行输入用户名、密码，这里的是第三方的用户名，密码，登录成功后，会返回access_token openid expire_in,这过程会使用到oauth2.0，不过在sdk里面进行内置回调获取了，后面我们会说明我们自身实现的oauth2.0
2.客户端拿到access_token、openid、login_type（qq、wechat…）请求应用服务器，应用服务器拿到这些数据后就会根据对应的login_type去对应的用户中心进行access_token和openid进行校验。校验不通过则返回对应错误码
3.校验通过后就会判断本地是否有这个login_type和openid是否存在，不存在则进行获取远程的用户名、头像等基础信息来作为本地基础数据，并且返回code值
4.如果已经存在，那就是进行登录操作，返回code值。
5.客户端拿到code值后进行token值的换取，这个完全遵照oauth2.0的协议来走的，后续每次请求必须带上token，token值在服务端的时间比较久，因为我们想要做的是那种永不下线的操作，所以每次请求我们都将token过期时间进行累加。
数据库设计 根据部分小伙伴的的建议，我这里做一下数据库的整理：
用户基础表（users）
字段备注user_id用户idtoken用户登陆的tokenexpire_intoken过期时间try_times登录失败次数 用户验证关联表（user_auth_rel）
字段备注id自增iduser_id用户idauth_id验证表idauth_type验证类型(local、third) 本地用户表|（user_local_auth）
字段备注auth_id认证id，自增iduser_name用户唯一标识password用户密码mobile用户手机 第三方用户表（user_third_auth）
字段备注auth_id用户idopenid第三方用户唯一标识login_type第三方平台标识(qq、wechat…)access_token第三方获取的access_token,校验使用 说明
1.users表只是单纯针对我们业务侧的登录，主要是做自身业务的oauth2.0业务，
2.user_local_auth是做自己用户名、密码登录，手机号码登录信息记录，
3.user_third_auth是我们第三方用户体系的数据记录，" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f73c3fb628747505e2bf427bc3145285/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-09-13T15:41:53+08:00" />
<meta property="article:modified_time" content="2020-09-13T15:41:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">面试官问我：如何设计 QQ、微信等第三方账号登陆 ？还要我说出数据库表设计！</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>面试官问我：如何设计 QQ、微信等第三方账号登陆 ？还要我说出数据库表设计！</h4> 
 <ul><li><a href="#_1" rel="nofollow">多账户的统一登录</a></li><li><ul><li><a href="#_2" rel="nofollow">名称解释</a></li><li><a href="#_5" rel="nofollow">内容</a></li><li><a href="#_11" rel="nofollow">架构演进</a></li><li><ul><li><a href="#_12" rel="nofollow">创业初期</a></li><li><a href="#_15" rel="nofollow">用户名密码注册登陆</a></li><li><a href="#_31" rel="nofollow">手机号注册登陆</a></li><li><a href="#_46" rel="nofollow">数据库设计</a></li><li><a href="#_58" rel="nofollow">引入第三方账户方案</a></li><li><a href="#_70" rel="nofollow">数据库设计</a></li></ul> 
   </li><li><a href="#_117" rel="nofollow">总结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>多账户的统一登录</h2> 
<h3><a id="_2"></a>名称解释</h3> 
<p>这里的多账户区别于系统级别的，我们讲的多账户系统是指，在我们互联网应用当中，我们的应用会使用多个第三方账号进行登录，比如现在常用的APP：网易、微信、QQ等等。</p> 
<h3><a id="_5"></a>内容</h3> 
<p>通过这一篇文章：</p> 
<p>1.可以学到：多用户下面的技术方案细节，以及相应的表设计，流程设计。<br> 2.不可以学到：与其他文章一样，我这里不会有具体代码实现细节，方案做的对，代码咋写都不会太烂。<br> <img src="https://images2.imgbox.com/a7/9a/p5bK7sx0_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="_11"></a>架构演进</h3> 
<h4><a id="_12"></a>创业初期</h4> 
<p>归结为创业初期是因为这个时候用户量比较少，甚至还没有接入上面所说的其他第三方的账户系统，只是自建的体系就可以满足，自建体系的话，目前常用的有</p> 
<h4><a id="_15"></a>用户名密码注册登陆</h4> 
<p>这种方式在很多初期网站建设会使用，先注册，再进行登录，在老一点的cms中都能找到这个影子。</p> 
<p>流程图：<br> <img src="https://images2.imgbox.com/bb/5d/ayQWVywp_o.png" alt="在这里插入图片描述"></p> 
<p>流程说明：</p> 
<p>1.前端将用户名、密码发送到服务器，服务器进行常规的判断，判断用户名、密码长度是否满足，用户名是否重复等条件，条件不通过直接返回对应错误码给到前端，这里密码字段，为了防止传输过程中被截胡，建议加密再上传，我们的传输密码默认都是会进行一个md5加密，然后记录到数据库再进行一层加密，就算是脱库也没事，密码不要明文存储。<br> 2.校验通过后，就将用户名密码写入数据库，并进行后面积分发放等操作，这里不展开。<br> 3.现在进行登录，前端将用户名，密码发送给到服务端，服务端首先会校验登录次数是否超过设置的阈值，如果超过只能继续等待被关小黑屋。<br> 4.如果未超过继续登录逻辑，判断用户名、密码是否正确，不正确密码则进行阈值的判断，如果超过则关小黑屋，记住小黑屋必须设置过期时间，要不然就会永久关上了，这个可以用redis的过期来做。<br> 5.登录成功后进行后续的一切后置逻辑，比如加积分。。。等操作。</p> 
<h4><a id="_31"></a>手机号注册登陆</h4> 
<p>流程图：<br> <img src="https://images2.imgbox.com/54/dd/RCfkH0jt_o.png" alt="在这里插入图片描述"><br> 流程说明：</p> 
<p>1.首先输入手机号，然后发送到服务端，服务端将手机号记录在我们数据库中，然后生成随机验证码，并将手机号和验证码绑定到一个redis里面，然后记录过期时间，这个过期时间一般是10分钟左右，这就是我们一般手机验证码的有效期。<br> 2.手机接收到手机短信后，那么就在界面填写验证码发送服务端，服务端收到验证码后就会在redis里面查询到这个手机号对应的验证码，失败就返回错误码。<br> 3.成功后就进行登录操作。</p> 
<p>这里看起来没有明确的注册登录操作，其实在发送手机号码就可以认为是一个常规的注册，然后后面的验证码输入就是一个登陆操作，</p> 
<p><mark>问： 那我要密码咋办？</mark></p> 
<p><mark>答：</mark> 在后续产品里面增加一个 <mark>手机号码密码补录的功能</mark> 即可，这也是现在很常规的手法，但是现在移动互联网大爆炸时代，密码已经显得不是那么重要了，反正我从来记不住密码，如果手机号码能操作的app，绝对不用密码来操作。</p> 
<h4><a id="_46"></a>数据库设计</h4> 
<p><mark>表结构 ：</mark></p> 
<table><thead><tr><th>自增id</th><th>用户名</th><th>密码</th><th>手机</th><th>错误次数</th></tr></thead><tbody><tr><td>1</td><td>user1</td><td>7fef6171469e80d32c0559f88b377245</td><td>13456789012</td><td>0</td></tr><tr><td>2</td><td>user2</td><td>7fef6171469e80d32c0559f88b377245</td><td>13456789012</td><td>0</td></tr></tbody></table> 
<p><mark>说明 ：</mark></p> 
<p>这里只是单纯说明需要用到的数据，没有扩展具体场景,这个表结构能够满足上面两个方案的设计。</p> 
<h4><a id="_58"></a>引入第三方账户方案</h4> 
<p>这里是以QQ-SDK的登录逻辑， 我们先来一波时序图</p> 
<p><img src="https://images2.imgbox.com/c6/6d/KH2EGFfA_o.png" alt="在这里插入图片描述"><br> 说明：</p> 
<p>1.客户端自己调起登录的界面，进行输入用户名、密码，这里的是第三方的用户名，密码，登录成功后，会返回access_token openid expire_in,这过程会使用到oauth2.0，不过在sdk里面进行内置回调获取了，后面我们会说明我们自身实现的oauth2.0<br> 2.客户端拿到access_token、openid、login_type（qq、wechat…）请求应用服务器，应用服务器拿到这些数据后就会根据对应的login_type去对应的用户中心进行access_token和openid进行校验。校验不通过则返回对应错误码<br> 3.校验通过后就会判断本地是否有这个login_type和openid是否存在，不存在则进行获取远程的用户名、头像等基础信息来作为本地基础数据，并且返回code值<br> 4.如果已经存在，那就是进行登录操作，返回code值。<br> 5.客户端拿到code值后进行token值的换取，这个完全遵照oauth2.0的协议来走的，后续每次请求必须带上token，token值在服务端的时间比较久，因为我们想要做的是那种永不下线的操作，所以每次请求我们都将token过期时间进行累加。</p> 
<h4><a id="_70"></a>数据库设计</h4> 
<p>根据部分小伙伴的的建议，我这里做一下数据库的整理：</p> 
<p><mark>用户基础表（users）</mark></p> 
<table><thead><tr><th>字段</th><th>备注</th></tr></thead><tbody><tr><td>user_id</td><td>用户id</td></tr><tr><td>token</td><td>用户登陆的token</td></tr><tr><td>expire_in</td><td>token过期时间</td></tr><tr><td>try_times</td><td>登录失败次数</td></tr></tbody></table> 
<p><mark>用户验证关联表（user_auth_rel）</mark></p> 
<table><thead><tr><th>字段</th><th>备注</th></tr></thead><tbody><tr><td>id</td><td>自增id</td></tr><tr><td>user_id</td><td>用户id</td></tr><tr><td>auth_id</td><td>验证表id</td></tr><tr><td>auth_type</td><td>验证类型(local、third)</td></tr></tbody></table> 
<p><mark>本地用户表|（user_local_auth）</mark></p> 
<table><thead><tr><th>字段</th><th>备注</th></tr></thead><tbody><tr><td>auth_id</td><td>认证id，自增id</td></tr><tr><td>user_name</td><td>用户唯一标识</td></tr><tr><td>password</td><td>用户密码</td></tr><tr><td>mobile</td><td>用户手机</td></tr></tbody></table> 
<p><mark>第三方用户表（user_third_auth）</mark></p> 
<table><thead><tr><th>字段</th><th>备注</th></tr></thead><tbody><tr><td>auth_id</td><td>用户id</td></tr><tr><td>openid</td><td>第三方用户唯一标识</td></tr><tr><td>login_type</td><td>第三方平台标识(qq、wechat…)</td></tr><tr><td>access_token</td><td>第三方获取的access_token,校验使用</td></tr></tbody></table> 
<p>说明</p> 
<p>1.users表只是单纯针对我们业务侧的登录，主要是做自身业务的oauth2.0业务，<br> 2.user_local_auth是做自己用户名、密码登录，手机号码登录信息记录，<br> 3.user_third_auth是我们第三方用户体系的数据记录，<br> user_auth_rel是用来关联我们users表与user_local_auth、user_third_auth。<br> 4.整个设计理念就是将自建用户与第三方在存储上区分，这在架构演进上也是合乎情理的，开始用户体系大多自建，而后才是对外接入。</p> 
<h3><a id="_117"></a>总结</h3> 
<p>1.总的来讲，第三方用户的接入技术上来讲是比较简单的，这里设计多一个user_thirds是可以支持足够多的第三方接入，当然一般我们也就两三个登录就好，太多登录方不仅自身维护成本，界面摆盘也不好看不是。<br> 2.希望大家能够通过以上学习，能够对于我们多账户登录有一个比较好的认知，这里设计方案不包含分表分库、没有服务化，就是简单直接的设计，当然用户量和需要的不一样，在这个基础上还要加很多东西，谢谢大家阅读！</p> 
<center>
  END 
</center> 
<p><img src="https://images2.imgbox.com/a4/68/f0r58Tfb_o.gif" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1438f2e6529f3f4ab489a160a44a53ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">springboot源码分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8b4f1cfd59acb6ababcfc9c78c5743fd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">go test 在用kind 安装了kubernetes 之后就不灵了</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>