<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C查漏补缺 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C查漏补缺" />
<meta property="og:description" content="c语言基础
1,void func1(void);普通函数声明，任意参数无返回值，需要实现函数体才能使用。
2,void *func2(void);普通函数声明，任意参数返回任意函数指针，需要实现函数体才能使用。
3,void (*func3)(void);函数指针声明，函数任意参数无返回值，属于变量声明，可以赋值。
4,void (*func4(void))(void);函数指针声明，属于一个返回函数指针的函数指针，本体函数指针任意参数，返回的函数指针任意参数无返回值
5，fork只会复制当前进程的调用fork的线程到子进程中。
6，c/c&#43;&#43;可以看到0x0001u的用法，这个u表示unsigned，还有其他的一些修饰数字的前后缀，比如01中0表示8进制，1L中L表示long int , 1u中u表示unsigned int。
7，c语言中变量定义和赋值中逗号和分号的应用：
结构体定义：内部用分号，结尾用分号。
枚举定义：内部逗号，结尾分号。
c&#43;&#43;类定义：内部分号，结尾分号。
8，数组指针的部分误解：
如果有int a[10];，那么a和&amp;a表示相同的地址，但是代表不同的含义，a表示数组的首地址，&amp;a表示数组大小为10的数组的地址。
也就是a&#43;1表示a[1]的地址，但是&amp;a&#43;1表示a[10]的地址
9，当表达式中有有符号数据和无符号数据时，一律将有符号转化为无符号。
这一点可能和向上转换原则不太一样，一般情况是小范围转大范围，但是有符号和无符号其实范围是一样的
10，结构体补齐规则
以前总是按照那3个准则来记忆，类似于：
对齐原则：每一成员的结束偏移量需对齐为后一成员类型的倍数 补齐原则：最终大小补齐为成员中最大值的倍数
有种方法更容易记忆。结构体成员以最大成员补齐，如果下个成员能填充到上个成员为对齐而空出的内容中的话，则这个成员会挤到上个成员会移到上个成员后的空位中
typedef struct A{ int a; //aaaa ***b cccccccc //如果没有b则a后仍空出4字节，b发现可以b的大小小于到4字节就会挤到空位中 char b; double c; }A; //16byte typedef struct B{ char b;//b*** aaaa cccccccc int a; double c; }B;//16byte typedef struct C{ int a;//aaaa**** cccccccc b******* double c; char b; }C;//24byte typedef struct D{ char b;//bbbbbbbb cccccccc aaaa**** double c; int a; }D;//24byte typedef struct E{ char b;//b*** aaaa c*** int a; char c; }E;//12byte 11，thread默认是非分离的，也就是如果thread_create后不进行thread_join,线程资源是不会释放的，一般可以手动设置detach，接下来线程结束后会自动释放，或者不设置detach，调用thread_join等待线程结束并释放资源。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8faeded3d8a8667d9676f8c650133512/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-31T10:26:50+08:00" />
<meta property="article:modified_time" content="2023-10-31T10:26:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C查漏补缺</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>c语言基础</p> 
<p>1,void func1(void);普通函数声明，任意参数无返回值，需要实现函数体才能使用。</p> 
<p></p> 
<p>2,void *func2(void);普通函数声明，任意参数返回任意函数指针，需要实现函数体才能使用。</p> 
<p></p> 
<p>3,void (*func3)(void);函数指针声明，函数任意参数无返回值，属于变量声明，可以赋值。</p> 
<p></p> 
<p>4,void (*func4(void))(void);函数指针声明，属于一个返回函数指针的函数指针，本体函数指针任意参数，返回的函数指针任意参数无返回值</p> 
<p>5，fork只会复制当前进程的调用fork的线程到子进程中。</p> 
<p>6，c/c++可以看到0x0001u的用法，这个u表示unsigned，还有其他的一些修饰数字的前后缀，比如01中0表示8进制，1L中L表示long int , 1u中u表示unsigned int。</p> 
<p>7，c语言中变量定义和赋值中逗号和分号的应用：</p> 
<p>结构体定义：内部用分号，结尾用分号。</p> 
<p>枚举定义：内部逗号，结尾分号。</p> 
<p>c++类定义：内部分号，结尾分号。</p> 
<p></p> 
<p>8，数组指针的部分误解：</p> 
<p>如果有int a[10];，那么a和&amp;a表示相同的地址，但是代表不同的含义，a表示数组的首地址，&amp;a表示数组大小为10的数组的地址。</p> 
<p>也就是a+1表示a[1]的地址，但是&amp;a+1表示a[10]的地址</p> 
<p></p> 
<p>9，当表达式中有有符号数据和无符号数据时，一律将有符号转化为无符号。</p> 
<p>这一点可能和向上转换原则不太一样，一般情况是小范围转大范围，但是有符号和无符号其实范围是一样的</p> 
<p>10，结构体补齐规则</p> 
<p>以前总是按照那3个准则来记忆，类似于：</p> 
<p><strong>对齐原则</strong>：每一成员的结束偏移量需对齐为后一成员类型的倍数 </p> 
<p><strong>补齐原则</strong>：最终大小补齐为成员中最大值的倍数</p> 
<p>有种方法更容易记忆。结构体成员以最大成员补齐，如果下个成员能填充到上个成员为对齐而空出的内容中的话，则这个成员会挤到上个成员会移到上个成员后的空位中</p> 
<pre class="has"><code>typedef struct A{
    int a; //aaaa ***b cccccccc //如果没有b则a后仍空出4字节，b发现可以b的大小小于到4字节就会挤到空位中
    char b;
    double c;
}A; //16byte

typedef struct B{
    char b;//b*** aaaa cccccccc
    int a;
    double c;
}B;//16byte

typedef struct C{
    int a;//aaaa**** cccccccc b*******
    double c;
    char b;
}C;//24byte

typedef struct D{
    char b;//bbbbbbbb cccccccc aaaa****
    double c;
    int a;
}D;//24byte

typedef struct E{
    char b;//b*** aaaa c***
    int a;
    char c;
}E;//12byte</code></pre> 
<p>11，thread默认是非分离的，也就是如果thread_create后不进行thread_join,线程资源是不会释放的，一般可以手动设置detach，接下来线程结束后会自动释放，或者不设置detach，调用thread_join等待线程结束并释放资源。</p> 
<p></p> 
<p>12、头文件分类</p> 
<p>stdlib.h:</p> 
<p>           getenv();atoi();abort();exit();free();malloc();</p> 
<p>unistd.h:</p> 
<p>        getcwd();getpid();access();read();write();</p> 
<p><strong>ISO C标准定义的头文件(24项)</strong></p> 
<p>&lt;assert.h&gt;       ----------------------   验证程序断言</p> 
<p>&lt;complex.h&gt;    ----------------------   支持复数算术运算</p> 
<p>&lt;ctype.h&gt;        ----------------------   字符类型</p> 
<p>&lt;errno.h&gt;        ----------------------   出错码</p> 
<p>&lt;fenv.h&gt;          ----------------------   浮点环境</p> 
<p>&lt;float.h&gt;          ----------------------   浮点常量</p> 
<p>&lt;inttypes.h&gt;    ----------------------   整型格式转换</p> 
<p>&lt;iso646.h&gt;      ----------------------   替代关系操作符宏</p> 
<p>&lt;limits.h&gt;         ----------------------   实现常量</p> 
<p>&lt;locale.h&gt;       ----------------------   局部类别</p> 
<p>&lt;math.h&gt;         ----------------------   数学常量</p> 
<p>&lt;setjmp.h&gt;      ----------------------   非局部goto</p> 
<p>&lt;signal.h&gt;       ----------------------   信号</p> 
<p>&lt;stdarg.h&gt;      ----------------------   可变参数表</p> 
<p>&lt;stdbool.h&gt;     ----------------------   布尔类型和值</p> 
<p>&lt;stddef.h&gt;       ----------------------   标准定义</p> 
<p>&lt;stdint.h&gt;        ----------------------   整型</p> 
<p>&lt;stdio.h&gt;         ----------------------   标准I/O库</p> 
<p>&lt;stdlib.h&gt;        ----------------------   实用程序库函数</p> 
<p>&lt;string.h&gt;       ----------------------   字符串操作</p> 
<p>&lt;tgmath.h&gt;     ----------------------   通用类型数学宏</p> 
<p>&lt;time.h&gt;         ----------------------   时间和日期</p> 
<p>&lt;wchar.h&gt;      ----------------------   扩展的多字节和宽字符支持</p> 
<p>&lt;wctype.h&gt;     ----------------------   宽字符分类和映射支持</p> 
<p><strong>POSIX标准定义的必须的头文件(26项)</strong></p> 
<p>&lt;dirent.h&gt;      ----------------------   目录项</p> 
<p>&lt;fcntl.h&gt;         ----------------------   文件控制</p> 
<p>&lt;fnmatch.h&gt;   ----------------------   文件名匹配类型</p> 
<p>&lt;glob.h&gt;         ----------------------   路径名模式匹配类型</p> 
<p>&lt;grp.h&gt;          ----------------------   组文件</p> 
<p>&lt;netdb.h&gt;      ----------------------   网络数据库操作</p> 
<p>&lt;pwd.h&gt;         ----------------------   口令文件</p> 
<p>&lt;regex.h&gt;      ----------------------   正则表达式</p> 
<p>&lt;tar.h&gt;           ----------------------   tar归档值</p> 
<p>&lt;termios.h&gt;    ----------------------   终端I/O</p> 
<p>&lt;unistd.h&gt;      ----------------------   符号常量</p> 
<p>&lt;utime.h&gt;       ----------------------   文件时间</p> 
<p>&lt;wordexp.h&gt;   ----------------------   字扩展类型</p> 
<p>&lt;arpa/inet.h&gt;  ----------------------   Internet定义</p> 
<p>&lt;net/if..h&gt;       ----------------------   套接字本地接口</p> 
<p>&lt;netinet/in.h&gt; ----------------------   Internet地址族</p> 
<p>&lt;netinet/tcp.h&gt;----------------------   传输控制协议定义</p> 
<p>&lt;sys/mman.h&gt;----------------------   内存管理声明</p> 
<p>&lt;sys/select.h&gt;----------------------   select函数</p> 
<p>&lt;sys/socket.h&gt;----------------------   套接字接口</p> 
<p>&lt;sys/stat.h&gt;    ----------------------   文件状态</p> 
<p>&lt;sys/times.h&gt;  ----------------------   进程时间</p> 
<p>&lt;sys/types.h&gt;  ----------------------   基本系统数据类型</p> 
<p>&lt;sys/un.h&gt;      ----------------------   UNIX域套接字定义</p> 
<p>&lt;sys/utsname.h&gt;----------------------系统名</p> 
<p>&lt;sys/wait.h&gt;    ----------------------   进程控制</p> 
<p></p> 
<p><strong>POSIX标准定义的XSI扩展头文件(26项)</strong></p> 
<p>&lt;cpio.h&gt;          ----------------------   cpio归档值</p> 
<p>&lt;dlfcn.h&gt;         ----------------------   动态链接</p> 
<p>&lt;fmtmsg.h&gt;     ----------------------   消息显示结构</p> 
<p>&lt;ftw.h&gt;            ----------------------   文件树漫游</p> 
<p>&lt;iconv.h&gt;        ----------------------   代码集转换实用程序</p> 
<p>&lt;langinfo.h&gt;    ----------------------   语言信息常量</p> 
<p>&lt;libgen.h&gt;       ----------------------   模式匹配函数定义</p> 
<p>&lt;monetary.h&gt;  ----------------------   货币类型</p> 
<p>&lt;ndbm.h&gt;        ----------------------   数据库操作</p> 
<p>&lt;nl_types.h&gt;   ----------------------   消息类别</p> 
<p>&lt;poll.h&gt;           ----------------------   轮询函数</p> 
<p>&lt;search.h&gt;      ----------------------   搜索表</p> 
<p>&lt;strings.h&gt;      ----------------------   字符串操作</p> 
<p>&lt;syslog.h&gt;      ----------------------   系统出错日志记录</p> 
<p>&lt;ucontext.h&gt;   ----------------------   用户上下文</p> 
<p>&lt;ulimit.h&gt;        ----------------------   用户限制</p> 
<p>&lt;utmpx.h&gt;       ----------------------   用户帐户数据库</p> 
<p>&lt;sys/ipc.h&gt;      ----------------------   IPC</p> 
<p>&lt;sys/msg.h&gt;    ----------------------   消息队列</p> 
<p>&lt;sys/resource.h&gt;-------------------   资源操作</p> 
<p>&lt;sys/sem.h&gt;    ----------------------   信号量</p> 
<p>&lt;sys/shm.h&gt;    ----------------------   共享存储</p> 
<p>&lt;sys/statvfs.h&gt;----------------------   文件系统信息</p> 
<p>&lt;sys/time.h&gt;    ----------------------   时间类型</p> 
<p>&lt;sys/timeb.h&gt;  ----------------------   附加的日期和时间定义</p> 
<p>&lt;sys/uio.h&gt;      ----------------------   矢量I/O操作</p> 
<p></p> 
<p><strong>POSIX标准定义的可选头文件(8项)</strong></p> 
<p>&lt;aio.h&gt;            ----------------------   异步I/O</p> 
<p>&lt;mqueue.h&gt;    ----------------------   消息队列</p> 
<p>&lt;pthread.h&gt;    ----------------------   线程</p> 
<p>&lt;sched.h&gt;       ----------------------   执行调度</p> 
<p>&lt;semaphore.h&gt;---------------------   信号量</p> 
<p>&lt;spawn.h&gt;       ----------------------   实时spawn接口</p> 
<p>&lt;stropts.h&gt;      ----------------------   XSI STREAMS接口</p> 
<p>&lt;trace.h&gt;         ----------------------   时间跟踪</p> 
<p></p> 
<h2>What is glibc?</h2> 
<p>The GNU C Library project provides <em>the</em> core libraries for the GNU system and GNU/Linux systems, as well as many other systems that use Linux as the kernel. These libraries provide critical APIs including ISO C11, POSIX.1-2008, BSD, OS-specific APIs and more. These APIs include such foundational facilities as open, read, write, malloc, printf, getaddrinfo, dlopen, pthread_create, crypt, login, exit and more.</p> 
<p>The GNU C Library is designed to be a backwards compatible, portable, and high performance ISO C library. It aims to follow all relevant standards including ISO C11, POSIX.1-2008, and IEEE 754-2008.</p> 
<p>The project was started circa 1988 and is more than 30 years old. You can see the complete project <a href="https://sourceware.org/glibc/wiki/Glibc%20Timeline" rel="nofollow" title="release history">release history</a> on the wiki.</p> 
<p>Despite the project's age there is still a lot to do so please <a href="https://www.gnu.org/software/libc/started.html" rel="nofollow" title="Get Started">Get Started</a> and <a href="https://www.gnu.org/software/libc/involved.html" rel="nofollow" title="Get Involved!">Get Involved!</a></p> 
<p></p> 
<p>13、无符号类型和有符号类型进行算术运算和比较运算时，有符号转换为无符号</p> 
<pre><code>    int aa = -1;

	unsigned int bb = 16;

	if (aa &gt; bb)

		cout &lt;&lt; "负数竟然大于正数了！\n";//实际aa转为无符号，大于bb</code></pre> 
<p>但是在算术运算时，无符号和有符号相加，结果一般也不会出什么问题，因为都是补码运算</p> 
<pre><code>    unsigned int b = 1;
	int c = -1;
	printf("%d\n",c + b);//结果为0</code></pre> 
<p></p> 
<p>14,16进制数据可以正数可以负数，</p> 
<pre><code>int a = -0x87654321;//error C4146: 一元负运算符应用于无符号类型，结果仍为无符号类型。原因是编译期首先将0x87654321赋予int，然后看到0x87654321大于INT_MAX，所以将0x87654321赋予unsigned int，然后看到前面有个负号，不能再讲unsigned转为有符号，所以报错

</code></pre> 
<p>但是使用%x输出时会输出其补码，原因是%x默认是输出无符号16进制数据</p> 
<pre><code>    int a = -0x01;
	printf("%x,%d\n", a,a);// ;ffffffff,-1</code></pre> 
<p>可以看到0x87654321虽然超过了MAX_INT，但是使用补码可以存下来，输出的时候用%x可以原封不动输出</p> 
<pre><code>    int a = 0x87654321;
	printf("%x,%d\n", a,a);// ;87654321,-2023406815</code></pre> 
<p></p> 
<p>15、c语言符号</p> 
<p>~表示按位取反</p> 
<p>！表示逻辑取反</p> 
<p>^表示按位异或，异或表示不同为1</p> 
<p></p> 
<p>16，printf家族：</p> 
<p><img alt="" height="523" src="https://images2.imgbox.com/0d/60/DVZ81Hdt_o.png" width="1200"></p> 
<p>printf表示格式化输入到标准输出中。</p> 
<p>sprintf表示格式化输入到字符串中。</p> 
<p>vprintf表示使用可变参数输入到标准输出。</p> 
<p>vsprintf表示使用可变参数输入到字符串中。</p> 
<p>vsnprintf表示使用可变参数输入到限制最大长度的字符串中。</p> 
<p></p> 
<p>17，__attribute__关键字用法和含义</p> 
<p>__attribute__主要用于补充函数和变量的属性，比如限制函数参数类型，限制变量宽度等等，下面给出三个例子：</p> 
<p>1,</p> 
<pre><code>extern int my_printf(void *my_object, const char *my_format, ...) __attribute__((format (printf, 2, 3)));
//摘取printf的定义为 int printf(const char *format, ...)
//archetype=printf:按照printf格式进行检查my_printf
//string-index=2:my_printf的第2个参数(my_format)对应了printf参数中的format
//first-to-check=3:my_printf的第3个参数(...)对应了printf参数中的...
</code></pre> 
<p> 2,</p> 
<pre><code>int y __attribute__((aligned (16))) = 0;
char z[15] __attribute__((aligned (16)));

//aligned应用于基础类型变量和数组时
//编译器对于基础类型变量和数组的编译原则如下：

//系统默认按照变量类型本身占用内存的字节数来对齐边界(地址原则)
//系统按照变量类型本身占用内存来分配内存字节数(内存原则)
//通俗来讲，针对于基础类型变量和数组时，属性限定了变量存储的内存首地址，但是并没有影响变量实际占用
//内存的大小。</code></pre> 
<p>3，</p> 
<pre><code>typedef struct F1{
    char i;
    int j[2] __attribute__((packed));
}F1_T;
//9btyes 

typedef struct F2{
    char i;
    int j[2] __attribute__((packed));
    int k;
}F2_T;
//16btyes

//系统应该为结构体成员按照最小的对齐方式来对齐边界(1bit或者1字节)</code></pre> 
<p>18，mmap使用方法</p> 
<p>mmap主要作用是可以将外设硬件/flash等地址空间映射到当前进程的虚拟地址空间，从而可以通过内存操作来控制外设硬件/flash，常常用于外设驱动当中。</p> 
<p>下面的例子是通过将一个文件映射到当前虚拟地址中，从而可以通过控制一块地址空间实现文件的读写。</p> 
<pre><code class="hljs">#include &lt;sys/mman.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
 
int main()
{
	int fd = open("./file.txt", O_RDWR);//读写权限
	if(fd &lt;= 0)
	{
		perror("\n");
		return -1;
	}
 
	int len = lseek(fd, 0, SEEK_END);//读取文件大小
	void* addr = mmap(NULL, len, PROT_WRITE, MAP_SHARED, fd, 0);//只有文件大小不为空时才能创建成功
	if(addr == MAP_FAILED)
	{
		perror("mmap failed\n");
		return -1;
	}
    close(fd);//内存映射成功后关闭文件描述符依然保持着映射
	const char* str = "hello, world";
	memcpy(addr, str, strlen(str));
	return 0;
}</code></pre> 
<p>此例子使用有以下点需要注意：</p> 
<p>①：映射建立后可以关闭文件描述符</p> 
<p>②：文件大小必须要大于0，并且文件大小映射后不能再改变</p> 
<pre><code class="hljs">$ gcc test_mmap.c -o test_mmap
$ touch file.txt
$ echo "test123" &gt; file.txt
$ ./test_mmap
$ cat file.txt
$ hello wo</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/eadc7c2eefc7ee2d040ca3cb90f9822a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Step7 OB组织块介绍和使用技巧</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3b5c199a59fdd31c8aff628ba936a51f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">UnrealSynth虚幻合成数据生成器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>