<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python类的实例方法、静态方法和类方法区别及其应用场景 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python类的实例方法、静态方法和类方法区别及其应用场景" />
<meta property="og:description" content="python类的实例方法、静态方法和类方法区别及其应用场景
一、先看语法，python 类语法中有三种方法，实例方法，静态方法，类方法。
ps.python中self，cls的区别
普通实例方法，第一个参数需要是self，它表示一个具体的实例本身。
如果用了staticmethod，那么就可以无视这个self，而将这个方法当成一个普通的函数使用。
而对于classmethod，它的第一个参数不是self，是cls，它表示这个类本身。
# coding:utf-8 class Foo(object): &#34;&#34;&#34;类三种方法语法形式&#34;&#34;&#34; def instance_method(self): print(&#34;是类{}的实例方法，只能被实例对象调用&#34;.format(Foo)) @staticmethod def static_method(): print(&#34;是静态方法&#34;) @classmethod def class_method(cls): print(&#34;是类方法&#34;) foo = Foo() foo.instance_method() foo.static_method() foo.class_method() print(&#39;----------------&#39;) Foo.static_method() Foo.class_method() 运行结果如下
是类&lt;class &#39;__main__.Foo&#39;&gt;的实例方法，只能被实例对象调用 是静态方法 是类方法 ---------------- 是静态方法 是类方法 说明：
实例方法只能被实例对象调用，静态方法(由@staticmethod装饰的方法)、类方法(由@classmethod装饰的方法)，可以被类或类的实例对象调用。
实例方法，第一个参数必须要默认传实例对象，一般习惯用self。
静态方法，参数没有要求。
类方法，第一个参数必须要默认传类，一般习惯用cls。
二、静态方法、类方法使用区别或者说使用场景
1、类方法用在模拟java定义多个构造函数的情况。
由于python类中只能有一个初始化方法，不能按照不同的情况初始化类。
参考django https://docs.djangoproject.com/en/1.9/ref/models/instances/ 请看下面的代码。
# coding:utf-8 class Book(object): def __init__(self, title): self.title = title @classmethod def class_method_create(cls, title): book = cls(title=title) return book @staticmethod def static_method_create(title): book= Book(title) return book book1 = Book(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e4ed78770b0d1e70354b62f9e765e085/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-04-14T15:48:00+08:00" />
<meta property="article:modified_time" content="2018-04-14T15:48:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python类的实例方法、静态方法和类方法区别及其应用场景</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>python类的实例方法、静态方法和类方法区别及其应用场景</p> 
<p><strong>一、先看语法，python 类语法中有三种方法，实例方法，静态方法，类方法。</strong></p> 
<p> </p> 
<p>ps.python中self，cls的区别</p> 
<p>普通实例方法，第一个参数需要是self，它表示一个具体的实例本身。<br> 如果用了staticmethod，那么就可以无视这个self，而将这个方法当成一个普通的函数使用。<br> 而对于classmethod，它的第一个参数不是self，是cls，它表示这个类本身。</p> 
<pre class="has"><code class="language-python"># coding:utf-8
class Foo(object):
    """类三种方法语法形式"""

    def instance_method(self):
        print("是类{}的实例方法，只能被实例对象调用".format(Foo))

    @staticmethod
    def static_method():
        print("是静态方法")

    @classmethod
    def class_method(cls):
        print("是类方法")

foo = Foo()
foo.instance_method()
foo.static_method()
foo.class_method()
print('----------------')
Foo.static_method()
Foo.class_method()</code></pre> 
<p>运行结果如下</p> 
<pre class="has"><code class="language-plain">是类&lt;class '__main__.Foo'&gt;的实例方法，只能被实例对象调用
是静态方法
是类方法
----------------
是静态方法
是类方法</code></pre> 
<p>说明：</p> 
<p>实例方法只能被实例对象调用，静态方法(由@staticmethod装饰的方法)、类方法(由@classmethod装饰的方法)，可以被类或类的实例对象调用。</p> 
<p>实例方法，第一个参数必须要默认传实例对象，一般习惯用self。<br> 静态方法，参数没有要求。</p> 
<p>类方法，第一个参数必须要默认传类，一般习惯用cls。</p> 
<p><strong>二、静态方法、类方法使用区别或者说使用场景</strong></p> 
<p> </p> 
<p><strong>1、类方法用在模拟java定义多个构造函数的情况。</strong></p> 
<p> 由于python类中只能有一个初始化方法，不能按照不同的情况初始化类。</p> 
<p>参考django https://docs.djangoproject.com/en/1.9/ref/models/instances/ 请看下面的代码。</p> 
<pre class="has"><code class="language-python"># coding:utf-8
class Book(object):

    def __init__(self, title):
        self.title = title

    @classmethod
    def class_method_create(cls, title):
        book = cls(title=title)
        return book

    @staticmethod
    def static_method_create(title):
        book= Book(title)
        return book

book1 = Book("use instance_method_create book instance")
book2 = Book.class_method_create("use class_method_create book instance")
book3 = Book.static_method_create("use static_method_create book instance")
print(book1.title)
print(book2.title)
print(book3.title)</code></pre> 
<p>结果：</p> 
<pre class="has"><code class="language-plain">use instance_method_create book instance
use class_method_create book instance
use static_method_create book instance

Process finished with exit code 0</code></pre> 
<p>特别说明，静态方法也可以实现上面功能，当静态方法每次都要写上类的名字，不方便。<br><br><strong>2、类中静态方法方法调用静态方法和类方法调用静态方法例子。</strong><br> 下面的代码，静态方法调用另一个静态方法，如果改用类方法调用静态方法，可以让cls代替类，</p> 
<p>让代码看起来精简一些。也防止类名修改了，不用在类定义中修改原来的类名。</p> 
<pre class="has"><code class="language-python"># coding:utf-8
class Foo(object):
    X = 1
    Y = 2

    @staticmethod
    def averag(*mixes):
        return sum(mixes) / len(mixes)

    @staticmethod
    def static_method():  # 在静态方法中调用静态方法
        print "在静态方法中调用静态方法"
        return Foo.averag(Foo.X, Foo.Y)

    @classmethod
    def class_method(cls):  # 在类方法中使用静态方法
        print "在类方法中使用静态方法"
        return cls.averag(cls.X, cls.Y)

foo = Foo()
print(foo.static_method())
print(foo.class_method())</code></pre> 
<p>结果：</p> 
<blockquote> 
 <p>在静态方法中调用静态方法<br> 1<br> 在类方法中使用静态方法<br> 1</p> 
</blockquote> 
<p><strong>3、继承类中的区别 </strong></p> 
<p>从下面代码可以看出，如果子类继承父类的方法，子类覆盖了父类的静态方法，<br> 子类的实例继承了父类的static_method静态方法，调用该方法，还是调用的父类的方法和类属性。</p> 
<p>子类的实例继承了父类的class_method类方法，调用该方法，调用的是子类的方法和子类的类属性。</p> 
<pre class="has"><code class="language-python"># coding:utf-8
class Foo(object):
    X = 1
    Y = 14

    @staticmethod
    def averag(*mixes):  # "父类中的静态方法"
        return sum(mixes) / len(mixes)

    @staticmethod
    def static_method():  # "父类中的静态方法"
        print "父类中的静态方法"
        return Foo.averag(Foo.X, Foo.Y)

    @classmethod
    def class_method(cls):  # 父类中的类方法
        print "父类中的类方法"
        return cls.averag(cls.X, cls.Y)


class Son(Foo):
    X = 3
    Y = 5

    @staticmethod
    def averag(*mixes):  # "子类中重载了父类的静态方法"
        print "子类中重载了父类的静态方法"
        print "666 ",mixes
        return sum(mixes) / 3

p = Son()
print "result of p.averag(1,5)"
print (p.averag(1,5))
print "result of p.static_method()"
print(p.static_method())
print "result of p.class_method()"
print(p.class_method())</code></pre> 
<p>结果如下：</p> 
<blockquote> 
 <p>result of p.averag(1,5)<br> 子类中重载了父类的静态方法<br> 666  (1, 5)<br> 2<br> result of p.static_method()<br> 父类中的静态方法<br> 7<br> result of p.class_method()<br> 父类中的类方法<br> 子类中重载了父类的静态方法<br> 666  (3, 5)<br> 2</p> 
 <p>Process finished with exit code 0</p> 
</blockquote> 
<p>参考网址：https://zhuanlan.zhihu.com/p/21101992</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/489a1875c9a4ee7a210666e7a215febb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在Windows中利用socket进行一次、循环传输数据</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/80fc33d7307796d3d8359dd41fef7662/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">四款好用的免费直播编码推流软件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>