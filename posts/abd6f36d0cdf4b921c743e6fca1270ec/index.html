<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>安卓开发 Fragment的简单使用与解析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="安卓开发 Fragment的简单使用与解析" />
<meta property="og:description" content="1.Fragment的简介：
Fragment是Android3.0以后引入的新的api，为了适配大屏的平板。
在普通手机开发的过程中，使用Fragment能实现一个界面的多次使用，能加快效率。Fragment可以被认为是Activity界面的一个布局，其依赖于Activity，但是拥有自己的活动事件与生命周期。可以通过替换Activity中的Fragment实现界面的优化处理。
现在Android提供一下两种包，在一个项目中最好使用同一个包下的Fragment，否则会出现一些不兼容问题，例如V4包不支持属性动画，app包下的不支持逐帧动画等
android.app.Fragment 兼容的最低版本是android:minSdkVersion=”11” 即3.0版。
android.support.v4.app.Fragment 兼容的最低版本是android:minSdkVersion=”4” 即1.6版。
2.Fragment的生命周期，依赖于Activity
可以看到Fragment比Activity多了几个额外的生命周期回调方法：
onAttach(Activity)
当Fragment与Activity发生关联时调用。
onCreateView(LayoutInflater, ViewGroup,Bundle)
创建该Fragment的视图
onActivityCreated(Bundle)
当Activity的onCreate方法返回时调用
onDestoryView()
与onCreateView想对应，当该Fragment的视图被移除时调用
onDetach()
与onAttach相对应，当Fragment与Activity关联被取消时调用
也就是Fragment的创建与删除过程都是先链接（Attach）到Avtivity，再创建视图（View）
注意：除了onCreateView，其他的所有方法如果你重写了，必须调用父类对于该方法的实现
3.Fragment的三个常用类
android.app.Fragment 主要用于定义Fragment
android.app.FragmentManager 主要用于在Activity中操作Fragment
android.app.FragmentTransaction 对Fragment进行增加删除等操作
a.得到Fragment
getFragmentManager() // v4中，getSupportFragmentManager
b.使用FragmentTransaction 操作Fragment的基本用法
transaction.add() 往Activity中添加一个Fragment
transaction.remove()
从Activity中移除一个Fragment，如果被移除的Fragment没有添加到回退栈，这个Fragment实例将会被销毁。
transaction.replace()
使用另一个Fragment替换当前的，实际上就是remove()然后add()的合体
transaction.hide()
隐藏当前的Fragment，仅仅是设为不可见，并不会销毁
transaction.show()
显示之前隐藏的Fragment
detach()
会将view从UI中移除,和remove()不同,此时fragment的状态依然由FragmentManager维护。
attach()
重建view视图，附加到UI上并显示。
transatcion.commit()//提交一个事务，注意一定要在onSaveInstance()前面执行，否则会出现stateloss异常
上述，基本是操作Fragment的所有的方式了，在一个事务开启到提交可以进行多个的添加、移除、替换等操作
4.Fragment的使用
1.静态的使用
步骤：
创建fragment的xml
自定义Fragment继承自Fragment，在其中绑定fragment的视图，写fragment自己的事件
再Activity的xml中通过id引用该fragment
评价：
简单易用，直接引用对应的Fragment就好，但是如果一个屏幕中只有一个且需要切换Fragment就不方便使用。此时需要动态使用Fragment
静态使用Fragment的例子：
fragment_one.xml
&lt;RelativeLayout android:background=&#34;@color/colorAccent&#34; xmlns:android=&#34;http://schemas.android.com/apk/res/android&#34; android:layout_width=&#34;match_parent&#34; android:layout_height=&#34;match_parent&#34;&gt; &lt;Button android:id=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/abd6f36d0cdf4b921c743e6fca1270ec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-09-13T10:46:29+08:00" />
<meta property="article:modified_time" content="2018-09-13T10:46:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">安卓开发 Fragment的简单使用与解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>1.Fragment的简介：</strong></p> 
<p>Fragment是Android3.0以后引入的新的api，为了适配大屏的平板。</p> 
<p>在普通手机开发的过程中，使用Fragment能实现一个界面的多次使用，能加快效率。Fragment可以被认为是Activity界面的一个布局，其依赖于Activity，但是拥有自己的活动事件与生命周期。可以通过替换Activity中的Fragment实现界面的优化处理。</p> 
<p>现在Android提供一下两种包，在一个项目中最好使用同一个包下的Fragment，<span style="color:#f33b45;">否则会出现一些不兼容问题，例如V4包不支持属性动画，app包下的不支持逐帧动画等</span></p> 
<p>android.app.Fragment 兼容的最低版本是android:minSdkVersion=”11” 即3.0版。</p> 
<p>android.support.v4.app.Fragment 兼容的最低版本是android:minSdkVersion=”4” 即1.6版。</p> 
<p> </p> 
<p><strong>2.Fragment的生命周期，依赖于Activity</strong></p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/43/bd/43CEXATy_o.png"></p> 
<p>可以看到Fragment比Activity多了几个额外的生命周期回调方法：</p> 
<p><strong>onAttach(Activity)</strong></p> 
<p>当Fragment与Activity发生关联时调用。</p> 
<p><strong>onCreateView(LayoutInflater, ViewGroup,Bundle)</strong></p> 
<p>创建该Fragment的视图</p> 
<p><strong>onActivityCreated(Bundle)</strong></p> 
<p>当Activity的onCreate方法返回时调用</p> 
<p><strong>onDestoryView()</strong></p> 
<p>与onCreateView想对应，当该Fragment的视图被移除时调用</p> 
<p><strong>onDetach()</strong></p> 
<p>与onAttach相对应，当Fragment与Activity关联被取消时调用</p> 
<p><span style="color:#f33b45;">也就是Fragment的创建与删除过程都是先链接（Attach）到Avtivity，再创建视图（View）</span></p> 
<p>注意：除了onCreateView，其他的所有方法如果你重写了，必须调用父类对于该方法的实现</p> 
<p> </p> 
<p> </p> 
<p><strong>3.Fragment的三个常用类</strong></p> 
<p>android.app.Fragment 主要用于定义Fragment</p> 
<p>android.app.FragmentManager 主要用于在Activity中操作Fragment</p> 
<p>android.app.FragmentTransaction 对Fragment进行增加删除等操作</p> 
<p><strong>a.得到Fragment</strong></p> 
<p>getFragmentManager() // v4中，getSupportFragmentManager</p> 
<p><strong>b.使用FragmentTransaction 操作Fragment的基本用法</strong></p> 
<p>transaction.add() </p> 
<p>往Activity中添加一个Fragment</p> 
<p>transaction.remove()</p> 
<p>从Activity中移除一个Fragment，如果被移除的Fragment没有添加到回退栈，这个Fragment实例将会被销毁。</p> 
<p>transaction.replace()</p> 
<p>使用另一个Fragment替换当前的，实际上就是remove()然后add()的合体</p> 
<p>transaction.hide()</p> 
<p>隐藏当前的Fragment，仅仅是设为不可见，并不会销毁</p> 
<p>transaction.show()</p> 
<p>显示之前隐藏的Fragment</p> 
<p>detach()</p> 
<p>会将view从UI中移除,和remove()不同,<span style="color:#f33b45;">此时fragment的状态依然由FragmentManager维护。</span></p> 
<p>attach()</p> 
<p>重建view视图，附加到UI上并显示。</p> 
<p>transatcion.commit()//提交一个事务，注意一定要在onSaveInstance()前面执行，否则会出现stateloss异常</p> 
<p>上述，基本是操作Fragment的所有的方式了，在一个事务开启到提交可以进行多个的添加、移除、替换等操作</p> 
<p> </p> 
<p> </p> 
<p><strong>4.Fragment的使用</strong></p> 
<p>1.静态的使用</p> 
<p>步骤：</p> 
<p>创建fragment的xml</p> 
<p>自定义Fragment继承自Fragment，在其中绑定fragment的视图，写fragment自己的事件</p> 
<p>再Activity的xml中通过id引用该fragment</p> 
<p>评价：</p> 
<p>简单易用，直接引用对应的Fragment就好，但是如果一个屏幕中只有一个且需要切换Fragment就不方便使用。此时需要动态使用Fragment</p> 
<p> </p> 
<p>静态使用Fragment的例子：</p> 
<p>fragment_one.xml</p> 
<pre class="has"><code>&lt;RelativeLayout
    android:background="@color/colorAccent"
    xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent"
    android:layout_height="match_parent"&gt;

    &lt;Button
        android:id="@+id/fragment_Btn1"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_centerInParent="true"
        android:text="One"
        /&gt;
&lt;/RelativeLayout&gt;</code></pre> 
<p>Fragment_One.java</p> 
<pre class="has"><code>public class Fragment_One extends Fragment {
    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {
        View view=inflater.inflate(R.layout.fragment_one,container,false);
        return view;
    }
}</code></pre> 
<p>Activity_Main.java</p> 
<pre class="has"><code>&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".Fragment.Fragment_Main"&gt;
  &lt;fragment
    android:id="@+id/main_fragment"
    android:name="com.example.zhang.androidtestdemo01.Fragment.Fragment_One"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    /&gt;
&lt;/FrameLayout&gt;</code></pre> 
<p><img alt="" class="has" height="326" src="https://images2.imgbox.com/c9/fb/3q3quOGC_o.png" width="179"></p> 
<p> </p> 
<p>2.动态Fragment的使用</p> 
<p>步骤：</p> 
<p>创建fragment的xml</p> 
<p>自定义Fragment继承自Fragment，在其中绑定fragment的视图，写fragment自己的事件</p> 
<p>在Activity的xml文件中加入一个空布局，用于加载fragment</p> 
<p>在Activity的java文件中使用api中的方法引入fragment</p> 
<p>评价：</p> 
<p>能动态加载需要的布局，但是后面还能对其优化</p> 
<p> </p> 
<p>Fragment_Two和Fragment_One的布局一样，就不贴了</p> 
<p>activity_main.xml</p> 
<pre class="has"><code>&lt;FrameLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".Fragment.Fragment_Main"&gt;
    &lt;FrameLayout
        android:id="@+id/fragment_content"
        android:layout_width="match_parent"
        android:layout_height="match_parent"&gt;
    &lt;/FrameLayout&gt;
&lt;Button
    android:id="@+id/main_btn"
    android:layout_width="match_parent"
    android:text="click to fragment two"
    android:layout_height="40dp" /&gt;
&lt;/FrameLayout&gt;</code></pre> 
<p>MainActivity .java</p> 
<pre class="has"><code>public class MainActivity extends AppCompatActivity{
    private Fragment_One mFOne;
    private Fragment_Two mFTwo;
    private Button mBtn;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        mFOne=new Fragment_One();
        FragmentManager fm=getFragmentManager();
        FragmentTransaction tx=fm.beginTransaction();
        tx.add(R.id.fragment_content,mFOne,"ONE");
        tx.commit();

        mBtn=findViewById(R.id.main_btn);
        mBtn.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                mFTwo=new Fragment_Two();
                FragmentManager fm=getFragmentManager();
                FragmentTransaction tx=fm.beginTransaction();
                tx.replace(R.id.fragment_content,mFTwo,"Two");
                tx.commit();
            }
        });
    }
}</code></pre> 
<p><img alt="" class="has" height="287" src="https://images2.imgbox.com/04/46/Jo4X7YSI_o.png" width="156"><img alt="" class="has" height="286" src="https://images2.imgbox.com/1e/0b/qWHIur7J_o.png" width="157"></p> 
<p> </p> 
<p>3.Fragment中实现事件的上交，让Activity来控制Fragment中的具体事件，两种实现方式，区别在于第二种需要在创建该对象的时候调用setfTwoBtnListener()（例子中Fragment_Two由Fragment_One跳转过去，所以在Fragment_One的点击事件中设置监听）</p> 
<p>第一种方式：Fragment_One.java</p> 
<pre class="has"><code>public class Fragment_One extends Fragment implements View.OnClickListener {
    public interface FOneBtnListener{
        void onFOneBtnClick();
    }
    private Button button;
    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle 
    savedInstanceState) {
        View view=inflater.inflate(R.layout.fragment_one,container,false);
        button=view.findViewById(R.id.fragment_Btn1);
        button.setOnClickListener(this);
        return view;
    }

    @Override
    public void onClick(View v) {
        //若实现了这个接口，就可以用，把事件交给Activity来做
        if (getActivity() instanceof FOneBtnListener){
            ((FOneBtnListener) getActivity()).onFOneBtnClick();
        }
    }
}</code></pre> 
<p>这时，只要Activity实现了FOneBtnListener这个接口，就可以直接在onFOneBtnClick()里写事件了</p> 
<p>第二种方式：Fragment_Two.java</p> 
<pre class="has"><code>public class Fragment_Two extends Fragment implements View.OnClickListener {
    public FTwoBtnListener fTwoBtnListener;
    public interface FTwoBtnListener{
        void onFTwoBtnClick();
    }
    //显式设置
    public void setfTwoBtnListener(FTwoBtnListener x){
        this.fTwoBtnListener=x;
    }

    private Button button;
    @Nullable
    @Override
    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle 
    savedInstanceState) {
        View view=inflater.inflate(R.layout.fragment_two,container,false);
        button=view.findViewById(R.id.fragment_Btn2);
        button.setOnClickListener(this);
        return view;
    }
    @Override
    public void onClick(View v) {
        //若实现了这个接口，就可以用，把事件交给Activity来做
        if(fTwoBtnListener != null)
        {
            fTwoBtnListener.onFTwoBtnClick();
        }
    }
}</code></pre> 
<p>Fragment_Two要求调用者显式的设置listener</p> 
<p>Fragment_Main.java（Fragment_Two就是最简单的Fragment_One）</p> 
<pre class="has"><code>public class Fragment_Main extends AppCompatActivity implements Fragment_One.FOneBtnListener,Fragment_Two.FTwoBtnListener{
    private Fragment_One mFOne;
    private Fragment_Two mFTwo;
    private Fragment_Three mFThree;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_fragment__main);
        mFOne=new Fragment_One();
        FragmentManager fm=getFragmentManager();
        FragmentTransaction tx=fm.beginTransaction();
        tx.add(R.id.fragment_content,mFOne,"ONE");
        tx.commit();
    }
    //Fragment_One的点击事件，跳转到Fragment_Two
    @Override
    public void onFOneBtnClick() {
        if (mFTwo==null){
            mFTwo=new Fragment_Two();
            mFTwo.setfTwoBtnListener(this);
            //必须显示调用，因为在Fragment_Twoz中写了只有设置监听才能用
        }
        FragmentManager fm=getFragmentManager();
        FragmentTransaction tx=fm.beginTransaction();
        tx.replace(R.id.fragment_content,mFTwo,"Two");
        tx.addToBackStack(null);//回退栈，加了后点击返回键可以返回到上一个fragment
        tx.commit();
    }
    //Fragment_Two的点击事件，跳转到上面的Fragment_Three
    @Override
    public void onFTwoBtnClick() {
        if (mFThree==null){
            mFThree=new Fragment_Three();
        }
        FragmentManager fm=getFragmentManager();
        FragmentTransaction tx=fm.beginTransaction();
        tx.hide(mFTwo);
        tx.add(R.id.fragment_content,mFThree,"Three");
        tx.addToBackStack(null);//回退栈，加了后点击返回键可以返回到上一个fragment
        tx.commit();
    }
}</code></pre> 
<p>到此完成了事件的上交，实现通过Acitivity来控制Fragment，效果和之前一样</p> 
<p>其他的例如Activity屏幕旋转后fragment会多次创建，数据的保存等问题，详见鸿洋的博客以及腾讯Bugly团队的文章</p> 
<p> </p> 
<p> </p> 
<p>传送门：</p> 
<p><a href="https://blog.csdn.net/lmj623565791/article/details/37992017">https://blog.csdn.net/lmj623565791/article/details/37992017</a></p> 
<p><a href="https://blog.csdn.net/wuyuxing24/article/details/78698633">https://blog.csdn.net/wuyuxing24/article/details/78698633</a></p> 
<p><a href="https://mp.weixin.qq.com/s/dUuGSVhWinAnN9uMiBaXgw" rel="nofollow">https://mp.weixin.qq.com/s/dUuGSVhWinAnN9uMiBaXgw</a></p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ecfbe9d2a001cbcf1e719f96dd9cea01/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">stm32学习笔记---ADC电压采集</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/61c9f47bcc1ca8340434df8e3b92ebd9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python模块学习——logging</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>