<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Word Search - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Word Search" />
<meta property="og:description" content="Given a 2D board and a word, find if the word exists in the grid.
The word can be constructed from letters of sequentially adjacent cell, where &#34;adjacent&#34; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.
For example,
Given board = [ [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;], [&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;], [&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;] ] word = &#34;ABCCED&#34;, -&gt; returns true,
word = &#34;SEE&#34;, -&gt; returns true,
word = &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/00f18f45a4c392585c784b5209d10a1e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-03T04:34:59+08:00" />
<meta property="article:modified_time" content="2019-07-03T04:34:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Word Search</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>Given a 2D board and a word, find if the word exists in the grid.</p> 
 <p>The word can be constructed from letters of sequentially adjacent cell, where "adjacent" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p> 
 <p>For example,<br>Given board = </p> 
 <pre>[
  ['A','B','C','E'],
  ['S','F','C','S'],
  ['A','D','E','E']
]
</pre> 
 <p>word = <code>"ABCCED"</code>, -&gt; returns <code>true</code>,<br>word = <code>"SEE"</code>, -&gt; returns <code>true</code>,<br>word = <code>"ABCB"</code>, -&gt; returns <code>false</code>.</p> 
 <p>在二维矩阵里搜索单词，显然是把这个二维的矩阵当作图来操作的，以二维矩阵的每一个点开始做DFS，看能否找到单词，遇到不符合的情况则回退，不再向下进行。因为题目要求同一个字母单元不能被重复使用，所以需要维护一个visited矩阵，将此次DFS过程中用到的点都置为True。当处理完一次路径，需要将该路径经过的所有结点的visited都置为False。一遍别的路径使用。代码如下：</p> 
 <div class="cnblogs_code"> 
  <pre><span style="color:#0000ff;">class</span><span style="color:#000000;"> Solution(object):
    </span><span style="color:#0000ff;">def</span><span style="color:#000000;"> exist(self, board, word):
        </span><span style="color:#800000;">"""</span><span style="color:#800000;">
        :type board: List[List[str]]
        :type word: str
        :rtype: bool
        </span><span style="color:#800000;">"""</span>
        <span style="color:#0000ff;">if</span> <span style="color:#0000ff;">not</span> board <span style="color:#0000ff;">and</span><span style="color:#000000;"> word:
            </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> False
        </span><span style="color:#0000ff;">if</span> <span style="color:#0000ff;">not</span> board <span style="color:#0000ff;">and</span> <span style="color:#0000ff;">not</span><span style="color:#000000;"> word:
            </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> True
        visited </span>= [[False] * len(board[0]) <span style="color:#0000ff;">for</span> i <span style="color:#0000ff;">in</span><span style="color:#000000;"> xrange(len(board))]
        </span><span style="color:#0000ff;">for</span> i <span style="color:#0000ff;">in</span><span style="color:#000000;"> xrange(len(board)):
            </span><span style="color:#0000ff;">for</span> j <span style="color:#0000ff;">in</span><span style="color:#000000;"> xrange(len(board[0])):
                </span><span style="color:#0000ff;">if</span><span style="color:#000000;">  self.search(board, visited, word, 0, i, j):
                    </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> True
        </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> False
        
    </span><span style="color:#0000ff;">def</span><span style="color:#000000;"> search(self, board, visited, word, i, x, y):
        </span><span style="color:#0000ff;">if</span> i ==<span style="color:#000000;"> len(word):
            </span><span style="color:#0000ff;">return</span><span style="color:#000000;"> True
        </span><strong><span style="color:#0000ff;">if</span> x &lt; 0 <span style="color:#0000ff;">or</span> y &lt; 0 <span style="color:#0000ff;">or</span> x &gt;= len(board) <span style="color:#0000ff;">or</span> y &gt;= len(board[0]) <span style="color:#0000ff;">or</span> visited[x][y] <span style="color:#0000ff;">or</span> word[i] !=<span style="color:#000000;"> board[x][y]: #越界，已访问，不等于原有单词这三种情况不进行处理．
            </span></strong><span style="color:#0000ff;">return</span><span style="color:#000000;"> False
        visited[x][y] </span>=<span style="color:#000000;"> True
        res </span>= self.search(board, visited, word, i+1, x+1, y) <span style="color:#0000ff;">or</span><span style="color:#000000;"> \
              self.search(board, visited, word, i</span>+1, x, y+1) <span style="color:#0000ff;">or</span><span style="color:#000000;"> \
              self.search(board, visited, word, i</span>+1, x-1, y) <span style="color:#0000ff;">or</span><span style="color:#000000;"> \
              self.search(board, visited, word, i</span>+1, x, y-1<span style="color:#000000;">)
        visited[x][y] </span>=<span style="color:#000000;"> False
        </span><span style="color:#0000ff;">return</span> res</pre> 
 </div> 
 <p>这题最坏一共进行O(m*n)次遍历。每次DFS的顶点数为m*n,边数也为m*n,总的时间复杂度为O(m*n) (O(V+E). 所以时间复杂度最坏是O(m^2*n^2).空间复杂度是栈的高度和visited矩阵中的比较大的值。O(m*n).栈高度最高也是O(m*n)级别的。</p> 
</div> 
<p>转载于:https://www.cnblogs.com/sherylwang/p/5641718.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f46cbeb0e6e835632567edd3ea0f8163/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">《oracle大型数据库系统在AIX/unix上的实战详解》讨论十二：关于读书</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0c2a0701998f3c8d895cb8e0d715b375/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">IOS  UItableView 滚动到底 触发事件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>