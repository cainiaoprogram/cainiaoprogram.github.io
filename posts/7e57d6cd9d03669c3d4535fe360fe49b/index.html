<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Express.js 与 Nest.js对比 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Express.js 与 Nest.js对比" />
<meta property="og:description" content="Express.js 与 Nest.js对比 自从 Node.js 发布以来，Javascript 在后端领域的使用有所增加。由于 Node.js 的使用越来越多，每天都会有新的框架和工具发布。Express 和 Nest 是使用 Node.js 创建后端应用程序的最著名的框架之一，在本文中，我们将对它们进行比较。
Express Express 是 Node.js 的简约框架。尽管它涵盖了创建服务器端应用程序的几个核心方面，但由于其简单性、灵活性和性能，它很流行，甚至 Nest 也是构建在 Express 之上的。但是，express 仍然存在一些问题，在我们深入研究这些问题之前，我们需要了解它们为我们提供了什么，让我们不使用任何框架而仅使用 Node.js 创建一个 Web 服务器。
const http = require(&#34;node:http&#34;); // Create a local server to receive data from const server = http.createServer((req, res) =&gt; { res.writeHead(200, { &#34;Content-Type&#34;: &#34;application/json&#34; }); res.end(JSON.stringify({ message: &#34;Hello World!&#34; })); }); server.listen(8000); 在上面的代码中，我们使用 Node.js 中内置的 HTTP 模块创建一个 Web 服务器。如果我们向http://localhost:8000发送 Web 请求，将从我们的 Node." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7e57d6cd9d03669c3d4535fe360fe49b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-17T22:32:49+08:00" />
<meta property="article:modified_time" content="2023-11-17T22:32:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Express.js 与 Nest.js对比</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Expressjs__Nestjs_0"></a>Express.js 与 Nest.js对比</h2> 
<p>自从 <code>Node.js</code> 发布以来，<code>Javascript</code> 在后端领域的使用有所增加。由于 <code>Node.js</code> 的使用越来越多，每天都会有新的框架和工具发布。<code>Express</code> 和 <code>Nest</code> 是使用 <code>Node.js</code> 创建后端应用程序的最著名的框架之一，在本文中，我们将对它们进行比较。</p> 
<h3><a id="Express_4"></a>Express</h3> 
<p><code>Express</code> 是 <code>Node.js</code> 的简约框架。尽管它涵盖了创建服务器端应用程序的几个核心方面，但由于其简单性、灵活性和性能，它很流行，甚至 <code>Nest</code> 也是构建在 <code>Express</code> 之上的。但是，<code>express</code> 仍然存在一些问题，在我们深入研究这些问题之前，我们需要了解它们为我们提供了什么，让我们不使用任何框架而仅使用 <code>Node.js</code> 创建一个 <code>Web</code> 服务器。</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"node:http"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Create a local server to receive data from</span>
<span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  res<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{<!-- --></span> <span class="token string-property property">"Content-Type"</span><span class="token operator">:</span> <span class="token string">"application/json"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  res<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">"Hello World!"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>在上面的代码中，我们使用 <code>Node.js</code> 中内置的 <code>HTTP</code> 模块创建一个 <code>Web</code> 服务器。如果我们向<code>http://localhost:8000</code>发送<code> Web</code> 请求，将从我们的 <code>Node.js</code> 服务器收到一条消息 (<code>Hello World</code>)。</p> 
<p>这很简单，但是如果我们想创建一个包含数百条不同路由的 <code>REST API</code> 该怎么办？然后我们必须编写一个路由匹配器并将每个路由发送到其特定的控制器。另外，我们必须实现 <code>GET</code>、<code>POST</code>、<code>PUT</code> 等 <code>HTTP</code> 方法来满足 <code>REST</code> 标准，对吗？<code>Express</code> 所做的正是这个，<code>express</code> 为我们处理请求/响应控制、路由、提供静态文件和中间件。这就是 <code>Express</code> 如此轻量和简单的美妙之处。现在让我们看看如何使用<code>express</code> 创建之前的应用程序。</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"express"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> <span class="token literal-property property">message</span><span class="token operator">:</span> <span class="token string">"Hello World"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>上面的代码也做了同样的事情。但是<code>express</code>为我们提供了一个与请求的<code>URL</code>匹配的路由机制，所以如果我们想使用<code>express router</code>创建一个<code>cat</code>路由，它会看起来像这样。</p> 
<pre><code class="prism language-js"><span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"express"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> router <span class="token operator">=</span> express<span class="token punctuation">.</span><span class="token function">Router</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

router<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"Hello Cats"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

router<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">"/create"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{<!-- --></span>
  res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">"Create New Cat!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">"/cats"</span><span class="token punctuation">,</span> router<span class="token punctuation">)</span><span class="token punctuation">;</span>
app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这很好，但是<code>Express</code>有什么问题呢？<code>Express</code> 非常简约且直接，为用户提供了灵活性。灵活性对于有经验的用户或复杂的场景非常有利，但灵活性会导致错误和结构错误的增加。此外，现在的应用程序需要大量额外的逻辑，例如请求验证、授权、文档、测试、日志记录等。因此，<code>Express</code> 只为我们提供了一些功能，人们需要使用其他库或框架来解决这些需求。这就是 <code>Nest.js</code> 存在的原因。</p> 
<h3><a id="Nest_56"></a>Nest</h3> 
<p><code>Nest</code> 是一个用于构建高效、可扩展的 <code>Node.js</code> 服务器端应用程序的框架。<code>Nest</code> 构建在常见 <code>Node.js</code> 框架（<code>Express</code>、<code>Fastify</code>）之上。它使用渐进式 <code>JavaScript</code>，使用 <code>TypeScript</code> 构建并完全支持 <code>TypeScript</code>（但仍然允许开发人员使用纯 <code>JavaScript</code> 进行编码），并结合了 <code>OOP</code>（面向对象编程）、<code>FP</code>（函数式编程）和 <code>FRP</code>（函数式反应式编程）的元素。</p> 
<p><code>Nest</code> 在这些常见 <code>Node.js</code> 框架（<code>Express/Fastify</code>）之上提供抽象，并将其<code> API</code> 直接公开给开发人员。这使开发人员可以自由地使用可用于底层平台的无数第三方模块。<code>Nest</code> 的目的是创建高度可测试、可扩展、松散耦合且易于维护的应用程序。</p> 
<p>为了证明这一点，让我们使用 <code>Nest</code> 重构之前的应用：</p> 
<pre><code class="prism language-js"><span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> Controller<span class="token punctuation">,</span> Get<span class="token punctuation">,</span> Post <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
@<span class="token function">Controller</span><span class="token punctuation">(</span><span class="token string">'cat'</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatController</span> <span class="token punctuation">{<!-- --></span>
  @<span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function">getCats</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token string">'Hello World'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  @<span class="token function">Post</span><span class="token punctuation">(</span><span class="token string">'create'</span><span class="token punctuation">)</span>
  <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token string">'Create New Cat!'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>Nest</code> 的路由方法与控制器配合使用，控制器可以组织路由并使路由更清晰、更易于管理。<code>Nest</code> 有一个默认的错误处理程序和其他内置实用程序，可帮助我们快速入门。当然，可以用<code>express</code>手动实现它们，但不需要重新发明轮子。所有这些便利设置使 <code>Nest</code> 成为初学者的更好选择，因为这些核心实用程序对于初学者来说可能很难理解。</p> 
<h3><a id="_81"></a>对比</h3> 
<p>现在我们了解了这些框架的基础知识，让我们深入了解、对比一下<code>Express</code>和<code>Next</code>。</p> 
<h4><a id="1__86"></a>1. 架构</h4> 
<p>在 <code>Express</code> 中，没有架构标准。这在许多大型项目或微服务应用程序中成为一个问题，因为它们需要强大而灵活的架构来保持应用程序的可维护性。</p> 
<p>另一方面，<code>Nest</code> 最强大的一面是架构，因为 <code>Nest</code> 有许多实用程序来提供灵活、干净且​​强大的架构。<code>Nest-Modules</code> 就是一个很好的例子。<code>Nest-Module</code> 用于组织应用程序结构并帮助开发人员管理模块的依赖关系。</p> 
<p><code>Nest</code> 还非常适合应用 N 层架构，旨在将应用程序划分为逻辑层。层是一种分离职责和管理依赖关系以实现关注点分离 (<code>SoC</code>) 原则的方法。为了实现这一目标，<code>Nest</code> 建议调用控制器内的服务层，并在这些服务层内执行所有业务逻辑。对于服务层，调用另一个层称为存储库层，该层负责数据访问。因此，我们将我们的关注点分为三层。分离这些层可以为软件提供可重用性和可维护性。它还使我们的应用程序易于测试，</p> 
<p>我们创建的<code>cat</code>路由，它可能看起来像这样：</p> 
<p>CatController -&gt; CatService -&gt; CatRepository</p> 
<p><img src="https://images2.imgbox.com/83/13/lnW3OCAA_o.png" alt="在这里插入图片描述"><br> 因此，每当我们需要在任何控制器中调用 <code>CatService</code> 的方法时，我们只需创建 <code>CatService</code> 的实例并调用该方法，或者我们可以通过将 <code>CatService</code> 实例作为 <code>CatController</code> 构造函数的参数传递来使用现有的 <code>CatService</code> 实例，即<code>Nest</code>还有一个概念叫做依赖注入。</p> 
<h4><a id="2__100"></a>2. 依赖注入</h4> 
<blockquote> 
 <p>依赖注入是一种设计模式，其中一个对象接收它所依赖的其他对象。依赖注入是控制反转的一种形式，旨在分离构造对象和使用对象的关注点，从而导致松散耦合的程序。</p> 
</blockquote> 
<p>在 <code>Nest</code> 中，可以通过在要注入的模块顶部添加 <code>Injectable</code> 装饰器来使用依赖注入。例如</p> 
<pre><code class="prism language-js"><span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> Injectable <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
@<span class="token function">Injectable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatService</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token string">'Hello World'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token string">'Create New Cat!'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-js"><span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> Controller<span class="token punctuation">,</span> Get<span class="token punctuation">,</span> Post <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@nestjs/common'</span><span class="token punctuation">;</span>
<span class="token keyword">import</span> <span class="token punctuation">{<!-- --></span> CatService <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./cat.service'</span><span class="token punctuation">;</span>

@<span class="token function">Controller</span><span class="token punctuation">(</span><span class="token string">'cat'</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">CatController</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token keyword">private</span> readonly catService<span class="token operator">:</span> CatService</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>

  @<span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token function">getCats</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>catService<span class="token punctuation">.</span><span class="token function">findAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  @<span class="token function">Post</span><span class="token punctuation">(</span><span class="token string">'create'</span><span class="token punctuation">)</span>
  <span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>catService<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>正如我们所看到的，我们将 <code>catService</code> 实例作为参数传递给 <code>CatController</code> 的构造函数。这种方法使应用程序更易于维护且易于测试，尤其是对于大型应用程序。这是使用 <code>Nest</code> 的最大优势之一。</p> 
<h4><a id="3__141"></a>3. 中间件</h4> 
<p>默认情况下，<code>Nest</code> 中间件相当于 <code>Express</code> 中间件。在 <code>Express</code> 中间件中，我们只需创建另一个在控制器之前/之后运行的路由处理程序。<code>Nest</code> 有一个<code>MiddlewareConsumer</code>类，它是一个辅助类。它提供了几种内置方法来管理中间件。所有这些都可以简单地以流畅的方式链接起来。<code>MiddlewareConsumer</code> 有一个<code>forRoutes</code>属性，我们可以在其中简单地输入字符串或控制器的路径来注册中间件。<code>Nest</code> 还有一个<code>exclude</code>属性，可以帮助我们排除路径或控制器。</p> 
<p><code>Nest</code> 还提供类似中间件的实用程序，例如管道、过滤器和拦截器。它们可以被认为是中间件，但它们更专注于不同的目的。例如，管道主要用于验证和数据转换。另一方面，中间件是在路由处理程序之前运行的处理程序，并且可以访问请求对象。过滤器与中间件相反。它们在路由处理程序之后运行并操作响应对象以进行错误处理等。最后，拦截器可以在调用路由处理程序之前和之后访问请求和响应对象。</p> 
<p><code>Nest</code> 还提供了一个名为 <code>ExecutionContext</code> 的实用程序，它提供有关当前执行过程的其他详细信息，例如接下来要执行的内容，而 <code>Express</code> 中间件则缺少此信息。</p> 
<h4><a id="4__148"></a>4. 自定义异常</h4> 
<p><code>Nest</code> 为大多数场景提供了默认的异常类，例如 <code>NotFoundException</code>、<code>UnAuthorizedException</code> 等。这可以节省我们一些时间。此外，还可以像在<code>express</code>中一样创建自己的异常类。</p> 
<h4><a id="5__151"></a>5. 验证</h4> 
<p>请求验证在很多方面都是有益的。它可以防止错误发生，并向用户显示一条有意义的消息，表明他们发送了错误的输入。此外，它还可以防止用户发送不需要的输入，从而使应用程序更加安全。</p> 
<p>在<code>express</code>中，我曾经在处理程序之前添加一个中间件，这个中间件采用一个验证器作为参数，该验证器是使用<code>Joi</code>工具创建的。但这非常耗时，并且会导致我们的路由/处理程序声明看起来更长、更复杂，并且有时候会忘记在处理程序之前添加验证器。不可能创建可在整个应用程序的所有上下文中使用的通用中间件。这是因为中间件不知道执行上下文，包括将被调用的处理程序及其任何参数。</p> 
<h4><a id="6__156"></a>6. 授权</h4> 
<p>授权是后端应用程序中的常见需求。某些服务可能需要基于角色的授权以防止不允许的操作。授权通常由传统 <code>Express</code> 应用程序中的中间件处理，通常看起来像这样。</p> 
<pre><code class="prism language-js">router<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/create'</span><span class="token punctuation">,</span> <span class="token function">authorize</span><span class="token punctuation">(</span>Role<span class="token punctuation">.</span>Admin<span class="token punctuation">)</span><span class="token punctuation">,</span> create<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>Nest</code> 的授权方式类似，但 <code>Nest</code> 通过其<code>Guards</code>概念提供了一些便利。守卫确定给定的请求是否将由路由处理程序处理。防护可以是控制器范围、方法范围或全局范围，这在实现中提供了易用性，也有助于保持代码干燥和声明性。此外，执行上下文可用于构建通用防护，这使得防护比传统中间件更强大。</p> 
<pre><code class="prism language-js">@<span class="token function">Post</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
@<span class="token function">Roles</span><span class="token punctuation">(</span><span class="token string">'admin'</span><span class="token punctuation">)</span> 
<span class="token keyword">async</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token parameter">@<span class="token function">Body</span><span class="token punctuation">(</span><span class="token punctuation">)</span> createCatDto<span class="token operator">:</span> CreateCatDto</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
  <span class="token keyword">this</span><span class="token punctuation">.</span>catsService<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>createCatDto<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="7__172"></a>7. 数据库</h4> 
<p>在<code>express</code>中我们通常使用 <code>ORM</code>（对象关系映射器）或<code>ODM</code>（对象文档映射器）如<code>Sequelize</code>或<code>Mongoose</code> 来处理数据库操作。<code>Nest</code> 没有什么不同，但 <code>Nest</code> 具有内置的 <code>ORM-ODM</code> 工具，这些工具提供模型/存储库注入、可测试性和动态配置，以便访问我们选择的数据库，我认为，<code>Nest</code> 的架构使使用数据库变得更容易</p> 
<h4><a id="8API_175"></a>8.API文档</h4> 
<p>迄今为止，在 <code>Nest.js</code> 中记录 <code>API</code> 是最简单的。<code>Nest</code> 提供了一个 <code>swagger</code> 模块，可以自动为 <code>API</code> 端点创建文档。此外，还可以使用如下装饰器定义请求/响应模式。</p> 
<pre><code class="prism language-js">  @<span class="token function">ApiBody</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> <span class="token literal-property property">type</span><span class="token operator">:</span> CreateCatDto <span class="token punctuation">}</span><span class="token punctuation">)</span>
  @<span class="token function">ApiCreatedResponse</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span> <span class="token literal-property property">type</span><span class="token operator">:</span> CreateCatResponseDto <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token function">create</span><span class="token punctuation">(</span>@<span class="token function">Body</span><span class="token punctuation">(</span><span class="token punctuation">)</span> createSampleDto<span class="token operator">:</span> CreateCatDto<span class="token punctuation">)</span> <span class="token operator">:</span> CreateCatResponseDto<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="9__186"></a>9. 性能</h4> 
<p><code>Nest</code> 允许使用 <code>Fastify</code> 适配器，它比 <code>Express</code> 适配器快两倍，如果不使用 <code>Fastify</code> 适配器，<code>Nest</code> 将无法击败 <code>Express</code>。我们知道 <code>Nest</code> 提供了这两个适配器的抽象以在它们之间进行切换，但这在每种情况下都是不可能的，因为在某些情况下这两个适配器的行为本质上不同。例如，<code>fastify</code> 适配器不支持嵌套路由，因此应该使用 <code>Express</code> 适配器来实现这一点。</p> 
<h4><a id="10__189"></a>10. 测试</h4> 
<p><code>Nest</code> 最强大的架构优势也在这里获胜。正如我们之前讨论的那样，<code>Nest</code> 使用模块并将它们与依赖项注入结合起来，这允许将任何依赖项注入到任何模块，因此我们可以注入测试服务而无需实例化它，并且它可以节省大量时间和精力，特别是对于较大的模块和服务。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4577ff31d0a7d0af214adb957b96bd55/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">windows11专业工作站版</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/17a37b77215afc2cbe4676a24364f669/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在 Node.js 中发出 HTTP 请求的 5 种方法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>