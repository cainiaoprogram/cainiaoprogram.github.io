<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C# modbus TCP协议应用总结（一） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C# modbus TCP协议应用总结（一）" />
<meta property="og:description" content="1.协议简介 Modbus由MODICON公司(现施耐德公司)于1979年开发，是一种工业现场总线协议标准。主要分为了RTU,ASCII,TCP三种协议类型。
本文我们只探讨C# modbusTCP的应用。 modbusTcp协议采用master/slave模型。在modbus总线中是以&#34;一主多从&#34;关系存在的。通讯方式是主站发出请求(广播或者单播)，从站收到请求后应答。
2.Modbus Tcp 主从站关系 什么时候需要编写主站程序，什么时候需要编写从站程序，对于初学者总有些疑惑。
2.1 Modbus 主站（master）：Modbus主站具有唯一性，可以主动发出读取、修改指令，对接多个Modbus从站。主站（master）一般作为工控机上位机程序来读取传感器设备的数据，编程时作为网络客户端（TCP Client），IP地址不需要固定。
2.2 Modbus从站（slave）：Modbus从站可以有多个，不会主动发出读取指令，只能对接一个Modbus主站。从站（slave）一般是传感器部分的程序，需要一个固定的IP地址，从站编程时一般作为网络服务端（TCP Server），监听回应主站发来的请求。
3.Modbus的功能码 功能码
含义
0x01
读线圈
0x02
读离散量输入
0x03
读保持寄存器
0x04
读输入寄存器
0x05
写单个线圈
0x06
写单个保持寄存器
0x0F
写多个线圈
0x10
写多个保持寄存器
例程：0x03：读保持寄存器，从远程设备中读保持寄存器连续块的内容 请求 ：19 15 00 00 00 06 01 03 05 4A 00 01 应答：19 15 00 00 00 05 01 03 02 11 22 请求解析： 19 15 为报文标识符（用户自定义），一般每次通信加1来表示区别不同报文 00 00 表示modbusTCP协议 00 06 表示后面的数据长度 01 从站号 03 功能码。 05 4A 读取数据的起始地址 00 01 读几位地址(寄存器数量） 应答解析： 19 15 为报文标识符 00 00 表示modbusTCP协议 00 05 表示后面的数据长度 01 从站号 03 功能码 02 表示读到的数据长度 11 22 表示读到的数据 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/656321638b71adb59a06ea8378dd9fe9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-24T14:52:26+08:00" />
<meta property="article:modified_time" content="2023-03-24T14:52:26+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C# modbus TCP协议应用总结（一）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div class="kdocs-document"> 
 <h2 style="">1.协议简介</h2> 
 <p style="">Modbus由MODICON公司(现施耐德公司)于1979年开发，是一种工业现场总线协议标准。主要分为了RTU,ASCII,TCP三种协议类型。</p> 
 <p style="">本文我们只探讨C# modbusTCP的应用。 modbusTcp协议采用master/slave模型。在modbus总线中是以"一主多从"关系存在的。通讯方式是主站发出请求(广播或者单播)，从站收到请求后应答。</p> 
 <h2 style="">2.Modbus Tcp 主从站关系</h2> 
 <p style="">什么时候需要编写主站程序，什么时候需要编写从站程序，对于初学者总有些疑惑。</p> 
 <p style="">2.1 Modbus 主站（master）：Modbus主站具有唯一性，可以主动发出读取、修改指令，对接多个Modbus从站。主站（master）一般作为工控机上位机程序来读取传感器设备的数据，编程时作为网络客户端（TCP Client），IP地址不需要固定。</p> 
 <p style="">2.2 Modbus从站（slave）：Modbus从站可以有多个，不会主动发出读取指令，只能对接一个Modbus主站。从站（slave）一般是传感器部分的程序，需要一个固定的IP地址，从站编程时一般作为网络服务端（TCP Server），监听回应主站发来的请求。</p> 
 <h2 style="">3.<span class="kdocs-bold" style="font-weight:bold;">Modbus的功能码</span></h2> 
 <div style=""> 
  <table class="kdocs-table" border="1" cellpadding="1" cellspacing="1" style=""><tbody><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:369px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">功能码</span></span></p></td><td class="kdocs-tableCell" style="width:369px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;"><span class="kdocs-bold" style="font-weight:bold;">含义</span></span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:369px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">0x01</span></p></td><td class="kdocs-tableCell" style="width:369px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">读线圈</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:369px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">0x02</span></p></td><td class="kdocs-tableCell" style="width:369px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">读离散量输入</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:369px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">0x03</span></p></td><td class="kdocs-tableCell" style="width:369px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">读保持寄存器</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:369px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">0x04</span></p></td><td class="kdocs-tableCell" style="width:369px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">读输入寄存器</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:369px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">0x05</span></p></td><td class="kdocs-tableCell" style="width:369px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">写单个线圈</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:369px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">0x06</span></p></td><td class="kdocs-tableCell" style="width:369px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">写单个保持寄存器</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:369px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">0x0F</span></p></td><td class="kdocs-tableCell" style="width:369px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">写多个线圈</span></p></td></tr><tr class="kdocs-tableRow"><td class="kdocs-tableCell" style="width:369px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">0x10</span></p></td><td class="kdocs-tableCell" style="width:369px;vertical-align:middle;height:52px;"><p style=""><span class="kdocs-fontSize" style="font-size:9pt;">写多个保持寄存器</span></p></td></tr></tbody></table> 
 </div> 
 <pre class="kdocs-csharp"><code class="language-csharp">例程：0x03：读保持寄存器，从远程设备中读保持寄存器连续块的内容
    请求 ：19 15 00 00 00 06 01 03 05 4A 00 01
    应答：19 15 00 00 00 05 01 03 02 11 22
        
        请求解析：
            19 15 为报文标识符（用户自定义），一般每次通信加1来表示区别不同报文
            00 00 表示modbusTCP协议
            00 06 表示后面的数据长度
            01 从站号
            03 功能码。
            05 4A 读取数据的起始地址
            00 01 读几位地址(寄存器数量）
            
        应答解析：
            19 15 为报文标识符
            00 00 表示modbusTCP协议
            00 05 表示后面的数据长度
            01 从站号
            03 功能码
            02 表示读到的数据长度
            11 22 表示读到的数据</code></pre> 
 <h2 style="">4. 基于NModbus4的Modbus TCP主从站例程</h2> 
 <p style="">下面程序参考了<a class="kdocs-link" style="color:#0A6CFF;" href="https://blog.csdn.net/qq_34699535/article/details/111658342" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_34699535/article/details/111658342</a>网站。</p> 
 <p style="">4.1 Modbus客户端：Slave（一般为设备端）</p> 
 <pre class="kdocs-csharp"><code class="language-csharp">//  Modbus TCP
using Modbus.Device;
using System.Net.Sockets;
using System.Net;
using Modbus.Data;
using System.Threading;
using Modbus.Utility;

private TcpListener listener;
private ModbusSlave slave;

//客户端监听端口
private void btn_SlaveListen_Click(object sender, EventArgs e)
{
    listener = new TcpListener(IPAddress.Parse(txt_SlaveIP.Text), (int)nud_SlavePort.Value);
    listener.Start();
    slave = ModbusTcpSlave.CreateTcp(1, listener);
    //创建寄存器存储对象
    slave.DataStore = DataStoreFactory.CreateDefaultDataStore();
    //订阅数据到达事件，可以在此事件中读取寄存器
    slave.DataStore.DataStoreWrittenTo += new EventHandler&lt;DataStoreEventArgs&gt;((obj, o) =&gt;
    {
         switch (o.ModbusDataType)
         {
             case ModbusDataType.Coil:   //code 5
                  ModbusDataCollection&lt;bool&gt; discretes = slave.DataStore.CoilDiscretes;
                  if (ckb_CD_1.InvokeRequired)
                  {
                      this.BeginInvoke(new Action(delegate
                      {
                           ckb_CD_1.Checked = discretes[1];       
                      }));
                  }
                    break;
             case ModbusDataType.HoldingRegister:   //code 15
                   ModbusDataCollection&lt;ushort&gt; holdingRegisters = slave.DataStore.HoldingRegisters;
                  if (txt_HR_1.InvokeRequired)
                  {
                      this.BeginInvoke(new Action(delegate
                      {
                           txt_HR_1.Text = holdingRegisters[1].ToString();
                      }));
                  }
                    break;
           }
    });

    //此事件，待补充
    slave.ModbusSlaveRequestReceived += new EventHandler&lt;ModbusSlaveRequestEventArgs&gt;((obj, o) =&gt;
    {
    });
    //此事件，待补充
    slave.WriteComplete += new EventHandler&lt;ModbusSlaveRequestEventArgs&gt;((obj, o) =&gt;
    {
    });
    slave.Listen();
}

//写入寄存器
private void btn_SlaveSend_Click(object sender, EventArgs e)
{
    //CoilDiscretes表示一个Bit，也就是一个bool类型
    slave.DataStore.CoilDiscretes[(int)nud_SlaveCoilAds.Value] = nud_SlaveCoilVal.Value == 1 ? true : false;
    //HoldingRegisters表示一个无符号的16位整数（2的16次幂：0-65535）
    slave.DataStore.HoldingRegisters[(int)nud_SlaveHRAds.Value] = (ushort)nud_SlaveHRVal.Value;
}
//停止监听
private void btn_SlaveStop_Click(object sender, EventArgs e)
{
    slave.Dispose();
}
</code></pre> 
 <p style="">4.2 Modbus主机端：Master（一般为上位机）</p> 
 <pre class="kdocs-csharp"><code class="language-csharp"> private TcpClient client;
 private ModbusIpMaster master;

 //连接
 private void btn_MasterConnect_Click(object sender, EventArgs e)
 {
     client = new TcpClient();
     client.Connect(IPAddress.Parse(txt_SlaveIP.Text.Trim()), (int)nud_SlavePort.Value);
     master = ModbusIpMaster.CreateIp(client);
 }
 //写入寄存器
 private void btn_MasterSend_Click(object sender, EventArgs e)
 {
     master.WriteSingleCoil((ushort)nud_MasterCoilAds.Value, nud_MasterCoilVal.Value == 1 ? true : false);
     master.WriteSingleRegister((ushort)nud_MasterHRAds.Value, (ushort)nud_MasterHRVal.Value);
 }
 //定时器中循环读取线圈和寄存器的值，当然，你也可以使用异步的方式
 private void timer1_Tick(object sender, EventArgs e)
 {
     bool[] coils = master.ReadCoils(1, 0, 9);
     ushort[] holding_register = master.ReadHoldingRegisters(1, 0, 9); 
 }
</code></pre> 
 <p style="">4.3 程序源码</p> 
 <p style=""><a class="kdocs-link" style="color:#0A6CFF;" href="https://download.csdn.net/download/hanhaitianyu/87576116" target="_blank" rel="noopener noreferrer">Modbus TCP例程</a></p> 
 <p style=""></p> 
 <p style="">参考网站：</p> 
 <p style=""><a class="kdocs-link" style="color:#0A6CFF;" href="https://www.cnblogs.com/ioufev/articles/10830028.html" rel="nofollow noopener noreferrer" target="_blank">https://www.cnblogs.com/ioufev/articles/10830028.html</a></p> 
 <p style=""><a class="kdocs-link" style="color:#0A6CFF;" href="https://blog.csdn.net/m0_57124501/article/details/127018946" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/m0_57124501/article/details/127018946</a></p> 
 <p style=""><a class="kdocs-link" style="color:#0A6CFF;" href="https://blog.csdn.net/qq_34699535/article/details/111658342" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_34699535/article/details/111658342</a></p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a80fd372563ebd05141b068ec8ff1889/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Modbus --- EasyModbus的简单读取与写入</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bc7aacb3800ac2e9073f7ad3d609b963/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【Python】字典与zip()函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>