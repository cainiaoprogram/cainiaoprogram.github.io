<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>语法基础——Objective-C语法基础 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="语法基础——Objective-C语法基础" />
<meta property="og:description" content="前言 学习过Swift之后，好久没用已经生疏了，现在有项目来了，不得不停下手下的工作，开始学习OC，当然这篇文章会以Java基础和C基础作为支撑，这样学习起来入门很简单，可能这篇文章有点个人主义，用作个人笔记吧
OC特点 支持C语法支持面向对象特性兼容性好，可以同时在项目中使用OC、C&#43;&#43;，也可以引入C、C&#43;&#43;库文件OC中没有命名空间机制，也没有包的概念，为了区分不同的类，在类名加前缀OC中关键字表示都以@开头，用于区分C和C&#43;&#43;的关键字，字符串也以@开头，如@public、@protected、@private、@”Hello World” 文件名后缀 语言头文件后缀主文件后缀c.h.cc&#43;&#43;.h.cppoc.h.moc与c&#43;&#43;.h.mm OC基本数据类型 基本数据类型：数值型（整型、浮点型），字符型（char）、布尔型（BOOL）、空类型（Void）、Block类型、指针数据类型（class、id类型）、特殊类型（SEL、nil）
1、instancetype和id类型
instancetype可以作为返回类型，可以返回和方法所在类相同类型的对象，只能作为返回值id可以作为返回类型，返回任意类型的objcetive-c的对象类型，既可以作为返回值也可以作为参数 类与属性 1、 类的声明语法
@interface Person : NSObject{ 属性声明 } 方法声明 @end 特点：
@interface：相当于Java中的class类名后面的冒号：相当于Java中的extends 2、类的实现语法
@implementation XYZPerson 方法实现{ } @end 3、完整例子
4、创建对象
//第一种创建方式：创建一个可用的对象 Person *p=[Person new]; //new方法的内部会分别调用两个方法来完成2件事情 //1、使用alloc方法来分配存储空间（返回分配的对象） //2、使用init方法来对对象进行初始化 //1、调用类方法&#43;alloc分配存储空间，返回未经初始化的对象 Person *p1=[person alloc]; //2、调用对象方法-init进行初始化，返回对象本身 Person *p2=[p1 init]; //第二种创建方式：以上2步简化为 Person *p=[[Person alloc] init]; //默认初始化完毕后，所有成员变量的值都为0 //用完对象要释放内存 [lisi release]; 究竟new方式和alloc/init方式有什么区别？
new和alloc/init在功能上是一致的，分配内存并完成初始化采用new方式只能采用默认的init方法完成初始化采用alloc的方式可以用自定义的构造方法完成初始化 5、访问对象属性
//调用类的属性，语法：对象-&gt;属性名 lisi-&gt;age; lisi-&gt;name; //或者：(*对象名).对象属性 (*lisi).name 6、调用方法
//调用无参方法，语法:[对象名 方法名] [Person eat] [Person run] //调用有参方法，语法:[对象名 方法名:参数] [Person eat:@&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8688e3094af2d38f6e10626d34967eb6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-02-21T19:37:29+08:00" />
<meta property="article:modified_time" content="2017-02-21T19:37:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">语法基础——Objective-C语法基础</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3 id="前言">前言</h3> 
<p>学习过Swift之后，好久没用已经生疏了，现在有项目来了，不得不停下手下的工作，开始学习OC，当然这篇文章会以Java基础和C基础作为支撑，这样学习起来入门很简单，可能这篇文章有点个人主义，用作个人笔记吧</p> 
<h3 id="oc特点">OC特点</h3> 
<ul><li>支持C语法</li><li>支持面向对象特性</li><li>兼容性好，可以同时在项目中使用OC、C++，也可以引入C、C++库文件</li><li>OC中没有命名空间机制，也没有包的概念，为了区分不同的类，在类名加前缀</li><li>OC中关键字表示都以@开头，用于区分C和C++的关键字，字符串也以@开头，如@public、@protected、@private、@”Hello World”</li></ul> 
<h3 id="文件名后缀">文件名后缀</h3> 
<table><thead><tr><th>语言</th><th>头文件后缀</th><th>主文件后缀</th></tr></thead><tbody><tr><td>c</td><td>.h</td><td>.c</td></tr><tr><td>c++</td><td>.h</td><td>.cpp</td></tr><tr><td>oc</td><td>.h</td><td>.m</td></tr><tr><td>oc与c++</td><td>.h</td><td>.mm</td></tr></tbody></table> 
<h3 id="oc基本数据类型">OC基本数据类型</h3> 
<p>基本数据类型：数值型（整型、浮点型），字符型（char）、布尔型（BOOL）、空类型（Void）、Block类型、指针数据类型（class、id类型）、特殊类型（SEL、nil）</p> 
<p>1、instancetype和id类型</p> 
<ol><li>instancetype可以作为返回类型，可以返回和方法所在类相同类型的对象，只能作为返回值</li><li>id可以作为返回类型，返回任意类型的objcetive-c的对象类型，既可以作为返回值也可以作为参数</li></ol> 
<h3 id="类与属性">类与属性</h3> 
<p>1、 类的声明语法</p> 
<pre class="prettyprint"><code class="language-oc hljs css"><span class="hljs-at_rule">@<span class="hljs-keyword">interface</span> Person : NSObject</span>{
    属性声明
}
    方法声明
<span class="hljs-at_rule">@<span class="hljs-keyword">end</span></span></code></pre> 
<p>特点：</p> 
<ol><li>@interface：相当于Java中的class</li><li>类名后面的冒号：相当于Java中的extends</li></ol> 
<p>2、类的实现语法</p> 
<pre class="prettyprint"><code class="language-oc hljs css"><span class="hljs-at_rule">@<span class="hljs-keyword">implementation</span> XYZPerson
    方法实现</span>{

    }
<span class="hljs-at_rule">@<span class="hljs-keyword">end</span></span></code></pre> 
<p>3、完整例子</p> 
<p><img src="https://images2.imgbox.com/0f/3c/GuYXWZLx_o.png" alt="" title=""></p> 
<p>4、创建对象</p> 
<pre class="prettyprint"><code class="language-oc hljs cs"><span class="hljs-comment">//第一种创建方式：创建一个可用的对象</span>
Person *p=[Person <span class="hljs-keyword">new</span>];
<span class="hljs-comment">//new方法的内部会分别调用两个方法来完成2件事情</span>
<span class="hljs-comment">//1、使用alloc方法来分配存储空间（返回分配的对象）</span>
<span class="hljs-comment">//2、使用init方法来对对象进行初始化</span>

<span class="hljs-comment">//1、调用类方法+alloc分配存储空间，返回未经初始化的对象</span>
Person *p1=[person  alloc];
<span class="hljs-comment">//2、调用对象方法-init进行初始化，返回对象本身</span>
Person *p2=[p1 init];
<span class="hljs-comment">//第二种创建方式：以上2步简化为</span>
Person *p=[[Person alloc] init];

<span class="hljs-comment">//默认初始化完毕后，所有成员变量的值都为0</span>
<span class="hljs-comment">//用完对象要释放内存</span>
[lisi release];</code></pre> 
<p>究竟new方式和alloc/init方式有什么区别？</p> 
<ol><li>new和alloc/init在功能上是一致的，分配内存并完成初始化</li><li>采用new方式只能采用默认的init方法完成初始化</li><li>采用alloc的方式可以用自定义的构造方法完成初始化</li></ol> 
<p>5、访问对象属性</p> 
<pre class="prettyprint"><code class=" hljs lasso"><span class="hljs-comment">//调用类的属性，语法：对象-&gt;属性名</span>
lisi<span class="hljs-subst">-&gt;</span>age;
lisi<span class="hljs-subst">-&gt;</span>name;
<span class="hljs-comment">//或者：(*对象名).对象属性</span>
(<span class="hljs-subst">*</span>lisi)<span class="hljs-built_in">.</span>name</code></pre> 
<p>6、调用方法</p> 
<pre class="prettyprint"><code class="language-oc hljs scss"><span class="hljs-comment">//调用无参方法，语法:[对象名 方法名]</span>
<span class="hljs-attr_selector">[Person eat]</span>
<span class="hljs-attr_selector">[Person run]</span>
<span class="hljs-comment">//调用有参方法，语法:[对象名 方法名:参数]</span>
<span class="hljs-attr_selector">[Person eat:@"吃虾"]</span>
<span class="hljs-attr_selector">[Person run:5]</span></code></pre> 
<p>7、@property和@synthesize</p> 
<p>在头文件中声明属性</p> 
<pre class="prettyprint"><code class=" hljs sql">//编译器会自动补出其<span class="hljs-operator"><span class="hljs-keyword">set</span>和<span class="hljs-keyword">get</span>方法
@property <span class="hljs-keyword">int</span> age;</span></code></pre> 
<p>在m文件中实现</p> 
<pre class="prettyprint"><code class=" hljs sql">//编译器会自动生成<span class="hljs-operator"><span class="hljs-keyword">set</span>和<span class="hljs-keyword">get</span>方法的实现，默认已经自动@synthesize属性的值
@synthesize age;</span></code></pre> 
<h3 id="构造方法">构造方法</h3> 
<p>1、默认的构造方法</p> 
<pre class="prettyprint"><code class="language-oc hljs ruby">- (instancetype)init{
    <span class="hljs-keyword">if</span>(slef = [<span class="hljs-keyword">super</span> init]){
        <span class="hljs-regexp">//</span>初始化
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;
}</code></pre> 
<p>2、自定义构造方法</p> 
<p>一般构造方法都以init开头，这样并不是复写系统默认的构造方法，而是再添加一个构造方法</p> 
<pre class="prettyprint"><code class=" hljs objectivec">- (instancetype)initWithDict:(<span class="hljs-built_in">NSDictionary</span> *)dict{
    <span class="hljs-keyword">if</span>(slef = [<span class="hljs-keyword">super</span> init]){
        <span class="hljs-comment">//初始化并赋值</span>
        <span class="hljs-keyword">self</span><span class="hljs-variable">.name</span> = dict[@<span class="hljs-string">"name"</span>];
    }
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>;
}</code></pre> 
<h3 id="函数">函数</h3> 
<p>1、减号表示对象方法，语法：-（返回值类型）方法名：（参数类型）参数名</p> 
<pre class="prettyprint"><code class=" hljs css"><span class="hljs-at_rule">@<span class="hljs-keyword">interface</span> Person : NSObject
<span class="hljs-function">-(Void)</span> someMethod</span>;
<span class="hljs-tag">-</span>(<span class="hljs-tag">Void</span>) <span class="hljs-tag">someMethodWithValue</span><span class="hljs-pseudo">:(someType)Value</span>;
<span class="hljs-at_rule">@<span class="hljs-keyword">end</span></span></code></pre> 
<p>特点：</p> 
<ol><li>函数的返回类型和参数类型必须用括号</li><li>函数的形参用冒号表示</li></ol> 
<p>2、加号表示静态方法（类方法），语法：+（返回值类型）方法名：（参数类型）参数名</p> 
<pre class="prettyprint"><code class="language-oc hljs r">@interface NSString: NSObject
+(id) string;
+(id) stringWithString:(NSString *)astring;
+(id) stringWithFormat:(NSString *)format,<span class="hljs-keyword">...</span>;
@end</code></pre> 
<p>区别：</p> 
<ol><li>对象方法可以直接访问属性，静态方法不能访问属性</li><li>静态方法可用类名直接调用方法，而对象方法不行</li></ol> 
<h3 id="点语法">点语法</h3> 
<p>声明对象并提供get和set方法</p> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-preprocessor">#import <span class="hljs-title">&lt;Foundation/Foundation.h&gt;</span></span>

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Person</span> : <span class="hljs-title">NSObject</span>{<!-- --></span>
   <span class="hljs-keyword">int</span> _age;
}
- (<span class="hljs-keyword">void</span>)setAge:(<span class="hljs-keyword">int</span>)age;
- (<span class="hljs-keyword">int</span>)age;

<span class="hljs-keyword">@end</span></code></pre> 
<p>实现对象</p> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-preprocessor">#import <span class="hljs-title">"Person.h"</span></span>

<span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Person</span></span>

- (<span class="hljs-keyword">void</span>)setAge:(<span class="hljs-keyword">int</span>)age{   <span class="hljs-comment">//set方法</span>
    _age = age;
}
- (<span class="hljs-keyword">int</span>)age{   <span class="hljs-comment">//get方法</span>
   <span class="hljs-keyword">return</span> _age;
}

<span class="hljs-keyword">@end</span></code></pre> 
<p>点语法的使用</p> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-preprocessor">#import <span class="hljs-title">&lt;Foundation/Foundation.h&gt;</span></span>
<span class="hljs-preprocessor">#import <span class="hljs-title">"Person.h"</span></span>

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[]){
    @autoreleasepool {    
        Person *person = [[Person alloc] init];

        person<span class="hljs-variable">.age</span> = <span class="hljs-number">10</span>;<span class="hljs-comment">//点语法，等效与[person setAge:10];</span>
        <span class="hljs-comment">//这里并不是给person的属性赋值，而是调用person的setAge方法</span>

        <span class="hljs-keyword">int</span> age = person<span class="hljs-variable">.age</span>;<span class="hljs-comment">//等效与int age = [person age];</span>
        <span class="hljs-comment">//这里调用person的set方法</span>

        <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">"age is %i"</span>, age);
        [person release];        
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>为什么有些使用_age，有些语法使用self.age？</p> 
<p>属性值：_age <br> 点语法：self.age</p> 
<ol><li>下划线是一种编程规范，_age是直接拿到age这个属性，不通过getAge方法获取，建议在init里面使用_age</li><li>self.age相当于调用[self getAge]，系统自动生成的代码(_age = age)，其实也是_age，如果你重写了getAge方法，返回的值就不一样了</li></ol> 
<h3 id="静态变量">静态变量</h3> 
<p>1、OC与Java或C的区别</p> 
<ol><li>OC中的静态变量：它是私有的全局变量，不能直接通过类名访问，它只作用于它声明所在的.m文件中</li><li>C或者Java中的静态变量：可以直接通过类名拿到这个变量，在其他类中可以进行修改</li></ol> 
<p>2、静态变量全局化</p> 
<p>不是说OC中静态变量不能使用在其他类中，可以通过静态方法向外提供该静态变量</p> 
<p>在h文件中定义静态变量和向外提供静态变量的方法</p> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-preprocessor">#import <span class="hljs-title">&lt;UIKit/UIKit.h&gt;</span></span>
<span class="hljs-comment">//静态变量</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> selectIndex;

<span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">TBC_SendPassword</span> : <span class="hljs-title">UITabBarController</span></span>
<span class="hljs-comment">//提供静态变量</span>
+(<span class="hljs-keyword">int</span>)getSelectIndex;
<span class="hljs-keyword">@end</span></code></pre> 
<p>在m文件中覆写该方法，提供静态变量，你可以在m文件中修改对应的selectIndex的值</p> 
<pre class="prettyprint"><code class=" hljs cs">+(<span class="hljs-keyword">int</span>)getSelectIndex{
    <span class="hljs-keyword">return</span> selectIndex;
}</code></pre> 
<p>在其他类中需要使用该类的静态变量，首先在h文件中导入头文件</p> 
<pre class="prettyprint"><code class=" hljs ruleslanguage"><span class="hljs-array">#import </span><span class="hljs-string">"TBC_SendPassword.h"</span></code></pre> 
<p>在m文件中直接通过静态的方法的使用，获取对应的值</p> 
<pre class="prettyprint"><code class=" hljs bash"><span class="hljs-keyword">if</span>([TBC_SendPassword getSelectIndex] != <span class="hljs-number">0</span>){
    <span class="hljs-keyword">return</span>;
}</code></pre> 
<h3 id="hello-world">Hello World</h3> 
<p>相当于Java的main方法</p> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-preprocessor">#import <span class="hljs-title">&lt;Foundation/Foundation.h&gt;</span></span>

<span class="hljs-keyword">int</span> main(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> * argv[]){
    @autoreleasepool{
        <span class="hljs-built_in">NSLog</span>(@<span class="hljs-string">"Hello World"</span>);
    }
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}</code></pre> 
<p>特点：</p> 
<ol><li>Foundation.h是Foundation框架中的头文件，是OC一个基础类库，基本所有OC代码都要引入这个类库</li><li>@autoreleasepool是OC的关键字，作用是对在关键字后面的程序自动进行内存回收</li></ol> 
<h3 id="import指令">import指令</h3> 
<ul><li>#include指令：单独使用会造成导入重复库文件，从而引起报错</li><li>#import指令：#include增强版，有效处理重复导入问题，不会报错</li></ul> 
<p>特点：</p> 
<ol><li>导入系统类库用&lt;&gt;，导入自定义类库用””</li><li>BOOL类型，包含两个值YES和NO，其实布尔类型就是整数1和0</li></ol> 
<h3 id="nslog">NSLog</h3> 
<pre class="prettyprint"><code class="language-oc hljs rust"><span class="hljs-comment">//定义一个字符串，str存放是内存地址</span>
NSString *<span class="hljs-keyword">str</span> = <span class="hljs-string">"你好"</span>;
NSLog(@<span class="hljs-string">"str的地址=%p,str的值=%@"</span>,<span class="hljs-keyword">str</span>,<span class="hljs-keyword">str</span>);
<span class="hljs-comment">//打印OC字符串要用@""</span>
NSLog(@<span class="hljs-string">"Hello OC"</span>);
<span class="hljs-comment">//用C语言打印字符串</span>
printf(<span class="hljs-string">"Hello OC"</span>);</code></pre> 
<p>注意不能用C语言打印OC字符串，也不能用OC语言打印C字符串</p> 
<h3 id="nsstring">NSString</h3> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-comment">//创建字符串</span>
<span class="hljs-built_in">NSString</span> * str = @<span class="hljs-string">"Hello"</span>;
<span class="hljs-comment">//字符串长度，OC中英文都占1个字节</span>
[str length]
<span class="hljs-comment">//创建字符串对象</span>
<span class="hljs-built_in">NSString</span> * str1 = [<span class="hljs-built_in">NSString</span> new]
<span class="hljs-comment">//复制字符串</span>
<span class="hljs-built_in">NSString</span> * str2 = [[<span class="hljs-built_in">NSString</span> malloc]initWithString:str];
<span class="hljs-comment">//格式化字符串</span>
<span class="hljs-built_in">NSString</span> * str3 = [<span class="hljs-built_in">NSString</span>  stringWithFormat:@<span class="hljs-string">"图片 xx %02d- %02d"</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>];
<span class="hljs-comment">//字符串拼接</span>
<span class="hljs-built_in">NSString</span> *newString = [<span class="hljs-built_in">NSString</span> stringWithFormat:@<span class="hljs-string">"%@%@"</span>,str1,str2];</code></pre> 
<h3 id="nsmutablearray">NSMutableArray</h3> 
<p>NSMutableArray是长度可变数组，也就是说当数组前面的元素被删除后，后面的元素会往前移，而NSArray是长度不可变数组</p> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-comment">//创建NSMutableArray</span>
<span class="hljs-built_in">NSMutableArray</span> *mArray = [<span class="hljs-built_in">NSMutableArray</span> array]; 
<span class="hljs-comment">//添加元素</span>
[mArray addObject:@<span class="hljs-string">"name"</span>];
<span class="hljs-comment">//移除元素</span>
[mArray removeObject:@<span class="hljs-string">"name"</span>];
<span class="hljs-comment">//移除所有元素</span>
[mArray removeAllObjects];
<span class="hljs-comment">//取出元素</span>
mArray[<span class="hljs-number">2</span>];</code></pre> 
<h3 id="强制类型转换">强制类型转换</h3> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-comment">//字符转int</span>
<span class="hljs-keyword">int</span> intString = [newString intValue];
<span class="hljs-comment">//int转字符</span>
<span class="hljs-built_in">NSString</span> *stringInt = [<span class="hljs-built_in">NSString</span> stringWithFormat:@<span class="hljs-string">"%d"</span>,intString];
<span class="hljs-comment">//字符转float</span>
<span class="hljs-keyword">float</span> floatString = [newString floatValue];
<span class="hljs-comment">//float转字符</span>
<span class="hljs-built_in">NSString</span> *stringFloat = [<span class="hljs-built_in">NSString</span> stringWithFormat:@<span class="hljs-string">"%f"</span>,intString];</code></pre> 
<h3 id="nsbundle">NSBundle</h3> 
<p>NSBundle是一个目录，其中包含了程序会使用到的资源，相当于项目中的主目录文件夹，NSBundle用得最多的是获取Plist文件，并获取Plist的内容，Plist文件可以简单理解为小数据库类型的文件，它在项目初始化时默认会创建一个info.plist文件，里面会存储系统的默认配置信息</p> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-comment">//打印沙盒路径</span>
<span class="hljs-built_in">NSLog</span>(NSHomeDirectory());
<span class="hljs-comment">//创建NSBundle</span>
<span class="hljs-built_in">NSBundle</span> *bundle = [<span class="hljs-built_in">NSBundle</span> mainBundle];
<span class="hljs-comment">//获取NSBundle里myPic.png文件的路径的两种方法</span>
<span class="hljs-built_in">NSString</span> *path = [mainBundle pathForResource:@<span class="hljs-string">"myPic"</span> ofType:@<span class="hljs-string">".png"</span>];
<span class="hljs-built_in">NSString</span> *path = [mainBundle pathForResource:@<span class="hljs-string">"myPic.png"</span> ofType:<span class="hljs-literal">nil</span>];
<span class="hljs-comment">//获取NSBundle里的Plist文件</span>
<span class="hljs-built_in">NSString</span> *plistPath = [mainBundle pathForResource:@<span class="hljs-string">"myList.plist"</span> ofType:<span class="hljs-literal">nil</span>];
<span class="hljs-comment">//通过Plist路径获取字典</span>
<span class="hljs-built_in">NSDictionary</span> *dict = [<span class="hljs-built_in">NSDictionary</span> dictionaryWithContentsOfFile:plistPath];
<span class="hljs-comment">//通过Plist路径获取数组</span>
<span class="hljs-built_in">NSArray</span> *array = [<span class="hljs-built_in">NSArray</span> arrayWithContentsOfFile:plistPath];</code></pre> 
<h3 id="kvc">kvc</h3> 
<p>OC中的KVC操作就和Java中使用反射机制去访问类中private权限的变量一样</p> 
<p>1、kvc与对象</p> 
<p>1.单个对象赋值：通过kvc的方式，可以省去自动解包和装包操作</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">//通过kvc方式设置属性</span>
Person *p = [[Person alloc] init];
[p setValue:@<span class="hljs-string">"jiangwei"</span> forKey:@<span class="hljs-string">"name"</span>];
[p setValue:@<span class="hljs-number">22</span> forKey:@<span class="hljs-string">"age"</span>];
<span class="hljs-comment">//通过kvc方式读取属性</span>
NSString *name = [p valueForKey:@<span class="hljs-string">"name"</span>];        </code></pre> 
<p>2.单个对象对对象赋值：对象中包含另一个对象</p> 
<pre class="prettyprint"><code class="language-java hljs ">Book *book = [[Book alloc] init];
Author *author = [[Author alloc] init];   
<span class="hljs-comment">//通过kvc方式设置对象</span>
[book setValue:author forKey:@<span class="hljs-string">"author"</span>];</code></pre> 
<p>3.单个对象对数组赋值：对象中存在数组属性，数组装的是另一个对象</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-comment">//author中的issueBook字段是个NSArray</span>
<span class="hljs-comment">//通过kvc方式获取数组的大小，语法：NSArray.@count</span>
NSNumber *count = [author valueForKeyPath:@<span class="hljs-string">"issueBook.@count"</span>];
<span class="hljs-comment">//通过kvc方式获取书籍价格的总和，语法：NSArray.@sum+字段名</span>
NSNumber *sum = [author valueForKeyPath:@<span class="hljs-string">"issueBook.@sum.price"</span>];
<span class="hljs-comment">//通过kvc方式获取书籍的平均值，语法：NSArray.@avg+字段名</span>
NSNumber *avg = [author valueForKeyPath:@<span class="hljs-string">"issueBook.@avg.price"</span>];
<span class="hljs-comment">//通过kvc方式获取书籍的价格最大值和最小值，语法：NSArray.@max+字段名</span>
NSNumber *max = [author valueForKeyPath:@<span class="hljs-string">"issueBook.@max.price"</span>];
NSNumber *min = [author valueForKeyPath:@<span class="hljs-string">"issueBook.@min.price"</span>];</code></pre> 
<p>2、kvc与字典</p> 
<p>1.通过获取字典字段，将字典转换为属性</p> 
<pre class="prettyprint"><code class=" hljs ruby"><span class="hljs-keyword">self</span>.name = dict[@<span class="hljs-string">"name"</span>];
<span class="hljs-keyword">self</span>.icon = dict[@<span class="hljs-string">"icon"</span>];</code></pre> 
<p>2.通过kvc方式进行赋值，自动将字段与属性匹配，前提是字段名和字典名必须相同</p> 
<pre class="prettyprint"><code class=" hljs ini"><span class="hljs-title">[self setValuesForKeysWithDictionary:dict]</span><span class="hljs-comment">;</span></code></pre> 
<h3 id="日期格式化">日期格式化</h3> 
<pre class="prettyprint"><code class=" hljs objectivec"><span class="hljs-comment">//取出当前时间 </span>
<span class="hljs-built_in">NSDate</span> *currentDate = [<span class="hljs-built_in">NSDate</span> date];
<span class="hljs-comment">//设置时间格式</span>
NSDateFormatter *formatter = [[NSDateFormatter alloc]init];
<span class="hljs-comment">//时间的格式</span>
formatter<span class="hljs-variable">.dateFormat</span> = @<span class="hljs-string">"yyyy-MM-dd HH:mm:ss"</span>;
<span class="hljs-comment">//获取时间的字符串</span>
<span class="hljs-built_in">NSString</span> *date = [formatter stringFromDate:currentDate];</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/90b0a7d74d6ab79e24eee9420bcf1de5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【scikit-learn】04：sklearn库下进行文本数据分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7ed08d549fd7d80ab655c03f79fd9517/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python3使用builtwith识别网站使用相关技术</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>