<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android SELinux avc dennied权限问题解决方法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android SELinux avc dennied权限问题解决方法" />
<meta property="og:description" content="1. 概述
SELinux是Google从android 5.0开始，强制引入的一套非常严格的权限管理机制，主要用于增强系统的安全性。
然而，在开发中，我们经常会遇到由于SELinux造成的各种权限不足，即使拥有“万能的root权限”，也不能获取全部的权限。本文旨在结合具体案例，讲解如何根据log来快速解决90%的SELinux权限问题。
2. 调试确认SELinux问题 为了澄清是否因为SELinux导致的问题，可先执行：
setenforce 0 （临时禁用掉SELinux）
getenforce （得到结果为Permissive）
如果问题消失了，基本可以确认是SELinux造成的权限问题，需要通过正规的方式来解决权限问题。
遇到权限问题，在logcat或者kernel的log中一定会打印avc denied提示缺少什么权限，可以通过命令过滤出所有的avc denied，再根据这些log各个击破：
cat /proc/kmsg | grep avc 或
dmesg | grep avc
例如：
audit(0.0:67): avc: denied { write } for path=&#34;/dev/block/vold/93:96&#34; dev=&#34;tmpfs&#34; ino=1263 scontext=u:r:kernel:s0 tcontext=u:object_r:block_device:s0 tclass=blk_file permissive=0
可以看到有avc denied，且最后有permissive=0，表示不允许。
3. 具体案例分析 解决原则是：缺什么权限补什么，一步一步补到没有avc denied为止。
解决权限问题需要修改的权限文件如下位置，以.te结尾
A：Android/devicesoftwinner/astar-common/sepolicy/*.te
B：Android/external/sepolicy/*.te
其中，A是对B的overlay（覆盖），能在A修改的尽量在A修改，尽量避免修改B，修改B可能会导致CTS fail问题，修改A不会影响CTS测试。
（如果不需要深入了解，请直接跳到万能公式这一章阅读更简洁）
下面给出四个案例：
案例1
audit(0.0:67): avc: denied { write } for path=&#34;/dev/block/vold/93:96&#34; dev=&#34;tmpfs&#34; ino=/1263 scontext=u:r:kernel:s0 tcontext=u:object_r:block_device:s0 tclass=blk_file permissive=0" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a09d5995cf3a185c5fb3b3c668915425/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-03-21T16:47:24+08:00" />
<meta property="article:modified_time" content="2020-03-21T16:47:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android SELinux avc dennied权限问题解决方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>1. </strong><strong>概述</strong></p> 
<p>SELinux是Google从android 5.0开始，强制引入的一套非常严格的权限管理机制，主要用于增强系统的安全性。</p> 
<p>然而，在开发中，我们经常会遇到由于SELinux造成的各种权限不足，即使拥有“万能的root权限”，也不能获取全部的权限。本文旨在结合具体案例，讲解如何根据log来快速解决90%的SELinux权限问题。</p> 
<h2><a name="_Toc457490118"></a><br><br><br> 2. <strong>调试确认SELinux问题</strong></h2> 
<p>为了澄清是否因为SELinux导致的问题，可先执行：</p> 
<p>setenforce 0 （临时禁用掉SELinux）</p> 
<p>getenforce  （得到结果为Permissive）</p> 
<p>如果问题消失了，基本可以确认是SELinux造成的权限问题，需要通过正规的方式来解决权限问题。</p> 
<p>遇到权限问题，在logcat或者kernel的log中一定会打印avc denied提示缺少什么权限，可以通过命令过滤出所有的avc denied，再根据这些log各个击破：</p> 
<p><strong>cat /proc/kmsg | grep avc </strong></p> 
<p>或</p> 
<p><strong>dmesg | grep avc</strong></p> 
<p><strong>例如：</strong></p> 
<p>audit(0.0:67): avc: denied { write } for path="/dev/block/vold/93:96" dev="tmpfs" ino=1263 scontext=u:r:kernel:s0 tcontext=u:object_r:block_device:s0 tclass=blk_file permissive=0</p> 
<p>可以看到有avc denied，且最后有permissive=0，表示不允许。</p> 
<h2><a name="_Toc457490119"></a><br><br><br> 3. <strong>具体案例分析</strong></h2> 
<p><strong>解决原则是：缺什么权限补什么，一步一步补到没有avc denied为止。</strong></p> 
<p>解决权限问题需要修改的权限文件如下位置，以.te结尾</p> 
<p>A：Android/devicesoftwinner/astar-common/sepolicy/*.te</p> 
<p>B：Android/external/sepolicy/*.te</p> 
<p>其中，A是对B的overlay（覆盖），能在A修改的尽量在A修改，尽量避免修改B，修改B可能会导致CTS fail问题，修改A不会影响CTS测试。</p> 
<p>（如果不需要深入了解，请直接跳到<a href="https://blog.csdn.net/tung214/article/details/72734086#_%E4%B8%87%E8%83%BD%E5%85%AC%E5%BC%8F" title="万能公式">万能公式</a>这一章阅读更简洁）</p> 
<p>下面给出四个案例：</p> 
<p>案例1</p> 
<table><tbody><tr><td style="vertical-align:top;"> <p>audit(0.0:67): avc: denied { <strong>write</strong> } for path="/dev/block/vold/93:96" dev="tmpfs" ino=/1263 scontext=u:r:<strong>kerne</strong>l:s0 tcontext=u:object_r:<strong>block_device</strong>:s0 tclass=<strong>blk_file </strong>permissive=0</p> </td></tr></tbody></table> 
<p></p> 
<p>分析过程：</p> 
<p>缺少什么权限：      {<!-- --><strong> write</strong> }权限，</p> 
<p>谁缺少权限：        scontext=u:r:<strong>kernel</strong>:s0</p> 
<p>对哪个文件缺少权限：tcontext=u:object_r:<strong>block_device</strong></p> 
<p>什么类型的文件：    tclass=<strong>blk_file</strong></p> 
<p>完整的意思： kernel进程对block_device类型的blk_file缺少write权限。</p> 
<p></p> 
<p>解决方法：在上文A位置，找到kernel.te这个文件，加入以下内容：</p> 
<table><tbody><tr><td style="vertical-align:top;"> <p>allow  <strong>kernel  block_device:blk_file  write</strong>;</p> </td></tr></tbody></table> 
<p>make installclean后重新编译，刷boot.img才会生效。</p> 
<p></p> 
<p>案例2</p> 
<table><tbody><tr><td style="vertical-align:top;"> <p>audit(0.0:53): avc: denied { <strong>execute</strong> } for  path="/data/data/com.mofing/qt-reserved-files/plugins/platforms/libgnustl_shared.so" dev="nandl" ino=115502 scontext=u:r:<strong>platform_app</strong>:s0 tcontext=u:object_r:<strong>app_data_file:</strong>s0 tclass=file permissive=0</p> </td></tr></tbody></table> 
<p></p> 
<p>分析过程：</p> 
<p>缺少什么权限：      {<!-- --><strong> execute</strong>}权限，</p> 
<p>谁缺少权限：        scontext = u:r:<strong>platform_app</strong>:s0</p> 
<p>对哪个文件缺少权限：tcontext = u:object_r:<strong>app_data_file</strong></p> 
<p>什么类型的文件：    tclass=<strong> file</strong></p> 
<p>完整的意思： platform_app进程对app_data_file类型的file缺少execute权限。</p> 
<p></p> 
<p>解决方法：在上文A位置，找到platform_app.te这个文件，加入以下内容：</p> 
<table><tbody><tr><td style="vertical-align:top;"> <p>allow  <strong>platform_app  app_data_file:file  execute;</strong></p> </td></tr></tbody></table> 
<p>make installclean后重新编译，刷boot.img才会生效。</p> 
<p></p> 
<p>案例3</p> 
<table><tbody><tr><td style="vertical-align:top;"> <p>audit(1444651438.800:8): avc: denied { <strong>search </strong>} for pid=158 comm="setmacaddr" name="/" dev="nandi" ino=1 scontext=u:r:<strong>engsetmacaddr</strong>:s0 tcontext=u:object_r:<strong>vfat</strong>:s0 tclass=<strong>dir</strong> permissive=0</p> </td></tr></tbody></table> 
<p>解决方法 ：engsetmacaddr.te</p> 
<table><tbody><tr><td style="vertical-align:top;"> <p>allow  <strong>engsetmacaddr  vfat:dir  { search </strong>write add_name create <strong>}; 或者</strong></p> <p>allow  <strong>engsetmacaddr   vfat:dir  create_dir_perms;</strong></p> </td></tr></tbody></table> 
<p>(create_dir_perms包含search<strong> </strong>write add_name create可参考external/sepolicy/global_macros的定义声明)</p> 
<p></p> 
<p>案例4</p> 
<table><tbody><tr><td style="vertical-align:top;"> <p>audit(1441759284.810:5): avc: denied { <strong>read </strong>} for pid=1494 comm="sdcard" name="0" dev="nandk" ino=245281 scontext=u:r:<strong>sdcardd</strong>:s0 tcontext=u:object_r:<strong>system_data_file</strong>:s0 tclass=<strong>dir</strong> permissive=0</p> </td></tr></tbody></table> 
<p>解决方法 ：sdcardd.te </p> 
<table><tbody><tr><td style="vertical-align:top;"> <p>allow  <strong>sdcardd  system_data_file:dir  read;  或者</strong><br> allow  <strong>sdcardd  system_data_file:dir  rw_dir_perms;</strong></p> </td></tr></tbody></table> 
<p> (rw_dir_perms包含read write，可参考external/sepolicy/global_macros的定义声明)</p> 
<p></p> 
<p></p> 
<h2><a name="_%E4%B8%87%E8%83%BD%E5%85%AC%E5%BC%8F"></a><br><br><br> 4. <strong>万能公式</strong></h2> 
<p>通过这四个案例，我们可以总结出一般规律,</p> 
<p>以第案例4为例：</p> 
<table><tbody><tr><td style="vertical-align:top;"> <p>audit(1441759284.810:5): avc: denied { <strong>read </strong>} for pid=1494 comm="sdcard" name="0" dev="nandk" ino=245281 scontext=u:r:<strong>sdcardd</strong>:s0 tcontext=u:object_r:<strong>system_data_file</strong>:s0 tclass=<strong>dir</strong> permissive=0</p> </td></tr></tbody></table> 
<p></p> 
<p>某个scontext对某个tclass类型的tcontext缺乏某个权限，我们需要允许这个权限：</p> 
<p>我们的log重新排列一下，</p> 
<p>scontext = u:r:<strong>sdcardd</strong></p> 
<p>tcontex t= u:object_r:<strong>system_data_file</strong>:s0</p> 
<p>tclass = <strong>dir</strong></p> 
<p>avc: denied { <strong>read</strong> }</p> 
<p></p> 
<p><strong>得到万能套用公式如下：</strong></p> 
<p>在scontext所指的.te文件（例如<strong>sdcardd.te</strong>）中加入类似如下allowe内容：</p> 
<p></p> 
<h2><a name="_Toc457490121"></a><br><br><br> 5. <strong>TIPS</strong></h2> 
<p>1. 以上以.te为后缀的文件都在以下位置：<br> A：Android/devicesoftwinner/astar-common/sepolicy/*.te</p> 
<p>B：Android/external/sepolicy/*.te<br> 其中，A是对B的overlay（覆盖），能在A修改的尽量在A修改，修改B可能会导致CTS fail问题，修改A不会影响CTS测试。修改之后，为了节约验证时间，只重刷boot.img即可看效果；</p> 
<p></p> 
<p>2. 有时候avc denied的log不是一次性暴露所有权限问题，要等解决一个权限问题之后，才会暴露另外一个权限问题。比如提示缺少某个目录的read权限，加入read之后，才显示缺少write权限，要一次次一次试，一次一次加，时间成本极大。<br> 针对dir缺少的任何权限，建议赋予create_dir_perms，基本涵盖对dir的所有权限，比如：<br> { open search write read rename create rmdir getattr }等等。<br> 针对file缺少的任何权限，建议赋予rwx_file_perms，基本涵盖对file的所有权限，比如：<br> 包含{ open read write open execute getattr create ioctl }等等。</p> 
<p>更多内容请参考external/sepolicy/global_macros来了解更多权限声明。</p> 
<p>3. 要加入的权限很多时，可以用中括号，比如：<br> allow engsetmacaddr  vfat:dir { search write add_name create};</p> 
<p>4. 修改A位置的.te文件遇到编译错误怎么办？<br> （首先请排除拼写错误）说明此项权限是SELinux明确禁止的，也是Google CTS禁止的，如果产品不需要过CTS，可以修改。一般来说，编译出错的log会提示相关哪个文件哪一行出错，文件位置一定会在B里的.te文件。比如B规定了以下neverallow,<br> neverallow system_server sdcard_type:dir { open read write };<br> 那么system_server是不能拥有这些权限的，如果赋予这些权限就编译报错，解决方法是根据编译错误提示的行号，把这一句注释掉即可。</p> 
<p></p> 
<p></p> 
<h2><a name="_Toc457490122"></a><br><br><br> 6. <strong>高级进阶</strong></h2> 
<h3><a name="_Toc457490123"></a><br><br><br> 6.1. <strong>新建.te安全策略文件方法</strong></h3> 
<p>以上基本是对已经存在的进程增加权限，但对第三方进程改如何新增一个全新的te文件并赋予权限呢？</p> 
<p>以写mac地址的setmacaddr执行文件为例（这个执行档android原生不存在，自行添加的）：</p> 
<p>在init.xxx.rc中如下服务：</p> 
<table><tbody><tr><td style="vertical-align:top;"> <p>service engsetmacaddr  /system/bin/setmacaddr  /data/misc/wifi/wifimac.txt</p> <p>    class main</p> <p>    disabled</p> <p>oneshot</p> </td></tr></tbody></table> 
<p></p> 
<p></p> 
<p>1. 在device/softwinner/astar-common/sepolicy/file_contexts中，参考其他进程声明一个scontext：</p> 
<table><tbody><tr><td style="vertical-align:top;"> <p>……</p> <p>/system/bin/install-recovery.sh u:object_r:install_recovery_exec:s0</p> <p>/system/bin/dex2oat     u:object_r:dex2oat_exec:s0</p> <p>/system/bin/patchoat    u:object_r:dex2oat_exec:s0</p> <p><strong>/system/bin/setmacaddr u:object_r:engsetmacaddr_exec:s0</strong></p> </td></tr></tbody></table> 
<p>指定setmacaddr的路径，并指定一个名字，一定要以service名+_exec结尾</p> 
<p></p> 
<p>2.参考其.te文件在device/softwinner/astar-common/sepolicy/file_contexts 创建engsetmacaddr.te文件，内容如下：</p> 
<table><tbody><tr><td style="vertical-align:top;"> <p>type engsetmacaddr, domain;</p> <p>type engsetmacaddr_exec, exec_type, file_type;<br><br> init_daemon_domain(engsetmacaddr)</p> <p><br> allow engsetmacaddr  vfat:dir { search write add_name create};<br> allow engsetmacaddr  vfat:file { create read write open };<br> allow engsetmacaddr  engsetmacaddr:capability dac_override;<br> allow engsetmacaddr  shell_exec:file { execute read open execute_no_trans};<br> allow engsetmacaddr  system_data_file:dir { write add_name remove_name };<br> allow engsetmacaddr  system_data_file:file { create execute_no_trans write open setattr};</p> <p>allow engsetmacaddr  system_file:file { execute_no_trans};</p> </td></tr></tbody></table> 
<p>以上赋予的权限全部是根据avc denied的log缺什么一步一步补什么来的。</p> 
<p></p> 
<h3><a name="_Toc457490124"></a><br><br><br> 6.2. <strong>新设备节点增加访问权限</strong></h3> 
<p>驱动创建了一个新的设备节点，即使权限是777，android层也是没有访问权限的。</p> 
<p>下面以一个/dev/wifi_bt节点为示范，让此节点被用户空间的system_server进程访问。</p> 
<p>1. 编辑devicesoftwinner/astar-common/sepolicy/device.te，仿照这个文件里的写法，定义一个dev_type类型的wifi_bt_device设备：</p> 
<table><tbody><tr><td style="vertical-align:top;"> <p>type misc_block_device, dev_type;</p> <p>type private_block_device, dev_type;</p> <p>……</p> <p>type <strong>wf_bt_device</strong>, dev_type;  </p> </td></tr></tbody></table> 
<p></p> 
<p>2. 编辑file_contexts.te，将/dev/wf_bt节点声明为第1步定义的wf_bt_device:</p> 
<table><tbody><tr><td style="vertical-align:top;"> <p>/dev/block/by-name/misc         u:object_r:misc_block_device:s0</p> <p>/dev/block/by-name/alog         u:object_r:log_block_device:s0</p> <p>/dev/block/by-name/private      u:object_r:private_block_device:s0</p> <p><strong># We add here  </strong></p> <p>/dev/wf_bt              u:object_r:<strong>wf_bt_device</strong>:s0  </p> </td></tr></tbody></table> 
<p></p> 
<p>3. 在system_server.te，根据dmesg | grep avc允许system_server对wf_bt_device这个节点可读可写：</p> 
<table><tbody><tr><td style="vertical-align:top;"> <p># Read/Write to /proc/net/xt_qtaguid/ctrl and and /dev/xt_qtaguid.  </p> <p>allow system_server qtaguid_proc:file rw_file_perms;  </p> <p>allow system_server qtaguid_device:chr_file rw_file_perms;  </p> <p> ……</p> <p>allow system_server <strong>wf_bt_device</strong>:chr_file rw_file_perms;  </p> </td></tr></tbody></table> 
<p>其他进程如需访问/dev/wf_bt节点，依样画葫芦，增加对wf_bt_device的权限即可。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8bc9352be649bd1ff5ea1db9778adc1a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python之format用法详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/02d50afc3489b81a636faba07d4f3fb3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">设计模式之一——Adapter模式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>