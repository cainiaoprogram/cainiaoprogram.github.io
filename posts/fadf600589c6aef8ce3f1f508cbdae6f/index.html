<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>retinex图像增强算法ssr-msr-msrcr详解及其opencv源码 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="retinex图像增强算法ssr-msr-msrcr详解及其opencv源码" />
<meta property="og:description" content="原文：https://blog.csdn.net/ajianyingxiaoqinghan/article/details/71435098
Retinex图像增强算法(SSR, MSR, MSRCR)详解及其OpenCV源码 Retinex是一种常用的建立在科学实验和科学分析基础上的图像增强方法，它是Edwin.H.Land于1963年提出的。就跟Matlab是由Matrix和Laboratory合成的一样，Retinex也是由两个单词合成的一个词语，他们分别是retina 和cortex，即：视网膜和皮层。Land的retinex模式是建立在以下三个假设之上的：
真实世界是无颜色的，我们所感知的颜色是光与物质的相互作用的结果。我们见到的水是无色的，但是水膜—肥皂膜却是显现五彩缤纷，那是薄膜表面光干涉的结果。每一颜色区域由给定波长的红、绿、蓝三原色构成的；三原色决定了每个单位区域的颜色。 Retinex理论的基础理论是物体的颜色是由物体对长波（红色）、中波（绿色）、短波（蓝色）光线的反射能力来决定的，而不是由反射光强度的绝对值来决定的，物体的色彩不受光照非均匀性的影响，具有一致性，即retinex是以色感一致性（颜色恒常性）为基础的。不同于传统的线性、非线性的只能增强图像某一类特征的方法，Retinex可以在动态范围压缩、边缘增强和颜色恒常三个方面达到平衡，因此可以对各种不同类型的图像进行自适应的增强。
40多年来，研究人员模仿人类视觉系统发展了Retinex算法，从单尺度Retinex算法，改进成多尺度加权平均的MSR算法，再发展成彩色恢复多尺度MSRCR算法。笔者在本文中，从原理阐述算法的流程，并提供源码地址。
参考链接： http://blog.csdn.net/carson2005/article/details/9502053 http://www.cnblogs.com/Imageshop/archive/2013/04/17/3026881.html 参考论文： 《一种结合直方图均衡化和MSRCR的图像增强新算法》——李锦 等人
一. 单尺度SSR(Single Scale Retinex) 1. 原理 一幅给定的图像S(x,y)可以分解为两个不同的图像：反射图像R(x,y)和入射图像（也有人称之为亮度图像）L(x,y)，其原理图如下所示： 如上图所示，图像可以看做是入射图像和反射图像构成，入射光照射在反射物体上，通过反射物体的反射，形成反射光进入人眼。最后形成的图像可以如下公式表示： r(x,y)=logR(x,y)=logS(x,y)L(x,y)r(x,y)=logR(x,y)=logS(x,y)L(x,y)
其中，R(x, y)表示了物体的反射性质，即图像内在属性，我们应该最大程度的保留；而L(x, y)表示入射光图像，决定了图像像素能达到的动态范围，我们应该尽量去除。 一般，我们把照射图像假设估计为空间平滑图像，原始图像为S(x, y)，反射图像为R(x, y)，亮度图像为L(x, y)，可以得出上面的公式(1)，以及下面的公式：
r(x,y)=logR(x,y)=logS(x,y)L(x,y)r(x,y)=logR(x,y)=logS(x,y)L(x,y) …………(2)
r(x,y)=logS(x,y)−log[F(x,y)⨂S(x,y)]r(x,y)=log⁡S(x,y)−log⁡[F(x,y)⨂S(x,y)] ………….(3)
这里，r(x, y)是输出图像，式(3)中后面中括号里的运算是卷积运算。F(x, y)是中心环绕函数，表示为：
F(x,y)=λe−(x2&#43;y2)c2F(x,y)=λe−(x2&#43;y2)c2 ………….(4)
式(4)中的C是高斯环绕尺度，λ是一个尺度，它的取值必须满足下式：
∫∫F(x,y)dxdy=1∫∫F(x,y)dxdy=1 ………….(5)
上面的式中可以看出，SSR算法中的卷积是对入射图像的计算，其物理意义是通过计算像素点与周围区域在加权平均的作用下，估计图像中照度的变化，并将L(x,y)L(x,y)属性。
2. 算法的实现流程 单尺度Retinex算法SSR的实现流程可以概括如下：
读原图S(x, y)： 若原图为灰度图：将图像各像素的灰度值由整数型(int)转换为浮点数(float)，并转换到对数域；若原图为彩色图：将颜色分通道处理，每个分量像素值由整数型(int)转换为浮点数(float)，并转换到对数域；输入高斯环绕尺度C，把积分运算离散化，转为求和运算，通过上式(4)(5)确定λ的值；由式(3)得r(x, y)； 若原图是灰度图，则只有一个r(x, y)；若原图为彩色图，则每个通道都有一个对应的r(x, y)；将r(x, y)从对数域转换到实数域，得到输出图像R(x, y)；此时的R(x, y)值的范围并不是0–255，所以还需要进行线性拉伸并转换成相应的格式输出显示。 前面的公式中，中心环绕函数F(x, y)用的是低通函数，这样能够在算法中估计出入射图像对应原始图像的低频部分。从原始图像中除去低频照射部分，就会留下原始图像所对应的高频分量。高频分量很有价值，因为在人类的视觉系统中，人眼对边缘部分的高频信息相当敏感，所以SSR算法可以较好的增强图像中的边缘信息。 由于SSR算法中所选用的高斯函数特点，对于动态范围大幅度压缩和对比度增强两个指标，增强后的图像不能同时保证。但是为了平衡两种增强效果，就必须选择一个较为恰当的高斯尺度常量C。C值一般取值在80–100之间。
3. OpenCV源码 见源码附录的Retenix()函数。
二. 多尺度MSR(Multi-Scale Retinex) 1. 原理 MSR是在SSR基础上发展来的，优点是可以同时保持图像高保真度与对图像的动态范围进行压缩的同时，MSR也可实现色彩增强、颜色恒常性、局部动态范围压缩、全局动态范围压缩，也可以用于X光图像增强。 MSR计算公式如下：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fadf600589c6aef8ce3f1f508cbdae6f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-06T20:55:55+08:00" />
<meta property="article:modified_time" content="2018-11-06T20:55:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">retinex图像增强算法ssr-msr-msrcr详解及其opencv源码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>原文：<a href="https://blog.csdn.net/ajianyingxiaoqinghan/article/details/71435098">https://blog.csdn.net/ajianyingxiaoqinghan/article/details/71435098</a></p> 
<h2 id="retinex图像增强算法ssr-msr-msrcr详解及其opencv源码">Retinex图像增强算法(SSR, MSR, MSRCR)详解及其OpenCV源码</h2> 
<p>Retinex是一种常用的建立在科学实验和科学分析基础上的图像增强方法，它是Edwin.H.Land于1963年提出的。就跟Matlab是由Matrix和Laboratory合成的一样，Retinex也是由两个单词合成的一个词语，他们分别是retina 和cortex，即：视网膜和皮层。Land的retinex模式是建立在以下三个假设之上的：</p> 
<ul><li>真实世界是无颜色的，我们所感知的颜色是光与物质的相互作用的结果。我们见到的水是无色的，但是水膜—肥皂膜却是显现五彩缤纷，那是薄膜表面光干涉的结果。</li><li>每一颜色区域由给定波长的红、绿、蓝三原色构成的；</li><li>三原色决定了每个单位区域的颜色。</li></ul> 
<p>Retinex理论的基础理论是物体的颜色是由物体对长波（红色）、中波（绿色）、短波（蓝色）光线的反射能力来决定的，而不是由反射光强度的绝对值来决定的，物体的色彩不受光照非均匀性的影响，具有一致性，即retinex是以色感一致性（颜色恒常性）为基础的。不同于传统的线性、非线性的只能增强图像某一类特征的方法，Retinex可以在动态范围压缩、边缘增强和颜色恒常三个方面达到平衡，因此可以对各种不同类型的图像进行自适应的增强。</p> 
<p>40多年来，研究人员模仿人类视觉系统发展了Retinex算法，从单尺度Retinex算法，改进成多尺度加权平均的MSR算法，再发展成彩色恢复多尺度MSRCR算法。笔者在本文中，从原理阐述算法的流程，并提供源码地址。</p> 
<p>参考链接： <br> <a href="http://blog.csdn.net/carson2005/article/details/9502053" rel="nofollow noopener noreferrer" target="_blank">http://blog.csdn.net/carson2005/article/details/9502053</a> <br> <a href="http://www.cnblogs.com/Imageshop/archive/2013/04/17/3026881.html" rel="nofollow noopener noreferrer" target="_blank">http://www.cnblogs.com/Imageshop/archive/2013/04/17/3026881.html</a> <br> 参考论文： <br> 《一种结合直方图均衡化和MSRCR的图像增强新算法》——李锦 等人</p> 
<h3 id="一-单尺度ssrsingle-scale-retinex">一. 单尺度SSR(Single Scale Retinex)</h3> 
<h4 id="1-原理">1. 原理</h4> 
<p>一幅给定的图像S(x,y)可以分解为两个不同的图像：反射图像R(x,y)和入射图像（也有人称之为亮度图像）L(x,y)，其原理图如下所示： <br> <img src="https://images2.imgbox.com/88/98/Rno3047y_o.png" alt="这里写图片描述" title=""> <br> 如上图所示，图像可以看做是入射图像和反射图像构成，入射光照射在反射物体上，通过反射物体的反射，形成反射光进入人眼。最后形成的图像可以如下公式表示： <br> <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-47-Frame" tabindex="0"><span class="math" id="MathJax-Span-1"><span class="mrow" id="MathJax-Span-2"><span class="mi" id="MathJax-Span-3">r</span><span class="mo" id="MathJax-Span-4">(</span><span class="mi" id="MathJax-Span-5">x</span><span class="mo" id="MathJax-Span-6">,</span><span class="mi" id="MathJax-Span-7">y</span><span class="mo" id="MathJax-Span-8">)</span><span class="mo" id="MathJax-Span-9">=</span><span class="mi" id="MathJax-Span-10">l</span><span class="mi" id="MathJax-Span-11">o</span><span class="mi" id="MathJax-Span-12">g</span><span class="mi" id="MathJax-Span-13">R</span><span class="mo" id="MathJax-Span-14">(</span><span class="mi" id="MathJax-Span-15">x</span><span class="mo" id="MathJax-Span-16">,</span><span class="mi" id="MathJax-Span-17">y</span><span class="mo" id="MathJax-Span-18">)</span><span class="mo" id="MathJax-Span-19">=</span><span class="mi" id="MathJax-Span-20">l</span><span class="mi" id="MathJax-Span-21">o</span><span class="mi" id="MathJax-Span-22">g</span><span class="mfrac" id="MathJax-Span-23"><span class="mrow" id="MathJax-Span-24"><span class="mi" id="MathJax-Span-25">S</span><span class="mo" id="MathJax-Span-26">(</span><span class="mi" id="MathJax-Span-27">x</span><span class="mo" id="MathJax-Span-28">,</span><span class="mi" id="MathJax-Span-29">y</span><span class="mo" id="MathJax-Span-30">)</span></span><span class="mrow" id="MathJax-Span-31"><span class="mi" id="MathJax-Span-32">L</span><span class="mo" id="MathJax-Span-33">(</span><span class="mi" id="MathJax-Span-34">x</span><span class="mo" id="MathJax-Span-35">,</span><span class="mi" id="MathJax-Span-36">y</span><span class="mo" id="MathJax-Span-37">)</span></span></span></span></span><span class="MJX_Assistive_MathML">r(x,y)=logR(x,y)=logS(x,y)L(x,y)</span></span></p> 
<p>其中，<code>R(x, y)</code>表示了物体的反射性质，即图像内在属性，我们应该最大程度的保留；而<code>L(x, y)</code>表示入射光图像，决定了图像像素能达到的动态范围，我们应该尽量去除。 <br> 一般，我们把照射图像假设估计为空间平滑图像，原始图像为<code>S(x, y)</code>，反射图像为<code>R(x, y)</code>，亮度图像为<code>L(x, y)</code>，可以得出上面的公式(1)，以及下面的公式：</p> 
<p><span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-48-Frame" tabindex="0"><span class="math" id="MathJax-Span-38"><span class="mrow" id="MathJax-Span-39"><span class="mi" id="MathJax-Span-40">r</span><span class="mo" id="MathJax-Span-41">(</span><span class="mi" id="MathJax-Span-42">x</span><span class="mo" id="MathJax-Span-43">,</span><span class="mi" id="MathJax-Span-44">y</span><span class="mo" id="MathJax-Span-45">)</span><span class="mo" id="MathJax-Span-46">=</span><span class="mi" id="MathJax-Span-47">l</span><span class="mi" id="MathJax-Span-48">o</span><span class="mi" id="MathJax-Span-49">g</span><span class="mi" id="MathJax-Span-50">R</span><span class="mo" id="MathJax-Span-51">(</span><span class="mi" id="MathJax-Span-52">x</span><span class="mo" id="MathJax-Span-53">,</span><span class="mi" id="MathJax-Span-54">y</span><span class="mo" id="MathJax-Span-55">)</span><span class="mo" id="MathJax-Span-56">=</span><span class="mi" id="MathJax-Span-57">l</span><span class="mi" id="MathJax-Span-58">o</span><span class="mi" id="MathJax-Span-59">g</span><span class="mfrac" id="MathJax-Span-60"><span class="mrow" id="MathJax-Span-61"><span class="mi" id="MathJax-Span-62">S</span><span class="mo" id="MathJax-Span-63">(</span><span class="mi" id="MathJax-Span-64">x</span><span class="mo" id="MathJax-Span-65">,</span><span class="mi" id="MathJax-Span-66">y</span><span class="mo" id="MathJax-Span-67">)</span></span><span class="mrow" id="MathJax-Span-68"><span class="mi" id="MathJax-Span-69">L</span><span class="mo" id="MathJax-Span-70">(</span><span class="mi" id="MathJax-Span-71">x</span><span class="mo" id="MathJax-Span-72">,</span><span class="mi" id="MathJax-Span-73">y</span><span class="mo" id="MathJax-Span-74">)</span></span></span></span></span><span class="MJX_Assistive_MathML">r(x,y)=logR(x,y)=logS(x,y)L(x,y)</span></span> …………(2)</p> 
<p><span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-49-Frame" tabindex="0"><span class="math" id="MathJax-Span-75"><span class="mrow" id="MathJax-Span-76"><span class="mi" id="MathJax-Span-77">r</span><span class="mo" id="MathJax-Span-78">(</span><span class="mi" id="MathJax-Span-79">x</span><span class="mo" id="MathJax-Span-80">,</span><span class="mi" id="MathJax-Span-81">y</span><span class="mo" id="MathJax-Span-82">)</span><span class="mo" id="MathJax-Span-83">=</span><span class="mi" id="MathJax-Span-84">log</span><span class="mo" id="MathJax-Span-85"></span><span class="mi" id="MathJax-Span-86">S</span><span class="mo" id="MathJax-Span-87">(</span><span class="mi" id="MathJax-Span-88">x</span><span class="mo" id="MathJax-Span-89">,</span><span class="mi" id="MathJax-Span-90">y</span><span class="mo" id="MathJax-Span-91">)</span><span class="mo" id="MathJax-Span-92">−</span><span class="mi" id="MathJax-Span-93">log</span><span class="mo" id="MathJax-Span-94"></span><span class="mo" id="MathJax-Span-95">[</span><span class="mi" id="MathJax-Span-96">F</span><span class="mo" id="MathJax-Span-97">(</span><span class="mi" id="MathJax-Span-98">x</span><span class="mo" id="MathJax-Span-99">,</span><span class="mi" id="MathJax-Span-100">y</span><span class="mo" id="MathJax-Span-101">)</span><span class="mo" id="MathJax-Span-102">⨂</span><span class="mi" id="MathJax-Span-103">S</span><span class="mo" id="MathJax-Span-104">(</span><span class="mi" id="MathJax-Span-105">x</span><span class="mo" id="MathJax-Span-106">,</span><span class="mi" id="MathJax-Span-107">y</span><span class="mo" id="MathJax-Span-108">)</span><span class="mo" id="MathJax-Span-109">]</span></span></span><span class="MJX_Assistive_MathML">r(x,y)=log⁡S(x,y)−log⁡[F(x,y)⨂S(x,y)]</span></span> ………….(3)</p> 
<p>这里，<code>r(x, y)</code>是输出图像，式(3)中后面中括号里的运算是卷积运算。<code>F(x, y)</code>是中心环绕函数，表示为：</p> 
<p><span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-50-Frame" tabindex="0"><span class="math" id="MathJax-Span-110"><span class="mrow" id="MathJax-Span-111"><span class="mi" id="MathJax-Span-112">F</span><span class="mo" id="MathJax-Span-113">(</span><span class="mi" id="MathJax-Span-114">x</span><span class="mo" id="MathJax-Span-115">,</span><span class="mi" id="MathJax-Span-116">y</span><span class="mo" id="MathJax-Span-117">)</span><span class="mo" id="MathJax-Span-118">=</span><span class="mi" id="MathJax-Span-119">λ</span><span class="msubsup" id="MathJax-Span-120"><span class="mi" id="MathJax-Span-121">e</span><span class="texatom" id="MathJax-Span-122"><span class="mrow" id="MathJax-Span-123"><span class="mfrac" id="MathJax-Span-124"><span class="mrow" id="MathJax-Span-125"><span class="mo" id="MathJax-Span-126">−</span><span class="mo" id="MathJax-Span-127">(</span><span class="msubsup" id="MathJax-Span-128"><span class="mi" id="MathJax-Span-129">x</span><span class="mn" id="MathJax-Span-130">2</span></span><span class="mo" id="MathJax-Span-131">+</span><span class="msubsup" id="MathJax-Span-132"><span class="mi" id="MathJax-Span-133">y</span><span class="mn" id="MathJax-Span-134">2</span></span><span class="mo" id="MathJax-Span-135">)</span></span><span class="msubsup" id="MathJax-Span-136"><span class="mi" id="MathJax-Span-137">c</span><span class="texatom" id="MathJax-Span-138"><span class="mrow" id="MathJax-Span-139"><span class="mn" id="MathJax-Span-140">2</span></span></span></span></span></span></span></span></span></span><span class="MJX_Assistive_MathML">F(x,y)=λe−(x2+y2)c2</span></span> ………….(4)</p> 
<p>式(4)中的C是<strong><font color="red">高斯环绕尺度</font></strong>，λ是一个尺度，它的取值必须满足下式：</p> 
<p><span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-51-Frame" tabindex="0"><span class="math" id="MathJax-Span-141"><span class="mrow" id="MathJax-Span-142"><span class="mo" id="MathJax-Span-143">∫</span><span class="mo" id="MathJax-Span-144">∫</span><span class="mi" id="MathJax-Span-145">F</span><span class="mo" id="MathJax-Span-146">(</span><span class="mi" id="MathJax-Span-147">x</span><span class="mo" id="MathJax-Span-148">,</span><span class="mi" id="MathJax-Span-149">y</span><span class="mo" id="MathJax-Span-150">)</span><span class="mi" id="MathJax-Span-151">d</span><span class="mi" id="MathJax-Span-152">x</span><span class="mi" id="MathJax-Span-153">d</span><span class="mi" id="MathJax-Span-154">y</span><span class="mo" id="MathJax-Span-155">=</span><span class="mn" id="MathJax-Span-156">1</span></span></span><span class="MJX_Assistive_MathML">∫∫F(x,y)dxdy=1</span></span> ………….(5)</p> 
<p>上面的式中可以看出，SSR算法中的卷积是对入射图像的计算，其物理意义是通过计算像素点与周围区域在加权平均的作用下，估计图像中照度的变化，并将<span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-52-Frame" tabindex="0"><span class="math" id="MathJax-Span-157"><span class="mrow" id="MathJax-Span-158"><span class="mi" id="MathJax-Span-159">L</span><span class="mo" id="MathJax-Span-160">(</span><span class="mi" id="MathJax-Span-161">x</span><span class="mo" id="MathJax-Span-162">,</span><span class="mi" id="MathJax-Span-163">y</span><span class="mo" id="MathJax-Span-164">)</span></span></span><span class="MJX_Assistive_MathML">L(x,y)</span></span>属性。</p> 
<h4 id="2-算法的实现流程">2. 算法的实现流程</h4> 
<p>单尺度Retinex算法SSR的实现流程可以概括如下：</p> 
<ol><li>读原图S(x, y)： <br> 
  <ul><li>若原图为灰度图：将图像各像素的灰度值由整数型(int)转换为浮点数(float)，并转换到对数域；</li><li>若原图为彩色图：将颜色分通道处理，每个分量像素值由整数型(int)转换为浮点数(float)，并转换到对数域；</li></ul></li><li>输入高斯环绕尺度C，把积分运算离散化，转为求和运算，通过上式(4)(5)确定λ的值；</li><li>由式(3)得<code>r(x, y)</code>； <br> 
  <ul><li>若原图是灰度图，则只有一个<code>r(x, y)</code>；</li><li>若原图为彩色图，则每个通道都有一个对应的<code>r(x, y)</code>；</li></ul></li><li>将<code>r(x, y)</code>从对数域转换到实数域，得到输出图像<code>R(x, y)</code>；</li><li>此时的<code>R(x, y)</code>值的范围并不是0–255，所以还需要进行线性拉伸并转换成相应的格式输出显示。</li></ol> 
<p>前面的公式中，中心环绕函数<code>F(x, y)</code>用的是低通函数，这样能够在算法中估计出入射图像对应原始图像的低频部分。从原始图像中除去低频照射部分，就会留下原始图像所对应的高频分量。高频分量很有价值，因为在人类的视觉系统中，人眼对边缘部分的高频信息相当敏感，所以SSR算法可以较好的增强图像中的边缘信息。 <br> 由于SSR算法中所选用的高斯函数特点，对于动态范围大幅度压缩和对比度增强两个指标，增强后的图像不能同时保证。但是为了平衡两种增强效果，就必须选择一个较为恰当的高斯尺度常量C。C值一般取值在80–100之间。</p> 
<h4 id="3-opencv源码">3. OpenCV源码</h4> 
<p>见源码附录的Retenix()函数。</p> 
<h3 id="二-多尺度msrmulti-scale-retinex">二. 多尺度MSR(Multi-Scale Retinex)</h3> 
<h4 id="1-原理-1">1. 原理</h4> 
<p>MSR是在SSR基础上发展来的，优点是可以同时保持图像高保真度与对图像的动态范围进行压缩的同时，MSR也可实现色彩增强、颜色恒常性、局部动态范围压缩、全局动态范围压缩，也可以用于X光图像增强。 <br> MSR计算公式如下：</p> 
<p><span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-6-Frame" tabindex="0"><span class="math" id="MathJax-Span-173"><span class="mrow" id="MathJax-Span-174"><span class="mi" id="MathJax-Span-175">r</span><span class="mo" id="MathJax-Span-176">(</span><span class="mi" id="MathJax-Span-177">x</span><span class="mo" id="MathJax-Span-178">,</span><span class="mi" id="MathJax-Span-179">y</span><span class="mo" id="MathJax-Span-180">)</span><span class="mo" id="MathJax-Span-181">=</span><span class="munderover" id="MathJax-Span-182"><span class="mo" id="MathJax-Span-183">∑</span><span class="texatom" id="MathJax-Span-184"><span class="mrow" id="MathJax-Span-185"><span class="mi" id="MathJax-Span-186">K</span></span></span><span class="texatom" id="MathJax-Span-187"><span class="mrow" id="MathJax-Span-188"><span class="mi" id="MathJax-Span-189">k</span></span></span></span><span class="msubsup" id="MathJax-Span-190"><span class="mi" id="MathJax-Span-191">w</span><span class="texatom" id="MathJax-Span-192"><span class="mrow" id="MathJax-Span-193"><span class="mi" id="MathJax-Span-194">k</span></span></span></span><span class="mo" id="MathJax-Span-195">{<!-- --></span><span class="mi" id="MathJax-Span-196">log</span><span class="mo" id="MathJax-Span-197"></span><span class="mi" id="MathJax-Span-198">S</span><span class="mo" id="MathJax-Span-199">(</span><span class="mi" id="MathJax-Span-200">x</span><span class="mo" id="MathJax-Span-201">,</span><span class="mi" id="MathJax-Span-202">y</span><span class="mo" id="MathJax-Span-203">)</span><span class="mo" id="MathJax-Span-204">−</span><span class="mi" id="MathJax-Span-205">log</span><span class="mo" id="MathJax-Span-206"></span><span class="mo" id="MathJax-Span-207">[</span><span class="msubsup" id="MathJax-Span-208"><span class="mi" id="MathJax-Span-209">F</span><span class="texatom" id="MathJax-Span-210"><span class="mrow" id="MathJax-Span-211"><span class="mi" id="MathJax-Span-212">k</span></span></span></span><span class="mo" id="MathJax-Span-213">(</span><span class="mi" id="MathJax-Span-214">x</span><span class="mo" id="MathJax-Span-215">,</span><span class="mi" id="MathJax-Span-216">y</span><span class="mo" id="MathJax-Span-217">)</span><span class="mo" id="MathJax-Span-218">⋅</span><span class="mi" id="MathJax-Span-219">S</span><span class="mo" id="MathJax-Span-220">(</span><span class="mi" id="MathJax-Span-221">x</span><span class="mo" id="MathJax-Span-222">,</span><span class="mi" id="MathJax-Span-223">y</span><span class="mo" id="MathJax-Span-224">)</span><span class="mo" id="MathJax-Span-225">]</span><span class="mo" id="MathJax-Span-226">}</span></span></span><span class="MJX_Assistive_MathML">r(x,y)=∑kKwk{log⁡S(x,y)−log⁡[Fk(x,y)⋅S(x,y)]}</span></span> …………(6)</p> 
<p>式中，K是高斯中心环绕函数的个数。当K=1时，MSR退化为SSR。 <br> 通常来讲，为了保证兼有SSR高、中、低三个尺度的优点来考虑，K取值通常为3，且有：</p> 
<p><span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-7-Frame" tabindex="0"><span class="math" id="MathJax-Span-227"><span class="mrow" id="MathJax-Span-228"><span class="msubsup" id="MathJax-Span-229"><span class="mi" id="MathJax-Span-230">w</span><span class="texatom" id="MathJax-Span-231"><span class="mrow" id="MathJax-Span-232"><span class="mn" id="MathJax-Span-233">1</span></span></span></span><span class="mo" id="MathJax-Span-234">=</span><span class="msubsup" id="MathJax-Span-235"><span class="mi" id="MathJax-Span-236">w</span><span class="texatom" id="MathJax-Span-237"><span class="mrow" id="MathJax-Span-238"><span class="mn" id="MathJax-Span-239">2</span></span></span></span><span class="mo" id="MathJax-Span-240">=</span><span class="msubsup" id="MathJax-Span-241"><span class="mi" id="MathJax-Span-242">w</span><span class="texatom" id="MathJax-Span-243"><span class="mrow" id="MathJax-Span-244"><span class="mn" id="MathJax-Span-245">3</span></span></span></span><span class="mo" id="MathJax-Span-246">=</span><span class="mfrac" id="MathJax-Span-247"><span class="mn" id="MathJax-Span-248">1</span><span class="mn" id="MathJax-Span-249">3</span></span></span></span><span class="MJX_Assistive_MathML">w1=w2=w3=13</span></span> …………(7)</p> 
<p>此外，实验表明，ci分别取15, 80, 200可以得到较好效果。</p> 
<p>一般的Retinex算法对光照图像估计时，都会假设初始光照图像是缓慢变化的，即光照图像是平滑的。但实际并非如此，亮度相差很大区域的边缘处，图像光照变化并不平滑。所以在这种情况下，Retinuex增强算法在亮度差异大区域的增强图像会产生光晕。 <br> 另外MSR常见的缺点还有边缘锐化不足，阴影边界突兀，部分颜色发生扭曲，纹理不清晰，高光区域细节没有得到明显改善，对高光区域敏感度小等。</p> 
<h4 id="2-效果对比">2. 效果对比</h4> 
<p>对于SSR与MSR的效果如下所示： <br> <img src="https://images2.imgbox.com/34/ac/z4BU3fjA_o.jpg" alt="原图" title=""> <br> 原图 <br> <img src="https://images2.imgbox.com/53/9a/p05hatBc_o.png" alt="SSR（尺度为300）增强" title=""> <br> SSR（尺度为300）增强 <br> <img src="https://images2.imgbox.com/ed/0b/IWC5xEvu_o.png" alt="MSR（尺度为300，尺度数为3）增强" title=""> <br> MSR（尺度为300，尺度数为3）增强</p> 
<p><img src="https://images2.imgbox.com/47/d2/KarqkmEY_o.jpg" alt="原图" title=""> <br> 原图 <br> <img src="https://images2.imgbox.com/0a/f8/J1MGJ0oo_o.png" alt="SSR（尺度为300）增强" title=""> <br> SSR（尺度为300）增强 <br> <img src="https://images2.imgbox.com/ef/5a/w200xaKw_o.png" alt="MSR（最大尺度为300，尺度数为3）增强" title=""> <br> MSR（最大尺度为300，尺度数为3）增强</p> 
<h4 id="3-opencv源码-1">3. OpenCV源码</h4> 
<p>见源码附录的MultiScaleRetinex()函数。</p> 
<h3 id="三-带颜色恢复的msr方法msrcrmulti-scale-retinex-with-color-restoration">三. 带颜色恢复的MSR方法MSRCR(Multi-Scale Retinex with Color Restoration)</h3> 
<p>在以上的两幅测试图像中，特别是第二幅，我们看到明显的偏色效果，这就是SSR和MSR普遍都存在的问题。</p> 
<p>为此，研究者又开发出一种称之为带色彩恢复的多尺度视网膜增强算法（MSRCR,Multi-Scale Retinex with Color Restoration) ，具体讨论的过程详见《A Multiscale Retinex for Bridging the Gap Between Color Images and the Human Observation of Scenes》论文。</p> 
<h4 id="1-原理-2">1. 原理</h4> 
<p>在前面的增强过程中，图像可能会因为增加了噪声，而使得图像的局部细节色彩失真，不能显现出物体的真正颜色，整体视觉效果变差。针对这一点不足，MSRCR在MSR的基础上，加入了色彩恢复因子C来调节由于图像局部区域对比度增强而导致颜色失真的缺陷。 <br> 改进算法如下所示：</p> 
<p><span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-8-Frame" tabindex="0"><span class="math" id="MathJax-Span-250"><span class="mrow" id="MathJax-Span-251"><span class="msubsup" id="MathJax-Span-252"><span class="mi" id="MathJax-Span-253">R</span><span class="texatom" id="MathJax-Span-254"><span class="mrow" id="MathJax-Span-255"><span class="mi" id="MathJax-Span-256">M</span><span class="mi" id="MathJax-Span-257">S</span><span class="mi" id="MathJax-Span-258">R</span><span class="mi" id="MathJax-Span-259">C</span><span class="msubsup" id="MathJax-Span-260"><span class="mi" id="MathJax-Span-261">R</span><span class="texatom" id="MathJax-Span-262"><span class="mrow" id="MathJax-Span-263"><span class="mi" id="MathJax-Span-264">i</span></span></span></span></span></span></span><span class="mo" id="MathJax-Span-265">(</span><span class="mi" id="MathJax-Span-266">x</span><span class="mo" id="MathJax-Span-267">,</span><span class="mi" id="MathJax-Span-268">y</span><span class="mo" id="MathJax-Span-269">)</span><span class="mo" id="MathJax-Span-270">=</span><span class="msubsup" id="MathJax-Span-271"><span class="mi" id="MathJax-Span-272">C</span><span class="texatom" id="MathJax-Span-273"><span class="mrow" id="MathJax-Span-274"><span class="mi" id="MathJax-Span-275">i</span></span></span></span><span class="mo" id="MathJax-Span-276">(</span><span class="mi" id="MathJax-Span-277">x</span><span class="mo" id="MathJax-Span-278">,</span><span class="mi" id="MathJax-Span-279">y</span><span class="mo" id="MathJax-Span-280">)</span><span class="msubsup" id="MathJax-Span-281"><span class="mi" id="MathJax-Span-282">R</span><span class="texatom" id="MathJax-Span-283"><span class="mrow" id="MathJax-Span-284"><span class="mi" id="MathJax-Span-285">M</span><span class="mi" id="MathJax-Span-286">S</span><span class="msubsup" id="MathJax-Span-287"><span class="mi" id="MathJax-Span-288">R</span><span class="texatom" id="MathJax-Span-289"><span class="mrow" id="MathJax-Span-290"><span class="mi" id="MathJax-Span-291">i</span></span></span></span></span></span></span><span class="mo" id="MathJax-Span-292">(</span><span class="mi" id="MathJax-Span-293">x</span><span class="mo" id="MathJax-Span-294">,</span><span class="mi" id="MathJax-Span-295">y</span><span class="mo" id="MathJax-Span-296">)</span></span></span><span class="MJX_Assistive_MathML">RMSRCRi(x,y)=Ci(x,y)RMSRi(x,y)</span></span> …………(10) <br> 其中参数说明如下：</p> 
<ul><li>Ii(x, y)表示第i个通道的图像</li><li>Ci表示第i个通道的彩色回复因子，用来调节3个通道颜色的比例；</li><li>f(·)表示颜色空间的映射函数；</li><li>β是增益常数；</li><li>α是受控制的非线性强度；</li></ul> 
<p>MSRCR算法利用彩色恢复因子C，调节原始图像中3个颜色通道之间的比例关系，从而把相对较暗区域的信息凸显出来，达到了消除图像色彩失真的缺陷。 <br> 处理后的图像局部对比度提高，亮度与真实场景相似，在人们视觉感知下，图像显得更加逼真。</p> 
<p>但是MSRCR算法处理图像后，像素值一般会出现负值。所以从对数域<code>r(x, y)</code>转换为实数域<code>R(x, y)</code>后，需要通过改变增益Gain，偏差Offset对图像进行修正。使用公式可以表示为： <br> <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-11-Frame" tabindex="0"><span class="math" id="MathJax-Span-456"><span class="mrow" id="MathJax-Span-457"><span class="msubsup" id="MathJax-Span-458"><span class="mi" id="MathJax-Span-459">R</span><span class="texatom" id="MathJax-Span-460"><span class="mrow" id="MathJax-Span-461"><span class="mi" id="MathJax-Span-462">M</span><span class="mi" id="MathJax-Span-463">S</span><span class="mi" id="MathJax-Span-464">R</span><span class="mi" id="MathJax-Span-465">C</span><span class="msubsup" id="MathJax-Span-466"><span class="mi" id="MathJax-Span-467">R</span><span class="texatom" id="MathJax-Span-468"><span class="mrow" id="MathJax-Span-469"><span class="mi" id="MathJax-Span-470">i</span></span></span></span></span></span></span><span class="mo" id="MathJax-Span-471">(</span><span class="mi" id="MathJax-Span-472">x</span><span class="mo" id="MathJax-Span-473">,</span><span class="mi" id="MathJax-Span-474">y</span><span class="msup" id="MathJax-Span-475"><span class="mo" id="MathJax-Span-476">)</span><span class="mo" id="MathJax-Span-477">′</span></span><span class="mo" id="MathJax-Span-478">=</span><span class="mi" id="MathJax-Span-479">G</span><span class="mo" id="MathJax-Span-480">⋅</span><span class="msubsup" id="MathJax-Span-481"><span class="mi" id="MathJax-Span-482">R</span><span class="texatom" id="MathJax-Span-483"><span class="mrow" id="MathJax-Span-484"><span class="mi" id="MathJax-Span-485">M</span><span class="mi" id="MathJax-Span-486">S</span><span class="mi" id="MathJax-Span-487">R</span><span class="mi" id="MathJax-Span-488">C</span><span class="msubsup" id="MathJax-Span-489"><span class="mi" id="MathJax-Span-490">R</span><span class="texatom" id="MathJax-Span-491"><span class="mrow" id="MathJax-Span-492"><span class="mi" id="MathJax-Span-493">i</span></span></span></span></span></span></span><span class="mo" id="MathJax-Span-494">(</span><span class="mi" id="MathJax-Span-495">x</span><span class="mo" id="MathJax-Span-496">,</span><span class="mi" id="MathJax-Span-497">y</span><span class="mo" id="MathJax-Span-498">)</span><span class="mo" id="MathJax-Span-499">+</span><span class="mi" id="MathJax-Span-500">O</span></span></span><span class="MJX_Assistive_MathML">RMSRCRi(x,y)′=G⋅RMSRCRi(x,y)+O</span></span> …………(11) <br> 式(11)中，G表示增益Gain，O表示偏差Offset。它们的值取决于软件中的算法实现。</p> 
<h4 id="2-msrcr其他实现方法">2. MSRCR其他实现方法</h4> 
<p>MSRCR方法如上，且获得了不错的效果。但在博文<a href="http://blog.csdn.net/yayan01/article/details/50129391" rel="nofollow noopener noreferrer" target="_blank">《MSRCR》</a>中，作者认为论文里的方法不起任何作用，并且论文里为了这个又引入了太多的可调参数，增加了算法的复杂性，不利于自动化实现。 <br> 博文作者认为，GIMP的contrast-retinex.c文件里使用的算法很好，效果也很好。他直接从量化的方式上入手，引入了均值和均方差的概念，再加上一个控制图像动态的参数来实现无色偏的调节过程，简要描述如下：</p> 
<ul><li>计算出 log[R(x,y)]中R/G/B各通道数据的均值Mean和均方差Var（注意是均方差）。</li><li>类似下述公式计算各通道的Min和Max值。 <br> 
  <ul><li>Min = Mean - Dynamic * Var;</li><li>Max = Mean + Dynamic * Var;</li></ul></li><li>对Log[R(x,y)]的每一个值Value，进行线性映射： <br> R(x,y) = ( Value - Min ) / (Max - Min) * (255 - 0), 同时要注意增加一个溢出判断，即： <br> 
  <ul><li>if (R(x, y) &gt; 255) R(x,y) = 255;</li><li>else if (R(x,y) &lt; 0) R(x,y) = 0;</li></ul></li></ul> 
<p>就是经过这么简单的处理，实践证明可以取得非常好的效果，下面贴出一些处理后的效果。</p> 
<p><img src="https://images2.imgbox.com/76/7a/sKiXJV0i_o.png" alt="MSR（尺度为300，尺度数为3）增强" title=""> <br> MSR（尺度为300，尺度数为3）增强 <br> <img src="https://images2.imgbox.com/c9/99/PtAzN8hp_o.png" alt="MSRCR（尺度为300,尺度数3,Dynamic = 2）增强" title=""> <br> MSRCR（尺度为300,尺度数3,Dynamic = 2）增强 <br> <img src="https://images2.imgbox.com/f3/97/VoLjDTJg_o.png" alt="MSRCR（尺度为300,尺度数6,Dynamic = 2）增强" title=""> <br> MSRCR（尺度为300,尺度数6,Dynamic = 2）增强</p> 
<p><img src="https://images2.imgbox.com/ad/6c/kLgp4yzs_o.png" alt="MSR（尺度300，尺度数为3）增强" title=""> <br> MSR（尺度300，尺度数为3）增强 <br> <img src="https://images2.imgbox.com/19/ea/73zdbQN1_o.png" alt="MSRCR（尺度300,尺度为3,Dynamic = 2）增强图像" title=""> <br> MSRCR（尺度300, 尺度为3, Dynamic = 2）增强图像 <br> <img src="https://images2.imgbox.com/70/a2/3OWXFgaM_o.png" alt="MSRCR（尺度300,尺度为6,Dynamic = 2）增强图像" title=""> <br> MSRCR（尺度300, 尺度为6, Dynamic = 2）增强图像</p> 
<p>由以上三幅图的效果得出的结论：</p> 
<ul><li>MSRCR效果要比MSR好很多，基本消除了色偏。</li><li>对于MSRCR，尺度数对结果的影像不是特别大，但是随着尺度数的增加，算法耗时会线性增加，因此，一般尺度数取3就较为合适了。</li></ul> 
<p>继续做比较： <br> <img src="https://images2.imgbox.com/3f/e6/iaMJbrlG_o.png" alt="MSRCR（Dynamic = 1）增强图像" title=""> <br> MSRCR（Dynamic = 1）增强图像 <br> <img src="https://images2.imgbox.com/6b/be/MUlbPw9a_o.png" alt="MSRCR（Dynamic = 2）增强图像" title=""> <br> MSRCR（Dynamic = 2）增强图像 <br> <img src="https://images2.imgbox.com/ad/9a/fAcP3T02_o.png" alt="MSRCR（Dynamic = 5）增强图像" title=""> <br> MSRCR（Dynamic = 5）增强图像</p> 
<p><img src="https://images2.imgbox.com/76/58/BxYipfaf_o.png" alt="MSRCR（Dynamic = 1）增强图像" title=""> <br> MSRCR（Dynamic = 1）增强图像 <br> <img src="https://images2.imgbox.com/72/75/fP65KAiY_o.png" alt="MSRCR（Dynamic = 2）增强图像" title=""> <br> MSRCR（Dynamic = 2）增强图像 <br> <img src="https://images2.imgbox.com/d4/bf/ecujeGPH_o.png" alt="MSRCR（Dynamic = 5）增强图像" title=""> <br> MSRCR（Dynamic = 5）增强图像</p> 
<p>由以上三幅图的效果得出的结论：</p> 
<ul><li>Dynamic取值越小，图像的对比度越强。</li><li>一般来说Dynamic取值2-3之间能取得较为明显的增强效果，即能取得很自然过渡效果，又能保持图像的清晰度适度增强。</li></ul> 
<p>关于尺度，个人建议取值以大于100为佳。</p> 
<p>retinex算法的效果对于一些正常的图像处理后的效果并不佳，我们可以认为它就是为那些在外界环境不理想的状态下拍摄的图像增强而设计的，如对于航拍的雾天图片，医学上的成像图片等成像条件恶劣的图有很明显的效果。笔者的毕业设计涉及了水下图像的修复，水下图像相对于空气中成像性低，应该会有很大的效果。</p> 
<p>NASA在处理航天相关照片时也使用了Retinex技术。关于NASA对Retinex技术的应用，可以参考：<a href="http://dragon.larc.nasa.gov/retinex/" rel="nofollow noopener noreferrer" target="_blank">http://dragon.larc.nasa.gov/retinex/</a></p> 
<p>关于GIMP的实现代码，笔者提供从网上找到的链接。如果要想完全看懂代码的意思很难，但算法部分还是不难提取的（不过笔者也懒得把它移植到OpenCV上……）下载链接如下； <br> <a href="http://files.cnblogs.com/Imageshop/contrast-retinex.rar" rel="nofollow noopener noreferrer" target="_blank">http://files.cnblogs.com/Imageshop/contrast-retinex.rar</a></p> 
<h3 id="四-retinex图像增强算法的其他算法">四. Retinex图像增强算法的其他算法</h3> 
<p>先贴出前面MSRCR的基本公式如下： <br> </p> 
<p><span class="MathJax_Preview"></span></p> 
<div class="MathJax_Display"></div> 
<span class="MathJax_Preview"></span> 
<div class="MathJax_Display"> 
 <span class="MathJax" id="MathJax-Element-12-Frame" tabindex="0"><span class="math" id="MathJax-Span-501"><span class="mrow" id="MathJax-Span-502"><span class="msubsup" id="MathJax-Span-503"><span class="mi" id="MathJax-Span-504">R</span><span class="texatom" id="MathJax-Span-505"><span class="mrow" id="MathJax-Span-506"><span class="mi" id="MathJax-Span-507">M</span><span class="mi" id="MathJax-Span-508">S</span><span class="mi" id="MathJax-Span-509">R</span><span class="mi" id="MathJax-Span-510">C</span><span class="msubsup" id="MathJax-Span-511"><span class="mi" id="MathJax-Span-512">R</span><span class="texatom" id="MathJax-Span-513"><span class="mrow" id="MathJax-Span-514"><span class="mi" id="MathJax-Span-515">i</span></span></span></span></span></span></span><span class="mo" id="MathJax-Span-516">(</span><span class="mi" id="MathJax-Span-517">x</span><span class="mo" id="MathJax-Span-518">,</span><span class="mi" id="MathJax-Span-519">y</span><span class="mo" id="MathJax-Span-520">)</span><span class="mo" id="MathJax-Span-521">=</span><span class="mn" id="MathJax-Span-522">255</span><span class="mfrac" id="MathJax-Span-523"><span class="mrow" id="MathJax-Span-524"><span class="msubsup" id="MathJax-Span-525"><span class="mi" id="MathJax-Span-526">R</span><span class="texatom" id="MathJax-Span-527"><span class="mrow" id="MathJax-Span-528"><span class="mi" id="MathJax-Span-529">M</span><span class="mi" id="MathJax-Span-530">S</span><span class="mi" id="MathJax-Span-531">R</span><span class="mi" id="MathJax-Span-532">C</span><span class="msubsup" id="MathJax-Span-533"><span class="mi" id="MathJax-Span-534">R</span><span class="texatom" id="MathJax-Span-535"><span class="mrow" id="MathJax-Span-536"><span class="mi" id="MathJax-Span-537">i</span></span></span></span></span></span></span><span class="mo" id="MathJax-Span-538">(</span><span class="mi" id="MathJax-Span-539">x</span><span class="mo" id="MathJax-Span-540">,</span><span class="mi" id="MathJax-Span-541">y</span><span class="mo" id="MathJax-Span-542">)</span><span class="mo" id="MathJax-Span-543">−</span><span class="mi" id="MathJax-Span-544">m</span><span class="mi" id="MathJax-Span-545">i</span><span class="msubsup" id="MathJax-Span-546"><span class="mi" id="MathJax-Span-547">n</span><span class="texatom" id="MathJax-Span-548"><span class="mrow" id="MathJax-Span-549"><span class="mi" id="MathJax-Span-550">i</span></span></span></span><span class="mo" id="MathJax-Span-551">(</span><span class="mi" id="MathJax-Span-552">m</span><span class="mi" id="MathJax-Span-553">i</span><span class="msubsup" id="MathJax-Span-554"><span class="mi" id="MathJax-Span-555">n</span><span class="texatom" id="MathJax-Span-556"><span class="mrow" id="MathJax-Span-557"><span class="mo" id="MathJax-Span-558">(</span><span class="mi" id="MathJax-Span-559">x</span><span class="mo" id="MathJax-Span-560">,</span><span class="mi" id="MathJax-Span-561">y</span><span class="mo" id="MathJax-Span-562">)</span></span></span></span><span class="msubsup" id="MathJax-Span-563"><span class="mi" id="MathJax-Span-564">R</span><span class="texatom" id="MathJax-Span-565"><span class="mrow" id="MathJax-Span-566"><span class="mi" id="MathJax-Span-567">M</span><span class="mi" id="MathJax-Span-568">S</span><span class="mi" id="MathJax-Span-569">R</span><span class="mi" id="MathJax-Span-570">C</span><span class="msubsup" id="MathJax-Span-571"><span class="mi" id="MathJax-Span-572">R</span><span class="texatom" id="MathJax-Span-573"><span class="mrow" id="MathJax-Span-574"><span class="mi" id="MathJax-Span-575">i</span></span></span></span></span></span></span><span class="mo" id="MathJax-Span-576">(</span><span class="mi" id="MathJax-Span-577">x</span><span class="mo" id="MathJax-Span-578">,</span><span class="mi" id="MathJax-Span-579">y</span><span class="mo" id="MathJax-Span-580">)</span><span class="mo" id="MathJax-Span-581">)</span></span><span class="mrow" id="MathJax-Span-582"><span class="mi" id="MathJax-Span-583">m</span><span class="mi" id="MathJax-Span-584">a</span><span class="msubsup" id="MathJax-Span-585"><span class="mi" id="MathJax-Span-586">x</span><span class="texatom" id="MathJax-Span-587"><span class="mrow" id="MathJax-Span-588"><span class="mi" id="MathJax-Span-589">i</span></span></span></span><span class="mo" id="MathJax-Span-590">(</span><span class="mi" id="MathJax-Span-591">m</span><span class="mi" id="MathJax-Span-592">a</span><span class="msubsup" id="MathJax-Span-593"><span class="mi" id="MathJax-Span-594">x</span><span class="texatom" id="MathJax-Span-595"><span class="mrow" id="MathJax-Span-596"><span class="mo" id="MathJax-Span-597">(</span><span class="mi" id="MathJax-Span-598">x</span><span class="mo" id="MathJax-Span-599">,</span><span class="mi" id="MathJax-Span-600">y</span><span class="mo" id="MathJax-Span-601">)</span></span></span></span><span class="msubsup" id="MathJax-Span-602"><span class="mi" id="MathJax-Span-603">R</span><span class="texatom" id="MathJax-Span-604"><span class="mrow" id="MathJax-Span-605"><span class="mi" id="MathJax-Span-606">M</span><span class="mi" id="MathJax-Span-607">S</span><span class="mi" id="MathJax-Span-608">R</span><span class="mi" id="MathJax-Span-609">C</span><span class="msubsup" id="MathJax-Span-610"><span class="mi" id="MathJax-Span-611">R</span><span class="texatom" id="MathJax-Span-612"><span class="mrow" id="MathJax-Span-613"><span class="mi" id="MathJax-Span-614">i</span></span></span></span></span></span></span><span class="mo" id="MathJax-Span-615">(</span><span class="mi" id="MathJax-Span-616">x</span><span class="mo" id="MathJax-Span-617">,</span><span class="mi" id="MathJax-Span-618">y</span><span class="mo" id="MathJax-Span-619">)</span><span class="mo" id="MathJax-Span-620">−</span><span class="mi" id="MathJax-Span-621">m</span><span class="mi" id="MathJax-Span-622">i</span><span class="msubsup" id="MathJax-Span-623"><span class="mi" id="MathJax-Span-624">n</span><span class="texatom" id="MathJax-Span-625"><span class="mrow" id="MathJax-Span-626"><span class="mi" id="MathJax-Span-627">i</span></span></span></span><span class="mo" id="MathJax-Span-628">(</span><span class="mi" id="MathJax-Span-629">m</span><span class="mi" id="MathJax-Span-630">i</span><span class="mi" id="MathJax-Span-631">n</span><span class="texatom" id="MathJax-Span-632"><span class="mrow" id="MathJax-Span-633"><span class="mo" id="MathJax-Span-634">(</span><span class="mi" id="MathJax-Span-635">x</span><span class="mo" id="MathJax-Span-636">,</span><span class="mi" id="MathJax-Span-637">y</span><span class="mo" id="MathJax-Span-638">)</span></span></span><span class="msubsup" id="MathJax-Span-639"><span class="mi" id="MathJax-Span-640">R</span><span class="texatom" id="MathJax-Span-641"><span class="mrow" id="MathJax-Span-642"><span class="mi" id="MathJax-Span-643">M</span><span class="mi" id="MathJax-Span-644">S</span><span class="mi" id="MathJax-Span-645">R</span><span class="mi" id="MathJax-Span-646">C</span><span class="msubsup" id="MathJax-Span-647"><span class="mi" id="MathJax-Span-648">R</span><span class="texatom" id="MathJax-Span-649"><span class="mrow" id="MathJax-Span-650"><span class="mo" id="MathJax-Span-651">(</span><span class="mi" id="MathJax-Span-652">x</span><span class="mo" id="MathJax-Span-653">,</span><span class="mi" id="MathJax-Span-654">y</span><span class="mo" id="MathJax-Span-655">)</span></span></span></span></span></span></span><span class="mo" id="MathJax-Span-656">)</span><span class="mo" id="MathJax-Span-657">)</span></span></span></span></span><span class="MJX_Assistive_MathML MJX_Assistive_MathML_Block">RMSRCRi(x,y)=255RMSRCRi(x,y)−mini(min(x,y)RMSRCRi(x,y))maxi(max(x,y)RMSRCRi(x,y)−mini(min(x,y)RMSRCR(x,y)))</span></span> 
</div> 
<br> …………(12) 
<p></p> 
<p>由于Retinex数据处理后的高动态特性，所以这种方式处理后，数据分布很广，会出现严重两极化现象，一般情况难以得到满意的结果。</p> 
<p>第二种方法：经典Canonical Gain/Offset算法： <br> 即在经典MSRCR文章《A Multiscale Retinex for Bridging the Gap Between Color Images and the Human Observation of Scenes》论文中提到的算法。公式如下： <br> <span class="MathJax_Preview"></span><span class="MathJax" id="MathJax-Element-13-Frame" tabindex="0"><span class="math" id="MathJax-Span-658"><span class="mrow" id="MathJax-Span-659"><span class="msubsup" id="MathJax-Span-660"><span class="mi" id="MathJax-Span-661">R</span><span class="texatom" id="MathJax-Span-662"><span class="mrow" id="MathJax-Span-663"><span class="mi" id="MathJax-Span-664">M</span><span class="mi" id="MathJax-Span-665">S</span><span class="mi" id="MathJax-Span-666">R</span><span class="mi" id="MathJax-Span-667">C</span><span class="msubsup" id="MathJax-Span-668"><span class="mi" id="MathJax-Span-669">R</span><span class="texatom" id="MathJax-Span-670"><span class="mrow" id="MathJax-Span-671"><span class="mi" id="MathJax-Span-672">i</span></span></span></span></span></span></span><span class="mo" id="MathJax-Span-673">(</span><span class="mi" id="MathJax-Span-674">x</span><span class="mo" id="MathJax-Span-675">,</span><span class="mi" id="MathJax-Span-676">y</span><span class="mo" id="MathJax-Span-677">)</span><span class="mo" id="MathJax-Span-678">=</span><span class="mi" id="MathJax-Span-679">G</span><span class="mo" id="MathJax-Span-680">[</span><span class="msubsup" id="MathJax-Span-681"><span class="mi" id="MathJax-Span-682">R</span><span class="texatom" id="MathJax-Span-683"><span class="mrow" id="MathJax-Span-684"><span class="mi" id="MathJax-Span-685">M</span><span class="mi" id="MathJax-Span-686">S</span><span class="mi" id="MathJax-Span-687">R</span><span class="mi" id="MathJax-Span-688">C</span><span class="msubsup" id="MathJax-Span-689"><span class="mi" id="MathJax-Span-690">R</span><span class="texatom" id="MathJax-Span-691"><span class="mrow" id="MathJax-Span-692"><span class="mi" id="MathJax-Span-693">i</span></span></span></span></span></span></span><span class="mo" id="MathJax-Span-694">(</span><span class="mi" id="MathJax-Span-695">x</span><span class="mo" id="MathJax-Span-696">,</span><span class="mi" id="MathJax-Span-697">y</span><span class="mo" id="MathJax-Span-698">)</span><span class="mo" id="MathJax-Span-699">−</span><span class="mi" id="MathJax-Span-700">b</span><span class="mo" id="MathJax-Span-701">]</span></span></span><span class="MJX_Assistive_MathML">RMSRCRi(x,y)=G[RMSRCRi(x,y)−b]</span></span> …………(13) <br> 式(12)中的G与b均为经验参数。</p> 
<p>第三种方法：自动色阶方法： <br> 该方法的处理类似于Photoshop中的自动色阶，将数据按照一定百分比去除最大最小部分，然后中间部分重新线性量化到0–255之间。</p> 
<p>第四种方法：GIMP的Retinex算法： <br> 详见前文上文：<strong>三.2.MSRCR其他实现方法</strong></p> 
<h3 id="五-opencv源码">五. OpenCV源码</h3> 
<p>笔者整理了OpenCV源码，在代码中做了中英文注释，并已经将源码上传到了我的GitHub账户上。笔者的OpenCV版本是2.4.9。 <br> 文件夹下载完毕后，终端进入其根目录执行指令即可：</p> 
<pre class="prettyprint"><code class="language-bash hljs  has-numbering">cmake ./
make</code>
 
 </pre><ul class="pre-numbering"><li>1</li><li>2</li></ul> 
<p>源码链接： <br> <a href="https://github.com/upcAutoLang/MSRCR-Restoration" rel="nofollow noopener noreferrer" target="_blank">https://github.com/upcAutoLang/MSRCR-Restoration</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e3e8469f48441cc0e9256ef0e584b1bc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">种群竞争模型</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e689de828459f272b8690295116116be/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux学习-常用文件目录操作命令（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>