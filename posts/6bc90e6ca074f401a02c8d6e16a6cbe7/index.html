<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C语言 -- 动态数组&amp;链表 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C语言 -- 动态数组&amp;链表" />
<meta property="og:description" content="目录
动态数组
动态数组的实现：
用户test
链表
目的：
链表的结构体：
链表的实现：
初始化链表
插入节点
遍历链表
删除节点
清空链表、销毁链表
用户回调函数
给用户提供接口获取链表长度
用户test
动态数组 将数组开辟到堆区，实现动态扩展。
问题：
① 用户的数据类型无法确定；
② 用户的数据无法确定创建在堆区还是栈区；
③ 不管数据在堆区还是栈上，都是在内存中，就会有地址，只需维护数据的地址就行。eg：如果数据类型是 int，则使用 int* 来指向该数据地址。
所以，这里使用万能指针 void* 来指向用户的数据地址。
第二点，我们是在堆区创建的一个数组，每一个元素都是 void* 类型的。如果要操纵这个数组，则可以使用二级指针 void** 来指向该数组的地址。
动态数组的实现： typedef struct DynamicArray { void** pAddr;	//维护真实在堆区开辟的数组的二级指针 int m_Capacity; //数组容量 int m_Size; //数组大小 }dynamicArray; //初始化数组,参数：初始数组的容量。返回值：数组指针 dynamicArray* init_dynamicArray(int capacity) { if (capacity &lt;= 0) { return NULL; } //给数组分配内存 dynamicArray* arr = malloc(sizeof(dynamicArray)); if (arr == NULL) return NULL; //数组属性初始化 arr-&gt;pAddr = malloc(sizeof(void*) * capacity); //我们维护的数据类型是void*， //这里是capacity个void*类型的数据大小，又malloc返回的是void**类型，pAddr同样是void**类型 arr-&gt;m_Capacity = capacity; arr-&gt;m_Size = 0; } //数组元素插入 void insert_dynamicArray(dynamicArray* arr, void* data, int pos) { if (arr == NULL) return; if (data == NULL) return; if (pos&lt;0 || pos&gt;arr-&gt;m_Size) pos = arr-&gt;m_Size; //判断数组是否满了 if (arr-&gt;m_Size == arr-&gt;m_Capacity) { //计算新的空间大小 int newCapacity = arr-&gt;m_Capacity * 2; //开辟新空间 void** newSpace = malloc(sizeof(void*) * newCapacity); //将原空间下数据拷贝到新空间下 memcpy(newSpace, arr-&gt;pAddr, sizeof(void*) * arr-&gt;m_Capacity); //释放原空间 free(arr-&gt;pAddr); //更改指向 arr-&gt;pAddr = newSpace; //更新容量 arr-&gt;m_Capacity = newCapacity; }	//将新元素插入到指定位置 for (int i = arr-&gt;m_Size - 1; i &gt;= pos; i--) //从最后边的数据开始移 { arr-&gt;pAddr[i &#43; 1] = arr-&gt;pAddr[i]; } arr-&gt;pAddr[pos] = data; //更新数组大小 arr-&gt;m_Size&#43;&#43;; } //遍历 void foreach_dynamicArray(dynamicArray* arr,void(*myPrint)(void*)) { if (arr == NULL) return; for (int i = 0; i &lt; arr-&gt;m_Size; i&#43;&#43;) { myPrint(arr-&gt;pAddr[i]); } } //删除数组中元素 //按照位置删除 void removeByPos_dynamicArray(dynamicArray* arr, int pos) { if (arr == NULL) return; if (pos&lt;0 || pos&gt;arr-&gt;m_Size - 1) return; for (int i = pos; i &lt; arr-&gt;m_Size; i&#43;&#43;) { arr-&gt;pAddr[i] = arr-&gt;pAddr[i &#43; 1]; } arr-&gt;m_Size--; } //按照数值删除 void removeByVal_dynamicArray(dynamicArray* arr, void* data, int(*myCompare)(void*,void*)) { if (arr == NULL) return; if (data == NULL) return; for (int i = 0; i &lt; arr-&gt;m_Size; i&#43;&#43;) { if (myCompare(arr-&gt;pAddr[i], data))//利用回调函数让用户告诉我们如何对比数据 { removeByPos_dynamicArray(arr,i); break; } } } void destory_dynamicArray(dynamicArray* arr) { if (arr == NULL) return; //内部维护在堆区数组指针先释放 if (arr-&gt;pAddr !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6bc90e6ca074f401a02c8d6e16a6cbe7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-09-04T21:03:24+08:00" />
<meta property="article:modified_time" content="2022-09-04T21:03:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C语言 -- 动态数组&amp;链表</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>目录</strong></p> 
<p id="%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84-toc" style="margin-left:0px;"><a href="#%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84" rel="nofollow">动态数组</a></p> 
<p id="%C2%A0%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow"> 动态数组的实现：</a></p> 
<p id="%E7%94%A8%E6%88%B7test-toc" style="margin-left:40px;"><a href="#%E7%94%A8%E6%88%B7test" rel="nofollow">用户test</a></p> 
<p id="%E9%93%BE%E8%A1%A8-toc" style="margin-left:0px;"><a href="#%E9%93%BE%E8%A1%A8" rel="nofollow">链表</a></p> 
<p id="%E7%9B%AE%E7%9A%84%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E7%9B%AE%E7%9A%84%EF%BC%9A" rel="nofollow">目的：</a></p> 
<p id="%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A" rel="nofollow">链表的结构体：</a></p> 
<p id="%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A-toc" style="margin-left:80px;"><a href="#%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A" rel="nofollow">链表的实现：</a></p> 
<p id="%E5%88%9D%E5%A7%8B%E5%8C%96%E9%93%BE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E9%93%BE%E8%A1%A8" rel="nofollow">初始化链表</a></p> 
<p id="%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9-toc" style="margin-left:80px;"><a href="#%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9" rel="nofollow">插入节点</a></p> 
<p id="%E9%81%8D%E5%8E%86%E9%93%BE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#%E9%81%8D%E5%8E%86%E9%93%BE%E8%A1%A8" rel="nofollow">遍历链表</a></p> 
<p id="%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9-toc" style="margin-left:80px;"><a href="#%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9" rel="nofollow">删除节点</a></p> 
<p id="%E6%B8%85%E7%A9%BA%E9%93%BE%E8%A1%A8%E3%80%81%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8-toc" style="margin-left:80px;"><a href="#%E6%B8%85%E7%A9%BA%E9%93%BE%E8%A1%A8%E3%80%81%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8" rel="nofollow">清空链表、销毁链表</a></p> 
<p id="%E7%94%A8%E6%88%B7%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-toc" style="margin-left:80px;"><a href="#%E7%94%A8%E6%88%B7%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" rel="nofollow">用户回调函数</a></p> 
<p id="%E7%BB%99%E7%94%A8%E6%88%B7%E6%8F%90%E4%BE%9B%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6-toc" style="margin-left:80px;"><a href="#%E7%BB%99%E7%94%A8%E6%88%B7%E6%8F%90%E4%BE%9B%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6" rel="nofollow">给用户提供接口获取链表长度</a></p> 
<p id="%E7%94%A8%E6%88%B7test-toc" style="margin-left:80px;"><a href="#%E7%94%A8%E6%88%B7test" rel="nofollow">用户test</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84">动态数组</h2> 
<p>将数组开辟到堆区，实现动态扩展。</p> 
<p><strong>问题：</strong></p> 
<p>① 用户的数据类型无法确定；</p> 
<p>② 用户的数据无法确定创建在堆区还是栈区；</p> 
<p>③ 不管数据在堆区还是栈上，都是在内存中，就会有地址，只需维护数据的地址就行。eg：如果数据类型是 int，则使用 int* 来指向该数据地址。</p> 
<p>所以，这里使用万能指针 void* 来指向用户的数据地址。</p> 
<p>第二点，我们是在堆区创建的一个数组，每一个元素都是 void* 类型的。如果要操纵这个数组，则可以使用二级指针 void** 来指向该数组的地址。</p> 
<p><img alt="" height="146" src="https://images2.imgbox.com/b0/e1/Ykigakcl_o.png" width="1079"></p> 
<h3 id="%C2%A0%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A"> 动态数组的实现：</h3> 
<pre><code class="language-cpp">typedef struct DynamicArray
{
	void** pAddr;	//维护真实在堆区开辟的数组的二级指针
	int m_Capacity; //数组容量
	int m_Size;     //数组大小
}dynamicArray;
//初始化数组,参数：初始数组的容量。返回值：数组指针
dynamicArray* init_dynamicArray(int capacity)
{
	if (capacity &lt;= 0)
	{
		return NULL;
	}
	//给数组分配内存
	dynamicArray* arr = malloc(sizeof(dynamicArray));
	if (arr == NULL)
		return NULL;
	//数组属性初始化
	arr-&gt;pAddr = malloc(sizeof(void*) * capacity); //我们维护的数据类型是void*，
 //这里是capacity个void*类型的数据大小，又malloc返回的是void**类型，pAddr同样是void**类型
	arr-&gt;m_Capacity = capacity;
	arr-&gt;m_Size = 0;
}
//数组元素插入
void insert_dynamicArray(dynamicArray* arr, void* data, int pos)
{
	if (arr == NULL)
		return;
	if (data == NULL)
		return;
	if (pos&lt;0 || pos&gt;arr-&gt;m_Size)
		pos = arr-&gt;m_Size;
	//判断数组是否满了
	if (arr-&gt;m_Size == arr-&gt;m_Capacity)
	{
		//计算新的空间大小
		int newCapacity = arr-&gt;m_Capacity * 2;
		//开辟新空间
		void** newSpace = malloc(sizeof(void*) * newCapacity);
		//将原空间下数据拷贝到新空间下
		memcpy(newSpace, arr-&gt;pAddr, sizeof(void*) * arr-&gt;m_Capacity);
		//释放原空间
		free(arr-&gt;pAddr);
		//更改指向
		arr-&gt;pAddr = newSpace;
		//更新容量
		arr-&gt;m_Capacity = newCapacity;
	}	
	//将新元素插入到指定位置
	for (int i = arr-&gt;m_Size - 1; i &gt;= pos; i--)  //从最后边的数据开始移
	{
		arr-&gt;pAddr[i + 1] = arr-&gt;pAddr[i];
	}
	arr-&gt;pAddr[pos] = data;
	//更新数组大小
	arr-&gt;m_Size++;
}
//遍历
void foreach_dynamicArray(dynamicArray* arr,void(*myPrint)(void*))
{
	if (arr == NULL)
		return;
	for (int i = 0; i &lt; arr-&gt;m_Size; i++)
	{
		myPrint(arr-&gt;pAddr[i]);
	}
}
//删除数组中元素
//按照位置删除
void removeByPos_dynamicArray(dynamicArray* arr, int pos)
{
	if (arr == NULL)
		return;
	if (pos&lt;0 || pos&gt;arr-&gt;m_Size - 1)
		return;
	for (int i = pos; i &lt; arr-&gt;m_Size; i++)
	{
		arr-&gt;pAddr[i] = arr-&gt;pAddr[i + 1];
	}
	arr-&gt;m_Size--;
}
//按照数值删除
void removeByVal_dynamicArray(dynamicArray* arr, void* data, int(*myCompare)(void*,void*))
{
	if (arr == NULL)
		return;
	if (data == NULL)
		return;
	for (int i = 0; i &lt; arr-&gt;m_Size; i++)
	{
		if (myCompare(arr-&gt;pAddr[i], data))//利用回调函数让用户告诉我们如何对比数据
		{
			removeByPos_dynamicArray(arr,i);
			break;
		}
	}
}

void destory_dynamicArray(dynamicArray* arr)
{
	if (arr == NULL)
		return;
	//内部维护在堆区数组指针先释放
	if (arr-&gt;pAddr != NULL)
	{
		free(arr-&gt;pAddr);
		arr-&gt;pAddr = NULL;
	}
	free(arr);
	arr = NULL;
}
</code></pre> 
<h3 id="%E7%94%A8%E6%88%B7test">用户test</h3> 
<pre><code class="language-cpp">typedef struct Person  //用户的数据类型
{
	char name[32];
	int age;
}person;
//回调函数，打印用户数据
void printPerson(void* data)
{
	person* person = data;
	printf("Name:%s Age:%d\n", person-&gt;name, person-&gt;age);
}
int comparePerson(void* data1, void* data2)
{
	person* p1 = data1;
	person* p2 = data2;
	return strcmp(p1-&gt;name, p2-&gt;name) == 0 &amp;&amp; p1-&gt;age == p2-&gt;age;
}


void test01()
{
	dynamicArray* arr = init_dynamicArray(5);
	person p1 = { "sun",18 };
	person p2 = { "yu",19 };
	person p3 = { "hang",17 };
	person p4 = { "li",20 };
	person p5 = { "hai",21 };

	printf("插入数据前：容量 = %d,大小 = %d\n", arr-&gt;m_Capacity, arr-&gt;m_Size);
	insert_dynamicArray(arr, &amp;p1, 0);
	insert_dynamicArray(arr, &amp;p2, 1);
	insert_dynamicArray(arr, &amp;p3, -1);
	insert_dynamicArray(arr, &amp;p4, 0);
	insert_dynamicArray(arr, &amp;p5, 2);

	foreach_dynamicArray(arr, printPerson);
	printf("插入数据后：容量 = %d,大小 = %d\n", arr-&gt;m_Capacity, arr-&gt;m_Size);
	printf("-------------------------------\n");
	//按位置删除
	removeByPos_dynamicArray(arr,0);
	foreach_dynamicArray(arr, printPerson);
	printf("-------------------------------\n");
	//按值删除
	removeByVal_dynamicArray(arr, &amp;p5, comparePerson);
	foreach_dynamicArray(arr, printPerson);
    printf("删除数据后：容量 = %d,大小 = %d\n", arr-&gt;m_Capacity, arr-&gt;m_Size);

	destory_dynamicArray(arr);
	arr = NULL;
}</code></pre> 
<pre><code class="language-cpp">插入数据前：容量 = 5,大小 = 0
Name:li Age:20
Name:sun Age:18
Name:hai Age:21
Name:yu Age:19
Name:hang Age:17
插入数据后：容量 = 5,大小 = 5
-------------------------------
Name:sun Age:18
Name:hai Age:21
Name:yu Age:19
Name:hang Age:17
-------------------------------
Name:sun Age:18
Name:yu Age:19
Name:hang Age:17
删除数据后：容量 = 5,大小 = 3</code></pre> 
<h2 id="%E9%93%BE%E8%A1%A8">链表</h2> 
<h4 id="%E7%9B%AE%E7%9A%84%EF%BC%9A"><strong>目的：</strong></h4> 
<p>设计一个可以存不同类型数据的链表。</p> 
<p>首先来看一个存储void*类型数据的普通链表。</p> 
<p><img alt="" height="362" src="https://images2.imgbox.com/b6/68/3plnCcnf_o.png" width="1200"></p> 
<p> 其中的一个节点只是一个独立的个体，无法代表整个链表。</p> 
<h4 id="%E9%93%BE%E8%A1%A8%E7%9A%84%E7%BB%93%E6%9E%84%E4%BD%93%EF%BC%9A">链表的结构体：</h4> 
<p>整个链表用一个新的结构体来维护，如下：</p> 
<pre><code class="language-cpp">struct LList
{
    struct LinkNode pHeader;  //链表的头结点，拿到链表的头结点即可还原整个链表
    int m_Size;               //记录链表的节点个数
}</code></pre> 
<p>在动态数组的实现中，我们可以随时访问动态数组的容量arr-&gt;m_Capacity，但由于整个数组的结构体暴露给了用户，导致用户也可以随意修改。</p> 
<p>链表的实现中，我们就不直接让用户拿到链表的结构体 LList，防止其被篡改。进行如下操作：</p> 
<pre><code class="language-cpp">typedef void* LinkList;  //给 void* 起别名</code></pre> 
<p>则用户拿到的数据永远都是 void* 类型的，我们在操作的时候，再把void*转为struct LList类型。</p> 
<h4 id="%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9A">链表的实现：</h4> 
<pre><code class="language-cpp">//链表的节点结构体
typedef struct LinkNode
{
	void* data;
	struct LinkNode* next;
}LinkNode;

//链表结构体
typedef struct LList
{
	struct LinkNode pHeader;
	int m_Size;
}Llist;

//void别名
typedef void* LinkList;</code></pre> 
<h4 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E9%93%BE%E8%A1%A8">初始化链表</h4> 
<pre><code class="language-cpp">//初始化链表
LinkList init_LinkList()
{
	//分配内存
	Llist* mylist = malloc(sizeof(Llist));
	if (mylist == NULL)
		return;
	mylist-&gt;pHeader.data = NULL;
	mylist-&gt;pHeader.next = NULL;
	mylist-&gt;m_Size = 0;

	return mylist;  //返回的是void*类型
}</code></pre> 
<h4 id="%E6%8F%92%E5%85%A5%E8%8A%82%E7%82%B9">插入节点</h4> 
<pre><code class="language-cpp">//插入节点
void insert_LinkList(LinkList list, int pos, void* data)
{
	if (list == NULL)
		return;
	if (data == NULL)
		return;
	Llist* mylist = list;
	if (pos&lt;0 || pos&gt;mylist-&gt;m_Size)
	{
		//如果传进来的位置是无效位置
		pos = mylist-&gt;m_Size;
	}
	//创建临时节点
	LinkNode* pCurrent = &amp;mylist-&gt;pHeader; //pHeader直接是一个节点，所以用&amp;取到其地址
	for (int i = 0; i &lt; pos; i++)
	{
		pCurrent = pCurrent-&gt;next;
	}
	//此时pCurrent就是插入位置的前驱节点
	//创建新节点
	LinkNode* newNode = malloc(sizeof(LinkNode));
	newNode-&gt;data = data;
	newNode-&gt;next = NULL;
	//建立节点之间的关系
	newNode-&gt;next = pCurrent-&gt;next;
	pCurrent-&gt;next = newNode;
	//更新链表长度
	mylist-&gt;m_Size++;
}</code></pre> 
<h4 id="%E9%81%8D%E5%8E%86%E9%93%BE%E8%A1%A8">遍历链表</h4> 
<pre><code class="language-cpp">//遍历链表
void foreach_LinkList(LinkList list,void(*myPrint)(void*))
{
	if (list == NULL)
		return;
	//还原链表真实结构体
	Llist* mylist = list;
	LinkNode* pCurrent = mylist-&gt;pHeader.next;
	for (int i = 0; i &lt; mylist-&gt;m_Size; i++)
	{
		myPrint(pCurrent-&gt;data); //我们不知道data的类型，所以这里使用用户自己的回调来打印
		pCurrent = pCurrent-&gt;next;
	}
}</code></pre> 
<h4 id="%E5%88%A0%E9%99%A4%E8%8A%82%E7%82%B9">删除节点</h4> 
<pre><code class="language-cpp">//删除链表节点之按位置删除
void removeByPos_LinkList(LinkList list, int pos)
{
	if (list == NULL)
		return;
	Llist* mylist = list;
	if (pos&lt;0 || pos&gt;mylist-&gt;m_Size - 1)
		return; //无效位置直接返回
	//找到待删除位置的前驱节点的位置
	LinkNode* pCurrent = &amp;mylist-&gt;pHeader;
	for (int i = 0; i &lt; pos; i++)
	{
		pCurrent = pCurrent-&gt;next;
	}
	//PCurrent就是待删除节点的前驱节点
	//利用一个指针记录待删除节点
	LinkNode* pDel = pCurrent-&gt;next;
	//更改指针的指向
	pCurrent-&gt;next = pDel-&gt;next;
	//释放待删除节点
	free(pDel);
	pDel = NULL;
	mylist-&gt;m_Size--;
}
//删除链表节点之按值删除
void removeByVal_LinkList(LinkList list, void* data, int(*myCompare)(void*))
{
	if (list == NULL)
		return;
	if (data == NULL)
		return;
	//将list还原为真实链表结构体
	Llist* mylist = list;
	//创建两个辅助指针变量
	LinkNode* pPrev = &amp;mylist-&gt;pHeader;
	LinkNode* pCurrent = mylist-&gt;pHeader.next;
	//遍历链表，找用户要删的数据
	for (int i = 0; i &lt; mylist-&gt;m_Size; i++)
	{
		if (myCompare(data, pCurrent-&gt;data))
		{
			//开始删除,更改指针指向
			pPrev-&gt;next = pCurrent-&gt;next;
			free(pCurrent);
			pCurrent = NULL;
			mylist-&gt;m_Size--;
			break;
		}
		//辅助指针向后移动
		pPrev = pCurrent;
		pCurrent = pCurrent-&gt;next;
	}
}</code></pre> 
<h4 id="%E6%B8%85%E7%A9%BA%E9%93%BE%E8%A1%A8%E3%80%81%E9%94%80%E6%AF%81%E9%93%BE%E8%A1%A8">清空链表、销毁链表</h4> 
<pre><code class="language-cpp">//请空链表
void clear_LinkList(LinkList list)
{
	if (list == NULL)
		return;
	Llist* mylist = list;
	LinkNode* pCurrent = mylist-&gt;pHeader.next;
	for (int i = 0; i &lt; mylist-&gt;m_Size; i++)
	{
		//记录下一个节点的位置
		LinkNode* pNext = pCurrent-&gt;next;

		free(pCurrent);
		pCurrent = pNext;
	}
	mylist-&gt;pHeader.next = NULL;
	mylist-&gt;m_Size = 0;
}

//销毁链表
void destory_LinkList(LinkList list)
{
	if (list == NULL)
		return;
	//先清空链表再销毁头结点
	clear_LinkList(list);

	free(list);
	list = NULL;
}</code></pre> 
<h4 id="%E7%94%A8%E6%88%B7%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0">用户回调函数</h4> 
<p>另外涉及到：打印用户数据，以及比较用户数据。由于我们不知道用户的数据类型，所以需要用户自己提供回调函数。</p> 
<pre><code class="language-cpp">//回调函数之打印
void printPerson(void* data)
{
	Person* person = data;
	printf("Name：%s，Age：%d\n", person-&gt;name, person-&gt;age);
}
//回调函数之比较
int ComparePerson(void* data1, void* data2)
{
	Person* p1 = data1;
	Person* p2 = data2;
	return strcmp(p1-&gt;name, p2-&gt;name) == 0 &amp;&amp; p1-&gt;age == p2-&gt;age;
}</code></pre> 
<h4 id="%E7%BB%99%E7%94%A8%E6%88%B7%E6%8F%90%E4%BE%9B%E6%8E%A5%E5%8F%A3%E8%8E%B7%E5%8F%96%E9%93%BE%E8%A1%A8%E9%95%BF%E5%BA%A6">给用户提供接口获取链表长度</h4> 
<pre><code class="language-cpp">//给用户提供接口获取链表长度
int size_LinkList(LinkList list)
{
	if (list == NULL)
		return -1;
	Llist* mylist = list;
	return mylist-&gt;m_Size;
}</code></pre> 
<h4>用户test</h4> 
<pre><code class="language-cpp">void test02()
{
	//初始化链表
	LinkList mylist = init_LinkList(); //mylist本质是一个void*类型的，用来隐藏结构体里的数据属性
	//mylist-&gt;m_size = -1;  //err，用户访问不到真实链表中的属性

	Person p1 = { "sun",18 };
	Person p2 = { "yu",19 };
	Person p3 = { "hang",17 };
	Person p4 = { "li",20 };
	Person p5 = { "hai",21 };

	insert_LinkList(mylist, 0, &amp;p1);
	insert_LinkList(mylist, 1, &amp;p2);
	insert_LinkList(mylist, -1, &amp;p3);
	insert_LinkList(mylist, 0, &amp;p4);
	insert_LinkList(mylist, 2, &amp;p5);
	//遍历链表
	foreach_LinkList(mylist, printPerson);
	printf("--------------------\n");
	removeByPos_LinkList(mylist,1);
	foreach_LinkList(mylist, printPerson);
	printf("--------------------\n");
	removeByVal_LinkList(mylist,&amp;p4,ComparePerson);
	foreach_LinkList(mylist, printPerson);
	printf("链表长度为：%d\n", size_LinkList(mylist));
	printf("--------------------\n");
	//清空链表
	clear_LinkList(mylist);
	printf("清空链表后链表长度为：%d\n", size_LinkList(mylist));
	//销毁链表
	destory_LinkList(mylist);
	mylist = NULL;
}</code></pre> 
<pre><code class="language-cpp">Name：li，Age：20
Name：sun，Age：18
Name：hai，Age：21
Name：yu，Age：19
Name：hang，Age：17
--------------------
Name：li，Age：20
Name：hai，Age：21
Name：yu，Age：19
Name：hang，Age：17
--------------------
Name：hai，Age：21
Name：yu，Age：19
Name：hang，Age：17
链表长度为：3
--------------------
清空链表后链表长度为：0</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e31a08e33e30ab5c8e30575db8dea3eb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Win11右键显示更多选项的关闭方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bce3450b27be048018aac91c7e7906bf/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">c&#43;&#43;/map函数</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>