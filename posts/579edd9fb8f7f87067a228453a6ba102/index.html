<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>条件熵和信息增益代码&#43;结果展示 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="条件熵和信息增益代码&#43;结果展示" />
<meta property="og:description" content="在这篇文章中我们详细的讨论了随机熵、时间无关熵和真实熵，但是他们都是针对单一变量的时间序列进行的处理，无法反映多变量时间序列之间的关系。那么要如何反映两个变量之间是否存在内在联系呢，这里就不得不提到条件熵：
信息熵反映的是随机变量的所有可能取值，即所有可能发生事件所带来的信息量的期望。那么信息熵指的是定义为X给定条件下，Y的条件概率分布的熵对X的数学期望。话不多说直接上代码：
# 计算信息熵 def calc_ent(x): &#34;&#34;&#34; calculate shanno ent of x &#34;&#34;&#34; x_value_list = set([x[i] for i in range(x.shape[0])]) ent = 0.0 for x_value in x_value_list: p = float(x[x == x_value].shape[0]) / x.shape[0] logp = np.log2(p) ent -= p * logp return ent # 计算条件熵 def calc_condition_ent(x, y): &#34;&#34;&#34; calculate ent H(y|x) &#34;&#34;&#34; # calc ent(y|x) x_value_list = set([x[i] for i in range(x.shape[0])]) ent = 0.0 for x_value in x_value_list: sub_y = y[x == x_value] temp_ent = calc_ent(sub_y) ent &#43;= (float(sub_y." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/579edd9fb8f7f87067a228453a6ba102/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-16T10:59:48+08:00" />
<meta property="article:modified_time" content="2023-08-16T10:59:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">条件熵和信息增益代码&#43;结果展示</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在<a class="link-info" href="https://blog.csdn.net/m0_53961910/article/details/128185978" title="这篇文章中">这篇文章中</a>我们详细的讨论了随机熵、时间无关熵和真实熵，但是他们都是针对单一变量的时间序列进行的处理，无法反映多变量时间序列之间的关系。那么要如何反映两个变量之间是否存在内在联系呢，这里就不得不提到条件熵：</p> 
<p style="text-align:center;"><img alt="H(Y \mid X)=\sum_{i=1}^n p_i H\left(Y \mid X=x_i\right)" class="mathcode" src="https://images2.imgbox.com/9d/ca/07M6JLwW_o.png"></p> 
<p> 信息熵反映的是随机变量的所有可能取值，即所有可能发生事件所带来的信息量的期望。那么信息熵指的是定义为X给定条件下，Y的条件概率分布的熵对X的数学期望。话不多说直接上代码：</p> 
<pre><code class="language-python"># 计算信息熵
def calc_ent(x):
    """
        calculate shanno ent of x
    """

    x_value_list = set([x[i] for i in range(x.shape[0])])
    ent = 0.0
    for x_value in x_value_list:
        p = float(x[x == x_value].shape[0]) / x.shape[0]
        logp = np.log2(p)
        ent -= p * logp

    return ent
# 计算条件熵
def calc_condition_ent(x, y):
    """
        calculate ent H(y|x)
    """

    # calc ent(y|x)
    x_value_list = set([x[i] for i in range(x.shape[0])])
    ent = 0.0
    for x_value in x_value_list:
        sub_y = y[x == x_value]
        temp_ent = calc_ent(sub_y)
        ent += (float(sub_y.shape[0]) / y.shape[0]) * temp_ent

    return ent</code></pre> 
<p>一个特征往往会使一个随机变量Y的信息量减少，减少的部分就是信息增益。如果信息增益的值越大，说明引入的特征使得随机变量Y的信息量减少的越多，随机变量Y的不确定性降低了，那么引入的这个特征就越好，它和随机变量Y的相关越高。</p> 
<p style="text-align:center;"><img alt="entroygain=H(Y)-H(Y|X)" class="mathcode" src="https://images2.imgbox.com/55/0c/DfKH3vrX_o.png"></p> 
<p>代码展示如下： </p> 
<pre><code class="language-python"># 计算信息增益
def calc_ent_grap(x,y):
    """
        calculate ent grap
    """
    base_ent = calc_ent(y)
    condition_ent = calc_condition_ent(x, y)
    ent_grap = base_ent - condition_ent

    return ent_grap</code></pre> 
<p>最终我们在我们随机生成的数据集上进行结果展示。该数据集展示了10个节点随时间的流量变化，为了便于后续时间序列的处理，我们对数据集进行了切分，（X,Y,Z）其对应的Y为节点数10，Z为所选的时间序列的长度，X为切分出来的（Y,Z）的数量。代码如下：</p> 
<pre><code class="language-python">cond_list = []
for i in range(node.shape[1]):
    cond = []
    for j in range(node.shape[1]):
        x = node[0, i, :]
        y = node[0, j, :]
        cond.append(calc_ent_grap(x, y))
    cond_list.append(cond)
print(np.array(cond_list).shape)
cond_array=np.array(cond_list)-np.diag(cond_list)*np.eye(10)
print(cond_list)</code></pre> 
<p>最终我们选择使用heatmap对结果进行展示，展示结果为一个10×10的矩阵，代表相应节点（i,j）之间的信息增益。</p> 
<pre><code class="language-python">sns.set_theme(font='Times New Roman', font_scale=1.2)
fig, ax = plt.subplots(constrained_layout=True, figsize=(6, 5))
node = sns.heatmap(cond_list, xticklabels=False, yticklabels=False, cbar=True, annot=True)
node = node.set_title('conditional entropy')
plt.show()</code></pre> 
<p>输出结果图展示如下：</p> 
<p class="img-center"><img alt="" height="285" src="https://images2.imgbox.com/64/cf/eNMjJx8U_o.png" width="342"></p> 
<p></p> 
<p class="img-center"><img alt="" height="282" src="https://images2.imgbox.com/73/cf/TcPHlrwF_o.png" width="339"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/59f67ce5705883a1b4f16116134bb031/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【附安装包】Maple 2023安装教程，数学问题迎刃而解！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fca244ed038983d97ca31c4bd5182159/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">基于PyG Temporal的DCRNN（扩散卷积递归神经网络）代码实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>