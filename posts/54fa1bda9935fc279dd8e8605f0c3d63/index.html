<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Protobuf 反射技术简介 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Protobuf 反射技术简介" />
<meta property="og:description" content="对于反射大家应该不会陌生，如果你接触过一些框架（如 ORM、IOC、OSGi 等） 的内部实现，应该更能体会反射技术的应用可谓无处不在。
反射概念最早出现于人工智能领域，20 世纪 70 年代末被引入到程序语言设计中。1982 年 MIT 的 Smith, Brian Cantwell 在他的博士论文中最早提出了程序反射的概念：
既然我们可以构造“有关某个外部世界表示”的计算过程, 并通过它来对那个外部世界进行推理; 那么我们也可以构造能够对自身表示和计算进行推理的计算过程 ,它包含负责管理有关自身的操作和结构表示的内部过程。
—— 1982年 Smith, Brian Cantwell 博士论文首次提出
从某种角度来看，所谓编程实际上就是在构造 “关于外部世界” 的计算过程。如果用 F 表示这个构造过程，用 X 表示外部世界，那么编写一个计算系统可表示为 F(X)。
那么非常有趣的点就在于：我们完全可以构造对上述过程本身进行描述和推理的计算过程。即将 F(X) 视为新的 “世界” 和 研究对象，构造 F(F(X))。
我们平时编写的计算系统是面向特定领域的（通常是面向现实建模）, 系统中包含 用来描述领域中的实体 和 实体间关系 的数据结构以及处理这些数据结构的规则。那么反射系统面向领域便是这个系统本身。
从上层概念往下走，很容易就能理解反射将为我们提供这样的能力：
计算机程序在运行时可以访问、检测和修改它本身状态或行为
—— 反射 (计算机科学) Wikipedia
很多编程语言可对程序本身进行构建（如何构建见下文），从而为程序员提供反射能力，即可在运行时访问和修改自身状态和行为：
// 运行时动态创建对象 Class&lt;?&gt; class1 = Class.forName(&#34;cn::lcy::dog&#34;); Dog dogObj = (Dog) class1.newInstance(); // 运行时动态访问状态 Field dogNameField = class1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/54fa1bda9935fc279dd8e8605f0c3d63/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-08T08:51:48+08:00" />
<meta property="article:modified_time" content="2024-01-08T08:51:48+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Protobuf 反射技术简介</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>对于反射大家应该不会陌生，如果你接触过一些框架（如 ORM、IOC、OSGi 等） 的内部实现，应该更能体会反射技术的应用可谓无处不在。</p> 
<p>反射概念最早出现于人工智能领域，20 世纪 70 年代末被引入到程序语言设计中。1982 年 MIT 的 <code>Smith, Brian Cantwell</code> 在他的博士论文中最早提出了程序反射的概念：</p> 
<blockquote> 
 <p>既然我们可以构造“有关某个外部世界表示”的计算过程, 并通过它来对那个外部世界进行推理; 那么我们也可以构造能够对自身表示和计算进行推理的计算过程 ,它包含负责管理有关自身的操作和结构表示的内部过程。</p> 
 <p>—— 1982年 Smith, Brian Cantwell 博士论文首次提出</p> 
</blockquote> 
<p>从某种角度来看，所谓编程实际上就是在构造 “关于外部世界” 的计算过程。如果用 F 表示这个构造过程，用 X 表示外部世界，那么编写一个计算系统可表示为 F(X)。</p> 
<p>那么非常有趣的点就在于：<strong>我们完全可以构造对上述过程本身进行描述和推理的计算过程。即将 F(X) 视为新的 “世界” 和 研究对象，构造 F(F(X))</strong>。</p> 
<p>我们平时编写的计算系统是面向特定领域的（通常是面向现实建模）, 系统中包含 <code>用来描述领域中的实体</code> 和 <code>实体间关系</code> 的数据结构以及处理这些数据结构的规则。那么反射系统面向领域便是这个系统本身。</p> 
<p>从上层概念往下走，很容易就能理解反射将为我们提供这样的能力：</p> 
<blockquote> 
 <p>计算机程序在运行时可以访问、检测和修改它本身状态或行为<br> —— 反射 (计算机科学) Wikipedia</p> 
</blockquote> 
<p>很多编程语言可对程序本身进行构建（如何构建见下文），从而为程序员提供反射能力，即可在运行时访问和修改自身状态和行为：</p> 
<pre><code class="prism language-java"><span class="token comment">// 运行时动态创建对象</span>
<span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> class1 <span class="token operator">=</span> <span class="token class-name">Class</span><span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"cn::lcy::dog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">Dog</span> dogObj <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Dog</span><span class="token punctuation">)</span> class1<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 运行时动态访问状态</span>
<span class="token class-name">Field</span> dogNameField <span class="token operator">=</span> class1<span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 运行时动态修改状态</span>
dogNameField<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>dogObj<span class="token punctuation">,</span> <span class="token string">"鸡你太美"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 运行时动态修改行为</span>
<span class="token class-name">Method</span> method <span class="token operator">=</span> class1<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"signJumpRapAndBall"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>dogObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>例子中写的是字符串常量形式如 <code>"cn::lcy::dog"</code> ，但实际上 <code>"cn::lcy::dog"</code> 等可以是一个动态变化的变量，它可以由程序计算生成，可以从本地文件中读取，也可以通过网络从远程获取，这便是运行时动态的含义。</p> 
<p>站在使用者的角度，通过上面例子应该可以对反射有一定的直观感受。</p> 
<p>而站在实现者的角度，编程语言是如何实现程序反射的呢？</p> 
<p>如果用一句话来总结反射实现的关键，笔者会概括为：<strong>获取系统元信息</strong></p> 
<blockquote> 
 <p>元信息：即系统自描述信息，用于描述系统本身。举例来讲，即系统有哪些类？类中有哪些字段、哪些方法？字段属于什么类型、方法又有怎样的参数和返回值？…</p> 
</blockquote> 
<p>对于上述例子的 Java 语言而言，其能够提供反射能力的关键是在编译阶段将程序的元信息编译进了 .class 文件，在程序运行时 JVM 将会把 .class 文件加载到 JVM 内存模型中的方法区。此后程序运行时将有能力获取关于自身的元信息。除了 Java 语言之外，JS、Python、GO、PHP 等各种语言也都在语言层面实现了程序反射。</p> 
<p>而由于 C++ 在编译时并不会将类的元信息写进结果中，最终编译结果中只会包含变量、函数地址偏移、函数关系等，所以 C++ 自身无法获取元信息，那么自然无法提供反射能力。但这并不意味着使用 C++ 就无法应用反射技术，程序可以自己设计与实现程序元信息以及元信息与地址之间的映射。例如本文所要介绍的 ProtoBuf 反射实现。</p> 
<h3><a id="ProtoBuf__48"></a>ProtoBuf 反射技术简介</h3> 
<p>与其它语言提供的反射类似，ProtoBuf 能够为使用者提供了如下的反射能力：</p> 
<pre><code class="prism language-c"><span class="token comment">/* 反射创建实例 */</span>
<span class="token keyword">auto</span> descriptor <span class="token operator">=</span> google<span class="token operator">::</span>protobuf<span class="token operator">::</span>DescriptorPool<span class="token operator">::</span><span class="token function">generated_pool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">FindMessageTypeByName</span><span class="token punctuation">(</span><span class="token string">"Dog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> prototype <span class="token operator">=</span> google<span class="token operator">::</span>protobuf<span class="token operator">::</span>MessageFactory<span class="token operator">::</span><span class="token function">generated_factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">GetPrototype</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> instance <span class="token operator">=</span> prototype<span class="token operator">-&gt;</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* 反射相关接口 */</span>
<span class="token keyword">auto</span> reflecter <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">GetReflection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> field <span class="token operator">=</span> descriptor<span class="token operator">-&gt;</span><span class="token function">FindFieldByName</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
reflecter<span class="token operator">-&gt;</span><span class="token function">SetString</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>instance<span class="token punctuation">,</span> field<span class="token punctuation">,</span> <span class="token string">"鸡你太美"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>

<span class="token comment">// 获取属性的值.</span>
std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>reflecter<span class="token operator">-&gt;</span><span class="token function">GetString</span><span class="token punctuation">(</span>instance <span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl <span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token number">0</span> <span class="token punctuation">;</span>
</code></pre> 
<p>利用上述 ProtoBuf 的反射能力，我们将能够实现许多强大的功能。例如各种 pb2json 库底层多是利用 ProtoBuf 的反射能力，实际上ProtoBuf 自身对编码结果反序列化并构建内存对象的过程用的也正是反射。</p> 
<p>正如上一节提到的，反射的核心要点是：<strong>获取程序元信息。</strong></p> 
<p>ProtoBuf 自然也不会例外，那么 ProtoBuf 反射所需的元信息在哪？答案便是使用 ProtoBuf 的第一步就会接触到的：<strong>.proto 文件。</strong></p> 
<h3><a id="ProtoBuf__74"></a>ProtoBuf 反射原理概述</h3> 
<p>我们在 <a href="https://www.jianshu.com/p/a24c88c0526a" rel="nofollow">深入 ProtoBuf - 简介</a> 一文中介绍过使用 ProtoBuf 的第一步便是创建 .proto 文件，定义我们所需的数据结构。但很多人没有意识到，这个过程同时也是为 ProtoBuf 提供我们数据元信息的过程，这些元信息包括数据由哪些字段构成，字段又属于什么类型以及字段之间的组合关系等。</p> 
<p>当然元信息也并非一定由 .proto 文件提供，它也可来自于网络或其它可能的输入，只要它满足 ProtoBuf Message 的定义语法即可。那么元信息的可能来源和处理就有：</p> 
<ul><li> <p>.proto 文件</p> 
  <ul><li>使用 ProtoBuf 内置的工具 protoc 编译器编译，protoc 将 .proto 文件内容编码并写入生成的代码中（.pb.cc 文件）</li><li>使用 ProtoBuf 提供的编译 API 在运行时手动（指编码）解析 .proto 文件内容。实际上 protoc 底层调用的也正是这个编译 API。</li></ul> </li><li> <p>非 .proto 文件</p> 
  <ul><li> <p>从远程读取，如将数据与数据元信息一同进行 protobuf 编码并传输：</p> <pre><code class="prism language-protobuf">message Req {
  optional string proto_file = 1;
  optional string data = 2;
}
</code></pre> </li><li> <p>从 Json 或其它格式数据中转换而来</p> </li><li> <p>…</p> </li></ul> </li></ul> 
<p>无论 .proto 文件来源于何处，我们都需要对其做进一步的处理，将其解析成内存对象，并构建其与实例的映射，同时也要计算每个字段的内存偏移。可总结出如下步骤：</p> 
<ol><li>提供 .proto （范指 ProtoBuf Message 语法描述的元信息）</li><li>解析 .proto 构建 FileDescriptor、FieldDescriptor 等，即 .proto 对应的内存模型（对象）</li><li>之后每创建一个实例，就将其存到相应的实例池中</li><li>将 Descriptor 和 instance 的映射维护到表中备查</li><li>通过 Descriptor 可查到相应的 instance，又由于了解 instance 中字段类型（FieldDescriptor），所以知道字段的内存偏移，那么就可以访问或修改字段的值</li></ol> 
<h3><a id="ProtoBuf__108"></a>ProtoBuf 反射源码解析</h3> 
<p>反射源码有许多阅读路径，在上一节中列出了元信息的不同来源，不同来源元信息就会导致处理上有所不同。我们没有必要解读源码中所有的实现路径，这里只选择最直观也是我们接触最多的一种路径。</p> 
<p>重看 <code>ProtoBuf 反射技术简介</code> 中的例子，可对这个例子一步步深入从而理解反射实现的原理（代码 4-1）：</p> 
<pre><code class="prism language-c"><span class="token comment">/* 反射创建实例 */</span>
<span class="token keyword">auto</span> descriptor <span class="token operator">=</span> google<span class="token operator">::</span>protobuf<span class="token operator">::</span>DescriptorPool<span class="token operator">::</span><span class="token function">generated_pool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">FindMessageTypeByName</span><span class="token punctuation">(</span><span class="token string">"Dog"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> prototype <span class="token operator">=</span> google<span class="token operator">::</span>protobuf<span class="token operator">::</span>MessageFactory<span class="token operator">::</span><span class="token function">generated_factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">GetPrototype</span><span class="token punctuation">(</span>descriptor<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> instance <span class="token operator">=</span> prototype<span class="token operator">-&gt;</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/* 反射相关接口 */</span>
<span class="token keyword">auto</span> reflecter <span class="token operator">=</span> instance<span class="token punctuation">.</span><span class="token function">GetReflection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> field <span class="token operator">=</span> descriptor<span class="token operator">-&gt;</span><span class="token function">FindFieldByName</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
reflecter<span class="token operator">-&gt;</span><span class="token function">SetString</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>instance<span class="token punctuation">,</span> field<span class="token punctuation">,</span> <span class="token string">"鸡你太美"</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>

<span class="token comment">// 获取属性的值.</span>
std<span class="token operator">::</span>cout<span class="token operator">&lt;&lt;</span>reflecter<span class="token operator">-&gt;</span><span class="token function">GetString</span><span class="token punctuation">(</span>instance <span class="token punctuation">,</span> field<span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl <span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token number">0</span> <span class="token punctuation">;</span>
</code></pre> 
<p><strong>一、</strong><br> 代码 4-1 第一步我们通过 DescriptorPool 的 FindMessageTypeByName 获得了元信息 Descriptor。</p> 
<p>DescriptorPool 为元信息池，对外提供了诸如 FindServiceByName、FindMessageTypeByName 等各类接口以便外部查询所需的元信息。当 DescriptorPool 不存在时需要查询的元信息时，将进一步到 DescriptorDatabase 中去查找。</p> 
<p>DescriptorDatabase 可从硬编码或磁盘中查询对应名称的 .proto 文件内容，解析后返回查询需要的元信息。</p> 
<p>DescriptorPool 相当于缓存了文件的 Descriptor（底层使用 Map），查询时将先到缓存中查询，如果未能找到再进一步到 DB 中（即 DescriptorDatabase）查询，此时可能需要从磁盘中读取文件内容，然后再解析成 Descriptor 返回，这里需要消耗一定的时间。</p> 
<p>从上面的描述不难看出，DescriptorPool 和 DescriptorDatabase 通过缓存机制提高了反射运行效率，但这只是反射工程实现上的一种优化，我们更感兴趣的应该是 Descriptor 的来源。</p> 
<p>DescriptorDatabase 从磁盘中读取 .proto 内容并解析成 Descriptor 这一来源很容易理解，但我们大多数时候并不会采用这种方式，反射时也不会去读取 .proto 文件。那么我们的 .proto 内容在哪？</p> 
<p>实际上我们在使用 protoc 生成 <code>xxx.pb.cc</code> 和 <code>xxx.pb.h</code> 文件时，其中不仅仅包含了读写数据的接口，还包含了 .proto 文件内容。阅读任意一个 <code>xxx.pb.cc</code> 的内容，你可以看到如下类似代码（代码 4-2）：</p> 
<pre><code class="prism language-c"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">AddDescriptorsImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
  <span class="token function">InitDefaults</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// .proto 内容</span>
  <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">char</span> descriptor<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE</span><span class="token punctuation">(</span>protodesc_cold<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
      <span class="token string">"\n\022single_int32.proto\"\035\n\010Example1\022\021\n\010int3"</span>
      <span class="token string">"2Val\030\232\005 \001(\005\" \n\010Example2\022\024\n\010int32Val\030\377\377\377\377"</span>
      <span class="token string">"\001 \003(\005b\006proto3"</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// 注册 descriptor</span>
  <span class="token operator">::</span>google<span class="token operator">::</span>protobuf<span class="token operator">::</span>DescriptorPool<span class="token operator">::</span><span class="token function">InternalAddGeneratedFile</span><span class="token punctuation">(</span>
      descriptor<span class="token punctuation">,</span> <span class="token number">93</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 注册 instance</span>
  <span class="token operator">::</span>google<span class="token operator">::</span>protobuf<span class="token operator">::</span>MessageFactory<span class="token operator">::</span><span class="token function">InternalRegisterGeneratedFile</span><span class="token punctuation">(</span>
    <span class="token string">"single_int32.proto"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>protobuf_RegisterTypes<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>其中 descriptor 数组存储的便是 .proto 内容。这里当然不是简单的存储原始文本字符串，而是经过了 <strong>SerializeToString</strong> 序列化处理，而后将结果以硬编码的形式保存在 xxx.pb.cc 中，真是充分利用了自己的高效编码能力。</p> 
<p>硬编码的 .proto 元信息内容将以懒加载的方式（被调用时才触发）被 DescriptorDatabase 加载、解析，并缓存到 DescriptorPool 中。</p> 
<p><strong>二、</strong><br> 代码 4-1 例子中的第二步是根据 MessageFactory 获得了一个实例。</p> 
<p>MessageFactory 是实例工厂，对外提供了根据元信息 descriptor 获取相应实例的能力。</p> 
<p>其实在代码 4-2 中已经涉及到该工厂，即：</p> 
<pre><code class="prism language-c"><span class="token comment">// 注册对应 descriptor 的 instance 到 MessageFactory</span>
<span class="token comment">// InternalRegisterGeneratedFile 函数内部，会将创建一个实例并做好 descriptor 与 instance 的映射</span>
<span class="token operator">::</span>google<span class="token operator">::</span>protobuf<span class="token operator">::</span>MessageFactory<span class="token operator">::</span><span class="token function">InternalRegisterGeneratedFile</span><span class="token punctuation">(</span>
    <span class="token string">"single_int32.proto"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>protobuf_RegisterTypes<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>每次构建实例后，都将 descriptor 和 instance 维护到一个 _table 中，即映射表以便获取。后续所谓通过反射获得某个类的某个实例子，实际就是查表的过程。</p> 
<p><strong>三、</strong><br> 代码 4-1 例子中的第三步，就是对 instance 实例对象的属性进行读写。</p> 
<p>实例对象的 reflection 里面存储了对象属性的偏移地址，而这些信息其实与 .proto 内容信息一样，在 protoc 编译时通过解析 proto 文件内容获得且记录在 <code>xxx.pb.cc</code> 中，阅读 <code>xxx.pb.cc</code> 代码，可看到如下类似代码：</p> 
<pre><code class="prism language-c"><span class="token keyword">const</span> <span class="token operator">::</span>google<span class="token operator">::</span>protobuf<span class="token operator">::</span>uint32 TableStruct<span class="token operator">::</span>offsets<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">GOOGLE_PROTOBUF_ATTRIBUTE_SECTION_VARIABLE</span><span class="token punctuation">(</span>protodesc_cold<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span>
  <span class="token operator">~</span><span class="token number">0u</span><span class="token punctuation">,</span>  <span class="token comment">// no _has_bits_</span>
  <span class="token comment">// 将会计算实例与属性的内存偏移</span>
  <span class="token function">GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET</span><span class="token punctuation">(</span><span class="token operator">::</span>Example1<span class="token punctuation">,</span> _internal_metadata_<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token operator">~</span><span class="token number">0u</span><span class="token punctuation">,</span>  <span class="token comment">// no _extensions_</span>
  <span class="token operator">~</span><span class="token number">0u</span><span class="token punctuation">,</span>  <span class="token comment">// no _oneof_case_</span>
  <span class="token operator">~</span><span class="token number">0u</span><span class="token punctuation">,</span>  <span class="token comment">// no _weak_field_map_</span>
  <span class="token function">GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET</span><span class="token punctuation">(</span><span class="token operator">::</span>Example1<span class="token punctuation">,</span> int32val_<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token operator">~</span><span class="token number">0u</span><span class="token punctuation">,</span>  <span class="token comment">// no _has_bits_</span>
  <span class="token function">GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET</span><span class="token punctuation">(</span><span class="token operator">::</span>Example2<span class="token punctuation">,</span> _internal_metadata_<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token operator">~</span><span class="token number">0u</span><span class="token punctuation">,</span>  <span class="token comment">// no _extensions_</span>
  <span class="token operator">~</span><span class="token number">0u</span><span class="token punctuation">,</span>  <span class="token comment">// no _oneof_case_</span>
  <span class="token operator">~</span><span class="token number">0u</span><span class="token punctuation">,</span>  <span class="token comment">// no _weak_field_map_</span>
  <span class="token function">GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET</span><span class="token punctuation">(</span><span class="token operator">::</span>Example2<span class="token punctuation">,</span> int32val_<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre> 
<p>有了属性的内存偏移，自然可以对属性进行读写操作，以例子中出现的 SetString 为例，其内部实现位于 <code>generated_message_reflection.cc</code> 中，核心代码如下：</p> 
<pre><code class="prism language-c"><span class="token comment">// 获取属性内存地址指针，内部根据 __</span>
<span class="token keyword">const</span> std<span class="token operator">::</span>string<span class="token operator">*</span> default_ptr <span class="token operator">=</span>
    <span class="token operator">&amp;</span>DefaultRaw<span class="token operator">&lt;</span>ArenaStringPtr<span class="token operator">&gt;</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// DefaultRaw 底层调用：</span>
<span class="token comment">// reinterpret_cast&lt;const uint8*&gt;</span>
<span class="token comment">// (default_instance_) +</span>
<span class="token comment">//     OffsetValue(offsets_[field-&gt;index()], field-&gt;type());</span>

<span class="token comment">// .......</span>

<span class="token comment">// assign 赋值</span>
MutableField<span class="token operator">&lt;</span>ArenaStringPtr<span class="token operator">&gt;</span><span class="token punctuation">(</span>message<span class="token punctuation">,</span> field<span class="token punctuation">)</span>
    <span class="token operator">-&gt;</span><span class="token function">Mutable</span><span class="token punctuation">(</span>default_ptr<span class="token punctuation">,</span> <span class="token function">GetArena</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token operator">-&gt;</span><span class="token function">assign</span><span class="token punctuation">(</span>std<span class="token operator">::</span><span class="token function">move</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>其他 SetInt32、SetInt64、SetBool 等等接口原理类似。</p> 
<p>ProtoBuf 的源码十分庞大，本节只是解析了其中一条路径，但已经足够呈现 ProtoBuf 的反射原理。如果想了解更多工程细节可进一步阅读 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fprotocolbuffers%2Fprotobuf" rel="nofollow">ProtoBuf 源码</a>。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/138912570f80a82abcb1ff31f0c546ab/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NodeJS报错Cannot access ‘xxx‘ before initialization排查解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cb36ba3e3d11210bb1370162a1ea4c02/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Protobuf 序列化源码解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>