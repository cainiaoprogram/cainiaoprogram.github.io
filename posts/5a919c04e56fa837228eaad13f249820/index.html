<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java的编码方式、单个char类型存储大部分中文字符、getBytes()、new String()的转换流程 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java的编码方式、单个char类型存储大部分中文字符、getBytes()、new String()的转换流程" />
<meta property="og:description" content="目录
一 编码种类
1.1 ASCII码
1.2 ISO8859-1编码
1.3 GBK编码
1.4 Unicode字符集
1.4.1 UTF-8编码
1.4.2 UTF-16编码
1.4.3 UTF-32编码
二 Java编码方式
2.1 内码、外码
2.2 单个char类型能存储大部分(BMP范围内)中文
2.3 String：字符个数和char数组长度的误区
2.4 getBytes()方法的转换流程
2.5 new String(字节数组，编码方式)方法的转换流程
2.6 System.out.println
一 编码种类 先了解下市面上的编码方式的相关知识点，为后面学习打好基础。
1.1 ASCII码 上个世纪60年代，美国制定了一套字符编码，对英文字符与二进制位之间的关系，做了统一规定，这被称为 ASCII码，一直沿用至今。
ASCII码 采用单字节编码，一共规定了128个字符的编码，其编码范围是 [0x00 , 0x7F]，这128个符号(包括了33个不能打印出来的控制字符或通信专用字符等)，只占用了一个字节的后面7位，最前面的1位统一规定为0。
0-31、127是控制字符或通信专用字符，如换行、回车、删除等。32-126是打印字符，可以通过键盘输入并且能够显示出来。 比如空格&#34;SPACE&#34;是32(二进制：0010 0000)，大写的字母A是65(二进制：0100 0001)。
ASCII 的编码表可以参考ASCII_百度百科
用128个符号编码便可以表示所有英文字符，但是用来表示其他语言，128个符号是不够的。比如在法语中，字母上方有注音符号，它就无法用 ASCII码 表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号，例如 ISO-8859-1编码，可以表示最多256个符号。 但是这里又出现了新的问题，不同的国家有不同的字母。因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语的编码中代表了é，在希伯来语的编码中却代表了字母Gimel (ג)，在俄语的编码中又会代表另一个符号。
但是不管怎样，所有这些编码方式中，[0 , 127]表示的符号是一样的，都是英文字符，不一样的只是[128 , 255]的这一段。
1.2 ISO8859-1编码 ISO-8859-1编码 采用单字节编码，向下兼容 ASCII 码，利用字节中闲置的最高位编入新的符号，其编码范围是 [0x00 , 0xFF]，[0x00 , 0x7F]的编码和 ASCII码 一致，[0x80 , 0x9F]是控制字符，[0xA0 , 0xFF]是文字符号，此字符集支持部分于欧洲使用的语言。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5a919c04e56fa837228eaad13f249820/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-04T14:22:01+08:00" />
<meta property="article:modified_time" content="2024-01-04T14:22:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java的编码方式、单个char类型存储大部分中文字符、getBytes()、new String()的转换流程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%20%E7%BC%96%E7%A0%81%E7%A7%8D%E7%B1%BB-toc" style="margin-left:0px;"><a href="#%E4%B8%80%20%E7%BC%96%E7%A0%81%E7%A7%8D%E7%B1%BB" rel="nofollow">一 编码种类</a></p> 
<p id="1.1%20ASCII%E7%A0%81-toc" style="margin-left:40px;"><a href="#1.1%20ASCII%E7%A0%81" rel="nofollow">1.1 ASCII码</a></p> 
<p id="1.2%20ISO8859-1-toc" style="margin-left:40px;"><a href="#1.2%20ISO8859-1" rel="nofollow">1.2 ISO8859-1编码</a></p> 
<p id="1.3%20GBK-toc" style="margin-left:40px;"><a href="#1.3%20GBK" rel="nofollow">1.3 GBK编码</a></p> 
<p id="1.4%20Unicode-toc" style="margin-left:40px;"><a href="#1.4%20Unicode" rel="nofollow">1.4 Unicode字符集</a></p> 
<p id="1.4.1%20UTF-8-toc" style="margin-left:80px;"><a href="#1.4.1%20UTF-8" rel="nofollow">1.4.1 UTF-8编码</a></p> 
<p id="1.4.2%20UTF-16-toc" style="margin-left:80px;"><a href="#1.4.2%20UTF-16" rel="nofollow">1.4.2 UTF-16编码</a></p> 
<p id="1.4.3%20UTF-32-toc" style="margin-left:80px;"><a href="#1.4.3%20UTF-32" rel="nofollow">1.4.3 UTF-32编码</a></p> 
<p id="%E4%BA%8C%20Java%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%20Java%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F" rel="nofollow">二 Java编码方式</a></p> 
<p style="margin-left:0px;">         <a href="#2.1%20%E5%86%85%E7%A0%81%E3%80%81%E5%A4%96%E7%A0%81" rel="nofollow">2.1 内码、外码</a></p> 
<p style="margin-left:40px;"><a href="#2.2%20%E5%8D%95%E4%B8%AAchar%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E5%A4%A7%E9%83%A8%E5%88%86%E4%B8%AD%E6%96%87" rel="nofollow">2.2 单个char类型能存储大部分(BMP范围内)中文</a></p> 
<p style="margin-left:40px;"><a href="#2.3%20String%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%AA%E6%95%B0%E5%92%8Cchar%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E7%9A%84%E8%AF%AF%E5%8C%BA" rel="nofollow">2.3 String：字符个数和char数组长度的误区</a></p> 
<p style="margin-left:40px;"><a href="#2.4%C2%A0getBytes%28%29%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%A8%8B" rel="nofollow">2.4 getBytes()方法的转换流程</a></p> 
<p style="margin-left:40px;"><a href="#2.4%20new%20String%28%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%EF%BC%8C%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%29%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%A8%8B" rel="nofollow">2.5 new String(字节数组，编码方式)方法的转换流程</a></p> 
<p style="margin-left:40px;"><a href="#2.5%C2%A0System.out.println" rel="nofollow">2.6 System.out.println</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%20%E7%BC%96%E7%A0%81%E7%A7%8D%E7%B1%BB">一 编码种类</h2> 
<p>先了解下市面上的编码方式的相关知识点，为后面学习打好基础。</p> 
<h3 id="1.1%20ASCII%E7%A0%81">1.1 ASCII码</h3> 
<p>上个世纪60年代，美国制定了一套字符编码，对英文字符与二进制位之间的关系，做了统一规定，这被称为 <span style="color:#fe2c24;">ASCII</span>码，一直沿用至今。</p> 
<p><span style="color:#fe2c24;">ASCII</span>码 采用<span style="color:#fe2c24;">单字节</span>编码，一共规定了<span style="color:#fe2c24;">128</span>个字符的编码，其编码范围是 <span style="color:#fe2c24;">[0x00 , 0x7F]</span><span style="color:#0d0016;">，</span>这128个符号(包括了33个不能打印出来的控制字符或通信专用字符等)，只占用了一个字节的后面<span style="color:#fe2c24;">7</span>位，<span style="color:#fe2c24;">最前面的1位统一规定为0</span>。</p> 
<ul><li>0-31、127是控制字符或通信专用字符，如换行、回车、删除等。</li><li>32-126是打印字符，可以通过键盘输入并且能够显示出来。</li></ul> 
<p>比如空格"SPACE"是32(二进制：0010 0000)，大写的字母A是65(二进制：0100 0001)。</p> 
<p>ASCII 的编码表可以参考<a href="https://baike.baidu.com/item/ASCII/309296?anchor=3#3" rel="nofollow" title="ASCII_百度百科">ASCII_百度百科</a></p> 
<p>用128个符号编码便可以表示所有英文字符，但是用来表示其他语言，128个符号是不够的。比如在法语中，字母上方有注音符号，它就无法用 ASCII码 表示。于是，一些欧洲国家就决定，利用字节中<span style="color:#fe2c24;">闲置的最高位</span>编入新的符号，例如 <span style="color:#fe2c24;">ISO-8859-1</span><span style="color:#0d0016;">编码，</span>可以表示最多256个符号<span style="color:#0d0016;">。</span> </p> 
<p>但是这里又出现了新的问题，不同的国家有不同的字母。因此，哪怕它们都使用256个符号的编码方式，代表的字母却不一样。比如，130在法语的编码中代表了é，在希伯来语的编码中却代表了字母Gimel (ג)，在俄语的编码中又会代表另一个符号。</p> 
<p>但是不管怎样，所有这些编码方式中，<span style="color:#fe2c24;">[0 , 127]表示的符号是一样的，都是英文字符，不一样的只是[128 , 255]的这一段</span>。</p> 
<h3 id="1.2%20ISO8859-1">1.2 ISO8859-1编码</h3> 
<p><span style="color:#fe2c24;">ISO-8859-1</span><span style="color:#0d0016;">编码</span><span style="color:#fe2c24;"> </span><span style="color:#0d0016;">采用</span><span style="color:#fe2c24;">单字节</span>编码，向下兼容 <span style="color:#fe2c24;">ASCII </span>码，利用字节中<span style="color:#fe2c24;">闲置的最高位</span>编入新的符号，其编码范围是 <span style="color:#fe2c24;">[0x00 , 0xFF]</span>，[0x00 , 0x7F]的编码和 ASCII码 一致，[0x80 , 0x9F]是控制字符，[0xA0 , 0xFF]是文字符号，此字符集支持部分于欧洲使用的语言。</p> 
<p>由于 <span style="color:#fe2c24;">ISO-8859-1</span> 是单字节编码，和计算机最基础的表示单位一致，所以很多时候，计算机默认使用 ISO8859-1编码 来表示，而且在很多协议上，如果不指定编码方式，默认使用该编码。</p> 
<h3 id="1.3%20GBK">1.3 GBK编码</h3> 
<p><span style="color:#fe2c24;">GBK</span>编码 采用<span style="color:#fe2c24;">双字节</span>编码，于1995年制定，兼容标准 ASCII码(低8位是 ASCII码，高8位是0)、GB2312、GB13000-1、BIG5 编码中的所有汉字，编码空间为 [0x8140 , 0xFEFE]，共有 23940 个码位，其中 GBK1 区和 GBK2 区也是 GB2312 的编码范围，收录了 21003 个汉字。</p> 
<h3 id="1.4%20Unicode">1.4 Unicode字符集</h3> 
<p>世界上存在着多种的编码方式，同一个二进制数可以被解释成不同的符号。因此，要想正确地打开一个文本文件，就必须知道它的编码方式，否则用错误的编码方式解读，就会出现乱码。为什么电子邮件常常出现乱码？就是因为发信人和收信人使用的编码方式不一样。</p> 
<p>可以想象，如果有一种编码，将世界上所有的符号都纳入其中，每一个符号都给予一个<span style="color:#fe2c24;">独一无二</span>的编码的字符集，那么乱码问题就会消失，这就是 <span style="color:#fe2c24;">Unicode</span>，也叫做万国码、统一码，从它的名字就可以看出，这是一种所有符号都有一个独一无二的编码，其编码范围是 <span style="color:#fe2c24;">[U+000000 , U+10FFFF]</span><span style="color:#0d0016;">。</span></p> 
<p><span style="color:#ff9900;">需要注意的是</span><span style="color:#0d0016;">，</span><span style="color:#fe2c24;">Unicode 只是一个字符集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储</span><span style="color:#0d0016;">。</span></p> 
<p><span style="color:#0d0016;">比如，汉字“严”的 Unicode代码点 是十六进制 0x4E25，转换成二进制数足足有15(100 1110 0010 0101)，也就是说这个符号的表示至少需要2个字节，而其他更大的符号，可能需要3个字节或4个字节，甚至更多。</span></p> 
<p><span style="color:#0d0016;">这里就有两个严重的问题：</span></p> 
<ol><li><span style="color:#0d0016;">计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号。</span></li><li><span style="color:#0d0016;">我们已经知道英文字符只用一个字节表示就够了，如果 Unicode 统一规定每个符号都用三个或四个字节表示，那么每个英文字符都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。</span></li></ol> 
<p><span style="color:#0d0016;">造成的结果是： </span></p> 
<ol><li><span style="color:#0d0016;">出现了 Unicode 的多种</span><span style="color:#fe2c24;">编码方式</span><span style="color:#0d0016;">来存储，也就是说有多种不同的二进制编码格式，可以用来表示 Unicode，例如UTF-8、UTF-16、UTF-32。</span></li><li><span style="color:#0d0016;">Unicode 在很长一段时间内无法推广，直到互联网的出现。</span></li></ol> 
<h4 id="1.4.1%20UTF-8">1.4.1 UTF-8编码</h4> 
<p><span style="color:#fe2c24;">UTF-8</span>编码方式 采用<span style="color:#fe2c24;">可变长字节</span>编码，是一个非常惊艳的编码方式，漂亮地实现了对 ASCII码 的向后兼容，以保证 Unicode 可以被大众接受。<span style="color:#fe2c24;">UTF-8</span> 是目前互联网上使用最广泛的一种 Unicode编码方式。</p> 
<p>它的最大特点就是<span style="color:#fe2c24;">可变长字节</span>，<span style="color:#fe2c24;">可使用1-4个字节表示一个字符，根据字符的不同变换字节的个数</span>。</p> 
<p>编码规则如下：</p> 
<ol><li>对于<span style="color:#fe2c24;">单个字节</span>的字符，第一位为<span style="color:#fe2c24;">0</span>，后面的 <span style="color:#fe2c24;">7</span> 位对应这个字符的 Unicode代码点，与 ASCII码 完全相同，这意味着编码方式为 ASCII码 的文档可以用 UTF-8编码 打开完全没有问题。</li><li>对于需要使用 N(<span style="color:#fe2c24;">N &gt; 1)</span>个字节来表示的字符，第一个字节的<span style="color:#fe2c24;">前 N 位都为1</span>，<span style="color:#fe2c24;">第 N + 1 位为0</span>，<span style="color:#fe2c24;">剩余的 N - 1 个字节的前两位都为10</span>，剩下的二进制位则从这个字符的 Unicode代码点 的<span style="color:#fe2c24;">最后一位开始，从后向前</span>依次填充对应格式中的x，剩下的x用0补上。</li></ol> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:center;">Unicode 十六进制码点范围 </td><td style="text-align:center;"> UTF-8 二进制</td></tr><tr><td style="text-align:center;">0000 0000 - 0000 007F</td><td style="text-align:center;"><span style="color:#fe2c24;">0</span>xxxxxxx</td></tr><tr><td style="text-align:center;">0000 0080 - 0000 07FF</td><td style="text-align:center;"><span style="color:#fe2c24;">110</span>xxxxx <span style="color:#fe2c24;">10</span>xxxxxx</td></tr><tr><td style="text-align:center;">0000 0800 - 0000 FFFF </td><td style="text-align:center;"><span style="color:#fe2c24;">1110</span>xxxx<span style="color:#fe2c24;"> 10</span>xxxxxx <span style="color:#fe2c24;">10</span>xxxxxx</td></tr><tr><td style="text-align:center;">0001 0000 - 0010 FFFF</td><td style="text-align:center;"><span style="color:#fe2c24;">11110</span>xxx <span style="color:#fe2c24;">10</span>xxxxxx <span style="color:#fe2c24;">10</span>xxxxxx <span style="color:#fe2c24;">10</span>xxxxxx</td></tr></tbody></table> 
<p>例如："汉"的 Unicode代码点 是 \u6c49(110 1100 0100 1001)，通过上面的对照表可以发现，\u6c49位于第三行的范围，那么得出其格式为 <span style="color:#fe2c24;">1110xxxx 10xxxxxx 10xxxxxx</span>。接着，从"汉"的 Unicode代码点 <span style="color:#0d0016;">的</span><span style="color:#fe2c24;">最后一位</span><span style="color:#0d0016;">开始，</span><span style="color:#fe2c24;">从后向前依次填充对应格式中的x，剩下的x用0补上</span>。这样，就得到了"汉"的 UTF-8编码 为 <span style="color:#fe2c24;">1110</span>0110 <span style="color:#fe2c24;">10</span>110001 <span style="color:#fe2c24;">10</span>001001，转换成十六进制就是 0xE6 B7 89。</p> 
<p>解码的过程：如果字节的第一位是0，则说明这个字节对应一个字符；如果一个字节的第一位是1，那么连续有多少个 1，就表示该字符占用多少个字节。</p> 
<p><span style="color:#ff9900;">注意点</span>：在解码的过程如果发现字节的格式不符合UTF-8的编码规则，则会用<span style="color:#fe2c24;">置换字符</span><span style="color:#0d0016;">(UTF-8编码 的置换字符是?)替换掉</span>不符合的字节。</p> 
<p>例如：字节的二进制数的开头为 1000 0000，对照 UTF-8 表，发现不对，UTF-8 码表规则不允许用<span style="color:#fe2c24;">10</span>开头，针对这种情况，转换规则里存在一种机制，会把不允许的字节全部自动变成一个叫"置换字符"的东西，UTF-8编码 的置换字符为?，所以通过 UTF-8 解码得到的字符为?。</p> 
<h4 id="1.4.2%20UTF-16">1.4.2 UTF-16编码</h4> 
<p>在了解<span style="color:#fe2c24;"> UTF-16</span>编码之前，先了解一下 Unicode 中的“<span style="color:#fe2c24;">平面</span>”概念。</p> 
<p>Unicode 是一本很厚的字典，它将全世界所有的字符定义在一个集合里，这么多的字符不是一次性定义的，而是分区定义，每个区可以存放 65536 个（2^16）字符，称为一个平面（plane）。目前，一共有 17 个（2^5）平面，也就是说，整个 Unicode 字符集的大小现在是 2^21。 </p> 
<p>最前面的 65536 个字符位，称为<span style="color:#fe2c24;">基本平面</span>（简称 <span style="color:#fe2c24;">BMP </span>），它的代码点范围是[0 , 2^16-1]，写成 16 进制就是<span style="color:#fe2c24;">[U+0000 , U+FFFF]</span>。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。</p> 
<p>剩下的字符都放在辅助平面或扩展平面（简称 <span style="color:#fe2c24;">SMP </span>），码点范围是<span style="color:#fe2c24;">[U+010000 , U+10FFFF]</span>。</p> 
<p>了解了平面的概念后，再说回到 UTF-16。UTF-16 编码介于 UTF-8 与 UTF-32 之间，同时结合了<span style="color:#fe2c24;">变长</span><span style="color:#0d0016;">和</span><span style="color:#fe2c24;">定长</span><span style="color:#0d0016;">字节</span>两种编码方法的特点。</p> 
<p>它的编码规则很简单：</p> 
<ol><li>基本平面(<span style="color:#fe2c24;">BMP</span>)内的字符占用2个字节，<span style="color:#fe2c24;">直接存 Unicode代码点</span>。</li><li>辅助平面(<span style="color:#fe2c24;">SMP</span>)内的字符占用4个字节，通过转换计算，被拆成两个基本平面的 Unicode代码点(范围是[0xD800 , 0xDFFF]，这个范围的 Unicode 不表示任何字符)表示。</li></ol> 
<p>也就是说，UTF-16 的编码长度要么是2个字节(<span style="color:#fe2c24;">[U+0000 , U+FFFF]</span>），要么是4个字节(<span style="color:#fe2c24;">[U+010000 , U+10FFFF]</span><span style="color:#0d0016;">)</span>。</p> 
<p>在基本平面(BMP)内，<span style="color:#fe2c24;">[U+D800 , U+DFFF] </span>是一个空段，即这些代码点不表示任何字符。因此，这个空段可以用来<span style="color:#fe2c24;">映射辅助平面的字符</span>。</p> 
<p>辅助平面的字符位共有2^20个，因此表示这些字符至少需要20个二进制位。UTF-16 将这20个二进制位分成两半，<span style="color:#fe2c24;">前10位映射在[U+D800 , U+DBFF]范围内，称为高位(H)</span>，<span style="color:#fe2c24;">后10位映射在[U+DC00 , U+DFFF]，称为低位(L)</span>。这意味着，一个辅助平面的字符，被拆成两个基本平面的 Unicode代码点表示。</p> 
<p>因此，当我们遇到两个字节，发现它的代码点在<span style="color:#fe2c24;">[U+D800 , U+DBFF]</span>之间，如果编码正确，则可以断定，紧跟在后面的两个字节的代码点在<span style="color:#fe2c24;">[U+DC00 , U+DFFF]</span>之间，这四个字节表示一个字符，必须放在一起解读。</p> 
<p>以汉字"?"为例，说明 UTF-16编码 是如何工作的。</p> 
<p>汉字"?"的 Unicode代码点 为\u20BB7，该码点超出基本平面的范围[0x0000 , 0xFFFF]，在SMP范围内，因此需要使用四个字节表示。首先用 0x20BB7 - 0x10000 计算出超出的部分，然后将其结果用20个二进制位表示(不足前面补0)，结果为 0001 0000 1011 1011 0111。接着，将前10位映射到 [U+D800 , U+DBFF]之间，后10位映射到[U+DC00 , U+DFFF]即可。U+D800 对应的二进制数为 1101 1000 0000 0000，直接填充后面的 10 个二进制位即可，得到 1101 1000 0100 0010，转成 16 进制数则为 0xD842。同理可得，低位为 0xDFB7。因此得出汉字"?"的 UTF-16编码 为 0xD8 42 DF B7，共4个字节。</p> 
<p>Unicode3.0 中给出了辅助平面字符的转换公式：</p> 
<pre><code class="language-javascript">H = Math.floor((c-0x10000) / 0x400) + 0xD800

L = (c - 0x10000) % 0x400 + 0xDC00
</code></pre> 
<p>UTF-16 用两个字节表示一个字符，那么用两个字节表示必然存在字节序BOM(Byte Order Mark)的问题，即大端小端(大端小端的详情可参考<a href="https://www.yht7.com/news/92601" rel="nofollow" title="Java中的大端和小端-云海天教程">Java中的大端和小端-云海天教程</a>)的问题。</p> 
<p>UTF-16根据BOM分为</p> 
<ul><li>UTF-16BE(内存<span style="color:#fe2c24;">低地址端存放高位字节</span>，编码前会放置FEFF)</li><li>UTF-16LE(内存<span style="color:#fe2c24;">高地址端存放高位字节</span>，编码前会放置FFFE)</li></ul> 
<p>Java采用的 UTF-16BE，也就是大端模式。</p> 
<p> (数组：0是低地址端) </p> 
<p><img alt="" height="297" src="https://images2.imgbox.com/da/58/AVK7oHyl_o.jpg" width="640"></p> 
<h4 id="1.4.3%20UTF-32">1.4.3 UTF-32编码</h4> 
<p><span style="color:#fe2c24;">UTF-32</span><span style="color:#0d0016;">编码</span> 采用<span style="color:#fe2c24;">定长</span><span style="color:#0d0016;">字节</span>编码，对每个字符统一都使用<span style="color:#fe2c24;">4</span><span style="color:#0d0016;">个</span>字节表示。就空间而言，是非常没有效率的，特别地，非基本平面(BMP)的字符在大部分文件中通常很罕见，以致于它们通常被认为不存在占用空间的大小，使得 UTF-32编码 通常会是其它编码的二到四倍。虽然每一个码位使用固定长的字节看似方便，它并不如其它 Unicode编码方式 使用得广泛。</p> 
<h2 id="%E4%BA%8C%20Java%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F">二 Java编码方式</h2> 
<h3 id="2.1%20%E5%86%85%E7%A0%81%E3%80%81%E5%A4%96%E7%A0%81">2.1 内码、外码</h3> 
<p>Java编码分为<span style="color:#fe2c24;">内码</span>，<span style="color:#fe2c24;">外码</span>2种。</p> 
<p><img alt="8b813e91cd35522097f8b2390b69bbe6.png" src="https://images2.imgbox.com/4a/b6/ubTqzaYu_o.png">​</p> 
<ul><li><span style="color:#fe2c24;">内码</span> :Java程序在JVM中运行时，字符(char、String)在内存中的编码方式，编码方式为<span style="color:#fe2c24;">UTF-16BE</span>。</li></ul> 
<p>也就是说，从外界进入Java世界的字符、字符串数据，无论原本的编码是什么，都会根据<span style="color:#fe2c24;">原本的编码和 Unicode字符集 之间的<span style="background-color:#ffd900;">映射表</span></span>，找到原本的编码对应的 Unicode代码点，然后使用 UTF-16 的编码方式存储到内存中，最后输出到外界时，根据外界指定的编码方式和 Unicode字符集 之间的映射表，找到 Unicode代码点 映射的外界的编码输出。</p> 
<ul><li><span style="color:#fe2c24;">外码 </span>:除了内码，皆是外码。<span style="color:#ff9900;">注意源代码编译产⽣的目标代码文件(可执行文件或class文件)的编码方式也属于外码</span>。</li></ul> 
<p>Javac在编译的时候，会解析Java的源文件从而形成语法树，这个解析的过程是解析Java源文件中的一个个字面的字符(import、public、private、int等)。Java的源文件可以是任意的编码方式，就像普通的文本文件一样，而在经过编译时，先根据源文件的编码方式得到编码，然后根据编码去<span style="background-color:#ff9900;">映射表</span>找到所有字符的 Unicode代码点，最后根据 Unicode代码点 生成编码格式为UTF-8 (一种modified UTF-8)的class文件。</p> 
<p>在这个过程中存在两种字符集之间的映射规则，如果搞错了编码方式，就会编译失败或者乱码。</p> 
<p>例如源文件是 UTF-8编码方式，然而Javac指定 ASCII码 编码，就有可能超过了 ASCII码 的范围(0-127)而导致编译失败，或者根据编码得到的ISO8859-1编码 和 Unicode 映射得到错误的 Unicode代码点 而乱码，本来是3个字节对应一个 Unicode代码点，使用 ISO8859-1编码 变成 一个字节对应一个 Unicode代码点。</p> 
<p><img alt="f18010616a7146c7f771058d885a673c.png" src="https://images2.imgbox.com/15/a1/9ybr2mQj_o.png">​</p> 
<p>所以在编译期要防止编译错误和乱码的情况发生，就得指定正确的编码来读取源文件，得到正确的编码结果，可使用 <span style="color:#fe2c24;">-encoding </span>参数来指定编码方式。</p> 
<h4 id="2.2%20%E5%8D%95%E4%B8%AAchar%E5%8F%98%E9%87%8F%E5%AD%98%E5%82%A8%E5%A4%A7%E9%83%A8%E5%88%86%E4%B8%AD%E6%96%87">2.2 单个char类型能存储大部分(BMP范围)中文</h4> 
<p><span style="background-color:#ffd900;">为什么中文字符的 UTF-8编码 的长度是3个字节，而char是2个字节也能存中文字符？</span></p> 
<p>之前没了解过Java的编码方式，所以对明明是2个字节的char类型也能存长度为3个字节的中文字符感到很疑惑，而通过查阅资料并总结(可通过阅读上文)后，知道了为什么char也能存中文字符。</p> 
<p>答案：<span style="color:#fe2c24;">因为Java内码的编码方式为 UTF-16，所以Java程序在运行时，并不是将中文字符的 UTF-8 编码 直接存到内存中，而是根据中文字符的 UTF-8编码 去 Unicode 映射表里找到对应的 Unicode代码点，然后根据 Unicode代码点 以 UTF-16 的编码方式存储到内存中</span>。UTF-16 的编码规则通过上文可知，如果中文字符(<span style="background-color:#ffd900;">大部分常见的中文字符都在</span><span style="color:#fe2c24;"><span style="background-color:#ffd900;">[U+4E00 , U+9FBB]</span></span><span style="background-color:#ffd900;">范围内，也就是在基本平面内</span>)是在基本平面(BMP)内，则中文字符对应的 UTF-16编码 的长度是2个字节，而<span style="color:#fe2c24;">char的长度为2个字节，可以存储基本平面(BMP)范围内的所有字符</span><span style="color:#0d0016;">，所以char能存BMP内的中文字符，</span>如果中文字符是在SMP内，则需要2个char才能存储。</p> 
<p>这也就是为什么char类型能存储长度为3个字节的 UTF-8编码 的中文字符(注意点：这里的中文字符是指在基本平面内的字符)。</p> 
<p><span style="background-color:#ffd900;">String的内部采用char数组存储字符，可以存储2或4个字节的字符，所以能存储所有的字符。</span></p> 
<h4 id="2.3%20String%EF%BC%9A%E5%AD%97%E7%AC%A6%E4%B8%AA%E6%95%B0%E5%92%8Cchar%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E7%9A%84%E8%AF%AF%E5%8C%BA">2.3 String：字符的个数不等于char数组的长度</h4> 
<p><span style="background-color:#ff9900;">误区</span>：在没了解Java的编码方式前，由于常见字符都在基本平面BMP内，而不是在SMP内，所以通常来说，String的length()方法的结果(char数组的长度)和字符的个数一样，然后就认为字符串有n个字符，char数组的长度就是n，一个char就能存所有的字符。</p> 
<p><span style="background-color:#ff9900;">正确的理解</span>：由于Java内码的编码方式是 UTF-16，所以<span style="background-color:#ffd900;">char数组的长度是由字符串的字符的 UTF-16编码 决定的</span>。</p> 
<p>例如：字符串的字符是在SMP内，就需要2个char才能存储，所以char数组的长度为2，而不是1。</p> 
<p>扩展点：1、在Idea开发环境中，如果字符是在辅助平面SMP的范围内，则在Java代码中，Idea会自动将字符根据 UTF-16编码规则 转换成2个长度为2字节的 Unicode代码点。例如：字符"𐏿"在SMP内，所以在代码里直接被转换显示为"\uD800\uDC00"。</p> 
<p>2、在Java中，在字符串中使用以"<span style="color:#fe2c24;">\u</span>"开头，后面带<span style="color:#fe2c24;">4</span>个十六进制符号，则表示一个长度为2个字节的 Unicode代码点，范围在[\u0000，\uFFFF]之间。Java运行时，不用通过转换，直接将 Unicode代码点 存到char中，而普通字符则需要通过 UTF16编码 转换成 Unicode代码点 存到char中。</p> 
<p>例如：</p> 
<p>1、String s = "\uD800\uDC00"，赋值给String，String会创建长度为<span style="color:#fe2c24;">2</span>的char数组存储它。(一个"\uXXXX"长度为2字节的 Unicode代码点 使用一个char存储)</p> 
<p><img alt="" height="493" src="https://images2.imgbox.com/2f/c0/lCdYr0lx_o.png" width="937"></p> 
<p>2、String s = "f发\uD9001\uD800\uDFFF";</p> 
<p>s的char数组长度为6，如图，注意Debug中显示是字符，实际内存中char存储的是字符的 Unicode代码点。</p> 
<p><img alt="" height="534" src="https://images2.imgbox.com/de/74/wnEWoLjd_o.png" width="938"></p> 
<h4 id="2.4%C2%A0getBytes()%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%A8%8B">2.4 getBytes()方法的转换流程</h4> 
<p>Java外码若不指定编码方式，则默认是<span style="color:#fe2c24;">file.encoding</span>的编码，即操作系统的编码，Idea如果设置开发环境的编码方式为 UTF-8，则会自动设置file.encoding的编码为UTF-8。</p> 
<p>可参考<a href="https://www.codenong.com/cs106124420/" rel="nofollow" title="深入浅出了解Java程序中的乱码 | 码农家园">深入浅出了解Java程序中的乱码 | 码农家园</a> </p> 
<p><span style="background-color:#ffd900;">转换流程：</span>String字符串在调用<span style="color:#ff9900;">getBytes</span>(若不指定编码方式，则默认是<span style="color:#fe2c24;">file.encoding</span>的编码)时，遍历字符串的char数组，根据 UTF-16编码规则 和char存储的 Unicode代码点 在 <span style="background-color:#ff9900;">Unicode 和指定编码方式的映射表</span>找映射行。若找到映射行，则映射行中对应的指定编码方式的编码就是指定编码方式对该字符的编码；若找不到映射行，说明指定的编码方式不存在对该字符的编码，则采用指定的编码方式的<span style="color:#fe2c24;">置换字符</span>的编码替换该字符。</p> 
<p>1、如果遍历到char是在基本平面<span style="color:#fe2c24;">BMP</span>，且不在<span style="color:#fe2c24;">[U+D800 , U+DFFF]</span>内，则根据char存储的 Unicode代码点 去映射表找对应映射行。若找到，则映射行中对应的指定编码方式的编码就是指定编码方式对该字符的编码；若找不到映射行，说明指定的编码方式不存在对该字符的编码，则采用指定的编码方式的<span style="color:#fe2c24;">置换字符</span>的编码替换该字符。</p> 
<p>2、如果遍历到char存储的 Unicode代码点 是在<span style="color:#fe2c24;">[U+D800 , U+DBFF]</span>内。</p> 
<p>   2.1、继续往后遍历下一个char，如果下一个char存储的 Unicode代码点 在<span style="color:#fe2c24;">[U+DC00 , U+DFFF]</span>内，则说明这2个char共同表示是一个长度为4字节的字符(在SMP内)，将这2个char通过 UTF-16编码 的转换公式得到字符的 Unicode代码点，然后根据代码点找到映射行得到编码，若没有，则采用<span style="color:#fe2c24;">置换字符</span>的编码替换，然后跳过下一个char，遍历<span style="color:#fe2c24;">下下</span>一个char。 </p> 
<p>   2.2、如果下一个char不是在<span style="color:#fe2c24;">[U+DC00 , U+DFFF]</span>内或没有下一个char，则可认为该char编码错误(缺少另一个char共同表示长度为4字节的字符)或不表示字符(因为<span style="background-color:#ff9900;">BMP里的[U+D800 , U+DFFF]是一个空段，在这个范围内的 Unicode代码点 不表示字符</span>)，使用<span style="color:#ff9900;">替换字符</span><span style="color:#0d0016;">的编码</span>替换该char，然后继续遍历下一个char。</p> 
<p>3、如果遍历到char存储的 Unicode代码点 是在<span style="color:#fe2c24;">[U+DC00 , U+DFFF]</span>内，则说明该char可能表示的字符不存在或编码错误，缺少另一个char共同表示4字节的字符，使用<span style="color:#ff9900;">替换字符</span><span style="color:#0d0016;">的编码</span>替换该char，然后继续遍历下一个char。</p> 
<p>Unicode、UTF-8、UTF-16、ISO8859-1 的映射表</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td style="text-align:center;">字符</td><td style="text-align:center;">Unicode</td><td style="text-align:center;">UTF-8</td><td style="text-align:center;">UTF-16</td><td style="text-align:center;">ISO8859-1</td></tr><tr><td style="text-align:center;">f</td><td style="text-align:center;">\u000066</td><td style="text-align:center;">0x66</td><td style="text-align:center;">0x0066</td><td style="text-align:center;">0x66</td></tr><tr><td style="text-align:center;">1</td><td style="text-align:center;">\u000031</td><td style="text-align:center;">0x31</td><td style="text-align:center;">0x0031</td><td style="text-align:center;">0x31</td></tr><tr><td style="text-align:center;">?</td><td style="text-align:center;">\u00003F</td><td style="text-align:center;">0x3F</td><td style="text-align:center;">0x003F</td><td style="text-align:center;">0x3F</td></tr><tr><td style="text-align:center;">发</td><td style="text-align:center;">\u0053D1</td><td style="text-align:center;">0xE5 8F 91</td><td style="text-align:center;">0x53D1</td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">𐏿</td><td style="text-align:center;">\u010000</td><td style="text-align:center;">0xF0 90 80 80</td><td style="text-align:center;">0xD800 DC00 </td><td style="text-align:center;"></td></tr><tr><td style="text-align:center;">�</td><td style="text-align:center;">\u00FFFD</td><td style="text-align:center;">0xEF BF BD</td><td style="text-align:center;">0xFFFD</td><td style="text-align:center;"></td></tr></tbody></table> 
<p>以字符串"<span style="color:#ff9900;">f发\uD9001𐏿</span>"为例，分别采用 <span style="color:#fe2c24;">ISO8859-1</span>、<span style="color:#fe2c24;">UTF-8</span>、<span style="color:#fe2c24;">UTF-16</span>编码方式返回对应编码的字节数组。</p> 
<p><span style="background-color:#ff9900;">a、</span>编码方式：<span style="color:#fe2c24;">ISO8859-1</span>编码，得到的字节数组流程如下：</p> 
<p>1、遍历字符串的char数组，得到第一个char存储的 Unicode代码点 \u0066("f")，代码点是在基本平面BMP(排除掉[U+D800 ,  U+DFFF])里，则根据代码点在<span style="color:#ff9900;">映射表</span>里找 <span style="color:#0d0016;">ISO8859-1</span>编码 的映射行。发现存在映射行，对应的编码是 0x66，所以字符"f"的 <span style="color:#fe2c24;">ISO8859-1</span>编码 为 <span style="color:#fe2c24;">0x66</span><span style="color:#0d0016;">。</span></p> 
<p>2、继续遍历char数组，得到第二个char存储的 Unicode代码点 \u53D1("发")，代码点是在基本平面BMP(排除掉[U+D800 ,  U+DFFF])里，则根据代码点在<span style="color:#ff9900;">映射表</span>里找 <span style="color:#0d0016;">ISO8859-1</span>编码 的映射行，发现不存在映射行，则采用 ISO8859-1编码 的置换字符"<span style="color:#fe2c24;">?</span>"的编码 0x3F 替换掉该字符，所以字符"发"的 <span style="color:#fe2c24;">ISO8859-1</span>编码 为 <span style="color:#fe2c24;">0x3F</span>。</p> 
<p>3、遍历第三个char："\uD900"，发现char存储的 Unicode代码点 是在[U+D800 ,  U+DBFF]内，则根据上文的<span style="color:#fe2c24;">转换流程2</span>，继续遍历下一个char，得到下一个char的 Unicode代码点 \u0031("1") 不在[U+DC00 ,  U+DFFF]内，所以用 ISO8859-1编码 的替换字符"<span style="color:#fe2c24;">?</span>"的编码 0x3F 替换掉该字符，所以 Unicode代码点 "\uD900" 的 <span style="color:#fe2c24;">ISO8859-1</span>编码 为 <span style="color:#fe2c24;">0x3F</span>。</p> 
<p>4、遍历第四个char存储的 Unicode代码点 \u0031("1")，它的 Unicode代码点 是在BMP(排除掉[U+D800 ,  U+DFFF])里，则根据代码点在<span style="color:#ff9900;">映射表</span>里找 <span style="color:#0d0016;">ISO8859-1</span>编码 的映射行。发现存在映射行，对应的编码是 0x31，所以字符"1"的 <span style="color:#fe2c24;">ISO8859-1</span>编码 为 <span style="color:#fe2c24;">0x31</span>。</p> 
<p>5、遍历第五个char："\uD800"，发现存储的 Unicode代码点 是在[U+D800 ,  U+DBFF]内，则根据上文的<span style="color:#fe2c24;">转换流程2</span>，继续遍历下一个char，得到下一个char的 Unicode代码点 \uDC00 在[U+DC00 ,  U+DFFF]内，则根据上文的<span style="color:#fe2c24;">转换流程2.1</span>，这2个char共同表示4字节的"𐏿"字符，将这2个char通过 UTF-16编码 的转换公式得到字符"𐏿"的 Unicode代码点 \u010000，根据代码点找到映射行得到编码，发现不存在映射行，则采用 <span style="color:#0d0016;">ISO8859-1</span>编码 的置换字符"<span style="color:#fe2c24;">?</span>"的编码 0x3F 替换掉该字符，所以字符"𐏿"的 <span style="color:#fe2c24;">ISO8859-1</span>编码 为 <span style="color:#fe2c24;">0x3F</span>；然后跳过下一个char，遍历<span style="color:#fe2c24;">下下</span>一个char。 </p> 
<p>6、发现没有下下一个char，则遍历结束，最后得到 <span style="color:#fe2c24;">ISO8859-1</span>编码 的字节数组长度是<span style="color:#fe2c24;">5</span>，内容为[0x66，0x3F，0x3F，0x31，0x3F]，换成十进制(计算机存储的是<span style="color:#fe2c24;">补码</span><span style="color:#0d0016;">，补码转换成原码，负数取反加1</span>)表示[102，63，63，49，63]，如图所示</p> 
<p><img alt="" height="476" src="https://images2.imgbox.com/d3/ce/cBdyBiPv_o.png" width="804"></p> 
<p><span style="background-color:#ffd900;">b、</span>编码方式：<span style="color:#fe2c24;">UTF-8</span>，得到的字节数组流程如下：</p> 
<p>1、遍历字符串的char数组，得到第一个char存储的 Unicode代码点 \u0066("f")，代码点是在基本平面BMP(排除掉[U+D800 ,  U+DFFF])里，则根据代码点在<span style="color:#ff9900;">映射表</span>里找 <span style="color:#0d0016;">UTF-8</span>编码 的映射行。发现存在映射行，对应的编码是 0x66，所以字符"f"的 <span style="color:#fe2c24;">UTF-8</span>编码 为 <span style="color:#fe2c24;">0x66</span><span style="color:#0d0016;">。</span></p> 
<p>2、继续遍历char数组，得到第二个char存储的 Unicode代码点 \u53D1("发")，代码点是在基本平面BMP(排除掉[U+D800 ,  U+DFFF])里，则根据代码点在<span style="color:#ff9900;">映射表</span>里找 <span style="color:#0d0016;">UTF-8</span>编码 的映射行，发现存在映射行，对应的编码是 0xE5 8F 91，所以字符"发"的 <span style="color:#fe2c24;">UTF-8</span>编码 为 <span style="color:#fe2c24;">0xE5 8F 91</span>。</p> 
<p>3、遍历第三个char："\uD900"，发现存储的 Unicode代码点 是在[U+D800 ,  U+DBFF]内，则根据上文的<span style="color:#fe2c24;">转换流程2</span>，继续遍历下一个char，得到下一个char的 Unicode代码点 \u0031("1") 不在[U+DC00 ,  U+DFFF]内，所以用 UTF-8编码 的替换字符"<span style="color:#fe2c24;">?</span>"的编码 0x3F 替换掉该字符，所以 Unicode代码点 "\uD900" 的 <span style="color:#fe2c24;">UTF-8</span>编码 为 <span style="color:#fe2c24;">0x3F</span>。</p> 
<p>4、遍历第四个char存储的 Unicode代码点 \u0031("1")，它的 Unicode代码点 是在BMP(排除掉[U+D800 ,  U+DFFF])里，则根据代码点在<span style="color:#ff9900;">映射表</span>里找 <span style="color:#0d0016;">UTF-8</span>编码 的映射行。发现存在映射行，对应的编码是 0x31，所以字符"1"的 <span style="color:#fe2c24;">UTF-8</span>编码 为 <span style="color:#fe2c24;">0x31</span>。</p> 
<p>5、遍历第五个char："\uD800"，发现存储的 Unicode代码点 是在[U+D800 ,  U+DBFF]内，则根据上文的<span style="color:#fe2c24;">转换流程2</span>，继续遍历下一个char，得到下一个char的 Unicode代码点 \uDC00 在[U+DC00 ,  U+DFFF]内，则根据上文的<span style="color:#fe2c24;">转换流程2.1</span>，这2个char共同表示4字节的"𐏿"字符，将这2个char通过 UTF-16编码 的转换公式得到字符"𐏿"的 Unicode代码点 \u010000，根据代码点找到映射行得到编码，发现存在映射行，对应的编码是 0xF0 90 80 80，所以字符"𐏿"的 <span style="color:#fe2c24;">UTF-8</span>编码 为 <span style="color:#fe2c24;">0xF0 90 80 80</span>；然后跳过下一个char，遍历<span style="color:#fe2c24;">下下</span>一个char。 </p> 
<p>6、发现没有下下一个char，则遍历结束，最后得到 <span style="color:#fe2c24;">UTF-8</span> 的字节数组长度是<span style="color:#fe2c24;">10</span>，内容为[0x66，0xE5，0x8F，0x91，0x3F，0x31，0xF0，0x90，0x80，0x80]，换成十进制(计算机存储的是<span style="color:#fe2c24;">补码</span><span style="color:#0d0016;">，补码转换成原码，负数取反加1</span>)表示[102，-27，-113，-111，63，49，-16，-112，-128，-128]，如图所示</p> 
<p><img alt="" height="569" src="https://images2.imgbox.com/6c/ce/aT06ygs4_o.png" width="760"></p> 
<p><span style="background-color:#ffd900;">c、</span>编码方式：<span style="color:#fe2c24;">UTF-16</span>，得到的字节数组流程如下：</p> 
<p><span style="color:#ff9900;">注意点</span>：UTF16编码 需要指定字节序BOM，Java采用的是大端模式，所以 UTF-16编码 的字节数组会<span style="color:#ff9900;">多出2个字节用来表示 UTF-16编码 采用大端模式</span>，十六进制表示是 FEFF(十进制：-2，-1)，放在字节数组的前2位。 </p> 
<p>1、遍历字符串的char数组，得到第一个char存储的 Unicode代码点 \u0066("f")，代码点是在基本平面BMP(排除掉[U+D800 ,  U+DFFF])里，则根据代码点在<span style="color:#ff9900;">映射表</span>里找 <span style="color:#0d0016;">UTF-16</span>编码 的映射行。发现存在映射行，对应的编码是 0x0066，所以字符"f"的 <span style="color:#fe2c24;">UTF-16</span>编码 为 <span style="color:#fe2c24;">0x0066</span>。</p> 
<p>2、继续遍历char数组，得到第二个char存储的 Unicode代码点 \u53D1("发")，代码点是在基本平面BMP(排除掉[U+D800 ,  U+DFFF])里，则根据代码点在<span style="color:#ff9900;">映射表</span>里找 <span style="color:#0d0016;">UTF-16</span>编码 的映射行，发现存在映射行，对应的编码是 0x53D1，所以字符"发"的 <span style="color:#fe2c24;">UTF-16</span>编码 为 <span style="color:#fe2c24;">0x53D1</span>。</p> 
<p>3、遍历第三个char："\uD900"，发现存储的 Unicode代码点 是在[U+D800 ,  U+DBFF]内，则根据上文的<span style="color:#fe2c24;">转换流程2</span>，继续遍历下一个char，得到下一个char的 Unicode代码点 \u0031("1") 不在[U+DC00 ,  U+DFFF]内，所以用 UTF-16编码 的替换字符"�"的编码 0xFFFD 替换掉该字符，所以 Unicode代码点 "\uD900" 的 <span style="color:#fe2c24;">UTF-16</span>编码 为 <span style="color:#fe2c24;">0xFFFD</span>。</p> 
<p>4、遍历第四个char存储的 Unicode代码点 \u0031("1")，它的 Unicode代码点 是在BMP(排除掉[U+D800 ,  U+DFFF])里，则根据代码点在<span style="color:#ff9900;">映射表</span>里找 <span style="color:#0d0016;">UTF-16</span>编码 的映射行。发现存在映射行，对应的编码是 0x0031，所以字符"1"的 <span style="color:#fe2c24;">UTF-16</span>编码 为 <span style="color:#fe2c24;">0x0031</span>。</p> 
<p>5、遍历第五个char："\uD800"，发现存储的 Unicode代码点 是在[U+D800 ,  U+DBFF]内，则根据上文的<span style="color:#fe2c24;">转换流程2</span>，继续遍历下一个char，下一个char的 Unicode代码点 \uDC00 在[U+DC00 ,  U+DFFF]内，则根据上文的<span style="color:#fe2c24;">转换流程2.1</span>，这2个char共同表示4字节的"𐏿"字符，将这2个char通过 UTF-16编码 的转换公式得到字符"𐏿"的 Unicode代码点 \u010000，根据代码点找到映射行得到编码，发现存在映射行，对应的编码是 0xD800 DC00，所以字符"𐏿"的 <span style="color:#fe2c24;">UTF-16</span>编码 为 <span style="color:#fe2c24;">0xD800 DC00</span>；然后跳过下一个char，遍历<span style="color:#fe2c24;">下下</span>一个char。 </p> 
<p>6、发现没有下下一个char，则遍历结束，最后得到 <span style="color:#fe2c24;">UTF-16</span> 的字节数组长度是<span style="color:#fe2c24;">14</span>，内容为[<span style="color:#fe2c24;">0xFE</span><span style="color:#0d0016;">，</span><span style="color:#fe2c24;">0xFF</span>，0x00，0x66，0x53，0xD1，0xFF，0xFD，0x00，0x31，0xD8，0x00，0xDC，0x00]，换成十进制(计算机存储的是<span style="color:#fe2c24;">补码</span><span style="color:#0d0016;">，补码转换成原码，负数取反加1</span>)表示[-2，-1，0，102，83，-47，-1，-3，0，49，-40，0，-36，0]，如图所示</p> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="570" src="https://images2.imgbox.com/9b/52/Xie0sLEx_o.png" width="784"></h4> 
<p>代码为</p> 
<pre><code class="language-java">@Test
    public void test20() throws UnsupportedEncodingException {
        String s = "f发\uD9001\uD800\uDC00";
        byte[] isoBytes = s.getBytes("ISO8859-1");
        byte[] utf8Bytes = s.getBytes("UTF-8");
        byte[] utf16Bytes = s.getBytes("UTF-16");
    }</code></pre> 
<h4 id="2.4%20new%20String(%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84%EF%BC%8C%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F)%E6%96%B9%E6%B3%95%E7%9A%84%E8%BD%AC%E6%8D%A2%E6%B5%81%E7%A8%8B">2.5 new String(字节数组，编码方式)方法的转换流程</h4> 
<p>new String(bytes, 编码方式)就是将bytes字节数组按照指定的编码方式规则(若是不符合指定编码方式的规则，则采用UTF-16(Java内码)<span style="color:#fe2c24;">置换字符</span>的编码替换)得到指定编码方式的编码，然后根据编码去映射表里找到编码的 Unicode代码点，然后按照 UTF-16 的编码规则存储到String的char数组里。</p> 
<p><span style="background-color:#ff9900;">转换流程</span>：以字节数组：[0xDF，0xE5，0x8F，0x91]为例，指定编码方式：<span style="color:#fe2c24;">UTF-8</span></p> 
<p>String utf8Decode = new String(utf8Bytes, "UTF-8");</p> 
<p>1、遍历第一个字节 0xDF(-33的补码：1101 1111)，发现是 110 开头，根据 UTF-8的编码规则，则继续往后遍历第二个字节 0xE5(1110 0101)，发现第二个字节不是以 10 开头的，则说明第一个字节 0xDF 不符合 UTF-8 的编码规则，则采用 UTF-16  的<span style="color:#fe2c24;">置换字符</span>"�"的编码替换，"�"的 Unicode代码点 是 \u00FFFD，在BMP里，直接存到char中，值为 0xFFFD。</p> 
<p>2、继续遍历第二个字节 0xE5(-27的补码：1110 0101)，发现是 1110 开头，根据 UTF-8的编码规则，则继续往后遍历2个字节，第三个字节是 0x8F(-113的补码：1000 1111)，第四个字节是 0x91(-111的补码：1001 0001)，都是 10 开头，符合规则，说明这3个字节共同表示一个编码方式 为 UTF-8，长度为3字节的字符("发")，将这3个字节组合得到 字符"发"的 UTF-8 的编码，根据映射表，得到字符"发"的 Unicode代码点 为\u0053D1，在BMP里，直接存到char中，值为 0x53D1。跳过第三、四个字节，往后遍历。</p> 
<p>3、遍历结束，最后得到的s字符串的char数组的长度为<span style="color:#fe2c24;">2</span>，分别是[0xFFFD，0x53D1]，十进制(char类型显示十进制表示不考虑符号位，符号位参与换算)表示[65533，‭21457‬]，也就是"�发"，如图所示</p> 
<p><img alt="" height="502" src="https://images2.imgbox.com/15/3a/zTidDs4p_o.png" width="793"></p> 
<h4 id="2.5%C2%A0System.out.println">2.6 System.out.println</h4> 
<p>System.out.println()方法的编码是<span style="color:#fe2c24;">file.encoding</span>的编码。</p> 
<p>如图，在灰色显示为"f发�1𐏿"，我认为是因为Idea界面显示直接使用UTF-16，"\uD900"代码点在 Unicode 里不表示字符，所以 UTF-16编码 采用置换字符"�" 替换显示。</p> 
<p>而使用System.out.println()输出是"f发?1𐀀"，显示"?"，而不是显示"�"，idea工作环境编码设置为UTF-8，所以file.encoding为UTF-8，System.out.println()内部将字符串s转换为 UTF-8编码 的字节数组，然后将字节数组交由控制台解码输出，而在上文提到，转换为 UTF-8编码的 字节数组，如果是不表示字符，则采用UTF-8编码置换字符"?"的编码替换，所以控制台才输出"?"。</p> 
<p>若是不对，请指教。</p> 
<p><img alt="" height="407" src="https://images2.imgbox.com/90/bb/qUTXbBHF_o.png" width="889"></p> 
<p>参考地址：</p> 
<p><a href="https://blog.csdn.net/weixin_33513218/article/details/114415834?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-114415834-blog-114411817.relrec_prioritylanding&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3" title="java中的编码_Java中的编码_luminousLCH的博客-CSDN博客">java中的编码_Java中的编码_luminousLCH的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/caoruntao_/article/details/108668319?spm=1001.2101.3001.6650.8&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-8-108668319-blog-125503899.pc_relevant_multi_platform_featuressortv2dupreplace&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-8-108668319-blog-125503899.pc_relevant_multi_platform_featuressortv2dupreplace&amp;utm_relevant_index=9" title="Java中如何存储汉字_caoruntao_的博客-CSDN博客_java中汉字用什么类型">Java中如何存储汉字_caoruntao_的博客-CSDN博客_java中汉字用什么类型</a></p> 
<p><a href="https://zazalu.space/2019/06/15/Java%E7%9A%84%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98%E4%B8%80%E8%AF%AD%E9%81%93%E7%A0%B4-GBK-UTF%E7%AD%89%E5%B8%B8%E7%94%A8%E7%BC%96%E7%A0%81/" rel="nofollow" title="Java的字符编码问题一语道破(GBK,UTF-8,ISO-8859-1)">Java的字符编码问题一语道破(GBK,UTF-8,ISO-8859-1)</a></p> 
<p><a href="https://maimai.cn/article/detail?fid=1740922373&amp;efid=oRW8aq_ir5d8XL5mJc45fQ" rel="nofollow" title="我赌你不懂系列：char占几个字节 - 脉脉">我赌你不懂系列：char占几个字节 - 脉脉</a></p> 
<p><a href="https://blog.csdn.net/buqutianya/article/details/80685437" title="细说Java中的字符和字符串（一）_不去天涯的博客-CSDN博客">细说Java中的字符和字符串（一）_不去天涯的博客-CSDN博客</a></p> 
<p><a href="https://blog.csdn.net/hezh1994/article/details/78899683" title="彻底弄懂 Unicode 编码_hezh1994的博客-CSDN博客_unicode">彻底弄懂 Unicode 编码_hezh1994的博客-CSDN博客_unicode</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/51475c794f1df4b62c801ea7f4a791c2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">苹果电脑菜单栏应用管理软件Bartender 4 mac软件特点</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/702930f21c39ebadff2b6366a4c7126e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">简述C语言中为什么要用指针</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>