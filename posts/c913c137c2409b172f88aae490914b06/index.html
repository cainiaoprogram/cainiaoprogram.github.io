<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux中对EINTR错误的处理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux中对EINTR错误的处理" />
<meta property="og:description" content="慢系统调用(slow system call)：此术语适用于那些可能永远阻塞的系统调用。永远阻塞的系统调用是指调用有可能永远无法返回，多数网络支持函数都属于这一类。如：若没有客户连接到服务器上，那么服务器的accept调用就没有返回的保证。 EINTR错误的产生：当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误。例如：在socket服务器端，设置了信号捕获机制，有子进程，当在父进程阻塞于慢系统调用时由父进程捕获到了一个有效信号时，内核会致使accept返回一个EINTR错误(被中断的系统调用)。 当碰到EINTR错误的时候，可以采取有一些可以重启的系统调用要进行重启，而对于有一些系统调用是不能够重启的。例如：accept、read、write、select、和open之类的函数来说，是可以进行重启的。不过对于套接字编程中的connect函数我们是不能重启的，若connect函数返回一个EINTR错误的时候，我们不能再次调用它，否则将立即返回一个错误。针对connect不能重启的处理方法是，必须调用select来等待连接完成。
在 linux 或者 unix 环境中， errno 是一个十分重要的部分。在调用的函 数出现问题的时候，我们可以通过 errno 的值来确定出错的原因，这就会 涉及到一个问题，那就是如何保证 errno 在多线程或者进程中安全？我们希望在多线程或者进程中，每个线程或者进程都拥有自己独立和唯一的一个 errno ，这样就能够保证不会有竞争条 件的出现。一般而言，编译器会自动保证 errno 的安全性，但是为了妥善期间，我们希望在写 makefile 的时 候把 _LIBC_REENTRANT 宏定义，比 如我们在检查 &lt;bits/errno.h&gt; 文件中发现如下的定义： C代码 # ifndef __ASSEMBLER__ /* Function to get address of global `errno&#39; variable. */ extern int *__errno_location (void) __THROW __attribute__ ((__const__)); # if !defined _LIBC || defined _LIBC_REENTRANT /* When using threads, errno is a per-thread value. */ # define errno (*__errno_location ()) # endif # endif /* !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c913c137c2409b172f88aae490914b06/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-08-24T15:59:49+08:00" />
<meta property="article:modified_time" content="2012-08-24T15:59:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux中对EINTR错误的处理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="margin:5px auto; padding-top:0px; padding-bottom:0px; color:rgb(73,73,73); font-size:14px; line-height:22px"> 慢系统调用(slow system call)：此术语适用于那些可能永远阻塞的系统调用。永远阻塞的系统调用是指调用有可能永远无法返回，多数网络支持函数都属于这一类。如：若没有客户连接到服务器上，那么服务器的accept调用就没有返回的保证。<br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> EINTR错误的产生：当阻塞于某个慢系统调用的一个进程捕获某个信号且相应信号处理函数返回时，该系统调用可能返回一个EINTR错误。例如：在socket服务器端，设置了信号捕获机制，有子进程，当在父进程阻塞于慢系统调用时由父进程捕获到了一个有效信号时，内核会致使accept返回一个EINTR错误(被中断的系统调用)。<br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> 当碰到EINTR错误的时候，可以采取有一些可以重启的系统调用要进行重启，而对于有一些系统调用是不能够重启的。例如：accept、read、write、select、和open之类的函数来说，是可以进行重启的。不过对于套接字编程中的connect函数我们是不能重启的，若connect函数返回一个EINTR错误的时候，我们不能再次调用它，否则将立即返回一个错误。针对connect不能重启的处理方法是，必须调用select来等待连接完成。</p> 
<p style="margin:5px auto; padding-top:0px; padding-bottom:0px; color:rgb(73,73,73); font-size:14px; line-height:22px">  </p> 
<p style="margin:5px auto; padding-top:0px; padding-bottom:0px; color:rgb(73,73,73); font-size:14px; line-height:22px"> 在 linux 或者 unix 环境中， errno 是一个十分重要的部分。在调用的函 数出现问题的时候，我们可以通过 errno 的值来确定出错的原因，这就会 涉及到一个问题，那就是如何保证 errno 在多线程或者进程中安全？我们希望在多线程或者进程中，每个线程或者进程都拥有自己独立和唯一的一个 errno ，这样就能够保证不会有竞争条 件的出现。一般而言，编译器会自动保证 errno 的安全性，但是为了妥善期间，我们希望在写 makefile 的时 候把 _LIBC_REENTRANT 宏定义，比 如我们在检查 &lt;bits/errno.h&gt; 文件中发现如下的定义： <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> C代码 <br style="margin:0px; padding:0px"> # ifndef __ASSEMBLER__ <br style="margin:0px; padding:0px"> /* Function to get address of global `errno' variable. */ <br style="margin:0px; padding:0px"> extern int *__errno_location (void) __THROW __attribute__ ((__const__)); <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> # if !defined _LIBC || defined _LIBC_REENTRANT <br style="margin:0px; padding:0px"> /* When using threads, errno is a per-thread value. */ <br style="margin:0px; padding:0px"> # define errno (*__errno_location ()) <br style="margin:0px; padding:0px"> # endif <br style="margin:0px; padding:0px"> # endif /* !__ASSEMBLER__ */ <br style="margin:0px; padding:0px"> #endif /* _ERRNO_H */ <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> 也就是说，在没有定义 __LIBC 或者定义 _LIBC_REENTRANT 的时候， errno 是多线程 / 进程安全的。 <br style="margin:0px; padding:0px"> 一般而言， __ASSEMBLER__, _LIBC 和 _LIBC_REENTRANT 都不会被编译器定义，但是如果我们定义 _LIBC_REENTRANT 一次又何妨那？ <br style="margin:0px; padding:0px"> 为了检测一下你编译器是否定义上述变量，不妨使用下面一个简单程序。 <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> C代码 <br style="margin:0px; padding:0px"> #include &lt;stdio.h&gt; <br style="margin:0px; padding:0px"> #include &lt;errno.h&gt; <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> int main( void ) <br style="margin:0px; padding:0px"> { <br style="margin:0px; padding:0px"> #ifndef __ASSEMBLER__ <br style="margin:0px; padding:0px"> printf( "Undefine __ASSEMBLER__\n" ); <br style="margin:0px; padding:0px"> #else <br style="margin:0px; padding:0px"> printf( "define __ASSEMBLER__\n" ); <br style="margin:0px; padding:0px"> #endif <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> #ifndef __LIBC <br style="margin:0px; padding:0px"> printf( "Undefine __LIBC\n" ); <br style="margin:0px; padding:0px"> #else <br style="margin:0px; padding:0px"> printf( "define __LIBC\n" ); <br style="margin:0px; padding:0px"> #endif <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> #ifndef _LIBC_REENTRANT <br style="margin:0px; padding:0px"> printf( "Undefine _LIBC_REENTRANT\n" ); <br style="margin:0px; padding:0px"> #else <br style="margin:0px; padding:0px"> printf( "define _LIBC_REENTRANT\n" ); <br style="margin:0px; padding:0px"> #endif <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> return 0; <br style="margin:0px; padding:0px"> } <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> 希望读者在进行移植的时候，读一下相关的 unix 版本的 &lt;bits/errno.h&gt; 文 件，来确定应该定义什么宏。不同的 unix 版本可能存在着一些小的差别！</p> 
<p style="margin:5px auto; padding-top:0px; padding-bottom:0px; color:rgb(73,73,73); font-size:14px; line-height:22px">  </p> 
<p style="margin:5px auto; padding-top:0px; padding-bottom:0px; color:rgb(73,73,73); font-size:14px; line-height:22px"> 有时候，在调用系统调用时，可能会接收到某个信号而导致调用退出。譬如使用system调用某个命令之后该进程会接收到SIGCHILD信号，然后如果这个进程的线程中有慢系统调用，那么接收到该信号的时候可能就会退出，返回EINTR错误码。</p> 
<p style="margin:5px auto; padding-top:0px; padding-bottom:0px; color:rgb(73,73,73); font-size:14px; line-height:22px"> EINTR<br style="margin:0px; padding:0px"> 　　linux中函数的返回状态，在不同的函数中意义不同：</p> 
<p style="margin:5px auto; padding-top:0px; padding-bottom:0px; color:rgb(73,73,73); font-size:14px; line-height:22px"> 1）write<br style="margin:0px; padding:0px"> 　　表示：由于信号中断，没写成功任何数据。<br style="margin:0px; padding:0px"> 　　The call was interrupted by a signal before any data was written.</p> 
<p style="margin:5px auto; padding-top:0px; padding-bottom:0px; color:rgb(73,73,73); font-size:14px; line-height:22px"> 2）read<br style="margin:0px; padding:0px"> 　　表示：由于信号中断，没读到任何数据。<br style="margin:0px; padding:0px"> 　　The call was interrupted by a signal before any data was read.</p> 
<p style="margin:5px auto; padding-top:0px; padding-bottom:0px; color:rgb(73,73,73); font-size:14px; line-height:22px"> 3）sem_wait<br style="margin:0px; padding:0px"> 　　函数调用被信号处理函数中断<br style="margin:0px; padding:0px"> 　　The call was interrupted by a signal handler.</p> 
<p style="margin:5px auto; padding-top:0px; padding-bottom:0px; color:rgb(73,73,73); font-size:14px; line-height:22px"> 4）recv<br style="margin:0px; padding:0px"> 　　由于信号中断返回，没有任何数据可用。<br style="margin:0px; padding:0px"> 　　function was interrupted by a signal that was caught, before any data was available.</p> 
<p style="margin:5px auto; padding-top:0px; padding-bottom:0px; color:rgb(73,73,73); font-size:14px; line-height:22px">  </p> 
<p style="margin:5px auto; padding-top:0px; padding-bottom:0px; color:rgb(73,73,73); font-size:14px; line-height:22px"> 调用系统调用的时候,有时系统调用会被中断.此时,系统调用会返回-1,并且错误码被置为EINTR.但是,有时并不将这样的情况作为错误.有两种处理方法:<br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> 1.如果错误码为EINTR则重新调用系统调用,例如Postgresql中有一段代码:<br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> view plain<br style="margin:0px; padding:0px"> copy to clipboard<br style="margin:0px; padding:0px"> print<br style="margin:0px; padding:0px"> ?<br style="margin:0px; padding:0px"> retry1: <br style="margin:0px; padding:0px"> if (send(port-&gt;sock, &amp;SSLok, 1, 0) != 1) <br style="margin:0px; padding:0px"> { <br style="margin:0px; padding:0px"> if (errno == EINTR) <br style="margin:0px; padding:0px"> goto retry1; /* if interrupted, just retry */ <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> [cpp] view plain<br style="margin:0px; padding:0px"> copy<br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> retry1: <br style="margin:0px; padding:0px"> if (send(port-&gt;sock, &amp;SSLok, 1, 0) != 1) <br style="margin:0px; padding:0px"> { <br style="margin:0px; padding:0px"> if (errno == EINTR) <br style="margin:0px; padding:0px"> goto retry1; /* if interrupted, just retry */ <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> 2.重新定义系统调用,忽略错误码为EINTR的情况.例如,Cherokee中的一段代码:<br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> view plain<br style="margin:0px; padding:0px"> copy to clipboard<br style="margin:0px; padding:0px"> print<br style="margin:0px; padding:0px"> ?<br style="margin:0px; padding:0px"> int <br style="margin:0px; padding:0px"> cherokee_stat (const char *restrict path, struct stat *buf) <br style="margin:0px; padding:0px"> { <br style="margin:0px; padding:0px"> int re; <br style="margin:0px; padding:0px"> do { <br style="margin:0px; padding:0px"> re = stat (path, buf); <br style="margin:0px; padding:0px"> } while ((re == -1) &amp;&amp; (errno == EINTR)); <br style="margin:0px; padding:0px"> return re; <br style="margin:0px; padding:0px"> } <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> 最近 socket 读数据老是遇到 Interrupted system call （EINTR），代码改为如下解决<br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> while (1)<br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> {<!-- --><br style="margin:0px; padding:0px"> select(socket+1, &amp;readfds, NULL, NULL, &amp;tv);<br style="margin:0px; padding:0px"> if (FD_ISSET(socket, &amp;readfds))<br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> {<!-- --><br style="margin:0px; padding:0px"> printf("connection got!\n");<br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> break;<br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> }<br style="margin:0px; padding:0px"> else{<!-- --><br style="margin:0px; padding:0px"> if (errno == EINTR)<br style="margin:0px; padding:0px"> continue;<br style="margin:0px; padding:0px"> else<br style="margin:0px; padding:0px"> printf("Timed out.\n");<br style="margin:0px; padding:0px"> }<br style="margin:0px; padding:0px"> }<br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> 下面的列表显示常见的 Linux 系统错误代码。 <br style="margin:0px; padding:0px"> 1 EPERM<br style="margin:0px; padding:0px"> Operation not permitted<br style="margin:0px; padding:0px"> 操作不许可 <br style="margin:0px; padding:0px"> 2 ENOENT<br style="margin:0px; padding:0px"> No such file or directory<br style="margin:0px; padding:0px"> 无此文件或目录 <br style="margin:0px; padding:0px"> 3 ESRCH<br style="margin:0px; padding:0px"> No such process<br style="margin:0px; padding:0px"> 无此过程 <br style="margin:0px; padding:0px"> 4 EINTR <br style="margin:0px; padding:0px"> Interrupted system call<br style="margin:0px; padding:0px"> 系统调用被禁止 <br style="margin:0px; padding:0px"> 5 EIO <br style="margin:0px; padding:0px"> I/O error<br style="margin:0px; padding:0px"> I/O 错误 <br style="margin:0px; padding:0px"> 6 ENXIO <br style="margin:0px; padding:0px"> No such device or address<br style="margin:0px; padding:0px"> 无此器件或地址 <br style="margin:0px; padding:0px"> 7 E2BIG <br style="margin:0px; padding:0px"> Arg list too long<br style="margin:0px; padding:0px"> Arg 列表太长 <br style="margin:0px; padding:0px"> 8 ENOEXEC <br style="margin:0px; padding:0px"> Exec format error<br style="margin:0px; padding:0px"> Exec 格式错误 <br style="margin:0px; padding:0px"> 9 EBADF <br style="margin:0px; padding:0px"> Bad file number<br style="margin:0px; padding:0px"> 文件数目错误<br style="margin:0px; padding:0px"> 10 ECHILD<br style="margin:0px; padding:0px"> No child processes<br style="margin:0px; padding:0px"> 无子过程<br style="margin:0px; padding:0px"> 11 EAGAIN<br style="margin:0px; padding:0px"> Try again<br style="margin:0px; padding:0px"> 再试一遍<br style="margin:0px; padding:0px"> 12 ENOMEM<br style="margin:0px; padding:0px"> Out of memory <br style="margin:0px; padding:0px"> 内存溢出<br style="margin:0px; padding:0px"> 13 EACCES<br style="margin:0px; padding:0px"> Permission denied <br style="margin:0px; padding:0px"> 许可拒绝<br style="margin:0px; padding:0px"> 14 EFAULT<br style="margin:0px; padding:0px"> Bad address <br style="margin:0px; padding:0px"> 错误的地址<br style="margin:0px; padding:0px"> 15 ENOTBLK<br style="margin:0px; padding:0px"> Block device required <br style="margin:0px; padding:0px"> 需要块设备<br style="margin:0px; padding:0px"> 16 EBUSY<br style="margin:0px; padding:0px"> Device or resource busy <br style="margin:0px; padding:0px"> 设备或资源忙<br style="margin:0px; padding:0px"> 17 EEXIST<br style="margin:0px; padding:0px"> File exists <br style="margin:0px; padding:0px"> 文件存在<br style="margin:0px; padding:0px"> 18 EXDEV<br style="margin:0px; padding:0px"> Cross-device link <br style="margin:0px; padding:0px"> 跨器链接<br style="margin:0px; padding:0px"> 19 ENODEV<br style="margin:0px; padding:0px"> No such device <br style="margin:0px; padding:0px"> 无此设备<br style="margin:0px; padding:0px"> 20 ENOTDIR<br style="margin:0px; padding:0px"> Not a directory <br style="margin:0px; padding:0px"> 不是一个目录<br style="margin:0px; padding:0px"> 21 EISDIR<br style="margin:0px; padding:0px"> Is a directory <br style="margin:0px; padding:0px"> 是一个目录<br style="margin:0px; padding:0px"> 22 EINVAL<br style="margin:0px; padding:0px"> Invalid argument <br style="margin:0px; padding:0px"> 无效的函数自变量<br style="margin:0px; padding:0px"> 23 ENFILE<br style="margin:0px; padding:0px"> File table overflow <br style="margin:0px; padding:0px"> 文件表溢出<br style="margin:0px; padding:0px"> 24 EMFILE<br style="margin:0px; padding:0px"> Too many open files<br style="margin:0px; padding:0px"> 打开的文件太多<br style="margin:0px; padding:0px"> 25 ENOTTY<br style="margin:0px; padding:0px"> Inappropriate ioctl for device <br style="margin:0px; padding:0px"> <br style="margin:0px; padding:0px"> 26 ETXTBSY<br style="margin:0px; padding:0px"> Text file busy <br style="margin:0px; padding:0px"> 文本文件忙<br style="margin:0px; padding:0px"> 27 EFBIG<br style="margin:0px; padding:0px"> File too large<br style="margin:0px; padding:0px"> 文件太大<br style="margin:0px; padding:0px"> 28 ENOSPC<br style="margin:0px; padding:0px"> No space left on device <br style="margin:0px; padding:0px"> 磁盘空间不足<br style="margin:0px; padding:0px"> 29 ESPIPE <br style="margin:0px; padding:0px"> Illegal seek <br style="margin:0px; padding:0px"> 不合法的寻找<br style="margin:0px; padding:0px"> 30 EROFS <br style="margin:0px; padding:0px"> Read-only file system <br style="margin:0px; padding:0px"> 只读文件系统<br style="margin:0px; padding:0px"> 31 EMLINK <br style="margin:0px; padding:0px"> Too many links<br style="margin:0px; padding:0px"> 太多的链接</p> 
<p style="margin:5px auto; padding-top:0px; padding-bottom:0px; color:rgb(73,73,73); font-size:14px; line-height:22px"> <br> </p> 
<p style="margin:5px auto; padding-top:0px; padding-bottom:0px; color:rgb(73,73,73); font-size:14px; line-height:22px"> 转自：<a href="http://www.cnblogs.com/flyfish10000/articles/2576885.html" rel="nofollow">http://www.cnblogs.com/flyfish10000/articles/2576885.html</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1968be1ecc00e0aea2c7cdec26753496/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">struts2处理form表单的多submit提交</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/86c7f65e8333d9aef7beb6cd24eb9c35/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">win7 安装程序无法创建新的系统分区，也无法定位现有系统分区</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>