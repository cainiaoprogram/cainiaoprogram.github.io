<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android开发学习之路--APT技术 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android开发学习之路--APT技术" />
<meta property="og:description" content="今年都快要过去了，也已经2个月没有写博客了，主要还是换了新工作，今年都好几家徘徊了，从最初的公司散伙，也快1年了，这么背的17年终于快要结束了。不过庆幸的是加入了目前的公司，一个暂时觉得可以锻炼自己的平台。从嵌入式到app到嵌入式android系统，这次又回到了app，希望这次可以深耕3-5年，能在移动互联网站稳脚跟。两个月的时间忙于熟悉了解公司业务，也少了自己学习的时间，机器学习还没继续，android也没有深入了解，是时候补一把了。 以前遇到Dagger2, ButterKnife, EventBus3等的都是直接用，也没有太关心内部的源码实现。当想看的时候，发现一堆的注解不是非常好理解，所以还是先打打基础学习下apt技术吧，虽然不是那么新鲜了。
1.前言 首先看下butterknife生成的代码，要是都自己来敲，那就没法去和女神约会潇洒了。作为有家室的，也得多留点时间陪媳妇。
@BindView(R.id.iv_left_menu) ImageView ivLeftMenu; @BindView(R.id.iv_add) ImageView ivAdd; @BindView(R.id.toolbar) Toolbar toolbar; @BindView(R.id.rv_content) RecyclerView rvRobots; @BindView(R.id.coordinator_layout) LinearLayout coordinatorLayout; 然后实际的生成的代码如下：
public class Main2Fragment_ViewBinding implements Unbinder { private Main2Fragment target; @UiThread public Main2Fragment_ViewBinding(Main2Fragment target, View source) { this.target = target; target.ivLeftMenu = Utils.findRequiredViewAsType(source, R.id.iv_left_menu, &#34;field &#39;ivLeftMenu&#39;&#34;, ImageView.class); target.ivAdd = Utils.findRequiredViewAsType(source, R.id.iv_add, &#34;field &#39;ivAdd&#39;&#34;, ImageView.class); target.toolbar = Utils.findRequiredViewAsType(source, R.id.toolbar, &#34;field &#39;toolbar&#39;&#34;, Toolbar.class); target.rvRobots = Utils.findRequiredViewAsType(source, R.id.rv_content, &#34;field &#39;rvRobots&#39;&#34;, RecyclerView.class); target." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4cab3fd182a3f4b694989f273eadba31/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-12-13T21:33:46+08:00" />
<meta property="article:modified_time" content="2017-12-13T21:33:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android开发学习之路--APT技术</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>今年都快要过去了，也已经2个月没有写博客了，主要还是换了新工作，今年都好几家徘徊了，从最初的公司散伙，也快1年了，这么背的17年终于快要结束了。不过庆幸的是加入了目前的公司，一个暂时觉得可以锻炼自己的平台。从嵌入式到app到嵌入式android系统，这次又回到了app，希望这次可以深耕3-5年，能在移动互联网站稳脚跟。两个月的时间忙于熟悉了解公司业务，也少了自己学习的时间，机器学习还没继续，android也没有深入了解，是时候补一把了。 <br> 以前遇到Dagger2, ButterKnife, EventBus3等的都是直接用，也没有太关心内部的源码实现。当想看的时候，发现一堆的注解不是非常好理解，所以还是先打打基础学习下apt技术吧，虽然不是那么新鲜了。</p> 
<h4 id="1前言">1.前言</h4> 
<p>首先看下butterknife生成的代码，要是都自己来敲，那就没法去和女神约会潇洒了。作为有家室的，也得多留点时间陪媳妇。</p> 
<pre class="prettyprint"><code class=" hljs css"><span class="hljs-at_rule">@<span class="hljs-keyword">BindView(R.id.iv_left_menu)</span>
ImageView ivLeftMenu</span>;
<span class="hljs-at_rule">@<span class="hljs-keyword">BindView(R.id.iv_add)</span>
ImageView ivAdd</span>;
<span class="hljs-at_rule">@<span class="hljs-keyword">BindView(R.id.toolbar)</span>
Toolbar toolbar</span>;
<span class="hljs-at_rule">@<span class="hljs-keyword">BindView(R.id.rv_content)</span>
RecyclerView rvRobots</span>;
<span class="hljs-at_rule">@<span class="hljs-keyword">BindView(R.id.coordinator_layout)</span>
LinearLayout coordinatorLayout</span>;</code></pre> 
<p>然后实际的生成的代码如下：</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main2Fragment_ViewBinding</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Unbinder</span> {<!-- --></span>
  <span class="hljs-keyword">private</span> Main2Fragment target;

  <span class="hljs-annotation">@UiThread</span>
  <span class="hljs-keyword">public</span> <span class="hljs-title">Main2Fragment_ViewBinding</span>(Main2Fragment target, View source) {
    <span class="hljs-keyword">this</span>.target = target;

    target.ivLeftMenu = Utils.findRequiredViewAsType(source, R.id.iv_left_menu, <span class="hljs-string">"field 'ivLeftMenu'"</span>, ImageView.class);
    target.ivAdd = Utils.findRequiredViewAsType(source, R.id.iv_add, <span class="hljs-string">"field 'ivAdd'"</span>, ImageView.class);
    target.toolbar = Utils.findRequiredViewAsType(source, R.id.toolbar, <span class="hljs-string">"field 'toolbar'"</span>, Toolbar.class);
    target.rvRobots = Utils.findRequiredViewAsType(source, R.id.rv_content, <span class="hljs-string">"field 'rvRobots'"</span>, RecyclerView.class);
    target.coordinatorLayout = Utils.findRequiredViewAsType(source, R.id.coordinator_layout, <span class="hljs-string">"field 'coordinatorLayout'"</span>, LinearLayout.class);
  }

  <span class="hljs-annotation">@Override</span>
  <span class="hljs-annotation">@CallSuper</span>
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unbind</span>() {
    Main2Fragment target = <span class="hljs-keyword">this</span>.target;
    <span class="hljs-keyword">if</span> (target == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">"Bindings already cleared."</span>);
    <span class="hljs-keyword">this</span>.target = <span class="hljs-keyword">null</span>;

    target.ivLeftMenu = <span class="hljs-keyword">null</span>;
    target.ivAdd = <span class="hljs-keyword">null</span>;
    target.toolbar = <span class="hljs-keyword">null</span>;
    target.rvRobots = <span class="hljs-keyword">null</span>;
    target.coordinatorLayout = <span class="hljs-keyword">null</span>;
  }
}</code></pre> 
<h4 id="2注解">2.注解</h4> 
<p>那么他是怎么实现的？在此之前需要了解下注解，可以参考下之前的一篇博客： <br> <a href="http://blog.csdn.net/eastmoon502136/article/details/50839054" target="_blank" rel="noopener noreferrer">Android开发学习之路–Annotation注解简化view控件之初体验</a> <br> 一年前刚接触的时候写的，勉强还能理解哈，这里主要还是实现了运行时的注解，用了反射肯定是需要消耗一定的性能。上述的butterknife生成的代码可是编译时生成的代码，基本不消耗性能的。</p> 
<h4 id="3什么是apt">3.什么是APT</h4> 
<p>理解了注解后，我们开始学习apt吧。</p> 
<ol><li>APT(Annotation Processing Tool)是一种处理注释的工具，它对源代码文件进行检测找出其中的Annotation，使用Annotation进行额外的处理。 Annotation处理器在处理Annotation时可以根据源文件中的Annotation生成额外的源文件和其它的文件(文件具体内容由Annotation处理器的编写者决定)，APT还会将编译生成的源文件和原来的源文件一起生成class文件。</li><li>annotationProcessor：APT工具中的一种，他是google开发的内置框架，不需要引入，具体可以直接在build.gradle中使用，比如butterknife和dagger2引入如下：</li></ol> 
<pre class="prettyprint"><code class=" hljs matlab">dependencies <span class="hljs-cell">{
    compile <span class="hljs-string">'com.jakewharton:butterknife:8.8.1'</span>
    annotationProcessor <span class="hljs-string">'com.jakewharton:butterknife-compiler:8.8.1'</span>

    compile <span class="hljs-string">'com.google.dagger:dagger:2.12'</span>
    annotationProcessor <span class="hljs-string">'com.google.dagger:dagger-compiler:2.12'</span>
}</span></code></pre> 
<h4 id="4apt注解的流程">4.APT注解的流程</h4> 
<ul><li>1.定义注解（如@automain）</li><li>2.定义注解处理器</li><li>3.在处理器里面完成处理方式，通常是生成java代码。</li><li>4.注册处理器</li><li>5.利用APT完成如下图的工作内容。 <br> <img src="https://images2.imgbox.com/ad/94/RDc2z301_o.png" alt="这里写图片描述" title=""></li></ul> 
<h4 id="5-apt的简单实现">5 APT的简单实现</h4> 
<p>既然了解了apt的过程，那么就来实现下了。</p> 
<h5 id="51-定义注解">5.1 定义注解</h5> 
<p>新建一个java库，命名为annotation。 <br> BindView注解：</p> 
<pre class="prettyprint"><code class=" hljs cs">@Retention(RetentionPolicy.CLASS)
@Target(ElementType.FIELD)
<span class="hljs-keyword">public</span> @<span class="hljs-keyword">interface</span> BindView {
    <span class="hljs-keyword">int</span> <span class="hljs-keyword">value</span>();
}</code></pre> 
<p>Onclick注解：</p> 
<pre class="prettyprint"><code class=" hljs cs">@Retention(RetentionPolicy.CLASS)
@Target(ElementType.METHOD)
<span class="hljs-keyword">public</span> @<span class="hljs-keyword">interface</span> OnClick {
    <span class="hljs-keyword">int</span>[] <span class="hljs-keyword">value</span>();
}</code></pre> 
<h5 id="52-定义注解处理器">5.2 定义注解处理器</h5> 
<p>新建一个java库，命名为processor。</p> 
<p>主要继承AbstractProcessor实现process方法生成对应的代码，至于AbstractProcessor何时被调用，怎么执行的，还没有做过多深入理解。利用了AutoService： <br> <a href="https://github.com/google/auto/tree/master/service" target="_blank" rel="noopener noreferrer">https://github.com/google/auto/tree/master/service</a>。看一段官方的话：</p> 
<blockquote> 
 <p>AutoService will generate the file <br> META-INF/services/javax.annotation.processing.Processor in the output <br> classes folder.</p> 
</blockquote> 
<p>在process方法里扫描所有的BindView和OnClick注解，然后javapoet来生成代码，这里生成代码的class为MAinActivity$$Finder.class，具体的实现可以参考github的例子，已经注释得很清楚了(例子源码在文末的链接中)。 <br> 若想要更深入理解javapoet的使用，可以参考这里：<a href="http://www.jianshu.com/p/95f12f72f69a" rel="nofollow noopener noreferrer" target="_blank">javapoet</a> </p> 
<h5 id="53-编译生成代码">5.3 编译生成代码</h5> 
<p>编译后在app/build/generated/source/apt/debug/com/jared/helloapt目录下会生成对应的MainActivity$$Finder.class文件</p> 
<pre class="prettyprint"><code class=" hljs axapta"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span>$$<span class="hljs-title">Finder</span> <span class="hljs-inheritance"><span class="hljs-keyword">implements</span></span> <span class="hljs-title">Finder</span>&lt;<span class="hljs-title">MainActivity</span>&gt; {<!-- --></span>
  @Override
  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> inject(<span class="hljs-keyword">final</span> MainActivity host, Object source, Provider provider) {
    host.tvInfo = (TextView)(provider.findView(source, <span class="hljs-number">2131165309</span>));
    View.OnClickListener listener;
    listener = <span class="hljs-keyword">new</span> View.OnClickListener() {
      @Override
      <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> onClick(View view) {
        host.onClick(view);
      }
    };
    provider.findView(source, <span class="hljs-number">2131165219</span>).setOnClickListener(listener);
    provider.findView(source, <span class="hljs-number">2131165220</span>).setOnClickListener(listener);
  }
}</code></pre> 
<p>很明显这里就是我们平时写的findview啊，setOnclickLIstener等方法的具体实现。通过注解，然后自动生成代码，注入到我们需要的类中。就免去了很多的重复劳动力，而且不会影响代码的运行效率。</p> 
<h5 id="54-注册处理器">5.4 注册处理器</h5> 
<p>新建一个android的library，命名为viewfinder。 <br> 实现ViewFinder的static的inject方法，用于注入代码。最后调用到注解处理器中生成的xxx$$Finder类的inject方法。其中这里xxx既是MainActivity。</p> 
<h4 id="6总结下">6.总结下</h4> 
<p>这里我们再把整个过程理一遍。 <br> <strong>编译期间</strong> <br> processor模块里的自定义的MyProcessor类的process会扫描所有的注解，然后生成自定义的XXX$$Finder.class代码。 <br> <strong>使用期间</strong> <br> 首先使用注解@BindView(R.id.tv_info)以及@OnClick({R.id.bt_change, R.id.bt_reset}), <br> 接着MainActivity的onCreate方法中调用 <br> ViewFinder.inject(this);方法来注入编译期间生成的代码。</p> 
<p>关于apt技术基本上也了解了，说了那么多其实把例子敲一遍就都明白了。 <br> <a href="https://github.com/eastmoon1117/StudyTestCase/tree/master/HelloAPT">github源码例子点击这里</a></p> 
<p>参考: <br> <a href="http://blog.chengyunfeng.com/?p=1021" rel="nofollow">http://blog.chengyunfeng.com/?p=1021</a> <br> <a href="http://blog.csdn.net/u011315960/article/details/64441120">http://blog.csdn.net/u011315960/article/details/64441120</a> <br> <a href="http://blog.csdn.net/hj7jay/article/details/52180023">http://blog.csdn.net/hj7jay/article/details/52180023</a> <br> <a href="https://github.com/sockeqwe/annotationprocessing101">https://github.com/sockeqwe/annotationprocessing101</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8c9dd463d3892b21d0d202280f0f535f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Android 7.0 Camera架构源码分析1 - CameraService启动</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8160bace57c895409451706ca9fa4b30/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring MVC 接收POST表单请求，获取参数总结</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>