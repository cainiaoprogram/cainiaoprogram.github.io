<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java实现多线程 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java实现多线程" />
<meta property="og:description" content="目录
基本概念
1、程序、进程、线程
2、使用线程的优点
3、线程的分类
4、线程的生命周期
多线程的实现方法
1、继承Thread类
2、实现Runnable接口
3、实现Callable接口
4、使用线程池
线程同步
1、同步代码、同步方法
2、同步机制中的锁
3、锁（Lock）
4、线程的通信
5、经典例题：
（1）生产者消费者问题
（2）车票问题
基本概念 1、程序、进程、线程 首先先来了解关于什么是程序、进程、线程
程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代
码，静态对象。 进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态 的过程：有它自身的产生、存在和消亡的过程。—生命周期 1、如：运行中的QQ，运行中的MP3播放器 2、程序是静态的，进程是动态的 3、进程作为资源分配的单位， 系统在运行时会为每个进程分配不同的内存区域 线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径。 1、若一个进程同一时间并行执行多个线程，就是支持多线程的。 2、线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小。 3、一个进程中的多个线程共享相同的内存单元/内存地址空间 -&gt; 它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患。 进程与线程 一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc() 垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。 2、使用线程的优点 1、提高应用程序的响应。对图形化界面更有意义，可增强用户体验。 2、提高计算机系统CPU的利用率。 3、改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。 3、线程的分类 Java中的线程分为两类：一种是守护线程，一种是用户线程。 1、它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开。 2、守护线程是用来服务用户线程的，通过在start()方法前调用 thread.setDaemon(true)可以把一个用户线程变成一个守护线程。 3、Java垃圾回收就是一个典型的守护线程。 4、若JVM中都是守护线程，当前JVM将退出。 4、线程的生命周期 （1）JDK 中用 Thread.State 类定义了线程的几种状态 要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类 及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五 种状态： 新建： 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是没分配到CPU资源 运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态， run()方法定义了线程的操作和功能 阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 CPU 并临时中止自己的执行，进入阻塞状态 死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束 （2）线程周期的图例 多线程的实现方法 1、继承Thread类 Java语言的JVM允许程序运行多个线程，它通过java." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4a7c26cd7fba5f80d02278783cb896f4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-29T19:14:14+08:00" />
<meta property="article:modified_time" content="2022-12-29T19:14:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java实现多线程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p></p> 
<p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" rel="nofollow">基本概念</a></p> 
<p id="1%E3%80%81%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B" rel="nofollow">1、程序、进程、线程</a></p> 
<p id="2%E3%80%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9" rel="nofollow">2、使用线程的优点</a></p> 
<p id="3%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB" rel="nofollow">3、线程的分类</a></p> 
<p id="4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" rel="nofollow">4、线程的生命周期</a></p> 
<p id="%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95-toc" style="margin-left:0px;"><a href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95" rel="nofollow">多线程的实现方法</a></p> 
<p id="1%E3%80%81%E7%BB%A7%E6%89%BFThread%E7%B1%BB-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E7%BB%A7%E6%89%BFThread%E7%B1%BB" rel="nofollow">1、继承Thread类</a></p> 
<p id="2%E3%80%81%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3" rel="nofollow">2、实现Runnable接口</a></p> 
<p id="3%E3%80%81%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3" rel="nofollow">3、实现Callable接口</a></p> 
<p id="4%E3%80%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0" rel="nofollow">4、使用线程池</a></p> 
<p id="%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-toc" style="margin-left:0px;"><a href="#%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5" rel="nofollow">线程同步</a></p> 
<p id="1%E3%80%81%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81-toc" style="margin-left:80px;"><a href="#1%E3%80%81%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81" rel="nofollow">1、同步代码、同步方法</a></p> 
<p id="2%E3%80%81%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%9A%84%E9%94%81-toc" style="margin-left:80px;"><a href="#2%E3%80%81%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%9A%84%E9%94%81" rel="nofollow">2、同步机制中的锁</a></p> 
<p id="3%E3%80%81%E9%94%81%EF%BC%88Lock%EF%BC%89-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E9%94%81%EF%BC%88Lock%EF%BC%89" rel="nofollow">3、锁（Lock）</a></p> 
<p id="4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1-toc" style="margin-left:80px;"><a href="#4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1" rel="nofollow">4、线程的通信</a></p> 
<p id="3%E3%80%81%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98%EF%BC%9A-toc" style="margin-left:80px;"><a href="#3%E3%80%81%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98%EF%BC%9A" rel="nofollow">5、经典例题：</a></p> 
<p id="%EF%BC%881%EF%BC%89%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98" rel="nofollow">（1）生产者消费者问题</a></p> 
<p id="%EF%BC%882%EF%BC%89%E8%BD%A6%E7%A5%A8%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E8%BD%A6%E7%A5%A8%E9%97%AE%E9%A2%98" rel="nofollow">（2）车票问题</a></p> 
<hr id="hr-toc"> 
<p></p> 
<hr> 
<p></p> 
<h2 id="%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</h2> 
<h4 id="1%E3%80%81%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B"><span style="color:#0d0016;">1、程序、进程、线程</span></h4> 
<p><strong>首先先来了解关于什么是程序、进程、线程</strong></p> 
<blockquote> 
 <p><strong><span style="color:#0000ff;">程序</span><span style="color:#0000ff;">(program)</span><span style="color:#000000;">是为完成特定任务、用某种语言编写的一组指令的集合。即指</span><span style="color:#fe2c24;">一段</span><span style="color:#ff0000;">静态的代</span></strong></p> 
 <p><strong><span style="color:#ff0000;">码</span></strong><span style="color:#000000;"><strong>，静态对象。</strong> </span></p> 
</blockquote> 
<blockquote> 
 <div> 
  <strong><span style="color:#0000ff;">进程</span><span style="color:#0000ff;">(process)</span><span style="color:#000000;">是程序的一次执行过程，或是</span><span style="color:#ff0000;">正在运行的一个程序</span><span style="color:#000000;">。是一个动态 的过程：有它自身的产生、存在和消亡的过程。—生命周期 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">1、如：运行中的QQ</span><span style="color:#000000;">，运行中的</span><span style="color:#000000;">MP3播放器 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">2、程序是静态的，进程是动态的 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#0d0016;">3、</span><span style="color:#ff0000;">进程作为资源分配的单位，</span></strong> 
  <span style="color:#000000;"><strong>系统在运行时会为每个进程分配不同的内存区域</strong> </span> 
 </div> 
</blockquote> 
<blockquote> 
 <div> 
  <strong><span style="color:#0000ff;">线程</span><span style="color:#0000ff;">(thread)</span><span style="color:#000000;">，进程可进一步细化为线程，是一个程序内部的一条执行路径。 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">1、若一个进程同一时间</span><span style="color:#0000ff;">并行</span><span style="color:#000000;">执行多个线程，就是支持多线程的。</span></strong> 
 </div> 
 <div> 
  <strong>2、<span style="color:#ff0000;">线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)</span><span style="color:#000000;">，线程切换的开销小。</span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">3、一个进程中的多个线程共享相同的内存单元/内存地址空间 -&gt; 它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来</span><span style="color:#ff0000;">安全的隐患</span><span style="color:#000000;">。</span></strong> 
 </div> 
</blockquote> 
<div></div> 
<div> 
 <strong><span style="color:#000000;">进程与线程</span></strong> 
 <img alt="" height="383" src="https://images2.imgbox.com/9b/b6/EUPNqel9_o.png" width="844"> 
</div> 
<p></p> 
<blockquote> 
 <div> 
  <strong><span style="color:#fe2c24;">一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc() 垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程。</span></strong> 
 </div> 
</blockquote> 
<div></div> 
<h4 id="2%E3%80%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9">2、使用线程的优点</h4> 
<blockquote> 
 <div> 
  <span style="color:#0d0016;"><strong>1、提高应用程序的响应。对图形化界面更有意义，可增强用户体验。 </strong></span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#0d0016;"><strong>2、提高计算机系统CPU的利用率。</strong></span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#0d0016;"><strong>3、改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改。</strong></span> 
 </div> 
</blockquote> 
<h4></h4> 
<h4 id="3%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB">3、线程的分类</h4> 
<blockquote> 
 <div> 
  <strong><span style="color:#000000;">Java</span><span style="color:#000000;">中的线程分为两类：一种是</span><span style="color:#fe2c24;">守护线程</span><span style="color:#000000;">，一种是</span><span style="color:#fe2c24;">用户线程</span><span style="color:#000000;">。</span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">1、它们在几乎每个方面都是相同的，唯一的区别是判断</span><span style="color:#000000;">JVM</span><span style="color:#000000;">何时离开。 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">2、守护线程是用来服务用户线程的，通过在</span><span style="color:#000000;">start()</span><span style="color:#000000;">方法前调用 </span><span style="color:#fe2c24;">thread.setDaemon(true)</span><span style="color:#000000;">可以把一个用户线程变成一个守护线程。 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">3、Java</span><span style="color:#000000;">垃圾回收就是一个典型的守护线程。 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">4、若</span><span style="color:#000000;">JVM</span><span style="color:#000000;">中都是守护线程，当前</span><span style="color:#000000;">JVM</span><span style="color:#000000;">将退出。 </span></strong> 
 </div> 
</blockquote> 
<div></div> 
<h4 id="4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">4、线程的生命周期</h4> 
<div> 
 <span style="color:#000000;"><strong>（1）JDK</strong></span> 
 <span style="color:#000000;"><strong>中用</strong></span> 
 <span style="color:#000000;"><strong>Thread.State</strong></span> 
 <span style="color:#000000;"><strong>类定义了线程的几种状态 </strong></span> 
</div> 
<div> 
 <blockquote> 
  <div> 
   <strong><span style="color:#000000;">要想实现多线程，必须在主线程中创建新的线程对象。</span><span style="color:#000000;">Java</span><span style="color:#000000;">语言使用</span><span style="color:#000000;">Thread</span><span style="color:#000000;">类</span></strong> 
   <strong><span style="color:#000000;">及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五</span></strong> 
   <strong><span style="color:#000000;">种状态： </span></strong> 
  </div> 
  <div></div> 
  <div> 
   <strong><span style="color:#fe2c24;">新建：</span><span style="color:#c00000;"> </span><span style="color:#000000;">当一个</span><span style="color:#000000;">Thread</span><span style="color:#000000;">类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 </span></strong> 
  </div> 
  <div></div> 
  <div> 
   <strong><span style="color:#fe2c24;">就绪：</span><span style="color:#000000;">处于新建状态的线程被</span><span style="color:#000000;">start()</span><span style="color:#000000;">后，将进入线程队列等待</span><span style="color:#000000;">CPU</span><span style="color:#000000;">时间片，此时它已具备了运行的条件，只是没分配到CPU</span><span style="color:#000000;">资源 </span></strong> 
  </div> 
  <div></div> 
  <div> 
   <strong><span style="color:#fe2c24;">运行：</span><span style="color:#000000;">当就绪的线程被调度并获得</span><span style="color:#000000;">CPU</span><span style="color:#000000;">资源时</span><span style="color:#000000;">,</span><span style="color:#000000;">便进入运行状态， </span><span style="color:#000000;">run()</span><span style="color:#000000;">方法定义了线程的操作和功能 </span></strong> 
  </div> 
  <div></div> 
  <div> 
   <strong><span style="color:#fe2c24;">阻塞：</span><span style="color:#000000;">在某种特殊情况下，被人为挂起或执行输入输出操作时，让出 </span><span style="color:#000000;">CPU </span><span style="color:#000000;">并临时中止自己的执行，进入阻塞状态 </span></strong> 
  </div> 
  <div></div> 
  <div> 
   <strong><span style="color:#fe2c24;">死亡：</span><span style="color:#000000;">线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</span></strong> 
  </div> 
 </blockquote> 
 <div> 
  <strong><span style="color:#000000;">（2）线程周期的图例</span></strong> 
  <img alt="" height="472" src="https://images2.imgbox.com/b5/09/rq2ZINiW_o.png" width="1157"> 
 </div> 
 <p></p> 
</div> 
<h2 id="%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95">多线程的实现方法</h2> 
<h4 id="1%E3%80%81%E7%BB%A7%E6%89%BFThread%E7%B1%BB">1、继承Thread类</h4> 
<div> 
 <strong><span style="color:#fe2c24;">Java语言的JVM允许程序运行多个线程，它通过java.lang.Thread类来体现。 </span></strong> 
</div> 
<div></div> 
<blockquote> 
 <div> 
  <strong><span style="color:#000000;">Thread</span><span style="color:#000000;">类的特性 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">（1）每个线程都是通过某个特定</span><span style="color:#000000;">Thread</span><span style="color:#000000;">对象的</span><span style="color:#000000;">run()</span><span style="color:#000000;">方法来完成操作的，经常 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">（2）把</span><span style="color:#000000;">run()</span><span style="color:#000000;">方法的主体称为</span><span style="color:#000000;">线程体 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">（3）通过该</span><span style="color:#000000;">Thread</span><span style="color:#000000;">对象的</span><span style="color:#000000;">start()</span><span style="color:#000000;">方法来启动这个线程，而非直接调用</span><span style="color:#000000;">run()</span></strong> 
 </div> 
</blockquote> 
<blockquote> 
 <div> 
  <strong>实现步骤：</strong> 
 </div> 
 <div> 
  <div> 
   <strong><span style="color:#000000;">1) </span><span style="color:#000000;">定义子类继承</span><span style="color:#000000;">Thread</span><span style="color:#000000;">类。 </span></strong> 
  </div> 
  <div> 
   <strong><span style="color:#000000;">2) </span><span style="color:#c00000;">子类中重写</span><span style="color:#c00000;">Thread</span><span style="color:#c00000;">类中的</span><span style="color:#c00000;">run</span><span style="color:#c00000;">方法。 </span></strong> 
  </div> 
  <div> 
   <strong><span style="color:#000000;">3) </span><span style="color:#000000;">创建</span><span style="color:#000000;">Thread</span><span style="color:#000000;">子类对象，即创建了线程对象。 </span></strong> 
  </div> 
  <div> 
   <strong><span style="color:#000000;">4) </span><span style="color:#000000;">调用线程对象</span><span style="color:#000000;">start</span><span style="color:#000000;">方法：启动线程，调用</span><span style="color:#000000;">run</span><span style="color:#000000;">方法。</span></strong> 
  </div> 
 </div> 
</blockquote> 
<h4 id="%E2%80%8B%E7%BC%96%E8%BE%91"><img alt="" height="583" src="https://images2.imgbox.com/84/1d/FzQZHiVn_o.png" width="763"></h4> 
<p><strong> 注意点：</strong></p> 
<blockquote> 
 <div> 
  <span style="color:#fe2c24;"><strong>1. 如果自己手动调用run()方法，那么就只是普通方法，没有启动多线程模式。 </strong></span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#fe2c24;"><strong>2. run()方法由JVM调用，什么时候调用，执行的过程控制都有操作系统的CPU调度决定。 </strong></span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#fe2c24;"><strong>3. 想要启动多线程，必须调用start方法。 </strong></span> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#fe2c24;"><strong>4. 一个线程对象只能调用一次start()方法启动，如果重复调用了，则将抛出以上的异常“IllegalThreadStateException”。</strong></span> 
 </div> 
</blockquote> 
<h4></h4> 
<h4 id="2%E3%80%81%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3">2、实现Runnable接口</h4> 
<blockquote> 
 <p><strong>实现步骤：</strong></p> 
 <div> 
  <strong><span style="color:#000000;">1) </span><span style="color:#000000;">定义子类，实现</span><span style="color:#000000;">Runnable</span><span style="color:#000000;">接口。 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">2) </span><span style="color:#c00000;">子类中重写</span><span style="color:#c00000;">Runnable</span><span style="color:#c00000;">接口中的</span><span style="color:#c00000;">run</span><span style="color:#c00000;">方法。 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">3) </span><span style="color:#000000;">通过</span><span style="color:#000000;">Thread</span><span style="color:#000000;">类含参构造器创建线程对象。 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">4) </span><span style="color:#c00000;">将</span><span style="color:#c00000;">Runnable</span><span style="color:#c00000;">接口的子类对象作为实际参数传递给</span><span style="color:#c00000;">Thread</span><span style="color:#c00000;">类的构造器中。 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">5) </span><span style="color:#000000;">调用</span><span style="color:#000000;">Thread</span><span style="color:#000000;">类的</span><span style="color:#000000;">start</span><span style="color:#000000;">方法：开启线程，调用</span><span style="color:#000000;">Runnable</span><span style="color:#000000;">子类接口的</span><span style="color:#000000;">run</span><span style="color:#000000;">方法。</span></strong> 
 </div> 
</blockquote> 
<div> 
 <img alt="" height="426" src="https://images2.imgbox.com/7b/7e/USgeo28y_o.png" width="906"> 
</div> 
<p></p> 
<blockquote> 
 <p><strong>关于<span style="color:#000000;">继承Thread方式和实现Runnable方式的联系与区别</span></strong></p> 
 <p><strong><span style="color:#000000;">区别</span></strong></p> 
 <p><strong>（1）继承Thread类：线程代码存放在Thread子类的run方法中。</strong></p> 
 <p><strong>（2）实现Runnable接口：线程代码存放在接口子类的run方法中。</strong></p> 
 <p><span style="color:#0d0016;"><strong>实现方式的好处</strong></span></p> 
 <p><strong>（1）避免了单继承的局限性。</strong></p> 
 <p><strong>（2）多个线程可以共享一个接口实现类的对象，非常适合多个相同的线程来处理同一份资源。</strong></p> 
</blockquote> 
<p></p> 
<blockquote> 
 <p><strong>练习：<span style="color:#000000;">创建两个分线程，让其中一个线程输出1-100</span><span style="color:#000000;">之间的偶数，另一 个线程输出1-100</span><span style="color:#000000;">之间的奇数。</span></strong></p> 
</blockquote> 
<p><strong><span style="color:#000000;">可以使用继承Thread类或实现Runnable接口，下面我以继承Thrrad类为例</span></strong></p> 
<pre><code class="language-java">public class TestDmo {
    public static void main(String[] args) {
        OddNumber o = new OddNumber();  //创建OddNumber的对象
        EvenNumber e = new EvenNumber();  //创建EvenNumber的对象
        o.start();
        e.start();  //两个线程同时启动，没有先后之分
    }
}

class OddNumber extends Thread{  //奇数
    //方法
    public void run() {  //重写thread类的run方法（将线程的执行操作声明其中）
        for (int i = 0; i &lt; 100; i++) {
            if(i%2!=0){
                System.out.println("奇数："+i);
            }
        }
    }
}

class EvenNumber extends Thread{  //偶数
    //方法
    public void run() {  //重写thread类的run方法（将线程的执行操作声明其中）
        for (int i = 0; i &lt; 100; i++) {
            if(i%2==0){
                System.out.println("偶数："+i);
            }
        }
    }
}</code></pre> 
<p></p> 
<h4 id="3%E3%80%81%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3">3、实现Callable接口</h4> 
<blockquote> 
 <div> 
  <strong><span style="color:#000000;">与使用</span><span style="color:#000000;">Runnable</span><span style="color:#000000;">相比， </span><span style="color:#000000;">Callable</span><span style="color:#000000;">功能更强大些 </span></strong> 
 </div> 
 <div> 
  <div> 
   <strong><span style="color:#000000;">（1）相比</span><span style="color:#000000;">run()</span><span style="color:#000000;">方法，可以有返回值 </span></strong> 
  </div> 
  <div> 
   <strong><span style="color:#000000;">（2）方法可以抛出异常 </span></strong> 
  </div> 
  <div> 
   <strong><span style="color:#000000;">（3）支持泛型的返回值 </span></strong> 
  </div> 
  <div> 
   <strong><span style="color:#000000;">（4）需要借助</span><span style="color:#000000;">FutureTask</span><span style="color:#000000;">类，比如获取返回结果</span></strong> 
  </div> 
 </div> 
</blockquote> 
<blockquote> 
 <div> 
  <strong><span style="color:#262626;">Future</span><span style="color:#262626;">接口 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#262626;">1、可以对具体</span><span style="color:#262626;">Runnable</span><span style="color:#262626;">、</span><span style="color:#262626;">Callable</span><span style="color:#262626;">任务的执行结果进行取消、查询是 否完成、获取结果等</span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#0000ff;">2、FutrueTask</span><span style="color:#0000ff;">是</span><span style="color:#0000ff;">Futrue</span><span style="color:#0000ff;">接口的唯一的实现类 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#262626;">3、FutureTask </span><span style="color:#262626;">同时实现了</span><span style="color:#262626;">Runnable, Future</span><span style="color:#262626;">接口。它既可以作为 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#262626;">4、Runnable</span><span style="color:#262626;">被线程执行，又可以作为</span><span style="color:#262626;">Future</span><span style="color:#262626;">得到</span><span style="color:#262626;">Callable</span><span style="color:#262626;">的返回值</span></strong> 
 </div> 
</blockquote> 
<h4><img alt="" height="483" src="https://images2.imgbox.com/61/f1/GqmZ8hz8_o.png" width="819"></h4> 
<p><img alt="" height="671" src="https://images2.imgbox.com/8a/a9/vOTUeKbe_o.png" width="821"> </p> 
<blockquote> 
 <p> <span style="color:#38d8f0;"><strong>实现Callable接口 —— JDK 5.0新增</strong></span></p> 
</blockquote> 
<h4></h4> 
<h4 id="4%E3%80%81%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0">4、使用线程池</h4> 
<blockquote> 
 <div> 
  <strong><span style="color:#000000;">背景：</span><span style="color:#000000;">经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大。</span></strong> 
 </div> 
 <div></div> 
 <div> 
  <div> 
   <strong><span style="color:#000000;">思路：</span><span style="color:#000000;">提前</span></strong> 
   <span style="color:#000000;"><strong>创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具。</strong> </span> 
  </div> 
 </div> 
</blockquote> 
<blockquote> 
 <div> 
  <span style="color:#000000;"><strong>好处： </strong></span> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">1、提高响应速度（减少了创建新线程的时间） </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">2、降低资源消耗（重复利用线程池中线程，不需要每次都创建） </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">3、便于线程管理 </span></strong> 
 </div> 
 <div> 
  <span style="color:#000000;">      3.1 </span> 
  <span style="color:#000000;">corePoolSize</span> 
  <span style="color:#000000;">：核心池的大小 </span> 
 </div> 
 <div> 
  <span style="color:#000000;">      3.2 maximumPoolSize</span> 
  <span style="color:#000000;">：最大线程数 </span> 
 </div> 
 <div> 
  <span style="color:#000000;">      3.3 keepAliveTime</span> 
  <span style="color:#000000;">：线程没有任务时最多保持多长时间后会终止</span> 
 </div> 
</blockquote> 
<h2></h2> 
<h2 id="%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5">线程同步</h2> 
<h4 id="1%E3%80%81%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81">1、同步代码、同步方法</h4> 
<p><strong>同步代码：</strong></p> 
<pre><code class="language-java">synchronized (对象){
       // 需要被同步的代码；
}</code></pre> 
<p><strong> 同步方法：</strong><span style="color:#000000;"><strong>synchronized</strong></span><span style="color:#000000;"><strong>还可以放在方法声明中，表示整个方法为</strong></span><span style="color:#ff0000;"><strong>同步方法</strong></span><span style="color:#000000;"><strong>。 </strong></span></p> 
<pre><code class="language-java">public synchronized void show (String name){ 
    // 需要同步的代码
}</code></pre> 
<p><strong>同步分析：</strong><img alt="" height="459" src="https://images2.imgbox.com/d0/ed/uYRzKJtn_o.png" width="885"></p> 
<p> </p> 
<blockquote> 
 <p><span style="color:#956fe7;"><strong>使用线程同步的原因是为了防止一张票被多个窗口同时卖出等类似的问题。</strong></span></p> 
</blockquote> 
<p><img alt="" height="554" src="https://images2.imgbox.com/c4/61/CxZ9as3U_o.png" width="943"></p> 
<p><img alt="" height="561" src="https://images2.imgbox.com/d5/36/wkPzmwqB_o.png" width="875"></p> 
<p> </p> 
<h4 id="2%E3%80%81%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%9A%84%E9%94%81">2、<span style="color:#000000;"><strong>同步机制中的锁</strong></span></h4> 
<blockquote> 
 <div> 
  <span style="color:#000000;"><strong>同步锁机制： </strong></span> 
 </div> 
 <div> 
  <span style="color:#000000;">在《</span> 
  <span style="color:#000000;">Thinking in Java</span> 
  <span style="color:#000000;">》中，是这么说的：对于并发工作，你需要某种方式来防止两个任务访问相同的资源（其实就是共享资源竞争）。 防止这种冲突的方法就是当资源被一个任务使用时，在其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它了，而在其被解锁之时，另一个任务就可以锁定并使用它了。 </span> 
 </div> 
</blockquote> 
<div> 
 <blockquote> 
  <div> 
   <span style="color:#000000;"><strong>synchronized</strong></span> 
   <span style="color:#000000;"><strong>的锁是什么？ </strong></span> 
  </div> 
  <div> 
   <span style="color:#000000;">1、任意对象都可以作为同步锁。所有对象都自动含有单一的锁（监视器）。 </span> 
  </div> 
  <div> 
   <span style="color:#000000;"><strong>2</strong>、<strong>同步方法的锁：静态方法（类名</strong></span> 
   <strong><span style="color:#000000;">.class</span><span style="color:#000000;">）、非静态方法（</span><span style="color:#000000;">this</span><span style="color:#000000;">） </span></strong> 
  </div> 
  <div> 
   <strong><span style="color:#000000;">3、同步代码块：自己指定，很多时候也是指定为</span><span style="color:#000000;">this</span><span style="color:#000000;">或类名</span><span style="color:#000000;">.class</span></strong> 
  </div> 
 </blockquote> 
</div> 
<blockquote> 
 <div> 
  <strong><span style="color:#000000;">注意： </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">1、必须确保使用同一个资源的</span><span style="color:#ff0000;">多个线程共用一把锁</span><span style="color:#000000;">，这个非常重要，否则就无法保证共享资源的安全 </span></strong> 
 </div> 
 <div> 
  <strong><span style="color:#000000;">2、一个线程类中的所有静态方法共用同一把锁（类名</span><span style="color:#000000;">.class</span><span style="color:#000000;">），所有非静态方法共用同一把锁（this</span><span style="color:#000000;">），同步代码块（指定需谨慎） </span></strong> 
 </div> 
</blockquote> 
<h4></h4> 
<h4 id="3%E3%80%81%E9%94%81%EF%BC%88Lock%EF%BC%89">3、锁（Lock）</h4> 
<blockquote> 
 <div> 
  <strong><span style="color:#000000;">从</span><span style="color:#000000;">JDK 5.0</span><span style="color:#000000;">开始，</span><span style="color:#000000;">Java</span><span style="color:#000000;">提供了更强大的线程同步机制</span><span style="color:#000000;">——</span><span style="color:#000000;">通过显式定义同步锁对象来实现同步。同步锁使用Lock</span><span style="color:#000000;">对象充当。</span></strong> 
 </div> 
</blockquote> 
<div> 
 <blockquote> 
  <div> 
   <strong><span style="color:#ff0000;">java.util.concurrent.locks.Lock</span><span style="color:#ff0000;">接口是控制多个线程对共享资源进行访问的工具。</span><span style="color:#000000;">锁提供了对共享资源的独占访问，每次只能有一个线程对</span><span style="color:#000000;">Lock</span><span style="color:#000000;">对象加锁，线程开始访问共享资源之前应先获得Lock</span><span style="color:#000000;">对象。</span></strong> 
  </div> 
 </blockquote> 
</div> 
<pre><code class="language-java">class A{
    private final ReentrantLock lock = new ReenTrantLock(); //实例化ReentrantLock
    public void m(){
        lock.lock();  //调用锁定方式lock()
       
        try{

            //lock.lock(); //也可以放在try里面
            //保证线程安全的代码;

        }
        finally{

             //因为防止同步代码有异常，所以将unlock写入finally里面
            lock.unlock(); //调用解锁方法unlock()

         }
    }
}</code></pre> 
<blockquote> 
 <div> 
  <div> 
   <strong><span style="color:#000000;">synchronized 与 </span><span style="color:#000000;">Lock 的对比</span></strong> 
  </div> 
  <div> 
   <strong><span style="color:#000000;">1、Lock</span><span style="color:#000000;">是显式锁（手动开启和关闭锁，别忘记关闭锁），</span><span style="color:#000000;">synchronized</span><span style="color:#000000;">是 隐式锁，出了用域自动释放 </span></strong> 
  </div> 
  <div></div> 
  <div> 
   <strong><span style="color:#000000;">2、Lock</span><span style="color:#000000;">只有代码块锁，</span><span style="color:#000000;">synchronized</span><span style="color:#000000;">有代码块锁和方法锁 </span></strong> 
  </div> 
  <div></div> 
  <div> 
   <strong><span style="color:#000000;">3、</span><span style="color:#000000;">使用</span><span style="color:#000000;">Lock</span><span style="color:#000000;">锁，</span><span style="color:#000000;">JVM</span><span style="color:#000000;">将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类） </span></strong> 
  </div> 
 </div> 
</blockquote> 
<blockquote> 
 <p><strong>使用Lock解决Runnable接口中的线程安全问题。（以售卖车票的问题为例子）</strong></p> 
</blockquote> 
<pre><code class="language-java">import java.util.concurrent.locks.ReentrantLock;

public class TestDmo {
    public static void main(String[] args) {
        Window w = new Window();  //共用一个

        Thread t1 = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w); //创建三个线程

        t1.setName("窗口一");
        t2.setName("窗口二");
        t3.setName("窗口三");  //设置三个线程的名称

        t1.start();
        t2.start();
        t3.start();  //启动三个线程
    }
}

class Window implements Runnable{
    //属性
    private int ticket = 100;  //票数及票号
    private ReentrantLock lock = new ReentrantLock();//1.实例化ReentrantLock

    //方法
    public void run() {  //实现Runnable中的抽象方法
        while(true)
            try {
                lock.lock();   //2.调用锁定方法lock()
                if(ticket&gt;0){
                    System.out.println(Thread.currentThread().getName()+",票号："+ticket);
                    ticket--;
                }
                else {
                    break;
                }
        }finally {
                lock.unlock();  //3.调用解锁方法：unlock()
            }
    }
}
</code></pre> 
<h4 id="4%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1">4、线程的通信</h4> 
<div> 
 <span style="color:#fe2c24;"><strong>wait() 与 notify() 和 notifyAll()</strong></span> 
</div> 
<div> 
 <blockquote> 
  <div> 
   <strong><span style="color:#fe2c24;">wait()</span><span style="color:#000000;">：令当前线程挂起并放弃</span><span style="color:#000000;">CPU</span><span style="color:#000000;">、同步资源并等待，使别的线程可访问并修改共享资源，而当前线程排队等候其他线程调用notify()</span><span style="color:#000000;">或</span><span style="color:#000000;">notifyAll()</span><span style="color:#000000;">方法唤醒，唤醒后等待重新获得对监视器的所有权后才能继续执行。 </span></strong> 
  </div> 
  <div> 
   <strong><span style="color:#fe2c24;">notify()</span><span style="color:#000000;">：唤醒正在排队等待同步资源的线程中优先级最高者结束等待。</span></strong> 
  </div> 
  <div> 
   <strong><span style="color:#fe2c24;">notifyAll ()</span><span style="color:#000000;">：唤醒正在排队等待资源的所有线程结束等待。</span></strong> 
  </div> 
 </blockquote> 
</div> 
<blockquote> 
 <p><span style="color:#38d8f0;"><strong>注意：</strong></span></p> 
 <div> 
  <span style="color:#38d8f0;"><strong>这三个方法只有在synchronized方法或synchronized代码块中才能使用，否则会报 java.lang.IllegalMonitorStateException异常</strong></span> 
 </div> 
</blockquote> 
<pre><code class="language-java">class Communication implements Runnable {
    int i = 1;
    public void run() {
        while (true) {
            synchronized (this) {
                notify();  //唤醒被阻塞的线程
                if (i &lt;= 100) {
                       System.out.println(Thread.currentThread().getName() + ":" + i++);
                } else
                    break;

                try {
                    wait();  //使线程进入阻塞状态
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}</code></pre> 
<h4></h4> 
<h4 id="3%E3%80%81%E7%BB%8F%E5%85%B8%E4%BE%8B%E9%A2%98%EF%BC%9A">5、经典例题：</h4> 
<h4 id="%EF%BC%881%EF%BC%89%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98">（1）生产者消费者问题</h4> 
<blockquote> 
 <div> 
  <strong><span style="color:#000000;">生产者</span><span style="color:#000000;">(Productor)</span><span style="color:#000000;">将产品交给店员</span><span style="color:#000000;">(Clerk)</span><span style="color:#000000;">，而消费者</span><span style="color:#000000;">(Customer)</span><span style="color:#000000;">从店员处</span></strong> 
  <strong><span style="color:#000000;">取走产品，店员一次只能持有固定数量的产品(</span><span style="color:#000000;">比如</span><span style="color:#000000;">:20</span><span style="color:#000000;">），如果生产者试图</span></strong> 
  <strong><span style="color:#000000;">生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通</span></strong> 
  <strong><span style="color:#000000;">知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如</span></strong> 
  <strong><span style="color:#000000;">果店中有产品了再通知消费者来取走产品。 </span></strong> 
 </div> 
 <div></div> 
 <div> 
  <span style="color:#a2e043;"><strong>这里可能出现两个问题： </strong></span> 
 </div> 
 <div> 
  <span style="color:#a2e043;"><strong>1、生产者比消费者快时，消费者会漏掉一些数据没有取到。 </strong></span> 
 </div> 
 <div> 
  <span style="color:#a2e043;"><strong>2、消费者比生产者快时，消费者会取相同的数据。</strong></span> 
 </div> 
</blockquote> 
<pre><code class="language-java">class Clerk{

    private int productCount = 0;
    //生产产品
    public synchronized void produceProduct() {

        if(productCount &lt; 20){
            productCount++;
            System.out.println(Thread.currentThread().getName() + ":开始生产第" + productCount + "个产品");

            notify();

        }else{
            //等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
    //消费产品
    public synchronized void consumeProduct() {
        if(productCount &gt; 0){
            System.out.println(Thread.currentThread().getName() + ":开始消费第" + productCount + "个产品");
            productCount--;

            notify();
        }else{
            //等待
            try {
                wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

    }
}

class Producer extends Thread{//生产者

    private Clerk clerk;

    public Producer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println(getName() + ":开始生产产品.....");

        while(true){

            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            clerk.produceProduct();
        }

    }
}

class Consumer extends Thread{//消费者
    private Clerk clerk;

    public Consumer(Clerk clerk) {
        this.clerk = clerk;
    }

    @Override
    public void run() {
        System.out.println(getName() + ":开始消费产品.....");

        while(true){

            try {
                Thread.sleep(20);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }

            clerk.consumeProduct();
        }
    }
}

public class ProductTest {

    public static void main(String[] args) {
        Clerk clerk = new Clerk();

        Producer p1 = new Producer(clerk);
        p1.setName("生产者1");

        Consumer c1 = new Consumer(clerk);
        c1.setName("消费者1");

        p1.start();
        c1.start();

    }
}</code></pre> 
<h4></h4> 
<h4 id="%EF%BC%882%EF%BC%89%E8%BD%A6%E7%A5%A8%E9%97%AE%E9%A2%98">（2）车票问题</h4> 
<blockquote> 
 <p><strong>三个窗口售卖100张车票。</strong></p> 
 <p></p> 
 <p><strong>注意：</strong></p> 
 <p><strong>1、不能出现重复数字的票。</strong></p> 
 <p><strong>2、也不能出现负数的票。</strong></p> 
</blockquote> 
<pre><code class="language-java">public class TestDmo {
    public static void main(String[] args) {
        Window w = new Window();  //共用一个

        Thread t1 = new Thread(w);
        Thread t2 = new Thread(w);
        Thread t3 = new Thread(w); //创建三个线程

        t1.setName("窗口一");
        t2.setName("窗口二");
        t3.setName("窗口三");  //设置三个线程的名称

        t1.start();
        t2.start();
        t3.start();  //启动三个线程
    }
}

class Window implements Runnable{
    //属性
    private int ticket = 100;  //票数及票号

    //方法
    public void run() {  //实现Runnable中的抽象方法
        while(true){
            show();  //没有可以结束循环的条件，要手动结束
        }
    }
    private synchronized void show(){  //同步方法
        if(ticket&gt;0){
            System.out.println(Thread.currentThread().getName()+",票号："+ticket);
            ticket--;
        }
    }
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/55850cf2d1b551a42c3277ebc9371eaa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Fuzz-AFL入门</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c55c1cedf837b22ffc53ee6977ffa7fa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Strategy pattern</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>