<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一步一步写算法（之单向链表） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一步一步写算法（之单向链表）" />
<meta property="og:description" content="【 声明：版权所有，欢迎转载，请勿用于商业用途。 联系信箱：feixiaoxing @163.com】
有的时候，处于内存中的数据并不是连续的。那么这时候，我们就需要在数据结构中添加一个属性，这个属性会记录下面一个数据的地址。有了这个地址之后，所有的数据就像一条链子一样串起来了，那么这个地址属性就起到了穿线连结的作用。
相比较普通的线性结构，链表结构的优势是什么呢？我们可以总结一下：
（1）单个节点创建非常方便，普通的线性内存通常在创建的时候就需要设定数据的大小
（2）节点的删除非常方便，不需要像线性结构那样移动剩下的数据
（3）节点的访问方便，可以通过循环或者递归的方法访问到任意数据，但是平均的访问效率低于线性表
那么在实际应用中，链表是怎么设计的呢？我们可以以int数据类型作为基础，设计一个简单的int链表：
（1）设计链表的数据结构
typedef struct _LINK_NODE { int data; struct _LINK_NODE* next; }LINK_NODE; （2）创建链表 LINK_NODE* alloca_node(int value) { LINK_NODE* pLinkNode = NULL; pLinkNode = (LINK_NODE*)malloc(sizeof(LINK_NODE)); pLinkNode-&gt;data = value; pLinkNode-&gt;next = NULL; return pLinkNode; } （3）删除链表
void delete_node(LINK_NODE** pNode) { LINK_NODE** pNext; if(NULL == pNode || NULL == *pNode) return ; pNext = &amp;(*pNode)-&gt;next; free(*pNode); delete_node(pNext);	} （4）链表插入数据 STATUS _add_data(LINK_NODE** pNode, LINK_NODE* pDataNode) { if(NULL == *pNode){ *pNode = pDataNode; return TRUE; } return _add_data(&amp;(*pNode)-&gt;next, pDataNode); } STATUS add_data(const LINK_NODE** pNode, int value) { LINK_NODE* pDataNode; if(NULL == *pNode) return FALSE; pDataNode = alloca_node(value); assert(NULL !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5527832ce0f23b60aa34fbb4312f48a6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2011-10-07T13:05:00+08:00" />
<meta property="article:modified_time" content="2011-10-07T13:05:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一步一步写算法（之单向链表）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>【 声明：版权所有，欢迎转载，请勿用于商业用途。  联系信箱：feixiaoxing @163.com】</p> 
<p><br> </p> 
<p>    有的时候，处于内存中的数据并不是连续的。那么这时候，我们就需要在数据结构中添加一个属性，这个属性会记录下面一个数据的地址。有了这个地址之后，所有的数据就像一条链子一样串起来了，那么这个地址属性就起到了穿线连结的作用。</p> 
<p>    相比较普通的线性结构，链表结构的优势是什么呢？我们可以总结一下：</p> 
<p>    （1）单个节点创建非常方便，普通的线性内存通常在创建的时候就需要设定数据的大小</p> 
<p>    （2）节点的删除非常方便，不需要像线性结构那样移动剩下的数据</p> 
<p>    （3）节点的访问方便，可以通过循环或者递归的方法访问到任意数据，但是平均的访问效率低于线性表</p> 
<p>    那么在实际应用中，链表是怎么设计的呢？我们可以以int数据类型作为基础，设计一个简单的int链表：</p> 
<p>    <strong><span style="color:#000099"><span style="background-color:rgb(255,102,0)">（1）设计链表的数据结构</span></span></strong></p> 
<p></p> 
<pre><code class="language-cpp">typedef struct _LINK_NODE
{
    int data;
	struct _LINK_NODE* next;
}LINK_NODE;
</code></pre> 
<br>      
<strong><span style="color:#000099"><span style="background-color:rgb(255,102,0)">（2）创建链表</span></span></strong> 
<p></p> 
<p></p> 
<pre><code class="language-cpp">LINK_NODE* alloca_node(int value)
{
    LINK_NODE* pLinkNode = NULL;
	pLinkNode = (LINK_NODE*)malloc(sizeof(LINK_NODE));
	
	pLinkNode-&gt;data = value;
	pLinkNode-&gt;next = NULL;
	return pLinkNode;
}</code></pre> 
<p></p> 
<p>    <strong><span style="color:#000099"><span style="background-color:rgb(255,102,0)">（3）删除链表</span></span></strong></p> 
<p></p> 
<pre><code class="language-cpp">void delete_node(LINK_NODE** pNode)
{
    LINK_NODE** pNext;
    if(NULL == pNode || NULL == *pNode)
	    return ;
		
	pNext = &amp;(*pNode)-&gt;next;
	free(*pNode);
	delete_node(pNext);	
}</code></pre>     
<strong><span style="color:#000099"><span style="background-color:rgb(255,102,0)">（4）链表插入数据</span></span></strong> 
<p></p> 
<p></p> 
<pre><code class="language-cpp">STATUS _add_data(LINK_NODE** pNode, LINK_NODE* pDataNode)
{
    if(NULL == *pNode){
	    *pNode = pDataNode;
		return TRUE;
	}
	
	return _add_data(&amp;(*pNode)-&gt;next, pDataNode);
}

STATUS add_data(const LINK_NODE** pNode, int value)
{
    LINK_NODE* pDataNode;
    if(NULL == *pNode)
	    return FALSE;
		
	pDataNode = alloca_node(value);
	assert(NULL != pDataNode);
	return _add_data((LINK_NODE**)pNode, pDataNode);
}</code></pre>     
<strong><span style="color:#000099"><span style="background-color:rgb(255,102,0)">（5）删除数据</span></span></strong> 
<p></p> 
<pre><code class="language-cpp">STATUS _delete_data(LINK_NODE** pNode, int value)
{
    LINK_NODE* pLinkNode;
    if(NULL == (*pNode)-&gt;next)
	    return FALSE;
	
	pLinkNode = (*pNode)-&gt;next;
	if(value == pLinkNode-&gt;data){
	    (*pNode)-&gt;next = pLinkNode-&gt;next;
		free(pLinkNode);
		return TRUE;
	}else{
	    return _delete_data(&amp;(*pNode)-&gt;next, value);
	}
}

STATUS delete_data(LINK_NODE** pNode, int value)
{
    LINK_NODE* pLinkNode;
    if(NULL == pNode || NULL == *pNode)
	    return FALSE;

    if(value == (*pNode)-&gt;data){
	    pLinkNode = *pNode;
		*pNode = pLinkNode-&gt;next;
		free(pLinkNode);
		return TRUE;
	}		
	
	return _delete_data(pNode, value);
}</code></pre> 
<p></p>      
<strong><span style="color:#000099"><span style="background-color:rgb(255,102,0)">（6）查找数据</span></span></strong> 
<p></p> 
<p></p> 
<pre><code class="language-cpp">LINK_NODE* find_data(const LINK_NODE* pLinkNode, int value)
{
    if(NULL == pLinkNode)
	    return NULL;
	
	if(value == pLinkNode-&gt;data)
	    return (LINK_NODE*)pLinkNode;
	
	return find_data(pLinkNode-&gt;next, value);
}</code></pre>     
<strong><span style="color:#000099"><span style="background-color:rgb(255,102,0)">（7）打印数据</span></span></strong> 
<p></p> 
<p></p> 
<pre><code class="language-cpp">void print_node(const LINK_NODE* pLinkNode)
{
    if(pLinkNode){
	    printf("%d\n", pLinkNode-&gt;data);
		print_node(pLinkNode-&gt;next);
	}
}</code></pre>   
<span style="color:#000099"><span style="background-color:rgb(255,102,0)"> </span></span> 
<strong><span style="color:#000099"><span style="background-color:rgb(255,102,0)">（8）统计数据</span></span></strong> 
<p></p> 
<p></p> 
<pre><code class="language-cpp">int count_node(const LINK_NODE* pLinkNode)
{
    if(NULL == pLinkNode)
	    return 0;
		
	return 1 + count_node(pLinkNode-&gt;next);
}</code></pre> 
<br> 
<br> 
<p></p> 
<p><strong><span style="color:#000099"><span style="background-color:rgb(255,102,0)">【预告： 下一篇博客介绍双向链表】</span></span></strong></p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f402b3e5f2e7e19af02e06efe876947f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Workbench3.0-vxworks6.6仿真测试和调试指南</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/09fb81c9d55eb356be68461694abf479/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">小谈linux下实际用户ID，有效用户ID和设置用户ID</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>