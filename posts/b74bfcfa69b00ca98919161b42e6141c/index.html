<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Java抽象工厂模式（附实例代码）每天一学设计模式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Java抽象工厂模式（附实例代码）每天一学设计模式" />
<meta property="og:description" content="1.抽象工厂模式：提供一个创建一系列相关或者相互依赖的接口，而无需指定它们具体的类。
（1）AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。
（2）ConcreateFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。
（3）AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的的业务方法。
（4）ConcreteProduct（具体产品）：它定义了具体工厂生产的具体产品对象，实现了抽象产品接口中声明的业务方法。
/**抽象工厂可以使接口也可以是具体类或者抽象类*/ public interface AbstractFactory{ public AbstractProductA createProductA();//工厂方法一 public AbstractProductB createProductB();//工厂方法二 ··· } /**具体工厂类*/ public class ConcreateFactory1 extends AbstractFactory{ //工厂方法一 public AbstractProductA createProductA(){ return new ConcreteProductA1(); } //工厂方法二 public AbstractProductB createProductB(){ return new ConcreteProductB1(); } ``` } 2.代码实例描述：在做一个类似编辑器的软件，现编辑器有数字、字母、符号三种字符。可以根据需求给这三种字符切换成黑色或者红色。下面就是具体的代码实现。（添加新的字符和颜色更加方便）。
/**数字接口，充当抽象产品*/ public interface Digit { public void display(); } /**黑色数字类，充当具体产品*/ public class BlackDigit implements Digit { public void display(){ System.out.println(&#34;显示黑色数字&#34;); } } /**红色数字，充当具体产品*/ public class RedDigit implements Digit { public void display(){ System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b74bfcfa69b00ca98919161b42e6141c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-16T11:13:02+08:00" />
<meta property="article:modified_time" content="2022-02-16T11:13:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Java抽象工厂模式（附实例代码）每天一学设计模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>1.抽象工厂模式</strong>：提供一个创建一系列相关或者相互依赖的接口，而无需指定它们具体的类。</p> 
<p>（1）AbstractFactory（抽象工厂）：它声明了一组用于创建<strong>一族产品</strong>的方法，<strong>每一个方法对应一种产品</strong>。</p> 
<p>（2）ConcreateFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，<strong>每一个产品都位于某个产品等级结构</strong>中。</p> 
<p>（3）AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的的业务方法。</p> 
<p>（4）ConcreteProduct（具体产品）：它定义了具体工厂生产的具体产品对象，实现了抽象产品接口中声明的业务方法。</p> 
<pre><code class="language-java" style="background:rgb(36,40,47);">/**抽象工厂可以使接口也可以是具体类或者抽象类*/
public interface AbstractFactory{
    public AbstractProductA createProductA();//工厂方法一
    public AbstractProductB createProductB();//工厂方法二
    ···
}
/**具体工厂类*/
public class ConcreateFactory1 extends AbstractFactory{
    //工厂方法一
    public AbstractProductA createProductA(){
        return new ConcreteProductA1();
    }
    //工厂方法二
    public AbstractProductB createProductB(){
        return new ConcreteProductB1();
    }
    ```
}</code></pre> 
<p><strong>2.代码实例描述</strong>：在做一个类似编辑器的软件，现编辑器有数字、字母、符号三种字符。可以根据需求给这三种字符切换成黑色或者红色。下面就是具体的代码实现。（添加新的字符和颜色更加方便）。</p> 
<pre><code class="language-java" style="background:rgb(36,40,47);">/**数字接口，充当抽象产品*/
public interface Digit {
    public void display();
}
/**黑色数字类，充当具体产品*/
public class BlackDigit implements Digit {
    public void display(){
        System.out.println("显示黑色数字");
    }
}
/**红色数字，充当具体产品*/
public class RedDigit implements Digit {
    public void display(){
        System.out.println("显示红色数字");
    }
}
/**字母抽象产品*/
public interface Letter {
    public void display();
}
/**黑色字母，充当具体产品*/
public class BlackLetter implements Letter {
    public void display(){
        System.out.println("显示黑色字母");
    }
}
/**Summer文本框类，充当具体产品*/
public class RedLetter implements Letter {
    public void display(){
        System.out.println("显示红色子母");
    }
}
/**符号接口，充当抽象产品*/
public interface Mark {
    public void display();
}
/**黑色符号类，充当具体产品*/
public class BlackMark implements Mark {
    public void display(){
        System.out.println("显示黑色符号");
    }
}
/**红色符号类，充当具体产品*/
public class RedMark implements Mark {
    public void display(){
        System.out.println("显示红色符号");
    }
}
/**字体颜色工厂接口，充当抽象工厂*/
public interface ColourFactory {
    public Digit createDigit();
    public Letter createLetter();
    public Mark createMark();
}
/**黑色工厂，充当具体工厂*/
public class BlackColourFactory implements ColourFactory {
    public Digit createDigit(){
        return new BlackDigit();
    }
    public Letter createLetter(){
        return new BlackLetter();
    }
    public Mark createMark(){
        return new BlackMark();
    }
}
/**红色工厂，充当具体工厂*/
public class RedColourFactory implements ColourFactory {
    public Digit createDigit(){
        return new RedDigit();
    }
    public Letter createLetter(){
        return new RedLetter();
    }
    public Mark createMark(){
        return new RedMark();
    }
}
/**客户端测试类*/
public class Client{
     public static void main(String args[]){
        //使用抽象层定义
        ColourFactory factory;
        Digit dt;
        Letter lt;
        Mark mk;
        //factory=(SkinFactory)XMLUtil.getBean();//为了开闭原则，可以利用反射机制和xml资源获取得到想使用的界面类
        factory = new RedColourFactory();//想更换颜色可以在这里做修改
        dt = factory.createDigit();
        lt = factory.createLetter();
        mk = factory.createMark();
        dt.display();
        lt.display();
        mk.display();
    }
}</code></pre> 
<p>运行结果显示 </p> 
<p><img alt="" height="78" src="https://images2.imgbox.com/75/dc/wYwi7GHr_o.png" width="689"><strong> </strong></p> 
<p><strong>3.简单工厂模式、工厂模式和抽象工厂模式的主要不同之处。</strong></p> 
<p>简单工厂模式的工厂要负责<strong>多种产品的创建</strong>；工厂模式的工厂会有子工厂，每个子工厂对应<strong>创建一个产品</strong>；抽象工厂模式的工厂也有子工厂，但是子工厂可以<strong>创建一类产品</strong>。</p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9c9cb926bab2f9fd36ad13f2f06295c6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">为什么CommonJS和ES6可以混合使用?</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a9390c8f5d4399a7e71f7e3080d03f36/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Linux之常用的压缩解压缩命令</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>