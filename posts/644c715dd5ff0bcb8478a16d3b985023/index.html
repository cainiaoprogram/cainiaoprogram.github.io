<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【MSP430中断】MSP430的IO口中断/中断特性|Px中断进不去 原因 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【MSP430中断】MSP430的IO口中断/中断特性|Px中断进不去 原因" />
<meta property="og:description" content="目录
MSP430学习笔记之七：IO口中断
【端口中断进不去】Px中断进不去 原因 MSP430学习笔记之七：IO口中断 MSP430中断嵌套机制
(1) 430默认的是关闭中断嵌套的，除非你在一个中断程序中再次开总中断EINT。
(2) 当进入中断程序时，只要不在中断中再次开中断，总中断是关闭的，此时来中断不管是比当前中断的优先级高还是低都不执行。
(3)若在中断A中开了总中断，刚可以响应后来的中断B(不管B的优先级比A高还是低)，B执行完现继续执行。注意：进入中断B生总中断同样也会关闭，如果B中断程序执行时需响应中断C，则此时也要开总中断，若不需响应中断，则不用开中断，B执行完后中跳出中断程序进入A程序时，总中断会自动打开。
(4)若在中断中开了总中断，后来的中断同时有多个，则会按优先级来执行，即中断优先级只有在多个中断同时到来才起做用！中断服务不执行抢先原则。
(5)对于单源中断，只要响应中断，系统硬件自动清中断标志位，对于TA/TB定时器的比较/捕获中断，只要访问TAIV/TBIV，标志位倍被自动清除；对于多源中断要手动清标志位，比如P1/P2口中断，要手工清除相应的标志，如果在这种中断用“EINT()；”开中断，而在打开中断前没有清标志，就会有相同的中断不断嵌入，而导致堆栈溢出引起复位，所以在这类中断必须先清标志现打开中断开关。关于CPU部分我这次主要着重讲述下SR状态寄存器各位功能作用,对于C语言写已足够用了。另外还会补充一部单片机全局性的资料。
MSP430的中断分为3种：系统复位、不可屏蔽中断、可屏蔽中断。关于中断相关状态情况:
(1)系统复位的中断向量为0xFFFE。
(2)不可屏蔽中断的中断向量为0xFFFC。响应不可屏蔽中断时,硬件自动将OFIE、NMIE、ACCVIE复位。软件首先判断中断源并复位中断标志,接着执行用户代码。退出中断之前需要置位OFIE、NMIE、ACCVIE,以便能够再次响应中断。需要特别注意点：置位OFIE、NMIE、ACCVIE后,必须立即退出中断相应程序,否则会再次触发中断,导致中断嵌套,从而导致堆栈溢出,致使程序执行结果的无法预料。
(3)可屏蔽中断的中断来源于具有中断能力的外围模块,包括看门狗定时器工作在定时器模式时溢出产生的中断。每一个中断都可以被自己的中断控制位屏蔽,也可以由全局中断控制位屏蔽。多个中断请求发生时,响应最高优先级中断。响应中断时,MSP430会将不可屏蔽中断控制位SR.GIE复位。因此,一旦响应了中断,即使有优先级更高的可屏蔽中断出现,也不会中断当前正在响应的中断,去响应另外的中断。但SR.GIE复位不影响不可屏蔽中断,所以仍可以接受不可屏蔽中断的中断请求。
中断响应的过程：
(1)如果CPU处于活动状态,则完成当前指令;
(2)若CPU处于低功耗状态,则退出低功耗状态;
(3)将下一条指令的PC值压入堆栈;
(4)将状态寄存器SR压入堆栈;
(5)若有多个中断请求,响应最高优先级中断;
(6)单中断源的中断请求标志位自动复位,多中断源的标志位不变,等待软件复位;
(7)总中断允许位SR.GIE复位。SR状态寄存器中的CPUOFF、OSCOFF、SCG1、V、N、Z、C位复位;
(8)相应的中断向量值装入PC寄存器,程序从此地址开始执行。
中断返回的过程：
(1)从堆栈中恢复PC值,若响应中断前CPU处于低功耗模式,则可屏蔽中断仍然恢复低功耗模式;
(2)从堆栈中恢复PC值,若响应中断前CPU不处于低功耗模式,则从此地址继续执行程序。
下面又是个简单例程：
#include &#34;msp430.h&#34;
int main(void)
{
WDTCTL = WDTPW &#43; WDTHOLD; // Stop watchdog timer
P1DIR |= 0x01; // Set P1.0 to output direction
P2DIR = 0; //set P2 is input all
P2IE = 0xFF; //the P2 interrupt is enable" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/644c715dd5ff0bcb8478a16d3b985023/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-04T01:31:00+08:00" />
<meta property="article:modified_time" content="2022-10-04T01:31:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【MSP430中断】MSP430的IO口中断/中断特性|Px中断进不去 原因</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body blogpost-body-html" style="font-size: 16px;"> 
 <div id="sina_keyword_ad_area2"> 
  <p id="main-toc"><strong>目录</strong></p> 
  <p id="MSP430%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%83%EF%BC%9AIO%E5%8F%A3%E4%B8%AD%E6%96%AD-toc"><a href="#MSP430%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%83%EF%BC%9AIO%E5%8F%A3%E4%B8%AD%E6%96%AD" rel="noopener">MSP430学习笔记之七：IO口中断</a></p> 
  <p id="%E3%80%90%E7%AB%AF%E5%8F%A3%E4%B8%AD%E6%96%AD%E8%BF%9B%E4%B8%8D%E5%8E%BB%E3%80%91Px%E4%B8%AD%E6%96%AD%E8%BF%9B%E4%B8%8D%E5%8E%BB%20%E5%8E%9F%E5%9B%A0%C2%A0-toc"><a href="#%E3%80%90%E7%AB%AF%E5%8F%A3%E4%B8%AD%E6%96%AD%E8%BF%9B%E4%B8%8D%E5%8E%BB%E3%80%91Px%E4%B8%AD%E6%96%AD%E8%BF%9B%E4%B8%8D%E5%8E%BB%20%E5%8E%9F%E5%9B%A0%C2%A0" rel="noopener">【端口中断进不去】Px中断进不去 原因 </a></p> 
  <hr id="hr-toc"> 
  <h2 id="MSP430%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B9%8B%E4%B8%83%EF%BC%9AIO%E5%8F%A3%E4%B8%AD%E6%96%AD">MSP430学习笔记之七：IO口中断</h2> 
  <div> 
   <p>MSP430中断嵌套机制</p> 
   <p>(1) 430默认的是关闭中断嵌套的，除非你在一个中断程序中再次开总中断EINT。</p> 
   <p>(2) 当进入中断程序时，只要不在中断中再次开中断，总中断是关闭的，此时来中断不管是比当前中断的优先级高还是低都不执行。</p> 
   <p>(3)若在中断A中开了总中断，刚可以响应后来的中断B(不管B的优先级比A高还是低)，B执行完现继续执行。注意：进入中断B生总中断同样也会关闭，如果B中断程序执行时需响应中断C，则此时也要开总中断，若不需响应中断，则不用开中断，B执行完后中跳出中断程序进入A程序时，总中断会自动打开。</p> 
   <p> (4)若在中断中开了总中断，后来的中断同时有多个，则会按优先级来执行，即中断优先级只有在多个中断同时到来才起做用！中断服务不执行抢先原则。</p> 
   <p>(5)对于单源中断，只要响应中断，系统硬件自动清中断标志位，对于TA/TB定时器的比较/捕获中断，只要访问TAIV/TBIV，标志位倍被自动清除；对于多源中断要手动清标志位，比如P1/P2口中断，要手工清除相应的标志，如果在这种中断用“EINT()；”开中断，而在打开中断前没有清标志，就会有相同的中断不断嵌入，而导致堆栈溢出引起复位，所以在这类中断必须先清标志现打开中断开关。关于CPU部分我这次主要着重讲述下SR状态寄存器各位功能作用,对于C语言写已足够用了。另外还会补充一部单片机全局性的资料。</p> 
   <p>MSP430的中断分为3种：系统复位、不可屏蔽中断、可屏蔽中断。关于中断相关状态情况:</p> 
   <p> (1)系统复位的中断向量为0xFFFE。</p> 
   <p> (2)不可屏蔽中断的中断向量为0xFFFC。响应不可屏蔽中断时,硬件自动将OFIE、NMIE、ACCVIE复位。软件首先判断中断源并复位中断标志,接着执行用户代码。退出中断之前需要置位OFIE、NMIE、ACCVIE,以便能够再次响应中断。需要特别注意点：置位OFIE、NMIE、ACCVIE后,必须立即退出中断相应程序,否则会再次触发中断,导致中断嵌套,从而导致堆栈溢出,致使程序执行结果的无法预料。</p> 
   <p> (3)可屏蔽中断的中断来源于具有中断能力的外围模块,包括看门狗定时器工作在定时器模式时溢出产生的中断。每一个中断都可以被自己的中断控制位屏蔽,也可以由全局中断控制位屏蔽。多个中断请求发生时,响应最高优先级中断。响应中断时,MSP430会将不可屏蔽中断控制位SR.GIE复位。因此,一旦响应了中断,即使有优先级更高的可屏蔽中断出现,也不会中断当前正在响应的中断,去响应另外的中断。但SR.GIE复位不影响不可屏蔽中断,所以仍可以接受不可屏蔽中断的中断请求。</p> 
   <p>中断响应的过程：</p> 
   <p> (1)如果CPU处于活动状态,则完成当前指令;</p> 
   <p> (2)若CPU处于低功耗状态,则退出低功耗状态;</p> 
   <p> (3)将下一条指令的PC值压入堆栈;</p> 
   <p> (4)将状态寄存器SR压入堆栈;</p> 
   <p> (5)若有多个中断请求,响应最高优先级中断;</p> 
   <p>(6)单中断源的中断请求标志位自动复位,多中断源的标志位不变,等待软件复位;</p> 
   <p> (7)总中断允许位SR.GIE复位。SR状态寄存器中的CPUOFF、OSCOFF、SCG1、V、N、Z、C位复位;</p> 
   <p> (8)相应的中断向量值装入PC寄存器,程序从此地址开始执行。</p> 
   <p>中断返回的过程：</p> 
   <p>(1)从堆栈中恢复PC值,若响应中断前CPU处于低功耗模式,则可屏蔽中断仍然恢复低功耗模式;</p> 
   <p>(2)从堆栈中恢复PC值,若响应中断前CPU不处于低功耗模式,则从此地址继续执行程序。</p> 
   <p>下面又是个简单例程：</p> 
   <p>#include "msp430.h"<br> int main(void)<br> {<!-- --><br>   WDTCTL = WDTPW + WDTHOLD;             // Stop watchdog timer<br>   P1DIR |= 0x01;                        // Set P1.0 to output direction<br>   P2DIR = 0;                            //set P2 is input all<br>   P2IE = 0xFF;                          //the P2 interrupt is enable<br>   P2OUT = 0xFF;                         //let the p2 is high<br>   _BIS_SR(LPM3_bits + GIE); //进入LPM3模式/ 开中断允许<br>   while(1)<br>   {<!-- --><br>     P2OUT = 0xFF;   //保持高电平<br>   }<br> }</p> 
   <p>#pragma vector=PORT2_VECTOR<br> __interrupt void PORT2 (void)<br> {<!-- --><br>      P1OUT ^= 0x01;                      // Toggle P1.0 using exclusive-OR<br>      P2IFG = 0;                          //clear the interrupt flag<br> }</p> 
   <p>这个例程，在USBFET仿真上跑起很好玩，按下灭，再按下亮</p> 
   <p><a href="http://bbs.eeworld.com.cn/thread-247917-1-1.html" rel="noopener" title="MSP430学习笔记之七：IO口中断 - 微控制器 MCU -  电子工程世界-论坛">MSP430学习笔记之七：IO口中断 - 微控制器 MCU - 电子工程世界-论坛</a></p> 
  </div> 
 </div> 
 <h2 id="%E3%80%90%E7%AB%AF%E5%8F%A3%E4%B8%AD%E6%96%AD%E8%BF%9B%E4%B8%8D%E5%8E%BB%E3%80%91Px%E4%B8%AD%E6%96%AD%E8%BF%9B%E4%B8%8D%E5%8E%BB%20%E5%8E%9F%E5%9B%A0%C2%A0">【端口中断进不去】Px中断进不去 原因 </h2> 
 <p>    今天，调试程序，P2.0的端口中断老是进不去，或者是进去之后就跑飞，查了一下P2IN 发现P2的0口一直是低电平，分析因此中断是进不去的，或者进去之后中断一直存在，所以出不来。经检查，发现P2.0 处于悬空状态，没有接上拉电阻！！！ 因此P2.0的电平不确定或者处于低电平状态，无法产生上升沿或者下降沿。</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e28cd8ac76fb91a1e9cbd7fbe5e1d4fe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【物联网】AT指令|AT返回错误|AT 指令 收发短信和GPRS上网 SIM508/548</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/92a2ccf3063f904ed85c4fc81c261b5c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【IAR 】MSP430 IAR 编译报错：error</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>