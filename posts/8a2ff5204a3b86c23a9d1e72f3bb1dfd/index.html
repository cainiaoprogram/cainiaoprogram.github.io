<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>@Mock和@InjectMocks之间的区别 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="@Mock和@InjectMocks之间的区别" />
<meta property="og:description" content="本文翻译自：Difference between @Mock and @InjectMocks
Mockito框架中的@Mock和@InjectMocks什么区别？ #1楼 参考：https://stackoom.com/question/175zp/Mock和-InjectMocks之间的区别
#2楼 @Mock creates a mock. @Mock创建了一个模拟。 @InjectMocks creates an instance of the class and injects the mocks that are created with the @Mock (or @Spy ) annotations into this instance. @InjectMocks创建该类的实例，并将使用@Mock （或@Spy ）注释创建的@Spy注入此实例。 Note that you must use @RunWith(MockitoJUnitRunner.class) or Mockito.initMocks(this) to initialize these mocks and inject them. 请注意，您必须使用@RunWith(MockitoJUnitRunner.class)或Mockito.initMocks(this)来初始化这些Mockito.initMocks(this)并注入它们。 @RunWith(MockitoJUnitRunner.class) public class SomeManagerTest { @InjectMocks private SomeManager someManager; @Mock private SomeDependency someDependency; // this will be injected into someManager //tests." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8a2ff5204a3b86c23a9d1e72f3bb1dfd/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-05-29T17:00:27+08:00" />
<meta property="article:modified_time" content="2020-05-29T17:00:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">@Mock和@InjectMocks之间的区别</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本文翻译自：<a href="https://oldbug.net/q/175zp/Difference-between-Mock-and-InjectMocks" rel="nofollow">Difference between @Mock and @InjectMocks</a></p> 
<p> Mockito框架中的<code>@Mock</code>和<code>@InjectMocks</code>什么区别？ </p> 
<hr> 
<h4>#1楼</h4> 
<p>参考：<a href="https://stackoom.com/question/175zp/Mock%E5%92%8C-InjectMocks%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">https://stackoom.com/question/175zp/Mock和-InjectMocks之间的区别</a></p> 
<hr> 
<h4>#2楼</h4> 
<p> <i><code>@Mock</code> creates a mock.</i> <b><code>@Mock</code>创建了一个模拟。</b> <i><code>@InjectMocks</code> creates an instance of the class and injects the mocks that are created with the <code>@Mock</code> (or <code>@Spy</code> ) annotations into this instance.</i> <b><code>@InjectMocks</code>创建该类的实例，并将使用<code>@Mock</code> （或<code>@Spy</code> ）注释创建的<code>@Spy</code>注入此实例。</b> </p> 
<p> <i>Note that you must use <code>@RunWith(MockitoJUnitRunner.class)</code> or <code>Mockito.initMocks(this)</code> to initialize these mocks and inject them.</i> <b>请注意，您必须使用<code>@RunWith(MockitoJUnitRunner.class)</code>或<code>Mockito.initMocks(this)</code>来初始化这些<code>Mockito.initMocks(this)</code>并注入它们。</b> </p> 
<pre><code>@RunWith(MockitoJUnitRunner.class)
public class SomeManagerTest {

    @InjectMocks
    private SomeManager someManager;

    @Mock
    private SomeDependency someDependency; // this will be injected into someManager

     //tests...

}
</code></pre> 
<hr> 
<h4>#3楼</h4> 
<p> <i><code>@Mock</code> annotation mocks the concerned object.</i> <b><code>@Mock</code>注释嘲笑有关对象。</b> </p> 
<p> <i><code>@InjectMocks</code> annotation allows to inject into the underlying object the different (and relevant) mocks created by <code>@Mock</code> .</i> <b><code>@InjectMocks</code>注释允许向底层对象注入由<code>@Mock</code>创建的不同（和相关） <code>@Mock</code> 。</b> </p> 
<p> <i><strong>Both are complementary.</strong></i> <b><strong>两者都是互补的。</strong></b> </p> 
<hr> 
<h4>#4楼</h4> 
<p> <i>A "mocking framework", which Mockito is based on, is a framework that gives you the ability to create Mock objects ( in old terms these objects could be called shunts, as they work as shunts for dependend functionality ) In other words, a mock object is used to imitate the real object your code is dependend on, you create a proxy object with the mocking framework.</i> <b>Mockito所基于的“模拟框架”是一个框架，它使您能够创建Mock对象（用旧的术语来说，这些对象可以被称为分流器，因为它们可以作为依赖功能的分流器）换句话说，一个模拟object用于模仿代码所依赖的真实对象，使用模拟框架创建代理对象。</b> <i>By using mock objects in your tests you are essentially going from normal unit testing to integrational testing</i> <b>通过在测试中使用模拟对象，您实际上是从正常的单元测试到集成测试</b> </p> 
<p> <i>Mockito is an open source testing framework for Java released under the MIT License, it is a "mocking framework", that lets you write beautiful tests with clean and simple API.</i> <b>Mockito是一个在MIT许可下发布的Java开源测试框架，它是一个“模拟框架”，可以让你用干净简单的API编写漂亮的测试。</b> <i>There are many different mocking frameworks in the Java space, however there are essentially two main types of mock object frameworks, ones that are implemented via proxy and ones that are implemented via class remapping.</i> <b>Java空间中有许多不同的模拟框架，但基本上有两种主要类型的模拟对象框架，一种是通过代理实现的，另一种是通过类重映射实现的。</b> </p> 
<p> <i>Dependency injection frameworks like Spring allow you to inject your proxy objects without modifying any code, the mock object expects a certain method to be called and it will return an expected result.</i> <b>像Spring这样的依赖注入框架允许您在不修改任何代码的情况下注入代理对象，模拟对象期望调用某个方法并返回预期结果。</b> </p> 
<p> <i>The <code>@InjectMocks</code> annotation tries to instantiate the testing object instance and injects fields annotated with <code>@Mock</code> or <code>@Spy</code> into private fields of the testing object.</i> <b><code>@InjectMocks</code>批注尝试实例化测试对象实例，并将带有<code>@Mock</code>或<code>@Spy</code>注释的字段注入测试对象的私有字段。</b> </p> 
<p> <i><code>MockitoAnnotations.initMocks(this)</code> call, resets testing object and re-initializes mocks, so remember to have this at your <code>@Before</code> / <code>@BeforeMethod</code> annotation.</i> <b><code>MockitoAnnotations.initMocks(this)</code>调用，重置测试对象并重新初始化模拟，所以请记住在<code>@Before</code> / <code>@BeforeMethod</code>注释中使用它。</b> </p> 
<hr> 
<h4>#5楼</h4> 
<p> <i>One advantage you get with the approach mentioned by @Tom is that you don't have to create any constructors in the SomeManager, and hence limiting the clients to instantiate it.</i> <b>使用@Tom提到的方法获得的一个优点是您不必在SomeManager中创建任何构造函数，因此限制客户端实例化它。</b> </p> 
<pre><code>@RunWith(MockitoJUnitRunner.class)
public class SomeManagerTest {

    @InjectMocks
    private SomeManager someManager;

    @Mock
    private SomeDependency someDependency; // this will be injected into someManager

    //You don't need to instantiate the SomeManager with default contructor at all
   //SomeManager someManager = new SomeManager();    
   //Or SomeManager someManager = new SomeManager(someDependency);

     //tests...

}
</code></pre> 
<p> <i>Whether its a good practice or not depends on your application design.</i> <b>是否良好实践取决于您的应用程序设计。</b> </p> 
<hr> 
<h4>#6楼</h4> 
<p> <i>In your test class, the tested class should be annotated with <code>@InjectMocks</code> .</i> <b>在测试类中，测试类应使用<code>@InjectMocks</code>进行注释。</b> <i>This tells Mockito which class to inject mocks into:</i> <b>这告诉Mockito哪个类注入模拟：</b> </p> 
<pre><code>@InjectMocks
private SomeManager someManager;
</code></pre> 
<p> <i>From then on, we can specify which specific methods or objects inside the class, in this case, <code>SomeManager</code> , will be substituted with mocks:</i> <b>从那时起，我们可以指定类中的哪些特定方法或对象，在本例中， <code>SomeManager</code>将被mocks替换：</b> </p> 
<pre><code>@Mock
private SomeDependency someDependency;
</code></pre> 
<p> <i>In this example, <code>SomeDependency</code> inside the <code>SomeManager</code> class will be mocked.</i> <b>在这个例子中， <code>SomeDependency</code>里面<code>SomeManager</code>类将被嘲笑。</b> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f7ea56d35da025b45df2091b1d30874b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">查找重复元素</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e282c7a0ea444dce3d9f8cb8e3608708/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Python实验：循环结构程序设计、字符串的应用、列表与元组的应用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>