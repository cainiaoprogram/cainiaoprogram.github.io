<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux Strace命令 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux Strace命令" />
<meta property="og:description" content="一 What strace: 是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互、例如：系统调用、信号传递、进程状态变更等。
strace底层使用内核的ptrace 特性来实现其功能。
在故障处理和问题诊断过程中，strace作为一种动态跟踪工具，能够帮助高效地定位进程和服务故障，它像是一个侦探，通过系统调用的过程，使你知道真相。
二 Why ① 通过strace 启动要跟踪的进程。
在执行想要执行的命令前加上strace就好。例如：想要跟踪 &#34;ls -lh /var/log/messages&#34; 命令的执行过程，则
strace ls -lh /var/log/messages ② 跟踪已经在运行的进程，在不中断进程执行的情况下，追踪它在做什么；这时在执行 strace -p pid 例如当前存在some_server 进程再执行，则先查看该进程的pid，
pidof some_server 17558 执行 strace 命令进行跟踪：
strace -p 17558 完成跟踪时，执行 Ctrl&#43;C 即可结束strace。
strace命令的参数：
option: -tt：在每行输出的前面，显示毫秒级别的时间 -T：显示每次系统调用所花费的时间 -v：对于某些相关调用，把完整的环境变量，文件 stat 结构等打出来。 -f：跟踪目标进程，以及目标进程创建的所有子进程 -e：控制要跟踪的事件和跟踪行为，比如指定要跟踪的系统调用名称 -o：把 strace 的输出单独写到指定的文件 -s：当系统调用的某个参数是字符串时，最多输出指定长度的内容，默认是 32 个字节 -p：指定要跟踪的进程 pid，要同时跟踪多个 pid，重复多次 -p 选项即可。 三 How 1、定位进程异常退出
问题：机器上有个叫做run.sh的常驻脚本，运行一分钟后会死掉。需要查出死因。
定位：进程还在运行时，通过ps命令获取其pid, 假设我们得到的pid是24298
strace -o strace.log -tt -p 24298 查看 strace." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a0a802a2946ea5abda63f809fe3c7e31/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-05T15:00:37+08:00" />
<meta property="article:modified_time" content="2023-10-05T15:00:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux Strace命令</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一 What</h2> 
<p>strace: 是一个可用于诊断、调试和教学的Linux用户空间跟踪器。我们用它来监控用户空间进程和内核的交互、例如：系统调用、信号传递、进程状态变更等。</p> 
<p>strace底层使用内核的ptrace 特性来实现其功能。</p> 
<p>在故障处理和问题诊断过程中，strace作为一种动态跟踪工具，能够帮助高效地定位进程和服务故障，它像是一个侦探，通过系统调用的过程，使你知道真相。</p> 
<h2>二 Why</h2> 
<p>① 通过strace 启动要跟踪的进程。</p> 
<p>在执行想要执行的命令前加上strace就好。例如：想要跟踪 "ls -lh /var/log/messages"  命令的执行过程，则</p> 
<pre><code class="language-bash">strace ls -lh /var/log/messages</code></pre> 
<p>② 跟踪已经在运行的进程，在不中断进程执行的情况下，追踪它在做什么；这时在执行 <span style="background-color:#cccccc;">strace -p pid </span> 例如当前存在some_server  进程再执行，则先查看该进程的pid，</p> 
<pre><code class="language-bash">pidof some_server                      
17558</code></pre> 
<p>执行 <span style="background-color:#cccccc;">strace </span> 命令进行跟踪：</p> 
<pre><code class="language-bash">strace -p 17558</code></pre> 
<p>完成跟踪时，执行 <span style="background-color:#cccccc;">Ctrl+C</span> 即可结束strace。</p> 
<p>strace命令的参数：</p> 
<pre><code class="language-bash">option:
-tt：在每行输出的前面，显示毫秒级别的时间
-T：显示每次系统调用所花费的时间
-v：对于某些相关调用，把完整的环境变量，文件 stat 结构等打出来。
-f：跟踪目标进程，以及目标进程创建的所有子进程
-e：控制要跟踪的事件和跟踪行为，比如指定要跟踪的系统调用名称
-o：把 strace 的输出单独写到指定的文件
-s：当系统调用的某个参数是字符串时，最多输出指定长度的内容，默认是 32 个字节
-p：指定要跟踪的进程 pid，要同时跟踪多个 pid，重复多次 -p 选项即可。</code></pre> 
<h2>三 How</h2> 
<p>1、定位进程异常退出</p> 
<p>问题：机器上有个叫做run.sh的常驻脚本，运行一分钟后会死掉。需要查出死因。</p> 
<p>定位：进程还在运行时，通过ps命令获取其pid, 假设我们得到的pid是24298</p> 
<pre><code>strace -o strace.log -tt -p 24298</code></pre> 
<p> 查看 strace.log，我们在最后 2 行看到如下内容:</p> 
<pre><code class="language-bash">22:47:42.803937 wait4(-1,  &lt;unfinished ...&gt;

22:47:43.228422 +++ killed by SIGKILL +++</code></pre> 
<p>这里可以看出，进程是被其他进程用 KILL 信号杀死的。</p> 
<p>实际上，通过分析，我们发现机器上别的服务有个监控脚本，它监控一个也叫做 run.sh 的进程，当发现 run.sh 进程数大于 2 时，就会把它杀死重启。结果导致我们这个 run.sh 脚本被误杀。</p> 
<p>进程被杀退出时，strace 会输出 killed by SIGX（SIGX 代表发送给进程的信号）等，那么，进程自己退出时会输出什么呢？</p> 
<p>这里有个叫做 test_exit 的程序，其代码如下:</p> 
<pre><code class="language-cpp">#include &lt;stdio.h&gt;

#include &lt;stdlib.h&gt;


int main(int argc, char **argv) {

exit(1);

}</code></pre> 
<p>我们 strace 看下它退出时 strace 上能看到什么痕迹。 </p> 
<pre><code class="language-bash">strace -tt -e trace=process -f ./test_exit</code></pre> 
<p>说明: -e trace=process 表示只跟踪和进程管理相关的系统调用。</p> 
<p>输出：</p> 
<blockquote> 
 <pre>23:07:24.672849 execve("./test_exit", ["./test_exit"], [/* 35 vars */]) = 0
23:07:24.674665 arch_prctl(ARCH_SET_FS, 0x7f1c0eca7740) = 0
23:07:24.675108 exit_group(1)           = ?
23:07:24.675259 +++ exited with 1 +++</pre> 
</blockquote> 
<p>可以看出，进程自己退出时（调用 exit 函数，或者从 main 函数返回）, 最终调用的是 exit_group 系统调用， 并且 strace 会输出 exited with X（X为退出码）。</p> 
<p>可能有人会疑惑，代码里面明明调用的是 exit，怎么显示为 exit_group?</p> 
<blockquote> 
 <p>这是因为这里的 exit 函数不是系统调用，而是 glibc 库提供的一个函数，exit 函数的调用最终会转化为 exit_group 系统调用，它会退出当前进程的所有线程。实际上，有一个叫做 _exit()的系统调用（注意 exit 前面的下划线)，线程退出时最终会调用它。</p> 
</blockquote> 
<p>2、定位共享内存异常</p> 
<p>有个服务启动时报错：</p> 
<pre><code class="language-bash">shmget 267264 30097568: Invalid argument

Can not get shm...exit!</code></pre> 
<p>错误日志大概告诉我们是获取共享内存出错，通过 strace 看下： </p> 
<pre><code class="language-bash">strace -tt -f -e trace=ipc ./a_mon_svr     ../conf/a_mon_svr.conf</code></pre> 
<p>输出： </p> 
<ol><li> <p><code>22:46:36.351798 shmget(0x5feb, 12000, 0666) = 0</code></p> </li><li> <p><code>22:46:36.351939 shmat(0, 0, 0) = ?</code></p> </li><li> <p><code>Process 21406 attached</code></p> </li><li> <p><code>22:46:36.355439 shmget(0x41400, 30097568, 0666) = -1 EINVAL (Invalid argument)</code></p> </li><li> <p><code>shmget 267264 30097568: Invalid argument</code></p> </li><li> <p><code>Can not get shm...exit!</code></p> </li></ol> 
<p>这里，我们通过 -e trace=ipc 选项，让 strace 只跟踪和进程通信相关的系统调用。</p> 
<p>从 strace 输出，我们知道是 shmget 系统调用出错了，errno 是 EINVAL。同样， 查询下 shmget 手册页，搜索 EINVAL 的错误码的说明:</p> 
<blockquote> 
 <p> EINVAL A new segment was to be created and size &lt; SHMMIN or size &gt; SHMMAX, or no new segment was to be created, a segment with given key existed, but size is greater than the size of that segment</p> 
</blockquote> 
<p>翻译下，shmget 设置 EINVAL 错误码的原因为下列之一：</p> 
<ul><li> <p>要创建的共享内存段比 SHMMIN 小 (一般是1个字节)</p> </li><li> <p>要创建的共享内存段比 SHMMAX 大 (内核参数 kernel.shmmax 配置)</p> </li><li> <p>指定 key 的共享内存段已存在，其大小和调用 shmget 时传递的值不同。</p> </li></ul> 
<p>从 strace 输出看，我们要连的共享内存 key 0x41400，指定的大小是 30097568 字节，明显与第1、2 种情况不匹配。那只剩下第三种情况。使用 ipcs 看下是否真的是大小不匹配：</p> 
<blockquote> 
 <p></p> 
 <pre>ipcs  -m | grep 41400
key        shmid      owner      perms      bytes      nattch     status    
0x00041400 1015822    root       666        30095516   1</pre> 
</blockquote> 
<p>可以看到，已经 0x41400 这个 key 已经存在，并且其大小为 30095516 字节，和我们调用参数中的 30097568 不匹配，于是产生了这个错误。</p> 
<p>在我们这个案例里面，导致共享内存大小不一致的原因，是一组程序中，其中一个编译为32位，另外一个编译为64位,代码里面使用了long这个变长int数据类型。</p> 
<blockquote> 
 <p>把两个程序都编译为64解决了这个问题。</p> 
</blockquote> 
<p>这里特别说下 strace 的 -e trace 选项。</p> 
<p>要跟踪某个具体的系统调用，-e trace=xxx 即可。但有时候我们要跟踪一类系统调用，比如所有和文件名有关的调用、所有和内存分配有关的调用。</p> 
<p>如果人工输入每一个具体的系统调用名称，可能容易遗漏。于是strace提供了几类常用的系统调用组合名字。</p> 
<blockquote> 
 <p>-e trace=file     跟踪和文件访问相关的调用(参数中有文件名)<br> -e trace=process  和进程管理相关的调用，比如fork/exec/exit_group<br> -e trace=network  和网络通信相关的调用，比如socket/sendto/connect<br> -e trace=signal    信号发送和处理相关，比如kill/sigaction<br> -e trace=desc  和文件描述符相关，比如write/read/select/epoll等<br> -e trace=ipc 进程见同学相关，比如shmget等</p> 
</blockquote> 
<p>绝大多数情况，我们使用上面的组合名字就够了。实在需要跟踪具体的系统调用时，可能需要注意C 库实现的差异。</p> 
<blockquote> 
 <p>比如我们知道创建进程使用的是 fork 系统调用，但在 glibc 里面，fork 的调用实际上映射到了更底层的 clone 系统调用。使用 strace 时，得指定 -e trace=clone，指定 -e trace=fork 什么也匹配不上。</p> 
</blockquote> 
<p>3、 性能分析</p> 
<p>假如有个需求，统计 Linux 4.5.4 版本内核中的代码行数（包含汇编和 C 代码）。这里提供两个Shell 脚本实现：</p> 
<p>poor_script.sh:</p> 
<ol><li> <p><code>!/bin/bash</code></p> </li><li> <p><code>total_line=0</code></p> </li><li> <p><code>while read filename; do</code></p> </li><li> <p><code>line=$(wc -l $filename | awk ‘{print $1}’)</code></p> </li><li> <p><code>(( total_line += line ))</code></p> </li><li> <p><code>done &lt; &lt;( find linux-4.5.4 -type f ( -iname ‘.c’ -o -iname ‘.h’ -o -iname ‘*.S’ ) )</code></p> </li><li> <p><code>echo “total line: $total_line”</code></p> </li><li></ol> 
<p>good_script.sh: </p> 
<ol><li> <p><code>!/bin/bash</code></p> </li><li> <p><code>find linux-4.5.4 -type f ( -iname ‘.c’ -o -iname ‘.h’ -o -iname ‘*.S’ ) -print0 \</code></p> </li><li> <p><code>| wc -l —files0-from - | tail -n 1</code></p> </li></ol> 
<p>两段代码实现的目的是一样的。 我们通过 strace 的 -c 选项来分别统计两种版本的系统调用情况和其所花的时间（使用 -f 同时统计子进程的情况）</p> 
<p>从两个输出可以看出，good_script.sh 只需要 2 秒就可以得到结果：19613114 行。它大部分的调用（calls）开销是文件操作（read/open/write/close）等，统计代码行数本来就是干这些事情。</p> 
<p>而 poor_script.sh 完成同样的任务则花了 539 秒。它大部分的调用开销都在进程和内存管理上(wait4/mmap/getpid…)。</p> 
<p>实际上，从两个图中 clone 系统调用的次数，我们可以看出 good_script.sh 只需要启动 3 个进程，而 poor_script.sh 完成整个任务居然启动了 126335 个进程！</p> 
<p>而进程创建和销毁的代价是相当高的，性能不差才怪。</p> 
<h2><a name="t4"></a>四 总结</h2> 
<p>当发现进程或服务异常时，我们可以通过 strace 来跟踪其系统调用，“看看它在干啥”，进而找到异常的原因。熟悉常用系统调用，能够更好地理解和使用strace。</p> 
<p>当然，万能的 strace 也不是真正的万能。当目标进程卡死在用户态时，strace 就没有输出了。</p> 
<p>这个时候我们需要其他的跟踪手段，比如 gdb / perf / SystemTap 等。</p> 
<p>备注：</p> 
<p>1、perf 原因 kernel 支持</p> 
<p>2、ftrace  kernel 支持可编程</p> 
<p>3、systemtap 功能强大，<a href="http://www.linuxidc.com/topicnews.aspx?tid=10" rel="nofollow" title="RedHat">RedHat</a> 系统支持，对用户态，内核态逻辑都能探查，使用范围更广。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e19bfae3baabd9b18c98adcad816f8f3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于微信小程序的付费自习室</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3eaa13255ca881b69098715328a0fa3d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CentOS 7 设置swap分区 (内存置换空间)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>