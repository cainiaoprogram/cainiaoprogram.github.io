<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入理解Java虚拟机高级特性与最佳实践 - 全国统一考试试卷(下) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深入理解Java虚拟机高级特性与最佳实践 - 全国统一考试试卷(下)" />
<meta property="og:description" content="本文整理自 深入理解Java虚拟机：JVM高级特性与最佳实践 – 周志明
第三部分 高效并发 物理机对并发的处理方案对于虚拟机的并发实现有相当大的参考意义。计算机的存储设备的运算速度与处理器的运算速度，有几个数量级的差距，所以现代计算机系统不得不加入一层读写速度尽可能接近处理器运算速度的高度缓存(Cache)来作为内存与处理器之间的缓冲。
工作原理如下：
将运算需要使用到的数据复制到缓存中，让运算能够快速进行运算结束后，再从缓存同步回内存之中。 Num 1：缓存一致性 在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存(Main Memory)。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，如果真出现此情况，那同步到主内存的数据以谁的缓存数据为准呢？为了解决这个缓存一致性的问题，需要各个处理器读写访问缓存时按照协议约定进行操作。这些协议包括但不限于：MSI、MESI、MOSI、Synapse、Firefly及Dragon Protocol等。不同架构下的物理机器使用不一样的缓存一致性协议，也就拥有不一样的内存模型。
Num 2：Java 内存模型的由来 C/C&#43;&#43;：直接使用物理硬件和操作系统的内存模型。由于不同操作系统平台上内存模型的差异，因此，运行结果也不同。
Java：Java虚拟机试图定义一种内存模型规范来屏蔽各种硬件、操作系统的内存访问差异，以实现让Java程序在各种平台上，都能达到一致的内存访问效果。
问题 1 Java 内存模型的英文简称是： 1 。
A：Java Working Memory,JWMB：Java Main Memory,JMMC ：Java Memory Model,JMM Num 3：Java 内存模型 Java 内存模型的主要目标是定义程序中各变量的访问规则，即：在虚拟机中，将变量存储到内存和从内存中取出变量(这里的变量包括了：实例字段、静态字段、构成数组的元素。不包括：局部变量与方法参数，因为这些属于线程私有的，不会被共享，也不存在竞争问题)。
问题 2 Java 内存模型规定了所有的变量都存储在 1 中，每条线程都有自己的工作内存(Working Memory，类比：Num 1：缓存一致性中的高速缓存)。线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取/写入等)，都必须在工作内存中，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。线程、主内存、工作内存三者的交互关系如下：
A：高速缓存B：工作内存(Working Memory，类比：Num 1：缓存一致性中的高速缓存)C：主内存(Main Memory，类比：Num 1：缓存一致性中的主内存) Num 4：内存间交互操作 Java 内存模型中定义了8中操作来完成主内存和工作内存之间具体的交互协议。虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。
lock(锁定)：作用于主内存的变量，把一个变量比欧式为一条线程独占的状态。unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。read(读取)：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。load(载入)：作用于工作内存的变量，把read操作从主内存得到的变量值放入工作内存的变量副本中。use(使用)：作用于工作内存的变量，把工作内存中的一个变量的值传递给执行引擎。assign(赋值)：作用于工作内存的变量，当虚拟机遇到一个给变量赋值的字节码指令时，把一个从执行引擎接收到的值赋给工作内存的变量store(存储)：作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。write(写入)：作用于主内存，把store操作从工作内存中得到的变量的值放入主内存的变量中。 long 和 double型变量的特殊规则 java 内存模型要求上述8种操作具有原子性，但对于64位的数据类型(long和double)，特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，
问题 3 如果要把一个变量从主内存复制到工作内存，顺序执行： 1 A：lock -&gt; unlockB：unlock -&gt; readC：read -&gt; load 问题 4 如果要把一个变量从工作内存复制到主内存，顺序执行： 1 A：use -&gt; assignB：assign -&gt; storeC：store -&gt; write Num 5：Volatile 型变量 关键字volatile可以说是虚拟机提供的最轻量级的同步机制，Java 内存模型对volatile专门定义了一些特殊的访问规则。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0ddc6a992d8143bc540fd09674596f41/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-01-03T13:18:43+08:00" />
<meta property="article:modified_time" content="2021-01-03T13:18:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入理解Java虚拟机高级特性与最佳实践 - 全国统一考试试卷(下)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>本文整理自 <a href="https://union-click.jd.com/jdc?e=&amp;p=AyIGZRprFQEVBlMYUx0yVlgNRQQlW1dCFFlQCxxKQgFHREkdSVJKSQVJHFRXFk9FUlpGQUpLCVBaTFhbXQtWVmpSWRtYEgMUBF0Ta2ZdYlA%2BZBBpYUdPVGkrQXxBWhVJLWUOHjdUK1sUAxIOUx1eFwIiN1Uca0NsEgZUGloUBxMDVitaJQIVBl0YXhYBFgdRHFslBRIOZc7SqdSrh4G66cyxht7mo1ocMiI3VitrJQIiBGVZNUIBGw5UGQ8VBkUFAB5bEAQbAFMdXkcLRQFSHwxHAxNUZRlaFAYb" rel="nofollow">深入理解Java虚拟机：JVM高级特性与最佳实践 – 周志明</a></p> 
<h2><a id="__3"></a>第三部分 高效并发</h2> 
<p>物理机对并发的处理方案对于虚拟机的并发实现有相当大的参考意义。计算机的存储设备的运算速度与处理器的运算速度，有几个数量级的差距，所以现代计算机系统不得不加入一层读写速度尽可能接近处理器运算速度的高度缓存(Cache)来作为内存与处理器之间的缓冲。</p> 
<p>工作原理如下：</p> 
<ul><li>将运算需要使用到的数据复制到缓存中，让运算能够快速进行</li><li>运算结束后，再从缓存同步回内存之中。</li></ul> 
<h3><a id="Num_1_12"></a>Num 1：缓存一致性</h3> 
<p>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存(Main Memory)。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，如果真出现此情况，那同步到主内存的数据以谁的缓存数据为准呢？为了解决这个缓存一致性的问题，需要各个处理器读写访问缓存时按照协议约定进行操作。这些协议包括但不限于：MSI、MESI、MOSI、Synapse、Firefly及Dragon Protocol等。不同架构下的物理机器使用不一样的缓存一致性协议，也就拥有不一样的内存模型。</p> 
<p><img src="https://images2.imgbox.com/3c/b6/yr7DfvFI_o.png" alt="处理器、高速缓存、主存 交互关系"></p> 
<h3><a id="Num_2Java__18"></a>Num 2：Java 内存模型的由来</h3> 
<blockquote> 
 <p><code>C/C++</code>：直接使用物理硬件和操作系统的内存模型。由于不同操作系统平台上内存模型的差异，因此，运行结果也不同。</p> 
 <p><code>Java</code>：Java虚拟机试图定义一种内存模型规范来屏蔽各种硬件、操作系统的内存访问差异，以实现让Java程序在各种平台上，都能达到一致的内存访问效果。</p> 
</blockquote> 
<h4><a id="_1_24"></a>问题 1</h4> 
<p>Java 内存模型的英文简称是：      1        。</p> 
<ul><li>A：<code>Java Working Memory,JWM</code></li><li>B：<code>Java Main Memory,JMM</code></li><li>C ：<code>Java Memory Model,JMM</code></li></ul> 
<h3><a id="Num_3Java__32"></a>Num 3：Java 内存模型</h3> 
<p>Java 内存模型的主要目标是定义程序中各<code>变量</code>的访问规则，即：在虚拟机中，将变量存储到内存和从内存中取出<code>变量</code>(这里的变量包括了：实例字段、静态字段、构成数组的元素。不包括：局部变量与方法参数，因为这些属于线程私有的，不会被共享，也不存在竞争问题)。</p> 
<h4><a id="_2_36"></a>问题 2</h4> 
<p>Java 内存模型规定了所有的变量都存储在      1       中，每条线程都有自己的工作内存(Working Memory，类比：<code>Num 1：缓存一致性</code>中的高速缓存)。线程的工作内存中保存了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作(读取/写入等)，都必须在工作内存中，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。线程、主内存、工作内存三者的交互关系如下：</p> 
<p><img src="https://images2.imgbox.com/da/66/v5oBvR9l_o.png" alt=""></p> 
<ul><li>A：高速缓存</li><li>B：工作内存(Working Memory，类比：<code>Num 1：缓存一致性</code>中的高速缓存)</li><li>C：主内存(Main Memory，类比：<code>Num 1：缓存一致性</code>中的主内存)</li></ul> 
<h3><a id="Num_4_46"></a>Num 4：内存间交互操作</h3> 
<p>Java 内存模型中定义了8中操作来完成主内存和工作内存之间具体的交互协议。虚拟机实现时必须保证下面提及的每一种操作都是原子的、不可再分的。</p> 
<ul><li>lock(锁定)：作用于主内存的变量，把一个变量比欧式为一条线程独占的状态。</li><li>unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read(读取)：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li><li>load(载入)：作用于工作内存的变量，把read操作从主内存得到的变量值放入工作内存的变量副本中。</li><li>use(使用)：作用于工作内存的变量，把工作内存中的一个变量的值传递给执行引擎。</li><li>assign(赋值)：作用于工作内存的变量，当虚拟机遇到一个给变量赋值的字节码指令时，把一个从执行引擎接收到的值赋给工作内存的变量</li><li>store(存储)：作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li><li>write(写入)：作用于主内存，把store操作从工作内存中得到的变量的值放入主内存的变量中。</li></ul> 
<h4><a id="long__double_59"></a><code>long</code> 和 <code>double</code>型变量的特殊规则</h4> 
<p>java 内存模型要求上述8种操作具有原子性，但对于64位的数据类型(long和double)，特别定义了一条相对宽松的规定：允许虚拟机将没有被<code>volatile</code>修饰的64位数据的读写操作划分为两次32位的操作来进行，</p> 
<h4><a id="_3_63"></a>问题 3</h4> 
<p>如果要把一个变量从主内存复制到工作内存，顺序执行：      1       </p> 
<ul><li>A：<code>lock -&gt; unlock</code></li><li>B：<code>unlock -&gt; read</code></li><li>C：<code>read -&gt; load</code></li></ul> 
<h4><a id="_4_71"></a>问题 4</h4> 
<p>如果要把一个变量从工作内存复制到主内存，顺序执行：      1       </p> 
<ul><li>A：<code>use -&gt; assign</code></li><li>B：<code>assign -&gt; store</code></li><li>C：<code>store -&gt; write</code></li></ul> 
<h3><a id="Num_5Volatile__79"></a>Num 5：Volatile 型变量</h3> 
<p>关键字<code>volatile</code>可以说是虚拟机提供的最轻量级的同步机制，Java 内存模型对<code>volatile</code>专门定义了一些特殊的访问规则。</p> 
<p>应用案例：<code>java.util.concurrent.atomic.AtomicInteger</code></p> 
<pre><code>public class AtomicInteger extends Number implements java.io.Serializable {
    private static final long serialVersionUID = 6214790243416807050L;

    // setup to use Unsafe.compareAndSwapInt for updates
    private static final Unsafe unsafe = Unsafe.getUnsafe();
    private static final long valueOffset;

    static {
        try {
            valueOffset = unsafe.objectFieldOffset
                (AtomicInteger.class.getDeclaredField("value"));
        } catch (Exception ex) { throw new Error(ex); }
    }

    private volatile int value;
    ...
}
</code></pre> 
<h4><a id="_5_105"></a>问题 5</h4> 
<p>当一个变量被<code>volatile</code>修饰，它具备两种特性。      1       和      2       </p> 
<ul><li>A：<code>变量对所有线程的可见性</code>、<code>加锁</code></li><li>B：<code>同步</code>、<code>加锁</code></li><li>C：<code>变量对所有线程的可见性</code>、<code>禁止指令重排序</code></li></ul> 
<p>可见性。指的是，当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。相比较于普通变量，不需要通过主内存来完成。以变量修改为例：</p> 
<ul><li>1、线程A修改了被<code>volatile</code>修饰的普通变量的值，然后向主内存回写</li><li>2、线程B在线程A回写完成之后，再从主内存进行读取操作，新变量值才会对线程B可见。</li></ul> 
<p>换句话说，<code>volatile</code>变量对所有线程是立即可见的，对<code>volatile</code>变量的写操作都能立即反应到其他线程中，即：<code>volatile</code>变量在各个线程中是一致的。</p> 
<p><code>volatile</code> 适合在多线程场景中，标识状态，协助控制并发。例如：多线程工作场景中，修饰工作进展状态，在任务终止时，所有线程安全退出。</p> 
<h4><a id="_6_122"></a>问题 6</h4> 
<p>20 个线程，每个线程对 volatile 关键字修饰的变量累加 10000 次，多次运行，结果是怎样？</p> 
<pre><code>public class VolatileTest {
    private static volatile int race = 0;

    private static void increase() {
        race++;
    }

    public static void main(String[] args) {
        int threadCount = 20;

        Thread[] threads = new Thread[threadCount];

        for (int i = 0; i &lt; threadCount; i++) {
            threads[i] = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i &lt; 10000; i++) {
                        increase();
                    }
                }
            });

            threads[i].start();
        }

        // 等待所有线程都结束
        while (Thread.activeCount() &gt; 1) {
            Thread.yield();
        }

        System.out.println(race);
    }
}
</code></pre> 
<ul><li>A：<code>200000</code></li><li>B：<code>大于 200000</code></li><li>C：<code>小于 200000</code></li></ul> 
<h3><a id="Num_6_166"></a>Num 6：指令重排序</h3> 
<p>指令重排序是并发编程中最容易让开发人员产生疑惑的地方，那么<code>volatile</code>关键字，是如何禁止指令重排序的呢？</p> 
<p><code>volatile</code>关键字修饰的变量，赋值后(<code>mov xxx,yyy</code>)字节码中多执行了一个<code>lock addl $0x0,(%esp)</code>操作，这个操作相当于一个内存屏障(Memory Barries或Memory Fence，重排序时，不能把后面的指令重排序到内存屏障之前的位置)，只有一个CPU访问内存时，并不需要内存屏障；但如果有两个或更多CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保障一致性。<code>lock addl $0x0,(%esp)</code>(把ESP寄存器的值加0)，显然是一个空操作，关键在于lock前缀，它的作用是使得本CPU的Cache写入了内存，该写入动作也会引起别的CPU或者别的内核无效化(Invalidate)其Cache，这种操作相当于对CPU Cache中的变量做了一次<code>store</code>、<code>write</code>操作。</p> 
<h4><a id="7_172"></a>问题7</h4> 
<pre><code>public class DoubleCheckSingleInstance {

    private static /*volatile*/ DoubleCheckSingleInstance doubleCheckSingleInstance;

    private DoubleCheckSingleInstance() {
    }

    public static DoubleCheckSingleInstance getInstance() {
        if (doubleCheckSingleInstance == null) {
            synchronized (DoubleCheckSingleInstance.class) {
                if (doubleCheckSingleInstance == null) {
                    doubleCheckSingleInstance = new DoubleCheckSingleInstance();
                }
            }
        }

        return doubleCheckSingleInstance;
    }

    public static void main(String[] args) {
        DoubleCheckSingleInstance.getInstance();
    }
}
</code></pre> 
<p>如上双重校验单例模式，一定要增加 <code>/*volatile*/</code>关键字修饰吗？</p> 
<ul><li>A：<code>不好说</code></li><li>B：<code>不需要</code></li><li>C：<code>一定需要</code></li></ul> 
<h4><a id="8_206"></a>问题8</h4> 
<p>并发三“傻”(特性)分别是：原子性、      1       、有序性。Java语言提供了<code>volatile</code>和<code>synchronized</code>两个关键字来保证线程之间操作的有序性，<code>volatile</code>本身就包含了禁止指令重排序的语义，而<code>synchronized</code>则是由：“一个变量在同一个时刻只允许一条线程对其进行<code>lock</code>操作”这条规则实现的，这条规则决定了持有同一个锁的两个同步块只能串行进入。</p> 
<p>大部分的并发控制操作都是使用<code>synchronized</code>来完成的，<code>synchronized</code>的“万能”也间接造成了它被程序员滥用的局面，越“万能”的并发控制，通常会伴随着越大的性能影响。</p> 
<ul><li>A：同步性</li><li>B：加锁性</li><li>C：有序性</li></ul> 
<h3><a id="Num_7_216"></a>Num 7：先行发生原则</h3> 
<p><code>先行发生原则</code>(happens-before) 非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，用来裁决并发环境下两个操作之间首付可能冲突。先行发生原则是虚拟机保证的，无须同步器。</p> 
<ul><li>程序次序规则：在一个线程内，按照程序代码顺序，书写在前面的操作先于书写在后面的操作。</li><li>管程锁定规则：对同一个锁来说，一个unlock操作先于后面对同一个锁的lock操作。</li><li>volatile变量规则：对一个volatile变量的写操作先于后面对这个变量的读操作。</li><li>线程启动规则：Thread对象的start()方法先于此线程的每一个动作。</li><li>线程终止规则：线程的所有操作都优先于线程的终止操作。</li><li>线程中断规则：线程的interrupt()方法先于线程中断检测事情，即：先于 interrupted() 方法</li><li>对象终结规则：一个对象的初始化完成(构造函数执行结束)先于它的finalize()方法</li><li>传递性：如果操作A先于操作B，操作B先于操作C，那么，操作A一定先于操作C。</li></ul> 
<h4><a id="9_229"></a>问题9</h4> 
<pre><code>Thread threadA = new Thread(() -&gt; i = 1);
Thread threadB = new Thread(() -&gt; j = i);
Thread threadC = new Thread(() -&gt; i = 2);
System.out.println("---&gt; " + j);
</code></pre> 
<p>如上代码中，线程B中的<code>变量j</code>具有线程安全性吗？</p> 
<ul><li>A：线程安全</li><li>B：在任何场景下，都能稳定输出</li><li>C：<code>变量j</code>的结果不确定，1和2都有可能，线程C对<code>变量i</code>的影响可能被线程B观察到，也可能观察不到，可能读到过期数据。</li></ul> 
<h3><a id="Num_8Java___244"></a>Num 8：Java 与 线程</h3> 
<h4><a id="_246"></a>线程</h4> 
<p>线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源，又可以独立调度。</p> 
<p>线程(线程与Java线程是两个概念)实现主要有三种方式：使用内核线程；使用用户线程；使用用户线程+轻量级进程混合实现。</p> 
<h4><a id="10_252"></a>问题10</h4> 
<p>线程调度有两种方式：协同式线程调度 和       1       。</p> 
<ul><li> <p>A：随机调度</p> </li><li> <p>B：加权式线程调度</p> </li><li> <p>C：抢占式线程调度。</p> </li><li> <p>协同式线程调度：一个线程执行完毕，要主动通知系统，系统会切换到另一个线程上。优点：实现简单。缺点：线程执行切换状态由自身控制，操作系统不可空。案例：windows 3.x</p> </li><li> <p>抢占式线程调度：每个线程由系统来分配执行时间，切换不由线程本身来决定。当一个线程出现问题，可以通过任务管理器将这个进程“杀掉”。</p> </li></ul> 
<h4><a id="Java__263"></a>Java 线程状态</h4> 
<p>Java 线程调度，是按照<code>抢占式线程</code>来调度的，即：系统来自动完成，但开发者可以通过优先级来设定优先执行顺序，Java 语言一共设定了10个级别的线程优先级，从 Thread.MIN_PRIORITY 到 Thread.MAX_PRIORITY。</p> 
<h4><a id="11_267"></a>问题11</h4> 
<p>Java 语言定义了5种线程状态，在任意一个时间点，一个线程有且只有一种状态</p> 
<ol><li>新建(NEW)：新创建了一个线程对象，并没有调用start()方法之前。</li><li>可运行(RUNNABLE)：也就是就绪状态，调用start()方法之后线程就进入就绪状态， 但是并不是说只要调用start()方法线程就马上变为当前线程，在变为当前线程之前都是为就绪状态。值得一提的是，线程在睡眠和挂起中恢复的时候也会进入就绪状态。线程对象创建后，其他线程(比如main线程）调用了该对象的start()方法。该状态的线程位于可运行线程池中，等待被线程调度选中，获取cpu 的使用权 。</li><li>运行(RUNNING)：可运行状态(runnable)的线程获得了cpu 时间片（timeslice），执行程序代码。线程被设置为当前线程，开始执行run()方法。就是线程进入运行状态</li><li>阻塞(BLOCKED)：阻塞状态是指线程因为某种原因放弃了cpu 使用权，也即让出了cpu timeslice，暂时停止运行。直到线程进入可运行(runnable)状态，才有机会再次获得cpu timeslice 转到运行(running)状态。线程被暂停，比如说调用sleep()方法后线程就进入阻塞状态。</li><li>死亡(DEAD)：线程执行结束，线程run()、main() 方法执行结束，或者因异常退出了run()方法，则该线程结束生命周期。死亡的线程不可再次复生。</li></ol> 
<p><img src="https://images2.imgbox.com/4c/65/hmB9H2Td_o.png" alt=""></p> 
<hr> 
<p>阻塞的情况分三种：</p> 
<p>(一). 等待阻塞：运行(running)的线程执行o.wait()方法，JVM会把该线程放入等待队列(waitting queue)中。<br> (二). 同步阻塞：运行(running)的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池(lock pool)中。<br> (三). 其他阻塞：运行(running)的线程执行Thread.sleep(long ms)或t.join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入可运行(runnable)状态。</p> 
<p>等待又可具体分为：无限期等待、限期等待两种情况。</p> 
<ul><li>无限期等待：Object.wait()、Thread.join()、LockSupport.park()</li><li>限期等待：Thread.sleep()、设置了TimeOut的Object.wait()、设置了TimeOut的Thread.join()、LockSupport.parkNanos()、LockSupport.parkUntil()；</li></ul> 
<h4><a id="12_292"></a>问题12</h4> 
<p><code>wait()</code>与<code>sleep()</code>的区别，简单来说<code>wait()</code>会释放      1       而<code>sleep()</code>不会。但是<code>wait</code>和<code>sleep</code>都会释放      2       。</p> 
<ul><li>A：内存资源、cpu资源</li><li>B：cpu资源、对象锁资源</li><li>C：对象锁资源、cpu资源</li></ul> 
<p>解析：wait用于锁机制，sleep不是，这就是为啥sleep不释放锁，wait释放锁的原因，sleep是线程的方法，跟锁没半毛钱关系，wait，notify,notifyall 都是Object对象的方法，是一起使用的，用于锁机制。 — 朝北教室的风筝</p> 
<h4><a id="Java__302"></a>Java 线程生命周期</h4> 
<p>1.sleep：Thread类的方法，必须带一个时间参数。会让当前线程休眠进入阻塞状态并释放CPU（阿里面试题 Sleep释放CPU，wait 也会释放cpu，因为cpu资源太宝贵了，只有在线程running的时候，才会获取cpu片段），提供其他线程运行的机会且不考虑优先级，但如果有同步锁则sleep不会释放锁即其他线程无法获得同步锁 可通过调用interrupt()方法来唤醒休眠线程。</p> 
<p>2.yield：让出CPU调度，Thread类的方法，类似sleep只是不能由用户指定暂停多长时间 ，并且yield()方法只能让同优先级的线程有执行的机会。 yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。调用yield方法只是一个建议，告诉线程调度器我的工作已经做的差不多了，可以让别的相同优先级的线程使用CPU了，没有任何机制保证采纳。</p> 
<p>3.wait：Object类的方法(notify()、notifyAll() 也是Object对象)，必须放在循环体和同步代码块中，执行该方法的线程会释放锁，进入线程等待池中等待被再次唤醒(notify随机唤醒，notifyAll全部唤醒，线程结束自动唤醒)即放入锁池中竞争同步锁</p> 
<p>4.join：一种特殊的wait，当前运行线程调用另一个线程的join方法，当前线程进入阻塞状态直到另一个线程运行结束等待该线程终止。 注意该方法也需要捕捉异常。</p> 
<p>等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测。</p> 
<p><img src="https://images2.imgbox.com/be/75/8H4mwm94_o.png" alt=""></p> 
<h4><a id="13_316"></a>问题13</h4> 
<pre><code>public class ThreadJoinTest {
    public static void main(String[] args) {
        Thread thread = new Thread(new JoinTask());
        thread.start();

        for (int i = 0; i &lt; 10; i++) {

            System.out.println("主线程第" + i + "此执行！");

            if (i &gt;= 2) {
                try {
                    thread.join();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}

class JoinTask implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i &lt; 10; i++) {
            System.out.println("线程JoinTask 第" + i + "次执行");
        }
    }
}
</code></pre> 
<p>上面，输出的最后一行是什么？</p> 
<ul><li>A：线程JoinTask 第9次执行</li><li>B：主线程第10此执行！</li><li>C：主线程第9此执行！</li></ul> 
<h3><a id="Num_9_355"></a>Num 9：线程安全</h3> 
<p>当多个对象访问一个对象时，如果不用考虑这些线程在运行时环境下的调度以及交替执行，也不需要进行额外的同步，或者在调用方进行任何协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。</p> 
<p>按照线程安全的“安全程度”由强到弱来排序，可以将Java语言中的各种操作共享的数据分为5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p> 
<h3><a id="Num_10_361"></a>Num 10：不可变的对象</h3> 
<p>不可变的对象是一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采用任何的线程安全保障措施。只要一个不可变的对象被正确的构建出来，那期外部的可见状态永远也不会改变。</p> 
<p>Java 语言中，如果共享数据是基本数据类型，那么，只需要使用final关键字修饰它就可以保证它是不可变的。如果共享数据的是一个对象，那就需要保证对象的行为不会对其状态产生任何影响。</p> 
<p>例如：<code>java.lang.String</code>是一个典型的不可变对象，我们调用它的substring()、replace()这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象。类似的应用案例还有：<code>java.lang.Integer</code>对象、枚举类型、<code>java.lang.Number</code>的部分子类，如：Long、Double等数值包装类型、BigInteger和BigDecimal等大数据类型；</p> 
<p>但：<code>java.util.concurrent.atomic.AtomicInteger</code> 不是。</p> 
<h3><a id="Num_11_371"></a>Num 11：绝对线程安全</h3> 
<p>绝对的意思是“不管运行时环境如何，调用者都不需要任何额外的同步措施”。例如：Vector集合类，全都加了<code>synchronized</code>关键字</p> 
<p>Vector.java</p> 
<pre><code>public synchronized E get(int index) {
    if (index &gt;= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    return elementData(index);
}
</code></pre> 
<h4><a id="14_387"></a>问题14</h4> 
<pre><code>public class VectoryThreadSafeTest {

    private static Vector&lt;Integer&gt; vectors = new Vector&lt;&gt;();

    public static void main(String[] args) {
        while (true) {
            for (int i = 0; i &lt; 30; i++) {
                vectors.add(i);
            }

            Thread removeThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i &lt; vectors.size(); i++) {
                        vectors.remove(i);
                    }
                }
            });

            Thread printThread = new Thread(new Runnable() {
                @Override
                public void run() {
                    for (int i = 0; i &lt; vectors.size(); i++) {
                        System.out.println(vectors.get(i));
                    }
                }
            });

            removeThread.start();
            printThread.start();

            while(Thread.activeCount() &gt; 80);
        }
    }
}
</code></pre> 
<p>上面的程序可能抛出<code>ArrayIndexOutOfBoundsException</code>异常吗？</p> 
<ul><li>A：一定不会</li><li>B：一定会</li><li>C：可能会</li></ul> 
<p>解析：</p> 
<pre><code>Exception in thread "Thread-21574" java.lang.ArrayIndexOutOfBoundsException: Array index out of range: 20
	at java.util.Vector.remove(Vector.java:831)
	at T_Java.VectoryThreadSafeTest$1.run(VectoryThreadSafeTest.java:21)
	at java.lang.Thread.run(Thread.java:745)
</code></pre> 
<h3><a id="Num_12_442"></a>Num 12：相对线程安全</h3> 
<p>首先需要保证对这个对象单独的操作是线程安全的，但是对一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。</p> 
<h3><a id="Num_13_446"></a>Num 13、线程安全的实现方法</h3> 
<p>实现线程安全的三种方案：互斥同步、非阻塞同步、无同步方案。</p> 
<h4><a id="_450"></a>互斥同步</h4> 
<p>互斥同步是指多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用。互斥是因，同步是果；互斥是方法，同步目的。最基本的互斥同步手段就是<code>synchronized</code>关键字。</p> 
<p><code>synchronized</code>编译之后，会在同步代码块前后生成monitorenter、monitorexit两个字节码指令，这两个字节码都需要一个reference类型的参数来指名要锁定和解锁的对象(实例对象+类对象)。</p> 
<p><code>synchronized</code>工作流程：</p> 
<ul><li>在执行monitorenter指令时，首先尝试获取对象锁。</li><li>如果对象锁获取成功或者已经拥有了该对象的锁，把锁的计数+1。如果获取失败，那当前线程就阻塞等待，直到对象锁释放。</li><li>相应的，在执行monitorexit指令时，将锁计数-1。</li><li>当锁计数 =0时，锁释放。</li></ul> 
<h4><a id="15_463"></a>问题15</h4> 
<p><code>synchronized</code>加锁是否可重入？</p> 
<ul><li>A：不确定</li><li>B：不是</li><li>C：是</li></ul> 
<h4><a id="synchronized_471"></a><code>synchronized</code>为什么是重量级操作？</h4> 
<p>Java 的线程是映射到操作系统的原生系统上，如果要阻塞或者唤醒一个线程，都需要操作系统来帮忙完成，即：需要从用户态切换到核心态中，因此状态转换需要耗费很多的处理器时间。对于简单的同步块，例如：<code>synchronized</code>修饰的get/set，状态切换消耗的时间有可能比用户代码执行的时间还要长。所以，<code>synchronized</code>是Java语言中一个重量级的操作。</p> 
<p>优化方案：</p> 
<ul><li>1、在通知操作系统阻塞线程之前 ，加入一段自旋等待的过程，避免频繁的切入到核心态之中。</li></ul> 
<h4><a id="javautilconcurrentReentrantLocksynchronized_480"></a><code>java.util.concurrent.ReentrantLock</code>与<code>synchronized</code>的区别？</h4> 
<p>它们都具备一样的线程重入特性，<code>ReentrantLock</code>使用lock()/unlock()方法配合try/finally语句块来完成，相比较：<code>synchronized</code>，有以下三项优化：</p> 
<ul><li>等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他工作。</li><li>可实现公平锁：多个线程在等待同一个锁时，必须按照申请锁的时间顺序来一次获得锁；<code>synchronized</code>是非公平的，<code>ReentrantLock</code>默认情况下也是非公平的，但可以通过传入带布尔值的条件的构造函数要求使用公平锁。<pre><code>/**
 * Creates an instance of {@code ReentrantLock}.
 * This is equivalent to using {@code ReentrantLock(false)}.
 */
public ReentrantLock() {
    sync = new NonfairSync();
}

/**
 * Creates an instance of {@code ReentrantLock} with the
 * given fairness policy.
 *
 * @param fair {@code true} if this lock should use a fair ordering policy
 */
public ReentrantLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
}
</code></pre> </li><li>锁可以绑定多个条件：<code>ReentrantLock</code>对象可以同时绑定多个Condition对象，</li></ul> 
<h4><a id="_507"></a>非阻塞同步</h4> 
<p>互斥同步是一种悲观策略，总是认为只要不去做正确的同步措施(例如：加锁)，那就肯定会出现问题，无论共享数据是否真的会出现竞争。</p> 
<p>随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略，通俗地讲，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，即：产生了冲突，那就再采用其他的补偿措施(例如：不断的重试，直到成功为止)，因此这成为：非阻塞同步。</p> 
<p>这类硬件指令常用的有：</p> 
<ul><li>测试并设置：Test-and-set</li><li>获取并增加：Fetch-and-Increment</li><li>交换：Swap</li><li>比较并交换：Compare-and-swap，即：CAS</li><li>加载链接/条件存储：Load-Linked/Store-Conditional，即：LL/SC</li></ul> 
<h4><a id="CAS__520"></a>CAS 工作过程</h4> 
<p>CAS 需要三个操作数，分别是内存位置，用V表示；旧的预期值，用A表示；新值，用B表示。CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的旧值，否则它就不执行更新；但是，无论是否更新了V的值，都会返回V的旧值，该处理过程是一个原子操作。</p> 
<h4><a id="CAS_ABA_524"></a>CAS 逻辑漏洞：ABA问题</h4> 
<p>解决方案，增加版本号，例如：提供了 AtomicStampedReference。ABA问题并不会影响程序的正确性。</p> 
<h4><a id="_528"></a>无同步方案</h4> 
<p>要保证线程安全，并不一定就要进行同步。有如下这样几种方式：</p> 
<ul><li>可重入代码：不依赖存储在堆上的数据和公用的系统资源，使用的数据都由参数中传入、不调用非可重入的方法等。</li><li>线程本地存储：每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V键值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。</li></ul> 
<h4><a id="_535"></a>自旋锁与自适应自旋</h4> 
<p>共享数据在锁定状态下只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得。所以，在多线程工作场景中，让后面需要申请锁的线程，多等一段时间，但不放弃处理器的执行时间，没准持有锁的线程很快就会释放锁。为了让线程多等一段时间，我们只需要让线程执行一个忙循环(自旋)，这项技术就是所谓的自旋。</p> 
<p>自旋等待不能代替阻塞。方法被锁占用的时间越短，自旋等待的效果也就越好。自旋次数，默认10次。</p> 
<h4><a id="_541"></a>锁消除</h4> 
<p>所消除是指虚拟机即时编译器运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。</p> 
<p>锁消除的判定依据：如果判定在一段代码中，对上的所有数据都不会逃逸出去从而被其他线程访问到，那么，即就可以认为它们是线程私有的，同步加锁自然就无须进行。</p> 
<h4><a id="_547"></a>轻量级锁</h4> 
<p>对象头的<code>Mark-Word</code>是实现轻量级锁和偏向锁的关键。</p> 
<table><thead><tr><th align="center">标记位</th><th align="center">状态</th></tr></thead><tbody><tr><td align="center">01</td><td align="center">未锁定</td></tr><tr><td align="center">00</td><td align="center">轻量级锁定</td></tr><tr><td align="center">10</td><td align="center">膨胀(重量级锁定)</td></tr><tr><td align="center">11</td><td align="center">GC标记</td></tr><tr><td align="center">01</td><td align="center">可偏向</td></tr></tbody></table> 
<p>工作流程：</p> 
<ul><li>1、在进入同步代码块时，如果次同步对象没有被锁定(锁标记位为：01)，虚拟机在栈帧上创建一个锁记录的(LockRecord)，存储MarkWord的拷贝</li><li>2、CAS操作，将对象的MarkWord更新成指向LockRecord的指针。</li><li>3、如果更新成功，线程获得对象的锁，并更新对象头锁标记=00，表示此对象处于轻量级锁定状态。</li><li>4、如果更新失败了，检查MarkWord是否指向当前线程，如果是，则：当前线程已经拥有该对象的锁，可以直接进入同步块继续执行。</li><li>5、否则：说明锁对象被其他线程抢占了，要膨胀为重量级锁，锁标记位更新为：10，MarkWord指向重量级锁的指针。</li></ul> 
<p>解锁过程，与之相反。</p> 
<h4><a id="_569"></a>为什么叫轻量级锁？</h4> 
<p>对于绝大部分的锁，在整个同步周期内都是不存在竞争的，这是一条经验数据。如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销。但如果存在锁竞争，除了互斥量的开销，还额外发生了CAS对象头的操作，因此在有竞争的情况下，轻量级锁会比传统重量级锁更慢。</p> 
<h4><a id="_573"></a>偏向锁</h4> 
<p>偏向锁的目的是消除数据在无竞争情况下的同步原语。如果说轻量级锁是在无竞争状态下，使用CAS操作去消除同步使用的互斥量的开销，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了。</p> 
<p>偏向锁的偏就是偏心的偏，偏袒的偏，它的意思是：这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他线程获取，则持有该偏向锁的线程将永远不需要再进行同步。</p> 
<p>假设虚拟机启用了偏向锁，启用参数：-XX:+UseBiasedLocking，那么当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标记位设为01，即：偏向模式。同时，把持有偏向锁的线程ID记录在MarkWord中，如果CAS操作成功，持有偏向锁的线程每次进入这个锁的相关同步块时，虚拟机都可以不再进行任何同步操作(Locking、Unlocking)。当有另外的线程，尝试去获取这个锁的时候，偏向模式宣告结束，撤销偏向。</p> 
<p><img src="https://images2.imgbox.com/6c/f9/QKYU3XM1_o.png" alt=""></p> 
<h4><a id="_583"></a>互斥量</h4> 
<p>当多个线程访问共享资源的时候，比如说共享内存，全局变量等，如果没有合理的线程同步机制的话，就会出现数据不一致的现象。为了实现同步机制，POSIX线程提供了多种方式，其中一种方式为互斥量mutex(也被称为互斥锁)。</p> 
<p>互斥量具体实现方式：每个线程在访问共享资源前先尝试对互斥量进行设置(加锁)，成功加锁后才可以对共享资源进行读写操作，操作结束后释放互斥量(解锁)。</p> 
<p>对互斥量进行加锁之后，任何其他试图再次对互斥量进行加锁的线程都会被阻塞直到当前线程释放该互斥锁，此时被阻塞的线程处于阻塞状态。如果释放互斥量时有一个以上的线程处于阻塞状态，那么所有该锁上的阻塞线程都会变成可运行状态，第1个变为运行态的线程就可以对互斥量加锁，其他线程就会检测到互斥量依然是锁住的，只能再次回到可运行状态，等待互斥量重新变为可以。使用互斥量进行线程同步的方式下，每次只有获得互斥量的那个线程可以向前执行。</p> 
<p>互斥量不是为了消除竞争，实际上，资源还是共享的，线程间也还是竞争的，只不过通过这种“加锁/解锁”机制将共享资源的访问变成互斥操作，也就是说当某一个线程访问这个共享资源时，其它线程无法访问它，从而消除与时间有关的错误。从互斥量的实现机制我们可以看出，同一时刻，只能有一个线程持有该锁。还有一点需要注意的是，所有访问该共享资源的线程必须采用相同的互斥量(锁)，而不能使用多个不同互斥量。</p> 
<h4><a id="_593"></a>关于锁状态</h4> 
<p>锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态。他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p> 
<hr> 
<h2><a id="_602"></a>参考资料</h2> 
<ol><li> <p><a href="https://union-click.jd.com/jdc?e=&amp;p=AyIGZRprFQEVBlMYUx0yVlgNRQQlW1dCFFlQCxxKQgFHREkdSVJKSQVJHFRXFk9FUlpGQUpLCVBaTFhbXQtWVmpSWRtYEgMUBF0Ta2ZdYlA%2BZBBpYUdPVGkrQXxBWhVJLWUOHjdUK1sUAxIOUx1eFwIiN1Uca0NsEgZUGloUBxMDVitaJQIVBl0YXhYBFgdRHFslBRIOZc7SqdSrh4G66cyxht7mo1ocMiI3VitrJQIiBGVZNUIBGw5UGQ8VBkUFAB5bEAQbAFMdXkcLRQFSHwxHAxNUZRlaFAYb" rel="nofollow">《深入理解Java虚拟机：JVM高级特性与最佳实践》 – 周志明</a></p> </li><li> <p><a href="https://union-click.jd.com/jdc?e=&amp;p=AyIGZRprFQEWB1QTWBUyVlgNRQQlW1dCFFlQCxxKQgFHREkdSVJKSQVJHFRXFk9FUlpGQUpLCVBaTFhbXQtWVmpSWRtYEQITD1Yba296FGwwfT8VZ0hxC0skTANTfgllXGUOHjdUK1sUAxIOUx1eFwIiN1Uca0NsEgZUGloUBxMDVitaJQIVBl0fWxYFEA9dGlwlBRIOZc7SqdSrh4G66cyxht7mo1ocMiI3VitrJQIiBGVZNRUGFQNQHF4UVkdXVB4ORlUbBwcaU0FXQQRUHw5FVRFSZRlaFAYb" rel="nofollow">《深入理解Android：Java虚拟机ART》 – 邓凡平</a></p> </li><li> <p><a href="https://union-click.jd.com/jdc?e=&amp;p=AyIGZRprFQEXBFQTXxwyVlgNRQQlW1dCFFlQCxxKQgFHREkdSVJKSQVJHFRXFk9FUlpGQUpLCVBaTFhbXQtWVmpSWRtYEAETD1ESa2heWmQCchxUZ0x9T34HT0VJBQh4PFMOHjdUK1sUAxIOUx1eFwIiN1Uca0NsEgZUGloUBxMDVitaJQIVBl0fWxYLEAdXH1IlBRIOZc7SqdSrh4G66cyxht7mo1ocMiI3VitrJQIiBGVZNRNWRgNSSQ9GVRQFVh4LFQRCVFIaWEEGFARSGQwSBBoAZRlaFAYb" rel="nofollow">《Java并发编程的艺术》+《Java并发编程实战》</a></p> </li><li> <p><a href="https://www.cnblogs.com/prayers/p/5515245.html" rel="nofollow">深入理解java虚拟机 – 战斗民族就是干</a></p> </li><li> <p><a href="https://www.cnblogs.com/aspirant/p/8900276.html" rel="nofollow">Java线程的5种状态及切换(透彻讲解) – 朝北教室的风筝</a></p> </li><li> <p><a href="https://www.cnblogs.com/aspirant/p/8876670.html" rel="nofollow">sleep、yield、wait、join的区别 – 朝北教室的风筝</a></p> </li><li> <p><a href="https://www.iteye.com/blog/icyfenix-1256329">Java虚拟机规范</a></p> </li><li> <p><a href="https://github.com/HailouWang/KotlinDemo">文中涉及源代码，github传送门</a></p> </li><li> <p><a href="https://www.cnblogs.com/takumicx/p/9338983.html" rel="nofollow">ReentrantLock(重入锁)功能详解和应用演示 – takumiCX</a></p> </li><li> <p><a href="https://www.cnblogs.com/paddix/p/5405678.html" rel="nofollow">Java并发编程：Synchronized底层优化（偏向锁、轻量级锁） – liuxiaopeng</a></p> </li><li> <p><a href="https://www.cnblogs.com/yunfan1024/p/11300810.html" rel="nofollow">线程同步—互斥量 – yunfan</a></p> </li><li> <p><a href="https://www.cnblogs.com/itplay/p/11189651.html" rel="nofollow">【锁】synchronized的实现（偏向锁、轻量级锁、重量级锁）-- 是谁扭曲了时空</a></p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ea81cc4be9752fef7f1d1fc499800dee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python学习笔记-9.高级变量5-公共方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2db5ea5d4e6d6163c50105130c09f807/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Kotlin 实战经验中的那些坑&#43;最佳实践</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>