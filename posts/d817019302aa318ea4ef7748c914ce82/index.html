<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>7、SpringBoot高频面试题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="7、SpringBoot高频面试题" />
<meta property="og:description" content="1、项目中为什么选择SpringBoot SpringBoot简化了Spring，可以快速搭建企业级项目，而且开发起来效率也会更高，它的主要优点如下：
版本锁定：SpringBoot在父工程中进行了大量常见依赖的版本锁定，省去了我们查找依赖版本和解决版本冲突的麻烦起步依赖：SpringBoot以功能化的方式将需要的依赖进行组装，并且允许程序员以starter的方式进行引入默认配置：SpringBoot实现了大量依赖框架的默认配置项，程序员无须再进行自己配置内置Tomcat：SpringBoot内置了一个tomcat，使用它开发的程序无需再进行tomcat部署，可直接运行 2、SpringBoot的自动装配原理 Springboot自动装配主要是基于注解编程和约定优于配置的思想来进行设计的
自动装配就是自动地把其他组件中的Bean装载到IOC容器中，不需要开发人员再去配置文件中添加大量的配置
我们只需要在SpringBoot的启动类上添加一个@SpringBootApplication的注解，就可以开启自动装配
SpringBootApplication底层最重要的一部分是@EnableAutoConfiguration这个注解来实现的，它作用是：
读取所有jar包中两个指定配置文件中的所有自动配置类(xxxxAutoConfiguration)这些值必须声明为Spring的配置类，也就是在类中需要向Spring容器放入对象为了防止非当前所需的组件进入到容器，配置类中需要使用@Conditional注解来声明配置成立的必要条件 3、SpringBoot的核心注解是哪个 SpringBoot的核心注解在启动类上，叫@SpringBootApplication，主要组合包含了以下3个注解：
@SpringBootConfiguration：组合了@Configuration注解，实现配置文件的功能@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项@ComponentScan：Spring组件扫描，默认会扫描启动类所在的包 4、SpringBoot中的starter是干什么的 当项目足够复杂时，因为涉及的组件太多了，就需要引入很多的依赖，此时管理依赖就边的很麻烦
此时SpringBoot的starter就派上用场了，每个starter都可以为我们提供某个服务场景所需要的一系列依赖
在导入starter之后，SpringBoot主要帮我们完成了两件事情：
相关组件的自动导入相关组件的自动配置 5、SpringBoot可以有哪些方式加载配置 SpringBoot支持很多种方式加载配置，常见有
配置文件，直接在项目中提供SpringBoot支持的配置文件，比如properties、yaml 、yml
系统环境变量，SpringBoot是可以读取系统环境变量中的配置信息的，但不推荐这么做
命令行参数，SpringBoot在项目启动的时候运行通过命令行直接传递参数，一般用于临时修改配置的情况
6、bootstrap.yml和application.yml有何区别 这是SpringBoot支持的两个核心配置文件，区别点在于
boostrap比applicaton优先加载，在应用程序上下文的引导阶段生效，且里面的属性不能被覆盖
一般来说我们在SpringCloud Config或者Nacos中会用到它
application用于SpringBoot项目的自动化配置，一般来说我们会将自己项目的业务配置项写在这里面
7、SpringBoot读取配置的方式有几种 SpringBoot常见的读取配置信息的方式有两种：
使用@Value配合EL表达式（@Value(“${name}”)）注解直接注入对应的值使用@ConfigurationProperties注解把对应的值绑定到一个配置对象，然后将配置对象注入到需要的地方 推荐使用使用第二种方式，在配置比较多的情况下，操作简单，可读性好
8、SpringBoot项目如何热部署 Spring Boot有一个开发工具（DevTools）模块，通过它可以实现SpringBoot项目的热部署
也就是开发人员将文件更改后，它会自动部署到服务器并自动重启服务器。
&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;/dependency&gt; 9、SpringBoot项目如何实现方法的异步调用 异步调用指的是a方法在调用b方法的时候，无需等待b方法执行完毕，就可以继续向下执行
一般用在a方法无需使用b方法返回结果的场景下，可以在一定程度上提高运行效率
在SpringBoot中使用异步调用是很简单的，只需要做两个操作就可以了
在启动类上添加@EnableAsync注解，开启异步调用支持在被调用的方法上添加@Async注解 controller-a(){ 代码1 service-a() 代码3 } @Async service-a(){} 10、SpringBoot中如何实现定时任务 在SpringBoot中使用定时任务主要有两种方式，一个就是使用SpringTask，另一个则是使用第三方框架Quartz
SpringTask主要是通过@Scheduled注解来实现定时任务触发的，格式如下
@Scheduled(fixedRate = 5000) public void printTime() { System.out.println(new Date().toLocaleString()); } 主要属性如下：
fixedRate：按一定的频率执行任务，参数类型为long，单位 msfixedDelay：上一次任务执行完后多久再执行，参数类型为long，单位 msinitialDelay：延迟多久再第一次执行任务，参数类型为 long，单位 mscron：使用cron表达式指定任务在特定时间执行 11、SpringBoot中如何解决跨域问题 跨域是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d817019302aa318ea4ef7748c914ce82/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-25T20:21:55+08:00" />
<meta property="article:modified_time" content="2023-11-25T20:21:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">7、SpringBoot高频面试题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1SpringBoot_0"></a>1、项目中为什么选择SpringBoot</h3> 
<p>SpringBoot简化了Spring，可以快速搭建企业级项目，而且开发起来效率也会更高，它的主要优点如下：</p> 
<ol><li>版本锁定：SpringBoot在父工程中进行了大量常见依赖的版本锁定，省去了我们查找依赖版本和解决版本冲突的麻烦</li><li>起步依赖：SpringBoot以功能化的方式将需要的依赖进行组装，并且允许程序员以starter的方式进行引入</li><li>默认配置：SpringBoot实现了大量依赖框架的默认配置项，程序员无须再进行自己配置</li><li>内置Tomcat：SpringBoot内置了一个tomcat，使用它开发的程序无需再进行tomcat部署，可直接运行</li></ol> 
<h3><a id="2SpringBoot_9"></a>2、SpringBoot的自动装配原理</h3> 
<p>Springboot自动装配主要是基于注解编程和约定优于配置的思想来进行设计的</p> 
<p>自动装配就是自动地把其他组件中的Bean装载到IOC容器中，不需要开发人员再去配置文件中添加大量的配置</p> 
<p>我们只需要在SpringBoot的启动类上添加一个@SpringBootApplication的注解，就可以开启自动装配</p> 
<p>SpringBootApplication底层最重要的一部分是@EnableAutoConfiguration这个注解来实现的，它作用是：</p> 
<ol><li>读取所有jar包中两个指定配置文件中的所有自动配置类(xxxxAutoConfiguration)</li><li>这些值必须声明为Spring的配置类，也就是在类中需要向Spring容器放入对象</li><li>为了防止非当前所需的组件进入到容器，配置类中需要使用@Conditional注解来声明配置成立的必要条件</li></ol> 
<h3><a id="3SpringBoot_23"></a>3、SpringBoot的核心注解是哪个</h3> 
<p>SpringBoot的核心注解在启动类上，叫@SpringBootApplication，主要组合包含了以下3个注解：</p> 
<ol><li>@SpringBootConfiguration：组合了@Configuration注解，实现配置文件的功能</li><li>@EnableAutoConfiguration：打开自动配置的功能，也可以关闭某个自动配置的选项</li><li>@ComponentScan：Spring组件扫描，默认会扫描启动类所在的包</li></ol> 
<h3><a id="4SpringBootstarter_31"></a>4、SpringBoot中的starter是干什么的</h3> 
<p>当项目足够复杂时，因为涉及的组件太多了，就需要引入很多的依赖，此时管理依赖就边的很麻烦</p> 
<p>此时SpringBoot的starter就派上用场了，每个starter都可以为我们提供某个服务场景所需要的一系列依赖</p> 
<p>在导入starter之后，SpringBoot主要帮我们完成了两件事情：</p> 
<ol><li>相关组件的自动导入</li><li>相关组件的自动配置</li></ol> 
<h3><a id="5SpringBoot_42"></a>5、SpringBoot可以有哪些方式加载配置</h3> 
<p>SpringBoot支持很多种方式加载配置，常见有</p> 
<ol><li> <p>配置文件，直接在项目中提供SpringBoot支持的配置文件，比如properties、yaml 、yml</p> </li><li> <p>系统环境变量，SpringBoot是可以读取系统环境变量中的配置信息的，但不推荐这么做</p> </li><li> <p>命令行参数，SpringBoot在项目启动的时候运行通过命令行直接传递参数，一般用于临时修改配置的情况</p> </li></ol> 
<h3><a id="6bootstrapymlapplicationyml_52"></a>6、bootstrap.yml和application.yml有何区别</h3> 
<p>这是SpringBoot支持的两个核心配置文件，区别点在于</p> 
<ol><li> <p>boostrap比applicaton优先加载，在应用程序上下文的引导阶段生效，且里面的属性不能被覆盖</p> <p>一般来说我们在SpringCloud Config或者Nacos中会用到它</p> </li><li> <p>application用于SpringBoot项目的自动化配置，一般来说我们会将自己项目的业务配置项写在这里面</p> </li></ol> 
<h3><a id="7SpringBoot_62"></a>7、SpringBoot读取配置的方式有几种</h3> 
<p>SpringBoot常见的读取配置信息的方式有两种：</p> 
<ol start="2"><li>使用@Value配合EL表达式（@Value(“${name}”)）注解直接注入对应的值</li><li>使用@ConfigurationProperties注解把对应的值绑定到一个配置对象，然后将配置对象注入到需要的地方</li></ol> 
<p>推荐使用使用第二种方式，在配置比较多的情况下，操作简单，可读性好</p> 
<h3><a id="8SpringBoot_71"></a>8、SpringBoot项目如何热部署</h3> 
<p>Spring Boot有一个开发工具（DevTools）模块，通过它可以实现SpringBoot项目的热部署</p> 
<p>也就是开发人员将文件更改后，它会自动部署到服务器并自动重启服务器。</p> 
<pre><code class="prism language-XML">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> 
<h3><a id="9SpringBoot_84"></a>9、SpringBoot项目如何实现方法的异步调用</h3> 
<p>异步调用指的是a方法在调用b方法的时候，无需等待b方法执行完毕，就可以继续向下执行</p> 
<p>一般用在a方法无需使用b方法返回结果的场景下，可以在一定程度上提高运行效率</p> 
<p>在SpringBoot中使用异步调用是很简单的，只需要做两个操作就可以了</p> 
<ol><li>在启动类上添加@EnableAsync注解，开启异步调用支持</li><li>在被调用的方法上添加@Async注解</li></ol> 
<pre><code class="prism language-markdown">controller-a(){
    代码1 
    service-a()
    代码3 
}

@Async
service-a(){}
</code></pre> 
<h3><a id="10SpringBoot_106"></a>10、SpringBoot中如何实现定时任务</h3> 
<p>在SpringBoot中使用定时任务主要有两种方式，一个就是使用SpringTask，另一个则是使用第三方框架Quartz</p> 
<p>SpringTask主要是通过@Scheduled注解来实现定时任务触发的，格式如下</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Scheduled</span><span class="token punctuation">(</span>fixedRate <span class="token operator">=</span> <span class="token number">5000</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLocaleString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>主要属性如下：</p> 
<ul><li>fixedRate：按一定的频率执行任务，参数类型为long，单位 ms</li><li>fixedDelay：上一次任务执行完后多久再执行，参数类型为long，单位 ms</li><li>initialDelay：延迟多久再第一次执行任务，参数类型为 long，单位 ms</li><li>cron：使用cron表达式指定任务在特定时间执行</li></ul> 
<h3><a id="11SpringBoot_126"></a>11、SpringBoot中如何解决跨域问题</h3> 
<p>跨域是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制</p> 
<p>当浏览器从一个域名的网页去请求另一个域名的资源时，出现域名、端口、协议任一不同，都属于跨域<br> <img src="https://images2.imgbox.com/2a/bb/iwiRdhmX_o.png" alt="在这里插入图片描述"></p> 
<p>SpringBoot解决跨域很简单，执行添加一个配置类实现WebMvcConfigurer接口然后重写addCorsMappings方法即可</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Configuration</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CorsConfig</span> <span class="token keyword">implements</span> <span class="token class-name">WebMvcConfigurer</span> <span class="token punctuation">{<!-- --></span>
	<span class="token annotation punctuation">@Override</span>
	<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addCorsMappings</span><span class="token punctuation">(</span><span class="token class-name">CorsRegistry</span> registry<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		registry<span class="token punctuation">.</span><span class="token function">addMapping</span><span class="token punctuation">(</span><span class="token string">"/**"</span><span class="token punctuation">)</span>
		<span class="token punctuation">.</span><span class="token function">allowedOrigins</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token comment">//允许跨域访问的路径</span>
		<span class="token punctuation">.</span><span class="token function">allowCredentials</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
		<span class="token punctuation">.</span><span class="token function">allowedMethods</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> <span class="token string">"POST"</span><span class="token punctuation">,</span> <span class="token string">"PUT"</span><span class="token punctuation">,</span> <span class="token string">"DELETE"</span><span class="token punctuation">,</span> <span class="token string">"OPTIONS"</span><span class="token punctuation">)</span><span class="token comment">//运行跨越的请求方式</span>
		<span class="token punctuation">.</span><span class="token function">maxAge</span><span class="token punctuation">(</span><span class="token number">3600</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="12_149"></a>12、如何理解拦截器</h3> 
<p>拦截器是Spring提供的一种拦截机制，目的是实现对指定请求路径进行拦截，然后做成指定的处理</p> 
<p>自定义一个拦截器需要实现HandlerInterceptor，并重写接口中定义的3个方法</p> 
<ol><li>preHandle： 这个方法在Controller处理请求之前被调用，通过方法的返回值可以确定是否放行请求</li><li>postHandle：这个方法在Controller处理请求之后被调用</li><li>afterCompletion：这个方法将在整个请求结束之后被调用，此方法主要用于进行资源清理</li></ol> 
<p><img src="https://images2.imgbox.com/ca/8d/FeM6tAam_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="13_160"></a>13、拦截器和过滤器的区别是什么</h3> 
<p>拦截器和过滤器都可以实现请求的拦截处理，不同点有下面几个：</p> 
<ol><li>技术栈所属不同：过滤器属于JavaWeb技术，依赖Servlet容器；而拦截器是属于Spring的技术</li><li>实现原理不同：拦截器是基于Java的反射机制，而过滤器是基于函数回调</li><li>拦截范围不同：过滤器可以拦截所有请求，而拦截器主要是针对发往controller请求</li><li>拦截位置不同：过滤器在前端控制器前拦截行，而拦截器在前端控制器后拦截</li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/165f1816c3995139d02f979d93f90eff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Bootstrap table插件 隐藏复选框，被选中的行颜色改变</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a23c2cd40e8dd6428c676f098902a6db/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">6、Spring高频面试题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>