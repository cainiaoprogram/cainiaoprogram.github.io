<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>infercnv - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="infercnv" />
<meta property="og:description" content="文章目录 brief安装使用体验输入文件制作运行试试吧结果部分others brief InferCNV is used to explore tumor single cell RNA-Seq data to identify evidence for somatic large-scale chromosomal copy number alterations, such as gains or deletions of entire chromosomes or large segments of chromosomes. This is done by exploring expression intensity of genes across positions of tumor genome in comparison to a set of reference ‘normal’ cells.
通过和‘normal’ cell的基因组位置相比，识别癌细胞基因组对应位置上发生的变化。
染色体畸变的 类型很多的，有结构上的（片段插入，片段缺失，重组，染色体断裂等等），有数量上的（染色体加倍，非整倍体，基因片段gain or lost）等等。
infercnv利用单细胞数据识别这些畸变，让我觉得很不可思议（测序深度，以及3‘或者5’端建库方法，可变剪接等等都会导致结果不可信）。不过很多的文章都在用它解析单细胞数据，我也不能仅仅停留在diss它的位置上，开学吧。
安装 # ubuntu 20 # https://sourceforge." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/038004c50b8f052df0f36f1c0691cff0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-15T10:38:15+08:00" />
<meta property="article:modified_time" content="2023-11-15T10:38:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">infercnv</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#brief_1" rel="nofollow">brief</a></li><li><a href="#_12" rel="nofollow">安装</a></li><li><a href="#_48" rel="nofollow">使用体验</a></li><li><ul><li><ul><li><a href="#_49" rel="nofollow">输入文件制作</a></li><li><a href="#_128" rel="nofollow">运行试试吧</a></li><li><a href="#_189" rel="nofollow">结果部分</a></li><li><a href="#_245" rel="nofollow"></a></li><li><a href="#others_271" rel="nofollow">others</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="brief_1"></a>brief</h2> 
<p>InferCNV is used to explore tumor single cell RNA-Seq data to identify evidence for somatic large-scale chromosomal copy number alterations, such as gains or deletions of entire chromosomes or large segments of chromosomes. This is done by exploring expression intensity of genes across positions of tumor genome in comparison to a set of reference ‘normal’ cells.</p> 
<p>通过和‘normal’ cell的基因组位置相比，识别癌细胞基因组对应位置上发生的变化。</p> 
<p>染色体畸变的 类型很多的，有结构上的（片段插入，片段缺失，重组，染色体断裂等等），有数量上的（染色体加倍，非整倍体，基因片段gain or lost）等等。</p> 
<p>infercnv利用单细胞数据识别这些畸变，让我觉得很不可思议（测序深度，以及3‘或者5’端建库方法，可变剪接等等都会导致结果不可信）。不过很多的文章都在用它解析单细胞数据，我也不能仅仅停留在diss它的位置上，开学吧。</p> 
<p><img src="https://images2.imgbox.com/f8/b7/JI3LK0Os_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_12"></a>安装</h2> 
<pre><code class="prism language-bash"><span class="token comment"># ubuntu 20</span>
<span class="token comment"># https://sourceforge.net/projects/mcmc-jags/files/JAGS/4.x/Source/</span>
<span class="token function">wget</span> https://sourceforge.net/projects/mcmc-jags/files/JAGS/4.x/Source/JAGS-4.3.2.tar.gz
<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> JAGS-4.3.2.tar.gz
<span class="token builtin class-name">cd</span> JAGS-4.3.0
./configure <span class="token parameter variable">--libdir</span><span class="token operator">=</span>/usr/local/lib64
<span class="token function">make</span>
<span class="token function">make</span> <span class="token function">install</span>
</code></pre> 
<pre><code class="prism language-R">if (!requireNamespace("BiocManager", quietly = TRUE))
     install.packages("BiocManager")
BiocManager::install("infercnv")
</code></pre> 
<p>安装成功的验证</p> 
<pre><code class="prism language-R">R
library(infercnv)

infercnv_obj = CreateInfercnvObject(raw_counts_matrix=system.file("extdata", "oligodendroglioma_expression_downsampled.counts.matrix.gz", package = "infercnv"),
                                    annotations_file=system.file("extdata", "oligodendroglioma_annotations_downsampled.txt", package = "infercnv"),
                                    delim="\t",
                                    gene_order_file=system.file("extdata", "gencode_downsampled.EXAMPLE_ONLY_DONT_REUSE.txt", package = "infercnv"),
                                    ref_group_names=c("Microglia/Macrophage","Oligodendrocytes (non-malignant)")) 

infercnv_obj = infercnv::run(infercnv_obj,
                             cutoff=1, # cutoff=1 works well for Smart-seq2, and cutoff=0.1 works well for 10x Genomics
                             out_dir=tempfile(), 
                             cluster_by_groups=TRUE, 
                             denoise=TRUE,
                             HMM=TRUE)
</code></pre> 
<h2><a id="_48"></a>使用体验</h2> 
<h4><a id="_49"></a>输入文件制作</h4> 
<pre><code class="prism language-R"># 内置的raw counts文件
rwa_counts &lt;- read.table(gzfile("/public/home/djs/miniconda3/envs/R4/lib/R/library/infercnv/extdata/oligodendroglioma_expression_downsampled.counts.matrix.gz","r"),sep="\t",header=T)
</code></pre> 
<p>行是基因，列是细胞<br> <img src="https://images2.imgbox.com/48/ec/D5nKosKV_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-R"># 内置的 cell annotation file
annotation_file &lt;- read.table("/public/home/djs/miniconda3/envs/R4/lib/R/library/infercnv/extdata/oligodendroglioma_annotations_downsampled.txt",sep="\t",header=T)
</code></pre> 
<p>文件分为两列，第一列记录细胞名称，第二列记录细胞注释类型，比如normal，malignant。<br> <img src="https://images2.imgbox.com/55/bc/rma1tGmz_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-R"># 内置的基因坐标文件
gene_order &lt;- read.table("/public/home/djs/miniconda3/envs/R4/lib/R/library/infercnv/extdata/gencode_downsampled.EXAMPLE_ONLY_DONT_REUSE.txt",sep="\t",header=T)
</code></pre> 
<p>文件分为四列，第一列记录基因名称，第二列记录基因在哪条染色体上，以及第三四列记录染色体上的起始终止位点。<br> <img src="https://images2.imgbox.com/9f/94/SKkgPjFs_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<p>开始制作输入文件…</p> 
<pre><code class="prism language-R"># 得到最容易得到的表达矩阵
sce &lt;- readRDS("immune.integrated.annotation.rds") # seurat对象
dim(sce@meta.data)
# [1] 57970    13
raw_counts &lt;- as.matrix(sce@assays$RNA@data) # 得到全部细胞的表达矩阵 
# 我这个数据集大约58000个细胞，软件运行的很慢而且再服务器上出图会报错，我打算取一些子集演示一下
# 只取上皮细胞
sce1 &lt;- subset(sce,subset = singleR == "Epithelial_cells")
dim(sce1@meta.data)
# [1] 14938    13
raw_counts &lt;- as.matrix(sce1@assays$RNA@data)
raw_counts[1:5,1:5] # 此时行是基因，列是细胞

# 现在 需要得到细胞的注释信息，一列是细胞名称，一列是细胞类型注释。
head(sce1@meta.data)
celltype &lt;- sce1@meta.data[,"singleR"]
cellname &lt;- rownames(sce1@meta.data)
annotation_file &lt;- as.data.frame(cbind(cellname,celltype))

write.table(annotation_file,file="annotation_file.txt",sep="\t",row.names=F,col.names=F)
</code></pre> 
<pre><code class="prism language-R"># 最后是基因在染色体上的坐标文件，这个因为不同的基因组注释文件以及版本可能有些不一样，应该是bug最多的一个文件了
# 归根揭底其实就是解析GTF/GFF文件
# https://www.gencodegenes.org/pages/data_format.html 这是gencode官网提供的信息，最后还贴心的附上了提取信息的code
cat ~/software/STAR-2.7.7a/genome_gtf/gencode.v40.annotation.gtf |  \
 awk '{if($3=="gene" &amp;&amp; $0~"level (1|2);") {print $10,$14,$12,$1,$4,$5,$7}}'  | \
 sed 's/[";]//g' |sed 's/ /\t/g' | \
 sed  '1i ENSG_id \t gene_symbl \t gene_type \t chr\t start \t end'  &gt; infercnv_gene_order.file.tsv

# 拿到这个这个文件后，再去R里面抓取表达矩阵出现的那些基因
gene_order &lt;- read.table("/public/home/djs/reference/infercnv_gene_order.file.tsv",header=T,sep="\t")
gene_order &lt;- gene_order[!duplicated(gene_order$ENSG_id),]
gene_order[1:5,]

# 很烦人，有些基因的名字不在注释文件中，看了一下大部分基因名字都是因为有后缀
length(rownames(raw_counts))
# [1] 25870
table(rownames(raw_counts) %in% gene_order$ENSG_id)
# FALSE  TRUE
# 6308 19562

# 算了，还是修改表达矩阵吧，也就是把那些没在gene_order中的基因丢了
raw_counts &lt;- raw_counts[which(rownames(raw_counts) %in% gene_order$ENSG_id),]
dim(raw_counts)
# [1] 19562 14938

gene_order_file &lt;- gene_order[which(gene_order$ENSG_id %in% rownames(raw_counts)),c(1,3,4,5)]
write.table(raw_counts,file="raw_counts_file.txt",sep="\t",row.names=T)  # 需要把基因作为行名写入文件
write.table(gene_order_file,file="gene_order_file.txt",sep="\t",row.names=F,col.names=F) # 行列名不需要写入
</code></pre> 
<h4><a id="_128"></a>运行试试吧</h4> 
<pre><code class="prism language-R"># create the infercnv object
infercnv_obj = CreateInfercnvObject(raw_counts_matrix="raw_counts_file.txt",
                                    annotations_file="annotation_file.txt",
                                    delim="\t",
                                    gene_order_file="gene_order_file.txt",
                                    ref_group_names=NULL)
                                    
# perform infercnv operations to reveal cnv signal
infercnv_obj = infercnv::run(infercnv_obj,
                             cutoff=0.1,  # use 1 for smart-seq, 0.1 for 10x-genomics
                             out_dir="output_dir",  # dir is auto-created for storing outputs
                             cluster_by_groups=T,   # cluster
                             denoise=T,
                             HMM=T
                             )
</code></pre> 
<ul><li> <p>ref_group_names参数的使用：<br> Note, if you do not have reference cells, you can set ref_group_names=NULL, in which case the average signal across all cells will be used to define the baseline. This can work well when there are sufficient differences among the cells included<br> 也可以设置为 <code>ref_group_names=c("NK_cell"))</code></p> </li><li> <p>需要注意的是cutoff 值，这是噪音过滤参数：<br> The cutoff value determines which genes will be used for the infercnv analysis. Genes with a mean number of counts across cells will be excluded. For smart-seq (full-length transcript sequencing, typically using cell plate assays rather than droplets), a value of 1 works well. For 10x (and potentially other 3’-end sequencing and droplet assays, where the count matrix tends to be more sparse), a value of 0.1 is found to generally work well.</p> </li><li> <p>inferCNV de-noising filters是为了干什么？还有其他方法吗？<br> These de-noising filter options are available for manipulating the residual expression intensities with the goal of reducing the noise (residual signal in the normal cells) while retaining the signal in tumor cells that could be interpreted as supporting CNV.</p> <p>把normal 细胞的表达信号当作背景信号，其他细胞的表达信号减去背景信号，也就是获取偏离normal 的信号，认为他们是gain or loss CNV。</p> </li></ul> 
<pre><code># 手动指定背景信号值
# A specific threshold deviation from the mean can be set using the 'noise_filter' attribute
 infercnv_obj = infercnv::run(infercnv_obj,
                             cutoff=1, # cutoff=1 works well for Smart-seq2, and cutoff=0.1 works well for 10x Genomics
                             out_dir=out_dir, 
                             cluster_by_groups=T, 
                             plot_steps=F,
                             denoise=T,
                             noise_filter=0.1   ## hard thresholds
                             )

# 更具偏离标准差的距离设定阈值
By default, the hard cutoffs for denoising are computed based on the standard deviation of the residual normal expression values. This thresholding can be adjusted using the 'sd_amplifier' setting.
infercnv_obj = infercnv::run(infercnv_obj,
                             cutoff=1, # cutoff=1 works well for Smart-seq2, and cutoff=0.1 works well for 10x Genomics
                             out_dir=out_dir, 
                             cluster_by_groups=T, 
                             plot_steps=F,
                             denoise=T,
                             sd_amplifier=1.5  ## set dynamic thresholding based on the standard deviation value.
                             )
</code></pre> 
<ul><li> <p>预测CNV的方法以及结果<br> <img src="https://images2.imgbox.com/65/42/JwhFRAnT_o.png" alt="在这里插入图片描述"></p> </li><li> <p>另一个参数细节：<br> By setting infercnv::run(analysis_mode=‘subclusters’), inferCNV will attempt to partition cells into groups having consistent patterns of CNV. CNV prediction (via HMM) would then be performed at the level of the subclusters rather than whole samples.<br> （The methods available for defining tumor subclusters will continue to be expanded. We’ve currently had best success with using <strong>hierarchical clustering based methods</strong>.）</p> </li></ul> 
<h4><a id="_189"></a>结果部分</h4> 
<p>出现最后的 making the final infercnv heatmap才是正常结束，运行时间大应该是14938个细胞13：00-19：00<br> <img src="https://images2.imgbox.com/a2/72/aBNwMbRq_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d8/01/TfqXmwpO_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p>了解一下都是些什么结果然后如何结合seurat对象作图<br> <img src="https://images2.imgbox.com/0a/3c/toUIMnQU_o.png" alt="在这里插入图片描述"></p> </li><li> <p>判定恶性细胞<br> 参考文章：<br> https://cloud.tencent.com/developer/inventory/7049/article/1737138<br> https://cloud.tencent.com/developer/inventory/7049/article/1737241</p> </li></ul> 
<pre><code class="prism language-R"># 读取infercnv.observations.txt文件来计算CNV score

cnv_table &lt;- read.table("plot_out/inferCNV_output2/infercnv.observations.txt", header=T)
# Score cells based on their CNV scores 
# Replicate the table 
cnv_score_table &lt;- as.matrix(cnv_table)
cnv_score_mat &lt;- as.matrix(cnv_table)
# Scoring
# CNV的5分类系统
cnv_score_table[cnv_score_mat &gt; 0 &amp; cnv_score_mat &lt; 0.3] &lt;- "A" #complete loss. 2pts
cnv_score_table[cnv_score_mat &gt;= 0.3 &amp; cnv_score_mat &lt; 0.7] &lt;- "B" #loss of one copy. 1pts
cnv_score_table[cnv_score_mat &gt;= 0.7 &amp; cnv_score_mat &lt; 1.3] &lt;- "C" #Neutral. 0pts
cnv_score_table[cnv_score_mat &gt;= 1.3 &amp; cnv_score_mat &lt;= 1.5] &lt;- "D" #addition of one copy. 1pts
cnv_score_table[cnv_score_mat &gt; 1.5 &amp; cnv_score_mat &lt;= 2] &lt;- "E" #addition of two copies. 2pts
cnv_score_table[cnv_score_mat &gt; 2] &lt;- "F" #addition of more than two copies. 2pts

# Check
table(cnv_score_table[,1])
# Replace with score 
cnv_score_table_pts &lt;- cnv_table
rm(cnv_score_mat)
#  把5分类调整为 3分类系统
cnv_score_table_pts[cnv_score_table == "A"] &lt;- 2
cnv_score_table_pts[cnv_score_table == "B"] &lt;- 1
cnv_score_table_pts[cnv_score_table == "C"] &lt;- 0
cnv_score_table_pts[cnv_score_table == "D"] &lt;- 1
cnv_score_table_pts[cnv_score_table == "E"] &lt;- 2
cnv_score_table_pts[cnv_score_table == "F"] &lt;- 2

# Scores are stored in “cnv_score_table_pts”. Use colSums to add up scores for each cell and store as vector 
cell_scores_CNV &lt;- as.data.frame(colSums(cnv_score_table_pts))
colnames(cell_scores_CNV) &lt;- "cnv_score"
head(cell_scores_CNV)
write.csv(x = cell_scores_CNV, file = "cnv_scores.csv") # 根据这个文件给每个细胞打分或者划高低中等分类然后比较或者可视化
</code></pre> 
<p>我自己的数据集中每个基因的 CNV score都“适中”，大概是因为我没有提供“reference normal cell”，所以上述代码就不搞了。<br> （打完分就可以得到cell barcode，这些cell barcode 结合 seurat object 就可以可视化到UMAP等图中了）<br> <img src="https://images2.imgbox.com/11/9c/GVXf3lsP_o.png" alt="在这里插入图片描述"></p> 
<hr> 
<h4><a id="_245"></a></h4> 
<p>算法思想细节<br> The detailed steps of the inferCNV algorithm involve the following:</p> 
<ul><li> <p>filtering genes: those genes found expressed in fewer than ‘min_cells_per_gene’ are removed from the counts matrix.<br> 把低表达基因基因去除</p> </li><li> <p>normalization for sequencing depth (total sum normalization): read counts per cell are scaled to sum to the median total read count across cells. Instead of a metric such as counts per million (cpm), values are counts per median sum.<br> 这里的normalization方法就很特殊 = （reads / total reads）* median of all sum reads from all cells</p> </li><li> <p>log transformation: individual matrix values (x) are transformed to log(x+1)<br> normalization 后 再log transformation</p> </li><li> <p>center by normal gene expression: the mean value for each gene across normal (reference) cells is subtracted from all cells for corresponding genes. Since this subtraction is performed in log space, this is effectively resulting in log-fold-change values relative to the mean of the normal cells.<br> 每个基因的scale</p> </li><li> <p>thresholding dynamic range for log-fold-change values. Any values with abs(log(x+1)) exceeding ‘max_centered_threshold’ (default=3) are capped at that value.</p> </li><li> <p>chromosome-level smoothing: for each cell, genes ordered along each chromosome have expression intensities smoothed using a weighted running average. By default, this is a window of 101 genes with a pyramidinal weighting scheme.</p> </li><li> <p>centering cells: each cell is centered with its median expression intensity at zero under the assumption that most genes are not in CNV regions.</p> </li><li> <p>adjustment relative to normal cells: The mean of the normals is once again subtracted from the tumor cells. This further compensates for differences that accrued after the smoothing process.</p> </li><li> <p>the log transformation is reverted. This makes the evidence for amplification or deletion more symmetrical around the mean. (note, with loss or gain of one copy, corresponding values 0.5 and 1.5 are not symmetrical in log space. Instead, 0.5 and 2 are symmetrical in log space. Hence, we invert the log transformation to better reflect symmetry in gains and losses).</p> </li></ul> 
<h4><a id="others_271"></a>others</h4> 
<p><img src="https://images2.imgbox.com/11/57/356TcyUJ_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c070eb7a04afd7f60fa5ed146941851d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">小猫爪：嵌入式小知识15-XCP基础简介</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/82a7d7e5e2cff4efbf7fde0ffc63dee5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">html：lang属性设置为中文zh-CN</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>