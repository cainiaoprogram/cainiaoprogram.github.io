<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>TCP/IP协议抓包分析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="TCP/IP协议抓包分析" />
<meta property="og:description" content="目录
一、TCP/IP协议在协议中分层的位置
二、TCP三次握手流程
三、打开wireshark抓包
四、TCP三次握手分析
1、TCP第一次握手
五、四次挥手流程
六、四次挥手抓包分析
一、TCP/IP协议在协议中分层的位置 二、TCP三次握手流程 1、客户端向服务端发送⼀个SYN=1（请求建立连接），并生成一个序列号seq=j。
2、服务端接收到SYN=1后，给客户端发送⼀个SYN=1与ACK=1；并将ack置为j&#43;1;同时生成一个序列号seq=k。
3、客户端接收到会检查ack是否为j&#43;1与ACK是否为1，如果是，则会给服务端发送一个ACK=1与ack=k&#43;1，以及自己的序列号seq=j=1; 服务端接收到会检查ACK是否为1与ack是否为k&#43;1,如果是则代表连接建立成功，两者间可以传递数据。
三、打开wireshark抓包 本地IP：10.168.1.112
百度IP：39.156.66.18
筛选规则：tcp and ip.addr==10.168.1.112 and tcp.port==50830
封包详细信息用来查看协议中的每个字段，各行信息显示对应的不同层级，如下图所示，分别是物理层、数据链路层、网络层、传输层，如果有应用层数据会显示第五层
四、TCP三次握手分析 1、TCP第一次握手 客户端向服务端发送⼀个SYN=1（请求建立连接），并生成一个序列号seq=j（实验中j=0）
源端口50830 ----&gt;目标端口36688
2、服务端接收到SYN=1后，给客户端发送⼀个SYN=1与ACK=1；并将确认序列号ack置为j&#43;1（即SYN&#43;1=0&#43;1=1）;同时生成一个序列号seq=k（实验中k=0）
3、客户端接收到会检查服务端回复的确认序列号ack是否为j&#43;1（即SYN&#43;1=0&#43;1=1）与ACK是否为1，如果是，则会给服务端发送一个ACK=1与ack=k&#43;1（即第二次握手时服务端生成的序列号seq，k&#43;1=0&#43;1=1），以及自己的序列号seq=j=1; 服务端接收到会检查ACK是否为1与ack是否为k&#43;1,如果是则代表连接建立成功，两者间可以传递数据
4、也可直接通过标志位看三次握手的数据包
五、四次挥手流程 1、Client端发起中断连接请求，也就是发送FIN报文。意思是说&#34;我Client端没有数据要发给你了&#34;，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。
2、Server端接到FIN报文后，发送ACK，告诉Client端，“你的请求我收到了，但是我还没准备好，请继续你等我的消息&#34;。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。
3、当Server端确定数据已发送完成，则向Client端发送FIN报文，告诉Client端，”好了，我这边数据发完了，准备好关闭连接了&#34;。
4、Client端收到FIN报文后，就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传
Server端收到ACK后，就知道可以断开连接了。
Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！
六、四次挥手抓包分析 抓包过程中，四次挥手只抓到了三个包的报文，查询了相关资料，说是因为服务器端在给客户端传回的过程中，将两个连续发送的包进行了合并。以下是基于抓到的三个包做的分析，如有错误请指正
1、第一次挥手：Client端发起中断连接请求，也就是发送FIN报文。意思是说&#34;我Client端没有数据要发给你了&#34;，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据
将标志位FIN和ACK置为1，序号seq=306，确认序号ack=21
2、第二次挥手：Server端接到FIN报文后，发送ACK，告诉Client端，“你的请求我收到了，但是我还没准备好，请继续你等我的消息&#34;。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文
此时，服务端回复客户端：FIN和ACK(标志位FIN=1,ACK=1)，确认序列号ack为收到的序列号（即第一次挥手携带的SYN）加1，即ack=306&#43;1=301。序列号seq为收到的确认序列号21
（抓包时第二次挥手和第三次挥手合并了）
3、第四次挥手：Client端收到FIN报文后，就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传
客户端收到服务器发送的FIN之后，发回ACK确认(标志位ACK=1),确认序列号为收到的序号加1，即21&#43;1=22。序列号为收到的确认序列号307
Server端收到ACK后，就知道可以断开连接了。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b64a9f4f9e4cd6f595bdf4e9d5b38e68/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-05-31T22:01:10+08:00" />
<meta property="article:modified_time" content="2022-05-31T22:01:10+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">TCP/IP协议抓包分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E4%B8%80%E3%80%81TCP%2FIP%E5%8D%8F%E8%AE%AE%E5%9C%A8%E5%8D%8F%E8%AE%AE%E4%B8%AD%E5%88%86%E5%B1%82%E7%9A%84%E4%BD%8D%E7%BD%AE-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81TCP%2FIP%E5%8D%8F%E8%AE%AE%E5%9C%A8%E5%8D%8F%E8%AE%AE%E4%B8%AD%E5%88%86%E5%B1%82%E7%9A%84%E4%BD%8D%E7%BD%AE" rel="nofollow">一、TCP/IP协议在协议中分层的位置</a></p> 
<p id="%E4%BA%8C%E3%80%81TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B" rel="nofollow">二、TCP三次握手流程</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%89%93%E5%BC%80wireshark%E6%8A%93%E5%8C%85-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%89%93%E5%BC%80wireshark%E6%8A%93%E5%8C%85" rel="nofollow">三、打开wireshark抓包</a></p> 
<p id="%E5%9B%9B%E3%80%81TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%88%86%E6%9E%90" rel="nofollow">四、TCP三次握手分析</a></p> 
<p id="1%E3%80%81TCP%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B-toc" style="margin-left:40px;"><a href="#1%E3%80%81TCP%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B" rel="nofollow">1、TCP第一次握手</a></p> 
<p id="%E4%BA%94%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%B5%81%E7%A8%8B-toc" style="margin-left:0px;"><a href="#%E4%BA%94%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%B5%81%E7%A8%8B" rel="nofollow">五、四次挥手流程</a></p> 
<p id="%E5%85%AD%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90-toc" style="margin-left:0px;"><a href="#%E5%85%AD%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90" rel="nofollow">六、四次挥手抓包分析</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81TCP%2FIP%E5%8D%8F%E8%AE%AE%E5%9C%A8%E5%8D%8F%E8%AE%AE%E4%B8%AD%E5%88%86%E5%B1%82%E7%9A%84%E4%BD%8D%E7%BD%AE" style="text-align:justify;"><strong>一、TCP/IP</strong><strong>协议在协议中分层的位置</strong></h2> 
<p><img alt="" height="579" src="https://images2.imgbox.com/97/52/MdFroUVz_o.png" width="865"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h2 id="%E4%BA%8C%E3%80%81TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E6%B5%81%E7%A8%8B" style="text-align:justify;"><strong>二、TCP</strong><strong>三次握手流程</strong></h2> 
<p style="margin-left:40.5pt;">1、客户端向服务端发送⼀个SYN=1（请求建立连接），并生成一个序列号seq=j。</p> 
<p style="margin-left:40.5pt;">2、服务端接收到SYN=1后，给客户端发送⼀个SYN=1与ACK=1；并将ack置为j+1;同时生成一个序列号seq=k。</p> 
<p style="margin-left:40.5pt;">3、客户端接收到会检查ack是否为j+1与ACK是否为1，如果是，则会给服务端发送一个ACK=1与ack=k+1，以及自己的序列号seq=j=1; 服务端接收到会检查ACK是否为1与ack是否为k+1,如果是则代表连接建立成功，两者间可以传递数据。</p> 
<h2 id="%E4%B8%89%E3%80%81%E6%89%93%E5%BC%80wireshark%E6%8A%93%E5%8C%85" style="text-align:justify;"><strong>三、打开wireshark抓包</strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;">本地IP：10.168.1.112</p> 
<p style="margin-left:.0001pt;text-align:justify;">百度IP：39.156.66.18</p> 
<p style="margin-left:.0001pt;text-align:justify;">筛选规则：tcp and ip.addr==10.168.1.112 and tcp.port==50830</p> 
<p style="margin-left:.0001pt;text-align:justify;">封包详细信息用来查看协议中的每个字段，各行信息显示对应的不同层级，如下图所示，分别是物理层、数据链路层、网络层、传输层，如果有应用层数据会显示第五层</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="449" src="https://images2.imgbox.com/5e/10/wtRmSa7D_o.png" width="1200"></p> 
<h2 id="%E5%9B%9B%E3%80%81TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%88%86%E6%9E%90" style="margin-left:.0001pt;text-align:justify;"><strong>四、TCP三次握手分析</strong></h2> 
<h3 id="1%E3%80%81TCP%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%8F%A1%E6%89%8B" style="text-align:justify;">1、TCP第一次握手</h3> 
<p style="margin-left:.0001pt;text-align:justify;">客户端向服务端发送⼀个SYN=1（请求建立连接），并生成一个序列号seq=j（实验中j=0）</p> 
<p style="margin-left:.0001pt;text-align:justify;">源端口50830 ----&gt;目标端口36688</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="449" src="https://images2.imgbox.com/ef/df/4wfa6We3_o.png" width="865"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="text-align:justify;">2、服务端接收到SYN=1后，给客户端发送⼀个SYN=1与ACK=1；并将确认序列号ack置为j+1（即SYN+1=0+1=1）;同时生成一个序列号seq=k（实验中k=0）</p> 
<p style="text-align:justify;"><img alt="" height="413" src="https://images2.imgbox.com/ba/54/axlx3yDN_o.png" width="865"></p> 
<p> </p> 
<p style="text-align:justify;">3、客户端接收到会检查服务端回复的确认序列号ack是否为j+1（即SYN+1=0+1=1）与ACK是否为1，如果是，则会给服务端发送一个ACK=1与ack=k+1（即第二次握手时服务端生成的序列号seq，k+1=0+1=1），以及自己的序列号seq=j=1; 服务端接收到会检查ACK是否为1与ack是否为k+1,如果是则代表连接建立成功，两者间可以传递数据</p> 
<p style="text-align:justify;"><img alt="" height="418" src="https://images2.imgbox.com/ec/78/3wEjohb1_o.png" width="865"></p> 
<p> </p> 
<p style="text-align:justify;">4、也可直接通过标志位看三次握手的数据包</p> 
<p style="text-align:justify;"><img alt="" height="175" src="https://images2.imgbox.com/9d/8b/HAqB4dAu_o.png" width="865"> </p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h2 id="%E4%BA%94%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%B5%81%E7%A8%8B" style="text-align:justify;"><strong>五、四次挥手流程</strong></h2> 
<p style="margin-left:40.5pt;">1、Client端发起中断连接请求，也就是发送FIN报文。意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据。</p> 
<p style="margin-left:40.5pt;">2、Server端接到FIN报文后，发送ACK，告诉Client端，“你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文。</p> 
<p style="margin-left:40.5pt;">3、当Server端确定数据已发送完成，则向Client端发送FIN报文，告诉Client端，”好了，我这边数据发完了，准备好关闭连接了"。</p> 
<p style="margin-left:40.5pt;">4、Client端收到FIN报文后，就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传</p> 
<p style="margin-left:40.5pt;">Server端收到ACK后，就知道可以断开连接了。</p> 
<p style="margin-left:40.5pt;">Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，我Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<h2 id="%E5%85%AD%E3%80%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%8A%93%E5%8C%85%E5%88%86%E6%9E%90" style="text-align:justify;"><strong>六、四次挥手抓包分析</strong></h2> 
<p style="margin-left:.0001pt;text-align:justify;">抓包过程中，四次挥手只抓到了三个包的报文，查询了相关资料，说是因为服务器端在给客户端传回的过程中，将两个连续发送的包进行了合并。以下是基于抓到的三个包做的分析，如有错误请指正</p> 
<p style="text-align:justify;">1、第一次挥手：Client端发起中断连接请求，也就是发送FIN报文。意思是说"我Client端没有数据要发给你了"，但是如果你还有数据没有发送完成，则不必急着关闭Socket，可以继续发送数据</p> 
<p style="margin-left:.0001pt;text-align:justify;">将标志位FIN和ACK置为1，序号seq=306，确认序号ack=21</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="411" src="https://images2.imgbox.com/dc/9a/uN9L6bxV_o.png" width="865"></p> 
<p> </p> 
<p style="text-align:justify;">2、第二次挥手：Server端接到FIN报文后，发送ACK，告诉Client端，“你的请求我收到了，但是我还没准备好，请继续你等我的消息"。这个时候Client端就进入FIN_WAIT状态，继续等待Server端的FIN报文</p> 
<p style="margin-left:.0001pt;text-align:justify;">此时，服务端回复客户端：FIN和ACK(标志位FIN=1,ACK=1)，确认序列号ack为收到的序列号（即第一次挥手携带的SYN）加1，即ack=306+1=301。序列号seq为收到的确认序列号21</p> 
<p style="margin-left:.0001pt;text-align:justify;">（抓包时第二次挥手和第三次挥手合并了）</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="487" src="https://images2.imgbox.com/be/72/s4USuIYy_o.png" width="865"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="text-align:justify;">3、第四次挥手：Client端收到FIN报文后，就知道可以关闭连接了，但是他还是不相信网络，怕Server端不知道要关闭，所以发送ACK后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传</p> 
<p style="text-align:justify;"><img alt="" height="500" src="https://images2.imgbox.com/a7/c4/bs9b8co7_o.png" width="865"></p> 
<p> </p> 
<p style="margin-left:.0001pt;text-align:justify;">客户端收到服务器发送的FIN之后，发回ACK确认(标志位ACK=1),确认序列号为收到的序号加1，即21+1=22。序列号为收到的确认序列号307</p> 
<p style="margin-left:.0001pt;text-align:justify;">Server端收到ACK后，就知道可以断开连接了。Client端等待了2MSL后依然没有收到回复，则证明Server端已正常关闭，Client端也可以关闭连接了。Ok，TCP连接就这样关闭了！</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a5fb8a85bfc1bb7b1b7171e6700fffe0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java异常：Throwable</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8d5d57e387374dd82fa968c13e90a751/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Rust Rc&#43;RefCell详解，实现二叉树</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>