<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Orchestrator MySQL主库故障切换的几种类型 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Orchestrator MySQL主库故障切换的几种类型" />
<meta property="og:description" content="Orchestrator 对MySQL主库的故障切换分为自动切换和手动切换。
手动切换又分为recover、force-master-failover、force-master-takeover以及graceful-master-takeover.
1.自动切换 自动切换是主库出现故障后，自动提升新主库，进行故的障切换。
自动切换受到以下条件限制和约束：
主库是downtime的集群不进行故障切换。如果希望忽略集群故障，可以设置downtime。处于故障活跃期的集群不进行故障切换(即in_active_period=1)只对配置项RecoverMasterClusterFilters匹配的集群进行故障切换 会周期检测主库状态。
自动切换，会周期进行故障扫描，如果发现故障，条件满足就会进行故障切换。
故障检测和切换具体由CheckAndRecover()实现，具体调用：
GetReplicationAnalysis()，进行故障扫描executeCheckAndRecoverFunction()，进行故障恢复 2.手动切换 手动切换包括: recover、force-master-failover, force-master-takeover以及graceful-master-takeover。
手动切换不受自动切换中提到的条件限制和约束。
2.1 recover recover 以故障主库以及候选实例candiateKey为参数，调用CheckAndRecover()，进行故障切换。
指定的故障主库必须是故障的，也就是已确认发生故障，如果不是故障的，不进行切换。
2.2 force-master-failover 不论集群主库是否故障，都会进行后续切换操作，需要用户确认已发生故障。
具体步骤：
(1) 故障扫描 forceAnalysisEntry()--&gt;GetReplicationAnalysis()(2) 故障恢复ForceExecuteRecovery(analysisEntry, nil,false)--&gt;executeCheckAndRecoverFunction()，不指定候选主库 最后，老主库成为单独的DB 实例。
2.3 force-master-takeover 同上，需要用户自己判定故障。
force-master-takeover，唯一不同于force-master-failover的点是，force-master-takeover带候选主库(即candidate)，并且候选主库必须是集群主库的直连从库。
其他同force-master-failover。
2.3 graceful-master-takeover 这种切换方式针对的是：老主库是正常的，需要提升新主库，老主库可作为从库。
具体操作步骤包括：
(1)检查候选主库
候选主库必须是集群的主库的直连从库候选主库，没有被禁止提升为主库(即promotion rule 不是must not)候选主库，没有延迟过大(超过20s) (2) 故障扫描，forceAnalysisEntry()--&gt;GetReplicationAnalysis()
(3) 调用hooks：PreGracefulTakeoverProcesses
(4) 如果集群中不只一个副本，将老主库的从库移动到候选主库之下
(5) 停止候选主库的复制，在候选主库上执行stop slave
(6) 设置老主库只读
(7) 使候选主库追上老主库(start slave until)
(8) 进行故障恢复，新主库形成ForceExecuteRecovery(analysisEntry, &amp;destination.Key, false)--&gt;executeCheckAndRecoverFunction()
(9) 将老主库变成新主库的从库
(10) 调用hooks: PostGracefulTakeoverProcesses" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/15c5a3cb605aa7514ca0c54d5dfc6433/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-25T23:23:20+08:00" />
<meta property="article:modified_time" content="2019-08-25T23:23:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Orchestrator MySQL主库故障切换的几种类型</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>Orchestrator 对MySQL主库的故障切换分为自动切换和手动切换。<br> 手动切换又分为recover、force-master-failover、force-master-takeover以及graceful-master-takeover.</p> 
<h2><a id="1_3"></a>1.自动切换</h2> 
<p>自动切换是主库出现故障后，自动提升新主库，进行故的障切换。</p> 
<p>自动切换受到以下条件限制和约束：</p> 
<ul><li>主库是downtime的集群不进行故障切换。如果希望忽略集群故障，可以设置downtime。</li><li>处于故障活跃期的集群不进行故障切换(即in_active_period=1)</li><li>只对配置项RecoverMasterClusterFilters匹配的集群进行故障切换</li></ul> 
<p>会周期检测主库状态。<br> 自动切换，会周期进行故障扫描，如果发现故障，条件满足就会进行故障切换。</p> 
<p>故障检测和切换具体由CheckAndRecover()实现，具体调用：</p> 
<ul><li>GetReplicationAnalysis()，进行故障扫描</li><li>executeCheckAndRecoverFunction()，进行故障恢复</li></ul> 
<h2><a id="2_20"></a>2.手动切换</h2> 
<p>手动切换包括: recover、force-master-failover, force-master-takeover以及graceful-master-takeover。</p> 
<p>手动切换不受自动切换中提到的条件限制和约束。</p> 
<h3><a id="21_recover_26"></a>2.1 recover</h3> 
<p>recover 以故障主库以及候选实例candiateKey为参数，调用CheckAndRecover()，进行故障切换。<br> 指定的故障主库必须是故障的，也就是已确认发生故障，如果不是故障的，不进行切换。</p> 
<h3><a id="22_forcemasterfailover_31"></a>2.2 force-master-failover</h3> 
<p>不论集群主库是否故障，都会进行后续切换操作，需要用户确认已发生故障。</p> 
<p>具体步骤：</p> 
<ul><li>(1) 故障扫描 <code>forceAnalysisEntry()--&gt;GetReplicationAnalysis()</code></li><li>(2) 故障恢复<code>ForceExecuteRecovery(analysisEntry, nil,false)--&gt;executeCheckAndRecoverFunction()</code>，不指定候选主库</li></ul> 
<p>最后，老主库成为单独的DB 实例。</p> 
<h3><a id="23_forcemastertakeover_40"></a>2.3 force-master-takeover</h3> 
<p>同上，需要用户自己判定故障。</p> 
<p>force-master-takeover，唯一不同于force-master-failover的点是，force-master-takeover带候选主库(即candidate)，并且候选主库必须是集群主库的直连从库。<br> 其他同force-master-failover。</p> 
<h3><a id="23_gracefulmastertakeover_46"></a>2.3 graceful-master-takeover</h3> 
<p>这种切换方式针对的是：老主库是正常的，需要提升新主库，老主库可作为从库。</p> 
<p>具体操作步骤包括：</p> 
<ul><li> <p>(1)检查候选主库</p> 
  <ul><li>候选主库必须是集群的主库的直连从库</li><li>候选主库，没有被禁止提升为主库(即promotion rule 不是must not)</li><li>候选主库，没有延迟过大(超过20s)</li></ul> </li><li> <p>(2) 故障扫描，<code>forceAnalysisEntry()--&gt;GetReplicationAnalysis()</code></p> </li><li> <p>(3) 调用hooks：PreGracefulTakeoverProcesses</p> </li><li> <p>(4) 如果集群中不只一个副本，将老主库的从库移动到候选主库之下</p> </li><li> <p>(5) 停止候选主库的复制，在候选主库上执行<code>stop slave</code></p> </li><li> <p>(6) 设置老主库只读</p> </li><li> <p>(7) 使候选主库追上老主库(<code>start slave until</code>)</p> </li><li> <p>(8) 进行故障恢复，新主库形成<code>ForceExecuteRecovery(analysisEntry, &amp;destination.Key, false)--&gt;executeCheckAndRecoverFunction()</code></p> </li><li> <p>(9) 将老主库变成新主库的从库</p> </li><li> <p>(10) 调用hooks: PostGracefulTakeoverProcesses</p> </li></ul> 
<p>之所以称为graceful，是因为老主库不是故障的，首先会让候选主库追上老主库。最后，将老主库作为新主库的从库(但没有执行<code>start slave</code>)。<br> 而force-master-failover、force-master-takeover 不会将老主库作为新主库的从库，老主库成为孤立的实例。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a09e5d697ed3ca8c08f38274029df239/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">tomcat查看部署的所有项目，以及运行状态，可视化工具的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bdd1612bd2326694e6d3aa238fc1fb00/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">记微信小程序 利用canvas压缩图片 并进行base64</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>