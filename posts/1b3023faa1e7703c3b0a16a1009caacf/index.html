<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>分析 WebAssembly 二进制文件 - Wasm 逆向工程 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="分析 WebAssembly 二进制文件 - Wasm 逆向工程" />
<meta property="og:description" content="我们最近发表了一篇关于WebAssembly (Wasm)的安全问题和基本概念的博文。作为后续，这篇文章将介绍 Wasm 应用程序的逆向工程。考虑一下您遇到未知 Wasm 应用程序的场景，您需要弄清楚它的作用。你将如何分析它？目前几乎没有任何关于该主题的有用文档，因此我们决定部分填补这一空白。
Wasm 应用程序可以通过不同的方式进行分析。今天我们将通过一个非常简单的应用程序来介绍 Chrome 内置的 Wasm 调试功能。随着我们的进行，一些理论将被介绍。
想要直接了解更多技术内容的不耐烦的读者可以从附录部分获取 HTML 文件 test.html，然后直接跳转到“调试我们的示例应用程序”部分。
为什么要分析 Wasm？ 为什么我们首先对分析 Wasm 应用程序感兴趣？在深入研究动手技术之前，让我们回答这个问题。
在 Forcepoint，我们对恶意行为者如何利用新兴技术和技术感兴趣。每当出现新的威胁时，例如新的勒索软件系列、物联网蠕虫或更不寻常的东西，安全研究人员都希望分析该恶意代码的功能。当我们知道恶意软件是如何工作的，并且我们知道它的属性时，我们可以编写签名来获得保护。
存在许多用于分析传统恶意软件的工具，无论是混淆的 JavaScript、恶意 Flash 对象、可移植可执行文件 (PE) 还是其他东西。存在一种行之有效的方法来分析这些类型的威胁。
正如我们在本系列的第一篇文章中提到的那样，Wasm 的情况有所不同。几乎没有关于如何分析 Wasm 应用程序的文档，而且大多数常见的逆向工程工具还不了解 Wasm。这篇博文试图阐明对 Wasm 二进制文件的逆向工程。
创建示例“Hello World”Wasm 应用程序 让我们从创建一个简单的 Wasm 应用程序开始，稍后我们将对其进行分析。我们将在浏览器中运行应用程序并使用 Chrome 的开发者工具对其进行分析。
要在浏览器中运行 Wasm 应用程序，我们需要一个 HTML 文件来加载和执行 Wasm 二进制文件。让我们来看看创建这个 HTML 文件的过程。（如前所述，我们最终将获得本文末尾附录中列出的文件。）
从以下骨架开始（我们将进一步修改）并将其保存为名为 test.html 的文件：
&lt;html&gt; &lt;script&gt; function test() { } &lt;/script&gt; &lt;body onLoad=&#34;test()&#34;&gt; &lt;/body&gt; &lt;/html&gt; 为了便于设置并避免安装任何工具，让我们使用一个名为WasmFiddler的在线 Web 应用程序来生成我们的 Wasm。在 WasmFiddler 中，键入以下简单程序：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1b3023faa1e7703c3b0a16a1009caacf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-18T19:32:25+08:00" />
<meta property="article:modified_time" content="2022-04-18T19:32:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">分析 WebAssembly 二进制文件 - Wasm 逆向工程</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>我们最近发表了一篇关于WebAssembly (Wasm)的安全问题和基本概念的博文。作为后续，这篇文章将介绍 Wasm 应用程序的逆向工程。考虑一下您遇到未知 Wasm 应用程序的场景，您需要弄清楚它的作用。你将如何分析它？目前几乎没有任何关于该主题的有用文档，因此我们决定部分填补这一空白。</p> 
<p>Wasm 应用程序可以通过不同的方式进行分析。今天我们将通过一个非常简单的应用程序来介绍 Chrome 内置的 Wasm 调试功能。随着我们的进行，一些理论将被介绍。</p> 
<p>想要直接了解更多技术内容的不耐烦的读者可以从附录部分获取 HTML 文件 test.html，然后直接跳转到“调试我们的示例应用程序”部分。</p> 
<h2><a id="_Wasm_6"></a>为什么要分析 Wasm？</h2> 
<p>为什么我们首先对分析 Wasm 应用程序感兴趣？在深入研究动手技术之前，让我们回答这个问题。</p> 
<p>在 Forcepoint，我们对恶意行为者如何利用新兴技术和技术感兴趣。每当出现新的威胁时，例如新的勒索软件系列、物联网蠕虫或更不寻常的东西，安全研究人员都希望分析该恶意代码的功能。当我们知道恶意软件是如何工作的，并且我们知道它的属性时，我们可以编写签名来获得保护。</p> 
<p>存在许多用于分析传统恶意软件的工具，无论是混淆的 JavaScript、恶意 Flash 对象、可移植可执行文件 (PE) 还是其他东西。存在一种行之有效的方法来分析这些类型的威胁。</p> 
<p>正如我们在本系列的第一篇文章中提到的那样，Wasm 的情况有所不同。几乎没有关于如何分析 Wasm 应用程序的文档，而且大多数常见的逆向工程工具还不了解 Wasm。这篇博文试图阐明对 Wasm 二进制文件的逆向工程。</p> 
<h2><a id="Hello_WorldWasm__16"></a>创建示例“Hello World”Wasm 应用程序</h2> 
<p>让我们从创建一个简单的 Wasm 应用程序开始，稍后我们将对其进行分析。我们将在浏览器中运行应用程序并使用 Chrome 的开发者工具对其进行分析。</p> 
<p>要在浏览器中运行 Wasm 应用程序，我们需要一个 HTML 文件来加载和执行 Wasm 二进制文件。让我们来看看创建这个 HTML 文件的过程。（如前所述，我们最终将获得本文末尾附录中列出的文件。）</p> 
<p>从以下骨架开始（我们将进一步修改）并将其保存为名为 test.html 的文件：</p> 
<pre><code>&lt;html&gt;
&lt;script&gt;
  function test() {
  }
&lt;/script&gt;
&lt;body onLoad="test()"&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<p>为了便于设置并避免安装任何工具，让我们使用一个名为WasmFiddler的在线 Web 应用程序来生成我们的 Wasm。在 WasmFiddler 中，键入以下简单程序：</p> 
<pre><code>void hello() {
  printf("Hello World\n");
}
</code></pre> 
<p>然后单击“构建”，如下面的屏幕截图所示：<br> <img src="https://images2.imgbox.com/24/16/wg5DVWX6_o.png" alt="在这里插入图片描述"><br> 图 1：使用 WasmFiddler 编译 Wasm 应用程序。<br> 在上面屏幕截图的右侧，我们看到了一个名为 utf8ToString() 的函数。将该函数复制并粘贴到我们 HTML 页面的 JavaScript 部分，将其放在 test() 函数上方。</p> 
<p>仍然看屏幕截图的右侧，我们可以看到函数 utf8ToString() 之后的几行 JavaScript：</p> 
<pre><code>let m = new WebAssembly.Instance(new WebAssembly.Module(buffer));
let h = new Uint8Array(m.exports.memory.buffer);
let p = m.exports.hello();
</code></pre> 
<p>复制这些行并将它们粘贴到 test() 函数中。这些行将从定义在名为“buffer”的数组中的代码中实例化我们的 Wasm，然后执行我们的 hello() 函数。</p> 
<p>那么我们如何真正定义这个缓冲区的内容（Wasm 代码）呢？在 WasmFiddler 中，单击源代码下方的下拉菜单（图 1 中显示“文本格式”的菜单），然后选择“代码缓冲区”。<br> <img src="https://images2.imgbox.com/20/30/yH8Fc2Bw_o.png" alt="在这里插入图片描述"><br> 图 2：查看 WasmFiddler 中的代码缓冲区。</p> 
<p>WasmFiddler 现在将生成二进制 Wasm 代码并将其放入 JavaScript 缓冲区。你应该得到这个（为了简洁而缩短）：</p> 
<pre><code>var wasmCode = new Uint8Array([0,97,115,109,1,0,0,0,...,108,100,0]);
</code></pre> 
<p>注意：如果你只是得到一个空数组（“var wasmCode = new Uint8Array([null]);”），那么你忘了先编译源代码。在这种情况下，单击构建并重试。</p> 
<p>复制此缓冲区并将其粘贴到我们的 test() 函数的开头。将数组从“wasmCode”重命名为“buffer”以匹配由 WasmFiddler 生成的其他代码的命名。</p> 
<p>如果您还记得我们在本系列的第一篇博文中，Wasm 应用程序无法自行将文本打印到屏幕上。我们需要定义一个 JavaScript 函数，我们的 Wasm 代码中的 printf() 调用可以使用该函数。在 WasmFiddler 中，在下拉菜单中选择 Text Format 以查看我们编译的 Wasm 应用程序的文本表示：<br> <img src="https://images2.imgbox.com/42/4d/HHewSnr9_o.png" alt="在这里插入图片描述"><br> 图 4： puts() 函数的导入模板。</p> 
<p>复制上面看到的“wasmImports”定义并将其粘贴到我们的 JavaScript test() 函数的开头。然后我们需要将此导入定义提供给 Wasm 的实例化。通过使用以下实例化来做到这一点：</p> 
<pre><code>var m = new WebAssembly.Instance(new WebAssembly.Module(buffer),wasmImports);
</code></pre> 
<p>最后，让我们定义 puts() 函数在调用时应该做什么。将其更改为以下内容：</p> 
<pre><code>puts: function puts (index) {
  alert(utf8ToString(h, index));
}
</code></pre> 
<p>现在我们已经完成了构建演示程序的所有必要步骤。在 Chrome 中加载我们的文件 test.html 会给我们一个警告：<br> <img src="https://images2.imgbox.com/fe/b1/jk0o9buw_o.png" alt="在这里插入图片描述"><br> 图 5：Chrome 中的警报。</p> 
<p>我们可以看到 Wasm 代码成功调用了我们的外部函数。</p> 
<p>注意：如果您没有看到弹出窗口，那么问题可能是您的浏览器不支持 Wasm。在这种情况下，请尝试使用更新的浏览器，因为所有主流浏览器的最新版本都应该支持 Wasm。</p> 
<h2><a id="_92"></a>调试我们的示例应用程序</h2> 
<p>现在我们终于可以使用 Chrome 开发者工具进行调试了。</p> 
<p>在 Chrome 中打开 test.html 文件后，启动 Chrome 开发者工具（按 F12）并选择顶部的 Sources 选项卡。然后按 Ctrl+R 重新加载页面。现在出现一个带有文本“wasm”的小云图标。展开它以及它下面的项目。选择 wasm 子树下的叶子条目。您现在应该看到如下内容：<br> <img src="https://images2.imgbox.com/65/7c/O7H30wPI_o.png" alt="在这里插入图片描述"><br> 图 6：Chrome 开发者工具</p> 
<p>让我们单步执行这个函数，以便更好地理解它的作用。单击以“i32”开头的行的左侧以设置断点。一个蓝色条将变为可见，表示已设置断点。接下来，按 Ctrl+R 再次重新加载页面。执行现在将在断点处停止。此时 Wasm 堆栈为空。现在按下调试器中的 Step Over 按钮（F10 或带有弯曲箭头的图标）以执行指令“i32.const 16”，这会将 16 的值放入堆栈：<br> <img src="https://images2.imgbox.com/2f/5e/TlO8zibo_o.png" alt="在这里插入图片描述"><br> 图 7：值 16 放入堆栈。</p> 
<p>Wasm 中的所有函数都有编号，函数编号 0 对应于 Wasm 从 JavaScript 导入的函数“puts”（函数编号 1 是“hello”函数）。因此，下一条指令 call 0 对应调用 printf/puts 函数，栈上的值 ‘16’ 就是参数。</p> 
<p>值“16”如何对应字符串“Hello World”？这个值实际上是一个指向 Wasm 应用程序内存空间中地址的指针。Chrome 的调试器让我们通过展开全局树来查看 Wasm 应用程序的内存：<br> <img src="https://images2.imgbox.com/76/28/kpnbTC0I_o.png" alt="在这里插入图片描述"><br> 图 8：查看 Wasm 应用程序的内存。</p> 
<p>让我们看看内存中的第 16 位：<br> <img src="https://images2.imgbox.com/8b/c9/pcFfJVXq_o.png" alt="在这里插入图片描述"><br> 图 9：Wasm 应用程序内存中的“Hello World”。</p> 
<p>正在运行的 Wasm 应用程序的内存空间实际上是作为 JavaScript 数组实现的。该数组在负责加载 Wasm 应用程序的 HTML 文件中声明。在上面的示例中，以下行声明了变量“h”，其中包含应用程序的内存空间：</p> 
<p>让 h = new Uint8Array(m.exports.memory.buffer);<br> 现在再次按下 Step Over 按钮以执行呼叫。这最终会给我们 JavaScript 警报。</p> 
<h2><a id="_118"></a>结论</h2> 
<p>我们现在已经成功地逆向设计了我们的第一个简单的 Wasm 程序。这个例子非常简单，但我们必须从基础开始。</p> 
<p>在逆向过程中，我们了解了 Wasm 如何通过调用在 JavaScript 中声明的导入函数与外部环境进行交互。此外，我们还了解了 JavaScript 和 Wasm 之间如何共享内存。</p> 
<p>Forcepoint 安全实验室将继续监控 WASM 的发展，并酌情提供更新。</p> 
<h2><a id="_125"></a>参考</h2> 
<p>WasmFiddle，在线编译 Wasm：https 😕/wasdk.github.io/WasmFiddle/?wvzhb</p> 
<p>有关如何在浏览器的调试器中调试 Wasm 的视频：https 😕/www.youtube.com/watch?v=R1WtBkMeGds</p> 
<p>在 JavaScript 和 Wasm 之间传递值：https 😕/hacks.mozilla.org/2017/07/memory-in-webassembly-and-why-its-safer-than-you-think/</p> 
<h2><a id="testhtml_132"></a>附录：test.html</h2> 
<p>为了便于参考，这里是我们创建并分析的整个 test.html 文件：</p> 
<pre><code>&lt;html&gt;
&lt;script&gt;
function utf8ToString(h, p) {
  let s = "";
  for (i = p; h[i]; i++) {
    s += String.fromCharCode(h[i]);
  }
  return s;
}

function test() {
  var wasmImports = {
    env: {
      puts: function puts (index) {
        alert(utf8ToString(h, index));
      }
    }
  };
  var buffer = new Uint8Array([0,97,115,109,1,0,0,0,1,137,128,128,128,0,2,
    96,1,127,1,127,96,0,0,2,140,128,128,128,0,1,3,101,110,118,4,112,117,
    116,115,0,0,3,130,128,128,128,0,1,1,4,132,128,128,128,0,1,112,0,0,5,
    131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,146,128,128,128,0,2,6,
    109,101,109,111,114,121,2,0,5,104,101,108,108,111,0,1,10,141,128,128,
    128,0,1,135,128,128,128,0,0,65,16,16,0,26,11,11,146,128,128,128,0,1,0,
    65,16,11,12,72,101,108,108,111,32,87,111,114,108,100,0]);
  let m = new WebAssembly.Instance(new WebAssembly.Module(buffer),wasmImports);
  let h = new Uint8Array(m.exports.memory.buffer);
  m.exports.hello();
}
&lt;/script&gt;
&lt;body onLoad="test()"&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/609c76b369532474ebb8c09a60372b77/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">无线渗透-----aircrack-ng破解WEP加密</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/66a82580d934f75e38e505ee8a0e9333/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">VOSviewer | （二）入门-分析web of science</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>