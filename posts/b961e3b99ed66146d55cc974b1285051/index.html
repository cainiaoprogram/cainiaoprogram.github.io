<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>华为ARP代理的三种方式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="华为ARP代理的三种方式" />
<meta property="og:description" content="注：使用华为设备
三种类型的ARP： 路由式arp：
使用场景：
路由器或者交换机三层转发的情况下
原理：
也就是普通的arp代理，当PC1没有网关时去ping不是同一网段的设备（直接封装目的IP的请求报文），到达了最近的路由器时，因为为广播帧，路由器会拆包查看，一般情况下请求的IP地址不是自己的，不会处理，但是开启了的路由的arp代理后，如果发现目的IP地址是自己有相应的路由表，并且出接口不是原来的接口，这时就会按照路由表项路由表的出接口请求ARP地址（如果是直连，直接请求，如果不是直连，请求下一跳），然后会将自己的ARP地址发送个请求端，让对方来找自己就行了，相当于自己就是一个中间人，帮助别人转发。
命令：在相应接收的接口下开启：arp-proxy enable //三层交换机是在对应的vlanif接口下使用
Vlan内ARP：
使用场景：
Vlan内的arp代理是在隔离端口处使用的，仅仅对二层隔离有效果（三层的端口隔离没有效果），双方设备处于同一个网段，在同一个vlan，如果设置了隔离的端口，就不能正常的互相通信了，但是我们在S1上的对应vlan上开启了arp代理，仍然PC1和PC2可以通信。
原理：
PC1发送arp报文请求PC2的信息，S1不会将从与S1相连的接口收到的信息通过二层转发从与PC2相连的接口发送出去。
如果开启了arp代理，当S1收到了PC1发送给PC2的信息时同样不会进行二层的发送，而是SW检查打上的tag和请求的IP地址从而将报文从允许此tag的接口上发送出去（不包括原来的接口），这样就是通过S1向PC2请求MAC地址。PC2进行arp报文回复，S1收到回复报文后将自己接口的MAC地址通过查找MAC地址表从与PC1相连的接口发送出去，完成了ARP代理，以后PC1其实都是将发送给PC2的报文发送给了S1进行代处理S1再进行转发，避免了两个接口间无法进行正常通信。
命令：
interface Vlanif1 //进入双方的都在的vlan中
ip address 10.1.1.254 255.255.255.0 //arp代理是三层技术，需要配置ip地址
arp-proxy inner-sub-vlan-proxy enable //开启区域内的arp代代理
Vlan间ARP：
使用场景：
Vlan间arp代理是使用在super vlan中的，也就是同一网段，不同vlan间的arp代理
原理：
因为目的地址在同一网段，PC发送arp请求信息的时候是直接请求对面的MAC地址的，并且会打上自己网段的tag，这时候super vlan会检测sub vlan间的通信（正常情况下只有本vlan的三层接口才会检测），查看arp请求报文的IP地址，正常情况下发现对方的IP地址不是自己就不做任何操作，所以arp请求报文就只能在原来的vlan泛洪，但是目标主机确是在另外一个vlan，所以无法正常请求到。当开启了arp区域间代理的时候，super vlan发现了arp请求报文，并且请求的地址和自己是同一网段的主机IP，它会知道这是他sub vlan的报文，但是到底是哪个sub vlan并不清楚，所以打上其余sub vlan的tag从可以通过对应tag的出接口发送出去，这样当arp请求报文回复以后，带有的tag就是对方所在sub vlan的tag，这样交换机就获取的了对方的MAC地址，现在就只需要将自己的MAC地址封装进入arp回复消息发送给请求端即可，回复的具体物理端口需要查看MAC地址表进行，由于PC请求的时候SW已经在相应的接口上学习到了，现在只需要从这个接口发送出去即可。
命令：
interface Vlanif1 //进入双方的都在的vlan中
ip address 10.1.1.254 255.255.255.0 //arp代理是三层计算，需要配置ip地址
arp-proxy inter-sub-vlan-proxy enable //开启区域间的arp代理
总结： 相同点：
3种arp代理都是都是将自己接口的MAC地址发送回复给对方（对方请求的都不是自己的MAC）做一个善意的欺骗，帮助别人进行通信过程。并且既然要进行arp的代理，就必须解封装到网络层，然后被识别，因为arp请求报文都是广播的报文，肯定是能够被对应的三层接口进行接收的（聚合vlan中因为super vlan和sub vlan进行了相互的关联，所以super vlan的接口也会处理sub vlan发送来的arp报文）。
不同点：
应用的环境不同中，路由arp的环境是一个路由器或者三层交换机连接了两个不同的网段，两台互相通信的设备在这两个不同的网段，并且需要请求的设备没有设置网关，这时候请求的设备会直接对方的MAC地址，当开启了ARP代理后接受的接口会帮助处理。
Vlan内路由适用于端口二层隔离的环境，这个在双方设备在同一个vlan中，只不过开启了二层隔离，当在对应vlan的接口上创建了IP地址后，配置了arp代理，arp请求报文虽然不能直接发送到对方，但是相应的vlanif接口会代为处理，发送arp请求报文发往其他允许其vlan tag通过的物理接口，得到回复后，将自己的MAC地址返回给原请求设备。以后进行的二层通信，都只需要将报文发送给S1，因为是S1vlanif接口的MAC地址，关于解封装到网络层查看，发现目的IP地址不是自己，然后查路由表，转发到相应的接口即可。
Vlan间arp代理使用在聚合vlan中，也就是在super vlan的接口上进行配置，super vlan关联sub vlan以后会处理sub vlan的信息，例如arp广播报文，虽然是sub vlan接收到的，但是也会转发到super vlan的接口下查看，这个时候如果开启了arp代理，super vlan会向其sub vlan关联的接口发送对应的arp请求消息代理请求。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b961e3b99ed66146d55cc974b1285051/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-13T11:07:29+08:00" />
<meta property="article:modified_time" content="2020-12-13T11:07:29+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">华为ARP代理的三种方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>注：使用华为设备</p> 
<h3><a id="ARP_2"></a>三种类型的ARP：</h3> 
<p><strong>路由式arp：</strong><br> <img src="https://images2.imgbox.com/02/cf/UEPmPWSR_o.png" alt="在这里插入图片描述"><br> 使用场景：<br> 路由器或者交换机三层转发的情况下</p> 
<p>原理：<br> 也就是普通的arp代理，当PC1没有网关时去ping不是同一网段的设备（直接封装目的IP的请求报文），到达了最近的路由器时，因为为广播帧，路由器会拆包查看，一般情况下请求的IP地址不是自己的，不会处理，但是开启了的路由的arp代理后，如果发现目的IP地址是自己有相应的路由表，并且出接口不是原来的接口，这时就会按照路由表项路由表的出接口请求ARP地址（如果是直连，直接请求，如果不是直连，请求下一跳），然后会将自己的ARP地址发送个请求端，让对方来找自己就行了，相当于自己就是一个中间人，帮助别人转发。</p> 
<p>命令：在相应接收的接口下开启：arp-proxy enable //三层交换机是在对应的vlanif接口下使用</p> 
<p><strong>Vlan内ARP：</strong><br> <img src="https://images2.imgbox.com/c3/95/V8TWPzKj_o.png" alt="在这里插入图片描述"><br> 使用场景：<br> Vlan内的arp代理是在隔离端口处使用的，仅仅对二层隔离有效果（三层的端口隔离没有效果），双方设备处于同一个网段，在同一个vlan，如果设置了隔离的端口，就不能正常的互相通信了，但是我们在S1上的对应vlan上开启了arp代理，仍然PC1和PC2可以通信。</p> 
<p>原理：<br> PC1发送arp报文请求PC2的信息，S1不会将从与S1相连的接口收到的信息通过二层转发从与PC2相连的接口发送出去。<br> 如果开启了arp代理，当S1收到了PC1发送给PC2的信息时同样不会进行二层的发送，而是SW检查打上的tag和请求的IP地址从而将报文从允许此tag的接口上发送出去（不包括原来的接口），这样就是通过S1向PC2请求MAC地址。PC2进行arp报文回复，S1收到回复报文后将自己接口的MAC地址通过查找MAC地址表从与PC1相连的接口发送出去，完成了ARP代理，以后PC1其实都是将发送给PC2的报文发送给了S1进行代处理S1再进行转发，避免了两个接口间无法进行正常通信。</p> 
<p>命令：<br> interface Vlanif1 //进入双方的都在的vlan中<br> ip address 10.1.1.254 255.255.255.0 //arp代理是三层技术，需要配置ip地址<br> arp-proxy inner-sub-vlan-proxy enable //开启区域内的arp代代理</p> 
<p><strong>Vlan间ARP：</strong><br> <img src="https://images2.imgbox.com/18/2c/V1mqly5V_o.png" alt="在这里插入图片描述"><br> 使用场景：<br> Vlan间arp代理是使用在super vlan中的，也就是同一网段，不同vlan间的arp代理</p> 
<p>原理：<br> 因为目的地址在同一网段，PC发送arp请求信息的时候是直接请求对面的MAC地址的，并且会打上自己网段的tag，这时候super vlan会检测sub vlan间的通信（正常情况下只有本vlan的三层接口才会检测），查看arp请求报文的IP地址，正常情况下发现对方的IP地址不是自己就不做任何操作，所以arp请求报文就只能在原来的vlan泛洪，但是目标主机确是在另外一个vlan，所以无法正常请求到。当开启了arp区域间代理的时候，super vlan发现了arp请求报文，并且请求的地址和自己是同一网段的主机IP，它会知道这是他sub vlan的报文，但是到底是哪个sub vlan并不清楚，所以打上其余sub vlan的tag从可以通过对应tag的出接口发送出去，这样当arp请求报文回复以后，带有的tag就是对方所在sub vlan的tag，这样交换机就获取的了对方的MAC地址，现在就只需要将自己的MAC地址封装进入arp回复消息发送给请求端即可，回复的具体物理端口需要查看MAC地址表进行，由于PC请求的时候SW已经在相应的接口上学习到了，现在只需要从这个接口发送出去即可。</p> 
<p>命令：<br> interface Vlanif1 //进入双方的都在的vlan中<br> ip address 10.1.1.254 255.255.255.0 //arp代理是三层计算，需要配置ip地址<br> arp-proxy inter-sub-vlan-proxy enable //开启区域间的arp代理</p> 
<h3><a id="_41"></a><strong>总结：</strong></h3> 
<p>相同点：<br> 3种arp代理都是都是将自己接口的MAC地址发送回复给对方（对方请求的都不是自己的MAC）做一个善意的欺骗，帮助别人进行通信过程。并且既然要进行arp的代理，就必须解封装到网络层，然后被识别，因为arp请求报文都是广播的报文，肯定是能够被对应的三层接口进行接收的（聚合vlan中因为super vlan和sub vlan进行了相互的关联，所以super vlan的接口也会处理sub vlan发送来的arp报文）。</p> 
<p>不同点：<br> 应用的环境不同中，路由arp的环境是一个路由器或者三层交换机连接了两个不同的网段，两台互相通信的设备在这两个不同的网段，并且需要请求的设备没有设置网关，这时候请求的设备会直接对方的MAC地址，当开启了ARP代理后接受的接口会帮助处理。</p> 
<p>Vlan内路由适用于端口二层隔离的环境，这个在双方设备在同一个vlan中，只不过开启了二层隔离，当在对应vlan的接口上创建了IP地址后，配置了arp代理，arp请求报文虽然不能直接发送到对方，但是相应的vlanif接口会代为处理，发送arp请求报文发往其他允许其vlan tag通过的物理接口，得到回复后，将自己的MAC地址返回给原请求设备。以后进行的二层通信，都只需要将报文发送给S1，因为是S1vlanif接口的MAC地址，关于解封装到网络层查看，发现目的IP地址不是自己，然后查路由表，转发到相应的接口即可。</p> 
<p>Vlan间arp代理使用在聚合vlan中，也就是在super vlan的接口上进行配置，super vlan关联sub vlan以后会处理sub vlan的信息，例如arp广播报文，虽然是sub vlan接收到的，但是也会转发到super vlan的接口下查看，这个时候如果开启了arp代理，super vlan会向其sub vlan关联的接口发送对应的arp请求消息代理请求。</p> 
<p>参考资料：华为培训教材</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d25a6d6d7c0e56be127ef647a6883e5e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">到底什么是载波聚合（CA）？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/39bf2c4e2535f1fcf68bc4a3ffbb2975/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mobaxterm连接ubuntu</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>