<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>避免HashMap扩容的正确姿势 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="避免HashMap扩容的正确姿势" />
<meta property="og:description" content="设置HashMap的初始容量 HashMap在Java的使用中占据着很重要的地位，平时使用的时候，相信很多Java程序员都知道在定义HashMap的时候，给它设置一个初始容量，以便减少hashMap扩容（resize）带来的额外开销，比如像我同（zi）事（ji）的这段代码：
@Test public void longLongAGo() { int count = 1000000; System.out.println(&#34;---------------- 不设置hashMap初始容量 ------------&#34;); long start = System.currentTimeMillis(); HashMap&lt;Integer, Object&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; count; i&#43;&#43;) { map.put(i, UUID.randomUUID()); } long end = System.currentTimeMillis(); System.out.println(&#34;添加1000000个元素耗时：&#34; &#43; (end - start)); System.out.println(&#34;---------------- 设置hashMap初始容量 -------------------&#34;); long start1 = System.currentTimeMillis(); HashMap&lt;Integer, Object&gt; map1 = new HashMap&lt;&gt;(count); for (int i = 0; i &lt; count; i&#43;&#43;) { map1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9b9938e364d546662293786a7ef4a5e3/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-19T23:06:09+08:00" />
<meta property="article:modified_time" content="2021-04-19T23:06:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">避免HashMap扩容的正确姿势</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>设置HashMap的初始容量</h3> 
<p><code>HashMap</code>在Java的使用中占据着很重要的地位，平时使用的时候，相信很多Java程序员都知道在定义<code>HashMap</code>的时候，给它设置一个初始容量，以便减少hashMap扩容（resize）带来的额外开销，比如像我同（zi）事（ji）的这段代码：</p> 
<pre><code class="language-java">@Test
public void longLongAGo() {
    int count = 1000000;

    System.out.println("---------------- 不设置hashMap初始容量 ------------");
    long start = System.currentTimeMillis();
    HashMap&lt;Integer, Object&gt; map = new HashMap&lt;&gt;();
    for (int i = 0; i &lt; count; i++) {
        map.put(i, UUID.randomUUID());
    }
    long end = System.currentTimeMillis();
    System.out.println("添加1000000个元素耗时：" + (end - start));

    System.out.println("---------------- 设置hashMap初始容量 -------------------");
    long start1 = System.currentTimeMillis();
    HashMap&lt;Integer, Object&gt; map1 = new HashMap&lt;&gt;(count);
    for (int i = 0; i &lt; count; i++) {
        map1.put(i, UUID.randomUUID());
    }
    long end1 = System.currentTimeMillis();
    System.out.println("添加1000000个元素耗时：" + (end1 - start1));
}
</code></pre> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/4f/4b/nTJNCh9U_o.png"></p> 
<p>我同事说他在初始化的时候设定了map的容量，不会在添加元素的过程中进行自动扩容了，大大提高了性能，从结果看确实如此！</p> 
<p>所以，集合初始化时，指定集合初始值大小能提升性能。</p> 
<p>然鹅，我抱着怀疑的态度，对比了设置初始容量和不设置初始容量时，hashMap的扩展次数，当设置初始容量为1000000时，容器并不是想象中的不扩容了，而是也扩容了1次：<br>  </p> 
<pre><code class="language-java">@SneakyThrows
@Test
public void testing() {
    int count = 1000000;

    System.out.println("---------------- 初始化hashMap容量为1000000 ------------");
    int resizeCount = 0;
    HashMap&lt;Integer, Object&gt; map = new HashMap&lt;&gt;(count);
    Method capacityMethod = map.getClass().getDeclaredMethod("capacity");
    capacityMethod.setAccessible(true);
    int capacity = (int) capacityMethod.invoke(map);
    System.out.println("初始容量：" + capacity);
    for (int i = 0; i &lt; count; i++) {
        map.put(i, UUID.randomUUID());
        int curCapacity = (int) capacityMethod.invoke(map);
        if (curCapacity &gt; capacity) {
            System.out.println("当前容量：" + curCapacity);
            resizeCount++;
            capacity = curCapacity;
        }
    }
    System.out.println("hashMap扩容次数：" + resizeCount);

    System.out.println("---------------- 不初始化hashMap容量 -------------------");
    resizeCount = 0;
    HashMap&lt;Integer, Object&gt; map1 = new HashMap&lt;&gt;();
    Method capacityMethod1 = map1.getClass().getDeclaredMethod("capacity");
    capacityMethod1.setAccessible(true);
    int capacity1 = (int) capacityMethod1.invoke(map1);
    System.out.println("初始容量：" + capacity1);
    for (int i = 0; i &lt; count; i++) {
        map1.put(i, UUID.randomUUID());
        int curCapacity = (int) capacityMethod1.invoke(map1);
        if (curCapacity &gt; capacity1) {
            System.out.println("当前容量：" + curCapacity);
            resizeCount++;
            capacity1 = curCapacity;
        }
    }
    System.out.println("扩容次数：" + resizeCount);
}
</code></pre> 
<p>由于我们无法直接调用hashMap的<code>capacity()</code>方法，因此使用反射来查看每添加一个元素，它的容量变化，以此来监测hashMap的扩容次数。</p> 
<pre><code class="language-java">//使用反射，调用hashMap的capacity()方法
Method capacityMethod = map.getClass().getDeclaredMethod("capacity");
capacityMethod.setAccessible(true);
int capacity = (int) capacityMethod.invoke(map);
</code></pre> 
<p>差点跑偏了，现在回到上面程序的执行结果：</p> 
<blockquote> 
 <pre>---------------- 初始化hashMap容量为1000000 ------------
初始容量：1048576
当前容量：2097152
hashMap扩容次数：1
---------------- 不初始化hashMap容量 -------------------
初始容量：16
当前容量：32
当前容量：64
当前容量：128
当前容量：256
当前容量：512
当前容量：1024
当前容量：2048
当前容量：4096
当前容量：8192
当前容量：16384
当前容量：32768
当前容量：65536
当前容量：131072
当前容量：262144
当前容量：524288
当前容量：1048576
当前容量：2097152
扩容次数：17

</pre> 
</blockquote> 
<p>通过运行结果发现：</p> 
<p>设置了初始容量的hashMap，其初始容量并不是我指定的1000000，而是1048576（2^20）<br> hashMap的容量并不是固定不变的，当达到扩容条件时会进行扩容，从 16 扩容到 32、64、128…（Hash 会选择大于当前容量的第一个 2 的幂作为容量）<br> 即使制定了初始容量，而且初始容量是1048576，当添加1000000个元素（1000000是小于1048576）时，hashMap依然会扩容1次<br> 为什么会酱紫呢？带着上面的三个发现，来看一下HashMap的扩容机制。</p> 
<p>HashMap的扩容机制<br> 先看一下HashMap的几个成员变量：<br><img alt="在这里插入图片描述" src="https://images2.imgbox.com/07/9a/ZOJNIqhl_o.png"></p> 
<p>DEFAULT_INITIAL_CAPACITY：默认初始容量是2^4=16<br> DEFAULT_LOAD_FACTOR：默认的装载系数是0.75，是用来衡量HashMap的容量满的程度的<br> transient int size：map中k,v对的数目<br> final float loadFactor：装载系数，默认值为0.75<br> int threshold：调整大小的下一个大小值(容量*装载系数)。当实际 KV 个数超过 threshold 时，HashMap 会将容量扩容<br> 再来看一个方法capacity()：<br>  </p> 
<pre><code class="language-java">final int capacity() {
    return (table != null) ? table.length :
        (threshold &gt; 0) ? threshold :
        DEFAULT_INITIAL_CAPACITY;
}
</code></pre> 
<p>这是啥？前面不是已经定义了一个size变量了吗？</p> 
<p>可以把capacity看成是HashMap这个桶的<code>体积</code>（这个体积是可以变大的），而size是这个桶当前装了多少东西。</p> 
<p>桶的容量是由<code>threshold</code>定义的，而且默认容量是2的4次幂，也就是16，源码上是这样写的：</p> 
<pre><code class="language-java">/**
 * The default initial capacity - MUST be a power of two.
 */
static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16
</code></pre> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/6c/33/pJqgzcjw_o.png"></p> 
<p>1 &lt;&lt; 4就是左移4位的意思，也就是2^4=16。</p> 
<p>那么什么时候扩容呢？这个很容易就能够想到，我们向hashMap这个桶里put数据，当桶的k,v对的数目size快填满桶-逼近capacity时，这个桶将要扩容，像金箍棒一样！</p> 
<p>前面的例子已经展示了，hashMap并不是等size到了capacity才扩容，而是在到达capacity的某个值时就扩容了，这个值就是threshold的时候，hashMap进行resize()，而这个，来看源码：</p> 
<p><img alt="" src="https://images2.imgbox.com/53/81/n4hHFUpH_o.png"></p> 
<p>当size增长到大于threshold的时候，hashMap进行resize()，而threshold = loadFactor * capacity，这样就可以知道hashMap这个桶在什么时候自动扩大它的体积了。</p> 
<p>真正的避免HashMap扩容<br> 前面分析到，当size &gt; threshold的时候，hashMap进行扩容，利用threshold = loadFactor * capacity这个公式，我们在初始化的时候就有方向了。</p> 
<p>首先肯定不能直接设置成loadFactor * capacity，因为这个数有可能不是2的幂，HashMap规定的容器容量必须是2的幂，既然如此，我设置成大于loadFactor * capacity的第一个2的幂的数就行了，可以这样做：<br>  </p> 
<pre><code class="language-java">int initCapacity = 1 + (int) (count / 0.75);
HashMap&lt;Integer, Object&gt; map = new HashMap&lt;&gt;(initCapacity);
</code></pre> 
<p><code>1 + (int) (count / 0.75)</code>这个公式来源于HashMap源码：</p> 
<pre><code class="language-java">/**
 * Returns a power of two size for the given target capacity.
 */
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16;
    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
</code></pre> 
<p>这一段代码真的是天外飞仙！其目的是：根据传入的容量值cap，通过一系列神仙操作计算，得到第一个比他大的 2 的幂并返回。</p> 
<p>这些都是二进制的位操作，将数依次向右移位，然后和原值取或。可以随便找一个数代入代码中验证，结果就是第一个比它大的2的幂！</p> 
<p>为什么这样做，或许就是因为 无符号右移 &gt;&gt;&gt; 、或运算 | 就是快吧！</p> 
<h3>结果验证</h3> 
<p>计算容量的公式前面已经搞出来了，现在验证一下对不对：</p> 
<pre><code class="language-java">@SneakyThrows
@Test
public void perfect() {
    int count = 1000000;

    int initCapacity = 1 + (int) (count / 0.75);
    HashMap&lt;Integer, Object&gt; map = new HashMap&lt;&gt;(initCapacity);
    Method capacityMethod = map.getClass().getDeclaredMethod("capacity");
    capacityMethod.setAccessible(true);
    int capacity = (int) capacityMethod.invoke(map);
    System.out.println("jdk hashMap default capacity:" + capacity);
    int resizeCount = 0;
    for (int i = 0; i &lt; count; i++) {
        map.put(i, UUID.randomUUID());
        int curCapacity = (int) capacityMethod.invoke(map);
        if (curCapacity &gt; capacity) {
            System.out.println("当前容量：" + curCapacity);
            resizeCount++;
            capacity = curCapacity;
        }
    }
    System.out.println("hashMap扩容次数：" + resizeCount);
</code></pre> 
<p>运行结果：</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/eb/8d/imcjsmsN_o.png"></p> 
<p>扩容次数为0，perfect！</p> 
<blockquote> 
 <p>把initCapacity=1333334这个数代入到HashMap的<code>tableSizeFor</code>方法就能算出容量为2097152=2^21了！</p> 
</blockquote> 
<h3>不想计算初始化容量-仍有他途</h3> 
<blockquote> 
 <p>Guava是一种基于开源的Java库，其中包含谷歌正在由他们很多项目使用的很多核心库。这个库是为了方便编码，并减少编码错误。这个库提供用于集合，缓存，支持原语，并发性，常见注解，字符串处理，I/O和验证的实用方法。</p> 
</blockquote> 
<p>Guava中有现成的初始化HashMap的方法，它不用我们计算initCapacity，测试一把看看。</p> 
<p>先引入Guava包：</p> 
<pre><code class="language-XML">&lt;dependency&gt;
    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;
    &lt;artifactId&gt;guava&lt;/artifactId&gt;
    &lt;version&gt;29.0-jre&lt;/version&gt;
&lt;/dependency&gt;
</code></pre> 
<p>测试：</p> 
<pre><code class="language-java">@SneakyThrows
@Test
public void perfectWithGuava() {
    int count = 1000000;

    HashMap&lt;Integer, Object&gt; map = Maps.newHashMapWithExpectedSize(count);
    Method capacityMethod = map.getClass().getDeclaredMethod("capacity");
    capacityMethod.setAccessible(true);
    int capacity = (int) capacityMethod.invoke(map);
    System.out.println("guava hashMap default capacity:" + capacity);
    int resizeCount = 0;
    for (int i = 0; i &lt; count; i++) {
        map.put(i, UUID.randomUUID());
        int curCapacity = (int) capacityMethod.invoke(map);
        if (curCapacity &gt; capacity) {
            System.out.println("当前容量：" + curCapacity);
            resizeCount++;
            capacity = curCapacity;
        }
    }
    System.out.println("hashMap扩容次数：" + resizeCount);
}
</code></pre> 
<p>运行结果：</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/48/d6/vS6DL0ND_o.png"></p> 
<p>同样能使HashMap不用扩容！</p> 
<p>瞅一下关键代码：</p> 
<pre><code class="language-java">HashMap&lt;Integer, Object&gt; map = Maps.newHashMapWithExpectedSize(count);
</code></pre> 
<p>我猜这个newHashMapWithExpectedSize(int)的源码中肯定也是按照类似于HashMap的return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;这种方法计算的，来看一下：</p> 
<p><img alt="在这里插入图片描述" src="https://images2.imgbox.com/35/53/sMjxCiZF_o.png"></p> 
<p> </p> 
<p>小结<br> 设置了初始容量的hashMap，其真实初始容量并不一定是指定的数值，而是HashMap内部计算过的<br> hashMap的容量并不是固定不变的，当达到扩容条件时会进行扩容，从 16 扩容到 32、64、128…（Hash 会选择大于当前容量的第一个 2 的幂作为容量）<br> 不要以为指定了初始容量，hashMap就不扩容了<br> 避免hashMap扩容的方法是传入一个<span style="color:#f33b45;">1 + (int) (count / 0.75)</span>计算出的初始值<br> 还可以使用<span style="color:#f33b45;">Guava</span>的<span style="color:#f33b45;">newHashMapWithExpectedSize(int count)</span><br>  </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ba1b767f442b5d6025f928761026fed4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">默认python版本从 2换到3</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/84ae1590352a19e583b543cf825f394d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Anconda安装教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>