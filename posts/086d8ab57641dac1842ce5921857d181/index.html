<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis 序列化器 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis 序列化器" />
<meta property="og:description" content="一、简介 Redis是一个基于内存的key-value结构数据库，所以Redis的读写性能高。可以用作数据库、缓存和消息中间件。
在 Redis 中，序列化器（Serializer）是用于将数据在存储和读取时进行序列化和反序列化操作，即对数据进行编码和解码。
在 Java 中操作 Redis 可以使用 Redis 客户端库。以下是一些常用的操作方式
方式一：Redis的Java客户端有很多，官方推荐的有三种：
Jedis
Lettuce
Redisson
方式二：Spring Data Redis
Spring 对 Redis 客户端进行了整合，提供了 Spring Data Redis，可以简化 Redis 操作。在 Spring Boot 项目中还提供了对应的 Starter，即 spring-boot-starter-data-redis
二、Spring Data Redis Spring Data Reids 中提供了一个高度封装的类：RedisTemplate，针对Jedis客户端中大量api进行了归类封装，将同一类型的操作封装为operation接口，具体分类如下：
ValueOperations：string类型操作
SetOperations：set类型数据操作
ZSetOperations：zset类型数据操作
HashOperations：map类型的数据操作
ListOperations：list类型的数据操作
三、设置序列化器原理 序列化：Java向Redis写入数据时，会对key以及value进行序列化
反序列化：Java从Redis读取数据时，会对key以及value进行反序列化
进入 RedisTemplate 类，可以看到它继承了 RedisAccessor 类。
进入 RedisAccessor 类，可以看到它实现了 InitializingBean 接口，它是一个 Spring 框架提供的接口，是用于在 Bean 实例化后进行初始化操作。
这个 InitializingBean 接口里面定义了一个方式 afterPropertiesSet() 方法，该方法就是在 Bean 的属性设置完成之后会自动调用该方法 ，可以在这个方法中可以进行一些额外的初始化操作，例如设置序列化器。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/086d8ab57641dac1842ce5921857d181/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-23T22:40:00+08:00" />
<meta property="article:modified_time" content="2023-08-23T22:40:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis 序列化器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、简介</h2> 
<blockquote> 
 <p>        Redis是一个基于<span style="color:#fe2c24;"><strong>内存</strong></span>的key-value结构数据库，所以Redis的读写性能高。可以用作数据库、缓存和消息中间件。</p> 
 <p>        在 Redis 中，序列化器（Serializer）是用于将数据在存储和读取时进行序列化和反序列化操作，即对数据进行编码和解码。</p> 
</blockquote> 
<p>在 Java 中操作 Redis 可以使用 Redis 客户端库。以下是一些常用的操作方式</p> 
<p><strong>方式一：</strong>Redis的Java客户端有很多，官方推荐的有三种：</p> 
<ul><li> <p>Jedis</p> </li><li> <p>Lettuce</p> </li><li> <p>Redisson</p> </li></ul> 
<p><strong>方式二：</strong>Spring Data Redis</p> 
<ul><li> <p>Spring 对 Redis 客户端进行了整合，提供了 <strong>Spring Data Redis</strong>，可以简化 Redis 操作。在 Spring Boot 项目中还提供了对应的 Starter，即 spring-boot-starter-data-redis</p> </li></ul> 
<p></p> 
<p></p> 
<h2>二、Spring Data Redis</h2> 
<p>Spring Data Reids 中提供了一个高度封装的类：<span style="color:#fe2c24;"><strong>RedisTemplate</strong></span>，针对Jedis客户端中大量api进行了归类封装，将同一类型的操作封装为operation接口，具体分类如下：</p> 
<ul><li> <p>ValueOperations：string类型操作</p> </li><li> <p>SetOperations：set类型数据操作</p> </li><li> <p>ZSetOperations：zset类型数据操作</p> </li><li> <p>HashOperations：map类型的数据操作</p> </li><li> <p>ListOperations：list类型的数据操作</p> </li></ul> 
<p></p> 
<p></p> 
<h2>三、设置序列化器原理</h2> 
<blockquote> 
 <p><strong>序列化：</strong>Java向Redis写入数据时，会对key以及value进行序列化</p> 
 <p><strong>反序列化：</strong>Java从Redis读取数据时，会对key以及value进行反序列化</p> 
</blockquote> 
<p>进入 RedisTemplate 类，可以看到它继承了 RedisAccessor 类。</p> 
<p><img alt="" height="173" src="https://images2.imgbox.com/ef/ee/fzneKkrg_o.png" width="527"></p> 
<p></p> 
<p></p> 
<p>进入 RedisAccessor 类，可以看到它实现了 InitializingBean 接口，它是一个 Spring 框架提供的接口，是用于在 Bean 实例化后进行初始化操作。</p> 
<p><img alt="" height="122" src="https://images2.imgbox.com/50/8c/XtmDyvIr_o.png" width="382"></p> 
<p></p> 
<p> 这个 InitializingBean 接口里面定义了一个方式 afterPropertiesSet() 方法，该方法就是在 Bean 的属性设置完成之后会自动调用该方法 ，可以在这个方法中可以进行一些额外的初始化操作，例如设置序列化器。</p> 
<p><img alt="" height="162" src="https://images2.imgbox.com/4b/b8/V1r0ZhXC_o.png" width="434"></p> 
<p></p> 
<p>接下来，实现类 RedisAccessor 重写了 afterPropertiesSet() 方法，并且只有一行代码，这行代码通过使用断言来判断是否已经配置了 RedisConnectionFactory 对象，如果没有配置，将抛出异常并提示"RedisConnectionFactory is required"。</p> 
<p><img alt="" height="39" src="https://images2.imgbox.com/ff/19/eF3vhEWC_o.png" width="557"></p> 
<p></p> 
<p>然后，这个 RedisTemplate 类继承了 RedisAccessor 类，并且重写了 afterPropertiesSet() 这个方法，所以 RedisTemplate 类中的afterPropertiesSet() 才是实现序列化器设置的方法。</p> 
<p>在方法中，首先调用了父类 RedisAccessor 的 afterPropertiesSet() 方法，判断是否配置RedisConnectionFactory对象 。</p> 
<p>接下来，对 defaultUsed 进行初始化操作，设置其为 false 表示没有使用默认序列化器</p> 
<p><img alt="" height="93" src="https://images2.imgbox.com/e9/0e/e5ZbTzfj_o.png" width="275"></p> 
<p></p> 
<p>接下来，判断默认序列化器（defaultSerializer）是否为空，也就是判断是否自定义了序列化器。如果没有设置，则创建一个 JDK序列化器（JdkSerializationRedisSerializer）对象，并设置为 JDK序列化器为默认序列化器，同时判断JDK序列化器的类加载器（classLoader）是否为空，如果为空，则在JDK序列化器对象的构造器参数中，放入序列化和反序列化所需的类。</p> 
<p><img alt="" height="70" src="https://images2.imgbox.com/fc/e7/tFrWKEay_o.png" width="501"></p> 
<p></p> 
<p>接下来，判断 enableDefaultSerializer 是否为 true，也就是说是否开启默认序列化器。如果开启了，则继续判断是否设置了 keySerializer、valueSerializer、hashKeySerializer、hashValueSerializer，如果没有设置，则将这个序列化器设置为默认序列化器（defaultSerializer），并设置 defaultUsed 为true，表示使用了默认序列化器</p> 
<p><img alt="" height="243" src="https://images2.imgbox.com/3b/89/Dr4QCYDZ_o.png" width="312"></p> 
<blockquote> 
 <p> 总的来说，就是当没有自定义初始化序列化器时，默认使用的序列化器是JDK序列化器</p> 
</blockquote> 
<p></p> 
<p></p> 
<h2> 四、配置序列化器</h2> 
<blockquote> 
 <p>        被序列化器后序列化后的字符串，是可读性非常差的一串字符。它所带来的优点就是安全性变高，但是同时它也会导致空间占用要比不序列化情况要多。所以序列化虽然保证了数据的安全性，但是也导致空间占用变多。</p> 
</blockquote> 
<p><strong>思路：</strong>一般情况下，对 key 进行序列化是没有意义的，如果进行序列化可能导致 key 的长度变长，提高内存使用和存储成本，并且增加了对 key 进行比较和查找的复杂性。所以 key 就无需序列化。而 value 是真正的数据内容，也就是 value 作为重要的数据是需要被序列化进行存储的。</p> 
<p><strong>解决方法：</strong>自定义一个 Redis 配置类，将 Key 序列化器以及 HashKey 序列化器设置为字符串序列化器（StringRedisSerializer）</p> 
<pre><code class="language-java">@Configuration
public class RedisConfig extends CachingConfigurerSupport {

    @Bean
    public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) {

        RedisTemplate&lt;Object, Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());
        return redisTemplate;
    }
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2490efec00353242f33c6cc720aef95f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">机器人力控入门——牛顿欧拉法动力学建模</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/70c1ceff08e034fcf2845cb9bbd1f9e4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java过滤器（Filter）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>