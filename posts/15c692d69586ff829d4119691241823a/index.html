<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>kafka的go版本api使用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="kafka的go版本api使用" />
<meta property="og:description" content="概述 go语言版本的kafakaAPI
准备 golangsarama 简单使用 生产和消费的过程都是通过一个配置开始的.
生产者 //设置配置 config := sarama.NewConfig() //等待服务器所有副本都保存成功后的响应 config.Producer.RequiredAcks = sarama.WaitForAll //随机的分区类型 config.Producer.Partitioner = sarama.NewRandomPartitioner //是否等待成功和失败后的响应,只有上面的RequireAcks设置不是NoReponse这里才有用. config.Producer.Return.Successes = true config.Producer.Return.Errors = true //设置使用的kafka版本,如果低于V0_10_0_0版本,消息中的timestrap没有作用.需要消费和生产同时配置 config.Version = sarama.V0_11_0_0 //使用配置,新建一个异步生产者 producer, e := sarama.NewAsyncProducer([]string{&#34;IP:9092&#34;,&#34;IP:9092&#34;,&#34;IP:9092&#34;}, config) if e != nil { panic(e) } defer producer.AsyncClose() //发送的消息,主题,key msg := &amp;sarama.ProducerMessage{ Topic: &#34;logstash_test&#34;, Key: sarama.StringEncoder(&#34;test&#34;), } var value string for { value = &#34;this is a message&#34; //设置发送的真正内容 fmt.Scanln(&amp;value) //将字符串转化为字节数组 msg.Value = sarama." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/15c692d69586ff829d4119691241823a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-11-30T13:29:36+08:00" />
<meta property="article:modified_time" content="2017-11-30T13:29:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">kafka的go版本api使用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="概述">概述</h2> 
<p>go语言版本的kafakaAPI</p> 
<h2 id="准备">准备</h2> 
<ul><li>golang</li><li><a href="https://github.com/Shopify/sarama" target="_blank" rel="noopener noreferrer">sarama</a></li></ul> 
<h2 id="简单使用">简单使用</h2> 
<p>生产和消费的过程都是通过一个配置开始的.</p> 
<h4 id="生产者">生产者</h4> 
<pre class="prettyprint"><code class=" hljs avrasm">//设置配置
    config := sarama<span class="hljs-preprocessor">.NewConfig</span>()
    //等待服务器所有副本都保存成功后的响应
    config<span class="hljs-preprocessor">.Producer</span><span class="hljs-preprocessor">.RequiredAcks</span> = sarama<span class="hljs-preprocessor">.WaitForAll</span>
    //随机的分区类型
    config<span class="hljs-preprocessor">.Producer</span><span class="hljs-preprocessor">.Partitioner</span> = sarama<span class="hljs-preprocessor">.NewRandomPartitioner</span>
    //是否等待成功和失败后的响应,只有上面的RequireAcks设置不是NoReponse这里才有用.
    config<span class="hljs-preprocessor">.Producer</span><span class="hljs-preprocessor">.Return</span><span class="hljs-preprocessor">.Successes</span> = true
    config<span class="hljs-preprocessor">.Producer</span><span class="hljs-preprocessor">.Return</span><span class="hljs-preprocessor">.Errors</span> = true
    //设置使用的kafka版本,如果低于V0_10_0_0版本,消息中的timestrap没有作用.需要消费和生产同时配置
    config<span class="hljs-preprocessor">.Version</span> = sarama<span class="hljs-preprocessor">.V</span>0_11_0_0

    //使用配置,新建一个异步生产者
    producer, e := sarama<span class="hljs-preprocessor">.NewAsyncProducer</span>([]string{<!-- --><span class="hljs-string">"IP:9092"</span>,<span class="hljs-string">"IP:9092"</span>,<span class="hljs-string">"IP:9092"</span>}, config)
    if e != nil {
        panic(e)
    }
    defer producer<span class="hljs-preprocessor">.AsyncClose</span>()

    //发送的消息,主题,key
    msg := &amp;sarama<span class="hljs-preprocessor">.ProducerMessage</span>{
        Topic: <span class="hljs-string">"logstash_test"</span>,
        Key:   sarama<span class="hljs-preprocessor">.StringEncoder</span>(<span class="hljs-string">"test"</span>),
    }

    var value string
    for {
        value = <span class="hljs-string">"this is a message"</span>
        //设置发送的真正内容
        fmt<span class="hljs-preprocessor">.Scanln</span>(&amp;value)
        //将字符串转化为字节数组
        msg<span class="hljs-preprocessor">.Value</span> = sarama<span class="hljs-preprocessor">.ByteEncoder</span>(value)
        fmt<span class="hljs-preprocessor">.Println</span>(value)

        //使用通道发送
        producer<span class="hljs-preprocessor">.Input</span>() &lt;- msg

        //循环判断哪个通道发送过来数据.
        select {
        case suc := &lt;-producer<span class="hljs-preprocessor">.Successes</span>():
            fmt<span class="hljs-preprocessor">.Println</span>(<span class="hljs-string">"offset: "</span>, suc<span class="hljs-preprocessor">.Offset</span>, <span class="hljs-string">"timestamp: "</span>, suc<span class="hljs-preprocessor">.Timestamp</span><span class="hljs-preprocessor">.String</span>(), <span class="hljs-string">"partitions: "</span>, suc<span class="hljs-preprocessor">.Partition</span>)
        case fail := &lt;-producer<span class="hljs-preprocessor">.Errors</span>():
            fmt<span class="hljs-preprocessor">.Println</span>(<span class="hljs-string">"err: "</span>, fail<span class="hljs-preprocessor">.Err</span>)
        }
    }</code></pre> 
<ul><li>首先新建一个<code>config</code>,用于配置生产者相关的配置项</li><li>通过<code>config</code>和一个包含一个或多个<code>kafka</code>服务器的字符串数组,新建一个<code>producer</code></li><li>定义一个 生产信息 ,包括发送的主题,哪个分区,重试次数等等信息和消息内容.</li><li>通过<code>producer</code>的输入通道,接受msg</li><li>如果配置中配置了,接收服务器反馈的响应,可以通过<code>Successes</code>和<code>Errors</code>通道来接受成功或失败的内容.</li></ul> 
<h4 id="消费者">消费者</h4> 
<pre class="prettyprint"><code class=" hljs avrasm">//配置
    config := sarama<span class="hljs-preprocessor">.NewConfig</span>()
    //接收失败通知
    config<span class="hljs-preprocessor">.Consumer</span><span class="hljs-preprocessor">.Return</span><span class="hljs-preprocessor">.Errors</span> = true
    //设置使用的kafka版本,如果低于V0_10_0_0版本,消息中的timestrap没有作用.需要消费和生产同时配置
    config<span class="hljs-preprocessor">.Version</span> = sarama<span class="hljs-preprocessor">.V</span>0_11_0_0
    //新建一个消费者
    consumer, e := sarama<span class="hljs-preprocessor">.NewConsumer</span>([]string{<!-- --><span class="hljs-string">"IP:9092"</span>, <span class="hljs-string">"IP:9092"</span>, <span class="hljs-string">"IP:9092"</span>}, config)
    if e != nil {
        panic(<span class="hljs-string">"error get consumer"</span>)
    }
    defer consumer<span class="hljs-preprocessor">.Close</span>()

    //根据消费者获取指定的主题分区的消费者,Offset这里指定为获取最新的消息.
    partitionConsumer, err := consumer<span class="hljs-preprocessor">.ConsumePartition</span>(<span class="hljs-string">"logstash_test"</span>, <span class="hljs-number">0</span>, sarama<span class="hljs-preprocessor">.OffsetNewest</span>)
    if err != nil {
        fmt<span class="hljs-preprocessor">.Println</span>(<span class="hljs-string">"error get partition consumer"</span>, err)
    }
    defer partitionConsumer<span class="hljs-preprocessor">.Close</span>()
    //循环等待接受消息.
    for {
        select {
        //接收消息通道和错误通道的内容.
        case msg := &lt;-partitionConsumer<span class="hljs-preprocessor">.Messages</span>():
            fmt<span class="hljs-preprocessor">.Println</span>(<span class="hljs-string">"msg offset: "</span>, msg<span class="hljs-preprocessor">.Offset</span>, <span class="hljs-string">" partition: "</span>, msg<span class="hljs-preprocessor">.Partition</span>, <span class="hljs-string">" timestrap: "</span>, msg<span class="hljs-preprocessor">.Timestamp</span><span class="hljs-preprocessor">.Format</span>(<span class="hljs-string">"2006-Jan-02 15:04"</span>), <span class="hljs-string">" value: "</span>, string(msg<span class="hljs-preprocessor">.Value</span>))
        case err := &lt;-partitionConsumer<span class="hljs-preprocessor">.Errors</span>():
            fmt<span class="hljs-preprocessor">.Println</span>(err<span class="hljs-preprocessor">.Err</span>)
        }
    }</code></pre> 
<ul><li>配置</li><li>新建一个消费者</li><li>通过消费者,指定主题的分区,获取一个特定的分区消费者.</li><li>通过分区消费者接收消息.</li></ul> 
<h4 id="客户端">客户端</h4> 
<p>客户端可以用来获取消费者和生产者,还可以获取kafka的<code>broker</code>信息和<code>topic</code>信息,以及每个topic中的offset等.</p> 
<pre class="prettyprint"><code class=" hljs go">config := sarama.NewConfig()
config.Version = sarama.V0_10_0_0
client, err := sarama.NewClient([]<span class="hljs-typename">string</span>{<!-- --><span class="hljs-string">"IP:9092"</span>, <span class="hljs-string">"IP:9092"</span>, <span class="hljs-string">"IP:9092"</span>}, config)
<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
    <span class="hljs-built_in">panic</span>(<span class="hljs-string">"client create error"</span>)
}
<span class="hljs-keyword">defer</span> client.Close()
<span class="hljs-comment">//获取主题的名称集合</span>
topics, err := client.Topics()
<span class="hljs-keyword">if</span> err != <span class="hljs-constant">nil</span> {
    <span class="hljs-built_in">panic</span>(<span class="hljs-string">"get topics err"</span>)
}
<span class="hljs-keyword">for</span> _, e := <span class="hljs-keyword">range</span> topics {
    fmt.Println(e)
}
<span class="hljs-comment">//获取broker集合</span>
brokers := client.Brokers()
<span class="hljs-comment">//输出每个机器的地址</span>
<span class="hljs-keyword">for</span> _, broker := <span class="hljs-keyword">range</span> brokers {
    fmt.Println(broker.Addr())
}</code></pre> 
<h2 id="sarama选项"><code>sarama</code>选项</h2> 
<h4 id="config结构体"><code>config</code>结构体</h4> 
<p>实例:</p> 
<pre class="prettyprint"><code class=" hljs fix"><span class="hljs-attribute">config :</span>=<span class="hljs-string"> sarama.NewConfig()</span></code></pre> 
<p>配置包括消费者,生产者,客户端等配置,需要用到哪个指定配置哪个即可.</p> 
<pre class="prettyprint"><code class=" hljs avrasm">c<span class="hljs-preprocessor">.Net</span><span class="hljs-preprocessor">.MaxOpenRequests</span> = <span class="hljs-number">5</span>
c<span class="hljs-preprocessor">.Net</span><span class="hljs-preprocessor">.DialTimeout</span> = <span class="hljs-number">30</span> * time<span class="hljs-preprocessor">.Second</span>
c<span class="hljs-preprocessor">.Net</span><span class="hljs-preprocessor">.ReadTimeout</span> = <span class="hljs-number">30</span> * time<span class="hljs-preprocessor">.Second</span>
c<span class="hljs-preprocessor">.Net</span><span class="hljs-preprocessor">.WriteTimeout</span> = <span class="hljs-number">30</span> * time<span class="hljs-preprocessor">.Second</span>
c<span class="hljs-preprocessor">.Net</span><span class="hljs-preprocessor">.SASL</span><span class="hljs-preprocessor">.Handshake</span> = true

c<span class="hljs-preprocessor">.Metadata</span><span class="hljs-preprocessor">.Retry</span><span class="hljs-preprocessor">.Max</span> = <span class="hljs-number">3</span>
c<span class="hljs-preprocessor">.Metadata</span><span class="hljs-preprocessor">.Retry</span><span class="hljs-preprocessor">.Backoff</span> = <span class="hljs-number">250</span> * time<span class="hljs-preprocessor">.Millisecond</span>
c<span class="hljs-preprocessor">.Metadata</span><span class="hljs-preprocessor">.RefreshFrequency</span> = <span class="hljs-number">10</span> * time<span class="hljs-preprocessor">.Minute</span>
c<span class="hljs-preprocessor">.Metadata</span><span class="hljs-preprocessor">.Full</span> = true

c<span class="hljs-preprocessor">.Producer</span><span class="hljs-preprocessor">.MaxMessageBytes</span> = <span class="hljs-number">1000000</span>
c<span class="hljs-preprocessor">.Producer</span><span class="hljs-preprocessor">.RequiredAcks</span> = WaitForLocal
c<span class="hljs-preprocessor">.Producer</span><span class="hljs-preprocessor">.Timeout</span> = <span class="hljs-number">10</span> * time<span class="hljs-preprocessor">.Second</span>
c<span class="hljs-preprocessor">.Producer</span><span class="hljs-preprocessor">.Partitioner</span> = NewHashPartitioner  //选择分区的分区选择器.用于选择主题的分区
c<span class="hljs-preprocessor">.Producer</span><span class="hljs-preprocessor">.Retry</span><span class="hljs-preprocessor">.Max</span> = <span class="hljs-number">3</span> //重试次数
c<span class="hljs-preprocessor">.Producer</span><span class="hljs-preprocessor">.Retry</span><span class="hljs-preprocessor">.Backoff</span> = <span class="hljs-number">100</span> * time<span class="hljs-preprocessor">.Millisecond</span>
c<span class="hljs-preprocessor">.Producer</span><span class="hljs-preprocessor">.Return</span><span class="hljs-preprocessor">.Errors</span> = true  //是否接收返回的错误消息,当发生错误时会放到Error这个通道中.从它里面获取错误消息

//抓取数据的大小设置
c<span class="hljs-preprocessor">.Consumer</span><span class="hljs-preprocessor">.Fetch</span><span class="hljs-preprocessor">.Min</span> = <span class="hljs-number">1</span>
c<span class="hljs-preprocessor">.Consumer</span><span class="hljs-preprocessor">.Fetch</span><span class="hljs-preprocessor">.Default</span> = <span class="hljs-number">32768</span>

c<span class="hljs-preprocessor">.Consumer</span><span class="hljs-preprocessor">.Retry</span><span class="hljs-preprocessor">.Backoff</span> = <span class="hljs-number">2</span> * time<span class="hljs-preprocessor">.Second</span> //失败后再次尝试的间隔时间
c<span class="hljs-preprocessor">.Consumer</span><span class="hljs-preprocessor">.MaxWaitTime</span> = <span class="hljs-number">250</span> * time<span class="hljs-preprocessor">.Millisecond</span>  //最大等待时间
c<span class="hljs-preprocessor">.Consumer</span><span class="hljs-preprocessor">.MaxProcessingTime</span> = <span class="hljs-number">100</span> * time<span class="hljs-preprocessor">.Millisecond</span>
c<span class="hljs-preprocessor">.Consumer</span><span class="hljs-preprocessor">.Return</span><span class="hljs-preprocessor">.Errors</span> = false  //是否接收返回的错误消息,当发生错误时会放到Error这个通道中.从它里面获取错误消息
c<span class="hljs-preprocessor">.Consumer</span><span class="hljs-preprocessor">.Offsets</span><span class="hljs-preprocessor">.CommitInterval</span> = <span class="hljs-number">1</span> * time<span class="hljs-preprocessor">.Second</span> // 提交跟新Offset的频率
c<span class="hljs-preprocessor">.Consumer</span><span class="hljs-preprocessor">.Offsets</span><span class="hljs-preprocessor">.Initial</span> = OffsetNewest // 指定Offset,也就是从哪里获取消息,默认时从主题的开始获取.

c<span class="hljs-preprocessor">.ClientID</span> = defaultClientID
c<span class="hljs-preprocessor">.ChannelBufferSize</span> = <span class="hljs-number">256</span>  //通道缓存大小
c<span class="hljs-preprocessor">.Version</span> = minVersion //指定kafka版本,不指定,使用最小版本,高版本的新功能可能无法正常使用.
c<span class="hljs-preprocessor">.MetricRegistry</span> = metrics<span class="hljs-preprocessor">.NewRegistry</span>()</code></pre> 
<h4 id="生产者的分区的分割器">生产者的分区的分割器</h4> 
<p>分区选择在多个分区存在的情况下,决定将消息发送到哪个分区.</p> 
<p><code>sarama</code>有多个分割器:</p> 
<pre class="prettyprint"><code class=" hljs cs">sarama.NewManualPartitioner() <span class="hljs-comment">//返回一个手动选择分区的分割器,也就是获取msg中指定的`partition`</span>
sarama.NewRandomPartitioner() <span class="hljs-comment">//通过随机函数随机获取一个分区号</span>
sarama.NewRoundRobinPartitioner() <span class="hljs-comment">//环形选择,也就是在所有分区中循环选择一个</span>
sarama.NewHashPartitioner() <span class="hljs-comment">//通过msg中的key生成hash值,选择分区,</span></code></pre> 
<h4 id="生产者的消息producermessage">生产者的消息<code>ProducerMessage</code></h4> 
<pre class="prettyprint"><code class=" hljs vala">Topic <span class="hljs-keyword">string</span> <span class="hljs-comment">// kafka 主题</span>
Key Encoder <span class="hljs-comment">//用于选择分区,和分割器的NewHashPartitioner联合使用,决定当前消息被保存在哪个分区</span>
Value Encoder  <span class="hljs-comment">//消息的内容.</span>

Headers []RecordHeader <span class="hljs-comment">//在生产者和消费者之间传递的键值对,</span>

Metadata <span class="hljs-class"><span class="hljs-keyword">interface</span>{<!-- --></span>} <span class="hljs-comment">//sarama 用于传递数据使用</span>

<span class="hljs-comment">//下面的内容有生产者返回后的内容填充.</span>
Offset <span class="hljs-keyword">int64</span> <span class="hljs-comment">// 返回新发布的消息的偏移量</span>
Partition <span class="hljs-keyword">int32</span> <span class="hljs-comment">//返回的信息的保存分区</span>
Timestamp time.Time <span class="hljs-comment">//保存在服务端的消息时间</span>

retries <span class="hljs-keyword">int</span>
flags   flagSet</code></pre> 
<h4 id="消费者信息consumermessage">消费者信息<code>ConsumerMessage</code></h4> 
<pre class="prettyprint"><code class=" hljs sql">// ConsumerMessage encapsulates a Kafka message returned by the consumer.
type ConsumerMessage struct {
    Key, Value     []byte  //key和保存的值
    Topic          string //要消费的主题
    Partition      int32 //要消费的分区
    Offset         int64 //要消费的消息的位置,从哪里开始消费,最开始的,还是最后的
    Timestamp      time.Time       // only <span class="hljs-operator"><span class="hljs-keyword">set</span> <span class="hljs-keyword">if</span> kafka <span class="hljs-keyword">is</span> version <span class="hljs-number">0.10</span>+, 内部时间
    BlockTimestamp <span class="hljs-keyword">time</span>.<span class="hljs-keyword">Time</span>       // <span class="hljs-keyword">only</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">if</span> kafka <span class="hljs-keyword">is</span> version <span class="hljs-number">0.10</span>+, <span class="hljs-keyword">outer</span> (compressed) block <span class="hljs-keyword">timestamp</span>
    Headers        []*RecordHeader // <span class="hljs-keyword">only</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">if</span> kafka <span class="hljs-keyword">is</span> version <span class="hljs-number">0.11</span>+
}</span></code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/47f22397390fa0e46e38f52eac680144/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LeetCode--Longest Consecutive Sequence（最长连续序列）Python</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/41dd6b5f213eb058a0b3f1251fe3b573/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">有道云笔记快捷键使用指南</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>