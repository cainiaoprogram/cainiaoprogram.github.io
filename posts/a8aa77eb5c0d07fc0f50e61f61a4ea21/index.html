<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java.lang.String的substring、split方法引起的内存问题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java.lang.String的substring、split方法引起的内存问题" />
<meta property="og:description" content="本文大部分内容，摘自下面两篇文章：
http://blog.xebia.com/2007/10/04/leaking-memory-in-java/、
http://www.iteye.com/topic/626801
先用一个极端例子说明String的substring方法引起的OutOfMemoryError问题：
public class TestGC { private String large = new String(new char[100000]); public String getSubString() { return this.large.substring(0,2); } public static void main(String[] args) { ArrayList&lt;String&gt; subStrings = new ArrayList&lt;String&gt;(); for (int i = 0; i &lt;1000000; i&#43;&#43;) { TestGC testGC = new TestGC(); subStrings.add(testGC.getSubString()); } } }运行该程序，结果出现： Exception in thread &#34;main&#34; java.lang.OutOfMemoryError: Java heap space
为什么会出现这个情况？查看一下JDK String类substring方法的源码，可以找到原因，源码如下：
public String substring(int beginIndex, int endIndex) { if (beginIndex &lt; 0) { throw new StringIndexOutOfBoundsException(beginIndex); } if (endIndex &gt; count) { throw new StringIndexOutOfBoundsException(endIndex); } if (beginIndex &gt; endIndex) { throw new StringIndexOutOfBoundsException(endIndex - beginIndex); } return ((beginIndex == 0) &amp;&amp; (endIndex == count)) ?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a8aa77eb5c0d07fc0f50e61f61a4ea21/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-07-15T13:51:24+08:00" />
<meta property="article:modified_time" content="2012-07-15T13:51:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java.lang.String的substring、split方法引起的内存问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>本文大部分内容，摘自下面两篇文章：</p> 
<p><a href="http://www.iteye.com/topic/130984"></a>           <a href="http://blog.xebia.com/2007/10/04/leaking-memory-in-java/" rel="nofollow">http://blog.xebia.com/2007/10/04/leaking-memory-in-java/</a>、</p> 
<p>            <a href="http://www.iteye.com/topic/626801">http://www.iteye.com/topic/626801</a></p> 
<p>先用一个极端例子说明String的substring方法引起的OutOfMemoryError问题：</p> 
<p></p> 
<pre><code class="language-java">public class TestGC {   
  private String large = new String(new char[100000]);   
  
  public String getSubString() {   
    return this.large.substring(0,2);   
  }   
  
  public static void main(String[] args) {   
    ArrayList&lt;String&gt; subStrings = new ArrayList&lt;String&gt;();   
    for (int i = 0; i &lt;1000000; i++) {   
      TestGC testGC = new TestGC();   
      subStrings.add(testGC.getSubString());   
    }   
  }   
}</code></pre>运行该程序，结果出现： 
<p></p> 
<p>    Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</p> 
<p>为什么会出现这个情况？查看一下JDK String类substring方法的源码，可以找到原因，源码如下：<br> </p> 
<pre><code class="language-java">    public String substring(int beginIndex, int endIndex) {
	if (beginIndex &lt; 0) {
	    throw new StringIndexOutOfBoundsException(beginIndex);
	}
	if (endIndex &gt; count) {
	    throw new StringIndexOutOfBoundsException(endIndex);
	}
	if (beginIndex &gt; endIndex) {
	    throw new StringIndexOutOfBoundsException(endIndex - beginIndex);
	}
	return ((beginIndex == 0) &amp;&amp; (endIndex == count)) ? this :
	    new String(offset + beginIndex, endIndex - beginIndex, value);
    }</code></pre> 
<span style="color:#cc0000">该方法最后一行，调用了String的一个私有的构造方法</span>，如下： 
<p></p> 
<p></p> 
<pre><code class="language-java">    // Package private constructor which shares value array for speed.
    String(int offset, int count, char value[]) {
	this.value = value;
	this.offset = offset;
	this.count = count;
    }</code></pre> 
<span style="color:#cc0000">从该构造函数的访问权限和注释，可以看出，SUN为了优化性能而专门写了这个构造方法。</span> 
<br> 
<span style="color:#cc0000">该方法为了避免内存拷贝，提高性能，并没有重新创建char数组，而是直接复用了原String对象的char[]，通过改变偏移量和长度来标识不同的字符串内容。也就是说，substring出的来String小对象，仍然会指向原String大对象的char[]，所以就导致了OutOfMemoryError问题</span>。 
<p>找到问题之后，将上面代码中，getSubString的方法修改一下，如下：</p> 
<p></p> 
<pre><code class="language-java">    public String getSubString() {
        return new String(this.large.substring(0,2)); 
    }</code></pre>将substring的结果，重新new一个String出来。再运行该程序，则没有出现OutOfMemoryError的问题。为什么？因为此时调用的是String类的public的构造方法，该方法源码如下： 
<p></p> 
<p></p> 
<pre><code class="language-java">    public String(String original) {
	int size = original.count;
	char[] originalValue = original.value;
	char[] v;
  	if (originalValue.length &gt; size) {
 	    // The array representing the String is bigger than the new
 	    // String itself.  Perhaps this constructor is being called
 	    // in order to trim the baggage, so make a copy of the array.
            int off = original.offset;
            v = Arrays.copyOfRange(originalValue, off, off+size);
 	} else {
 	    // The array representing the String is the same
 	    // size as the String, so no point in making a copy.
	    v = originalValue;
 	}
	this.offset = 0;
	this.count = size;
	this.value = v;
    }</code></pre>从代码可以看出，在String对象中value的length大于count的情况下，会重新创建一个char[]，并进行内存拷贝。 
<br> 
<br> 
<p><span style="color:#cc0000">除了substring方法之后，String的split方法，也存在同样的问题</span>，split的源码如下：</p> 
<p></p> 
<pre><code class="language-java">    public String[] split(String regex, int limit) {
	return Pattern.compile(regex).split(this, limit);
    }</code></pre> 
<p>可以看出，String的split方法通过Pattern的split方法来实现，Pattern的split方法源码如下：</p> 
<p></p> 
<pre><code class="language-java">public String[] split(CharSequence input, int limit) {
        int index = 0;
        boolean matchLimited = limit &gt; 0;
        ArrayList&lt;String&gt; matchList = new ArrayList&lt;String&gt;();
        Matcher m = matcher(input);

        // Add segments before each match found
        while(m.find()) {
            if (!matchLimited || matchList.size() &lt; limit - 1) {
                String match = input.subSequence(index, m.start()).toString();
                matchList.add(match);
                index = m.end();
            } else if (matchList.size() == limit - 1) { // last one
                String match = input.subSequence(index,
                                                 input.length()).toString();
                matchList.add(match);
                index = m.end();
            }
        }

        // If no match was found, return this
        if (index == 0)
            return new String[] {input.toString()};

        // Add remaining segment
        if (!matchLimited || matchList.size() &lt; limit)
            matchList.add(input.subSequence(index, input.length()).toString());

        // Construct result
        int resultSize = matchList.size();
        if (limit == 0)
            while (resultSize &gt; 0 &amp;&amp; matchList.get(resultSize-1).equals(""))
                resultSize--;
        String[] result = new String[resultSize];
        return matchList.subList(0, resultSize).toArray(result);
    }</code></pre>方法中的第9行： 
<span style="font-family:Helvetica,Tahoma,Arial,sans-serif; line-height:25px; background-color:rgb(239,239,239)"><span style="font-size:12px">Stirng match = input.subSequence(intdex, m.start()).toString();</span></span> 
<br> 调用了String类的subSequence方法，该方法源码如下： 
<p></p> 
<p></p> 
<pre><code class="language-java">    public CharSequence subSequence(int beginIndex, int endIndex) {
        return this.substring(beginIndex, endIndex);
    }</code></pre> 
<p>通过代码可以看出，最终调用的是String类的substring方法，因此存在同样的问题。<span style="color:#cc0000">split出来的小对象，直接使用原String对象的char[]</span>。</p> 
<p><br> </p> 
<p>看了一下<span style="color:#cc0000">StringBuilder和StringBuffer的substring方法，则不存在这样的问题</span>。其源码如下：</p> 
<p></p> 
<pre><code class="language-java">    public String substring(int start, int end) {
	if (start &lt; 0)
	    throw new StringIndexOutOfBoundsException(start);
	if (end &gt; count)
	    throw new StringIndexOutOfBoundsException(end);
	if (start &gt; end)
	    throw new StringIndexOutOfBoundsException(end - start);
        return new String(value, start, end - start);
    }</code></pre>最后一行，调用了String类的public构造方法，方法源码如下： 
<p></p> 
<p></p> 
<pre><code class="language-java">    public String(char value[], int offset, int count) {
        if (offset &lt; 0) {
            throw new StringIndexOutOfBoundsException(offset);
        }
        if (count &lt; 0) {
            throw new StringIndexOutOfBoundsException(count);
        }
        // Note: offset or count might be near -1&gt;&gt;&gt;1.
        if (offset &gt; value.length - count) {
            throw new StringIndexOutOfBoundsException(offset + count);
        }
        this.offset = 0;
        this.count = count;
        this.value = Arrays.copyOfRange(value, offset, offset+count);
    }</code></pre>该方法不是直接使用原String对象的char[]，而是重新进行了内存拷贝。 
<br> 
<br> 
<br> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f5ece82469e6be8d230371270eb09b43/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JS判断是否到达指定时间，执行任务，可以精确到秒。</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cb7dba6e73ab311ac28dca2edabf4e7b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">PL/SQL 别名时用中文字符报错ora-00911 或中文乱码解决办法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>