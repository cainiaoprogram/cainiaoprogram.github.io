<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>用 cmake 构建Qt工程(对比qmake进行学习) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="用 cmake 构建Qt工程(对比qmake进行学习)" />
<meta property="og:description" content="cmake vs qmake qmake 是为 Qt 量身打造的，使用起来非常方便cmake 使用上不如qmake简单直接，但复杂换来的是强大的功能 内置的 out-of source 构建。（目前QtCreator为qmake也默认启用了该功能，称：shadow build）
为各种平台和场景提供条件编译 可处理多个可执行文件情况，和很好配合 QtTest 工作
如何选择?
Using CMake to Build Qt Projects 一文中说：
对简单的Qt工程，采用 qmake对复杂度超过 qmake 处理能力的，采用 cmake 尽管如此，如果简单Qt的工程都不知道怎么用 cmake 构建，复杂的工程，就更不知道如何使用 cmake 了。还是从简单的学起吧
简单的 Qt 程序 #include &lt;QtCore/QCoreApplication&gt;
#include &lt;QtCore/QDebug&gt;
int main(int argc, char** argv)
{
QCoreApplication app(argc, argv);
qDebug()&lt;&lt;&#34;hello qt!&#34;;
app.exec();
} 如果不使用构建工具，直接调用编译器来编译的话，只需要类似这样的一条命令：
g&#43;&#43; main.cpp -Ie:/Qt/4.7.0/include -o main -Le:/Qt/4.7.0/lib -lQtCore4 指定头文件目录，以及需要链接的库
qmake qmake 需要一个 .pro 文件:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/74f49c99042e355ac7e5694afac2c5c6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2010-12-12T21:35:00+08:00" />
<meta property="article:modified_time" content="2010-12-12T21:35:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">用 cmake 构建Qt工程(对比qmake进行学习)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p> </p> 
<h3>cmake vs qmake</h3> 
<ul><li>qmake 是为 Qt 量身打造的，使用起来非常方便</li><li>cmake 使用上不如qmake简单直接，但复杂换来的是强大的功能 
  <ul><li> <p class="line862">内置的 out-of source 构建。（目前QtCreator为qmake也默认启用了该功能，称：shadow build）</p> </li><li>为各种平台和场景提供条件编译</li><li> <p class="line862">可处理多个可执行文件情况，和很好配合 QtTest 工作</p> </li></ul> </li></ul> 
<p class="line874">如何选择?</p> 
<p class="line867"><a class="http" href="http://developer.qt.nokia.com/quarterly/view/using_cmake_to_build_qt_projects" rel="nofollow">Using CMake to Build Qt Projects</a> 一文中说：</p> 
<ul><li>对简单的Qt工程，采用 qmake</li><li>对复杂度超过 qmake 处理能力的，采用 cmake</li></ul> 
<p class="line874">尽管如此，如果简单Qt的工程都不知道怎么用 cmake 构建，复杂的工程，就更不知道如何使用 cmake 了。还是从简单的学起吧</p> 
<h3>简单的 Qt 程序</h3> 
<div class="highlight cpp"> 
 <div class="codearea" dir="ltr"> 
  <pre dir="ltr"><span class="line"><span class="Preprc">#</span><span class="Preprc">include &lt;QtCore</span><span class="Preprc">/</span><span class="Preprc">QCoreApplication&gt;</span></span><br><span class="line"><span class="Preprc">#</span><span class="Preprc">include &lt;QtCore</span><span class="Preprc">/</span><span class="Preprc">QDebug&gt;</span></span><br><span class="line"><span class="ResWord">int</span> <span class="ID">main</span>(<span class="ResWord">int</span> <span class="ID">argc</span>, <span class="ResWord">char</span>** <span class="ID">argv</span>)</span><br><span class="line">{<!-- --></span><br><span class="line">    <span class="ID">QCoreApplication</span> <span class="ID">app</span>(<span class="ID">argc</span>, <span class="ID">argv</span>);</span><br><span class="line">    <span class="ID">qDebug</span>()&lt;&lt;<span class="String">"</span><span class="String">hello qt!</span><span class="String">"</span>;</span><br><span class="line">    <span class="ID">app</span>.<span class="ID">exec</span>();</span><br><span class="line">}</span></pre> 
 </div> 
</div> 
<p class="line874">如果不使用构建工具，直接调用编译器来编译的话，只需要类似这样的一条命令：</p> 
<pre>g++ main.cpp -Ie:/Qt/4.7.0/include -o main -Le:/Qt/4.7.0/lib -lQtCore4</pre> 
<p class="line874">指定头文件目录，以及需要链接的库</p> 
<h4>qmake</h4> 
<p class="line874">qmake 需要一个 .pro 文件:</p> 
<pre>CONFIG += qt<br>QT -= gui<br>SOURCES += main.cpp</pre> 
<ul><li> <p class="line862">因为我们需要 Qt的库和头文件，所以需要<tt> CONFIG += qt </tt>。</p> 
  <ul><li>这是默认项，可直接去掉该行</li></ul> </li><li>启用qt后，可以通过 QT -= gui 来进一步细调我们需要的模块 
  <ul><li>默认是 core gui。我们不需要gui模块，故去掉。</li></ul> </li></ul> 
<h4>cmake</h4> 
<p class="line874">cmake 需要一个 CMakeLists.txt 文件：</p> 
<div class="highlight cmake"> 
 <div class="codearea" dir="ltr"> 
  <pre dir="ltr"><span class="line"><span class="ResWord">PROJECT</span>(<span class="String">example</span>)</span><br><span class="line"><span class="ResWord">FIND_PACKAGE</span>(<span class="String">Qt4</span> <span class="String">REQUIRED</span>)</span><br><span class="line"><span class="ResWord">SET</span>(<span class="String">QT_DONT_USE_QTGUI</span> <span class="String">TRUE</span>)</span><br><span class="line"><span class="ResWord">INCLUDE</span>(${<!-- --><span class="ID">QT_USE_FILE</span>})</span><br><span class="line"><span class="ResWord">ADD_EXECUTABLE</span>(<span class="String">example</span> <span class="String">main.cpp</span>)</span><br><span class="line"><span class="ResWord">TARGET_LINK_LIBRARIES</span>(<span class="String">example</span> ${<!-- --><span class="ID">QT_LIBRARIES</span>})</span></pre> 
 </div> 
</div> 
<ul><li>FIND_PACKAGE 来启用 Qt4</li><li>默认使用了core 和 gui，故手动禁用 QTGUI 
  <ul><li> <p class="line862">这两行可以直接使用 <tt>FIND_PACKAGE(Qt4 COMPONENTS QtCore REQUIRED)</tt>，未指定的模块将被禁用</p> </li></ul> </li><li>包含一个CMake为Qt提供的配置文件，${QT_USE_FILE}变量是一个文件名</li><li>添加可执行程序目标</li><li>链接到 Qt 的库</li></ul> 
<h3>复杂一点</h3> 
<p class="line874">考虑一个常规Qt程序：</p> 
<ul><li>main.cpp</li><li>mainwindows.ui</li><li>mainwindows.h</li><li>mainwindows.cpp</li></ul> 
<p class="line874">如果手动编译的话：</p> 
<ul><li>mainwindow.ui 需要使用 uic 预处理</li></ul> 
<p class="line867"> </p> 
<pre>uic mainwindow.ui -o ui_mainwindow.h</pre> 
<ul><li>mainwindow.h 需要 moc 预处理</li></ul> 
<p class="line867"> </p> 
<pre>moc mainwindow.h -o moc_mainwindow.cpp</pre> 
<ul><li>调用编译器进行编译</li></ul> 
<p class="line867"> </p> 
<pre>g++ main.cpp mainwindow.cpp  moc_mainwindow.cpp -Ie:/Qt/4.7.0/include -o main  -Le:/Qt/4.7.0/lib -lQtCore4 -lQtGui4</pre> 
<h4>qmake</h4> 
<p class="line874">使用 qmake 的的话，一个简单的 pro 文件</p> 
<pre>TARGET = example<br>TEMPLATE = app<br>SOURCES += main.cpp mainwindow.cpp<br>HEADERS  += mainwindow.h<br>FORMS    += mainwindow.ui</pre> 
<p class="line874">HEADERS 中的文件是否需要 moc 进行预处理，qmake 运行时会根据其是否含有Q_OBJECT自动判断。</p> 
<p class="line874">这也是为什么 很多人添加Q_OBJECT宏后不重新运行qmake会出错误的原因。</p> 
<h4>cmake</h4> 
<p class="line874">看看相应的 cmake 的 CMakeLists.txt 文件</p> 
<div class="highlight cmake"> 
 <div class="codearea" dir="ltr"> 
  <pre dir="ltr"><span class="line"><span class="ResWord">PROJECT</span>(<span class="String">example</span>)</span><br><span class="line"><span class="ResWord">CMAKE_MINIMUM_REQUIRED</span>(<span class="String">VERSION</span> <span class="String">2.6</span>)</span><br><span class="line"><span class="ResWord">FIND_PACKAGE</span>(<span class="String">Qt4</span> <span class="String">REQUIRED</span>)</span><br><span class="line"><span class="ResWord">INCLUDE</span>(${<!-- --><span class="ID">QT_USE_FILE</span>})</span><br><span class="line"><span class="ResWord">INCLUDE_DIRECTORIES</span>(${<!-- --><span class="ID">CMAKE_CURRENT_BINARY_DIR</span>})</span><br><span class="line">QT4_WRAP_CPP(example_MOCS mainwindow.h)</span><br><span class="line">QT4_WRAP_UI(example_UIS mainwindow.ui)</span><br><span class="line"><span class="ResWord">ADD_EXECUTABLE</span>(<span class="String">example</span> <span class="String">main.cpp</span> <span class="String">mainwindow.cpp</span> ${<!-- --><span class="ID">example_MOCS</span>})</span><br><span class="line"><span class="ResWord">TARGET_LINK_LIBRARIES</span>(<span class="String">example</span> ${<!-- --><span class="ID">QT_LIBRARIES</span>})</span></pre> 
 </div> 
</div> 
<ul><li>需要 moc 的文件，用 QT4_WRAP_CPP 处理 
  <ul><li>生成的文件放入变量 example_MOCS 中，最后一块链接到可执行程序</li></ul> </li><li>需要 uic 的文件，用 QT4_WRAP_UI 处理</li></ul> 
<h4>Windows</h4> 
<p class="line874">因为windows下链接时分为 console 和 windows 两个子系统，所以windows下有些问题需要特殊处理。</p> 
<p class="line874">用 qmake 时：</p> 
<ul><li>默认是 windows 子系统</li><li>可以通过 CONFIG += console 使用 console 子系统</li></ul> 
<p class="line874">用 cmake 是：</p> 
<ul><li>默认是 console 子系统</li><li>使用 windows 子系统需要</li></ul> 
<p class="line867"> </p> 
<pre>SET(QT_USE_QTMAIN TRUE)<br>ADD_EXECUTABLE(example WIN32 main.cpp mainwindow.cpp ${example_MOCS})</pre> 
<p class="line862">前者启用 qtmain.lib 库来提供windows下的 WinMain 入口函数。后者链接 windows 子系统</p> 
<h3>再复杂一点</h3> 
<ul><li>main.cpp</li><li>mainwindows.ui</li><li>mainwindows.h</li><li>mainwindows.cpp</li><li>main.qrc</li><li>main.rc</li></ul> 
<p class="line874">前面已经用到了Qt的 moc 和 uic，这次增加了资源系统 需要用 rcc</p> 
<pre>rcc main.qrc -o qrc_main.cpp</pre> 
<p class="line874">同时，使用了windows下的资源文件 .rc (比如给程序添加图标)</p> 
<ul><li>MVSC 中使用 rc.exe 对 .rc 文件进行处理</li><li>MinGW 中使用 windres.exe 处理 .rc 文件</li></ul> 
<h4>qmake</h4> 
<p class="line867"> </p> 
<pre>TARGET = example<br>TEMPLATE = lib<br>HEADERS = mainwindow.h widget.h<br>SOURCES = main.cpp widget.cpp  mainwindow.cpp<br>RESOURCES = main.qrc<br>RC_FILE = main.rc</pre> 
<h4>cmake</h4> 
<div class="highlight cmake"> 
 <div class="codearea" dir="ltr"> 
  <pre dir="ltr"><span class="line"><span class="ResWord">PROJECT</span>(<span class="String">example</span>)</span><br><span class="line"><span class="ResWord">CMAKE_MINIMUM_REQUIRED</span>(<span class="String">VERSION</span> <span class="String">2.6</span>)</span><br><span class="line"><span class="ResWord">FIND_PACKAGE</span>(<span class="String">Qt4</span> <span class="String">REQUIRED</span>)</span><br><span class="line"><span class="ResWord">SET</span>(<span class="String">QT_USE_QTMAIN</span> <span class="String">TRUE</span>)</span><br><span class="line"><span class="ResWord">INCLUDE</span>(${<!-- --><span class="ID">QT_USE_FILE</span>})</span><br><span class="line"><span class="ResWord">INCLUDE_DIRECTORIES</span>(${<!-- --><span class="ID">CMAKE_CURRENT_BINARY_DIR</span>})</span><br><br><span class="line"><span class="ResWord">if</span>(<span class="String">MINGW</span>)</span><br><span class="line">  <span class="ResWord">set</span>(<span class="String">CMAKE_RC_COMPILER_INIT</span> <span class="String">windres</span>)</span><br><span class="line">  <span class="ResWord">ENABLE_LANGUAGE</span>(<span class="String">RC</span>)</span><br><span class="line">  <span class="ResWord">SET</span>(<span class="String">CMAKE_RC_COMPILE_OBJECT</span></span><br><span class="line">    <span class="String">"&lt;CMAKE_RC_COMPILER&gt; &lt;FLAGS&gt; -O coff &lt;DEFINES&gt; -i &lt;SOURCE&gt; -o &lt;OBJECT&gt;"</span>)</span><br><span class="line"><span class="ResWord">endif</span>(<span class="String">MINGW</span>)</span><br><br><span class="line"><span class="ResWord">SET</span>(<span class="String">example_SRCS</span> <span class="String">main.cpp</span> <span class="String">mainwindow.cpp</span> <span class="String">widget.cpp</span> <span class="String">res/main.rc</span>)</span><br><span class="line"><span class="ResWord">SET</span>(<span class="String">example_MOC_SRCS</span> <span class="String">mainwindow.h</span> <span class="String">widget.h</span>)</span><br><span class="line">QT4_WRAP_CPP(example_MOCS ${example_MOC_SRCS})</span><br><span class="line">QT4_ADD_RESOURCES(example_RCC_SRCS main.qrc)</span><br><span class="line"><span class="ResWord">SET</span>(<span class="String">example_SRCS</span> ${<!-- --><span class="ID">example_SRCS</span>} ${<!-- --><span class="ID">example_MOCS</span>} ${<!-- --><span class="ID">example_RCC_SRCS</span>})</span><br><br><span class="line"><span class="ResWord">ADD_EXECUTABLE</span>(<span class="String">example</span> <span class="String">WIN32</span> <span class="String">main.cpp</span> <span class="String">mainwindow.cpp</span> ${<!-- --><span class="ID">example_SRCS</span>})</span><br><span class="line"><span class="ResWord">TARGET_LINK_LIBRARIES</span>(<span class="String">example</span> ${<!-- --><span class="ID">QT_LIBRARIES</span>})</span></pre> 
 </div> 
</div> 
<ul><li>对Qt的资源文件，使用 QT4_ADD_RESOURCES 来调用rcc进行预处理</li><li>对 Windows 资源文件，直接和源文件一样，添加到列表中即可。只是： 
  <ul><li>MinGW 下仅仅这么做还不行，上面的 MinGW 块用来修复这个问题</li></ul> </li></ul> 
<h3>Debug 与 Release</h3> 
<h4>qmake</h4> 
<p class="line874">使用 qmake 时，可以在 pro 文件内分别为两种模式设置不同的选项。</p> 
<p class="line874">使用时，可以直接 make release 或 make debug 来编译不同的版本</p> 
<h4>cmake</h4> 
<p class="line874">不同于 qmake，由于 cmake 采用 out-of-source 方式。故：</p> 
<ul><li>建立debug release两目录，分别在其中执行cmake -DCMAKE_BUILD_TYPE=Debug（或Release）</li><li>需要编译不同版本时进入不同目录执行make</li></ul> 
<p class="line874">对生成 msvc 工程的情况, CMAKE_BUILD_TYPE 不起作用。生成工程后使用IDE自带的模式选择。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f0455b1bef5c42b4508c54ba44dbfd82/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何清理“通知区域图标”中的过期图标</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3b384efebe1ae5c7db933232bd135f7e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Windows无法启动(WINDOWS\SYSTEM32\CONFIG\SYSTEM文件的损坏或丢失)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>