<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue经典面试题：常见的钩子函数你知道哪些 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue经典面试题：常见的钩子函数你知道哪些" />
<meta property="og:description" content="📌大前端入门到精通 专栏正在持续更新中，案例的原理图解析、各种模块分析💖这里都有哦，同时也欢迎大家订阅专栏，获取更多详细信息哦✊✊✊
✨个人主页：零小唬的博客主页
🥂欢迎大家 👍点赞 📨评论 🔔收藏
✨作者简介：20级计算机专业学生一枚，来自宁夏，可能会去做大前端，目前还在努力学习并记录博客中🧸
🎀本系列专栏: 大前端入门到精通
💕希望本文对你在学习前端的过程中有所帮助，如有不足请指正一起学习，一起进步🥇
⛪座右铭：只要你还愿意努力，世界一定会给你惊喜
首先，我们都应该知道在vue中可以自动执行的函数叫做钩子函数。
生命周期钩子函数
1、定义：vue实例从创建到销毁的过程中被自动执行的函数
2、书写位置：与 data methods watch computed directives 同级的位置
3、作用：给程序提供一个自动执行逻辑的场所
4、4大阶段8大钩子：
实例创建前后：
beforeCreate（数据的观测与事件的初始化 属性的创建还没有进行）created（此时vue实例已经创建完毕 所以数据的观测属性方法等内容都已经创建完毕（el属性还没有挂载）） 模板渲染前后：
beforeMount（页面挂载前调用，在此阶段页面还没有进行渲染与模板的编译，程序在此时会把数据绑定到页面上，但是页面并没有显示）mounted（页面已经渲染出来了，html的内容会在dom中进行加载展示） 数据更新前后：
beforeUpdate（在此时数据会不停的在dom中进行修改）updated（把修改之后的dom内容已经在页面成功的展示了） 实例销毁前后：
beforeDestory（此时vue实例还能用）destoryed（什么都没有了，vue实例等内容都没了） 5、生命周期第一次执行那些（页面第一次加载触发哪些）
实例创建之前-----beforeCreate实例创建之后-----created模板渲染之前-----beforeMount模板渲染之后-----mounted 6、dom在那个阶段渲染完毕
模板渲染之后-----mounted 自定义指令的钩子函数
1、常见的自定义指令的钩子函数：
bind 指令绑定到元素之上的时候执行 但是只执行一次unbind 指令被移除的时候执行 只执行一次update 所有组件节点更新的时候执行调用componentUpdate 指令所在节点以及所有的子节点都更新完成的时候调用inserted 绑定指令的元素在页面展示的时候调用（常用） 2、全局自定义指令–directive
Vue.directive(&#34;自定义指令名字&#34;,{ 自定义指令钩子函数(el你绑定自定义指令的dom){ 你的逻辑 } }) 3、局部自定义指令–directives
directives:{ 自定义指令的名字:{ 自定义指令的钩子函数（el代表的就是指定放在那个dom上形参就是谁）{ 你的逻辑 inserted(el){ el.focus() } } }, 自定义指令的名字2:{ }, } 路由的钩子函数
1、路由钩子（路由守卫/导航守卫/路由卫士）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/dbd45658ae3aa22e7f3dc0e36c4d7017/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-26T09:32:45+08:00" />
<meta property="article:modified_time" content="2023-11-26T09:32:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue经典面试题：常见的钩子函数你知道哪些</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>📌<a href="https://blog.csdn.net/weixin_55804957/category_12284247.html">大前端入门到精通</a> 专栏正在持续更新中，案例的原理图解析、各种模块分析💖这里都有哦，同时也欢迎大家订阅专栏，获取更多详细信息哦✊✊✊<br> ✨个人主页：<a href="https://blog.csdn.net/weixin_55804957">零小唬的博客主页</a><br> 🥂欢迎大家 👍点赞 📨评论 🔔收藏<br> ✨作者简介：20级计算机专业学生一枚，来自宁夏，可能会去做大前端，目前还在努力学习并记录博客中🧸<br> 🎀本系列专栏: <a href="https://blog.csdn.net/weixin_55804957/category_12284247.html">大前端入门到精通</a><br> 💕希望本文对你在学习前端的过程中有所帮助，如有不足请指正一起学习，一起进步🥇<br> ⛪座右铭：只要你还愿意努力，世界一定会给你惊喜</p> 
</blockquote> 
<hr> 
<p>首先，我们都应该知道在vue中可以<strong>自动执行的函数叫做钩子函数</strong>。</p> 
<hr> 
<p><strong>生命周期钩子函数</strong></p> 
<p>1、定义：vue实例从创建到销毁的过程中被自动执行的函数</p> 
<p>2、书写位置：与 data methods watch computed directives 同级的位置</p> 
<p>3、作用：给程序提供一个自动执行逻辑的场所</p> 
<p>4、4大阶段8大钩子：</p> 
<ul><li> <p>实例创建前后：</p> 
  <ul><li>beforeCreate（数据的观测与事件的初始化 属性的创建还没有进行）</li><li>created（此时vue实例已经创建完毕 所以数据的观测属性方法等内容都已经创建完毕（el属性还没有挂载））</li></ul> </li><li> <p>模板渲染前后：</p> 
  <ul><li>beforeMount（页面挂载前调用，在此阶段页面还没有进行渲染与模板的编译，程序在此时会把数据绑定到页面上，但是页面并没有显示）</li><li>mounted（页面已经渲染出来了，html的内容会在dom中进行加载展示）</li></ul> </li><li> <p>数据更新前后：</p> 
  <ul><li>beforeUpdate（在此时数据会不停的在dom中进行修改）</li><li>updated（把修改之后的dom内容已经在页面成功的展示了）</li></ul> </li><li> <p>实例销毁前后：</p> 
  <ul><li>beforeDestory（此时vue实例还能用）</li><li>destoryed（什么都没有了，vue实例等内容都没了）</li></ul> </li></ul> 
<p>5、生命周期第一次执行那些（页面第一次加载触发哪些）</p> 
<ul><li>实例创建之前-----beforeCreate</li><li>实例创建之后-----created</li><li>模板渲染之前-----beforeMount</li><li>模板渲染之后-----mounted</li></ul> 
<p>6、dom在那个阶段渲染完毕</p> 
<ul><li>模板渲染之后-----mounted</li></ul> 
<hr> 
<p><strong>自定义指令的钩子函数</strong></p> 
<hr> 
<p>1、常见的自定义指令的钩子函数：</p> 
<ul><li>bind 指令绑定到元素之上的时候执行 但是只执行一次</li><li>unbind 指令被移除的时候执行 只执行一次</li><li>update 所有组件节点更新的时候执行调用</li><li>componentUpdate 指令所在节点以及所有的子节点都更新完成的时候调用</li><li>inserted 绑定指令的元素在页面展示的时候调用（常用）</li></ul> 
<p>2、全局自定义指令–directive</p> 
<pre><code class="prism language-html">Vue.directive("自定义指令名字",{
  自定义指令钩子函数(el你绑定自定义指令的dom){
    你的逻辑
  }
})
</code></pre> 
<p>3、局部自定义指令–directives</p> 
<pre><code class="prism language-html">directives:{
    自定义指令的名字:{
	    自定义指令的钩子函数（el代表的就是指定放在那个dom上形参就是谁）{
			  你的逻辑
      inserted(el){
        el.focus()
      }
	    }
    },
    自定义指令的名字2:{
    },
}
</code></pre> 
<hr> 
<p><strong>路由的钩子函数</strong></p> 
<hr> 
<p>1、路由钩子（路由守卫/导航守卫/路由卫士）</p> 
<p>2、常见的钩子函数：</p> 
<ul><li> <p>全局前置守卫—beforeEach()：在所有路由跳转之前 触发的钩子函数（此时路由还没有跳转完成）</p> </li><li> <p>全局后置守卫— afterEach()：所有路由跳转之后 触发的钩子函数 （此时已经进入到了跳转之后的新页面）</p> </li></ul> 
<pre><code class="prism language-html">// 全局前置
router.beforeEach((to,from,next)=&gt;{
  console.log(to);
  console.log(from);
  //可以进行判断是否登录设置进步进入此页面
  if(to.path=="/phone"||to.path=="/shop"){
    next()
  }else{
    alert("您没有登录请您登录后再访问")
    next("/phone")
  }
})
// 全局后置
router.afterEach((to,from)=&gt;{
  console.log("全局后置守卫")
})
</code></pre> 
<ul><li>路由独享—beforeEnter：只会对一个路由规则生效（路由独享写在那个规则之上 就对哪一个生效）</li></ul> 
<pre><code class="prism language-html">{
  path: '/about',
  name: 'About',
  component: () =&gt; import('../views/About.vue'),
  // 路由独享守卫
  beforeEnter(to,from,next){
    console.log(to);
    console.log(from);
    next()
  }
},
</code></pre> 
<ul><li> <p>进入组件时候—beforeRouteEnter</p> </li><li> <p>离开组件的时候—beforeRouteLeave</p> </li></ul> 
<pre><code class="prism language-html">// 进入组件
beforeRouteEnter(to,from,next){
  console.log("我进来了")
  console.log(to)
  console.log(from)
  next()
},
beforeRouteLeave(to,from,next){
  console.log(to)
  console.log(from)
  if(confirm("您确定离开吗？")){
    next()
  }else{
    next(false)
  }
},
</code></pre> 
<hr> 
<p><strong>keep-alive钩子函数</strong></p> 
<hr> 
<p>1、在 Vue.js 中， 是一个抽象组件，用于缓存动态组件的状态，以便在组件切换时保留组件的状态和避免重新渲染。它可以在有条件地保留组件状态的情况下，提高应用性能。</p> 
<p>2、主要作用：</p> 
<ul><li>（1）缓存组件状态： 包裹的动态组件在被切换时，并不会被销毁，而是被缓存起来。这样在下次再切换到这个组件时，不需要重新创建和渲染，而是直接从缓存中取出，保留之前的状态。</li><li>（2）钩子函数： 提供了两个钩子函数，分别是 activated 和 deactivated。这些钩子函数在组件被激活（插入到 DOM 中）和停用（从 DOM 中移除）时被调用，可以用来执行一些特定的逻辑，例如数据的重置或异步操作。</li></ul> 
<p>3、常见的钩子函数：</p> 
<ul><li>activated 在进入被kepp-alive管理的组件时候触发 deactivated 在离开被kepp-alive管理的组件时候触发</li></ul> 
<p>注意：这两个钩子应该写在被keep-alive管理的组件中 与data等属性同级</p> 
<hr> 
<p>🎉<code>记录是为了不停的思考，创作更是为了更好的思考</code>，有人说过：2023年以后的中国市场将永远属于长期主义者，如果你觉得对您有帮助，欢迎一起交流学习，本人也是一名很菜的20级学生，编程界的小白，一起加油变优秀啦！</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b03dd10181dbcb3eb16df0cf3e9bc385/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue经典面试题：声明式导航和编程式导航</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1202aa2c2e373027a83018e75ea1e803/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">贪知梦连练</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>