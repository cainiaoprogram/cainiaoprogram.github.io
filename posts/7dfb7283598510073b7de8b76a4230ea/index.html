<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>sqlite删除一条记录android,android  – 在SQLite表中检索最后一条记录(再次) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="sqlite删除一条记录android,android  – 在SQLite表中检索最后一条记录(再次)" />
<meta property="og:description" content="我先做了几次搜索,但仍然有一个问题.
我发现最好的答案是this SO答案.总结如下：
SELECT * FROM TABLE WHERE ID =(SELECT MAX(ID)FROM TABLE);
我想知道的是,以下方法是否也能正常工作(因为我懒得改变它,我碰巧喜欢它).
SELECT * FROM TABLE ORDER BY ID DESC LIMIT 1
If no ROWID is specified on the insert, or if the specified ROWID has a value of NULL, then an appropriate ROWID is created automatically. The usual algorithm is to give the newly created row a ROWID that is one larger than the largest ROWID in the table prior to the insert." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7dfb7283598510073b7de8b76a4230ea/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-05-27T09:16:31+08:00" />
<meta property="article:modified_time" content="2021-05-27T09:16:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">sqlite删除一条记录android,android  – 在SQLite表中检索最后一条记录(再次)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>我先做了几次搜索,但仍然有一个问题.</p> 
 <p>我发现最好的答案是this SO答案.总结如下：</p> 
 <p>SELECT * FROM TABLE WHERE ID =(SELECT MAX(ID)FROM TABLE);</p> 
 <p>我想知道的是,以下方法是否也能正常工作(因为我懒得改变它,我碰巧喜欢它).</p> 
 <p>SELECT * FROM TABLE ORDER BY ID DESC LIMIT 1</p> 
 <p>If no ROWID is specified on the insert, or if the specified ROWID has a value of NULL, then an appropriate ROWID is created automatically. The usual algorithm is to give the newly created row a ROWID that is one larger than the largest ROWID in the table prior to the insert. If the table is initially empty, then a ROWID of 1 is used. [emphasis added]</p> 
 <p>并进一步,</p> 
 <p>The normal ROWID selection algorithm described above will generate monotonically increasing unique ROWIDs as long as you never use the maximum ROWID value and you never delete the entry in the table with the largest ROWID. If you ever delete rows or if you ever create a row with the maximum possible ROWID, then ROWIDs from previously deleted rows might be reused when creating new rows and newly created ROWIDs might not be in strictly ascending order. [emphasis added]</p> 
 <p>关于我提出的SQL语句的问题来自最后一句话.它似乎表明,如果删除任何行,无论是否使用了最大ROWID,都可以重用以前删除的ROWID.如果我们假设从不使用最大ROWID(手动或仅使用那么多记录),那么我们只需要担心删除记录.在这种情况下,第一个SQLite documnetation摘录使听起来好像你不会遇到我的查询的任何问题.</p> 
 <p>有人有确切消息么？</p> 
 <p>我喜欢我的查询,因为它只涉及一个选择(albiet,以订单为代价).我想,我可能过分关注微小的优化,不是吗？</p> 
 <p>编辑：</p> 
 <p>实际上,重新审查上面引用的SQLite页面,我认为使用AUTOINCREMENT关键字可以保证单调增加ROWID.最后一节详细讨论了它.</p> 
 <p>If a column has the type INTEGER PRIMARY KEY AUTOINCREMENT then a slightly different ROWID selection algorithm is used. The ROWID chosen for the new row is at least one larger than the largest ROWID that has ever before existed in that same table. If the table has never before contained any data, then a ROWID of 1 is used. If the table has previously held a row with the largest possible ROWID, then new INSERTs are not allowed and any attempt to insert a new row will fail with an SQLITE_FULL error.</p> 
 <p>我现在看起来很清楚.只是填不了表(最多9223372036854775807).</p> 
 <p>对不起,我之前只修过了这部分！</p> 
 <p>解决方法:</p> 
 <p>您显示的两个查询是等效的.</p> 
 <p>至于他们是否返回最后一条记录,这取决于“最后”的含义.如果删除行,则不能依赖任一查询来返回最后插入的行.</p> 
 <p>标签：android,sql,sqlite</p> 
 <p>来源： https://codeday.me/bug/20190725/1537950.html</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e7e92d6451f9e6fba9ca8ea0cfe92cc8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">android蓝牙包,Android Bluetooth蓝牙技术初体验</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c6d3e80732d34450a759f11633a075a7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">多种隐藏滚动条但是依然可以滚动实现方式</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>