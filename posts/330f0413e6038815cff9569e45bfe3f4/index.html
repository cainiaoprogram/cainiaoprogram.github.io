<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>基于轨迹的游客行为特征分析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="基于轨迹的游客行为特征分析" />
<meta property="og:description" content="---------------------------------------------------------------------------------------------
[版权申明：本文系作者原创，转载请注明出处] 文章出处：https://blog.csdn.net/sdksdk0/article/details/83068473
作者：朱培 ID：sdksdk0 --------------------------------------------------------------------------------------------
大数据时代，深度“数据挖掘”高级分析技术成为大势所趋，对于旅游景区来说，谁先掌握互联网平台、善用大数据，谁就最有可能先人一步破除体制壁垒与管理围墙，实现转型升级和跨越式发展。通过在旅游景区部署移动信号监测设备，就可以发现该群体游客的相关属性，例如在一个区县，在不同景点之间部署，可以发现游客移动的轨迹是怎么样，本文主要就是用于分析游客在不同景点之间的浏览情况，这样可以更加合理的设计景区与景区之间的交通路线，销售相关旅游产品和应急预案等方面的东西。本文所涉及的内容使用mysql&#43;springboot来实现。
首先来看一下清洗完成后的数据：浏览线路的格式为： 景区A=&gt;景区C=&gt;景区B=&gt;景区D。
现在有数据格式如下（完整的数据集在文末提供下载链接）：
第一列为id，第二列为景区编号，第三列为用户编号，第四列为时间，第五列为景区名称。
1 18C8E750176E 3478D7E2C139 20180503000000 嵩溪村
2 18C8E750182A C46699E01080 20180503000000 江南第一家花海
3 18C8E750180E 084ACF3E591F 20180503000000 水晶城
4 18C8E75017DA 386EA2788110 20180503000000 高速路
5 18C8E7501806 205D479A3020 20180503000001 翠湖
6 18C8E750181E 442C05543BED 20180503000001 水晶城
7 18C8E750182E F06D781D8FAF 20180503000002 通济桥水库大坝
8 18C8E75017EE B4EFFAC7D0C7 20180503000002 汽车客运站
9 18C8E75017EE 6C5C14743F6F 20180503000002 汽车客运站
10 18C8E75017A6 F4B7B356B876 20180503000003 檀溪镇
11 18C8E750181A 4C0FC7DF8C8E 20180503000003 金狮湖
12 18C8E750180A B436A9063032 20180503000003 翠湖" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/330f0413e6038815cff9569e45bfe3f4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-10-16T10:33:28+08:00" />
<meta property="article:modified_time" content="2018-10-16T10:33:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">基于轨迹的游客行为特征分析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>---------------------------------------------------------------------------------------------<br> [版权申明：本文系作者原创，转载请注明出处] <br> 文章出处：<a href="https://blog.csdn.net/sdksdk0/article/details/83068473">https://blog.csdn.net/sdksdk0/article/details/83068473</a></p> 
<p>作者：朱培      ID：sdksdk0     <br> --------------------------------------------------------------------------------------------</p> 
<p>大数据时代，深度“数据挖掘”高级分析技术成为大势所趋，对于旅游景区来说，谁先掌握互联网平台、善用大数据，谁就最有可能先人一步破除体制壁垒与管理围墙，实现转型升级和跨越式发展。通过在旅游景区部署移动信号监测设备，就可以发现该群体游客的相关属性，例如在一个区县，在不同景点之间部署，可以发现游客移动的轨迹是怎么样，本文主要就是用于分析游客在不同景点之间的浏览情况，这样可以更加合理的设计景区与景区之间的交通路线，销售相关旅游产品和应急预案等方面的东西。本文所涉及的内容使用mysql+springboot来实现。</p> 
<p>首先来看一下清洗完成后的数据：浏览线路的格式为：  景区A=&gt;景区C=&gt;景区B=&gt;景区D。</p> 
<p>现在有数据格式如下（完整的数据集在文末提供下载链接）：</p> 
<p>第一列为id，第二列为景区编号，第三列为用户编号，第四列为时间，第五列为景区名称。</p> 
<p>1    18C8E750176E    3478D7E2C139    20180503000000     嵩溪村<br> 2    18C8E750182A    C46699E01080    20180503000000     江南第一家花海<br> 3    18C8E750180E    084ACF3E591F    20180503000000     水晶城<br> 4    18C8E75017DA    386EA2788110    20180503000000     高速路<br> 5    18C8E7501806    205D479A3020    20180503000001     翠湖<br> 6    18C8E750181E    442C05543BED    20180503000001     水晶城<br> 7    18C8E750182E    F06D781D8FAF    20180503000002     通济桥水库大坝<br> 8    18C8E75017EE    B4EFFAC7D0C7    20180503000002     汽车客运站<br> 9    18C8E75017EE    6C5C14743F6F    20180503000002     汽车客运站<br> 10    18C8E75017A6    F4B7B356B876    20180503000003     檀溪镇<br> 11    18C8E750181A    4C0FC7DF8C8E    20180503000003     金狮湖<br> 12    18C8E750180A    B436A9063032    20180503000003     翠湖</p> 
<p>下载需要统计的就是同一个用户去了哪些景区，按时间维度进行排列，即可得出单个游客的移动轨迹。然后将所有游客的轨迹在一个List中进行合并处理，相同游客轨迹的数量加1，最终即可全部游客的移动轨迹。因为全部数据量在非常大，所以数据从数据仓库中选取了某一天的部分数据量来这里做演示。</p> 
<p>1、在mysql数据库中创建表orbit_data，将数据集导入进去（文末提供数据集下载链接）</p> 
<p>2、创建bean，OrbitData.java,里面包含和数据库表结构相对应的字段</p> 
<p>    private Integer id;<br>     private String probMac;<br>     private String devcMac;<br>     private String inTime;<br>     private String name;</p> 
<p>3、mybatiss中查询</p> 
<p>&lt;select id="selectByMapAllList" resultType="OrbitData"&gt;<br>         select *  from orbit_data  where 1=1<br>         and devcMac in<br>         (select devcMac from  orbit_data  where 1=1<br>         and length(devcMac)&gt;=10<br>         &lt;if test="beginTime != null and beginTime != '' "&gt;<br>             and inTime &lt;![CDATA[ &gt;= ]]&gt; #{beginTime}<br>         &lt;/if&gt;<br>         &lt;if test="endTime != null and endTime != '' "&gt;<br>             and inTime &lt;![CDATA[ &lt;=]]&gt; #{endTime}<br>         &lt;/if&gt;<br>         group by devcMac<br>         having count(*)&gt;1<br>         )<br>         &lt;if test="beginTime != null and beginTime != '' "&gt;<br>             and inTime &lt;![CDATA[ &gt;= ]]&gt; #{beginTime}<br>         &lt;/if&gt;<br>         &lt;if test="endTime != null and endTime != '' "&gt;<br>             and inTime &lt;![CDATA[ &lt;=]]&gt; #{endTime}<br>         &lt;/if&gt;<br>         order by devcMac,inTime asc<br>     &lt;/select&gt;</p> 
<p>4、因为这个轨迹分析计算是离线处理的，每天只需要运行一次即可，所以处理逻辑如下：</p> 
<p>log.info("游客轨迹分析定时任务，开始...");<br>         //获取总人数<br>         Calendar cal = Calendar.getInstance();<br>         cal.add(Calendar.DATE, -1);<br>         String dayId = DateUtil.format(cal.getTime(), "yyyyMMdd");<br>         String beginTime = dayId + "000000";<br>         String endTime = dayId+"235959";<br>         <br>         List&lt;OrbitData&gt; orbitList = orbitMapper.selectByMapAllList(beginTime,endTime);<br>         <br>         List&lt;Map&lt;String, Object&gt;&gt; lineList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();<br>  <br>         String tempLine="";<br>         for(int i=0;i&lt;orbitList.size();i++){<!-- --><br>             Map&lt;String, Object&gt; lineMap=new HashMap&lt;String,Object&gt;();<br>             OrbitData orbit = orbitList.get(i);<br>             if(i==0){<!-- --><br>                 tempLine = orbitList.get(i).getName()+"=&gt;";<br>                 location += "("+orbitList.get(i).getLongitude()+","+orbitList.get(i).getLatitude()+"),";<br>             }else if(i&gt;0 &amp;&amp; i&lt;orbitList.size()){<!-- --><br>                 //如果相等，说明是同一个人<br>                 if(orbit.getDevcMac().equals(orbitList.get(i-1).getDevcMac())){<!-- --><br>                     if(!orbitList.get(i-1).getName().equals(orbit.getName())){<!-- --><br>                         BigDecimal a= new BigDecimal(orbitList.get(i-1).getInTime().toString().trim());<br>                         BigDecimal b= new BigDecimal(orbitList.get(i).getInTime().toString().trim());<br>                         BigDecimal cc=b.subtract(a);</p> 
<p>                         //不同景点之间需要间隔10分钟以上的才属于有效数据<br>                         if( cc.compareTo(new BigDecimal(1000))&gt;-1){<!-- --><br>                             tempLine += orbitList.get(i).getName()+"=&gt;";    <br>                         }else if(i+1&lt;orbitList.size()){<!-- --><br>                            <br>                             if(!orbit.getDevcMac().equals(orbitList.get(i+1).getDevcMac())){<!-- --><br>                                 tempLine += orbitList.get(i).getName()+"=&gt;";    <br>                             }<br>                         }<br>                     }<br>                 }else{<!-- --><br>                     String[] split = tempLine.split("=&gt;");<br>                     if(split.length&gt;1){<!-- --><br>                         tempLine=tempLine.substring(0,tempLine.length()-2);<br>                         lineMap.put("track", tempLine);<br>                         lineMap.put("day_id", DateUtil.format(cal.getTime(), "yyyy-MM-dd"));<br>                         lineMap.put("num", 1);<br>                         lineList.add(lineMap);<br>                     }<br>                     tempLine="";<br>                     location="";<br>                     tempLine += orbitList.get(i).getName()+"=&gt;";    <br>                 }<br>             }<br>         }<br>         <br>         //lineList合并处理<br>         List&lt;Map&lt;String, Object&gt;&gt; countList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();// 用于存放最后的结果<br>         for (int i = 0; i &lt; lineList.size(); i++) {<!-- --><br>             String track = lineList.get(i).get("track").toString();<br>             String day_id = lineList.get(i).get("day_id").toString();<br>             int flag = 0;// 0为新增数据，1为增加count<br>             for (int j = 0; j &lt; countList.size(); j++) {<!-- --><br>                 String track_ = countList.get(j).get("track").toString();<br>                 String day_id_ = countList.get(j).get("day_id").toString();<br>                 if (track.equals(track_) &amp;&amp; day_id.equals(day_id_)) {<!-- --><br>                     int sum = Integer.parseInt(lineList.get(i).get("num").toString())<br>                             + Integer.parseInt(countList.get(j).get("num").toString());<br>                     countList.get(j).put("num", sum + "");<br>                     flag = 1;<br>                     continue;<br>                 }<br>             }<br>             if (flag == 0) {<!-- --><br>                 countList.add(lineList.get(i));<br>             }<br>         }<br>         if(countList.size()&gt;0){<!-- --></p> 
<p>          //将查询出来的结果存放到数据库中<br>             personStayLineMapper.insertBatch(countList);<br>         }<br>         log.info("游客轨迹分析定时任务，结束...");</p> 
<p>5、处理完成的结果如下</p> 
<p><img alt="" class="has" height="736" src="https://images2.imgbox.com/e5/c1/CIfLV3qv_o.png" width="447"></p> 
<p>处理完成之后有的有轨迹至少要有2个景区，同时会存在有多个景点情况</p> 
<p><img alt="" class="has" height="685" src="https://images2.imgbox.com/7c/1d/pYvgd8Fu_o.png" width="427"></p> 
<p> </p> 
<p>数据集下载地址为：<a href="https://download.csdn.net/download/sdksdk0/10723169">https://download.csdn.net/download/sdksdk0/10723169</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8d424a6201844343435a805d07590651/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">div内的scroll局部滚动</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b97e4fdbb471b367874128b36420b8c3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android 通过ADB Shell 强行关闭和启动应用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>