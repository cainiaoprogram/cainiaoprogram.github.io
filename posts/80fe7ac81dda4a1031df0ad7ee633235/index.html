<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Java实习生】每日面试题打卡——计算机网络篇 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Java实习生】每日面试题打卡——计算机网络篇" />
<meta property="og:description" content="临近秋招，备战暑期实习，祝大家每天进步亿点点！Day14本篇总结的是 计算机网络 相关的面试题，后续会每日更新~文章参考自：硬核！30 张图解 HTTP 常见的面试题、JAVA开发面试题_网络_操作系统、计算机网络面试题、JavaGuide 1、OSI 七层结构、TCP/IP 四层结构、五层协议结构 OSI 七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。TCP/IP 四层：网络接口层、网际层、运输层、应用层。五层协议：物理层、数据链路层、网络层、运输层、应用层。 注：按照由下至上的顺序。
OSI 七层参考模型，每一层的作用：
对应的层作用对应的网络协议/硬件物理层提供数据传输的硬件保证，网卡接口，传输介质。中继器、集线器、网关.数据链路层进行数据交换，将要传输的数据转换为二进制形式。网卡、网桥、交换机网络层进行路由选择，网络互联。IP、ICMP、…传输层用于端到端的可靠数据传输。TCP 、UDP、…会话层用于建立用户级的连接，选择适当的传输服务。SQL、RPC、…表示层用于对数据的压缩、加密。JPEG、MPEG、ASII、…应用层提供用户服务，具体功能由应用程序实现。SMTP、HTTP、DNS、… 2、TCP 和 UDP 的区别？基于 TCP、UDP 的协议有哪些？ TCP 和 UDP 的区别？
TCP 提供面向连接的、可靠的数据流传输，而 UDP 提供的是无连接的、不可靠的数据流传输。TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。TCP 传输单位称为 TCP 报文段，UDP 传输单位称为用户数据报。TCP 注重数据安全性，UDP 数据传输快，因为不需要连接等待，少了许多操作，但是其安全性却一般。 面向连接与非面向连接区别？
面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。非面向连接地服务，不需要预先建立一个联络两个通信节点地连接，需要通信地时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输地过程中不再加以监控。 基于 TCP、UDP 的协议有哪些？
基于 TCP 的协议：
HTTP：Web服务器传输超文本到本地浏览器的传送协议。SMTP：邮件传送协议，用于发送邮件。服务器开放的是 25 号端口。FTP：定义了文件传输协议，使用21 端口。… 基于 UDP 的协议：
DNS：用于域名解析服务，将域名地址转换为 IP 地址。DNS 用的是53号端口。… TCP 与 UDP 的适用场景：
TCP：当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，HTTP、HTTPS、FTP等传输文件的协议会使用到。
UDP：当强调传输性能而不是传输的完整性时，要求网络通讯速度能尽量的快：如 QQ语音，QQ视频等。
3、TCP 协议如何保证可靠传输？ TCP 通过以下几种措施来保证数据的可靠传输：
① 对应用数据进行分割：将应用数据被分割成 TCP 认为最适合发送的数据块。② 对数据包进行编号：TCP 给要发送的每一个数据包进行编号，接收方按照编号对数据包进行排序，把有序数据传送给应用层。③ 校验和：这是一个端到端的校验，目的是检测数据在传输过程中的任何变化。如果接受端的校验有差错，说明数据在传输过程中出问题了，接收端将丢弃不再接受该数据。④ 流量控制： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）⑤ 拥塞控制：当网络拥塞时，减少数据的发送。防止过多的数据注入到网络中，避免传输链路过载。⑥ ARQ协议：该协议也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。⑦ 超时重传：当 TCP 发出一个报文段后，它启动一个定时器，等待接收端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。 滑动窗口和流量控制：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/80fe7ac81dda4a1031df0ad7ee633235/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-03T07:56:31+08:00" />
<meta property="article:modified_time" content="2021-06-03T07:56:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Java实习生】每日面试题打卡——计算机网络篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <ul><li>临近秋招，备战暑期实习，祝大家每天进步亿点点！<mark>Day14</mark></li><li>本篇总结的是 <strong>计算机网络</strong> 相关的面试题，后续会每日更新~</li><li>文章参考自：<a href="https://mp.weixin.qq.com/s/bUy220-ect00N4gnO0697A" rel="nofollow">硬核！30 张图解 HTTP 常见的面试题</a>、<a href="https://blog.csdn.net/weixin_37841366/article/details/109110242">JAVA开发面试题_网络_操作系统</a>、<a href="https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html" rel="nofollow">计算机网络面试题</a>、<a href="https://snailclimb.gitee.io/javaguide/#/docs/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C" rel="nofollow">JavaGuide</a></li></ul> 
<p><img src="https://images2.imgbox.com/77/5b/uzo4GBAq_o.jpg" alt="在这里插入图片描述" width="400" height="400"></p> 
<hr> 
<h3><a id="1OSI_TCPIP__9"></a>1、OSI 七层结构、TCP/IP 四层结构、五层协议结构</h3> 
<ul><li><strong>OSI 七层</strong>：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。</li><li><strong>TCP/IP 四层</strong>：网络接口层、网际层、运输层、应用层。</li><li><strong>五层协议</strong>：物理层、数据链路层、网络层、运输层、应用层。</li></ul> 
<p><strong>注</strong>：按照由下至上的顺序。</p> 
<blockquote> 
 <p>OSI 七层参考模型，每一层的作用：</p> 
</blockquote> 
<table><thead><tr><th>对应的层</th><th>作用</th><th>对应的网络协议/硬件</th></tr></thead><tbody><tr><td>物理层</td><td>提供数据传输的<strong>硬件保证</strong>，网卡接口，传输介质。</td><td>中继器、集线器、网关.</td></tr><tr><td>数据链路层</td><td>进行<strong>数据交换</strong>，将要传输的数据转换为二进制形式。</td><td>网卡、网桥、交换机</td></tr><tr><td>网络层</td><td>进行<strong>路由选择</strong>，网络互联。</td><td><strong>IP</strong>、ICMP、…</td></tr><tr><td>传输层</td><td>用于端到端的可靠数据传输。</td><td><strong>TCP</strong> 、<strong>UDP</strong>、…</td></tr><tr><td>会话层</td><td>用于建立用户级的连接，选择适当的<strong>传输服务</strong>。</td><td>SQL、<strong>RPC</strong>、…</td></tr><tr><td>表示层</td><td>用于对数据的<strong>压缩</strong>、<strong>加密</strong>。</td><td>JPEG、MPEG、ASII、…</td></tr><tr><td>应用层</td><td>提供用户服务，具体功能由应用程序实现。</td><td>SMTP、<strong>HTTP</strong>、DNS、…</td></tr></tbody></table> 
<hr> 
<h3><a id="2TCP__UDP__TCPUDP__31"></a>2、TCP 和 UDP 的区别？基于 TCP、UDP 的协议有哪些？</h3> 
<blockquote> 
 <p>TCP 和 UDP 的区别？</p> 
</blockquote> 
<ul><li>TCP 提供<strong>面向连接</strong>的、<strong>可靠的数据流传输</strong>，而 UDP 提供的是<strong>无连接</strong>的、<strong>不可靠的数据流传输</strong>。</li><li>TCP保证数据正确性，UDP可能丢包，TCP保证数据顺序，UDP不保证。</li><li>TCP 传输单位称为 <strong>TCP 报文段</strong>，UDP 传输单位称为<strong>用户数据报</strong>。</li><li><strong>TCP 注重数据安全性</strong>，<strong>UDP 数据传输快</strong>，因为不需要连接等待，少了许多操作，但是其安全性却一般。</li></ul> 
<blockquote> 
 <p>面向连接与非面向连接区别？</p> 
</blockquote> 
<ul><li>面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。</li><li>非面向连接地服务，不需要预先建立一个联络两个通信节点地连接，需要通信地时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输地过程中不再加以监控。</li></ul> 
<blockquote> 
 <p>基于 TCP、UDP 的协议有哪些？</p> 
</blockquote> 
<p>基于 TCP 的协议：</p> 
<ul><li><strong>HTTP</strong>：Web服务器传输超文本到本地浏览器的传送协议。</li><li><strong>SMTP</strong>：邮件传送协议，用于发送邮件。服务器开放的是 <strong>25</strong> 号端口。</li><li><strong>FTP</strong>：定义了文件传输协议，使用<strong>21</strong> 端口。</li><li>…</li></ul> 
<p>基于 UDP 的协议：</p> 
<ul><li><strong>DNS</strong>：用于<strong>域名解析</strong>服务，将域名地址转换为 IP 地址。DNS 用的是<strong>53</strong>号端口。</li><li>…</li></ul> 
<blockquote> 
 <p>TCP 与 UDP 的适用场景：</p> 
</blockquote> 
<p>TCP：当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，HTTP、HTTPS、FTP等传输文件的协议会使用到。</p> 
<p>UDP：当强调传输性能而不是传输的完整性时，要求网络通讯速度能尽量的快：如 QQ语音，QQ视频等。</p> 
<hr> 
<h3><a id="3TCP__67"></a>3、TCP 协议如何保证可靠传输？</h3> 
<blockquote> 
 <p>TCP 通过以下几种措施来保证数据的可靠传输：</p> 
</blockquote> 
<ul><li><strong>① 对应用数据进行分割</strong>：将应用数据被分割成 TCP 认为最适合发送的数据块。</li><li><strong>② 对数据包进行编号</strong>：TCP 给要发送的每一个数据包进行编号，接收方按照编号对数据包进行排序，把有序数据传送给应用层。</li><li><strong>③ 校验和</strong>：这是一个端到端的校验，目的是检测数据在传输过程中的任何变化。如果接受端的校验有差错，说明数据在传输过程中出问题了，接收端将丢弃不再接受该数据。</li><li><strong>④ 流量控制</strong>： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。<mark>TCP 使用的流量控制协议是可变大小的滑动窗口协议</mark>。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>⑤ 拥塞控制</strong>：当网络拥塞时，减少数据的发送。防止过多的数据注入到网络中，避免传输链路过载。</li><li><strong>⑥ ARQ协议</strong>：该协议也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>⑦ 超时重传</strong>：当 TCP 发出一个报文段后，它启动一个定时器，等待接收端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ul> 
<blockquote> 
 <p>滑动窗口和流量控制：</p> 
</blockquote> 
<p>TCP利用<strong>滑动窗口</strong>实现<strong>流量控制</strong>。<strong>流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong></p> 
<p>接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p> 
<blockquote> 
 <p>TCP如何实现拥塞控制？</p> 
</blockquote> 
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口</strong>(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p> 
<p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始 、 拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。</p> 
<ul><li><strong>慢开始</strong>： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li><li><strong>拥塞避免</strong>： 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li><li><strong>快重传与快恢复</strong>： 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li></ul> 
<hr> 
<h3><a id="4_TCP__96"></a>4、什么是 TCP 粘包，它的产生原因以及解决方法？</h3> 
<ul><li>TCP 粘包是指：<strong>发送方发送的若干个包数据到接收方接收时，粘成一个包数据</strong>。</li><li>TCP 是基于字节流的，虽然应用层和 TCP 传输层之间的数据交互是大小不等的数据块，但是 TCP 把这些数据块仅仅看成一连串无结构的字节流，没有边界，这就可能导致字节流合并（粘包）。</li></ul> 
<blockquote> 
 <p>TCP 粘包产生的原因：</p> 
</blockquote> 
<h4><a id="__103"></a>① 发送方产生的粘包</h4> 
<ul><li>采用 TCP 协议传输数据的客户端与服务器经常是保持一个长连接的状态（一次连接发一次数据不存在粘包），双方在连接不断开的情况下，可以一直传输数据。但当发送的数据包过于的小时，那么 TCP 协议默认的会启用 <strong>Nagle 算法</strong>，将这些较小的数据包进行合并发送（缓冲区数据发送是一个堆压的过程）；这个合并过程就是在发送缓冲区中进行的，也就是说数据发送出来它已经是粘包的状态了。</li><li>总结：<strong>要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。</strong></li></ul> 
<h4><a id="__108"></a>② 接受方产生的粘包</h4> 
<ul><li>接收方采用 TCP 协议接收数据时的过程是这样的：数据到接收方，从网络模型的下方传递至传输层，传输层的 TCP 协议处理是将其放置接收缓冲区，然后由应用层来主动获取（例如C 语言用函数等）；这时会出现一个问题，就是我们在程序中调用的读取数据函数不能及时的把缓冲区中的数据拿出来，而下一个数据又到来并有一部分放入的缓冲区末尾，等我们读取数据时就是一个粘包。（放数据的速度 &gt; 应用层拿数据速度）。</li><li>总结：<strong>接收数据端的应用层没有及时读取缓冲区中的数据，导致缓冲区数据堆积，将发生粘包。</strong></li></ul> 
<h4><a id="_113"></a>如何避免粘包？</h4> 
<p>避免粘包有以下两种方式：</p> 
<ul><li>在每个包的末尾加上特殊字符，用以区分连续的两个包。（例如加<code>\r\n</code>标记）</li><li>在报文首部添加包的长度。</li></ul> 
<hr> 
<h3><a id="5TCP__122"></a>5、TCP 三次握手和四次挥手</h3> 
<ul><li>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。</li><li><strong>建立一个 TCP 连接需要"三次握手"</strong>。</li></ul> 
<h4><a id="51_127"></a>5.1、三次握手图解</h4> 
<p>如下图所示，下面的两个机器人通过 3 次握手确定了对方能正确接收和发送消息：</p> 
<p><img src="https://images2.imgbox.com/ec/b0/oLGdVN0k_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/ac/cb/94hsiWFG_o.png" alt=""></p> 
<p>上图流程为：</p> 
<ul><li>一次握手：客户端发送带有 <strong>SYN</strong> 标志的数据包给服务端。</li><li>二次握手：服务端发送带有 <strong>SYN/ACK</strong> 标志的数据包给客户端。</li><li>三次握手：客户端发送带有带有 <strong>ACK</strong> 标志的数据包给服务端。</li></ul> 
<h4><a id="52_141"></a>5.2、为什么要三次握手？</h4> 
<p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p> 
<ul><li>第一次握手：是为了服务端确认对方 (客户端) 发送数据正常，自己接收数据正常。</li><li>第二次握手：是为了客户端确认自己发送、接收数据正常，同时客户端也知道了对方 (服务端) 发送、接收数据都正常。</li><li>第三次握手：是为了让服务端确认自己发送、接收数据正常，同时服务端也知道了对方 (客户端) 发送、接收数据正常。</li></ul> 
<p>所以三次握手<strong>为了让客户端和服务端双方，互相都知道自己和对方发送、接收功能都正常</strong>，缺一不可。</p> 
<h4><a id="53_ACK__SYN__151"></a>5.3、第二次握手服务端传回了 ACK 为什么还要传回 SYN ？</h4> 
<p>服务端端传回发送端所发送的 <strong>ACK</strong> 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 <strong>SYN</strong> 则是为了建立从服务端到客户端的通信。</p> 
<blockquote> 
 <p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p> 
</blockquote> 
<h4><a id="54__157"></a>5.4 为什么要四次挥手？</h4> 
<p>如图所示：</p> 
<p><img src="https://images2.imgbox.com/de/7f/WbzEhlXx_o.png" alt=""></p> 
<p><strong>断开一个 TCP 连接则需要“四次挥手”</strong>：</p> 
<ul><li>第一次挥手：客户端发送一个 <strong>FIN</strong> 数据包给服务端，用来告诉服务端，我要关闭与你的 TCP 连接。(<strong>客户端主动关闭到服务器的数据传输，但此时客户端还能接收服务端传来的数据</strong>)</li><li>服务端收到这个 <strong>FIN</strong> 数据包后，它返回一 个 <strong>ACK</strong> 数据包给客户端，确认序号为收到的序号加 <em>1</em> （和 <strong>SYN</strong> 一样，一个 <strong>FIN</strong> 将占用一个序号），目的是告诉客户端，我收到了你的关闭连接请求。</li><li>服务端主动关闭到客户端的连接，并发送一个<strong>FIN</strong> 数据包给客户端，告诉客户端我也关闭了和你的 TCP 连接。(<strong>服务端不会再给客户端发送数据了</strong>)</li><li>客户端收到服务端返回的 <strong>FIN</strong> 数据包后，再发送一个 <strong>ACK</strong> 数据包给服务端确认，并将确认序号设置为收到序号加 <em>1</em>。</li></ul> 
<h4><a id="55_170"></a>5.5、如果已经建立了连接，但是客户端突然出现故障了怎么办？</h4> 
<ul><li>TCP 设有一个<strong>保活计时器</strong>，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户请求后都会重新复位这个计时器，时间通常是设置为 <em>2</em> 小时，若两小时还没收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔 <em>75</em> 秒发送一次。若一连发送 <em>10</em> 个探测报文仍然没有反应，服务器就认为客户端出了故障，接着就关闭连接。</li></ul> 
<hr> 
<h3><a id="6URL__176"></a>6、在浏览器中输入URL 地址，回车后经历了那些过程</h3> 
<ul><li><strong>所经历的过程</strong>：DNS 域名解析、TCP 连接、发送 HTTP 请求、服务器处理请求并返回 HTTP 报文、浏览器渲染、结束。</li></ul> 
<p>下面来逐步分析一下：</p> 
<h4><a id="_DNS__182"></a>① DNS 域名解析</h4> 
<p>当我们在浏览器中输入一个域名然后回车时，首先检查本机的‪<code>C:\Windows\System32\drivers\etc\hosts</code>配置文件下有没有对应的域名映射，如下所示：</p> 
<pre><code class="prism language-sql"><span class="token comment"># 前台本机域名映射</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span>:<span class="token number">80</span> web<span class="token punctuation">.</span>csp1999<span class="token punctuation">.</span>com
    
<span class="token comment"># 后端接口本机域名映射</span>
<span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span>:<span class="token number">8080</span> api<span class="token punctuation">.</span>csp1999<span class="token punctuation">.</span>com   
</code></pre> 
<p><strong>如果有</strong>，则返回对应的 <strong>IP</strong> 地址。</p> 
<p><strong>如果没有</strong>，浏览器会发出一个 DNS 请求到本地DNS服务器找对应的 <strong>IP</strong> 地址，本地 DNS 服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动：（图片来源：<a href="" rel="nofollow">https://blog.csdn.net/qq_45173404/article/details/117396953</a>）</p> 
<p><img src="https://images2.imgbox.com/94/37/yfTRgrFM_o.png" alt=""></p> 
<h4><a id="__TCP__200"></a>② 建立 TCP 连接：三次握手</h4> 
<ul><li>解析出 <strong>IP</strong> 地址后，浏览器根据 <strong>IP</strong> 地址和默认端口 <strong>443</strong> 向网站的服务器发起请求，三次握手，建立 <strong>TCP</strong> 连接。</li></ul> 
<h4><a id="__HTTP__204"></a>③ 发送 HTTP 请求</h4> 
<ul><li>建立好 TCP 连接后，浏览器 (客户端) 通过 HTTP 协议发送请求，请求从服务器端获取数据。</li><li>服务器处理客户端的 HTTP 请求后，就将请求的数据返回给浏览器。</li></ul> 
<h4><a id="__TCP__209"></a>④ 关闭 TCP 连接：四次挥手</h4> 
<ul><li>浏览器与服务器数据传送完毕后，四次握手，释放 TCP 连接。</li></ul> 
<h4><a id="__213"></a>⑤ 浏览器回显</h4> 
<ul><li>浏览器对数据进行解析并渲染显示。</li></ul> 
<hr> 
<h3><a id="7HTTP_219"></a>7、什么是HTTP协议？</h3> 
<blockquote> 
 <p>HTTP的概念：</p> 
</blockquote> 
<ul><li>HTTP 是超文本传输协议，<strong>用于客户端和服务器端之间的通信</strong>，即在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</li></ul> 
<blockquote> 
 <p>HTTP 的特性(优点)：</p> 
</blockquote> 
<ul><li>HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」。</li></ul> 
<blockquote> 
 <p>HTTP的常见字段：</p> 
</blockquote> 
<h4><a id="_Host__231"></a>① Host 字段</h4> 
<ul><li>客户端发送请求时，用来指定服务器的域名。</li></ul> 
<p><img src="https://images2.imgbox.com/bb/90/Vos5RuI3_o.png" alt=""></p> 
<pre><code class="prism language-javascript">Host<span class="token punctuation">:</span> www<span class="token punctuation">.</span><span class="token constant">A</span><span class="token punctuation">.</span>com
</code></pre> 
<p>有了 <code>Host</code> 字段，就可以将请求发往「同一台」服务器上的不同网站。</p> 
<h4><a id="_ContentLength__243"></a>② Content-Length 字段</h4> 
<ul><li>服务器在返回数据时，会有 <code>Content-Length</code> 字段，表明本次响应的数据长度。</li></ul> 
<p><img src="https://images2.imgbox.com/76/d6/ZkE6Kl7G_o.png" alt=""></p> 
<pre><code class="prism language-javascript">Content<span class="token operator">-</span>Length<span class="token punctuation">:</span> <span class="token number">1000</span>
</code></pre> 
<p>如上面则是告诉浏览器，本次服务器回应的数据长度是 1000 个字节，后面的字节就属于下一个回应了。</p> 
<h4><a id="_Connection__255"></a>③ Connection 字段</h4> 
<ul><li><code>Connection</code> 字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。</li></ul> 
<p><img src="https://images2.imgbox.com/79/18/ICGTJgY9_o.png" alt=""></p> 
<p>HTTP/1.1 版本的默认连接都是持久连接，但为了兼容老版本的 HTTP，需要指定 <code>Connection</code> 首部字段的值为 <code>Keep-Alive</code>。</p> 
<pre><code class="prism language-javascript">Connection<span class="token punctuation">:</span> keep<span class="token operator">-</span>alive
</code></pre> 
<p>一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段。</p> 
<h4><a id="_ContentType__269"></a>④ Content-Type 字段</h4> 
<ul><li><code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。</li></ul> 
<p><img src="https://images2.imgbox.com/9d/64/GT2XD1iw_o.png" alt=""></p> 
<pre><code class="prism language-javascript">Content<span class="token operator">-</span>Type<span class="token punctuation">:</span> text<span class="token operator">/</span>html<span class="token punctuation">;</span> charset<span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span>
</code></pre> 
<p>上面的类型表明，发送的是网页，而且编码是UTF-8。</p> 
<p>客户端请求的时候，可以使用 <code>Accept</code> 字段声明自己可以接受哪些数据格式。</p> 
<pre><code class="prism language-javascript">Accept<span class="token punctuation">:</span> <span class="token operator">*</span><span class="token comment">/*
</span></code></pre> 
<p>上面代码中，客户端声明自己可以接受任何格式的数据。</p> 
<h4><a id="_ContentEncoding__289"></a>⑤ Content-Encoding 字段</h4> 
<ul><li><code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。</li></ul> 
<p><img src="https://images2.imgbox.com/96/78/0cAmEufs_o.png" alt=""></p> 
<pre><code class="prism language-java">Content<span class="token operator">-</span>Encoding<span class="token operator">:</span> gzip
</code></pre> 
<p>上面表示服务器返回的数据采用了 <strong>gzip</strong> 方式压缩，告知客户端需要用此方式解压。</p> 
<p>客户端在请求时，用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法。</p> 
<pre><code class="prism language-javascript">Accept<span class="token operator">-</span>Encoding<span class="token punctuation">:</span> gzip<span class="token punctuation">,</span> deflate
</code></pre> 
<hr> 
<h3><a id="8GET__POST__309"></a>8、GET 和 POST 的区别？</h3> 
<ul><li><strong>URL 中参数可见性</strong>：GET 参数可见（通过拼接 URL 进行传递参数），POST 参数不可见。</li><li><strong>是否可缓存</strong>：GET 请求是可以缓存的，POST 请求不可以缓存。</li><li><strong>传输数据的大小</strong>：GET 一般传输数据大小不超过 <code>2k-4k</code>（根据浏览器不同，限制不一样，但相差不大），POST 请求传输数据的大小根据 <code>php.ini</code> 配置文件设定，也可以无限大。</li><li><strong>安全性</strong>：GET 不安全，POST 安全。</li><li><strong>数据包个数</strong>：GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。</li></ul> 
<hr> 
<h3><a id="9HTTP__319"></a>9、HTTP 的优缺点</h3> 
<ul><li>HTTP 协议的特性「<strong>无状态、明文传输</strong>」既是优点也是缺点，同时还有一大缺点「<strong>不安全</strong>」。</li></ul> 
<h4><a id="__323"></a>① 无状态协议的优缺点：</h4> 
<ul><li>无状态的<strong>好处</strong>：服务器不用去记忆 HTTP 的状态，不需要额外的资源来记录状态信息，这能减轻服务器的负担，能够把更多的 CPU 和内存资源用在对外提供服务上。</li><li>无状态的<strong>坏处</strong>：服务器没有记忆能力，它在完成有关联性的操作时会非常麻烦。 
  <ul><li>例如<strong>登录 -&gt; 添加购物车 -&gt; 下单 -&gt; 结算 -&gt; 支付</strong>，这系列操作都要知道用户的身份才行。但服务器不知道这些请求是有关联的，每次都要确认一遍用户身份信息。</li></ul> </li></ul> 
<p>对于无状态的问题，解法方案有很多种，其中比较简单的方式用 <strong>Cookie</strong> 技术。</p> 
<p><code>Cookie</code> 通过在请求和响应中写入 Cookie 信息来控制客户端的状态。相当于，<strong>在客户端第一次请求后，服务器会下发一个带有客户身份信息的「小贴纸」，后续客户端请求服务器的时候，带上「小贴纸」，服务器就能试别了</strong>：</p> 
<p><img src="https://images2.imgbox.com/9c/96/V2dWrue8_o.png" alt=""></p> 
<h4><a id="__335"></a>② 明文传输的优缺点：</h4> 
<ul><li> <p>明文意味着在传输过程中的信息，是可方便阅读的，通过浏览器的 F12 控制台或 Wireshark 抓包都可以直接肉眼查看，为我们调试工作带了极大的便利性。</p> </li><li> <p>但是这正是这样，HTTP 的所有信息都暴露在了光天化日下，相当于<strong>信息裸奔</strong>。在传输的漫长的过程中，信息的内容都毫无隐私可言，很容易就能被窃取，如果里面有你的账号密码信息，那<strong>你号没了</strong>。</p> </li></ul> 
<hr> 
<h3><a id="10HTTP__HTTPS__343"></a>10、HTTP 和 HTTPS 的区别是什么？</h3> 
<ul><li><strong>① 安全性区别</strong>：HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 可以保证信息传输安全，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li><li><strong>② 建里连接流程区别</strong>：HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li><li><strong>③ 端口区别</strong>：HTTP 的端口号是 80，HTTPS 的端口号是 443。</li><li><strong>④ 是否需要申请数字证书</strong>：HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。而 HTTP 协议不需要。</li></ul> 
<blockquote> 
 <p>混合加密：</p> 
</blockquote> 
<p>HTTPS 采用<strong>对称加密</strong>和<strong>非对称加密</strong>结合的「混合加密」方式，将服务器公钥放到<strong>数字证书</strong>中，来<strong>解决窃听风险</strong>。</p> 
<ul><li>在通信建立前采用<strong>非对称加密</strong>的方式交换「会话秘钥」，后续就不再使用非对称加密。</li><li>在通信过程中全部使用<strong>对称加密</strong>的「会话秘钥」的方式加密明文数据。</li></ul> 
<blockquote> 
 <p>摘要算法：</p> 
</blockquote> 
<ul><li>HTTPS 采用<strong>摘要算法</strong>来确保<strong>数据的完整性</strong>，解决了数据被篡改的风险。</li><li><strong>摘要算法</strong>能够为数据生成独一无二的「标识」，用于校验数据的完整性，从而解决了篡改的风险。</li></ul> 
<p><img src="https://images2.imgbox.com/69/11/COR0O4bK_o.png" alt=""></p> 
<blockquote> 
 <p>HTTPS 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议，如图：</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/d7/78/UqQ1HPHd_o.png" alt=""></p> 
<h3><a id="11Cookie__Session__370"></a>11、Cookie 的作用是什么？和 Session 有什么区别?</h3> 
<blockquote> 
 <p>Cookie 和 Session 的作用：</p> 
</blockquote> 
<p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但两者有所区别：</p> 
<ul><li> <p><strong>Cookie 一般用来保存用户信息</strong>。比如我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；</p> </li><li> <p>**Session 的主要作用就是通过服务端记录用户的状态。**典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p> </li></ul> 
<blockquote> 
 <p>Cookie 和 Session 的区别如下：</p> 
</blockquote> 
<ul><li>Cookie 数据保存在客户端，Session 数据保存在服务器端。</li><li>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</li><li>Cookie ⼀般⽤来保存⽤户信息，<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong></li></ul> 
<hr> 
<h3><a id="12URI__URL__388"></a>12、URI 和 URL 的区别是什么？</h3> 
<blockquote> 
 <p>参考文章：</p> 
 <ul><li><a href="https://blog.csdn.net/sinat_38719275/article/details/102607458">https://blog.csdn.net/sinat_38719275/article/details/102607458</a></li><li><a href="https://blog.csdn.net/qq_32595453/article/details/80563142">https://blog.csdn.net/qq_32595453/article/details/80563142</a></li></ul> 
</blockquote> 
<ul><li><strong>URI</strong>：是<strong>统一资源标志符</strong>，可以唯一标识一个资源。</li><li><strong>URL</strong>：是<strong>统一资源定位符</strong>，可以提供该资源的路径。URL 是 URI 的一个子集，它不仅唯一标识资源，而且还提供了定位该资源的信息。</li></ul> 
<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。</p> 
<h3><a id="13HTTP_10__HTTP_11_HTTP_20__398"></a>13、HTTP 1.0 、 HTTP 1.1 、HTTP 2.0 的主要区别是什么？</h3> 
<ul><li> <p><strong>HTTP 1.0：<strong>默认使用</strong>短连接</strong>，浏览器每次请求都需要与服务器建立一次 TCP 连接，服务器处理完成后立即断开 TCP 连接（无连接），服务端不记录客户端的请求状态（无状态）。</p> </li><li> <p><strong>HTTP 1.1</strong>：默认使用<strong>长连接</strong>，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：</p> <pre><code class="prism language-javascript"><span class="token comment">// Keep-Alive不会永久保持连接，它有一个持续时间，可以在不同的服务器软件中设定这个时间。</span>
<span class="token comment">// 实现长连接需要客户端和服务端都支持长连接。</span>
Connection<span class="token punctuation">:</span>keep<span class="token operator">-</span>alive
</code></pre> <p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p> </li><li> <p><strong>HTTP 2.0：<strong>引入</strong>二进制数据帧和流</strong>的概念，支持多路复用、服务器推送，支持使用<strong>二进制格式传输数据</strong>，而 HTTP 1.0 依然使用文本格式传输。</p> </li></ul> 
<hr> 
<h3><a id="14_416"></a>14、简单介绍一下对称加密算法和非对称加密算法的区别？</h3> 
<ul><li><strong>对称加密算法</strong>：双方持有<strong>相同的密钥</strong>，进行<strong>加密速度快</strong>，典型对称加密算法：DES、AES。</li><li><strong>非对称加密算法</strong>：密钥成对出现（<strong>私钥、公钥</strong>），私钥只有自己知道，不在网络中传输；而公钥可以公开。相比对称加密速度较慢，典型的非对称加密算法有：RSA、DSA。</li></ul> 
<hr> 
<h3><a id="15HTTPS___423"></a>15、HTTPS 是如何建立连接的？其间交互了什么？</h3> 
<p>HTTPS 是在 HTTP 与 TCP 之间加了一层 SSL/TLS 协议 ，所以建里连接流程如下：</p> 
<p><strong>① 首先建立 TCP 连接</strong>：三次握手。</p> 
<p><strong>② 然后建里 SSL/TLS 加密</strong>：</p> 
<blockquote> 
 <p>SSL/TLS 协议基本流程：</p> 
</blockquote> 
<ul><li>客户端向服务器索要并验证服务器的公钥。</li><li>双方协商生产「会话秘钥」。</li><li>双方采用「会话秘钥」进行加密通信。</li></ul> 
<p>前两步也就是 SSL/TLS 的建立过程，也就是握手阶段。</p> 
<p><strong>③ 发送HTTP 请求</strong>。</p> 
<hr> 
<p><font color="red">总结的面试题也挺费时间的，文章会不定时更新，有时候一天多更新几篇，如果帮助您复习巩固了知识点，还请三连支持一下，后续会亿点点的更新！</font></p> 
<p><img src="https://images2.imgbox.com/57/e8/dp7UxnNM_o.gif" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0b886c6d2fe284a2e6c4cffc669a4336/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">鸿蒙系统的特点,鸿蒙系统有什么特别之处</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e8ce3783bc2587d1c885008ec89277b0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android缓存一个int值,Android SharedPreferences工具类，可设置缓存时间</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>