<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>栈和队列-Java - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="栈和队列-Java" />
<meta property="og:description" content="目录
一、栈
1.1 概念
1.2 栈的使用
1.3 栈的模拟实现 1.4 栈的应用场景
1.5 概念区分
二、队列
2.1 概念
2.2 队列的使用
2.3 队列的模拟实现
2.4 循环队列
三、双端队列
四、面试题
一、栈 1.1 概念 栈：一种特殊的线性表，只允许在固定的一端进行插入和删除元素操作。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底，栈中的元素遵循先进后出的原则。
压栈：栈的插入操作，也叫进栈或入栈，在栈顶插入数据；出栈：栈的删除操作，在栈顶删除数据。
1.2 栈的使用 方法解释Stack()构造一个空的栈E push(E e)将 e 入栈，并返回eE pop()将栈顶元素出栈并返回E peek()获取栈顶元素int size()获取栈中有效元素个数boolean empty()检测栈是否为空 public static void main(String[] args) { Stack&lt;Integer&gt; stack = new Stack(); stack.push(1); stack.push(2); stack.push(3); stack.push(4); stack.push(5); System.out.println(stack.size());//5 //获取栈顶元素 System.out.println(stack.peek());//5 System.out.println(stack); //[1, 2, 3, 4, 5] stack.pop();//出栈 5 System.out.println(stack.size());//4 System.out.println(stack); //[1, 2, 3, 4] System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ac9b8907271c78cae864fc18279128b2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-26T18:03:07+08:00" />
<meta property="article:modified_time" content="2023-09-26T18:03:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">栈和队列-Java</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E6%A0%88-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E6%A0%88" rel="nofollow">一、栈</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.1%20%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.1%20%E6%A6%82%E5%BF%B5" rel="nofollow">     1.1 概念</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.2%20%E6%A0%88%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.2%20%E6%A0%88%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">     1.2 栈的使用</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.3%20%E6%A0%88%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%C2%A0-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.3%20%E6%A0%88%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%C2%A0" rel="nofollow">     1.3 栈的模拟实现 </a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.4%20%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.4%20%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">     1.4 栈的应用场景</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A01.5%20%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%86-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A01.5%20%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%86" rel="nofollow">    1.5 概念区分</a></p> 
<p id="%E4%BA%8C%E3%80%81%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E9%98%9F%E5%88%97" rel="nofollow">二、队列</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A02.1%20%E6%A6%82%E5%BF%B5-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A02.1%20%E6%A6%82%E5%BF%B5" rel="nofollow">    2.1 概念</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A02.2%20%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A02.2%20%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">    2.2 队列的使用</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.3%20%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.3%20%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0" rel="nofollow">    2.3 队列的模拟实现</a></p> 
<p id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.4%20%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97-toc" style="margin-left:40px;"><a href="#%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.4%20%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97" rel="nofollow">    2.4 循环队列</a></p> 
<p id="%E4%B8%89%E3%80%81%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97" rel="nofollow">三、双端队列</a></p> 
<p id="%E5%9B%9B%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98-toc" style="margin-left:0px;"><a href="#%E5%9B%9B%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98" rel="nofollow">四、面试题</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E6%A0%88">一、栈</h2> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.1%20%E6%A6%82%E5%BF%B5">     1.1 概念</h3> 
<p>        栈：<span style="color:#333333;">一种特殊的线性表，<strong>只允许在固定的一端进行插入和删除元素操作</strong></span><span style="color:#333333;">。进行数据插入和删除操作的一端称为栈顶，另一端称为栈底，栈中的元素遵循<strong>先进后出</strong>的原则。</span></p> 
<p><span style="color:#333333;">       <strong> 压栈</strong>：栈的插入操作，也叫<strong>进栈或入栈</strong>，在<strong>栈顶插入数据</strong>；<strong>出栈</strong>：栈的删除操作，在<strong>栈顶删除数据</strong>。</span></p> 
<p><span style="color:#333333;">        </span><img alt="" height="358" src="https://images2.imgbox.com/25/50/zJCDiPde_o.png" width="436"></p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.2%20%E6%A0%88%E7%9A%84%E4%BD%BF%E7%94%A8">     1.2 栈的使用</h3> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>方法</td><td>解释</td></tr><tr><td>Stack()</td><td>构造一个空的栈</td></tr><tr><td>E push(E e)</td><td>将 e 入栈，并返回e</td></tr><tr><td>E pop()</td><td>将栈顶元素出栈并返回</td></tr><tr><td>E peek()</td><td>获取栈顶元素</td></tr><tr><td>int size()</td><td>获取栈中有效元素个数</td></tr><tr><td>boolean empty()</td><td>检测栈是否为空</td></tr></tbody></table> 
<blockquote> 
 <pre>public static void main(String[] args) {
    Stack&lt;Integer&gt; stack = new Stack();
    stack.push(1);
    stack.push(2);
    stack.push(3);
    stack.push(4);
    stack.push(5);

    System.out.println(stack.size());//5
    //获取栈顶元素
    System.out.println(stack.peek());//5
    System.out.println(stack);  //[1, 2, 3, 4, 5]

    stack.pop();//出栈  5

    System.out.println(stack.size());//4
    System.out.println(stack);  //[1, 2, 3, 4]

    System.out.println(stack.empty());//false
}
</pre> 
</blockquote> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.3%20%E6%A0%88%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%C2%A0">     1.3 栈的模拟实现 </h3> 
<p><img alt="" height="573" src="https://images2.imgbox.com/93/dd/bulDCfHg_o.png" width="854"></p> 
<p>        由图可知<span style="color:#333333;">Stack继承了</span><span style="color:#333333;">Vector</span><span style="color:#333333;">，</span><span style="color:#333333;">Vector</span><span style="color:#333333;">和</span><span style="color:#333333;">ArrayList</span><span style="color:#333333;">类似，都是动态的顺序表，不同的是</span><span style="color:#333333;">Vector</span><span style="color:#333333;">是线程安全的。</span></p> 
<blockquote> 
 <pre>public class MyStack {
    int[] elem;
    int usedSize;
    public MyStack(){
        elem = new int[3];
    }
    //判断栈是否满了
    private boolean CapacityIsFull(){
        return  usedSize == elem.length;
    }
    //确保容量充足
    private  void  ensureCapacity(){
        if(CapacityIsFull()){
            elem = Arrays.copyOf(elem,elem.length*2);
        }
    }
    //入栈
    public int push(int data){
        ensureCapacity();
        elem[usedSize++] = data;
        return  data;
    }
    //获取栈顶元素
    public int peek(){
        if(usedSize == 0){
            throw new StackNullEception("栈为空，无法获取栈顶元素");
        }
        return  elem[usedSize-1];
    }

    //出栈
    public int pop (){
        int e = peek();
        usedSize--;
        return  e;
    }
    //获取栈的长度
    public  int size(){
        return  usedSize;
    }
    //判断栈是否为空
    public boolean empty(){
        return  usedSize == 0;
    }
}</pre> 
</blockquote> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A01.4%20%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" style="background-color:transparent;">     1.4 栈的应用场景</h3> 
<p>        <strong>1. 改变元素的序列</strong></p> 
<blockquote> 
 <div> 
  <span style="color:#333333;">1. </span> 
  <span style="color:#333333;">若进栈序列为 </span> 
  <span style="color:#333333;">1,2,3,4 </span> 
  <span style="color:#333333;">，进栈过程中可以出栈，则下列不可能的一个出栈序列是（） </span> 
 </div> 
 <div> 
  <span style="color:#333333;">        A: 1,4,3,2      B: 2,3,4,1      C: 3,1,4,2      D: 3,4,2,1 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">2.</span> 
  <span style="color:#333333;">一个栈的初始状态为空。现将元素</span> 
  <span style="color:#333333;">1</span> 
  <span style="color:#333333;">、</span> 
  <span style="color:#333333;">2</span> 
  <span style="color:#333333;">、</span> 
  <span style="color:#333333;">3</span> 
  <span style="color:#333333;">、</span> 
  <span style="color:#333333;">4</span> 
  <span style="color:#333333;">、</span> 
  <span style="color:#333333;">5</span> 
  <span style="color:#333333;">、</span> 
  <span style="color:#333333;">A</span> 
  <span style="color:#333333;">、</span> 
  <span style="color:#333333;">B</span> 
  <span style="color:#333333;">、</span> 
  <span style="color:#333333;">C</span> 
  <span style="color:#333333;">、</span> 
  <span style="color:#333333;">D</span> 
  <span style="color:#333333;">、</span> 
  <span style="color:#333333;">E</span> 
  <span style="color:#333333;">依次入栈，然后再依次出栈，则元素出栈的顺 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">序是（ ）。 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">A: 12345ABCDE      B: EDCBA54321      C: ABCDE12345      D: 54321EDCBA </span> 
 </div> 
</blockquote> 
<div> 
 <span style="color:#333333;">        <strong>2. 将递归转化为循环</strong></span> 
</div> 
<blockquote> 
 <div> 
  <pre>//递归方式
void printList(Node head){
    if(head == null){
        return;
    }
    printList(head.next);
    System.out.println(head.val+" ");
}
//循环方式
void printList2(Node head){
    if(head == null){
        return;
    }
    Stack&lt;LinkList.Node&gt; stack = new Stack&lt;&gt;();
    //将链表中的元素(节点)放入栈中
    Node cur = head;
    while(cur !=null){
        stack.push(cur);
        cur = cur.next;
    }
    //栈中的元素出栈
    while (!stack.empty()){
        System.out.print(stack.pop().val+" ");
    }
}
</pre> 
 </div> 
</blockquote> 
<p>     3. <a class="link-info" href="https://leetcode.cn/problems/valid-parentheses/description/" rel="nofollow" title="括号匹配">括号匹配</a></p> 
<p><img alt="" height="380" src="https://images2.imgbox.com/c5/4c/5Ncwpp1W_o.png" width="1200"></p> 
<p>        代码实现</p> 
<blockquote> 
 <p>public boolean isValid(String s) {<!-- --></p> 
 <p>        Stack&lt;Character&gt;  stack = new Stack&lt;&gt;();</p> 
 <p>        for(int i = 0; i&lt; s.length(); i++){<!-- --></p> 
 <p>            char ch = s.charAt(i);</p> 
 <p>            if(ch == '(' || ch == '[' || ch == '{'){<!-- --></p> 
 <p>                stack.push(ch);</p> 
 <p>            } else {<!-- --></p> 
 <p>                if(stack.empty()){<!-- --></p> 
 <p>                    return false;</p> 
 <p>                }</p> 
 <p>                //从栈中取栈顶</p> 
 <p>                char ch1 = stack.pop();</p> 
 <p>                if((ch1 =='(' &amp;&amp; ch == ')') || (ch1 == '[' &amp;&amp; ch == ']') || (ch1 == '{' &amp;&amp; ch == '}')){<!-- --></p> 
 <p>                    continue;</p> 
 <p>                } else {<!-- --></p> 
 <p>                    return false;</p> 
 <p>                }</p> 
 <p>            }</p> 
 <p>        }</p> 
 <p>        //栈中还有左括号</p> 
 <p>        if(!stack.empty()){<!-- --></p> 
 <p>            return false;</p> 
 <p>        }</p> 
 <p>        return true;</p> 
 <p>    }</p> 
</blockquote> 
<p>     4. <a class="link-info" href="https://leetcode.cn/problems/evaluate-reverse-polish-notation/description/" rel="nofollow" title="逆波兰表达式求值">逆波兰表达式求值</a></p> 
<p><img alt="" height="321" src="https://images2.imgbox.com/5a/c0/dcvt38Ge_o.png" width="1200"></p> 
<p>    代码实现</p> 
<blockquote> 
 <p>public int evalRPN(String[] tokens) {<!-- --></p> 
 <p>        Stack&lt;Integer&gt; stack = new Stack();</p> 
 <p>        for(String s:tokens){<!-- --></p> 
 <p>            if(!(s.equals("+")||s.equals("-")||s.equals("*")||s.equals("/"))){<!-- --></p> 
 <p>                stack.push(Integer.parseInt(s));</p> 
 <p>            }else{<!-- --></p> 
 <p>                int num2 = stack.pop();</p> 
 <p>                int num1 = stack.pop();</p> 
 <p>                switch(s){<!-- --></p> 
 <p>                    case "+":</p> 
 <p>                        stack.push(num1+num2);</p> 
 <p>                        break;</p> 
 <p>                    case "-":</p> 
 <p>                        stack.push(num1-num2);</p> 
 <p>                        break;</p> 
 <p>                    case "*":</p> 
 <p>                        stack.push(num1*num2);</p> 
 <p>                        break;</p> 
 <p>                    case "/":</p> 
 <p>                        stack.push(num1/num2);</p> 
 <p>                        break;</p> 
 <p>                }</p> 
 <p>            }</p> 
 <p>        }</p> 
 <p>        return stack.pop();</p> 
 <p>    }</p> 
</blockquote> 
<p>     5. <a class="link-info" href="https://www.nowcoder.com/practice/d77d11405cc7470d82554cb392585106?tpId=13&amp;&amp;tqId=11174&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/coding-interviews/question-ranking" rel="nofollow" title="出栈入栈次序匹配">出栈入栈次序匹配</a></p> 
<p><img alt="" height="494" src="https://images2.imgbox.com/90/a8/uLDLI621_o.png" width="1106"></p> 
<p><img alt="" height="343" src="https://images2.imgbox.com/78/7e/bDuHKpiy_o.png" width="717"></p> 
<p>        代码实现</p> 
<blockquote> 
 <p>public boolean IsPopOrder (int[] pushV, int[] popV) {<!-- --></p> 
 <p>        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</p> 
 <p>        //i遍历pushV，j遍历popV</p> 
 <p>        int i = 0, j = 0;</p> 
 <p>        for(;i &lt; pushV.length; i++){<!-- --></p> 
 <p>            //入栈</p> 
 <p>            stack.push(pushV[i]);</p> 
 <p>            //获取栈顶元素</p> 
 <p>            int pe = stack.peek();</p> 
 <p>            //判断栈顶元素是否需要出栈</p> 
 <p>            while(pe == popV[j]){<!-- --></p> 
 <p>                stack.pop();</p> 
 <p>                j++;</p> 
 <p>                //栈空</p> 
 <p>                if(stack.empty()){<!-- --></p> 
 <p>                    break;</p> 
 <p>                }</p> 
 <p>                //判断后面是否需要出栈</p> 
 <p>                pe = stack.peek();</p> 
 <p>            }</p> 
 <p>        }</p> 
 <p>        //栈中还有元素</p> 
 <p>        if(!stack.empty()){<!-- --></p> 
 <p>            return false;</p> 
 <p>        }</p> 
 <p>        return true;</p> 
 <p>    }</p> 
</blockquote> 
<p>     6. <a class="link-info" href="https://leetcode.cn/problems/min-stack/description/" rel="nofollow" title="最小栈">最小栈</a></p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A01.5%20%E6%A6%82%E5%BF%B5%E5%8C%BA%E5%88%86"><img alt="" height="739" src="https://images2.imgbox.com/61/e5/ExaG2vQF_o.png" width="1089"></h3> 
<p>        代码实现</p> 
<blockquote> 
 <p>class MinStack {<!-- --></p> 
 <p>    //普通栈</p> 
 <p>    private Stack&lt;Integer&gt; stack;</p> 
 <p>    //最小值栈-》存放当前普通栈中的最小值</p> 
 <p>    private Stack&lt;Integer&gt; minStack;</p> 
 <p>    public MinStack() {<!-- --></p> 
 <p>        stack = new Stack&lt;&gt;();</p> 
 <p>        minStack = new Stack&lt;&gt;();</p> 
 <p>    }</p> 
 <p>    //入栈</p> 
 <p>    public void push(int val) {<!-- --></p> 
 <p>        if(stack.empty()){<!-- --></p> 
 <p>            stack.push(val);</p> 
 <p>            minStack.push(val);</p> 
 <p>        }else {<!-- --></p> 
 <p>            stack.push(val);</p> 
 <p>            int peek = minStack.peek();</p> 
 <p>            //判断minStack是否要入栈</p> 
 <p>            if(val &lt;= peek){<!-- --></p> 
 <p>                minStack.push(val);</p> 
 <p>            }</p> 
 <p>        }</p> 
 <p>    }</p> 
 <p>    //出栈</p> 
 <p>    public void pop() {<!-- --></p> 
 <p>        //普通栈为空</p> 
 <p>        if(stack.empty()){<!-- --></p> 
 <p>            return;</p> 
 <p>        }</p> 
 <p>        int po= stack.pop();</p> 
 <p>        //判断minStack是否要出栈</p> 
 <p>        if(po == minStack.peek()){<!-- --></p> 
 <p>            minStack.pop();</p> 
 <p>        }</p> 
 <p>    }</p> 
 <p>    //获取栈顶元素</p> 
 <p>    public int top() {<!-- --></p> 
 <p>        //普通栈为空</p> 
 <p>        if(stack.empty()){<!-- --></p> 
 <p>            return  -1;</p> 
 <p>        }</p> 
 <p>        return stack.peek();</p> 
 <p>    }</p> 
 <p>    //获取当前栈中最小值</p> 
 <p>    public int getMin() {<!-- --></p> 
 <p>        //最小值栈-》 空</p> 
 <p>        if(minStack.empty()){<!-- --></p> 
 <p>            return  -1;</p> 
 <p>        }</p> 
 <p>        return minStack.peek();</p> 
 <p>    }</p> 
 <p>}</p> 
</blockquote> 
<h3>    1.5 概念区分</h3> 
<p>        栈、虚拟机栈、栈帧有何区别？</p> 
<p>        栈是一种数据结构，虚拟机栈是JVM划分的一块内存，栈帧是方法调用时，虚拟机给方法分配的一块内存。</p> 
<h2 id="%E4%BA%8C%E3%80%81%E9%98%9F%E5%88%97">二、队列</h2> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A02.1%20%E6%A6%82%E5%BF%B5">    2.1 概念</h3> 
<p>       <strong> 队列</strong>：<span style="color:#333333;">只允许在一端进行插入数据操作，在另一端进行删除数据操作的特殊线性表，队列具有<strong>先进先出</strong>的特点入队列：进行<strong>插入</strong>操作的一端称为</span><span style="color:#333333;"><strong>队尾（</strong></span><span style="color:#333333;"><strong>Tail/Rear</strong></span><span style="color:#333333;"><strong>） </strong></span><span style="color:#333333;">出队列：进行<strong>删除</strong>操作的一端称为</span><span style="color:#333333;"><strong>队头</strong></span></p> 
<p><img alt="" height="159" src="https://images2.imgbox.com/f4/60/SGRcaZY5_o.png" width="744"></p> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A02.2%20%E9%98%9F%E5%88%97%E7%9A%84%E4%BD%BF%E7%94%A8">    2.2 队列的使用</h3> 
<div> 
 <span style="color:#333333;"><strong>        Queue是个接口，底层是通过链表实现。</strong></span> 
</div> 
<p>        <img alt="" height="185" src="https://images2.imgbox.com/1f/00/LETE5Ws2_o.png" width="151"></p> 
<p>        </p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:500px;"><tbody><tr><td>方法</td><td>解释</td></tr><tr><td>boolean offer(E e)</td><td>入队列</td></tr><tr><td>E poll()</td><td>出队列并返回</td></tr><tr><td>E peek()</td><td>获取队头元素</td></tr><tr><td>int size()</td><td>获取队列中有效长度的个数</td></tr><tr><td>boolean isEmpty</td><td>判断队列是否为空</td></tr></tbody></table> 
<p>        <span style="color:#333333;">Queue</span><span style="color:#333333;">是个接口，在实例化时必须实例化</span><span style="color:#333333;">LinkedList</span><span style="color:#333333;">的对象，因为</span><span style="color:#333333;">LinkedList</span><span style="color:#333333;">实现了</span><span style="color:#333333;">Queue</span><span style="color:#333333;">接口。</span></p> 
<blockquote> 
 <pre>public static void main(String[] args) {
    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
    //入队
    queue.offer(1);
    queue.offer(2);
    queue.offer(3);
    System.out.println(queue);//[1, 2, 3]
    //获取队头元素
    int t = queue.peek();
    System.out.println(t);//1
    //出队
    System.out.println(queue.poll());//1
    System.out.println(queue);//[2, 3]
    //判断队列是否为空
    boolean bool = queue.isEmpty();
    System.out.println(bool);//false
}</pre> 
</blockquote> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.3%20%E9%98%9F%E5%88%97%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0">     2.3 队列的模拟实现</h3> 
<div> 
 <span style="color:#333333;">        队列中可以存储元素，那底层肯定要有能够保存元素的空间，通过前面线性表的学习了解到</span> 
</div> 
<div> 
 <span style="color:#333333;">常见的空间类型有两种：<strong>顺序结构 和 链式结构，</strong>那么</span> 
 <span style="color:#333333;"><strong>队列的实现使用顺序结构还是链式结构好？</strong></span> 
</div> 
<div> 
 <img alt="" height="399" src="https://images2.imgbox.com/de/3a/TiXJ62xj_o.png" width="742"> 
</div> 
<blockquote> 
 <div> 
  <pre>/*双向链式队列*/
public class MyLinkqueue {
    static  class  ListNode{
        int val;
        ListNode next;
        ListNode pre;
        public ListNode(int val){
            this.val = val;
        }
    }
    ListNode first;//队头
    ListNode last;//队尾
    int usedsize;//队列中元素个数
    //入队列
    public boolean offer(int data){
        ListNode node = new ListNode(data);
        if(first == null){
            //空队列
            first = node;
            last = node;
        }else {
            last.next = node;
            node.pre = last;
            last = last.next;
        }
        usedsize++;
        return  true;
    }
    //获取队头元素
    public int peek(){
        if(usedsize == 0){
            return -1;
        }
        return first.val;
    }
    //出队列
    public int poll(){
        int x = peek();
        //只有一个元素
        if(first.next==null){
            first = null;
            last = null;
        }
        first = first.next;
        first.pre = null;
        usedsize--;
        return  x;
    }
    //获取队列中元素的个数
    public int size(){
        return usedsize;
    }
    //判断队列是否为空
    public boolean isEmpty(){
        return usedsize == 0;
    }
}
</pre> 
 </div> 
</blockquote> 
<h3 id="%C2%A0%C2%A0%C2%A0%C2%A0%C2%A02.4%20%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97">     2.4 循环队列</h3> 
<div> 
 <span style="color:#333333;">        实际中我们有时会使用一种队列叫循环队列，环形队列通常使用数组实现。</span> 
</div> 
<div> 
 <span style="color:#333333;">        </span> 
 <img alt="" height="276" src="https://images2.imgbox.com/ef/e7/eNjvxsMq_o.png" width="849"> 
</div> 
<div> 
 <img alt="" height="646" src="https://images2.imgbox.com/9c/c9/Mze3U3Ji_o.png" width="1200"> 
</div> 
<div></div> 
<div>
           
 <a class="link-info" href="https://leetcode.cn/problems/design-circular-queue/description/" rel="nofollow" title="设计循环队列">设计循环队列</a> 
</div> 
<div></div> 
<h2 id="%E4%B8%89%E3%80%81%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97">三、双端队列</h2> 
<p>        <span style="color:#333333;">双端队列（deque</span><span style="color:#333333;">）指<strong>允许两端都可以进行入队和出队操作的队列</strong>，</span><span style="color:#333333;">说明元素可以从队头入队和出队，也可以从队尾入队和出队。</span></p> 
<p><img alt="" height="174" src="https://images2.imgbox.com/08/5d/CuxUQ1RD_o.png" width="809"></p> 
<p>        <span style="color:#333333;">Deque</span><span style="color:#333333;">是一个接口，使用时必须创建</span><span style="color:#333333;">LinkedList</span><span style="color:#333333;">的对象。</span></p> 
<p>        <img alt="" height="468" src="https://images2.imgbox.com/ab/54/f8MbDkGT_o.png" width="512"></p> 
<p>        <span style="color:#333333;">实际工程中，使用</span><span style="color:#333333;">Deque</span><span style="color:#333333;">接口是比较多的，栈和队列均可以使用该接口。</span></p> 
<blockquote> 
 <div> 
  <span style="color:#333333;">Deque&lt;Integer&gt; stack = new ArrayDeque&lt;&gt;();//</span> 
  <span style="color:#333333;">双端队列的线性实现 </span> 
 </div> 
 <div> 
  <span style="color:#333333;">Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;();//双端队列的链式实现</span> 
 </div> 
</blockquote> 
<h2 id="%E5%9B%9B%E3%80%81%E9%9D%A2%E8%AF%95%E9%A2%98" style="background-color:transparent;">四、面试题</h2> 
<p>        1、<span style="color:#333333;">用队列实现栈    <a class="link-info" href="https://leetcode.cn/problems/implement-stack-using-queues/description/" rel="nofollow" title="链接">链接</a></span></p> 
<p><img alt="" height="598" src="https://images2.imgbox.com/01/0b/mj4jwVPp_o.png" width="1186"></p> 
<p>        代码实现</p> 
<blockquote> 
 <p>class MyStack {<!-- --></p> 
 <p>    private Queue&lt;Integer&gt; queue1 ;</p> 
 <p>    private Queue&lt;Integer&gt; queue2 ;</p> 
 <p></p> 
 <p>    public MyStack() {<!-- --></p> 
 <p>        queue1 = new LinkedList&lt;&gt;();</p> 
 <p>        queue2 = new LinkedList&lt;&gt;();</p> 
 <p>    }</p> 
 <p>    //入栈</p> 
 <p>    public void push(int x) {<!-- --></p> 
 <p>        //栈为空</p> 
 <p>        if (empty()){<!-- --></p> 
 <p>            queue1.offer(x);</p> 
 <p>        }else {<!-- --></p> 
 <p>            //放入非空队列中</p> 
 <p>            if(!queue1.isEmpty()){<!-- --></p> 
 <p>                queue1.offer(x);</p> 
 <p>            }else {<!-- --></p> 
 <p>                queue2.offer(x);</p> 
 <p>            }</p> 
 <p>        }</p> 
 <p>    }</p> 
 <p>    //出栈</p> 
 <p>    public int pop() {<!-- --></p> 
 <p>        //栈空</p> 
 <p>        if(empty()){<!-- --></p> 
 <p>            return -1;</p> 
 <p>        }</p> 
 <p>        if(!queue1.isEmpty()){<!-- --></p> 
 <p>            //将queue1中的size-1个元素放入queue2</p> 
 <p>            while (queue1.size()&gt;1){<!-- --></p> 
 <p>                int x= queue1.poll();</p> 
 <p>                queue2.offer(x);</p> 
 <p>            }</p> 
 <p>            //出队x并返回x</p> 
 <p>            int x = queue1.poll();</p> 
 <p>            return  x;</p> 
 <p>        }else {<!-- --></p> 
 <p>            //将queue2中的size-1个元素放入queue1</p> 
 <p>            while (queue2.size()&gt;1){<!-- --></p> 
 <p>                int x= queue2.poll();</p> 
 <p>                queue1.offer(x);</p> 
 <p>            }</p> 
 <p>            //出队x并返回x</p> 
 <p>            int x = queue2.poll();</p> 
 <p>            return  x;</p> 
 <p>        }</p> 
 <p>    }</p> 
 <p>    //获取栈顶元素</p> 
 <p>    public int top() {<!-- --></p> 
 <p>        //栈空</p> 
 <p>        if(empty()){<!-- --></p> 
 <p>            return  -1;</p> 
 <p>        }</p> 
 <p>        if(!queue1.isEmpty()){<!-- --></p> 
 <p>            //将queue1中的size-1个元素放入queue2</p> 
 <p>            while (queue1.size()&gt;1){<!-- --></p> 
 <p>                int x= queue1.poll();</p> 
 <p>                queue2.offer(x);</p> 
 <p>            }</p> 
 <p>            //出队x放入另一队列并返回x</p> 
 <p>            int x = queue1.poll();</p> 
 <p>            queue2.offer(x);</p> 
 <p>            return  x;</p> 
 <p>        }else {<!-- --></p> 
 <p>            //将queue2中的size-1个元素放入queue1</p> 
 <p>            while (queue2.size()&gt;1){<!-- --></p> 
 <p>                int x= queue2.poll();</p> 
 <p>                queue1.offer(x);</p> 
 <p>            }</p> 
 <p>            //出队x放入另一队列并返回x</p> 
 <p>            int x = queue2.poll();</p> 
 <p>            queue1.offer(x);</p> 
 <p>            return  x;</p> 
 <p>        }</p> 
 <p>    }</p> 
 <p>    //判断栈是否为空</p> 
 <p>    public boolean empty() {<!-- --></p> 
 <p>        //两个队都为空-》栈为空</p> 
 <p>        return queue1.isEmpty() &amp;&amp; queue2.isEmpty();</p> 
 <p>    }</p> 
 <p>}</p> 
 <p></p> 
</blockquote> 
<p><span style="color:#333333;">         2、 用栈实现队列    <span style="color:#333333;"><a class="link-info" href="https://leetcode.cn/problems/implement-queue-using-stacks/description/" rel="nofollow" title="链接">链接</a></span></span></p> 
<p><img alt="" height="287" src="https://images2.imgbox.com/1b/8e/p1wtQGCO_o.png" width="919"></p> 
<p><img alt="" height="404" src="https://images2.imgbox.com/7e/de/QatFeRtm_o.png" width="908"></p> 
<p>        代码实现</p> 
<blockquote> 
 <p>class MyQueue {<!-- --></p> 
 <p>    private Stack&lt;Integer&gt; stack1;//入队</p> 
 <p>    private Stack&lt;Integer&gt; stack2;//出队</p> 
 <p></p> 
 <p>    public MyQueue() {<!-- --></p> 
 <p>        stack1 = new Stack&lt;&gt;();</p> 
 <p>        sstack2 = new Stack&lt;&gt;();</p> 
 <p>    }</p> 
 <p>    //入队</p> 
 <p>    public void push(int x) {<!-- --></p> 
 <p>        stack1.push(x);</p> 
 <p>    }</p> 
 <p>    //出队</p> 
 <p>    public int pop() {<!-- --></p> 
 <p>        //队空</p> 
 <p>        if(empty()){<!-- --></p> 
 <p>            return -1;</p> 
 <p>        }</p> 
 <p>        //保证stack2不为空</p> 
 <p>        if(stack2.isEmpty()){<!-- --></p> 
 <p>            while (!stack1.isEmpty()){<!-- --></p> 
 <p>                stack2.push(stack1.pop());</p> 
 <p>            }</p> 
 <p>        }</p> 
 <p>        return stack2.pop();</p> 
 <p>    }</p> 
 <p>    //获取队头元素</p> 
 <p>    public int peek() {<!-- --></p> 
 <p>        //队空</p> 
 <p>        if(empty()){<!-- --></p> 
 <p>            return -1;</p> 
 <p>        }</p> 
 <p>        //保证stack2不为空</p> 
 <p>        if(stack2.isEmpty()){<!-- --></p> 
 <p>            while (!stack1.isEmpty()){<!-- --></p> 
 <p>                stack2.push(stack1.pop());</p> 
 <p>            }</p> 
 <p>        }</p> 
 <p>        return stack2.peek();</p> 
 <p>    }</p> 
 <p>    //判断队列是否为空</p> 
 <p>    public boolean empty() {<!-- --></p> 
 <p>        //两个栈都为空-》队列为空</p> 
 <p>        return stack1.isEmpty() &amp;&amp; stack2.isEmpty();</p> 
 <p>    }</p> 
 <p>}</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/95b6456077cd0278fa774dc962ee5ac6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue3.0中使用Element-plus默认英文组件修改为中文</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f08de7f09882f17be7b4a29c718ffaff/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu/Docker环境下调试mediasoup-demo</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>