<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>RabbitMQ 消息Ack确认机制 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="RabbitMQ 消息Ack确认机制" />
<meta property="og:description" content="确认种类 RabbitMQ的消息确认有两种。
环境配置 消息发送确认：这种是用来确认生产者将消息发送给交换器，交换器传递给队列的过程中，消息是否成功投递。发送确认分为两步，一是确认是否到达交换器，二是确认是否到达队列。
消费接收确认。这种是确认消费者是否成功消费了队列中的消息。
为了测试，我们先配置rabbit环境
引入Maven依赖
&lt;dependencies&gt;
&lt;dependency&gt;
&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;/dependencies&gt;
配置文件
spring.application.name=rabbitmq
server.port=8084
spring.rabbitmq.host=192.168.3.253
spring.rabbitmq.port=5672
spring.rabbitmq.username=admin
spring.rabbitmq.password=123456
Rabbit配置RabbitConfig.java
package com.lay.rabbitmqtwo.config; /** * @Description: * @Author: lay * @Date: Created in 13:34 2018/12/20 * @Modified By:IntelliJ IDEA */ @Configuration public class RabbitConfig { public static final String CONFIRM_QUEUE_A = &#34;confirm_queue_A&#34;; public static final String CONFIRM_QUEUE_B = &#34;confirm_queue_B&#34;; public static final String CONFIRM_EXCHANGE = &#34;confirm_topic_exchange&#34;; private static final String CONFIRM_QUEUE_A_RoutingKey=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/2a4b7f5d32cd41ec42df675bb0283ffc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-14T17:13:23+08:00" />
<meta property="article:modified_time" content="2022-01-14T17:13:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">RabbitMQ 消息Ack确认机制</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>确认种类</h3> 
<p>RabbitMQ的消息确认有两种。</p> 
<p></p> 
<p></p> 
<h3><a name="t2"></a><a id="_10"></a>环境配置</h3> 
<p></p> 
<p></p> 
<ul><li> <p><strong>消息发送确认</strong>：这种是用来确认生产者将消息发送给交换器，交换器传递给队列的过程中，消息是否成功投递。发送确认分为两步，一是确认是否到达交换器，二是确认是否到达队列。</p> </li><li> <p><strong>消费接收确认</strong>。这种是确认消费者是否成功消费了队列中的消息。</p> </li></ul> 
<p>为了测试，我们先配置rabbit环境</p> 
<p>引入<a href="https://so.csdn.net/so/search?q=Maven&amp;spm=1001.2101.3001.7020" title="Maven">Maven</a>依赖</p> 
<blockquote> 
 <p><br>     &lt;dependencies&gt;<br>         &lt;dependency&gt;<br>             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;<br>             &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;<br>         &lt;/dependency&gt;<br>     &lt;/dependencies&gt;</p> 
</blockquote> 
<p>配置文件</p> 
<blockquote> 
 <p>spring.application.name=rabbitmq<br> server.port=8084</p> 
 <p>spring.rabbitmq.host=192.168.3.253<br> spring.rabbitmq.port=5672<br> spring.rabbitmq.username=admin<br> spring.rabbitmq.password=123456</p> 
</blockquote> 
<p>Rabbit配置RabbitConfig.java</p> 
<pre><code>package com.lay.rabbitmqtwo.config;

/**
 * @Description:
 * @Author: lay
 * @Date: Created in 13:34 2018/12/20
 * @Modified By:IntelliJ IDEA
 */
@Configuration
public class RabbitConfig {
    public static final String CONFIRM_QUEUE_A = "confirm_queue_A";
    public static final String CONFIRM_QUEUE_B = "confirm_queue_B";
    public static final String CONFIRM_EXCHANGE = "confirm_topic_exchange";
    private static final String CONFIRM_QUEUE_A_RoutingKey="topic.message";
    private static final String CONFIRM_QUEUE_B_RoutingKey="topic.#";
    
    //Json格式转换
    private static final MessageConverter jsonMessageConverter=new Jackson2JsonMessageConverter();

    @Autowired
    private RabbitTemplate rabbitTemplate;

    //测试队列A
    @Bean
    public Queue confirmQueryA() {
        return new Queue(CONFIRM_QUEUE_A);
    }

    //测试队列B
    @Bean
    public Queue confirmQueryB() {
        return new Queue(CONFIRM_QUEUE_B);
    }

    //测试交换机,类型为topic
    @Bean
    TopicExchange confirmTopicExchange() {
        return new TopicExchange(CONFIRM_EXCHANGE);
    }

    //绑定测试交换机和测试队列A
    @Bean
    Binding bindingConfirmExchangeA(Queue confirmQueryA, TopicExchange confirmTopicExchange) {
        return BindingBuilder.bind(confirmQueryA).to(confirmTopicExchange).with(CONFIRM_QUEUE_A_RoutingKey);
    }

    //绑定测试交换机和测试队列B
    @Bean
    Binding bindingConfirmExchangeB(Queue confirmQueryB, TopicExchange confirmTopicExchange) {
        return BindingBuilder.bind(confirmQueryB).to(confirmTopicExchange).with(CONFIRM_QUEUE_B_RoutingKey);
    }


}
</code></pre> 
<h3>消息发送确认</h3> 
<h4><a name="t4"></a><a id="1ConfirmCallback_101"></a>（1）<strong>ConfirmCallback</strong></h4> 
<p>通过实现ConfirmCallBack接口，消息发送到交换器<strong>Exchange</strong>后触发回调。</p> 
<p>ConfirmCallBackHandler.java</p> 
<pre><code>package com.lay.rabbitmqtwo.config;

import org.springframework.amqp.rabbit.connection.CorrelationData;
import org.springframework.amqp.rabbit.core.RabbitTemplate;

/**
 * @Description:通过实现ConfirmCallBack接口，消息发送到交换器Exchange后触发回调。
 * @Author: lay
 * @Date: Created in 10:20 2018/12/20
 * @Modified By:IntelliJ IDEA
 */

public class ConfirmCallBackHandler implements RabbitTemplate.ConfirmCallback {
    @Override
    public void confirm(CorrelationData correlationData, boolean ack, String cause) {
        System.out.println("消息唯一标识："+correlationData);
        System.out.println("确认结果："+ack);
        System.out.println("失败原因："+cause);
    }
}
</code></pre> 
<p>在RabbitConfig中配置RabbitTempalte</p> 
<blockquote> 
 <p>  //初始化加载方法，对RabbitTemplate进行配置<br>     @PostConstruct<br>     void rabbitTemplate(){<!-- --><br>         //消息发送确认，发送到交换器Exchange后触发回调<br>         rabbitTemplate.setConfirmCallback(new ConfirmCallBackHandler());<br>     }</p> 
</blockquote> 
<p>该功能需要开启确认，spring-boot中配置如下：</p> 
<blockquote> 
 <p>#消息发送交换机确认</p> 
 <p>spring.rabbitmq.publisher-confirms = true</p> 
</blockquote> 
<h4>（2）<strong>ReturnCallback</strong></h4> 
<p>通过实现ReturnCallback接口，如果消息从交换器发送到对应队列失败时触发（比如根据发送消息时指定的routingKey找不到队列时会触发）</p> 
<p>ReturnCallBackHandler.java</p> 
<pre><code>package com.lay.rabbitmqtwo.config;

/**
 * @Description:通过实现ReturnCallback接口
 * 如果消息从交换器发送到对应队列失败时触发（比如根据发送消息时指定的routingKey找不到队列时会触发）
 * @Author: lay
 * @Date: Created in 10:31 2018/12/20
 * @Modified By:IntelliJ IDEA
 */

public class ReturnCallBackHandler implements RabbitTemplate.ReturnCallback {
    @Override
    public void returnedMessage(Message message, int replyCode, String replyText, String exchange, String routingKey) {
        System.out.println("消息主体 message："+message);
        System.out.println("应答码 replyCode: ："+replyCode);
        System.out.println("原因描述 replyText："+replyText);
        System.out.println("交换机 exchange："+exchange);
        System.out.println("消息使用的路由键 routingKey："+routingKey);
    }
}
————————————————
</code></pre> 
<p>在RabbitConfig中配置RabbitTempalte</p> 
<pre><code> //初始化加载方法，对RabbitTemplate进行配置
    @PostConstruct
    void rabbitTemplate(){
        //消息发送确认，发送到交换器Exchange后触发回调
        rabbitTemplate.setConfirmCallback(new ConfirmCallBackHandler());
        //消息发送确认，如果消息从交换器发送到对应队列失败时触发（比如根据发送消息时指定的routingKey找不到队列时会触发）
        rabbitTemplate.setReturnCallback(new ReturnCallBackHandler());
        //自定义格式转换
        //rabbitTemplate.setMessageConverter(jsonMessageConverter);
    }
</code></pre> 
<p>使用该功能需要开启确认，spring-boot中配置如下：</p> 
<blockquote> 
 <p>#消息发送队列回调</p> 
 <p>spring.rabbitmq.publisher-returns = true</p> 
</blockquote> 
<h3>消息接收确认</h3> 
<h4><a name="t7"></a><a id="1_205"></a>（1）确认模式</h4> 
<ul><li>AcknowledgeMode.NONE：不确认</li><li>AcknowledgeMode.AUTO：自动确认</li><li>AcknowledgeMode.MANUAL：手动确认</li></ul> 
<p>spring-boot中配置方法：</p> 
<blockquote> 
 <p>spring.rabbitmq.listener.simple.acknowledge-mode = manual</p> 
</blockquote> 
<p>如果使用自定义监听容器</p> 
<p></p> 
<pre><code> //RabbitMQ监听容器
    @Bean
    public SimpleRabbitListenerContainerFactory rabbitListenerContainerFactory(ConnectionFactory connectionFactory){
        SimpleRabbitListenerContainerFactory factory = new SimpleRabbitListenerContainerFactory();
        factory.setConnectionFactory(connectionFactory);
        //设置并发
        factory.setConcurrentConsumers(1);
        SimpleMessageListenerContainer s=new SimpleMessageListenerContainer();
        //最大并发
        factory.setMaxConcurrentConsumers(1);
        //消息接收——手动确认
        factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);
        //设置超时
        factory.setReceiveTimeout(2000L);
        //设置重试间隔
        factory.setFailedDeclarationRetryInterval(3000L);
        //监听自定义格式转换
        //factory.setMessageConverter(jsonMessageConverter);
        return factory;
    }</code></pre> 
<h4>（2）手动确认</h4> 
<p></p> 
<p>未确认的消息数</p> 
<p>上图为channel中未被消费者确认的消息数。</p> 
<p>通过RabbitMQ的host地址加上默认端口号15672访问管理界面。</p> 
<p><strong>成功确认</strong></p> 
<blockquote> 
 <p>void basicAck(long deliveryTag, boolean multiple) throws IOException;</p> 
</blockquote> 
<ul><li> <p>deliveryTag：该消息的index</p> </li><li> <p>multiple：是否批量. true：将一次性ack所有小于deliveryTag的消息。</p> </li></ul> 
<p>消费者成功处理后，调用<code>channel.basicAck(message.getMessageProperties().getDeliveryTag(), false)</code>方法对消息进行确认。</p> 
<p>示例：</p> 
<pre><code>@Component
@RabbitListener(queues = "confirm_queue_B")
public class Customer {
    @RabbitHandler
    public void process(Message message, Channel channel){
        System.out.println("ReceiverA："+new String(message.getBody()));
        channel.basicAck(message.getMessageProperties().getDeliveryTag(),true);
}
</code></pre> 
<p> </p> 
<p>失败确认</p> 
<p>失败确认一：</p> 
<pre><code>void basicNack(long deliveryTag, boolean multiple, boolean requeue) throws IOException;</code></pre> 
<ul><li> <p>deliveryTag：该消息的index。</p> </li><li> <p>multiple：是否批量. true：将一次性拒绝所有小于deliveryTag的消息。</p> </li><li> <p>requeue：被拒绝的是否重新入队列。</p> </li></ul> 
<p>示例 </p> 
<pre><code>@Component
@RabbitListener(queues = "confirm_queue_B")
public class Customer {
    @RabbitHandler
    public void processJsonMessage(@Payload String body, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag, Message message,Channel channel){      
        System.out.println("ReceiverA："+new String(message.getBody()));
        channel.basicNack(deliveryTag,true,true);
}
</code></pre> 
<p> 失败确认二：</p> 
<pre><code>void basicReject(long deliveryTag, boolean requeue) throws IOException;</code></pre> 
<ul><li> <p>deliveryTag：该消息的index。</p> </li><li> <p>requeue：被拒绝的是否重新入队列。</p> </li></ul> 
<p><code>channel.basicNack</code> 与 <code>channel.basicReject</code> 的区别在于<code>basicNack</code>可以批量拒绝多条消息，而<code>basicReject</code>一次只能拒绝一条消息。</p> 
<pre><code>@Component
@RabbitListener(queues = "confirm_queue_B")
public class Customer {
     public void processJsonMessage(@Payload String body, @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag, Message message,Channel channel){  
        System.out.println("ReceiverA："+new String(message.getBody()));
        channel.basicReject(deliveryTag,true);
}
</code></pre> 
<p> </p> 
<p>思考<br> （1）手动确认模式，消息手动拒绝中如果requeue为true会重新放入队列，但是如果消费者在处理过程中一直抛出异常，会导致入队-》拒绝-》入队的循环，该怎么处理呢？</p> 
<p>第一种方法是根据异常类型来选择是否重新放入队列。</p> 
<p>第二种方法是先成功确认，然后通过**channel.basicPublish()**重新发布这个消息。重新发布的消息网上说会放到队列后面，进而不会影响已经进入队列的消息处理。</p> 
<pre><code>void basicPublish(String exchange, String routingKey, boolean mandatory, boolean immediate, BasicProperties props, byte[] body) throws IOException;
</code></pre> 
<p>（2）消息确认的作用是什么？</p> 
<p>为了防止消息丢失。消息丢失分为发送丢失和消费者处理丢失，相应的也有两种确认机制。</p> 
<p>这里我写了一个处理的模板</p> 
<pre><code>package com.lay.rabbitmqtwo.customer;

/**
 * @Description:
 * @Author: lay
 * @Date: Created in 13:19 2018/12/25
 * @Modified By:IntelliJ IDEA
 */
@Component
@RabbitListener(queues = "confirm_queue_B")
public class AckTempalte {
    enum Action{
        ACCEPT, // 处理成功
        RETRY, // 可以重试的错误
        REJECT, // 无需重试的错误
    }
    @RabbitHandler
    public void processJsonUser(Message message, Channel channel){
        Action action=Action.ACCEPT;
        long tag=message.getMessageProperties().getDeliveryTag();
        try{

            message.getMessageProperties().getConsumerTag();
            System.out.println( message.getMessageProperties().getConsumerTag());
            String message1 = new String(message.getBody(), "UTF-8");
            System.out.println("获取消息'" + message1 + "'");

        }catch (Exception e){
            // 根据异常种类决定是ACCEPT、RETRY还是 REJECT
            action = Action.RETRY;
            e.printStackTrace();

        }finally {
            try {
                // 通过finally块来保证Ack/Nack会且只会执行一次
                if (action == Action.ACCEPT) {
                    channel.basicAck(tag, true);
                    // 重试
                } else if (action == Action.RETRY) {
                    channel.basicNack(tag, false, true);
                    Thread.sleep(2000L);
                    // 拒绝消息也相当于主动删除mq队列的消息
                } else {
                    channel.basicNack(tag, false, false);
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}


</code></pre> 
<p>附录：Channel接口参数<br> channel.exchangeDeclare()：<br> type：direct、fanout、topic三种<br> durable：true、false true：服务器重启会保留下来Exchange。警告：仅设置此选项，不代表消息持久化。即不保证重启后消息还在。原文：true if we are declaring a durable exchange (the exchange will survive a server restart)<br> autoDelete：true、false.true:当已经没有消费者时，服务器是否可以删除该Exchange。原文1：true if the server should delete the exchange when it is no longer in use。</p> 
<pre><code>/**
     * Declare an exchange.
     * @see com.rabbitmq.client.AMQP.Exchange.Declare
     * @see com.rabbitmq.client.AMQP.Exchange.DeclareOk
     * @param exchange the name of the exchange
     * @param type the exchange type
     * @param durable true if we are declaring a durable exchange (the exchange will survive a server restart)
     * @param autoDelete true if the server should delete the exchange when it is no longer in use
     * @param arguments other properties (construction arguments) for the exchange
     * @return a declaration-confirm method to indicate the exchange was successfully declared
     * @throws java.io.IOException if an error is encountered
     */
    Exchange.DeclareOk exchangeDeclare(String exchange, String type, boolean durable, boolean autoDelete,Map&lt;String, Object&gt; arguments) throws IOException;
</code></pre> 
<p> chanel.basicQos()<br> prefetchSize：0<br> prefetchCount：会告诉RabbitMQ不要同时给一个消费者推送多于N个消息，即一旦有N个消息还没有ack，则该consumer将block掉，直到有消息ack<br> global：true\false 是否将上面设置应用于channel，简单点说，就是上面限制是channel级别的还是consumer级别<br> 备注：据说prefetchSize 和global这两项，rabbitmq没有实现，暂且不研究</p> 
<pre><code>/**
 * Request specific "quality of service" settings.
 *
 * These settings impose limits on the amount of data the server
 * will deliver to consumers before requiring acknowledgements.
 * Thus they provide a means of consumer-initiated flow control.
 * @see com.rabbitmq.client.AMQP.Basic.Qos
 * @param prefetchSize maximum amount of content (measured in
 * octets) that the server will deliver, 0 if unlimited
 * @param prefetchCount maximum number of messages that the server
 * will deliver, 0 if unlimited
 * @param global true if the settings should be applied to the
 * entire channel rather than each consumer
 * @throws java.io.IOException if an error is encountered
 */
void basicQos(int prefetchSize, int prefetchCount, boolean global) throws IOException;</code></pre> 
<p> </p> 
<p>channel.basicPublish()<br> routingKey：路由键，#匹配0个或多个单词，*匹配一个单词，在topic exchange做消息转发用</p> 
<p>mandatory：true：如果exchange根据自身类型和消息routeKey无法找到一个符合条件的queue，那么会调用basic.return方法将消息返还给生产者。false：出现上述情形broker会直接将消息扔掉</p> 
<p>immediate：true：如果exchange在将消息route到queue(s)时发现对应的queue上没有消费者，那么这条消息不会放入队列中。当与消息routeKey关联的所有queue(一个或多个)都没有消费者时，该消息会通过basic.return方法返还给生产者。</p> 
<p>BasicProperties ：需要注意的是BasicProperties.deliveryMode，0:不持久化 1：持久化 这里指的是消息的持久化，配合channel(durable=true),queue(durable)可以实现，即使服务器宕机，消息仍然保留<br> 简单来说：mandatory标志告诉服务器至少将该消息route到一个队列中，否则将消息返还给生产者；</p> 
<p>immediate：标志告诉服务器如果该消息关联的queue上有消费者，则马上将消息投递给它，如果所有queue都没有消费者，直接把消息返还给生产者，不用将消息入队列等待消费者了。</p> 
<p>/**<br> * Publish a message.<br> *<br> * Publishing to a non-existent exchange will result in a channel-level<br> * protocol exception, which closes the channel.<br> *<br> * Invocations of Channel#basicPublish will eventually block if a<br> * resource-driven alarm is in effect.<br> *<br> * @see com.rabbitmq.client.AMQP.Basic.Publish<br> * @see Resource-driven alarms.<br> * @param exchange the exchange to publish the message to<br> * @param routingKey the routing key<br> * @param mandatory true if the ‘mandatory’ flag is to be set<br> * @param immediate true if the ‘immediate’ flag is to be<br> * set. Note that the RabbitMQ server does not support this flag.<br> * @param props other properties for the message - routing headers etc<br> * @param body the message body<br> * @throws java.io.IOException if an error is encountered<br> */<br> void basicPublish(String exchange, String routingKey, boolean mandatory, boolean immediate, BasicProperties props, byte[] body) throws IOException;</p> 
<p></p> 
<pre><code>### channel.basicAck();

- deliveryTag：该消息的index
- multiple：是否批量.true:将一次性ack所有小于deliveryTag的消息。



```java
/**
* Acknowledge one or several received
* messages. Supply the deliveryTag from the {@link com.rabbitmq.client.AMQP.Basic.GetOk}
* or {@link com.rabbitmq.client.AMQP.Basic.Deliver} method
* containing the received message being acknowledged.
* @see com.rabbitmq.client.AMQP.Basic.Ack
* @param deliveryTag the tag from the received {@link com.rabbitmq.client.AMQP.Basic.GetOk} or {@link com.rabbitmq.client.AMQP.Basic.Deliver}
* @param multiple true to acknowledge all messages up to and
* including the supplied delivery tag; false to acknowledge just
* the supplied delivery tag.
* @throws java.io.IOException if an error is encountered
*/
void basicAck(long deliveryTag, boolean multiple) throws IOException;</code></pre> 
<p>channel.basicNack(delivery.getEnvelope().getDeliveryTag(), false, true)<br> deliveryTag：该消息的index</p> 
<p>multiple：是否批量.true:将一次性拒绝所有小于deliveryTag的消息。</p> 
<p>requeue：被拒绝的是否重新入队列</p> 
<pre><code>/**
 * Reject one or several received messages.
 *
 * Supply the &lt;code&gt;deliveryTag&lt;/code&gt; from the {@link com.rabbitmq.client.AMQP.Basic.GetOk}
 * or {@link com.rabbitmq.client.AMQP.Basic.GetOk} method containing the message to be rejected.
 * @see com.rabbitmq.client.AMQP.Basic.Nack
 * @param deliveryTag the tag from the received {@link com.rabbitmq.client.AMQP.Basic.GetOk} or {@link com.rabbitmq.client.AMQP.Basic.Deliver}
 * @param multiple true to reject all messages up to and including
 * the supplied delivery tag; false to reject just the supplied
 * delivery tag.
 * @param requeue true if the rejected message(s) should be requeued rather
 * than discarded/dead-lettered
 * @throws java.io.IOException if an error is encountered
 */
void basicNack(long deliveryTag, boolean multiple, boolean requeue)
        throws IOException;</code></pre> 
<p>channel.basicReject(delivery.getEnvelope().getDeliveryTag(), false);<br> deliveryTag：该消息的index<br> requeue：被拒绝的是否重新入队列<br> channel.basicNack 与 channel.basicReject 的区别在于basicNack可以拒绝多条消息，而basicReject一次只能拒绝一条消息</p> 
<p></p> 
<h4>channel.basicConsume(QUEUE_NAME, true, consumer);</h4> 
<ul><li>autoAck：是否自动ack，如果不自动ack，需要使用channel.ack、channel.nack、channel.basicReject 进行消息应答</li></ul> 
<pre><code>/**
 * Start a non-nolocal, non-exclusive consumer, with
 * a server-generated consumerTag.
 * @param queue the name of the queue
 * @param autoAck true if the server should consider messages
 * acknowledged once delivered; false if the server should expect
 * explicit acknowledgements
 * @param callback an interface to the consumer object
 * @return the consumerTag generated by the server
 * @throws java.io.IOException if an error is encountered
 * @see com.rabbitmq.client.AMQP.Basic.Consume
 * @see com.rabbitmq.client.AMQP.Basic.ConsumeOk
 * @see #basicConsume(String, boolean, String, boolean, boolean, Map, Consumer)
 */
String basicConsume(String queue, boolean autoAck, Consumer callback) throws IOException;
</code></pre> 
<p> </p> 
<h4>chanel.exchangeBind()</h4> 
<p>channel.queueBind(queueName, EXCHANGE_NAME, bindingKey);<br> 用于通过绑定<code>bindingKey</code>将<code>queue</code>到<code>Exchange</code>，之后便可以进行消息接收</p> 
<pre><code>/**
 * Bind an exchange to an exchange, with no extra arguments.
 * @see com.rabbitmq.client.AMQP.Exchange.Bind
 * @see com.rabbitmq.client.AMQP.Exchange.BindOk
 * @param destination the name of the exchange to which messages flow across the binding
 * @param source the name of the exchange from which messages flow across the binding
 * @param routingKey the routine key to use for the binding
 * @return a binding-confirm method if the binding was successfully created
 * @throws java.io.IOException if an error is encountered
 */
Exchange.BindOk exchangeBind(String destination, String source, String routingKey) throws IOException;
</code></pre> 
<p>channel.queueDeclare(QUEUE_NAME, false, false, false, null);<br> durable：true、false true：在服务器重启时，能够存活<br> exclusive ：是否为当前连接的专用队列，在连接断开后，会自动删除该队列，生产环境中应该很少用到吧。<br> autodelete：当没有任何消费者使用时，自动删除该队列。this means that the queue will be deleted when there are no more processes consuming messages from it.</p> 
<pre><code>/**
     * Declare a queue
     * @see com.rabbitmq.client.AMQP.Queue.Declare
     * @see com.rabbitmq.client.AMQP.Queue.DeclareOk
     * @param queue the name of the queue
     * @param durable true if we are declaring a durable queue (the queue will survive a server restart)
     * @param exclusive true if we are declaring an exclusive queue (restricted to this connection)
     * @param autoDelete true if we are declaring an autodelete queue (server will delete it when no longer in use)
     * @param arguments other properties (construction arguments) for the queue
     * @return a declaration-confirm method to indicate the queue was successfully declared
     * @throws java.io.IOException if an error is encountered
     */
    Queue.DeclareOk queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete,Map&lt;String, Object&gt; arguments) throws IOException;</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fd1227fb8ebba08a6dbdc1e780b51226/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Spring boot 项目（十五）——实现163邮箱发送邮件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/949d46091ffb95f959cf5f8071c0f984/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java中的static属性详细介绍</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>