<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>VCS和UVM常用编译选项 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="VCS和UVM常用编译选项" />
<meta property="og:description" content="VCS编译选项 -full64在64bit模式下编译、仿真，用于64位操作系统-j8指定编译器可以并行编译的进程数为8-timescale=1ns/1ps指定仿真时间和精度-y &lt;dir_pathname&gt;指定verilog库路径&#43;libext&#43;.v&#43;.V&#43;.sv&#43;.svh识别.v、.sv、.svh等多种格式文件-sverilog支持system verilog 语法的编译选项-f xxx.lisf 指定包含所有设计文件列表的文件名-top test设置顶层模块为test。（指包含DUT和TB的top？）-l xx.log编译log输出到指定的文件xx.log&#43;define&#43;XX_MACRO定义一个宏变量XX_MACRO，可作用到dut或tb文件中。也可以具体给这个宏定义一个具体的值：&#43;define&#43;XX_MACRO = 9&#43;incdir&#43;/xx/xx/指定 `include指令使用的包含文件的目录，可以指定多个-M使能增量编译，即编译时只对修改的文件进行重新编译-Mdir=&lt;directory&gt;指定一个目录让VCS存储编译产生的文件，默认是csrc-Mlib=&lt;directory&gt;指定一个目录让VCS搜索某个模块是否需要重新编译。与-Mdir配合，可以实现不同模块的增量编译。-Mupdate[=0]默认情况下，VCS编译时会覆盖上次编译生成的makefile。如果想保留上次的makefile，使用-Mupdate=0；如果不带=0，则进行增量编译，并覆盖上次的makefile。-noIncrComp关闭增量编译-notice `-notice`是VCS编译器的一个选项，用于控制编译过程中的警告信息的显示方式。
通过使用`-notice`选项，您可以获得更多关于编译和仿真过程的信息，并且能够找到潜在的问题或改进的建议。这对于调试和优化设计非常有用。
-R编译完成后立即执行simv命令进行仿真；（一般还是先编译，再仿真；方便debug和调试）&#43;memcbk使能多维数组变量的回调。为了可以查看多维数组变量的波形（vcs默认是不能查看多维数组或memory型变量）&#43;warn=none忽略所有warning，不予显示&#43;warn=all显示所有warning-debug_access&#43;all-debug_all将debug的信息全部保存下来，如波形文件等-debug 或 -debug_all使能UCLI命令行-kdb 选项在执行仿真时，打开KDB调试模式，以便可以通过命令行进行交互式的调试操作。
-cm &lt;options&gt;指定覆盖率的类型，包括：line（行覆盖）、cond（条件覆盖）、fsm（状态机覆盖）、tgl（翻转率覆盖）、path（路径覆盖）、branch（分支覆盖）和assert（断言覆盖）。如果包括两种或以上的覆盖率类型，可用“&#43;”，如-cm line&#43;cond&#43;fsm&#43;tgl-cm_assert_hier &lt;filename&gt;将SVA覆盖率统计限定在文件列表中指定的module层次-cm_cond &lt;arguments&gt;进一步细化条件覆盖率的统计方式，包括：basic,std,full,allops,event,anywidth,for,tf,sop等选项。-cm_count在统计是否覆盖的基础上，进一步统计覆盖的次数-cm_dir &lt;directory_path_name&gt;指定覆盖率统计结果的存放路径，默认是simv.cm-cm_hier &lt;filename&gt;指定覆盖率统计的范围，范围在文件中定义，可以指定module名、层次名和源文件等。-cm_log &lt;filename&gt;指定仿真过程中记录覆盖率的log文件名-cm_name &lt;filename&gt;指定保存覆盖率结果的文本文件的名称-o &lt;name&gt;指定编译生成的可执行文件的名称，默认是simv&#43;v2k支持Verilog-2001标准&#43;vcs&#43;initmem&#43;0/1/x/z初始化设计中所有存储器的值&#43;vcs&#43;initreg&#43;0/1/x/z初始化设计中所有寄存器的值&#43;vcs&#43;lic&#43;wait一直等待license &#43;nospecify
是一种仿真运行时的选项。它用于控制VCS在仿真过程中如何处理Verilog中的`specify`块。 `specify`块是一种用于描述和约束时序电路中时序行为的特殊语言结构。它可以定义信号的时序延迟、校准和约束规则等。在仿真过程中，通常使用`specify`块进行时序约束的模拟。
，当我们希望对设计进行功能仿真或性能分析时，并不需要考虑`specify`块中的时序约束，而只关注设计本身的逻辑行为。这时，可以使用`&#43;nospecify`选项告诉VCS在仿真过程中忽略`specify`块。 具体地说，当使用了`&#43;nospecify`选项时，VCS会在编译时将`specify`块从Verilog源代码中移除，并在仿真过程中忽略时序约束，从而将仿真重点放在逻辑行为上。
&#43;notimecheck 是一种仿真运行时的选项。它用于控制VCS在仿真过程中是否执行时序约束的检查。
Verilog中的时序约束用于描述和约束时序电路中的时序行为，例如信号的时序延迟、时钟和数据的关系等。在仿真过程中，VCS默认会执行时序约束的检查，以确保设计是否满足约束规定的时序要求。 然而，有时在进行功能仿真或性能分析时，并不需要进行严格的时序约束检查，而只关注设计本身的逻辑行为。这时可以使用`&#43;notimecheck`选项告诉VCS在仿真过程中跳过时序约束的检查。 具体来说，当使用了`&#43;notimecheck`选项时，VCS会忽略时序约束，不执行相关的检查。这将加快仿真速度，并且更侧重于逻辑行为的仿真。
上面这2个编译有时候需要加上，之前遇到了自己的makefile跑用例没有问题，但是eman回归就有问题，最后发现是两边的编译选项不一样；仿真选项（SIM）&#43;ntb_random_seed-line使能VriSim中的单步运行-ntb使能ntb（Native TestBench），支持OpenVera验证平台语言结构。-timescale=&lt;time_unit&gt;/&lt;time_precision&gt;源代码文件中有的包括timescale编译指令，有的不包括，如果在VCS命令行中，不包括timescale的源代码文件在最前面，VCS会停止编译。使用-timescale选项为这些在前面且又没有`timescale的源文件指定timescale-override_timescale=&lt;time_unit&gt;/&lt;time_precision&gt;让源文件统一使用指定的timescale-pvalues&#43;&lt;parameter_name&gt;=&lt;value&gt;改变指定参数的值
-pvalue选项支持在编译阶段去更改parameter的值；然后直接在makefile里控制parameter的随机即可-parameters &lt;filename&gt;通过文件的方式改变参数的值，参数的路径和改变的值均在文件中定义&#43;error&#43;&lt;n&gt;将编译时运行的NTB错误增加到N-vcd &lt;filename&gt;指定VCD波形文件名，默认是verilog.dump，会被源代码文件中的$dumpfile覆盖 分离（块）（编译选项： -partcomp=adaptive_sched -fastpartcomp=j8 分离编译的优点 （1）拆分成多个线程去并行执行编译，节省了编译时间。-fastpartcom=jn，n代表并行线程的数量
（2）将DUT和TB分成若干partition，未修改的partition不需要重新编译
参考链接：
vcs 分离编译_vcs分块编译_卓麻麻的博客-CSDN博客
参考：vcs常用仿真选项_lobbiy的博客-CSDN博客
vcs把verilog文件编译完成后，会生成simv文件；
（跑仿真：./simv -l sim.log）
跑仿真：./simv &#43;ntb_random_seed=12345 -l sim.log；（自动化脚本中，随机种子一般在makefile里面通过变量SEED传递进来）
vcs的单步仿真： 生成波形文件：在top_tb.sv中加入下面这个initial块
把数组型数据生成到波形文件中：
-F/-f的区别：
1. -F 使用相对路径索引include的文件。
2.-f 使用绝对路径索引include的文件。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fdd1bdd77769c0cd31a2ac6c9126d8bc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-19T11:19:01+08:00" />
<meta property="article:modified_time" content="2023-09-19T11:19:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">VCS和UVM常用编译选项</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <table align="left" border="1" cellpadding="1" cellspacing="1" style="width:626px;"><caption> 
  <strong>VCS编译选项</strong> 
 </caption><thead><tr><th style="width:155px;"><strong>-full64</strong></th><th style="width:469px;">在64bit模式下编译、仿真，用于64位操作系统</th></tr></thead><tbody><tr><td style="width:155px;">-j8</td><td style="width:469px;">指定编译器可以并行编译的进程数为8</td></tr><tr><td style="width:155px;"><strong>-timescale=1ns/1ps</strong></td><td style="width:469px;">指定仿真时间和精度</td></tr><tr><td>-y &lt;<em><strong>dir_pathname</strong></em>&gt;</td><td>指定verilog库路径</td></tr><tr><td style="width:155px;"></td><td style="width:469px;"></td></tr><tr><td style="width:155px;"><strong>+libext+.v+.V+.sv+.svh</strong></td><td style="width:469px;"><strong>识别.v、.sv、.svh等多种格式文件</strong></td></tr><tr><td style="width:155px;"><strong>-sverilog</strong></td><td style="width:469px;">支持system verilog 语法的编译选项</td></tr><tr><td style="width:155px;"><strong>-f xxx.lisf </strong></td><td style="width:469px;">指定包含所有设计文件列表的文件名</td></tr><tr><td style="width:155px;">-top test</td><td style="width:469px;">设置顶层模块为test。（指包含DUT和TB的top？）</td></tr><tr><td style="width:155px;"><strong>-l  xx.log</strong></td><td style="width:469px;">编译log输出到指定的文件xx.log</td></tr><tr><td style="width:155px;">+define+XX_MACRO</td><td style="width:469px;">定义一个宏变量XX_MACRO，可作用到dut或tb文件中。也可以具体给这个宏定义一个具体的值：+define+XX_MACRO = 9</td></tr><tr><td style="width:155px;">+incdir+/xx/xx/</td><td style="width:469px;">指定 `include指令使用的包含文件的目录，可以指定多个</td></tr><tr><td style="width:155px;"><strong>-M</strong></td><td style="width:469px;">使能增量编译，即编译时只对修改的文件进行重新编译</td></tr><tr><td>-Mdir=&lt;<em><strong>directory</strong></em>&gt;</td><td>指定一个目录让VCS存储编译产生的文件，默认是csrc</td></tr><tr><td>-Mlib=&lt;<em><strong>directory</strong></em>&gt;</td><td>指定一个目录让VCS搜索某个模块是否需要重新编译。与-Mdir配合，可以实现不同模块的增量编译。</td></tr><tr><td>-Mupdate[=0]</td><td>默认情况下，VCS编译时会覆盖上次编译生成的makefile。如果想保留上次的makefile，使用-Mupdate=0；如果不带=0，则进行增量编译，并覆盖上次的makefile。</td></tr><tr><td>-noIncrComp</td><td>关闭增量编译</td></tr><tr><td style="width:155px;">-notice</td><td style="width:469px;"> <p>`-notice`是VCS编译器的一个选项，用于控制编译过程中的警告信息的显示方式。</p> <p>通过使用`-notice`选项，您可以获得更多关于编译和仿真过程的信息，并且能够找到潜在的问题或改进的建议。这对于调试和优化设计非常有用。</p> </td></tr><tr><td style="width:155px;"><strong>-R</strong></td><td style="width:469px;">编译完成后立即执行simv命令进行仿真；（一般还是先编译，再仿真；方便debug和调试）</td></tr><tr><td style="width:155px;">+memcbk</td><td style="width:469px;">使能多维数组变量的回调。为了可以查看多维数组变量的波形（vcs默认是不能查看多维数组或memory型变量）</td></tr><tr><td style="width:155px;">+warn=none</td><td style="width:469px;">忽略所有warning，不予显示</td></tr><tr><td style="width:155px;">+warn=all</td><td style="width:469px;">显示所有warning</td></tr><tr><td style="width:155px;">-debug_access+all</td><td style="width:469px;"></td></tr><tr><td style="width:155px;">-debug_all</td><td style="width:469px;">将debug的信息全部保存下来，如波形文件等</td></tr><tr><td>-debug 或 -debug_all</td><td>使能UCLI命令行</td></tr><tr><td style="width:155px;">-kdb</td><td style="width:469px;"> <p>选项在执行仿真时，打开KDB调试模式，以便可以通过命令行进行交互式的调试操作。</p> </td></tr><tr><td>-cm &lt;<em><strong>options</strong></em>&gt;</td><td>指定覆盖率的类型，包括：line（行覆盖）、cond（条件覆盖）、fsm（状态机覆盖）、tgl（翻转率覆盖）、path（路径覆盖）、branch（分支覆盖）和assert（断言覆盖）。如果包括两种或以上的覆盖率类型，可用“+”，如-cm line+cond+fsm+tgl</td></tr><tr><td>-cm_assert_hier &lt;<em><strong>filename</strong></em>&gt;</td><td>将SVA覆盖率统计限定在文件列表中指定的module层次</td></tr><tr><td>-cm_cond &lt;<em><strong>arguments</strong></em>&gt;</td><td>进一步细化条件覆盖率的统计方式，包括：basic,std,full,allops,event,anywidth,for,tf,sop等选项。</td></tr><tr><td>-cm_count</td><td>在统计是否覆盖的基础上，进一步统计覆盖的次数</td></tr><tr><td>-cm_dir &lt;<em><strong>directory_path_name</strong></em>&gt;</td><td>指定覆盖率统计结果的存放路径，<a href="http://xn--simv-zi0ix13qgd2a.cm/" rel="nofollow" title="默认是simv.cm">默认是simv.cm</a></td></tr><tr><td>-cm_hier &lt;<em><strong>filename</strong></em>&gt;</td><td>指定覆盖率统计的范围，范围在文件中定义，可以指定module名、层次名和源文件等。</td></tr><tr><td>-cm_log &lt;<em><strong>filename</strong></em>&gt;</td><td>指定仿真过程中记录覆盖率的log文件名</td></tr><tr><td>-cm_name &lt;<em><strong>filename</strong></em>&gt;</td><td>指定保存覆盖率结果的文本文件的名称</td></tr><tr><td>-o &lt;<em><strong>name</strong></em>&gt;</td><td>指定编译生成的可执行文件的名称，默认是simv</td></tr><tr><td>+v2k</td><td>支持Verilog-2001标准</td></tr><tr><td><strong>+vcs+initmem</strong>+0/1/x/z</td><td>初始化设计中所有存储器的值</td></tr><tr><td><strong>+vcs+initreg</strong>+0/1/x/z</td><td>初始化设计中所有寄存器的值</td></tr><tr><td>+vcs+lic+wait</td><td>一直等待license</td></tr><tr><td> <p>+nospecify</p> </td><td> <p>是一种仿真运行时的选项。它用于控制VCS在仿真过程中如何处理Verilog中的`specify`块。 `specify`块是一种用于描述和约束时序电路中时序行为的特殊语言结构。它可以定义信号的时序延迟、校准和约束规则等。在仿真过程中，通常使用`specify`块进行时序约束的模拟。</p> <p>，当我们希望对设计进行功能仿真或性能分析时，并不需要考虑`specify`块中的时序约束，而只关注设计本身的逻辑行为。这时，可以使用`+nospecify`选项告诉VCS在仿真过程中忽略`specify`块。 具体地说，当使用了`+nospecify`选项时，VCS会在编译时将`specify`块从Verilog源代码中移除，并在仿真过程中忽略时序约束，从而将仿真重点放在逻辑行为上。</p> </td></tr><tr><td>+notimecheck</td><td> <p>是一种仿真运行时的选项。它用于控制VCS在仿真过程中是否执行时序约束的检查。</p> <p>Verilog中的时序约束用于描述和约束时序电路中的时序行为，例如信号的时序延迟、时钟和数据的关系等。在仿真过程中，VCS默认会执行时序约束的检查，以确保设计是否满足约束规定的时序要求。 然而，有时在进行功能仿真或性能分析时，并不需要进行严格的时序约束检查，而只关注设计本身的逻辑行为。这时可以使用`+notimecheck`选项告诉VCS在仿真过程中跳过时序约束的检查。 具体来说，当使用了`+notimecheck`选项时，VCS会忽略时序约束，不执行相关的检查。这将加快仿真速度，并且更侧重于逻辑行为的仿真。</p> </td></tr><tr><td style="width:155px;"></td><td style="width:469px;">上面这2个编译有时候需要加上，之前遇到了自己的makefile跑用例没有问题，但是eman回归就有问题，最后发现是两边的编译选项不一样；</td></tr><tr><td style="width:155px;">仿真选项（SIM）</td><td style="width:469px;"></td></tr><tr><td style="width:155px;">+ntb_random_seed</td><td style="width:469px;"></td></tr><tr><td>-line</td><td>使能VriSim中的单步运行</td></tr><tr><td>-ntb</td><td>使能ntb（Native TestBench），支持OpenVera验证平台语言结构。</td></tr><tr><td>-timescale=&lt;<em><strong>time_unit</strong></em>&gt;/&lt;<em><strong>time_precision</strong></em>&gt;</td><td>源代码文件中有的包括<code>timescale编译指令，有的不包括，如果在VCS命令行中，不包括</code>timescale的源代码文件在最前面，VCS会停止编译。使用-timescale选项为这些在前面且又没有`timescale的源文件指定timescale</td></tr><tr><td>-override_timescale=&lt;<em><strong>time_unit</strong></em>&gt;/&lt;<em><strong>time_precision</strong></em>&gt;</td><td>让源文件统一使用指定的timescale</td></tr><tr><td>-pvalues+&lt;<em><strong>parameter_name</strong></em>&gt;=&lt;<em><strong>value</strong></em>&gt;</td><td>改变指定参数的值<br> -pvalue选项支持在编译阶段去更改parameter的值；然后直接在makefile里控制parameter的随机即可</td></tr><tr><td>-parameters &lt;<em><strong>filename</strong></em>&gt;</td><td>通过文件的方式改变参数的值，参数的路径和改变的值均在文件中定义</td></tr><tr><td>+error+&lt;<em><strong>n</strong></em>&gt;</td><td>将编译时运行的NTB错误增加到N</td></tr><tr><td>-vcd &lt;<em><strong>filename</strong></em>&gt;</td><td>指定VCD波形文件名，默认是verilog.dump，会被源代码文件中的$dumpfile覆盖</td></tr><tr><td style="width:155px;"></td><td style="width:469px;"></td></tr><tr><td style="width:155px;"></td><td style="width:469px;"></td></tr></tbody></table> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<hr> 
<p>分离（块）（编译选项： -partcomp=adaptive_sched    -fastpartcomp=j8 </p> 
<h3>分离编译的优点</h3> 
<p>（1）拆分成多个线程去并行执行编译，节省了编译时间。-fastpartcom=jn，n代表并行线程的数量<br> （2）将DUT和TB分成若干partition，未修改的partition不需要重新编译</p> 
<p>参考链接：</p> 
<p><a href="https://blog.csdn.net/qq_41729871/article/details/125099963" title="vcs 分离编译_vcs分块编译_卓麻麻的博客-CSDN博客">vcs 分离编译_vcs分块编译_卓麻麻的博客-CSDN博客</a></p> 
<hr> 
<p>参考：<a href="https://blog.csdn.net/bcs_01/article/details/79803304" title="vcs常用仿真选项_lobbiy的博客-CSDN博客">vcs常用仿真选项_lobbiy的博客-CSDN博客</a></p> 
<hr> 
<p>vcs把verilog文件编译完成后，会生成simv文件；</p> 
<p>（跑仿真：./simv -l sim.log）</p> 
<p>跑仿真：./simv  +ntb_random_seed=12345  -l sim.log；（自动化脚本中，随机种子一般在makefile里面通过变量SEED传递进来）</p> 
<p>vcs的单步仿真： </p> 
<p></p> 
<p>生成波形文件：在top_tb.sv中加入下面这个initial块</p> 
<p><img alt="" height="134" src="https://images2.imgbox.com/49/9e/dhzPaxfo_o.png" width="666"></p> 
<p></p> 
<p>把数组型数据生成到波形文件中：</p> 
<p></p> 
<hr> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>-F/-f的区别</strong>：</p> 
<p style="margin-left:.0001pt;text-align:justify;">1. -F 使用<strong>相对路径</strong>索引include的文件。</p> 
<p style="margin-left:.0001pt;text-align:justify;">2.-f  使用<strong>绝对路径</strong>索引include的文件。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<hr> 
<p><strong>UVM常用编译选项：</strong> </p> 
<p>参考：</p> 
<p><a class="has-card" href="https://blog.csdn.net/weixin_41979380/article/details/121656373" title="UVM实战 卷I学习笔记18——UVM常用宏汇总_菜鸡想要飞的博客-CSDN博客"><span class="link-card-box"><span class="link-title">UVM实战 卷I学习笔记18——UVM常用宏汇总_菜鸡想要飞的博客-CSDN博客</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/09/90/Y9Zwibyh_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/weixin_41979380/article/details/121656373</span></span></a><a class="has-card" href="https://blog.csdn.net/weixin_41979380/article/details/121656117" title="UVM实战 卷I学习笔记17——UVM命令行参数汇总_菜鸡想要飞的博客-CSDN博客"><span class="link-card-box"><span class="link-title">UVM实战 卷I学习笔记17——UVM命令行参数汇总_菜鸡想要飞的博客-CSDN博客</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/0c/61/xJJLO8IZ_o.png" alt="icon-default.png?t=N7T8">https://blog.csdn.net/weixin_41979380/article/details/121656117</span></span></a>宏与运行时的<a href="https://so.csdn.net/so/search?q=%E5%91%BD%E4%BB%A4%E8%A1%8C&amp;spm=1001.2101.3001.7020" title="命令行">命令行</a>参数不同。它有两种定义方式，一是<strong>直接在源文件中中使用define进行定义</strong>：</p> 
<p>`define MACRO 100</p> 
<p>二是<strong>在编译时的命令行中使用如下方式</strong>：&lt;compile command&gt; +define+MACRO=100</p> 
<p>常见的<strong>UVM宏</strong>有：</p> 
<p>信息打印级别：USER_VCS_RUN_OPTS += +UVM_VERBOSITY=UVM_HIGH</p> 
<p>指定用例：+UVM_TESTNAME=xxx_tc</p> 
<p>打印出所有的命令行参数：&lt;sim command&gt; +UVM_DUMP_CMDLINE_ARGS</p> 
<p>在命令行中设置<a href="https://so.csdn.net/so/search?q=%E5%86%97%E4%BD%99&amp;spm=1001.2101.3001.7020" title="冗余">冗余</a>度阈值：+UVM_VERBOSITY=UVM_HIGH</p> 
<p>ERROR到达一定数量退出仿真：&lt;sim command&gt; +UVM_MAX_QUIT_COUNT=6,NO  （6数error数，no是不重载）（&lt;sim command&gt; +UVM_MAX_QUIT_COUNT=&lt;count&gt;,&lt;overridable&gt;<br> ）</p> 
<p>设置全局的超时时间：&lt;sim command&gt; +UVM_TIMEOUT="300ns, YES"</p> 
<p>打开phase的调试功能：&lt;sim command&gt; +UVM_PHASE_TRACE</p> 
<p>打开objection的调试功能：&lt;sim command&gt; +UVM_OBJECTION_TRACE</p> 
<p>打开config_db的调试功能： &lt;sim command&gt; +UVM_CONFIG_DB_TRACE</p> 
<p> 打开resource_db的调试功能： &lt;sim command&gt; +UVM_RESOURCE_DB_TRACE</p> 
<p>拓展寄存器模型的<strong>数据</strong>位宽：`define UVM_REG_DATA_WIDTH 128</p> 
<p>拓展寄存器模型的<strong>地址</strong>位宽：`define UVM_REG_ADDR_WIDTH 64<br> 自定义字选择位宽（很少见）：`define UVM_REG_BYTENABLE_WIDTH 8<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9fd92de9c3bbe05e24aec16983490055/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">docker部署最新版nacos(2.2.3)设置登录密码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/eab35dd923216c20292ba65fb4bb7198/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">ubuntu安装eigen、pangolin库</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>