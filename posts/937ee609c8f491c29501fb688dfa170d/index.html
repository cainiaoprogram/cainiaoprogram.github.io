<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>android NSD服务详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="android NSD服务详解" />
<meta property="og:description" content="android NSD服务详解 一.NSD的基础知识： NSD全称为: Network Service Discovery.翻译过来的意思就是发现服务器网络的意思。理解的说就是：发现服务器对应的网络信息。 作用为: The addition of Network Service Discovery (NSD) takes this further by allowing an application to seek out a nearby device running services with which it can communicate. (也就是说使用这个服务就可以搜索附近哪个网络设备设备可以进行通信，一般指的是局域网内连接同一个wifi的信号源).
NSD的作用和意义 NSD只是发现网络，并非直接连接网络，发现网络就是发现某个局域网内可连网络，并且获取到对应设备的IP地址和端口号。
NSD的作用就是为下一步连接网络做准备，比如使用Socket网络连接同一局域网两个手机，并且进行数据通信，这就要知道服务器的ip地址和端口号。
Socket不限于蓝牙交互，通过IP和端口号也是可以进行网络交互的，并且效率也比较快，就是会麻烦一些。
二.关于NSD的开发的过程. NSD（NsdManager）是Android SDK中自带的类库，可以直接调用编程。
这里我吐槽一下，网上很多示例代码都是比较坑爹的，基本步骤都是说什么注册、监听、处理、注销。。。 他们最大的失误是没有区分服务端和客户端。。。而是将代码混合在一起，刚开始接触的开发者就不知道怎么搞了！
其实NSD和Socket有点类似，都是有Server服务器端和Client客户端
对于Socket： SocketServer服务器端需要定义端口号，然后进行监听连接 SocketClient客户端需要知道服务器端定义的端口号和服务器的ip地址，然后请求连接 然后在客户端进行发送请求连接，服务器端同意连接，这时Socket连接就建立起来的，就可以相互通信了。 对于NSD： NSD Server服务器端定义主机名字、端口号，然后进行NSD注册 NSD Client客户端进行扫描，但是只能扫描到包含NSD Server服务器定义的主机名字的NsdServiceInfo对象 然后NSD Client客户端能根据这个NsdServiceInfo对象解析到服务器端的IP地址和它的端口号 到这里我们就应该知道了：NSD是为Socket连接做准备的其中一种手段！ 1.NSD Server 服务器端的开发 服务器端很简单的，就一个注册就可以了 具体的步骤有：
（1）进行注册监听 private NsdManager.RegistrationListener mRegistrationListener; //实例化注册监听器 private void initializeRegistrationListener() { mRegistrationListener = new NsdManager." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/937ee609c8f491c29501fb688dfa170d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-03-15T23:46:31+08:00" />
<meta property="article:modified_time" content="2018-03-15T23:46:31+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">android NSD服务详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2 id="android-nsd服务详解">android NSD服务详解</h2> 
<h2 id="一nsd的基础知识">一.NSD的基础知识：</h2> 
<p>NSD全称为: Network Service Discovery.翻译过来的意思就是发现服务器网络的意思。理解的说就是：发现服务器对应的网络信息。 <br> 作用为: The addition of Network Service Discovery (NSD) takes this further by allowing an application to seek out a nearby device running services with which it can communicate. <br> (也就是说使用这个服务就可以搜索附近哪个网络设备设备可以进行通信，一般指的是局域网内连接同一个wifi的信号源).</p> 
<h3 id="nsd的作用和意义">NSD的作用和意义</h3> 
<p>NSD只是发现网络，并非直接连接网络，发现网络就是发现某个局域网内可连网络，并且获取到对应设备的IP地址和端口号。</p> 
<p>NSD的作用就是为下一步连接网络做准备，比如使用Socket网络连接同一局域网两个手机，并且进行数据通信，这就要知道服务器的ip地址和端口号。</p> 
<p>Socket不限于蓝牙交互，通过IP和端口号也是可以进行网络交互的，并且效率也比较快，就是会麻烦一些。</p> 
<h2 id="二关于nsd的开发的过程">二.关于NSD的开发的过程.</h2> 
<p>NSD（NsdManager）是Android SDK中自带的类库，可以直接调用编程。</p> 
<p>这里我吐槽一下，网上很多示例代码都是比较坑爹的，基本步骤都是说什么注册、监听、处理、注销。。。 <br> 他们最大的失误是没有区分服务端和客户端。。。而是将代码混合在一起，刚开始接触的开发者就不知道怎么搞了！</p> 
<p>其实NSD和Socket有点类似，都是有Server服务器端和Client客户端</p> 
<h4 id="对于socket">对于Socket：</h4> 
<h5 id="socketserver服务器端需要定义端口号然后进行监听连接">SocketServer服务器端需要定义端口号，然后进行监听连接</h5> 
<h5 id="socketclient客户端需要知道服务器端定义的端口号和服务器的ip地址然后请求连接">SocketClient客户端需要知道服务器端定义的端口号和服务器的ip地址，然后请求连接</h5> 
<h5 id="然后在客户端进行发送请求连接服务器端同意连接这时socket连接就建立起来的就可以相互通信了">然后在客户端进行发送请求连接，服务器端同意连接，这时Socket连接就建立起来的，就可以相互通信了。</h5> 
<h4 id="对于nsd">对于NSD：</h4> 
<h5 id="nsd-server服务器端定义主机名字端口号然后进行nsd注册">NSD Server服务器端定义主机名字、端口号，然后进行NSD注册</h5> 
<h5 id="nsd-client客户端进行扫描但是只能扫描到包含nsd-server服务器定义的主机名字的nsdserviceinfo对象">NSD Client客户端进行扫描，但是只能扫描到包含NSD Server服务器定义的主机名字的NsdServiceInfo对象</h5> 
<h5 id="然后nsd-client客户端能根据这个nsdserviceinfo对象解析到服务器端的ip地址和它的端口号">然后NSD Client客户端能根据这个NsdServiceInfo对象解析到服务器端的IP地址和它的端口号</h5> 
<h5 id="到这里我们就应该知道了nsd是为socket连接做准备的其中一种手段">到这里我们就应该知道了：NSD是为Socket连接做准备的其中一种手段！</h5> 
<h3 id="1nsd-server-服务器端的开发">1.NSD Server 服务器端的开发</h3> 
<p>服务器端很简单的，就一个注册就可以了 <br> 具体的步骤有：</p> 
<h4 id="1进行注册监听">（1）进行注册监听</h4> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">private</span> NsdManager.RegistrationListener mRegistrationListener;

<span class="hljs-comment">//实例化注册监听器</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeRegistrationListener</span>() {
        mRegistrationListener = <span class="hljs-keyword">new</span> NsdManager.RegistrationListener() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRegistrationFailed</span>(NsdServiceInfo serviceInfo, <span class="hljs-keyword">int</span> errorCode) {
                Log.e(TAG, <span class="hljs-string">"NsdServiceInfo onRegistrationFailed"</span>);

            }

            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUnregistrationFailed</span>(NsdServiceInfo serviceInfo, <span class="hljs-keyword">int</span> errorCode) {
                Log.i(TAG, <span class="hljs-string">"onUnregistrationFailed serviceInfo: "</span> + serviceInfo + <span class="hljs-string">" ,errorCode:"</span> + errorCode);

            }

            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceRegistered</span>(NsdServiceInfo serviceInfo) {
                Log.i(TAG, <span class="hljs-string">"onServiceRegistered: "</span> + serviceInfo);

            }

            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceUnregistered</span>(NsdServiceInfo serviceInfo) {
                Log.i(TAG, <span class="hljs-string">"onServiceUnregistered serviceInfo: "</span> + serviceInfo);

            }
        };
    }
</code></pre> 
<p>注册监听是为了监听后面的注册服务器是否成功</p> 
<h4 id="2进行注册">（2）进行注册</h4> 
<pre class="prettyprint"><code class=" hljs cs">  <span class="hljs-keyword">private</span> NsdManager mNsdManager;
  <span class="hljs-comment">//注册服务器端</span>
   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerService</span>(Context context, String serviceName, <span class="hljs-keyword">int</span> port) {
        mNsdManager = (NsdManager) context.getSystemService(Context.NSD_SERVICE);
        NsdServiceInfo serviceInfo = <span class="hljs-keyword">new</span> NsdServiceInfo();
        serviceInfo.setServiceName(serviceName);
        serviceInfo.setPort(port);
        serviceInfo.setServiceType(<span class="hljs-string">"_http._tcp."</span>);<span class="hljs-comment">//客户端发现服务器是需要对应的这个Type字符串</span>
        mNsdManager.registerService(serviceInfo, NsdManager.PROTOCOL_DNS_SD, mRegistrationListener);
    }

</code></pre> 
<p>到这里如果客户端马上进行扫描就能看到注册了NSD的服务器网络数据 <br> 接着就可以进行Socket连接，并且可以取消掉注册NSD服务器，就是让别人看不到你的NSD服务器</p> 
<h4 id="3取消注册">（3）取消注册</h4> 
<pre class="prettyprint"><code class=" hljs cs">  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stopNSDServer</span>() {
        mNsdManager.unregisterService(mRegistrationListener);
    }
</code></pre> 
<p>如果要一直暴露自己的ip和端口数据，这个NSDServer就不要关闭，开发中根据实际情况来。 <br> 反正我是一直没有关闭这个暴露的端口信息，即使Socket连接上了，也没有关闭（隐藏），让它一直暴露着也没什么大问题！</p> 
<p>NSD服务器端就是这么简单，网上说的还要扫描，解析的那些都是在客户端来完成的。虽然也是NSD的一些操作方法，但是在服务器端是完全没有用到的。</p> 
<h3 id="2nsd-client-客户端的开发">2.NSD Client 客户端的开发</h3> 
<p>客户端分为两个步骤：扫描，解析 <br> 但是过程分为四步：</p> 
<h4 id="1注册扫描监听器">（1）注册扫描监听器</h4> 
<pre class="prettyprint"><code class=" hljs lasso">  <span class="hljs-comment">//NSD管理器</span>
  <span class="hljs-keyword">private</span> NsdManager mNsdManager <span class="hljs-subst">=</span> <span class="hljs-built_in">null</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-literal">void</span> initData() {
        mNsdManager <span class="hljs-subst">=</span> (NsdManager) getSystemService(Context<span class="hljs-built_in">.</span>NSD_SERVICE);
    }

  <span class="hljs-keyword">private</span> NsdManager<span class="hljs-built_in">.</span>DiscoveryListener mNSDDiscoveryListener <span class="hljs-subst">=</span> <span class="hljs-built_in">null</span>;    <span class="hljs-comment">//    搜寻监听器</span>

   <span class="hljs-comment">//注册NSD服务网络的监听，发现NSD网络后会在对应的方法回调</span>
    <span class="hljs-keyword">private</span> <span class="hljs-literal">void</span> initNSDDiscoveryListener() {
        mNSDDiscoveryListener <span class="hljs-subst">=</span> <span class="hljs-literal">new</span> NsdManager<span class="hljs-built_in">.</span>DiscoveryListener() {
            @Override
            <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onStartDiscoveryFailed(<span class="hljs-built_in">String</span> serviceType, int errorCode) {
                <span class="hljs-keyword">Log</span><span class="hljs-built_in">.</span>i(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">"onStartDiscoveryFailed--&gt; "</span> <span class="hljs-subst">+</span> serviceType <span class="hljs-subst">+</span> <span class="hljs-string">":"</span> <span class="hljs-subst">+</span> errorCode);
            }

            @Override
            <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onStopDiscoveryFailed(<span class="hljs-built_in">String</span> serviceType, int errorCode) {
                <span class="hljs-keyword">Log</span><span class="hljs-built_in">.</span>i(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">"onStopDiscoveryFailed--&gt; "</span> <span class="hljs-subst">+</span> serviceType <span class="hljs-subst">+</span> <span class="hljs-string">":"</span> <span class="hljs-subst">+</span> errorCode);
            }

            @Override
            <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onDiscoveryStarted(<span class="hljs-built_in">String</span> serviceType) {
                <span class="hljs-keyword">Log</span><span class="hljs-built_in">.</span>i(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">"onDiscoveryStarted--&gt; "</span> <span class="hljs-subst">+</span> serviceType );
            }

            @Override
            <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onDiscoveryStopped(<span class="hljs-built_in">String</span> serviceType) {
                <span class="hljs-keyword">Log</span><span class="hljs-built_in">.</span>i(<span class="hljs-built_in">TAG</span>, <span class="hljs-string">"onDiscoveryStopped--&gt; "</span> <span class="hljs-subst">+</span> serviceType );
            }

            @Override
            <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> onServiceFound(NsdServiceInfo serviceInfo) {<!-- --><span class="hljs-comment">//关键的回调方法</span>
        <span class="hljs-comment">//这里的 serviceInfo里面只有NSD服务器的主机名，要解析后才能得到该主机名的其他数据信息</span>
                 <span class="hljs-keyword">Log</span><span class="hljs-built_in">.</span>i(<span class="hljs-built_in">TAG</span>, onServiceFound Info: <span class="hljs-subst">--&gt;</span> <span class="hljs-string">" + serviceInfo);
                //开始解析数据

            }

            @Override
            public void onServiceLost(NsdServiceInfo serviceInfo) {
        Log.i(TAG, "</span>onServiceLost<span class="hljs-subst">--&gt;</span> <span class="hljs-string">" + serviceInfo);
            }
        };
    }

</span></code></pre> 
<h4 id="2注册解析监听器">（2）注册解析监听器</h4> 
<pre class="prettyprint"><code class=" hljs java">    <span class="hljs-keyword">private</span> NsdManager.ResolveListener mNSDResolveListener = <span class="hljs-keyword">null</span>;<span class="hljs-comment">//    解析监听器</span>

    <span class="hljs-comment">//注册解析NSD网络的监听 ,解析NSD数据后回调</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initNSDResolveListener</span>() {
        mNSDResolveListener = <span class="hljs-keyword">new</span> NsdManager.ResolveListener() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onResolveFailed</span>(NsdServiceInfo serviceInfo, <span class="hljs-keyword">int</span> errorCode) {

            }

            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceResolved</span>(NsdServiceInfo serviceInfo) {<!-- --><span class="hljs-comment">//到这里就是我们要的最终数据信息</span>
                Log.i(TAG, <span class="hljs-string">"resolution : "</span> + serviceInfo.getServiceName() + <span class="hljs-string">" \n host_from_server: "</span> + serviceInfo.getHost() +
                        <span class="hljs-string">"\n port from server: "</span> + serviceInfo.getPort());
                String hostAddress = serviceInfo.getHost().getHostAddress();


                Log.i(TAG, <span class="hljs-string">"hostAddress ip--&gt; "</span> + hostAddress );


            }
        };

    }

</code></pre> 
<h4 id="3扫描网络">（3）扫描网络</h4> 
<pre class="prettyprint"><code class=" hljs java">   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String mServerType = <span class="hljs-string">"_http._tcp."</span>;

  <span class="hljs-comment">//发现周边的NSD相关网络</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">discoveryNSDServer</span>(View view) {
        <span class="hljs-comment">//三个参数</span>
    <span class="hljs-comment">//第一个参数要和NSD服务器端定的ServerType一样，</span>
    <span class="hljs-comment">//第二个参数是固定的</span>
    <span class="hljs-comment">//第三个参数是扫描监听器</span>
        mNsdManager.discoverServices(mServerType, NsdManager.PROTOCOL_DNS_SD, mNSDDiscoveryListener);

    }
</code></pre> 
<p>进行发现服务操作后，会在扫描监听器对应的方法得到数据。</p> 
<h4 id="4解析网络">（4）解析网络</h4> 
<pre class="prettyprint"><code class=" hljs cs">
   <span class="hljs-comment">//对得到的NDSServiceInfo进行解析</span>
   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resoleServer</span>(){

   <span class="hljs-comment">//第一个参数是扫描得到的对象，第二个参数是解析监听对象</span>
   mNsdManager.resolveService(nsdServiceInfo, mNSDResolveListener);
   }

</code></pre> 
<p>对数据解析后就能在解析监听对象的回调方法中，获取到我们最终要的数据了。</p> 
<h5 id="有些人看网上那些例子说客户端也要注册才不会导致什么什么问题但是我是没有注册的并且程序很正常">有些人看网上那些例子，说客户端也要注册，才不会导致什么什么问题。但是我是没有注册的并且程序很正常。</h5> 
<p>按道理来说也是，不需要注册的，因为我们是要连接服务器端，自己并不需要作为服务器端，Socket连接也是这样的。 <br> 如果要自己是客户端，又是别人的服务器端，这种情况那就另说了。</p> 
<h2 id="对nsd的其他方面">对NSD的其他方面</h2> 
<p>NSD的Server服务器端的注册和监听最好是放在子线程中或者使用Android服务类Service来注册监听 <br> 同样Client客户端也是用子线程或Service来实现比较稳妥。 <br> 直接服务器端直接在Activity监听，回调，拿到里面的数据显示在Activity上面是有点问题的，我试过！ <br> NSD还有一些其他的坑，比如客户端扫描NSD网络中，这个扫描监听器不能在执行一次扫描，要等它扫描完成，否则程序会崩溃。</p> 
<h3 id="关于nsd这里有个简单的示例代码">关于NSD这里有个简单的示例，代码：</h3> 
<p><a href="https://download.csdn.net/download/wenzhi20102321/10289492" target="_blank" rel="noopener noreferrer">https://download.csdn.net/download/wenzhi20102321/10289492</a> <br> 程序基本功能还是可以的。就是现在不方便展示！ <br> 这个程序的主页是选择“Server页面”或者“Client”页面 <br> 点击选择“Server页面”进入服务器端页面，输入主机名、端口号，点击注册，稍等一下就显示是否注册成功 <br> 如果有另一个手机选择“Client页面”进入客户端页面，只有一个按钮选择dicoveryNSD，就会进行NSD网络发现，并且解析，最后显示扫描到的NSD网络的完整数据。</p> 
<h4 id="这里还有一个服务器端的封装代码可以直接拿来用的">这里还有一个服务器端的封装代码，可以直接拿来用的</h4> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-keyword">package</span> com.nsd.lwx.nsddemo.nsd;

<span class="hljs-keyword">import</span> android.content.Context;
<span class="hljs-keyword">import</span> android.net.nsd.NsdManager;
<span class="hljs-keyword">import</span> android.net.nsd.NsdServiceInfo;
<span class="hljs-keyword">import</span> android.util.Log;

<span class="hljs-keyword">import</span> com.nsd.lwx.nsddemo.utils.Constant;


<span class="hljs-javadoc">/**
 * Description: NSD Server 的封装类
 */</span>

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NSDServer</span> {<!-- --></span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String TAG = <span class="hljs-string">"NSDServer"</span>;
    <span class="hljs-keyword">private</span> NsdManager mNsdManager;
    <span class="hljs-keyword">private</span> NsdManager.RegistrationListener mRegistrationListener;<span class="hljs-comment">//注册监听器对象</span>
    <span class="hljs-keyword">private</span> String mServerName;
    <span class="hljs-keyword">private</span> Context mContext;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> mPort;
    <span class="hljs-keyword">private</span> String mServiceName;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String mServerType = <span class="hljs-string">"_http._tcp."</span>;

    <span class="hljs-comment">//监听注册，并开始NSDServer注册</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startNSDServer</span>(Context context, String serviceName, <span class="hljs-keyword">int</span> port) {
        initializeRegistrationListener();
        registerService(context, serviceName, port);
    }

    <span class="hljs-comment">//实例化注册监听器</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initializeRegistrationListener</span>() {
        mRegistrationListener = <span class="hljs-keyword">new</span> NsdManager.RegistrationListener() {
            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onRegistrationFailed</span>(NsdServiceInfo serviceInfo, <span class="hljs-keyword">int</span> errorCode) {
                Log.e(TAG, <span class="hljs-string">"NsdServiceInfo onRegistrationFailed"</span>);
                <span class="hljs-keyword">if</span> (registerState != <span class="hljs-keyword">null</span>) {
                    registerState.onRegistrationFailed(serviceInfo, errorCode);
                }
            }

            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUnregistrationFailed</span>(NsdServiceInfo serviceInfo, <span class="hljs-keyword">int</span> errorCode) {
                Log.i(TAG, <span class="hljs-string">"onUnregistrationFailed serviceInfo: "</span> + serviceInfo + <span class="hljs-string">" ,errorCode:"</span> + errorCode);
                <span class="hljs-keyword">if</span> (registerState != <span class="hljs-keyword">null</span>) {
                    registerState.onUnregistrationFailed(serviceInfo, errorCode);
                }
            }

            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceRegistered</span>(NsdServiceInfo serviceInfo) {
                mServerName = serviceInfo.getServiceName();
                Log.i(TAG, <span class="hljs-string">"onServiceRegistered: "</span> + serviceInfo);
                Log.i(TAG, <span class="hljs-string">"mServerName onServiceRegistered: "</span> + mServerName);
                <span class="hljs-keyword">if</span> (registerState != <span class="hljs-keyword">null</span>) {
                    registerState.onServiceRegistered(serviceInfo);
                }
            }

            <span class="hljs-annotation">@Override</span>
            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onServiceUnregistered</span>(NsdServiceInfo serviceInfo) {
                Log.i(TAG, <span class="hljs-string">"onServiceUnregistered serviceInfo: "</span> + serviceInfo);
                <span class="hljs-keyword">if</span> (registerState != <span class="hljs-keyword">null</span>) {
                    registerState.onServiceUnregistered(serviceInfo);
                }
            }
        };
    }

    <span class="hljs-comment">//注册NSD服务器端</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerService</span>(Context context, String serviceName, <span class="hljs-keyword">int</span> port) {
        mNsdManager = (NsdManager) context.getSystemService(Context.NSD_SERVICE);
        NsdServiceInfo serviceInfo = <span class="hljs-keyword">new</span> NsdServiceInfo();
        serviceInfo.setServiceName(serviceName);
        serviceInfo.setPort(port);
        serviceInfo.setServiceType(mServerType);
        mNsdManager.registerService(serviceInfo, NsdManager.PROTOCOL_DNS_SD, mRegistrationListener);
    }

    <span class="hljs-comment">//取消注册NSD服务器端</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stopNSDServer</span>() {
        mNsdManager.unregisterService(mRegistrationListener);
    }


    <span class="hljs-comment">//NSD服务注册监听接口</span>
    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IRegisterState</span> {<!-- --></span>
        <span class="hljs-keyword">void</span> onServiceRegistered(NsdServiceInfo serviceInfo);     <span class="hljs-comment">//注册NSD成功</span>

        <span class="hljs-keyword">void</span> onRegistrationFailed(NsdServiceInfo serviceInfo, <span class="hljs-keyword">int</span> errorCode);   <span class="hljs-comment">//注册NSD失败</span>

        <span class="hljs-keyword">void</span> onServiceUnregistered(NsdServiceInfo serviceInfo);  <span class="hljs-comment">//取消NSD注册成功</span>

        <span class="hljs-keyword">void</span> onUnregistrationFailed(NsdServiceInfo serviceInfo, <span class="hljs-keyword">int</span> errorCode); <span class="hljs-comment">//取消NSD注册失败</span>

    }

    <span class="hljs-comment">//NSD服务接口对象</span>
    <span class="hljs-keyword">private</span> IRegisterState registerState;


    <span class="hljs-comment">//设置NSD服务接口对象</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRegisterState</span>(IRegisterState registerState) {
        <span class="hljs-keyword">this</span>.registerState = registerState;
    }
}

</code></pre> 
<p>具体的用法可以看看示例程序。</p> 
<p>总之明白一点，NSD就是为了发现周边可通信的网络设备。</p> 
<h2 id="共勉新加坡人阿杜在建筑工地的日子也好不到哪去">共勉：新加坡人阿杜在建筑工地的日子，也好不到哪去。</h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3246327e762a3eaf6300c569f49c4c48/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">商业模式画布</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d78803b1cbf0780cc04de5c973908788/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">分布式版本控制工具 Mercurial 使用教程 (hg 入门简单命令)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>