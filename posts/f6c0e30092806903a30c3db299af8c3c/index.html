<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>STM32-微项目08-ADC单通道/多通道模式采集 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="STM32-微项目08-ADC单通道/多通道模式采集" />
<meta property="og:description" content="huo
一、微项目实现目标：
1，利用STM32内置的ADC模块，将外部模拟量信号（0-3.3v）转化成12位有效（16位数据）的数字量（0-4095），在将采集的数字除4095，就会得到对应采集的模拟量信号；
二、微项目硬件配置需求：
stm32F103C8T6核心板一块；
0.96寸OLED显示，用于显示计数；
模拟量输入（滑动电阻、光线传感器、温度传感器等），接线时刻，需要接AO输出口；
三、前置知识：
1，逐次逼近型ADC的处理逻辑
在外部有模拟量输入时，DAC设置参数并输出模拟量，对比模拟量数据和输入的模拟量相近或相等时刻，则配置输出的DAC的数字量参数，就是输入模拟量的对应转化后的数字量；
2，ADC整体控制逻辑框图
①数据流：外部GPIO模拟量-----AD转换器（注入组和规则组）-----触发转化 ----转化数值存放到AD数据寄存器中
②ADC关键模块解析
图中2：表示外部模拟量的输入端口，有18个通道入口其中0-15是外部接口
图中1：表示启动ADC启动
图中3：表示ADC的时钟，ADC1最大接受时钟14MHZ的，外部接入72MHZ，需要配置分频处理；
图中4：具体转化执行模块
图中5：注入通道和规则通道寄存器，转化后数据存放在这。其中规则通道只有一个，所有转化后，需要立即取走，否则后续转化数据会覆盖掉；
图中6：DMA请求，ADC转化后，配合DMA模式进行数据转移；
③输入通道及转化模式
1-ADC1通道情况
1）单次模式和连续模式：数据转化时，是否连续转化。单次模式，仅转化一次；连续模式时，转换一次 后再从头开始重新转化；
2）扫描模式和非扫描模式：扫描模式，就是将序列中数据从头到尾全部转化；非扫描模式，仅转化序列中的第一个；
3）几种数据转化模式：
单次转换，非扫描模式
连续转换，非扫描模式
、
单次转换，扫描模式
连续转换，扫描模式
④触发转化，一般选用软件触发
⑤转化后，寄存器数据对齐方式，一般选用靠右侧对齐
⑥转化校准，具体代码中执行
四、代码逻辑分析：
①开启GPIO和ADC的时钟，并且对输入ADC通道进行分频处理；
②配置GPIO模式，模拟输入
③配置AD输入通道，即配置输入通道和所在处理序列；
④初始化AD模块，并配置AD模式\数据对齐\扫描模式\连续模式等
⑤打开ADC使能开关（并非开启后ADC就会工作，需要软件触发源触发执行）
⑥执行AD校准模块
⑦开启软件触发ADC执行工作
五、代码示例：
①开启GPIO和ADC的时钟，并且对输入ADC通道进行分频处理；
//打开ADC1时钟 和GPIO时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE); RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE); //配置ADC1的分频，ADC最高支持14mhz RCC_ADCCLKConfig(RCC_PCLK2_Div6); ②配置GPIO模式，模拟输入
//初始化GPIO模块,模拟输入模式 GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.GPIO_Mode=GPIO_Mode_AIN; GPIO_InitStruct.GPIO_Pin=GPIO_Pin_0; GPIO_InitStruct.GPIO_Speed=GPIO_Speed_50MHz; GPIO_Init(GPIOA,&amp;GPIO_InitStruct); ③配置AD输入通道，即配置输入通道和所在处理序列；
第二个参数：通道接入的端口
第三个参数：规则序列的位置
第四个参数：采样时间
//配置ad输入通道 ADC_RegularChannelConfig( ADC1, ADC_Channel_0, 1, ADC_SampleTime_55Cycles5); ④初始化AD模块，并配置AD模式\数据对齐\扫描模式\连续模式等" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f6c0e30092806903a30c3db299af8c3c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-14T13:07:42+08:00" />
<meta property="article:modified_time" content="2023-03-14T13:07:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">STM32-微项目08-ADC单通道/多通道模式采集</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>huo</p> 
<p></p> 
<p></p> 
<p>一、微项目实现目标：</p> 
<p>1，利用STM32内置的ADC模块，将外部模拟量信号（0-3.3v）转化成12位有效（16位数据）的数字量（0-4095），在将采集的数字除4095，就会得到对应采集的模拟量信号；</p> 
<p></p> 
<p>二、微项目硬件配置需求：</p> 
<p> <a href="https://so.csdn.net/so/search?q=stm32F103C8T6&amp;spm=1001.2101.3001.7020" title="stm32F103C8T6">stm32F103C8T6</a>核心板一块；</p> 
<p>0.96寸OLED显示，用于显示计数；</p> 
<p>模拟量输入（滑动电阻、光线传感器、温度传感器等），接线时刻，需要接AO输出口；</p> 
<p></p> 
<p><img alt="" height="183" src="https://images2.imgbox.com/ef/99/VJh5ctfe_o.png" width="227"><img alt="" height="180" src="https://images2.imgbox.com/dd/02/0UX4Wydj_o.png" width="178"></p> 
<p><img alt="" height="468" src="https://images2.imgbox.com/17/28/Z5yL1MM9_o.png" width="404"></p> 
<p> </p> 
<p>三、前置知识：</p> 
<p>1，逐次逼近型ADC的处理逻辑</p> 
<p>在外部有模拟量输入时，DAC设置参数并输出模拟量，对比模拟量数据和输入的模拟量相近或相等时刻，则配置输出的DAC的数字量参数，就是输入模拟量的对应转化后的数字量；</p> 
<p><img alt="" height="471" src="https://images2.imgbox.com/c3/28/CykJpPFO_o.png" width="736"></p> 
<p> 2，ADC整体控制逻辑框图</p> 
<p><img alt="" height="350" src="https://images2.imgbox.com/9d/25/Cnhly5TO_o.png" width="748"></p> 
<p> ①数据流：外部GPIO模拟量-----AD转换器（注入组和规则组）-----触发转化 ----转化数值存放到AD数据寄存器中</p> 
<p><img alt="" height="783" src="https://images2.imgbox.com/f2/4a/7VtlKnh6_o.png" width="586"></p> 
<p>②ADC关键模块解析</p> 
<p> 图中2：表示外部模拟量的输入端口，有18个通道入口其中0-15是外部接口</p> 
<p>图中1：表示启动ADC启动</p> 
<p>图中3：表示ADC的时钟，ADC1最大接受时钟14MHZ的，外部接入72MHZ，需要配置分频处理；</p> 
<p>图中4：具体转化执行模块</p> 
<p>图中5：注入通道和规则通道寄存器，转化后数据存放在这。其中规则通道只有一个，所有转化后，需要立即取走，否则后续转化数据会覆盖掉；</p> 
<p>图中6：DMA请求，ADC转化后，配合DMA模式进行数据转移；</p> 
<p></p> 
<p>③输入通道及转化模式</p> 
<p>1-ADC1通道情况</p> 
<p><img alt="" height="397" src="https://images2.imgbox.com/70/41/RxbwfxLK_o.png" width="213"></p> 
<p>1）单次模式和连续模式：数据转化时，是否连续转化。单次模式，仅转化一次；连续模式时，转换一次 后再从头开始重新转化；</p> 
<p>2）扫描模式和非扫描模式：扫描模式，就是将序列中数据从头到尾全部转化；非扫描模式，仅转化序列中的第一个；</p> 
<p></p> 
<p>3）几种数据转化模式：</p> 
<p>单次转换，非扫描模式</p> 
<p><img alt="" height="389" src="https://images2.imgbox.com/a3/61/ZIZFVfy9_o.png" width="600"></p> 
<p> 连续转换，非扫描模式</p> 
<p><img alt="" height="393" src="https://images2.imgbox.com/67/06/2DxOi9YI_o.png" width="620">、</p> 
<p>单次转换，扫描模式</p> 
<p> <img alt="" height="370" src="https://images2.imgbox.com/76/a2/4L65RRwQ_o.png" width="664"></p> 
<p> 连续转换，扫描模式</p> 
<p><img alt="" height="395" src="https://images2.imgbox.com/a2/f6/4wSNNfwn_o.png" width="741"></p> 
<p> </p> 
<p>④触发转化，一般选用软件触发</p> 
<p><img alt="" height="396" src="https://images2.imgbox.com/b0/51/h83NUFs8_o.png" width="1094"></p> 
<p> ⑤转化后，寄存器数据对齐方式，一般选用靠右侧对齐</p> 
<p><img alt="" height="75" src="https://images2.imgbox.com/b5/6a/YZli7uJO_o.png" width="898"></p> 
<p> ⑥转化校准，具体代码中执行</p> 
<p></p> 
<p></p> 
<p>四、代码逻辑分析：</p> 
<p>①开启GPIO和ADC的时钟，并且对输入ADC通道进行分频处理；</p> 
<p>②配置GPIO模式，模拟输入</p> 
<p>③配置AD输入通道，即配置输入通道和所在处理序列；</p> 
<p>④初始化AD模块，并配置AD模式\数据对齐\扫描模式\连续模式等</p> 
<p>⑤打开ADC使能开关（并非开启后ADC就会工作，需要软件触发源触发执行）</p> 
<p>⑥执行AD校准模块</p> 
<p>⑦开启软件触发ADC执行工作</p> 
<p></p> 
<p>五、代码示例：</p> 
<p>①开启GPIO和ADC的时钟，并且对输入ADC通道进行分频处理；</p> 
<pre><code class="hljs">	//打开ADC1时钟 和GPIO时钟
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);
	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);
	//配置ADC1的分频，ADC最高支持14mhz
	RCC_ADCCLKConfig(RCC_PCLK2_Div6);</code></pre> 
<p>②配置GPIO模式，模拟输入</p> 
<pre><code class="hljs">	//初始化GPIO模块,模拟输入模式
	GPIO_InitTypeDef GPIO_InitStruct;
	GPIO_InitStruct.GPIO_Mode=GPIO_Mode_AIN;
	GPIO_InitStruct.GPIO_Pin=GPIO_Pin_0;
	GPIO_InitStruct.GPIO_Speed=GPIO_Speed_50MHz;
	
	GPIO_Init(GPIOA,&amp;GPIO_InitStruct);</code></pre> 
<p>③配置AD输入通道，即配置输入通道和所在处理序列；</p> 
<p>第二个参数：通道接入的端口</p> 
<p>第三个参数：规则序列的位置</p> 
<p>第四个参数：采样时间</p> 
<pre><code class="hljs">//配置ad输入通道
	ADC_RegularChannelConfig( ADC1,  ADC_Channel_0, 1, ADC_SampleTime_55Cycles5);</code></pre> 
<p>④初始化AD模块，并配置AD模式\数据对齐\扫描模式\连续模式等</p> 
<pre><code class="hljs">	//初始化AD模块
	ADC_InitTypeDef  ADC_InitStruct;
	ADC_InitStruct.ADC_ContinuousConvMode=DISABLE;//单次模式
	ADC_InitStruct.ADC_DataAlign=ADC_DataAlign_Right ;//转化后在寄存器内右对齐
	ADC_InitStruct.ADC_ExternalTrigConv=ADC_ExternalTrigConv_None ;//软件触发，不使用硬件触发转化
	ADC_InitStruct.ADC_Mode=ADC_Mode_Independent;//独立模式
	ADC_InitStruct.ADC_NbrOfChannel=1;
	ADC_InitStruct.ADC_ScanConvMode=DISABLE;//扫描模式
	ADC_Init( ADC1, &amp; ADC_InitStruct);</code></pre> 
<p>⑤打开ADC使能开关（并非开启后ADC就会工作，需要软件触发源触发执行）</p> 
<pre><code class="hljs">//开启adc电源
	ADC_Cmd(ADC1,ENABLE);</code></pre> 
<p>⑥执行AD校准模块</p> 
<pre><code class="hljs">//ADC校准
	ADC_ResetCalibration(ADC1);
	while(ADC_GetResetCalibrationStatus(ADC1)==SET);//完成后会被硬件置为reset
	ADC_StartCalibration(ADC1);
	while(ADC_GetCalibrationStatus(ADC1)==SET);</code></pre> 
<p>⑦获取转化后的寄存器数值</p> 
<p>注意是先进行软件触发，之后等待标志位E0C，再返回数据</p> 
<pre><code class="hljs">uint16_t AD_getvalue(void)
{
	ADC_SoftwareStartConvCmd( ADC1, ENABLE);//软件触发转换
	
	while(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC)==RESET);
	//转化完成后，返回的是reset.读完后，对应寄存器会自动变为reset
	return  ADC_GetConversionValue(ADC1);
}</code></pre> 
<p>最后在主函数中，简答配置</p> 
<pre><code class="hljs">#include "stm32f10x.h"                  // Device header
#include "delay.h"
#include "OLED.H"
#include "ad.H"

uint16_t advalue=0;
float voltage=0.0;
int main()
{
	OLED_Init();
	ADC_init();
	OLED_ShowString(1,1,"ADvalue:");
	OLED_ShowString(2,1,"voltage:0.00v");
	while(1)
	{
		advalue= AD_getvalue();
		voltage=(float)advalue/4095*3.3;//输出电压
		OLED_ShowNum(1,9,advalue,4);
		OLED_ShowNum(2,9,voltage,1);
		OLED_ShowNum(2,11,(uint16_t)(voltage*100)%100,2);
		Delay_ms(1000);
	}
}</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/021e2e1d79d24612b39e97bea41c2fee/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">mysql 删除表卡死，或是截断（truncate）卡死解决办法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e74e23e89931e5c713226b9cf74e2a1d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">从BERT到ROBERTA：预训练语言模型的优化之路</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>