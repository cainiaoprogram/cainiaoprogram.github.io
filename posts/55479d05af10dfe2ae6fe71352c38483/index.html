<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>WPF 入门教程DispatcherTimer计时器 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="WPF 入门教程DispatcherTimer计时器" />
<meta property="og:description" content="https://www.zhihu.com/tardis/bd/art/430630047?source_id=1001
在 WinForms 中，有一个名为 Timer 的控件，它可以在给定的时间间隔内重复执行一个操作。WPF 也有这种可能性，但我们有DispatcherTimer控件，而不是不可见的控件。它几乎做同样的事情，但不是将它放在表单上，​​而是专门从代码隐藏代码中创建和使用它。
DispatcherTimer 类的工作方式是指定一个时间间隔，然后订阅每次满足该时间间隔时将发生的Tick事件。在调用Start()方法或将IsEnabled属性设置为 true之前，不会启动 DispatcherTimer 。
让我们尝试一个简单的例子，我们使用 DispatcherTimer 创建一个数字时钟：
&lt;Window x:Class=&#34;WpfTutorialSamples.Misc.DispatcherTimerSample&#34; xmlns=&#34;http://schemas.microsoft.com/winfx/2006/xaml/presentation&#34; xmlns:x=&#34;http://schemas.microsoft.com/winfx/2006/xaml&#34; Title=&#34;DispatcherTimerSample&#34; Height=&#34;150&#34; Width=&#34;250&#34;&gt; &lt;Grid&gt; &lt;Label Name=&#34;lblTime&#34; FontSize=&#34;48&#34; HorizontalAlignment=&#34;Center&#34; VerticalAlignment=&#34;Center&#34; /&gt; &lt;/Grid&gt; &lt;/Window&gt; using System; using System.Windows; using System.Windows.Threading; namespace WpfTutorialSamples.Misc { public partial class DispatcherTimerSample : Window { public DispatcherTimerSample() { InitializeComponent(); DispatcherTimer timer = new DispatcherTimer(); timer.Interval = TimeSpan.FromSeconds(1); timer.Tick &#43;= timer_Tick; timer.Start(); } void timer_Tick(object sender, EventArgs e) { lblTime." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/55479d05af10dfe2ae6fe71352c38483/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T17:29:17+08:00" />
<meta property="article:modified_time" content="2024-01-05T17:29:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">WPF 入门教程DispatcherTimer计时器</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><a href="https://www.zhihu.com/tardis/bd/art/430630047?source_id=1001" rel="nofollow" title="https://www.zhihu.com/tardis/bd/art/430630047?source_id=1001">https://www.zhihu.com/tardis/bd/art/430630047?source_id=1001</a></p> 
<p></p> 
<p>在 WinForms 中，有一个名为 Timer 的控件，它可以在给定的时间间隔内重复执行一个操作。WPF 也有这种可能性，但我们有<strong>DispatcherTimer</strong>控件，而不是不可见的控件。它几乎做同样的事情，但不是将它放在表单上，​​而是专门从代码隐藏代码中创建和使用它。</p> 
<p>DispatcherTimer 类的工作方式是指定一个时间间隔，然后订阅每次满足该时间间隔时将发生的<strong>Tick</strong>事件。在调用<strong>Start()</strong>方法或将<strong>IsEnabled</strong>属性设置为 true之前，不会启动 DispatcherTimer 。</p> 
<p>让我们尝试一个简单的例子，我们使用 DispatcherTimer 创建一个数字时钟：</p> 
<pre><code>&lt;Window x:Class="WpfTutorialSamples.Misc.DispatcherTimerSample"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="DispatcherTimerSample" Height="150" Width="250"&gt;
    &lt;Grid&gt;
        &lt;Label Name="lblTime" FontSize="48" HorizontalAlignment="Center" VerticalAlignment="Center" /&gt;
    &lt;/Grid&gt;
&lt;/Window&gt;</code></pre> 
<pre><code>using System;
using System.Windows;
using System.Windows.Threading;

namespace WpfTutorialSamples.Misc
{
	public partial class DispatcherTimerSample : Window
	{
		public DispatcherTimerSample()
		{
			InitializeComponent();
			DispatcherTimer timer = new DispatcherTimer();
			timer.Interval = TimeSpan.FromSeconds(1);
			timer.Tick += timer_Tick;
			timer.Start();
		}

		void timer_Tick(object sender, EventArgs e)
		{
			lblTime.Content = DateTime.Now.ToLongTimeString();
		}
	}
}
</code></pre> 
<p></p> 
<p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/a2/24/KLEcvqeO_o.png" width="250"></p> 
<p>XAML 部分非常简单——它只是一个带有大字体的居中标签，用于显示当前时间。</p> 
<p>在这个例子中，代码隐藏是魔法发生的地方。在窗口的构造函数中，我们创建了一个 DispatcherTimer 实例。我们将<strong>Interval</strong>属性设置为 一秒，订阅 Tick 事件，然后启动计时器。在 Tick 事件中，我们只需更新标签以显示当前时间。</p> 
<p>当然，DispatcherTimer 可以以更小或更大的间隔工作。例如，您可能只希望每 30 秒或 5 分钟发生一次 - 只需使用 TimeSpan.From* 方法，如 FromSeconds 或 FromMinutes，或创建一个完全符合您需求的新 TimeSpan 实例。</p> 
<p>为了展示 DispatcherTimer 的功能，让我们尝试更频繁地更新……更频繁地更新！</p> 
<pre><code>using System;
using System.Windows;
using System.Windows.Threading;

namespace WpfTutorialSamples.Misc
{
	public partial class DispatcherTimerSample : Window
	{
		public DispatcherTimerSample()
		{
			InitializeComponent();
			DispatcherTimer timer = new DispatcherTimer();
			timer.Interval = TimeSpan.FromMilliseconds(1);
			timer.Tick += timer_Tick;
			timer.Start();
		}

		void timer_Tick(object sender, EventArgs e)
		{
			lblTime.Content = DateTime.Now.ToString("HH:mm:ss.fff");
		}
	}
}
</code></pre> 
<p></p> 
<p class="img-center"><img alt="" height="150" src="https://images2.imgbox.com/07/f2/iiEWcibo_o.png" width="335"></p> 
<p>如您所见，我们现在要求 DispatcherTimer 每毫秒触发一次！在 Tick 事件中，我们也使用自定义时间格式字符串来显示标签中的毫秒数。现在您有一些可以轻松用作秒表的东西 - 只需向窗口添加几个按钮，然后让它们调用 计时器上的<strong>Stop()</strong>、<strong>Start()</strong>和<strong>Restart()</strong>方法。</p> 
<h3>概括</h3> 
<p>在许多情况下，您需要在给定的时间间隔内在应用程序中发生某些事情，而使用 DispatcherTimer，这很容易实现。请注意，如果您在 Tick 事件中做了一些复杂的事情，它不应该运行得太频繁，就像在上一个示例中，计时器每毫秒滴答一次——这会给运行您的应用程序的计算机带来沉重的压力。</p> 
<p><span style="color:#fe2c24;">另请注意，DispatcherTimer 并非在所有情况下都 100% 精确。tick 操作放在 Dispatcher 队列中，因此如果计算机压力很大，您的操作可能会延迟。.NET 框架承诺 Tick 事件永远不会太早发生，但不能承诺它不会稍微延迟。但是，对于大多数用例， DispatcherTimer 已经足够精确了。</span></p> 
<p>如果您需要您的计时器在队列中具有更高的优先级，您可以通过发送 DispatcherTimer 优先级上的值之一来设置 DispatcherPriority 。</p> 
<p>推荐WPF MVVM框架开源控件库：Newbeecoder.UI</p> 
<p><a href="https://link.zhihu.com/?target=https%3A//www.zhihu.com/video/1515266659548389376" rel="nofollow" title="​编辑https://www.zhihu.com/video/1515266659548389376">​编辑https://www.zhihu.com/video/1515266659548389376</a></p> 
<p>Demo下载：</p> 
<p><a href="https://link.zhihu.com/?target=https%3A//share.weiyun.com/py6W1dcK" rel="nofollow" title="Newbeecoder.UI开源项目">Newbeecoder.UI开源项目</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a5cdf22c5e5636666f380a648ee8ff9c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python安装Pandas库</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2bb8b582d6c8b0a7d2a448ba5c1a0d3e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">多线程和JVM</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>