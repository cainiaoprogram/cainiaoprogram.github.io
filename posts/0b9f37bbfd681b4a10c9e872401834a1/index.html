<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SelFlow: Self-Supervised Learning of Optical Flow - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SelFlow: Self-Supervised Learning of Optical Flow" />
<meta property="og:description" content="本文提出了一种用于光流的自监督学习方法。该方法从非遮挡像素中提取可靠的流估计，并使用这些预测作为真值来学习幻觉遮挡的光流。 本文设计了一个简单的 CNN，以利用 来自多个帧的时间信息 来更好地进行流估计。本方法可以在 MPI Sintel、KITTI 2012 和 2015 等具有挑战性的基准上为无监督光流学习产生最佳性能。 光流估计是各种计算机视觉系统的核心构建模块。由于遮挡，准确的流估计仍然是一个悬而未决的问题。传统方法最小化能量函数以 鼓励视觉上相似像素的关联 并规范非相干运动 以将流估计从非遮挡像素传播到遮挡像素。然而，这一系列方法通常很耗时，并且不适用于实时应用。 最近的研究学习使用卷积神经网络 (CNN) 从图像中端到端地估计光流。然而，训练完全监督的 CNN 需要大量标记的训练数据 ，这对于光流来说是极其难以获得的，尤其是在存在遮挡的情况下。训练数据的大小是光流估计的关键瓶颈。 在没有大规模真实世界注释的情况下，现有方法转向在 合成标记数据集 上进行 预训练，然后在小型注释数据集上 进行微调。然而，合成数据的分布与自然场景之间通常存在很大差距。为了训练一个稳定的模型，我们必须仔细遵循不同数据集的特定学习计划 。 受益于未标记数据的无监督光流学习方法的基本思想 是根据估计的光流 将目标图像向参考图像扭曲，然后使用 光度损失 最小化参考图像和扭曲目标图像之间的差异。这种想法适用于非遮挡像素，但会为遮挡像素提供误导性信息。最近的方法建议在计算光度损失时排除那些被遮挡的像素，或者使用额外的空间和时间平滑项来规范流量估计 。DDFlow [26] 提出了一种 数据蒸馏 方法，该方法采用 随机裁剪 来创建遮挡以进行自监督。但这些方法不能很好地泛化所有自然遮挡。因此，将无监督方法与最先进的全监督方法相比，仍然存在很大的性能差距。 （data distillation：对没有标签的数据进行多种变换(类似与数据增强)，使用单模型进行预测，然后集成预测结果，自动生成图像标签的方法 ） 本文展示了一种自监督的方法 可以学习从未标记的数据中 使用任何形式的遮挡 来估计光流。本文的工作基于从非遮挡像素中提取可靠的流估计，并使用这些预测 来指导遮挡的光流学习。图 1 说明了本文通过 扰动超像素 来创建合成遮挡的想法。本文进一步 利用 来自多个帧的时间信息 来提高简单 CNN 架构中的流预测精度。由此产生的学习方法在 Sintel 和 KITTI 基准上的所有无监督光流学习方法中产生了最高的准确性。 图1：首先用经典的光度损失（测量参考图像（a）和扭曲的目标图像（d）之间的差异）训练我们的 NOC 模型，由遮挡图（g）引导。然后 扰动目标图像（b）中随机选择的超像素 以产生幻觉遮挡。最后，使用来自NOC 模型的可靠流估计来指导 OCC 模型学习那些新被遮挡的像素（由自监督掩码 (i) 表示，其中值 1 表示像素在 (g )中未遮挡 但在 (h) 中被遮挡。请注意，黄色区域是移动狗的一部分。我们的自监督方法学习运动物体和静态场景的光流。 Selflow是监督学习方法第一次在不使用任何外部标记数据的情况下实现如此出色的准确性。 Related Work： 经典的光流估计： 经典变分方法将光流估计建模为 基于亮度恒定性和空间平滑度的能量最小化问题。这种方法 对小运动有效，但当位移很大时往往会失败 。后来的工作集成了特征匹配以初始化稀疏匹配，然后以金字塔粗到细的方式插入密集流图 [6, 47, 38]。 最近的工作使用卷积神经网络 (CNN) 通过学习有效的特征嵌入来改进稀疏匹配 [49, 2]。然而，这些方法通常计算成本高，并且无法进行端到端的训练。 提高流估计的鲁棒性和准确性的一种自然扩展是在多个帧上合并时间信息。一种直接的方法是添加时间上的约束 ，例如恒定速度、恒定加速度、低维线性子空间 或刚性/非刚性分割。 但本文的方法要简单得多，并且不依赖于任何数据假设。Selflow直接为数据中 存在更广泛的具有挑战性的案例 学习光流。 光流的监督学习：使用 CNN 学习光流 FlowNet 是第一个端到端的光流学习框架。它以两个连续的图像作为输入并输出一个密集的流图。 FlowNet 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0b9f37bbfd681b4a10c9e872401834a1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-25T22:07:46+08:00" />
<meta property="article:modified_time" content="2023-05-25T22:07:46+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SelFlow: Self-Supervised Learning of Optical Flow</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;">       本文提出了一种<strong>用于光流的</strong>自监督学习方法。该方法<strong>从非遮挡像素中提取可靠的流估计</strong>，并使用这些预测作为真值来学习幻觉遮挡的光流。</span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;">       本文设计了一个简单的 CNN，以利用 来自多个帧的时间信息 来更好地进行流估计。本方法可以在 MPI Sintel、KITTI 2012 和 2015 等具有挑战性的基准上为无监督光流学习产生最佳性能。</span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;">       光流估计是各种计算机视觉系统的核心构建模块。由于<span style="color:#800000;"><strong>遮挡</strong></span>，准确的流估计仍然是一个悬而未决的问题。传统方法<span style="color:#800000;">最小化能量函数</span>以 鼓励视觉上相似像素的关联 并规范非相干运动 以将流估计从非遮挡像素传播到遮挡像素。然而，这一系列方法通常很<strong>耗时</strong>，并且不适用于实时应用。</span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;">       <span style="color:#000000;">最近的研究学习使用卷积神经网络 (</span><span style="color:#000000;"><strong>CNN</strong></span><span style="color:#000000;">) 从图像中</span><span style="color:#800000;">端到端地估计光流</span><span style="color:#000000;">。然而，训练完全监督的 CNN  </span><span style="color:#000000;"><strong>需要大量标记的训练数据</strong></span><span style="color:#000000;"> ，这对于光流来说是极其难以获得的，尤其是在存在遮挡的情况下。</span><span style="color:#800000;"><strong>训练数据的大小</strong></span><span style="color:#000000;">是光流估计的关键瓶颈。 </span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">在没有大规模真实世界注释的情况下，现有方法转向在 </span><span style="color:#000000;"><strong>合成标记数据集</strong></span><span style="color:#000000;"> 上进行 预训练，然后在小型注释数据集上 进行微调。然而，合成数据的分布与自然场景之间通常存在很大差距。为了训练一个稳定的模型，我们必须仔细遵循不同数据集的特定学习计划 。</span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">受益于未标记数据的</span><span style="color:#800000;">无监督</span><span style="color:#000000;">光流学习方法的基本思想 是根据估计的光流 将目标图像向参考图像扭曲，然后使用 光度损失 最小化参考图像和扭曲目标图像之间的差异。这种想法</span><span style="color:#800000;"><strong>适用于非遮挡像素</strong></span><span style="color:#000000;">，但会为遮挡像素提供误导性信息。最近的方法建议在计算光度损失时排除那些被遮挡的像素，或者使用额外的空间和时间平滑项来规范流量估计 。DDFlow [26] 提出了一种 </span><span style="color:#000000;"><strong>数据蒸馏</strong></span><span style="color:#000000;"> 方法，该方法采用 </span><span style="color:#800000;">随机裁剪</span><span style="color:#000000;"> 来创建遮挡以进行自监督。但这些方法不能很好地泛化所有自然遮挡。因此，将无监督方法与最先进的全监督方法相比，仍然存在很大的性能差距。 </span></span></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">（</span><span style="color:#000000;"><strong>data distillation</strong></span><span style="color:#000000;">：对没有标签的数据进行多种变换(类似与数据增强)，使用单模型进行预测，然后集成预测结果，自动生成图像标签的方法 ）</span></span></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">本文展示了一种</span><span style="color:#800000;"><strong>自监督</strong></span><span style="color:#000000;">的方法 可以学习从未标记的数据中 </span><span style="color:#800000;"><strong>使用任何形式的遮挡</strong></span><span style="color:#000000;"> 来估计光流。本文的工作基于</span><span style="color:#800000;">从非遮挡像素中提取可靠的流估计</span><span style="color:#000000;">，</span><span style="color:#800000;">并使用这些预测 来指导遮挡的光流学习</span><span style="color:#000000;">。图 1 说明了本文通过 </span><span style="color:#000000;"><strong>扰动超像素</strong></span><span style="color:#000000;"> 来创建合成遮挡的想法。本文进一步 </span><span style="color:#000000;"><strong>利用 来自多个帧的时间信息</strong></span><span style="color:#000000;"> 来提高简单 CNN 架构中的流预测精度。由此产生的学习方法在 Sintel 和 KITTI 基准上的所有无监督光流学习方法中产生了最高的准确性。 </span></span></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">图1：首先用经典的</span><span style="color:#000000;"><strong>光度损失</strong></span><span style="color:#000000;">（测量参考图像（a）和扭曲的目标图像（d）之间的差异）训练我们的 NOC 模型，</span><span style="color:#800000;">由遮挡图（g）引导。</span><span style="color:#000000;">然后 </span><span style="color:#800000;">扰动目标图像（b）中随机选择的超像素</span><span style="color:#000000;"> 以产生幻觉遮挡。最后，使用来自NOC 模型的可靠流估计来</span><span style="color:#800000;"><strong>指导</strong></span><span style="color:#000000;"> OCC 模型学习那些</span><span style="color:#800000;"><strong>新被遮挡的像素</strong></span><span style="color:#000000;">（由自监督掩码 (i) 表示，其中值 1 表示像素在 (g )中未遮挡 但在 (h) 中被遮挡。请注意，黄色区域是移动狗的一部分。我们的自监督方法</span><span style="color:#800000;"><strong>学习运动物体和静态场景的光流</strong></span><span style="color:#000000;">。 </span></span></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">Selflow是监督学习方法</span><span style="color:#000000;"><strong>第一次</strong></span><span style="color:#000000;">在不使用任何外部标记数据的情况下实现如此出色的准确性。 </span></span></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#800000;"><strong>Related Work</strong></span><span style="color:#000000;">：</span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;"><strong>经典的光流估计</strong></span><span style="color:#000000;">：</span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">        </span><span style="color:#000000;">经典变分方法将光流估计建模为 基于亮度恒定性和空间平滑度的</span><span style="color:#800000;"><strong>能量最小化问题</strong></span><span style="color:#000000;">。这种方法 </span><span style="color:#000000;"><strong>对小运动有效</strong></span><span style="color:#000000;">，但当位移很大时往往会失败 。后来的工作集成了特征匹配以初始化稀疏匹配，然后以金字塔粗到细的方式插入密集流图 [6, 47, 38]。</span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">        </span><span style="color:#000000;">最近的工作使用卷积神经网络 (CNN) 通过学习有效的特征嵌入来改进稀疏匹配 [49, 2]。然而，这些方法通常</span><span style="color:#800000;">计算成本高</span><span style="color:#000000;">，并且无法进行端到端的训练。</span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">        </span><span style="color:#000000;">提高流估计的鲁棒性和准确性的一种自然扩展是</span><span style="color:#800000;"><strong>在多个帧上合并时间信息</strong></span><span style="color:#000000;">。一种直接的方法是</span><span style="color:#000000;"><strong>添加时间上的约束</strong></span><span style="color:#000000;"> ，例如恒定速度、恒定加速度、低维线性子空间 或刚性/非刚性分割。</span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">        </span><span style="color:#000000;">但本文的方法要简单得多，并且不依赖于任何数据假设。Selflow直接为数据中 存在更广泛的具有挑战性的案例 学习光流。 </span></span></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;"><strong>光流的监督学习</strong></span><span style="color:#000000;">：使用 CNN 学习光流</span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">        </span><span style="color:#000000;">FlowNet 是</span><span style="color:#800000;">第一个端到端的</span><span style="color:#000000;">光流学习框架。它以两个连续的图像作为输入并输出一个密集的流图。 FlowNet 2.0堆叠了几个基本的 FlowNet 模型进行迭代细化，并显著提高了准确性。 </span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">        </span><span style="color:#000000;">SpyNet 建议</span><span style="color:#800000;">在多个尺度上</span><span style="color:#000000;"><strong>扭曲图像</strong></span><span style="color:#000000;">以应对大位移，从而形成紧凑的空间金字塔网络。 </span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">        </span><span style="color:#000000;">PWC-Net和 LiteFlowNet提出 扭曲 从 CNN 中提取的特征，并通过 </span><span style="color:#800000;">轻量级框架</span><span style="color:#000000;"> 实现最先进的结果。然而，使用这些 CNN 获得高精度 需要对多个合成数据集进行预训练 并遵循特定的训练计划。</span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">        </span><span style="color:#000000;">本文</span><span style="color:#000000;"><strong>减少了对合成数据预训练的依赖</strong></span><span style="color:#000000;">，并提出了一种有效的未标记数据的自监督训练方法。 </span></span></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;"><strong>无监督光流学习：</strong></span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">基于亮度恒定性和空间平滑度的基本原理 计算得到常用的</span><span style="color:#800000;"><strong>光度损失</strong></span><span style="color:#000000;">，其 </span><span style="color:#000000;"><strong>测量参考图像和扭曲图像之间的差异</strong></span><span style="color:#000000;">。但是，这种损失</span><span style="color:#800000;">不适用于被遮挡的像素</span><span style="color:#000000;">。</span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">最近的研究建议 首先获得一个遮挡图，然后 </span><span style="color:#000000;"><strong>在计算光度差时 排除那些被遮挡的像素</strong></span><span style="color:#000000;">。[18] 介绍了使用多帧公式和更先进的遮挡推理来估计光流，实现了最先进的无监督结果。DDFlow [26] 提出了一种数据蒸馏方法来学习被遮挡像素的光流，这对于 </span><span style="color:#800000;"><strong>靠近图像边界的像素 特别有效</strong></span><span style="color:#000000;">。</span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">所有这些无监督学习方法都只处理被遮挡像素的特定情况，</span><span style="color:#000000;"><strong>缺乏推理</strong></span><span style="color:#000000;"> 所有可能被遮挡像素的光流的能力。本文通过 </span><span style="color:#800000;"><strong>基于超像素的遮挡幻觉技术</strong></span><span style="color:#000000;"> 解决了这个问题。</span></span></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;"><strong>自监督学习</strong></span><span style="color:#000000;">：</span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">监督信号纯粹是从数据本身生成的，被广泛用于从未标记的数据中学习特征表示。通常采用前置任务，例如图像修复、图像着色、解决拼图游戏。 [33] 建议探索基于运动的低级线索，以在没有人工监督的情况下学习特征表示。[9] 结合多个自监督学习任务来训练单个视觉表示。</span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">本文</span><span style="color:#000000;"><strong>利用光流的领域知识</strong></span><span style="color:#000000;">，</span><span style="color:#800000;">将非遮挡像素的可靠预测作为自监督信号来指导对遮挡像素的光流学习</span><span style="color:#000000;">。 </span></span></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">Method：</span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">本文训练了两个具有相同网络架构的 CNN（</span><span style="color:#800000;"><strong>NOC-Model 和 OCC-Model</strong></span><span style="color:#000000;">）。</span><span style="color:#800000;"><strong>NOC-Model</strong></span><span style="color:#000000;">专注于对非遮挡像素的准确流估计，</span><span style="color:#800000;"><strong>OCC-Model</strong></span><span style="color:#000000;">学习预测所有像素的光流。</span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">本文 </span><span style="color:#800000;">从 NOC-Model 中提取可靠的非遮挡流估计来指导 OCC-Model 对那些遮挡像素的学习</span><span style="color:#000000;">。测试时只需要 OCC 模型。本文基于 PWC-Net 构建网络，并进一步将其扩展到多帧光流估计（图 2）。</span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">在获得光流后，使用 Spatial Transformer Network 向后扭曲目标图像以重建参考图像。用 Oi→j 来表示从 Ii 到 Ij 的</span><span style="color:#000000;"><strong>遮挡图</strong></span><span style="color:#000000;">，其中值 1 表示 Ii 中的像素在 Ij 中不可见。  </span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">本文通过 </span><span style="color:#800000;"><strong>在超像素上注入随机噪声</strong></span><span style="color:#000000;"> 以</span><span style="color:#000000;"><strong>生成遮挡</strong></span><span style="color:#000000;">来创建新的目标图像 ~It+1。可以向三个连续帧中的任何一个甚至多个连续帧注入噪声，如图 1 所示。 </span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">图2：在 KITTI 数据集上，遮挡图是稀疏的，仅包含移出图像边界的像素。 </span></span></span> 
</div> 
<div></div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">如图 2 所示，本文的三帧流估计网络结构 建立在两帧 PWC-Net 之上，并进行了一些修改以聚合时间信息。</span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">首先，网络将三幅图像作为输入，从而产生三个特征表示 Ft−1、Ft 和 Ft+1。</span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">然后，除了正向流量 wt→t+1 和正向成本量，网络还同时计算每个级别的反向流量 wt→t-1 和反向成本量。在估计正向流时，我们还利用初始反向流量和反向成本量信息。因为 </span><span style="color:#800000;"><strong>过去的 It-1 帧</strong></span><span style="color:#000000;"> 可以提供非常有价值的信息，特别是对于那些在未来的 It+1 帧中被遮挡但在 It-1 中没有被遮挡的区域。将所有这些信息结合在一起可以更准确地估计光流。</span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">        </span><span style="color:#000000;">第三，叠加初始前向流˙wl t→t+1，负初始后向流−˙wl t+1→t，参考图像F lt 的特征，前向成本量和后向成本量来估计每个级别的前向流。对于后向流量，交换流量和成本量作为输入。前向和后向流估计网络</span><span style="color:#800000;"><strong> 共享相同的网络结构和权重</strong></span><span style="color:#000000;">。 </span></span></span> 
</div> 
<div> 
 <span style="color:#000000;"><span style="background-color:#ffffff;"><span style="color:#000000;">       </span><span style="color:#000000;">对于每个级别的初始流，本文在分辨率和幅度上都提升了下一个级别的光流。 </span></span></span> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6e0a0f080101fec609b7072c026b8352/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">弹性盒最后一个元素靠左显示 而不是居中</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d3cc99193b066e931b171f1cc5cb7c45/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MonoRUn: Monocular 3D Object Detection by Reconstruction and Uncertainty Propagation</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>