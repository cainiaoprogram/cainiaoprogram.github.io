<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>spring的面向切面编程AOP最强解释 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="spring的面向切面编程AOP最强解释" />
<meta property="og:description" content="面向切面编程 AOP 也就是面向横切面编程, 在软件原有流程中横向织入扩展功能代码, 在不改变原有功能的情况下扩展横切功能.
生活中的横切面功能: 面向切面编程解决的横切问题: 面向切面编程中的关键概念: 切面组件通知切入点运行期间织入 1. 切面组件 切面组件本身也是一个被Spring管理的Bean组件, 这个组件用于封装面向切面的功能扩展方法.
在软件中执行切向功能的组件. 是一种&#34;拦截器&#34;组件.
案例:
@Component @Aspect public class DemoAspect { //通知(切入点) 通知&#43;切入点=织入位置 @Before( &#34;execution(* cn.tedu.note.service.*Service.*(..))&#34;) public void hello(){ System.out.println(&#34;Hello World!&#34;); } } 使用如上功能必须导入 AspectJ 相关的包, Spring提供的AOP功能是利用 AspectJ 的API实现的.
&lt;dependency&gt; &lt;groupId&gt;aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjlib&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt; &lt;/dependency&gt; 2. 通知 用于指定发生切向事件的位置点:
通知有如下几种:
@Before @AfterRetuning@AfterThrowing@After@Around 其在方法的切位置关系如下: try{ // @Before 切入点 方法 // @AfterRetuning }catch(e){ // @AfterThrowing }finally{ // @After } @Around 通知, 是在方法前后调用的通知:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/464c0bfb2575efdf45d8f76c89afd2ec/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-12-11T11:11:24+08:00" />
<meta property="article:modified_time" content="2019-12-11T11:11:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">spring的面向切面编程AOP最强解释</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="margin-left:0pt;"> </h2> 
<p> </p> 
<p> </p> 
<h2 style="margin-left:0pt;"><span style="color:#000000;"><strong><span style="color:#000000;"><strong>面向切面编程 AOP</strong></span></strong></span></h2> 
<p style="margin-left:0pt;"><span style="color:#333333;">也就是面向横切面编程, 在软件原有流程中横向织入扩展功能代码, 在不改变原有功能的情况下扩展横切功能.</span></p> 
<h4 style="margin-left:0pt;"><span style="color:#333333;">生活中的横切面功能:</span></h4> 
<p style="margin-left:0pt;"><img alt="" class="has" height="511" src="https://images2.imgbox.com/45/93/UAYChSAj_o.png" width="1028"></p> 
<h4 style="margin-left:0pt;"><span style="color:#333333;">面向切面编程解决的横切问题:</span></h4> 
<p style="margin-left:0pt;"><img alt="" class="has" height="469" src="https://images2.imgbox.com/06/fd/JE25YKwX_o.png" width="831"></p> 
<h4 style="margin-left:0pt;"><span style="color:#333333;">面向切面编程中的关键概念:</span></h4> 
<ol><li><span style="color:#333333;">切面组件</span></li><li><span style="color:#333333;">通知</span></li><li><span style="color:#333333;">切入点</span></li><li><span style="color:#333333;">运行期间织入</span></li></ol> 
<h3 style="margin-left:0pt;"><span style="color:#000000;"><strong><span style="color:#000000;"><strong>1. 切面组件</strong></span></strong></span></h3> 
<p style="margin-left:0pt;"><span style="color:#333333;">切面组件本身也是一个被Spring管理的Bean组件, 这个组件用于封装面向切面的功能扩展方法.</span></p> 
<p style="margin-left:0pt;"><span style="color:#333333;">在软件中执行切向功能的组件. 是一种"拦截器"组件.</span></p> 
<p style="margin-left:0pt;"><span style="color:#333333;">案例:</span></p> 
<pre class="has"><code class="language-java">@Component
@Aspect
public class DemoAspect {

    //通知(切入点) 通知+切入点=织入位置
    @Before(
    "execution(* cn.tedu.note.service.*Service.*(..))")
    public void hello(){
        System.out.println("Hello World!");
    }
}</code></pre> 
<p style="margin-left:0pt;"><span style="color:#333333;">使用如上功能必须导入 AspectJ 相关的包, Spring提供的AOP功能是利用 AspectJ 的API实现的.</span></p> 
<pre class="has"><code class="language-java">    &lt;dependency&gt;
        &lt;groupId&gt;aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjlib&lt;/artifactId&gt;
        &lt;version&gt;1.5.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;aspectj&lt;/groupId&gt;
        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;
        &lt;version&gt;1.5.3&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;cglib&lt;/groupId&gt;
        &lt;artifactId&gt;cglib&lt;/artifactId&gt;
        &lt;version&gt;2.2.2&lt;/version&gt;
    &lt;/dependency&gt;</code></pre> 
<h3 style="margin-left:0pt;"><span style="color:#000000;"><strong><span style="color:#000000;"><strong>2. 通知</strong></span></strong></span></h3> 
<p style="margin-left:0pt;"><span style="color:#333333;">用于指定发生切向事件的位置点:</span></p> 
<p style="margin-left:0pt;"><span style="color:#333333;">通知有如下几种:</span></p> 
<ul><li><span style="color:#333333;">@Before </span></li><li><span style="color:#333333;">@AfterRetuning</span></li><li><span style="color:#333333;">@AfterThrowing</span></li><li><span style="color:#333333;">@After</span></li><li><span style="color:#333333;">@Around</span></li></ul> 
<p style="margin-left:0pt;"><span style="color:#333333;">其在方法的切位置关系如下: </span></p> 
<pre class="has"><code class="language-java">try{
    // @Before 
    切入点 方法
    // @AfterRetuning
}catch(e){
    // @AfterThrowing
}finally{
    // @After
}</code></pre> 
<p><img alt="" class="has" height="431" src="https://images2.imgbox.com/f1/ef/n8SE4Jcz_o.png" width="760"></p> 
<p style="margin-left:0pt;"><span style="color:#333333;">@Around 通知, 是在方法前后调用的通知:</span></p> 
<pre class="has"><code class="language-java">@Around("bean(userService)")
public Object testAround(
        ProceedingJoinPoint target)
    throws Throwable{
    System.out.println("调用开始");
    //执行目标方法
    Object obj=target.proceed();
    System.out.println("调用结束");
    return obj;
}</code></pre> 
<h3 style="margin-left:0pt;"><span style="color:#000000;"><strong><span style="color:#000000;"><strong>3. 切入点</strong></span></strong></span></h3> 
<p style="margin-left:0pt;"><span style="color:#333333;">切入点是指明 通知发送的位置.</span></p> 
<p style="margin-left:0pt;"><span style="color:#333333;">仅仅指定通知是不能精确定位 切面 的织入位置, 还要在通知中指定切入点. </span></p> 
<h4 style="margin-left:0pt;"><span style="color:#f33b45;">有3种：</span></h4> 
<p><strong><span style="color:#333333;"><strong>3.1：Bean组件切入 (按照Bean对象进行切入)</strong></span></strong></p> 
<pre class="has"><code class="language-java">bean(beanId) 
如: bean(userService)  
    bean(noteService)
    bean(*Service)

多个Bean
    bean(userService) || bean(noteService)</code></pre> 
<h4 style="margin-left:0pt;"><strong><span style="color:#333333;"><strong>3.2：类限定名: 包和类进行切入</strong></span></strong></h4> 
<pre class="has"><code class="language-java">within(包名.类名)
如:
within(cn.tedu.note.service.UserService)
within(cn.tedu.note.service.*)
within(cn.tedu.note.service.*Service)
within(cn.tedu.note..*Service)</code></pre> 
<h4 style="margin-left:0pt;"><strong><span style="color:#333333;"><strong>3.3方法限定名: 切入到特定方法</strong></span></strong></h4> 
<pre class="has"><code class="language-java">execution(* 包.类.方法(参数))
如:
execution(* cn.tedu.note.service.UserService.login(..))
execution(* cn.tedu.note.service.UserService.find*(..))
execution(* cn.tedu.note.service.*Service.find*(..))
execution(* cn.tedu.note.service.*.find*(..))
execution(* cn.tedu.note..*.find*(..))
execution(* cn.tedu.note.service.*.*(..))</code></pre> 
<h4 style="margin-left:0pt;"><strong><span style="color:#333333;"><strong>织入位置</strong></span></strong></h4> 
<p style="margin-left:0pt;"><span style="color:#333333;">通过通知和切入点的组合,才能明确指定切面代码的位置, 也就是: </span></p> 
<p style="margin-left:0pt;"><span style="color:#f33b45;">通知+切入点=织入位置</span></p> 
<hr> 
<hr> 
<h2 style="margin-left:0pt;"><span style="color:#000000;"><strong><span style="color:#000000;"><strong>AOP 的配置</strong></span></strong></span></h2> 
<p><span style="color:#333333;">AOP注解必须与Spring配合才能起到作用, Spring的配置如下:</span></p> 
<pre class="has"><code class="language-java"> &lt;context:component-scan 
    base-package="cn.tedu.aop"/&gt;
 &lt;!-- 注解驱动 aspectj AOP,
    使 @Aspect 和 @Before 等注解起作用  --&gt;
 &lt;aop:aspectj-autoproxy /&gt;

</code></pre> 
<p><span style="color:#333333;">案例:</span></p> 
<pre class="has"><code class="language-java">@Component
@Aspect
public class DemoAspect {

    //通知(切入点) 通知+切入点=织入位置
    @Before("execution(* cn.tedu.note.service.*Service.*(..))")
    public void hello(){
        System.out.println("Hello World!");
    }

    @Around("bean(userService)")
    public Object testAround( ProceedingJoinPoint target)
        throws Throwable{
        System.out.println("调用开始");
        //执行目标方法
        Object obj=target.proceed();
        System.out.println("调用结束");
        return obj;
    }
}</code></pre> 
<p><span style="color:#777777;">测试结果说明: 如上代码在执行时候, 会在所有的业务层方法中织入 hello() 方法, 也就是在所有业务方法之前执行 hello(). </span></p> 
<p> </p> 
<p><span style="color:#000000;"><strong><span style="color:#000000;"><strong>AOP 是如何做到的：</strong></span></strong></span></p> 
<ol><li><span style="color:#333333;">采用动态代理模式实现.</span></li><li><span style="color:#333333;">动态代理是利用反射技术实现的.</span></li></ol> 
<p><span style="color:#000000;"><strong><span style="color:#000000;"><strong>代理模式:</strong></span></strong></span></p> 
<p><img alt="" class="has" height="385" src="https://images2.imgbox.com/14/03/aMDfsfM1_o.png" width="882"></p> 
<p> </p> 
<p style="margin-left:0pt;"><span style="color:#333333;">案例:</span></p> 
<pre class="has"><code class="language-java">@Component("userServiceProxy")
public class UserServiceProxy 
    implements UserService{

    @Autowired
    DemoAspect demoAspect;

    @Autowired 
    UserService target;

    public User login(String name, String password) throws NameOrPasswordException {
        //调用切面组件的方法?
        demoAspect.hello();
        System.out.println("Hello Proxy");
        return target.login(name, password);
    }
    public User regist(String name, String nick, String password, String confirm) {
        System.out.println("Hello Proxy");
        return target.regist(name, nick, password, confirm);
    }
}</code></pre> 
<p style="margin-left:0pt;"><span style="color:#777777;">如上类就是一个静态代理类, 代理的业务层UserService的方法.</span></p> 
<p style="margin-left:0pt;"> </p> 
<h3 style="margin-left:0pt;"><span style="color:#000000;"><strong><span style="color:#000000;"><strong>动态代理技术</strong></span></strong></span></h3> 
<ol><li><span style="color:#333333;">JDK 的反射API提供了动态代理 </span> 
  <ul><li><span style="color:#333333;">JDK的动态代理必须依赖于接口</span></li></ul></li><li><span style="color:#333333;">CBLIB API 提供了基于类的动态代理</span></li><li><span style="color:#333333;">Spring会自动的使用如上API, 在有接口时候 优先选JDK代理, 如果没有接口,会自动利用CGLIB代理.</span></li></ol> 
<p style="margin-left:0pt;"><span style="color:#777777;">        Spring的AOP底层就是利用动态代理技术实现的.</span></p> 
<p style="margin-left:0pt;"><span style="color:#777777;">        提示: 可以查看异常出现时候的方法调用栈, 来了解Spring内部的调用关系:</span></p> 
<p style="margin-left:0pt;"><span style="color:#333333;">如:</span></p> 
<pre class="has"><code class="language-java">java.lang.NullPointerException
    at cn.tedu.note.service.NoteServiceImpl.createNote(NoteServiceImpl.java:76)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:497)
    at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:317)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.invokeJoinpoint(ReflectiveMethodInvocation.java:183)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:150)
    at org.springframework.aop.framework.adapter.MethodBeforeAdviceInterceptor.invoke(MethodBeforeAdviceInterceptor.java:51)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
    at org.springframework.transaction.interceptor.TransactionInterceptor$1.proceedWithInvocation(TransactionInterceptor.java:96)
    at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:260)
    at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:94)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
    at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:91)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
    at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:204)
    at com.sun.proxy.$Proxy24.createNote(Unknown Source)
    at cn.tedu.note.web.NoteController.addNote(NoteController.java:58)
    at cn.tedu.note.web.NoteController$$FastClassBySpringCGLIB$$fb9c5e1b.invoke(&lt;generated&gt;)
    at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:204)
    at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:700)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:150)
    at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:80)
    at cn.tedu.aop.ExceptionAspect.process(ExceptionAspect.java:21)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:497)
    at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:621)
    at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:610)
    at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:65)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
    at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:91)
    at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:172)
    at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:633)
    at cn.tedu.note.web.NoteController$$EnhancerBySpringCGLIB$$d281c6f4.addNote(&lt;generated&gt;)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:497)
    at org.springframework.web.method.support.InvocableHandlerMethod.invoke(InvocableHandlerMethod.java:215)
    at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:132)
    at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:104)
    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:745)
    at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:686)
    at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:80)
    at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:925)
    at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:856)
    at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:953)
    at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:855)
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:650)
    at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:829)
    at javax.servlet.http.HttpServlet.service(HttpServlet.java:731)
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:303)
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)
    at org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)
    at cn.tedu.note.util.AccessFilter.checkdo(AccessFilter.java:66)
    at cn.tedu.note.util.AccessFilter.doFilter(AccessFilter.java:45)
    at org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:241)
    at org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:208)
    at org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:220)
    at org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:122)
    at org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:505)
    at org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:169)
    at org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:103)
    at org.apache.catalina.valves.AccessLogValve.invoke(AccessLogValve.java:956)
    at org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:116)
    at org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:423)
    at org.apache.coyote.http11.AbstractHttp11Processor.process(AbstractHttp11Processor.java:1079)
    at org.apache.coyote.AbstractProtocol$AbstractConnectionHandler.process(AbstractProtocol.java:625)
    at org.apache.tomcat.util.net.JIoEndpoint$SocketProcessor.run(JIoEndpoint.java:318)
    at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
    at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
    at org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)
    at java.lang.Thread.run(Thread.java:745)</code></pre> 
<h3 style="margin-left:0pt;"><span style="color:#000000;"><strong><span style="color:#000000;"><strong>Spring事务处理</strong></span></strong></span></h3> 
<p style="margin-left:0pt;"><span style="color:#333333;">关键特性: ACID</span></p> 
<ul><li><span style="color:#333333;">A 原子性</span></li><li><span style="color:#333333;">C 一致性</span></li><li><span style="color:#333333;">I 隔离性</span></li><li><span style="color:#333333;">D 持久性</span></li></ul> 
<p style="margin-left:0pt;"><span style="color:#333333;">Oracle 支持ACID</span></p> 
<p style="margin-left:0pt;"><span style="color:#333333;">MySQL 有两种数据库引擎: </span></p> 
<ul><li><span style="color:#333333;">MyISAM 引擎 不支持 ACID, 适合数据一致性要求不高,性能好就行</span></li><li><span style="color:#333333;">INNODB 引擎 支持ACID, 适合数据一致性高的场合.</span></li></ul> 
<h3><span style="color:#000000;"><strong><span style="color:#000000;"><strong>编程式事务控制:</strong></span></strong></span></h3> 
<p><span style="color:#333333;">经典代码</span></p> 
<pre class="has"><code class="language-java">try{
    开启事务
    业务处理.
    业务处理.
    提交事务
}catch(e){
    回滚事务
}finally{
    回收资源
}</code></pre> 
<p><span style="color:#333333;">很明显, 编程式事务处理, 非常适合替换为AOP事务处理:</span></p> 
<p><img alt="" class="has" height="352" src="https://images2.imgbox.com/bb/4d/eX2vVBgZ_o.png" width="777"></p> 
<p><span style="color:#333333;">Spring 事务处理, 是AOP的经典用途. Spring的事务处理底层就是AOP.</span></p> 
<h3><span style="color:#000000;"><strong><span style="color:#000000;"><strong>使用Spring 事务</strong></span></strong></span></h3> 
<p style="margin-left:0pt;"><span style="color:#333333;">使用Spring 事务 并不需要AOP编程, 只需要使用注解即可</span></p> 
<p style="margin-left:0pt;"><span style="color:#333333;">配置:</span></p> 
<pre class="has"><code class="language-java">&lt;!-- 添加 注解事务支持 --&gt;
&lt;bean id="txManager" 
    class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
    &lt;property name="dataSource" 
        ref="dataSource" /&gt;
&lt;/bean&gt;
&lt;tx:annotation-driven
    transaction-manager="txManager"/&gt;</code></pre> 
<p style="margin-left:0pt;"><span style="color:#333333;">使用:</span></p> 
<pre class="has"><code class="language-java">@Transactional(readOnly=true,
        isolation=Isolation.READ_COMMITTED,
        propagation=Propagation.REQUIRED)
public Note loadNote(String noteId) {
    if(noteId==null || noteId.trim().isEmpty()){
        throw new IllegalArgumentException("noteId不能空");
    }
    return noteDao.findNoteById(noteId);
}</code></pre> 
<p style="margin-left:0pt;"> </p> 
<p style="margin-left:0pt;"> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f5d44611244e088b73c905b4d50b1656/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Java】- Incompatible types. Found: java. lang. String&#39;, required:&#39; byte, char, short or int&#39;</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0b17bbf8cd8815063363ceca36707a71/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MVG（second）学习笔记- 摄像机模型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>