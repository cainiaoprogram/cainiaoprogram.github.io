<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据结构与算法教程，数据结构C语言版教程！（第二部分、线性表详解：数据结构线性表10分钟入门）九 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据结构与算法教程，数据结构C语言版教程！（第二部分、线性表详解：数据结构线性表10分钟入门）九" />
<meta property="og:description" content="第二部分、线性表详解：数据结构线性表10分钟入门 线性表，数据结构中最简单的一种存储结构，专门用于存储逻辑关系为&#34;一对一&#34;的数据。
线性表，基于数据在实际物理空间中的存储状态，又可细分为顺序表（顺序存储结构）和链表（链式存储结构）。
本章还会讲解顺序表和链表的结合体——静态链表，不仅如此，还会涉及循环链表、双向链表、双向循环链表等链式存储结构。
十七、如何判断单链表为有环链表？ 循环链表一节，给大家详细地介绍了循环链表。在此基础上，本节带领大家讨论一个问题：如何判断一个单链表中有环？
注意，有环链表并不一定就是循环链表。循环链表指的是“首尾相连”的单链表，而有环链表则指的是单链表中存在一个循环子链表，如图 1 所示。
图 1 有环链表示意图
图 1 所示就是一个有环链表，但并不是循环链表。
那么，如果给定一个单链表，如何判断其是否为有环链表呢？常用的判断方法有如下 2 种。
1) 最直接的实现思想就是：从给定链表的第一个节点开始遍历，每遍历至一个节点，都将其和所有的前驱节点进行比对，如果为同一个节点，则表明当前链表中有环；反之，如果遍历至链表最后一个节点，仍未找到相同的节点，则证明该链表中无环。
注意，如果一个单链表为有环链表，基于单链表中各节点有且仅有 1 个指针域的特性，则势必该链表是没有尾结点的（如图 1 所示）。换句话说，有环链表的遍历过程是无法自行结束的，需要使用 break 语句手动结束遍历。
基于上面的实现思想，下面设计了一个相应的实现函数：
//自定义 bool 类型
typedef enum bool
{
False=0,
True=1
}bool;
// H 为链表的表头
bool HaveRing(link * H) {
link * Htemp = H; /
/存储所遍历节点所有前驱节点的存储地址，64位环境下地址占 8 个字节，所以这里用 long long 类型
long long addr[20] = { 0 };
int length = 0, i = 0;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/622de81a6c69f67dfd465c969383eb54/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-07T08:30:00+08:00" />
<meta property="article:modified_time" content="2024-01-07T08:30:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据结构与算法教程，数据结构C语言版教程！（第二部分、线性表详解：数据结构线性表10分钟入门）九</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2 style="text-align:justify;"> 第二部分、线性表详解：数据结构线性表10分钟入门</h2> 
<p class="img-center"><img alt="" height="120" src="https://images2.imgbox.com/e1/a9/wnXwhcby_o.png" width="178"></p> 
<p style="text-align:justify;">线性表，数据结构中最简单的一种存储结构，<strong>专门用于存储逻辑关系为"一对一"的数据。</strong></p> 
<p style="text-align:justify;">线性表，基于数据在实际物理空间中的存储状态，又可细分为顺序表（顺序存储结构）和链表（链式存储结构）。</p> 
<p style="text-align:justify;">本章还会讲解顺序表和链表的结合体——静态链表，不仅如此，还会涉及循环链表、双向链表、双向循环链表等链式存储结构。</p> 
<h2 style="text-align:justify;"><span style="color:#fe2c24;">十七、如何判断单链表为有环链表？</span></h2> 
<p style="text-align:justify;">循环链表一节，给大家详细地介绍了循环链表。在此基础上，本节带领大家讨论一个问题：如何判断一个单链表中有环？<br><br><span style="color:#fe2c24;"><strong>注意，有环链表并不一定就是循环链表。循环链表指的是“首尾相连”的单链表，而有环链表则指的是单链表中存在一个循环子链表，</strong></span>如图 1 所示。</p> 
<p class="img-center"><img alt="" height="234" src="https://images2.imgbox.com/59/a1/bg6OhSHD_o.gif" width="348"></p> 
<p style="text-align:center;">图 1 有环链表示意图</p> 
<p style="text-align:justify;">图 1 所示就是一个有环链表，但并不是循环链表。<br><br> 那么，如果给定一个单链表，如何判断其是否为有环链表呢？常用的判断方法有如下 2 种。</p> 
<p style="text-align:justify;"><strong>1) 最直接的实现思想就是：</strong>从给定链表的第一个节点开始遍历，每遍历至一个节点，都将其和所有的前驱节点进行比对，如果为同一个节点，则表明当前链表中有环；反之，如果遍历至链表最后一个节点，仍未找到相同的节点，则证明该链表中无环。</p> 
<blockquote> 
 <p style="text-align:justify;">注意，如果一个单链表为有环链表，基于单链表中各节点有且仅有 1 个指针域的特性，则势必该链表是没有尾结点的（如图 1 所示）。换句话说，有环链表的遍历过程是无法自行结束的，需要使用 break 语句手动结束遍历。</p> 
</blockquote> 
<p style="text-align:justify;">基于上面的实现思想，下面设计了一个相应的实现函数：</p> 
<blockquote> 
 <p style="text-align:justify;">//自定义 bool 类型</p> 
 <p style="text-align:justify;">typedef enum bool</p> 
 <p style="text-align:justify;">{<!-- --></p> 
 <p style="text-align:justify;">        False=0,</p> 
 <p style="text-align:justify;">        True=1</p> 
 <p style="text-align:justify;">}bool;</p> 
 <p style="text-align:justify;">// H 为链表的表头</p> 
 <p style="text-align:justify;">bool HaveRing(link * H) {<!-- --></p> 
 <p style="text-align:justify;">        link * Htemp = H; /</p> 
 <p style="text-align:justify;">        /存储所遍历节点所有前驱节点的存储地址，64位环境下地址占 8 个字节，所以这里用         long long 类型</p> 
 <p style="text-align:justify;">        long long addr[20] = { 0 };</p> 
 <p style="text-align:justify;">        int length = 0, i = 0;</p> 
 <p style="text-align:justify;">        //逐个遍历链表中各个节点</p> 
 <p style="text-align:justify;">        while (Htemp) {<!-- --></p> 
 <p style="text-align:justify;">                //依次将 Htemp 和 addr 数组中记录的已遍历的地址进行比对</p> 
 <p style="text-align:justify;">                for (i = 0; i &lt; length; i++) {<!-- --></p> 
 <p style="text-align:justify;">                        //如果比对成功，则证明有环</p> 
 <p style="text-align:justify;">                        if (Htemp == addr[i]) {<!-- --></p> 
 <p style="text-align:justify;">                                return True;</p> 
 <p style="text-align:justify;">                        }</p> 
 <p style="text-align:justify;">                }</p> 
 <p style="text-align:justify;">                //比对不成功，则记录 Htemp 节点的存储地址</p> 
 <p style="text-align:justify;">                addr[length] = Htemp;</p> 
 <p style="text-align:justify;">                length++;</p> 
 <p style="text-align:justify;">                Htemp = Htemp-&gt;next;</p> 
 <p style="text-align:justify;">        }</p> 
 <p style="text-align:justify;">        return False;</p> 
 <p style="text-align:justify;">}</p> 
</blockquote> 
<p style="text-align:justify;">如上所示，<strong><span style="background-color:#a2e043;">当函数的返回值为 True，表示该链表有环；反之若函数返回值为 False，表明链表中无环。</span></strong>显然，此实现方案的时间复杂度为<code>O(<img alt="n^{2}" class="mathcode" src="https://images2.imgbox.com/29/9c/led7Xz17_o.png">)</code>。<br><br> 2) 相比上一种实现方案，<span style="color:#1c7331;"><strong>这里介绍一种时间复杂度为 O(n) 的算法。</strong></span><br><br> 该算法的实现思想需要借助一个论点，即在一个链表中，如果 2 个指针（假设为 H1 和 H2）都从表头开始遍历链表，其中 H1 每次移动 2 个节点的长度（H1 = H1-&gt;next-&gt;next）,而 H2 每次移动 1 个节点的长度（H2 = H2-&gt;next），如果该链表为有环链表，则 H1、H2 最终必定会相等；反之，如果该链表中无环，则 H1、H2 永远不会相遇。</p> 
<blockquote> 
 <p style="text-align:justify;">有关在有环链表中 H1 和 H2 必定会相遇的结论，假设有环链表中的环包含 n 个节点，则第一次遍历，H1 和 H2 相差 1 个节点；第二次遍历，H1 和 H2 相差 2 个节点；第三次遍历，H1 和 H2 相差 3 个节点...，最终经过多次遍历，H1 和 H2 会相差 n-1 个节点，此时就会在环中重合，此时 H1 和 H2 相等。</p> 
</blockquote> 
<p style="text-align:justify;">基于以上这个结论，我们可以轻松编写出对应的实现代码：</p> 
<blockquote> 
 <p style="text-align:justify;">//H为链表的表头，该函数会返回一个枚举的 bool 类型数据</p> 
 <p style="text-align:justify;">bool HaveRing(link * H) {<!-- --></p> 
 <p style="text-align:justify;">        link * H1 = H-&gt;next;</p> 
 <p style="text-align:justify;">        link * H2 = H;</p> 
 <p style="text-align:justify;">        while (H1) {<!-- --></p> 
 <p style="text-align:justify;">                if (H1 == H2) {<!-- --></p> 
 <p style="text-align:justify;">                        //链表中有环</p> 
 <p style="text-align:justify;">                        return True;</p> 
 <p style="text-align:justify;">                } else {<!-- --></p> 
 <p style="text-align:justify;">                        H1 = H1-&gt;next;</p> 
 <p style="text-align:justify;">                        if (!H1) {<!-- --></p> 
 <p style="text-align:justify;">                                //链表中无环</p> 
 <p style="text-align:justify;">                                return False;</p> 
 <p style="text-align:justify;">                        }</p> 
 <p style="text-align:justify;">                         else</p> 
 <p style="text-align:justify;">                         {<!-- --></p> 
 <p style="text-align:justify;">                                H1 = H1-&gt;next;</p> 
 <p style="text-align:justify;">                                H2 = H2-&gt;next;</p> 
 <p style="text-align:justify;">                        }</p> 
 <p style="text-align:justify;">                }</p> 
 <p style="text-align:justify;">        }</p> 
 <p style="text-align:justify;">        //链表中无环</p> 
 <p style="text-align:justify;">        return False;</p> 
 <p style="text-align:justify;">}</p> 
</blockquote> 
<p style="text-align:justify;">和上一种实现代码一样，当函数返回 False 时，表明当前链表中无环；反之若返回 True，则表明该链表为有环链表。和第一种算法相比，本算法的时间复杂度为 O(n)。</p> 
<p style="text-align:justify;"></p> 
<hr> 
<h2 style="text-align:justify;"><span style="color:#fe2c24;"> 十八、双向循环链表（C语言）详解</span></h2> 
<p style="text-align:justify;">我们知道，单链表通过首尾连接可以构成单向循环链表，如图 1 所示：</p> 
<p class="img-center"><img alt="单向循环链表示意图" height="67" src="https://images2.imgbox.com/8a/e2/1RLIWC9d_o.gif" width="400"></p> 
<p style="text-align:center;">图 1 单向循环链表示意图</p> 
<p style="text-align:justify;">同样，双向链表也可以进行首尾连接，构成<strong><span style="color:#1c7331;">双向循环链表</span></strong>。如图 2 所示：</p> 
<p class="img-center"><img alt="双向循环链表示意图" height="75" src="https://images2.imgbox.com/08/e9/qCo76q9B_o.gif" width="400"></p> 
<p style="text-align:center;">图 2 双向循环链表示意图</p> 
<p style="text-align:justify;"><span style="color:#fe2c24;"><strong>当问题中涉及到需要 "循环往复" 地遍历表中数据时，就需要使用双向循环链表。</strong></span>例如，前面章节我们对约瑟夫环问题进行了研究，其实约瑟夫环问题有多种玩法，每次顺时针报数后，下一轮可以逆时针报数，然后再顺时针......一直到剩下最后一个人。解决这个问题就需要使用双向循环链表结构。</p> 
<h3 style="text-align:justify;">双向循环链表的创建</h3> 
<p style="text-align:justify;">创建双向循环链表，<span style="color:#fe2c24;"><strong>只需在创建完成</strong></span><span style="color:#1c7331;"><strong>双向链表的基础上</strong></span><span style="color:#fe2c24;"><strong>，将其首尾节点进行双向连接即可</strong></span>。<br><br> C 语言实现代码如下：</p> 
<blockquote> 
 <p style="text-align:justify;">//创建双向循环链表</p> 
 <p style="text-align:justify;">line* initLine(line * head){<!-- --></p> 
 <p style="text-align:justify;">        head=(line*)malloc(sizeof(line));</p> 
 <p style="text-align:justify;">        head-&gt;prior=NULL;</p> 
 <p style="text-align:justify;">        head-&gt;next=NULL;</p> 
 <p style="text-align:justify;">        head-&gt;data=1;</p> 
 <p style="text-align:justify;">        line * list=head;</p> 
 <p style="text-align:justify;">        for (int i=2; i&lt;=3; i++) {<!-- --></p> 
 <p style="text-align:justify;">                line * body=(line*)malloc(sizeof(line));</p> 
 <p style="text-align:justify;">                body-&gt;prior=NULL;</p> 
 <p style="text-align:justify;">                body-&gt;next=NULL;</p> 
 <p style="text-align:justify;">                body-&gt;data=i;</p> 
 <p style="text-align:justify;"></p> 
 <p style="text-align:justify;">                list-&gt;next=body;</p> 
 <p style="text-align:justify;">                body-&gt;prior=list;</p> 
 <p style="text-align:justify;">                list=list-&gt;next;</p> 
 <p style="text-align:justify;">        }</p> 
 <p style="text-align:justify;">        //通过以上代码，已经创建好双线链表，接下来将链表的首尾节点进行双向连接</p> 
 <p style="text-align:justify;">        list-&gt;next=head;</p> 
 <p style="text-align:justify;">        head-&gt;prior=list;</p> 
 <p style="text-align:justify;">        return head;</p> 
 <p style="text-align:justify;">}</p> 
</blockquote> 
<p style="text-align:justify;">通过向 main 函数中调用 initLine 函数，就可以成功创建一个存储有<strong><span style="background-color:#a2e043;"> </span><code><span style="background-color:#a2e043;">{1,2,3}</span></code></strong> 数据的双向循环链表，其完整的 C 语言实现代码为：</p> 
<blockquote> 
 <p style="text-align:justify;">#include &lt;stdio.h&gt;</p> 
 <p style="text-align:justify;">#include &lt;stdlib.h&gt;</p> 
 <p style="text-align:justify;">typedef struct line{<!-- --></p> 
 <p style="text-align:justify;">        struct line * prior;</p> 
 <p style="text-align:justify;">        int data;</p> 
 <p style="text-align:justify;">        struct line * next;</p> 
 <p style="text-align:justify;">}line;</p> 
 <p style="text-align:justify;"></p> 
 <p style="text-align:justify;">line* initLine(line * head);</p> 
 <p style="text-align:justify;">void display(line * head);</p> 
 <p style="text-align:justify;">int main() {<!-- --></p> 
 <p style="text-align:justify;">        line * head=NULL;</p> 
 <p style="text-align:justify;">        head=initLine(head);</p> 
 <p style="text-align:justify;">        display(head);</p> 
 <p style="text-align:justify;">        return 0;</p> 
 <p style="text-align:justify;">}</p> 
 <p style="text-align:justify;">//创建双向循环链表</p> 
 <p style="text-align:justify;">line* initLine(line * head){<!-- --></p> 
 <p style="text-align:justify;">        head=(line*)malloc(sizeof(line));</p> 
 <p style="text-align:justify;">        head-&gt;prior=NULL;</p> 
 <p style="text-align:justify;">        head-&gt;next=NULL;</p> 
 <p style="text-align:justify;">        head-&gt;data=1;</p> 
 <p style="text-align:justify;">        line * list=head;</p> 
 <p style="text-align:justify;">        for (int i=2; i&lt;=3; i++) {<!-- --></p> 
 <p style="text-align:justify;">                line * body=(line*)malloc(sizeof(line));</p> 
 <p style="text-align:justify;">                body-&gt;prior=NULL;</p> 
 <p style="text-align:justify;">                body-&gt;next=NULL;</p> 
 <p style="text-align:justify;">                body-&gt;data=i;</p> 
 <p style="text-align:justify;"></p> 
 <p style="text-align:justify;">                list-&gt;next=body;</p> 
 <p style="text-align:justify;">                body-&gt;prior=list;</p> 
 <p style="text-align:justify;">                 list=list-&gt;next;</p> 
 <p style="text-align:justify;">        }</p> 
 <p style="text-align:justify;">         //通过以上代码，已经创建好双线链表，接下来将链表的首尾节点进行双向连接</p> 
 <p style="text-align:justify;">         list-&gt;next=head;</p> 
 <p style="text-align:justify;">         head-&gt;prior=list;</p> 
 <p style="text-align:justify;">         return head;</p> 
 <p style="text-align:justify;">}</p> 
 <p style="text-align:justify;"></p> 
 <p style="text-align:justify;">//输出链表的功能函数</p> 
 <p style="text-align:justify;">void display(line * head){ l</p> 
 <p style="text-align:justify;">        ine * temp=head;</p> 
 <p style="text-align:justify;">        //由于是循环链表，所以当遍历指针temp指向的下一个节点是head时，证明此时已经循环至链表的最后一个节点</p> 
 <p style="text-align:justify;">        while (temp-&gt;next!=head) {<!-- --></p> 
 <p style="text-align:justify;">                 if (temp-&gt;next==NULL) {<!-- --></p> 
 <p style="text-align:justify;">                         printf("%d\n",temp-&gt;data);</p> 
 <p style="text-align:justify;">                 }else{<!-- --></p> 
 <p style="text-align:justify;">                         printf("%d-&gt;",temp-&gt;data);</p> 
 <p style="text-align:justify;">                 }</p> 
 <p style="text-align:justify;">                 temp=temp-&gt;next;</p> 
 <p style="text-align:justify;">         }</p> 
 <p style="text-align:justify;">         //输出循环链表中最后一个节点的值</p> 
 <p style="text-align:justify;">         printf("%d",temp-&gt;data);</p> 
 <p style="text-align:justify;">}</p> 
</blockquote> 
<p style="text-align:justify;">程序输出结果如下：</p> 
<blockquote> 
 <p style="text-align:justify;">1-&gt;2-&gt;3</p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/050f63ae1340dc2d9816ec1080ac54ea/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">vue,小程序,uni-app的生命周期?</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d1345206fcb33f58ab316a5c6a446ff0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用什么实现跨域的？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>