<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>下MFC中对象、句柄、ID之间的区别. - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="下MFC中对象、句柄、ID之间的区别." />
<meta property="og:description" content="Windows程序中，有各种各样的资源（窗口、图标、光标），系统在创建这些资源的时候会为他们分配内存，并返回标识这些资源的标识号，即句柄HANDLE（ID）。图标句柄（HICON）、光标句柄（HCURSOR）、画刷句柄（HBRUSH）。
为什么有个窗口对象还要窗口句柄呢？还有什么线程句柄，甚至还有控件ID和进程ID呢？MFC中的对象，比如应用程序对象，视图对象等，是对象就会占用内存空间，我们就可以用指针指向此对象进行访问，但windows还提供了句柄访问，初看好像有点多余，实则不然。如果我们一个进程想访问另一个进程，根据对象指针访问就不行了。我们现在的Windows是一个完全保护的系统，应用程序工作于CPU的保护模式下，引入了虚存技术。每个进程拥有独立的4GB的地址空间，所以在应用程序中的地址是自己眼中的地址，不具有通用性。那么两个进程就不能简单地传个地址就行了，窗体句柄就是windows内核的一种数据结构，不同窗体（可以是不同进程的不同窗体）有不同的窗体句柄，windows通过句柄可以识别不同的窗体对象。那么进程句柄也是全局唯一的么？非也！进程句柄也是在本进程内有效，由创建进程或者打开进程时得到的句柄。进程ID才是全局唯一的。那么控件ID是全局唯一的么？也不是！控件ID代表一个资源，很多时候就是代表一个资源所在的路径及资源名
句柄到底是什么东东呢，指针呢？
其实，句柄并没有什么神奇之处，不管哪种句柄，实际都是一个整数。它标识一种资源，如窗口、位图等等。就象你找一个人，必须知道它的地址一样，如果你要操作一种资源，必须先获得句柄。“取窗口句柄（）”并不是只能取出窗口的句柄，所有窗口控件，如编辑框、标签等都可以用本命令取出自己的句柄，如：编辑框1.取窗口句柄（）或标签1.取窗口句柄（）。控件的句柄同样，任何控件都有它自身的特有属性，句柄也就指它的特有属性（包括共性）。
句柄英文译作HANDLE，HANDLE的本意是把柄，把手的意思，是与操作系统打交道的东东。有人举过比较通俗的例子：你考上了大学，入学后，学校（操作系统）会给你一个学生证号。注意，这个号码是学校指定的，你无法自选。有了这个号码（学生证，假设一证多用）享受学校提供的服务：如你就可以去图书馆借书，去食堂吃饭，去教室上课等 等。但你不能到食堂里买啤酒，因为学校不允许这种服务。而在计算机中系统提供的服务就是API调用了。当你有了HANDLE，就可以理直气壮地向系统提出调用API的服务。而指针的权力就大多了，有了指针你可以到处去喝酒，打架，学校（操作系统）管不着，所以句柄和指针的区别在于句柄只能调用系统提供的服务。而句柄虽然是一个能相互区别的号码，但与我们普通的ID号又有区别，普通的ID号是可以由程序员自己定义的，而句柄不行，它是对象生成时系统指定的，是为了区别系统中存在的各个对象，这个句柄不是由程序员赋给的。
可以引用csdn上一个人的话来说明句柄，指针对象实例之间的关系：
牧童遥指杏花村。牧童的手为指针，杏花村的牌子为句柄，杏花村酒店为对象的实例。
深入探讨句柄
更透彻的说，句柄是一种指向指针的指针。大家都知道，所谓指针是一种内存地址。应用程序启动后，组成这个程序的各对象是住留在内存的。如果简单地理解，似乎我们只要获知这个内存的首地址，那么就可以随时用这个地址访问对象。但是，如果您真的这样认为，那么您就大错特错了。我们知道，Windows是一个以虚拟内存为基础的操作系统。在这种系统环境 下，Windows内存管理器经常在内存中来回移动对象，依此来满足各种应用程序的内存需要。对象被移动意味着它的地址变化了。如果地址总是如此变化，我们该到哪里去找该对象呢? 为了解决这个问题，Windows操作系统为各应用程序腾出一些内存储地址，用来专门登记各应用对象在内存中的地址变化，而这个地址(存储单元的位置)本 身是不变的。Windows内存管理器在移动对象在内存中的位置后，把对象新的地址告知这个句柄地址来保存。这样我们只需记住这个句柄地址就可以间接地知道对象具体在内存中的哪个位置。这个地址是在对象装载(Load)时由系统分配给的，当系统卸载时(Unload)又释放给系统。句柄地址(稳定) ─→记载着对象在内存中的地址─→对象在内存中的地址(不稳定) ─→实际对象 本质：WINDOWS程序中并不是用物理地址来标识一个内存块，文件，任务或动态装入模块的，相反的，WINDOWS API给这些项目分配确定的句柄，并将句柄返回给应用程序，然后通过句柄来进行操作。 但是必须注意的是程序每次从新启动，系统不能保证分配给这个程序的句柄还是原来的那个句柄，而且绝大多数情况的确不一样的。假如我们把进入电影院看电影看 成是一个应用程序的启动运行，那么系统给应用程序分配的句柄总是不一样，这和每次电影院售给我们的门票总是不同的一个座位是一样的道理。
MFC _窗口ID，句柄，指针三者相互转换函数
ID--HANDLE--HWND三者之间的互相转换
id-&gt;句柄 hWnd = ::GetDlgItem(hParentWnd,id);
id-&gt;指针 CWnd::GetDlgItem();
句柄-&gt;id id = GetWindowLong(hWnd,GWL_ID);
句柄-&gt;指针 CWnd *pWnd=CWnd::FromHandle(hWnd);
指针-&gt;ID id = GetWindowLong(pWnd-&gt;GetSafeHwnd,GWL_ID);
GetDlgCtrlID();
指针-&gt;句柄 hWnd=cWnd.GetSafeHandle() or mywnd-&gt;m_hWnd; 指针的使用在编程过程中至关重要，恰到好处并能正确无误的使用指针不但能够提高程序自身的运行效率，而且有助于节省程序执行所需要消耗的资源。指针对应着某个数据在内存空间中的地址，得到了指针就可以自由地修改该数据。句柄代表指针的“指针”，也可以将其比作表中数据项的索引值( 表对应某个进程自身的内存空间 )。句柄是间接的引用对象。
指针和句柄的不同之处：
句柄所指的可以是一个很复杂的结构，并且很有可能与系统有关的，比如上面所说线程的句柄，它指向的就是一个类或者结构，它和系统有很密切的关系。当一个线程由于不可预料的原因而终止时，系统就可以通过句柄来回收它所占用的资料，如CPU，内存等等。反过来想，这些句柄中的某一些，是与系统进行交互用的。
指针它也可以指向一个复杂的结构，但通常是由用户自我定义的，所以一些必需的工作都要由用户自己完成，特别是在删除的时候。
另外需要注意的是句柄往往有自己的存在区限，比如一个进程，如果将其传递到另一个进程中，句柄也就失去了意义( 表中数据项的索引值，索引离开了具体的表也就失去了意义 )。
具体转换：
( 句柄转为指针 )
CWnd* pWnd=FromeHandle(hMyHandle); pWnd-&gt;SetWindowText(&#34;Hello World!&#34;); or CWnd* pWnd; pWnd-&gt;Attach(hMyHandle); MFC类中有的还提供了标准方法，比如Window句柄：
static CWnd* PASCAL FromHandle( HWND hWnd ); HWND GetSafeHwnd( ) const; 对于位图： static CBitmap* PASCAL FromHandle( HBITMAP hBitmap ); static CGdiObject* PASCAL FromHandle( HGDIOBJ hObject ); HGDIOBJ GetSafeHandle( ) const;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ccbc489642c7e4cd6c90885704f9c813/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-12T07:51:52+08:00" />
<meta property="article:modified_time" content="2022-12-12T07:51:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">下MFC中对象、句柄、ID之间的区别.</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>Windows程序中，有各种各样的资源（窗口、图标、光标），系统在创建这些资源的时候会为他们分配内存，并返回标识这些资源的标识号，即句柄HANDLE（ID）。图标句柄（HICON）、光标句柄（HCURSOR）、画刷句柄（HBRUSH）。</p> 
<p>为什么有个窗口对象还要窗口句柄呢？还有什么线程句柄，甚至还有控件ID和进程ID呢？MFC中的对象，比如应用程序对象，视图对象等，是对象就会占用内存空间，我们就可以用指针指向此对象进行访问，但windows还提供了句柄访问，初看好像有点多余，实则不然。如果我们一个进程想访问另一个进程，根据对象指针访问就不行了。我们现在的Windows是一个完全保护的系统，应用程序工作于CPU的保护模式下，引入了虚存技术。每个进程拥有独立的4GB的地址空间，所以在应用程序中的地址是自己眼中的地址，不具有通用性。那么两个进程就不能简单地传个地址就行了，窗体句柄就是windows内核的一种数据结构，不同窗体（可以是不同进程的不同窗体）有不同的窗体句柄，windows通过句柄可以识别不同的窗体对象。那么进程句柄也是全局唯一的么？非也！进程句柄也是在本进程内有效，由创建进程或者打开进程时得到的句柄。进程ID才是全局唯一的。那么控件ID是全局唯一的么？也不是！控件ID代表一个资源，很多时候就是代表一个资源所在的路径及资源名</p> 
<p> </p> 
<p>句柄到底是什么东东呢，指针呢？</p> 
<p>其实，句柄并没有什么神奇之处，不管哪种句柄，实际都是一个整数。它标识一种资源，如窗口、位图等等。就象你找一个人，必须知道它的地址一样，如果你要操作一种资源，必须先获得句柄。“取窗口句柄（）”并不是只能取出窗口的句柄，所有窗口控件，如编辑框、标签等都可以用本命令取出自己的句柄，如：编辑框1.取窗口句柄（）或标签1.取窗口句柄（）。控件的句柄同样，任何控件都有它自身的特有属性，句柄也就指它的特有属性（包括共性）。</p> 
<p>句柄英文译作HANDLE，HANDLE的本意是把柄，把手的意思，是与操作系统打交道的东东。有人举过比较通俗的例子：你考上了大学，入学后，学校（操作系统）会给你一个学生证号。注意，这个号码是学校指定的，你无法自选。有了这个号码（学生证，假设一证多用）享受学校提供的服务：如你就可以去图书馆借书，去食堂吃饭，去教室上课等 等。但你不能到食堂里买啤酒，因为学校不允许这种服务。而在计算机中系统提供的服务就是API调用了。当你有了HANDLE，就可以理直气壮地向系统提出调用API的服务。而指针的权力就大多了，有了指针你可以到处去喝酒，打架，学校（操作系统）管不着，所以句柄和指针的区别在于句柄只能调用系统提供的服务。而句柄虽然是一个能相互区别的号码，但与我们普通的ID号又有区别，普通的ID号是可以由程序员自己定义的，而句柄不行，它是对象生成时系统指定的，是为了区别系统中存在的各个对象，这个句柄不是由程序员赋给的。</p> 
<p>可以引用csdn上一个人的话来说明句柄，指针对象实例之间的关系：</p> 
<p>牧童遥指杏花村。牧童的手为指针，杏花村的牌子为句柄，杏花村酒店为对象的实例。</p> 
<p>深入探讨句柄</p> 
<p>更透彻的说，句柄是一种指向指针的指针。大家都知道，所谓指针是一种内存地址。应用程序启动后，组成这个程序的各对象是住留在内存的。如果简单地理解，似乎我们只要获知这个内存的首地址，那么就可以随时用这个地址访问对象。但是，如果您真的这样认为，那么您就大错特错了。我们知道，Windows是一个以虚拟内存为基础的操作系统。在这种系统环境 下，Windows内存管理器经常在内存中来回移动对象，依此来满足各种应用程序的内存需要。对象被移动意味着它的地址变化了。如果地址总是如此变化，我们该到哪里去找该对象呢? 为了解决这个问题，Windows操作系统为各应用程序腾出一些内存储地址，用来专门登记各应用对象在内存中的地址变化，而这个地址(存储单元的位置)本 身是不变的。Windows内存管理器在移动对象在内存中的位置后，把对象新的地址告知这个句柄地址来保存。这样我们只需记住这个句柄地址就可以间接地知道对象具体在内存中的哪个位置。这个地址是在对象装载(Load)时由系统分配给的，当系统卸载时(Unload)又释放给系统。句柄地址(稳定) ─→记载着对象在内存中的地址─→对象在内存中的地址(不稳定) ─→实际对象 本质：WINDOWS程序中并不是用物理地址来标识一个内存块，文件，任务或动态装入模块的，相反的，WINDOWS API给这些项目分配确定的句柄，并将句柄返回给应用程序，然后通过句柄来进行操作。 但是必须注意的是程序每次从新启动，系统不能保证分配给这个程序的句柄还是原来的那个句柄，而且绝大多数情况的确不一样的。假如我们把进入电影院看电影看 成是一个应用程序的启动运行，那么系统给应用程序分配的句柄总是不一样，这和每次电影院售给我们的门票总是不同的一个座位是一样的道理。</p> 
<p> <br> MFC _窗口ID，句柄，指针三者相互转换函数<br> ID--HANDLE--HWND三者之间的互相转换<br> id-&gt;句柄        hWnd = ::GetDlgItem(hParentWnd,id);<br> id-&gt;指针        CWnd::GetDlgItem();<br> 句柄-&gt;id        id = GetWindowLong(hWnd,GWL_ID);<br> 句柄-&gt;指针    CWnd *pWnd=CWnd::FromHandle(hWnd);<br> 指针-&gt;ID       id = GetWindowLong(pWnd-&gt;GetSafeHwnd,GWL_ID);<br>                                             GetDlgCtrlID();<br> 指针-&gt;句柄     hWnd=cWnd.GetSafeHandle() or mywnd-&gt;m_hWnd;  </p> 
<p>指针的使用在编程过程中至关重要，恰到好处并能正确无误的使用指针不但能够提高程序自身的运行效率，而且有助于节省程序执行所需要消耗的资源。指针对应着某个数据在内存空间中的地址，得到了指针就可以自由地修改该数据。句柄代表指针的“指针”，也可以将其比作表中数据项的索引值( 表对应某个进程自身的内存空间 )。句柄是间接的引用对象。</p> 
<p>        指针和句柄的不同之处：</p> 
<p>句柄所指的可以是一个很复杂的结构，并且很有可能与系统有关的，比如上面所说线程的句柄，它指向的就是一个类或者结构，它和系统有很密切的关系。当一个线程由于不可预料的原因而终止时，系统就可以通过句柄来回收它所占用的资料，如CPU，内存等等。反过来想，这些句柄中的某一些，是与系统进行交互用的。<br> 指针它也可以指向一个复杂的结构，但通常是由用户自我定义的，所以一些必需的工作都要由用户自己完成，特别是在删除的时候。<br> 另外需要注意的是句柄往往有自己的存在区限，比如一个进程，如果将其传递到另一个进程中，句柄也就失去了意义( 表中数据项的索引值，索引离开了具体的表也就失去了意义 )。<br>         具体转换：</p> 
<p>        ( 句柄转为指针 )</p> 
<p>        CWnd* pWnd=FromeHandle(hMyHandle); <br>         pWnd-&gt;SetWindowText("Hello World!"); </p> 
<p>        or </p> 
<p>        CWnd* pWnd; <br>         pWnd-&gt;Attach(hMyHandle);  </p> 
<p>        MFC类中有的还提供了标准方法，比如Window句柄：</p> 
<p>        static CWnd* PASCAL FromHandle( <br>         HWND hWnd <br>         ); <br>         HWND GetSafeHwnd( ) const; </p> 
<p>        对于位图： <br>         static CBitmap* PASCAL FromHandle( <br>        HBITMAP hBitmap <br>          );  <br>          static CGdiObject* PASCAL FromHandle( <br>        HGDIOBJ hObject <br>          ); <br>         HGDIOBJ GetSafeHandle( ) const;</p> 
<p>        当然，更详细的信息需要在具体使用中自我查询。</p> 
<p>建 议：指针和句柄的使用属于比较复杂、危险性较高的应用，在具体实践中，如果可以，尽量不要使用指针和句柄，最好选择现有的、封装完好的方式来实现，更别提指针同句柄的转换了，它更加危险。</p> 
<p>        比如在操作字符串时，尽量使用CString类来实现，通过定义好的构造、析构函数来完成分配和回收，最好不要通过指针来动态操作。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c87855b420a96e90b14b84fae347395f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Arcgis使用教程（十二）ARCGIS地图制图之比例尺设置参数详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3ac340e2696f7598592663c601e04d3a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">TEE/Trustzone学习</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>