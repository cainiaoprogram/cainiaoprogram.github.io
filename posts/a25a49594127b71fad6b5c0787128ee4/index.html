<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis的缓存问题（三）缓存穿透、缓存雪崩、缓存击穿 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis的缓存问题（三）缓存穿透、缓存雪崩、缓存击穿" />
<meta property="og:description" content="Redis的缓存问题（三）缓存穿透、缓存雪崩、缓存击穿
缓存穿透
什么是缓存穿透？
解决方案（2种）
（1）缓存空对象
（2）布隆过滤
综上所述
代码实现
思路图解
运行测试
扩展
缓存雪崩
什么是缓存雪崩？
解决方案（4种）
（1）给不同的Key的TTL添加随机值（推荐）
（2）利用Redis集群提高服务的可用性
（3）给缓存业务添加降级限流策略
（4）给业务添加多级缓存 缓存击穿
什么是缓存击穿？
解决方案（2种）
（1）互斥锁
（2）逻辑过期
互斥锁与逻辑过期的对比分析
具体实现
（1）关于互斥锁的实现
需求描述
代码实现
（2）逻辑过期的实现
需求描述
代码实现
完整代码
Redis的缓存问题（三）缓存穿透、缓存雪崩、缓存击穿 缓存穿透 什么是缓存穿透？ 缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库。
解决方案（2种） （1）缓存空对象 简单的来说，就是请求之后，发现数据不存在，就将null值打入Redis中。
优点：
实现简单，维护方便 缺点：
额外的内存消耗可能造成短期的不一致 分析：
当请求第一次来时，数据库中没有该数据，数据库向Redis写入一个null；此时正好数据库中被插入了该数据，又有一个请求来访问，但是刚刚向Redis中插入的null来没有过期，就出现了不一致（该请求从Redis拿到的结果就是null，而数据库中其实是有实际数据的）
当然我们也有许多的解决办法，例如：将TTL的时间设置的足够短；每次向数据库新增数据的时候主动将其插入缓存中去覆盖那个null。
（2）布隆过滤 在客户端与Redis之间加了一个布隆过滤器，对于请求进行过滤。 布隆过滤器的大致的原理：布隆过滤器中存放二进制位。数据库的数据通过hash算法计算其hash值并存放到布隆过滤器中，之后判断数据是否存在的时候，就是判断该hash值是0还是1。
但是这个玩意是一种概率上的统计，当其判断不存在的时候就一定是不存在；当其判断存在的时候就不一定存在。所以有一定的穿透风险！！！
优点：
内存占用较少，没有多余key 缺点：
实现复杂存在误判可能 综上所述 我们可以两种方案一起用，这样子最为保险。据统计使用布隆过滤器一般可以避免90%的无效请求。但是黑马程序员这里的视频是使用方案一（缓存空对象）。
代码实现 思路图解 显然我们在这里只要做两件事：
当查询数据在数据库中不存在时，将空值写入 redis 判断缓存是否命中后，再加一个判断是否为空值 @Override public Result queryById(Long id) { // 从redis查询商铺缓存 String key = CACHE_SHOP_KEY &#43; id; String shopJson = stringRedisTemplate." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a25a49594127b71fad6b5c0787128ee4/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-20T22:57:36+08:00" />
<meta property="article:modified_time" content="2022-08-20T22:57:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis的缓存问题（三）缓存穿透、缓存雪崩、缓存击穿</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><a href="#Redis%E7%9A%84%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%EF%BC%88%E4%B8%89%EF%BC%89%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF" rel="nofollow">Redis的缓存问题（三）缓存穿透、缓存雪崩、缓存击穿</a></p> 
<p id="%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-toc" style="margin-left:0px;"><a href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F" rel="nofollow">缓存穿透</a></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9F" rel="nofollow">什么是缓存穿透？</a></p> 
<p id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%882%E7%A7%8D%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%882%E7%A7%8D%EF%BC%89" rel="nofollow">解决方案（2种）</a></p> 
<p id="%EF%BC%881%EF%BC%89%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1" rel="nofollow">（1）缓存空对象</a></p> 
<p id="%EF%BC%882%EF%BC%89%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4" rel="nofollow">（2）布隆过滤</a></p> 
<p id="%E7%BB%BC%E4%B8%8A%E6%89%80%E8%BF%B0-toc" style="margin-left:80px;"><a href="#%E7%BB%BC%E4%B8%8A%E6%89%80%E8%BF%B0" rel="nofollow">综上所述</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">代码实现</a></p> 
<p id="%E6%80%9D%E8%B7%AF%E5%9B%BE%E8%A7%A3-toc" style="margin-left:80px;"><a href="#%E6%80%9D%E8%B7%AF%E5%9B%BE%E8%A7%A3" rel="nofollow">思路图解</a></p> 
<p id="%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95-toc" style="margin-left:80px;"><a href="#%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95" rel="nofollow">运行测试</a></p> 
<p id="%E6%89%A9%E5%B1%95-toc" style="margin-left:40px;"><a href="#%E6%89%A9%E5%B1%95" rel="nofollow">扩展</a></p> 
<p id="%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9-toc" style="margin-left:0px;"><a href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9" rel="nofollow">缓存雪崩</a></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9F" rel="nofollow">什么是缓存雪崩？</a></p> 
<p id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%884%E7%A7%8D%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%884%E7%A7%8D%EF%BC%89" rel="nofollow">解决方案（4种）</a></p> 
<p id="%EF%BC%881%EF%BC%89%E7%BB%99%E4%B8%8D%E5%90%8C%E7%9A%84Key%E7%9A%84TTL%E6%B7%BB%E5%8A%A0%E9%9A%8F%E6%9C%BA%E5%80%BC%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E7%BB%99%E4%B8%8D%E5%90%8C%E7%9A%84Key%E7%9A%84TTL%E6%B7%BB%E5%8A%A0%E9%9A%8F%E6%9C%BA%E5%80%BC%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89" rel="nofollow">（1）给不同的Key的TTL添加随机值（推荐）</a></p> 
<p id="%EF%BC%882%EF%BC%89%E5%88%A9%E7%94%A8Redis%E9%9B%86%E7%BE%A4%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E5%88%A9%E7%94%A8Redis%E9%9B%86%E7%BE%A4%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7" rel="nofollow">（2）利用Redis集群提高服务的可用性</a></p> 
<p id="%EF%BC%883%EF%BC%89%E7%BB%99%E7%BC%93%E5%AD%98%E4%B8%9A%E5%8A%A1%E6%B7%BB%E5%8A%A0%E9%99%8D%E7%BA%A7%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5-toc" style="margin-left:80px;"><a href="#%EF%BC%883%EF%BC%89%E7%BB%99%E7%BC%93%E5%AD%98%E4%B8%9A%E5%8A%A1%E6%B7%BB%E5%8A%A0%E9%99%8D%E7%BA%A7%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5" rel="nofollow">（3）给缓存业务添加降级限流策略</a></p> 
<p id="%EF%BC%884%EF%BC%89%E7%BB%99%E4%B8%9A%E5%8A%A1%E6%B7%BB%E5%8A%A0%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%C2%A0%C2%A0-toc" style="margin-left:80px;"><a href="#%EF%BC%884%EF%BC%89%E7%BB%99%E4%B8%9A%E5%8A%A1%E6%B7%BB%E5%8A%A0%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%C2%A0%C2%A0" rel="nofollow">（4）给业务添加多级缓存  </a></p> 
<p id="%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-toc" style="margin-left:0px;"><a href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF" rel="nofollow">缓存击穿</a></p> 
<p id="%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%9F-toc" style="margin-left:40px;"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%9F" rel="nofollow">什么是缓存击穿？</a></p> 
<p id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%882%E7%A7%8D%EF%BC%89-toc" style="margin-left:40px;"><a href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%882%E7%A7%8D%EF%BC%89" rel="nofollow">解决方案（2种）</a></p> 
<p id="%EF%BC%881%EF%BC%89%E4%BA%92%E6%96%A5%E9%94%81-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E4%BA%92%E6%96%A5%E9%94%81" rel="nofollow">（1）互斥锁</a></p> 
<p id="%EF%BC%882%EF%BC%89%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F" rel="nofollow">（2）逻辑过期</a></p> 
<p id="%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E7%9A%84%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90-toc" style="margin-left:40px;"><a href="#%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E7%9A%84%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90" rel="nofollow">互斥锁与逻辑过期的对比分析</a></p> 
<p id="%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0" rel="nofollow">具体实现</a></p> 
<p id="%EF%BC%881%EF%BC%89%E5%85%B3%E4%BA%8E%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%EF%BC%881%EF%BC%89%E5%85%B3%E4%BA%8E%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">（1）关于互斥锁的实现</a></p> 
<p id="%E9%9C%80%E6%B1%82%E6%8F%8F%E8%BF%B0-toc" style="margin-left:80px;"><a href="#%E9%9C%80%E6%B1%82%E6%8F%8F%E8%BF%B0" rel="nofollow">需求描述</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">代码实现</a></p> 
<p id="%EF%BC%882%EF%BC%89%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E7%9A%84%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%EF%BC%882%EF%BC%89%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E7%9A%84%E5%AE%9E%E7%8E%B0" rel="nofollow">（2）逻辑过期的实现</a></p> 
<p id="%E9%9C%80%E6%B1%82%E6%8F%8F%E8%BF%B0-toc" style="margin-left:80px;"><a href="#%E9%9C%80%E6%B1%82%E6%8F%8F%E8%BF%B0" rel="nofollow">需求描述</a></p> 
<p id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-toc" style="margin-left:80px;"><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0" rel="nofollow">代码实现</a></p> 
<p id="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%C2%A0-toc" style="margin-left:0px;"><a href="#%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%C2%A0" rel="nofollow">完整代码</a></p> 
<hr> 
<h2>Redis的缓存问题（三）缓存穿透、缓存雪崩、缓存击穿</h2> 
<h2 id="%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F">缓存穿透</h2> 
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%EF%BC%9F">什么是缓存穿透？</h3> 
<p>缓存穿透是指<strong>客户端请求</strong>的数据在<strong>缓存</strong>中和<strong>数据库</strong>中<strong>都不存在</strong>，这样缓存永远不会生效，这些请求都会打到数据库。</p> 
<h3 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%882%E7%A7%8D%EF%BC%89">解决方案（2种）</h3> 
<h4 id="%EF%BC%881%EF%BC%89%E7%BC%93%E5%AD%98%E7%A9%BA%E5%AF%B9%E8%B1%A1">（1）缓存空对象</h4> 
<p class="img-center"><img alt="" height="312" src="https://images2.imgbox.com/d5/e9/ifac7A6O_o.png" width="254"></p> 
<p>简单的来说，就是请求之后，发现数据不存在，就将<strong>null</strong>值打入Redis中。</p> 
<p><strong>优点：</strong></p> 
<ul><li>实现简单，维护方便</li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li><strong>额外的内存消耗</strong></li><li><span style="color:#fe2c24;"><strong>可能造成短期的不一致</strong></span></li></ul> 
<p><strong>分析：</strong></p> 
<p>当请求第一次来时，数据库中没有该数据，数据库向Redis写入一个<strong>null</strong>；此时正好数据库中被插入了该数据，又有一个请求来访问，但是刚刚向Redis中插入的null来<strong>没有过期</strong>，就出现了不一致（该请求从<strong>Redis</strong>拿到的结果就是<strong>null</strong>，而<strong>数据库</strong>中其实是有实际数据的）</p> 
<p>当然我们也有许多的解决办法，例如：将TTL的时间设置的足够短；<strong>每次向数据库新增数据的时候主动将其插入缓存中去覆盖那个null。</strong></p> 
<h4 id="%EF%BC%882%EF%BC%89%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4">（2）布隆过滤</h4> 
<p class="img-center"><img alt="" height="340" src="https://images2.imgbox.com/70/d6/QfqS3c6d_o.png" width="302"></p> 
<p>在客户端与Redis之间加了一个布隆过滤器，对于请求进行过滤。 </p> 
<p>布隆过滤器的大致的原理：布隆过滤器中存放<strong>二进制位</strong>。数据库的数据通过<strong>hash算法</strong>计算其<strong>hash值</strong>并存放到布隆过滤器中，之后判断数据是否存在的时候，就是判断该<strong>hash值</strong>是0还是1。</p> 
<p>但是这个玩意是一种<strong>概率上</strong>的统计，<span style="color:#fe2c24;">当其<strong>判断不存在</strong>的时候就<strong>一定是不存在</strong>；当其<strong>判断存在</strong>的时候就</span><strong><span style="color:#fe2c24;">不一定存在</span>。</strong>所以有<strong>一定的穿透风险！！！</strong></p> 
<p><strong>优点：</strong></p> 
<ul><li><strong>内存占用较少，没有多余key</strong></li></ul> 
<p><strong>缺点：</strong></p> 
<ul><li>实现<strong>复杂</strong></li><li>存在误判可能</li></ul> 
<h4 id="%E7%BB%BC%E4%B8%8A%E6%89%80%E8%BF%B0">综上所述</h4> 
<p>我们可以<strong>两种方案一起用</strong>，这样子最为保险。据统计使用布隆过滤器一般可以避免90%的无效请求。但是黑马程序员这里的视频是使用<strong><span style="color:#fe2c24;">方案一（缓存空对象）</span>。</strong></p> 
<h3 id="%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</h3> 
<h4 id="%E6%80%9D%E8%B7%AF%E5%9B%BE%E8%A7%A3">思路图解</h4> 
<p><img alt="" height="634" src="https://images2.imgbox.com/8c/16/fkwcLWze_o.png" width="1200"></p> 
<p>显然我们在这里只要做两件事：</p> 
<ul><li>当查询数据在数据库中不存在时，将<strong>空值写入 redis</strong></li><li> 判断缓存是否命中后，再加一个<strong>判断是否为空值</strong></li></ul> 
<pre><code class="language-java">@Override
public Result queryById(Long id) {

    // 从redis查询商铺缓存
    String key = CACHE_SHOP_KEY + id;
    String shopJson = stringRedisTemplate.opsForValue().get(key);

    // 判断是否存在
    if (StrUtil.isNotBlank(shopJson)) {
        // 存在，直接返回
        Shop shop = JSONUtil.toBean(shopJson, Shop.class);
        return Result.ok(shop);
    }

    // 1.判断空值
    if (shopJson != null) {
        // 返回一个错误信息
        return Result.fail("店铺不存在！");
    }


    // 不存在，根据id查询数据库
    Shop shop = getById(id);

    // 不存在，返回错误
    if (shop == null) {
        
        // 2.防止穿透问题，将空值写入redis!!!
        stringRedisTemplate.opsForValue().set(key,"",CACHE_NULL_TTL,TimeUnit.MINUTES);
        return Result.fail("店铺不存在！");
    }

    // 存在，写入Redis
    // 把shop转换成为JSON形式写入Redis
    // 同时添加超时时间
    stringRedisTemplate.opsForValue().set(key, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);
    return Result.ok(shop);
}</code></pre> 
<h4 id="%E8%BF%90%E8%A1%8C%E6%B5%8B%E8%AF%95">运行测试</h4> 
<p>我们可以查看后台接口数据</p> 
<div> 
 <p><img alt="" height="288" src="https://images2.imgbox.com/7b/49/YhWvP5EV_o.png" width="643">​</p> 
</div> 
<h3 id="%E6%89%A9%E5%B1%95">扩展</h3> 
<p>上述所提到的两种方案其实都是<strong>被动</strong>的，（即<span style="color:#fe2c24;"><strong>缓存穿透已经发生了</strong></span>） </p> 
<p>在此之前我们应该先行避免这种现象的发生。<span style="color:#fe2c24;"><strong>如何避免？？？</strong></span></p> 
<ul><li>我们可以增加 <strong>id </strong>设计时的复杂度，避免被本人猜到 id 的规律</li><li>做好基础数据格式校验（将不符合我们定义规范的 id <strong>先行剔除</strong>）</li><li>加强<strong>用户权限的校验</strong></li><li>**做好<strong>限流</strong>（SpringCloud~~~）</li></ul> 
<h2 id="%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9">缓存雪崩</h2> 
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9F">什么是缓存雪崩？</h3> 
<p>缓存雪崩是指在<strong>同一时段大量的缓存key同时失效</strong>或者<strong>Redis服务宕机</strong>，导致大量请求到达数据库，带来巨大压力。情况大致如下图所示：</p> 
<div> 
 <p><img alt="" height="351" src="https://images2.imgbox.com/ce/87/Fej6WgG3_o.png" width="652">​</p> 
</div> 
<h3 id="%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%884%E7%A7%8D%EF%BC%89">解决方案（4种）</h3> 
<h4 id="%EF%BC%881%EF%BC%89%E7%BB%99%E4%B8%8D%E5%90%8C%E7%9A%84Key%E7%9A%84TTL%E6%B7%BB%E5%8A%A0%E9%9A%8F%E6%9C%BA%E5%80%BC%EF%BC%88%E6%8E%A8%E8%8D%90%EF%BC%89"><span style="color:#fe2c24;">（1）给不同的Key的TTL添加随机值（推荐）</span></h4> 
<p>操作简单，当我们在做<strong>缓存预热</strong>的时候，就有可能在<strong>同一时间批量插入大量的数据</strong>，那么如果它们的<strong>TTL都一样</strong>的话就可能出现<strong>大量key同时过期</strong>的情况！！！所以我们需要在设置<strong>过期时间TTL</strong>的时候，定义一个范围，追加<strong>该范围内的一个随机数</strong>。</p> 
<h4 id="%EF%BC%882%EF%BC%89%E5%88%A9%E7%94%A8Redis%E9%9B%86%E7%BE%A4%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%8F%AF%E7%94%A8%E6%80%A7">（2）利用Redis集群提高服务的可用性</h4> 
<p>使用集群提高可靠性，后续讲解~~~之后写了会在这里贴上链接。</p> 
<h4 id="%EF%BC%883%EF%BC%89%E7%BB%99%E7%BC%93%E5%AD%98%E4%B8%9A%E5%8A%A1%E6%B7%BB%E5%8A%A0%E9%99%8D%E7%BA%A7%E9%99%90%E6%B5%81%E7%AD%96%E7%95%A5">（3）给缓存业务添加降级限流策略</h4> 
<p>也是后续的微服务的知识~~~<strong>SpringCloud</strong>中有提！！！</p> 
<h4 id="%EF%BC%884%EF%BC%89%E7%BB%99%E4%B8%9A%E5%8A%A1%E6%B7%BB%E5%8A%A0%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%C2%A0%C2%A0">（4）给业务添加多级缓存  </h4> 
<p>请求到达浏览器，nginx可以做缓存，未命中找Redis，再未命中找JVM，最后到数据库......</p> 
<p><strong>SpringCloud</strong>中有多级缓存的实现方案，Redis后期也会提到，之后也会更新。</p> 
<h2 id="%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF">缓存击穿</h2> 
<h3 id="%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%9F">什么是缓存击穿？</h3> 
<p><strong>缓存雪崩</strong>是因为大量的key同时过期所导致的问题，而<strong>缓存击穿</strong>则是部分key过期导致的严重后果。</p> 
<p>为什么大量key过期会产生问题<strong>而少量的key也会有问题呢</strong>？？？</p> 
<p>这是因为这一部分的<strong>key不简单</strong>！！！</p> 
<p><span style="color:#fe2c24;"><strong>缓存击穿</strong></span>问题也叫<strong>热点Key问题</strong>，就是⼀个<span style="color:#fe2c24;"><strong>被高并发访问</strong></span>并且<span style="color:#fe2c24;"><strong>缓存重建业务较复杂</strong></span>的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。</p> 
<p>具体情况如下图所示：</p> 
<p><img alt="" height="434" src="https://images2.imgbox.com/27/43/xgVUNnlo_o.png" width="666"></p> 
<p>上述：此时假设该<strong>热点key</strong>的TTL时间到（<strong>失效了</strong>），则查询缓存未命中，会继续<strong>查询数据库</strong>，并进行<strong>缓存重建</strong>工作。但是由于<strong>查询SQL逻辑比较复杂</strong>、<strong>重建缓存的时间较久</strong>，并且该key又是热点key，短时间内<strong>有大量的线程</strong>对其进行访问，所以<strong>请求会直接 “打到” 数据库</strong>中，数据库就有可能<strong>崩掉</strong>！！！</p> 
<h3>解决方案（2种）</h3> 
<h4 id="%EF%BC%881%EF%BC%89%E4%BA%92%E6%96%A5%E9%94%81">（1）互斥锁</h4> 
<p class="img-center"><img alt="" height="523" src="https://images2.imgbox.com/b5/23/5OwgYONg_o.png" width="447"></p> 
<p>简单的来说就是，并不是所有的线程都有 “ <strong>资格 </strong>” 去访问数据库，只有持有<strong>锁</strong>的线程才可以对其进行操作。</p> 
<p>不过该操作有一个很明显的问题，就是会出现相互等待的情况。</p> 
<h4 id="%EF%BC%882%EF%BC%89%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F">（2）逻辑过期</h4> 
<p class="img-center"><img alt="" height="502" src="https://images2.imgbox.com/b4/6f/a96i0EXV_o.png" width="605"></p> 
<p>不设置TTL，之前所说导致缓存击穿的原因就是该key的TTL到期了，所以我们在这就<strong>不设置TTL了</strong>，而是使用一个<strong>字段</strong>例如：expire表示过期时间（<strong>逻辑</strong>上的）。当我们想让它 “ 过期 ” 的时候，我们可以直接<strong>手动</strong>将其<strong>删除</strong>（热点key，即只是<strong>在一段时间</strong>内，其<strong>被访问的频次很高</strong>）。</p> 
<h3 id="%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E7%9A%84%E5%AF%B9%E6%AF%94%E5%88%86%E6%9E%90">互斥锁与逻辑过期的对比分析</h3> 
<p class="img-center"><img alt="" height="223" src="https://images2.imgbox.com/02/06/dFx9nVZv_o.png" width="582"></p> 
<h3 id="%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">具体实现</h3> 
<h4 id="%EF%BC%881%EF%BC%89%E5%85%B3%E4%BA%8E%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0">（1）关于互斥锁的实现</h4> 
<h4 id="%E9%9C%80%E6%B1%82%E6%8F%8F%E8%BF%B0"><strong>需求描述</strong></h4> 
<p><strong>修改根据id查询商铺的业务，基于互斥锁方式来解决缓存击穿问题</strong></p> 
<p class="img-center"><img alt="" height="486" src="https://images2.imgbox.com/8b/ab/Ob0YoIDG_o.png" width="663"></p> 
<p>之前在“<strong>判断缓存是否命中</strong>”，如果是未命中，则会直接查数据库；但是现在要先判断一下是否可以拿到<strong>锁</strong>！ </p> 
<h4>代码实现</h4> 
<p>（1）首先，我们声明一下获取锁、释放锁的方法，<strong>tryLock()、unLock()</strong></p> 
<pre><code class="language-java">/**
  * 获取锁
  * @param key
  * @return
*/
private boolean tryLock(String key) {
    // setnx 就是 setIfAbsent 如果存在
    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key, "1", 10, TimeUnit.MINUTES);
    // 装箱是将值类型装换成引用类型的过程；拆箱就是将引用类型转换成值类型的过程
    // 不要直接返回flag，可能为null
    return BooleanUtil.isTrue(flag);
}

/**
 * 释放锁
 * @param key
 */
private void unLock(String key) {
    stringRedisTemplate.delete(key);
}</code></pre> 
<p><strong>注意</strong>：这里的锁不是真正的线程锁，而是redis里面的一个特殊的key。 </p> 
<p>（2）互斥锁解决缓存击穿 <strong>queryWithMutex()</strong></p> 
<pre><code class="language-java">/**
 * 互斥锁解决缓存击穿 queryWithMutex()
 * @param id
 * @return
 */
public Shop queryWithMutex(Long id) {
    // 1.从redis查询商铺缓存
    String key = CACHE_SHOP_KEY + id;
    String shopJson = stringRedisTemplate.opsForValue().get(key);

    // 2.判断是否存在
    if (StrUtil.isNotBlank(shopJson)) {
        return JSONUtil.toBean(shopJson, Shop.class);
    }

    // 判断空值
    if (shopJson != null) {
        // 返回一个错误信息
        return null;
    }

    String lockKey = "lock:shop:" + id;
    Shop shop = null;
    try {
        // 4.实现缓存重建
        // 4.1获取互斥锁
        boolean isLock = tryLock(lockKey);

        // 4.2判断是否成功
        if (!isLock) {
            // 4.3失败，则休眠并重试
            Thread.sleep(50);
            // 递归
            return queryWithMutex(id);
        }
        // 4.4成功，根据id查询数据库
        shop = getById(id);

        // 模拟延迟
        Thread.sleep(200);

        // 5.不存在，返回错误
        if (shop == null) {
            stringRedisTemplate.opsForValue().set(key,"",CACHE_NULL_TTL,TimeUnit.MINUTES);
            return null;
        }

        // 6.存在，写入redis
        stringRedisTemplate.opsForValue().set(key,JSONUtil.toJsonStr(shop),CACHE_SHOP_TTL,TimeUnit.MINUTES);

    } catch (InterruptedException ex) {
        throw new RuntimeException(ex);
    } finally {
        // 7.释放锁
        unLock(lockKey);
    }

    // 8.返回
    return shop;
}</code></pre> 
<h4 id="%EF%BC%882%EF%BC%89%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F%E7%9A%84%E5%AE%9E%E7%8E%B0">（2）逻辑过期的实现</h4> 
<h4><strong>需求描述</strong></h4> 
<p><strong>修改根据id查询商铺的业务，基于逻辑过期方式来解决缓存击穿问题</strong></p> 
<p class="img-center"><img alt="" height="345" src="https://images2.imgbox.com/56/cb/HyACQ9jj_o.png" width="659"></p> 
<p><strong>注意</strong>：这里的key是否过期，不是由redis控制的，而是由我们自己去手动编写逻辑去控制的。 </p> 
<h4>代码实现</h4> 
<p><strong>（1）添加逻辑过期时间的字段</strong></p> 
<p>由于我们之前的<strong>Shop</strong>中是没有逻辑过期的字段，那么<strong>我们要如何让它带有这个属性，又不修改之前的代码呢？</strong></p> 
<pre><code class="language-java">@Data
@EqualsAndHashCode(callSuper = false)
@Accessors(chain = true)
@TableName("tb_shop")
public class Shop implements Serializable {
    private static final long serialVersionUID = 1L;
    /**
     * 主键
     */
    @TableId(value = "id", type = IdType.AUTO)
    private Long id;
    private String name;
    private Long typeId;
    private String images;
    private String area;
    private String address;
    private Double x;
    private Double y;
    private Long avgPrice;
    private Integer sold;
    private Integer comments;
    private Integer score;
    private String openHours;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
    @TableField(exist = false)
    private Double distance;
}
</code></pre> 
<p>新建一个<strong>RedisData对象</strong>，里面的<strong>data</strong>指的是Shop对象，而expireTime是逻辑过期时间。</p> 
<p><span style="color:#fe2c24;">即：我们可以使用 <strong>JSONUtil.toBean</strong> 将Shop对象通过序列化、反序列化到<strong>RedisData</strong>类的<strong>data</strong>属性中。</span></p> 
<pre><code class="language-java">@Data
public class RedisData {
    // LocalDateTime ： 同时含有年月日时分秒的日期对象
    // 并且LocalDateTime是线程安全的！
    private LocalDateTime expireTime;
    private Object data;
}
</code></pre> 
<p>（2）逻辑过期解决缓存击穿问题 <strong>queryWithLogicalExpire()</strong></p> 
<p><strong>缓存重建</strong></p> 
<pre><code class="language-java">/**
 * 重建缓存,先缓存预热一下，否则queryWithLogicalExpire() 的expire为null
 * @param id
 * @param expireSeconds
 */
public void saveShopRedis(Long id, Long expireSeconds) {
    // 1.查询店铺数据
    Shop shop = getById(id);
    // 2.封装逻辑过期时间
    RedisData redisData = new RedisData();
    redisData.setData(shop);
    redisData.setExpireTime(LocalDateTime.now().plusSeconds(expireSeconds));  // 过期时间
    // 3.写入redis
    stringRedisTemplate.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(redisData));
}</code></pre> 
<p>先使用测试方法运行一下<strong>saveShopRedis()</strong>，否则redis里面<strong>没有expireTime ！</strong></p> 
<p class="img-center"><img alt="" height="262" src="https://images2.imgbox.com/14/29/as0tG61M_o.png" width="643"></p> 
<pre><code class="language-java">/**
 * 逻辑过期解决缓存击穿问题 queryWithLogicalExpire()
 * 测试前要先缓存预热一下！不然 data 与 expireTime 的缓存值是null！
 * @param id
 * @return
 */
public Shop queryWithLogicalExpire(Long id) {
    // 1.从redis查询商铺缓存
    String key = CACHE_SHOP_KEY + id;
    String shopJson = stringRedisTemplate.opsForValue().get(key);

    // 2.判断是否存在
    if (StrUtil.isBlank(shopJson)) {
        return null;
    }

    // 4.命中，需要将json反序列化为对象
    // redisData没有数据
    RedisData redisData = JSONUtil.toBean(shopJson, RedisData.class);
    Shop shop = JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);
    LocalDateTime expireTime = redisData.getExpireTime();

    // 5.判断是否过期
    if (expireTime.isAfter(LocalDateTime.now())) {
        // 5.1未过期，直接返回店铺信息
        return shop;
    }

    // 5.2已过期，需要缓存重建
    // 6.缓存重建
    // 6.1.获取互斥锁
    String lockKey = LOCK_SHOP_KEY + id;
    boolean islock = tryLock(lockKey);
    // 6.2.判断是否获取互斥锁成功
    if (islock) {
        // 6.3.成功，开启独立线程，实现缓存重建
        CACHE_REBUILD_EXECUTOR.submit( () -&gt; {
            try {
                // 重建缓存，过期时间为20L
                saveShopRedis(id,20L);
            } catch (Exception ex) {
                throw new RuntimeException(ex);
            } finally {
                unLock(lockKey);
            }
        });
    }
    // 6.4.返回过期店铺信息
    return shop;
}</code></pre> 
<p>我们可以看到在测试的时候，name的值为：“100XXXX”</p> 
<p>我们现在来修改一下<strong>数据库</strong>，将值改为：“900XXXX”，看看并发情况下<strong>缓存重建能否正确</strong>！</p> 
<p class="img-center"><img alt="" height="241" src="https://images2.imgbox.com/74/4b/1BMQmmUz_o.png" width="647"></p> 
<p>通过<strong>Jmeter</strong>做压力测试</p> 
<p class="img-center"><img alt="" height="293" src="https://images2.imgbox.com/c9/ab/EUgxKuvJ_o.png" width="668"></p> 
<p>再查看Redis中的数据，可以看到name的值<strong>已经被修改</strong>了，而且上面的<strong>jmeter</strong>的每一个http都是正常的！</p> 
<p class="img-center"><img alt="" height="232" src="https://images2.imgbox.com/a7/c9/HYwqJga0_o.png" width="663"></p> 
<h2 id="%E5%AE%8C%E6%95%B4%E4%BB%A3%E7%A0%81%C2%A0">完整代码 </h2> 
<p><strong>见</strong><span style="color:#fe2c24;"><strong>分支 v5_cache_breakdown</strong></span></p> 
<p>最新的代码见master主分支（代码还未写完，视频还未看完，所以master是最新的分支，而<span style="color:#fe2c24;"><strong>v5_cache_breakdown</strong></span><span style="color:#0d0016;">就是上述的这些功能实现！不会再做修改了！</span>） ​​​​​​​</p> 
<p><a class="link-info has-card" href="https://gitee.com/Harmony_TL/redis_heima_project" rel="nofollow" title="https://gitee.com/Harmony_TL/redis_heima_project"><span class="link-card-box"><span class="link-title">https://gitee.com/Harmony_TL/redis_heima_project</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/4a/83/Td8boJ2b_o.png" alt="icon-default.png?t=M7J4">https://gitee.com/Harmony_TL/redis_heima_project</span></span></a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7d98b01bed5245a3a8fd637e12cc5876/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Python numpy 统计数组某一元素的个数/ 统计数组满足条件的元素个数</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a6caf2ef34d202bdcf4b017d83c0e82f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Password Strength Backround</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>