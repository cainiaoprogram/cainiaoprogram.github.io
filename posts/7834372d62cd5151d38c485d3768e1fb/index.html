<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>SpringBoot 统一登录鉴权、异常处理、数据格式 的正确姿势 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="SpringBoot 统一登录鉴权、异常处理、数据格式 的正确姿势" />
<meta property="og:description" content="1. 统一用户登录权限效验 用户登录权限的发展完善过程
最初用户登录效验：在每个方法中获取 Session 和 Session 中的用户信息，如果存在用户，那么就认为登录成功了，否则就登录失败了
第二版用户登录效验：提供统一的方法，在每个需要验证的方法中调用统一的用户登录身份效验方法来判断
第三版用户登录效验：使用 Spring AOP 来统一进行用户登录效验
第四版用户登录效验：使用 Spring 拦截器来实现用户的统一登录验证
1.1 最初用户登录权限效验 @RestController @RequestMapping(&#34;/user&#34;) public class UserController { @RequestMapping(&#34;/a1&#34;) public Boolean login (HttpServletRequest request) { // 有 Session 就获取，没有就不创建 HttpSession session = request.getSession(false); if (session != null &amp;&amp; session.getAttribute(&#34;userinfo&#34;) != null) { // 说明已经登录，进行业务处理 return true; } else { // 未登录 return false; } } @RequestMapping(&#34;/a2&#34;) public Boolean login2 (HttpServletRequest request) { // 有 Session 就获取，没有就不创建 HttpSession session = request." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/7834372d62cd5151d38c485d3768e1fb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-05T23:34:49+08:00" />
<meta property="article:modified_time" content="2023-12-05T23:34:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">SpringBoot 统一登录鉴权、异常处理、数据格式 的正确姿势</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3></h3> 
<blockquote> 
 <h3><em>1. 统一用户登录权限效验</em></h3> 
</blockquote> 
<p>用户登录权限的发展完善过程</p> 
<ul><li> <p><strong>最初用户登录效验：</strong>在每个方法中获取 Session 和 Session 中的用户信息，如果存在用户，那么就认为登录成功了，否则就登录失败了</p> </li><li> <p><strong>第二版用户登录效验：</strong>提供统一的方法，在每个需要验证的方法中调用统一的用户登录身份效验方法来判断</p> </li><li> <p><strong>第三版用户登录效验：</strong>使用 Spring AOP 来统一进行用户登录效验</p> </li><li> <p><strong>第四版用户登录效验：</strong>使用 Spring 拦截器来实现用户的统一登录验证</p> </li></ul> 
<blockquote> 
 <h4><em>1.1 最初用户登录权限效验</em></h4> 
</blockquote> 
<pre><code class="language-java">@RestController
@RequestMapping("/user")
public class UserController {

    @RequestMapping("/a1")
    public Boolean login (HttpServletRequest request) {
        // 有 Session 就获取，没有就不创建
        HttpSession session = request.getSession(false);
        if (session != null &amp;&amp; session.getAttribute("userinfo") != null) {
            // 说明已经登录，进行业务处理
            return true;
        } else {
            // 未登录
            return false;
        }
    }

    @RequestMapping("/a2")
    public Boolean login2 (HttpServletRequest request) {
        // 有 Session 就获取，没有就不创建
        HttpSession session = request.getSession(false);
        if (session != null &amp;&amp; session.getAttribute("userinfo") != null) {
            // 说明已经登录，进行业务处理
            return true;
        } else {
            // 未登录
            return false;
        }
    }
}</code></pre> 
<p>这种方式写的代码，每个方法中都有相同的用户登录验证权限，缺点是：</p> 
<ul><li> <p>每个方法中都要单独写用户登录验证的方法，即使封装成公共方法，也一样要传参调用和在方法中进行判断</p> </li><li> <p>添加控制器越多，调用用户登录验证的方法也越多，这样就增加了后期的修改成功和维护成功</p> </li><li> <p>这些用户登录验证的方法和现在要实现的业务几乎没有任何关联，但还是要在每个方法中都要写一遍，所以提供一个公共的 AOP 方法来进行统一的用户登录权限验证是非常好的解决办法。</p> </li></ul> 
<blockquote> 
 <h4><em>1.2 Spring AOP 统一用户登录验证</em></h4> 
</blockquote> 
<p>统一用户登录验证，首先想到的实现方法是使用 Spring AOP 前置通知或环绕通知来实现</p> 
<pre><code class="language-java">@Aspect // 当前类是一个切面
@Component
public class UserAspect {
    // 定义切点方法 Controller 包下、子孙包下所有类的所有方法
    @Pointcut("execution(* com.example.springaop.controller..*.*(..))")
    public void  pointcut(){}
    
    // 前置通知
    @Before("pointcut()")
    public void doBefore() {}
    
    // 环绕通知
    @Around("pointcut()")
    public Object doAround(ProceedingJoinPoint joinPoint) {
        Object obj = null;
        System.out.println("Around 方法开始执行");
        try {
            obj = joinPoint.proceed();
        } catch (Throwable e) {
            e.printStackTrace();
        }
        System.out.println("Around 方法结束执行");
        return obj;
    }
}</code></pre> 
<p>但如果只在以上代码 Spring AOP 的切面中实现用户登录权限效验的功能，有这样两个问题：</p> 
<ul><li> <p>没有办法得到 <code>HttpSession</code> 和 Request 对象</p> </li><li> <p>我们要对一部分方法进行拦截，而另一部分方法不拦截，比如注册方法和登录方法是不拦截的，也就是实际的拦截规则很复杂，使用简单的 aspectJ 表达式无法满足拦截的需求</p> </li></ul> 
<blockquote> 
 <h4><em>1.3 Spring 拦截器</em></h4> 
</blockquote> 
<p>针对上面代码 Spring AOP 的问题，Spring 中提供了具体的实现拦截器：<code>HandlerInterceptor</code>，拦截器的实现有两步：</p> 
<p>1.创建自定义拦截器，实现 Spring 中的 <code>HandlerInterceptor</code> 接口中的 preHandle方法</p> 
<p>2.将自定义拦截器加入到框架的配置中，并且设置拦截规则</p> 
<ul><li> <p>给当前的类添加 <code>@Configuration</code> 注解</p> </li><li> <p>实现 <code>WebMvcConfigurer</code> 接口</p> </li><li> <p>重写 <code>addInterceptors</code> 方法</p> </li></ul> 
<blockquote> 
 <p>“注意：一个项目中可以同时配置多个拦截器</p> 
</blockquote> 
<blockquote> 
 <h6><em>（1）创建自定义拦截器</em></h6> 
</blockquote> 
<pre><code class="language-java">/**
 * @Description: 自定义用户登录的拦截器
 * @Date 2023/2/13 13:06
 */
@Component
public class LoginIntercept implements HandlerInterceptor {
    // 返回 true 表示拦截判断通过，可以访问后面的接口
    // 返回 false 表示拦截未通过，直接返回结果给前端
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
                             Object handler) throws Exception {
        // 1.得到 HttpSession 对象
        HttpSession session = request.getSession(false);
        if (session != null &amp;&amp; session.getAttribute("userinfo") != null) {
            // 表示已经登录
            return true;
        }
        // 执行到此代码表示未登录，未登录就跳转到登录页面
        response.sendRedirect("/login.html");
        return false;
    }
}</code></pre> 
<blockquote> 
 <h6><em>2）将自定义拦截器添加到系统配置中，并设置拦截的规则</em></h6> 
</blockquote> 
<ul><li> <p><code>addPathPatterns</code>：表示需要拦截的 URL，<code>**</code>表示拦截所有⽅法</p> </li><li> <p><code>excludePathPatterns</code>：表示需要排除的 URL</p> </li></ul> 
<p>说明：拦截规则可以拦截此项⽬中的使⽤ URL，包括静态⽂件（图⽚⽂件、JS 和 CSS 等⽂件）。</p> 
<pre><code class="language-java">/**
 * @Description: 将自定义拦截器添加到系统配置中，并设置拦截的规则
 * @Date 2023/2/13 13:13
 */
@Configuration
public class AppConfig implements WebMvcConfigurer {

    @Resource
    private LoginIntercept loginIntercept;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
//        registry.addInterceptor(new LoginIntercept());//可以直接new 也可以属性注入
        registry.addInterceptor(loginIntercept).
                addPathPatterns("/**").    // 拦截所有 url
                excludePathPatterns("/user/login"). //不拦截登录注册接口
                excludePathPatterns("/user/reg").
                excludePathPatterns("/login.html").
                excludePathPatterns("/reg.html").
                excludePathPatterns("/**/*.js").
                excludePathPatterns("/**/*.css").
                excludePathPatterns("/**/*.png").
                excludePathPatterns("/**/*.jpg");
    }
}</code></pre> 
<blockquote> 
 <h4><em>1.4 练习：登录拦截器</em></h4> 
</blockquote> 
<p>要求</p> 
<ul><li> <p>登录、注册页面不拦截，其他页面都拦截</p> </li><li> <p>当登录成功写入 session 之后，拦截的页面可正常访问</p> </li></ul> 
<p>在 1.3 中已经创建了自定义拦截器 和 将自定义拦截器添加到系统配置中，并设置拦截的规则</p> 
<p>（1）下面创建登录和首页的 html</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="312" src="https://images2.imgbox.com/c0/69/9hRiMHEE_o.png" width="1080"></p> 
<p></p> 
<p>（2）创建 <code>controller</code> 包，在包中创建 <code>UserController</code>，写登录页面和首页的业务代码</p> 
<pre><code class="language-java">@RestController
@RequestMapping("/user")
public class UserController {

    @RequestMapping("/login")
    public boolean login(HttpServletRequest request,String username, String password) {
        boolean result = false;
        if (StringUtils.hasLength(username) &amp;&amp; StringUtils.hasLength(password)) {
            if(username.equals("admin") &amp;&amp; password.equals("admin")) {
                HttpSession session = request.getSession();
                session.setAttribute("userinfo","userinfo");
                return true;
            }
        }
        return result;
    }

    @RequestMapping("/index")
    public String index() {
        return "Hello Index";
    }
}</code></pre> 
<p>（3）运行程序，访问页面，对比登录前和登录后的效果</p> 
<p class="img-center"><img alt="图片" height="575" src="https://images2.imgbox.com/e4/5f/mVZoHw5H_o.png" width="1080"></p> 
<p class="img-center"><img alt="图片" height="437" src="https://images2.imgbox.com/23/17/PF1DJbfW_o.png" width="1080"></p> 
<h4>1.5 拦截器实现原理</h4> 
<p>有了拦截器之后，会在调⽤ Controller 之前进⾏相应的业务处理，执⾏的流程如下图所示</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="821" src="https://images2.imgbox.com/f7/5c/tlA9nair_o.png" width="1069"></p> 
<p><strong>实现原理源码分析</strong></p> 
<p>所有的 <code>Controller</code> 执行都会通过一个调度器 <code>DispatcherServlet</code> 来实现</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="104" src="https://images2.imgbox.com/76/db/u0KkFczI_o.png" width="1080"></p> 
<p>而所有方法都会执行 <code>DispatcherServlet</code> 中的 <code>doDispatch</code> 调度⽅法，<code>doDispatch</code> 源码分析如下：</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="261" src="https://images2.imgbox.com/da/ed/q2H1FQBS_o.png" width="1080"></p> 
<p>通过源码分析，可以看出，Sping 中的拦截器也是通过动态代理和环绕通知的思想实现的</p> 
<blockquote> 
 <h4><em>1.6 统一访问前缀添加</em></h4> 
</blockquote> 
<p>所有请求地址添加 api 前缀，c 表示所有</p> 
<p><img alt="" height="218" src="https://images2.imgbox.com/71/96/UTUhEA6J_o.png" width="1080"></p> 
<blockquote> 
 <h3><em>2. 统一异常处理</em></h3> 
</blockquote> 
<p>给当前的类上加 <code>@ControllerAdvice</code> 表示控制器通知类</p> 
<p>给方法上添加 <code>@ExceptionHandler(xxx.class)</code>，表示异常处理器，添加异常返回的业务代码</p> 
<pre><code class="language-java">@RestController
@RequestMapping("/user")
public class UserController {
    @RequestMapping("/index")
    public String index() {
        int num = 10/0;
        return "Hello Index";
    }
}</code></pre> 
<p>在config 包中，创建  <span style="color:#38d8f0;">MyExceptionAdvice</span> 类</p> 
<pre><code class="language-java">@RestControllerAdvice // 当前是针对 Controller 的通知类（增强类）
public class MyExceptionAdvice {
    @ExceptionHandler(ArithmeticException.class)
    public HashMap&lt;String,Object&gt; arithmeticExceptionAdvice(ArithmeticException e) {
        HashMap&lt;String, Object&gt; result = new HashMap&lt;&gt;();
        result.put("state",-1);
        result.put("data",null);
        result.put("msg" , "算出异常："+ e.getMessage());
        return result;
    }
}</code></pre> 
<p>也可以这样写，效果是一样的</p> 
<pre><code class="language-java">@ControllerAdvice
public class MyExceptionAdvice {
    @ExceptionHandler(ArithmeticException.class)
    @ResponseBody
    public HashMap&lt;String,Object&gt; arithmeticExceptionAdvice(ArithmeticException e) {
        HashMap&lt;String, Object&gt; result = new HashMap&lt;&gt;();
        result.put("state",-1);
        result.put("data",null);
        result.put("msg" , "算数异常："+ e.getMessage());
        return result;
    }
}</code></pre> 
<p></p> 
<p class="img-center"><img alt="图片" height="214" src="https://images2.imgbox.com/b0/7a/0jEjJ7s4_o.png" width="1080"></p> 
<p>如果再有一个空指针异常，那么上面的代码是不行的，还要写一个针对空指针异常处理器</p> 
<pre><code class="language-java">@ExceptionHandler(NullPointerException.class)
public HashMap&lt;String,Object&gt; nullPointerExceptionAdvice(NullPointerException e) {
    HashMap&lt;String, Object&gt; result = new HashMap&lt;&gt;();
    result.put("state",-1);
    result.put("data",null);
    result.put("msg" , "空指针异常异常："+ e.getMessage());
    return result;
}
@RequestMapping("/index")
public String index(HttpServletRequest request,String username, String password) {
    Object obj = null;
    System.out.println(obj.hashCode());
    return "Hello Index";
}</code></pre> 
<p></p> 
<p class="img-center"><img alt="图片" height="217" src="https://images2.imgbox.com/30/1c/cNs5uOMZ_o.png" width="1080"></p> 
<p>但是需要考虑的一点是，如果每个异常都这样写，那么工作量是非常大的，并且还有自定义异常，所以上面这样写肯定是不好的，既然是异常直接写 Exception 就好了，它是所有异常的父类，如果遇到不是前面写的两种异常，那么就会直接匹配到 Exception</p> 
<p>当有多个异常通知时，匹配顺序为当前类及其⼦类向上依次匹配</p> 
<pre><code class="language-java">@ExceptionHandler(Exception.class)
public HashMap&lt;String,Object&gt; exceptionAdvice(Exception e) {
    HashMap&lt;String, Object&gt; result = new HashMap&lt;&gt;();
    result.put("state",-1);
    result.put("data",null);
    result.put("msg" , "异常："+ e.getMessage());
    return result;
}</code></pre> 
<p>可以看到优先匹配的还是前面写的  空指针异常</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="241" src="https://images2.imgbox.com/9d/1d/Aw3WqXwD_o.png" width="1080"></p> 
<blockquote> 
 <h3><em>3. 统一数据格式返回</em></h3> 
</blockquote> 
<p>3.1 统一数据格式返回的实现</p> 
<p>（1）给当前类添加 <span style="color:#38d8f0;">@ControllerAdvice</span></p> 
<p>（2）实现 <span style="color:#38d8f0;">ResponseBodyAdvice</span> 重写其方法</p> 
<p></p> 
<ul><li><span style="background-color:#4da8ee;">supports</span>  方法，此方法表示内容是否需要重写 (通过此方法可以选择性部分控制器和方法进行重写)，如果要重写返回true</li><li><span style="color:#4da8ee;">beforeBodyWrite</span> 方法， 方法返回之前调用此方法</li></ul> 
<pre><code class="language-java">@ControllerAdvice
public class MyResponseAdvice implements ResponseBodyAdvice {

    // 返回一个 boolean 值，true 表示返回数据之前对数据进行重写，也就是会进入 beforeBodyWrite 方法
    // 返回 false 表示对结果不进行任何处理，直接返回
    @Override
    public boolean supports(MethodParameter returnType, Class converterType) {
        return true;
    }

    // 方法返回之前调用此方法
    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType, ServerHttpRequest request, ServerHttpResponse response) {
        HashMap&lt;String,Object&gt; result = new HashMap&lt;&gt;();
        result.put("state",1);
        result.put("data",body);
        result.put("msg","");
        return result;
    }
}
@RestController
@RequestMapping("/user")
public class UserController {

    @RequestMapping("/login")
    public boolean login(HttpServletRequest request,String username, String password) {
        boolean result = false;
        if (StringUtils.hasLength(username) &amp;&amp; StringUtils.hasLength(password)) {
            if(username.equals("admin") &amp;&amp; password.equals("admin")) {
                HttpSession session = request.getSession();
                session.setAttribute("userinfo","userinfo");
                return true;
            }
        }
        return result;
    }

    @RequestMapping("/reg")
    public int reg() {
        return 1;
    }
}</code></pre> 
<p></p> 
<p class="img-center"><img alt="图片" height="272" src="https://images2.imgbox.com/29/bb/36dWs40z_o.png" width="1080"></p> 
<blockquote> 
 <h4><em>3.2 @ControllerAdvice 源码分析</em></h4> 
</blockquote> 
<p>通过对 <code>@ControllerAdvice</code> 源码的分析我们可以知道上面统一异常和统一数据返回的执行流程</p> 
<p>（1）先看 @ControllerAdvice 源码</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="660" src="https://images2.imgbox.com/ba/36/827OWLss_o.png" width="1080"></p> 
<p>可以看到 <code>@ControllerAdvice</code> 派生于 <code>@Component</code> 组件而所有组件初始化都会调用 <code>InitializingBean</code> 接口</p> 
<p>（2）下面查看 initializingBean 有哪些实现类</p> 
<p>在查询过程中发现，其中 Spring MVC 中的实现子类是 <code>RequestMappingHandlerAdapter</code>，它里面有一个方法 <code>afterPropertiesSet（）</code>方法，表示所有的参数设置完成之后执行的方法</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="412" src="https://images2.imgbox.com/a6/af/N2HyTBhr_o.png" width="1080"></p> 
<p>（3）而这个方法中有一个 initControllerAdviceCache 方法，查询此方法</p> 
<p></p> 
<p class="img-center"><img alt="图片" height="411" src="https://images2.imgbox.com/c2/b9/3NW22PNb_o.png" width="1080"></p> 
<p>发现这个方法在执行时会查找使用所有的 <code>@ControllerAdvice</code> 类，发送某个事件时，调用相应的 Advice 方法，比如返回数据前调用统一数据封装，比如发生异常是调用异常的 Advice 方法实现的！</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/96/dd/RZayq5dt_o.jpg" width="1080"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ca9b1a106f361b3f164cd5afe629184f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决：Docker中CentOS镜像的yum等安装问题bash: xxxx: command not found</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fa32abcb07752ebe7cf40270b8efb08f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">腾讯混元大模型初体验</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>