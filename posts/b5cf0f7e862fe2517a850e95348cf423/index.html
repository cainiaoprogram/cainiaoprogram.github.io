<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>go语言gc机制中三色标记法的理解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="go语言gc机制中三色标记法的理解" />
<meta property="og:description" content="go语言gc 目录 go语言gc介绍Mark and Sweep三色标记法解决办法读写屏障增量更新原始快照优缺点 介绍 go语言的垃圾回收是自动实现的，所谓垃圾回收就是释放哪些不会再使用的程序所占的空间，比如已
经没有引用的变量。垃圾回收过程是与go程序并发执行的。目前go语言v1.8使用的是混合写屏障，在
此之前使用的是Mark and Sweep算法，v1.5是三色标记法。本笔记针对三色标记发经行学习。
Mark and Sweep Mark and Sweep主要是两个步骤：
1.标记(Mark phase)
2.清除(Sweep phase)
第一步，找出不可达的对象，然后做上标记。
第二步，回收标记好的对象。
操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即STW(stop the w orld）。
也就是说，这段时间程序会卡在哪儿。在暂停期间，从根对象开始标记扫描
整个堆，找到所有可达到的对象并做上标记，然后删除所有未标记对象，达
到垃圾回收功能。
缺点
垃圾回收时会暂停整个程序，并且需要扫描整个堆。会影响程序执行效率。
三色标记法 在go中，这个问题是不太可以接受的，所以go后续采用三色标记算法来经行
垃圾回收。
三色标记算法的原则就是把堆中的对象分配到不同颜色的集合当中，通过
黑，白，灰三色来标记对象。其中各颜色的含义是：
黑：对象和它所直接引用的所有对象都被访问过。
灰：这个对象已经被访问过，但是这个对象所直接引用的对象中，至少还有
一个没有被访问到，表示这个对象正在枚举中。
白：这个对象还没有被访问过，在初始阶段，所有对象都是白色，所有都枚
举完仍是白色的对象将会被当做垃圾对象被清理。
根据这些定义，我们可以得出：
1.在可达性分析的初始阶段，所有对象都是白色，一旦访问了这个对象，那
么就变成灰色，一旦这个对象所有直接引用的对象都访问过（或者没有引用
其它对象），那么就变成黑色
2.初始标记之后，GC Root节点变为黑色（GC Root不会是垃圾），GC Root
直接引用的对象变为灰色
3.正常情况下，一个对象如果是黑色，那么其直接引用的对象要么是黑色，
要么是灰色，不可能是白色（如果出现了黑色对象直接引用白色对象的情
况，就说明漏标了，就会导致对象误删，后面会介绍如何解决），这个特性
也可以说是三色标记算法正确性保障的前提条件。
算法大致的流程是（初始状态所有对象都是白色）：
1.首先我们从GC Roots开始枚举，它们所有的直接引用变为灰色，自己变为
黑色。可以想象有一个队列用于存储灰色对象，会把这些灰色对象放到这个
队列中。
2.然后从队列中取出一个灰色对象进行分析：将这个对象所有的直接引用变
为灰色，放入队列中，然后这个对象变为黑色；如果取出的这个灰色对象没
有直接引用，那么直接变成黑色。
3.继续从队列中取出一个灰色对象进行分析，分析步骤和第二步相同，一直
重复直到灰色队列为空。
4.分析完成后仍然是白色的对象就是不可达的对象，可以作为垃圾被清理。
5.最后重置标记状态。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b5cf0f7e862fe2517a850e95348cf423/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-10-21T18:26:07+08:00" />
<meta property="article:modified_time" content="2022-10-21T18:26:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">go语言gc机制中三色标记法的理解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="gogc_0"></a>go语言gc</h2> 
<p></p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#gogc_0" rel="nofollow">go语言gc</a></li><li><ul><li><a href="#_2" rel="nofollow">介绍</a></li><li><a href="#Mark_and_Sweep_6" rel="nofollow">Mark and Sweep</a></li><li><a href="#_28" rel="nofollow">三色标记法</a></li><li><ul><li><a href="#_113" rel="nofollow">解决办法</a></li><li><ul><li><a href="#_116" rel="nofollow">读写屏障</a></li><li><a href="#_121" rel="nofollow">增量更新</a></li><li><a href="#_128" rel="nofollow">原始快照</a></li><li><a href="#_139" rel="nofollow">优缺点</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="_2"></a>介绍</h3> 
<p>go语言的垃圾回收是自动实现的，所谓垃圾回收就是释放哪些不会再使用的程序所占的空间，比如已<br> 经没有引用的变量。垃圾回收过程是与go程序并发执行的。目前go语言v1.8使用的是混合写屏障，在<br> 此之前使用的是Mark and Sweep算法，v1.5是三色标记法。本笔记针对三色标记发经行学习。</p> 
<h3><a id="Mark_and_Sweep_6"></a>Mark and Sweep</h3> 
<p>Mark and Sweep主要是两个步骤：</p> 
<p>1.标记(Mark phase)</p> 
<p>2.清除(Sweep phase)</p> 
<p>第一步，找出不可达的对象，然后做上标记。</p> 
<p>第二步，回收标记好的对象。</p> 
<p>操作非常简单，但是有一点需要额外注意：mark and sweep算法在执行的时候，需要程序暂停！即STW(stop the w orld）。</p> 
<p>也就是说，这段时间程序会卡在哪儿。在暂停期间，从根对象开始标记扫描</p> 
<p>整个堆，找到所有可达到的对象并做上标记，然后删除所有未标记对象，达</p> 
<p>到垃圾回收功能。</p> 
<p><strong>缺点</strong></p> 
<p>垃圾回收时会暂停整个程序，并且需要扫描整个堆。会影响程序执行效率。</p> 
<h3><a id="_28"></a>三色标记法</h3> 
<p>在go中，这个问题是不太可以接受的，所以go后续采用三色标记算法来经行</p> 
<p>垃圾回收。</p> 
<p>三色标记算法的原则就是把堆中的对象分配到不同颜色的集合当中，通过</p> 
<p>黑，白，灰三色来标记对象。其中各颜色的含义是：</p> 
<p>黑：对象和它所直接引用的所有对象都被访问过。</p> 
<p>灰：这个对象已经被访问过，但是这个对象所直接引用的对象中，至少还有</p> 
<p>一个没有被访问到，表示这个对象正在枚举中。</p> 
<p>白：这个对象还没有被访问过，在初始阶段，所有对象都是白色，所有都枚</p> 
<p>举完仍是白色的对象将会被当做垃圾对象被清理。</p> 
<p><strong>根据这些定义，我们可以得出：</strong></p> 
<p>1.在可达性分析的初始阶段，所有对象都是白色，一旦访问了这个对象，那</p> 
<p>么就变成灰色，一旦这个对象所有直接引用的对象都访问过（或者没有引用</p> 
<p>其它对象），那么就变成黑色</p> 
<p>2.初始标记之后，GC Root节点变为黑色（GC Root不会是垃圾），GC Root</p> 
<p>直接引用的对象变为灰色</p> 
<p>3.正常情况下，一个对象如果是黑色，那么其直接引用的对象要么是黑色，</p> 
<p>要么是灰色，不可能是白色（如果出现了黑色对象直接引用白色对象的情</p> 
<p>况，就说明漏标了，就会导致对象误删，后面会介绍如何解决），这个特性</p> 
<p>也可以说是三色标记算法正确性保障的前提条件。</p> 
<p><strong>算法大致的流程是（初始状态所有对象都是白色）：</strong></p> 
<p>1.首先我们从GC Roots开始枚举，它们所有的直接引用变为灰色，自己变为</p> 
<p>黑色。可以想象有一个队列用于存储灰色对象，会把这些灰色对象放到这个</p> 
<p>队列中。</p> 
<p>2.然后从队列中取出一个灰色对象进行分析：将这个对象所有的直接引用变</p> 
<p>为灰色，放入队列中，然后这个对象变为黑色；如果取出的这个灰色对象没</p> 
<p>有直接引用，那么直接变成黑色。</p> 
<p>3.继续从队列中取出一个灰色对象进行分析，分析步骤和第二步相同，一直</p> 
<p>重复直到灰色队列为空。</p> 
<p>4.分析完成后仍然是白色的对象就是不可达的对象，可以作为垃圾被清理。</p> 
<p>5.最后重置标记状态。</p> 
<p><strong>并发标记可能出现的问题</strong></p> 
<p>1.本来为垃圾的对象变为非垃圾。</p> 
<p>此现象为产生了浮动垃圾，即原被标记为黑色的对象，在用户操作中失去了</p> 
<p>与父节点的连接，成为了垃圾，但是又被标为了黑灰色，则无法在最后被回</p> 
<p>收。</p> 
<p>该现象会占用不必要的资源，但是在下一轮gc操作后，会被清除，不会造成</p> 
<p>太大影响。</p> 
<p>2.本来不是垃圾的对象变为垃圾。</p> 
<p>在用户态执行的过程中，可能会将原本灰色结点引用的对象，变改为黑色结</p> 
<p>点去引用，此时会产生一个已经被标记为黑色对象下还引用一个白色对象的</p> 
<p>现象。此现象会产生很大的bug，即在gc回收时，会将白色对象清除，原本</p> 
<p>应该被引用的对象也会被清除，导致程序无法正常执行。</p> 
<h4><a id="_113"></a>解决办法</h4> 
<p>为解决此问题，增加了读写屏障与增量更新与原始快照(SATB)三个方法</p> 
<h5><a id="_116"></a>读写屏障</h5> 
<p>这里的屏障很简单，可以理解成就是在读写操作前后插入一段代码，用于记</p> 
<p>录一些信息、保存某些数据等，概念类似于AOP。</p> 
<h5><a id="_121"></a>增量更新</h5> 
<p>增量更新则是当黑色对象新增一个白色对象的引用时，就通过写屏障将这个</p> 
<p>引用关系记录下来。然后在重新标记阶段，再以这些引用关系中的黑色对象</p> 
<p>为根，再扫描一次，以此保证不会漏标。</p> 
<h5><a id="_128"></a>原始快照</h5> 
<p>原始快照则是针对被减少引用的对象经行的操作，在该对象减少引用前，进</p> 
<p>行写屏障操作，将被减少的对象记录下来，再断开之间的引用，后续将被记</p> 
<p>录的对象标记为黑色。这样会造成两个后果，被记录的对象是垃圾，需要回</p> 
<p>收，此时就造成了浮动垃圾，在下一轮gc中会被清理，如果被记录对象不是</p> 
<p>垃圾，则就避免了bug的产生。</p> 
<h5><a id="_139"></a>优缺点</h5> 
<p>增量更新可以有效避免过多的浮动垃圾的产生，但是原始快照效率更高，不</p> 
<p>需要再对原有的结点经行枚举，减少了多余操作，增量更新操作在重新标记</p> 
<p>时需要STW，原始快照的实现也更加的简单方便。在并发清理阶段或者不是</p> 
<p>状态转移，而是直接创建的新对象被黑色对象引用时，就无法经行原始快照</p> 
<p>操作，解决办法除了使用增量更新以外，也可以将新创建的对象直接标记为</p> 
<p>黑色，缺点虽然与原始快照一样会产生浮动垃圾，但是加快了速率，也更好</p> 
<p>实现。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/efc937471f14fc009c45c730bf3668b0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">各linux操作系统查看内核版本命令</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/3597c084f8bc727dfc9a1ca39f37e73d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Gradle版本与Java版本的对应关系</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>