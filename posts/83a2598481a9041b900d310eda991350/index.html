<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HashMap：学习总结 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HashMap：学习总结" />
<meta property="og:description" content="有关ConcurrentHashMap的学习总结我记录在了这一篇博文：ConcurrentHashMap学习总结
首先是HashMap的整体结构：
主体采用数组进行存储。当数组处的节点产生碰撞，会向下延伸，生成一条链表当超过成树阈值（8）且数组长度大于64后，采用红黑树进行存储（红黑树的结构复杂，但是查找效率高） HashTable的创建 jdk8以前：在创建的时候就会有一个Entry[] table来存储
jdk8以后：会在第一次put方法被调用的时候创建Entry[] 数组
数据的存储 通过Key的hashCode方法计算出值，再通过某种算法计算出数组中存储数据的空间的索引值，如果没有数据则存储。
计算索引的方式：key的hashCode方法计算出hash值，再用hash值与数组长度进行无符号右移(&gt;&gt;&gt;)，按位异或（^）、按位与（&amp;）计算出索引
如果key已经存在 – 检查hashCode是否一致。一致则更新数据 如果不一致，将会在索引位置上，生成一条链表来存储数据。
同时，会执行拉链法的数据查找，再这一条链表上进行key的equals方法比较（同时比较value和hashCode）。相等才进行数据更新
HashMap的插入过程 为什么初始数组长度必须为2的n次方？
hash &amp;（length - 1）使数组分布更加均匀，有效的减少了碰撞的发生
采用取余： hash &amp; (length - 1) == hash % length （当为2的n次幂时）但是位运算效率高很多
求近位数的算法
// 在算法之前会执行一次与MAXIMUM_CAPACITY的比较，超过则代入MAXIMUM_CAPACITY static final int tableSizeFor(int cap) { int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/83a2598481a9041b900d310eda991350/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-05T09:40:14+08:00" />
<meta property="article:modified_time" content="2020-08-05T09:40:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HashMap：学习总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>有关ConcurrentHashMap的学习总结我记录在了这一篇博文：<a href="https://blog.csdn.net/qq_41989109/article/details/107686904">ConcurrentHashMap学习总结</a></p> 
<p>首先是HashMap的整体结构：</p> 
<p> </p> 
<p><img alt="" src="https://images2.imgbox.com/d6/bf/1SC1ANnV_o.png"></p> 
<p> </p> 
<ol><li>主体采用数组进行存储。</li><li>当数组处的节点产生碰撞，会向下延伸，生成一条链表</li><li>当超过成树阈值（8）且数组长度大于64后，采用红黑树进行存储（红黑树的结构复杂，但是查找效率高）</li></ol> 
<p> </p> 
<p><img alt="image-20200714152901941" src="https://images2.imgbox.com/f2/ea/MQSAT62b_o.png"></p> 
<p> </p> 
<ul><li>HashTable的创建</li></ul> 
<blockquote> 
 <p>jdk8以前：在创建的时候就会有一个Entry[] table来存储</p> 
 <p>jdk8以后：会在第一次put方法被调用的时候创建Entry[] 数组</p> 
</blockquote> 
<ul><li>数据的存储</li></ul> 
<blockquote> 
 <p>通过Key的hashCode方法计算出值，再通过某种算法计算出数组中存储数据的空间的索引值，如果没有数据则存储。</p> 
 <p><span style="color:#ffbb66;">计算索引的方式</span>：key的hashCode方法计算出hash值，再用hash值与数组长度进行无符号右移(&gt;&gt;&gt;)，按位异或（^）、按位与（&amp;）计算出索引</p> 
</blockquote> 
<ul><li>如果key已经存在 – 检查hashCode是否一致。一致则更新数据</li></ul> 
<blockquote> 
 <p>如果不一致，将会在索引位置上，生成一条链表来存储数据。</p> 
 <p>同时，会执行拉链法的数据查找，再这一条链表上进行<span style="color:#86ca5e;">key的equals方法比较（同时比较value和hashCode）</span>。相等才进行数据更新</p> 
</blockquote> 
<h4><a name="t0"></a><a id="HashMap_29"></a>HashMap的插入过程</h4> 
<p><img alt="image-20200714153456010" src="https://images2.imgbox.com/1f/63/X4CHWZOl_o.png"></p> 
<p> </p> 
<blockquote> 
 <p><strong>为什么初始数组长度必须为2的n次方？</strong></p> 
 <p>hash &amp;（length - 1）使数组分布更加均匀，有效的减少了碰撞的发生</p> 
 <p>采用取余： hash &amp; (length - 1) == hash % length （当为2的n次幂时）但是位运算效率高很多</p> 
</blockquote> 
<p>求近位数的算法</p> 
<pre><code class="language-java">// 在算法之前会执行一次与MAXIMUM_CAPACITY的比较，超过则代入MAXIMUM_CAPACITY
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n &gt;&gt;&gt; 1;
    n |= n &gt;&gt;&gt; 2;
    n |= n &gt;&gt;&gt; 4;
    n |= n &gt;&gt;&gt; 8;
    n |= n &gt;&gt;&gt; 16;
    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}</code></pre> 
<p> </p> 
<p>算法执行过程：</p> 
<p> </p> 
<p><img alt="image-20200714154840933" src="https://images2.imgbox.com/ed/7f/DVv35grT_o.png"></p> 
<p>总共执行了32次移位操作</p> 
<p> </p> 
<p><img alt="image-20200714155118019" src="https://images2.imgbox.com/16/34/0OCzHHDQ_o.png"></p> 
<p> </p> 
<p><strong>HashMap常见参数</strong></p> 
<pre><code class="language-java">//根据泊松分布来确认，链表超过8的概率非常小。因为红黑树的空间占用比较大

// 树化为8，链化是6

// 当链表长度大于8会转换成红黑树
static final int TREEIFY_THRESHOLD = 8;
// 当红黑树的大小小于6的时候会转化成链表
static final int UNTREEIFY_THRESHOLD = 6;
// 数组长度大于64才可以转化为红黑树
static final int MIN_TREEIFY_CAPACITY = 64;
// HashMap的size不是指数组长度，而是指当前存储的节点个数
int size;
// 容量*负载因子
int threshold;
// 负载因子 0~1之间
int loadFactor;
</code></pre> 
<p><strong>loadFactor – 加载因子</strong>：</p> 
<ul><li> <p>表示HashMap的稀疏程度，影响<strong>hash操作到同一个数组位置的概率</strong></p> </li><li> <p>默认是0.75f，不建议修改。官方给出的一个比较科学的</p> </li><li> <p>数组的扩容是一个非常复杂的操作，很消耗性能，需要尽量避免hashmap的扩容</p> 
  <ul><li>过大 – 数组太满，容易发生碰撞。链表会较多。影响查询性能</li><li>过小 – 数组会经常扩容，耗费时间</li></ul></li></ul> 
<p><strong>HashMap的构造方法</strong></p> 
<pre><code class="language-java">public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}
</code></pre> 
<p> </p> 
<ul><li>尽量先预估存储的数值区间，再来创建HashMap，避免扩容操作</li></ul> 
<pre><code class="language-java">final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) {
    int s = m.size();
    if (s &gt; 0) {
        if (table == null) { // pre-size
            // 之所以要+1.0f，主要是为了避免tableSizeFor中更新index的时候产生的扩容
            float ft = ((float)s / loadFactor) + 1.0F;
            int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ?
                     (int)ft : MAXIMUM_CAPACITY);
            if (t &gt; threshold)
                threshold = tableSizeFor(t);
        }
        else if (s &gt; threshold)
            resize();
        for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) {
            K key = e.getKey();
            V value = e.getValue();
            putVal(hash(key), key, value, false, evict);
        }
    }
}</code></pre> 
<h4>成员方法</h4> 
<p><a id="put_136"></a>put方法（重点）</p> 
<p><strong>hash值计算</strong></p> 
<pre><code class="language-java">static final int hash(Object key) {
    // 主要目的：防止高位变化较大，而低位变化较小，从而导致hash冲突
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
}</code></pre> 
<p> </p> 
<p> </p> 
<p><img alt="image-20200714162803208" src="https://images2.imgbox.com/8d/dd/sOU59sBl_o.png"></p> 
<p> </p> 
<pre><code class="language-java">final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        // 在第一次put的时候会创建Node数组
        n = (tab = resize()).length;
    // 这里执行了hash计算的操作。没有出现碰撞
    // p已经在这里实现了赋值，就是hash计算后的节点
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        // 如果没有碰撞，则直接put
        // 这里的null代表的是拉链法 链表 的下一个结点暂时为null（还没有碰撞产生）
        tab[i] = newNode(hash, key, value, null);
    else {
        Node&lt;K,V&gt; e; K k;
        // 判断key是否相同
        if (p.hash == hash &amp;&amp;
            // 如果key相同或者key与k相等
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        // 判断是否是树节点
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        else {
            // 链表遍历
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) {
                    p.next = newNode(hash, key, value, null);
                    // 如果结点大于8，那么链表成树
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                }
                // 链表上出现相同的key
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            }
        }
        // 如果当前位置存在结点
        if (e != null) { // existing mapping for key
            // 只修改值
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }
    }
    // 记录map的修改次数
    ++modCount;
	// 插入成功，size+1， 当大于阈值，执行扩容    
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}</code></pre> 
<p> </p> 
<p>红黑树转换</p> 
<pre><code class="language-java">final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) {
    int n, index; Node&lt;K,V&gt; e;
    // 如果数组长度小于64，会执行扩容，而不是建树
    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
        resize(); // 倍增扩容
    // 判断当前桶中的节点是否为null
    else if ((e = tab[index = (n - 1) &amp; hash]) != null) {
        // hd -- 头结点，tl -- 尾结点
        TreeNode&lt;K,V&gt; hd = null, tl = null;
        // 将链表里的每一个节点替换成TreeNode
        do {
            // 将Node转换为TreeNode
            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);
            // p作为树的根节点
            if (tl == null)
                hd = p;
            else {
                // 
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);
        // 如果根节点不为空，执行建树
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    }
}</code></pre> 
<p> </p> 
<p>扩容方法 - resize</p> 
<pre><code class="language-java">final Node&lt;K,V&gt;[] resize() {
    Node&lt;K,V&gt;[] oldTab = table;
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    int oldThr = threshold;
    // 新的容量和阈值
    int newCap, newThr = 0;
    if (oldCap &gt; 0) {
        // 进行扩容。如果超过最大容量，那么不变，阈值变为最大
        if (oldCap &gt;= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        // 如果扩容后满足条件，那么新阈值等于旧阈值翻倍
        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;
                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr &lt;&lt; 1; // double threshold
    }
    // 通过阈值的方式来创建HashMap
    else if (oldThr &gt; 0) // initial capacity was placed in threshold
        newCap = oldThr;
    else {               // zero initial threshold signifies using defaults
        //阈值为零，那么使用默认值
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    // 扩容超界或者旧容量小于默认容量
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    threshold = newThr;
    @SuppressWarnings({"rawtypes","unchecked"})
    // 重新创建数组
    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];
    table = newTab;
    if (oldTab != null) {
        // 将旧数组的数组放到新数组里
        for (int j = 0; j &lt; oldCap; ++j) {
            Node&lt;K,V&gt; e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null;
                if (e.next == null)
                    newTab[e.hash &amp; (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    // 树节点建树
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                else { // preserve order
                    // 链表复制
                    Node&lt;K,V&gt; loHead = null, loTail = null;
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;
                    Node&lt;K,V&gt; next;
                    do {
                        next = e.next;
                        // 变化的高位为0
                        if ((e.hash &amp; oldCap) == 0) {
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        }
                        else {
                            // 高位变为1
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    if (loTail != null) {
                        loTail.next = null;
                        // 将结点放在原位置
                        newTab[j] = loHead;
                    }
                    if (hiTail != null) {
                        hiTail.next = null;
                        // 将节点放在原位置+旧容量的地方
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}</code></pre> 
<p> </p> 
<blockquote> 
 <p>在扩容时，不需要重新计算hash，<strong>只需要看原来的hash新增的那个高位bit是1还是0</strong>.</p> 
 <ul><li>0索引不变</li><li>1变成”原索引 + oldCap“</li></ul> 
 <p> </p> 
</blockquote> 
<p> </p> 
<p> </p> 
<p><img alt="image-20200714200434457" src="https://images2.imgbox.com/28/31/1ZDXp0Hc_o.png"></p> 
<p> </p> 
<h4>HashMap问题整理</h4> 
<ol><li>设置初始化参数</li></ol> 
<p> </p> 
<p><img alt="image-20200714204411369" src="https://images2.imgbox.com/6d/3b/ffNLM6F6_o.png"></p> 
<blockquote> 
 <p>如果要存储7个元素。那么初始化值最好设置为 7 / 0.75 + 1.0f = 10</p> 
</blockquote> 
<h4><a name="t3"></a><a id="_356"></a>补充，链表的头插法和尾插法：</h4> 
<p><strong>头插法</strong>：（Jdk 1.7）相当于将其他结点往后移，然后从首部插入结点 – 考虑到新插入的节点可能会被优先访问到</p> 
<pre><code class="language-java">void addEntry(int hash, K key, V value, int bucketIndex) {
    if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) {
        resize(2 * table.length);
        hash = (null != key) ? hash(key) : 0;
        bucketIndex = indexFor(hash, table.length);
    }

    createEntry(hash, key, value, bucketIndex);
}

void createEntry(int hash, K key, V value, int bucketIndex) {
    Entry&lt;K,V&gt; e = table[bucketIndex];
    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
    size++;
}</code></pre> 
<p>头插法的问题：在多线程的情况下，在扩容的时候，会导致环形链表的出现，最终导致线程死锁</p> 
<p><img alt="img" src="https://images2.imgbox.com/9e/73/0S74QdrC_o.png"></p> 
<p><strong>尾插法</strong>：（jdk 1.8）遍历到链表尾部添加结点。</p> 
<p> </p> 
<p>这是putVal方法中的一段：</p> 
<pre><code class="language-java">for (int binCount = 0; ; ++binCount) {
    // 其实就是遍历到尾部进行插入，保证链表的顺序
    if ((e = p.next) == null) {
        p.next = newNode(hash, key, value, null);
        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
            treeifyBin(tab, hash);
        break;
    }
    if (e.hash == hash &amp;&amp;
        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
        break;
    p = e;
}</code></pre> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a7a9f36bd1ce32c34752a983e1d15d0e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">日志系统：一条SQL更新语句是如何执行的？（基础篇02）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f032aaaf118a9704673cfd21161501b8/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">nested exception is com.spire.doc.packages.sprfIc</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>