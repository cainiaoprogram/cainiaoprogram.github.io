<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>wince usb驱动代码详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="wince usb驱动代码详解" />
<meta property="og:description" content="随着USB设备的不断增加，我们这些开发人员也就多了对USB设备进行驱动程序开发的工作。但是对于很多初学者来说，存在以下三个困难：
一是对WinCE的驱动程序结构了解得太少，没办法得心应手的专注于驱动程序的开发工作；
二是对WinCE自带的USB驱动程序的例子没有弄懂，看到一大堆文件夹结构和源程序思维混乱；
三是几乎没有什么中文的参考资料，不知如何下手。
第三条是很多开发人员都遇到的，我也一样，很多朋友问我有没有什么资料，我也只能说抱歉，因为我也同样有这个问题，一切都靠自己的黑暗中摸索，因此本文不谈第三条。
第一条是可以找到资料的，如《Windows CE .NET系统分析及实验教程》，因此本文也不打算在此花费大量笔墨。
这样，本文的着重点就在第二条上面了，通过本文，我希望能让更多的朋友理解Windows CE下对USB设备的驱动模型及样例程序中的实现过程，以样例代码为基础理顺USB设备驱动程序的开发思路。同样，本文的读者对象预期是入门者和准备着手USB驱动开发的人员，驱动开发高手自然就当一笑吧。同时写本文的目的也是履行我半年前答应很多朋友的诺言，并向我的慵懒致歉。
好了，在看样例程序之前，我们还有些东西需要了解，我们就先来看下图：
在此图中，我们可以非常清晰的看到主机和物理外设之间的结构方式，在主机端，通过USBD模块和HCD模块使用默认的PIPE访问一个通用的逻辑设备，实际上就是说USBD和HCD是一组抽象出来的访问所有USB设备的逻辑接口，它们负责管理所有USB设备的连接、加载、移除、数据传输和通用的配置。其中HCD是主机控制驱动，是为USBD提供底层的功能访问服务，USBD是USB总线驱动，位于HCD的上层，利用HCD的服务提供较高层次抽象的功能。
由于HCD和USBD都是面向的一致的逻辑设备接口，那么对于各种各样的物理设备，就需要有唯一对应的设备驱动程序，这就是上图中最上层的特殊的PIPE所连接的物理设备和USB设备驱动程序。
有了对这个结构的认识，我们可以明确的是我们要写的就是最上端的USB设备驱动程序，在WINCE的样例程序中也称为USB Client Driver，它是工作于USBD之上，所以实际上我们的工作就变成了利用USBD提供的接口针对特定的物理设备来完成USB设备驱动程序，而暂时与其他的部分无关。
好了，先到这，接下来就准备看一些具体的东西吧！ 接下来，我们就来分析一下CE中的样例程序，我用的是4.2版本的，所以下面的内容是4.2版本中的程序。这里的程序是通过文件夹的形式组织在一起的，所以我们还是像以前学习CE的时候那样，先来了解与此相关的文件夹结构，如下图。
在USB文件夹下，分成了CLASS,CLIENTS,COMMON,HCD,INC,USBD几个文件夹，其中INC和COMMON里面有一个lock.c的程序，这个程序很明显是将要被其他USB有关的驱动程序所使用的一个锁，代码很简单，只是一个类似临界区的封装体，可以保护多线程对同一内存区域的读写访问，可以先不去管它。CLIENTS文件夹可能最初微软的开发人员是用来放置设备驱动程序的，但是后来没有放，而发布的时候也没有删除，所以遗留了下来，里面是个空的文件夹，所以没用实际用处。USBD和HCD是前述的底层驱动，里面含有很多子文件夹和程序，由于我们只针对USB设备驱动，因此对这两部分不做分析，不兴趣的朋友可以自己去了解。
重点就在CLASS文件夹了，展开来看，里面又包含了COMMON、HID、PRINTER、STORAGE几个文件夹，同样，COMMON里面存放的源程序是为HID、PRINTER、STORAGE所共有的。HID是USB输入设备如键盘/鼠标的样例驱动程序，PRINTER是USB打印机的样例驱动程序，STORAGE是USB存储设备如U盘的样例程序。
我们此次以USB存储设备为例，所以再来展开STORAGE文件夹，其中的INC文件夹里面是头文件，CLASS是USB存储设备的驱动程序，DISK是磁盘驱动程序。这里为什么有两个驱动程序呢，我来简要解释一下。
驱动程序工作在硬件与操作系统之间，它有两个功能，一个是 将操作系统转发来的操作以符合指定硬件设备的形式控制硬件设备，另一个是向操作系统提供这个访问接口。比如说U盘，一方面驱动程序要把操作系统对U盘的识别、读、写等操作转换成U盘的动作，另一方面又告诉操作系统这是个U盘，可以当成一个文件夹或文件系统来用，能够接受标准的文件操作命令。所以此处存在两个驱动。
另外还有一个文件夹，WINCE420/PUBLIC/COMMON/DDK/INC，这里面是与设备驱动有关的头文件，对于USB设备，相关的文件有USB100.H, USBTYPES.H, USBDI.H，这里面前两个里面关于USB的定义是完全符合USB规范的，不是随便定义出来的，而USBDI.H文件里的内容就是USBD总线驱动程序向USB设备驱动程序提供的接口描述，在开发USB设备驱动时必须要包含此头文件，这样才可以得到USBD接口的原型。
此前，我们共同了解了USB驱动在CE中的位置结构，也了解了样例驱动程序的文件夹结构，接下来，我们就要了解一下USBD为我们提供了哪些接口来实现设备访问以及驱动程序管理的功能。找到USBDI.H，不要告诉我你找不到吧，不管你用什么编辑器，记事本也好，PB也好，VC/EVC或者VS都行，打开它，我们一起来了解一下USBD为我们提供了什么。
我们首先看到的一个大的结构体就是_USB_DRIVER_SETTINGS，注意这个结构体不是USB规范中的USB设备描述，而是为了CE设备管理器加载USB设备驱动程序方便而建立的。该结构体中对供应商描述、设备描述和Interface的描述是用来匹配注册表中对USB设备驱动的注册表键，当设备管理器发现你设备的这些值与注册表中的这些值相符时，就会加载你的驱动。也就是说它是与你的设备唯一对应的东西，是一种标识。该结构体的供应商部分的描述需要根据你的设备的供应商信息来填，设备描述的设备类、子类、协议等可以在USB规范中找到，在USB100.H头文件中也有一部分，在后面的样例程序中也定义了一部分。
在接下来有三个函数是必须由USB设备驱动程序实现的，这也就是我们在MSDN里或其他CE的文档里所看到的，这几个函数就是：
USBDeviceAttach：设备加载的时候由系统调用
USBInstallDriver：设备第一次加载的时候由系统调用，用来安装注册表配置以便搜索设备
USBUnInstallDriver：设备移除后清理由上一个函数写入的注册表配置
这样在我们的驱动程序中就一定要按照这三个函数的原型来实现，否则就不能为设备管理器所识别。其实除了这三个，个我觉得第四个也是必须的，这就是一个函数指针所指向的函数：
*LPDEVICE_NOTIFY_ROUTINE
这个指针所指向的函数是用来接收通知消息的，既然微软说任何USB设备必须实现USB_CLOSE_DEVICE消息的响应，那么这个指针所指向的函数自然也就是必须要实现的了。
继续向下看，是一组函数的原型，这些函数就是USBD向设备驱动程序提供的服务接口，有些函数是可以任意调用的，用来完成版本信息读取、注册表操作和设备驱动程序注册，这些函数有：
GetUSBDVersion RegisterClientDriverID UnRegisterClientDriverID RegisterClientSettings
UnRegisterClientSettings OpenClientRegistryKey
还有大量的函数是必须通过指针调用的，通常只允许在驱动程序中调用，为了方例使用，在这里给出一个_USB_FUNCS的结构体，每一个结构体成员对应了一个函数指针，这样在驱动程序中要想使用USBD函数只能通过一个结构体变量来进行了，在这里我们要记住这个结构体的名字，并且微软还对这个结构体变量进行了以下的类型定义：
typedef struct _USB_FUNCS USB_FUNCS, * PUSB_FUNCS, * LPUSB_FUNCS;
typedef struct _USB_FUNCS const * PCUSB_FUNCS;
typedef struct _USB_FUNCS const * LPCUSB_FUNCS;
好了，到此我们发现，大部分的USB工作都已经被USBD完成了，我们为了实现自己的设备驱动，只需要利用这些指针或函数，来实现四个我们自己的函数，然后在其中匹配上我们自己的设备就可以了。是不是忒简单，没错，总不能刚开始就把自己吓得不行，那样后面可就没法做了。
在上次了解了所有USBD接口函数以后，我们已经有了很多基础知识了，回顾USB样例的文件夹结构，我们还能记得USB/CLASS/COMMON这个文件夹下是存放所公共部分的源程序，它是微软专门抽象出来的能为大多数USB设备驱动程序服务的一些结构体以及函数的封装，我们这次再来概略的了解一下这里面的源程序。
这里面包含了三个程序，分别是：
remlock usbclient utils 下面我们分别来了解一下这三个程序的功能和接口，很显然，USB设备驱动程序肯定是会用到这其中的一部分函数的，因此我们不一定需要读懂这其中的每一行，但至少要对这些函数有个印象，不至于在读驱动程序时不知道函数的来源。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c4547d12a99674847610aa9e3e08a6e5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2009-12-17T17:59:00+08:00" />
<meta property="article:modified_time" content="2009-12-17T17:59:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">wince usb驱动代码详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>随着USB设备的不断增加，我们这些开发人员也就多了对USB设备进行驱动程序开发的工作。但是对于很多初学者来说，存在以下三个困难：<br>        一是对WinCE的驱动程序结构了解得太少，没办法得心应手的专注于驱动程序的开发工作；<br>        二是对WinCE自带的USB驱动程序的例子没有弄懂，看到一大堆文件夹结构和源程序思维混乱；<br>        三是几乎没有什么中文的参考资料，不知如何下手。</p> 
<p>        第三条是很多开发人员都遇到的，我也一样，很多朋友问我有没有什么资料，我也只能说抱歉，因为我也同样有这个问题，一切都靠自己的黑暗中摸索，因此本文不谈第三条。<br>        第一条是可以找到资料的，如《Windows CE .NET系统分析及实验教程》，因此本文也不打算在此花费大量笔墨。<br>        这样，本文的着重点就在第二条上面了，通过本文，我希望能让更多的朋友理解Windows CE下对USB设备的驱动模型及样例程序中的实现过程，以样例代码为基础理顺USB设备驱动程序的开发思路。同样，本文的读者对象预期是入门者和准备着手USB驱动开发的人员，驱动开发高手自然就当一笑吧。同时写本文的目的也是履行我半年前答应很多朋友的诺言，并向我的慵懒致歉。</p> 
<p>        好了，在看样例程序之前，我们还有些东西需要了解，我们就先来看下图：</p> 
<p> </p> 
<p>         在此图中，我们可以非常清晰的看到主机和物理外设之间的结构方式，在主机端，通过USBD模块和HCD模块使用默认的PIPE访问一个通用的逻辑设备，实际上就是说USBD和HCD是一组抽象出来的访问所有USB设备的逻辑接口，它们负责管理所有USB设备的连接、加载、移除、数据传输和通用的配置。其中HCD是主机控制驱动，是为USBD提供底层的功能访问服务，USBD是USB总线驱动，位于HCD的上层，利用HCD的服务提供较高层次抽象的功能。</p> 
<p>        由于HCD和USBD都是面向的一致的逻辑设备接口，那么对于各种各样的物理设备，就需要有唯一对应的设备驱动程序，这就是上图中最上层的特殊的PIPE所连接的物理设备和USB设备驱动程序。</p> 
<p>        有了对这个结构的认识，我们可以明确的是我们要写的就是最上端的USB设备驱动程序，在WINCE的样例程序中也称为USB Client Driver，它是工作于USBD之上，所以实际上我们的工作就变成了利用USBD提供的接口针对特定的物理设备来完成USB设备驱动程序，而暂时与其他的部分无关。</p> 
<p>        好了，先到这，接下来就准备看一些具体的东西吧！ </p> 
<p>接下来，我们就来分析一下CE中的样例程序，我用的是4.2版本的，所以下面的内容是4.2版本中的程序。这里的程序是通过文件夹的形式组织在一起的，所以我们还是像以前学习CE的时候那样，先来了解与此相关的文件夹结构，如下图。</p> 
<p> </p> 
<p>        在USB文件夹下，分成了CLASS,CLIENTS,COMMON,HCD,INC,USBD几个文件夹，其中INC和COMMON里面有一个lock.c的程序，这个程序很明显是将要被其他USB有关的驱动程序所使用的一个锁，代码很简单，只是一个类似临界区的封装体，可以保护多线程对同一内存区域的读写访问，可以先不去管它。CLIENTS文件夹可能最初微软的开发人员是用来放置设备驱动程序的，但是后来没有放，而发布的时候也没有删除，所以遗留了下来，里面是个空的文件夹，所以没用实际用处。USBD和HCD是前述的底层驱动，里面含有很多子文件夹和程序，由于我们只针对USB设备驱动，因此对这两部分不做分析，不兴趣的朋友可以自己去了解。</p> 
<p>        重点就在CLASS文件夹了，展开来看，里面又包含了COMMON、HID、PRINTER、STORAGE几个文件夹，同样，COMMON里面存放的源程序是为HID、PRINTER、STORAGE所共有的。HID是USB输入设备如键盘/鼠标的样例驱动程序，PRINTER是USB打印机的样例驱动程序，STORAGE是USB存储设备如U盘的样例程序。</p> 
<p>        我们此次以USB存储设备为例，所以再来展开STORAGE文件夹，其中的INC文件夹里面是头文件，CLASS是USB存储设备的驱动程序，DISK是磁盘驱动程序。这里为什么有两个驱动程序呢，我来简要解释一下。</p> 
<p>        驱动程序工作在硬件与操作系统之间，它有两个功能，一个是 将操作系统转发来的操作以符合指定硬件设备的形式控制硬件设备，另一个是向操作系统提供这个访问接口。比如说U盘，一方面驱动程序要把操作系统对U盘的识别、读、写等操作转换成U盘的动作，另一方面又告诉操作系统这是个U盘，可以当成一个文件夹或文件系统来用，能够接受标准的文件操作命令。所以此处存在两个驱动。</p> 
<p>        另外还有一个文件夹，WINCE420/PUBLIC/COMMON/DDK/INC，这里面是与设备驱动有关的头文件，对于USB设备，相关的文件有USB100.H, USBTYPES.H, USBDI.H，这里面前两个里面关于USB的定义是完全符合USB规范的，不是随便定义出来的，而USBDI.H文件里的内容就是USBD总线驱动程序向USB设备驱动程序提供的接口描述，在开发USB设备驱动时必须要包含此头文件，这样才可以得到USBD接口的原型。</p> 
<p>此前，我们共同了解了USB驱动在CE中的位置结构，也了解了样例驱动程序的文件夹结构，接下来，我们就要了解一下USBD为我们提供了哪些接口来实现设备访问以及驱动程序管理的功能。找到USBDI.H，不要告诉我你找不到吧，不管你用什么编辑器，记事本也好，PB也好，VC/EVC或者VS都行，打开它，我们一起来了解一下USBD为我们提供了什么。</p> 
<p>        我们首先看到的一个大的结构体就是_USB_DRIVER_SETTINGS，注意这个结构体不是USB规范中的USB设备描述，而是为了CE设备管理器加载USB设备驱动程序方便而建立的。该结构体中对供应商描述、设备描述和Interface的描述是用来匹配注册表中对USB设备驱动的注册表键，当设备管理器发现你设备的这些值与注册表中的这些值相符时，就会加载你的驱动。也就是说它是与你的设备唯一对应的东西，是一种标识。该结构体的供应商部分的描述需要根据你的设备的供应商信息来填，设备描述的设备类、子类、协议等可以在USB规范中找到，在USB100.H头文件中也有一部分，在后面的样例程序中也定义了一部分。</p> 
<p>        在接下来有三个函数是必须由USB设备驱动程序实现的，这也就是我们在MSDN里或其他CE的文档里所看到的，这几个函数就是：<br>         USBDeviceAttach：设备加载的时候由系统调用<br>         USBInstallDriver：设备第一次加载的时候由系统调用，用来安装注册表配置以便搜索设备<br>         USBUnInstallDriver：设备移除后清理由上一个函数写入的注册表配置</p> 
<p>         这样在我们的驱动程序中就一定要按照这三个函数的原型来实现，否则就不能为设备管理器所识别。其实除了这三个，个我觉得第四个也是必须的，这就是一个函数指针所指向的函数：<br>         *LPDEVICE_NOTIFY_ROUTINE<br>这个指针所指向的函数是用来接收通知消息的，既然微软说任何USB设备必须实现USB_CLOSE_DEVICE消息的响应，那么这个指针所指向的函数自然也就是必须要实现的了。</p> 
<p>        继续向下看，是一组函数的原型，这些函数就是USBD向设备驱动程序提供的服务接口，有些函数是可以任意调用的，用来完成版本信息读取、注册表操作和设备驱动程序注册，这些函数有：<br>GetUSBDVersion    RegisterClientDriverID    UnRegisterClientDriverID    RegisterClientSettings<br>UnRegisterClientSettings    OpenClientRegistryKey</p> 
<p>        还有大量的函数是必须通过指针调用的，通常只允许在驱动程序中调用，为了方例使用，在这里给出一个_USB_FUNCS的结构体，每一个结构体成员对应了一个函数指针，这样在驱动程序中要想使用USBD函数只能通过一个结构体变量来进行了，在这里我们要记住这个结构体的名字，并且微软还对这个结构体变量进行了以下的类型定义：<br>typedef struct _USB_FUNCS USB_FUNCS, * PUSB_FUNCS, * LPUSB_FUNCS;<br>typedef struct _USB_FUNCS const * PCUSB_FUNCS;<br>typedef struct _USB_FUNCS const * LPCUSB_FUNCS;</p> 
<p>        好了，到此我们发现，大部分的USB工作都已经被USBD完成了，我们为了实现自己的设备驱动，只需要利用这些指针或函数，来实现四个我们自己的函数，然后在其中匹配上我们自己的设备就可以了。是不是忒简单，没错，总不能刚开始就把自己吓得不行，那样后面可就没法做了。</p> 
<p>在上次了解了所有USBD接口函数以后，我们已经有了很多基础知识了，回顾USB样例的文件夹结构，我们还能记得USB/CLASS/COMMON这个文件夹下是存放所公共部分的源程序，它是微软专门抽象出来的能为大多数USB设备驱动程序服务的一些结构体以及函数的封装，我们这次再来概略的了解一下这里面的源程序。</p> 
<p>        这里面包含了三个程序，分别是：<br>        remlock        usbclient        utils <br>        下面我们分别来了解一下这三个程序的功能和接口，很显然，USB设备驱动程序肯定是会用到这其中的一部分函数的，因此我们不一定需要读懂这其中的每一行，但至少要对这些函数有个印象，不至于在读驱动程序时不知道函数的来源。</p> 
<p>        remlock程序是一个移除设备的锁，利用这个结构体<br>   typedef struct _REMOVE_LOCK <br>   { <br>       BOOL Removed;<br>       LONG IoCount;<br>       HANDLE RemoveEvent; <br>   } REMOVE_LOCK, *PREMOVE_LOCK<br>来实现在设备移除时进行的同步控制。其中Removed成员是对设备是否已经移除的标识，IoCount成员是对设备进行访问的数量，这也是驱动程序中常用的行为，就像此前我们看到的那个Lock程序一样，RemoveEvent是一个内核事件，熟悉WIN32编程的应该都很清楚，它是内核通知应用程序的一种方式，也是线程这间并发控制的一种手段，如果不熟悉，还是像我在以前文章中提到的那样，一定要找WINDOWS高级编程之类的书把它学明白，否则就很难控制驱动程序了。<br>        利用它实现的那几个函数就不说了，与临界区的用法是一样的。另外提一句，在此程序中有类似InterlockedIncrement这样的函数，这种函数是WIN32 API函数，专门用来提供多线程对同一变量的同步访问的，可以通过MSDN查到详细用法。</p> 
<p>        usbclient程序是对USBD进行包装以供USB设备驱动程序使用的函数接口，通过usbclient.h我们可以发现里面是关于数据传输、属性设置、状态描述和复位的一组函数原形的定义，我们再看usbclient.c文件，这些函数大部分都拥有一个LPCUSB_FUNCS类型的参数，回顾上次我们对USBD的了解可知，正是通过这一参数才能访问USBD提供的服务功能，浏览一下函数的实现发现，确实每个函数都是通过这个参数调用了USBD的函数，然后处理调用后的结果，所以这里只是多了一层封装，使得驱动程序的编写更加清晰易于维护。</p> 
<p>        另外，这里我们要留意一下IssueBulkTransfer()、IssueInterruptTransfer()、IssueVendorTransfer() 这三个函数，它们实现了通用的Bulk传输、中断传输和自定义的传输方式，在驱动程序中要用得到。</p> 
<p>        utils程序很简单，是对注册表操作的封装，利用_REG_VALUE_DESCR这个结构体和GetSetKeyValues()函数可以方便的访问注册表，在驱动程序的安装中会用得较多。</p> 
<p>        又说了这么多东西，虽然没有看多少程序，但我们又离驱动程序近了一层，至少知道了很多函数是要在驱动程序中用到的，如果有兴趣，可以具体阅读每一个函数的实现方法，但我觉得这并不影响对驱动程序的开发。如果是我写驱动，在没有特别的情况下，我会把这些公用的源程序照搬过来，这可是能极大的缩短开发周期的事哦！</p> 
<p> 正如所料，接下来我们就进入到DRIVERS/USB/CLASS/STORAGE/CLASS文件夹下，接触USB设备驱动程序。</p> 
<p>         我们先来了解两个头文件，分别是STORAGE/INC/usbmsc.h和STORAGE/CLASS/usbmscp.h，其中前者是USB存储设备公用的头文件，后者是需要按照自己的设备更改的头文件。我们先来看前者。</p> 
<p>        在usbmsc.h这个头文件中，前边定义了很多常量，包括子类和协议的常量，这是从哪里来的呢？前文我们已经提到过，这些量值是依据USB设备规范得来的，在规范上都作了定义，所以此处的值必须与USB规范中的相一致。再向下的命令块结构体和数据块结构体是用来与USB设备通讯用的，可以通过这两个结构体的实例与USB设备传输数据。 下面的函数原型就不说了，前文提到过，在这里只记得有这几个函数就行了。</p> 
<p>        再来看usbmscp.h这个头文件，这个头文件是要按照自己的需要和USB设备来进行修改的，比如DRIVER_NAME_SZ是驱动程序的名字，RESET_TIMEOUT 是一个超时的默认值。还有很重要的一个就是USBMSC_DRIVER_SETTINGS的设置，这个设置是与USBDI.H中的USB_DRIVER_SETTINGS结构体一一对应的，为了符合我自己的设备，通常要把dwVendorId和dwProductId等设置成设备的对应值，比如我的U盘的VendorID是0x058F，ProductID是0x9321,那我就会把这两个值对应的写在相应的位置上。同时在系统注册表中也会利用这两个值修改注册表的键以便设备管理器可以顺利的找到我的设备驱动。</p> 
<p>        下面还有一个_USBMSC_DEVICE结构体，它是用来描述你自己的USB存储设备的，是封装了USBD函数表指针、磁盘设备指针、管道和配置项的最重要的数据结构，在驱动程序实现上此数据结构就是重点的参数，鉴于样例程序对每一个结构体元素都作了明确的注释，此处我就不一一描述了，它就像C++中的类一样，是最后把一些小类组合起来的可以最终使用的结构。</p> 
<p>        好了，对这两个头文件有所了解以后，我们就进入最关键的部分，源程序。我们接下来来看usbmsc.c这个文件。为什么要先看这个文件而不是同一文件夹下的其他几个文件呢？我来解释一下。在这个文件夹中有一个usbmsc.def的文件，大家都知道它是定义了导出函数的，通常与它同名的程序文件都会含有DllEntry的入口，既然入口在这，那我们自然就先来看这个文件了。如果用到了其他的文件，再看不迟。</p> 
<p>        这可是一个有1000多行的源程序，但不要害怕，我们只看最主要的，别的函数的实现你可以自己去研究。首先看到文件的DllEntry入口之前有5个函数原型的定义，从函数名上就可以知道这个函数的功能了，很显然这几个函数是程序实现过程中被调用的，所以目前知道功能就行了，不用了解实现方法。忘了说一句，这个程序中包含了bot.h和cbit.h两个头文件，可见程序中是要用到它们的功能的，不过先不管它，继续往下看。</p> 
<p>        DllEntry入口函数的下面，就是USBInstallDriver()这个函数了，它的作用是进行与USB设备相关的注册表操作，主要的语句是：<br>bRc = RegisterClientDriverID( wsUsbDeviceID );<br>bRc = RegisterClientSettings( szDriverLibFile, wsUsbDeviceID, NULL, &amp;usbDriverSettings );<br>即先注册设备类别，然后是设备细节。 同样，USBUnInstallDriver()函数是以相反的顺序解除注册信息的。 这几个与注册有关的函数在前面我们提到过，是由USBD接口提供的，这里我们可以看到USBD对设备驱动程序的重要性。 <br>在继续向下看，我们发现了USBDeviceAttach()函数，这可是最重要的地方了，当有USB设备插入插口以后，操作系统是如何识别它的呢，如何将其做为一个文件夹加以访问的呢？我们就来解开这里的谜团。<br>        为了我们方便说明，我将此程序简化如下：</p> 
<p> </p> 
<p>         后面的程序将以此行号进行说明。</p> 
<p> 我们来看程序的第4行，这里有一个判断语句，它是在判断插入的设备是否是USBMSC_INTERFACE_CLASS类型的，这个常量是在usbmsc.h文件中定义的，也就是说如果设备不是USB存储设备，那么就结束这个函数，也就是此驱动只能处理USB存储设备。</p> 
<p>        当发现设备符合此驱动程序的要求后，就通过函数ParseUsbDescriptors()来解析这个设备，这个函数在下面的程序中将被实现，我们可以看一下该函数的函数体，很显然，它是在为设备进行各种配置，这就不多说它了。</p> 
<p>        再往下，分配内存，设置标志，从注册表中读取信息。注意，这里读取到的注册表信息是Drivers//USB//ClientDrivers//Mass_Storage_Class和bInterfaceSubClass变量组合成的注册表键下的值，具体可参阅源程序，这个注册表键下放置的内容是<br>[HKEY_LOCAL_MACHINE/Drivers/USB/ClientDrivers/Mass_Storage_Class/6]<br>"DLL"="USBDISK6.DLL"<br>"Prefix"="DSK"<br>"Folder"="USB Disk"<br>"IOCTL"=dword:4<br>"IClass"="{A4E7EDDA-E575-4252-9D6B-4195D48BB865}"<br>由此可以看出，通过此处的注册表读取，驱动程序可以知道这个设备将通过哪种形式以及哪个DLL向操作系统提供接口。同时也为后续的操作进行了准备。</p> 
<p>        最关键的部分就在接下来的LoadDriver()那句，加载了另一个驱动程序的DLL文件，就是上述注册表中的USBDISK6.DLL文件，计数器增一，取到该文件中UsbDiskAttach函数及UsbDiskDetach函数的地址，注册事件通知处理函数，然后调用了该DLL文件中的UsbDiskAttach函数。</p> 
<p>        由此可见，USB设备驱动程序有两层功能，一方面是识别出指定的设备并进行配置，另一方面按照要求调用更高层的驱动程序来向操作系统提供接口。当调用了USBDISK6.DLL后，操作系统就会按该文件中的程序以一个磁盘的形式或文件夹的形式进行处理，通过文件系统的操作，就可以对其进行读写控制了。我们也可以看一下HID设备的这个函数，它也是通过这种方式让操作系统知道把USB设备识别成鼠标设备的。</p> 
<p>        前文我们说过还有一个通知消息的回调函数，我们在刚才的程序体中已经发现通过：<br>UsbFuncs-&gt;lpRegisterNotificationRoutine( hDevice, UsbDeviceNotify, pUsbDevice );<br>语句已经对这个函数进行了设置。我们再向下来看一下这个函数的函数体。这个函数很简单，只要对USB_CLOSE_DEVICE消息进行处理，既然是要关闭USB设备，那么调用USBDISK6.DLL中的Detach函数是必须的，让上层的驱动程序进行释放，然后将引用计数减一，如果不再有设备引用此驱动程序，则FreeLibrary()，仅此而已。</p> 
<p>        其余的函数可以再仔细研究一下，在此就不详细描述了，接下来我们要弄明白的就是到底操作系统是如何通过抽象的DISK读写具体的设备呢？</p> 
<p>带着上次留下的疑问，我们继续来学习操作系统如何通过USBDISK读写USB设备的。我们先看USB/CLASS/STORAGE/DISK/SCSI2/usbdisk6.def文件。在这个文件中可以看到，该DLL一共导出了14个函数，其中两个是上次内容当中被设备驱动程序调用的UsbDiskAttach和UsbDiskDetach，余下的是一组以DSK开头的流驱动接口，易见，USBDISK是以流驱动的形式向操作系统提供服务的。</p> 
<p>        为了清晰起见，以下大量的程序我们并不学习，而只关心设备读写，因此我们来看DISK.C这个程序文件。找到DSK_Read和DSK_Write两个函数，令我们大失所望，因为这两个函数都是形如<br>UNREFERENCED_PARAMETER(pDevice);<br>UNREFERENCED_PARAMETER(pBuffer);<br>UNREFERENCED_PARAMETER(BufferLength);</p> 
<p>DEBUGMSG(ZONE_ERR,(TEXT("DSK_Read/n")));<br>SetLastError(ERROR_INVALID_FUNCTION);<br>return 0;<br>这样的实现，也就是说用户无法通过常规的ReadFile和WriteFile函数使用这个设备，那怎么办？是否意味着这个DISK无法读写呢？当然不是，我们应该马上想到DSK_IOControl()这个函数，当遇到某些设备无法用常规的文件操作函数操作时，我们有DeviceIoControl()用户函数可以使用，而这个函数就会调用到驱动程序中的DSK_IOControl函数。</p> 
<p>        在这个函数中，我们找到了对IOCTL_DISK_READ等命令的处理程序，其中最关键的一句就是ScsiRWSG(pDevice, pSgReq, pDevice-&gt;Lun, bRead)，即调用了一个ScsiRWSG的函数。</p> 
<p>        在Scsi2.c这个程序中，我们找到了这个函数，其中SG指的是一种读写缓冲区的数据结构，实际上就是带有缓冲区及长度的一个结构体，是CE下磁盘设备通用的读写数据结构，可以在diskio.h中找到它的定义。在这个函数中我们发现它再次调用了ScsiReadWrite()这个函数进行读写操作，找到这个函数，里面有我们最重要的一行调用，即调用了UsbsDataTransfer()函数，还记得这个函数在哪见过吗？没错，就是在USB设备的驱动程序当中。</p> 
<p>        通过这一过程我们发现，那些Scsi的函数都只是在准备一些缓冲区、数据结构等，并没有对硬件进行操作，真正要操作硬件设备的还是由驱动程序来完成的，可见，设备驱动程序是有着很强层次结构的，下层是专门针对物理设备的，上层是针对操作系统的抽象设备的，下层是U盘等物理实体，上层是文件夹，二者通过一定的通信或调用机制完成了设备在操作系统下的正常工作。<br>        回到usbmsc.c程序中来，找到UsbsDataTransfer函数，这个函数很简单，根据传输协议调用CBIT_DataTransfer()或BOT_DataTransfer() 即可。 </p> 
<p><br>本文来自CSDN博客，转载请标明出处：<a href="http://blog.csdn.net/linarm/archive/2006/12/20/1451002.aspx">http://blog.csdn.net/linarm/archive/2006/12/20/1451002.aspx</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8158efd84ec0a960a1eab7ca35e48a30/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">OSPF 笔记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a74c9a2d2e7886cf1aed0c8b85c5c751/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">一些常用路由协议默认的AD值</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>