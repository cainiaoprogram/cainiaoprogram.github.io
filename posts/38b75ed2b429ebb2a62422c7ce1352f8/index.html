<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>解析C&#43;&#43;中std::ref - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="解析C&#43;&#43;中std::ref" />
<meta property="og:description" content="1. 前言 关于c&#43;&#43;中的std::ref，std::ref在c&#43;&#43;11引入。本文通过讲解std::ref的常用方式，及剖析下std::ref内部实现，进而再来讲解下std::reference_wrapper，然后我们再进一步分析为什么使用std::ref。
2. std::ref 用法 简单举例来说：
int n1 = 0; auto n2 = std::ref(n1); n2&#43;&#43;; n1&#43;&#43;; std::cout &lt;&lt; n1 &lt;&lt; std::endl; // 2 std::cout &lt;&lt; n2 &lt;&lt; std::endl; // 2 可以看到 是把n1的引用传递给了n2，分别进行加法，可以看到n2是n1的引用，最终得到的值都是2
那么大家可能会想，我都已经有了’int&amp; a = b’的这种引用赋值的语法了，为什么c&#43;&#43;11又出现了一个std::ref，我们继续来看例子：
#include &lt;iostream&gt; #include &lt;thread&gt; void thread_func(int&amp; n2) { // error, &gt;&gt; int n2 n2&#43;&#43;; } int main() { int n1 = 0; std::thread t1(thread_func, n1); t1.join(); std::cout &lt;&lt; n1 &lt;&lt; std::endl; } 我们如果写成这样是编译不过的，除非是去掉引用符号，那么我如果非要传引用怎么办呢？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/38b75ed2b429ebb2a62422c7ce1352f8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-26T19:15:40+08:00" />
<meta property="article:modified_time" content="2022-01-26T19:15:40+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">解析C&#43;&#43;中std::ref</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atelier-sulphurpool-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4><a id="1__0"></a>1. 前言</h4> 
<p>关于c++中的std::ref，std::ref在c++11引入。本文通过讲解std::ref的常用方式，及剖析下std::ref内部实现，进而再来讲解下std::reference_wrapper，然后我们再进一步分析为什么使用std::ref。</p> 
<h4><a id="2_stdref__4"></a>2. std::ref 用法</h4> 
<p>简单举例来说：</p> 
<pre><code class="prism language-C++">int n1 = 0;
auto n2 = std::ref(n1);

n2++;
n1++;

std::cout &lt;&lt; n1 &lt;&lt; std::endl;  // 2
std::cout &lt;&lt; n2 &lt;&lt; std::endl;  // 2
</code></pre> 
<p>可以看到 是把n1的引用传递给了n2，分别进行加法，可以看到n2是n1的引用，最终得到的值都是2</p> 
<p>那么大家可能会想，我都已经有了’int&amp; a = b’的这种引用赋值的语法了，为什么c++11又出现了一个std::ref，我们继续来看例子：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;thread&gt;

void thread_func(int&amp; n2) { // error, &gt;&gt; int n2
    n2++;
}

int main() {
    int n1 = 0;
    std::thread t1(thread_func, n1);

    t1.join();
    std::cout &lt;&lt; n1 &lt;&lt; std::endl;
}
</code></pre> 
<p>我们如果写成这样是编译不过的，除非是去掉引用符号，那么我如果非要传引用怎么办呢？</p> 
<pre><code class="prism language-c++">// snap ...

int main() {
    int n1 = 0;
    std::thread t1(thread_func, std::ref(n1));

    t1.join();
    std::cout &lt;&lt; n1 &lt;&lt; std::endl; // 1
}
</code></pre> 
<p>这样可以看到引用传递成功，并且能够达到我们效果，我们再来看个例子：</p> 
<pre><code class="prism language-c++">#include &lt;iostream&gt;
#include &lt;functional&gt;

void func(int&amp; n2) {
    n2++;
}

int main() {
    int n1 = 0;
    auto bind_fn = std::bind(&amp;func, std::ref(n1));

    bind_fn();
    std::cout &lt;&lt; n1 &lt;&lt; std::endl; // 1
}
</code></pre> 
<p>这里我们也发现std::bind这样也是需要通过std::ref来实现bind引用。</p> 
<p>那么我们其实可以看的出来，std::bind或者std::thread里是做了什么导致我们原来的通过&amp;传递引用的方式失效，或者说std::ref是做了什么才能使得我们使用std::bind和std::thread能够传递引用。</p> 
<p>那么我们展开std::ref看看他的真面目，大致内容如下：</p> 
<pre><code class="prism language-c++">template &lt;class _Ty&gt;
reference_wrapper&lt;_Ty&gt; ref(_Ty&amp; _Val) noexcept {
    return reference_wrapper&lt;_Ty&gt;(_Val);
}
</code></pre> 
<p>这里我们看到std::ref最终只是被包装成reference_wrapper返回，所以关键点还是std::reference_wrapper</p> 
<h4><a id="3_stdreference_wrapper_88"></a>3. std::reference_wrapper</h4> 
<p>关于这个类，我们看下cppreference上的实现形式为：</p> 
<pre><code class="prism language-c++">namespace detail {
template &lt;class T&gt; constexpr T&amp; FUN(T&amp; t) noexcept { return t; }
template &lt;class T&gt; void FUN(T&amp;&amp;) = delete;
}
 
template &lt;class T&gt;
class reference_wrapper {
public:
  // types
  typedef T type;
 
  // construct/copy/destroy
  template &lt;class U, class = decltype(
    detail::FUN&lt;T&gt;(std::declval&lt;U&gt;()),
    std::enable_if_t&lt;!std::is_same_v&lt;reference_wrapper, std::remove_cvref_t&lt;U&gt;&gt;&gt;()
  )&gt;
  constexpr reference_wrapper(U&amp;&amp; u) noexcept(noexcept(detail::FUN&lt;T&gt;(std::forward&lt;U&gt;(u))))
    : _ptr(std::addressof(detail::FUN&lt;T&gt;(std::forward&lt;U&gt;(u)))) {}
  reference_wrapper(const reference_wrapper&amp;) noexcept = default;
 
  // 赋值
  reference_wrapper&amp; operator=(const reference_wrapper&amp; x) noexcept = default;
 
  // 访问
  constexpr operator T&amp; () const noexcept { return *_ptr; }
  constexpr T&amp; get() const noexcept { return *_ptr; }
 
  template&lt; class... ArgTypes &gt;
  constexpr std::invoke_result_t&lt;T&amp;, ArgTypes...&gt;
    operator() ( ArgTypes&amp;&amp;... args ) const {
    return std::invoke(get(), std::forward&lt;ArgTypes&gt;(args)...);
  }
 
private:
  T* _ptr;
};
 
// deduction guides
template&lt;class T&gt;
reference_wrapper(T&amp;) -&gt; reference_wrapper&lt;T&gt;;
</code></pre> 
<p>里边有一些语法比较晦涩，我们一点一点的来看</p> 
<p>最开始是一个detail的<strong>namespace</strong>，里边有两个函数，第一个是接收左值引用的，第二个是接收右值引用的，接收右值引用的被delete，不能调用。这里detail是为后边做校验的，大家可能会像，不用右值引用不写就可以了，为啥写了这个函数还要标记为delete。这是因为如果没有第二个函数右值参数是可以传递给第一个函数的，如果写了就会优先匹配到到第二个函数，发现这个函数是delete，不能编译通过，明白了这个我们继续。<br></p> 
<p>接着我们看到reference_wrapper，首先是一个模板，看到很长的一个<strong>构造函数</strong>，我们拆开来看，template &lt;class U, class = xxx&gt;这种写法，后边那个class=也是在编译期做校验使用，SFINEA的一种实现形式吧，如果class=后边那个编译不过，那么你就不可以使用这个构造函数。</p> 
<p>class=后边这段很长的代码：</p> 
<pre><code class="prism language-c++">template &lt;class U, class = decltype(
    detail::FUN&lt;T&gt;(std::declval&lt;U&gt;()),
    std::enable_if_t&lt;!std::is_same_v&lt;reference_wrapper, std::remove_cvref_t&lt;U&gt;&gt;&gt;()
  )&gt;
</code></pre> 
<p>首先是一个decltype关键字，得到的是一个类型。decltype内部是使用逗号表达式连接两部分，逗号左边部分调用detail的FUN来校验，std::declval是不用调用构造函数便可以使用类的成员函数，不过只能用于不求值语境。获取U的对象看下是否是右值，上边也说到如果右值则编译不过。如果是左值的话看逗号右边的部分，std::enable_if_t&lt;&gt;, 这里&lt;&gt;中的第一个参数是条件，如果条件满足返回第二个参数，第二个参数是类型， 这里没有第二个参数，默认是void，即如果满足条件可以编译通过，否则编译不通过。条件是std::is_same_v取反，std::is_same_v&lt;&gt;是如果两个模板参数相同类型则是true，否则false。所以reference_wrapper和std::remove_cvref_t&lt;U&gt;不相同则可以通过编译，std::remove_cvref_t这个模板又是去掉U这个类型的const,volatile和引用的属性，单纯两个类型比较。</p> 
<p>上边总结就是在调用构造函数时，首先进行校验，传入参数时右值和reference_wrapper类型就不能编译通过。</p> 
<p>然后是构造函数的正文：</p> 
<pre><code class="prism language-C++">constexpr reference_wrapper(U&amp;&amp; u) noexcept(noexcept(detail::FUN&lt;T&gt;(std::forward&lt;U&gt;(u))))
    : _ptr(std::addressof(detail::FUN&lt;T&gt;(std::forward&lt;U&gt;(u)))) {}
</code></pre> 
<p>这里先看下“noexcept(noexcept(detail::FUN(std::forward&lt;U&gt;(u))))”这段代码，不了解noexcept我这里大概讲解下。</p> 
<blockquote> 
 <p>语法上来说noexcept分为修饰符和操作符两种分类吧。</p> 
 <p>修饰符写法是noexcept(expression)，expression是常量表达式，expression这个值返回true则编译器认为修饰的函数不抛出异常，这时如果该函数再抛出异常则调用std::abort终止程序，如果值返回false则认为该函数可能会抛出异常。而我们常看到函数声明后边只写一个noexcept，其实也是相当于noexcept(true)。</p> 
 <p>操作符大都用于模板中，写法就是我们这里缩写的那样noexcept(noexcept(T()))，那么这里T()决定该函数是否抛出异常，如果T()会抛出异常那么第二个noexcept就会返回false，否则返回true。</p> 
</blockquote> 
<p>那么这里构造函数就是说如果执行“detail::FUN(std::forward&lt;U&gt;(u))”不会抛出异常，那么就不会抛出异常，这样也是更好的告知编译器一个条件吧。</p> 
<p>继续的就是_ptr存放的是传进来参数的地址，这里也是比较关键，相当于是reference_wrapper的实现就是通过保存传进来参数的地址来达到引用的包装（ref wrapper）效果。</p> 
<p>构造函数终于讲完了，拷贝构造函数和赋值运算符应该不用讲了</p> 
<p>再然后就是看下如何访问了</p> 
<pre><code class="prism language-c++">constexpr operator T&amp; () const noexcept { return *_ptr; }
constexpr T&amp; get() const noexcept { return *_ptr; }
</code></pre> 
<p>这两个也比较简单，提供了一个get函数和()的重载，实现就是获取_ptr存放地址所指向的值。</p> 
<pre><code class="prism language-c++">template&lt; class... ArgTypes &gt;
  constexpr std::invoke_result_t&lt;T&amp;, ArgTypes...&gt;
    operator() ( ArgTypes&amp;&amp;... args ) const {
    return std::invoke(get(), std::forward&lt;ArgTypes&gt;(args)...);
  }
</code></pre> 
<p>还有一个实现是给存放的参数是函数类型使用的，也就是重载"()()"，可以调用这个函数并传参过去。</p> 
<p>最后就是C++17引入的推导指引，顾名思义就是帮助模板类型推导使用的</p> 
<pre><code class="prism language-c++"> 推导指引
template&lt;class T&gt;
reference_wrapper(T&amp;) -&gt; reference_wrapper&lt;T&gt;;
</code></pre> 
<p>如果没有这句话，我们构造reference_wraper时，需要这么写reference_wraper&lt;int&gt;(n1)，那么有了这句推导指引，我们可以写成这样reference_wraper(n1)，方便很多，不用写模板参数类型。</p> 
<p>那么接下来我们调用试试看（因为cppreference中实现有些语法用到了C++17或者更高，使用编译器要更高版本或者替换一些语法即可）:</p> 
<pre><code class="prism language-c++">void func(int&amp; n2) {
    n2++;
}

int main() {
    int n1 = 0;
    auto bind_fn = std::bind(&amp;func, reference_wrapper(n1));

    bind_fn();
    std::cout &lt;&lt; n1 &lt;&lt; std::endl;  // 1
}
</code></pre> 
<p>完美！可以通过, 所以reference_wrapper本质是把对象的地址保存, 访问是取出地址的值。</p> 
<p>这里我们借助的是cppreference中实现来讲解的，大家也可以参考自己本地编译器的实现。</p> 
<h4><a id="4__224"></a>4. 为什么使用</h4> 
<p>我们看下为什么std::bind或者std::thread为什么要使用reference_wrapper，我们以std::bind为例子吧，我们大致去跟踪下std::bind，跟踪的目的是看传递bound参数(即我们传给bind函数的参数)的生命周期，以vs2019的实现为例：</p> 
<pre><code class="prism language-c++">template &lt;class _Fx, class... _Types&gt;
_NODISCARD _CONSTEXPR20 _Binder&lt;_Unforced, _Fx, _Types...&gt; bind(_Fx&amp;&amp; _Func, _Types&amp;&amp;... _Args) {
    return _Binder&lt;_Unforced, _Fx, _Types...&gt;(_STD forward&lt;_Fx&gt;(_Func), _STD forward&lt;_Types&gt;(_Args)...);
}
</code></pre> 
<p>看到是构造了一个_Binder的对象返回，bound参数作为构造函数的参数传入,</p> 
<pre><code class="prism language-c++">using _Second = tuple&lt;decay_t&lt;_Types&gt;...&gt;; //std::decay_t会移除掉引用属性
_Compressed_pair&lt;_First, _Second&gt; _Mypair;

constexpr explicit _Binder(_Fx&amp;&amp; _Func, _Types&amp;&amp;... _Args)
        : _Mypair(_One_then_variadic_args_t{}, _STD forward&lt;_Fx&gt;(_Func), _STD forward&lt;_Types&gt;(_Args)...) {}
</code></pre> 
<p>也可以看到构造函数中，参数传递给_Mypair成员。到这里结束。</p> 
<p>我们再看下调用时：</p> 
<pre><code class="prism language-c++">#define _CALL_BINDER                                                                  \
    _Call_binder(_Invoker_ret&lt;_Ret&gt;{}, _Seq{}, _Mypair._Get_first(), _Mypair._Myval2, \
        _STD forward_as_tuple(_STD forward&lt;_Unbound&gt;(_Unbargs)...))

template &lt;class... _Unbound&gt;
    _CONSTEXPR20 auto operator()(_Unbound&amp;&amp;... _Unbargs) noexcept(noexcept(_CALL_BINDER)) -&gt; decltype(_CALL_BINDER) {
    return _CALL_BINDER;
}
</code></pre> 
<p>看到调用时会用到_CALL_BINDER宏，这里调用_Call_binder函数，并把_Mypair传入，再接下来就会调用到我们的函数并传入bound的参数了。</p> 
<p>总结下就是std::bind首先将传入的参数存放起来，等到要调用bind的函数就将参数传入，而这里没有保存传入参数的引用，只能保存一份参数的拷贝，如果使用我们上边说的“int&amp; a = b”语法，_Binder类中无法保存b的引用，自然调用时传入的就不是b的引用，所以借助reference_wrapper将传入参数的地址保存，使用是通过地址取出来值进而调用函数。</p> 
<h4><a id="5__264"></a>5. 总结</h4> 
<p>我来给总结下，首先我们讲解了std::ref的一些用法，然后我们讲解std::ref是通过std::reference_wrapper实现，然后我们借助了cppreference上的实现来给大家剖析了他本质就是存放了对象的地址(类似指针的用法😁)，还讲解了noexcept等语法，最后我们讲解了下std::bind为什么要使用到reference_wrapper.</p> 
<h4><a id="6__268"></a>6. 参考</h4> 
<ul><li>https://en.cppreference.com</li><li>《深入理解C++11》</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/22510bd3afc6bd8162c888f52d70ef29/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">七天玩转Redis | Day6、SpringBoot集成Redis</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/e9c0b57cdebe64e7b89cdaec0abc5ac7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">（尚硅谷）Vue笔记------22</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>