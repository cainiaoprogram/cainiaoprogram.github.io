<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>POJ 1459 Power Network （多源点多汇点求最大流问题） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="POJ 1459 Power Network （多源点多汇点求最大流问题）" />
<meta property="og:description" content="题目链接 POJ-1459 Power Network
题目分析 题意：
简单来说，由多个源点向多个汇点传输数据，每个源点传出的数据是有限的，每个汇点接受的数据也是有限的，某些点之间可以传输一定量的数据，求最大流。
思路：
相比于普通的最大流问题，这个地方的源点和汇点不唯一，而且源点的最大流出容量也有所限制，其实我们只要简单处理了一下，就可以将这类问题转化为普通的最大流问题。
我们在图中新增一个超级源点s和一个超级汇点t，由超级源点s向每个源点连一条容量为对应最大流出容量的边，再从每个汇点向超级汇点t连一条容量为对应最大流入容量的边，这样处理之后，问题就转化为了求超级源点到超级汇点之间的最大流了
代码区 #include&lt;iostream&gt; #include&lt;cstdio&gt; #include&lt;algorithm&gt; #include&lt;cstring&gt; #include&lt;queue&gt; #include&lt;string&gt; #include&lt;fstream&gt; #include&lt;vector&gt; #include&lt;stack&gt; #include &lt;map&gt; #include &lt;iomanip&gt; #define bug cout &lt;&lt; &#34;**********&#34; &lt;&lt; endl #define show(x,y) cout&lt;&lt;&#34;[&#34;&lt;&lt;x&lt;&lt;&#34;,&#34;&lt;&lt;y&lt;&lt;&#34;] &#34; //#define LOCAL = 1; using namespace std; typedef long long ll; const int inf = 0x3f3f3f3f; const ll mod = 1e6 &#43; 3; const int Max = 1e4 &#43; 10; struct Edge { int to, next; int flow; }edge[Max &lt;&lt; 2]; int n, out, in, m; int head[110], tot; int dis[110];	//表示顶点到源点的距离标号 void init() { memset(head, -1, sizeof(head));tot = 0; } void add(int u, int v, int flow) { edge[tot]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c4510a28a52fa21beb0556a947cfbf4c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-08-06T17:28:56+08:00" />
<meta property="article:modified_time" content="2019-08-06T17:28:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">POJ 1459 Power Network （多源点多汇点求最大流问题）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3>题目链接</h3> 
<p style="text-indent:50px;"><span style="color:#3399ea;"><a href="http://poj.org/problem?id=1459" rel="nofollow">POJ-1459 Power Network</a></span></p> 
<h3>题目分析</h3> 
<p style="text-indent:50px;"> 题意：</p> 
<p style="text-indent:50px;">简单来说，由多个源点向多个汇点传输数据，每个源点传出的数据是有限的，每个汇点接受的数据也是有限的，某些点之间可以传输一定量的数据，求最大流。</p> 
<p style="text-indent:50px;">思路：</p> 
<p style="text-indent:50px;">相比于普通的最大流问题，这个地方的源点和汇点不唯一，而且源点的最大流出容量也有所限制，其实我们只要简单处理了一下，就可以将这类问题转化为普通的最大流问题。</p> 
<p style="text-indent:50px;">我们在图中新增一个超级源点s和一个超级汇点t，由超级源点s向每个源点连一条容量为对应最大流出容量的边，再从每个汇点向超级汇点t连一条容量为对应最大流入容量的边，这样处理之后，问题就转化为了求超级源点到超级汇点之间的最大流了</p> 
<h3>代码区</h3> 
<pre class="has"><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;cstdio&gt;
#include&lt;algorithm&gt;
#include&lt;cstring&gt;
#include&lt;queue&gt;
#include&lt;string&gt;
#include&lt;fstream&gt;
#include&lt;vector&gt;
#include&lt;stack&gt;
#include &lt;map&gt;
#include &lt;iomanip&gt;
#define bug cout &lt;&lt; "**********" &lt;&lt; endl
#define show(x,y) cout&lt;&lt;"["&lt;&lt;x&lt;&lt;","&lt;&lt;y&lt;&lt;"] "
//#define LOCAL = 1;
using namespace std;
typedef long long ll;
const int inf = 0x3f3f3f3f;
const ll mod = 1e6 + 3;
const int Max = 1e4 + 10;

struct Edge
{
	int to, next;
	int flow;
}edge[Max &lt;&lt; 2];

int n, out, in, m;
int head[110], tot;
int dis[110];			//表示顶点到源点的距离标号

void init()
{
	memset(head, -1, sizeof(head));tot = 0;
}

void add(int u, int v, int flow)
{
	edge[tot].to = v;
	edge[tot].flow = flow;
	edge[tot].next = head[u];
	head[u] = tot++;
}

bool bfs()												//判断残留网络是否连通，并求出dis
{
	queue&lt;int&gt;q;
	memset(dis, -1, sizeof(dis));
	dis[0] = 0;
	q.push(0);
	while (!q.empty())
	{
		int u = q.front();q.pop();
		for (int i = head[u]; i != -1; i = edge[i].next)
		{
			int v = edge[i].to;
			if (dis[v] == -1 &amp;&amp; edge[i].flow &gt; 0)		//可以借助边i到达新的结点
			{
				dis[v] = dis[u] + 1;					//求顶点到源点的距离编号
				q.push(v);
			}
		}
	}
	return dis[n] != -1;								//确认是否连通
}

int dfs(int u, int flow_in)								//求增广路
{
	if (u == n) return flow_in;
	int flow_out = 0;									//记录这一点实际流出的流量
	for (int i = head[u]; i != -1;i = edge[i].next)
	{
		int v = edge[i].to;
		if(dis[v] == dis[u] + 1 &amp;&amp; edge[i].flow &gt; 0 )
		{
			int flow_part = dfs(v, min(flow_in, edge[i].flow));

			if (flow_part == 0) continue;

			flow_in -= flow_part;						//流出了一部分，剩余可分配流入就减少了
			flow_out += flow_part;						//记录这一点最大的流出

			edge[i].flow -= flow_part;
			edge[i ^ 1].flow += flow_part;				//常规操作了...
			if (flow_in == 0)
				break;
		}
	}
	return flow_out;
}


int max_flow()
{
	int sum = 0;
	while (bfs())
	{
		sum += dfs(0, inf);
	}
	return sum;
}

int main()
{
#ifdef LOCAL
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);
#endif
	while (scanf("%d%d%d%d", &amp;n, &amp;out, &amp;in, &amp;m) != EOF)
	{
		init();
		n++;										//新增超级源点0和超超级汇点n
		for (int i = 1, u, v, flow;i &lt;= m;i++)
		{
			scanf(" (%d,%d)%d", &amp;u, &amp;v, &amp;flow);
			u++, v++;								//把0当作超级源点
			add(u, v, flow);add(v, u, 0);
		}

		for (int i = 1, v, flow;i &lt;= out;i++)		//由超级源点向每个源点连一条容量为对应最大流出容量的边
		{
			scanf(" (%d)%d", &amp;v, &amp;flow);v++;
			add(0, v, flow);add(v, 0, 0);
		}

		for (int i = 1, u, flow;i &lt;= in; i++)		//从每个汇点向超级汇点连一条容量为对应最大流入容量的边
		{
			scanf(" (%d)%d", &amp;u, &amp;flow);u++;
			add(u, n, flow);add(n, u, 0);
		}
		printf("%d\n", max_flow());
	}
	return 0;
}</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f579f0ec9f202f7efcab323b82773f40/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux下普通用户和超级用户的切换</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d9d40c4c502846053d49f49a1a506ff6/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在Linux系统中搭建web服务器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>