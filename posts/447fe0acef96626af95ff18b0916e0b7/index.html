<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>关于SQL调优、如何养成书写高质量SQL，由浅及深持续更新中 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="关于SQL调优、如何养成书写高质量SQL，由浅及深持续更新中" />
<meta property="og:description" content="标题 如何进行调优------------及原理基础调优常规调优思维巧用where条件合理使用limit分页优化你的like语句合理选择 in 跟 exists 中级调优思维尽量避免在索引列上使用mysql的内置函数join 、 union 篇幅合理使用索引如果数据量较大，优化你的插入、修改、删除语句、慎用distinct关键字（用EXISTS代替DISTINCT去重）高效的删除重复记录sql不要有超过5个以上的表连接 高级调优思维尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型尽量避免向客户端返回过多数据量。索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。当在SQL语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。尽可能使用varchar/nvarchar 代替 char/nchar。为了提高group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。sql优化中，一个重要的基本原则就是“永远用小结果集驱动大的结果集”。合理选择TRUNCATE跟DELETE 终极调优思维使用explain 分析你SQL的计划 网址推荐-------------------------书写高质量SQL的30条建议 前言：之前一直也没研究太多关于sql调优的知识，仅仅停留在能查出自己想要的数据即可，从不考虑查询成本，虽然在面试中也会经常问到此类问题，也只是死记几条。但为了更好的发展，建议早点研究基本原理进而在深入理解，在平时尽量养成规范的编码习惯，平时也要善于总结，及时应用不用背就能记住，在说到这块就能侃侃而谈。 内容有很多，后续慢慢补齐，持续更新中。 如何进行调优------------及原理 基础调优 常规调优思维 1、查询SQL尽量不要使用select *，而是select具体字段。 只取需要的字段，节省资源、减少网络开销。 select * 进行查询时，很可能就不会使用到覆盖索引了， 就会造成回表查询。 巧用where条件 1、应尽量避免在where子句中使用or来连接条件。 反例:select * from user where userid=1 or age =18 正例：//使用union all select * from user where userid=1 union all select * from user where age = 18 使用or可能会使索引失效，从而全表扫描。 对于or&#43;没有索引的age这种情况，假设它走了userId的索引，但是走到age查询条件时，它还得全表扫描， 也就是需要三步过程：全表扫描&#43;索引扫描&#43;合并 如果它一开始就走全表扫描，直接一遍扫描就完事。 mysql是有优化器的，处于效率与成本考虑，遇到or条件，索引可能失效，看起来也合情合理。 2、使用where条件限定要查询的数据，避免返回多余的行。 需要什么数据，就去查什么数据，避免返回不必要的数据，节省开销。 3、应尽量避免在 where 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫。 反例：select * from user where age-1 =10； 正例：select * from user where age =11； 理由：虽然age加了索引，但是因为对它进行运算，索引直接迷路了。。。 4、应尽量避免在 where 子句中使用!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/447fe0acef96626af95ff18b0916e0b7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-27T15:22:01+08:00" />
<meta property="article:modified_time" content="2022-04-27T15:22:01+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">关于SQL调优、如何养成书写高质量SQL，由浅及深持续更新中</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>标题</h4> 
 <ul><li><a href="#_4" rel="nofollow">如何进行调优------------及原理</a></li><li><a href="#_5" rel="nofollow">基础调优</a></li><li><ul><li><a href="#_6" rel="nofollow">常规调优思维</a></li><li><a href="#where_13" rel="nofollow">巧用where条件</a></li><li><a href="#limit_57" rel="nofollow">合理使用limit分页</a></li><li><a href="#like_80" rel="nofollow">优化你的like语句</a></li><li><a href="#_in__exists_90" rel="nofollow">合理选择 in 跟 exists</a></li></ul> 
  </li><li><a href="#_116" rel="nofollow">中级调优思维</a></li><li><ul><li><a href="#mysql_117" rel="nofollow">尽量避免在索引列上使用mysql的内置函数</a></li><li><a href="#join__union__126" rel="nofollow">join 、 union 篇幅</a></li><li><a href="#_153" rel="nofollow">合理使用索引</a></li><li><a href="#_204" rel="nofollow">如果数据量较大，优化你的插入、修改、删除语句、</a></li><li><a href="#distinctEXISTSDISTINCT_239" rel="nofollow">慎用distinct关键字（用EXISTS代替DISTINCT去重）</a></li><li><a href="#sql_261" rel="nofollow">高效的删除重复记录sql</a></li><li><a href="#5_265" rel="nofollow">不要有超过5个以上的表连接</a></li></ul> 
  </li><li><a href="#_272" rel="nofollow">高级调优思维</a></li><li><ul><li><a href="#_273" rel="nofollow">尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</a></li><li><a href="#_281" rel="nofollow">尽量避免向客户端返回过多数据量。</a></li><li><a href="#_297" rel="nofollow">索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。</a></li><li><a href="#SQL_302" rel="nofollow">当在SQL语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。</a></li><li><a href="#varcharnvarchar__charnchar_311" rel="nofollow">尽可能使用varchar/nvarchar 代替 char/nchar。</a></li><li><a href="#group_by__323" rel="nofollow">为了提高group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。</a></li><li><a href="#sql_333" rel="nofollow">sql优化中，一个重要的基本原则就是“永远用小结果集驱动大的结果集”。</a></li><li><a href="#TRUNCATEDELETE_342" rel="nofollow">合理选择TRUNCATE跟DELETE</a></li></ul> 
  </li><li><a href="#_350" rel="nofollow">终极调优思维</a></li><li><ul><li><a href="#explain_SQL_351" rel="nofollow">使用explain 分析你SQL的计划</a></li></ul> 
 </li></ul> 
</div> 
<br> 
<strong><a href="https://zhuanlan.zhihu.com/p/444165942?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=1127364501472919552&amp;utm_campaign=shareopn" rel="nofollow">网址推荐-------------------------书写高质量SQL的30条建议</a></strong> 
<br> 前言：之前一直也没研究太多关于sql调优的知识，仅仅停留在能查出自己想要的数据即可，从不考虑查询成本，虽然在面试中也会经常问到此类问题，也只是死记几条。但为了更好的发展，建议早点研究基本原理进而在深入理解，在平时尽量养成规范的编码习惯，平时也要善于总结，及时应用不用背就能记住，在说到这块就能侃侃而谈。 
<br> 
<strong>内容有很多，后续慢慢补齐，持续更新中。</strong> 
<p></p> 
<h2><a id="_4"></a>如何进行调优------------及原理</h2> 
<h2><a id="_5"></a>基础调优</h2> 
<h3><a id="_6"></a>常规调优思维</h3> 
<pre><code class="prism language-sql"><span class="token number">1</span>、查询<span class="token keyword">SQL</span>尽量不要使用<span class="token keyword">select</span> <span class="token operator">*</span>，而是<span class="token keyword">select</span>具体字段。
只取需要的字段，节省资源、减少网络开销。 <span class="token keyword">select</span> <span class="token operator">*</span> 进行查询时，很可能就不会使用到覆盖索引了，
就会造成回表查询。

</code></pre> 
<h3><a id="where_13"></a>巧用where条件</h3> 
<pre><code class="prism language-sql"><span class="token number">1</span>、应尽量避免在<span class="token keyword">where</span>子句中使用<span class="token operator">or</span>来连接条件。
反例:<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> userid<span class="token operator">=</span><span class="token number">1</span> <span class="token operator">or</span> age <span class="token operator">=</span><span class="token number">18</span>
正例：<span class="token comment">//使用union all</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> userid<span class="token operator">=</span><span class="token number">1</span> 
<span class="token keyword">union</span> <span class="token keyword">all</span> 
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> age <span class="token operator">=</span> <span class="token number">18</span>
使用<span class="token operator">or</span>可能会使索引失效，从而全表扫描。
对于<span class="token operator">or</span><span class="token operator">+</span>没有索引的age这种情况，假设它走了userId的索引，但是走到age查询条件时，它还得全表扫描，
也就是需要三步过程：全表扫描<span class="token operator">+</span>索引扫描<span class="token operator">+</span>合并 如果它一开始就走全表扫描，直接一遍扫描就完事。
mysql是有优化器的，处于效率与成本考虑，遇到<span class="token operator">or</span>条件，索引可能失效，看起来也合情合理。
<span class="token number">2</span>、使用<span class="token keyword">where</span>条件限定要查询的数据，避免返回多余的行。
需要什么数据，就去查什么数据，避免返回不必要的数据，节省开销。
<span class="token number">3</span>、应尽量避免在 <span class="token keyword">where</span> 子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫。
反例：<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> age<span class="token operator">-</span><span class="token number">1</span> <span class="token operator">=</span><span class="token number">10</span>；
正例：<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> age <span class="token operator">=</span><span class="token number">11</span>；
理由：虽然age加了索引，但是因为对它进行运算，索引直接迷路了。。。
<span class="token number">4</span>、应尽量避免在 <span class="token keyword">where</span> 子句中使用<span class="token operator">!=</span>或<span class="token operator">&lt;&gt;</span>操作符，否则将引擎放弃使用索引而进行全表扫描。
反例：<span class="token keyword">select</span> age<span class="token punctuation">,</span>name  <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> age <span class="token operator">&lt;&gt;</span><span class="token number">18</span><span class="token punctuation">;</span>
正例：<span class="token comment">//可以考虑分开两条sql写</span>
<span class="token keyword">select</span> age<span class="token punctuation">,</span>name  <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> age <span class="token operator">&lt;</span><span class="token number">18</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> age<span class="token punctuation">,</span>name  <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> age <span class="token operator">&gt;</span><span class="token number">18</span><span class="token punctuation">;</span>
理由：使用<span class="token operator">!=</span>和<span class="token operator">&lt;&gt;</span>很可能会让索引失效
<span class="token number">5</span>、<span class="token keyword">where</span>子句中考虑使用默认值代替<span class="token boolean">null</span>。
反例：
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> age <span class="token operator">is</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">;</span><span class="token punctuation">(</span>未使用索引<span class="token punctuation">)</span>
正例：<span class="token comment">//设置0为默认值</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> age<span class="token operator">&gt;</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">(</span>使用索引age<span class="token punctuation">)</span>
理由：
并不是说使用了<span class="token operator">is</span> <span class="token boolean">null</span> 或者 <span class="token operator">is</span> <span class="token operator">not</span> <span class="token boolean">null</span> 就会不走索引了，这个跟mysql版本以及查询成本都有关。 
如果mysql优化器发现，走索引比不走索引成本还要高，肯定会放弃索引，
这些条件！<span class="token operator">=</span>，<span class="token operator">&gt;</span><span class="token operator">is</span> <span class="token boolean">null</span>，<span class="token operator">is</span> <span class="token operator">not</span> <span class="token boolean">null</span>经常被认为让索引失效，
其实是因为一般情况下，查询的成本高，优化器自动放弃的。
如果把<span class="token boolean">null</span>值，换成默认值，很多时候让走索引成为可能，同时，表达意思会相对清晰一点。
<span class="token number">6</span>、如何字段类型是字符串，<span class="token keyword">where</span>时一定用引号括起来，否则索引失效。
反例：
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> userid <span class="token operator">=</span><span class="token number">123</span><span class="token punctuation">;</span>
正例：
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> userid <span class="token operator">=</span><span class="token string">'123'</span><span class="token punctuation">;</span>
理由：
为什么第一条语句未加单引号就不走索引了呢？这是因为不加单引号时，是字符串跟数字的比较，
它们类型不匹配，MySQL会做隐式的类型转换，把它们转换为浮点数再做比较。
</code></pre> 
<h3><a id="limit_57"></a>合理使用limit分页</h3> 
<pre><code class="prism language-sql"><span class="token number">1</span>、如果知道查询结果只有一条或者只要最大<span class="token operator">/</span>最小一条记录，建议用<span class="token keyword">limit</span> <span class="token number">1</span>。
加上<span class="token keyword">limit</span> <span class="token number">1</span>后<span class="token punctuation">,</span>只要找到了对应的一条记录<span class="token punctuation">,</span>就不会继续向下扫描了<span class="token punctuation">,</span>效率将会大大提高。
 当然，如果name是唯一索引的话，是不必要加上<span class="token keyword">limit</span> <span class="token number">1</span>了，
 因为<span class="token keyword">limit</span>的存在主要就是为了防止全表扫描，从而提高性能<span class="token punctuation">,</span>如果一个语句本身可以预知不用全表扫描
 ，有没有<span class="token keyword">limit</span> ，性能的差别并不大。
<span class="token number">2</span>、优化<span class="token keyword">limit</span>分页。
我们日常做分页需求时，一般会用 <span class="token keyword">limit</span> 实现，但是当偏移量特别大的时候，查询效率就变得低下。
反例：
<span class="token keyword">select</span> id，name，age <span class="token keyword">from</span> employee <span class="token keyword">limit</span> <span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">10</span>
正例：
<span class="token comment">//方案一 ：返回上次查询的最大记录(偏移量)</span>
<span class="token keyword">select</span> id，name <span class="token keyword">from</span> employee <span class="token keyword">where</span> id<span class="token operator">&gt;</span><span class="token number">10000</span> <span class="token keyword">limit</span> <span class="token number">10</span>
<span class="token comment">//方案二：order by + 索引</span>
<span class="token keyword">select</span> id，name <span class="token keyword">from</span> employee <span class="token keyword">order</span> <span class="token keyword">by</span> id  <span class="token keyword">limit</span> <span class="token number">10000</span><span class="token punctuation">,</span><span class="token number">10</span>
理由：
当偏移量最大的时候，查询效率就会越低，因为Mysql并非是跳过偏移量直接去取后面的数据，
而是先把偏移量<span class="token operator">+</span>要取的条数，然后再把前面偏移量这一段的数据抛弃掉再返回的。
如果使用优化方案一，返回上次最大查询记录（偏移量），这样可以跳过偏移量，效率提升不少。
方案二使用<span class="token keyword">order</span> <span class="token keyword">by</span><span class="token operator">+</span>索引，也是可以提高查询效率的。 方案三的话，建议跟业务讨论，
有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。
</code></pre> 
<h3><a id="like_80"></a>优化你的like语句</h3> 
<pre><code class="prism language-sql"><span class="token number">1</span>、优化你的<span class="token operator">like</span>语句
日常开发中，如果用到模糊关键字查询，很容易想到<span class="token operator">like</span>，但是<span class="token operator">like</span>很可能让你的索引失效。
反例：
<span class="token keyword">select</span> userId，name <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> userId <span class="token operator">like</span> <span class="token string">'%123'</span><span class="token punctuation">;</span>
正例：
<span class="token keyword">select</span> userId，name <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> userId <span class="token operator">like</span> <span class="token string">'123%'</span><span class="token punctuation">;</span>
把<span class="token operator">%</span>放前面，并不走索引。把<span class="token operator">%</span> 放关键字后面，还是会走索引的。
</code></pre> 
<h3><a id="_in__exists_90"></a>合理选择 in 跟 exists</h3> 
<pre><code class="prism language-sql"><span class="token number">1</span>、如果B的数据量小于A，适合使用<span class="token operator">in</span>，如果B的数据量大于A，即适合选择exist。
<span class="token punctuation">(</span><span class="token operator">in</span> 就是遍历A里面嵌套遍历B，exist就是遍历B里面嵌套遍历B<span class="token punctuation">)</span>
假设表A表示某企业的员工表，表B表示部门表，查询所有部门的所有员工，很容易有以下<span class="token keyword">SQL</span>:
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> A <span class="token keyword">where</span> deptId <span class="token operator">in</span> <span class="token punctuation">(</span><span class="token keyword">select</span> deptId <span class="token keyword">from</span> B<span class="token punctuation">)</span><span class="token punctuation">;</span> 这样写等价于：
先查询部门表B
<span class="token keyword">select</span> deptId <span class="token keyword">from</span> B
再由部门deptId，查询A的员工
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> A <span class="token keyword">where</span> A<span class="token punctuation">.</span>deptId <span class="token operator">=</span> B<span class="token punctuation">.</span>deptId
可以抽象成这样的一个循环：
List<span class="token operator">&lt;&gt;</span> resultSet <span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>B<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span> { <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span> { <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token operator">=</span><span class="token operator">=</span>B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span> { resultSet<span class="token punctuation">.</span><span class="token keyword">add</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span> } } } 显然，除了使用<span class="token operator">in</span>，我们也可以用<span class="token keyword">exists</span>实现一样的查询功能，如下：
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> A <span class="token keyword">where</span> <span class="token keyword">exists</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token number">1</span> <span class="token keyword">from</span> B <span class="token keyword">where</span> A<span class="token punctuation">.</span>deptId <span class="token operator">=</span> B<span class="token punctuation">.</span>deptId<span class="token punctuation">)</span><span class="token punctuation">;</span> 
因为<span class="token keyword">exists</span>查询的理解就是，先执行主查询，获得数据后，再放到子查询中做条件验证，
根据验证结果（<span class="token boolean">true</span>或者<span class="token boolean">false</span>），来决定主查询的数据结果是否得意保留。
那么，这样写就等价于：
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> A<span class="token punctuation">,</span>先从A表做循环
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> B <span class="token keyword">where</span> A<span class="token punctuation">.</span>deptId <span class="token operator">=</span> B<span class="token punctuation">.</span>deptId<span class="token punctuation">,</span>再从B表做循环<span class="token punctuation">.</span>
同理，可以抽象成这样一个循环：
List<span class="token operator">&lt;&gt;</span> resultSet <span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span> { <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>B<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">+</span><span class="token operator">+</span><span class="token punctuation">)</span> { <span class="token keyword">if</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>deptId<span class="token operator">=</span><span class="token operator">=</span>B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>deptId<span class="token punctuation">)</span> { resultSet<span class="token punctuation">.</span><span class="token keyword">add</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">break</span><span class="token punctuation">;</span> } } } 
数据库最费劲的就是跟程序链接释放。假设链接了两次，每次做上百万次的数据集查询，查完就走，
这样就只做了两次；相反建立了上百万次链接，申请链接释放反复重复，这样系统就受不了了。
即mysql优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优。
因此，我们要选择最外层循环小的，也就是，如果B的数据量小于A，适合使用<span class="token operator">in</span>，
如果B的数据量大于A，即适合选择exist。
</code></pre> 
<h2><a id="_116"></a>中级调优思维</h2> 
<h3><a id="mysql_117"></a>尽量避免在索引列上使用mysql的内置函数</h3> 
<pre><code class="prism language-sql"><span class="token number">1</span>、业务需求：查询最近七天内登陆过的用户<span class="token punctuation">(</span>假设loginTime加了索引<span class="token punctuation">)</span>
反例：
<span class="token keyword">select</span> userId<span class="token punctuation">,</span>loginTime <span class="token keyword">from</span> loginuser <span class="token keyword">where</span> Date_ADD<span class="token punctuation">(</span>loginTime<span class="token punctuation">,</span><span class="token keyword">Interval</span> <span class="token number">7</span> <span class="token keyword">DAY</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
正例：
<span class="token keyword">explain</span>  <span class="token keyword">select</span> userId<span class="token punctuation">,</span>loginTime <span class="token keyword">from</span> loginuser <span class="token keyword">where</span>  loginTime <span class="token operator">&gt;=</span> Date_ADD<span class="token punctuation">(</span><span class="token function">NOW</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">INTERVAL</span> <span class="token operator">-</span> <span class="token number">7</span> <span class="token keyword">DAY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
理由：索引列上使用mysql的内置函数，索引失效。如果索引列不加内置函数，索引还是会走的。
</code></pre> 
<h3><a id="join__union__126"></a>join 、 union 篇幅</h3> 
<pre><code class="prism language-sql"><span class="token number">1</span>、<span class="token keyword">Inner</span> <span class="token keyword">join</span> 、<span class="token keyword">left</span> <span class="token keyword">join</span>、<span class="token keyword">right</span> <span class="token keyword">join</span>，优先使用<span class="token keyword">Inner</span> <span class="token keyword">join</span>，如果是<span class="token keyword">left</span> <span class="token keyword">join</span>，
左边表结果尽量小
都满足<span class="token keyword">SQL</span>需求的前提下，推荐优先使用<span class="token keyword">Inner</span> <span class="token keyword">join</span>（内连接），如果要使用<span class="token keyword">left</span> <span class="token keyword">join</span>，
左边表数据结果尽量小，如果有条件的尽量放到左边处理。
反例:
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tab1 t1 <span class="token keyword">left</span> <span class="token keyword">join</span> tab2 t2  <span class="token keyword">on</span> t1<span class="token punctuation">.</span>size <span class="token operator">=</span> t2<span class="token punctuation">.</span>size <span class="token keyword">where</span> t1<span class="token punctuation">.</span>id<span class="token operator">&gt;</span><span class="token number">2</span><span class="token punctuation">;</span>
正例：
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tab1 <span class="token keyword">where</span> id <span class="token operator">&gt;</span><span class="token number">2</span><span class="token punctuation">)</span> t1 <span class="token keyword">left</span> <span class="token keyword">join</span> tab2 t2 <span class="token keyword">on</span> t1<span class="token punctuation">.</span>size <span class="token operator">=</span> t2<span class="token punctuation">.</span>size<span class="token punctuation">;</span>
理由：
如果<span class="token keyword">inner</span> <span class="token keyword">join</span>是等值连接，或许返回的行数比较少，所以性能相对会好一点。 
同理，使用了左连接，左边表数据结果尽量小，条件尽量放到左边处理，意味着返回的行数可能比较少。
<span class="token number">2</span>、尽量用 <span class="token keyword">union</span> <span class="token keyword">all</span> 替换 <span class="token keyword">union</span>。
如果检索结果中不会有重复的记录，推荐<span class="token keyword">union</span> <span class="token keyword">all</span> 替换 <span class="token keyword">union</span>。
反例：
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> userid<span class="token operator">=</span><span class="token number">1</span> 
<span class="token keyword">union</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> age <span class="token operator">=</span> <span class="token number">10</span>
正例：
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> userid<span class="token operator">=</span><span class="token number">1</span> 
<span class="token keyword">union</span> <span class="token keyword">all</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> age <span class="token operator">=</span> <span class="token number">10</span>
理由：
如果使用<span class="token keyword">union</span>，不管检索结果有没有重复，都会尝试进行合并，然后在输出最终结果前进行排序。
如果已知检索结果没有重复记录，使用<span class="token keyword">union</span> <span class="token keyword">all</span> 代替<span class="token keyword">union</span>，这样会提高效率。
</code></pre> 
<h3><a id="_153"></a>合理使用索引</h3> 
<pre><code class="prism language-sql"><span class="token number">1</span>、使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。
表结构：（有一个联合索引idx_userid_age，userId在前，age在后）
<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>user<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>userId<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_userid_age<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>userId<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">AUTO_INCREMENT</span><span class="token operator">=</span><span class="token number">2</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>

反例：
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> age <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
正例：
<span class="token comment">//符合最左匹配原则</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> userid<span class="token operator">=</span><span class="token number">10</span> <span class="token operator">and</span> age <span class="token operator">=</span><span class="token number">10</span>；
<span class="token comment">//符合最左匹配原则</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> userid <span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">;</span>
理由：
当我们创建一个联合索引的时候，如<span class="token punctuation">(</span>k1<span class="token punctuation">,</span>k2<span class="token punctuation">,</span>k3<span class="token punctuation">)</span>，相当于创建了（k1）、<span class="token punctuation">(</span>k1<span class="token punctuation">,</span>k2<span class="token punctuation">)</span>和<span class="token punctuation">(</span>k1<span class="token punctuation">,</span>k2<span class="token punctuation">,</span>k3<span class="token punctuation">)</span>三个索引，
这就是最左匹配原则。 联合索引不满足最左原则，索引一般会失效，但是这个还跟Mysql优化器有关的。

<span class="token number">2</span>、对查询进行优化，应考虑在 <span class="token keyword">where</span> 及 <span class="token keyword">order</span> <span class="token keyword">by</span> 涉及的列上建立索引，尽量避免全表扫描。
反例：
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> address <span class="token operator">=</span><span class="token string">'深圳'</span> <span class="token keyword">order</span> <span class="token keyword">by</span> age <span class="token punctuation">;</span>
正例：添加索引
<span class="token keyword">alter</span> <span class="token keyword">table</span> <span class="token keyword">user</span> <span class="token keyword">add</span> <span class="token keyword">index</span> idx_address_age <span class="token punctuation">(</span>address<span class="token punctuation">,</span>age<span class="token punctuation">)</span>
<span class="token number">3</span>、在适当的时候，使用覆盖索引。
覆盖索引能够使得你的<span class="token keyword">SQL</span>语句不需要回表，仅仅访问索引就能够得到所有需要的数据，大大提高了查询效率。
反例：
<span class="token comment">// like模糊查询，不走索引了</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> userid <span class="token operator">like</span> <span class="token string">'%123%'</span><span class="token punctuation">;</span>
正例：
<span class="token comment">//id为主键，那么为普通索引，即覆盖索引登场了。</span>
<span class="token keyword">select</span> id<span class="token punctuation">,</span>name <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> userid <span class="token operator">like</span> <span class="token string">'%123%'</span><span class="token punctuation">;</span>
<span class="token number">4</span>、删除冗余和重复索引。
反例：
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_userId<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>userId<span class="token punctuation">`</span></span><span class="token punctuation">)</span>
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_userId_age<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>userId<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span><span class="token punctuation">)</span>
正例:
  <span class="token comment">//删除userId索引，因为组合索引（A，B）相当于创建了（A）和（A，B）索引</span>
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>idx_userId_age<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>userId<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span><span class="token punctuation">)</span>
理由：重复的索引需要维护，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能的。
<span class="token number">5</span>、索引不宜太多，一般<span class="token number">5</span>个以内。
索引并不是越多越好，索引虽然提高了查询的效率，但是也降低了插入和更新的效率。
<span class="token keyword">insert</span>或<span class="token keyword">update</span>时有可能会重建索引，所以建索引需要慎重考虑，视具体情况来定。
一个表的索引数最好不要超过<span class="token number">5</span>个，若太多需要考虑一些索引是否没有存在的必要。
</code></pre> 
<h3><a id="_204"></a>如果数据量较大，优化你的插入、修改、删除语句、</h3> 
<pre><code class="prism language-sql"><span class="token number">1</span>、如果插入数据过多，考虑批量插入。
反例：
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">User</span> u :list<span class="token punctuation">)</span>{
 <span class="token keyword">INSERT</span> <span class="token keyword">into</span> <span class="token keyword">user</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token comment">#name#,#age#)   </span>
}

正例：
<span class="token comment">//一次500批量插入，分批进行</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">user</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span>age<span class="token punctuation">)</span> <span class="token keyword">values</span>
<span class="token operator">&lt;</span>foreach collection<span class="token operator">=</span><span class="token string">"list"</span> item<span class="token operator">=</span><span class="token string">"item"</span> <span class="token keyword">index</span><span class="token operator">=</span><span class="token string">"index"</span> separator<span class="token operator">=</span><span class="token string">","</span><span class="token operator">&gt;</span>
    <span class="token punctuation">(</span><span class="token comment">#{item.name},#{item.age})</span>
<span class="token operator">&lt;</span><span class="token operator">/</span>foreach<span class="token operator">&gt;</span>
理由：
批量插入性能好，更加省时间 打个比喻:假如你需要搬一万块砖到楼顶<span class="token punctuation">,</span>你有一个电梯<span class="token punctuation">,</span>
电梯一次可以放适量的砖（最多放<span class="token number">500</span>）<span class="token punctuation">,</span>你可以选择一次运送一块砖<span class="token punctuation">,</span>也可以一次运送<span class="token number">500</span><span class="token punctuation">,</span>
你觉得哪个时间消耗大?
<span class="token number">2</span>、如果数据量较大，优化你的修改<span class="token operator">/</span>删除语句。
避免同时修改或删除过多数据，因为会造成cpu利用率过高，从而影响别人对数据库的访问。
反例：
<span class="token comment">//一次删除10万或者100万+？</span>
<span class="token keyword">delete</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> id <span class="token operator">&lt;</span><span class="token number">100000</span><span class="token punctuation">;</span>
<span class="token comment">//或者采用单一循环操作，效率低，时间漫长</span>
<span class="token keyword">for</span>（<span class="token keyword">User</span> <span class="token keyword">user</span>：list）{
   <span class="token keyword">delete</span> <span class="token keyword">from</span> <span class="token keyword">user</span>；
}
正例：
<span class="token comment">//分批进行删除,如每次500</span>
<span class="token keyword">delete</span> <span class="token keyword">user</span> <span class="token keyword">where</span> id<span class="token operator">&lt;</span><span class="token number">500</span>
<span class="token keyword">delete</span> product <span class="token keyword">where</span> id<span class="token operator">&gt;=</span><span class="token number">500</span> <span class="token operator">and</span> id<span class="token operator">&lt;</span><span class="token number">1000</span>；
理由：

一次性删除太多数据，可能会有<span class="token keyword">lock</span> wait timeout exceed的错误，所以建议分批操作。
</code></pre> 
<h3><a id="distinctEXISTSDISTINCT_239"></a>慎用distinct关键字（用EXISTS代替DISTINCT去重）</h3> 
<pre><code class="prism language-sql"><span class="token keyword">distinct</span> 关键字一般用来过滤重复记录，以返回不重复的记录。
在查询一个字段或者很少字段的情况下使用时，给查询带来优化效果。
但是在字段很多的时候使用，却会大大降低查询效率。
反例：
<span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> <span class="token operator">*</span> <span class="token keyword">from</span>  <span class="token keyword">user</span><span class="token punctuation">;</span>
正例：
<span class="token keyword">select</span> <span class="token keyword">DISTINCT</span> name <span class="token keyword">from</span> <span class="token keyword">user</span><span class="token punctuation">;</span>
理由：
带<span class="token keyword">distinct</span>的语句cpu时间和占用时间都高于不带<span class="token keyword">distinct</span>的语句。因为当查询很多字段时，
如果使用<span class="token keyword">distinct</span>，数据库引擎就会对数据进行比较，过滤掉重复数据，然而这个比较，
过滤的过程会占用系统资源，cpu时间。

在多表连接，尤其是一对多的表连接中，如果只需要‘一’表的数据，可以采用<span class="token keyword">EXISTS</span>子句替换主查询的多表
连接，这样避免了主查询中出现重复的数据。因为<span class="token keyword">DISTINCT</span>会在查询出来的结果集基础上进行排序、
去重，增加了额外的工作。
如：低效：<span class="token keyword">SELECT</span>  <span class="token keyword">DISTINCT</span>  D<span class="token punctuation">.</span>DEPT_NO<span class="token punctuation">,</span>D<span class="token punctuation">.</span>DEPT_NAME  <span class="token keyword">FROM</span>  DEPT D <span class="token punctuation">,</span> EMP E <span class="token keyword">WHERE</span> D<span class="token punctuation">.</span>DEPT_NO <span class="token operator">=</span> E<span class="token punctuation">.</span>DEPT_NO<span class="token punctuation">;</span>
高效：<span class="token keyword">SELECT</span>  DEPT_NO<span class="token punctuation">,</span>DEPT_NAME  <span class="token keyword">FROM</span>  DEPT D  <span class="token keyword">WHERE</span>  <span class="token keyword">EXISTS</span> <span class="token punctuation">(</span> <span class="token keyword">SELECT</span> ‘X'<span class="token keyword">FROM</span>  EMP E  <span class="token keyword">WHERE</span> E<span class="token punctuation">.</span>DEPT_NO <span class="token operator">=</span> D<span class="token punctuation">.</span>DEPT_NO<span class="token punctuation">)</span><span class="token punctuation">;</span>

在查询数据无差别的情况下，采用<span class="token keyword">group</span> <span class="token keyword">by</span>比<span class="token keyword">distinct</span>快，不论查询列是否添加索引。
</code></pre> 
<h3><a id="sql_261"></a>高效的删除重复记录sql</h3> 
<pre><code class="prism language-sql"> <span class="token keyword">DELETE</span>  <span class="token keyword">FROM</span>  EMP E  <span class="token keyword">WHERE</span>  E<span class="token punctuation">.</span>ROWID <span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">SELECT</span> <span class="token function">MIN</span><span class="token punctuation">(</span>X<span class="token punctuation">.</span>ROWID<span class="token punctuation">)</span> <span class="token keyword">FROM</span>  EMP X  <span class="token keyword">WHERE</span>  X<span class="token punctuation">.</span>EMP_NO <span class="token operator">=</span> E<span class="token punctuation">.</span>EMP_NO<span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> 
<h3><a id="5_265"></a>不要有超过5个以上的表连接</h3> 
<pre><code class="prism language-sql">连表越多，编译的时间和开销也就越大。
把连接表拆开成较小的几个执行，可读性更高。
如果一定需要连接很多表才能得到数据，那么意味着糟糕的设计了。

</code></pre> 
<h2><a id="_272"></a>高级调优思维</h2> 
<h3><a id="_273"></a>尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</h3> 
<pre><code class="prism language-sql">反例：
king_id<span class="token identifier"><span class="token punctuation">`</span> varchar（20） NOT NULL COMMENT '守护者Id'
正例：
<span class="token punctuation">`</span></span>king_id<span class="token identifier"><span class="token punctuation">`</span> int(11) NOT NULL COMMENT '守护者Id'<span class="token punctuation">`</span></span>
理由：相对于数字型字段，字符型会降低查询和连接的性能，并会增加存储开销。
</code></pre> 
<h3><a id="_281"></a>尽量避免向客户端返回过多数据量。</h3> 
<pre><code class="prism language-sql">假设业务需求是，用户请求查看自己最近一年观看过的直播数据。

反例：
<span class="token comment">//一次性查询所有数据回来</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> LivingInfo <span class="token keyword">where</span> watchId <span class="token operator">=</span>useId <span class="token operator">and</span> watchTime <span class="token operator">&gt;=</span> Date_sub<span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">Interval</span> <span class="token number">1</span> Y<span class="token punctuation">)</span>

正例：
<span class="token comment">//分页查询</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> LivingInfo <span class="token keyword">where</span> watchId <span class="token operator">=</span>useId <span class="token operator">and</span> watchTime<span class="token operator">&gt;=</span> Date_sub<span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">Interval</span> <span class="token number">1</span> Y<span class="token punctuation">)</span> <span class="token keyword">limit</span> <span class="token keyword">offset</span>，pageSize

<span class="token comment">//如果是前端分页，可以先查询前两百条记录，因为一般用户应该也不会往下翻太多页，</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> LivingInfo <span class="token keyword">where</span> watchId <span class="token operator">=</span>useId <span class="token operator">and</span> watchTime<span class="token operator">&gt;=</span> Date_sub<span class="token punctuation">(</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">Interval</span> <span class="token number">1</span> Y<span class="token punctuation">)</span> <span class="token keyword">limit</span> <span class="token number">200</span> <span class="token punctuation">;</span>

</code></pre> 
<h3><a id="_297"></a>索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。</h3> 
<pre><code class="prism language-sql">因为<span class="token keyword">SQL</span>优化器是根据表中数据量来进行查询优化的，如果索引列有大量重复数据，
Mysql查询优化器推算发现不走索引的成本更低，很可能就放弃索引了。
</code></pre> 
<h3><a id="SQL_302"></a>当在SQL语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。</h3> 
<pre><code class="prism language-sql">反例：
<span class="token keyword">select</span>  <span class="token operator">*</span> <span class="token keyword">from</span> A <span class="token keyword">inner</span>
<span class="token keyword">join</span> B <span class="token keyword">on</span> A<span class="token punctuation">.</span>deptId <span class="token operator">=</span> B<span class="token punctuation">.</span>deptId<span class="token punctuation">;</span>
正例：
<span class="token keyword">select</span>  memeber<span class="token punctuation">.</span>name<span class="token punctuation">,</span>deptment<span class="token punctuation">.</span>deptName <span class="token keyword">from</span> A member <span class="token keyword">inner</span>
<span class="token keyword">join</span> B deptment <span class="token keyword">on</span> member<span class="token punctuation">.</span>deptId <span class="token operator">=</span> deptment<span class="token punctuation">.</span>deptId<span class="token punctuation">;</span>
</code></pre> 
<h3><a id="varcharnvarchar__charnchar_311"></a>尽可能使用varchar/nvarchar 代替 char/nchar。</h3> 
<pre><code class="prism language-sql">反例：
  <span class="token identifier"><span class="token punctuation">`</span>deptName<span class="token punctuation">`</span></span> <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'部门名称'</span>
正例：
  <span class="token identifier"><span class="token punctuation">`</span>deptName<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span> <span class="token keyword">COMMENT</span> <span class="token string">'部门名称'</span>
理由：
因为首先变长字段存储空间小，可以节省存储空间。
其次对于查询来说，在一个相对较小的字段内搜索，效率更高。

</code></pre> 
<h3><a id="group_by__323"></a>为了提高group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。</h3> 
<pre><code class="prism language-sql">反例：
<span class="token keyword">select</span> job，avg（salary） <span class="token keyword">from</span> employee  <span class="token keyword">group</span> <span class="token keyword">by</span> job <span class="token keyword">having</span> job <span class="token operator">=</span><span class="token string">'president'</span> 
<span class="token operator">or</span> job <span class="token operator">=</span> <span class="token string">'managent'</span>
正例：
<span class="token keyword">select</span> job，avg（salary） <span class="token keyword">from</span> employee <span class="token keyword">where</span> job <span class="token operator">=</span><span class="token string">'president'</span> 
<span class="token operator">or</span> job <span class="token operator">=</span> <span class="token string">'managent'</span> <span class="token keyword">group</span> <span class="token keyword">by</span> job；
</code></pre> 
<h3><a id="sql_333"></a>sql优化中，一个重要的基本原则就是“永远用小结果集驱动大的结果集”。</h3> 
<pre><code class="prism language-sql">为什么？因为驱动结果集越大，意味着需要循环的次数越多，也就是说在被驱动结果集上面所需要执行的查询检索次数会越多。
当然，此优化的前提条件是通过<span class="token keyword">Join</span>条件对各个表的每次访问的资源消耗差别不是太大。
如果访问存在较大的差别的时候（一般都是因为索引的区别），我们就不能简单的通过结果集的大小来判断需要<span class="token keyword">Join</span>语句的驱动顺序，
而是要通过比较循环次数和每次循环所需要的消耗的乘积的大小来得到如何驱动更优化。

</code></pre> 
<h3><a id="TRUNCATEDELETE_342"></a>合理选择TRUNCATE跟DELETE</h3> 
<pre><code class="prism language-sql">用<span class="token keyword">TRUNCATE</span>替代<span class="token keyword">DELETE</span>以释放空间<span class="token keyword">DELETE</span>：DML操作，数据存放在回滚段<span class="token punctuation">(</span><span class="token keyword">rollback</span> segments<span class="token punctuation">)</span>中，
执行<span class="token keyword">COMMIT</span>则真正删除，反之回滚。<span class="token keyword">TRUNCATE</span>：DDL操作，会彻底删除数据，不存回滚段；
资源调用少、执行快。彻底不用的表可以采用此命令。
</code></pre> 
<p><img src="https://images2.imgbox.com/df/aa/JzZMQjhs_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_350"></a>终极调优思维</h2> 
<h3><a id="explain_SQL_351"></a>使用explain 分析你SQL的计划</h3> 
<pre><code class="prism language-sql">日常开发写<span class="token keyword">SQL</span>的时候，尽量养成一个习惯吧。用<span class="token keyword">explain</span>分析一下你写的<span class="token keyword">SQL</span>，尤其是走不走索引这一块。
<span class="token keyword">explain</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> userid <span class="token operator">=</span><span class="token number">10086</span> <span class="token operator">or</span> age <span class="token operator">=</span><span class="token number">18</span><span class="token punctuation">;</span>
</code></pre> 
<table><thead><tr><th><strong>优化法则</strong></th><th><strong>性能提升效果</strong></th><th><strong>优化成本</strong></th></tr></thead><tbody><tr><td>减少数据访问（减少磁盘访问）</td><td>1~1000</td><td>低</td></tr><tr><td>返回更少数据 （减少网络传输或磁盘访问）</td><td>1~100</td><td>低</td></tr><tr><td>减少交互次数（减少网络传输）</td><td>1~20</td><td>低</td></tr><tr><td>减少服务器CPU开销（减少CPU及内存开销）</td><td>1~5</td><td>低</td></tr><tr><td>利用更多资源（增加资源）</td><td>@~10</td><td>高</td></tr></tbody></table> 
<p><img src="https://images2.imgbox.com/d2/c6/GsEhImYG_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4f918b9d966fa7602872707cfad9d12f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">libevent 报 undefined reference to `getrandom‘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/945b93be10964c8f875d8ac9d97a127c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【学习笔记】可视化工具之 Superset</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>