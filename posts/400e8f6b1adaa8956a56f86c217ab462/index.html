<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python——函数/方法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python——函数/方法" />
<meta property="og:description" content="1.函数 •所谓函数，就是把 具有独立功能的代码块 组织为一个小模块，在需要的时候调用； •函数的使用包含两个步骤： 1.定义函数 —— 封装 独立的功能；2.调用函数 —— 享受 封装 的成果；
•函数的作用，在开发程序时，使用函数可以提高编写的效率以及代码的 重用
2.函数的参数：函数(参数) 2.1 函数参数的使用 •在函数名的后面的小括号内部填写 参数
•多个参数之间使用 , 分隔
例如：sum_2_num(num1, num2)
2.2参数的作用 函数的参数，增加函数的 通用性，针对 相同的数据处理逻辑，能够 适应更多的数据 ①.在函数 内部，把参数当做 变量 使用，进行需要的数据处理
②.函数调用时，按照函数定义的参数顺序，把 希望在函数内部处理的数据，通过参数 传递
2.3形参与实参 形参（形式上的参数），定义 函数时，小括号中的参数，是用来接收参数用的，在函数内部 作为变量使用
实参（实际要用的参数），调用 函数时，小括号中的参数，是用来把数据传递到 函数内部 用的
可混合使用位置实参、关键字实参和默认值实参。
①位置实参(实参顺序很重要)
def pet(animal_type,pet_name):
snip
pet(&#39;dog&#39;,&#39;lucky&#39;)
②关键字实参
关键字实参是传递给函数的名称-值对，直接在实参中将名称和值关联起来了，因此向函数传递实参时不会混淆。不用考虑函数调用的实参顺序。
def pet(animal_type,pet_name):
snip
pet(animal_type=&#39;dog&#39;,pet_name=&#39;lucky&#39;)
③默认值实参
•定义函数时，可以给 某个参数 指定一个默认值，具有默认值的参数就叫做 缺省参数（默认值实参）
•调用函数时，如果没有传入 缺省参数 的值，则在函数内部使用定义函数时指定的 参数默认值；如果给形参提供了实参时，则使用指定的实参值
•函数的缺省参数，将常见的值设置为参数的缺省值，从而 简化函数的调用
例如：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/400e8f6b1adaa8956a56f86c217ab462/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-26T13:43:08+08:00" />
<meta property="article:modified_time" content="2023-09-26T13:43:08+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python——函数/方法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.函数</h2> 
<p>•所谓函数，就是把 具有独立功能的代码块 组织为一个小模块，在需要的时候调用；  </p> 
<p>•函数的使用包含两个步骤： 1.定义函数 —— 封装 独立的功能；2.调用函数 —— 享受 封装 的成果；</p> 
<p>•函数的作用，在开发程序时，使用函数可以提高编写的效率以及代码的 重用</p> 
<h2>2.函数的参数：函数(参数)</h2> 
<h3>  2.1 函数参数的使用</h3> 
<p>  •在函数名的后面的小括号内部填写 参数<br>   •多个参数之间使用 , 分隔</p> 
<p>   例如：sum_2_num(num1, num2)</p> 
<h3>  2.2参数的作用</h3> 
<p>   函数的参数，增加函数的 通用性，针对 相同的数据处理逻辑，能够 适应更多的数据    </p> 
<p>   ①.在函数 内部，把参数当做 变量 使用，进行需要的数据处理<br>    ②.函数调用时，按照函数定义的参数顺序，把 希望在函数内部处理的数据，通过参数 传递</p> 
<h3>  2.3形参与实参</h3> 
<p>  形参（形式上的参数），<strong>定义</strong> 函数时，小括号中的参数，是用来接收参数用的，在函数内部 作为变量使用</p> 
<p>  实参（实际要用的参数），<strong>调用</strong> 函数时，小括号中的参数，是用来把数据传递到 函数内部 用的</p> 
<p>  可混合使用位置实参、关键字实参和默认值实参。</p> 
<p>  ①位置实参(实参顺序很重要)</p> 
<p>  def pet(animal_type,pet_name):</p> 
<p>      snip</p> 
<p>  pet('dog','lucky')</p> 
<p>  ②关键字实参</p> 
<p>关键字实参是传递给函数的名称-值对，直接在实参中将名称和值关联起来了，因此向函数传递实参时不会混淆。不用考虑函数调用的实参顺序。</p> 
<p>  def pet(animal_type,pet_name):</p> 
<p>      snip</p> 
<p>  pet(animal_type='dog',pet_name='lucky')</p> 
<p>  ③默认值实参</p> 
<p>  •定义函数时，可以给 某个参数 指定一个默认值，具有默认值的参数就叫做 缺省参数（默认值实参）<br>   •调用函数时，如果没有传入 缺省参数 的值，则在函数内部使用定义函数时指定的 参数默认值；如果给形参提供了实参时，则使用指定的实参值<br>   •函数的缺省参数，将常见的值设置为参数的缺省值，从而 简化函数的调用</p> 
<p>  例如：</p> 
<p>  def pet(pet_name，animal_type='dog'):</p> 
<p>       snip</p> 
<p>   pet(pet_name='lucky')</p> 
<p>  注意事项：</p> 
<p>  1) 缺省参数的定义位置<br>    •<strong>必须保证 带有默认值的缺省参数在参数列表末尾</strong></p> 
<p>  2) 调用带有多个缺省参数（默认值实参）的函数<br>    •在 调用函数时，如果有 多个缺省参数，需要指定参数名，这样解释器才能够知道参数的对应关系</p> 
<h3>  2.4不可变和可变的参数 </h3> 
<p>可变类型参数：列表_list, 字典_dict、set<br> 不可变类型参数：数字型（int,bool,float,complex,long）、字符串、元组、日期</p> 
<p>问题 1：在函数内部，针对参数使用 赋值语句，会不会影响调用函数时传递的 实参变量？</p> 
<p>         —— 不会！无论传递的参数是 可变 还是 不可变 ，只要 针对参数 使用 赋值语句，会在 函数<strong>内部</strong> 修改 局部变量的引用，不会影响到 <strong>外部</strong>变量的引用。</p> 
<pre><code class="language-python">def demo (num, num_list) :
     num = 200
     num_list = [1,2,3]

     print(num)
     print(num_list)

demo(10,[5,6])
#输出结果：
200
[1, 2, 3] </code></pre> 
<p>  问题 2：如果传递的参数是 可变类型，在函数内部，使用 方法 修改了数据的内容，同样会影响到外部的数据</p> 
<pre><code class="language-python">def demo2 (num_list):
     num_list.extend([1,2,3])
     print(num_list)

demo2([11,22])
#输出结果：[11, 22, 1, 2, 3]</code></pre> 
<h3>2.5传递列表</h3> 
<p><strong>  参数为列表：</strong></p> 
<pre><code class="language-python">'''向列表的每位用户发出简单的问候'''
def greet_users(names):
    for name in names:
        msg = "Hello, " + name.title() + "!"
        print(msg)

usernames = ['hannah','ty','margot']
greet_users(usernames)
'''输出：
Hello, Hannah!
Hello, Ty!
Hello, Margot!
'''</code></pre> 
<p><strong>在函数中修改列表：</strong></p> 
<p>在函数中对这个列表所做的任何修改都是永久性的。</p> 
<p>原函数：</p> 
<pre><code class="language-python">'''打印设计好的模型：模拟打印每个设计，直到没有未打印的设计为止'''
unprinted_designs = ['iphone case','robot pendant','dodecahedron']
completed_models = []

while unprinted_designs:
    current_design = unprinted_designs.pop()
    print("Printting model: " + current_design)
    completed_models.append(current_design)

print("\nThe following models have been printed:")
for completed_model in completed_models:
    print(completed_model)
    
'''
Printting model: dodecahedron
Printting model: robot pendant
Printting model: iphone case

The following models have been printed:
dodecahedron
robot pendant
iphone case
'''</code></pre> 
<p>改造成函数：</p> 
<pre><code class="language-python">def print_models(unprinted_designs,completed_models):
    while unprinted_designs:
        current_design = unprinted_designs.pop()
        print("Printting model: " + current_design)
        completed_models.append(current_design)

def show_completed_models(completed_models):
    print("\nThe following models have been printed:")
    for completed_model in completed_models:
        print(completed_model)

unprinted_designs = ['iphone case','robot pendant','dodecahedron']
completed_models = []
print_models(unprinted_designs,completed_models)
show_completed_models(completed_models)

'''
Printting model: dodecahedron
Printting model: robot pendant
Printting model: iphone case

The following models have been printed:
dodecahedron
robot pendant
iphone case
[]
'''</code></pre> 
<p><strong>禁止函数修改列表：</strong></p> 
<p> 有时候，需要禁止修改函数列表。你如上述例子，即便打印所有设计后，也要保留原来未打印的设计列表，以供备案。</p> 
<p>解决方案：可向函数传递列表的副本而不是原件。function_name(list_name[:])，切片表示法[:]创建列表的副本。</p> 
<pre><code class="language-python">def print_models(unprinted_designs,completed_models):
    while unprinted_designs:
        current_design = unprinted_designs.pop()
        print("Printting model: " + current_design)
        completed_models.append(current_design)

def show_completed_models(completed_models):
    print("\nThe following models have been printed:")
    for completed_model in completed_models:
        print(completed_model)

unprinted_designs = ['iphone case','robot pendant','dodecahedron']
completed_models = []
print_models(unprinted_designs[:],completed_models)
show_completed_models(completed_models)
print(unprinted_designs)

'''
Printting model: dodecahedron
Printting model: robot pendant
Printting model: iphone case

The following models have been printed:
dodecahedron
robot pendant
iphone case
['iphone case', 'robot pendant', 'dodecahedron']
''</code></pre> 
<h3>2.6多值参数</h3> 
<p>  定义 支持多值参数 的函数：</p> 
<p>  •有时可能需要一个函数能够处理的参数 个数 是不确定的，这个时候，就可以使用多值参数，Python允许函数从调用语句中<strong>收集任意数量的实参</strong>。<br>   •python 中有 两种 多值参数： ◦参数名前增加 一个* 可以接收 元组<br>                                                    ◦参数名前增加 两个* 可以接收 字典<br>   •一般在给多值参数命名时，习惯使用以下两个名字<br>       *args（args 是 arguments 的缩写，有变量的含义） —— 存放 元组 参数，前面有一个 *<br>       **kwargs（kw 是 keyword 的缩写，kwargs 可以记忆 键值对参数） —— 存放 字典 参数，前面有两个 *</p> 
<p>  案例：计算任意多个数字的和：</p> 
<pre><code class="language-python">def sum_numbers(*args):
    num = 0
    # 遍历 args 元组顺序求和
    for n in args:
        num += n
    return num
print(sum_numbers(1, 2, 3)) #结果：6</code></pre> 
<pre><code class="language-python">'''创建一个字典，包含我们知道的有关用户的一切'''
def build_profile(first,last,**user_info):
    profile = {}
    profile['first_name'] = first
    profile['last_name'] = last
    for key,value in user_info.items():
        profile[key] = value
    return profile
user_profile = build_profile('albert','einstein',location='princeton',field = 'physics')
print(user_profile) #{'field': 'physics', 'first_name': 'albert', 'last_name': 'einstein', 'location': 'princeton'}</code></pre> 
<p> <strong>元组和字典的拆包：</strong></p> 
<p>  •在<strong>调用</strong>带有多值参数的函数时，如果希望： ◦将一个 元组变量，直接传递给 args<br>                                                                         ◦将一个 字典变量，直接传递给 kwargs</p> 
<p>  •就可以使用 拆包，简化参数的传递，拆包 的方式是： ◦在 元组变量前，增加 一个 *<br>                                                                                          ◦在 字典变量前，增加 两个 *</p> 
<pre><code>def demo(*args, **kwargs):
    print(args)
    print(kwargs)

gl_nums = (1, 2, 3)
gl_dict = {"name": "小明", "age": 18}
demo(*gl_nums, **gl_dict)
'''结果 
(1, 2, 3)    
{'name': '小明', 'age': 18}
'''</code></pre> 
<p>如果调用函数变量前不使用星号：</p> 
<pre><code>def demo(*args, **kwargs):
    print(args)
    print(kwargs)


gl_nums = (1, 2, 3)
gl_dict = {"name": "小明", "age": 18}
demo(gl_nums, gl_dict)
'''结果
((1, 2, 3), {'age': 18, 'name': '小明'})
{}
'''</code></pre> 
<h2>3.函数的返回值</h2> 
<p>•在程序开发中，有时候会希望一个函数执行结束后，告诉调用者一个结果，以便调用者针对具体的结果做后续的处理<br> •返回值 是函数完成工作后，最后给调用者的 一个结果<br> •在函数中使用 return 关键字可以返回结果<br> •调用函数一方，可以使用变量来接收函数的返回结果</p> 
<p>注意：return 表示返回，后续的代码都不会被执行</p> 
<h3>（1）返回简单值</h3> 
<p>举例:</p> 
<pre><code class="language-python">"""对两个数字的求和"""
def sum_2_num(num1, num2):
    return num1 + num2

# 调用函数，并使用 result 变量接收计算结果
result = sum_2_num(10, 20)
print("计算结果是 %d" % result) #计算结果是 30</code></pre> 
<h3> （2）让实参变为可选的</h3> 
<p>有时候需要让实参变为可选的，这样调用函数时只需在必要时才提供额外的信息，可使用默认值来让实参变成可选的。</p> 
<p>举例：get_formatted_name()</p> 
<pre><code class="language-python">def get_formatted_name(first_name,middle_name,last_name):
    full_name = first_name + ' ' + middle_name + ' ' + last_name
    return full_name

musician = get_formatted_name('John','Lee','Hooker')
print(musician) #John Lee Hooker</code></pre> 
<p>然而并非所有人都有中间名，如果只提供名和姓，该函数不能正常运行。改造：</p> 
<pre><code class="language-python">def get_formatted_name(first_name,last_name,middle_name=''):
    if middle_name:
        full_name = first_name + ' ' + middle_name + ' ' + last_name
    else:
        full_name = first_name + ' ' + last_name
    return full_name

musician = get_formatted_name('John','Lee','Hooker')
print(musician) #John Lee Hooker
dancer = get_formatted_name('Jimmy','Hendrix')
print(dancer) #Jimmy Hendrix</code></pre> 
<h3>（3）返回字典</h3> 
<p>函数可返回任何类型的值，包括列表和字典等复杂的数据结构。</p> 
<pre><code class="language-python">def build_person(first_name,last_name,age=''):
    person = {'first':first_name,'last':last_name}
    if age:
        person['age'] = age
    return person

musician = build_person('Jimi','Hendrix')
print(musician) #{'last': 'Hendrix', 'first': 'Jimi'}
musician = build_person('Jimi','Hendrix',age=27)
print(musician) #{'first': 'Jimi', 'age': 27, 'last': 'Hendrix'}</code></pre> 
<p><strong>函数参数和返回值的作用</strong></p> 
<p>定义函数时，是否接收参数，或者是否返回结果，是根据 实际的功能需求 来决定的<br> 1.如果函数 内部处理的数据不确定，就可以将外界的数据以参数传递到函数内部<br> 2.如果希望一个函数 执行完成后，向外界汇报执行结果，就可以增加函数的返回值</p> 
<h2>4.函数的嵌套调用</h2> 
<p> 一个函数里面又调用了另外一个函数，这就是 函数嵌套调用。</p> 
<p><strong>函数的递归</strong>：一个函数 内部 调用自己 <br>                      ◦函数内部可以调用其他函数，当然在函数内部也可以调用自己</p> 
<p>代码特点<br> 1.函数内部的 代码 是相同的，只是针对 参数 不同，处理的结果不同<br> 2.当参数满足一个条件 时，函数不再执行 <br>     •这个非常重要，通常被称为递归的出口，否则 会出现死循环！</p> 
<pre><code class="language-python">def f(x):
    if x &gt; 0:
        return x + f(x - 1)
    else:
        return 0


print(f(100))  # 5050</code></pre> 
<h2>5.使用模块中的函数</h2> 
<p>   模块是 Python 程序架构的一个核心概念<br> •模块 就好比是 工具包，要想使用这个工具包中的工具，就需要 导入( import) 这个模块<br> •每一个以扩展名 .py 结尾的 Python 源代码文件都是一个 模块<br> •在模块中定义的 全局变量 、函数 都是模块能够提供给外界直接使用的工具</p> 
<p>模块可以让 曾经编写过的代码方便的被 复用！</p> 
<p>•可以 在一个 Python 文件 中 定义 变量 或者 函数<br> •然后在 另外一个文件中 使用 import 导入这个模块<br> •导入之后，就可以使用 模块名.变量 / 模块名.函数 的方式，使用这个模块中定义的变量或者函数</p> 
<p><strong>将函数存储在模块中</strong></p> 
<p>import 模块名字</p> 
<p>import 模块名字 as 简略名字</p> 
<p>#导入模块中的所有函数</p> 
<p>from 模块名字 import *</p> 
<p>#导入特定函数</p> 
<p>from 模块名字 import 函数名字</p> 
<h2>6.方法：对象.方法名(参数)</h2> 
<p>•方法 和函数类似，同样是封装了独立的功能<br> •方法 需要通过 对象 来调用，表示针对这个 对象 要做的操作</p> 
<h2>7.常见方法</h2> 
<h4 id="main-toc"> input()</h4> 
<p>输入函数input()，函数等待用户在键盘上输入一些文本，并按下回车键，这个函数求值为一个字符串，即用户输入的文本。比如：myname = input()，你可以认为input()函数调用是一个表达式，它求值为用户输入的任何字符串。如果用户输入'Al'，那么该表达式就求值为myName = 'Al'。</p> 
<h4 id="print()">print()</h4> 
<p>输出函数print()，1.向控制台输出内容结束之后，不会换行：print("*******", end="")；<br>                             2.单纯的换行：print("*********")</p> 
<p>                           end = ""，表示输出结束后，不换行<br>                            "\t" 可以在控制台输出一个制表符，协助在输出文本时对齐</p> 
<p>                           print("%d * %d = %d" % (col, row, row * col), end="\t")   # 用%表示前后对应</p> 
<pre><code>title = driver.title
print("title:"+ title)#或者print("title:",title)</code></pre> 
<pre><code class="language-python">def pet(animal_type, pet_name):
    print("It's a " + animal_type + ",and it's name is " + pet_name) # It's a dog,and it's name is lucky
    print("It's a %s,and it's name is %s" % (animal_type,pet_name)) #It's a dog,and it's name is lucky
pet('dog', 'lucky')</code></pre> 
<p></p> 
<h4>int()</h4> 
<pre><code class="language-html">class int(x, base=10)</code></pre> 
<ul><li>x -- 字符串或数字。</li><li>base -- 进制数，默认十进制。</li></ul> 
<p><img alt="" height="227" src="https://images2.imgbox.com/e4/42/v8sI7XgK_o.png" width="713"></p> 
<h4 id="len()">len()</h4> 
<p>len()函数，你可以向len()函数传递一个字符串（或包含字符串的变量），然后该函数求值为一个整型值，即字符串中字符的个数。</p> 
<h4>split()</h4> 
<p>string.split(str="", num) 以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 '\r', '\t', '\n' 和空格。</p> 
<p>num -- 分割次数。默认为 -1, 即分隔所有。</p> 
<pre><code>str = "Line1-abcdef \nLine2-abc \nLine4-abcd"
print(str.split( ))     # 以空格为分隔符，包含 \n
print(str.split(' ', 1 ))# 以空格为分隔符，分隔成两个</code></pre> 
<p>结果：</p> 
<p>['Line1-abcdef', 'Line2-abc', 'Line4-abcd']<br> ['Line1-abcdef', '\nLine2-abc \nLine4-abcd'] </p> 
<h4 id="eval()">eval()</h4> 
<p>评估函数eval()，去掉参数最外侧引号并执行剩下的语句</p> 
<h4 id="format()">format()</h4> 
<p>{  }.format( )，{ }表示槽，后续format里面的变量填充到槽里</p> 
<p>&gt;&gt;&gt;"{} {}".format("hello", "world") # 不设置指定位置，按默认顺序 'hello world'</p> 
<p>&gt;&gt;&gt; "{0} {1}".format("hello", "world") # 设置指定位置 'hello world'</p> 
<p>&gt;&gt;&gt; "{1} {0} {1}".format("hello", "world") # 设置指定位置 'world hello world'</p> 
<h4 id="round()">round()</h4> 
<p>round()，通常让小数精确到小数点后多少位，其中小数位数是由第二个实参指定的。如果将第二个实参指定为负数，round()将圆整到最近的10,100,1000等整数倍。</p> 
<p>round(number,digits)</p> 
<ol><li>digits&gt;0，四舍五入到指定的小数位</li><li>digits=0, 四舍五入到最接近的整数</li><li>digits&lt;0 ，在小数点左侧进行四舍五入</li><li>如果round()函数只有number这个参数，等同于digits=0</li></ol> 
<p>四舍五入规则：</p> 
<ol><li>要求保留位数的后一位&lt;=4，则舍去，如5.214保留小数点后两位，结果是5.21</li><li>要求保留位数的后一位“=5”，且该位数后面没有数字，则不进位，如5.215，结果为5.21</li><li>要求保留位数的最后一位“=5”，且该位数后面有数字，则进位，如5.2151，结果为5.22</li><li>要求保留位数的最后一位“&gt;=6”，则进位。如5.216，结果为5.22</li></ol> 
<h4>yield()</h4> 
<p>yield 的函数在 Python 中被称之为 generator（生成器）,不像一般的函数会生成值后退出，生成器函数在生成值后会自动挂起并暂停他们的执行和状态，他的本地变量将保存状态信息，这些信息在函数恢复时将再度有效。</p> 
<p>为什么叫生成器函数？因为他随着时间的推移生成了一个数值队列。一般的函数在执行完毕之后会返回一个值然后退出，但是生成器函数会自动挂起，然后重新拾起继续执行，他会利用yield关键字关起函数，给调用者返回一个值，同时保留了当前的足够多的状态，可以使函数继续执行。生成器和迭代协议是密切相关的，可迭代的对象都有一个__next()__成员方法,这个方法要么返回迭代的下一项，要么引起异常结束迭代。为了支持迭代协议，拥有yield语句的函数被编译为生成器，这类函数被调用时返回一个生成器对象，返回的对象支持迭代接口，即成员方法__next()__继续从中断处执行执行。</p> 
<pre><code>def myfun(total):
    for i in range(total):
        yield i</code></pre> 
<p>生成器有3种调用方式：</p> 
<p>①用next调用</p> 
<pre><code>&gt;&gt;&gt; m = myfun(4)
&gt;&gt;&gt; next(m)
0
&gt;&gt;&gt; next(m)
1
&gt;&gt;&gt; next(m)
2
&gt;&gt;&gt; next(m)
3
&gt;&gt;&gt; next(m)
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
StopIteration</code></pre> 
<p>②循环调用</p> 
<pre><code>for i in myfun(4):
    print(i)</code></pre> 
<p>③循环中调用next</p> 
<pre><code>&gt;&gt;&gt; m = myfun(4)
&gt;&gt;&gt; while True:
...     try:
...         print(next(m))
...     except StopIteration:
...         break</code></pre> 
<h4>range()</h4> 
<p>函数原型：range（start， end， scan):</p> 
<p>参数含义：</p> 
<ul><li>start:计数从start开始。默认是从0开始。例如range（5）等价于range（0， 5）;</li><li>end:计数到end结束，但不包括end.例如：range（0， 5） 是[0, 1, 2, 3, 4]没有5</li><li>scan：每次跳跃的间距，默认为1，且step可正可负，但不能为0。例如：range(3,100,25)，结果是3,28,53,78</li></ul> 
<p>range() 函数返回的结果是一个整数序列的对象。</p> 
<p>另：</p> 
<pre><code>a = int(input())
#range(a)就是range(你输入的数)
for i in range(a):</code></pre> 
<pre><code class="language-python">li = ["alec", " aric", "Alex", "Tony", "rain"]
tu = ("alec", " aric", "Alex", "Tony", "rain")
dic = {'k1': "alex", 'k2': ' aric',  "k3": "Alex", "k4": "Tony"}

for a in range(len(li)):
    pass
print(li) # ['alec', ' aric', 'Alex', 'Tony', 'rain']

for b in range(len(tu)):
    pass
print(tu) #('alec', ' aric', 'Alex', 'Tony', 'rain')

for c in dic:
    pass
print(dic) #{'k1': 'alex', 'k2': ' aric', 'k3': 'Alex', 'k4': 'Tony'}</code></pre> 
<pre><code class="language-python">for i in range(10, -6, -2):
    print(i)
'''
结果：
10
8
6
4
2
0
-2
-4
'''</code></pre> 
<h4></h4> 
<h4>count()</h4> 
<p>count() 方法用于统计字符串里某个字符出现的次数</p> 
<p>语法：str.count(sub, start=0,end=len(string))</p> 
<ul><li>sub -- 搜索的子字符串</li><li>start -- 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。</li><li>end -- 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。</li></ul> 
<pre><code>str = "this is string example....wow!!!"
sub = "i"
print("str.count(sub, 4, 40) : ", str.count(sub, 4, 40))</code></pre> 
<p>结果：str.count(sub, 4, 40) :  2</p> 
<h4>List count()</h4> 
<p>返回元素在列表中出现的次数。</p> 
<pre><code class="language-html">list.count(obj)   #obj -- 列表中统计的对象。必需。任何类型（字符串、数字、列表、元组等）。要搜索的值。</code></pre> 
<pre><code>aList = [123, 'xyz', 'zara', 'abc', 123];
print ("Count for 123 : ", aList.count(123))
print ("Count for zara : ", aList.count('zara'))</code></pre> 
<p>结果：</p> 
<p>Count for 123 :  2<br> Count for zara :  1</p> 
<h4>max()</h4> 
<p>max() 方法返回给定参数的最大值，或者 iterable（可迭代对象，包含一个或多个供比较的项目） 中有最大值的项目。如果值是字符串，则按字母顺序进行比较</p> 
<p>语法：</p> 
<p><code>max</code>(<em>iterable</em>, <em>*</em>[, <em>key</em>, <em>default</em>])</p> 
<p><code>max</code>(<em>arg1</em>, <em>arg2</em>, <em>*args</em>[, <em>key</em>])    #命名参数key，其为一个函数，用来指定取最大值的方法（<em>key</em> 实参指定排序函数用的参数）。default命名参数用来指定最大值不存在时返回的默认值。</p> 
<p>和其他稳定排序工具如 <code>sorted(iterable, key=keyfunc, reverse=True)一致。</code></p> 
<ul><li>默认数值型参数，取值大者；</li><li>当存在多个相同的最大值时，返回的是最先出现的那个最大值</li><li>字符型参数，取字母表排序靠后者；</li><li>序列型参数，则依次按索引位置的值进行比较取最大者。</li><li>还可以通过传入命名参数key，指定取最大值方法。</li></ul> 
<p>举例：</p> 
<pre><code>#传入的多个参数的最大值
print(max(80, 100, 1000)) #1000
#传入可迭代对象时，取其元素最大值
a = '12345'
print(max(a)) #5
a='1,2,3,4'
print(type(a)) #&lt;class 'str'&gt;
print(max(a)) #4
a=[1,2,3,4]
print(type(a)) #&lt;class 'list'&gt;
print(max(a)) #4
# #列表里面的元素都由元组构成，元组都由数字组成，输出最大值
a=[(1,2),(2,3),(3,4)]
print(max(a)) #(3, 4)
#因为ascii 码里面，按照排列顺序 小 a在 A的后面
a=[('a',1),('A',1)]
print(max(a))  #('a', 1)
#比较字典里面的最大值，会输出最大的键值
a={1:2,2:2,3:1,4:'aa'}
print(max(a)) #4
#传入可迭代对象为空时，必须指定参数default，用来返回默认值输出。如果可迭代对象为空，并且没有给 default ，则会触发 ValueError
print(max((),default=1)) #1
#传入命名参数key，其为一个函数，用来指定取最大值的方法
a = [
    {'name': 'sumcet', 'age': 18},
    {'name': 'bbu', 'age': 11}]
print(max(a, key=lambda x: x['age']))  #{'age': 18, 'name': 'sumcet'}
#key参数的另外一个作用是，不同类型对象本来不能比较取最大值的，传入适当的key函数，变得可以比较能取最大值了。
print(max(1,2,'3',key = int)) #3
print(max(-1,0,key = abs)) # -1</code></pre> 
<pre><code>当传入参数为数据类型不一致时，传入的所有参数将进行隐式数据类型转换后再比较，如果不能进行隐式数据类型转换，则会报错：
</code> </pre> 
<pre><code>&gt;&gt;&gt; max(1,1.1,1.3E1)
13.0
&gt;&gt;&gt; max(1,2,3,'3')
Traceback (most recent call last):
  File "&lt;pyshell#1&gt;", line 1, in &lt;module&gt;
    max(1,2,3,'3')
TypeError: unorderable types: str() &gt; int()
&gt;&gt;&gt; max([1,2],(1,3))
Traceback (most recent call last):
  File "&lt;pyshell#2&gt;", line 1, in &lt;module&gt;
    max([1,2],(1,3))
TypeError: unorderable types: tuple() &gt; list()</code></pre> 
<h4>join()</h4> 
<pre><code class="language-html">str.join(sequence):用于将序列中的元素以指定的字符连接生成一个新的字符串</code></pre> 
<pre><code>str = "-";
seq = ("a", "b", "c"); # 字符串序列
print str.join( seq );</code></pre> 
<p>结果：a-b-c</p> 
<h4>ctime()</h4> 
<p>Python time ctime() 函数把一个时间戳（按秒计算的浮点数）转化为time.asctime()的形式。 如果参数未给或者为None的时候，将会默认time.time()为参数。它的作用相当于 asctime(localtime(secs))。</p> 
<pre><code>from time import ctime
print("time is %s" % ctime())</code></pre> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1a20f3550bdf20bfc13708a11e85f544/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">小猫爪：嵌入式小知识18-XCP SeedNKey.dll</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/21af8d9c2ff605cf8baaf75c6cf70ba4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">用Dockerfile构建镜像</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>