<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>集合Map详述---HashMap、HashTable（底层实现原理） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="集合Map详述---HashMap、HashTable（底层实现原理）" />
<meta property="og:description" content="一、Map概述 1、Map特点 （1）Map和Collection没有继承关系，是单独的一个分支
（2）Map集合以键值对方式存储 &lt;key,value&gt;
key和value都是引用数据类型，存储的是对象的内存地址
key起到主导地位，value是key的一个附属品
2、Map接口中常用方法 向Map集合中添加键值对---------V put（K，V） 通过key获取value--------------V get(key) 获取map集合中所有key-------Set keySet（） 所有的键是一个set集合 获取map集合中键值对的个数----int size（） 获取map集合中所有value-----Collection values（） 通过key删除键值对------------V remove（key） 清空map集合-----------------void clear（） 判断是否包含某个key---------boolean cotainsKey（key） 判断是否包含某个value---------boolean cotainsValue（value） 判断是否是否为空，元素个数为0---------boolean isEmpty（） Map集合转成Set集合--------- Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() 将map中的key和value转成一个set集合，set集合中存储的对象为Map.Entry类型对象，对象包含key和value两个属性 3、Map集合的遍历 Map&lt;Integer,String&gt; map=new HashMap&lt;&gt;(); map.put(1,&#34;zs&#34;); map.put(2,&#34;ls&#34;); map.put(3,&#34;ww&#34;); （1）获取所有key，通过遍历key，来遍历value
迭代器 //获得所有Key---Set集合 Set&lt;Integer&gt; keys=map.KeySet(); //迭代器遍历 Iterator&lt;Integer&gt; it=keys.iterator(); while(it.hasNext()){ System.out.println(it.next()); } foreach
//获得所有Key---Set集合 Set&lt;Integer&gt; keys=map.KeySet(); //foreach迭代 for(Integer k:keys){ System.out.println(k&#43;&#34;---&gt;&#34;&#43;map.get(k)); //1---&gt;zs } （2）将map集合全部转成set集合，遍历set集合（适合大数据量）
//Map集合---&gt;Set集合(key部分是一个Entry数组) Set&lt;Map.Entry&lt;Integer,String&gt;,String&gt; set=map.entrySet(); //迭代器遍历 Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it=set.iterator(); while(it.hasNext()){ System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1360260f955fcb945c672d762e352c44/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-13T21:46:56+08:00" />
<meta property="article:modified_time" content="2021-09-13T21:46:56+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">集合Map详述---HashMap、HashTable（底层实现原理）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、Map概述</h2> 
<h4>1、Map特点 </h4> 
<p>（1）Map和Collection没有继承关系，是单独的一个分支</p> 
<p>（2）Map集合以键值对方式存储 &lt;key,value&gt;</p> 
<p>           key和value都是引用数据类型，存储的是对象的内存地址</p> 
<p>           key起到主导地位，value是key的一个附属品</p> 
<h4>2、Map接口中常用方法</h4> 
<pre><code>向Map集合中添加键值对---------V     put（K，V）

通过key获取value--------------V      get(key)

获取map集合中所有key-------Set     keySet（）   所有的键是一个set集合

获取map集合中键值对的个数----int    size（）

获取map集合中所有value-----Collection values（）

通过key删除键值对------------V       remove（key）

清空map集合-----------------void    clear（）

判断是否包含某个key---------boolean  cotainsKey（key）

判断是否包含某个value---------boolean  cotainsValue（value）

判断是否是否为空，元素个数为0---------boolean  isEmpty（）

Map集合转成Set集合--------- Set&lt;Map.Entry&lt;K,V&gt;&gt;   entrySet()    
    将map中的key和value转成一个set集合，set集合中存储的对象为Map.Entry类型对象，对象包含key和value两个属性</code></pre> 
<h4>3、Map集合的遍历</h4> 
<pre><code>Map&lt;Integer,String&gt; map=new HashMap&lt;&gt;();
map.put(1,"zs");
map.put(2,"ls");
map.put(3,"ww");</code></pre> 
<p>（1）获取所有key，通过遍历key，来遍历value</p> 
<ul><li>     迭代器</li></ul> 
<pre><code>//获得所有Key---Set集合
Set&lt;Integer&gt; keys=map.KeySet();

//迭代器遍历
Iterator&lt;Integer&gt; it=keys.iterator();
while(it.hasNext()){
   System.out.println(it.next());
} </code></pre> 
<p>foreach</p> 
<pre><code>//获得所有Key---Set集合
Set&lt;Integer&gt; keys=map.KeySet();

//foreach迭代
for(Integer k:keys){
   System.out.println(k+"---&gt;"+map.get(k)); //1---&gt;zs
}</code></pre> 
<p>（2）将map集合全部转成set集合，遍历set集合（适合大数据量）</p> 
<pre><code>//Map集合---&gt;Set集合(key部分是一个Entry数组)
Set&lt;Map.Entry&lt;Integer,String&gt;,String&gt; set=map.entrySet();

//迭代器遍历
Iterator&lt;Map.Entry&lt;Integer,String&gt;&gt; it=set.iterator();
while(it.hasNext()){
   System.out.println(it.next());
} 

//foreach遍历
for(Map.Entry&lt;Integer,String&gt; node:set){
   System.out.println(node.getKey()+"---&gt;"+node.getValue()); //1=zs
}</code></pre> 
<h2>二、HashMap</h2> 
<h3>（一）底层结构</h3> 
<p>   1、哈希表=数组+单向链表</p> 
<p>   2、哈希表是一个数值和单向链表的结合体，融合了两种数据结构的优点</p> 
<p>        数组：查询快</p> 
<p>        链表：增删改快</p> 
<p>3、HashMap的key value实质是存在Entry中，Entry是hashMap中封装key-value键值对的</p> 
<p><img alt="" height="313" src="https://images2.imgbox.com/2a/8e/pS5QGUp0_o.png" width="597"></p> 
<p> 此部分来源：<a href="https://blog.csdn.net/strivenoend/article/details/80397825" title="(1条消息) hashmap的实现原理 数组 entry_Mar.三月-CSDN博客_entry数组">(1条消息) hashmap的实现原理 数组 entry_Mar.三月-CSDN博客_entry数组</a> </p> 
<p> </p> 
<h3>（二）底层源码</h3> 
<p><img alt="" height="348" src="https://images2.imgbox.com/79/bf/zHIu98hi_o.png" width="1024"></p> 
<p>  HashMap底层实际是一个一维数组，数组的元素是一个单向链表</p> 
<h3>（三）底层实现原理</h3> 
<h4>1、概述实现过程   </h4> 
<p>   （1）采用hash算法将要存储的对象存储到数组的对应位置，</p> 
<p>    （2）当元素较多时，容易出现hash冲突，即多个元素需存储到同一个数组下标位置</p> 
<p>    （3）解决：单向链表，多个元素以链表形式存储在同一个数组下标下</p> 
<p>   （4）当单向链表节点数大于8时，链表转成红黑树------几率极小，因为会数组扩容</p> 
<h4>2、hash算法</h4> 
<p> （1）数组的初始容量值为什么是16？</p> 
<ul><li>数组初始值是16，则数组下标是0-15</li><li>15的二进制数-----1111</li><li>任何多位二进制数和1111进行与操作的值范围均在0-15（多位二进制位数&gt;=4）</li></ul> 
<p>（2）hash算法如何将数据放入map中</p> 
<ul><li> 每个键值对的key，都有一个hashCode------多位的二进制数（&gt;4）</li><li>将key的hashCode和数组容量-1的二进制数进行与操作------得到key的hash值，即数组的下标</li></ul> 
<p><span style="color:#7b7f82;"> key hashCode      1010111010011101</span></p> 
<p><span style="color:#7b7f82;"> 数组容量-1  15                             1111</span></p> 
<p><span style="color:#7b7f82;"> 与操作                                          1101   （相当于取hashCode后四位）</span></p> 
<p>1101------&gt;13，则该键值对存放在数组的下标13位置</p> 
<h4>3、hash碰撞</h4> 
<p> （1）当key通过hash算法得到的哈希值相同时------hash碰撞（hash冲突）</p> 
<p> （2）解决：链表</p> 
<ul><li> 将同哈希值的key及value以链表形式存储在同下标下</li><li>新来的相同哈希值的键值对用尾插法存到同下标下的链表中</li></ul> 
<p>        1.7及之前----头插法------死锁问题（多线程）</p> 
<p>         1.8及之后----尾插法</p> 
<ul><li>当链表的节点数&gt;8------链表转换成红黑树（平衡二叉树）</li><li>由于数组会不断扩容，链表转换成红黑树的概率为千万分之一</li></ul> 
<h4>4、数组扩容</h4> 
<ul><li>   数组扩容因子是0.75， 当数组存储量超过0.75时，数组就会2倍扩容</li></ul> 
<p>            初始值：16     超过16*0.75=12  &gt;12扩容2倍---&gt;32</p> 
<ul><li>为什么2倍扩容------因为这样才能得到全1二进制数进行与操作</li><li>数组扩容：将小数组复制到大容量数组，会2次哈希</li></ul> 
<h4>5、数组元素迁移---rehash </h4> 
<p>（1）JDK7</p> 
<p>  在准备好新的数组后，map会遍历数组的每个链表，然后遍历链表中的每个Entity，</p> 
<p>  重新计算其hash值（也有可能不计算），找到新数组中的对应位置，</p> 
<p>  以<strong>头插法</strong>插入新的链表。</p> 
<p>【注】</p> 
<ul><li>是否要重新计算hash值的条件这里不深入讨论，读者可自行查阅源码。</li><li>因为是头插法，因此新旧链表的元素位置会发生转置现象。</li><li>元素迁移的过程中在多线程情境下有可能会触发死循环（无限进行链表反转）。</li></ul> 
<p>（2）JDK8</p> 
<p>由于数组的容量是以2的幂次方扩容的，</p> 
<p>那么一个Entity在扩容时，新的位置要么在<strong>原位置</strong>，要么在<strong>原长度+原位置</strong>的位置。</p> 
<p>原因如下图：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/2c/a1/ou4AwNHM_o.png" width="727"></p> 
<p>数组长度变为原来的2倍，表现在二进制上就是<strong>多了一个高位参与数组下标确定</strong>。</p> 
<p>一个元素通过hash转换坐标的方法计算后，恰好出现一个现象：</p> 
<p><span style="color:#fe2c24;">最高位是0则坐标不变</span>，</p> 
<p>最<span style="color:#fe2c24;">高位是1则</span>坐标变为“10000+原坐标”，即“<span style="color:#fe2c24;">原长度+原坐标</span>”。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d8/65/T7Zbpz24_o.png" width="520"></p> 
<p>  元素迁移部分来源：<a href="https://zhuanlan.zhihu.com/p/114363420" rel="nofollow" title="HashMap的扩容机制 - 知乎">HashMap的扩容机制 - 知乎</a></p> 
<h2>三、HashTable----properties</h2> 
<p>1、HashTable的底层是哈希表</p> 
<p>2、hashtable的key和value都不可以为null（hashmap可以）</p> 
<p>3、HashTable是线程安全的，所有方法都带有synchronized关键字，效率较低</p> 
<p>4、HashTable的初始化容量是11</p> 
<p>     集合扩容是：原容量*2+1</p> 
<p>5、properties----继承HashTable，线程安全</p> 
<p>  （1）properties的存取</p> 
<pre><code>Properties p=new Properties ();
//存 setProperty(key,value)
p.setProperty("username","root");
p.setProperty("password","123");

//取 getProperty(key)
String uname=p.getProperty("username");
String pwd=p.getProperty("password");</code></pre> 
<p>   (2)常见使用：配置文件 xx.properties</p> 
<p>                          反射机制 灵活存取不同对象class信息</p> 
<h2>四、SoretMap----TreeMap</h2> 
<p>            TreeMap底层是二叉树，可排序Map-----TreeSet（详见TreeSet）</p> 
<p></p> 
<p>附：老杜总结图</p> 
<p><img alt="" height="619" src="https://images2.imgbox.com/1a/20/08lOYazP_o.png" width="1178"></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/24cbb760a9bf819c998967ff47ee93c9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">电子工程师入门基础模电知识</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c3018c408d83a479993059cd587bc374/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">服务器-测试题(快来测验一下基础知识啦)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>