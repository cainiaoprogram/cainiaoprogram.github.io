<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深度学习核心技术与实践之计算机视觉篇 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深度学习核心技术与实践之计算机视觉篇" />
<meta property="og:description" content="非书中全部内容，只是写了些自认为有收获的部分
计算机视觉背景 （1）视觉皮层的神经元是一列一列组织起来的，每一列神经元只喜欢某一种特定的形状或者某些简单的线条组合，而不是鱼、老鼠、鲜花
（2）视觉的前期，并不是对鱼或老鼠进行整体识别，而是对简单的形状结构进行处理，这种简单的形状结构就是边缘
（3）视觉是分层的
（4）简单的3D摄像机就是用两个镜头，然后把图片叠加实现的。同样，对干语音问题，自然界的语音是重叠的，解决办法是用两只耳朵，在技术上就可以采用多个麦克风
（5）对人来说，很多遮挡并不是问题，比如看到部分虎纹就知道是老虎，这说明对视觉来说特征可能是最重要的。尺度不变特征变换算法认为只需要看到部分即可进行识别。而且就算整体上有些形变，具体特征也会保持不变
图像分类模型 LeNet-5 （1）对输入像素归一化：白色背景取值-0.1，黑色前景取值1.175，这样使得在MNIST数据集上像素点取值均值近似为0，方差近似为1
（2）每个C3层的特征图只与部分S2层的特征图进行连接。这样做有两个原因:
1.部分不完全的连接关系能将连接数控制在一个比较合理的范围内
2.更重要的是，它强制地打破了网络的对称性，不同的特征图由干输入不同而能够表达出不同的特征
（3）输出层由每个类别对应一个欧几里得RBF单元构成，每个RBF单元计算的是输入向量和参数向量w之间的欧式距离，输入向量与参数向量之间的距离越远，RBF单元的输出越大
AlexNet （1）AlexNet模型中间层分为两路，明确显示了两块GPU之间的职责划分——一块GPU运行图中顶部模型部分，而另一块GPU则运行图中底部模型部分。GPU之间仅在某些层互相通信。
（2）创新之处：
1.ReLU
2.多GPU训练：第三层卷积需要以第二层产生的所有特征图作为输入，而第四层卷积则只需要以第三层的特征图中处在同一块GPU的部分作为输入。选择层间特征图的连接关系是一个交叉验证问题，但这使得我们能够将通信量精准地调整到一个可接受的范围内
3.局部相应归一化：
4.重叠池化：有重叠的池化层相比传统池化层出现过拟合现象的问题也略有缓解
5.整体网络结构：第二、四、五个卷积层只连接到前一个卷积层中也位于同一块GPU上的那些特征图，第三个卷积层则连接着第二个卷积层中的所有特征图，全连接层中的神经元连接前一层所有的神经元。在第一和第二个卷积层后面各接了一个局部响应归一化层。在局部响应归一化层和第五个卷积层之后接的最大池化层采用了前文介绍的重叠池化方式。所有卷积层和全连接层都采用ReLU作为非线性激活函数
6.降低过拟合：
运用两种数据增强：裁剪和水平翻转、改变训练数据中RGB通道的强度(对整个ImageNet训练数据的RGB像素值做主成分分析)。后一种变换能够使网络近似地学习到自然物体识别中一个很重要的属性，即物体识别应该对光照强度和颜色保持不变性
使用Dropout。测试时将所有神经元输出x0.5来近似
VGGNet （1）VGGNet采用的卷积核感受野很小: 3x3；在其中一组配置中，VGGNet甚至采用了1x1的卷积核，这时卷积退化成为对输入的线性变换 (后面跟一个非线性单元)
（2）小卷积核代替大卷积核的好处：
1.用整合了的三个非线性激活层替代单一非线性激活层，增加了判别能力。
2.减少了网络参数。假设三个3x3的卷积层的输入输出都是C个通道，那么小结构中参数个数为3x(3C)² =27C²。类似地，一个7x7的卷积层则需要 7²C² =49C²个参数，多出了81%。也可以看作对7x7的卷积网络施加了某种正则化，使其能够分解成三个3x3的卷积层
3.使用尺寸为1x1的卷积层能够在不影响感受野的情况下，增加网络非线性判别能力。尽管在VGGNet中 1x1卷积实质上是在相同维度空间(输入输出通道数一致) 上的线性投影，但激活函数还是引入了额外的非线性能力
GoogLeNet （1）在 AlexNet 和 VGGNet 中全连接层占据 90%的参数量，而且容易引起过拟合；而GoogLeNet用全局平均池化层取代全连接层
（2）在传统的CNN中卷积层实质上是一种广义的线性模型，其表达和抽象能力不足；相比普通的卷积网络，MLP网络能够更好地拟合局部特征，也就是增强了输入局部的表达能力
（3）两个卷积层级联，如果统一增加卷积核数量，那么计算量的增大将与卷积核数的增加成平方关系
（4）如果用一个大型、稀疏的深度神经网络表示某数据集的概率分布，那么最优的网络拓扑可以通过逐层分析与之前神经元的统计相关，并将高相关性的神经元进行聚类得到。
Inception （1）Inception模块将稀疏矩阵聚成相对稠密的子矩阵能带来客观的性能提升
（2）Inception结构的主要思想是用便捷可得的密集原件去近以卷积视觉网络的最优局部稀疏结构。接下来需要做的就是找到一种最优的局部结构，重复这结构把它们拼接在一起组成网络
（3）Arora等人提出一种层与层的结构，在结构的最后一层进行相关性统计，将相关性高的单元聚集到一起。这些簇构成下一层的单元，与上一层的单元连接
（4）假设前面层的每个单元对应于输入图像的某些区域，这些单元被滤波器进行分组。低层(接近输入层)的单元集中在某些局部区域，这意味着最终会得到在单个区域的大量群，它们能在下一层通过 1x1卷积覆盖；然而，也可以通过一个簇覆盖更大的空间来减少的数量。为了避免patch-alignment问题，将滤波器大小限制在1x1、3x3 和 5x5(主要是为了方便，非必要)。在池化层添加一个备用的池化路径可以提高效率
（5）得益于Embedding技术的成功，即使低维度的Embedding也能包含相对大的图像区域中的丰富信息。然而，Embedding将信息表达为调密压缩的模式，处理起来更困难。我们期望的是在大部分地方保持稀疏，只在需要放大的位置产生稠密信号。于是，1x1卷积放置在计算昂贵的3x3和5x5卷积层前，用于减少计算量。1x1卷积不仅用来降维，还用来修正线性特征
后续版本改进 (1) Inception-v2在之前的版本中主要加入了Batch Normalization；另外也借鉴了VGGNet的思想，用两个3x3的卷积代替了5x5的卷积，不仅降低了训练参数，而且提升了速度。
(2) Inception-v3在v2的基础上进一步分解大的卷积，比如把nxn的卷积拆分成两个一维的卷积1xn，nx1。例如7x7的卷积可以被拆分为1x7和7x1两个卷积。
(3) Inception-v4借鉴了ResNet可以构建更深层网络的相关思想，设计了一个更深、更优化的模型。
ResNet （1）放弃直接拟合某个函数y=H(x)的传统思路，转而拟合残差F(x) =H(x) - x，原始映射就变成H(x)=F(x)&#43;x" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/80da8c3d400a39e0a32851fa575663ad/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-01T10:21:32+08:00" />
<meta property="article:modified_time" content="2024-01-01T10:21:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深度学习核心技术与实践之计算机视觉篇</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>非书中全部内容，只是写了些自认为有收获的部分</p> 
<h2>计算机视觉背景</h2> 
<p>（1）视觉皮层的神经元是一列一列组织起来的，每一列神经元只喜欢某一种特定的形状或者某些简单的线条组合，而不是鱼、老鼠、鲜花</p> 
<p>（2）视觉的前期，并不是对鱼或老鼠进行整体识别，而是对简单的形状结构进行处理，这种简单的形状结构就是边缘</p> 
<p>（3）视觉是分层的</p> 
<p><img alt="" height="314" src="https://images2.imgbox.com/40/db/NjxMWdYv_o.png" width="946"></p> 
<p>（4）简单的3D摄像机就是用两个镜头，然后把图片叠加实现的。同样，对干语音问题，自然界的语音是重叠的，解决办法是用两只耳朵，在技术上就可以采用多个麦克风</p> 
<p>（5）对人来说，很多遮挡并不是问题，比如看到部分虎纹就知道是老虎，这说明对视觉来说特征可能是最重要的。尺度不变特征变换算法认为只需要看到部分即可进行识别。而且就算整体上有些形变，具体特征也会保持不变</p> 
<h2>图像分类模型</h2> 
<h3>LeNet-5</h3> 
<p><img alt="" height="397" src="https://images2.imgbox.com/f3/a3/BXwar1r3_o.png" width="1116"></p> 
<p>（1）对输入像素归一化：白色背景取值-0.1，黑色前景取值1.175，这样使得在MNIST数据集上像素点取值均值近似为0，方差近似为1</p> 
<p>（2）每个C3层的特征图只与部分S2层的特征图进行连接。这样做有两个原因:<br>         1.部分不完全的连接关系能将连接数控制在一个比较合理的范围内<br>         2.更重要的是，它强制地打破了网络的对称性，不同的特征图由干输入不同而能够表达出不同的特征</p> 
<p><img alt="" height="241" src="https://images2.imgbox.com/a0/54/faa6OCl3_o.png" width="564"></p> 
<p>（3）输出层由每个类别对应一个欧几里得RBF单元构成，每个RBF单元计算的是输入向量和参数向量w之间的欧式距离，输入向量与参数向量之间的距离越远，RBF单元的输出越大</p> 
<h3>AlexNet</h3> 
<p><img alt="" height="552" src="https://images2.imgbox.com/5f/0c/QAk0mIA1_o.png" width="1046"></p> 
<p>（1）AlexNet模型中间层分为两路，明确显示了两块GPU之间的职责划分——一块GPU运行图中顶部模型部分，而另一块GPU则运行图中底部模型部分。GPU之间仅在某些层互相通信。</p> 
<p>（2）创新之处：</p> 
<p>        1.ReLU</p> 
<p>        2.多GPU训练：第三层卷积需要以第二层产生的所有特征图作为输入，而第四层卷积则只需要以第三层的特征图中处在同一块GPU的部分作为输入。选择层间特征图的连接关系是一个交叉验证问题，但这使得我们能够将通信量精准地调整到一个可接受的范围内</p> 
<p>        3.局部相应归一化：</p> 
<p><img alt="" height="119" src="https://images2.imgbox.com/24/76/7L2kB1gT_o.png" width="701"></p> 
<p>        4.重叠池化：有重叠的池化层相比传统池化层出现过拟合现象的问题也略有缓解</p> 
<p>        5.整体网络结构：第二、四、五个卷积层只连接到前一个卷积层中也位于同一块GPU上的那些特征图，第三个卷积层则连接着第二个卷积层中的所有特征图，全连接层中的神经元连接前一层所有的神经元。在第一和第二个卷积层后面各接了一个局部响应归一化层。在局部响应归一化层和第五个卷积层之后接的最大池化层采用了前文介绍的重叠池化方式。所有卷积层和全连接层都采用ReLU作为非线性激活函数</p> 
<p>        6.降低过拟合：</p> 
<p>                运用两种数据增强：裁剪和水平翻转、改变训练数据中RGB通道的强度(对整个ImageNet训练数据的RGB像素值做主成分分析)。后一种变换能够使网络近似地学习到自然物体识别中一个很重要的属性，即物体识别应该对光照强度和颜色保持不变性</p> 
<p>                使用Dropout。测试时将所有神经元输出x0.5来近似</p> 
<h3>VGGNet</h3> 
<p><img alt="" height="708" src="https://images2.imgbox.com/a3/e8/Lo8dsm4u_o.png" width="1200"></p> 
<p><img alt="" height="820" src="https://images2.imgbox.com/41/b0/f9D1sFt3_o.png" width="1200"></p> 
<p>（1）VGGNet采用的卷积核感受野很小: 3x3；在其中一组配置中，VGGNet甚至采用了1x1的卷积核，这时卷积退化成为对输入的线性变换 (后面跟一个非线性单元)</p> 
<p>（2）小卷积核代替大卷积核的好处：</p> 
<p>        1.用整合了的三个非线性激活层替代单一非线性激活层，增加了判别能力。</p> 
<p>        2.减少了网络参数。假设三个3x3的卷积层的输入输出都是C个通道，那么小结构中参数个数为3x(3C)² =27C²。类似地，一个7x7的卷积层则需要 7²C² =49C²个参数，多出了81%。也可以看作对7x7的卷积网络施加了某种正则化，使其能够分解成三个3x3的卷积层</p> 
<p>        3.使用尺寸为1x1的卷积层能够在不影响感受野的情况下，增加网络非线性判别能力。尽管在VGGNet中 1x1卷积实质上是在相同维度空间(输入输出通道数一致) 上的线性投影，但激活函数还是引入了额外的非线性能力</p> 
<h3>GoogLeNet</h3> 
<p><img alt="" height="1064" src="https://images2.imgbox.com/7d/f6/OhmutL88_o.png" width="897"></p> 
<p>（1）在 AlexNet 和 VGGNet 中全连接层占据 90%的参数量，而且容易引起过拟合；而GoogLeNet用全局平均池化层取代全连接层</p> 
<p>（2）在传统的CNN中卷积层实质上是一种广义的线性模型，其表达和抽象能力不足；相比普通的卷积网络，MLP网络能够更好地拟合局部特征，也就是增强了输入局部的表达能力</p> 
<p>（3）两个卷积层级联，如果统一增加卷积核数量，那么计算量的增大将与卷积核数的增加成平方关系</p> 
<p>（4）如果用一个大型、稀疏的深度神经网络表示某数据集的概率分布，那么最优的网络拓扑可以通过逐层分析与之前神经元的统计相关，并将高相关性的神经元进行聚类得到。</p> 
<h4>Inception</h4> 
<p>（1）Inception模块将稀疏矩阵聚成相对稠密的子矩阵能带来客观的性能提升</p> 
<p>（2）Inception结构的主要思想是用便捷可得的密集原件去近以卷积视觉网络的最优局部稀疏结构。接下来需要做的就是找到一种最优的局部结构，重复这结构把它们拼接在一起组成网络</p> 
<p>（3）Arora等人提出一种层与层的结构，在结构的最后一层进行相关性统计，将相关性高的单元聚集到一起。这些簇构成下一层的单元，与上一层的单元连接</p> 
<p>（4）假设前面层的每个单元对应于输入图像的某些区域，这些单元被滤波器进行分组。低层(接近输入层)的单元集中在某些局部区域，这意味着最终会得到在单个区域的大量群，它们能在下一层通过 1x1卷积覆盖；然而，也可以通过一个簇覆盖更大的空间来减少的数量。为了避免patch-alignment问题，将滤波器大小限制在1x1、3x3 和 5x5(主要是为了方便，非必要)。在池化层添加一个备用的池化路径可以提高效率</p> 
<p>（5）得益于Embedding技术的成功，即使低维度的Embedding也能包含相对大的图像区域中的丰富信息。然而，Embedding将信息表达为调密压缩的模式，处理起来更困难。我们期望的是在大部分地方保持稀疏，只在需要放大的位置产生稠密信号。于是，1x1卷积放置在计算昂贵的3x3和5x5卷积层前，用于减少计算量。1x1卷积不仅用来降维，还用来修正线性特征</p> 
<h4>后续版本改进</h4> 
<p>(1) Inception-v2在之前的版本中主要加入了Batch Normalization；另外也借鉴了VGGNet的思想，用两个3x3的卷积代替了5x5的卷积，不仅降低了训练参数，而且提升了速度。<br> (2) Inception-v3在v2的基础上进一步分解大的卷积，比如把nxn的卷积拆分成两个一维的卷积1xn，nx1。例如7x7的卷积可以被拆分为1x7和7x1两个卷积。<br> (3) Inception-v4借鉴了ResNet可以构建更深层网络的相关思想，设计了一个更深、更优化的模型。</p> 
<h3>ResNet</h3> 
<p><img alt="" height="446" src="https://images2.imgbox.com/29/02/Dme8K60A_o.png" width="525"></p> 
<p>（1）放弃直接拟合某个函数y=H(x)的传统思路，转而拟合残差F(x) =H(x) - x，原始映射就变成H(x)=F(x)+x</p> 
<p>（2）在实际情况中，单位映射不太可能是最优的情况，但是改写为残差能帮助预处理整个问题。当一个最优的函数接近于单位映射而不是零时，找到一个参照单位映射的扰动比学习一个新的函数要更容易</p> 
<p>（3）如果特征图数量减半，那么卷积核数量就翻倍，保持每一层的时间复杂度</p> 
<p>（4）ResNet直接将卷积层步长设为2来实现降采样</p> 
<p>（5）当维度增加时，考虑两种选择：1.仍然使用恒等快捷连接，增加的维度直接补0，这种方式不会引入新的参数；2.将维度较少的低层输出映射到与高层相同的维度上(通过1x1卷积实现)。无论怎么选择，当快捷连接跨过两层特征图时，步长设为2</p> 
<h3>DenseNet</h3> 
<p>（1）DenseNet具有更多的跨层快捷连接，从输入层开始，每层都作为后面各层的输入</p> 
<p><img alt="" height="71" src="https://images2.imgbox.com/c0/b4/8syQgjxg_o.png" width="396"></p> 
<p><img alt="" height="67" src="https://images2.imgbox.com/5b/64/iHm7OLQq_o.png" width="568"></p> 
<p>（2）最终的DenseNet由Dense Block以及转换层 (Transition Layer)组成，转换层一般由一个Batch Normalizatin层、卷积核大小为1x1的卷积层和池化层组成，其中1x1的卷积主要用于瘦身，即降低通道数量</p> 
<h2>目标检测</h2> 
<h3>传统目标检测</h3> 
<h4>滑动窗口</h4> 
<p>(1) 利用不同尺寸的滑动窗口框住图中的某一部分作为候选区域<br> (2)提取与候选区域相关的视觉特征。比如人脸检测常用的Harr特征；行人检测和普通目标检测常用的HOG特征等<br> (3) 利用分类器进行识别，比如常用的SVM模型</p> 
<h4>DPM</h4> 
<p>（1）多尺度形变部件模型</p> 
<p>（2）把物体看成了多个组成的部件(比如人脸的鼻子、嘴巴等)，用部件间的关系来描述物体，这个特性非常符合自然界很多物体的非刚体特征。DPM可以看作HOG+SVM的扩展，很好地继承了两者的优点</p> 
<h3>相关研究</h3> 
<h4>选择性搜索</h4> 
<p>（1）第一步：区域提名，也就是找出可能的感兴趣区域(ROI)。尽量切碎到小的连通域(比如小的笔画之类的)然后再根据相邻块的一些形态学特征进行合并</p> 
<p>（2）区域提名的方法：</p> 
<p>        1.滑动窗口：穷举法，利用不同的尺度和长宽比把所有可能的大大小小的块都穷举出来</p> 
<p>        2.规则块：在穷举法的基础上进行一些剪枝，只选用固定的大小和长宽比</p> 
<p>        3.选择性搜索：自底向上合并相邻的重叠区域，从而减少冗余。选择性搜索采用多样性策略来增加候选区域以保证召回率，比如颜色空间考虑RGB、灰度、HSV及其变种等，计算相似度时既考虑颜色相似度，又考虑纹理大小、重叠情况等</p> 
<h4>OverFeat</h4> 
<p>（1）核心思想：</p> 
<p>        1.多尺度的滑动窗口；</p> 
<p>        2.统一用CNN来做分类和预测边框位置，模型与AlexNe类似，其中1~5层为特征抽取层，即将图片转换为固定维度的特征向量，6~9层为分类层(分类任务专用)，不同的任务 (分类、定位、检测)公用特征抽取层(1 ~5层)，只替6 ~9层；</p> 
<p>        3.因为用了滑动窗口，同一个目标对象会有多个位置，也就是多个视角:因为用了多尺度，同一个目标对象又会有多个大小不一的块。这些不同位置和不同大小块上的分类置信度会进行累加</p> 
<p>（2）OverFeat的另一个重要贡献是它的滑动窗口分类回归非常高效</p> 
<h3>基于区域提名的方法</h3> 
<h4>RCNN</h4> 
<p>（1）主要步骤：</p> 
<p>        1.区域提名: 通过选择性搜索从原始图片中提取2000个左右的区域候选框。<br>         2.区域大小归一化: 把所有候选框缩放成固定大小 (原文采用227x227) 。<br>         3.特征提取: 通过CNN网络提取特征。<br>         4.分类与回归:在特征层的基础上添加两全连接层，再用SVM分类来进行识别，用线性回归来微调边框位置与大小，其中每个类别单独训练一个边框回归器</p> 
<p>（2）缺点：</p> 
<p>        1.重复计算:R-NN虽然不再穷举，但依然有2000个左右的侯选框，这些候选框都需要进行CNN操作，计算量仍然很大，其中有不少其实是重复计算。<br>         2.SVM模型:分类和回归使用SM模型，而且还是线性模型，无法将梯度后向传播给卷积特征提取层，在标注数据不缺的时候显然不是最好的选择。<br>         3.训练测试分为多步: 区域提名、特征提取、分类、回归都是断开的训练的过程，中间数据还需要单独保存。<br>         4.训练的空间和时间代价很高: 卷积出来的特征需要先存在硬盘上，这些特征需要几百GB的存储空。<br>         5.慢: 前面的缺点最终导致R-CNN出奇的慢，在GPU上处理一张图片需要13秒，在CPU上则需要53秒</p> 
<h4>SPP-net</h4> 
<p>（1）主要思想：去掉了原始图片上的crop/warp等操作，换成了卷积特征上的空间金字塔池化层</p> 
<p>（2）之所以引入SPP层，主要原因是CNN的全连接层要求输入图片的大小一致，而实际中的输入图片往往大小不一，如果直接缩放到同一尺寸，很可能有的物体会充满整张图片，而有的物体只占到图片的一角。传统的解决方案是进行不同位置的裁剪，但是这些裁剪技术都可能会导致出现一些问题，比如图11-8中的crop会导致物体不全，warp导致物体被拉后形变严重。SPP对整图提取固定维度的特征，再把图片均分成4份，每份提取相同维度的特征，再把图片均分为16份，依此类准。可以看出，无论图片大小如何，提取出来的数据维度是一致的，这样就可以统一送至全连接层了。SPP思想在后来的R-CNN系列模型中也被广泛用到</p> 
<p><img alt="" height="331" src="https://images2.imgbox.com/eb/85/yniZeIMR_o.png" width="672"></p> 
<p>（3）优点：</p> 
<p>        1.不论输入图片大小是多少，SPP都能抽取到固定长度的特征<br>         2.SPP使用了多级的空间尺度特征，鲁棒性更好<br>         3.由于输入维度可变，SPP能够在不同的维度抽取特征</p> 
<p>（4）主要步骤：</p> 
<p>        1.区域提名: 用选择性搜索从原图中生成2000个左右的候选框。<br>         2.区域大小缩放:SPP-net不再做区域大小归一化，而是缩放到min (w,h) =s，即统一图像长宽尺寸中最边长度，S选自480，576，688，864，1200中的一个，选择的标准是使得缩放后的目标物体候选框大小与224x224最接近。<br>         3.特征提取: 利用SPP-net网络结构提取特征。<br>         4.分类与回归: 类似于R-CNN，利用SVM基于上面的特征训练分类器模型，用边框回归来微调候选框的位置。</p> 
<p><img alt="" height="614" src="https://images2.imgbox.com/fb/70/teambGLJ_o.png" width="804"></p> 
<h4>Fast R-CNN</h4> 
<p>（1）主要思想：</p> 
<p>        1.使用一个简化的SPP层——Rol池化层，操作与SPP类似。<br>         2.训练和测试时不再分多步:不再需要额外的硬盘来存储中间层的特征，梯度能够通过RoI池化层直接传播:此外，分类和回归用Mulit-task的方式一起进行<br>         3.SVD: 使用SVD分解全连接层的参数矩阵，压缩为两个规模小很多的全连接层</p> 
<p>（2）主要步骤：</p> 
<p>        1.特征提取: 以整张图片为输入，利用CNN得到图片的特征层。<br>         2.区域提名: 通过选择性搜索等方法从原始图片中提取区域候选框，并把这些候选框一 一投影到最后的特征层<br>         3.区域归一化:针对特征层上的每个区域候选进行Rol池化操作，得到固定大小的特征表示。<br>         4.分类与回归: 通过两个全连接层，分别用Softmax多分类进行目标识别，用回归模型进行边框位置与大小微调</p> 
<p><img alt="" height="326" src="https://images2.imgbox.com/23/1c/AcqEprpx_o.png" width="718"></p> 
<h4>Faster R-CNN</h4> 
<p>（1）利用RPN(Region Proposal Network) 网络来计算候选框。RPN以一张任意大小的图片为输入，输出一批矩形区域提名，每个区域对应一个目标分数和位置信息</p> 
<p><img alt="" height="504" src="https://images2.imgbox.com/7e/4b/ADiZARRe_o.png" width="754"></p> 
<p>（2）主要步骤：</p> 
<p>        1.特征提取: 同Fast R-CNN，以整张图片为输入，利用CNN得到图片的特征层。<br>         2.区域提名: 在最终的卷积特征层上为每个点利用k个不同的矩形框(Anchor Box) 进行提名，k一般取9。</p> 
<blockquote> 
 <p>"每个点"指的是特征图上的一个激活单元（即一个像素）。Faster R-CNN通过在特征图上滑动一个小的卷积核（通常大小为3x3）来对每个点进行提名。</p> 
</blockquote> 
<p><br>         3.区域判定和回归:对每个矩形框对应的区域进行object/non-object二分类，并用K个回归模型各自对应不同的矩形)微调候选位置与大小。<br>         4.分类与回归: 对区域提名网络给出的区域结果进行筛选，进行目标分类和边框回归。</p> 
<p>（3）总之，Faster R-CNN抛弃了选择性搜索，引入了RPN网络，使得区域提名、分类、回归一起共用卷积特征，从而得到进一步的加速。但是，Faster R-CNN仍然分成两步: 对两万个矩形框先判断是否是目标 (目标判定)，然后再进行目标识别</p> 
<h4>R-FCN</h4> 
<p>（1）前面的目标检测方法都可以细分为两个子网络:共享的全卷积网络和不共享计算的与ROI相关的子网络(比如全连接网络)</p> 
<p>（2）R-FCN[14][15]将最后的全连接层之类的换成了一个位置敏感的卷积网络，从而让所有计算都可以共享。具体来说，先把每个提名区域划分为k x k个网格，每个网格都有对应的编码，但预测时会有C+1个输出，C表示类别数量，+1是因为有背景类别</p> 
<p><img alt="" height="384" src="https://images2.imgbox.com/24/b5/TdljI13o_o.png" width="811"></p> 
<p><img alt="" height="429" src="https://images2.imgbox.com/5c/ed/PMJ43DLJ_o.png" width="749"></p> 
<p>（3）不同位置都存在一个九宫格，但是池化时只有一个起作用，比如bottom-right层只有右下角的小块起作用。那么题来了，这一层其他的8个框有什么作用呢? 答案是它们可以作为其他ROI(偏左或偏上一些的ROI)的右下角</p> 
<p>（4）步骤：</p> 
<p>        1.区域提名: 使用RPN (Region Proposal Network，区域提名网络)，RPN本身是全卷积网络结构的<br>         2.分类与回归: 利用和RPN共享的特征进行分类。当进行bbox回归时，则将C设置为4</p> 
<blockquote> 
 <p>"bbox"是"bounding box"的缩写，中文通常翻译为“边界框”。边界框是一种用于标记图像中目标物体位置的矩形框。它是由四个坐标点定义的，分别对应于矩形框的左上角(x1, y1)和右下角(x2, y2)的坐标。</p> 
</blockquote> 
<h3>无需区域提名的方法</h3> 
<h4>YOLO</h4> 
<p>（1）把目标判定和目标识别合二为一</p> 
<p>（2）处理步骤：</p> 
<p>        1.把输入图片缩放到448x448大小<br>         2.运行卷积网络。<br>         3.对模型置信度卡阈值，得到目标位置与类别</p> 
<p>（3）将448x448大小的图片切成SxS的网格，目标中心点所在的格子负责该目标的相关检测，每个网格预测 B个边框及其置信度，以及种类别的概率。在YOLO中S=7，B=2，C取决于数据集中物体类别数量。对VOC数据集来说，YOLO就是把图片统一缩放到448x448，然后每张图平均划分为7x7=49个小格子，每个格子预测2个矩形框及其置信度，以及20种类别的概率。较大的物体可能会由多个网格单元提名，YOLO采用了NMS方法来过滤结果。NMS将mAP提升了2~3个百分点。</p> 
<p><img alt="" height="584" src="https://images2.imgbox.com/fa/18/jTrddwuQ_o.png" width="841"></p> 
<h4>SSD</h4> 
<p>（1）冲着YOLO的缺点来的</p> 
<p>（2）在每个格子上有一系列固定大小的Box (有点类似于前面提到的矩形框)，这些在SSD中称为Default Box，用来框定目标物体的位置，在训练时Ground Truth会赋给某个固定的Box，比如图 (b) 中的深色框和图 (c) 中的深色框</p> 
<p><img alt="" height="322" src="https://images2.imgbox.com/4e/ae/5OSgnPKr_o.png" width="717"></p> 
<p>（3）SSD网络分为两部分，前面的网络是用于图像分类的标准网络 (去掉了与分类相关的层)；后面的网络是用于检测的多尺度特征映射层，从而实现检测不同大小的目标。SSD和YOLO的网络结构对比如图11-18所示。</p> 
<p><img alt="" height="575" src="https://images2.imgbox.com/2a/b5/iYdc4eXt_o.png" width="1007"></p> 
<h2>语义分割</h2> 
<p>（1）按照语义对每个像素点进行分类</p> 
<p>（2）基本流程：</p> 
<p>        1.用全卷积神经网络来获取基准的像素分类<br>         2.通过CRF/MRF来使用全局信息使得像素分类的准确率进一步提升</p> 
<blockquote> 
 <p>CRF模型由美国学者John Lafferty最早提出，用于改进传统的NLP标注任务。它的主要作用是在给定一组输入随机变量（例如文本中的单词）条件下，预测另一组输出随机变量（例如单词的词性标签或实体类别）的条件概率分布。<br> CRF模型的特点是假设输出随机变量（即标注序列）构成一个马尔科夫随机场，这意味着在序列中，每一个标签仅依赖于它之前的标签，而与更远的标签无关。这种假设使得模型在处理长序列时计算效率较高。<br> CRF模型的另一个特点是它是判别式模型，这意味着它直接学习输出序列，而不是通过学习输入和输出之间的映射关系。这使得CRF在处理标注问题时更为直接和有效。</p> 
</blockquote> 
<p>（3）语义分割面临着语义和位置的内在矛盾：全局信息解答是什么，局部信息解答在哪里</p> 
<h3>全卷积网络</h3> 
<h4>FCN</h4> 
<p>（1）定义了一个”skip”结构来合并深层的、粗粒度的语义信息和浅层的、细粒度的位置信息。FCN的成功是建立在深度网络在图像分类和迁移学习基础上的</p> 
<h5>与用于识别的深度学习网络的主要区别</h5> 
<p>1.如何把图片分类中粗粒度的特征图还原到像素级别</p> 
<p>（1）直接把最后的全连接层用卷积层代替，全卷积网络的输出天然就很适合解决这种稠密的问题</p> 
<p>（2）由于网络是全卷积网络，所以它可以使用任意尺寸的输入图片</p> 
<p>2.反卷积层做上采样</p> 
<p>（1）将粗粒度输出变为稠密输出</p> 
<p>（2）上采样f倍，可以看作卷积操作的步长是1/f</p> 
<p>（3）一组反卷积和激活函数可以构造非线性的上采样</p> 
<blockquote> 
 <p>在FCN（全卷积网络）中，上采样操作通常是通过插值方法来实现的，而不是通过反卷积。反卷积操作（也称为转置卷积）在某些网络结构中用于上采样，但不是FCN中上采样的标准操作。<br> 具体来说，FCN在上采样阶段通常采用最近邻插值（Nearest neighbor interpolation）或双线性插值（Bilinear interpolation）方法。这些插值方法通过对原始特征图的像素进行放大，从而恢复到输入图像的原始尺寸。最近邻插值是最简单的插值方法，它通过查找最近的像素值来填充新产生的像素点。双线性插值则更为复杂，它通过加权平均周围四个像素的值来估计新像素的值，从而实现更加平滑的图像放大。</p> 
</blockquote> 
<p>3.切分网络结构</p> 
<p>（1）FCN借用了ILSVRC分类网络的参数，然后在这个网络后面增加了用于相密计算的上采样和像素级损失函数，通过微调的方式来训练新增网络结构的参数，如图12-3所示，这个网络结构的一大亮点在于<strong>浅层信息和深层信息的合并</strong>，也就解决了本节开始提出的如何把全局的语义信息与局部的分割信息相融合的问题，图12-3中的FCN-32s直接在最后一个卷积层的特征图后做了上采样，这一步采用的是不可学习的<strong>双线性插值上采样</strong>，FCN-16s和FCN-8s分别对最后一个卷积层的特征图做了2倍和4倍的上采样，这里的上采样的参教初始化为双线性插值，在训练过程中参数可学，实验说明，FCN-8s的效果最好。由于这个网络的参数大多了，而用于分割的训练样本数又较少，所以作者使用其他的分类问题来训练好初始的网络，然后再微调后面的上采样过程。<br> （2）FCN的每个<strong>解码器</strong>学习上采样的参数，上采样得到特征图后，与<strong>对应的编码特征图合并</strong>，作为输入传送给下一个解码器。编码器的参数数量巨大(134M)，但是解码器的参数数量非常少(0.5M) 。由于参数太多了，端到端的训练难以直接完成，所以采用了分步的训练方式，每个解码层逐个加入已经练好的网络中，直到性能不再提升时，就不再加入新的解码层了。</p> 
<blockquote> 
 <p>这里的“解码器”是指卷积神经网络（Convolutional Neural Network, CNN）中的一个部分，它通常位于网络的末端，用于从编码器部分接收抽象的特征表示并对其进行解码，以生成原始输入的某种形式或结构。在您提到的场景中，解码器是学习上采样参数的组件，其目的是将特征图从较低分辨率上采样到较高分辨率。</p> 
</blockquote> 
<h4>DeconvNet</h4> 
<p><img alt="" height="336" src="https://images2.imgbox.com/02/00/TjyI0iwE_o.png" width="1005"></p> 
<p>（1）使用反卷积和Unpooling来弥补FCN规定了维度的缺点</p> 
<p>（2）Unpooling与池化层相对应，池化层记录好每个结果对应的来源(下标)传递给Unpooling层，如图12-5所示</p> 
<p><img alt="" height="369" src="https://images2.imgbox.com/23/d0/hseThQiT_o.png" width="894"></p> 
<p>（3）图12-6示意了反卷积操作，尽管看起来反卷积操作将特征图扩大了，但是DeconvNet中的反卷积层保持特征图不变。特征图的增大是通过Unpooling来实现的</p> 
<p><img alt="" height="404" src="https://images2.imgbox.com/c0/b4/SL9tAcrO_o.png" width="897"></p> 
<p>（4）与FCN相比，这种结构化的反卷积能够获得不同层次的形状和细节，弥补了FCN在特大或特小物体语义分割上的缺陷</p> 
<p>（5）DeconvNet也同样遇到了网络结构复杂、训练样本少的问题。为了解决这个问题，De-onvNet在每个卷积和反卷积层增加了Batch Normalization。DeconvNet还采用了分段训练的方式，先使用简单的样本训练网络，然后再用复杂的样本微调网络。为了获得简单的训练样本，先裁剪图片，使得目标物体位于图片中央。在推断时，采用了区域提名的技术来辅助，将多个区域的结果合并作为最终结果呈现</p> 
<h4>SegNet</h4> 
<p>（1）在SegNet中也采用Unpooling来进行解码。在解码阶段重用Max-Pooling参数的好处是:</p> 
<p>        1.提升了边界的描述能力;</p> 
<p>        2.减少了端到端训练的参数数量;</p> 
<p>        3.这种类型的上采样可以应用到任何编码-解码的结构中。另外，SegNet并没有使用反卷积层，而是使用了卷积层。<br> （2）与FCN和DeconvNet相比，SegNet减少了原来分类网络中的全连接层，内存消耗和计算时间都有优势。由于参数数量的减少，采用SegNet比较容易实现端到端的训练。</p> 
<p>（3）对图像语义分割效果的判断方式：</p> 
<p>        1.全局均值：按像素正确分类的比例计算，这个指标的计算方式简单，容易应用在深度神经网络中。但是它没有考虑不同种类物体的差别，它与人类的认知也有一定的差别。<br>         2.分类平均准确率：所有分类预测准确率的平均值</p> 
<p>        3.交集/并集的均值：mloU比分类平均准确率更严格，因为它惩罚了伪正例。但是它的缺点是交叉熵损失不好直接优化。另外，它只是衡量了像素点正确分类的总数，并没有精确地描述切分边界的准确性。<br>         4.语义轮廓得分：在给定容忍距离的情况下，计算预测边界和真实边界的F1-measure。语义轮廓得分和mloU组合的方式与人类的认知最接近。</p> 
<h4>DilatedConvNet</h4> 
<p>（1）FCN、DeconvNet和SegNet都表明为分类而训练的卷积网络可以用来进行语义分割</p> 
<p>（2）分类网终通过下采样来获得不同尺度的上下文信息。然而，稠密预测不仅需要多尺度的上<br> 文信息，还需要全分辨率的输出</p> 
<blockquote> 
 <p>1.细节与语义的平衡：全分辨率输出可以提供图像的精细细节，但可能缺乏对图像整体语义的把握。多尺度特征能够捕捉到不同层次的语义信息，但可能会忽略某些细节。<br> 2.计算资源与性能：全分辨率输出需要较高的计算资源和存储空间，因为需要处理大量的像素数据。而多尺度特征通常涉及上下采样操作，这可能会导致计算资源的浪费，尤其是在需要高分辨率输出时。<br> 3.上下采样的影响：在多尺度特征中，上下采样操作可能会导致信息的丢失。上采样虽然可以恢复一些细节，但很难恢复原始的高分辨率信息。这会影响分割的精确度。</p> 
</blockquote> 
<p>（3）最近有两种方法来解决多尺度和全分辨率输出的矛盾：</p> 
<p>        1.通过下采样获取全局信息后，使用多层上采样-卷积来恢复丢失的分辨率信息</p> 
<p>        2.使用多尺度的输入图片作为多个输入，然后把不同输入的预测结合起来</p> 
<p>（4）DilatedConvNet与前面所述的三种网络结构不同，前三种网络都是在分类网络的基础上加入了解码结构，使得原来求解分类问题的网络变为求解稠密问题的网络。而DilatedConvNet则使用了膨胀卷积，在不损失分辨率、不需要借助多尺度输入图片的基础上，融合了多尺度的上下文信息</p> 
<p>（5）DilatedConvNet的实现也以VGGNet16为蓝本，但是去了所有的池化和步长，而是以膨胀卷积层来扩大感受野。实验指出，去掉池化层和中间层的填充会提升准确率</p> 
<h3>CRF/MRF的使用</h3> 
<h4>DeepLab</h4> 
<p>（1）把DCNN直接用于语义分割，需要克服两方面的缺点：一是信号降采样；二是空间不变性</p> 
<p>（2）DeepLab为了克服降采样的缺点，先于DilatedConvNet采用了膨胀卷积，但是它保留了池化层</p> 
<p>（3）第二个问题则是由以获取目标来做决策的分类问题跟与空间信息相关的分割问题的矛盾引发的。Deeplab为了解决第二个问题，采用了条件随机场DenseCRF。之所以使用DenseCRF，是由于它不仅运算速度快，而且既保留了细节，又能获得长距离的依赖关系</p> 
<p>（4）可以说，Deeplab的贡献在于结合了深度卷积神经网络和概率图模型这两大机器学习方法</p> 
<p>（5）DCNN的得分映射 (Score Map，Sofmax层的输入)能够预测物体的大概位置，但是边界定位得不够好。卷积层天然使得在分类准确性和定位准确性之存在取舍：在分类网络中，具有多个池化层的更深的模型在分类问题上更准确，但是它的位置无关性和更大的感受野使得在得分映射上计算准确位置更难</p> 
<p>（6）传统的CRF使用能量函数来建模相邻节点，使相近的像素点更倾向于相同分类，这与图像语义分割的目标不同：得分映射已经非常平滑，相近的像素点已经具有同质化的分类，在这种情况下，使用短距离的CRF可能会有害。<strong>语义分割的目标是还原细节，但不是进一步平滑</strong>。所Deeplab采用了长距离的CRF，模型的能量函数如下:</p> 
<p><img alt="" height="118" src="https://images2.imgbox.com/fa/a9/kuJEgloF_o.png" width="581"></p> 
<p>（7）DeepLab还使用了多尺度预测的方法，在输入图片和前四个池化层的输出后都增加两层感知机</p> 
<h4>CRFasRNN</h4> 
<p>（1）Deeplab中的深度卷积神经网络和条件随机场相互独立，可以说是在DCNN的结果后面增加了一个独立的概率图型，没有办法获得CRF的信息，CRF能力还没有得到完全的发挥</p> 
<p>（2）CRFasRNN的贡献在于把CRF建模成深度神经网络的一部分，实现了端到端深度学习的解决方案。首先用CNN来建模CRF的一次迭代，然后用RNN来建模所有迭代</p> 
<p>（3）平均长建模为CNN的步骤：</p> 
<p>        1.初始化。在每个像素点上对每个标签都做Softmax，这步操作没有任何额外的参数，而且可以很容易地使用CNN中的Softmax来实现前向、后向传播。<br>         2.信息传递。在DenseCRF中，信息传递的实现是在Q值上使用了m个高斯核。高斯核的系数由像素位置和RGB值来决定。由于CRF可能是全局关联的，所以每个高斯核的感受野都需要是整张图片的大小。<br>         3.高斯核结果加权求和。对每个像素点的每个标签都做一次求和操作，把前一步骤中的每个高斯核的结果做加权求和。<br>         4.相容性变换。μ(l, l')表示 l 和 l‘ 这两个标签之间的相容性。不同的标签对具有不同的外罚，例如，&lt;"人"，“自行车”&gt;的外罚要比&lt;"天空"，"自行车“&gt;的处罚低。这一步可以看作输入通道和输出通道都是L(标签个数)的卷积核大小为1x1的卷积层。这一步就是在学习标签之间的相容性函数<br>         5.增加一元势函数。这一步没有额外的参数.<br>         6.标准化。采用一个Softmax函数实现</p> 
<p><img alt="" height="659" src="https://images2.imgbox.com/2f/9b/db1adim5_o.png" width="1004"></p> 
<p>（4）将CRF多次迭代建模成RNN：</p> 
<p>网络的行为可以用如下一组公式来表示：</p> 
<p><img alt="" height="423" src="https://images2.imgbox.com/08/ac/QRmMAieP_o.png" width="636"></p> 
<p>平均场迭代不超过10次就可以收敛，在实际使用中，超过5次迭代之后，继续迭代，就不能显著地提高效果了。所以在这个问题上并不会遇到梯度消失或梯度爆炸的问题。因此这里采用了更简洁的RNN结构，并没有采用诸如LSTM之类的结构。</p> 
<p><img alt="" height="705" src="https://images2.imgbox.com/72/c7/Q2PeFtoo_o.png" width="839"></p> 
<h4>DPN</h4> 
<p>（1）使用现有的CNN来完成一元问题，然后又精心设计了其他层来模拟平均场算法的二元问题</p> 
<p>（2）优点：</p> 
<p>        1.在综合使用了CNN和随机场的一般工作中，需要对随机场做多次迭代，然而DPN只做一次迭代就可以获得比较好的效果。<br>         2.DPN同时考虑了空间上下文关系和高阶关系，有能力对各种二元问题进行建模，使得很多二元问题成为DPN的特例。<br>         3.DPN使得马尔可夫场问题能够并行化解决，通过GPU来加速计算。DPN使用卷积和池化操作来近似MF，可以通过近似来加速</p> 
<p>（3）二元势函数都是通过考虑任意两个像素点之间的关系来构造的，比如如RGB像素点的距离或者空间距离。在空间上相近且看起来相似的两个点，应该更容易获得相同的标签</p> 
<p>（4）缺点：</p> 
<p>        1.它只考虑了共现的频率，却没有考虑空间上下文关系，比如当人和椅子一起出现的时候，人应该是坐在椅子上的，而不太可能在椅子下</p> 
<p>        2.它只考虑了像素点之间成对的关系，却没有考虑更高阶的关系</p> 
<p>（5）为了解决这些缺点，在二元势函数中引入了三元惩罚项:</p> 
<p><img alt="" height="163" src="https://images2.imgbox.com/c1/1c/49CBZHDP_o.png" width="766"></p> 
<p>这个式子学习了局部标记上下文的混合。K是混合组件的数量，λk取值为0或1，表示哪个组件被激活，且∑λk=1</p> 
<h3>实例分割</h3> 
<p>（1）可以使用Faster R-CNN与FCN方法相结合实现实例的分割</p> 
<h4 style="background-color:transparent;">Mask R-CNN</h4> 
<p><img alt="" height="443" src="https://images2.imgbox.com/e4/df/4YHBmnq0_o.png" width="787"></p> 
<p>（1）在Faster R-CNN的基础上做了以下改进：</p> 
<p>        1.在每个Rol上都增加了一个分支，能够在预测分类和边框的同时，使用一个很小的全卷积网络来得到掩码。整个网络的损失由三部分构成:分类损失、边框损失和掩码损失。在FCN中，为每个像素点进行多个分类之间的Softmax运算，不同类之间存在竞争关系，然而，在Mask R-CNN中，为每个分类都会生成一份掩码，不同类之间没有竞争关系。</p> 
<blockquote> 
 <p>在传统的分类任务中，比如使用 Softmax 函数的神经网络，目的是要预测一个像素或者一个物体的类别。在这个过程中，不同的类别之间是相互竞争的，因为一个像素或物体只能属于一个类别，所以神经网络输出的概率分布要能够反映出这种竞争关系。<br> 而在 Mask R-CNN 中，我们不仅预测物体的类别，还要为每个物体生成一个掩码。这个掩码是一个二值图，表明图像中的每个像素是否属于该物体。因此，对于每个类别，我们都会生成一个掩码，不同类别的掩码之间并不相互竞争，因为它们对应的是不同的物体。即使是同一物体，不同类别的掩码也是独立的，因为每个类别都对应物体的一部分或者全部。</p> 
</blockquote> 
<p>        2.使用RolAlign代替RolPool，在Fast R-CNN中使用RolPool把Rol的浮点数量化为整数，这个量化使RolPool的结果与真实的特征图谱之间存在误差。为了解决这个问题，RolAlign使用了双线性插值来表示精确的Rol。<br>         3.使用了FPN来获取不同维度的特征。</p> 
<h2>图像检索的深度哈希编码</h2> 
<p>（1）为了满足实时性的搜索要求，一般会提取出图片特征并以0、1的哈希编码来压缩代替</p> 
<h3>传统哈希编码方法</h3> 
<p>（1）解决思路：先对原图像用人工提取的特征来表达，即先从原图像压缩至特征表达，然后再从特征表达映射至哈希编码</p> 
<p>（2）以KSH为例，其所代表的算法如下：</p> 
<p>        1.提取特征：在训练集T内共含M张图，遍历m=1,2，.., M，对第m图提取人工特征，如HOG、SIFT等，然后将特征连接起来形成一个长向量来表达该图: feature(m)<br>         2.分解相似度矩阵：将按照标准的两两相似/不相似结果构建矩阵S，即1为相似、0为不似，则S为0和1组成的矩阵，且Sij为图 i 和图 j 相似与否的标注结果；将S分解成HH.T，使得min|HH.T-S|，则H为训练集T对应的哈希编码矩阵，其第m行对应图片m的哈希编码值。</p> 
<p>        3.求得特征表达至哈希值的映射g: feature (m) -&gt; H (m)。训练学习结束。<br>         4.测试时，对应图片I，先样提取特征表达feature (I)，再根据映射g得到其哈希编码</p> 
<p>H (I)=g(feature (I))。</p> 
<p>（3）从以上步骤可以看出，难点集中在第2步，即将相似度矩阵S分解成可能的哈希编码矩阵HH.T，并且约束H的取值为0或1</p> 
<p>（4）训练集过大，则意味着S也会过大，分解起来将会变得十分困难，甚至不可达成</p> 
<h3>CNNH(CNN-Hashing)</h3> 
<p><img alt="" height="323" src="https://images2.imgbox.com/a1/d4/9bMeUISR_o.png" width="1006"></p> 
<p>（1）Stage1是将相似度矩阵拆解成哈希编码矩阵及其转置的乘积。这一步与传统方法的第2步完全相同</p> 
<p>（2）Stage2利用CNN一并完成了传统方法的第1、3步</p> 
<p>（3）缺点：</p> 
<p>        1.相以度矩阵分解依然是问题的瓶颈</p> 
<p>        2.分解后的哈希编码在Stage2无法继续改进，整个流程仍然不是端到端的简洁模型。</p> 
<h3>DSH</h3> 
<p><img alt="" height="397" src="https://images2.imgbox.com/fb/ab/JR09akSW_o.png" width="1007"></p> 
<p>（1）DSH方法不再包含分解相似度矩阵的步骤，而是从图片到二值哈希编码一气呵成，最后的全连接层就是哈希编码了</p> 
<p>（2）Q：是如何省去相似度矩阵分解的呢？</p> 
<p><img alt="" height="503" src="https://images2.imgbox.com/14/1f/WeGMfozi_o.png" width="1008"></p> 
<p>A：DSH方法其实是双路模型，即输入为一对图片，输出为这一对图片的距离，对应于其相似、不相似的标签，如图13-3所示。因此，DSH是按图片对及它们的相似标签进行训练的，两路网络的参数共享，因此它们是一模一样的。在测试时，待检索的图片只需经过单路模型，得到其<br> 哈希编码。</p> 
<p>（3）图片对的当前哈希编码距离是在最后一层的基础上得到的，网络训练的损失函数则围绕这个距离的大小与实际相似与否的标签来进行。大体思路是，如果标签相同，哈希编码距离越小则损失函数值越小；反之，如果标签不同，则距离越大好。此外，由于哈希编码要限制在0或1上，还需要补充损失函数完成这样的偏好选择。具体的损失函数表达式如下:</p> 
<p><img alt="" height="283" src="https://images2.imgbox.com/01/2d/KH3sEOyE_o.png" width="824"></p> 
<p>        第一部分对应的是在标注结果“相同”的情况下，图片的哈希编码距密的损失以欧式距离来表示；</p> 
<p>        第二部分是在标注结果“不同”的情况下，以折页损失函数(Hinge loss Function)来表示，即距离小于m时，距离越小则损失函数值越大，而当距离大于值m后，认为已经分开得足够远了，损失降为0；</p> 
<p>        第三部分则为与"二值化”相关的损失，在DSH中，将哈希值的二值规定为-1、1，因此，如果哈希编码的各个位的值的绝对值越接近于1，则损失函数值越小。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/381d1c28b117a6406bde4973f1fd2fdb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">新年快乐！</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6b951da076c26c99b25f6df7c29e09b3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">2021/11/11 idea设置和快捷键、idea打jar包、nsis工具</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>