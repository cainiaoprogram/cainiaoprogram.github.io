<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>＜ 数据结构 ＞ 堆的应用 --- 堆排序和Topk问题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="＜ 数据结构 ＞ 堆的应用 --- 堆排序和Topk问题" />
<meta property="og:description" content="目录
1、堆排序
法一：自己写堆进行排序
时间复杂度分析
法二：直接对数组建堆
①、向上调整建堆
②、向下调整建堆
向上建堆和向下建堆熟优？
升序能否建小堆？
排序（建大堆）
2、TopK问题
何为Topk？
实现过程
1、堆排序 假如我们有一串乱序数组，如下： 现在想要对它进行排序，按照我们之前学过的知识，想要单纯的实现排序其实并不难，可以直接暴力排序，也可以冒泡排序，甚至使用库函数qsort进行排序……
但是，既然近期学习了堆，那么堆的一个重要应用就是进行堆排序，这里先简要提下：堆排序即快排的一种。在后面的学习中，我将为大家继续展开其它更多样的快排。今儿个就向各位浅谈下快排之一：堆排序
法一：自己写堆进行排序 思路： 在上篇博文中，我们模拟实现了堆，实现后即可对一串乱序数组进行堆排序。假设我们排升序，且堆为小根堆。实现过程非常简单。
首先，把数组的每个元素（HeapPush）插入到堆中。其次，我们深知小根堆的堆顶是最小的数字，依次遍历堆顶（HeapTop）的元素，将堆顶元素赋值到数组里，从下标0开始，赋值后删除（HeapPop）堆顶元素，&#43;&#43;数组下标。此时堆就会重新调整，最终堆顶依旧是最小的，再重复上述赋值堆顶到数组的操作，直到堆为空（HeapEmpty） 代码如下： //堆排序 --- 升序 void HeapSort(int* a, int size) { //创建堆结构并初始化 HP hp; HeapInit(&amp;hp); //将数组元素插入堆中 for (int i = 0; i &lt; size; i&#43;&#43;) { HeapPush(&amp;hp, a[i]); } size_t j = 0; //依次遍历，取堆顶赋值数组，&#43;&#43;下标，pop堆顶，依次循环，直至堆为空 while (!HeapEmpty(&amp;hp)) { a[j] = HeapTop(&amp;hp); j&#43;&#43;; HeapPop(&amp;hp); } //记得销毁动态开辟空间 HeapDestroy(&amp;hp); } int main() { int a[] = { 4,2,7,8,5,1,0,6 }; HeapSort(a, sizeof(a) / sizeof(int)); //实现堆排序 for (int i = 0; i &lt; sizeof(a) / sizeof(int); i&#43;&#43;) { printf(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/77c4387d02186b00fb737db28c865567/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-18T16:07:17+08:00" />
<meta property="article:modified_time" content="2022-04-18T16:07:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">＜ 数据结构 ＞ 堆的应用 --- 堆排序和Topk问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E5%A0%86%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F" rel="nofollow">1、堆排序</a></p> 
<p id="%E6%B3%95%E4%B8%80%EF%BC%9A%E8%87%AA%E5%B7%B1%E5%86%99%E5%A0%86%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#%E6%B3%95%E4%B8%80%EF%BC%9A%E8%87%AA%E5%B7%B1%E5%86%99%E5%A0%86%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F" rel="nofollow">     </a> <a href="#%E6%B3%95%E4%B8%80%EF%BC%9A%E8%87%AA%E5%B7%B1%E5%86%99%E5%A0%86%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F" rel="nofollow">法一：自己写堆进行排序</a></p> 
<p id="%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90-toc" style="margin-left:80px;"><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90" rel="nofollow">              </a><a href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90" rel="nofollow">时间复杂度分析</a></p> 
<p id="%E6%B3%95%E4%BA%8C%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%AF%B9%E6%95%B0%E7%BB%84%E5%BB%BA%E5%A0%86-toc" style="margin-left:80px;"><a href="#%E6%B3%95%E4%BA%8C%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%AF%B9%E6%95%B0%E7%BB%84%E5%BB%BA%E5%A0%86" rel="nofollow">      </a><a href="#%E6%B3%95%E4%BA%8C%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%AF%B9%E6%95%B0%E7%BB%84%E5%BB%BA%E5%A0%86" rel="nofollow">法二：直接对数组建堆</a></p> 
<p id="%E2%91%A0%E3%80%81%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E5%BB%BA%E5%A0%86-toc" style="margin-left:80px;"><a href="#%E2%91%A0%E3%80%81%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E5%BB%BA%E5%A0%86" rel="nofollow">              </a><a href="#%E2%91%A0%E3%80%81%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E5%BB%BA%E5%A0%86" rel="nofollow">①、向上调整建堆</a></p> 
<p id="%E2%91%A1%E3%80%81%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E5%BB%BA%E5%A0%86-toc" style="margin-left:80px;"><a href="#%E2%91%A1%E3%80%81%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E5%BB%BA%E5%A0%86" rel="nofollow">              </a><a href="#%E2%91%A1%E3%80%81%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E5%BB%BA%E5%A0%86" rel="nofollow">②、向下调整建堆</a></p> 
<p id="%E5%90%91%E4%B8%8A%E5%BB%BA%E5%A0%86%E5%92%8C%E5%90%91%E4%B8%8B%E5%BB%BA%E5%A0%86%E7%86%9F%E4%BC%98%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E5%90%91%E4%B8%8A%E5%BB%BA%E5%A0%86%E5%92%8C%E5%90%91%E4%B8%8B%E5%BB%BA%E5%A0%86%E7%86%9F%E4%BC%98%EF%BC%9F" rel="nofollow">              </a><a href="#%E5%90%91%E4%B8%8A%E5%BB%BA%E5%A0%86%E5%92%8C%E5%90%91%E4%B8%8B%E5%BB%BA%E5%A0%86%E7%86%9F%E4%BC%98%EF%BC%9F" rel="nofollow">向上建堆和向下建堆熟优？</a></p> 
<p id="%E5%8D%87%E5%BA%8F%E8%83%BD%E5%90%A6%E5%BB%BA%E5%B0%8F%E5%A0%86%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E5%8D%87%E5%BA%8F%E8%83%BD%E5%90%A6%E5%BB%BA%E5%B0%8F%E5%A0%86%EF%BC%9F" rel="nofollow">              </a><a href="#%E5%8D%87%E5%BA%8F%E8%83%BD%E5%90%A6%E5%BB%BA%E5%B0%8F%E5%A0%86%EF%BC%9F" rel="nofollow">升序能否建小堆？</a></p> 
<p id="%E6%8E%92%E5%BA%8F%EF%BC%88%E5%BB%BA%E5%A4%A7%E5%A0%86%EF%BC%89-toc" style="margin-left:80px;"><a href="#%E6%8E%92%E5%BA%8F%EF%BC%88%E5%BB%BA%E5%A4%A7%E5%A0%86%EF%BC%89" rel="nofollow">              </a><a href="#%E6%8E%92%E5%BA%8F%EF%BC%88%E5%BB%BA%E5%A4%A7%E5%A0%86%EF%BC%89" rel="nofollow">排序（建大堆）</a></p> 
<p id="TopK%E9%97%AE%E9%A2%98-toc" style="margin-left:80px;"><a href="#TopK%E9%97%AE%E9%A2%98" rel="nofollow">2、TopK问题</a></p> 
<p id="%E4%BD%95%E4%B8%BATopk%EF%BC%9F-toc" style="margin-left:80px;"><a href="#%E4%BD%95%E4%B8%BATopk%EF%BC%9F" rel="nofollow">        </a><a href="#%E4%BD%95%E4%B8%BATopk%EF%BC%9F" rel="nofollow">何为Topk？</a></p> 
<p id="%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B-toc" style="margin-left:80px;"><a href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B" rel="nofollow">        </a><a href="#%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B" rel="nofollow">实现过程</a></p> 
<hr> 
<h4>1、堆排序</h4> 
<blockquote> 
 <ul><li>假如我们有一串乱序数组，如下：</li></ul> 
 <p><img alt="" height="44" src="https://images2.imgbox.com/dc/41/cyWvoVk6_o.png" width="613"></p> 
 <p> 现在想要对它进行排序，按照我们之前学过的知识，想要单纯的实现排序其实并不难，可以直接<span style="color:#956fe7;">暴力排序，也可以冒泡排序，甚至使用库函数qsort进行排序……</span></p> 
 <p>但是，既然近期学习了堆，那么堆的一个重要应用就是进行堆排序，这里先简要提下：堆排序即快排的一种。在后面的学习中，我将为大家继续展开其它更多样的快排。<span style="color:#956fe7;">今儿个就向各位浅谈下快排之一：堆排序</span></p> 
</blockquote> 
<h4 id="%E6%B3%95%E4%B8%80%EF%BC%9A%E8%87%AA%E5%B7%B1%E5%86%99%E5%A0%86%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F">法一：自己写堆进行排序</h4> 
<blockquote> 
 <ul><li><span style="background-color:#fbd4d0;">思路：</span></li></ul> 
 <p>在上篇博文中，我们模拟实现了堆，实现后即可对一串乱序数组进行堆排序。假设我们排升序，且堆为小根堆。实现过程非常简单。</p> 
 <ol><li>首先，<span style="color:#956fe7;">把数组的每个元素（HeapPush）插入到堆中。</span></li><li>其次，我们深知小根堆的堆顶是最小的数字，<span style="color:#956fe7;">依次遍历堆顶（HeapTop）的元素，将堆顶元素赋值到数组里，从下标0开始，赋值后删除（HeapPop）堆顶元素，++数组下标。</span>此时堆就会重新调整，最终堆顶依旧是最小的，<span style="color:#fe2c24;">再重复上述赋值堆顶到数组的操作，直到堆为空（HeapEmpty）</span></li></ol> 
 <ul><li><span style="background-color:#fbd4d0;">代码如下：</span></li></ul> 
 <pre><code class="language-cpp">//堆排序 --- 升序
void HeapSort(int* a, int size)
{
//创建堆结构并初始化
	HP hp; 
	HeapInit(&amp;hp);
//将数组元素插入堆中
	for (int i = 0; i &lt; size; i++)
	{
		HeapPush(&amp;hp, a[i]);
	}
	size_t j = 0;
//依次遍历，取堆顶赋值数组，++下标，pop堆顶，依次循环，直至堆为空
	while (!HeapEmpty(&amp;hp))
	{
		a[j] = HeapTop(&amp;hp);
		j++;
		HeapPop(&amp;hp);
	}
//记得销毁动态开辟空间
	HeapDestroy(&amp;hp);
}
int main()
{
	int a[] = { 4,2,7,8,5,1,0,6 };
	HeapSort(a, sizeof(a) / sizeof(int)); //实现堆排序
	for (int i = 0; i &lt; sizeof(a) / sizeof(int); i++)
	{
		printf("%d ", a[i]); //打印
	}
	printf("\n");
	return 0;
}</code></pre> 
 <ul><li><span style="background-color:#fbd4d0;">效果如</span><span style="background-color:#fbd4d0;">下：</span></li></ul> 
 <p><img alt="" height="64" src="https://images2.imgbox.com/e6/e2/swHAQdwn_o.png" width="601"></p> 
</blockquote> 
<h4 id="%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90">时间复杂度分析</h4> 
<blockquote> 
 <ul><li><span style="background-color:#fbd4d0;">段一：</span></li></ul> 
 <pre><code class="language-cpp">	for (int i = 0; i &lt; size; i++)
	{
		HeapPush(&amp;hp, a[i]);
	}</code></pre> 
 <p><span style="color:#fe2c24;">此段代码的时间复杂度为O(N*logN)</span><span style="color:#494949;">，</span>因为HeapPush函数的内部执行过程就是把数组的每个元素插入堆中，有N次。接着，每插入一个数据都要重新向上调整（AdjustUp）高度次以确保为堆，每个都要调整高度次，高度为logN，综上此段为O(N*logN)</p> 
 <ul><li><span style="background-color:#fbd4d0;">段二：</span></li></ul> 
 <pre><code class="language-cpp">	while (!HeapEmpty(&amp;hp))
	{
		a[j] = HeapTop(&amp;hp);
		j++;
		HeapPop(&amp;hp);
	}</code></pre> 
 <p><span style="color:#fe2c24;">此段的时间复杂度同样为O(N*logN)</span>，原理跟上一段类似，不过多赘述。</p> 
 <ul><li><span style="background-color:#fbd4d0;">分析：</span></li></ul> 
 <p><span style="color:#fe2c24;">综上，时间复杂度为O(N*logN)</span>，确实比我们先前的冒泡排序O(N^2)要快不少。但是，这个方法排序是及其不好的，因为难道说为了实现堆排序还要自己手写一个完整的堆吗？这么复杂的实现堆的过程还不如不用堆排序了，这种伤敌一千，自损八百的感脚实在是难受。<span style="color:#956fe7;">更何况此法的空间复杂度也是很大的，达到了惊人的O(N)。原因是实现堆的过程是动态开辟的，所以空间复杂度自然是O(N)。</span>可不可以换一更优的方法，但同样是利用堆的思想实现快排呢？</p> 
 <p><span style="background-color:#ffd900;">现在我们要求如下：</span></p> 
 <ol><li>依旧是堆的思想</li><li>时间复杂度O(N*logN)</li><li>空间复杂度O(1)</li></ol> 
 <p>前面我们已经知晓，数组即为完全二叉树，为什么还要实现一个堆呢？直接把数组看作堆难道不香嘛？<span style="color:#0d0016;">由此我们引出：</span><span style="color:#956fe7;">直接对数组建堆。</span>详解见下文：</p> 
</blockquote> 
<h4 id="%E6%B3%95%E4%BA%8C%EF%BC%9A%E7%9B%B4%E6%8E%A5%E5%AF%B9%E6%95%B0%E7%BB%84%E5%BB%BA%E5%A0%86">法二：直接对数组建堆</h4> 
<blockquote> 
 <p>再来看下这串乱序数组：</p> 
 <p><img alt="" height="45" src="https://images2.imgbox.com/fa/2c/mCm8LTln_o.png" width="651"></p> 
 <p>既然上文说到可以直接把它看作二叉树，那不妨把逻辑结构画出来看看：</p> 
 <p> <img alt="" height="232" src="https://images2.imgbox.com/11/c5/XgeqAAGc_o.png" width="701"></p> 
 <p>接下来，我们就要进行建堆了，有两种方法：</p> 
 <ol><li>使用向上建堆，插入数据的思想建堆</li><li>使用向下调整建堆</li></ol> 
</blockquote> 
<h4 id="%E2%91%A0%E3%80%81%E5%90%91%E4%B8%8A%E8%B0%83%E6%95%B4%E5%BB%BA%E5%A0%86">①、向上调整建堆</h4> 
<blockquote> 
 <ul><li><span style="background-color:#fbd4d0;">思想：</span></li></ul> 
 <p>首先，我们把第一个数字看成堆，也就是4，当第二个数字插入进去的时候，进行向上调整算法，使其确保为小堆，向上调整的算法在上篇博文已详细讲解过，不过多赘述。具体插入数据过程就是遍历数组，确保数组里每一个数进行向上调整算法</p> 
 <ul><li><span style="background-color:#fbd4d0;">画图演示：</span></li></ul> 
 <p><img alt="" height="933" src="https://images2.imgbox.com/27/52/Rpu1baNC_o.png" width="1156"></p> 
 <ul><li><span style="background-color:#fbd4d0;"> 代码如下：</span></li></ul> 
 <pre><code class="language-cpp">//交换
void Swap(int* pa, int* pb)
{
	int tmp = *pa;
	*pa = *pb;
	*pb = tmp;
}
//向上调整算法
void AdjustUp(int* a, size_t child)
{
	size_t parent = (child - 1) / 2;
	while (child &gt; 0)
	{
		//if (a[child] &gt; a[parent]) //大根堆
		if (a[child] &lt; a[parent]) //小根堆
		{
			Swap(&amp;a[child], &amp;a[parent]);
			child = parent;
			parent = (child - 1) / 2;
		}
		else
		{
			break;
		}
	}
}
//升序
void HeapSort(int* a, int n)
{
	//建堆
	int i = 0;
	for (i = 1; i &lt; n; i++) //应该从i=1时遍历，因为第一个数据在堆里不需要调整，后续再插入时调整
	{
		AdjustUp(a, i);
	}
}
int main()
{
	int a[] = { 4,2,7,8,5,1,0,6 };
	HeapSort(a, sizeof(a) / sizeof(int));
	for (int i = 0; i &lt; sizeof(a) / sizeof(int); i++)
	{
		printf("%d ", a[i]);
	}
	return 0;
}</code></pre> 
 <ul><li><span style="background-color:#fbd4d0;"> 效果如下：</span></li></ul> 
 <p><img alt="" height="57" src="https://images2.imgbox.com/70/ad/Wpywd8aY_o.png" width="553"></p> 
 <p> 符合小堆的性质</p> 
</blockquote> 
<h4 id="%E2%91%A1%E3%80%81%E5%90%91%E4%B8%8B%E8%B0%83%E6%95%B4%E5%BB%BA%E5%A0%86">②、向下调整建堆</h4> 
<blockquote> 
 <ul><li><span style="color:#956fe7;"><strong>问题：</strong>能直接进行向下建堆吗？</span></li></ul> 
 <p><span style="color:#fe2c24;"><strong>答案：</strong>不能</span></p> 
 <p><strong>解析：</strong>首先回顾下使用向下调整的前提是什么？<span style="color:#ff9900;">必须得确保根结点的左右子树均为小堆才可</span>，而这里，数组为乱序的，无法直接使用。</p> 
 <ul><li><span style="color:#956fe7;"><strong>解决办法：</strong>从倒数第一个非叶结点开始向下调整，从下往上调</span></li></ul> 
 <p><strong>分析：</strong>从该解决方案中，我们首先要找到这个倒数第一个非叶结点的数在哪？其实<span style="color:#ff9900;">最后一个结点的父亲即为倒数第一个非叶结点。</span>当我们找到这个非叶结点时，把它和它的孩子看成一个整体，进行向下调整。调整后，再将次父节点向前挪动，再次向下调整，依次循环下去。</p> 
 <ul><li><span style="color:#956fe7;">再回顾下父亲和孩子间的关系：</span></li></ul> 
 <ol><li><span style="color:#ff9900;">leftchild = parent*2 + 1</span></li><li><span style="color:#ff9900;">rightchild = parent*2 + 2</span></li><li><span style="color:#fe2c24;">parent = (child - 1) / 2</span></li></ol> 
 <ul><li><span style="color:#956fe7;">画图解析过程：</span></li></ul> 
 <p><img alt="" height="997" src="https://images2.imgbox.com/d2/10/FrBEo5lV_o.png" width="1200"></p> 
 <ul><li><span style="background-color:#fbd4d0;"> 代码如下：</span></li></ul> 
 <pre><code class="language-cpp">//升序
void HeapSort(int* a, int n)
{
	//建堆
	//1、向上调整
	int i = 0;
	for (i = 1; i &lt; n; i++) //应该从i=1时遍历，因为第一个数据在堆里不需要调整，后续再插入时调整
	{
		AdjustUp(a, i);
	}
	//2、向下调整
	for (int i = (n - 1 - 1)/2; i &gt;= 0; i--)
	{
		AdjustDown(a, n, i);
	}
}</code></pre> 
 <ul><li><span style="background-color:#fbd4d0;">效果如下：</span></li></ul> 
 <p><img alt="" height="55" src="https://images2.imgbox.com/26/13/7gyYRO7c_o.png" width="653"></p> 
 <p> 符合小堆的性质</p> 
</blockquote> 
<h4 id="%E5%90%91%E4%B8%8A%E5%BB%BA%E5%A0%86%E5%92%8C%E5%90%91%E4%B8%8B%E5%BB%BA%E5%A0%86%E7%86%9F%E4%BC%98%EF%BC%9F">向上建堆和向下建堆熟优？</h4> 
<blockquote> 
 <ul><li>首先，我们画张图看下向上和向下建堆后的样子。</li></ul> 
 <p><img alt="" height="287" src="https://images2.imgbox.com/e8/11/5VNnXU2E_o.png" width="873"></p> 
 <p>从上图中，我们可以看出，使用不同的方式建堆最后的样子是不同的，那哪种方式好呢？</p> 
 <ul><li><span style="color:#0d0016;">接下来，我将通过</span><span style="color:#956fe7;">时间复杂度</span><span style="color:#0d0016;">的方式为大家解惑：以一颗</span><span style="color:#956fe7;">满二叉树</span><span style="color:#0d0016;">为例：</span></li></ul> 
 <p><img alt="" height="343" src="https://images2.imgbox.com/e0/a5/kOpfR1Xo_o.png" width="946"></p> 
 <ul><li><span style="background-color:#fbd4d0;"> 向上建堆：</span></li></ul> 
 <p></p> 
 <p><span style="color:#0d0016;">时间复杂度计算的是其调整的次数，根据上文的知识我们已经知晓其是从数组的第二个元素开始的，也就是可以理解为第二层的第一个节点。计算的思想非常简单：</span><span style="color:#956fe7;">计算每层有多少个节点乘以该层的高度次，然后累计相加即可。</span>如下：</p> 
 <p><img alt="" height="377" src="https://images2.imgbox.com/17/d4/atFyrrQF_o.png" width="1123"></p> 
 <p><span style="color:#0d0016;">通过计算得知：向上建堆的时间复杂度为</span><strong><span style="color:#fe2c24;">O(N*logN)</span></strong></p> 
 <ul><li><span style="background-color:#fbd4d0;">向下建堆：</span></li></ul> 
 <p><span style="color:#0d0016;">向下调整我们前面已经知道它是从倒数第1个非叶节点开始调整的，每层的调整次数为，</span><span style="color:#956fe7;">该层的节点个数*该层高度减1，一直从第1层开始调直至倒数第2层，并将其依次累加</span><span style="color:#0d0016;">，此计算过程和向上调整差不多，都是等比*等差的求和，过程如下：</span></p> 
 <p><img alt="" height="372" src="https://images2.imgbox.com/1f/63/bKdKfMb8_o.png" width="1029"></p> 
 <p><span style="color:#0d0016;"> 通过计算得知：向下建堆的时间复杂度为</span><strong><span style="color:#fe2c24;">O(N)</span></strong></p> 
 <ul><li><span style="background-color:#fbd4d0;">对比：</span></li></ul> 
 <p><span style="color:#0d0016;">通过上述计算，我们得到如下：</span></p> 
 <ol><li><span style="color:#956fe7;">向上建堆：O(N*logN)</span></li><li><span style="color:#fe2c24;">向下建堆：O(N)</span></li></ol> 
 <p><span style="color:#ff9900;">由此可见，使用向下建堆的方式更优，其时间复杂度较小。</span><span style="color:#0d0016;">当然，使用向上建堆也是可以的，只不过向下建堆更好一点。</span></p> 
</blockquote> 
<h4 id="%E5%8D%87%E5%BA%8F%E8%83%BD%E5%90%A6%E5%BB%BA%E5%B0%8F%E5%A0%86%EF%BC%9F">升序能否建小堆？</h4> 
<blockquote> 
 <ul><li><span style="color:#fe2c24;"><strong>答案：</strong>不能</span></li></ul> 
 <p><span style="color:#0d0016;"><strong>解析：</strong></span></p> 
 <p><span style="color:#0d0016;">从上文我们已经知道建堆用向下建堆是比较优的，为O(N)，并且建好堆后第一个位置的数字即为最小的，此时第一个数字已经确定了并且是最小的，但如若使用小堆的话，也就是需要从第二个数字开始往后看成一个堆，此时关系就全乱了，不再符合小堆的性质，此时</span><span style="color:#956fe7;">也就意味着我们需要从第二个数字往后重新向下建堆，以确保此时的堆顶也就是数组第二个元素为次小的，并以此类推重新建堆确保第三个次小的，依次循环下去……</span><span style="color:#0d0016;">如果这样做，还不如直接遍历选数！搞这么复杂。</span></p> 
 <ul><li><span style="color:#fe2c24;"><strong>解决方案：</strong>升序建大堆</span></li></ul> 
</blockquote> 
<h4 id="%E6%8E%92%E5%BA%8F%EF%BC%88%E5%BB%BA%E5%A4%A7%E5%A0%86%EF%BC%89">排序（建大堆）</h4> 
<blockquote> 
 <ul><li><span style="color:#0d0016;"><span style="background-color:#fbd4d0;"> 先看下建好大堆的样子：</span></span></li></ul> 
 <p><img alt="" height="300" src="https://images2.imgbox.com/0a/e9/cSHNhPx1_o.png" width="895"></p> 
 <ul><li><span style="background-color:#fbd4d0;">思路：</span></li></ul> 
 <p><span style="color:#0d0016;">首先，得明确我们建堆后，此时堆顶就是最大的数据，现在我们把</span><span style="color:#956fe7;">第一个数字</span><span style="color:#0d0016;">和</span><span style="color:#956fe7;">最后一个数字</span><span style="color:#fe2c24;">交换</span><span style="color:#0d0016;">，把</span><span style="color:#956fe7;">最后一个数字不看做堆里</span>的，只需要<span style="color:#956fe7;">数组个数N</span><span style="color:#0d0016;">--即可。此时的左子树和右子树依旧是大堆，再进行向下调整即可。</span></p> 
 <ul><li><span style="background-color:#fbd4d0;">画图解析过程：</span></li></ul> 
 <p><img alt="" height="1200" src="https://images2.imgbox.com/7a/20/VCx8qVPE_o.png" width="1200"></p> 
 <ul><li><span style="background-color:#fbd4d0;">代码如下：</span></li></ul> 
 <pre><code class="language-cpp">//交换
void Swap(int* pa, int* pb)
{
	int tmp = *pa;
	*pa = *pb;
	*pb = tmp;
}
//向下调整算法
void AdjustDown(int* a, size_t size, size_t root)
{
	int parent = (int)root;
	int child = 2 * parent + 1;
	while (child &lt; size)
	{
		//1、确保child的下标对应的值最大，即取左右孩子较大那个
		if (child + 1 &lt; size &amp;&amp; a[child + 1] &gt; a[child]) //得确保右孩子存在
		{
			child++; //此时右孩子大
		}
		//2、如果孩子大于父亲则交换，并继续往下调整
		if (a[child] &gt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = 2 * parent + 1;
		}
		else
		{
			break;
		}
	}
}
//升序
void HeapSort(int* a, int n)
{
	//向下调整建堆
	for (int i = (n - 1 - 1) / 2; i &gt;= 0; i--)
	{
		AdjustDown(a, n, i);
	}
	//大堆升序
	size_t end = n - 1;
	while (end &gt; 0)
	{
		Swap(&amp;a[0], &amp;a[end]);
		AdjustDown(a, end, 0);
		end--;
	}
}
int main()
{
	int a[] = { 4,2,7,8,5,1,0,6 };
	HeapSort(a, sizeof(a) / sizeof(int));
	for (int i = 0; i &lt; sizeof(a) / sizeof(int); i++)
	{
		printf("%d ", a[i]);
	}
	return 0;
}</code></pre> 
 <ul><li><span style="background-color:#fbd4d0;"> 效果如下：</span></li></ul> 
 <p><img alt="" height="49" src="https://images2.imgbox.com/f9/31/Jbx9Frdj_o.png" width="559"></p> 
</blockquote> 
<h4 id="TopK%E9%97%AE%E9%A2%98">2、TopK问题</h4> 
<h4 id="%E4%BD%95%E4%B8%BATopk%EF%BC%9F">何为Topk？</h4> 
<blockquote> 
 <ul><li><strong>TOP-K问题：</strong><span style="color:#956fe7;">N个数里面找出最大/最小的前k个。</span>一般情况下数据量都比较大。</li></ul> 
 <p>比如：专业前10名、世界500强、富豪榜、游戏中前100的活跃玩家等。</p> 
 <p>对于Top-K问题，我们能想到的方法有很多，如下：</p> 
 <ol><li><span style="color:#fe2c24;">排序 </span>-- 时间复杂度：<span style="color:#956fe7;">O(N*logN)</span>。 空间复杂度：<span style="color:#956fe7;">O(1) </span>-- 要求进一步优化。</li><li><span style="color:#fe2c24;">建立N个数的大堆，Pop K次，就可以找出最大的前K个 </span>-- 时间复杂度：<span style="color:#956fe7;">O(N+logN*k)</span>。空间复杂度：<span style="color:#956fe7;">O(1)</span></li></ol> 
 <ul><li><span style="background-color:#fbd4d0;">问题：</span></li></ul> 
 <p><span style="color:#0d0016;">有可能N非常大，以至于远大于K。比如100亿个数里面找出最大的前10个。此时上面的方法就不能用了，因为此时会导致</span><span style="color:#956fe7;">内存不够</span><span style="color:#0d0016;">。就好比我现在想知道100亿个整数需要多少空间？</span></p> 
 <ul><li>1G = 1024MB</li><li>1024MB = 1024*1024KB</li><li>1024*1024KB = 1024*1024*1024Byte ≈ 10亿字节</li><li>一个整数4个字节，100亿个整数400亿个字节，≈40G</li></ul> 
 <p><span style="color:#0d0016;">40个G内存根本放不下，说明100亿个整数是放在磁盘中的，也就是文件中。由此得知上述方法不得行，得寻找一个更优解。</span></p> 
 <ul><li><span style="background-color:#fbd4d0;">解决方案：</span></li></ul> 
 <p><strong><span style="color:#fe2c24;">用前K个数建立一个K个数的小堆，然后剩下的N-K个依次遍历，如果比堆顶的数据大，就替换它进堆</span></strong><span style="color:#fe2c24;">（向下调整）</span><strong><span style="color:#fe2c24;">，最后堆里面的K个数就是最大的K个。</span></strong></p> 
 <p></p> 
 <ul><li><span style="background-color:#fbd4d0;">复杂度：</span></li></ul> 
 <ol><li>时间复杂度：<span style="color:#956fe7;">O(K + logK * (N-K))</span></li><li>空间复杂度：<span style="color:#956fe7;">O(K)</span></li></ol> 
</blockquote> 
<h4 id="%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B">实现过程</h4> 
<blockquote> 
 <p>以从1w个数里找出最大的前10个数为例：</p> 
 <pre><code class="language-cpp">//向下调整算法
void AdjustDown(int* a, size_t size, size_t root)
{
	int parent = (int)root;
	int child = 2 * parent + 1;
	while (child &lt; size)
	{
		//1、确保child的下标对应的值最小，即取左右孩子较小那个
		if (child + 1 &lt; size &amp;&amp; a[child + 1] &lt; a[child]) //得确保右孩子存在
		{
			child++; //此时右孩子大
		}
		//2、如果孩子小于父亲则交换，并继续往下调整
		if (a[child] &lt; a[parent])
		{
			Swap(&amp;a[child], &amp;a[parent]);
			parent = child;
			child = 2 * parent + 1;
		}
		else
		{
			break;
		}
	}
}
void PrintTopK(int* a, int n, int k)
{
	// 1. 建堆--用a中前k个元素建堆
	int* kminHeap = (int*)malloc(sizeof(int) * k);
	assert(kminHeap);
	for (int i = 0; i &lt; k; i++)
	{
		kminHeap[i] = a[i];
	}
	//建小堆
	for (int j = (k - 1 - 1) / 2; j &gt;= 0; j--)
	{
		//从倒数第一个非叶节点开始
		AdjustDown(a, k, j);
	}
	// 2. 将剩余n-k个元素依次与堆顶元素交换，不满则则替换
	for (int i = k; i &lt; n; i++)
	{
		if (a[i] &gt; kminHeap[0])
		{
			kminHeap[0] = a[i]; //如果比堆顶大，就替换
			AdjustDown(kminHeap, k, 0); //向下调整确保为堆
		}
	}
	for (int j = 0; j &lt; k; j++)
	{
		printf("%d ", kminHeap[j]);
	}
	printf("\n");
	free(kminHeap);
}
void TestTopk()
{
	int n = 10000;
	int* a = (int*)malloc(sizeof(int) * n);
	srand(time(0));
	for (size_t i = 0; i &lt; n; ++i)
	{
		a[i] = rand() % 1000000; //产生一个随机数，数值均小于100万
	}
	a[5] = 1000000 + 1;
	a[1231] = 1000000 + 2;
	a[531] = 1000000 + 3;
	a[5121] = 1000000 + 4;
	a[115] = 1000000 + 5;
	a[2335] = 1000000 + 6;
	a[9999] = 1000000 + 7;
	a[76] = 1000000 + 8;
	a[423] = 1000000 + 9;
	a[3144] = 1000000 + 10;
	PrintTopK(a, n, 10);
}

int main()
{
	TestTopk();
	return 0;
}</code></pre> 
 <ul><li><span style="background-color:#fbd4d0;">效果</span><span style="background-color:#fbd4d0;">如下：</span></li></ul> 
 <p><img alt="" height="73" src="https://images2.imgbox.com/da/dd/6Dyc4KeF_o.png" width="850"></p> 
</blockquote>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b2ddb77edf633f4d5cd7ac4be76a381a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Parcel服务报错:regeneratorRuntime is not defined</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c693db15be965a5d79517d534a008fa9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">17.AD域和LDAP协议</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>