<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>浅谈Docker四种网络模式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="浅谈Docker四种网络模式" />
<meta property="og:description" content="一、docker 容器网桥实现原理 Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。
Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接Container-IP访问到容器。
如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即docker run创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器。
二、四类网络模式 host：容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。
Container：创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。
None：该模式关闭了容器的网络功能。
Bridge：此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。
[root@moapp-0003 pg_dockerfile]# docker network ls NETWORK ID NAME DRIVER SCOPE baa06c63cee9 bridge bridge local 6818dc14af4b docker_gwbridge bridge local fbaff9613bbc host host local d6tgeu5nrfrv ingress overlay swarm a7faafcce0dc none null local mdtdf6d41zay test_default overlay swarm 1、host模式 —— 使用--net=host指定
众所周知，Docker使用了Linux的Namespaces技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。一个Network Namespace提供了一份独立的网络环境，包括网卡、路由、Iptable规则等都与其他的Network Namespace隔离。一个Docker容器一般会分配一个独立的Network Namespace。
但是，如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。
容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。
使用host模式的容器可以直接使用宿主机的IP地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行NAT，host最大的优势就是网络性能比较好，但是docker host上已经使用的端口就不能再用了，网络的隔离性不好。
例如，我们在10.10.101.105/24的机器上用host模式启动一个含有web应用的Docker容器，监听tcp80端口。当我们在容器中执行任何类似ifconfig命令查看网络环境时，看到的都是宿主机上的信息。而外界访问容器中的应用，则直接使用10.10.101.105:80即可，不用任何NAT转换，就如直接跑在宿主机中一样。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。
2、container模式 —— 使用--net=container:NAME_or_ID指定" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9324ca47c275bdb1a0557b7a8c25a48a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-08T16:50:58+08:00" />
<meta property="article:modified_time" content="2022-03-08T16:50:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">浅谈Docker四种网络模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>一、docker 容器网桥实现原理</h4> 
<p>　　Docker使用Linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。</p> 
<p>　　Docker网桥是宿主机虚拟出来的，并不是真实存在的网络设备，外部网络是无法寻址到的，这也意味着外部网络无法通过直接Container-IP访问到容器。</p> 
<p>　　如果容器希望外部访问能够访问到，可以通过映射容器端口到宿主主机（端口映射），即docker run创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器。</p> 
<h4>二、四类网络模式</h4> 
<blockquote> 
 <p>host：容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。</p> 
 <p>Container：创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围。</p> 
 <p>None：该模式关闭了容器的网络功能。</p> 
 <p>Bridge：此模式会为每一个容器分配、设置IP等，并将容器连接到一个docker0虚拟网桥，通过docker0网桥以及Iptables nat表配置与宿主机通信。</p> 
</blockquote> 
<pre><code class="language-bash">[root@moapp-0003 pg_dockerfile]# docker network ls
NETWORK ID     NAME              DRIVER    SCOPE
baa06c63cee9   bridge            bridge    local
6818dc14af4b   docker_gwbridge   bridge    local
fbaff9613bbc   host              host      local
d6tgeu5nrfrv   ingress           overlay   swarm
a7faafcce0dc   none              null      local
mdtdf6d41zay   test_default      overlay   swarm</code></pre> 
<p>1、host模式  ——  <strong>使用--net=host指定</strong></p> 
<p>　　众所周知，Docker使用了Linux的Namespaces技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。一个Network Namespace提供了一份独立的网络环境，包括网卡、路由、Iptable规则等都与其他的Network Namespace隔离。一个Docker容器一般会分配一个独立的Network Namespace。</p> 
<p>　　但是，如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。</p> 
<p>　　容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p> 
<p>　　使用host模式的容器可以直接使用宿主机的IP地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行NAT，host最大的优势就是网络性能比较好，但是docker host上已经使用的端口就不能再用了，网络的隔离性不好。</p> 
<p>　　例如，我们在10.10.101.105/24的机器上用host模式启动一个含有web应用的Docker容器，监听tcp80端口。当我们在容器中执行任何类似ifconfig命令查看网络环境时，看到的都是宿主机上的信息。而外界访问容器中的应用，则直接使用10.10.101.105:80即可，不用任何NAT转换，就如直接跑在宿主机中一样。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d9/54/CnLoTS2O_o.png"></p> 
<p>2、container模式  ——  使用--net=container:NAME_or_ID指定</p> 
<p>　　在理解了host模式后，这个模式也就好理解了。这个模式指定新创建的容器和已经存在的一个容器共享一个Network Namespace，而不是和宿主机共享。</p> 
<p>　　新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过lo网卡设备通信。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/90/c8/sbejFf3y_o.png"></p> 
<p>3、none模式  —— <strong> 使用--net=none指定</strong></p> 
<p>　　使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。</p> 
<p>　　这种网络模式下容器只有lo回环网络，没有其他网卡。none模式可以在容器创建时通过--network=none来指定。这种类型的网络没有办法联网，封闭的网络能很好的保证容器的安全性。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/46/79/e313ZYId_o.png"></p> 
<p>4、bridge模式  —— <strong>使用--net=bridge指定，默认设置</strong></p> 
<p>　　当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p> 
<p>　　从docker0子网中分配一个IP给容器使用，并<strong>设置docker0的IP地址为容器的默认网关</strong>。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中(具体见下图)。可以通过<strong>brctl show</strong>命令查看。</p> 
<p><img alt="" height="158" src="https://images2.imgbox.com/84/2d/yeSthWTK_o.png" width="824"></p> 
<p>　　<strong>bridge模式是docker的默认网络模式</strong>，不写--net参数，就是bridge模式。使用docker run -p时，docker实际是在iptables做了DNAT规则，实现端口转发功能。可以使用<strong>iptables -t nat -v -n -L</strong>查看。</p> 
<p><img alt="" height="263" src="https://images2.imgbox.com/d0/19/NkkVFGDo_o.png" width="1088"></p> 
<p>　　bridge模式如下图所示：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/85/e8/YCpRrMgT_o.png"></p> 
<h4>三、bridge 模式具体介绍</h4> 
<p>1、网络拓扑</p> 
<p>　　当Docker server启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p> 
<blockquote> 
 <p>RFC1918协议包含以下私有网络</p> 
 <p>10.0.0.0 - 10.255.255.255 (10/8比特前缀)</p> 
 <p>172.16.0.0 - 172.31.255.255 (172.16/12比特前缀)</p> 
 <p>192.168.0.0 - 192.168.255.255 (192.168/16比特前缀)</p> 
</blockquote> 
<p>　　接下来就要为容器分配IP了，Docker会从<a href="http://tools.ietf.org/html/rfc1918" rel="nofollow" title="RFC1918">RFC1918</a>所定义的私有IP网段中，选择一个和宿主机不同的IP地址和子网分配给docker0，连接到docker0的容器就从这个子网中选择一个未占用的IP使用。如一般Docker会使用172.17.0.0/16这个网段，并将172.17.42.1/16分配给docker0网桥（在主机上使用ifconfig命令是可以看到docker0的，可以认为它是网桥的管理接口，在宿主机上作为一块虚拟网卡使用）。单机环境下的网络拓扑如下，主机地址为10.10.101.105/24。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/64/cb/keforocb_o.png"></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f0/0a/GcYapCHc_o.png"></p> 
<p>　　Docker完成以上网络配置的过程大致是这样的：</p> 
<blockquote> 
 <p>（1）在主机上创建一对虚拟网卡veth pair设备。veth设备总是成对出现的，它们组成了一个数据的通道，数据从一个设备进入，就会从另一个设备出来。因此，veth设备常用来连接两个网络设备。</p> 
 <p>（2）Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0。另一端放在主机中，以veth65f9这样类似的名字命名，并将这个网络设备加入到docker0网桥中，可以通过brctl show命令查看。</p> 
 <p>（3）从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。</p> 
</blockquote> 
<p>2、<strong>bridge模式下容器的通信</strong></p> 
<p>　　在bridge模式下，连在同一网桥上的容器可以相互通信（若出于安全考虑，也可以禁止它们之间通信，方法是在DOCKER_OPTS变量中设置--icc=false，这样只有使用--link才能使两个容器通信）。</p> 
<p>　　容器也可以与外部通信，我们看一下主机上的Iptable规则，可以看到这么一条：-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE</p> 
<p>（直接通过iptables -L -n 命令查看多有iptables）</p> 
<p><img alt="" height="257" src="https://images2.imgbox.com/1d/68/3SjbhUYG_o.png" width="828"></p> 
<p>　　这条规则会将源地址为172.17.0.0/16的包（也就是从Docker容器产生的包），并且不是从docker0网卡发出的，进行源地址转换，转换成主机网卡的地址。这么说可能不太好理解，举一个例子说明一下。假设主机有一块网卡为eth0，IP地址为10.10.101.105/24，网关为10.10.101.254。从主机上一个IP为172.17.0.1/16的容器中ping百度（180.76.3.151）。IP包首先从容器发往自己的默认网关docker0，包到达docker0后，也就到达了主机上。然后会查询主机的路由表，发现包应该从主机的eth0发往主机的网关10.10.105.254/24。接着包会转发给eth0，并从eth0发出去（主机的<strong>ip_forward转发</strong>应该已经打开）。这时候，上面的Iptable规则就会起作用，对包做SNAT转换，将源地址换为eth0的地址。这样，在外界看来，这个包就是从10.10.101.105上发出来的，Docker容器对外是不可见的。</p> 
<blockquote> 
 <p><strong>ip_forward</strong>作用及开启方式</p> 
 <p>出于安全考虑，Linux系统默认是禁止数据包转发的。所谓转发即当主机拥有多于一块的网卡时，其中一块收到数据包，根据数据包的目的ip地址将数据包发往本机另一块网卡，该网卡根据路由表继续发送数据包。这通常是路由器所要实现的功能。</p> 
 <p>要让Linux系统具有路由转发功能，需要配置一个Linux的内核参数<code>net.ipv4.ip_forward</code>。这个参数指定了Linux系统当前对路由转发功能的支持情况；其值为0时表示禁止进行IP转发；如果是1,则说明IP转发功能已经打开。</p> 
 <p><strong>临时生效方式（重启后失效）</strong></p> 
 <p>1.sysctl 命令的 -w 参数可以实时修改Linux的内核参数，并生效。所以使用如下命令可以开发Linux的路由转发功能。</p> 
 <pre><code>sysctl -w net.ipv4.ip_forward=1</code></pre> 
 <p>2.修改内核参数的映射文件：/proc/sys/net/ipv4/ip_forward</p> 
 <pre><code>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code></pre> 
 <p><strong>永久生效方式</strong></p> 
 <p>1.<strong>修改/etc/sysctl.conf 配置文件</strong></p> 
 <p>在sysctl.conf配置文件中有一项名为<code>net.ipv4.ip_forward</code>的配置项，用于配置Linux内核中的<code>net.ipv4.ip_forward</code>参数。其值为0,说明禁止进行IP转发；如果是1,则说明IP转发功能已经打开。</p> 
 <p>需要注意的是，修改sysctl.conf文件后需要执行指令<code>sysctl -p</code> 后新的配置才会生效。</p> 
 <pre><code class="language-bash">vi /etc/sysctl.conf
修改net.ipv4.ip_forward=1
sysctl -p /etc/sysctl.conf</code></pre> 
 <p>2.<strong>修改/etc/sysconfig/network配置文件</strong></p> 
 <p>在文件最后添加一行：<code>FORWARD_IPV4=YES</code></p> 
 <p>需要注意的是，修改/etc/sysconfig/network配置文件后需要重启网络服务(<code>service netwrok restart</code>)才能使新的配置生效。</p> 
 <pre><code class="language-bash">vi /etc/sysconfig/network
末尾追加FORWARD_IPV4=YES
service network restart</code></pre> 
</blockquote> 
<p>　　那么，外面的机器是如何访问Docker容器的服务呢？我们首先用下面命令创建一个含有redis服务的容器，将容器的6379端口映射到主机的7001端口。docker run -d --name web -p 7001:6379 redis</p> 
<p>　　然后查看Iptable规则的变化，发现多了这样一条规则：-A DOCKER ! -i docker0 -p tcp -m tcp --dport 7001 -j DNAT --to-destination 172.17.0.2:6379</p> 
<p>（直接通过iptables -L -n 命令查看多有iptables）</p> 
<p><img alt="" height="180" src="https://images2.imgbox.com/6b/0d/SEgtzo31_o.png" width="953"></p> 
<p>　　此条规则就是对主机eth0收到的目的端口为7001的tcp流量进行DNAT转换，将流量发往172.17.0.2:6379，也就是我们上面创建的Docker容器。所以，外界只需访问192.168.174.129:6379就可以访问到容器中得服务。</p> 
<p>　　除此之外，我们还可以自定义Docker使用的IP地址、DNS等信息，甚至使用自己定义的网桥，但是其工作方式还是一样的。</p> 
<h4>四、Docker-Compose自动创建网桥与局域网冲突处理方案</h4> 
<p>        通过docker-compose.yml 部署应用时，docker 默认的网络模式是bridge ,默认网段是172.17.0.1/16 。在多次执行docker-compose up -d 部署服务后，其自动生成的网桥会依次使用： 172.18.x.x ,172.19.x.x，... 。</p> 
<p>        倘若，主机使用的ip为172.20.x.x，这是docker-compose创建的网桥所使用的ip就会和主机使用ip发生冲突，导致docker服务无法正常通讯。</p> 
<blockquote> 
 <p>解决方案</p> 
 <p>1.部署服务时，采用host网络模式，通过<strong>--net=host</strong>共用主机网络，但是在网络的隔离性方面很差，会占用多个主机端口。因此，在生产环境不推荐使用该方式。</p> 
 <p>2.在docker-compose.yml中指定子网地址，即其会根据该子网地址创建虚拟网桥</p> 
 <p>在docker-compose.yml中添加以下配置，指定其根据172.177.0.0/16子网网段创建网桥</p> 
 <pre><span style="color:#24292f;"><code>networks:
  default:
    ipam:
      config:
        - subnet: 172.177.0.0/16</code></span>但是上述方式需要在每个编配服务配置中添加以上配置，较为繁琐，且存在人为配置子网ip冲突的情况
</pre> 
 <p>3.修改默认地址池default-address-pools，docker和docker-compose会基于该地址池中的子网段创建网桥与容器之间进行通讯（此解决方案只适用于linux系统）</p> 
 <pre><code>vi /etc/docker/daemon.json
添加以下配置
{
  "debug" : true,
  "default-address-pools" : [
    {
      "base" : "172.31.0.0/16",
      "size" : 24
    }
  ]
}</code></pre> 
 <p>配置完成后，docker和docker-compose就会从172.31.0.0/16网段开始顺序创建网桥</p> 
 <p>此解决方案见：<a href="https://github.com/docker/compose/issues/4336" title="https://github.com/docker/compose/issues/4336">https://github.com/docker/compose/issues/4336</a></p> 
</blockquote> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7ce491d356b4c427581fc03d5567dcaa/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于主机Overlay和自研虚拟化网关的VPC在360的落地</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ea7ad9bfb23b2cf2071fd239a5b427e1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">dependencies和devDependencies的区别</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>