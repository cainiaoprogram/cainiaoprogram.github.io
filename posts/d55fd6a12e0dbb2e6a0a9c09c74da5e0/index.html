<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>装饰器的作用，以及给装饰器添加参数 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="装饰器的作用，以及给装饰器添加参数" />
<meta property="og:description" content="一.装饰器的作用
装饰器可用于修改或拓展函数或方法，通常用于在不修改原始函数代码的情况下，添加额外的功能、行为或逻辑。常见用途有：
1.代码复用：装饰器可以定义一些通用的功能，并将其应用于多个函数，从而实现代码的复用。
2.日志记录：用装饰器来记录函数的调用时间、参数和返回值，以便进行调试和性能分析。
3.权限检查：用于检查用户是否有足够的权限进行某个操作，从而进行访问控制。
4.性能优化：装饰器可用于缓存函数的结果，避免重复计算，提高程序性能。
5.异常处理：装饰器可用于捕获函数内部的异常，并进行相应处理。
6.参数验证：用于验证函数的输入参数是否符合预期，从而提高代码的鲁棒性。
7.缓存：装饰器可用于实现缓存机制，将函数的结果缓存起来，提高程序的运行效率。
示例：记录函数的执行时间
import time def time_decorator(func): def wrapper(*args, **kwargs): start_time = time.time() result = func(*args, **kwargs) end_time = time.time() print(f&#34;function {func.__name__} took {end_time - start_time:.4f} seconds to execute.&#34;) return result return wrapper @time_decorator def example_func(): time.sleep(3) #调用被装饰的函数 example_func() 在这里使用语法糖@time_decorator等价于：
def example_func() time.sleep(2) example_func = time_decorator(example_func) example_func() 注意：多个装饰器可以同时用在一个函数上：
@add @square def func(): ... 在这里先调用square，后调用add 二.如何给装饰器传递参数
1.装饰器工厂函数：创建一个装饰器工厂函数，该工厂函数接收参数并返回一个真正的装饰器函数
def decorator_factory(param): def decorator(func): def wrapper(*args, **kwargs): print(f&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d55fd6a12e0dbb2e6a0a9c09c74da5e0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-08T17:13:55+08:00" />
<meta property="article:modified_time" content="2024-01-08T17:13:55+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">装饰器的作用，以及给装饰器添加参数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>一.装饰器的作用</strong></p> 
<p>装饰器可用于修改或拓展函数或方法，通常用于在不修改原始函数代码的情况下，添加额外的功能、行为或逻辑。常见<strong>用途</strong>有：</p> 
<p>1.代码复用：装饰器可以定义一些通用的功能，并将其应用于多个函数，从而实现代码的复用。</p> 
<p>2.日志记录：用装饰器来记录函数的调用时间、参数和返回值，以便进行调试和性能分析。</p> 
<p>3.权限检查：用于检查用户是否有足够的权限进行某个操作，从而进行访问控制。</p> 
<p>4.性能优化：装饰器可用于缓存函数的结果，避免重复计算，提高程序性能。</p> 
<p>5.异常处理：装饰器可用于捕获函数内部的异常，并进行相应处理。</p> 
<p>6.参数验证：用于验证函数的输入参数是否符合预期，从而提高代码的鲁棒性。</p> 
<p>7.缓存：装饰器可用于实现缓存机制，将函数的结果缓存起来，提高程序的运行效率。</p> 
<p></p> 
<p>示例：记录函数的执行时间</p> 
<pre><code>import time

def time_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        print(f"function {func.__name__} took {end_time - start_time:.4f} seconds to execute.")
        return result
    return wrapper

@time_decorator
def example_func():
    time.sleep(3)

#调用被装饰的函数
example_func()</code></pre> 
<p>在这里使用语法糖@time_decorator等价于：</p> 
<pre><code>def example_func()
    time.sleep(2)

example_func = time_decorator(example_func)
example_func()</code></pre> 
<p><strong>注意</strong>：多个装饰器可以同时用在一个函数上：</p> 
<pre><code>@add
@square
def func():
    ...

在这里先调用square，后调用add</code></pre> 
<p>二.如何给装饰器传递参数</p> 
<p>1.<strong>装饰器工厂函数：</strong>创建一个装饰器工厂函数，该工厂函数接收参数并返回一个真正的装饰器函数</p> 
<pre><code class="hljs">def decorator_factory(param):
    def decorator(func):
        def wrapper(*args, **kwargs):
            print(f"Decorator with parameter {param} is applied to {func.__name__}")
            result = func(*args,**kwargs)
            return result
        return wrapper
    return decorator


@decorator_factory(param = "some_value")
def myfunc():
    print("hello")

myfunc()</code></pre> 
<p>2.使用偏函数：使用functools.partial船舰一个偏函数，将函数传递给他，并将其应用于装饰器</p> 
<pre><code class="hljs">from functools import partial

def decorator(param, func):
    def wrapper(*args, **kwargs):
        print("...")
        result = func(*args, **kwargs)
        return result
    return wrapper

myfunc = partial(decorator, param = "some_value")(myfunc)
myfunc()</code></pre> 
<p>3.使用类作为装饰器：定义一个类作为装饰器，该类的“__init__”方法接收参数。”__call__“方法用于实现装饰逻辑。</p> 
<pre><code class="hljs">class Mydecorator:
    def __init__(self, param):
        self.param = param

    def __call__(self, func):
        def wrapper(*args, **kwargs):
            print("hello")
            result(*args, **kwargs)
            return result
        return wrapper

@Mydecorator(param = "some_value")
def myfunc():
    print("hello")

myfunc()
</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/84bc5b8def44b747cdbc032d3c253cff/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">大创项目推荐 深度学习图像风格迁移</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d00bc3854931fe5f0f43b9504373a16c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">920. 最优乘车（sstream使用，最短路）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>