<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>DETR纯代码分享（九）transformer.py - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="DETR纯代码分享（九）transformer.py" />
<meta property="og:description" content="一、定义DETR Transformer用于DETR模型 &#34;&#34;&#34; DETR Transformer class. Copy-paste from torch.nn.Transformer with modifications: * positional encodings are passed in MHattention * extra LN at the end of encoder is removed * decoder returns a stack of activations from all decoding layers &#34;&#34;&#34; import copy from typing import Optional, List import torch import torch.nn.functional as F from torch import nn, Tensor 这段代码是一个用于实现DETR模型中的Transformer类的定义。DETR是一个用于目标检测的神经网络模型，它将目标检测任务转化为一个序列到序列（Sequence-to-Sequence）问题。下面是对这段代码的解释：
DETR Transformer class: 这是一个类的定义，表示DETR模型中的Transformer部分。该类用于实现Transformer的结构和功能。
Copy-paste from torch.nn.Transformer with modifications: 该注释表明该类的定义是从PyTorch的torch.nn.Transformer类进行复制并进行了一些修改。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/42648f561235372d832284e4240821e8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T21:55:59+08:00" />
<meta property="article:modified_time" content="2024-01-05T21:55:59+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">DETR纯代码分享（九）transformer.py</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p class="img-center"><img alt="" height="457" src="https://images2.imgbox.com/ba/0a/eHSBDVm6_o.png" width="464"></p> 
<h4 style="text-align:justify;">一、定义DETR Transformer用于DETR模型</h4> 
<pre><code class="language-python">"""
DETR Transformer class.

Copy-paste from torch.nn.Transformer with modifications:
    * positional encodings are passed in MHattention
    * extra LN at the end of encoder is removed
    * decoder returns a stack of activations from all decoding layers
"""
import copy
from typing import Optional, List

import torch
import torch.nn.functional as F
from torch import nn, Tensor</code></pre> 
<p style="text-align:justify;">这段代码是一个用于实现DETR模型中的Transformer类的定义。DETR是一个用于目标检测的神经网络模型，它将目标检测任务转化为一个序列到序列（Sequence-to-Sequence）问题。下面是对这段代码的解释：</p> 
<ol><li> <p style="text-align:justify;"><code>DETR Transformer class</code>: 这是一个类的定义，表示DETR模型中的Transformer部分。该类用于实现Transformer的结构和功能。</p> </li><li> <p style="text-align:justify;"><code>Copy-paste from torch.nn.Transformer with modifications</code>: 该注释表明该类的定义是从PyTorch的<code>torch.nn.Transformer</code>类进行复制并进行了一些修改。</p> </li><li> <p style="text-align:justify;"><code>positional encodings are passed in MHattention</code>: <strong>在标准的Transformer模型中，位置编码是在Encoder和Decoder之前添加的。<span style="background-color:#a2e043;">然而，在这里的DETR模型中，位置编码是在Multi-Head Attention（MHattention）中传递的，这是一种修改。</span></strong></p> </li><li> <p style="text-align:justify;"><code>extra LN at the end of encoder is removed</code>: 在标准的Transformer中，通常在Encoder的最后添加了一个Layer Normalization（LN）层，但<strong><span style="background-color:#a2e043;">在DETR中，这个额外的LN层已被移除。</span></strong></p> </li><li> <p style="text-align:justify;"><code>decoder returns a stack of activations from all decoding layers</code>: 这表示<strong><span style="background-color:#a2e043;">在DETR的Decoder部分，不仅返回最后一层的输出，还返回了所有解码层的激活（输出）堆栈。</span></strong>这个修改可能有助于在目标检测任务中捕获多尺度特征。</p> </li></ol> 
<p style="text-align:justify;">总之，这段代码定义了DETR模型中的Transformer类，其中包含了一些修改，以适应目标检测任务的需要。它是DETR模型的关键组件之一，用于处理序列到序列的输入数据，从而实现目标检测任务。</p> 
<h4 style="text-align:justify;">二、定义Transformer模型</h4> 
<pre><code class="language-python">class Transformer(nn.Module):

    def __init__(self, d_model=512, nhead=8, num_encoder_layers=6,
                 num_decoder_layers=6, dim_feedforward=2048, dropout=0.1,
                 activation="relu", normalize_before=False,
                 return_intermediate_dec=False):
        super().__init__()

        encoder_layer = TransformerEncoderLayer(d_model, nhead, dim_feedforward,
                                                dropout, activation, normalize_before)
        encoder_norm = nn.LayerNorm(d_model) if normalize_before else None
        self.encoder = TransformerEncoder(encoder_layer, num_encoder_layers, encoder_norm)

        decoder_layer = TransformerDecoderLayer(d_model, nhead, dim_feedforward,
                                                dropout, activation, normalize_before)
        decoder_norm = nn.LayerNorm(d_model)
        self.decoder = TransformerDecoder(decoder_layer, num_decoder_layers, decoder_norm,
                                          return_intermediate=return_intermediate_dec)

        self._reset_parameters()

        self.d_model = d_model
        self.nhead = nhead

    def _reset_parameters(self):
        for p in self.parameters():
            if p.dim() &gt; 1:
                nn.init.xavier_uniform_(p)

    def forward(self, src, mask, query_embed, pos_embed):
        # flatten NxCxHxW to HWxNxC
        bs, c, h, w = src.shape
        src = src.flatten(2).permute(2, 0, 1)
        pos_embed = pos_embed.flatten(2).permute(2, 0, 1)
        query_embed = query_embed.unsqueeze(1).repeat(1, bs, 1)
        mask = mask.flatten(1)

        tgt = torch.zeros_like(query_embed)
        memory = self.encoder(src, src_key_padding_mask=mask, pos=pos_embed)
        hs = self.decoder(tgt, memory, memory_key_padding_mask=mask,
                          pos=pos_embed, query_pos=query_embed)
        return hs.transpose(1, 2), memory.permute(1, 2, 0).view(bs, c, h, w)</code></pre> 
<p style="text-align:justify;">这段代码定义了一个Transformer模型。</p> 
<h5 style="text-align:justify;">1、__init__()</h5> 
<pre><code class="language-python">class Transformer(nn.Module):

    def __init__(self, d_model=512, nhead=8, num_encoder_layers=6,
                 num_decoder_layers=6, dim_feedforward=2048, dropout=0.1,
                 activation="relu", normalize_before=False,
                 return_intermediate_dec=False):
        super().__init__()

        encoder_layer = TransformerEncoderLayer(d_model, nhead, dim_feedforward,
                                                dropout, activation, normalize_before)
        encoder_norm = nn.LayerNorm(d_model) if normalize_before else None
        self.encoder = TransformerEncoder(encoder_layer, num_encoder_layers, encoder_norm)

        decoder_layer = TransformerDecoderLayer(d_model, nhead, dim_feedforward,
                                                dropout, activation, normalize_before)
        decoder_norm = nn.LayerNorm(d_model)
        self.decoder = TransformerDecoder(decoder_layer, num_decoder_layers, decoder_norm,
                                          return_intermediate=return_intermediate_dec)

        self._reset_parameters()

        self.d_model = d_model
        self.nhead = nhead</code></pre> 
<p style="text-align:justify;">这段代码定义了一个自定义的Transformer模型，它包含编码器（Encoder）和解码器（Decoder）部分。以下是每行代码的详细解释：</p> 
<ol><li> <p style="text-align:justify;"><code>def __init__(self, d_model=512, nhead=8, num_encoder_layers=6, num_decoder_layers=6, dim_feedforward=2048, dropout=0.1, activation="relu", normalize_before=False, return_intermediate_dec=False):</code>：这是构造函数，用于初始化Transformer模型的各种参数。</p> 
  <ul><li style="text-align:justify;"><code>d_model</code>：模型的输入和输出特征维度，默认为512。</li><li style="text-align:justify;"><code>nhead</code>：多头自注意力机制中的注意头数，默认为8。</li><li style="text-align:justify;"><code>num_encoder_layers</code>：编码器层数，默认为6。</li><li style="text-align:justify;"><code>num_decoder_layers</code>：解码器层数，默认为6。</li><li style="text-align:justify;"><code>dim_feedforward</code>：前馈神经网络的中间层维度，默认为2048。</li><li style="text-align:justify;"><code>dropout</code>：Dropout概率，默认为0.1。</li><li style="text-align:justify;"><code>activation</code>：激活函数类型，默认为"relu"。</li><li style="text-align:justify;"><strong><code><span style="background-color:#a2e043;">normalize_before</span></code><span style="background-color:#a2e043;">：指定是否在每个子层之前应用层标准化，默认为False。</span></strong></li><li style="text-align:justify;"><strong><code><span style="background-color:#a2e043;">return_intermediate_dec</span></code><span style="background-color:#a2e043;">：指定是否返回解码器的中间层输出，默认为False。</span></strong></li></ul></li><li> <p style="text-align:justify;"><code>encoder_layer</code>：创建了一个Transformer编码器层（<code>TransformerEncoderLayer</code>）的实例，该层包含自注意力机制和前馈神经网络。<strong><span style="background-color:#38d8f0;">具体实现见本文（五、</span><code><span style="background-color:#38d8f0;">TransformerEncoderLayer</span></code><span style="background-color:#38d8f0;">）</span></strong></p> 
  <ul><li style="text-align:justify;"><code>d_model</code>：特征维度。</li><li style="text-align:justify;"><code>nhead</code>：注意头数。</li><li style="text-align:justify;"><code>dim_feedforward</code>：前馈神经网络中间层的维度。</li><li style="text-align:justify;"><code>dropout</code>：Dropout概率。</li><li style="text-align:justify;"><code>activation</code>：激活函数类型。</li><li style="text-align:justify;"><code>normalize_before</code>：是否应用层标准化。</li></ul></li><li> <p style="text-align:justify;"><code>encoder_norm</code>：根据<code>normalize_before</code>参数决定是否创建编码器层的层标准化层（<code>nn.LayerNorm</code>）。</p> </li><li> <p style="text-align:justify;"><code>self.encoder</code>：创建了一个Transformer编码器（<code>TransformerEncoder</code>）的实例，该编码器由多个编码器层组成，这些层在编码输入序列时进行堆叠。</p> 
  <ul><li style="text-align:justify;">参数包括编码器层、层数和编码器层的层标准化层。<strong><span style="background-color:#38d8f0;">具体实现见本文（三、</span><code><span style="background-color:#38d8f0;">TransformerEncoder类</span></code><span style="background-color:#38d8f0;">）</span></strong></li></ul></li><li> <p style="text-align:justify;"><code>decoder_layer</code>：创建了一个Transformer解码器层（<code>TransformerDecoderLayer</code>）的实例，该层包含自注意力机制、编码-解码注意力机制和前馈神经网络。</p> 
  <ul><li style="text-align:justify;">参数与编码器层相似。<strong><span style="background-color:#38d8f0;">具体实现见本文（六、</span><code><span style="background-color:#38d8f0;">TransformerDecoderLayer</span></code><span style="background-color:#38d8f0;">）</span></strong></li></ul></li><li> <p style="text-align:justify;"><code>decoder_norm</code>：创建了解码器层的层标准化层。</p> </li><li> <p style="text-align:justify;"><code>self.decoder</code>：创建了一个Transformer解码器（<code>TransformerDecoder</code>）的实例，该解码器由多个解码器层组成，这些层在解码序列时进行堆叠。</p> 
  <ul><li style="text-align:justify;">参数包括解码器层、层数、解码器层的层标准化层和是否返回解码器的中间层输出。<strong><span style="background-color:#38d8f0;">具体实现见本文（四、</span><code><span style="background-color:#38d8f0;">TransformerDecoder类</span></code><span style="background-color:#38d8f0;">）</span></strong></li></ul></li><li> <p style="text-align:justify;"><code>self._reset_parameters()</code>：初始化模型的参数。<strong><span style="background-color:#fe2c24;">对于权重参数，使用Xavier均匀分布进行初始化。</span></strong></p> </li><li> <p style="text-align:justify;"><code>self.d_model = d_model</code> 和 <code>self.nhead = nhead</code>：保存模型的特征维度和注意头数供后续使用。</p> </li></ol> 
<h5 style="text-align:justify;">2、 <code>_reset_parameters()</code></h5> 
<pre><code class="language-python">    def _reset_parameters(self):
        for p in self.parameters():
            if p.dim() &gt; 1:
                nn.init.xavier_uniform_(p)</code></pre> 
<p style="text-align:justify;">这是<code>Transformer</code>模型类中的一个私有方法 <strong><code>_reset_parameters</code>，用于初始化模型的参数</strong>。具体实现如下：</p> 
<ol><li> <p style="text-align:justify;"><code>for p in self.parameters()</code>：遍历模型的所有参数。</p> </li><li> <p style="text-align:justify;"><code>if p.dim() &gt; 1</code>：检查<strong>参数的维度是否大于1</strong>，<span style="color:#0d0016;"><span style="background-color:#a2e043;">以排除偏置项（维度为1的参数）</span></span>。</p> </li><li> <p style="text-align:justify;"><code>nn.init.xavier_uniform_(p)</code>：对于维度大于1的参数，使用Xavier均匀分布初始化它们的值。<strong>Xavier初始化有助于确保参数的初始值适合深度神经网络的训练，有助于加速收敛和训练的稳定性。这种初始化方法是常用的初始化策略之一。</strong></p> </li></ol> 
<p style="text-align:justify;">总之，<code>_reset_parameters</code> 方法的目的是为了确保模型的参数以适当的方式进行初始化，以便更容易训练和提高模型性能。这有助于模型在训练过程中更快地收敛到合适的解。</p> 
<h5 style="text-align:justify;">3、forward()</h5> 
<pre><code class="language-python">    def forward(self, src, mask, query_embed, pos_embed):
        # flatten NxCxHxW to HWxNxC
        bs, c, h, w = src.shape
        src = src.flatten(2).permute(2, 0, 1)
        pos_embed = pos_embed.flatten(2).permute(2, 0, 1)
        query_embed = query_embed.unsqueeze(1).repeat(1, bs, 1)
        mask = mask.flatten(1)

        tgt = torch.zeros_like(query_embed)
        memory = self.encoder(src, src_key_padding_mask=mask, pos=pos_embed)
        hs = self.decoder(tgt, memory, memory_key_padding_mask=mask,
                          pos=pos_embed, query_pos=query_embed)
        return hs.transpose(1, 2), memory.permute(1, 2, 0).view(bs, c, h, w)</code></pre> 
<p style="text-align:justify;">这是<code>Transformer</code>模型的前向传播方法 <code>forward</code>，该方法实现了Transformer的前向计算过程。以下是每行代码的详细解释：</p> 
<ol><li> <p style="text-align:justify;"><strong><code><span style="background-color:#ffd900;">bs, c, h, w = src.shape</span></code></strong>：获取输入<code>src</code>的形状信息，其中<code>bs</code>是批次大小（batch size），<code>c</code>是通道数（channels），<code>h</code>和<code>w</code>分别是高度和宽度。</p> </li><li> <p style="text-align:justify;"><code>src = <strong><span style="background-color:#ffd900;">src.flatten(2)</span></strong>.permute(2, 0, 1)</code>：首先使用 <code>flatten(2)</code> 操作将输入<code>src</code>从四维张量（NxCxHxW）变换为三维张量（HWxNxC），然后使用 <code>permute(2, 0, 1)</code> 操作重新排列维度，将其变为（序列长度x批次大小x特征维度）的形状。<code>分为两个部分：<strong><span style="background-color:#a2e043;">首先是src.flatten(2)</span></strong></code><strong><span style="background-color:#a2e043;"> 这个操作</span></strong>，其中的参数 <code>2</code> 表示要展平的维度，即在第三维度（即 <code>height</code> 维度）上执行展平操作。效果是将 <code>src</code> 中的每个通道的高度维度展平，<strong>结果是一个形状为 <code>(batch_size, channels, height * width)</code> 的三维张量；</strong><span style="background-color:#a2e043;">然后是</span><code><span style="background-color:#a2e043;">.permute(2, 0, 1)</span>，将</code><strong><code>(batch_size, channels, height * width)变成(h * w，bs, channels)</code></strong></p> </li><li> <p style="text-align:justify;"><code>pos_embed = pos_embed.flatten(2).permute(2, 0, 1)</code>：对位置编码<code>pos_embed</code>执行类似的操作，将其变为与输入相同的形状。<strong><code>(h * w，bs, channels)</code></strong></p> </li><li> <p style="text-align:justify;"><code>query_embed = query_embed.unsqueeze(1).repeat(1, bs, 1)</code>：将<code>query_embed</code>的维度从<strong>（ N,  channels）</strong>扩展为（N, 1, channels），然后使用 <code>repeat(1, bs, 1)</code> 将其复制<code>bs</code>次，以匹配批次大小，使其变为（ N, bs, channels）<span style="background-color:#a2e043;">的形状</span>。<span style="background-color:#38d8f0;"> N是查询数量，d是嵌入维度</span></p> </li><li> <p style="text-align:justify;"><code>mask = mask.flatten(1)</code>：将掩码<code>mask</code>从二维形状（bs, seq_len）展平为一维形状（bs * seq_len），以适应Transformer的输入要求。</p> </li><li> <p style="text-align:justify;"><code>tgt = torch.zeros_like(query_embed)</code>：创建一个与<code>query_embed</code>具有相同形状的全零张量作为目标。<span style="background-color:#a2e043;">（ N, bs, channels）</span></p> </li><li> <p style="text-align:justify;"><code><strong>memory</strong> = self.encoder(src, src_key_padding_mask=mask, pos=pos_embed)</code>：将编码器（<code>self.encoder</code>）应用于输入<code>src</code>，并传递掩码 <code>src_key_padding_mask</code> 以屏蔽填充位置。位置编码 <code>pos_embed</code> 也被传递给编码器。  <strong><span style="background-color:#a2e043;">encoder的输出 </span><code>(h * w，bs, channels)</code></strong></p> </li><li> <p style="text-align:justify;"><code><strong>hs</strong> = self.decoder(tgt, memory, memory_key_padding_mask=mask, pos=pos_embed, query_pos=query_embed)</code>：将解码器（<code>self.decoder</code>）应用于目标 <code>tgt</code> 和编码器的输出 <code>memory</code>，同时传递了掩码 <code>memory_key_padding_mask</code>、位置编码 <code>pos_embed</code> 以及查询位置编码 <code>query_pos</code>。    <strong><span style="background-color:#a2e043;">decoder的输出      </span></strong>（ N, bs, channels）<span style="background-color:#a2e043;">的形状</span></p> </li><li> <p style="text-align:justify;"><code>return hs.transpose(1, 2), memory.permute(1, 2, 0).view(bs, c, h, w)</code>：将解码器的输出 <strong><code>hs</code> 进行维度转置，使其变为（n, channels, bs）</strong>，然后将编码器的输出<strong> <code>memory</code></strong> 进行维度变换，<strong><span style="background-color:#a2e043;">将其形状重新排列为（bs, channels, h, w ）</span></strong>。最后，返回这两个张量作为模型的输出。</p> </li></ol> 
<p style="text-align:justify;">总之，该前向传播方法实现了Transformer模型的完整前向计算过程，包括编码器和解码器的操作。这是一个用于图像分析任务的变种Transformer模型。</p> 
<h4 style="text-align:justify;">三、<code>TransformerEncoder</code>类</h4> 
<pre><code class="language-python">class TransformerEncoder(nn.Module):

    def __init__(self, encoder_layer, num_layers, norm=None):
        super().__init__()
        self.layers = _get_clones(encoder_layer, num_layers)
        self.num_layers = num_layers
        self.norm = norm

    def forward(self, src,
                mask: Optional[Tensor] = None,
                src_key_padding_mask: Optional[Tensor] = None,
                pos: Optional[Tensor] = None):
        output = src

        for layer in self.layers:
            output = layer(output, src_mask=mask,
                           src_key_padding_mask=src_key_padding_mask, pos=pos)

        if self.norm is not None:
            output = self.norm(output)

        return output</code></pre> 
<p style="text-align:justify;">这是<code>TransformerEncoder</code>类的实现，它表示Transformer模型中的编码器部分。总之，<code>TransformerEncoder</code>类实现了Transformer模型的编码器部分，<strong>可以对输入序列进行多层编码处理，并可选地进行归一化处理。</strong></p> 
<h5 style="text-align:justify;">1、<code>__init__()</code></h5> 
<pre><code class="language-python">class TransformerEncoder(nn.Module):

    def __init__(self, encoder_layer, num_layers, norm=None):
        super().__init__()
        self.layers = _get_clones(encoder_layer, num_layers)
        self.num_layers = num_layers
        self.norm = norm</code></pre> 
<p style="text-align:justify;">这段代码定义了<code>TransformerEncoder</code>类的构造函数，用于初始化编码器对象。以下是每行代码的详细解释：</p> 
<ol><li> <p style="text-align:justify;"><code>def __init__(self, encoder_layer, num_layers, norm=None):</code>：这是构造函数的定义，它接受以下参数：</p> 
  <ul><li style="text-align:justify;"><code>encoder_layer</code>：表示单个编码器层的实例，通常是 <code>TransformerEncoderLayer</code> 类的对象。</li><li style="text-align:justify;"><code>num_layers</code>：表示编码器中包含多少个这样的编码器层，即要重复多少次 <code>encoder_layer</code>。</li><li style="text-align:justify;"><code>norm</code>：可选参数，表示是否包含规范化层（Normalization Layer）。</li></ul></li><li> <p style="text-align:justify;"><code>super().__init__()</code>：调用父类的构造函数，确保正确地初始化<code>nn.Module</code>的基本功能。</p> </li><li> <p style="text-align:justify;"><code>self.layers = <strong>_get_clones</strong>(encoder_layer, num_layers)</code>：这行代码创建了一个包含多个编码器层的列表，<strong><span style="background-color:#a2e043;">这些层是通过克隆（复制）给定的</span><code><span style="background-color:#a2e043;">encoder_layer</span></code><span style="background-color:#a2e043;">创建的，克隆的数量由</span><code><span style="background-color:#a2e043;">num_layers</span></code><span style="background-color:#a2e043;">参数指定。这样，</span><code><span style="background-color:#a2e043;">self.layers</span></code><span style="background-color:#a2e043;"> 中存储了多个编码器层的实例，用于构建多层编码器。</span></strong></p> </li><li> <p style="text-align:justify;"><code>self.num_layers = num_layers</code>：存储编码器的层数，以备将来的引用。</p> </li><li> <p style="text-align:justify;"><code>self.norm = norm</code>：存储规范化层（Normalization Layer）的实例。这是一个可选参数，如果提供了规范化层，编码器在每个层之后都会进行规范化操作。</p> </li></ol> 
<p style="text-align:justify;">总之，这段代码初始化了<code>TransformerEncoder</code>类的实例，创建了多个编码器层的列表，存储了编码器的层数和规范化层。这些成员变量将在编码器的前向传播中使用。</p> 
<h5 style="text-align:justify;">2、<code>forward()</code></h5> 
<pre><code class="language-python">    def forward(self, src,
                mask: Optional[Tensor] = None,
                src_key_padding_mask: Optional[Tensor] = None,
                pos: Optional[Tensor] = None):
        output = src

        for layer in self.layers:
            output = layer(output, src_mask=mask,
                           src_key_padding_mask=src_key_padding_mask, pos=pos)

        if self.norm is not None:
            output = self.norm(output)

        return output</code></pre> 
<p style="text-align:justify;">这段代码定义了<code>TransformerEncoder</code>类的前向传播方法<code>forward</code>，该方法实现了编码器的前向计算。以下是每行代码的详细解释：</p> 
<ol><li> <p style="text-align:justify;"><code>def forward(self, src, mask: Optional[Tensor] = None, src_key_padding_mask: Optional[Tensor] = None, pos: Optional[Tensor] = None):</code>：这是前向传播方法的定义，它接受以下参数：</p> 
  <ul><li style="text-align:justify;"><code>src</code>：表示输入序列的张量，即待编码的数据。</li><li style="text-align:justify;"><code>mask</code>：可选参数，表示注意力掩码，用于控制哪些位置的信息被关注，哪些位置被忽略。</li><li style="text-align:justify;"><code>src_key_padding_mask</code>：可选参数，表示<strong>对输入序列的填充位置进行掩码</strong>，以便在计算注意力时忽略这些位置的信息。</li><li style="text-align:justify;"><code>pos</code>：可选参数，表示位置编码，用于引入序列元素的位置信息。</li></ul></li><li> <p style="text-align:justify;"><code>output = src</code>：将输入张量<code>src</code>赋值给<code>output</code>，这是初始的输出。</p> </li><li> <p style="text-align:justify;"><code>for layer in self.layers:</code>：这是一个循环，用于迭代遍历多个编码器层。</p> </li><li> <p style="text-align:justify;"><code>output = layer(<span style="color:#fe2c24;">output, src_mask=mask, src_key_padding_mask=src_key_padding_mask, pos=pos</span>)</code>：在每个循环迭代中，将当前的<code>output</code>作为输入传递给编码器层<code>layer</code>，并同时传递掩码信息<code>mask</code>、填充位置掩码信息<code>src_key_padding_mask</code>以及位置编码<code>pos</code>。编码器层将执行自注意力机制和前馈神经网络等操作，然后更新<code>output</code>以包含更丰富的编码信息。</p> </li><li> <p style="text-align:justify;"><code>if self.norm is not None:</code>：检查是否存在规范化层。</p> </li><li> <p style="text-align:justify;"><code>output = self.norm(output)</code>：如果存在规范化层，对最终的<code>output</code>进行规范化操作，以确保输出的数值稳定性和可训练性。</p> </li><li> <p style="text-align:justify;"><code>return output</code>：返回最终的编码结果作为输出。这个输出包含了输入序列的编码表示，已经通过多个编码器层的处理。</p> </li></ol> 
<p style="text-align:justify;">总之，这段代码实现了编码器的前向传播过程，通过多个编码器层对输入数据进行编码，并返回编码后的表示作为输出。每个编码器层都接受输入、注意力掩码、填充位置掩码和位置编码，然后更新输出。最终，如果存在规范化层，还会对输出进行规范化处理。</p> 
<h4 style="text-align:justify;">四、<code>TransformerDecoder</code>类</h4> 
<pre><code class="language-python">class TransformerDecoder(nn.Module):

    def __init__(self, decoder_layer, num_layers, norm=None, return_intermediate=False):
        super().__init__()
        self.layers = _get_clones(decoder_layer, num_layers)
        self.num_layers = num_layers
        self.norm = norm
        self.return_intermediate = return_intermediate

    def forward(self, tgt, memory,
                tgt_mask: Optional[Tensor] = None,
                memory_mask: Optional[Tensor] = None,
                tgt_key_padding_mask: Optional[Tensor] = None,
                memory_key_padding_mask: Optional[Tensor] = None,
                pos: Optional[Tensor] = None,
                query_pos: Optional[Tensor] = None):
        output = tgt

        intermediate = []

        for layer in self.layers:
            output = layer(output, memory, tgt_mask=tgt_mask,
                           memory_mask=memory_mask,
                           tgt_key_padding_mask=tgt_key_padding_mask,
                           memory_key_padding_mask=memory_key_padding_mask,
                           pos=pos, query_pos=query_pos)
            if self.return_intermediate:
                intermediate.append(self.norm(output))

        if self.norm is not None:
            output = self.norm(output)
            if self.return_intermediate:
                intermediate.pop()
                intermediate.append(output)

        if self.return_intermediate:
            return torch.stack(intermediate)

        return output.unsqueeze(0)</code></pre> 
<p style="text-align:justify;">这段代码定义了<code>TransformerDecoder</code>类，它表示Transformer的解码器部分。</p> 
<h5 style="text-align:justify;">1、<code>__init__()</code></h5> 
<pre><code class="language-python">class TransformerDecoder(nn.Module):

    def __init__(self, decoder_layer, num_layers, norm=None, return_intermediate=False):
        super().__init__()
        self.layers = _get_clones(decoder_layer, num_layers)
        self.num_layers = num_layers
        self.norm = norm
        self.return_intermediate = return_intermediate</code></pre> 
<p style="text-align:justify;">这是<code>TransformerDecoder</code>类的初始化方法，用于创建一个Transformer解码器的实例。以下是每行代码的详细解释：</p> 
<ol><li> <p style="text-align:justify;"><code>def __init__(self, decoder_layer, num_layers, norm=None, return_intermediate=False):</code>：初始化方法定义，接受以下参数：</p> 
  <ul><li style="text-align:justify;"><code>decoder_layer</code>：表示解码器层的类型，通常是<code>TransformerDecoderLayer</code>。</li><li style="text-align:justify;"><code>num_layers</code>：表示解码器中要堆叠的解码器层数。</li><li style="text-align:justify;"><code>norm</code>：可选参数，表示规范化层。</li><li style="text-align:justify;"><code><span style="background-color:#a2e043;">return_intermediate</span></code><span style="background-color:#a2e043;">：可选参数，表示是否返回中间层的输出</span>。</li></ul></li><li> <p style="text-align:justify;"><code>super().__init__()</code>：调用父类的构造函数，即<code>nn.Module</code>的构造函数，以确保正确初始化该类的基类部分。</p> </li><li> <p style="text-align:justify;"><code>self.layers = _get_clones(decoder_layer, num_layers)</code>：创建了一个包含多个解码器层的列表，这些层是由<code>decoder_layer</code>复制而来的，共有<code>num_layers</code>个。这样，可以堆叠多个解码器层以增加解码器的深度。</p> </li><li> <p style="text-align:justify;"><code>self.num_layers = num_layers</code>：记录解码器中的层数。</p> </li><li> <p style="text-align:justify;"><code>self.norm = norm</code>：存储规范化层。规范化层用于调整解码器层的输出，以确保输出的数值稳定性和可训练性。</p> </li><li> <p style="text-align:justify;"><code>self.return_intermediate = return_intermediate</code>：记录是否返回中间层的输出。如果设置为True，则在每个解码器层之后会保留中间层的输出，否则只返回最终解码器层的输出。</p> </li></ol> 
<p style="text-align:justify;">总之，这个初始化方法用于配置解码器的结构，包括解码器层的堆叠、规范化层的设置以及是否返回中间层的输出。</p> 
<h5 style="text-align:justify;">2、<code>forward()</code></h5> 
<pre><code class="language-python">    def forward(self, tgt, memory,
                tgt_mask: Optional[Tensor] = None,
                memory_mask: Optional[Tensor] = None,
                tgt_key_padding_mask: Optional[Tensor] = None,
                memory_key_padding_mask: Optional[Tensor] = None,
                pos: Optional[Tensor] = None,
                query_pos: Optional[Tensor] = None):
        output = tgt

        intermediate = []</code></pre> 
<p style="text-align:justify;">这是<code>TransformerDecoder</code>类的前向传播方法，用于处理输入并生成解码器的输出。以下是每行代码的详细解释：</p> 
<ol><li> <p style="text-align:justify;"><code>def forward(self, tgt, memory, tgt_mask: Optional[Tensor] = None, memory_mask: Optional[Tensor] = None, tgt_key_padding_mask: Optional[Tensor] = None, memory_key_padding_mask: Optional[Tensor] = None, pos: Optional[Tensor] = None, query_pos: Optional[Tensor] = None):</code>：前向传播方法的定义，接受多个参数，用于指定输入和各种掩码。</p> </li><li> <p style="text-align:justify;"><code>output = tgt</code>：将输入<code>tgt</code>赋值给<code>output</code>，这里的<code>tgt</code>通常表示目标序列（target sequence）。</p> </li><li> <p style="text-align:justify;"><code>intermediate = []</code>：<strong>创建一个空列表<code>intermediate</code>，用于存储中间层的输出</strong>。这个列表将用于保存每个解码器层的中间层输出，如果<code>self.return_intermediate</code>为True。</p> </li></ol> 
<p style="text-align:justify;">总之，前向传播方法将输入目标序列<code>tgt</code>与记忆序列<code>memory</code>一起传递给解码器的层。在每个解码器层中，它执行解码操作，并根据需要应用掩码。如果<code>self.return_intermediate</code>为True，则还会保存每个解码器层的中间输出到<code>intermediate</code>列表中。最后，输出结果将是解码器的最终输出或中间输出的堆叠，具体取决于是否需要返回中间层输出。</p> 
<h5 style="text-align:justify;">3、循环遍历解码器的多个层</h5> 
<pre><code class="language-python">        for layer in self.layers:
            output = layer(output, memory, tgt_mask=tgt_mask,
                           memory_mask=memory_mask,
                           tgt_key_padding_mask=tgt_key_padding_mask,
                           memory_key_padding_mask=memory_key_padding_mask,
                           pos=pos, query_pos=query_pos)
            if self.return_intermediate:
                intermediate.append(self.norm(output))</code></pre> 
<p style="text-align:justify;">这部分代码是循环遍历解码器的多个层，遍历了解码器中的每个层（layer）。在Transformer模型中，通常会有多个相同结构的解码器层，每个层都独立处理输入数据。</p> 
<ol><li> <p style="text-align:justify;"><code>for layer in self.layers:</code>：通过遍历<code>self.layers</code>中的每个解码器层</p> </li><li> <p style="text-align:justify;"><code>output = layer(<span style="color:#fe2c24;"><span style="background-color:#a2e043;">output</span>, memory, <span style="background-color:#a2e043;">tgt_mask=tgt_mask</span>, memory_mask=memory_mask, <span style="background-color:#a2e043;">tgt_key_padding_mask=tgt_key_padding_mask,</span> memory_key_padding_mask=memory_key_padding_mask, <span style="background-color:#a2e043;">pos=pos</span>, query_pos=query_pos</span>)</code>：对当前解码器层(<code>layer</code>)进行前向传播。这里传递了多个参数：（1）<code>memory</code>：通常是编码器的输出，用于与解码器进行注意力计算。（2）<code>tgt_mask</code> 和 <code>memory_mask</code>：用于在自注意力机制中屏蔽（mask）某些位置，以防止模型关注到这些位置。（3）<code>tgt_key_padding_mask</code> 和 <code>memory_key_padding_mask</code>：用于指示哪些位置是填充（padding）的，不应该参与注意力计算。<code>pos</code> 和 <code>query_pos</code>：位置编码信息。</p> </li><li> <p style="text-align:justify;"><code>if self.return_intermediate:</code>：检查是否需要返回中间层的输出，即<code>self.return_intermediate</code>是否为True。</p> </li><li> <p style="text-align:justify;"><strong><code><span style="background-color:#38d8f0;">intermediate.append(self.norm(output))</span></code></strong>：如果 <code>self.return_intermediate</code> 为True，并且解码器层的输出需要被标准化（归一化），则将当前层的输出 <code>output</code> 经过标准化后添加到 <code>intermediate</code> 列表中。<strong><span style="background-color:#a2e043;">这将保留每个解码器层的中间输出。</span></strong></p> </li></ol> 
<h5 style="text-align:justify;">4、norm及<code>intermediate</code></h5> 
<pre><code class="language-python">        if self.norm is not None:
            output = self.norm(output)
            if self.return_intermediate:
                intermediate.pop()
                intermediate.append(output)

        if self.return_intermediate:
            return torch.stack(intermediate)

        return output.unsqueeze(0)</code></pre> 
<p style="text-align:justify;">这是另一个条件语句，检查是否设置了 <code>self.norm</code>。</p> 
<ol><li> <p style="text-align:justify;"><code>if self.norm is not None</code>：检查是否存在标准化层。如果<code>self.norm</code>不为None，表示需要对输出进行标准化。</p> </li><li> <p style="text-align:justify;"><code>output = self.norm(output)</code>：<code>self.norm</code> 通常是解码器层后的正规化（归一化）层，<strong><span style="background-color:#a2e043;">用于归一化<span style="color:#fe2c24;">整个解码器</span>的输出。</span></strong></p> </li><li> <p style="text-align:justify;"><code>if self.return_intermediate</code>：再次检查是否需要返回中间层的输出。</p> </li><li> <p style="text-align:justify;"><code>intermediate.<strong>pop()</strong></code>：如果需要返回中间层的输出，这里会从<code>intermediate</code>列表中<strong>移除最后一个元素</strong>，因为我们已经在前面的代码行中将当前的标准化后的输出添加到了<code>intermediate</code>中。</p> </li><li> <p style="text-align:justify;"><code>intermediate.append(output)</code>：将标准化后的输出<strong>再次添加到<code>intermediate</code>列表中，以确保最终列表中包含的是标准化后的输出。</strong></p> </li><li> <p style="text-align:justify;"><code>if self.return_intermediate</code>：再次检查是否需要返回中间层的输出。</p> </li><li> <p style="text-align:justify;"><code>return torch.stack(intermediate)</code>：则返回每个解码器层的中间输出的堆叠。这将返回一个形状为<strong><code><span style="background-color:#38d8f0;">(num_layers, batch_size, sequence_length, d_model)</span></code><span style="background-color:#38d8f0;">的张量</span></strong>，其中<code>num_layers</code>是解码器层数。这是为了在训练过程中分析每个层的输出。每个中间输出都包含了解码器处理输入数据的某一阶段的信息。</p> </li><li> <p style="text-align:justify;"><code>return output.unsqueeze(0)</code>：如果 <code>self.return_intermediate</code> 为False，表示<strong><span style="color:#fe2c24;"><span style="background-color:#a2e043;">只返回最后一个解码器层的输出。</span></span></strong>解码器的最终输出被添加一个额外的维度以满足形状要求。这里使用<code>unsqueeze(0)</code>将输出的维度<strong><span style="background-color:#38d8f0;">从</span><code><span style="background-color:#38d8f0;">(batch_size, sequence_length, d_model)</span></code><span style="background-color:#38d8f0;">扩展为</span><code><span style="background-color:#38d8f0;">(1, batch_size, sequence_length, d_model)</span></code></strong>，以符合模型的预期输出形状。</p> </li></ol> 
<h4 style="text-align:justify;">五、<code>TransformerEncoderLayer</code></h4> 
<pre><code class="language-python">class TransformerEncoderLayer(nn.Module):

    def __init__(self, d_model, nhead, dim_feedforward=2048, dropout=0.1,
                 activation="relu", normalize_before=False):
        super().__init__()
        self.self_attn = nn.MultiheadAttention(d_model, nhead, dropout=dropout)
        # Implementation of Feedforward model
        self.linear1 = nn.Linear(d_model, dim_feedforward)
        self.dropout = nn.Dropout(dropout)
        self.linear2 = nn.Linear(dim_feedforward, d_model)

        self.norm1 = nn.LayerNorm(d_model)
        self.norm2 = nn.LayerNorm(d_model)
        self.dropout1 = nn.Dropout(dropout)
        self.dropout2 = nn.Dropout(dropout)

        self.activation = _get_activation_fn(activation)
        self.normalize_before = normalize_before

    def with_pos_embed(self, tensor, pos: Optional[Tensor]):
        return tensor if pos is None else tensor + pos

    def forward_post(self,
                     src,
                     src_mask: Optional[Tensor] = None,
                     src_key_padding_mask: Optional[Tensor] = None,
                     pos: Optional[Tensor] = None):
        q = k = self.with_pos_embed(src, pos)
        src2 = self.self_attn(q, k, value=src, attn_mask=src_mask,
                              key_padding_mask=src_key_padding_mask)[0]
        src = src + self.dropout1(src2)
        src = self.norm1(src)
        src2 = self.linear2(self.dropout(self.activation(self.linear1(src))))
        src = src + self.dropout2(src2)
        src = self.norm2(src)
        return src

    def forward_pre(self, src,
                    src_mask: Optional[Tensor] = None,
                    src_key_padding_mask: Optional[Tensor] = None,
                    pos: Optional[Tensor] = None):
        src2 = self.norm1(src)
        q = k = self.with_pos_embed(src2, pos)
        src2 = self.self_attn(q, k, value=src2, attn_mask=src_mask,
                              key_padding_mask=src_key_padding_mask)[0]
        src = src + self.dropout1(src2)
        src2 = self.norm2(src)
        src2 = self.linear2(self.dropout(self.activation(self.linear1(src2))))
        src = src + self.dropout2(src2)
        return src

    def forward(self, src,
                src_mask: Optional[Tensor] = None,
                src_key_padding_mask: Optional[Tensor] = None,
                pos: Optional[Tensor] = None):
        if self.normalize_before:
            return self.forward_pre(src, src_mask, src_key_padding_mask, pos)
        return self.forward_post(src, src_mask, src_key_padding_mask, pos)</code></pre> 
<p style="text-align:justify;">这是Transformer编码器层的代码。</p> 
<h5 style="text-align:justify;">1、<code>__init__()</code></h5> 
<pre><code class="language-python">class TransformerEncoderLayer(nn.Module):

    def __init__(self, d_model, nhead, dim_feedforward=2048, dropout=0.1,
                 activation="relu", normalize_before=False):
        super().__init__()
        self.self_attn = nn.MultiheadAttention(d_model, nhead, dropout=dropout)
        # Implementation of Feedforward model
        self.linear1 = nn.Linear(d_model, dim_feedforward)
        self.dropout = nn.Dropout(dropout)
        self.linear2 = nn.Linear(dim_feedforward, d_model)

        self.norm1 = nn.LayerNorm(d_model)
        self.norm2 = nn.LayerNorm(d_model)
        self.dropout1 = nn.Dropout(dropout)
        self.dropout2 = nn.Dropout(dropout)

        self.activation = _get_activation_fn(activation)
        self.normalize_before = normalize_before</code></pre> 
<p style="text-align:justify;">这是Transformer编码器层的初始化方法，它设置了该层的各个组件和参数。</p> 
<ol><li> <p style="text-align:justify;"><code>super().__init__()</code>：调用父类（nn.Module）的初始化方法。</p> </li><li> <p style="text-align:justify;"><code>self.self_attn = nn.<strong><span style="background-color:#a2e043;">MultiheadAttention</span></strong>(d_model, nhead, dropout=dropout)</code>：创建了<strong>一个多头自注意力机制层</strong>。这一层将输入的特征进行自注意力计算。</p> </li><li> <p style="text-align:justify;"><code>self.<span style="background-color:#ffd900;">linear1</span> = nn.Linear(<span style="background-color:#ffd900;">d_model, dim_feedforward</span>)</code>：创建了一个线性变换层，用于将输入特征映射到一个中间维度（dim_feedforward）的空间。</p> </li><li> <p style="text-align:justify;"><code>self.dropout = nn.Dropout(dropout)</code>：创建了一个Dropout层，用于在训练过程中进行随机失活以防止过拟合。</p> </li><li> <p style="text-align:justify;"><code>self.<span style="background-color:#ffd900;">linear2</span> = nn.Linear(<span style="background-color:#ffd900;">dim_feedforward, d_model</span>)</code>：创建了另一个线性变换层，将中间维度的特征映射回原始维度（d_model）。</p> </li><li> <p style="text-align:justify;"><code>self.norm1 = nn.LayerNorm(d_model)</code> 和 <code>self.norm2 = nn.LayerNorm(d_model)</code>：分别创建了两个层归一化层，用于归一化输入特征。</p> </li><li> <p style="text-align:justify;"><code>self.dropout1 = nn.Dropout(dropout)</code> 和 <code>self.dropout2 = nn.Dropout(dropout)</code>：创建了两个<strong><span style="background-color:#a2e043;">Dropout层，用于在自注意力和前馈神经网络之间的层之间进行随机失活。</span></strong></p> </li><li> <p style="text-align:justify;"><code>self.activation = _get_activation_fn(activation)</code>：根据指定的激活函数类型创建了激活函数。</p> </li><li> <p style="text-align:justify;"><code>self.normalize_before = normalize_before</code>：记录是否在自注意力和前馈神经网络之前应用层归一化。这是一个布尔值。</p> </li></ol> 
<p style="text-align:justify;">这个初始化方法设置了Transformer编码器层的各个组件，用于处理输入特征。根据 <code>normalize_before</code> 参数的不同设置，它可以选择在不同的位置应用层归一化。</p> 
<h5 style="text-align:justify;">2、<code>with_pos_embed（）</code></h5> 
<pre><code class="language-python">    def with_pos_embed(self, tensor, pos: Optional[Tensor]):
        return tensor if pos is None else tensor + pos</code></pre> 
<p style="text-align:justify;">这是Transformer编码器层中的一个辅助函数，<strong>用于将位置编码（pos）与输入特征张量（tensor）相加（如果pos不为None的话），以考虑位置信息。</strong><strong><span style="background-color:#38d8f0;">在（七）backbone.py中，经过Joiner()类得到的</span></strong>，features和pos还是分离的，在这把它们相加在一起。</p> 
<ul><li> <p style="text-align:justify;"><code>def with_pos_embed(self, tensor, pos: Optional[Tensor]):</code>：这是一个方法定义，它接受两个参数，<code>tensor</code> 和 <code>pos</code>。<code>tensor</code> 是输入特征张量，<code>pos</code> 是位置编码张量，它们可以是可选的张量对象（<code>Optional[Tensor]</code> 表示参数可以是张量，也可以是None）。</p> </li><li> <p style="text-align:justify;"><code>return tensor if pos is None else tensor + pos</code>：这行代码实现了函数的逻辑。它首先检查 <code>pos</code> 是否为None。如果 <code>pos</code> 为None，就返回输入的 <code>tensor</code>，表示不考虑位置编码。如果 <code>pos</code> 不为None，就执行 <code>tensor + pos</code> 的操作，将位置编码与输入特征相加，以获得包含位置信息的特征张量。</p> </li></ul> 
<p style="text-align:justify;">这个函数的作用是将位置编码与输入特征相结合，以考虑对象在序列中的位置。这在自注意力机制中特别有用，因为它帮助模型更好地理解输入序列中的元素之间的相对位置关系。这是Transformer模型中用于处理序列数据的重要组成部分。</p> 
<p style="text-align:justify;">左边为forward_pre()，右边为forward_post()</p> 
<p style="text-align:justify;"><img alt="" height="399" src="https://images2.imgbox.com/ac/69/DUbyyjDx_o.png" width="997"></p> 
<h5 style="text-align:justify;">3、 <code>forward_post（）</code></h5> 
<pre><code class="language-python">    def forward_post(self,
                     src,
                     src_mask: Optional[Tensor] = None,
                     src_key_padding_mask: Optional[Tensor] = None,
                     pos: Optional[Tensor] = None):
        q = k = self.with_pos_embed(src, pos)
        src2 = self.self_attn(q, k, value=src, attn_mask=src_mask,
                              key_padding_mask=src_key_padding_mask)[0]
        src = src + self.dropout1(src2)
        src = self.norm1(src)
        src2 = self.linear2(self.dropout(self.activation(self.linear1(src))))
        src = src + self.dropout2(src2)
        src = self.norm2(src)
        return src</code></pre> 
<p style="text-align:justify;"><strong><span style="background-color:#a2e043;">先注意力再norm</span></strong></p> 
<p style="text-align:justify;">这段代码是Transformer编码器层中的前向传播方法 <code>forward_post</code> 的实现，用于处理输入序列。</p> 
<p style="text-align:justify;">每个操作后的形状都应该与输入数据 <code>src</code> 的形状相同，这有助于确保模型在每个处理阶段保持相同的数据形状，以便进行后续的计算和处理</p> 
<ul><li> <p style="text-align:justify;"><code>def forward_post(self, src, src_mask: Optional[Tensor] = None, src_key_padding_mask: Optional[Tensor] = None, pos: Optional[Tensor] = None)</code>：这是一个方法定义，它接受四个参数，分别是 <code>src</code>、<code>src_mask</code>、<code>src_key_padding_mask</code> 和 <code>pos</code>。<strong><span style="background-color:#c7e6ea;">（1）</span><code><span style="background-color:#c7e6ea;">src</span></code><span style="background-color:#c7e6ea;"> 是输入特征张量，（2）</span><code><span style="background-color:#c7e6ea;">src_mask</span></code><span style="background-color:#c7e6ea;"> 是用于自注意力机制的掩码（可选），（3）</span><code><span style="background-color:#c7e6ea;">src_key_padding_mask</span></code><span style="background-color:#c7e6ea;"> 是用于屏蔽填充位置的掩码（可选），（4）</span><code><span style="background-color:#c7e6ea;">pos</span></code><span style="background-color:#c7e6ea;"> 是位置编码张量（可选）。</span></strong></p> </li><li> <p style="text-align:justify;"><code>q = k = self.with_pos_embed(src, pos)</code>：这行代码使用 <code>with_pos_embed</code> 方法将位置编码 <code>pos</code> 添加到输入特征 <code>src</code> 中，生成查询（q）和键（k）。 </p> </li><li> <p style="text-align:justify;"><code>src2 = self.self_attn(q, k, value=src, attn_mask=src_mask, key_padding_mask=src_key_padding_mask)[0]</code>：这行代码执行自注意力机制操作。它使用查询（q）和键（k）计算注意力分布，并将该分布应用于值（value）张量 <code>src</code>。<code>attn_mask</code> 用于屏蔽不需要考虑的位置，<code>key_padding_mask</code> 用于屏蔽填充位置。<strong>注意力机制的输出被解包为元组，并且我们只取第一个元素，即注意力加权的结果。</strong><span style="background-color:#a2e043;">（</span><code><span style="background-color:#a2e043;">src</span></code><span style="background-color:#a2e043;"> 的每个位置现在包含了该位置与整个输入序列中其他位置的相关性的信息。）</span></p> </li></ul> 
<ul><li> <p style="text-align:justify;"><code>q</code>：查询（query）向量，通常表示当前位置的信息。<code>k</code>：键（key）向量，用于计算注意力权重。</p> </li><li> <p style="text-align:justify;"><code>value=src</code>：值（value）向量，包含了整个输入序列的信息。</p> </li><li> <p style="text-align:justify;"><code>attn_mask=src_mask</code>：用于屏蔽（mask）注意力的掩码，通常用于防止模型关注特定位置。</p> </li><li> <p style="text-align:justify;"><code>key_padding_mask=src_key_padding_mask</code>：用于遮蔽注意力中的键（key）的掩码，通常用于指示哪些位置是填充（padding）的。</p> </li><li> <p>自注意力操作计算了注意力权重，并将这些权重应用于值 <code>src</code> 上，得到了经过自注意力操作的输出 <code>src2</code>。<code>src2</code> 包含了加权的信息，其中每个位置都受到其他位置的注意力影响。</p> </li></ul> 
<ul><li> <p style="text-align:justify;"><code>src = src + self.dropout1(src2)</code>：这行代码将注意力加权的结果与输入特征张量相加，以便引入注意力信息。<code>self.dropout1</code> 是一个丢弃层，用于防止过拟合。</p> </li><li> <p style="text-align:justify;"><code>src = self.norm1(src)</code>：这行代码执行第一个层归一化操作，将特征张量 <code>src</code> 进行标准化，以便加速训练。</p> </li><li> <p style="text-align:justify;"><code>src2 = self.linear2(self.dropout(self.activation(self.linear1(src))))</code>：这行代码执行前馈神经网络（Feedforward Network）操作，对特征张量进行非线性变换。具体来说，它首先应用线性变换 <code>self.linear1</code>，然后使用激活函数 <code>self.activation</code> 进行非线性映射，最后应用线性变换 <code>self.linear2</code>。</p> </li><li> <p style="text-align:justify;"><code>src = src + self.dropout2(src2)</code>：这行代码将前馈神经网络的输出与输入特征张量相加，以引入更多的非线性变换。<code>self.dropout2</code> 是另一个丢弃层，用于防止过拟合。</p> </li><li> <p style="text-align:justify;"><code>src = self.norm2(src)</code>：这行代码执行第二个层归一化操作，将特征张量 <code>src</code> 进行标准化。</p> </li><li> <p style="text-align:justify;"><code>return src</code>：最后，该方法返回处理后的特征张量 <code>src</code> 作为输出。</p> </li></ul> 
<p style="text-align:justify;">总之，这个方法实现了Transformer编码器层的前向传播，包括自注意力机制和前馈神经网络操作，以便对输入序列进行特征提取和表示学习。</p> 
<h5 style="text-align:justify;">4、<code>forward_pre()</code></h5> 
<p><strong><span style="background-color:#a2e043;">先norm再注意力</span></strong></p> 
<pre><code class="language-python">    def forward_pre(self, src,
                    src_mask: Optional[Tensor] = None,
                    src_key_padding_mask: Optional[Tensor] = None,
                    pos: Optional[Tensor] = None):
        src2 = self.norm1(src)
        q = k = self.with_pos_embed(src2, pos)
        src2 = self.self_attn(q, k, value=src2, attn_mask=src_mask,
                              key_padding_mask=src_key_padding_mask)[0]
        src = src + self.dropout1(src2)
        src2 = self.norm2(src)
        src2 = self.linear2(self.dropout(self.activation(self.linear1(src2))))
        src = src + self.dropout2(src2)
        return src</code></pre> 
<p style="text-align:justify;">这段代码是Transformer编码器层中的前向传播方法 <code>forward_pre</code> 的实现，用于处理输入序列。</p> 
<ul><li> <p style="text-align:justify;"><code>def forward_pre(self, src, src_mask: Optional[Tensor] = None, src_key_padding_mask: Optional[Tensor] = None, pos: Optional[Tensor] = None):</code>：这是一个方法定义，它接受四个参数，分别是 <code>src</code>、<code>src_mask</code>、<code>src_key_padding_mask</code> 和 <code>pos</code>。<code>src</code> 是输入特征张量，<code>src_mask</code> 是用于自注意力机制的掩码（可选），<code>src_key_padding_mask</code> 是用于屏蔽填充位置的掩码（可选），<code>pos</code> 是位置编码张量（可选）。</p> </li><li> <p style="text-align:justify;"><code>src2 = self.norm1(src)</code>：这行代码执行第一个层归一化操作，将特征张量 <code>src</code> 进行标准化，以便加速训练。这是在自注意力之前执行的。</p> </li><li> <p style="text-align:justify;"><code>q = k = self.with_pos_embed(src2, pos)</code>：这行代码使用 <code>with_pos_embed</code> 方法将位置编码 <code>pos</code> 添加到输入特征 <code>src2</code> 中，生成查询（q）和键（k）。</p> </li><li> <p style="text-align:justify;"><code>src2 = self.self_attn(q, k, value=src2, attn_mask=src_mask, key_padding_mask=src_key_padding_mask)[0]</code>：这行代码执行自注意力机制操作。它使用查询（q）和键（k）计算注意力分布，并将该分布应用于值（value）张量 <code>src2</code>。<code>attn_mask</code> 用于屏蔽不需要考虑的位置，<code>key_padding_mask</code> 用于屏蔽填充位置。注意力机制的输出被解包为元组，并且我们只取第一个元素，即注意力加权的结果。</p> </li><li> <p style="text-align:justify;"><code>src = src + self.dropout1(src2)</code>：这行代码将注意力加权的结果与输入特征张量相加，以便引入注意力信息。<code>self.dropout1</code> 是一个丢弃层，用于防止过拟合。</p> </li><li> <p style="text-align:justify;"><code>src2 = self.norm2(src)</code>：这行代码执行第二个层归一化操作，将特征张量 <code>src</code> 进行标准化。</p> </li><li> <p style="text-align:justify;"><code>src2 = self.linear2(self.dropout(self.activation(self.linear1(src2))))</code>：这行代码执行前馈神经网络（Feedforward Network）操作，对特征张量进行非线性变换。具体来说，它首先应用线性变换 <code>self.linear1</code>，然后使用激活函数 <code>self.activation</code> 进行非线性映射，最后应用线性变换 <code>self.linear2</code>。</p> </li><li> <p style="text-align:justify;"><code>src = src + self.dropout2(src2)</code>：这行代码将前馈神经网络的输出与输入特征张量相加，以引入更多的非线性变换。<code>self.dropout2</code> 是另一个丢弃层，用于防止过拟合。</p> </li><li> <p style="text-align:justify;"><code>return src</code>：最后，该方法返回处理后的特征张量 <code>src</code> 作为输出。</p> </li></ul> 
<p style="text-align:justify;">总之，这个方法实现了Transformer编码器层的前向传播，包括自注意力机制和前馈神经网络操作，以便对输入序列进行特征提取和表示学习。<strong><span style="background-color:#38d8f0;">这里的不同之处在于层归一化的位置，它是在自注意力之前执行的。</span></strong></p> 
<h5 style="text-align:justify;">5、<code>forward()</code></h5> 
<pre><code class="language-python">    def forward(self, src,
                src_mask: Optional[Tensor] = None,
                src_key_padding_mask: Optional[Tensor] = None,
                pos: Optional[Tensor] = None):
        if self.normalize_before:
            return self.forward_pre(src, src_mask, src_key_padding_mask, pos)
        return self.forward_post(src, src_mask, src_key_padding_mask, pos)</code></pre> 
<p style="text-align:justify;">这段代码是 `TransformerEncoderLayer` 类的 `forward` 方法的实现，根据 `normalize_before` 参数决定是执行 `forward_pre` 还是 `forward_post` 方法。</p> 
<p style="text-align:justify;">- `def forward(self, src, src_mask: Optional[Tensor] = None, src_key_padding_mask: Optional[Tensor] = None, pos: Optional[Tensor] = None):`：这是方法定义，接受四个输入参数，包括 `src`（输入特征张量）、`src_mask`（自注意力掩码，可选）、`src_key_padding_mask`（键值填充掩码，可选）和 `pos`（位置编码，可选）。</p> 
<p style="text-align:justify;">- `if self.normalize_before:`：这是一个条件语句，检查 `normalize_before` 是否为真（即是否启用了归一化操作在自注意力之前）。如果为真，则执行以下代码块。</p> 
<p style="text-align:justify;">  - `return self.forward_pre(src, src_mask, src_key_padding_mask, pos)`：这行代码调用 `forward_pre` 方法，执行自注意力和前馈神经网络等操作，并将结果返回。</p> 
<p style="text-align:justify;">- 如果 `normalize_before` 为假，表示不需要在自注意力之前执行归一化操作，那么代码将执行以下操作。</p> 
<p style="text-align:justify;">  - `return self.forward_post(src, src_mask, src_key_padding_mask, pos)`：这行代码调用 `forward_post` 方法，执行自注意力和前馈神经网络等操作，并将结果返回。</p> 
<p style="text-align:justify;">总之，<strong>这个 `forward` 方法根据 `normalize_before` 参数的值，选择性地执行 `forward_pre` 或 `forward_post` 方法来进行特征提取和处理。</strong>这种设计允许用户根据需求选择在自注意力之前或之后应用归一化操作。</p> 
<h4 style="text-align:justify;">六、<code>TransformerDecoder层</code></h4> 
<pre><code class="language-python">class TransformerDecoderLayer(nn.Module):

    def __init__(self, d_model, nhead, dim_feedforward=2048, dropout=0.1,
                 activation="relu", normalize_before=False):
        super().__init__()
        self.self_attn = nn.MultiheadAttention(d_model, nhead, dropout=dropout)
        self.multihead_attn = nn.MultiheadAttention(d_model, nhead, dropout=dropout)
        # Implementation of Feedforward model
        self.linear1 = nn.Linear(d_model, dim_feedforward)
        self.dropout = nn.Dropout(dropout)
        self.linear2 = nn.Linear(dim_feedforward, d_model)

        self.norm1 = nn.LayerNorm(d_model)
        self.norm2 = nn.LayerNorm(d_model)
        self.norm3 = nn.LayerNorm(d_model)
        self.dropout1 = nn.Dropout(dropout)
        self.dropout2 = nn.Dropout(dropout)
        self.dropout3 = nn.Dropout(dropout)

        self.activation = _get_activation_fn(activation)
        self.normalize_before = normalize_before

    def with_pos_embed(self, tensor, pos: Optional[Tensor]):
        return tensor if pos is None else tensor + pos

    def forward_post(self, tgt, memory,
                     tgt_mask: Optional[Tensor] = None,
                     memory_mask: Optional[Tensor] = None,
                     tgt_key_padding_mask: Optional[Tensor] = None,
                     memory_key_padding_mask: Optional[Tensor] = None,
                     pos: Optional[Tensor] = None,
                     query_pos: Optional[Tensor] = None):
        q = k = self.with_pos_embed(tgt, query_pos)
        tgt2 = self.self_attn(q, k, value=tgt, attn_mask=tgt_mask,
                              key_padding_mask=tgt_key_padding_mask)[0]
        tgt = tgt + self.dropout1(tgt2)
        tgt = self.norm1(tgt)
        tgt2 = self.multihead_attn(query=self.with_pos_embed(tgt, query_pos),
                                   key=self.with_pos_embed(memory, pos),
                                   value=memory, attn_mask=memory_mask,
                                   key_padding_mask=memory_key_padding_mask)[0]
        tgt = tgt + self.dropout2(tgt2)
        tgt = self.norm2(tgt)
        tgt2 = self.linear2(self.dropout(self.activation(self.linear1(tgt))))
        tgt = tgt + self.dropout3(tgt2)
        tgt = self.norm3(tgt)
        return tgt

    def forward_pre(self, tgt, memory,
                    tgt_mask: Optional[Tensor] = None,
                    memory_mask: Optional[Tensor] = None,
                    tgt_key_padding_mask: Optional[Tensor] = None,
                    memory_key_padding_mask: Optional[Tensor] = None,
                    pos: Optional[Tensor] = None,
                    query_pos: Optional[Tensor] = None):
        tgt2 = self.norm1(tgt)
        q = k = self.with_pos_embed(tgt2, query_pos)
        tgt2 = self.self_attn(q, k, value=tgt2, attn_mask=tgt_mask,
                              key_padding_mask=tgt_key_padding_mask)[0]
        tgt = tgt + self.dropout1(tgt2)
        tgt2 = self.norm2(tgt)
        tgt2 = self.multihead_attn(query=self.with_pos_embed(tgt2, query_pos),
                                   key=self.with_pos_embed(memory, pos),
                                   value=memory, attn_mask=memory_mask,
                                   key_padding_mask=memory_key_padding_mask)[0]
        tgt = tgt + self.dropout2(tgt2)
        tgt2 = self.norm3(tgt)
        tgt2 = self.linear2(self.dropout(self.activation(self.linear1(tgt2))))
        tgt = tgt + self.dropout3(tgt2)
        return tgt

    def forward(self, tgt, memory,
                tgt_mask: Optional[Tensor] = None,
                memory_mask: Optional[Tensor] = None,
                tgt_key_padding_mask: Optional[Tensor] = None,
                memory_key_padding_mask: Optional[Tensor] = None,
                pos: Optional[Tensor] = None,
                query_pos: Optional[Tensor] = None):
        if self.normalize_before:
            return self.forward_pre(tgt, memory, tgt_mask, memory_mask,
                                    tgt_key_padding_mask, memory_key_padding_mask, pos, query_pos)
        return self.forward_post(tgt, memory, tgt_mask, memory_mask,
                                 tgt_key_padding_mask, memory_key_padding_mask, pos, query_pos)</code></pre> 
<p style="text-align:justify;">这段代码实现了 <code>TransformerDecoderLayer</code> 类，它是 Transformer 解码器中的一个层，总的来说，<code>TransformerDecoderLayer</code> 是 Transformer 解码器的一个层，包括自注意力、多头自注意力和前馈神经网络，以及归一化和 Dropout 操作。这个层可以用于构建 Transformer 解码器。</p> 
<h5 style="text-align:justify;">1、__init__()</h5> 
<pre><code class="language-python">class TransformerDecoderLayer(nn.Module):

    def __init__(self, d_model, nhead, dim_feedforward=2048, dropout=0.1,
                 activation="relu", normalize_before=False):
        super().__init__()
        self.self_attn = nn.MultiheadAttention(d_model, nhead, dropout=dropout)
        self.multihead_attn = nn.MultiheadAttention(d_model, nhead, dropout=dropout)
        # Implementation of Feedforward model
        self.linear1 = nn.Linear(d_model, dim_feedforward)
        self.dropout = nn.Dropout(dropout)
        self.linear2 = nn.Linear(dim_feedforward, d_model)

        self.norm1 = nn.LayerNorm(d_model)
        self.norm2 = nn.LayerNorm(d_model)
        self.norm3 = nn.LayerNorm(d_model)
        self.dropout1 = nn.Dropout(dropout)
        self.dropout2 = nn.Dropout(dropout)
        self.dropout3 = nn.Dropout(dropout)

        self.activation = _get_activation_fn(activation)
        self.normalize_before = normalize_before</code></pre> 
<p style="text-align:justify;">这段代码定义了 `TransformerDecoderLayer` 类，该类是 Transformer 解码器中的一个层，包含以下参数和组件：</p> 
<p style="text-align:justify;">- `d_model`：模型的维度大小，通常是输入嵌入的维度和输出嵌入的维度，它表示了模型中特征的维度。</p> 
<p style="text-align:justify;">- `nhead`：多头注意力机制的头数，决定了自注意力机制被划分为多少个子空间，每个头都学习不同的表示。</p> 
<p style="text-align:justify;">- `dim_feedforward`：前馈神经网络隐藏层的维度，它是自注意力子层后的前馈神经网络的维度。</p> 
<p style="text-align:justify;">- `dropout`：Dropout 概率，用于在模型训练时随机丢弃一部分神经元，以减少过拟合。</p> 
<p style="text-align:justify;">- `activation`：激活函数的类型，通常为 ReLU。</p> 
<p style="text-align:justify;">- `normalize_before`：一个布尔值，确定是否在自注意力和前馈神经网络之前执行归一化操作。</p> 
<p style="text-align:justify;"><strong>接下来，该类创建了以下组件：</strong></p> 
<p style="text-align:justify;">- `self.self_attn` 和 `self.multihead_attn`：多头注意力机制，分别用于自注意力和多头自注意力操作。</p> 
<p style="text-align:justify;">- `self.linear1` 和 `self.linear2`：两个线性层，用于前馈神经网络中的线性变换。</p> 
<p style="text-align:justify;"><span style="background-color:#a2e043;">- `self.norm1`、`self.norm2` 和 `self.norm3`：LayerNorm 归一化层，分别用于自注意力、多头自注意力和前馈神经网络。</span></p> 
<p style="text-align:justify;"><span style="background-color:#a2e043;">- `self.dropout1`、`self.dropout2` 和 `self.dropout3`：Dropout 层，用于自注意力、多头自注意力和前馈神经网络。</span></p> 
<p style="text-align:justify;">- `self.activation`：激活函数，通常为 ReLU。</p> 
<p style="text-align:justify;">接下来，该类定义了三个方法，分别用于执行不同步骤的前向传播操作：</p> 
<p style="text-align:justify;">- `with_pos_embed` 方法接受一个输入张量 `tensor` 和一个位置编码张量 `pos`（可选），并返回二者相加的结果。这个方法用于将位置编码添加到输入张量中，以便在自注意力操作中使用。</p> 
<p style="text-align:justify;"><strong>- `forward_post` </strong>方法执行层的前向传播操作，包括自注意力、多头自注意力和前馈神经网络，以及归一化和 Dropout 操作。</p> 
<p style="text-align:justify;"><strong>- `forward_pre` </strong>方法执行层的前向传播操作，包括自注意力、多头自注意力和前馈神经网络，以及归一化和 Dropout 操作。</p> 
<p style="text-align:justify;">最后，`forward` 方法根据 `normalize_before` 参数确定是调用 `forward_pre` 还是 `forward_post` 方法来执行前向传播。这取决于是否在自注意力之前执行归一化。</p> 
<h5 style="text-align:justify;">2、with_pos_embed()</h5> 
<pre><code class="language-python">    def with_pos_embed(self, tensor, pos: Optional[Tensor]):
        return tensor if pos is None else tensor + pos</code></pre> 
<p style="text-align:justify;">这是 `TransformerDecoderLayer` 类中的一个方法，其作用是将位置编码（`pos`）添加到输入张量（`tensor`）中，如果位置编码为 `None`，则直接返回输入张量。</p> 
<p style="text-align:justify;">具体来说，该方法首先检查传入的位置编码 `pos` 是否为 `None`。如果 `pos` 是 `None`，则说明不需要添加位置编码，直接返回原始输入张量 `tensor`。如果 `pos` 不是 `None`，则将输入张量 `tensor` 和位置编码张量 `pos` 进行逐元素相加，从而实现了将位置编码与输入张量相叠加的操作。</p> 
<p style="text-align:justify;">这个方法的目的是为了在自注意力操作中使用位置编码，以便模型能够根据输入的位置信息更好地理解序列数据。在 Transformer 模型中，位置编码通常会与输入嵌入相加，以为模型提供关于每个输入位置的信息。</p> 
<p style="text-align:justify;"> 左边为forward_pre()，右边为forward_post()</p> 
<p class="img-center"><img alt="" height="432" src="https://images2.imgbox.com/98/5e/GzV72lxG_o.png" width="511"></p> 
<h5 style="text-align:justify;">3、forward_post()</h5> 
<pre><code class="language-python">    def forward_post(self, tgt, memory,
                     tgt_mask: Optional[Tensor] = None,
                     memory_mask: Optional[Tensor] = None,
                     tgt_key_padding_mask: Optional[Tensor] = None,
                     memory_key_padding_mask: Optional[Tensor] = None,
                     pos: Optional[Tensor] = None,
                     query_pos: Optional[Tensor] = None):
        q = k = self.with_pos_embed(tgt, query_pos)
        tgt2 = self.self_attn(q, k, value=tgt, attn_mask=tgt_mask,
                              key_padding_mask=tgt_key_padding_mask)[0]
        tgt = tgt + self.dropout1(tgt2)
        tgt = self.norm1(tgt)
        tgt2 = self.multihead_attn(query=self.with_pos_embed(tgt, query_pos),
                                   key=self.with_pos_embed(memory, pos),
                                   value=memory, attn_mask=memory_mask,
                                   key_padding_mask=memory_key_padding_mask)[0]
        tgt = tgt + self.dropout2(tgt2)
        tgt = self.norm2(tgt)
        tgt2 = self.linear2(self.dropout(self.activation(self.linear1(tgt))))
        tgt = tgt + self.dropout3(tgt2)
        tgt = self.norm3(tgt)
        return tgt</code></pre> 
<p style="text-align:justify;">这是 `TransformerDecoderLayer` 类中的一个方法，表示 Transformer 解码器层的前向传播操作。该方法接受多个输入参数，包括 `tgt`（目标序列的表示）、<span style="background-color:#a2e043;">`memory`（编码器的输出，通常作为上下文信息）</span>、`tgt_mask`、`memory_mask`、`tgt_key_padding_mask`、`memory_key_padding_mask`、`pos` 和 `query_pos`（位置编码信息）。</p> 
<p style="text-align:justify;">下面是每行代码的详细解释：</p> 
<p style="text-align:justify;">1. `q = k = self.with_pos_embed(tgt, query_pos)`</p> 
<p style="text-align:justify;">将位置编码 `query_pos` 添加到目标序列 `tgt` 中，以便在自注意力机制中使用。这里同时给 `q` 和 `k` 赋相同的值，因为它们在自注意力中充当查询和键。</p> 
<p style="text-align:justify;">2. `tgt2 = self.self_attn(q, k, value=tgt, attn_mask=tgt_mask, key_padding_mask=tgt_key_padding_mask)[0]`</p> 
<p style="text-align:justify;">使用自注意力机制（`self_attn`）计算目标序列 `tgt` 中的注意力，其中 `tgt_mask` 用于屏蔽未来信息，`tgt_key_padding_mask` 用于屏蔽填充的标记。这将生成更新后的目标序列表示 `tgt2`。</p> 
<p style="text-align:justify;">3. `tgt = tgt + self.dropout1(tgt2)`</p> 
<p style="text-align:justify;">将原始目标序列 `tgt` 与通过自注意力计算得到的 `tgt2` 相加，以引入自注意力的信息。`dropout1` 用于应用丢弃操作，以减少过拟合。</p> 
<p style="text-align:justify;">4. `tgt = self.norm1(tgt)`</p> 
<p style="text-align:justify;">应用 Layer Normalization 到更新后的目标序列 `tgt` 上，以规范化其特征。</p> 
<p style="text-align:justify;">5. `<span style="background-color:#a2e043;">tgt2 = self.multihead_attn(query=self.with_pos_embed(tgt, query_pos), key=self.with_pos_embed(memory, pos), value=memory, attn_mask=memory_mask, key_padding_mask=memory_key_padding_mask)[0]</span>`</p> 
<p style="text-align:justify;">使用多头注意力机制（`multihead_attn`）计算目标序列 `tgt` 与编码器输出 `memory` 之间的注意力，以捕获上下文信息。`query` 表示目标序列，`key` 表示编码器输出，`value` 表示编码器输出。`memory_mask` 和 `memory_key_padding_mask` 用于控制注意力的计算。</p> 
<p style="text-align:justify;">6. `tgt = tgt + self.dropout2(tgt2)`</p> 
<p style="text-align:justify;">将目标序列 `tgt` 与上一步计算得到的 `tgt2` 相加，以引入编码器的上下文信息。同样，`dropout2` 用于丢弃操作。</p> 
<p style="text-align:justify;">7. `tgt = self.norm2(tgt)`</p> 
<p style="text-align:justify;">再次应用 Layer Normalization 到更新后的目标序列 `tgt` 上。</p> 
<p style="text-align:justify;">8. `tgt2 = self.linear2(self.dropout(self.activation(self.linear1(tgt))))`</p> 
<p style="text-align:justify;">通过两个线性层和激活函数执行前馈神经网络（Feedforward Neural Network）操作。这有助于捕获更复杂的特征。</p> 
<p style="text-align:justify;">9. `tgt = tgt + self.dropout3(tgt2)`</p> 
<p style="text-align:justify;">将目标序列 `tgt` 与前馈神经网络的输出 `tgt2` 相加，以引入更高级的表示信息。`dropout3` 用于丢弃操作。</p> 
<p style="text-align:justify;">10. `tgt = self.norm3(tgt)`</p> 
<p style="text-align:justify;">最后一次应用 Layer Normalization 到更新后的目标序列 `tgt` 上。</p> 
<p style="text-align:justify;">11. `return tgt`</p> 
<p style="text-align:justify;">返回更新后的目标序列作为解码器层的输出。</p> 
<p style="text-align:justify;">总之，这个方法实现了 Transformer 解码器层的前向传播，包括自注意力和多头注意力机制，以及前馈神经网络操作，用于生成解码器的输出。这些操作允许模型在生成目标序列时考虑输入序列和上下文信息。</p> 
<h5 style="text-align:justify;">4、forward_pre()</h5> 
<pre><code class="language-python">    def forward_pre(self, tgt, memory,
                    tgt_mask: Optional[Tensor] = None,
                    memory_mask: Optional[Tensor] = None,
                    tgt_key_padding_mask: Optional[Tensor] = None,
                    memory_key_padding_mask: Optional[Tensor] = None,
                    pos: Optional[Tensor] = None,
                    query_pos: Optional[Tensor] = None):
        tgt2 = self.norm1(tgt)
        q = k = self.with_pos_embed(tgt2, query_pos)
        tgt2 = self.self_attn(q, k, value=tgt2, attn_mask=tgt_mask,
                              key_padding_mask=tgt_key_padding_mask)[0]
        tgt = tgt + self.dropout1(tgt2)
        tgt2 = self.norm2(tgt)
        tgt2 = self.multihead_attn(query=self.with_pos_embed(tgt2, query_pos),
                                   key=self.with_pos_embed(memory, pos),
                                   value=memory, attn_mask=memory_mask,
                                   key_padding_mask=memory_key_padding_mask)[0]
        tgt = tgt + self.dropout2(tgt2)
        tgt2 = self.norm3(tgt)
        tgt2 = self.linear2(self.dropout(self.activation(self.linear1(tgt2))))
        tgt = tgt + self.dropout3(tgt2)
        return tgt</code></pre> 
<p style="text-align:justify;">这是 `TransformerDecoderLayer` 类中的另一个方法，表示 Transformer 解码器层的前向传播操作，但与之前的方法 `forward_post` 有所不同。这个方法在不同的顺序下应用了层归一化（Layer Normalization），自注意力（Self-Attention）和多头注意力（Multi-Head Attention）等操作。</p> 
<p style="text-align:justify;">下面是每行代码的详细解释：</p> 
<p style="text-align:justify;">1. `tgt2 = self.norm1(tgt)`</p> 
<p style="text-align:justify;">首先，将输入目标序列 `tgt` 应用 Layer Normalization，以规范化其特征。</p> 
<p style="text-align:justify;">2. `q = k = self.with_pos_embed(tgt2, query_pos)`</p> 
<p style="text-align:justify;">然后，将位置编码 `query_pos` 添加到 `tgt2` 中，以供后续的自注意力和多头注意力机制使用。同时，`q` 和 `k` 都赋予相同的值，因为它们在自注意力中充当查询和键。</p> 
<p style="text-align:justify;">3. `tgt2 = self.self_attn(q, k, value=tgt2, attn_mask=tgt_mask, key_padding_mask=tgt_key_padding_mask)[0]`</p> 
<p style="text-align:justify;">接下来，使用自注意力机制（`self_attn`）计算目标序列 `tgt2` 上的自注意力，其中 `tgt_mask` 用于屏蔽未来信息，`tgt_key_padding_mask` 用于屏蔽填充的标记。这将生成更新后的目标序列表示 `tgt2`。</p> 
<p style="text-align:justify;">4. `tgt = tgt + self.dropout1(tgt2)`</p> 
<p style="text-align:justify;">将原始目标序列 `tgt` 与通过自注意力计算得到的 `tgt2` 相加，以引入自注意力的信息。`dropout1` 用于应用丢弃操作，以减少过拟合。</p> 
<p style="text-align:justify;">5. `tgt2 = self.norm2(tgt)`</p> 
<p style="text-align:justify;">再次应用 Layer Normalization 到更新后的目标序列 `tgt` 上，以规范化其特征。</p> 
<p style="text-align:justify;">6. `tgt2 = self.multihead_attn(query=self.with_pos_embed(tgt2, query_pos), key=self.with_pos_embed(memory, pos), value=memory, attn_mask=memory_mask, key_padding_mask=memory_key_padding_mask)[0]`</p> 
<p style="text-align:justify;">然后，使用多头注意力机制（`multihead_attn`）计算目标序列 `tgt2` 与编码器输出 `memory` 之间的注意力，以捕获上下文信息。`query` 表示目标序列，`key` 表示编码器输出，`value` 表示编码器输出。`memory_mask` 和 `memory_key_padding_mask` 用于控制注意力的计算。</p> 
<p style="text-align:justify;">7. `tgt = tgt + self.dropout2(tgt2)`</p> 
<p style="text-align:justify;">将目标序列 `tgt` 与上一步计算得到的 `tgt2` 相加，以引入编码器的上下文信息。同样，`dropout2` 用于丢弃操作。</p> 
<p style="text-align:justify;">8. `tgt2 = self.norm3(tgt)`</p> 
<p style="text-align:justify;">最后一次应用 Layer Normalization 到更新后的目标序列 `tgt` 上，以规范化其特征。</p> 
<p style="text-align:justify;">9. `tgt2 = self.linear2(self.dropout(self.activation(self.linear1(tgt2))))`</p> 
<p style="text-align:justify;">通过两个线性层和激活函数执行前馈神经网络（Feedforward Neural Network）操作。这有助于捕获更复杂的特征。</p> 
<p style="text-align:justify;">10. `tgt = tgt + self.dropout3(tgt2)`</p> 
<p style="text-align:justify;">将目标序列 `tgt` 与前馈神经网络的输出 `tgt2` 相加，以引入更高级的表示信息。`dropout3` 用于丢弃操作。</p> 
<p style="text-align:justify;">11. `return tgt`</p> 
<p style="text-align:justify;">返回更新后的目标序列作为解码器层的输出。</p> 
<p style="text-align:justify;">总之，这个方法实现了 Transformer 解码器层的前向传播，但与 `forward_post` 方法相比，它在不同的顺序下应用了操作。这些操作允许模型在生成目标序列时考虑输入序列和上下文信息，但是它们的计算顺序不同。</p> 
<h5 style="text-align:justify;">5、forward()</h5> 
<pre><code class="language-python">    def forward(self, tgt, memory,
                tgt_mask: Optional[Tensor] = None,
                memory_mask: Optional[Tensor] = None,
                tgt_key_padding_mask: Optional[Tensor] = None,
                memory_key_padding_mask: Optional[Tensor] = None,
                pos: Optional[Tensor] = None,
                query_pos: Optional[Tensor] = None):
        if self.normalize_before:
            return self.forward_pre(tgt, memory, tgt_mask, memory_mask,
                                    tgt_key_padding_mask, memory_key_padding_mask, pos, query_pos)
        return self.forward_post(tgt, memory, tgt_mask, memory_mask,
                                 tgt_key_padding_mask, memory_key_padding_mask, pos, query_pos)</code></pre> 
<p style="text-align:justify;">这个 `forward` 方法实际上是 `TransformerDecoderLayer` 的主要前向传播方法，它根据是否使用 "normalize_before" 标志来选择是执行 "forward_pre" 还是 "forward_post" 方法。</p> 
<p style="text-align:justify;">以下是每行代码的详细解释：</p> 
<p style="text-align:justify;">1. `if self.normalize_before:`：这是一个条件语句，检查 `normalize_before` 标志是否为真。如果 `normalize_before` 为真，它将执行 "forward_pre" 方法，否则将执行 "forward_post" 方法。</p> 
<p style="text-align:justify;">2. `return self.forward_pre(tgt, memory, tgt_mask, memory_mask, tgt_key_padding_mask, memory_key_padding_mask, pos, query_pos)`：如果 `normalize_before` 为真，就调用 "forward_pre" 方法，将目标序列 `tgt`、编码器输出 `memory`、目标序列掩码 `tgt_mask`、编码器输出掩码 `memory_mask`、目标序列的键掩码 `tgt_key_padding_mask`、编码器输出的键掩码 `memory_key_padding_mask`、位置编码 `pos` 以及查询位置编码 `query_pos` 传递给 "forward_pre" 方法。然后，它返回 "forward_pre" 方法的结果。</p> 
<p style="text-align:justify;">3. `return self.forward_post(tgt, memory, tgt_mask, memory_mask, tgt_key_padding_mask, memory_key_padding_mask, pos, query_pos)`：如果 `normalize_before` 为假，就调用 "forward_post" 方法，将相同的参数传递给 "forward_post" 方法。然后，它返回 "forward_post" 方法的结果。</p> 
<p style="text-align:justify;">总之，这个 `forward` 方法基于 `normalize_before` 标志来选择适当的前向传播方法，并将相同的输入参数传递给选定的方法。这是为了根据模型的配置决定前向传播的计算顺序，以灵活地适应不同的模型结构。</p> 
<h4 style="text-align:justify;">七、<code>_get_clones()</code></h4> 
<pre><code class="language-python">def _get_clones(module, N):
    return nn.ModuleList([copy.deepcopy(module) for i in range(N)])</code></pre> 
<p style="text-align:justify;">这个函数 <code>_get_clones</code> 接受两个参数：<code>module</code> 和 <code>N</code>。它的作用是创建一个包含 <code>N</code> 个克隆副本的 PyTorch 模块列表，并返回该列表。</p> 
<p style="text-align:justify;">以下是每行代码的详细解释：</p> 
<ol><li style="text-align:justify;"><code>nn.ModuleList([copy.deepcopy(module) for i in range(N)])</code>：这一行代码首先创建一个空的 PyTorch 模块列表 <code>nn.ModuleList([])</code>。然后，它使用列表推导式 <code>copy.deepcopy(module) for i in range(N)</code> 来创建 <code>N</code> 个 <code>module</code> 的深度克隆副本，并将它们添加到模块列表中。</li></ol> 
<p style="text-align:justify;">简而言之，这个函数的<span style="color:#fe2c24;"><strong>目的是创建一个包含多个相同模块的列表，以便在模型中多次使用相同的模块</strong></span>，例如在 Transformer 模型中的多层编码器或解码器中。这样可以确保每个模块都有独立的权重和参数，但它们具有相同的结构。这对于构建深度神经网络模型非常有用。</p> 
<h4 style="text-align:justify;">八、<code>build_transformer</code> ()</h4> 
<pre><code class="language-python">def build_transformer(args):
    return Transformer(
        d_model=args.hidden_dim,
        dropout=args.dropout,
        nhead=args.nheads,
        dim_feedforward=args.dim_feedforward,
        num_encoder_layers=args.enc_layers,
        num_decoder_layers=args.dec_layers,
        normalize_before=args.pre_norm,
        return_intermediate_dec=True,
    )</code></pre> 
<p style="text-align:justify;">这个函数 <code>build_transformer</code> 用于构建一个 Transformer 模型，其配置参数由传入的 <code>args</code> 参数决定。</p> 
<p style="text-align:justify;">这个函数返回一个 Transformer 模型，其中各参数的含义如下：</p> 
<ul><li> <p style="text-align:justify;"><code>d_model</code>: Transformer 模型的隐藏维度，通常是模型中重要的超参数之一。</p> </li><li> <p style="text-align:justify;"><code>dropout</code>: 模型中的丢弃率，用于正则化，以防止过拟合。</p> </li><li> <p style="text-align:justify;"><code>nhead</code>: 多头自注意力机制中的头数。</p> </li><li> <p style="text-align:justify;"><code>dim_feedforward</code>: Feedforward 网络的中间维度。</p> </li><li> <p style="text-align:justify;"><code>num_encoder_layers</code>: 编码器的层数。</p> </li><li> <p style="text-align:justify;"><code>num_decoder_layers</code>: 解码器的层数。</p> </li><li> <p style="text-align:justify;"><code>normalize_before</code>: 是否在每个子层之前进行层归一化。</p> </li><li> <p style="text-align:justify;"><code>return_intermediate_dec</code>: 是否返回解码器中每一层的输出，通常用于一些多任务学习或其他任务中。</p> </li></ul> 
<p style="text-align:justify;">这个函数的目的是<strong>创建一个 Transformer 模型，并使用传入的参数配置该模型的各个部分。</strong></p> 
<h4 style="text-align:justify;">九、<code>_get_activation_fn()</code></h4> 
<pre><code class="language-python">def _get_activation_fn(activation):
    """Return an activation function given a string"""
    if activation == "relu":
        return F.relu
    if activation == "gelu":
        return F.gelu
    if activation == "glu":
        return F.glu
    raise RuntimeError(F"activation should be relu/gelu, not {activation}.")</code></pre> 
<p style="text-align:justify;"><code>_get_activation_fn</code> 函数用于<span style="background-color:#a2e043;">根据输入的字符串 </span><code><span style="background-color:#a2e043;">activation</span></code><span style="background-color:#a2e043;"> 返回相应的激活函数</span>。激活函数是神经网络中的一种非线性函数，用于引入非线性变换，以增加模型的表示能力。这个函数支持返回三种激活函数，具体如下：</p> 
<ul><li> <p style="text-align:justify;">如果 <code>activation</code> 参数的值是 <code>"relu"</code>，则返回 ReLU（Rectified Linear Unit）激活函数，表示为 <code>F.relu</code>。</p> </li><li> <p style="text-align:justify;">如果 <code>activation</code> 参数的值是 <code>"gelu"</code>，则返回 GELU（Gaussian Error Linear Unit）激活函数，表示为 <code>F.gelu</code>。</p> </li><li> <p style="text-align:justify;">如果 <code>activation</code> 参数的值是 <code>"glu"</code>，则返回 GLU（Gated Linear Unit）激活函数，表示为 <code>F.glu</code>。</p> </li></ul> 
<p style="text-align:justify;">如果 <code>activation</code> 参数的值不是上述三者之一，函数会引发一个 <code>RuntimeError</code> 异常，指示传入的激活函数不受支持。</p> 
<p style="text-align:justify;">这个函数的目的是为了方便地根据字符串指定的激活函数名称获取相应的激活函数对象，以在神经网络的各个层中使用。这有助于使代码更具可读性和可维护性，因为开发者可以直观地指定所需的激活函数。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0a4c180ee6bb01c7d57aeac5c64b4e3d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">shell 获取主机IP 脚本中使用IP 打印出来IP</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/82e7e9bb8efc5c9ab673e2aa2c3a1dd0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">vmware中ubuntu虚拟机不能够用共享文件夹</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>