<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Maven详细总结 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Maven详细总结" />
<meta property="og:description" content="参考博客：https://blog.csdn.net/xiaodi2016/article/details/121341063
※注意：
我们自己的Maven工程必须执行安装操作才会进入仓库。安装的命令是：mvn install
任何一个Maven工程会根据坐标到本地仓库中去查找它所依赖的jar包。如果能够找到则可以正常工作，否则就不行。HelloFriend 回到本地仓库去找HelloWorld jar包。
4.5 依赖管理
当A jar包需要用到B jar包中的类时，我们就说A对B有依赖。
直接依赖和间接依赖
如果A依赖B，B依赖C，那么A→B和B→C都是直接依赖，而A→C是间接依赖。
4.5.1 依赖的范围
依赖的范围：类似于变量的作用域，jar包可以使用的范围
&lt;scope&gt;&lt;/scope&gt;指明依赖范围
compile：
默认值，可以使用在main目录与test目录下使用
部署到Tomcat服务器上运行时要放在WEB-INF的lib目录下
test：
只能在test目录下使用
部署时无需上传服务器，服务器上没有是没有问题的
provided：
可以使用在main目录与test目录下使用
部署时无需上传服务器，因为服务器上理论上是已经存在的了(假定)
4.5.2 依赖的传递性
当存在间接依赖的情况时，主工程对间接依赖的jar可以访问吗？这要看间接依赖的jar包引入时的依赖范围——只有依赖范围为compile时可以访问。
间接依赖是否可以用还需要看依赖的范围，只有是complie才可以间接依赖。
原则：最短路径者优先和先声明者优先
如果可以不去依赖某个工程的jar包可以使用&lt;exclusion&gt;标签
&lt;exclusions&gt;
&lt;exclusion&gt;
&lt;groupId&gt;junit&lt;/groupId&gt;
&lt;artifactId&gt;junit&lt;/artifactId&gt;
&lt;/exclusion&gt;
&lt;/exclusions&gt;
4.5.3 统一管理目标Jar包的版本
以对Spring的jar包依赖为例：Spring的每一个版本中都包含spring-context，springmvc等jar包。我们应该导入版本一致的Spring jar包，而不是使用4.0.0的spring-context的同时使用4.1.1的springmvc。
问题是如果我们想要将这些jar包的版本统一升级为4.1.1，显然，我们有统一配置的方式：
4.6:仓库：
（1）本地仓库：为当前本机电脑上的所有Maven工程服务。
（2）远程仓库
a）私服：架设在当前局域网环境下，为当前局域网范围内的所有Maven工程服务。 b）中央仓库：架设在Internet上，为全世界所有Maven工程服务。 c）中央仓库的镜像：架设在各个大洲，为中央仓库分担流量。减轻中央仓库的压力，同时更快的响应用户请求。 4.6.3：仓库中的文件
（1）Maven的插件
（2）我们自己开发的项目的模块
（3）第三方框架或工具的jar包
不管是什么样的jar包，在仓库中都是按照坐标生成目录结构，所以可以通过统一的方式查询或依赖。
4.7:maven生命周期
Maven生命周期定义了各个构建环节的执行顺序，有了这个清单，Maven就可以自动化的执行构建命令了。
Clean Lifecycle在进行真正的构建之前进行一些清理工作。
Default Lifecycle构建的核心部分，编译，测试，打包，安装，部署等等。(用的比较多，可以帮助我们自动化构建我们需要的内容)
Site Lifecycle生成项目报告，站点，发布站点。(在浏览器上查看项目的信息，是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能，文档及统计数据自动生成，但是一般我们用不上)
4.7.1：生命周期与自动化构建
运行任何一个阶段的时候，它前面的所有阶段都会被运行，例如我们运行mvn install 的时候，代码会被编译，测试，打包。这就是Maven为什么能够自动执行构建过程的各个环节的原因。此外，Maven的插件机制是完全依赖Maven的生命周期的。
4.8：插件和目标
（1）Maven的核心仅仅定义了抽象的生命周期，具体的任务都是交由插件完成的。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ca99df036ce6a0e0659708965862d306/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-02T18:22:45+08:00" />
<meta property="article:modified_time" content="2022-12-02T18:22:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Maven详细总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>参考博客：https://blog.csdn.net/xiaodi2016/article/details/121341063<br> <img src="https://images2.imgbox.com/43/5d/a4EVgA9b_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/70/0e/qIDXAleC_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/58/9d/REPRSuol_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a3/ef/xmolf7oH_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a6/c3/G3JsD0T8_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a0/3b/SPD2nFAW_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/86/f0/4Iy4tGFJ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/0d/71/b5T7Jdph_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/09/ec/Lm3Dc1HE_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/5b/2f/w2PdK86W_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/7d/05/G9tuP01v_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/91/19/Yu2br3II_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/90/ad/iOGdBM5E_o.png" alt="在这里插入图片描述"><br> ※注意：<br> 我们自己的Maven工程必须执行安装操作才会进入仓库。安装的命令是：mvn install<br> <img src="https://images2.imgbox.com/48/cf/vjkP40ZV_o.png" alt="在这里插入图片描述"><br> 任何一个Maven工程会根据坐标到本地仓库中去查找它所依赖的jar包。如果能够找到则可以正常工作，否则就不行。HelloFriend 回到本地仓库去找HelloWorld jar包。<br> <strong>4.5 依赖管理</strong><br> 当A jar包需要用到B jar包中的类时，我们就说A对B有依赖。</p> 
<p><strong>直接依赖和间接依赖</strong><br> 如果A依赖B，B依赖C，那么A→B和B→C都是直接依赖，而A→C是间接依赖。<br> <strong>4.5.1 依赖的范围</strong><br> 依赖的范围：类似于变量的作用域，jar包可以使用的范围<br> <strong>&lt;scope&gt;&lt;/scope&gt;指明依赖范围</strong><br> compile：<br> 默认值，可以使用在main目录与test目录下使用<br> 部署到Tomcat服务器上运行时要放在WEB-INF的lib目录下<br> test：<br> 只能在test目录下使用<br> 部署时无需上传服务器，服务器上没有是没有问题的<br> provided：<br> 可以使用在main目录与test目录下使用<br> 部署时无需上传服务器，因为服务器上理论上是已经存在的了(假定)</p> 
<p><strong>4.5.2 依赖的传递性</strong><br> 当存在间接依赖的情况时，主工程对间接依赖的jar可以访问吗？这要看间接依赖的jar包引入时的依赖范围——<strong>只有依赖范围为compile时可以访问</strong>。<br> <strong>间接依赖是否可以用还需要看依赖的范围，只有是complie才可以间接依赖。</strong><br> 原则：最短路径者优先和先声明者优先<br> <img src="https://images2.imgbox.com/d5/54/4ZvXcHrO_o.png" alt="在这里插入图片描述"><br> 如果可以不去依赖某个工程的jar包可以使用&lt;exclusion&gt;标签<br> &lt;exclusions&gt;<br> &lt;exclusion&gt;<br> &lt;groupId&gt;junit&lt;/groupId&gt;<br> &lt;artifactId&gt;junit&lt;/artifactId&gt;<br> &lt;/exclusion&gt;<br> &lt;/exclusions&gt;<br> <img src="https://images2.imgbox.com/e8/63/6jkiChaY_o.png" alt="在这里插入图片描述"><br> <strong>4.5.3 统一管理目标Jar包的版本</strong><br> 以对Spring的jar包依赖为例：Spring的每一个版本中都包含spring-context，springmvc等jar包。我们应该导入版本一致的Spring jar包，而不是使用4.0.0的spring-context的同时使用4.1.1的springmvc。<br> 问题是如果我们想要将这些jar包的版本统一升级为4.1.1，显然，我们有统一配置的方式：<br> <img src="https://images2.imgbox.com/8e/3b/OVHn14Q5_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/d6/fc/eXGbJa4C_o.png" alt="在这里插入图片描述"><br> <strong>4.6:仓库：</strong><br> （1）本地仓库：为当前本机电脑上的所有Maven工程服务。</p> 
<p>（2）远程仓库</p> 
<pre><code>    a）私服：架设在当前局域网环境下，为当前局域网范围内的所有Maven工程服务。

    b）中央仓库：架设在Internet上，为全世界所有Maven工程服务。

    c）中央仓库的镜像：架设在各个大洲，为中央仓库分担流量。减轻中央仓库的压力，同时更快的响应用户请求。
</code></pre> 
<p><strong>4.6.3：仓库中的文件</strong><br> （1）Maven的插件</p> 
<p>（2）我们自己开发的项目的模块</p> 
<p>（3）第三方框架或工具的jar包</p> 
<p>不管是什么样的jar包，在仓库中都是按照坐标生成目录结构，所以可以通过统一的方式查询或依赖。<br> <strong>4.7:maven生命周期</strong><br> Maven生命周期定义了各个构建环节的执行顺序，有了这个清单，Maven就可以自动化的执行构建命令了。<br> <img src="https://images2.imgbox.com/05/61/9hzlyVQf_o.png" alt="在这里插入图片描述"></p> 
<ul><li> <p>Clean Lifecycle在进行真正的构建之前进行一些清理工作。</p> </li><li> <p>Default Lifecycle构建的核心部分，编译，测试，打包，安装，部署等等。(用的比较多，可以帮助我们自动化构建我们需要的内容)</p> </li><li> <p>Site Lifecycle生成项目报告，站点，发布站点。(在浏览器上查看项目的信息，是site阶段和site-deploy阶段，用以生成和发布Maven站点，这可是Maven相当强大的功能，文档及统计数据自动生成，但是一般我们用不上)<br> <strong>4.7.1：生命周期与自动化构建</strong><br> <strong>运行任何一个阶段的时候，它前面的所有阶段都会被运行</strong>，例如我们运行mvn install 的时候，代码会被编译，测试，打包。这就是Maven为什么能够自动执行构建过程的各个环节的原因。此外，Maven的插件机制是完全依赖Maven的生命周期的。<br> <strong>4.8：插件和目标</strong><br> （1）Maven的核心仅仅定义了<strong>抽象的生命周期</strong>，具体的任务都是交由<strong>插件</strong>完成的。<br> （2）每个插件都能实现多个功能，每个功能就是一个插件目标。<br> （3）Maven的生命周期与插件目标相互绑定，以完成某个具体的构建任务。<br> 例如：compile就是插件maven-compiler-plugin的一个功能；pre-clean是插件maven-clean-plugin的一个目标。<br> <strong>五：继承与聚合<br> 5.1：为什么需要继承机制？</strong><br> 由于非compile范围的依赖信息是不能在“依赖链”中传递的，所以有需要的工程只能单独配置。<br> <strong>父项目一般不做业务处理，所以无需打包，并且无需保留src目录</strong><br> 需要在父项目中声明标签 可以传的值有：</p> <pre><code>  pom：不打包
  jar：默认值，打包时打成jar包
  war：打包时打成war包
</code></pre> </li></ul> 
<p>子项目应该声明代码知道父项目是谁<br> <img src="https://images2.imgbox.com/c8/1f/hqEWW9Ms_o.png" alt="在这里插入图片描述"><br> <strong>5.2：父项目的导包方式：<br> 方式一：</strong><br> <strong>结果：子项目中直接拥有父项目中的所有jar包</strong><br> <img src="https://images2.imgbox.com/7f/8a/lXpu1YEk_o.png" alt="在这里插入图片描述"><br> <strong>方式二：<br> 结果：父项目中实际上没有导包进入，只不过进行了声明，子项目需要再次导入声明，但是此时无需指定版本</strong><br> <img src="https://images2.imgbox.com/7e/1f/XHNkuU4z_o.png" alt="在这里插入图片描述"><br> 原因：父项目作为整个项目的管理者，没有业务逻辑代码，所以本身不需要导包，父项目只不过作为jar包管理，这里可能有很多的jar包，子项目中可以根据需求进行声明。<br> <strong>5.3：聚合：</strong><br> <strong>5.3.1:为什么要使用聚合？</strong><br> <strong>将多个工程拆分为模块后，需要手动逐个安装到仓库后依赖才能够生效。修改源码后也需要逐个手动进行clean操作。而使用了聚合之后就可以批量进行Maven工程的安装、清理工作,方便管理。</strong><br> <strong>5.3.2:配置：</strong><br> <strong>(在父项目中进行配置，目的是父亲知道谁是它的儿子，这样的话才能统一管理子项目)</strong><br> <img src="https://images2.imgbox.com/b8/72/czSykTh2_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ad35b639bbaf9862409887eef564c015/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">wsl-系统迁移-非系统盘</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/20779af9069f5bdc5a4d1a4666cdcf04/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">解决Photoshop CS6在window10中窗口字体太小问题</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>