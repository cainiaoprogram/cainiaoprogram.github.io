<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【c&#43;&#43;】友元函数 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【c&#43;&#43;】友元函数" />
<meta property="og:description" content="为什么要引入友元函数：在实现类之间数据共享时，减少系统开销，提高效率。
c&#43;&#43;利用friend修饰符，可以让一些你设定的函数能够对这些保护数据进行操作，避免把类成员全部设置为public，最大限度的保护数据成员的安全。
具体来说：为了使其它类的成员函数直接访问该类的私有变量。
即：允许外面的类或函数去访问类的私有变量和保护变量，从而使两个类共享同一函数。（友元函数不是类的成员函数，是普通函数）
优点：能够提高效率，表达简单、清晰。
缺点：友元函数破坏了封装机制，尽量使用成员函数，除非不得已的情况下才使用友元函数。
什么时候使用友元：
运算符重载的某些场合需要使用友元。两个类要共享数据的时候。 怎么使用友元：
友元函数的参数：
因为友元函数是没有this指针的，则参数要有三种情况：
要访问非static成员时，需要对象做参数。（常用）要访问static成员或全局变量时，不需要对象做参数。如果做参数的对象是全局对象，则不需要对象做参数。 友元函数的位置：
因为友元函数是类外的函数，所以它的声明可以放在类的私有段或公有段且没有区别。
友元函数的调用：
可以直接调用友元函数，不需要通过对象或者指针。
友元函数 友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需要在友元的名称前面加上关键字friend。
具体格式为friend 类型 函数名(形式参数);
友元函数的声明可以放在类的私有部分，也可以放在类的公有部分，它们是没有区别的，都说明是该类的一个友元函数。
一个函数可以是多个类的友元函数，只需要在各个类中分别声明。
友元函数的调用与一般函数的调用方式和原理一致。
友元类 友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。
当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。定义友元类的语句格式如下：friend class 类名;其中：friend和class是关键字，类名必须是程序中的一个已经定义过的类。
函数来源总结 1 普通函数的友元函数 目的：使普通函数能够访问类的友元
语法：声明位置：公有私有均可，常写为公有
声明：friend&#43;普通函数声明
实现位置：类内类外均可
实现代码：与普通函数相同
调用：类似普通函数，直接调用
2 类Y的所有成员函数都是类X的友元函数–友元类 目的：使用单个声明使Y类的所有函数成为类X的友元
它提供了一种类之间合作的一种方式，使类Y的对象可以具有类X和类Y的功能。
前提：A是Ｂ的友元　可推　Ａ中的成员函数可以访问Ｂ中的所有成员。
语法：声名位置：公有私有均可，常写为私有（把类看成一个变量）。
声明：friend＋类名。
代码：
#include&lt;iostream&gt; using namespace std; class girl{ private: char *name; int age; friend class boy;//声明类boy是类girl的友元 public: girl(char *n,int age):name(n),age(age){}; }; class boy{ private: char *name; int age; public: boy(char *n,int age):name(n),age(age){}; void disp(girl &amp;); }; void boy::disp(girl &amp;x){//该函数必须在girl类定义的后面定义，否则girl中的私有变量还是未知的 cout&lt;&lt;&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6fc7c94ffd336cda62c700ef40231507/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-21T18:31:49+08:00" />
<meta property="article:modified_time" content="2022-12-21T18:31:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【c&#43;&#43;】友元函数</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><strong><mark>为什么要引入友元函数</mark>：在实现类之间数据共享时，减少系统开销，提高效率。</strong><br> c++利用friend修饰符，可以让一些你设定的函数能够对这些保护数据进行操作，避免把类成员全部设置为public，最大限度的保护数据成员的安全。<br> <strong>具体来说：为了使其它类的成员函数直接访问该类的私有变量。</strong><br> 即：允许外面的类或函数去访问类的私有变量和保护变量，从而使两个类共享同一函数。（友元函数不是类的成员函数，是普通函数）<br> 优点：能够提高效率，表达简单、清晰。<br> 缺点：友元函数破坏了封装机制，尽量使用成员函数，除非不得已的情况下才使用友元函数。</p> 
<p><strong>什么时候使用友元：</strong></p> 
<ul><li>运算符重载的某些场合需要使用友元。</li><li>两个类要共享数据的时候。</li></ul> 
<p><strong>怎么使用友元：</strong><br> 友元函数的参数：<br> 因为<mark>友元函数是没有this指针</mark>的，则参数要有三种情况：</p> 
<ul><li>要访问非static成员时，需要对象做参数。（常用）</li><li>要访问static成员或全局变量时，不需要对象做参数。</li><li>如果做参数的对象是全局对象，则不需要对象做参数。</li></ul> 
<p><strong>友元函数的位置：</strong><br> 因为友元函数是类外的函数，所以它的声明可以放在类的私有段或公有段且没有区别。<br> <strong>友元函数的调用：</strong><br> 可以直接调用友元函数，不需要通过对象或者指针。</p> 
<h4><a id="_23"></a>友元函数</h4> 
<p>友元函数是可以直接访问类的私有成员的非成员函数。它是定义在类外的普通函数，它不属于任何类，但需要在类的定义中加以声明，声明时只需要在友元的名称前面加上关键字<code>friend</code>。<br> 具体格式为<code>friend 类型 函数名(形式参数);</code><br> 友元函数的声明可以放在类的私有部分，也可以放在类的公有部分，它们是没有区别的，都说明是该类的一个友元函数。<br> <mark>一个函数可以是多个类的友元函数，只需要在各个类中分别声明。</mark><br> 友元函数的调用与一般函数的调用方式和原理一致。</p> 
<h4><a id="_30"></a>友元类</h4> 
<p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。<br> 当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。定义友元类的语句格式如下：<code>friend class 类名;</code>其中：friend和class是关键字，类名必须是程序中的一个已经定义过的类。</p> 
<h4><a id="_34"></a>函数来源总结</h4> 
<h5><a id="1__35"></a>1 普通函数的友元函数</h5> 
<p>目的：使普通函数能够访问类的友元<br> 语法：声明位置：公有私有均可，常写为公有<br> 声明：friend+普通函数声明<br> 实现位置：类内类外均可<br> 实现代码：与普通函数相同<br> 调用：类似普通函数，直接调用</p> 
<h5><a id="2_YX_42"></a>2 类Y的所有成员函数都是类X的友元函数–友元类</h5> 
<p>目的：使用单个声明使Y类的所有函数成为类X的友元<br> 它提供了一种类之间合作的一种方式，使类Y的对象可以具有类X和类Y的功能。<br> 前提：A是Ｂ的友元　可推　Ａ中的成员函数可以访问Ｂ中的所有成员。<br> 语法：声名位置：公有私有均可，常写为私有（把类看成一个变量）。<br> 声明：friend＋类名。<br> 代码：</p> 
<pre><code>#include&lt;iostream&gt;
using namespace std;
class girl{
	private:
		char *name;
		int age;
		friend class boy;//声明类boy是类girl的友元
	public:
		girl(char *n,int age):name(n),age(age){};
};
class boy{
	private:
		char *name;
		int age;
	public:
		boy(char *n,int age):name(n),age(age){};
		void disp(girl &amp;);
};
void boy::disp(girl &amp;x){//该函数必须在girl类定义的后面定义，否则girl中的私有变量还是未知的
	cout&lt;&lt;"boy's"&lt;&lt;name&lt;&lt;age&lt;&lt;endl;
	cout&lt;&lt;"girl's"&lt;&lt;x.name&lt;&lt;x.age&lt;&lt;endl;
}
int main(){
	boy b((char*)"aaa",8);
	girl g((char*)"bbb",99);
	b.disp(g);
	return 0;
}
</code></pre> 
<h5><a id="3_YX_79"></a>3 类Y的一个成员函数为类X的友元函数</h5> 
<p>目的：使类Y的一个成员函数成为类X的友元。<br> 具体而言：在类Y的这个成员函数中，借助参数X，可以直接以X私有变量的形式访问私有变量。<br> 语法：声明位置：声明在公有中（本身为函数）<br> 声明：friend+成员函数的声明<br> 调用：先定义Y的对象y，使用y调用自己的成员函数，自己的成员函数中使用了友元机制。</p> 
<h5><a id="4_operator_86"></a>4 在模板中使用友元operator&lt;&lt;(对&lt;&lt;运算符的重载)</h5> 
<p>使用方式：<br> 在模板类中声明：</p> 
<pre><code>friend ostream&amp; operator&lt;&lt; &lt;&gt;(ostream&amp; cout,const MGraph&lt;&gt;)
</code></pre> 
<p>说明：<br> 在函数声明中加入<code>operator&lt;&lt; &lt;&gt;":</code>是将operator&lt;&lt;函数定义为函数模板，将函数模板声明为类模板的友元时，是一对一对绑定的。<br> 实际的声明函数，这里的模板参数可以省略，但是&lt;&gt;不可以省略。<br> 友元函数和类的成员函数区别：有无this指针。</p> 
<h4><a id="_96"></a>使用友元类时注意</h4> 
<ul><li>友元关系不能被继承。</li><li>友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</li><li>友元的关系不具有传递性。若类B是类A的友元，类C是类B的友元，则类C不一定是类A的友元，同样要看类中是否有相应的声明。</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/96f62588b03c05387e357db1e04db937/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Power BI 11个必学官方示例数据案例（附下载链接）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1150f245d60739ef8ea850015dff9b0c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">攻防世界新手练习区——unseping</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>