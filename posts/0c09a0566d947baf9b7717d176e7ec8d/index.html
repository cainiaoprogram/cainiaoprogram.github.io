<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>policy机制中经典的python用法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="policy机制中经典的python用法" />
<meta property="og:description" content="由于接触python时间还不长，属于边用边学，在看项目代码的时候，遇到了很多不太懂的python语法，但是我认为这些用法用的实在是好，希望以后自己在写程序时，也能写出这么经典的代码，在这里记录下来这些：
1. 将函数名作为参数传递给另一个模块中的函数使用：
def init(): ...... #read_cached_file做的事是读取_POLICY_PATH文件中的数据，和这个文件修改的时间，保存到_POLICY_CACHE字典中， #然后使用_set_rules(data)来解析这些数据，最后返回这些数据。 utils.read_cached_file(_POLICY_PATH, _POLICY_CACHE, reload_func=_set_rules) def _set_rules(data): default_rule = CONF.policy_default_rule policy.set_rules(policy.Rules.load_json(data, default_rule)) 2. 类方法的使用
class Rules(dict): @classmethod def load_json(cls, data, default_rule=None): rules = dict((k, parse_rule(v)) for k, v in jsonutils.loads(data).items()) return cls(rules, default_rule)以前一直弄不清楚类方法和静态方法的区别，都是通过类名去调用，但是现在清楚了，类方法有一个很好的特性，就是它可以在创建类对象之前，做一些初始化的工作，这样创建的对象，比直接调用Rules()，更灵活。 这里还想说一下继承自dict这个特性，通过覆盖父类中的方法，__missing__()，__str__()等定制了一个自己的字典类型，用起来很舒服啊。
3. 解释器的使用
_checks = {} def register(name, func=None): def decorator(func): _checks[name] = func return func if func: return decorator(func) return decorator @register(&#34;rule&#34;) class RuleCheck(Check): pass @register(&#34;role&#34;) class RoleCheck(Check): pass 文档在加载的时候，每遇到一个@register()修饰符，就会将被修饰的类添加到_check变量中，简洁方便。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0c09a0566d947baf9b7717d176e7ec8d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-11-30T12:33:27+08:00" />
<meta property="article:modified_time" content="2012-11-30T12:33:27+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">policy机制中经典的python用法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>由于接触python时间还不长，属于边用边学，在看项目代码的时候，遇到了很多不太懂的python语法，但是我认为这些用法用的实在是好，希望以后自己在写程序时，也能写出这么经典的代码，在这里记录下来这些：</p> 
<p>1. 将函数名作为参数传递给另一个模块中的函数使用：</p> 
<pre><code class="language-python">def init():
    ......
    #read_cached_file做的事是读取_POLICY_PATH文件中的数据，和这个文件修改的时间，保存到_POLICY_CACHE字典中，
    #然后使用_set_rules(data)来解析这些数据，最后返回这些数据。
    utils.read_cached_file(_POLICY_PATH, _POLICY_CACHE,
                           reload_func=_set_rules)
 
def _set_rules(data):
    default_rule = CONF.policy_default_rule
    policy.set_rules(policy.Rules.load_json(data, default_rule))</code></pre> 
<br> 
<p>2. 类方法的使用</p> 
<p></p> 
<pre><code class="language-python">class Rules(dict):
    @classmethod
    def load_json(cls, data, default_rule=None):
 
        rules = dict((k, parse_rule(v)) for k, v in
                     jsonutils.loads(data).items())
 
        return cls(rules, default_rule)</code></pre>以前一直弄不清楚类方法和静态方法的区别，都是通过类名去调用，但是现在清楚了，类方法有一个很好的特性，就是它可以在创建类对象之前，做一些初始化的工作，这样创建的对象，比直接调用Rules()，更灵活。 
<br> 
<p>这里还想说一下继承自dict这个特性，通过覆盖父类中的方法，__missing__()，__str__()等定制了一个自己的字典类型，用起来很舒服啊。</p> 
<p><br> </p> 
<p></p> 
<p>3. 解释器的使用</p> 
<p></p> 
<pre><code class="language-python">_checks = {}
 
def register(name, func=None):
    def decorator(func):
        _checks[name] = func
        return func
    if func:
        return decorator(func)
 
    return decorator
 
@register("rule")
class RuleCheck(Check):
    pass
 
@register("role")
class RoleCheck(Check):
    pass</code></pre> 
<p>文档在加载的时候，每遇到一个@register()修饰符，就会将被修饰的类添加到_check变量中，简洁方便。</p> 
<p><br> </p> 
<p></p> 
<p>4. yield的使用<br> yield在我看来，是一种能够间断的循环，一直都不太会用它，policy中在解析复合rule时，就用到了yield:</p> 
<p></p> 
<pre><code class="language-python">state = ParseState() 
    for tok, value in _parse_tokenize(rule):
        state.shift(tok, value)
 
# 这个函数主要是将规则的字符串进行了一下预处理，然后调用_parse_check()最终将字符串转换成BaseCheck对象
def _parse_tokenize(rule):
    #这段代码的意思是将一个字符串以空格为间隔，重组为一个字符串的列表，如：
    # a.split('(is_admin:True or project_id:%(project_id)s)')
    # ['(is_admin:True', 'or', 'project_id:%(project_id)s)']
    for tok in _tokenize_re.split(rule):
        # Skip empty tokens
        if not tok or tok.isspace():
            continue
 
        # Handle leading parens on the token
        clean = tok.lstrip('(')
        for i in range(len(tok) - len(clean)):
            yield '(', '('
 
        # If it was only parentheses, continue
        if not clean:
            continue
        else:
            tok = clean
 
        # Handle trailing parens on the token
        clean = tok.rstrip(')')
        trail = len(tok) - len(clean)
 
        # Yield the cleaned token
        lowered = clean.lower()
        if lowered in ('and', 'or', 'not'):
            # Special tokens
            yield lowered, clean
        elif clean:
            # Not a special token, but not composed solely of ')'
            if len(tok) &gt;= 2 and ((tok[0], tok[-1]) in
                                  [('"', '"'), ("'", "'")]):
                # It's a quoted string
                yield 'string', tok[1:-1]
            else:
                yield 'check', _parse_check(clean)
 
        # Yield the trailing parens
        for i in range(trail):
            yield ')', ')'</code></pre>程序中每遇到一个yield，就会中断当前的执行，返回值，然后由外部的for循环进行处理，处理完之后，再回到刚才中断的地方继续执行。 
<p><br> </p> 
<p>5. 元类的使用<br> 元类以前从来没有接触过，policy里也用到了，还是在解析复合rule的时候，用的这个元类：ParseStateMeta，通过使用元类，可以自定义某些类是如何创建的，从根本上说赋予你如何创建类的控制权：</p> 
<pre><code class="language-python">class ParseStateMeta(type):
    # name是子类的类名，bases是子类的数据，cls_dict是子类中的属性
    def __new__(cls, name, bases, cls_dict):
 
        reducers = []
 
        # key为属性名，value为属性的对象，如：
        # shift : &lt;function shift at 0xa27b4fc&gt;
        # _make_not_expr : &lt;function _make_not_expr at 0xa27b6bc&gt;
        for key, value in cls_dict.items():
            if not hasattr(value, 'reducers'):# 如果没有包含reducers属性，即那些没有@reducer修饰的方法
                continue
            for reduction in value.reducers:# 遍历某个函数中的reducers列表，把它添加到元类中的reducers列表中
                reducers.append((reduction, key))
 
        cls_dict['reducers'] = reducers
        return super(ParseStateMeta, cls).__new__(cls, name, bases, cls_dict)
 
# 虽然只是简单的定义了一个ParseState对象，但是却做了很多的事：
# 1.@reducer修饰器给被装饰的的方法添加了reducers列表，并且将修饰器的参数建成一个列表添加到该列表中;
#   --&gt;形式如：[['','',''],['','','']],
#        再如：[['(', 'or_expr', ')'], ['(', 'and_expr', ')'], ['(', 'check', ')']]
# 2.ParseStateMeta元类创建了一个reducers变量（针对于ParseState是全局的），也是一个列表,
#   然后遍历了ParseState的所有属性，找到有reducers属性的属性(即带有@reducer的方法)，
#   然后再遍历该方法的reducers列表，将列表的每一项和该方法的名字组合成一个元组，存放在reducers变量中;
#   --&gt;形式如：[(['','',''],funcname),(['','',''],funcname),(['','',''],funcname)]
#       再如：[(['check', 'or', 'check'], '_make_or_expr'), (['or_expr', 'or', 'check'], '_extend_or_expr')]
class ParseState(object):
    __metaclass__ = ParseStateMeta
    ......</code></pre> 
<br> 6. 递归的使用 
<p></p> 
<pre><code class="language-python">    def reduce(self):
        #a[-3:]表示a这个列表的最后三个数
        for reduction, methname in self.reducers:
            # 如果当前的tokens的长度大于reduction的长度，并且tokens的最后几个和reduction相同
            # 即模式匹配，则调用相应的方法来进行复合判断
            # 什么情况不执行这段呢？
            # 1. 没有复合的规则
            # 2. 复合的规则和reduction不匹配
            # 这两种情况下，就不执行复合，直接返回的还是原来的对象：RuleCheck, RoleCheck, HttpCheck, GenericCheck
            # 如果复合的话，返回的是复合对象：OrCheck, AndCheck, NotCheck
            if (len(self.tokens) &gt;= len(reduction) and
                self.tokens[-len(reduction):] == reduction):
                    # Get the reduction method
                    meth = getattr(self, methname)
 
                    # Reduce the token stream
                    # 有两个GenericCheck对象和一个‘or’，传递给_make_or_expr()方法，用这两个
                    # 对象构造了一个OrCheck对象，该对象的返回值，是按照这两个GenericCheck对象在的
                    # target和creds上能否执行的真假来进行或操作得到的
                    results = meth(*self.values[-len(reduction):])
 
                    # Update the tokens and values
                    self.tokens[-len(reduction):] = [r[0] for r in results]
                    self.values[-len(reduction):] = [r[1] for r in results]
 
                    # Check for any more reductions
                    return self.reduce()</code></pre> 
<br> another url: 
<a href="http://freedomhui.com/2012/11/policy%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%BB%8F%E5%85%B8%E7%9A%84python%E7%94%A8%E6%B3%95/?lang=zh-hans" rel="nofollow"> http://freedomhui.com/2012/11/policy%E6%9C%BA%E5%88%B6%E4%B8%AD%E7%BB%8F%E5%85%B8%E7%9A%84python%E7%94%A8%E6%B3%95/?lang=zh-hans</a> 
<br> 
<p></p> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c63943c7f2a9265290bf484b83434d8c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">UE 汇编语法高亮文件新版 与 UE 常用技巧</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b32d73e56ec99bc5ec8f83871cde708a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">another</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>