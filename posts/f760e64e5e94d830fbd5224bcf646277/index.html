<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java客户端调用webservice - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java客户端调用webservice" />
<meta property="og:description" content="最近的工作是java和c&#43;&#43;的交互，利用的就是webservice；博客中介绍了如何利用java生成webservice，这篇博客接着说如何利用java调用webservice。
我主要用的是axis2工具来实现java的webservice调用。
我比较常用的两种方法一个是直接利用RPCServiceClient的invokeBlocking方法，另外一种是OMAbstractFactory的createOMElement方法。其实这两种方式本质是一样的都是处理xml。因为webservice的基石就是xml。如果你用一个抓包工具来查看相关传输协议的传输信息的话，你会发现，其实这两种方式的执行过程都是通过互相传送xml数据来进行相关的webservice方法调用的。
主要过程就是java通过上面的方法把webservice的xml信息接收到，之后在把调用方法的参数信息填写到xml中，之后webservice服务端就通过你所填写的参数，执行相应的方法，返回相应的数据到xml中，之后java客户端进行解析之后获得相应的数据。这就是简单的一个执行流程。
知道执行流程之后，我们就要说说这两种方法的具体使用了。
首先导入jar是必须的，还是axis2的jar，不介绍怎么弄了，比较简单。
第一种方法：
RPCServiceClient serviceClient = newRPCServiceClient(); Optionsoptions = serviceClient.getOptions(); EndpointReferencetargetEPR = new EndpointReference(url); options.setTo(targetEPR); // 在创建QName对象时，QName类的构造方法的第一个参数表示WSDL文件的命名空间名，也就是&lt;wsdl:definitions&gt;元素的targetNamespace属性值 QName opAddEntry = new QName(&#34;http://service.wf.cypheta.com&#34;,method); 主要是建立RPCServiceClient客户对象，通过这个对象我们能够通过传入相应的webservice地址完成我们相应接口的调用。上面的url就是我们要传入的webservice的url。之后我们要建立QName对象，QName其实说白了就是有着特定格式的xml元素（命名空间&#43;特定元素），我们通过传入命名空间和特定元素（这里是我们要调用的方法）之后定位到我们要执行方法的xml文件信息。
随后就是定义传入参数和返回值信息：
Object[] opAddEntryArgs = new Object[]{481L}; // 返回参数类型，这个和axis1有点区别 // invokeBlocking方法有三个参数，其中第一个参数的类型是QName对象，表示要调用的方法名； // 第二个参数表示要调用的WebService方法的参数值，参数类型为Object[]； // 第三个参数表示WebService方法的返回值类型的Class对象，参数类型为Class[]。 // 当方法没有参数时，invokeBlocking方法的第二个参数值不能是null，而要使用new Object[]{} // 如果被调用的WebService方法没有返回值，应使用RPCServiceClient类的invokeRobust方法， // 该方法只有两个参数，它们的含义与invokeBlocking方法的前两个参数的含义相同 Class[] classes = new Class[] {String.class }; /* Object[] object=serviceClient.invokeBlocking(opAddEntry,opAddEntryArgs,classes); for(int i=0;i&lt;object.length;i&#43;&#43;){ System.out.println(object[i]); }*/ System.out.println(serviceClient.invokeBlocking(opAddEntry,opAddEntryArgs,classes)[0].toString()); 最后通过invokeBlocking方法获得一个对象数组，这里面它已经给我封装好了xml交互的操作，所以我们非常轻松的就能够调用webservice接口并且获得我们相应的数据。
第二种方法：
这种方法主要是自己动手来实现xml的交互：这里面包括四部分：1、设置发送请求的URL；2、设置调用的webservice地址；3、获得返回的xml数据；4、利用dom4j解析webservice返回的数据。
第一步：
OMFactory fac = OMAbstractFactory." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f760e64e5e94d830fbd5224bcf646277/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2012-09-18T08:47:54+08:00" />
<meta property="article:modified_time" content="2012-09-18T08:47:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java客户端调用webservice</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><span style="font-size:14px;">         最近的工作是java和c++的交互，利用的就是webservice；博客中介绍了如何利用java生成webservice，这篇博客接着说如何利用java调用webservice。</span></p> 
<p><span style="font-size:14px;">        我主要用的是axis2工具来实现java的webservice调用。</span></p> 
<p><span style="font-size:14px;">        我比较常用的两种方法一个是直接利用RPCServiceClient的invokeBlocking</span><span style="font-size:14px;color:black;">方法，另外一种是OMAbstractFactory</span><span style="font-size:14px;">的createOMElement方法。其实这两种方式本质是一样的都是处理xml。因为webservice的基石就是xml。如果你用一个抓包工具来查看相关传输协议的传输信息的话，你会发现，其实这两种方式的执行过程都是通过互相传送xml数据来进行相关的webservice方法调用的。</span></p> 
<p><span style="font-size:14px;color:black;">         主要过程就是java</span><span style="font-size:14px;">通过上面的方法把webservice的xml信息接收到，之后在把调用方法的参数信息填写到xml中，之后webservice服务端就通过你所填写的参数，执行相应的方法，返回相应的数据到xml中，之后java客户端进行解析之后获得相应的数据。这就是简单的一个执行流程。</span></p> 
<p><span style="font-size:14px;color:black;">         知道执行流程之后，我们就要说说这两种方法的具体使用了。</span></p> 
<p><span style="font-size:14px;color:black;">         首先导入jar</span><span style="font-size:14px;">是必须的，还是axis2的jar，不介绍怎么弄了，比较简单。</span></p> 
<p><span style="font-size:14px;color:black;">         第一种方法：</span></p> 
<pre><code class="language-java">                     RPCServiceClient serviceClient = newRPCServiceClient();

                     Optionsoptions = serviceClient.getOptions();

                     EndpointReferencetargetEPR = new EndpointReference(url);

                     options.setTo(targetEPR);

                     // 在创建QName对象时，QName类的构造方法的第一个参数表示WSDL文件的命名空间名，也就是&lt;wsdl:definitions&gt;元素的targetNamespace属性值

                      QName opAddEntry = new QName("http://service.wf.cypheta.com",method);</code></pre> 
<br> 
<br> 
<p><span style="color:black;"> </span></p> 
<p><span style="font-size:14px;color:black;">        主要是建立RPCServiceClient</span><span style="font-size:14px;">客户对象，通过这个对象我们能够通过传入相应的webservice地址完成我们相应接口的调用。上面的url就是我们要传入的webservice的url。之后我们要建立QName对象，QName其实说白了就是有着特定格式的xml元素（命名空间+特定元素），我们通过传入命名空间和特定元素（这里是我们要调用的方法）之后定位到我们要执行方法的xml文件信息。</span></p> 
<p><span style="font-size:14px;color:black;">        随后就是定义传入参数和返回值信息：</span></p> 
<p align="left"><span style="color:black;">                     </span></p> 
<pre><code class="language-java"><span style="color:black;">                      Object[] opAddEntryArgs = new Object[]{481L};

                      // 返回参数类型，这个和axis1有点区别

                      // invokeBlocking方法有三个参数，其中第一个参数的类型是QName对象，表示要调用的方法名；

                      // 第二个参数表示要调用的WebService方法的参数值，参数类型为Object[]；

                      // 第三个参数表示WebService方法的返回值类型的Class对象，参数类型为Class[]。

                      // 当方法没有参数时，invokeBlocking方法的第二个参数值不能是null，而要使用new Object[]{}

                      // 如果被调用的WebService方法没有返回值，应使用RPCServiceClient类的invokeRobust方法，

                      // 该方法只有两个参数，它们的含义与invokeBlocking方法的前两个参数的含义相同

                      Class[] classes = new Class[] {String.class };

                      /*                Object[] object=serviceClient.invokeBlocking(opAddEntry,opAddEntryArgs,classes);

                      for(int i=0;i&lt;object.length;i++){

                             System.out.println(object[i]);

                      }*/

                      System.out.println(serviceClient.invokeBlocking(opAddEntry,opAddEntryArgs,classes)[0].toString());</span></code></pre> 
<span style="color:black;"><br><br></span> 
<p><span style="font-size:14px;color:black;">         最后通过invokeBlocking</span><span style="font-size:14px;">方法获得一个对象数组，这里面它已经给我封装好了xml交互的操作，所以我们非常轻松的就能够调用webservice接口并且获得我们相应的数据。</span></p> 
<p><span style="font-size:14px;color:black;"> </span></p> 
<p><span style="font-size:14px;color:black;">        第二种方法：</span></p> 
<p><span style="font-size:14px;color:black;">         这种方法主要是自己动手来实现xml</span><span style="font-size:14px;">的交互：这里面包括四部分：1、设置发送请求的URL；2、设置调用的webservice地址；3、获得返回的xml数据；4、利用dom4j解析webservice返回的数据。</span></p> 
<p><span style="font-size:14px;color:black;">第一步：</span></p> 
<pre><code class="language-java">              OMFactory fac = OMAbstractFactory.getOMFactory();

              OMNamespaceomNs =fac.createOMNamespace("http://www.primeton.com/WSProcessInstManagerService", ""); // 命名空间

              OMElementdata = fac.createOMElement(method, omNs);// 获得要调用的方法名

              if(params.length!=0){

                     for (int i = 0; i&lt; params.length; i++) {

                            OMElementinner = fac.createOMElement(params[i], omNs); // 获得该方法名要调用的参数名

                            inner.setText(String.valueOf(paramValues[i]));// 输入参数

                            data.addChild(inner);

                     }

              }

              // 将该参数加入要调用的方法节点

              return data;</code></pre> 
<br> 
<br> 
<p><span style="font-size:14px;color:black;">         这一步主要是设置发送请求的url</span><span style="font-size:14px;">，也就是我们要设置我们要调用的方法和要传入的参数，从上面代码我们能够看出，我们首先要创建这样一个xml文件，主要包含的数据就是命名空间和方法名称还有就是方法的参数信息</span></p> 
<p><span style="font-size:14px;color:black;">         第二步：</span></p> 
<pre><code class="language-java">              Options options = newOptions();

              options.setSoapVersionURI(SOAP11Constants.SOAP_ENVELOPE_NAMESPACE_URI);

              options.setAction("http://www.primeton.com/WSProcessInstManagerService" +method); // 设置调用的命名空间加方法

              options.setTo(targetAirline);

              options.setTransportInProtocol(Constants.TRANSPORT_HTTP); // 设置传输协议

              return options;</code></pre> 
<br> 
<br> 
<p><span style="font-size:14px;color:black;">         这部分主要是设置调用的webservice</span><span style="font-size:14px;">地址，这一步和上面那种方法的前三句代码是一个作用，都是把调用的webservice的url设置好。</span></p> 
<p><span style="font-size:14px;color:black;">         第三步：</span></p> 
<pre><code class="language-java">              try {

                     ServiceClientsender = new ServiceClient();

                     sender.setOptions(buildOptions(method));

                     OMElementresult = sender.sendReceive(buildParam(params,

                                   paramValues,method));

                     System.out.println("解析之前的数据：" +result.toString());

                     returnresult.toString();

              } catch(Exception e) {

                     e.printStackTrace();

                     System.out.println("调用出错！");

                     return"调用出错！";

              }</code></pre> 
<br> 
<br> 
<p><span style="font-size:14px;color:black;">          这一步主要是完成相关方法的调用，将我们之前设置好的要发送的xml</span><span style="font-size:14px;">信息发送给我们的webservice，webservice通过解析我们的xml请求，执行相应的方法，返回相应的信息，这个信息是以xml的形式返回出来的。</span></p> 
<p><span style="font-size:14px;color:black;">          最后一步：</span></p> 
<pre><code class="language-java">              try {

                     Documentdoc = DocumentHelper.parseText(getResultByCode(params,

                                   paramValues,method));

                     Elementroot = doc.getRootElement();

                     Elementrn = root.element("s"); // 节点名

                     System.out.println(rn.getData());

                     return (String)rn.getData();

              } catch(DocumentException e) {

                     // TODOAuto-generated catch block

                     e.printStackTrace();

                     System.out.println("解析出错！");

                     return"解析出错！";

              }</code></pre> 
<br> 
<br> 
<p><span style="font-size:14px;color:black;">         这一步就是我们通过dom4j</span><span style="font-size:14px;">来解析我们所需要的数据了。这个就不详细介绍了。</span></p> 
<p><span style="font-size:14px;color:black;"> </span></p> 
<p><span style="font-size:14px;color:black;">         到这一步之后我们就通过java</span><span style="font-size:14px;">成功调用了webservice。其实不是非常困难，主要还是原理上明白怎么个处理流程。</span></p> 
<p><span style="font-size:14px;color:black;"> </span></p> 
<p><span style="font-size:14px;color:black;">         希望通过这两篇博客的整理，大家能够会使用axis2</span><span style="font-size:14px;">创建webservice和利用axis2调用webservice！</span></p> 
<br> 
<br>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/adef27219bb3dbbcfa9df69881ece6fc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python面试题目</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9670b28f02d21b2194eabac40d8d9778/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ping命令返回错误信息说明</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>