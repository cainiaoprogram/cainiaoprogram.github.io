<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AIGC系列之：Transformer原理及论文解读 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AIGC系列之：Transformer原理及论文解读" />
<meta property="og:description" content="目录
模型概述
Transformer输入
Word Embedding
Positional Encoding
Transformer的输出
Self Attention
Multi-Head Attention
Encoder结构
最后层的输出
Masked Multi-Head Attention
Decoder输入
Decoder的输出
Transformer训练和推理过程
《Attention is All You Need》
论文地址：https://arxiv.org/abs/1706.03762
原理解读：https://blog.csdn.net/m0_47256162/article/details/127339899
本文的内容参考来自👆这篇博客，感谢博主的辛苦工作～
模型概述 Transformer模块主要包含Encoders和Decoders两个部分
Transformer输入 以一个翻译的例子理解transformer原理过程：
整个模型的输入是中文我爱你，目标是将其翻译成英文的I love you，但是对于中文我爱你模型是无法训练的，要将其数值化再送入模型当中。将中文转成数值一般有两种方法：
One Hot编码：形成高维向量，向量的维度为词袋大小，如果是中文，向量的维度就是所有汉字的数量，然后是哪个字就将对应位置变为1，其它位置为0。
Embedding词嵌入：通过网络进行训练或者通过一些训练好的模型将其转化成连续性的向量。（常用）
Word Embedding Embedding可以使用一些预训练好的模型比如word2vec得到，通过Embedding会将每个字形成一个连续型向量，这里假设嵌入维度为5，所以是使用一个维度为5的向量来表示一个字。嵌入后输入的向量维度为[序列长度, 嵌入维度], [3, 5]。
Positional Encoding 由于Transformer中使用的是自注意力机制来提取信息，虽然处理每个字的时候能够考虑到所有字对其的影响，但是并没有考虑到各个字相互之间的位置信息，也就是上下文，例如如果输入序列变为爱我你，如果仅使用自注意力机制那么输出应该是一样的，所以需要添加整个序列的位置信息。
在Transformer中使用的是位置编码来表示单词的顺序信息，位置信息也是通过Embedding进行表示，对于位置编码来说有两种方式可以得到：
通过Embedding进行训练
通过公式计算
Transformer中使用公式将每个位置信息进行编码，然后将这个编码信息和对应位置词的编码进行相加，让自注意力机制同时考虑词的顺序信息，同时又可考虑到所有输入的词。
Transformer的输出 对于Transformer的输出就是翻译出的：I love you，由于需要预测出每个字需要翻译为哪个词，所以这是个多分类问题（Softmax），相当于做词个数个多分类问题，每个位置对应的输出的维度应为所有单词的个数，每个维度对应预测为该词的概率，概率最大位置对应的词就是该位置预测出翻译的词。输出n个词，每个词对应的维度为词袋的个数，第一个位置预测为I，说明对应该向量I单词对应的概率最大。
Self Attention Transformer中最重要的模块就是自注意力机制，Self-Attention自注意力机制有三个输入，分别是Q（查询）、K（键）、V（值）。经过注意力机制后就会得到词个数个新的编码向量，新的编码向量由于采用了注意力机制就会考虑到其它词对其的影响，影响程度就由注意力分数所影响。
注意力机制有几个步骤：
根据输入向量x计算对应q、k、v
用自己的查询向量q和其它词的k做点积来计算注意力分数
将得到的注意力分数进行Softmax
将注意力分数与各个词的v向量相乘得到加权表示向量
为了得到Q、K、V，需要使用三个不同的权重矩阵，然后与输入矩阵相乘，然后将输入矩阵X映射到一个新的维度空间，然后就可以利用得到的Q、K、V计算相应的注意力分数和加权向量。得到的Q、K、V行代表的是每个词，就是每个词对应的q向量。
由上面可知Q、K、V矩阵，然后利用Q和K相乘得到不同词之间的注意力分数。
为了提高并行度，利用矩阵进行运算，将Q和K的转置相乘，这样就会得到一个方型矩阵，矩阵的每个元素代表每个词对其它词的注意力分数。
然后对得到的注意力分数进行Softmax操作来归一化，这样每一行的分数加起来就为1。然后利用归一化后的注意力分数然后与V进行相乘得到各个词的加权向量，得到的Z每一行代表每个词的新的编码向量。
Multi-Head Attention Transformer中采用的是Multi-Head Attention（多头注意力机制），它可以类比CNN中的多个kernel，CNN中每个kernel可以理解为提取不同模式的特征图，所以这里也引入了这个机制，不同的头可以提取出不同的语义信息。多头注意力机制就是采用了多个的Self-Attention，这样每一次就会得到多组的Z，比如这里我们设置头的个数为8，那么我们就会得到8个Z矩阵。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9362a53e865edfb136de31c749e98620/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-27T18:06:41+08:00" />
<meta property="article:modified_time" content="2023-11-27T18:06:41+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AIGC系列之：Transformer原理及论文解读</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0-toc" style="margin-left:80px;"><a href="#%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0" rel="nofollow">模型概述</a></p> 
<p id="Transformer%E8%BE%93%E5%85%A5-toc" style="margin-left:80px;"><a href="#Transformer%E8%BE%93%E5%85%A5" rel="nofollow">Transformer输入</a></p> 
<p id="Word%20Embedding-toc" style="margin-left:80px;"><a href="#Word%20Embedding" rel="nofollow">Word Embedding</a></p> 
<p id="Positional%20Encoding-toc" style="margin-left:80px;"><a href="#Positional%20Encoding" rel="nofollow">Positional Encoding</a></p> 
<p id="Transformer%E7%9A%84%E8%BE%93%E5%87%BA-toc" style="margin-left:80px;"><a href="#Transformer%E7%9A%84%E8%BE%93%E5%87%BA" rel="nofollow">Transformer的输出</a></p> 
<p id="Self%20Attention-toc" style="margin-left:80px;"><a href="#Self%20Attention" rel="nofollow">Self Attention</a></p> 
<p id="Multi-Head%20Attention-toc" style="margin-left:80px;"><a href="#Multi-Head%20Attention" rel="nofollow">Multi-Head Attention</a></p> 
<p id="Encoder%E7%BB%93%E6%9E%84-toc" style="margin-left:80px;"><a href="#Encoder%E7%BB%93%E6%9E%84" rel="nofollow">Encoder结构</a></p> 
<p id="%E6%9C%80%E5%90%8E%E5%B1%82%E7%9A%84%E8%BE%93%E5%87%BA-toc" style="margin-left:80px;"><a href="#%E6%9C%80%E5%90%8E%E5%B1%82%E7%9A%84%E8%BE%93%E5%87%BA" rel="nofollow">最后层的输出</a></p> 
<p id="Masked%20Multi-Head%20Attention-toc" style="margin-left:80px;"><a href="#Masked%20Multi-Head%20Attention" rel="nofollow">Masked Multi-Head Attention</a></p> 
<p id="Decoder%E8%BE%93%E5%85%A5-toc" style="margin-left:80px;"><a href="#Decoder%E8%BE%93%E5%85%A5" rel="nofollow">Decoder输入</a></p> 
<p id="Decoder%E7%9A%84%E8%BE%93%E5%87%BA-toc" style="margin-left:80px;"><a href="#Decoder%E7%9A%84%E8%BE%93%E5%87%BA" rel="nofollow">Decoder的输出</a></p> 
<p id="Transformer%E8%AE%AD%E7%BB%83%E5%92%8C%E6%8E%A8%E7%90%86%E8%BF%87%E7%A8%8B-toc" style="margin-left:80px;"><a href="#Transformer%E8%AE%AD%E7%BB%83%E5%92%8C%E6%8E%A8%E7%90%86%E8%BF%87%E7%A8%8B" rel="nofollow">Transformer训练和推理过程</a></p> 
<hr id="hr-toc"> 
<p></p> 
<p>《Attention is All You Need》</p> 
<p>论文地址：<a href="https://arxiv.org/abs/1706.03762" rel="nofollow" title="https://arxiv.org/abs/1706.03762">https://arxiv.org/abs/1706.03762</a></p> 
<p>原理解读：<a class="link-info" href="https://blog.csdn.net/m0_47256162/article/details/127339899" title="https://blog.csdn.net/m0_47256162/article/details/127339899">https://blog.csdn.net/m0_47256162/article/details/127339899</a></p> 
<p>本文的内容参考来自👆这篇博客，感谢博主的辛苦工作～</p> 
<h4 id="%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0">模型概述</h4> 
<p>Transformer模块主要包含Encoders和Decoders两个部分</p> 
<p><img alt="" height="1182" src="https://images2.imgbox.com/88/a3/dGkKq6zK_o.png" width="750"></p> 
<h4 id="Transformer%E8%BE%93%E5%85%A5">Transformer输入</h4> 
<p>        以一个翻译的例子理解transformer原理过程：</p> 
<p><img alt="" height="874" src="https://images2.imgbox.com/c3/7e/ouIrU8jt_o.png" width="1200"></p> 
<p>        整个模型的输入是中文我爱你，目标是将其翻译成英文的I love you，但是对于中文我爱你模型是无法训练的，要将其数值化再送入模型当中。将中文转成数值一般有两种方法：</p> 
<ul><li> <p>One Hot编码：形成高维向量，向量的维度为词袋大小，如果是中文，向量的维度就是所有汉字的数量，然后是哪个字就将对应位置变为1，其它位置为0。</p> </li><li> <p>Embedding词嵌入：通过网络进行训练或者通过一些训练好的模型将其转化成连续性的向量。（常用）</p> </li></ul> 
<h4 id="Word%20Embedding">Word Embedding</h4> 
<p>        Embedding可以使用一些预训练好的模型比如word2vec得到，通过Embedding会将每个字形成一个连续型向量，这里假设嵌入维度为5，所以是使用一个维度为5的向量来表示一个字。嵌入后输入的向量维度为[序列长度, 嵌入维度], [3, 5]。</p> 
<p><img alt="" height="416" src="https://images2.imgbox.com/5f/06/Ucte5qwU_o.png" width="1200"></p> 
<h4 id="Positional%20Encoding">Positional Encoding</h4> 
<p>        由于Transformer中使用的是自注意力机制来提取信息，虽然处理每个字的时候能够考虑到所有字对其的影响，但是并没有考虑到各个字相互之间的位置信息，也就是上下文，例如如果输入序列变为爱我你，如果仅使用自注意力机制那么输出应该是一样的，所以需要添加整个序列的位置信息。</p> 
<p>        在Transformer中使用的是位置编码来表示单词的顺序信息，位置信息也是通过Embedding进行表示，对于位置编码来说有两种方式可以得到：</p> 
<ul><li> <p>通过Embedding进行训练</p> </li><li> <p>通过公式计算</p> </li></ul> 
<p><img alt="" height="230" src="https://images2.imgbox.com/ac/c0/Eb1NW1Zp_o.png" width="1200"></p> 
<p></p> 
<p>        Transformer中使用公式将每个位置信息进行编码，然后将这个编码信息和对应位置词的编码进行相加，让自注意力机制同时考虑词的顺序信息，同时又可考虑到所有输入的词。</p> 
<p><img alt="" height="276" src="https://images2.imgbox.com/f9/09/L6tx6X3I_o.png" width="1200"></p> 
<h4 id="Transformer%E7%9A%84%E8%BE%93%E5%87%BA">Transformer的输出</h4> 
<p>        对于Transformer的输出就是翻译出的：I love you，由于需要预测出每个字需要翻译为哪个词，所以这是个多分类问题（Softmax），相当于做词个数个多分类问题，每个位置对应的输出的维度应为所有单词的个数，每个维度对应预测为该词的概率，概率最大位置对应的词就是该位置预测出翻译的词。输出n个词，每个词对应的维度为词袋的个数，第一个位置预测为I，说明对应该向量I单词对应的概率最大。</p> 
<p><img alt="" height="429" src="https://images2.imgbox.com/87/9c/RziSkcVh_o.png" width="1200"></p> 
<h4 id="Self%20Attention">Self Attention</h4> 
<p>        Transformer中最重要的模块就是自注意力机制，Self-Attention自注意力机制有三个输入，分别是Q（查询）、K（键）、V（值）。经过注意力机制后就会得到词个数个新的编码向量，新的编码向量由于采用了注意力机制就会考虑到其它词对其的影响，影响程度就由注意力分数所影响。</p> 
<p><img alt="" height="820" src="https://images2.imgbox.com/51/09/u7Wx89Lh_o.png" width="1200"></p> 
<p>注意力机制有几个步骤：</p> 
<ol><li> <p>根据输入向量x计算对应q、k、v</p> </li><li> <p>用自己的查询向量q和其它词的k做点积来计算注意力分数</p> </li><li> <p>将得到的注意力分数进行Softmax</p> </li><li> <p>将注意力分数与各个词的v向量相乘得到加权表示向量</p> </li></ol> 
<p>        为了得到Q、K、V，需要使用三个不同的权重矩阵，然后与输入矩阵相乘，然后将输入矩阵X映射到一个新的维度空间，然后就可以利用得到的Q、K、V计算相应的注意力分数和加权向量。得到的Q、K、V行代表的是每个词，就是每个词对应的q向量。</p> 
<p><img alt="" height="1077" src="https://images2.imgbox.com/ed/50/R9aDolK0_o.png" width="1200"></p> 
<p>由上面可知Q、K、V矩阵，然后利用Q和K相乘得到不同词之间的注意力分数。</p> 
<p><img alt="" height="388" src="https://images2.imgbox.com/9b/47/94Kdk0Mh_o.png" width="1200"></p> 
<p>        为了提高并行度，利用矩阵进行运算，将Q和K的转置相乘，这样就会得到一个方型矩阵，矩阵的每个元素代表每个词对其它词的注意力分数。</p> 
<p><img alt="" height="552" src="https://images2.imgbox.com/a3/07/lM4Si83S_o.png" width="1200"></p> 
<p>        然后对得到的注意力分数进行Softmax操作来归一化，这样每一行的分数加起来就为1。然后利用归一化后的注意力分数然后与V进行相乘得到各个词的加权向量，得到的Z每一行代表每个词的新的编码向量。</p> 
<p><img alt="" height="327" src="https://images2.imgbox.com/60/53/msoCT4wW_o.png" width="1200"></p> 
<h4 id="Multi-Head%20Attention">Multi-Head Attention</h4> 
<p>        Transformer中采用的是Multi-Head Attention（多头注意力机制），它可以类比CNN中的多个kernel，CNN中每个kernel可以理解为提取不同模式的特征图，所以这里也引入了这个机制，不同的头可以提取出不同的语义信息。多头注意力机制就是采用了多个的Self-Attention，这样每一次就会得到多组的Z，比如这里我们设置头的个数为8，那么我们就会得到8个Z矩阵。</p> 
<p class="img-center"><img alt="" height="535" src="https://images2.imgbox.com/d6/dd/GyILVg3B_o.png" width="573"></p> 
<p>        将输入向量X分别送入8个不同的头中，就是8个不同的自注意力机制模块，每个模块拥有自己的参数(Wq, Wk, Wv)。得到了8个输出矩阵Z1，Z2…Z8之后，然后把这个8个矩阵拼接起来，然后利用全连接网络将其映射成一个与输入向量X形状一致的矩阵。Multi-Head Attention输出的矩阵Z和输入矩阵X的维度是一致的。</p> 
<p><img alt="" height="616" src="https://images2.imgbox.com/2e/d4/L0kdN8ic_o.png" width="1200"></p> 
<h4 id="Encoder%E7%BB%93%E6%9E%84">Encoder结构</h4> 
<p>        Encoder是由Multi-Head Attention、Add &amp; Norm、Feed Forward、Add &amp; Norm四个小模块组成。</p> 
<p><img alt="" height="1058" src="https://images2.imgbox.com/ee/61/m4LNhpNh_o.png" width="852"></p> 
<p>        多头注意力机制会得到8个输出，每个输出维度为[3,5], 然后经过多头注意力机制进行特征提取，会得到多个输出Z向量，也就是每个头提取出不同模式的矩阵，维度是[词个数，隐向量维度]。</p> 
<p><img alt="" height="610" src="https://images2.imgbox.com/7a/ad/g45wdlfb_o.png" width="1200"></p> 
<p>        将各个头对应的Z矩阵进行拼接，形成一个大矩阵维度为[词个数, 头个数*隐向量维度]，然后将其喂入一个全连接网络，然后会映射成为一个与输入向量形状一致的Z矩阵，这样目的就是能够保持最终的输出向量和输入维度一致，因为Transformer中采用了残差结构，以便于能够相加。最终的Z矩阵每一行就是经过多头注意力机制提取后每个词对应的编码向量。</p> 
<p>Add &amp; Norm是分成两个部分，一个是残差结构，一个是LayerNorm，其计算公式如下：</p> 
<p><img alt="" height="217" src="https://images2.imgbox.com/1f/e3/El4TmOmH_o.png" width="1200"></p> 
<p>Encoder中有两处使用了残差结构：</p> 
<ul><li> <p>第一处是将输入矩阵X与经过多头注意力机制得到的Z相加</p> </li><li> <p>第二处是将输入向量与经过FeedForward网络的输出相加</p> </li></ul> 
<p>        采用残差结构主要是为了解决网络难以训练的问题，有了残差结构就可以把网络做的更深，现很多深层的神经网络都使用了残差结构。</p> 
<p>        LayerNorm是指Layer Normalization，他与Batch Normalization是不同的，对于Batch Normalization会对同一批次的所有样本的同一特征计算均值和方差，但是对于文本问题，一般序列长度是不一致的，所以无法对于同一特征进行计算，所以这里采用了Layer Normalization，就是对于同一样本的所有特征计算均值和方差。</p> 
<p>        Feed Forward在Transformer就是普通的全连接网络，激活函数使用的是ReLU：</p> 
<p><img alt="" height="134" src="https://images2.imgbox.com/06/e6/aZnFQE5H_o.png" width="934"></p> 
<p>        由于输入数据是：我爱你，那么经过多头注意力机制及残差网络后得到的输出向量为Z，维度为[词个数，嵌入维度]，这个全连接网络会对每个词输出的Z向量进行转换，并不是有3个全连接网络，而是和RNN差不多，是使用了一个全连接网络参数共享。处理每个字的全连接网络是一个，这是参数共享的，并不是说为每个字都分配一个网络。</p> 
<p><img alt="" height="882" src="https://images2.imgbox.com/a2/e6/BhMpl7Dv_o.png" width="1200"></p> 
<h4 id="%E6%9C%80%E5%90%8E%E5%B1%82%E7%9A%84%E8%BE%93%E5%87%BA">最后层的输出</h4> 
<p>        经过6个Encoder个层堆叠后，最后一层的输出就是整个Encoder的输出，输出维度为[词个数, 嵌入向量维度]，也就是和Z一样的形状。Z传入到Decoder中计算相应的K和V。</p> 
<p class="img-center"><img alt="" height="745" src="https://images2.imgbox.com/3d/11/qvwPh3T1_o.png" width="467"></p> 
<p>Decoder结构</p> 
<ul><li> <p>每个Decoder Block有两个Multi-Head Attention层</p> </li><li> <p>第一个Multi-Head Attention层采用了Masked操作</p> </li><li> <p>第二个Multi-Head Attention层的K、V矩阵输入源来自Encoder的输出编码矩阵，而Q矩阵是由经过Add &amp; Norm层之后的输出计算来的。<img alt="" height="1068" src="https://images2.imgbox.com/f8/cc/oMupATro_o.png" width="602"></p> </li></ul> 
<h4 id="Masked%20Multi-Head%20Attention">Masked Multi-Head Attention</h4> 
<p>        Decoder中的第一个Multi-Head Attention是采用了Masked的操作，他和普通的多头注意力机制计算上来将是一致的，只是多了个掩码矩阵，用于遮盖当前输入后面的数据，不让当前时间模型知道后面的答案是什么。掩码只是在第一个注意力机制使用，第二个是没有用的，因为第一个注意力机制接收的输入为正确答案，在预测当前单词的翻译是我们是不能够让他知道正确答案的，只能根据前面已经翻译出来的内容进行推理。</p> 
<p><img alt="" height="302" src="https://images2.imgbox.com/77/eb/erEzhD14_o.png" width="1200"></p> 
<ul><li> <p><strong>第一步：</strong> 构造掩码矩阵Mask，目的就是为了遮盖当前位置之后的信息，由于输入词个数为3，所以会形成一个 3* 3 的掩码矩阵，矩阵绿色代表当前位置是否可利用，第一个单词只可利用自身，第二个单词则可利用自身和前一个单词，而最后一个则可利用所有信息</p> </li><li> <p><strong>第二步：</strong> 接下来和普通注意力机制是一样的，通过输入矩阵，计算出Q、K、V矩阵</p> </li><li> <p><strong>第三步：</strong> 然后利用Q和K矩阵计算出对应的注意力分数</p> </li><li> <p><strong>第四步：</strong> 将上一步得到的注意力分数进行归一化操作，使每一行的概率和为1</p> </li><li> <p>第五步： 将归一化后的注意力分数与掩码矩阵按位相乘，这样就会得到一个遮盖后的注意力分数矩阵，对于QK矩阵来说，每一行是每个单词对其它单词的注意力分数，为了不让当前位置看到单词的信息，要将当前位置单词之后的注意力分数变为0，这样注意力机制就只会参考前面出现的信息。</p> </li><li> <p><img alt="" height="330" src="https://images2.imgbox.com/6e/75/GlexCzcN_o.png" width="1200"></p> </li></ul> 
<ul><li> <p><strong>第六步：</strong> 使用Mask矩阵与V矩阵相乘得到输出矩阵Z，这样每个词的输出向量就只包含它之前单词的信息。<img alt="" height="329" src="https://images2.imgbox.com/e9/69/nyb5uzuC_o.png" width="1200"></p> </li></ul> 
<ul><li> <p><strong>第七步：</strong> 和多头注意力机制一样，将每个头的输出矩阵Z进行拼接，然后使用全连接网络将其映射成和输入矩阵X维度一样。<img alt="" height="579" src="https://images2.imgbox.com/ce/0e/NY1GECLQ_o.png" width="1200"></p> </li></ul> 
<p>        Decoder中的第二个Multi-Head Attention其实和Encoder中的是一样的，只不过输入的Q、K、V数据来源不一样，K、V矩阵是由Encoder最后一层输出计算得来的，而Q矩阵是由经过第一个掩码注意力机制后的矩阵计算得来的。这里是不需要Mask的，因为在翻译过程需要看所有单词的信息，就是我爱你所有上下文信息都要看到，这也是为什么要从Encoder的输出矩阵计算K和V，Encoder的最终输出可以理解为整句话的最终编码信息，包含了所有的语义信息。</p> 
<h4 id="Decoder%E8%BE%93%E5%85%A5">Decoder输入</h4> 
<p>        对于Decoder的输入分为第一个Decoder Block和之后的Block，第一个Block输入的是Ground Truth，也就是真实答案的嵌入向量，而之后block的输入为前一个块的输出。</p> 
<h4 id="Decoder%E7%9A%84%E8%BE%93%E5%87%BA">Decoder的输出</h4> 
<p>        对于翻译任务来说，需要预测每个字的概率，那就需要使用Softmax来预测所有可能词的概率，比如词库有I、love、you、today、me这五个单词，那么对于一个词 “I” 的输出就为 【0.5，0.1，0.1，0.2，0.1】，由于对应 “I” 位置的概率最大，所以第一个单词预测为 “I”。经过Softmax后，每一行概率和为1，每一行预测出的词就为概率最大的一个。</p> 
<p><img alt="" height="396" src="https://images2.imgbox.com/b3/f2/xPXoiMWb_o.png" width="646"></p> 
<h4 id="Transformer%E8%AE%AD%E7%BB%83%E5%92%8C%E6%8E%A8%E7%90%86%E8%BF%87%E7%A8%8B">Transformer训练和推理过程</h4> 
<ul><li> <p>训练过程：对于训练过程，我们是将原始输入和正确答案一同输入的，训练过程采用Teacher Forcing，而对于正确答案输入是采用了Mask操作，就是为了不让模型看到当前词之后的信息，这是可以并行进行的。</p> </li><li> <p>推理过程：但是对于推理过程，是不会输入正确答案的，而且和RNN运行差不多是一个一个的，首先会给Decoder输入开始标志，然后经过Decoder会预测出 “I” 单词，然后拿着这个 “I” 单词继续喂入Decoder去预测 “love”，但后拿着 “love” 去预测 “you” ，最后拿着 “you” 去预测结束标志。</p> </li></ul> 
<p>        对于翻译任务来说，这是序列到序列的问题，显然每次的输出序列的长度是不一致的，所以需要一个结束标志来表明这句话已经翻译完成，所以需要按顺序一个一个翻译，不断拿着已经翻译出的词送入模型，知道预测出结束标志为止。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/c513d568e80576fd3fc6fa81b67d1568/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">树莓派在Ubuntu的命令行系统中怎么连接WIFI</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/933b472728bbfff0735a7ae4cbd9672b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">AIGC系列之：DDPM原理解读（简单易懂版）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>