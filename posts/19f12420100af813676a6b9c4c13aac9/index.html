<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>php判断请求是都ajax,PHP判断一个请求是Ajax请求仍是普通请求 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="php判断请求是都ajax,PHP判断一个请求是Ajax请求仍是普通请求" />
<meta property="og:description" content="Javascript中大多数的框架如 jquery(jquery ui、jquery easyui)、Mootools 等，在发出 Ajax 请求时，都会发送额外的 HTTP_X_REQUESTED_WITH 头部信息，所以每当发送一个ajax请求你就能够在服务器端侦测到是 Ajax 请求； php
一、经过传递_GET参数的方法简单实现网页请求的判断。
url上这么传递：*******.php?ajax
php这么判断： html
if(isset($_GET[&#39;ajax&#39;])){
...这是一个ajax请求，而后...
}
else{
...这不是一个ajax请求，而后...
}
这种实现方法不好劲，至关容易容易容易伪造。判断和不判断没有任何区别。
因此又出来一种自认为很科学的处理方式，这种方式确实有必定的学习价值。
二、经过PHP获取预约义变量中的XMLHttpRequest判读。 jquery
首先你必须使用jquery或Js发送ajax请求，经过jquery发送的$.ajax, $.get or $.post方法请求网页内容时，它会向服务器传递一个HTTP_X_REQUESTED_WITH的参数，这个参数的值是XMLHttpRequest。
代码： ajax
beforeSend : function (XMLHttpRequest) {
XMLHttpRequest.setRequestHeader(&#34;X_Requested_With&#34;,&#34;XMLHttpRequest&#34;);
}；
参数名X_Requested_With，参数值XMLHttpRequest，你能够任意定义。Php取得时候要在参数名前面加上大写的http字样(即一个“HTTP_”前缀)而后“X_Requested_With”这个变量所有大写(必定要大写)，而后再$_SERVER这个超级变量中找就能够了。 浏览器
代码： 服务器
/**
* 判断是否Ajax请求
*/
function is_ajax_request(){
if(isset($_SERVER[&#39;HTTP_X_REQUESTED_WITH&#39;]) &amp;&amp; strtolower($_SERVER[&#39;HTTP_X_REQUESTED_WITH&#39;]) == &#39;xmlhttprequest&#39;)
{
return true;
}
else
{
return false;
}
} 若是你的jquery请求是经过iframe打开网页的，那么HTTP_X_REQUESTED_WITH参数不会被传递，也就是说你没有办法判断请求的类型。
IE5，IE6老版本的浏览器中$.ajax, $.get or $.post方法不会自动发送HTTP_X_REQUESTED_WITH的参数到头部信息，所以PHP中也是没法获取参数进行判断。除非你本身构造XMLHttpRequest对象出来，而后再发送给php脚本，至关于用最原始的Js实现ajax功能。但这样的话jquery框架原本封装好的ajax就失去意义了。 session" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/19f12420100af813676a6b9c4c13aac9/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-05T20:15:13+08:00" />
<meta property="article:modified_time" content="2021-08-05T20:15:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">php判断请求是都ajax,PHP判断一个请求是Ajax请求仍是普通请求</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>Javascript中大多数的框架如 jquery(jquery ui、jquery easyui)、Mootools 等，在发出 Ajax 请求时，都会发送额外的 HTTP_X_REQUESTED_WITH 头部信息，所以每当发送一个ajax请求你就能够在服务器端侦测到是 Ajax 请求； php</p> 
 <p>一、经过传递_GET参数的方法简单实现网页请求的判断。</p> 
 <p>url上这么传递：*******.php?ajax</p> 
 <p>php这么判断： html</p> 
 <p>if(isset($_GET['ajax'])){<!-- --></p> 
 <p>...这是一个ajax请求，而后...</p> 
 <p>}</p> 
 <p>else{<!-- --></p> 
 <p>...这不是一个ajax请求，而后...</p> 
 <p>}</p> 
 <p>这种实现方法不好劲，至关容易容易容易伪造。判断和不判断没有任何区别。</p> 
 <p>因此又出来一种自认为很科学的处理方式，这种方式确实有必定的学习价值。</p> 
 <p>二、经过PHP获取预约义变量中的XMLHttpRequest判读。 jquery</p> 
 <p>首先你必须使用jquery或Js发送ajax请求，经过jquery发送的$.ajax, $.get or $.post方法请求网页内容时，它会向服务器传递一个HTTP_X_REQUESTED_WITH的参数，这个参数的值是XMLHttpRequest。</p> 
 <p>代码： ajax</p> 
 <p>beforeSend : function (XMLHttpRequest) {<!-- --></p> 
 <p>XMLHttpRequest.setRequestHeader("X_Requested_With","XMLHttpRequest");</p> 
 <p>}；</p> 
 <p>参数名X_Requested_With，参数值XMLHttpRequest，你能够任意定义。Php取得时候要在参数名前面加上大写的http字样(即一个“HTTP_”前缀)而后“X_Requested_With”这个变量所有大写(必定要大写)，而后再$_SERVER这个超级变量中找就能够了。 浏览器</p> 
 <p>代码： 服务器</p> 
 <p>/**</p> 
 <p>* 判断是否Ajax请求</p> 
 <p>*/</p> 
 <p>function is_ajax_request(){<!-- --></p> 
 <p>if(isset($_SERVER['HTTP_X_REQUESTED_WITH']) &amp;&amp; strtolower($_SERVER['HTTP_X_REQUESTED_WITH']) == 'xmlhttprequest')</p> 
 <p>{<!-- --></p> 
 <p>return true;</p> 
 <p>}</p> 
 <p>else</p> 
 <p>{<!-- --></p> 
 <p>return false;</p> 
 <p>}</p> 
 <p>} 若是你的jquery请求是经过iframe打开网页的，那么HTTP_X_REQUESTED_WITH参数不会被传递，也就是说你没有办法判断请求的类型。</p> 
 <p>IE5，IE6老版本的浏览器中$.ajax, $.get or $.post方法不会自动发送HTTP_X_REQUESTED_WITH的参数到头部信息，所以PHP中也是没法获取参数进行判断。除非你本身构造XMLHttpRequest对象出来，而后再发送给php脚本，至关于用最原始的Js实现ajax功能。但这样的话jquery框架原本封装好的ajax就失去意义了。 session</p> 
 <p>经过jquery的$.ajax()方法，能够轻松地在发送ajax请求以前，建立咱们自定义的header头信息。 ide</p> 
 <p>$.ajax({<!-- --></p> 
 <p>type : "GET",</p> 
 <p>url : base_url + 'php_check_ajax_request/get_user_list.html',</p> 
 <p>beforeSend : function (XMLHttpRequest) {<!-- --></p> 
 <p>XMLHttpRequest.setRequestHeader("request_type","ajax");</p> 
 <p>},</p> 
 <p>success : function(data){<!-- --></p> 
 <p>$("#user_list").html(data);</p> 
 <p>$tip.hide();</p> 
 <p>$button.attr('disabled',true);</p> 
 <p>}</p> 
 <p>}); 那么在php中就应该这样取得：</p> 
 <p>$_SERVER['HTTP_REQUEST_TYPE']</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7092a6967681d5765e0b862cfb27befb/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">多路ADC的采集——stm32</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b534076c4f3134cb8d6f5650038df157/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu 21.04系统安装 &#43; Nvidia RTX3080 Ti 显卡驱动安装&#43;驱动安装后重启黑屏解决&#43;cuda&#43;pytorch深度学习环境搭建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>