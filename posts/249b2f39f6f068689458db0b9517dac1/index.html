<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>[TI TDA4 J721E]TIOVX OpenVX Graph Pipelining理解和移植使用（更新版） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="[TI TDA4 J721E]TIOVX OpenVX Graph Pipelining理解和移植使用（更新版）" />
<meta property="og:description" content="首先感谢阅读，如果您也对TDA4相关的开发感兴趣，我们这边有个学习交流微信群，可以入群和大家一起交流学习。
资历较浅，水平有限，如遇错误，请大家多指正！
保持开源精神，共同分享、进步！
博主WX ： AIR_12 我会拉你入群。
链接：TDA4 相关专栏 链接：TDA4 Demo Gitee开源库
欢迎大家加入，一起维护这个开源库，给更多的朋友提供帮助。
更新时间：2022年06月30日
一、Graph和Pipeline的区别和对比： 1、Pipeline的本质：通过分时复用的方式，提高了硬件的整体利用率，但在本质上，运行单条流水线和运行一次graph的时间是相同的。
2、原有的Graph，如果执行vxProcessGraph，那么graph一旦运行起来，就不允许被打断；且同一个时刻，只有一个核参与整体的graph的处理过程。
3、但是Pipeline，可以实现在graph运行过程中，对关心的数据即通过（graph_parameters_queue_params_list）进行调整，比如图片替换、复制等等。
4、同时，pipeline还允许不同的核在同一个时间，参与到不同流水线的处理过程中。整体上提升了硬件的利用效率。
GraphPipeline是否可打断不可以可以（通过graph_parameters_queue_params_list）硬件同时运行不可以可以（同一个时刻，允许多个核同时运行不同的pipeline的处理） 二、例程说明 本例程以SDK 0800版本为基准，使用 ./apps/dl_demos/app_tidl_od_cam 作为示例。
在app_create_graph 函数内，创建了一下一系列的 node 顺序如下：
节点名称节点主要功能CaptureNode从摄像头获取传感器图像数据VpacVissNode将RAW 数据转换成YUV格式的数据AewbNode实现图像自动白平衡等相关的处理VpacLdcNode对图像进行畸变矫正等VpacMscScaleNode图像缩放处理节点（缩放至训练网络接收的size） ImgPreProcNode
图像预处理节点（将图像数据预处理转换成Tidl模块可以处理的RGB格式等）TIDLNode深度网络，实现目标检测、推理等功能DrawBoxDetectionsNode绘制检测到物体框的节点ImgMosaicNode图像镶嵌节点，将多个图像嵌入到同一个图像内DisplayNode显示节点，将经过镶嵌的图像显示到显示器 其中 VpacVissNode AewbNode VpacLdcNode VpacMscScaleNode ImgPreProcNode
在创建的时候，会使用vxReplicateNode节点进行相应节点的复制。这里我当时的主要疑问是复制了几个这样的节点。
在创建这些node的时候，会传入一个vx_object_array，具体说明参考这里
[TI TDA4 J721E] TIOVX 常用函数详解 之——vxReplicateNode_AIRKernel的博客-CSDN博客
创建的总数量应该是和这个参数包含的成员数量相当。（成员数量=4 ，创建的个数 = 4-1 =3），因为已经创建了一个Node了。
三、graph_parameters_queue_params_list graph_parameters_queue_params_list 必须被设置，这个列表表示在graph运行过程中可以被访问对象的索引。
graph_parameter_index = 0; add_graph_parameter_by_node_index(obj-&gt;graph, obj-&gt;captureObj.node, 1); //将captureNode 的序号为1的参数，加入到 graph_parameters_queue_params_list中 obj-&gt;captureObj.graph_parameter_index = graph_parameter_index; //设置capture节点的 索引 graph_parameters_queue_params_list[graph_parameter_index]." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/249b2f39f6f068689458db0b9517dac1/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-10T12:33:05+08:00" />
<meta property="article:modified_time" content="2022-07-10T12:33:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">[TI TDA4 J721E]TIOVX OpenVX Graph Pipelining理解和移植使用（更新版）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>          首先感谢阅读，如果您也对TDA4相关的开发感兴趣，我们这边有个学习交流微信群，可以入群和大家一起交流学习。</strong></p> 
<p style="text-align:center;"><strong>资历较浅，水平有限，如遇错误，请大家多指正！</strong></p> 
<p style="text-align:center;"><strong>保持开源精神，共同分享、进步！</strong></p> 
<p style="text-align:center;"><strong>博主WX ： AIR_12  我会拉你入群。</strong></p> 
<p style="text-align:center;"><strong>链接：<strong><strong><strong><strong><strong><strong><strong><a href="https://blog.csdn.net/airkernel/category_11289572.html?spm=1001.2014.3001.5482" title="TDA4 相关专栏">TDA4 相关专栏</a></strong></strong></strong></strong></strong></strong></strong>        链接：<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><a class="link-info" href="https://gitee.com/tda4/ti-tda4" rel="nofollow" title="TDA4  Demo  Gitee开源库">TDA4  Demo  Gitee开源库</a></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></p> 
<p style="text-align:center;"><strong>欢迎大家加入，一起维护这个开源库，给更多的朋友提供帮助。</strong></p> 
<hr> 
<p>更新时间：2022年06月30日</p> 
<h2>一、Graph和Pipeline的区别和对比：</h2> 
<p>1、<strong>Pipeline的本质</strong>：通过<strong>分时复用</strong>的方式，提高了硬件的整体利用率，但在本质上，运行单条流水线和运行一次graph的时间是相同的。</p> 
<p>2、原有的Graph，如果执行vxProcessGraph，那么graph一旦运行起来，就<span style="color:#fe2c24;"><strong>不允许被打断</strong></span>；且同一个时刻，<strong><span style="color:#fe2c24;">只有一个核</span></strong>参与整体的graph的处理过程。</p> 
<p>3、但是Pipeline，可以实现在graph运行过程中，对关心的数据即通过（graph_parameters_queue_params_list）进行调整，比如图片替换、复制等等。</p> 
<p>4、同时，pipeline还允许不同的核在同一个时间，参与到不同流水线的处理过程中。整体上提升了硬件的利用效率。</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:613px;"><tbody><tr><td style="width:108px;"></td><td style="width:64px;">Graph</td><td style="width:440px;">Pipeline</td></tr><tr><td style="width:108px;">是否可打断</td><td style="width:64px;">不可以</td><td style="width:440px;">可以（通过graph_parameters_queue_params_list）</td></tr><tr><td style="width:108px;">硬件同时运行</td><td style="width:64px;">不可以</td><td style="width:440px;">可以（同一个时刻，允许多个核同时运行不同的pipeline的处理）</td></tr></tbody></table> 
<hr> 
<h2>二、例程说明</h2> 
<p>本例程以SDK 0800版本为基准，使用 ./apps/dl_demos/app_tidl_od_cam 作为示例。</p> 
<p>在app_create_graph 函数内，创建了一下一系列的 node 顺序如下：</p> 
<table border="1" cellpadding="1" cellspacing="1" style="width:700px;"><tbody><tr><td style="width:187px;">节点名称</td><td style="width:511px;">节点主要功能</td></tr><tr><td style="width:187px;">CaptureNode</td><td style="width:511px;">从摄像头获取传感器图像数据</td></tr><tr><td style="width:187px;">VpacVissNode</td><td style="width:511px;">将RAW 数据转换成YUV格式的数据</td></tr><tr><td style="width:187px;">AewbNode</td><td style="width:511px;">实现图像自动白平衡等相关的处理</td></tr><tr><td style="width:187px;">VpacLdcNode</td><td style="width:511px;">对图像进行畸变矫正等</td></tr><tr><td style="width:187px;">VpacMscScaleNode</td><td style="width:511px;">图像缩放处理节点（缩放至训练网络接收的size）</td></tr><tr><td style="width:187px;"> <p>ImgPreProcNode</p> </td><td style="width:511px;">图像预处理节点（<span style="color:#ff9900;">将图像数据预处理转换成Tidl模块可以处理的RGB格式等</span>）</td></tr><tr><td style="width:187px;">TIDLNode</td><td style="width:511px;">深度网络，实现目标检测、推理等功能</td></tr><tr><td style="width:187px;">DrawBoxDetectionsNode</td><td style="width:511px;">绘制检测到物体框的节点</td></tr><tr><td style="width:187px;">ImgMosaicNode</td><td style="width:511px;">图像镶嵌节点，将多个图像嵌入到同一个图像内</td></tr><tr><td style="width:187px;">DisplayNode</td><td style="width:511px;">显示节点，将经过镶嵌的图像显示到显示器</td></tr></tbody></table> 
<p>其中 VpacVissNode AewbNode VpacLdcNode VpacMscScaleNode ImgPreProcNode</p> 
<p>在创建的时候，会使用<span style="color:#4da8ee;"><strong>vxReplicateNode</strong></span>节点进行相应节点的复制。这里我当时的主要疑问是复制了几个这样的节点。<br> 在创建这些node的时候，会传入一个<span style="color:#4da8ee;"><strong>vx_object_array</strong></span>，具体说明参考这里</p> 
<p><a href="https://blog.csdn.net/AIRKernel/article/details/125519892?spm=1001.2014.3001.5501" title="[TI TDA4 J721E] TIOVX 常用函数详解 之——vxReplicateNode_AIRKernel的博客-CSDN博客">[TI TDA4 J721E] TIOVX 常用函数详解 之——vxReplicateNode_AIRKernel的博客-CSDN博客</a></p> 
<p>创建的总数量应该是和这个参数包含的成员数量相当。（成员数量=4 ，创建的个数 = 4-1 =3），因为已经创建了一个Node了。</p> 
<hr> 
<h2>三、graph_parameters_queue_params_list</h2> 
<p>graph_parameters_queue_params_list 必须被设置，这个列表表示在graph运行过程中可以被访问对象的索引。</p> 
<div> 
 <pre><code class="language-cpp">        graph_parameter_index = 0;
        add_graph_parameter_by_node_index(obj-&gt;graph, obj-&gt;captureObj.node, 1); //将captureNode 的序号为1的参数，加入到 graph_parameters_queue_params_list中

        obj-&gt;captureObj.graph_parameter_index = graph_parameter_index; //设置capture节点的 索引
        graph_parameters_queue_params_list[graph_parameter_index].graph_parameter_index = graph_parameter_index; //设置graph_parameters_queue_params_list中对应成员的索引
        graph_parameters_queue_params_list[graph_parameter_index].refs_list_size = APP_BUFFER_Q_DEPTH;          //注意：设置该成员包含的子成员的个数
        graph_parameters_queue_params_list[graph_parameter_index].refs_list = (vx_reference *)&amp;obj-&gt;captureObj.raw_image_arr[0];    //成员指针指向被操作的对象地址
        graph_parameter_index++;    //索引数量增加

        vxSetGraphScheduleConfig(obj-&gt;graph,
                                 VX_GRAPH_SCHEDULE_MODE_QUEUE_AUTO,
                                 graph_parameter_index,
                                 graph_parameters_queue_params_list);</code></pre> 
</div> 
<hr> 
<h2>四、Enqueue 和 Dequeue 相关顺序说明</h2> 
<p>更新时间：2022年06月30日</p> 
<p>工作流程（请结合第五点代码）：</p> 
<p>1、根据需要，可以将需要对enqueue对象进行的修改完成后，等待enqueue。</p> 
<p>2、根据流水线深度，Enqueue相关的对象 。</p> 
<p>3、执行Dequeue。</p> 
<p>4、执行Dequeue后，会自动将流水线向前执行一条流水线，完成一个完整graph的运行（注意此处说的是整个pipline的graph_parameters_queue_params_list<span style="color:#fe2c24;">只有一个成员</span>。如果有两个成员，需要继续再次Dequeue，才能完成整条流水线的工作）。</p> 
<hr> 
<h2>五、Enqueue 和 Dequeue</h2> 
<p>请结合代码注释阅读！！！</p> 
<div> 
 <pre><code class="language-cpp">
    if(obj-&gt;pipeline &lt;= 0)
    {
        /* Enqueue outpus */
        /* Enqueue inputs during pipeup dont execute */
        //将capture获取到的图像，逐个入队到graph中
        vxGraphParameterEnqueueReadyRef(obj-&gt;graph, captureObj-&gt;graph_parameter_index, (vx_reference*)&amp;captureObj-&gt;raw_image_arr[obj-&gt;enqueueCnt], 1);

        obj-&gt;enqueueCnt++;
        obj-&gt;enqueueCnt   = (obj-&gt;enqueueCnt  &gt;= APP_BUFFER_Q_DEPTH)? 0 : obj-&gt;enqueueCnt;
        obj-&gt;pipeline++;
    }

    if(obj-&gt;pipeline &gt; 0)
    {
        vx_image capture_input_image;
        uint32_t num_refs;

        /* Dequeue input */
        //将经过运行captureNode节点，得到的输出图像出队。
        vxGraphParameterDequeueDoneRef(obj-&gt;graph, captureObj-&gt;graph_parameter_index, (vx_reference*)&amp;capture_input_image, 1, &amp;num_refs);
        // Dequeue实际上是将TIOVX空间的数据，映射到用户空间内，用户可以根据这个指针对数据进行修改。
        //经过出对的图像数据，可以在这里进行操作。
        // 执行出队后，capture_input_image图像可能位于captureObj-&gt;raw_image_arr[array]中的任意位置，如果需要确定，需要将
        // capture_input_image和captureObj-&gt;raw_image_arr[array]中的对象进行对比，参考0703的decode部分。
        //
        /* Enqueue input - start execution */
        //将映射到用户空间的对象重新入队。原来的位置会被自动至为NULL，直到下次dequeue。
        vxGraphParameterEnqueueReadyRef(obj-&gt;graph, captureObj-&gt;graph_parameter_index, (vx_reference*)&amp;capture_input_image, 1);

        obj-&gt;enqueueCnt++;
        obj-&gt;dequeueCnt++;

        obj-&gt;enqueueCnt = (obj-&gt;enqueueCnt &gt;= APP_BUFFER_Q_DEPTH)? 0 : obj-&gt;enqueueCnt;
        obj-&gt;dequeueCnt = (obj-&gt;dequeueCnt &gt;= APP_BUFFER_Q_DEPTH)? 0 : obj-&gt;dequeueCnt;
    }

    appPerfPointEnd(&amp;obj-&gt;total_perf);</code></pre> 
</div> 
<p>以下是0703版本Decode版本的相关代码：</p> 
<p>其中这两个函数，就是为了查找到被dequeue出来的对象在array中的索引。</p> 
<p>app_find_image_array_index<br> app_find_user_object_array_index </p> 
<div> 
 <pre><code class="language-cpp">vx_status app_run_decodeGraph(vx_graph graph, DecodeObj *decodeObj, vx_user_data_object *bitStream)
{
    vx_status status = VX_SUCCESS;

    if (decodeObj-&gt;pipeline &lt; 0)
    {
        /* Enqueue output */
        vxGraphParameterEnqueueReadyRef(graph, decodeObj-&gt;output_image_graph_parameter_index, (vx_reference *)&amp;decodeObj-&gt;output_image[decodeObj-&gt;enqueueCnt], 1);

        app_copy_encodeBitStream_to_decodeBitStream(&amp;decodeObj-&gt;bitstream_obj[decodeObj-&gt;enqueueCnt], bitStream);

        /* Enqueue input - start execution */
        vxGraphParameterEnqueueReadyRef(graph, decodeObj-&gt;input_bitstream_graph_parameter_index, (vx_reference *)&amp;decodeObj-&gt;bitstream_obj[decodeObj-&gt;enqueueCnt], 1);

        decodeObj-&gt;enqueueCnt++;
        decodeObj-&gt;enqueueCnt = (decodeObj-&gt;enqueueCnt &gt;= decodeObj-&gt;num_buf) ? 0 : decodeObj-&gt;enqueueCnt;
        decodeObj-&gt;pipeline++;
    }
    else if (decodeObj-&gt;pipeline &gt;= 0)
    {
        vx_int32 array_idx = -1, img_array_idx = -1;
        vx_image out_image;
        vx_user_data_object in_bitstream;
        uint32_t num_refs;
        /* Dequeue &amp; Save output */
        //参数说明：要出队的参数索引、被出队的对象填充该区域、最大的出队个数、实际的出队个数
        vxGraphParameterDequeueDoneRef(graph, decodeObj-&gt;output_image_graph_parameter_index, (vx_reference *)&amp;out_image, 1, &amp;num_refs);
        app_find_image_array_index(decodeObj-&gt;output_image, (vx_reference)out_image, decodeObj-&gt;num_buf, &amp;img_array_idx);

        if (img_array_idx != -1)
        {
            app_decode_saveImageToFile("/home/root/mydecode.yuv", &amp;decodeObj-&gt;output_image[img_array_idx]);
        }
        /* Dequeue input */
        vxGraphParameterDequeueDoneRef(graph, decodeObj-&gt;input_bitstream_graph_parameter_index, (vx_reference *)&amp;in_bitstream, 1, &amp;num_refs);


        /* Enqueue output */
        vxGraphParameterEnqueueReadyRef(graph, decodeObj-&gt;output_image_graph_parameter_index, (vx_reference *)&amp;out_image, 1);
        app_find_user_object_array_index(decodeObj-&gt;bitstream_obj, (vx_reference)in_bitstream, decodeObj-&gt;num_buf, &amp;array_idx);

        if (array_idx != -1)
        {
            app_copy_encodeBitStream_to_decodeBitStream(&amp;decodeObj-&gt;bitstream_obj[array_idx], bitStream);
        }
        /* Enqueue input - start execution */
        vxGraphParameterEnqueueReadyRef(graph, decodeObj-&gt;input_bitstream_graph_parameter_index, (vx_reference *)&amp;in_bitstream, 1);
     }

    return status;
}

void app_find_user_object_array_index(vx_user_data_object object_array[], vx_reference ref, vx_int32 array_size, vx_int32 *array_idx)
{
    vx_int32 i;

    *array_idx = -1;
    for (i = 0; i &lt; array_size; i++)
    {
        if (ref == (vx_reference)object_array[i])
        {
            *array_idx = i;
            break;
        }
    }
}

void app_find_image_array_index(vx_image image_array[], vx_reference ref, vx_int32 array_size, vx_int32 *array_idx)
{
    vx_int32 i;

    *array_idx = -1;
    for (i = 0; i &lt; array_size; i++)
    {
        if (ref == (vx_reference)image_array[i])
        {
            *array_idx = i;
            break;
        }
    }
}</code></pre> 
</div> 
<hr> 
<p style="text-align:center;"><span style="color:#4da8ee;"><strong>【声明】<br> 【欢迎转载转发，请注明出处。原创比较辛苦，请尊重原创，祝大家学习愉快！】<br> 【博主专注嵌入式开发，具有多年嵌入式软、硬件开发经验，欢迎大家学习交流！】<br> 【如有嵌入式相关项目需求，欢迎私信】    </strong></span></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/937bc8fa6b08d0eecbf359c6371416d7/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Linux应急响应Gscan使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/fc38d638e946bc947cef41eb5768d5a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深度学习框架(PaddlePaddle)使用教程</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>