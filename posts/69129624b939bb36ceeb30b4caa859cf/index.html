<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>一篇搞定Java注解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="一篇搞定Java注解" />
<meta property="og:description" content="参考：https://blog.csdn.net/yeahPeng11/article/details/120394276
https://blog.csdn.net/yeahPeng11/article/details/120330630
https://www.cnblogs.com/CF1314/p/16580232.html
通过现有注解，明白注解是什么东东。
在 SpringBoot中，我们会用到返回值@ResponseBody注解。@ResponseBody返回的是字符串类型数据。
@Target(ElementType.METHOD) //作用于方法上 @Retention(RetentionPolicy.RUNTIME) //作用在运行时 @Documented //生成到文档里 public @interface ResponseBody { String value(); } 元注解
用于定义注解的注解，包括@Target、@Retention、@Documented、@Inherited。
@Target(目标)
Target意为 目标，指定定义的注解起作用的场景。限定注解的使用场景、使用对象等，注解的使用变得十分明确。它的取值由ElementType类提供。
ElementType.TYPE ：作用于类、接口（包括注解类型接口）或者枚举类型。 ElementType.FIELD：作用于字段属性。 ElementType.METHOD：作用于方法。 ElementType.PARAMETER：作用于参数。 ElementType.CONSTRUCTOR：作用于构造器。 ElementType.LOCAL_VARIABLE：作用于局部变量。 ElementType.ANNOTATION_TYPE：作用于注解。 ElementType.PACKAGE：作用于包。 ElementType.TYPE_PARAMETER：作用于类型参数（since jdk1.8）。 ElementType.TYPE_USE：作用于使用的类型（since jdk1.8）。 ElementType.MODULE：作用于模块声明（since jdk9）。 在@ResponseBody中，ElementType.METHOD 代表作用在方法上。 @Retention(保留)
Retention意为 保留，解释这个注解的保留的时间（存活的时间）。它的取值由RetentionPolicy类提供。
​ RetentionPolicy.SOURCE：注解只在源码阶段保留，将被编译器丢弃。
​ RetentionPolicy.CLASS：默认行为，注解只被保留到编译进行的时候，不会被加载到 JVM 中。
​ RetentionPolicy.RUNTIME：注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，程序运行时可读取，可被反射读取到。
Java代码保留（存活）的时间段分为 source -&gt; class -&gt; runtime 三个。
@ResponseBody 注解中，@Retention(RetentionPolicy.RUNTIME) 代表作用在运行时。
@Documented(文档)
Documented意为 文档，解释此注解可以生成在 Javadoc 中。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/69129624b939bb36ceeb30b4caa859cf/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-23T13:13:22+08:00" />
<meta property="article:modified_time" content="2023-11-23T13:13:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">一篇搞定Java注解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <blockquote> 
 <p>参考：https://blog.csdn.net/yeahPeng11/article/details/120394276</p> 
 <p>https://blog.csdn.net/yeahPeng11/article/details/120330630<br> https://www.cnblogs.com/CF1314/p/16580232.html</p> 
</blockquote> 
<p>通过现有注解，明白注解是什么东东。</p> 
<p>在 SpringBoot中，我们会用到返回值@ResponseBody注解。@ResponseBody返回的是字符串类型数据。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">)</span>         <span class="token comment">//作用于方法上</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span> <span class="token comment">//作用在运行时</span>
<span class="token annotation punctuation">@Documented</span>                         <span class="token comment">//生成到文档里</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">ResponseBody</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">String</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>元注解</strong></p> 
<p>用于定义注解的注解，包括@Target、@Retention、@Documented、@Inherited。</p> 
<p><strong>@Target(目标)</strong></p> 
<p>Target意为 目标，指定定义的注解起作用的场景。限定注解的使用场景、使用对象等，注解的使用变得十分明确。它的取值由ElementType类提供。</p> 
<pre><code>ElementType.TYPE ：作用于类、接口（包括注解类型接口）或者枚举类型。

ElementType.FIELD：作用于字段属性。

ElementType.METHOD：作用于方法。

ElementType.PARAMETER：作用于参数。

ElementType.CONSTRUCTOR：作用于构造器。

ElementType.LOCAL_VARIABLE：作用于局部变量。

ElementType.ANNOTATION_TYPE：作用于注解。

ElementType.PACKAGE：作用于包。

ElementType.TYPE_PARAMETER：作用于类型参数（since jdk1.8）。

ElementType.TYPE_USE：作用于使用的类型（since jdk1.8）。

ElementType.MODULE：作用于模块声明（since jdk9）。

	在@ResponseBody中，ElementType.METHOD 代表作用在方法上。
</code></pre> 
<p><strong>@Retention(保留)</strong></p> 
<p>Retention意为 保留，解释这个注解的保留的时间（存活的时间）。它的取值由RetentionPolicy类提供。</p> 
<p>​ RetentionPolicy.SOURCE：注解只在源码阶段保留，将被编译器丢弃。</p> 
<p>​ RetentionPolicy.CLASS：默认行为，注解只被保留到编译进行的时候，不会被加载到 JVM 中。</p> 
<p>​ RetentionPolicy.RUNTIME：注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，程序运行时可读取，可被反射读取到。</p> 
<p>Java代码保留（存活）的时间段分为 source -&gt; class -&gt; runtime 三个。</p> 
<p>@ResponseBody 注解中，@Retention(RetentionPolicy.RUNTIME) 代表作用在运行时。</p> 
<p><strong>@Documented(文档)</strong></p> 
<p>Documented意为 文档，解释此注解可以生成在 Javadoc 中。</p> 
<p>**@**<strong>Inherited(继承)</strong></p> 
<p>该注解使父类的注解能被其子类继承</p> 
<p><strong>@Repeatable(可重复)</strong></p> 
<p>Repeatable意为 可重复，jdk1.8新特性。它表示修饰的注解可以重复被使用。</p> 
<p>例如，在Controller类中，我们无法对一个类或方法增加多个 @RequestMapping 注解，会报错 does not have a valid java.lang.annotation.Repeatable annotation，但也有注解，比如 @MapperScan 和 @CompentScan 都可以在一个类和方法上重复使用，原因就是该注解用 @Repeatable 注解</p> 
<p>注解：</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Retension</span><span class="token punctuation">(</span><span class="token class-name">RetensionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token class-name">ElementTyoe<span class="token punctuation">.</span>Type</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token class-name">MapperScannerRegister</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">}</span><span class="token punctuation">)</span>   <span class="token comment">// 声明是一个配置类</span>
<span class="token annotation punctuation">@Repetable</span><span class="token punctuation">(</span><span class="token class-name">MapperScans</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">MapperScanP</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p><strong>Java预设的注解</strong></p> 
<ul><li>@Deprecated：Deprecated意为 弃用、过时，Java语言在不断的迭代中，针对同一需求不断的优化解决方案，旧的解决方案就会使用@Deprecated标记过时，但是还是可以正常使用。</li><li>@Override：重写父类方法需要使用@Override。</li><li>@SuppressWarnings：阻止警告。</li><li>@SafeVarargs：参数安全类型注解。</li><li>@FunctionalInterface：函数式接口注解，这个是 Java 1.8 版本引入的新特性</li></ul> 
<p><strong>Java内建注解</strong></p> 
<p>Java提供了三种内建注解。</p> 
<ol><li> <p><strong>@Override</strong>——当我们想要复写父类中的方法时，我们需要使用该注解去告知编译器我们想要复写这个方法。这样一来当父类中的方法移除或者发生更改时编译器将提示错误信息。</p> </li><li> <p><strong>@Deprecated</strong>——当我们希望编译器知道某一方法不建议使用时，我们应该使用这个注解。Java在javadoc 中推荐使用该注解，我们应该提供为什么该方法不推荐使用以及替代的方法。</p> </li><li> <p><strong>@SuppressWarnings</strong>——这个仅仅是告诉编译器忽略特定的警告信息，例如在泛型中使用原生数据类型。它的保留策略是SOURCE（译者注：在源文件中有效）并且被编译器丢弃。</p> </li></ol> 
<p><strong>问题：</strong></p> 
<p>为什么 @GetMapping 注解请求是 Get请求，为什么@RequestMapping 指定请求类型需要用 RequestMethod.POST。</p> 
<p><strong>答疑：</strong></p> 
<p>首先通过查看 @GetMapping 的源码</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token class-name">ElementType</span><span class="token punctuation">.</span><span class="token constant">METHOD</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetrntionPolicy</span><span class="token punctuation">.</span><span class="token constant">RUNTIME</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>
    method <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">}</span>
<span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">GetMapping</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span>
</code></pre> 
<p>从源码中可以看到，@GetMapping引用了注解@RequestMapping，同时含有参数RequestMethod.GET。@RequestMapping注解中的RequestMethod枚举，也就表明了请求类型的方式。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2c8bb494eff1b71450147d3380064635/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">微信开放平台Android平台应用签名怎么填写</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/58eb8ac2cd04b4cd2dc12c8b3a54a2fd/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">搭建RabbitMQ Server高可用集群</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>