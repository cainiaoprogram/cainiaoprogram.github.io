<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>LongAdder源码解析 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="LongAdder源码解析" />
<meta property="og:description" content="1、LongAdder由来 LongAdder类是JDK1.8新增的一个原子性操作类。AtomicLong通过CAS算法提供了非阻塞的原子性操作，相比受用阻塞算法的同步器来说性能已经很好了，但是JDK开发组并不满足于此，因为经常搞并发的请求下AtomicLong的性能是不能让人接受的。
如下AtomicLong 的incrementAndGet的代码，虽然AtomicLong使用CAS算法，但是CAS失败后还是通过无限循环的自旋锁不多的尝试，这就是高并发下CAS性能低下的原因所在。源码如下：
public final long incrementAndGet() { for (;;) { long current = get(); long next = current &#43; 1; if (compareAndSet(current, next)) return next; } } 高并发下N多线程同时去操作一个变量会造成大量线程CAS失败，然后处于自旋状态，导致严重浪费CPU资源，降低了并发性。
2、LongAdder与AtomicLong的简单介绍 我们知道，volatile关键字是轻量级锁，可以解决多线程内存不可见问题。对于一写多读，可以解决变量同步问题，但是如果是多写，volatile无法解决线程安全问题的。例如，count&#43;&#43;操作，就应该使用如下方式： AtomicInteger count = new AtomicInteger(); 、count.addAndGet(1);而如果是JDK8及以上，推荐使用LongAdder对象替代，因为它的性能比AtomicLong 更好（减少乐观锁的重试次数）。 LongAdder其他应用场景：
对于Java项目中计数统计的一些需求，如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）
在大多数项目及开源组件中，计数统计使用最多的仍然还是AtomicLong，虽然是阿里巴巴这样说，但是我们仍然要根据使用场景来决定是否使用LongAdder。
今天主要是来讲讲LongAdder的实现原理，还是老方式，通过图文一步步解开LongAdder神秘的面纱，通过此篇文章你会了解到：
为什么AtomicLong在高并发场景下性能急剧下降？LongAdder为什么快？LongAdder实现原理（图文分析）AtomicLong是否可以被遗弃或替换？ 本文代码全部基于JDK 1.8，建议边看文章边看源码更加利于消化！
3、AtomicLong 当我们在进行计数统计的时，通常会使用AtomicLong来实现。AtomicLong能保证并发情况下计数的准确性，其内部通过CAS来解决并发安全性的问题。
3.1 AtomicLong实现原理 说到线程安全的计数统计工具类，肯定少不了Atomic下的几个原子类。AtomicLong就是juc包下重要的原子类，在并发情况下可以对长整形类型数据进行原子操作，保证并发情况下数据的安全性。
public class AtomicLong extends Number implements java.io.Serializable { // &#43; 1 public final long incrementAndGet() { return unsafe." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c925479d3ffd81db27b9d6e588a37f30/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-26T10:52:52+08:00" />
<meta property="article:modified_time" content="2021-04-26T10:52:52+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">LongAdder源码解析</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1LongAdder_0"></a>1、LongAdder由来</h3> 
<p><code>LongAdder</code>类是JDK1.8新增的一个原子性操作类。<code>AtomicLong</code>通过CAS算法提供了非阻塞的原子性操作，相比受用阻塞算法的同步器来说性能已经很好了，但是JDK开发组并不满足于此，因为经常搞并发的请求下<code>AtomicLong</code>的性能是不能让人接受的。</p> 
<p>如下<code>AtomicLong</code> 的<code>incrementAndGet</code>的代码，虽然<code>AtomicLong</code>使用CAS算法，但是CAS失败后还是通过无限循环的自旋锁不多的尝试，这就是高并发下CAS性能低下的原因所在。源码如下：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">long</span> current <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">long</span> next <span class="token operator">=</span> current <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>current<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> next<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>高并发下N多线程同时去操作一个变量会造成大量线程CAS失败，然后处于自旋状态，导致严重浪费CPU资源，降低了并发性。</p> 
<h3><a id="2LongAdderAtomicLong_21"></a>2、LongAdder与AtomicLong的简单介绍</h3> 
<ul><li>我们知道，<code>volatile</code>关键字是轻量级锁，可以解决多线程内存不可见问题。对于一写多读，可以解决变量同步问题，但是如果是多写，<code>volatile</code>无法解决线程安全问题的。</li><li>例如，<code>count++</code>操作，就应该使用如下方式： 
  <ul><li><code>AtomicInteger count = new AtomicInteger();</code> 、<code>count.addAndGet(1);</code></li><li>而如果是JDK8及以上，推荐使用<code>LongAdder</code>对象替代，因为它的性能比<code>AtomicLong</code> 更好（减少乐观锁的重试次数）。</li></ul> </li></ul> 
<blockquote> 
 <p>LongAdder其他应用场景：</p> 
</blockquote> 
<p>对于<code>Java项目中</code>计数统计的一些需求，<strong>如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）</strong></p> 
<p>在大多数项目及开源组件中，计数统计使用最多的仍然还是<code>AtomicLong</code>，虽然是阿里巴巴这样说，但是我们仍然要根据使用场景来决定是否使用<code>LongAdder</code>。</p> 
<p>今天主要是来讲讲<code>LongAdder</code>的<strong>实现原理</strong>，还是老方式，通过<strong>图文</strong>一步步解开<code>LongAdder</code>神秘的面纱，通过此篇文章你会了解到：</p> 
<ul><li><strong>为什么AtomicLong在高并发场景下性能急剧下降？</strong></li><li><strong>LongAdder为什么快？</strong></li><li><strong>LongAdder实现原理（图文分析）</strong></li><li><strong>AtomicLong是否可以被遗弃或替换？</strong></li></ul> 
<p><strong>本文代码全部基于JDK 1.8，建议边看文章边看源码更加利于消化！</strong></p> 
<h3><a id="3AtomicLong_45"></a>3、AtomicLong</h3> 
<p>当我们在进行计数统计的时，通常会使用<code>AtomicLong</code>来实现。<code>AtomicLong</code>能保证并发情况下计数的准确性，其内部通过<code>CAS</code>来解决并发安全性的问题。</p> 
<h4><a id="31_AtomicLong_49"></a>3.1 AtomicLong实现原理</h4> 
<p>说到线程安全的计数统计工具类，肯定少不了<code>Atomic</code>下的几个原子类。<code>AtomicLong</code>就是<strong>juc包</strong>下重要的<strong>原子类</strong>，在并发情况下可以对长整形类型数据进行原子操作，<strong>保证并发情况下数据的安全性。</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicLong</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span> <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">// + 1</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span>L<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>L<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// - 1</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span>L<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>L<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们在计数的过程中，一般使用<code>incrementAndGet()</code>和<code>decrementAndGet()</code>进行加一和减一操作，这里调用了<code>Unsafe</code>类中的<code>getAndAddLong()</code>方法进行操作。</p> 
<p>接着看看<code>unsafe.getAndAddLong()</code>方法：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Unsafe</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">getAndAddLong</span><span class="token punctuation">(</span>Object var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">long</span> var4<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
         <span class="token keyword">long</span> var6<span class="token punctuation">;</span>
         <span class="token keyword">do</span> <span class="token punctuation">{<!-- --></span>
             var6 <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getLongVolatile</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span>var1<span class="token punctuation">,</span> var2<span class="token punctuation">,</span> var6<span class="token punctuation">,</span> var6 <span class="token operator">+</span> var4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 
         <span class="token keyword">return</span> var6<span class="token punctuation">;</span>
     <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span>Object var1<span class="token punctuation">,</span> <span class="token keyword">long</span> var2<span class="token punctuation">,</span> <span class="token keyword">long</span> var4<span class="token punctuation">,</span> <span class="token keyword">long</span> var6<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里直接进行<strong>CAS+自旋</strong>操作更新<code>AtomicLong</code>中的<code>value</code>值，进而保证<code>value</code>值的<strong>原子性更新</strong>。</p> 
<h4><a id="32_AtomicLong_90"></a>3.2 AtomicLong瓶颈分析</h4> 
<p>如上代码所示，我们在使用<strong>CAS + 自旋</strong>的过程中，在高并发环境下，N个线程同时进行自旋操作，会出现大量失败并不断自旋的情况，此时<code>AtomicLong</code>的自旋会成为瓶颈。</p> 
<p><img src="https://images2.imgbox.com/99/c6/NRkh8nMk_o.png" alt="在这里插入图片描述"></p> 
<p>如上图所示，高并发场景下<code>AtomicLong</code>性能会急剧下降，我们后面也会举例说明。</p> 
<p>那么高并发下计数的需求有没有更好的替代方案呢？在<code>JDK8</code> 中 <code>Doug Lea</code>大神新写了一个<code>LongAdder</code>来解决此问题，我们后面来看<code>LongAdder</code>是如何优化的。</p> 
<h3><a id="4LongAdder_102"></a>4、LongAdder</h3> 
<h4><a id="41_LongAdderAtomicLong_104"></a>4.1 LongAdder和AtomicLong性能测试</h4> 
<p>我们说了很多<code>LongAdder</code>上性能优于<code>AtomicLong</code>，到底是不是呢？一切还是以代码说话：</p> 
<pre><code class="prism language-java"><span class="token comment">/**
 * Atomic和LongAdder耗时测试
 */</span>
 <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicLongAdderTest</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{<!-- --></span>
         <span class="token function">testAtomicLongAdder</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">testAtomicLongAdder</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">testAtomicLongAdder</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">10000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testAtomicLongAdder</span><span class="token punctuation">(</span><span class="token keyword">int</span> threadCount<span class="token punctuation">,</span> <span class="token keyword">int</span> times<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{<!-- --></span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"threadCount: "</span> <span class="token operator">+</span> threadCount <span class="token operator">+</span> <span class="token string">", times: "</span> <span class="token operator">+</span> times<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> start <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">testLongAdder</span><span class="token punctuation">(</span>threadCount<span class="token punctuation">,</span> times<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"LongAdder 耗时："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"threadCount: "</span> <span class="token operator">+</span> threadCount <span class="token operator">+</span> <span class="token string">", times: "</span> <span class="token operator">+</span> times<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">long</span> atomicStart <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">testAtomicLong</span><span class="token punctuation">(</span>threadCount<span class="token punctuation">,</span> times<span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"AtomicLong 耗时："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> atomicStart<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"ms"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----------------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testAtomicLong</span><span class="token punctuation">(</span><span class="token keyword">int</span> threadCount<span class="token punctuation">,</span> <span class="token keyword">int</span> times<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{<!-- --></span>
        AtomicLong atomicLong <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        List<span class="token generics function"><span class="token punctuation">&lt;</span>Thread<span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> times<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    atomicLong<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span>Thread thread <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span>Thread thread <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"AtomicLong value is : "</span> <span class="token operator">+</span> atomicLong<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testLongAdder</span><span class="token punctuation">(</span><span class="token keyword">int</span> threadCount<span class="token punctuation">,</span> <span class="token keyword">int</span> times<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{<!-- --></span>
        LongAdder longAdder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LongAdder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        List<span class="token generics function"><span class="token punctuation">&lt;</span>Thread<span class="token punctuation">&gt;</span></span> list <span class="token operator">=</span> Lists<span class="token punctuation">.</span><span class="token function">newArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> threadCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> times<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    longAdder<span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span>Thread thread <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">for</span> <span class="token punctuation">(</span>Thread thread <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            thread<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"LongAdder value is : "</span> <span class="token operator">+</span> longAdder<span class="token punctuation">.</span><span class="token function">longValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>执行结果：</p> 
<p><img src="https://images2.imgbox.com/56/10/14BX35Jz_o.png" alt="在这里插入图片描述"></p> 
<p>这里可以看到随着并发的增加，<code>AtomicLong</code>性能是急剧下降的，耗时是<code>LongAdder</code>的数倍。至于原因我们还是接着往后看。</p> 
<h4><a id="42_LongAdder_183"></a>4.2 LongAdder为什么这么快</h4> 
<p>先看下<code>LongAdder</code>的操作原理图：</p> 
<p><img src="https://images2.imgbox.com/b5/61/ZqEod2aG_o.png" alt="在这里插入图片描述"></p> 
<p>既然说到<code>LongAdder</code>可以显著提升高并发环境下的性能，那么它是如何做到的？</p> 
<p><strong>1、 设计思想上，<code>LongAdder</code>采用"分段"的方式降低<code>CAS</code>失败的频次</strong></p> 
<p>这里先简单的说下<code>LongAdder</code>的思路，后面还会详述<code>LongAdder</code>的原理。</p> 
<p>我们知道，<code>AtomicLong</code>中有个内部变量<code>value</code>保存着实际的<code>long</code>值，所有的操作都是针对该变量进行。也就是说，高并发环境下，<code>value</code>变量其实是一个<strong>热点数据</strong>，也就是<strong>N个线程竞争一个热点。</strong></p> 
<p><code>LongAdder</code>的基本思路就是<strong>分散热点</strong>，将<code>value</code>值的新增操作分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个<code>value</code>值进行<code>CAS</code>操作，这样热点就被分散了，冲突的概率就小很多。</p> 
<p><code>LongAdder</code>有一个全局变量<code>volatile long base</code>值，当并发不高的情况下都是通过<code>CAS</code>来直接操作<code>base</code>值，如果<code>CAS</code>失败，则针对<code>LongAdder</code>中的<code>Cell[]</code>数组中的<code>Cell</code>进行<code>CA</code>S操作，减少失败的概率。</p> 
<p>例如当前类中<code>base = 10</code>，有三个线程进行<code>CAS</code>原子性的**+1操作**，<strong>线程一执行成功，此时base=11</strong>，<strong>线程二、线程三执行失败后</strong>开始针对于<code>Cell[]</code>数组中的<code>Cell</code>元素进行**+1操作**，同样也是<code>CAS</code>操作，此时数组<code>index=1</code>和<code>index=2</code>中<code>Cell</code>的<code>value</code>都被设置为了1.</p> 
<p>执行完成后，统计累加数据：<code>sum = 11 + 1 + 1 = 13</code>，利用<code>LongAdder</code>进行累加的操作就执行完了，流程图如下：</p> 
<p><img src="https://images2.imgbox.com/ac/13/e1GKCuLJ_o.png" alt="在这里插入图片描述"></p> 
<p>如果要获取真正的<code>long</code>值，只要将各个槽中的变量值累加返回。这种分段的做法类似于<code>JDK7</code>中<code>ConcurrentHashMap</code>的分段锁。</p> 
<p><strong>2、使用Contended注解来消除伪共享</strong></p> 
<p>在 <code>LongAdder</code> 的父类 <code>Striped64</code> 中存在一个 <code>volatile Cell[] cells;</code> 数组，其长度是<strong>2 的幂次方</strong>，每个<code>Cell</code>都使用 <code>@Contended</code> 注解进行修饰，而<code>@Contended</code>注解可以进行<strong>缓存行填充</strong>，从而解决<strong>伪共享问题</strong>。伪共享会导致缓存行失效，缓存一致性开销变大。</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@sun</span><span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Contended <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Cell</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>伪共享</strong>指的是多个线程同时读写同一个缓存行的不同变量时导致的 <code>CPU缓存失效</code>。尽管这些变量之间没有任何关系，但由于在主内存中邻近，存在于同一个缓存行之中，它们的相互覆盖会导致频繁的缓存未命中，引发性能下降。这里对于伪共享我只是提一下概念，并不会深入去讲解，大家可以自行查阅一些资料。</p> 
<p>解决伪共享的方法一般都是使用<strong>直接填充</strong>，我们只需要保证不同线程的变量存在于不同的 <code>CacheLine</code> 即可，使用多余的字节来填充可以做点这一点，这样就不会出现伪共享问题。例如在<code>Disruptor队列</code>的设计中就有类似设计。</p> 
<p><img src="https://images2.imgbox.com/71/49/DmnYj8ZN_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/ef/ab/cXtbD8c1_o.png" alt="在这里插入图片描述"></p> 
<p>在<code>Striped64</code>类中我们可以看看<code>Doug Lea</code>在<code>Cell</code>上加的注释也有说明这一点：</p> 
<p><img src="https://images2.imgbox.com/9a/b3/dlPxRSFp_o.png" alt="在这里插入图片描述"></p> 
<p>框中的翻译如下：</p> 
<p><code>Cell</code>类是<code>AtomicLong</code>添加了<code>padded（via@sun.misc.compended)</code>来消除<strong>伪共享</strong>的变种版本。缓存行填充对于大多数原子来说是繁琐的，因为它们通常不规则地分散在内存中，因此彼此之间不会有太大的干扰。但是，驻留在数组中的原子对象往往彼此相邻，因此在没有这种预防措施的情况下，通常会共享缓存行数据（对性能有巨大的负面影响）。</p> 
<p><strong>3、惰性求值</strong></p> 
<p><code>LongAdder</code>只有在使用<code>longValue()</code>获取当前累加值时才会真正的去结算计数的数据，<code>longValue()</code>方法底层就是调用<code>sum()</code>方法，对<code>base</code>和<code>Cell数组</code>的数据累加然后返回，做到数据写入和读取分离。</p> 
<p>而<code>AtomicLong</code>使用<code>incrementAndGet()</code>每次都会返回<code>long</code>类型的计数值，每次递增后还会伴随着数据返回，增加了额外的开销。</p> 
<h4><a id="43_LongAdder_240"></a>4.3 LongAdder实现原理</h4> 
<p>之前说了，<code>AtomicLong</code>是多个线程针对单个<strong>热点值value进行原子操作</strong>。而<code>LongAdder</code>是每个线程拥有自己的槽，各个线程一般只对自己槽中的那个值进行<code>CAS操作</code>。</p> 
<p>比如有三个线程同时对value增加1，那么<code>value = 1 + 1 + 1 = 3</code></p> 
<p>但是对于<code>LongAdder</code>来说，内部有一个<code>base</code>变量，一个<code>Cell[]</code>数组。<br> <code>base</code>变量：非竞争条件下，直接累加到该变量上<br> <code>Cell[]</code>数组：竞争条件下，累加个各个线程自己的槽<code>Cell[i]</code>中<br> 最终结果的计算是下面这个形式：</p> 
<p><img src="https://images2.imgbox.com/68/fa/bSd4VqWD_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="44_ongAdder_253"></a>4.4 ongAdder源码剖析</h4> 
<p>前面已经用图分析了<code>LongAdder</code>高性能的原理，我们继续看下<code>LongAdder</code>实现的源码：</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LongAdder</span> <span class="token keyword">extends</span> <span class="token class-name">Striped64</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
         <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 
     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
         Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> as<span class="token punctuation">;</span> <span class="token keyword">long</span> b<span class="token punctuation">,</span> v<span class="token punctuation">;</span> <span class="token keyword">int</span> m<span class="token punctuation">;</span> Cell a<span class="token punctuation">;</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>as <span class="token operator">=</span> cells<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">casBase</span><span class="token punctuation">(</span>b <span class="token operator">=</span> base<span class="token punctuation">,</span> b <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
             <span class="token keyword">boolean</span> uncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>as <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>m <span class="token operator">=</span> as<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>
                <span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span><span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> m<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span>
                <span class="token operator">!</span><span class="token punctuation">(</span>uncontended <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">cas</span><span class="token punctuation">(</span>v <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">,</span> v <span class="token operator">+</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token function">longAccumulate</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> null<span class="token punctuation">,</span> uncontended<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">casBase</span><span class="token punctuation">(</span><span class="token keyword">long</span> cmp<span class="token punctuation">,</span> <span class="token keyword">long</span> val<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> UNSAFE<span class="token punctuation">.</span><span class="token function">compareAndSwapLong</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> BASE<span class="token punctuation">,</span> cmp<span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>一般我们进行计数时都会使用<code>increment()</code>方法，每次进行**+1操作**，<code>increment()</code>会直接调用<code>add()</code>方法。</p> 
<p><strong>变量说明：</strong></p> 
<ul><li>as 表示cells引用</li><li>b 表示获取的base值</li><li>v 表示 期望值,</li><li>m 表示 cells 数组的长度</li><li>a 表示当前线程命中的cell单元格</li></ul> 
<p><strong>条件分析：</strong></p> 
<p><strong>条件一：as == null || (m = as.length - 1) &lt; 0</strong><br> 此条件成立说明cells数组未初始化。如果不成立则说明cells数组已经完成初始化，对应的线程需要找到Cell数组中的元素去写值。</p> 
<p><img src="https://images2.imgbox.com/41/29/WjXtRbn0_o.png" alt="在这里插入图片描述"></p> 
<p><strong>条件二：(a = as[getProbe() &amp; m]) == null</strong><br> <code>getProbe()</code>获取当前线程的hash值，m表示cells长度-1，cells长度是2的幂次方数，原因之前也讲到过，与数组长度取模可以转化为按位与运算，提升计算性能。</p> 
<p>当条件成立时说明当前线程通过hash计算出来数组位置处的cell为空，进一步去执行<code>longAccumulate()</code>方法。如果不成立则说明对应的cell不为空，下一步将要将x值通过CAS操作添加到cell中。</p> 
<p><strong>条件三：!(uncontended = a.cas(v = a.value, v + x)</strong><br> 主要看<code>a.cas(v = a.value, v + x)</code>，接着条件二，说明当前线程hash与数组长度取模计算出的位置的cell有值，此时直接尝试一次CAS操作，如果成功则退出if条件，失败则继续往下执行<code>longAccumulate()</code>方法。</p> 
<p><img src="https://images2.imgbox.com/3f/58/t6ZNUXsq_o.png" alt="在这里插入图片描述"></p> 
<p>接着往下看核心的<code>longAccumulate()</code>方法，代码很长，后面会一步步分析，先上代码：</p> 
<p><code>java.util.concurrent.atomic.Striped64.</code>:</p> 
<pre><code class="prism language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">longAccumulate</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> LongBinaryOperator fn<span class="token punctuation">,</span> <span class="token keyword">boolean</span> wasUncontended<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">int</span> h<span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">=</span> <span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
         ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         h <span class="token operator">=</span> <span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         wasUncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
     <span class="token keyword">boolean</span> collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> as<span class="token punctuation">;</span> Cell a<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token keyword">long</span> v<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>as <span class="token operator">=</span> cells<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> as<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    Cell r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token keyword">boolean</span> created <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                            Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> rs<span class="token punctuation">;</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
                            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rs <span class="token operator">=</span> cells<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>m <span class="token operator">=</span> rs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> rs<span class="token punctuation">[</span>j <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                                rs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">;</span>
                                created <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                            <span class="token punctuation">}</span>
                        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
                            cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                        <span class="token punctuation">}</span>
                        <span class="token keyword">if</span> <span class="token punctuation">(</span>created<span class="token punctuation">)</span>
                            <span class="token keyword">break</span><span class="token punctuation">;</span>
                       <span class="token keyword">continue</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
                collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wasUncontended<span class="token punctuation">)</span>
                wasUncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">cas</span><span class="token punctuation">(</span>v <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fn <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> v <span class="token operator">+</span> x <span class="token operator">:</span> fn<span class="token punctuation">.</span><span class="token function">applyAsLong</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> NCPU <span class="token operator">||</span> cells <span class="token operator">!=</span> as<span class="token punctuation">)</span>
                collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>collide<span class="token punctuation">)</span>
                collide <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>cells <span class="token operator">==</span> as<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
                            rs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> as<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
                        cells <span class="token operator">=</span> rs<span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
                    cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            h <span class="token operator">=</span> <span class="token function">advanceProbe</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> cells <span class="token operator">==</span> as <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">boolean</span> init <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>cells <span class="token operator">==</span> as<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                    rs<span class="token punctuation">[</span>h <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    cells <span class="token operator">=</span> rs<span class="token punctuation">;</span>
                    init <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
                cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>init<span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casBase</span><span class="token punctuation">(</span>v <span class="token operator">=</span> base<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fn <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> v <span class="token operator">+</span> x <span class="token operator">:</span> fn<span class="token punctuation">.</span><span class="token function">applyAsLong</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>                          
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>代码很长，<code>if else</code>分支很多，除此看肯定会很头疼。这里一点点分析，然后结合画图一步步了解其中实现原理。</p> 
<p><strong>我们首先要清楚执行这个方法的前置条件，它们是或的关系，如上面条件一、二、三</strong></p> 
<ol><li>cells数组没有初始化</li><li>cells数组已经初始化，但是当前线程对应的cell数据为空</li><li>cells数组已经初始化， 当前线程对应的cell数据为空，且CAS操作+1失败</li></ol> 
<p><strong>longAccumulate()方法的入参：</strong></p> 
<ul><li>long x 需要增加的值，一般默认都是1</li><li>LongBinaryOperator fn 默认传递的是null</li><li>wasUncontended竞争标识，如果是false则代表有竞争。只有cells初始化之后，并且当前线程CAS竞争修改失败，才会是false</li></ul> 
<p><strong>然后再看下Striped64中一些变量或者方法的定义：</strong></p> 
<ul><li>base: 类似于AtomicLong中全局的value值。在没有竞争情况下数据直接累加到base上，或者cells扩容时，也需要将数据写入到base上</li><li>collide：表示扩容意向，false 一定不会扩容，true可能会扩容。</li><li>cellsBusy：初始化cells或者扩容cells需要获取锁, 0:表示无锁状态 1:表示其他线程已经持有了锁</li><li>casCellsBusy(): 通过CAS操作修改cellsBusy的值，CAS成功代表获取锁，返回true</li><li>NCPU：当前计算机CPU数量，Cell数组扩容时会使用到</li><li>getProbe(): 获取当前线程的hash值</li><li>advanceProbe(): 重置当前线程的hash值</li></ul> 
<p><strong>接着开始正式解析longAccumulate()源码：</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> PROBE<span class="token punctuation">;</span>
 
 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>h <span class="token operator">=</span> <span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     h <span class="token operator">=</span> <span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     wasUncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
 
 <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getProbe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> UNSAFE<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> PROBE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们上面说过<code>getProbe()</code>方法是为了获取当前线程的<code>hash值</code>，具体实现是通过<code>UNSAFE.getInt()</code>实现的，<code>PROBE</code>是在初始化时候获取当前线程<code>threadLocalRandomProbe</code>的值。</p> 
<blockquote> 
 <p>注：<code>Unsafe.getInt()</code>有三个重载方法<code>getInt(Object o, long offset)</code>、<code>getInt(long address)</code>和<code>getIntVolatile(long address)</code>，都是从指定的位置获取变量的值，只不过第一个的offset是相对于对象o的相对偏移量，第二个address是绝对地址偏移量。如果第一个方法中o为null是，offset也会被作为绝对偏移量。第三个则是带有volatile语义的load读操作。</p> 
</blockquote> 
<p>如果当前线程的<strong>hash值h=getProbe()为0，0与任何数取模都是0，会固定到数组第一个位置</strong>，所以这里做了优化，使用<code>ThreadLocalRandom</code>为当前线程重新计算一个<code>hash</code>值。最后设置<code>wasUncontended = true</code>，这里含义是重新计算了当前线程的<code>hash</code>后认为此次不算是一次竞争。<code>hash</code>值被重置就好比一个全新的线程一样，所以设置了竞争状态为<code>true</code>。</p> 
<p>可以画图理解为：</p> 
<p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-eeDNufEW-1619405510325)(C:/Users/dell/Desktop/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70)]</p> 
<p>接着执行<code>for循环</code>，我们可以把<code>for循环</code>代码拆分一下，每个<code>if条件</code>算作一个<code>CASE</code>来分析：</p> 
<pre><code class="prism language-java"><span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">longAccumulate</span><span class="token punctuation">(</span><span class="token keyword">long</span> x<span class="token punctuation">,</span> LongBinaryOperator fn<span class="token punctuation">,</span> <span class="token keyword">boolean</span> wasUncontended<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 
     <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
         Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> as<span class="token punctuation">;</span> Cell a<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> <span class="token keyword">long</span> v<span class="token punctuation">;</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>as <span class="token operator">=</span> cells<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> as<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 
         <span class="token punctuation">}</span>
         <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> cells <span class="token operator">==</span> as <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
 
        <span class="token punctuation">}</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casBase</span><span class="token punctuation">(</span>v <span class="token operator">=</span> base<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fn <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> v <span class="token operator">+</span> x <span class="token operator">:</span> fn<span class="token punctuation">.</span><span class="token function">applyAsLong</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>如上所示，第一个<code>if语句代表CASE1</code>，里面再有<code>if判断</code>会以<code>CASE1.1</code>这种形式来讲解，下面接着的<code>else if</code>为<code>CASE2</code>， 最后一个为<code>CASE3</code></p> 
<p><strong>CASE1执行条件</strong>：</p> 
<pre><code class="prism language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>as <span class="token operator">=</span> cells<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> as<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>cells数组</code>不为空，且数组长度大于0的情况会执行<code>CASE1</code>，<code>CASE1</code>的实现细节代码较多，放到最后面讲解。</p> 
<p><strong>CASE2执行条件和实现原理</strong>：</p> 
<pre><code class="prism language-java"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> cells <span class="token operator">==</span> as <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">boolean</span> init <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
         <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
             <span class="token keyword">if</span> <span class="token punctuation">(</span>cells <span class="token operator">==</span> as<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                 Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
                 rs<span class="token punctuation">[</span>h <span class="token operator">&amp;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
                 cells <span class="token operator">=</span> rs<span class="token punctuation">;</span>
                 init <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
             <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
            cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>init<span class="token punctuation">)</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>CASE2</code> 标识<code>cells数组</code>还未初始化，因为判断<code>cells == as</code>，这个代表当前线程到了这里获取的<code>cells</code>还是之前的一致。我们可以先看这个<code>case</code>，最后再回头看最为麻烦的<code>CASE1</code>实现逻辑。</p> 
<p><code>cellsBusy</code>上面说了是加锁的状态，初始化<code>cells数组</code>和扩容的时候都要获取加锁的状态，这个是通过<code>CAS</code>来实现的，为0代表无锁状态，为1代表其他线程已经持有锁了。<code>cells==as</code>代表当前线程持有的数组未进行修改过，<code>casCellsBusy()</code>通过<code>CAS操作</code>去获取锁。但是里面的<code>if条件</code>又再次判断了<code>cell==as</code>，这一点是不是很奇怪？通过画图来说明下问题：</p> 
<p><img src="https://images2.imgbox.com/1c/d7/0T5pR6r2_o.png" alt="在这里插入图片描述"></p> 
<p>cells==as双重判断说明.png</p> 
<p>如果上面条件都执行成功就会执行数组的初始化及赋值操作， <code>Cell[] rs = new Cell[2]</code>表示数组的长度为2，<code>rs[h &amp; 1] = new Cell(x)</code> 表示创建一个新的<code>Cell元素</code>，<strong>value是x值，默认为1。</strong></p> 
<p><code>h &amp; 1</code>类似于我们之前<code>HashMap</code>或者<code>ThreadLocal</code>里面经常用到的计算散列桶<code>index</code>的算法，通常都是<code>hash &amp; (table.len - 1)</code>，这里就不做过多解释了。执行完成后直接退出<code>for循环</code>。</p> 
<p><strong>CASE3执行条件和实现原理</strong>：</p> 
<pre><code class="prism language-java"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casBase</span><span class="token punctuation">(</span>v <span class="token operator">=</span> base<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fn <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> v <span class="token operator">+</span> x <span class="token operator">:</span> fn<span class="token punctuation">.</span><span class="token function">applyAsLong</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
</code></pre> 
<p>进入到这里说明<code>cells</code>正在或者已经初始化过了，执行<code>caseBase()</code>方法，通过<code>CAS操作</code>来修改<code>base</code>的值，如果修改成功则跳出循环，这个<code>CAS</code>E只有在初始化<code>Cell数组</code>的时候，多个线程尝试<code>CAS</code>修改<code>cellsBusy</code>加锁的时候，失败的线程会走到这个分支，然后直接<code>CAS</code>修改<code>base</code>数据。</p> 
<p><strong>CASE1 实现原理</strong>：</p> 
<p>分析完了<code>CASE2和CASE3</code>，我们再折头回看一下<code>CASE1</code>，进入<code>CASE1</code>的前提是：<code>cells数组</code>不为空，已经完成了初始化赋值操作。</p> 
<p>接着还是一点点往下拆分代码，首先看第一个判断分支<code>CASE1.1</code>：</p> 
<pre><code class="prism language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
         Cell r <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
             <span class="token keyword">boolean</span> created <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
             <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
                 Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> rs<span class="token punctuation">;</span> <span class="token keyword">int</span> m<span class="token punctuation">,</span> j<span class="token punctuation">;</span>
                 <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rs <span class="token operator">=</span> cells<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>m <span class="token operator">=</span> rs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> rs<span class="token punctuation">[</span>j <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                     rs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">;</span>
                    created <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
                cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>created<span class="token punctuation">)</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这个if条件中<code>(a = as[(n - 1) &amp; h]) == null</code>代表当前线程对应的数组下标位置的<code>cell</code>数据为<code>null</code>，代表没有线程在此处创建<code>Cell</code>对象。</p> 
<p>接着判断<code>cellsBusy==0</code>，代表当前锁未被占用。然后新创建<code>Cell对象</code>，接着又判断了一遍<code>cellsBusy == 0</code>，然后执行<code>casCellsBusy()</code>尝试通过CAS操作修改<code>cellsBusy=1</code>，加锁成功后修改扩容意向<code>collide = false;</code></p> 
<pre><code class="prism language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rs <span class="token operator">=</span> cells<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>m <span class="token operator">=</span> rs<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> rs<span class="token punctuation">[</span>j <span class="token operator">=</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> h<span class="token punctuation">]</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
         rs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> r<span class="token punctuation">;</span>
         created <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 
     <span class="token keyword">if</span> <span class="token punctuation">(</span>created<span class="token punctuation">)</span>
         <span class="token keyword">break</span><span class="token punctuation">;</span>
     <span class="token keyword">continue</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上面代码判断当前线程<code>hash</code>后指向的数据位置元素是否为空，如果为空则将<code>cell</code>数据放入数组中，跳出循环。如果不为空则继续循环。</p> 
<p><img src="https://images2.imgbox.com/21/ec/98QSmwjj_o.png" alt="在这里插入图片描述"></p> 
<p>继续往下看代码，<strong>CASE1.2</strong>：</p> 
<pre><code class="prism language-java"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>wasUncontended<span class="token punctuation">)</span>
    wasUncontended <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

h <span class="token operator">=</span> <span class="token function">advanceProbe</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>wasUncontended</code>表示<code>cells</code>初始化后，当前线程竞争修改失败<code>wasUncontended =false</code>，这里只是重新设置了这个值为<code>true</code>，紧接着执行<code>advanceProbe(h)</code>重置当前线程的<code>hash</code>，重新循环。</p> 
<p>接着看<strong>CASE1.3</strong>：</p> 
<pre><code class="prism language-java"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">cas</span><span class="token punctuation">(</span>v <span class="token operator">=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>fn <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> v <span class="token operator">+</span> x <span class="token operator">:</span> fn<span class="token punctuation">.</span><span class="token function">applyAsLong</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
</code></pre> 
<p>进入<code>CASE1.3</code>说明当前线程对应的数组中有了数据，也重置过<code>hash值</code>，这时通过CAS操作尝试对当前数中的<code>value值</code>进行累加x操作，x默认为1，如果<code>CAS</code>成功则直接跳出循环。</p> 
<p><img src="https://images2.imgbox.com/a8/5f/eN7iwixg_o.png" alt="在这里插入图片描述"></p> 
<p>接着看<strong>CASE1.4：</strong></p> 
<pre><code class="prism language-java"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">&gt;=</span> NCPU <span class="token operator">||</span> cells <span class="token operator">!=</span> as<span class="token punctuation">)</span>
    collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    
</code></pre> 
<p>如果<code>cells数组</code>的长度达到了<code>CPU核心数</code>，或者<code>cells</code>扩容了，设置扩容意向<code>collide为false</code>并通过下面的<code>h = advanceProbe(h)</code>方法修改线程的<code>probe</code>再重新尝试</p> 
<p>至于这里为什么要提出和<code>CPU数量</code>做判断的问题：每个线程会通过线程对<code>cells[threadHash%cells.length]</code>位置的<code>Cell</code>对象中的<code>value</code>做累加，这样相当于将线程绑定到了<code>cells</code>中的某个<code>cell</code>对象上，如果超过<code>CPU数量</code>的时候就不再扩容是因为<code>CPU</code>的数量代表了机器处理能力，当超过<code>CPU</code>数量时，多出来的<code>cells</code>数组元素没有太大作用。</p> 
<p><img src="https://images2.imgbox.com/56/12/825c9yK1_o.png" alt="在这里插入图片描述"></p> 
<p>接着看<strong>CASE1.5</strong>：</p> 
<pre><code class="prism language-java"> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>collide<span class="token punctuation">)</span>
   collide <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre> 
<p>如果扩容意向<code>collide</code>是<code>false</code>则修改它为<code>true</code>，然后重新计算当前线程的<code>hash</code>值继续循环，在<code>CASE1.4</code>中，如果当前数组的长度已经大于了<code>CPU</code>的核数，就会再次设置扩容意向<code>collide=false</code>，这里的意义是保证扩容意向为<code>false</code>后不再继续往后执行<code>CASE1.6</code>的扩容操作。</p> 
<p><strong>接着看CASE1.6分支：</strong></p> 
<pre><code class="prism language-java"> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>cellsBusy <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">casCellsBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>cells <span class="token operator">==</span> as<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
             Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
             <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
                 rs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> as<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
             cells <span class="token operator">=</span> rs<span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
     <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{<!-- --></span>
        cellsBusy <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    collide <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">continue</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里面执行的其实是扩容逻辑，首先是判断通过<code>CAS</code>改变<code>cellsBusy</code>来尝试加锁，如果<code>CAS</code>成功则代表获取锁成功，继续向下执行，判断当前的<code>cells</code>数组和最先赋值的<code>as</code>是同一个，代表没有被其他线程扩容过，然后进行扩容，扩容大小为之前的容量的两倍，这里用的按位左移1位来操作的。</p> 
<pre><code class="prism language-java">Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> rs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cell</span><span class="token punctuation">[</span>n <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> 
<p>扩容后再将之前数组的元素拷贝到新数组中，释放锁设置<code>cellsBusy = 0</code>，设置扩容状态，然后继续循环执行。</p> 
<p>到了这里，我们已经分析完了<code>longAccumulate()</code>所有的逻辑，逻辑分支挺多，仔细分析看看其实还是挺清晰的，流程图如下：</p> 
<p><img src="https://images2.imgbox.com/82/34/dh7eER2u_o.png" alt="在这里插入图片描述"></p> 
<p>我们再举一些线程执行的例子里面场景覆盖不全，大家可以按照这种模式自己模拟场景分析代码流程：</p> 
<p><img src="https://images2.imgbox.com/22/df/nttUHXuw_o.png" alt="在这里插入图片描述"></p> 
<p>如有问题也请及时指出，我会第一时间更正，不胜感激！</p> 
<h4><a id="45_LongAddersum_642"></a>4.5 LongAdder的sum方法</h4> 
<p>当我们最终获取计数器值时，我们可以使用<code>LongAdder.longValue()</code>方法，其内部就是使用<code>sum</code>方法来汇总数据的。</p> 
<p><code>java.util.concurrent.atomic.LongAdder.sum()</code>:</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     Cell<span class="token punctuation">[</span><span class="token punctuation">]</span> as <span class="token operator">=</span> cells<span class="token punctuation">;</span> Cell a<span class="token punctuation">;</span>
     <span class="token keyword">long</span> sum <span class="token operator">=</span> base<span class="token punctuation">;</span>
     <span class="token keyword">if</span> <span class="token punctuation">(</span>as <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> as<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">=</span> as<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>
                 sum <span class="token operator">+=</span> a<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
     <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>实现很简单，base + <img src="https://images2.imgbox.com/2c/7f/lZLIF4rg_o.png" alt="在这里插入图片描述">，遍历<code>cells</code>数组中的值，然后累加。</p> 
<h4><a id="46_AtomicLong_664"></a>4.6 AtomicLong可以弃用了吗？</h4> 
<p>看上去<code>LongAdder</code>的性能全面超越了<code>AtomicLong</code>，而且阿里巴巴开发手册也提及到 <strong>推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）</strong>，但是我们真的就可以舍弃掉<code>LongAdder</code>了吗？</p> 
<p>当然不是，我们需要看场景来使用，如果是并发不太高的系统，使用<code>AtomicLong</code>可能会更好一些，而且内存需求也会小一些。</p> 
<p>我们看过<code>sum()</code>方法后可以知道<code>LongAdder</code>在统计的时候如果有并发更新，可能导致统计的数据有误差。</p> 
<p>而在高并发统计计数的场景下，才更适合使用<code>LongAdder</code>。</p> 
<h3><a id="5_674"></a>5、总结</h3> 
<p><code>LongAdder</code>中最核心的思想就是利用空间来换时间，将热点<code>value</code>分散成一个<strong>Cell列表来承接并发的CAS</strong>，以此来提升性能。</p> 
<p><code>LongAdder</code>的原理及实现都很简单，但其设计的思想值得我们品味和学习。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/86d9e35498fc897386530427e650cbbc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">JS逆向之淘宝h5视频sign破解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cbae9945f50cb9d2dd8813f6bc2add49/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">probability，odds，logit, softmax, logSoftmax，交叉熵</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>