<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>vue(四) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="vue(四)" />
<meta property="og:description" content="内置指令 我们学过的指令:
v-bind : 单向绑定解析表达式，可简写为:XXx
v-model : 双向数据绑定
v- for : 遍历数组/对象/字符串
v- on : 绑定事件监听，可简写为@
v-if : 条件渲染(动态控制节点是否存存在)
v-else : 条件渲染(动态控制节点是否存存在) v- show : 条件演染(动态控制节点是否展示)
v-text 1.作用:向其所在的节点中渲染文本内容。
2.与插值语法的区别: v-text会替换掉节点中的内容
v-html 注意: v-html有安全性问题
(1).在网站上动态谊染任意HTML是非常危险的。
(2).一定要在可信的内容上使用v-html
v-cloak
1.本质是个特殊属性， Vue重例创建完中并接管容器后，会删掉v- cloak属性。
2.使用css配合v-cloak可以解决网速慢时页面展示出{{xxx}}的
&lt;style&gt; [v-clock]{ display: none; } &lt;/style&gt; &lt;body&gt; &lt;div&gt; &lt;h2 v-cloak&gt;{{name}}&lt;/h2&gt; &lt;/div&gt; &lt;/body&gt; v-once
1.v-once所在节点在初次动态演染后，就视为静态内容了。
2.以后数据的改变不会引起V- once所在结构的更新。可以用于优化性能。
&lt;div id=&#34;root&#34;&gt; &lt;h2 v-once&gt;n的初值：{{n}}&lt;/h2&gt; &lt;h2&gt;当前n的值&lt;/h2&gt; &lt;button @click=&#34;n&#43;&#43;&#34;&gt;点击n&#43;&#43;&lt;/button&gt; &lt;/div&gt; v-pre
1.跳过其所在节点的编译过程。
2.可利用它跳过:没有使用指令语法、没有使用插值语法的节点，会加快编译。
&lt;div id=&#34;root&#34;&gt; &lt;h2 v-pre&gt;Vue&lt;/h2&gt; &lt;h2 v-once&gt;n的初值：{{n}}&lt;/h2&gt; &lt;h2&gt;当前n的值&lt;/h2&gt; &lt;button @click=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e0cb1ca662c03e57ec81df7c83c4d62f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-08T09:55:02+08:00" />
<meta property="article:modified_time" content="2022-04-08T09:55:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">vue(四)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3><strong>内置指令</strong></h3> 
<blockquote> 
 <p>我们学过的指令:<br> v-bind            :        单向绑定解析表达式，可简写为:XXx<br> v-model         :        双向数据绑定<br> v- for              :        遍历数组/对象/字符串<br> v- on              :        绑定事件监听，可简写为@<br> v-if                 :        条件渲染(动态控制节点是否存存在)<br> v-else            :        条件渲染(动态控制节点是否存存在) <br> v- show         :        条件演染(动态控制节点是否展示)</p> 
</blockquote> 
<p></p> 
<h4><strong>v-text</strong></h4> 
<blockquote> 
 <p><br> 1.作用:向其所在的节点中渲染文本内容。<br> 2.与插值语法的区别: v-text会替换掉节点中的内容</p> 
</blockquote> 
<h4>v-html</h4> 
<blockquote> 
 <p>注意: v-html有安全性问题<br> (1).在网站上动态谊染任意HTML是非常危险的。<br> (2).一定要在可信的内容上使用v-html</p> 
</blockquote> 
<p></p> 
<p><strong>v-cloak</strong></p> 
<blockquote> 
 <p>1.本质是个特殊属性， Vue重例创建完中并接管容器后，会删掉v- cloak属性。<br> 2.使用css配合v-cloak可以解决网速慢时页面展示出{<!-- -->{xxx}}的</p> 
</blockquote> 
<pre><code class="language-html">&lt;style&gt;
    [v-clock]{
        display: none;
    }
&lt;/style&gt;

&lt;body&gt;
    &lt;div&gt;
        &lt;h2 v-cloak&gt;{<!-- -->{name}}&lt;/h2&gt;
    &lt;/div&gt;
&lt;/body&gt;</code></pre> 
<p></p> 
<p></p> 
<p><strong>v-once</strong></p> 
<blockquote> 
 <p>1.v-once所在节点在初次动态演染后，就视为静态内容了。<br> 2.以后数据的改变不会引起V- once所在结构的更新。可以用于优化性能。</p> 
</blockquote> 
<pre><code class="language-html">&lt;div id="root"&gt;
    &lt;h2 v-once&gt;n的初值：{<!-- -->{n}}&lt;/h2&gt;
    &lt;h2&gt;当前n的值&lt;/h2&gt;
    &lt;button @click="n++"&gt;点击n++&lt;/button&gt;
&lt;/div&gt;</code></pre> 
<p></p> 
<p> <strong>v-pre</strong></p> 
<blockquote> 
 <p>1.跳过其所在节点的编译过程。<br> 2.可利用它跳过:没有使用指令语法、没有使用插值语法的节点，会加快编译。</p> 
</blockquote> 
<pre><code class="language-html">&lt;div id="root"&gt;
    &lt;h2 v-pre&gt;Vue&lt;/h2&gt;
    &lt;h2 v-once&gt;n的初值：{<!-- -->{n}}&lt;/h2&gt;
    &lt;h2&gt;当前n的值&lt;/h2&gt;
    &lt;button @click="n++"&gt;点击n++&lt;/button&gt;
&lt;/div&gt;</code></pre> 
<p></p> 
<p> <strong>自定义指令：</strong></p> 
<blockquote> 
 <p>在directives中定义自定义指令</p> 
</blockquote> 
<p><strong>例：</strong></p> 
<pre><code class="language-html">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;TODO supply a title&lt;/title&gt;
        &lt;meta charset="GBK"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
       &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt; 
	&lt;div id="root"&gt;
          &lt;div id="root"&gt;
            &lt;span&gt;当前n为：&lt;span v-text="n"&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;
            &lt;span&gt;放大十倍n为：&lt;span v-big="n"&gt;&lt;/span&gt;&lt;/span&gt;&lt;br/&gt;
            &lt;input v-fbind="n"&gt;&lt;br/&gt;
            &lt;button @click="n++"&gt;n++&lt;/button&gt;
	    
    	   
    
	&lt;/div&gt;
    
	&lt;/div&gt;
	&lt;script&gt;

	new Vue({
    	    el:"#root",
	    data:{
		n:1
      	    },
	    directives:{
                //big何时调用？1.数据成功绑定时2.数据更新时
                //简写
                big(element,binding){
                    element.innerText=binding.value*10
                },
                //详写
                fbind:{
                    //数据成功绑定时
                    bind(element,binding){
                        element.innerText=binding.value*10
                    },
                    //插入到页面时
                    inserted(element,binding){
                        element.focus()
                    },
                    //指令被重新解析时
                    update(element,binding){
                        element.innerText=binding.value*10
                    }
                }

	    }
      	    
        
	})
	&lt;/script&gt;
        
    &lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p></p> 
<p></p> 
<h3><strong>生命周期</strong></h3> 
<blockquote> 
 <p><strong>vm的一生(vm的生命周期) :<br>         将要创建===&gt;调用beforeCreate函数。<br>         创建完毕===&gt;调用created函数。 <br>         将要挂载===&gt;调用beforeMount函数。<br>         (重要)挂载完毕===&gt;调用mounted函数。 ============&gt;[重要的钩子)<br>         将要更新===&gt;调用beforeUpdate图数。<br>         更新完毕===&gt; 调用updated函数。<br>         (重要)将要销毁===&gt;调用beforeDestroy函数。=======&gt;[重要的钩子]<br>         销毁完毕===&gt; 调用destroyed函数。</strong><br>  </p> 
</blockquote> 
<p></p> 
<h3>非单文本组件</h3> 
<p><span style="color:#fe2c24;"><strong>组件的定义-------实现应用中局部功能代码和资源的集合</strong></span></p> 
<p></p> 
<h4> Vue中使用组件的三大步骤: </h4> 
<blockquote> 
 <p><br> 一，定义组件(创建组件)<br> 二、注册组件<br> 三、使用组件(写组件标签)</p> 
</blockquote> 
<h4><br> 如何定义一个组件?</h4> 
<blockquote> 
 <p><br> 使用Vue.extend(options)创建，其中options和new Vue(options )时传入的那个options几乎一样，但也有点区别: <br> 区别如下:<br><strong>1.el不要写，为什么?</strong><br> 最终 所有的组件都要经过个vm的管理， 由vm中的el决定服务哪个容器。</p> 
 <p><br><strong>2.data必须写成函数，为什么?</strong></p> 
 <p>避免组件被复用时，数据存在引用关系。<br> 备注:使用template 可以配置组件结构。</p> 
 <p><br><strong>如何注册组件? </strong><br> 1.局部注册:靠new Vue的时候传入components选项<br> 2.全局注册:靠Vue.component('组件名' ,组件)<br><br><strong>三、编写组件标签:</strong><br> &lt;school&gt;&lt;/school&gt;</p> 
</blockquote> 
<p></p> 
<pre><code class="language-html">&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;TODO supply a title&lt;/title&gt;
        &lt;meta charset="GBK"&gt;
        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
       &lt;script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"&gt;&lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt; 
	&lt;div id="root"&gt;
		{<!-- -->{msg}}
            &lt;!--第三步：编写组件标签--&gt;
            &lt;school&gt;&lt;/school&gt;
    	   
    
	&lt;/div&gt;
	&lt;script&gt;
            //第一步：创建组件
            const school=Vue.extend({
                template:'&lt;div&gt;学校名称：&lt;span&gt;{<!-- -->{schoolName}}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;学校地址：{<!-- -->{address}}&lt;/span&gt;&lt;/div&gt;',
                data(){
                    return{
                        schoolName:"aaaaa",
                        address:"bbbbb"
                    }
                }
            })
            
            //第二部：全局注册组件
            //Vue.component("Shool",shool)
            
            //第三部创建vm
            new Vue({
                el:"#root",
                data:{
                    msg:"你好"
                },
		components:{school}

	
      	    
        
	})
	&lt;/script&gt;
        
    &lt;/body&gt;
&lt;/html&gt;</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<h4>组件注意点：</h4> 
<blockquote> 
 <p>几个注意点: <br><strong>1.关于组件名:</strong><br> 一个单词组成:<br> 第一种写法(首字母小写): school<br> 第二种写法(首字母大写): School<br> 多个单词组成<br> 第一种写法(kebab-case命名): my-school <br> 第二种写法(CamelCase 命名): MySchool (需要Vue脚手架支持)<br><strong>备注:</strong><br> (1).组件名尽可能回避HTML中已有的元素名称，例如: h2、H2都不行。<br> (2).可以使用name配置项指定组件在开发者工具中呈现的名字。<br><strong>2.关于组件标签:</strong><br> 第一种写法: &lt;schoo1&gt;&lt;/schoo1&gt;<br> 第二种写法: &lt;school/&gt;<br> 备注:不用使用脚架时，&lt;school/&gt; 会导致后续组件不能渲染。<br>  </p> 
</blockquote> 
<h4><strong> 组件的嵌套：</strong></h4> 
<pre><code class="language-javascript">const school=Vue.extend({
                template:'&lt;div&gt;学校名称：&lt;span&gt;{<!-- -->{schoolName}}&lt;/span&gt;&lt;br/&gt;&lt;span&gt;学校地址：{<!-- -->{address}}&lt;/span&gt;&lt;/div&gt;',
                data(){
                    return{
                        schoolName:"aaaaa",
                        address:"bbbbb"
                    }
                },
                components:{student}
            })</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/77af4f643fa2e0760df35174b59bc659/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">VB / VBA 中比较模式的区别：binarycompare和textcompare区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/852ffcc11068e55a35520fa3c2e2be94/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">opencv同时显示两张图片</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>