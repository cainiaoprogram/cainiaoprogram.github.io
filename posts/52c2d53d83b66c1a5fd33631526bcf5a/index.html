<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Python下使用Pytest参数化&#43;Fixture&#43;Allure - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Python下使用Pytest参数化&#43;Fixture&#43;Allure" />
<meta property="og:description" content="前言：上一期文章，我们讲解了unittest框架的核心及使用方式，今天我们再来介绍另外一个框架：Pytest
一、pytest安装 a) 主流框架：
unittest -python自带
pytest -三方库
nose -三方库
behava -BDD
b) 安装Pytest:
1.安装命令：pip install pytest
2.设置pychram编译为：pytest
3.删除历史运行，不然pytest运行不了
二、pytest的使用 a) 具体使用
1.用例名称：
不可以有__init__(） ，类下下面的方法也是如此
函数名，必须以 def test_开头
2.断言比对： 断言(实际和预期的对比 ) assert 表达式（True/False）
例子： assert random_num() == 7 我希望这个随机数是7
3.异常捕获： AssertionError就代表用例失败
用例抛其他异常了
异常报错示例： b) 编写用例及运行
用例示例：
import pytest class TestDemo: #类名以Test开头，不然识别不了这个个用例类 #这里不能写__init__初始化函数，因为这是个测试类 def test_demo001(self): #函数名以Test开头，不然识别不用例 &#34;&#34;&#34;测试用例函数&#34;&#34;&#34; assert 1 == 1 #assert:pytest内置的断言方法 ——》 assert A == B 断言A是否等于B def test_demo002(self): &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/52c2d53d83b66c1a5fd33631526bcf5a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-18T17:43:15+08:00" />
<meta property="article:modified_time" content="2022-08-18T17:43:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Python下使用Pytest参数化&#43;Fixture&#43;Allure</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>        前言：上一期文章，我们讲解了unittest框架的核心及使用方式，今天我们再来介绍另外一个框架：Pytest<img alt="" height="112" src="https://images2.imgbox.com/03/aa/YfKJDPCK_o.gif" width="112"></p> 
<p> </p> 
<h3><strong>一、pytest安装</strong></h3> 
<p><strong>a) 主流框架：</strong></p> 
<blockquote> 
 <p>unittest -python自带</p> 
 <p>pytest -三方库</p> 
 <p>nose -三方库</p> 
 <p>behava -BDD</p> 
</blockquote> 
<p><strong>b) 安装Pytest:</strong></p> 
<p>1.安装命令：pip install pytest</p> 
<p><img alt="" height="519" src="https://images2.imgbox.com/b3/6c/J9MEZbD0_o.jpg" width="993"></p> 
<p> 2.设置pychram编译为：pytest</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/e5/ab/Lt4zY0aQ_o.jpg" width="1072"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/06/b1/ziMWSJxX_o.jpg" width="1200"></p> 
<p>3.删除历史运行，不然pytest运行不了</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/33/8d/nRBG7A5C_o.jpg" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/75/38/OD8FDZXp_o.jpg" width="1200"> </p> 
<p> </p> 
<h3><strong>二、pytest的使用</strong></h3> 
<p></p> 
<p><strong>a) 具体使用</strong></p> 
<blockquote> 
 <p>1.用例名称：</p> 
 <p>        不可以有__init__(） ，类下下面的方法也是如此</p> 
 <p>        函数名，必须以 def test_开头</p> 
 <p></p> 
 <p>2.断言比对：        </p> 
 <p>        断言(实际和预期的对比 )  assert 表达式（True/False）</p> 
 <p>        例子：    assert  random_num() == 7   我希望这个随机数是7</p> 
 <p></p> 
 <p>3.异常捕获： </p> 
 <p>           AssertionError就代表用例失败</p> 
 <p>           用例抛其他异常了</p> 
</blockquote> 
<p>异常报错示例： </p> 
<p><img alt="" height="96" src="https://images2.imgbox.com/c5/ed/4NCPunik_o.jpg" width="868"></p> 
<p></p> 
<p><strong>b) 编写用例及运行</strong></p> 
<p><strong>用例示例：</strong></p> 
<pre><code class="language-python">import pytest


class TestDemo:  #类名以Test开头，不然识别不了这个个用例类

    #这里不能写__init__初始化函数，因为这是个测试类

    def test_demo001(self): #函数名以Test开头，不然识别不用例
        """测试用例函数"""
        assert  1 == 1   #assert:pytest内置的断言方法 ——》  assert A == B 断言A是否等于B

    def test_demo002(self):
        """测试用例函数"""
        assert  1 == 2

pytest.main()
</code></pre> 
<p><strong>c) pytest运行方式： </strong></p> 
<pre><code class="language-python">方法一：

    把用例运行器修改成 pytest, 点击播放键运行

方法二：

- 在当前目录下运行
- 运行所有的用例：pytest.main() 或者 pytest</code></pre> 
<p></p> 
<p><strong>d) pytest运行结果图解： </strong></p> 
<p><img alt="" height="888" src="https://images2.imgbox.com/dd/87/Wzqff9jE_o.jpg" width="1200"></p> 
<p></p> 
<h3><strong>三、pytest收集用例的原理</strong></h3> 
<blockquote> 
 <p>1、收集目录：以rootdir作为根目录。从rootdir目录下开始搜索用例</p> 
 <p></p> 
 <p>2、文件名称以test_**.py  或者文件名以_test结果的py文件</p> 
 <p></p> 
 <p>3、文件下的用例过滤：.py下的函数，函数名以test_开头/.py下类里面的方法,方法名以test开头</p> 
</blockquote> 
<p></p> 
<h3><strong>四、pytest的数据驱动方式（DDT方式）</strong></h3> 
<p><strong>a）概念</strong></p> 
<blockquote> 
 <p>应用场景：场景流程是一样的，只有数据不一样。 --- 参数化</p> 
 <p></p> 
 <p>python测试框架当中应用数据驱动:</p> 
 <p>unittest: ddt库<br> pytest:  自带的。</p> 
</blockquote> 
<p><strong>b) 参数化的使用</strong></p> 
<blockquote> 
 <p>@pytest.mark.parametrize("参数名",列表数据)------参数化函数</p> 
 <p>        参数名：用来接收每一项数据，并作为测试用例的参数。</p> 
 <p>        列表数据：多组测试数据。</p> 
</blockquote> 
<p><strong>代码示例：</strong></p> 
<pre><code class="language-python">示例:
import pytest
from .login import login_check

datas = [
    {"user":'python37', "passwd": 'lemonban', "check": {"code": 0, "msg": "登录成功"} },
    {"user":'python37', "passwd": 'lemonban666', "check": {"code": 1, "msg": "账号或密码不正确"} },
    {"user": 'python370', "passwd": 'lemonban', "check": {"code": 1, "msg": "账号或密码不正确"}},
    {"user": None, "passwd": 'lemonban', "check": {"code": 1, "msg": "所有的参数不能为空"}},
    {"user": 'python37', "passwd": None, "check": {"code": 1, "msg": "所有的参数不能为空"}}
]

class TestLogin:#定义类

    # @pytest.mark.parametrize 专门是pyttest做的数据驱动，应用场景：场景流程是一样的，只有数据不一样——————参数化
    @pytest.mark.parametrize("case",datas) #case任意取得，datas是你要传进来的数据
    def test_login(self,case):#这里需要用case来接收每一组数据，这个case名字要跟上面取得名字一致
            actual = login_check(case["user"],case["passwd"])
            assert actual == case["check"]
</code></pre> 
<pre><code class="language-python">import pytest

test_data = [{"测试数据001"},{"测试数据002"},{"测试数据003"},{"测试数据004"},{"测试数据005"}]  #做数据驱动的数据，列表嵌套字典的格式


class TestDemo:  #类名以Test开头，不然识别不了这个个用例类
    #这里不能写__init__初始化函数，因为这是个测试类

    @pytest.mark.parametrize("info", test_data) #@pytest.mark.parametrize（自定义变量名，用到的数据驱动名称,比如这里就是test_data）
    def test_demo001(self,info): #函数名以Test开头，不然识别不用例
        """测试用例函数"""
        print(info)
        assert  1 == 1   #assert:pytest内置的断言方法 ——》  assert A == B 断言A是否等于B

pytest.main()</code></pre> 
<p><img alt="" height="973" src="https://images2.imgbox.com/e6/f3/VOhrtPGG_o.jpg" width="1200"></p> 
<p> </p> 
<h3><strong>五、pytest的前后置（fixtrue）</strong></h3> 
<p></p> 
<p><strong>a) 前置/后置原理：</strong></p> 
<blockquote> 
 <p>测试用例的：</p> 
 <p>                     前置操作(准备工作 - 准备环境/数据/资源...)、<br>                      后置操作(清理工作 -关闭环境/清理数据/释放资源...)</p> 
</blockquote> 
<p><strong>a1) fixtrue的语法</strong></p> 
<blockquote> 
 <p>前置工作 - setup:</p> 
 <p>                     在每条测试用例执行之前，打印：一条测试用例开始执行</p> 
 <p></p> 
 <p>yield#用来区分前后置       </p> 
 <p>                     前后置代码的分割代码，yield之前是前置代码，yield是后置代码     </p> 
 <p></p> 
 <p>后置工作 - teardown</p> 
 <p>                     在每条测试用例执行之后，打印：一条测试用例执行结束</p> 
</blockquote> 
<p><strong>a2) fixtrue的定义</strong></p> 
<p><img alt="" height="286" src="https://images2.imgbox.com/8e/3d/WHc4T3iw_o.jpg" width="1043"></p> 
<p><strong> a3) 代码示例：@pytest.fixture()</strong></p> 
<pre><code class="language-python">例子：
    @pytest.fixture(autouse=True)
    def hello(self):
        #前置准备工作的代码
        print("一条用例开始执行了")
        print("66666666666666666")
        yield #前后置代码的分割代码，yield之前是前置代码，yield是后置代码
        #后置清理工作的代码
        print("一条用例执行结束了")
        print("99999999999999999")</code></pre> 
<p></p> 
<p><strong>b) 夹具的function作用域</strong></p> 
<blockquote> 
 <p>fixture 作用域：<br> -function（测试函数-默认）、<br> -class（测试类）<br> -module（测试模块）、<br> -session（测试会话）----用scope="xxx"来设置</p> 
 <p></p> 
 <p></p> 
 <p> fixture 作用域:<br> - 函数<br> - 类<br> - 模块<br> - 包<br> - session</p> 
 <p>顺序：<br> session -&gt; 包 -》 模块 -》 类 -》函数<br> 同一级别，哪个在前，先执行</p> 
</blockquote> 
<p><strong>b1) autouse:调用前后置</strong></p> 
<blockquote> 
 <p>@pytest.fixture(autouse=True)<br> autouse就是用来调用前后置的</p> 
</blockquote> 
<p><img alt="" height="972" src="https://images2.imgbox.com/a0/40/QwkdiixV_o.jpg" width="1200"></p> 
<p><strong>b2) 调用fixture</strong></p> 
<blockquote> 
 <p> 在测试类/测试用例的名字上：<br> @pytest.mark.usefixtures("定义的fixtrue名字") ----支持调用多个</p> 
</blockquote> 
<p><img alt="" height="993" src="https://images2.imgbox.com/35/6c/nYCsC84W_o.jpg" width="1200"></p> 
<p><strong>b3 ) yield 返回值</strong></p> 
<blockquote> 
 <p>在定义的时候：yield 返回值<br> 在调用的时候，将fixture的名字作为用例的参数，去接收返回值并使用<br> 如果fixture作为用例参数时，那么我们在用例前面是可以不用 @pytest..mark.usefixtures</p> 
</blockquote> 
<p><strong>b4 ) fixture继承</strong></p> 
<blockquote> 
 <p>     "继承"  fixture使用其它的fixture<br>      @pytest.fixture(scope="class")<br>      def class_fix():<br>         # 前置准备工作的代码<br>         print("-----测试类下的用例开始执行------")<br>         yield#用来区分前后置<br>         # 后置清理工作的代码<br>         print("-----测试类下的用例执行结束------")</p> 
</blockquote> 
<pre><code class="language-python">    @pytest.fixture
    def hello(class_fix):
        # 前置准备工作的代码
        print("打开浏览器，打开淘宝，登陆成功")
        yield
        # 后置清理工作的代码
        print("退出帐号，关闭浏览器")

    执行顺序：
    class_fix的前置
    hello的前置
    hellor的后置
    class_fix的后置

    fixture1(fixture2) --fixture2的scope不能低于fixture1</code></pre> 
<p><strong>b5 ) fixture共享机制（conftest）</strong></p> 
<blockquote> 
 <p>注意点：conftest（名字固定不能改）一般在工程根目录放一个conftest.py起到全局作用  ——重点 </p> 
 <p></p> 
 <p>共享机制：<br>      定义的fixture,不同的.py里的测试用例，都可以调用。</p> 
 <p>     公共的地方：conftest.py(存放fixtures)</p> 
 <p>     不需要测试用例.py文件去引入，pytest会自动找的。</p> 
 <p><br>      (fixtures可以放在类里面、 .py里面、  conftest.py)</p> 
 <p>     用例当中如果调用了fixture，<br>      那么，首先找自己所在的文件有没有<br>      如果有，优先用自己的。<br>      如果没有，则会去找同级目录下的conftest.py里有没有<br>      如果同级没有，则会去上找一级目录下的conftest.py里有没有<br>      ...<br>      一直到rootdir</p> 
</blockquote> 
<p></p> 
<h3><strong>六、pytest的测试报告（Allure）</strong></h3> 
<p><strong>—— 踩坑</strong></p> 
<p><img alt="" height="999" src="https://images2.imgbox.com/02/8b/fxcaelSF_o.jpg" width="1200"></p> 
<p></p> 
<p><strong>a) Allure报告安装及配置环境变量 </strong></p> 
<blockquote> 
 <p>allure报告  - allure插件</p> 
 <p>        1、要生成allure工具可以解析的测试结果文件</p> 
 <p>        2、再用allure工具，将测试结果文件生成报告</p> 
 <p>        3、 命令：pip install allure-pytest，安装的是allure命令行工具，不是allure工具</p> 
 <p></p> 
 <p>下载allure工具：https://repo.maven.apache.org/maven2/io/qameta/allure/allure-commandline/</p> 
 <p></p> 
 <p>MAC配置Allure环境变量：https://zhuanlan.zhihu.com/p/343497208https://zhuanlan.zhihu.com/p/343497208</p> 
 <p></p> 
 <p>Windows配置环境变量：https://www.cnblogs.com/Simple-Small/p/11512337.html</p> 
</blockquote> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/23/54/pOrdO2gx_o.jpg" width="1200"></p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/4e/b0/x70deIem_o.jpg" width="1200"></p> 
<p> </p> 
<p><strong>b) 再用allure工具，将测试结果文件生成报告</strong></p> 
<p>PS：测试结果文件的路径不能出错<br>         命令：allure serve 测试结果文件的路径</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/31/d3/kyYaMBF2_o.jpg" width="1200"></p> 
<p></p> 
<p>在pytest执行用例的命令当中，添加：<br> --alluredir =路径（相对于rootdir）</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/75/5d/wohiqAxI_o.jpg" width="1200"></p> 
<p> </p> 
<h3><strong>七、pytest的测试报告（HTML）——不推荐，不好用，难看</strong></h3> 
<blockquote> 
 <p>html报告 -html插件</p> 
 <p></p> 
 <p>安装：</p> 
 <p>        Windows命令：pip install pytest -html</p> 
 <p>        Mac命令：python3 -m pip install pytest-html</p> 
</blockquote> 
<p>生成报告：</p> 
<pre><code class="language-python">pytest命令加入参数： --html=报告路径(相对于rootdir)


import pytest
pytest.main(["-s","-v","--html=py37.html"])#在命令行运行pytest效果一样</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5f3a844d68bb5e5f06b9f926af991656/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">EntityFramework实体框架—反向工程（实体类生成）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f4cea783001b08f07c3fa47d5d2596a3/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Bootstrap简述</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>