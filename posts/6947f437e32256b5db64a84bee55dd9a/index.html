<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>AFL入门笔记 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="AFL入门笔记" />
<meta property="og:description" content="文章目录 1. 安装2. 插桩3. Quick Startcorpus基本使用输出多线程字典崩溃分析 4. 用户手册如何查看结果如何配置（环境变量）多线程 5. Using ASAN with AFL6. TipsFuzz优化 7. More about AFLAFL原理 8. Demo9. 其它参考资料 官方文档：https://afl-1.readthedocs.io/en/latest/fuzzing.html 其他文章：
https://www.freebuf.com/articles/system/191536.htmlhttps://xz.aliyun.com/t/4314 1. 安装 https://afl-1.readthedocs.io/en/latest/INSTALL.html
Ubuntu直接在AFL根目录make编译安装即可：
sudo make &amp;&amp; sudo make install 2. 插桩 https://afl-1.readthedocs.io/en/latest/instrumenting.html
如果有目标程序的源码，就可以对源码进行编译时插桩。AFL也可以使用AFL的QEMU mode对二进制文件进行插桩，但是编译时插桩效率要高很多。
afl-gcc/afl-g&#43;&#43;作为gcc/g&#43;&#43;的wrapper, 用法与gcc/g&#43;&#43;完全一样, 大概提供了这么一些：
afl-gcc,afl-g&#43;&#43;, afl-clang, afl-clang&#43;&#43;, afl-clang-fast, afl-clang-fast&#43;&#43; 配置一下就能用：
./configure CC=&#34;afl-gcc&#34; CXX=&#34;afl-g&#43;&#43;&#34; 如果目标是共享库，可以设置LD_LIBRARY_PATH让程序加载经过AFL插桩的.so文件：
./configure --disable-shared CC=&#34;afl-gcc&#34; CXX=&#34;afl-g&#43;&#43;&#34; 划重点，Linux版的校验器~， 有大佬说，“AFL Fuzzing without ASAN is just a waste of CPU”.
AFL配备了谷歌自家的Address Sanitizer（ASAN），一个内存检测工具，相当于windows下的verifier校验器：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6947f437e32256b5db64a84bee55dd9a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-01T20:57:38+08:00" />
<meta property="article:modified_time" content="2022-04-01T20:57:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">AFL入门笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#1__8" rel="nofollow">1. 安装</a></li><li><a href="#2__18" rel="nofollow">2. 插桩</a></li><li><a href="#3_Quick_Start_72" rel="nofollow">3. Quick Start</a></li><li><ul><li><a href="#corpus_76" rel="nofollow">corpus</a></li><li><a href="#_97" rel="nofollow">基本使用</a></li><li><a href="#_132" rel="nofollow">输出</a></li><li><a href="#_144" rel="nofollow">多线程</a></li><li><a href="#_148" rel="nofollow">字典</a></li><li><a href="#_156" rel="nofollow">崩溃分析</a></li></ul> 
  </li><li><a href="#4__208" rel="nofollow">4. 用户手册</a></li><li><ul><li><a href="#_212" rel="nofollow">如何查看结果</a></li><li><a href="#_229" rel="nofollow">如何配置（环境变量）</a></li><li><a href="#_239" rel="nofollow">多线程</a></li></ul> 
  </li><li><a href="#5_Using_ASAN_with_AFL_248" rel="nofollow">5. Using ASAN with AFL</a></li><li><a href="#6_Tips_252" rel="nofollow">6. Tips</a></li><li><ul><li><a href="#Fuzz_254" rel="nofollow">Fuzz优化</a></li></ul> 
  </li><li><a href="#7_More_about_AFL_258" rel="nofollow">7. More about AFL</a></li><li><ul><li><a href="#AFL_260" rel="nofollow">AFL原理</a></li></ul> 
  </li><li><a href="#8_Demo_268" rel="nofollow">8. Demo</a></li><li><a href="#9__381" rel="nofollow">9. 其它参考资料</a></li></ul> 
</div> 
<br> 官方文档：https://afl-1.readthedocs.io/en/latest/fuzzing.html 
<p></p> 
<p>其他文章：</p> 
<ul><li>https://www.freebuf.com/articles/system/191536.html</li><li>https://xz.aliyun.com/t/4314</li></ul> 
<h2><a id="1__8"></a>1. 安装</h2> 
<p>https://afl-1.readthedocs.io/en/latest/INSTALL.html</p> 
<p>Ubuntu直接在AFL根目录make编译安装即可：</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>
</code></pre> 
<h2><a id="2__18"></a>2. 插桩</h2> 
<p>https://afl-1.readthedocs.io/en/latest/instrumenting.html</p> 
<p>如果有目标程序的源码，就可以对源码进行编译时插桩。AFL也可以使用AFL的<code>QEMU mode</code>对二进制文件进行插桩，但是编译时插桩效率要高很多。</p> 
<p>afl-gcc/afl-g++作为gcc/g++的wrapper, 用法与gcc/g++完全一样, 大概提供了这么一些：</p> 
<pre><code class="prism language-shell">afl-gcc,afl-g++, 
afl-clang, afl-clang++, 
afl-clang-fast, afl-clang-fast++
</code></pre> 
<p>配置一下就能用：</p> 
<pre><code class="prism language-shell">./configure <span class="token assign-left variable">CC</span><span class="token operator">=</span><span class="token string">"afl-gcc"</span> <span class="token assign-left variable">CXX</span><span class="token operator">=</span><span class="token string">"afl-g++"</span>
</code></pre> 
<p>如果目标是共享库，可以设置<code>LD_LIBRARY_PATH</code>让程序加载经过AFL插桩的.so文件：</p> 
<pre><code class="prism language-shell">./configure --disable-shared <span class="token assign-left variable">CC</span><span class="token operator">=</span><span class="token string">"afl-gcc"</span> <span class="token assign-left variable">CXX</span><span class="token operator">=</span><span class="token string">"afl-g++"</span> 
</code></pre> 
<p>划重点，<strong>Linux版的校验器</strong>~， 有大佬说，“AFL Fuzzing without ASAN is just a waste of CPU”.</p> 
<p>AFL配备了谷歌自家的Address Sanitizer（ASAN），一个内存检测工具，相当于windows下的verifier校验器：</p> 
<pre><code class="prism language-shell"><span class="token assign-left variable">CC</span><span class="token operator">=</span>afl-gcc <span class="token assign-left variable">CFLAGS</span><span class="token operator">=</span><span class="token string">"-g -fsanitize=address -O1 -fno-omit-frame-pointer"</span> <span class="token assign-left variable">AFL_USE_ASAN</span><span class="token operator">=</span><span class="token number">1</span> ./configure
<span class="token function">make</span> clean all
<span class="token comment"># or</span>
afl-gcc -fsanitize<span class="token operator">=</span>address -O1 -fno-omit-frame-pointer <span class="token punctuation">..</span>.
</code></pre> 
<p>项目地址：https://github.com/google/sanitizers, wiki很详细。</p> 
<p>其它校验器还有MemorySanitizer, ThreadSanitizer, LeakSanitizer。</p> 
<pre><code class="prism language-shell">-fsanitize<span class="token operator">=</span>memory -fPIE -pi
-fsanitize<span class="token operator">=</span>leak
<span class="token punctuation">..</span>.
</code></pre> 
<p>如果没有目标程序源码，就要对目标程序（Non-instrumented binaries）进行黑盒测试，需要<code>-Q</code>参数使用QEMU 模式。需要先下载依赖并执行afl下的脚本：</p> 
<pre><code class="prism language-shell">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> libini-config-dev libtool-bin automake bison libglib2.0-dev -y
$ <span class="token builtin class-name">cd</span> qemu_mode <span class="token operator">&amp;&amp;</span> build_qemu_support.sh
</code></pre> 
<h2><a id="3_Quick_Start_72"></a>3. Quick Start</h2> 
<p>https://afl-1.readthedocs.io/en/latest/fuzzing.html</p> 
<h3><a id="corpus_76"></a>corpus</h3> 
<p>译为语料，有时也叫样本。</p> 
<p>语料大小最好1Kb，可参考/testcases子目录。</p> 
<p>如果语料很多很大，可以使用afl-cmin工具来筛选，假设有多个文件，都覆盖了相同的代码，那么就丢掉多余的文件。</p> 
<pre><code class="prism language-shell">afl-cmin <span class="token punctuation">[</span> options <span class="token punctuation">]</span> -- /path/to/target_app <span class="token punctuation">[</span> <span class="token punctuation">..</span>. <span class="token punctuation">]</span>
afl-cmin -i input_dir -o output_dir -- /path/to/tested/program <span class="token punctuation">[</span>params<span class="token punctuation">]</span> @@
<span class="token comment"># @@ 会替换为语料文件</span>
</code></pre> 
<p>测试一个项目时，项目目录里一般也会有输入用例，直接拿来用就行。</p> 
<p>另外还有很多开源的语料库：</p> 
<ul><li>https://github.com/google/fuzzer-test-suite</li><li>http://samples.ffmpeg.org/</li></ul> 
<h3><a id="_97"></a>基本使用</h3> 
<p>如果已经配置了崩溃转储，可能会让afl-fuzz把崩溃误判为超时，所以修改下core_pattern文件：</p> 
<pre><code class="prism language-shell"><span class="token builtin class-name">echo</span> core <span class="token operator">&gt;</span>/proc/sys/kernel/core_pattern
</code></pre> 
<p>我测试时，如果没有修改core_pattern，afl-fuzz是会报错提示的。</p> 
<p>针对读取stdin的程序进行fuzz:</p> 
<pre><code class="prism language-shell">afl-fuzz -i testcase_dir -o findings_dir /path/to/program <span class="token punctuation">[</span><span class="token punctuation">..</span>.params<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre> 
<p>针对读取文件的程序进行fuzz:</p> 
<pre><code class="prism language-shell">afl-fuzz -i testcase_dir -o findings_dir /path/to/program @@
<span class="token comment"># @@ 会替换为语料文件</span>
</code></pre> 
<p>其它选项，如<code>-f， -d</code>，可以查看-h帮助信息。</p> 
<p>可以搭配元老级工具screen。</p> 
<p>如果没有源码，那么带上-Q使用qemu模式进行黑盒测试：</p> 
<pre><code class="prism language-shell">afl-fuzz -Q -m none -i <span class="token keyword">in</span> -o out /path/to/tested/program <span class="token punctuation">[</span>params<span class="token punctuation">]</span> @@
</code></pre> 
<p>如何看输出信息，可参考<a href="https://afl-1.readthedocs.io/en/latest/user_guide.html#status-screen" rel="nofollow">Understanding the status screen</a>。</p> 
<h3><a id="_132"></a>输出</h3> 
<p>Fuzz过程中会生成3个目录：</p> 
<ul><li>queue, 语料库，可以用afl-cmin进一步优化；</li><li>crashes，导致崩溃（SIGSEGV, SIGILL, SIGABRT）的语料；</li><li>hangs，导致超时/卡死/死循环的语料。</li></ul> 
<p>尝试复现崩溃时，记着设置与afl-fuzz参数相同的参数，如-m和LIMIT_MB.</p> 
<p>如果安装了gnuplot ，可以用afl-plot生成统计图。</p> 
<h3><a id="_144"></a>多线程</h3> 
<p>如何多线程fuzz，可参考<a href="https://afl-1.readthedocs.io/en/latest/user_guide.html#parallel-fuzzing" rel="nofollow">Tips for parallel fuzzing</a>，这里还提到如何与其它fuzzer联动。</p> 
<h3><a id="_148"></a>字典</h3> 
<p>AFL适合比较紧凑的文件格式，如图像、多媒体、压缩文件、正则表达式、shell脚本等，不适合html、sql这种特别复杂的语言。</p> 
<p>AFL-fuzz支持用-x参数指定语料字典，可参考<code>dictionaries/README.dictionaries</code>，该目录下也提供了sql、js等例子。</p> 
<p>即使没有-x指定，afl-fuzz也会通过插桩从输入的预料中提取关键字，不过效果没有-x好。</p> 
<h3><a id="_156"></a>崩溃分析</h3> 
<p>出现崩溃后，我们的目的之一是判断这是不是可利用的漏洞。</p> 
<p>每一个崩溃语料都能追溯到它的上一个没有崩溃的语料（父语料），这有助于分析原因。</p> 
<p>一般操作：</p> 
<ul><li>用xxd, 010editor之类的工具看下崩溃语料的十六进制数据；</li><li>gdb调试。</li></ul> 
<p>AFL-fuzz的-C选项可以进入崩溃探索模式（crash exploration mode），该模式通过输入崩溃语料反馈代码路径。</p> 
<p>除了agl-cmin，还有另一个语料优化工具afl-tmin , 它可以减小语料文件的大小, 有插桩模式和崩溃模式：</p> 
<pre><code class="prism language-shell"><span class="token comment"># default instrumented mode</span>
afl-tmin -i test_case -o minimized_result -- /path/to/program <span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>
afl-tmin -i test_case -o minimized_result -- /path/to/program @@

<span class="token comment"># crash mode</span>
afl-tmin -x -i test_case -o minimized_result -- /path/to/program <span class="token punctuation">[</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>
afl-tmin -x -i test_case -o minimized_result -- /path/to/tested/program @@
</code></pre> 
<p>AFL还提供了分析工具afl-analyze, 可参考<a href="https://afl-1.readthedocs.io/en/latest/about_afl.html#technical-details" rel="nofollow">How AFL works</a>页面的末尾 【The afl-analyze tool】 部分。</p> 
<p>AFL的experimental目录下还提供了triage_crashes.sh脚本，可触发收集到的崩溃。</p> 
<p>对于被测试的程序，使用一些宏有助于减少随机数带来的影响，可参考<a href="https://www.llvm.org/docs/LibFuzzer.html" rel="nofollow">libFuzzer</a>文档：</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">MyInitPRNG</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">FUZZING_BUILD_MODE_UNSAFE_FOR_PRODUCTION</span></span>
  <span class="token comment">// In fuzzing mode the behavior of the code should be deterministic.</span>
  <span class="token function">srand</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
  <span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
<span class="token punctuation">}</span>
</code></pre> 
<p>AFL专有的宏是<code>__AFL_COMPILER</code>。</p> 
<p>其它崩溃分析工具：</p> 
<ul><li>https://github.com/bnagy/crashwalk</li><li>https://github.com/rc0r/afl-utils</li><li>afl-cov， 计算覆盖率</li></ul> 
<h2><a id="4__208"></a>4. 用户手册</h2> 
<p>https://afl-1.readthedocs.io/en/latest/user_guide.html</p> 
<h3><a id="_212"></a>如何查看结果</h3> 
<p>包括字段的颜色以及含义</p> 
<p>关注点：</p> 
<ol><li>last new path 如果报错那么要及时修正命令行参数，不然继续fuzz也是徒劳（因为路径是不会改变的）；</li><li>cycles done 如果变绿就说明后面及时继续fuzz，出现crash的几率也很低了，可以选择在这个时候停止</li><li>uniq crashes 代表的是crash的数量</li></ol> 
<p>afl-fuzz永远不会停止（所以推荐搭配screen），所以何时停止测试是依靠fuzz状态来决定的，除了cycles done字段颜色，还有以下方法：</p> 
<ul><li>afl-whatsup</li><li>afl-stat, 类似afl-whatsup</li><li>afl-plot</li><li>pythia</li></ul> 
<h3><a id="_229"></a>如何配置（环境变量）</h3> 
<p>比如启用ASAN：</p> 
<pre><code class="prism language-shell">
</code></pre> 
<h3><a id="_239"></a>多线程</h3> 
<p>除了单机上多线程，文档还提供了分布式教程，源码位于<code>/experimental/distributed_fuzzing/</code></p> 
<p>其它开源实现：</p> 
<ul><li>https://github.com/MartijnB/disfuzz-afl</li><li>https://github.com/richo/roving</li></ul> 
<h2><a id="5_Using_ASAN_with_AFL_248"></a>5. Using ASAN with AFL</h2> 
<h2><a id="6_Tips_252"></a>6. Tips</h2> 
<h3><a id="Fuzz_254"></a>Fuzz优化</h3> 
<p>https://afl-1.readthedocs.io/en/latest/tips.html#performance-tips</p> 
<h2><a id="7_More_about_AFL_258"></a>7. More about AFL</h2> 
<h3><a id="AFL_260"></a>AFL原理</h3> 
<p><a href="https://afl-1.readthedocs.io/en/latest/about_afl.html#technical-details" rel="nofollow">More about AFL</a></p> 
<p>AFL使用了fork server来提高性能，目标程序只需要执行一次execve()、链接和libc初始化，利用写时拷贝基址克隆进程。</p> 
<p>但不断fork也会影响性能，于是提供了Persistent Mode。可以参考<code>/experimental/persistent_demo</code>示例。</p> 
<h2><a id="8_Demo_268"></a>8. Demo</h2> 
<p>以<a href="https://github.com/the-tcpdump-group/tcpdump.git">tcpdump</a>为例，源码tests目录下提供了很多pcap用例，可以作为语料。</p> 
<p>另外还需要<a href="https://github.com/the-tcpdump-group/libpcap.git">libcap</a>源码。</p> 
<p>正常查看pcap的命令：</p> 
<pre><code class="prism language-shell"><span class="token function">sudo</span> tcpdump -vv -nnr tests/tftp-heapoverflow.pcap
reading from <span class="token function">file</span> tests/tftp-heapoverflow.pcap, link-type LINUX_SLL <span class="token punctuation">(</span>Linux cooked<span class="token punctuation">)</span>
09:10:59.680304 IP <span class="token punctuation">(</span>tos 0x30, ttl <span class="token number">48</span>, <span class="token function">id</span> <span class="token number">12336</span>, offset <span class="token number">0</span>, flags <span class="token punctuation">[</span>DF<span class="token punctuation">]</span>, proto UDP <span class="token punctuation">(</span><span class="token number">17</span><span class="token punctuation">)</span>, length <span class="token number">12336</span>, bad <span class="token function">cksum</span> <span class="token number">3030</span> <span class="token punctuation">(</span>-<span class="token operator">&gt;</span>299d<span class="token punctuation">)</span><span class="token operator">!</span><span class="token punctuation">)</span>
    <span class="token number">48.48</span>.48.48.69 <span class="token operator">&gt;</span> <span class="token number">48.48</span>.48.48.12336:  <span class="token number">12308</span> RRQ <span class="token string">"00"</span> <span class="token punctuation">[</span><span class="token operator">|</span>tftp<span class="token punctuation">]</span>
</code></pre> 
<p>用afl-cmin精简一下：</p> 
<pre><code class="prism language-shell">$ <span class="token function">sudo</span> afl-cmin -i tests/ -o mintests -m none tcpdump -vv -r @@
corpus minimization tool <span class="token keyword">for</span> afl-fuzz by <span class="token operator">&lt;</span>lcamtuf@google.com<span class="token operator">&gt;</span>

<span class="token punctuation">[</span>-<span class="token punctuation">]</span> Error: binary <span class="token string">'/usr/sbin/tcpdump'</span> doesn't appear to be instrumented.
</code></pre> 
<p>报错tcpdump无法插桩，尴尬了，本想试试-Q黑盒测试来着。</p> 
<p>那就试试白盒吧，先编译libcap：</p> 
<pre><code class="prism language-shell"><span class="token assign-left variable">CC</span><span class="token operator">=</span>afl-gcc <span class="token assign-left variable">CFLAGS</span><span class="token operator">=</span><span class="token string">"-g -fsanitize=address -O1 -fno-omit-frame-pointer"</span> <span class="token assign-left variable">AFL_USE_ASAN</span><span class="token operator">=</span><span class="token number">1</span> ./configure
<span class="token function">sudo</span> <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>
</code></pre> 
<p>再编译tcpdump:</p> 
<pre><code class="prism language-shell">$ <span class="token assign-left variable">CC</span><span class="token operator">=</span>afl-gcc <span class="token assign-left variable">CFLAGS</span><span class="token operator">=</span><span class="token string">"-g -fsanitize=address -O1 -fno-omit-frame-pointer"</span> <span class="token assign-left variable">LDFLAGS</span><span class="token operator">=</span><span class="token string">"-lpcap"</span>  <span class="token assign-left variable">AFL_USE_ASAN</span><span class="token operator">=</span><span class="token number">1</span> ./configure
$ <span class="token function">sudo</span> <span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">make</span> <span class="token function">install</span>

<span class="token comment"># 添加so的搜索路径，不然找不到libpcap.so</span>
$ <span class="token function">sudo</span> <span class="token function">vim</span> /etc/ld.so.conf
$ <span class="token function">cat</span> /etc/ld.so.conf
include /etc/ld.so.conf.d/*.conf
/usr/local/lib
/usr/lib
$ <span class="token function">sudo</span> ldconfig
$ <span class="token function">sudo</span> ./tcpdump --version
tcpdump version <span class="token number">5.0</span>.0-PRE-GIT
libpcap version <span class="token number">1.11</span>.0-PRE-GIT <span class="token punctuation">(</span>with TPACKET_V3<span class="token punctuation">)</span>
OpenSSL <span class="token number">1.1</span>.1  <span class="token number">11</span> Sep <span class="token number">2018</span>
Compiled with AddressSanitizer/GCC.
</code></pre> 
<p>再次执行afl-cmin精简语料库，等了大概十分钟：</p> 
<pre><code class="prism language-shell">$ <span class="token function">sudo</span> afl-cmin -i tests/ -o mintests -m none ./tcpdump -vv -r @@
corpus minimization tool <span class="token keyword">for</span> afl-fuzz by <span class="token operator">&lt;</span>lcamtuf@google.com<span class="token operator">&gt;</span>

<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Testing the target binary<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>+<span class="token punctuation">]</span> OK, <span class="token number">1090</span> tuples recorded.
<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Obtaining traces <span class="token keyword">for</span> input files <span class="token keyword">in</span> <span class="token string">'tests/'</span><span class="token punctuation">..</span>.
    Processing <span class="token function">file</span> <span class="token number">20</span>/1313<span class="token punctuation">..</span>.
    Processing <span class="token function">file</span> <span class="token number">32</span>/1313<span class="token punctuation">..</span>.
    Processing <span class="token function">file</span> <span class="token number">1313</span>/1313<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Sorting trace sets <span class="token punctuation">(</span>this may take a <span class="token keyword">while</span><span class="token punctuation">)</span><span class="token punctuation">..</span>.
<span class="token punctuation">[</span>+<span class="token punctuation">]</span> Found <span class="token number">28291</span> unique tuples across <span class="token number">1313</span> files.
<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Finding best candidates <span class="token keyword">for</span> each tuple<span class="token punctuation">..</span>.
    Processing <span class="token function">file</span> <span class="token number">1313</span>/1313<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Sorting candidate list <span class="token punctuation">(</span>be patient<span class="token punctuation">)</span><span class="token punctuation">..</span>.
<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Processing candidates and writing output files<span class="token punctuation">..</span>.
    Processing tuple <span class="token number">28291</span>/28291<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>+<span class="token punctuation">]</span> Narrowed down to <span class="token number">442</span> files, saved <span class="token keyword">in</span> <span class="token string">'mintests'</span><span class="token builtin class-name">.</span>
$ ll tests/ <span class="token operator">|</span> <span class="token function">wc</span> -l
<span class="token number">1317</span>
$ ll fuzz_tcpdump_output/ <span class="token operator">|</span> <span class="token function">wc</span> -l
<span class="token number">445</span>
</code></pre> 
<p>开始fuzz:</p> 
<pre><code class="prism language-shell">$ <span class="token function">sudo</span> afl-fuzz -i mintests/ -o fuzz_tcpdump_output -m none ./tcpdump -vv -r @@
<span class="token punctuation">..</span>.
<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Attempting dry run with <span class="token string">'id:000008,orig:DECnet_Phone.pcap'</span><span class="token punctuation">..</span>.
    len <span class="token operator">=</span> <span class="token number">7678</span>, map size <span class="token operator">=</span> <span class="token number">1147</span>, <span class="token builtin class-name">exec</span> speed <span class="token operator">=</span> <span class="token number">3372</span> us
<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Attempting dry run with <span class="token string">'id:000009,orig:DTP.pcap'</span><span class="token punctuation">..</span>.
    len <span class="token operator">=</span> <span class="token number">934</span>, map size <span class="token operator">=</span> <span class="token number">1144</span>, <span class="token builtin class-name">exec</span> speed <span class="token operator">=</span> <span class="token number">3268</span> us
<span class="token punctuation">[</span>*<span class="token punctuation">]</span> Attempting dry run with <span class="token string">'id:000010,orig:EIGRP_adjacency.pcap'</span><span class="token punctuation">..</span>.

<span class="token punctuation">[</span>-<span class="token punctuation">]</span> The program took <span class="token function">more</span> than <span class="token number">1000</span> ms to process one of the initial <span class="token builtin class-name">test</span> cases.
    This is bad news<span class="token punctuation">;</span> raising the limit with the -t option is possible, but
    will probably <span class="token function">make</span> the fuzzing process extremely slow.

    If this <span class="token builtin class-name">test</span> <span class="token keyword">case</span> is just a fluke, the other option is to just avoid it
    altogether, and <span class="token function">find</span> one that is <span class="token function">less</span> of a CPU hog.

<span class="token punctuation">[</span>-<span class="token punctuation">]</span> PROGRAM ABORT <span class="token builtin class-name">:</span> Test <span class="token keyword">case</span> <span class="token string">'id:000010,orig:EIGRP_adjacency.pcap'</span> results <span class="token keyword">in</span> a <span class="token function">timeout</span>
         Location <span class="token builtin class-name">:</span> perform_dry_run<span class="token punctuation">(</span><span class="token punctuation">)</span>, afl-fuzz.c:2806
</code></pre> 
<p>总是会有语料爆出timeout超时错误，而mintests这个目录最好不要动它，目录本身是故意设置成非root用户不可写的。</p> 
<p>最后只用一个文件作为语料库测试了。。。</p> 
<pre><code class="prism language-shell">$ <span class="token function">cp</span> tests/reason_code-10.pcap in/
$ <span class="token function">sudo</span> afl-fuzz -i in/ -o fuzz_tcpdump_output -m none ./tcpdump -vv -r @@
</code></pre> 
<p><img src="https://images2.imgbox.com/b2/00/47cgPiSw_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="9__381"></a>9. 其它参考资料</h2> 
<p><a href="https://www.freebuf.com/articles/system/191536.html" rel="nofollow">AFL漏洞挖掘技术漫谈（一）：用AFL开始你的第一次Fuzzing - FreeBuf网络安全行业门户</a></p> 
<p><a href="https://cloud.tencent.com/developer/article/1844735" rel="nofollow">Linux终端命令神器–Screen命令详解。助力Linux使用和管理 - 云+社区 - 腾讯云 (tencent.com)</a></p> 
<p><a href="https://myfzy.top/2021/03/04/AFL/" rel="nofollow">模糊测试之AFL总结 (myfzy.top)</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ddc77aed42d03da0ff444f2818bbb696/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【第二篇】Flowable之Eclipse流程绘制</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a771b28ab2aa310e8e33329cfdff64f2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">net 6框架下的EF Core操作数据库表操作基本增删改查</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>