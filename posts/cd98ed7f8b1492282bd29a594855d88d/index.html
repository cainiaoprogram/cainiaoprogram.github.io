<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>万字详细解析Dubbo - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="万字详细解析Dubbo" />
<meta property="og:description" content="什么是Dubbo?
Dubbo是一款高性能的分布式服务框架，它由阿里巴巴开发并开源。Dubbo提供了完整的RPC通信机制，包括服务自动注册与发现、负载均衡、容错等多种功能，它可以帮助我们快速构建分布式服务体系，并满足高可用、高并发的需求。Dubbo广泛应用于各种互联网企业中，如电商、金融、物流等领域。
为什么要使用Dubbo?
使用Dubbo有以下几个优点：
高性能：Dubbo采用了多种技术手段，如网络通讯、序列化、线程模型等优化，保证了高并发场景下的性能表现。多语言支持：Dubbo实现了跨语言的RPC通信机制，支持Java、.NET、Python、Node.js等多种编程语言，便于不同团队之间的协作与整合。高可用性：Dubbo提供了多种容错机制，如重试、熔断、降级等，保证在分布式环境中服务的稳定性。易于扩展：Dubbo支持插件化扩展，可以按需自定义各种功能，例如注册中心、负载均衡、序列化方式等。可视化管理：Dubbo提供了可视化的管理平台Dubbo-Admin，方便监控和管理服务的状态和流量。 综上所述，Dubbo具备高性能、多语言支持、高可用性、易于扩展和可视化管理等特点，是构建分布式服务体系的理想选择。
使用Dubbo背景
使用Dubbo的背景可以从以下几个方面来说明：
分布式系统的兴起：随着互联网技术的快速发展，分布式系统逐渐成为构建大型互联网应用的必然选择。在分布式系统中，服务的数量和复杂度不断增加，如何有效地管理和调用这些服务成为了一个重要问题。高并发场景的需求：互联网应用常常需要应对高并发访问的情况，而传统的单体应用往往无法满足这种需求。因此，采用分布式架构可以将负载均衡和并发处理能力分散到多台服务器上，提高应用的响应能力和可扩展性。服务治理的需求：在分布式系统中，服务的注册、发现、路由、负载均衡、容错等方面都需要进行有效的管理和治理，以保证服务的稳定性和可靠性。而Dubbo正是基于这些需求而设计和开发的，它提供了完整而强大的服务治理功能，帮助用户轻松构建分布式服务体系。 综上所述，使用Dubbo反映了分布式系统和高并发场景下的实际需求，也是为了解决分布式架构中服务治理的问题。
Dubbo提供了哪3个关键功能？
Dubbo提供了以下三个关键功能：
远程调用：Dubbo支持基于Java的远程过程调用（RPC），使得不同进程或者不同机器上的服务可以像调用本地方法一样进行调用。负载均衡：Dubbo提供多种负载均衡策略，例如随机、轮询、最少活跃等。通过负载均衡，Dubbo能够实现请求分发，从而保证服务的高可用和质量。集群容错：Dubbo支持多种集群容错策略，例如失败自动切换、失败快速恢复、失败粘滞等。这些策略可以在服务出现故障时自动切换到备用节点，从而避免因单点故障而导致整个系统崩溃的情况。 Dubbo服务的关键节点有哪些?
Dubbo服务的关键节点包括以下几个：
服务提供者(Provider)：提供具体的服务实现，向注册中心注册服务地址以及提供服务。注册中心(Register)：Dubbo使用注册中心来管理和发现服务提供者。它可以是Zookeeper、Redis等第三方分布式协调框架，也可以是Dubbo自带的简易版注册中心。服务消费者(Consumer)：调用远程服务的客户端，通过注册中心获取可用的服务列表，并选择合适的服务提供者进行调用。监控中心(Monitor)：Dubbo支持将服务调用信息发送到监控中心进行统计和监控。常见的监控中心有Dubbo自带的Monitor、Elasticsearch等。 上述四个节点构成了Dubbo服务的关键组成部分，同时还有负载均衡器、集群容错等辅助组件，共同协作完成服务的调用和治理。
说一下Dubbo服务注册流程?
Dubbo服务注册流程如下：
启动服务提供者(Provider)：Dubbo服务提供者启动时，会将自己提供的服务信息发布到注册中心。注册服务：服务提供者在启动时，会将自己提供的服务信息封装成一个URL对象，并调用注册中心的API将该URL注册到注册中心上。注册中心接收到服务提供者的注册请求后，会将服务提供者的信息保存到自己的本地存储中。发现服务：服务消费者(Consumer)启动时，会向注册中心发起订阅请求，获取当前可用的服务列表。注册中心会返回符合条件的服务提供者列表给服务消费者。选择服务提供者：服务消费者根据负载均衡策略，从服务提供者列表中选择一台服务提供者进行调用。调用服务：服务消费者通过RPC调用选中的服务提供者，完成服务调用。 上述流程是Dubbo服务注册的基本流程，整个过程中涉及到服务提供者、注册中心和服务消费者三个角色的协作。
Dubbo架构的特点？
Dubbo架构的特点主要包括以下几个方面：
面向接口编程：Dubbo采用面向接口编程的方式，服务提供者将自己提供的服务封装成一个接口，服务消费者通过调用该接口来消费服务。分布式服务治理：Dubbo提供了多种分布式服务治理方案，例如负载均衡、集群容错、服务降级、路由等，以保证服务的高度可用。可扩展性：Dubbo支持插件化扩展，可以灵活地定制和扩展各个模块，满足不同应用场景下的需求。高性能：Dubbo底层采用Netty网络通信框架，并使用Hessian、Protobuf等高效序列化协议，以及多种高效的线程池和队列等技术实现高性能的RPC调用。服务治理中心：Dubbo提供了可视化的服务治理中心，可以对服务进行监控、统计和管理，方便运维人员实时掌握服务的运行情况。多语言支持：Dubbo支持Java、Python、Node.js等多种语言，以及多种序列化协议，可以实现跨语言远程调用。 Dubbo的核心配置？用途？
Dubbo的核心配置如下：
dubbo:application：服务应用配置，用于配置当前应用的名称等信息。dubbo:registry：注册中心配置，用于配置注册中心的地址和协议等信息。dubbo:protocol：远程调用协议配置，用于配置服务暴露的协议类型、端口号等信息。dubbo:service：服务提供者配置，用于配置服务接口实现类、超时时间、负载均衡等信息。dubbo:reference：服务消费者配置，用于配置服务消费方的接口类型、超时时间、重试次数等信息。dubbo:monitor：监控中心配置，用于配置监控中心的地址和协议等信息。 以上几个配置项是Dubbo框架的核心配置，也是使用Dubbo进行服务开发的必要配置。它们分别对应了Dubbo的几个关键功能，例如应用管理、服务注册与发现、远程调用协议、服务提供者和消费者等，都是构成Dubbo服务治理体系不可或缺的一部分。
配置优先级规则？
Dubbo的配置优先级规则如下：
方法级别优先：Dubbo的方法级别配置具有最高优先级，如果在dubbo:service或dubbo:reference中同时配置了方法级别和全局级别的属性，以方法级别为准。属性覆盖规则：如果同一个标签内部出现相同的属性，后面的属性会覆盖前面的属性。全局默认值：对于没有配置的属性，Dubbo会使用全局默认值进行填充。可以通过设置系统属性来修改默认值。外部化配置：Dubbo支持将配置外部化到properties、XML等文件中，如果外部化的配置项与内部配置项冲突，则以外部化的配置为准。Java系统属性：Dubbo还支持将配置写入Java系统属性，如果系统属性中存在相应的配置项，则以系统属性中的配置为准。 总体来说，方法级别优先，属性覆盖规则次之，全局默认值再次之，外部化配置和Java系统属性优先级较低。在实际开发中，需要根据具体情况选择合适的配置方式，并注意配置的优先级规则。
如何用代码方式绕过注册中心点对点直连？
在Dubbo中，可以使用点对点直连方式来进行服务调用，绕过注册中心。如果要在代码中实现绕过注册中心点对点直连，需要按照以下步骤进行：
获取服务引用：在代码中获取服务引用时，不再使用Dubbo的注解或XML配置，而是通过代码创建服务引用对象。 ServiceConfig&lt;HelloService&gt; service = new ServiceConfig&lt;HelloService&gt;(); service.setInterface(HelloService.class); service.setRef(new HelloServiceImpl()); 复制代码 设置URL：在创建服务引用对象后，需要设置URL对象，包括协议、IP地址、端口号等信息。 URL url = new URL(&#34;dubbo&#34;, &#34;localhost&#34;, 20880); service.setUrl(url); 复制代码 暴露服务：在设置完URL后，需要将服务暴露出去，使得其他服务消费者能够调用该服务。 service.export(); 复制代码 调用服务：在其他服务消费者中进行服务调用时，也需要通过代码指定直连的服务地址和端口号。 ReferenceConfig&lt;HelloService&gt; reference = new ReferenceConfig&lt;HelloService&gt;(); reference.setInterface(HelloService.class); reference.setUrl(&#34;dubbo://localhost:20880&#34;); HelloService helloService = reference.get(); String result = helloService." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/cd98ed7f8b1492282bd29a594855d88d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-10T13:11:54+08:00" />
<meta property="article:modified_time" content="2023-05-10T13:11:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">万字详细解析Dubbo</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>什么是Dubbo?</p> 
<p>Dubbo是一款高性能的分布式服务框架，它由阿里巴巴开发并开源。Dubbo提供了完整的RPC通信机制，包括服务自动注册与发现、负载均衡、容错等多种功能，它可以帮助我们快速构建分布式服务体系，并满足高可用、高并发的需求。Dubbo广泛应用于各种互联网企业中，如电商、金融、物流等领域。</p> 
<p>为什么要使用Dubbo?</p> 
<p>使用Dubbo有以下几个优点：</p> 
<ol><li>高性能：Dubbo采用了多种技术手段，如网络通讯、序列化、线程模型等优化，保证了高并发场景下的性能表现。</li><li>多语言支持：Dubbo实现了跨语言的RPC通信机制，支持Java、.NET、Python、Node.js等多种编程语言，便于不同团队之间的协作与整合。</li><li>高可用性：Dubbo提供了多种容错机制，如重试、熔断、降级等，保证在分布式环境中服务的稳定性。</li><li>易于扩展：Dubbo支持插件化扩展，可以按需自定义各种功能，例如注册中心、负载均衡、序列化方式等。</li><li>可视化管理：Dubbo提供了可视化的管理平台Dubbo-Admin，方便监控和管理服务的状态和流量。</li></ol> 
<p>综上所述，Dubbo具备高性能、多语言支持、高可用性、易于扩展和可视化管理等特点，是构建分布式服务体系的理想选择。</p> 
<p>使用Dubbo背景</p> 
<p>使用Dubbo的背景可以从以下几个方面来说明：</p> 
<ol><li>分布式系统的兴起：随着互联网技术的快速发展，分布式系统逐渐成为构建大型互联网应用的必然选择。在分布式系统中，服务的数量和复杂度不断增加，如何有效地管理和调用这些服务成为了一个重要问题。</li><li>高并发场景的需求：互联网应用常常需要应对高并发访问的情况，而传统的单体应用往往无法满足这种需求。因此，采用分布式架构可以将负载均衡和并发处理能力分散到多台服务器上，提高应用的响应能力和可扩展性。</li><li>服务治理的需求：在分布式系统中，服务的注册、发现、路由、负载均衡、容错等方面都需要进行有效的管理和治理，以保证服务的稳定性和可靠性。而Dubbo正是基于这些需求而设计和开发的，它提供了完整而强大的服务治理功能，帮助用户轻松构建分布式服务体系。</li></ol> 
<p>综上所述，使用Dubbo反映了分布式系统和高并发场景下的实际需求，也是为了解决分布式架构中服务治理的问题。</p> 
<p>Dubbo提供了哪3个关键功能？</p> 
<p>Dubbo提供了以下三个关键功能：</p> 
<ol><li>远程调用：Dubbo支持基于Java的远程过程调用（RPC），使得不同进程或者不同机器上的服务可以像调用本地方法一样进行调用。</li><li>负载均衡：Dubbo提供多种负载均衡策略，例如随机、轮询、最少活跃等。通过负载均衡，Dubbo能够实现请求分发，从而保证服务的高可用和质量。</li><li>集群容错：Dubbo支持多种集群容错策略，例如失败自动切换、失败快速恢复、失败粘滞等。这些策略可以在服务出现故障时自动切换到备用节点，从而避免因单点故障而导致整个系统崩溃的情况。</li></ol> 
<p>Dubbo服务的关键节点有哪些?</p> 
<p>Dubbo服务的关键节点包括以下几个：</p> 
<ol><li>服务提供者(Provider)：提供具体的服务实现，向注册中心注册服务地址以及提供服务。</li><li>注册中心(Register)：Dubbo使用注册中心来管理和发现服务提供者。它可以是Zookeeper、Redis等第三方分布式协调框架，也可以是Dubbo自带的简易版注册中心。</li><li>服务消费者(Consumer)：调用远程服务的客户端，通过注册中心获取可用的服务列表，并选择合适的服务提供者进行调用。</li><li>监控中心(Monitor)：Dubbo支持将服务调用信息发送到监控中心进行统计和监控。常见的监控中心有Dubbo自带的Monitor、Elasticsearch等。</li></ol> 
<p>上述四个节点构成了Dubbo服务的关键组成部分，同时还有负载均衡器、集群容错等辅助组件，共同协作完成服务的调用和治理。</p> 
<p>说一下Dubbo服务注册流程?</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3f/80/Afb7X0U4_o.png"></p> 
<p>Dubbo服务注册流程如下：</p> 
<ol><li>启动服务提供者(Provider)：Dubbo服务提供者启动时，会将自己提供的服务信息发布到注册中心。</li><li>注册服务：服务提供者在启动时，会将自己提供的服务信息封装成一个URL对象，并调用注册中心的API将该URL注册到注册中心上。注册中心接收到服务提供者的注册请求后，会将服务提供者的信息保存到自己的本地存储中。</li><li>发现服务：服务消费者(Consumer)启动时，会向注册中心发起订阅请求，获取当前可用的服务列表。注册中心会返回符合条件的服务提供者列表给服务消费者。</li><li>选择服务提供者：服务消费者根据负载均衡策略，从服务提供者列表中选择一台服务提供者进行调用。</li><li>调用服务：服务消费者通过RPC调用选中的服务提供者，完成服务调用。</li></ol> 
<p>上述流程是Dubbo服务注册的基本流程，整个过程中涉及到服务提供者、注册中心和服务消费者三个角色的协作。</p> 
<p>Dubbo架构的特点？</p> 
<p>Dubbo架构的特点主要包括以下几个方面：</p> 
<ol><li>面向接口编程：Dubbo采用面向接口编程的方式，服务提供者将自己提供的服务封装成一个接口，服务消费者通过调用该接口来消费服务。</li><li>分布式服务治理：Dubbo提供了多种分布式服务治理方案，例如负载均衡、集群容错、服务降级、路由等，以保证服务的高度可用。</li><li>可扩展性：Dubbo支持插件化扩展，可以灵活地定制和扩展各个模块，满足不同应用场景下的需求。</li><li>高性能：Dubbo底层采用Netty网络通信框架，并使用Hessian、Protobuf等高效序列化协议，以及多种高效的线程池和队列等技术实现高性能的RPC调用。</li><li>服务治理中心：Dubbo提供了可视化的服务治理中心，可以对服务进行监控、统计和管理，方便运维人员实时掌握服务的运行情况。</li><li>多语言支持：Dubbo支持Java、Python、Node.js等多种语言，以及多种序列化协议，可以实现跨语言远程调用。</li></ol> 
<p>Dubbo的核心配置？用途？</p> 
<p>Dubbo的核心配置如下：</p> 
<ol><li><a href="https://link.juejin.cn?target=" rel="nofollow" title="dubbo:application">dubbo:application</a>：服务应用配置，用于配置当前应用的名称等信息。</li><li><a href="https://link.juejin.cn?target=" rel="nofollow" title="dubbo:registry">dubbo:registry</a>：注册中心配置，用于配置注册中心的地址和协议等信息。</li><li><a href="https://link.juejin.cn?target=" rel="nofollow" title="dubbo:protocol">dubbo:protocol</a>：远程调用协议配置，用于配置服务暴露的协议类型、端口号等信息。</li><li><a href="https://link.juejin.cn?target=" rel="nofollow" title="dubbo:service">dubbo:service</a>：服务提供者配置，用于配置服务接口实现类、超时时间、负载均衡等信息。</li><li><a href="https://link.juejin.cn?target=" rel="nofollow" title="dubbo:reference">dubbo:reference</a>：服务消费者配置，用于配置服务消费方的接口类型、超时时间、重试次数等信息。</li><li><a href="https://link.juejin.cn?target=" rel="nofollow" title="dubbo:monitor">dubbo:monitor</a>：监控中心配置，用于配置监控中心的地址和协议等信息。</li></ol> 
<p>以上几个配置项是Dubbo框架的核心配置，也是使用Dubbo进行服务开发的必要配置。它们分别对应了Dubbo的几个关键功能，例如应用管理、服务注册与发现、远程调用协议、服务提供者和消费者等，都是构成Dubbo服务治理体系不可或缺的一部分。</p> 
<p>配置优先级规则？</p> 
<p>Dubbo的配置优先级规则如下：</p> 
<ol><li>方法级别优先：Dubbo的方法级别配置具有最高优先级，如果在<a href="https://link.juejin.cn?target=" rel="nofollow" title="dubbo:service">dubbo:service</a>或<a href="https://link.juejin.cn?target=" rel="nofollow" title="dubbo:reference">dubbo:reference</a>中同时配置了方法级别和全局级别的属性，以方法级别为准。</li><li>属性覆盖规则：如果同一个标签内部出现相同的属性，后面的属性会覆盖前面的属性。</li><li>全局默认值：对于没有配置的属性，Dubbo会使用全局默认值进行填充。可以通过设置系统属性来修改默认值。</li><li>外部化配置：Dubbo支持将配置外部化到properties、XML等文件中，如果外部化的配置项与内部配置项冲突，则以外部化的配置为准。</li><li>Java系统属性：Dubbo还支持将配置写入Java系统属性，如果系统属性中存在相应的配置项，则以系统属性中的配置为准。</li></ol> 
<p>总体来说，方法级别优先，属性覆盖规则次之，全局默认值再次之，外部化配置和Java系统属性优先级较低。在实际开发中，需要根据具体情况选择合适的配置方式，并注意配置的优先级规则。</p> 
<p>如何用代码方式绕过注册中心点对点直连？</p> 
<p>在Dubbo中，可以使用点对点直连方式来进行服务调用，绕过注册中心。如果要在代码中实现绕过注册中心点对点直连，需要按照以下步骤进行：</p> 
<ol><li>获取服务引用：在代码中获取服务引用时，不再使用Dubbo的注解或XML配置，而是通过代码创建服务引用对象。</li></ol> 
<pre><code>ServiceConfig&lt;HelloService&gt; service = new ServiceConfig&lt;HelloService&gt;();
service.setInterface(HelloService.class);
service.setRef(new HelloServiceImpl());
复制代码</code></pre> 
<ol><li>设置URL：在创建服务引用对象后，需要设置URL对象，包括协议、IP地址、端口号等信息。</li></ol> 
<pre><code>URL url = new URL("dubbo", "localhost", 20880);
service.setUrl(url);
复制代码</code></pre> 
<ol><li>暴露服务：在设置完URL后，需要将服务暴露出去，使得其他服务消费者能够调用该服务。</li></ol> 
<pre><code>service.export();
复制代码</code></pre> 
<ol><li>调用服务：在其他服务消费者中进行服务调用时，也需要通过代码指定直连的服务地址和端口号。</li></ol> 
<pre><code>ReferenceConfig&lt;HelloService&gt; reference = new ReferenceConfig&lt;HelloService&gt;();
reference.setInterface(HelloService.class);
reference.setUrl("dubbo://localhost:20880");
HelloService helloService = reference.get();
String result = helloService.sayHello("Dubbo");
复制代码</code></pre> 
<p>以上就是在代码中绕过注册中心进行点对点直连的步骤，需要注意的是，这种方式适用于测试和开发阶段，不建议在生产环境中使用，因为无法实现服务的动态发现和负载均衡等功能。</p> 
<p>Dubbo配置来源有几种？分别是？</p> 
<p>Dubbo的配置来源主要有以下几种：</p> 
<ol><li>XML配置文件：Dubbo使用XML配置文件来进行服务治理，所有的配置信息都可以通过XML文件进行配置。Dubbo支持多个不同的XML配置文件，例如dubbo.xml、spring.xml等。</li><li>注解方式：Dubbo提供了一些注解，例如@DubboService和@DubboReference，可以用于在Java代码中指定Dubbo的相关配置信息。这种方式相对于XML配置更加简单方便，适合快速搭建Demo或者小型项目。</li><li>Java系统属性：Dubbo还支持将配置写入Java系统属性中，可以通过System.setProperty()方法来设置，也可以通过命令行参数或JVM启动参数配置。</li><li>外部化配置：Dubbo支持将配置外部化到properties、XML等文件中，可以通过Spring的PropertyPlaceholderConfigurer等机制来加载外部配置文件，从而实现灵活的配置管理。</li></ol> 
<p>以上四种方式是Dubbo常见的配置来源，可以根据具体需求和应用场景选择合适的方式进行配置。</p> 
<p>如何禁用某个服务的启动检查？</p> 
<p>在Dubbo中，可以通过配置来禁用某个服务的启动检查。如果某个服务在启动过程中因为依赖的资源还未准备好而无法正常启动，Dubbo会自动关闭该服务，以避免对系统造成不良影响。但有时候我们希望暂时禁用服务的启动检查，可以按照以下步骤进行：</p> 
<ol><li>在服务提供者(Provider)端的XML配置中，增加<code>check=false</code>的属性：</li></ol> 
<pre><code>&lt;dubbo:service interface="com.xxx.XxxService" ref="xxxService" check="false"/&gt;
复制代码</code></pre> 
<ol><li>在服务消费者(Consumer)端的XML配置中，增加<code>check=false</code>的属性：</li></ol> 
<pre><code>&lt;dubbo:reference interface="com.xxx.XxxService" check="false" /&gt;
复制代码</code></pre> 
<p>在以上两种情况下，都将会禁用启动检查。需要注意的是，在实际生产环境中，不建议长期禁用服务启动检查，应尽快解决服务的依赖问题，并重新开启启动检查。</p> 
<p>Dubbo 负载均衡策略？默认是？</p> 
<p>Dubbo提供了多种负载均衡策略，默认是随机(Random)负载均衡策略，具体的负载均衡策略包括：</p> 
<ol><li>随机(RANDOM)：随机选择一台可用的服务提供者进行调用。</li><li>轮询(ROUND_ROBIN)：轮流选择可用的服务提供者进行调用，按照顺序依次选择。</li><li>最少活跃数(MIN_ACTIVE)：选择当前负载最小的服务提供者进行调用，即已发起调用数最少的服务提供者。</li><li>一致性哈希(CONSISTENT_HASH)：根据客户端IP地址和服务提供者地址计算哈希值，找到该哈希值在环上最近的服务提供者节点，进行调用。</li><li>加权轮询(ROUND_ROBIN_WEIGHT)：按照服务提供者的权重值进行轮询，权重值越高的服务提供者被选择的概率越大。</li><li>加权随机(RANDOM_WEIGHT)：按照服务提供者的权重值进行随机，权重值越高的服务提供者被选择的概率越大。</li><li>可用性优先(AVAILABLE_FIRST)：优先选择可用性高的服务提供者进行调用。</li><li>哈希(HASH)：根据方法参数的哈希值来选择服务提供者进行调用。</li></ol> 
<p>以上是Dubbo支持的几种负载均衡策略，开发者可以根据实际需求选择合适的策略。默认情况下，Dubbo使用的是随机(RANDOM)负载均衡策略。</p> 
<p>开发测试环境，想绕过注册中心如何配置？</p> 
<p>在Dubbo中，可以通过点对点直连的方式绕过注册中心进行服务调用。如果在开发测试环境中需要绕过注册中心，可以按照以下步骤进行配置：</p> 
<ol><li>服务提供者(Provider)端配置：在服务提供者的XML配置文件中，可以设置URL属性，指定服务的直连地址和端口号。例如：</li></ol> 
<pre><code>&lt;dubbo:protocol name="dubbo" port="20880"/&gt;
&lt;dubbo:service interface="com.xxx.XxxService" ref="xxxService"&gt;
    &lt;dubbo:export protocol="dubbo" url="dubbo://localhost:20880"/&gt;
&lt;/dubbo:service&gt;
复制代码</code></pre> 
<ol><li>服务消费者(Consumer)端配置：在服务消费者的XML配置文件中，可以设置URL属性，指定要消费的服务的直连地址和端口号。例如：</li></ol> 
<pre><code>&lt;dubbo:reference interface="com.xxx.XxxService"
                 url="dubbo://localhost:20880"
                 check="false"/&gt;
复制代码</code></pre> 
<p>通过以上配置，就可以实现在开发测试环境中绕过注册中心进行服务调用。需要注意的是，这种方式只适合于开发测试环境中使用，不建议在生产环境中使用，因为无法实现服务的动态发现和负载均衡等功能。</p> 
<p>集群容错几种方法？</p> 
<p>Dubbo提供了多种集群容错方法，用于提高服务的稳定性和可靠性，具体的集群容错方法包括以下几种：</p> 
<ol><li>Failover Cluster：失败自动切换，默认方式。调用失败自动切换到其他节点上进行重试，通常用于实现高可用性。</li><li>Failfast Cluster：快速失败。只发起一次调用，失败立即抛出异常，通常用于非幂等性操作。</li><li>Failsafe Cluster：失败安全。调用失败时，直接忽略失败，并记录下失败日志，通常用于写入日志、监控等操作。</li><li>Failback Cluster：失败自动恢复。调用失败后，记录下失败日志，在后台定时任务中进行重试，通常用于对业务数据的最终一致性要求较高的场景。</li><li>Forking Cluster：并行调用多个服务提供者。同时调用多个服务提供者，只要有一个成功返回结果即可，通常用于提高服务的响应速度和可用性。</li><li>Broadcast Cluster：广播调用所有服务提供者。将请求广播给所有的服务提供者，通常用于通知推送等场景。</li></ol> 
<p>以上就是Dubbo提供的几种集群容错方法，开发者可以根据实际需求选择合适的容错策略。需要注意的是，在使用集群容错机制时，应结合实际业务场景进行设置，选择合适的容错策略和参数值来保证服务的稳定性和可靠性。</p> 
<p>Dubbo有几种配置方式？</p> 
<p>Dubbo提供了多种配置方式，可以根据实际需求和应用场景选择合适的配置方式。常见的Dubbo配置方式包括以下几种：</p> 
<ol><li>XML配置：Dubbo使用XML配置文件来进行服务治理，所有的配置信息都可以通过XML文件进行配置。Dubbo支持多个不同的XML配置文件，例如dubbo.xml、spring.xml等。</li><li>注解配置：Dubbo提供了一些注解，例如@DubboService和@DubboReference，可以用于在Java代码中指定Dubbo的相关配置信息，这种方式相对于XML配置更加简单方便，适合快速搭建Demo或者小型项目。</li><li>Java系统属性：Dubbo还支持将配置写入Java系统属性中，可以通过System.setProperty()方法来设置，也可以通过命令行参数或JVM启动参数配置。</li><li>外部化配置：Dubbo支持将配置外部化到properties、XML等文件中，可以通过Spring的PropertyPlaceholderConfigurer等机制来加载外部配置文件，从而实现灵活的配置管理。</li><li>API配置：Dubbo提供了丰富的API接口，可以通过调用API接口来进行配置，例如ServiceConfig、ReferenceConfig等类。</li></ol> 
<p>以上就是Dubbo常见的配置方式，开发者可以根据实际需求和技术选型进行选择。需要注意的是，在使用Dubbo进行配置时，应遵循良好的规范和原则，以保证配置的合理性和可维护性。</p> 
<p>Dubbo有哪些协议？推荐？</p> 
<p>在Dubbo中，提供了多种协议用于服务之间的通信，常见的Dubbo协议包括以下几种：</p> 
<ol><li>Dubbo协议：基于TCP长连接和Java序列化实现的高性能、高可靠性的协议。默认使用的就是Dubbo协议。</li><li>REST协议：基于HTTP协议和REST风格的API调用协议，支持XML和JSON等多种数据格式。适合与非Java语言的系统进行交互。</li><li>Hessian协议：基于二进制协议和RPC框架的协议，支持多种编程语言，并具有较好的跨语言能力。</li><li>Thrift协议：由Facebook开发的跨语言的高效服务框架，支持多种编程语言，并具有很好的扩展性和灵活性。</li><li>RMI协议：基于Java标准的远程方法调用协议，使用JRMP协议进行底层传输，具有很好的集成性和兼容性，但不支持跨语言。</li></ol> 
<p>推荐使用Dubbo协议，因为Dubbo协议是Dubbo框架自带的协议，能够带来更好的性能和稳定性。同时，在不同场景下选择合适的协议也是非常重要的，应根据实际项目需求和网络环境选择适合的通信协议。</p> 
<p>Dubbo使用什么通信框架?</p> 
<p>Dubbo使用Netty作为默认的通信框架。Netty是一个高性能、异步事件驱动的网络应用程序框架，基于NIO实现，适用于高并发、高吞吐量的网络应用场景。Dubbo使用Netty作为底层通信框架，能够带来更快的响应速度和更好的可靠性，同时还支持多种序列化方式，例如Hessian、Java原生序列化等，使得Dubbo在跨语言、跨平台的服务调用中也具有很好的扩展性和兼容性。</p> 
<p>除了Netty，Dubbo还支持其他通信框架的扩展，例如MINA、Grizzly等，可以根据具体需求选择合适的通信框架。但默认情况下，建议使用Netty作为通信框架，以获得更好的性能和稳定性。</p> 
<p>dubbo协议默认端口号？http协议默认端口？hessian?rmi?</p> 
<p>在Dubbo中，不同的协议有不同的默认端口号。常见Dubbo协议和其默认端口号如下：</p> 
<ol><li>Dubbo协议：默认使用20880端口。</li><li>REST协议：默认使用80端口。</li><li>Hessian协议：默认使用80端口。</li><li>Thrift协议：默认使用9090端口。</li><li>RMI协议：默认使用1099端口。</li></ol> 
<p>需要注意的是，这些都是Dubbo框架协议的默认端口号，可以通过在XML配置文件中修改相应端口来进行定制。例如：</p> 
<pre><code>&lt;!-- 修改Dubbo协议的默认端口号为8888 --&gt;
&lt;dubbo:protocol name="dubbo" port="8888"/&gt;
复制代码</code></pre> 
<p>对于HTTP协议，默认的端口号是80，Hessian协议也默认使用80端口。而RMI协议默认使用1099端口，但通常建议使用非默认端口号以提高安全性。需要注意的是，在使用网络通信时，除了端口号，还要考虑安全性、可用性等因素来进行配置和设计。</p> 
<p>Dubbo默认序列化框架?其他的你还知道？</p> 
<p>Dubbo默认使用的序列化框架是Hessian2，它是一种基于二进制协议的序列化框架，具有快速、高效、跨语言等特点。除了Hessian2，Dubbo还支持多种其他序列化框架，包括：</p> 
<ol><li>Java原生序列化：Java自带的序列化机制，可以序列化任何实现了Serializable接口的Java对象，但其序列化过程较慢，而且不支持跨语言。</li><li>JSON序列化：支持将Java对象序列化成JSON格式，具有很好的可读性和兼容性，但相比二进制序列化会存在一定的性能损失。</li><li>FST序列化：一种高性能的Java序列化框架，相比Java原生序列化在序列化和反序列化过程中都表现更优秀。</li><li>Kryo序列化：一个高性能的Java序列化框架，适合用于对性能要求较高的场景，但对类型的支持不如Hessian2那么全面。</li><li>Protobuf序列化：Google开发的一种高效的序列化协议，通常用于跨平台和跨语言的数据交换。</li></ol> 
<p>需要注意的是，每种序列化框架都有其适用的场景和优缺点，开发者在选择序列化框架时应根据实际需求和具体情况进行选择。</p> 
<p>一个服务有多重实现时，如何处理？</p> 
<p>在Dubbo中，一个服务有多重实现时，可以通过以下两种方式进行处理：</p> 
<ol><li>使用group和version：Dubbo支持对同一接口的不同实现使用group和version进行区分。在服务提供者端，可以通过配置不同的group和version来注册不同的服务实现，而在服务消费者端，可以通过指定相应的group和version来选择特定的服务实现。这种方式适用于同一接口的不同实现之间差异较大的场景。</li><li>使用URL参数：Dubbo还支持直接在URL中指定具体的实现类名来进行服务调用。在服务消费者端，可以通过设置URL中的"interface"参数和"retries"参数来指定要调用的服务实现类。这种方式适用于同一接口的不同实现之间差异较小的场景。</li></ol> 
<p>需要注意的是，无论采用哪种方式，都需要保证服务提供者和服务消费者之间的协议、接口、序列化等配置信息是一致的，否则会出现服务调用失败的情况。同时，在设计和开发阶段，也需要考虑多实现的问题，从接口定义和实现的角度进行合理划分和设计，以便更好地适应后续的需求变化。</p> 
<p>Dubbo服务调用默认是阻塞的？还有其他的？</p> 
<p>Dubbo服务调用默认是阻塞的，即客户端发送请求后会一直等待服务器返回结果后才能继续执行。这种调用方式适合于对响应时间要求较高的场景，但如果调用过程中出现了网络故障或者服务提供方宕机等情况，整个调用过程会被一直阻塞，影响系统的可用性和性能。</p> 
<p>除了阻塞调用外，Dubbo还支持异步调用、单向调用、Future调用等多种调用方式，具体如下：</p> 
<ol><li>异步调用：客户端发送请求后不会等待服务端的响应，而是立即返回一个Future对象，通过Future可以获取到调用结果。这种调用方式适合对响应时间要求较高，但同时也需要考虑结果处理的线程安全性和并发控制。</li><li>单向调用：客户端发送请求后不会等待服务端的响应，因此也不会返回任何结果。这种调用方式适合于通知类的调用，例如日志记录、事件订阅等场景。</li><li>Future调用：在发送请求时，Dubbo会返回一个Future对象，用于接收服务端的响应结果。客户端在调用时可以设置超时时间，并可以在指定时间内判断Future是否已经完成，并通过Future获取调用结果。</li></ol> 
<p>需要注意的是，无论采用哪种调用方式，都需要根据实际场景进行选择和配置，并考虑并发控制、线程安全性等问题。同时，在使用异步调用、Future调用等方式时，也需要注意结果处理的正确性和异常处理的规范性。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ca65b67932ca75b556300758cb6b339a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">SpringBoot 如何结合 Liquibase 实现数据库的变更管理?</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0634d87cfb00651948f440ee350b24ad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">搭建angularjs开发环境</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>