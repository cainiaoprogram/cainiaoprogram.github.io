<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>计算机网络_02_应用层(个人总结) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="计算机网络_02_应用层(个人总结)" />
<meta property="og:description" content="声明: 1. 本文为我的个人复习总结, 并非那种从零基础开始普及知识 内容详细全面, 言辞官方的文章
2. 由于是个人总结, 所以用最精简的话语来写文章
3. 若有错误不当之处, 请指出
基础 HTTP是什么? HTTP 是超文本传输协议, ⼀个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」
URI, URL, URN URI 指的是一个资源，URL 指的是用地址定位一个资源，URN 指的是用名称定位一个资源
HTTP状态码: 301: 永久重定向
**302: ** 临时重定向
304: 资源未修改
400: 客户端请求的报文有错, 笼统的客户端错误
403: 禁止访问此资源
404: 请求的资源寻找不到
500: 服务端出错, 笼统的服务端错误
502: 网关服务器自身正常, 后端服务器出错
503: 服务端忙碌
请求头字段: **Host: ** 指定服务器的域名, 有了 Host 字段，就可以将请求发往「同一台」服务器上的不同网站
Content-Length: 本次响应的数据长度
Connection: 长连接
Content-Type: 数据格式
Content-Encoding: 压缩方式
请求报文格式: 请求行（请求方法&#43;URI协议&#43;版本）请求头空行请求体 示例:
GET/sample.jspHTTP/1.1 请求行 Accept:image/gif.image/jpeg, 请求头部 Accept-Language:zh-cn Connection:Keep-Alive Host:localhost User-Agent:Mozila/4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fad99dd116773b30493137cc17b8b7d6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-25T15:46:19+08:00" />
<meta property="article:modified_time" content="2022-04-25T15:46:19+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">计算机网络_02_应用层(个人总结)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>    <strong>声明:</strong> 1. 本文为我的个人复习总结, 并<strong>非</strong>那种从零基础开始普及知识 <strong>内容详细全面</strong>, <strong>言辞官方</strong>的文章<br>               2. 由于是个人总结, 所以用最精简的话语来写文章<br>               3. 若有错误不当之处, 请指出</p> 
<h3><a id="_3"></a>基础</h3> 
<h4><a id="HTTP_5"></a>HTTP是什么?</h4> 
<p>HTTP 是超文本传输协议, ⼀个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」</p> 
<h4><a id="URI_URL_URN_9"></a>URI, URL, URN</h4> 
<p>URI 指的是一个资源，URL 指的是用地址定位一个资源，URN 指的是用名称定位一个资源</p> 
<h4><a id="HTTP_13"></a>HTTP状态码:</h4> 
<p><img src="https://images2.imgbox.com/90/c4/gSmif65M_o.png" alt="在这里插入图片描述"></p> 
<p><strong>301:</strong> 永久重定向</p> 
<p>**302: ** 临时重定向</p> 
<p><strong>304:</strong> 资源未修改</p> 
<p><strong>400:</strong> 客户端请求的报文有错, 笼统的客户端错误</p> 
<p><strong>403:</strong> 禁止访问此资源</p> 
<p><strong>404:</strong> 请求的资源寻找不到</p> 
<p><strong>500:</strong> 服务端出错, 笼统的服务端错误</p> 
<p><strong>502:</strong> 网关服务器自身正常, 后端服务器出错</p> 
<p><strong>503:</strong> 服务端忙碌</p> 
<h4><a id="_40"></a>请求头字段:</h4> 
<p>**Host: ** 指定服务器的域名, 有了 Host 字段，就可以将请求发往「同一台」服务器上的不同网站</p> 
<p><strong>Content-Length:</strong> 本次响应的数据长度</p> 
<p><strong>Connection:</strong> 长连接</p> 
<p><strong>Content-Type:</strong> 数据格式</p> 
<p><strong>Content-Encoding:</strong> 压缩方式</p> 
<h4><a id="_52"></a>请求报文格式:</h4> 
<ol><li>请求行（请求方法+URI协议+版本）</li><li>请求头</li><li>空行</li><li>请求体</li></ol> 
<p><strong>示例:</strong></p> 
<pre><code>GET/sample.jspHTTP/1.1 请求行
Accept:image/gif.image/jpeg, 请求头部
Accept-Language:zh-cn
Connection:Keep-Alive
Host:localhost
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
Accept-Encoding:gzip,deflate

username=jinqiao&amp;password=1234 请求主体
</code></pre> 
<h4><a id="_73"></a>响应报文格式:</h4> 
<ol><li>响应行（版本+状态码+原因短语）</li><li>响应头</li><li>空行</li><li>响应体</li></ol> 
<p><strong>示例:</strong></p> 
<pre><code>HTTP/1.1 200 OK
Server:Apache Tomcat/5.0.12
Date:Mon,6Oct2003 13:23:42 GMT
Content-Length:112

&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;HTTP响应示例&lt;title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        Hello HTTP!
    &lt;/body&gt;
&lt;/html&gt;
</code></pre> 
<h4><a id="_98"></a>请求方法:</h4> 
<p><img src="https://images2.imgbox.com/b2/92/UPdD8Hsl_o.png" alt="在这里插入图片描述"></p> 
<p>Get: 幂等 &amp; 安全</p> 
<p>POST: 不幂等 &amp; 不安全</p> 
<p>PUT: 幂等 &amp; 不安全</p> 
<p>DELETE: 幂等 &amp; 不安全</p> 
<h4><a id="_111"></a>幂等:</h4> 
<p>幂等是指不管进行多少次操作，结果都一样</p> 
<h4><a id="_115"></a>安全:</h4> 
<p>发送请求不会改变服务端的状态</p> 
<h4><a id="Get__Post_119"></a>Get &amp; Post:</h4> 
<ol><li> <p>幂等安全方面:</p> <p>Get 幂等, 不会修改服务端数据(安全)</p> <p>Post 非幂等, 会修改服务端数据(不安全)</p> </li><li> <p>浏览器地址栏</p> <p>Get 使用 URL 传参, 会将携带的数据(如用户名密码)展现出来</p> <p>Post 使用 Body 传参, 不会将携带的数据展现出来</p> </li><li> <p>携带数据长度大小</p> <p>GET 携带的数据长度较小, POST 携带的数据长度较大</p> </li></ol> 
<h4><a id="Cookie__Session__137"></a>Cookie 和 Session 是如何配合的呢？</h4> 
<p>第一次请求服务器的时候，创建对应的 Session, Cookie 记录此 SessionID</p> 
<p>第二次访问服务器的时候，服务端会从 Cookie 中获取 SessionID 查找其对应的 Session 信息</p> 
<ul><li>如果找得到, 则维护原本的会话</li><li>如果找不到, 则创建新的会话返回SessionID</li></ul> 
<h4><a id="CookieSession_146"></a>Cookie和Session的区别？</h4> 
<ol><li> <p>作用范围:</p> <p>Cookie 保存在客户端; Session 保存在服务端</p> </li><li> <p>有效期:</p> <p>Cookie 可设置为长时间保持; Session 一般失效时间较短默认为30min</p> </li><li> <p>隐私策略:</p> <p>Cookie 存储在客户端 安全性不高；Session 存储在服务端 安全性高</p> </li><li> <p>存储大小:</p> <p>单个 Cookie 保存的数据不能超过 4K，Session 可存储数据要高于 Cookie</p> </li><li> <p>所支持的数据类型:</p> <p>Cookie 只能保存 ASCII; Session 可以存任意数据类型</p> </li></ol> 
<h4><a id="DNS_168"></a>DNS:</h4> 
<p>主机向<code>本地域名服务器</code>的查询是递归查询(热心肠)，本地域名服务器向<code>根域名</code>的查询是迭代查询, 根域名服务器向<code>顶级域名</code>的查询是迭代查询</p> 
<p><strong>流程:</strong></p> 
<p>浏览器DNS缓存 -&gt; 操作系统DNS缓存-&gt; 本地的hosts文件 -&gt; 本地服务器(热心肠)</p> 
<p>-&gt; 根域名服务器 -&gt; 顶级域名服务器 -&gt; 权限域名服务器 -&gt; 本地服务器响应给主机 所查到的ip地址</p> 
<h4><a id="wwwbaiducom_178"></a>浏览器地址栏键入www.baidu.com后的执行流程:</h4> 
<ol><li> <p>域名解析</p> <p>并缓存新的ip域名映射</p> </li><li> <p>TCP三次握手</p> </li><li> <p>建立 TCP 连接后发起 Http 请求</p> </li><li> <p>ARP的 ip转MAC</p> </li><li> <p>服务器响应 http 请求, 返回给客户端http代码</p> </li><li> <p>浏览器解析 html 代码，并请求 html 中的资源, 并对页面进行渲染</p> </li></ol> 
<h3><a id="HTTPS_194"></a>HTTPS</h3> 
<h4><a id="__196"></a>公钥/私钥 那个用来加密/解密?</h4> 
<blockquote> 
 <p>加密数据: 那肯定是不希望别人知道我的消息, 所以只有我才能解密; 所以<strong>公钥负责加密，私钥负责解密</strong></p> 
 <p>签名: 那肯定是不希望有人冒充我发消息, 只有我才能发布这个签名; 所以<strong>私钥负责签名，公钥负责验证</strong></p> 
</blockquote> 
<h4><a id="__202"></a>加密、摘要、签名、证书 都是什么?</h4> 
<blockquote> 
 <p><code>摘要算法</code>/ 签名算法: 一种生成<code>哈希值</code>的算法, 防止数据被<code>篡改</code><br> <code>签名</code>: 是使用私钥 对 hash值 进行<code>加密</code>后的结果, 防<code>窃听</code><br> <code>数字证书</code>: 由CA机构颁发, 防<code>冒充</code></p> 
</blockquote> 
<h4><a id="HTTPS__HTTP__208"></a>HTTPS 与 HTTP 的区别？</h4> 
<blockquote> 
 <ol><li>HTTP默认端口是80，HTTPS默认端口是443</li><li>HTTP运行在TCP协议之上；HTTPS运行在SSL协议之上，SSL运行在TCP协议之上</li><li>HTTPS比HTTP更安全: 
   <ol><li>HTTP是<strong>明文传输</strong>; HTTPS是<strong>ssl加密传输</strong></li><li>HTTPS要验证证书, 防止服务端被冒充, 向CA机构申请证书需要付费</li></ol> </li></ol> 
</blockquote> 
<h4><a id="_216"></a>数字签名的制作过程?</h4> 
<blockquote> 
 <ol><li>使用签名算法对证书内容进行<strong>hash运算</strong></li><li>对hash值进行<strong>私钥加密</strong>, 即得到数字签名</li></ol> 
</blockquote> 
<h4><a id="_221"></a>验证证书的过程?</h4> 
<blockquote> 
 <ol><li>用CA机构的公钥<strong>对数字签名解密</strong></li><li>用签名算法<strong>对证书内容进行hash运算</strong></li><li>比较解密后的数字签名 和 对证书内容做hash运算后得到的哈希值，相等则表明证书可信</li></ol> 
</blockquote> 
<h4><a id="HTTPS__SSL_227"></a>HTTPS原理 / SSL四次握手过程?</h4> 
<blockquote> 
 <ol><li>客户端向服务端<strong>发送请求</strong> 进行协商加密算法</li><li>服务端响应自己<strong>选中</strong>的加密算法, 并<strong>返回证书</strong>(证书内容、签名算法、签名)</li><li>客户端进行验证证书, 若验证成功, 则继续请求服务端执行后续握手, 否则进行断开</li><li>服务端生成<strong>密钥</strong>, 响应给客户端</li></ol> 
</blockquote> 
<h4><a id="HTTPS____234"></a>HTTPS 的优缺点 / 特点?</h4> 
<p><strong>优点</strong>：</p> 
<ul><li> <p><code>安全</code>性：</p> 
  <ul><li> <p>HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被<code>窃取</code>、<code>改变</code>，确保数据的<code>完整性</code></p> </li><li> <p>HTTPS是现行架构下最安全的解决方案，<code>虽然不是绝对安全</code>，但它大幅增加了中间人攻击的成本</p> </li></ul> </li><li> <p><code>SEO</code>方面：比起同等的HTTP网站，采用HTTPS加密的网站在搜索结果中的排名将会更高</p> </li></ul> 
<p><strong>缺点</strong>：</p> 
<ul><li>HTTPS 相比于 HTTP 的开销更大, 响应时间更久</li><li>HTTPS 的安全是有限的</li></ul> 
<h3><a id="HTTP_250"></a>HTTP</h3> 
<h4><a id="HTTP__252"></a>HTTP 的优点:</h4> 
<ol><li> <p>简单</p> <p>HTTP 基本的报⽂格式就是 header + body ，头部信息也是 key-value 简单⽂本的形式</p> </li><li> <p>灵活和易于扩展</p> 
  <ul><li>请求方法、状态码、头字段 可以自定义扩充</li><li>网络分层, 下层可以随意变化 
    <ul><li>如HTTPS在TCP上方加了一层SSL层</li><li>如HTTP3.0 将TCP替换成了基于UDP的Quic</li></ul> </li></ul> </li><li> <p>应用广泛和跨平台</p> </li></ol> 
<h4><a id="HTTP__267"></a>HTTP 的缺点:</h4> 
<ol><li> <p>无状态(双刃剑)</p> <p><strong>好处:</strong></p> <p>服务器不会去记忆 HTTP 的状态，所以不需要额外的资源来记录状态信息，这能减轻服务器的<code>负担</code></p> <p><strong>坏处:</strong></p> <p>每次验证身份登录信息时, 都显示未登录</p> <p><strong>解决方案:</strong></p> <p>Cookie-Session</p> </li><li> <p>不安全</p> 
  <ol><li>明文传输，内容可能会被<code>窃听</code></li><li>不验证通信方的身份，服务端可能是<code>冒充</code>的</li><li>无法证明报文的完整性，所以报文有可能已遭<code>篡改</code></li></ol> </li></ol> 
<h4><a id="HTTP11HTTP10_289"></a>HTTP1.1和HTTP1.0的区别?</h4> 
<ul><li> <p><strong>长连接</strong></p> </li><li> <p><strong>缓存</strong>处理, 如果访问的资源没有被修改且缓存没过期 则不再重新请求服务端</p> </li><li> <p>新增了一些<strong>状态响应码</strong></p> </li><li> <p>新增了请求头<strong>range</strong>字段, 可以用来指定只访问局部资源 节省网络带宽</p> </li><li> <p><strong>断点续传</strong>的功能</p> </li><li> <p>新增了<strong>Host头处理</strong>：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此请求消息中的URL并没有传递主机名;</p> <p>到了HTTP1.1时代，在一台物理服务器上可以存在多个虚拟主机 并且它们共享一个IP地址，故HTTP1.1增加了HOST信息</p> </li><li> <p><strong>异步发送多个请求</strong>, 但不完善, 服务端依旧按序响应 可能会发生队头阻塞</p> </li></ul> 
<p><strong>缺陷:</strong> 队头阻塞</p> 
<p><img src="https://images2.imgbox.com/da/fe/VjLGHdXP_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="HTTP20_HTTP11_312"></a>HTTP2.0和 HTTP1.1的区别？</h4> 
<ul><li><strong>二进制格式</strong>：HTTP1.1的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。</li><li><strong>多路复用</strong>，服务端异步响应, 防止队头阻塞</li><li><strong>头部压缩</strong>，HTTP1.1的头部（header）带有大量信息，而且每次都要重复发送；HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</li><li><strong>服务端推送</strong>：服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求。</li><li><strong>指定请求的优先级</strong></li></ul> 
<p><strong>缺陷:</strong> 粒度太大, 丢包时 导致所有同批次的请求都得重传</p> 
<p><img src="https://images2.imgbox.com/1a/e2/o1SJKNf2_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="HTTP30_HTTP20_325"></a>HTTP3.0和 HTTP2.0的区别？</h4> 
<p>采用基于 UDP 的 QUIC 协议, 可以实现类似 TCP 的可靠性传输</p> 
<ol><li> <p>粒度小, 丢包时 其他同批次的请求不受影响</p> </li><li> <p>头部压缩算法升级成了 QPack</p> </li><li> <p>连接迁移时(wifi 转换为 流量)不必重新建立连接</p> <p>基于四元组（源 IP、源端口、目的 IP、目的端口）</p> </li></ol>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ac0aba58d59250f84d974fe0e855d0b8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">R实战 | 聚类分析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d7b1cb5becd123076726f36e9363e4b4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机网络_03_传输层(个人总结)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>