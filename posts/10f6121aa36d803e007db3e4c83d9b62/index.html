<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MyBatis一对多关联查询 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MyBatis一对多关联查询" />
<meta property="og:description" content="转自:
MyBatis一对多关联查询
一对多级联关系的处理
一对多的级联关系：在我们日常开发中有很多这样的情况，
如:
一个用户下面会有很多订单，但是每一个订单都只会属于一个用户，
这就是一个典型的一对多的级联关系操作,那么如何使用MyBatis进行此类数据的查询操作呢？下文将一一道来，如下所示:
实现思路: 在 MyBatis 中， 我们可通过 &lt;resultMap&gt; 元素的子元素 &lt;collection&gt; 处理一对多级联关系， collection 可以将关联查询的多条记录映射到一个 list 集合属性中， 代码如下 &lt;collection property=&#34;orderList&#34; ofType=&#34;com.java265.po.Order&#34; column=&#34;id&#34; select=&#34;com.java265.mapper.OrderMapper.selectOrderById&#34; /&gt; 在&lt;collection&gt;元素中通常使用以下属性。 property：指定映射到实体类的对象属性。 column：指定表中对应的字段（即查询返回的列名）。 javaType：指定映射到实体对象属性的类型。 select：指定引入嵌套查询的子 SQL 语句，该属性用于关联映射中的嵌套查询。
一对多关联查询可采用以下两种方式：分步查询，通过两次或多次查询，为一对多关系的实体 Bean 赋值单步查询，通过关联查询实现 例 下面以用户和订单为例讲解一对多关联查询（实现“根据 id 查询用户及其关联的订单信息”的功能）的处理过程。
创建数据表
本实例需要两张数据表，一张是用户表 user，一张是订单表 order，这两张表具有一对多的级联关系。SQL 语句如下： CREATE TABLE `order` ( `id` int(11) NOT NULL AUTO_INCREMENT, `ordernum` int(25) DEFAULT NULL, `userId` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `userId` (`userId`) ) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8; insert into `order`(`id`,`ordernum`,`userId`) values (1,20210101,1),(2,20210102,2),(3,20210103,3),(4,20200645,1),(5,20210104,2),(6,20210105,2),(7,20210106,3); DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20) DEFAULT NULL, `pwd` varchar(20) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8; insert into `user`(`id`,`name`,`pwd`) values (1,&#39;张三&#39;,&#39;123&#39;),(2,&#39;王二&#39;,&#39;456&#39;),(3,&#39;麻子&#39;,&#39;123&#39;),(4,&#39;张积粮&#39;,&#39;345&#39;),(5,&#39;李晓爱&#39;,&#39;123&#39;),(6,&#39;古天乐&#39;,&#39;789&#39;);" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/10f6121aa36d803e007db3e4c83d9b62/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-27T16:29:57+08:00" />
<meta property="article:modified_time" content="2022-11-27T16:29:57+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MyBatis一对多关联查询</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>转自:</p> 
<p><a href="http://www.java265.com/JavaFramework/MyBatis/202107/544.html" rel="nofollow" title="MyBatis一对多关联查询">MyBatis一对多关联查询</a></p> 
<p>一对多级联关系的处理</p> 
<p><span style="color:#fe2c24;"><strong>一对多的级联关系：在我们日常开发中有很多这样的情况</strong></span>，<br> 如:<br> 一个用户下面会有很多订单，但是每一个订单都只会属于一个用户，<br> 这就是一个典型的一对多的级联关系操作,那么如何使用MyBatis进行此类数据的查询操作呢？下文将一一道来，如下所示:</p> 
<pre>实现思路:
  在 MyBatis 中，

我们可通过 &lt;resultMap&gt; 元素的子元素 &lt;collection&gt; 处理一对多级联关系，
collection 可以将关联查询的多条记录映射到一个 list 集合属性中，
代码如下
&lt;collection property="orderList"
        ofType="com.java265.po.Order" column="id"
        select="com.java265.mapper.OrderMapper.selectOrderById" /&gt;

</pre> 
<p>在&lt;collection&gt;元素中通常使用以下属性。 property：指定映射到实体类的对象属性。 column：指定表中对应的字段（即查询返回的列名）。 javaType：指定映射到实体对象属性的类型。 select：指定引入嵌套查询的子 SQL 语句，该属性用于关联映射中的嵌套查询。</p> 
<ol><li>一对多关联查询可采用以下两种方式：</li><li>分步查询，通过两次或多次查询，为一对多关系的实体 Bean 赋值</li><li>单步查询，通过关联查询实现</li></ol> 
<p>例 下面以用户和订单为例讲解一对多关联查询（实现“根据 id 查询用户及其关联的订单信息”的功能）的处理过程。</p> 
<p>创建数据表</p> 
<p>本实例需要两张数据表，一张是用户表 user，一张是订单表 order，这两张表具有一对多的级联关系。SQL 语句如下： CREATE TABLE `order` ( `id` int(11) NOT NULL AUTO_INCREMENT, `ordernum` int(25) DEFAULT NULL, `userId` int(11) DEFAULT NULL, PRIMARY KEY (`id`), KEY `userId` (`userId`) ) ENGINE=InnoDB AUTO_INCREMENT=9 DEFAULT CHARSET=utf8; insert into `order`(`id`,`ordernum`,`userId`) values (1,20210101,1),(2,20210102,2),(3,20210103,3),(4,20200645,1),(5,20210104,2),(6,20210105,2),(7,20210106,3); DROP TABLE IF EXISTS `user`; CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(20) DEFAULT NULL, `pwd` varchar(20) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8; insert into `user`(`id`,`name`,`pwd`) values (1,'张三','123'),(2,'王二','456'),(3,'麻子','123'),(4,'张积粮','345'),(5,'李晓爱','123'),(6,'古天乐','789');</p> 
<p>创建持久化类</p> 
<p>创建持久化类 User 和 Order，代码</p> 
<pre>package com.java265.po;
import java.util.List;
public class User {
    private int id;
    private String name;
    private String pwd;
    private List&lt;Order&gt; orderList;
    /*省略setter和getter方法*/
    @Override
    public String toString() {
        return "User [id=" + id + ", name=" + name + ", orderList=" + orderList + "]";
    }
}
</pre> 
<p>Order 类</p> 
<pre>package com.java265.po;
public class Order {
    private int id;
    private int ordernum;
    /*省略setter和getter方法*/
    @Override
    public String toString() {
        return "Order [id=" + id + ", ordernum=" + ordernum + "]";
    }
}
</pre> 
<p>分步查询</p> 
<p>OrderMapper 类</p> 
<pre>public List&lt;Order&gt; selectOrderById(int id);
</pre> 
<p>OrderMapper.xml 中相应的映射 SQL 语句</p> 
<pre>&lt;select id="selectOrderById" resultType="com.java265.po.Order"
    parameterType="Integer"&gt;
    SELECT * FROM `order` where userId=#{id}
&lt;/select&gt;

</pre> 
<p>UserMapper 类</p> 
<pre>public User selectUserOrderById1(int id);
</pre> 
<p>UserMapper.xml 中相应的映射 SQL 语句如下</p> 
<pre>&lt;!-- 一对多 根据id查询用户及其关联的订单信息：级联查询的第一种方法（分步查询） --&gt;
&lt;resultmap id="userAndOrder1" type="com.java265.po.User"&gt;
    &lt;id column="id" property="id"&gt;
    &lt;result column="name" property="name"&gt;
    &lt;result column="pwd" property="pwd"&gt;
    &lt;!-- 一对多级联查询，ofType表示集合中的元素类型，将id传递给selectOrderById --&gt;
    &lt;collection column="id" oftype="com.java265.po.Order" property="orderList" select="com.java265.mapper.OrderMapper.selectOrderById"&gt;
&lt;/collection&gt;&lt;/result&gt;&lt;/result&gt;&lt;/id&gt;&lt;/resultmap&gt;
&lt;select id="selectUserOrderById1" parametertype="Integer" resultmap="userAndOrder1"&gt;
    select * from user where id=#{id}
&lt;/select&gt;

</pre> 
<p>测试代码</p> 
<pre>public class Test {
    public static void main(String[] args) throws IOException {
        InputStream config = Resources.getResourceAsStream("mybatis-config.xml");
        SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(config);
        SqlSession ss = ssf.openSession();
        User us = ss.getMapper(UserMapper.class).selectUserOrderById1(1);
        System.out.println(us);
    }
}
</pre> 
<p>运行结果<br> DEBUG [main] - ==&gt; Preparing: select * from user where id=?<br> DEBUG [main] - ==&gt; Parameters: 1(Integer)<br> DEBUG [main] - ====&gt; Preparing: SELECT * FROM `order` where userId=?<br> DEBUG [main] - ====&gt; Parameters: 1(Integer)<br> DEBUG [main] - &lt;==== Total: 2<br> DEBUG [main] - &lt;== Total: 1 User [id=1, name=张三, orderList=[Order [id=1, ordernum=20210101], Order [id=4, ordernum=20200645]]]</p> 
<p>单步查询</p> 
<p>该种方式实现一对多关联查询需要修改 Order 持久化类，因为 Order 中的 id 不能和 User 中的 id 重复。</p> 
<pre>package com.java265.po;
public class Order {
    private int oId;
    private int ordernum;
    /*省略setter和getter方法*/
    @Override
    public String toString() {
        return "Order [id=" + oId+ ", ordernum=" + ordernum + "]";
    }
}
</pre> 
<p>UserMapper 类</p> 
<pre>public User selectUserOrderById2(int id);
</pre> 
<p>UserMapper.xml 中相关映射 SQL 语句</p> 
<pre>&lt;!-- 一对多 根据id查询用户及其关联的订单信息：级联查询的第二种方法（单步查询） --&gt;
&lt;resultmap id="userAndOrder2" type="com.java265.po.User"&gt;
    &lt;id column="id" property="id"&gt;
    &lt;result column="name" property="name"&gt;
    &lt;result column="pwd" property="pwd"&gt;
    &lt;!-- 一对多级联查询，ofType表示集合中的元素类型 --&gt;
    &lt;collection oftype="com.java265.po.Order" property="orderList"&gt;
        &lt;id column="oId" property="oId"&gt;
        &lt;result column="ordernum" property="ordernum"&gt;
    &lt;/result&gt;&lt;/id&gt;&lt;/collection&gt;
&lt;/result&gt;&lt;/result&gt;&lt;/id&gt;&lt;/resultmap&gt;
&lt;select id="selectUserOrderById2" parametertype="Integer" resultmap="userAndOrder2"&gt;
    SELECT u.*,o.id as oId,o.ordernum FROM `user` u,`order` o
    WHERE
    u.id=o.`userId` AND u.id=#{id}
&lt;/select&gt;
</pre> 
<p>测试代码修改调用方法，如下</p> 
<pre>public class Test {
    public static void main(String[] args) throws IOException {
        InputStream config = Resources.getResourceAsStream("mybatis-config.xml");
        SqlSessionFactory ssf = new SqlSessionFactoryBuilder().build(config);
        SqlSession ss = ssf.openSession();
        User us = ss.getMapper(UserMapper.class).selectUserOrderById2(1);
        System.out.println(us);
    }
}
</pre> 
<p>运行结果如下<br> DEBUG [main] - ==&gt; Preparing: SELECT u.*,o.id as oId,o.ordernum FROM `user` u,`order` o WHERE u.id=o.`userId` AND u.id=?<br> DEBUG [main] - ==&gt; Parameters: 1(Integer)<br> DEBUG [main] - &lt;== Total: 2 User [id=1, name=张三, orderList=[Order [id=1, ordernum=20200107], Order [id=4, ordernum=20200645]]]</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/fea1ee16845e768b7fb8bd2164fde39b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">int *p=a和int *p=&amp;a的区别</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a81320e6ff25141ccc6e9c6b1f9c8304/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">#韭菜自我修养记录贴</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>