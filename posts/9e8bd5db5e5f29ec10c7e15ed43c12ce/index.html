<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【UnityShader入门精要学习笔记】第三章（1）Unity Shader介绍 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【UnityShader入门精要学习笔记】第三章（1）Unity Shader介绍" />
<meta property="og:description" content="本系列为作者学习UnityShader入门精要而作的笔记，内容将包括：
书本中句子照抄 &#43; 个人批注项目源码一堆新手会犯的错误潜在的太监断更，有始无终 总之适用于同样开始学习Shader的同学们进行有取舍的参考。
文章目录 Unity Shader概述Unity中的材质Unity Shader Unity Shader基础之ShaderLab什么是ShaderLab Unity Shader的结构命名材质和Unity Shader的桥梁：Properties重要的部分：SubShader状态（[RenderSetup])SubShader的标签（Tag）Pass语义块后路：FallbackShaderLab的其他语义 从本章节开始我们要学习Shader相关的知识了，诸位看客可能有的人很高兴了，“太好了终于可以写Shader了，我已经迫不及待了”。其实还没有，第三章我们只是介绍Shader的基础知识。“那下章就可以写Shader了”，其实也不是，下章我们要学习数学基础。起码要下下章才能开始学习编写Shader代码，还得从最基本的语法开始学习，路漫漫其修远兮，心急吃不了热豆腐。
Unity Shader概述 根据第二章中我们学习的知识，我们知道了渲染管线中有各种可编程的着色器阶段和许多可以配置的渲染设置。其实UnityShader的作用就是对各类着色器代码以及渲染设置进行管理。
经常接触3D开发的开发者们都知道，在Unity中，想要为一个模型网格体渲染出强大的视觉效果，往往离不开两个东西：
材质（Material）Shader 一个常见的网格体渲染设置的流程是：
创建一个材质
创建一个UnityShader，并把它赋给上一步中创建的材质（或是选择Unity预设的Shader）
把材质赋给要渲染的对象
在材质面板中调整UnityShader的属性，以得到满意的效果
下图显示了Shader和材质是如何一起工作来控制物体的渲染的：
UnityShader中定义了渲染所需的各种代码（如顶点着色器和片元着色器）、属性（如使用哪些纹理等）和指令（渲染和标签设置等）。而材质则允许我们调节这些属性，并最终赋值给相应的模型。
Unity中的材质 我们知道了如果需要为网格渲染需要赋予材质，而材质需要赋予Shader。空白的网格体其实相当于一张空白画布，把材质赋予网格体相当于在画布上绘画，而Shader就像是材质的调色板，可以通过改变Shader中的属性来修改网格上画面的属性和渲染状态。
在此处，我认为有必要理清材质（Material）、着色器（Shader）、贴图（Map）、纹理（Texture）的关系 。首先从集合上的包含关系来看，材质Material（包含着色器）&gt;贴图Map&gt;纹理Texture 。
Material本质上是一个数据集，它包含了Shader的渲染设置，以及供Shader读取的那些数据（包括了纹理texture和各类贴图map），而实际上纹理应当被贴图包含，纹理的全称应该被称为Texture Map，也就是纹理贴图，以上图为例，unity中的Albedo其实是反射率贴图，用于表示模型的纹理和颜色，因此我们常常把纹理贴图赋值给这个属性。
而贴图不仅仅包含了基本的纹理，实际上还包含了UV坐标，各种输入输出控制等其他信息，所以会有很多贴图，Height Map（光照贴图），Normal Map（法线贴图）。
本质上贴图的英文Map代表的不是位图bitmap，这个Map是一个动词，翻译过来是“映射”，其功能就是把纹理通过 UV 坐标映射到3D 物体表面。
（上述答案可能有误，关于贴图和纹理的关系网上众说纷纭，其实没必要咬文嚼字）
Unity Shader 为了和前面通用的Shader语义进行区分，我们把Unity中的Shader文件统称为Unity Shader。因为Unity Shader和我们之前提到的渲染管线的Shader有很大不同（这将在后文中解释）。
我们可以在资源栏右键创建一个Unity Shader，Unity为我们提供了四种模板（上图是2022版本，提供了5种）。
Standard Surface Shader 会产生一个包含标准光照模型的表面着色器模板。UnlitShader会产生一个不包含光照（但包含雾效）的基本的顶点/片元着色器。Image Effect Shader 为我们实现各种屏幕的后处理效果提供一个基本的模板。Compute Shader 会产生一种特殊的Shader 文件，这类Shader旨在利用GPU的并行性来进行一些与常规渲染流水线无关的计算。Ray Tracing Shader是利用RTX显卡实现光线追踪的Shader。
Standard Surface Shader是一种典型的表面着色器的实现方法。但是本书的重点在于如何在Unity中编写顶点/片元着色器，因此后续的学习中我们通常会使用Unlit Shader来编写Shader。
在Shader的面板上，我们可以看到该Shader的面板属性（这些属性在材质中是可以直接通过编辑器来赋值和调整的）,也对应了最下方的Properties： 显示的属性（Properties显示了属性名和其类型，方便我们在C#中通过代码进行调用）。
在Shader的Imported Object面板上，我们可以看到一些和该Unity Shader相关的信息，例如它是否是一个表面着色器（Surface shader）、是否是固定函数着色器（Fixed Function）等来判断其着色器类型，还有一些信息是我们在UnityShader中的标签设置相关，例如是否计算阴影（Cast shadows），使用的渲染队列（Render queue）、LOD层级等" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9e8bd5db5e5f29ec10c7e15ed43c12ce/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-04T21:37:02+08:00" />
<meta property="article:modified_time" content="2024-01-04T21:37:02+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【UnityShader入门精要学习笔记】第三章（1）Unity Shader介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/d9/2d/FTb7D62Q_o.png" alt="在这里插入图片描述"><br> 本系列为作者学习UnityShader入门精要而作的笔记，内容将包括：</p> 
<ul><li>书本中句子照抄 + 个人批注</li><li>项目源码</li><li>一堆新手会犯的错误</li><li>潜在的太监断更，有始无终</li></ul> 
<p>总之适用于同样开始学习Shader的同学们进行有取舍的参考。</p> 
<hr> 
<p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#Unity_Shader_16" rel="nofollow">Unity Shader概述</a></li><li><ul><li><a href="#Unity_42" rel="nofollow">Unity中的材质</a></li><li><a href="#Unity_Shader_57" rel="nofollow">Unity Shader</a></li></ul> 
  </li><li><a href="#Unity_ShaderShaderLab_83" rel="nofollow">Unity Shader基础之ShaderLab</a></li><li><ul><li><a href="#ShaderLab_89" rel="nofollow">什么是ShaderLab</a></li></ul> 
  </li><li><a href="#Unity_Shader_119" rel="nofollow">Unity Shader的结构</a></li><li><ul><li><a href="#_121" rel="nofollow">命名</a></li><li><a href="#Unity__ShaderProperties_132" rel="nofollow">材质和Unity Shader的桥梁：Properties</a></li><li><a href="#SubShader_179" rel="nofollow">重要的部分：SubShader</a></li><li><ul><li><a href="#RenderSetup_204" rel="nofollow">状态（[RenderSetup])</a></li><li><a href="#SubShaderTag_219" rel="nofollow">SubShader的标签（Tag）</a></li><li><a href="#Pass_246" rel="nofollow">Pass语义块</a></li><li><a href="#Fallback_292" rel="nofollow">后路：Fallback</a></li><li><a href="#ShaderLab_319" rel="nofollow">ShaderLab的其他语义</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<hr> 
<p>从本章节开始我们要学习Shader相关的知识了，诸位看客可能有的人很高兴了，“太好了终于可以写Shader了，我已经迫不及待了”。其实还没有，第三章我们只是介绍Shader的基础知识。“那下章就可以写Shader了”，其实也不是，下章我们要学习数学基础。起码要下下章才能开始学习编写Shader代码，还得从最基本的语法开始学习，路漫漫其修远兮，心急吃不了热豆腐。</p> 
<h2><a id="Unity_Shader_16"></a>Unity Shader概述</h2> 
<p>根据第二章中我们学习的知识，我们知道了渲染管线中有各种可编程的着色器阶段和许多可以配置的渲染设置。其实UnityShader的作用就是对各类着色器代码以及渲染设置进行管理。</p> 
<p>经常接触3D开发的开发者们都知道，在Unity中，想要为一个模型网格体渲染出强大的视觉效果，往往离不开两个东西：</p> 
<ul><li><strong>材质（Material）</strong></li><li><strong>Shader</strong></li></ul> 
<p>一个常见的网格体渲染设置的流程是：</p> 
<ol><li> <p>创建一个材质<img src="https://images2.imgbox.com/25/03/4cMZg7aE_o.png" alt="在这里插入图片描述"></p> </li><li> <p>创建一个UnityShader，并把它赋给上一步中创建的材质（或是选择Unity预设的Shader）<img src="https://images2.imgbox.com/1c/f3/7K78TqT4_o.png" alt="在这里插入图片描述"></p> </li><li> <p>把材质赋给要渲染的对象<img src="https://images2.imgbox.com/b6/ac/KrJWTZPt_o.png" alt="在这里插入图片描述"></p> </li><li> <p>在材质面板中调整UnityShader的属性，以得到满意的效果<img src="https://images2.imgbox.com/1e/fc/kMjm0XEf_o.png" alt="在这里插入图片描述"></p> </li></ol> 
<p>下图显示了Shader和材质是如何一起工作来控制物体的渲染的：</p> 
<p><img src="https://images2.imgbox.com/6d/f0/fr69sWRh_o.png" alt="在这里插入图片描述"></p> 
<p>UnityShader中定义了渲染所需的各种代码（如顶点着色器和片元着色器）、属性（如使用哪些纹理等）和指令（渲染和标签设置等）。而材质则允许我们调节这些属性，并最终赋值给相应的模型。</p> 
<hr> 
<h3><a id="Unity_42"></a>Unity中的材质</h3> 
<p>我们知道了如果需要为网格渲染需要赋予材质，而材质需要赋予Shader。空白的网格体其实相当于一张空白画布，把材质赋予网格体相当于在画布上绘画，而Shader就像是材质的调色板，可以通过改变Shader中的属性来修改网格上画面的属性和渲染状态。<br> <img src="https://images2.imgbox.com/bb/43/FdgcMkD1_o.png" alt="在这里插入图片描述"><br> 在此处，我认为有必要理清<strong>材质（Material）、着色器（Shader）、贴图（Map）、纹理（Texture）的关系</strong> 。首先从集合上的包含关系来看，<strong>材质Material（包含着色器）&gt;贴图Map&gt;纹理Texture</strong> 。</p> 
<p>Material本质上是一个数据集，它包含了Shader的渲染设置，以及供Shader读取的那些数据（包括了纹理texture和各类贴图map），而实际上纹理应当被贴图包含，纹理的全称应该被称为Texture Map，也就是纹理贴图，以上图为例，unity中的Albedo其实是反射率贴图，用于表示模型的纹理和颜色，因此我们常常把纹理贴图赋值给这个属性。</p> 
<p>而贴图不仅仅包含了基本的纹理，实际上还包含了UV坐标，各种输入输出控制等其他信息，所以会有很多贴图，Height Map（光照贴图），Normal Map（法线贴图）。</p> 
<p>本质上贴图的英文Map代表的不是位图bitmap，这个Map是一个动词，翻译过来是“<strong>映射</strong>”，其功能就是把纹理通过 UV 坐标映射到3D 物体表面。</p> 
<p>（上述答案可能有误，关于贴图和纹理的关系网上众说纷纭，其实没必要咬文嚼字）</p> 
<hr> 
<h3><a id="Unity_Shader_57"></a>Unity Shader</h3> 
<p>为了和前面通用的Shader语义进行区分，我们把Unity中的Shader文件统称为Unity Shader。因为Unity Shader和我们之前提到的渲染管线的Shader有很大不同（这将在后文中解释）。</p> 
<p><img src="https://images2.imgbox.com/7f/09/Wq9ZTQhh_o.png" alt="在这里插入图片描述"><br> 我们可以在资源栏右键创建一个Unity Shader，Unity为我们提供了四种模板（上图是2022版本，提供了5种）。</p> 
<p><mark>Standard Surface Shader 会产生一个包含标准光照模型的表面着色器模板。UnlitShader会产生一个不包含光照（但包含雾效）的基本的顶点/片元着色器。Image Effect Shader 为我们实现各种屏幕的后处理效果提供一个基本的模板。Compute Shader 会产生一种特殊的Shader 文件，这类Shader旨在利用GPU的并行性来进行一些与常规渲染流水线无关的计算。Ray Tracing Shader是利用RTX显卡实现光线追踪的Shader。</mark></p> 
<p>Standard Surface Shader是一种典型的表面着色器的实现方法。但是本书的重点在于如何在Unity中编写顶点/片元着色器，因此后续的学习中我们通常会使用Unlit Shader来编写Shader。</p> 
<p><img src="https://images2.imgbox.com/d0/17/SrZv4wpH_o.png" alt="在这里插入图片描述"><br> 在Shader的面板上，我们可以看到该Shader的面板属性（这些属性在材质中是可以直接通过编辑器来赋值和调整的）,也对应了最下方的<strong>Properties：</strong> 显示的属性（Properties显示了属性名和其类型，方便我们在C#中通过代码进行调用）。</p> 
<p><mark>在Shader的Imported Object面板上，我们可以看到一些和该Unity Shader相关的信息，例如它是否是一个表面着色器（Surface shader）、是否是固定函数着色器（Fixed Function）等来判断其着色器类型，还有一些信息是我们在UnityShader中的标签设置相关，例如是否计算阴影（Cast shadows），使用的渲染队列（Render queue）、LOD层级等</mark></p> 
<p><img src="https://images2.imgbox.com/d1/35/g3RZwPDi_o.png" alt="在这里插入图片描述"><br> 对于表面着色器，我们可以通过点击<strong>Show generated code</strong>来生产代码文件，该文件将显示Unity为该Shader的表面着色器生产的顶点/片元着色器。（同样的如果该Shader是一个固定函数着色器，也可以点击生成对应的顶点/片元着色器）</p> 
<p>点击<strong>Compile and show code</strong>下拉列表可以让开发者检查Unity Shader针对不同图像编程接口最终编译的Shader代码。直接单机该按钮以生成可查看的底层汇编指令，我们可以利用这些代码来分析和优化着色器。</p> 
<p>除此之外，Unity Shader的导入面板还可以查看使用的渲染队列（Render queue）、是否关闭批处理（Disable batching）、属性列表（Properties）等信息，非常方便。</p> 
<hr> 
<h2><a id="Unity_ShaderShaderLab_83"></a>Unity Shader基础之ShaderLab</h2> 
<p>在学习和编写着色器的过程中，为了自定义渲染效果往往需要和很多文件和设置打交道，这些过程很容易消磨掉初学者的耐心。而且，一些细节问题也往往需要开发者花费较多的时间去解决。</p> 
<p>Unity为了解决上述问题，为我们提供了一层抽象——Unity Shader，我们与这层抽象打交道的途径就是使用Unity提供的一种专门为Unity Shader服务的语言——<strong>ShaderLab</strong>。</p> 
<h3><a id="ShaderLab_89"></a>什么是ShaderLab</h3> 
<p>Unity Shader是Unity为开发者提供的高层级的渲染抽象层。<br> <img src="https://images2.imgbox.com/af/d4/3WGVoAFw_o.png" alt="在这里插入图片描述"><br> 由于渲染过程中涉及的步骤和设置太多。开发者需要和很多的设置文件打交道，而使用ShaderLab来编写Unity Shader就可以完成左图中的所有工作。在Unity中我们可以使用这种方式来更轻松地控制渲染。</p> 
<p>所有的Unity Shader都是使用ShaderLab来编写的。<mark>它使用了一些嵌套在花括号内部的语义来描述了一个Unity Shader文件的结构。</mark>这些结构包含了许多渲染所需的数据，例如<strong>Properites</strong>语句块中定义了着色器所需的各种属性，这些属性我们可以Import面板中检视，或者在材质面板中进行调整。<strong>ShaderLab定义了一个材质所需的所有东西，而不仅仅是着色器代码。</strong></p> 
<pre><code class="prism language-c">Shader <span class="token string">"ShaderName"</span>
<span class="token punctuation">{<!-- --></span>
    Properties
    <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//属性</span>
    <span class="token punctuation">}</span>
    SubShader
    <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//显卡A使用的子着色器</span>
    <span class="token punctuation">}</span>
    SubShader
    <span class="token punctuation">{<!-- --></span>
		<span class="token comment">//显卡B使用的子着色器</span>
    <span class="token punctuation">}</span>
    Fallback <span class="token string">"VertexLit"</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>上述代码是一个Unity Shader的基础结构，Unity会将其编译为真正的代码和Shader文件。</p> 
<hr> 
<h2><a id="Unity_Shader_119"></a>Unity Shader的结构</h2> 
<h3><a id="_121"></a>命名</h3> 
<p>每个Unity Shader文件的第一行都需要通过Shader语义来指定该Unity Shader的名字。例如：</p> 
<pre><code class="prism language-c">Shader <span class="token string">"Custom/MyShader"</span>
</code></pre> 
<p>其中，最后一级反斜杠后的字符串代表了该Unity Shader的名称，而前面的字符串代表了路径，以每个反斜杠后的字符为一级，当添加路径之后这个Shader就可以出现在材质球的Shader选择的下拉列表里。<br> <img src="https://images2.imgbox.com/ef/40/1z72xqut_o.png" alt="在这里插入图片描述"><br> 如上图所示，我们可以根据名字在材质面板的相应路径下找到该Unity Shader。</p> 
<h3><a id="Unity__ShaderProperties_132"></a>材质和Unity Shader的桥梁：Properties</h3> 
<p>Properties语句块中包含了一系列属性，这些属性将会出现在材质面板中。</p> 
<p>Properties语义块的定义如下：</p> 
<pre><code class="prism language-c">Properties <span class="token punctuation">{<!-- --></span> 
<span class="token function">Name</span> <span class="token punctuation">(</span><span class="token string">"display name"</span><span class="token punctuation">,</span> PropertyType<span class="token punctuation">)</span> <span class="token operator">=</span> DefaultValue 
<span class="token function">Name</span> <span class="token punctuation">(</span><span class="token string">"display name"</span><span class="token punctuation">,</span> PropertyType<span class="token punctuation">)</span> <span class="token operator">=</span> DefaultValue 
<span class="token comment">//更多属性</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>每个属性字段应当包含三个主要定义：</p> 
<ul><li>Name（名字），当我们需要在Unity Shader中访问这个属性的时候，需要用到Name（通常Name的起名是下划线加大驼峰，例如“_MainTex”）</li><li>display name（显示名称），这一定义代表了Shader在材质面板上显示的当前属性的名称（也就是材质面板上显示的是display name而非Name）</li><li>PropertyType（类型），它定义了当前属性的类型</li><li>DefaultValue（默认值），我们还需要为属性定义一个默认值，当Shader第一次被赋值给材质的时候就会自动初始化为默认值。</li></ul> 
<p>通常如果我们需要在C#脚本中访问Shader属性，则需要根据Name的值来进行访问。而在材质面板中则需要修改对应的Display Name 的属性值。</p> 
<hr> 
<table><thead><tr><th align="left">属性类型</th><th align="left">默认值的定义语法</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">Int</td><td align="left">number</td><td align="left">_Int(“Int”,Int) = 2</td></tr><tr><td align="left">Float</td><td align="left">number</td><td align="left">_Float(“Float”,Float) = 1.5</td></tr><tr><td align="left">Range(min,max)</td><td align="left">number</td><td align="left">_Range(“Range”,Range(0.0,5.0)) = 3.0</td></tr><tr><td align="left">Color</td><td align="left">(number,number,number,number)</td><td align="left">_Color(“Color”,Color) = (1,1,1,1)</td></tr><tr><td align="left">Vector</td><td align="left">(number,number,number,number)</td><td align="left">_Vector(“Vector”,Vector) = (2,3,6,1)</td></tr><tr><td align="left">2D</td><td align="left">“defaulttexture”{}</td><td align="left">_2D(“2D”,2D) = “” {}</td></tr><tr><td align="left">Cube</td><td align="left">“defaulttexture”{}</td><td align="left">_Cube(“Cube”,Cube) = “white” {}</td></tr><tr><td align="left">3D</td><td align="left">“defaulttexture”{}</td><td align="left">_3D(“3D”,3D) = “black” {}</td></tr></tbody></table> 
<p>上表展示了一些Unity Shader中的基本属性，主要可以分为三大类。</p> 
<ul><li><strong>Int，Float，Range</strong> 这些number型的属性，其默认值就是一个数字，Int我们用整数，而Float和Range使用浮点数。</li><li><strong>Color和Vector</strong> 使用一个圆括号包裹的四维向量，因为这两个属性的值都需要四维向量来进行描述，Color包含了RGB和Alpha通道，Vector用四元数来表示向量，对应XYZW。</li><li><strong>2D，Cube，3D</strong>都是默认纹理，通过一个字符串加花括号来指定。其中字符串要么为空，要么是内置的纹理名称，如：“white",“black”,“gray”,“bump”。花括号原本是用于指定一些纹理属性的，不过后来的版本中被移除了。</li></ul> 
<p><img src="https://images2.imgbox.com/84/54/01QcfxPv_o.png" alt="在这里插入图片描述"><br> 如果我们想要在Unity的材质面板中显示更多类型的遍历，例如使用bool来控制Shader面板中的计算方法，Unity也允许我们重载材质编辑面板，在后文中也能学习到。</p> 
<hr> 
<h3><a id="SubShader_179"></a>重要的部分：SubShader</h3> 
<p>每个Unity Shader文件可以包含多个SubShader（子着色器）语义块，但最少需要有一个，当Unity需要加载这个Unity Shader时，Unity会扫描所有的SubShader语义快，然后选择第一个能够在目标平台上运行的SubShader。</p> 
<p>Unity之所以要提供这样的语义，是由于不同显卡支持的指令数不同，我们希望在旧显卡上使用计算复杂度较低的着色器，在高级显卡上使用计算复杂度较高的着色器。</p> 
<p>SubShader语句块的定义如下：</p> 
<pre><code class="prism language-c">SubShader <span class="token punctuation">{<!-- --></span> 
	<span class="token comment">//可选的</span>
	<span class="token punctuation">[</span>Tags<span class="token punctuation">]</span> 
	<span class="token comment">//可选的</span>
	<span class="token punctuation">[</span>RenderSetup<span class="token punctuation">]</span>
	Pass <span class="token punctuation">{<!-- --></span> 
	<span class="token punctuation">}</span>
	<span class="token comment">// Other Passes</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>SubShader定义了一系列<strong>Pass</strong>以及可选的<strong>状态（[RenderSetup])</strong> 和<strong>标签([Tags])</strong> 设置，每个Pass都定义了一次完整的渲染流程，如果我们定义了多个Pass，那么渲染时每帧的效果也需要经过多次Pass的渲染，也就是要经历多次渲染流程。</p> 
<p>因此，如果Pass的数量过多，往往会造成渲染性能的下降。因此，我们应尽量使用数目少的Pass（除非真的有必要定义多个Pass）。</p> 
<p>标签和状态同样可以在Pass中声明。不同的是，SubShader中的一些标签设置是特定的，这些特定的标签设置与在Pass中使用的标签是不一样的，虽然语法相同，但是如果我们在SubShader中进行了这些标签设置，那么它们将会作用与所有Pass。（类似全局变量与局部变量?)</p> 
<h4><a id="RenderSetup_204"></a>状态（[RenderSetup])</h4> 
<center>
  常见的渲染状态设置选项 
</center> 
<table><thead><tr><th align="left">状态名称</th><th align="left">设置指令</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">Cull</td><td align="left">Cull Back | Front | Off</td><td align="left">设置剔除模式：剔除背面/正面/关闭剔除</td></tr><tr><td align="left">ZTest</td><td align="left">ZTest Less Greater |LEqual |GEqual | Equal | NotEqual | Always</td><td align="left">设置深度测试时使用的函数</td></tr><tr><td align="left">ZWrite</td><td align="left">ZWrite On | Off</td><td align="left">开启/关闭深度写入</td></tr><tr><td align="left">Blend</td><td align="left">Blend SrcFactor DstFactor</td><td align="left">开启并设置混合模式</td></tr></tbody></table> 
<p>若在SubShader中设置了上述渲染状态，则会应用到所有的Pass，如果我们不想影响全局，例如在双面渲染中，我们希望第一个Pass中剔除正面来对背面进行渲染，第二个Pass中剔除背面来对正面进行渲染，我们就应当在不同的Pass块中单独进行上面的设置。</p> 
<p>（我很喜欢这些高级语言的直白性，一条英文指令+中文解释就能很形象地描述这条指令的作用，并且十分好记）</p> 
<h4><a id="SubShaderTag_219"></a>SubShader的标签（Tag）</h4> 
<p>Tag是一个<strong>键值对(Key/Value Pair)</strong>，其键和值都是字符串类型的。这些键值对是SubShader和渲染引擎之间的沟通桥梁，它们告诉Unity的渲染引擎我们希望怎样以及何时渲染这个对象：</p> 
<p>标签的结构如下：</p> 
<pre><code class="prism language-c">Tags <span class="token punctuation">{<!-- --></span> <span class="token string">" TagNamel "</span> <span class="token operator">=</span> <span class="token string">"Valuel "</span> <span class="token string">"TagName2"</span> <span class="token operator">=</span> <span class="token string">"Value2 "</span> <span class="token punctuation">}</span>
</code></pre> 
<center>
  SubShader标签块支持的标签类型如下表所示 
</center> 
<table><thead><tr><th align="left">标签类型</th><th align="left">说明</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">Queue</td><td align="left">控制渲染顺序，指定该物体属于哪一个渲染队列，通过这种方式可以保证所有的透明物体可以在所有不透明物体后面被渲染。我们也可以自定义使用的渲染队列来控制物体的渲染顺序</td><td align="left">Tags {“Queue” = “Transparent“}</td></tr><tr><td align="left">RenderType</td><td align="left">对着色器进行分类，例如这是一个不透明的着色器，或是一个透明的着色器。这可以被用于着色器替换（Shader Replacement）功能。</td><td align="left">Tags {“RenderType” = “Opaque“}</td></tr><tr><td align="left">DisableBatching</td><td align="left">一些SubShader在使用Unity的批处理功能会出现问题，例如使用了模型空间下的坐标进行顶点动画。这时可以通过该标签来直接指明是否对该SubShader使用批处理</td><td align="left">Tags {“DisableBatching" = “True”}</td></tr><tr><td align="left">ForceNoShadowCasting</td><td align="left">控制使用该SubShader的物体是否会投射阴影</td><td align="left">Tags {“ForceNoShadowCasting" = “True”}</td></tr><tr><td align="left">IgnoreProjector</td><td align="left">如果该标签值为“True”，那么使用该SubShader的物体将不会收到Projector（projector指Unity中的投影仪组件）的影响。通常用于半透明物体</td><td align="left">Tags {“IgnoreProjector" = “True”}</td></tr><tr><td align="left">CanUseSpriteAtlas</td><td align="left">当该SubShader是用于Sprite时，将该标签设为“False”</td><td align="left">Tags {“CanUseSpriteAtlas" = “False”}</td></tr><tr><td align="left">PreViewType</td><td align="left">指明材质面板将如何预览该材质。默认情况下，材质将显示为一个球，我们可以通过把该标签的值设为"Plane""SkyBox"来改变预览类型</td><td align="left">Tags {“PreViewType" = “Plane”}</td></tr></tbody></table> 
<p>具体的标签设置我们会在后文中学习。<br> 需要注意，上述标签仅可以在SubShader中声明，而不可以在Pass块中声明。Pass块虽然也可以定义标签，但这些标签是不同于SubShader的标签类型。</p> 
<hr> 
<h4><a id="Pass_246"></a>Pass语义块</h4> 
<p>Pass 语义块包含的语义如下：</p> 
<pre><code class="prism language-c">Pass<span class="token punctuation">{<!-- --></span>
	<span class="token punctuation">[</span>Name<span class="token punctuation">]</span>
	<span class="token punctuation">[</span>Tags<span class="token punctuation">]</span>
	<span class="token punctuation">[</span>RenderSetup<span class="token punctuation">]</span>
	<span class="token comment">//Other code</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>我们可以在语句块中定义该Pass的名称，例如：</p> 
<pre><code class="prism language-c">Name <span class="token string">"MyPassName"</span>
</code></pre> 
<p>通过Pass名，我们可以使用ShaderLab的<strong>UsePass</strong> 命令来直接使用其他Unity Shader的Pass块：</p> 
<pre><code class="prism language-c">Use Pass <span class="token string">"MyShader/MYPASSNAME"</span>
</code></pre> 
<p>这样可以提高代码的复用性。需要注意的是，由于Unity 内部会把所有 Pass 的名称转换成大写字母，因此在使用 UsePass命令时必须使用大写全拼的名字。</p> 
<p>（哈哈，这不是我们面向对象编程的类函数方法调用吗，下次使用记得标明出处)</p> 
<p>其次，我们也可以对Pass设置渲染状态，SubShader的状态设置同样适用于Pass。除了上述提到的状态设置外，在Pass块中我们还可以使用固定管线的着色器命令（谁用啊）。</p> 
<p>Pass 同样可以设置标签 但它的标签不同于 SubShader 的标签。这些标签也是用于告诉渲染引擎我们希望怎样来渲染该物体。</p> 
<center>
  Pass的标签类型 
</center> 
<table><thead><tr><th align="left">标签类型</th><th align="left">说明</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">LightMode</td><td align="left">定义该Pass在Unity的渲染流水线中的角色</td><td align="left">Tags {“LightMode” = “ForwardBase”}</td></tr><tr><td align="left">RequireOptions</td><td align="left">用于指定当满足某些条件时才渲染该Pass，它的值是一个由空格分隔的字符串，目前Unity支持的选项有：SoftVegetation。在后续版本可能增加更多的选项（喜报，根据Unity官方文档，直至2023.2版本依然只有这一个选项）</td><td align="left">Tags {“RequireOptions” = “SoftVegetation”}</td></tr></tbody></table> 
<p>除了上述普通的Pass定义外，Unity Shader还支持一些特殊的Pass，以进行代码复用或实现更复杂的效果：</p> 
<ul><li><strong>UsePass</strong>，之前提到了，可以使用该命令来复用其他Unity Shader 的Pass</li><li><strong>GrabPass</strong>，该Pass负责抓起屏幕并将结果存储在一张纹理中，以用于后续的Pass处理（这个好，类似于后处理了）</li></ul> 
<hr> 
<h4><a id="Fallback_292"></a>后路：Fallback</h4> 
<p>最后，当我们写完SubShader块定义后，我们可以追加一个<strong>Fallback</strong>（失败回滚）指令，它用于告诉Unity：“如果上面定义的所有SubShader块都无法在显卡上运行，那就使用这个最低级的Shader吧！”</p> 
<p>（就像是ShaderLab中的Try Catch语法一样，Catch到错误后抛出异常并处理）</p> 
<p>语义如下：</p> 
<pre><code class="prism language-c">Fallback <span class="token string">"Name"</span>
<span class="token comment">// 或者</span>
Fallback Off
</code></pre> 
<p>我们可以根据Name字符串来指定这个最低级的Unity Shader是谁（注意这里的Name指的并不是Pass，也不是SubShader，而是一个Unity Shader的Name！）。当然我们也可以用<code>Fallback Off</code>关闭，关闭了之后即使失败引擎也不管它了。</p> 
<pre><code class="prism language-c"><span class="token comment">// 最常见的Fallback Shader</span>
Fallback <span class="token string">"VertexLit"</span>
</code></pre> 
<p>事实上，Fallback还会影响到阴影的投射。在渲染阴影纹理的时候，Unity会在每个Unity Shader中寻找一个阴影投射的Pass。通常情况下我们不需要自己专门实现一个Pass，这是由于Fallback使用的内置Shader中包含了这样一个通用的Pass。如果我们Fallback使用的Shader没有阴影渲染的Pass的话那就使得阴影渲染出问题了。</p> 
<p>因此，为每个Unity Shader正确设置Fallback也是非常重要的。</p> 
<hr> 
<h4><a id="ShaderLab_319"></a>ShaderLab的其他语义</h4> 
<p>除了上述语义，ShaderLab还有一些不常用的语义。如果我们不满足于Unity内置的属性类型，想要自定义材质面板的编辑界面，就可以使用<strong>CustomEditor</strong>语义来扩展编辑界面。我们还可以用<strong>Category</strong>来对Unity Shader中的命令进行分组。书中对这二者并未详细讲解，如果后续学习中涉及到了再展开来讲吧。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a08ae549de5a724a1926202e41202c91/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">BUU-crypto-刷题记录20</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/030b0e6b84f23cd559a7cc295119657d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">虚幻UE 增强输入-第三人称模板增强输入分析与扩展</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>