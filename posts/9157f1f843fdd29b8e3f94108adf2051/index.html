<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>让人头痛事务问题到底要如何解决？ - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="让人头痛事务问题到底要如何解决？" />
<meta property="og:description" content="前言 正好前段时间我在公司处理过这个问题，我们当时由于项目初期时间比较紧张，为了快速完成业务功能，忽略了系统部分性能问题。项目顺利上线后，专门抽了一个迭代的时间去解决大事务问题，目前已经优化完成，并且顺利上线。现给大家总结了一下，我们当时使用的一些解决办法，以便大家被相同问题困扰时，可以参考一下。
大事务引发的问题 在分享解决办法之前，先看看系统中如果出现大事务可能会引发哪些问题
从上图可以看出如果系统中出现大事务时，问题还不小，所以我们在实际项目开发中应该尽量避免大事务的情况。如果我们已有系统中存在大事务问题，该如何解决呢？
解决办法 少用@Transactional注解 大家在实际项目开发中，我们在业务方法加上@Transactional注解开启事务功能，这是非常普遍的做法，它被称为声明式事务。
部分代码如下：
@Transactional(rollbackFor=Exception.class) public void save(User user) { doSameThing... } 然而，我要说的第一条是：少用@Transactional注解。
为什么？
我们知道@Transactional注解是通过spring的aop起作用的，但是如果使用不当，事务功能可能会失效。如果恰巧你经验不足，这种问题不太好排查。至于事务哪些情况下会失效。
@Transactional注解一般加在某个业务方法上，会导致整个业务方法都在同一个事务中，粒度太粗，不好控制事务范围，是出现大事务问题的最常见的原因。
那我们该怎么办呢？
可以使用编程式事务，在spring项目中使用TransactionTemplate类的对象，手动执行事务。
部分代码如下：
@Autowired private TransactionTemplate transactionTemplate; ... public void save(final User user) { transactionTemplate.execute((status) =&gt; { doSameThing... return Boolean.TRUE; }) } 从上面的代码中可以看出，使用TransactionTemplate的编程式事务功能自己灵活控制事务的范围，是避免大事务问题的首选办法。
当然，我说少使用@Transactional注解开启事务，并不是说一定不能用它，如果项目中有些业务逻辑比较简单，而且不经常变动，使用@Transactional注解开启事务开启事务也无妨，因为它更简单，开发效率更高，但是千万要小心事务失效的问题。
将查询(select)方法放到事务外 如果出现大事务，可以将查询(select)方法放到事务外，也是比较常用的做法，因为一般情况下这类方法是不需要事务的。
比如出现如下代码：
@Transactional(rollbackFor=Exception.class) public void save(User user) { queryData1(); queryData2(); addData1(); updateData2(); } 可以将queryData1和queryData2两个查询方法放在事务外执行，将真正需要事务执行的代码才放到事务中，比如：addData1和updateData2方法，这样就能有效的减少事务的粒度。
如果使用TransactionTemplate的编程式事务这里就非常好修改。
@Autowired private TransactionTemplate transactionTemplate; ... public void save(final User user) { queryData1(); queryData2(); transactionTemplate." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/9157f1f843fdd29b8e3f94108adf2051/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-06T09:42:33+08:00" />
<meta property="article:modified_time" content="2024-01-06T09:42:33+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">让人头痛事务问题到底要如何解决？</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <h3>前言</h3> 
</blockquote> 
<p>正好前段时间我在公司处理过这个问题，我们当时由于项目初期时间比较紧张，为了快速完成业务功能，忽略了系统部分性能问题。项目顺利上线后，专门抽了一个迭代的时间去解决大事务问题，目前已经优化完成，并且顺利上线。现给大家总结了一下，我们当时使用的一些解决办法，以便大家被相同问题困扰时，可以参考一下。</p> 
<blockquote> 
 <h3>大事务引发的问题</h3> 
</blockquote> 
<p>在分享解决办法之前，先看看系统中如果出现大事务可能会引发哪些问题</p> 
<p> </p> 
<p><img src="https://images2.imgbox.com/a5/e4/jF6jkw3A_o.png" alt="8cff5da48680d9e97df61535fa086a2f.png"></p> 
<p>从上图可以看出如果系统中出现大事务时，问题还不小，所以我们在实际项目开发中应该尽量避免大事务的情况。如果我们已有系统中存在大事务问题，该如何解决呢？</p> 
<blockquote> 
 <h3>解决办法</h3> 
 <h4>少用@Transactional注解</h4> 
</blockquote> 
<p>大家在实际项目开发中，我们在业务方法加上<code>@Transactional</code>注解开启事务功能，这是非常普遍的做法，它被称为<code>声明式事务</code>。</p> 
<p>部分代码如下：</p> 
<pre><code class="language-java">@Transactional(rollbackFor=Exception.class)
   public void save(User user) {
         doSameThing...
   }
</code></pre> 
<p>然而，我要说的第一条是：少用<code>@Transactional</code>注解。</p> 
<p>为什么？</p> 
<ol><li> <p>我们知道<code>@Transactional</code>注解是通过<code>spring</code>的<code>aop</code>起作用的，但是如果使用不当，事务功能可能会失效。如果恰巧你经验不足，这种问题不太好排查。至于事务哪些情况下会失效。</p> </li><li> <p><code>@Transactional</code>注解一般加在某个业务方法上，会导致整个业务方法都在同一个事务中，粒度太粗，不好控制事务范围，是出现大事务问题的最常见的原因。</p> </li></ol> 
<p>那我们该怎么办呢？</p> 
<p>可以使用<code>编程式事务</code>，在<code>spring</code>项目中使用<code>TransactionTemplate</code>类的对象，手动执行事务。</p> 
<p>部分代码如下：</p> 
<pre><code class="language-java">   @Autowired
   private TransactionTemplate transactionTemplate;
   
   ...
   
   public void save(final User user) {
         transactionTemplate.execute((status) =&gt; {
            doSameThing...
            return Boolean.TRUE;
         })
   }
</code></pre> 
<p>从上面的代码中可以看出，使用<code>TransactionTemplate</code>的<code>编程式事务</code>功能自己灵活控制事务的范围，是避免大事务问题的首选办法。</p> 
<p>当然，我说少使用<code>@Transactional</code>注解开启事务，并不是说一定不能用它，如果项目中有些业务逻辑比较简单，而且不经常变动，使用<code>@Transactional</code>注解开启事务开启事务也无妨，因为它更简单，开发效率更高，但是千万要小心事务失效的问题。</p> 
<blockquote> 
 <h4>将查询(select)方法放到事务外</h4> 
</blockquote> 
<p>如果出现大事务，可以将查询(select)方法放到事务外，也是比较常用的做法，因为一般情况下这类方法是不需要事务的。</p> 
<p>比如出现如下代码：</p> 
<pre><code class="language-java">@Transactional(rollbackFor=Exception.class)
   public void save(User user) {
         queryData1();
         queryData2();
         addData1();
         updateData2();
   }
</code></pre> 
<p>可以将<code>queryData1</code>和<code>queryData2</code>两个查询方法放在事务外执行，将真正需要事务执行的代码才放到事务中，比如：<code>addData1</code>和<code>updateData2</code>方法，这样就能有效的减少事务的粒度。</p> 
<p>如果使用<code>TransactionTemplate</code>的<code>编程式事务</code>这里就非常好修改。</p> 
<pre><code class="language-java">   @Autowired
   private TransactionTemplate transactionTemplate;
   
   ...
   
   public void save(final User user) {
         queryData1();
         queryData2();
         transactionTemplate.execute((status) =&gt; {
            addData1();
            updateData2();
            return Boolean.TRUE;
         })
   }
</code></pre> 
<p>但是如果你实在还是想用<code>@Transactional</code>注解，该怎么拆分呢？</p> 
<pre><code class="language-java">public void save(User user) {
         queryData1();
         queryData2();
         doSave();
    }
   
    @Transactional(rollbackFor=Exception.class)
    public void doSave(User user) {
       addData1();
       updateData2();
    }
</code></pre> 
<p>这个例子是非常经典的错误，这种直接方法调用的做法事务不会生效，给正在坑中的朋友提个醒。因为<code>@Transactional</code>注解的声明式事务是通过<code>spring aop</code>起作用的，而<code>spring aop</code>需要生成代理对象，直接方法调用使用的还是原始对象，所以事务不会生效。</p> 
<p>有没有办法解决这个问题呢？</p> 
<p>1.新加一个Service方法</p> 
<p>这个方法非常简单，只需要新加一个Service方法，把<code>@Transactional</code>注解加到新Service方法上，把需要事务执行的代码移到新方法中。具体代码如下：</p> 
<pre><code class="language-java">@Servcie
  publicclass ServiceA {
     @Autowired
     prvate ServiceB serviceB;
  
     public void save(User user) {
           queryData1();
           queryData2();
           serviceB.doSave(user);
     }
   }
   
   @Servcie
   publicclass ServiceB {
   
      @Transactional(rollbackFor=Exception.class)
      public void doSave(User user) {
         addData1();
         updateData2();
      }
   
   }
</code></pre> 
<p>2.在该Service类中注入自己</p> 
<p>如果不想再新加一个Service类，在该Service类中注入自己也是一种选择。具体代码如下：</p> 
<pre><code class="language-java">@Servcie
  publicclass ServiceA {
     @Autowired
     prvate ServiceA serviceA;
  
     public void save(User user) {
           queryData1();
           queryData2();
           serviceA.doSave(user);
     }
     
     @Transactional(rollbackFor=Exception.class)
     public void doSave(User user) {
         addData1();
         updateData2();
      }
   }
</code></pre> 
<p>可能有些人可能会有这样的疑问：这种做法会不会出现循环依赖问题？</p> 
<p>其实<code>spring ioc</code>内部的三级缓存保证了它，不会出现循环依赖问题。如果你想进一步了解循环依赖问题。</p> 
<p>3.在该Service类中使用AopContext.currentProxy()获取代理对象</p> 
<p>上面的方法2确实可以解决问题，但是代码看起来并不直观，还可以通过在该Service类中使用AOPProxy获取代理对象，实现相同的功能。具体代码如下：</p> 
<pre><code class="language-java">@Servcie
  publicclass ServiceA {
  
     public void save(User user) {
           queryData1();
           queryData2();
           ((ServiceA)AopContext.currentProxy()).doSave(user);
     }
     
     @Transactional(rollbackFor=Exception.class)
     public void doSave(User user) {
         addData1();
         updateData2();
      }
   }
</code></pre> 
<blockquote> 
 <h4>事务中避免远程调用</h4> 
</blockquote> 
<p>我们在接口中调用其他系统的接口是不能避免的，由于网络不稳定，这种远程调的响应时间可能比较长，如果远程调用的代码放在某个事物中，这个事物就可能是大事务。当然，远程调用不仅仅是指调用接口，还有包括：发MQ消息，或者连接redis、mongodb保存数据等。</p> 
<pre><code class="language-java">@Transactional(rollbackFor=Exception.class)
   public void save(User user) {
         callRemoteApi();
         addData1();
   }
</code></pre> 
<p>远程调用的代码可能耗时较长，切记一定要放在事务之外。</p> 
<pre><code class="language-java">   @Autowired
   private TransactionTemplate transactionTemplate;
   
   ...
   
   public void save(final User user) {
         callRemoteApi();
         transactionTemplate.execute((status) =&gt; {
            addData1();
            return Boolean.TRUE;
         })
   }
</code></pre> 
<p>有些朋友可能会问，远程调用的代码不放在事务中如何保证数据一致性呢？这就需要建立：<code>重试</code>+<code>补偿机制</code>，达到数据<code>最终一致性</code>了。</p> 
<blockquote> 
 <h4>事务中避免一次性处理太多数据</h4> 
</blockquote> 
<p>如果一个事务中需要处理的数据太多，也会造成大事务问题。比如为了操作方便，你可能会一次批量更新1000条数据，这样会导致大量数据锁等待，特别在高并发的系统中问题尤为明显。</p> 
<p>解决办法是分页处理，1000条数据，分50页，一次只处理20条数据，这样可以大大减少大事务的出现。</p> 
<blockquote> 
 <h4>非事务执行</h4> 
</blockquote> 
<p>在使用事务之前，我们都应该思考一下，是不是所有的数据库操作都需要在事务中执行？</p> 
<pre><code class="language-java">   @Autowired
   private TransactionTemplate transactionTemplate;
   
   ...
   
   public void save(final User user) {
         transactionTemplate.execute((status) =&gt; {
            addData();
            addLog();
            updateCount();
            return Boolean.TRUE;
         })
   }
</code></pre> 
<p>上面的例子中，其实<code>addLog</code>增加操作日志方法 和 <code>updateCount</code>更新统计数量方法，是可以不在事务中执行的，因为操作日志和统计数量这种业务允许少量数据不一致的情况。</p> 
<pre><code class="language-java">   @Autowired
   private TransactionTemplate transactionTemplate;
   
   ...
   
   public void save(final User user) {
         transactionTemplate.execute((status) =&gt; {
            addData();           
            return Boolean.TRUE;
         })
         addLog();
         updateCount();
   }
</code></pre> 
<p>当然大事务中要鉴别出哪些方法可以非事务执行，其实没那么容易，需要对整个业务梳理一遍，才能找出最合理的答案。</p> 
<blockquote> 
 <h4>异步处理</h4> 
</blockquote> 
<p>还有一点也非常重要，是不是事务中的所有方法都需要同步执行？我们都知道，方法同步执行需要等待方法返回，如果一个事务中同步执行的方法太多了，势必会造成等待时间过长，出现大事务问题。</p> 
<p>看看下面这个列子：</p> 
<pre><code class="language-java">   @Autowired
   private TransactionTemplate transactionTemplate;
   
   ...
   
   public void save(final User user) {
         transactionTemplate.execute((status) =&gt; {
            order();
            delivery();
            return Boolean.TRUE;
         })
   }
</code></pre> 
<p><code>order</code>方法用于下单，<code>delivery</code>方法用于发货，是不是下单后就一定要马上发货呢？</p> 
<p>答案是否定的。</p> 
<p>这里发货功能其实可以走mq异步处理逻辑。</p> 
<pre><code class="language-java">   @Autowired
   private TransactionTemplate transactionTemplate;
   
   ...
   
   public void save(final User user) {
         transactionTemplate.execute((status) =&gt; {
            order();
            return Boolean.TRUE;
         })
         sendMq();
   }
</code></pre> 
<blockquote> 
 <h3>总结</h3> 
</blockquote> 
<p>本人从网友的一个问题出发，结合自己实际的工作经验分享了处理大事务的6种办法：</p> 
<ol><li> <p>少用@Transactional注解</p> </li><li> <p>将查询(select)方法放到事务外</p> </li><li> <p>事务中避免远程调用</p> </li><li> <p>事务中避免一次性处理太多数据</p> </li><li> <p>非事务执行</p> </li><li> <p>异步处理</p> </li></ol> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dcc898e53b2cdd1afbf04fc43b6f80cc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">网络调试 TCP，开发板用静态地址-入门7</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ea4814ea73f1e1bacba5bfdd4ce725a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">金和OA C6 UploadFileEditorSave.aspx 任意文件上传漏洞</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>