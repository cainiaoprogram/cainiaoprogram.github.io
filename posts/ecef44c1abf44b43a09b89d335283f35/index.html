<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据库拾遗 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据库拾遗" />
<meta property="og:description" content="本文整理自剑指Java面试-Offer直通车
如何设计一个关系型数据库
存储
文件系统
程序实例
存储管理
IO效率极低，所以数据库中的行在存储中没有实际意义，一般都是按块或页存储，一次IO读取多行数据
缓存机制
一旦某行数据被访问了，它周围的数据也极有可能被访问
缓存不宜过大，要有淘汰机制
SQL解析
将SQL编译解析，翻译成机器可识别的指令
缓存
日志管理
权限划分
多用户管理
容灾机制
从错误中恢复
索引管理
锁管理
为什么要使用索引
如果不使用索引，数据库会进行全表扫描，使用索引是为了尽量避免全表扫描，加快查询速度
全表扫描在数据量少的表中，查询效率反而更快
索引的灵感来自于字典
什么样的信息能成为索引
能把该记录限定在一定查找范围内的字段，即关键信息，如主键
主键、唯一键以及普通键等
索引的数据结构
平衡二叉树（不适合）
平衡二叉树查找效率为O(logn)
检索深度每加一，都要进行一次IO，严重影响查询效率
数据库的数据经过增删后，很容易变成线性结构，查询效率为O(n)
可通过树的旋转特性，使树保持为平衡二叉树 B-Tree（平衡多路查找树，不适合）
为了减少IO，需要把平衡二叉树变矮，使每个节点存储的数据变多，则成为了B-Tree
查找效率为O(logn)
与平衡二叉树相比，B-Tree可以通过合并、上移下移节点等保持结构
B&#43;-Tree（适合，常用）
是对B-Tree优化后的一种数据类型，所有数据存在叶子节点中，非叶子节点只存储关键字，会比B-Tree更矮
叶子节点有链指针指向下一个叶子节点，可横向做统计
B&#43;-Tree更适合来做存储索引
磁盘读写代价更低（数据都在叶子节点中，一次读取的索引更多）
查找效率更加稳定（非叶子节点只存索引，所有数据走的路径一样，效率O(logn)）
有利于数据库的扫描（链指针）
Hash（小众）
缺点
仅能满足“=”，“IN”，不能使用范围查询
无法被用来避免数据的排序操作
不能利用部分索引建查询（组合索引中的某个索引，B&#43;-Tree支持）
不能避免表扫描
遇到大量Hash值相等的情况后，性能并不一定比B-Tree索引高
BitMap（位图）索引
Oracle支持，MySQL不支持
只有几种值的情况（如性别），效率很高
新增修改的时候，通常会把同一个位图的数据都锁住
密集索引和稀疏索引的区别
密集索引文件中的每个搜索码值都对应一个索引值
叶子节点保存的不止是键值，还保存了位于同一行的其他列的信息
由于密集索引决定了表的物理排列顺序，一个表只能有一个密集索引
稀疏索引文件只为索引码的某些值建立索引项
叶子节点仅保存了键位信息以及该行数据的地址
有的稀疏索引仅保存了键位信息及其主键
定位到叶子节点后，还需要通过其中的信息，进一步定位到数据
MySQL中的InnoDB（聚簇）
必须定义一个密集索引
若一个逐渐被定义，则该主键座位密集索引
若没有主键被定义，则该表的第一个唯一非空索引作为密集索引
若不满足以上条件，InnoDB内部会生成一个隐藏主键（密集索引）
MySQL中的MyISAM（非聚簇）" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ecef44c1abf44b43a09b89d335283f35/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-12-23T18:40:35+08:00" />
<meta property="article:modified_time" content="2018-12-23T18:40:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据库拾遗</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <ul><li> <p>本文整理自<a href="https://coding.imooc.com/class/303.html" rel="nofollow">剑指Java面试-Offer直通车</a></p> </li><li> <p>如何设计一个关系型数据库</p> 
  <ul><li> <p>存储</p> 
    <ul><li> <p>文件系统</p> </li></ul></li><li> <p>程序实例</p> 
    <ul><li> <p>存储管理</p> 
      <ul><li> <p>IO效率极低，所以数据库中的行在存储中没有实际意义，一般都是按块或页存储，一次IO读取多行数据</p> </li></ul></li><li> <p>缓存机制</p> 
      <ul><li> <p>一旦某行数据被访问了，它周围的数据也极有可能被访问</p> </li><li> <p>缓存不宜过大，要有淘汰机制</p> </li></ul></li><li> <p>SQL解析</p> 
      <ul><li> <p>将SQL编译解析，翻译成机器可识别的指令</p> </li><li> <p>缓存</p> </li></ul></li><li> <p>日志管理</p> </li><li> <p>权限划分</p> 
      <ul><li> <p>多用户管理</p> </li></ul></li><li> <p>容灾机制</p> 
      <ul><li> <p>从错误中恢复</p> </li></ul></li><li> <p>索引管理</p> </li><li> <p>锁管理</p> </li></ul></li></ul></li><li> <p>为什么要使用索引</p> 
  <ul><li> <p>如果不使用索引，数据库会进行全表扫描，使用索引是为了尽量避免全表扫描，加快查询速度</p> 
    <ul><li> <p>全表扫描在数据量少的表中，查询效率反而更快</p> </li><li> <p>索引的灵感来自于字典</p> </li></ul></li></ul></li><li> <p>什么样的信息能成为索引</p> 
  <ul><li> <p>能把该记录限定在一定查找范围内的字段，即关键信息，如主键</p> </li><li> <p>主键、唯一键以及普通键等</p> </li></ul></li><li> <p>索引的数据结构</p> 
  <ul><li> <p>平衡二叉树（不适合）</p> 
    <ul><li> <p>平衡二叉树查找效率为O(logn)</p> 
      <ul><li> <p>检索深度每加一，都要进行一次IO，严重影响查询效率</p> </li></ul></li><li> <p>数据库的数据经过增删后，很容易变成线性结构，查询效率为O(n)</p> 
      <ul><li> <p>可通过树的旋转特性，使树保持为平衡二叉树 </p> </li></ul></li><li> <p><img alt="" class="has" height="300" src="https://images2.imgbox.com/3f/2d/p2CX0TkX_o.png" width="376"></p> </li></ul></li><li> <p>B-Tree（平衡多路查找树，不适合）</p> 
    <ul><li> <p>为了减少IO，需要把平衡二叉树变矮，使每个节点存储的数据变多，则成为了B-Tree</p> </li><li> <p>查找效率为O(logn)</p> </li><li> <p>与平衡二叉树相比，B-Tree可以通过合并、上移下移节点等保持结构</p> </li><li> <p><img alt="" class="has" height="320" src="https://images2.imgbox.com/42/2c/XTvmzEkM_o.png" width="531"></p> </li></ul></li><li> <p>B+-Tree（适合，常用）</p> 
    <ul><li> <p>是对B-Tree优化后的一种数据类型，所有数据存在叶子节点中，非叶子节点只存储关键字，会比B-Tree更矮</p> </li><li> <p>叶子节点有链指针指向下一个叶子节点，可横向做统计</p> </li><li> <p>B+-Tree更适合来做存储索引</p> 
      <ul><li> <p>磁盘读写代价更低（数据都在叶子节点中，一次读取的索引更多）</p> </li><li> <p>查找效率更加稳定（非叶子节点只存索引，所有数据走的路径一样，效率O(logn)）</p> </li><li> <p>有利于数据库的扫描（链指针）</p> </li></ul></li><li> <p><img alt="" class="has" height="333" src="https://images2.imgbox.com/05/ab/4OvWLB1A_o.png" width="543"></p> </li></ul></li><li> <p>Hash（小众）</p> 
    <ul><li> <p>缺点</p> 
      <ul><li> <p>仅能满足“=”，“IN”，不能使用范围查询</p> </li><li> <p>无法被用来避免数据的排序操作</p> </li><li> <p>不能利用部分索引建查询（组合索引中的某个索引，B+-Tree支持）</p> </li><li> <p>不能避免表扫描</p> </li><li> <p>遇到大量Hash值相等的情况后，性能并不一定比B-Tree索引高</p> </li></ul></li><li> <p><img alt="" class="has" height="338" src="https://images2.imgbox.com/ab/09/X92BuAH5_o.png" width="542"></p> </li></ul></li><li> <p>BitMap（位图）索引</p> 
    <ul><li> <p>Oracle支持，MySQL不支持</p> </li><li> <p>只有几种值的情况（如性别），效率很高</p> </li><li> <p>新增修改的时候，通常会把同一个位图的数据都锁住</p> </li><li> <p><img alt="" class="has" height="403" src="https://images2.imgbox.com/e8/cf/3Sc7qs9D_o.png" width="551"></p> </li></ul></li></ul></li><li> <p>密集索引和稀疏索引的区别</p> 
  <ul><li> <p>密集索引文件中的每个搜索码值都对应一个索引值</p> 
    <ul><li> <p>叶子节点保存的不止是键值，还保存了位于同一行的其他列的信息</p> </li><li> <p>由于密集索引决定了表的物理排列顺序，一个表只能有一个密集索引</p> </li><li> <p><img alt="" class="has" height="247" src="https://images2.imgbox.com/5e/27/1rzN7cyl_o.png" width="506"></p> </li></ul></li><li> <p>稀疏索引文件只为索引码的某些值建立索引项</p> 
    <ul><li> <p>叶子节点仅保存了键位信息以及该行数据的地址</p> </li><li> <p>有的稀疏索引仅保存了键位信息及其主键</p> </li><li> <p>定位到叶子节点后，还需要通过其中的信息，进一步定位到数据</p> </li><li> <p><img alt="" class="has" height="390" src="https://images2.imgbox.com/87/60/EqEXYMeV_o.png" width="456"></p> </li></ul></li><li> <p>MySQL中的InnoDB（聚簇）</p> 
    <ul><li> <p>必须定义一个密集索引</p> 
      <ul><li> <p>若一个逐渐被定义，则该主键座位密集索引</p> </li><li> <p>若没有主键被定义，则该表的第一个唯一非空索引作为密集索引</p> </li><li> <p>若不满足以上条件，InnoDB内部会生成一个隐藏主键（密集索引）</p> </li></ul></li><li> <p><img alt="" class="has" height="378" src="https://images2.imgbox.com/d3/8b/XTUf8k64_o.png" width="400"></p> </li></ul></li><li> <p>MySQL中的MyISAM（非聚簇）</p> 
    <ul><li> <p>使用了稀疏索引</p> </li><li> <p><img alt="" class="has" height="350" src="https://images2.imgbox.com/fe/7a/X87ohWWU_o.png" width="391"></p> </li></ul></li></ul></li><li> <p>如何定位并优化慢SQL</p> 
  <ul><li> <p>根据慢日志定位慢查询SQL </p> 
    <ul><li> <p>show variables like '%query%'</p> 
      <ul><li> <p>slow_query_log</p> 
        <ul><li> <p>set global slow_query_log = ON</p> </li></ul></li><li> <p>slow_query_log_file</p> 
        <ul><li> <p>慢SQL日志地址，慢SQL会写入此中</p> </li></ul></li><li> <p>long_query_time</p> 
        <ul><li> <p>查询时间大于此值，则属于慢SQL</p> </li><li> <p>set global long_query_time = 1</p> 
          <ul><li> <p>默认10秒太长</p> </li><li> <p>需要重新连接客户端</p> </li></ul></li></ul></li></ul></li><li> <p>show status like '%slow_queries%'</p> 
      <ul><li> <p>本次回话的慢查询执行次数</p> </li></ul></li></ul></li><li> <p>使用explain等工具分析SQL</p> 
    <ul><li> <p>直接加在查询语句前面</p> </li><li> <p>type，从最优到最差</p> 
      <ul><li> <p>system,const,eq_ref,ref,fulltext,ref_or_null,index_merge,unique_subquery,index_subquery,range,index,all</p> 
        <ul><li> <p>一般情况下，如果是index和all，则表示语句需要优化</p> </li></ul></li></ul></li><li> <p>extra，出现以下2项意味着MySQL根本不能使用索引，效率会受到重大影响，有可能需要优化语句</p> 
      <ul><li> <p>Using filesort</p> 
        <ul><li> <p>表示MySQL会对结果使用一个外部索引排序，而不是从表里按索引次序读到相关内容</p> </li><li> <p>可能在内存或者磁盘上进行排序</p> </li><li> <p>MySQL无法利用索引完成的排序操作称为“文件排序”</p> </li></ul></li><li> <p>Using temporary</p> 
        <ul><li> <p>表示MySQL在对查询结果排序时使用临时表。常见于排序order by和分组查询group by</p> </li></ul></li></ul></li></ul></li><li> <p>修改SQL或者尽量让SQL走索引</p> 
    <ul><li> <p>MySQL的查询优化器有时候并非最优结果，可以使用force index语法指定合适的索引</p> </li></ul></li></ul></li><li> <p>联合索引的最左匹配原则的成因</p> 
  <ul><li> <p>联合索引中，如A_B组成联合索引，where A='' and B='' 走索引，where A='' 也走索引，where B='' 则不会走索引</p> </li><li> <p>MySQL会一直向右匹配知道遇到范围查询（&gt;,&lt;,between,like）就停止匹配</p> 
    <ul><li> <p>如，a = 3 and b = 4 and c &gt; 5 and d = 6</p> 
      <ul><li> <p>如果建立（a,b,c,d）顺序的索引，d是用不到索引的</p> </li><li> <p>如果建立（a,b,d,c）的索引，则都可以用到，a,b,d的顺序可以任意调整</p> </li></ul></li></ul></li><li> <p>联合索引中，=和in可以乱序</p> 
    <ul><li> <p>如，a=1 and b =2 and c = 3 建立（a,b,c）联合索引可以任意顺序，MySQL的查询优化器会优化成索引可以识别的形式 </p> </li></ul></li><li> <p>  如下图，建立索引（col3,col2），MySQL会根据第一个字段，建立一个B+-Tree，因此使用此索引，必须要遵循最左匹配原则</p> </li><li> <p><img alt="" class="has" height="309" src="https://images2.imgbox.com/88/fc/3EcPHAi9_o.png" width="714"></p> </li></ul></li><li> <p>索引是建立的越多越好吗</p> 
  <ul><li> <p>不是</p> </li><li> <p>数据量小的表不需要建立索引，建立索引会增加额外的索引开销</p> </li><li> <p>数据变更需要维护索引，因此更多的索引意味着更多的维护成本</p> </li><li> <p>更多的索引意味着需要更多的空间</p> </li></ul></li><li> <p>MyISAM与InnoDB关于锁方面的区别是什么</p> 
  <ul><li> <p>读锁与写锁</p> 
    <ul><li> <p>读锁</p> 
      <ul><li> <p>读锁未释放时，无法再加上写锁</p> </li><li> <p>读锁又称共享锁，一个表可以同时加上多个读锁</p> </li><li> <p>lock tables 表名 read; -&gt; 手动给表加上读锁，unlock tables; -&gt; 释放锁</p> </li><li> <p>在select后面加上lock in share mode也可以加上共享锁</p> </li></ul></li><li> <p>写锁</p> 
      <ul><li> <p>写锁未释放时，无法再加上读锁</p> </li><li> <p>写锁又称排它锁，不能同时拥有多个</p> </li><li> <p>在select后面加上for update关键字，可以加上排它锁</p> </li></ul></li></ul></li><li> <p>MyISAM</p> 
    <ul><li> <p>默认用的是表级锁，不支持行级锁</p> 
      <ul><li> <p>如，查询ID在1和2000000之间的数据时，对ID等于2000001的数据进行更新，更新会等待查询完成</p> </li></ul></li><li> <p>不支持事务</p> </li><li> <p>当Select时，MyISAM引擎会为查询的表加上表级别的读锁</p> </li><li> <p>当Insert,Update,Delete时，MyISAM引擎会为增删改的表加上表级别的写锁</p> </li><li> <p>适合的场景</p> 
      <ul><li> <p>频繁执行全表count语句，MyISAM用一个变量保存了表的行数，count时取出即可</p> </li><li> <p>对数据进行增删改的频率不高，查询非常频繁时</p> </li><li> <p>没有事务</p> </li></ul></li></ul></li><li> <p>InnoDB</p> 
    <ul><li> <p>默认用的是行级锁，也支持表级锁</p> 
      <ul><li> <p>SQL语句用到索引才会加行级锁，否则加表级锁</p> </li></ul></li><li> <p>支持事务</p> 
      <ul><li> <p>MySQL默认事务自动提交</p> 
        <ul><li> <p>show variables like 'autocommit';</p> </li><li> <p>set autocommit = 0; -- 关闭自动提交，只针对当前session</p> </li><li> <p>set autocommit = 1; -- 开启自动提交，只针对当前session</p> </li><li> <p>或使用begin transaction，手动控制事务</p> </li></ul></li></ul></li><li> <p>当操作一行数据时，行级锁不会影响另一行数据的操作</p> </li><li> <p>适合的场景</p> 
      <ul><li> <p>数据增删改查都相当频繁</p> </li><li> <p>可靠性要求比较高，要求支持事务</p> </li></ul></li></ul></li></ul></li><li> <p>数据库锁的分类</p> 
  <ul><li> <p>按锁的力度划分</p> 
    <ul><li> <p>表级锁</p> </li><li> <p>行级锁</p> </li><li> <p>页级锁</p> </li></ul></li><li> <p>按锁级别划分</p> 
    <ul><li> <p>共享锁</p> </li><li> <p>排它锁</p> </li></ul></li><li> <p>按枷锁方式划分</p> 
    <ul><li> <p>自动锁</p> </li><li> <p>显式锁</p> </li></ul></li><li> <p>按操作划分</p> 
    <ul><li> <p>DML锁</p> </li><li> <p>DDL锁</p> </li></ul></li><li> <p>按使用方式划分</p> 
    <ul><li> <p>乐观锁</p> </li><li> <p>悲观锁</p> </li></ul></li></ul></li><li> <p>数据库事务的四大特性</p> 
  <ul><li> <p>ACID</p> </li><li> <p>原子性（Atomic）</p> 
    <ul><li> <p>事务中的操作，要么全做，要么全不做</p> </li></ul></li><li> <p>一致性（Consistency）</p> 
    <ul><li> <p>事务应确保数据的状态从一个一致的状态，转变到另一个一致的状态</p> </li><li> <p>A和B共有两千元，A向B转账，不管怎么转，最终A和B还是应该有两千元</p> </li></ul></li><li> <p>隔离性（Isolation）</p> 
    <ul><li> <p>多个事务并发执行时，一个事务的执行不应该影响另一个事务的执行</p> </li></ul></li><li> <p>持久性（Durability）</p> 
    <ul><li> <p>一个事务一旦提交，它对数据的修改应该永久保存在数据库</p> </li></ul></li></ul></li><li> <p>事务并发引起的问题及如何避免</p> 
  <ul><li> <p>查看MySQL的事务隔离级别</p> 
    <ul><li> <p>select @@tx_isolation;</p> 
      <ul><li> <p>查询当前会话的事务隔离级别，默认是REPEATABLE-READ，可重复读</p> </li></ul></li><li> <p>set session transaction isolation level  read uncommitted;</p> 
      <ul><li> <p>设置当前会话的事务隔离级别为未提交读</p> </li></ul></li><li> <p>set session transaction isolation level  read committed;</p> 
      <ul><li> <p>设置当前会话的事务隔离级别为提交读</p> </li></ul></li><li> <p>set session transaction isolation level  repeatable read;</p> 
      <ul><li> <p>设置当前会话的事务隔离级别为可重复读</p> </li></ul></li><li> <p>set session transaction isolation level serializable;</p> 
      <ul><li> <p>设置当前会话的事务隔离级别为串行化</p> </li></ul></li></ul></li><li> <p>更新丢失，一个事务的更新覆盖了另一个事务的更新</p> 
    <ul><li> <p><img alt="" class="has" height="287" src="https://images2.imgbox.com/77/b8/QiXyBThC_o.png" width="639"></p> </li></ul></li><li> <p>脏读，一个事务读到另一个事务未提交的数据</p> </li><li> <p>不可重复读，一个事务中，对同一个数据的多次读取值不一致（别的事务对数据进行了更新）</p> </li><li> <p>幻读，事务开启过程中，受到其他事务对新增或删除行的影响，像出现幻觉一样</p> </li><li> <p><img alt="" class="has" height="295" src="https://images2.imgbox.com/92/d9/nQc2gDB6_o.png" width="602"></p> </li></ul></li><li> <p>InnoDB可重复读事务隔离级别下如何避免幻读</p> 
  <ul><li> <p>表象</p> 
    <ul><li> <p>快照读（非阻塞读），伪MVCC</p> </li></ul></li><li> <p>内在</p> 
    <ul><li> <p>next-key锁（行锁+Gap锁）</p> 
      <ul><li> <p>行锁</p> </li><li> <p>Gap锁</p> 
        <ul><li> <p>Gap-&gt;索引中的间隙，锁一个范围</p> </li><li> <p>Gap锁 会用在非唯一索引或者不走索引的当前读中</p> 
          <ul><li> <p>非唯一索引</p> 
            <ul><li> <p>如下图，对所操作的记录周围的Gap上锁，即 (6,9],(9,11] </p> </li><li> <p>主键的值也会对范围产生影响，如插入('bb',6)成功，插入('dd',6)则会判定在Gap锁范围内</p> </li><li> <p><img alt="" class="has" height="402" src="https://images2.imgbox.com/64/c5/gH5kNbc0_o.png" width="426"></p> </li></ul></li><li> <p>不走索引</p> 
            <ul><li> <p>锁住所有Gap，需要避免这种情况</p> </li><li> <p><img alt="" class="has" height="457" src="https://images2.imgbox.com/20/af/L0t1Ok3Z_o.png" width="477"></p> </li></ul></li></ul></li><li> <p>如果where条件全部命中，则不会用Gap锁，只会用记录锁</p> 
          <ul><li> <p><img alt="" class="has" height="480" src="https://images2.imgbox.com/da/6e/HpL8JyAo_o.png" width="529"></p> </li></ul></li><li> <p>如果where条件部分命中或者全不命中，则会加Gap锁</p> </li></ul></li></ul></li></ul></li></ul></li><li> <p>快照读和当前读</p> 
  <ul><li> <p>当前读</p> 
    <ul><li> <p>读取的是数据的最新版本，并且读取后需要保证其他事务不能修改当前记录</p> </li><li> <p>加了锁的增删改查语句，成为当前读</p> 
      <ul><li> <p>select ... lock in share mode</p> </li><li> <p>select ... for update</p> </li><li> <p>update</p> </li><li> <p>delete</p> </li><li> <p>insert</p> </li></ul></li></ul></li><li> <p>快照读</p> 
    <ul><li> <p>事务非Serializable级别下，不加锁的select操作，Serializable事务隔离级别时，由于是串行化，快照读会退化为当前读</p> </li><li> <p>可重复读事务隔离级别下，快照读可能读到数据的历史版本</p> 
      <ul><li> <p>事务A先进行快照读，事务B进行更新并提交，事务A的快照读可读到历史版本</p> </li><li> <p>事务A开启，事务B进行更新并提交，事务A的快照读，读到的是最新版本</p> </li></ul></li></ul></li></ul></li><li> <p>RC、RR级别下的InnoDB的非阻塞读（快照读）如何实现</p> 
  <ul><li> <p>数据行里的DB_TRX_ID,DB_ROLL_PTR,DB_ROW_ID三个字段</p> 
    <ul><li> <p>DB_TRX_ID</p> 
      <ul><li> <p>最近一次对本行做修改的事务ID</p> </li></ul></li><li> <p>DB_ROLL_PTR</p> 
      <ul><li> <p>回滚指针</p> </li></ul></li><li> <p>DB_ROW_ID</p> 
      <ul><li> <p>行ID</p> </li></ul></li></ul></li><li> <p>undo日志</p> 
    <ul><li> <p><img alt="" class="has" height="318" src="https://images2.imgbox.com/df/50/vlgllH5r_o.png" width="580"></p> </li></ul></li><li> <p>read view</p> 
    <ul><li> <p>做可见性判断</p> </li><li> <p>RR级别下，第一条快照读，会创建一个read view，将当前数据库的事务状态记录，同一事务中再次进行快照读时，使用的是同一个read view</p> </li><li> <p>RC级别下，每次进行快照读，都会创建一个新的read view</p> </li></ul></li></ul></li></ul> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/8d10dec46d85bd7a94bbaab8b8c31b38/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机网络拾遗</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cbb4786243227ef434c53d7317d6e57b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Redis拾遗</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>