<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring Cloud中的Feign调用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring Cloud中的Feign调用" />
<meta property="og:description" content="目录
前言
一、Feign是什么？
二、使用说明
1.引入依赖
2.FeignClient注解的参数说明
实际用例
前言 主要介绍了feign client的参数的用户，并列举了开发中的一个实际用例
一、Feign是什么？ Feign是Netflix开发的声明式、模板化的HTTP客户端， Feign可以帮助我们更快捷、优雅地调用HTTP API。Feign支持多种注解，例如Feign自带的注解或者JAX-RS注解等。Spring Cloud对Feign进行了增强，使Feign支持了Spring MVC注解，并整合了Ribbon和Eureka，从而让Feign的使用更加方便。Spring Cloud Feign是基于Netflix feign实现，整合了Spring Cloud Ribbon和Spring Cloud Hystrix，除了提供这两者的强大功能外，还提供了一种声明式的Web服务客户端定义的方式。Spring Cloud Feign帮助我们定义和实现依赖服务接口的定义。在Spring Cloud feign的实现下，只需要创建一个接口并用注解方式配置它，即可完成服务提供方的接口绑定，简化了在使用Spring Cloud Ribbon时自行封装服务调用客户端的开发量。 二、使用说明 1.引入依赖 &lt;!--服务调用--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; 2.FeignClient注解的参数说明 // // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package org.springframework.cloud.openfeign; import java.lang.annotation.Documented; import java.lang.annotation.ElementType; import java.lang.annotation.Inherited; import java.lang.annotation.Retention; import java.lang.annotation.RetentionPolicy; import java.lang.annotation.Target; import org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ec599d949d9dfd2d25afe9e9ac0de492/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-27T14:15:13+08:00" />
<meta property="article:modified_time" content="2022-11-27T14:15:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring Cloud中的Feign调用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2><a id="_0"></a></h2> 
<div> 
 <p id="main-toc"><strong>目录</strong></p> 
 <p id="-toc" style="margin-left:0px;"></p> 
 <p id="%E5%89%8D%E8%A8%80-toc" style="margin-left:0px;"><a href="#%E5%89%8D%E8%A8%80" rel="nofollow">前言</a></p> 
 <p id="%E4%B8%80%E3%80%81Feign%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81Feign%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">一、Feign是什么？</a></p> 
 <p id="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E" rel="nofollow">二、使用说明</a></p> 
 <p id="1.%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96-toc" style="margin-left:40px;"><a href="#1.%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96" rel="nofollow">1.引入依赖</a></p> 
 <p id="2.FeignClient%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E-toc" style="margin-left:40px;"><a href="#2.FeignClient%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E" rel="nofollow">2.FeignClient注解的参数说明</a></p> 
 <p id="%E5%AE%9E%E9%99%85%E7%94%A8%E4%BE%8B-toc" style="margin-left:0px;"><a href="#%E5%AE%9E%E9%99%85%E7%94%A8%E4%BE%8B" rel="nofollow">实际用例</a></p> 
 <p></p> 
</div> 
<hr> 
<h2 id="%E5%89%8D%E8%A8%80"><a id="_12"></a>前言</h2> 
<p>主要介绍了feign client的参数的用户，并列举了开发中的一个实际用例</p> 
<hr> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81Feign%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><a id="pandas_22"></a>一、Feign是什么？</h2> 
<ol><li>Feign是Netflix开发的声明式、模板化的HTTP客户端， Feign可以帮助我们更快捷、优雅地调用HTTP API。</li><li>Feign支持多种注解，例如Feign自带的注解或者JAX-RS注解等。</li><li>Spring Cloud对Feign进行了增强，使Feign支持了Spring MVC注解，并整合了Ribbon和Eureka，从而让Feign的使用更加方便。</li><li>Spring Cloud Feign是基于Netflix feign实现，整合了Spring Cloud Ribbon和Spring Cloud Hystrix，除了提供这两者的强大功能外，还提供了一种声明式的Web服务客户端定义的方式。</li><li>Spring Cloud Feign帮助我们定义和实现依赖服务接口的定义。在Spring Cloud feign的实现下，只需要创建一个接口并用注解方式配置它，即可完成服务提供方的接口绑定，简化了在使用Spring Cloud Ribbon时自行封装服务调用客户端的开发量。</li></ol> 
<h2 id="%E4%BA%8C%E3%80%81%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E"><a id="_26"></a>二、使用说明</h2> 
<h3 id="1.%E5%BC%95%E5%85%A5%E4%BE%9D%E8%B5%96"><a id="1_27"></a>1.引入依赖</h3> 
<pre><code class="language-java">&lt;!--服务调用--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> 
<h3 id="2.FeignClient%E6%B3%A8%E8%A7%A3%E7%9A%84%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><a id="2_41"></a>2.FeignClient注解的参数说明</h3> 
<pre><code class="language-java">//
// Source code recreated from a .class file by IntelliJ IDEA
// (powered by FernFlower decompiler)
//

package org.springframework.cloud.openfeign;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Inherited;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.springframework.core.annotation.AliasFor;

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
public @interface FeignClient {
    @AliasFor("name")
    String value() default "";

    String contextId() default "";

    @AliasFor("value")
    String name() default "";

    /** @deprecated */
    @Deprecated
    String qualifier() default "";

    String[] qualifiers() default {};

    String url() default "";

    boolean decode404() default false;

    Class&lt;?&gt;[] configuration() default {};

    Class&lt;?&gt; fallback() default void.class;

    Class&lt;?&gt; fallbackFactory() default void.class;

    String path() default "";

    boolean primary() default true;
}
</code></pre> 
<p>value和name</p> 
<p>如果没有配置url，那么配置的值将作为服务的名称，用于服务的发现。</p> 
<p>注意配置的内容是提供接口的服务的名字，对用服务发现、走网关调用,由这个参数控制。</p> 
<p>这两个是一样的效果，内容互相引用</p> 
<p>contextId</p> 
<p>如果同一个工程中出现两个接口使用一样的服务名称会报错。原因是Client名字注册到容器中重复了。这种情况可以使用contextId来解决问题。</p> 
<p>比如我们有个user服务，但user服务中有很多个接口，我们不想将所有的调用接口都定义在一个类中，比如UserFeignClientA、UserFeignClentB，当不同的Feign的name一致的时候，这时候Bean的名称就会冲突，解决方式可以通过指定不同的contextId来解决问题。</p> 
<p>配置了contextId属性，就会采用contextId作为bean的名称注入进容器中，如果没有配置就会去找value然后是name</p> 
<p>在真正的项目开发中，这种情况很少，一般是定义在一个类中，方便管理。</p> 
<p>另外在注册FeignClient中，这个属性还会作为Client别名的一部分，如果配置了qualifier，会有限使用qualifier作为别名。</p> 
<pre><code class="language-java">// 拼接别名
    String alias = contextId + "FeignClient";
    AbstractBeanDefinition beanDefinition = definition.getBeanDefinition();
 
 
    boolean primary = (Boolean) attributes.get("primary"); // has a default, won't be
                                // null
 
 
    beanDefinition.setPrimary(primary);
 
    // 配置了qualifier优先用qualifier
    String qualifier = getQualifier(attributes);
    if (StringUtils.hasText(qualifier)) {
      alias = qualifier;
    }
 
 
    BeanDefinitionHolder holder = new BeanDefinitionHolder(beanDefinition, className,
        new String[] { alias });
    BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</code></pre> 
<p>url</p> 
<p>用于配置指定的地址，相当于使用http的形式直接请求这个服务，不经过注册中心。如果配置了这个属性，name属性（通过注册中心调用目标服务）将会被覆盖，不会通过配置中心调用服务。</p> 
<p>configuration</p> 
<p>这个属性是配置feign的配置类，在配置类中可以定义Feign的Encoder、Decoder、loglevel、contract、鉴权信息等</p> 
<p>fallback</p> 
<p><code>fallback</code>定义容错的处理类，也就是回退逻辑，<code>fallback</code>的类必须实现<code>Feign Client</code>的接口，无法知道熔断的异常信息，只是重写了回退方法。</p> 
<p>fallbackFactory</p> 
<p>也是容错的处理，可以通过输出Throwable（调用异常的原因）知道熔断的异常信息。</p> 
<p>用线程抛出了异常，可以看到底层具体的问题。</p> 
<p>path</p> 
<p><code>path</code>定义当前<code>FeignClient</code>访问接口时的统一前缀，比如接口地址是/user/get, 如果你定义了前缀是user, 那么具体方法上的路径就只需要写/get 即可。</p> 
<p>qualifier</p> 
<p>如果由于某些特殊原因，你必须得去掉<code>primary=true</code>的设置，这种情况下我们怎么进行注入，我们可以配置一个<code>qualifier</code>，然后使用<code>@Qualifier</code>注解进行注入</p> 
<pre><code class="language-java">@FeignClient(name = "optimization-user", path="user", qualifier="userRemoteClient")
public interface UserRemoteClient {

	@GetMapping("/get")
	public User getUser(@RequestParam("id") int id);
}
</code></pre> 
<p> feign client的注入</p> 
<pre><code class="language-java">@Autowired
@Qualifier("userRemoteClient")
private UserRemoteClient userRemoteClient;
</code></pre> 
<p>primary</p> 
<p>primary对应的是@Primary注解，默认为true，官方这样设置也是有原因的。当我们的Feign实现了fallback后，也就意味着FeignClient有多个相同的Bean在Spring容器中，当我们在使用@Autowired进行注入的时候，不知道注入哪个，所以我们需要设置一个优先级高的，@Primary注解就是干这件事情的。</p> 
<hr> 
<h2 id="%E5%AE%9E%E9%99%85%E7%94%A8%E4%BE%8B"><a id="_55"></a>实际用例</h2> 
<p>在微服务的框架中，每个服务一般会再定义一个api的模块，用来专门存放feign client。</p> 
<p>假设在job模块调用order的模块的接口</p> 
<p>首先在order模块的api中定义feign client</p> 
<p>1.导入feign的依赖</p> 
<p>2.设置接口类</p> 
<p>在这里，我定义了contextId，value，fallbackFactory，path四个参数信息</p> 
<pre><code class="language-java">package com.qingdao2world.settle.api;

import com.qingdao2world.settle.api.domain.BmsExpressMonthDetailDto;
import com.qingdao2world.settle.api.factory.RemoteBizExpressMonthDetailFallbackFactory;
import com.ruoyi.common.core.constant.SecurityConstants;
import com.ruoyi.common.core.constant.ServiceNameConstants;
import com.ruoyi.common.core.domain.R;
import org.springframework.cloud.openfeign.FeignClient;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.bind.annotation.RequestParam;

import java.util.List;

/**
 * @author linaibo
 */
@FeignClient(contextId = "remoteBizExpressMonthDetailService",value= ServiceNameConstants.SETTLE_SERVICE,fallbackFactory= RemoteBizExpressMonthDetailFallbackFactory.class,path="/express")
public interface RemoteBizExpressMonthDetailService {

    @GetMapping("/selectDetails")
    public R&lt;List&lt;BmsExpressMonthDetailDto&gt;&gt; selectBmsExpressMonthDetailByStatus(@RequestParam("expressStatus") Integer expressStatus, @RequestHeader(SecurityConstants.FROM_SOURCE) String source);

    @GetMapping("/updateDetail")
    public R&lt;String&gt; updateCompanyByLogistics(@RequestParam("logisticsNo") String logisticsNo,@RequestParam("expressStatus") Integer expressStatus, @RequestHeader(SecurityConstants.FROM_SOURCE) String source);
}
</code></pre> 
<p>3.设置容错处理类</p> 
<p>这里使用的fallbackFactory，因为可以看到出错的原因</p> 
<pre><code class="language-java">package com.qingdao2world.settle.api.factory;

import com.qingdao2world.settle.api.RemoteBizExpressMonthDetailService;
import com.qingdao2world.settle.api.domain.BmsExpressMonthDetailDto;
import com.ruoyi.common.core.domain.R;
import org.springframework.cloud.openfeign.FallbackFactory;

import java.util.List;

/**
 * @author linaibo
 * @version 1.0
 * Create by 2022/8/17 15:12
 */

public class RemoteBizExpressMonthDetailFallbackFactory implements FallbackFactory&lt;RemoteBizExpressMonthDetailService&gt; {
    @Override
    public RemoteBizExpressMonthDetailService create(Throwable cause) {
        return new RemoteBizExpressMonthDetailService(){
            @Override
            public R&lt;List&lt;BmsExpressMonthDetailDto&gt;&gt; selectBmsExpressMonthDetailByStatus(Integer expressStatus, String source) {
                return R.fail("查询快递费用明细失败" + cause.getMessage());
            }
            @Override
            public R&lt;String&gt; updateCompanyByLogistics(String logisticsNo, Integer expressStatus, String source) {
                return R.fail("更新快递费用明细失败" + cause.getMessage());
            }
        };
    }
}
</code></pre> 
<p>4.将容错处理类交由spring容器进行管理</p> 
<p>将容错处理类添加在下面这个文件中</p> 
<p>billsys-api/billsys-api-settle/src/main/resources/META-INF/spring.factories</p> 
<pre><code class="language-java">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  com.qingdao2world.settle.api.factory.RemoteBizExpressMonthDetailFallbackFactory,\
  com.qingdao2world.settle.api.factory.RemoteBmsDayBillsDetailServiceFallbackFactory</code></pre> 
<p>5.在order模块定义一个apiController专门处理feign调用的接口</p> 
<p>在order模块中api文件夹中专门设置了一个controler类来处理feign的调用，可以和其他的接口调用区分开，使整个框架更加清晰。可以让这个controller类实现feign client的接口，这样可以避免一些错误。</p> 
<pre><code class="language-java">package com.qingdao2world.settle.api;

import com.qingdao2world.settle.api.domain.BmsExpressMonthDetailDto;
import com.qingdao2world.settle.service.IBmsExpressMonthDetailService;
import com.ruoyi.common.core.domain.R;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * @author linaibo
 * @version 1.0
 * Create by 2022/8/17 13:43
 */
@RestController
@RequestMapping("/express")
public class ApiBmsExpressMonthDetailController {

    @Autowired
    private IBmsExpressMonthDetailService expressMonthDetailService;

    @GetMapping("/selectDetails")
    public R&lt;List&lt;BmsExpressMonthDetailDto&gt;&gt; selectBmsExpressMonthDetailByStatus(@RequestParam("expressStatus") Integer expressStatus, @RequestHeader(required = false) String source) {
        List&lt;BmsExpressMonthDetailDto&gt; bmsExpressMonthDetailDtoList = expressMonthDetailService.selectBmsExpressMonthDetailByStatus(expressStatus);
        return R.ok(bmsExpressMonthDetailDtoList);
    }

    @GetMapping("/updateDetail")
    public R&lt;String&gt; updateCompanyByLogistics(@RequestParam("logisticsNo") String logisticsNo, @RequestParam("expressStatus") Integer expressStatus, @RequestHeader(required = false) String source) {
        int updateNum = expressMonthDetailService.updateCompanyByLogistics(logisticsNo, expressStatus);
        return updateNum &gt; 0 ? R.ok("快递信息锁定成功") : R.fail("快递信息锁定失败");
    }

}
</code></pre> 
<p>6.在job模块中引入order的api模块的依赖</p> 
<pre><code class="language-java">        &lt;dependency&gt;
            &lt;groupId&gt;com.qingdao2world&lt;/groupId&gt;
            &lt;artifactId&gt;billsys-api-settle&lt;/artifactId&gt;
            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
            &lt;scope&gt;compile&lt;/scope&gt;
        &lt;/dependency&gt;</code></pre> 
<p>7.在job模块的启动类中天添加@EnableFeignClients注解</p> 
<p>8.在job模块的service中注入order的api模块的feign client，直接使用就可以</p> 
<pre><code class="language-java">package com.ruoyi.job.queue.disruptor.expressDetailWmsProcess;

import cn.hutool.json.JSONUtil;
import com.lmax.disruptor.WorkHandler;
import com.qingdao2world.settle.api.RemoteBizExpressMonthDetailService;
import com.qingdao2world.settle.api.domain.BmsExpressMonthDetailDto;
import com.qingdao2world.settle.api.domain.ExpressWmsDto;
import com.ruoyi.common.core.constant.SecurityConstants;
import com.ruoyi.common.core.domain.R;
import com.ruoyi.common.core.enums.ExpressStatusEnum;
import com.ruoyi.job.manager.WmsManager;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.BeanUtils;

/**
 * 推送wms系统
 *
 * @author linaibo
 */

@RequiredArgsConstructor
@Slf4j
public class ExpressDetailWmsProcessEventHandler implements WorkHandler&lt;ExpressDetailWmsProcessEvent&gt; {

	private final RemoteBizExpressMonthDetailService remoteBizExpressMonthDetailService;
	private final WmsManager wmsManager;

	@Override
	public void onEvent(ExpressDetailWmsProcessEvent event) {
		//锁住信息，将状态更新为对接中
		BmsExpressMonthDetailDto express = event.getValue();
		R&lt;String&gt; result =  remoteBizExpressMonthDetailService.updateCompanyByLogistics(express.getLogisticsNo(), ExpressStatusEnum.DOCKING.expressStatus, SecurityConstants.INNER);
		if(!result.isSuccess()){
			log.error("快递明细更新失败"+ JSONUtil.toJsonStr(express));
			event.setStop(true);
			return;
		}
		//将信息推送到wms
		ExpressWmsDto expressWmsDto = new ExpressWmsDto();
		BeanUtils.copyProperties(express,expressWmsDto);
		R&lt;String&gt; result2 = wmsManager.importExpress(expressWmsDto);
		if (!result2.isSuccess()) {
			event.setStop(true);
			log.info("快递信息推送WMS系统失败" + JSONUtil.toJsonStr(expressWmsDto));
			//更新快递状态为3（对接失败）
			remoteBizExpressMonthDetailService.updateCompanyByLogistics(express.getLogisticsNo(),ExpressStatusEnum.DOCKFAIL.expressStatus, SecurityConstants.INNER);
			return;
		}
	}

}
</code></pre> 
<p>api模块的构成</p> 
<p><img alt="" height="644" src="https://images2.imgbox.com/81/55/L4q72bQ4_o.png" width="650"></p> 
<p>注意：</p> 
<p> feign client中的请求url一定要和被请求接口在controller中的url保持一致</p> 
<p>参数一定要设置正确</p> 
<p>容错处理类要明确出错的原因，方便对异常的处理</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a984df0f288442145c874cc4f6b5c7cf/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">yocto杂记</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/26396352c69242d43c0140c639e1db1b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【零基础上手yolov5】yolov5的安装与相关环境的搭建</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>