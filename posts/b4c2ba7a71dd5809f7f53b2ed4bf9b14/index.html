<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>linux性能分析工具 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="linux性能分析工具" />
<meta property="og:description" content="sysstat sysstat是一个linux性能工具，用来监控和分析系统的性能，以下案例中会用到这个包的2个命令mpstat和pidstat。
mpstat 是一个常用的多核CPU性能分析工具用来实时查看每个CPU的性能指标，一级所有CPI的平均指标。 # -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据 mpstat -P ALL 5 Linux 4.18.0-147.5.1.el8_1.x86_64 (service) 2021年06月17日 _x86_64_	(4 CPU) 11时02分41秒 CPU %usr %nice %sys %iowait %irq %soft %steal %guest %gnice %idle 11时02分46秒 all 53.29 0.00 5.72 0.00 1.22 2.28 0.00 0.00 0.00 37.49 11时02分46秒 0 8.69 0.00 15.56 0.00 0.61 0.20 0.00 0.00 0.00 74.95 11时02分46秒 1 99.40 0.00 0.00 0.00 0.60 0.00 0.00 0." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b4c2ba7a71dd5809f7f53b2ed4bf9b14/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-06-30T18:56:39+08:00" />
<meta property="article:modified_time" content="2021-06-30T18:56:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">linux性能分析工具</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="sysstat_0"></a>sysstat</h2> 
<p>sysstat是一个linux性能工具，用来监控和分析系统的性能，以下案例中会用到这个包的2个命令mpstat和pidstat。</p> 
<ul><li>mpstat 是一个常用的多核CPU性能分析工具用来实时查看每个CPU的性能指标，一级所有CPI的平均指标。</li></ul> 
<pre><code class="prism language-bash"><span class="token comment"># -P ALL 表示监控所有 CPU，后面数字 5 表示间隔 5 秒后输出一组数据</span>
 mpstat -P ALL <span class="token number">5</span>
Linux <span class="token number">4.18</span>.0-147.5.1.el8_1.x86_64 <span class="token punctuation">(</span>service<span class="token punctuation">)</span> 	<span class="token number">2021</span>年06月17日 	_x86_64_	<span class="token punctuation">(</span><span class="token number">4</span> CPU<span class="token punctuation">)</span>

<span class="token number">11</span>时02分41秒  CPU    %usr   %nice    %sys %iowait    %irq   %soft  %steal  %guest  %gnice   %idle
<span class="token number">11</span>时02分46秒  all   <span class="token number">53.29</span>    <span class="token number">0.00</span>    <span class="token number">5.72</span>    <span class="token number">0.00</span>    <span class="token number">1.22</span>    <span class="token number">2.28</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">37.49</span>
<span class="token number">11</span>时02分46秒    <span class="token number">0</span>    <span class="token number">8.69</span>    <span class="token number">0.00</span>   <span class="token number">15.56</span>    <span class="token number">0.00</span>    <span class="token number">0.61</span>    <span class="token number">0.20</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">74.95</span>
<span class="token number">11</span>时02分46秒    <span class="token number">1</span>   <span class="token number">99.40</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.60</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>
<span class="token number">11</span>时02分46秒    <span class="token number">2</span>    <span class="token number">2.92</span>    <span class="token number">0.00</span>    <span class="token number">7.52</span>    <span class="token number">0.00</span>    <span class="token number">3.34</span>    <span class="token number">9.19</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">77.04</span>
<span class="token number">11</span>时02分46秒    <span class="token number">3</span>   <span class="token number">99.60</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.40</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>
</code></pre> 
<table><thead><tr><th>参数</th><th>释义</th></tr></thead><tbody><tr><td>CPU</td><td>处理器ID</td></tr><tr><td>%usr</td><td>在internal时间段里，用户态的CPU时间（%），不包含 nice值为负进程 sr/total*100</td></tr><tr><td>%nice</td><td>在internal时间段里，nice值为负进程的CPU时间（%） nice/total*100</td></tr><tr><td>%sys</td><td>在internal时间段里，CPU时间（%） system/total*100</td></tr><tr><td>%iowait</td><td>在internal时间段里，硬盘IO等待（%） iowait/total*100</td></tr><tr><td>%irq</td><td>在internal时间段里，硬中断时间（%） irq/total*100</td></tr><tr><td>%soft</td><td>在internal时间段里，软中断时间（%） softirq/total*100</td></tr><tr><td>%steal</td><td>显示虚拟机管理器在服务另一个虚拟处理器时虚拟CPU处在非自愿等待下花费时间的百分比 steal/total*100</td></tr><tr><td>%guest</td><td>显示运行虚拟处理器时CPU花费时间的百分比 guest/total*100</td></tr><tr><td>%gnice</td><td>gnice/total*100</td></tr><tr><td>%idle</td><td>在internal时间段里，CPU除去等待磁盘IO操作外的因为任何原因而空闲的时间闲置时间（%） idle/total*100</td></tr></tbody></table> 
<ul><li>pidstat 是一个常用的进程性能分析工具，用来实时查看进程的CPU、内存、I/O以及上下文切换等性能指标。</li></ul> 
<pre><code class="prism language-bash">pidstat -t <span class="token number">5</span>
<span class="token number">19</span>时40分33秒   <span class="token environment constant">UID</span>       PID   cswch/s nvcswch/s  Command
<span class="token number">19</span>时40分38秒     <span class="token number">0</span>         <span class="token number">9</span>      <span class="token number">1.00</span>      <span class="token number">0.00</span>  ksoftirqd/0
<span class="token number">19</span>时40分38秒     <span class="token number">0</span>        <span class="token number">10</span>     <span class="token number">30.94</span>      <span class="token number">0.00</span>  rcu_sched
</code></pre> 
<table><thead><tr><th>参数</th><th>释义</th></tr></thead><tbody><tr><td>UID</td><td>用户id</td></tr><tr><td>PID</td><td>进程ID</td></tr><tr><td>%usr</td><td>进程在用户空间占用cpu的百分比</td></tr><tr><td>%system</td><td>进程在内核空间占用cpu的百分比</td></tr><tr><td>%guest</td><td>进程在虚拟机占用cpu的百分比</td></tr><tr><td>%wait</td><td>进程在等待CPU的时间百分比</td></tr><tr><td>%CPU</td><td>进程占用cpu的百分比</td></tr><tr><td>CPU</td><td>处理进程的cpu编号</td></tr><tr><td>%Command</td><td>当前进程对应的命令</td></tr></tbody></table> 
<h2><a id="uptime_55"></a>uptime</h2> 
<p>查看平均负载的变化情况:</p> 
<pre><code class="prism language-bash"><span class="token function">watch</span> -d <span class="token function">uptime</span>
</code></pre> 
<h2><a id="vmstat_62"></a>vmstat</h2> 
<p>vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分 析 CPU 上下文切换和中断的次数。</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@ ~<span class="token punctuation">]</span><span class="token comment"># vmstat 5</span>
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   <span class="token function">free</span>   buff  cache   si   so    bi    bo   <span class="token keyword">in</span>   cs us sy <span class="token function">id</span> wa st
 <span class="token number">2</span>  <span class="token number">0</span> <span class="token number">101120</span> <span class="token number">2083104</span>   <span class="token number">1044</span> <span class="token number">692872</span>    <span class="token number">0</span>    <span class="token number">0</span>     <span class="token number">0</span>     <span class="token number">0</span> <span class="token number">37327</span> <span class="token number">57872</span>  <span class="token number">3</span>  <span class="token number">8</span> <span class="token number">89</span>  <span class="token number">0</span>  <span class="token number">0</span>
</code></pre> 
<p>需要特别关注的四列内容:</p> 
<ul><li>cs(context switch)是每秒上下文切换的次数</li><li>in(interrupt)则是每秒中断的次数</li><li>r(Running or Runnable)是就绪队列的长度，也就是正在运行和等待 CPU 的进程 数</li><li>b(Blocked)则是处于不可中断睡眠状态的进程数<br> 可以看到，这个例子中的上下文切换次数 cs 是 57872 次，系统中断次数 in 则是 37327 次，而就绪队列长度 r是2此， 不可中断状态进程数 b 是0。</li></ul> 
<h2><a id="perf_78"></a>perf</h2> 
<p>perf 是 Linux 2.6.31 以后内置的性能分析工具。它以性能事件采样为基础，不仅可以分析系统的各种事件和内核性能，还可以用来分析指定应用程序的性能问题。<br> <img src="https://images2.imgbox.com/3e/9f/it6hMvta_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-bash">perf <span class="token function">top</span> -g
Samples: 785K of event <span class="token string">'cpu-clock:pppH'</span>, <span class="token number">4000</span> Hz, Event count <span class="token punctuation">(</span>approx.<span class="token punctuation">)</span>: <span class="token number">8358801205</span> lost: <span class="token number">0</span>/0 drop: <span class="token number">0</span>/0
 Overhead     Shared Object                                           Symbol
<span class="token number">32.52</span>%         <span class="token number">0.04</span>%  imsocket                                <span class="token punctuation">[</span>.<span class="token punctuation">]</span> imsocketio/events.ListeningClose
<span class="token number">22.03</span>%         <span class="token number">2.86</span>%  <span class="token punctuation">[</span>kernel<span class="token punctuation">]</span>                              <span class="token punctuation">[</span>k<span class="token punctuation">]</span> __softirqentry_text_start

<span class="token punctuation">..</span><span class="token punctuation">..</span>
   
</code></pre> 
<p>输出结果中，第一行包含三个数据，分别是采样数(Samples)、事件类型(event)和 事件总数量(Event count)。比如这个例子中，perf 总共采集了 785K CPU 时钟事件，而总事件数则为 8358801205。</p> 
<p>另外，采样数需要我们特别注意。如果采样数过少(比如只有十几个)，那下面的排序和 百分比就没什么实际参考价值了。<br> 再往下看是一个表格式样的数据，每一行包含四列，分别是:</p> 
<ol><li>第一列 Overhead ，是该符号的性能事件在所有采样中的比例，用百分比来表示</li><li>第二列 Shared ，是该函数或指令所在的动态共享对象(Dynamic Shared Object)， 如内核、进程名、动态链接库名、内核模块名等。</li><li>第三列 Object ，是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间。</li><li>最后一列 Symbol 是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示。<br> 以上面的输出为例，我们可以看到，占用 CPU 时钟最多的是 imsocket不过它 的比例有 32.52%，说明系统 CPU 性能问题并不大，但是这个可以进行优化。 perf top 的使用应该很清楚了吧。</li></ol> 
<p>接着再来看第二种常见用法，也就是 perf record 和 perf report。 perf top 虽然实时展 示了系统的性能信息，但它的缺点是并不保存数据，也就无法用于离线或者后续的分析。 而 perf record 则提供了保存数据的功能，保存后的数据，需要你用 perf report 解析展示。</p> 
<pre><code class="prism language-bash">perf record -g
</code></pre> 
<h2><a id="dstat_109"></a>dstat</h2> 
<p>dstat 是一个新的性能工具，它吸收了 vmstat、iostat、ifstat 等几种工具的优点， 可以同时观察系统的 CPU、磁盘 I/O、网络以及内存使用情况。</p> 
<h3><a id="_112"></a>安装</h3> 
<pre><code class="prism language-bash">yum <span class="token function">install</span> -y dstat
</code></pre> 
<h3><a id="_118"></a>使用说明</h3> 
<p>安装完后就可以使用了，dstat非常强大，可以实时的监控cpu、磁盘、网络、IO、内存等使用情况。</p> 
<p>直接使用dstat，默认使用的是-cdngy参数，分别显示cpu、disk、net、page、system信息，默认是1s显示一条信息。可以在最后指定显示一条信息的时间间隔，如dstat 5是没5s显示一条，dstat 5 10表示没5s显示一条，一共显示10条。</p> 
<pre><code class="prism language-bash"><span class="token comment"># dstat</span>
----total-usage---- -dsk/total- -net/total- ---paging-- ---system--
usr sys idl wai stl<span class="token operator">|</span> <span class="token builtin class-name">read</span>  writ<span class="token operator">|</span> recv  send<span class="token operator">|</span>  <span class="token keyword">in</span>   out <span class="token operator">|</span> int   csw 
  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">99</span>   <span class="token number">0</span>   <span class="token number">0</span><span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>5266B 3868B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span><span class="token number">1283</span>  <span class="token number">2306</span> 
  <span class="token number">0</span>   <span class="token number">1</span>  <span class="token number">99</span>   <span class="token number">0</span>   <span class="token number">0</span><span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>4860B 1846B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span><span class="token number">1384</span>  <span class="token number">2488</span> 
  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">99</span>   <span class="token number">0</span>   <span class="token number">0</span><span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>4798B 4753B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span><span class="token number">1255</span>  <span class="token number">2293</span> 
  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">99</span>   <span class="token number">0</span>   <span class="token number">0</span><span class="token operator">|</span>   <span class="token number">0</span>    23k<span class="token operator">|</span>4799B 1754B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span><span class="token number">1279</span>  <span class="token number">2345</span> 
  <span class="token number">0</span>   <span class="token number">0</span> <span class="token number">100</span>   <span class="token number">0</span>   <span class="token number">0</span><span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>4799B 1762B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span><span class="token number">1189</span>  <span class="token number">2174</span> 
  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">99</span>   <span class="token number">0</span>   <span class="token number">0</span><span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>5075B 2072B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span><span class="token number">1274</span>  <span class="token number">2310</span> 
  <span class="token number">3</span>   <span class="token number">1</span>  <span class="token number">96</span>   <span class="token number">0</span>   <span class="token number">0</span><span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>5348B 2294B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span><span class="token number">1567</span>  <span class="token number">2477</span> 
  <span class="token number">2</span>   <span class="token number">1</span>  <span class="token number">97</span>   <span class="token number">0</span>   <span class="token number">0</span><span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>5010B 2069B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span><span class="token number">1510</span>  <span class="token number">2424</span> 
  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">99</span>   <span class="token number">0</span>   <span class="token number">0</span><span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>5075B 1941B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span><span class="token number">1257</span>  <span class="token number">2324</span> 
  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">99</span>   <span class="token number">0</span>   <span class="token number">0</span><span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>4799B 1754B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span><span class="token number">1267</span>  <span class="token number">2315</span> 
  <span class="token number">0</span>   <span class="token number">0</span>  <span class="token number">99</span>   <span class="token number">0</span>   <span class="token number">0</span><span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span>4865B 1886B<span class="token operator">|</span>   <span class="token number">0</span>     <span class="token number">0</span> <span class="token operator">|</span><span class="token number">1260</span>  <span class="token number">2274</span>
</code></pre> 
<p>下面对显示出来的部分信息作一些说明：</p> 
<ol><li>cpu：hiq、siq分别为硬中断和软中断次数。</li><li>system：int、csw分别为系统的中断次数（interrupt）和上下文切换（context switch）。</li></ol> 
<h3><a id="_144"></a>语法</h3> 
<p>dstat [-afv] [options…] [delay [count]]</p> 
<h3><a id="_147"></a>常用选项</h3> 
<ul><li>-c：显示CPU系统占用，用户占用，空闲，等待，中断，软件中断等信息。</li><li>-C：当有多个CPU时候，此参数可按需分别显示cpu状态，例：-C 0,1 是显示cpu0和cpu1的信息。</li><li>-d：显示磁盘读写数据大小。</li><li>-D hda,total：include hda and total。</li><li>-n：显示网络状态。</li><li>-N eth1,total：有多块网卡时，指定要显示的网卡。</li><li>-l：显示系统负载情况。</li><li>-m：显示内存使用情况。</li><li>-g：显示页面使用情况。</li><li>-p：显示进程状态。</li><li>-s：显示交换分区使用情况。</li><li>-S：类似D/N。</li><li>-r：I/O请求情况。</li><li>-y：系统状态。</li><li>–ipc：显示ipc消息队列，信号等信息。</li><li>–socket：用来显示tcp udp端口状态。</li><li>-a：此为默认选项，等同于-cdngy。</li><li>-v：等同于 -pmgdsc -D total。</li><li>–output 文件：此选项也比较有用，可以把状态信息以csv的格式重定向到指定的文件中，以便日后查看。例：dstat --output /root/dstat.csv &amp; 此时让程序默默的在后台运行并把结果输出到/root/dstat.csv文件中。</li></ul> 
<h3><a id="_168"></a>实例</h3> 
<p>如想监控swap，process，sockets，filesystem并显示监控的时间：</p> 
<pre><code class="prism language-bash">dstat -tsp --socket --fs
----system---- ----swap--- ---procs--- --------sockets--------- --filesystem-
     <span class="token function">time</span>     <span class="token operator">|</span> used  <span class="token function">free</span><span class="token operator">|</span>run blk new<span class="token operator">|</span>tot  tcp  udp  raw  frg <span class="token operator">|</span>files  inodes
05-07 <span class="token number">16</span>:04:08<span class="token operator">|</span>  68M 4028M<span class="token operator">|</span>  <span class="token number">0</span>   <span class="token number">0</span>    <span class="token operator">|</span><span class="token number">355</span>   <span class="token number">99</span>    <span class="token number">4</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">3616</span>  <span class="token number">87574</span> 
05-07 <span class="token number">16</span>:04:09<span class="token operator">|</span>  68M 4028M<span class="token operator">|</span><span class="token number">0.5</span>   <span class="token number">0</span> <span class="token number">1.0</span><span class="token operator">|</span><span class="token number">355</span>   <span class="token number">99</span>    <span class="token number">4</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">3648</span>  <span class="token number">87580</span> 
05-07 <span class="token number">16</span>:04:10<span class="token operator">|</span>  68M 4028M<span class="token operator">|</span>  <span class="token number">0</span>   <span class="token number">0</span> <span class="token number">0.5</span><span class="token operator">|</span><span class="token number">356</span>  <span class="token number">100</span>    <span class="token number">4</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">3680</span>  <span class="token number">87586</span> 
05-07 <span class="token number">16</span>:04:11<span class="token operator">|</span>  68M 4028M<span class="token operator">|</span>  <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span><span class="token operator">|</span><span class="token number">356</span>  <span class="token number">100</span>    <span class="token number">4</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">3680</span>  <span class="token number">87586</span> 
05-07 <span class="token number">16</span>:04:12<span class="token operator">|</span>  68M 4028M<span class="token operator">|</span>  <span class="token number">0</span>   <span class="token number">0</span>   <span class="token number">0</span><span class="token operator">|</span><span class="token number">356</span>  <span class="token number">100</span>    <span class="token number">4</span>    <span class="token number">0</span>    <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">3680</span>  <span class="token number">87586</span>
</code></pre> 
<h2><a id="sar_184"></a>sar</h2> 
<p>sar 是一个系统活动报告工具，既可以实时查看系统的当前活动，又可以配置保存和报 告历史统计数据。</p> 
<pre><code class="prism language-bash"><span class="token comment"># -n DEV 表示显示网络收发的报告，间隔 1 秒输出一组数据</span>
sar-n DEV <span class="token number">1</span>
Linux <span class="token number">4.18</span>.0-147.5.1.el8_1.x86_64 <span class="token punctuation">(</span>service<span class="token punctuation">)</span> 	<span class="token number">2021</span>年07月02日 	_x86_64_	<span class="token punctuation">(</span><span class="token number">2</span> CPU<span class="token punctuation">)</span>

<span class="token number">15</span>时09分17秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
<span class="token number">15</span>时09分18秒        lo      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>
<span class="token number">15</span>时09分18秒      eth0  <span class="token number">15542.00</span>   <span class="token number">7773.00</span>    <span class="token number">910.68</span>    <span class="token number">444.02</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>

<span class="token number">15</span>时09分18秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
<span class="token number">15</span>时09分19秒        lo      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>
<span class="token number">15</span>时09分19秒      eth0  <span class="token number">15541.00</span>   <span class="token number">7771.00</span>    <span class="token number">910.61</span>    <span class="token number">440.28</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>

<span class="token number">15</span>时09分19秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
<span class="token number">15</span>时09分20秒        lo      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>
<span class="token number">15</span>时09分20秒      eth0  <span class="token number">15202.00</span>   <span class="token number">7602.00</span>    <span class="token number">890.75</span>    <span class="token number">431.15</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>

<span class="token number">15</span>时09分20秒     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s   %ifutil
<span class="token number">15</span>时09分21秒        lo      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>
<span class="token number">15</span>时09分21秒      eth0  <span class="token number">15565.00</span>   <span class="token number">7784.00</span>    <span class="token number">912.00</span>    <span class="token number">441.44</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>
</code></pre> 
<p>对于 sar 的输出界面，我先来简单介绍一下，从左往右依次是:</p> 
<ul><li>第一列：表示报告的时间。</li><li>第二列：IFACE 表示网卡。</li><li>第三、四列：rxpck/s 和 txpck/s 分别表示每秒接收、发送的网络帧数，也就是 PPS。</li><li>第五、六列:rxkB/s 和 txkB/s 分别表示每秒接收、发送的千字节数，也就是 BPS。</li></ul> 
<h3><a id="sar_213"></a>sar参数说明</h3> 
<ul><li>-A 汇总所有的报告</li><li>-a 报告文件读写使用情况</li><li>-B 报告附加的缓存的使用情况</li><li>-b 报告缓存的使用情况</li><li>-c 报告系统调用的使用情况</li><li>-d 报告磁盘的使用情况</li><li>-g 报告串口的使用情况</li><li>-h 报告关于buffer使用的统计数据</li><li>-m 报告IPC消息队列和信号量的使用情况</li><li>-n 报告命名cache的使用情况</li><li>-p 报告调页活动的使用情况</li><li>-q 报告运行队列和交换队列的平均长度</li><li>-R 报告进程的活动情况</li><li>-r 报告没有使用的内存页面和硬盘块</li><li>-u 报告CPU的利用率</li><li>-v 报告进程、i节点、文件和锁表状态</li><li>-w 报告系统交换活动状况</li><li>-y 报告TTY设备活动状况</li></ul> 
<h2><a id="hping3_234"></a>hping3</h2> 
<p>hping3 是一个可以构造 TCP/IP 协议数据包的工具，可以对系统进行安全审计、防火墙 测试等。</p> 
<pre><code class="prism language-bash"><span class="token comment"># -S 参数表示设置 TCP 协议的 SYN(同步序列号)，-p 表示目的端口为 80</span>
<span class="token comment"># -i u100 表示每隔 100 微秒发送一个网络帧</span>
<span class="token comment"># 注:如果你在实践过程中现象不明显，可以尝试把 100 调小，比如调成 10 甚至 1 4 </span>
hping3 -S -p <span class="token number">80</span> -i u100 <span class="token number">192.168</span>.0.30

</code></pre> 
<h2><a id="tcpdump_245"></a>tcpdump</h2> 
<p>tcpdump 是一个常用的网络抓包工具，常用来分析各种网络问题。</p> 
<h2><a id="proc__249"></a>proc 文件系统</h2> 
<p>proc 文件系统。它是一种内核空间和用户空间进行通信的机制，可以用来查看内核的数据结构，或者用来动态修改内核的配置：</p> 
<ul><li>/proc/softirqs 提供了软中断的运行情况;</li><li>/proc/interrupts 提供了硬中断的运行情况。</li></ul> 
<h2><a id="execsnoop_256"></a>execsnoop-短时进程追踪工具</h2> 
<p>在实际工作中，偶尔会遇到系统的CPU使用率和系统平均负载很高，但却找不到高CPU的应用；</p> 
<p>产生这个问题的原因：进程有可能在不断的崩溃、重启</p> 
<p>通过uptime发现系统负载很高，但是通过top，mpstat，pidstat，perf等工具很难发现是什么进程导致了系统负载和CPU使用率很高；</p> 
<p>注：通过上面工具的判断，即不是CPU密集型，也不存在IO等待，也不存在进程、线程争用的情况</p> 
<p>execsnoop-专门用于为追踪短时进程（瞬时进程）设计的工具；</p> 
<p>它通过 ftrace 实时监控进程的 exec() 行为，并输出短时进程的基本信息，包括进程 PID、父进程 PID、命令行参数以及执行的结果</p> 
<h2><a id="strace_270"></a>strace</h2> 
<p>strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。</p> 
<h2><a id="ldd__273"></a>ldd 查看程序依赖库</h2> 
<p>来查看程式运行所需的共享库,常用来解决程式因缺少某个库文件而不能运行的一些问题。<br> 查看test程序运行所依赖的库:</p> 
<pre><code class="prism language-bash">ldd <span class="token builtin class-name">test</span>
libstdc++.so.6 <span class="token operator">=</span><span class="token operator">&gt;</span> /usr/lib64/libstdc++.so.6 <span class="token punctuation">(</span>0x00000039a7e00000<span class="token punctuation">)</span>
libm.so.6 <span class="token operator">=</span><span class="token operator">&gt;</span> /lib64/libm.so.6 <span class="token punctuation">(</span>0x0000003996400000<span class="token punctuation">)</span>
libgcc_s.so.1 <span class="token operator">=</span><span class="token operator">&gt;</span> /lib64/libgcc_s.so.1 <span class="token punctuation">(</span>0x00000039a5600000<span class="token punctuation">)</span>
libc.so.6 <span class="token operator">=</span><span class="token operator">&gt;</span> /lib64/libc.so.6 <span class="token punctuation">(</span>0x0000003995800000<span class="token punctuation">)</span>
/lib64/ld-linux-x86-64.so.2 <span class="token punctuation">(</span>0x0000003995400000<span class="token punctuation">)</span>
</code></pre> 
<h2><a id="pstack__284"></a>pstack 跟踪进程栈</h2> 
<p>此命令可显示每个进程的栈跟踪。pstack 命令必须由相应进程的属主或 root 运行。可以使用 pstack 来确定进程挂起的位置。此命令允许使用的唯一选项是要检查的进程的 PID。</p> 
<p>这个命令在排查进程问题时非常有用，比如我们发现一个服务一直处于work状态（如假死状态，好似死循环），使用这个命令就能轻松定位问题所在；可以在一段时间内，多执行几次pstack，若发现代码栈总是停在同一个位置，那个位置就需要重点关注，很可能就是出问题的地方；</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@webim-service-mq ~<span class="token punctuation">]</span><span class="token comment"># pstack 23664</span>
Thread <span class="token number">7</span> <span class="token punctuation">(</span>LWP <span class="token number">23832</span><span class="token punctuation">)</span>:
<span class="token comment">#0  runtime.futex () at /usr/local/go/src/runtime/sys_linux_amd64.s:580</span>
<span class="token comment">#1  0x0000000000432306 in runtime.futexsleep (addr=0xc000261950, val=0, ns=-1) at /usr/local/go/src/runtime/os_linux.go:44</span>
<span class="token comment">#2  0x000000000040c17f in runtime.notesleep (n=0xc000261950) at /usr/local/go/src/runtime/lock_futex.go:159</span>
<span class="token comment">#3  0x000000000043b7f9 in runtime.mPark () at /usr/local/go/src/runtime/proc.go:1340</span>
<span class="token comment">#4  0x000000000043cdf2 in runtime.stopm () at /usr/local/go/src/runtime/proc.go:2257</span>
<span class="token comment">#5  0x000000000043e32e in runtime.findrunnable (gp=0xc000033000, inheritTime=false) at /usr/local/go/src/runtime/proc.go:2916</span>
<span class="token comment">#6  0x000000000043f677 in runtime.schedule () at /usr/local/go/src/runtime/proc.go:3125</span>
<span class="token comment">#7  0x000000000043fbfd in runtime.park_m (gp=0xc000083380) at /usr/local/go/src/runtime/proc.go:3274</span>
<span class="token comment">#8  0x0000000000469bbb in runtime.mcall () at /usr/local/go/src/runtime/asm_amd64.s:327</span>
<span class="token comment">#9  0x000000c00020fdc0 in ?? ()</span>
<span class="token comment">#10 0x0000000000000000 in ?? ()</span>
Thread <span class="token number">6</span> <span class="token punctuation">(</span>LWP <span class="token number">23669</span><span class="token punctuation">)</span>:

</code></pre> 
<h2><a id="ipcs_306"></a>ipcs</h2> 
<p>ipcs是Linux下显示进程间通信设施状态的工具。可以显示消息队列、共享内存和信号量的信息。对于程序员非常有用，普通的系统管理员一般用不到此指令。</p> 
<h3><a id="IPC_309"></a>查看系统使用的IPC资源</h3> 
<p>查看系统使用的IPC资源</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@<span class="token comment"># ~]# ipcs</span>

--------- 消息队列 -----------
键        msqid      拥有者  权限     已用字节数 消息      

------------ 共享内存段 --------------
键        shmid      拥有者  权限     字节     连接数  状态      

--------- 信号量数组 -----------
键        semid      拥有者  权限     nsems     
0x002fa327 <span class="token number">0</span>          root       <span class="token number">600</span>        <span class="token number">2</span>    
</code></pre> 
<p>分别查询IPC资源：</p> 
<pre><code class="prism language-bash"><span class="token comment"># ipcs -m 查看系统使用的IPC共享内存资源</span>
<span class="token comment"># ipcs -q 查看系统使用的IPC队列资源</span>
<span class="token comment"># ipcs -s 查看系统使用的IPC信号量资源</span>
</code></pre> 
<h2><a id="free__332"></a>free 查询可用内存</h2> 
<p>free工具用来查看系统可用内存：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@webim-service-mq ~<span class="token punctuation">]</span><span class="token comment"># free</span>
              total        used        <span class="token function">free</span>      shared  buff/cache   available
Mem:        <span class="token number">3871192</span>     <span class="token number">1210960</span>     <span class="token number">1027116</span>         <span class="token number">508</span>     <span class="token number">1633116</span>     <span class="token number">2392104</span>
Swap:       <span class="token number">4194300</span>       <span class="token number">69120</span>     <span class="token number">4125180</span>
</code></pre> 
<p>free的输出一共有2行，第2行为交换区的信息，分别是交换的总量（total），使用量（used）和有多少空闲的交换区（free），这个比较清楚，不说太多。</p> 
<p>可以看到，free 输出的是一个表格，其中的数值都默认以字节为单位。表格总共有两行 六列，这两行分别是物理内存 Mem 和交换分区 Swap 的使用情况，而六列中，每列数据 的含义分别为:</p> 
<ol><li>第一列，total 是总内存大小；</li><li>第二列，used 是已使用内存的大小，包含了共享内存；</li><li>第三列，free 是未使用内存的大小；</li><li>第四列，shared 是共享内存的大小;</li><li>第五列，buff/cache 是缓存和缓冲区的大小；</li><li>最后一列，available 是新进程可用内存的大小。</li></ol> 
<p>这里尤其注意一下，最后一列的可用内存 available 。available 不仅包含未使用内存，还 包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中。</p> 
<h2><a id="iostat_IO_353"></a>iostat 监视I/O子系统</h2> 
<p>iostat是I/O statistics（输入/输出统计）的缩写，用来动态监视系统的磁盘操作活动。</p> 
<h3><a id="_356"></a>命令格式</h3> 
<p>iostat[参数][时间][次数]</p> 
<h3><a id="_359"></a>命令功能</h3> 
<p>通过iostat方便查看CPU、网卡、tty设备、磁盘、CD-ROM 等等设备的活动情况, 负载信息。</p> 
<h3><a id="_362"></a>命令参数</h3> 
<ol><li>-C 显示CPU使用情况</li><li>-d 显示磁盘使用情况</li><li>-k 以 KB 为单位显示</li><li>-m 以 M 为单位显示</li><li>-N 显示磁盘阵列(LVM) 信息</li><li>-n 显示NFS 使用情况</li><li>-p[磁盘] 显示磁盘和分区的情况</li><li>-t 显示终端和CPU的信息</li><li>-x 显示详细信息</li><li>-V 显示版本信息</li></ol> 
<h3><a id="_374"></a>显示所有设备负载情况</h3> 
<pre><code class="prism language-bash">iostat 
Linux <span class="token number">4.18</span>.0-147.5.1.el8_1.x86_64 <span class="token punctuation">(</span>webim-service-mq<span class="token punctuation">)</span> 	<span class="token number">2021</span>年07月05日 	_x86_64_	<span class="token punctuation">(</span><span class="token number">4</span> CPU<span class="token punctuation">)</span>

avg-cpu:  %user   %nice %system %iowait  %steal   %idle
          <span class="token number">21.50</span>    <span class="token number">0.01</span>   <span class="token number">18.61</span>    <span class="token number">0.01</span>    <span class="token number">0.00</span>   <span class="token number">59.88</span>

Device             tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn
vda               <span class="token number">0.55</span>         <span class="token number">0.25</span>        <span class="token number">17.46</span>    <span class="token number">2416716</span>  <span class="token number">168716452</span>
</code></pre> 
<p>cpu属性值说明：</p> 
<ul><li>%user：CPU处在用户模式下的时间百分比。</li><li>%nice：CPU处在带NICE值的用户模式下的时间百分比。</li><li>%system：CPU处在系统模式下的时间百分比。</li><li>%iowait：CPU等待输入输出完成时间的百分比。</li><li>%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。</li><li>%idle：CPU空闲时间百分比。</li></ul> 
<p>注：如果%iowait的值过高，表示硬盘存在I/O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。</p> 
<p>disk属性值说明：</p> 
<ul><li>rrqm/s：每秒进行 merge 的读操作数目。即 rmerge/s</li><li>wrqm/s：每秒进行 merge 的写操作数目。即wmerge/s</li><li>r/s：每秒完成的读 I/O 设备次数。即 rio/s</li><li>w/s：每秒完成的写 I/O 设备次数。即 wio/s</li><li>rsec/s：每秒读扇区数。即 rsect/s</li><li>wsec/s：每秒写扇区数。即 wsect/s</li><li>rkB/s：每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。</li><li>wkB/s：每秒写K字节数。是 wsect/s 的一半。</li><li>avgrq-sz：平均每次设备I/O操作的数据大小 (扇区)。</li><li>avgqu-sz：平均I/O队列长度。</li><li>await: 平均每次设备I/O操作的等待时间(毫秒)。</li><li>svctm：平均每次设备I/O操作的服务时间 (毫秒)。</li><li>%util：一秒中有百分之多少的时间用于 I/O操作，即被io消耗的cpu百分比</li></ul> 
<p>注：如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。如果avgqu-sz比较大，也表示有当量io在等待。</p> 
<h2><a id="cachestatcachetop__414"></a>cachestat、cachetop 缓存命中情况工具</h2> 
<p>cachestat：提供了整个操作系统缓存的读写命中情况。<br> cachetop：提供了每个进程的缓存命中情况。</p> 
<p>这两个工具都是 bcc 软件包的一部分，它们基于 Linux 内核的 eBPF(extended Berkeley Packet Filters)机制，来跟踪内核中管理的缓存，并输出缓存的使用和命中情况。</p> 
<pre><code class="prism language-bash">yum <span class="token function">install</span> -y bcc-tools
<span class="token comment">#操作完这些步骤，bcc 提供的所有工具就都安装到 /usr/share/bcc/tools 这个目录中了。不过，bcc 软件包默认不会把这些工具配置到系统的 PATH 路径中，所以得自己手动配置:</span>
<span class="token comment"># 配置 PATH 路径</span>
<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span>:/usr/share/bcc/tools
</code></pre> 
<p>配置完，就可以运行 cachestat 和 cachetop 命令了。比如，下面就是一个 cachestat 的运行界面，它以 1 秒的时间间隔，输出了 3 组缓存统计数据:</p> 
<pre><code class="prism language-bash">cachestat <span class="token number">1</span> <span class="token number">3</span>
HITS   MISSES  DIRTIES HITRATIO   BUFFERS_MB  CACHED_MB
 <span class="token number">0</span>       <span class="token number">0</span>        <span class="token number">0</span>     <span class="token number">0.00</span>%         <span class="token number">2</span>        <span class="token number">2114</span>
 <span class="token number">0</span>       <span class="token number">0</span>        <span class="token number">0</span>     <span class="token number">0.00</span>%         <span class="token number">2</span>        <span class="token number">2114</span>
<span class="token number">5690</span>     <span class="token number">0</span>        <span class="token number">0</span>   <span class="token number">100.00</span>%         <span class="token number">2</span>        <span class="token number">2114</span>
</code></pre> 
<p>可以看到，cachestat 的输出其实是一个表格。每行代表一组数据，而每一列代表不同的缓存统计指标。这些指标从左到右依次表示：</p> 
<blockquote> 
 <p>我得这个版本没有显示总的io数</p> 
</blockquote> 
<ul><li>TOTAL ，表示总的 I/O 次数</li><li>HITS：表示缓存命中的次数</li><li>MISSES：表示缓存未命中的次数</li><li>DIRTIES：表示新增到缓存中的脏页数</li><li>BUFFERS_MB：表示 Buffers 的大小，以 MB 为单位</li><li>CACHED_MB：表示 Cache 的大小，以 MB 为单位</li></ul> 
<p>接下来再来看一个 cachetop 的运行界面：</p> 
<pre><code class="prism language-bash">cachetop
<span class="token number">14</span>:13:41 Buffers MB: <span class="token number">2</span> / Cached MB: <span class="token number">2129</span> / Sort: HITS / Order: descending
PID      <span class="token environment constant">UID</span>      CMD              HITS     MISSES   DIRTIES  READ_HIT%  WRITE_HIT%
<span class="token number">60894</span>    www	  php              <span class="token number">5505</span>        <span class="token number">0</span>        <span class="token number">0</span>     <span class="token number">100.0</span>%       <span class="token number">0.0</span>%
<span class="token number">60934</span>    www	  supervisord      <span class="token number">1370</span>        <span class="token number">0</span>        <span class="token number">0</span>     <span class="token number">100.0</span>%       <span class="token number">0.0</span>%
<span class="token number">60934</span>    www	  php              <span class="token number">1111</span>        <span class="token number">0</span>        <span class="token number">0</span>     <span class="token number">100.0</span>%       <span class="token number">0.0</span>%
</code></pre> 
<p>它的输出跟 top 类似，默认按照缓存的命中次数(HITS)排序，展示了每个进程的缓存命 中情况。具体到每一个指标，这里的 HITS、MISSES 和 DIRTIES ，跟 cachestat 里的含义一样，分别代表间隔时间内的缓存命中次数、未命中次数以及新增到缓存中的脏页数。</p> 
<p>而 READ_HIT 和 WRITE_HIT ，分别表示读和写的缓存命中率。</p> 
<h2><a id="pcstat__458"></a>pcstat 查看文件在内存中的缓存大小以及缓存比例</h2> 
<p>pcstat 是一个基于 Go 语言开发的工具，所以安装它之前，首先应该安装 Go 语言</p> 
<pre><code class="prism language-bash"> go get github.com/tobert/pcstat/pcstat
</code></pre> 
<p>全部安装完成后，你就可以运行 pcstat 来查看文件的缓存情况了。比如，下面就是一个 pcstat 运行的示例，它展示了 /bin/ls 这个文件的缓存情况:</p> 
<pre><code class="prism language-bash">pcstat /bin/ls
+---------+----------------+------------+-----------+---------+
<span class="token operator">|</span> Name    <span class="token operator">|</span> Size <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>   <span class="token operator">|</span> Pages      <span class="token operator">|</span> Cached    <span class="token operator">|</span> Percent <span class="token operator">|</span>
<span class="token operator">|</span>---------+----------------+------------+-----------+---------<span class="token operator">|</span>
<span class="token operator">|</span> /bin/ls <span class="token operator">|</span> <span class="token number">157376</span>         <span class="token operator">|</span> <span class="token number">39</span>         <span class="token operator">|</span> <span class="token number">0</span>       <span class="token operator">|</span> 000.000 <span class="token operator">|</span>
+---------+----------------+------------+-----------+---------+
</code></pre> 
<p>这个输出中，Cached 就是 /bin/ls 在缓存中的大小，而 Percent 则是缓存的百分比。你看到它们都是 ，这说明 /bin/ls 并不在缓存中。</p> 
<p>接着，如果你执行一下 ls 命令，再运行相同的命令来查看的话，就会发现 /bin/ls 都在缓存中了：</p> 
<pre><code class="prism language-bash"><span class="token function">ls</span>
pcstat /bin/ls
+---------+----------------+------------+-----------+---------+
<span class="token operator">|</span> Name    <span class="token operator">|</span> Size <span class="token punctuation">(</span>bytes<span class="token punctuation">)</span>   <span class="token operator">|</span> Pages      <span class="token operator">|</span> Cached    <span class="token operator">|</span> Percent <span class="token operator">|</span>
<span class="token operator">|</span>---------+----------------+------------+-----------+---------<span class="token operator">|</span>
<span class="token operator">|</span> /bin/ls <span class="token operator">|</span> <span class="token number">157376</span>         <span class="token operator">|</span> <span class="token number">39</span>         <span class="token operator">|</span> <span class="token number">13</span>        <span class="token operator">|</span> 033.333 <span class="token operator">|</span>
+---------+----------------+------------+-----------+---------+
</code></pre> 
<h2><a id="memleak__488"></a>memleak 检测内存泄漏的工具</h2> 
<p>memleak 可以跟踪系统或 指定进程的内存分配、释放请求，然后定期输出一个未释放内存和相应调用栈的汇总情况 (默认 5 秒)。</p> 
<p>当然，memleak 是 bcc 软件包中的一个工具，我们一开始就装好了，执行/usr/share/bcc/tools/memleak 就可以运行它。</p> 
<pre><code class="prism language-bash"><span class="token comment"># -a 表示显示每个内存分配请求的大小以及地址</span>
<span class="token comment"># -p 指定案例应用的 PID 号</span>
/usr/share/bcc/tools/memleak -p <span class="token number">23664</span> -a
</code></pre> 
<h2><a id="iostat__IO__499"></a>iostat 磁盘 I/O 观测</h2> 
<p>iostat 是最常用的磁盘 I/O 性能观测工具，它提供了每个磁盘的使用率、IOPS、吞吐量等 各种常见的性能指标，当然，这些指标实际上来自 /proc/diskstats。</p> 
<p>iostat 的输出界面如下</p> 
<pre><code class="prism language-bash"><span class="token comment"># -d -x 表示显示所有磁盘 I/O 的指标</span>
iostat -d -x <span class="token number">1</span>
Linux <span class="token number">4.18</span>.0-147.5.1.el8_1.x86_64 <span class="token punctuation">(</span>webim-service-mq<span class="token punctuation">)</span> 	<span class="token number">2021</span>年07月29日 	_x86_64_	<span class="token punctuation">(</span><span class="token number">4</span> CPU<span class="token punctuation">)</span>

Device            r/s     w/s     rkB/s     wkB/s   rrqm/s   wrqm/s  %rrqm  %wrqm r_await w_await aqu-sz rareq-sz wareq-sz  svctm  %util
vda              <span class="token number">0.01</span>    <span class="token number">0.56</span>      <span class="token number">0.47</span>     <span class="token number">23.48</span>     <span class="token number">0.00</span>     <span class="token number">0.07</span>   <span class="token number">3.77</span>  <span class="token number">11.71</span>   <span class="token number">14.87</span>   <span class="token number">37.98</span>   <span class="token number">0.02</span>    <span class="token number">38.50</span>    <span class="token number">42.24</span>   <span class="token number">0.37</span>   <span class="token number">0.02</span>

Device            r/s     w/s     rkB/s     wkB/s   rrqm/s   wrqm/s  %rrqm  %wrqm r_await w_await aqu-sz rareq-sz wareq-sz  svctm  %util
vda              <span class="token number">0.00</span>    <span class="token number">0.00</span>      <span class="token number">0.00</span>      <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>    <span class="token number">0.00</span>    <span class="token number">0.00</span>   <span class="token number">0.00</span>     <span class="token number">0.00</span>     <span class="token number">0.00</span>   <span class="token number">0.00</span>   <span class="token number">0.00</span>

</code></pre> 
<p>从这里可以看到，iostat 提供了非常丰富的性能指标。第一列的 Device 表示磁盘设备的名字，其他各列指标，虽然数量较多，但是每个指标的含义都很重要。为了方便你理 解，我把它们总结成了一个表格。<br> <img src="https://images2.imgbox.com/ce/07/QcSabUnQ_o.jpg" alt="在这里插入图片描述"><br> 这些指标中，要注意：</p> 
<ul><li>%util ，就是我们前面提到的磁盘 I/O 使用率；</li><li>r/s+ w/s ，就是 IOPS；</li><li>rkB/s+wkB/s ，就是吞吐量；</li><li>r_await+w_await ，就是响应时间</li></ul> 
<p>在观测指标时，也别忘了结合请求的大小( rareq-sz 和 wareq-sz)一起分析。</p> 
<h2><a id="_IO__526"></a>进程 I/O 观测</h2> 
<p>除了每块磁盘的 I/O 情况，每个进程的 I/O 情况也是我们需要关注的重点。</p> 
<p>上面提到的 iostat 只提供磁盘整体的 I/O 性能数据，缺点在于，并不能知道具体是哪些进程在进行磁盘读写。要观察进程的 I/O 情况，还可以使用 pidstat 和 iotop 这两个工具。</p> 
<p>pidstat 是我们的老朋友了，这里我就不再啰嗦它的功能了。给它加上 -d 参数，你就可以 看到进程的 I/O 情况，如下所示:</p> 
<pre><code class="prism language-bash">pidstat -d <span class="token number">1</span>
<span class="token number">17</span>时24分39秒   <span class="token environment constant">UID</span>       PID   kB_rd/s   kB_wr/s kB_ccwr/s  Command
<span class="token number">17</span>时24分44秒     <span class="token number">0</span>       <span class="token number">266</span>      <span class="token number">0.00</span>      <span class="token number">0.80</span>      <span class="token number">0.00</span>  jbd2/vda1-8
<span class="token number">17</span>时24分44秒     <span class="token number">0</span>       <span class="token number">504</span>      <span class="token number">0.00</span>     <span class="token number">12.80</span>      <span class="token number">0.00</span>  jbd2/vdb-8
<span class="token number">17</span>时24分44秒    <span class="token number">27</span>      <span class="token number">1387</span>      <span class="token number">0.00</span>      <span class="token number">0.80</span>      <span class="token number">0.00</span>  mysqld
<span class="token number">17</span>时24分44秒   <span class="token number">997</span>      <span class="token number">8908</span>      <span class="token number">0.00</span>      <span class="token number">1.60</span>      <span class="token number">0.00</span>  nginx
<span class="token number">17</span>时24分44秒  <span class="token number">1000</span>     <span class="token number">25621</span>      <span class="token number">0.00</span>     <span class="token number">14.40</span>      <span class="token number">0.00</span>  php-fpm
<span class="token number">17</span>时24分44秒  <span class="token number">1000</span>     <span class="token number">26288</span>      <span class="token number">0.00</span>     <span class="token number">17.60</span>      <span class="token number">0.00</span>  php-fpm

</code></pre> 
<p>从 pidstat 的输出你能看到，它可以实时查看每个进程的 I/O 情况，包括下面这些内容。</p> 
<ul><li>用户 ID(UID)和进程 ID(PID) 。</li><li>每秒读取的数据大小(kB_rd/s) ，单位是 KB。</li><li>每秒发出的写请求数据大小(kB_wr/s) ，单位是 KB。</li><li>每秒取消的写请求数据大小(kB_ccwr/s) ，单位是 KB。</li><li>块 I/O 延迟(iodelay)，包括等待同步块 I/O 和换入块 I/O 结束的时间，单位是时钟周期。</li></ul> 
<h2><a id="iotop__IO__552"></a>iotop 按照 I/O 大小对进程排序</h2> 
<p>iotop。它是一个类似于 top 的工具，你可以按照 I/O 大小对进程排序，然后找到 I/O 较大的那些进程。</p> 
<pre><code class="prism language-bash">iotop
Total DISK READ <span class="token builtin class-name">:</span>	<span class="token number">0.00</span> B/s <span class="token operator">|</span> Total DISK WRITE <span class="token builtin class-name">:</span>      <span class="token number">35.27</span> K/s
Actual DISK READ:	<span class="token number">0.00</span> B/s <span class="token operator">|</span> Actual DISK WRITE:     <span class="token number">368.40</span> K/s
TID  PRIO  <span class="token environment constant">USER</span>     DISK READ  DISK WRITE  SWAPIN     IO<span class="token operator">&gt;</span>    COMMAND                                                                                                       
<span class="token number">16811</span> be/2 root        <span class="token number">0.00</span> B/s    <span class="token number">3.92</span> K/s  <span class="token number">0.00</span> %  <span class="token number">0.00</span> % AliYunDun
</code></pre> 
<p>从这个输出，可以看到，前两行分别表示，进程的磁盘读写大小总数和磁盘真实的读写 大小总数。因为缓存、缓冲区、I/O 合并等因素的影响，它们可能并不相等。</p> 
<p>剩下的部分，则是从各个角度来分别表示进程的 I/O 情况，包括线程 ID、I/O 优先级、每 秒读磁盘的大小、每秒写磁盘的大小、换入和等待 I/O 的时钟百分比等。</p> 
<h2><a id="lsof__565"></a>lsof 查看进程打开文件列表</h2> 
<pre><code class="prism language-bash"><span class="token function">lsof</span> -p <span class="token number">23664</span>
COMMAND    PID <span class="token environment constant">USER</span>   FD      TYPE   DEVICE SIZE/OFF      NODE NAME
imsocket <span class="token number">23664</span> root  cwd       DIR    <span class="token number">253,1</span>       <span class="token number">56</span> <span class="token number">302019283</span> /data/imsocket
imsocket <span class="token number">23664</span> root  rtd       DIR    <span class="token number">253,1</span>      <span class="token number">272</span>       <span class="token number">128</span> /
imsocket <span class="token number">23664</span> root  txt       REG    <span class="token number">253,1</span> <span class="token number">13773370</span> <span class="token number">302024957</span> /data/imsocket/imsocket
imsocket <span class="token number">23664</span> root    0r     FIFO     <span class="token number">0,13</span>      0t0  <span class="token number">61209341</span> pipe
imsocket <span class="token number">23664</span> root    1w     FIFO     <span class="token number">0,13</span>      0t0  <span class="token number">61209342</span> pipe
imsocket <span class="token number">23664</span> root    2w     FIFO     <span class="token number">0,13</span>      0t0  <span class="token number">61209343</span> pipe
imsocket <span class="token number">23664</span> root    4u  a_inode     <span class="token number">0,14</span>        <span class="token number">0</span>     <span class="token number">11876</span> <span class="token punctuation">[</span>eventpoll<span class="token punctuation">]</span>
imsocket <span class="token number">23664</span> root    5r     FIFO     <span class="token number">0,13</span>      0t0  <span class="token number">61210406</span> pipe
imsocket <span class="token number">23664</span> root    6w     FIFO     <span class="token number">0,13</span>      0t0  <span class="token number">61210406</span> pipe
imsocket <span class="token number">23664</span> root    7u     sock      <span class="token number">0,9</span>      0t0  <span class="token number">61210408</span> protocol: TCP
imsocket <span class="token number">23664</span> root    9u     IPv4 <span class="token number">61211103</span>      0t0       TCP nsqHost:43566-<span class="token operator">&gt;</span>nsqHost:PowerAlert-nsa <span class="token punctuation">(</span>ESTABLISHED<span class="token punctuation">)</span>
imsocket <span class="token number">23664</span> root   10u     IPv6 <span class="token number">61212017</span>      0t0       TCP *:9501 <span class="token punctuation">(</span>LISTEN<span class="token punctuation">)</span>
imsocket <span class="token number">23664</span> root   11u     IPv4 <span class="token number">61209344</span>      0t0       TCP nsqHost:43568-<span class="token operator">&gt;</span>nsqHost:PowerAlert-nsa <span class="token punctuation">(</span>ESTABLISHED<span class="token punctuation">)</span>
imsocket <span class="token number">23664</span> root   12u     IPv4 <span class="token number">61212019</span>      0t0       TCP nsqHost:43570-<span class="token operator">&gt;</span>nsqHost:PowerAlert-nsa <span class="token punctuation">(</span>ESTABLISHED<span class="token punctuation">)</span>
imsocket <span class="token number">23664</span> root   13u     IPv4 <span class="token number">61212020</span>      0t0       TCP nsqHost:43572-<span class="token operator">&gt;</span>nsqHost:PowerAlert-nsa <span class="token punctuation">(</span>ESTABLISHED<span class="token punctuation">)</span>
imsocket <span class="token number">23664</span> root   14u     IPv4 <span class="token number">61209347</span>      0t0       TCP nsqHost:43574-<span class="token operator">&gt;</span>nsqHost:PowerAlert-nsa <span class="token punctuation">(</span>ESTABLISHED<span class="token punctuation">)</span>
</code></pre> 
<p>COMMAND：进程的名称！</p> 
<ul><li>PID： 进程标识符！</li><li>USER： 进程所有者！</li><li>FD： 文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等！</li><li>TYPE： 文件类型，如DIR、REG,MEM等！</li><li>DEVICE： 指定磁盘的名称！</li><li>SIZE： 文件的大小</li><li>NODE： 索引节点（文件在磁盘上的标识）</li><li>NAME： 打开的文件名称</li></ul> 
<p>FD 列中的文件描述符意义：</p> 
<ul><li>cwd 表示应用程序的当前工作目录，也是该应用程序启动的目录，除非它本身对这个目录进行更改</li><li>txt 表示该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的/sbin/init程序</li><li>数值 表示应用程序的文件描述符，打开该文件时返回的整数。如上的最后一行文件/dev/initctl，其文件描述符为 10；dev/null的描述符为2！</li><li>u 表示该文件被打开并处于读取/写入模式，而不是只读®或只写(w)模式。大写的W表示该应用程序具有对整个文件的写锁。该文件描述符用于确保每次只能打开一个应用程序实例！</li><li>初始打开每个应用程序时，都具有三个文件描述符，从0到2，分别表示标准输入、输出和错误流。所以大多数应用程序所打开的文件的FD都是从3开始。</li></ul> 
<p>Type 列中的文件描述符意义：</p> 
<ul><li>REG 表示文件</li><li>DIR 表示目录</li><li>CHR 表示字符设备</li><li>BLK 表示和块设备</li><li>UNIX 表示UNIX 域套接字</li><li>FIFO 表示先进先出(FIFO)队列</li><li>IPv4 表示网际协议(IP)套接字</li></ul> 
<h2><a id="filetop__616"></a>filetop 跟踪内核中文件的读写情况</h2> 
<p>它是 bcc 软件包的一部分，基于 Linux 内核的 eBPF(extended Berkeley Packet Filters)机制，主要跟踪内核中文件的读写情况，并 输出线程 ID(TID)、读写大小、读写类型以及文件名称。</p> 
<pre><code class="prism language-bash"><span class="token comment"># -C 选项表示输出新内容时不清空屏幕</span>
filetop -C
TID    COMM             READS  WRITES R_Kb    W_Kb    T FILE
<span class="token number">27168</span>  supervisord       <span class="token number">0</span>      <span class="token number">1</span>      <span class="token number">0</span>       <span class="token number">0</span>      R supervisord.log-20210728
<span class="token number">156999</span> php               <span class="token number">8</span>      <span class="token number">0</span>      <span class="token number">32</span>      <span class="token number">0</span>      R openssl.cnf
<span class="token number">156999</span> php               <span class="token number">4</span>      <span class="token number">0</span>      <span class="token number">32</span>      <span class="token number">0</span>      R SymfonyStyle.php
<span class="token number">31177</span>  AliYunDun         <span class="token number">4</span>      <span class="token number">0</span>      <span class="token number">31</span>      <span class="token number">0</span>      R <span class="token function">stat</span>
<span class="token number">156999</span> php               <span class="token number">3</span>      <span class="token number">0</span>      <span class="token number">24</span>      <span class="token number">0</span>      R .env
<span class="token number">156999</span> php               <span class="token number">4</span>      <span class="token number">0</span>      <span class="token number">16</span>      <span class="token number">0</span>      R hosts
<span class="token number">156999</span> php               <span class="token number">4</span>      <span class="token number">0</span>      <span class="token number">16</span>      <span class="token number">0</span>      R opensslcnf.txt

</code></pre> 
<p>我们会看到，filetop 输出了 8 列内容，分别是线程 ID、线程命令行、读写次数、读写的大 小(单位 KB)、文件类型以及读写的文件名称</p> 
<p>多观察一会儿，就会发现，每隔一段时间，线程号为 156999 的 php 应用就会先写入的 openssl.cnf 文件，再大量地读。</p> 
<p>运行下面的ps命令查看一下：</p> 
<pre><code class="prism language-bash"><span class="token function">ps</span> -efT <span class="token operator">|</span><span class="token function">grep</span> <span class="token number">156999</span>
www       <span class="token number">156999</span>  <span class="token number">156999</span>   <span class="token number">27168</span>  <span class="token number">0</span> <span class="token number">17</span>:37 ?        00:00:00 /usr/bin/php /data/api/artisan user-cache
</code></pre> 
<p>我们看到，这个线程正是案例应用 156999 的线程。终于可以先松一口气，不过还没完， filetop 只给出了文件名称，却没有文件路径，还得继续找啊。</p> 
<p>在使用opensnoop工具 。它同属于 bcc 软件包，可以动态跟踪内核中的 open 系统调用。这样，我们就可以找出这些文件的路径。</p> 
<pre><code class="prism language-bash">opensnoop

</code></pre> 
<h2><a id="fio__IO__651"></a>fio 文件系统和磁盘 I/O 性能基准测试工具</h2> 
<p>fio(Flexible I/O Tester)正是最常用的文件系统和磁盘 I/O 性能基准测试工具。它提供了大量的可定制化选项，可以用来测试，裸盘或者文件系统在各种场景下的 I/O 性能，包 括了不同块大小、不同 I/O 引擎以及是否使用缓存等场景。<br> 安装</p> 
<pre><code class="prism language-bash">yum <span class="token function">install</span> -y fio
</code></pre> 
<p>安装完成后，就可以执行 man fio 查询它的使用方法。</p> 
<p>fio 的选项非常多， 我们通过几个常见场景的测试方法，介绍一些最常用的选项。这些常 见场景包括随机读、随机写、顺序读以及顺序写等，你可以执行下面这些命令来测试：</p> 
<pre><code class="prism language-bash"><span class="token comment"># 随机读</span>
fio -name<span class="token operator">=</span>randread -direct<span class="token operator">=</span><span class="token number">1</span> -iodepth<span class="token operator">=</span><span class="token number">64</span> -rw<span class="token operator">=</span>randread -ioengine<span class="token operator">=</span>libaio -bs<span class="token operator">=</span>4k -size<span class="token operator">=</span>1G -

<span class="token comment"># 随机写</span>
fio -name<span class="token operator">=</span>randwrite -direct<span class="token operator">=</span><span class="token number">1</span> -iodepth<span class="token operator">=</span><span class="token number">64</span> -rw<span class="token operator">=</span>randwrite -ioengine<span class="token operator">=</span>libaio -bs<span class="token operator">=</span>4k -size<span class="token operator">=</span>1G

<span class="token comment"># 顺序读</span>
fio -name<span class="token operator">=</span>read -direct<span class="token operator">=</span><span class="token number">1</span> -iodepth<span class="token operator">=</span><span class="token number">64</span> -rw<span class="token operator">=</span>read -ioengine<span class="token operator">=</span>libaio -bs<span class="token operator">=</span>4k -size<span class="token operator">=</span>1G -numjobs<span class="token operator">=</span><span class="token number">10</span>

<span class="token comment"># 顺序写</span>
fio -name<span class="token operator">=</span>write -direct<span class="token operator">=</span><span class="token number">1</span> -iodepth<span class="token operator">=</span><span class="token number">64</span> -rw<span class="token operator">=</span>write -ioengine<span class="token operator">=</span>libaio -bs<span class="token operator">=</span>4k -size<span class="token operator">=</span>1G -numjob

</code></pre> 
<p>在这其中，有几个参数需要我们重点关注一下。</p> 
<ul><li>direct，表示是否跳过系统缓存。上面示例中，我设置的 1 ，就表示跳过系统缓存。</li><li>iodepth，表示使用异步 I/O(asynchronous I/O，简称 AIO)时，同时发出的 I/O 请 求上限。在上面的示例中，我设置的是 64。</li><li>rw，表示 I/O 模式。上面的示例中， read/write 分别表示顺序读 / 写，而 randread/randwrite 则分别表示随机读 / 写。</li><li>ioengine，表示 I/O 引擎，它支持同步(sync)、异步(libaio)、内存映射 (mmap)、网络(net)等各种 I/O 引擎。上面示例中，设置的 libaio 表示使用异 步 I/O。</li><li>bs，表示 I/O 的大小。示例中，我设置成了 4K(这也是默认值)。</li><li>filename，表示文件路径，当然，它可以是磁盘路径(测试磁盘性能)，也可以是文件 路径(测试文件系统性能)。示例中，我把它设置成了磁盘 /dev/sdb。不过注意，用磁盘路径测试写，会破坏这个磁盘中的文件系统，所以在使用前，一定要事先做好数据备份。</li></ul> 
<h2><a id="pktgen_Linux_684"></a>pktgen Linux网络测试工具</h2> 
<p>Linux 内核自带的高性能网络测试工具 pktgen。 pktgen 支持丰富的自定义选项，方便你根据实际需要构造所需网络包，从而更准确地测 试出目标服务器的性能。</p> 
<p>不过，在 Linux 系统中，并不能直接找到 pktgen 命令。因为 pktgen 作为一个内核线程来运行，需要加载 pktgen 内核模块后，再通过 /proc 文件系统来交互。下面就是 pktgen 启动的两个内核线程和 /proc 文件系统的交互文件：</p> 
<pre><code class="prism language-bash">modprobe pktgen
<span class="token function">ps</span> -ef <span class="token operator">|</span> <span class="token function">grep</span> pktgen<span class="token operator">|</span> g rep-v <span class="token function">grep</span> <span class="token number">3</span> 
root <span class="token number">26384</span> <span class="token number">2</span> <span class="token number">0</span> 06:17 ?    00:00:00 <span class="token punctuation">[</span>kpktgend_0<span class="token punctuation">]</span>
root <span class="token number">26385</span> <span class="token number">2</span> <span class="token number">0</span> 06:17 ?    00:00:00 <span class="token punctuation">[</span>kpktgend_1<span class="token punctuation">]</span>
<span class="token function">ls</span> /proc/net/pktgen/
kpktgend_0 kpktgend_1 pgctrl
</code></pre> 
<p>pktgen 在每个 CPU 上启动一个内核线程，并可以通过 /proc/net/pktgen 下面的同名文件，跟这些线程交互；而 pgctrl 则主要用来控制这次测试的开启和停止。</p> 
<blockquote> 
 <p>如果 modprobe 命令执行失败，说明你的内核没有配置<br> CONFIG_NET_PKTGEN 选项。这就需要你配置 pktgen 内核模块(即<br> CONFIG_NET_PKTGEN=m)后，重新编译内核，才可以使用。</p> 
</blockquote> 
<p>在使用 pktgen 测试网络性能时，需要先给每个内核线程 kpktgend_X 以及测试网卡，配 置 pktgen 选项，然后再通过 pgctrl 启动测试。</p> 
<h3><a id="TCPUDP__706"></a>TCP/UDP 性能压测</h3> 
<p>说到 TCP 和 UDP 的测试，已经很熟悉了，甚至可能一下子就能想到相应的测试工具，比如 iperf 或者 netperf。</p> 
<p>iperf 和 netperf 都是最常用的网络性能测试工具，测试 TCP 和 UDP 的吞吐量。它们都以客户端和服务器通信的方式，测试一段时间内的平均吞吐量。</p> 
<p>接下来，我们就以 iperf 为例，看一下 TCP 性能的测试方法。目前，iperf 的最新版本为 iperf3，你可以运行下面的命令来安装：</p> 
<pre><code class="prism language-bash">yum <span class="token function">install</span> iperf3

</code></pre> 
<p>然后，在目标机器上启动 iperf 服务端：</p> 
<pre><code class="prism language-bash"><span class="token comment"># -s 表示启动服务端，-i 表示汇报间隔，-p 表示监听端口</span>
iperf3 -s -i <span class="token number">1</span> -p <span class="token number">10000</span>
</code></pre> 
<p>接着，在另一台机器上运行 iperf 客户端，运行测试：</p> 
<pre><code class="prism language-bash"><span class="token comment"># -c 表示启动客户端，192.168.0.30 为目标服务器的 IP 2 # -b 表示目标带宽 (单位是 bits/s)</span>
<span class="token comment"># -t 表示测试时间</span>
<span class="token comment"># -P 表示并发数，-p 表示目标服务器监听端口</span>
iperf3 -c <span class="token number">172.31</span>.36.80 -b 10G -t <span class="token number">15</span> -P <span class="token number">2</span> -p <span class="token number">10000</span>
</code></pre> 
<p>稍等一会儿(15 秒)测试结束后，回到目标服务器，查看 iperf 的报告：</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span> ID<span class="token punctuation">]</span> Interval           Transfer     Bitrate
<span class="token punctuation">[</span>  <span class="token number">5</span><span class="token punctuation">]</span>   <span class="token number">0.00</span>-15.04  sec  <span class="token number">1.51</span> GBytes   <span class="token number">860</span> Mbits/sec                  receiver
<span class="token punctuation">[</span>  <span class="token number">8</span><span class="token punctuation">]</span>   <span class="token number">0.00</span>-15.04  sec  <span class="token number">1.24</span> GBytes   <span class="token number">709</span> Mbits/sec                  receiver
<span class="token punctuation">[</span>SUM<span class="token punctuation">]</span>   <span class="token number">0.00</span>-15.04  sec  <span class="token number">2.75</span> GBytes  <span class="token number">1.57</span> Gbits/sec                  receiver
</code></pre> 
<p>最后的 SUM 行就是测试的汇总结果，包括测试时间、数据传输量以及带宽等。按照发送和接收，这一部分又分为了 sender 和 receiver 两行。</p> 
<p>从测试结果你可以看到，这台机器 TCP 接收的带宽(吞吐量)为 1.57 Gb/s， 跟目标的 10Gb/s 相比，还是有些差距的。</p> 
<h2><a id="HTTP__742"></a>HTTP 性能压测</h2> 
<p>从传输层再往上，到了应用层。有的应用程序，会直接基于 TCP 或 UDP 构建服务。当 然，也有大量的应用，基于应用层的协议来构建服务，HTTP 就是最常用的一个应用层协 议。比如，常用的 Apache、Nginx 等各种 Web 服务，都是基于 HTTP。</p> 
<p>要测试 HTTP 的性能，也有大量的工具可以使用，比如 ab、webbench 等，都是常用的 HTTP 压力测试工具。其中，ab 是 Apache 自带的 HTTP 压测工具，主要测试 HTTP 服 务的每秒请求数、请求延迟、吞吐量以及请求延迟的分布情况等。</p> 
<p>运行下面的命令，你就可以安装 ab 工具：</p> 
<pre><code class="prism language-bash">yum <span class="token function">install</span> -y httpd-tools
</code></pre> 
<p>运行 ab 命令，测试 Nginx 的性能：</p> 
<pre><code class="prism language-bash"><span class="token comment"># -c 表示并发请求数为 1000，-n 表示总的请求数为 10000</span>
ab -c <span class="token number">1000</span> -n <span class="token number">10000</span> http://172.31.36.80/
<span class="token punctuation">..</span><span class="token punctuation">..</span>
Server Software:        nginx
Server Hostname:        <span class="token number">172.31</span>.36.80
Server Port:            <span class="token number">80</span>

Document Path:          /
Document Length:        <span class="token number">3196</span> bytes

Concurrency Level:      <span class="token number">1000</span>
Time taken <span class="token keyword">for</span> tests:   <span class="token number">0.462</span> seconds
Complete requests:      <span class="token number">10000</span>
Failed requests:        <span class="token number">4</span>
   <span class="token punctuation">(</span>Connect: <span class="token number">0</span>, Receive: <span class="token number">0</span>, Length: <span class="token number">0</span>, Exceptions: <span class="token number">4</span><span class="token punctuation">)</span>
Total transferred:      <span class="token number">34460000</span> bytes
HTML transferred:       <span class="token number">31960000</span> bytes
Requests per second:    <span class="token number">21634.86</span> <span class="token punctuation">[</span><span class="token comment">#/sec] (mean)</span>
Time per request:       <span class="token number">46.222</span> <span class="token punctuation">[</span>ms<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean<span class="token punctuation">)</span>
Time per request:       <span class="token number">0.046</span> <span class="token punctuation">[</span>ms<span class="token punctuation">]</span> <span class="token punctuation">(</span>mean, across all concurrent requests<span class="token punctuation">)</span>
Transfer rate:          <span class="token number">72806.37</span> <span class="token punctuation">[</span>Kbytes/sec<span class="token punctuation">]</span> received

Connection Times <span class="token punctuation">(</span>ms<span class="token punctuation">)</span>
              min  mean<span class="token punctuation">[</span>+/-sd<span class="token punctuation">]</span> median   max
Connect:        <span class="token number">0</span>   <span class="token number">12</span>   <span class="token number">1.7</span>     <span class="token number">12</span>      <span class="token number">18</span>
Processing:     <span class="token number">5</span>   <span class="token number">16</span>   <span class="token number">8.5</span>     <span class="token number">15</span>     <span class="token number">233</span>
Waiting:        <span class="token number">0</span>   <span class="token number">13</span>   <span class="token number">8.4</span>     <span class="token number">11</span>     <span class="token number">230</span>
Total:         <span class="token number">14</span>   <span class="token number">28</span>   <span class="token number">8.6</span>     <span class="token number">27</span>     <span class="token number">247</span>

Percentage of the requests served within a certain <span class="token function">time</span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span>
  <span class="token number">50</span>%     <span class="token number">27</span>
  <span class="token number">66</span>%     <span class="token number">29</span>
  <span class="token number">75</span>%     <span class="token number">31</span>
  <span class="token number">80</span>%     <span class="token number">31</span>
  <span class="token number">90</span>%     <span class="token number">34</span>
  <span class="token number">95</span>%     <span class="token number">36</span>
  <span class="token number">98</span>%     <span class="token number">40</span>
  <span class="token number">99</span>%     <span class="token number">41</span>
 <span class="token number">100</span>%    <span class="token number">247</span> <span class="token punctuation">(</span>longest request<span class="token punctuation">)</span>
 
</code></pre> 
<p>可以看到，ab 的测试结果分为三个部分，分别是请求汇总、连接时间汇总还有请求延迟汇总。以上面的结果为例，我们具体来看。</p> 
<p>在请求汇总部分，可以看到：</p> 
<ul><li>Requests per second: 21634.86</li><li>每个请求的延迟(Time per request)分为两行，第一行的 46.222 ms 表示平均延迟，包括了线程运行的调度时间和网络请求响应时间，而下一行的 0.046 ms ，则表示实际请求 的响应时间；</li><li>Transfer rate 表示吞吐量(BPS)为 72806.37 KB/s。</li></ul> 
<p>连接时间汇总部分，则是分别展示了建立连接、请求、等待以及汇总等的各类时间，包括最小、最大、平均以及中值处理时间。</p> 
<p>最后的请求延迟汇总部分，则给出了不同时间段内处理请求的百分比，比如， 90% 的请 求，都可以在 34ms 内完成。</p> 
<h2><a id="_808"></a>应用负载性能</h2> 
<p>当使用 iperf 或者 ab 等测试工具，得到 TCP、HTTP 等的性能数据后，这些数据是否就能表示应用程序的实际性能呢？我想，那肯定不是的。</p> 
<p>比如，应用程序基于 HTTP 协议，为最终用户提供一个 Web 服务。这时，使用 ab 工具，可以得到某个页面的访问性能，但这个结果跟用户的实际请求，很可能不一致。因 为用户请求往往会附带着各种各种的负载（payload），而这些负载会影响 Web 应用程序内部的处理逻辑，从而影响最终性能。</p> 
<p>那么，为了得到应用程序的实际性能，就要求性能工具本身可以模拟用户的请求负载，而 iperf、ab 这类工具就无能为力了。但是，我们还可以用 wrk、TCPCopy、Jmeter 或者 LoadRunner 等实现这个目标。</p> 
<p>以 wrk 为例，它是一个 HTTP 性能测试工具，内置了 LuaJIT，方便你根据实际需求，生成所需的请求负载，或者自定义响应的处理方法。</p> 
<p>wrk 工具本身不提供 yum 或 apt 的安装方法，需要通过源码编译来安装。</p> 
<pre><code class="prism language-bash"><span class="token function">git</span> clone https://github.com/wg/wrk.git
<span class="token builtin class-name">cd</span> wrk
<span class="token function">make</span>
<span class="token function">cp</span> wrk /usr/local/bin/
</code></pre> 
<p>wrk 的命令行参数比较简单。比如，我们可以用 wrk ，来重新测一下前面已经启动的 Nginx 的性能。</p> 
<pre><code class="prism language-bash"><span class="token comment"># -c 表示并发连接数 1000，-t 表示线程数为 2</span>
wrk -c <span class="token number">1000</span> -t <span class="token number">2</span> http://api.tickeup.com/oss/getstsinfo/
Running 10s <span class="token builtin class-name">test</span> @ http://api.tickeup.com/oss/getstsinfo/
  <span class="token number">2</span> threads and <span class="token number">1000</span> connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency   <span class="token number">286</span>.14ms  <span class="token number">207</span>.38ms   <span class="token number">1</span>.81s    <span class="token number">65.46</span>%
    Req/Sec     <span class="token number">1</span>.49k     <span class="token number">1</span>.16k    <span class="token number">6</span>.24k    <span class="token number">77.60</span>%
  <span class="token number">25253</span> requests <span class="token keyword">in</span> <span class="token number">10</span>.03s, <span class="token number">7</span>.60MB <span class="token builtin class-name">read</span>
  Socket errors: connect <span class="token number">0</span>, <span class="token builtin class-name">read</span> <span class="token number">0</span>, <span class="token function">write</span> <span class="token number">0</span>, <span class="token function">timeout</span> <span class="token number">315</span>
  Non-2xx or 3xx responses: <span class="token number">24950</span>
Requests/sec:   <span class="token number">2517.19</span>
Transfer/sec:    <span class="token number">775</span>.54KB
</code></pre> 
<p>这里使用 2 个线程、并发 1000 连接，测试了应用程序的性能。你可以看到，每秒请求数为 2517.19，吞吐量为 775.54KB，平均延迟为 286.14ms。</p> 
<h3><a id="time_843"></a>time</h3> 
<p>time 命令可以用来运行命令并报告CPU用量。它可能在操作系统的/usr/bin目录下，或者在shell里内建。</p> 
<pre><code class="prism language-bash"><span class="token punctuation">[</span>root@node<span class="token punctuation">]</span><span class="token comment"># time</span>
real	0m0.000s
user	0m0.000s
sys	0m0.000s
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ed4e06b46232909c134a65549d9c8432/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java面试总结，上海银行2021春招面试开始了吗</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8449f4dab9977ac629f00346a9085b96/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java学习之重写与重载的异同</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>