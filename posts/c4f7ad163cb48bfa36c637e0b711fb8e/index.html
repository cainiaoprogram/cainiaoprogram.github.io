<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【云原生系列】Kubernetes知识点 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【云原生系列】Kubernetes知识点" />
<meta property="og:description" content="目录
概念
基础架构
单master节点
多master节点
组件
Master节点核心组件
其他组件
请求发送流程
插件
核心资源
调度资源
Pod
创建pod组件间调用流程
pod生命周期：
初始化容器
镜像拉取策略
重启策略
钩子函数
探针
探针的实现方式
DownwardAPI
ReplicationController
ReplicaSet
Deployment
更新 Deploymen
回滚 Deployment
更新 Deployment 的注意事项
StatefulSet
DaemonSet
CronJob
HPA
配置资源
ConfigMap
创建ConfigMap的四种方式
应用方式
Secret
Secret常用类型：
进行加密
configMap和secret区别
服务发布
Service
service作用
服务访问
支持多种访问方式实现
Ingress
Ingress Controller
路径匹配方式
数据存储
Volume
PV和PVC
PV回收策略（persistentVolumeReclaimPolicy）
访问模式（accessModes）
存储分类
高级调度
容忍和污点
设计理念
配置解析
创建污点
创建容忍
Taint常用命令
准入控制
Resources指定pod资源限制
命名空间资源配额" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c4f7ad163cb48bfa36c637e0b711fb8e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-11-30T14:33:11+08:00" />
<meta property="article:modified_time" content="2023-11-30T14:33:11+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【云原生系列】Kubernetes知识点</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E6%A6%82%E5%BF%B5-toc" style="margin-left:0px;"><a href="#%E6%A6%82%E5%BF%B5" rel="nofollow">概念</a></p> 
<p id="C14FZ-toc" style="margin-left:0px;"><a href="#C14FZ" rel="nofollow">基础架构</a></p> 
<p id="taPbK-toc" style="margin-left:40px;"><a href="#taPbK" rel="nofollow">单master节点</a></p> 
<p id="P8E8Y-toc" style="margin-left:40px;"><a href="#P8E8Y" rel="nofollow">多master节点</a></p> 
<p id="jHuwx-toc" style="margin-left:0px;"><a href="#jHuwx" rel="nofollow">组件</a></p> 
<p id="dM03U-toc" style="margin-left:40px;"><a href="#dM03U" rel="nofollow">Master节点核心组件</a></p> 
<p id="u5Ohy-toc" style="margin-left:40px;"><a href="#u5Ohy" rel="nofollow">其他组件</a></p> 
<p id="cTHz0-toc" style="margin-left:40px;"><a href="#cTHz0" rel="nofollow">请求发送流程</a></p> 
<p id="yqBfX-toc" style="margin-left:40px;"><a href="#yqBfX" rel="nofollow">插件</a></p> 
<p id="AnACU-toc" style="margin-left:0px;"><a href="#AnACU" rel="nofollow">核心资源</a></p> 
<p id="pUkEd-toc" style="margin-left:40px;"><a href="#pUkEd" rel="nofollow">调度资源</a></p> 
<p id="TPOhA-toc" style="margin-left:80px;"><a href="#TPOhA" rel="nofollow">Pod</a></p> 
<p id="lwW4g-toc" style="margin-left:120px;"><a href="#lwW4g" rel="nofollow">创建pod组件间调用流程</a></p> 
<p id="DD9QR-toc" style="margin-left:120px;"><a href="#DD9QR" rel="nofollow">pod生命周期：</a></p> 
<p id="caVjy-toc" style="margin-left:120px;"><a href="#caVjy" rel="nofollow">初始化容器</a></p> 
<p id="kiUAK-toc" style="margin-left:120px;"><a href="#kiUAK" rel="nofollow">镜像拉取策略</a></p> 
<p id="PoeBg-toc" style="margin-left:120px;"><a href="#PoeBg" rel="nofollow">重启策略</a></p> 
<p id="OV40E-toc" style="margin-left:120px;"><a href="#OV40E" rel="nofollow">钩子函数</a></p> 
<p id="QHaB3-toc" style="margin-left:120px;"><a href="#QHaB3" rel="nofollow">探针</a></p> 
<p id="cnYrs-toc" style="margin-left:120px;"><a href="#cnYrs" rel="nofollow">探针的实现方式</a></p> 
<p id="o3LKJ-toc" style="margin-left:120px;"><a href="#o3LKJ" rel="nofollow">DownwardAPI</a></p> 
<p id="jRwvM-toc" style="margin-left:80px;"><a href="#jRwvM" rel="nofollow">ReplicationController</a></p> 
<p id="awcQ2-toc" style="margin-left:80px;"><a href="#awcQ2" rel="nofollow">ReplicaSet</a></p> 
<p id="Nemo4-toc" style="margin-left:80px;"><a href="#Nemo4" rel="nofollow">Deployment</a></p> 
<p id="dwZGA-toc" style="margin-left:120px;"><a href="#dwZGA" rel="nofollow">更新 Deploymen</a></p> 
<p id="cqOqM-toc" style="margin-left:120px;"><a href="#cqOqM" rel="nofollow">回滚 Deployment</a></p> 
<p id="RSpAP-toc" style="margin-left:120px;"><a href="#RSpAP" rel="nofollow">更新 Deployment 的注意事项</a></p> 
<p id="LJ4e2-toc" style="margin-left:80px;"><a href="#LJ4e2" rel="nofollow">StatefulSet</a></p> 
<p id="R9CZ4-toc" style="margin-left:80px;"><a href="#R9CZ4" rel="nofollow">DaemonSet</a></p> 
<p id="WOc4J-toc" style="margin-left:80px;"><a href="#WOc4J" rel="nofollow">CronJob</a></p> 
<p id="gG120-toc" style="margin-left:80px;"><a href="#gG120" rel="nofollow">HPA</a></p> 
<p id="gFY4n-toc" style="margin-left:40px;"><a href="#gFY4n" rel="nofollow">配置资源</a></p> 
<p id="RouLa-toc" style="margin-left:80px;"><a href="#RouLa" rel="nofollow">ConfigMap</a></p> 
<p id="gmypG-toc" style="margin-left:120px;"><a href="#gmypG" rel="nofollow">创建ConfigMap的四种方式</a></p> 
<p id="VOZ8b-toc" style="margin-left:120px;"><a href="#VOZ8b" rel="nofollow">应用方式</a></p> 
<p id="zBcwn-toc" style="margin-left:80px;"><a href="#zBcwn" rel="nofollow">Secret</a></p> 
<p id="mKPrY-toc" style="margin-left:120px;"><a href="#mKPrY" rel="nofollow">Secret常用类型：</a></p> 
<p id="kPBKH-toc" style="margin-left:120px;"><a href="#kPBKH" rel="nofollow">进行加密</a></p> 
<p id="KFDJp-toc" style="margin-left:80px;"><a href="#KFDJp" rel="nofollow">configMap和secret区别</a></p> 
<p id="jDUmo-toc" style="margin-left:40px;"><a href="#jDUmo" rel="nofollow">服务发布</a></p> 
<p id="XcCWH-toc" style="margin-left:80px;"><a href="#XcCWH" rel="nofollow">Service</a></p> 
<p id="ifr2V-toc" style="margin-left:120px;"><a href="#ifr2V" rel="nofollow">service作用</a></p> 
<p id="MLXCU-toc" style="margin-left:120px;"><a href="#MLXCU" rel="nofollow">服务访问</a></p> 
<p id="NpTBT-toc" style="margin-left:120px;"><a href="#NpTBT" rel="nofollow">支持多种访问方式实现</a></p> 
<p id="QIdNT-toc" style="margin-left:80px;"><a href="#QIdNT" rel="nofollow">Ingress</a></p> 
<p id="O6cu1-toc" style="margin-left:120px;"><a href="#O6cu1" rel="nofollow">Ingress Controller</a></p> 
<p id="HS35m-toc" style="margin-left:120px;"><a href="#HS35m" rel="nofollow">路径匹配方式</a></p> 
<p id="WrGAE-toc" style="margin-left:0px;"><a href="#WrGAE" rel="nofollow">数据存储</a></p> 
<p id="BMO6h-toc" style="margin-left:40px;"><a href="#BMO6h" rel="nofollow">Volume</a></p> 
<p id="MYsTY-toc" style="margin-left:40px;"><a href="#MYsTY" rel="nofollow">PV和PVC</a></p> 
<p id="EvI34-toc" style="margin-left:80px;"><a href="#EvI34" rel="nofollow">PV回收策略（persistentVolumeReclaimPolicy）</a></p> 
<p id="ILfGT-toc" style="margin-left:80px;"><a href="#ILfGT" rel="nofollow">访问模式（accessModes）</a></p> 
<p id="vvHV7-toc" style="margin-left:80px;"><a href="#vvHV7" rel="nofollow">存储分类</a></p> 
<p id="df9tP-toc" style="margin-left:0px;"><a href="#df9tP" rel="nofollow">高级调度</a></p> 
<p id="khDqj-toc" style="margin-left:40px;"><a href="#khDqj" rel="nofollow">容忍和污点</a></p> 
<p id="UBQdE-toc" style="margin-left:80px;"><a href="#UBQdE" rel="nofollow">设计理念</a></p> 
<p id="coSno-toc" style="margin-left:80px;"><a href="#coSno" rel="nofollow">配置解析</a></p> 
<p id="h4lmq-toc" style="margin-left:120px;"><a href="#h4lmq" rel="nofollow">创建污点</a></p> 
<p id="o1XgS-toc" style="margin-left:120px;"><a href="#o1XgS" rel="nofollow">创建容忍</a></p> 
<p id="Vd6Eh-toc" style="margin-left:120px;"><a href="#Vd6Eh" rel="nofollow">Taint常用命令</a></p> 
<p id="GNC6h-toc" style="margin-left:0px;"><a href="#GNC6h" rel="nofollow">准入控制</a></p> 
<p id="OhpCp-toc" style="margin-left:40px;"><a href="#OhpCp" rel="nofollow">Resources指定pod资源限制</a></p> 
<p id="yqdrG-toc" style="margin-left:40px;"><a href="#yqdrG" rel="nofollow">命名空间资源配额</a></p> 
<p id="UYLDI-toc" style="margin-left:40px;"><a href="#UYLDI" rel="nofollow">命名空间下的所有pod资源配额限制</a></p> 
<p id="ZD5CP-toc" style="margin-left:40px;"><a href="#ZD5CP" rel="nofollow">Pod服务质量QoS</a></p> 
<p id="CIbTD-toc" style="margin-left:0px;"><a href="#CIbTD" rel="nofollow">认证方式</a></p> 
<p id="JqZlj-toc" style="margin-left:40px;"><a href="#JqZlj" rel="nofollow">UserAccount</a></p> 
<p id="zn6f7-toc" style="margin-left:40px;"><a href="#zn6f7" rel="nofollow">ServiceAccount</a></p> 
<p id="WjfE1-toc" style="margin-left:40px;"><a href="#WjfE1" rel="nofollow">权限</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E6%A6%82%E5%BF%B5">概念</h2> 
<p><strong>容器是什么？</strong></p> 
<blockquote> 
 <p>容器顾名思义是一个载体，我们生活当中使用的容器，一般指的是被子，碗等等，用来装东西的。在软件开发运维方面容器承载的是应用程序及其所有依赖项（例如jdk、jar。构建后的文件、nginx）</p> 
</blockquote> 
<p><strong>为什么要用容器化技术？</strong></p> 
<blockquote> 
 <p>按照传统方式进行部署时，可以简单的分为两步，在操作系统上安装环境依赖，然后再跑程序。如果需要在另外一台服务器上进行部署还是需要重复上面的操作，安装依赖再运行程序。可能现在觉得两步骤并不麻烦，但当一个繁重的系统，需要依赖很多环境配置和中间件，那部署对于运维人员是一个重复且枯燥的体力活，而且一旦版本不一致还会导致其他问题的产生。</p> 
 <p>按照容器方式进行部署时，可以启动一个liunx基础容器，将环境依赖和程序在容器中安装运行，当需要在其他服务器部署时，把容器打包为镜像或tar包移植部署，避免了繁琐的部署步骤。</p> 
</blockquote> 
<p><img alt="" height="400" src="https://images2.imgbox.com/e5/ed/os5SFbPg_o.png" width="883"></p> 
<p><strong>容器化技术的优点 ？</strong></p> 
<ul><li>跨平台性： 容器可以在不同的操作系统和云平台上运行，提供了跨平台性，使应用程序更加可移植。</li><li>轻量级： 容器共享主机操作系统的内核，相比虚拟机来说更加轻量级。容器可以更快速地启动和停止，并占用更少的系统资源。</li><li>快速部署： 容器可以迅速部署，几乎瞬间启动。有助于快速开发、测试和部署应用程序。</li><li>一致性： 容器包含应用程序及其所有依赖项，确保了在不同环境中一致的运行，从而减少了因环境差异而引起的问题。</li><li>资源隔离： 每个容器都运行在其独立的用户空间，提供了良好的资源隔离，避免了应用程序之间的冲突。</li></ul> 
<p><strong>kubernetes是什么 ？</strong></p> 
<p class="img-center"><img alt="" height="191" src="https://images2.imgbox.com/c1/97/s6uagN4n_o.png" width="198"></p> 
<blockquote> 
 <p>公司内随着容器的越来越多，容器的管理出现了一些问题，健康检查不到位、容器的扩容、部署、回滚和更新不够灵活。</p> 
 <p>kubernetes是一个开源的容器编排和管理平台，它用来处理容器的自动化部署、自动恢复、水平伸缩等任务。通过给用户提供操作的接口，可以对容器进行增删改查等操作。</p> 
 <p>Kubernetes 是希腊语『舵手』的意思，它最开始由 Google 的几位软件工程师创立。作为编排工具，从社区的年龄来讲，Kubernetes 不占优势，Apache 推出的 Mesos 最早。从官方性方面也不占优势，Docker Swarm是docker官方提供的容器编排工具。但是后来因为是谷歌开源出来，社区很活跃，有很多人在使用，所以变成了以后整个行业的主要支柱。</p> 
</blockquote> 
<h2 id="C14FZ">基础架构</h2> 
<h3 id="taPbK">单master节点</h3> 
<p><img alt="" height="547" src="https://images2.imgbox.com/9c/e4/wJBASTgH_o.png" width="750"></p> 
<h3 id="P8E8Y">多master节点</h3> 
<p><img alt="" height="374" src="https://images2.imgbox.com/99/fa/98iHBWIy_o.png" width="750"></p> 
<h2 id="jHuwx">组件</h2> 
<h3 id="dM03U">Master节点核心组件</h3> 
<p id="u9a717f3d"><strong>APIServer</strong><br>         提供资源操作的唯一入口（任何组件想要访问Etcd都要经过APIServer），并且提供认证/授权/kubernets的访问控制。<br>         可以通过kubectl和自己开发的客户端，通过http的请求通过restapi的形式来访问apiserver，从而实现对整个集群的控制</p> 
<p id="u207eba4d">6443端口</p> 
<p><img alt="" height="361" src="https://images2.imgbox.com/b8/0a/dickBYVR_o.png" width="1200"></p> 
<p id="u6fa98002"><strong>ControllerManager</strong><br> 负责维护整个集群的状态，如，故障检测/扩缩容/滚动更新等</p> 
<p id="uea99203c"><strong>Scheduler</strong><br> 负责资源的调度，按照预定的调度策略，把pod调度到相应的node节点<br> K8s有丰富的调度策略</p> 
<h3 id="u5Ohy">其他组件</h3> 
<p id="u8b94387d"><strong>Kubelet</strong><br> 维护当前节点的容器的生命周期，维护当前节点的volume/网络等的管理，与master节点进行交互</p> 
<p id="u4678f6e7"><strong>Kube-proxy</strong><br> 每个node都会运行一个kube-proxy，提供内部的服务发现和负载均衡，为service的概念提供一个落地的方法。具体来说，就是实现集群内的客户端pod访问service，或者是集群外的主机通过NodePort等方式访问service。</p> 
<p id="udf6a3915">有userSpace(已废弃)、iptables、IPvs工作模式</p> 
<p id="u2e2fb641">userSpace:</p> 
<p><img alt="" height="201" src="https://images2.imgbox.com/99/63/FQvTBrpm_o.png" width="729"></p> 
<p id="uad6b3b26">iptables:只支持轮询调度</p> 
<p id="uf65cc8a2"></p> 
<p class="img-center"><img alt="" height="239" id="u9e8ae0a0" src="https://images2.imgbox.com/57/c9/go1RsMRe_o.png" width="718"></p> 
<p id="uafab2ad3">ipvs:</p> 
<p id="u13d1ab35"></p> 
<p class="img-center"><img alt="" height="226" id="u62e7d054" src="https://images2.imgbox.com/aa/c2/tU2Di08s_o.png" width="697"></p> 
<p id="uafb15181"></p> 
<p id="uc2dce23b"><strong>Etcd</strong><br> 主要用于一致性存储，保存pod/service和集群的状态等信息<br> 相当于k8s集群需要持久化的数据都会存储在etcd</p> 
<h3 id="cTHz0">请求发送流程</h3> 
<ul><li id="u7e8c0d3c">用户执行kubectl/userClient向api server发起一个命令</li><li id="ue5a76b99">经过认证授权后，经过scheduler的各种策略，得到一个目标node</li><li id="u61a5ad58">然后告诉api server，api server 会请求相关node的kubelet，通过kubelet把pod运行起来，apiserver还会将pod的信息保存在etcd</li><li id="u3da7133f">pod运行起来后，controllermanager就会负责管理pod的状态，如，若pod挂了，controllermanager就会重新创建一个一样的pod，或者像扩缩容等</li></ul> 
<p id="uc351bb5c"></p> 
<h3 id="yqBfX">插件</h3> 
<p id="uce58ea8e"><strong>Kube-dns</strong><br> 提供通过servicename访问服务，但并不是必须的。若不需要通过名字来访问，可以不安装kube-dns，但通常会安装，因为通过名字访问是一个比较重要的功能</p> 
<blockquote> 
 <p id="u853dd956">DNS服务在kubernetes中经历了三个阶段（SkyDNS-》KubeDNS-》CoreDNS）：</p> 
 <p id="ue4e27b76">【第一阶段】在kubernetes 1.2版本时，dns服务使用的是由SkyDNS提供的，由4个容器组成：kube2sky、skydns、etcd和healthz。etcd存储dns记录；kube2sky监控service变化，生成dns记录；skydns读取服务，提供查询服务；healthz提供健康检查。</p> 
 <p id="u50d7b0b2">【第二阶段】在kubernetes 1.4版本开始使用KubeDNS，有3个容器组成：kubedns、dnsmasq和sidecar。kubedns监控service变化，并记录到内存（存到内存提高性能）中；dnsmasq获取dns记录，提供dns缓存，提供dns查询服务；sidecar提供健康检查。</p> 
 <p id="u466f04e0">【第三阶段】从kubernetes &gt;=1.11版本开始，dns服务有CoreDNS提供，coredns支持自定义dns记录及配置upstream dns server，可以统一管理内部dns和物理dns。coredns只有一个coredns容器。下面是coredns的架构。</p> 
</blockquote> 
<p id="ue585eb97"><strong>Calico</strong></p> 
<p id="uf92c99fd"><strong>Calico</strong> 是一套开源的网络和网络安全方案，用于容器、<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E6%8B%9F%E6%9C%BA&amp;spm=1001.2101.3001.7020" title="虚拟机">虚拟机</a>、宿主机之前的网络连接，可以用在kubernetes、OpenShift、DockerEE、OpenStrack等PaaS或IaaS平台上。</p> 
<p></p> 
<p id="uaba44b8b"><strong>Metrics Server</strong></p> 
<p id="u12b981dd">在新版的Kubernetes中系统资源的采集均使用Metrics-server，可以通过Metrics采集节点和Pod的内存、磁盘、CPU和网络的使用率</p> 
<h2 id="AnACU">核心资源</h2> 
<h3 id="pUkEd">调度资源</h3> 
<h4 id="TPOhA">Pod</h4> 
<ul><li id="u4787e6d2">最小的调度以及资源单位</li><li id="u0ff41031">由一个或者多个容器组成</li><li id="ua234c608">定义容器运行的方式（Command、环境变量）</li><li id="u4308ac40">提供容器共享的运行环境（网络、进程空间、存储卷）</li></ul> 
<p id="ue2b7913f"></p> 
<p id="u0a7c152e">为什么pod必须是原子调度的单位？</p> 
<p id="u6d01eef8">        如果两个容器app、log紧密合作，需要部署在同一个worker节点，app服务需要1G、log服务需要0.5G，如果节点资源是1.25G，那app服务被调度到该节点，再调度log服务时，会发现资源不够，这样就是成组调度失败。失败之后就需要补偿策略进行回滚，重新选择worker节点，这实现起来就比较复杂。而且目前还没有考虑多请求同时调度的情况，在这种情况下可能产生死锁，要进行回滚更加复杂，调度效率会大大降低。</p> 
<p>有了pod进程组的存在，就可以根据pod来进行资源分配，不需要考虑以上情况</p> 
<p id="u1322a969"></p> 
<h5 id="lwW4g">创建pod组件间调用流程</h5> 
<p id="u43ad42f1"><img alt="" id="u09befa65" src="https://images2.imgbox.com/6a/80/Y5psJ3E9_o.png" width="1176"></p> 
<h5 id="DD9QR">pod生命周期：</h5> 
<ol><li id="u4bc4968b">启动pause容器，初始化网络、设定命名空间</li><li id="u85135270">初始化容器，可以有多个，串行机制来实现。例如：调整内核操作</li><li id="u70ad4c44">运行主容器，如果有多个就并行执行，各自维护各自的生命周期</li><li id="u524598dc">在运行主容器过程中，会运行postStart，如果没有配置，就默认success</li><li id="u500824d0">检测容器是否正常启动。startupprobe</li><li id="ufa1d8ebd">运行期间，如果配置了探针检测：livenessprobe readinessprobe</li><li id="u04588b6a">容器退出：prostop。1）清理注册信息。2）优雅关闭进程</li></ol> 
<p id="u12f04fbf"></p> 
<blockquote> 
 <p id="uf12020dd">pause容器时pod的父容器，主要负责僵尸进程的回收管理，同时使同一个pod的不同容器共享存储、网络、PID、IPC等，容器之间可以使用localhost:port相互访问，可以使用volume等实现数据共享</p> 
</blockquote> 
<p id="u0051e4a2"></p> 
<h5 id="caVjy">初始化容器</h5> 
<p id="ua788c473">在主要的容器启动之前地洞的一个容器：重点是用来做初始化动作</p> 
<ul><li id="u9d3903c0">app容器依赖mysql的数据交互，可以启动一个初始化容器检查mysql服务是否正常启动，正常则启动主容器</li><li id="uc11cafa0">使用初始化容器对系统内核参数进行调优，然后共享给著容器使用</li></ul> 
<p id="u88f40cd8"></p> 
<h5 id="kiUAK">镜像拉取策略</h5> 
<p id="u4d53223a">通过 spec.containers[].imagePullPolicy 参数可以指定镜像的拉取策略，目前支持的策略如下：</p> 
<p id="u28a2b285">Always：总是拉取，当镜像 tag 为 latest 时，且 imagePullPolicy 未配置，默认为 Always</p> 
<p id="uddd43980">Never：不管是否存在都不会拉取</p> 
<p id="ud4f9257f">IfNotPresent：镜像不存在时拉取镜像，如果 tag 为非 latest，且 imagePullPolicy 未配置，默认为 IfNotPresent</p> 
<p id="u93d9aa39"></p> 
<h5 id="PoeBg">重启策略</h5> 
<p id="uf687c8c4">可以使用 spec.restartPolicy 指定容器的重启策略</p> 
<p id="uaf7ac326">Always：默认策略。容器失效时，自动重启该容器</p> 
<p id="ubde3050a">OnFailure：容器以不为 0 的状态码终止，自动重启该容器</p> 
<p id="u8c78993b">Never：无论何种状态，都不会重启</p> 
<p id="ucb142f49"></p> 
<h5 id="OV40E">钩子函数</h5> 
<p id="u2381fe38">用来监听容器生命周期的特定时间，并在事件发生时执行已注册的回调函数</p> 
<ul><li id="ud5bddb59">当一个容器启动后，k8s将立即执行postStart时间关联的动作</li><li id="uca2a6484">在容器被终结之前，k8s将立即执行preStop时间关联的动作</li></ul> 
<p id="u31c36cce">两种钩子</p> 
<table id="TNrXP"><tbody><tr><td> <p id="u7f9f4e73">名称</p> </td><td> <p id="u0281a7ee">作用</p> </td></tr><tr><td> <p id="u513831a1">poststart</p> </td><td> <p id="uc9651aca">容器创建后自己执行，由于是异步执行，无法保证一定在容器之前运行，如果失败容器回被杀死，并根据restartPolicy决定是否重启</p> </td></tr><tr><td> <p id="ua6bffa7f">preStop</p> </td><td> <p id="u9b0ed2f0">在容器终止前执行，在完成之前会阻塞容器的操作，默认等待时间30s，通过terminationGracePeriodSeconds宽限时间</p> </td></tr></tbody></table> 
<p id="u975b050b"></p> 
<h5 id="QHaB3">探针</h5> 
<table id="OOBpw"><tbody><tr><td> <p id="u36140b5c">名称</p> </td><td> <p id="u397e8564">作用</p> </td></tr><tr><td> <p id="u337c8013">startupProbe</p> <p id="u564989c8">启动探针</p> </td><td> <p id="ua351b07b">检测容器中的应用是否正常启动，如果使用了启动探针，则其他探针都会被禁用，需要等待启动探针检测成功之后才可以执行。如果探测失败，Kubelet 会杀死容器，之后根据重启策略进行处理，如果探测成功，或没有配置 startupProbe， 则状态为成功，之后就不再探测 （只会探测一次）</p> <p id="uc718bf6f">用来检查容器是否真的启动，比如检查端口，检查进程</p> </td></tr><tr><td> <p id="ufcfd0b6e">livenessProbe</p> <p id="u3534c026">存活探针</p> </td><td> <p id="uce3086a9">用于探测容器是否在运行，如果探测失败，kubelet 会“杀死”容器并根据重启策略 进行相应的处理。如果未指定该探针，将默认为 Success （持续探测）</p> <p id="u57f5ea14">通过curl命令请求一个接口，判断状态码</p> </td></tr><tr><td> <p id="u8020555e">readinessProbe</p> <p id="ud22af2fc">就绪探针</p> </td><td> <p id="u3ee69997">一般用于探测容器内的程序是否健康，即判断容器是否为就绪（Ready）状态。如果是，则可以处理请求，反之 Endpoints Controller 将从所有的 Service 的 Endpoints 中删除此容器所在 Pod 的 IP 地址。如果未指定，将默认为 Success</p> <p id="ubaaf64c9">通过curl命令请求一个接口，判断状态码</p> </td></tr></tbody></table> 
<p id="u02316406">startupProbe和livenessProbe如果失败，k8s会杀死容器，根据重启策略决定是否重启。readinessProbe如果失败，将容器设定为未就绪状态，将其从负载均衡列表中移除，请求就不会调度到该pod</p> 
<h5 id="cnYrs">探针的实现方式</h5> 
<table id="sA8Ss"><tbody><tr><td> <p id="ud7d90ae9">实现方式</p> </td><td> <p id="u107130ca">说明</p> </td></tr><tr><td> <p id="ucbb47108">ExecAction</p> </td><td> <p id="uc4a38990">在容器内执行一个指定的命令，如果命令返回值为 0，则认为容器健康</p> </td></tr><tr><td> <p id="ua0c4b829">TCPSocketAction</p> </td><td> <p id="u041d43c8">通过 TCP 连接检查容器指定的端口，如果端口开放，则认为容器健康</p> </td></tr><tr><td> <p id="uaf9f2dfb">HTTPGetAction</p> </td><td> <p id="u3991becf">对指定的 URL 进行 Get 请求，如果状态码在 200~400 之间，则认为容器健康</p> </td></tr></tbody></table> 
<p id="u67ee5632"></p> 
<h5 id="o3LKJ">DownwardAPI</h5> 
<p id="u81861b57">可以让容器获取pod的相关元数据信息，比如pod名称，pod的ip，pod的资源限制，获取后通过env、volume的方式将相关的环境信息注入到容器中，从而让容器通过这些环境变量的信息，来设定容器的运行特性</p> 
<p id="u293c74c5"></p> 
<h4 id="jRwvM">ReplicationController</h4> 
<p id="u0806086d">Replication Controller（简称 RC）可确保 Pod 副本数达到期望值，也就是 RC 定义的数量。如果存在的 Pod 大于设定的值，则 Replication Controller 将终止额外的 Pod。如果太小， Replication Controller 将启动更多的 Pod 用于保证达到期望值。</p> 
<p id="u285493f0">Replication Controller 类似于进程 管理程序，但是 Replication Controller 不是监视单个节点上的各个进程，而是监视多个节点上的 多个 Pod。</p> 
<h4 id="awcQ2">ReplicaSet</h4> 
<p id="u23b8610f">ReplicaSet 是支持基于集合的标签选择器的下一代 Replication Controller，它主要用作 Deployment 协调创建、删除和更新 Pod，和 Replication Controller 唯一的区别是，ReplicaSet 支持 标签选择器。</p> 
<h4 id="Nemo4">Deployment</h4> 
<ul><li id="u4c69841d">Deployment控制器是工作在ReplicaSet之上的，Deployment通过控制ReplicaSet来控制pod，并不是直接控制pod</li><li id="uc8add57d">Deployment有ReplicaSet的所有功能</li><li id="u8e8f3452">无状态应用管理，所有pod等价</li><li id="ue5b34c3a">由于现在企业服务都是集群化部署，服务都是无状态的，也是最常用的控制器</li></ul> 
<p id="u56c5e274">高级功能：无缝迁移、自动扩容缩容、自动灾难恢复、一键回滚</p> 
<h5 id="dwZGA">更新 Deploymen</h5> 
<p id="u6e05fbc2">当且仅当 Deployment 的 Pod 模板（即.spec.template）更改时，才会触发 Deployment 更新，例如更改内存、CPU 配置或者容器的 image。</p> 
<pre id="pblon"><code class="language-bash">假如更新 Nginx Pod 的 image 使用 nginx:latest，并使用--record 记录当前更改的参数，后期 回滚时可以查看到对应的信息： 
# kubectl set image deployment nginx-deployment nginx=nginx:1.9.1 -- record 
	deployment.extensions/nginx-deployment image updated 

当然也可以使用 edit 命令直接编辑 Deployment，效果相同： 
# kubectl edit deployment.v1.apps/nginx-deployment 
	deployment.apps/nginx-deployment edited 
 
 同样可以使用 kubectl rollout status 查看更新过程：
 # kubectl rollout status deployment.v1.apps/nginx-deployment
	Waiting for deployment "nginx-deployment" rollout to finish: 1 out of 3 
	new replicas have been updated...
	Waiting for deployment "nginx-deployment" rollout to finish: 2 out of 3 
	new replicas have been updated...
	Waiting for deployment "nginx-deployment" rollout to finish: 2 out of 3 
	new replicas have been updated...
	Waiting for deployment "nginx-deployment" rollout to finish: 2 out of 3 
	new replicas have been updated...
	Waiting for deployment "nginx-deployment" rollout to finish: 1 old 
	replicas are pending termination...
	Waiting for deployment "nginx-deployment" rollout to finish: 1 old 
	replicas are pending termination...
	deployment "nginx-deployment" successfully rolled out</code></pre> 
<h5 id="cqOqM">回滚 Deployment</h5> 
<p id="ub7251179">查看历史信息</p> 
<pre id="RD5yG"><code>使用 kubectl rollout history 查看更新历史：
# kubectl rollout history deployment/nginx-deployment
	REVISION CHANGE-CAUSE
	1 &lt;none&gt;
	2 kubectl set image deployment nginx-deployment nginx=nginx:1.9.1 
	--record=true
	3 kubectl set image deployment nginx-deployment 
	nginx=dotbalo/canary:v1 --record=true
	4 kubectl set image deployment nginx-deployment 
	nginx=dotbalo/canary:v2 --record=true

查看 Deployment 某次更新的详细信息，使用--revision 指定某次更新版本号：
 # kubectl rollout history deployment/nginx-deployment --revision=3
	deployment.apps/nginx-deployment with revision #3
	Pod Template:
	 Labels: app=nginx
	pod-template-hash=645959bf6b
	 Annotations: kubernetes.io/change-cause: kubectl set image deployment 
	nginx-deployment nginx=dotbalo/canary:v1 --record=true
	 Containers:
	 nginx:
	 Image: dotbalo/canary:v1
	 Port: 80/TCP
	 Host Port: 0/TCP
	 Environment:&lt;none&gt;
	 Mounts: &lt;none&gt;
	 Volumes: &lt;none&gt;</code></pre> 
<p id="u058d48c8">回滚</p> 
<pre id="WNfC7"><code>如果只需要回滚到上一个稳定版本，使用 kubectl rollout undo 即可：
# kubectl rollout undo deployment/nginx-deployment
	deployment.apps/nginx-deployment

如果要回滚到指定版本，使用--to-revision 参数：
# kubectl rollout undo deployment/nginx-deployment --to-revision=2
	deployment.extensions/nginx-deployment</code></pre> 
<h5 id="RSpAP">更新 Deployment 的注意事项</h5> 
<p id="uc84e2943">历史版本清理策略：</p> 
<p id="u5e1069a2">在默认情况下，revision 保留 10 个旧的 ReplicaSet，其余的将在后台进行垃圾回收，可以 在.spec.revisionHistoryLimit 设置保留 ReplicaSet 的个数。当设置为 0 时，不保留历史记录</p> 
<p id="u0e4d7459"></p> 
<p id="ufa577fa9">更新策略：</p> 
<ul><li id="ufd784a76">.spec.strategy.type==Recreate，表示重建，先删掉旧的Pod再创建新的Pod；</li><li id="u53fb7a9f">.spec.strategy.type==RollingUpdate，表示滚动更新，可以指定maxUnavailable和maxSurge 来控制滚动更新过程；</li></ul> 
<ul><li> 
  <ul><li id="u77f44953">.spec.strategy.rollingUpdate.maxUnavailable，指定在回滚更新时最大不可用的Pod数量， 可选字段，默认为25%，可以设置为数字或百分比，如果maxSurge为0，则该值不能 为0；</li><li id="u2732f961">.spec.strategy.rollingUpdate.maxSurge可以超过期望值的最大Pod数，可选字段，默认为 25%，可以设置成数字或百分比，如果maxUnavailable为0，则该值不能为0</li></ul></li></ul> 
<h4 id="LJ4e2">StatefulSet</h4> 
<p id="u24bff825">常用于部署有状态的且需要有序启动的应用程序。</p> 
<p id="udf27d3cf">适用于以下：</p> 
<ul><li id="ub59a3f98">需要稳定的独一无二的网络标识符</li><li id="udcd03161">需要持久化数据</li><li id="u02498208">需要有序的、优雅的部署和扩展</li><li id="u1bf4eb88">需要有序的自动滚动更新</li></ul> 
<p id="uc3a82a63"></p> 
<p id="ucd0dd8af">statefulSet为每个Pod维护了一个粘性标识。而StatefulSet创建的Pod一般使用Headless Service(无头服务）进行Pod之前的通信，和普通的Service的区别子啊与Headless Service没有Cluster IP，它使用Endpoint进行互相通信</p> 
<p id="udede8ed5"></p> 
<h4 id="R9CZ4">DaemonSet</h4> 
<p id="u3e0fcd92">在每个节点上跑一个 Pod，可以用来做节点监控、节点日志收集等</p> 
<p id="uc46505f3">DaemonSet不管理Replicas，因为DaemonSet不是基于期望的副本数，而是基于节点数量来控制Pod数量</p> 
<p id="u80283264">DaemonSet典型用法，在每个节点上运行集群存储守护进程、日志收集守护进程、监控守护进程、网络插件为Pod提供网络服务。</p> 
<h4 id="WOc4J">CronJob</h4> 
<p id="uc3087181">Job 用来表达的是一次性的任务，而 CronJob 会根据其时间规划反复运行。</p> 
<h4 id="gG120">HPA</h4> 
<p id="u17a74cd4">根据监控指标进行自动扩容伸缩。HPA v1为稳定版自动水平伸缩，只支持CPU指标 ，V2为beta版本，分为v2beta1(支持CPU、内存和自定义指标) ，v2beta2(支持CPU、内存、自定义指标Custom和额外指标ExternalMetrics)</p> 
<p id="ub9875fc7"></p> 
<ul><li id="u53caa4fa">必须安装metrics-server或其他自定义metrics-server</li><li id="u176be70a">必须配置requests参数</li><li id="u99f9c0f2">不能扩容无法缩放的对象，statefulset一般代表有状态服务，副本不可随便修改，而Job一般代表短生命周期的，所以基本可以认为HPA目前是专门控制deployment的扩缩容的（不建议直接控制RS，否则将无法滚动升级）</li></ul> 
<p id="u1c5633a2">一般生产环境不能直接使用，因为某项指标的升高并不是因为监控的此服务导致的，可能是由于下游服务导致，扩容此服务无法解决该问题</p> 
<h3 id="gFY4n">配置资源</h3> 
<h4 id="RouLa">ConfigMap</h4> 
<p id="ud41affe7">configmap资源主要为容器注入相关的程序配置信息，用来定制程序的运行方式。定义好一个configmap资源后，如果pod需要使用，通过环境变量或者存储卷的形式将其挂载并加载相关的配置，大大降低配置文件与容器镜像的耦合关系。</p> 
<p id="u9100a8e9"></p> 
<h5 id="gmypG">创建ConfigMap的四种方式</h5> 
<p id="u23990dab">1.通过--from-literal（文字的）</p> 
<pre id="qE95O"><code class="language-bash"># kubectl create cm myconfigmap1 --from-literal=username=root --from-literal=pasword=123.com</code></pre> 
<p id="u2eb12bd7">2、通过from-file（文件）</p> 
<pre id="F2TRo"><code class="language-bash"># echo root &gt; username
# echo 123.com  &gt; password
#  kubectl create cm myconfigmap2 --from-file=username --from-file=password </code></pre> 
<p id="uf2bc7931">3、通过-- from- env-file</p> 
<pre id="LzAVI"><code class="language-bash">#vim env.txt 
username=root
password=123.com

# kubectl create cm myconfigmap3 --from-env-file=env.txt </code></pre> 
<p id="u5ba6f07c">4、通过yaml配置文件</p> 
<pre id="Tjkt8"><code class="language-bash"># vim myconfigmap4.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: myconfigmap4
data:
  username: root
  password: 123.com
  
# kubectl apply -f myconfigmap4.yaml</code></pre> 
<p id="ub9a67b72"></p> 
<h5 id="VOZ8b">应用方式</h5> 
<p id="u8576bc27">1、使用valueFrom一对一定义环境变量</p> 
<p id="uf67030e9">2、使用envFrom定义环境变量</p> 
<p id="uef9564c8">3、以文件的形式挂载ConfigMap（可以挂载nginx配置文件）</p> 
<p id="uad8e618c"></p> 
<p id="u2f410040">        如果引用secret数据的应用， 要求会随着secret资源对象内保存的数据的更新，而实时更新，那么应该使用volumes挂载的方式引用资源因为用<span style="color:#fe2c24;">环境变量的方式引用不会实时更新数据</span>。</p> 
<h4 id="zBcwn">Secret</h4> 
<p id="u8691cba7">        Secret是用来保存小片敏感数据的k8s资源，例如密码，token，或者秘钥。这类数据当然也可以存放在Pod或者镜像中，但是放在Secret中是为了更方便的控制如何使用数据，并减少暴露的风险。</p> 
<p id="u6bb7182a"></p> 
<h5 id="mKPrY">Secret常用类型：</h5> 
<ul><li id="ue2717924">Opaque：通用型Secret，默认类型；</li><li id="u54fff1b0">kubernetes.io/service-account-token：作用于ServiceAccount，包含一个令牌，用于标识API服务账户；</li><li id="ue494beb0">kubernetes.io/dockerconfigjson：下载私有仓库镜像使用的Secret， 和宿主机的/root/.docker/config.json一致，宿主机登录后即可产生该文件；</li><li id="ub8d614c3">kubernetes.io/basic-auth：用于使用基本认证（账号密码）的Secret，可以使用Opaque取代；</li><li id="ua6f6ee41">kubernetes.io/ssh-auth：用于存储ssh密钥的Secret；</li><li id="u6754e7b0">kubernetes.io/tls：用于存储HTTPS域名证书文件的Secret，可以被Ingress使用；</li><li id="u802019c1">bootstrap.kubernetes.io/token：一种简单的 bearer token， 用于创建新集群或将新节点添加到现有集群，在集群安装时可用于自动颁发集群的证书。</li></ul> 
<h5 id="SmPzv"></h5> 
<h5 id="kPBKH">进行加密</h5> 
<pre id="QqjQx"><code class="language-bash">-----把需要保存的数据加密（”base64“的方式）
# echo root | base64
cm9vdAo=
# echo 123.com | base64
MTIzLmNvbQo=

------解码
# echo -n cm9vdAo | base64 --decode 
root
# echo -n MTIzLmNvbQo | base64 --decode 
123.com

------编写secret4的yaml文件
# vim secret4.yaml
apiVersion: v1
kind: Secret
metadata:
  name: secret4
data:
  username: cm9vdAo=
  password: MTIzLmNvbQo=
  
# kubectl apply -f secret4.yaml</code></pre> 
<h4 id="KFDJp">configMap和secret区别</h4> 
<p id="u1794fbbc"><strong>相同点：</strong></p> 
<ul><li id="uce0d1c9f">key/value的形式</li><li id="u9a9ccb50">属于某个特定的namespace</li><li id="ub73d74a1">可以导出到环境变量</li><li id="uf27db6eb">可以通过目录/文件形式挂载</li><li id="u219eb279">通过 volume 挂载的配置信息均可热更新</li></ul> 
<p id="u49357965"></p> 
<p id="u1917ee45"><strong>不同点：</strong></p> 
<ul><li id="u42174155">Secret 可以被 ServerAccount 关联</li><li id="u26f9b881">Secret 可以存储 docker register 的鉴权信息，用在 ImagePullSecret 参数中，用于拉取私有仓库的镜像</li><li id="u1b13f430">Secret 支持 Base64 加密</li><li id="u57abcb56">Secret 分为 kubernetes.io/service-account-token、kubernetes.io/dockerconfigjson、Opaque 三种类型，而 Configmap 不区分类型</li></ul> 
<h3 id="jDUmo">服务发布</h3> 
<h4 id="XcCWH">Service</h4> 
<blockquote> 
 <p id="uc8c751b9">为什么使用service？</p> 
 <p id="u08aa9289">通过Ip访问pod，但是pod的Ip不固定，一旦pod发生重建，ip地址会变更</p> 
 <p id="u16b6cb3d">pod如果扩展多份，会造成客户端无法有效新增Pod，如果Pod进行缩容又会造成客户端访问错误。</p> 
</blockquote> 
<p id="uc8bc9ab1"></p> 
<p class="img-center"><img alt="" height="377" id="ub713e491" src="https://images2.imgbox.com/e8/52/Hfe5ilJn_o.png" width="480"></p> 
<p id="uf0a477f5">提供访问一个或者多个Pod实例的稳定访问地址，通过标签选择器进行绑定</p> 
<h5 id="ifr2V">service作用</h5> 
<p id="u1300e724">暴露流量：让用户可以通过 ServiceIP+ ServicePort访问对应后端的Pod应用</p> 
<p id="uf0f241d2">负载均衡：提供基于4层的TCP/IP负载均衡,并不提供HTTP/HTTPS等负载均衡</p> 
<p id="u3bc189a5">不过 Service 并不直接与Pod建立关联关系,它们之间还有一个中间层 Endpoints, Endpoints对象是由IP地址和端口组成的列表,这些IP地址和端口来自于 Service标签选择器所匹配到的 PodIP、 Podport,默认情况下,创建 Service资源时,其关联Endpoints对象会被自动创建</p> 
<p id="u5941bcf3">服务发现：当发现新增Pod则自动加入至 Service的后端，如发现Pod异常则自动剔除Service后端</p> 
<p id="u84945455"></p> 
<h5 id="MLXCU">服务访问</h5> 
<p id="ucd82ab2f">1.同一个命名空间下，可以通过servicename直接访问</p> 
<p id="u547d5a56">2.不同命名空间下，需要servicename.namespace来访问</p> 
<p id="u4bc70097">3.外部服务， 希望 Service 指向外部集群中的服务，通过Service和Endpoints代理访问</p> 
<pre id="Si3Yv"><code class="language-bash">apiVersion: v1
kind: Service
metadata:
  labels:
    app: nginx-svc-external
  name: nginx-svc-external
  namespace: ingress-nginx
spec:
  ports:
  - name: http
    port: 9090
    protocol: TCP
    targetPort: 9090
  sessionAffinity: None
  type: ClusterIP
---
apiVersion: v1
kind: Endpoints
metadata:
  labels:
    app: nginx-svc-external
  name: nginx-svc-external
  namespace: ingress-nginx
subsets:
- addresses:
  - ip: 192.168.25.234  //还可以添加多个ip 
  ports:
  - name: http
    port: 9090
    protocol: TCP</code></pre> 
<p id="u8a2095a9">访问结果</p> 
<p id="u54927570"></p> 
<p class="img-center"><img alt="" height="243" id="ue08ebf33" src="https://images2.imgbox.com/21/20/7fyzLppk_o.png" width="932"></p> 
<p id="u57cb6aa7"></p> 
<h5 id="NpTBT">支持多种访问方式实现</h5> 
<ul><li id="ub7690a85">ClusterIP：在集群内部使用，默认值，只能从集群中访问。</li><li id="u29c88185">NodePort：在所有安装了 Kube-Proxy 的节点上打开一个端口，此端口可以代理至后端 Pod，可以通过 NodePort 从集群外部访问集群内的服务，格式为 NodeIP:NodePort。</li><li id="u4e8c7844">LoadBalancer：使用云提供商的负载均衡器公开服务，成本较高。</li><li id="u08f0ef60">ExternalName：通过返回定义的 CNAME 别名，没有设置任何类型的代理，需要 1.7 或 更高版本 kube-dns 支持。</li></ul> 
<h4 id="QIdNT">Ingress</h4> 
<blockquote> 
 <p>为什么使用Ingress？</p> 
 <p id="u5010bd57">使用NodePort类型的Service可以将集群内部服务暴露给集群外部客户端，但是存在以下几个问题</p> 
 <ul><li id="u2bab3801">一个端口只能一个服务使用,所有通过 Nodeport暴露的端口都需要提前规划;</li><li id="uf8a3db8a">如果通过 Nodeport暴露端口过多,后期维护成本太大,且不易于管理;</li><li id="ubcc3a2ba">目前 Service底层使用的是 Iptables、IPVS,仅支持4层协议,无法完成https协议传输</li></ul> 
</blockquote> 
<p id="u803df032"></p> 
<p class="img-center"><img alt="" height="451" id="u68d04540" src="https://images2.imgbox.com/a2/9b/4feVPNJa_o.png" width="682"></p> 
<p id="u5720fc17">ingress为k8s集群中的服务提供了入口，可以提供负载均衡和基于名称（域名）的虚拟主机、应用的灰度发布等功能，常用的Ingress有Treafik、Nginx、HAP Roxy、Istio等</p> 
<h5 id="O6cu1">Ingress Controller</h5> 
<p id="u880e4c89">Ingress Controller是一类以代理HTTP/HTTPS协议为主的代理程序。</p> 
<p id="u4a5f2bd5">类似于Nginx服务，负责读取Ingress的规则，然后转换将规则转换为nginx.conf配置文件，这样就可以根据对应的规则来实现流量的调度。会实时感知后端service对应的pod变化，结合Ingress的规则，进而完成对应的配置动态更新</p> 
<p id="ua6d21a09">注意：不经过Service转发，Service只是识别出Pod的IP</p> 
<h5 id="HS35m">路径匹配方式</h5> 
<p id="u72c998a2">pathType：路径的匹配方式，目前有 ImplementationSpecific、Exact 和 Prefix 方式</p> 
<ul><li id="uc183ba41">Exact：精确匹配，比如配置的 path 为/bar，那么/bar/将不能被路由；</li><li id="uda1c6e04">Prefix：前缀匹配，基于以 / 分隔的 URL 路径。比如 path 为/abc，可以匹配 到/abc/bbb 等，比较常用的配置</li><li id="u65c48911">ImplementationSpecific：这种类型的路由匹配根据 Ingress Controller 来实现， 可以当做一个单独的类型，也可以当做 Prefix 和 Exact</li></ul> 
<h2 id="WrGAE">数据存储</h2> 
<h3 id="BMO6h">Volume</h3> 
<ul><li id="ua9896efd">声明在Pod中的容器可访问的文件目录</li><li id="u6baf57f2">可以挂载在Pod中一个或者多个容器的指定路径下</li></ul> 
<p id="u477953b4">临时存储卷：emptyDir（ 一般 emptyDir 卷用于 Pod 中的不同 Container 共享数据 ）</p> 
<p id="u7d52b530">本地存储卷：hostPath、local</p> 
<p id="ua461715e">网络文件系统：NFS、Glusterfs、CephFS</p> 
<p id="u6f9ffe45"></p> 
<h3 id="MYsTY">PV和PVC</h3> 
<blockquote> 
 <p id="u94adb583">volume无法解决的问题？</p> 
 <p id="uab718e37">当某个数据卷不再被挂载使用时，里面的数据如何处理？</p> 
 <p id="u6af02036">如果想要实现只读挂载如何处理？</p> 
 <p id="ufade73a8">如果想要只能一个Pod挂载如何处理？</p> 
 <p id="ub4decb0f">如何只允许某个Pod使用10G的空间？</p> 
</blockquote> 
<p id="ua6c74274">PV：持久卷，集群中的一块存储，可由集群管理员根据PV所支持的存储卷插件定义好底层存储类型、及存储空间</p> 
<p id="u839e6115">PVC：持久卷申领，用户通过PVC进行存储资源申请，根据用户申请的存储（大小、类型）来绑定符合条件的PV持久卷</p> 
<p id="u194514bf"></p> 
<p id="u79a8d41f">定义PVC时,用户可通过访问模式、存储资源空间需求、限制、标签选择器、卷名称、卷类型等标准来筛选集群上的PV资源</p> 
<ul><li id="uc7204b47">accessmodes：PvC的访问模式;它同样支持RWO、RWX、ROX三种方式;</li><li id="u3f2e6b33">resources：申明使用的存储空间的最小值和最大值;</li><li id="u04bbc667">selector：筛选PV时额外使用的标签选择器</li><li id="u685c07d2">volume Name：直接指定要绑定的PV资源名称;</li><li id="u5771c752">strogeclassname：指定从哪类存储资源下筛选PV,如果指定的名称不存在,则无法绑定成功。如果指定的资源下没有符合的空间也无法绑定成功。比如申请20G空间，但pV都只有10G空间,则无法满足</li></ul> 
<p id="u1cea88dd"></p> 
<h4 id="EvI34">PV回收策略（persistentVolumeReclaimPolicy）</h4> 
<p id="u4672e14a">1.retain（保留）：需要手动回收</p> 
<p id="u7802aabf">删除pvc后将保留其绑定的pv及存储的数据，但会把该pv置为Released状态，它不可再被其他pvc所绑定，且需要有管理员手动进行后续回收操作：首先删除pv，接着手动清理其关联的外部存储组件上的数据，最后基于该组件重新创建pv</p> 
<p id="uff70370a">2.Recycle（回收）：基本擦除（rm -rf /thevolume/*)</p> 
<p id="u2e29631d">对于支持该回收策略的存储卷插件，删除pvc时，其绑定的pv所关联的外部存储组件上的数据会被清空，随后该pv将转为Available状态，可再次接受其他pvd的绑定请求，不过目前仅NFS和Hostpath支持回收策略</p> 
<p id="ua7511c46">3.delete（删除）</p> 
<p id="u336f9b80">对于支持该回收策略的卷插件，删除一个pvc将同时删除其绑定的pv资源及该pv关联的外部存储组件</p> 
<p id="uef16befa">pvc中的storageClassName未指定所以就可以从所有的pv中进行匹配选择</p> 
<p id="uede0fece"></p> 
<h4 id="ILfGT">访问模式（accessModes）</h4> 
<p id="u2be2f29a">用于描述用户应用对存储资源的访问权限，访问权限包括下面几种方式：<br> ReadWriteOnce（RWO）：读写权限，但是只能被单个节点挂载（块存储不能共享只能被单个节点挂载）<br> ReadOnlyMany（ROX）： 只读权限，可以被多个节点挂载<br> ReadWriteMany（RWX）：读写权限，可以被多个节点挂载</p> 
<p id="u7137e6d8"></p> 
<h4 id="vvHV7">存储分类</h4> 
<ul><li id="uffaac4de">文件存储：一些数据可能需要被多个节点使用，比如用户的头像、用户上传的文 件等，实现方式：NFS、NAS、FTP、CephFS等。</li><li id="ud3b736d8">块存储：一些数据只能被一个节点使用，或者是需要将一块裸盘整个挂载使用， 比如数据库、Redis等，实现方式：Ceph、GlusterFS、公有云。</li><li id="uc57f0f72">对象存储：由程序代码直接实现的一种存储方式，云原生应用无状态化常用的实 现方式，实现方式：一般是符合S3协议的云存储，比如AWS的S3存储、Minio、七牛云等。</li></ul> 
<h2 id="df9tP">高级调度</h2> 
<h3 id="khDqj">容忍和污点</h3> 
<h4 id="UBQdE">设计理念</h4> 
<p id="uee12a96a">Taint在Node上打上污点，让不能容忍这个污点的Pod不能部署 在打了污点的Node上。</p> 
<p id="u8dbb2bcf">Toleration是让Pod容忍节点上配置的污点，可以让一些 需要特殊配置的Pod能够调用到具有污点和特殊配置的节点上。</p> 
<p id="u9f51acaa"></p> 
<p class="img-center"><img alt="" height="553" id="u8db16516" src="https://images2.imgbox.com/dd/af/ETClIQGy_o.png" width="1101"></p> 
<h4 id="coSno">配置解析</h4> 
<h5 id="h4lmq">创建污点</h5> 
<p id="u1f3d473b">（一个节点可以有多个污点）：</p> 
<p id="u6f474a6e">kubectl taint nodes NODE_NAME TAINT_KEY=TAINT_VALUE:EFFECT</p> 
<p id="uceadba17">比如：</p> 
<p id="ub0b2b680">kubectl taint nodes k8s-node01 ssd=true:PreferNoSchedule</p> 
<h5 id="o1XgS">创建容忍</h5> 
<p id="u241ac39a">方式一完全匹配：</p> 
<pre id="igAzH"><code>tolerations:
- key: "taintKey"
  operator: "Equal"
  value: "taintValue"
  effect: "NoSchedule"</code></pre> 
<p id="ubd0ed58b">方式二不完全匹配：</p> 
<pre id="Zt3DU"><code>tolerations:
- key: "taintKey"
  operator: "Exists"
  effect: "NoSchedule"</code></pre> 
<p id="u4b85ac23">方式三大范围匹配（不推荐key为内置Taint）</p> 
<pre id="zYS44"><code>- key: "taintKey"
  operator: "Exists"
</code></pre> 
<p id="uaa2d3f4d">NoSchedule：禁止调度到该节点，已经在该节点上的Pod不受影响</p> 
<p id="ufc4bfc77">NoExecute：禁止调度到该节点，如果不符合这个污点，会立马被驱逐（或在一段时间后）</p> 
<p id="u7f8b95fa">PreferNoSchedule：尽量避免将Pod调度到指定的节点上，如果没有更合适的节点，可以部署到该节点</p> 
<h5 id="Vd6Eh">Taint常用命令</h5> 
<pre><code class="language-bash">创建一个污点（一个节点可以有多个污点）：
kubectl taint nodes NODE_NAME TAINT_KEY=TAINT_VALUE:EFFECT
比如：
kubectl taint nodes k8s-node01 ssd=true:PreferNoSchedule

查看一个节点的污点：
kubectl get node k8s-node01 -o go-template --template {<!-- -->{.spec.taints}}
kubectl describe node k8s-node01 | grep Taints -A 10

删除污点（和label类似）：
基于Key删除： kubectl taint nodes k8s-node01 ssd基于Key+Effect删除： kubectl taint nodes k8s-node01 ssd:PreferNoSchedule修改污点（Key和Effect相同）：
kubectl taint nodes k8s-node01 ssd=true:PreferNoSchedule --overwrite</code></pre> 
<h2 id="GNC6h">准入控制</h2> 
<h3 id="OhpCp">Resources指定pod资源限制</h3> 
<p id="u0ec43b01">requests：启动Pod时申请分配的资源大小；</p> 
<p id="uf76d7375">limits：限制Pod运行时最大可用的资源大小；</p> 
<p id="uc60e28d4">单位：</p> 
<p id="u56dc5372">cpu：100m = 0.1核</p> 
<p id="u01cf3f38">memory：“100Mi" = 100MB</p> 
<p id="u32aa009c"></p> 
<h3 id="yqdrG">命名空间资源配额</h3> 
<p id="ufb5c30c7">当系统存在多个用户或团队共享具有固定节点的 Kubernetes集群时,一般会根据不同团队创建不同的命名空间,但可能会出现某个应用将该命名空间的CPU或内存耗尽的情况,无法保证其公平分配原则。可以通过 Resourcequotas资源配额来解决这个问题。</p> 
<p id="uf42f40fb">ResourceQuota</p> 
<pre id="S7BCK"><code>apiVersion: v1
kind: ResourceQuota
metadata:
  name: compute-resources
spec:
  hard:
    pods: "4"         # 限制最多启动pod的个数
    requests.cpu: "1"     #  该空间下所有的request相加限制最高CPU的request请求数上限
    requests.memory: 1Gi      # 该空间下所有的request相加限制最高内存的request请求数上限
    limits.cpu: "2"         # 该空间下所有的limit相加限制最高CPU的limit上限
    limits.memory: 2Gi      # 该空间下所有的limit相加限制最高内存的limit上限</code></pre> 
<h3 id="UYLDI">命名空间下的所有pod资源配额限制</h3> 
<p id="u26f9f4aa">limitRange</p> 
<p id="u2ebc9e0a">为什么要有limitRange？</p> 
<p id="u0f91d476">如果ResourceQuota限制该空间下可以有100个pod，但是</p> 
<p id="uc01fcee1">如果创建的pod没有限制，设置默认的requests和limits配额，或者限制requests和limits最大最小是多少</p> 
<pre id="GXYib"><code>apiVersion: v1
kind: LimitRange
metadata:
  name: cpu-mem-limit-range
spec:
  limits:
  - default:               # default：默认limits配置
      cpu: 1
      memory: 512Mi
    defaultRequest:        # defaultRequest：默认requests配置
      cpu: 0.5
      memory: 256Mi
    type: Container
</code></pre> 
<p id="uf553e57b">内存、cpu设置最小配置和最大配置</p> 
<pre id="PxxM2"><code>apiVersion: v1
kind: LimitRange
metadata:
  name: cpu-mem-limit-range
spec:
  limits:
  - max:               # max：内存CPU的最大配置
      cpu: 800m
      memory: 1Gi
    min:               # min：内存CPU的最小配置
      cpu: 200m
      memory: 500Mi
    type: Container</code></pre> 
<p id="uc9d3d0af">限制申请存储空间的大小</p> 
<pre id="V9h5k"><code>apiVersion: v1
kind: LimitRange
metadata:
  name: storagelimits
spec:
  limits:
  - type: PersistentVolumeClaim
    max:         # max：最大PVC的空间
      storage: 2Gi
    min:         # min：最小PVC的空间
      storage: 1Gi
</code></pre> 
<p id="ue6ba64bf"></p> 
<p id="u605ee101"></p> 
<h3 id="ZD5CP">Pod服务质量QoS</h3> 
<p id="ue1845c53">Guaranteed：每个容器都为cpu资源设置了具有相同值的requests和limits属性，容器都为内存资源设置了具有相同值的requests和limits属性的pod资源会自动归属此类别，这类pod资源具有最高优先级</p> 
<p id="uf9d454bc">Burstable：至少有一个容器设置了cpu或内存资源的requests属性，但不满足guaranteed类别的pod资源自动归属此类别，具有中等优先级</p> 
<p id="uf9276d98">BestEffort（默认）：没有为任何容器设置Requests核limits属性，这类pod对象服务质量是最低级别</p> 
<p id="ubdf76657"></p> 
<p id="u47c7f3a0">当k8s集群内存资源紧缺，优先杀死BestEffort类别容器。接下来就轮到Burstable类别的容器，如果有多个，看谁实际运行占用的内存资源多，优先干掉谁。</p> 
<p></p> 
<h2 id="CIbTD">认证方式</h2> 
<h3 id="JqZlj">UserAccount</h3> 
<p id="u0c2f9a15">用户账户，是给K8S集群外部用户使用的，如kubectl访问K8S集群要用useraccount用户，kubeadm搭建的K8s集群默认useraccount用户是kubernetes-admin。</p> 
<h3 id="zn6f7">ServiceAccount</h3> 
<p id="u9fa2f2ff">pod使用的账户，如果创建pod没有填写ServiceAccount的对应的名称，系统会给一个默认的ServiceAccount。该默认的ServiceAccount可以访问集群的元数据信息。如果pod想对集群做操作，那默认的SA就没有足够的权限，我们可以自行创建SA，而后赋予对应的权限，然后注入到pod中，pod就拥有了对应的权限</p> 
<h3 id="WjfE1">权限</h3> 
<p id="u0a68f2a8">ClusterRole：配置权限，允许对整个集群做权限限制</p> 
<p id="u48b9064a">Role：只允许对该Namespace做权限限制</p> 
<p id="u62df7552">K8s利用Role和ClusterRole两类角色来赋予相应的权限，同时也需要用到另外两类资源Rolebinding和ClusterRolebinding来完成用户与角色之间的绑定关系</p> 
<p id="u8d434207"></p> 
<p id="ub6f6663c">RoleBinding：将角色和对象进行绑定，范围限定在 namespace；</p> 
<p id="ued11e8c2">ClusterRoleBinding：将集群角色和对象进行绑定，不受 namespace 限制；</p> 
<p id="u0f3d36f7"></p> 
<p id="u61055238">角色--》组--》用户</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/03bd6643baf1c2ae3dd72cdcd8e95ff4/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">FFmpeg 集成 x265 编译及解码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a5a1a8ae89172ae81d703a6d73615ece/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Flutter自定义TextInputFormatter实现金额输入框</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>