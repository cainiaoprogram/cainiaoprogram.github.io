<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>java解析xml 忽略dtd_使用Scala中的XML解析整个文件夹下的xml，并忽略dtd检测 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="java解析xml 忽略dtd_使用Scala中的XML解析整个文件夹下的xml，并忽略dtd检测" />
<meta property="og:description" content="需求：快速解析一个文件夹下的所有xml(10年的数据，大概一千万个xml)
遇到的坑：xml里面有dtd，必须这个文件存在，不然会报错
处理思路：重写原有的方法
语言对比：Java处理速度慢，并且代码量大，这儿不做考虑，其次python，由于需要处理的xml太过复杂，python需要写多层嵌套循环，并且不能分布式处理，这儿重点讲一下Scala
Scala我么通过scala.xml.XML可以很方便的取出任意一个标签，并且可以分布式去处理。
Scala XML API提供了类似XPath的语法来解析XML。在NodeSeq这类父类里，定义了两个很重要的操作符(&#34;&#34;和&#34;\&#34;)，用来获得解析XML：
\ ：\ 简单来说就是根据条件搜索第一次出现的节点
\\：而 \\ 则是根据条件搜索所有的子节点
我们先分享几个小方法：
1.递归遍历文件夹，找出所有以xml结尾的文件
/**
递归查找文件及子文件夹下面的XML文件
@param file
@return
*/
def getFile(file:File): Array[File] ={
val files = file.listFiles().filter(! .isDirectory)
.filter(t =&gt; t.toString.toLowerCase.endsWith(&#34;.xml&#34;)) //此处读取.txt and .md文件
files &#43;&#43; file.listFiles().filter(.isDirectory).flatMap(getFile)
}
2.解决dtd校验文件问题
源码：
这儿我们会用到loadFile去加载xml文件，我们根据源码可以看到loadFile传进去了一个parser方法:
XML.XML.loadFile(filename)
/**
Loads XML from the given InputSource, using the supplied parser.
The methods available in scala.xml.XML use the XML parser in the JDK.
/" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/286aac82789aabd5ef24ab5b8315e28a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-03-02T01:32:16+08:00" />
<meta property="article:modified_time" content="2021-03-02T01:32:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">java解析xml 忽略dtd_使用Scala中的XML解析整个文件夹下的xml，并忽略dtd检测</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div style="font-size:16px;"> 
 <p>需求：快速解析一个文件夹下的所有xml(10年的数据，大概一千万个xml)</p> 
 <p>遇到的坑：xml里面有dtd，必须这个文件存在，不然会报错</p> 
 <p>处理思路：重写原有的方法</p> 
 <p>语言对比：Java处理速度慢，并且代码量大，这儿不做考虑，其次python，由于需要处理的xml太过复杂，python需要写多层嵌套循环，并且不能分布式处理，这儿重点讲一下Scala</p> 
 <p>Scala我么通过scala.xml.XML可以很方便的取出任意一个标签，并且可以分布式去处理。</p> 
 <p>Scala XML API提供了类似XPath的语法来解析XML。在NodeSeq这类父类里，定义了两个很重要的操作符(""和"\")，用来获得解析XML：</p> 
 <p>\ ：\ 简单来说就是根据条件搜索第一次出现的节点</p> 
 <p>\\：而 \\ 则是根据条件搜索所有的子节点</p> 
 <p>我们先分享几个小方法：</p> 
 <p>1.递归遍历文件夹，找出所有以xml结尾的文件</p> 
 <p>/**</p> 
 <p>递归查找文件及子文件夹下面的XML文件</p> 
 <p>@param file</p> 
 <p>@return</p> 
 <p>*/</p> 
 <p>def getFile(file:File): Array[File] ={<!-- --></p> 
 <p>val files = file.listFiles().filter(! .isDirectory)</p> 
 <p>.filter(t =&gt; t.toString.toLowerCase.endsWith(".xml")) //此处读取.txt and .md文件</p> 
 <p>files ++ file.listFiles().filter(.isDirectory).flatMap(getFile)</p> 
 <p>}</p> 
 <p>2.解决dtd校验文件问题</p> 
 <p>源码：</p> 
 <p>这儿我们会用到loadFile去加载xml文件，我们根据源码可以看到loadFile传进去了一个parser方法:</p> 
 <p>XML.XML.loadFile(filename)</p> 
 <p>/**</p> 
 <p>Loads XML from the given InputSource, using the supplied parser.</p> 
 <p>The methods available in scala.xml.XML use the XML parser in the JDK.</p> 
 <p>/</p> 
 <p>def loadXML(source: InputSource, parser: SAXParser): T = {<!-- --></p> 
 <p>val newAdapter = adapter</p> 
 <p>newAdapter.scopeStack push TopScope</p> 
 <p>parser.parse(source, newAdapter)</p> 
 <p>newAdapter.scopeStack.pop()</p> 
 <p>newAdapter.rootElem.asInstanceOf[T]</p> 
 <p>}</p> 
 <p>/* Loads XML from the given file, file descriptor, or filename. */</p> 
 <p>def loadFile(file: File): T = loadXML(fromFile(file), parser)</p> 
 <p>def loadFile(fd: FileDescriptor): T = loadXML(fromFile(fd), parser)</p> 
 <p>继承XMLLoader，重写parser方法，设置参数忽略校验</p> 
 <p>object MyXML extends XMLLoader[Elem] {<!-- --></p> 
 <p>override def parser: SAXParser = {<!-- --></p> 
 <p>val f = javax.xml.parsers.SAXParserFactory.newInstance()</p> 
 <p>f.setNamespaceAware(false)</p> 
 <p>f.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)</p> 
 <p>f.newSAXParser()</p> 
 <p>}</p> 
 <p>}</p> 
 <p>最终代码实现：</p> 
 <p>import java.io.File</p> 
 <p>import java.util</p> 
 <p>import org.apache.spark.sql.SparkSession</p> 
 <p>import scala.xml.{Elem, SAXParser, XML}</p> 
 <p>import scala.xml.factory.XMLLoader</p> 
 <p>object ParseCNPatentFile {<!-- --></p> 
 <p>def main(args: Array[String]): Unit = {<!-- --></p> 
 <p>//构建sparksession</p> 
 <p>val spark = SparkSession.builder()</p> 
 <p>.appName("SparkSQLDemo")</p> 
 <p>.master("local[1]")</p> 
 <p>.getOrCreate()</p> 
 <p>val sc = spark.sparkContext</p> 
 <p>//需要解析的文件路径</p> 
 <p>val path = new File("data/CNPatentData")</p> 
 <p>val parseddata = getFile(path).map(line =&gt; {<!-- --></p> 
 <p>// println(line.toString)</p> 
 <p>val parseFile = line.toString</p> 
 <p>//解析xml的方法</p> 
 <p>parseCNPatent(parseFile)</p> 
 <p>})</p> 
 <p>sc.parallelize(parseddata).saveAsTextFile("data/CNPatentData/result")</p> 
 <p>}</p> 
 <p>/**</p> 
 <p>递归查找文件及子文件夹下面的XML文件</p> 
 <p>@param file</p> 
 <p>@return</p> 
 <p>*/</p> 
 <p>def getFile(file:File): Array[File] ={<!-- --></p> 
 <p>val files = file.listFiles().filter(! .isDirectory)</p> 
 <p>.filter(t =&gt; t.toString.toLowerCase.endsWith(".xml")) //此处读取.txt and .md文件</p> 
 <p>files ++ file.listFiles().filter(.isDirectory).flatMap(getFile)</p> 
 <p>}</p> 
 <p>/**</p> 
 <p>解析xml文件</p> 
 <p>@param filename</p> 
 <p>@return</p> 
 <p>/</p> 
 <p>def parseCNPatent(filename:String): String ={<!-- --></p> 
 <p>// val someXML = XML.loadFile(filename)</p> 
 <p>val someXML = MyXML.loadFile(filename)</p> 
 <p>/*</p> 
 <p>提取基础属性</p> 
 <p>*/</p> 
 <p>val ossfoder = filename</p> 
 <p>val file = (someXML \ "PatentDocumentAndRelated" "@file").text</p> 
 <p>.</p> 
 <p>.</p> 
 <p>.</p> 
 <p>}</p> 
 <p>object MyXML extends XMLLoader[Elem] {<!-- --></p> 
 <p>override def parser: SAXParser = {<!-- --></p> 
 <p>val f = javax.xml.parsers.SAXParserFactory.newInstance()</p> 
 <p>f.setNamespaceAware(false)</p> 
 <p>f.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false)</p> 
 <p>f.newSAXParser()</p> 
 <p>}</p> 
 <p>}</p> 
 <p>}</p> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3f21c4d75335e1b1bafa997de459a2c0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python中shuffle是什么意思_python中shuffle()方法的功能详解</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2967cc4351615939ee240d4490333aea/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java八股文指的是什么_八股文是指什么？</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>