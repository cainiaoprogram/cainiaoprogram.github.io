<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>juc之CurrentHashMap (二) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="juc之CurrentHashMap (二)" />
<meta property="og:description" content="我们熟知的缓存技术（比如redis、memcached）的核心其实就是在内存中维护一张巨大的哈希表，还有大家熟知的HashMap、CurrentHashMap等的应用。
文章目录 1.ConcurrentHashMap与HashMap等的区别1.1 HashMap1.2 HashTable 2.ConcurrentHashMap2.1 JDK1.7版本的CurrentHashMap的实现原理2.2 JDK1.8版本的CurrentHashMap的实现原理 3.总结 1.ConcurrentHashMap与HashMap等的区别 1.1 HashMap 我们知道HashMap是线程不安全的，在多线程环境下，使用Hashmap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。
1.2 HashTable HashTable和HashMap的实现原理几乎一样，差别无非是
HashTable不允许key和value为null
HashTable是线程安全的
但是HashTable线程安全的策略实现代价却太大了，简单粗暴，get/put所有相关操作都是synchronized的，这相当于给整个哈希表加了一把大锁。
多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。
2.ConcurrentHashMap 主要就是为了应对hashmap在并发环境下不安全而诞生的，ConcurrentHashMap的设计与实现非常精巧，大量的利用了volatile，final，CAS等lock-free技术来减少锁竞争对于性能的影响。
我们都知道Map一般都是数组&#43;链表结构（JDK1.8该为数组&#43;红黑树）。
ConcurrentHashMap避免了对全局加锁改成了局部加锁操作，这样就极大地提高了并发环境下的操作速度，由于ConcurrentHashMap在JDK1.7和1.8中的实现非常不同，接下来我们谈谈JDK在1.7和1.8中的区别。
2.1 JDK1.7版本的CurrentHashMap的实现原理 在JDK1.7中ConcurrentHashMap采用了数组&#43;Segment&#43;分段锁的方式实现。
ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表,同时又是一个ReentrantLock（Segment继承了ReentrantLock）。
内部结构图
从上面的结构我们可以了解到，ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作。
第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部。
该结构的优劣势
坏处是这一种结构的带来的副作用是Hash的过程要比普通的HashMap要长。
好处是写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment，这样，在最理想的情况下，ConcurrentHashMap可以最高同时支持Segment数量大小的写操作（刚好这些写操作都非常平均地分布在所有的Segment上）。
所以，通过这一种结构，ConcurrentHashMap的并发能力可以大大的提高。
2.2 JDK1.8版本的CurrentHashMap的实现原理 synchronized&#43;cas&#43;node&#43;红黑树的实现方式来设计，内部大量采用CAS操作,Node中的val和next都有volatle修饰。保证了原子性。
JDK8中彻底放弃了Segment转而采用的是Node，其设计思想也不再是JDK1.7中的分段锁思想。
查找,替换,赋值的操作都有CAS
class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; { final int hash; final K key; volatile V val; volatile Node&lt;K,V&gt; next; //... 省略部分代码 } Java8 ConcurrentHashMap结构基本上和Java8的HashMap一样，不过保证线程安全性。
在JDK8中ConcurrentHashMap的结构，由于引入了红黑树，使得ConcurrentHashMap的实现非常复杂，我们都知道，红黑树是一种性能非常好的二叉查找树，其查找性能为O（logN），但是其实现过程也非常复杂，而且可读性也非常差，Doug
Lea的思维能力确实不是一般人能比的，早期完全采用链表结构时Map的查找时间复杂度为O（N），JDK8中ConcurrentHashMap在链表的长度大于某个阈值的时候会将链表转换成红黑树进一步提高其查找性能。
3.总结 其实可以看出JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock&#43;Segment&#43;HashEntry，到JDK1.8版本中synchronized&#43;CAS&#43;HashEntry&#43;红黑树。
1.数据结构：取消了Segment分段锁的数据结构，取而代之的是数组&#43;链表&#43;红黑树的结构。
2.保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS&#43;Synchronized保证线程安全。
3.锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fb0461a065717a96b04944decc016d08/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-06-04T12:30:50+08:00" />
<meta property="article:modified_time" content="2022-06-04T12:30:50+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">juc之CurrentHashMap (二)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-github-gist">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>我们熟知的缓存技术（比如redis、memcached）的核心其实就是在内存中维护一张巨大的哈希表，还有大家熟知的HashMap、CurrentHashMap等的应用。<br> </p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><ul><li><a href="#1ConcurrentHashMapHashMap_2" rel="nofollow">1.ConcurrentHashMap与HashMap等的区别</a></li><li><ul><li><a href="#11_HashMap_3" rel="nofollow">1.1 HashMap</a></li><li><a href="#12_HashTable_6" rel="nofollow">1.2 HashTable</a></li></ul> 
    </li><li><a href="#2ConcurrentHashMap_15" rel="nofollow">2.ConcurrentHashMap</a></li><li><ul><li><a href="#21_JDK17CurrentHashMap_21" rel="nofollow">2.1 JDK1.7版本的CurrentHashMap的实现原理</a></li><li><a href="#22_JDK18CurrentHashMap_49" rel="nofollow">2.2 JDK1.8版本的CurrentHashMap的实现原理</a></li></ul> 
    </li><li><a href="#3_75" rel="nofollow">3.总结</a></li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h4><a id="1ConcurrentHashMapHashMap_2"></a>1.ConcurrentHashMap与HashMap等的区别</h4> 
<h5><a id="11_HashMap_3"></a>1.1 HashMap</h5> 
<p>我们知道HashMap是线程不安全的，在多线程环境下，使用Hashmap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。</p> 
<h5><a id="12_HashTable_6"></a>1.2 HashTable</h5> 
<p>HashTable和HashMap的实现原理几乎一样，差别无非是</p> 
<p>HashTable不允许key和value为null<br> HashTable是线程安全的<br> 但是HashTable线程安全的策略实现代价却太大了，简单粗暴，get/put所有相关操作都是synchronized的，这相当于给整个哈希表加了一把大锁。</p> 
<p>多线程访问时候，只要有一个线程访问或操作该对象，那其他线程只能阻塞，相当于将所有的操作串行化，在竞争激烈的并发场景中性能就会非常差。</p> 
<h4><a id="2ConcurrentHashMap_15"></a>2.ConcurrentHashMap</h4> 
<p>主要就是为了应对hashmap在并发环境下不安全而诞生的，ConcurrentHashMap的设计与实现非常精巧，大量的利用了volatile，final，CAS等lock-free技术来减少锁竞争对于性能的影响。<br> 我们都知道Map一般都是数组+链表结构（JDK1.8该为数组+红黑树）。</p> 
<p>ConcurrentHashMap避免了对全局加锁改成了局部加锁操作，这样就极大地提高了并发环境下的操作速度，由于ConcurrentHashMap在JDK1.7和1.8中的实现非常不同，接下来我们谈谈JDK在1.7和1.8中的区别。</p> 
<h5><a id="21_JDK17CurrentHashMap_21"></a>2.1 JDK1.7版本的CurrentHashMap的实现原理</h5> 
<p><strong>在JDK1.7中ConcurrentHashMap采用了数组+Segment+分段锁的方式实现。</strong></p> 
<p>ConcurrentHashMap中的分段锁称为Segment，它即类似于HashMap的结构，即内部拥有一个Entry数组，数组中的每个元素又是一个链表,同时又是一个ReentrantLock（Segment继承了ReentrantLock）。</p> 
<p><strong>内部结构图</strong></p> 
<p><img src="https://images2.imgbox.com/aa/91/hyhWxV0H_o.png" alt="在这里插入图片描述"><br> 从上面的结构我们可以了解到，ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作。</p> 
<p>第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部。</p> 
<p><strong>该结构的优劣势</strong></p> 
<p>坏处是这一种结构的带来的副作用是Hash的过程要比普通的HashMap要长。</p> 
<p>好处是写操作的时候可以只对元素所在的Segment进行加锁即可，不会影响到其他的Segment，这样，在最理想的情况下，ConcurrentHashMap可以最高同时支持Segment数量大小的写操作（刚好这些写操作都非常平均地分布在所有的Segment上）。<br> 所以，通过这一种结构，ConcurrentHashMap的并发能力可以大大的提高。</p> 
<h5><a id="22_JDK18CurrentHashMap_49"></a>2.2 JDK1.8版本的CurrentHashMap的实现原理</h5> 
<p><strong>synchronized+cas+node+红黑树</strong>的实现方式来设计，内部大量采用CAS操作,Node中的val和next都有volatle修饰。保证了原子性。</p> 
<p>JDK8中彻底放弃了Segment转而采用的是Node，其设计思想也不再是JDK1.7中的分段锁思想。</p> 
<p>查找,替换,赋值的操作都有CAS</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>
    <span class="token keyword">final</span> <span class="token class-name">K</span> key<span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> <span class="token class-name">V</span> val<span class="token punctuation">;</span>
    <span class="token keyword">volatile</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
    <span class="token comment">//... 省略部分代码</span>
<span class="token punctuation">}</span> 
</code></pre> 
<p>Java8 ConcurrentHashMap结构基本上和Java8的HashMap一样，不过保证线程安全性。</p> 
<p>在JDK8中ConcurrentHashMap的结构，由于引入了红黑树，使得ConcurrentHashMap的实现非常复杂，我们都知道，红黑树是一种性能非常好的二叉查找树，其查找性能为O（logN），但是其实现过程也非常复杂，而且可读性也非常差，Doug<br> Lea的思维能力确实不是一般人能比的，早期完全采用链表结构时Map的查找时间复杂度为O（N），JDK8中ConcurrentHashMap在链表的长度大于某个阈值的时候会将链表转换成红黑树进一步提高其查找性能。<br> <img src="https://images2.imgbox.com/14/9c/t0JU1zo4_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="3_75"></a>3.总结</h4> 
<p>其实可以看出JDK1.8版本的ConcurrentHashMap的数据结构已经接近HashMap，相对而言，ConcurrentHashMap只是增加了同步的操作来控制并发，从JDK1.7版本的ReentrantLock+Segment+HashEntry，到JDK1.8版本中synchronized+CAS+HashEntry+红黑树。</p> 
<p>1.数据结构：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。<br> 2.保证线程安全机制：JDK1.7采用segment的分段锁机制实现线程安全，其中segment继承自ReentrantLock。JDK1.8采用CAS+Synchronized保证线程安全。<br> 3.锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁（Node）。<br> 4.链表转化为红黑树:定位结点的hash算法简化会带来弊端,Hash冲突加剧,因此在链表节点数量大于8时，会将链表转化为红黑树进行存储。<br> 5.查询时间复杂度：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1de7a672e939eda06c76a626b36a0c18/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Flyway简介及使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0a6ad206aa9f1a415b6cd9714d336404/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C语言大作业 俄罗斯方块（一）主界面和排行榜界面</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>