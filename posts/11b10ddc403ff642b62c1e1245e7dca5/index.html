<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入理解CyclicBarrier - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深入理解CyclicBarrier" />
<meta property="og:description" content="CyclicBarrier翻译过来是回环栅栏，它可以实现让一组线程等待至某个状态之后再全部同步执行，这个状态叫屏障点。当所有等待线程都被释放后，CyclicBarrier可以重置再次使用。
CyclicBarrier的功能是由ReentrantLock和Condition共同实现的，因此在其内部拥有ReentrantLock类型的lock属性和Condition类型的trip属性。此外，还有用于保存该屏障拦截的线程数parties属性和当前剩余等待的线程数count属性。这些属性的作用在后面我们详细介绍源码时再详细介绍。
CyclicBarrier的构造函数如下：
//parties表示当前屏障拦截的线程数 public CyclicBarrier(int parties) { this(parties, null); } //barriesAction表示当所有线程都到达屏障时首先执行的行为 public CyclicBarrier(int parties, Runnable barrierAction) { if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction; } 常用方法如下：
public int await() throws InterruptedException, BrokenBarrierException：当前线程阻塞，直到parties个线程全部调用await()方法时再唤醒。BrokenBarrierException异常表示栅栏已被破坏，可能是由于其中的一个线程await()时被中断或超时；public void reset()：重置屏障计数器的值，并将条件队列的所有线程唤醒。 由于CyclicBarrier的计数器可以重置，屏障可以重复使用，因此当paries的整数倍数量的线程调用await()方法时程序都是可以正常结束的，否则由于还有线程在阻塞，程序会一直阻塞不会结束。例如下面的程序中定义了屏障的拦截线程数paties=3，随后分别在7个线程中调用CyclicBarrier的await()方法。
public class CyclicBarrierTest { public static void main(String[] args) { CyclicBarrier cyclicBarrier = new CyclicBarrier(3); for (int i = 0; i &lt; 7; i&#43;&#43;) { new Thread(() -&gt; { try { System." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/11b10ddc403ff642b62c1e1245e7dca5/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-21T23:22:30+08:00" />
<meta property="article:modified_time" content="2023-08-21T23:22:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入理解CyclicBarrier</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="u41ec1d0e">CyclicBarrier翻译过来是回环栅栏，它可以实现让一组线程等待至某个状态之后再全部同步执行，这个状态叫屏障点。当所有等待线程都被释放后，CyclicBarrier可以重置再次使用。</p> 
<p id="u134bdcb9">CyclicBarrier的功能是由ReentrantLock和Condition共同实现的，因此在其内部拥有ReentrantLock类型的lock属性和Condition类型的trip属性。此外，还有用于保存该屏障拦截的线程数parties属性和当前剩余等待的线程数count属性。这些属性的作用在后面我们详细介绍源码时再详细介绍。</p> 
<p id="ue22d557b">CyclicBarrier的构造函数如下：</p> 
<pre id="MO37H"><code>//parties表示当前屏障拦截的线程数
public CyclicBarrier(int parties) {
    this(parties, null);
}
//barriesAction表示当所有线程都到达屏障时首先执行的行为
public CyclicBarrier(int parties, Runnable barrierAction) {
    if (parties &lt;= 0) throw new IllegalArgumentException();
    this.parties = parties;
    this.count = parties;
    this.barrierCommand = barrierAction;
}</code></pre> 
<p id="u6d598248">常用方法如下：</p> 
<ul><li id="u408aa92a">public int await() throws InterruptedException, BrokenBarrierException：当前线程阻塞，直到parties个线程全部调用await()方法时再唤醒。BrokenBarrierException异常表示栅栏已被破坏，可能是由于其中的一个线程await()时被中断或超时；</li><li id="u9ff30375">public void reset()：重置屏障计数器的值，并将条件队列的所有线程唤醒。</li></ul> 
<p id="u922cc182">由于CyclicBarrier的计数器可以重置，屏障可以重复使用，因此当paries的整数倍数量的线程调用await()方法时程序都是可以正常结束的，否则由于还有线程在阻塞，程序会一直阻塞不会结束。例如下面的程序中定义了屏障的拦截线程数paties=3，随后分别在7个线程中调用CyclicBarrier的await()方法。</p> 
<pre id="mFX2K"><code>public class CyclicBarrierTest {
    public static void main(String[] args) {
        CyclicBarrier cyclicBarrier = new CyclicBarrier(3);
        for (int i = 0; i &lt; 7; i++) {
            new Thread(() -&gt; {
				try {
					System.out.println(Thread.currentThread().getName()
							+ "开始等待其他线程");
					cyclicBarrier.await();
					System.out.println(Thread.currentThread().getName() + "开始执行");
					Thread.sleep(5000);
					System.out.println(Thread.currentThread().getName() + "执行完毕");

				} catch (Exception e) {
					e.printStackTrace();
				}
			}).start();
        }
    }
}</code></pre> 
<p id="u3555a414">控制人打印结果如下图，可以发现程序没有结束，因此线程Thread-6还在阻塞。</p> 
<p id="u590e7643"></p> 
<p class="img-center"><img alt="" height="431" id="ue908b125" src="https://images2.imgbox.com/71/2f/cMMlO1ZJ_o.png" width="372"></p> 
<h3 id="KxtEV">CyclicBarrier原理</h3> 
<p id="u320fa8ee">由于CyclicBarrier是借助ReentrantLock和Condition实现的，因此我们在深入解析CyclicBarrier源码之前先来简单介绍下ReentrantLock和Condition是怎么工作的。</p> 
<h4 id="MLwhZ">ReentrantLock和Condition</h4> 
<p id="u8b558ece">我们都知道AQS是基于MESA管程模型实现的，ReentrantLock是AQS的独占锁实现，而Condition可以理解为是MESA模型中的条件变量，那么当执行下面的程序时锁（ReentrantLock）是怎么变化的呢？需要注意的是，下面的程序中只有一个ReentrantLock对象，因此只有一把锁。</p> 
<pre id="I82Xq"><code>public class ReentrantLockDemo6 {
    private static ReentrantLock lock = new ReentrantLock();
    private static Condition cigCon = lock.newCondition();
    private static Condition takeCon = lock.newCondition();

    private static boolean hashcig = false;
    private static boolean hastakeout = false;

    //送烟
    public void cigratee(){
        lock.lock();
        try {
            while(!hashcig){
                try {
                    log.debug("没有烟，歇一会");
                    cigCon.await();

                }catch (Exception e){
                    e.printStackTrace();
                }
            }
            log.debug("有烟了，干活");
        }finally {
            lock.unlock();
        }
    }

    //送外卖
    public void takeout(){
        lock.lock();
        try {
            while(!hastakeout){
                try {
                    log.debug("没有饭，歇一会");
                    takeCon.await();

                }catch (Exception e){
                    e.printStackTrace();
                }
            }
            log.debug("有饭了，干活");
        }finally {
            lock.unlock();
        }
    }

    public static void main(String[] args) {
        ReentrantLockDemo6 test = new ReentrantLockDemo6();
        new Thread(() -&gt;{
            test.cigratee();
        },"t1").start();

        new Thread(() -&gt; {
            test.takeout();
        },"t2").start();

        new Thread(() -&gt;{
            lock.lock();
            try {
                hashcig = true;
                log.debug("唤醒送烟的等待线程");
                cigCon.signal();
            }finally {
                lock.unlock();
            }


        },"t3").start();

        new Thread(() -&gt;{
            lock.lock();
            try {
                hastakeout = true;
                log.debug("唤醒送饭的等待线程");
                takeCon.signal();
            }finally {
                lock.unlock();
            }


        },"t4").start();
    }

}</code></pre> 
<p id="u4e1776d1">控制台打印结果如下：</p> 
<p id="u7fe421ff"></p> 
<p class="img-center"><img alt="" height="197" id="u7d49f73f" src="https://images2.imgbox.com/b8/d6/ob47IUU7_o.png" width="854"></p> 
<ol><li id="u3495f18f">线程t1执行cigratee()方法，cigratee()内部执行lock()方法加锁（即将当前lock对象的state设为1），随后cigCon调用await()方法释放锁（即将当前lock对象的state设为0），并将线程t1阻塞；</li><li id="u90700aef">线程t2执行takeout()方法，takeout()内部执行lock()方法加锁（即将当前lock对象的state设为1），随后takeCon调用await()方法释放锁（即将当前lock对象的state设为0），并将线程t2阻塞；</li><li id="ue4ce6ea5">线程t3调用cigCon.signal()方法将阻塞在cigCon这个“条件变量”的条件队列线程t1转移到lock的同步等待队列中，当线程t1获取锁后继续执行后面的逻辑，执行完后再调用unlock()方法释放锁；</li><li id="u2b72e71a">线程t4调用takeCon.signal()方法将阻塞在takeCon这个“条件变量”的条件队列线程t2转移到lock的同步等待队列中，当线程t2获取锁后继续执行后面的逻辑，执行完后再调用unlock()方法释放锁。</li></ol> 
<p id="u4c86c2d9">关于以上，需要做更多的说明：</p> 
<ul><li id="ud1e2c07f">ReentrantLock加锁的方式是将state设为1，并且保存持有锁的线程引用；解锁的方式是将state设为0，并释放线程引用；</li><li id="u3c5ae168">Condition的await()方法会释放锁，且阻塞当前线程，这一点可以从程序输出结果得到；</li><li id="ub6b9ffc1">Condition的signal()方法在唤醒阻塞在当前条件变量上的线程时，需要首先获取锁，否则会抛出IllegalMonitorStateException异常；</li><li id="uedb7a7b8">按照MESA模型，调用Condition的signal()方法后，会将当前条件变量的条件队列的线程转移到锁的同步等待队列中，当获取锁时才会继续执行后续逻辑。</li></ul> 
<p id="u23fe6272">我们可以通过跟踪CyclicBarrier的源码来达到学习CyclicBarrier以及ReentrantLock与Condition协作的目的。</p> 
<h4 id="jkBK4">CyclicBarrier源码</h4> 
<p id="ueedb37b3">这里是从CyclicBarrier的await()方法一步一步地介绍的，较复杂，如果不想看可以直接跳到这一部分后面总结的await()方法执行的流程图部分。</p> 
<p id="u5e0b4510">我们使用下面的程序来切入CyclicBarrier源码的介绍。在下面的程序中，使用三个线程分别计算三位同学的平均分，三个线程都计算完成后再计算三位同学的平均分。</p> 
<pre id="wdA4c"><code>public class CyclicBarrierTest2 {

    //保存每个学生的平均成绩
    private ConcurrentHashMap&lt;String, Integer&gt; map=new ConcurrentHashMap&lt;String,Integer&gt;();

    private ExecutorService threadPool= Executors.newFixedThreadPool(3);

    private CyclicBarrier cb=new CyclicBarrier(3,()-&gt;{
        int result=0;
        Set&lt;String&gt; set = map.keySet();
        for(String s:set){
            result+=map.get(s);
        }
        System.out.println("三人平均成绩为:"+(result/3)+"分");
    });


    public void count(){
        for(int i=0;i&lt;3;i++){
            threadPool.execute(new Runnable(){

                @Override
                public void run() {
                    //获取学生平均成绩
                    int score=(int)(Math.random()*40+60);
                    map.put(Thread.currentThread().getName(), score);
                    System.out.println(Thread.currentThread().getName()
                            +"同学的平均成绩为："+score);
                    try {
                        //执行完运行await(),等待所有学生平均成绩都计算完毕
                        cb.await();
                    } catch (InterruptedException | BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                }

            });
        }
    }


    public static void main(String[] args) {
        CyclicBarrierTest2 cb=new CyclicBarrierTest2();
        cb.count();
    }
}</code></pre> 
<p id="u04fc46c5">当线程t1首先计算完成执行cb.await()方法，await()方法实现如下：</p> 
<pre id="JjsxX"><code>public int await() throws InterruptedException, BrokenBarrierException {
    try {
        return dowait(false, 0L);
    } catch (TimeoutException toe) {
        throw new Error(toe); // cannot happen
    }
}</code></pre> 
<p id="u280e6f0d">dowait()方法实现如下：</p> 
<pre id="UYuEq"><code>private int dowait(boolean timed, long nanos)
        throws InterruptedException, BrokenBarrierException,
               TimeoutException {
        //1.使用CyclicBarrier的lock对象加锁
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            final Generation g = generation;

            if (g.broken)
                throw new BrokenBarrierException();

            if (Thread.interrupted()) {
                breakBarrier();
                throw new InterruptedException();
            }

            //2.当前线程到达屏障，因此count数量-1，判断计算后的值是否为0
            int index = --count;
            if (index == 0) { 
                boolean ranAction = false;
                try {
                    final Runnable command = barrierCommand;
                    if (command != null)
                        command.run();
                    ranAction = true;
                    nextGeneration();
                    return 0;
                } finally {
                    if (!ranAction)
                        breakBarrier();
                }
            }

            //3.当前线程阻塞，直到被唤醒、中断或超时
            for (;;) {
                try {
                    if (!timed)
                        //4.调用CyclicBarrier的Condition的await()方法
                        trip.await();
                    else if (nanos &gt; 0L)
                        nanos = trip.awaitNanos(nanos);
                } catch (InterruptedException ie) {
                    if (g == generation &amp;&amp; ! g.broken) {
                        breakBarrier();
                        throw ie;
                    } else {
                        Thread.currentThread().interrupt();
                    }
                }

                if (g.broken)
                    throw new BrokenBarrierException();

                if (g != generation)
                    return index;

                if (timed &amp;&amp; nanos &lt;= 0L) {
                    breakBarrier();
                    throw new TimeoutException();
                }
            }
        } finally {
            lock.unlock();
        }
    }</code></pre> 
<ol><li id="u21cad220">前面提到过CyclicBarrier中有一个ReentrantLock类型的属性lock，此处使用lock对象加锁，目的其实是为了后面Condition的await()方法的调用。需要注意的是，按照MESA模型，线程进入条件队列必须是在其获得锁之后，因此此处必须先加锁；</li><li id="uf6e4e280">此时count = parties = 3，线程t1已到达屏障处，因此count需要减1，此时count=2，parties仍为3，parties的值是不会变的，原因后面会介绍；</li><li id="u27042d42">由于此时count!=0，因此我们直接跳到4处，调用CyclicBarrier的Condition类型的属性trip的await()方法。</li></ol> 
<p id="u95eaee74">这里需要特别说明的是，Condition是一个接口，其实现类是AQS中的一个内部类ConditionObject，在其内部维护了条件等待队列的首节点Node对象firstWaiter和尾结点lastWaiter，另外还包括一些维护条件队列出队入队操作的方法。此处调用的trip的await()方法当然是Condition接口的await()方法，实现如下：</p> 
<pre id="RsU0h"><code>public final void await() throws InterruptedException {
        if (Thread.interrupted())
            throw new InterruptedException();
    	//1
        Node node = addConditionWaiter();
    	//2
        int savedState = fullyRelease(node);
        int interruptMode = 0;
    	//3
        while (!isOnSyncQueue(node)) {
            LockSupport.park(this);
            if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
                break;
        }
    	//4
        if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)
            interruptMode = REINTERRUPT;
        if (node.nextWaiter != null) // clean up if cancelled
            unlinkCancelledWaiters();
        if (interruptMode != 0)
            reportInterruptAfterWait(interruptMode);
    }</code></pre> 
<p id="u4fb34ff3">首先进入addConditionWaiter()方法，实现如下：</p> 
<pre id="QTICi"><code>private Node addConditionWaiter() {
    Node t = lastWaiter;
    if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) {
        unlinkCancelledWaiters();
        t = lastWaiter;
    }
    Node node = new Node(Thread.currentThread(), Node.CONDITION);
    if (t == null)
        firstWaiter = node;
    else
        t.nextWaiter = node;
    lastWaiter = node;
    return node;
}</code></pre> 
<ol><li id="u6cd62082">由于此时条件等待队列还是空队列，因此尾节点lastWaiter为null；</li><li id="uadb8b70d">将线程t1封装到Node对象中，并且将当前Node节点的状态设为CONDITION（值为-2）表示该节点是条件等待队列的节点；</li><li id="u0e7c2298">将firstWaiter首节点和尾节点lastWaiter都指向线程t1的Node节点，表示t1节点入队。</li></ol> 
<p id="ua2dd7445">然后回到await()方法，进入2处的fullRelease()方法，其实现逻辑如下：</p> 
<pre id="ggi84"><code>final int fullyRelease(Node node) {
    boolean failed = true;
    try {
        int savedState = getState();
        if (release(savedState)) {
            failed = false;
            return savedState;
        } else {
            throw new IllegalMonitorStateException();
        }
    } finally {
        if (failed)
            node.waitStatus = Node.CANCELLED;
    }
}</code></pre> 
<p id="uebb3cb46">需要注意的是，此时还在CyclicBarrier的lock锁内，此处调用release()方法释放锁（主要就是将state设为0，ReentrantLock的表示独占锁拥有者的exclusiveOwnerThread属性置为null），关于release()方法我们在介绍ReentrantLock的文章中介绍过，此处不再赘述。</p> 
<p id="u3466db18">再返回await()方法的代码3处，isOnSyncQueue()方法的实现如下：</p> 
<pre id="O9Nxk"><code>final boolean isOnSyncQueue(Node node) {
    if (node.waitStatus == Node.CONDITION || node.prev == null)
        return false;
    if (node.next != null) 
        return true;
    return findNodeFromTail(node);
}</code></pre> 
<p id="u0b8f3b8c">由于线程t1节点是在条件等待队列中，其状态是CONDITION，因此此处直接返回false。</p> 
<p id="uebe46f4f">再返回await()方法，可以看到isOnSyncQueue()方法返回false后就执行了LockSupport的park()方法将当前线程t1阻塞。</p> 
<p id="u580421ed">此时线程t1内部执行CyclicBarrier的await()方法的逻辑就暂时完成了，总结如下：</p> 
<ol><li id="u3e00d2f6">使用CyclicBarrier的lock对象加锁；</li><li id="uab8537d6">将CyclicBarrier的计数器count的值减1，此时count=2；</li><li id="u05db0721">判断count不为0，调用Condition类型的trip属性的await()方法；</li><li id="uc65ceccb">将当前线程t1封装到Node节点对象中，状态为CONDITION，表示该节点在条件等待队列中，将线程t1节点入队条件等待队列，此时firstWaiter和lastWaiter指向的都是线程t1节点；</li><li id="u0653cf6d">释放lock锁；</li><li id="u8983be01">将线程t1阻塞。</li></ol> 
<p id="u9be9afe3">随后线程t2也执行到了await()方法，此处我们不再一步步地跟踪了，其执行逻辑如下：</p> 
<ol><li id="u1feaba51">使用CyclicBarrier的lock对象加锁；</li><li id="u3baf246a">将CyclicBarrier的计数器count的值减1，此时count=1；</li><li id="u191f6ea1">判断count不为0，调用Condition类型的trip属性的await()方法；</li><li id="ufbe5123c">将当前线程t2封装到Node节点对象中，状态为CONDITION，表示该节点在条件等待队列中，将线程t2节点入队条件等待队列，此时firstWaiter指向线程t1节点，lastWaiter指向线程t2节点；</li><li id="udf93bc23">释放lock锁；</li><li id="ub3114f8f">将线程t2阻塞。</li></ol> 
<p id="u021ef0f3">最后线程t3也执行到了await()方法，前两个步骤与线程t1和t2一样：</p> 
<ol><li id="u80298756">使用CyclicBarrier的lock对象加锁；</li><li id="u02bde4de">将CyclicBarrier的计数器count的值减1，此时count=0；</li></ol> 
<p id="u668ba321">在第三个步骤dowait()方法，判断count的值为0，此处与线程t3与前面的线程逻辑不再一样了，相关部分代码如下：</p> 
<pre id="oMvaR"><code>if (index == 0) {  // tripped
    boolean ranAction = false;
    try {
        final Runnable command = barrierCommand;
        if (command != null)
            command.run();
        ranAction = true;
        nextGeneration();
        return 0;
    } finally {
        if (!ranAction)
            breakBarrier();
    }
}</code></pre> 
<p id="udb4435a6">此处由于计数器count=0，已经到了屏障处，因此首先执行我们在构造函数中传入的barrierCommand任务。随后调用nextGeneration()方法，实现如下：</p> 
<pre id="MtDPL"><code>private void nextGeneration() {
    trip.signalAll();
    count = parties;
    generation = new Generation();
}</code></pre> 
<p id="u26d38647">可以看到又调用了Condition的signalAll()方法，实现如下：</p> 
<pre id="Y7CMb"><code>public final void signalAll() {
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    Node first = firstWaiter;
    if (first != null)
        doSignalAll(first);
}</code></pre> 
<p id="u751cb826">首先判断当前线程t2是否是获取独占锁的线程，是的。随后判断条件队列的首节点即线程t1节点不为空，调用doSignalAll()方法，实现如下：</p> 
<pre id="Vs1ND"><code>private void doSignalAll(Node first) {
    lastWaiter = firstWaiter = null;
    do {
        Node next = first.nextWaiter;
        first.nextWaiter = null;
        transferForSignal(first);
        first = next;
    } while (first != null);
}</code></pre> 
<ol><li id="u6bfe557a">将条件队列的首节点和尾节点置为null；</li><li id="u797e148f">将首节点（线程t1节点）出队，执行transferForsignal()方法；</li><li id="u74402fb5">循环条件队列，不断地将节点出队，调用transferForsignal()方法。</li></ol> 
<p id="u7ea4f49e">在我们这个例子中循环了两次，分别为线程t1和线程t2的节点执行transferForsignal()方法，transferForsignal()方法实现如下：</p> 
<pre id="zmteb"><code>final boolean transferForSignal(Node node) {
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;
    Node p = enq(node);
    int ws = p.waitStatus;
    if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        LockSupport.unpark(node.thread);
    return true;
}</code></pre> 
<ol><li id="u4ad46fb0">使用CAS将节点的waitStatus置为0，在此之前条件队列节点的状态为CONDITION（-2）；</li><li id="uc818323c">调用enq()方法将节点入队到AQS的同步等待队列中，此方法在介绍ReentrantLock时也介绍过，不再赘述；</li><li id="u6b083de4">随后使用CAS将节点在同步等待队列中的前一个节点的waitStatus置为-1，表示当前节点可以被唤醒。</li></ol> 
<p id="u2961766a">线程t2的逻辑到此处就执行完成了，一层层的方法返回，最终CyclicBarrier的doWait()方法的finally块中执行lock.unpark()方法。unpark()方法唤醒的是当前lock对象的同步等待队列的头节点，在当前lock锁竞争激烈的场景下，头节点有可能不是线程t1或者线程t2。此处需要注意的是，当线程t1或线程t2获得CPU继续执行时，应该在它们被阻塞的地方继续执行，即在AQS的ConditionObject的await()方法的代码4处（翻到前面的代码块）继续执行。继续执行的acquireQueued()方法是循环调用CAS获取lock锁的逻辑，因此线程t1和t2在此处会再次获取到锁，执行我们自己的代码中CyclicBarrier的await()方法之后的逻辑。</p> 
<h4 id="oAnHN">CyclicBarrier的await()逻辑流程图</h4> 
<p id="ud24589f1"></p> 
<p id="ufbb797db"></p> 
<p id="u874f0ac3"></p> 
<p id="u5c24e3a6"></p> 
<p id="u5aeeb5bf"></p> 
<p id="uf00a53a6"></p> 
<p id="u3002cb38"></p> 
<p id="u1cf747ef"></p> 
<p id="uf014811e"></p> 
<p id="u3eb4a7a3"></p> 
<p id="u3527baae"></p> 
<p id="u9a7fbd60"></p> 
<p id="u69fd2679"></p> 
<p id="u31f36dc7"></p> 
<p id="uce2818d1"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e096c7617946f130f0d8a2d52e2d36c6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">gRPC 客户端调用服务端需要连接池吗？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/28f5537e2ac215785e0d8a96f7fd3a3b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">深入理解阻塞队列BlockingQueue</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>