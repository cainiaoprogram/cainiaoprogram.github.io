<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>如何使用filter过滤器对入参进行处理（完整版） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="如何使用filter过滤器对入参进行处理（完整版）" />
<meta property="og:description" content="阅读本文大概需要 9 分钟。
来自：blog.csdn.net/Muscleheng/article/details/80067772
遇见的问题： 前台把参数通过报文或者使用表单、ajax提交到后台，如果我们的请求参数是加密的，那么我们在controller里面的每一个方法里都需要进行解密处理。如果方法太多，那就太麻烦了。
设计方案： 使用过滤器，在一个Filter中将 HttpServletRequest 里的所有参数都取出来分别进行过滤然后再放回到该HttpServletRequest 中行不行呢？
通过测试后发现是不行的，因为HttpServletRequest 只提供了getParameter ，而没有提供setParameter；所以，我们只能自己写一个HttpServletRequest 方法继承HttpServletRequestWrapper，然后覆盖里面的方法，并且增加我们自己的setParameters方法，这样我们就可以为所欲为了，最后再在filter中调用该类的方法对参数进行处理（获取、修改、存储等等）。
解决方案： 在请求参数到达controller之前，在filter里面进行解密；这样，通过简单的过滤器处理，把需要处理的请求都在过滤器里进行解密操作，这样就等于实现了自动化处理。
这里我们针对两种不同的请求方式进行讲解：
普通的表单、ajax请求；
json格式的报文请求。（三步搞定）
1.普通的表单、ajax请求； 第一步：新建一个类
这个类继承自HttpServletRequestWrapper
import java.io.IOException; import java.util.HashMap; import java.util.Map; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletRequestWrapper; /** * 重写 HttpServletRequestWrapper * 处理表单、ajax请求 * @author zhaoheng * */ public class MyHttpServletRequestWrapper1 extends HttpServletRequestWrapper{ // 用于存储请求参数 private Map&lt;String , String[]&gt; params = new HashMap&lt;String, String[]&gt;(); // 构造方法 public MyHttpServletRequestWrapper1(HttpServletRequest request) throws IOException { super(request); // 把请求参数添加到我们自己的map当中 this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/f30a55599ea229a3971f69a4b0ebdfbe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-15T16:01:12+08:00" />
<meta property="article:modified_time" content="2022-02-15T16:01:12+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">如何使用filter过滤器对入参进行处理（完整版）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="js_content"> 
 <p>阅读本文大概需要 9 分钟。</p> 
 <p>来自：<em>blog.csdn.net/Muscleheng/article/details/80067772</em></p> 
 <h4>遇见的问题：</h4> 
 <p style="text-align:justify;">前台把参数通过报文或者使用表单、ajax提交到后台，如果我们的请求参数是加密的，那么我们在controller里面的每一个方法里都需要进行解密处理。如果方法太多，那就太麻烦了。</p> 
 <h4>设计方案：</h4> 
 <p style="text-align:justify;">使用过滤器，在一个Filter中将 HttpServletRequest 里的所有参数都取出来分别进行过滤然后再放回到该HttpServletRequest 中行不行呢？</p> 
 <p style="text-align:justify;">通过测试后发现是不行的，因为HttpServletRequest 只提供了getParameter ，而没有提供setParameter；所以，我们只能自己写一个HttpServletRequest 方法继承HttpServletRequestWrapper，然后覆盖里面的方法，并且增加我们自己的setParameters方法，这样我们就可以为所欲为了，最后再在filter中调用该类的方法对参数进行处理（获取、修改、存储等等）。</p> 
 <h4>解决方案：</h4> 
 <p style="text-align:justify;">在请求参数到达controller之前，在filter里面进行解密；这样，通过简单的过滤器处理，把需要处理的请求都在过滤器里进行解密操作，这样就等于实现了自动化处理。</p> 
 <p style="text-align:justify;">这里我们针对两种不同的请求方式进行讲解：</p> 
 <ol><li><p style="text-align:justify;">普通的表单、ajax请求；</p></li><li><p style="text-align:justify;">json格式的报文请求。（三步搞定）</p></li></ol> 
 <h5>1.普通的表单、ajax请求；</h5> 
 <p style="text-align:justify;"><strong>第一步：新建一个类</strong></p> 
 <p style="text-align:justify;">这个类继承自HttpServletRequestWrapper</p> 
 <pre class="has"><code class="language-go">import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;
/**
 * 重写 HttpServletRequestWrapper
 * 处理表单、ajax请求
 * @author zhaoheng
 *
 */
public class MyHttpServletRequestWrapper1 extends HttpServletRequestWrapper{  
  
  // 用于存储请求参数
  private Map&lt;String , String[]&gt; params = new HashMap&lt;String, String[]&gt;();  
  // 构造方法
     public MyHttpServletRequestWrapper1(HttpServletRequest request) throws IOException {    
         super(request);
         // 把请求参数添加到我们自己的map当中
         this.params.putAll(request.getParameterMap()); 
     }    
     
     
     /**
      * 添加参数到map中
      * @param extraParams
      */
     public void setParameterMap(Map&lt;String, Object&gt; extraParams) {
         for (Map.Entry&lt;String, Object&gt; entry : extraParams.entrySet()) {
             setParameter(entry.getKey(), entry.getValue());
         }
     }
     
     /**
      * 添加参数到map中
      * @param name 
      * @param value
      */
     public void setParameter(String name, Object value) {
         if (value != null) {
             System.out.println(value);
             if (value instanceof String[]) {
                 params.put(name, (String[]) value);
             } else if (value instanceof String) {
                 params.put(name, new String[]{(String) value});
             } else {
                 params.put(name, new String[]{String.valueOf(value)});
             }
         }
     }
     
     /**
      * 重写getParameter，代表参数从当前类中的map获取
      * @param name
      * @return
      */
     @Override
     public String getParameter(String name) {
         String[]values = params.get(name);
         if(values == null || values.length == 0) {
             return null;
         }
         return values[0];
     }

     /**
      * 重写getParameterValues方法，从当前类的 map中取值
      * @param name
      * @return
      */
     @Override
     public String[] getParameterValues(String name) {
         return params.get(name);
     }
}</code></pre> 
 <p style="text-align:justify;">通过建立这个类我们就能完成向request对象添加我们处理之后的参数了。</p> 
 <p style="text-align:justify;"><strong>第二步：通过实现filter接口建一个过滤器</strong></p> 
 <pre class="has"><code class="language-go">package com.zhh.filter;
import java.io.IOException;
import java.util.Arrays;
import java.util.List;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;

import org.apache.log4j.Logger;

import com.zhh.util.request.MyHttpServletRequestWrapper1;

/**
 * 参数处理验过滤器（针对ajax、表单等请求） 1.获取请求参数；2.对获取到的请求参数进行处理（解密、字符串替、请求参数分类截取等等）；3.把处理后的参数放回到请求列表里面
 * 
 * @author zhaoheng
 *
 */
public class ValidatorFilter1 implements Filter {

 private static final Logger log = Logger.getLogger(ValidatorFilter1.class);

 /**
  * 需要过滤的地址
  */
 private static List&lt;String&gt; urlList = Arrays.asList("/pastOrder/filterCsF");

 /**
  * 是否不需要过滤
  * 
  * @param requestUrl
  *            请求的url
  * @return
  */
 public boolean isPast(String requestUrl) {
  for (String url : urlList) {
   if (requestUrl.equals(url)) {
    return true;
   }
  }

  return false;
 }

 @Override
 public void destroy() {
 }

 @SuppressWarnings("unchecked")
 @Override
 public void doFilter(ServletRequest request, ServletResponse response,
   FilterChain chain) throws IOException, ServletException {
  log.info("过滤器2执行开始");
  String url = ((HttpServletRequest) request).getRequestURI().substring(((HttpServletRequest)request).getContextPath().length());

  //通过地址对特定的请求进行处理，如果不需要可以不用，如果不用，就会对使用的请求进行过滤
  if (isPast(url)) {
   MyHttpServletRequestWrapper1 requestWrapper1 = new MyHttpServletRequestWrapper1(
     (HttpServletRequest) request);
   // 1.获取需要处理的参数
   String email = requestWrapper1.getParameter("email");
   // 2.把处理后的参数放回去（这里是大小转小写处理）
   requestWrapper1.setParameter("email", email.toLowerCase());
   // 3.放行，把我们的requestWrapper1放到方法当中
   chain.doFilter(requestWrapper1, response);
  } else {
   chain.doFilter(request, response);
  }
 }

 @Override
 public void init(FilterConfig arg0) throws ServletException {
 }
}</code></pre> 
 <p style="text-align:justify;"><strong>第三步：过滤器的配置</strong></p> 
 <p style="text-align:justify;">方法一、在web.xml文件里面进行简单的配置（一般项目）</p> 
 <p style="text-align:justify;">把我们的过滤器在该文件中注册</p> 
 <pre class="has"><code class="language-go">&lt;!--  配置过滤器  --&gt;
   &lt;filter&gt;  
     &lt;filter-name&gt;ValidatorFilter1&lt;/filter-name&gt;  
     &lt;!--  我们写的过滤的地址   --&gt;
     &lt;filter-class&gt;com.zhh.filter.ValidatorFilter1&lt;/filter-class&gt;  
 &lt;/filter&gt;  
 &lt;filter-mapping&gt;  
     &lt;filter-name&gt;ValidatorFilter1&lt;/filter-name&gt;  
     &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  
 &lt;/filter-mapping&gt;</code></pre> 
 <p style="text-align:justify;"><strong>方法二、springboot项目的配置</strong></p> 
 <p style="text-align:justify;">新建一个配置类，加上@Configuration注解，在方法头加上@Bean注解</p> 
 <pre class="has"><code class="language-go">@Configuration
public class WebFileterConfig {
 /**
     * 配置过滤器
     * order属性:控制过滤器加载顺序：数字越小，加载越早
     * @return
     */
    @Bean
    public FilterRegistrationBean ValidatorFilterRegistration() {
        //新建过滤器注册类
        FilterRegistrationBean registration = new FilterRegistrationBean();
        // 添加我们写好的过滤器
        registration.setFilter( new ValidatorFilter1());
        // 设置过滤器的URL模式
        registration.addUrlPatterns("/*");
        registration.setOrder(Integer.MAX_VALUE-10);
        return registration;
    }
}</code></pre> 
 <p style="text-align:justify;">controller 接收参数代码：</p> 
 <pre class="has"><code class="language-go">/**
  * 过滤方法测试
  */
 @RequestMapping("/filterCsF2")
 public void filterCs22(String email,String userName){
  System.out.println("处理后的参数："+userName+"  "+email);
 }</code></pre> 
 <p style="text-align:justify;">请求示例代码：</p> 
 <pre class="has"><code class="language-go">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;
&lt;title&gt;请求demo&lt;/title&gt;
&lt;/head&gt;

&lt;body&gt;

 &lt;form id="userForm" action="#" method="post"&gt;
        username：&lt;input type="text" id ="userName" name="userName" value="21088888"/&gt;&lt;br/&gt;&lt;br&gt;
        email：&lt;input type="text" id ="email" name="email" value="zhaoHENG@163.com"/&gt;&lt;br/&gt;&lt;br/&gt;
   age：&lt;input type="text" id ="age" name="age" value="18"/&gt;&lt;br/&gt;&lt;br/&gt;
      
        &lt;input type="reset" value="重置"/&gt;&amp;nbsp;&amp;nbsp;
        &lt;input type="button" id ="sub" value="提交"&gt;
    &lt;/form&gt;

&lt;/body&gt;
    &lt;script src="jquery.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript"&gt;
 
   $("#sub").click(
 function(){
  var userName = $("#userName").val(); 
    var email = $("#email").val(); 
      var age = $("#age").val(); 
   $.ajax({
   type : "POST",
   url:'http://127.0.0.1:8080/merchant_wap/pastOrder/filterCsF2',
   dataType : "json",
   data : {
     "userName":userName,
     "age":age,
     "email":email
   },
   success : function(data) {
   alert("33");
   },
   error : function(data) {
   alert("cccc"+data.email);
   }
  });
  }
   );
&lt;/script&gt;
&lt;/html&gt;</code></pre> 
 <p style="text-align:justify;">处理结果：</p> 
 <pre class="has"><code class="language-go">处理后的参数：21088888  zhaoheng@163.com</code></pre> 
 <p style="text-align:justify;">从结果可以看出，我们成功的通过过滤器对请求的email进行大写转小写处理</p> 
 <h5>2.json格式的报文请求；</h5> 
 <p style="text-align:justify;"><strong>第一步：新建一个类</strong></p> 
 <p style="text-align:justify;">这个类继承自HttpServletRequestWrapper</p> 
 <pre class="has"><code class="language-go">package com.zhh.util.request;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;

import javax.servlet.ServletInputStream;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletRequestWrapper;

import jodd.io.StreamUtil;

/**
 * 重写 HttpServletRequestWrapper
 * 处理json报文请求
 * @author zhaoheng
 *
 */
public class MyHttpServletRequestWrapper extends HttpServletRequestWrapper{  
 
  private  byte[] body; //用于保存读取body中数据   

     public MyHttpServletRequestWrapper(HttpServletRequest request) throws IOException {    
         super(request);
         //读取请求的数据保存到本类当中
         body = StreamUtil.readBytes(request.getReader(), "UTF-8");    
     }
     //覆盖（重写）父类的方法
     @Override    
     public BufferedReader getReader() throws IOException {    
         return new BufferedReader(new InputStreamReader(getInputStream()));    
     }    
     //覆盖（重写）父类的方法
     @Override    
     public ServletInputStream getInputStream() throws IOException {    
         final ByteArrayInputStream bais = new ByteArrayInputStream(body);    
         return new ServletInputStream() {    
             @Override    
             public int read() throws IOException {    
                 return bais.read();    
             } 
         };    
     }
    
     /**
      * 获取body中的数据
      * @return
      */
 public byte[] getBody() {
  return body;
 }
 /**
  * 把处理后的参数放到body里面
  * @param body
  */
 public void setBody(byte[] body) {
  this.body = body;
 }
}</code></pre> 
 <p style="text-align:justify;">通过建立这个类我们就能完成向request对象添加我们处理之后的参数了。</p> 
 <p style="text-align:justify;"><strong>第二步：通过实现filter接口建一个过滤器</strong></p> 
 <pre class="has"><code class="language-go">package com.zhh.filter;

import java.io.BufferedReader;
import java.io.IOException;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

import javax.servlet.Filter;
import javax.servlet.FilterChain;
import javax.servlet.FilterConfig;
import javax.servlet.ServletException;
import javax.servlet.ServletRequest;
import javax.servlet.ServletResponse;
import javax.servlet.http.HttpServletRequest;

import org.apache.log4j.Logger;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.JSONObject;
import com.zhh.util.request.MyHttpServletRequestWrapper;

/**
 * 参数校验过滤器（针对json报文请求） 1.获取请求参数；2.对获取到的请求参数进行处理（解密、字符串替、请求参数分类截取等等）；3.把处理后的参数放回到请求列表里面
 * 
 * @author zhaoheng
 *
 */
public class ValidatorFilter implements Filter {

 private static final Logger log = Logger.getLogger(ValidatorFilter.class);

 /**
  * 需要过滤的地址
  */
 private static List&lt;String&gt; urlList = Arrays.asList("/pastOrder/filterCs");
 /**
  * 是否需要过滤
  * 
  * @param requestUrl
  *            请求的url
  * @return
  */
 public boolean isPast(String requestUrl) {
  for (String url : urlList) {
   if (requestUrl.equals(url)) {
    return true;
   }
  }
  return false;
 }

 @Override
 public void destroy() {
  log.info("过滤器执行结束");
 }

 @SuppressWarnings("unchecked")
 @Override
 public void doFilter(ServletRequest request, ServletResponse response,
   FilterChain chain) throws IOException, ServletException {
  log.info("过滤器1执行开始");
  String url0 = ((HttpServletRequest) request).getRequestURI();
  String url1 = ((HttpServletRequest) request).getContextPath();
  System.out.println("完整地址："+url0);
  System.out.println("返回当前页面所在的应用的名字："+url1);
  System.out.println("返回当前页面所在的应用的名字长度："+url1.length());
  
  // 获取请求地址
  String url = ((HttpServletRequest) request).getRequestURI().substring(((HttpServletRequest)request).getContextPath().length());
  System.out.println("截取后的地址："+url);
  
  if (isPast(url)) {
   //处理json报文请求
   MyHttpServletRequestWrapper requestWrapper = new MyHttpServletRequestWrapper(
     (HttpServletRequest) request);
   // 读取请求内容
   BufferedReader br;
   br = requestWrapper.getReader();
   String line = null;
   StringBuilder sb = new StringBuilder();
   while ((line = br.readLine()) != null) {
    sb.append(line);
   }
   // 将json字符串转换为json对象
   JSONObject jsonObject = JSONObject.parseObject(sb.toString());

   Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
   // 把json对象转换为Map集合
   map = JSON.toJavaObject(jsonObject, Map.class);
   for (Entry&lt;String, Object&gt; entry : map.entrySet()) {
    // 把邮箱地址转换为小写
    if (entry.getKey().equals("email")) {
     map.put(entry.getKey(), entry.getValue().toString()
       .toLowerCase());
    }
   }
   
   // 把参数转换之后放到我们的body里面
   String json = JSON.toJSONString(map);
   requestWrapper.setBody(json.getBytes("UTF-8"));
   // 放行 
   chain.doFilter(requestWrapper, response);
  } else {
   chain.doFilter(request, response);
  }
 }

 @Override
 public void init(FilterConfig arg0) throws ServletException {

 }

}</code></pre> 
 <p style="text-align:justify;"><strong>第三步：</strong></p> 
 <p style="text-align:justify;">方法一、在web.xml文件里面进行简单的配置</p> 
 <p style="text-align:justify;">把我们的过滤器在该文件中注册</p> 
 <pre class="has"><code class="language-go">&lt;!--  配置过滤器  --&gt;
   &lt;filter&gt;  
     &lt;filter-name&gt;ValidatorFilter&lt;/filter-name&gt; 
      &lt;!--  我们写的过滤的地址   --&gt; 
     &lt;filter-class&gt;com.zhh.filter.ValidatorFilter&lt;/filter-class&gt;  
 &lt;/filter&gt;  
 &lt;filter-mapping&gt;  
     &lt;filter-name&gt;ValidatorFilter&lt;/filter-name&gt;  
     &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  
 &lt;/filter-mapping&gt;</code></pre> 
 <p style="text-align:justify;">方法二、springboot项目的配置</p> 
 <p style="text-align:justify;">新建一个配置类，加上@Configuration注解，在方法头加上@Bean注解</p> 
 <pre class="has"><code class="language-go">@Configuration
public class WebFileterConfig {
 /**
     * 配置过滤器
     * order属性:控制过滤器加载顺序：数字越小，加载越早
     * @return
     */
    @Bean
    public FilterRegistrationBean ValidatorFilterRegistration() {
        //新建过滤器注册类
        FilterRegistrationBean registration = new FilterRegistrationBean();
        // 添加我们写好的过滤器
        registration.setFilter( new ValidatorFilter());
        // 设置过滤器的URL模式
        registration.addUrlPatterns("/*");
        registration.setOrder(Integer.MAX_VALUE-10);
        return registration;
    }
}</code></pre> 
 <p style="text-align:justify;">controller 接收参数代码：</p> 
 <pre class="has"><code class="language-go">/**
  * 过滤方法测试
  * @RequestBody User user 该注解用于接收json请求的参数
  * @return
  */
 @ResponseBody
 @RequestMapping(value = "/filterCs")
 public User filterCs(@RequestBody User user){
  System.out.println(user.toString());
  return user;
 }</code></pre> 
 <p style="text-align:justify;">请求报文示例：</p> 
 <p style="text-align:justify;">我这里使用的是postman工具进行json参数请求</p> 
 <pre class="has"><code class="language-go">{
 "email": "zhaoHENG@163.com",
 "userName":"20181100",
 "age":"18"
}</code></pre> 
 <p style="text-align:justify;">返回结果：</p> 
 <pre class="has"><code class="language-go">{
 "email": "zhaoheng@163.com",
 "userName":"20181100",
 "age":"18"
}</code></pre> 
 <p style="text-align:justify;">通过该过滤器，把email转换从小写成功。</p> 
 <p style="text-align:justify;">通过以上操作，我们就成功的创建了一个过滤器。</p> 
 <pre class="has"><code class="language-go">往期干货：
 26个经典微信小程序+35套微信小程序源码+微信小程序合集源码下载（免费） 干货~~~2021最新前端学习视频~~速度领取
 前端书籍-前端290本高清pdf电子书打包下载
点赞和在看就是最大的支持❤️</code></pre> 
</div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f9623188ef2e66ffd94db4ca3656ad83/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">架构套路总结</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9a8a306a40d60f12c35acfffc516c80d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【VUE3源码学习】nextTick 实现原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>