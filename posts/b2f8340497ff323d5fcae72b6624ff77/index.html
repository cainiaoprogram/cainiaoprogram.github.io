<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>8种排序算法(Java实现) - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="8种排序算法(Java实现)" />
<meta property="og:description" content="目录
1.简介:
2.性能:
二.具体实现
1.冒泡排序
2.简单选择排序
3.直接插入排序
4.希尔排序(对直接插入的改进)
5.快速排序
6.归并排序
7.基数排序(桶排序的扩展)
8.堆排序
一.排序算法的简单介绍
1.简介: 2.性能: 3.总结和对比
二.具体实现 1.冒泡排序 每次遍历排序都找出一个最大值放在后面 就像冒泡一样 应用了交换的思想
[3, 9, -1, 10, 20]
第1次遍历排序:
[3, -1, 9, 10, 20]
第2次遍历排序:
[-1, 3, 9, 10, 20]
第3次遍历排序:
[-1, 3, 9, 10, 20]
第4次遍历排序:
[-1, 3, 9, 10, 20]
最终排序结果:
[-1, 3, 9, 10, 20]
*所以5个数组进行4次遍历排序就可
*根据上面的遍历我们还发现第三次遍历数组已经有序，无需进行第四次遍历，所以我们可以对这点进行优化 。 也就是如果经历一次遍历排序一次交换也没发生，那么我们就认为这个数组已经有序，直接retuen.
1.1代码实现:
/** * 冒泡排序 * @param arr 进行排序的数组 * @return 排好序的数组 */ public static int[] bubbleSort(int[] arr) { int temp = 0; int count = 0; for (int i = arr." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b2f8340497ff323d5fcae72b6624ff77/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-02-08T23:48:37+08:00" />
<meta property="article:modified_time" content="2022-02-08T23:48:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">8种排序算法(Java实现)</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="1.%E7%AE%80%E4%BB%8B%3A-toc" style="margin-left:80px;"><a href="#1.%E7%AE%80%E4%BB%8B%3A" rel="nofollow">1.简介:</a></p> 
<p id="2.%E6%80%A7%E8%83%BD%3A-toc" style="margin-left:80px;"><a href="#2.%E6%80%A7%E8%83%BD%3A" rel="nofollow">2.性能:</a></p> 
<p id="%E4%BA%8C.%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0-toc" style="margin-left:40px;"><a href="#%E4%BA%8C.%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0" rel="nofollow">二.具体实现</a></p> 
<p id="1.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#1.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" rel="nofollow">1.冒泡排序</a></p> 
<p id="2.%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#2.%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" rel="nofollow">2.简单选择排序</a></p> 
<p id="3.%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#3.%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" rel="nofollow">3.直接插入排序</a></p> 
<p id="4.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F(%E5%AF%B9%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E7%9A%84%E6%94%B9%E8%BF%9B)-toc" style="margin-left:80px;"><a href="#4.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%28%E5%AF%B9%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E7%9A%84%E6%94%B9%E8%BF%9B%29" rel="nofollow">4.希尔排序(对直接插入的改进)</a></p> 
<p id="5.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(%E5%AF%B9%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%94%B9%E8%BF%9B)-toc" style="margin-left:80px;"><a href="#5.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%28%E5%AF%B9%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%94%B9%E8%BF%9B%29" rel="nofollow">5.快速排序</a></p> 
<p id="6.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#6.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" rel="nofollow">6.归并排序</a></p> 
<p id="7.%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#7.%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F" rel="nofollow">7.基数排序(桶排序的扩展)</a></p> 
<p id="8.%E5%A0%86%E6%8E%92%E5%BA%8F-toc" style="margin-left:80px;"><a href="#8.%E5%A0%86%E6%8E%92%E5%BA%8F" rel="nofollow">8.堆排序</a></p> 
<hr id="hr-toc"> 
<p><strong>一.排序算法的简单介绍</strong></p> 
<h4 id="1.%E7%AE%80%E4%BB%8B%3A"><strong>1.简介:</strong></h4> 
<p><img alt="" height="429" src="https://images2.imgbox.com/82/3b/gGBagugB_o.png" width="792"></p> 
<p></p> 
<h4 id="2.%E6%80%A7%E8%83%BD%3A"><strong>2.性能:</strong></h4> 
<p><img alt="" height="412" src="https://images2.imgbox.com/8d/7e/3HlhGLp2_o.png" width="622"></p> 
<p><strong>3.总结和对比</strong></p> 
<p><img alt="" height="585" src="https://images2.imgbox.com/15/c6/Jd2q7hHh_o.png" width="1151"></p> 
<p></p> 
<h3 id="%E4%BA%8C.%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0">二.具体实现</h3> 
<h4 id="1.%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">1.冒泡排序</h4> 
<hr> 
<p>每次遍历排序都找出一个最大值放在后面 就像冒泡一样 应用了交换的思想</p> 
<p>[3, 9, -1, 10, 20]<br> 第1次遍历排序:<br> [3, -1, 9, 10, <strong><span style="color:#fe2c24;">20</span></strong>]<br> 第2次遍历排序:<br> [-1, 3, 9, <span style="color:#fe2c24;"><strong>10</strong></span>,<strong><span style="color:#fe2c24;"> 20</span></strong>]<br> 第3次遍历排序:<br> [-1, 3, <strong><span style="color:#fe2c24;">9</span></strong>, <strong><span style="color:#fe2c24;">10</span></strong>, <span style="color:#fe2c24;"><strong>20</strong></span>]<br> 第4次遍历排序:<br> [-1, <strong><span style="color:#fe2c24;">3</span></strong>, <span style="color:#fe2c24;"><strong>9</strong></span>, <strong><span style="color:#fe2c24;">10</span></strong>, <strong><span style="color:#fe2c24;">20</span></strong>]<br> 最终排序结果:<br> [-1, 3, 9, 10, 20]</p> 
<p><strong>*所以5个数组进行4次遍历排序就可</strong></p> 
<p><strong>*根据上面的遍历我们还发现第三次遍历数组已经有序，无需进行第四次遍历，所以我们可以对这点进行优化 。  也就是如果经历一次遍历排序一次交换也没发生，那么我们就认为这个数组已经有序，直接retuen.</strong></p> 
<p><strong>1.1代码实现:</strong></p> 
<pre><code class="language-java">    /**
     * 冒泡排序
     * @param arr 进行排序的数组
     * @return 排好序的数组
     */
    public static int[] bubbleSort(int[] arr) {
        int temp = 0;
        int count = 0;

        for (int i =  arr.length-1; i &gt; 0; i--) {
            count = 0;
            //每次循环都遍历出了一个最大的放在数组的后面
            for (int j = 0; j &lt; i ; j++) {
                //如果比后一个元素大则进行交换
                if(arr[j] &gt; arr[j+1]) {
                    temp = arr[j];
                    arr[j] = arr[j+1];
                    arr[j+1] = temp;
                   //记录进行交换的次数
                    count++;
                }
            }

//            System.out.println("第" + (arr.length-i)  +"次排序:");
//            System.out.println(Arrays.toString(arr));
            //说明已经有序了 无须在排
            if (count == 0) {
                return arr;
            }
            
        }
        return arr;
    }</code></pre> 
<p><strong>1.2测试排序十万个随机数所需要的时间:</strong></p> 
<pre><code class="language-java">        //创建随机数组
        int[] testArr = new int[100000];

        for (int i = 0; i &lt; testArr.length; i++) {
            //生成[0,8000]间的随机数
            testArr[i] = (int) (Math.random()*8000000);
        }

        //开始时间
        Date dataBegin = new Date();

        //冒泡排序
        sort.bubbleSort(testArr);

        //结束时间
        Date dataEnd = new Date();
        System.out.println(dataEnd.getTime()-dataBegin.getTime());</code></pre> 
<p><strong>结果:14523ms</strong></p> 
<p><img alt="" height="166" src="https://images2.imgbox.com/7c/9f/0B7tHtps_o.png" width="469"></p> 
<p></p> 
<h4 id="2.%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">2.简单选择排序</h4> 
<hr> 
<p>每次遍历排序都选择一个最小值 然后与最前面的数进行交换  与冒泡排序不同 只交换一次</p> 
<p>[3, 9, <span style="color:#38d8f0;">-1</span>, 10, 20]<br> 第1次遍历排序:<br> [<span style="color:#fe2c24;"><strong>-1</strong></span>, 9, <span style="color:#38d8f0;">3</span>, 10, 20]<br> 第2次遍历排序:<br> [<strong><span style="color:#fe2c24;">-1</span></strong>, <span style="color:#fe2c24;"><strong>3</strong></span>, <span style="color:#38d8f0;">9</span>, 10, 20]<br> 第3次遍历排序:<br> [<span style="color:#fe2c24;"><strong>-1</strong></span>, <span style="color:#fe2c24;"><strong>3</strong></span>, <strong><span style="color:#fe2c24;">9</span></strong>, <span style="color:#38d8f0;">10</span>, 20]<br> 第4次遍历排序:<br> [<span style="color:#fe2c24;"><strong>-1</strong></span>, <span style="color:#fe2c24;"><strong>3</strong></span>,<span style="color:#fe2c24;"><strong> 9</strong></span>, <span style="color:#fe2c24;"><strong>10</strong></span>, 20]<br> 最终排序结果:<br> [-1, 3, 9, 10, 20]</p> 
<p><span style="color:#38d8f0;">蓝色</span><span style="color:#0d0016;">代表每次遍历要找到的最小值</span></p> 
<p><strong>2.1代码实现</strong></p> 
<pre><code class="language-java">    /**
     * 选择排序
     * @param arr 进行排序的数组
     * @return 排好序的数组
     */
    public static int[] selectSort(int[] arr) {
        int temp = 0;
        //最小值的下标
        int min = 0;
        for (int i = 0; i &lt; arr.length - 1; i++) {
            //先假设最小的数是arr[i]
            min = i;
            //遍历找到最小的那个
            for (int j = i + 1; j &lt; arr.length; j++) {
                //如果发现arr[j] 比 arr[min]小 则令min = j
                if(arr[j] &lt; arr[min]) {
                    min = j;
                }
            }
            //将的到的最小值与arr[i]进行交换
            if (min != i) {
                temp = arr[min];
                arr[min] = arr[i];
                arr[i] = temp;
            }
//            System.out.println("第" + (i+1)  +"次排序:");
//            System.out.println(Arrays.toString(arr));
        }
        return arr;
    }</code></pre> 
<p><strong>2.2测试排序十万个随机数所需要的时间:</strong></p> 
<pre><code class="language-java">        //创建随机数组
        int[] testArr = new int[100000];
        for (int i = 0; i &lt; testArr.length; i++) {
            //生成[0,8000]间的随机数
            testArr[i] = (int) (Math.random()*8000000);
        }

        //开始时间
        Date dataBegin = new Date();

        //选择排序
        sort.selectSort(testArr);

        //结束时间
        Date dataEnd = new Date();
        System.out.println(dataEnd.getTime()-dataBegin.getTime());</code></pre> 
<p><strong>结果：4024ms</strong></p> 
<p><img alt="" height="162" src="https://images2.imgbox.com/06/ae/6jQxQU5V_o.png" width="398"></p> 
<h4 id="3.%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">3.直接插入排序</h4> 
<hr> 
<p>先将要排序数组中第一个数当作以已排序好的数组，然后依次遍历剩下的数 按顺序插入已排序好的数组。全部遍历一遍后则得到一个排序好的数组。</p> 
<p>[<span style="color:#fe2c24;"><strong>3</strong></span>, <span style="color:#38d8f0;">9</span>, -1, 10, 20]<br> 第1次遍历排序:<br> [<span style="color:#fe2c24;"><strong>3</strong></span>, <strong><span style="color:#fe2c24;">9</span></strong>, <span style="color:#38d8f0;">-1</span>, 10, 20]<br> 第2次遍历排序:<br> [<span style="color:#fe2c24;"><strong>-1</strong></span>, <span style="color:#fe2c24;"><strong>3</strong></span>, <span style="color:#fe2c24;"><strong>9</strong></span>, <span style="color:#38d8f0;">10</span>, 20]<br> 第3次遍历排序:<br> [<strong><span style="color:#fe2c24;">-1</span></strong>, <strong><span style="color:#fe2c24;">3</span></strong>, <span style="color:#fe2c24;"><strong>9</strong></span>, <strong><span style="color:#fe2c24;">10</span></strong>, <span style="color:#38d8f0;">20</span>]<br> 第4次遍历排序:<br> [<span style="color:#fe2c24;"><strong>-1</strong></span>, <span style="color:#fe2c24;"><strong>3</strong></span>, <span style="color:#fe2c24;"><strong>9</strong></span>, <span style="color:#fe2c24;"><strong>10</strong></span>, <strong><span style="color:#fe2c24;">20</span></strong>]<br> 最终排序结果:<br> [-1, 3, 9, 10, 20]</p> 
<p><span style="color:#38d8f0;">蓝色</span>对应代码中的insertValue</p> 
<p><span style="color:#fe2c24;">红色</span>代表已排好序的数组</p> 
<p><strong>3.1代码实现：</strong></p> 
<pre><code class="language-java">    /**
     * 插入排序
     * @param arr 进行排序的数组
     * @return 排好序的数组
     */
    public static int[] insertSort(int[] arr) {
        //要插入的值
        int insertValue;
        //插入的下标
        int insertIndex;
        for (int i = 1; i &lt; arr.length; i++) {
            insertValue = arr[i];
            //先从已经排好序的数组中最后一个数开始比较
            insertIndex = i - 1;
            //如果下标小于0了说明已经跟 已排好序的数组全部做过了比较
            //如果要插入的那个值 小于 已排好序的数组中最后一个 九将这个数后移以为 然后在往前遍历 依此比较
            //知道找到一个比要插入值小的 则该点就是要插入的点
            //如果一次while循环也没进入 则说明要插入的这个值比 已排好序的数组中所有的都要大
            while (insertIndex &gt;= 0 &amp;&amp; insertValue &lt; arr[insertIndex]) {
                arr[insertIndex + 1] = arr[insertIndex];
                insertIndex--;
            }
            //将值插入
            arr[insertIndex + 1] = insertValue;

            System.out.println("第" + i +"次遍历排序:");
            System.out.println(Arrays.toString(arr));
        }

        return arr;
    }</code></pre> 
<p><strong>3.2测试排序十万个随机数所需要的时间:912ms   </strong></p> 
<p></p> 
<p><img alt="" height="175" src="https://images2.imgbox.com/be/ab/iCEKkMJc_o.png" width="468"></p> 
<h4 id="4.%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F(%E5%AF%B9%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E7%9A%84%E6%94%B9%E8%BF%9B)">4.希尔排序(对直接插入的改进)</h4> 
<hr> 
<p><strong>希尔排序</strong>是一种高效的排序算法，它基于插入排序算法。如果较小的值在最右边并且必须移到最左边，在这样的情况下入过用直接插入排序代价很大，采用希尔排序就能很好的解决这个问题。希尔排序也称<strong>缩小排量排序</strong>。</p> 
<p>arr = [8, 9, 1, 7, 2, 3, 5, 4, 6, 0]</p> 
<p>group = arr.lenght()/2</p> 
<p>1）先将数组分成数group 个组 然后把每组中数据进行排序；</p> 
<p>2）然后再令group = group/2 ,再对每组中数据进行排列；</p> 
<p>3）重复上面步骤，知道最后分成 group = 1时，再对每组中数据进行排列，这时数组就是有序数组了。</p> 
<p>[8, 9, 1, 7, 2, 3, 5, 4, 6, 0]<br> 第1次遍历排序:分成5组进行排序<br> [<strong><span style="color:#fe2c24;">3</span></strong>,<strong><span style="color:#38d8f0;"> 5</span></strong>, <strong><span style="color:#511b78;">1</span></strong>, <strong><span style="color:#1c7331;">6</span></strong>, <strong>0</strong>, <strong><span style="color:#fe2c24;">8</span></strong>, <strong><span style="color:#38d8f0;">9</span></strong>, <strong><span style="color:#511b78;">4</span></strong>, <strong><span style="color:#1c7331;">7</span></strong>, <strong>2</strong>]<br> 第2次遍历排序:分成2组进行排序<br> [<strong><span style="color:#fe2c24;">0</span></strong>, <span style="color:#38d8f0;"><strong>2</strong></span>, <strong><span style="color:#fe2c24;">1</span></strong>, <span style="color:#38d8f0;"><strong>4</strong></span>, <strong><span style="color:#fe2c24;">3</span></strong>, <span style="color:#38d8f0;"><strong>5</strong></span>, <strong><span style="color:#fe2c24;">7</span></strong>, <span style="color:#38d8f0;"><strong>6</strong></span>, <strong><span style="color:#fe2c24;">9</span></strong>, <span style="color:#38d8f0;"><strong>8</strong></span>]<br> 第3次遍历排序:分成1组进行排序<br> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br> 最终排序结果:<br> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</p> 
<p><strong>4.1.1代码实现(交换法)</strong></p> 
<pre><code class="language-java">    /**
     * 希尔排序
     * @param arr 进行排序的数组
     * @return 排好序的数组
     */
    public static int[] shellSort(int[] arr) {
      
        int temp = 0;
        //分成几个一组
        int group = arr.length / 2;
        while (group != 0) {
            for (int i = group; i &lt; arr.length; i++) {
                //遍历每组中的元素，步长为group
                for (int j = i - group; j &gt;= 0; j -= group) {
                    //采用交换法
                    if (arr[j] &gt; arr[j + group]) {
                        temp = arr[j];
                        arr[j] = arr[j + group];
                        arr[j + group] = temp;
                    }
                }
            }
//            System.out.println("第" + (++count)  +"次遍历排序:分成" + group +"组");
//            System.out.println(Arrays.toString(arr));
            //进行下一次分组
            group = group / 2;

        }
        return arr;
    }</code></pre> 
<p><strong>4.1.2测试排序十万个随机数所需要的时间: 7039ms</strong></p> 
<p><img alt="" height="168" src="https://images2.imgbox.com/2c/fd/kQQZQxbc_o.png" width="413"></p> 
<p><strong>4.2.1代码实现(移位法)</strong></p> 
<pre><code class="language-java">    /**
     * 希尔排序 (移位法) 效率高
     * @param arr 进行排序的数组
     * @return 排好序的数组
     */
    public static int[] shellSort(int[] arr) {
        int temp = 0;
        //分成几个一组
        int group = arr.length / 2;
        while (group != 0) {
            for (int i = group; i &lt; arr.length; i++) {
                //j代表待插入值的下标
                int j = i;
                temp = arr[j];
                if (arr[j] &lt; arr[j - group]) {
                    //与直接插入的思想相似 找到比它小的 就让他后移group位
                    while (j - group &gt;= 0 &amp;&amp; temp &lt; arr[j - group]) {
                        arr[j] = arr[j - group];
                        j -= group;
                    }
                    //退出while时 代表找到temp位置
                    arr[j] = temp;
                }

            }
            //进行下一次分组
            group = group / 2;

        }
        return arr;
    }</code></pre> 
<p><strong>4.2.2测试排序十万个随机数所需要的时间:</strong> <strong>21ms </strong></p> 
<p><img alt="" height="152" src="https://images2.imgbox.com/a3/4f/GNShEd2Z_o.png" width="427"></p> 
<p><strong>*所以移位法的性能远高于交换法</strong></p> 
<h4 id="5.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F(%E5%AF%B9%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E7%9A%84%E6%94%B9%E8%BF%9B)">5.快速排序</h4> 
<hr> 
<p><strong>快速排序</strong>(Quicksort）是对冒泡排序的一种改进。基本思想是:通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数掘都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p> 
<p>缺点:不稳定</p> 
<p>举例:</p> 
<p>1 4 7 5 3 6 4 0</p> 
<p>取中间值 (0+7)/2=3 所以也就是5</p> 
<p><span style="color:#0d0016;">左边索引从0开始遍历 右边索引从7开始遍历</span></p> 
<p>1 4 7 5 3 6 4 0</p> 
<p>先遍历左边找到比5大的</p> 
<p>1 4<span style="color:#fe2c24;"> 7</span> 5 3 6 4 0</p> 
<p>然后再遍历右边找到个比5小的</p> 
<p>1 4<span style="color:#fe2c24;"> 7</span> 5 3 6 4 <span style="color:#4da8ee;">0 </span><span style="color:#0d0016;">==》1 4 0 5 3 6 4 0</span></p> 
<p><span style="color:#0d0016;">重复上述步骤</span></p> 
<p><span style="color:#0d0016;">1 4 0 </span><span style="color:#fe2c24;">5</span><span style="color:#0d0016;"> 3 6 </span><span style="color:#38d8f0;">4</span><span style="color:#0d0016;"> 7 ==》1 4 0 4 3 6 5 7</span></p> 
<p><span style="color:#0d0016;">1 4 0 4 3 </span><span style="color:#fe2c24;">6</span><span style="color:#0d0016;"> </span><span style="color:#38d8f0;">5</span><span style="color:#0d0016;"> 7 ==》1 4 0 4 3 5 6 7</span></p> 
<p>这就完成了第一次分割 <span style="color:#fe2c24;">1 4 0 4 3 </span><span style="color:#0d0016;">      5      </span><span style="color:#38d8f0;">6 7</span></p> 
<p><span style="color:#0d0016;">然后继续左边1 4 0 4 3的分割     右边 <strong>6 7分割</strong></span></p> 
<p><strong>5.1代码实现</strong></p> 
<pre><code class="language-java">public class QuickSort {
    public static void quickSort(int[] arr) {
        quickSort(arr, 0, arr.length - 1);
    }
    public static void quickSort(int[] arr, int star, int end) {
        if (star &gt;= end) {
            return ;
        }
        int l = star;
        int r = end;
        int piovt = arr[(l + r)/2];
        while (l &lt;= r) {
            while (l &lt;= r &amp;&amp; arr[l] &lt; piovt) {
                l++;
            }
            while (l &lt;= r &amp;&amp; arr[r] &gt; piovt) {
                r--;
            }
            //交换
            if (l &lt;= r) {
                int temp = arr[l];
                arr[l] = arr[r];
                arr[r] = temp;
                l++;
                r--;
            }
        }
        quickSort(arr,star,r);
        quickSort(arr,l,end);

    }
}</code></pre> 
<p><strong>5</strong>.<strong>2测试排序十万个随机数所需要的时间: 16ms</strong></p> 
<p><img alt="" height="132" src="https://images2.imgbox.com/28/63/L6BHkU1j_o.png" width="400"></p> 
<h4 id="6.%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">6.归并排序</h4> 
<hr> 
<p>归并排序是利用归并的思想实现的排序方法，该算法采用经典的分治策略（分治法将问题分成一些小的问题然后递归求解，而治的阶段则将分的阶段得到的各答案"修补"在一起，即分而治之)。</p> 
<p>缺点:需要额外的空间</p> 
<p><img alt="" height="419" src="https://images2.imgbox.com/34/6f/vvxoNDUz_o.png" width="547"> <img alt="" height="536" src="https://images2.imgbox.com/1e/d1/8fvoBfBU_o.png" width="1200"></p> 
<p><strong> 6.1.1代码实现</strong></p> 
<pre><code class="language-java">public class MergeSort {
    public static void mergeSort(int[] arr) {
        int[] temp = new int[arr.length];
        mergeSort(arr,0, arr.length-1, temp);
    }


    public static void mergeSort(int[] arr, int star, int end, int[] temp) {
        if (star &gt;= end) {
            return;
        }
        int mid = star + (end - star) / 2;
        //分
        mergeSort(arr, star, mid, temp);
        mergeSort(arr, mid + 1, end, temp);
        
        //治
        merge(arr,star,mid,end,temp);
    }

    private static void merge(int[] arr, int star, int mid, int end, int[] temp) {
        int left = star;
        int right = mid + 1;
        int index = star;
        while (left &lt;= mid &amp;&amp; right &lt;= end) {
            if (arr[left] &lt; arr[right]) {
                temp[index++] = arr[left++];
            } else {
                temp[index++] = arr[right++];
            }
        }
        while (left &lt;= mid) {
            temp[index++] = arr[left++];
        }
        while (right &lt;= end) {
            temp[index++] = arr[right++];
        }
        for (int i = 0; i &lt;= end; i++) {
            arr[i] = temp[i];
        }
    }
}</code></pre> 
<p><strong>6.1.2测试排序十万个随机数所需要的时间:</strong>  <strong>2244ms</strong></p> 
<p><img alt="" height="179" src="https://images2.imgbox.com/f7/a3/lVZsC4Tm_o.png" width="479"></p> 
<p><strong><span style="color:#fe2c24;">经过测试我发先 把临时数组当成参数时 可以大大提高该方法的效率 </span></strong></p> 
<p><span style="color:#fe2c24;"><strong>原因可能是每次归并都需要创建一个新数组 所以花费了很多时间</strong></span></p> 
<p><strong><span style="color:#0d0016;">6.2.1代码改进</span></strong></p> 
<pre><code class="language-java">/**
     * 归并排序
     * @param arr 待排序数组
     * @param leftIndex 最左侧下标
     * @param rightIndex 最右侧下标
     * @param tempArr 临时数组
     * @return
     */
    public static int[] mergeSort(int[] arr,int leftIndex, int rightIndex, int[] tempArr) {
        //先分 通过递归将数组分成单个 再归并
        if (leftIndex &lt; rightIndex) {
            //中间索引 也就是左侧最后一个数的索引
            int midIndex = (leftIndex + rightIndex)/2;
            //向左递归
            mergeSort(arr, leftIndex, midIndex, tempArr);
            //向右递归
            mergeSort(arr, midIndex + 1, rightIndex, tempArr);
            //全部分好了之后 进行合并
            merge(arr,leftIndex,rightIndex,tempArr);
        }
        return arr;
    }

    /**
     * 将已经分好的 进行归并
     * @param arr 待归并数组
     * @param leftIndex 左边第一个数的索引
     * @param rightIndex 右侧最后一个数的索引
     * @param tempArr 临时数组
     */
    public static void merge(int[] arr, int leftIndex, int rightIndex, int[] tempArr) {
        //中间索引 也就是左侧最后一个数的索引
        int midIndex = (leftIndex + rightIndex)/2;
        //左边第一个数的索引
        int l = leftIndex;
        //右侧第一个数的索引
        int r = midIndex + 1;

        int tempIndex = 0;
        //当有一侧都遍历完成时退出while
        while (l &lt;= midIndex &amp;&amp; r &lt;= rightIndex) {
            if (arr[l] &lt;= arr[r]) {
                tempArr[tempIndex] = arr[l];
                tempIndex++;
                l++;
            } else {
                tempArr[tempIndex] = arr[r];
                tempIndex++;
                r++;
            }

        }
        //说明左面没遍历完 仍须遍历
        while (l &lt;= midIndex) {
            tempArr[tempIndex] = arr[l];
            tempIndex++;
            l++;
        }
        //说明右面没遍历完 仍须遍历
        while (r &lt;= rightIndex) {
            tempArr[tempIndex] = arr[r];
            tempIndex++;
            r++;
        }
        //都遍历完成后 把tempArr赋给arr
        //注意 这时并不是copy所有数据 它可能只时归并中的一个小步骤
        tempIndex = 0;
        l = leftIndex;
//        System.out.println("左索引"+l+"右索引" +rightIndex);
//        System.out.println("要归并的数组" + Arrays.toString(tempArr));
        while (l &lt;= rightIndex) {
            arr[l] = tempArr[tempIndex];
            l++;
            tempIndex++;
        }

    }</code></pre> 
<p><strong>6.2.2测试排序十万个随机数所需要的时间:</strong>  <strong>13ms</strong></p> 
<p><img alt="" height="174" src="https://images2.imgbox.com/5a/d9/So7JHCLi_o.png" width="476"></p> 
<p></p> 
<h4 id="7.%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">7.基数排序(桶排序的扩展)</h4> 
<hr> 
<p><strong>基数排序基本思想</strong>：将所有待比较数值统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。</p> 
<p><strong>先创建10个和待排序数组一样大的桶，把待排序数组一次遍历，按照个位数字放在对应的 0 1 2 3 4 5 6 7 8 9的10个桶里，放完后在从0~9号桶按顺序在放回数组，然后再按照十位数.....只到遍历完数组最大值的位数(比如待排序数组最大值只有三位 这是我们只需要遍历到百位就好)。数列就变成一个有序序列。</strong></p> 
<p>要注意的是基数排序非常消耗内存 因为他会创建10个跟待排序数组一样大的桶；</p> 
<p><strong>7.1代码实现</strong></p> 
<pre><code class="language-java">    /**
     * 基数排序
     * @param arr 待排序数组
     * @return 排好序的数组
     */
    public static int[] radixSort(int[] arr) {
        int max = arr[0];
        //遍历出数组的最大值
        for (int t = 0; t &lt; arr.length; t++) {
            if (max &lt; arr[t]) {
                max = arr[t];
            }
        }
        //最大位数
        int digit = (max+"").length();
        //创建一个二维数组 模拟10个桶 分别装 0 1 2 3 4 5 6 7 8 9
        int[][] bucket = new int[10][arr.length];
        //用来记录桶中存放了几个数据  比如bucketElementCounts[2] = 3; 就代表存放2的那个桶中有3个数据
        int[] bucketElementCounts = new int[10];
        int temp;
        //个 十 百 位....只到遍历到最高位
        for (int w = 0; w &lt; digit; w++) {
            //放进对应的桶中
            for (int i = 0; i &lt; arr.length; i++) {
                //获取对应的位的值 比如第一次就是取个位的值 然后再取十位的值 以此类推
                temp = (int) (arr[i] / ( Math.pow(10,w)) % 10);
                //放进对应的桶中
                bucket[temp][bucketElementCounts[temp]] = arr[i];
                //记录桶中存放元素的个数++
                bucketElementCounts[temp]++;
            }
            //当做遍历arr的索引
            int index = 0;
            //从桶中依次放进arr中 j代表哪个桶
            for (int j = 0; j &lt; 10; j++) {
                //如果桶中有数据在遍历
                if(bucketElementCounts[j] != 0) {
                    for (int k = 0; k &lt; bucketElementCounts[j]; k++) {
                        //取出元素放在arr中
                        arr[index] = bucket[j][k];
                        index++;
                    }
                }
                //遍历完一个桶后 要把记录桶中数据的个数清零 要不然会影响下一次的存放
                bucketElementCounts[j] = 0;
            }
        }
        return arr;
    }</code></pre> 
<p><strong>7</strong>.<strong>2测试排序<span style="color:#fe2c24;">一百万</span>个随机数所需</strong><strong>要的时间:</strong>  526ms</p> 
<p><img alt="" height="185" src="https://images2.imgbox.com/eb/2a/RqLjXGOv_o.png" width="522"></p> 
<p><strong> 所以它在处理大量数据时效率非常高</strong></p> 
<p><strong>本代码没有考虑负数问题 后面补充</strong></p> 
<h4 id="8.%E5%A0%86%E6%8E%92%E5%BA%8F"><strong>8.堆排序</strong></h4> 
<hr> 
<p>一般升序采用<strong>大顶堆</strong>，降序采用<strong>小顶堆</strong></p> 
<p><strong>大顶堆:</strong>父节点比子节点都要大</p> 
<p><strong>小顶堆:</strong>父节点比子节点都要小</p> 
<p><strong>8.1<span style="color:#000000;">堆排序基本思想 </span></strong></p> 
<p><span style="color:#000000;">1) 将待排序序列构造成一个大顶堆 </span></p> 
<p><span style="color:#000000;">2) 此时，整个序列的最大值就是堆顶的根节点.</span></p> 
<p><span style="color:#000000;">3) 将其与末尾元素进行交换，此时末尾就为最大值。 </span></p> 
<p><span style="color:#000000;">4) 然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 </span><span style="color:#000000;">n </span><span style="color:#000000;">个元素的次小值。如此反复执行，能得到一个有序序列了。 </span></p> 
<p><strong>8.2过程分析</strong></p> 
<div> 
 <span style="color:#fe2c24;"><strong>步骤一</strong> </span> 
 <span style="color:#000000;"><strong>构造初始堆。将给定无序序列构造成一个大顶堆（一般升序采用大顶堆，降序采用小顶堆)。 </strong></span> 
</div> 
<p>假定待排序数组arr = { 4, 6, 8, 5, 9} 要求<span style="color:#000000;">将数组升序排序。</span></p> 
<div> 
 <span style="color:#000000;">1) .先把它看成个堆(二叉树)</span> 
</div> 
<div> 
 <p style="text-align:center;"><img alt="" height="250" src="https://images2.imgbox.com/8b/2a/NKb1pIt5_o.png" width="398"></p> 
</div> 
<p><span style="color:#000000;">2) .此时我们从最后一个非叶子结点开始（叶结点自然不用调整，第一个非叶子结点</span></p> 
<p><span style="color:#000000;">arr.length/2-1=5/2-1=1，也就是下面的 6 结点），从左至右，从下至上进行调整。</span></p> 
<p> <img alt="" height="393" src="https://images2.imgbox.com/ee/3c/Ekoh4IZz_o.png" width="1052"></p> 
<div> 
 <span style="color:#000000;">3) .找到第二个非叶节点 4，由于[4,9,8]中 9 元素最大，4 和 9 交换。</span> 
</div> 
<div></div> 
<div> 
 <img alt="" height="394" src="https://images2.imgbox.com/11/b3/uglIJeI8_o.png" width="1047"> 
</div> 
<p> <span style="color:#000000;">4) 这时，交换导致了子根[4,5,6]结构混乱，继续调整，[4,5,6]中 6 最大，交换 4 和 6。</span></p> 
<div> 
 <img alt="" height="417" src="https://images2.imgbox.com/e2/8a/U3L43bFj_o.png" width="1076"> 
</div> 
<p> <span style="color:#000000;">此时，我们就将一个无序序列构造成了一个大顶堆。</span></p> 
<div> 
 <span style="color:#fe2c24;"><strong>步骤二</strong></span> 
 <span style="color:#000000;"><strong> 将堆顶元素与末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换。</strong></span> 
</div> 
<div></div> 
<div> 
 <div> 
  <span style="color:#000000;">1) 将堆顶元素 9 和末尾元素 4 进行交换 </span> 
 </div> 
</div> 
<div></div> 
<div> 
 <img alt="" height="383" src="https://images2.imgbox.com/8e/cc/iASuycsf_o.png" width="1105"> 
</div> 
<p></p> 
<div> 
 <span style="color:#000000;">2) .重新调整结构，使其继续满足堆定义</span> 
</div> 
<div> 
 <img alt="" height="393" src="https://images2.imgbox.com/aa/0b/ba6D50El_o.png" width="1099"> 
</div> 
<div> 
 <span style="color:#000000;">3) .再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素 8.</span>  
 <img alt="" height="414" src="https://images2.imgbox.com/a4/8b/t5GaIDuZ_o.png" width="1171"> 
</div> 
<p> <span style="color:#000000;">4) 后续过程，继续进行调整，交换，如此反复进行，最终使得整个序列有序</span></p> 
<div> 
 <p style="text-align:center;"><img alt="" height="250" src="https://images2.imgbox.com/9b/a1/tmoT8KW4_o.png" width="373"></p> 
</div> 
<div> 
 <span style="color:#fe2c24;"><strong>总结:</strong></span> 
</div> 
<div> 
 <strong>1).将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;</strong> 
</div> 
<div> 
 <span style="color:#000000;"><strong>2).将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端; </strong></span> 
</div> 
<div> 
 <div> 
  <span style="color:#000000;"><strong>3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤,</strong></span> 
  <span style="color:#000000;"><strong>直到整个序列有序。</strong></span> 
 </div> 
</div> 
<div> 
 <strong>8.4代码实现</strong> 
</div> 
<div> 
 <pre><code class="language-java">/**
     * 堆排序
     * @param arr 待排序数组
     * @return 有序数组
     */
    public static int[] heapSort(int[] arr) {
        int temp = 0;
        //把无序数组 变成大顶堆
        for (int i = arr.length/2 -1; i &gt;= 0; i--) {
            max2Root(arr, i, arr.length);
        }
//        System.out.println(Arrays.toString(arr));
        //将堆顶元素与末尾元素交换,将最大元素"沉"到数组末端;
        //重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。
        for (int j = arr.length - 1; j &gt; 0; j--) {
            //交换
            temp = arr[j];
            arr[j] = arr[0];
            arr[0] = temp;
            //把剩下数组继续变成大顶堆
            max2Root(arr, 0, j);
        }
        return arr;
    }

    /**
     * 将数组变成大顶堆
     * @param arr 待排序数组
     * @param i 父节点下标
     * @param lenght 数组长度
     */
    public static void max2Root(int[] arr, int i, int lenght) {
        int temp = arr[i];
        //将最大值与父节点交换
        for (int k = i * 2 + 1; k &lt; lenght; k = k * 2 + 1) {
            //如果左子节点大于右子节点 则k指向右子节点
            if (k + 1 &lt; lenght &amp;&amp; arr[k] &lt; arr[k + 1]) {
                k = k + 1;
            }
            //如果父节点 小于 最大的子节点
            if (temp &lt; arr[k]) {
                arr[i] = arr[k];
                //让i指向k 继续循环
                i = k;
            } else {
                //父节点就是最大的了 直接退出
                break;
            }
        }
        //将 temp放到调整后的位置
        arr[i] = temp;
    }</code></pre> 
 <p><strong>8.5测试排序十万个随机数所需要的时间: 14ms</strong></p> 
 <p><img alt="" height="168" src="https://images2.imgbox.com/5c/19/cGYqUJdX_o.png" width="462"></p> 
 <p></p> 
</div> 
<div></div> 
<div></div> 
<div></div> 
<div></div> 
<div></div> 
<div></div> 
<div></div>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b8d2c1a7c8e463b64b4098f0b08f2114/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">单片机的分频是什么意思？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/310d62daeb04d632e74e59543b5bd47f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">TencentOS Server 简介</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>