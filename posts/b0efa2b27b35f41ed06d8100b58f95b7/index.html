<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;：单调栈和单调队列及其应用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;：单调栈和单调队列及其应用" />
<meta property="og:description" content="栈和队列是两个很重要的数据结构。其中单调栈和单调队列是栈和队列的“特别版”。下面就来介绍一下单调栈和单调队列以及它们可能的用处。
目录 一、单调栈1、栈2、单调栈①、寻找某一个数左边第一个小于它的数②、寻找某一个数右边第一个小于它的数的==下标==③、寻找某一个数右边第一个大于它的数④、寻找某一个数右边第一个大于它的数的下标 二、单调队列1、队列2、单调（双端）队列 一、单调栈 1、栈 栈是限制插入和删除操作只能在一个位置上进行的表，这个位置是表的末端，叫栈顶。对栈的基本操作有入栈（push）和出栈（pop）。通俗点说，就是一个有底的罐子，可以往里面放东西，放的时候只能放在最上面，拿的时候也只能拿最上面的东西。栈的实现很简单，这里我用数组来实现，并且由于这篇文章主要用来介绍单调栈和单调队列，所以只实现一些简单的操作。直接上代码：
const int N = 100010; //算法题不需要考虑大型程序中变量名字冲突的问题，因此定义全局变量 //tail的首字母是t，就起名叫tt吧 int stk[N], tt = 0; //插入操作：向栈顶插入一个数 void push(int x) { stk[ &#43;&#43; tt] = x; } //删除操作：弹出栈顶的数 void pop() { tt -- ; } //查询栈顶的值 int query() { return stk[tt]; } //判断栈是否为空，空的返回0，否则返回1 bool is_empty() { return tt; } 2、单调栈 所谓单调栈，就是字面意思，单调的栈（从栈底到栈顶）。单调栈分为两种：单调增加的栈和单调减少的栈。具体一点就是说，在每次增加元素的时候，在保证删除最少元素的情况下，保持栈的单调性。
我们举个例子，单调减少的栈：
void insert(int x) { //判断栈是否为空，并且把小于等于x的数都弹出 while (tt &amp;&amp; stk[tt] &lt;= x) tt -- ; stk[ &#43;&#43; tt] = x; } 那么单调栈有什么用呢，最典型的一种问题就是：在一串数中，找到某一个数左边（或右边）第一个比它小（大）的数的值或下标。其他问题用到的很少，基本不用考虑。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b0efa2b27b35f41ed06d8100b58f95b7/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-06T19:32:47+08:00" />
<meta property="article:modified_time" content="2023-06-06T19:32:47+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;：单调栈和单调队列及其应用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>栈和队列是两个很重要的数据结构。其中单调栈和单调队列是栈和队列的“特别版”。下面就来介绍一下单调栈和单调队列以及它们可能的用处。<br> </p> 
<div class="toc"> 
 <h4>目录</h4> 
 <ul><li><a href="#_2" rel="nofollow">一、单调栈</a></li><li><ul><li><a href="#1_3" rel="nofollow">1、栈</a></li><li><a href="#2_37" rel="nofollow">2、单调栈</a></li><li><ul><li><a href="#_52" rel="nofollow">①、寻找某一个数左边第一个小于它的数</a></li><li><a href="#_108" rel="nofollow">②、寻找某一个数右边第一个小于它的数的==下标==</a></li><li><a href="#_148" rel="nofollow">③、寻找某一个数右边第一个大于它的数</a></li><li><a href="#_188" rel="nofollow">④、寻找某一个数右边第一个大于它的数的下标</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_224" rel="nofollow">二、单调队列</a></li><li><ul><li><a href="#1_225" rel="nofollow">1、队列</a></li><li><a href="#2_257" rel="nofollow">2、单调（双端）队列</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>一、单调栈</h2> 
<h3><a id="1_3"></a>1、栈</h3> 
<p>栈是<mark>限制插入和删除操作</mark>只能在一个位置上进行的表，这个位置是表的末端，叫<mark>栈顶</mark>。对栈的基本操作有<mark>入栈（push）和出栈（pop）</mark>。通俗点说，就是一个<strong>有底的罐子</strong>，可以往里面放东西，放的时候只能放在最上面，拿的时候也只能拿最上面的东西。栈的实现很简单，这里我用数组来实现，并且由于这篇文章主要用来介绍单调栈和单调队列，所以只实现一些简单的操作。直接上代码：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span>

<span class="token comment">//算法题不需要考虑大型程序中变量名字冲突的问题，因此定义全局变量</span>
<span class="token comment">//tail的首字母是t，就起名叫tt吧</span>
<span class="token keyword">int</span> stk<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token comment">//插入操作：向栈顶插入一个数</span>
<span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    stk<span class="token punctuation">[</span> <span class="token operator">++</span> tt<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//删除操作：弹出栈顶的数</span>
<span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    tt <span class="token operator">--</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//查询栈顶的值</span>
<span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> stk<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//判断栈是否为空，空的返回0，否则返回1</span>
<span class="token keyword">bool</span> <span class="token function">is_empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> tt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="2_37"></a>2、单调栈</h3> 
<p>所谓单调栈，就是字面意思，<mark>单调的栈（从栈底到栈顶）</mark>。单调栈分为两种：<strong>单调增加的栈</strong>和<strong>单调减少的栈</strong>。具体一点就是说，在<mark>每次增加元素的时候，在保证删除最少元素的情况下，保持栈的单调性</mark>。</p> 
<p>我们举个例子，单调减少的栈：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//判断栈是否为空，并且把小于等于x的数都弹出</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>tt <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">[</span>tt<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> x<span class="token punctuation">)</span> tt <span class="token operator">--</span> <span class="token punctuation">;</span>
    stk<span class="token punctuation">[</span> <span class="token operator">++</span> tt<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>那么单调栈有什么用呢，最典型的一种问题就是：<strong>在一串数中，找到某一个数左边（或右边）第一个比它小（大）的数的<mark>值或下标</mark></strong>。其他问题用到的很少，基本不用考虑。<br> 那么我们就把每种情况都说一说：</p> 
<h4><a id="_52"></a>①、寻找某一个数左边第一个小于它的数</h4> 
<p>我们用例题来说明：<a href="https://www.acwing.com/problem/content/832/" rel="nofollow">acwing单调栈</a></p> 
<blockquote> 
 <p>给定一个长度为 N 的整数数列，输出每个数左边第一个比它小的数，如果不存在则输出 −1 。<br> <strong>输入格式</strong><br> 第一行包含整数 N，表示数列长度。<br> 第二行包含 N 个整数，表示整数数列。<br> <strong>输出格式</strong><br> 共一行，包含 N 个整数，其中第 i 个数表示第 i 个数的左边第一个比它小的数，如果不存在则输出 −1。<br> <strong>数据范围</strong><br> 1≤N≤105<br> 1≤数列中元素≤109<br> <strong>输入样例</strong>：</p> 
 <blockquote> 
  <p>5<br> 3 4 2 7 5</p> 
 </blockquote> 
 <p><strong>输出样例</strong>：</p> 
 <blockquote> 
  <p>-1 3 -1 2 2</p> 
 </blockquote> 
</blockquote> 
<p>这道题当然可以暴力来做，也就是遍历数组元素，然后二重循环回溯当前遍历到的元素之前的元素。但是不难发现这样的时间复杂度是 <em>O(n²)</em> 的，很容易就TLE了。但是我们可以利用单调栈来优化算法：<br> 我们先构造一个<strong>单调递增栈</strong>，保证所有栈内元素从栈底到栈顶是<mark>递增</mark>的（初始为空）。这时候我们再设置一个指针去遍历所有元素，每次<strong>比较当前元素和栈顶元素</strong>，如果<strong>当前元素小于栈顶元素</strong>，那就<strong>把栈顶元素弹出</strong>，直到找到一个比当前元素小的元素，那么这个元素就是当前元素所求的答案。当然也可能找不到，也就是<strong>把栈弹空了</strong>也没有一个比当前元素小的，那就直接宣布<strong>没找到</strong>。走完这一套流程之后呢，就把当前元素<mark>入栈</mark>，等待作为下一个元素的比较对象。<br> 那这时候就会一个问题：在处理当前元素的时候，是把<strong>比它大的</strong>都弹出去了，那万一<mark>被弹出去的元素是后面元素的答案</mark>怎么办？这是不可能的，因为想一下，弹出去的<strong>都是比当前元素大的元素</strong>，走完一套流程之后<strong>当前元素入栈</strong>，后面新来了一个等待比较的元素，从栈顶元素（也就是刚刚操作完的那个元素）开始比较。就算<strong>被弹出的某个元素</strong>比<strong>待比较元素</strong>小，那也轮不到它来当答案，因为<strong>栈顶元素一定比那个被弹出的小</strong>，所以栈顶元素才是答案（入栈顺序是数组遍历顺序，因此新入栈的一定比之前入栈的元素更靠近当前比较的元素）。一句话说就是：被弹出去的元素是因为永远不可能成为后面的答案才被弹出去的。<br> 这时候我们就可以把上面说的转化成代码了：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> stk<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//当前待比较元素</span>
        <span class="token keyword">int</span> x<span class="token punctuation">;</span>
        cin <span class="token operator">&gt;&gt;</span> x<span class="token punctuation">;</span>
        <span class="token comment">//所谓的“一套流程”</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>tt <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">[</span>tt<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> x<span class="token punctuation">)</span> tt <span class="token operator">--</span> <span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tt<span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">"-1 "</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> cout <span class="token operator">&lt;&lt;</span> stk<span class="token punctuation">[</span>tt<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>
        <span class="token comment">//当前元素入栈</span>
        stk<span class="token punctuation">[</span> <span class="token operator">++</span> tt<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>注意这里我没有把数据存到数组里，因为这道题没有必要。操作都是按照从左到右的顺序来的，所以按顺序操作就好。</p> 
<p><mark>时间复杂度</mark>：因为只遍历一次所有元素，每个元素至多只会经历一次入栈和一次出栈，因此时间复杂度为 <em>O(2n)</em> 。</p> 
<h4><a id="_108"></a>②、寻找某一个数右边第一个小于它的数的<mark>下标</mark></h4> 
<p>这个和上面的完全是一个思路，只需要通过一些小手段来保存下标就好：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> stk<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> n<span class="token punctuation">,</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>
    cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>
    <span class="token comment">//因为要用到下标，所以只能存到数组里咯</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> cin <span class="token operator">&gt;&gt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//小手段1：比较栈顶元素（下标）对应的元素</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>tt <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>stk<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> tt <span class="token operator">--</span> <span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tt<span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"-1 "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> stk<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//小手段2：用栈存下标</span>
        stk<span class="token punctuation">[</span> <span class="token operator">++</span> tt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>用一样的题目看看输出（输出的是下标）<img src="https://images2.imgbox.com/1b/db/aKsS8MR4_o.png" alt="在这里插入图片描述"></p> 
<p>此外还有<strong>寻找某一个数左边第一个大于它的数</strong>以及<strong>寻找某一个数左边第一个大于它的数的下标</strong>。思路完全一样，只需要把上面的单调递增栈变成单调递减栈就好。</p> 
<pre><code class="prism language-cpp"><span class="token comment">//也就是把while (tt &amp;&amp; stk[tt] &gt;= x) tt -- ;变成</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>tt <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">[</span>tt<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> x<span class="token punctuation">)</span> tt <span class="token operator">--</span> <span class="token punctuation">;</span>
</code></pre> 
<h4><a id="_148"></a>③、寻找某一个数右边第一个大于它的数</h4> 
<p>我们只需要逆向思维一下，反向遍历数组，其实问题就迎刃而解了。我们举个例子：</p> 
<blockquote> 
 <p>找到 3 4 2 7 5 右边第一个大于它的数</p> 
</blockquote> 
<p>我们把它颠倒过来，也就是</p> 
<blockquote> 
 <p>找到 5 7 2 4 3 左边第一个大于它的数</p> 
</blockquote> 
<p>上代码看看输出：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> stk<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> tt<span class="token punctuation">,</span> ans<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> cin <span class="token operator">&gt;&gt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token comment">//逆向遍历，并且由于答案是逆向存储的，要加一个答案数组</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">--</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>tt <span class="token operator">&amp;&amp;</span> stk<span class="token punctuation">[</span>tt<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> tt <span class="token operator">--</span> <span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tt<span class="token punctuation">)</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">;</span>
        stk<span class="token punctuation">[</span> <span class="token operator">++</span> tt<span class="token punctuation">]</span> <span class="token operator">=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/0b/84/nR6BeBNC_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="_188"></a>④、寻找某一个数右边第一个大于它的数的下标</h4> 
<p>这也就是先逆序，再用一些小手段来存储下标就好。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">3e5</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> stk<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> tt<span class="token punctuation">,</span> ans<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> cin <span class="token operator">&gt;&gt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">--</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//小手段1：比较栈顶元素（下标）对应的元素</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>tt <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>stk<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> tt <span class="token operator">--</span> <span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>tt<span class="token punctuation">)</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">else</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> stk<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token comment">//小手段2：存储下标</span>
        stk<span class="token punctuation">[</span> <span class="token operator">++</span> tt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> cout <span class="token operator">&lt;&lt;</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/aa/70/1R0AqZn5_o.png" alt="在这里插入图片描述"><br> 此外还有<strong>寻找某一个数右边第一个小于它的数</strong>以及<strong>寻找某一个数右边第一个小于它的数的下标</strong>。也和上面提到的一样，改变一个大于小于号就好。</p> 
<h2><a id="_224"></a>二、单调队列</h2> 
<h3><a id="1_225"></a>1、队列</h3> 
<p>队列也是一种表，和栈的区别就是它的插入和删除操作在不同端进行。插入的地方叫队尾，删除的地方叫队头。形象的比喻就是一个队伍，先排队的人在队头，队头的人先出队；后来的人在队尾，只能从队尾进队。还是用数组简单实现一下基本操作：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">100010</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> q<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> hh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token comment">//插入操作：向队尾插入一个数</span>
<span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    q<span class="token punctuation">[</span> <span class="token operator">++</span> tt<span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//删除操作：弹出队尾的数</span>
<span class="token keyword">void</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    hh <span class="token operator">++</span> <span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//查询队头的值</span>
<span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//判断队列是否为空，空的返回0，否则返回1</span>
<span class="token keyword">bool</span> <span class="token function">is_empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">return</span> hh <span class="token operator">&lt;=</span> tt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="2_257"></a>2、单调（双端）队列</h3> 
<p>单调队列和单调栈差不多，毕竟栈和队列也只是操作端口的差异。顾名思义就是队内元素单调递增或单调递减的队列。<br> 由于要<strong>维护其单调性</strong>，因此单调队列并不是严格意义上的队列，而是一种<mark>双端队列</mark>，具体来说就是两边都可以进出的队列。为什么呢，我们举个例子：</p> 
<blockquote> 
 <p>假设现在单调递增队列中有 2 4 6 ，现在 5 要进队，那么为了单调性考虑，只能让队尾的 6 出队， 变成 2 4 5 。</p> 
</blockquote> 
<p>我们举个例子，单调减少的队列：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">//判断队列是否为空以及维护单调性，为了维护单调性，不得不从队尾出队</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">&amp;&amp;</span> x <span class="token operator">&gt;=</span> q<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">)</span> tt <span class="token operator">--</span> <span class="token punctuation">;</span>
    q<span class="token punctuation">[</span> <span class="token operator">++</span> tt <span class="token punctuation">]</span> <span class="token operator">=</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>单调队列的应用要大于单调栈。最典型的应用是滑动窗口问题，并且单调队列还在优化bp方面有很大作用，但是鉴于本文只是介绍单调队列的基本应用，因此优化bp在此不作讲述。我们重点来解决滑动窗口问题。<br> 先看例题：<a href="https://www.acwing.com/problem/content/156/" rel="nofollow">acwing滑动窗口</a></p> 
<blockquote> 
 <p>给定一个大小为 n≤10^6 的数组。<br> 有一个大小为 k 的滑动窗口，它从数组的最左边移动到最右边。<br> 你只能在窗口中看到 k 个数字。<br> 每次滑动窗口向右移动一个位置。<br> 以下是一个例子：<br> 该数组为 [1 3 -1 -3 5 3 6 7]，k 为 3。</p> 
 <table><thead><tr><th align="center">窗口位置</th><th align="center">最小值</th><th align="center">最大值</th></tr></thead><tbody><tr><td align="center">[1 3 -1] -3 5 3 6 7</td><td align="center">-1</td><td align="center">3</td></tr><tr><td align="center">1 [3 -1 -3] 5 3 6 7</td><td align="center">-3</td><td align="center">3</td></tr><tr><td align="center">1 3 [-1 -3 5] 3 6 7</td><td align="center">-3</td><td align="center">5</td></tr><tr><td align="center">1 3 -1 [-3 5 3] 6 7</td><td align="center">-3</td><td align="center">5</td></tr><tr><td align="center">1 3 -1 -3 [5 3 6] 7</td><td align="center">3</td><td align="center">6</td></tr><tr><td align="center">1 3 -1 -3 5 [3 6 7]</td><td align="center">3</td><td align="center">7</td></tr></tbody></table> 
 <p>你的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p> 
 <p><strong>输入格式</strong><br> 输入包含两行。<br> 第一行包含两个整数 n 和 k，分别代表数组长度和滑动窗口的长度。<br> 第二行有 n 个整数，代表数组的具体数值。<br> 同行数据之间用空格隔开。</p> 
 <p><strong>输出格式</strong><br> 输出包含两个。<br> 第一行输出，从左至右，每个位置滑动窗口中的最小值。<br> 第二行输出，从左至右，每个位置滑动窗口中的最大值。</p> 
 <p><strong>输入样例</strong>：</p> 
 <blockquote> 
  <p>8 3<br> 1 3 -1 -3 5 3 6 7</p> 
 </blockquote> 
 <p><strong>输出样例</strong>：</p> 
 <blockquote> 
  <p>-1 -3 -3 -3 3 3<br> 3 3 5 5 6 7</p> 
 </blockquote> 
</blockquote> 
<p>首先想想暴力算法，无非就是从头开始遍历数组元素，然后对于每个元素，比较一下包括它本身在内的k个元素。很容易看出时间复杂度是 <em>O(nk)</em> ，很容易TLE。这时候我们就要用单调栈来优化一下了。<br> 先拿<strong>找窗口中的最小值</strong>为例，我们构造一个<mark>单调递增</mark>（从队头到队尾）的队列，这个<strong>队列中的元素</strong>就是<strong>当前窗口中的元素</strong>。<mark>首先要保证队首元素时刻都位于窗口中</mark>（不然就不符合窗口的大小了），然后想<strong>求滑动窗口中最小值</strong>的话，就是求<strong>当前队列中的队头元素</strong>。这时候用一个“指针”去遍历数组元素（相当于<strong>窗口右边框</strong>的位置），每次用当前元素去比较队尾元素，如果当前元素小于队尾元素，就弹出队尾元素，直到当前元素大于队尾元素或者队列为空（这一步<mark>维护了单调性</mark>），这时候让当前元素进队，并且输出队首元素（最小元素）。然后让指针移动到下一个元素，这时候<mark>首先要判断队首元素是否滑出了窗口</mark>，再进行比较的操作。<br> 需要注意的是，前 k - 1 个数不能构成一个窗口，所以输出操作至少要从第 k 个数开始。<br> 另外，为了方便（维护窗口大小），我们这里用队列存储相应元素的下标。<br> 我们把上面所说的转化成代码：</p> 
<pre><code class="prism language-cpp">    <span class="token keyword">int</span> hh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//判断队列是否为空以及判断队首是否滑出窗口</span>
        <span class="token comment">//如果队首元素在窗口之外，所以要删除队首元素</span>
        <span class="token comment">//同时由于窗口每次只前进一个元素，所以用if就可以</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">&amp;&amp;</span> i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;</span> q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">)</span> hh <span class="token operator">++</span> <span class="token punctuation">;</span>
        
        <span class="token comment">//为维护单调性，只能在队尾删除元素</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>q<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> tt <span class="token operator">--</span> <span class="token punctuation">;</span>
        q<span class="token punctuation">[</span> <span class="token operator">++</span> tt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        
        <span class="token comment">//判断是否为前 k - 1 个数</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>找最大值的方法和找最小值的一样，只需要构造一个<mark>单调递减</mark>的队列就好。所以实现起来，只要改变一个符号就好：</p> 
<pre><code class="prism language-cpp">    <span class="token keyword">int</span> hh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">&amp;&amp;</span> i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;</span> q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">)</span> hh <span class="token operator">++</span> <span class="token punctuation">;</span>
        
        <span class="token comment">//维护单调递减</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>q<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> tt <span class="token operator">--</span> <span class="token punctuation">;</span>
        q<span class="token punctuation">[</span> <span class="token operator">++</span> tt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
</code></pre> 
<p>由此综合一下，给出本题答案：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span> N <span class="token operator">=</span> <span class="token number">1000010</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> q<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> n<span class="token punctuation">,</span> k<span class="token punctuation">;</span>
    cin <span class="token operator">&gt;&gt;</span> n <span class="token operator">&gt;&gt;</span> k<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span> cin <span class="token operator">&gt;&gt;</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token keyword">int</span> hh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">&amp;&amp;</span> i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;</span> q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">)</span> hh <span class="token operator">++</span> <span class="token punctuation">;</span>
        
        <span class="token keyword">while</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>q<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&gt;=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> tt <span class="token operator">--</span> <span class="token punctuation">;</span>
        q<span class="token punctuation">[</span> <span class="token operator">++</span> tt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token function">puts</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    hh <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> tt <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i <span class="token operator">++</span> <span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">&amp;&amp;</span> i <span class="token operator">-</span> k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&gt;</span> q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">)</span> hh <span class="token operator">++</span> <span class="token punctuation">;</span>
        
        <span class="token keyword">while</span> <span class="token punctuation">(</span>hh <span class="token operator">&lt;=</span> tt <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>q<span class="token punctuation">[</span>tt<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> tt <span class="token operator">--</span> <span class="token punctuation">;</span>
        q<span class="token punctuation">[</span> <span class="token operator">++</span> tt<span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>
        
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;=</span> k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> a<span class="token punctuation">[</span>q<span class="token punctuation">[</span>hh<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/df4b4d585b3aa7579d4e18501928814a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java程序执行流程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4a364b4f60cdccecd5e290cb39b316a9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">C&#43;&#43;：【数据结构】trie树</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>