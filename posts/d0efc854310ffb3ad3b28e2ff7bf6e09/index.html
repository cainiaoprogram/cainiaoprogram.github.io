<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Nginx在局域网内实现真正的ip_hash负载均衡 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Nginx在局域网内实现真正的ip_hash负载均衡" />
<meta property="og:description" content="Nginx在局域网内实现真正的ip_hash负载均衡 遇到的问题 本人在以前公司的局域网内搭载Nginx负载均衡的时候发现使用ip_hash实现负载均衡会发生一个奇怪的显现，所有客户端的请求访问都打在了同一个服务器上！这使得负载均衡根本就没有起到任何作用，本人查阅了相关资料最终发现解决方法，多谢网上的各位大神，参考文献在最后说明。 为什么无法实现在同一局域网内ip_hash负载均衡说明 在同一个局域网中，大多数情况下我们在同一局域网内的所有机器IP前3位都是相同的，假设都为192.168.1.xxx。
根据官方的解析（参考网上大神的说法）
This directive causes requests to be distributed between upstreams based on the IP-address of the client.
The key for the hash is the class-C network address or the entire IPv6-address of the client. IPv6 is supported for ip_hash since 1.3.2 or 1.2.2. This method guarantees that the client request will always be transferred to the same server. But if this server is considered inoperative, then the request of this client will be transferred to another server." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d0efc854310ffb3ad3b28e2ff7bf6e09/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-18T12:11:44+08:00" />
<meta property="article:modified_time" content="2020-12-18T12:11:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Nginx在局域网内实现真正的ip_hash负载均衡</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="Nginxip_hash_0"></a><strong>Nginx在局域网内实现真正的ip_hash负载均衡</strong></h3> 
<ul><li><strong>遇到的问题</strong></li></ul> 
<ol><li>本人在以前公司的局域网内搭载Nginx负载均衡的时候发现使用<strong>ip_hash</strong>实现负载均衡会发生一个奇怪的显现，所有<strong>客户端的请求</strong>访问都打在了<strong>同一个服务器</strong>上！</li><li>这使得负载均衡根本就没有起到任何作用，本人查阅了相关资料最终发现解决方法，多谢网上的各位大神，参考文献在最后说明。</li></ol> 
<hr> 
<ul><li><em><strong>为什么无法实现在同一局域网内ip_hash负载均衡说明</strong></em></li></ul> 
<p>在同一个局域网中，大多数情况下我们在同一局域网内的所有机器IP<strong>前3位</strong>都是相同的，假设都为192.168.1.xxx。</p> 
<blockquote> 
 <p>根据官方的解析（参考网上大神的说法）<br> This directive causes requests to be distributed between upstreams based on the IP-address of the client.<br> The key for the hash is the class-C network address or the entire IPv6-address of the client. IPv6 is supported for ip_hash since 1.3.2 or 1.2.2. This method guarantees that the client request will always be transferred to the same server. But if this server is considered inoperative, then the request of this client will be transferred to another server. This gives a high probability clients will always connect to the same server. （简译：将客户端ip转化成C类网络地址，然后将该网络地址当作hash关键字，来保证这个客户端请求总是被转发到一台服务器上）</p> 
</blockquote> 
<p>由此可以知道ip_hash是用C类IP地址的前3位网络号码进行hash计算的。<br> (C类IP地址是指在IP地址的四段号码中，前三段号码为网络号码，剩下的一段号码为本地计算机的号码,解析来自百度百科)</p> 
<p><strong>到此问题就很明显了</strong>，由于我们在同一局域网内，ip地址的前3位都是一样的，不管你是那台客服端发送的请求，hash计算出来的值都是一样的，所以所有的请问访问都会打在同一个服务器上，导致没有实现真正的负载均衡！</p> 
<hr> 
<ul><li><em><strong>修改ip_hash代码算法中的取值，解决问题</strong></em></li></ul> 
<blockquote> 
 <p>1.在我们下载好的Nginx按转包中打开压缩包(以1.18.0版本为例子)</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/72/a8/48tK6DRQ_o.png" alt="Nginx"></p> 
<blockquote> 
 <p>2.找到nginx目录下的src/http/modules/ngx_http_upstream_ip_hash_module.c文件</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/91/d0/2UWg0KiP_o.png" alt="Nginx"></p> 
<blockquote> 
 <p>3.打开该文件，在180行左右会找到hash变量的赋值语句</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/08/25/BIYF0HZ9_o.png" alt="Nginx"></p> 
<blockquote> 
 <p>4.修改iphp-&gt;addrlen长度（一共有3处地方需要修改）</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/38/fb/s1xcAjtY_o.png" alt="Nginx"><br> <img src="https://images2.imgbox.com/34/ec/YSu41DJK_o.png" alt="Nginx"></p> 
<blockquote> 
 <p>5.保存修改<br> 在保存中xx.tar.gz文件不允许修改后直接保存，360压缩可以直接转为zip保存，这个没啥影响，如果不想转为zip，可先解压把ngx_http_upstream_ip_hash_module.c文件修改好后直接替换。</p> 
</blockquote> 
<blockquote> 
 <p>6.把重新编写过的Nginx安装在服务器上，这时候ip_hash在局域网内客户端发送请求就能实现真正的负载均衡，会发送到不同的服务器上。</p> 
</blockquote> 
<hr> 
<p>如有不足之处请多多指出。<br> 参考文章地址：https://blog.csdn.net/zhangjunli/article/details/81115323<br> 参考文章地址：https://blog.csdn.net/yswknight/article/details/107180893</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/93fafe0706d2928e67d0097deca3f1fe/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">[转载] Java8 Stream流遍历 如何使用索引</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/cfc72ae37ed0f8fc47b03712ac22ac70/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">unipp 使用uni.createCanvasContext画图</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>