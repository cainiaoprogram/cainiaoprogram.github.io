<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux内核驱动学习---编写最简单Linux内核模块HelloWorld - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux内核驱动学习---编写最简单Linux内核模块HelloWorld" />
<meta property="og:description" content="以下内容来源于 https://blog.csdn.net/lihaoweiV/article/details/6602261 https://blog.csdn.net/sh21_/article/details/60878812 https://blog.csdn.net/u010632165/article/details/86541941 https://blog.csdn.net/FallingU/article/details/76166194 推荐 https://blog.csdn.net/zhengnianli/article/details/120838057 什么是内核模块
模块是可以根据实际需要可以动态加载和卸载到内核中的代码。它们扩展了内核的功能，而无需重启系统，就可以进行模块加载，并工作。例如，一种类型的模块是设备驱动程序，它允许内核访问连接到系统的硬件。没有模块，我们必须构建整个内核并将新功能直接添加到内核映像中。除了拥有更大的内核之外，这还有一个缺点，就是每次我们想要新功能时都需要我们重新编译内核并烧录到设备。
Linux内核模块基本原理
Linux 内核模块（LKM）是一些在启动的操作系统内核需要时可以载入内核执行的代码块，不需要时由操作系统卸载。它们扩展了操作系统内核功能却不需要重新编译内核、启动系统。如果没有内核模块，就不得不反复编译生成操作系统的内核镜像来加入新功能，当附加的功能很多时，还会使内核变得臃肿。一个Linux 内核模块主要由以下几个部分组成：
(1) 模块加载函数(必须)：当通过insmod 或modprobe 命令加载内核模块时，模块的加载函数会自动被内核执行，完成本模块相关初始化工作。
(2) 模块卸载函数（必须）：当通过rmmod 命令卸载模块时，模块的卸载函数会自动被内核执行，完成与模块加载函数相反的功能。
(3) 模块许可证声明（必须）：模块许可证（LICENCE）声明描述内核模块的许可权限，如果不声明LICENCE,模块被加载时将收到内核被污染的警告。大多数情况下，内核模块应遵循GPL 兼容许可权。Linux2.6 内核模块最常见的是以MODULE_LICENSE(“Dual BSD/GPL”)语句声明模块采用BSD/GPL 双LICENSE。
(4) 模块参数（可选）：模块参数是模块被加载的时候可以被传递给他的值，它本身对应模块内部的全局变量。
(5) 模块导出符号（可选）：内核模块可以导出符号(symbol,对应于函数或变量)，这样其他模块可以使用本模块中的变量或函数。
(6) 模块作者等信息声明（可选）。
一个内核模块至少包含两个函数，模块被加载时执行的初始化函数init_module()和模块被卸载时执行的结束函数cleanup_module()。在最新内核稳定版本2.6 中，两个函数可以起任意的名字，通过宏module_init()和module_exit()注册调用要编译内核模块，把代码嵌进内核空间，首先要获取内核源代码，且版本必需与当前正在运行的版本一致。
hello.c
/*包含了对模块的结构定义以及模块的版本控制， * 任何模块程序的编写都要包含这个头文件*/ #include &lt;linux/module.h&gt; #include &lt;linux/kernel.h&gt; //包含了常用的内核函数 /*宏__init告诉编译程序相关的函数和变量仅用于初始化， * 编译程序将标有__init的所有代码存储到特殊的内存段中， * 初始化结束后就释放这段内存*/ #include &lt;linux/init.h&gt; //包含了宏__init和宏__exit static int __init hello_init(void)//lkp_init()是模块初始化函数 { /*printk()函数，该函数是由内核定义的，功能与C库中的 printf（）类似，它把要打印的信息输出到终端或者系统日志*/ printk(KERN_INFO &#34;module init success\n&#34;); return 0; } static void __exit hello_exit(void) //lkp_cleanup()是模块的退出和清理函数 { printk(KERN_INFO &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e6c5b8ee282399b7980eb47bf9c2081b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-20T16:49:09+08:00" />
<meta property="article:modified_time" content="2022-03-20T16:49:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux内核驱动学习---编写最简单Linux内核模块HelloWorld</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <pre><code class="prism language-javascript">以下内容来源于
https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>blog<span class="token punctuation">.</span>csdn<span class="token punctuation">.</span>net<span class="token operator">/</span>lihaoweiV<span class="token operator">/</span>article<span class="token operator">/</span>details<span class="token operator">/</span><span class="token number">6602261</span>
https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>blog<span class="token punctuation">.</span>csdn<span class="token punctuation">.</span>net<span class="token operator">/</span>sh21_<span class="token operator">/</span>article<span class="token operator">/</span>details<span class="token operator">/</span><span class="token number">60878812</span>
https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>blog<span class="token punctuation">.</span>csdn<span class="token punctuation">.</span>net<span class="token operator">/</span>u010632165<span class="token operator">/</span>article<span class="token operator">/</span>details<span class="token operator">/</span><span class="token number">86541941</span>
https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>blog<span class="token punctuation">.</span>csdn<span class="token punctuation">.</span>net<span class="token operator">/</span>FallingU<span class="token operator">/</span>article<span class="token operator">/</span>details<span class="token operator">/</span><span class="token number">76166194</span>
推荐
https<span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>blog<span class="token punctuation">.</span>csdn<span class="token punctuation">.</span>net<span class="token operator">/</span>zhengnianli<span class="token operator">/</span>article<span class="token operator">/</span>details<span class="token operator">/</span><span class="token number">120838057</span>
</code></pre> 
<p><strong>什么是内核模块</strong><br> 模块是可以根据实际需要可以动态加载和卸载到内核中的代码。它们扩展了内核的功能，而无需重启系统，就可以进行模块加载，并工作。例如，一种类型的模块是设备驱动程序，它允许内核访问连接到系统的硬件。没有模块，我们必须构建整个内核并将新功能直接添加到内核映像中。除了拥有更大的内核之外，这还有一个缺点，就是每次我们想要新功能时都需要我们重新编译内核并烧录到设备。<br> <strong>Linux内核模块基本原理</strong><br> Linux 内核模块（LKM）是一些在启动的操作系统内核需要时可以载入内核执行的代码块，不需要时由操作系统卸载。它们扩展了操作系统内核功能却不需要重新编译内核、启动系统。如果没有内核模块，就不得不反复编译生成操作系统的内核镜像来加入新功能，当附加的功能很多时，还会使内核变得臃肿。一个Linux 内核模块主要由以下几个部分组成：<br> <code>(1) 模块加载函数(必须)：当通过insmod 或modprobe 命令加载内核模块时，模块的加载函数会自动被内核执行，完成本模块相关初始化工作</code>。<br> <code>(2) 模块卸载函数（必须）：当通过rmmod 命令卸载模块时，模块的卸载函数会自动被内核执行，完成与模块加载函数相反的功能</code>。<br> <code>(3) 模块许可证声明（必须）：模块许可证（LICENCE）声明描述内核模块的许可权限，如果不声明LICENCE,模块被加载时将收到内核被污染的警告。大多数情况下，内核模块应遵循GPL 兼容许可权。Linux2.6 内核模块最常见的是以MODULE_LICENSE(“Dual BSD/GPL”)语句声明模块采用BSD/GPL 双LICENSE</code>。<br> (4) 模块参数（可选）：模块参数是模块被加载的时候可以被传递给他的值，它本身对应模块内部的全局变量。<br> (5) 模块导出符号（可选）：内核模块可以导出符号(symbol,对应于函数或变量)，这样其他模块可以使用本模块中的变量或函数。<br> (6) 模块作者等信息声明（可选）。<br> <code>一个内核模块至少包含两个函数，模块被加载时执行的初始化函数init_module()和模块被卸载时执行的结束函数cleanup_module()。在最新内核稳定版本2.6 中，两个函数可以起任意的名字，通过宏module_init()和module_exit()注册调用要编译内核模块，把代码嵌进内核空间，首先要获取内核源代码，且版本必需与当前正在运行的版本一致</code>。<br> hello.c</p> 
<pre><code class="prism language-javascript"><span class="token comment">/*包含了对模块的结构定义以及模块的版本控制，
* 任何模块程序的编写都要包含这个头文件*/</span>
#include <span class="token operator">&lt;</span>linux<span class="token operator">/</span>module<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>    
#include <span class="token operator">&lt;</span>linux<span class="token operator">/</span>kernel<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>    <span class="token comment">//包含了常用的内核函数</span>
<span class="token comment">/*宏__init告诉编译程序相关的函数和变量仅用于初始化，
* 编译程序将标有__init的所有代码存储到特殊的内存段中，
* 初始化结束后就释放这段内存*/</span>
#include <span class="token operator">&lt;</span>linux<span class="token operator">/</span>init<span class="token punctuation">.</span>h<span class="token operator">&gt;</span>      <span class="token comment">//包含了宏__init和宏__exit</span>

<span class="token keyword">static</span> int __init <span class="token function">hello_init</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token comment">//lkp_init()是模块初始化函数</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">/*printk()函数，该函数是由内核定义的，功能与C库中的
      printf（）类似，它把要打印的信息输出到终端或者系统日志*/</span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token constant">KERN_INFO</span> <span class="token string">"module init success\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> __exit <span class="token function">hello_exit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token comment">//lkp_cleanup()是模块的退出和清理函数</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token function">printk</span><span class="token punctuation">(</span><span class="token constant">KERN_INFO</span> <span class="token string">"module exit success\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//printk("Hello World! End of hello world module!\n");</span>
<span class="token punctuation">}</span>
<span class="token comment">/*是模块编程中最基本也是必需的两个函数*/</span>
<span class="token function">module_init</span><span class="token punctuation">(</span>hello_init<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//向内核注册模块提供新功能</span>
<span class="token function">module_exit</span><span class="token punctuation">(</span>hello_exit<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//注销由模块提供所有的功能</span>
<span class="token constant">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//告诉内核该模块具有GNU公共许可证</span>
<span class="token constant">MODULE_AUTHOR</span><span class="token punctuation">(</span><span class="token string">"作者"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token constant">MODULE_DESCRIPTION</span><span class="token punctuation">(</span><span class="token string">"功能描述"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这是一个简单内核模块程序，可以动态加载和卸载。虽然没有实际的功能。<br> <strong>模块加载</strong>的时候系统会打印<code>module init success\n</code><br> <strong>模块卸载</strong>的时候系统会打印<code>module exit success\n</code><br> <strong>模块编译</strong><br> Makefile文件</p> 
<pre><code class="prism language-javascript">obj<span class="token operator">-</span>m <span class="token punctuation">:</span><span class="token operator">=</span>hello<span class="token punctuation">.</span>o                  #产生hello模块的目标文件
all<span class="token punctuation">:</span>
	make <span class="token operator">-</span><span class="token constant">C</span> <span class="token operator">/</span>lib<span class="token operator">/</span>modules<span class="token operator">/</span><span class="token function">$</span><span class="token punctuation">(</span>shell uname <span class="token operator">-</span>r<span class="token punctuation">)</span><span class="token operator">/</span>build <span class="token constant">SUBDIRS</span><span class="token operator">=</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token constant">PWD</span><span class="token punctuation">)</span> modules    #编译模块
clean<span class="token punctuation">:</span>
	make <span class="token operator">-</span><span class="token constant">C</span> <span class="token operator">/</span>lib<span class="token operator">/</span>modules<span class="token operator">/</span><span class="token function">$</span><span class="token punctuation">(</span>shell uname <span class="token operator">-</span>r<span class="token punctuation">)</span><span class="token operator">/</span>build <span class="token constant">SUBDIRS</span><span class="token operator">=</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token constant">PWD</span><span class="token punctuation">)</span> clean      #清理
</code></pre> 
<p>或者</p> 
<pre><code class="prism language-clike">obj<span class="token operator">-</span>m<span class="token punctuation">:</span><span class="token operator">=</span>hello<span class="token punctuation">.</span>o
PWD<span class="token punctuation">:</span><span class="token operator">=</span> $<span class="token punctuation">(</span>shell pwd<span class="token punctuation">)</span>
KERNELDIR<span class="token punctuation">:</span><span class="token operator">=</span> <span class="token operator">/</span>lib<span class="token operator">/</span>modules<span class="token operator">/</span>$<span class="token punctuation">(</span>shell uname <span class="token operator">-</span>r<span class="token punctuation">)</span><span class="token operator">/</span>build
EXTRA_CFLAGS<span class="token operator">=</span> <span class="token operator">-</span>O0

all<span class="token punctuation">:</span>
	make <span class="token operator">-</span>C $<span class="token punctuation">(</span>KERNELDIR<span class="token punctuation">)</span>  M<span class="token operator">=</span>$<span class="token punctuation">(</span>PWD<span class="token punctuation">)</span> modules
clean<span class="token punctuation">:</span>
	make <span class="token operator">-</span>C $<span class="token punctuation">(</span>KERNELDIR<span class="token punctuation">)</span> M<span class="token operator">=</span>$<span class="token punctuation">(</span>PWD<span class="token punctuation">)</span> clean
</code></pre> 
<p>上面的Makefile中使用了<code>obj-m :=</code> 这个赋值语句，其含义说明要使用目标文件<code>hello.o</code>建立一个模块，<code>最后生成的模块名字是hello.ko</code></p> 
<p>将<code>hello.c</code>和<code>Makefile</code>放在同一路径下进行编译，编译成功，会在当前路径下生成<code>hello.ko</code>，这就是我们将要加载到内核的模块。</p> 
<pre><code class="prism language-javascript">make
</code></pre> 
<p>执行了make之后，当前目录下会生成加载内核模块所需要的文件<br> <img src="https://images2.imgbox.com/37/fc/hDb4jjkd_o.png" alt="在这里插入图片描述"><br> 因为是要插入内核，要在内核空间运行，所以普通用户是不能直接把内核模块插入到内核中的，必须要获得权限才能进行内核模块的插入操作</p> 
<pre><code class="prism language-javascript">su
</code></pre> 
<p><strong>测试结果</strong><br> <strong>模块加载</strong><br> 加载<code>hello.ko</code>模块到内核中</p> 
<pre><code class="prism language-javascript">insmod hello<span class="token punctuation">.</span>ko
</code></pre> 
<p><img src="https://images2.imgbox.com/99/99/KLJiu7aa_o.png" alt="在这里插入图片描述"><br> <strong>如果模块加载成功的话，可以查看模块</strong></p> 
<pre><code class="prism language-javascript">lsmod <span class="token operator">|</span> grep hello
</code></pre> 
<p>成功加载会显示以下结果</p> 
<pre><code class="prism language-javascript">hello                  <span class="token number">16384</span>  <span class="token number">0</span> 
</code></pre> 
<p>也可以直接用lsmod查看我们编写的模块是否插入成功</p> 
<p><strong>查看内核打印的消息</strong></p> 
<pre><code class="prism language-javascript">dmesg <span class="token operator">|</span> grep <span class="token string">"init success"</span>
</code></pre> 
<pre><code class="prism language-javascript"><span class="token punctuation">[</span> <span class="token number">4160.003247</span><span class="token punctuation">]</span> module init success
</code></pre> 
<p>也可以直接用dmesg查看查看内核打印的消息</p> 
<p><strong>模块卸载</strong></p> 
<pre><code class="prism language-javascript">rmmod hello<span class="token punctuation">.</span>ko
</code></pre> 
<p><code>成功卸载hello模块后</code>，可以查看内核是否正常打印出我们预设在程序的打印信息。</p> 
<pre><code class="prism language-javascript">dmesg <span class="token operator">|</span> grep <span class="token string">"exit success"</span>
</code></pre> 
<p>可以看到终端上显示<code>module exit success</code>，说明通过rmmod成功卸载hello.ko</p> 
<pre><code class="prism language-javascript"><span class="token punctuation">[</span> <span class="token number">7160.003247</span><span class="token punctuation">]</span> module exit success
</code></pre> 
<p>这时候，如果再通过<code>lsmod</code>去查看当前的内核模块，就会发现<code>hello.ko</code>已经消失不见了。</p> 
<p><strong>相关指令</strong></p> 
<table><thead><tr><th>name</th><th>function</th></tr></thead><tbody><tr><td>lsmod</td><td>查看已经加载到内核中的模块</td></tr><tr><td>insmod</td><td>加载模块到内核中</td></tr><tr><td>rmmod</td><td>从内核卸载模块</td></tr><tr><td>depmod</td><td>生成模块所需要的依赖</td></tr><tr><td>modprobe</td><td>很强大的指令(-h)</td></tr></tbody></table> 
<p><strong>编写模块时的声明(含MODULE_LICENSE等)</strong><br> 编写模块必须先声明下面两句：</p> 
<pre><code class="prism language-javascript">#include <span class="token operator">&lt;</span>linux<span class="token operator">/</span>module<span class="token punctuation">.</span>h<span class="token operator">&gt;</span><span class="token comment">//这个头文件包含了许多符号与函数的定义，这些符号与函数多与加载模块有关</span>

#include <span class="token operator">&lt;</span>linux<span class="token operator">/</span>init<span class="token punctuation">.</span>h<span class="token operator">&gt;</span><span class="token comment">//这个头文件包含了你的模块初始化与清除的函数</span>
</code></pre> 
<p>另外，如果你的模块需要用到参数传递，那么你可能就要声明moduleparam.h这个头文件了。<br> 再者，模块里常包含一些描述性声明，如：</p> 
<pre><code class="prism language-javascript"><span class="token constant">MODULE_LICENSE</span><span class="token punctuation">(</span><span class="token string">"GPL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">// "GPL" 是指明了 这是GNU General Public License的任意版本                                                          // “GPL v2” 是指明 这仅声明为GPL的第二版本                                                          // "GPL and addtional"                                                         // "Dual BSD/GPL"                                                           // "Dual MPL/GPL"                                                           // "Proprietary"  私有的                                                            // 除非你的模块显式地声明一个开源版本，否则内核会默认你这是一个私有的模块(Proprietary)。</span>
<span class="token constant">MODULE_AUTHOR</span>              <span class="token comment">// 声明作者</span>
<span class="token constant">MODULE_DESCRIPTION</span>   <span class="token comment">//对这个模块作一个简单的描述，这个描述是"human-readable"的</span>
<span class="token constant">MODULE_VERSION</span>            <span class="token comment">// 这个模块的版本</span>
<span class="token constant">MODULE_ALIAS</span>              <span class="token comment">// 这个模块的别名</span>
<span class="token constant">MODULE_DEVICE_TABLE</span> <span class="token comment">// 告诉用户空间这个模块支持什么样的设备</span>
</code></pre> 
<p>MODULE_声明可以写在模块的任何地方（但必须在函数外面），但是惯例是写在模块最后。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a937d6f884f8c300726043b0fbf7abb5/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">yaml 文件（字符串）的解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/18ee800a1c45fe2a8245dc11d9a6ca13/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Spring AOP 源码解析</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>