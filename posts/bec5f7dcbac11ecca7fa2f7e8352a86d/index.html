<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据预处理Part7——特征选择 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据预处理Part7——特征选择" />
<meta property="og:description" content="文章目录 特征选择：1. 什么是特征选择？2. 为什么要进行特征选择？3. 怎样进行特征选择3.1 Filter过滤法3.1.1 方差过滤a. VarianceThresholdb. 方差过滤对模型的影响: 3.1.2 相关性过滤3.1.2.1 卡方过滤a 卡方过滤b. 选取超参数K 3.1.2.2 F检验3.1.2.3 互信息法 3.1.3 总结 3.2 Embedded嵌入法3.3 Wrapper包装法 4. 总结 特征选择： 1. 什么是特征选择？ 特征选择就是从所有的特征中，选择出有意义，对模型有帮助的特征，以避免必须将所有特征都导入模型去训练的情况。
特征选择完全独立于任何机器学习算法。他是根据各种统计检验中的分数以及相关性的各项指标来选择特征。
2. 为什么要进行特征选择？ 在实际工作中，用于模型中的特征维度往往很高，维度过高会增大模型计算复杂度，而且在这么多维数据中，并不是每个特征对模型的预测都是有效果的，所以需要利用一些方法去除一些不必要特征，从而降低模型的计算复杂度。
3. 怎样进行特征选择 常见的特征选择方法：
过滤法嵌入法包装法降维算法 3.1 Filter过滤法 3.1.1 方差过滤 a. VarianceThreshold Variance：方差。Threshold：阈。这是通过特征本身的方差来筛选特征的类，比如一个特征本身的方差很小，就表示样本在这个特征上基本没有差异，可能特征中的大多数值都一样，甚至整个特征的取值都相同，那这个特征对于样本区分没有什么作用。所以无论接下来的特征工程要做什么，都要优先消除方差为0的特征。
VarianceThreshold中有重要参数threshold，也就是方差的阈值，表示舍弃所有方差小于threshold的特征，不填默认为0，即删除所有的记录都相同的特征。
引包：
import pandas as pd import numpy as np from sklearn.feature_selection import VarianceThreshold 数据加载：
data = pd.read_csv(&#34;digit recognizor.csv&#34;) data.head() data.shape (42000, 785)
缺失值处理：
data.fillna(0,inplace = True) 切分特征和标签：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/bec5f7dcbac11ecca7fa2f7e8352a86d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-03T16:20:42+08:00" />
<meta property="article:modified_time" content="2020-06-03T16:20:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据预处理Part7——特征选择</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-dracula">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">特征选择：</a></li><li><ul><li><a href="#1__2" rel="nofollow">1. 什么是特征选择？</a></li><li><a href="#2__8" rel="nofollow">2. 为什么要进行特征选择？</a></li><li><a href="#3__10" rel="nofollow">3. 怎样进行特征选择</a></li><li><ul><li><a href="#31_Filter_17" rel="nofollow">3.1 Filter过滤法</a></li><li><ul><li><a href="#311__19" rel="nofollow">3.1.1 方差过滤</a></li><li><ul><li><a href="#a_VarianceThreshold_20" rel="nofollow">a. VarianceThreshold</a></li><li><a href="#b__69" rel="nofollow">b. 方差过滤对模型的影响:</a></li></ul> 
     </li><li><a href="#312__131" rel="nofollow">3.1.2 相关性过滤</a></li><li><ul><li><a href="#3121__134" rel="nofollow">3.1.2.1 卡方过滤</a></li><li><ul><li><a href="#a__135" rel="nofollow">a 卡方过滤</a></li><li><a href="#b_K_165" rel="nofollow">b. 选取超参数K</a></li></ul> 
      </li><li><a href="#3122_F_207" rel="nofollow">3.1.2.2 F检验</a></li><li><a href="#3123__236" rel="nofollow">3.1.2.3 互信息法</a></li></ul> 
     </li><li><a href="#313__263" rel="nofollow">3.1.3 总结</a></li></ul> 
    </li><li><a href="#32_Embedded_276" rel="nofollow">3.2 Embedded嵌入法</a></li><li><a href="#33_Wrapper_282" rel="nofollow">3.3 Wrapper包装法</a></li></ul> 
   </li><li><a href="#4__313" rel="nofollow">4. 总结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>特征选择：</h2> 
<h3><a id="1__2"></a>1. 什么是特征选择？</h3> 
<p>  <strong>特征选择就是从所有的特征中，选择出有意义，对模型有帮助的特征，以避免必须将所有特征都导入模型去训练的情况</strong>。</p> 
<p>  特征选择完全独立于任何机器学习算法。他是根据各种统计检验中的分数以及相关性的各项指标来选择特征。</p> 
<h3><a id="2__8"></a>2. 为什么要进行特征选择？</h3> 
<p>  在实际工作中，用于模型中的特征维度往往很高，维度过高会增大模型计算复杂度，而且在这么多维数据中，并不是每个特征对模型的预测都是有效果的，所以需要利用一些方法去除一些不必要特征，从而降低模型的计算复杂度。</p> 
<h3><a id="3__10"></a>3. 怎样进行特征选择</h3> 
<p>常见的特征选择方法：</p> 
<ul><li><strong>过滤法</strong></li><li><strong>嵌入法</strong></li><li><strong>包装法</strong></li><li><strong>降维算法</strong></li></ul> 
<h4><a id="31_Filter_17"></a>3.1 Filter过滤法</h4> 
<h5><a id="311__19"></a>3.1.1 方差过滤</h5> 
<h6><a id="a_VarianceThreshold_20"></a>a. VarianceThreshold</h6> 
<p>  Variance：方差。Threshold：阈。这是通过特征本身的方差来筛选特征的类，比如<strong>一个特征本身的方差很小，就表示样本在这个特征上基本没有差异</strong>，可能特征中的大多数值都一样，甚至整个特征的取值都相同，那这个特征对于样本区分没有什么作用。所以<strong>无论接下来的特征工程要做什么，都要优先消除方差为0的特征</strong>。</p> 
<p>  VarianceThreshold中有重要参数threshold，也就是方差的阈值，表示舍弃所有方差小于threshold的特征，不填默认为0，即删除所有的记录都相同的特征。</p> 
<p><strong>引包：</strong></p> 
<pre><code class="prism language-python"><span class="token keyword">import</span> pandas <span class="token keyword">as</span> pd
<span class="token keyword">import</span> numpy <span class="token keyword">as</span> np
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>feature_selection <span class="token keyword">import</span> VarianceThreshold
</code></pre> 
<p><strong>数据加载：</strong></p> 
<pre><code class="prism language-python">data <span class="token operator">=</span> pd<span class="token punctuation">.</span>read_csv<span class="token punctuation">(</span><span class="token string">"digit recognizor.csv"</span><span class="token punctuation">)</span>
data<span class="token punctuation">.</span>head<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/ec/50/F4CVt4N5_o.png" alt="在这里插入图片描述"></p> 
<pre><code class="prism language-python">data<span class="token punctuation">.</span>shape
</code></pre> 
<p>(42000, 785)</p> 
<p><strong>缺失值处理：</strong></p> 
<pre><code class="prism language-python">data<span class="token punctuation">.</span>fillna<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>inplace <span class="token operator">=</span> <span class="token boolean">True</span><span class="token punctuation">)</span>
</code></pre> 
<p><strong>切分特征和标签：</strong></p> 
<pre><code class="prism language-python">x<span class="token punctuation">,</span>y <span class="token operator">=</span> data<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span>data<span class="token punctuation">.</span>iloc<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>
</code></pre> 
<p><strong>以0为阈值进行方差过滤：</strong></p> 
<pre><code class="prism language-python">model_var <span class="token operator">=</span> VarianceThreshold<span class="token punctuation">(</span><span class="token punctuation">)</span>
x_var0 <span class="token operator">=</span> model_var<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
x_var0<span class="token punctuation">.</span>shape
</code></pre> 
<p>(42000, 708)</p> 
<p><strong>以方差中位数为阈值进行方差过滤：</strong></p> 
<pre><code class="prism language-python">medium_var <span class="token operator">=</span> np<span class="token punctuation">.</span>median<span class="token punctuation">(</span>x<span class="token punctuation">.</span>var<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
model_var <span class="token operator">=</span> VarianceThreshold<span class="token punctuation">(</span>threshold<span class="token operator">=</span>medium_var<span class="token punctuation">)</span>
x_var_medium <span class="token operator">=</span> model_var<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
x_var_medium<span class="token punctuation">.</span>shape
</code></pre> 
<p>(42000, 392)</p> 
<h6><a id="b__69"></a>b. 方差过滤对模型的影响:</h6> 
<p>  我们这样做了以后，对模型效果会有怎样的影响呢？我们通过对比<strong>KNN和随机森林分别在方差过滤前和方差过滤后运行的效果和运行时间</strong>来说明。KNN是K近邻算法中的分类算法，其原理非常简单，是利用每个样本到其他样本点的距离来判断每个样本点的相似度，然后对样本进行分类。KNN必须遍历每个特征和每个样本，因而特征越多，KNN的计算也就会越缓慢。</p> 
<blockquote> 
 <p>这一部分代码运算时间很长，这里我使用colab环境进行运行。</p> 
</blockquote> 
<p><strong>KNN算法方差过滤前：</strong></p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>neighbors <span class="token keyword">import</span> KNeighborsClassifier <span class="token keyword">as</span> KNN
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> cross_val_score
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>ensemble <span class="token keyword">import</span> RandomForestClassifier
```python
cross_val_score<span class="token punctuation">(</span>KNN<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>cv<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>0.9658569700264943</p> 
<pre><code class="prism language-python"><span class="token operator">%</span><span class="token operator">%</span>timeit
cross_val_score<span class="token punctuation">(</span>KNN<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>cv<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><strong>KNN算法方差过滤后：</strong></p> 
<pre><code class="prism language-python">cross_val_score<span class="token punctuation">(</span>KNN<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x_fsvar<span class="token punctuation">,</span>y<span class="token punctuation">,</span>cv<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>0.9659997478150573</p> 
<pre><code class="prism language-python"><span class="token operator">%</span><span class="token operator">%</span>timeit
cross_val_score<span class="token punctuation">(</span>KNN<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x_fsvar<span class="token punctuation">,</span>y<span class="token punctuation">,</span>cv<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/09/f3/KU7JjF9s_o.png" alt="在这里插入图片描述"><br> <em>对于KNN，过滤后的效果十分明显：准确率稍有提升，耗费时间减少了近一半。</em></p> 
<p><strong>随机森林算法方差过滤前：</strong></p> 
<pre><code class="prism language-python">cross_val_score<span class="token punctuation">(</span>RFC<span class="token punctuation">(</span>random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>cv<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>0.9380003861799541</p> 
<pre><code class="prism language-python"><span class="token operator">%</span><span class="token operator">%</span>timeit
cross_val_score<span class="token punctuation">(</span>RFC<span class="token punctuation">(</span>n_estimators<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span>random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">,</span>cv<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>19.4 s ± 1.26 s per loop (mean ± std. dev. of 7 runs, 1 loop each)</p> 
<p><strong>随机森林算法方差过滤后：</strong></p> 
<pre><code class="prism language-python">cross_val_score<span class="token punctuation">(</span>RFC<span class="token punctuation">(</span>random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x_var_medium<span class="token punctuation">,</span>y<span class="token punctuation">,</span>cv<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>0.9388098166696807</p> 
<pre><code class="prism language-python">cross_val_score<span class="token punctuation">(</span>RFC<span class="token punctuation">(</span>random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x_var_medium<span class="token punctuation">,</span>y<span class="token punctuation">,</span>cv<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>19.1 s ± 1.38 s per loop (mean ± std. dev. of 7 runs, 1 loop each)</p> 
<p>  首先可以观察到的是，随机森林的准确率略逊于KNN，但运行时间却连KNN的1%都不到，只需要十几秒钟。其次，方差过滤后，随机森林的准确率也微弱上升，但运行时间却几乎是没什么变化，依然是19秒钟。</p> 
<p>  为什么随机森林运行如此之快？为什么方差过滤对随机森林没很大的有影响？这是由于两种算法的原理中涉及到的计算量不同。最近邻算法KNN，单棵决策树，支持向量机SVM，神经网络，回归算法，都需要遍历特征或升维来进行运算，所以他们本身的运算量就很大，需要的时间就很长，因此方差过滤这样的特征选择对他们来说就尤为重要。</p> 
<p>  但对于不需要遍历特征的算法，比如随机森林，它随机选取特征进行分枝，本身运算就非常快速，因此特征选择对它来说效果平平。这其实很容易理解，无论过滤法如何降低特征的数量，随机森林也只会选取固定数量的特征来建模；而最近邻算法就不同了，特征越少，距离计算的维度就越少，模型明显会随着特征的减少变得轻量。因此，过<strong>滤法的主要对象是：需要遍历特征或升维的算法们，而过滤法的主要目的是：在维持算法表现的前提下，帮助算法们降低计算成本</strong></p> 
<h5><a id="312__131"></a>3.1.2 相关性过滤</h5> 
<p>   方差挑选之后，我们就要考虑下一个问题：相关性。<strong>我们希望选出与标签相关且有意义的特征，因为这样的特征能够为我们提供大量信</strong>息、如果特征与标签无关，那只会白白浪费时间，可能还会给模型带来噪音。在sklearn当中，我们有三种常用的方法评判特征与标签之间的相关性：<strong>卡方检验，F检验，互信息</strong></p> 
<h6><a id="3121__134"></a>3.1.2.1 卡方过滤</h6> 
<h6><a id="a__135"></a>a 卡方过滤</h6> 
<p>  <strong>卡方过滤是专门针对离散型标签(分类)的相关性过滤</strong>。卡方检验类feature_selection.chi2计算每个非负特征和标签之间的卡方统计量，并<strong>按照卡方统计量由高到低为特征排名</strong>。再结合feature_selection.SelectKBest这个可以<strong>输入“评分标准”来选出前K个分数最高的特征</strong>的类，我们可以借此除去最可能独立于标签，与我们分类目的无关的特征。<br>   另外，如果卡方检验检测到某个特征中的所有值都相同，会提示我们使用方差先进行方差过滤，并且我们已经验证过，当我们使用方差过滤筛选掉一半的特征后，模型的表现是提升的。因此在这里，我们使用<strong>threshold=中位数</strong>完成的方差过滤的数据来做卡方检验：</p> 
<p><strong>引包：</strong></p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>feature_selection <span class="token keyword">import</span> SelectKBest
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>feature_selection <span class="token keyword">import</span> chi2
</code></pre> 
<p><strong>卡方过滤：</strong></p> 
<pre><code class="prism language-python">model_chi2 <span class="token operator">=</span> SelectKBest<span class="token punctuation">(</span>chi2<span class="token punctuation">,</span>k<span class="token operator">=</span><span class="token number">300</span><span class="token punctuation">)</span>
x_chi2 <span class="token operator">=</span> model_chi2<span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>x_var_medium<span class="token punctuation">,</span>y<span class="token punctuation">)</span>
x_chi2<span class="token punctuation">.</span>shape
</code></pre> 
<p>(42000, 300)</p> 
<p><strong>模型效果对比：</strong></p> 
<pre><code class="prism language-python">cross_val_score<span class="token punctuation">(</span>RFC<span class="token punctuation">(</span>random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x_var_medium<span class="token punctuation">,</span>y<span class="token punctuation">,</span>cv<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>0.9411198132299345</p> 
<pre><code class="prism language-python">cross_val_score<span class="token punctuation">(</span>RFC<span class="token punctuation">(</span>random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x_chi2<span class="token punctuation">,</span>y<span class="token punctuation">,</span>cv<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>0.9378586603630324</p> 
<p>  可以看出，<strong>模型的效果降低</strong>了，这说明我们在设定k=300的时候删除了与模型相关且有效的特征，我们的K值设置得太小，要么我们需要调整K值，要么我们必须放弃相关性过滤。当然，如果模型的表现提升，则说明我们的相关性过滤是有效地，是过滤掉了模型的噪音的，这时候我们就保留相关性过滤的结果。</p> 
<h6><a id="b_K_165"></a>b. 选取超参数K</h6> 
<p>  那如何设置一个最佳的K值呢？在现实数据中，数据量很大，模型很复杂的时候，我们也许不能先去跑一边模型看看效果，而是希望最开始就能选择一个最优的超参数K，那第一个方法就是我们之前提到过的学习曲线：</p> 
<pre><code class="prism language-python">score_list <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">390</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    x_chi2 <span class="token operator">=</span> SelectKBest<span class="token punctuation">(</span>chi2<span class="token punctuation">,</span>k<span class="token operator">=</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>
    score <span class="token operator">=</span> cross_val_score<span class="token punctuation">(</span>RFC<span class="token punctuation">(</span>random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x_chi2<span class="token punctuation">,</span>y<span class="token punctuation">,</span>cv<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
    score_list<span class="token punctuation">.</span>append<span class="token punctuation">(</span>score<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>plot<span class="token punctuation">(</span><span class="token builtin">range</span><span class="token punctuation">(</span><span class="token number">390</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>score_list<span class="token punctuation">)</span>
plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p><img src="https://images2.imgbox.com/dd/38/u52wb6eK_o.png" alt="在这里插入图片描述"></p> 
<p>  通过这条曲线，我们可以观察到，随着K值得不断增加，模型的表现不断上升。这说明，<strong>K越大越好，数据中所有的特征都是与标签相关的</strong>。但是运行这条曲线的时间同样也是非常长，接下来我们就来介绍一种<strong>更好的选择K的方法：看P值选择K</strong></p> 
<p>  卡<strong>方检验的本质是推测两种数据之间的差异，其检验的原假设是 “两组数据是相互独立的”。卡方检验返回卡方值和P值两个统计量</strong>，其中卡方值很难界定有效的范围，而P值，我们一般使用0.01或0.05作为显著性水平，即P值判断的边界，具体我们可以这样来看：</p> 
<table><thead><tr><th>P值</th><th>&lt;=0.05或0.01</th><th>&gt;0.05或0.01</th></tr></thead><tbody><tr><td>数据差异</td><td>差异不是自然形成的</td><td>这些差异是很自然的样本误差</td></tr><tr><td>相关性</td><td>两组数据是相关的</td><td>亮度数据是相互独立的</td></tr><tr><td>原假设</td><td>拒绝原假设，接受备选假设</td><td>接受原假设</td></tr></tbody></table> 
<p>  从特征工程的角度，我们希望<strong>选取卡方值很大，P值小于0.05的特征</strong>，即和标签是相关联的特征。而调用SelectKBest之前，我们可以直接<strong>从chi2实例化的模型中获得各个特征所对应的卡方值和P值</strong>。</p> 
<pre><code class="prism language-python">chivalue<span class="token punctuation">,</span>pvalue <span class="token operator">=</span> chi2<span class="token punctuation">(</span>x_var_medium<span class="token punctuation">,</span>y<span class="token punctuation">)</span> <span class="token comment"># 计算卡方值和P值</span>
chivalue<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token comment"># 计算得出前10个卡方值</span>
</code></pre> 
<p>array([ 945664.84392643, 1244766.05139164, 1554872.30384525,<br> 1834161.78305343, 1903618.94085294, 1845226.62427198,<br> 1602117.23307537, 708535.17489837, 974050.20513718,<br> 1188092.19961931])</p> 
<pre><code class="prism language-python">pvalue<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token comment"># 计算得出前10个P值</span>
</code></pre> 
<p>array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])</p> 
<pre><code class="prism language-python">k <span class="token operator">=</span> x_var_medium<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token punctuation">(</span>pvalue<span class="token operator">&gt;</span><span class="token number">0.05</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># 计算选取特征数</span>
k
</code></pre> 
<p>  通过观察，所有的特征P值都是0，这说明对于dight_recignizor这个数据集来说，方差验证已经把所有和标签无关的特征都剔除了，或者这个数据集本身就不含与标签无关的特征。在这种情况下，舍弃任何一个特征，都会舍弃对模型有用的信息，而是模型表现下降，因此我们对计算速度感到满意时，我们不需要使用相关性过滤来过滤我们的数据，我们试试用其他的相关性过滤方法验证一下我们在这个数据集上的结论。</p> 
<h6><a id="3122_F_207"></a>3.1.2.2 F检验</h6> 
<p>  <strong>F检验，又称ANOVA，方差齐性检验，是用来捕捉每个特征与标签之间的线性关系的过滤方法</strong>。它既可以做回归也可以做分类，因此包含feature_selection.f_classif和feature_selection.regression两个类。其中<strong>F检验分类用于标签是离散型变量的数据，而F检验回归用于标签是连续性变量的数据</strong>。</p> 
<p>  和卡方检验一样，这两个类需要和类SelectKBest连用，并且我们也可以直接通过输出的统计量来判断我们到底要设置一个什么样的K。需要注意的是，<strong>F检验在数据服从正态分布时效果会非常稳定，因此如果使用F检验过滤，我们会先将数据转换成服从正态分布的形式。</strong></p> 
<p>  <strong>F检验的本质是寻找两组数据之间的线性关系，其原假设是数据不存在显著的线性关系</strong>。它返回F值和P值两个统计量。和卡方过滤一样，<strong>我们希望选取P值小于0.05或0.01的特征，这些特征与标签是显著线性相关的，而P值大于0.05或0.01的特征则被我们认为是和标签没有显著线性关系的特征，应该被删除</strong>。以F检验的分类为例，我们继续在数字数据集上来进行特征选择：</p> 
<p><strong>引包：</strong></p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>feature_selection <span class="token keyword">import</span> f_classif
</code></pre> 
<p><strong>F检验计算P值：</strong></p> 
<pre><code class="prism language-python">F<span class="token punctuation">,</span>pvalues_f <span class="token operator">=</span> f_classif<span class="token punctuation">(</span>x_var_medium<span class="token punctuation">,</span>y<span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-python">pvalues_f<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span>
</code></pre> 
<p>array([0., 0., 0., 0., 0., 0., 0., 0., 0., 0.])</p> 
<p><strong>计算特征选取个数：</strong></p> 
<pre><code class="prism language-python">k <span class="token operator">=</span> F<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token punctuation">(</span>pvalues_f <span class="token operator">&gt;</span> <span class="token number">0.05</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
k
</code></pre> 
<p>392</p> 
<p>  得到的结论和我们用卡方过滤得到的结论一模一样：<strong>没有任何特征的P值大于0.01.所有的特征都是和标签相关的，因此我们不需要相关性过滤</strong>。</p> 
<h6><a id="3123__236"></a>3.1.2.3 互信息法</h6> 
<p>  <strong>互信息法是用来捕捉每个特征与标签之间的任意关系(包括线性和非线性关系)的过滤方法</strong>。和F检验相似，它<strong>既可以做回归也可以做分类</strong>，并且包含两个类feature_selection.mutual_info_classif和feature_selection.mutual_info_regression.这两个类的用法和参数都和F检验一模一样，不过互信息法比F检验更加强大，<strong>F检验只能够找出线性关系，而互信息法可以找出任意关系</strong>。</p> 
<p>  互信息法不返回P值和F值类似的统计量，他<strong>返回每个特征与目标之间打的互信息量的估计，这个估计量在[0.1]之间取值，为0则表示两个变量独立，为1则表示两个变量完全相关</strong>。以互信息分类为例的代码如下：</p> 
<p><strong>引包：</strong></p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>feature_selection <span class="token keyword">import</span> mutual_info_classif <span class="token keyword">as</span> MIC
</code></pre> 
<pre><code class="prism language-python">result <span class="token operator">=</span> MIC<span class="token punctuation">(</span>x_var_medium<span class="token punctuation">,</span>y<span class="token punctuation">)</span>
result<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">10</span><span class="token punctuation">]</span>
</code></pre> 
<p>array([0.06271997, 0.08577215, 0.10750456, 0.11162415, 0.11419952,<br> 0.10023697, 0.08377809, 0.05608807, 0.0715175 , 0.10122818])</p> 
<p><strong>计算特征选取个数：</strong></p> 
<pre><code class="prism language-python">k <span class="token operator">=</span> result<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token builtin">sum</span><span class="token punctuation">(</span>result<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">)</span>
k
</code></pre> 
<p>392</p> 
<p>  所有特征的互信息量估计都大于0，因此所有特征都与标签相关。</p> 
<p>  无论是F检验还是互信息法，都可以使用学习曲线，只是<strong>使用统计量的方法会更加高效</strong>。当统计量判断已经没有特征可以删除时，无论用学习曲线如何跑，删除特征都只会降低模型的表现。当然了，如果数据量太庞大，模型太复杂，我们还是可以牺牲模型表现来提升模型速度，一切都看大家的具体需求。</p> 
<h5><a id="313__263"></a>3.1.3 总结</h5> 
<table><thead><tr><th>类</th><th>说明</th><th>超参数的选择</th></tr></thead><tbody><tr><td>VarianceThreshold</td><td>方差过滤，可输入方差阈值，返回方差大于阈值的新特征矩阵</td><td>看具体数据究竟是含有更多噪声还是更多有效特征。一般就使用0或1筛选，也可以画学习曲线或者取中位数跑模型来帮忙确认</td></tr><tr><td>SelectKBest</td><td>用来选取K个统计量结果最佳的特征，生成符合统计量要求的新特征矩阵</td><td>看配合使用的统计量</td></tr><tr><td>chi2</td><td>卡方检验，专用于分类算法，捕捉相关性</td><td>选择P小于显著性水平的特征</td></tr><tr><td>f_classif</td><td>F检验分类，只能捕捉线性相关性，要求数据服从正态分布</td><td>追求P小于显著性水平的特征</td></tr><tr><td>f_regression</td><td>F检验回归，只能捕捉线性相关性，要求数据服从正态分布</td><td>追求P小于显著性水平的特征</td></tr><tr><td>mutual_info_classif</td><td>互信息分类，可以捕捉任何相关性，不能用于稀疏矩阵</td><td>追求互信息估计大于0的特征</td></tr><tr><td>mutual_info_regression</td><td>互信息回归，可以捕捉任何相关性，不能用于稀疏矩阵</td><td>追求互信息估计大于0的特征</td></tr></tbody></table> 
<h4><a id="32_Embedded_276"></a>3.2 Embedded嵌入法</h4> 
<p>  <strong>嵌入法是一种让算法自己决定使用哪些特征的方法，即特征选择和算法训练同时进行</strong>。在使用嵌入法时，我们先试用某些机器学习的算法和模型进行训练，得到各个特征的权值系数，根据权值系数从大到小选择特征。这些<strong>权值系数往往代表了特征对于模型的某种贡献或某种重要性</strong>，比如决策树和随机森林中的<strong>feature_importances_<strong>属性，可以列出各个特征对树的建立的贡献，我们就可以</strong>基于这种贡献的评估，找出对模型建立最有用的特征</strong>。因此相比于过滤法，嵌入法的结果会更加精确到模型的效用本身，对于提高模型效力有更好的结果。并且，由于考虑特征对模型的贡献，因此无关的特征(需要相关性过滤的特征)和无区分度的特征(需要方差过滤的特征)都会因为缺乏对模型的贡献而被删除掉，可谓是过滤法的进化版。</p> 
<p>  然而，嵌入法也不是没有缺点。过滤法中使用的统计量可以使用统计知识和常识来查找范围(如P值)。而<strong>嵌入法中使用的权值系数却没有这样的范围可找</strong>，我们可以说，权值系数为0的特征对模型丝毫没有作用。但当大量特征都对模型有贡献且贡献不一时，我们就很难去界定一个有效的临界值。这种情况下，模型权值系数就是我们的超参数，我们或许需要学习曲线，或者根据模型本身的某些性质去判断这个超参数的最佳值究竟应该是多少。</p> 
<h4><a id="33_Wrapper_282"></a>3.3 Wrapper包装法</h4> 
<p>  <strong>包装法也是一个特征选择和算法训练同时进行的方法</strong>，与嵌入法十分相似，他也是依赖于算法自身的选择，比如coef_属性或feature_importances_属性来完成特征选择。但不同的是，我们往往使用一个目标函数作为黑盒来帮助我们选取特征，而不是自己输入某个评估指标或统计量的阈值。包装法在初始特征集上训练评估器，并且通过coef_属性或通过feature_importances_属性获得每个特征的重要性。然后，从当前的一组特征中修剪最不重要的特征。在修剪的集合上递归地重复该过程，直到最终到大所需数量的要选择的特征。区别于过滤法和嵌入法的一次训练解决所有问题，<strong>包装法要使用特征子集进行多次训练，因此他所需要的计算成本是最高的。</strong></p> 
<p>  注意，这个算法指的不是我们最终用来导入数据的分类或回归算法，而是专业的数据挖掘算法，即我们的目标函数。这些数据挖掘算法的核心功能就是选取最佳特征子集。</p> 
<p>  <strong>最典型的目标函数是递归特征消除法</strong>。他是一种贪婪的优化算法，旨在找到性能最佳的特征子集。<strong>它反复创建模型，并在每次迭代时保留最佳特征或剔除最差特征，下一次迭代时，他会使用上一次建模中没有被选中的特征来构建下一个模型，直到所有特征都耗尽为止。然后，他根据自己保留或剔除特征的顺序来对特征进行排名，最终选出一个最佳子集</strong>。包装法的效果是所有特征选择方法中最利于提升模型表现的，他可以使用很少的特征达到很优秀的效果。除此之外，在特征数目相同时，包装法和嵌入法的效果能够匹敌，不过它比嵌入法算的更加缓慢，所以也不适用于太大型的数据。相比之下，包装法是最能保证模型效果的特征选择方法。</p> 
<p><strong>代码实现：</strong></p> 
<p><strong>引包：</strong></p> 
<pre><code class="prism language-python"><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>feature_selection <span class="token keyword">import</span> RFE
</code></pre> 
<p><strong>n_features_to_select</strong>：想要特征的个数；<br> <strong>step</strong>：每次迭代中希望溢出的特征个数</p> 
<pre><code class="prism language-python">selector <span class="token operator">=</span> RFE<span class="token punctuation">(</span>RFC<span class="token punctuation">(</span>random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>n_features_to_select<span class="token operator">=</span><span class="token number">340</span><span class="token punctuation">,</span>step<span class="token operator">=</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fit<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>
</code></pre> 
<pre><code class="prism language-python">selector<span class="token punctuation">.</span>support_<span class="token punctuation">.</span><span class="token builtin">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment"># support_返回所有特征最后是否被选中的布尔矩阵</span>
</code></pre> 
<pre><code class="prism language-python">selector<span class="token punctuation">.</span>ranking_ <span class="token comment"># 返回特征按迭代次数中重要性排名</span>
</code></pre> 
<pre><code class="prism language-python">X_wrapper <span class="token operator">=</span> selector<span class="token punctuation">.</span>transform<span class="token punctuation">(</span>x<span class="token punctuation">)</span>
cross_val_score<span class="token punctuation">(</span>RFC<span class="token punctuation">(</span>random_state<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>X_wrapper<span class="token punctuation">,</span>y<span class="token punctuation">,</span>cv<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mean<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<p>0.9412862149257508</p> 
<h3><a id="4__313"></a>4. 总结</h3> 
<p>  经验来说，过滤法更快速，但更粗糙。包装法和嵌入法更精确，比较适合具体到算法去调整，但计算量比较大，运行时间长。当数据量很大的时候，优先使用方差过滤和互信息法调整，在上其他特征选择方法。使用逻辑回归时，优先使用嵌入法。使用支持向量机时，优先使用包装法。</p> 
<p><strong>参考资料</strong>：《<a href="http://edu.cda.cn/course/982" rel="nofollow">菜菜的sklearn学习</a>》</p> 
<p><strong>关联文章</strong>：</p> 
<p><a href="https://blog.csdn.net/weixin_43060843/article/details/106278844">数据预处理Part1——数据清洗</a><br> <a href="https://blog.csdn.net/weixin_43060843/article/details/106318234">数据预处理Part2——数据标准化</a><br> <a href="https://blog.csdn.net/weixin_43060843/article/details/106302053">数据预处理Part3——真值转换</a><br> <a href="https://blog.csdn.net/weixin_43060843/article/details/106351639">数据预处理Part4——数据离散化</a><br> <a href="https://blog.csdn.net/weixin_43060843/article/details/106452221">数据预处理Part5——样本分布不均衡</a><br> <a href="https://blog.csdn.net/weixin_43060843/article/details/106495704">数据预处理Part6——数据抽样</a><br> <a href="https://blog.csdn.net/weixin_43060843/article/details/106497433">数据预处理Part8——数据共线性</a><br> <a href="https://blog.csdn.net/weixin_43060843/article/details/106594363">数据预处理Part9——数据降维</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7b8015a66bb3827c235e579bd27a36ec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Mariadb】-Mariadb集群故障节点替换过程（技术支持，请勿转载）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/05d6c1400de2dc8001d31a46fb605f78/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">使用Azure Kinect Body骨骼构造SMPL三维人体模型</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>