<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>css优化--vue2和vue3中虚拟滚动，懒加载实现 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="css优化--vue2和vue3中虚拟滚动，懒加载实现" />
<meta property="og:description" content="重绘(repaint)：只是当页面的颜色、透明度等信息发生变化时会导致重绘。例如：color、background-color、visibility等，结构不变。
回流、重排(reflow)：整个dom树重新渲染。
假设实际开发中服务端一次响应10万条列表数据，此时设备屏幕只允许容纳10条，那么用户理论上只可以看见10条数据。此时如果前端将10万条数据全部渲染成DOM元素，可能造成程序卡顿，占用较大资源，非常影响用户体验，那么虚拟滚动技术就完美的解决了这一问题。
【虚拟滚动的实现】
1、获取滚动高度
2、列表单个item的高度
3、计算屏幕容纳几个item
4、计算滚动了几个item到顶部不可见区域
5、使用css3的transform属性将滚动到上方不可见区域的DOM元素偏移到可见区域，同时进行数据的更新(重绘操作节约性能)。
使用 react，vue 等页面框架来编写 view 页面，采用虚拟 DOM 技术，极可能的将多次重排浓缩成一次
vue2代码：
&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&#34;UTF-8&#34;&gt; &lt;!-- import CSS --&gt; &lt;link rel=&#34;stylesheet&#34; href=&#34;https://unpkg.com/element-ui/lib/theme-chalk/index.css&#34;&gt; &lt;script src=&#34;https://cdn.bootcdn.net/ajax/libs/vue/2.6.13/vue.min.js&#34;&gt;&lt;/script&gt; &lt;!-- import JavaScript --&gt; &lt;script src=&#34;https://unpkg.com/element-ui/lib/index.js&#34;&gt;&lt;/script&gt; &lt;title&gt;虚拟滚动原理&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&#34;app&#34;&gt; &lt;el-row :gutter=&#34;10&#34;&gt; &lt;el-col :xs=&#34;6&#34; :sm=&#34;6&#34; :md=&#34;5&#34; :lg=&#34;4&#34; :xl=&#34;2&#34;&gt; &lt;el-button type=&#34;danger&#34; @click=&#34;virtualScrolling(20)&#34;&gt;20条&lt;/el-button&gt; &lt;/el-col&gt; &lt;el-col :xs=&#34;6&#34; :sm=&#34;6&#34; :md=&#34;5&#34; :lg=&#34;4&#34; :xl=&#34;2&#34;&gt; &lt;el-button type=&#34;primary&#34; @click=&#34;virtualScrolling(100)&#34;&gt;一百条&lt;/el-button&gt; &lt;/el-col&gt; &lt;el-col :xs=&#34;6&#34; :sm=&#34;6&#34; :md=&#34;5&#34; :lg=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/dd7cce8cc0001e215cbc2327b8b0bf16/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-21T14:20:32+08:00" />
<meta property="article:modified_time" content="2023-03-21T14:20:32+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">css优化--vue2和vue3中虚拟滚动，懒加载实现</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/33/6e/1rHe9NtC_o.png" alt="在这里插入图片描述"><br> 重绘(repaint)：只是当页面的颜色、透明度等信息发生变化时会导致重绘。例如：color、background-color、visibility等，结构不变。<br> 回流、重排(reflow)：整个dom树重新渲染。<br> 假设实际开发中服务端一次响应10万条列表数据，此时设备屏幕只允许容纳10条，那么用户理论上只可以看见10条数据。此时如果前端将10万条数据全部渲染成DOM元素，可能造成程序卡顿，占用较大资源，非常影响用户体验，那么虚拟滚动技术就完美的解决了这一问题。<br> 【虚拟滚动的实现】<br> 1、获取滚动高度</p> 
<p>2、列表单个item的高度</p> 
<p>3、计算屏幕容纳几个item</p> 
<p>4、计算滚动了几个item到顶部不可见区域</p> 
<p>5、使用css3的transform属性将滚动到上方不可见区域的DOM元素偏移到可见区域，同时进行数据的更新(重绘操作节约性能)。<br> 使用 react，vue 等页面框架来编写 view 页面，采用虚拟 DOM 技术，极可能的将多次重排浓缩成一次<br> vue2代码：</p> 
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
 
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;!-- import CSS --&gt;
    &lt;link rel="stylesheet" href="https://unpkg.com/element-ui/lib/theme-chalk/index.css"&gt;
    &lt;script src="https://cdn.bootcdn.net/ajax/libs/vue/2.6.13/vue.min.js"&gt;&lt;/script&gt;
    &lt;!-- import JavaScript --&gt;
    &lt;script src="https://unpkg.com/element-ui/lib/index.js"&gt;&lt;/script&gt;
    &lt;title&gt;虚拟滚动原理&lt;/title&gt;
&lt;/head&gt;
 
&lt;body&gt;
    &lt;div id="app"&gt;
        &lt;el-row :gutter="10"&gt;
            &lt;el-col :xs="6" :sm="6" :md="5" :lg="4" :xl="2"&gt;
                &lt;el-button type="danger" @click="virtualScrolling(20)"&gt;20条&lt;/el-button&gt;
            &lt;/el-col&gt;
            &lt;el-col :xs="6" :sm="6" :md="5" :lg="4" :xl="2"&gt;
                &lt;el-button type="primary" @click="virtualScrolling(100)"&gt;一百条&lt;/el-button&gt;
            &lt;/el-col&gt;
            &lt;el-col :xs="6" :sm="6" :md="5" :lg="4" :xl="2"&gt;
                &lt;el-button type="success" @click="virtualScrolling(1000)"&gt;一千条&lt;/el-button&gt;
            &lt;/el-col&gt;
            &lt;el-col :xs="6" :sm="6" :md="5" :lg="4" :xl="2"&gt;
                &lt;el-button @click="virtualScrolling(100000)"&gt;十万条&lt;/el-button&gt;
            &lt;/el-col&gt;
        &lt;/el-row&gt;
        &lt;div class="wrap" @scroll="liScroll"&gt;
            &lt;ul class="ul_wrap" :style="`height:${ulHei}px`"&gt;
                &lt;li class="li_item" :style="`height:${liHei}px;transform:translateY(${ScroolNum}px)`"
                    v-for="item in liList" :key="item"&gt;
                    {<!-- -->{item}}
                &lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;style&gt;
    .wrap {
        height: 400px;
        background-color: #fff;
        overflow: scroll;
        margin-top: 20px;
    }
 
    .li_item {
        border: 1px red solid;
        line-height: 50px;
 
    }
&lt;/style&gt;
&lt;script&gt;
    new Vue({
        el: '#app',
        data(){
            return {
                liHei: 50,//li的高度
                ulHei: 480,//ul的高度
                liList: [],//真实展示的列表
                scrollHei:0,//@scroll事件滚动的top值
                ScroolNum: 0,//scrollHei能被li高度取余数的整数值。ScroolNum=scrollHei-(scrollHei%liHei)
                showList: 0,//真实展示的条数
                tableData: [],//全部数据的集合
                lastTime:0,//最后时间
            }
        },
        mounted () {
            this.virtualScrolling(100)
            
        },
        methods: {
             /**滚动监听 */
            liScroll (e) {
                if(new Date().getTime()-this.lastTime&gt;40){//设置时间间隔，防止滚动事件高频触发消耗内存资源
                this.ele = e;//保存元素，方便重置scrollTop值
                this.scrollHei = e.target.scrollTop;//保存滚动条scrollTop值
                this.ScroolNum = this.scrollHei - (this.scrollHei % this.liHei);//获取已滚动到页面上方不可见的li元素的总高度（translateY的偏移高度）
                let len = this.ScroolNum / this.liHei;//计算已经有多少个li滚动到页面上方（视图上方用户不可见的数量）
                this.liList = this.tableData.slice(len, len + this.showList);//每次滚动事件后重新计算展示内容（截取的内容对应全部数据集的部分内容）
                this.lastTime=new Date().getTime();//记录最后一次更新时间
                }
                
            },
           /**初始化数据*/
            virtualScrolling (num) {
                let arr = [];//初始化数组
                for (let i = 0; i &lt; num; i++) {//计算给定数据量
                    arr.push(i+1)
                }
                this.tableData = arr;//全部数据集
                this.showList = Math.floor(this.ulHei / this.liHei) + 4;//计算真实渲染的列表数量
                this.liList = this.tableData.slice(0, this.showList);//初始化可视列表的内容
                this.lastTime=new Date().getTime();//记录最后一次更新时间
                this.$message({
                    message: `当前数据为${num}条`,
                    type: 'success'
                    });
               
                if (!!this.ele) {//判断监听元素是否保存到ele字段中
                    this.ele.target.scrollTop = 0;//如果元素存在ele中则将scrollTop初始化为0;
                    this.ScroolNum=0;//初始化translateY的偏移高度
                }
               
            },
        }
    })
&lt;/script&gt;
 
&lt;/html&gt;
</code></pre> 
<p>vue3:</p> 
<pre><code>&lt;script setup&gt;
import { ref, computed, nextTick } from "vue";
//设置10W条模拟数据
const count = ref(100000);let arr = ref([]);
for (let index = 0; index &lt; count.value; index++) {  
   arr.value.push(index);
}
 
//容器真实高度
let containerHeight = ref(arr.value.length * 40);
//当前状态的索引
let startKey = ref(0);
//视窗内应该显示的 DOM 数量
let showItemNum = ref(0);
//容器dom节点
const wrapper = ref(null);
//容器高度
let wrapperHeight = ref(0);
nextTick(() =&gt; {  
   //获取容器高度
   wrapperHeight.value = wrapper.value.clientHeight; 
   //运算出应该显示的 DOM 数量
   showItemNum.value = Math.ceil(wrapperHeight.value / 40);
});
//片段容器偏移量
let scrollTopWrapper = ref(0);
//滚动事件
const wrapperScroll = (e) =&gt; {  
  //计算当前状态的索引
  let tempNum = Math.floor(e.target.scrollTop / 40); 
   
  //当前状态的索引发生变化才触发视图层刷新
  if (tempNum !== startKey.value) {    
    startKey.value = tempNum    
    scrollTopWrapper.value = e.target.scrollTop;  
  }
};
//对数据进行切片处理方法
const showItem = computed(() =&gt; {  
  
  return [...arr.value.slice(startKey.value, showItemNum.value + startKey.value + 3)];
});
&lt;/script&gt;
&lt;template&gt; 
   &lt;div class="wrapper" ref="wrapper" @scroll="wrapperScroll($event)"&gt;      
      &lt;div class="wrapper-scroll" :style="{ height: containerHeight + 'px' }"   style="position: relative;" &gt;        
        &lt;div   :style="{ transform: `translateY(${scrollTopWrapper}px)` }"  style="position: absolute; width: 100%;"   &gt;
           &lt;div  v-for="(item, key) in showItem"   :key="key"  style="height:40px;line-height:40px"   &gt;
           {<!-- -->{item}}
           &lt;/div&gt;        
        &lt;/div&gt;   
      &lt;/div&gt;  
   &lt;/div&gt;
&lt;/template&gt;
&lt;style&gt;
.wrapper {  
   position: relative;  
   width: 200px;  
   height: 200px;  
   overflow: auto;  
   border: 1px solid #ccc;
}
&lt;/style&gt;
</code></pre> 
<p>其他Css优化方法：<br> 1，首推的是合并css文件，如果页面加载10个css文件，每个文件1k，那么也要比只加载一个100k的css文件慢。</p> 
<p>2，减少css嵌套，最好不要套三层以上。</p> 
<p>3，不要在ID选择器前面进行嵌套，ID本来就是唯一的而且人家权值那么大，嵌套完全是浪费性能。</p> 
<p>4，建立公共样式类，把相同样式提取出来作为公共类使用，比如我们常用的清除浮动等。</p> 
<p>5，减少通配符*或者类似[hidden=“true”]这类选择器的使用，挨个查找所有…这性能能好吗？当然重置样式这些必须 的东西是不能少的。</p> 
<p>6，巧妙运用css的继承机制，如果父节点定义了，子节点就无需定义。</p> 
<p>7，拆分出公共css文件，对于比较大的项目我们可以将大部分页面的公共结构的样式提取出来放到单独css文件里， 这样一次下载后就放到缓存里，当然这种做法会增加请求，具体做法应以实际情况而定。</p> 
<p>8，不用css表达式，表达式只是让你的代码显得更加炫酷，但是他对性能的浪费可能是超乎你的想象的。</p> 
<p>9，少用css rest，可能你会觉得重置样式是规范，但是其实其中有很多的操作是不必要不友好的，有需求有兴趣的 朋友可以选择normolize.css</p> 
<p>10，cssSprite，合成所有icon图片，用宽高加上bacgroud-position的背景图方式显现出我们要的icon图，这是一种 十分实用的技巧，极大减少了http请求。</p> 
<p>11，当然我们还需要一些善后工作，CSS压缩(这里提供一个在线压缩 YUI Compressor ，当然你会用其他工具来压缩是十 分好的)，</p> 
<p>12，GZIP压缩，Gzip是一种流行的文件压缩算法</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5e02840ea013bdcc792388992e423f43/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Java基础】之AWT，一篇文章搞懂awt(包含绘图)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c3adf05e3b8de5c76b5fd35f035f8b59/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">es数据库基本操作</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>