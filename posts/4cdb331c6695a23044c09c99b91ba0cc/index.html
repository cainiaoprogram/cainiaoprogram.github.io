<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>简易文件系统-用Go语言从零开始设计(四) 文件系统冗余措施 一致性hash算法 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="简易文件系统-用Go语言从零开始设计(四) 文件系统冗余措施 一致性hash算法" />
<meta property="og:description" content="一、一致性hash算法 一致性Hash介绍 分布式均匀算法--hash性一致算法--hash slot
上面是大致介绍，根据自身理解，其只是更随机更均匀的分配。本系统需要同一md5元数据不能分配到同一文件节点中，因此需要对其进行改造。
也就是计算元数据key时，会遍历对应key中是否有相同md5值的数据，如果有则寻找下一个key对应的node，直到找到为止。
本来一致性Hash能快速根据key获取信息，不用存储Key对应的文件信息，但由于本系统需求，需要存储空间记录信息。
Go语言一致性Hash代码为网上开源，只是对其功能进行修改
一致性Hash算法
package main //一致性哈希(Consistent Hashing) import ( &#34;fmt&#34; &#34;hash/crc32&#34; &#34;sort&#34; &#34;strconv&#34; &#34;sync&#34; ) const DEFAULT_REPLICAS = 2000 type HashRing []uint32 func (c HashRing) Len() int { return len(c) } func (c HashRing) Less(i, j int) bool { return c[i] &lt; c[j] } func (c HashRing) Swap(i, j int) { c[i], c[j] = c[j], c[i] } type Node struct { Id string Weight int } func NewNode(id string, weight int) *Node { return &amp;Node{ Id: id, Weight: weight, } } type Consistent struct { Nodes map[uint32]Node numReps int Resources map[string]bool NodeIdMap map[string]Node ring HashRing sync." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/4cdb331c6695a23044c09c99b91ba0cc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-02-23T18:19:14+08:00" />
<meta property="article:modified_time" content="2021-02-23T18:19:14+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">简易文件系统-用Go语言从零开始设计(四) 文件系统冗余措施 一致性hash算法</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>一、一致性hash算法</h2> 
<p><a href="https://www.cnblogs.com/lpfuture/p/5796398.html" rel="nofollow">一致性Hash介绍</a>     </p> 
<p><a href="https://www.cnblogs.com/myseries/p/10959050.html" rel="nofollow">分布式均匀算法--hash性一致算法--hash slot</a></p> 
<p>上面是大致介绍，根据自身理解，其只是更随机更均匀的分配。本系统需要同一md5元数据不能分配到同一文件节点中，因此需要对其进行改造。</p> 
<p><img alt="" height="1098" src="https://images2.imgbox.com/9c/65/2O41Nu2y_o.png" width="1200"></p> 
<p>也就是计算元数据key时，会遍历对应key中是否有相同md5值的数据，如果有则寻找下一个key对应的node，直到找到为止。</p> 
<p>本来一致性Hash能快速根据key获取信息，不用存储Key对应的文件信息，但由于本系统需求，需要存储空间记录信息。</p> 
<p>Go语言一致性Hash代码为网上开源，只是对其功能进行修改</p> 
<p><a href="https://blog.csdn.net/xcl168/article/details/43898807">一致性Hash算法</a></p> 
<pre><code class="language-Go">package main

//一致性哈希(Consistent Hashing)

import (
	"fmt"
	"hash/crc32"
	"sort"
	"strconv"
	"sync"
)

const DEFAULT_REPLICAS = 2000

type HashRing []uint32

func (c HashRing) Len() int {
	return len(c)
}

func (c HashRing) Less(i, j int) bool {
	return c[i] &lt; c[j]
}

func (c HashRing) Swap(i, j int) {
	c[i], c[j] = c[j], c[i]
}

type Node struct {
	Id     string
	Weight int
}

func NewNode(id string, weight int) *Node {
	return &amp;Node{
		Id:     id,
		Weight: weight,
	}
}

type Consistent struct {
	Nodes     map[uint32]Node
	numReps   int
	Resources map[string]bool
	NodeIdMap map[string]Node
	ring      HashRing
	sync.RWMutex
}

func NewConsistent() *Consistent {
	return &amp;Consistent{
		Nodes:     make(map[uint32]Node),
		numReps:   DEFAULT_REPLICAS,
		Resources: make(map[string]bool),
		NodeIdMap: make(map[string]Node),
		ring:      HashRing{},
	}
}

func (c *Consistent) FindNode(NodeId string) (*Node, error) {
	c.RLock()
	defer c.RUnlock()
	node, exit := c.NodeIdMap[NodeId]
	if exit {
		return &amp;node, nil
	} else {
		return nil, fmt.Errorf("没有找到HashID%s\n", NodeId)
	}

}

func (c *Consistent) Add(node *Node) bool {
	c.Lock()
	defer c.Unlock()

	if _, ok := c.Resources[node.Id]; ok {
		return false
	}

	count := c.numReps * node.Weight
	for i := 0; i &lt; count; i++ {
		str := c.joinStr(i, node)
		c.Nodes[c.hashStr(str)] = *(node)
	}
	c.Resources[node.Id] = true
	c.NodeIdMap[node.Id] = *node
	c.sortHashRing()
	return true
}

func (c *Consistent) sortHashRing() {
	c.ring = HashRing{}
	for k := range c.Nodes {
		c.ring = append(c.ring, k)
	}
	sort.Sort(c.ring)
}

func (c *Consistent) joinStr(i int, node *Node) string {
	return node.Id + "-" + strconv.Itoa(i)
}

// MurMurHash算法 :https://github.com/spaolacci/murmur3
func (c *Consistent) hashStr(key string) uint32 {
	return crc32.ChecksumIEEE([]byte(key))
}

func (c *Consistent) Get(key string) Node {
	c.RLock()
	defer c.RUnlock()

	hash := c.hashStr(key)
	i := c.search(hash)

	return c.Nodes[c.ring[i]]
}

// 获取与输入nodeid不重复的Node
func (c *Consistent) GetNotRepeatNode(key string, Keyid []string) (Node, error) {
	c.RLock()
	defer c.RUnlock()
	Nodeid := make([]string, 0)
	// KeyId 转化 NodeId
	for i := 0; i &lt; len(Keyid); i++ {
		hash := c.hashStr(Keyid[i])
		i := c.search(hash)
		Nodeid = append(Nodeid, c.Nodes[c.ring[i]].Id)
	}

	hash := c.hashStr(key)
	i := c.search(hash)
	// 存在相同ID
	if ContainSameString(c.Nodes[c.ring[i]].Id, Nodeid) {
		// 对Hash环遍历
		for index := (i + 1) % len(c.ring); (index % len(c.ring)) != i; index++ {
			if !ContainSameString(c.Nodes[c.ring[index%len(c.ring)]].Id, Nodeid) {
				return c.Nodes[c.ring[index%len(c.ring)]], nil
			}

		}
		return c.Nodes[c.ring[i]], fmt.Errorf("无法找到不重复节点")
	}
	// 不存在相同ID
	// 直接返回

	return c.Nodes[c.ring[i]], nil

}

func ContainSameString(key string, data []string) bool {
	for i := 0; i &lt; len(data); i++ {
		if key == data[i] {
			return true
		}
	}
	return false
}

func (c *Consistent) search(hash uint32) int {

	i := sort.Search(len(c.ring), func(i int) bool { return c.ring[i] &gt;= hash })
	if i &lt; len(c.ring) {
		if i == len(c.ring)-1 {
			return 0
		} else {
			return i
		}
	} else {
		return len(c.ring) - 1
	}
}

func (c *Consistent) Remove(node *Node) {
	c.Lock()
	defer c.Unlock()

	if _, ok := c.Resources[node.Id]; !ok {
		return
	}

	delete(c.Resources, node.Id)
	delete(c.NodeIdMap, node.Id)
	count := c.numReps * node.Weight
	for i := 0; i &lt; count; i++ {
		str := c.joinStr(i, node)
		delete(c.Nodes, c.hashStr(str))
	}
	c.sortHashRing()
}
</code></pre> 
<h2><a id="_30"></a>二、文件系统冗余措施</h2> 
<p>由于每份元数据存储n份，并且如果掉线Filenode小于n，则用户可以读取其数据。</p> 
<p>当FileNode掉线时需要对FileNode进行重新平衡</p> 
<p><img alt="" height="1200" src="https://images2.imgbox.com/d5/f9/q617yW0k_o.png" width="1160"></p> 
<pre><code class="language-Go">// 重新分配资源
func RedistributionResource() {
	// 数据库读取所有元数据信息
	Metdatas, err := msql.GetMetdata()
	if err != nil {
		fmt.Println(err)
		return
	}
	// 按照读取顺序排序的VirtualIDMap
	VirtualIdMap := MetdataBuildVirtualMap(Metdatas)
	// 获取当前在线服务器ID
	//OnLindeNodeId := GetOnLineFileNode()
	// 对元数据进行遍历
	for i := 0; i &lt; len(Metdatas); i++ {
		// 获取元数据id
		mdata := Metdatas[i]
		// 获取相同VirtualiDMap中比自己前的MetaDataID
		HightRankIds := GetHightRankMetdata(mdata, VirtualIdMap[mdata.VirtualID])
		ItemNode, err := HashConsistent.GetNotRepeatNode(mdata.MetaDataID, HightRankIds)
		if err != nil {
			fmt.Println("RedistributionResource", err)
			continue
		}
		// 当前记录ID与期望不符合，开始转移数据
		if ItemNode.Id != mdata.MetaDataNodeId {
			go MoveMetadata(mdata, ItemNode.Id, VirtualIdMap)
		}
	}
}

// 转移数据
func MoveMetadata(mdata Metadata, ItemNodeID string, VirtualDataMap map[string][]Metadata) error {
	OldItemId := mdata.MetaDataNodeId
	// 判断 目标机器ItemNodeID 是否在线
	if !IsFileNodeOnline(ItemNodeID) {
		fmt.Println("目标机器未在线转移数据失败", ItemNodeID)
		return fmt.Errorf("目标机器未在线转移数据失败", ItemNodeID)
	}
	// 判断需要转移数据所在节点是否在线
	if IsFileNodeOnline(OldItemId) {
		return MoveMetadataFromOnlineNode(mdata, ItemNodeID)
	} else {
		return MoveMetdateFromOffLineNode(mdata, ItemNodeID, VirtualDataMap)
	}
}

// 从在线节点转移数据
func MoveMetadataFromOnlineNode(mdata Metadata, ItemNodeID string) error {
	// 开始读取其文件
	Data, err := ServerReadMetdata(mdata)
	if err != nil {
		fmt.Println("MoveMetdateFromOffLineNode", err)
		return err
	}
	mdata.Data = Data
	// 插入数据
	err = ServerMetadataInsert(mdata, ItemNodeID, 4)
	if err != nil {
		fmt.Println("MoveMetdateFromOffLineNode1", err)
		return err
	}

	// 删除老节点的数据
	err = DeleteMetaData(mdata, false)
	if err != nil {
		fmt.Println("MoveMetdateFromOffLineNode2", err)
		return err
	}
	// 数据库修改数据
	mdata.MetaDataNodeId = ItemNodeID
	err = msql.MetadaDataUpdate(mdata)
	return err
}

// 从离线节点转移数据
func MoveMetdateFromOffLineNode(mdata Metadata, ItemNodeID string, VirtualDataMap map[string][]Metadata) error {
	// 获取相同虚拟数据ID的其他数据 从其他数据那读取再转移至目标机器
	mdata.MetaDataNodeId = ItemNodeID
	OtherMetdata := VirtualDataMap[mdata.VirtualID]
	for i := 0; i &lt; len(OtherMetdata); i++ {
		if OtherMetdata[i].MetaDataID != mdata.MetaDataID {
			// 判断其所在机器是否在线
			if IsFileNodeOnline(OtherMetdata[i].MetaDataNodeId) {
				// 开始读取其文件
				Data, err := ServerReadMetdata(OtherMetdata[i])
				if err != nil {
					fmt.Println("MoveMetdateFromOffLineNode", err)
					continue
				}
				mdata.Data = Data
				// 插入数据
				err = ServerMetadataInsert(mdata, ItemNodeID, 4)
				if err != nil {
					fmt.Println("MoveMetdateFromOffLineNode1", err)
					continue
				}
				// 数据库修改数据
				mdata.MetaDataNodeId = ItemNodeID
				err = msql.MetadaDataUpdate(mdata)
				return nil
			}
		}
	}
	return fmt.Errorf("未转移成功%s", mdata.MetaDataID)
}</code></pre> 
<p> </p> 
<h3><a id="1_31"></a></h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bf85c1bb47706da89b26e3f04b020c81/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">简易文件系统-用Go语言从零开始设计(三) 文件上传 文件下载 文件删除 文件共享</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/76a834383fa5d6d403622ec973a69eed/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">pycharm怎样编写java_Pycharm改进和编写代码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>