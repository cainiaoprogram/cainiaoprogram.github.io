<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>`ElementUI` 中的奇技淫巧（2023） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="`ElementUI` 中的奇技淫巧（2023）" />
<meta property="og:description" content="在ElementUI的世界中，不仅有基础的组件和功能，还有一些让你眼前一亮、*得不能再*的高级技巧和窍门。本文将揭示这些技巧，让你在前端开发的舞台上独领风骚。无论你是一个勇敢的创新者还是一个喜欢调皮捣蛋的开发者，这些技巧都将让你的ElementUI应用更加酷炫和有趣！
直接进入正题
el-scrollbar滚动条 参数说明类型可选值native是否采用原生滚动。即只是隐藏原生滚动条，但并没有使用自定义的滚动条）Boolean-wrapStyle容器样式Object-wrapClass容器样式名Object-viewClass展示视图的样式名Object-viewStyle展示视图的样式Object-noresize容器大小是否不可变。如果 container 尺寸不会发生变化，最好设置它可以优化性能Boolean-tag渲染容器的标签。view容器用那种标签渲染，默认为divString- 自定义滚动条的原理
warp：滚动的可显示区域，滚动内容就是在这个区域中滚动；
view：实际的滚动内容，超出warp可显示区域的内容将被隐藏；
track：滚动条的滚动滑块；
thumb：上下滚动的轨迹。
&lt;el-scrollbar&gt; &lt;li v-for=&#34;user in userList&#34; :key=&#34;user.id&#34;&gt;{{user.name}}&lt;/li&gt; &lt;/el-scrollbar&gt; 管理弹出层的z-index：PopupManager ElementUI的弹出层在元素定位上，都有两种实现方式，分别是：
append-to-body：此模式下，弹出层会被放在&lt;body&gt;元素上，通过position: fixed定位，配合动态的top和left属性，完成弹出元素的定位。非append-to-body：此模式下，弹出层通过position: absolute定位，配合其父元素position: relative来完成弹出元素的定位。 在大多数情况下，ElementUI都是默认使用append-to-body，因为非append-to-body存在严重副作用，只有迫不得已的情况下才需要使用。
ElementUI弹出层的核心实现机制： 只要让新出现的弹出层，永远比之前所有弹出层的层级要高，就不会有新弹层被旧弹层遮盖的事情发生。
PopupManager：为弹出层提供获取实例、注册、注销等各种能力，但其最重要的能力，是提供了z-index的层级管理能力。
ElementUI为其内置了一个弹出层z-index基数（2000），但可以进行修改。
// 修改弹出层的`z-index`从3000开始递增 Vue.use(Element, {zIndex: 3000}) &lt;template&gt; &lt;div class=&#34;container&#34;&gt; &lt;el-button @click=&#34;onClick&#34;&gt;增加&lt;/el-button&gt; z-index: {{ value }} &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { PopupManager } from &#39;element-ui/src/utils/popup&#39; export default { data() { return { value: 0 } }, methods: { onClick() { // 使用 this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c0a09e26200281fca10c0f7fbd3c3e83/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-10T17:12:17+08:00" />
<meta property="article:modified_time" content="2023-12-10T17:12:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">`ElementUI` 中的奇技淫巧（2023）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在<code>ElementUI</code>的世界中，不仅有基础的组件和功能，还有一些让你眼前一亮、<code>*</code>得不能再<code>*</code>的高级技巧和窍门。本文将揭示这些技巧，让你在前端开发的舞台上独领风骚。无论你是一个勇敢的创新者还是一个喜欢调皮捣蛋的开发者，这些技巧都将让你的<code>ElementUI</code>应用更加酷炫和有趣！</p> 
<p><strong>直接进入正题</strong></p> 
<h5><code>el-scrollbar</code>滚动条</h5> 
<table><thead><tr><th>参数</th><th>说明</th><th>类型</th><th>可选值</th></tr></thead><tbody><tr><td><code>native</code></td><td><em>是否采用原生滚动。即只是隐藏原生滚动条，但并没有使用自定义的滚动条）</em></td><td><code>Boolean</code></td><td>-</td></tr><tr><td><code>wrapStyle</code></td><td><em>容器样式</em></td><td><code>Object</code></td><td>-</td></tr><tr><td><code>wrapClass</code></td><td><em>容器样式名</em></td><td><code>Object</code></td><td>-</td></tr><tr><td><code>viewClass</code></td><td><em>展示视图的样式名</em></td><td><code>Object</code></td><td>-</td></tr><tr><td><code>viewStyle</code></td><td><em>展示视图的样式</em></td><td><code>Object</code></td><td>-</td></tr><tr><td><code>noresize</code></td><td><em>容器大小是否不可变。如果 <code>container</code> 尺寸不会发生变化，最好设置它可以优化性能</em></td><td><code>Boolean</code></td><td>-</td></tr><tr><td><code>tag</code></td><td><em>渲染容器的标签</em>。<em><code>view</code>容器用那种标签渲染，默认为<code>div</code></em></td><td><code>String</code></td><td>-</td></tr></tbody></table> 
<p><strong>自定义滚动条的原理</strong></p> 
<p><img alt="" height="514" src="https://images2.imgbox.com/07/80/FV5TGOBw_o.png" width="514"></p> 
<p><strong><code>warp</code></strong>：滚动的可显示区域，滚动内容就是在这个区域中滚动；</p> 
<p><strong><code>view</code></strong>：实际的滚动内容，超出<code>warp</code>可显示区域的内容将被隐藏；</p> 
<p><strong><code>track</code></strong>：滚动条的滚动滑块；</p> 
<p><strong><code>thumb</code></strong>：上下滚动的轨迹。</p> 
<pre><code class="language-javascript">&lt;el-scrollbar&gt;
    &lt;li v-for="user in userList" :key="user.id"&gt;{<!-- -->{user.name}}&lt;/li&gt;
&lt;/el-scrollbar&gt;</code></pre> 
<h5>管理弹出层的<code>z-index</code>：<code>PopupManager</code></h5> 
<p><code>ElementUI</code>的弹出层在元素定位上，都有两种实现方式，分别是：</p> 
<ul><li><code>append-to-body</code>：此模式下，弹出层会被放在<code>&lt;body&gt;</code>元素上，通过<code>position: fixed</code>定位，配合动态的<code>top</code>和<code>left</code>属性，完成弹出元素的定位。</li><li>非<code>append-to-body</code>：此模式下，弹出层通过<code>position: absolute</code>定位，配合其父元素<code>position: relative</code>来完成弹出元素的定位。</li></ul> 
<p>在大多数情况下，<code>ElementUI</code>都是默认使用<code>append-to-body</code>，因为非<code>append-to-body</code>存在严重副作用，只有迫不得已的情况下才需要使用。</p> 
<blockquote> 
 <p><code>ElementUI</code>弹出层的核心实现机制： 只要让新出现的弹出层，永远比之前所有弹出层的层级要高，就不会有<strong>新弹层</strong>被<strong>旧弹层</strong>遮盖的事情发生。</p> 
 <p><code>PopupManager</code>：为弹出层提供获取实例、注册、注销等各种能力，但其最重要的能力，是提供了<code>z-index</code>的层级管理能力。</p> 
 <p><code>ElementUI</code>为其内置了一个弹出层<code>z-index</code>基数（<code>2000</code>），但可以进行修改。</p> 
 <p></p> 
</blockquote> 
<pre><code class="language-javascript">// 修改弹出层的`z-index`从3000开始递增
Vue.use(Element, {zIndex: 3000})</code></pre> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;div class="container"&gt;
    &lt;el-button @click="onClick"&gt;增加&lt;/el-button&gt;
    z-index: {<!-- -->{ value }} 
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import { PopupManager } from 'element-ui/src/utils/popup'
export default {
  data() {
    return {
      value: 0
    }
  },
  methods: {
    onClick() {
      // 使用
      this.value = PopupManager.nextZIndex()
    }
  }
}
&lt;/script&gt;
</code></pre> 
<p><strong>实战：一个更灵活的全屏组件</strong></p> 
<blockquote> 
 <p></p> 
 <p>众所周知，浏览器是有官方的全屏<code>API</code>的：<code>Element.requestFullscreen()</code>，它可以让一个元素立刻铺满视窗，并且置于所有元素之上。官方全屏是设定层级高于一切，那些<code>append-to-body</code>的弹窗，无论<code>z-index</code>多高，也绝对不会被显示出来。而那些非<code>append-to-body</code>模式的弹出层，确实会在某些业务场景不符合要求。</p> 
 <p></p> 
</blockquote> 
<p><strong>符合<code>ElementUI</code>层级标准的全屏组件</strong></p> 
<p>和浏览器官方<code>API</code>实现全屏的思路基本一致，但不同的地方在于：</p> 
<ul><li>官方全屏会默认置顶，<code>z-index</code>无限大；</li><li>封装的全屏组件，<code>z-index</code>符合<code>PopupManager</code>管家的规范。</li></ul> 
<p> <strong>示例代码</strong></p> 
<pre><code class="language-javascript">&lt;template&gt;
    &lt;div :class="{ 'custom-full-screen': isFullScreen }" :style="{zIndex: currentZIndex}"&gt;
      &lt;slot&gt;&lt;/slot&gt;
    &lt;/div&gt;
    &lt;/template&gt;
&lt;script&gt;
import { PopupManager } from 'element-ui/src/utils/popup'
​
export default {
  data() {
    return {
      isFullScreen: false,
      currentZIndex: null
    }
  },
  methods: {
    request() {
      this.isFullScreen = true
      this.currentZIndex = PopupManager.nextZIndex()
    }
  }
}
&lt;/script&gt;
&lt;style&gt;
.custom-full-screen {
  position: fixed !important;
  top: 0 !important;
  left: 0 !important;
  right: 0 !important;
  bottom: 0 !important;
  width: 100% !important;
  height: 100% !important;
}
&lt;/style&gt;</code></pre> 
<h5>万能弹出组件：<code>vue-popper</code></h5> 
<blockquote> 
 <p><code>ElementUI</code>中的大部分弹出层都是基于<code>vue-popper</code>组件来实现的。比如<code>select</code>、<code>data-picker</code>、<code>cascader</code>、<code>dropdown</code>、<code>popver</code>、<code>tooltip</code>等。</p> 
</blockquote> 
<p>如何使用<code>vue-popper</code></p> 
<p>通常来说，它的主要用法是<code>混入（mixins）</code>。</p> 
<blockquote> 
 <p>可以<a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FElemeFE%2Felement%2Fblob%2Fdev%2Fpackages%2Fselect%2Fsrc%2Fselect-dropdown.vue" rel="nofollow" title="参考">参考</a><code>ElementUI select-dropdown</code>中对它的具体使用。</p> 
</blockquote> 
<p> <strong>实战：完全自定义的弹出层</strong></p> 
<ol><li> <p>引入<code>vue-popper</code>，在模板中引入该组件，并定义一个弹出层元素，一个定位元素。</p> </li></ol> 
<pre><code class="language-javascript">&lt;template&gt;
  &lt;!-- 定位元素 --&gt;
  &lt;div class="custom-picker"&gt;
    &lt;!-- vue-popper组件 --&gt;
    &lt;Popper ref="popper" v-model="showPopper"&gt;&lt;/Popper&gt;
    &lt;!-- 弹出组件 --&gt;
    &lt;div ref="fly-piece" v-show="showPopper" class="custom-picker__popper"&gt;弹出内容&lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
// 引入vue-popper组件
import Popper from 'element-ui/src/utils/vue-popper';
​
export default {
  components: {
    Popper
  },
  data() {
    return {
      // 双向绑定，控制弹出层是否弹出
      showPopper: false
    },
  },
}
&lt;/script&gt;
</code></pre> 
<p>2.给<code>vue-popper</code>实例指定<strong>弹出层</strong>和<strong>定位层</strong>。</p> 
<pre><code class="language-javascript">mounted() {
  this.$refs.popper.popperElm = this.$refs['fly-piece'];
  this.$refs.popper.referenceElm = this.$el;
}</code></pre> 
<p>3.通过控制<code>vue-popper</code>的<code>props.value</code>来控制是否弹出。</p> 
<pre><code class="language-javascript">this.showPopper = !this.showPopper</code></pre> 
<h5><code>ClickOutside</code></h5> 
<blockquote> 
 <p><code>ClickOutside</code>是<code>ElementUI</code>实现的一个自定义指令，顾名思义，就是点击元素外面才会触发的事件。<code>ElementUI</code>中的<code>select</code>、<code>dropdown</code>、<code>popver</code>等组件都用到该指令。</p> 
</blockquote> 
<pre><code class="language-javascript">&lt;template&gt;
    &lt;div v-clickoutside="handleClose" v-show="flag"&gt;&lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import Clickoutside from "element-ui/src/utils/clickoutside"
export default{
    data(){
        return {
            flag: true
        }
    },
    directives: { Clickoutside },
    methods: {
        handleClose(){
            this.flag = false;
        }
    }
}    
&lt;/script&gt;</code></pre> 
<p> 通过掌握这些高级技巧和窍门，你可以更好地定制和优化<code>ElementUI</code>应用程序，提供更出色的用户体验和更灵活的界面交互。还有没有发现<code>ElementUI</code>中更好玩的内容，发出来大家学习学习。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9ff29e83d521ddd26487c39917c66de6/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">复制粘贴——QT实现原理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/07cc04cc782cca397bc885a656199bfe/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">CTF学习笔记——ret2text</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>