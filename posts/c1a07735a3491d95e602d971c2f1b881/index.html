<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>手撕Spring源码解析Bean的生命周期 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="手撕Spring源码解析Bean的生命周期" />
<meta property="og:description" content="这里我们主要分析生命周期从以下方法进入:
bean的实例化（开辟内存空间）-》bean的属性填充-》bean的初始化;
SpringBean的加载肯定是找到Bean的定义信息，来源有xml、yml等文件；
调用如下入口方法，加载配置文件进入源码解析；
先缕清大体脉络，后深入；
入口：
ClassPathXmlApplicationContext()创建spring以用程序上下文, 调用构造方法，设置配置文件路径到当前应用程序中，开始进入容器的创建和刷新环节 refresh(); AbstractApplicationContext()的refresh(); bean的生命周期从创建到销毁共12个流程方法，总体流程脉络如下：
// 刷新spring容器前的准备，例如清空缓存 prepareRefresh(); // 获取一个全新的工厂bean ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 设置一些bean工厂的属性 lijiaqi prepareBeanFactory(beanFactory); // 注册bean的增强器 postProcessBeanFactory(beanFactory); // 调用上面注册的bean工厂的增强器（bean工厂） invokeBeanFactoryPostProcessors(beanFactory); // 注册所有的 Bean 后处理器（bean） registerBeanPostProcessors(beanFactory); // 用于初始化消息源 ！ initMessageSource(); // 用于初始化事件多播器！ initApplicationEventMulticaster(); // 模板方法模式，用于执行特定方法 onRefresh(); // 注册所有的监听器 registerListeners(); // 完成非惰性单例的实例化 finishBeanFactoryInitialization(beanFactory); // 发布相应的事件 finishRefresh(); bean的实例化主要方法（spring最易懂，只有do开头才是干事的方法）
记住下面流程的方法顺序我们在源码中找出来
getBean()-&gt;doGetBean()-&gt;createBean()-&gt;doCreateBean()-&gt;createBeanInstance()-&gt;instantiateBean()-&gt;instantiate()-&gt;BeanUtils.instantiateClass(constructorToUse)-&gt;ctor.newInstance(argsWithDefaultValues)-&gt;T inst = (T) ca.newInstance(initargs);
开始深入实例化方法的解析：
进入之后主要看最后的方法往里进，需要看两个地方
// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c1a07735a3491d95e602d971c2f1b881/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-26T09:56:03+08:00" />
<meta property="article:modified_time" content="2023-09-26T09:56:03+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">手撕Spring源码解析Bean的生命周期</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>这里我们主要分析生命周期从以下方法进入:<br> bean的实例化（开辟内存空间）-》bean的属性填充-》bean的初始化;<br> SpringBean的加载肯定是找到Bean的定义信息，来源有xml、yml等文件；<br> 调用如下入口方法，加载配置文件进入源码解析；<br> 先缕清大体脉络，后深入；<br> 入口</strong>：</p> 
<pre>ClassPathXmlApplicationContext()创建spring以用程序上下文,
调用构造方法，设置配置文件路径到当前应用程序中，开始进入容器的创建和刷新环节 <strong>refresh();</strong>
AbstractApplicationContext()的<strong>refresh();</strong></pre> 
<p><strong>bean的生命周期从创建到销毁共12个流程方法，总体流程脉络如下：</strong></p> 
<pre>// 刷新spring容器前的准备，例如清空缓存
prepareRefresh();</pre> 
<pre>// 获取一个全新的工厂bean
ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</pre> 
<pre>// 设置一些bean工厂的属性 lijiaqi
prepareBeanFactory(beanFactory);</pre> 
<pre>// 注册bean的增强器
postProcessBeanFactory(beanFactory);

// 调用上面注册的bean工厂的增强器（bean工厂）
invokeBeanFactoryPostProcessors(beanFactory);

// 注册所有的 Bean 后处理器（bean）
registerBeanPostProcessors(beanFactory);

// 用于初始化消息源 ！
initMessageSource();

// 用于初始化事件多播器！
initApplicationEventMulticaster();

// 模板方法模式，用于执行特定方法
onRefresh();

// 注册所有的监听器
registerListeners();

// 完成非惰性单例的实例化
finishBeanFactoryInitialization(beanFactory);

// 发布相应的事件
finishRefresh();
</pre> 
<p><strong>bean的实例化主要方法（spring最易懂，只有do开头才是干事的方法）<br> 记住下面流程的方法顺序我们在源码中找出来</strong><br><br> getBean()-&gt;doGetBean()-&gt;createBean()-&gt;doCreateBean()-&gt;createBeanInstance()-&gt;instantiateBean()-&gt;instantiate()-&gt;BeanUtils.instantiateClass(constructorToUse)-&gt;ctor.newInstance(argsWithDefaultValues)-&gt;T inst = (T) ca.newInstance(initargs);<br>  </p> 
<p><strong>开始深入实例化方法的解析：</strong><br><img alt="" height="108" src="https://images2.imgbox.com/66/94/9zhPp0qJ_o.png" width="576"></p> 
<p>进入之后主要看最后的方法往里进，需要看两个地方<br><img alt="" height="824" src="https://images2.imgbox.com/ee/08/NGxpo0yY_o.png" width="1200"></p> 
<pre>// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
// 从容器中获取了所有实现了LoadTimeWeaverAware接口的bean名称（需要增强的bean实现的接口）
// 初始化这些bean，这些bean收到通知注册各自的类和相关切入点
String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
for (String weaverAwareName : weaverAwareNames) {
    getBean(weaverAwareName);
}
</pre> 
<pre>// 实例化所有剩余（非惰性初始化）单例。
beanFactory.preInstantiateSingletons();
进入看到我们的<strong>getBean()
</strong>

<strong>工厂bean和普通单例bean走不同的getBean()</strong>
<strong>进去看见我们的doGetBean()</strong>
</pre> 
<p> 经过一系列判断看到我们的<strong>createBean()</strong>,创建bean的实例对象<br> 这里强调一下</p> 
<pre>sharedInstance = getSingleton(beanName, () -&gt; {
    try {
       //入口
       return createBean(beanName, mbd, args);
    }</pre> 
<p>传入的是一个lambda表达式，在接收的参数对象调用其唯一抽象方法时调用；<br> 在解释一下mbd，是RootBeanDefinition类型的，<strong>MBD（MergedBeanDefinition）</strong>表示合并后的BeanDefinition。在Spring容器中，一个bean可以有一个或多个BeanDefinition，例如，在多个配置文件或注解中定义同一个bean。在这种情况下，Spring容器需要合并这些BeanDefinition以创建一个统一的BeanDefinition，这就是MBD的作用。<br><img alt="" height="404" src="https://images2.imgbox.com/01/8f/ePv3KzHN_o.png" width="1112"></p> 
<p><strong> 之后就是我们的doCreateBean()；</strong><br><img alt="" height="409" src="https://images2.imgbox.com/32/8b/7t5Kjoaf_o.png" width="1070"><br><img alt="" height="578" src="https://images2.imgbox.com/b0/8f/4lHrTGE6_o.png" width="1032"><br><strong>反射创建对象,</strong><br> instantiateBean(beanName,mbd)-&gt;使用其默认构造函数实例化给定的 Bean<br> -&gt;instantiate(mdb,beanName,beanFactory)-&gt;获取其构造器传入BeanUtils.instantiateClass(constructorToUse);<br><img alt="" height="883" src="https://images2.imgbox.com/30/f3/BmbSBXey_o.png" width="1029"><br><img alt="" height="550" src="https://images2.imgbox.com/68/2e/pYmaYdx5_o.png" width="1061"><br><img alt="" height="658" src="https://images2.imgbox.com/67/0d/l04RVVfZ_o.png" width="1008"><br><img alt="" height="518" src="https://images2.imgbox.com/b3/77/49GqEgXq_o.png" width="1105"></p> 
<p><strong> 一层层返回到拿到一个BeanWrapper</strong><br> BeanWrapper是Spring提供的一个用来操作JavaBean属性的工具类<br> 对合成后的MergedBeanDefinition进行一些后置处理<br><img alt="" height="295" src="https://images2.imgbox.com/0b/d0/dbc1BrZH_o.png" width="794"></p> 
<p><strong> 三级缓存在拿到实例化对象后</strong><br><img alt="" height="278" src="https://images2.imgbox.com/01/e8/x4vHJNmS_o.png" width="780"><br>  </p> 
<p><strong>填充属性</strong><br> populateBean(beanName, mbd, instanceWrapper);</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3e6afe6e1e21f1fe29bbf371f4423b48/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vue&#43;ElementUi实现点击表格中链接进行页面跳转和路由</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/1e9cdfd9fbd782f475b8a11321cbfed2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Flowable高级篇 -6.8.0 最全表结构说明-主要表结构字段注释</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>