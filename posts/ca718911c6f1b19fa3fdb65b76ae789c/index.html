<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>链路追踪详解（四）：分布式链路追踪的事实标准 OpenTelemetry 概述 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="链路追踪详解（四）：分布式链路追踪的事实标准 OpenTelemetry 概述" />
<meta property="og:description" content="目录
OpenTelemetry 是什么？
OpenTelemetry 的起源和目标
OpenTelemetry 主要特点和功能
OpenTelemetry 的核心组件
OpenTelemetry 的工作原理
OpenTelemetry 的特点
OpenTelemetry 的应用场景
小结
OpenTelemetry 是什么？ OpenTelemetry 是一个为实现可观测性的开源的框架和工具集，用于创建和管理遥测数据，例如 traces,、metrics 和 logs，旨在提供统一的解决方案来满足分布式系统的可观察性需求。OpenTelemetry 整合了 OpenCensus 和 OpenTracing 的功能，并扩展了更多的度量指标和追踪信息采集能力，使分布式系统的可观测性变得更加简单、可扩展和可互操作。OpenTelemetry 与提供可观测性产品的供应商无关，可以与各种各样的可观测性后端一起使用，包括像 Zipkin、Jaeger、Prometheus 等开源产品，以及其他商业产品。OpenTelemetry 也是是云原生计算基金会（CNCF）的一个托管项目。
OpenTelemetry 的起源和目标 随着云计算、微服务架构和日益复杂的业务需求的兴起，对可观测性的需求也越来越大，可观测性是通过检查分析系统的输出内容来了解其内部状态的能力。
最初，开发者使用日志来解决这个问题，但很快发现通过日志不能够清晰地看到一次请求是如何被处理和流转的。为了解决这些问题，Google 开发了 Dapper 布式系统追踪的框架，Dapper 的思想启发了很多公司和开源项目，如 OpenTracing 和 OpenCensus，它们提供了标准化的 API 和库，以帮助开发者在他们的应用中实现分布式链路追踪和指标收集。
然而，随着这两个项目的发展，社区意识到存在一些重叠和不一致的地方。因此，OpenTracing 和 OpenCensus 合并为 OpenTelemetry，以创建一个统一的、更强大的工具集，不仅包含了 traces 和 metrics，还包括了 logs。
在软件系统中，可以通过检查遥测数据（包括 traces,、metrics 和 logs）了解系统的内部状态。为了实现系统的可观测性，必须对系统进行检测。也就是说，代码需要能产生 traces、metrics 和 logs，并将这些数据发送到可观测性后端。
OpenTelemetry 主要特点和功能 统一的观察性标准：OpenTelemetry 提供了一套统一的观测性标准，使得不同厂商和工具之间的数据可以相互兼容和共享，有助于减少开发和运维人员在系统集成方面的成本和难度。丰富的度量指标和追踪信息：OpenTelemetry 支持采集丰富的度量指标和追踪信息，包括跟踪数据（traces）、指标数据（metrics）、日志数据（logs）。这些数据可以用于分析系统的性能、行为和问题，帮助开发人员更好地了解系统运行状况。灵活的数据采集和导出：OpenTelemetry 支持多种数据采集和导出的方式，包括直接从应用程序中采集数据、从日志文件中导入数据、或者通过代理（agent）从远程系统中采集数据。还提供了对常见数据格式和协议的支持，如 Prometheus、Zipkin、Jaeger 等。可扩展的插件式架构：OpenTelemetry 采用插件式架构，允许用户根据需要定制和扩展其功能。开发者可以通过编写插件来支持新的数据格式、导出工具或传输协议。这种可扩展性使得 OpenTelemetry 能够适应不同的使用场景和需求。开源社区和生态系统：OpenTelemetry 是一个开源项目，拥有活跃的社区和生态系统。开发者可以参与开源项目的开发、贡献代码、解决问题、讨论使用经验等。此外，OpenTelemetry 还提供了丰富的文档、教程和示例，帮助用户快速上手和使用。 OpenTelemetry 的核心组件 OpenTelemetry 主要由以下几个核心组件构成：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ca718911c6f1b19fa3fdb65b76ae789c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-12-13T22:16:53+08:00" />
<meta property="article:modified_time" content="2023-12-13T22:16:53+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">链路追踪详解（四）：分布式链路追踪的事实标准 OpenTelemetry 概述</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="OpenTelemetry%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-toc" style="margin-left:0px;"><a href="#OpenTelemetry%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F" rel="nofollow">OpenTelemetry 是什么？</a></p> 
<p id="OpenTelemetry%20%E7%9A%84%E8%B5%B7%E6%BA%90%E5%92%8C%E7%9B%AE%E6%A0%87-toc" style="margin-left:0px;"><a href="#OpenTelemetry%20%E7%9A%84%E8%B5%B7%E6%BA%90%E5%92%8C%E7%9B%AE%E6%A0%87" rel="nofollow">OpenTelemetry 的起源和目标</a></p> 
<p id="OpenTelemetry%20%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9%E5%92%8C%E5%8A%9F%E8%83%BD-toc" style="margin-left:0px;"><a href="#OpenTelemetry%20%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9%E5%92%8C%E5%8A%9F%E8%83%BD" rel="nofollow">OpenTelemetry 主要特点和功能</a></p> 
<p id="OpenTelemetry%20%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6-toc" style="margin-left:0px;"><a href="#OpenTelemetry%20%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6" rel="nofollow">OpenTelemetry 的核心组件</a></p> 
<p id="OpenTelemetry%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86-toc" style="margin-left:0px;"><a href="#OpenTelemetry%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86" rel="nofollow">OpenTelemetry 的工作原理</a></p> 
<p id="OpenTelemetry%20%E7%9A%84%E7%89%B9%E7%82%B9-toc" style="margin-left:0px;"><a href="#OpenTelemetry%20%E7%9A%84%E7%89%B9%E7%82%B9" rel="nofollow">OpenTelemetry 的特点</a></p> 
<p id="OpenTelemetry%20%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:0px;"><a href="#OpenTelemetry%20%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">OpenTelemetry 的应用场景</a></p> 
<p id="%E5%B0%8F%E7%BB%93-toc" style="margin-left:0px;"><a href="#%E5%B0%8F%E7%BB%93" rel="nofollow">小结</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="OpenTelemetry%20%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F">OpenTelemetry 是什么？</h2> 
<p>OpenTelemetry 是一个为实现可观测性的开源的框架和工具集，用于创建和管理遥测数据，例如 traces,、metrics 和 logs，旨在提供统一的解决方案来满足分布式系统的可观察性需求。OpenTelemetry 整合了 OpenCensus 和 OpenTracing 的功能，并扩展了更多的度量指标和追踪信息采集能力，使分布式系统的可观测性变得更加简单、可扩展和可互操作。OpenTelemetry 与提供可观测性产品的供应商无关，可以与各种各样的可观测性后端一起使用，包括像 Zipkin、Jaeger、Prometheus 等开源产品，以及其他商业产品。OpenTelemetry 也是是云原生计算基金会（CNCF）的一个托管项目。</p> 
<h2 id="OpenTelemetry%20%E7%9A%84%E8%B5%B7%E6%BA%90%E5%92%8C%E7%9B%AE%E6%A0%87">OpenTelemetry 的起源和目标</h2> 
<p>随着云计算、微服务架构和日益复杂的业务需求的兴起，对可观测性的需求也越来越大，可观测性是通过检查分析系统的输出内容来了解其内部状态的能力。</p> 
<p>最初，开发者使用日志来解决这个问题，但很快发现通过日志不能够清晰地看到一次请求是如何被处理和流转的。为了解决这些问题，Google 开发了 Dapper 布式系统追踪的框架，Dapper 的思想启发了很多公司和开源项目，如 OpenTracing 和 OpenCensus，它们提供了标准化的 API 和库，以帮助开发者在他们的应用中实现分布式链路追踪和指标收集。</p> 
<p>然而，随着这两个项目的发展，社区意识到存在一些重叠和不一致的地方。因此，OpenTracing 和 OpenCensus 合并为 OpenTelemetry，以创建一个统一的、更强大的工具集，不仅包含了 traces 和 metrics，还包括了 logs。</p> 
<p>在软件系统中，可以通过检查遥测数据（包括 traces,、metrics 和 logs）了解系统的内部状态。为了实现系统的可观测性，必须对系统进行检测。也就是说，代码需要能产生 traces、metrics 和 logs，并将这些数据发送到可观测性后端。</p> 
<h2 id="OpenTelemetry%20%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9%E5%92%8C%E5%8A%9F%E8%83%BD">OpenTelemetry 主要特点和功能</h2> 
<ol><li>统一的观察性标准：OpenTelemetry 提供了一套统一的观测性标准，使得不同厂商和工具之间的数据可以相互兼容和共享，有助于减少开发和运维人员在系统集成方面的成本和难度。</li><li>丰富的度量指标和追踪信息：OpenTelemetry 支持采集丰富的度量指标和追踪信息，包括跟踪数据（traces）、指标数据（metrics）、日志数据（logs）。这些数据可以用于分析系统的性能、行为和问题，帮助开发人员更好地了解系统运行状况。</li><li>灵活的数据采集和导出：OpenTelemetry 支持多种数据采集和导出的方式，包括直接从应用程序中采集数据、从日志文件中导入数据、或者通过代理（agent）从远程系统中采集数据。还提供了对常见数据格式和协议的支持，如 Prometheus、Zipkin、Jaeger 等。</li><li>可扩展的插件式架构：OpenTelemetry 采用插件式架构，允许用户根据需要定制和扩展其功能。开发者可以通过编写插件来支持新的数据格式、导出工具或传输协议。这种可扩展性使得 OpenTelemetry 能够适应不同的使用场景和需求。</li><li>开源社区和生态系统：OpenTelemetry 是一个开源项目，拥有活跃的社区和生态系统。开发者可以参与开源项目的开发、贡献代码、解决问题、讨论使用经验等。此外，OpenTelemetry 还提供了丰富的文档、教程和示例，帮助用户快速上手和使用。</li></ol> 
<h2 id="OpenTelemetry%20%E7%9A%84%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6">OpenTelemetry 的核心组件</h2> 
<p>OpenTelemetry 主要由以下几个核心组件构成：</p> 
<ul><li>API：定义了收集遥测数据的接口，使开发者能够编写可插拔的代码，以便在不同的遥测系统之间切换，而无需更改应用程序的主体代码。</li><li>SDK：是对 API 的实现，用来实现对遥测数据的收集、处理和导出。SDK 通常是可配置的，允许开发者调整数据收集的粒度和性能影响。</li><li>Instrumentation Libraries：这些库提供了对常见框架和库的自动插桩支持，以便开发者无需手动编写大量的遥测代码。</li><li>Collector：是一个独立的服务，可以接收、处理和导出遥测数据。可以部署为代理或作为后端服务的一部分，以接收来自应用程序的遥测数据。</li><li>Exporters：借助不同的 Exporter 可以使 SDK 或 Collector 将遥测数据导出到各种后端系统，如 Prometheus、Jaeger、Zipkin 等。</li></ul> 
<h2 id="OpenTelemetry%20%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">OpenTelemetry 的工作原理</h2> 
<p>OpenTelemetry 的工作原理可以分为以下几个步骤：</p> 
<ol><li>自动插桩：开发者通过将 OpenTelemetry 的 Instrumentation Libraries 集成到自己的应用程序中，自动地在代码的关键路径上收集遥测数据。</li><li>数据收集与处理：借助 Instrumentation Libraries 收集到相应数据后，通过 SDK 进行进一步的处理，如聚合、过滤和批处理，以优化性能和数据传输。</li><li>数据导出：处理后的数据通过 Exporters 发送到指定的后端系统，可以是专门的链路追踪系统、时序数据库或者日志系统。</li></ol> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/72/0e/q0YpJ3F9_o.png"></p> 
<h2 id="OpenTelemetry%20%E7%9A%84%E7%89%B9%E7%82%B9">OpenTelemetry 的特点</h2> 
<p>OpenTelemetry 的设计考虑了现代应用的需求：</p> 
<ul><li>开源和跨语言：支持多种编程语言和框架，适用于多样化的开发环境。</li><li>可扩展性：通过 Exporters 和自定义 SDK 配置，可以轻松地适配不同的后端系统。</li><li>端到端追踪：提供了在复杂的分布式系统中跟踪请求的能力，对于微服务架构来说也非常实用。</li><li>性能考量：SDK 提供了数据采样和处理的功能，将对应用性能的影响降到最低。</li></ul> 
<h2 id="OpenTelemetry%20%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">OpenTelemetry 的应用场景</h2> 
<p>OpenTelemetry 可以应用于多种场景，包括但不限于：</p> 
<ul><li>微服务监控：在微服务架构中，可以使用 OpenTelemetry 来跟踪跨服务的请求，并收集服务的性能指标。</li><li>云原生应用：为 Kubernetes 和其他云原生技术提供了强大的监控和追踪能力。</li><li>故障排查：当出现性能下降或请求错误时，OpenTelemetry 可以帮助快速定位问题。</li></ul> 
<h2 id="%E5%B0%8F%E7%BB%93">小结</h2> 
<p>OpenTelemetry 代表了分布式链路追踪和监控的未来方向，目标是简化和统一遥测数据的收集和管理，随着社区的不断发展和技术的成熟，OpenTelemetry 无疑将在现代软件开发和运维中发挥越来越重要的作用。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/70c5aad10c8327914517db29943992b3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">3D三维数据格式分类（种类/软件平台）</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/43a3bc15ddbde6e34d328e92fedf2890/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Faster RCNN训练自己的数据集【傻瓜式教程】</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>