<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>CTF-记一次PWN练习 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="CTF-记一次PWN练习" />
<meta property="og:description" content="PWN是一个黑客语法的俚语词，自&#34;own&#34;这个字引申出来的，这个词的含意在于，玩家在整个游戏对战中处在胜利的优势，或是说明竞争对手处在完全惨败的情形下，这个词习惯上在网络游戏文化主要用于嘲笑竞争对手在整个游戏对战中已经完全被击败（例如：“You
just got pwned!”）。有一个非常著名的国际赛事叫做Pwn2Own，即通过打败对手来达到拥有的目的。
在CTF中PWN题型通常会直接给定一个已经编译好的二进制程序（Windows下的EXE或者Linux下的ELF文件等），然后参赛选手通过对二进制程序进行逆向分析和调试来找到利用漏洞，并编写利用代码，通过远程代码执行来达到溢出攻击的效果，最终拿到目标机器的shell夺取flag。
又到了介绍工具的时候了！首先了解一下gdb。
gdb是Linux下常用的一款命令行调试器，拥有十分强大的调试功能。本实验中需要用到的gdb命令如下：
这个工具类似逆向里面的IDA这类的神器。
除了工具还需要知道一些简单的汇编基础，读懂常见的汇编指令是CTF竞赛中PWN解题的基本要求，本实验中需要理解的汇编指令如下：
汇编语言中，esp寄存器用于指示当前函数栈帧的栈顶的位置，函数中局部变量都存储在栈空间中，栈的生长方向是向下的（即从高地址往低地址方向生长）。
缓冲区溢出是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量，使得溢出的数据覆盖在合法数据上，理想的情况是程序检查数据长度并不允许输入超过缓冲区长度的字符，但是绝大多数程序都会假设数据长度总是与所分配的储存空间相匹配，这就为缓冲区溢出埋下隐患。
本文涉及知识点实操练习：
[《CTFPWN练习》](https://www.hetianlab.com/expc.do?ec=ECID172.19.104.182014103116591300001&amp;pk_campaign=freebuf-
wemedia)（PWN是CTF竞赛中的主要题型之一，主要考查参赛选手的逆向分析、漏洞挖掘以及Exploit编写能力。CTF-
PWN系列实验以最常见的栈溢出为主线，通过由浅入深的方式，一步一步讲解栈溢出攻击原理与实践，同时详细介绍了Linux下GDB调试器的基本使用方法。）。
先看题目描述，跟看web源码一样重要，主机/home/test/1目录下有一个pwn1程序，执行这个程序的时候可以输入数据进行测试，pwn1程序会输出Please
try again.的提示信息，请对pwn1程序进行逆向分析和调试，找到程序内部的漏洞，并构造特殊的输入数据，使之输出Congratulations,
you pwned it.信息。
首先第一步源码审计在实际的CTF竞赛的PWN题目中，一般是不会提供二进制程序的源代码的。这里为了方便大家学习，给出二进制程序的C语言源代码供大家分析，以源码审计的方式确定漏洞所在位置，方便后续进行汇编级别的分析。
（在没有源代码的情况下，我们通常使用IDA Pro对二进制程序进行逆向分析，使用IDA的Hex-
Rays插件可以将反汇编代码还原为C语言伪代码，可以达到类似源代码的可读效果，在后期的实验中会专门对IDA的使用进行讲解）
使用cd /home/test/1切换到程序所在目录，执行cat pwn1.c即可看到源代码：
``#include &lt;stdio.h&gt;int main(int argc, char argv){int modified;char buffer[64];modified = 0;gets(buffer); // 引发缓冲区溢出if (modified != 0){printf(“Congratulations, you pwned it.\n”);}else{printf(“Please try again.\n”);}return 0;}
我们看这里使用gets函数读取输入数据时，并不会对buffer缓冲区的长度进行检查，输入超长的输入数据时会引发缓冲区溢出。 漏洞找到了，我们来看利用过程执行gdb pwn1即可开始通过gdb对pwn1进行调试，现在我们需要阅读main函数的汇编代码，在gdb中执行disas main命令即可： ![图片3.png](https://img-blog.csdnimg.cn/img_convert/1464da519212f5d1df248cf6cfc9d1e2.jpeg) 下面是对main函数中的汇编代码的解释： ``0x080482a0 &lt;&#43;0&gt;: push %ebp0x080482a1 &lt;&#43;1&gt;: mov %esp,%\ebp0x080482a3 &lt;&#43;3&gt;: and $0xfffffff0,%\esp; esp = esp - 0x60，即在栈上分配0x60）字节的空间0x080482a6 &lt;&#43;6&gt;: sub $0x60,%\esp; modified变量位于esp &#43; 0x5C处，将其初始化为00x080482a9 &lt;&#43;9&gt;: movl $0x0,0x5c(%\esp); buffer位于esp &#43; 0x1C处0x080482b1 &lt;&#43;17&gt;: lea 0x1c(%\esp),%eax0x080482b5 &lt;&#43;21&gt;: mov %eax,(%\esp); 调用gets(buffer)读取输入数据0x080482b8 &lt;&#43;24&gt;: call 0x8049360 &lt;gets&gt;; 判断modified变量的值是否是00x080482bd &lt;&#43;29&gt;: cmpl $0x0,0x5c(%\esp); 如果modified的值等于0，就跳转到 0x080482d20x080482c2 &lt;&#43;34&gt;: je 0x80482d2 &lt;main&#43;50&gt;; modified不为0，打印成功提示0x080482c4 &lt;&#43;36&gt;: movl $0x80b3eec,(%\esp)0x080482cb &lt;&#43;43&gt;: call 0x8049500 &lt;puts&gt;0x080482d0 &lt;&#43;48&gt;: jmp 0x80482de &lt;main&#43;62&gt;; modified为0，打印失败提示0x080482d2 &lt;&#43;50&gt;: movl $0x80b3f0b,(%\esp)0x080482d9 &lt;&#43;57&gt;: call 0x8049500 &lt;puts&gt;0x080482de &lt;&#43;62&gt;: mov $0x0,%\eax0x080482e3 &lt;&#43;67&gt;: leave0x080482e4 &lt;&#43;68&gt;: ret`` `` 通过对上面的汇编代码进行分析，我们知道buffer位于esp&#43;0x1C处，而modified位于esp&#43;0x5C处，两个地址的距离为0x5C - 0x1C = 0x40，即64，刚好为buffer数组的大小。因此当我们输入的数据超过64字节时，modified变量就可以被覆盖。 下面在gdb中进行验证，在gdb中执行b 0x080482bd命令对gets的下一条指令下一个断点： !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d0a3e843fac6d72a9a47f8ecae69fc2d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-10T22:17:13+08:00" />
<meta property="article:modified_time" content="2023-08-10T22:17:13+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">CTF-记一次PWN练习</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>PWN是一个黑客语法的俚语词，自"own"这个字引申出来的，这个词的含意在于，玩家在整个游戏对战中处在胜利的优势，或是说明竞争对手处在完全惨败的情形下，这个词习惯上在网络游戏文化主要用于嘲笑竞争对手在整个游戏对战中已经完全被击败（例如：“You<br> just got pwned!”）。有一个非常著名的国际赛事叫做Pwn2Own，即通过打败对手来达到拥有的目的。</p> 
<p>在CTF中PWN题型通常会直接给定一个已经编译好的二进制程序（Windows下的EXE或者Linux下的ELF文件等），然后参赛选手通过对二进制程序进行逆向分析和调试来找到利用漏洞，并编写利用代码，通过远程代码执行来达到溢出攻击的效果，最终拿到目标机器的shell夺取flag。</p> 
<p>又到了介绍工具的时候了！首先了解一下gdb。</p> 
<p>gdb是Linux下常用的一款命令行调试器，拥有十分强大的调试功能。本实验中需要用到的gdb命令如下：</p> 
<p><img src="https://images2.imgbox.com/8b/cb/sevIOFbF_o.jpg" alt="图片1.png"></p> 
<p>这个工具类似逆向里面的IDA这类的神器。</p> 
<p>除了工具还需要知道一些简单的汇编基础，读懂常见的汇编指令是CTF竞赛中PWN解题的基本要求，本实验中需要理解的汇编指令如下：</p> 
<p><img src="https://images2.imgbox.com/2b/3d/J6Zu117n_o.jpg" alt="图片2.png"></p> 
<p>汇编语言中，esp寄存器用于指示当前函数栈帧的栈顶的位置，函数中局部变量都存储在栈空间中，栈的生长方向是向下的（即从高地址往低地址方向生长）。</p> 
<p>缓冲区溢出是指当计算机向缓冲区内填充数据位数时超过了缓冲区本身的容量，使得溢出的数据覆盖在合法数据上，理想的情况是程序检查数据长度并不允许输入超过缓冲区长度的字符，但是绝大多数程序都会假设数据长度总是与所分配的储存空间相匹配，这就为缓冲区溢出埋下隐患。</p> 
<p>本文涉及知识点实操练习：<br> [《CTFPWN练习》](https://www.hetianlab.com/expc.do?ec=ECID172.19.104.182014103116591300001&amp;pk_campaign=freebuf-<br> wemedia)（PWN是CTF竞赛中的主要题型之一，主要考查参赛选手的逆向分析、漏洞挖掘以及Exploit编写能力。CTF-<br> PWN系列实验以最常见的栈溢出为主线，通过由浅入深的方式，一步一步讲解栈溢出攻击原理与实践，同时详细介绍了Linux下GDB调试器的基本使用方法。）。</p> 
<p>先看题目描述，跟看web源码一样重要，主机/home/test/1目录下有一个pwn1程序，执行这个程序的时候可以输入数据进行测试，pwn1程序会输出Please<br> try again.的提示信息，请对pwn1程序进行逆向分析和调试，找到程序内部的漏洞，并构造特殊的输入数据，使之输出Congratulations,<br> you pwned it.信息。</p> 
<p>首先第一步源码审计在实际的CTF竞赛的PWN题目中，一般是不会提供二进制程序的源代码的。这里为了方便大家学习，给出二进制程序的C语言源代码供大家分析，以源码审计的方式确定漏洞所在位置，方便后续进行汇编级别的分析。</p> 
<p>（在没有源代码的情况下，我们通常使用IDA Pro对二进制程序进行逆向分析，使用IDA的Hex-<br> Rays插件可以将反汇编代码还原为C语言伪代码，可以达到类似源代码的可读效果，在后期的实验中会专门对IDA的使用进行讲解）</p> 
<p>使用cd /home/test/1切换到程序所在目录，执行cat pwn1.c即可看到源代码：</p> 
<p>``#include &lt;stdio.h&gt;int main(int argc, char argv){int modified;char buffer[64];modified = 0;gets(buffer); // 引发缓冲区溢出if (modified != 0){printf(“Congratulations, you pwned it.\n”);}else{printf(“Please try again.\n”);}return 0;}</p> 
<pre><code>
我们看这里使用gets函数读取输入数据时，并不会对buffer缓冲区的长度进行检查，输入超长的输入数据时会引发缓冲区溢出。

漏洞找到了，我们来看利用过程执行gdb pwn1即可开始通过gdb对pwn1进行调试，现在我们需要阅读main函数的汇编代码，在gdb中执行disas
main命令即可：

![图片3.png](https://img-blog.csdnimg.cn/img_convert/1464da519212f5d1df248cf6cfc9d1e2.jpeg)

下面是对main函数中的汇编代码的解释：

``0x080482a0 &lt;+0&gt;: push %ebp0x080482a1 &lt;+1&gt;: mov %esp,%\ebp0x080482a3 &lt;+3&gt;: and $0xfffffff0,%\esp; esp = esp - 0x60，即在栈上分配0x60）字节的空间0x080482a6 &lt;+6&gt;: sub $0x60,%\esp; modified变量位于esp + 0x5C处，将其初始化为00x080482a9 &lt;+9&gt;: movl $0x0,0x5c(%\esp); buffer位于esp + 0x1C处0x080482b1 &lt;+17&gt;: lea 0x1c(%\esp),%eax0x080482b5 &lt;+21&gt;: mov %eax,(%\esp); 调用gets(buffer)读取输入数据0x080482b8 &lt;+24&gt;: call 0x8049360 &lt;gets&gt;; 判断modified变量的值是否是00x080482bd &lt;+29&gt;: cmpl $0x0,0x5c(%\esp); 如果modified的值等于0，就跳转到 0x080482d20x080482c2 &lt;+34&gt;: je 0x80482d2 &lt;main+50&gt;; modified不为0，打印成功提示0x080482c4 &lt;+36&gt;: movl $0x80b3eec,(%\esp)0x080482cb &lt;+43&gt;: call 0x8049500 &lt;puts&gt;0x080482d0 &lt;+48&gt;: jmp 0x80482de &lt;main+62&gt;; modified为0，打印失败提示0x080482d2 &lt;+50&gt;: movl $0x80b3f0b,(%\esp)0x080482d9 &lt;+57&gt;: call 0x8049500 &lt;puts&gt;0x080482de &lt;+62&gt;: mov $0x0,%\eax0x080482e3 &lt;+67&gt;: leave0x080482e4 &lt;+68&gt;: ret``

``

通过对上面的汇编代码进行分析，我们知道buffer位于esp+0x1C处，而modified位于esp+0x5C处，两个地址的距离为0x5C - 0x1C
= 0x40，即64，刚好为buffer数组的大小。因此当我们输入的数据超过64字节时，modified变量就可以被覆盖。

下面在gdb中进行验证，在gdb中执行b 0x080482bd命令对gets的下一条指令下一个断点：

![图片4.png](https://img-blog.csdnimg.cn/img_convert/5c2e416ee24ad101ad43f4b8a5d667ab.jpeg)

在gdb中执行r命令，让被调试的pwn1程序跑起来，就可以输入数据进行测试了，这里我们输入64个A以及1个B（即AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB），按下Enter键程序就在断点处断下了：

![图片5.png](https://img-blog.csdnimg.cn/img_convert/50de82877931ab5c62e8c5ada2307ef9.jpeg)

在gdb中输入x
$esp+0x5C，查看modified变量的值已经被修改成了0x00000042，而0x42就是字符’B’的ASCII值，表明我们成功用输入数据的第65个字节覆盖了modified变量：

![image](https://img-blog.csdnimg.cn/img_convert/fe9d5f89bf1d99015e1301d0a409eb0e.jpeg)

在gdb中连续两次执行ni命令，可以看到je指令没有跳转，说明modified的值不为0，程序进入输出通过信息的if语句分支：

![图片7.png](https://img-blog.csdnimg.cn/img_convert/b40d70bdafeba39f4316d3cff0f7cfae.jpeg)

在gdb中输入c命令就可以让程序继续执行，看到输出了通过提示信息：

![图片8.png](https://img-blog.csdnimg.cn/img_convert/72d8bdadfbf70233878f65946014bab5.jpeg)

通过上面的步骤我们已经知道了如果控制输入数据来进行攻击，以达到进入if语句分支的目的。下面我们就可以通过构造输入数据进行攻击了。

如果你还没有退出gdb，输入q命令就可以退出gdb。下面通过python语句构造输入数据，然后通过管道传给pwn1程序，执行命令python -c
"print 'A'64+'B'" | ./pwn1

![图片9.png](https://img-blog.csdnimg.cn/img_convert/613f81ca7a57643e4871768cc591d9a9.jpeg)

看到已经成功发起了溢出攻击，程序被你PWN掉啦！

B'" | ./pwn1

[外链图片转存中...(img-oUak6lkK-1691677019926)]

看到已经成功发起了溢出攻击，程序被你PWN掉啦！


## 最后
对于从来没有接触过网络安全的同学，我们帮你准备了详细的学习成长路线图。可以说是最科学最系统的学习路线，大家跟着这个大的方向学习准没问题。  
![](https://img-blog.csdnimg.cn/9663e318367645b8bf9d8c9858f43905.png#pic_center)
同时每个成长路线对应的板块都有配套的视频提供：
![](https://img-blog.csdnimg.cn/95c51a2db203495cacd852a94dbe0814.png)
![](https://img-blog.csdnimg.cn/c62dc5cb223b4472b26ab6661feac302.png)
当然除了有配套的视频，同时也为大家整理了各种文档和书籍资料&amp;工具，并且已经帮大家分好类了。  
![](https://img-blog.csdnimg.cn/69ab0c080ea94332b51bd55d6afec28f.png)
**因篇幅有限，仅展示部分资料，有需要的小伙伴，可以【点下方卡片】免费领取：**
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/38f390ce9a5e18e1bc378d6a1f4e406c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python基础02_print()函数和简单的数据操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/67d0d3c939e919bb96e2f312bdb6a2b4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java知识点--常用类--String</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>