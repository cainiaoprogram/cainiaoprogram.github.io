<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>完整的学习C&#43;&#43;的读书路线图 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="完整的学习C&#43;&#43;的读书路线图" />
<meta property="og:description" content="/*推荐给想学C&#43;&#43;的朋友一个简单但是完整的学习C&#43;&#43;的读书路线图：
C&#43;&#43; Primer-&gt; c&#43;&#43;标准程序库-&gt; effective C&#43;&#43;-&gt; effective STL-&gt;深入探索C&#43;&#43;对象模型
C程序常用算法源码
算法（Algorithm）：计算机解题的基本思想方法和步骤。算法的描述：是对要解决一个问题或要完成一项任务所采取的方法和步骤的描述，包括需要什么数据（输入什么数据、输出什么结果）、采用什么结构、使用什么语句以及如何安排这些语句等。
通常使用自然语言、结构化流程图、伪代码等来描述算法。
一、计数、求和、求阶乘等简单算法
此类问题都要使用循环，要注意根据问题确定循环变量的初值、终值或结束条件，更要注意用来表示计数、和、阶乘的变量的初值。
例：用随机函数产生100个[0，99]范围内的随机整数，统计个位上的数字分别为1，2，3，4，5，6，7，8，9，0的数的个数并打印出来。
本题使用数组来处理，用数组a[100]存放产生的确100个随机整数，数组x[10]来存放个位上的数字分别为 1，2，3，4，5，6，7，8，9，0的数的个数。
即个位是1的个数存放在x[1]中，个位是2的个数存放在x[2]中，……个位是0的个数存放在 x[10].
void main()
{
int a[101],x[11],i,p;
for(i=0;i&lt;=11;i&#43;&#43;)
x=0;
for(i=1;i&lt;=100;i&#43;&#43;)
{
a=rand() % 100;
printf(&#34;%4d&#34;,a);
if(i%10==0)printf(&#34;\n&#34;);
}
for(i=1;i&lt;=100;i&#43;&#43;)
{
p=a%10;
if(p==0) p=10;
x[p]=x[p]&#43;1;
}
for(i=1;i&lt;=10;i&#43;&#43;)
{
p=i;
if(i==10) p=0;
printf(&#34;%d,%d\n&#34;,p,x);
}
printf(&#34;\n&#34;);
}
二、求两个整数的最大公约数、最小公倍数
分析：求最大公约数的算法思想：（最小公倍数=两个整数之积/最大公约数）
（1） 对于已知两数m，n，使得m&gt;n；
（2） m除以n得余数r；
（3） 若r=0，则n为求得的最大公约数，算法结束；否则执行（4）；
（4） m ← n，n ← r，再重复执行（2）。
例如： 求 m=14 ，n=6 的最大公约数。 m n r" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fc3d2a0397589af233e5307c2f6eadc8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-07-05T01:46:25+08:00" />
<meta property="article:modified_time" content="2019-07-05T01:46:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">完整的学习C&#43;&#43;的读书路线图</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <p>/*推荐给想学C++的朋友一个简单但是完整的学习C++的读书路线图：<br><br>    C++ Primer-&gt; c++标准程序库-&gt; effective C++-&gt; effective STL-&gt;深入探索C++对象模型<br><br>    C程序常用算法源码<br><br>    算法（Algorithm）：计算机解题的基本思想方法和步骤。算法的描述：是对要解决一个问题或要完成一项任务所采取的方法和步骤的描述，包括需要什么数据（输入什么数据、输出什么结果）、采用什么结构、使用什么语句以及如何安排这些语句等。<br><br>    通常使用自然语言、结构化流程图、伪代码等来描述算法。<br><br>    一、计数、求和、求阶乘等简单算法<br><br>    此类问题都要使用循环，要注意根据问题确定循环变量的初值、终值或结束条件，更要注意用来表示计数、和、阶乘的变量的初值。<br><br>    例：用随机函数产生100个[0，99]范围内的随机整数，统计个位上的数字分别为1，2，3，4，5，6，7，8，9，0的数的个数并打印出来。<br><br>    本题使用数组来处理，用数组a[100]存放产生的确100个随机整数，数组x[10]来存放个位上的数字分别为 1，2，3，4，5，6，7，8，9，0的数的个数。<br><br>    即个位是1的个数存放在x[1]中，个位是2的个数存放在x[2]中，……个位是0的个数存放在 x[10].<br>void main()<br>{<!-- --><br>int a[101],x[11],i,p;<br><br>for(i=0;i&lt;=11;i++)<br>x<em>=0;<br><br></em>for(i=1;i&lt;=100;i++)<br>{<!-- --><br>a=rand() % 100;<br>printf("%4d",a);<br>if(i%10==0)printf("\n");<br>}<br><br>for(i=1;i&lt;=100;i++)<br>{<!-- --><br>p=a%10;<br>if(p==0) p=10;<br>x[p]=x[p]+1;<br>}<br><br>for(i=1;i&lt;=10;i++)<br>{<!-- --><br>p=i;<br>if(i==10) p=0;<br>printf("%d,%d\n",p,x);<br>}<br>printf("\n");<br>}<br><br><br><br><br>    二、求两个整数的最大公约数、最小公倍数<br><br>    分析：求最大公约数的算法思想：（最小公倍数=两个整数之积/最大公约数）<br><br>    （1） 对于已知两数m，n，使得m&gt;n；<br><br>    （2） m除以n得余数r；<br><br>    （3） 若r=0，则n为求得的最大公约数，算法结束；否则执行（4）；<br><br>    （4） m ← n，n ← r，再重复执行（2）。<br><br>    例如： 求 m=14 ，n=6 的最大公约数。 m n r<br><br>    14 6 2<br><br>    6 2 0<br>void main()<br>{<!-- --><br>int nm,r,n,m,t;<br>printf("please input two numbers:\n");<br>scanf("%d,%d",&amp;m,&amp;n);<br>nm=n*m;<br>if (m&lt;n)<br>{<!-- --><br>t=n;<br>n=m;<br>m=t;<br>}<br><br>r=m%n;<br>while (r!=0)<br>{<!-- --><br>m=n;<br>n=r;<br>r=m%n;<br>}<br>printf("最大公约数:%d\n",n);<br>printf("最小公倍数:%d\n",nm/n);<br>}<br><br><br><br>    三、判断素数<br><br>    只能被1或本身整除的数称为素数 基本思想：把m作为被除数，<br><br>    将2至sqrt（m）作为除数，如果都除不尽，m就是素数，否则就不是。（可用以下程序段实现）<br>void main()<br>{<!-- --><br>int m,i,k;<br>printf("please input a number:\n");<br>scanf("%d",&amp;m);<br>k=sqrt(m);<br>for(i=2;i&lt;k;i++)<br>if(m%i==0) break;<br>if(i&gt;=k)<br>printf("该数是素数");<br>else<br>printf("该数不是素数");<br>}<br><br><br><br>    将其写成一函数，若为素数返回1，不是则返回0<br>int prime(int m)<br>{<!-- --><br>int i,k;<br>k=sqrt(m);<br>for(i=2;i&lt;k;i++)<br>if(m%i==0) return 0;<br>return 1;<br>}<br><br><br>    四、验证哥德巴赫猜想<br><br>    （任意一个大于等于6的偶数都可以分解为两个素数之和）<br><br>    基本思想：n为大于等于6的任一偶数，可分解为n1和n2两个数，分别检查n1和n2是否为素数，如都是，则为一组解。如n1不是素数，就不必再检查n2是否素数。<br><br>    先从n1=3开始，检验n1和n2（n2=N-n1）是否素数。然后使n1+2 再检验n1、n2是否素数，…<br><br>    直到n1=n/2为止。<br><br>    利用上面的prime函数，验证哥德巴赫猜想的程序代码如下：<br>#include "math.h"<br>int prime(int m)<br>{<!-- --><br>int i,k;<br>k=sqrt(m);<br>for(i=2;i&lt;k;i++)<br>if(m%i==0) break;<br>if(i&gt;=k)<br>return 1;<br>else<br>return 0;<br>}<br><br>main()<br>{<!-- --><br>int x,i;<br>printf("please input a even number(&gt;=6):\n");<br>scanf("%d",&amp;x);<br>if (x&lt;6||x%2!=0)<br>printf("data error!\n");<br>else<br>for(i=2;i&lt;=x/2;i++)<br>if (prime(i)&amp;&amp;prime(x-i))<br>{<!-- --><br>printf("%d+%d\n",i,x-i);<br>printf("验证成功!");<br>break;<br>}<br>}<br><br><br><br><br>    五、排序问题<br><br>    1.选择法排序（升序）<br><br>    基本思想：<br><br>    1）对有n个数的序列（存放在数组a（n）中），从中选出最小的数，与第1个数交换位置；<br><br>    2）除第1 个数外，其余n-1个数中选最小的数，与第2个数交换位置；<br><br>    3）依次类推，选择了n-1次后，这个数列已按升序排列。<br><br>    程序代码如下：<br>void main()<br>{<!-- --><br>int i,j,imin,s,a[10];<br>printf("\n input 10 numbers:\n");<br>for(i=0;i&lt;10;i++)<br>scanf("%d",&amp;a);<br><br>for(i=0;i&lt;9;i++)<br>{<!-- --><br>imin=i;<br>for(j=i+1;j&lt;10;j++)<br>if(a[imin]&gt;a[j]) imin=j;<br><br>if(i!=imin)<br>{<!-- --><br>s=a;<br>a=a[imin];<br>a[imin]=s; }<br>printf("%d\n",a);<br>}<br>}<br>}<br><br><br><br><br>    2.冒泡法排序（升序）<br><br>    基本思想：（将相邻两个数比较，小的调到前头）<br><br>    1）有n个数（存放在数组a（n）中），第一趟将每相邻两个数比较，小的调到前头，经n-1次两两相邻比较后，最大的数已“沉底”，    放在最后一个位置，小数上升“浮起”；<br><br>    2）第二趟对余下的n-1个数（最大的数已“沉底”）按上法比较，<br><br>    经n-2次两两相邻比较后得次大的数；<br><br>    3）依次类推，n个数共进行n-1趟比较，在第j趟中要进行n-j次两两比较。<br>程序段如下<br>void main()<br>{<!-- --><br>int a[10];<br>int i,j,t;<br>printf("input 10 numbers\n");<br>for(i=0;i&lt;10;i++)<br>scanf("%d",&amp;a);<br><br>printf("\n");<br>for(j=0;j&lt;=8;j++)<br>for(i=0;i&lt;9-j;i++)<br>if(a&gt;a[i+1])<br>{<!-- --><br>t=a;<br>a=a[i+1];<br>a[i+1]=t;<br>}<br><br>printf("the sorted numbers:\n");<br><br>for(i=0;i&lt;10;i++)<br>printf("%d\n",a);<br>}<br><br><br><br><br>    3.合并法排序（将两个有序数组A、B合并成另一个有序的数组C，升序）<br><br>    基本思想：<br><br>    1）先在A、B数组中各取第一个元素进行比较，将小的元素放入C数组；<br><br>    2）取小的元素所在数组的下一个元素与另一数组中上次比较后较大的元素比较，<br><br>    重复上述比较过程，直到某个数组被先排完；<br><br>    3）将另一个数组剩余元素抄入C数组，合并排序完成。<br><br>    程序段如下：<br>void main()<br>{<!-- --><br>int a[10],b[10],c[20],i,ia,ib,ic;<br>printf("please input the first array:\n");<br>for(i=0;i&lt;10;i++)<br>scanf("%d",&amp;a);<br><br>for(i=0;i&lt;10;i++)<br>scanf("%d",&amp;b);<br><br>printf("\n");<br>ia=0;ib=0;ic=0;<br>while(ia&lt;10&amp;&amp;ib&lt;10)<br>{<!-- --><br>if(a[ia]&lt;b[ib])<br>{<!-- --><br>c[ic]=a[ia];<br>ia++;<br>}<br>else<br>{<!-- --><br>c[ic]=b[ib];<br>ib++;<br>}<br>ic++;<br>}<br><br>while(ia&lt;=9)<br>{<!-- --><br>c[ic]=a[ia];<br>ia++;ic++;<br>}<br><br>while(ib&lt;=9)<br>{<!-- --><br>c[ic]=b[ib];<br>b++;ic++;<br>}<br><br>for(i=0;i&lt;20;i++)<br>printf("%d\n",c);<br>}<br><br><br><br><br>    六、查找问题<br><br>    1.①顺序查找法（在一列数中查找某数x）<br><br>    基本思想：一列数放在数组a[1]——a[n]中，待查找的数放在x 中，把x与a数组中的元素从头到尾一一进行比较查找。用变量p表示a数组元素下标，p初值为1，使x与a[p]比较，如果x不等于a[p]，则使 p=p+1，不断重复这个过程；一旦x等于a[p]则退出循环；另外，如果p大于数组长度，循环也应该停止。（这个过程可由下语句实现）<br>void main()<br>{<!-- --><br>int a[10],p,x,i;<br>printf("please input the array:\n");<br>for(i=0;i&lt;10;i++)<br>scanf("%d",&amp;a);<br><br>printf("please input the number you want find:\n");<br>scanf("%d",&amp;x);<br>printf("\n");<br>p=0;<br>while(x!=a[p]&amp;&amp;p&lt;10)<br>p++;<br>if(p&gt;=10)<br>printf("the number is not found!\n");<br>else<br>printf("the number is found the no%d!\n",p);<br>}<br><br><br><br><br>    思考：将上面程序改写一查找函数Find，若找到则返回下标值，找不到返回-1<br><br>    ②基本思想：一列数放在数组a[1]——a[n]中，待查找的关键值为key，把key与a数组中的元素从头到尾一一进行比较查找，若相同，查找成功，若找不到，则查找失败。（查找子过程如下。index：存放找到元素的下标。）<br>void main()<br>{<!-- --><br>int a[10],index,x,i;<br>printf("please input the array:\n");<br>for(i=0;i&lt;10;i++)<br>scanf("%d",&amp;a);<br><br>printf("please input the number you want find:\n");<br>scanf("%d",&amp;x);<br>printf("\n");<br>index=-1;<br>for(i=0;i&lt;10;i++)<br>if(x==a)<br>{<!-- --><br>index=i;<br>break;<br>}<br><br>if(index==-1)<br>printf("the number is not found!\n");<br>else<br>printf("the number is found the no%d!\n",index);<br>}<br><br><br><br><br>    2.折半查找法（只能对有序数列进行查找）<br><br>    基本思想：设n个有序数（从小到大）存放在数组a[1]——a[n]中，要查找的数为x.用变量bot、top、mid 分别表示查找数据范围的底部（数组下界）<br><br>    顶部（数组的上界）和中间，mid=（top+bot）/2，折半查找的算法如下：<br><br>    （1）x=a（mid），则已找到退出循环，否则进行下面的判断；<br><br>    （2）x&lt;a（mid），x必定落在bot和mid-1的范围之内，即top=mid-1；（3）x&gt;a（mid），x必定落在mid+1和top的范围之内，即bot=mid+1；<br><br>    （4）在确定了新的查找范围后，重复进行以上比较，直到找到或者bot&lt;=top.<br><br>    将上面的算法写成如下程序：<br>void main()<br>{<!-- --><br>int a[10],mid,bot,top,x,i,find;<br>printf("please input the array:\n");<br>for(i=0;i&lt;10;i++)<br>scanf("%d",&amp;a);<br><br>printf("please input the number you want find:\n");<br><br>scanf("%d",&amp;x);<br>printf("\n");<br>bot=0;top=9;find=0;<br><br>while(bot&lt;top&amp;&amp;find==0)<br>{<!-- --><br>mid=(top+bot)/2;<br>if(x==a[mid])<br>{<!-- --><br>find=1;<br>break;<br>}<br>else<br>if(x&lt;a[mid])<br>top=mid-1;<br>else<br>bot=mid+1;<br>}<br><br>if (find==1)<br>printf("the number is found the no%d!\n",mid);<br>else<br>printf("the number is not found!\n");<br>}</p> 
 <p>七、插入法<br><br>    把一个数插到有序数列中，插入后数列仍然有序<br><br>    基本思想：n个有序数（从小到大）存放在数组a（1）—a（n）中，要插入的数x.首先确定x插在数组中的位置P；（可由以下语句实现）<br>#define N 10<br>void insert(int a[],int x)<br>{ int p, i;<br>p=0;<br>while(x&gt;a[p]&amp;&amp;p&lt;N)<br>p++;<br>for(i=N; i&gt;p; i--)<br>a[i]=a[i-1];<br>a[p]=x;<br>}<br>main()<br>{ int a[N+1]={1,3,4,7,8,11,13,18,56,78}, x, i;<br>for(i=0; i&lt;N; i++) printf("%d,", a[i]);<br>printf("\nInput x:");<br>scanf("%d", &amp;x);<br>insert(a, x);<br>for(i=0; i&lt;=N; i++) printf("%d,", a[i]);<br>printf("\n");<br>}<br><br><br><br>    八、矩阵（二维数组）运算<br><br>    （1）矩阵的加、减运算<br><br>    C（i，j）=a（i，j）+b（i，j） 加法<br><br>    C（i，j）=a（i，j）-b（i，j） 减法<br><br>    （2）矩阵相乘<br><br>    （矩阵A有M*L个元素，矩阵B有L*N个元素，则矩阵C=A*B有M*N个元素）。矩阵C中任一元素 （i=1，2，…，m； j=1，2，…，n）<br>#define M 2<br>#define L 4<br>#define N 3<br>void mv(int a[M][L], int b[L][N], int c[M][N])<br>{ int i, j, k;<br>for(i=0; i&lt;M; i++)<br>for(j=0; j&lt;N; j++)<br>{ c[i][j]=0;<br>for(k=0; k&lt;L; k++)<br>c[i][j]+=a[i][k]*b[k][j];<br>}<br>}<br>main()<br>{ int a[M][L]={<!-- -->{1,2,3,4},{1,1,1,1}};<br>int b[L][N]={<!-- -->{1,1,1},{1,2,1},{2,2,1},{2,3,1}}, c[M][N];<br>int i, j;<br>mv(a,b,c);<br>for(i=0; i&lt;M; i++)<br>{ for(j=0; j&lt;N; j++)<br>printf("%4d", c[i][j]);<br>printf("\n");<br>}<br>}<br><br><br><br>    （3）矩阵传置<br><br>    例：有二维数组a（5，5），要对它实现转置，可用下面两种方式：<br>#define N 3<br>void ch1(int a[N][N])<br>{ int i, j, t;<br>for(i=0; i&lt;N; i++)<br>for(j=i+1; j&lt;N; j++)<br>{ t=a[i][j];<br>a[i][j]=a[j][i];<br>a[j][i]=t;<br>}<br>}<br>void ch2(int a[N][N])<br>{ int i, j, t;<br>for(i=1; i&lt;N; i++)<br>for(j= 0; j&lt;i; j++)<br>{ t=a[i][j];<br>a[i][j]=a[j][i];<br>a[j][i]=t;<br>}<br>}<br>main()<br>{ int a[N][N]={<!-- -->{1,2,3},{4,5,6},{7,8,9}}, i, j;<br>ch1(a); /*或ch2(a);*/<br>for(i=0; i&lt;N; i++)<br>{ for(j=0; j&lt;N; j++)<br>printf("%4d", a[i][j]);<br>printf("\n");<br>}<br>}<br><br><br><br>    （4）求二维数组中最小元素及其所在的行和列基本思路同一维数组，可用下面程序段实现（以二维数组a[3][4]为例）：‘变量max中存放最大值，row，column存放最大值所在行列号<br>#define N 4<br>#define M 3<br>void min(int a[M][N])<br>{ int min, row, column, i, j;<br>min=a[0][0];<br>row=0;<br>column=0;<br>for(i=0; i&lt;M; i++)<br>for(j=0; j&lt;N; j++)<br>if(a[i][j]&lt;min)<br>{ min=a[i][j];<br>row=i;<br>column=j;<br>}<br>printf("Min=%d\nAt Row%d,Column%d\n", min, row, column);<br>}<br>main()<br>{ int a[M][N]={<!-- -->{1,23,45,-5},{5,6,-7,6},{0,33,8,15}};<br>min(a);<br>}<br><br><br><br><br>    九、迭代法<br><br>    算法思想：对于一个问题的求解x，可由给定的一个初值x0，根据某一迭代公式得到一个新的值x1，这个新值x1比初值x0更接近要求的值x；再以新值作为初值，即：x1→x0，重新按原来的方法求x1，重复这一过和直到|x1-x0|&lt;ε（某一给定的精度）。此时可将x1作为问题的解。<br><br>    例：用迭代法求某个数的平方根。 已知求平方根的迭代公式为：<br>#include&lt;math.h&gt;<br>float fsqrt(float a)<br>{ float x0, x1;<br>x1=a/2;<br>do{<!-- --><br>x0=x1;<br>x1=0.5*(x0+a/x0);<br>}while(fabs(x1-x0)&gt;0.00001);<br>return(x1);<br>}<br>main()<br>{ float a;<br>scanf("%f", &amp;a);<br>printf("genhao =%f\n", fsqrt(a));<br>}<br><br><br><br>    十、数制转换<br><br>    将一个十进制整数m转换成 →r（2－16）进制字符串。<br><br>    方法：将m不断除 r 取余数，直到商为零，以反序得到结果。下面写出一转换函数，参数idec为十进制数，ibase为要转换成数的基（如二进制的基是2，八进制的基是8等），函数输出结果是字符串。<br>char *trdec(int idec, int ibase)<br>{ char strdr[20], t;<br>int i, idr, p=0;<br>while(idec!=0)<br>{ idr=idec % ibase;<br>if(idr&gt;=10)<br>strdr[p++]=idr-10+65;<br>else<br>strdr[p++]=idr+48;<br>idec/=ibase;<br>}<br>for(i=0; i&lt;p/2; i++)<br>{ t=strdr[i];<br>strdr[i]=strdr[p-i-1];<br>strdr[p-i-1]=t;<br>}<br>strdr[p]=’\0’;<br>return(strdr);<br>}<br>main()<br>{ int x, d;<br>scanf("%d%d", &amp;x, &amp;d);<br>printf("%s\n", trdec(x,d));<br>}<br><br><br><br>    十一、字符串的一般处理<br><br>    1.简单加密和解密<br><br>    加密的思想是： 将每个字母C加（或减）一序数K，即用它后的第K个字母代替，变换式公式： c=c+k例如序数k为5，这时 A→ F， a→f，B→？G… 当加序数后的字母超过Z或z则 c=c+k -26例如：You are good→ Dtz fwj ltti解密为加密的逆过程将每个字母C减（或加）一序数K，即 c=c-k，例如序数k为5，这时 Z→U，z→u，Y→T… 当加序数后的字母小于A或a则 c=c-k +26下段程序是加密处理：<br>#include&lt;stdio.h&gt;<br>char *jiami(char stri[])<br>{ int i=0;<br>char strp[50],ia;<br>while(stri[i]!=’\0’)<br>{ if(stri[i]&gt;=’A’&amp;&amp;stri[i]&lt;=’Z’)<br>{ ia=stri[i]+5;<br>if (ia&gt;’Z’) ia-=26;<br>}<br>else if(stri[i]&gt;=’a’&amp;&amp;stri[i]&lt;=’z’)<br>{ ia=stri[i]+5;<br>if (ia&gt;’z’) ia-=26;<br>}<br>else ia=stri[i];<br>strp[i++]=ia;<br>}<br>strp[i]=’\0’;<br>return(strp);<br>}<br>main()<br>{ char s[50];<br>gets(s);<br>printf("%s\n", jiami(s));<br>}<br><br><br><br>    2.统计文本单词的个数<br><br>    输入一行字符，统计其中有多少个单词，单词之间用格分隔开。<br><br>    算法思路：<br><br>    （1）从文本（字符串）的左边开始，取出一个字符；设逻辑量word表示所取字符是否是单词内的字符，初值设为0<br><br>    （2）若所取字符不是“空格”，“逗号”，“分号”或“感叹号”等单词的分隔符，再判断word是否为1，若word不为1则表是新单词的开始，让单词数num = num +1，让word =1；<br><br>    （3）若所取字符是“空格”，“逗号”，“分号”或“感叹号”等单词的分隔符， 则表示字符不是单词内字符，让word=0；<br><br>    （4） 再依次取下一个字符，重得（2）（3）直到文本结束。<br><br>    下面程序段是字符串string中包含的单词数<br>#include "stdio.h"<br>main()<br>{char c,string[80];<br>int i,num=0,word=0;<br>gets(string);<br>for(i=0;(c=string[i])!='\0';i++)<br>if(c==' ') word=0;<br>else if(word==0)<br>{ word=1;<br>num++;}<br>printf("There are %d word in the line.\n",num);<br>}<br><br><br><br>    十二、穷举法<br><br>    穷举法（又称“枚举法”）的基本思想是：一一列举各种可能的情况，并判断哪一种可能是符合要求的解，这是一种“在没有其它办法的情况的方法”，是一种最“笨”的方法，然而对一些无法用解析法求解的问题往往能奏效，通常采用循环来处理穷举问题。<br><br>    例： 将一张面值为100元的人民币等值换成100张5元、1元和0.5元的零钞，要求每种零钞不少于1张，问有哪几种组合？<br>main()<br>{ int i, j, k;<br>printf(" 5元 1元 5角\n");<br>for(i=1; i&lt;=20; i++)<br>for(j=1; j&lt;=100-i; j++)<br>{ k=100-i-j;<br>if(5*i+1*j+0.5*k==100)<br>printf(" %3d %3d %3d\n", i, j, k);<br>}<br>}<br><br><br><br>    十三、递归算法<br><br>    用自身的结构来描述自身，称递归<br><br>    VB允许在一个Sub子过程和Function过程的定义内部调用自己，即递归Sub子过程和递归Function函数。递归处理一般用栈来实现，每调用一次自身，把当前参数压栈，直到递归结束条件；然后从栈中弹出当前参数，直到栈空。<br><br>    递归条件：（1）递归结束条件及结束时的值；（2）能用递归形式表示，且递归向终止条件发展。<br><br>    例：编fac（n）=n！ 的递归函数<br><br>int fac(int n)<br>{ if(n==1)<br>return(1);<br>else<br>return(n*fac(n-1));<br>}<br>main()<br>{ int n;<br>scanf("%d", &amp;n);<br>printf("n!=%d\n", fac(n));<br>} <br><br><br>    签到工作后，用人单位承诺是嵌入式方向，让我好生欢喜，而且用人单位也很负责任的为我们应届毕业生着想，委托了一家在东北地区小有名气的培训机构为我们提供价格不菲的培训， 其中当然少不了C语言，于是特意买了本《C语言的科学与艺术》好好复习C.一个博士生讲解的C语言中级教程，虽然没有多少新意，但是总有一些久而荒废的知识，贴出来不断提醒自己“温故知新”。<br><br>    1.关于printf输出函数自从学过C++后，就再也没有用过C的printf函数，与std：：cout相比printf不能判断输出量的类型，而且对内存的操作，会有危险。<br><br>    printf的原型中参数是常量字符串+……；返回值是整形。<br><br>    其中的常量字符串中的输出格式需要注意：常用的%d、%f、%s不用多说，但是%g和%%需要说明一下：%g表示普通型，数值用%f和%e格式中较短的一个显示，在不能事先确定输出值的情况下，他是最好的输出格式。如定义了float型的变量，如果它是一个整数值，那么以%g格式输出不会显示一堆0，好像是以%d格式输出一般，若是小数值，也不会补充一堆0，让人看得很亲切。<br><br>    %%是百分号的输出表示，而不是我们常规思路那样用转义字符\.<br><br>    精度控制：<br><br>    负号：表示数值左对齐，没有负号右对齐；<br><br>    宽度：表示输出字段的最小字符数。若要显示的数值所占空间少，则以空格 填充；若数值太大，不能在指定大小的字段中显示，那么扩大字段宽度直到能够容纳这个数值。<br><br>    小数点精度：对%g而言，精度参数说明了最大有效位；%f和%e来说精度参数指定了小数点后的位数；%s而言，则表示字符串中显示的位数。<br><br>    注意：小数点占一位！<br><br>    返回值为int，在windows下平台下表示了printf函数输出的字符个数，或者发生输出错误的相关字节。特别注意一点：\t\n等制表换行的字符，虽然在输出是没有确切的字符显示，但是也算一个字符！<br><br>    2.关于scanf（）函数<br><br>    这个函数一样没法识别输入量的类型，所以也要在参数表里显示指定类型，如%d，%f等等，但是有一点不同于printf的就是%f，在输出时%f可以输出double和float两种类型，但是输入时，double的位数明显大于float于是如果象这样：<br><br>    double d；<br><br>    scanf（“%f”，&amp;d）；<br><br>    printf（“%f”，d）；<br><br>    就会输出%！$%#^@#%一堆不知所云的东西，原因就在于类型的宽度问题，正确的是以%lf输出。<br><br>    在windows的32位系统环境下，sizeof 后short 2；int 4；float 4；double 8；但是让我不理解的是long double也是8（怎么也应该比double大呀）；<br><br>    在linux的32位系统环境下，sizeof后只有long double于win32不同是12.这让我少感欣慰。<br><br>    但是还有一点需要注意：输入时可加上宽度限制，但是不可加精度限制；<br><br>    如：char c，d；scanf（“%3c，%3c”，&amp;c，&amp;d）；printf（“%c，%d”，c，d）；若输入abcdef［Enter］则会认定abc中赋给c的是a，def中赋给d的是d.<br><br>3.getchar和putchar<br><br>    这两个函数都是一次处理一个字符，以前曾写过：<br><br>    while（c = getchar（））<br><br>    {putchar（c）；<br><br>    putchar（'\n'）；……}<br><br>    这次和班里的一位同学讨论说，按照常理思考应该是输入一个字符，马上输出一个字符，但当我们输入一个字符串时，会把这个字符串挨个输出一遍。<br><br>    由于这两个函数都可由以上两个函数实现，所以我想是不是putchar中用到了scanf，然后向2那样把输入的字符串放到一个buffer里，然后依次截取下来，轮流处理。<br><br>    而若想输入一个字符，马上输出一个字符，可能是需要系统检测keydown的中断，来处理。<br><br>    这个问题还不明白，希望如果有哪位高手路过，指点一下！谢谢。<br><br>    有个哲人曾说过“一知半解是危险的。”最近对这句话的体会越来越深刻。<br><br>    林语堂先生说过“只用一样东西，不明白它的道理，是在不高明。”谨记慎行！<br><br>    全局变量&amp;局部变量<br><br>    当全局变量和局部变量同名时，会遮蔽全局变量，在函数内引用此变量时会用到同名的局部变量，而不会用到全局变量（如果想引用全局变量需要加上：：）。而且局部变量可以相互遮蔽，如if嵌套，for嵌套等。<br><br>    这都与局部变量的作用域有关，而作用域又根据各编译器的实现有关，这就联系到编译原理的内容（顺便复习一下）</p> 
 <table cellspacing="0" cellpadding="0"><tbody><tr><td id="postmessage_3553" class="t_msgfont">一般而言，标示符的符号表要包含几种属性：名字、类型、存储类别、作用域、可视性、存储分配信息。<br><br>    1）名字：<br><br>    符号表中符号名一般不允许重名，若程序出现重名标示符，则根据语言的定义， 按照该标示符的作用域和可视性规则进行相应的处理。<br><br>    若程序允许重载，函数名通过它们的参数个数、类型、返回值来区分。<br><br>    2）类型：<br><br>    决定变量的数据在存储空间的存储格式，还决定了在变量上可施加的运算。<br><br>    3）存储类别：<br><br>    其定义方法有两种形式：关键字指定，变量定义+位置。<br><br>    这个属性是编译过程语义处理，检查和存储分配的重要依据，还决定了它的作用 域可视性生命周期等问题。<br><br>    4）作用域和可视性：<br><br>    通常一个变量的作用域就是该变量可以出现的地方；函数形参作为函数内部变量处理；分程序结构本身含有局部变量声明的语句。<br><br>    5）存储分配：<br><br>    编译程序一般根据标示符的存储类别以及他们出现的位置和次序来确定每个变量应分配的存储区及该区域的具体位置。<br><br>    静态存储区 公共静态区 公共+外部 整个域作用<br><br>    局部静态区 局部静态 局部<br><br>    动态存储区<br><br>    标示符在源程序中出现的位置和先后顺序决定了标示符在存储区中的具体位置，即一个偏移量。<br><br>    关于符号表的建立：<br><br>    如程序：<br>main()<br>{int a = 1; float c =0.1;<br>{<!-- --><br>float a =1.0;<br>{float x=5.5,b =7.1;}<br>{int b =9; c =a+b+c;}<br>}<br>}<br><br><br><br>    1.建立符号表第一层到内存中main的指向；<br><br>    2.建立符号表第二层到内存中a，c的指向，指向a；<br><br>    3.建立符号表第三层到内存中a的指向，指向a；（第二层的a与第三层的a不同）<br><br>    4.建立符号表第四层到内存中x，b的指向，遇到后一个括号}表明本层结束，建立内存中结束项，然后从结束项建立 指针，指向上层最后一个元素，即第三层的a，然后删除本层的符号表到内存中的指针；<br><br>    ……<br><br>    n.最后形成的结果是符号表到内存中共有三个指向，分别指向main、a和c的a、a，然后又很多结束项指回前三层。<br><br>    （由于不会在blog里用图形，所以不能更形象地标示出来。等以后整明白的。）<br><br>    特别一点：如果是不同的C文件中，以static方式来声明同名的全局变量，如果要正常运行，要求只能有一个C文件对此变量赋值，此时连接不会出错<br><br>    补充：<br><br>    Static全局变量和普通全局变量的区别<br><br>    全局变量本身就是静态存储方式，静态全局变量当然也是，两者在存储方式上并无区别。<br><br>    这两者的区别在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件构成时，非静态的全局变量在各个文件中都是有效的，而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其他源文件中不可使用。<br><br>    由于静态全局变量的作用域限制于一个源文件中，只能为该文件内的函数使用，也可避免一些在其他文件中引起的错误。<br><br>    Static局部变量和普通局部变量的区别<br><br>    静态局部变量的存储方式与普通局部变量不同，因此生命周期也不同，后者是动态的，存放于堆栈中。<br><br>    全局的在静态区，动态的分配在堆中。<br><br>    Static函数与普通函数的区别<br>    Static函数在内存中只有一份拷贝，而普通函数每次调用，都会有一份拷贝。<br><br>    */ /*<br><br>    "C之诡谲"C语言之精华总结！<br><br>    C之诡谲（上）<br><br>    从研究生二年纪开始学习计算机也差不多两年了，一路走来，有很多的收获，也有不少的遗憾，现在正好有一段闲暇，就想对走过的路留下一些足迹，回忆。每个人都有自己不同的人生，说到这里，就是程序人生了，歌德在《浮士德》中说过：“如果不曾在悲哀中咀嚼过面包，不曾在哭泣中等待过明天，这样的人就不知道你——天的力量。”所以我想记下一些带给我悲哀，带给我哭泣的程序人生。其实学习计算机的基础课程是非常重要的，离散数学，编译原理，操作系统，形式语言……，如果你认真走过了这些路，在以后的日子你会发现你的路会越走越宽，以前的努力和汗水会不断的给你灵感，给你支持，给你前进的武器和勇气。你会发现以后取得的很多成就，不过是朝花夕拾而已！<br><br>    对于程序语言我喜欢的是C++，它能带给你别的语言无法给予你的无上的智力快感，当然也会给你一门语言所能给你的魔鬼般的折磨。其实Java，C#，Python语言也非常的不错，我也极为喜欢。它们都是非常成功的语言，我从来就不愿意做某一种语言的盲目信仰者，每种语言都有它成功的地方，失败的地方，都有它适合的地方，不如意的地方。所以每一次看到评价语言的文章，我看看，但从来不会发言。<br><br>    C++的前世是C，而且C所留下的神秘以及精简在C++中是青出于蓝而胜于蓝！C所带给人的困惑以及灵活太多，即使一个有几年经验的高段C程序员仍然有可能在C语言的小水沟里翻船。不过其实C语言真的不难，下面我想指出C语言中最神秘而又诡谲多变的四个地方，它们也继续在C++语言中变幻莫测</td></tr></tbody></table> 
</div> 
<p>转载于:https://www.cnblogs.com/rogee/archive/2010/10/12/1848817.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/7db27540ac70b76a27451fe1b0fdaaec/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">将一个对象相同的属性(不区分大小写)赋值给一个新对象</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/7fb718e261efba4728d443d71ca20de9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">图像与文字的合成</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>