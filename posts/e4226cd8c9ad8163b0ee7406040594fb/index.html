<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>tomcat的启动流程及原理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="tomcat的启动流程及原理" />
<meta property="og:description" content="组件介绍： Tomcat 最重要的是两个组件是：Connector（连接器） 和 Container（容器/集装箱），Connector 组件是可以被替换，这样可以提供给服务器设计者更多的选择，因为这个组件是如此重要，不仅跟服务器的设计的本身，而且和不同的应用场景也十分相关，所以一个 Container 可以选择对应多个 Connector。
多个 Connector 和一个 Container 就组成一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境， Server 就提供了这样一个环境。所以整个 Tomcat 的生命周期由 Server 控制。
tomcat核心组件.JPG
下面来一层层的看，首先是Server，什么是server呢？
Server Server 要完成的任务很简单，就是要能够提供一个接口让其它程序能够访问到 Service 集合，同时要维护它所包含的所有 Service 的生命周期，包括如何初始化、如何结束服务、如何找到别人要访问的 Service。还有一些次要的任务，如记录Service运行日志，维护Session等等。Server包含的组件结构如下：
tomcat-Server.png
Service Service 是在 Connector 和 Container 外面多包一层，把它们组装在一起，向外面提供服务，一个 Service 可以设置多个 Connector，但是只能有一个 Container 容器。当然Service不仅仅包含这两个组件， Service 接口的方法列表如下:
tomcat-Service方法.png
Container Container本意是集装箱的意思，是一个接口，定义了下属的各种容器，重要的是Wrapper、Host、Engine、Context等
tomcat-container结构.png
tomcat-container类图.png
Engine(引擎) 负责处理来自相关联的service的所有请求，处理后，将结果返回给service，而connector是作为service与engine的中间媒介出现的。
一个engine下可以配置一个默认主机，每个虚拟主机都有一个域名。当engine获得一个请求时，它把该请求匹配到虚拟主机(host)上，然后把请求交给该主机来处理。
Engine有一个默认主机，当请求无法匹配到任何一个虚拟主机时，将交给默认host来处理。Engine以线程的方式启动Host。
Host 代表一个虚拟主机，每个虚拟主机和某个网络域名（Domain Name）相匹配。
每个虚拟主机下都可以部署一个或多个web应用，每个web应用对应于一个context，有一个context path。
当Host获得一个请求时，将把该请求匹配到某个Context上，然后把该请求交给该Context来处理匹配的方法是“最长匹配”，所以一个path==””的Context将成为该Host的默认Context所有无法和其它Context的路径名匹配的请求都将最终和该默认Context匹配。
Context 一个Context对应于一个Web应用，一个Web应用由一个或者多个Servlet组成Context在创建的时候将根据配置文件$CATALINA_HOME/conf/web.xml和$ WEBAPP_HOME/WEB-INF/web.xml载入Servlet类。当Context获得请求时，将在自己的映射表(mapping table)中寻找相匹配的Servlet类，如果找到，则执行该类，获得请求的回应，并返回。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e4226cd8c9ad8163b0ee7406040594fb/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-01-29T16:43:25+08:00" />
<meta property="article:modified_time" content="2023-01-29T16:43:25+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">tomcat的启动流程及原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>组件介绍：</h2> 
<p>Tomcat 最重要的是两个组件是：Connector（连接器） 和 Container（容器/集装箱），Connector 组件是可以被替换，这样可以提供给服务器设计者更多的选择，因为这个组件是如此重要，不仅跟服务器的设计的本身，而且和不同的应用场景也十分相关，所以一个 Container 可以选择对应多个 Connector。</p> 
<p>多个 Connector 和一个 Container 就组成一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境， Server 就提供了这样一个环境。所以整个 Tomcat 的生命周期由 Server 控制。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/fd/c8/IFTj5Cxv_o.jpg"></p> 
<p>tomcat核心组件.JPG</p> 
<p>下面来一层层的看，首先是Server，什么是server呢？</p> 
<h2>Server</h2> 
<p>Server 要完成的任务很简单，就是要能够提供一个接口让其它程序能够访问到 Service 集合，同时要维护它所包含的所有 Service 的生命周期，包括<strong>如何初始化</strong>、<strong>如何结束服务</strong>、<strong>如何找到别人要访问的 Service</strong>。还有一些次要的任务，如记录Service运行日志，维护Session等等。Server包含的组件结构如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ba/21/eXLoCGCi_o.png"></p> 
<p>tomcat-Server.png</p> 
<h2>Service</h2> 
<p>Service 是在 Connector 和 Container 外面多包一层，把它们组装在一起，向外面提供服务，一个 Service 可以设置多个 Connector，但是只能有一个 Container 容器。当然Service不仅仅包含这两个组件， Service 接口的方法列表如下:</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/3f/d8/9WgHqnoj_o.png"></p> 
<p>tomcat-Service方法.png</p> 
<h2>Container</h2> 
<p>Container本意是集装箱的意思，是一个接口，定义了下属的各种容器，重要的是Wrapper、Host、Engine、Context等</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/da/82/abIYE4M3_o.png"></p> 
<p>tomcat-container结构.png</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e5/8b/zwWWEkqN_o.png"></p> 
<p>tomcat-container类图.png</p> 
<h3>Engine(引擎)</h3> 
<p>负责处理来自相关联的service的所有请求，处理后，将结果返回给service，而connector是作为service与engine的中间媒介出现的。<br> 一个engine下可以配置一个默认主机，每个虚拟主机都有一个域名。当engine获得一个请求时，它把该请求匹配到虚拟主机(host)上，然后把请求交给该主机来处理。<br> Engine有一个默认主机，当请求无法匹配到任何一个虚拟主机时，将交给默认host来处理。Engine以线程的方式启动Host。</p> 
<h3>Host</h3> 
<p>代表一个虚拟主机，每个虚拟主机和某个网络域名（Domain Name）相匹配。<br> 每个虚拟主机下都可以部署一个或多个web应用，每个web应用对应于一个context，有一个context path。<br> 当Host获得一个请求时，将把该请求匹配到某个Context上，然后把该请求交给该Context来处理匹配的方法是“最长匹配”，所以一个path==””的Context将成为该Host的默认Context所有无法和其它Context的路径名匹配的请求都将最终和该默认Context匹配。</p> 
<h3>Context</h3> 
<p>一个Context对应于一个Web应用，一个Web应用由一个或者多个Servlet组成Context在创建的时候将根据配置文件<code>$CATALINA_HOME/conf/web.xml</code>和<code>$ WEBAPP_HOME/WEB-INF/web.xml</code>载入Servlet类。当Context获得请求时，将在自己的映射表(mapping table)中寻找相匹配的Servlet类，如果找到，则执行该类，获得请求的回应，并返回。</p> 
<h3>Wrapper</h3> 
<p>Wrapper 代表一个 Servlet，它负责管理一个 Servlet，包括的 Servlet 的装载、初始化、执行以及资源回收。Wrapper 是最底层的容器，它没有子容器了，所以调用它的 addChild 将会报错。<br> Wrapper 的实现类是 StandardWrapper，StandardWrapper 还实现了拥有一个 Servlet 初始化信息的 ServletConfig，由此看出 StandardWrapper 将直接和 Servlet 的各种信息打交道。</p> 
<h3>Connector</h3> 
<p>Connector将在某个指定的端口上来监听客户的请求，把从socket传递过来的数据，封装成Request，传递给Engine来处理，并从Engine处获得响应并返回给客户。</p> 
<p>Tomcat通常会用到两种Connector：</p> 
<blockquote> 
 <ol><li>Http Connector 在端口8080处侦听来自客户browser的http请求。 AJP Connector</li><li>在端口8009处侦听来自其它WebServer(Apache)的servlet/jsp代理请求。</li></ol> 
</blockquote> 
<h3>Lifecycle</h3> 
<p>现实生活中大部分的事物都有生命周期，就像人的生老病死一样。</p> 
<p>在编程中也有很多对象是具有生命周期的，从初始化、运行、回收等 会经历几个不同的阶段。 在tomcat中容器相关的好多组建都实现了Lifecycle接口，当tomcat启动时，其依赖的下层组件会全部进行初始化。 并且可以<strong><em>对每个组件生命周期中的事件添加监听器</em></strong>。</p> 
<p>例如当服务器启动的时候，tomcat需要去调用servlet的init方法和初始化容器等一系列操作，而停止的时候，也需要调用servlet的destory方法。而这些都是通过org.apache.catalina.Lifecycle接口来实现的。由这个类来制定各个组件生命周期的规范。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/cb/c3/a9nahsA6_o.png"></p> 
<p>Lifecycle类图.png</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8f/3b/nwvwWF5C_o.png"></p> 
<p>tomcat生命周期类分析.png</p> 
<h4>LifecycleListener</h4> 
<p>在Lifecycle的介绍中提到，Lifecycle会对每个组件生命周期中的事件添加监听器，也就是addLifecycleListener(LifecycleListener listener)方法，而LifecycleListener就是上面提到的监听器。</p> 
<h3>LifecycleEvent</h3> 
<p>顾名思义，就是当有监听事件发生的时候，LifecycleEvent会存储时间类型和数据</p> 
<p></p> 
<pre><code>/**
* Construct a new LifecycleEvent with the specified      parameters.
*
* @param lifecycle Component on which this event occurred
* @param type Event type (required)
* @param data Event data (if any)
*/
public LifecycleEvent(Lifecycle lifecycle, String type, Object data) {
   super(lifecycle);
   this.type = type;
   this.data = data;
}
</code></pre> 
<h2>tomcat 的启动过程</h2> 
<p>tomcat的启动的起点是Server.start()方法，在这里它会依次启动<code>Container</code>和 <code>Connector</code>相关组件，最后到达EndPoint（Tomcat启动的Socket管理者），完成整个启动过程。如下图是个简易过程：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/57/6a/DgCit2mb_o.jpg"></p> 
<p>tomcat启动流程.JPG</p> 
<p></p> 
<h3>具体实现过程</h3> 
<h4>StartFirst</h4> 
<p></p> 
<pre><code>/**
 * Start the server.
 *
 * @throws LifecycleException Start error
 */
public void start() throws LifecycleException {
    getServer();
    getConnector();
    server.start();
}
</code></pre> 
<p>server启动之前需要准备好Server和Connector，server的默认实现是StandardServer, start()方法在其父类LifecycleBase中</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/17/0c/PR0DVXZP_o.png"></p> 
<p>tomcat-LifecycleBase的start方法.png</p> 
<blockquote> 
 <p>注：LifecycleBase还是<code>StandardService</code>, <code>StandardEngine</code>, <code>StandardHost</code>, <code>StandardContext</code>等的父类，所以当调用这些类的<code>start()</code>方法时其实都是调用此处的<code>start()</code>方法，而最重要的是在<code>start()</code>方法中会调用<code>startInternal()</code>，<code>startInternal()</code>在LifecycleBase中是抽象方法，具体实现由各个实现类自己定义。</p> 
</blockquote> 
<h4>startServer</h4> 
<p>启动server其实就是启动service容器，靠StandardService中的startInternal()实现方法，参考代码如下：</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f0/96/gBiBAucq_o.png"></p> 
<p>tomcat-启动service容器.png</p> 
<h4>startService</h4> 
<p>启动service其实就是启动engine容器和connector容器，是在StandardEngine中实现的。参考代码如下：</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/b6/36/5IxzZBob_o.png"></p> 
<p>tomcat-engine和connector容器准备.png</p> 
<h4>启动Engine</h4> 
<p>启动engine其实就是启动host容器(多线程),是在StandardHost中实现，参考代码如下：</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c1/6e/wrUQsoRN_o.png"></p> 
<p>tomcat-host容器准备.png</p> 
<h4>启动Host</h4> 
<p>启动Host的方式和上图一样，都是以线程的方式启动子Container，这里Host的children为Context</p> 
<h4>启动Context（上下文）</h4> 
<p><strong>启动Wrapper</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/53/38/U4ph4R8R_o.png"></p> 
<p>tomcat-启动Wrapper.png</p> 
<p></p> 
<p><strong>loadServlet</strong>（加载servlet）:</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/da/0d/6bRJfmj3_o.png"></p> 
<p>loadServlet1.png</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/08/0e/YXhJfHPx_o.png"></p> 
<p>loadServlet2.png</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e0/8a/U6LsdryI_o.png"></p> 
<p>loadServlet3.png</p> 
<p></p> 
<p>它基本上描述了对 Servlet 的操作，当装载了 Servlet 后就会调用 Servlet 的<code>init</code> 方法，同时会传一个 <code>StandardWrapperFacade</code>对象给 Servlet，这个对象包装了 StandardWrapper，ServletConfig 与它们的关系图如下：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e2/ff/85nYwJEA_o.png"></p> 
<p>tomcat-ServletConfig类关系.png</p> 
<p></p> 
<h4>启动Connector</h4> 
<p>Tomcat的Connector是Coyote connector的一种实现，这是tomcat的官方解释：The Coyote HTTP/1.1 Connector element represents a Connector component that supports the HTTP/1.1 protocol. It enables Catalina to function as a stand-alone web server, in addition to its ability to execute servlets and JSP pages.<br> Tomcat8之后默认使用nio作为接受请求策略，默认在Service启动的时候进行初始化，当然也可以单独启动，在默认的构造函数中会初始化ProtocolHandler</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/dd/52/c6mshSG4_o.png"></p> 
<p>tomcat-connector构造.png</p> 
<p></p> 
<p>tomcat中支持两种协议的连接器：HTTP/1.1与AJP/1.3</p> 
<p>HTTP/1.1协议负责建立HTTP连接，web应用通过浏览器访问tomcat服务器用的就是这个连接器，默认监听的是8080端口；</p> 
<p>AJP/1.3协议负责和其他HTTP服务器建立连接，监听的是8009端口，比如tomcat和apache或者iis集成时需要用到这个连接器。</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/64/89/5Ofv5HMJ_o.png"></p> 
<p>配置协议连机器.png</p> 
<p><strong><code>Connector</code>的启动其实就是<code>ProtocolHandler</code>的启动</strong>，如下图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/48/01/7gDf4P4L_o.png"></p> 
<p>connector启动.png</p> 
<p></p> 
<p>ProtocolHandler的类结构如下图：</p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/21/2e/UCmIm9gG_o.png"></p> 
<p>ProtocolHandler的类结构.png</p> 
<p><code>Connector</code>的<code>startInternal</code>方法调用了<code>ProtocolHandle</code>的<code>start</code>方法，这个<code>start</code>方法就在<code>AbstractProtocol</code>中，如下图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a3/33/CewxcctY_o.png"></p> 
<p>ProtocolHandle-start.png</p> 
<p></p> 
<h4>EndPoint启动</h4> 
<p>EndPoint是tomcat启动的终点，EndPoint是Tomcat启动的Socket管理者(<em>注：通过类图可以看出AbstractEndpoint已经脱离了Lifecycle和LifecycleListener体系，所以它只是一个简简单单的Socket管理者</em>)，因为是由他直接启动默认的Nio，在启动的时候先看看类结构图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/ee/84/HeTkRsar_o.png"></p> 
<p>EndPoint类关系.png</p> 
<p></p> 
<p>EndPoint能做什么呢？来看一下他的方法：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/af/67/9BSdS3av_o.png"></p> 
<p>EndPoint的方法.png</p> 
<p><br><code>createAcceptor</code>、<code>createExecutor</code>等方法都是在初始化EndPoint很重要方法，因为在接收请求的时候，通过Acceptor的接收，经过重重模块，才能一路到达Servlet<br> 那么EndPoint的启动，如下图：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/5d/0d/zAqxTiTZ_o.png"></p> 
<p>tomcat-Endpoint启动.png</p> 
<p><br> 在这个地方会启动很多的线程，这些线程大多是用于tomcat接收请求的作用。关于tomcat的接收请求流程，后续会继续积累。</p> 
<p>参考自：<a href="https://blog.csdn.net/sunyunjie361/article/details/58588033" title="Tomcat的概念及启动原理浅析_sunyunjie361的博客-CSDN博客">Tomcat的概念及启动原理浅析_sunyunjie361的博客-CSDN博客</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6e03030c6776ab9bc6471b79b6f322ea/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">NX二次开发 UFUN创建扫掠 UF_MODL_create_sweep</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ac49e29facbba5b6502428ec776a513f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">YOLOV5-7.0源码阅读（一）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>