<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring AOP - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring AOP" />
<meta property="og:description" content="1.为什么要学习AOP？ 案例：有一个接口Service有一个insert方法，在insert被调用时打印调用前的毫秒数与调用后的毫秒数，其实现为
public class UserServiceImpl implements UserService { private UserDao userDao; public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void addUser(){ System.out.println(&#34;方法开始时间：&#34;&#43;new Date()); userDao.addUser(); System.out.println(&#34;方法结束时间：&#34;&#43;new Date()); } } 问题：输出日志的逻辑还是无法复用
2.AOP概述 AOP：全称是Aspect Oriented Programming即：面向切面编程。
简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对程序进行增强：权限校验,日志记录,性能监控,事务控制.
3.AOP相关术语 连接点（joinpoint）
被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法。
切入点（pointcut）
切入点是指我们要对哪些连接点进行拦截的定义
通知/增强（advice）
所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类
切面（aspect）
是切入点和通知的结合
引介（introduction）
是一种特殊的通知，在不修改代码的前提下，引介可以在运行期为类动态地添加一些方法或字段
目标对象（Target）
要代理的目标对象（要增强的类）
织入（weave）
将增强应用到目标的过程将advice应用到target的过程
代理（Proxy）
一个类被AOP织入增强之后，就产生一个代理类
4.Spring的AOP配置 4.1创建工程 4.1.1pom.xml &lt;dependencies&gt; &lt;!-- ioc --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.1.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 日志--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/560ebc11ba1cbc23c96c964d7226c7ac/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-05T20:30:05+08:00" />
<meta property="article:modified_time" content="2024-01-05T20:30:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring AOP</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>1.为什么要学习AOP？</h2> 
<p>案例：有一个接口Service有一个insert方法，在insert被调用时打印调用前的毫秒数与调用后的毫秒数，其实现为</p> 
<pre><code class="language-java">public class UserServiceImpl implements UserService {

    private UserDao userDao;

    public void setUserDao(UserDao userDao) {
        this.userDao = userDao;
    }

    public void addUser(){
        System.out.println("方法开始时间："+new Date());
        userDao.addUser();
        System.out.println("方法结束时间："+new Date());
    }
}</code></pre> 
<ul><li> <p>问题：输出日志的逻辑还是无法复用</p> </li></ul> 
<h2>2.AOP概述</h2> 
<p>AOP：全称是Aspect Oriented Programming即：面向切面编程。</p> 
<p><img alt="" height="221" src="https://images2.imgbox.com/f7/ee/hH6lUJ0A_o.png" width="1200"></p> 
<p> 简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对程序进行增强：权限校验,日志记录,性能监控,事务控制.</p> 
<h2>3.AOP相关术语</h2> 
<ol><li> <p>连接点（joinpoint）</p> <p>被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法。</p> </li><li> <p><strong>切入点（pointcut）</strong></p> <p>切入点是指我们要对哪些连接点进行拦截的定义</p> </li><li> <p><strong>通知/增强（advice）</strong></p> <p>所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类</p> </li><li> <p><strong>切面（aspect）</strong></p> <p>是切入点和通知的结合</p> </li><li> <p>引介（introduction）</p> <p>是一种特殊的通知，在不修改代码的前提下，引介可以在运行期为类动态地添加一些方法或字段</p> </li><li> <p>目标对象（Target）</p> <p>要代理的目标对象（要增强的类）</p> </li><li> <p>织入（weave）</p> <p>将增强应用到目标的过程将advice应用到target的过程</p> </li><li> <p>代理（Proxy）</p> <p>一个类被AOP织入增强之后，就产生一个代理类</p> </li></ol> 
<p><img alt="" height="417" src="https://images2.imgbox.com/22/ac/ypOoqeN3_o.png" width="899"></p> 
<h2>4.Spring的AOP配置</h2> 
<h3>4.1创建工程</h3> 
<h4> <img alt="" height="423" src="https://images2.imgbox.com/cf/f2/Sc09ldOU_o.png" width="819"> 4.1.1pom.xml</h4> 
<pre><code class="language-XML">&lt;dependencies&gt;
    &lt;!-- ioc --&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
        &lt;version&gt;5.1.8.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;!--        日志--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
        &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
        &lt;version&gt;1.7.30&lt;/version&gt;
    &lt;/dependency&gt;
&lt;!--    aop--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
        &lt;version&gt;5.1.8.RELEASE&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre> 
<h4> 4.1.2dao</h4> 
<pre><code class="language-java">package com.by.dao;

public class UserDaoImpl implements UserDao{
    @Override
    public void addUser(){
        System.out.println("insert into tb_user......");
    }
}
</code></pre> 
<h4>4.1.3service</h4> 
<pre><code class="language-java">package com.by.service;

import com.by.dao.UserDao;

public class UserServiceImpl implements UserService{
    private UserDao userDao;

    public void setUserDao(UserDao userDao){
        this.userDao=userDao;
    }
    @Override
    public void addUser(){
        userDao.addUser();
//        int a=10;
//        System.out.println(a/0);
    }
}
</code></pre> 
<h4>4.1.4applicationContext.xml</h4> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!--注意：添加约束--&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       			   http://www.springframework.org/schema/beans/spring-beans.xsd
       			   http://www.springframework.org/schema/aop
       			   http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;
    &lt;bean id="userDao" class="com.by.dao.UserDaoImpl"&gt;&lt;/bean&gt;
    &lt;bean id="userService" class="com.by.service.UserServiceImpl"&gt;
        &lt;property name="userDao" ref="userDao"&gt;&lt;/property&gt;
    &lt;/bean&gt;
&lt;/beans&gt;</code></pre> 
<h4> 4.1.5web</h4> 
<pre><code class="language-java">package com.by.web;

import com.by.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Client {
    public static void main(String[] args) {
      ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
        UserService userService = ac.getBean("userService", UserService.class);
        userService.addUser();
        System.out.println(userService.getClass());

    }
}
</code></pre> 
<h3> 4.2增强</h3> 
<p>1.创建增强类</p> 
<pre><code class="language-java">package com.by.advice;

import org.aspectj.lang.ProceedingJoinPoint;

public class MyAdvice {
    public void before(){
        System.out.println("前置通知....");
    }
    public void after(){
        System.out.println("最终通知....");
    }
    public void afterReturn(){
     System.out.println("后置通知.....");
    }
    public void afterThrow(){
        System.out.println("异常通知，出错了......");
    }
    public void around(ProceedingJoinPoint joinPoint){
        try {
            System.out.println("方法执行前的环绕通知.......");
            joinPoint.proceed();
            System.out.println("方法执行后的环绕通知........");
        } catch (Throwable e) {
            e.printStackTrace();
        }
    }
}
</code></pre> 
<p>2.配置增强类</p> 
<pre><code class="language-java">&lt;!--    增强--&gt;
    &lt;bean id="myAdvice" class="com.by.advice.MyAdvice"&gt;&lt;/bean&gt;</code></pre> 
<h3>4.3切点</h3> 
<ol><li> <p>切点表达式</p> <p>表达式语法：</p> <p><code>execution([修饰符] 返回值类型 包名.类名.方法名(参数))</code></p> <p>例如：</p> <p><code>execution(* com.by.service.UserService.add(..))</code></p> <p><code>execution(* com.by.service.UserService.*(..))</code></p> <p><code>execution(* com.by.service.*.*(..))</code></p> </li><li> <p>配置切点</p> </li></ol> 
<pre><code class="language-XML">  &lt;aop:config&gt;
        &lt;!--    切点--&gt;
        &lt;aop:pointcut id="pointcut" expression="execution(* com.by.service.*.*(..))"/&gt;
   &lt;/aop:config&gt;</code></pre> 
<h3> 4.4切面</h3> 
<ol><li> <p>增强的类型</p> 
  <ul><li> <p>aop:before：用于配置前置通知</p> </li><li> <p>aop:after-returning：用于配置后置【try】通知，它和异常通知只能有一个执行</p> </li><li> <p>aop:after-throwing：用于配置异常【catch】通知，它和后置通知只能执行一个</p> </li><li> <p>aop:after：用于配置最终【finally】通知</p> </li><li> <p>aop:around：用于配置环绕通知</p> </li></ul></li><li> <p>配置切面</p> </li></ol> 
<pre><code class="language-XML">&lt;!--    增强--&gt;
    &lt;bean id="myAdvice" class="com.by.advice.MyAdvice"&gt;&lt;/bean&gt;

    &lt;aop:config&gt;
        &lt;!--    切点--&gt;
        &lt;aop:pointcut id="pointcut" expression="execution(* com.by.service.*.*(..))"/&gt;
        &lt;!--    切面:将增强作用与切点上--&gt;
        &lt;aop:aspect ref="myAdvice"&gt;
&lt;!--            方法执行前--&gt;
            &lt;aop:before method="before" pointcut-ref="pointcut"&gt;&lt;/aop:before&gt;
&lt;!--            最终方法--&gt;
            &lt;aop:after method="after" pointcut-ref="pointcut"&gt;&lt;/aop:after&gt;
&lt;!--            环绕通知--&gt;
            &lt;aop:around method="around" pointcut-ref="pointcut"&gt;&lt;/aop:around&gt;
&lt;!--            方法执行后--&gt;
            &lt;aop:after-returning method="afterReturn" pointcut-ref="pointcut"&gt;&lt;/aop:after-returning&gt;
&lt;!--            异常通知--&gt;
            &lt;aop:after-throwing method="afterThrow" pointcut-ref="pointcut"&gt;&lt;/aop:after-throwing&gt;
        &lt;/aop:aspect&gt;
    &lt;/aop:config&gt;
</code></pre> 
<h3>4.5测试</h3> 
<p><img alt="" height="410" src="https://images2.imgbox.com/81/bd/LuQgoqE7_o.png" width="1153"> </p> 
<h2>5.基于注解的AOP配置</h2> 
<h3>5.1创建工程</h3> 
<p><img alt="" height="454" src="https://images2.imgbox.com/f6/a1/0se3zGt3_o.png" width="813"></p> 
<h4>5.1.1pom.xml</h4> 
<pre><code class="language-XML">   &lt;dependencies&gt;
        &lt;!-- ioc --&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
            &lt;version&gt;5.1.8.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--        日志--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.slf4j&lt;/groupId&gt;
            &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;
            &lt;version&gt;1.7.30&lt;/version&gt;
        &lt;/dependency&gt;
        &lt;!--    aop--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework&lt;/groupId&gt;
            &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;
            &lt;version&gt;5.1.8.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</code></pre> 
<h4> 5.1.2dao</h4> 
<pre><code class="language-java">package by.dao;

import org.springframework.stereotype.Repository;

@Repository
public class UserDaoImpl implements UserDao{
    @Override
    public void addUser(){
        System.out.println("insert into tb_user......");
    }
}
</code></pre> 
<h4> 5.1.3<strong style="color:#4f4f4f;font-size:18px;font-weight:bold;">service</strong></h4> 
<pre><code class="language-java">package by.service;

import by.dao.UserDao;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

@Service
public class UserServiceImpl implements UserService{

    @Autowired
    private UserDao userDao;
    @Override
    public void addUser(){
        userDao.addUser();
//        int a=10;
//        System.out.println(a/0);
    }
}
</code></pre> 
<h4>5.1.4.applicationContext.xml</h4> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!--注意：添加约束--&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       			   http://www.springframework.org/schema/beans/spring-beans.xsd
       			   http://www.springframework.org/schema/context
      			   http://www.springframework.org/schema/context/spring-context.xsd
       			   http://www.springframework.org/schema/aop
       			   http://www.springframework.org/schema/aop/spring-aop.xsd"&gt;
    &lt;context:component-scan base-package="by"&gt;&lt;/context:component-scan&gt;
&lt;!--    告诉Spring要扫描的注解--&gt;
    &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;
&lt;/beans&gt;</code></pre> 
<h4>5.1.5 测试</h4> 
<pre><code class="language-java">package by.web;

import by.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Client {
    public static void main(String[] args) {
      ApplicationContext ac = new ClassPathXmlApplicationContext("applicationContext.xml");
        UserService userService = ac.getBean("userServiceImpl", UserService.class);
        userService.addUser();
        System.out.println(userService.getClass());

    }
}
</code></pre> 
<h3>5.2增强的applicationContext.xml语句</h3> 
<h3></h3> 
<pre><code class="language-XML">&lt;!-- 开启spring对注解AOP的支持 --&gt;
&lt;aop:aspectj-autoproxy/&gt;</code></pre> 
<h3>5.3AOP配置</h3> 
<ol><li> <p>常用注解</p> 
  <ul><li> <p>@Aspect：把当前类声明为切面类</p> </li><li> <p>@Before：前置通知，可以指定切入点表达式</p> </li><li> <p>@AfterReturning：后置【try】通知，可以指定切入点表达式</p> </li><li> <p>@AfterThrowing：异常【catch】通知，可以指定切入点表达式</p> </li><li> <p>@After：最终【finally】通知，可以指定切入点表达式</p> </li><li> <p>@Around：环绕通知，可以指定切入点表达式</p> </li></ul></li></ol> 
<p>2.注解方式实现aop  </p> 
<pre><code class="language-java">package by.advice;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

@Component
@Aspect //标识要增强的类
public class MyAdvice {
    @Before("execution(* by.service.*.*(..))")
    public void before(){
        System.out.println("前置通知....");
    }

    @After("execution(* by.service.*.*(..))")
    public void after(){
        System.out.println("最终通知....");
    }

    @AfterReturning("execution(* by.service.*.*(..))")
    public void afterReturn(){
     System.out.println("后置通知.....");
    }

    @AfterThrowing("execution(* by.service.*.*(..))")
    public void afterThrow(){
        System.out.println("异常通知，出错了......");
    }

    @Around("execution(* by.service.*.*(..))")
    public void around(ProceedingJoinPoint joinPoint){
        try {
            System.out.println("方法执行前的环绕通知.......");
            joinPoint.proceed();
            System.out.println("方法执行后的环绕通知........");
        } catch (Throwable e) {
            e.printStackTrace();
        }
    }
}
</code></pre> 
<p>测试结果</p> 
<p><img alt="" height="383" src="https://images2.imgbox.com/36/af/MRunzj0L_o.png" width="1200"></p> 
<h2> 6.AOP的核心概念</h2> 
<p>1.aop的核心概念<br>         切点(pintcut)：要增强的方法，eg：add()、update()<br>         通知/增强(advice)：要搞的事情，eg：日志<br>             前置通知：aop:before<br>             后置通知：aop:after-returning【try】<br>             最终通知：aop:after【finally】<br>             异常通知：aop:after-throwing【catch】<br>             环绕通知：aop:around</p> 
<p>            try{<!-- --><br>                 ...<br>                 return aop:after-returning<br>             }catch(Exception e){<!-- --><br>                 ...<br>                 aop:after-throwing<br>             }finally{<!-- --><br>                 ...<br>                 aop:after<br>             }</p> 
<p>        切面(aspect)：把增强应用到切点上<br>     2、切点表达式<br>         格式：execution([修饰符] 返回值 报名.类名.方法名(参数))<br>         eg：execution(* com.by.service.*.*(..))</p> 
<p>    3、基于xml的aop配置<br>         1）pom.xml<br>             spring-context、spring-aspects、slf4j-log4j12<br>         2）advice<br>             public class MyLogAdvice {<!-- --></p> 
<p>                public void before(){<!-- --><br>                     System.out.println("前置通知....");<br>                 }<br>             }<br>         2）aop<br>             &lt;!--增强(advice)--&gt;<br>             &lt;bean id="myLogAdvice" class="com.by.advice.MyLogAdvice"&gt;&lt;/bean&gt;</p> 
<p>            &lt;aop:config&gt;<br>                     &lt;!--切点(pintcut)--&gt;<br>                     &lt;aop:pointcut id="pointcut" expression="execution(* com.by.service.*.*(..))"/&gt;<br>                     &lt;aop:aspect ref="myLogAdvice"&gt;<br>                                 &lt;aop:before method="before" pointcut-ref="pointcut"&gt;&lt;/aop:before&gt;<br>                     &lt;/aop:aspect&gt;<br>             &lt;/aop:config&gt;</p> 
<p>4、spring基于注解的aop配置<br>     1）pom.xml<br>         spring-context、spring-aspects、slf4j-log4j12<br>     2）advice<br>         @Component<br>         @Aspect<br>         public class MyLogAdvice {<!-- --></p> 
<p>            @Before("execution(* com.by.service.*.*(..)")<br>             public void before(){<!-- --><br>                 System.out.println("前置通知....");<br>             }<br>         }<br>     5、开启spring对aop注解的支持<br>         &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9ae39d5fd30044bc95dad5cfc0794a1c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">打包Python程序为不依赖本地环境独立的 Windows 可执行程序详细教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/d669c91adc22cd6e491cb756fcda2a32/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Rust 字符串 初步了解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>