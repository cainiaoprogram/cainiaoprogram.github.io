<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>多路转接技术 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="多路转接技术" />
<meta property="og:description" content="欢迎关注博主 Mindtechnist 或加入【智能科技社区】一起学习和分享Linux、C、C&#43;&#43;、Python、Matlab，机器人运动控制、多机器人协作，智能优化算法，滤波估计、多传感器信息融合，机器学习，人工智能等相关领域的知识和技术。关注公粽号 《机器和智能》 回复关键词 “python项目实战” 即可获取美哆商城视频资源！
博主介绍：
CSDN博客专家，CSDN优质创作者，CSDN实力新星，CSDN内容合伙人；
阿里云社区专家博主；
华为云社区云享专家；
51CTO社区入驻博主，掘金社区入驻博主，支付宝社区入驻博主，博客园博主。
IO多路转接技术 —— select详解 1. 什么是IO多路转接2. IO多路转接技术——select详解（1）select()函数详解（2）文件描述符操作函数（3）使用select函的优缺点（4）select工作过程分析（5）select多路转接代码实现 图书推荐 -《精通嵌入式Linux编程》 专栏：《Linux从小白到大神》《网络编程》
1. 什么是IO多路转接 IO操作方式有两种
阻塞等待
优点：不占用CPU时间片
缺点：同一时刻只能处理一个操作，效率低下
非阻塞(忙轮询)
优点是提高了程序的执行效率，缺点是需要占用更多的CPU和系统资源
只有一个任务时
多个任务
对于非阻塞方式多任务的场景，也就是上图中的情况，解决方法是使用IO多路转接技术，常用的IO多路转接技术包括select/poll/epoll。
select/poll —— 实现方式为线性表遍历
在通信的时候，委托内核去检测连接到server的client，有哪些client是在通信的，比如说有10个client连接，但是只有6个发送了数据，要把这6个client找出来，这个工作由内核去做。但是内核只能给出发送数据的client的个数6，至于是哪6个client，需要进程自己去遍历。 在这两种方式下，可以这么理解，select 代收员比较懒， 她只会告诉你有几个快递到了，但是具体是哪个快递，你需要挨个遍历一遍。实际上，多路转接就是进程委托内核去做一些事情，在进程中只要调用select/poll/epoll就可以了，这样就实现了多任务的处理。 epoll —— 通过红黑树实现
epoll代收快递员很勤快，她不仅会告诉你有几个快递到了，还会告诉你是哪个快递公司的快递。 通过上面介绍已经大体了解了多路转接是什么，那么多路转接技术是怎么工作的呢？
先构造一张有关文件描述符的列表，将要监听的文件描述符添加到该表中。（类似于阻塞信号集）
然后调用一个函数，监听该表中的文件描述符，直到这些描述符表中的一个进行I/O操作时，该函数才返回。（select/poll/epoll）
该函数为阻塞函数函数对文件描述符的检测操作是由内核完成的 在返回时，它告诉进程有多少(哪些)描述符要进行I/O操作。
文件描述符对应的是内核缓冲区，监听文件描述符，实际上就是监听内核缓冲区的read区，因为read区有数据就说明有进程给我发送数据。select/poll会返回发生IO操作的进程个数；epoll返回发生IO操作的进程个数，以及是哪些进程。 2. IO多路转接技术——select详解 （1）select()函数详解 函数原型
int select( int nfds, fd_set *readfds, /*传入传出参数 | 传入传出参数：传入函数之前，指针指向的内存就已经有值了，函数执行完毕后，这个内存的值可能发生变化，并通过指针传递出来。*/ fd_set *writefds, fd_set *exceptfds, struct timeval *timeout ); 函数参数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3d2671cad5e9e41b21c72a459ef27afe/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-12T08:15:00+08:00" />
<meta property="article:modified_time" content="2024-01-12T08:15:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">多路转接技术</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p><img src="https://images2.imgbox.com/9e/49/rQvGggoA_o.jpg" alt="在这里插入图片描述"></p> 
<blockquote> 
 <p>欢迎关注博主 <a href="https://blog.csdn.net/qq_43471489?spm=1000.2115.3001.5343">Mindtechnist</a> 或加入【<a href="https://bbs.csdn.net/forums/mindtechnist">智能科技社区</a>】一起学习和分享Linux、C、C++、Python、Matlab，机器人运动控制、多机器人协作，智能优化算法，滤波估计、多传感器信息融合，机器学习，人工智能等相关领域的知识和技术。关注公粽号 <strong>《机器和智能》</strong> 回复关键词 “python项目实战” 即可获取美哆商城视频资源！</p> 
 <hr> 
 <p>博主介绍：<br> CSDN博客专家，CSDN优质创作者，CSDN实力新星，CSDN内容合伙人；<br> 阿里云社区专家博主；<br> 华为云社区云享专家；<br> 51CTO社区入驻博主，掘金社区入驻博主，支付宝社区入驻博主，博客园博主。</p> 
 <hr> 
 <p></p> 
 <div class="toc"> 
  <h4>IO多路转接技术 —— select详解</h4> 
  <ul><li><ul><li><a href="#1_IO_17" rel="nofollow">1. 什么是IO多路转接</a></li><li><a href="#2_IOselect_84" rel="nofollow">2. IO多路转接技术——select详解</a></li><li><ul><li><a href="#1select_86" rel="nofollow">（1）select()函数详解</a></li><li><a href="#2_138" rel="nofollow">（2）文件描述符操作函数</a></li><li><a href="#3select_156" rel="nofollow">（3）使用select函的优缺点</a></li><li><a href="#4select_168" rel="nofollow">（4）select工作过程分析</a></li><li><a href="#5select_190" rel="nofollow">（5）select多路转接代码实现</a></li></ul> 
    </li><li><a href="#_Linux_311" rel="nofollow">图书推荐 -《精通嵌入式Linux编程》</a></li></ul> 
  </li></ul> 
 </div> 
 <p></p> 
 <hr> 
 <p>专栏：<a href="https://blog.csdn.net/qq_43471489/category_11764472.html?spm=1001.2014.3001.5482">《Linux从小白到大神》</a><a href="https://blog.csdn.net/qq_43471489/category_12150203.html?spm=1001.2014.3001.5482">《网络编程》</a></p> 
</blockquote> 
<hr> 
<h3><a id="1_IO_17"></a>1. 什么是IO多路转接</h3> 
<p>IO操作方式有两种</p> 
<ul><li> <p>阻塞等待</p> 
  <ul><li> <p>优点：不占用CPU时间片</p> <p><img src="https://images2.imgbox.com/f6/2f/RBpiNr4Q_o.png" alt=""></p> </li><li> <p>缺点：同一时刻只能处理一个操作，效率低下</p> <p><img src="https://images2.imgbox.com/3c/d9/zbIHePEF_o.png" alt="在这里插入图片描述"></p> </li></ul> </li><li> <p>非阻塞(忙轮询)</p> 
  <ul><li> <p>优点是提高了程序的执行效率，缺点是需要占用更多的CPU和系统资源</p> </li><li> <p>只有一个任务时</p> <p><img src="https://images2.imgbox.com/02/37/hzm6Vqpg_o.png" alt="在这里插入图片描述"></p> </li><li> <p>多个任务</p> <p><img src="https://images2.imgbox.com/01/cf/sL3qh6NQ_o.png" alt="在这里插入图片描述"></p> </li></ul> </li></ul> 
<p>对于非阻塞方式多任务的场景，也就是上图中的情况，解决方法是使用IO多路转接技术，常用的IO多路转接技术包括select/poll/epoll。</p> 
<ul><li> <p>select/poll —— 实现方式为线性表遍历</p> 
  <ul><li>在通信的时候，委托内核去检测连接到server的client，有哪些client是在通信的，比如说有10个client连接，但是只有6个发送了数据，要把这6个client找出来，这个工作由内核去做。但是内核只能给出发送数据的client的个数6，至于是哪6个client，需要进程自己去遍历。</li></ul> <p><img src="https://images2.imgbox.com/4a/f3/gKjCYoqG_o.png" alt="在这里插入图片描述"></p> 
  <ul><li>在这两种方式下，可以这么理解，select 代收员比较懒， 她只会告诉你有几个快递到了，但是具体是哪个快递，你需要挨个遍历一遍。</li><li>实际上，多路转接就是进程委托内核去做一些事情，在进程中只要调用select/poll/epoll就可以了，这样就实现了多任务的处理。</li></ul> </li><li> <p>epoll —— 通过红黑树实现</p> <p><img src="https://images2.imgbox.com/42/10/d4xuhoy9_o.png" alt="在这里插入图片描述"></p> 
  <ul><li>epoll代收快递员很勤快，她不仅会告诉你有几个快递到了，还会告诉你是哪个快递公司的快递。</li></ul> </li></ul> 
<p>通过上面介绍已经大体了解了多路转接是什么，那么多路转接技术是怎么工作的呢？</p> 
<ul><li> <p>先构造一张有关文件描述符的列表，将要监听的文件描述符添加到该表中。（类似于阻塞信号集）</p> <p><img src="https://images2.imgbox.com/0c/d8/adO0MNnQ_o.png" alt="在这里插入图片描述"></p> </li><li> <p>然后调用一个函数，监听该表中的文件描述符，直到这些描述符表中的一个进行I/O操作时，该函数才返回。（select/poll/epoll）</p> </li><li> 
  <ul><li>该函数为阻塞函数</li><li>函数对文件描述符的检测操作是由内核完成的</li></ul> </li><li> <p>在返回时，它告诉进程有多少(哪些)描述符要进行I/O操作。</p> 
  <ul><li>文件描述符对应的是内核缓冲区，监听文件描述符，实际上就是监听内核缓冲区的read区，因为read区有数据就说明有进程给我发送数据。</li><li>select/poll会返回发生IO操作的进程个数；</li><li>epoll返回发生IO操作的进程个数，以及是哪些进程。</li></ul> </li></ul> 
<h3><a id="2_IOselect_84"></a>2. IO多路转接技术——select详解</h3> 
<h4><a id="1select_86"></a>（1）select()函数详解</h4> 
<ul><li> <p>函数原型</p> <pre><code class="prism language-c"><span class="token keyword">int</span> <span class="token function">select</span><span class="token punctuation">(</span> <span class="token keyword">int</span> nfds<span class="token punctuation">,</span> 
			fd_set <span class="token operator">*</span>readfds<span class="token punctuation">,</span> 	<span class="token comment">/*传入传出参数 | 传入传出参数：传入函数之前，指针指向的内存就已经有值了，函数执行完毕后，这个内存的值可能发生变化，并通过指针传递出来。*/</span>
			fd_set <span class="token operator">*</span>writefds<span class="token punctuation">,</span>
            fd_set <span class="token operator">*</span>exceptfds<span class="token punctuation">,</span> 
			<span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>timeout <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> </li><li> <p>函数参数</p> 
  <ul><li> <p>nfds：要检测的文件描述符中最大的fd+1 —— 可以直接传1024（文件描述符最大是1023，＋1就是1024），因为内核要做遍历，所以它需要一个最大值来作为遍历的终点。</p> </li><li> <p>readfds：读集合，重点关注，因为判断其他进程有没有给当前发送数据就是看读缓冲区有没有数据，读缓冲区有数据说明有进程连接并发送数据通信，这是被动的，是当前进程无法预知的，所以要把文件描述符放入到读集合中，让内核检测读缓冲区什么时候有数据。也就是告诉内核，只检测文件描述符对应的读缓冲区。——我们想知道对方有没有发数据，所以让内核检测文件描述符对应的读缓冲区是否有数据，所以要把文件描述符放到读集合中。读集合的类型是一个fd_set(fd_set数据类型在内核中是用一个数组实现的，数组大小是1024)，这个集合所能存放的文件描述符的个数最大是1024个。内核检测的方式，是把这些文件描述符放到一个线性表中，然后遍历线性表。</p> 
    <ul><li>文件描述符集类型：fd_set readfds；fd_set数据类型的内核代码如下，通过下面的内核代码可以看出，使用select多路转接的时候，最多只能委托内核检测1024个文件描述符，这是内核决定的。</li></ul> <p><img src="https://images2.imgbox.com/e8/40/JZt9dmTB_o.png" alt="在这里插入图片描述"></p> </li><li> <p>writefds: 写集合，写是进程主动动作，不需要去检测，一般传NULL。（写集合作用：让内核只检测文件描述符对应的写缓冲区）</p> </li><li> <p>exceptfds: 异常集合，不关心异常传NULL（让内核只检测文件描述符是否发生异常），如果想要捕捉对文件描述符的异常操作就要把它加到异常集合中。</p> </li><li> <p>timeout: 设置select是否阻塞</p> </li><li> 
    <ul><li> <p>NULL: 永久阻塞</p> </li><li> 
      <ul><li>当检测到fd变化的时候返回（缓冲区数据变化）</li></ul> </li><li> <p>struct timeval timeout;</p> </li><li> 
      <ul><li>timeout.tv_sec = 10，阻塞10s，10s后不管fd是否变换，都会返回，也就是说，只有到达指定时间才会返回。</li><li>timeout.tv_usec = 0;</li></ul> </li><li> <pre><code class="prism language-c"><span class="token function">settitimer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">struct</span> <span class="token punctuation">{<!-- --></span>
       	<span class="token keyword">long</span>    tv_sec<span class="token punctuation">;</span>                    
	 	<span class="token keyword">long</span>    tv_usec<span class="token punctuation">;</span>            
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">/*赋值的时候，秒和微秒都要赋值，因为最终结果是二者之和，否则得到的就是一个随机数。*/</span>
</code></pre> </li></ul> </li></ul> </li><li> <p>函数返回值</p> 
  <ul><li>检测的文件描述符集合中，只要有一个fd变化了，select函数就返回。</li><li>有几个文件描述符发生变化，就返回几，然后再通过遍历，把变化的fd找出来。</li></ul> </li></ul> 
<h4><a id="2_138"></a>（2）文件描述符操作函数</h4> 
<ul><li> <p>全部清空</p> </li><li> 
  <ul><li>void FD_ZERO(fd_set *set); //所有标志位清0</li></ul> </li><li> <p>从集合中删除某一项</p> </li><li> 
  <ul><li>void FD_CLR(int fd, fd_set *set); //在set中清除fd</li></ul> </li><li> <p>将某个文件描述符添加到集合</p> </li><li> 
  <ul><li>void FD_SET(int fd, fd_set *set);</li></ul> </li><li> <p>判断某个文件描述符是否在集合中</p> </li><li> 
  <ul><li>int FD_ISSET(int fd, fd_set *set); //fd对应集合中的标志位是0则返回0，是1就返回1</li></ul> </li></ul> 
<h4><a id="3select_156"></a>（3）使用select函的优缺点</h4> 
<ul><li> <p>优点:</p> </li><li> 
  <ul><li>跨平台</li></ul> </li><li> <p>缺点:</p> </li><li> 
  <ul><li>每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大（内核态到用户态的频繁切换，以及fd集合从用户态和内核态之间的复制）。</li><li>同时每次调用select都需要在内核遍历传递进来的所有fd，这个开销在fd很多时也很大，客户端越多select的效率越低，并且随着进程的增多，效率下降的越来越快。——对于前两个缺点，poll和select都有这两个缺点，但是epoll没有，因为select/poll在用户和内核有两块内存，所以需要来回复制，而epoll是内核和用户使用同一块共享内存。</li><li>select支持的文件描述符数量太小了，默认是1024。poll不受1024的影响，但是poll不可以跨平台，其他方面二者差不多。（select中的fd_set是用数组实现的，而poll用的是链表实现的，所以不受限制。epoll就更厉害了，用的是树来实现的）。——实际上进程中文件描述符最多是1024个，这个数字是可以修改的，只要修改相应的配置文件，重启电脑就好了。</li></ul> </li></ul> 
<h4><a id="4select_168"></a>（4）select工作过程分析</h4> 
<p>首先假设客户端A、B、C、D、E、 F连接到服务器，分别对应文件描述符 3、4、100、101、102、103（fd都是server端的，每有一个client连接到server，都会产生一个用于通信的fd）。</p> 
<p>现在，server通过select函数来委托内核去检测客户端ABCDEF是否给server发数据了。</p> 
<ul><li>fd_set reads, temp; —— 文件描述符表reads，存放在用户空间；内核会拷贝一份，复制到内核区。因为在内核中会修改这个表并覆盖原来的reads，所以我们需要提前备份一下原始表temp。</li><li>FD_SET(3, &amp;reads); —— 调用6次把3、4、100、101、102、103依次加入reads集合。</li><li>select(103+1, &amp;reads, NULL, NULL, NULL); 
  <ul><li>103+1表示要检测的文件描述符中数字最大的fd+1，来指定遍历的终点。</li><li>reads是传入传出参数，内核会对拿到的初始表进行修改，根据读缓冲区是否有数据将相应的位分别置1或者清0，然后用修改后的表覆盖传入的初始表reads，并作为传出参数传出。</li></ul> </li></ul> 
<p><img src="https://images2.imgbox.com/e5/98/ol7hGMZ9_o.png" alt="在这里插入图片描述"></p> 
<p>在上面的图中</p> 
<ul><li>文件描述符0、1、2分别是标准输入、标准输出、标准错误，所以供我们使用的文件描述符是从数字3开始的。</li><li>被修改后的表在内核中，它会再一次拷贝，并放到用户区，且覆盖原来的reads，这时候的reads是内核处理后的（fd变化则保留1，否则清0），所以只要遍历reads，就可以找出发送数据的client，reads相应位值为1的文件描述符对应的client发送了数据。那么我们就对应的执行read操作，去读数据。</li><li>select中传入的参数nfds是104，所以内核会遍历检测0-103文件描述符，先检测文件描述符标志位是不是1，如果是1再去检测fd对应的读缓冲区有没有数据，有数据说明和该fd通信的client发送数据了。</li><li>client连接server的时候会进行三次握手，发送FIN数据包到server的监听文件描述符lfd对应的读缓冲区中。所以，要想知道有没有client发出连接请求，就要把lfd放到读集合中，让内核去检测。也就是说，有没有连接请求也是委托内核去检测。</li></ul> 
<h4><a id="5select_190"></a>（5）select多路转接代码实现</h4> 
<pre><code class="prism language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/types.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/socket.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;arpa/inet.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;ctype.h&gt;</span></span>


<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>argc <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"eg: ./a.out port\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> serv_addr<span class="token punctuation">;</span>
    <span class="token class-name">socklen_t</span> serv_len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>serv_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> port <span class="token operator">=</span> <span class="token function">atoi</span><span class="token punctuation">(</span>argv<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 创建套接字</span>
    <span class="token keyword">int</span> lfd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> SOCK_STREAM<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 初始化服务器 sockaddr_in </span>
    <span class="token function">memset</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>serv_addr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> serv_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    serv_addr<span class="token punctuation">.</span>sin_family <span class="token operator">=</span> AF_INET<span class="token punctuation">;</span> <span class="token comment">// 地址族 </span>
    serv_addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr <span class="token operator">=</span> <span class="token function">htonl</span><span class="token punctuation">(</span>INADDR_ANY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 监听本机所有的IP</span>
    serv_addr<span class="token punctuation">.</span>sin_port <span class="token operator">=</span> <span class="token function">htons</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 设置端口 </span>
    <span class="token comment">// 绑定IP和端口</span>
    <span class="token function">bind</span><span class="token punctuation">(</span>lfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>serv_addr<span class="token punctuation">,</span> serv_len<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 设置同时监听的最大个数</span>
    <span class="token function">listen</span><span class="token punctuation">(</span>lfd<span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Start accept ......\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> client_addr<span class="token punctuation">;</span>
    <span class="token class-name">socklen_t</span> cli_len <span class="token operator">=</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>client_addr<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 最大的文件描述符</span>
    <span class="token keyword">int</span> maxfd <span class="token operator">=</span> lfd<span class="token punctuation">;</span>
    <span class="token comment">// 文件描述符读集合</span>
    fd_set reads<span class="token punctuation">,</span> temp<span class="token punctuation">;</span>
    <span class="token comment">// init 初始化</span>
    <span class="token function">FD_ZERO</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>reads<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">FD_SET</span><span class="token punctuation">(</span>lfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>reads<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">// 委托内核做IO检测</span>
        temp <span class="token operator">=</span> reads<span class="token punctuation">;</span>
        <span class="token comment">//在Linux下maxfd必须写正确，要及时更新；在Windows下可以随便写</span>
        <span class="token keyword">int</span> ret <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>maxfd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>ret <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"select error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 客户端发起了新的连接 </span>
        <span class="token comment">// 用于监听的文件描述符有且只有1个lfd，lfd对应位为1，说明有新的连接请求</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>lfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 接受新连接，返回一个用于通信的cfd,并加入到原始的读集合reads(备份)</span>
            
            <span class="token comment">// 接受连接请求 - accept不阻塞 //因为只要进入if语句，就说明有新连接</span>
            <span class="token keyword">int</span> cfd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>lfd<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>client_addr<span class="token punctuation">,</span> <span class="token operator">&amp;</span>cli_len<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>cfd <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"accept error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">char</span> ip<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"new client IP: %s, Port: %d\n"</span><span class="token punctuation">,</span> 
                   <span class="token function">inet_ntop</span><span class="token punctuation">(</span>AF_INET<span class="token punctuation">,</span> <span class="token operator">&amp;</span>client_addr<span class="token punctuation">.</span>sin_addr<span class="token punctuation">.</span>s_addr<span class="token punctuation">,</span> ip<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ip<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                   <span class="token function">ntohs</span><span class="token punctuation">(</span>client_addr<span class="token punctuation">.</span>sin_port<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 将cfd加入到待检测的读集合中 - 下一次就可以检测到了</span>
            <span class="token comment">// 下次循环的时候，如果cfd发生变化就可以检测到，当前循环是检测不到的，这也说明select是异步的。</span>
            <span class="token function">FD_SET</span><span class="token punctuation">(</span>cfd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>reads<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 更新最大的文件描述符//maxfd决定了内核遍历检测的范围</span>
            maxfd <span class="token operator">=</span> maxfd <span class="token operator">&lt;</span> cfd <span class="token operator">?</span> cfd <span class="token operator">:</span> maxfd<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 已经连接的客户端有数据到达</span>
        <span class="token comment">// 需要遍历去判断哪个client通信的cfd发生了变化（说明通信了），变化则read读取数据。</span>
        <span class="token comment">// i为啥是从lfd+1开始的？</span>
        <span class="token comment">// 因为lfd是第一个创建的文件描述符，而文件描述符创建的规则是当前最小空闲，所以lfd+1应该就是第一个用于通信的文件描述符cfd。</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>lfd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>maxfd<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>temp<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
                <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">recv</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span><span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
                <span class="token punctuation">{<!-- --></span>
                    <span class="token function">perror</span><span class="token punctuation">(</span><span class="token string">"recv error"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>len <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
                <span class="token punctuation">{<!-- --></span>
                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"客户端已经断开了连接\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">close</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token comment">// 从读集合中删除</span>
                    <span class="token function">FD_CLR</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>reads<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">else</span>
                <span class="token punctuation">{<!-- --></span>
                    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"recv buf: %s\n"</span><span class="token punctuation">,</span> buf<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token function">send</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> buf<span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        			<span class="token comment">//strlen(buf)不包括'\0',所以需要+1，并且前提是buf已经被初始化为0</span>
       	 			<span class="token comment">//必须把'\0'发出去来表示字符串结束，否则数据可能出错（比实际数据长），出现乱码</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token function">close</span><span class="token punctuation">(</span>lfd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_Linux_311"></a>图书推荐 -《精通嵌入式Linux编程》</h3> 
<blockquote> 
 <p>书名：<strong>《精通嵌入式Linux编程》</strong><br> 出版社：清华大学出版社<br> 本书的每一章都介绍嵌入式Linux的一个主要领域。它描述知识背景，以便你可以了解一般原则，它还包括详细的有效示例来说明这些领域中的操作。<br> <img src="https://images2.imgbox.com/0f/56/vTTk9ncJ_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<blockquote> 
 <p><strong>京东购买链接：</strong><a href="https://item.jd.com/14065180.html" rel="nofollow">点击直达</a><br> <strong>当当购买链接：</strong><a href="http://product.dangdang.com/29599092.html" rel="nofollow">点击直达</a></p> 
</blockquote> 
<blockquote> 
 <p><strong>内容简介：</strong>《精通嵌入式Linux编程》详细阐述了与嵌入式Linux开发相关的基本解决方案，主要包括初识嵌入式Linux开发、关于工具链、引导加载程序详解、配置和构建内核、构建根文件系统、选择构建系统、使用Yocto进行开发、Yocto技术内幕、创建存储策略、现场更新软件、连接设备驱动程序、使用分线板进行原型设计、init程序、使用BusyBoX nunit启动、管理电源、打包Python程序、了解进程和线程、管理内存、使用GDB进行调试、性能分析和跟踪、实时编程等内容。此外，该书还提供了相应的示例、代码，以帮助读者进一步理解相关方案的实现过程。<br> 　　《精通嵌入式Linux编程》适合作为高等院校计算机及相关专业的教材和教学参考书，也可作为相关开发人员的自学用书和参考手册。<br> <img src="https://images2.imgbox.com/42/10/R9BqHg2H_o.png" alt="在这里插入图片描述"></p> 
</blockquote> 
<hr> 
<p><img src="https://images2.imgbox.com/00/b7/ml245Vza_o.jpg" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/4c/06/z9n9Qxuc_o.gif" alt="在这里插入图片描述"></p> 
<hr>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f5be8481826532942e21383bfb8493d3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">将Github Copilot转换为免费使用GPT-4</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/307ddbbfc53490b128924c630b0fc2a5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">扩散模型的机器学习应用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>