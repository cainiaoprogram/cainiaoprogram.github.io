<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>python函数讲座【修改】 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="python函数讲座【修改】" />
<meta property="og:description" content="python函数讲座 函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性，和代码的重复利用率。简单地说，在Python中，函数是一组执行特定任务的相关语句。
Python 中函数的应用非常广泛，前面讲座中我们已经使用过过多个函数，比如 input() 、print()、range()函数等等，这些都是 Python 的内置函数，可以直接使用。
除了可以直接使用的内置函数外，Python 还支持自定义函数，即将一段有规律的、可重复使用的代码定义成函数，从而达到一次编写、多次调用的目的。
注意：和C语言、Visual Basic语言等函数定义不可以嵌套，调用可以嵌套不同，python函数定义和调用都可以嵌套，这一点和JavaScript函数一样。
Python函数的一般分类
（1）内置函数。Python语言内置了若干常用的函数，例如abs()、len()等等，在程序中可以直接使用。
（2）标准库函数。Python语言安装程序同时会安装若干标准库，例如math、random等等。通过import语句，可以导入标准库，然后使用其中定义的函数。
（3）第三方库函数。Python社区提供了许多其他高质量的库，如Python图像库等等，需要下载安装。下载安装这些库后，通过import语句，可以导入库，然后使用其中定义的函数。
（4）用户自定义函数。本讲座将讨论函数的定义和调用方法。
自定义函数的简单规则：
函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()和冒号：。
任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。
函数内容（函数体）缩进。
Python 定义函数的语法格式
Python 定义函数使用 def 关键字，一般格式如下：
def 函数名([参数列表]):
[&#34;&#34;&#34;docstring&#34;&#34;&#34;]
函数体
[return [返回值]]
各部分的含义如下：
其中[ ]表示其内的部分是可选的即不一定有——可写有可不写，[ ]本身不写。
关键字def标志这一个函数头部的开始。
函数名：其实就是一个符合 Python 语法的标识符，但不建议读者使用 a、b、c 这类简单的标识符作为函数名，函数名最好能够体现出该函数的功能。
参数列表：是可选的。设置该函数可以接收多少个参数，多个参数之间用逗号（ , ）分隔。即使函数不需要参数，也必须保留括号（）。
一个冒号(:)是标志着函数头部的结束。
docstring：是documentation string的缩写。它用来简单地解释函数的作用。
函数体：由一个或多个有效python语句组成。语句必须有相同的缩进(通常是4个空格)。 [return [返回值] ]：整体作为函数的可选参参数，用于设置该函数的返回值。也就是说，一个函数，可以用返回值，也可以没有返回值，是否需要根据实际情况而定。函数体中没有 return 语句时，函数运行结束会隐含返回一个 None 作为返回值，类型是 NoneType，与 return 、return None 等效，都是返回 None。
函数中可以有多条return语句，只要执行了一条return语句，程序返回到调用程序。
注意，在创建函数时，即使函数不需要参数，也必须保留一对空的“()”，否则 Python 解释器将提示“invaild syntax”错误。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/56b2197e64510cbee455a15b788579aa/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-10-30T15:26:24+08:00" />
<meta property="article:modified_time" content="2023-10-30T15:26:24+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">python函数讲座【修改】</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4 style="margin-left:0cm;text-align:center;"><strong>python函数讲座</strong></h4> 
<p style="margin-left:0cm;">函数是组织好的，可重复使用的，用来实现单一，或相关联功能的代码段。函数能提高应用的模块性，和代码的重复利用率。简单地说，在Python中，函数是一组执行特定任务的相关语句。</p> 
<p style="margin-left:0cm;">Python 中函数的应用非常广泛，前面讲座中我们已经使用过过多个函数，比如 input() 、print()、range()函数等等，这些都是 Python 的内置函数，可以直接使用。</p> 
<p style="margin-left:0cm;">除了可以直接使用的内置函数外，Python 还支持自定义函数，即将一段有规律的、可重复使用的代码定义成函数，从而达到一次编写、多次调用的目的。</p> 
<p style="margin-left:0cm;"><strong>注意</strong>：和C语言、Visual Basic语言等函数定义不可以嵌套，调用可以嵌套不同，python函数定义和调用都可以嵌套，这一点和JavaScript函数一样。</p> 
<p style="margin-left:0cm;">Python函数的一般分类</p> 
<p style="margin-left:0cm;">（1）内置函数。Python语言内置了若干常用的函数，例如abs()、len()等等，在程序中可以直接使用。</p> 
<p style="margin-left:0cm;">（2）标准库函数。Python语言安装程序同时会安装若干标准库，例如math、random等等。通过import语句，可以导入标准库，然后使用其中定义的函数。</p> 
<p style="margin-left:0cm;">（3）第三方库函数。Python社区提供了许多其他高质量的库，如Python图像库等等，需要下载安装。下载安装这些库后，通过import语句，可以导入库，然后使用其中定义的函数。</p> 
<p style="margin-left:0cm;">（4）用户自定义函数。本讲座将讨论函数的定义和调用方法。</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">自定义函数的简单规则：</p> 
<p style="margin-left:0cm;">函数代码块以 def 关键词开头，后接函数标识符名称和圆括号 ()和冒号：。</p> 
<p style="margin-left:0cm;">任何传入参数和自变量必须放在圆括号中间，圆括号之间可以用于定义参数。</p> 
<p style="margin-left:0cm;">函数内容（函数体）缩进。</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">Python 定义函数的语法格式</p> 
<p style="margin-left:0cm;">Python 定义函数使用 def 关键字，一般格式如下：</p> 
<p style="margin-left:0cm;">def 函数名([参数列表]):</p> 
<p style="margin-left:0cm;">    ["""docstring"""]</p> 
<p style="margin-left:0cm;">    函数体</p> 
<p style="margin-left:0cm;">    [return [返回值]]</p> 
<p style="margin-left:0cm;">各部分的含义如下：</p> 
<p style="margin-left:0cm;">其中[ ]表示其内的部分是可选的<span style="color:#4d4d4d;">即不一定有</span>——可写有可不写，[ ]本身不写。</p> 
<p style="margin-left:0cm;">关键字def标志这一个函数头部的开始。</p> 
<p style="margin-left:0cm;">函数名：其实就是一个符合 Python 语法的标识符，但不建议读者使用 a、b、c 这类简单的标识符作为函数名，函数名最好能够体现出该函数的功能。</p> 
<p style="margin-left:0cm;">参数列表：是可选的。设置该函数可以接收多少个参数，多个参数之间用逗号（ , ）分隔。即使函数不需要参数，也必须保留括号（）。</p> 
<p style="margin-left:0cm;">一个冒号(:)是标志着函数头部的结束。</p> 
<p style="margin-left:0cm;">docstring：是documentation string的缩写。它用来简单地解释函数的作用。</p> 
<p style="margin-left:0cm;">函数体：由一个或多个有效python语句组成。语句必须有相同的缩进(通常是4个空格)。 </p> 
<p style="margin-left:0cm;">[return [返回值] ]：整体作为函数的可选参参数，用于设置该函数的返回值。也就是说，一个函数，可以用返回值，也可以没有返回值，是否需要根据实际情况而定。函数体中没有 return 语句时，函数运行结束会隐含返回一个 None 作为返回值，类型是 NoneType，与 return 、return None 等效，都是返回 None。</p> 
<p style="margin-left:0cm;">函数中可以有多条return语句，只要执行了一条return语句，程序返回到调用程序。</p> 
<p style="margin-left:0cm;">注意，在创建函数时，即使函数不需要参数，也必须保留一对空的“()”，否则 Python 解释器将提示“invaild syntax”错误。</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">函数中使用Docstring（文档字符串）的例子</p> 
<p style="margin-left:0cm;">示例中，我们在函数标头下方有一个文档字符串。 我们通常使用三引号，以便文档字符串可以扩展到多行。 该字符串可以作为函数的__doc__属性使用,我们可以使用__doc__查看函数中使用Docstring（文档字符串）,例如</p> 
<p>def greet(name):<br>      """This function greets to the person passed in as parameter"""</p> 
<p>print(greet.__doc__)  # 查看函数中使用Docstring（文档字符串）</p> 
<p style="margin-left:0cm;">运行之，参见下图：</p> 
<p style="margin-left:0cm;"><img alt="" height="379" src="https://images2.imgbox.com/4e/7e/OMIVOshQ_o.png" width="801"></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">例、#定义一个比较字符串大小的函数</p> 
<p style="margin-left:0cm;">#函数的定义（声明）</p> 
<p style="margin-left:0cm;">def s_max(s1,s2):</p> 
<p style="margin-left:0cm;">       if s1&gt;s2:</p> 
<p style="margin-left:0cm;">              return s1</p> 
<p style="margin-left:0cm;">       else:</p> 
<p style="margin-left:0cm;">              return s2</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">Python函数的调用</p> 
<p style="margin-left:0cm;">python函数的应用一般需要：先定义（声明）、后调用，函数调用函数例外，详见 <a href="https://blog.csdn.net/couragehope/article/details/83031932" title=" https://blog.csdn.net/couragehope/article/details/83031932"> https://blog.csdn.net/couragehope/article/details/83031932</a>。</p> 
<p style="margin-left:0cm;">定义一个函数只给了函数一个名称，指定了函数里包含的参数，和代码块结构。</p> 
<p style="margin-left:0cm;">这个函数的基本结构完成以后，你可以通过另一个函数调用执行，也可以直接从Python提示符执行。要调用函数，只需键入带有适当参数的函数名。</p> 
<p style="margin-left:0cm;">调用函数一方，可以使用变量来接收函数的返回结果。</p> 
<p style="margin-left:0cm;">s1= s_max('li','wang')  #函数的调用</p> 
<p style="margin-left:0cm;">print(s1)</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">参见下图：</p> 
<p style="margin-left:0cm;"><img alt="" height="641" src="https://images2.imgbox.com/7c/f6/w0SUGEdR_o.png" width="995"></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;"><strong>函数参数</strong></p> 
<p style="margin-left:0cm;">常见的<strong>普通参数</strong>也叫必须参数、位置参数，前面的例子就是。实参和形参在顺序上和数量上必须要保持一致，否则可能造成异常，具体而言：实参和形参数量不同时将抛出异常报错；，实参和形参在顺序上不一致时，若实参和形参类型不一致将抛出异常报错，若实参和形参类型一致，虽然不抛出异常报错，但会产生结果与预期不符。</p> 
<p style="margin-left:0cm;"><strong>关键字参数</strong>指调用函数时使用形参的名字来确定传入的参数值<strong>，</strong>即调用函数时使用 <strong>形参名=值</strong> 这样的形式，这种情形不需要在乎参数的位置顺序。</p> 
<p style="margin-left:0cm;">可以将上例中s1= s_max('li','wang')  #函数的调用</p> 
<p style="margin-left:0cm;">改为：s1= s_max(s1='li', s2='wang')  #函数的调用</p> 
<p style="margin-left:0cm;">参见下图：</p> 
<p style="margin-left:0cm;"><img alt="" height="486" src="https://images2.imgbox.com/4b/2d/l5zqMnK6_o.png" width="776"></p> 
<p style="margin-left:0cm;">这种方式，参数从左至右的关系已不再重要了，因为参数是通过变量名进行传递的，而不是通过其位置，例如：</p> 
<p style="margin-left:0cm;">def f(a,b,c):</p> 
<p style="margin-left:0cm;">    print(a,b,c)</p> 
<p style="margin-left:0cm;">f(c=3,a=1,b=2)   #函数的调用</p> 
<p style="margin-left:0cm;">参见下图：</p> 
<p style="margin-left:0cm;"><img alt="" height="388" src="https://images2.imgbox.com/c4/5a/bmX95cMU_o.png" width="779"></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">函数的定义和调用示例2、计算并返回第n阶调和数（1 + 1/2 + 1/3 + … + 1/n）的函数，输出前n个调和数</p> 
<p style="margin-left:0cm;">def harmonic(n):    #自定义函数：计算n阶调和数（1 + 1/2 + 1/3 + … + 1/n）</p> 
<p style="margin-left:0cm;">    total = 0.0</p> 
<p style="margin-left:0cm;">    for i in range(1, n+1):</p> 
<p style="margin-left:0cm;">        total += 1.0 / i</p> 
<p style="margin-left:0cm;">    return total</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">n = int(6)     #调用前用定义的函数</p> 
<p style="margin-left:0cm;">for i in range(1, n+1):   #输出前n个调和数的值</p> 
<p style="margin-left:0cm;">    print(harmonic(i))</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;"><img alt="" height="718" src="https://images2.imgbox.com/dd/f0/NPSj5ZSO_o.png" width="780"></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">参数的作用</p> 
<p style="margin-left:0cm;">函数的参数，增加函数的通用性，针对相同的数据处理逻辑，能够适应更多的数据。</p> 
<p style="margin-left:0cm;">1.在函数内部，把参数当作变量使用，进行需要的数据处理。</p> 
<p style="margin-left:0cm;">2.函数调用时，按照函数定义的参数顺序，把希望在函数内部处理的数据，通过参数传递。</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">形式参数（简称形参）和实际参数（简称实参）</p> 
<p style="margin-left:0cm;">形参：定义函数时，小括号中的参数，是用来接收参数用的，在函数内部作为变量使用。</p> 
<p style="margin-left:0cm;">实参：调用函数时，小括号中的参数，是用来把数据传递到函数内部用的。</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">声明函数时声明的形式参数，等同于函数体中的局部变量，在函数体中的任何位置都可以使用。</p> 
<p style="margin-left:0cm;">局部变量和形式参数变量的区别在于，局部变量在函数体中绑定到某个对象；而形式参数变量则绑定到函数调用代码传递的对应实际参数对象。</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">Python 函数参数的传递方式</p> 
<p style="margin-left:0cm;">python的参数传递机制<br><strong>按对象引用调用</strong>（call by object reference）。调用者和被调用者之间共享这个对象，而对于不可变对象，由于并不能真正被修改，因此，修改往往是通过生成一个新对象然后赋值来实现的。<br> 【实参是使用 按值调用(call by value) 来传递的（其中的 值 始终是对象的引用 而不是对象的值） [1] 。[注1]：实际上，按对象引用调用(call by object reference) 这种说法更好，因为，传递的是可变对象时，调用者能发现被调者做出的任何更改（插入列表的元素）。节选自官方文档 <a href="https://docs.python.org/zh-cn/3/tutorial/controlflow.html#defining-functions" rel="nofollow" title="https://docs.python.org/zh-cn/3/tutorial/controlflow.html#defining-functions">https://docs.python.org/zh-cn/3/tutorial/controlflow.html#defining-functions</a>】<br>  </p> 
<p style="margin-left:0cm;">需要注意可变(mutable)与不可变(immutable)的影响。</p> 
<p style="margin-left:0cm;">【可变(mutable)与不可变(immutable)的含义</p> 
<p style="margin-left:0cm;">在 python 中，strings, tuples, 和 numbers 是不可变（不可更改）的对象，而 list,dict 等则是可变的对象。</p> 
<p style="margin-left:0cm;">不可变对象就是那些一旦被创建，它们的状态就不能被改变的对象，每次对它们的改变都是产生了新的对象。</p> 
<p style="margin-left:0cm;">可变对象就是那些创建后，状态依然可以被改变的对象。</p> 
<p style="margin-left:0cm;">不可变类型：变量赋值 a=5 后再赋值 a=10，这里实际是新生成一个 int 值对象 10，再让 a 指向它，而 5 被丢弃，不是改变a的值，相当于新生成了a。即一旦试图更改其值，将会构造一个新的对象而非对原来的值进行更改。</p> 
<p style="margin-left:0cm;">可变类型：变量赋值 la=[1,2,3,4] 后再赋值 la[2]=5 则是将列表 la 的第三个元素值更改，本身la没有动，只是其内部的一部分值被修改了。即其值可以被更改。】</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong> </strong><strong>可变(mutable)</strong> <strong>对象参数与不可变(immutable)</strong><strong>对象参数的区别</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">由于 Python 中的变量存放的是对象引用，所以对于不可变对象而言，尽管对象本身不可变，但变量的对象引用是可变的——变化的情况实际上是由于变量重新指向了新的对象，而不是修改了原来的对象。运用这样的机制，有时候会让人产生糊涂，似乎可变对象变化了。如下面的代码：</p> 
<p style="margin-left:.0001pt;text-align:justify;">i = 73 </p> 
<p style="margin-left:.0001pt;text-align:justify;">i += 2</p> 
<p style="margin-left:.0001pt;text-align:justify;">不可变的对象的特征没有变，依然是不可变对象，变的只是创建了新对象，改变了变量的对象引用。参见下图：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="107" src="https://images2.imgbox.com/d7/b9/hyS5cM2l_o.png" width="514"> ​</p> 
<p style="margin-left:.0001pt;text-align:justify;">对于可变对象，其对象的内容是可以变化的。当对象的内容发生变化时，变量的对象引用是不会变化的。如下面的例子。</p> 
<p style="margin-left:.0001pt;text-align:justify;">m=[5,9] </p> 
<p style="margin-left:.0001pt;text-align:justify;">m+=[6]</p> 
<p style="margin-left:.0001pt;text-align:justify;">参见下图：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="109" src="https://images2.imgbox.com/43/b1/wj5kZSo8_o.png" width="530"> ​</p> 
<p style="margin-left:.0001pt;text-align:justify;">【Mutable（可变）对象</p> 
<p style="margin-left:.0001pt;text-align:justify;">可变对象可以在其 id() 保持固定的情况下改变其取值。</p> 
<p style="margin-left:.0001pt;text-align:justify;">Immutable（不可变）对象</p> 
<p style="margin-left:.0001pt;text-align:justify;">具有固定值的对象。不可变对象包括数字（numbers）、字符串（strings）和元组（tuples）。这样的对象不能被改变。如果必须存储一个不同的值，则必须创建新的对象。不可变对象不允许对自身内容进行修改。如果我们对一个不可变对象进行赋值，实际上是生成一个新对象，再让变量指向这个对象。哪怕这个对象简单到只是数字 0 和 1。】</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">下面程序演示了<strong>不可变参数</strong>传递的情况：</p> 
<pre><code class="language-python">def add_fun(num):
    num +=1
    print(num, id(num))
    return

num = 3
add_fun(num)
print(num, id(num))
</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">【顺便提示：id()的值不是固定不变的——此值系统为对象分配的内存地址，在你练习时显示的不同值是正常的。】</p> 
<p style="margin-left:.0001pt;text-align:justify;">这段代码运行结果是：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#4da8ee;">4 1857150478736<br> 3 1857150478704</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">不可变的对象的特征没有变，依然是不可变对象，变的只是创建了新对象，改变了变量的对象引用。</p> 
<p style="margin-left:.0001pt;text-align:justify;">下面程序演示了<strong>可变参数</strong>传递的情况：</p> 
<pre><code class="language-python">def list_append_fun(list_t):
    list_t.append("abc")
    print(list_t, id(list_t))
    return

list_t = [1,2,3]
print(list_t, id(list_t))
list_append_fun(list_t)
print(list_t, id(list_t))</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">这段代码运行结果是：</p> 
<p style="margin-left:.0001pt;text-align:justify;"><span style="color:#4da8ee;">[1, 2, 3] 2005885237248<br> [1, 2, 3, 'abc'] 2005885237248<br> [1, 2, 3, 'abc'] 2005885237248</span></p> 
<p style="margin-left:.0001pt;text-align:justify;">当传递列表或者字典时，如果改变引用的值，就改变了原始对象。对于可变对象参数，其对象的内容是可以变化的。当对象的内容发生变化时，变量的对象引用是不会变化的。</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>变量的作用域</strong></p> 
<p style="margin-left:0cm;">局部变量、全局变量和类型成员变量</p> 
<p style="margin-left:0cm;">局部变量是在函数内部定义的变量，只能在函数内部使用，临时保存函数内部需要使用的数据，函数执行结束后，函数内部的局部变量，会被系统回收。</p> 
<p style="margin-left:0cm;">不同的函数，可以定义相同的名字的局部变量，但是各用各的不会产生影响。</p> 
<p style="margin-left:0cm;">如果在一个函数中定义的局部变量（或形式参数变量）与全局变量重名，则局部变量（或形式参数变量）优先，即函数中定义的变量是指局部变量（或形式参数变量），而不是全局变量。</p> 
<p style="margin-left:0cm;">全局变量：在一个源代码文件中，在函数和类定义之外声明的变量。</p> 
<p style="margin-left:0cm;">全局变量的作用域为其定义的模块，从定义的位置起，直到文件结束位置。</p> 
<p style="margin-left:0cm;">全局变量是在函数外部定义的变量，(没有定义在某一个函数内)，所有函数内部都可以使用这个变量。</p> 
<p style="margin-left:0cm;">通过import语句导入模块，也可以通过全限定名称“模块名.变量名”访问。或者通过from…import语句导入模块中的变量并访问。</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">例、</p> 
<p style="margin-left:0cm;">#局部变量全局变量的例子</p> 
<p style="margin-left:0cm;">num = 100      #全局变量</p> 
<p style="margin-left:0cm;">def f():</p> 
<p style="margin-left:0cm;">  num = 105    #局部变量</p> 
<p style="margin-left:0cm;">  print("输出函数内的局部变量的值：",num) </p> 
<p style="margin-left:0cm;">#测试代码</p> 
<p style="margin-left:0cm;">f()</p> 
<p style="margin-left:0cm;">print("输出函数外的全局变量的值：",num)</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;"><img alt="" height="618" src="https://images2.imgbox.com/b6/d0/PJKdUu2c_o.png" width="776"></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">在函数体中，可以引用全局变量，但如果函数内部的变量名是第一次出现且在赋值语句之前（变量赋值），则解释为定义局部变量（不存在），参见下例：</p> 
<p style="margin-left:0cm;">m = 100</p> 
<p style="margin-left:0cm;">n = 200</p> 
<p style="margin-left:0cm;">def f():</p> 
<p style="margin-left:0cm;">    print(m+10)  #引用全局变量m</p> 
<p style="margin-left:0cm;">    n =n + 10 #注意这句错误</p> 
<p style="margin-left:0cm;">#测试代码</p> 
<p style="margin-left:0cm;">f()</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;"><img alt="" height="649" src="https://images2.imgbox.com/37/d2/te5Mhrfm_o.png" width="778"></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">变量的作用域是程序中识别变量的部分。函数内部定义的参数和变量从外部看不到。因此，它们具有局部作用域。一旦我们从函数返回，它们就会被销毁。因此，函数不记得以前调用的变量的值。</p> 
<p style="margin-left:0cm;">下面例子来说明函数中变量的作用域：</p> 
<p style="margin-left:0cm;">def my_func():</p> 
<p style="margin-left:0cm;">       x = 10</p> 
<p style="margin-left:0cm;">       print("Value inside function:",x)</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">x = 20</p> 
<p style="margin-left:0cm;">my_func()</p> 
<p style="margin-left:0cm;">print("Value outside function:",x)</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">运行之，输出参见下图：</p> 
<p style="margin-left:0cm;"><img alt="" height="438" src="https://images2.imgbox.com/f5/92/R3oCSnf2_o.png" width="797"></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">下面的例子来说明函数中变量的作用域：</p> 
<p style="margin-left:0cm;">def my_func():</p> 
<p style="margin-left:0cm;">     x = 10</p> 
<p style="margin-left:0cm;">     print("Value inside function:",x)</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">x = 20</p> 
<p style="margin-left:0cm;">my_func()</p> 
<p style="margin-left:0cm;">print("Value outside function:",x)</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">运行之，输出参见下图：</p> 
<p style="margin-left:0cm;"><img alt="" height="447" src="https://images2.imgbox.com/64/f8/hGSnOflA_o.png" width="786"></p> 
<p style="margin-left:0cm;">这里，我们可以看到x的初始值是20。尽管函数my_func（）将x的值更改为10，但它不会影响函数外部的值。这是因为函数内部的变量x与外部的变量x不同，虽然它们有相同的名称，但它们是两个不同的变量，具有不同的作用域。</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">类成员变量</p> 
<p style="margin-left:0cm;">类成员变量是在类中声明的变量，包括静态变量和实例变量，其有效范围（作用域）为类定义体内。</p> 
<p style="margin-left:0cm;">在外部，通过创建类的对象实例，然后通过“对象.实例变量”访问类的实例变量，或者通过“类.静态变量”访问类的静态变量。</p> 
<p style="margin-left:0cm;">这部分内容将在面向对象程序设计讲座介绍。</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">python函数参数的进一步介绍</p> 
<p style="margin-left:0cm;">现在介绍默认参数、可变参数（*开头的参数、**开头的参数）。</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">默认参数</p> 
<p style="margin-left:0cm;">默认参数就是定义函数时，形参给定一个缺省默认值。</p> 
<p style="margin-left:0cm;">下面给出一个求幂的例子</p> 
<p style="margin-left:0cm;">由于我们经常计算x2，所以，可以把第二个参数n的默认值设定为2，当我们调用power(5)时，相当于调用power(5, 2)。</p> 
<p style="margin-left:0cm;">def power(x, n=2):</p> 
<p style="margin-left:0cm;">    s = 1</p> 
<p style="margin-left:0cm;">    while n &gt; 0:</p> 
<p style="margin-left:0cm;">        n = n - 1</p> 
<p style="margin-left:0cm;">        s = s * x</p> 
<p style="margin-left:0cm;">    return s</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">print("power(3,2)=",power(3,2))</p> 
<p style="margin-left:0cm;">print("power(3,2)=",power(3))</p> 
<p style="margin-left:0cm;">print("power(3,4)=",power(3,4))</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;"><img alt="" height="565" src="https://images2.imgbox.com/df/57/gqh9kOKA_o.png" width="788"></p> 
<p style="margin-left:0cm;">可以改变默认参数的值，如果没有给默认形参一个值作为实参，那么就会调用默认形参的值作为实参，因此会得到默认的值；如果我们在调用函数时输入了一个非默认形参值，这时候默认形参的值会发生变化，变为输入的那个值！</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">*开头的参数——可变数量参数（不定长参数）</p> 
<p style="margin-left:0cm;">在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。带有*的形参，可以容纳很多个参数（包括0个参数）。</p> 
<p style="margin-left:0cm;">def change(*str):</p> 
<p style="margin-left:0cm;">    for i in str:</p> 
<p style="margin-left:0cm;">        print(i)</p> 
<p style="margin-left:0cm;">    return</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">change("王一民","中国山东","软件开发爱好者")</p> 
<p style="margin-left:0cm;"><img alt="" height="497" src="https://images2.imgbox.com/cd/79/vNNJXi1r_o.png" width="773"></p> 
<p style="margin-left:0cm;">带有*的形参，本例中是*str，调用该函数时，可以传入任意个参数，包括0个参数。</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">**开头的参数</p> 
<p style="margin-left:0cm;">带有**的形参，允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict类型数据——会将多个值转成一个字典来处理。</p> 
<p style="margin-left:0cm;">例</p> 
<p style="margin-left:0cm;">def show_three(**kw):</p> 
<p style="margin-left:0cm;">    print(type(kw))</p> 
<p style="margin-left:0cm;">    print(kw)</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">show_three(name='张三',age='20',sex='男')</p> 
<p style="margin-left:0cm;">运行情况参见下图：</p> 
<p style="margin-left:0cm;"><img alt="" height="444" src="https://images2.imgbox.com/4d/bd/xebI2P2L_o.png" width="795"></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">组合参数，就是使用多种参数，定义函数时参数时的顺序有要求：普通参数（必须参数）、默认值参数、*开头的参数、**开头的参数。下面给出一个例子：</p> 
<p style="margin-left:0cm;">#函数定义</p> 
<p style="margin-left:0cm;">def hs(a1,a2,a3=10,*a4,**cs):</p> 
<p style="margin-left:0cm;">     print('a1=', a1, 'a2=',a2, 'a3=',a3, '*4a=',a4, '**cs=',cs)</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">xx={'name':'xiaozhi','age':'18','interesting':'basketball'}</p> 
<p style="margin-left:0cm;">hs(1,2,3,4,5,6,7,m=26,n=25,**xx)  #第一次调用</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">tu=(1,2,3,4,5,6,7,8,'zhao')</p> 
<p style="margin-left:0cm;">zd={'m':26, 'n':25, 'x':'wang'}</p> 
<p style="margin-left:0cm;">hs(*tu, **zd) #第二次调用</p> 
<p style="margin-left:0cm;">运行情况参见下图：</p> 
<p style="margin-left:0cm;"><img alt="" height="490" src="https://images2.imgbox.com/f5/6b/SFHXP82X_o.png" width="1163"></p> 
<p style="margin-left:0cm;">在第一次调用函数时，1、2分别给a1，a2，形参a3=10，但是传入实参为3，改变了原来的值，因此a3=3，*a4 是不定长参数，因此4、5、6、7给*a4，以元组的形式输出，m、n以及**xx 的值给**cs，以字典形式输出。</p> 
<p style="margin-left:0cm;">在第二次调用函数时，tu为一个元组，用*tu调用时输出 a1=1，a2=2，a3=3，*4a=(4,5,6,7,8, 'zhao')，用**zd调用时以字典形式输出{'m': 26, 'n': 25, 'x': 'wang'}。</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">再给出一个例子：</p> 
<p style="margin-left:0cm;">def myFun(args, *args1, **args2):</p> 
<p style="margin-left:0cm;">    print(args)</p> 
<p style="margin-left:0cm;">    print(args1)</p> 
<p style="margin-left:0cm;">    print(args2)</p> 
<p style="margin-left:0cm;">  </p> 
<p style="margin-left:0cm;">myFun('测试：','李明', 9, '小学生', name='刘美媚', job='软件测试', Gender='女')</p> 
<p style="margin-left:0cm;">运行情况参见下图：</p> 
<p style="margin-left:0cm;"><img alt="" height="469" src="https://images2.imgbox.com/d5/41/fZ4DVutf_o.png" width="786"></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;"><strong>匿名函数（Anonymous Function）</strong></p> 
<p style="margin-left:0cm;">匿名函数格式：</p> 
<p style="margin-left:0cm;">lambda [参数列表]: 表达式</p> 
<p style="margin-left:0cm;">说明</p> 
<p style="margin-left:0cm;">Python语言使用lambda关键字来创建匿名函数。</p> 
<p style="margin-left:0cm;">参数列表不需要小括号，多个参数之间用英文逗号分隔。无参就不写参数。</p> 
<p style="margin-left:0cm;">冒号用来分割参数列表和表达式部分。</p> 
<p style="margin-left:0cm;">不需要使用return。表达式的值，就是匿名函数的返回值。表达式中不能出现等号。</p> 
<p style="margin-left:0cm;">lambda表达式（匿名函数）只能写在一行上。</p> 
<p style="margin-left:0cm;">匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数，如果有参数，将对应的参数放进括号。</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">所谓匿名，即不再使用def语句这样标准的形式定义一个函数，没有函数名字。</p> 
<p style="margin-left:0cm;">匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量。</p> 
<p style="margin-left:0cm;">匿名函数调用方式</p> 
<p style="margin-left:0cm;">1）直接赋值给一个变量,然后再像一般函数调用，如：</p> 
<p style="margin-left:0cm;">c = lambda x,y,z: x*y*z</p> 
<p style="margin-left:0cm;">print(c(2,3,4))   #输出 24</p> 
<p style="margin-left:0cm;">2）直接后面传递实参，如：</p> 
<p style="margin-left:0cm;">print((lambda x,y: x if x&gt; y else y)(101,102)) #输出 102</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">下面给出例子并运行之。</p> 
<p style="margin-left:0cm;">f = lambda x: x * x<br> print(f(3))</p> 
<p style="margin-left:0cm;">运行之，参见下图：</p> 
<p style="margin-left:0cm;"><img alt="" height="344" src="https://images2.imgbox.com/93/07/CRwe7Fgo_o.png" width="779"></p> 
<p style="margin-left:0cm;"></p> 
<p>也可以把匿名函数作为别的函数的返回值返回。例：<br> def build(x, y):<br>     return lambda: x * x + y * y</p> 
<p>f=build(1, 2)  # 调用<br> print(f())  # 注意这句<br>  </p> 
<p style="margin-left:0cm;">运行之，参见下图：</p> 
<p style="margin-left:0cm;"><img alt="" height="412" src="https://images2.imgbox.com/47/73/pPGAxAOa_o.png" width="774"></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;"><strong>递归函数（Recursive function）</strong></p> 
<p style="margin-left:0cm;">递归算法（Recursive algorithm）在计算机科学中是指一种通过重复将问题分解为同类的子问题而解决问题的方法。递归算法是一种直接或者间接调用自身函数或者方法的算法。</p> 
<p style="margin-left:0cm;">运用递归的条件：每一步进行的操作基本相同，并且问题规模逐渐减小。</p> 
<p style="margin-left:0cm;"><strong>递归的过程</strong></p> 
<p style="margin-left:0cm;">递归，顾名思义，其包含了两个意思：递 和 归，这正是递归思想的精华所在。递归就是有去（递去）有回（归来），用递归求4！如下图所示:</p> 
<p style="margin-left:0cm;"><img alt="" height="314" src="https://images2.imgbox.com/5c/0e/MstEa8KD_o.png" width="438"></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">递归函数（Recursive function），一个函数在内部调用自己，那么这个函数是递归函数。递归会反复使用本身，每递归一次，越接近最终的值。当一个问题可以由许多相似的小问题解决， 可以考虑使用递归函数。随着递归的深入，问题规模相比上次都应所减小。return函数本身的方法保证了递归的持续进行，但是如果没有明确的结束条件，递归会无限进行下去。所以当已经到了问题解决的程度， 应该告诉函数结束递归，这就需要明确的结束条件。</p> 
<p style="margin-left:0cm;">下面是用递归求阶乘的python代码</p> 
<p>def fun(n):<br>     if n == 0 or n == 1:<br>         return 1<br>     else:<br>         return (n * fun(n - 1))</p> 
<p>num = int(input("请输入一个正整数: "))<br> a = fun(num)<br> print(a)</p> 
<p style="margin-left:0cm;">运行之，参见下图：</p> 
<p style="margin-left:0cm;"><img alt="" height="472" src="https://images2.imgbox.com/7c/08/1pSR7Qev_o.png" width="833"></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">经典递归问题</p> 
<p style="margin-left:0cm;">汉诺塔：汉诺塔（又称河内塔）问题是源于印度一个古老传说的益智玩具。此问题等价于：</p> 
<p style="margin-left:0cm;">设a,b,c是3个柱子。开始时，在柱子a上有一叠共n个圆盘，这些圆盘自下而上，由大到小地叠在一起。各圆盘从小到大编号为1,2,…,n,现要求将柱子a上的圆盘移到柱子c上，在移动圆盘时可以借助b柱子，但应遵守以下移动规则：</p> 
<p style="margin-left:0cm;">规则1：每次只能移动1个圆盘；</p> 
<p style="margin-left:0cm;">规则2：任何时刻都不允许将较大的圆盘压在较小的圆盘之上；</p> 
<p style="margin-left:0cm;">规则3：在满足移动规则1和2的前提下，可将圆盘移至a,b,c中任一柱子上。</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;"><img alt="" height="156" src="https://images2.imgbox.com/43/fc/eO51IdiO_o.png" width="402"></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">目标：把a柱子上的n个盘子移动到c柱子</p> 
<p style="margin-left:0cm;">递归的思想就是把这个目标分解成三个子目标</p> 
<p style="margin-left:0cm;">子目标1：将前n-1个盘子从a移动到b上</p> 
<p style="margin-left:0cm;">子目标2：将最底下的最后一个盘子从a移动到c上</p> 
<p style="margin-left:0cm;">子目标3：将b上的n-1个盘子移动到c上</p> 
<p style="margin-left:0cm;">然后每个子目标又是一次独立的汉诺塔游戏，也就可以继续分解目标直到N为1</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">用递归求汉诺塔的python代码</p> 
<p style="margin-left:0cm;">def hanoi(n, a, b, c):<br>     if n == 1:<br>         print(a, '--&gt;', c)<br>     else:<br>         hanoi(n - 1, a, c, b)<br>         hanoi(1    , a, b, c)<br>         hanoi(n - 1, b, a, c)<br> # 调用<br> n = int(input("请输入汉诺塔的层数并回车："))<br> hanoi(n, 'A', 'B', 'C')</p> 
<p style="margin-left:0cm;">运行之，参见下图：</p> 
<p style="margin-left:0cm;"><img alt="" height="607" src="https://images2.imgbox.com/7d/e7/ywd7aXqw_o.png" width="830"></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;"><strong>嵌套函数（Nested function）和闭包（closure）</strong></p> 
<p style="margin-left:0cm;">Python允许函数的嵌套，即在函数体中定义函数，内部的函数称为<strong>嵌套函数</strong>（nested function），也叫内部函数（inner function）。为了执行内部函数，必须调用外部函数。 如果不调用外部函数，内部函数将永远不会执行。</p> 
<p style="margin-left:0cm;">怎么在函数外部调用内部函数？不能直接调用内部函数，需要先调用外部函数，在调用内部函数，否则出错，请留意下面例子调用的写法。</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">例子1、</p> 
<p style="margin-left:0cm;">def f1(x):</p> 
<p style="margin-left:0cm;">    print("from f1",x)</p> 
<p style="margin-left:0cm;">    def f2(y):</p> 
<p style="margin-left:0cm;">        print("from f2",y)</p> 
<p style="margin-left:0cm;">       </p> 
<p style="margin-left:0cm;">    f2("xyz")  # 调用内层函数f2</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">f1(123)  #调用</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">运行之，参见下图：</p> 
<p style="margin-left:0cm;"><img alt="" height="455" src="https://images2.imgbox.com/29/64/w6tC1U5m_o.png" width="809"></p> 
<p></p> 
<p style="margin-left:0cm;">请注意这种情况下函数的访问顺序，在上面的示例中，f2()是在 f1()内部定义的，因此它是一个内部函数。 要调用 f2() ，必须先调用 f1()， 然后，f1()将继续调用在其中定义的 f2()。</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">对上例，修改如下，请仔细对比：</p> 
<p style="margin-left:0cm;">def f1(x):</p> 
<p style="margin-left:0cm;">    print("from f1",x)</p> 
<p style="margin-left:0cm;">    def f2(y):</p> 
<p style="margin-left:0cm;">        print("from f2",y)</p> 
<p style="margin-left:0cm;">    return f2  #注意此处改动了</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">f1(123)("xyx")  #注意此处改动了。本句和res=f1(123)和res("xyz")这两句，效果是一样</p> 
<p style="margin-left:0cm;">print("---------")</p> 
<p style="margin-left:0cm;">res=f1(123)</p> 
<p style="margin-left:0cm;">res("xyz")</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">运行之，参见下图：</p> 
<p style="margin-left:0cm;"><img alt="" height="538" src="https://images2.imgbox.com/fd/32/f3BdfQT5_o.png" width="801"></p> 
<p style="margin-left:.0001pt;text-align:justify;">注意修改处，这样一来，调用函数时，除使用<strong>先外后内方式</strong>调用，还可以采用了<strong>多括号方式</strong>调用。</p> 
<p style="margin-left:.0001pt;text-align:justify;">一般而言，调用一个函数是加一个括号。</p> 
<p style="margin-left:.0001pt;text-align:justify;">如果看见调用函数括号后还有一个括号，说明第一个函数（外部函数）返回了一个函数（内部函数）——第一个函数（外部函数）使用 return 内部函数名，前面的括号是外部函数的，后面的括号是内部函数的。</p> 
<p style="margin-left:.0001pt;text-align:justify;">有了上述基础，理解闭包就容易了。</p> 
<p style="margin-left:0cm;"><strong>闭包（closure）</strong></p> 
<p style="margin-left:0cm;">在一个外部函数内定义了一个内部函数，内部函数里运用了外部函数的临时变量，并且外部函数的返回值是内部函数的引用，这样就构成了一个闭包（closure）。【如果一个内部函数访问外部函数作用域的变量，并返回值是这个内部函数，这样就构成了一个闭包。】</p> 
<p style="margin-left:0cm;">以下是在 Python 中创建闭包所需满足的条件：</p> 
<p style="margin-left:0cm;">必须有一个嵌套函数。</p> 
<p style="margin-left:0cm;">内部函数必须引用在enclosing scope（外层/封闭作用域）中定义的值——内部函数必须引用外部函数中的变量。</p> 
<p style="margin-left:0cm;">enclosing function（外层/封闭函数）必须返回嵌套函数。</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">计算一个数的 n 次幂，用闭包可以写成下面的代码：</p> 
<p style="margin-left:0cm;">#闭包函数，其中 exponent 是外层变量</p> 
<p style="margin-left:0cm;">def nth_power(exponent):</p> 
<p style="margin-left:0cm;">    def exponent_of(base):</p> 
<p style="margin-left:0cm;">        return base ** exponent</p> 
<p style="margin-left:0cm;">    return exponent_of # 返回值是 exponent_of 函数，注意不能带括号</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">square = nth_power(2) # 计算一个数的平方</p> 
<p style="margin-left:0cm;">cube = nth_power(3) # 计算一个数的立方</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">print(square(2))  # 计算 2 的平方</p> 
<p style="margin-left:0cm;">print(cube(2)) # 计算 2 的立方</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">运行之，参见下图：</p> 
<p style="margin-left:0cm;"><img alt="" height="515" src="https://images2.imgbox.com/7a/05/6AXzKv6R_o.png" width="801"></p> 
<p>在执行完 square = nth_power(2) 和 cube = nth_power(3) 后，外部函数 nth_power() 的参数 exponent 会和内部函数 exponent_of 一起赋值给 squre 和 cube，这样在之后调用 square(2) 或者 cube(2) 时，程序就能顺利地输出结果，而不会报错说参数 exponent 没有定义。</p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;">关于python之 Nested Function和closure延展阅读 <a class="link-info" href="https://blog.csdn.net/cnds123/article/details/129684125" title="https://blog.csdn.net/cnds123/article/details/129684125">https://blog.csdn.net/cnds123/article/details/129684125</a></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><strong>__closure__ </strong><strong>属性</strong></p> 
<p style="margin-left:.0001pt;text-align:justify;">Python闭包比普通的函数相比，多了一个 __closure__ 属性，该属性记录着自由变量的地址。当闭包被调用时，系统就会根据该地址找到对应的自由变量，完成整体的函数调用。</p> 
<p style="margin-left:.0001pt;text-align:justify;">以上面提到的nth_power() 为例，当其被调用时，可以通过 __closure__ 属性获取外层变量（对本例而言是程序中的 exponent 参数）存储的地址，例如：</p> 
<p style="margin-left:.0001pt;text-align:justify;">def nth_power(exponent):</p> 
<p style="margin-left:.0001pt;text-align:justify;">    def exponent_of(base):</p> 
<p style="margin-left:.0001pt;text-align:justify;">        return base ** exponent</p> 
<p style="margin-left:.0001pt;text-align:justify;">    return exponent_of</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">square = nth_power(2)</p> 
<p style="margin-left:.0001pt;text-align:justify;">#查看 __closure__ 的值</p> 
<p style="margin-left:.0001pt;text-align:justify;">print(square.__closure__)</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;"><img alt="" height="441" src="https://images2.imgbox.com/94/2c/OXUoXlbo_o.png" width="810"></p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:justify;">Python变量的认识理解 <a class="link-info" href="https://blog.csdn.net/cnds123/article/details/116768499" title="https://blog.csdn.net/cnds123/article/details/116768499">https://blog.csdn.net/cnds123/article/details/116768499</a></p> 
<p style="margin-left:.0001pt;text-align:justify;">关于Python的全局变量、局部变量、类变量、实例变量，以及global和nonlocal等更多详情可见<a class="link-info" href="https://blog.csdn.net/cnds123/article/details/129488233" title="https://blog.csdn.net/cnds123/article/details/129488233">https://blog.csdn.net/cnds123/article/details/129488233</a></p> 
<p>关于Python函数的几点说明 <a class="link-info" href="https://blog.csdn.net/cnds123/article/details/127924671" title="https://blog.csdn.net/cnds123/article/details/127924671">https://blog.csdn.net/cnds123/article/details/127924671</a></p> 
<p>关于Python的函数的几点特别说明 <a class="link-info" href="https://blog.csdn.net/cnds123/article/details/115770008" title="https://blog.csdn.net/cnds123/article/details/115770008">https://blog.csdn.net/cnds123/article/details/115770008</a></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;"></p> 
<p style="margin-left:0cm;"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a3a6058b8f2546cf5241c7a6ba30cb70/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Java字符串整齐输出</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/789e554bcff894662d847b715fc0f248/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">寄存器、CPU缓存、内存。以及他们之间的关系</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>