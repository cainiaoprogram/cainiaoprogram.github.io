<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>IC设计入门——异步FIFO - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="IC设计入门——异步FIFO" />
<meta property="og:description" content="在异步FIFO中，数据读取和写入操作使用不同的时钟频率。由于写入和读取时钟不同步，因此称为异步FIFO。通常，这些用于数据需要从一个时钟域传递到另一个时钟域的系统中，这通常称为“时钟域交叉”。因此，异步FIFO有助于在两个工作于不同时钟的系统之间同步数据流。
异步FIFO框图 信号：
wr_en：写使能
wr_data：写入数据
full：FIFO 已满
empty：FIFO 为空
rd_en：读取启用
rd_data：读取数据
b_wptr：二进制写入指针
g_wptr：格雷码写入指针
b_wptr_next：二进制写入指针 下一页
g_wptr_next： 下一个格雷码写指针
b_rptr：二进制读取指针
g_rptr：格雷码读取指针
b_rptr_next： 下一个二进制读取指针
g_rptr_next：下一个格雷码读取指针
b_rptr_sync：二进制读取指针同步
b_wptr_sync：二进制写入指针同步
异步FIFO操作 在同步FIFO的情况下，写入和读取指针在同一时钟上生成。但是，在异步FIFO的情况下，写入指针与写入时钟域对齐，而读取指针与读取时钟域对齐。因此，它需要域交叉来计算FIFO的满条件和空条件。这会导致实际设计中的亚稳态。为了解决这种亚稳态问题，可以使用2个触发器或3个触发器同步器来传递写入和读取指针。为了解释，我们将使用 2 个触发器同步器。请注意，单个“两拍同步器”只能解析一位的亚稳态。因此，根据写入和读取指针的不同，需要多个 两拍 同步器。
module synchronizer #(parameter WIDTH=3) (input clk, rst_n, [WIDTH:0] d_in, output reg [WIDTH:0] d_out ); reg [WIDTH:0] q1; always@(posedge clk) begin if(!rst_n) begin q1 &lt;= 0; d_out &lt;= 0; end else begin q1 &lt;= d_in; d_out &lt;= q1; end end endmodule 在异步FIFO中使用二进制到格雷码转换器，反之亦然 到目前为止，我们讨论了如何在各自的时钟域中获取异步写入和读取指针。但是，我们不应该传递二进制格式的写入和读取指针值。由于亚稳态，整体写入或读取指针值可能不同。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/a17f34c0223f41521bd4d03b2eccfe3d/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-12T14:22:30+08:00" />
<meta property="article:modified_time" content="2024-01-12T14:22:30+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">IC设计入门——异步FIFO</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在异步FIFO中，数据读取和写入操作使用不同的时钟频率。由于写入和读取时钟不同步，因此称为异步FIFO。通常，这些用于数据需要从一个时钟域传递到另一个时钟域的系统中，这通常称为“时钟域交叉”。因此，异步FIFO有助于在两个工作于不同时钟的系统之间同步数据流。</p> 
<p></p> 
<p></p> 
<p class="img-center"><img alt="异步 FIFO 使用" height="266" src="https://images2.imgbox.com/b5/79/JmPlLP8S_o.gif" width="468"></p> 
<h3>异步FIFO框图</h3> 
<p></p> 
<p class="img-center"><img alt="异步FIFO" height="578" src="https://images2.imgbox.com/88/34/3ruZ9HeJ_o.gif" width="1024"></p> 
<p><strong>信号：</strong></p> 
<p>wr_en：写使能</p> 
<p>wr_data：写入数据</p> 
<p>full：FIFO 已满</p> 
<p>empty：FIFO 为空</p> 
<p>rd_en：读取启用</p> 
<p>rd_data：读取数据</p> 
<p>b_wptr：二进制写入指针</p> 
<p>g_wptr：格雷码写入指针</p> 
<p>b_wptr_next：二进制写入指针 下一页</p> 
<p>g_wptr_next： 下一个格雷码写指针</p> 
<p>b_rptr：二进制读取指针</p> 
<p>g_rptr：格雷码读取指针</p> 
<p>b_rptr_next： 下一个二进制读取指针</p> 
<p>g_rptr_next：下一个格雷码读取指针</p> 
<p>b_rptr_sync：二进制读取指针同步</p> 
<p>b_wptr_sync：二进制写入指针同步</p> 
<h3>异步FIFO操作</h3> 
<p>在同步FIFO的情况下，写入和读取指针在同一时钟上生成。但是，在异步FIFO的情况下，写入指针与写入时钟域对齐，而读取指针与读取时钟域对齐。因此，它需要域交叉来计算FIFO的满条件和空条件。这会导致实际设计中的<a href="https://en.wikipedia.org/wiki/Metastability_%28electronics%29" rel="nofollow" title="亚稳态">亚稳态</a>。为了解决这种亚稳态问题，可以使用2个触发器或3个触发器同步器来传递写入和读取指针。为了解释，我们将使用 2 个触发器同步器。请注意，单个“两拍同步器”只能解析一位的亚稳态。因此，根据写入和读取指针的不同，需要多个 两拍 同步器。</p> 
<p></p> 
<p class="img-center"><img alt="" height="378" src="https://images2.imgbox.com/86/db/D7zc02Rv_o.gif" width="570"></p> 
<pre><code>module synchronizer 
#(parameter WIDTH=3)
(input clk, 
       rst_n, 
       [WIDTH:0] d_in, 
output reg [WIDTH:0] d_out
);
  reg [WIDTH:0] q1;
  always@(posedge clk) begin
    if(!rst_n) begin
      q1 &lt;= 0;
      d_out &lt;= 0;
    end
    else begin
      q1 &lt;= d_in;
      d_out &lt;= q1;
    end
  end
endmodule</code></pre> 
<h4>在异步FIFO中使用二进制到格雷码转换器，反之亦然</h4> 
<p>到目前为止，我们讨论了如何在各自的时钟域中获取异步写入和读取指针。但是，我们不应该传递二进制格式的写入和读取指针值。由于亚稳态，整体写入或读取指针值可能不同。</p> 
<p>示例：当写入时钟域的二进制值 wr_ptr = 4'b1101 通过 2FF 同步器传输时，在读取时钟域wr_ptr值可能接收为 4'b1111 或任何其他不可接受的值。而灰色代码可以保证与以前的值相比只有一位变化。因此，写入和读取指针都需要首先转换为相应域中的等效格雷码，然后将它们传递到相反的域。要检查另一个域中的FIFO满条件和空条件，我们有两种方法。</p> 
<h5>方式 1</h5> 
<p>将收到的格雷码格式指针转换为二进制格式，然后检查完整和空条件。</p> 
<h6>FIFO 满载条件</h6> 
<pre><code>g2b_converter g2b_wr(g_rptr_sync, b_rptr_sync);
wrap_around = b_rptr_sync[PTR_WIDTH] ^ b_wptr[PTR_WIDTH];
wfull = wrap_around &amp; (b_wptr[PTR_WIDTH-1:0] == b_rptr_sync[PTR_WIDTH-1:0]);</code></pre> 
<h6>FIFO 空条件</h6> 
<pre><code>g2b_converter g2b_rd(g_wptr_sync, b_wptr_sync);
rempty = (b_wptr_sync == b_rptr_next);</code></pre> 
<p></p> 
<h5>方式 2</h5> 
<p>在接收到的灰色编码写和读指针的帮助下，直接检查满和空条件。这很有效，因为它不需要额外的硬件来将格雷编码的写入和读取指针转换为等效的二进制形式。</p> 
<h6>FIFO 满载条件</h6> 
<pre><code>wfull = (g_wptr_next == {~g_rptr_sync[PTR_WIDTH:PTR_WIDTH-1], g_rptr_sync[PTR_WIDTH-2:0]});</code></pre> 
<p></p> 
<h6>FIFO 空条件</h6> 
<pre><code>rempty = (g_wptr_sync == g_rptr_next);</code></pre> 
<h3>异步FIFO Verilog码</h3> 
<h4>写入指针处理程序</h4> 
<p>同步器g_rptr_sync的输出作为“写入指针处理程序”模块的输入，用于生成FIFO满条件。如果二进制写入指针 （b_wptr） 满足 （w_en &amp; ！full） 条件，则该指针递增。该b_wptr值被馈送到fifo_mem模块，以将数据写入FIFO。</p> 
<pre><code>module wptr_handler #(parameter PTR_WIDTH=3) (
  input wclk, wrst_n, w_en,
  input [PTR_WIDTH:0] g_rptr_sync,
  output reg [PTR_WIDTH:0] b_wptr, g_wptr,
  output reg full
);

  reg [PTR_WIDTH:0] b_wptr_next;
  reg [PTR_WIDTH:0] g_wptr_next;
   
  reg wrap_around;
  wire wfull;
  
  assign b_wptr_next = b_wptr+(w_en &amp; !full);
  assign g_wptr_next = (b_wptr_next &gt;&gt;1)^b_wptr_next;
  
  always@(posedge wclk or negedge wrst_n) begin
    if(!wrst_n) begin
      b_wptr &lt;= 0; // set default value
      g_wptr &lt;= 0;
    end
    else begin
      b_wptr &lt;= b_wptr_next; // incr binary write pointer
      g_wptr &lt;= g_wptr_next; // incr gray write pointer
    end
  end
  
  always@(posedge wclk or negedge wrst_n) begin
    if(!wrst_n) full &lt;= 0;
    else        full &lt;= wfull;
  end

  assign wfull = (g_wptr_next == {~g_rptr_sync[PTR_WIDTH:PTR_WIDTH-1], g_rptr_sync[PTR_WIDTH-2:0]});

endmodule</code></pre> 
<h4>读取指针处理程序</h4> 
<p>同步器g_wptr_sync的输出作为“读取指针处理程序”模块的输入，以生成FIFO空条件。如果二进制读取指针 （b_rptr） 满足 （r_en &amp; ！empty） 条件，则该指针递增。该b_rptr值被馈送到fifo_mem模块，以从FIFO读取数据。</p> 
<pre><code>module rptr_handler #(parameter PTR_WIDTH=3) (
  input rclk, rrst_n, r_en,
  input [PTR_WIDTH:0] g_wptr_sync,
  output reg [PTR_WIDTH:0] b_rptr, g_rptr,
  output reg empty
);

  reg [PTR_WIDTH:0] b_rptr_next;
  reg [PTR_WIDTH:0] g_rptr_next;

  assign b_rptr_next = b_rptr+(r_en &amp; !empty);
  assign g_rptr_next = (b_rptr_next &gt;&gt;1)^b_rptr_next;
  assign rempty = (g_wptr_sync == g_rptr_next);
  
  always@(posedge rclk or negedge rrst_n) begin
    if(!rrst_n) begin
      b_rptr &lt;= 0;
      g_rptr &lt;= 0;
    end
    else begin
      b_rptr &lt;= b_rptr_next;
      g_rptr &lt;= g_rptr_next;
    end
  end
  
  always@(posedge rclk or negedge rrst_n) begin
    if(!rrst_n) empty &lt;= 1;
    else        empty &lt;= rempty;
  end
endmodule</code></pre> 
<h4>FIFO存储器</h4> 
<p>基于二进制编码的写入和读取指针，数据分别写入FIFO或从FIFO读取。</p> 
<pre><code class="hljs">module fifo_mem #(parameter DEPTH=8, DATA_WIDTH=8, PTR_WIDTH=3) (
  input wclk, w_en, rclk, r_en,
  input [PTR_WIDTH:0] b_wptr, b_rptr,
  input [DATA_WIDTH-1:0] data_in,
  input full, empty,
  output reg [DATA_WIDTH-1:0] data_out
);
  reg [DATA_WIDTH-1:0] fifo[0:DEPTH-1];
  
  always@(posedge wclk) begin
    if(w_en &amp; !full) begin
      fifo[b_wptr[PTR_WIDTH-1:0]] &lt;= data_in;
    end
  end
  /*
  always@(posedge rclk) begin
    if(r_en &amp; !empty) begin
      data_out &lt;= fifo[b_rptr[PTR_WIDTH-1:0]];
    end
  end
  */
  assign data_out = fifo[b_rptr[PTR_WIDTH-1:0]];
endmodule</code></pre> 
<h4>顶部模块</h4> 
<pre><code>`include "synchronizer.v"
`include "wptr_handler.v"
`include "rptr_handler.v"
`include "fifo_mem.v"

module asynchronous_fifo #(parameter DEPTH=8, DATA_WIDTH=8) (
  input wclk, wrst_n,
  input rclk, rrst_n,
  input w_en, r_en,
  input [DATA_WIDTH-1:0] data_in,
  output reg [DATA_WIDTH-1:0] data_out,
  output reg full, empty
);
  
  parameter PTR_WIDTH = $clog2(DEPTH);
 
  reg [PTR_WIDTH:0] g_wptr_sync, g_rptr_sync;
  reg [PTR_WIDTH:0] b_wptr, b_rptr;
  reg [PTR_WIDTH:0] g_wptr, g_rptr;

  wire [PTR_WIDTH-1:0] waddr, raddr;

  synchronizer #(PTR_WIDTH) sync_wptr (rclk, rrst_n, g_wptr, g_wptr_sync); //write pointer to read clock domain
  synchronizer #(PTR_WIDTH) sync_rptr (wclk, wrst_n, g_rptr, g_rptr_sync); //read pointer to write clock domain 
  
  wptr_handler #(PTR_WIDTH) wptr_h(wclk, wrst_n, w_en,g_rptr_sync,b_wptr,g_wptr,full);
  rptr_handler #(PTR_WIDTH) rptr_h(rclk, rrst_n, r_en,g_wptr_sync,b_rptr,g_rptr,empty);
  fifo_mem fifom(wclk, w_en, rclk, r_en,b_wptr, b_rptr, data_in,full,empty, data_out);

endmodule</code></pre> 
<p> </p> 
<h3>testbench代码</h3> 
<pre><code>module async_fifo_TB;

  parameter DATA_WIDTH = 8;

  wire [DATA_WIDTH-1:0] data_out;
  wire full;
  wire empty;
  reg [DATA_WIDTH-1:0] data_in;
  reg w_en, wclk, wrst_n;
  reg r_en, rclk, rrst_n;

  // Queue to push data_in
  reg [DATA_WIDTH-1:0] wdata_q[$], wdata;

  asynchronous_fifo as_fifo (wclk, wrst_n,rclk, rrst_n,w_en,r_en,data_in,data_out,full,empty);

  always #10ns wclk = ~wclk;
  always #35ns rclk = ~rclk;
  
  initial begin
    wclk = 1'b0; wrst_n = 1'b0;
    w_en = 1'b0;
    data_in = 0;
    
    repeat(10) @(posedge wclk);
    wrst_n = 1'b1;

    repeat(2) begin
      for (int i=0; i&lt;30; i++) begin
        @(posedge wclk iff !full);
        w_en = (i%2 == 0)? 1'b1 : 1'b0;
        if (w_en) begin
          data_in = $urandom;
          wdata_q.push_back(data_in);
        end
      end
      #50;
    end
  end

  initial begin
    rclk = 1'b0; rrst_n = 1'b0;
    r_en = 1'b0;

    repeat(20) @(posedge rclk);
    rrst_n = 1'b1;

    repeat(2) begin
      for (int i=0; i&lt;30; i++) begin
        @(posedge rclk iff !empty);
        r_en = (i%2 == 0)? 1'b1 : 1'b0;
        if (r_en) begin
          wdata = wdata_q.pop_front();
          if(data_out !== wdata) $error("Time = %0t: Comparison Failed: expected wr_data = %h, rd_data = %h", $time, wdata, data_out);
          else $display("Time = %0t: Comparison Passed: wr_data = %h and rd_data = %h",$time, wdata, data_out);
        end
      end
      #50;
    end

    $finish;
  end
  
  initial begin 
    $dumpfile("dump.vcd"); $dumpvars;
  end
endmodule</code></pre> 
<div> 
 <div style="margin-left:auto;"> 
  <div> 
   <div> 
    <div style="margin-left:auto;"> 
     <div> 
      <div> 
       <div> 
        <div> 
         <h4 style="margin-left:0;"><span style="color:#22323d;"><span style="background-color:#ffffff;"><span style="color:#000000;">波形</span></span></span></h4> 
        </div> 
       </div> 
       <div style="text-align:center;"> 
        <div> 
         <p class="img-center"><img alt="" class="attachment-large ezlazyloaded size-large wp-image-6822" height="304" src="https://images2.imgbox.com/fc/50/z0rfeDnO_o.png" width="1024"></p> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
  <div> 
   <div> 
    <div> 
     <div> 
      <div> 
       <div> 
        <div style="margin-left:auto;"> 
         <div> 
          <div> 
           <div> 
            <div></div> 
           </div> 
          </div> 
         </div> 
        </div> 
       </div> 
      </div> 
     </div> 
    </div> 
   </div> 
  </div> 
 </div> 
</div> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/9daef8672a559c9547d3f85eeb9933fd/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">如何使用SVN查看旧版本</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/07948f0e065c0cb49ec1e8e35a512272/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Edge扩展插件安装</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>