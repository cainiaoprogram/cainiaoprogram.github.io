<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>（P53-56）物理层查询优化 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="（P53-56）物理层查询优化" />
<meta property="og:description" content="文章目录 1.为什么要物理查询优化？2.代价估算3.代价估算总结4.小结 1.为什么要物理查询优化？ 一个选择查询的eg：
的执行方案
方案1：表空间扫描方法
直接对Course表进行扫描，从第一条检索到最后一条，将满足条件的记录找出方案2：利用Course上的Cname排序索引的方法
利用排序索引可以进行诸如二分查找等快速检索，找到相应的索引项，依据指针将满足条件的记录找出当条件更复杂时，可选择的方案还会更多，对于上述的方案，究竟用哪一个算法的程序来执行?为什么如此选择? 物理查询运算符
物理查询运算符通常是关系代数操作符的一个特定实现程序获取关系元组的操作
TableScan(\R) —表空间扫描算法
SortTableScan(\R)—表空间扫描排序算法
IndexScan(\R)—索引扫描算法
SortIndexScan(\R)—索引扫描排序算法 关系操作的各种实现算法
，集合上的操作： , 包上的操作： , 积，连接： PRODUCT， JOIN每个关系操作都有下面的算法：一趟算法、两趟算法；基于索引算法、基于散列算法、基于排序算法； 迭代器构造–流水化、物化；
物理优化
就是为每一个关系代数操作选择合适的执行程序
2.代价估算 DBMS如何衡量物理查询计划的优劣呢？
衡量I/O访问次数衡量CPU的占用时间内存使用代价(与缓冲区数目与大小的匹配)中间结果存储代价计算量(如搜索记录、合并记录、排序记录、字段值的计算等)网络通信量 依据什么信息来计算这些方案的上述各种指标呢？
依据数据库的一些统计信息—存放在数据字典或系统目录中的
T R 或 者 T ( R ) ： 关 系 R 的 元 组 数 目 T_R或者T(R)：关系R的元组数目 TR​或者T(R)：关系R的元组数目 B R 或 B ( R ) ： 关 系 R 的 磁 盘 块 数 目 B_R或B(R) ：关系R的磁盘块数目 BR​或B(R)：关系R的磁盘块数目 f R 或 f ( R ) : R 的 块 因 子 ， 即 一 块 能 够 存 储 的 R 的 元 组 数 目 f_R或f(R) : R的块因子，即一块能够存储的R的元组数目 fR​或f(R):R的块因子，即一块能够存储的R的元组数目 V ( R , A ) : R 中 属 性 A 出 现 不 同 值 的 数 目 ， 即 π A ( R ) 的 数 目 V(R, A): R中属性A出现不同值的数目，即 π_A(R) 的数目 V(R,A):R中属性A出现不同值的数目，即πA​(R)的数目 S C ( A , R ) : R 中 属 性 A 的 选 择 基 数 ， 满 足 A 上 等 值 条 件 的 平 均 记 录 数 SC(A, R): R中属性A的选择基数，满足A上等值条件的平均记录数 SC(A,R):R中属性A的选择基数，满足A上等值条件的平均记录数 b ： 每 个 磁 盘 块 的 字 节 数 ； b：每个磁盘块的字节数； b：每个磁盘块的字节数；DBMS依据上述统计信息对DB操作的各种物理查询计划进行评估，以确定最优的计划予以执行 上述信息如何获得呢？" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/77f4cd1b36ac031001784cc362c2cc3f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-22T11:41:21+08:00" />
<meta property="article:modified_time" content="2021-11-22T11:41:21+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">（P53-56）物理层查询优化</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#1_2" rel="nofollow">1.为什么要物理查询优化？</a></li><li><a href="#2_33" rel="nofollow">2.代价估算</a></li><li><a href="#3_139" rel="nofollow">3.代价估算总结</a></li><li><a href="#4_153" rel="nofollow">4.小结</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="1_2"></a>1.为什么要物理查询优化？</h3> 
<p>一个选择查询的eg：<br> <img src="https://images2.imgbox.com/44/92/wowZE46G_o.png" alt="在这里插入图片描述">的执行方案</p> 
<ul><li>方案1：表空间扫描方法<br> 直接对Course表进行扫描，从第一条检索到最后一条，将满足条件的记录找出</li><li>方案2：利用Course上的Cname排序索引的方法<br> 利用排序索引可以进行诸如二分查找等快速检索，找到相应的索引项，依据指针将满足条件的记录找出</li><li>当条件更复杂时，可选择的方案还会更多，<strong>对于上述的方案，究竟用哪一个算法的程序来执行?为什么如此选择?</strong></li></ul> 
<p>物理查询运算符</p> 
<ul><li>物理查询运算符通常是关系代数操作符的一个特定实现程序</li><li>获取关系元组的操作<br> TableScan(\R) —表空间扫描算法<br> SortTableScan(\R)—表空间扫描排序算法<br> IndexScan(\R)—索引扫描算法<br> SortIndexScan(\R)—索引扫描排序算法</li></ul> 
<p>关系操作的各种实现算法</p> 
<ul><li><img src="https://images2.imgbox.com/7e/2c/8slBqffk_o.png" alt="在这里插入图片描述">，集合上的操作：<img src="https://images2.imgbox.com/3e/65/Cx0812aD_o.png" alt="在这里插入图片描述"> , 包上的操作： <img src="https://images2.imgbox.com/59/4c/sEV5dI6P_o.png" alt="在这里插入图片描述">, 积，连接： PRODUCT， JOIN</li><li>每个关系操作都有下面的算法：一趟算法、两趟算法；基于索引算法、基于散列算法、基于排序算法；</li></ul> 
<p>迭代器构造–流水化、物化；</p> 
<p>物理优化</p> 
<ul><li>就是为每一个关系代数操作选择合适的执行程序<br> <img src="https://images2.imgbox.com/81/59/H7DeFun4_o.png" alt="在这里插入图片描述"></li></ul> 
<h3><a id="2_33"></a>2.代价估算</h3> 
<p>DBMS如何衡量物理查询计划的优劣呢？</p> 
<ul><li>衡量I/O访问次数</li><li>衡量CPU的占用时间</li><li>内存使用代价(与缓冲区数目与大小的匹配)</li><li>中间结果存储代价</li><li>计算量(如搜索记录、合并记录、排序记录、字段值的计算等)</li><li>网络通信量</li></ul> 
<p>依据什么信息来计算这些方案的上述各种指标呢？</p> 
<ul><li>依据数据库的一些统计信息—存放在数据字典或系统目录中的<br> <img src="https://images2.imgbox.com/75/fe/1rsup6wW_o.png" alt="在这里插入图片描述"></li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           T 
          
         
           R 
          
         
        
          或 
         
        
          者 
         
        
          T 
         
        
          ( 
         
        
          R 
         
        
          ) 
         
        
          ： 
         
        
          关 
         
        
          系 
         
        
          R 
         
        
          的 
         
        
          元 
         
        
          组 
         
        
          数 
         
        
          目 
         
        
       
         T_R或者T(R)：关系R的元组数目 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.13889em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">者</span><span class="mord mathdefault" style="margin-right: 0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mclose">)</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">关</span><span class="mord cjk_fallback">系</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">目</span></span></span></span></span></li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           B 
          
         
           R 
          
         
        
          或 
         
        
          B 
         
        
          ( 
         
        
          R 
         
        
          ) 
         
        
          ： 
         
        
          关 
         
        
          系 
         
        
          R 
         
        
          的 
         
        
          磁 
         
        
          盘 
         
        
          块 
         
        
          数 
         
        
          目 
         
        
       
         B_R或B(R) ：关系R的磁盘块数目 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.05017em;">B</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.05017em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord cjk_fallback">或</span><span class="mord mathdefault" style="margin-right: 0.05017em;">B</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mclose">)</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">关</span><span class="mord cjk_fallback">系</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">磁</span><span class="mord cjk_fallback">盘</span><span class="mord cjk_fallback">块</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">目</span></span></span></span></span></li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           f 
          
         
           R 
          
         
        
          或 
         
        
          f 
         
        
          ( 
         
        
          R 
         
        
          ) 
         
        
          : 
         
        
          R 
         
        
          的 
         
        
          块 
         
        
          因 
         
        
          子 
         
        
          ， 
         
        
          即 
         
        
          一 
         
        
          块 
         
        
          能 
         
        
          够 
         
        
          存 
         
        
          储 
         
        
          的 
         
        
          R 
         
        
          的 
         
        
          元 
         
        
          组 
         
        
          数 
         
        
          目 
         
        
       
         f_R或f(R) : R的块因子，即一块能够存储的R的元组数目 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.10764em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right: 0.00773em;">R</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mord cjk_fallback">或</span><span class="mord mathdefault" style="margin-right: 0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">块</span><span class="mord cjk_fallback">因</span><span class="mord cjk_fallback">子</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">即</span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">块</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">够</span><span class="mord cjk_fallback">存</span><span class="mord cjk_fallback">储</span><span class="mord cjk_fallback">的</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">元</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">目</span></span></span></span></span></li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          V 
         
        
          ( 
         
        
          R 
         
        
          , 
         
        
          A 
         
        
          ) 
         
        
          : 
         
        
          R 
         
        
          中 
         
        
          属 
         
        
          性 
         
        
          A 
         
        
          出 
         
        
          现 
         
        
          不 
         
        
          同 
         
        
          值 
         
        
          的 
         
        
          数 
         
        
          目 
         
        
          ， 
         
        
          即 
         
         
         
           π 
          
         
           A 
          
         
        
          ( 
         
        
          R 
         
        
          ) 
         
        
          的 
         
        
          数 
         
        
          目 
         
        
       
         V(R, A): R中属性A出现不同值的数目，即 π_A(R) 的数目 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.22222em;">V</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault">A</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">属</span><span class="mord cjk_fallback">性</span><span class="mord mathdefault">A</span><span class="mord cjk_fallback">出</span><span class="mord cjk_fallback">现</span><span class="mord cjk_fallback">不</span><span class="mord cjk_fallback">同</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">目</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">即</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">A</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mclose">)</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">目</span></span></span></span></span></li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          S 
         
        
          C 
         
        
          ( 
         
        
          A 
         
        
          , 
         
        
          R 
         
        
          ) 
         
        
          : 
         
        
          R 
         
        
          中 
         
        
          属 
         
        
          性 
         
        
          A 
         
        
          的 
         
        
          选 
         
        
          择 
         
        
          基 
         
        
          数 
         
        
          ， 
         
        
          满 
         
        
          足 
         
        
          A 
         
        
          上 
         
        
          等 
         
        
          值 
         
        
          条 
         
        
          件 
         
        
          的 
         
        
          平 
         
        
          均 
         
        
          记 
         
        
          录 
         
        
          数 
         
        
       
         SC(A, R): R中属性A的选择基数，满足A上等值条件的平均记录数 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mord mathdefault" style="margin-right: 0.07153em;">C</span><span class="mopen">(</span><span class="mord mathdefault">A</span><span class="mpunct">,</span><span class="mspace" style="margin-right: 0.166667em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mclose">)</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mord cjk_fallback">中</span><span class="mord cjk_fallback">属</span><span class="mord cjk_fallback">性</span><span class="mord mathdefault">A</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">选</span><span class="mord cjk_fallback">择</span><span class="mord cjk_fallback">基</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">满</span><span class="mord cjk_fallback">足</span><span class="mord mathdefault">A</span><span class="mord cjk_fallback">上</span><span class="mord cjk_fallback">等</span><span class="mord cjk_fallback">值</span><span class="mord cjk_fallback">条</span><span class="mord cjk_fallback">件</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">平</span><span class="mord cjk_fallback">均</span><span class="mord cjk_fallback">记</span><span class="mord cjk_fallback">录</span><span class="mord cjk_fallback">数</span></span></span></span></span></li><li><span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
        
          b 
         
        
          ： 
         
        
          每 
         
        
          个 
         
        
          磁 
         
        
          盘 
         
        
          块 
         
        
          的 
         
        
          字 
         
        
          节 
         
        
          数 
         
        
          ； 
         
        
       
         b：每个磁盘块的字节数； 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.69444em; vertical-align: 0em;"></span><span class="mord mathdefault">b</span><span class="mord cjk_fallback">：</span><span class="mord cjk_fallback">每</span><span class="mord cjk_fallback">个</span><span class="mord cjk_fallback">磁</span><span class="mord cjk_fallback">盘</span><span class="mord cjk_fallback">块</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">字</span><span class="mord cjk_fallback">节</span><span class="mord cjk_fallback">数</span><span class="mord cjk_fallback">；</span></span></span></span></span></li><li>DBMS依据上述统计信息对DB操作的各种物理查询计划进行评估，以确定最优的计划予以执行</li></ul> 
<p>上述信息如何获得呢？</p> 
<ul><li>当一个表装入内存和创建索引的时候，统计信息不是被自动收集的，必须<strong>由DBA使用特定的命令</strong>来完成信息统计，这些命令就是收集统计信息并把其存入系统目录中的实用程序</li><li>随着表的更新操作，统计信息可能会过时，过时的统计信息会使DBMS确定方案时决策错误，因此要求DBA定期的对有频繁更新操作的Table进行统计</li><li>DBA要熟悉统计信息收集命令的使用，并定期执行</li></ul> 
<pre><code class="prism language-sql">IBM DB2使用Runstats收集统计信息
RUNSTATS <span class="token keyword">ON</span> <span class="token keyword">TABLE</span> username<span class="token punctuation">.</span>tablename
<span class="token punctuation">[</span> <span class="token keyword">WITH</span> DISTRIBUTION <span class="token punctuation">[</span> <span class="token operator">AND</span> DETAILED <span class="token punctuation">]</span>
{ INDEXES <span class="token keyword">ALL</span> <span class="token operator">|</span> <span class="token keyword">INDEX</span> indexname} <span class="token punctuation">]</span> ；

收集SCT数据库的Student表的统计信息
Runstats <span class="token keyword">on</span> <span class="token keyword">table</span> SCT<span class="token punctuation">.</span>student <span class="token punctuation">;</span>

Oracle使用<span class="token keyword">Analyze</span>命令收集统计信息并将其放入系统表中
<span class="token keyword">ANALYZE</span> { <span class="token keyword">INDEX</span> <span class="token operator">|</span> <span class="token keyword">TABLE</span> <span class="token operator">|</span> CLUSTER }
{ indexname <span class="token operator">|</span> tablename <span class="token operator">|</span> clustername }
<span class="token keyword">COMPUTE</span> <span class="token keyword">STATISTICS</span>
{ <span class="token keyword">FOR</span> <span class="token keyword">TABLE</span> <span class="token operator">|</span> <span class="token keyword">FOR</span> <span class="token keyword">ALL</span> <span class="token punctuation">[</span> INDEXED <span class="token punctuation">]</span> <span class="token keyword">COLUMNS</span> <span class="token punctuation">[</span>SIZE n<span class="token punctuation">]</span> } ；

收集SCT数据库的Student表的统计信息
<span class="token keyword">Analyze</span> <span class="token keyword">table</span> student <span class="token keyword">compute</span> <span class="token keyword">statistics</span> <span class="token keyword">for</span> <span class="token keyword">table</span> <span class="token punctuation">;</span>
</code></pre> 
<p>物理查询计划的形成：</p> 
<ul><li> <p>理想: 寻找最优的查询计划；</p> </li><li> <p>现实: 避免最差的查询计划</p> </li><li> <p>给定一个表达式E，如何计算E的元组数目T(E)以及属性A上不同值的数目V(E,A)?<br> （1）在E实际获得之前计算T(A)，V(E,A)等是很难的事情；<br> （2）因而，要“估算”，代价估算；</p> </li></ul> 
<p>投影运算的代价估算</p> 
<ul><li>估算一个投影 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           π 
          
         
           L 
          
         
        
          ( 
         
        
          R 
         
        
          ) 
         
        
       
         π_L(R) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mclose">)</span></span></span></span></span> 的大小<br> 简单: T(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           π 
          
         
           L 
          
         
        
          ( 
         
        
          R 
         
        
          ) 
         
        
       
         π_L(R) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mclose">)</span></span></span></span></span>) = T(\R)<br> 投影运算只是对列有所取舍，并未对行有所变化，如并未消除重复（物理优化的投影运算不会去重，逻辑优化的投影可以）<br> 投影运算并未减少行数，但可能有效地减少了存储结果关系的块数</li><li>例如：磁盘块大小=1024 Byte<br> R的元组长度=120 Byte, 8元组/块，T®=10,000, 则<br> B(\R) = 10000/8 = 1250;<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           π 
          
         
           L 
          
         
        
          ( 
         
        
          R 
         
        
          ) 
         
        
       
         π_L(R) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mclose">)</span></span></span></span></span>的元组长度=20 Byte, 50元组/块，则<br> B(<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
      
       
        
         
         
           π 
          
         
           L 
          
         
        
          ( 
         
        
          R 
         
        
          ) 
         
        
       
         π_L(R) 
        
       
     </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mclose">)</span></span></span></span></span>) = 10000/50 = 200;</li></ul> 
<p>不同选择运算的代价估算</p> 
<ul><li> <p>估算选择运算 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           S 
          
         
           = 
          
          
          
            σ 
           
           
           
             A 
            
           
             = 
            
           
             c 
            
           
          
         
           ( 
          
         
           R 
          
         
           ) 
          
         
        
          S = σ_{A=c}(R) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mrel mtight">=</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mclose">)</span></span></span></span></span>的大小<br> T(S) 介于 0 to T(\R)–V(R,A)+1之间—最多：A属性不同值的元组都只存在一个，剩余的都是A=c的元组<br> 估计: T(S) = T(\R) / V(R,A)—A属性不同值的元组数假设是平均分布的<br> 当不知道V(R,A)时，估计：T(S) = T(\R)/10</p> </li><li> <p>估算选择运算<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           S 
          
         
           = 
          
          
          
            σ 
           
           
           
             A 
            
           
             &lt; 
            
           
             c 
            
           
          
         
           ( 
          
         
           R 
          
         
           ) 
          
         
        
          S = σ_{A&lt;c}(R) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mrel mtight">&lt;</span><span class="mord mathdefault mtight">c</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.17737em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mclose">)</span></span></span></span></span>的大小<br> T(S) 介于 0 to T(\R) 之间—最多：所有元组都满足条件<br> 估计：T(S) = T(\R)/2—直觉，应有一半的元组，<br> 实际应用的估计： T(S) = T(\R)/3</p> </li><li> <p>估算选择运算 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           S 
          
         
           = 
          
          
          
            σ 
           
           
           
             A 
            
           
             = 
            
           
             10 
            
           
             A 
            
           
             N 
            
           
             D 
            
           
             B 
            
           
             &lt; 
            
           
             20 
            
           
          
         
           ( 
          
         
           R 
          
         
           ) 
          
         
        
          S = σ_{A=10 AND B&lt;20}(R) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mrel mtight">=</span><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right: 0.10903em;">N</span><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">D</span><span class="mord mathdefault mtight" style="margin-right: 0.05017em;">B</span><span class="mrel mtight">&lt;</span><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.17737em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mclose">)</span></span></span></span></span>的大小<br> 估计：T(S) = T(\R)/(V(R, A)*3)<br> <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           S 
          
         
           = 
          
          
          
            σ 
           
           
           
             A 
            
           
             = 
            
           
             10 
            
           
             A 
            
           
             N 
            
           
             D 
            
           
             B 
            
           
             &lt; 
            
           
             20 
            
           
          
         
           ( 
          
         
           R 
          
         
           ) 
          
         
        
          S = σ_{A=10 AND B&lt;20}(R) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mrel mtight">=</span><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mathdefault mtight">A</span><span class="mord mathdefault mtight" style="margin-right: 0.10903em;">N</span><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">D</span><span class="mord mathdefault mtight" style="margin-right: 0.05017em;">B</span><span class="mrel mtight">&lt;</span><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.17737em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mclose">)</span></span></span></span></span> = <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
          
          
            σ 
           
           
           
             B 
            
           
             &lt; 
            
           
             20 
            
           
          
         
           ( 
          
          
          
            σ 
           
           
           
             A 
            
           
             = 
            
           
             10 
            
           
          
         
           ) 
          
         
           ( 
          
         
           R 
          
         
           ) 
          
         
        
          σ_{B&lt;20}(σ_{A=10})(R) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.05017em;">B</span><span class="mrel mtight">&lt;</span><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.17737em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mrel mtight">=</span><span class="mord mtight">1</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mclose">)</span></span></span></span></span><br> A=10，得出T(S) = T(\R)/V(R,A);<br> B&lt;20，得出T(S) = T(S)/3</p> </li><li> <p>估算选择运算 <span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           S 
          
         
           = 
          
          
          
            σ 
           
           
           
             C 
            
           
             1 
            
           
             o 
            
           
             r 
            
           
             C 
            
           
             2 
            
           
          
         
           ( 
          
         
           R 
          
         
           ) 
          
         
        
          S = σ_{C1 or C2}(R) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right: 0.07153em;">C</span><span class="mord mtight">1</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right: 0.07153em;">C</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.15em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mclose">)</span></span></span></span></span>的大小<br> 估计：T(S)=n(1-(1-m1/n)(1-m2/n))<br> R有n个元组，其中有m1个满足C1, 有m2个满足C2<br> (1-m1/n)是不满足C1的那些元组，(1-m2/n)是不满足C2的那些元组<br> 两数之积是不在S中的那部分R的元组，1减去这个积就是属于S的那部分元组出现的概率。</p> </li><li> <p>估算选择运算<span class="katex--inline"><span class="katex"><span class="katex-mathml"> 
       
        
         
         
           S 
          
         
           = 
          
          
          
            σ 
           
           
           
             A 
            
           
             = 
            
           
             10 
            
           
             o 
            
           
             r 
            
           
             B 
            
           
             &lt; 
            
           
             20 
            
           
          
         
           ( 
          
         
           R 
          
         
           ) 
          
         
        
          S = σ_{A=10 or B&lt;20}(R) 
         
        
      </span><span class="katex-html"><span class="base"><span class="strut" style="height: 0.68333em; vertical-align: 0em;"></span><span class="mord mathdefault" style="margin-right: 0.05764em;">S</span><span class="mspace" style="margin-right: 0.277778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right: 0.277778em;"></span></span><span class="base"><span class="strut" style="height: 1em; vertical-align: -0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right: 0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height: 0.328331em;"><span class="" style="top: -2.55em; margin-left: -0.03588em; margin-right: 0.05em;"><span class="pstrut" style="height: 2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">A</span><span class="mrel mtight">=</span><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mathdefault mtight">o</span><span class="mord mathdefault mtight" style="margin-right: 0.02778em;">r</span><span class="mord mathdefault mtight" style="margin-right: 0.05017em;">B</span><span class="mrel mtight">&lt;</span><span class="mord mtight">2</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height: 0.17737em;"><span class=""></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right: 0.00773em;">R</span><span class="mclose">)</span></span></span></span></span>的大小<br> 估计：T(S)=n(1-(1-m1/n)(1-m2/n))<br> n = T(\R)=10000, V(R,A)=50,<br> m1=T(\R)/V(R,A)=10000/50=200;<br> m2=T(\R)/3 = 10000/3  3333<br> （有m1个满足C1, 有m2个满足C2，(1-m1/n)(1-m2/n)不满足这个条件的元组的概率，1- (1-m1/n)(1-m2/n)满足这个条件的元组的概率 )<br> —简单估计：T(S)= T(\R)/3 = 10000/3 = 3333<br> —复杂估计：<br> T(S)=10000*(1-(1-200/10000)(1-3333/10000) = 3466</p> </li><li> <p>估算连接运算 S = R(X,Y) Natural Join S(Y,Z)的大小<br> 估计：T (S)=T(\R)T(S)/max(V(R,Y),V(S,Y))<br> 假定V(R,Y)&gt;=V(S,Y),R中元组r和S中元组有相同Y值的概率=1/V(R,Y)<br> 假定V(R,Y)&lt;V(S,Y),R中元组r和S中元组有相同Y值的概率=1/V(S,Y)<br> 则，在Y上相等的概率 = 1/max(V(R,Y),V(S,Y))<br> eg：<br> 例：T(\R)=10000, T(S)=50000, V(R, Y) = 500, V(S, Y)=1000<br> 估计：T(S)=10000<em>50000/1000=500000记录<br> 例：T(\R)=10000, T(S)=50000, V(R, Y) = 2000, V(S, Y)=1000<br> 估计：T(S)=10000</em>50000/2000=250000</p> </li></ul> 
<h3><a id="3_139"></a>3.代价估算总结</h3> 
<p>T(\R)–R的元祖个数，V(R, A)—R中属性A上出现的不同值的数目<br> 判断满足单一条件元组出现的概率</p> 
<ul><li>出现等于某一个值的概率 = 1 / V(R,A), 或者简单的概率 = 1/10</li><li>出现不等于某一个值的概率 = 1 – 1/V(R,A), 或者简单的概率 = 1-1/10</li><li>出现小于或不等于某一个值的概率直觉上 = 1/2, 实际处理概率=1/3</li></ul> 
<p>判断满足多个条件的元组出现的概率</p> 
<ul><li>如果是“与”，则将满足两个条件的概率相乘</li><li>如果是“或”，则=(1-(1-m1/n)(1-m2/n)，不出现满足条件1的元组的概率(1-m1/n)，不出现满足条件2的元组的概率(1-m2/n)，二者相乘是不同时出现的概率，<strong>则1- (1-m1/n)(1-m2/n)即为去掉不同时出现的概率</strong>，即为或条件的概率。</li></ul> 
<p>复杂的表达式可以依上原则进行估算，确定估算公式</p> 
<h3><a id="4_153"></a>4.小结</h3> 
<p><img src="https://images2.imgbox.com/13/b9/5wMDbZOb_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5b3ce1a9c3dab3302d9843b593b3600a/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">ESP32定时器</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/76e6b53490480e0f20ac0330f6ae350c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">在mv 过程中，不小心中断了怎么办，有影响吗</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>