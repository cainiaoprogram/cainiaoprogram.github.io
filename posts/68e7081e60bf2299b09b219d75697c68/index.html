<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis客户端 - RedisSerializer - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis客户端 - RedisSerializer" />
<meta property="og:description" content="原文首更地址，阅读效果更佳！
Redis客户端 - RedisSerializer | CoderMast编程桅杆https://www.codermast.com/database/redis/redistemplate-redis-serializer.html
前景回顾
在上一篇中，我们实现了一个简单的案例，操作一个 String 类型的数据，插入了一个 name = codermast 的数据到Redis。
使用redis-cli客户端连接对应的Redis服务器后，按道理来讲get name这个指令的返回结果应该是 codermast
redis-cli客户端查看
返回的结果是无，这是为什么呢？使用可视化工具查看一下，看看到底数据是否存储在Redis服务器中。
使用可视化工具查看
可以明显的看到，所存储的 key 之前加上了一段字符，但是从代码中看，存储的 key 为 &#34;name&#34;，但是实际存储的 key 是 \xac\xed\x00\x05t\x00\x04name，而且里面的 value 也做了同样的处理 \xac\xed\x00\x05t\x00\x09codermast
出现这种现象的原因是什么呢？这是因为 RedisTemplate 在底层将数据序列化处理以后，才存储到 Redis 服务器中。
RedisTemplate 可以接收任意 Object 作为值写入 Redis ，只不过在写入之前会把 Object 序列化成为字节形式，默认是采用 JDK 序列化，得到的结果就如图所示。
缺点
可读性差资源占用高 既然这样可读性又差，资源占用又高，那么如何解决这些问题呢？我们可以通过自定义 RedisTemplate 序列化的方式来解决。
#编写一个 RedisConfig 配置类 @Configuration public class RedisTemplate{ @Bean public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory){ // 1.创建RedisTemplate对象 RedisTemplate&lt;String ,Object&gt; redisTemplate = new RedisTemplate&lt;&gt;(); // 2." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/68e7081e60bf2299b09b219d75697c68/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-06-17T18:09:43+08:00" />
<meta property="article:modified_time" content="2023-06-17T18:09:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis客户端 - RedisSerializer</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p style="text-align:center;"><span style="color:#fe2c24;">原文首更地址，阅读效果更佳！</span></p> 
<p><a class="has-card" href="https://www.codermast.com/database/redis/redistemplate-redis-serializer.html" rel="nofollow" title="Redis客户端 - RedisSerializer | CoderMast编程桅杆"><span class="link-card-box"><span class="link-title">Redis客户端 - RedisSerializer | CoderMast编程桅杆</span><span class="link-link"><img class="link-link-icon" src="https://images2.imgbox.com/f0/30/v0lcd22o_o.png" alt="icon-default.png?t=N5F7">https://www.codermast.com/database/redis/redistemplate-redis-serializer.html</span></span></a></p> 
<p>前景回顾</p> 
<p>在上一篇中，我们实现了一个简单的案例，操作一个 String 类型的数据，插入了一个 name = codermast 的数据到Redis。</p> 
<p>使用redis-cli客户端连接对应的Redis服务器后，按道理来讲<code>get name</code>这个指令的返回结果应该是 <code>codermast</code></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e3/7b/qQJjxxyq_o.png"></p> 
<p>redis-cli客户端查看</p> 
<p>返回的结果是无，这是为什么呢？使用可视化工具查看一下，看看到底数据是否存储在Redis服务器中。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/25/53/TwHjBmai_o.png"></p> 
<p>使用可视化工具查看</p> 
<p>可以明显的看到，所存储的 key 之前加上了一段字符，但是从代码中看，存储的 key 为 "name"，但是实际存储的 key 是 <code>\xac\xed\x00\x05t\x00\x04name</code>，而且里面的 value 也做了同样的处理 <code>\xac\xed\x00\x05t\x00\x09codermast</code></p> 
<p>出现这种现象的原因是什么呢？这是因为 RedisTemplate 在底层将数据序列化处理以后，才存储到 Redis 服务器中。</p> 
<p>RedisTemplate 可以接收任意 Object 作为值写入 Redis ，只不过在写入之前会把 Object 序列化成为字节形式，默认是采用 JDK 序列化，得到的结果就如图所示。</p> 
<p>缺点</p> 
<ul><li>可读性差</li><li>资源占用高</li></ul> 
<p>既然这样可读性又差，资源占用又高，那么如何解决这些问题呢？我们可以通过自定义 RedisTemplate 序列化的方式来解决。</p> 
<h3 id="编写一个-redisconfig-配置类"><a href="https://www.codermast.com/database/redis/redistemplate-redis-serializer.html#%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA-redisconfig-%E9%85%8D%E7%BD%AE%E7%B1%BB" rel="nofollow" title="#">#</a>编写一个 RedisConfig 配置类</h3> 
<p></p> 
<pre><code>@Configuration
public class RedisTemplate{
    @Bean
    public RedisTemplate&lt;String, Object&gt; redisTemplate(RedisConnectionFactory factory){

        // 1.创建RedisTemplate对象
        RedisTemplate&lt;String ,Object&gt; redisTemplate = new RedisTemplate&lt;&gt;();

        // 2.设置连接⼯⼚
        redisTemplate.setConnectionFactory(factory);
        
        // 3.创建序列化对象
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
        GenericJackson2JsonRedisSerializer genericJackson2JsonRedisSerializer = new GenericJackson2JsonRedisSerializer();
        
        // 4.设置 key 和 hashKey 采⽤ String 的序列化⽅式
        redisTemplate.setKeySerializer(stringRedisSerializer);
        redisTemplate.setHashKeySerializer(stringRedisSerializer);
        
        // 5.设置 value 和 hashValue 采⽤ json的 序列化⽅式
        redisTemplate.setValueSerializer(genericJackson2JsonRedisSerializer);
        redisTemplate.setHashValueSerializer(genericJackson2JsonRedisSerializer);

        return redisTemplate;
    }
}
</code></pre> 
<p>注意</p> 
<p>我们自定义的配置类中，使用到了 Jackson 序列化类，所以在使用之前需要导入 jackson-datebind 这个依赖项。</p> 
<p></p> 
<pre><code>&lt;!-- jackson-databind 依赖 --&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> 
<h3 id="自定义序列化方式"><a href="https://www.codermast.com/database/redis/redistemplate-redis-serializer.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F" rel="nofollow" title="#">#</a>自定义序列化方式</h3> 
<p>自定义的序列化方式也加进去了对引用类型的序列化，我们来实际测试一下。</p> 
<ul><li>编写一个 User 类</li></ul> 
<p></p> 
<pre><code>@Data
public User{
    Integer age;
    String name;
}
</code></pre> 
<blockquote> 
 <p>类中属性需要给出 set 和 get方法</p> 
</blockquote> 
<ul><li>将 User 对象存储至 Redis</li></ul> 
<p></p> 
<pre><code>@Test
void testObject(){
    User user = new User();
    user.setAge(18);
    user.setName("codermast");

    // 插入一条 Object 类型的数据
    redisTemplate.opsForValue().set("user",user);

    // 获取一条 Object 类型的数据
    User user_coder = (User)redisTemplate.opsForValue().get("user");

    System.out.println(user_coder);
}
</code></pre> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/24/f8/pBMFiPlf_o.png"></p> 
<p>  </p> 
<p>虽然 JSON 的序列化方式可以满足我们存储对象的需求，为了在反序列化时知道对象的类型，将对象的类路径地址也序列化进 JSON 结果中，存入 Redis ，会带来额外的资源消耗。</p> 
<p>针对如图所示的特殊情况，类路径地址比我们真实的数据内容还大，造成了极大的资源浪费。</p> 
<h3 id="优化自定义序列化"><a href="https://www.codermast.com/database/redis/redistemplate-redis-serializer.html#%E4%BC%98%E5%8C%96%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BA%8F%E5%88%97%E5%8C%96" rel="nofollow" title="#">#</a>优化自定义序列化</h3> 
<p>为了节省内存空间，通常情况下不会使用 JSON 序列化器来处理 Value ，而是统一使用 String 序列化器，要求只能存储 String 类型的 key 和 value。当要存储 Java 对象时，手动完成对象的序列化和反序列化。</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/a0/96/JLEWLPDB_o.png"></p> 
<p>  </p> 
<p>Spring 默认提供了一个 StringRedisTemplate 类，它的 key 和 value 的序列化方式默认就是 String 方式，省去了我们自定义的 RedisTemplate 的过程。</p> 
<p>现在在存储数据之前需要进行手动序列化，在获取数据以后，需要手动反序列化对象。</p> 
<h3 id="小结"><a href="https://www.codermast.com/database/redis/redistemplate-redis-serializer.html#%E5%B0%8F%E7%BB%93" rel="nofollow" title="#">#</a>小结</h3> 
<p>RedisTemplate 的两种序列化实践方案</p> 
<ol><li>方案一 
  <ul><li>自定义RedisTemplate</li><li>修改RedisTemplate 的序列化器为 GenericJackson2JsonRedisSerializer</li></ul></li><li>方案二 
  <ul><li>使用 StringRedisTemplate</li><li>写入 Redis 之前，将对象手动序列化为 JSON</li><li>读取数据以后，将 JSON 手动反序列化为对象</li></ul></li></ol> 
<p>提示</p> 
<p>上述仅说明了操作 String 类型的数据，操作 Hash、List、Set、SortedSet类型时，使用对应的 ops 对象即可操作。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/dbe0b9169306095e72af170974ffcfa1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LaTeX数学公式-详细教程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/9014525ca62ace9cbb771c9751127b3e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Yum源配置</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>