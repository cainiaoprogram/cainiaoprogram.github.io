<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HTTP协议详解 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HTTP协议详解" />
<meta property="og:description" content="文章目录 HTTP协议详解HTTP协议的特点：HTTP协议详解之URLHTTP协议详解之请求方法HTTP协议详解之请求报文请求行请求首部字段AcceptAccept-CharsetAccept-EncodingAccept-LanguageAuthorizationExpectFromHostIf-xxxxMax-ForwardsProxy-AuthorizationRangeRefererTEUser-Agent HTTP协议详解 HTTP协议的特点： 支持客户/服务器模式。简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。单请求：每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP协议详解之URL HTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下：
http://host[&#34;:&#34;port][abs_path]
http表示要通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。 例如：
输入：www.guet.edu.cn
浏览器自动转换成：http://www.guet.edu.cn/最终的URL：http:192.168.0.116:8080/index.jsp HTTP协议详解之请求方法 HTTP协议详解之请求报文 下图是HTTP请求报文的结构.
请求行 以一个方法符号开头，以空格或斜杠分开，后面跟着请求的URI和协议的版本。
格式如下：Method Request-URI HTTP-Version CRLF
Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。 例如：GET / 123.jpg / HTTP1.1
请求首部字段 请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。
Accept Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 type/subtype 这种形式，一次指定多种媒体类型。
常见accept媒体类型有：
- 文本文件
text/html, text/plain, text/css …
application/xhtml&#43;xml, application/xml …
- 图片文件
image/jpeg, image/gif, image/png …
- 视频文件
video/mpeg, video/quicktime …
- 应用程序使用的二进制文件
application/octet-stream, application/zip …
Accept-Charset Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/83e85d46beeb57c2d6c13ea4fa7c7fd2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-02-02T17:43:42+08:00" />
<meta property="article:modified_time" content="2020-02-02T17:43:42+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HTTP协议详解</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#HTTP_1" rel="nofollow">HTTP协议详解</a></li><li><ul><li><a href="#HTTP_2" rel="nofollow">HTTP协议的特点：</a></li><li><a href="#HTTPURL_9" rel="nofollow">HTTP协议详解之URL</a></li><li><a href="#HTTP_21" rel="nofollow">HTTP协议详解之请求方法</a></li><li><a href="#HTTP_23" rel="nofollow">HTTP协议详解之请求报文</a></li><li><ul><li><a href="#_27" rel="nofollow">请求行</a></li><li><a href="#_37" rel="nofollow">请求首部字段</a></li><li><ul><li><a href="#Accept_40" rel="nofollow">Accept</a></li><li><a href="#AcceptCharset_53" rel="nofollow">Accept-Charset</a></li><li><a href="#AcceptEncoding_56" rel="nofollow">Accept-Encoding</a></li><li><a href="#AcceptLanguage_68" rel="nofollow">Accept-Language</a></li><li><a href="#Authorization_71" rel="nofollow">Authorization</a></li><li><a href="#Expect_74" rel="nofollow">Expect</a></li><li><a href="#From_91" rel="nofollow">From</a></li><li><a href="#Host_94" rel="nofollow">Host</a></li><li><a href="#Ifxxxx_101" rel="nofollow">If-xxxx</a></li><li><a href="#MaxForwards_109" rel="nofollow">Max-Forwards</a></li><li><a href="#ProxyAuthorization_114" rel="nofollow">Proxy-Authorization</a></li><li><a href="#Range_117" rel="nofollow">Range</a></li><li><a href="#Referer_121" rel="nofollow">Referer</a></li><li><a href="#TE_128" rel="nofollow">TE</a></li><li><a href="#UserAgent_133" rel="nofollow">User-Agent</a></li></ul> 
   </li></ul> 
  </li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="HTTP_1"></a>HTTP协议详解</h2> 
<h3><a id="HTTP_2"></a>HTTP协议的特点：</h3> 
<ol><li>支持客户/服务器模式。</li><li>简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。</li><li>灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。</li><li>单请求：每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</li><li>无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</li></ol> 
<h3><a id="HTTPURL_9"></a>HTTP协议详解之URL</h3> 
<p>HTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下：<br> <strong>http://host[":"port][abs_path]</strong></p> 
<ul><li>http表示要通过HTTP协议来定位网络资源；</li><li>host表示合法的Internet主机域名或者IP地址；</li><li>port指定一个端口号，为空则使用缺省端口80；</li><li>abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。</li></ul> 
<p>例如：</p> 
<ol><li>输入：www.guet.edu.cn<br> 浏览器自动转换成：http://www.guet.edu.cn/</li><li>最终的URL：http:192.168.0.116:8080/index.jsp</li></ol> 
<h3><a id="HTTP_21"></a>HTTP协议详解之请求方法</h3> 
<p><img src="https://images2.imgbox.com/ee/74/shwoFgi7_o.png" alt="method"></p> 
<h3><a id="HTTP_23"></a>HTTP协议详解之请求报文</h3> 
<p>下图是HTTP请求报文的结构.<br> <img src="https://images2.imgbox.com/b2/6b/bOqBUwYz_o.png" alt="qingqiu"></p> 
<h4><a id="_27"></a>请求行</h4> 
<p>以一个方法符号开头，以空格或斜杠分开，后面跟着请求的URI和协议的版本。<br> 格式如下：Method Request-URI HTTP-Version CRLF</p> 
<ul><li>Method表示请求方法；</li><li>Request-URI是一个统一资源标识符；</li><li>HTTP-Version表示请求的HTTP协议版本；</li><li>CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。</li></ul> 
<p>例如：<strong>GET / 123.jpg / HTTP1.1</strong></p> 
<h4><a id="_37"></a>请求首部字段</h4> 
<p>请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。<br> <img src="https://images2.imgbox.com/13/42/d6TW7b5U_o.png" alt="首部"></p> 
<h5><a id="Accept_40"></a>Accept</h5> 
<p>Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级。可使用 <strong>type/subtype</strong> 这种形式，一次指定多种媒体类型。<br> <img src="https://images2.imgbox.com/85/b1/4YOlUYDo_o.png" alt="acpet"><br> 常见accept媒体类型有：<br> - 文本文件<br> text/html, text/plain, text/css …<br> application/xhtml+xml, application/xml …<br> - 图片文件<br> image/jpeg, image/gif, image/png …<br> - 视频文件<br> video/mpeg, video/quicktime …<br> - 应用程序使用的二进制文件<br> application/octet-stream, application/zip …</p> 
<h5><a id="AcceptCharset_53"></a>Accept-Charset</h5> 
<p>Accept-Charset 首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级。<br> 如：<strong>Accept-Charset: iso-8859-5, unicode-1-1;q=0.8</strong></p> 
<h5><a id="AcceptEncoding_56"></a>Accept-Encoding</h5> 
<p>Accept-Encoding 首部字段用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码。采用权重 q 值来表示相对优先级，这点与首部字段 Accept 相同。另外，也可使用星号（*）作为通配符，指定任意的编码格式。<br> 如：<strong>Accept-Encoding: gzip, deflate</strong><br> 试举几个内容编码的例子：<br> - gzip<br> 由文件压缩程序 gzip（GNU zip）生成的编码格式（RFC1952），采用 Lempel-Ziv 算法（LZ77）及 32 位循环冗余校验（Cyclic Redundancy Check，通称 CRC）。<br> - compress<br> 由 UNIX 文件压缩程序 compress 生成的编码格式，采用 Lempel-Ziv-Welch 算法（LZW）。<br> - deflate<br> 组合使用 zlib 格式（RFC1950）及由 deflate 压缩算法（RFC1951）生成的编码格式。<br> - identity<br> 不执行压缩或不会变化的默认编码格式</p> 
<h5><a id="AcceptLanguage_68"></a>Accept-Language</h5> 
<p>首部字段 Accept-Language 用来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集。和 Accept 首部字段一样，按权重值 q 来表示相对优先级。<br> 如：<strong>Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3</strong></p> 
<h5><a id="Authorization_71"></a>Authorization</h5> 
<p>首部字段 Authorization 是用来告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异。<br> <img src="https://images2.imgbox.com/00/11/sANv9J6a_o.png" alt="renzheng"></p> 
<h5><a id="Expect_74"></a>Expect</h5> 
<p>客户端使用首部字段 Expect 来告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回<br> 状态码 417 Expectation Failed。<br> 客户端可以利用该首部字段，写明所期望的扩展。虽然 HTTP/1.1 规范只定义了 100-continue。<br> 如：<strong>Expect: 100-continue</strong><br> <strong>100-continue</strong>：<br> 　　1、http 100-continue用于客户端在发送POST数据给服务器前，征询服务器情况，看服务器是否处理POST的数据，如果不处理，客户<br> 　　 端则不上传POST数据，如果处理，则POST上传数据。在现实应用中，通过在POST大数据时，才会使用100-continue协议。<br> 　　2、客户端策略。<br> 　　　　1）如果客户端有POST数据要上传，可以考虑使用100-continue协议。加入头{“Expect”:“100-continue”}<br> 　　　　2）如果没有POST数据，不能使用100-continue协议，因为这会让服务端造成误解。<br> 　　　　3）并不是所有的Server都会正确实现100-continue协议，如果Client发送Expect:100-continue消息后，在timeout时间内无响应，<br> 　　　　Client需要立马上传POST数据。<br> 　　　　4）有些Server会错误实现100-continue协议，在不需要此协议时返回100，此时客户端应该忽略。<br> 　　3、服务端策略。<br> 　　　　1）正确情况下，收到请求后，返回100或错误码。<br> 　　　　2）如果在发送100-continue前收到了POST数据（客户端提前发送POST数据），则不发送100响应码(略去)。</p> 
<h5><a id="From_91"></a>From</h5> 
<p>首部字段 From 用来告知服务器使用用户代理的用户的电子邮件地址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。使用代理时，应尽可能包含 From 首部字段（但可能会因代理不同，将电子邮件地址记录在 User-Agent 首部字段内）。<br> <img src="https://images2.imgbox.com/20/87/2vkuhPXP_o.png" alt="from"></p> 
<h5><a id="Host_94"></a>Host</h5> 
<p>首部字段 Host 会告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请<br> 求内的首部字段。<br> <img src="https://images2.imgbox.com/90/47/sFbPQZ4T_o.png" alt="host"><br> 首部字段 Host 和以单台服务器分配多个域名的虚拟主机的工作机制有很密切的关联，这是首部字段 Host 必须存在的意义。请求被发送至服务器时，请求中的主机名会用 IP 地址直接替换解决。但如果这时，<strong>相同的 IP 地址下部署运行着多个域名</strong>，那么服务器就会无法理解究竟是哪个域名对应的请求。因此，<strong>就需要使用首部字段 Host 来明确指出请求的主机名</strong>。<br> 若服务器未设定主机名，那直接发送一个空值即可。如下所示。<br> <img src="https://images2.imgbox.com/6e/82/irxbM7js_o.png" alt="kong"></p> 
<h5><a id="Ifxxxx_101"></a>If-xxxx</h5> 
<p>形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求。</p> 
<ul><li>If-Match:只有当 If-Match 的字段值跟 ETag 值匹配一致时，服务器才会接受请求反之，则返回状态码 412 Precondition Failed 的响<br> 应。</li><li>If-Modified-Since:如果在 If-Modified-Since 字段指定的日期时间后，资源发生了更新，服务器会接受请求,而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应。</li><li>If-None-Match:只有在 If-None-Match 的字段值与 ETag 值不一致时，可处理该请求。与 If-Match 首部字段的作用相反</li><li>If-Range:它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源。</li><li>If-Unmodified-Since:首部字段 If-Unmodified-Since 和首部字段 If-Modified-Since 的作用相反。它的作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回。</li></ul> 
<h5><a id="MaxForwards_109"></a>Max-Forwards</h5> 
<p>通过 TRACE 方法或 OPTIONS 方法，发送包含首部字段 Max-Forwards 的请求时，该字段以十进制整数形式指定可经过的服务器最大数目。服务器在往下一个服务器转发请求之前，Max-Forwards 的值减 1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应。<br> 使用 HTTP 协议通信时，请求可能会经过代理等多台服务器。途中，如果代理服务器由于某些原因导致请求转发失败，客户端也就等不到服务器返回的响应了。对此，我们无从可知。<br> 因此可以灵活使用首部字段 Max-Forwards，针对以上问题产生的原因展开调查。由于当 Max-Forwards 字段值为 0 时，服务器就会立即返回响应，由此我们至少可以对以那台服务器为终点的传输路径的通信状况有所把握。<br> <img src="https://images2.imgbox.com/dc/9a/kJJUG6zw_o.png" alt="maxfor"></p> 
<h5><a id="ProxyAuthorization_114"></a>Proxy-Authorization</h5> 
<p>接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段Proxy-Authorization 的请求，以告知服务器认证所需要的信息。这个行为是与客户端和服务器之间的 HTTP 访问认证相类似的，不同之处在于，认证行为发生在客户端与代理之间。客户端与服务器之间的认证，使用首部字段 Authorization 可起到相同作用。<br> 如：Proxy-Authorization: Basic dGlwOjkpNLAGfFY5</p> 
<h5><a id="Range_117"></a>Range</h5> 
<p>例子：<strong>Range: bytes=5001-10000</strong><br> 对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。上面的示例表示请求获取从第 5001 字节至第10000 字节的资源。<br> 接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源。</p> 
<h5><a id="Referer_121"></a>Referer</h5> 
<p>首部字段 Referer 会告知服务器请求的<strong>原始资源的 URI</strong>。（应该是指从哪个页面跳转过来的）<br> 比如：在https://blog.csdn.net/shenqueying/article/details/79426884网页中有一个https://www.sojson.com/blog/58.html链接，如下图所示：<br> <img src="https://images2.imgbox.com/76/64/FHOVPNBR_o.png" alt="11111"><br> 点击这个https://www.sojson.com/blog/58.html，在该http请求中的header信息里就有：<br> Referer=https://blog.csdn.net/shenqueying/article/details/79426884<br> <img src="https://images2.imgbox.com/f3/c8/FwCqVfaB_o.png" alt="12dfgsd"></p> 
<h5><a id="TE_128"></a>TE</h5> 
<p>首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级。它和首部字段 Accept-Encoding 的功能很相像，但是用于传输编码。<br> 如：<strong>TE: gzip, deflate;q=0.5</strong><br> 首部字段 TE 除指定传输编码之外，还可以指定伴随 trailer 字段的分块传输编码的方式。应用后者时，只需把 trailers 赋值给该字段值。<br> 如：<strong>TE: trailers</strong></p> 
<h5><a id="UserAgent_133"></a>User-Agent</h5> 
<p>首部字段 User-Agent 会将创建请求的浏览器和用户代理名称等信息传达给服务器。<br> 例如QQ浏览器访问网页时，就会带上QQ浏览器的信息.<br> <img src="https://images2.imgbox.com/08/d8/nzZyM7ie_o.png" alt="qq"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b0f3d00af4c000f0f7f77d125c132524/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">EasyUI框架02——datagrid</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8a9dbaa2638f4ca6294067b6d9be9054/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">v-for</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>