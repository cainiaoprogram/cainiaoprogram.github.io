<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>selenium 元素定位 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="selenium 元素定位" />
<meta property="og:description" content="开头 简单介绍selenium的元素定位，主要集中在 xpath中
xpath XML Path Language用于解析html和xml xpath 的缺点比css慢，是从头到尾的便利
常用的表达式
常用在网页端进行测试，在想匹配的地方， 打开控制台，进行匹配测试, 可以先用clear() 清除控制台无用信息
在控制台中 匹配想要的结果并查看,需要写完xpath定位式之后填写回车
匹配最后一个的 xpath 写法：
$x(&#34;//div[@class=&#39;s_order&#39;]/a[last()]&#34;) # 匹配列表元素的最后一个 $x(&#34;//div[@class=&#39;s_order&#39;]/a[last()-1]&#34;) # 匹配列表元素的倒数第二个 测试例子 # xpath的使用 from lxml import etree html = &#39;&#39;&#39; &lt;div id=&#34;container&#34;&gt; &lt;ul class=&#34;list&#34;&gt; &lt;li class=&#34;item-0&#34;&gt;first item&lt;/li&gt; &lt;li class=&#34;item-1&#34;&gt;&lt;a href=&#34;link2.html&#34;&gt;second item&lt;/a&gt;&lt;/li&gt; &lt;li class=&#34;item-0 active&#34;&gt;&lt;a href=&#34;link3.html&#34;&gt;&lt;span class=&#34;bold&#34;&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; &lt;li class=&#34;item-1 active&#34;&gt;&lt;a href=&#34;link4.html&#34;&gt;fourth item&lt;/a&gt;&lt;/li&gt; &lt;li class=&#34;item-0&#34;&gt;&lt;a href=&#34;link5.html&#34;&gt;fifth item&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &#39;&#39;&#39; doc = etree.HTML(html) # 拿到指定的标签下的原代码，因为etree.tostring是拿到brary所以需要decode转为str ul_list = doc." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/ff9bc9138881d39dbf0361513e913290/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-05-11T16:34:37+08:00" />
<meta property="article:modified_time" content="2023-05-11T16:34:37+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">selenium 元素定位</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h3 id="开头">开头</h3> 
<p>简单介绍selenium的元素定位，主要集中在 xpath中</p> 
<h3 id="xpath">xpath</h3> 
<ul><li>XML Path Language</li><li>用于解析html和xml</li></ul> 
<p>xpath 的缺点比css慢，是从头到尾的便利</p> 
<p>常用的表达式</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/77/97/stdLapVT_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/f4/80/cUio6JLE_o.png"></p> 
<p>常用在网页端进行测试，在想匹配的地方， 打开控制台，进行匹配测试, 可以先用clear() 清除控制台无用信息</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/32/0b/DHYrw1vp_o.png"></p> 
<p>在控制台中 匹配想要的结果并查看,需要写完xpath定位式之后填写回车</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/19/e6/jkM8ALBP_o.png"></p> 
<p>匹配最后一个的 xpath 写法：</p> 
<pre><code class="hljs">$x("//div[@class='s_order']/a[last()]") # 匹配列表元素的最后一个
$x("//div[@class='s_order']/a[last()-1]") # 匹配列表元素的倒数第二个</code></pre> 
<h3 id="测试例子">测试例子</h3> 
<pre><code class="hljs"># xpath的使用
from lxml import etree

html = '''
&lt;div id="container"&gt;
    &lt;ul class="list"&gt;
         &lt;li class="item-0"&gt;first item&lt;/li&gt;
         &lt;li class="item-1"&gt;&lt;a href="link2.html"&gt;second item&lt;/a&gt;&lt;/li&gt;
         &lt;li class="item-0 active"&gt;&lt;a href="link3.html"&gt;&lt;span class="bold"&gt;third item&lt;/span&gt;&lt;/a&gt;&lt;/li&gt;
         &lt;li class="item-1 active"&gt;&lt;a href="link4.html"&gt;fourth item&lt;/a&gt;&lt;/li&gt;
         &lt;li class="item-0"&gt;&lt;a href="link5.html"&gt;fifth item&lt;/a&gt;&lt;/li&gt;
     &lt;/ul&gt;
 &lt;/div&gt;
'''
doc = etree.HTML(html)
# 拿到指定的标签下的原代码，因为etree.tostring是拿到brary所以需要decode转为str
ul_list = doc.xpath('//ul[@class="list"]')
ul_html = etree.tostring(ul_list[0]).decode('utf-8')
# print(ul_html) # 拿到ul下的

li_list = doc.xpath('//li')
for li_s in li_list:
    li_html = etree.tostring(li_s).decode('utf-8') # 拿到li下的所有文字


# 父节点的选择 在这里我们可以用 .. 来获取父节点。
par_list = doc.xpath('//ul[@class="list"]/..')
par_html = etree.tostring(par_list[0]).decode('utf-8')
# print(par_list)
# print(par_html)

# 属性匹配                              
# result = doc.xpath('//li[@class="item-0"]')
# for i in result:
#     print(i.xpath('.//text()'))

# 文本获取 只要在Li下的文本都匹配
result = doc.xpath('//li')
# for i in result:
#     # print(i.xpath('.//text()')) # // 拿到全部的文本
#     print(i.xpath('./text()')) # 拿到 只在这个标签下的 text

# 拿到标签里面的属性
# for i in result:
#     print(i.xpath('./a/@href'))

# 多属性匹配
text = '''
&lt;li class="li li-first" name="item"&gt;&lt;a href="https://ask.hellobi.com/link.html"&gt;first item&lt;/a&gt;&lt;/li&gt;
'''
html = etree.HTML(text)
result = html.xpath('//li[contains(@name, "item")]/a/@href')
print(result)

# 如果还含有name,有and
result = html.xpath('//li[contains(@class, "li") and @name="item"]/a/@href')
print(result)

# 读一个html文件，构建一个xml dom树
# html = etree.parse('./test.html', etree.HTMLParser())
# result = html.xpath('//ul//a')
# print(result)

html = '''
&lt;div class="wrap"&gt;
    Hello, World
    &lt;p&gt;This is a paragraph.&lt;/p&gt;
&lt;/div&gt;
'''
# print(html)
html = etree.HTML(html)
resp = html.xpath('//div[@class="wrap"]/text()') # 只提取当前标签下的
print(resp)
############两个办法提取某标签下全部文本#########
resps = html.xpath('//div[@class="wrap"]//text()')
print(resps)
con = []
for x in resps:
    con.append(x.strip()) # 得到的text会去掉所有换行
print(con)
# print('--')
re_ = ''.join(con)
print(re_)

############2222#########
print('='*30)
resps = html.xpath('//div[@class="wrap"]') # 提取全部的文本
# print(resps)
con = []
for x in resps:
    # print(x.xpath('string(.)'))
    con.append(x.xpath('string(.)').strip()) # 会更完整的保留text 
print(con)
# print('--')
re_ = ''.join(con)
print(re_)

# xpath取其中几个使用position 的使用，可以用 &gt; 或者 &lt;
# path："//*[@id='nav']/ul/li[position()&gt;1 and position()&lt;7]"
resps = html.xpath('//td[@valign="top"][2]/div[@class="ut"]/span[position()&gt;1 and contains(@class, "ctt")]')


# 关于xpath下载到二进制的问题
with open('t1.html', 'r', encoding='utf-8') as f:
    html = f.read()
html = bytes(bytearray(html, encoding='utf-8')) # 撞成二进制的格式然后bytearray() 方法返回一个新字节数组。转为bytearray数组之后再转为二进制B 最后可以生成dom树
# 参考 https://blog.csdn.net/songhao8080/article/details/103670324 如果text读取不出来，就需要放二进制读取
# scrapy中response.body 与 response.text区别
# body http响应正文， byte类型
# text 文本形式的http正文，str类型，它是response.body经过response.encoding经过解码得到</code></pre> 
<p>完。<strong> </strong></p> 
<p><strong>最后：</strong>下方这份完整的软件测试视频学习教程已经整理上传完成，朋友们如果需要可以自行免费领取<span style="color:#fe2c24;"><strong>【保证100%免费】</strong></span></p> 
<p class="img-center"><img alt="在这里插入图片描述" src="https://images2.imgbox.com/94/16/klsavDxv_o.png"></p> 
<h3>软件测试面试文档</h3> 
<p>我们学习必然是为了找到高薪的工作，下面这些面试题是来自阿里、腾讯、字节等一线互联网大厂最新的面试资料，并且有字节大佬给出了权威的解答，刷完这一套面试资料相信大家都能找到满意的工作。</p> 
<p class="img-center"><img alt="图片" src="https://images2.imgbox.com/49/5f/ZqW1JWPv_o.png"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/02/2f/T02nlYbU_o.gif"></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/e8/6e/mWW3xtHZ_o.gif"></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a4f55cc68f2effd28420f15b0afdac9c/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">计算机网络基础（四）—— 什么是TCP/IP协议？是两种网络协议？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/22849eb9c593b3f9a5ec13853e140a83/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Chrome浏览器更新字体看不清的最终解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>