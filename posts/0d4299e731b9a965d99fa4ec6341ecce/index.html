<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>自定义FragmentNavigator解决Navigation重复创建的问题 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="自定义FragmentNavigator解决Navigation重复创建的问题" />
<meta property="og:description" content="最近在学习用Navigation管理Fragment时,我们会发现在切换Fragment的时候并不会像ViewPager一样复用Fragment而是会创建新的Fragment,而这样的后果就是每次切还都会重新请求数据,这样一是用户体验会不好,二是加重了服务器的负担。所以需要想办法搞一搞o(╥﹏╥)o。。。
在查看源码后我们得知，之所以会重复创建Fragment是因为在FragmentNavigator中并没有对Fragment做复用，而是在切换时直接移除了前一个Fragment(源代码如下):
@Nullable @Override public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) { if (mFragmentManager.isStateSaved()) { Log.i(TAG, &#34;Ignoring navigate() call: FragmentManager has already&#34; &#43; &#34; saved its state&#34;); return null; } String className = destination.getClassName(); if (className.charAt(0) == &#39;.&#39;) { className = mContext.getPackageName() &#43; className; } final Fragment frag = instantiateFragment(mContext, mFragmentManager, className, args); frag.setArguments(args); final FragmentTransaction ft = mFragmentManager.beginTransaction(); int enterAnim = navOptions !" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/0d4299e731b9a965d99fa4ec6341ecce/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-04-20T16:31:36+08:00" />
<meta property="article:modified_time" content="2022-04-20T16:31:36+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">自定义FragmentNavigator解决Navigation重复创建的问题</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>最近在学习用Navigation管理Fragment时,我们会发现在切换Fragment的时候并不会像ViewPager一样复用Fragment而是会创建新的Fragment,而这样的后果就是每次切还都会重新请求数据,这样一是用户体验会不好,二是加重了服务器的负担。所以需要想办法搞一搞o(╥﹏╥)o。。。</p> 
<p>在查看源码后我们得知，之所以会重复创建Fragment是因为在FragmentNavigator中并没有对Fragment做复用，而是在切换时直接移除了前一个Fragment(源代码如下):</p> 
<pre><code class="language-java">@Nullable
    @Override
    public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args,
            @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {
        if (mFragmentManager.isStateSaved()) {
            Log.i(TAG, "Ignoring navigate() call: FragmentManager has already"
                    + " saved its state");
            return null;
        }
        String className = destination.getClassName();
        if (className.charAt(0) == '.') {
            className = mContext.getPackageName() + className;
        }
        final Fragment frag = instantiateFragment(mContext, mFragmentManager,
                className, args);
        frag.setArguments(args);
        final FragmentTransaction ft = mFragmentManager.beginTransaction();

        int enterAnim = navOptions != null ? navOptions.getEnterAnim() : -1;
        int exitAnim = navOptions != null ? navOptions.getExitAnim() : -1;
        int popEnterAnim = navOptions != null ? navOptions.getPopEnterAnim() : -1;
        int popExitAnim = navOptions != null ? navOptions.getPopExitAnim() : -1;
        if (enterAnim != -1 || exitAnim != -1 || popEnterAnim != -1 || popExitAnim != -1) {
            enterAnim = enterAnim != -1 ? enterAnim : 0;
            exitAnim = exitAnim != -1 ? exitAnim : 0;
            popEnterAnim = popEnterAnim != -1 ? popEnterAnim : 0;
            popExitAnim = popExitAnim != -1 ? popExitAnim : 0;
            ft.setCustomAnimations(enterAnim, exitAnim, popEnterAnim, popExitAnim);
        }

        ft.replace(mContainerId, frag);//重点:此处并不是show或hide而是直接replace掉了
        ft.setPrimaryNavigationFragment(frag);

        final @IdRes int destId = destination.getId();
        final boolean initialNavigation = mBackStack.isEmpty();
        // TODO Build first class singleTop behavior for fragments
        final boolean isSingleTopReplacement = navOptions != null &amp;&amp; !initialNavigation
                &amp;&amp; navOptions.shouldLaunchSingleTop()
                &amp;&amp; mBackStack.peekLast() == destId;

        boolean isAdded;
        if (initialNavigation) {
            isAdded = true;
        } else if (isSingleTopReplacement) {
            // Single Top means we only want one instance on the back stack
            if (mBackStack.size() &gt; 1) {
                // If the Fragment to be replaced is on the FragmentManager's
                // back stack, a simple replace() isn't enough so we
                // remove it from the back stack and put our replacement
                // on the back stack in its place
                mFragmentManager.popBackStack(
                        generateBackStackName(mBackStack.size(), mBackStack.peekLast()),
                        FragmentManager.POP_BACK_STACK_INCLUSIVE);
                ft.addToBackStack(generateBackStackName(mBackStack.size(), destId));
            }
            isAdded = false;
        } else {
            ft.addToBackStack(generateBackStackName(mBackStack.size() + 1, destId));
            isAdded = true;
        }
        if (navigatorExtras instanceof Extras) {
            Extras extras = (Extras) navigatorExtras;
            for (Map.Entry&lt;View, String&gt; sharedElement : extras.getSharedElements().entrySet()) {
                ft.addSharedElement(sharedElement.getKey(), sharedElement.getValue());
            }
        }
        ft.setReorderingAllowed(true);
        ft.commit();
        // The commit succeeded, update our view of the world
        if (isAdded) {
            mBackStack.add(destId);
            return destination;
        } else {
            return null;
        }
    }</code></pre> 
<p>所以要达到我们想要的效果需要我们对这个方法进行重写(代码如下):</p> 
<pre><code class="language-java">@Navigator.Name("fixFragment") //这是新的Navigator得名称,千万别忘了加
public class FixFragmentNavigator extends FragmentNavigator {
    private final String TAG = "ReLoadFragmentNavictor";
    private final Context mContext;
    private final FragmentManager mFragmentManager;
    private final int mContainerId;

    public FixFragmentNavigator(@NonNull Context context, @NonNull FragmentManager manager, int containerId) {
        super(context, manager, containerId);
        mContext = context;
        mFragmentManager = manager;
        mContainerId = containerId;
    }

    @Nullable
    @Override
    public NavDestination navigate(@NonNull Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions, @Nullable Navigator.Extras navigatorExtras) {

       if (mFragmentManager.isStateSaved()) {
            Log.i(TAG, "Ignoring navigate() call: FragmentManager has already"
                    + " saved its state");
            return null;
        }
        String className = destination.getClassName();
        if (className.charAt(0) == '.') {
            className = mContext.getPackageName() + className;
        }
        Fragment frag = mFragmentManager.findFragmentByTag(className);
        if (null == frag) {
            //不存在，则创建
            frag = instantiateFragment(mContext, mFragmentManager, className, args);
        }

        frag.setArguments(args);
        final FragmentTransaction ft = mFragmentManager.beginTransaction();

        int enterAnim = navOptions != null ? navOptions.getEnterAnim() : -1;
        int exitAnim = navOptions != null ? navOptions.getExitAnim() : -1;
        int popEnterAnim = navOptions != null ? navOptions.getPopEnterAnim() : -1;
        int popExitAnim = navOptions != null ? navOptions.getPopExitAnim() : -1;
        if (enterAnim != -1 || exitAnim != -1 || popEnterAnim != -1 || popExitAnim != -1) {
            enterAnim = enterAnim != -1 ? enterAnim : 0;
            exitAnim = exitAnim != -1 ? exitAnim : 0;
            popEnterAnim = popEnterAnim != -1 ? popEnterAnim : 0;
            popExitAnim = popExitAnim != -1 ? popExitAnim : 0;
            ft.setCustomAnimations(enterAnim, exitAnim, popEnterAnim, popExitAnim);
        }

//        ft.replace(mContainerId, frag);
        List&lt;Fragment&gt; fragments = mFragmentManager.getFragments();
        for (Fragment fragment : fragments) {
            ft.hide(fragment);
        }
        if (!frag.isAdded()) {
            ft.add(mContainerId, frag, className);
        }
        ft.show(frag);
        ft.setPrimaryNavigationFragment(frag);

        final @IdRes int destId = destination.getId();

        //通过反射获取mBackStack
        ArrayDeque&lt;Integer&gt; mBackStack;
        try {
            Field field = FragmentNavigator.class.getDeclaredField("mBackStack");
            field.setAccessible(true);
            mBackStack = (ArrayDeque&lt;Integer&gt;) field.get(this);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }

        final boolean initialNavigation = mBackStack.isEmpty();
        final boolean isSingleTopReplacement = navOptions != null &amp;&amp; !initialNavigation
                &amp;&amp; navOptions.shouldLaunchSingleTop()
                &amp;&amp; mBackStack.peekLast() == destId;

        boolean isAdded;
        if (initialNavigation) {
            isAdded = true;
        } else if (isSingleTopReplacement) {
            if (mBackStack.size() &gt; 1) {
                mFragmentManager.popBackStack(
                        generateBackStackName(mBackStack.size(), mBackStack.peekLast()),
                        FragmentManager.POP_BACK_STACK_INCLUSIVE);
                ft.addToBackStack(generateBackStackName(mBackStack.size(), destId));
            }
            isAdded = false;
        } else {
            ft.addToBackStack(generateBackStackName(mBackStack.size() + 1, destId));
            isAdded = true;
        }
        if (navigatorExtras instanceof Extras) {
            Extras extras = (Extras) navigatorExtras;
            for (Map.Entry&lt;View, String&gt; sharedElement : extras.getSharedElements().entrySet()) {
                ft.addSharedElement(sharedElement.getKey(), sharedElement.getValue());
            }
        }
        ft.setReorderingAllowed(true);
        ft.commit();
        if (isAdded) {
            mBackStack.add(destId);
            return destination;
        } else {
            return null;
        }
    }
    //navigate需要打方法重复类直接复制过来就可以
    @NonNull
    private String generateBackStackName(int backStackIndex, int destId) {
        return backStackIndex + "-" + destId;
    }
}</code></pre> 
<p>然后在我们的activity中创建我们自定义的Navigator并设置给NavController:</p> 
<pre><code class="language-java">        Fragment fragmentById = getSupportFragmentManager().findFragmentById(R.id.nav_host);
        //fragment的重复加载问题和NavController有关
        final NavController navController = NavHostFragment.findNavController(fragmentById);

        NavigatorProvider provider = navController.getNavigatorProvider();
        //设置自定义的navigator
        FixFragmentNavigator fixFragmentNavictor = new FixFragmentNavigator(this, fragmentById.getChildFragmentManager(), fragmentById.getId());
        provider.addNavigator(fixFragmentNavictor);

        //将BottomNavigationView和NaviGraph关联起来
        NavigationUI.setupWithNavController(activityIndexBinding.navBottom,navController);</code></pre> 
<p>本以为这就完了,但是在运行起来之后,不断创建的Fragment却告诉我"你以为完了就完了?",在看了各位大佬的博客后我发现思路虽然没错但是还需要我们加一点点细节.....</p> 
<p>首先在我们的xml的容器中的属性需要进行部分的修改:</p> 
<pre><code class="language-XML">&lt;fragment
            android:id="@+id/nav_host"
            android:layout_width="match_parent"
            android:layout_height="match_parent"
            android:name="androidx.navigation.fragment.NavHostFragment"
            app:navGraph="@navigation/nav_graph"//这条属性删掉,navGraph我们自己创建
            app:defaultNavHost="true"/&gt;</code></pre> 
<p>然后我们在activity中创建我们需要的navGraph:</p> 
<pre><code class="language-java"> private NavGraph initNavGraph(NavigatorProvider provider, FixFragmentNavigator fragmentNavigator) {
        NavGraph navGraph = new NavGraph(new NavGraphNavigator(provider));

        //用自定义的导航器来创建目的地
        FragmentNavigator.Destination destination1 = fragmentNavigator.createDestination();
        destination1.setId(R.id.afragment);
        destination1.setClassName(AFragment.class.getCanonicalName());
        navGraph.addDestination(destination1);


        FragmentNavigator.Destination destination2 = fragmentNavigator.createDestination();
        destination2.setId(R.id.bfragment);
        destination2.setClassName(BFragment.class.getCanonicalName());
        navGraph.addDestination(destination2);

        FragmentNavigator.Destination destination3 = fragmentNavigator.createDestination();
        destination3.setId(R.id.cfragment);
        destination3.setClassName(CFragment.class.getCanonicalName());
        navGraph.addDestination(destination3);

        FragmentNavigator.Destination destination4 = fragmentNavigator.createDestination();
        destination4.setId(R.id.dfragment);
        destination4.setClassName(DFragment.class.getCanonicalName());
        navGraph.addDestination(destination4);

        FragmentNavigator.Destination destination5 = fragmentNavigator.createDestination();
        destination5.setId(R.id.efragment);
        destination5.setClassName(EFragment.class.getCanonicalName());
        navGraph.addDestination(destination5);

        navGraph.setStartDestination(destination1.getId());

        return navGraph;
    }</code></pre> 
<p>最后给NavController设置NavGraph:</p> 
<pre><code class="language-java"> Fragment fragmentById = getSupportFragmentManager().findFragmentById(R.id.nav_host);
        //fragment的重复加载问题和NavController有关
        final NavController navController = NavHostFragment.findNavController(fragmentById);

        NavigatorProvider provider = navController.getNavigatorProvider();
        //设置自定义的navigator
        FixFragmentNavigator fixFragmentNavictor = new FixFragmentNavigator(this, getSupportFragmentManager(), fragmentById.getId());
        provider.addNavigator(fixFragmentNavictor);

        NavGraph navDestinations = initNavGraph(provider, fixFragmentNavictor);
        navController.setGraph(navDestinations);

        //将BottomNavigationView和NaviGraph关联起来---&gt;自定义navigator后这样设置会有一些奇葩的问题,谁用谁知道(╥╯^╰╥)....
       //NavigationUI.setupWithNavController(activityIndexBinding.navBottom,navController);
        //正确的关联方式o(￣▽￣)ｄ
        activityIndexBinding.navBottom.setOnNavigationItemSelectedListener(item -&gt; {
            navController.navigate(item.getItemId());
            return true;
        });</code></pre> 
<p>----------------------------------------------------------------------------------------------------------&gt;</p> 
<p>感谢 <a href="https://blog.csdn.net/yang_study_first" title="八归少年">八归少年</a> 给出的补充,为了防止点击返回键无法退出界面而是退回到切换前的fragment,我们需要处理一下返回键的点击事件:</p> 
<pre><code>@Override
    public void onBackPressed() {
        finish();
    }</code></pre> 
<p>更新:附上Demo地址</p> 
<p><a class="has-card" href="https://github.com/Coursem/FixFragmentNavigatorDemo.git" title="GitHub - Coursem/FixFragmentNavigatorDemo"><span class="link-card-box"><span class="link-title">GitHub - Coursem/FixFragmentNavigatorDemo</span><span class="link-desc">Contribute to Coursem/FixFragmentNavigatorDemo development by creating an account on GitHub.</span><span class="link-link"><img alt="" class="link-link-icon" src="https://images2.imgbox.com/6e/e1/TQoBH459_o.png">https://github.com/Coursem/FixFragmentNavigatorDemo.git</span></span></a></p> 
<p>-------------------------------------------------------------------------------------------------------------&gt;</p> 
<p>小发现:</p> 
<p>        正常使用原生Navigator时给navController加上setOnNavigationItemSelectedListener可以有效的控制多次的点击同一个item时fragment的多次刷新问题</p> 
<pre><code class="language-Kotlin">vNavBottom.setOnNavigationItemSelectedListener {
            // 避免再次点击重复创建
            if (it.isChecked) {
                return@setOnNavigationItemSelectedListener true
            }
            return@setOnNavigationItemSelectedListener NavigationUI.onNavDestinationSelected(
                it, navController
            )
        }</code></pre> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3ef708f63bb34a5677d6dd7bd9f58102/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python 提示‘grep‘ 不是内部或外部命令，也不是可运行的程序或批处理文件</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/ce221a97c4c0676d744a9ee4f8233924/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">达梦数据库主备集群备库异常</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>