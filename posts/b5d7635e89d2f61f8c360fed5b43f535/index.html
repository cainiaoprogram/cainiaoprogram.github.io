<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>牛客选择题错题本 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="牛客选择题错题本" />
<meta property="og:description" content="1、 return i&#43;&#43; 是先 return i 然后 i&#43;&#43;，与 赋值语句是一个道理
2、 一个容器类数据结构，读写平均，使用锁机制保证线程安全。如果要综合提高该数据结构的访问性能，最好的办法是______。
只对写操作加锁，不对读操作加锁 读操作不加锁，采用copyOnWrite的方式实现写操作 分区段加锁 无法做到 答案：C A，只对写操作加锁，不对读操作加锁，会造成读到脏数据 B，CopyOnWrite的核心思想是利用高并发往往是读多写少的特性，对读操作不加锁，对写操作，先复制一份新的集合，在新的集合上面修改，然后将新集合赋值给旧的引用。这里读写平均，不适用 C，分段加锁，只在影响读写的地方加锁，锁可以用读写锁，可以提高效率 3、 抽象类方法的访问权限默认都是public。（ ）
正确答案: B 你的答案: A (错误)
正确 错误 关于抽象类 JDK 1.8以前，抽象类的方法默认访问权限为protected JDK 1.8时，抽象类的方法默认访问权限变为default 关于接口 JDK 1.8以前，接口中的方法必须是public的 JDK 1.8时，接口中的方法可以是public的，也可以是default的 JDK 1.9时，接口中的方法可以是private的 4、 将下列哪个代码（A、B、C、D）放入程序中标注的【代码】处将导致编译错误？
class A{ public float getNum(){ return 3.0f; } } public class B extends A{ 【代码】 } 正确答案: B 你的答案: C (错误)
public float getNum(){return 4.0f} public void getNum(){} public void getNum(double d){} public double getNum(float d){return 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b5d7635e89d2f61f8c360fed5b43f535/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-11-02T11:20:58+08:00" />
<meta property="article:modified_time" content="2021-11-02T11:20:58+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">牛客选择题错题本</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="1_0"></a>1、</h2> 
<p>return i++ 是先 return i 然后 i++，与 赋值语句是一个道理</p> 
<h2><a id="2_6"></a>2、</h2> 
<p>一个容器类数据结构，读写平均，使用锁机制保证线程安全。如果要综合提高该数据结构的访问性能，最好的办法是______。</p> 
<pre><code>只对写操作加锁，不对读操作加锁
读操作不加锁，采用copyOnWrite的方式实现写操作
分区段加锁
无法做到
</code></pre> 
<pre><code>答案：C

A，只对写操作加锁，不对读操作加锁，会造成读到脏数据
B，CopyOnWrite的核心思想是利用高并发往往是读多写少的特性，对读操作不加锁，对写操作，先复制一份新的集合，在新的集合上面修改，然后将新集合赋值给旧的引用。这里读写平均，不适用
C，分段加锁，只在影响读写的地方加锁，锁可以用读写锁，可以提高效率
</code></pre> 
<h2><a id="3_25"></a>3、</h2> 
<p>抽象类方法的访问权限默认都是public。（ ）</p> 
<p>正确答案: B 你的答案: A (错误)</p> 
<pre><code>正确
错误
</code></pre> 
<pre><code>关于抽象类
JDK 1.8以前，抽象类的方法默认访问权限为protected
JDK 1.8时，抽象类的方法默认访问权限变为default

关于接口
JDK 1.8以前，接口中的方法必须是public的
JDK 1.8时，接口中的方法可以是public的，也可以是default的
JDK 1.9时，接口中的方法可以是private的
</code></pre> 
<h2><a id="4_47"></a>4、</h2> 
<p>将下列哪个代码（A、B、C、D）放入程序中标注的【代码】处将导致编译错误？</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token number">3.0f</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span>
    【代码】
<span class="token punctuation">}</span>
</code></pre> 
<p>正确答案: B 你的答案: C (错误)</p> 
<pre><code>public float getNum(){return 4.0f}
public void getNum(){}
public void getNum(double d){}
public double getNum(float d){return 4.0d}
</code></pre> 
<p>解析：A 是方法的重写吗，要求返回值类型相同，方法名相同并且传递参数类型相同，所以 A 对 B 不对，而 CD 都是方法方法的新定义，既不是重写也不是重载，因为重载要求方法名相同，返回值类型相同，但是传递参数可能不同</p> 
<pre><code>方法的重写（override）两同两小一大原则：

方法名相同，参数类型相同

子类返回类型小于等于父类方法返回类型，

子类抛出异常小于等于父类方法抛出异常，

子类访问权限大于等于父类方法访问权限。
</code></pre> 
<h2><a id="5_87"></a>5、</h2> 
<p>要导入java/awt/event下面的所有类，叙述正确的是？()</p> 
<p>正确答案: C 你的答案: A (错误)</p> 
<pre><code>import java.awt.*和import java.awt.event.*都可以
只能是import java.awt.*
只能是import java.awt.event.*
import java.awt.*和import java.awt.event.*都不可以
</code></pre> 
<p><a href="https://www.baidu.com/s?wd=java.awt&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y3uWD1mhRYn19BnjwWnWPb0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnHRYnHnknWD3P1b3PHDkn10zPs" rel="nofollow">java.awt</a>.*是导入java\awt包下所有的类，并不包括其子包下的类。</p> 
<p><strong><a href="https://www.baidu.com/s?wd=java.awt&amp;tn=44039180_cpr&amp;fenlei=mv6quAkxTZn0IZRqIHckPjm4nH00T1Y3uWD1mhRYn19BnjwWnWPb0ZwV5Hcvrjm3rH6sPfKWUMw85HfYnjn4nH6sgvPsT6KdThsqpZwYTjCEQLGCpyw9Uz4Bmy-bIi4WUvYETgN-TLwGUv3EnHRYnHnknWD3P1b3PHDkn10zPs" rel="nofollow">java.awt</a>.event.*才能导入java\awt\event包下的类。</strong></p> 
<h2><a id="6_104"></a>6、</h2> 
<p>下面有关JVM内存，说法错误的是？</p> 
<p>正确答案: C 你的答案: D (错误)</p> 
<pre><code>程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的
虚拟机栈描述的是Java方法执行的内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的
方法区用于存储JVM加载的类信息、常量、静态变量、以及编译器编译后的代码等数据，是线程隔离的
原则上讲，所有的对象都在堆区上分配内存，是线程之间共享的
</code></pre> 
<p>方法区在JVM中也是一个非常重要的区域，它与堆一样，是被 <strong>线程共享</strong> 的区域。 在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。</p> 
<h2><a id="7_119"></a>7、</h2> 
<p>定义二维数组的时候，第一个中括号必须有值，表示的是二维数组中有多少个一维数组</p> 
<h2><a id="8_123"></a>8、</h2> 
<p>以下（）不是合法的标识符？</p> 
<p>正确答案: C 你的答案: 空 (错误)</p> 
<pre><code>STRING
x3x
void
deSf
</code></pre> 
<p>标识符就是变量的意思， void 不能作为变量</p> 
<h2><a id="9_138"></a>9、</h2> 
<p>以下程序的运行结果是：( )</p> 
<pre><code class="prism language-java"><span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> subSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">606</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">613</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
     set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
subSet <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">TreeSet</span><span class="token punctuation">)</span>set<span class="token punctuation">.</span><span class="token function">subSet</span><span class="token punctuation">(</span><span class="token number">608</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token number">611</span><span class="token punctuation">,</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">609</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>subSet<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>此题的答案是[606, 608, 609，610, 612] [608, 609，610]</p> 
<p>可能会好奇，为什么 609 也出现在 subSet 中？因为 指向的数据是同一组数据，不论谁对原数据进行操作，最后获取的都是修改后的原数据</p> 
<p><img src="https://images2.imgbox.com/c7/e7/jI5uZSVg_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/de/e1/aU7gIP89_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="10_164"></a>10、</h2> 
<p>下列有关Servlet的生命周期，说法不正确的是？</p> 
<p>正确答案: A 你的答案: 空 (错误)</p> 
<pre><code>在创建自己的Servlet时候，应该在初始化方法init()方法中创建Servlet实例
在Servlet生命周期的服务阶段，执行service()方法，根据用户请求的方法，执行相应的doGet()或是doPost()方法
在销毁阶段，执行destroy()方法后会释放Servlet 占用的资源
destroy()方法仅执行一次，即在服务器停止且卸载Servlet时执行该方法
</code></pre> 
<p>只有 A 的说法是错误的，因为 创建Servlet的实例是由Servlet容器来完成的，且创建Servlet实例是在初始化方法init()之前</p> 
<h2><a id="11_179"></a>11、</h2> 
<p>Which lines of the following will produce an error?</p> 
<pre><code class="prism language-java"><span class="token keyword">byte</span> a1 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> a2 <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">,</span> a3<span class="token punctuation">;</span>
<span class="token keyword">short</span> s <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>
a2 <span class="token operator">=</span> s<span class="token punctuation">;</span>
a3 <span class="token operator">=</span> a1 <span class="token operator">*</span> a2<span class="token punctuation">;</span> 
</code></pre> 
<pre><code>Line 3 and Line 4
Line 1 only
Line 3 only
Line 4 only
</code></pre> 
<p>错误答案是 A，因为 s 是 short 类型，转换成 byte 会出错， a1 * a2 是 int 类型，转换成 byte 会出错</p> 
<h2><a id="12_199"></a>12、</h2> 
<p>有关线程的哪些叙述是对的（）</p> 
<pre><code>一旦一个线程被创建，它就立即开始运行。
使用start()方法可以使一个线程成为可运行的，但是它不一定立即开始运行。
当一个线程因为抢先机制而停止运行，它可能被放在可运行队列的前面。
一个线程可能因为不同的原因停止并进入就绪状态。
</code></pre> 
<p>正确答案是 BCD，因为</p> 
<pre><code>一个新创建的线程并不是自动的开始运行的，必须调用它的start()方法使之将线程放入可运行态(runnable state)，这只是意味着该线程可被JVM的线程调度程序调度而不是意味着它可以立即运行。

线程的调度是抢先式的，而不是分时间片式的。
具有比当前运行线程高优先级的线程可以使当前线程停止运行而进入就绪状态。

不同优先级的线程间是抢先式的，而同级线程间是轮换式的。

一个线程停止运行可以是因为不同原因，可能是因为更高优先级线程的抢占，也可能是因为调用sleep()方法。

而即使是因为抢先而停止也不一定就进入可运行队列的前面，因为同级线程是轮换式的，它的运行可能就是因为轮换，而它因抢占而停止后只能在轮换队列中排队而不能排在前面。
</code></pre> 
<h2><a id="13_225"></a>13、</h2> 
<p>以下代码执行的结果显示是多少（）？</p> 
<p><img src="https://images2.imgbox.com/ff/9d/iix4Fm1V_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-IgpWKXIX-1635822973362)(C:\Users\62459\AppData\Roaming\Typora\typora-user-images\image-20211018100645460.png)]"></p> 
<pre><code>num * count = 505000
num * count = 0
运行时错误
num * count = 5050
</code></pre> 
<p>正确答案是 B，count 一直都是 0，原因是：count = count++ 的意思是，先把 count 中的值放入操作栈中，然后执行 count = count + 1，此时 count = 1，但是还要执行赋值语句，count = 操作栈中的数字，也就是说 count 一直都是 0。</p> 
<p>而且就算是 count = count + 1，结果也不是 A 选项，因为 count 等于 101</p> 
<h2><a id="14_243"></a>14、</h2> 
<p>在为传统面向对象语言的程序做单元测试的时候,经常用到mock对象。Mock对象通过反射数。请问反射最大程度破坏了面向对象的以下哪个特性？</p> 
<p>正确答案: A 你的答案: B (错误)</p> 
<pre><code>封装
多态
继承
抽象
</code></pre> 
<p>通过反射可以调用到类中的 private 方法，所以破坏了封装性。</p> 
<pre><code class="prism language-java">mock对象：也成为伪对象，在测试中的利用mock对象来代替真实对象，方便测试的进行。
java的封装性：指的是将对象的状态信息隐藏在对象内部，不允许外部程序直接访问对象内部信息，通过该类提供的方法实现对内部信息的操作访问。
反射机制：在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法<span class="token punctuation">;</span>对于任意一个对象，都能够调用它的任意一个方法和属性
</code></pre> 
<h2><a id="15_264"></a>15、</h2> 
<p>多重继承的概念在Java中实现是通过如下哪些？（）</p> 
<p>I. 扩展两个或多个类</p> 
<p>II. 扩展一个类并实现一个或多个接口。</p> 
<p>III. 实现两个或更多接口。</p> 
<p>都是</p> 
<p>正确答案: B 你的答案: D (错误)</p> 
<pre><code>只有I &amp;amp;II
只有II &amp;amp; III
只有III
都是
</code></pre> 
<p>需要注意，扩展类其实就是 extends 类，由于 java 只能单继承，所以 A 选项不能选</p> 
<h2><a id="16_289"></a>16、</h2> 
<p>下面有关List接口、Set接口和Map接口的描述，错误的是？</p> 
<p>正确答案: A 你的答案: B (错误)</p> 
<pre><code>他们都继承自Collection接口
List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置
Set是一种不包含重复的元素的Collection
Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value
</code></pre> 
<p>需要注意，Map 接口和 Collection 接口没有任何关系，这两个接口是同一个等级的</p> 
<p><img src="https://images2.imgbox.com/67/8d/8UKCY89P_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-lFokQrLo-1635822973365)(C:\Users\62459\AppData\Roaming\Typora\typora-user-images\image-20211019145208520.png)]"></p> 
<p><img src="https://images2.imgbox.com/57/a3/f2fTGKxQ_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-v11UJolV-1635822973367)(C:\Users\62459\AppData\Roaming\Typora\typora-user-images\image-20211019145447114.png)]"></p> 
<p><img src="https://images2.imgbox.com/6d/38/bAsm2ZwF_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-OYaoOi2v-1635822973368)(C:\Users\62459\AppData\Roaming\Typora\typora-user-images\image-20211019145455334.png)]"></p> 
<h2><a id="17_313"></a>17、</h2> 
<p>以下JAVA程序的运行结果是什么( )</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Object</span> o1 <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Object</span> o2<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    o2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{<!-- --></span>
        o2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>o1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>o2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-java">三元运算符会对两个结果的数据类型，进行自动的类型提升。
因此，可以把
<span class="token class-name">Object</span> o1 <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
看作
<span class="token class-name">Object</span> o1 <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token operator">?</span> <span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h2><a id="18_340"></a>18、</h2> 
<p>下面代码的输出结果是什么？</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ZeroTest</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
     <span class="token keyword">try</span><span class="token punctuation">{<!-- --></span>
       <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">100</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span>
       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token keyword">finally</span><span class="token punctuation">{<!-- --></span>
       <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span>
</code></pre> 
<p>答案是 12</p> 
<p>解析：</p> 
<pre><code class="prism language-java">执行 <span class="token number">100</span> <span class="token operator">/</span> <span class="token number">0</span> 此时出错，不会执行下面的 sout，
进入 <span class="token keyword">catch</span> 里，执行代码 sout，执行 <span class="token keyword">finally</span>，然后抛出异常，程序结束，不会在执行
</code></pre> 
<h2><a id="19_370"></a>19、</h2> 
<p>instanceof运算符能够用来判断一个对象是否为:</p> 
<p>正确答案: C 你的答案: A (错误)</p> 
<pre><code>一个类的实例
一个实现指定接口的类的实例
全部正确
一个子类的实例
</code></pre> 
<p><strong>instance是java的二元运算符，用来判断他左边的对象是否为右面类（接口，抽象类，父类）的实例</strong></p> 
<p>所以此题是 全都正确</p> 
<h2><a id="20_387"></a>20、</h2> 
<p>关于抽象类叙述正确的是？ ( )</p> 
<p>正确答案: B 你的答案: D (错误)</p> 
<pre><code>抽象类不能实现接口
抽象类必须有“abstract class”修饰
抽象类必须包含抽象方法
抽象类也有类的特性，可以被实例化
</code></pre> 
<p><strong>A.抽象类是可以实现接口的，而且抽象类也可以继承自抽象类</strong></p> 
<p><strong>B.对</strong></p> 
<p><strong>C.抽象类指有abstract修饰的class，其可以包含抽象方法，也可以不包含</strong></p> 
<p><strong>D.抽象类和接口都是不能被实例化的，只有具体的类才可以被实例化</strong></p> 
<p><img src="https://images2.imgbox.com/00/bc/5ziq3q7J_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-MJw29AJ6-1635822973369)(C:\Users\62459\AppData\Roaming\Typora\typora-user-images\image-20211023172933384.png)]"></p> 
<h2><a id="21_411"></a>21、</h2> 
<p>能单独和finally语句一起使用的块是( )</p> 
<p>正确答案: A 你的答案: C (错误)</p> 
<pre><code>try
catch
throw
throws
</code></pre> 
<p>解析：处理异常常用的两种方式：<br> 1、try…catch(捕获处理机制)；<br> 2、throws(冒泡处理机制).<br> 注意细节：使用<strong>try…catch块捕获时可以没有catch块,但当没用catch块的时候必须得有finally块</strong>.故选A）</p> 
<h2><a id="22_429"></a>22、</h2> 
<p>下面代码的运行结果是（ ）</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Arraytest</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> main <span class="token punctuation">(</span> <span class="token class-name">String</span> arg<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span>println <span class="token punctuation">(</span> a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>正确答案: C 你的答案: B (错误)</p> 
<pre><code>null
0
编译出错
运行出错
</code></pre> 
<p>在static方法中是不能访问非静态变量 a 的，需要将 a 声明为static，答案才会是 0 ，否则是编译出错</p> 
<h2><a id="23_453"></a>23、</h2> 
<p>下面哪些情况下该类一定为抽象类？</p> 
<p>正确答案: A B D 你的答案: B D (错误)</p> 
<pre><code>当一个类的一个或多个方法是抽象方法时
当类是一个抽象类的子类，并且不能为任何抽象方法提供任何实现细节或方法体时
当一个类实现多个接口时
当一个类实现一个接口，并且不能为任何抽象方法提供实现细节或方法体时
</code></pre> 
<pre><code>1.A选项。一个类中有抽象方法则必须申明为抽象类。
public abstract class HaveAbstractMethod {
public abstract void method1();}
2.B选项。 我建一个接口，然后一个抽象类implements这个接口，并override的所有方法。然后我在建一个类extends这个抽象类，并且不能为任何抽象方法提供任何细节或方法体时，这时这个类必须是抽象类。
public interface MyInterface { public void method1();}
public abstract class MyAbstractClass implements MyInterface{
@Override
public void method1() {   } }
public abstract class ChildAbstractClass extends MyAbstractClass{
@Override
public abstract void method1();
}
3.D选项。我建一个接口，然后一个类implements这个接口，并且不能为任何抽象方法提供任何细节或方法体时，这个类必须是抽象类，并override的所有方法。然后我在建一个普通类extends这个抽象类，就可以为所欲为了 。这种情况就是java设计模式中的适配器模式。
public interface MyInterface { public void method1();}
public abstract class MyAbstractClass implements MyInterface{
@Override
public void method1() {   } }
public class MyNormalClass extends MyAbstractClass{
@Override
public void method1() {System.out.println("from method1");}
</code></pre> 
<h2><a id="24_489"></a>24、</h2> 
<p><strong>对</strong> <strong>Map</strong> <strong>的用法，正确的有：</strong></p> 
<p>正确答案: C D 你的答案: A B D (错误)</p> 
<pre><code>new java.util.Map().put("key" , "value") ;
new java.util.SortedMap().put("key" , "value") ;
new java.util.HashMap().put( null , null ) ;
new java.util.TreeMap().put( 0 , null ) ;
</code></pre> 
<p>选C、D。考察的是<strong>Map接口</strong>实现类的<strong>创建对象</strong>以及对象类型包含的<strong>方法</strong>。</p> 
<p>A选项<strong>Map属于接口类型</strong>，不可以new的方式创建对象。所以A错误。</p> 
<p>B选项<strong>SortedMap属于接口类型</strong>，不可以new的方式创建对象。所以B错误。</p> 
<p>C选项<strong>HashMap</strong>基于哈希表实现Map接口的类，<strong>并允许null的值和null键</strong>。</p> 
<p>D选项<strong>TreeMap</strong>通过红黑树实现Map接口的类，key不可以为null，会报<strong>NullPointerException</strong>异常,value可以为null。</p> 
<h2><a id="25_512"></a>25、</h2> 
<p>byte b1=1,b2=2,b3,b6,b8;<br> final byte b4=4,b5=6,b7;<br> b3=(b1+b2); /<em>语句1</em>/<br> b6=b4+b5; /<em>语句2</em>/<br> b8=(b1+b4); /<em>语句3</em>/<br> b7=(b2+b5); /<em>语句4</em>/<br> System.out.println(b3+b6);</p> 
<pre><code>本题答案应为：B、C、D
------------知识点------------
Java表达式转型规则由低到高转换：
1、所有的byte,short,char型的值将被提升为int型；
2、如果有一个操作数是long型，计算结果是long型；

3、如果有一个操作数是float型，计算结果是float型；

4、如果有一个操作数是double型，计算结果是double型；
5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。
--------------解析--------------
语句1错误：b3=(b1+b2);自动转为int，所以正确写法为b3=(byte)(b1+b2);或者将b3定义为int；
语句2正确：b6=b4+b5;b4、b5为final类型，不会自动提升，所以和的类型视左边变量类型而定，即b6可以是任意数值类型；
语句3错误：b8=(b1+b4);虽然b4不会自动提升，但b1仍会自动提升，所以结果需要强转，b8=(byte)(b1+b4);
语句4错误：b7=(b2+b5); 同上。同时注意b7是final修饰，即只可赋值一次，便不可再改变。
</code></pre> 
<p><img src="https://images2.imgbox.com/ee/81/gQ5r6MXg_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CrfmaVyz-1635822973369)(C:\Users\62459\AppData\Roaming\Typora\typora-user-images\image-20211023173950639.png)]"></p> 
<h2><a id="26_543"></a>26、</h2> 
<p>下列程序test 类中的变量c 的最后结果为</p> 
<pre><code>public class Test {
    public static void main(String args[]) {
        int a = 10;
        int b;
        int c;
        if (a &gt; 50) {
             b = 9;
        }
        c = b + a;
    }
}
</code></pre> 
<p>正确答案: D 你的答案: A (错误)</p> 
<pre><code>10
0
19
编译出错
</code></pre> 
<p>方法内定义的变量没有初始值，所以必须要初始化</p> 
<p>类中定义的变量有默认值，可以不用初始化</p> 
<h2><a id="27_576"></a>27、</h2> 
<p>内部类（也叫成员内部类）可以有4种访问权限。（ ）</p> 
<p>正确答案: A 你的答案: B (错误)</p> 
<pre><code>正确
错误
</code></pre> 
<p>成员内部类可以有四种访问权限</p> 
<h2><a id="28_589"></a>28、</h2> 
<p>下列代码执行结果为（）</p> 
<pre><code>public static void main(String args[])throws InterruptedException{
	    	Thread t=new Thread(new Runnable() {
				public void run() {
					try {
						Thread.sleep(2000);
					} catch (InterruptedException e) {
						throw new RuntimeException(e);
					}
					System.out.print("2");
				}
			});
	    	t.start();
</code></pre> 
<p>​</p> 
<pre><code>    	t.join();
    	System.out.print("1");
    }
</code></pre> 
<p>正确答案: A 你的答案: A (正确)</p> 
<pre><code>21
12
可能为12，也可能为21
以上答案都不对
</code></pre> 
<p>join()的作用是：“等待该线程终止”，这里需要理解的就是该线程是指的主线程等待子线程的终止。也就是在子线程调用了join()方法后面的代码，只有等到子线程结束了才能执行。</p> 
<h2><a id="29_625"></a>29、</h2> 
<p>下列可作为java语言标识符的是（）</p> 
<p>正确答案: A B C 你的答案: A C D (错误)</p> 
<pre><code>a1
$1
_1
11
</code></pre> 
<ol><li>标识符的组成元素是字母（a-z，A-Z），数字（0~9），下划线（_）和美元符号（$）。</li><li><strong>标识符不能以数字开头。</strong></li><li><strong>java的标识符是严格区分大小写的。</strong></li><li>标识符的长度可以是任意的。</li><li>关键字以及null、true、false不能用于自定义的标识符。</li></ol> 
<h2><a id="30_644"></a>30、</h2> 
<p>下面哪些情况会引发异常：</p> 
<p>正确答案: A B C 你的答案: A B (错误)</p> 
<pre><code>数组越界
指定URL不存在
使用throw语句抛出
使用throws语句
</code></pre> 
<p>throws 和 throw：</p> 
<p>throws出现在方法头，表示可能会出现异常；</p> 
<p>throw是在方法体，抛出了异常，执行throw则一定抛出了某种异常</p> 
<h2><a id="31_663"></a>31、</h2> 
<p>已知有下列Test类的说明，在该类的main方法的横线处，则下列哪个语句是正确的？（）</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span>

<span class="token punctuation">{<!-- --></span>

<span class="token keyword">private</span> <span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token number">1.0f</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> main <span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token punctuation">{<!-- --></span>

<span class="token class-name">Test</span> t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

————————

<span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>正确答案: A 你的答案: B (错误)</p> 
<pre><code>t.f = 1;
this.n = 1;
Test.m = 1;
Test.f = 1;
</code></pre> 
<p>1、f 虽然是 Test 类的私有成员属性，但因为 main 方法就在 Test 类内，因此可以通过 “对象名.属性名” 的方式调用，所以 A 对。</p> 
<p>2、static 静态成员属性不能使用 this 关键字调用，B 错</p> 
<p>3、m 和 f 都是普通成员属性，而 “类名.” 方式只能调用 静态成员属性，因此 C 和 D 都错。</p> 
<h2><a id="32_708"></a>32、</h2> 
<p>运行代码，输出的结果是（）</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">P</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> abc <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"P is init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">S</span> <span class="token keyword">extends</span> <span class="token class-name">P</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">static</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"S is init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">S</span><span class="token punctuation">.</span>abc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>正确答案: A 你的答案: C (错误)</p> 
<pre><code>P is init&lt;br /&gt;123
S is init&lt;br /&gt;P is init&lt;br /&gt;123
P is init&lt;br /&gt;S is init&lt;br /&gt;123
S is init&lt;br /&gt;123
</code></pre> 
<p>(abc 是 static 修饰的)</p> 
<p><strong>不会初始化子类的几种</strong></p> 
<p><strong>1. 调用的是父类的static方法或者字段</strong></p> 
<p><strong>2.调用的是父类的final方法或者字段</strong></p> 
<p><strong>3. 通过数组来引用</strong></p> 
<h2><a id="33_750"></a>33、</h2> 
<p>以下哪些类是线程安全的（）</p> 
<p>正确答案: A D E 你的答案: A D (错误)</p> 
<pre><code>Vector
HashMap
ArrayList
StringBuffer
Properties
</code></pre> 
<p>Vector，stringBuffer，Propertities</p> 
<h2><a id="34_766"></a>34、</h2> 
<p>下面哪个语句可以用来声明了一个创建N个字符串对象数组的变量？</p> 
<p>正确答案: B C F 你的答案: D E (错误)</p> 
<pre><code>char a[][];
String a[];
String[] a;
Object a[50];
String a[50];
Object a[];
</code></pre> 
<p>声明一个数组时，不能直接限定数组长度，只有在创建实例化对象时，才能对给定数组长度.</p> 
<h2><a id="35_783"></a>35、</h2> 
<p>关于匿名内部类叙述正确的是？ ( )</p> 
<p>正确答案: B 你的答案: D (错误)</p> 
<pre><code>匿名内部类可以继承一个基类，不可以实现一个接口
匿名内部类不可以定义构造器
匿名内部类不能用于形参
以上说法都不正确
</code></pre> 
<p>由于构造器的名字必须与类名相同，而匿名类没有类名，所以匿名类不能有构造器。</p> 
<ol><li>使用匿名内部类时，必须继承一个类或实现一个接口</li><li>匿名内部类由于没有名字，因此不能定义构造函数</li><li>匿名内部类中不能含有静态成员变量和静态方法</li></ol> 
<h2><a id="36_802"></a>36、</h2> 
<pre><code class="prism language-java"> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> main <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> 
    <span class="token class-name">String</span> classFile <span class="token operator">=</span> <span class="token string">"com.jd."</span><span class="token punctuation">.</span> <span class="token function">replaceAll</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">,</span> <span class="token string">"/"</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"MyClass.class"</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>classFile<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>正确答案: C 你的答案: B (错误)</p> 
<pre><code>com. jd
com/jd/MyClass.class
///MyClass.class
com.jd.MyClass
</code></pre> 
<p><strong>选C 由于replaceAll方法的第一个参数是一个正则表达式，而".“在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成”/"。如果想替换的只是"."，那么久要写成"\.".</strong>， 一开始没看懂</p> 
<p>. 在正则表达式里表示任意字符，如果真的想替换 .，需要使用 “\ \.”</p> 
<h2><a id="37_824"></a>37、</h2> 
<p>Which method you define as the starting point of new thread in a class from which n thread can be execution?</p> 
<p>下列哪一个方法你认为是新线程开始执行的点，也就是从该点开始线程n被执行。</p> 
<p>正确答案: B 你的答案: A (错误)</p> 
<pre><code>public void start()
public void run()
public void int()
public static void main(String args[])
public void runnable()
</code></pre> 
<p>答案：B</p> 
<p>要写一个线程类，可以继承Thread方法，然后override他的run（）方法</p> 
<p>另一种方法是实现Runable接口，即为实现run（）方法。</p> 
<p>A，start（）是启动一个线程的方法</p> 
<p>run 是新线程开始执行， start 是启动线程</p> 
<h2><a id="38_852"></a>38、</h2> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Tester</span><span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
   <span class="token class-name">Integer</span> var1<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token class-name">Integer</span> var2<span class="token operator">=</span>var1<span class="token punctuation">;</span>
   <span class="token function">doSomething</span><span class="token punctuation">(</span>var2<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>var1<span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>var1<span class="token operator">==</span>var2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> integer<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    integer<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>正确答案: A 你的答案: B (错误)</p> 
<pre><code>1true
2true
1false
2false
</code></pre> 
<p>本题选 A，因为 Java 中只有值传递，方法 doSomething 调用时只是 var2 的一个副本，所以最后的记过，var1 和 var2 都是 1，而且地址相同</p> 
<h2><a id="39_881"></a>39、</h2> 
<p>下面哪些标识符是正确的？</p> 
<p>正确答案: A B 你的答案: A B C (错误)</p> 
<pre><code>MyWorld
parseXML
–value
&amp;amp;maybe
</code></pre> 
<p>java 中标识符：</p> 
<ul><li>字母，数字（数字不能开头）$ 符号和下划线</li><li>数字不能开头</li></ul> 
<p>所以此题，AB 是对的，C 中不能是 -，只能是下划线</p> 
<h2><a id="40_901"></a>40、</h2> 
<p>以下关于final关键字说法错误的是（）</p> 
<p>正确答案: A C 你的答案: A B C D (错误)</p> 
<pre><code>final是java中的修饰符，可以修饰类、接口、抽象类、方法和属性
final修饰的类不能被继承
final修饰的方法不能被重载
final修饰的变量不允许被再次赋值
</code></pre> 
<p>审题 啊！！！！！题目中问的是错误的是，</p> 
<p>A 选项，final 不能修饰接口</p> 
<p>C选项，final修饰的方法不能被重写</p> 
<h2><a id="41_920"></a>41、</h2> 
<p>Servlet的生命周期可以分为初始化阶段，运行阶段和销毁阶段三个阶段，以下过程属于初始化阶段是（）。</p> 
<p>正确答案: A C D 你的答案: A B C (错误)</p> 
<pre><code>加载Servlet类及.class对应的数据
创建servletRequest和servletResponse对象//调用 service 方法才会构造
创建ServletConfig对象
创建Servlet对象
</code></pre> 
<p>Servlet的生命周期一般可以用三个方法来表示：</p> 
<ol><li>init()：仅执行一次，负责在装载Servlet时初始化Servlet对象</li><li>service() ：核心方法，一般HttpServlet中会有get,post两种处理方式。在调用doGet和doPost方法时会构造servletRequest和servletResponse请求和响应对象作为参数。</li><li>destory()：在停止并且卸载Servlet时执行，负责释放资源</li></ol> 
<p>初始化阶段：Servlet启动，会读取配置文件中的信息，构造指定的Servlet对象，创建ServletConfig对象，将ServletConfig作为参数来调用init()方法。所以选ACD。<strong>B是在调用service方法时才构造的</strong></p> 
<h2><a id="42_941"></a>42、</h2> 
<p>下列哪个选项是正确计算42度（角度）的余弦值？</p> 
<p>正确答案: C 你的答案: D (错误)</p> 
<pre><code class="prism language-java"><span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">cosine</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">toRadians</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">double</span> d <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">cos</span><span class="token punctuation">(</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">toDegrees</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>计算余弦值使用Math类的cos()方法，<strong>计算的是指定弧度的余弦值</strong></p> 
<p><strong>toRadians()是将角度转换为弧度</strong></p> 
<p><strong>toDegrees()是将弧度转换为角度</strong></p> 
<h2><a id="43_960"></a>43、</h2> 
<p>public interface IService {String NAME=“default”;}</p> 
<p>默认类型等价表示是哪一项:</p> 
<p>正确答案: C 你的答案: A (错误)</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token class-name">String</span> NAME<span class="token operator">=</span><span class="token string">"default"</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">String</span> NAME<span class="token operator">=</span><span class="token string">"default"</span><span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> NAME<span class="token operator">=</span><span class="token string">"default"</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token class-name">String</span> NAME<span class="token operator">=</span><span class="token string">"default"</span><span class="token punctuation">;</span>
</code></pre> 
<p>接口中的变量默认是 <strong>public static final</strong> 的，方法默认是 <strong>public abstract</strong> 的</p> 
<h2><a id="44_977"></a>44、</h2> 
<p>以下叙述正确的是</p> 
<p>正确答案: D 你的答案: B (错误)</p> 
<pre><code class="prism language-java">实例方法可直接调用超类的实例方法
实例方法可直接调用超类的类方法、
实例方法可直接调用子类的实例方法
实例方法可直接调用本类的实例方法
</code></pre> 
<p>实例成员包括实例变量和实例方法，也就是我们平时说的成员变量和成员方法</p> 
<p>A、不能只能调用，必须先创建一个 超类的对象才能</p> 
<p>B、当父类的类方法定义为 private 的时候，就不能直接调用了</p> 
<p>C、子类的方法对父类不可见</p> 
<p>D、正确</p> 
<h2><a id="45_1002"></a>45、</h2> 
<p>下面有关JAVA异常类的描述，说法错误的是？</p> 
<p>正确答案: D 你的答案: C (错误)</p> 
<pre><code>异常的继承结构：基类为Throwable，Error和Exception继承Throwable，RuntimeException和IOException等继承Exception
非RuntimeException一般是外部错误(非Error)，其一般被 try{}catch语句块所捕获
Error类体系描述了Java运行系统中的内部错误以及资源耗尽的情形，Error不需要捕捉
RuntimeException体系包括错误的类型转换、数组越界访问和试图访问空指针等等，必须被 try{}catch语句块所捕获
</code></pre> 
<p>D：运行时异常是在程序运行时发生的异常，编写的人也不知道会不会发生，所以不一定会被 try catch 捕获3</p> 
<h2><a id="46_1017"></a>46、</h2> 
<p>java Thread中，run方法和start方法的区别，下面说法错误的是？</p> 
<p>正确答案: B 你的答案: D (错误)</p> 
<pre><code>通过调用Thread类的start()方法来启动一个线程，这时此线程是处于就绪状态，并没有运行。
他们都可以实现了多线程运行。
run方法是thread的一个普通方法调用。
调用start方法后，一旦得到cpu时间片，就开始执行run()方法。
</code></pre> 
<p>两种方法的区别: 1.start方法 用 start方法来启动线程，是真正实现了多线程， 通过调用Thread类的start()方法来启动一个线程，这时此线程处于就绪（可运行）状态，并没有运行，一旦得到cpu时间片，就开始执行run()方法。但要注意的是，此时无需等待run()方法执行完毕，即可继续执行下面的代码。所以run()方法并没有实现多线程。</p> 
<p>2.run方法 run()方法只是类的一个普通方法而已，如果直接调用Run方法，程序中依然只有主线程这一个线程，其程序执行路径还是只有一条，还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行下面的代码。</p> 
<h2><a id="47_1034"></a>47、</h2> 
<pre><code class="prism language-java"><span class="token class-name">Integer</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
<span class="token class-name">Long</span> l <span class="token operator">=</span> <span class="token number">42l</span><span class="token punctuation">;</span>
<span class="token class-name">Double</span> d <span class="token operator">=</span> <span class="token number">42.0</span><span class="token punctuation">;</span>
</code></pre> 
<p>正确答案: G 你的答案: F (错误)</p> 
<pre><code>(i == l)
(i == d)
(l == d)
i.equals(d)
d.equals(l)
i.equals(l)
l.equals(42L)
</code></pre> 
<p>此题考查：equals 方法不能处理数据的转型，所以此题选最后一个选项</p> 
<h2><a id="48_1056"></a>48、</h2> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Base</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> baseName <span class="token operator">=</span> <span class="token string">"base"</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token function">callName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">callName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span> out<span class="token punctuation">.</span> <span class="token function">println</span><span class="token punctuation">(</span>baseName<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
 
    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Sub</span> <span class="token keyword">extends</span> <span class="token class-name">Base</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">private</span> <span class="token class-name">String</span> baseName <span class="token operator">=</span> <span class="token string">"sub"</span><span class="token punctuation">;</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">callName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token class-name">System</span><span class="token punctuation">.</span> out<span class="token punctuation">.</span> println <span class="token punctuation">(</span>baseName<span class="token punctuation">)</span> <span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Base</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre> 
<p>正确答案: A 你的答案: B (错误)</p> 
<pre><code>null
sub
base
</code></pre> 
<p><strong>编译看左，运行看右，会调用 Base 的构造器执行 callName 方法，由于子类中有，所以调用子类的构造器，此时子类还没有初始化，所以初始 null</strong></p> 
<h2><a id="49_1100"></a>49、</h2> 
<p>执行如下程序代码</p> 
<p>char chr = 127;</p> 
<p>int sum = 200;</p> 
<p>chr += 1;</p> 
<p>sum += chr;</p> 
<p>后，sum的值是 ; （ ）</p> 
<p>备注：同时考虑c/c++和Java的情况的话</p> 
<p>正确答案: A C 你的答案: C (错误)</p> 
<pre><code class="prism language-java"><span class="token number">72</span>
<span class="token number">99</span>
<span class="token number">328</span>
<span class="token number">327</span>
</code></pre> 
<p>java char 是 2个字节，不会越界，但是 c 是一个字节， 127 加上 1 就变成了 1000 0000，也就是 -128。</p> 
<h2><a id="50_1127"></a>50、</h2> 
<p>Java类Demo中存在方法func1、func2、func3和func4，请问该方法中，哪些是不合法的定义？( )</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span><span class="token punctuation">{<!-- --></span>

　　<span class="token keyword">float</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
　　<span class="token punctuation">{<!-- --></span>
　　　　<span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>
　　　　<span class="token keyword">return</span><span class="token punctuation">;</span>
　　<span class="token punctuation">}</span>
　　<span class="token keyword">float</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
　　<span class="token punctuation">{<!-- --></span>
　　　　<span class="token keyword">short</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>
　　　　<span class="token keyword">return</span> i<span class="token punctuation">;</span>
　　<span class="token punctuation">}</span>
　　<span class="token keyword">float</span> <span class="token function">func3</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
　　<span class="token punctuation">{<!-- --></span>
　　　　<span class="token keyword">long</span> i<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">;</span>
　　　　<span class="token keyword">return</span> i<span class="token punctuation">;</span>
　　<span class="token punctuation">}</span>
　　<span class="token keyword">float</span> <span class="token function">func4</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
　　<span class="token punctuation">{<!-- --></span>
　　　　<span class="token keyword">double</span> i<span class="token operator">=</span><span class="token number">4</span><span class="token punctuation">;</span>
　　　　<span class="token keyword">return</span> i<span class="token punctuation">;</span>
　　<span class="token punctuation">}</span>
<span class="token punctuation">}</span>	
</code></pre> 
<p>正确答案: A D 你的答案: A B C (错误)</p> 
<pre><code>func1
func2
func3
func4
</code></pre> 
<p><strong>考查强制类型转换问题，short 转换成 float 是自动转换，所以 fun2 正确</strong></p> 
<p><strong>long 转换成 float 也是自动转换，所有 fun3 正确，</strong></p> 
<p><strong>double 转换成 float 没有强制类型转换，是错误的，所以选 AD</strong></p> 
<p><img src="https://images2.imgbox.com/85/93/tEiRqbdy_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-VrSRC3up-1635822973371)(C:\Users\62459\AppData\Roaming\Typora\typora-user-images\image-20211030122754491.png)]"></p> 
<h2><a id="51_1175"></a>51、</h2> 
<p>在Java中，关于HashMap类的描述，以下错误的是（）？</p> 
<p>正确答案: A 你的答案: C (错误)</p> 
<pre><code>HashMap能够保证其中元素的顺序
HashMap允许将null用作值
HashMap允许将null用作键
HashMap使用键/值得形式保存数据
</code></pre> 
<p>C：HashMap 允许让一条 null 当做键</p> 
<p>A：HashMap的底层是由数组加链表实现的，对于每一个key值，都需要计算哈希值，然后通过哈希值来确定顺序，并不是按照加入顺序来存放的，因此可以认为是无序的，但不管是有序还是无序，它都一个自己的顺序</p> 
<h2><a id="52_1192"></a>52、</h2> 
<p>Java数据库连接库JDBC用到哪种设计模式?</p> 
<p>正确答案: B 你的答案: A (错误)</p> 
<pre><code>生成器
桥接模式
抽象工厂
单例模式
</code></pre> 
<p>桥接模式是结构型模式，关注点在依赖关系的维护。对于jdbc技术来说，它解耦了业务与数据库通信协议这两个纬度之间的关系，所以这两个纬度之间的关系就需要一个桥，即Driver</p> 
<h2><a id="53_1207"></a>53、</h2> 
<p>请求转发地址栏不变</p> 
<p>重定向地址栏改变</p> 
<h2><a id="54_1213"></a>54、</h2> 
<pre><code class="prism language-java"><span class="token keyword">double</span> d1<span class="token operator">=</span><span class="token operator">-</span><span class="token number">0.5</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Ceil d1="</span><span class="token operator">+</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">ceil</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"floor d1="</span><span class="token operator">+</span><span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>d1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>正确答案: A 你的答案: B (错误)</p> 
<pre><code>Ceil d1=-0.0
floor d1=-1.0
Ceil d1=0.0
floor d1=-1.0
</code></pre> 
<p><strong>ceil 是向上取整，floor 是向下取整，round 是四舍五入。</strong></p> 
<p>在 ceil 的代码注释中：If the argument value is less than zero but greater than -1.0, then the result is negative zero.</p> 
<p><img src="https://images2.imgbox.com/29/4a/cTo1VzNq_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Wp5NVarL-1635822973371)(C:\Users\62459\AppData\Roaming\Typora\typora-user-images\image-20211031142852520.png)]"></p> 
<p><strong>如果在 -1 和 0 之间，那么会输出 -0，也就是 negative zero</strong></p> 
<h2><a id="55_1239"></a>55、</h2> 
<p>Java是一门支持反射的语言,基于反射为Java提供了丰富的动态性支持，下面关于Java反射的描述，哪些是错误的：( )</p> 
<p>正确答案: A D F 你的答案: B E (错误)</p> 
<pre><code>Java反射主要涉及的类如Class, Method, Filed,等，他们都在java.lang.reflet包下
通过反射可以动态的实现一个接口，形成一个新的类，并可以用这个类创建对象，调用对象方法
通过反射，可以突破Java语言提供的对象成员、类成员的保护机制，访问一般方式不能访问的成员
Java反射机制提供了字节码修改的技术，可以动态的修剪一个类
Java的反射机制会给内存带来额外的开销。例如对永生堆的要求比不通过反射要求的更多
Java反射机制一般会带来效率问题，效率问题主要发生在查找类的方法和字段对象，因此通过缓存需要反射类的字段和方法就能达到与之间调用类的方法和访问类的字段一样的效率
</code></pre> 
<p>A：class 在 lang 包下面</p> 
<p>D：反射不能修剪一个类</p> 
<p>E：反射带来的效率问题主要是动态解析类，JVM没法对反射代码优化。</p> 
<h2><a id="56_1260"></a>56、</h2> 
<pre><code class="prism language-java"><span class="token keyword">enum</span> <span class="token class-name">AccountType</span>
<span class="token punctuation">{<!-- --></span>
    SAVING<span class="token punctuation">,</span> FIXED<span class="token punctuation">,</span> CURRENT<span class="token punctuation">;</span>
    <span class="token keyword">private</span> <span class="token class-name">AccountType</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"It is a account type"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">EnumOne</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span>args<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">AccountType</span><span class="token punctuation">.</span>FIXED<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>正确答案: C 你的答案: C (正确)</p> 
<pre><code>编译正确，输出”It is a account type”once followed by”FIXED”
编译正确，输出”It is a account type”twice followed by”FIXED”
编译正确，输出”It is a account type”thrice followed by”FIXED”
编译正确，输出”It is a account type”four times followed by”FIXED”
编译错误
</code></pre> 
<p>答案：C</p> 
<p>枚举类有三个实例，故调用三次构造方法，打印三次It is a account type</p> 
<h2><a id="57_1294"></a>57、</h2> 
<p>下列说法正确的是( )</p> 
<p>正确答案: C 你的答案: D (错误)</p> 
<pre><code>volatile,synchronized 都可以修改变量，方法以及代码块
volatile，synchronized 在多线程中都会存在阻塞问题
volatile能保证数据的可见性，但不能完全保证数据的原子性，synchronized即保证了数据的可见性也保证了原子性
volatile解决的是变量在多个线程之间的可见性、原子性，而sychroized解决的是多个线程之间访问资源的同步性
</code></pre> 
<p>volatile 和 synchronized 的对比：</p> 
<p>A、<strong>volatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。</strong></p> 
<p><strong>但是volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块</strong></p> 
<p>synchronized关键字之后进行了主要包括<strong>为了减少获得锁和释放锁带来的性能消耗</strong>而<strong>引入的偏向锁和轻量级锁以及其它各种优化</strong>之后执行效率有了显著提升，实际开发中<strong>使用 synchronized 关键字的场景还是更多</strong>一些。</p> 
<p><strong>B、多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</strong></p> 
<p><strong>C、violate 关键字能够保证数据的可见性，但是不能保证数据的原子性，而 synchronized 关键字都可以保证</strong></p> 
<p><strong>D、violate 关键字主要用与解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</strong></p> 
<h2><a id="58_1321"></a>58、</h2> 
<p>在上下文和头文件正常的情况下，代码</p> 
<pre><code>System.out.println(10%3*2);
</code></pre> 
<p>将打印？</p> 
<p>正确答案: B 你的答案: C (错误)</p> 
<pre><code>1
2
4
6
</code></pre> 
<p>%和*是同一个优先级，从左到右运算</p> 
<h2><a id="59_1342"></a>59、</h2> 
<p>在Java线程状态转换时，下列转换不可能发生的有（）？</p> 
<p>正确答案: A C 你的答案: A D (错误)</p> 
<pre><code>初始态-&gt;运行态
就绪态-&gt;运行态
阻塞态-&gt;运行态
运行态-&gt;就绪态
</code></pre> 
<p><img src="https://images2.imgbox.com/ec/e4/pDnCF0Wk_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-fZcWYoFI-1635822973372)(C:\Users\62459\AppData\Roaming\Typora\typora-user-images\image-20211102111011012.png)]"></p> 
<p>不可能的是</p> 
<p><strong>初始态 -&gt; 运行态</strong></p> 
<p><strong>阻塞态 -&gt; 运行态</strong></p> 
<h2><a id="60_1364"></a>60、</h2> 
<p><img src="https://images2.imgbox.com/65/31/HfhEYJgW_o.png" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-i9OxUqQr-1635822973373)(C:\Users\62459\AppData\Roaming\Typora\typora-user-images\image-20211102111209716.png)]"></p> 
<p>C中定义的抽象方法没有实体时候，大括号必须省略。</p> 
<h2><a id="61_1371"></a>61、</h2> 
<p>下面哪些赋值语句是正确的（）</p> 
<p>正确答案: A B D 你的答案: C D (错误)</p> 
<pre><code>long test=012
float f=-412
int other =(int)true
double d=0x12345678
byte b=128
</code></pre> 
<p>选ABD</p> 
<p><strong>A和B中long和float，正常定义需要加l和f，但是long和float属于基本类型，会进行转化，所以不会报出异常。AB正确</strong></p> 
<p><strong>boolean类型不能和任何类型进行转换，会报出类型异常错误。所以C错。</strong></p> 
<h2><a id="62_1391"></a>62、</h2> 
<p>以下说法哪个是正确的（）</p> 
<p>正确答案: A B C D 你的答案: A C (错误)</p> 
<pre><code>IOException在编译时会被发现
NullPointerEception在编译时不被发现
SQLException在编译时会被发现
FileNotFoundException在编译时会被发现
</code></pre> 
<h2><a id="63_1404"></a>63、</h2> 
<p>关于多线程和多进程，下面描述正确的是（）：<br> 正确答案: A C 你的答案: B D (错误)<br> 多进程里，子进程可获得父进程的所有堆和栈的数据；而线程会与同进程的其他线程共享数据，拥有自己的栈空间。<br> 线程因为有自己的独立栈空间且共享数据，所有执行的开销相对较大，同时不利于资源管理和保护。<br> 线程的通信速度更快，切换更快，因为他们在同一地址空间内。<br> 一个线程可以属于多个进程。</p> 
<p><strong>A.子进程得到的是除了代码段是与父进程共享以外，其他所有的都是得到父进程的一个副本，子进程的所有资源都继承父进程，得到父进程资源的副本，子进程可获得父进程的所有堆和栈的数据，但二者并不共享地址空间。两个是单独的进程，继承了以后二者就没有什么关联了，子进程单独运行；进程的线程之间共享由进程获得的资源，但线程拥有属于自己的一小部分资源，就是栈空间，保存其运行状态和局部自动变量的。<br> B.线程之间共享进程获得的数据资源，所以开销小，但不利于资源的管理和保护；而进程执行开销大，但是能够很好的进行资源管理和保护。<br> C.线程的通信速度更快，切换更快，因为他们共享同一进程的地址空间。<br> D.一个进程可以有多个线程，线程是进程的一个实体，是CPU调度的基本单位。</strong></p> 
<h2><a id="64_1417"></a>64、</h2> 
<p>在使用super和this关键字时，以下描述错误的是（）<br> 正确答案: B C D 你的答案: A B C D (错误)<br> 在子类构造方法中使用super()显示调用父类的构造方法，super()必须写在子类构造方法的第一行，否则编译不通过<br> super()和this()不一定要放在构造方法内第一行<br> this()和super()可以同时出现在一个构造函数中<br> this()和super()可以在static环境中使用，包括static方法和static语句块</p> 
<p><strong>super和this都只能位于构造器的第一行，而且不能同时使用，这是因为会造成初始化两次，this用于调用重载的构造器，super用于调用父类被子类重写的方法</strong></p> 
<h2><a id="65_1427"></a>65</h2> 
<p>如下代码的输出结果是什么？</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span> 
    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">aMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">static</span> <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        i<span class="token operator">++</span><span class="token punctuation">;</span> 
        <span class="token keyword">return</span> i<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    test<span class="token punctuation">.</span><span class="token function">aMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token keyword">int</span> j <span class="token operator">=</span> test<span class="token punctuation">.</span><span class="token function">aMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>答案：编译失败，因为静态变量属于类不属于方法，所以，static 修饰的变量不能在方法中声明，要在类中声明</strong></p> 
<h2><a id="66_1447"></a>66、</h2> 
<p>我们在程序中经常使用“System.out.println()”来输出信息，语句中的System是包名，out是类名，println是方法名。<br> 正确答案: B 你的答案: A (错误)<br> 对<br> 错</p> 
<p><strong>System 是 java.lang 包下面的一个类， out 是 System 内的一个成员变量， println 是方法名<br> （由于 out 首字母不是大写，所以按照规范来说不可能是类名）</strong></p> 
<h2><a id="67_1456"></a>67、</h2> 
<pre><code class="prism language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>正确答案: B 你的答案: C (错误)<br> 0<br> 1<br> 出现异常</p> 
<p><strong>String split 这个方法默认返回一个数组， 如果没有找到分隔符， 会把整个字符串当成一个长度为 1 的字符串数组返回到结果， 所以此处结果就是 1，所以这里用的是 length 而不是 length() 因为这里返回的是一个数组</strong></p> 
<h2><a id="68_1469"></a>68、</h2> 
<p>下面有关SPRING的事务传播特性，说法错误的是？<br> 正确答案: B 你的答案: 空 (错误)<br> PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行<br> PROPAGATION_REQUIRED：支持当前事务，如果当前没有事务，就抛出异常<br> PROPAGATION_REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起<br> PROPAGATION_NESTED：支持当前事务，新增Savepoint点，与当前事务同步提交或回滚</p> 
<p>Spring的API设计很不错，基本上根据英文翻译就能知道作用:Required:必须的。说明必须要有事物，没有就新建事物。supports:支持。说明仅仅是支持事务，没有事务就非事务方式执行。mandatory:强制的。说明一定要有事务，没有事务就抛出异常。required_new:必须新建事物。如果当前存在事物就挂起。not_supported:不支持事物，如果存在事物就挂起。never:绝不有事务。如果存在事物就抛出异常</p> 
<h2><a id="69_1479"></a>69、</h2> 
<p>如果Child extends Parent，那么正确的有（）？</p> 
<p>正确答案: B C D 你的答案: B C (错误)<br> 如果Child是class，且只有一个有参数的构造函数，那么必然会调用Parent中相同参数的构造函数<br> 如果Child是interface，那么Parent必然是interface<br> 如果Child是interface，那么Child可以同时extends Parent1，Parent2等多个interface<br> 如果Child是class，并且没有显示声明任何构造函数，那么此时仍然会调用Parent的构造函数</p> 
<p><strong>选BCD<br> A、子类的构造器第一行默认都是super()，默认调用直接父类的无参构造，一旦直接父类没有无参构造，那么子类必须显式的声明要调用父类或者自己的哪一个构造器。<br> BC、接口只能继承接口，但是可以多继承。类都是单继承，但是继承有传递性。<br> D、一个类一旦没有显式的定义任何构造，那么JVM会默认给你一个无参构造。无参构造的第一行依然默认是super()。</strong></p> 
<p><img src="https://images2.imgbox.com/36/1a/57giLeoT_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c2/a8/9ZnZ51wr_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="70_1496"></a>70、</h2> 
<p>关于volatile关键字，下列描述不正确的是？<br> 正确答案: B D 你的答案: B D (正确)<br> 用volatile修饰的变量，每次更新对其他线程都是立即可见的。<br> 对volatile变量的操作是原子性的。<br> 对volatile变量的操作不会造成阻塞。<br> 不依赖其他锁机制，多线程环境下的计数器可用volatile实现。</p> 
<p><strong>所谓 volatile的措施，就是<br> 1.每次从内存中取值，不从缓存中什么的拿值。这就保证了用 volatile 修饰的共享变量，每次的更新对于其他线程都是可见的。<br> 2.volatile保证了其他线程的立即可见性，就没有保证原子性。<br> 3.由于有些时候对 volatile的操作，不会被保存，说明不会造成阻塞。<br> 不可用与多线程环境下的计数器。</strong></p> 
<h2><a id="71_1510"></a>71、</h2> 
<p>在使用super和this关键字时，以下描述错误的是（）<br> 正确答案: B C D 你的答案: B D (错误)<br> 在子类构造方法中使用super()显示调用父类的构造方法，super()必须写在子类构造方法的第一行，否则编译不通过<br> super()和this()不一定要放在构造方法内第一行<br> this()和super()可以同时出现在一个构造函数中<br> this()和super()可以在static环境中使用，包括static方法和static语句块</p> 
<p><strong>1、super()表示调用父类构造函数、this()调用自己的构造函数，而自己的构造函数第一行要使用super()调用父类的构造函数，所以这俩不能在一个构造函数中会出现重复引用的情况<br> 2、super()和this()必须在构造函数第一行，所以这一点也表明他俩不能在一个构造函数中<br> 3、this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块(里面不能使用非static类型的)。</strong></p> 
<h2><a id="72_1522"></a>72</h2> 
<p>如果子类要调用父类的无参构造函数，则通过super（）调用来实现。<br> 正确答案: A 你的答案: B (错误)<br> 正确<br> 错误</p> 
<p><strong>如果父类已经有一个构造方法, 系统不会额外提供无参的构造方法，此时, <font color="red">如果父类仅定义了有参构造方法, 并且子类没有定义任何的构造方法(系统会为它提供一个无参构造方法, 然后隐式调用父类无参构造方法), 或子类定义的构造方法中没有显式调用父类的有参构造方法(会隐式调用父类的无参构造方法), 就都会因为父类没有无参构造方法而报错。</font></strong></p> 
<h2><a id="73_1530"></a>73、</h2> 
<p>下面代码输出结果是？</p> 
<pre><code class="prism language-java"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token operator">~</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>正确答案: C 你的答案: A (错误)<br> Compilation error because”~”doesn’t operate on integers<br> -5<br> -6<br> 15<br> <strong>~n == -n + 1</strong><br> <strong><font color="red">公式-n=<sub>n+1可推出</sub>n=-n-1，所以~10=-11再加5结果为-6</font></strong></p> 
<h2><a id="74_1545"></a>74、</h2> 
<p>如下哪些是 java 中有效的关键字（）</p> 
<p>正确答案: A D 你的答案: A C D (错误)<br> native<br> NULL<br> false<br> this</p> 
<p><strong><font color="red">true false null都不是关键字</font></strong><br> <strong><font color="red">true false null都不是关键字</font></strong><br> <strong><font color="red">true false null都不是关键字</font></strong></p> 
<h2><a id="75_1560"></a>75、</h2> 
<p><img src="https://images2.imgbox.com/55/2f/cwSL8ipl_o.png" alt="在这里插入图片描述"><br> 正确答案: A D 你的答案: B D (错误)<br> InsideOne ei=eo.new InsideOne();<br> eo.InsideOne ei=eo.new InsideOne();<br> InsideOne ei=EnclosingOne.new InsideOne();<br> EnclosingOne.InsideOne ei=eo.new InsideOne();</p> 
<p><strong>对于选择 A，B 选项，有一些分析如下：</strong></p> 
<p><strong><font color="red"> A 选项为什么是对的，是因为写了导包语句，将内部类的包导入了，否则是不能直接创建对象的，如图：</font></strong></p> 
<p><img src="https://images2.imgbox.com/41/4a/tu4MB2DB_o.png" alt="在这里插入图片描述"><br> <strong>但是如果写了导包语句，就可以直接 new 对象了，这里不附图了。</strong></p> 
<p><strong><font color="red"> 对于 B 选项，eo 是不能调用 类进行 new 对象的，只能是 D 选项那样 new 才对</font></strong></p> 
<h2><a id="76_1577"></a>76、</h2> 
<pre><code class="prism language-java"><span class="token class-name">Boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"false"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>正确答案: B 你的答案: A (错误)<br> 编译错误<br> true<br> false<br> 什么也没有输出</p> 
<p><strong>因为 if 里面用的是单等号，先赋值了</strong><br> <strong>if(flag = true)的时候flag已经是true了，所以输出true；<br> 要是为if(flag == true)输出才为false</strong></p> 
<h2><a id="77_1599"></a>77、</h2> 
<p>抽象类方法的访问权限默认都是public。（ ）<br> 正确答案: B 你的答案: A (错误)<br> 正确<br> 错误</p> 
<p><strong><font color="red"> 抽象类在 1.8 的版本下，默认的访问权限是 default</font></strong><br> <strong>关于抽象类<br> JDK 1.8以前，抽象类的方法默认访问权限为protected<br> JDK 1.8时，抽象类的方法默认访问权限变为default</strong></p> 
<h2><a id="78_1610"></a>78、</h2> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token keyword">implements</span> <span class="token class-name">B</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">int</span> i<span class="token punctuation">;</span>
        <span class="token class-name">A</span> a1<span class="token operator">=</span><span class="token keyword">new</span>  <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        i <span class="token operator">=</span>a1<span class="token punctuation">.</span>k<span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"i="</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">interface</span> <span class="token class-name">B</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">10</span>；
<span class="token punctuation">}</span>
</code></pre> 
<p>正确答案: B 你的答案: B (正确)<br> i=0<br> i=10<br> 程序有编译错误<br> i=true</p> 
<p><strong>需要注意：接口当中的变量都是 public static final 修饰的，是 公共的，最终的，静态的常量，可以直接调用</strong></p> 
<h2><a id="79_1635"></a>79、</h2> 
<p>在java7中，下列不能做switch()的参数类型是？<br> 正确答案: D 你的答案: B (错误)<br> int型<br> 枚举类型<br> 字符串<br> 浮点型</p> 
<p><strong><font color="blue"> switch 后面的控制表达式只能是 short，char， int， long 整数类型和枚举类型，不能是 float， double 和 boolean 类型，String 类型是从 java7 之后开始支持的</font></strong></p> 
<h2><a id="80_1646"></a>80、</h2> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> foo <span class="token punctuation">{<!-- --></span>
<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> sgf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

<span class="token class-name">StringBuffer</span> a<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>“<span class="token class-name">A</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">StringBuffer</span> b<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span>“<span class="token class-name">B</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">operate</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token operator">+</span>”<span class="token punctuation">.</span>”<span class="token operator">+</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token class-name">StringBuffer</span> x<span class="token punctuation">,</span><span class="token class-name">StringBuffer</span> y<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
x<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
y<span class="token operator">=</span>x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>正确答案: C 你的答案: 空 (错误)<br> 代码可以编译运行，输出“AB.AB”。<br> 代码可以编译运行，输出“A.A”。<br> 代码可以编译运行，输出“AB.B”。<br> 代码可以编译运行，输出“A.B”。</p> 
<p><strong><font color="blue"> 简单理解，一共四个引用<br> a -&gt; A<br> b - &gt;B<br> x -&gt; A<br> y - &gt;B<br> 然后开始调用 operate 方法，x 添加 y 元素，由于 a 和 x 指向的地址一样，所以此时 a 和 x 都指向 AB，此时 y = x，修改了 y 指针，此时 y 指向 AB，但是 b 指针一直没变，b 一直都是指向 B</font></strong></p> 
<h2><a id="81_1681"></a>81、</h2> 
<p>在java中重写方法应遵循规则的包括（）<br> 正确答案: B C 你的答案: A C (错误)<br> 访问修饰符的限制一定要大于被重写方法的访问修饰符<br> 可以有不同的访问修饰符<br> 参数列表必须完全与被重写的方法相同<br> 必须具有不同的参数列表</p> 
<p><strong><font color="blue">A：大于等于<br> B：可以，但是权限必须大于等于父类<br> C：重写方法的参数列表必须相同<br> D：自行理解把</font></strong></p> 
<h2><a id="82_1694"></a>82、</h2> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EqualsMethod</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Integer</span> n1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">47</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Integer</span> n2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">47</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>n1 <span class="token operator">==</span> n2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>n1 <span class="token operator">!=</span> n2<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>正确答案: B 你的答案: C (错误)<br> false，false<br> false，true<br> true，false<br> true，true</p> 
<p><strong>这个题目聪明反被聪明误了，此题考得并不是 128 陷阱，而是 new 对象，先说 128 的情况，如果题目中是这样给出的：</strong><br> <img src="https://images2.imgbox.com/87/52/E0UqAcXm_o.png" alt="在这里插入图片描述"><br> <strong>就是考察 128 陷阱，但是只要是 new 的对象，都是在 堆空间存储的，地址就是不一样的，所以此题得 false, true</strong></p> 
<h2><a id="83_1721"></a>83、</h2> 
<p>下面哪几个函数 public void example(){…} 的重载函数？（）<br> 正确答案: A D 你的答案: A B D (错误)<br> public void example(int m){…}<br> public int example(){…}<br> public void example2(){…}<br> public int example(int m,float f){…}</p> 
<p><strong>重载只要求参数列表不同，方法名称相同，不需要看返回类型</strong><br> <img src="https://images2.imgbox.com/7d/cd/z3ZTF52e_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="84_1731"></a>84、</h2> 
<p>volatile关键字的说法错误的是<br> 正确答案: A 你的答案: B (错误)<br> 能保证线程安全<br> volatile关键字用在多线程同步中，可保证读取的可见性<br> JVM保证从主内存加载到线程工作内存的值是最新的<br> volatile能禁止进行指令重排序</p> 
<p><strong>volatile用于限定变量只能从内存中读取，保证对所有线程而言，值都是一致的。但是volatile不能保证原子性，也就不能保证线程安全。但是允许数据的可见性</strong></p> 
<h2><a id="85_1741"></a>85、</h2> 
<pre><code class="prism language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">synchronized</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">}</span>
    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Test</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>正确答案: A C 你的答案: C D (错误)<br> 同一个对象，分别调用方法a和b，锁住的是同一个对象<br> 同一个对象，分别调用方法a和c，锁住的是同一个对象<br> 同一个对象，分别调用方法b和c，锁住的不是同一个对象<br> 同一个对象，分别调用方法a、b、c，锁住的不是同一个对象</p> 
<p><strong>修饰非静态方法 锁的是this 对象<br> 修饰静态方法 锁的是class对象</strong></p> 
<p><strong>对于 synchronize 修饰的非静态方法，锁定的是 this 对象，所以 ab 锁一个对象<br> 对于静态方法，锁定的是 class 对象，所以 cd 锁定的是一个对象</strong></p> 
<h2><a id="86_1772"></a>86、</h2> 
<p>下列说法正确的是（）？<br> 正确答案: A B 你的答案: A B C (错误)<br> 对于局部内部类，只有在方法的局部变量被标记为final或局部变量是effctively final的，内部类才能使用它们<br> 成员内部类位于外部类内部，可以直接调用外部类的所有方法（静态方法和非静态方法）<br> 由于匿名内部类只能用在方法内部，所以匿名内部类的用法与局部内部类是一致的<br> 静态内部类可以直接访问外部类的非静态成员</p> 
<p><strong>匿名内部类用法与局部内部类不一致，首先从定义上就不一样，匿名类用在任何允许存在表达式的地方，而局部内部类用于在任何允许出现局部变量的地方出现。<font color="red"> 还有更重要的是匿名类只能使用一次，而局部类则可以在自己的定义域内多次使用。</font></strong></p> 
<h2><a id="87_1782"></a>87、</h2> 
<p>定义类中成员变量时不可能用到的修饰是（）</p> 
<p>正确答案: B 你的答案: C (错误)<br> final<br> void<br> protected<br> static</p> 
<p><strong>不可能用 void啊</strong></p> 
<h2><a id="88_1793"></a>88、</h2> 
<p><img src="https://images2.imgbox.com/d9/e5/wSAzW89m_o.png" alt="在这里插入图片描述"><br> 正确答案: D 你的答案: B (错误)<br> try catch<br> try finally catch<br> try finally<br> try catch finally</p> 
<p><strong>结果为try catch finally,运行过程如下： 在执行到try代码块中，首先输出try，然后抛出异常，直接跳转到catch中，输出catch，然后跳转到finally块中，输出finally。</strong></p> 
<p><strong><font color="red"> 如果是如下这种情况，catch 语句有 return，那么就会先执行 catch 中 return 前面的语句，然后执行 finally 然后最后执行 return</font></strong><br> <img src="https://images2.imgbox.com/84/57/KOTgycF6_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/e4/20/0d8Ux3mj_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="89_1806"></a>89、</h2> 
<p>下列有关java构造函数叙述正确的是（）<br> 正确答案: C D 你的答案: A B C D (错误)<br> 构造器的返回值为void类型<br> 如果一个源文件中有多个类，那么构造器必须与公共类同名<br> 构造器可以有0个，1个或一个以上的参数<br> 每个类可以有一个以上的构造器</p> 
<p><strong>构造器没有返回类型<br> 构造器不一定与公共类同名，因为每个类都可能有构造器</strong></p> 
<h2><a id="90_1817"></a>90、</h2> 
<p>下面有关servlet中init,service,destroy方法描述错误的是？<br> 正确答案: D 你的答案: A (错误)<br> init()方法是servlet生命的起点。一旦加载了某个servlet，服务器将立即调用它的init()方法<br> service()方法处理客户机发出的所有请求<br> destroy()方法标志servlet生命周期的结束<br> servlet在多线程下使用了同步机制，因此，在并发编程下servlet是线程安全的</p> 
<p><strong>servlet在多线程下其本身<font color="red"> 并不是线程安全的。<br> 如果在类中定义成员变量，而在service中根据不同的线程对该成员变量进行更改，那么在并发的时候就会引起错误。最好是在方法中，定义局部变量，而不是类变量或者对象的成员变量。由于方法中的局部变量是在栈中，彼此各自都拥有独立的运行空间而不会互相干扰，因此才做到线程安全。</font></strong></p> 
<h2><a id="91_1828"></a>91、</h2> 
<p>字符界面下接受用户从键盘输入，需要import的包是：（ ）</p> 
<p>正确答案: C 你的答案: A (错误)<br> java.lang包<br> java.awt包<br> java.io包<br> java.applet包</p> 
<p><strong>这个问题的前提是：字符界面下<br> <font color="red">前端用户输入、后台程序获取，都是字符流的传输，因此需要导入java.io包。</font></strong><br> <strong>而java.util中的 Scanner 则是获取控制台的输入。<br> 因此，答案选C</strong></p> 
<h2><a id="92_1842"></a>92、</h2> 
<p>下面关于volatile的功能说法正确的是哪个<br> 正确答案: B C 你的答案: B C D (错误)<br> 原子性<br> 有序性<br> 可见性<br> 持久性</p> 
<p><strong>有序性和可见性</strong></p> 
<h2><a id="93_1852"></a>93、</h2> 
<p>jre 判断程序是否执行结束的标准是（）</p> 
<p>正确答案: A 你的答案: C (错误)<br> 所有的前台线程执行完毕<br> 所有的后台线程执行完毕<br> 所有的线程执行完毕<br> 和以上都无关</p> 
<p><strong><font color="red"> 前台线程执行完毕</font></strong></p> 
<h2><a id="94_1863"></a>94、</h2> 
<p>关于Java中参数传递的说法，哪个是错误的？<br> 正确答案: D 你的答案: A (错误)<br> 在方法中，修改一个基础类型的参数不会影响原始参数值<br> 在方法中，改变一个对象参数的引用不会影响到原始引用<br> 在方法中，修改一个对象的属性会影响原始对象参数<br> 在方法中，修改集合和Maps的元素不会影响原始集合参数</p> 
<p>A、<img src="https://images2.imgbox.com/9e/95/upZJKpo7_o.png" alt="在这里插入图片描述"><br> D、举例：修改 集合中的元素当然会影响原始集合<br> <img src="https://images2.imgbox.com/0e/a8/Yjo3C8mP_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="95_1874"></a>95、</h2> 
<p>关于依赖注入，下列选项中说法错误的是（）<br> 正确答案: B 你的答案: D (错误)<br> 依赖注入能够独立开发各组件，然后根据组件间关系进行组装<br> 依赖注入使组件之间相互依赖，相互制约<br> 依赖注入提供使用接口编程<br> 依赖注入指对象在使用时动态注入</p> 
<p><strong>依赖注入的动机就是<font color="red"> 减少组件之间的耦合度，使开发更为简洁</font></strong></p> 
<h2><a id="96_1884"></a>96、</h2> 
<p>下面有关forward和redirect的描述，正确的是() ？</p> 
<p>正确答案: B C D 你的答案: B C (错误)</p> 
<p>forward是服务器将控制权转交给另外一个内部服务器对象，由新的对象来全权负责响应用户的请求</p> 
<p><strong>执行forward时，浏览器不知道服务器发送的内容是从何处来，浏览器地址栏中还是原来的地址</strong></p> 
<p><strong>执行redirect时，服务器端告诉浏览器重新去请求地址</strong></p> 
<p><strong>forward是内部重定向，redirect是外部重定向</strong></p> 
<p>redirect默认将产生301 Permanently moved的HTTP响应</p> 
<h2><a id="97_1899"></a>97、</h2> 
<p>以下可以正确获取结果集的有<br> 正确答案: A D 你的答案: B C (错误)</p> 
<pre><code class="prism language-cpp">Statement sta<span class="token operator">=</span>con<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ResultSet rst<span class="token operator">=</span>sta<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>“select <span class="token operator">*</span> from book”<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-cpp">Statement sta<span class="token operator">=</span>con<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span>“select <span class="token operator">*</span> from book”<span class="token punctuation">)</span><span class="token punctuation">;</span> 
ResultSet rst<span class="token operator">=</span>sta<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-cpp">PreparedStatement pst<span class="token operator">=</span>con<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ResultSet rst<span class="token operator">=</span>pst<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span>“select <span class="token operator">*</span> from book”<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<pre><code class="prism language-cpp">PreparedStatement pst<span class="token operator">=</span>con<span class="token punctuation">.</span><span class="token function">prepareStatement</span><span class="token punctuation">(</span>“select <span class="token operator">*</span> from book”<span class="token punctuation">)</span><span class="token punctuation">;</span>
ResultSet rst<span class="token operator">=</span>pst<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><strong><font color="blue"> 答案选 AD，Statement 是不传递参数的，但是 PreparedStatement 是需要传递 sql 语句的</font></strong></p> 
<h2><a id="98_1924"></a>98、</h2> 
<p>关于抽象类和接口叙述正确的是？ ( )</p> 
<p>正确答案: D 你的答案: C (错误)<br> 抽象类和接口都能实例化的<br> 抽象类不能实现接口<br> 抽象类方法的访问权限默认都是public<br> 接口方法的访问权限默认都是public</p> 
<pre><code class="prism language-cpp"><span class="token number">1</span>、抽象类和方法都不能被实例化
<span class="token number">2</span>、抽象类可以实现接口
<span class="token number">3</span>、抽象类方法默认访问权限都是<span class="token keyword">default</span>
<span class="token number">4</span>、接口就是访问的，默认访问权限都是<span class="token keyword">public</span>
</code></pre> 
<h2><a id="99_1941"></a>99、</h2> 
<p>下列哪个选项是Java调试器？如果编译器返回程序代码的错误，可以用它对程序进行调试。<br> 正确答案: C 你的答案: B (错误)<br> java<br> javadoc<br> jdb<br> javaprof</p> 
<pre><code class="prism language-cpp">java调试器jdb<span class="token punctuation">.</span>exe
</code></pre> 
<h2><a id="100_1953"></a>100、</h2> 
<p>DBMS 中实现事务持久性的子系统是()</p> 
<p>正确答案: D 你的答案: 空 (错误)<br> 安全性管理子系统<br> 完整性管理子系统<br> 并发控制子系统<br> 恢复管理子系统</p> 
<pre><code class="prism language-cpp">持久性<span class="token operator">:</span>一个事务一旦提交，那么它对数据库产生的影响就是永久的不可逆的，如果后面再回滚或者出异常，都不会影响已提交的事务（由DBMS的恢复管理子系统实现的）
</code></pre> 
<h2><a id="101_1965"></a>101、</h2> 
<p>下列Java代码中的变量a、b、c分别在内存的____存储区存放。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">private</span> String a <span class="token operator">=</span> “aa”<span class="token punctuation">;</span>
    <span class="token keyword">public</span> boolean <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        String b <span class="token operator">=</span> “bb”<span class="token punctuation">;</span>
        final String c <span class="token operator">=</span> “cc”<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-cpp">正确答案：堆区、栈区、栈区
</code></pre> 
<p>a是类中的成员变量，存放在堆区<br> b、c都是方法中的局部变量，存放在栈区</p> 
<h2><a id="102_1985"></a>102、</h2> 
<p>下面哪些选项是正确的（）</p> 
<p>正确答案: A D 你的答案: A C (错误)</p> 
<pre><code class="prism language-cpp"><span class="token operator">&gt;&gt;</span>是算术右移操作符
<span class="token operator">&gt;&gt;</span>是逻辑右移操作符
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>是算术右移操作符
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span>是逻辑右移操作符
</code></pre> 
<p><strong>两个是算术移动，高位补符号位，能保证符号<br> 三个是逻辑移动，补零，不能保证符号</strong></p> 
<h2><a id="103_1999"></a>103、</h2> 
<p>JAVA反射机制主要提供了以下哪些功能？<br> 正确答案: A B C D 你的答案: A C D (错误)<br> 在运行时判断一个对象所属的类<br> 在运行时构造一个类的对象<br> 在运行时判断一个类所具有的成员变量和方法<br> 在运行时调用一个对象的方法</p> 
<h2><a id="104_2007"></a>104、</h2> 
<p>下面有关java的引用类型，说法正确的有？<br> 正确答案: A B C D 你的答案: A B C (错误)<br> 对于一个对象来说，只要有强引用的存在，它就会一直存在于内存中<br> 如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。<br> 如果一个对象只具有软引用，则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存<br> 一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的空间</p> 
<h2><a id="105_2016"></a>105、</h2> 
<p>下面的switch语句中，x可以是哪些类型的数据：()</p> 
<pre><code class="prism language-cpp"><span class="token keyword">switch</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
<span class="token keyword">default</span><span class="token operator">:</span>
System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>正确答案: B D 你的答案: B D E (错误)<br> long<br> char<br> float<br> byte<br> double<br> Object</p> 
<pre><code class="prism language-cpp">jdk1<span class="token punctuation">.</span><span class="token number">7</span>之前byte<span class="token punctuation">,</span><span class="token keyword">short</span> <span class="token punctuation">,</span><span class="token keyword">int</span> <span class="token punctuation">,</span><span class="token keyword">char</span>
jdk1<span class="token punctuation">.</span><span class="token number">7</span>之后加入String 
</code></pre> 
<p><strong><font color="red"> 所以 1.8 支持的类型有：byte， short， int， char， String</font></strong></p> 
<h2><a id="106_2039"></a>106、</h2> 
<p>@SuppressWarnings(“deprecation”)的功能是什么？<br> 正确答案: A 你的答案: D (错误)<br> 屏蔽不赞同使用的类和方法的警告<br> 屏蔽在强制类型转换的时候编译器给出的警告<br> 关闭所有警告信息<br> 当在可序列化的类上缺少serialVersionUID定义的警告</p> 
<p><strong>如果在注解上加了 @deprecation 注解，说明是不建议使用的</strong><br> <img src="https://images2.imgbox.com/63/a1/BjOAk1Fw_o.png" alt="在这里插入图片描述"><br> <strong>但是如果加上 @SuppressWarings 就是屏蔽那些不赞同使用的注解</strong><br> <img src="https://images2.imgbox.com/2d/71/J1ehSU4w_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a2/24/T1Ylz8ab_o.png" alt="在这里插入图片描述"><br> <strong>所以此题选 A。</strong></p> 
<h2><a id="107_2054"></a>107、</h2> 
<p>要导入java/awt/event下面的所有类，叙述正确的是？()</p> 
<p>正确答案: C 你的答案: A (错误)<br> import java.awt.<em>和import java.awt.event.<em>都可以<br> 只能是import java.awt.</em><br> 只能是import java.awt.event.</em><br> import java.awt.*和import java.awt.event.*都不可以</p> 
<p><strong><font color="red"> 导包只可以导到当前层，不可以再导入包里面的包中的类</font></strong></p> 
<h2><a id="108_2068"></a>108、</h2> 
<p>Which statement is true for the class java.util.ArrayList?<br> 正确答案: A 你的答案: B (错误)<br> The elements in the collection are ordered.<br> The collection is guaranteed to be immutable.<br> The elements in the collection are guaranteed to be unique.<br> The elements in the collection are accessed using a unique key.<br> The elements in the collections are guaranteed to be synchronized.</p> 
<p><strong><font color="red"> 这里 immutable 的意思是不可变的，所以错误<br> A 的意思是，元素插入的过程中记录了元素的插入顺序，所以是有序的，而不是自动排序的意思</font></strong></p> 
<h2><a id="109_2080"></a>109、</h2> 
<p>ArrayList list = new ArrayList(20);中的list扩充几次<br> 正确答案: A 你的答案: C (错误)<br> 0<br> 1<br> 2<br> 3</p> 
<p><strong>Arraylist默认数组大小是10，扩容后的大小是扩容前的1.5倍，最大值小于Integer 的最大值减 8，<font color="red">如果新创建的集合有带初始值，默认就是传入的大小，也就不会扩容</font></strong></p> 
<p><strong>总结：带有初始值，默认转入大小，不会扩容</strong></p> 
<h2><a id="110_2092"></a>110、</h2> 
<p>list是一个ArrayList的对象，哪个选项的代码填到//todo delete处，可以在Iterator遍历的过程中正确并安全的删除一个list中保存的对象？（）</p> 
<pre><code class="prism language-cpp">Iterator it <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    Object obj <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">needDelete</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">//needDelete返回boolean，决定是否要删除</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token comment">//todo delete</span>
    <span class="token punctuation">}</span>
    index <span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>想在循环语句中删除集合中的某个元素，就要用迭代器iterator的remove()方法，因为remove()方法不仅会删除元素，还会维护一个标志，用来记录目前是不是可删除状态，例如，不能连续两次调用remove()方法，调用之前至少有一次next()方法的调用。</strong></p> 
<h2><a id="111_2110"></a>111、</h2> 
<p>Object obj = it.next();<br> if (needDelete(obj)) //needDelete返回boolean，决定是否要删除</p> 
<pre><code class="prism language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">getNum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token keyword">return</span> <span class="token number">3.0f</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> extends A<span class="token punctuation">{<!-- --></span>
    【代码】
<span class="token punctuation">}</span>

</code></pre> 
<p>正确答案: B 你的答案: D (错误)<br> public float getNum(){return 4.0f}<br> public void getNum(){}<br> public void getNum(double d){}<br> public double getNum(float d){return 4.0d}</p> 
<p><strong>重写需要满足的条件<br> 1、参数列表完全相同<br> 2、返回类型小于等于父类方法的返回类型<br> 3、访问权限小于等于父类方法的的访问权限<br> <font color="red"> A、参数列表相同，返回类型相同，是正确重写<br> B、参数列表相同，返回值类型不同，不满足重写条件<br> C、参数不同，返回类型不同，这是同名的方法，不是重写，只是方法名称一样而已<br> D、同 C</font></strong></p> 
<h2><a id="112_2142"></a>112、</h2> 
<p>下面有关jdbc statement的说法错误的是？<br> 正确答案: C 你的答案: D (错误)<br> JDBC提供了Statement、PreparedStatement 和 CallableStatement三种方式来执行查询语句，其中 Statement 用于通用查询， PreparedStatement 用于执行参数化查询，而 CallableStatement则是用于存储过程<br> 对于PreparedStatement来说，数据库可以使用已经编译过及定义好的执行计划，由于 PreparedStatement 对象已预编译过，所以其执行速度要快于 Statement 对象”<br> PreparedStatement中，“?” 叫做占位符，一个占位符可以有一个或者多个值<br> PreparedStatement可以阻止常见的SQL注入式攻击</p> 
<p><strong>选择C<br> JDBC statement中的PReparedStatement的占位符对应着即将与之对应当值，并且一个占位符只能对应一个值，如果能对应多个就会引起混淆。sql语句是确定的，那么一个占位符必定只能对应一个值</strong></p> 
<h2><a id="113_2153"></a>113、</h2> 
<p>下面哪些Java中的流对象是字节流?</p> 
<p>正确答案: A B C D 你的答案: A D (错误)<br> FileInputStream<br> BufferedInputStream<br> PushbackInputStream<br> ByteArrayInputStream</p> 
<p><strong>stream结尾都是字节流，reader和writer结尾都是字符流 两者的区别就是读写的时候一个是按字节读写，一个是按字符</strong></p> 
<h2><a id="114_2164"></a>114、</h2> 
<p>类之间存在以下几种常见的关系：<br> 正确答案: A B C 你的答案: B C (错误)<br> “USES-A”关系<br> “HAS-A”关系<br> “IS-A”关系<br> “INHERIT-A”关系<br> <strong><font color="blue"> USES-A：依赖关系，A类会用到B类，这种关系具有偶然性，临时性。但B类的变化会影响A类。这种在代码中的体现为：A类方法中的参数包含了B类。</font></strong><br> <strong>关联关系：A类会用到B类，这是一种强依赖关系，是长期的并非偶然。在代码中的表现为：A类的成员变量中含有B类。</strong><br> <strong><font color="pink"> HAS-A：聚合关系，拥有关系，是关联关系的一种特例，是整体和部分的关系。比如鸟群和鸟的关系是聚合关系，鸟群中每个部分都是鸟。</font></strong><br> <strong><font color="purple"> IS-A：表示继承。父类与子类，这个就不解释了。</font></strong><br> <strong>组合关系也是关联关系的一种特例，它体现一种contains-a的关系，这种关系比聚合更强，也称为强聚合。它同样体现整体与部分的关系，但这种整体和部分是不可分割</strong>的。</p> 
<h2><a id="115_2178"></a>115、</h2> 
<p>下面哪种情况会导致持久区jvm堆内存溢出？<br> 正确答案: C 你的答案: C (正确)<br> 循环上万次的字符串处理<br> 在一段代码内申请上百M甚至上G的内存<br> 使用CGLib技术直接操<br> 作字节码运行，生成大量的动态类<br> 不断创建对象</p> 
<p><strong><font color="red"> 年老代溢出原因有 循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存，既A B D选项<br> 持久代溢出原因 动态加载了大量Java类而导致溢出</font></strong></p> 
<h2><a id="116_2192"></a>116、</h2> 
<p>一个文件中的数据要在控制台上显示，首先需要（ ）。<br> 正确答案: C 你的答案: A (错误)<br> System.out.print (buffer[i]);<br> FileOutputStream fout = new FileOutputStream(this.filename);<br> FileInputStream fin = new FileInputStream(this.filename);。<br> System.in.read(buffer)。</p> 
<p><strong>一个文件中的数据要在控制台显示，首先需要获取文件中的内容，使用FileInputStream fin = new FileInputStream(this.filename);</strong></p> 
<h2><a id="117_2202"></a>117、</h2> 
<p>off-heap是指那种内存（）<br> 正确答案: B 你的答案: C (错误)<br> JVM GC能管理的内存<br> JVM进程管理的内存<br> 在JVM老年代内存区<br> 在JVM新生代内存</p> 
<p><strong>off-heap叫做堆外内存，将你的对象从堆中脱离出来序列化，然后存储在一大块内存中，这就像它存储到磁盘上一样，但它仍然在RAM中。对象在这种状态下不能直接使用，它们必须首先反序列化，也不受垃圾收集。</strong></p> 
<h2><a id="118_2212"></a>118、</h2> 
<p>设有下面两个赋值语句：</p> 
<p>a = Integer.parseInt(“1024”);</p> 
<p>b = Integer.valueOf(“1024”).intValue();</p> 
<p>下述说法正确的是（）<br> 正确答案: D 你的答案: A (错误)<br> a是整数类型变量，b是整数类对象。<br> a是整数类对象，b是整数类型变量。<br> a和b都是整数类对象并且它们的值相等。<br> a和b都是整数类型变量并且它们的值相等。</p> 
<p><strong>intValue()是把Integer对象类型变成int的基础数据类型；<br> parseInt()是把String 变成int的基础数据类型；<br> Valueof()是把String 转化成Integer对象类型；（现在JDK版本支持自动装箱拆箱了。）<br> 本题：<font color="blue"> parseInt得到的是基础数据类型 int，<font color="red"> valueof 得到的是装箱数据类型 Integer，<font color="blue"> 然后再通过valueInt转换成int，所以选择D</font></font></font></strong></p> 
<h2><a id="119_2232"></a>119、</h2> 
<p>如何获取ServletContext设置的参数值？<br> 正确答案: B 你的答案: A (错误)<br> context.getParameter()<br> context.getInitParameter()<br> context.getAttribute()<br> context.getRequestDispatcher()</p> 
<p><strong>getParameter() 是获取POST/GET传递的参数值；<br> getInitParameter获取Tomcat的server.xml中设置 Context 的初始化参数</strong></p> 
<h2><a id="120_2243"></a>120、</h2> 
<p>对文件名为Test.java的java代码描述正确的是()<br> 复制代码</p> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">String</span> name <span class="token operator">=</span> <span class="token string">"No name"</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token class-name">String</span> nm<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        name <span class="token operator">=</span> nm<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Employee</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span> <span class="token punctuation">{<!-- --></span>
    <span class="token class-name">String</span> empID <span class="token operator">=</span> <span class="token string">"0000"</span><span class="token punctuation">;</span>
    <span class="token keyword">public</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token class-name">String</span> id<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        empID <span class="token operator">=</span> id<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span> args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Employee</span> e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Employee</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>empID<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>正确答案: C 你的答案: B (错误)<br> 输出：0000<br> 输出：123<br> 编译报错<br> 输出：No name</p> 
<p><strong>由于 子类的构造方法总是先调用父类的构造方法，所以如果子类没有明确地指调用父类的哪个方法，就会调用无参的，但是本题没有无参数的构造方法，所以子类需要在构造方法中显示地调用父类的构造函数</strong></p> 
<p><strong>直接会上 debug 看执行顺序：</strong></p> 
<p><img src="https://images2.imgbox.com/77/42/KzP7TwIZ_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/c2/f1/YH3MqBx6_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/34/a3/LzVlyZal_o.png" alt="在这里插入图片描述"><br> <strong>如果修改代码，父类有无参的，就会改变编译顺序：</strong><br> <img src="https://images2.imgbox.com/5a/17/JSrdPhhe_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="130_2282"></a>130、</h2> 
<p>建立Statement对象的作用是？<br> 正确答案: C 你的答案: B (错误)<br> 连接数据库<br> 声明数据库<br> <strong><strong>执行SQL语句</strong></strong><br> 保存查询结果</p> 
<p><strong>1、Statement对象用于执行不带参数的简单SQL语句。<br> 2、Prepared Statement 对象用于执行预编译SQL语句。<br> 3、Callable Statement对象用于执行对存储过程的调用。</strong></p> 
<h2><a id="131_2295"></a>131、</h2> 
<p>String s = new String(“xyz”);创建了几个StringObject？<br> 正确答案: A 你的答案: C (错误)<br> 两个或一个都有可能<br> 两个<br> 一个<br> 三个</p> 
<p><strong>如果字符串常量池有，就只会创建一个，否则会创建两个</strong></p> 
<h2><a id="132_2306"></a>132、</h2> 
<p>String s = new String(“xyz”);创建了几个StringObject？<br> 正确答案: A 你的答案: C (错误)<br> 两个或一个都有可能<br> 两个<br> 一个<br> 三个</p> 
<p><strong>抛InterruptedException的代表方法有：</strong></p> 
<p><strong><font color="red"> java.lang.Object 类的 wait 方法</font></strong></p> 
<p><strong><font color="red"> java.lang.Thread 类的 sleep 方法</font></strong></p> 
<p><strong><font color="red"> java.lang.Thread 类的 join 方法</font></strong></p> 
<h2><a id="133_2323"></a>133、</h2> 
<p>下列叙述中，错误的是（ ）</p> 
<p>正确答案: B 你的答案: D (错误)<br> File类能够存储文件属性<br> File类能够读写文件<br> File类能够建立文件<br> File类能够获取文件目录信息</p> 
<p><strong>能够读写文件的是数据流（OutputStream和InputStream）</strong></p> 
<h2><a id="134_2334"></a>134、</h2> 
<p>This调用语句必须是构造函数中的第一个可执行语句。<br> 正确答案: B 你的答案: A (错误)<br> 正确<br> 错误</p> 
<p><strong>this()才必须是构造函数中的第一个可执行语句，用this调用语句并不需要。</strong></p> 
<h2><a id="135_2342"></a>135、</h2> 
<p>jre 判断程序是否执行结束的标准是（）</p> 
<p>正确答案: A 你的答案: C (错误)<br> 所有的前台线程执行完毕<br> 所有的后台线程执行完毕<br> 所有的线程执行完毕<br> 和以上都无关</p> 
<p><strong>所有的前台线程执行完毕是 jre 判断执行结束的标准</strong></p> 
<h2><a id="136_2354"></a>136、</h2> 
<pre><code class="prism language-java"><span class="token keyword">class</span> <span class="token class-name">Two</span><span class="token punctuation">{<!-- --></span>
    <span class="token class-name">Byte</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">PassO</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">PassO</span> p<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">PassO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        p<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token class-name">Two</span> t<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Two</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>x<span class="token operator">+</span>””<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">Two</span> t2<span class="token operator">=</span><span class="token function">fix</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>x<span class="token operator">+</span>” ” <span class="token operator">+</span>t2<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token class-name">Two</span> <span class="token function">fix</span><span class="token punctuation">(</span><span class="token class-name">Two</span> tt<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        tt<span class="token punctuation">.</span>x<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> tt<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><strong>包装类 Byte 类型，是变量，初始化是 null</strong><br> <strong>使用 fix 传递的是地址，所以 t 的值也是改变的</strong></p> 
<p><strong>sizeof 不是 java 的关键字</strong></p> 
<h2><a id="137_2384"></a>137、</h2> 
<p>下列哪个修饰符可以使在一个类中定义的成员变量只能被同一包中的类访问？<br> 正确答案: B 你的答案: D (错误)<br> private<br> 无修饰符<br> public<br> protected<br> <img src="https://images2.imgbox.com/14/62/tb1by2NB_o.png" alt="在这里插入图片描述"><br> <strong><font color="red"> protected：可以被同一包的所有类访问，子类就算不在同一个包，也能访问<br> default：可以被同一包的所有类访问</font></strong></p> 
<h2><a id="138_2396"></a>138、</h2> 
<p>下面选项中,哪些是interface中合法方法定义?()<br> 正确答案: A C D 你的答案: D (错误)<br> public void main(String [] args);<br> private int getSum();<br> boolean setFlag(Boolean [] test);<br> public float get(int x);</p> 
<p><strong>B 选项：由于接口中的方法必须被实现，private 修饰了以后就访问不到了，所以接口中的方法不能是 private 类型的。</strong></p> 
<h2><a id="139_2406"></a>139、</h2> 
<p><strong>servlet 线程不安全，因为 在Servlet类中可能会定义共享的类变量，这样在并发的多线程访问的情况下，不同的线程对成员变量的修改会引发错误。</strong></p> 
<h2><a id="140_2409"></a>140、</h2> 
<p><strong>switch 里面的参数不能是 浮点型，String 是在 java7 以后支持的</strong></p> 
<h2><a id="141_2412"></a>141、</h2> 
<p><strong>接口可以定义成员变量但必须是常量</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/e6a47d6509249e64547029b901150b12/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">五角星代码</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0e1f0971da4d6ba14a129a0cfd2c120b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">java.lang.IllegalStateException: 提交响应后无法转发</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>