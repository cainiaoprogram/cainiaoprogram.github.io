<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Linux 内存管理篇(2)内核初始化与内存管理启用 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Linux 内存管理篇(2)内核初始化与内存管理启用" />
<meta property="og:description" content="前言 继内存寻址之后， 本篇开始介绍Linux内核地址空间初始化过程。
通过内存寻址篇我们知道， Linux 系统运行过程中位于保护模式,系统必须要是用MMU来完成地址寻址， 这就依赖于段表跟页表。
但是问题来了, 系统是如何将段表跟页表是如何装入的呢？
本文通过 Linux 系统初始化过程，开始介绍内存管理的构建过程。
BIOS 时代: 当PC机加电的那一刻，主机开始获取操作指令，初始化操作系统。
这个时候，系统cpu是运行在实模式(详情见说明)下的, CPU最开始从0xFFFF0 处定位BIOS通过影子内存(详情见说明)定位BIOS第一条指令。
BIOS 就开始地检测内存、显卡等外设信息，当硬件检测通过之后，就在内存的物理内存的起始位置 0x000 ~ 0x3FF建立中断向量表。
然后, BIOS 将启动磁盘中的第1个扇区（MBR 扇区，Master Boot Record）的 512 个字节的数据加载到物理内存地址为 0x7C00 ~ 0x7E00 的区域，然后程序就跳转到 0x7C00 处开始执行，至此，BIOS 就完成了所有的工作，将控制权转交到了 MBR 中的代码。通过MBR加载Linux 内核映像。
实模式运行阶段: 先将内核镜像文件中的起始第一部分 boot/setup.bin 加载到 0x7c00 地址之上的物理内存中，然后跳转到 setup.bin 文件中的入口地址开始执行。
涉及的文件有 arch/x86/boot/header.S、链接脚本setup.ld、arch/x86/boot/main.c。header.S 第一部分定义了 .bstext、.bsdata、.header 这 3 个节，共同构成了vmlinuz 的第一个512字节(即引导扇区的内容)。常量 BOOTSEG 和 SYSSEG 定义了引导扇区和内核的载入的地址。
BOOTSEG = 0x07C0 /* original address of boot-sector */ SYSSEG = 0x1000 /* historical load address &gt;&gt; 4 */ 主要完成的工作:" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/47f954723de5a5209682c12f3effa795/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-01-15T16:30:05+08:00" />
<meta property="article:modified_time" content="2020-01-15T16:30:05+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Linux 内存管理篇(2)内核初始化与内存管理启用</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>前言</h4> 
<p>继<a href="https://links.jianshu.com/go?to=https%3A%2F%2Faiden-dong.github.io%2F2019%2F04%2F03%2FLinux-%25E5%2586%2585%25E5%25AD%2598%25E7%25AE%25A1%25E7%2590%2586%25E7%25AF%2587%25E4%25B9%258B%25E5%2586%2585%25E5%25AD%2598%25E5%25AF%25BB%25E5%259D%2580%2F" rel="nofollow">内存寻址</a>之后， 本篇开始介绍Linux内核地址空间初始化过程。</p> 
<p>通过内存寻址篇我们知道， Linux 系统运行过程中位于保护模式,系统必须要是用<strong>MMU</strong>来完成地址寻址， 这就依赖于<strong>段表</strong>跟<strong>页表</strong>。</p> 
<p>但是问题来了, 系统是如何将段表跟页表是如何装入的呢？</p> 
<p>本文通过 Linux 系统初始化过程，开始介绍内存管理的构建过程。</p> 
<h4>BIOS 时代:</h4> 
<p>当PC机加电的那一刻，主机开始获取操作指令，初始化操作系统。</p> 
<p>这个时候，系统cpu是运行在<strong>实模式</strong>(详情见说明)下的, CPU最开始从<strong>0xFFFF0</strong> 处定位BIOS通过<strong>影子内存</strong>(详情见说明)定位BIOS第一条指令。</p> 
<p>BIOS 就开始地检测内存、显卡等外设信息，当硬件检测通过之后，就在内存的物理内存的起始位置 <code>0x000 ~ 0x3FF</code>建立<strong>中断向量表</strong>。</p> 
<p>然后, BIOS 将启动磁盘中的第1个扇区（<strong>MBR 扇区</strong>，Master Boot Record）的 512 个字节的数据加载到物理内存地址为 <code>0x7C00 ~ 0x7E00</code> 的区域，然后程序就跳转到 <code>0x7C00</code> 处开始执行，至此，BIOS 就完成了所有的工作，将控制权转交到了 MBR 中的代码。通过MBR加载Linux 内核映像。</p> 
<h4>实模式运行阶段:</h4> 
<p>先将内核镜像文件中的起始第一部分 <code>boot/setup.bin</code> 加载到 <code>0x7c00</code> 地址之上的物理内存中，然后跳转到 setup.bin 文件中的入口地址开始执行。</p> 
<p>涉及的文件有 <code>arch/x86/boot/header.S</code>、<code>链接脚本setup.ld</code>、<code>arch/x86/boot/main.c</code>。<code>header.S</code> 第一部分定义了 <code>.bstext</code>、<code>.bsdata</code>、<code>.header</code> 这 3 个节，共同构成了vmlinuz 的第一个512字节(即引导扇区的内容)。常量 <code>BOOTSEG</code> 和 <code>SYSSEG</code> 定义了引导扇区和内核的载入的地址。</p> 
<p> </p> 
<pre class="has"><code>BOOTSEG     = 0x07C0        /* original address of boot-sector */
SYSSEG      = 0x1000        /* historical load address &gt;&gt; 4 */
</code></pre> 
<blockquote> 
 <p>主要完成的工作:</p> 
</blockquote> 
<ul><li>初始化早期启动状态下的控制台（console）。</li><li>初始化临时堆栈空间。</li><li>检测 CPU 相关信息。</li><li>通过向 BIOS 查询的方式，收集硬件相关信息，并将结果存放在第 0 号物理页中。</li></ul> 
<blockquote> 
 <p>实模式下的最终内存模型</p> 
</blockquote> 
<p><img alt="" class="has" src="https://images2.imgbox.com/04/c2/RnOlj6vC_o.png"></p> 
<p>image.png</p> 
<h4>保护模式运行模式</h4> 
<p>第一次处于保护模式下-内核加载</p> 
<p>为了进入保护模式,需要先设置gdt,这个时候的gdt为boot_gdt,代码段和数据段描述符中的基址都为0.</p> 
<p> </p> 
<pre class="has"><code>arch/x86/boot/pm.c    

static void setup_gdt(void)
{           
     /* There are machines which are known to not boot with the GDT
         being 8-byte unaligned.  Intel recommends 16 byte alignment. */
         
      static const u64 boot_gdt[] __attribute__((aligned(16))) = {
          /* CS: code, read/execute, 4 GB, base 0 */
          [GDT_ENTRY_BOOT_CS] = GDT_ENTRY(0xc09b, 0, 0xfffff),
          /* DS: data, read/write, 4 GB, base 0 */
          [GDT_ENTRY_BOOT_DS] = GDT_ENTRY(0xc093, 0, 0xfffff),
          /* TSS: 32-bit tss, 104 bytes, base 4096 */
          /* We only have a TSS here to keep Intel VT happy;
             we don't actually use it for anything. */
          [GDT_ENTRY_BOOT_TSS] = GDT_ENTRY(0x0089, 4096, 103),
      }; 
      
      /* Xen HVM incorrectly stores a pointer to the gdt_ptr, instead
         of the gdt_ptr contents.  Thus, make it static so it will
          stay in memory, at least long enough that we switch to the
         proper kernel GDT. */
      
      static struct gdt_ptr gdt;
              
      gdt.len = sizeof(boot_gdt)-1;
      gdt.ptr = (u32)&amp;boot_gdt + (ds() &lt;&lt; 4);
              
      asm volatile("lgdtl %0" : : "m" (gdt));   //加载段描述符
 } 
</code></pre> 
<p>当完成以上内容后， 置 CPU <code>PE</code>标志为1， 打开保护模式， 这时候分页还没有开启。<br> 进入保护模式后,就设置各个段选择子.所有段寄存器(<code>ds</code>、<code>es</code>、<code>fs</code>、<code>gs</code>、<code>ss</code>)都为设置为 <code>_BOOT_DS</code> 选择子.</p> 
<p>再由于没有分页,所以线性地址就是物理地址.</p> 
<p>然后, 把内核镜像 bzImage 中的第二部分 <code>boot/vmlinux.bin</code> 加载到物理内存中起始地址为 <code>0x100000</code> 的位置.</p> 
<ul><li>将 <code>boot/vmlinux.bin</code> 文件中解压内核的代码拷贝到物理内存中 <code>boot/vmlinux.bin</code> 的后面。</li><li>初始化 stack 和 heap 空间。</li><li>解压缩内核，解压缩后的内核就是我们从源码编译得到的 vmlinux ELF 可执行文件。</li></ul> 
<p>第二次设置 gdtr</p> 
<p>解压完内核后就应该跳入真正的内核,即内核中第二个 <code>startup_32()</code> .这个时候的整个vmlinux的编译链接地址都是从虚拟地址(线性地址) <code>0xc0000000(__PAGE_OFFSET)</code> 开始的,所以需要重新设置下段寻址。</p> 
<p>这个是linux内核第二次设置段寻址,称为第二次进入保护模式.</p> 
<p>这一次设置的原因是在之前的处理过程中，指令地址是从物理地址<code>0x100000</code> 开始的，而此时整个 vmlinux 的编译链接地址是从虚拟地址 <code>0xC0000000(__PAGE_OFFSET)</code> 开始的，所以需要在这里重新设置 <code>boot_gdt</code> 的位置。</p> 
<p> </p> 
<pre class="has"><code>ENTRY(startup_32)
    cld
    lgdt boot_gdt_descr - __PAGE_OFFSET
    movl $(__BOOT_DS),%eax
    movl %eax,%ds
    movl %eax,%es
    movl %eax,%fs
    movl %eax,%gs

/*
 * Clear BSS first so that there are no surprises...
 * No need to cld as DF is already clear from cld above...
 */
    xorl %eax,%eax
    movl $__bss_start - __PAGE_OFFSET,%edi
    movl $__bss_stop - __PAGE_OFFSET,%ecx
    subl %edi,%ecx
    shrl $2,%ecx
    rep ; stosl
</code></pre> 
<p>内核运行到这个时候,所有段基址都是0x00000000开始,而内核链接的线性地址都是从虚拟地址0xc0000000,但是这个时候还没有开启分页,那如果要访问一个变量应该怎么寻址呢?<br> 则使用 <code>X-__PAGE_OFFSET</code> 如上所示,或者使用 <code>__pa</code>, <code>__va</code> 宏定义:</p> 
<p> </p> 
<pre class="has"><code>#define __pa(x)         ((unsigned long)(x)-PAGE_OFFSET)
#define __va(x)         ((void *)((unsigned long)(x)+PAGE_OFFSET))
</code></pre> 
<p>进入分页模式 - 建立临时内核页表</p> 
<p>虽然可以使用<code>X-__PAGE_OFFSET</code>来获得真实位置,但是依然不是长久之计,当务之急是开启分页,在内核编译链接时,就已经存在了一张全局目录:</p> 
<p> </p> 
<pre class="has"><code>ENTRY(swapper_pg_dir)
    .fill 1024,4,0
</code></pre> 
<p>内核通过把<code>swapper_pg_dir</code>所有项都填充为0来创建期望映射，不过 <code>0</code>, <code>1</code>, <code>0x300</code>(768项)，<code>0x301</code>(769项)除外。</p> 
<ul><li><code>0</code> 项和 <code>0x300</code> 项的地址字段置位 <code>pg0</code> 的物理地址，</li><li><code>1</code> 项和 <code>0x301</code> 项的地址字段置为紧随 pg0后的页框的物理地址。</li><li>这四项的 <code>Present</code>, <code>Read</code>/<code>Write</code> 和 <code>User</code>/<code>Supervisor</code> 标志都置位</li><li>把这四项中的 <code>Accessed</code>, <code>Dirty</code>, <code>PCD</code>, <code>PWD</code> <code>和Page Size</code> 标志清零。</li></ul> 
<p>pg0 这两个页表分别实现如下范围内的映射关系，依次实现对物理地址前8M 的寻址</p> 
<p> </p> 
<pre class="has"><code>0x00000000 - 0x007fffff -&gt; 0x00000000 - 0x007fffff
0xc0000000 - 0xc07fffff -&gt; 0x00000000 - 0x007fffff
</code></pre> 
<p>在第一次开启分页时就把这张表作为<strong>页全局目录</strong>,将其地址给<code>cr3寄存器</code>，并开启分页.</p> 
<p> </p> 
<pre class="has"><code>movl $swapper_pg_dir-__PAGE_OFFSET,%eax
movl %eax,%cr3      /* set the page table pointer.. */
movl %cr0,%eax
orl $0x80000000,%eax
movl %eax,%cr0      /* ..and set paging (PG) bit */
</code></pre> 
<p>第三次设置 gdtr:</p> 
<p>开启分页之后， 接下来就通过分页寻址得到编译好的最终全局描述符表 gdt 的地址(<code>cpu_gdt_table</code>),将其地址付给gdtr，把段寄存器初始化为最终值。</p> 
<h4>收尾</h4> 
<p>通过以上系统初始过程， Linux 进入保护保护模式， 并完成对前 8M RAM内存空间的映射关系。</p> 
<p>接下来便可以在保护模式下对内核代码段与数据段进行寻址。</p> 
<p><img alt="" class="has" src="https://images2.imgbox.com/bd/bc/gd2DHsen_o.png"></p> 
<p>image.png</p> 
<p>后续，代码跳转到 <code>start_kernel()</code> 函数, 完成 Linux内核初始化工作。</p> 
<ul><li>调度程序初始化</li><li>内存管理区初始化</li><li>伙伴系统分配程序初始化</li><li>IDT 初始化</li><li>slab 分配器初始化</li></ul> 
<p>...</p> 
<hr> 
<blockquote> 
 <p>说明:</p> 
</blockquote> 
<ul><li>内核版本 <code>2.6.11.2</code></li><li>处理机: <code>i386</code></li></ul> 
<blockquote> 
 <p>实模式 :</p> 
</blockquote> 
<p>它是 Intel公司 <code>80286</code> 及以后的x86(<code>80386</code>,<code>80486</code>等)处理器的一种操作模式。<br> 实模式被特殊定义为20位地址内存可访问空间上，这就意味着它的容量是(1M)的可访问内存空间（物理内存和BIOS-ROM），软件可通过这些地址直接访问BIOS程序和外围硬件。<br> 实模式下处理器没有硬件级的内存保护概念和多道任务的工作模式。但是为了向下兼容，所以80286及以后的x86系列兼容处理器仍然是开机启动时工作在实模式下。</p> 
<p>在寻址上实模式采用了<strong>分段寻址模式</strong>, 具体为: <strong>[16位段基地址DS]</strong>:<strong>[16位偏移EA]</strong> 组成。<br> 其地址换算方式为: <code>物理地址 = (DS &lt;&lt; 4) +EA</code>, 例如 <code>1000:FFFF = 1FFFFF</code></p> 
<p>虽然理论上这种寻址模式支持的最大值为<code>FFFF:FFFF=10FFEF</code>, 但是由于只有20为有效地址总线，所以无法对第21为进行寻址。<br> 为了解决上述兼容性问题，IBM使用键盘控制器上剩余的一些输出线来管理第21根地址线（从0开始数是第20根） 的有效性，被称为<strong>A20</strong>：<br> 如果A20 Gate被打开，则当程序员给出100000H-10FFEFH之间的地址的时候，系统将真正访问这块内存区域</p> 
<blockquote> 
 <p>影子内存</p> 
</blockquote> 
<p>影子内存(Shadow RAM，或称ROM shadow)是为了提高系统效率而采用的一种专门技术。它把系统主板上的系统ROM BIOS和适配器卡上的视频ROM BIOS等拷贝到系统RAM内存中去运行，其地址仍使用它们在上位内存中占用的原地址。</p> 
<p>确切地说，是将ROM中的数据，拷贝至RAM。</p> 
<p>“影子”内存所占用的空间是768KB—1024KB之间的区域。</p> 
<blockquote> 
 <p>参考文档 :</p> 
</blockquote> 
<p><a href="https://links.jianshu.com/go?to=http%3A%2F%2Fwww.maxwellxxx.com%2Flinuxearlymemory" rel="nofollow">Linux内核初始化阶段内存管理的几种阶段(1) maxwellxxx's Blog</a></p> 
<p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwoshijpf.github.io%2F%25E5%2586%2585%25E6%25A0%25B8%2F2017%2F06%2F26%2FLinux-%25E5%2586%2585%25E6%25A0%25B8%25E5%258A%25A0%25E8%25BD%25BD%25E5%2590%25AF%25E5%258A%25A8%25E8%25BF%2587%25E7%25A8%258B%25E5%2588%2586%25E6%259E%2590.html" rel="nofollow">Linux 内核加载启动过程分析</a></p> 
<p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Flongintchar%2Farticle%2Fdetails%2F79464007" rel="nofollow">setup.s 分析—— Linux-0.11 学习笔记（二） - ARM的程序员敲着诗歌的梦 - CSDN博客</a></p> 
<p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fkennyrose%2Farticle%2Fdetails%2F7563649" rel="nofollow">CPU 实模式 保护模式 和虚拟8086模式 - 辉仔 の专栏 - CSDN博客</a></p> 
<p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fblog.csdn.net%2Fvanbreaker%2Farticle%2Fdetails%2F7549681" rel="nofollow">Linux页表机制初始化 - vanbreaker的专栏 - CSDN博客</a></p> 
<p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2Fsaligia-eva%2Fdocument%2Fblob%2Fmaster%2F%25E6%25B7%25B1%25E5%2585%25A5%25E7%2590%2586%25E8%25A7%25A3linux%25E5%2586%2585%25E6%25A0%25B8%25E4%25B8%25AD%25E6%2596%2587%25E7%25AC%25AC%25E4%25B8%2589%25E7%2589%2588.pdf" rel="nofollow">document/深入理解linux内核中文第三版.pdf at master · saligia-eva/document · GitHub</a></p> 
<p><a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.kernel.org" rel="nofollow">The Linux Kernel Archives</a></p> 
<p><br><br> 作者：陌城小川<br> 链接：https://www.jianshu.com/p/c5770a06507a<br> 来源：简书<br> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/189652fa3489d70434b617be2728e94d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">python中print用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/b187b029a142942a4cb4afaa73e47cee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">NPM提示版本依赖报错：No matching version found for</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>