<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android进程间通信 - 几种方式的对比总结 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android进程间通信 - 几种方式的对比总结" />
<meta property="og:description" content=" 文章目录 什么是RPC什么是IPC参考 什么是RPC RPC（Remote Procedure Call）即远程过程调用，它是一种通过网络从远程计算机程序上请求服务，在不需要了解底层网络技术的协议下，即可获取计算机进程中的数据。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。
RPC在OSI网络通信7层模型中，位于传输层与应用层之间，即位于会话层：
RPC实现模式，就是我们常说的C/S结构，引用百度百科的定义：
RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。
简而言之：客户端能向服务端发送若干个进程请求，服务端根据发送的进程参数依次返回对应的计算结果。RPC可以说客户端调用服务端的接口的过程，是面向接口的编程。
RPC在Android中咋样体现的，我们看看官方的解释RPC与IPC的关系
Android 利用远程过程调用 (RPC) 提供了一种进程间通信 (IPC) 机制，通过这种机制，由 Activity 或其他应用组件调用的方法将（在其他进程中）远程执行，而所有结果将返回给调用方。 这就要求把方法调用及其数据分解至操作系统可以识别的程度，并将其从本地进程和地址空间传输至远程进程和地址空间，然后在远程进程中重新组装并执行该调用。 然后，返回值将沿相反方向传输回来。 Android 提供了执行这些 IPC 事务所需的全部代码，因此您只需集中精力定义和实现 RPC 编程接口即可。
要执行 IPC，必须使用 bindService() 将应用绑定到服务上。
也就是说，RPC在的Android具体体现，是依赖 bindService()的方式，在onBind方法将服务端的计算结果返回给客户端（Activity等组件）的过程。
什么是IPC IPC 即 Inter-Process Communication (进程间通信)，是指进程间数据交互的过程。
Android底层是基于Linux，而Linux基于安全考虑，是不允许两个进程间直接操作对方的数据，这就是进程隔离
在Linux系统中，虚拟内存机制为每个进程分配了线性连续的内存空间，操作系统将这种虚拟内存空间映射到物理内存空间，每个进程有自己的虚拟内存空间，进而不能操作其他进程的内存空间，每个进程只能操作自己的虚拟内存空间，只有操作系统才有权限操作物理内存空间.进程隔离保证了每个进程的内存安全，但是在大多数情形下，不同进程间的数据通讯是不可避免的，因此操作系统必须提供跨进程通信机制。
虽然Android是基于Linux，但并不能继承Linux中的进程通信的方式，Android有着自己进程间通信方式。常用有如下几种：
Bundle （四大组件间）文件共享 可参考Android进程通信 - 序列化Serialzable与Parcelable中的示例 AIDL （基于Binder） 能自动生成Binder文件的工具，相当于工具。Android进程通信 - AIDL的使用方法 Messenger（基于Binder） 类似于Hnadler发消息用法Android进程间通信 - Messenger的使用和理解 ContentProvider（基于Binder） Android进程间通信 - ContentProvider内容提供者 Socket（网络） Android进程间通信 - Socket使用（TCP、UDP） 下面引用Android开发艺术探索的总结，已经很全面了
参考 Android开发艺术探索https://blog.csdn.net/u010132993/article/details/72582655https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E5%8D%8F%E8%AE%AE/6893245?fromtitle=RPC&amp;fromid=609861https://developer.android.com/guide/components/processes-and-threadshttps://blog.csdn.net/u011240877/article/details/72863432 " />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/d8505c321b51705a8f3474efe61b03de/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-29T21:12:45+08:00" />
<meta property="article:modified_time" content="2018-07-29T21:12:45+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android进程间通信 - 几种方式的对比总结</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><ul><li><a href="#RPC_1" rel="nofollow">什么是RPC</a></li><li><a href="#IPC_22" rel="nofollow">什么是IPC</a></li><li><a href="#_46" rel="nofollow">参考</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h3><a id="RPC_1"></a>什么是RPC</h3> 
<p>RPC（Remote Procedure Call）即<code>远程过程调用</code>，它是一种通过网络从远程计算机程序上请求服务，在不需要了解底层网络技术的协议下，即可获取计算机进程中的数据。RPC使得开发包括网络分布式多程序在内的应用程序更加容易。</p> 
<p>RPC在OSI网络通信7层模型中，位于<code>传输层</code>与<code>应用层</code>之间，即位于<code>会话层</code>：<br> <img src="https://images2.imgbox.com/3e/81/ShL5inhi_o.jpg" alt="这里写图片描述"></p> 
<p>RPC实现模式，就是我们常说的C/S结构，引用百度百科的定义：</p> 
<blockquote> 
 <p>RPC采用客户机/服务器模式。请求程序就是一个客户机，而服务提供程序就是一个服务器。首先，客户机调用进程发送一个有进程参数的调用信息到服务进程，然后等待应答信息。在服务器端，进程保持睡眠状态直到调用信息到达为止。当一个调用信息到达，服务器获得进程参数，计算结果，发送答复信息，然后等待下一个调用信息，最后，客户端调用进程接收答复信息，获得进程结果，然后调用执行继续进行。</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/08/9a/lCNZeebj_o.png" alt="这里写图片描述"></p> 
<p>简而言之：客户端能向服务端发送若干个进程请求，服务端根据发送的进程参数依次返回对应的计算结果。RPC可以说客户端调用服务端的接口的过程，是面向接口的编程。</p> 
<p>RPC在Android中咋样体现的，我们看看官方的解释<a href="https://developer.android.com/guide/components/processes-and-threads" rel="nofollow">RPC与IPC的关系</a></p> 
<blockquote> 
 <p>Android 利用远程过程调用 (RPC) 提供了一种进程间通信 (IPC) 机制，通过这种机制，由 Activity 或其他应用组件调用的方法将（在其他进程中）远程执行，而所有结果将返回给调用方。 这就要求把方法调用及其数据分解至操作系统可以识别的程度，并将其从本地进程和地址空间传输至远程进程和地址空间，然后在远程进程中重新组装并执行该调用。 然后，返回值将沿相反方向传输回来。 Android 提供了执行这些 IPC 事务所需的全部代码，因此您只需集中精力定义和实现 RPC 编程接口即可。<br> 要执行 IPC，必须使用 bindService() 将应用绑定到服务上。</p> 
</blockquote> 
<p>也就是说，RPC在的Android具体体现，是依赖 bindService()的方式，在onBind方法将服务端的计算结果返回给客户端（Activity等组件）的过程。</p> 
<h3><a id="IPC_22"></a>什么是IPC</h3> 
<p>IPC 即 Inter-Process Communication (进程间通信)，是指进程间数据交互的过程。<br> Android底层是基于Linux，而Linux基于安全考虑，是不允许两个进程间直接操作对方的数据，这就是<code>进程隔离</code></p> 
<blockquote> 
 <p>在Linux系统中，虚拟内存机制为每个进程分配了线性连续的内存空间，操作系统将这种虚拟内存空间映射到物理内存空间，每个进程有自己的虚拟内存空间，进而不能操作其他进程的内存空间，每个进程只能操作自己的虚拟内存空间，只有操作系统才有权限操作物理内存空间.进程隔离保证了每个进程的内存安全，但是在大多数情形下，不同进程间的数据通讯是不可避免的，因此操作系统必须提供跨进程通信机制。</p> 
</blockquote> 
<p>虽然Android是基于Linux，但并不能继承Linux中的进程通信的方式，Android有着自己进程间通信方式。常用有如下几种：</p> 
<ul><li>Bundle （四大组件间）</li><li>文件共享 
  <ul><li>可参考<a href="https://blog.csdn.net/hzw2017/article/details/80978663">Android进程通信 - 序列化Serialzable与Parcelable</a>中的示例</li></ul> </li><li>AIDL （基于Binder） 
  <ul><li>能自动生成Binder文件的工具，相当于工具。</li><li><a href="https://blog.csdn.net/hzw2017/article/details/81048650">Android进程通信 - AIDL的使用方法</a></li></ul> </li><li>Messenger（基于Binder） 
  <ul><li>类似于Hnadler发消息用法</li><li><a href="https://blog.csdn.net/hzw2017/article/details/81090319">Android进程间通信 - Messenger的使用和理解</a></li></ul> </li><li>ContentProvider（基于Binder） 
  <ul><li><a href="https://blog.csdn.net/hzw2017/article/details/81123791">Android进程间通信 - ContentProvider内容提供者</a></li></ul> </li><li>Socket（网络） 
  <ul><li><a href="https://blog.csdn.net/hzw2017/article/details/81210979">Android进程间通信 - Socket使用（TCP、UDP）</a></li></ul> </li></ul> 
<p>下面引用Android开发艺术探索的总结，已经很全面了<br> <img src="https://images2.imgbox.com/da/c4/hJE2nqiG_o.jpg" alt="这里写图片描述"></p> 
<h3><a id="_46"></a>参考</h3> 
<ul><li>Android开发艺术探索</li><li>https://blog.csdn.net/u010132993/article/details/72582655</li><li>https://baike.baidu.com/item/%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8%E5%8D%8F%E8%AE%AE/6893245?fromtitle=RPC&amp;fromid=609861</li><li>https://developer.android.com/guide/components/processes-and-threads</li><li>https://blog.csdn.net/u011240877/article/details/72863432</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d57606ef0cc7eea479cffd4f9cf74703/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">【Linux】Linux的进程调度</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/249c2a1d7195e3e2633656fa42196ddc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">python3_实现BP神经网络 &#43; BP神经网络应用实例</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>