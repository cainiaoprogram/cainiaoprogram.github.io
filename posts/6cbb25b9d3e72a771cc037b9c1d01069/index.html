<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>HAL库教程9：串口接收不定长数据 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="HAL库教程9：串口接收不定长数据" />
<meta property="og:description" content="串口收到的两组数据之间，往往会有一定的时间间隔。可以判断这个间隔，来实现无需结束符，无需指定长度，串口可接收不定长数据的功能。如果串口在一定的时间内没有收到新的数据，可以认为一组数据已经接收完毕了。思路是用定时器来设置一个“闹钟”，连续的一段时间没有收到新的数据，闹钟响起，就把已经收到的数据打包，做相应处理。
定时器溢出时间配置 首先修改定时器的溢出时间。本文规定使用5ms的间隔。在某些通信协议中，会规定间隔时间。例如Modbus规定两组数据之间要间隔3.5字符。
实际上，间隔的时间常常与通信的波特率是相关的。在9600波特率下，一个字节的数据共 起始&#43;8数据&#43;结束=10位，一位是104us，所以一个字节的数据是1.04ms，3.5个字节，我们就认为是4ms。有时可能有校验位，稍微保险一点，5ms吧。假如使用115200的波特率，5ms已经算是非常“奢侈”了。
本文使用定时器3来计时，配置的PSC为8399，ARR为49，可得5ms的溢出时间，配置过程可以参考通用定时器章节。
串口接收中断服务函数 我们在串口接收中断服务中，把收到的所有数据都放到数组中去，判断收到的是否是第一个字符，如果是则开启定时器。
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { if(huart-&gt;Instance==USART1) { __HAL_TIM_SET_COUNTER(&amp;htim3,0); if(0 == UART1_Rx_cnt)//如果是第一个字符，则开启定时器 { __HAL_TIM_CLEAR_FLAG(&amp;htim3,TIM_FLAG_UPDATE); HAL_TIM_Base_Start_IT(&amp;htim3); } UART1_Rx_Buf[UART1_Rx_cnt] = UART1_temp[0]; UART1_Rx_cnt&#43;&#43;; HAL_UART_Receive_IT(&amp;huart1,(uint8_t *)UART1_temp,REC_LENGTH); } } 其中__HAL_TIM_SET_COUNTER是HAL提供的一个宏定义，类似于函数，功能是通过宏来直接修改寄存器的值。
由于HAL库的串口接收中断在每次执行后都会关闭，所有在串口的中断里要重新手动开启串口接收中断。
另外，由于定时器中断在开启定时器的时候就会执行，所以需要开启定时器之前就把中断标记位清除。
定时器中断服务 一旦定时器发生溢出中断，说明已经到了5ms的时间间隔，可以把数据截断，根据业务需求来做相应处理，我的做法是设着一个标志位，然后在主函数的死循环内不断检测标志位，如果标志位被置1，则把收到的数据发送出去。
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if(htim==(&amp;htim3)) { LED1 = !LED1; UART1_Rx_flg = 1; HAL_TIM_Base_Stop_IT(&amp;htim3);//关闭定时器 } } //main() while(1) if(UART1_Rx_flg) { HAL_UART_Transmit(&amp;huart1,UART1_Rx_Buf,UART1_Rx_cnt,0xffff); //发送接收到的数据 for(int i = 0;i&lt;UART1_Rx_cnt;i&#43;&#43;) UART1_Rx_Buf[i] = 0; UART1_Rx_cnt = 0; UART1_Rx_flg = 0; } 功能是串口接收什么就回复什么，但无需结束符，也不用指定长度。当然最长不能超过UART1_Rx_Buf数据的大小。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/6cbb25b9d3e72a771cc037b9c1d01069/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-16T09:18:28+08:00" />
<meta property="article:modified_time" content="2019-04-16T09:18:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">HAL库教程9：串口接收不定长数据</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>  串口收到的两组数据之间，往往会有一定的时间间隔。可以判断这个间隔，来实现无需结束符，无需指定长度，串口可接收不定长数据的功能。如果串口在一定的时间内没有收到新的数据，可以认为一组数据已经接收完毕了。思路是用定时器来设置一个“闹钟”，连续的一段时间没有收到新的数据，闹钟响起，就把已经收到的数据打包，做相应处理。</p> 
<h3><a id="_1"></a>定时器溢出时间配置</h3> 
<p>  首先修改定时器的溢出时间。本文规定使用5ms的间隔。在某些通信协议中，会规定间隔时间。例如Modbus规定两组数据之间要间隔3.5字符。<br>   实际上，间隔的时间常常与通信的波特率是相关的。在9600波特率下，一个字节的数据共 起始+8数据+结束=10位，一位是104us，所以一个字节的数据是1.04ms，3.5个字节，我们就认为是4ms。有时可能有校验位，稍微保险一点，5ms吧。假如使用115200的波特率，5ms已经算是非常“奢侈”了。<br>   本文使用定时器3来计时，配置的PSC为8399，ARR为49，可得5ms的溢出时间，配置过程可以参考通用定时器章节。</p> 
<h3><a id="_5"></a>串口接收中断服务函数</h3> 
<p>  我们在串口接收中断服务中，把收到的所有数据都放到数组中去，判断收到的是否是第一个字符，如果是则开启定时器。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">HAL_UART_RxCpltCallback</span><span class="token punctuation">(</span>UART_HandleTypeDef <span class="token operator">*</span>huart<span class="token punctuation">)</span>

<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>huart<span class="token operator">-&gt;</span>Instance<span class="token operator">==</span>USART1<span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    <span class="token function">__HAL_TIM_SET_COUNTER</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>htim3<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">==</span> UART1_Rx_cnt<span class="token punctuation">)</span><span class="token comment">//如果是第一个字符，则开启定时器</span>
    <span class="token punctuation">{<!-- --></span>
    <span class="token function">__HAL_TIM_CLEAR_FLAG</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>htim3<span class="token punctuation">,</span>TIM_FLAG_UPDATE<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">HAL_TIM_Base_Start_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>htim3<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    UART1_Rx_Buf<span class="token punctuation">[</span>UART1_Rx_cnt<span class="token punctuation">]</span> <span class="token operator">=</span> UART1_temp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    UART1_Rx_cnt<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token function">HAL_UART_Receive_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span><span class="token punctuation">(</span>uint8_t <span class="token operator">*</span><span class="token punctuation">)</span>UART1_temp<span class="token punctuation">,</span>REC_LENGTH<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>  其中__HAL_TIM_SET_COUNTER是HAL提供的一个宏定义，类似于函数，功能是通过宏来直接修改寄存器的值。<br>   由于HAL库的串口接收中断在每次执行后都会关闭，所有在串口的中断里要重新手动开启串口接收中断。<br>   另外，由于定时器中断在开启定时器的时候就会执行，所以需要开启定时器之前就把中断标记位清除。</p> 
<h3><a id="_28"></a>定时器中断服务</h3> 
<p>  一旦定时器发生溢出中断，说明已经到了5ms的时间间隔，可以把数据截断，根据业务需求来做相应处理，我的做法是设着一个标志位，然后在主函数的死循环内不断检测标志位，如果标志位被置1，则把收到的数据发送出去。</p> 
<pre><code class="prism language-c"><span class="token keyword">void</span> <span class="token function">HAL_TIM_PeriodElapsedCallback</span><span class="token punctuation">(</span>TIM_HandleTypeDef <span class="token operator">*</span>htim<span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>htim<span class="token operator">==</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>htim3<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">{<!-- --></span>
    LED1 <span class="token operator">=</span> <span class="token operator">!</span>LED1<span class="token punctuation">;</span>
    UART1_Rx_flg <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token function">HAL_TIM_Base_Stop_IT</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>htim3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//关闭定时器</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<pre><code class="prism language-c"><span class="token comment">//main() while(1)</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>UART1_Rx_flg<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
      <span class="token function">HAL_UART_Transmit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>huart1<span class="token punctuation">,</span>UART1_Rx_Buf<span class="token punctuation">,</span>UART1_Rx_cnt<span class="token punctuation">,</span><span class="token number">0xffff</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//发送接收到的数据</span>
      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>UART1_Rx_cnt<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>
        UART1_Rx_Buf<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      UART1_Rx_cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
      UART1_Rx_flg <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>   
</code></pre> 
<p>  功能是串口接收什么就回复什么，但无需结束符，也不用指定长度。当然最长不能超过UART1_Rx_Buf数据的大小。<br> 附上<a href="https://download.csdn.net/download/geek_monkey/11114177">源码</a></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/4416678a005b035d901d15301e63d35d/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">在 React Hooks 中如何请求数据？</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f4b8dc701ee225b610f82f4a9730ea42/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">消息ID的范围</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>