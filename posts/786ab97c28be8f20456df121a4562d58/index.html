<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>小学生都听得懂的数据库范式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="小学生都听得懂的数据库范式" />
<meta property="og:description" content="什么是范式？ 数据库就像是一个巨大的文件柜，用来存储很多信息。这些信息被组织成很多小表格。而在数据库的世界里，我们有一些规则来确保这些表格整齐、有序，不会乱七八糟。这些规则就叫做范式。
范式就像我们要求字写得工整、清晰、有条理一样，是一种让数据库变得更加规范和整洁的方法。范式有很多级别，每个级别都有自己的标准和要求。
第一范式要求每个属性都是原子性的，不能再分解成更小的部分。就像我们写字一样，每个字只能由一个个笔画组成，不能再分解成更小的部分。第二范式要求每个非主键属性都完全依赖于主键。就像我们写信需要写上地址，才能保证信能准确到达收件人。第三范式要求每个非主键属性都不依赖于其他非主键属性，就像我们写信的时候，信封上只需要写上一个地址就可以了，不需要写上其他无关的信息。第四范式要要求每个非主键属性都与主键直接相关，而不是间接相关。就像我们在学习时，需要直接学习相关的知识点，而不是先学习一些无关的知识点再间接地学习相关的知识点。 详细解释什么是第一范式（1NF） 比如，我们有一张学生表，其中一个字段是地址。如果我们把地址拆分成省份、城市、街道、门牌号等多个字段存储，那么这就不符合第一范式的要求了，因为地址被分解成了多个部分，不再是原子性的了。正确的做法是把地址作为一个属性，存储为一个完整的字符串。
详细解释什么是第二范式（2NF） 什么是函数依赖？ 函数依赖是指在一个关系中，一个或多个属性的值可以唯一地决定另一个属性的值。就像我们在算数中，如果我们知道了某些数字的值，就可以唯一地确定另一个数字的值。
举个例子，假设我们有一个学生表，其中包括学生姓名、年龄、班级、学号等字段。我们可以发现，一个学生的学号是唯一的，并且可以唯一地确定该学生的姓名、年龄、班级等信息。而反过来，如果我们只知道一个学生的姓名、年龄、班级等信息，就无法唯一地确定该学生的学号。因此，学号函数依赖于姓名、年龄、班级等属性。
什么是完全函数依赖？ 完全函数依赖是指在一个关系中，一个或多个属性的值可以唯一地决定另一个属性的值，且这个属性不依赖于任何一个属性的真子集。我们可以通过一个简单的例子来解释：
假设我们有一个班级表，其中包括学号、姓名、性别、年龄、班级、电话等字段。我们可以发现，一个学生的电话号码可以唯一地确定该学生的信息，包括姓名、性别、年龄、班级等。而反过来，如果我们只知道一个学生的姓名、性别、年龄、班级等信息，就无法唯一地确定该学生的电话号码。但是，如果我们知道了该学生的学号，就可以唯一地确定该学生的电话号码。这就是一个完全函数依赖关系，因为电话号码只依赖于学号这个属性，而不依赖于任何一个属性的真子集。
什么是部分函数依赖？ 部分函数依赖是指在一个关系中，一个或多个属性的值可以唯一地决定另一个属性的值，但是这个属性还依赖于其他属性。我们可以通过一个简单的例子来解释：
假设我们有一个订单表，其中包括订单号、客户名称、客户地址、产品名称、数量、单价等字段。我们可以发现，一个订单的客户地址可以唯一地确定该订单的客户名称，但是客户名称还依赖于客户地址和其他属性，比如邮编等。这就是一个部分函数依赖关系，因为客户名称既依赖于客户地址这个属性，又依赖于其他属性。
什么是第二范式？ 比如，我们有一张学生成绩表，其中包括学生姓名、课程名称、成绩等字段。如果我们把学生姓名和课程名称合并成一个复合主键，那么成绩就不完全依赖于主键了，因为成绩既依赖于学生姓名，又依赖于课程名称。正确的做法是把学生姓名和课程名称分别作为主键和外键，成绩作为非主键属性。
详细解释什么是第三范式（3NF） 比如，我们有一张订单表，其中包括订单号、客户名称、产品名称、数量、单价等字段。如果我们在表中存储了订单总价这个计算属性，那么它就不符合第三范式的要求了，因为订单总价依赖于数量和单价两个非主键属性。正确的做法是将订单总价作为一个视图或者计算字段来展示，不存储在表中。
详细解释什么是第四范式（4NF） 比如，我们有一张部门表和员工表，其中部门表的主键是部门编号，员工表的主键是员工编号，部门表和员工表之间通过部门编号建立了关联。如果我们在员工表中存储部门名称这个属性，那么它就不符合第四范式的要求了，因为部门名称与主键部门编号只是间接相关，并不直接相关。正确的做法是在查询时将部门名称通过关联查询获得，而不是存储在员工表中。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/786ab97c28be8f20456df121a4562d58/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-21T18:36:38+08:00" />
<meta property="article:modified_time" content="2023-03-21T18:36:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">小学生都听得懂的数据库范式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>什么是范式？</h2> 
<p>数据库就像是一个巨大的文件柜，用来存储很多信息。这些信息被组织成很多小表格。而在数据库的世界里，我们有一些规则来确保这些表格整齐、有序，不会乱七八糟。这些规则就叫做范式。</p> 
<p>范式就像我们要求字写得工整、清晰、有条理一样，是一种让数据库变得更加规范和整洁的方法。范式有很多级别，每个级别都有自己的标准和要求。</p> 
<ol><li>第一范式要求每个属性都是原子性的，不能再分解成更小的部分。就像我们写字一样，每个字只能由一个个笔画组成，不能再分解成更小的部分。</li><li>第二范式要求每个非主键属性都完全依赖于主键。就像我们写信需要写上地址，才能保证信能准确到达收件人。</li><li>第三范式要求每个非主键属性都不依赖于其他非主键属性，就像我们写信的时候，信封上只需要写上一个地址就可以了，不需要写上其他无关的信息。</li><li>第四范式要要求每个非主键属性都与主键直接相关，而不是间接相关。就像我们在学习时，需要直接学习相关的知识点，而不是先学习一些无关的知识点再间接地学习相关的知识点。</li></ol> 
<h2><a id="1NF_10"></a>详细解释什么是第一范式（1NF）</h2> 
<p>比如，我们有一张学生表，其中一个字段是地址。如果我们把地址拆分成省份、城市、街道、门牌号等多个字段存储，那么这就不符合第一范式的要求了，因为地址被分解成了多个部分，不再是原子性的了。正确的做法是把地址作为一个属性，存储为一个完整的字符串。</p> 
<h2><a id="2NF_13"></a>详细解释什么是第二范式（2NF）</h2> 
<h3><a id="_14"></a>什么是函数依赖？</h3> 
<p>函数依赖是指在一个关系中，一个或多个属性的值可以唯一地决定另一个属性的值。就像我们在算数中，如果我们知道了某些数字的值，就可以唯一地确定另一个数字的值。</p> 
<p>举个例子，假设我们有一个学生表，其中包括学生姓名、年龄、班级、学号等字段。我们可以发现，一个学生的学号是唯一的，并且可以唯一地确定该学生的姓名、年龄、班级等信息。而反过来，如果我们只知道一个学生的姓名、年龄、班级等信息，就无法唯一地确定该学生的学号。因此，学号函数依赖于姓名、年龄、班级等属性。</p> 
<h4><a id="_18"></a>什么是完全函数依赖？</h4> 
<p>完全函数依赖是指在一个关系中，一个或多个属性的值可以唯一地决定另一个属性的值，且这个属性不依赖于任何一个属性的真子集。我们可以通过一个简单的例子来解释：</p> 
<p>假设我们有一个班级表，其中包括学号、姓名、性别、年龄、班级、电话等字段。我们可以发现，一个学生的电话号码可以唯一地确定该学生的信息，包括姓名、性别、年龄、班级等。而反过来，如果我们只知道一个学生的姓名、性别、年龄、班级等信息，就无法唯一地确定该学生的电话号码。但是，如果我们知道了该学生的学号，就可以唯一地确定该学生的电话号码。这就是一个完全函数依赖关系，因为电话号码只依赖于学号这个属性，而不依赖于任何一个属性的真子集。</p> 
<h4><a id="_22"></a>什么是部分函数依赖？</h4> 
<p>部分函数依赖是指在一个关系中，一个或多个属性的值可以唯一地决定另一个属性的值，但是这个属性还依赖于其他属性。我们可以通过一个简单的例子来解释：</p> 
<p>假设我们有一个订单表，其中包括订单号、客户名称、客户地址、产品名称、数量、单价等字段。我们可以发现，一个订单的客户地址可以唯一地确定该订单的客户名称，但是客户名称还依赖于客户地址和其他属性，比如邮编等。这就是一个部分函数依赖关系，因为客户名称既依赖于客户地址这个属性，又依赖于其他属性。</p> 
<h3><a id="_26"></a>什么是第二范式？</h3> 
<p>比如，我们有一张学生成绩表，其中包括学生姓名、课程名称、成绩等字段。如果我们把学生姓名和课程名称合并成一个复合主键，那么成绩就不完全依赖于主键了，因为成绩既依赖于学生姓名，又依赖于课程名称。正确的做法是把学生姓名和课程名称分别作为主键和外键，成绩作为非主键属性。</p> 
<h2><a id="3NF_29"></a>详细解释什么是第三范式（3NF）</h2> 
<p>比如，我们有一张订单表，其中包括订单号、客户名称、产品名称、数量、单价等字段。如果我们在表中存储了订单总价这个计算属性，那么它就不符合第三范式的要求了，因为订单总价依赖于数量和单价两个非主键属性。正确的做法是将订单总价作为一个视图或者计算字段来展示，不存储在表中。</p> 
<h2><a id="4NF_32"></a>详细解释什么是第四范式（4NF）</h2> 
<p>比如，我们有一张部门表和员工表，其中部门表的主键是部门编号，员工表的主键是员工编号，部门表和员工表之间通过部门编号建立了关联。如果我们在员工表中存储部门名称这个属性，那么它就不符合第四范式的要求了，因为部门名称与主键部门编号只是间接相关，并不直接相关。正确的做法是在查询时将部门名称通过关联查询获得，而不是存储在员工表中。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b26ab0ee4347f915d569ee862d2834dc/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">手动创建数据集（csv文件），用于Pytorch深度学习</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/67ceaa459468cdac69f7aae8cfa3bde5/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">keil5中文乱码</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>