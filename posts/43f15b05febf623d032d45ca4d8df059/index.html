<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Dijkstra最短路径算法详细过程附C&#43;&#43;详细代码 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Dijkstra最短路径算法详细过程附C&#43;&#43;详细代码" />
<meta property="og:description" content="一.算法思想 将所有节点分为两组，一组节点是，从起点到该点的最短路径已经被确认，而另外一组是未被确定最短路径的节点。一开始，只有起点的最短路径被确认，并且为0，然后它遍历其他节点，并不断更新从起点到当前节点的最短路径。直到该点被访问后，则该点的最短路径被确定。
二.如下图所示，用Dijkstra算法找出节点O到T的最短路径
（1）首先初始化起点最短路径L(O)=0，剩下的点L(A)=L(B)=L(C)=L(D)=L(E)=L(F)=L(T)=∞；S是所有被遍历过的节点集合。U是当前被遍历的节点，W(Vi，Ui)表示两个节点的权值。
通过判断当前节点的最短路径加上到下一个节点的权值来确定下一个节点的最短路径，并不断迭代。
第一次迭代，U=O，和S={O}； L(O)&#43;W(O,A)=2&lt;L(A);
L(O)&#43;W(O,B)=5&lt;L(B);
L(O)&#43;W(O,C)=4&lt;L(C);
更新上面3个点的最短路径：L（A）=2，L（B）=5,L(C)=4；
第二次迭代 U=A,S={O,A}
L(A)&#43;W(A,B)=4&lt;L(B);
L(A)&#43;W(A,F)=14&lt;L(F);
L(A)&#43;W(A,D)=9&lt;L(D);
更新上面三个点的最短路径L（B）=4，L（F）=14,L(D)=9
第三次迭代U=B、S={O、A、B}
L(B)&#43;W(B,D)=8&lt;L(D);
L(B)&#43;W(B,E)=7&lt;L(E);
更新上述两点的最短路径 L(D)=8,L(E)=7;
第四次迭代U=C、S={O，A、B、C}
L(C)&#43;W(C,E)=8&gt;L(E);
没有更新点。
第五次迭代U=D、S={O、A、B、C、D}
L(D)&#43;W(D,T)=13&lt;L(T);
将最短路径更新到上面节点 L(T)=13；
第六次迭代U=E、S={O、A、B、C、D、E}
L(E)&#43;W(E,T)=14&gt;L(T);
无更新点
第七次迭代U=F、S={O、A、B、C、D、E、F}
L(F)&#43;W(F,T)=17&gt;L(T)
没有更新点。
第八次迭代，U=T、S={O、A、B、C、D、E、T}
从最短的O到T的没有更新点路径为13。
三，算法代码（C&#43;&#43;实现）
#include&lt;iostream&gt; #include&lt;string&gt; using namespace std; class Node{ public: Node() { minL=100;//初始化最短路径为无穷大。 } char node;//节点名称 int minL;//当前节点的最短路径 Node* last;//下一个节点 };//定义从一个节点类 void print(Node *node)//最短路径函数的递归打印 { if (node == NULL) { return; } print(node-&gt;last);/*递归调用,先打印前面的节点*/ cout &lt;&lt; node-&gt;node &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/43f15b05febf623d032d45ca4d8df059/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-01-28T10:11:09+08:00" />
<meta property="article:modified_time" content="2022-01-28T10:11:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Dijkstra最短路径算法详细过程附C&#43;&#43;详细代码</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>一.算法思想 </p> 
<p style="margin-left:.0001pt;text-align:justify;">将所有节点分为两组，一组节点是，从起点到该点的最短路径已经被确认，而另外一组是未被确定最短路径的节点。一开始，只有起点的最短路径被确认，并且为0，然后它遍历其他节点，并不断更新从起点到当前节点的最短路径。直到该点被访问后，则该点的最短路径被确定。</p> 
<p style="margin-left:.0001pt;text-align:justify;">二.如下图所示，用Dijkstra算法找出节点O到T的最短路径</p> 
<p style="margin-left:.0001pt;text-align:justify;"></p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" height="227" src="https://images2.imgbox.com/6b/b3/hIP4wgqg_o.png" width="472"></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;">（1）首先初始化起点最短路径L(O)=0，剩下的点L(A)=L(B)=L(C)=L(D)=L(E)=L(F)=L(T)=∞；S是所有被遍历过的节点集合。U是当前被遍历的节点，W(Vi，Ui)表示两个节点的权值。</p> 
<p style="margin-left:.0001pt;text-align:justify;">通过判断当前节点的最短路径加上到下一个节点的权值来确定下一个节点的最短路径，并不断迭代。</p> 
<p style="margin-left:.0001pt;text-align:justify;">第一次迭代，U=O，和S={O}； L(O)+W(O,A)=2&lt;L(A);</p> 
<p style="margin-left:.0001pt;text-align:justify;">                                                  L(O)+W(O,B)=5&lt;L(B);</p> 
<p style="margin-left:.0001pt;text-align:justify;">                                                  L(O)+W(O,C)=4&lt;L(C);</p> 
<p style="margin-left:.0001pt;text-align:justify;">更新上面3个点的最短路径：L（A）=2，L（B）=5,L(C)=4；</p> 
<p style="margin-left:.0001pt;text-align:justify;">第二次迭代 U=A,S={O,A}</p> 
<p style="margin-left:.0001pt;text-align:justify;">                                                    L(A)+W(A,B)=4&lt;L(B);</p> 
<p style="margin-left:.0001pt;text-align:justify;">                                                    L(A)+W(A,F)=14&lt;L(F);</p> 
<p style="margin-left:.0001pt;text-align:justify;">                                                    L(A)+W(A,D)=9&lt;L(D);</p> 
<p style="margin-left:.0001pt;text-align:justify;">更新上面三个点的最短路径L（B）=4，L（F）=14,L(D)=9</p> 
<p></p> 
<p></p> 
<p style="margin-left:.0001pt;text-align:justify;">第三次迭代U=B、S={O、A、B}</p> 
<p style="margin-left:.0001pt;text-align:justify;">                                                    L(B)+W(B,D)=8&lt;L(D);</p> 
<p style="margin-left:.0001pt;text-align:justify;">                                                    L(B)+W(B,E)=7&lt;L(E);</p> 
<p style="margin-left:.0001pt;text-align:justify;"> 更新上述两点的最短路径           L(D)=8,L(E)=7;</p> 
<p style="margin-left:.0001pt;text-align:justify;">第四次迭代U=C、S={O，A、B、C}</p> 
<p style="margin-left:.0001pt;text-align:justify;">                                                    L(C)+W(C,E)=8&gt;L(E);</p> 
<p style="margin-left:.0001pt;text-align:justify;">                                                      没有更新点。</p> 
<p style="margin-left:.0001pt;text-align:justify;"> 第五次迭代U=D、S={O、A、B、C、D}<br>                                                     L(D)+W(D,T)=13&lt;L(T);<br> 将最短路径更新到上面节点             L(T)=13；</p> 
<p style="margin-left:.0001pt;text-align:justify;">第六次迭代U=E、S={O、A、B、C、D、E}</p> 
<p style="margin-left:.0001pt;text-align:justify;">                                                   L(E)+W(E,T)=14&gt;L(T);</p> 
<p style="margin-left:.0001pt;text-align:justify;">                                                        无更新点</p> 
<p style="margin-left:.0001pt;text-align:justify;">第七次迭代U=F、S={O、A、B、C、D、E、F}</p> 
<p style="margin-left:.0001pt;text-align:justify;">                                                  L(F)+W(F,T)=17&gt;L(T)</p> 
<p style="margin-left:.0001pt;text-align:justify;">                                                           没有更新点。</p> 
<p style="margin-left:.0001pt;text-align:justify;">第八次迭代，U=T、S={O、A、B、C、D、E、T}</p> 
<p style="margin-left:.0001pt;text-align:justify;">                             从最短的O到T的没有更新点路径为13。</p> 
<p style="margin-left:.0001pt;text-align:justify;">三，算法代码（C++实现）</p> 
<pre><code class="language-cpp">#include&lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
class Node{
public:
	Node()
	{
		minL=100;//初始化最短路径为无穷大。
	}
	char node;//节点名称
	int minL;//当前节点的最短路径
	Node* last;//下一个节点
};//定义从一个节点类

void print(Node *node)//最短路径函数的递归打印
{
	if (node == NULL)
	{
		return;
	}
	print(node-&gt;last);/*递归调用,先打印前面的节点*/
    cout &lt;&lt; node-&gt;node &lt;&lt; "-&gt;";
}

int main()
{

	int wvalue[8][8];//定义路径权重	
for (int a = 0; a &lt; 8; a++)
	{
		for (int b = 0; b &lt; 8; b++)
		{
			wvalue[a][b] = 1000;//初始化权值，如若两个点没有连接则为无穷大。
		}
	}
    wvalue[0][1] = 2;//根据图来设置各个点之间的路径。
	wvalue[0][2] = 5;
	wvalue[0][3] = 4;
	wvalue[1][6] = 12;
	wvalue[1][2] = 2;
	wvalue[1][4] = 7;
	wvalue[2][3] = 1;
	wvalue[2][4] = 4;
	wvalue[2][5] = 3;
	wvalue[3][5] = 4;
	wvalue[4][5] = 1;
	wvalue[4][7] = 5;
	wvalue[5][7] = 7;
	wvalue[6][7] = 3;
	Node node[8];//定义节点变量
	node[0].node = 'O';//命名各个节点
	node[0].last = NULL;//初始化前一个节点为空
	node[1].node = 'A';
	node[2].node = 'B';
	node[3].node = 'C';
	node[4].node = 'D';
	node[5].node = 'E';
	node[6].node = 'F';
	node[7].node = 'T';
	Node u;//定义当前被访问的节点
	Node S[8];//辅助变量存储8个节点
    int a = 0;
	for (int i = 0; i &lt; 8;i++) //第一个循环遍历这8个节点
{
		u = node[i];//当前被遍历的节点
		if (i==0)
		{
		 u.minL = 0;//初始化第一个结点的最短路径	
	    }
		S[i] = node[i];//储存被遍历的节点
		for (int j = 0;j&lt;8; j++)//遍一个节点与其他8个节点的两个路径权值	
        {
			if (u.minL + wvalue[i][j] &lt; node[j].minL)/*如果当前节点的最短路径加上该节点到相邻节点的权重小于其下一个节点路径的权重，则更新其下一个节点路径的最小距离*/	
        	{
				node[j].minL = u.minL + wvalue[i][j];
				node[j].last = &amp;S[i];

			}
		}
}
	cout &lt;&lt; node[7].minL &lt;&lt; endl;//打印最短路径
	print(&amp;node[7]);
	return 0;
}</code></pre> 
<p style="margin-left:.0001pt;text-align:justify;">最后结果</p> 
<p style="margin-left:.0001pt;text-align:center;"><img alt="" src="https://images2.imgbox.com/ae/a5/LLq1nHO2_o.png"></p> 
<p></p> 
<table><tbody><tr><td></td></tr><tr><td></td><td></td></tr></tbody></table>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0e18bcc9c8db59ff3316288660f174d8/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">漏洞修复：TLS 1.0 enabled</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/94b283acc74ad1bcec3207c9a732cac2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Ubuntu搭建FTP服务器</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>