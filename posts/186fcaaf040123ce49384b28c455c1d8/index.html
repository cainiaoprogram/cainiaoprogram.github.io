<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>硬件预取之空间预取 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="硬件预取之空间预取" />
<meta property="og:description" content="《data prefetching techniques in computer system》翻译之空间预取器
2 Spatial prefetching 数据预取器需要在应用程序运行时预测处理器未来的内存访问。为此，它们通常依赖于数据访问之间的循环模式或相关性。在处理器上运行时，应用程序的数据访问中出现的模式或特定相关性越多，数据预取器就越能更好地预测未来的内存引用。
空间数据预取器通过依赖空间地址相关性来预测未来的内存访问。空间地址相关性是指多个内存区域间数据访问模式的相似性。访问模式演示了空间相关性，因为应用程序使用具有规则的并且固定布局，并且遍历数据结构时会重新进行访问[1]。
例如，应用程序可以使用结构体数组，而该结构体有多个元素。访问不同数据结构的模式很可能是相似的(有时是相同的)。图1显示了几个内存区域的访问模式。在这个图中可以看到访问模式的相似性。这种访问模式与内存区域(在本例中，与结构体相关的内存区域)的相似性被称为空间相关性。
有几种空间数据预取器[1-10]。这些预取器将内存地址空间划分为固定大小的部分，称为空间区域，并学习这些部分的内存访问模式。当应用程序触及相同或类似的空间区域时，学习访问模式用于预取未来的内存引用。在本章中，我们将讨论空间预取器学习空间区域访问模式的机制，以及它们如何将所学应用于未来类似空间区域的预取。
空间数据预取器的优点之一是它们施加的面积开销很小，因为它们存储偏移量(offset即，块地址从空间区域开始的距离)或增量(delta即，落入空间区域的两个连续访问的距离)作为它们的元数据信息，而不是完整的地址。空间数据预取器的另一个同样显著的优点是它们能够消除强制缓存丢失[11]。
强制缺失是指地址第一次被缓存看到的缓存缺失。这些失误也被称为冷启动失误或首次引用失误。当缓存第一次看到这些地址时，这样的数据访问通常会在缓存中丢失。因此，在重要的应用程序类别中，强制缓存缺失是导致性能下降的主要原因，例如，scan-dominated的工作负载，其中scan大量数据产生大量不可见的内存访问，无法被缓存捕获[1]。通过将在过去的空间区域中观察到的模式利用到新的未观察到的空间区域，空间预取器可以减轻强制缓存丢失，从而显着提高系统性能。
空间数据预取的关键限制是它无法预测指针跟踪导致的缓存丢失[12-16]。例如，对于链表，每个元素都是动态地分配到内存中的某个位置，并且元素之间不一定是相邻的。相反，它们使用指针连接在一起。通常，由于动态对象可能被分配到内存中的任何地方，因此不一定彼此相邻，因此指针跟踪访问通常不会显示空间相关性。相反，它们会产生大量依赖的缓存缺失，由于缺乏空间地址相关性，空间预取器几乎做不了这些缓存缺失。
我们介绍了两种最先进的空间预取技术:(1)spatial memory streaming (SMS 2006’ISCA)[2]，(2)VLDP[4]。
2.1 spatial memory streaming(SMS 2006’ISCA) SMS是一种最先进的空间预取器，它是在服务器和科学应用的背景下提出和评估的。每当第一次请求某个空间区域时，只要应用程序正在积极使用该空间区域，SMS就开始观察并记录对该空间区域的访问。每当空间区域不再被使用时(即空间区域的相应块开始从缓存中被清除)，SMS将观察到的访问信息存储在其元数据表中，称为模式历史表(PHT)。
PHT中的信息以_&lt;event, pattern&gt;_的形式存储。event(pc&#43;addr/pc&#43;offset/addr/offsetd等)是一条与观察到的访问模式相关联的信息。也就是说，如果将来事件再次发生时使用相应的存储访问模式。SMS根据经验选择PC &#43;触发访问的偏移量 (即，第一次访问空间区域的指令的PC加上第一个请求的缓存块与空间区域开始的距离)作为访问模式相关的事件。这样，每当PC &#43; Offset重新出现时，相关的访问模式历史记录将用于发出预取请求。模式是发生在每个空间区域的访问历史。SMS将访问模式编码为位向量。通过这种方式，对于空间区域中的每个缓存块，存储一个位，表示该块是否有在最近一次使用空间区域使用有则标记为(’ 1 ‘)若无则标记为 (’ 0 &#39;)。
因此，无论何时使用一个模式，预取请求只针对存储模式中对应位为“1”的块发出。图2为SMS的硬件实现。
2.1.1 example 让我们假设SMS跟踪大小为256字节的空间区域，缓存直接映射为512字节，而块大小为**64字节。**在本例中，缓存包含8个块，每个区域长4个块。
序号Region1序号Region204167/5805134626320071490 在本例中，我们考虑以下内存访问顺序:67、200、580、1346、1490、1310开始时，缓存和预取器状态都是空的。地址67不在缓存中，映射到它的第二个块(上表的序号1)。此外，这是第一次进入一个新的空间区域。因此，它触发了SMS。SMS记录访问的PC(比如PC=0x001F54)和偏移量64，因为这个地址是空间区域的第二个块。第二个内存访问是地址200。这个地址也不在缓存中，并映射到它的第四个块(上表的序号3)。此外，地址200与地址67来自相同的空间区域，因此，偏移量192将被记录。
下一个内存访问是地址580。这个地址也不在缓存中，并映射到它的第二个块。因此，地址67将被替换为缓存中的这个地址。当一个活动空间区域的一个块在缓存中被替换时，表明该空间区域不再是活动的。因此，将记录{PC &#43; Offset, Bit Pattern}(在本例中为{0x001F54&#43;64，{0,1,0,1}})。地址580也开始一个新的空间区域。为简洁起见，我们不提及该空间区域的SMS记录。
下一个内存访问地址是1346。此地址不在缓存中，并映射到缓存的第六个块。这种访问也是一个新的空间区域的开始。为简洁起见，我们不提SMS是如何跟踪这个空间区域中的访问的。SMS还检查此访问是否匹配任何记录的**PC &#43;偏移量。假设此内存访问来自与先前内存访问相同的加载指令。因此，pc是相同的。由于空间区域中的偏移量为64，因此偏移量也匹配。因此，SMS在新的空间区域中预取模式{0,1,0,1}(即只有块地址1472作为块地址1346的后续访问)。
下一个地址是1490。和前面一样，块地址1472是预取的，地址1490已经在缓存中，因此是命中。最后一个地址是1310，它来自与前一次内存访问相同的空间区域。
但是，这个地址不在缓存中，因为SMS先前用于预取的模式没有这个块，因此SMS没有预取这个缓存块，因此要将其加到PC&#43;offset的访问模式中即为{1、1、1、0}。
2.2 VLDP(2015’Micro) VLDP是一种最新的最先进的空间数据预取器，它依赖于内存空间区域之间delta模式的相似性。VLDP记录落入空间区域的连续访问之间的距离，并使用它们来预测未来的缺失。VLDP的关键创新是部署多个预测表来预测增量模式。 VLDP使用几个历史表，其中每个表根据输入历史的特定长度保存元数据。
VLDP的元数据组织如图3所示。三个主要组件是Delta历史缓冲区(DHB)、Delta预测表(DPT)和偏移预测表(OPT)。DHB是一个记录当前活动空间区域的增量历史的小表。DHB中的每个条目都与一个活动的空间区域相关联，并包含像最后引用块这样的详细信息。
这些详细信息用于索引OPT和DPT，以便发出预取请求。DPT是一组键值对，它将增量序列与下一个预期增量关联起来。VLDP受益于多个DPT，其中每个DPT以不同的输入长度记录历史。DPT-i将利用i个历史delta来预取下一个期望的序列。例如，如果一个空间区域的最后三个增量是d3, d2和d1 (d1是最近的增量)，DPT-2存储&lt;d3,d2&gt; --d1,DPT1记录–d3。在查找dpt时，如果提供其中几个delta用于预测，则使用具有最长delta序列的表的预测，因为基于更长的输入进行的预测预计会更准确[1]。
通过这种方式，VLDP消除了由于短输入而产生的错误预测，从而提高了预取器的准确性和缺失覆盖率。
OPT是VLDP的另一个元数据表，它使用对空间区域的第一次访问的偏移量(而不是增量)进行索引。仅仅依靠增量进行预取要求预取器在发出预取请求之前至少观察到对空间区域的前两次访问;然而，有许多稀疏的空间区域，其中一些(例如两个)块被应用程序使用。因此，当应用程序在大量稀疏空间区域上操作时，在开始预取之前等待两次访问可能会使预取器失去发出足够的预取请求的机会。使用OPT可以使VLDP在第一次访问空间区域后立即开始预取。OPT将空间区域的第一次访问的偏移量与下一个期望的增量相关联。在第一次访问空间区域之后，使用访问的偏移量查找OPT，并使用表的输出发出预取请求。对于对空间区域的其余访问(即第二次访问)，VLDP只使用dpt。
尽管VLDP依赖于具有单个下一个预取增量的预测表，但它仍然能够提供大于1的预取前瞻性，使用提出了多级预取机制。在多度模式下，在预测空间区域中的下一个delta后，VLDP将该预测作为dpt的输入，以进行更多的预测**(递归)**。
2.2.1 举例 与SMS的示例类似，让我们假设VLDP跟踪大小为256字节的空间区域，缓存直接映射为512字节大小，块大小为64字节。在本例中，缓存包含8个块，每个区域长4个块。
我们考虑与SMS相同的地址序列:67、200、580、1346、1490、1310开始时，缓存和预取器状态都是空的。地址67不在缓存中，映射到它的第二个块。此外，由于这是空间区域的第一个地址，因此在增量历史缓冲区(DHB)中没有与之相关的条目。因此，以下条目将被添加到DHB(请注意，偏移量和增量是以缓存块而不是字节为单位的)(表1)。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/186fcaaf040123ce49384b28c455c1d8/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-16T10:44:17+08:00" />
<meta property="article:modified_time" content="2023-09-16T10:44:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">硬件预取之空间预取</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>《data prefetching techniques in computer system》翻译之空间预取器</p> 
<h2><a id="2_Spatial_prefetching_2"></a>2 Spatial prefetching</h2> 
<p>数据预取器需要在应用程序运行时预测处理器未来的内存访问。为此，它们通常依赖于<strong>数据访问之间的循环模式或相关性</strong>。在处理器上运行时，应用程序的数据访问中出现的<strong>模式</strong>或<strong>特定相关性</strong>越多，数据预取器就越能更好地预测未来的内存引用。</p> 
<p>空间数据预取器通过依赖空间地址相关性来预测未来的内存访问。<strong>空间地址相关性是指多个内存区域间数据访问模式的相似性</strong>。访问模式演示了空间相关性，因为应用程序使用具有规则的并且固定布局，并且遍历数据结构时会重新进行访问[1]。</p> 
<p>例如，应用程序可以使用结构体数组，而该结构体有多个元素。访问不同数据结构的模式很可能是相似的(有时是相同的)。图1显示了几个内存区域的访问模式。在这个图中可以看到访问模式的相似性。这种访问模式与内存区域(在本例中，与结构体相关的内存区域)的相似性被称为空间相关性。<br> <img src="https://images2.imgbox.com/5f/b7/8PtD7lSe_o.png" alt=""><br> 有几种空间数据预取器[1-10]。这些预取器将<strong>内存地址空间划分为固定大小的部分，称为空间区域</strong>，并学习这些部分的内存访问模式。当应用程序触及相同或类似的空间区域时，学习访问模式用于预取未来的内存引用。在本章中，我们将讨论空间预取器学习空间区域访问模式的机制，以及它们如何将所学应用于未来类似空间区域的预取。</p> 
<p>空间数据预取器的优点之一是它们<strong>施加的面积开销很小</strong>，因为它们<strong>存储偏移量(offset即，块地址从空间区域开始的距离)<strong>或</strong>增量(delta即，落入空间区域的两个连续访问的距离)<strong>作为它们的元数据信息，而不是完整的地址。空间数据预取器的另一个同样显著的优点是它们能够</strong>消除强制缓存丢失</strong>[11]。</p> 
<p>强制缺失是指地址第一次被缓存看到的缓存缺失。这些失误也被称为冷启动失误或首次引用失误。当缓存第一次看到这些地址时，这样的数据访问通常会在缓存中丢失。因此，在重要的应用程序类别中，强制缓存缺失是导致性能下降的主要原因，例如，scan-dominated的工作负载，其中scan大量数据产生大量不可见的内存访问，无法被缓存捕获[1]。通过将在过去的空间区域中观察到的模式利用到新的未观察到的空间区域，空间预取器可以减轻强制缓存丢失，从而显着提高系统性能。</p> 
<p><strong><mark>空间数据预取的关键限制是它无法预测指针跟踪导致的缓存丢失</mark></strong>[12-16]。例如，对于链表，每个元素都是动态地分配到内存中的某个位置，并且元素之间不一定是相邻的。相反，它们使用指针连接在一起。通常，由于动态对象可能被分配到内存中的任何地方，因此不一定彼此相邻，因此指针跟踪访问通常不会显示空间相关性。相反，它们会产生大量依赖的缓存缺失，由于缺乏空间地址相关性，空间预取器几乎做不了这些缓存缺失。</p> 
<p>我们介绍了两种最先进的空间预取技术:(1)spatial memory streaming (SMS 2006’ISCA)[2]，(2)VLDP[4]。</p> 
<h3><a id="21_spatial_memory__streamingSMS_2006ISCA_18"></a>2.1 spatial memory streaming(SMS 2006’ISCA)</h3> 
<p>SMS是一种最先进的空间预取器，它是在服务器和科学应用的背景下提出和评估的。每当第一次请求某个空间区域时，<strong>只要应用程序正在积极使用该空间区域，SMS就开始观察并记录对该空间区域的访问</strong>。每当空间区域不再被使用时(即空间区域的相应块开始从缓存中被清除)，SMS将观察到的访问信息存储在其元数据表中，称为<strong>模式历史表(PHT)</strong>。</p> 
<p>PHT中的信息以_&lt;event, pattern&gt;_的形式存储。<strong>event</strong>(pc+addr/<strong>pc+offset</strong>/addr/offsetd等)是一条与观察到的访问模式相关联的信息。也就是说，如果将来事件再次发生时使用相应的存储访问模式。SMS根据经验选择PC +触发访问的偏移量 (即，第一次访问空间区域的指令的PC加上第一个请求的缓存块与空间区域开始的距离)作为访问模式相关的<strong>事件</strong>。这样，每当PC + Offset重新出现时，相关的访问模式历史记录将用于发出预取请求。模式是发生在每个空间区域的访问历史。SMS将访问<strong>模式编码为位向量</strong>。通过这种方式，对于空间区域中的每个缓存块，存储一个位，表示该块是否有在最近一次使用空间区域使用有则标记为(’ 1 ‘)若无则标记为 (’ 0 ')。</p> 
<p>因此，无论何时使用一个模式，预取请求只针对存储模式中对应位为“1”的块发出。图2为SMS的硬件实现。<br> <img src="https://images2.imgbox.com/4b/24/ekSAF3mL_o.png" alt=""></p> 
<h4><a id="211_example_25"></a>2.1.1 example</h4> 
<p>让我们假设SMS跟踪大小为256字节的空间区域，缓存<strong>直接映射为512字节</strong>，而块大小为**64字节。**在本例中，缓存包含8个块，每个区域长4个块。</p> 
<table><thead><tr><th>序号</th><th>Region1</th><th>序号</th><th>Region2</th></tr></thead><tbody><tr><td>0</td><td></td><td>4</td><td></td></tr><tr><td>1</td><td>67/580</td><td>5</td><td>1346</td></tr><tr><td>2</td><td></td><td>6</td><td></td></tr><tr><td>3</td><td>200</td><td>7</td><td>1490</td></tr></tbody></table> 
<p>在本例中，我们考虑以下内存访问顺序:67、200、580、1346、1490、1310开始时，缓存和预取器状态都是空的。地址67不在缓存中，映射到它的第二个块(上表的序号1)。<strong>此外，这是第一次进入一个新的空间区域。因此，它触发了SMS</strong>。SMS记录访问的PC(比如PC=0x001F54)和偏移量64，因为这个地址是空间区域的第二个块。第二个内存访问是地址200。这个地址也不在缓存中，并映射到它的第四个块(上表的序号3)。此外，地址200与地址67来自相同的空间区域，因此，偏移量192将被记录。</p> 
<p>下一个内存访问是地址580。这个地址也不在缓存中，并映射到它的第二个块。因此，地址67将被替换为缓存中的这个地址。当一个活动空间区域的一个块在缓存中被替换时，表明该空间区域不再是活动的。因此，将记录{PC + Offset, Bit Pattern}(在本例中为{0x001F54+64，{0,1,0,1}})。地址580也开始一个新的空间区域。为简洁起见，我们不提及该空间区域的SMS记录。</p> 
<p>下一个内存访问地址是1346。此地址不在缓存中，并映射到缓存的<strong>第六个块</strong>。这种访问也是一个新的空间区域的开始。为简洁起见，我们不提SMS是如何跟踪这个空间区域中的访问的。SMS还检查此访问是否匹配任何记录的**PC +偏移量。<strong>假设此内存访问来自与先前内存访问相同的加载指令。因此，pc是相同的。由于空间区域中的偏移量为64，因此偏移量也匹配。因此，SMS在新的空间区域中预取模式{0,1,0,1}(即只有块地址1472作为块地址1346的后续访问)。</strong></p> 
<p>下一个地址是1490。和前面一样，块地址1472是预取的，地址1490已经在缓存中，因此是命中。最后一个地址是1310，它来自与前一次内存访问相同的空间区域。</p> 
<p>但是，这个地址不在缓存中，因为SMS先前用于预取的模式没有这个块，因此SMS没有预取这个缓存块，因此要将其加到PC+offset的访问模式中即为{1、1、1、0}。</p> 
<h3><a id="22_VLDP2015Micro_44"></a>2.2 VLDP(2015’Micro)</h3> 
<p>VLDP是一种最新的最先进的空间数据预取器，它依赖于内存空间区域之间delta模式的相似性。VLDP记录落入空间区域的连续访问之间的距离，并使用它们来预测未来的缺失。VLDP的<strong>关键创新是部署多个预测表来预测增量模式</strong>。 VLDP使用几个历史表，其中每个表根据<strong>输入历史的特定长度</strong>保存元数据。<br> <img src="https://images2.imgbox.com/f4/78/zDDIijNi_o.png" alt=""><br> VLDP的元数据组织如图3所示。三个主要组件是Delta历史缓冲区(DHB)、Delta预测表(DPT)和偏移预测表(OPT)。DHB是一个记录当前活动空间区域的增量历史的小表。<strong>DHB中的每个条目都与一个活动的空间区域</strong>相关联，并包含像最后引用块这样的详细信息。</p> 
<p>这些详细信息用于索引OPT和DPT，以便发出预取请求。DPT是一组键值对，它将增量序列与下一个预期增量关联起来。VLDP受益于多个DPT，其中每个DPT以不同的输入长度记录历史。DPT-i将利用i个历史delta来预取下一个期望的序列。例如，如果一个空间区域的最后三个增量是d3, d2和d1 (d1是最近的增量)，DPT-2存储&lt;d3,d2&gt; --d1,DPT1记录–d3。在查找dpt时，如果提供其中几个delta用于预测，则使用具有最长delta序列的表的预测，因为基于更长的输入进行的预测预计会更准确[1]。</p> 
<p>通过这种方式，VLDP消除了由于短输入而产生的错误预测，从而提高了预取器的准确性和缺失覆盖率。</p> 
<p>OPT是VLDP的另一个元数据表，它使用对空间区域的<strong>第一次访问的偏移</strong>量(而不是增量)进行索引。仅仅依靠增量进行预取要求预取器在发出预取请求之前至少观察到对空间区域的前两次访问;然而，有许多稀疏的空间区域，其中一些(例如两个)块被应用程序使用。因此，当应用程序在大量稀疏空间区域上操作时，在开始预取之前等待两次访问可能会使预取器失去发出足够的预取请求的机会。<strong>使用OPT可以使VLDP在第一次访问空间区域后立即开始预取</strong>。OPT将空间区域的第一次访问的偏移量与下一个期望的增量相关联。<strong>在第一次访问空间区域之后，使用访问的偏移量查找OPT</strong>，并使用表的输出发出预取请求。对于对空间区域的其余访问(即第二次访问)，VLDP只使用dpt。</p> 
<p>尽管VLDP依赖于具有单个下一个预取增量的预测表，但它仍然能够提供大于1的预取前瞻性，使用提出了多级预取机制。在多度模式下，在预测空间区域中的下一个delta后，VLDP将该预测作为dpt的输入，以进行更多的预测**(递归)**。</p> 
<h4><a id="221__56"></a>2.2.1 举例</h4> 
<p>与SMS的示例类似，让我们假设VLDP跟踪大小为256字节的空间区域，缓存直接映射为512字节大小，块大小为64字节。在本例中，缓存包含8个块，每个区域长4个块。</p> 
<p>我们考虑与SMS相同的地址序列:67、200、580、1346、1490、1310开始时，缓存和预取器状态都是空的。地址67不在缓存中，映射到它的第二个块。此外，由于这是空间区域的第一个地址，因此在增量历史缓冲区(DHB)中没有与之相关的条目。因此，以下条目将被添加到DHB(<strong>请注意，偏移量和增量是以缓存块而不是字节为单位的</strong>)<strong>(表1)。</strong></p> 
<p>第二个内存访问是地址200。这个地址也不在缓存中，并映射到它的第四个块。此外，地址200和地址67来自同一个空间区域，因此DHB表项将被更新**(表2)<strong>。此外，由于这是对该空间区域的第二次访问，因此将在偏移量预测表(OPT)中添加一个条目</strong>(表3)**。<br> ![](https://img-blog.csdnimg.cn/img_convert/7a5323897181ef46bd90a126dd67e0c1.png = 500x)<img src="https://images2.imgbox.com/48/bc/iv2QiEa7_o.png" alt="" width="500"><br> ![](https://img-blog.csdnimg.cn/img_convert/4a06d3fcccadf75d990328b8051a24b7.png 500x)<br> 下一个内存访问是地址580。这个地址也不在缓存中，并映射到它的第二个块。因此，地址67将被替换为缓存中的这个地址。由于这个地址来自不同的空间区域，因此将在DHB中为它创建一个条目(表4)。</p> 
<p>此外，由于这是对空间区域的第一次访问，<strong>因此它有资格使用OPT进行预取</strong>。从空间区域开始的这次访问的偏移量是1，并且由于具有此偏移量的条目存在于OPT中，VLDP预取BlockAddress(580) + 2*BlockSize=576 + 128=704。</p> 
<p>下一个内存访问是地址1347。此地址不在缓存中，并映射到缓存的第六个块。这个通道也是一个新的空间区域的开始。DHB的含量见表5。此外，由于这是对空间区域的第一次访问，因此它有资格使用OPT进行预取。这次访问与空间区域开始的偏移量为1。使用OPT, VLDP预取BlockAddress(1347) +2*BlockSize=1344 + 128=1472。</p> 
<p>下一个地址是1490。和前面一样，块地址1472是预取的，地址1490已经在缓存中，因此是命中。1490命中后，DHB如表6所示。<br> 他的最后一个地址是1310，来自同一个空间区域。但是，这个地址不在缓存中，因为VLDP没有预取它。表7显示了访问内存后DHB的内容。</p> 
<p>此外，由于在DHB的一行中有多个增量，我们可以向增量预测表(DPT)添加条目。在这种情况下，由于只有两个delta，我们可以在DPT-1上添加“2==&gt; -3”对于将来的内存访问，这个表项可以用于预取</p> 
<h3><a id="23__75"></a>2.3 总结</h3> 
<p>空间预取已经被提出并发展为捕捉内存页之间访问模式的相似性(例如，如果一个程序访问页X的位置{A,B,C,D}，它很可能也访问其他页的位置{A,B,C,D})。空间预取之所以有效，是因为应用程序使用<strong>具有规则和固定布局的数据对</strong>象，并且在遍历数据结构时重新进行访问。空间预取很有吸引力，因为它给系统带来了较低的存储开销，为将来系统采用空间预取铺平了道路。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1c93c6d33d0d56abadddf275ff0188a0/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">二值图细化算法 查表法&#43;ZS算法 (附有完整代码)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/872822980608b204770fd63f0de48e09/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Idea找不到Add Frameworks Support</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>