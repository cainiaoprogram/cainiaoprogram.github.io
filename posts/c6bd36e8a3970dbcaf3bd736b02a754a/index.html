<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Hadoop认证Kerberos--UserGroupInformation.doAs - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Hadoop认证Kerberos--UserGroupInformation.doAs" />
<meta property="og:description" content="在访问带有kerberos认证的hadoop生态圈服务时，必须带上keytab文件认证。
常用的代码：
String userCode=&#34;user1&#34;; String keytabPath = &#34;./user1.keytab&#34;; System.setProperty(&#34;java.security.krb5.kdc&#34;, kdc); System.setProperty(&#34;java.security.krb5.realm&#34;, realm); final Configuration conf = new Configuration(); UserGroupInformation ugi = UserGroupInformation.loginUserFromKeytabAndReturnUGI(userCode, keytabPath); final HConnection connection; ugi.doAs(new PrivilegedAction&lt;Object&gt;() { @Override public Object run() { try { connection = HConnectionManager.createConnection(conf); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } return null; } }); userCode是用户的名称，keytabPath是keytab文件的路径，一般系统是采用kdc生成的验证文件，来进行系统登录。系统不需要知道密码。 这里的ugi,就是kerberos的ticket, 是通过 UserGroupInformation.loginUserFromKeytabAndReturnUGI(userCode,keytabPath); 这个方法
成功后，返回的票据信息，通过这个票据，可以在没过期的情况下，用来访问hadoop系统。
重点是要说明，为什么要用这个票据的doAs方法来进行访问。首先我们看下UserGroupInformation的代码：
@InterfaceAudience.Public @InterfaceStability.Evolving public &lt;T&gt; T doAs(PrivilegedAction&lt;T&gt; action) { logPrivilegedAction(subject, action); return Subject." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c6bd36e8a3970dbcaf3bd736b02a754a/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-11-01T14:56:04+08:00" />
<meta property="article:modified_time" content="2018-11-01T14:56:04+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Hadoop认证Kerberos--UserGroupInformation.doAs</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>在访问带有kerberos认证的hadoop生态圈服务时，必须带上keytab文件认证。</p> 
<p>常用的代码：</p> 
<pre class="has"><code class="hljs language-java">String userCode="user1";
String keytabPath = "./user1.keytab";
System.setProperty("java.security.krb5.kdc", kdc); 
System.setProperty("java.security.krb5.realm", realm);
final Configuration conf = new Configuration();
UserGroupInformation ugi = UserGroupInformation.loginUserFromKeytabAndReturnUGI(userCode, keytabPath);
final HConnection connection;
ugi.doAs(new PrivilegedAction&lt;Object&gt;() {

	@Override
	public Object run() {
		try {
			connection = HConnectionManager.createConnection(conf);
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		return null;
	}
});</code></pre> 
<p>userCode是用户的名称，keytabPath是keytab文件的路径，一般系统是采用kdc生成的验证文件，来进行系统登录。系统不需要知道密码。   </p> 
<p>    这里的ugi,就是kerberos的ticket, 是通过 UserGroupInformation.loginUserFromKeytabAndReturnUGI(userCode,keytabPath); 这个方法<br> 成功后，返回的票据信息，通过这个票据，可以在没过期的情况下，用来访问hadoop系统。</p> 
<p>  重点是要说明，为什么要用这个票据的doAs方法来进行访问。首先我们看下UserGroupInformation的代码：</p> 
<pre class="has"><code class="hljs language-java">  @InterfaceAudience.Public
  @InterfaceStability.Evolving
  public &lt;T&gt; T doAs(PrivilegedAction&lt;T&gt; action) {
    logPrivilegedAction(subject, action);
    return Subject.doAs(subject, action);
  }</code></pre> 
<p><br> logPrivilegedAction是记录日志信息，先不用管，关键在Subject.doAs,事实上，这个是jdk的代码</p> 
<p>   </p> 
<pre class="has"><code class="hljs language-java">public static &lt;T&gt; T doAs(final Subject subject,
                        final java.security.PrivilegedAction&lt;T&gt; action) {
 
        java.lang.SecurityManager sm = System.getSecurityManager();
        if (sm != null) {
            sm.checkPermission(AuthPermissionHolder.DO_AS_PERMISSION);
        }
        if (action == null)
            throw new NullPointerException
                (ResourcesMgr.getString("invalid.null.action.provided"));
 
        // set up the new Subject-based AccessControlContext
        // for doPrivileged
        final AccessControlContext currentAcc = AccessController.getContext();
 
        // call doPrivileged and push this new context on the stack
        return java.security.AccessController.doPrivileged
                                        (action,
                                        createContext(subject, currentAcc));
    }</code></pre> 
<p>最后的代码是原生的看不到了，根据注释，可以看出，这里是新开了一个上下文，这个上下文是subject来初始化的，然后调用我们的连接方法。</p> 
<p><br> subject就是存放票据的地方，Userinformation初始化后，就不可变了 </p> 
<p>定义是 privatefinal Subjectsubject;</p> 
<p>为什么有的时候，不用doAs方法，调用认证的方法后，也可以正常访问kerberos的hadoop集群呢？  这里看下 loginUserFromKeytabAndReturnUGI的方法</p> 
<p> </p> 
<pre class="has"><code class="hljs language-java"> static UserGroupInformation loginUserFromKeytabAndReturnUGI(String user,
                                  String path
                                  ) throws IOException {
    if (!isSecurityEnabled())
      return UserGroupInformation.getCurrentUser();
    String oldKeytabFile = null;
    String oldKeytabPrincipal = null;
 
    long start = 0;
    try {
      oldKeytabFile = keytabFile;
      oldKeytabPrincipal = keytabPrincipal;
      keytabFile = path;
      keytabPrincipal = user;
      Subject subject = new Subject();
      
      LoginContext login = newLoginContext(
          HadoopConfiguration.KEYTAB_KERBEROS_CONFIG_NAME, subject,
          new HadoopConfiguration());
       
      start = Time.now();
      login.login();
      metrics.loginSuccess.add(Time.now() - start);
      UserGroupInformation newLoginUser = new UserGroupInformation(subject);
      newLoginUser.setLogin(login);
      newLoginUser.setAuthenticationMethod(AuthenticationMethod.KERBEROS);
      
      return newLoginUser;
    }</code></pre> 
<p><br>  </p> 
<pre class="has"><code class="hljs language-java">private static LoginContext   newLoginContext(String appName, Subject subject,     javax.security.auth.login.Configuration loginConf)       throws LoginException {     
    // Temporarily switch the thread's ContextClassLoader to match this     
// class's classloader, so that we can properly load HadoopLoginModule    
 // from the JAAS libraries.     
Thread t = Thread.currentThread();     
ClassLoader oldCCL = t.getContextClassLoader(); t.setContextClassLoader(HadoopLoginModule.class.getClassLoader());     
try {       
    return new LoginContext(appName, subject, null, loginConf);     
} finally {       
t.setContextClassLoader(oldCCL);     
}   
}</code></pre> 
<p><br>   </p> 
<p> LoginContext login 这个方法，是把当前线程的，切换到登录后subject上面去了，也就是当前线程的上下文，具备了登录信息，也就不需要用doAs的方法，也可以正常访问kerberos.<br>   不过这种方式有局限性：</p> 
<p>   1.切换用户，必须进行一次登录操作，频繁登录，给kdc服务器造成压力，kerberos的票据，是有保存期限的，在期限里面，我们不需要登录。</p> 
<p>   2.这种方式对jdk有依赖，根据实践,IBM的jdk，重复登录，无法切换到新的用户，必须用doAs的方式才正常。<br>  </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0d293f1003246bce203980b10ca9f7b1/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">适用于 iOS、Android 和 Windows 设备的移动设备管理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c45f7470cba64cd1fb85d2aac1a400cc/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Java中instanceof的用法和实战</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>