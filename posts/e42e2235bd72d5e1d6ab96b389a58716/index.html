<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Docker 简介与安装 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Docker 简介与安装" />
<meta property="og:description" content="Docker 简介与安装 1. 简介 1.1 基本概念 Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。
容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）。几乎没有性能开销,可以很容易地在机器和数据中心中运行。最重要的是，他们不依赖于任何语言、框架或包括系统。
1.2 实现方式 Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）、Cgroup 等技术。
在 LXC 的基础上，Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。
1.3 Docker 和传统虚拟化方式的不同 容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件的基础上，虚拟出自己的系统，再在系统上部署相关的 APP 应用。
传统虚拟化方案：
Docker虚拟化方案：
Docker 虚拟化有三个概念需要理解：镜像、容器、仓库。
镜像：docker 的镜像其实就是模板，跟我们常见的 ISO 镜像类似，是一个样板。
容器：使用镜像所创建的应用或者系统，我们称之为一个容器。
仓库：仓库是存放镜像的地方，分为公开仓库（Public）和私有仓库（Private）两种形式。
1.4 Docker 虚拟化特点 操作启动快
运行时的性能可以获取极大提升，管理操作（启动，停止，开始，重启等等）都是以秒或毫秒为单位的。
轻量级虚拟化
你会拥有足够的『操作系统』，仅需添加或减小镜像即可。在一台服务器上可以布署几百个 Containers 容器。但是传统虚拟化，你虚拟 20 个虚拟机就不错了。
开源免费
开源的，免费的，低成本的。由现代 Linux 内核支持并驱动。轻量的 Container 必定可以在一个物理机上开启更多“容器”，注定比 VMs 要便宜。
2. 在 CentOS 上安装 Docker 以下 CentOS 的版本是 8 。另外，以下命令默认以 root 进行操作。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/e42e2235bd72d5e1d6ab96b389a58716/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-08-05T14:09:18+08:00" />
<meta property="article:modified_time" content="2021-08-05T14:09:18+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Docker 简介与安装</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="Docker__0"></a>Docker 简介与安装</h2> 
<h3><a id="1__4"></a>1. 简介</h3> 
<h4><a id="11__6"></a>1.1 基本概念</h4> 
<p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化。</p> 
<p>容器是完全使用沙箱机制，相互之间不会有任何接口（<code>类似 iPhone 的 app</code>）。几乎没有性能开销,可以很容易地在机器和数据中心中运行。最重要的是，他们不依赖于任何语言、框架或包括系统。</p> 
<h4><a id="12__14"></a>1.2 实现方式</h4> 
<p>Docker 项目的目标是实现轻量级的操作系统虚拟化解决方案。 Docker 的基础是 Linux 容器（LXC）、Cgroup 等技术。</p> 
<p>在 LXC 的基础上，Docker 进行了进一步的封装，让用户不需要去关心容器的管理，使得操作更为简便。用户操作 Docker 的容器就像操作一个快速轻量级的虚拟机一样简单。</p> 
<h4><a id="13_Docker__22"></a>1.3 Docker 和传统虚拟化方式的不同</h4> 
<p>容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，而传统方式则是在硬件的基础上，虚拟出自己的系统，再在系统上部署相关的 APP 应用。</p> 
<ul><li> <p>传统虚拟化方案：</p> <p><img src="https://images2.imgbox.com/3b/94/wMrpqUoh_o.png" alt="在这里插入图片描述"></p> </li><li> <p>Docker虚拟化方案：</p> <p><img src="https://images2.imgbox.com/ec/47/5D7mt9vO_o.png" alt="在这里插入图片描述"></p> </li></ul> 
<p>Docker 虚拟化有三个概念需要理解：镜像、容器、仓库。</p> 
<ul><li> <p>镜像：docker 的镜像其实就是模板，跟我们常见的 ISO 镜像类似，是一个样板。</p> </li><li> <p>容器：使用镜像所创建的应用或者系统，我们称之为一个容器。</p> </li><li> <p>仓库：仓库是存放镜像的地方，分为公开仓库（Public）和私有仓库（Private）两种形式。</p> </li></ul> 
<h4><a id="14_Docker__46"></a>1.4 Docker 虚拟化特点</h4> 
<ul><li> <p>操作启动快</p> <p>运行时的性能可以获取极大提升，管理操作（启动，停止，开始，重启等等）都是以秒或毫秒为单位的。</p> </li><li> <p>轻量级虚拟化</p> <p>你会拥有足够的『操作系统』，仅需添加或减小镜像即可。在一台服务器上可以布署几百个 Containers 容器。但是传统虚拟化，你虚拟 20 个虚拟机就不错了。</p> </li><li> <p>开源免费</p> <p>开源的，免费的，低成本的。由现代 Linux 内核支持并驱动。轻量的 Container 必定可以在一个物理机上开启更多“容器”，注定比 VMs 要便宜。</p> </li></ul> 
<h3><a id="2__CentOS__Docker_62"></a>2. 在 CentOS 上安装 Docker</h3> 
<blockquote> 
 <p>以下 CentOS 的版本是 8 。另外，以下命令默认以 root 进行操作。<br> 另外，开发环境中，简单起见，记得关闭 Linux 防火墙</p> 
 <table><thead><tr><th>#</th><th>命令</th></tr></thead><tbody><tr><td>开启</td><td><code>systemctl start firewalld</code></td></tr><tr><td>关闭</td><td><code>systemctl stop firewalld</code></td></tr><tr><td>查看状态</td><td><code>systemctl status firewalld</code></td></tr><tr><td>开机禁用</td><td><code>systemctl disable firewalld</code></td></tr><tr><td>开机启用</td><td><code>systemctl enable firewalld</code></td></tr></tbody></table> 
</blockquote> 
<h4><a id="21__75"></a>2.1 前期准备工作</h4> 
<ul><li> <p>查看内核版本</p> <p>Docker 官方要求 Linux 内核版本至少 3.8 以上，建议 3.10 以上。通过以下命令可查看内核版本：</p> <pre><code class="prism language-sh">uname -rCopy to clipboardErrorCopied
</code></pre> <p>CentOS 7 的内核版本是满足其要求的。</p> </li><li> <p>卸载旧版本</p> <p>较旧的 Docker 版本称为 <em>docker</em> 或 <em>docker-engine</em> 。如果已安装这些程序，请卸载它们以及相关的依赖项。</p> <pre><code class="prism language-sh">yum remove docker \
           docker-client \
           docker-client-latest \
           docker-common \
           docker-latest \
           docker-latest-logrotate \
           docker-logrotate \
           docker-engineCopy to clipboardErrorCopied
</code></pre> </li><li> <p>前期准备 3：为配置 docker 软件源作准备</p> <pre><code class="prism language-sh">yum install -y \
    yum-utils \
    device-mapper-persistent-data \
    lvm2Copy to clipboardErrorCopied
</code></pre> </li><li> <p>前期准备 4：为 CentOS 添加 docker 软件源</p> <pre><code class="prism language-sh">yum-config-manager \
    --add-repo  \
    https://download.docker.com/linux/centos/docker-ce.repoCopy to clipboardErrorCopied
</code></pre> </li><li> <p>截至目前为止，我们干了什么？</p> <p>CentOS 的默认的 yum 软件源中实际上有 docker 的安装包，如果直接进行 <code>yum install docker</code> 也是可行的。</p> <p>但是 docker 官方考虑到不同的用户对 docker 的不同版本有不同的需求（有人追求最新，有人追求稳定），他们专门提供了一个仓库/网址用以提供多个版本的 docker 的下载。</p> <p>因此，我们必须告知 yum 有这样一个仓库的存在，并且未来要求 yum 从这个仓库中下载我们指定版本的 docker 。而非默认的仓库。</p> </li><li> <p>前期准备 5：查看所有仓库中所有 docker 版本</p> <pre><code class="prism language-sh">yum list docker-ce --showduplicates | sort -rCopy to clipboardErrorCopied
</code></pre> </li></ul> 
<h4><a id="22__docker__133"></a>2.2 安装 docker 并验证</h4> 
<h5><a id="221__135"></a>2.2.1 从网络仓库中下载，安装</h5> 
<pre><code class="prism language-shell">yum <span class="token function">install</span> -y docker-ce
或
yum <span class="token function">install</span> -y docker-ce-xxxCopy to clipboardErrorCopied
</code></pre> 
<p>上述命令中的 <code>xxx</code> 是指定的版本。例如：</p> 
<pre><code class="prism language-shell">yum <span class="token function">install</span> -y docker-ce-18.06.3.ce-3.el7Copy to clipboardErrorCopied
</code></pre> 
<p>安装过程中会出现类似如下询问：</p> 
<pre><code>从 https://download.docker.com/linux/centos/gpg 检索密钥
导入 GPG key 0x621E9F35:
 用户ID     : "Docker Release (CE rpm) &lt;docker@docker.com&gt;"
 指纹       : 060a 61c5 1b55 8a7f 742b 77aa c52f eb6b 621e 9f35
 来自       : https://download.docker.com/linux/centos/gpg
是否继续？[y/N]：Copy to clipboardErrorCopied
</code></pre> 
<p>输入 <code>y</code> 按回车继续安装。</p> 
<p>最终会出现：</p> 
<pre><code>完毕！Copy to clipboardErrorCopied
</code></pre> 
<h5><a id="222__Docker_168"></a>2.2.2 启动 Docker，并将其加入开机启动</h5> 
<pre><code class="prism language-shell"><span class="token comment"># systemctl start docker</span>

systemctl <span class="token builtin class-name">enable</span> docker --now

systemctl status dockerCopy to clipboardErrorCopied
</code></pre> 
<p>会出现类似如下结果：</p> 
<pre><code class="prism language-sh">Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.Copy to clipboardErrorCopied
</code></pre> 
<h5><a id="223__184"></a>2.2.3 验证安装是否成功</h5> 
<p>（有 client 和 service 两部分表示 docker 安装启动都成功了）</p> 
<p>输入 <code>docker version</code> 命令，会出现类似如下内容：</p> 
<pre><code class="prism language-sh">Client:
  Version:    17.12.1-ce
  API version:    1.35
  Go version:    go1.9.4
  Git commit:    7390fc6
  Built:    Tue Feb 27 22:15:20 2018
  OS/Arch:    linux/amd64

Server:
 Engine:
   Version:    17.12.1-ce
   API version:    1.35 (minimum version 1.12)
   Go version:    go1.9.4
   Git commit:    7390fc6
   Built:    Tue Feb 27 22:17:54 2018
   OS/Arch:    linux/amd64
   Experimental:    falseCopy to clipboardErrorCopied
</code></pre> 
<h5><a id="224__docker_hub__210"></a>2.2.4 验证连接 docker hub 中央镜像仓库</h5> 
<p>输入 <code>docker search -f is-official=true mysql</code> 命令，会出现类似如下结果：</p> 
<pre><code class="prism language-sh">NAME     DESCRIPTION                                     STARS  OFFICIAL ...
mysql    MySQL is a widely used, open-source relation…   8819   [OK]     ...
mariadb  MariaDB is a community-developed fork of MyS…   3102   [OK]     ...
percona  Percona Server is a fork of the MySQL relati…   459    [OK]     ...Copy to clipboardErrorCopied
</code></pre> 
<h4><a id="23__221"></a>2.3 配置国内镜像</h4> 
<p>由于 docker hub 的中央镜像仓库在国外，因此有时我们连接 docker hub 从中下载镜像速度会很感人，因此，我们需要配置国内的镜像网址，从国内现在镜像文件。</p> 
<pre><code>国内的镜像本质上就是 docker hub 中央仓库在国内的一份缓存/备份。Copy to clipboardErrorCopied
</code></pre> 
<p>通过 vi 命令编辑相关配置文件：</p> 
<pre><code class="prism language-sh">vi /etc/docker/daemon.json Copy to clipboardErrorCopied
</code></pre> 
<p>如果该文件存在，则将其内容清除；如果文件不存在，（打开该文件后，其内容是空白的），编辑结束后保存退出，即创建。</p> 
<p>输入如下内容：</p> 
<pre><code class="prism language-sh">{
  "registry-mirrors": [
    "https://registry.docker-cn.com",
    "https://docker.mirrors.ustc.edu.cn"
  ]
}Copy to clipboardErrorCopied
</code></pre> 
<p>该配置文件配置了两个镜像，一个是 docker 官方在中国境内的官方镜像，一个是中科大维护的一个镜像。</p> 
<p>重新启动 docker 服务：</p> 
<pre><code class="prism language-sh">systemctl restart dockerCopy to clipboardErrorCopied
</code></pre> 
<p>查看修改结果：</p> 
<pre><code class="prism language-sh">docker infoCopy to clipboardErrorCopied
</code></pre> 
<p>会有如下内容：</p> 
<pre><code>...
Registry Mirrors:
 https://registry.docker-cn.com/
 https://docker.mirrors.ustc.edu.cn/
...Copy to clipboardErrorCopied
</code></pre> 
<h4><a id="24__272"></a>2.4 导入已有的镜像文件</h4> 
<p>考虑到有些场景下的联网的不方便，docker 提供了将已下载的 images 打包导出，再在别处导入的功能。</p> 
<p>导出已有 image 使用命令：</p> 
<pre><code class="prism language-sh">docker save &lt;repository&gt;:&lt;tag&gt; -o &lt;repository&gt;.tarCopy to clipboardErrorCopied
</code></pre> 
<p>例如：</p> 
<pre><code class="prism language-sh">docker save mysql:5.7 -o mysql-5.7.tarCopy to clipboardErrorCopied
</code></pre> 
<p>导入 image 使用命令：</p> 
<pre><code class="prism language-sh">docker load -i &lt;repository&gt;.tarCopy to clipboardErrorCopied
</code></pre> 
<p>例如：</p> 
<pre><code class="prism language-sh">docker load -i mysql-5.7.tarCopy to clipboardErrorCopied
</code></pre> 
<h3><a id="3_Ubuntu__Docker_300"></a>3. Ubuntu 上安装 Docker</h3> 
<blockquote> 
 <p>以下 CentOS 的版本是 8 。另外，以下命令默认以 root 进行操作。<br> 另外，开发环境中，简单起见，记得关闭 Linux 防火墙</p> 
 <table><thead><tr><th>#</th><th>命令</th></tr></thead><tbody><tr><td>查看状态</td><td><code>sudo ufw status</code></td></tr><tr><td>开启并开机启动</td><td><code>sudo ufw enable</code></td></tr><tr><td>关闭</td><td><code>sudo ufw disable</code></td></tr></tbody></table> 
 <p>Ubuntu 的防火墙默认是关闭的。</p> 
</blockquote> 
<h4><a id="31__313"></a>3.1 前期准备工作</h4> 
<p>Ubuntu 的默认的 apt 软件源中实际上有 docker 的安装包，理论上来说，你直接利用默认软件源中的 docker 安装包进行安装也是可行的。</p> 
<p>但是 docker 官方考虑到不同的用户对 docker 的不同版本有不同的需求（有人追求最新，有人追求稳定），他们专门提供了一个仓库用以提供多个版本的 docker 的下载。</p> 
<p>另外，通常 apt 默认软件源中的软件的版本并不一定是最新版。</p> 
<p>因此，我们必须『告知』apt 有这样一个仓库的存在，并且未来要求 apt 从这个仓库中下载我们指定版本的 docker 。而非默认的仓库。</p> 
<ol><li> <p>查看内核版本</p> <p>Docker 官方要求 Linux 内核版本至少 <code>3.8</code> 以上，建议 <code>3.10</code> 以上。Ubuntu 18.04 的内核是符合其要求的。</p> <p>通过以下命令可查看内核版本：</p> <pre><code class="prism language-sh">uname -rCopy to clipboardErrorCopied
</code></pre> </li><li> <p>卸载旧版本</p> <p>较旧的 Docker 版本称为 <em>docker</em> 或 <em>docker-engine</em> 。如果已安装这些程序，请卸载它们以及相关的依赖项。</p> <pre><code class="prism language-sh">sudo apt remove \
        docker \
        docker-engine \
        docker-ce \
        docker.ioCopy to clipboardErrorCopied
</code></pre> </li><li> <p>为配置 docker 软件源作准备</p> <pre><code class="prism language-sh">sudo apt install \
        apt-transport-https \
        ca-certificates \
        curl \
        software-properties-commonCopy to clipboardErrorCopied
</code></pre> <p>这一步操作是为下一步操作作准备工作。</p> </li><li> <p>为 apt 将要添加的 docker 软件源添加校验</p> <pre><code class="prism language-sh">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -Copy to clipboardErrorCopied
</code></pre> <p>这一步操作是为下一步操作作准备工作。</p> </li><li> <p>为 apt 添加 docker 官方软件源</p> <pre><code class="prism language-sh">sudo add-apt-repository \
  "deb [arch=amd64] https://download.docker.com/linux/ubuntu \
  $(lsb_release -cs) \
  stable"Copy to clipboardErrorCopied
</code></pre> <p>这步操作的最直观的效果就是：你的 <strong>/etc/apt/sources.list</strong> 文件中会『多出来一行』（一个远程仓库的网址）</p> <p>记得执行以此 <strong>sudo apt update</strong>，去更新『软件清单』。</p> </li><li> <p>验证仓库是否添加成功：查看所有仓库中所有 docker 版本</p> <pre><code class="prism language-sh">apt-cache madison docker-ceCopy to clipboardErrorCopied
</code></pre> </li></ol> 
<h4><a id="32__docker__384"></a>3.2. 安装 docker 并验证</h4> 
<h5><a id="321__386"></a>3.2.1 从网络仓库中下载，安装</h5> 
<pre><code class="prism language-sh">sudo apt install \
  docker-ce \
  docker-ce-cli \
  containerd.ioCopy to clipboardErrorCopied
</code></pre> 
<p>在没有指定版本的情况下，apt 下载的是软件源中的最新版。如果想要指定特定版本，则使用如下语法：</p> 
<pre><code class="prism language-sh">sudo apt install \
  docker-ce=&lt;VERSION_STRING&gt; \
  docker-ce-cli=&lt;VERSION_STRING&gt; \
  containerd.ioCopy to clipboardErrorCopied
</code></pre> 
<p>带入特定版本号，例如：<code>5:19.03.13~3-0~ubuntu-bionic</code> 。</p> 
<h5><a id="322__Docker_406"></a>3.2.2 启动 Docker</h5> 
<p>类似于 MySQL，<strong>Docker 也是基于 CS 架构的</strong>。你的 Ubuntu 上存在一个 Docker 服务端和一个 Docker 客户端。</p> 
<p>要使用 Docker 的前提是：确保 Docker 的服务端启动了。</p> 
<pre><code class="prism language-sh"># 启动 docker 服务端
sudo systemctl start docker

# 将 docker 服务端设置为开机启动
sudo systemctl enable dockerCopy to clipboardErrorCopied
</code></pre> 
<h5><a id="323__420"></a>3.2.3 验证安装是否成功</h5> 
<p>Docker 是 CS 架构的，<strong>docker 的服务端是以 docker 用户</strong>（属于 docker 用户组）身份运行的，因此你去执行 docker 命令时，你的身份（和权限）是不符合的。</p> 
<p>当你通过 <strong>docker version</strong> 命令去验证安装是否成功时，会出现如下信息：</p> 
<pre><code class="prism language-sh">Got permission denied while trying to connect to the Docker daemon socket ...... connect: permission deniedCopy to clipboardErrorCopied
</code></pre> 
<p>有 client 和 server 两部分表示 docker 安装启动都成功了。</p> 
<p>解决办法有 2 个：</p> 
<ol><li> <p>你所执行的所有的 docker 命令前面都加上 <strong>sudo</strong> 。将你的身份临时提升为 root，root 自然是有权限执行 docker 命令的。</p> <pre><code class="prism language-bash"><span class="token function">sudo</span> docker versionCopy to clipboardErrorCopied
</code></pre> </li><li> <p>将你自己添加到 docker 用户组中。你和 docker 用户所属同一个用户组，你的自然就有权限执行 docker 命令。</p> <pre><code class="prism language-bash"><span class="token comment"># 创建名为 docker 的用户组。</span>
<span class="token comment"># 正常情况下，这条命令的结果会告诉你 docker 用户组已存在。</span>
<span class="token function">sudo</span> <span class="token function">groupadd</span> docker 

<span class="token comment"># 将当前用户（即你所登录系统的账号）添加至 docker 用户组</span>
<span class="token function">sudo</span> gpasswd -a <span class="token environment constant">$USER</span> docker 

<span class="token comment"># 更新 docker 用户组</span>
newgrp docker Copy to clipboardErrorCopied
</code></pre> </li></ol> 
<h5><a id="324__docker_hub__454"></a>3.2.4 验证连接 docker hub 中央镜像仓库</h5> 
<p>输入 <code>docker search -f is-official=true mysql</code> 命令，会出现类似如下结果：</p> 
<pre><code class="prism language-sh">NAME     DESCRIPTION                                     STARS  OFFICIAL ...
mysql    MySQL is a widely used, open-source relation…   8819   [OK]     ...
mariadb  MariaDB is a community-developed fork of MyS…   3102   [OK]     ...
percona  Percona Server is a fork of the MySQL relati…   459    [OK]     ...Copy to clipboardErrorCopied
</code></pre> 
<h4><a id="33__465"></a>3.3 配置国内镜像</h4> 
<p>由于 docker hub 的中央镜像仓库在国外，因此有时我们连接 docker hub 从中下载镜像速度会很感人，因此，我们需要配置国内的镜像网址，从国内现在镜像文件。</p> 
<pre><code>国内的镜像本质上就是 docker hub 中央仓库在国内的一份缓存/备份。Copy to clipboardErrorCopied
</code></pre> 
<p>通过 vi 命令编辑相关配置文件：</p> 
<pre><code class="prism language-sh">sudo vi /etc/docker/daemon.json Copy to clipboardErrorCopied
</code></pre> 
<p>如果该文件存在，则将其内容清除；如果文件不存在，（打开该文件后，其内容是空白的），编辑结束后保存退出，即创建。</p> 
<p>输入如下内容：</p> 
<pre><code class="prism language-sh">{
  "registry-mirrors": [
    "https://registry.docker-cn.com",
    "https://docker.mirrors.ustc.edu.cn"
  ]
}Copy to clipboardErrorCopied
</code></pre> 
<p>该配置文件配置了两个镜像，一个是 docker 官方在中国境内的官方镜像，一个是中科大维护的一个镜像。</p> 
<p>重新启动 docker 服务：</p> 
<pre><code class="prism language-sh">sudo systemctl restart dockerCopy to clipboardErrorCopied
</code></pre> 
<p>查看修改结果：</p> 
<pre><code class="prism language-sh">docker infoCopy to clipboardErrorCopied
</code></pre> 
<p>会有如下内容：</p> 
<pre><code>...
Registry Mirrors:
 https://registry.docker-cn.com/
 https://docker.mirrors.ustc.edu.cn/
...Copy to clipboardErrorCopied
</code></pre> 
<h4><a id="34__516"></a>3.4 导入已有的镜像文件</h4> 
<p>考虑到有些场景下的联网的不方便，docker 提供了将已下载的 images 打包导出，再在别处导入的功能。</p> 
<p>导出已有 image 使用命令：</p> 
<pre><code class="prism language-sh">docker save &lt;repository&gt;:&lt;tag&gt; -o &lt;repository&gt;.tarCopy to clipboardErrorCopied
</code></pre> 
<p>例如：</p> 
<pre><code class="prism language-sh">docker save mysql:5.7 -o mysql-5.7.tarCopy to clipboardErrorCopied
</code></pre> 
<p>导入 image 使用命令：</p> 
<pre><code class="prism language-sh">docker load -i &lt;repository&gt;.tarCopy to clipboardErrorCopied
</code></pre> 
<p>例如：</p> 
<pre><code class="prism language-sh">docker load -i mysql-5.7.tar
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/951396f6c88942819ad940ee21f8c9e2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">解决Ado连接MySQL使用“GetRecordCount“返回-1</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4317f52c628654601b12c4f86bea236f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">arcgis许可启动不了解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>