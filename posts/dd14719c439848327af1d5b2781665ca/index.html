<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>cmake-debug和release模式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="cmake-debug和release模式" />
<meta property="og:description" content="一般在工程中，自动构建可能会编译两个版本的发布包，一个debug版本，一个release版本。那么通过cmake怎样来实现呢？本文就以这个需求为例，来介绍cmake中的逻辑控制。
文章目录 目录结构Debug-Release模式控制顶层CMakeLists.txt默认编译release 编译debug编译 控制逻辑条件命令 目录结构 |-- bin |-- build |-- CMakeLists.txt |-- src | `-- main.c Debug-Release模式控制 顶层CMakeLists.txt cmake_minimum_required(VERSION 3.12) project(test07) aux_source_directory(${PROJECT_SOURCE_DIR}/src src_dirs) # 条件判断 if(CMAKE_BUILD_TYPE AND (CMAKE_BUILD_TYPE STREQUAL &#34;Debug&#34;)) set(CMAKE_C_FLAGS_DEBUG &#34;${CMAKE_C_FLAGS_DEBUG} -Wall -O0&#34;) message(&#34;Debug mode:${CMAKE_C_FLAGS_DEBUG}&#34;) add_executable(test_debug ${src_dirs}) elseif(CMAKE_BUILD_TYPE AND (CMAKE_BUILD_TYPE STREQUAL &#34;Release&#34;)) set(CMAKE_C_FLAGS_RELEASE &#34;${CMAKE_C_FLAGS_RELEASE} -Wall -O3&#34;) message(&#34;Release mode:${CMAKE_C_FLAGS_RELEASE}&#34;) add_executable(test_release ${src_dirs}) else() message(&#34;else:${CMAKE_BUILD_TYPE}&#34;) message(&#34;else:${CMAKE_C_FLAGS_RELEASE}&#34;) add_executable(test_release ${src_dirs}) endif() 先简要的描述一下该CMakeLists.txt的控制逻辑。如果CMAKE_BUILD_TYPE的值为&#34;Debug&#34;就采用debug模式编译；如果CMAKE_BUILD_TYPE的值为&#34;Release&#34;就采用release模式编译；如果CMAKE_BUILD_TYPE的值为空，默认采用release模式
默认编译 从上图可以看出，CMAKE_C_FLAGS_RELEASE 编译选项的默认值为-O3 -DNDEBUG。最终生成可执行文件test_release，./test_release输出’hello cmake’。test_release文件大小为8600字节。
release 编译 从上图可以看出，通过cmake命令行指定CMAKE_BUILD_TYPE为Release，最终生成可执行文件test_release，./test_release输出’hello cmake’。test_release文件大小为8600字节。
debug编译 从上图可以看出，通过cmake命令行指定CMAKE_BUILD_TYPE为Debug，最终生成可执行文件test_release，." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/dd14719c439848327af1d5b2781665ca/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-08-27T09:07:54+08:00" />
<meta property="article:modified_time" content="2020-08-27T09:07:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">cmake-debug和release模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>一般在工程中，自动构建可能会编译两个版本的发布包，一个debug版本，一个release版本。那么通过cmake怎样来实现呢？本文就以这个需求为例，来介绍cmake中的逻辑控制。<br> </p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_2" rel="nofollow">目录结构</a></li><li><a href="#DebugRelease_15" rel="nofollow">Debug-Release模式控制</a></li><li><ul><li><a href="#CMakeListstxt_17" rel="nofollow">顶层CMakeLists.txt</a></li><li><ul><li><a href="#_44" rel="nofollow">默认编译</a></li><li><a href="#release__49" rel="nofollow">release 编译</a></li><li><a href="#debug_54" rel="nofollow">debug编译</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_60" rel="nofollow">控制逻辑</a></li><li><ul><li><a href="#_64" rel="nofollow">条件命令</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="_2"></a>目录结构</h2> 
<pre><code class="prism language-shell"><span class="token operator">|</span>-- bin
<span class="token operator">|</span>-- build
<span class="token operator">|</span>-- CMakeLists.txt
<span class="token operator">|</span>-- src
<span class="token operator">|</span>   `-- main.c

</code></pre> 
<h2><a id="DebugRelease_15"></a>Debug-Release模式控制</h2> 
<h3><a id="CMakeListstxt_17"></a>顶层CMakeLists.txt</h3> 
<pre><code class="prism language-cmake">cmake_minimum_required(VERSION 3.12)
project(test07)

aux_source_directory(${PROJECT_SOURCE_DIR}/src src_dirs)

# 条件判断
if(CMAKE_BUILD_TYPE AND (CMAKE_BUILD_TYPE STREQUAL "Debug"))
    set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -Wall -O0")
    message("Debug mode:${CMAKE_C_FLAGS_DEBUG}")
    add_executable(test_debug ${src_dirs})

elseif(CMAKE_BUILD_TYPE AND (CMAKE_BUILD_TYPE STREQUAL "Release"))
    set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -Wall -O3")
    message("Release mode:${CMAKE_C_FLAGS_RELEASE}")
    add_executable(test_release ${src_dirs})
else()
    message("else:${CMAKE_BUILD_TYPE}")
    message("else:${CMAKE_C_FLAGS_RELEASE}")
    add_executable(test_release ${src_dirs})
endif()
</code></pre> 
<p>先简要的描述一下该CMakeLists.txt的控制逻辑。如果CMAKE_BUILD_TYPE的值为"Debug"就采用debug模式编译；如果CMAKE_BUILD_TYPE的值为"Release"就采用release模式编译；如果CMAKE_BUILD_TYPE的值为空，默认采用release模式</p> 
<h4><a id="_44"></a>默认编译</h4> 
<p><img src="https://images2.imgbox.com/43/2a/PkVHMtTr_o.png" alt="在这里插入图片描述"></p> 
<p>从上图可以看出，CMAKE_C_FLAGS_RELEASE 编译选项的默认值为<code>-O3 -DNDEBUG</code>。最终生成可执行文件test_release，<code>./test_release</code>输出’hello cmake’。test_release文件大小为8600字节。</p> 
<h4><a id="release__49"></a>release 编译</h4> 
<p><img src="https://images2.imgbox.com/1c/b7/g3lrzTTN_o.png" alt="在这里插入图片描述"></p> 
<p>从上图可以看出，通过cmake命令行指定CMAKE_BUILD_TYPE为Release，最终生成可执行文件test_release，<code>./test_release</code>输出’hello cmake’。test_release文件大小为8600字节。</p> 
<h4><a id="debug_54"></a>debug编译</h4> 
<p><img src="https://images2.imgbox.com/f6/49/dbE7qoRD_o.png" alt="在这里插入图片描述"></p> 
<p>从上图可以看出，通过cmake命令行指定CMAKE_BUILD_TYPE为Debug，最终生成可执行文件test_release，<code>./test_release</code>输出’hello cmake’。test_release文件大小为9872字节。因为debug模式编译生成的可执行文件包含可调试的相关信息，所以文件大小会变大。</p> 
<h2><a id="_60"></a>控制逻辑</h2> 
<p>通过上例知道，可以通过if命令来控制cmake的编译逻辑，接下来，详细介绍cmake中if命令的使用。</p> 
<h3><a id="_64"></a>条件命令</h3> 
<blockquote> 
 <pre><code class="prism language-cmake">if(&lt;condition&gt;)
  &lt;commands&gt;
elseif(&lt;condition&gt;) # optional block, can be repeated
  &lt;commands&gt;
else()              # optional block
  &lt;commands&gt;
endif()
</code></pre> 
</blockquote> 
<p><a href="https://cmake.org/cmake/help/v3.18/command/if.html" rel="nofollow">if</a>条件命名的语法非常简单。这里需要特别说明关于<code>if(&lt;variable&gt;)</code>中variable的注意点，引用<a href="https://cmake.org/cmake/help/v3.18/command/if.html" rel="nofollow">文档</a>中的一段话：</p> 
<blockquote> 
 <p>The if command was written very early in CMake’s history, predating the <code>${}</code> variable evaluation syntax, and for convenience evaluates variables named by its arguments as shown in the above signatures. Note that normal variable evaluation with <code>${}</code> applies before the if command even receives the arguments.</p> 
</blockquote> 
<p>这段话的意思是，由于if命令语法在变量引用<code>${}</code>语法之前出现，所以如果使用<code>if(${var})</code>，那么将会被引用两次；如果使用<code>if(var)</code>，将只会被if本身的语法引用一次。也就是要注意<strong>两次引用</strong>问题。</p> 
<p>举个栗子：</p> 
<pre><code class="prism language-cmake"># 在前面的CMakeLists.txt中
if(CMAKE_BUILD_TYPE AND (CMAKE_BUILD_TYPE STREQUAL "Debug"))

如果是通过cmake .. 编译，而没有指定CMAKE_BUILD_TYPE的话，那么if命令本身会引用变量CMAKE_BUILD_TYPE，其值为空，if条件判断为假；
如果是通过cmake -DCMAKE_BUILD_TYPE=Debug .. 编译，if命令本身会引用变量CMAKE_BUILD_TYPE，其值为Debug，if条件判断为真；

# 如果将变量CMAKE_BUILD_TYPE通过${}再引用一次，会发生什么？
if(${CMAKE_BUILD_TYPE} AND (CMAKE_BUILD_TYPE STREQUAL "Debug"))

</code></pre> 
<p>由于 <code>${CMAKE_BUILD_TYPE}</code>的值为空，<code>if(${CMAKE_BUILD_TYPE}</code>相当于<code>if(空变量)</code>，然后if命令再对"空变量"进行引用，显然，语法上错误。即会报如下图错误：<br> <img src="https://images2.imgbox.com/ad/5c/h4bmvF4Q_o.png" alt="在这里插入图片描述"></p> 
<p>如果你非要使用<code>if($var)</code>，那你必须明确的知道变量var的值是另一个变量的变量名。</p> 
<p>例如，将前面的CMakeLists.txt做如下修改(虽然没有什么实际意义，仅作为解释语法特点)</p> 
<pre><code class="prism language-cmake">cmake_minimum_required(VERSION 3.12)
project(test07)

aux_source_directory(${PROJECT_SOURCE_DIR}/src src_dirs)

set(mode "CMAKE_BUILD_TYPE") # 修改点

# 条件判断
if(${mode} AND (CMAKE_BUILD_TYPE STREQUAL "Debug")) # 修改点
    set(CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -Wall -O0")
    message("Debug mode:${CMAKE_C_FLAGS_DEBUG}")
    add_executable(test_debug ${src_dirs})

elseif(${mode} AND (CMAKE_BUILD_TYPE STREQUAL "Release")) # 修改点
    set(CMAKE_C_FLAGS_RELEASE "${CMAKE_C_FLAGS_RELEASE} -Wall -O3")
    message("Release mode:${CMAKE_C_FLAGS_RELEASE}")
    add_executable(test_release ${src_dirs})
else()
    message("else:${CMAKE_BUILD_TYPE}")
    message("else:${CMAKE_C_FLAGS_RELEASE}")
    add_executable(test_release ${src_dirs})
endif()
</code></pre>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/716756d75e0fecca7e03c82089641f87/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">LeetCode第 787 题：K 站中转内最便宜的航班(C&#43;&#43;)</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/a14fa176df0cbc759c93506de431a52c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">js中 window.location.href使用post请求</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>