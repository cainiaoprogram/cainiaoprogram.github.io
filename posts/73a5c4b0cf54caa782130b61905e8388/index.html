<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【文献翻译】七种FD发现算法（未完成） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【文献翻译】七种FD发现算法（未完成）" />
<meta property="og:description" content="【文献翻译】Functional Dependency Discovery:An Experimental Evaluation of Seven Algorithms 摘要1. 函数依赖关系2. FD算法概述2.1 准备工作2.2 分类2.3 其他算法 3. 七种FD发现算法3.1 TANE3.2 FUN3.3 FD Mine3.4 DFD3.5 Dep-Miner3.6 FastFDs3.7 FDEP 4. 评价4.1 实验装置4.2 行可扩展性实验4.3 列可扩展性实验4.4 对不同数据集的实验4.5 内存实验4.6 实验结果外推 5. 总结 摘要 1. 函数依赖关系 所有算法的目标相同，即发现给定数据集中所有最小的、非平凡的函数依赖关系。
分析：怎么理解最小，非平凡
贡献：我们按其主要概念对七种FD算法进行了分类，并对最新的发展进行了概述。我们重新审视所有的算法，并为它们的实际实现提供额外的描述，因为它们的原始出版物很少。我们比较了不同数据集的算法，并评估运行时和内存使用情况。从我们的实验结果，我们得出了具体的建议，何时使用哪种算法。我们还将所有实施、数据和评估框架在线提供
结构：第2节给出了FD发现的概述，讨论了常见概念、替代方法以及我们对发现算法的分类。第3节描述了算法的实现。第4节给出了我们的评估结果，第5节总结了每种发现算法的优缺点
2. FD算法概述 2.1 准备工作 FD的定义：X-&gt;A ；如果X的子集并不确定A，则函数依赖性X→A是最小的。如果A不是X的子集，则它是非平凡的。为了发现数据集中的所有函数依赖性，只要发现所有最小的、非平凡的FDs就足够了，因为所有的左侧（lhs）子集都是非依赖性的，而所有的左侧（lhs）超集都是逻辑推理的依赖性。
子集和超集：
2.2 分类 为了更好地理解这七种函数依赖性发现算法及其性质，我们将它们分为三类。第3节以下是对每种算法的详细讨论。
2.3 其他算法 3. 七种FD发现算法 3.1 TANE 有参考资料
基于三个概念：
分区细分（partition refinement）检查函数依赖是否成立先验-基因（apriori-gen）确保找到所有且只有最小的函数依赖被发现剪枝规则（pruning rules）动态缩小搜索空间
与所有的格遍历算法一样，TANE将搜索空间建模为Hasse图，如第2.1节所述。 2.1节讲了什么
图1描述了关系式r ={A,B,C}的Hasse图。
晶格被划分为级别，其中Li级别包含大小为i的所有属性组合。TANE没有开始计算整个晶格，而是从第1级（大小为1 属性集）开始，然后逐级向上移动（示例中的粗体）。
In each level Li, the algorithm tests all attribute combinations X ∈ Li for the functional dependency X \ A → A for all A ∈ X." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/73a5c4b0cf54caa782130b61905e8388/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-07-02T21:15:54+08:00" />
<meta property="article:modified_time" content="2021-07-02T21:15:54+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【文献翻译】七种FD发现算法（未完成）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>【文献翻译】Functional Dependency Discovery:An Experimental Evaluation of Seven Algorithms</h4> 
 <ul><li><a href="#_1" rel="nofollow">摘要</a></li><li><a href="#1__2" rel="nofollow">1. 函数依赖关系</a></li><li><a href="#2_FD_11" rel="nofollow">2. FD算法概述</a></li><li><ul><li><a href="#21__12" rel="nofollow">2.1 准备工作</a></li><li><a href="#22__19" rel="nofollow">2.2 分类</a></li><li><a href="#23__22" rel="nofollow">2.3 其他算法</a></li></ul> 
  </li><li><a href="#3_FD_23" rel="nofollow">3. 七种FD发现算法</a></li><li><ul><li><a href="#31_TANE_24" rel="nofollow">3.1 TANE</a></li><li><a href="#32_FUN_64" rel="nofollow">3.2 FUN</a></li><li><a href="#33_FD_Mine_66" rel="nofollow">3.3 FD Mine</a></li><li><a href="#34_DFD_67" rel="nofollow">3.4 DFD</a></li><li><a href="#35_DepMiner_68" rel="nofollow">3.5 Dep-Miner</a></li><li><a href="#36_FastFDs_69" rel="nofollow">3.6 FastFDs</a></li><li><a href="#37_FDEP_70" rel="nofollow">3.7 FDEP</a></li></ul> 
  </li><li><a href="#4__71" rel="nofollow">4. 评价</a></li><li><ul><li><a href="#41__72" rel="nofollow">4.1 实验装置</a></li><li><a href="#42__73" rel="nofollow">4.2 行可扩展性实验</a></li><li><a href="#43__74" rel="nofollow">4.3 列可扩展性实验</a></li><li><a href="#44__75" rel="nofollow">4.4 对不同数据集的实验</a></li><li><a href="#45__76" rel="nofollow">4.5 内存实验</a></li><li><a href="#46__77" rel="nofollow">4.6 实验结果外推</a></li></ul> 
  </li><li><a href="#5__78" rel="nofollow">5. 总结</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>摘要</h2> 
<h2><a id="1__2"></a>1. 函数依赖关系</h2> 
<p>所有算法的目标相同，即发现给定数据集中所有最小的、非平凡的函数依赖关系。</p> 
<blockquote> 
 <p>分析：怎么理解最小，非平凡</p> 
</blockquote> 
<p><strong>贡献</strong>：我们按其主要概念对七种FD算法进行了分类，并对最新的发展进行了概述。我们重新审视所有的算法，并为它们的实际实现提供额外的描述，因为它们的原始出版物很少。我们比较了不同数据集的算法，并评估运行时和内存使用情况。从我们的实验结果，我们得出了具体的建议，何时使用哪种算法。我们还将所有实施、数据和评估框架在线提供</p> 
<p><strong>结构</strong>：第2节给出了FD发现的概述，讨论了常见概念、替代方法以及我们对发现算法的分类。第3节描述了算法的实现。第4节给出了我们的评估结果，第5节总结了每种发现算法的优缺点</p> 
<h2><a id="2_FD_11"></a>2. FD算法概述</h2> 
<h3><a id="21__12"></a>2.1 准备工作</h3> 
<p>FD的定义：X-&gt;A ；如果X的子集并不确定A，则函数依赖性X→A是最小的。如果A不是X的子集，则它是非平凡的。为了发现数据集中的所有函数依赖性，只要发现所有最小的、非平凡的FDs就足够了，因为所有的左侧（lhs）子集都是非依赖性的，而所有的左侧（lhs）超集都是逻辑推理的依赖性。</p> 
<blockquote> 
 <p>子集和超集：</p> 
</blockquote> 
<p><img src="https://images2.imgbox.com/2f/89/uKnhGVtM_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="22__19"></a>2.2 分类</h3> 
<p>为了更好地理解这七种函数依赖性发现算法及其性质，我们将它们分为三类。第3节以下是对每种算法的详细讨论。</p> 
<h3><a id="23__22"></a>2.3 其他算法</h3> 
<h2><a id="3_FD_23"></a>3. 七种FD发现算法</h2> 
<h3><a id="31_TANE_24"></a>3.1 TANE</h3> 
<blockquote> 
 <p>有参考资料</p> 
</blockquote> 
<p>基于三个概念：</p> 
<ul><li>分区细分（partition refinement）检查函数依赖是否成立</li><li>先验-基因（apriori-gen）确保找到所有且只有最小的函数依赖被发现</li><li>剪枝规则（pruning rules）动态缩小搜索空间<br> 与所有的格遍历算法一样，TANE将搜索空间建模为Hasse图，如第2.1节所述。</li></ul> 
<blockquote> 
 <p>2.1节讲了什么</p> 
</blockquote> 
<p>图1描述了关系式r ={A,B,C}的Hasse图。<br> <img src="https://images2.imgbox.com/44/57/MhtjvqJL_o.png" alt="图1 一种用于TANE的修剪过的格子"></p> 
<p>晶格被划分为级别，其中Li级别包含大小为i的所有属性组合。TANE没有开始计算整个晶格，而是从第1级（大小为1 属性集）开始，然后逐级向上移动（示例中的粗体）。</p> 
<p>In each level Li, the algorithm tests all attribute combinations X ∈ Li for the functional dependency X \ A → A for all A ∈ X.</p> 
<blockquote> 
 <p>X \ A表示差集</p> 
</blockquote> 
<p>在每一级别中Li中算法对X∈Li的所有的属性组合进行测试，进行函数依赖X \ A→A的测试</p> 
<p>如果一个测试交付一个新的函数依赖项，那么 Tane 会使用一组剪枝规则修正所有已发现 FD 的超集。当向上移动到下一个级别时，apriorigen 函数[2]只计算前一个级别中尚未裁剪的属性组合。</p> 
<p>请注意，图1显示了一个示例，我们将在本节的最后更详细地描述这个示例。</p> 
<p>TANE’s search space pruning is based on the fact that for a complete result only minimal functional dependencies need be discovered. To prune efficiently, the algorithm stores a set of right-hand-side candidates C+(X) for each attribute combination X. The set C+(X) = {A ∈ R | ∀B ∈ X : X \ {A, B} → B does not hold} contains all attributes that may still depend on set X. C+(X) is used in the following three pruning rules:</p> 
<p>TANE’s的搜索空间修剪是基于这样一个事实，即对于一个完整的结果，只需要发现最小的函数依赖性。为了有效地修剪，该算法为<strong>每个属性组合</strong>X存储一组右侧候选对象C+(X)。</p> 
<p>集合C+(X)={A∈R|∀B∈X：X \ {A，B}→B不成立}, 集合C+(X)包含仍然可能依赖于集合X的所有属性</p> 
<blockquote> 
 <p>问题：C+（X）为什么包含的是可能依赖于X的所有属性？ 对C+（X）这个集合的概念理解起来有点困难</p> 
</blockquote> 
<p>以下三个修剪规则中使用了C+(X)：</p> 
<ul><li> <p>最小性剪枝：如果一个函数依赖项X\A→A成立，则可以从C+(X)中删除A和所有B∈C+(X)\X。换句话说，如果X包含FD X\A→A，则任何FD X→B都不能是最小值，因为A使X成为非最小值。请注意，此定义还包括A=B。</p> 
  <blockquote> 
   <p>问题：为什么要删除这里的B？ 如果存在 X\A→A说明 X→ A不是最小的，为啥说明X→B也不是最小的。</p> 
  </blockquote> </li><li> <p>右侧剪枝：如果C+(X)=∅，则可以从格中修剪属性组合X，因为没有最小函数依赖性的右侧候选对象。</p> </li><li> <p>键剪枝：如果属性组合X是键，可以从格中修剪。键X是一种属性组合，它确定关系R中的所有其他属性R\X。因此，X的所有超集都是超键，根据定义是非最小的。</p> 
  <blockquote> 
   <p>理解：这里说X的所有超码需要剪到候选码</p> 
  </blockquote> </li></ul> 
<h3><a id="32_FUN_64"></a>3.2 FUN</h3> 
<blockquote> 
 <p>有参考资料</p> 
</blockquote> 
<h3><a id="33_FD_Mine_66"></a>3.3 FD Mine</h3> 
<h3><a id="34_DFD_67"></a>3.4 DFD</h3> 
<h3><a id="35_DepMiner_68"></a>3.5 Dep-Miner</h3> 
<h3><a id="36_FastFDs_69"></a>3.6 FastFDs</h3> 
<h3><a id="37_FDEP_70"></a>3.7 FDEP</h3> 
<h2><a id="4__71"></a>4. 评价</h2> 
<h3><a id="41__72"></a>4.1 实验装置</h3> 
<h3><a id="42__73"></a>4.2 行可扩展性实验</h3> 
<h3><a id="43__74"></a>4.3 列可扩展性实验</h3> 
<h3><a id="44__75"></a>4.4 对不同数据集的实验</h3> 
<h3><a id="45__76"></a>4.5 内存实验</h3> 
<h3><a id="46__77"></a>4.6 实验结果外推</h3> 
<h2><a id="5__78"></a>5. 总结</h2>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/bac58cd2d7ba2cb8262fb836a375dd1b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Lombok 中 @EqualsAndHashCode注解的使用</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/90b2dc67258823958b8e489046a23bb7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Excel Power Pivot是什么?（原文带有Power Pivot简单的操作）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>