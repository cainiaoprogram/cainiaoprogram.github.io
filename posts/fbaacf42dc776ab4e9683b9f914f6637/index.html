<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>spring框架简单入门 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="spring框架简单入门" />
<meta property="og:description" content="初识spring
spring框架的两大优势:
1.==简化开发== 简化了企业级开发的复杂性
2.==框架继承==高效整合了其他主流框架,提升运行与开发效率
核心思想:
1.IOC(控制反转)
2.AOC(面向切面编程)
spring发展史:
2004年Rod Johnson创建了更为高效的spring框架,
spring1.0: 是去全配置形式进行编程
spring2.0: 添加了注解功能,提高了开发效率
spring3.0: 完全变成了纯注解开发
spring4.0: 根据jdk的更新, 对个别jdk进行了调整
spring5.0: 全面支持jdk8, 这个时候如果要用spring框架就要使用jdk8至以上的版本
spring框架的架构图:
IOC与DI核心思想:
IOC(Inversion of Control 控制反转)
new对象这样层级之间的耦合性就会很高,IOC是将创建对象的权利移交给了外部,也就是spring,spring框架在外部创建了一个IOC容器,将创建的对象称之为Bean存储在容器中.当我们需要用到对象的时候,容器给我们提供了一个方法,我们就可以获取到对象,也解除了耦合性
DI(Dependency Injection 依赖注入)
往往一个对象的执行需要依赖于其他对象的支撑,这个时候spring框架会将IOC容器中存储的有依赖关系的bean进行依赖绑定.
IOC和DI的实现,为了实现充分的解耦,这样我们不仅可以直接从容器中拿到bean,而且bean也获取到了所有的依赖关系
使用配置文件简单实现IOC控制反转
&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt; &lt;beans xmlns=&#34;http://www.springframework.org/schema/beans&#34; xmlns:xsi=&#34;http://www.w3.org/2001/XMLSchema-instance&#34; xsi:schemaLocation=&#34;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&#34;&gt; &lt;!--在spring配置文件中配置管理bean--&gt; &lt;!--配置数据实现层bean--&gt; &lt;!-- id属性: 代表指定的bean名称,在从容器中获取bean的时候,用此名称可以获取到此bean--&gt; &lt;!-- class属性: 指定bean的类型,这里用全类名指定到数据实现层的实现类BookDaoImpl,代表创建的bean是BookDaoImpl类型--&gt; &lt;bean id=&#34;bookDao&#34; class=&#34;com.itheima.dao.impl.BookDaoImpl&#34;&gt; &lt;/bean&gt; &lt;!--配置业务实现层bean--&gt; &lt;!-- id属性: 代表指定的bean名称,在从容器中获取bean的时候,用此名称可以获取到此bean--&gt; &lt;!-- class属性: 指定bean的类型,这里用全类名指定到数据实现层的实现类BookServiceImpl,代表创建的bean是BookServiceImpl类型--&gt; &lt;bean id=&#34;bookService&#34; class=&#34;com.itheima.service.impl.BookServiceImpl&#34;&gt; &lt;!--而业务实现层对象是依赖于数据实现层对象运行的,所以service层依赖dao层,使用DI进行依赖注入--&gt; &lt;!--name属性:代表配置的哪一个具体的属性--&gt; &lt;!--ref属性: 代表依赖的哪一个bean,这里依赖的是dao层的bean--&gt; &lt;property name=&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/fbaacf42dc776ab4e9683b9f914f6637/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-03-03T19:48:38+08:00" />
<meta property="article:modified_time" content="2022-03-03T19:48:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">spring框架简单入门</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><strong>初识spring</strong></p> 
<blockquote> 
 <p><strong>spring框架的两大优势:</strong></p> 
 <p>        1.==简化开发== 简化了企业级开发的复杂性</p> 
 <p>        2.==框架继承==高效整合了其他主流框架,提升运行与开发效率</p> 
 <p><strong>核心思想:</strong></p> 
 <p>        1.IOC(控制反转)</p> 
 <p>        2.AOC(面向切面编程)</p> 
 <p><strong>spring发展史:</strong></p> 
 <p><img alt="" height="501" src="https://images2.imgbox.com/5a/a6/ux1F2pos_o.png" width="1104"></p> 
 <p> 2004年Rod Johnson创建了更为高效的spring框架,</p> 
 <p>spring1.0: 是去全配置形式进行编程</p> 
 <p>spring2.0: 添加了注解功能,提高了开发效率</p> 
 <p>spring3.0: 完全变成了纯注解开发</p> 
 <p>spring4.0: 根据jdk的更新, 对个别jdk进行了调整</p> 
 <p>spring5.0: 全面支持jdk8, 这个时候如果要用spring框架就要使用jdk8至以上的版本</p> 
</blockquote> 
<p><strong>spring框架的架构图:</strong></p> 
<blockquote> 
 <img alt="" height="574" src="https://images2.imgbox.com/2a/80/w32ZHG3f_o.png" width="1165"> 
</blockquote> 
<p><strong>IOC与DI核心思想:</strong></p> 
<blockquote> 
 <p><strong>IOC(Inversion of Control  控制反转)</strong></p> 
 <p>        new对象这样层级之间的耦合性就会很高,IOC是将创建对象的权利移交给了外部,也就是spring,spring框架在外部创建了一个IOC容器,将创建的对象称之为Bean存储在容器中.当我们需要用到对象的时候,容器给我们提供了一个方法,我们就可以获取到对象,也解除了耦合性</p> 
 <p><strong>DI(Dependency Injection  依赖注入)</strong></p> 
 <p>        往往一个对象的执行需要依赖于其他对象的支撑,这个时候spring框架会将IOC容器中存储的有依赖关系的bean进行依赖绑定.</p> 
 <p><strong>IOC和DI的实现,为了实现充分的解耦,这样我们不仅可以直接从容器中拿到bean,而且bean也获取到了所有的依赖关系</strong></p> 
</blockquote> 
<p><strong>使用配置文件简单实现IOC控制反转</strong></p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;

    &lt;!--在spring配置文件中配置管理bean--&gt;

    &lt;!--配置数据实现层bean--&gt;
    &lt;!-- id属性: 代表指定的bean名称,在从容器中获取bean的时候,用此名称可以获取到此bean--&gt;
    &lt;!-- class属性: 指定bean的类型,这里用全类名指定到数据实现层的实现类BookDaoImpl,代表创建的bean是BookDaoImpl类型--&gt;
    &lt;bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"&gt;

    &lt;/bean&gt;


    &lt;!--配置业务实现层bean--&gt;
    &lt;!-- id属性: 代表指定的bean名称,在从容器中获取bean的时候,用此名称可以获取到此bean--&gt;
    &lt;!-- class属性: 指定bean的类型,这里用全类名指定到数据实现层的实现类BookServiceImpl,代表创建的bean是BookServiceImpl类型--&gt;
    &lt;bean id="bookService" class="com.itheima.service.impl.BookServiceImpl"&gt;

        &lt;!--而业务实现层对象是依赖于数据实现层对象运行的,所以service层依赖dao层,使用DI进行依赖注入--&gt;

        &lt;!--name属性:代表配置的哪一个具体的属性--&gt;
        &lt;!--ref属性: 代表依赖的哪一个bean,这里依赖的是dao层的bean--&gt;
        &lt;property name="bookDao" ref="bookDao"/&gt;

    &lt;/bean&gt;


&lt;/beans&gt;</code></pre> 
<p><strong>实例化bean的三种实现方式:</strong></p> 
<blockquote> 
 <p><strong>构造方法:</strong></p> 
 <pre><code class="language-XML">&lt;bean id="bookDao" class="com.itheima.dao.impl.BookDaoImpl"&gt;</code></pre> 
 <p>静态/非静态工厂方法: (有些老一点的程序为了解耦创建了对象工厂)</p> 
 <p><img alt="" height="457" src="https://images2.imgbox.com/d4/7f/utlCSV9B_o.png" width="1157"></p> 
 <p> 实例化工厂的升级方法:</p> 
 <p><img alt="" height="692" src="https://images2.imgbox.com/08/e7/zzj4NVw1_o.png" width="813"></p> 
 <p> <img alt="" height="116" src="https://images2.imgbox.com/2a/9b/UT3FwKRz_o.png" width="884"></p> 
 <p></p> 
</blockquote> 
<p><strong>bean的生命周期</strong></p> 
<blockquote> 
 <p><strong>1.使用属性:</strong></p> 
 <p>init-method="初始化方法" destroy-method="销毁前执行的方法"</p> 
 <p><strong>2.使用接口</strong></p> 
 <p>InitializingBean, DisposableBean</p> 
 <p>实现这两个类,重写方法</p> 
 <p><img alt="" height="251" src="https://images2.imgbox.com/34/c5/vaVKOO19_o.png" width="695"></p> 
 <p> bean的销毁时机:</p> 
 <p> 在容器销毁的时候才会执行bean的销毁方法,</p> 
 <p>1.手动关闭容器:</p> 
 <p><code>ConfigurableApplicationContext</code>接口的<code>close()</code>方法</p> 
 <p>2.注册关闭钩子(在虚拟机关闭前,先关闭容器再关闭虚拟机)</p> 
 <p><code>ConfigurableApplicationContext</code>接口的<code>registerShutdownHook()</code>方法</p> 
</blockquote> 
<p><strong>DI的简单实现</strong></p> 
<blockquote> 
 <p><strong>setter注入:</strong></p> 
 <p>        使用&lt;property&gt;标签 </p> 
 <p>        &lt;property name="bookDao" ref="bookDao"/&gt;</p> 
 <p>        name属性是指set方法,ref属性是对应容器中的bean对象</p> 
 <p><strong>构造器注入:</strong></p> 
 <p><strong>        </strong>使constructor-arg&gt;标签</p> 
 <p>        &lt;constructor-arg name="bookDao" ref="bookDao"/&gt;</p> 
 <p>        name属性是指构造方法中的参数名,ref属性是对应容器中的bean对象</p> 
 <p><strong>注入基本数据类型:</strong></p> 
 <p><strong>        </strong>&lt;var&gt;标签换为&lt;value&gt;</p> 
</blockquote> 
<p><strong>自动装配:</strong></p> 
<blockquote> 
 <p>概念:</p> 
 <p>        IOC容器根据bean需要的依赖,自动在容器中找到对应的bean进行装配注入</p> 
 <p>使用<strong>autowire</strong>属性关键字:</p> 
 <p>        <strong>autowire="byType"</strong> 根据类型进行自动装配(需保证bean的唯一性,推荐使用)</p> 
 <p>        <strong>autowire="byName" </strong>根据bean名称进行装配(不推荐使用)</p> 
</blockquote> 
<p><strong>集合注入:</strong></p> 
<blockquote> 
 <pre><code class="language-XML">  &lt;!--注入数组数据--&gt;
        &lt;property name="array"&gt;
            &lt;array&gt;
                &lt;value&gt;100&lt;/value&gt;
                &lt;value&gt;200&lt;/value&gt;
            &lt;/array&gt;
        &lt;/property&gt;
        &lt;!--注入list集合数据--&gt;
        &lt;property name="list"&gt;
            &lt;list&gt;
                &lt;value&gt;aa&lt;/value&gt;
                &lt;value&gt;bb&lt;/value&gt;
            &lt;/list&gt;
        &lt;/property&gt;
        &lt;!--注入set集合数据(会自动删选重复数据)--&gt;
        &lt;property name="set"&gt;
            &lt;set&gt;
                &lt;value&gt;aa&lt;/value&gt;
                &lt;value&gt;aa&lt;/value&gt;&lt;!--会被筛选掉--&gt;
            &lt;/set&gt;
        &lt;/property&gt;
        &lt;!--注入map集合数据--&gt;
        &lt;property name="map"&gt;
            &lt;map&gt;
                &lt;entry key="键1" value="值1"/&gt;
                &lt;entry key="键2" value="值2"/&gt;
            &lt;/map&gt;
        &lt;/property&gt;
        &lt;property name="properties"&gt;
            &lt;props&gt;
                &lt;prop key="country"&gt;china&lt;/prop&gt;
                &lt;prop key="province"&gt;henan&lt;/prop&gt;
                &lt;prop key="city"&gt;kaifeng&lt;/prop&gt;
            &lt;/props&gt;
        &lt;/property&gt;</code></pre> 
 <p>property标签表示setter方式注入，构造方式注入constructor-arg标签内部也可以写&lt;array&gt;、&lt;list&gt;、&lt;set&gt;、&lt;map&gt;、&lt;props&gt;标签</p> 
</blockquote> 
<p></p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d9b6d8f15f167ac1ffbbf661882c1d83/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Sentinel哨兵框架</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/f044adb6803973e54612621c0f7e02f9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Lesson 13.3 梯度不平稳性与Glorot条件</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>