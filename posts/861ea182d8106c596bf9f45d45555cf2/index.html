<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>指针02 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="指针02" />
<meta property="og:description" content="1.类型的转换 1）基础类型之间可以进行转换 例如：下面的代码可以通过编译 int x = 1; char y = 2; x = y; 2）基础数据和结构类型之间不能转换 无法通过编译： struct st{ int a; int b; }; void fun() { st t1 = {1, 2}; int x = (int) t1; } 3）待*的类型的转换 带*的基础类型和带*的结构类型之间可以转换 例如：可以通过编译： struct st{ int a; int b; }; void fun() { int* x = (int*)1; st* y = (st*)x ; } 2.&amp;符号 &amp;是地址符，类型是其后面的类型加一个“*”，任何变量都可以使用&amp;来获取地址，但不能用在常量上。 获取变量a的地址： int a = 1; int* pa = &amp;a; &amp;a的类型就是变量a的类型加上一个*；例如这里a是int，&amp;a就是int*； 带*的类型通常赋值是必须用完整写法： int* a = (int*)1; 和取地址符&amp;一起使用时可以简写； char a = 10; short b = 20; int c = 30; char* pa = (char*)&amp;a; short* pb = (short*)&amp;b; int* pc = (int*)&amp;c; 简写为： char* pa = &amp;a; short* pb = &amp;b; int* pc = &amp;c; 带更多*的类型也一样： char a = 10; short b = 20; int c = 30; char* pa = &amp;a; short* pb = &amp;b; int* pc = &amp;c; char** ppa = (char**)&amp;pa; short** ppb = (short**)&amp;pb; int** ppc = (int**)&amp;pc; 简写为： char** ppa = &amp;pa; short** ppb = &amp;pb; int** ppc = &amp;pc; 反汇编分析： 代码： void fun() { int x = 1; int* y; y = &amp;x; } 反汇编： 3." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/861ea182d8106c596bf9f45d45555cf2/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-09-27T10:27:00+08:00" />
<meta property="article:modified_time" content="2019-09-27T10:27:00+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">指针02</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <div id="cnblogs_post_body" class="blogpost-body"> 
 <div>
   1.类型的转换 
 </div> 
 <div>
   1）基础类型之间可以进行转换 
 </div> 
 <div>
   例如：下面的代码可以通过编译 
 </div> 
 <div> 
  <div>
    int x = 1; 
  </div> 
  <div>
    char y = 2; 
  </div> 
  <div>
    x = y; 
  </div> 
 </div> 
 <div>
     
 </div> 
 <div>
   2）基础数据和结构类型之间不能转换 
 </div> 
 <div>
   无法通过编译： 
 </div> 
 <div> 
  <div>
    struct st{ 
  </div> 
  <div>
        int a; 
  </div> 
  <div>
        int b; 
  </div> 
  <div>
    }; 
  </div> 
  <div>
      
  </div> 
  <div>
    void fun()     
  </div> 
  <div>
    {    
  </div> 
  <div>
        st t1 = {1, 2}; 
  </div> 
  <div>
        int x = (int) t1; 
  </div> 
  <div>
    } 
  </div> 
 </div> 
 <div>
     
 </div> 
 <div>
   3）待*的类型的转换 
 </div> 
 <div>
   带*的基础类型和带*的结构类型之间可以转换 
 </div> 
 <div>
   例如：可以通过编译： 
 </div> 
 <div> 
  <div>
    struct st{ 
  </div> 
  <div>
        int a; 
  </div> 
  <div>
        int b; 
  </div> 
  <div>
    }; 
  </div> 
  <div>
    void fun()     
  </div> 
  <div>
    {    
  </div> 
  <div>
        int* x = (int*)1; 
  </div> 
  <div>
        st* y = (st*)x ;     
  </div> 
  <div>
    } 
  </div> 
 </div> 
 <div>
     
 </div> 
 <div>
   2.&amp;符号 
 </div> 
 <div>
   &amp;是地址符，类型是其后面的类型加一个“*”，任何变量都可以使用&amp;来获取地址，但不能用在常量上。 
 </div> 
 <div>
     
 </div> 
 <div>
   获取变量a的地址： 
 </div> 
 <div> 
  <div>
    int a = 1; 
  </div> 
  <div>
    int* pa = &amp;a; 
  </div> 
 </div> 
 <div>
   &amp;a的类型就是变量a的类型加上一个*；例如这里a是int，&amp;a就是int*； 
 </div> 
 <div>
     
 </div> 
 <div>
   带*的类型通常赋值是必须用完整写法： 
 </div> 
 <div> 
  <div>
    int* a = (int*)1; 
  </div> 
 </div> 
 <div>
   和取地址符&amp;一起使用时可以简写； 
 </div> 
 <div> 
  <div>
    char a = 10;         
  </div> 
  <div>
    short b = 20;         
  </div> 
  <div>
    int c = 30;         
  </div> 
  <div>
             
  </div> 
  <div>
    char* pa = (char*)&amp;a;         
  </div> 
  <div>
    short* pb = (short*)&amp;b;         
  </div> 
  <div>
    int* pc = (int*)&amp;c;         
  </div> 
  <div>
             
  </div> 
  <div>
    简写为：         
  </div> 
  <div>
    char* pa = &amp;a;         
  </div> 
  <div>
    short* pb = &amp;b;         
  </div> 
  <div>
    int* pc = &amp;c;     
  </div> 
 </div> 
 <div>
   带更多*的类型也一样： 
 </div> 
 <div> 
  <div>
    char a = 10;             
  </div> 
  <div>
    short b = 20;             
  </div> 
  <div>
    int c = 30;             
  </div> 
  <div>
                 
  </div> 
  <div>
    char* pa = &amp;a;             
  </div> 
  <div>
    short* pb = &amp;b;             
  </div> 
  <div>
    int* pc = &amp;c;             
  </div> 
  <div>
                 
  </div> 
  <div>
    char** ppa = (char**)&amp;pa;             
  </div> 
  <div>
    short** ppb = (short**)&amp;pb;             
  </div> 
  <div>
    int** ppc = (int**)&amp;pc;             
  </div> 
  <div>
                 
  </div> 
  <div>
    简写为：             
  </div> 
  <div>
    char** ppa = &amp;pa;             
  </div> 
  <div>
    short** ppb = &amp;pb;             
  </div> 
  <div>
    int** ppc = &amp;pc; 
  </div> 
 </div> 
 <div>
     
 </div> 
 <div>
   反汇编分析： 
 </div> 
 <div>
   代码： 
 </div> 
 <div> 
  <div>
    void fun()     
  </div> 
  <div>
    {    
  </div> 
  <div>
        int x = 1; 
  </div> 
  <div>
        int* y; 
  </div> 
  <div>
        y = &amp;x; 
  </div> 
  <div>
    } 
  </div> 
 </div> 
 <div>
   反汇编： 
 </div> 
 <div> 
  <img src="https://images2.imgbox.com/8d/b5/1GhVvLWR_o.png" alt=""> 
 </div> 
 <div>
     
 </div> 
 <div>
   3.带*的类型求值（解引用） 
 </div> 
 <div>
   1）*运算结果的类型 
 </div> 
 <div>
   带*的类型的变量，面加*运算符后所得的值的类型： 
 </div> 
 <div> 
  <div>
    int* px;         
  </div> 
  <div>
    int** px2;         
  </div> 
  <div>
    int*** px3;         
  </div> 
  <div>
    int**** px4;         
  </div> 
  <div>
             
  </div> 
  <div>
    //*(px) 是什么类型?     -&gt;int        
  </div> 
  <div>
    //*(px2) 是什么类型?    -&gt;int*         
  </div> 
  <div>
    //*(px3) 是什么类型?    -&gt;int**         
  </div> 
  <div>
    //*(px4) 是什么类型?    -&gt;int*** 
  </div> 
 </div> 
 <div>
   也就是说：*a的值的类型是a去掉一个*后的类型； 
 </div> 
 <div>
   只有带*的类型才能用*运算； 
 </div> 
 <div>
     
 </div> 
 <div>
   2）*运算结果的值 
 </div> 
 <div>
   例如： 
 </div> 
 <div> 
  <div>
    void fun()     
  </div> 
  <div>
    {    
  </div> 
  <div>
        int x = 1; 
  </div> 
  <div>
        int* y = &amp;x; 
  </div> 
  <div>
        int** z = &amp;y; 
  </div> 
  <div>
         
  </div> 
  <div>
        int r = *(*(z)); 
  </div> 
  <div>
    } 
  </div> 
 </div> 
 <div>
   反汇编： 
 </div> 
 <div> 
  <img src="https://images2.imgbox.com/3c/91/rC1iipLg_o.png" alt=""> 
 </div> 
 <div>
   可以看出来：*运算符的反汇编是用带*变量的值来寻址，找到的值即为结果； 
 </div> 
 <div>
     
 </div> 
 <div>
   总结：                             
 </div> 
 <div>
       1、带*类型的变量，可以通过在其变量前加*来获取其指向内存中存储的值.                             
 </div> 
 <div>
       2、在带*类型的变量前面加*，类型是其原来的类型减去一个*. 
 </div> 
 <div>
     
 </div> 
 <div>
   4.用指针操作数组 
 </div> 
 <div>
   取数组第一个元素的地址： 
 </div> 
 <div> 
  <div>
    char arr[10];             
  </div> 
  <div>
                 
  </div> 
  <div>
    char* p = &amp;arr[0]; //取数组第一个元素的地址             
  </div> 
  <div>
    char* p2 = arr;    //简写 
  </div> 
 </div> 
 <div>
   也就是说，数组变量名就是数组第一个元素的地址； 
 </div> 
 <div>
     
 </div> 
 <div>
   因为带*类型变量 + N  =  带*类型变量 + N*(去掉一个*后类型的宽度)  ， 
 </div> 
 <div>
   利用这一特点可以用来操作数组： 
 </div> 
 <div> 
  <img src="https://images2.imgbox.com/52/87/vuKhTarO_o.png" alt=""> 
 </div> 
 <div>
     
 </div> 
 <div>
   原理： 
 </div> 
 <div>
   char* p = (char*)10; 
 </div> 
 <div>
   p+1 = 11; 
 </div> 
 <div> 
  <img src="https://images2.imgbox.com/fd/a3/YgKkM9za_o.png" alt=""> 
 </div> 
 <div>
     
 </div> 
 <div>
   short* p = (short*)10; 
 </div> 
 <div>
   p+1 = 12; 
 </div> 
 <div> 
  <img src="https://images2.imgbox.com/a0/41/8pkB6lIT_o.png" alt=""> 
 </div> 
 <div>
     
 </div> 
 <div>
     
 </div> 
 <div>
   总结：                         
 </div> 
 <div>
       1、&amp;arr[0]代表取数组中第一个元素的地址，可以省略为数组名.                         
 </div> 
 <div>
       2、*(p+i) = p[i] 
 </div> 
 <div>
     
 </div> 
 <div>
     
 </div> 
 <div>
     
 </div> 
</div> 
<p>转载于:https://www.cnblogs.com/ShiningArmor/p/11596219.html</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/04f21b8144b8d16b60343d6165b95869/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">指针01</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c81d47f8fded3f0f22e07b968e04c3d4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Vue实现仿iPhone悬浮球</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>