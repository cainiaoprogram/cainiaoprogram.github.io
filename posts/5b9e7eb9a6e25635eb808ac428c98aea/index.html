<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>闭包，看这一篇就够了——带你看透闭包的本质，百发百中 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="闭包，看这一篇就够了——带你看透闭包的本质，百发百中" />
<meta property="og:description" content="1、概念 闭包函数：声明在一个函数中的函数，叫做闭包函数。
闭包：内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。
2、特点 让外部访问函数内部变量成为可能；
局部变量会常驻在内存中；
可以避免使用全局变量，防止全局变量污染；
会造成内存泄漏（有一块内存空间被长期占用，而不被释放）
3、闭包的创建：­­­ 闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。闭包会发生内存泄漏，每次外部函数执行的时 候，外部函数的引用地址不同，都会重新创建一个新的地址。但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。
闭包内存泄漏为： key = value，key 被删除了 value 常驻内存中; 局部变量闭包升级版（中间引用的变量） =&gt; 自由变量；
上面的都是什么鬼，是人话么，能看懂早就看懂了，生气······
不过，答应我，看完例子再回看上面的概念，会理解的更！透！彻！
---------------------------------------------我是容易看懂的分界线----------------------------------------------- 4、闭包的应用场景 结论：闭包找到的是同一地址中父级函数中对应变量最终的值 最终秘诀就这一句话，每个例子请自行带入这个结论！！！！！！！！！！！！！
/* 例子1 */
function funA(){ var a = 10; // funA的活动对象之中; return function(){ //匿名函数的活动对象; alert(a); } } var b = funA(); b(); //10 /* 例子2 */
function outerFn(){ var i = 0; function innerFn(){ i&#43;&#43;; console.log(i); } return innerFn; } var inner = outerFn(); //每次外部函数执行的时候,都会开辟一块内存空间,外部函数的地址不同，都会重新创建一个新的地址 inner(); inner(); inner(); var inner2 = outerFn(); inner2(); inner2(); inner2(); //1 2 3 1 2 3 /* 例子3 */" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/5b9e7eb9a6e25635eb808ac428c98aea/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-04-22T17:36:35+08:00" />
<meta property="article:modified_time" content="2019-04-22T17:36:35+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">闭包，看这一篇就够了——带你看透闭包的本质，百发百中</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h4>1、概念</h4> 
<p><strong>闭包函数：</strong>声明在一个函数中的函数，叫做闭包函数。</p> 
<p><strong>闭包：</strong>内部函数总是可以访问其所在的外部函数中声明的参数和变量，即使在其外部函数被返回（寿命终结）了之后。</p> 
<h4>2、特点</h4> 
<p style="margin-left:0cm;"><span style="color:#ff0000;">  让外部访问函数内部变量成为可能；</span></p> 
<p style="margin-left:0cm;"><span style="color:#ff0000;">  局部变量会常驻在内存中；</span></p> 
<p style="margin-left:0cm;"><span style="color:#ff0000;">  可以避免使用全局变量，防止全局变量污染；</span></p> 
<p style="margin-left:0cm;"><span style="color:#ff0000;">  会造成内存泄漏（有一块内存空间被长期占用，而不被释放）</span></p> 
<h4 style="margin-left:0cm;">3、<strong>闭包的创建：</strong>­­­</h4> 
<p style="margin-left:0cm;">闭包就是可以创建一个独立的环境，每个闭包里面的环境都是独立的，互不干扰。闭包会发生内存泄漏，<strong><span style="color:#ff0000;">每次外部函数执行的时 候，外部函数的引用地址不同，都会重新创建一个新的地址。</span></strong><span style="color:#000000;">但凡是当前活动对象中有被内部子集引用的数据，那么这个时候，这个数据不删除，保留一根指针给内部活动对象。</span></p> 
<p style="margin-left:0cm;">闭包内存泄漏为： key = value，key 被删除了 value 常驻内存中; 局部变量闭包升级版（中间引用的变量） =&gt; 自由变量；</p> 
<p style="margin-left:0cm;"> </p> 
<p style="margin-left:0cm;">上面的都是什么鬼，是人话么，能看懂早就看懂了，生气······</p> 
<p style="margin-left:0cm;">不过，答应我，看完例子再回看上面的概念，会理解的更！透！彻！</p> 
<h4 style="margin-left:0cm;">---------------------------------------------我是容易看懂的分界线-----------------------------------------------</h4> 
<h4 style="margin-left:0cm;"><strong>4、闭包的应用场景</strong></h4> 
<h2><u><span style="color:#e579b6;"><strong>结论：</strong><strong>闭包找到的是同一地址中父级函数中对应变量最终的值</strong></span></u></h2> 
<p><u><span style="color:#e579b6;"><strong>最终秘诀就这一句话，每个例子请自行带入这个结论！！！！！！！！！！！！！</strong></span></u></p> 
<p><span style="color:#f33b45;"><strong>/* 例子1 */</strong></span></p> 
<pre class="has"><code class="language-javascript">function funA(){
  var a = 10;  // funA的活动对象之中;
  return function(){   //匿名函数的活动对象;
        alert(a);
  }
}
var b = funA();
b();  //10
</code></pre> 
<p><span style="color:#f33b45;"><strong>/* 例子2 */</strong></span></p> 
<pre class="has"><code class="language-javascript">function outerFn(){
  var i = 0; 
  function innerFn(){
      i++;
      console.log(i);
  }
  return innerFn;
}
var inner = outerFn();  //每次外部函数执行的时候,都会开辟一块内存空间,外部函数的地址不同，都会重新创建一个新的地址
inner();
inner();
inner();
var inner2 = outerFn();
inner2();
inner2();
inner2();   //1 2 3 1 2 3
</code></pre> 
<p><span style="color:#f33b45;"><strong>/* 例子3 */</strong></span></p> 
<pre class="has"><code class="language-javascript">var i = 0;
function outerFn(){
  function innnerFn(){
       i++;
       console.log(i);
  }
  return innnerFn;
}
var inner1 = outerFn();
var inner2 = outerFn();
inner1();
inner2();
inner1();
inner2();     //1 2 3 4
</code></pre> 
<p><span style="color:#f33b45;"><strong>/* 例子4 */</strong></span></p> 
<pre class="has"><code class="language-javascript">function fn(){
	var a = 3;
	return function(){
		return  ++a;                                     
	}
}
alert(fn()());  //4
alert(fn()());  //4    
</code></pre> 
<p><span style="color:#f33b45;"><strong>/* 例子5 */</strong></span></p> 
<pre class="has"><code class="language-javascript">function outerFn(){
var i = 0;
  function innnerFn(){
      i++;
      console.log(i);
  }
  return innnerFn;
}
var inner1 = outerFn();
var inner2 = outerFn();
inner1();
inner2();
inner1();
inner2();    //1 1 2 2
</code></pre> 
<p><span style="color:#f33b45;"><strong>/* 例子6 */</strong></span></p> 
<pre class="has"><code class="language-javascript">(function() { 
  var m = 0; 
  function getM() { return m; } 
  function seta(val) { m = val; } 
  window.g = getM; 
  window.f = seta; 
})(); 
f(100);
console.info(g());   //100  闭包找到的是同一地址中父级函数中对应变量最终的值
</code></pre> 
<p><span style="color:#f33b45;"><strong>/* 例子7 */</strong></span></p> 
<pre class="has"><code class="language-javascript">function a() { 
  var i = 0; 
  function b() { alert(++i); } 
  return b; 
} 
var c = a(); 
c();      //1 
c();      //2 
</code></pre> 
<p><span style="color:#f33b45;"><strong>/* 例子8 */</strong></span></p> 
<pre class="has"><code class="language-javascript">function f() { 
  var count = 0; 
  return  function() { 
      count++; 
      console.info(count); 
  } 
} 
var t1 = f();
t1();     //1 
t1();     //2 
t1();     //3 
</code></pre> 
<p><span style="color:#f33b45;"><strong>/* 例子9 */</strong></span></p> 
<pre class="has"><code class="language-javascript">var add = function(x) { 
  var sum = 1; 
  var tmp = function(x) { 
      sum = sum + x; 
      return tmp;    
  } 
  tmp.toString = function() { 
      return sum; 
  }
  return tmp; 
} 
alert(add(1)(2)(3));     //6
</code></pre> 
<p><span style="color:#f33b45;"><strong>/* 例子10 */</strong></span></p> 
<pre class="has"><code class="language-javascript">var lis = document.getElementsByTagName("li");
for(var i=0;i&lt;lis.length;i++){
  (function(i){
      lis[i].onclick = function(){
           console.log(i);
      };
  })(i);       //事件处理函数中闭包的写法
}  
</code></pre> 
<p><span style="color:#f33b45;"><strong>/* 例子11 */</strong></span></p> 
<pre class="has"><code class="language-javascript">function m1(){
     var x = 1;
     return function(){
          console.log(++x);
     }
}

m1()();   //2
m1()();   //2
m1()();   //2

var m2 = m1();
m2();   //2
m2();   //3
m2();   //4
</code></pre> 
<p><span style="color:#f33b45;"><strong>/* 例子12 */</strong></span></p> 
<pre class="has"><code class="language-javascript">var  fn=(function(){
   var  i=10;
   function  fn(){
      console.log(++i);
   }
   return   fn;
})() 
fn();   //11
fn();   //12
</code></pre> 
<p><span style="color:#f33b45;"><strong>/* 例子13 */</strong></span></p> 
<pre class="has"><code class="language-javascript">function love1(){
     var num = 223;
     var me1 = function() {
           console.log(num);
     }
     num++;
     return me1;
}
var loveme1 = love1();
loveme1();   //输出224
</code></pre> 
<p><span style="color:#f33b45;"><strong>/* 例子14 */</strong></span></p> 
<pre class="has"><code class="language-javascript">function fun(n,o) {
    console.log(o);
    return {
         fun:function(m) {
               return fun(m,n);
         }
    };
}
var a = fun(0);  //undefined
a.fun(1);  //0  
a.fun(2);  //0  
a.fun(3);  //0  
var b = fun(0).fun(1).fun(2).fun(3);   //undefined  0  1  2
var c = fun(0).fun(1);  
c.fun(2);  
c.fun(3);  //undefined  0  1  1
</code></pre> 
<p><span style="color:#f33b45;"><strong>/* 例子15 */</strong></span></p> 
<pre class="has"><code class="language-javascript">function fn(){
   var arr = [];
   for(var i = 0;i &lt; 5;i ++){
	 arr[i] = function(){
		 return i;
	 }
   }
   return arr;
}
var list = fn();
for(var i = 0,len = list.length;i &lt; len ; i ++){
   console.log(list[i]());
}  //5 5 5 5 5
</code></pre> 
<p><span style="color:#f33b45;"><strong>/* 例子16 */</strong></span></p> 
<pre class="has"><code class="language-javascript">function fn(){
  var arr = [];
  for(var i = 0;i &lt; 5;i ++){
	arr[i] = (function(i){
		return function (){
			return i;
		};
	})(i);
  }
  return arr;
}
var list = fn();
for(var i = 0,len = list.length;i &lt; len ; i ++){
  console.log(list[i]());
}  //0 1 2 3 4
</code></pre> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/d2e532ab89e93de2ef4f3498e846d7ad/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">xtrabackup备份原理解析</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/55655e6e5f55ee64fa8cdf7881d7ccf1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">卷积神经网络概念与原理</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>