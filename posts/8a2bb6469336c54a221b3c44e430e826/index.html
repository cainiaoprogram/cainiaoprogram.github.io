<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Spring循环依赖的三种方式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Spring循环依赖的三种方式" />
<meta property="og:description" content="引言：循环依赖就是N个类中循环嵌套引用，如果在日常开发中我们用new 对象的方式发生这种循环依赖的话程序会在运行时一直循环调用，直至内存溢出报错。下面说一下Spring是如果解决循环依赖的。
第一种：构造器参数循环依赖 Spring容器会将每一个正在创建的Bean 标识符放在一个“当前创建Bean池”中，Bean标识符在创建过程中将一直保持
在这个池中，因此如果在创建Bean过程中发现自己已经在“当前创建Bean池”里时将抛出
BeanCurrentlyInCreationException异常表示循环依赖；而对于创建完毕的Bean将从“当前创建Bean池”中清除掉。
首先我们先初始化三个Bean。
public class StudentA { private StudentB studentB ; public void setStudentB(StudentB studentB) { this.studentB = studentB; } public StudentA() { } public StudentA(StudentB studentB) { this.studentB = studentB; } } public class StudentB { private StudentC studentC ; public void setStudentC(StudentC studentC) { this.studentC = studentC; } public StudentB() { } public StudentB(StudentC studentC) { this.studentC = studentC; } } public class StudentC { private StudentA studentA ; public void setStudentA(StudentA studentA) { this." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/8a2bb6469336c54a221b3c44e430e826/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-03-01T15:46:16+08:00" />
<meta property="article:modified_time" content="2017-03-01T15:46:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Spring循环依赖的三种方式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><br> </p> 
<p>       <strong>   引言：循环依赖就是N个类中循环嵌套引用，如果在日常开发中我们用new 对象的方式发生这种循环依赖的话程序会在运行时一直循环调用，直至内存溢出报错。下面说一下Spring是如果解决循环依赖的。</strong></p> 
<p><br> </p> 
<h3>第一种：构造器参数循环依赖</h3> 
<p><br> </p> 
<p><br> </p> 
<p><span style="font-family:MicrosoftYaHei; color:#000000; font-size:10pt; font-style:normal; font-variant:normal">Spring容器会将每一个正在创建的Bean 标识符放在一个“当前创建Bean池”中，Bean标识符在创建过程中将一直保持<br> <span style="font-family:MicrosoftYaHei; color:#000000; font-size:10pt; font-style:normal; font-variant:normal">在这个池中，因此如果在创建Bean过程中发现自己已经在“当前创建Bean池”里时将抛出<br> <span style="font-family:MicrosoftYaHei; color:#000000; font-size:10pt; font-style:normal; font-variant:normal">BeanCurrentlyInCreationException异常表示循环依赖；而对于创建完毕的Bean将从“当前创建Bean池”中清除掉。</span></span></span><br> </p> 
<p><br> </p> 
<p>首先我们先初始化三个Bean。</p> 
<pre><code class="language-java">public class StudentA {

    private StudentB studentB ;

    public void setStudentB(StudentB studentB) {
        this.studentB = studentB;
    }

    public StudentA() {
    }
    
    public StudentA(StudentB studentB) {
        this.studentB = studentB;
    }
}</code></pre> 
<br> 
<pre><code class="language-java">public class StudentB {

    private StudentC studentC ;

    public void setStudentC(StudentC studentC) {
        this.studentC = studentC;
    }
    
    public StudentB() {
    }

    public StudentB(StudentC studentC) {
        this.studentC = studentC;
    }
}</code></pre> 
<pre><code class="language-java">public class StudentC {

    private StudentA studentA ;

    public void setStudentA(StudentA studentA) {
        this.studentA = studentA;
    }

    public StudentC() {
    }
 
    public StudentC(StudentA studentA) {
        this.studentA = studentA;
    }
}</code></pre> 
<br> OK，上面是很基本的3个类，，StudentA有参构造是StudentB。StudentB的有参构造是StudentC，StudentC的有参构造是StudentA ，这样就产生了一个循环依赖的情况， 
<p></p> 
<p>我们都把这三个Bean交给Spring管理，并用有参构造实例化</p> 
<p></p> 
<pre><code class="language-html"> &lt;bean id="a" class="com.zfx.student.StudentA"&gt;
		&lt;constructor-arg index="0" ref="b"&gt;&lt;/constructor-arg&gt;
	&lt;/bean&gt;
	&lt;bean id="b" class="com.zfx.student.StudentB"&gt;
		&lt;constructor-arg index="0" ref="c"&gt;&lt;/constructor-arg&gt;
	&lt;/bean&gt;
	&lt;bean id="c" class="com.zfx.student.StudentC"&gt;
		&lt;constructor-arg index="0" ref="a"&gt;&lt;/constructor-arg&gt;
	&lt;/bean&gt; </code></pre> 
<p></p> 
<p>下面是测试类：</p> 
<p></p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("com/zfx/student/applicationContext.xml");
        //System.out.println(context.getBean("a", StudentA.class));
    }
}</code></pre> 
<br> 执行结果报错信息为： 
<p></p> 
<p></p> 
<pre><code class="language-java">Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: 
	Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference?</code></pre> 
<br> 
<br> 
<p></p> 
<p></p> 
<p>如果大家理解开头那句话的话，这个报错应该不惊讶，Spring容器先创建单例StudentA，StudentA依赖StudentB，然后将A放在<span style="font-family:MicrosoftYaHei; color:#000000; font-size:10pt; font-style:normal; font-variant:normal"><span style="font-family:MicrosoftYaHei; color:#000000; font-size:10pt; font-style:normal; font-variant:normal">“当前创建Bean池”</span></span>中，<span style="font-family:MicrosoftYaHei">此时创建StudentB,StudentB依赖StudentC ,然后将B放在<span style="font-family:MicrosoftYaHei; color:#000000; font-size:10pt; font-style:normal; font-variant:normal"><span style="font-family:MicrosoftYaHei; color:#000000; font-size:10pt; font-style:normal; font-variant:normal">“当前创建Bean池”</span></span>中,此时创建StudentC，StudentC又依赖StudentA， 但是，此时Student已经在池中，所以会报错，，<span style="color:#FF0000">因为在池中的Bean都是未初始化完的，所以会依赖错误 ，（初始化完的Bean会从池中移除）</span></span></p> 
<p><span style="font-family:MicrosoftYaHei"><span style="color:#FF0000"><br> </span></span></p> 
<h3><strong>第二种：setter方式单例，默认方式</strong></h3> 
<p><br> </p> 
<p><br> </p> 
<p>如果要说setter方式注入的话，我们最好先看一张Spring中Bean实例化的图</p> 
<p><img src="https://images2.imgbox.com/4f/3c/4Xvxx5zz_o.jpg" alt=""></p> 
<p><br> </p> 
<p>如图中前两步骤得知：<strong><span style="color:#FF0000">Spring是先将Bean对象实例化之后再设置对象属性的</span></strong></p> 
<p><strong><span style="color:#FF0000"><br> </span></strong></p> 
<p>修改配置文件为set方式注入<br> </p> 
<p></p> 
<pre><code class="language-html">	&lt;!--scope="singleton"(默认就是单例方式)  --&gt;
	&lt;bean id="a" class="com.zfx.student.StudentA" scope="singleton"&gt;
		&lt;property name="studentB" ref="b"&gt;&lt;/property&gt;
	&lt;/bean&gt;
	&lt;bean id="b" class="com.zfx.student.StudentB" scope="singleton"&gt;
		&lt;property name="studentC" ref="c"&gt;&lt;/property&gt;
	&lt;/bean&gt;
	&lt;bean id="c" class="com.zfx.student.StudentC" scope="singleton"&gt;
		&lt;property name="studentA" ref="a"&gt;&lt;/property&gt;
	&lt;/bean&gt;</code></pre> 
<br> 下面是测试类： 
<p></p> 
<p></p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("com/zfx/student/applicationContext.xml");
        System.out.println(context.getBean("a", StudentA.class));
    }
}</code></pre> 
<br> 打印结果为： 
<p></p> 
<p></p> 
<pre><code class="language-java">com.zfx.student.StudentA@1fbfd6</code></pre> 
<br> 为什么用set方式就不报错了呢 ？ 
<p></p> 
<p><strong>    我们结合上面那张图看，Spring先是用构造实例化Bean对象 ，此时Spring会将这个实例化结束的对象放到一个Map中，并且Spring提供了获取这个未设置属性的实例化对象引用的方法。   结合我们的实例来看，，当Spring实例化了StudentA、StudentB、StudentC后，紧接着会去设置对象的属性，此时StudentA依赖StudentB，就会去Map中取出存在里面的单例StudentB对象，以此类推，不会出来循环的问题喽、</strong></p> 
<p><strong><br> </strong></p> 
<p>下面是Spring源码中的实现方法，。以下的源码在Spring的Bean包中的<strong><span style="color:#FF0000">DefaultSingletonBeanRegistry</span>.java</strong>类中</p> 
<p></p> 
<pre><code class="language-java">/** Cache of singleton objects: bean name --&gt; bean instance（缓存单例实例化对象的Map集合） */
	private final Map&lt;String, Object&gt; singletonObjects = new ConcurrentHashMap&lt;String, Object&gt;(64);
	
	/** Cache of singleton factories: bean name --&gt; ObjectFactory（单例的工厂Bean缓存集合） */
	private final Map&lt;String, ObjectFactory&gt; singletonFactories = new HashMap&lt;String, ObjectFactory&gt;(16);
	
	/** Cache of early singleton objects: bean name --&gt; bean instance（早期的单身对象缓存集合） */
	private final Map&lt;String, Object&gt; earlySingletonObjects = new HashMap&lt;String, Object&gt;(16);
	
	/** Set of registered singletons, containing the bean names in registration order（单例的实例化对象名称集合） */
	private final Set&lt;String&gt; registeredSingletons = new LinkedHashSet&lt;String&gt;(64);
	/**
	 * 添加单例实例
	 * 解决循环引用的问题
	 * Add the given singleton factory for building the specified singleton
	 * if necessary.
	 * &lt;p&gt;To be called for eager registration of singletons, e.g. to be able to
	 * resolve circular references.
	 * @param beanName the name of the bean
	 * @param singletonFactory the factory for the singleton object
	 */
	protected void addSingletonFactory(String beanName, ObjectFactory singletonFactory) {
		Assert.notNull(singletonFactory, "Singleton factory must not be null");
		synchronized (this.singletonObjects) {
			if (!this.singletonObjects.containsKey(beanName)) {
				this.singletonFactories.put(beanName, singletonFactory);
				this.earlySingletonObjects.remove(beanName);
				this.registeredSingletons.add(beanName);
			}
		}
	}</code></pre> 
<br> 
<br> 
<p></p> 
<p></p> 
<h3><strong>第三种：setter方式原型，prototype</strong></h3> 
<p></p> 
<p><br> </p> 
<p>修改配置文件为：</p> 
<p></p> 
<pre><code class="language-html">&lt;bean id="a" class="com.zfx.student.StudentA" <span style="color:#FF0000;">scope="prototype"</span>&gt;
		&lt;property name="studentB" ref="b"&gt;&lt;/property&gt;
	&lt;/bean&gt;
	&lt;bean id="b" class="com.zfx.student.StudentB" <span style="color:#FF0000;">scope="prototype"</span>&gt;
		&lt;property name="studentC" ref="c"&gt;&lt;/property&gt;
	&lt;/bean&gt;
	&lt;bean id="c" class="com.zfx.student.StudentC" <span style="color:#FF0000;">scope="prototype"</span>&gt;
		&lt;property name="studentA" ref="a"&gt;&lt;/property&gt;
	&lt;/bean&gt;</code></pre> 
<br> 
<span style="color:#FF0000">scope="prototype" 意思是 每次请求都会创建一个实例对象。两者的区别是：有状态的bean都使用Prototype作用域，无状态的一般都使用singleton单例作用域。</span> 
<p></p> 
<p>测试用例：</p> 
<p></p> 
<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        ApplicationContext context = new ClassPathXmlApplicationContext("com/zfx/student/applicationContext.xml");
        <strong>//此时必须要获取Spring管理的实例，因为现在scope="prototype" 只有请求获取的时候才会实例化对象</strong>
        System.out.println(context.getBean("a", StudentA.class));
    }
}</code></pre> 
<p></p> 
<p>打印结果：</p> 
<p></p> 
<pre><code class="language-java">Caused by: org.springframework.beans.factory.BeanCurrentlyInCreationException: 
	Error creating bean with name 'a': Requested bean is currently in creation: Is there an unresolvable circular reference?</code></pre> 
<br> 为什么原型模式就报错了呢 ？ 
<p></p> 
<p><span style="color:#FF0000"><strong><span style="font-family:MicrosoftYaHei; font-size:10pt; font-style:normal; font-variant:normal">对于“prototype”作用域Bean，Spring容器无法完成依赖注入，因为“prototype”作用域的Bean，Spring容<br> <span style="font-family:MicrosoftYaHei; font-size:10pt; font-style:normal; font-variant:normal">器不进行缓存，因此无法提前暴露一个创建中的Bean。</span></span></strong></span><br> </p> 
<p><br> <br> </p> 
<p><br> </p> 
<br> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/b350b0df7c460b72c241c4126fae22c9/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">windows环境下用c&#43;&#43;实现socket编程</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/47ad417a177db55a6b34e4cc7acc3d2f/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">bootstrap下拉菜单无效的解决方法之一</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>