<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>k8s的集群调度 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="k8s的集群调度" />
<meta property="og:description" content="k8s的集群调度： scheduler：负责调度资源，把pod调度到node节点。
预算策略
优选策略
1、List-watch k8s集群当中，通过list-watch的机制进行每个组件的协作，保存数据同步。每个组件之间的解耦。
kubectl配置文件，向APIserver发送命令-------apiserver把命令发送给各个组件。
kubectl run nginx --image=nginx:1.22-----------apiserver--------controller manager---------scheduler------------------------kubelet.
创建完成之后，kubelet get pod kubectl describe pod nginx--------------------&gt;etcd的数据库当中。
监听：
list-watch------会在每一步把监听的消息（APIserver:6443）-------------controller manager，schedule，kubelet，etcd都会监听
apiserver:6443端口来监听
如何来把pod分配到node.
2、调度的过程和策略： schedule是k8s集群的调度器，把pod分配搭配集群的节点。
有以下几个问题：
1、公平，每个节点都能够分配到资源
2、资源高效利用：集群当中的每个资源都可以被最大化使用
3、效率：调度的性能要好，能够尽快的完成大批量的pod的调度工作
4、灵活：允许用户根据自己的需求，控制和改变调度的逻辑。
schedule是一个单独运行的程序，启动之后就会一直监听APIserver，获取报文中的字段：spec.nodeName
创建pod的时候，为每个pod创建一个binding，表示该往哪个节点上部署。
创建pod节点时，有两个策略，先执行预算策略，再执行优选策略：这两步的操作都必须成功，否则立刻返回报错。
也就是说，部署的node，必须满足这两个策略。
预算策略： predicate自带一些算法，选择node节点（schedule自带的算法策略，不需要人工干预）
1、podfitsresources：pod适应资源，检查节点上的剩余资源是否满足pod请求的资源。主要是cpu和内存。
2、podfitshost：适应主机，如果pod指定了node的name，nginx1 pod------&gt;node01，检测主机名是否存在，存在要和pod指定的名称匹配。这样才能调度过去。
3、podselectormatches：pod选择器匹配，创建pod的时候可以根据node的标签来进行匹配。查找
指定的node节点上的标签是否存在，存在的标签是否匹配。
4、nodiskconflict：无磁盘冲突，确保已挂载的卷于pod的卷不发生冲突，除非目录是只读，就会覆盖。
node1
nginx1 pod /opt/nginx1
nginx2 pod /opt/nginx1
冲突了，会看node2上有没有，然后部署在node2节点上。
如果预算策略都不满足，pod将始终处于pending的状态，不断的重试调度，直到有节点满足条件为止。
若node1 node2 node3
经过预算策略，上述三个节点都满足条件，那该怎么办？------&gt;进行优选。
优选策略： leastrequestedpriority：最低请求优先级，通过算法计算节点上的cpu和内存使用率，确定节点的权重。
使用率低的节点相应的权重越高。调度时会更倾向使用率低的节点，实现资源合理的理由。
balanceresourceallocation：平衡资源分配，算cpu和内存的使用率，给节点赋予权重。权重算的是cpu和内存使用率接近。权重越高。
和上面的leastrequestedpriority最低请求优先级一起使用。
node1 cpu和内存使用率：20:60
node2 cpu和内存的使用率：50:50
node2在被调度时会被优先。
imagelocalitypriority：节点上是否已经有了要部署的镜像。镜像的总数成正比，满足的镜像数越多，权重越高。
nginx1.22
node1 无" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/95f90c8a28f581f2d099b68b83c6412c/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-08T17:40:44+08:00" />
<meta property="article:modified_time" content="2024-01-08T17:40:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">k8s的集群调度</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <h2>k8s的集群调度：</h2> 
<p>scheduler：负责调度资源，把pod调度到node节点。</p> 
<p>预算策略</p> 
<p>优选策略</p> 
<p></p> 
<h2>1、List-watch</h2> 
<p>k8s集群当中，通过list-watch的机制进行每个组件的协作，保存数据同步。每个组件之间的解耦。</p> 
<p>kubectl配置文件，向APIserver发送命令-------apiserver把命令发送给各个组件。</p> 
<p>kubectl run nginx --image=nginx:1.22-----------apiserver--------controller manager---------scheduler------------------------kubelet.</p> 
<p>创建完成之后，kubelet get pod kubectl describe pod nginx--------------------&gt;etcd的数据库当中。</p> 
<p><img alt="" height="1041" src="https://images2.imgbox.com/e2/7a/tPzyqjql_o.png" width="1200"></p> 
<p>监听：</p> 
<p>list-watch------会在每一步把监听的消息（APIserver:6443）-------------controller manager，schedule，kubelet，etcd都会监听</p> 
<p>apiserver:6443端口来监听</p> 
<p></p> 
<p>如何来把pod分配到node.</p> 
<h2>2、调度的过程和策略：</h2> 
<p>schedule是k8s集群的调度器，把pod分配搭配集群的节点。</p> 
<p>有以下几个问题：</p> 
<p>1、公平，每个节点都能够分配到资源</p> 
<p>2、资源高效利用：集群当中的每个资源都可以被最大化使用</p> 
<p>3、效率：调度的性能要好，能够尽快的完成大批量的pod的调度工作</p> 
<p>4、灵活：允许用户根据自己的需求，控制和改变调度的逻辑。</p> 
<p></p> 
<p>schedule是一个单独运行的程序，启动之后就会一直监听APIserver，获取报文中的字段：spec.nodeName</p> 
<p>创建pod的时候，为每个pod创建一个binding，表示该往哪个节点上部署。</p> 
<p>创建pod节点时，有两个策略，先执行预算策略，再执行优选策略：这两步的操作都必须成功，否则立刻返回报错。</p> 
<p>也就是说，部署的node，必须满足这两个策略。</p> 
<h3>预算策略：</h3> 
<p>predicate自带一些算法，选择node节点（schedule自带的算法策略，不需要人工干预）</p> 
<p>1、podfitsresources：pod适应资源，检查节点上的剩余资源是否满足pod请求的资源。主要是cpu和内存。</p> 
<p>2、podfitshost：适应主机，如果pod指定了node的name，nginx1 pod------&gt;node01，检测主机名是否存在，存在要和pod指定的名称匹配。这样才能调度过去。</p> 
<p>3、podselectormatches：pod选择器匹配，创建pod的时候可以根据node的标签来进行匹配。查找</p> 
<p>指定的node节点上的标签是否存在，存在的标签是否匹配。</p> 
<p>4、nodiskconflict：无磁盘冲突，确保已挂载的卷于pod的卷不发生冲突，除非目录是只读，就会覆盖。</p> 
<p>node1</p> 
<p>nginx1 pod /opt/nginx1</p> 
<p>nginx2 pod /opt/nginx1</p> 
<p>冲突了，会看node2上有没有，然后部署在node2节点上。</p> 
<p>如果预算策略都不满足，pod将始终处于pending的状态，不断的重试调度，直到有节点满足条件为止。</p> 
<p>若node1 node2 node3</p> 
<p>经过预算策略，上述三个节点都满足条件，那该怎么办？------&gt;进行优选。</p> 
<p></p> 
<h3>优选策略：</h3> 
<p>leastrequestedpriority：最低请求优先级，通过算法计算节点上的cpu和内存使用率，确定节点的权重。</p> 
<p>使用率低的节点相应的权重越高。调度时会更倾向使用率低的节点，实现资源合理的理由。</p> 
<p>balanceresourceallocation：平衡资源分配，算cpu和内存的使用率，给节点赋予权重。权重算的是cpu和内存使用率接近。权重越高。</p> 
<p>和上面的leastrequestedpriority最低请求优先级一起使用。</p> 
<p>node1 cpu和内存使用率：20:60</p> 
<p>node2 cpu和内存的使用率：50:50</p> 
<p>node2在被调度时会被优先。</p> 
<p>imagelocalitypriority：节点上是否已经有了要部署的镜像。镜像的总数成正比，满足的镜像数越多，权重越高。</p> 
<p>nginx1.22</p> 
<p>node1 无</p> 
<p>node2 有</p> 
<p>以上这些策略schedule自带的算法。</p> 
<p>通过预算选择出可以部署的节点，再通过优先选择出来最好的节点。以上都是自带的算法。k8s集群自己来选择。</p> 
<p><strong>指定节点：</strong></p> 
<p>spec参数设置：</p> 
<p>nodeName：node02（node节点的名称）</p> 
<p><strong>注：如果指定了节点，在参数中设置了nodeName，指定了节点的名称，会跳过scheduler的调度</strong></p> 
<p><strong>策略，这个规则是强制匹配。（不走调度算法）</strong></p> 
<p><img alt="" height="556" src="https://images2.imgbox.com/28/43/IkmPjGWZ_o.png" width="609"></p> 
<p><img alt="" height="770" src="https://images2.imgbox.com/2d/75/csOWIiRt_o.png" width="849"></p> 
<p><img alt="" height="331" src="https://images2.imgbox.com/81/e2/ogN6QSmq_o.png" width="856"></p> 
<p></p> 
<h4><strong>指定标签：</strong></h4> 
<p>spec</p> 
<p>nodeSelector：</p> 
<h4>自定义标签</h4> 
<p>kubectl label nodes master01 test1=a</p> 
<p>kubectl label nodes node01 test2=b</p> 
<p>kubectl label nodes node01 test3=c</p> 
<p>查看标签：</p> 
<p>12:02</p> 
<p>kubectl get nodes --show-labels</p> 
<p><img alt="" height="435" src="https://images2.imgbox.com/f9/57/h4AsJYnj_o.png" width="1139"></p> 
<p></p> 
<p>选择标签</p> 
<p><img alt="" height="496" src="https://images2.imgbox.com/38/35/AQMNsHv6_o.png" width="385"></p> 
<p><img alt="" height="625" src="https://images2.imgbox.com/e3/cd/LK6xbA0X_o.png" width="852"></p> 
<p><img alt="" height="505" src="https://images2.imgbox.com/59/6e/0sZn7na7_o.png" width="1122"></p> 
<p><img alt="" height="231" src="https://images2.imgbox.com/09/7c/ZU9XH5GF_o.png" width="1139"></p> 
<p><strong>注：指定节点标签部署pod，是要经过scheduler的算法，如果节点不满足条件，pod会进入pending状态，直到节点满足条件为止。</strong></p> 
<p></p> 
<h2><strong>亲和性：</strong></h2> 
<p><strong>node节点亲和性</strong></p> 
<p><strong>pod亲和性</strong></p> 
<p><strong>软策略和硬策略</strong></p> 
<h3><strong>node节点的亲和性：</strong></h3> 
<h3 style="background-color:transparent;">preferredDuringSchedulingIgnoredDuringExecution软策略：</h3> 
<p><strong>选择node节点时，我声明了我最好能部署在node01，软策略会尽量满足这个条件。不一定会完全部署在node01节点上。</strong></p> 
<p></p> 
<h3><strong>requiredDuringSchedulingIgnoredDuringExecution硬策略：</strong></h3> 
<p><strong>选择pod时，声明了node01，我是硬策略，必须满足硬策略的条件。必须部署在node01.强制性要求。</strong></p> 
<p></p> 
<h3><strong>pod的亲和性：</strong></h3> 
<h3><strong>preferredDuringSchedulingIgnoredDuringExecution</strong><strong>软策略：</strong></h3> 
<p><strong>要求调度器将pod调度到其他pod的亲和性匹配的节点上。可以是，也可以不是，尽量满足</strong></p> 
<p>pod nginx1 node01</p> 
<p>pod nginx2 nginx2希望和nginx1部署在一个节点上，尽量满足。</p> 
<h3><strong>requiredDuringSchedulingIgnoredDuringExecution硬策略：</strong></h3> 
<p><strong>要求调度器将pod调度到其他pod的亲和性匹配的节点上，必须是</strong></p> 
<p>pod nginx1 node01</p> 
<p>pod nginx2 nginx2必须要和nginx的亲和性匹配，只能往node01</p> 
<p></p> 
<h3><strong>键值的运行关系：</strong></h3> 
<p>标签，都是根据标签来选择亲和性。</p> 
<p>In：在</p> 
<p>选择的标签值，在node节点上存在</p> 
<p>Notin：不再</p> 
<p>选择label的值不再node节点上</p> 
<p>Gt：大于，大于选择的标签值</p> 
<p>Lt：小于，小于选择的标签值</p> 
<p>Exists：存在，选择标签对象，值不考虑。</p> 
<p>DoesNotExist：不存在，选择不具有指定标签的对象。值不考虑。</p> 
<p></p> 
<p></p> 
<p>spec：</p> 
<p>  containers:</p> 
<p>    -image：nginx:1.22</p> 
<p>      name: nginx</p> 
<p>  affinity：</p> 
<p>#选择亲和性的部署方式：</p> 
<p>    nodeAffinity:</p> 
<p>#选择的是node节点的亲和性</p> 
<p>      re</p> 
<p>        nodeSelectorTerms:</p> 
<p>#选择了亲和性的策略，nodeSelectorTerms你要选择哪个node作为硬策略。匹配的节点的标签。</p> 
<p>          matchExpressions:</p> 
<p>#定义一个符合我要选择的node节点的信息</p> 
<p>          - key: test3</p> 
<p>          poerator: In</p> 
<p>#指定键值对的算法</p> 
<p>          values：</p> 
<p>           - c</p> 
<p></p> 
<p>Exist or DoesNotExist不能使用vlaue字段</p> 
<p><img alt="" height="717" src="https://images2.imgbox.com/8c/a6/MP3JYCeZ_o.png" width="692"></p> 
<p><img alt="" height="526" src="https://images2.imgbox.com/f7/fe/eEjblMp2_o.png" width="952"></p> 
<h3 style="background-color:transparent;"><img alt="" height="110" src="https://images2.imgbox.com/b8/ce/lgBKmFq5_o.png" width="557"></h3> 
<h3 style="background-color:transparent;"><img alt="" height="552" src="https://images2.imgbox.com/60/a0/okzqCxml_o.png" width="1141"></h3> 
<h3 style="background-color:transparent;"><img alt="" height="435" src="https://images2.imgbox.com/42/d0/gNO1BmtR_o.png" width="1139"></h3> 
<h3 style="background-color:transparent;"><strong>软策略</strong></h3> 
<p>选择node节点的亲和性改为软策略</p> 
<p>加上权重值</p> 
<p>preference</p> 
<p>选择节点的倾向，尽量满足要求而不是一定。</p> 
<p></p> 
<p><strong>总结：</strong></p> 
<p><strong>多个软策略看权重，权重高，执行指定的软策略</strong></p> 
<p><strong>硬策略：</strong></p> 
<p><strong>先满足硬策略，再考虑软策略。</strong></p> 
<p></p> 
<p>问题：</p> 
<p>你在部署pod的时候选择什么策略？</p> 
<p>node的亲和性：</p> 
<p>性能不一致，尽量把pod往性能高的多部署 软策略</p> 
<p>节点故障或者节点维护，只能选择硬策略，把故障节点剔除出去。</p> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/2ad9e723a55cc8c2982633f448a04417/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">DVWA-Hight-远程命令执行漏洞</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/08c510651f52b3f03e609bad7b8cd4d1/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">大创项目推荐 深度学习大数据物流平台 python</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>