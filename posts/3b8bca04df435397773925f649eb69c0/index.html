<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>死磕Spring之IoC篇 - Spring 应用上下文 ApplicationContext - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="死磕Spring之IoC篇 - Spring 应用上下文 ApplicationContext" />
<meta property="og:description" content="该系列文章是本人在学习 Spring 的过程中总结下来的，里面涉及到相关源码，可能对读者不太友好，请结合我的源码注释 Spring 源码分析 GitHub 地址 进行阅读
Spring 版本：5.1.14.RELEASE
开始阅读这一系列文章之前，建议先查看《深入了解 Spring IoC（面试题）》这一篇文章
该系列其他文章请查看：《死磕 Spring 之 IoC 篇 - 文章导读》
Spring 应用上下文 ApplicationContext 前面一系列文章都是围绕 BeanFactory 进行分析的，BeanFactory 是 Spring 底层 IoC 容器的实现，完成了 IoC 容器的基本功能。在实际的应用场景中，BeanFactory 容器有点简单，它并不适用于生产环境，我们通常会选择 ApplicationContext。ApplicationContext 就是大名鼎鼎的 Spring 应用上下文，它不仅继承了 BeanFactory 体系，还提供更加高级的功能，更加适用于我们的正式应用环境。如以下几个功能：
继承 MessageSource，提供国际化的标准访问策略继承 ApplicationEventPublisher ，提供强大的事件机制扩展 ResourceLoader，可以用来加载多个 Resource，可以灵活访问不同的资源对 Web 应用的支持 ApplicationContext 体系结构 先来看看 ApplicationContext 接口的继承关系
可以看到 ApplicationContext 除了继承 BeanFactory 接口以外，还继承了 MessageSource、ApplicationEventPublisher、ResourceLoader 等接口
简单描述几个接口：
org.springframework.core.io.ResourceLoader，资源加载接口，用于访问不同的资源org.springframework.context.ApplicationEventPublisher，事件发布器接口，支持发布事件org.springframework.context.MessageSource，消息资源接口，提供国际化的标准访问策略org.springframework.core.env.EnvironmentCapable，环境暴露接口，Spring 应用上下文支持多环境的配置org.springframework.context.ApplicationContext，Spring 应用上下文，仅可读org.springframework.context.ConfigurableApplicationContext，Spring 应用上下文，支持配置相关属性 接下来我们来看看它们的实现类的继承关系（部分）
简单描述上面几个关键的类：
org.springframework.context.support.AbstractApplicationContext，Spring 应用上下文的抽象类，实现了大部分功能，提供骨架方法交由子类去实现org.springframework.web.context.ConfigurableWebApplicationContext，可配置的 Spring 应用上下文接口，支持 Web 应用org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3b8bca04df435397773925f649eb69c0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-23T20:21:23+08:00" />
<meta property="article:modified_time" content="2021-04-23T20:21:23+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">死磕Spring之IoC篇 - Spring 应用上下文 ApplicationContext</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <blockquote> 
 <p>该系列文章是本人在学习 Spring 的过程中总结下来的，里面涉及到相关源码，可能对读者不太友好，请结合我的源码注释 <a href="https://github.com/liu844869663/spring-framework">Spring 源码分析 GitHub 地址</a> 进行阅读</p> 
 <p>Spring 版本：5.1.14.RELEASE</p> 
 <p>开始阅读这一系列文章之前，建议先查看<a href="https://www.cnblogs.com/lifullmoon/p/14422101.html" rel="nofollow"><strong>《深入了解 Spring IoC（面试题）》</strong></a>这一篇文章</p> 
 <p>该系列其他文章请查看：<a href="https://www.cnblogs.com/lifullmoon/p/14436372.html" rel="nofollow"><strong>《死磕 Spring 之 IoC 篇 - 文章导读》</strong></a></p> 
</blockquote> 
<h3 id="spring-应用上下文-applicationcontext">Spring 应用上下文 ApplicationContext</h3> 
<p>前面一系列文章都是围绕 BeanFactory 进行分析的，BeanFactory 是 Spring 底层 IoC 容器的实现，完成了 IoC 容器的基本功能。在实际的应用场景中，BeanFactory 容器有点简单，它并不适用于生产环境，我们通常会选择 ApplicationContext。ApplicationContext 就是大名鼎鼎的 Spring 应用上下文，它不仅继承了 BeanFactory 体系，还提供更加高级的功能，更加适用于我们的正式应用环境。如以下几个功能：</p> 
<ul><li>继承 MessageSource，提供国际化的标准访问策略</li><li>继承 ApplicationEventPublisher ，提供强大的事件机制</li><li>扩展 ResourceLoader，可以用来加载多个 Resource，可以灵活访问不同的资源</li><li>对 Web 应用的支持</li></ul> 
<h4 id="applicationcontext-体系结构">ApplicationContext 体系结构</h4> 
<p>先来看看 ApplicationContext 接口的继承关系</p> 
<img src="https://images2.imgbox.com/0a/a5/Ko2U2yL6_o.png" alt="ApplicationContext.png"> 
<p>可以看到 ApplicationContext 除了继承 BeanFactory 接口以外，还继承了 MessageSource、ApplicationEventPublisher、ResourceLoader 等接口</p> 
<p>简单描述几个接口：</p> 
<ul><li><code>org.springframework.core.io.ResourceLoader</code>，资源加载接口，用于访问不同的资源</li><li><code>org.springframework.context.ApplicationEventPublisher</code>，事件发布器接口，支持发布事件</li><li><code>org.springframework.context.MessageSource</code>，消息资源接口，提供国际化的标准访问策略</li><li><code>org.springframework.core.env.EnvironmentCapable</code>，环境暴露接口，Spring 应用上下文支持多环境的配置</li><li><code>org.springframework.context.ApplicationContext</code>，Spring 应用上下文，仅可读</li><li><code>org.springframework.context.ConfigurableApplicationContext</code>，Spring 应用上下文，支持配置相关属性</li></ul> 
<p>接下来我们来看看它们的实现类的继承关系（部分）</p> 
<img src="https://images2.imgbox.com/a8/f2/JBe3cbzS_o.png" alt="AbstractApplicationContext.png"> 
<p>简单描述上面几个关键的类：</p> 
<ul><li><code>org.springframework.context.support.AbstractApplicationContext</code>，Spring 应用上下文的抽象类，实现了大部分功能，提供骨架方法交由子类去实现</li><li><code>org.springframework.web.context.ConfigurableWebApplicationContext</code>，可配置的 Spring 应用上下文接口，支持 Web 应用</li><li><code>org.springframework.context.support.AbstractRefreshableConfigApplicationContext</code>，支持设置 XML 文件</li><li><code>org.springframework.web.context.support.AbstractRefreshableWebApplicationContext</code>，支持 Web 应用</li><li><code>org.springframework.web.context.support.AnnotationConfigWebApplicationContext</code>，支持 Web 应用，可以设置 XML 文件，并可以扫描注解下面的 Bean</li><li><code>org.springframework.context.annotation.AnnotationConfigApplicationContext</code>，支持扫描注解下面的 Bean</li><li><code>org.springframework.web.context.support.ClassPathXmlApplicationContext</code>，支持设置 XML 文件，也可以从 classpath 下面扫描相关资源</li></ul> 
<p>ApplicationContext 的子类比较多，主要根据支持 Web、支持注解、支持 XML 文件三个功能进行区分，我们大致了解每个实现类的作用即可。其中基本的实现都是在 <strong>AbstractApplicationContext</strong> 这个抽象类中完成的，在它的 <code>refresh()</code> 方法体现了 Spring 应用上下文的生命周期。<code>AbstractApplicationContext#refresh()</code> 这个方法可以说是 Spring 应用上下文的准备阶段，在使用 Spring 时该方法会被调用，本文就围绕它进行展述。</p> 
<p>可以先看到我的另一篇文章<a href="https://www.cnblogs.com/lifullmoon/p/14131802.html" rel="nofollow">《精尽Spring MVC源码分析 - WebApplicationContext 容器的初始化》</a>，在 Spring MVC 启动过程中，创建 Spring 应用上下文后会调用其 <code>refresh()</code> 方法进行刷新，让 Spring 应用上下文准备就绪。</p> 
<h4 id="abstractapplicationcontext">AbstractApplicationContext</h4> 
<p><code>org.springframework.context.support.AbstractApplicationContext</code>，Spring 应用上下文的抽象类，实现了大部分功能，提供骨架方法交由子类去实现</p> 
<p>先来看看它的相关属性</p> 
<pre><code class="language-java">public abstract class AbstractApplicationContext extends DefaultResourceLoader
		implements ConfigurableApplicationContext {
    
	public static final String MESSAGE_SOURCE_BEAN_NAME = "messageSource";

	public static final String LIFECYCLE_PROCESSOR_BEAN_NAME = "lifecycleProcessor";

	public static final String APPLICATION_EVENT_MULTICASTER_BEAN_NAME = "applicationEventMulticaster";

	static {
		// Eagerly load the ContextClosedEvent class to avoid weird classloader issues
		// on application shutdown in WebLogic 8.1. (Reported by Dustin Woods.)
		ContextClosedEvent.class.getName();
	}

	/** Unique id for this context, if any. */
	private String id = ObjectUtils.identityToString(this);

	/** Display name. */
	private String displayName = ObjectUtils.identityToString(this);

	/** 父应用上下文 */
	@Nullable
	private ApplicationContext parent;

	/** 当前应用上下文的环境 */
	@Nullable
	private ConfigurableEnvironment environment;

	/** BeanFactory 的处理器 */
	private final List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors = new ArrayList&lt;&gt;();

	/** 启动时间 */
	private long startupDate;

	/** 是否处于激活状态 */
	private final AtomicBoolean active = new AtomicBoolean();

	/** 是否处于关闭状态 */
	private final AtomicBoolean closed = new AtomicBoolean();

	/** 启动和销毁时的锁对象 */
	private final Object startupShutdownMonitor = new Object();

	/** 钩子函数，用于 JVM 关闭时的回调 */
	@Nullable
	private Thread shutdownHook;

	/** ResourcePatternResolver used by this context. */
	private ResourcePatternResolver resourcePatternResolver;

	/** LifecycleProcessor for managing the lifecycle of beans within this context. */
	@Nullable
	private LifecycleProcessor lifecycleProcessor;

	/** MessageSource we delegate our implementation of this interface to. */
	@Nullable
	private MessageSource messageSource;

	/** 事件广播器 */
	@Nullable
	private ApplicationEventMulticaster applicationEventMulticaster;

	/** 事件监听器 */
	private final Set&lt;ApplicationListener&lt;?&gt;&gt; applicationListeners = new LinkedHashSet&lt;&gt;();

	/** 早期（Spring 应用上下文还未就绪）注册的时间监听器 */
	@Nullable
	private Set&lt;ApplicationListener&lt;?&gt;&gt; earlyApplicationListeners;

	/** 早期（Spring 应用上下文还未就绪）发布的事件 */
	@Nullable
	private Set&lt;ApplicationEvent&gt; earlyApplicationEvents;

	public AbstractApplicationContext() {
		this.resourcePatternResolver = getResourcePatternResolver();
	}

	public AbstractApplicationContext(@Nullable ApplicationContext parent) {
		this();
		setParent(parent);
	}
}
</code></pre> 
<p>属性不多，上面都有注释</p> 
<h5 id="publishevent-方法">publishEvent 方法</h5> 
<p><code>publishEvent(ApplicationEvent event)</code> 方法，发布事件，因为它继承了 ApplicationEventPublisher 事件发布器，如下：</p> 
<pre><code class="language-java">@Override
public void publishEvent(ApplicationEvent event) {
    publishEvent(event, null);
}

protected void publishEvent(Object event, @Nullable ResolvableType eventType) {
    Assert.notNull(event, "Event must not be null");

    // Decorate event as an ApplicationEvent if necessary
    ApplicationEvent applicationEvent;
    if (event instanceof ApplicationEvent) {
        applicationEvent = (ApplicationEvent) event;
    }
    else {
        // 如果不是 ApplicationEvent 类型的事件，则封装成 PayloadApplicationEvent
        applicationEvent = new PayloadApplicationEvent&lt;&gt;(this, event);
        if (eventType == null) {
            eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();
        }
    }

    // Multicast right now if possible - or lazily once the multicaster is initialized
    if (this.earlyApplicationEvents != null) {
        this.earlyApplicationEvents.add(applicationEvent);
    }
    else {
        // 广播该事件
        getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);
    }

    // Publish event via parent context as well...
    // 父容器也要发布事件
    if (this.parent != null) {
        if (this.parent instanceof AbstractApplicationContext) {
            ((AbstractApplicationContext) this.parent).publishEvent(event, eventType);
        }
        else {
            this.parent.publishEvent(event);
        }
    }
}
</code></pre> 
<p>过程如下：</p> 
<ol><li>如果不是 ApplicationEvent 类型的事件，则封装成 PayloadApplicationEvent</li><li>如果 <code>earlyApplicationEvents</code> 不为 <code>null</code>，则表示当前 Spring 应用上下文正在处于刷新阶段，还没有准备就绪，则先将这个早期事件添加至 <code>earlyApplicationEvents</code>；否则，Spring 应用上下文已经准备就绪了，此时就对该事件进行广播</li><li>如果存在父应用上下文，也需要进行广播</li></ol> 
<p>上面的第 <code>2</code> 步中的 <code>earlyApplicationEvents</code> 如果不为 <code>null</code> ，为什么 Spring 应用上下文还没有准备就绪呢？答案会在后面体现</p> 
<h5 id="addbeanfactorypostprocessor-方法">addBeanFactoryPostProcessor 方法</h5> 
<p><code>addBeanFactoryPostProcessor(BeanFactoryPostProcessor postProcessor)</code> 方法，添加 BeanFactoryPostProcessor 处理器，如下：</p> 
<pre><code class="language-java">@Override
public void addBeanFactoryPostProcessor(BeanFactoryPostProcessor postProcessor) {
    Assert.notNull(postProcessor, "BeanFactoryPostProcessor must not be null");
    this.beanFactoryPostProcessors.add(postProcessor);
}
</code></pre> 
<p>直接往 <code>beanFactoryPostProcessors</code> 添加，BeanFactoryPostProcessor 处理器用于在 Spring 应用上下文刷新阶段对创建好的 BeanFactory 进行后缀处理</p> 
<h5 id="addapplicationlistener-方法">addApplicationListener 方法</h5> 
<p><code>addApplicationListener(ApplicationListener&lt;?&gt; listener)</code> 方法，添加事件监听器，如下：</p> 
<pre><code class="language-java">@Override
public void addApplicationListener(ApplicationListener&lt;?&gt; listener) {
    Assert.notNull(listener, "ApplicationListener must not be null");
    if (this.applicationEventMulticaster != null) {
        this.applicationEventMulticaster.addApplicationListener(listener);
    }
    this.applicationListeners.add(listener);
}
</code></pre> 
<p>如果事件广播器不为空则将该监听器添加进去，然后再添加到本地的 <code>applicationListeners</code> 中</p> 
<h5 id="【核心】refresh-方法">【核心】refresh 方法</h5> 
<p><code>refresh()</code> 方法，Spring 应用上下文的刷新，让 Spring 应用上下文处于准备就绪状态，如下：</p> 
<pre><code class="language-java">/**
 * 刷新上下文，在哪会被调用？
 * 在 **Spring MVC** 中，{@link org.springframework.web.context.ContextLoader#initWebApplicationContext} 方法初始化上下文时，会调用该方法
 */
@Override
public void refresh() throws BeansException, IllegalStateException {
    // &lt;1&gt; 来个锁，不然 refresh() 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛
    synchronized (this.startupShutdownMonitor) {

        // &lt;2&gt; 刷新上下文环境的准备工作，记录下容器的启动时间、标记'已启动'状态、对上下文环境属性进行校验
        prepareRefresh();

        // &lt;3&gt; 创建并初始化一个 BeanFactory 对象 `beanFactory`，会加载出对应的 BeanDefinition 元信息们
        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

        // &lt;4&gt; 为 `beanFactory` 进行一些准备工作，例如添加几个 BeanPostProcessor，手动注册几个特殊的 Bean
        prepareBeanFactory(beanFactory);

        try {
            // &lt;5&gt; 对 `beanFactory` 在进行一些后期的加工，交由子类进行扩展
            postProcessBeanFactory(beanFactory);

            // &lt;6&gt; 执行 BeanFactoryPostProcessor 处理器，包含 BeanDefinitionRegistryPostProcessor 处理器
            invokeBeanFactoryPostProcessors(beanFactory);

            // &lt;7&gt; 对 BeanPostProcessor 处理器进行初始化，并添加至 BeanFactory 中
            registerBeanPostProcessors(beanFactory);

            // &lt;8&gt; 设置上下文的 MessageSource 对象
            initMessageSource();

            // &lt;9&gt; 设置上下文的 ApplicationEventMulticaster 对象，上下文事件广播器
            initApplicationEventMulticaster();

            // &lt;10&gt; 刷新上下文时再进行一些初始化工作，交由子类进行扩展
            onRefresh();

            // &lt;11&gt; 将所有 ApplicationListener 监听器添加至 `applicationEventMulticaster` 事件广播器，如果已有事件则进行广播
            registerListeners();

            // &lt;12&gt; 设置 ConversionService 类型转换器，**初始化**所有还未初始化的 Bean（不是抽象、单例模式、不是懒加载方式）
            finishBeanFactoryInitialization(beanFactory);

            // &lt;13&gt; 刷新上下文的最后一步工作，会发布 ContextRefreshedEvent 上下文完成刷新事件
            finishRefresh();
        }
        // &lt;14&gt; 如果上面过程出现 BeansException 异常
        catch (BeansException ex) {
            if (logger.isWarnEnabled()) {
                logger.warn("Exception encountered during context initialization - " +
                        "cancelling refresh attempt: " + ex);
            }
            // &lt;14.1&gt; “销毁” 已注册的单例 Bean
            destroyBeans();

            // &lt;14.2&gt; 设置上下文的 `active` 状态为 `false`
            cancelRefresh(ex);

            // &lt;14.3&gt; 抛出异常
            throw ex;
        }
        // &lt;15&gt; `finally` 代码块
        finally {
            // Reset common introspection caches in Spring's core, since we
            // might not ever need metadata for singleton beans anymore...
            // 清除相关缓存，例如通过反射机制缓存的 Method 和 Field 对象，缓存的注解元数据，缓存的泛型类型对象，缓存的类加载器
            resetCommonCaches();
        }
    }
}
</code></pre> 
<p>整个过程比较长，每一个步骤都调用一个方法，过程如下：</p> 
<ol><li>来个锁，不然 <code>refresh()</code> 还没结束，你又来个启动或销毁容器的操作，那不就乱套了嘛</li><li><strong>应用上下文启动准备阶段</strong>，调用 <code>prepareRefresh()</code> 方法，说明：刷新上下文环境的准备工作，记录下容器的启动时间、标记'已启动'状态、对上下文环境属性进行校验</li><li><strong>BeanFactory 创建阶段</strong>，调用 <code>obtainFreshBeanFactory()</code> 方法，说明：创建并初始化一个 BeanFactory 对象 <code>beanFactory</code>，会加载出对应的 BeanDefinition 元信息们</li><li><strong>BeanFactory 准备阶段</strong>，调用 <code>prepareBeanFactory()</code> 方法，说明：为 <code>beanFactory</code> 进行一些准备工作，例如添加几个 BeanPostProcessor，手动注册几个特殊的 Bean</li><li><strong>BeanFactory 后置处理阶段</strong>，调用 <code>postProcessBeanFactory(ConfigurableListableBeanFactory)</code> 方法，说明：对 <code>beanFactory</code> 在进行一些后期的加工，交由子类进行扩展</li><li><strong>BeanFactory 后置处理阶段</strong>，调用 <code>invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory)</code> 方法，说明：执行 BeanFactoryPostProcessor 处理器，包含 BeanDefinitionRegistryPostProcessor 处理器</li><li><strong>BeanFactory 注册 BeanPostProcessor 阶段</strong>，调用 <code>registerBeanPostProcessors(ConfigurableListableBeanFactory)</code> 方法，说明：对 BeanPostProcessor 处理器进行初始化，并添加至 BeanFactory 中</li><li><strong>初始化内建 Bean：MessageSource</strong>，调用 <code>initMessageSource()</code> 方法，说明：设置上下文的 MessageSource 对象</li><li><strong>初始化内建 Bean：Spring 事件广播器</strong>，调用 <code>initApplicationEventMulticaster()</code> 方法，说明：设置上下文的 ApplicationEventMulticaster 对象，上下文事件广播器</li><li><strong>Spring 应用上下文刷新扩展阶段</strong>，调用 <code>onRefresh()</code> 方法，说明：刷新上下文时再进行一些初始化工作，交由子类进行扩展</li><li><strong>Spring 事件监听器注册阶段</strong>，调用 <code>registerListeners()</code> 方法，说明：将所有 ApplicationListener 监听器添加至 <code>applicationEventMulticaster</code> 事件广播器，如果已有事件则进行广播</li><li><strong>BeanFactory 初始化完成阶段</strong>，调用 <code>finishBeanFactoryInitialization(ConfigurableListableBeanFactory)</code> 方法，说明：设置 ConversionService 类型转换器，<strong>初始化</strong>所有还未初始化的 Bean（不是抽象、单例模式、不是懒加载方式）</li><li><strong>应用上下文刷新完成阶段</strong>，调用 <code>finishRefresh()</code> 方法，说明：刷新上下文的最后一步工作，会发布 ContextRefreshedEvent 上下文完成刷新事件</li><li>如果上面过程出现 BeansException 异常 
  <ol><li>“销毁” 已注册的单例 Bean</li><li>设置上下文的 <code>active</code> 状态为 <code>false</code></li><li>抛出异常</li></ol></li><li><code>finally</code> 代码块，清除相关缓存，例如通过反射机制缓存的 Method 和 Field 对象，缓存的注解元数据，缓存的泛型类型对象，缓存的类加载器</li></ol> 
<p>可以看到该过程分为许多阶段，每个阶段都非常关键，将在后续已经进行分析</p> 
<h5 id="registershutdownhook-方法">registerShutdownHook 方法</h5> 
<p><code>registerShutdownHook()</code> 方法，向 JVM 注册一个钩子函数，当 JVM 关闭时执行该函数，如下：</p> 
<pre><code class="language-java">@Override
public void registerShutdownHook() {
    if (this.shutdownHook == null) {
        // No shutdown hook registered yet.
        this.shutdownHook = new Thread() {
            @Override
            public void run() {
                synchronized (startupShutdownMonitor) {
                    doClose();
                }
            }
        };
        // 为当前的 JVM 运行环境添加一个钩子函数，用于关闭当前上下文
        Runtime.getRuntime().addShutdownHook(this.shutdownHook);
    }
}
</code></pre> 
<p>这个钩子函数也就是调用了 <code>doClose()</code> 方法，用于关闭当前 Spring 应用上下文</p> 
<h5 id="close-方法">close 方法</h5> 
<p><code>close()</code> 方法，关闭当前 Spring 应用上下文，如下：</p> 
<pre><code class="language-java">@Override
public void close() {
   synchronized (this.startupShutdownMonitor) {
      doClose();
      // If we registered a JVM shutdown hook, we don't need it anymore now:
      // We've already explicitly closed the context.
      if (this.shutdownHook != null) {
         try {
            Runtime.getRuntime().removeShutdownHook(this.shutdownHook);
         }
         catch (IllegalStateException ex) {
            // ignore - VM is already shutting down
         }
      }
   }
}
</code></pre> 
<p>关闭当前 Spring 应用上下文，也是调用 <code>doClose()</code> 方法，同时如果存在钩子函数则将其从 JVM 中移除，因为上面已经关闭了</p> 
<h5 id="doclose-方法">doClose 方法</h5> 
<p><code>doClose()</code> 方法，关闭当前 Spring 应用上下文，如下：</p> 
<pre><code class="language-java">protected void doClose() {
    // Check whether an actual close attempt is necessary...
    if (this.active.get() &amp;&amp; this.closed.compareAndSet(false, true)) {
        // Live Beans JMX 撤销托管
        LiveBeansView.unregisterApplicationContext(this);

        try {
            // Publish shutdown event.
            // 发布当前 Spring 应用上下文关闭事件
            publishEvent(new ContextClosedEvent(this));
        }
        catch (Throwable ex) {
            logger.warn("Exception thrown from ApplicationListener handling ContextClosedEvent", ex);
        }

        // Stop all Lifecycle beans, to avoid delays during individual destruction.
        if (this.lifecycleProcessor != null) {
            try {
                // 关闭 Lifecycle Beans
                this.lifecycleProcessor.onClose();
            }
            catch (Throwable ex) {
                logger.warn("Exception thrown from LifecycleProcessor on context close", ex);
            }
        }

        // Destroy all cached singletons in the context's BeanFactory.
        // 销毁所有的单例 Bean
        destroyBeans();

        // Close the state of this context itself.
        // 关闭底层 BeanFactory 容器
        closeBeanFactory();

        // Let subclasses do some final clean-up if they wish...
        // 提供给子类去实现，用于清理相关资源
        onClose();

        // Reset local application listeners to pre-refresh state.
        if (this.earlyApplicationListeners != null) {
            this.applicationListeners.clear();
            this.applicationListeners.addAll(this.earlyApplicationListeners);
        }

        // Switch to inactive.
        this.active.set(false);
    }
}
</code></pre> 
<p>主要做以下事情：</p> 
<ol><li>Live Beans JMX 撤销托管</li><li>发布当前 Spring 应用上下文关闭事件</li><li>销毁所有的单例 Bean，调用 DefaultListableBeanFactory#destroySingletons() 方法</li><li>关闭底层 BeanFactory 容器</li><li>回调 onClose() 方法</li></ol> 
<h4 id="1-应用上下文启动准备阶段">1. 应用上下文启动准备阶段</h4> 
<p>AbstractApplicationContext#prepareRefresh() 方法，如下：</p> 
<pre><code class="language-java">// AbstractApplicationContext.java
protected void prepareRefresh() {
    // 设置启动时间
    this.startupDate = System.currentTimeMillis();
    // 设置当前 ApplicationContext 的状态
    this.closed.set(false);
    this.active.set(true);

    // Initialize any placeholder property sources in the context environment.
    // 初始化 ApplicationContext 的 Environment（上下文环境）的相关属性，交由子类去实现，如果是 Web 则会设置 ServletContext 和 ServletConfig
    initPropertySources();

    // Validate that all properties marked as required are resolvable:
    // see ConfigurablePropertyResolver#setRequiredProperties
    // 对属性进行必要的验证
    getEnvironment().validateRequiredProperties();

    // Store pre-refresh ApplicationListeners...
    if (this.earlyApplicationListeners == null) {
        this.earlyApplicationListeners = new LinkedHashSet&lt;&gt;(this.applicationListeners);
    }
    else {
        // Reset local application listeners to pre-refresh state.
        this.applicationListeners.clear();
        this.applicationListeners.addAll(this.earlyApplicationListeners);
    }

    // Allow for the collection of early ApplicationEvents,
    // to be published once the multicaster is available...
    this.earlyApplicationEvents = new LinkedHashSet&lt;&gt;();
}
</code></pre> 
<p>主要做了以下事情：</p> 
<ol><li>设置启动时间：startupDate</li><li>设置 Spring 应用上下文的状态标识：closed(false)、active(true)</li><li>初始化 PropertySources - initPropertySources()，初始化 ApplicationContext 的 Environment（上下文环境）的相关属性，交由子类去实现，如果是 Web 则会设置 ServletContext 和 ServletConfig</li><li>校验 Environment 中必须属性</li><li>初始化早期 Spring 事件集合 <code>earlyApplicationEvents</code>，注意这里创建了一个空的集合，也就是不为 null，回到前面的 <code>publishEvent(...)</code> 方法，如果 <code>earlyApplicationEvents</code> 不为 null 则会添加到这个集合里面，不会进行广播。这一步的目的就是在 Spring 应用上下文还未完全就绪时，如果发布了事件，则需要先存储起来，等就绪后才进行广播</li></ol> 
<h4 id="2-beanfactory-创建阶段">2. BeanFactory 创建阶段</h4> 
<p>整个过程会创建一个 DefaultListableBeanFactory 对象作为底层 IoC 容器，然后从资源文件或者根据指定路径下 .class 文件（标注了@ Component 注解）加载出所有的 BeanDefinition</p> 
<h5 id="21-obtainfreshbeanfactory-方法">2.1 obtainFreshBeanFactory 方法</h5> 
<p>AbstractApplicationContext#obtainFreshBeanFactory() 方法，如下：</p> 
<pre><code class="language-java">protected ConfigurableListableBeanFactory obtainFreshBeanFactory() {
    refreshBeanFactory();
    return getBeanFactory();
}
</code></pre> 
<p>这两个方法都是抽象方法，交由子类实现，我们来看到 AbstractRefreshableApplicationContext 的实现</p> 
<h5 id="22-refreshbeanfactory-方法">2.2 refreshBeanFactory 方法</h5> 
<p>AbstractRefreshableApplicationContext#refreshBeanFactory() 方法，如下：</p> 
<pre><code class="language-java">@Override
protected final void refreshBeanFactory() throws BeansException {
    // 若已有 BeanFactory ，销毁它的 Bean 们，并销毁 BeanFactory
    if (hasBeanFactory()) {
        destroyBeans();
        closeBeanFactory();
    }
    try {
        // 创建 DefaultListableBeanFactory 对象
        DefaultListableBeanFactory beanFactory = createBeanFactory();
        // 指定序列化编号
        beanFactory.setSerializationId(getId());
        // 定制 BeanFactory 相关属性（是否允许 BeanDefinition 重复定义，是否允许循环依赖，默认都是允许）
        customizeBeanFactory(beanFactory);
        // 加载 BeanDefinition 们
        loadBeanDefinitions(beanFactory);
        synchronized (this.beanFactoryMonitor) {
            this.beanFactory = beanFactory;
        }
    }
    catch (IOException ex) {
        throw new ApplicationContextException("I/O error parsing bean definition source for " + getDisplayName(), ex);
    }
}

protected DefaultListableBeanFactory createBeanFactory() {
    return new DefaultListableBeanFactory(getInternalParentBeanFactory());
}

protected void customizeBeanFactory(DefaultListableBeanFactory beanFactory) {
    if (this.allowBeanDefinitionOverriding != null) {
        beanFactory.setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding);
    }
    if (this.allowCircularReferences != null) {
        beanFactory.setAllowCircularReferences(this.allowCircularReferences);
    }
}
</code></pre> 
<p>主要做以下事情：</p> 
<ol><li>若已有 BeanFactory ，销毁它的 Bean 们，并销毁 BeanFactory</li><li>创建 BeanFactory，DefaultListableBeanFactory 对象</li><li>设置 BeanFactory Id</li><li>定制 BeanFactory 相关属性（是否允许 BeanDefinition 重复定义，是否允许循环依赖，默认都是允许）</li><li>加载出 BeanDefinition 们 - <code>loadBeanDefinitions(DefaultListableBeanFactory beanFactory)</code> 方法，交由子类实现（主要是 XML 和 Annotation 的区别）</li><li>关联 BeanFactory 到 Spring 应用上下文（ApplicationContext）</li></ol> 
<p>上面第 <code>6</code> 步会将第 <code>2</code> 步创建的 DefaultListableBeanFactory 设置为 Spring 应用上下文的 BeanFactory 对象，也就可以通过 <code>getBeanFactory()</code> 获取</p> 
<p>我们再来看到 <code>loadBeanDefinitions(...)</code> 抽象方法的实现，主要为注解和 XML 的区别，先来看到 AbstractXmlApplicationContext 的实现</p> 
<h5 id="23-loadbeandefinitions-方法（xml）">2.3 loadBeanDefinitions 方法（XML）</h5> 
<p>AbstractXmlApplicationContext#loadBeanDefinitions(DefaultListableBeanFactory beanFactory) 方法，如下：</p> 
<pre><code class="language-java">@Override
protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) throws BeansException, IOException {
    // Create a new XmlBeanDefinitionReader for the given BeanFactory.
    // 创建 XmlBeanDefinitionReader 对象
    XmlBeanDefinitionReader beanDefinitionReader = new XmlBeanDefinitionReader(beanFactory);

    // Configure the bean definition reader with this context's
    // resource loading environment.
    // 对 XmlBeanDefinitionReader 进行环境变量的设置
    beanDefinitionReader.setEnvironment(this.getEnvironment());
    beanDefinitionReader.setResourceLoader(this);
    beanDefinitionReader.setEntityResolver(new ResourceEntityResolver(this));

    // Allow a subclass to provide custom initialization of the reader,
    // then proceed with actually loading the bean definitions.
    // 对 XmlBeanDefinitionReader 进行设置，可以进行覆盖
    initBeanDefinitionReader(beanDefinitionReader);

    // 从 Resource 们中，加载 BeanDefinition 们
    loadBeanDefinitions(beanDefinitionReader);
}

protected void loadBeanDefinitions(XmlBeanDefinitionReader reader) throws BeansException, IOException {
    // 从配置文件 Resource 中，加载 BeanDefinition 们
    Resource[] configResources = getConfigResources();
    if (configResources != null) {
        reader.loadBeanDefinitions(configResources);
    }
    // 从配置文件地址中，加载 BeanDefinition 们
    String[] configLocations = getConfigLocations();
    if (configLocations != null) {
        reader.loadBeanDefinitions(configLocations);
    }
}
</code></pre> 
<p>可以看到这里创建了 <a href="https://www.cnblogs.com/lifullmoon/p/14437305.html" rel="nofollow"><strong>《BeanDefinition 的加载阶段（XML 文件）》</strong></a>这篇文章中讲到的 XmlBeanDefinitionReader 资源解析器对象，然后通过它解析 XML 配置文件，解析过程在之前的文章中已经分析过了。</p> 
<blockquote> 
 <p>配置文件怎么来的呢？</p> 
 <p>在 <a href="https://www.cnblogs.com/lifullmoon/p/14131802.html" rel="nofollow"><strong>《精尽Spring MVC源码分析 - WebApplicationContext 容器的初始化》</strong></a>的 ContextLoader#configureAndRefreshWebApplicationContext(...) 方法中可以看到，会将 <code>web.xml</code> 文件中配置的 <code>contextConfigLocation</code> 设置到 Spring 应用上下文中</p> 
</blockquote> 
<p>我们再来看到 AnnotationConfigWebApplicationContext 的实现</p> 
<h5 id="23-loadbeandefinitions-方法（注解）">2.3 loadBeanDefinitions 方法（注解）</h5> 
<p>AnnotationConfigWebApplicationContext#loadBeanDefinitions(DefaultListableBeanFactory beanFactory) 方法，如下：</p> 
<pre><code class="language-java">@Override
protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) {
    AnnotatedBeanDefinitionReader reader = getAnnotatedBeanDefinitionReader(beanFactory);
    ClassPathBeanDefinitionScanner scanner = getClassPathBeanDefinitionScanner(beanFactory);

    BeanNameGenerator beanNameGenerator = getBeanNameGenerator();
    if (beanNameGenerator != null) {
        reader.setBeanNameGenerator(beanNameGenerator);
        scanner.setBeanNameGenerator(beanNameGenerator);
        beanFactory.registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);
    }

    ScopeMetadataResolver scopeMetadataResolver = getScopeMetadataResolver();
    if (scopeMetadataResolver != null) {
        reader.setScopeMetadataResolver(scopeMetadataResolver);
        scanner.setScopeMetadataResolver(scopeMetadataResolver);
    }

    if (!this.componentClasses.isEmpty()) {
        if (logger.isDebugEnabled()) {
            logger.debug("Registering component classes: [" +
                    StringUtils.collectionToCommaDelimitedString(this.componentClasses) + "]");
        }
        reader.register(ClassUtils.toClassArray(this.componentClasses));
    }

    if (!this.basePackages.isEmpty()) {
        if (logger.isDebugEnabled()) {
            logger.debug("Scanning base packages: [" +
                    StringUtils.collectionToCommaDelimitedString(this.basePackages) + "]");
        }
        // 扫描指定包路径下 @Component 注解的 .class 文件，会解析出 BeanDefinition 对象
        scanner.scan(StringUtils.toStringArray(this.basePackages));
    }

    String[] configLocations = getConfigLocations();
    if (configLocations != null) {
        for (String configLocation : configLocations) {
            try {
                Class&lt;?&gt; clazz = ClassUtils.forName(configLocation, getClassLoader());
                if (logger.isTraceEnabled()) {
                    logger.trace("Registering [" + configLocation + "]");
                }
                reader.register(clazz);
            }
            catch (ClassNotFoundException ex) {
                if (logger.isTraceEnabled()) {
                    logger.trace("Could not load class for config location [" + configLocation +
                            "] - trying package scan. " + ex);
                }
                int count = scanner.scan(configLocation);
                if (count == 0 &amp;&amp; logger.isDebugEnabled()) {
                    logger.debug("No component classes found for specified class/package [" + configLocation + "]");
                }
            }
        }
    }
}

protected ClassPathBeanDefinitionScanner getClassPathBeanDefinitionScanner(DefaultListableBeanFactory beanFactory) {
    return new ClassPathBeanDefinitionScanner(beanFactory, true, getEnvironment());
}
</code></pre> 
<p>我们主要看到关键的一步，会创建一个 ClassPathBeanDefinitionScanner 扫描器对象，然后调用其 scan(String... basePackages) 方法去扫描指定包路径下的 .class 文件，整个扫描过程在 <a href="https://www.cnblogs.com/lifullmoon/p/14451788.html" rel="nofollow"><strong>《BeanDefinition 的解析过程（面向注解）》</strong></a> 这篇文章中已经分析过了</p> 
<h4 id="3-beanfactory-准备阶段">3. BeanFactory 准备阶段</h4> 
<p>AbstractApplicationContext#prepareBeanFactory(ConfigurableListableBeanFactory) 方法，如下：</p> 
<pre><code class="language-java">protected void prepareBeanFactory(ConfigurableListableBeanFactory beanFactory) {
    // 设置 ClassLoader 类加载器
    beanFactory.setBeanClassLoader(getClassLoader());
    // 设置 BeanExpressionResolver 表达式语言处理器，Spring 3 开始增加了对语言表达式的支持，例如可以使用 #{bean.xxx} 的形式来调用这个 Bean 的属性值
    beanFactory.setBeanExpressionResolver(new StandardBeanExpressionResolver(beanFactory.getBeanClassLoader()));
    // 添加一个默认的 PropertyEditorRegistrar 属性编辑器
    beanFactory.addPropertyEditorRegistrar(new ResourceEditorRegistrar(this, getEnvironment()));

    /*
     * 添加一个 BeanPostProcessor 处理器，ApplicationContextAwareProcessor，初始化 Bean 的**前置**处理
     * 这个 BeanPostProcessor 其实是对几种 Aware 接口的处理，调用其 setXxx 方法
     * 可以跳到 AbstractAutowireCapableBeanFactory 的 initializeBean(...) 方法（调用 Bean 的初始化方法）中看看
     */
    beanFactory.addBeanPostProcessor(new ApplicationContextAwareProcessor(this));
    // 忽略 Aware 回调接口作为依赖注入接口
    beanFactory.ignoreDependencyInterface(EnvironmentAware.class);
    beanFactory.ignoreDependencyInterface(EmbeddedValueResolverAware.class);
    beanFactory.ignoreDependencyInterface(ResourceLoaderAware.class);
    beanFactory.ignoreDependencyInterface(ApplicationEventPublisherAware.class);
    beanFactory.ignoreDependencyInterface(MessageSourceAware.class);
    beanFactory.ignoreDependencyInterface(ApplicationContextAware.class);

    // 设置几个自动装配的特殊规则，当你自动注入下面这些类型的 Bean 时，注入的就是右边的值
    // 可以看到 ApplicationContext.class 对应当前对象
    beanFactory.registerResolvableDependency(BeanFactory.class, beanFactory);
    beanFactory.registerResolvableDependency(ResourceLoader.class, this);
    beanFactory.registerResolvableDependency(ApplicationEventPublisher.class, this);
    beanFactory.registerResolvableDependency(ApplicationContext.class, this);

    // Register early post-processor for detecting inner beans as ApplicationListeners.
    // 添加一个 BeanPostProcessor 处理器，ApplicationListenerDetector，用于装饰监听器
    // 初始化 Bean 的时候，如果是 ApplicationListener 类型且为单例模式，则添加到 Spring 应用上下文
    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(this));

    // 增加对 AspectJ 的支持，AOP 相关
    if (beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
        // Set a temporary ClassLoader for type matching.
        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    }

    // 注册几个 ApplicationContext 上下文默认的 Bean 对象
    if (!beanFactory.containsLocalBean(ENVIRONMENT_BEAN_NAME)) {
        beanFactory.registerSingleton(ENVIRONMENT_BEAN_NAME, getEnvironment());
    }
    if (!beanFactory.containsLocalBean(SYSTEM_PROPERTIES_BEAN_NAME)) {
        beanFactory.registerSingleton(SYSTEM_PROPERTIES_BEAN_NAME, getEnvironment().getSystemProperties());
    }
    if (!beanFactory.containsLocalBean(SYSTEM_ENVIRONMENT_BEAN_NAME)) {
        beanFactory.registerSingleton(SYSTEM_ENVIRONMENT_BEAN_NAME, getEnvironment().getSystemEnvironment());
    }
}
</code></pre> 
<p>主要做以下事情：</p> 
<ol><li>设置 ClassLoader 类加载器</li><li>设置 BeanExpressionResolver <strong>表达式语言处理器</strong>，Spring 3 开始增加了对语言表达式的支持，例如可以使用 #{bean.xxx} 的形式来获取这个 Bean 的属性值</li><li>添加一个默认的 PropertyEditorRegistrar <strong>属性编辑器</strong> - ResourceEditorRegistrar</li><li>添加一个 BeanPostProcessor 处理器 - <code>ApplicationContextAwareProcessor</code>，相关 Aware 回调接口的实现，调用其 setXxx 方法</li><li>忽略 Aware 回调接口作为依赖注入接口</li><li>注册 ResolvableDependency 对象 - BeanFactory、ResourceLoader、ApplicationEventPublisher 以及 ApplicationContext，依赖注入这几个对象时注入的都是当前 Spring 应用上下文，在<a href="https://www.cnblogs.com/lifullmoon/p/14453011.html" rel="nofollow"><strong>《@Autowired 等注解的实现原理》</strong></a>这篇文章中有讲到</li><li>添加一个 BeanPostProcessor 处理器 - <code>ApplicationListenerDetector</code>，初始化 Bean 的时候，如果是 ApplicationListener 类型且为单例模式，则添加到 Spring 应用上下文</li><li>添加一个 BeanPostProcessor 处理器 - LoadTimeWeaverAwareProcessor，增加对 AspectJ 的支持，AOP 相关</li><li>注册几个单例对象 - Environment、SystemProperties（Java System Properties）、SystemEnvironment（OS 环境变量）</li></ol> 
<h4 id="4-beanfactory-后置处理阶段">4. BeanFactory 后置处理阶段</h4> 
<p>有序地执行所有 BeanFactoryPostProcessor（包括 BeanDefinitionRegistryPostProcessor）处理器，例如 <code>@Bean</code> 等注解定义的 Bean 的就是通过 BeanDefinitionRegistryPostProcessor 处理器接续出来的</p> 
<h5 id="41-postprocessbeanfactory-方法">4.1 postProcessBeanFactory 方法</h5> 
<p>该抽象方法交由子类实现，例如 AbstractRefreshableWebApplicationContext#postProcessBeanFactory(ConfigurableListableBeanFactory) 方法，如下：</p> 
<pre><code class="language-java">@Override
protected void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) {
    // 添加 ServletContextAwareProcessor 到 BeanFactory 容器中，
    // 该 processor 实现 BeanPostProcessor 接口，主要用于将 ServletContext 传递给实现了 ServletContextAware 接口的 bean
    beanFactory.addBeanPostProcessor(new ServletContextAwareProcessor(this.servletContext, this.servletConfig));
    // 忽略 ServletContextAware、ServletConfigAware，上面的 ServletContextAwareProcessor 已代替
    beanFactory.ignoreDependencyInterface(ServletContextAware.class);
    beanFactory.ignoreDependencyInterface(ServletConfigAware.class);

    // 注册 WEB 应用特定的域（scope）到 beanFactory 中，以便 WebApplicationContext 可以使用它们。
    // 比如'request','session','globalSession','application'
    WebApplicationContextUtils.registerWebApplicationScopes(beanFactory, this.servletContext);
    // 注册 WEB 应用特定的 Environment bean 到 beanFactory 中，以便 WebApplicationContext 可以使用它们
    // 如：'contextParameters','contextAttributes'
    WebApplicationContextUtils.registerEnvironmentBeans(beanFactory, this.servletContext, this.servletConfig);
}
</code></pre> 
<p>添加 ServletContext 相关内容</p> 
<h5 id="42-invokebeanfactorypostprocessors-方法">4.2 invokeBeanFactoryPostProcessors 方法</h5> 
<p>AbstractApplicationContext#invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory) 方法，如下：</p> 
<pre><code class="language-java">protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    // 执行所有的BeanFactoryPostProcessor处理器
    PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors());

    // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime
    // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor)
    // 在 prepareBeanFactory() 方法中也有相同操作
    if (beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) {
        beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory));
        beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader()));
    }
}
</code></pre> 
<p>这里借助于 PostProcessorRegistrationDelegate 这个类执行所有 BeanFactoryPostProcessor 处理器，对前面创建的 BeanFactory 进行后置处理</p> 
<h5 id="43-invokebeanfactorypostprocessors-方法">4.3 invokeBeanFactoryPostProcessors 方法</h5> 
<p>PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors 方法，如下（方法比较长，可直接查看下面的总结）：</p> 
<pre><code class="language-java">public static void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) {

    // Invoke BeanDefinitionRegistryPostProcessors first, if any.
    Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;();

    // &lt;1&gt; 执行当前 Spring 应用上下文和底层 BeanFactory 容器中的 BeanFactoryPostProcessor、BeanDefinitionRegistryPostProcessor 们的处理
    if (beanFactory instanceof BeanDefinitionRegistry) {
        BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;
        List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;();
        List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;();

        // &lt;1.1&gt; 先遍历当前 Spring 应用上下文中的 `beanFactoryPostProcessors`，如果是 BeanDefinitionRegistryPostProcessor 类型则进行处理
        for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) {
            if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) {
                BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor;
                // 执行
                registryProcessor.postProcessBeanDefinitionRegistry(registry);
                // 添加，以供后续执行其他 `postProcessBeanFactory(registry)` 方法
                registryProcessors.add(registryProcessor);
            }
            else {
                regularPostProcessors.add(postProcessor);
            }
        }

        // Do not initialize FactoryBeans here: We need to leave all regular beans
        // uninitialized to let the bean factory post-processors apply to them!
        // Separate between BeanDefinitionRegistryPostProcessors that implement
        // PriorityOrdered, Ordered, and the rest.
        // 临时变量，用于临时保存 BeanFactory 容器中的 BeanDefinitionRegistryPostProcessor 对象
        List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;();

        // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered.
        // &lt;1.2&gt; 获取底层 BeanFactory 容器中所有 BeanDefinitionRegistryPostProcessor 类型的 Bean 们，遍历进行处理
        String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
        for (String ppName : postProcessorNames) {
            // 如果实现了 PriorityOrdered 接口，则获取到对应的 Bean
            if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
                // 初始化
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                processedBeans.add(ppName);
            }
        }
        // 排序
        sortPostProcessors(currentRegistryProcessors, beanFactory);
        // 临时保存起来
        registryProcessors.addAll(currentRegistryProcessors);
        // 执行
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
        // 清理
        currentRegistryProcessors.clear();

        // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.
        // &lt;1.3&gt; 获取底层 BeanFactory 容器中所有 BeanDefinitionRegistryPostProcessor 类型的 Bean 们，遍历进行处理
        postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
        for (String ppName : postProcessorNames) {
            // 如果实现了 Ordered 接口并且没有执行过，则获取到对应的 Bean
            if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) { // Ordered类型
                // 初始化
                currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                processedBeans.add(ppName);
            }
        }
        // 排序
        sortPostProcessors(currentRegistryProcessors, beanFactory);
        // 临时保存起来
        registryProcessors.addAll(currentRegistryProcessors);
        // 执行
        invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
        // 清理
        currentRegistryProcessors.clear();

        // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear.
        boolean reiterate = true;
        while (reiterate) {
            reiterate = false;
            // &lt;1.4&gt; 获取底层 BeanFactory 容器中所有 BeanDefinitionRegistryPostProcessor 类型的 Bean 们，遍历进行处理
            postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false);
            for (String ppName : postProcessorNames) {
                // 如果该 BeanDefinitionRegistryPostProcessors 在上述过程中没有执行过，则获取到对应的 Bean
                if (!processedBeans.contains(ppName)) {
                    // 初始化
                    currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));
                    processedBeans.add(ppName);
                    reiterate = true;
                }
            }
            // 排序
            sortPostProcessors(currentRegistryProcessors, beanFactory);
            // 临时保存起来
            registryProcessors.addAll(currentRegistryProcessors);
            // 执行
            invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);
            // 清理
            currentRegistryProcessors.clear();
        }

        // Now, invoke the postProcessBeanFactory callback of all processors handled so far.
        /*
         * &lt;1.5&gt; 上述执行完当前 Spring 应用上下文和底层 BeanFactory 容器中所有 BeanDefinitionRegistryPostProcessor 处理器中的 postProcessBeanDefinitionRegistry(registry) 方法后，
         * 接下来执行它们的 postProcessBeanFactory(beanFactory) 方法
         *
         * 注意：BeanDefinitionRegistryPostProcessor 继承 BeanFactoryPostProcessor 接口
         */
        invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);
        /*
         * &lt;1.6&gt; 这里我们执行当前 Spring 应用上下文中 BeanFactoryPostProcessor 处理器（非 BeanDefinitionRegistryPostProcessors 类型）的
         * postProcessBeanFactory(beanFactory) 方法
         *
         * 例如：PropertyPlaceholderConfigurer、PropertySourcesPlaceholderConfigurer
         */
        invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);
    }

    // &lt;2&gt; 执行当前 Spring 应用上下文中的 BeanFactoryPostProcessor 处理器的 postProcessBeanFactory(beanFactory) 方法
    else {
        // Invoke factory processors registered with the context instance.
        invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);
    }

    // Do not initialize FactoryBeans here: We need to leave all regular beans
    // uninitialized to let the bean factory post-processors apply to them!
    // &lt;3&gt; 获取底层 BeanFactory 容器中所有 BeanFactoryPostProcessor 类型的 Bean 们
    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false);

    // Separate between BeanFactoryPostProcessors that implement PriorityOrdered,
    // Ordered, and the rest.
    List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
    List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
    List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
    for (String ppName : postProcessorNames) {
        if (processedBeans.contains(ppName)) { // 上面已经执行过了则跳过
            // skip - already processed in first phase above
        }
        else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) { // PriorityOrdered
            priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));
        }
        else if (beanFactory.isTypeMatch(ppName, Ordered.class)) { // Ordered
            orderedPostProcessorNames.add(ppName);
        }
        else { // nonOrder
            nonOrderedPostProcessorNames.add(ppName);
        }
    }

    // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered.
    // &lt;3.1&gt; PriorityOrdered 类型的 BeanFactoryPostProcessor 对象
    // 排序
    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
    // 执行
    invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);

    // Next, invoke the BeanFactoryPostProcessors that implement Ordered.
    // &lt;3.2&gt; Ordered 类型的 BeanFactoryPostProcessor 对象
    List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();
    for (String postProcessorName : orderedPostProcessorNames) {
        orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
    }
    // 排序
    sortPostProcessors(orderedPostProcessors, beanFactory);
    // 执行
    invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);

    // Finally, invoke all other BeanFactoryPostProcessors.
    // &lt;3.2&gt; nonOrdered 的 BeanFactoryPostProcessor 对象
    List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();
    for (String postProcessorName : nonOrderedPostProcessorNames) {
        nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));
    }
    // 无需排序，直接执行
    invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);

    // Clear cached merged bean definitions since the post-processors might have
    // modified the original metadata, e.g. replacing placeholders in values...
    beanFactory.clearMetadataCache();
}
</code></pre> 
<p>主要做以下事情：</p> 
<ol><li>如果当前 Spring 应用上下文是 BeanDefinitionRegistry 类型，则执行当前 Spring 应用上下文中所有 BeanDefinitionRegistryPostProcessor、BeanFactoryPostProcessor 的处理，以及底层 BeanFactory 容器中 BeanDefinitionRegistryPostProcessor 的处理，处理顺序如下： 
  <ol><li>当前 Spring 应用上下文中所有 BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry</li><li>底层 BeanFactory 容器中所有 BeanDefinitionRegistryPostProcessor#postProcessBeanDefinitionRegistry（优先级：PriorityOrdered &gt; Ordered &gt; 无）</li><li>当前 Spring 应用上下文和底层 BeanFactory 容器中所有 BeanDefinitionRegistryPostProcessor#postProcessBeanFactory</li><li>当前 Spring 应用上下文中所有 BeanFactoryPostProcessor#postProcessBeanFactory</li></ol></li><li>否则，执行当前 Spring 应用上下文中所有 BeanFactoryPostProcessor#postProcessBeanFactory</li><li>执行底层 BeanFactory 容器中所有 BeanFactoryPostProcessor#postProcessBeanFactory，上面已经处理过的会跳过，执行顺序和上面一样：PriorityOrdered &gt; Ordered &gt; 无</li></ol> 
<p>总结：有序地执行所有 BeanFactoryPostProcessor（包括 BeanDefinitionRegistryPostProcessor）处理器</p> 
<h4 id="5-beanfactory-注册-beanpostprocessor-阶段">5. BeanFactory 注册 BeanPostProcessor 阶段</h4> 
<p>将所有已加载出来的 BeanPostProcessor 类型的 BeanDefinition 通过依赖查找获取到 Bean 们，然后有序的添加至 BeanFactory 中</p> 
<p>AbstractApplicationContext#registerBeanPostProcessors(ConfigurableListableBeanFactory) 方法，如下：</p> 
<pre><code class="language-java">protected void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory) {
    PostProcessorRegistrationDelegate.registerBeanPostProcessors(beanFactory, this);
}
</code></pre> 
<p>这里也借助于 PostProcessorRegistrationDelegate 这个类注册所有 BeanPostProcessor 处理器，如下：</p> 
<pre><code class="language-java">public static void registerBeanPostProcessors(ConfigurableListableBeanFactory beanFactory, AbstractApplicationContext applicationContext) {

    // &lt;1&gt; 获取所有的 BeanPostProcessor 类型的 beanName
    // 这些 beanName 都已经全部加载到容器中去，但是没有实例化
    String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanPostProcessor.class, true, false);

    // Register BeanPostProcessorChecker that logs an info message when
    // a bean is created during BeanPostProcessor instantiation, i.e. when
    // a bean is not eligible for getting processed by all BeanPostProcessors.
    // &lt;2&gt; 记录所有的 BeanPostProcessor 数量，为什么加 1 ？因为下面又添加了一个
    int beanProcessorTargetCount = beanFactory.getBeanPostProcessorCount() + 1 + postProcessorNames.length;
    // 注册 BeanPostProcessorChecker，它主要是用于在 BeanPostProcessor 实例化期间记录日志
    // 当 Spring 中高配置的后置处理器还没有注册就已经开始了 bean 的实例化过程，这个时候便会打印 BeanPostProcessorChecker 中的内容
    beanFactory.addBeanPostProcessor(new BeanPostProcessorChecker(beanFactory, beanProcessorTargetCount));

    // Separate between BeanPostProcessors that implement PriorityOrdered, Ordered, and the rest.
    // &lt;3&gt; 开始注册 BeanPostProcessor
    // 实现了 `PriorityOrdered` 接口的 BeanPostProcessor 对应的 Bean 集合
    List&lt;BeanPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;();
    // MergedBeanDefinitionPostProcessor 类型对应的 Bean 集合
    List&lt;BeanPostProcessor&gt; internalPostProcessors = new ArrayList&lt;&gt;();
    // 实现了 `Ordered` 接口的 BeanPostProcessor 对应的 beanName 集合
    List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;();
    // 没有顺序的 BeanPostProcessor 对应的 beanName 集合
    List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;();
    for (String ppName : postProcessorNames) {
        // PriorityOrdered
        if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) {
            // 调用 getBean(...) 方法获取该 BeanPostProcessor 处理器的 Bean 对象
            BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
            priorityOrderedPostProcessors.add(pp);
            if (pp instanceof MergedBeanDefinitionPostProcessor) {
                internalPostProcessors.add(pp);
            }
        }
        // Ordered
        else if (beanFactory.isTypeMatch(ppName, Ordered.class)) {
            orderedPostProcessorNames.add(ppName);
        }
        // 无序
        else {
            nonOrderedPostProcessorNames.add(ppName);
        }
    }

    // First, register the BeanPostProcessors that implement PriorityOrdered.
    // 第一步，对所有实现了 PriorityOrdered 的 BeanPostProcessor 进行排序
    sortPostProcessors(priorityOrderedPostProcessors, beanFactory);
    // 进行注册，也就是添加至 DefaultListableBeanFactory 中
    registerBeanPostProcessors(beanFactory, priorityOrderedPostProcessors);

    // Next, register the BeanPostProcessors that implement Ordered.
    // 第二步，获取所有实现了 Ordered 接口的 BeanPostProcessor 对应的 Bean 们
    List&lt;BeanPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;();
    for (String ppName : orderedPostProcessorNames) {
        // 调用 getBean(...) 方法获取该 BeanPostProcessor 处理器的 Bean 对象
        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
        orderedPostProcessors.add(pp);
        if (pp instanceof MergedBeanDefinitionPostProcessor) {
            internalPostProcessors.add(pp);
        }
    }
    // 对所有实现了 Ordered 的 BeanPostProcessor 进行排序
    sortPostProcessors(orderedPostProcessors, beanFactory);
    // 进行注册，也就是添加至 DefaultListableBeanFactory 中
    registerBeanPostProcessors(beanFactory, orderedPostProcessors);

    // Now, register all regular BeanPostProcessors.
    // 第三步注册所有无序的 BeanPostProcessor
    List&lt;BeanPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;();
    for (String ppName : nonOrderedPostProcessorNames) {
        // 调用 getBean(...) 方法获取该 BeanPostProcessor 处理器的 Bean 对象
        BeanPostProcessor pp = beanFactory.getBean(ppName, BeanPostProcessor.class);
        nonOrderedPostProcessors.add(pp);
        if (pp instanceof MergedBeanDefinitionPostProcessor) {
            internalPostProcessors.add(pp);
        }
    }
    // 注册，无需排序
    registerBeanPostProcessors(beanFactory, nonOrderedPostProcessors);

    // Finally, re-register all internal BeanPostProcessors.
    // 最后，注册所有的 MergedBeanDefinitionPostProcessor 类型的 Bean 们
    sortPostProcessors(internalPostProcessors, beanFactory);
    registerBeanPostProcessors(beanFactory, internalPostProcessors);

    // Re-register post-processor for detecting inner beans as ApplicationListeners,
    // moving it to the end of the processor chain (for picking up proxies etc).
    // 重新注册 ApplicationListenerDetector（探测器），用于探测内部 ApplicationListener 类型的 Bean
    // 在完全初始化 Bean 后，如果是 ApplicationListener 类型且为单例模式，则添加到 Spring 应用上下文
    beanFactory.addBeanPostProcessor(new ApplicationListenerDetector(applicationContext));
}
</code></pre> 
<p>主要做以下事情：</p> 
<ol><li>获取所有 BeanPostProcessor 类型的 beanName</li><li>添加 BeanPostProcessor - BeanPostProcessorChecker，用于打印日志（所有 BeanPostProcessor 还没有全部实例化就有 Bean 初始化完成）</li><li>获取所有 BeanPostProcessor 实现类（依赖查找），添加至 BeanFactory 容器中（顺序：PriorityOrdered &gt; Ordered &gt; 无）</li><li>注意，第 <code>3</code> 步添加的 BeanPostProcessor 如果是 MergedBeanDefinitionPostProcessor 类型，会再次添加（先移除再添加，也就是将顺序往后挪）</li><li>重新添加 BeanPostProcessor - ApplicationListenerDetector，目的将其移至最后，因为这个后置处理器用于探测 ApplicationListener 类型的 Bean，需要保证 Bean 完全初始化，放置最后比较合适</li></ol> 
<blockquote> 
 <p>对与上述第 <code>4</code> 步是否疑惑？我的理解是 MergedBeanDefinitionPostProcessor 主要是依赖注入的实现，需要保证当前 Spring Bean 的相关初始化工作已完成，然后再进行依赖注入</p> 
</blockquote> 
<p>总结：将所有已加载出来的 BeanPostProcessor 类型的 BeanDefinition 通过依赖查找获取到 Bean 们，然后有序的添加至 BeanFactory 中</p> 
<h4 id="6-初始化内建-bean：messagesource">6. 初始化内建 Bean：MessageSource</h4> 
<p>AbstractApplicationContext#initMessageSource() 方法，如下：</p> 
<pre><code class="language-java">protected void initMessageSource() {
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    // 如果当前上下文中包含名称为 `messageSource` 的 Bean 对象
    if (beanFactory.containsLocalBean(MESSAGE_SOURCE_BEAN_NAME)) {
        this.messageSource = beanFactory.getBean(MESSAGE_SOURCE_BEAN_NAME, MessageSource.class);
        // 如果有父 ApplicationContext，并且 `messageSource` 为 HierarchicalMessageSource 对象，分级处理的 MessageSource
        if (this.parent != null &amp;&amp; this.messageSource instanceof HierarchicalMessageSource) {
            HierarchicalMessageSource hms = (HierarchicalMessageSource) this.messageSource;
            if (hms.getParentMessageSource() == null) {
                // Only set parent context as parent MessageSource if no parent MessageSource registered already.
                // 如果 `messageSource` 没有注册父 MessageSource，则设置为父类上下文的的 MessageSource
                hms.setParentMessageSource(getInternalParentMessageSource());
            }
        }
        if (logger.isTraceEnabled()) {
            logger.trace("Using MessageSource [" + this.messageSource + "]");
        }
    }
    else {
        // Use empty MessageSource to be able to accept getMessage calls.
        // 使用空 MessageSource
        DelegatingMessageSource dms = new DelegatingMessageSource();
        dms.setParentMessageSource(getInternalParentMessageSource());
        this.messageSource = dms;
        beanFactory.registerSingleton(MESSAGE_SOURCE_BEAN_NAME, this.messageSource);
        if (logger.isTraceEnabled()) {
            logger.trace("No '" + MESSAGE_SOURCE_BEAN_NAME + "' bean, using [" + this.messageSource + "]");
        }
    }
}
</code></pre> 
<p>初始化当前 Spring 应用上下文的 MessageSource 对象，MessageSource 对象和国际化文案相关，Spring 默认情况不提供国际化文案，但是 MessageSource Bean 对象（空实现）是存在的，在 Spring Boot 中有实现，参考 MessageSourceAutoConfiguration 自动装配类</p> 
<h4 id="7-初始化内建-bean：spring-事件广播器">7. 初始化内建 Bean：Spring 事件广播器</h4> 
<p>AbstractApplicationContext#initApplicationEventMulticaster() 方法，如下：</p> 
<pre><code class="language-java">protected void initApplicationEventMulticaster() {
    ConfigurableListableBeanFactory beanFactory = getBeanFactory();
    // 如果当前上下文中包含名称为 `applicationEventMulticaster` 的 Bean 对象
    if (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) {
        this.applicationEventMulticaster = beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);
    }
    else {
        // 没有则新建 SimpleApplicationEventMulticaster，并将该 Bean 注册至当前上下文
        this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory);
        beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, this.applicationEventMulticaster);
    }
}
</code></pre> 
<p>初始化当前 Spring 应用上下文的 ApplicationEventMulticaster 事件广播器对象，Spring 默认情况下为 SimpleApplicationEventMulticaster 对象</p> 
<h4 id="8应用上下文刷新扩展阶段">8.应用上下文刷新扩展阶段</h4> 
<p>AbstractApplicationContext#onRefresh() 方法，空方法，交由子类实现，如 AbstractRefreshableWebApplicationContext 的实现</p> 
<pre><code class="language-java">@Override
protected void onRefresh() {
    this.themeSource = UiApplicationContextUtils.initThemeSource(this);
}
</code></pre> 
<p>Web 场景下的 Spring 应用上下文会初始化 ThemeSource 对象</p> 
<h4 id="9-spring-事件监听器注册阶段">9. Spring 事件监听器注册阶段</h4> 
<p>AbstractApplicationContext#registerListeners() 方法，如下：</p> 
<pre><code class="language-java">protected void registerListeners() {
    // &lt;1&gt; 将当前 Spring 应用上下文已有的事件监听器依次添加至事件广播器
    for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) {
        getApplicationEventMulticaster().addApplicationListener(listener);
    }

    // Do not initialize FactoryBeans here: We need to leave all regular beans
    // uninitialized to let post-processors apply to them!
    // &lt;2&gt; 从底层 BeanFactory 容器中获取所有 ApplicationListener 类型的 beanName 们（还未初始化），然后依次添加至事件广播器
    String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false);
    for (String listenerBeanName : listenerBeanNames) {
        getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);
    }

    // Publish early application events now that we finally have a multicaster...
    //&lt;3&gt; 至此，已经完成将事件监听器全部添加至事件广播器，接下来将早期的事件通过该事件广播器广播到所有的事件监听器
    // 早期事件：在当前 Spring 应用上下文刷新的过程中已经发布的事件（此时发布不会被监听到，因为事件监听器才刚全部找到，需要到此处通过事件广播器进行广播）
    Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents;
    /**
     * 将 `earlyApplicationEvents` 置为 `null`
     * 这里很关键！！！后续发布的事件不再是早期事件，会立即被事件广播器广播。因为当前 Spring 应用中的事件广播器已经就绪了，事件监听器也都获取到了（虽然还没有初始化）
     * 不过在下面广播的时候，如果事件监听器能够处理该事件，则会通过依赖注入的方式初始化该事件监听器
     */
    this.earlyApplicationEvents = null;
    if (earlyEventsToProcess != null) {
        for (ApplicationEvent earlyEvent : earlyEventsToProcess) {
            // 广播该事件，能够处理该事件的事件监听器会被初始化
            getApplicationEventMulticaster().multicastEvent(earlyEvent);
        }
    }
}
</code></pre> 
<p>主要做以下事情：</p> 
<ol><li>将当前 Spring 应用上下文已有的事件监听器依次添加至事件广播器</li><li>从底层 BeanFactory 容器中获取所有 ApplicationListener 类型的 beanName 们（还未初始化），然后依次添加至事件广播器</li><li>复制全部的 <code>earlyApplicationEvents</code> <strong>早期事件</strong>，然后将 <code>earlyApplicationEvents</code> 置为 <code>null</code></li><li>广播<strong>早期事件</strong>，如果事件监听器能够处理该事件，则会通过依赖注入的方式初始化该事件监听器</li></ol> 
<p><strong>早期事件</strong>：在当前 Spring 应用上下文刷新的过程中已经发布的事件（此时发布不会被监听到，因为事件监听器才刚全部找到，需要到此处通过事件广播器进行广播）</p> 
<p>上面第 <code>3</code> 步会将 <code>earlyApplicationEvents</code> 置为 <code>null</code>，前面的 publishEvent 方法中你可以看到，如果该对象为 <code>null</code> 则会直接广播事件</p> 
<h4 id="10-beanfactory-初始化完成阶段">10. BeanFactory 初始化完成阶段</h4> 
<p>主要为底层 BeanFactory 容器设置 ConversionService 类型转换器，<strong>初始化</strong>所有还未初始化的 Bean（不是抽象、单例模式、不是懒加载方式）</p> 
<h5 id="finishbeanfactoryinitialization-方法">finishBeanFactoryInitialization 方法</h5> 
<p>AbstractApplicationContext#finishBeanFactoryInitialization(ConfigurableListableBeanFactory) 方法，如下：</p> 
<pre><code class="language-java">protected void finishBeanFactoryInitialization(ConfigurableListableBeanFactory beanFactory) {
    // 如果底层 BeanFactory 容器包含 ConversionService 类型转换器，则初始化并设置到底层 BeanFactory 容器的属性中
    if (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp; beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) {
        beanFactory.setConversionService(beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));
    }

    // 如果底层 BeanFactory 容器没有设置 StringValueResolver 解析器，则添加一个 PropertySourcesPropertyResolver 解析器
    if (!beanFactory.hasEmbeddedValueResolver()) {
        beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));
    }

    // Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.
    // 提前初始化 LoadTimeWeaverAware 类型的 Bean，AOP 相关
    String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, false, false);
    for (String weaverAwareName : weaverAwareNames) {
        getBean(weaverAwareName);
    }

    // Stop using the temporary ClassLoader for type matching.
    // 将临时的 ClassLoader 置为 null，它主要用于 AOP
    beanFactory.setTempClassLoader(null);

    // Allow for caching all bean definition metadata, not expecting further changes.
    // 冻结底层 BeanFactory 容器所有的 BeanDefinition，目的是不希望再去修改 BeanDefinition
    beanFactory.freezeConfiguration();

    // 【重点】初始化所有还未初始化的 Bean（不是抽象、单例模式、不是懒加载方式），依赖查找
    beanFactory.preInstantiateSingletons();
}
</code></pre> 
<p>我们看到最后一步，会调用 DefaultListableBeanFactory 的 preInstantiateSingletons() 方法，初始化所有还未初始化的 Bean（不是抽象、单例模式、不是懒加载方式），依赖查找</p> 
<h5 id="preinstantiatesingletons-方法">preInstantiateSingletons 方法</h5> 
<p>DefaultListableBeanFactory#preInstantiateSingletons() 方法，如下：</p> 
<pre><code class="language-java">@Override
public void preInstantiateSingletons() throws BeansException {
    if (logger.isTraceEnabled()) {
        logger.trace("Pre-instantiating singletons in " + this);
    }

    // Iterate over a copy to allow for init methods which in turn register new bean definitions.
    // While this may not be part of the regular factory bootstrap, it does otherwise work fine.
    // 复制一份本地的所有 beanNames 集合
    List&lt;String&gt; beanNames = new ArrayList&lt;&gt;(this.beanDefinitionNames);

    // Trigger initialization of all non-lazy singleton beans...
    // 遍历所有的 beanName
    for (String beanName : beanNames) {
        // 从容器中获取 beanName 相应的 RootBeanDefinition 对象
        RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);
        // 如果该 Bean 的定义为：不是抽象、单例模式、不是懒加载方式，则进行初始化
        if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) {
            // 如果是 FactoryBean 类型的 Bean
            if (isFactoryBean(beanName)) {
                // 初始化 FactoryBean 类型本身这个 Bean，注意这里在 beanName 的前面添加了一个 '&amp;'
                Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);
                // 如果这个 FactoryBean 为 SmartFactoryBean 类型，并且需要提前初始化
                // 则初始 beanName 对应的 Bean，也就是调用 FactoryBean 的 getObject() 方法
                if (bean instanceof FactoryBean) {
                    final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;
                    boolean isEagerInit;
                    if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) {
                        isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)
                                        ((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,
                                getAccessControlContext());
                    }
                    else {
                        isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());
                    }
                    if (isEagerInit) {
                        getBean(beanName);
                    }
                }
            }
            else {
                // 初始化 beanName 对应的 Bean
                getBean(beanName);
            }
        }
    }

    // Trigger post-initialization callback for all applicable beans...
    for (String beanName : beanNames) {
        Object singletonInstance = getSingleton(beanName);
        if (singletonInstance instanceof SmartInitializingSingleton) {
            final SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;
            if (System.getSecurityManager() != null) {
                AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; {
                    smartSingleton.afterSingletonsInstantiated();
                    return null;
                }, getAccessControlContext());
            }
            else {
                smartSingleton.afterSingletonsInstantiated();
            }
        }
    }
}
</code></pre> 
<p>首先会遍历所以的 <code>beanName</code>，如果该 Bean 的定义满足下面三个条件，则进行初始化过程</p> 
<ul><li>不是抽象</li><li>单例模式</li><li>不是懒加载方式</li></ul> 
<p>实际就是通过 <code>getBean(String beanName)</code> 方法进行初始化，在前面的 <a href="https://www.cnblogs.com/lifullmoon/p/14452795.html" rel="nofollow"><strong>《开启 Bean 的加载》</strong></a> 等文章中已经分析过了。注意，如果是 FactoryBean 类型的 Bean，需要先初始化 FactoryBean 本身这个 Bean，<code>beanName</code> 前面加 <code>&amp;</code>，然后再初始化这个 <code>beanName</code>，也就是调用 FactoryBean#getObject() 方法</p> 
<p>在初始化所有的 Bean 后，其实还有一个<strong>初始化完成阶段</strong>，会遍历所有已初始化好的 Bean，如果是 SmartInitializingSingleton 类型，则调用这个 Bean 的 afterSingletonsInstantiated() 方法</p> 
<blockquote> 
 <p>SmartInitializingSingleton 的作用？</p> 
 <p>通过 getBean(beanName) 初始化一个 Bean 的时候也会初始化依赖的对象，这样可能会出现过早的初始化问题（例如可能有些 BeanPostProcessor 还未添加进来就初始化了），导致相关 Bean 可能还未完全初始化，Spring 4.1 之后就提供了 SmartInitializingSingleton 接口机制让你可以确保 Bean 的初始化行为比较正常。</p> 
 <p>还有就是在所有的 Bean 完成初始化后，可以在这里进行注解的相关处理，例如 @EventListener 注解就是通过 EventListenerMethodProcessor 实现的，会将@EventListener 注解标注的方法解析成 ApplicationListener 事件监听器，并注册至 Spring 应用上下文。</p> 
</blockquote> 
<h4 id="11-应用上下文刷新完成阶段">11. 应用上下文刷新完成阶段</h4> 
<p>AbstractApplicationContext#finishRefresh() 方法，如下：</p> 
<pre><code class="language-java">protected void finishRefresh() {
    // Clear context-level resource caches (such as ASM metadata from scanning).
    // 清除当前 Spring 应用上下文中的缓存，例如通过 ASM（Java 字节码操作和分析框架）扫描出来的元数据
    clearResourceCaches();

    // Initialize lifecycle processor for this context.
    // 初始化 LifecycleProcessor 到当前上下文的属性中
    initLifecycleProcessor();

    // Propagate refresh to lifecycle processor first.
    // 通过 LifecycleProcessor 启动 Lifecycle 生命周期对象
    getLifecycleProcessor().onRefresh();

    // 发布 ContextRefreshedEvent 事件，会通过事件广播器进行广播，可通过自定义监听器在当前 Spring 应用上下文初始化完后进行相关操作
    publishEvent(new ContextRefreshedEvent(this));

    // Participate in LiveBeansView MBean, if active.
    // 如果当前 Spring 应用上下文的 Environment 环境中配置了 'spring.liveBeansView.mbeanDomain'
    // 则向 MBeanServer（JMX 代理层的核心）托管 Live Beans，也就是让 Spring Bean 桥接到 MBeanServer
    LiveBeansView.registerApplicationContext(this);
}
</code></pre> 
<p>主要做以下事情：</p> 
<ol><li>清除当前 Spring 应用上下文中的缓存，例如通过 ASM（Java 字节码操作和分析框架）扫描出来的元数据</li><li>初始化 LifecycleProcessor 到当前上下文的属性中</li><li>通过 LifecycleProcessor 启动 Lifecycle 生命周期对象</li><li>发布 <code>ContextRefreshedEvent</code> 上下文刷新完成事件，会通过事件广播器进行广播</li><li>如果当前 Spring 应用上下文的 Environment 环境中配置了 <code>spring.liveBeansView.mbeanDomain</code>，则向 MBeanServer（JMX 代理层的核心）托管 Live Beans，也就是让 Spring Bean 桥接到 MBeanServer</li></ol> 
<h4 id="总结">总结</h4> 
<p>ApplicationContext 就是大名鼎鼎的 Spring 应用上下文，底层 IoC 容器就是 DefaultListableBeanFactory 这个类，在它的基础上提供出更多的高级功能，更加适用于正式的应用环境。子类 AbstractApplicationContext 抽象类实现了大部分功能，调用它的 <code>refresh()</code> 方法可以让 Spring 应用上下文处于准备就绪状态，使用 Spring 都会显示或者隐式地调用该方法，这个方法中有非常多核心的步骤，这些步骤在上面的每个小节中依次进行分析过，具体过程可查看上面的每个小节。</p> 
<blockquote> 
 <p>AbstractApplicationContext#refresh() 方法在哪被调用？</p> 
 <p>可以看到我的另一篇文章<a href="https://www.cnblogs.com/lifullmoon/p/14131802.html" rel="nofollow">《精尽Spring MVC源码分析 - WebApplicationContext 容器的初始化》</a>，在 Spring MVC 启动过程中，创建 Spring 应用上下文后，（在 ContextLoader#configureAndRefreshWebApplicationContext 方法中）会调用其 <code>refresh()</code> 方法进行刷新，让 Spring 应用上下文准备就绪。</p> 
</blockquote> 
<p>至此，Spring IoC 的相关内容差不多都讲完了，关于 <code>@Bean</code> 等注解的处理在下一篇文章中进行分析。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/346e5149fba53ae48cab277d8046fc55/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">overflow: scroll隐藏滚动条的问题</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0cd53583046f99a4abca1a037a73d5ad/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">synchronized关键字详解</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>