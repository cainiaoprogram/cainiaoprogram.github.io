<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>C&#43;&#43;重温笔记(十): C&#43;&#43;输入输出流 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="C&#43;&#43;重温笔记(十): C&#43;&#43;输入输出流" />
<meta property="og:description" content="1. 写在前面 c&#43;&#43;在线编译工具，可快速进行实验: https://www.bejson.com/runcode/cpp920/
这段时间打算重新把c&#43;&#43;捡起来， 实习给我的一个体会就是算法工程师是去解决实际问题的，所以呢，不能被算法或者工程局限住，应时刻提高解决问题的能力，在这个过程中，我发现cpp很重要， 正好这段时间也在接触些c&#43;&#43;开发相关的任务，所有想借这个机会把c&#43;&#43;重新学习一遍。 在推荐领域， 目前我接触到的算法模型方面主要是基于Python， 而线上的服务全是c&#43;&#43;(算法侧， 业务那边基本上用go)，我们所谓的模型，也一般是训练好部署上线然后提供接口而已。所以现在也终于知道，为啥只单纯熟悉Python不太行了， cpp，才是yyds。
和python一样， 这个系列是重温，依然不会整理太基础性的东西，更像是查缺补漏， 不过，c&#43;&#43;对我来说， 已经5年没有用过了， 这个缺很大， 也差不多相当重学了， 所以接下来的时间， 重温一遍啦 😉
资料参考主要是C语言中文网和光城哥写的C&#43;&#43;教程，然后再加自己的理解和编程实验作为辅助，加深印象，当然有些地方我也会通过其他资料进行扩充。 关于更多的细节，还是建议看这两个教程。
今天这篇文章整理C&#43;&#43;关于输入和输出的操作，也就是我们所熟知的&#34;流&#34;操作， 我发现学习哪个语言，都需要学习它的I/O操作， 毕竟这是我们读数据和写数据的前提呀， C&#43;&#43;也不例外，通常，我们在C&#43;&#43;中使用cin输入流实现数据输入， cout输出流实现数据输出(输入和输出流本质上是已经定义好的类对象), 但是， 这只是流里面的冰山一小小角， 其实C&#43;&#43;输入流和输出流不仅实现基本的输入输出操作， 通过类内部成员函数， 还可以满足特殊场景的输入输出需求， 这又是一个很长很长的故事…
主要内容:
C&#43;&#43;输入流和输出流C&#43;&#43;输出单个字符(put)和字符串(write)C&#43;&#43;的tellp和seekp方法详解C&#43;&#43; cout的格式化输出C&#43;&#43;输入输出重定向C&#43;&#43;管理输出缓冲区C&#43;&#43;读取单个字符(get)和读入字符串(getline)C&#43;&#43;跳过指定字符(ignore)及查看输入流中的下一个字符(peek)C&#43;&#43; cin如何判断输入结束？C&#43;&#43;处理输入输出错误小总 Ok, let’s go!
2. C&#43;&#43;输入流和输出流 C语言有一套完成数据读写的解决方案:
scanf()、gets()等函数从键盘读取数据， printf()、puts()等向屏幕输出数据fscanf()、fgets()等函数读取文件中数据，fprintf()、fputs()向文件写入数据 这套I/O方案在C&#43;&#43;也同样适用，不过C&#43;&#43;还独立开发了一套全新I/O解决方案， 这套解决方案是我们所说的&#34;流类&#34;组成的类库。 整个流类以及它们的关系如下:
这些流类的功能也可以见名知意:
istream: 接收从键盘输入的数据ostream: 数据输出到屏幕ifstream: 读文件中的数据ofstream: 向文件写数据iostream: istream和ostream类功能合体，既可以从键盘输入，也可以输出到屏幕fstream: ifstream和ofstream类功能合体，既能读取文件数据，又能向文件写数据 之前学习的cin是istream对象， cout是ostream对象， 它们都声明在&lt;iostream&gt;中。除了cout, 头文件中还声明了2个对象，叫做cerr和clog， 它们用法和cout一样，只不过cerr常用来输出警告和错误信息， clog常用来输出程序执行中的日志信息。区别如下:
cout除了可以将数据输出到屏幕，还可以通过重定向，实现数据输出到指定文件； 而cerr和clog不支持重定向，只能将数据输出到屏幕cout和clog都有缓冲区， 它们输出数据时， 会先将数据放到缓冲区，等缓冲区满或手动换行时(换行符\n)，才会将数据全部显示到屏幕；cerr没有缓冲区，会直接将数据输出到屏幕。 其他的，这哥仨无不同。
std::cout &lt;&lt; &#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/852504322b2efa5d16af012de57adbce/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-01-04T14:41:49+08:00" />
<meta property="article:modified_time" content="2024-01-04T14:41:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">C&#43;&#43;重温笔记(十): C&#43;&#43;输入输出流</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="1__0"></a>1. 写在前面</h3> 
<p>c++在线编译工具，可快速进行实验: <a href="https://www.bejson.com/runcode/cpp920/" rel="nofollow">https://www.bejson.com/runcode/cpp920/</a></p> 
<p>这段时间打算重新把c++捡起来， 实习给我的一个体会就是算法工程师是去解决实际问题的，所以呢，不能被算法或者工程局限住，应时刻提高解决问题的能力，在这个过程中，我发现cpp很重要， 正好这段时间也在接触些c++开发相关的任务，所有想借这个机会把c++重新学习一遍。 在推荐领域， 目前我接触到的算法模型方面主要是基于Python， 而线上的服务全是c++(算法侧， 业务那边基本上用go)，我们所谓的模型，也一般是训练好部署上线然后提供接口而已。所以现在也终于知道，为啥只单纯熟悉Python不太行了， cpp，才是yyds。</p> 
<p>和python一样， 这个系列是重温，依然不会整理太基础性的东西，更像是查缺补漏， 不过，c++对我来说， 已经5年没有用过了， 这个缺很大， 也差不多相当重学了， 所以接下来的时间， 重温一遍啦 😉</p> 
<p>资料参考主要是<a href="http://c.biancheng.net/cplus/" rel="nofollow">C语言中文网</a>和<a href="https://light-city.club/sc/" rel="nofollow">光城哥写的C++教程</a>，然后再加自己的理解和编程实验作为辅助，加深印象，当然有些地方我也会通过其他资料进行扩充。 关于更多的细节，还是建议看这两个教程。</p> 
<p>今天这篇文章整理C++关于输入和输出的操作，也就是我们所熟知的"流"操作， 我发现学习哪个语言，都需要学习它的I/O操作， 毕竟这是我们读数据和写数据的前提呀， C++也不例外，通常，我们在C++中使用cin输入流实现数据输入， cout输出流实现数据输出(输入和输出流本质上是已经定义好的类对象), 但是， 这只是流里面的冰山一小小角， 其实C++输入流和输出流不仅实现基本的输入输出操作， 通过类内部成员函数， 还可以满足特殊场景的输入输出需求， 这又是一个很长很长的故事…</p> 
<p><strong>主要内容</strong>:</p> 
<ul><li>C++输入流和输出流</li><li>C++输出单个字符(put)和字符串(write)</li><li>C++的tellp和seekp方法详解</li><li>C++ cout的格式化输出</li><li>C++输入输出重定向</li><li>C++管理输出缓冲区</li><li>C++读取单个字符(get)和读入字符串(getline)</li><li>C++跳过指定字符(ignore)及查看输入流中的下一个字符(peek)</li><li>C++ cin如何判断输入结束？</li><li>C++处理输入输出错误</li><li>小总</li></ul> 
<p>Ok, let’s go!</p> 
<h3><a id="2_C_26"></a>2. C++输入流和输出流</h3> 
<p>C语言有一套完成数据读写的解决方案:</p> 
<ul><li>scanf()、gets()等函数从键盘读取数据， printf()、puts()等向屏幕输出数据</li><li>fscanf()、fgets()等函数读取文件中数据，fprintf()、fputs()向文件写入数据</li></ul> 
<p>这套I/O方案在C++也同样适用，不过C++还独立开发了一套全新I/O解决方案， 这套解决方案是我们所说的"流类"组成的类库。 整个流类以及它们的关系如下:<br> <img src="https://images2.imgbox.com/f9/1d/9rM6cyJy_o.png" alt="在这里插入图片描述"><br> 这些流类的功能也可以见名知意:</p> 
<ul><li>istream: 接收从键盘输入的数据</li><li>ostream: 数据输出到屏幕</li><li>ifstream: 读文件中的数据</li><li>ofstream: 向文件写数据</li><li>iostream: istream和ostream类功能合体，既可以从键盘输入，也可以输出到屏幕</li><li>fstream: ifstream和ofstream类功能合体，既能读取文件数据，又能向文件写数据</li></ul> 
<p>之前学习的cin是istream对象， cout是ostream对象， 它们都声明在<code>&lt;iostream&gt;</code>中。除了cout, 头文件中还声明了2个对象，叫做cerr和clog， 它们用法和cout一样，只不过cerr常用来输出警告和错误信息， clog常用来输出程序执行中的日志信息。区别如下:</p> 
<ul><li>cout除了可以将数据输出到屏幕，还可以通过重定向，实现数据输出到指定文件； 而cerr和clog不支持重定向，只能将数据输出到屏幕</li><li>cout和clog都有缓冲区， 它们输出数据时， 会先将数据放到缓冲区，等缓冲区满或手动换行时(换行符<code>\n</code>)，才会将数据全部显示到屏幕；cerr没有缓冲区，会直接将数据输出到屏幕。</li></ul> 
<p>其他的，这哥仨无不同。</p> 
<pre><code class="prism language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"cout："</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"wuzhongqiang"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"cerr："</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"wuzhongqiang"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>clog <span class="token operator">&lt;&lt;</span> <span class="token string">"clog："</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"wuzhongqiang"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl
</code></pre> 
<p>注意， 这里的cin, cout, cerr, clog等不是C++关键字，而是流对象。 另外，这里既然谈到了缓冲区， 我有些好奇，所以就先对缓冲区进行了下学习。</p> 
<blockquote> 
 <p>缓冲区，又称缓存，是内存空间的一部分。 即在内存空间中预留一定存储空间，用来缓冲输入和输出数据的。根据其对应是输入还是输出设备， 分为输入和输出缓冲区。<br> <img src="https://images2.imgbox.com/a4/41/80TtND7a_o.png" alt="在这里插入图片描述"><br> 缓冲区有三种类型:</p> 
 <ul><li>全缓冲: 当填满标准I/O缓存后才进行实际I/O操作，典型代表是对磁盘文件读写</li><li>行缓冲: 当在输入和输出遇到换行符时， 执行真正的I/O操作。典型代表是键盘输入数据， 我们输入的数据先存放在缓冲区，等按下回车换行时，才进行实际I/O操作。 
   <ul><li>既然说到cin上，就顺便解释下标准输入缓冲区， 这个放在上大学的时候，是没理解的了。</li><li>当我们从键盘输入字符串的时候， 需要敲一下回车键才能将这个字符串送入缓冲区， 而这个回车键，会转换成一个<code>'\n'</code>， 也被存储在cin缓冲区，并且这个东西也被当成一个字符。</li><li>cin读取数据时，是从缓冲区读取， 缓冲区为空， cin的成员函数会阻塞等待数据到来， 而一旦缓冲区有数据，就触发成员函数去读取数据</li></ul> </li><li>不带缓冲: 就像上面的cerr这种的，有出错信息尽快抛出来</li></ul> 
 <p><br>缓冲区会刷新的四种情况: 缓冲区满，执行flush， 执行endl， 关闭文件</p> 
</blockquote> 
<p>当然， 上面提到cin, cout, cerr和clog都是类对象，其实istream和ostream还提供了很多实用的函数， 供这几个类对象调用。 下面盘点下， 这些我们在日常中也常用，但其实有时候并不知道他们的区别。</p> 
<p>cin对象常用的一些成员方法以及功能:</p> 
<table><thead><tr><th>成员方法名</th><th>功能</th></tr></thead><tbody><tr><td>getline(str, n, ch)</td><td>从输入流中接收 n-1 个字符给 str 变量，当遇到指定 ch 字符时会停止读取，默认情况下 ch 为 ‘\0’</td></tr><tr><td>get()</td><td>从输入流中读取一个字符，同时该字符会从输入流中消失</td></tr><tr><td>gcount()</td><td>返回上次从输入流提取出的字符个数，该函数常和 get()、getline()、ignore()、peek()、read()、readsome()、putback() 和 unget() 联用</td></tr><tr><td>peek()</td><td>返回输入流中的第一个字符，但并不提取</td></tr><tr><td>putback()</td><td>将字符c置入输入流</td></tr><tr><td>ignore(n, ch)</td><td>从输入流中逐个提取字符，但提取出的字符被忽略，不被使用，直至提取出 n 个字符，或者当前读取的字符为 ch</td></tr><tr><td>operator&gt;&gt;</td><td>重载&gt;&gt;运算符，用于读取指定类型的数据， 并返回输入流对象本身</td></tr></tbody></table> 
<p>cout哥仨常用的一些成员方法及功能</p> 
<table><thead><tr><th>成员方法名</th><th>功能</th></tr></thead><tbody><tr><td>put()</td><td>输出单个字符</td></tr><tr><td>write()</td><td>输出指定字符串</td></tr><tr><td>tellp()</td><td>用于获取当前输入流指针的位置</td></tr><tr><td>seekp()</td><td>设置输出流指针位置</td></tr><tr><td>flush()</td><td>刷新输出流缓冲区</td></tr><tr><td>operator&lt;&lt;</td><td>重载&lt;&lt;运算符，使其用于输出其后指定类型数据</td></tr></tbody></table> 
<p>看个例子:</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> url<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 读取一行字符串</span>
    cin<span class="token punctuation">.</span><span class="token function">getline</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 输出上面读取字符个数</span>
    cout <span class="token operator">&lt;&lt;</span> cin<span class="token punctuation">.</span><span class="token function">gcount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token comment">// 输出出来</span>
    cout<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 此时输入hello world</span>
<span class="token comment">// 给到url的是hello wor   cin.gcount=9, 把9个字符给到url</span>
</code></pre> 
<h3><a id="3_Cputwrite_108"></a>3. C++输出单个字符(put)和字符串(write)</h3> 
<h4><a id="31_put_109"></a>3.1 <code>put()</code>函数</h4> 
<p>put()成员函数用于向输出流缓冲区添加单个字符， 函数原型如下:</p> 
<pre><code class="prism language-cpp">ostream＆<span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">char</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>可以看到， 该函数返回一个ostream类的引用对象， 可以理解为cout的引用，所以这玩意可以拼接输出:</p> 
<pre><code class="prism language-cpp">cout<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c3<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>应用实例:</p> 
<pre><code class="prism language-cpp">cout<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// a</span>
cout<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">65</span><span class="token operator">+</span><span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// a</span>
cout<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">97</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// a</span>

cout<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">71</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">79</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">79</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token number">68</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// GOOD</span>
</code></pre> 
<p>除了使用<code>cout.put()</code>函数输出一个字符外，可以用<code>putchar()</code>函数输出， 这个是C语言中使用的，在<code>&lt;stdio.h&gt;</code>中定义， C++保留了这个函数， 在<code>&lt;iostream&gt;</code>头文件中定义。</p> 
<p>OK， 这个<code>put()</code>函数，看似很简单， 但我有个问题，就是为啥要有这玩意呢？ 你要说输出单个字符， 我<code>cout&lt;&lt;</code>难道实现不了吗？ 这个问题， 勾起了我的好奇心， 首先， <code>cout.put()</code>是可以将字符的ASCII码转成字符直接输出的， 下面可以看这两个的不同：</p> 
<pre><code class="prism language-cpp">cout <span class="token operator">&lt;&lt;</span> <span class="token number">71</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// 71</span>
cout<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">71</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// G</span>

<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// 97</span>
cout<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment">// a</span>
</code></pre> 
<p>当然，为了这个问题， 我还特意查了下《C++ Primer Plus》，发现put()函数其实和历史有关，在C++2.0之前版本中， C++语言用int值表示字符串常量，比如下面这句话，是没法输出字符的:</p> 
<pre><code class="prism language-cpp">cout <span class="token operator">&lt;&lt;</span> <span class="token char">'W'</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>   <span class="token comment">// 87</span>

<span class="token keyword">char</span> ch <span class="token operator">=</span> <span class="token char">'W'</span><span class="token punctuation">;</span>  <span class="token comment">// 在早期版本中， 会从常量'W'中复制左边8位给到ch</span>
</code></pre> 
<p>'W’的编码87会存储在一个16位或者32位的单元中， 而char变量一般占8位。 所以对于cout， ch和’W’是天壤之别的，虽然存储的值可能相同。 所以那时候，如果想打印出字符来， 就需要</p> 
<pre><code class="prism language-cpp">cout<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token char">'W'</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">// W</span>
</code></pre> 
<p>不过C++2.0之后， C++字符常量存储已经改成了char类型，不是int类型了，所以cout可以正确处理字符常量。 <code>put()</code>函数我感觉用的并不是很多了现在。</p> 
<h4><a id="32_write_155"></a>3.2 <code>write()</code>函数</h4> 
<p>write()方法用于向输出缓冲区添加指定的字符串， 格式:</p> 
<pre><code class="prism language-cpp">ostream＆write（<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> s，streamsize n）<span class="token punctuation">;</span>  <span class="token comment">// s用于指定某个长度至少为n的字符数组或字符串， n表示输出前n个字符</span>
</code></pre> 
<p>这个函数同样返回了一个ostream类的引用对象，可以连着输出:</p> 
<pre><code class="prism language-cpp">cout<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>c1<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>c2<span class="token punctuation">.</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>c3<span class="token punctuation">.</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>下面演示一下这个方法， 这个函数感觉还是很强大的， 在C++没有切片的情况下，不一定能直接想到<code>cout&lt;&lt;</code>的替代方法。比如下面这个:</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    
    
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> w1 <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> w2 <span class="token operator">=</span> <span class="token string">"world"</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> len <span class="token operator">=</span> <span class="token function">strlen</span><span class="token punctuation">(</span>w1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        cout<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>w1<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 输出结果</span>
h
he
hel
hell
hello
hello
hellow
hellowo
hellowor
</code></pre> 
<p>如果不用python的这种切片， 这种对一个字符串，先输出前1个字符，再输出前2个字符，依次类推输出， 用<code>cout&lt;&lt;</code>一时还想出怎么搞，但<code>write()</code>函数就可以轻松搞定。</p> 
<p>但通过这个例子， 至少有两点能够看出来， 第一个就是<code>write()</code><strong>方法不会遇到空字符自动停止打印字符，而只是打印指定数目的字符，即使超出字符串的边界</strong>。看循环边界的len+5， 这显然已经超出了w1的范围， 但还是会打印， 打印到w2里面去了。 当然，这是我故意这么写的， 之所以用const限制，就是因为这样能使得w1和w2在内存中能连着放， 可以看的清晰些， 这是第二点。</p> 
<p>当然， <code>write()</code>方法， 也可以用于数值数据:</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">long</span> val <span class="token operator">=</span> <span class="token number">2397923872389</span><span class="token punctuation">;</span>
    cout<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>val<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 厦O.</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里会发现输出的是乱码， 这是因为这个强转操作， 不会将数字转成相应的字符， 而是传输内存中的位表示，4字节的long值，将作为4个独立字节传输。 输出设备把每个字节的ASCII码进行解释，所以，可能出来乱码。 但<code>write()</code>方法确实给数值数据存储在文件中提供了一种简洁， 准确的方式， 后面会整理， 但这个方法确实是很重要的一个方法。</p> 
<h3><a id="4_Ctellpseekp_213"></a>4. C++的tellp和seekp方法详解</h3> 
<p>cout输出普通数据(也包括<code>cout.put()</code>和<code>cout.write()</code>)， 数据都会先放到流缓冲区， 待缓冲区刷新，数据才会输出到指定位置。</p> 
<p>ostream类中的<code>tellp()</code>和<code>seekp()</code>成员方法， 是帮助我们<strong>修改暂存在输出流缓冲区里面的数据</strong>的。</p> 
<h4><a id="41_tellp_218"></a>4.1 tellp()成员方法</h4> 
<p>tellp()用于获取<strong>当前输出缓冲区中最后一个字符所在的位置</strong>， 语法如下:</p> 
<pre><code class="prism language-cpp">streampos <span class="token function">tellp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>tellp()不需要传任何参数， 会返回一个streampos类型值。</p> 
<p>streampos是fpos类型的别名，通过自动类型转换，可直接赋值给一个整形变量。即可以用一个整形变量接收该函数返回值。</p> 
<blockquote> 
 <p>注意，当输出流缓冲区中没有任何数据时，该函数返回的整形值为 0；当指定的输出流缓冲区不支持此操作，或者操作失败时，该函数返回的整形值为 -1</p> 
</blockquote> 
<p>下面我做了一个实验：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;cstring&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    std<span class="token double-colon punctuation">::</span>ofstream outfile<span class="token punctuation">;</span>
    
    outfile<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        outfile<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        
        <span class="token comment">// 获取当前输出流</span>
        <span class="token keyword">long</span> pos <span class="token operator">=</span> outfile<span class="token punctuation">.</span><span class="token function">tellp</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> pos <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>  <span class="token comment">// 1 2 3 4 5 6 7 8 9 10 11 </span>
        
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>程序每次向输出缓冲区放入字符， pos都表示当前字符的位置。</p> 
<p>这里另外想补充的一点，就是，一开始上面这个程序我尝试， 输出屏幕的时候进行定位，发现会报错。 结果搜了下， 感觉这个函数是用于在文件操作中定位内置指针位置的，一般在写文件的时候用。 另外，还有个和他类似的函数叫<code>tellg()</code>， 这个是用于读文件的时候获取内置指针的位置。</p> 
<p>总而言之：当我们读取一个文件，并要知道内置指针的当前位置时，应该使用<code>tellg()</code>；当我们写入一个文件，并要知道内置指针的当前位置时，应该使用<code>tellp()</code>.</p> 
<h4><a id="42_seekp_257"></a>4.2 seekp()成员方法</h4> 
<p><code>seekp()</code>方法用于指定下一个进入输出缓冲区的字符所在的位置。</p> 
<p>比如上面的hello world输出的时候，我们知道最后一个d的位置是11， 此时，如果继续向缓冲区存入数据， 则下一个字符所在位置应该是12， 但借助这个方法，我们可以手动指定下一个字符存放的位置。</p> 
<p>seekp() 方法有如下 2 种语法格式：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//指定下一个字符存储的位置</span>
ostream<span class="token operator">&amp;</span> <span class="token function">seekp</span> <span class="token punctuation">(</span>streampos pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//通过偏移量间接指定下一个字符的存储位置   </span>
ostream<span class="token operator">&amp;</span> <span class="token function">seekp</span> <span class="token punctuation">(</span>streamoff off<span class="token punctuation">,</span> ios_base<span class="token double-colon punctuation">::</span>seekdir way<span class="token punctuation">)</span><span class="token punctuation">;</span>

## 
off<span class="token operator">:</span> 相对于way位置的偏移量， 可以是正数可以是负数
way<span class="token operator">:</span> 指定偏移位置，即从哪里计算偏移量， 三种选择
	ios<span class="token double-colon punctuation">::</span>beg<span class="token operator">:</span> 文件开头开始计算
	ios<span class="token double-colon punctuation">::</span>end<span class="token operator">:</span> 文件末尾开始计算
	ios<span class="token double-colon punctuation">::</span>cur<span class="token operator">:</span> 当前位置开始计算
</code></pre> 
<p>seekp()返回的是引用形式的ostream对象，所以这东西还可以查看缓冲区里面某一位置上的字符</p> 
<pre><code class="prism language-cpp">cout<span class="token punctuation">.</span><span class="token function">seekp</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>看下面的例子：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token comment">//定义一个文件输出流对象</span>
    std<span class="token double-colon punctuation">::</span>ofstream outfile<span class="token punctuation">;</span>
    <span class="token comment">//打开 test.txt，等待接收数据</span>
    outfile<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
    <span class="token comment">//将 str 字符串中的字符逐个输出到 test.txt 文件中，每个字符都会暂时存在输出流缓冲区中</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">strlen</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        outfile<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> outfile<span class="token punctuation">.</span><span class="token function">tellp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 11</span>
    
    outfile<span class="token punctuation">.</span><span class="token function">seekp</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   
    <span class="token comment">// 等价于 outfile.seekp(6, ios::beg)  outfile.seekp(-6, ios::cur) outfile.seekp(-6, ios::end)</span>
    
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"新插入的位置: "</span> <span class="token operator">&lt;&lt;</span> outfile<span class="token punctuation">.</span><span class="token function">tellp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 新插入的位置: 6</span>
    
    <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>newstr <span class="token operator">=</span> <span class="token string">"C++"</span><span class="token punctuation">;</span>
    outfile<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>newstr<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> outfile<span class="token punctuation">.</span><span class="token function">tellp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 9</span>
    
    <span class="token comment">// 关闭文件之前， 刷新outfile输出缓冲区， 使所有字符由缓冲区流入test.txt文件</span>
    outfile<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 读入看看</span>
    std<span class="token double-colon punctuation">::</span>ifstream <span class="token function">File</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    <span class="token keyword">char</span> s<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    
    File<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> File<span class="token punctuation">.</span><span class="token function">tellg</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 9</span>
    std<span class="token double-colon punctuation">::</span>cout<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// hello C++</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>这里首先发现的第一个事情， <code>tellp()</code>是输出缓冲区末尾的位置， 这个末尾的意思不是最后一个字符位置其实，一开始缓冲区没有数据的时候， 此时<code>tellp()</code>指向0位置， 当插入一个字符之后， <code>tellp()</code>就后移了一下到了1位置，依次类推。当把hello world这11个字符全部插入， <code>tellp()</code>指向了第11个位置， 但注意hello world存放到了0~10. 所以准确的说，这个<code>tellp()</code>应该是最后一个字符的后面一个待插入字符位置。 这样，上面的结果才能说得通。</p> 
<p>第二个点，就是<code>tellg()</code>函数， 这里也演示了一下用法， 这个是在文件输入中获取当前的指针位置，由于hello C++也是存储到了0~8，所以<code>tellg()</code>这里和<code>tellp()</code>一样，其实也是最后一个字符后面一个位置。</p> 
<h3><a id="5_C_cout_322"></a>5. C++ cout格式化输出</h3> 
<p>某些实际场景中， 可能需要一定的格式输出数据， 比如保留几位小数等， C语言里面的printf()在输出数据时， 可以通过设定一些合理格式控制符， 来达到指定格式输出数据的目的。 比如%.2f， %#X表示十六进制等， 具体可以看<a href="http://c.biancheng.net/view/1793.html" rel="nofollow">这篇文章</a></p> 
<p>C++的cout在输出数据时， 实现格式化输出的方式更加多样， 一方面cout作为ostream类的对象， 该类中提供一些成员方法，可实现对输出数据格式化， 另一方面， C++专门提供了一个<code>&lt;iomanip&gt;</code>头文件， 这里面包含大量格式控制符。但这个没有涉及到原理性的东西，并且没有必要死记硬背， 会查即可，所以这个在这里也不整理， 可以直接看<a href="http://c.biancheng.net/view/7578.html" rel="nofollow">文档</a></p> 
<h3><a id="6_C_328"></a>6. C++输入输出重定向</h3> 
<p>什么是重定向？ 默认情况下， <code>cin</code>只能接收从键盘输入的数据， <code>cout</code>也只能将数据输出到屏幕上。 但通过重定向， <code>cin</code>可以将指定文件作为输入源， <code>cout</code>可以将原本要输出到屏幕上的数据写到指定文件。</p> 
<p>C++实现重定向常用方式有3种:</p> 
<h4><a id="61_freopen_333"></a>6.1 freopen()函数实现重定向</h4> 
<p>这个函数的定义在<code>&lt;stdio.h&gt;</code>头文件，C语言标准库中的函数，专门用于重定向输入流(<code>scanf(),gets()</code>)和输出流(<code>printf,puts</code>)。 但这个函数也可以对C++中的<code>cin</code>和<code>cout</code>重定向。</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;iostream&gt;</span>  </span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	<span class="token comment">// 标准输入流重定向到abc.in文件中</span>
	<span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"abc.in"</span><span class="token punctuation">,</span><span class="token string">"r"</span><span class="token punctuation">,</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">// 标准输出流重定向到abc.out文件中</span>
	<span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"abc.out"</span><span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">,</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> n<span class="token punctuation">;</span>
	cin<span class="token operator">&gt;&gt;</span>n<span class="token punctuation">;</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;=</span>n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> 
		cin<span class="token operator">&gt;&gt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment">// 这个在abc.in文件中读取</span>
	<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>n<span class="token punctuation">;</span> i<span class="token operator">&gt;=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>
		cout<span class="token operator">&lt;&lt;</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span><span class="token string">" "</span><span class="token punctuation">;</span>   <span class="token comment">// 输出到abc.out文件中</span>
	
	<span class="token comment">// 关闭重定向</span>
	<span class="token function">fclose</span><span class="token punctuation">(</span><span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">fclose</span><span class="token punctuation">(</span><span class="token constant">stdout</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="62_rdbuf_358"></a>6.2 rdbuf()函数实现重定向</h4> 
<p><code>rdbuf()</code>函数定义在<code>&lt;ios&gt;</code>头文件， 专门用于实现C++输入输出流重定向。</p> 
<p>语法格式有两种：</p> 
<pre><code class="prism language-cpp">streambuf <span class="token operator">*</span><span class="token function">rdbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>   <span class="token comment">// 返回一个指向当前缓冲区的类</span>
streambuf <span class="token operator">*</span><span class="token function">rdbuf</span><span class="token punctuation">(</span>streambuf <span class="token operator">*</span>sb<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将sb指向的缓冲区设置为当前流的新缓冲区，并返回一个指向旧缓冲区的对象</span>
</code></pre> 
<p>第二个函数好好理解下， 是sb指向的缓冲区设置为当前流的新缓冲区，但返回的是一个指向原先缓冲区的对象。<code>streambuf</code>是C++标准库中用于表示缓冲区的类，该类的指针对象用于代指某个具体的流缓冲区。</p> 
<p>看个例子：</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;fstream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
 
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token comment">// 打开in.txt文件，等待读取</span>
    ifstream <span class="token function">fin</span><span class="token punctuation">(</span><span class="token string">"in.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 打开out.txt 文件， 等待写入</span>
    ofstream <span class="token function">fout</span><span class="token punctuation">(</span><span class="token string">"out.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    streambuf <span class="token operator">*</span>oldcin<span class="token punctuation">;</span>
    streambuf <span class="token operator">*</span>oldcout<span class="token punctuation">;</span>
    
    <span class="token keyword">char</span> a<span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 用rdbuf()重新定向， 返回旧输入流缓冲区指针</span>
    oldcin <span class="token operator">=</span> cin<span class="token punctuation">.</span><span class="token function">rdbuf</span><span class="token punctuation">(</span>fin<span class="token punctuation">.</span><span class="token function">rdbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cin <span class="token operator">&gt;&gt;</span> a<span class="token punctuation">;</span>   <span class="token comment">// 从input.txt文件读入</span>
    
    <span class="token comment">// 用rdbuf()重新定向， 返回旧输出流缓冲区指针</span>
    oldcout <span class="token operator">==</span> cout<span class="token punctuation">.</span><span class="token function">rdbuf</span><span class="token punctuation">(</span>fout<span class="token punctuation">.</span><span class="token function">rdbuf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>   <span class="token comment">// 写入out.txt</span>
    
    <span class="token comment">// 还原标准输入输出流, 恢复键盘输入和输出</span>
    cin<span class="token punctuation">.</span><span class="token function">rdbuf</span><span class="token punctuation">(</span>oldcin<span class="token punctuation">)</span><span class="token punctuation">;</span>
    cout<span class="token punctuation">.</span><span class="token function">rdbuf</span><span class="token punctuation">(</span>oldcout<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">// 打开的文件要手动关闭</span>
    fin<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    fout<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<h4><a id="63__406"></a>6.3 控制台实现重定向</h4> 
<p>这个的意思是在控制到执行.exe的时候， 通过后面添加参数的方式实现重定向。</p> 
<p>比如写个程序:</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    string name<span class="token punctuation">,</span> url<span class="token punctuation">;</span>
    cin <span class="token operator">&gt;&gt;</span> name <span class="token operator">&gt;&gt;</span> url<span class="token punctuation">;</span>
    cout <span class="token operator">&lt;&lt;</span> name <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span> <span class="token operator">&lt;&lt;</span> url<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>此时编译链接， 会生成一个demo.exe的可执行文件。 然后再控制台执行这个可执行文件的时候，后面指定上参数:</p> 
<pre><code class="prism language-cpp">C<span class="token operator">:</span>\Users\mengma<span class="token operator">&gt;</span>D<span class="token operator">:</span>\demo<span class="token punctuation">.</span>exe <span class="token operator">&lt;</span>in<span class="token punctuation">.</span>txt <span class="token operator">&gt;</span>out<span class="token punctuation">.</span>txt
</code></pre> 
<p>执行后会发现，控制台没有任何输出。这是因为，我们使用了"&lt;in.txt"对程序中的 cin 输入流做了重定向，同时还用 "&gt;out.txt"对程序中的 cout 输出流做了重定向。</p> 
<h3><a id="7_C_430"></a>7. C++管理输出缓冲区</h3> 
<p>每个输出流都管理一个缓冲区，用来保存程序读写的数据。比如下面代码：</p> 
<pre><code class="prism language-cpp">cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hello world"</span><span class="token punctuation">;</span>
</code></pre> 
<p>字符串可能立即打印，也有可能os先保存到缓冲区，然后再打印。</p> 
<blockquote> 
 <p>有了缓冲机制，os可以将程序多个输出操作组合成单一的系统级写操作。 这样可以带来性能提升，因为写操作可能很耗时。</p> 
</blockquote> 
<p>导致缓冲区刷新(数据真正写到输出设备或文件)的原因如下:</p> 
<ol><li>程序正常结束，作为<code>main()</code>函数的return操作的一部分， 缓冲刷新被执行。</li><li>缓冲区满时， 需要刷新缓冲区</li><li>使用操纵符如endl来显式刷新缓冲区</li><li>在每个输出操作之后，可以用操纵符unitbuf设置流的内部状态，来清空缓冲区。 默认情况下，对cerr是设置unitbuf的，因此写到cerr得的内容都是立即刷新</li><li>一个输出流可能被关联到另一个流。这种情况下，当读写被关联的流时， 关联到的流的缓冲区会被刷新。 默认情况下，cin和cerr都关联到cout。 因此读cin或者写cerr都会导致cout的缓冲区被刷新。</li></ol> 
<p>后三个详细理解下。</p> 
<h4><a id="71__447"></a>7.1 操纵符显示刷新</h4> 
<p>之前使用过操作符endl， 它完成换行并刷新缓冲区的工作。 IO库中还有两个类似操作符flush和ends:</p> 
<ol><li>flush刷新缓冲区，但不输出任何额外的字符。 值得一提，cout 所属 ostream 类中还提供有 <code>flush()</code> 成员方法，它和 flush 操纵符的功能完全一样，仅在使用方法上（ <code>cout.flush()</code> ）有区别。</li><li>ends向缓冲区插入一个空字符， 然后刷新缓冲区</li></ol> 
<p>比如:</p> 
<pre><code class="prism language-cpp">cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hi!"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>  <span class="token comment">//输出hi和一个换行，然后刷新缓冲区</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hi!"</span> <span class="token operator">&lt;&lt;</span> flush<span class="token punctuation">;</span>  <span class="token comment">//输出hi，然后刷新缓冲区，不附加任何额外字符 等价于cout &lt;&lt; "hi!"; cout.flush();</span>
cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hi!"</span> <span class="token operator">&lt;&lt;</span> ends<span class="token punctuation">;</span>  <span class="token comment">//输出hi和一个空字符，然后刷新缓冲区</span>
</code></pre> 
<h4><a id="72_unitbuf_459"></a>7.2 unitbuf操作符</h4> 
<p>如果想在每次输出操作后都刷新缓冲区，我们可以使用 <code>unitbuf</code> 操作符，它告诉流在接下来的每次写操作之后都进行一次 <code>flush</code> 操作。而 <code>nounitbuf</code> 操作符则重置流， 使其恢复使用正常的系统管理的缓冲区刷新机制：</p> 
<pre><code class="prism language-cpp">cout <span class="token operator">&lt;&lt;</span> unitbuf<span class="token punctuation">;</span>  <span class="token comment">//所有输出操作后都会立即刷新缓冲区</span>
<span class="token comment">//任何输出都立即刷新，无缓冲</span>
cout <span class="token operator">&lt;&lt;</span> nounitbuf<span class="token punctuation">;</span>  <span class="token comment">//回到正常的缓冲方式</span>
</code></pre> 
<p>如果程序异常终止， 输出缓冲区是不会被刷新的。</p> 
<blockquote> 
 <p>当调试一个已经崩溃的程序时，需要确认那些你认为已经输出的数据确实已经刷新了。否则，可能将大量时间浪费在追踪代码为什么没有执行上，而实际上代码已经执行了，只是程序崩溃后缓冲区没有被刷新，输出数据被挂起没有打印而已。</p> 
</blockquote> 
<h4><a id="73__470"></a>7.3 关联输入和输出流</h4> 
<p>当一个输入流被关联到一个输出流时， 任何试图从输入流读取数据的操作都会先刷新关联的输出流。 标准库的cout和cin关联在一起，所以执行:</p> 
<pre><code class="prism language-cpp">cin <span class="token operator">&gt;&gt;</span> name<span class="token punctuation">;</span>
</code></pre> 
<p>会导致cout的缓冲区被刷新。</p> 
<blockquote> 
 <p>交互式系统通常应该关联输入流和输出流。这意味着所有输出，包括用户提示信息，都会在读操作之前被打印出来。</p> 
</blockquote> 
<p><code>tie()</code>函数可以用来绑定输出流:</p> 
<pre><code class="prism language-cpp">ostream<span class="token operator">*</span> <span class="token function">tie</span> <span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>  <span class="token comment">//返回指向绑定的输出流的指针。</span>
ostream<span class="token operator">*</span> <span class="token function">tie</span> <span class="token punctuation">(</span> ostream<span class="token operator">*</span> os <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将 os 指向的输出流绑定的该对象上，并返回上一个绑定的输出流指针。</span>
</code></pre> 
<p>我们可以将一个istream对象关联到另一个ostream， 也可以将一个ostream关联到另一个ostream。</p> 
<pre><code class="prism language-cpp">cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cout<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//仅仅是用来展示，标准库已经将 cin 和 cout 关联在一起</span>

<span class="token comment">//old_tie 指向当前关联到 cin 的流（如果有的话）</span>
ostream <span class="token operator">*</span>old_tie <span class="token operator">=</span> cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// cin 不再与其他流关联</span>

<span class="token comment">//将 cin 与 cerr 关联，这不是一个好主意，因为 cin 应该关联到 cout</span>
cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cerr<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//读取 cin 会刷新 cerr 而不是 cout</span>

cin<span class="token punctuation">.</span><span class="token function">tie</span><span class="token punctuation">(</span>old_tie<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//重建 cin 和 cout 间的正常关联</span>
</code></pre> 
<p>在这段代码中，为了将一个给定的流关联到一个新的输出流，我们将新流的指针传递给了 <code>tie()</code>。为了彻底解开流的关联，我们传递了一个空指针。每个流同时最多关联到一个流， 但多个流可以同时关联到同一个ostream。</p> 
<h3><a id="8_Cgetgetline_500"></a>8. C++读取单个字符(get)和读入字符串(getline)</h3> 
<p>上面整理的输出， 下面我们看输入部分。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p><code>get()</code>函数是istream类的成员函数， 用于从输入流中读入一个字符，返回该值字符的ASCII码。如果碰到输入的末尾， 就返回EOF。</p> 
<blockquote> 
 <p>EOF是End of File的缩写。 istream类从输入流读取数据的成员函数， 在把输入数据都读取完后，再进行读取就返回EOF。 EOF是iostream类中定义的一个整型常量，值为-1</p> 
</blockquote> 
<p>这个让我想起了这个语句：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> c<span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	cout<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>get()</code>函数不会跳过空格，制表符，回车等特殊字符，所有字符都能被输入。</p> 
<p>如果要读取文件的字符， 可以使用上面重定向的知识：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> c<span class="token punctuation">;</span>
<span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c<span class="token operator">=</span>cin<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
	cout<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>那么，如果想读入一行字符串怎么办呢？</p> 
<p>这时候，就可以用<code>getline()</code>函数。</p> 
<pre><code class="prism language-cpp">istream <span class="token operator">&amp;</span><span class="token function">getline</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">int</span> bufSize<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 从输入流读取bufSize-1个字符到缓冲区buf，或遇到\n位置。 函数会自动在buf读入数据的结尾添加\0</span>
istream <span class="token operator">&amp;</span><span class="token function">getline</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token keyword">int</span> bufSize<span class="token punctuation">,</span> <span class="token keyword">char</span> delim<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这个是读到delim字符位置， 而不是读到\n了，并且\n和delim字符都不会读入到buf，但会被从输入流中取走</span>
</code></pre> 
<p>两个函数返回值就是函数所作用的对象的引用。如果输入流中\n或delim之前的字符个数达到bufSize， 就会导致读入出错，结果是: 虽本次读入已经完成，但之后的读入会失败。</p> 
<p>从输入流读入一行，可以用上面第一个， <code>cin&gt;&gt;str</code>这个不行，因为这种读法遇到行中的空格或制表符就会停止，因此不能保证str读入的是整行。 像<code>get, getline</code>这种，也称为非格式化输入方法。因为它们只是读取字符输入，并不会跳过空白，也不会转换数据格式。</p> 
<p>下面看一个例子：</p> 
<pre><code class="prism language-cpp"><span class="token keyword">char</span> szBuf<span class="token punctuation">[</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token number">120</span><span class="token punctuation">;</span>

<span class="token comment">// 如果输入流中一行字符超过5个，就会出错</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>cin<span class="token punctuation">.</span><span class="token function">getline</span><span class="token punctuation">(</span>szBuf<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	cout <span class="token operator">&lt;&lt;</span> <span class="token string">"error"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> szBuf <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

<span class="token comment">// 测试下还能不能读入了</span>
cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>

<span class="token comment">// clear能清楚cin内部的错误，使之恢复正常</span>
cin<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
</code></pre> 
<p>测试一:</p> 
<p><img src="https://images2.imgbox.com/e7/f3/gY7Xpq3r_o.png" alt="在这里插入图片描述"><br> 这个没有任何问题， 因为一开始<code>ab cd</code>，这一行输入流中字符没超过5， getline不会出错，下面的都能正常读入。</p> 
<p>测试二：<br> <img src="https://images2.imgbox.com/25/e7/8WHI8RCO_o.png" alt="在这里插入图片描述"><br> 这个就出问题了， 第一行的输入<code>ab cd123456k</code>是不符合<code>cin.getline(szBuf, 6)</code>的，所以这个会直接保存，但是呢？ 这个函数依然会把<code>ab cd</code>四个字符读入给到szBuf。但后面n这个就不能正常读入了，所以n这个直接是输出默认值120. 当执行<code>cin.clear()</code>之后， 消除错误，恢复正常，此时又能正常读入， 但此时从错误出开始， 读入了123456， 因为n定义的是整数，所以k不会被读进来。</p> 
<p>可以用 <code>getline()</code> 函数的返回值（为 false 则输入结束）来判断输入是否结束。例如，要将文件 test.txt 中的全部内容（假设文件中一行最长有 10 000个字符）原样显示</p> 
<pre><code class="prism language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> MAX_LINE_LEN <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span>  <span class="token comment">//假设文件中一行最长 10000 个字符</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">char</span> szBuf<span class="token punctuation">[</span>MAX_LINE_LEN <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">freopen</span><span class="token punctuation">(</span><span class="token string">"test.txt"</span><span class="token punctuation">,</span> <span class="token string">"r"</span><span class="token punctuation">,</span> <span class="token constant">stdin</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将标准输入重定向为 test.txt</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin<span class="token punctuation">.</span><span class="token function">getline</span><span class="token punctuation">(</span>szBuf<span class="token punctuation">,</span> MAX_LINE_LEN <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        cout <span class="token operator">&lt;&lt;</span> szBuf <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>程序每次读入文件中的一行到 szBuf 并输出。szBuf 中不会读入回车符，因此输出 szBuf 后要再输出 endl 以换行。</p> 
<h3><a id="9Cignorepeek_583"></a>9.C++跳过指定字符ignore及查看输入流中的下一个字符peek</h3> 
<p><code>ignore()</code>是istream类成员函数，原型</p> 
<pre><code class="prism language-cpp">istream <span class="token operator">&amp;</span> <span class="token function">ignore</span><span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> delim <span class="token operator">=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>此函数的作用是跳过输入流中的 n 个字符，或跳过 delim 及其之前的所有字符，哪个条件先满足就按哪个执行。两个参数都有默认值，因此 <code>cin.ignore()</code> 就等效于 <code>cin.ignore(1, EOF)</code>， 即跳过一个字符。</p> 
<p>该函数常用于跳过输入中的无用部分，提取有用部分。</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> n<span class="token punctuation">;</span>
cin<span class="token punctuation">.</span><span class="token function">ignore</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token char">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>
cout <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">;</span>

<span class="token comment">// 输入abcde34     跳过5个字符，   n=34</span>
<span class="token comment">// 输入abA67  先遇到了A， 跳过abA， n=67</span>
</code></pre> 
<p><code>peek()</code>函数是istream类成员函数，原型:</p> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>这个函数返回输入流中的下一个字符，但并不会将该字符重输入流中取走。 类似于栈的<code>gettop()</code>。</p> 
<p><code>cin.peek()</code>不会跳过输入流中的空格，回车符。输入流已经结束的情况下， <code>cin.peek()</code>返回EOF。</p> 
<p>在输入数据的格式不同，需要预先判断格式再决定如何读取输入时，<code>peek()</code> 就能起到作用。</p> 
<blockquote> 
 <p>比如编写一个日期转换函数， 输入是若干个日期， 每行一个，有中式格式"2011.12.24"也有西式格式"Dec 24 2011"，而输出全部转成"yyyy-mm-dd"的格式。</p> 
</blockquote> 
<p>这时候在读入之前，就需要先试探一下是大写字母开头，还是数字开头，先把西式和中式分开， 然后再cin了。 具体代码如下:</p> 
<pre><code class="prism language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iomanip&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
string Months<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token string">"Jan"</span><span class="token punctuation">,</span><span class="token string">"Feb"</span><span class="token punctuation">,</span><span class="token string">"Mar"</span><span class="token punctuation">,</span><span class="token string">"Apr"</span><span class="token punctuation">,</span><span class="token string">"May"</span><span class="token punctuation">,</span><span class="token string">"Jun"</span><span class="token punctuation">,</span><span class="token string">"Jul"</span><span class="token punctuation">,</span><span class="token string">"Aug"</span><span class="token punctuation">,</span> <span class="token string">"Sep"</span><span class="token punctuation">,</span><span class="token string">"Oct"</span><span class="token punctuation">,</span><span class="token string">"Nov"</span><span class="token punctuation">,</span><span class="token string">"Dec"</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> c<span class="token punctuation">;</span>
    <span class="token comment">// 先进行试探 取输入流中第一个字符先看看</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>c <span class="token operator">=</span> cin<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token constant">EOF</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">char</span><span class="token punctuation">(</span>cin<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> day<span class="token punctuation">;</span>
        <span class="token comment">// 美国日期格式</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">&gt;=</span> <span class="token char">'A'</span> <span class="token operator">&amp;&amp;</span> c <span class="token operator">&lt;=</span> <span class="token char">'Z'</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
            string sMonth<span class="token punctuation">;</span>
            cin <span class="token operator">&gt;&gt;</span> sMonth <span class="token operator">&gt;&gt;</span> day <span class="token operator">&gt;&gt;</span> year<span class="token punctuation">;</span>
            <span class="token comment">// 转成中式月份</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">12</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>sMonth <span class="token operator">==</span> Months<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                    month <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
                    <span class="token keyword">break</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
            <span class="token comment">// 中国日期格式</span>
            cin <span class="token operator">&gt;&gt;</span> year<span class="token punctuation">;</span>
            cin<span class="token punctuation">.</span><span class="token function">ignore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> month<span class="token punctuation">;</span>  <span class="token comment">// ignore忽略.</span>
            cin<span class="token punctuation">.</span><span class="token function">ignore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> day<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        cin<span class="token punctuation">.</span><span class="token function">ignore</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 跳过末尾的'\n'</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> year <span class="token operator">&lt;&lt;</span> <span class="token string">"-"</span> <span class="token operator">&lt;&lt;</span> <span class="token function">setfill</span><span class="token punctuation">(</span><span class="token char">'0'</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> month <span class="token operator">&lt;&lt;</span> <span class="token string">"-"</span> <span class="token operator">&lt;&lt;</span> <span class="token function">setw</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> day <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>结果如下:<br> <img src="https://images2.imgbox.com/36/c5/ObbN4Ppu_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="10_C_cin_654"></a>10. C++ cin如何判断输入结束？</h3> 
<p>cin 可以用来从键盘输入数据；将标准输入重定向为文件后，cin 也可以用来从文件中读入数据。在输入数据的多少不确定，且没有结束标志的情况下，该如何判断输入数据已经读完了呢？</p> 
<blockquote> 
 <p>文件末尾，还是 Ctrl+Z 或者 Ctrl+D，它们都是结束标志；cin 在正常读取时返回 true，遇到结束标志时返回 false，我们可以根据 cin 的返回值来判断是否读取结束。</p> 
</blockquote> 
<pre><code class="prism language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    <span class="token keyword">int</span> maxN <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>cin <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>  <span class="token comment">//输入没有结束，cin 就返回 true，条件就为真</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>maxN <span class="token operator">&lt;</span> n<span class="token punctuation">)</span>
            maxN <span class="token operator">=</span> n<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    cout <span class="token operator">&lt;&lt;</span> maxN <span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p><code>cin&gt;&gt;n</code>的返回值的确是 <code>istream &amp;</code> 类型的，而 while 语句中的条件表达式的返回值应该是 bool 类型、整数类型或其他和整数类型兼容的类型，<code>istream &amp;</code> 显然和整数类型不兼容，为什么<code>while(cin&gt;&gt;n)</code>还能成立呢？</p> 
<blockquote> 
 <p>这是因为，istream 类对强制类型转换运算符 bool 进行了重载，这使得 cin 对象可以被自动转换成 bool 类型。所谓自动转换的过程，就是调用 cin 的 <code>operator bool()</code> 这个成员函数，而该成员函数可以返回某个标志值，该标志值在 cin 没有读到输入结尾时为 true，读到输入结尾后变为 false。</p> 
</blockquote> 
<p>如果cin在读取过程中发生了错误， <code>cin&gt;&gt;n</code>表达式也会返回false，比如一个int型的n，输入进去的是个字母。</p> 
<h3><a id="11_C_675"></a>11. C++处理输入输出错误</h3> 
<p>这一块目前用的不多， 详细的可以去中文网的文档中看，这里简单整理下C++中会把输入输出时发生的错误归为四类，称为流状态，并且用四个标志位来表示，而每个标志位都对应着检测函数。</p> 
<table><thead><tr><th>检测函数</th><th>对应的标志位</th><th>说明</th></tr></thead><tbody><tr><td>good()</td><td>goodbit</td><td>操作成功，没有发生任何错误</td></tr><tr><td>eof()</td><td>eofbit</td><td>到达输入末尾或文件末尾</td></tr><tr><td>fail()</td><td>failbit</td><td>发生某些意外错误，比如要读入一个数字，却读入了字符</td></tr><tr><td>bad()</td><td>badbit</td><td>发生严重错误，比如磁盘读故障</td></tr></tbody></table> 
<p>这时候，我们想让程序更加鲁棒的话，就应该考虑到这些问题，并及时采取相应的方案，下面是一个简单例子：</p> 
<pre><code class="prism language-cpp"><span class="token comment">//从 ist 中读入整数到 v 中，直到遇到 eof() 或终结符</span>
<span class="token keyword">void</span> <span class="token function">fill_vector</span><span class="token punctuation">(</span>istream<span class="token operator">&amp;</span> ist<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> v<span class="token punctuation">,</span> <span class="token keyword">char</span> terminator<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
    <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">int</span> i<span class="token punctuation">;</span> ist<span class="token operator">&gt;&gt;</span>i<span class="token punctuation">;</span> <span class="token punctuation">)</span> v<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//正常情况</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ist<span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment">//发现到了文件尾，正确，返回</span>
    <span class="token comment">//发生严重错误，只能退出函数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ist<span class="token punctuation">.</span><span class="token function">bad</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"cin is bad!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//error是自定义函数，它抛出异常，并给出提示信息</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//发生意外情况</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ist<span class="token punctuation">.</span><span class="token function">fail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>  <span class="token comment">//最好清除混乱，然后汇报问题</span>
        ist<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//清除流状态</span>
        <span class="token comment">//检测下一个字符是否是终结符</span>
        <span class="token keyword">char</span> c<span class="token punctuation">;</span>
        ist<span class="token operator">&gt;&gt;</span>c<span class="token punctuation">;</span>  <span class="token comment">//读入一个符号，希望是终结符</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>c <span class="token operator">!=</span> terminator<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span> <span class="token comment">// 非终结符</span>
            ist<span class="token punctuation">.</span><span class="token function">unget</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//放回该符号</span>
            ist<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span>ios_base<span class="token double-colon punctuation">::</span>failbit<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将流状态设置为 fail()</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="12__709"></a>12. 小总</h3> 
<p>这里依然是一张思维导图拎起来:</p> 
<p><img src="https://images2.imgbox.com/21/e4/AH6pumR8_o.png" alt="在这里插入图片描述"></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/3f8a5656a23b2f27e1ee9335875488f3/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">java.lang.UnsupportedOperationException: null 怎么解决</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/2cae7d9036ec90a9cf50a9543ce543fa/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">计算机网络 综合(习题)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>