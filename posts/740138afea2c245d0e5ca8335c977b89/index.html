<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Caffeine 使用与原理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Caffeine 使用与原理" />
<meta property="og:description" content="这里写自定义目录标题 caffeine、GuavaCache、EhCache 比较Caffeine 基础使用SpringBoot 集成Caffeine配置注解@Cacheable@CachePut@CacheEvict@Caching@Caching 其他功能监听器（Removal ）统计（Statistics） 补充说明 Caffeine 策略分析过期策略更新策略填充策略同步加载（Loading）异步加载（Asynchronously Loading） 驱逐策略基于大小（size-based）基于时间（Time-based）基于引用（reference-based） Caffeine 原理分析缓存算法FIFOLRULFU Caffeine 源码分析 caffeine、GuavaCache、EhCache 比较 Google Guava工具包中的一个非常方便易用的本地化缓存实现，基于LRU算法实现，支持多种缓存过期策略。
EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。
Caffeine是使用Java8对Guava缓存的重写版本，在Spring Boot 2.0中将取代，基于LRU算法实现，支持多种缓存过期策略。
场景1：8个线程读，100%的读操作
场景2：6个线程读，2个线程写，也就是75%的读操作，25%的写操作
场景3：8个线程写，100%的写操作
Caffeine 基础使用 SpringBoot 集成 添加pom文件 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt; &lt;artifactId&gt;caffeine&lt;/artifactId&gt; &lt;/dependency&gt; 添加配置文件 spring.cache.cache-names=ConfigCache spring.cache.caffeine.spec=initialCapacity=50,maximumSize=500,expireAfterWrite=4s spring.cache.type=caffeine Application.class中添加 @EnableCaching 注解
@SpringBootApplication @EnableCaching public class Application { public static void main(String[] args) { SpringApplication.run(Application .class, args); } } 添加需要缓存的方法 import lombok.extern.slf4j.Slf4j; import org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/740138afea2c245d0e5ca8335c977b89/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2019-11-18T15:03:07+08:00" />
<meta property="article:modified_time" content="2019-11-18T15:03:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Caffeine 使用与原理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>这里写自定义目录标题</h4> 
 <ul><li><a href="#caffeineGuavaCacheEhCache__1" rel="nofollow">caffeine、GuavaCache、EhCache 比较</a></li><li><a href="#_14" rel="nofollow"></a></li><li><a href="#Caffeine__15" rel="nofollow">Caffeine 基础使用</a></li><li><ul><li><a href="#SpringBoot__17" rel="nofollow">SpringBoot 集成</a></li><li><a href="#Caffeine_115" rel="nofollow">Caffeine配置</a></li><li><a href="#_133" rel="nofollow">注解</a></li><li><ul><li><a href="#Cacheable_141" rel="nofollow">@Cacheable</a></li><li><a href="#CachePut_215" rel="nofollow">@CachePut</a></li><li><a href="#CacheEvict_233" rel="nofollow">@CacheEvict</a></li><li><a href="#Caching_264" rel="nofollow">@Caching</a></li><li><a href="#Caching_280" rel="nofollow">@Caching</a></li></ul> 
   </li><li><a href="#_301" rel="nofollow">其他功能</a></li><li><ul><li><a href="#Removal__302" rel="nofollow">监听器（Removal ）</a></li><li><a href="#Statistics_304" rel="nofollow">统计（Statistics）</a></li></ul> 
   </li><li><a href="#_312" rel="nofollow">补充说明</a></li></ul> 
  </li><li><a href="#Caffeine__315" rel="nofollow">Caffeine 策略分析</a></li><li><ul><li><a href="#_316" rel="nofollow">过期策略</a></li><li><a href="#_322" rel="nofollow">更新策略</a></li><li><a href="#_338" rel="nofollow">填充策略</a></li><li><ul><li><a href="#Loading_339" rel="nofollow">同步加载（Loading）</a></li><li><a href="#Asynchronously_Loading_357" rel="nofollow">异步加载（Asynchronously Loading）</a></li></ul> 
   </li><li><a href="#_386" rel="nofollow">驱逐策略</a></li><li><ul><li><a href="#sizebased_388" rel="nofollow">基于大小（size-based）</a></li><li><a href="#Timebased_424" rel="nofollow">基于时间（Time-based）</a></li><li><a href="#referencebased_462" rel="nofollow">基于引用（reference-based）</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Caffeine__487" rel="nofollow">Caffeine 原理分析</a></li><li><ul><li><a href="#_488" rel="nofollow">缓存算法</a></li><li><ul><li><a href="#FIFO_490" rel="nofollow">FIFO</a></li><li><a href="#LRU_501" rel="nofollow">LRU</a></li><li><a href="#LFU_512" rel="nofollow">LFU</a></li></ul> 
  </li></ul> 
  </li><li><a href="#Caffeine__525" rel="nofollow">Caffeine 源码分析</a></li></ul> 
</div> 
<p></p> 
<h2><a id="caffeineGuavaCacheEhCache__1"></a>caffeine、GuavaCache、EhCache 比较</h2> 
<p>Google Guava工具包中的一个非常方便易用的本地化缓存实现，基于LRU算法实现，支持多种缓存过期策略。</p> 
<p>EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。</p> 
<p>Caffeine是使用Java8对Guava缓存的重写版本，在Spring Boot 2.0中将取代，基于LRU算法实现，支持多种缓存过期策略。</p> 
<p>场景1：8个线程读，100%的读操作<br> <img src="https://images2.imgbox.com/eb/4a/Oz4PvUFg_o.png" alt="在这里插入图片描述"><br> 场景2：6个线程读，2个线程写，也就是75%的读操作，25%的写操作<br> <img src="https://images2.imgbox.com/c9/84/N37QdEmT_o.png" alt="在这里插入图片描述"><br> 场景3：8个线程写，100%的写操作<br> <img src="https://images2.imgbox.com/c5/4f/1PTlX82X_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_14"></a></h2> 
<h2><a id="Caffeine__15"></a>Caffeine 基础使用</h2> 
<h3><a id="SpringBoot__17"></a>SpringBoot 集成</h3> 
<ol><li>添加pom文件</li></ol> 
<pre><code>&lt;dependency&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
     &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.github.ben-manes.caffeine&lt;/groupId&gt;
    &lt;artifactId&gt;caffeine&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre> 
<ol start="2"><li>添加配置文件</li></ol> 
<pre><code>spring.cache.cache-names=ConfigCache
spring.cache.caffeine.spec=initialCapacity=50,maximumSize=500,expireAfterWrite=4s
spring.cache.type=caffeine
</code></pre> 
<p>Application.class中添加 <mark>@EnableCaching</mark> 注解</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@SpringBootApplication</span>
<span class="token annotation punctuation">@EnableCaching</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Application</span> <span class="token punctuation">{<!-- --></span>
	<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
		SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>Application <span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="3"><li>添加需要缓存的方法</li></ol> 
<pre><code class="prism language-java"><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Slf4j<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>CachePut<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>cache<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Cacheable<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Service<span class="token punctuation">;</span>

<span class="token annotation punctuation">@Service</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CaffeineService</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Cacheable</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"IZUUL"</span><span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token string">"#key"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> String <span class="token function">cacheIZUUL</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"cacheIZUUL()方法执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token function">getCache</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@CachePut</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"IZUUL"</span><span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token string">"#key"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> String <span class="token function">cachePutIZUUL</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"cachePutIZUUL()方法执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token string">"cachePutIZUUL--"</span> <span class="token operator">+</span> key<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> String <span class="token function">getCache</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        <span class="token keyword">try</span> <span class="token punctuation">{<!-- --></span>
            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"getCache()方法执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> key<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<ol start="4"><li>添加Controller 进行测试</li></ol> 
<pre><code class="prism language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>beans<span class="token punctuation">.</span>factory<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Autowired<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>GetMapping<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>PathVariable<span class="token punctuation">;</span>
<span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>web<span class="token punctuation">.</span>bind<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RestController<span class="token punctuation">;</span>

<span class="token annotation punctuation">@RestController</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CaffeineController</span> <span class="token punctuation">{<!-- --></span>

    <span class="token annotation punctuation">@Autowired</span>
    <span class="token keyword">private</span> CaffeineService caffeineService<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/cache-izuul/{key}"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> String <span class="token function">cacheIZUUL</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> String key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token keyword">return</span> caffeineService<span class="token punctuation">.</span><span class="token function">cacheIZUUL</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@GetMapping</span><span class="token punctuation">(</span><span class="token string">"/cache-put-izuul/{key}"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> String <span class="token function">cachePutIZUUL</span><span class="token punctuation">(</span><span class="token annotation punctuation">@PathVariable</span> String key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>

        <span class="token keyword">return</span> caffeineService<span class="token punctuation">.</span><span class="token function">cachePutIZUUL</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="Caffeine_115"></a>Caffeine配置</h3> 
<ul><li>initialCapacity=[integer]: 初始的缓存空间大小</li><li>maximumSize=[long]: 缓存的最大条数</li><li>maximumWeight=[long]: 缓存的最大权重</li><li>expireAfterAccess=[duration]: 最后一次写入或访问后经过固定时间过期</li><li>expireAfterWrite=[duration]: 最后一次写入后经过固定时间过期</li><li>refreshAfterWrite=[duration]: 创建缓存或者最近一次更新缓存后经过固定的时间间隔，刷新缓存</li><li>weakKeys: 打开key的弱引用</li><li>weakValues：打开value的弱引用</li><li>softValues：打开value的软引用</li><li>recordStats：开发统计功能</li></ul> 
<p><em><strong>注意：</strong></em><br> <em>expireAfterWrite和expireAfterAccess同事存在时，以expireAfterWrite为准。</em><br> <em>maximumSize和maximumWeight不可以同时使用</em><br> <em>weakValues和softValues不可以同时使用</em></p> 
<h3><a id="_133"></a>注解</h3> 
<ul><li>@Cacheable 触发缓存入口（这里一般放在创建和获取的方法上）</li><li>@CacheEvict 触发缓存的eviction（用于删除的方法上）</li><li>@CachePut 更新缓存且不影响方法执行（用于修改的方法上，该注解下的方法始终会被执行）</li><li>@Caching 将多个缓存组合在一个方法上（该注解可以允许一个方法同时设置多个注解）</li><li>@CacheConfig 在类级别设置一些缓存相关的共同配置（与其它缓存配合使用）</li></ul> 
<h4><a id="Cacheable_141"></a>@Cacheable</h4> 
<p>先看看它的源码</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Cacheable</span> <span class="token punctuation">{<!-- --></span>

    <span class="token comment">/**
     * 设定要使用的cache的名字，必须提前定义好缓存
     */</span>
    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"cacheNames"</span><span class="token punctuation">)</span>
    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 同value()，决定要使用那个/些缓存
     */</span>
    <span class="token annotation punctuation">@AliasFor</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span>
    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">cacheNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 使用SpEL表达式来设定缓存的key，如果不设置默认方法上所有参数都会作为key的一部分
     */</span>
    String <span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 用来生成key，与key()不可以共用
     */</span>
    String <span class="token function">keyGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 设定要使用的cacheManager，必须先设置好cacheManager的bean，这是使用该bean的名字
     */</span>
    String <span class="token function">cacheManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 使用cacheResolver来设定使用的缓存，用法同cacheManager，但是与cacheManager不可以同时使用
     */</span>
    String <span class="token function">cacheResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 使用SpEL表达式设定出发缓存的条件，在方法执行前生效
     */</span>
    String <span class="token function">condition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 使用SpEL设置出发缓存的条件，这里是方法执行完生效，所以条件中可以有方法执行后的value
     */</span>
    String <span class="token function">unless</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 用于同步的，在缓存失效（过期不存在等各种原因）的时候，如果多个线程同时访问被标注的方法
     * 则只允许一个线程通过去执行方法
     */</span>
    <span class="token keyword">boolean</span> <span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>
</code></pre> 
<p>使用示例</p> 
<pre><code class="prism language-java">    <span class="token comment">/**
     * condition条件判断是否要走缓存，无法使用方法中出现的值（返回结果等）,条件为true放入缓存
     * unless是方法执行后生效，决定是否放入缓存,返回true的放缓存
     * */</span>
    <span class="token annotation punctuation">@Cacheable</span><span class="token punctuation">(</span>cacheNames <span class="token operator">=</span> <span class="token string">"outLimit"</span><span class="token punctuation">,</span>key <span class="token operator">=</span> <span class="token string">"#name"</span><span class="token punctuation">,</span>condition <span class="token operator">=</span> <span class="token string">"#value != null "</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> String <span class="token function">getCaffeineServiceTest</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span>Integer age<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        String value <span class="token operator">=</span> name <span class="token operator">+</span> <span class="token string">" nihao "</span><span class="token operator">+</span> age<span class="token punctuation">;</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"getCaffeineServiceTest value = {}"</span><span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p><strong>sync 属性</strong>：<br> 用于保证缓存需要加载时，只会有一个线程计算数据，其他线程阻塞。caffeine 本身也有类似机制，但是使用 sync 属性，其他线程由 spring 阻塞 ，而不是 caffeine。因为 caffeine 的阻塞机制中 ，每个阻塞的线程仍要重复 “获取锁，计算加载缓存，释放锁” 类似的过程，而由 spring 阻塞，阻塞的线程会待计算数据的线程加载完缓存后，直接从缓存中获取数据。</p> 
<p><strong>unless 属性</strong>：<br> 用于否决（veto）缓存，缓存计算结束后判断，若满足该表达式，则计算结果不会加入缓存中。如 unless = “#result == null” ，表示若计算结果为空，则不加入缓存。</p> 
<h4><a id="CachePut_215"></a>@CachePut</h4> 
<p>使用示例</p> 
<pre><code class="prism language-java">  <span class="token annotation punctuation">@CachePut</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"outLimit"</span><span class="token punctuation">,</span> key <span class="token operator">=</span> <span class="token string">"#key"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> String <span class="token function">cachePutIZUUL</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"cachePutIZUUL()方法执行"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token string">"cachePutIZUUL--"</span> <span class="token operator">+</span> key<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>这是个一般用于修改方法上的注解，它的代码跟Cacheable基本相同，这里不做介绍。<br> 现在说下CachePut和Cacheable的主要区别。</p> 
<pre><code>@Cacheable：它的注解的方法是否被执行取决于Cacheable中的条件，方法很多时候都可能不被执行。 
@CachePut：这个注解不会影响方法的执行，也就是说无论它配置的条件是什么，方法都会被执行，更多的时候是被用到修改上。
</code></pre> 
<h4><a id="CacheEvict_233"></a>@CacheEvict</h4> 
<pre><code class="prism language-java">    <span class="token comment">/**
     * CacheEvict删除key，会调用cache的evict
     * */</span>
    <span class="token annotation punctuation">@CacheEvict</span><span class="token punctuation">(</span>cacheNames <span class="token operator">=</span> <span class="token string">"outLimit"</span><span class="token punctuation">,</span>key <span class="token operator">=</span> <span class="token string">"#name"</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> String <span class="token function">deleteCaffeineServiceTest</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
        String value <span class="token operator">=</span> name <span class="token operator">+</span> <span class="token string">" nihao"</span><span class="token punctuation">;</span>
        logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"deleteCaffeineServiceTest value = {}"</span><span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre> 
<p>跟上边的两个注解相比，源码中多了两个属性</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">CacheEvict</span> <span class="token punctuation">{<!-- --></span>


    <span class="token comment">/**
     * 是否删除缓存中的所有数据，默认为false，只会删除被注解方法中传入的key的缓存
     */</span>
    <span class="token keyword">boolean</span> <span class="token function">allEntries</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

    <span class="token comment">/**
     * 设置缓存的删除在方法执行前执行还是执行后执行。如果设置true，则无论该方法是否正常结束，缓存中的值都会被删除。
     */</span>
    <span class="token keyword">boolean</span> <span class="token function">beforeInvocation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

<span class="token punctuation">}</span>

</code></pre> 
<h4><a id="Caching_264"></a>@Caching</h4> 
<p>它是个组合上面三个注解的注解，之前我并没有用到，现在结合spring文档简单说下。<br> 源码</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Caching</span> <span class="token punctuation">{<!-- --></span>
    Cacheable<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">cacheable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    CachePut<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    CacheEvict<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">evict</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>它只是给出了三种注解的组合，并没有给出限制条件，所以其使用也很简单，如下</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Caching</span><span class="token punctuation">(</span>evict <span class="token operator">=</span> <span class="token punctuation">{<!-- --></span> <span class="token annotation punctuation">@CacheEvict</span><span class="token punctuation">(</span><span class="token string">"primary"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token annotation punctuation">@CacheEvict</span><span class="token punctuation">(</span>cacheNames<span class="token operator">=</span><span class="token string">"secondary"</span><span class="token punctuation">,</span> key<span class="token operator">=</span><span class="token string">"#p0"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> Book <span class="token function">importBooks</span><span class="token punctuation">(</span>String deposit<span class="token punctuation">,</span> Date date<span class="token punctuation">)</span>
</code></pre> 
<h4><a id="Caching_280"></a>@Caching</h4> 
<p>类级别的注解，可以设置某类中所有注解的相同部分，这个可以参考spring的类级别的@Mapping来理解。<br> 其代码很简单</p> 
<pre><code class="prism language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">CacheConfig</span> <span class="token punctuation">{<!-- --></span>
    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">cacheNames</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    String <span class="token function">keyGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>
    String <span class="token function">cacheManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>
    String <span class="token function">cacheResolver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>使用如下</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@CacheConfig</span><span class="token punctuation">(</span><span class="token string">"books"</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BookRepositoryImpl</span> <span class="token keyword">implements</span> <span class="token class-name">BookRepository</span> <span class="token punctuation">{<!-- --></span>
    <span class="token annotation punctuation">@Cacheable</span>
    <span class="token keyword">public</span> Book <span class="token function">findBook</span><span class="token punctuation">(</span>ISBN isbn<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="_301"></a>其他功能</h3> 
<h4><a id="Removal__302"></a>监听器（Removal ）</h4> 
<p>您可以通过Caffeine.removalListener(RemovalListener) 为缓存指定一个删除侦听器，以便在删除数据时执行某些操作。 RemovalListener可以获取到key、value和RemovalCause（删除的原因）。</p> 
<h4><a id="Statistics_304"></a>统计（Statistics）</h4> 
<p>使用Caffeine.recordStats()，您可以打开统计信息收集。Cache.stats() 方法返回提供统计信息的CacheStats，如：</p> 
<ul><li>hitRate()：返回命中与请求的比率</li><li>hitCount(): 返回命中缓存的总数</li><li>evictionCount()：缓存逐出的数量</li><li>averageLoadPenalty()：加载新值所花费的平均时间</li></ul> 
<h3><a id="_312"></a>补充说明</h3> 
<p><strong>spring cache 使用基于动态生成子类的代理机制来对方法的调用进行切面，如果缓存的方法是内部调用而不是外部引用，会导致代理失败，切面失效。</strong></p> 
<h2><a id="Caffeine__315"></a>Caffeine 策略分析</h2> 
<h3><a id="_316"></a>过期策略</h3> 
<p>在Caffeine中分为两种缓存，一个是有界缓存，一个是无界缓存，无界缓存不需要过期并且没有界限。在有界缓存中提供了三个过期API：</p> 
<ul><li><strong>expireAfterWrite</strong>：代表着写了之后多久过期。</li><li><strong>expireAfterAccess</strong>： 代表着最后一次访问了之后多久过期。</li><li><strong>expireAfter</strong>：在expireAfter中需要自己实现Expiry接口，这个接口支持create,update,以及access了之后多久过期。注意这个API和前面两个API是互斥的。这里和前面两个API不同的是，需要你告诉缓存框架，他应该在具体的某个时间过期，也就是通过前面的重写create,update,以及access的方法，获取具体的过期时间。</li></ul> 
<h3><a id="_322"></a>更新策略</h3> 
<pre><code class="prism language-java">LoadingCache<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> String<span class="token punctuation">&gt;</span></span> build <span class="token operator">=</span> Caffeine<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">refreshAfterWrite</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">)</span>
   <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">CacheLoader</span><span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> String<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token annotation punctuation">@Override</span>
          <span class="token keyword">public</span> String <span class="token function">load</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span>  <span class="token punctuation">{<!-- --></span>
             <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> 
<p>但是实际使用中，你设置了一天刷新，但是一天后你发现缓存并没有刷新。这是因为必有在1天后这个缓存再次访问才能刷新，如果没人访问，那么永远也不会刷新。你明白了吗？</p> 
<p>我们来看看自动刷新他是怎么做的呢？自动刷新只存在读操作之后，也就是我们afterRead()这个方法，其中有个方法叫refreshIfNeeded，他会根据你是同步还是异步然后进行刷新处理。</p> 
<h3><a id="_338"></a>填充策略</h3> 
<h4><a id="Loading_339"></a>同步加载（Loading）</h4> 
<pre><code class="prism language-java"><span class="token comment">// 初始化缓存</span>
LoadingCache<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">&gt;</span></span> loadingCache <span class="token operator">=</span> Caffeine<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">maximumSize</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">expireAfterWrite</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>key <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">createExpensiveGraph</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

String key <span class="token operator">=</span> <span class="token string">"name1"</span><span class="token punctuation">;</span>
<span class="token comment">// 采用同步方式去获取一个缓存和上面的手动方式是一个原理。在build Cache的时候会提供一个createExpensiveGraph函数。</span>
<span class="token comment">// 查询并在缺失的情况下使用同步的方式来构建一个缓存</span>
Object graph <span class="token operator">=</span> loadingCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 获取组key的值返回一个Map</span>
List<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> keys <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
keys<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
Map<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">&gt;</span></span> graphs <span class="token operator">=</span> loadingCache<span class="token punctuation">.</span><span class="token function">getAll</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="Asynchronously_Loading_357"></a>异步加载（Asynchronously Loading）</h4> 
<pre><code class="prism language-java">AsyncLoadingCache<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">&gt;</span></span> asyncLoadingCache <span class="token operator">=</span> Caffeine<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">maximumSize</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">expireAfterWrite</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span>
        <span class="token comment">// Either: Build with a synchronous computation that is wrapped as asynchronous</span>
        <span class="token punctuation">.</span><span class="token function">buildAsync</span><span class="token punctuation">(</span>key <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">createExpensiveGraph</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// Or: Build with a asynchronous computation that returns a future</span>
        <span class="token comment">// .buildAsync((key, executor) -&gt; createExpensiveGraphAsync(key, executor));</span>

String key <span class="token operator">=</span> <span class="token string">"name1"</span><span class="token punctuation">;</span>

<span class="token comment">// 查询并在缺失的情况下使用异步的方式来构建缓存</span>
CompletableFuture<span class="token generics function"><span class="token punctuation">&lt;</span>Object<span class="token punctuation">&gt;</span></span> graph <span class="token operator">=</span> asyncLoadingCache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 查询一组缓存并在缺失的情况下使用异步的方式来构建缓存</span>
List<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">&gt;</span></span> keys <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
keys<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
CompletableFuture<span class="token operator">&lt;</span>Map<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token punctuation">&gt;</span></span><span class="token operator">&gt;</span> graphs <span class="token operator">=</span> asyncLoadingCache<span class="token punctuation">.</span><span class="token function">getAll</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 异步转同步</span>
loadingCache <span class="token operator">=</span> asyncLoadingCache<span class="token punctuation">.</span><span class="token function">synchronous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>AsyncLoadingCache是继承自LoadingCache类的，异步加载使用Executor去调用方法并返回一个CompletableFuture。异步加载缓存使用了响应式编程模型。</p> 
<p>如果要以同步方式调用时，应提供CacheLoader。要以异步表示时，应该提供一个AsyncCacheLoader，并返回一个CompletableFuture。</p> 
<p>synchronous()这个方法返回了一个LoadingCacheView视图，LoadingCacheView也继承自LoadingCache。调用该方法后就相当于你将一个异步加载的缓存AsyncLoadingCache转换成了一个同步加载的缓存LoadingCache。</p> 
<p>默认使用ForkJoinPool.commonPool()来执行异步线程，但是我们可以通过Caffeine.executor(Executor) 方法来替换线程池。</p> 
<h3><a id="_386"></a>驱逐策略</h3> 
<p>Caffeine提供三类驱逐策略：基于大小（size-based），基于时间（time-based）和基于引用（reference-based）。</p> 
<h4><a id="sizebased_388"></a>基于大小（size-based）</h4> 
<p>基于大小驱逐，有两种方式：一种是基于缓存大小，一种是基于权重。</p> 
<pre><code class="prism language-java"><span class="token comment">// 根据缓存的计数进行驱逐</span>
LoadingCache<span class="token generics function"><span class="token punctuation">&lt;</span>Key<span class="token punctuation">,</span> Graph<span class="token punctuation">&gt;</span></span> graphs <span class="token operator">=</span> Caffeine<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">maximumSize</span><span class="token punctuation">(</span><span class="token number">10</span>_000<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>key <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">createExpensiveGraph</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 根据缓存的权重来进行驱逐（权重只是用于确定缓存大小，不会用于决定该缓存是否被驱逐）</span>
LoadingCache<span class="token generics function"><span class="token punctuation">&lt;</span>Key<span class="token punctuation">,</span> Graph<span class="token punctuation">&gt;</span></span> graphs <span class="token operator">=</span> Caffeine<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">maximumWeight</span><span class="token punctuation">(</span><span class="token number">10</span>_000<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">weigher</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Graph graph<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> graph<span class="token punctuation">.</span><span class="token function">vertices</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>key <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">createExpensiveGraph</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>我们可以使用Caffeine.maximumSize(long)方法来指定缓存的最大容量。当缓存超出这个容量的时候，会使用Window TinyLfu策略来删除缓存。我们也可以使用权重的策略来进行驱逐，可以使用Caffeine.weigher(Weigher) 函数来指定权重，使用Caffeine.maximumWeight(long) 函数来指定缓存最大权重值。</p> 
<p>让我们看看如何计算缓存中的对象。当缓存初始化时，其大小等于零：</p> 
<pre><code class="prism language-java">LoadingCache<span class="token generics function"><span class="token punctuation">&lt;</span>String<span class="token punctuation">,</span> DataObject<span class="token punctuation">&gt;</span></span> cache <span class="token operator">=</span> Caffeine<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                      <span class="token punctuation">.</span><span class="token function">maximumSize</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
                      <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>k <span class="token operator">-</span><span class="token operator">&gt;</span> DataObject<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"Data for "</span> <span class="token operator">+</span> k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
<span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> cache<span class="token punctuation">.</span><span class="token function">estimatedSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> 
<p>当我们添加一个值时，大小明显增加：</p> 
<pre><code class="prism language-java">cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
<span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> cache<span class="token punctuation">.</span><span class="token function">estimatedSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> 
<p>我们可以将第二个值添加到缓存中，这导致第一个值被删除：</p> 
<pre><code class="prism language-java">cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token function">assertEquals</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> cache<span class="token punctuation">.</span><span class="token function">estimatedSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
</code></pre> 
<h4><a id="Timebased_424"></a>基于时间（Time-based）</h4> 
<pre><code class="prism language-java"><span class="token comment">// 基于固定的到期策略进行退出</span>
LoadingCache<span class="token generics function"><span class="token punctuation">&lt;</span>Key<span class="token punctuation">,</span> Graph<span class="token punctuation">&gt;</span></span> graphs <span class="token operator">=</span> Caffeine<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">expireAfterAccess</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>key <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">createExpensiveGraph</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
LoadingCache<span class="token generics function"><span class="token punctuation">&lt;</span>Key<span class="token punctuation">,</span> Graph<span class="token punctuation">&gt;</span></span> graphs <span class="token operator">=</span> Caffeine<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">expireAfterWrite</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>key <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">createExpensiveGraph</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 要初始化自定义策略，我们需要实现 Expiry 接口</span>
LoadingCache<span class="token generics function"><span class="token punctuation">&lt;</span>Key<span class="token punctuation">,</span> Graph<span class="token punctuation">&gt;</span></span> graphs <span class="token operator">=</span> Caffeine<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">expireAfter</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Expiry</span><span class="token generics function"><span class="token punctuation">&lt;</span>Key<span class="token punctuation">,</span> Graph<span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
          <span class="token annotation punctuation">@Override</span>
          <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">expireAfterCreate</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Graph graph<span class="token punctuation">,</span> <span class="token keyword">long</span> currentTime<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">// Use wall clock time, rather than nanotime, if from an external resource</span>
            <span class="token keyword">long</span> seconds <span class="token operator">=</span> graph<span class="token punctuation">.</span><span class="token function">creationDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">plusHours</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
                   <span class="token punctuation">.</span><span class="token function">minus</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> MILLIS<span class="token punctuation">)</span>
                   <span class="token punctuation">.</span><span class="token function">toEpochSecond</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> TimeUnit<span class="token punctuation">.</span>SECONDS<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>seconds<span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>

          <span class="token annotation punctuation">@Override</span>
          <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">expireAfterUpdate</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Graph graph<span class="token punctuation">,</span> 
            <span class="token keyword">long</span> currentTime<span class="token punctuation">,</span> <span class="token keyword">long</span> currentDuration<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token keyword">return</span> currentDuration<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>

          <span class="token annotation punctuation">@Override</span>
          <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">expireAfterRead</span><span class="token punctuation">(</span>Key key<span class="token punctuation">,</span> Graph graph<span class="token punctuation">,</span>
             <span class="token keyword">long</span> currentTime<span class="token punctuation">,</span> <span class="token keyword">long</span> currentDuration<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
             <span class="token keyword">return</span> currentDuration<span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>key <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">createExpensiveGraph</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<h4><a id="referencebased_462"></a>基于引用（reference-based）</h4> 
<p>强引用，软引用，弱引用概念说明请点击连接，这里说一下各各引用的区别：</p> 
<table><thead><tr><th align="left">引用类型</th><th>被垃圾回收时间</th><th align="left">用途</th><th>生存时间</th></tr></thead><tbody><tr><td align="left">强引用</td><td>从来不会</td><td align="left">对象的一般状态</td><td>JVM停止运行时终止</td></tr><tr><td align="left">软引用</td><td>在内存不足时</td><td align="left">对象缓存</td><td>内存不足时终止</td></tr><tr><td align="left">弱引用</td><td>被垃圾回收时</td><td align="left">对象缓存</td><td>GC运行后终止</td></tr><tr><td align="left">虚引用</td><td>Unknown</td><td align="left">Unknown</td><td>Unknown</td></tr></tbody></table> 
<pre><code class="prism language-java"><span class="token comment">// 当key和value都没有引用时驱逐缓存</span>
LoadingCache<span class="token generics function"><span class="token punctuation">&lt;</span>Key<span class="token punctuation">,</span> Graph<span class="token punctuation">&gt;</span></span> graphs <span class="token operator">=</span> Caffeine<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                                          <span class="token punctuation">.</span><span class="token function">weakKeys</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                                          <span class="token punctuation">.</span><span class="token function">weakValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                                          <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>key <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">createExpensiveGraph</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 当垃圾收集器需要释放内存时驱逐</span>
LoadingCache<span class="token generics function"><span class="token punctuation">&lt;</span>Key<span class="token punctuation">,</span> Graph<span class="token punctuation">&gt;</span></span> graphs <span class="token operator">=</span> Caffeine<span class="token punctuation">.</span><span class="token function">newBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                                          <span class="token punctuation">.</span><span class="token function">softValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                                          <span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span>key <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">createExpensiveGraph</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> 
<p>我们可以将缓存的驱逐配置成基于垃圾回收器。当没有任何对对象的强引用时，使用 WeakRefence 可以启用对象的垃圾收回收。SoftReference 允许对象根据 JVM 的全局最近最少使用（Least-Recently-Used）的策略进行垃圾回收。</p> 
<p>注意：AsyncLoadingCache不支持弱引用和软引用。</p> 
<h2><a id="Caffeine__487"></a>Caffeine 原理分析</h2> 
<h3><a id="_488"></a>缓存算法</h3> 
<p>缓存算法（FIFO 、LRU、LFU三种算法的区别）</p> 
<h4><a id="FIFO_490"></a>FIFO</h4> 
<p>FIFO 算法是一种比较容易实现的算法。它的思想是先进先出（FIFO，队列），这是最简单、最公平的一种思想，即如果一个数据是最先进入的，那么可以认为在将来它被访问的可能性很小。空间满的时候，最先进入的数据会被最早置换（淘汰）掉。</p> 
<p>FIFO 算法的描述：设计一种缓存结构，该结构在构造时确定大小，假设大小为 K，并有两个功能：</p> 
<ol><li>set(key,value)：将记录(key,value)插入该结构。当缓存满时，将最先进入缓存的数据置换掉。</li><li>get(key)：返回key对应的value值。</li></ol> 
<p>实现：维护一个FIFO队列，按照时间顺序将各数据（已分配页面）链接起来组成队列，并将置换指针指向队列的队首。再进行置换时，只需把置换指针所指的数据（页面）顺次换出，并把新加入的数据插到队尾即可。</p> 
<p>缺点：判断一个页面置换算法优劣的指标就是缺页率，而FIFO算法的一个显著的缺点是，在某些特定的时刻，缺页率反而会随着分配页面的增加而增加，这称为Belady现象。产生Belady现象现象的原因是，FIFO置换算法与进程访问内存的动态特征是不相容的，被置换的内存页面往往是被频繁访问的，或者没有给进程分配足够的页面，因此FIFO算法会使一些页面频繁地被替换和重新申请内存，从而导致缺页率增加。因此，现在不再使用FIFO算法。</p> 
<h4><a id="LRU_501"></a>LRU</h4> 
<p>LRU（The Least Recently Used，最近最久未使用算法）是一种常见的缓存算法，在很多分布式缓存系统（如Redis, Memcached）中都有广泛使用。</p> 
<p>LRU算法的思想是：如果一个数据在最近一段时间没有被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最久没有访问的数据最先被置换（淘汰）。</p> 
<p>LRU算法的描述： 设计一种缓存结构，该结构在构造时确定大小，假设大小为 K，并有两个功能：</p> 
<ol><li>set(key,value)：将记录(key,value)插入该结构。当缓存满时，将最久未使用的数据置换掉。</li><li>get(key)：返回key对应的value值。</li></ol> 
<p>实现：最朴素的思想就是用数组+时间戳的方式，不过这样做效率较低。因此，我们可以用双向链表（LinkedList）+哈希表（HashMap）实现（链表用来表示位置，哈希表用来存储和查找），在Java里有对应的数据结构LinkedHashMap。</p> 
<h4><a id="LFU_512"></a>LFU</h4> 
<p>LFU（Least Frequently Used ，最近最少使用算法）也是一种常见的缓存算法。</p> 
<p>顾名思义，LFU算法的思想是：如果一个数据在最近一段时间很少被访问到，那么可以认为在将来它被访问的可能性也很小。因此，当空间满时，最小频率访问的数据最先被淘汰。</p> 
<p>LFU 算法的描述：<br> 设计一种缓存结构，该结构在构造时确定大小，假设大小为 K，并有两个功能：</p> 
<ol><li>set(key,value)：将记录(key,value)插入该结构。当缓存满时，将访问频率最低的数据置换掉。</li><li>get(key)：返回key对应的value值。</li></ol> 
<p>算法实现策略：考虑到 LFU 会淘汰访问频率最小的数据，我们需要一种合适的方法按大小顺序维护数据访问的频率。LFU 算法本质上可以看做是一个 top K 问题(K = 1)，即选出频率最小的元素，因此我们很容易想到可以用二项堆来选择频率最小的元素，这样的实现比较高效。最终实现策略为小顶堆+哈希表。</p> 
<h2><a id="Caffeine__525"></a>Caffeine 源码分析</h2> 
<p><strong>caffeine的load put 和invalidate操作都是原子的，这个意思是这3个操作是互斥的，load和put是不能同时执行的，load和invalidate也是不能同时执行的。<br> 先load再invalidate，invalidate操作是要等load操作执行完的。如果load操作执行比较慢，那invalidate操作就要等很久了。<br> caffeine的存储就是ConcurrentHashMap，利用了ConcurrentHashMap自己的node节点锁。</strong></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/1a14c38836027219a54d32325dd3152e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">腾讯云加速 配置docker加速镜像</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/35b766415778673d3020f931e60496be/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">android之清理缓存实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>