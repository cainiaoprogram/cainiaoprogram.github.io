<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式——工厂方法模式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式——工厂方法模式" />
<meta property="og:description" content="工厂方法 也被称作：抽象构造
目的 工厂方法是一种创建设计模式，它在父类中提供了创建对象的接口但允许子类更改将要创建的对象的类型。
问题 假设您正在创建一个物流管理应用程序。你的应用的第一个版本只能处理卡车运输，所以你的大部分代码都存在于卡车类中。
不久之后，你的应用就变得非常受欢迎。每天你都会收到几十个海运公司的请求，要求将海运物流整合到应用程序中。
但是目前大多数代码都与卡车类耦合在一起。将船类添加到应用中需要对整个代码库进行修改。此外如果之后你决定在应用程序中添加另一种类型的交通工具，你可能需要再次进行所有这些更改。
结果您将得到非常糟糕的代码，其中充满了根据传输对象的类来切换应用程序行为的条件。
解决方案 工厂方法模式建议将直接对象构造调用(使用new操作符)替换为对特殊工厂方法的调用。对象仍然是通过new操作符创建的，但它是从工厂方法内部调用的。工厂方法返回的对象通常称为产品。
乍一看，这种更改可能毫无意义：我们只是将构造函数调用从程序的一个部分移到另一个部分。但是请考虑这一点：现在您可以在子类中重写工厂方法并更改由该方法创建的产品的类。
但是有一个轻微的限制：只有当这些产品具有公共的基类或接口时，子类才能返回不同类型的产品。此外，基类中的工厂方法应该将其返回类型声明为此接口。
例如，Truck和Ship类都应该实现Transport接口，该接口声明了一个名为deliver的方法。每个类都以不同的方式实现这个方法:卡车通过陆地运送货物，轮船通过海上运送货物。RoadLogistics类中的工厂方法返回卡车对象，而SeaLogistics类中的工厂方法返回船舶。
使用工厂方法的代码(通常称为客户端代码)看不到各种子类返回的实际产品之间的差异。客户将所有产品视为抽象运输。客户端知道所有传输对象都应该具有deliver方法，但它的具体工作方式对客户端并不重要。
结构 声明了Product这个接口，它对所有可以由创建者及其子类产生的对象都是通用的。Concrete Product是Product接口的不同实现。Creator类声明了返回新产品对象的工厂方法。这个方法的返回类型必须与产品接口匹配，这一点很重要。您可以将工厂方法声明为抽象的，以强制所有子类实现它们自己的方法版本。作为一种替代方法，基本工厂方法可以返回某种默认产品类型。请注意尽管名称如此，产品创建并不是创建者的主要职责。通常，创建者类已经拥有一些与产品相关的核心业务逻辑。工厂方法有助于将这种逻辑从具体的产品类中分离出来。这里有一个类比：一个大型软件开发公司可以有一个程序员培训部门。然而整个公司的主要职能仍然是编写代码而不是培养程序员。Concrete Creator重写基本工厂方法，因此它返回不同类型的产品。 注意工厂方法不必一直创建新实例。它还可以从缓存、对象池或其他源返回现有对象。
伪码 这个例子演示了如何使用Factory方法来创建跨平台的UI元素而不用将客户端代码耦合到具体的UI类。
基类Dialog使用不同的UI元素来呈现它的窗口。在不同的操作系统下，这些元素可能看起来有些不同但它们仍然应该保持一致的行为。Windows中的按钮在Linux中仍然是按钮。
当工厂方法开始发挥作用时，您不需要为每个操作系统重写Dialog类的逻辑。如果我们在基本的Dialog类中声明一个工厂方法来产生按钮，我们以后可以创建一个子类，从工厂方法返回windows样式的按钮。然后子类继承基类的大部分代码但是由于工厂方法，可以在屏幕上呈现windows外观的按钮。
要使此模式工作，基本Dialog类必须与抽象按钮一起工作：所有具体按钮都遵循的基类或接口。通过这种方式Dialog中的代码保持功能性，无论它处理的是哪种类型的按钮。
当然您也可以将此方法应用于其他UI元素。但是随着您向Dialog中添加的每一个新的工厂方法，您将更接近抽象工厂模式。不要害怕我们稍后会讨论这个模式。
// The creator class declares the factory method that must // return an object of a product class. The creator&#39;s subclasses // usually provide the implementation of this method. class Dialog is // The creator may also provide some default implementation // of the factory method." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/499aab40101c63b7376024e2ba0ffdb6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-07-31T12:25:28+08:00" />
<meta property="article:modified_time" content="2022-07-31T12:25:28+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式——工厂方法模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h3><a id="_0"></a>工厂方法</h3> 
<p><strong>也被称作</strong>：抽象构造</p> 
<h4><a id="_3"></a>目的</h4> 
<p>工厂方法是一种创建设计模式，它在父类中提供了创建对象的接口但允许子类更改将要创建的对象的类型。<br> <img src="https://images2.imgbox.com/2c/ba/SI3vKhQn_o.png" alt="工厂模式示意图"></p> 
<h4><a id="_6"></a>问题</h4> 
<p>假设您正在创建一个物流管理应用程序。你的应用的第一个版本只能处理卡车运输，所以你的大部分代码都存在于卡车类中。</p> 
<p>不久之后，你的应用就变得非常受欢迎。每天你都会收到几十个海运公司的请求，要求将海运物流整合到应用程序中。</p> 
<p><img src="https://images2.imgbox.com/74/34/0UUJD5vJ_o.png" alt="如果现有代码已经同存在的类耦合添加新的类型会变得困难"><br> 但是目前大多数代码都与卡车类耦合在一起。将船类添加到应用中需要对整个代码库进行修改。此外如果之后你决定在应用程序中添加另一种类型的交通工具，你可能需要再次进行所有这些更改。</p> 
<p>结果您将得到非常糟糕的代码，其中充满了根据传输对象的类来切换应用程序行为的条件。</p> 
<h4><a id="_16"></a>解决方案</h4> 
<p>工厂方法模式建议将直接对象构造调用(使用new操作符)替换为对特殊工厂方法的调用。对象仍然是通过new操作符创建的，但它是从工厂方法内部调用的。工厂方法返回的对象通常称为产品。</p> 
<p><img src="https://images2.imgbox.com/b6/55/L98bSBPI_o.png" alt="子类可以替换工厂方法返回的对象类型"><br> 乍一看，这种更改可能毫无意义：我们只是将构造函数调用从程序的一个部分移到另一个部分。但是请考虑这一点：现在您可以在子类中重写工厂方法并更改由该方法创建的产品的类。</p> 
<p>但是有一个轻微的限制：只有当这些产品具有公共的基类或接口时，子类才能返回不同类型的产品。此外，基类中的工厂方法应该将其返回类型声明为此接口。</p> 
<p><img src="https://images2.imgbox.com/89/83/lK46CX83_o.png" alt="所有的产品必须派生自同一种接口"><br> 例如，Truck和Ship类都应该实现Transport接口，该接口声明了一个名为deliver的方法。每个类都以不同的方式实现这个方法:卡车通过陆地运送货物，轮船通过海上运送货物。RoadLogistics类中的工厂方法返回卡车对象，而SeaLogistics类中的工厂方法返回船舶。</p> 
<p><img src="https://images2.imgbox.com/9f/1a/93Gd4SEA_o.png" alt="随着所有的产品派生自同一个通用接口，你可以把对象传给客户端代码"><br> 使用工厂方法的代码(通常称为客户端代码)看不到各种子类返回的实际产品之间的差异。客户将所有产品视为抽象运输。客户端知道所有传输对象都应该具有deliver方法，但它的具体工作方式对客户端并不重要。</p> 
<h4><a id="_30"></a>结构</h4> 
<p><img src="https://images2.imgbox.com/97/85/9ZfxK3jk_o.png" alt="在这里插入图片描述"></p> 
<ol><li>声明了<code>Product</code>这个接口，它对所有可以由创建者及其子类产生的对象都是通用的。</li><li><code>Concrete Product</code>是Product接口的不同实现。</li><li><code>Creator</code>类声明了返回新产品对象的工厂方法。这个方法的返回类型必须与产品接口匹配，这一点很重要。您可以将工厂方法声明为抽象的，以强制所有子类实现它们自己的方法版本。作为一种替代方法，基本工厂方法可以返回某种默认产品类型。请注意尽管名称如此，产品创建并不是创建者的主要职责。通常，创建者类已经拥有一些与产品相关的核心业务逻辑。工厂方法有助于将这种逻辑从具体的产品类中分离出来。这里有一个类比：一个大型软件开发公司可以有一个程序员培训部门。然而整个公司的主要职能仍然是编写代码而不是培养程序员。</li><li><code>Concrete Creator</code>重写基本工厂方法，因此它返回不同类型的产品。</li></ol> 
<p>注意工厂方法不必一直创建新实例。它还可以从缓存、对象池或其他源返回现有对象。</p> 
<h4><a id="_39"></a>伪码</h4> 
<p>这个例子演示了如何使用Factory方法来创建跨平台的UI元素而不用将客户端代码耦合到具体的UI类。<br> <img src="https://images2.imgbox.com/3e/94/VZuwuS1i_o.png" alt="在这里插入图片描述"><br> 基类<code>Dialog</code>使用不同的UI元素来呈现它的窗口。在不同的操作系统下，这些元素可能看起来有些不同但它们仍然应该保持一致的行为。Windows中的按钮在Linux中仍然是按钮。</p> 
<p>当工厂方法开始发挥作用时，您不需要为每个操作系统重写<code>Dialog</code>类的逻辑。如果我们在基本的<code>Dialog</code>类中声明一个工厂方法来产生按钮，我们以后可以创建一个子类，从工厂方法返回windows样式的按钮。然后子类继承基类的大部分代码但是由于工厂方法，可以在屏幕上呈现windows外观的按钮。</p> 
<p>要使此模式工作，基本Dialog类必须与抽象按钮一起工作：所有具体按钮都遵循的基类或接口。通过这种方式<code>Dialog</code>中的代码保持功能性，无论它处理的是哪种类型的按钮。</p> 
<p>当然您也可以将此方法应用于其他UI元素。但是随着您向<code>Dialog</code>中添加的每一个新的工厂方法，您将更接近抽象工厂模式。不要害怕我们稍后会讨论这个模式。</p> 
<pre><code class="prism language-java"><span class="token comment">// The creator class declares the factory method that must</span>
<span class="token comment">// return an object of a product class. The creator's subclasses</span>
<span class="token comment">// usually provide the implementation of this method.</span>
<span class="token keyword">class</span> <span class="token class-name">Dialog</span> is
    <span class="token comment">// The creator may also provide some default implementation</span>
    <span class="token comment">// of the factory method.</span>
    <span class="token keyword">abstract</span> method <span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token class-name">Button</span>

    <span class="token comment">// Note that, despite its name, the creator's primary</span>
    <span class="token comment">// responsibility isn't creating products. It usually</span>
    <span class="token comment">// contains some core business logic that relies on product</span>
    <span class="token comment">// objects returned by the factory method. Subclasses can</span>
    <span class="token comment">// indirectly change that business logic by overriding the</span>
    <span class="token comment">// factory method and returning a different type of product</span>
    <span class="token comment">// from it.</span>
    method <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        <span class="token comment">// Call the factory method to create a product object.</span>
        <span class="token class-name">Button</span> okButton <span class="token operator">=</span> <span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token comment">// Now use the product.</span>
        okButton<span class="token punctuation">.</span><span class="token function">onClick</span><span class="token punctuation">(</span>closeDialog<span class="token punctuation">)</span>
        okButton<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>


<span class="token comment">// Concrete creators override the factory method to change the</span>
<span class="token comment">// resulting product's type.</span>
<span class="token keyword">class</span> <span class="token class-name">WindowsDialog</span> <span class="token keyword">extends</span> <span class="token class-name">Dialog</span> is
    method <span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token class-name">Button</span> is
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">WindowsButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">WebDialog</span> <span class="token keyword">extends</span> <span class="token class-name">Dialog</span> is
    method <span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token class-name">Button</span> is
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HTMLButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>


<span class="token comment">// The product interface declares the operations that all</span>
<span class="token comment">// concrete products must implement.</span>
<span class="token keyword">interface</span> <span class="token class-name">Button</span> is
    method <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    method <span class="token function">onClick</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>

<span class="token comment">// Concrete products provide various implementations of the</span>
<span class="token comment">// product interface.</span>
<span class="token keyword">class</span> <span class="token class-name">WindowsButton</span> <span class="token keyword">implements</span> <span class="token class-name">Button</span> is
    method <span class="token function">render</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> is
        <span class="token comment">// Render a button in Windows style.</span>
    method <span class="token function">onClick</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> is
        <span class="token comment">// Bind a native OS click event.</span>

<span class="token keyword">class</span> <span class="token class-name">HTMLButton</span> <span class="token keyword">implements</span> <span class="token class-name">Button</span> is
    method <span class="token function">render</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> is
        <span class="token comment">// Return an HTML representation of a button.</span>
    method <span class="token function">onClick</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> is
        <span class="token comment">// Bind a web browser click event.</span>


<span class="token keyword">class</span> <span class="token class-name">Application</span> is
    field dialog<span class="token operator">:</span> <span class="token class-name">Dialog</span>

    <span class="token comment">// The application picks a creator's type depending on the</span>
    <span class="token comment">// current configuration or environment settings.</span>
    method <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        config <span class="token operator">=</span> <span class="token function">readApplicationConfigFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>OS <span class="token operator">==</span> <span class="token string">"Windows"</span><span class="token punctuation">)</span> then
            dialog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WindowsDialog</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>config<span class="token punctuation">.</span>OS <span class="token operator">==</span> <span class="token string">"Web"</span><span class="token punctuation">)</span> then
            dialog <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WebDialog</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Exception</span><span class="token punctuation">(</span><span class="token string">"Error! Unknown operating system."</span><span class="token punctuation">)</span>

    <span class="token comment">// The client code works with an instance of a concrete</span>
    <span class="token comment">// creator, albeit through its base interface. As long as</span>
    <span class="token comment">// the client keeps working with the creator via the base</span>
    <span class="token comment">// interface, you can pass it any creator's subclass.</span>
    method <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> is
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initialize</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        dialog<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> 
<h4><a id="_131"></a>应用</h4> 
<p><strong>当你事先不知道你的代码应该处理的对象的确切类型和依赖关系时使用工厂方法。</strong></p> 
<p>工厂方法将产品构造代码从实际使用产品的代码中分离出来。因此更容易独立于其他代码扩展产品构造代码。例如要向应用程序添加一个新的产品类型，您只需要创建一个新的creator子类，并覆盖其中的工厂方法。</p> 
<p><strong>当你想为你的库或框架的用户提供一种扩展其内部组件的方法时使用工厂方法。</strong></p> 
<p>继承可能是扩展库或框架默认行为的最简单方法。但是框架如何识别应该使用你的子类而不是标准组件呢？解决方案是将跨框架构建组件的代码减少到单个工厂方法中并且除了扩展组件本身之外，允许任何人重写该方法。</p> 
<p>让我们看看它是如何工作的。假设您使用开源UI框架编写一个应用程序。你的应用程序应该有圆形的按钮，但框架只提供方形的按钮。您可以用一个漂亮的<code>RoundButton</code>子类来扩展标准的<code>Button</code>类。但是现在您需要告诉主<code>UIFramework</code>类使用新的按钮子类而不是默认的。</p> 
<p>为了实现这一点你从一个基本框架类中创建一个子类<code>UIWithRoundButtons</code>并覆盖它的createButton方法。当这个方法返回基类中的<code>Button</code>对象时，你让你的子类返回<code>RoundButton</code>对象。现在使用<code>UIWithRoundButtons</code>类来代替<code>UIFramework</code>。就是这样!</p> 
<p><strong>当您希望通过重用现有对象而不是每次重新构建它们来节省系统资源时，请使用工厂方法。</strong></p> 
<p>在处理大型、资源密集型对象(如数据库连接、文件系统和网络资源)时，您经常会遇到这种需求。</p> 
<p>让我们想想要重用一个现有的对象需要做些什么：</p> 
<ol><li>首先，您需要创建一些存储来跟踪所有创建的对象。</li><li>当有人请求一个对象时，程序应该在池中查找空闲对象。</li><li>然后将其返回给客户机代码。</li><li>如果没有空闲对象，程序应该创建一个新对象(并将其添加到池中)。</li></ol> 
<p>这是很多代码！它必须放在一个单独的地方，这样你就不会用重复的代码污染程序。可能放置这些代码的最明显和最方便的地方是我们试图重用其对象的类的构造函数。但是根据定义构造函数必须始终返回新对象。它不能返回现有的实例。</p> 
<p>因此您需要有一个能够创建新对象和重用现有对象的常规方法。这听起来很像工厂方法。</p> 
<h4><a id="_160"></a>如何实现</h4> 
<ol><li> <p>使所有产品遵循相同的界面。这个接口应该声明在每个产品中都有意义的方法。</p> </li><li> <p>在创建者类中添加一个空工厂方法。方法的返回类型应该与通用产品接口匹配。</p> </li><li> <p>在创建者的代码中找到对产品构造函数的所有引用。将它们逐个替换为对工厂方法的调用，同时将产品创建代码提取到工厂方法中。您可能需要向工厂方法添加一个临时参数来控制返回产品的类型。此时工厂方法的代码可能看起来非常难看。它可能有一个较大的switch语句，用于选择实例化哪个产品类。不过别担心，我们很快就会修好的。</p> </li><li> <p>现在为工厂方法中列出的每种产品类型创建一组creator子类。在子类中重写工厂方法并从基方法中提取适当的构造代码位。如果有太多的产品类型并且为所有产品类型创建子类没有意义，您可以在子类中重用基类中的控制参数。</p> </li><li> <p>例如假设你有以下类的层次结构：基本的<strong>Mail</strong>类有两个子类：<strong>AirMail</strong>和<strong>GroundMail</strong>；<strong>Transport</strong>类有<strong>Plane</strong>，<strong>Truck</strong>和<strong>Train</strong>。当<strong>AirMail</strong>类只使用<strong>Plane</strong>对象时，<strong>GroundMail</strong>可以同时使用<strong>Truck</strong>和<strong>Train</strong>对象。你可以创建一个新的子类(比如TrainMail)来处理这两种情况。但还有另一种选择，客户端代码可以向<strong>GroundMail</strong>类的工厂方法传递一个参数以控制它想要接收的产品。</p> </li><li> <p>如果在所有抽象之后，基本工厂方法变成空的，你可以将其转为抽象类。如果还有一些东西没有处理您可以将其作为该方法的默认行为。</p> </li></ol> 
<h4><a id="_173"></a>正反面</h4> 
<p><strong>正面因素</strong></p> 
<ul><li>你避免了创造者和具体产品之间的紧密耦合。</li><li>单一责任原则。您可以将产品创建代码移动到程序中的一个位置，使代码更易于支持。</li><li>打开/关闭原则。您可以在不破坏现有客户端代码的情况下将新类型的产品引入程序。</li></ul> 
<p><strong>反面因素</strong></p> 
<ul><li>代码可能会变得更加复杂，因为您需要引入许多新的子类来实现模式。最好的情况是将模式引入到现有的创建者类层次结构中。</li></ul> 
<h4><a id="_182"></a>同其他模式的关系</h4> 
<ul><li> <p>许多设计开始使用<strong>工厂方法</strong>(更简单，更可通过子类定制)，然后发展到<strong>抽象工厂</strong>、<strong>原型</strong>或<strong>构建器</strong>(更灵活，但更复杂)。</p> </li><li> <p><strong>抽象工厂</strong>类通常基于一组工厂方法，但您也可以使用<strong>原型</strong>来组合这些类上的方法。</p> </li><li> <p>您可以使用<strong>工厂方法</strong>和<strong>迭代器</strong>来让集合的子类返回与集合兼容的不同类型的迭代器。</p> </li><li> <p><strong>原型</strong>不是基于继承的，所以它没有缺点。另一方面，<strong>原型</strong>需要对克隆对象进行复杂的初始化。工厂方法基于继承但不需要初始化步骤。</p> </li><li> <p><strong>工厂方法</strong>是<strong>模板方法</strong>的特例化。同时工厂方法可以作为大型<strong>模板方法</strong>中的一个步骤。</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/38443755004db899cb627f754d592161/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">从旋转向量到欧拉角的六种计算方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/0f3c9ecba6037cd8f2eae065b1b7168d/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">mysql having的用法</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>