<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>【Django缓存实现】前端缓存和后端缓存 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="【Django缓存实现】前端缓存和后端缓存" />
<meta property="og:description" content="目录
一、什么是缓存？
二、Web缓存
（一）前端缓存
（二）后端缓存
三、Django缓存
（一）缓存类型
（二）设置缓存
1.Memcached
2.Redis
3.数据库缓存
4.文件系统缓存
5.本地内存缓存
6.虚拟缓存（用于开发模式）
7.使用自定义缓存后端
8.缓存参数
（四）站点缓存
（五）视图缓存
（六）在 URLconf 中指定视图缓存
（七）模板片段缓存
（八）底层缓存 API
（九）访问缓存
四、基本用法
1.缓存键前缀
2.缓存版本控制
3.缓存键转换
4.缓存键警告
五、异步支持
六、注意事项
一、什么是缓存？ 缓存的定义：缓存（cache），原始意义是指访问速度比一般随机存取存储器（RAM）快的一种高速存储器，通常它不像系统主存那样使用DRAM技术，而使用昂贵但较快速的SRAM技术。缓存的设置是所有现代计算机系统发挥高性能的重要因素之一。
缓存的优点汇总，加快页面打开速度，减少网络带宽消耗，降低服务器压力。
具体工作原理可参考：缓存_百度百科 (baidu.com)。通俗的说，这里涉及到计算机的各种存储，内存、磁盘、cpu等都算是计算机的存储器。
二、Web缓存 我们的django程序是计算机的一个进程，进程是运行在内存上的，当用户访问时，会在进程中开启一个线程处理请求。
（一）前端缓存 前端缓存即浏览器缓存，可以解决减轻请求服务器的频次、提高页面展示效率。在实际开发中，因网站的性质不同，往往会考虑缓存的问题。一般的展示型网站（官网、介绍等）为了减轻请求服务器的频次、提高页面展示效率将设置缓存配置。
前端缓存是根据请求头headers的expires和cache-control判断是否重新请求服务器，缓存的对象为html、css、js、图片等静态文件。
（二）后端缓存 通常情况下，计算一个值是很昂贵的（也就是耗费资源，而且速度很慢），所以把值保存到快速访问的缓存中，为下次需要时做好准备，会有巨大的好处。
Django 自带强大的缓存系统，可以让你保存动态页面，这样就不必为每次请求计算。为了方便，Django 提供了不同级别的缓存粒度。你可以缓存特定视图的输出，你可以只缓存难以生成的部分，或者你可以缓存整个网站。
三、Django缓存 （一）缓存类型 Memcached：一种高性能的分布式内存对象缓存系统，用于动态网站，以减轻数据库负载。
Redis：
数据库缓存：缓存信息存储在网站数据库的缓存表中，缓存表可以在项目的配置文件中配置，适合大中型网站使用。
文件系统缓存：缓存信息以文本文件格式保存，适合中小型网站使用。
本地内存缓存：django默认的缓存保存方式，将缓存存放在项目所在系统的内存中，之适用于项目开发测试。
虚拟缓存：django内置的虚拟缓存，市级上只提供缓存接口，并不能存储缓存的相关配置。
（二）设置缓存 缓存系统需要少量的设置。也就是说，你必须告诉它你的缓存数据应该放在哪里 —— 是在数据库中，还是在文件系统上，或者直接放在内存中。这是一个重要的决定，会影响你的缓存的性能；是的，有些缓存类型比其他类型快。
缓存设置项位于你的配置文件的缓存配置中。这里有缓存配置所有可用值的说明。
1.Memcached Memcached 以一个守护进程的形式运行，并且被分配了指定数量的 RAM。它所做的就是提供一个快速接口用于在缓存中添加，检索和删除数据。所有数据都直接存储在内存中，因此不会产生数据库或文件系统使用的开销。
在安装了 Memcached 本身之后，你需要安装一个 Memcached 绑定。有几个 Python Memcached 绑定可用；Django 支持的两个绑定是 pylibmc 和 pymemcache 。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/66f2c42e62becb73773c31fe5a3acb7f/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-04-05T20:10:44+08:00" />
<meta property="article:modified_time" content="2023-04-05T20:10:44+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">【Django缓存实现】前端缓存和后端缓存</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%EF%BC%9F-toc" style="margin-left:0px;"><a href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%EF%BC%9F" rel="nofollow">一、什么是缓存？</a></p> 
<p id="%E4%BA%8C%E3%80%81Web%E7%BC%93%E5%AD%98-toc" style="margin-left:0px;"><a href="#%E4%BA%8C%E3%80%81Web%E7%BC%93%E5%AD%98" rel="nofollow">二、Web缓存</a></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98" rel="nofollow">（一）前端缓存</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%90%8E%E7%AB%AF%E7%BC%93%E5%AD%98-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E5%90%8E%E7%AB%AF%E7%BC%93%E5%AD%98" rel="nofollow">（二）后端缓存</a></p> 
<p id="%E4%B8%89%E3%80%81Django%E7%BC%93%E5%AD%98-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81Django%E7%BC%93%E5%AD%98" rel="nofollow">三、Django缓存</a></p> 
<p id="%EF%BC%88%E4%B8%80%EF%BC%89%E7%BC%93%E5%AD%98%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%B8%80%EF%BC%89%E7%BC%93%E5%AD%98%E7%B1%BB%E5%9E%8B" rel="nofollow">（一）缓存类型</a></p> 
<p id="%EF%BC%88%E4%BA%8C%EF%BC%89%E8%AE%BE%E7%BD%AE%E7%BC%93%E5%AD%98-toc" style="margin-left:40px;"><a href="#%EF%BC%88%E4%BA%8C%EF%BC%89%E8%AE%BE%E7%BD%AE%E7%BC%93%E5%AD%98" rel="nofollow">（二）设置缓存</a></p> 
<p id="1.Memcached-toc" style="margin-left:80px;"><a href="#1.Memcached" rel="nofollow">1.Memcached</a></p> 
<p id="2.Redis-toc" style="margin-left:80px;"><a href="#2.Redis" rel="nofollow">2.Redis</a></p> 
<p id="3.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98-toc" style="margin-left:80px;"><a href="#3.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98" rel="nofollow">3.数据库缓存</a></p> 
<p id="4.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%AD%98-toc" style="margin-left:80px;"><a href="#4.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%AD%98" rel="nofollow">4.文件系统缓存</a></p> 
<p id="%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%C2%B6-toc" style="margin-left:80px;"><a href="#%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%C2%B6" rel="nofollow">5.本地内存缓存</a></p> 
<p id="%E8%99%9A%E6%8B%9F%E7%BC%93%E5%AD%98%EF%BC%88%E7%94%A8%E4%BA%8E%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%89%C2%B6-toc" style="margin-left:80px;"><a href="#%E8%99%9A%E6%8B%9F%E7%BC%93%E5%AD%98%EF%BC%88%E7%94%A8%E4%BA%8E%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%89%C2%B6" rel="nofollow">6.虚拟缓存（用于开发模式）</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%93%E5%AD%98%E5%90%8E%E7%AB%AF%C2%B6-toc" style="margin-left:80px;"><a href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%93%E5%AD%98%E5%90%8E%E7%AB%AF%C2%B6" rel="nofollow">7.使用自定义缓存后端</a></p> 
<p id="%E7%BC%93%E5%AD%98%E5%8F%82%E6%95%B0%C2%B6-toc" style="margin-left:80px;"><a href="#%E7%BC%93%E5%AD%98%E5%8F%82%E6%95%B0%C2%B6" rel="nofollow">8.缓存参数</a></p> 
<p id="%E7%AB%99%E7%82%B9%E7%BC%93%E5%AD%98%C2%B6-toc" style="margin-left:40px;"><a href="#%E7%AB%99%E7%82%B9%E7%BC%93%E5%AD%98%C2%B6" rel="nofollow">（四）站点缓存</a></p> 
<p id="%E8%A7%86%E5%9B%BE%E7%BC%93%E5%AD%98%C2%B6-toc" style="margin-left:40px;"><a href="#%E8%A7%86%E5%9B%BE%E7%BC%93%E5%AD%98%C2%B6" rel="nofollow">（五）视图缓存</a></p> 
<p id="%E5%9C%A8%20URLconf%20%E4%B8%AD%E6%8C%87%E5%AE%9A%E8%A7%86%E5%9B%BE%E7%BC%93%E5%AD%98%C2%B6-toc" style="margin-left:40px;"><a href="#%E5%9C%A8%20URLconf%20%E4%B8%AD%E6%8C%87%E5%AE%9A%E8%A7%86%E5%9B%BE%E7%BC%93%E5%AD%98%C2%B6" rel="nofollow">（六）在 URLconf 中指定视图缓存</a></p> 
<p id="%E6%A8%A1%E6%9D%BF%E7%89%87%E6%AE%B5%E7%BC%93%E5%AD%98%C2%B6-toc" style="margin-left:40px;"><a href="#%E6%A8%A1%E6%9D%BF%E7%89%87%E6%AE%B5%E7%BC%93%E5%AD%98%C2%B6" rel="nofollow">（七）模板片段缓存</a></p> 
<p id="%E5%BA%95%E5%B1%82%E7%BC%93%E5%AD%98%20API%C2%B6-toc" style="margin-left:40px;"><a href="#%E5%BA%95%E5%B1%82%E7%BC%93%E5%AD%98%20API%C2%B6" rel="nofollow">（八）底层缓存 API</a></p> 
<p id="%E8%AE%BF%E9%97%AE%E7%BC%93%E5%AD%98%C2%B6-toc" style="margin-left:40px;"><a href="#%E8%AE%BF%E9%97%AE%E7%BC%93%E5%AD%98%C2%B6" rel="nofollow">（九）访问缓存</a></p> 
<p id="%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%C2%B6-toc" style="margin-left:0px;"><a href="#%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%C2%B6" rel="nofollow">四、基本用法</a></p> 
<p id="%E7%BC%93%E5%AD%98%E9%94%AE%E5%89%8D%E7%BC%80%C2%B6-toc" style="margin-left:80px;"><a href="#%E7%BC%93%E5%AD%98%E9%94%AE%E5%89%8D%E7%BC%80%C2%B6" rel="nofollow">1.缓存键前缀</a></p> 
<p id="%E7%BC%93%E5%AD%98%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%C2%B6-toc" style="margin-left:80px;"><a href="#%E7%BC%93%E5%AD%98%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%C2%B6" rel="nofollow">2.缓存版本控制</a></p> 
<p id="%E7%BC%93%E5%AD%98%E9%94%AE%E8%BD%AC%E6%8D%A2%C2%B6-toc" style="margin-left:80px;"><a href="#%E7%BC%93%E5%AD%98%E9%94%AE%E8%BD%AC%E6%8D%A2%C2%B6" rel="nofollow">3.缓存键转换</a></p> 
<p id="%E7%BC%93%E5%AD%98%E9%94%AE%E8%AD%A6%E5%91%8A%C2%B6-toc" style="margin-left:80px;"><a href="#%E7%BC%93%E5%AD%98%E9%94%AE%E8%AD%A6%E5%91%8A%C2%B6" rel="nofollow">4.缓存键警告</a></p> 
<p id="%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81%C2%B6-toc" style="margin-left:0px;"><a href="#%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81%C2%B6" rel="nofollow">五、异步支持</a></p> 
<p id="%E4%B8%89%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9-toc" style="margin-left:0px;"><a href="#%E4%B8%89%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="nofollow">六、注意事项</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%EF%BC%9F">一、什么是缓存？</h2> 
<p>缓存的定义：<strong>缓存（cache</strong>），原始意义是指访问速度比一般<a href="https://baike.baidu.com/item/%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E5%AD%98%E5%82%A8%E5%99%A8?fromModule=lemma_inlink" rel="nofollow" title="随机存取存储器">随机存取存储器</a>（RAM）快的一种高速存储器，通常它不像系统主存那样使用<a href="https://baike.baidu.com/item/DRAM?fromModule=lemma_inlink" rel="nofollow" title="DRAM">DRAM</a>技术，而使用昂贵但较快速的<a href="https://baike.baidu.com/item/SRAM?fromModule=lemma_inlink" rel="nofollow" title="SRAM">SRAM</a>技术。缓存的设置是所有现代计算机系统发挥高性能的重要因素之一。</p> 
<p>缓存的优点汇总，加快页面打开速度，减少网络带宽消耗，降低服务器压力。</p> 
<p>具体工作原理可参考<a href="https://baike.baidu.com/item/%E7%BC%93%E5%AD%98/100710?fr=aladdin" rel="nofollow" title="：缓存_百度百科 (baidu.com)">：缓存_百度百科 (baidu.com)</a>。通俗的说，这里涉及到计算机的各种存储，内存、磁盘、cpu等都算是计算机的存储器。<br>  </p> 
<h2 id="%E4%BA%8C%E3%80%81Web%E7%BC%93%E5%AD%98">二、Web缓存</h2> 
<p>我们的django程序是计算机的一个进程，进程是运行在内存上的，当用户访问时，会在进程中开启一个线程处理请求。</p> 
<h3 id="%EF%BC%88%E4%B8%80%EF%BC%89%E5%89%8D%E7%AB%AF%E7%BC%93%E5%AD%98">（一）前端缓存</h3> 
<p><strong>前端缓存</strong>即浏览器缓存，可以解决减轻请求服务器的频次、提高页面展示效率。在实际开发中，因网站的性质不同，往往会考虑缓存的问题。一般的展示型网站（官网、介绍等）为了减轻请求服务器的频次、提高页面展示效率将设置缓存配置。</p> 
<p>前端缓存是根据请求头headers的expires和cache-control判断是否重新请求服务器，缓存的对象为html、css、js、图片等静态文件。</p> 
<h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89%E5%90%8E%E7%AB%AF%E7%BC%93%E5%AD%98">（二）后端缓存</h3> 
<p>通常情况下，计算一个值是很昂贵的（也就是耗费资源，而且速度很慢），所以把<strong>值</strong>保存到快速访问的缓存中，为下次需要时做好准备，会有巨大的好处。</p> 
<p>Django 自带强大的缓存系统，可以让你保存动态页面，这样就不必为每次请求计算。为了方便，Django 提供了不同级别的缓存粒度。你可以缓存特定视图的输出，你可以只缓存难以生成的部分，或者你可以缓存整个网站。</p> 
<h2 id="%E4%B8%89%E3%80%81Django%E7%BC%93%E5%AD%98">三、Django缓存</h2> 
<h3 id="%EF%BC%88%E4%B8%80%EF%BC%89%E7%BC%93%E5%AD%98%E7%B1%BB%E5%9E%8B">（一）缓存类型</h3> 
<p>Memcached：一种高性能的分布式内存对象缓存系统，用于动态网站，以减轻数据库负载。</p> 
<p>Redis：</p> 
<p>数据库缓存：缓存信息存储在网站数据库的缓存表中，缓存表可以在项目的配置文件中配置，适合大中型网站使用。</p> 
<p>文件系统缓存：缓存信息以文本文件格式保存，适合中小型网站使用。</p> 
<p>本地内存缓存：django默认的缓存保存方式，将缓存存放在项目所在系统的内存中，之适用于项目开发测试。</p> 
<p>虚拟缓存：django内置的虚拟缓存，市级上只提供缓存接口，并不能存储缓存的相关配置。</p> 
<h3 id="%EF%BC%88%E4%BA%8C%EF%BC%89%E8%AE%BE%E7%BD%AE%E7%BC%93%E5%AD%98">（二）设置缓存</h3> 
<p>缓存系统需要少量的设置。也就是说，你必须告诉它你的缓存数据应该放在哪里 —— 是在数据库中，还是在文件系统上，或者直接放在内存中。这是一个重要的决定，会影响你的缓存的性能；是的，有些缓存类型比其他类型快。</p> 
<p>缓存设置项位于你的配置文件的缓存配置中。这里有缓存配置所有可用值的说明。</p> 
<h4 id="1.Memcached">1.Memcached</h4> 
<p>Memcached 以一个守护进程的形式运行，并且被分配了指定数量的 RAM。它所做的就是提供一个快速接口用于在缓存中添加，检索和删除数据。所有数据都直接存储在内存中，因此不会产生数据库或文件系统使用的开销。</p> 
<p>在安装了 Memcached 本身之后，你需要安装一个 Memcached 绑定。有几个 Python Memcached 绑定可用；Django 支持的两个绑定是 <a href="https://pypi.org/project/pylibmc/" rel="nofollow" title="pylibmc">pylibmc</a> 和 <a href="https://pypi.org/project/pymemcache/" rel="nofollow" title="pymemcache">pymemcache</a> 。</p> 
<p>在 Django 中使用 Memcached ：</p> 
<ul><li>设置 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-BACKEND" rel="nofollow" title="BACKEND">BACKEND</a> 为 django.core.cache.backends.memcached.PyMemcacheCache 或 django.core.cache.backends.memcached.PyLibMCCache （取决于你选择的 memcached 绑定）。</li><li>将 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-LOCATION" rel="nofollow" title="LOCATION">LOCATION</a> 设置为 <code>ip:port</code> 值，其中 <code>ip</code> 是 Memcached 守护进程的 IP 地址，<code>port</code> 是 Memcached 运行的端口，或者设置为 <code>unix:path</code> 值，其中 <code>path</code> 是 Memcached Unix socket 文件的路径。</li></ul> 
<p>在这个例子中，Memcached 运行在 localhost（127.0.0.1）端口 11211，使用 <code>pymemcache</code> 绑定：</p> 
<pre>CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',
        'LOCATION': '127.0.0.1:11211',
    }
}
</pre> 
<p>在这个例子中，Memcached 可以通过本地 Unix 套接字文件 <code>/tmp/memcached.sock</code> 使用 <code>pymemcache</code> 绑定：</p> 
<pre>CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',
        'LOCATION': 'unix:/tmp/memcached.sock',
    }
}
</pre> 
<p>Memcached 有一个很好的特性，就是它可以在多台服务器上共享一个缓存。这意味着你可以在多台机器上运行 Memcached 守护进程，程序将把这组机器作为一个 <em>单一</em> 的缓存，而不需要在每台机器上重复缓存值。要利用这个特性，请在 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-LOCATION" rel="nofollow" title="LOCATION">LOCATION</a> 中包含所有服务器地址，可以是分号或逗号分隔的字符串，也可以是一个列表。</p> 
<p>在这个例子中，缓存是通过运行在 IP 地址 172.19.26.240 和 172.19.26.242 上的 Memcached 实例共享的，这两个实例都在 11211 端口上：</p> 
<pre>CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',
        'LOCATION': [
            '172.19.26.240:11211',
            '172.19.26.242:11211',
        ]
    }
}
</pre> 
<p>在下面的例子中，缓存是由运行在 IP 地址 172.19.26.240（端口11211）、172.19.26.242（端口11212）和 172.19.26.244（端口11213）上的 Memcached 实例共享的：</p> 
<pre>CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',
        'LOCATION': [
            '172.19.26.240:11211',
            '172.19.26.242:11212',
            '172.19.26.244:11213',
        ]
    }
}
</pre> 
<p>关于 Memcached 的最后一点是，基于内存的缓存有一个缺点：因为缓存的数据存储在内存中，如果你的服务器崩溃，数据将丢失。显然，内存并不是用来永久存储数据的，所以不要依赖基于内存的缓存作为你唯一的数据存储。毫无疑问，Django 缓存后端中的 <em>每个</em> 都不应该用于永久存储 —— 它们的目的都是为了缓存的解决方案，而不是存储 —— 但我们在这里指出这一点是因为基于内存的缓存是格外临时的。</p> 
<p>Changed in Django 3.2:</p> 
<p>增加了 <code>PyMemcacheCache</code> 后端。</p> 
<p>3.2 版后已移除:MemcachedCache` 后端已被废弃，因为 <code>python-memcached</code> 有一些问题，而且似乎没有维护。使用 <code>PyMemcacheCache</code> 或 <code>PyLibMCCache</code> 代替。</p> 
<h4 id="2.Redis">2.Redis</h4> 
<p>这是一个可用于缓存的内存数据库。首先，您需要在本地或远程计算机上运行Redis服务器。</p> 
<p>设置完Redis服务器后，需要为Redis安装Python绑定。redis-py是Django本机支持的绑定。还建议安装额外的hiredispy包。</p> 
<pre>CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.redis.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379',
    }
}
</pre> 
<p>通常，Redis服务器受身份验证保护。为了提供用户名和密码，请将其与URL一起添加到LOCATION中：</p> 
<pre>CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.redis.RedisCache',
        'LOCATION': 'redis://username:password@127.0.0.1:6379',
    }
}
</pre> 
<p>如果在复制模式下设置了多个Redis服务器，则可以将服务器指定为分号或逗号分隔的字符串或列表。当使用多个服务器时，在第一个服务器（引导服务器）上执行写入操作。读取操作在随机选择的其他服务器（副本）上执行：</p> 
<pre>CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.redis.RedisCache',
        'LOCATION': [
            'redis://127.0.0.1:6379', # leader
            'redis://127.0.0.1:6378', # read-replica 1
            'redis://127.0.0.1:6377', # read-replica 2
        ],
    }
}
</pre> 
<h4 id="3.%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%93%E5%AD%98">3.数据库缓存</h4> 
<p>Django 可以在数据库中存储缓存数据。如果你有一个快速、索引正常的数据库服务器，这种缓存效果最好。</p> 
<p>在这个例子中，缓存表的名称是 <code>my_cache_table</code> ：</p> 
<pre>CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.db.DatabaseCache',
        'LOCATION': 'my_cache_table',
    }
}
</pre> 
<p>与其他缓存后端不同，数据库缓存不支持在数据库级别自动筛选过期条目。相反，每次调用add（）、set（）或touch（）时，都会删除过期的缓存条目。</p> 
<p><strong>注意：</strong>使用数据库缓存之前，必须通过下面的命令创建缓存表：</p> 
<pre>python manage.py createcachetable
</pre> 
<p>这将在数据库中创建一个表，该表的格式与 Django 数据库缓存系统期望的一致。该表的表名取自 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-LOCATION" rel="nofollow" title="LOCATION">LOCATION</a> 。</p> 
<p>如果你正在使用多个数据库缓存， <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/django-admin/#django-admin-createcachetable" rel="nofollow" title="createcachetable">createcachetable</a> 会为每个缓存创建一个表。</p> 
<p>如果你正在使用多个数据库， <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/django-admin/#django-admin-createcachetable" rel="nofollow" title="createcachetable">createcachetable</a> 观察你的数据库路由器的 <code>allow_migrate()</code> 方法（见下文）。</p> 
<p>像 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/django-admin/#django-admin-migrate" rel="nofollow" title="migrate">migrate</a> 一样， <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/django-admin/#django-admin-createcachetable" rel="nofollow" title="createcachetable">createcachetable</a> 不会影响已经存在的表，它只创建缺失的表。</p> 
<p>要打印即将运行的 SQL，而不是运行它，请使用 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/django-admin/#cmdoption-createcachetable-dry-run" rel="nofollow" title="createcachetable --dry-run">createcachetable --dry-run</a> 选项。</p> 
<p>多数据库<a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#multiple-databases" rel="nofollow" title="¶">¶</a></p> 
<p>如果在多数据库中使用缓存，你也需要设置数据库缓存表的路由指令。因为路由的原因，数据库缓存表在 <code>django_cache</code> 应用程序中显示为 <code>CacheEntry</code> 的模型名。这个模型不会出现在模型缓存中，但模型详情可用于路由目的。</p> 
<p>比如，下面的路由可以将所有缓存读取操作指向 <code>cache_replica</code> ，并且所有的写操作指向 <code>cache_primary</code>。缓存表将会只同步到 <code>cache_primary</code>。</p> 
<pre>class CacheRouter:
    """A router to control all database cache operations"""

    def db_for_read(self, model, **hints):
        "All cache read operations go to the replica"
        if model._meta.app_label == 'django_cache':
            return 'cache_replica'
        return None

    def db_for_write(self, model, **hints):
        "All cache write operations go to primary"
        if model._meta.app_label == 'django_cache':
            return 'cache_primary'
        return None

    def allow_migrate(self, db, app_label, model_name=None, **hints):
        "Only install the cache model on primary"
        if app_label == 'django_cache':
            return db == 'cache_primary'
        return None
</pre> 
<p>如果你没有指定路由指向数据库缓存模型，缓存后端将使用 <code>默认</code> 的数据库。</p> 
<p>如果没使用数据库缓存后端，则无需担心为数据库缓存模型提供路由指令。</p> 
<h4 id="4.%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%BC%93%E5%AD%98">4.文件系统缓存</h4> 
<p>基于文件的后端序列化并保存每个缓存值作为单独的文件。要使用此后端，可将 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-BACKEND" rel="nofollow" title="BACKEND">BACKEND</a> 设置为 <code>"django.core.cache.backends.filebased.FileBasedCache"</code> 并将 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-LOCATION" rel="nofollow" title="LOCATION">LOCATION</a> 设置为一个合适的路径。比如，在 <code>/var/tmp/django_cache</code> 存储缓存数据，使用以下配置：</p> 
<pre>CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': '/var/tmp/django_cache',
    }
}
</pre> 
<p>如果使用 Windows 系统，将驱动器号放在路径开头，如下：</p> 
<pre>CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': 'c:/foo/bar',
    }
}
</pre> 
<p>目录路径应该是绝对路径——因此，它应该以文件系统根目录开始。无需担心是否需要以斜杠结尾。</p> 
<p>Make sure the directory pointed-to by this setting either exists and is readable and writable, or that it can be created by the system user under which your web server runs. Continuing the above example, if your server runs as the user <code>apache</code>, make sure the directory <code>/var/tmp/django_cache</code> exists and is readable and writable by the user <code>apache</code>, or that it can be created by the user <code>apache</code>.</p> 
<p>警告</p> 
<p>当缓存 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-LOCATION" rel="nofollow" title="LOCATION">LOCATION</a> 包含在 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-MEDIA_ROOT" rel="nofollow" title="MEDIA_ROOT">MEDIA_ROOT</a> 或 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-STATICFILES_FINDERS" rel="nofollow" title="STATICFILES_FINDERS">STATICFILES_FINDERS</a> 中，敏感数据可能被暴露。</p> 
<p>获得访问缓存文件的攻击者不仅可以伪造 HTML 内容，你的网站会信任它，而且还可以远程执行任意代码，因为数据是用 <a href="https://docs.python.org/3/library/pickle.html#module-pickle" rel="nofollow" title="pickle">pickle</a> 序列化的。</p> 
<h4 id="%E6%9C%AC%E5%9C%B0%E5%86%85%E5%AD%98%E7%BC%93%E5%AD%98%C2%B6">5.本地内存缓存</h4> 
<p>如果你的配置文件中没有指定其他缓存，那么这是默认的缓存。如果你想获得内存缓存的速度优势，但又不具备运行 Memcached 的能力，可以考虑使用本地内存缓存后端。这个缓存是每进程所有（见下文）和线程安全的。要使用它，可以将 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-BACKEND" rel="nofollow" title="BACKEND">BACKEND</a> 设置为 <code>"django.core.cache.backends.locmem.LocMemCache"</code>。例如：</p> 
<pre>CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
        'LOCATION': 'unique-snowflake',
    }
}
</pre> 
<p><a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-LOCATION" rel="nofollow" title="LOCATION">LOCATION</a> 被用于标识各个内存存储。如果只有一个 <code>locmem</code> 缓存，你可以忽略 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-LOCATION" rel="nofollow" title="LOCATION">LOCATION</a> 。但是如果你有多个本地内存缓存，那么你至少要为其中一个起个名字，以便将它们区分开。</p> 
<p>这种缓存使用最近最少使用（LRU）的淘汰策略。</p> 
<p>请注意，每个进程都会有自己的私有缓存实例，这意味着不可能进行跨进程缓存。这也意味着本地内存缓存的内存效率不是特别高，所以对于生产环境来说，它可能不是一个好的选择。对于开发来说是不错的选择。</p> 
<h4 id="%E8%99%9A%E6%8B%9F%E7%BC%93%E5%AD%98%EF%BC%88%E7%94%A8%E4%BA%8E%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%EF%BC%89%C2%B6">6.虚拟缓存（用于开发模式）</h4> 
<p>最后，Django 带有一个实际上不是缓存的 “虚拟” 缓存，它只是实现缓存接口，并不做其他操作。</p> 
<p>如果你有一个生产网站，在不同的地方使用了大量的缓存，但在开发／测试环境中，你不想缓存，也不想单独修改你的代码，那么这就很有用。要激活虚拟缓存，可以像这样设置 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-BACKEND" rel="nofollow" title="BACKEND">BACKEND</a> ：</p> 
<pre>CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.dummy.DummyCache',
    }
}
</pre> 
<h4 id="%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BC%93%E5%AD%98%E5%90%8E%E7%AB%AF%C2%B6">7.使用自定义缓存后端</h4> 
<p>虽然 Django 包含了许多开箱即用的缓存后端支持，但有时你可能会想使用一个自定义的缓存后端。要在 Django 中使用外部缓存后端，使用 Python 导入路径作为 <code>BACKEND</code> 的 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES" rel="nofollow" title="CACHES">CACHES</a> 配置中的 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-BACKEND" rel="nofollow" title="BACKEND">BACKEND</a>，像这样：</p> 
<pre>CACHES = {
    'default': {
        'BACKEND': 'path.to.backend',
    }
}
</pre> 
<p>如果你正在创建自己的后端，你可以使用标准缓存作为参考实现。你可以在 Django 源代码的 <code>django/core/cache/backends/</code> 目录找到代码。</p> 
<p>注意：除非是令人信服的理由，诸如服务器不支持缓存，否则你应该使用 Django 附带的缓存后端。他们经过了良好的测试并有完整文档。</p> 
<h4 id="%E7%BC%93%E5%AD%98%E5%8F%82%E6%95%B0%C2%B6">8.缓存参数</h4> 
<p>每个缓存后端可以通过额外的参数来控制缓存行为。这些参数在 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES" rel="nofollow" title="CACHES">CACHES</a> 配置中作为附加键提供。有效参数如下：</p> 
<ul><li> <p><a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-TIMEOUT" rel="nofollow" title="TIMEOUT">TIMEOUT</a> ：缓存的默认超时时间，以秒为单位。这个参数默认为 <code>300</code> 秒（5 分钟）。你可以将 <code>TIMEOUT</code> 设置为 <code>None</code>，这样，默认情况下，缓存键永远不会过期。值为 <code>0</code> 会导致键立即过期（实际上是 “不缓存”）。</p> </li><li> <p><a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-OPTIONS" rel="nofollow" title="OPTIONS">OPTIONS</a> ：任何应该传递给缓存后端的选项。有效的选项列表会随着每个后端而变化，由第三方库支持的缓存后端会直接将其选项传递给底层缓存库。</p> <p>实施自有缓存策略的缓存后端（即 <code>locmem</code>、<code>filesystem</code> 和 <code>database</code> 后端）将尊重以下选项：</p> 
  <ul><li> <p><code>MAX_ENTRIES</code> ：删除旧值之前允许缓存的最大条目。默认是 <code>300</code> 。</p> </li><li> <p><code>CULL_FREQUENCY</code> ：当达到 <code>MAX_ENTRIES</code> 时，被删除的条目的比例。实际比例是 <code>1 / CULL_FREQUENCY</code>，所以将 <code>CULL_FREQUENCY</code> 设置为 <code>2</code>，即当达到 <code>MAX_ENTRIES</code> 时将删除一半的条目。这个参数应该是一个整数，默认为 <code>3</code>。</p> <p><code>CULL_FREQUENCY</code> 的值为 <code>0</code> 意味着当达到 <code>MAX_ENTRIES</code> 时，整个缓存将被转储。在某些后端（特别是 <code>database</code> ），这使得缓存速度 <em>更</em> 快，但代价是缓存未命中更多。</p> </li></ul><p>The Memcached and Redis backends pass the contents of <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-OPTIONS" rel="nofollow" title="OPTIONS">OPTIONS</a> as keyword arguments to the client constructors, allowing for more advanced control of client behavior. For example usage, see below.</p> </li><li> <p><a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-KEY_PREFIX" rel="nofollow" title="KEY_PREFIX">KEY_PREFIX</a>。一个自动包含在 Django 服务器使用的所有缓存键中的字符串（默认为前缀）。</p> <p>查看 <a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#cache-key-prefixing" rel="nofollow" title="缓存文档">缓存文档</a> 获取更多信息。</p> </li><li> <p><a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-VERSION" rel="nofollow" title="VERSION">VERSION</a> ：Django 服务器生成的缓存键的默认版本号。</p> <p>查看 <a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#cache-versioning" rel="nofollow" title="缓存文档">缓存文档</a> 获取更多信息。</p> </li><li> <p><a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-KEY_FUNCTION" rel="nofollow" title="KEY_FUNCTION">KEY_FUNCTION</a> 一个字符串，包含一个函数的点分隔路径，该函数定义了如何将前缀、版本和键组成一个最终的缓存键。</p> <p>查看 <a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#cache-key-transformation" rel="nofollow" title="缓存文档">缓存文档</a> 获取更多信息。</p> </li></ul> 
<p>在本例中，正在配置一个文件系统后端，超时为 60 秒，最大容量 1000 项：</p> 
<pre>CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': '/var/tmp/django_cache',
        'TIMEOUT': 60,
        'OPTIONS': {
            'MAX_ENTRIES': 1000
        }
    }
}
</pre> 
<p>下面是一个基于 <code>pylibmc</code> 的后端配置的例子，它启用了二进制协议、SASL 认证和 <code>ketama</code> 行为模式：</p> 
<pre>CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.PyLibMCCache',
        'LOCATION': '127.0.0.1:11211',
        'OPTIONS': {
            'binary': True,
            'username': 'user',
            'password': 'pass',
            'behaviors': {
                'ketama': True,
            }
        }
    }
}
</pre> 
<p>下面是一个基于 <code>pymemcache</code> 的后端配置实例，它启用了客户端池（通过保持客户端连接来提高性能），将 memcache／网络错误视为缓存失效，并在连接的 socket 上设置了 <code>TCP_NODELAY</code> 标志：</p> 
<pre>CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.memcached.PyMemcacheCache',
        'LOCATION': '127.0.0.1:11211',
        'OPTIONS': {
            'no_delay': True,
            'ignore_exc': True,
            'max_pool_size': 4,
            'use_pooling': True,
        }
    }
}
</pre> 
<p>Here's an example configuration for a <code>redis</code> based backend that selects database <code>10</code> (by default Redis ships with 16 logical databases), specifies a <a href="https://github.com/redis/redis-py#parsers" title="parser class">parser class</a> (<code>redis.connection.HiredisParser</code> will be used by default if the <code>hiredis-py</code> package is installed), and sets a custom <a href="https://github.com/redis/redis-py#connection-pools" title="connection pool class">connection pool class</a> (<code>redis.ConnectionPool</code> is used by default):</p> 
<pre>CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.redis.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379',
        'OPTIONS': {
            'db': '10',
            'parser_class': 'redis.connection.PythonParser',
            'pool_class': 'redis.BlockingConnectionPool',
        }
    }
}
</pre> 
<h3 id="%E7%AB%99%E7%82%B9%E7%BC%93%E5%AD%98%C2%B6">（四）站点缓存</h3> 
<p>一旦缓存设置完毕，使用缓存最简便的方式就是缓存整个站点。你需要在 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-MIDDLEWARE" rel="nofollow" title="MIDDLEWARE">MIDDLEWARE</a> 设置中添加 <code>'django.middleware.cache.UpdateCacheMiddleware'</code> 和 <code>'django.middleware.cache.FetchFromCacheMiddleware'</code> ，像下面这个例子一样：</p> 
<pre>MIDDLEWARE = [
    'django.middleware.cache.UpdateCacheMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.cache.FetchFromCacheMiddleware',
]
</pre> 
<p>备注</p> 
<p>不，这不是错别字：“update” 中间件必须在列表的第一位，而 “fetch” 中间件必须在最后。细节有点晦涩难懂，但如果你想知道完整的故事，请看下面的 <a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#order-of-middleware" rel="nofollow" title="中间件的顺序">中间件的顺序</a> 。</p> 
<p>最后，在 Django 设置文件里添加下面的必需配置：</p> 
<ul><li><a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHE_MIDDLEWARE_ALIAS" rel="nofollow" title="CACHE_MIDDLEWARE_ALIAS">CACHE_MIDDLEWARE_ALIAS</a> -- 用于存储的缓存别名。</li><li><a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHE_MIDDLEWARE_SECONDS" rel="nofollow" title="CACHE_MIDDLEWARE_SECONDS">CACHE_MIDDLEWARE_SECONDS</a> -- 应缓存每个页面的秒数。</li><li><a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHE_MIDDLEWARE_KEY_PREFIX" rel="nofollow" title="CACHE_MIDDLEWARE_KEY_PREFIX">CACHE_MIDDLEWARE_KEY_PREFIX</a> -- 如果使用相同的 Django installation ，通过多站点进行缓存共享，请将此值设置为站点名，或者设置成在Django 实例中唯一的其他字符串，以此防止键冲突。如果你不介意，可以设置成空字符串。</li></ul> 
<p>在请求和响应标头允许的情况下，<code>FetchFromCacheMiddleware</code> 缓存状态为200的 GET 和 HEAD 响应。对于具有不同查询参数的相同URL的请求的响应被认为是单独的页面，并分别缓存。这个中间件期望一个HEAD请求的响应头与相应的GET请求具有相同的响应头；在这种情况下，它可以为HEAD请求返回一个缓存的GET响应。</p> 
<p>此外，<code>UpdateCacheMiddleware</code> 在每个 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/request-response/#django.http.HttpResponse" rel="nofollow" title="HttpResponse">HttpResponse</a> 里会自动设置一些 headers，这会影响 <a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#downstream-caches" rel="nofollow" title="下游缓存">下游缓存</a>:</p> 
<ul><li>设置 <code>Expires</code> header 为当前日期/时间加上定义的 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHE_MIDDLEWARE_SECONDS" rel="nofollow" title="CACHE_MIDDLEWARE_SECONDS">CACHE_MIDDLEWARE_SECONDS</a> 。</li><li>设置 <code>Cache-Control</code> header 为缓存页面的最长时间，同样，在 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHE_MIDDLEWARE_SECONDS" rel="nofollow" title="CACHE_MIDDLEWARE_SECONDS">CACHE_MIDDLEWARE_SECONDS</a> 里设置。</li></ul> 
<p>查看 <a href="https://docs.djangoproject.com/zh-hans/4.0/topics/http/middleware/" rel="nofollow" title="中间件">中间件</a> 获取更多中间件信息。</p> 
<p>如果一个视图设置了它自己的缓存过期时间（比如在它的 <code>Cache-Control</code> header 里有 <code>max-age</code> 部分），然后页面将被缓存起来直到过期，而不是 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHE_MIDDLEWARE_SECONDS" rel="nofollow" title="CACHE_MIDDLEWARE_SECONDS">CACHE_MIDDLEWARE_SECONDS</a> 。使用在 <code>django.views.decorators.cache</code> 的装饰器，你可以很轻松的设置视图的过期时间（使用 <a href="https://docs.djangoproject.com/zh-hans/4.0/topics/http/decorators/#django.views.decorators.cache.cache_control" rel="nofollow" title="cache_control()">cache_control()</a> 装饰器）或者禁用视图缓存（使用 <a href="https://docs.djangoproject.com/zh-hans/4.0/topics/http/decorators/#django.views.decorators.cache.never_cache" rel="nofollow" title="never_cache()">never_cache()</a> 装饰器）。有关这些装饰器的更多信息，请查看 <a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#controlling-cache-using-other-headers" rel="nofollow" title="using other headers">using other headers</a> 部分。</p> 
<p id="i18n-cache-key">如果设置 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-USE_I18N" rel="nofollow" title="USE_I18N">USE_I18N</a> 为 <code>True</code>，然后已生成的缓存键将包含动态 <a href="https://docs.djangoproject.com/zh-hans/4.0/topics/i18n/#term-language-code" rel="nofollow" title="language">language</a> 的名称（参阅 <a href="https://docs.djangoproject.com/zh-hans/4.0/topics/i18n/translation/#how-django-discovers-language-preference" rel="nofollow" title="Django 如何发现语言偏好">Django 如何发现语言偏好</a>）。这将允许你轻松缓存使用多语言的站点，而不用再创建缓存键。</p> 
<p>当 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-USE_TZ" rel="nofollow" title="USE_TZ">USE_TZ</a> 被设置为 <code>True</code> 时，缓存键也包括 <a href="https://docs.djangoproject.com/zh-hans/4.0/topics/i18n/timezones/#default-current-time-zone" rel="nofollow" title="当前时区">当前时区</a>。</p> 
<h3 id="%E8%A7%86%E5%9B%BE%E7%BC%93%E5%AD%98%C2%B6">（五）视图缓存</h3> 
<p><code>django.views.decorators.cache.</code><code>cache_page</code>(<em>timeout</em>, <em>*</em>, <em>cache=None</em>, <em>key_prefix=None</em>)<a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#django.views.decorators.cache.cache_page" rel="nofollow" title="¶">¶</a></p> 
<p>使用缓存框架的通用办法是缓存视图结果。<code>django.views.decorators.cache</code> 定义了一个 <code>cache_page</code> 装饰器，它将自动缓存视图的响应：</p> 
<pre>from django.views.decorators.cache import cache_page

@cache_page(60 * 15)
def my_view(request):
    ...
</pre> 
<p><code>cache_page</code> 使用了一个单独的参数：缓存过期时间，以秒为单位。在上面的例子里，<code>my_view()</code> 视图的结果将缓存15分钟。（注意，我们用 <code>60 * 15</code> 这样的方式编写，目的是方便阅读。 <code>60 * 15</code> 将计算为 <code>900</code>，也就是15分钟乘以每分钟60秒。）</p> 
<p><code>cache_page</code> 设置的缓存超时优先于 <code>Cache-Control</code> 头中的 <a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#id1" rel="nofollow" title="``  ">``</a>max-age'' 指令。</p> 
<p>和缓存站点一样，对视图缓存，以 URL 为键。如果许多 URL 指向相同的视图，每个 URL 将被单独缓存。继续以 <code>my_view</code> 为例，如果你的 URLconf 是这样的：</p> 
<pre>urlpatterns = [
    path('foo/&lt;int:code&gt;/', my_view),
]
</pre> 
<p>那么 <code>/foo/1/</code> 和 <code>/foo/23/</code> 的请求将被分别缓存，正如你所料。但一旦部分 URL （比如 <code>/foo/23/</code> ）已经被请求，那么随后的请求都将使用缓存。</p> 
<p><code>cache_page</code> 也可以传递可选关键字参数 <code>cache</code>，它指引装饰器在缓存视图结果时使用特定的缓存（来自 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES" rel="nofollow" title="CACHES">CACHES</a> 设置）。默认情况下，将使用默认缓存，但你可以指定任何你想要的缓存：</p> 
<pre>@cache_page(60 * 15, cache="special_cache")
def my_view(request):
    ...
</pre> 
<p>你可以基于每个视图覆盖缓存前缀。<code>cache_page</code> 传递了一个可选关键字参数 <code>key_prefix</code> ，它的工作方式与中间件的 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHE_MIDDLEWARE_KEY_PREFIX" rel="nofollow" title="CACHE_MIDDLEWARE_KEY_PREFIX">CACHE_MIDDLEWARE_KEY_PREFIX</a> 相同。可以这样使用它：</p> 
<pre>@cache_page(60 * 15, key_prefix="site1")
def my_view(request):
    ...
</pre> 
<p><code>key_prefix</code> 和 <code>cache</code> 参数可能需要被一起指定。<code>key_prefix</code> 参数和 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES" rel="nofollow" title="CACHES">CACHES</a> 下指定的 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-KEY_PREFIX" rel="nofollow" title="KEY_PREFIX">KEY_PREFIX</a> 将被连接起来。</p> 
<p>此外， <code>cache_page</code> 在响应中自动设置 <code>Cache-Control</code> 和 <code>Expires</code> 头， 这会影响 <a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#downstream-caches" rel="nofollow" title="下游缓存">下游缓存</a>.</p> 
<h3 id="%E5%9C%A8%20URLconf%20%E4%B8%AD%E6%8C%87%E5%AE%9A%E8%A7%86%E5%9B%BE%E7%BC%93%E5%AD%98%C2%B6">（六）在 URLconf 中指定视图缓存</h3> 
<p>上一节的例子硬编码了视图被缓存的事实，因为 <code>cache_page</code> 改变了 <code>my_view</code> 函数。这种方法将你的视图和缓存系统耦合起来，这样并不理想。例如，你可能想在其他没有缓存的站点上重用这个视图函数，或者你可能想分发这个视图给那些想使用视图但不想缓存它们的人员。解决这些问题的办法是在 URLconf 中指定视图缓存，而不是视图函数旁边指定。</p> 
<p>当你在 URLconf 中使用 <code>cache_page</code> 时，可以这样包装视图函数。这是之前提到的 URLconf：</p> 
<pre>urlpatterns = [
    path('foo/&lt;int:code&gt;/', my_view),
]
</pre> 
<p>将 <code>my_view</code> 包含在 <code>cache_page</code> 中：</p> 
<pre>from django.views.decorators.cache import cache_page

urlpatterns = [
    path('foo/&lt;int:code&gt;/', cache_page(60 * 15)(my_view)),
]
</pre> 
<h3 id="%E6%A8%A1%E6%9D%BF%E7%89%87%E6%AE%B5%E7%BC%93%E5%AD%98%C2%B6">（七）模板片段缓存</h3> 
<p>如果你获得更多的控制，你也可以使用 <code>cache</code> 模板标签(tag)来缓存模板片段。要使你的模板能够访问这个标签，请将 <code>{% load cache %}</code> 放在模板顶部。</p> 
<p><code>{% cache %}</code> 模板标签在给定的时间里缓存片段内容。它需要至少两个参数：缓存时效时间（以秒为单位），缓存片段的名称。如果缓存失效时间被设置为 <code>None</code> ，那么片段将被永久缓存。名称不能使变量名。例如：</p> 
<pre>{% load cache %}
{% cache 500 sidebar %}
    .. sidebar ..
{% endcache %}
</pre> 
<p>有时你想缓存片段的多个副本，这取决于显示在的片段内一些动态数据。比如，你可能想为你的站点内每个用户分别独立缓存上面例子中的使用的 sidebar 副本。通过传递一个或多个附加参数，参数可能是带有或不带过滤器的变量，<code>{% cache %}</code> 模板标签必须在缓存片断中被唯一识别：</p> 
<pre>{% load cache %}
{% cache 500 sidebar request.user.username %}
    .. sidebar for logged in user ..
{% endcache %}
</pre> 
<p>如果 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-USE_I18N" rel="nofollow" title="USE_I18N">USE_I18N</a> 被设为 <code>True</code>，那么站点中间件缓存将支持多语言（ respect the active language ）。对于 <code>cache</code> 模板标签来说，你可以使用模板中可用的特定翻译变量之一（ translation-specific variables ）来达到同样的结果：</p> 
<pre>{% load i18n %}
{% load cache %}

{% get_current_language as LANGUAGE_CODE %}

{% cache 600 welcome LANGUAGE_CODE %}
    {% translate "Welcome to example.com" %}
{% endcache %}
</pre> 
<p>缓存失效时间可以是模板变量，只要模板变量解析为一个整数值即可。例如，如果模板变量 <code>my_timeout</code> 被设置成 <code>600</code>，那么下面两个例子是一样的：</p> 
<pre>{% cache 600 sidebar %} ... {% endcache %}
{% cache my_timeout sidebar %} ... {% endcache %}
</pre> 
<p>这个可以避免在模板中重复。你可以在某处设置缓存失效时间，然后复用这个值。</p> 
<p>默认情况下，缓存标签会先尝试使用名为 "template_fragments" 的缓存。如果这个缓存不存在，它将回退使用默认缓存。你可以选择一个备用缓存后端与 <code>using</code> 关键字参数一起使用，这个参数必须是标签的最后一个参数。</p> 
<pre>{% cache 300 local-thing ...  using="localcache" %}
</pre> 
<p>未设置指定的缓存名称将被视为错误。</p> 
<p><code>django.core.cache.utils.</code><code>make_template_fragment_key</code>(<em>fragment_name</em>, <em>vary_on=None</em>)<a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#django.core.cache.utils.make_template_fragment_key" rel="nofollow" title="¶">¶</a></p> 
<p>如果你想获得用于缓存片段的缓存键，你可以使用 <code>make_template_fragment_key</code> 。<code>fragment_name</code> 是 <code>cache</code> 模板标签的第二个参数；<code>vary_on</code> 是所有传递给标签的附加参数列表。这个函数可用来使缓存项无效或者重写。例如：</p> 
<pre>&gt;&gt;&gt; from django.core.cache import cache
&gt;&gt;&gt; from django.core.cache.utils import make_template_fragment_key
# cache key for {% cache 500 sidebar username %}
&gt;&gt;&gt; key = make_template_fragment_key('sidebar', [username])
&gt;&gt;&gt; cache.delete(key) # invalidates cached template fragment
True
</pre> 
<h3 id="%E5%BA%95%E5%B1%82%E7%BC%93%E5%AD%98%20API%C2%B6">（八）底层缓存 API</h3> 
<p>有时，缓存整个渲染页面并不会带来太多好处，事实上，这样会很不方便。</p> 
<p>或许，你的站点包含了一个视图，它的结果依赖于许多费时的查询，而且结果会随着时间变化而改变。在这个情况下，使用站点或视图缓存策略提供的全页面缓存并不理想，因为不能缓存所有结果（一些数据经常变动），不过你仍然可以缓存几乎没有变化的结果。</p> 
<p>像这样的情况，Django 公开了一个底层的缓存 API 。你可以使用这个 API 以任意级别粒度在缓存中存储对象。你可以缓存任何可以安全的 pickle 的 Python 对象：模型对象的字符串、字典、列表，或者其他。（大部分通用的 Python 对象都可以被 pickle；可以参考 Python 文档关于 pickling 的信息）</p> 
<h3 id="%E8%AE%BF%E9%97%AE%E7%BC%93%E5%AD%98%C2%B6">（九）访问缓存</h3> 
<p><code>django.core.cache.</code><code>caches</code><a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#django.core.cache.caches" rel="nofollow" title="¶">¶</a></p> 
<p>你可以通过类似字典一样的 object: <code>django.core.cache.caches</code> 对象访问在 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES" rel="nofollow" title="CACHES">CACHES</a> 配置的缓存。重复请求同一个线程里的同一个别名将返回同一个对象。</p> 
<pre>&gt;&gt;&gt; from django.core.cache import caches
&gt;&gt;&gt; cache1 = caches['myalias']
&gt;&gt;&gt; cache2 = caches['myalias']
&gt;&gt;&gt; cache1 is cache2
True
</pre> 
<p>如果键名不存在，将会引发 <code>InvalidCacheBackendError</code> 错误。</p> 
<p>为了支持线程安全，将为每个线程返回缓存后端的不同实例。</p> 
<p><code>django.core.cache.</code><code>cache</code><a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#django.core.cache.cache" rel="nofollow" title="¶">¶</a></p> 
<p>作为快捷方式，默认缓存可以通过 <code>django.core.cache.cache</code> 引用：</p> 
<pre>&gt;&gt;&gt; from django.core.cache import cache
</pre> 
<p>这个对象等价于 <code>caches['default']</code> 。</p> 
<h2 id="%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%C2%B6">四、基本用法</h2> 
<p>基本接口是：</p> 
<p><code>cache.</code><code>set</code>(<em>key</em>, <em>value</em>, <em>timeout=DEFAULT_TIMEOUT</em>, <em>version=None</em>)<a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#django.core.caches.cache.set" rel="nofollow" title="¶">¶</a></p> 
<pre>&gt;&gt;&gt; cache.set('my_key', 'hello, world!', 30)
</pre> 
<p><code>cache.</code><code>get</code>(<em>key</em>, <em>default=None</em>, <em>version=None</em>)<a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#django.core.caches.cache.get" rel="nofollow" title="¶">¶</a></p> 
<pre>&gt;&gt;&gt; cache.get('my_key')
'hello, world!'
</pre> 
<p><code>key</code> 是一个字符串，<code>value</code> 可以任何 picklable 形式的 Python 对象。</p> 
<p><code>timeout</code> 参数是可选的，默认为 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES" rel="nofollow" title="CACHES">CACHES</a> 中相应后端的 <code>timeout</code> 参数。它是值存在缓存里的秒数。<code>timeout</code> 设置为 <code>None</code> 时将永久缓存。<code>timeout</code> 为0将不缓存值。</p> 
<p>如果对象不在缓存中，<code>cache.get()</code> 将返回 <code>None</code>。</p> 
<pre>&gt;&gt;&gt; # Wait 30 seconds for 'my_key' to expire...
&gt;&gt;&gt; cache.get('my_key')
None
</pre> 
<p>如果你需要确定对象是否存在于缓存中，并且你已经存储了一个字面值 <code>None</code>，使用一个前哨对象作为默认：</p> 
<pre>&gt;&gt;&gt; sentinel = object()
&gt;&gt;&gt; cache.get('my_key', sentinel) is sentinel
False
&gt;&gt;&gt; # Wait 30 seconds for 'my_key' to expire...
&gt;&gt;&gt; cache.get('my_key', sentinel) is sentinel
True
</pre> 
<p><code>MemcachedCache</code></p> 
<p>由于 <code>python-memcached</code> 的限制，在已废弃的 <code>MemcachedCache</code> 后端，不可能区分存储的 <code>None</code> 值和返回值为 <code>None</code> 的缓存失效。</p> 
<p><code>cache.get()</code> 可以带一个默认参数。如果对象不在缓存中，将返回指定的值。</p> 
<pre>&gt;&gt;&gt; cache.get('my_key', 'has expired')
'has expired'
</pre> 
<p><code>cache.</code><code>add</code>(<em>key</em>, <em>value</em>, <em>timeout=DEFAULT_TIMEOUT</em>, <em>version=None</em>)<a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#django.core.caches.cache.add" rel="nofollow" title="¶">¶</a></p> 
<p>在键不存在的时候，使用 <code>add()</code> 方法可以添加键。它与 <code>set()</code> 带有相同的参数，但如果指定的键已经存在，将不会尝试更新缓存。</p> 
<pre>&gt;&gt;&gt; cache.set('add_key', 'Initial value')
&gt;&gt;&gt; cache.add('add_key', 'New value')
&gt;&gt;&gt; cache.get('add_key')
'Initial value'
</pre> 
<p>如果你想知道通过 <code>add()</code> 存储的值是否在缓存中，你可以检查返回值。如果值已保存，将返回 <code>True</code> ，否则返回 <code>False</code> 。</p> 
<p><code>cache.</code><code>get_or_set</code>(<em>key</em>, <em>default</em>, <em>timeout=DEFAULT_TIMEOUT</em>, <em>version=None</em>)<a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#django.core.caches.cache.get_or_set" rel="nofollow" title="¶">¶</a></p> 
<p>如果你想得到键值或者如果键不在缓存中时设置一个值，可以使用 <code>get_or_set()</code> 方法。它带有和 <code>get()</code> 一样的参数，但默认是为那个键设置一个新缓存值，而不是返回：</p> 
<pre>&gt;&gt;&gt; cache.get('my_new_key')  # returns None
&gt;&gt;&gt; cache.get_or_set('my_new_key', 'my new value', 100)
'my new value'
</pre> 
<p>你也可以传递任何可调用的值作为默认值：</p> 
<pre>&gt;&gt;&gt; import datetime
&gt;&gt;&gt; cache.get_or_set('some-timestamp-key', datetime.datetime.now)
datetime.datetime(2014, 12, 11, 0, 15, 49, 457920)
</pre> 
<p><code>cache.</code><code>get_many</code>(<em>keys</em>, <em>version=None</em>)<a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#django.core.caches.cache.get_many" rel="nofollow" title="¶">¶</a></p> 
<p>这里也有 <code>get_many()</code> 接口，返回一个字典，其中包含你请求的键，这些键真实存在缓存中（并且没过期）：</p> 
<pre>&gt;&gt;&gt; cache.set('a', 1)
&gt;&gt;&gt; cache.set('b', 2)
&gt;&gt;&gt; cache.set('c', 3)
&gt;&gt;&gt; cache.get_many(['a', 'b', 'c'])
{'a': 1, 'b': 2, 'c': 3}
</pre> 
<p><code>cache.</code><code>set_many</code>(<em>dict</em>, <em>timeout</em>)<a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#django.core.caches.cache.set_many" rel="nofollow" title="¶">¶</a></p> 
<p>使用 <code>set_many()</code> 传递键值对的字典，可以更有效的设置多个值。</p> 
<pre>&gt;&gt;&gt; cache.set_many({'a': 1, 'b': 2, 'c': 3})
&gt;&gt;&gt; cache.get_many(['a', 'b', 'c'])
{'a': 1, 'b': 2, 'c': 3}
</pre> 
<p>类似 <code>cache.set()</code>，<code>set_many()</code> 带有一个可选的 <code>timeout</code> 参数。</p> 
<p>在已支持的后端（memcached），<code>set_many()</code> 会返回无法插入的键列表。</p> 
<p><code>cache.</code><code>delete</code>(<em>key</em>, <em>version=None</em>)<a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#django.core.caches.cache.delete" rel="nofollow" title="¶">¶</a></p> 
<p>你可以使用 <code>delete()</code> 显示地删除键，以清空特定对象的缓存：</p> 
<pre>&gt;&gt;&gt; cache.delete('a')
True
</pre> 
<p>如果键被成功删除，将返回 <code>delete()</code> ，否则返回 <code>False</code> 。</p> 
<p><code>cache.</code><code>delete_many</code>(<em>keys</em>, <em>version=None</em>)<a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#django.core.caches.cache.delete_many" rel="nofollow" title="¶">¶</a></p> 
<p>如果你想一次性清除很多键，给 <code>delete_many()</code> 传递一个键列表即可删除。</p> 
<pre>&gt;&gt;&gt; cache.delete_many(['a', 'b', 'c'])
</pre> 
<p><code>cache.</code><code>clear</code>()<a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#django.core.caches.cache.clear" rel="nofollow" title="¶">¶</a></p> 
<p>最后，如果你想删除缓存里的所有键，使用 <code>cache.clear()</code>。注意，<code>clear()</code> 将删除缓存里的 <em>任何</em> 键，不只是你应用里设置的那些键。</p> 
<pre>&gt;&gt;&gt; cache.clear()
</pre> 
<p><code>cache.</code><code>touch</code>(<em>key</em>, <em>timeout=DEFAULT_TIMEOUT</em>, <em>version=None</em>)<a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#django.core.caches.cache.touch" rel="nofollow" title="¶">¶</a></p> 
<p><code>cache.touch()</code> 为键设置一个新的过期时间。比如，更新一个键为从现在起10秒钟后过期：</p> 
<pre>&gt;&gt;&gt; cache.touch('a', 10)
True
</pre> 
<p>和其他方法一样，<code>timeout</code> 参数是可选的，并且默认是 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES" rel="nofollow" title="CACHES">CACHES</a> 设置的相应后端的 <code>TIMEOUT</code> 选项。</p> 
<p>如果键被成功 <code>touch()</code>，将返回 <code>True</code>，否则返回 <code>False</code>。</p> 
<p><code>cache.</code><code>incr</code>(<em>key</em>, <em>delta=1</em>, <em>version=None</em>)<a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#django.core.caches.cache.incr" rel="nofollow" title="¶">¶</a></p> 
<p><code>cache.</code><code>decr</code>(<em>key</em>, <em>delta=1</em>, <em>version=None</em>)<a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#django.core.caches.cache.decr" rel="nofollow" title="¶">¶</a></p> 
<p>你也可以使用分别使用 <code>incr()</code> 或 <code>decr()</code> 方法来递增或递减一个已经存在的键的值。默认情况下，存在的缓存值将递增或递减1。通过为递增/递减的调用提供参数来指定其他递增/递减值。如果你试图递增或递减一个不存在的缓存键，将会引发 ValueError 错误。</p> 
<pre>&gt;&gt;&gt; cache.set('num', 1)
&gt;&gt;&gt; cache.incr('num')
2
&gt;&gt;&gt; cache.incr('num', 10)
12
&gt;&gt;&gt; cache.decr('num')
11
&gt;&gt;&gt; cache.decr('num', 5)
6
</pre> 
<p>备注</p> 
<p>不保证 <code>incr()</code> / <code>decr()</code> 方法是原子。那些后端支持原子递增/递减（最值得注意的是 memcached 后端），递增和递减操作是原子的。然而，如果后端本身没有提供递增/递减方法，则将使用两步（检索和更新）来实现。</p> 
<p><code>cache.</code><code>close</code>()<a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#django.core.caches.cache.close" rel="nofollow" title="¶">¶</a></p> 
<p>如果缓存后端已经实现了 <code>close()</code> 方法，你可以关闭和缓存的连接。</p> 
<pre>&gt;&gt;&gt; cache.close()
</pre> 
<p>备注</p> 
<p>对于没有实现 <code>close</code> 方法的缓存，它将无效操作。</p> 
<p>备注</p> 
<p>The async variants of base methods are prefixed with <code>a</code>, e.g. <code>cache.aadd()</code> or <code>cache.adelete_many()</code>. See <a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#id14" rel="nofollow" title="Asynchronous support">Asynchronous support</a> for more details.</p> 
<p>Changed in Django 4.0:</p> 
<p>The async variants of methods were added to the <code>BaseCache</code>.</p> 
<h4 id="%E7%BC%93%E5%AD%98%E9%94%AE%E5%89%8D%E7%BC%80%C2%B6">1.缓存键前缀</h4> 
<p>如果你正在服务器之间或者生产/开发缓存之间共享缓存实例，有可能会使得一个服务器使用另一个服务器的缓存数据。如果缓存数据格式是相同的，这会导致一些难以诊断的问题。</p> 
<p>为了防止这个问题，Django 为单台服务器提供了为所有缓存键提供前缀的方法。当一个特殊的缓存键被保存或检索时，Django 会为缓存键自动添加 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-KEY_PREFIX" rel="nofollow" title="KEY_PREFIX">KEY_PREFIX</a> 缓存设置的前缀值。</p> 
<p>要确保每个 Django 实例有不同的 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-KEY_PREFIX" rel="nofollow" title="KEY_PREFIX">KEY_PREFIX</a> ，这样就保证缓存值不会发生冲突。</p> 
<h4 id="%E7%BC%93%E5%AD%98%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%C2%B6">2.缓存版本控制</h4> 
<p>当更改使用缓存值的运行代码时，你可能需要清除任何已存的缓存值。最简单的方法是刷新整个缓存，但这会导致那些仍然有用且有效的缓存值。</p> 
<p>Django 提供更好的方式来指向单个缓存值。Django 缓存框架有一个系统范围的版本标识，需要在 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-VERSION" rel="nofollow" title="VERSION">VERSION</a> 缓存配置中指定。这个配置的值将自动与缓存前缀和用户提供的缓存键组合起来获取最终的缓存键。</p> 
<p>默认情况下，任何键请求将自动包含站点默认缓存键版本。但是，早期的缓存函数都包含一个 <code>version</code> 参数，因此你可以指定 set 还是 get 特定缓存键的版本。举例：</p> 
<pre>&gt;&gt;&gt; # Set version 2 of a cache key
&gt;&gt;&gt; cache.set('my_key', 'hello world!', version=2)
&gt;&gt;&gt; # Get the default version (assuming version=1)
&gt;&gt;&gt; cache.get('my_key')
None
&gt;&gt;&gt; # Get version 2 of the same key
&gt;&gt;&gt; cache.get('my_key', version=2)
'hello world!'
</pre> 
<p>一个指定键的版本可以使用 <code>incr_version()</code> 和 <code>decr_version()</code> 方法来递增或递减。这使得特定键会自动获取新版本，而不影响其他键。继续我们前面的例子：</p> 
<pre>&gt;&gt;&gt; # Increment the version of 'my_key'
&gt;&gt;&gt; cache.incr_version('my_key')
&gt;&gt;&gt; # The default version still isn't available
&gt;&gt;&gt; cache.get('my_key')
None
# Version 2 isn't available, either
&gt;&gt;&gt; cache.get('my_key', version=2)
None
&gt;&gt;&gt; # But version 3 *is* available
&gt;&gt;&gt; cache.get('my_key', version=3)
'hello world!'
</pre> 
<h4 id="%E7%BC%93%E5%AD%98%E9%94%AE%E8%BD%AC%E6%8D%A2%C2%B6">3.缓存键转换</h4> 
<p>如前面两节所述，用户提供的缓存键不是单独使用的，它是与缓存前缀和键版本组合后获取最终缓存键。默认情况下，使用冒号连接这三部分生成最终的字符串：</p> 
<pre>def make_key(key, key_prefix, version):
    return '%s:%s:%s' % (key_prefix, version, key)
</pre> 
<p>如果你想用不同方式组合，或者应用其他处理来获得最终键（比如，获得关键部分的哈希摘要），那么你可以提供一个自定义的键函数。</p> 
<p><a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-KEY_FUNCTION" rel="nofollow" title="KEY_FUNCTION">KEY_FUNCTION</a> 缓存设置指定一个与上面的 <code>make_key()</code> 原型匹配的函数路径。如果提供，这个自定义键函数将代替默认的键组合函数来使用。</p> 
<h4 id="%E7%BC%93%E5%AD%98%E9%94%AE%E8%AD%A6%E5%91%8A%C2%B6">4.缓存键警告</h4> 
<p>Memcached 作为最常用的缓存后端，不允许缓存键超过250个字符、包含空格或控制字符，并且使用这些键将会导致异常。为了增加代码可移植性和最小惊讶，如果使用会导致 memcached 报错的键，那么其他内置的缓存框架会发出警告（ <code>django.core.cache.backends.base.CacheKeyWarning</code> ）。</p> 
<p>如果你正在使用的生产后端能接受更大范围的键（自定义后端或非 memcached 的内置后端），并且在没有警告的情况下使用更广的范围，你可以在 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-INSTALLED_APPS" rel="nofollow" title="INSTALLED_APPS">INSTALLED_APPS</a> 中的 <code>management</code> 模块里静默 <code>CacheKeyWarning</code> 使用这个代码：</p> 
<pre>import warnings

from django.core.cache import CacheKeyWarning

warnings.simplefilter("ignore", CacheKeyWarning)
</pre> 
<p>如果你想为某个内置的后端提供自定义的键检验逻辑，你可以将其子类化，只覆盖 <code>validate_key</code> 方法，并且按照 <code>使用自定义缓存后端</code> 的说明操作。比如，想要为 <code>locmem</code> 后端执行此操作，请将下面代码放入模块中：</p> 
<pre>from django.core.cache.backends.locmem import LocMemCache

class CustomLocMemCache(LocMemCache):
    def validate_key(self, key):
        """Custom validation, raising exceptions or warnings as needed."""
        ...
</pre> 
<p>...然后在 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES" rel="nofollow" title="CACHES">CACHES</a> 里的 <a href="https://docs.djangoproject.com/zh-hans/4.0/ref/settings/#std-setting-CACHES-BACKEND" rel="nofollow" title="BACKEND">BACKEND</a> 部分使用路径导入此类。</p> 
<h2 id="%E5%BC%82%E6%AD%A5%E6%94%AF%E6%8C%81%C2%B6">五、异步支持</h2> 
<p>New in Django 4.0.</p> 
<p>Django has developing support for asynchronous cache backends, but does not yet support asynchronous caching. It will be coming in a future release.</p> 
<p><code>django.core.cache.backends.base.BaseCache</code> has async variants of <a href="https://docs.djangoproject.com/zh-hans/4.0/topics/cache/#cache-basic-interface" rel="nofollow" title="all base methods">all base methods</a>. By convention, the asynchronous versions of all methods are prefixed with <code>a</code>. By default, the arguments for both variants are the same:</p> 
<pre>&gt;&gt;&gt; await cache.aset('num', 1)
&gt;&gt;&gt; await cache.ahas_key('num')
True
</pre> 
<h2 id="%E4%B8%89%E3%80%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">六、注意事项</h2> 
<p style="text-align:justify;">1.全站缓存时文章的更新</p> 
<p style="text-align:justify;">启用缓存之后网站的访问速度是提升，但是同样的在新建页面的时候，比如说新增一篇文章，网站页面不会立即显示这篇文章，因为首页的内容已经被放到了缓存中，当你再次访问的时候，Django不是从数据库中捞数据，而是从缓存中捞数据。解决方法就是给函数前设置一个页面缓存。</p> 
<div> 
 <pre><code>from django.views.decorators.cache import cache_page
@cache_page(60) # 60代表缓存的寿命,表示缓存时长60秒钟
def memcached(req):
    return render(req,"memcached.html")
</code></pre> 
</div> 
<p> 2.post请求是更新缓存</p> 
<p>参考链接：<a href="https://blog.csdn.net/u011510825/article/details/50393380" title="django 自带页面缓存cache_page的使用及清除_果汁华的博客-CSDN博客">django 自带页面缓存cache_page的使用及清除_果汁华的博客-CSDN博客</a></p> 
<div> 
 <pre><code>from django.core.cache import cache
from django.utils.cache import get_cache_key

def expire_page(requset):
    key = get_cache_key(request)
    print(key )
    #判断缓存中是否存在
    if cache.has_key(key):
        cache.delete(key)</code></pre> 
</div> 
<p></p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/62e0d2585df4489a05e17a3ea762b04f/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">IO图解及Java中InputStream，OutputStream，FileReader，FileWriter用法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/bfda14e7e948b4ef3b4c73ef0ea9efd0/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">曙光超算slurm作业使用</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>