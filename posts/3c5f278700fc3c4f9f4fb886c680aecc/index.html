<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>react原理-transition概念 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="react原理-transition概念" />
<meta property="og:description" content="在react18之中，引入了transition的概念。而且有一个新的api和两个新的hooks
startTransitionuseTransitionuseDeferredValue 场景应用：
比如通过输入框输入内容更新列表内容，对于用户来说，输入框输入之后立马反馈的优先级是高过于列表更新的优先级的。但是对于18之前的版本来说，更新没有分优先级，导致如果数据量大，列表更新慢，用户输入在输入框输入内容后很慢才能得到反馈，用户体验差。
而transition可以让列表更新的优先级降低，让用户输入的先处理，然后再处理列表更新。18之后开启了concurrent mode模式，更新也分了优先级的概念。
用法：
setData1(e) startTransition(()=&gt;{ setData2(e) }) 将需要延迟更新的任务放到startTransition去执行，这样里面的更新任务就会被赋予transition的优先级。
setTimeout setTimeout也有类似于延迟更新的效果，比如
setData1(e) setTimeout(()=&gt;{ setData2(e) }, 200) 跟startTransition相比，startTransition的本质是，将任务的优先级降低，所以当用户一致输入的时候，优先级较低的任务，不会阻碍输入框的回显。并且transition的时机，是比setTImeout更加合适的，他会在没有搞优先级任务的情况下，第一时间处理。而setTimeout的时间是人为控制的，不够准确。第二则是，当渲染任务多的时候，setTImeout仍会阻碍搞优先级的任务，因为等延时时间一到，setTImeout里面的任务就会被执行，此时仍会阻止页面的交互。但是transition就不同了，在conCurrent mode下，react将该任务的优先级降低，等到浏览器空闲的时候才会执行。但也不是说startTransition的任务永远不会影响主流程，因为在react中，每个任务都有过期时间，而过渡任务的过期时间比紧急任务长了很多而已，但是当该过渡任务迟迟得不到处理，并且已经过期的时候，react就会先处理这个过期的过渡任务，然后再继续调度。具体可以了解react的schedlue模块。 防抖 输入框的内容经常跟防抖节流打交道，但是其本质也是通过setTimeout，只不过控制了render的次数，而且防抖节流也需要人为的控制时间，而使用startTransition就不需要考虑这么多。 transition功能特性 transition顾名思义过度，状态更新的任务一般有两种，一种是紧急更新任务，比如用户交互行为，点击，输入等等。
而另一种则是过渡更新任务，比如上面列表的更新，这种任务的优先级低于紧急更新任务。
startTransition startTransition(fn) 同步执行，但是fn里面的更新会被标记transition的优先级。也就是优先级更低了。
useTransition startTransition只是用来降低优先级的，也就是过渡，但是过渡了多久我们需要一个状态来知道。useTransition就是用来做这个事情的。
const [isPending, startTransition] = useTransition() startTransition(fn) useTransition返回两个值，第一个就是是否正在过渡到控制变量，第二个就是跟startTransition用法一样的，用来降低任务优先级的函数。但任务处于过渡阶段的时候，isPending为true，告诉开发者，目前该任务正在过渡。
useDeferredValue 上述的startTransition和useTransition本质都是将一些任务的优先级降低。
而useDeferredValue可以让状态滞后更新。实现效果类似于transiton，当紧急的任务执行之后，再得到新的状态，而这个新的状态就是deferredValue。
跟useTransition的区别 同：内部实现一样，都是将任务标记为过渡更新任务。
别：
useTransition是将处理一段逻辑，将任务变为过渡任务，useDeferredValue是将原值通过过渡任务后得到新的值，他是产生一个新的状态。其次就是useDeferredValue的更新会更滞后于useTransition，因为内部是使用useEffect来调用startTranstion的。下面原理环节会讲到。 原理 startTransition startTransition的源码实现
他的本质有点类似于17之前的事件更新，通过开关ReactCurrentBAtchConfig.transition
ReactCurrentBAtchConfig.transition默认值是null，再需要更新过渡任务的时候，将其置为{}，这样startTransition里面的函数执行的时候，就会判断ReactCurrentBAtchConfig.transition以此来将其优先级降低。
useTransition mount更新阶段，执行的函数是mountTransition，update阶段执行的函数是updateTransition
如图是mountTransition，本质很简单，就是通过调用mountState产生一个状态，然后通过startTransition绑定默认参数，调用moutnWorkInProgressHook创建hooks对象，跟其他hook链接，最后这个hooks.memoizedState保存的就是startTransition这个函数。
注意这里的startTransition跟上面的startTransition不一样， 如上，则是useTransition返回的第二个参数，本质就是先调用setPending(ture)，然后切换transitiion上下文，让setPending(false)的更新也变成了过渡任务，这样setPending(false)和callback的任务优先级相同，他们会同时处理。
所以useTransition可以看成useState&#43;startTransition
useDeferredValue useDeferredValue本质也是调用了useState&#43;useEffect，通过监听value值的改变，触发useEffect回调函数的更新，再去切换tranition上下文，更新setValue(value)
所以useDeferredValue可以看成：useState&#43;useEffect&#43;startTransition。
看看react如何通过判断transition上下文。 const [data, setData] = useState({}) startTransition(()=&gt;setData({})) 一般startTransition里面函数，存在着触发更新的动作，比如useState的第二个参数setState，他们会创建update，更新优先级，开始调度。具体可以看hooks实现逻辑
所以重点看看产生update时候的优先级的处理，以setState为例子
useState的第二个参数，实际上是调用dispatchSetState函数" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3c5f278700fc3c4f9f4fb886c680aecc/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-12-11T16:08:15+08:00" />
<meta property="article:modified_time" content="2022-12-11T16:08:15+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">react原理-transition概念</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p>在react18之中，引入了transition的概念。而且有一个新的api和两个新的hooks</p> 
<ul><li>startTransition</li><li>useTransition</li><li>useDeferredValue</li></ul> 
<p>场景应用：<br> 比如通过输入框输入内容更新列表内容，对于用户来说，输入框输入之后立马反馈的优先级是高过于列表更新的优先级的。但是对于18之前的版本来说，更新没有分优先级，导致如果数据量大，列表更新慢，用户输入在输入框输入内容后很慢才能得到反馈，用户体验差。</p> 
<p>而transition可以让列表更新的优先级降低，让用户输入的先处理，然后再处理列表更新。18之后开启了concurrent mode模式，更新也分了优先级的概念。</p> 
<p>用法：</p> 
<pre><code class="prism language-ts"><span class="token function">setData1</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
<span class="token function">startTransition</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{<!-- --></span> 
	<span class="token function">setData2</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre> 
<p>将需要延迟更新的任务放到startTransition去执行，这样里面的更新任务就会被赋予transition的优先级。</p> 
<h6><a id="setTimeout_20"></a>setTimeout</h6> 
<p>setTimeout也有类似于延迟更新的效果，比如</p> 
<pre><code class="prism language-ts"><span class="token function">setData1</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{<!-- --></span> 
	<span class="token function">setData2</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span>
</code></pre> 
<ul><li>跟startTransition相比，startTransition的本质是，将任务的优先级降低，所以当用户一致输入的时候，优先级较低的任务，不会阻碍输入框的回显。并且transition的时机，是比setTImeout更加合适的，他会在没有搞优先级任务的情况下，第一时间处理。而setTimeout的时间是人为控制的，不够准确。</li><li>第二则是，当渲染任务多的时候，setTImeout仍会阻碍搞优先级的任务，因为等延时时间一到，setTImeout里面的任务就会被执行，此时仍会阻止页面的交互。但是transition就不同了，在conCurrent mode下，react将该任务的优先级降低，等到浏览器空闲的时候才会执行。</li><li>但也不是说startTransition的任务永远不会影响主流程，因为在react中，每个任务都有过期时间，而过渡任务的过期时间比紧急任务长了很多而已，但是当该过渡任务迟迟得不到处理，并且已经过期的时候，react就会先处理这个过期的过渡任务，然后再继续调度。具体可以了解react的schedlue模块。</li></ul> 
<h6><a id="_32"></a>防抖</h6> 
<ul><li>输入框的内容经常跟防抖节流打交道，但是其本质也是通过setTimeout，只不过控制了render的次数，而且防抖节流也需要人为的控制时间，而使用startTransition就不需要考虑这么多。</li></ul> 
<h4><a id="transition_35"></a>transition功能特性</h4> 
<p>transition顾名思义过度，状态更新的任务一般有两种，一种是紧急更新任务，比如用户交互行为，点击，输入等等。<br> 而另一种则是过渡更新任务，比如上面列表的更新，这种任务的优先级低于紧急更新任务。</p> 
<h5><a id="startTransition_40"></a>startTransition</h5> 
<pre><code>startTransition(fn)
</code></pre> 
<p>同步执行，但是fn里面的更新会被标记transition的优先级。也就是优先级更低了。</p> 
<h5><a id="useTransition_45"></a>useTransition</h5> 
<p>startTransition只是用来降低优先级的，也就是过渡，但是过渡了多久我们需要一个状态来知道。useTransition就是用来做这个事情的。</p> 
<pre><code class="prism language-ts"><span class="token keyword">const</span> <span class="token punctuation">[</span>isPending<span class="token punctuation">,</span> startTransition<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useTransition</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">startTransition</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
</code></pre> 
<p>useTransition返回两个值，第一个就是是否正在过渡到控制变量，第二个就是跟startTransition用法一样的，用来降低任务优先级的函数。但任务处于过渡阶段的时候，isPending为true，告诉开发者，目前该任务正在过渡。</p> 
<h5><a id="useDeferredValue_54"></a>useDeferredValue</h5> 
<p>上述的startTransition和useTransition本质都是将一些任务的优先级降低。<br> 而useDeferredValue可以让状态滞后更新。实现效果类似于transiton，当紧急的任务执行之后，再得到新的状态，而这个新的状态就是deferredValue。</p> 
<h6><a id="useTransition_58"></a>跟useTransition的区别</h6> 
<p>同：内部实现一样，都是将任务标记为过渡更新任务。<br> 别：</p> 
<ul><li>useTransition是将处理一段逻辑，将任务变为过渡任务，useDeferredValue是将原值通过过渡任务后得到新的值，他是产生一个新的状态。</li><li>其次就是useDeferredValue的更新会更滞后于useTransition，因为内部是使用useEffect来调用startTranstion的。下面原理环节会讲到。</li></ul> 
<h4><a id="_65"></a>原理</h4> 
<h5><a id="startTransition_66"></a>startTransition</h5> 
<p>startTransition的源码实现</p> 
<p><img src="https://images2.imgbox.com/b0/6f/LOYdPVa5_o.png" alt="在这里插入图片描述"><br> 他的本质有点类似于17之前的事件更新，通过开关ReactCurrentBAtchConfig.transition<br> ReactCurrentBAtchConfig.transition默认值是null，再需要更新过渡任务的时候，将其置为{}，这样startTransition里面的函数执行的时候，就会判断ReactCurrentBAtchConfig.transition以此来将其优先级降低。<br> <img src="https://images2.imgbox.com/2a/61/AJNeAVZO_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="useTransition_73"></a>useTransition</h5> 
<p><img src="https://images2.imgbox.com/7b/56/oiCJMLK8_o.png" alt="在这里插入图片描述"><br> mount更新阶段，执行的函数是mountTransition，update阶段执行的函数是updateTransition<br> <img src="https://images2.imgbox.com/4c/aa/A9hQnv2J_o.png" alt="在这里插入图片描述"><br> 如图是mountTransition，本质很简单，就是通过调用mountState产生一个状态，然后通过startTransition绑定默认参数，调用moutnWorkInProgressHook创建hooks对象，跟其他hook链接，最后这个hooks.memoizedState保存的就是startTransition这个函数。</p> 
<h6><a id="startTransitionstartTransition_78"></a>注意这里的startTransition跟上面的startTransition不一样，</h6> 
<p><img src="https://images2.imgbox.com/2e/5e/6sHZiGSj_o.png" alt="在这里插入图片描述"><br> 如上，则是useTransition返回的第二个参数，本质就是先调用setPending(ture)，然后切换transitiion上下文，让setPending(false)的更新也变成了过渡任务，这样setPending(false)和callback的任务优先级相同，他们会同时处理。</p> 
<p>所以useTransition可以看成useState+startTransition<br> <img src="https://images2.imgbox.com/bb/9a/DSWVHk9m_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="useDeferredValue_84"></a>useDeferredValue</h5> 
<p><img src="https://images2.imgbox.com/ce/e1/FkqkdMqv_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/a4/81/FMqnbBAY_o.png" alt="在这里插入图片描述"><br> useDeferredValue本质也是调用了useState+useEffect，通过监听value值的改变，触发useEffect回调函数的更新，再去切换tranition上下文，更新setValue(value)<br> 所以useDeferredValue可以看成：useState+useEffect+startTransition。<br> <img src="https://images2.imgbox.com/c6/ce/88seXWPr_o.png" alt="在这里插入图片描述"></p> 
<h5><a id="reacttransition_93"></a>看看react如何通过判断transition上下文。</h5> 
<pre><code class="prism language-ts"><span class="token keyword">const</span> <span class="token punctuation">[</span>data<span class="token punctuation">,</span> setData<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">startTransition</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token punctuation">{<!-- --></span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> 
<p>一般startTransition里面函数，存在着触发更新的动作，比如useState的第二个参数setState，他们会创建update，更新优先级，开始调度。具体可以看<a href="https://blog.csdn.net/lin_fightin/article/details/125038072?spm=1001.2014.3001.5501">hooks实现逻辑</a><br> 所以重点看看产生update时候的优先级的处理，以setState为例子<br> useState的第二个参数，实际上是调用<code>dispatchSetState</code>函数<br> <img src="https://images2.imgbox.com/65/32/3HXI52Tg_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/21/18/FrfFIPkI_o.png" alt="在这里插入图片描述"><br> requestUpdateLane就是用来获取当前update的优先级的。来看具体实现<br> <img src="https://images2.imgbox.com/f6/ca/1HFMk2kL_o.png" alt="在这里插入图片描述"><br> 第一个判断就是判断是否是同步模式下，也就是18之前的模式，他不支持优先级的概念。</p> 
<p><img src="https://images2.imgbox.com/48/13/SUBfaiNr_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/30/bc/8iIJgEv4_o.png" alt="在这里插入图片描述"><img src="https://images2.imgbox.com/1b/30/rvheunb5_o.png" alt="在这里插入图片描述"></p> 
<p>其次就是判断是否是transition的上下文，判断方式也很简单粗暴，直接判断ReactCurrentBatchConfig.transition是否不等于null，是的话就表示处于transition的更新。<br> 然后返回currentEventTransitionLane，也就是transition的优先级<br> <img src="https://images2.imgbox.com/57/c2/kyQL27oA_o.png" alt="在这里插入图片描述"></p> 
<p><img src="https://images2.imgbox.com/31/73/CJm8qHl7_o.png" alt="在这里插入图片描述"></p> 
<p>这也就解释了通过切换transition上下文，产生的update的优先级并不一样。<br> 然后处理这个update的时候<br> <img src="https://images2.imgbox.com/a4/03/ZrCmEPuk_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/89/bd/FAZpX9p7_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/86/cb/Nk9sGYRK_o.png" alt="在这里插入图片描述"><br> 可以看到，setSe 产生的update的确走了这个逻辑，最后返回的优先级就是64。<br> 然后将update插入hooks的update连表上，更新调用scheduleUpdateOnFiber开始新的一轮调度。<br> 然后最后会执行ensureRootIsScheduled函数，该函数根据当前的优先级，调用schedule模块提供的schedule_callback函数调度任务。如下：<br> <img src="https://images2.imgbox.com/1f/16/qJEWWMiR_o.png" alt="在这里插入图片描述"></p> 
<p>对于64的优先级，被分配到了normalPriority的优先级，<br> <img src="https://images2.imgbox.com/e0/81/1mE2dXrs_o.png" alt="在这里插入图片描述"><br> 然后通过注册任务，开启调度。</p> 
<p>自此，整个transition的流程就已经走通了。</p> 
<p>总结：</p> 
<ul><li> <p>transition过渡，就是将一些不紧要的任务降低其优先级，使其不阻塞高优先级的任务。</p> </li><li> <p>具体实现就是通过切换transition上下文，使产生的udpate获取更低的优先级，这样调度的时候过期时间就会更长，从而不会阻塞高优先级的任务。</p> </li><li> <p>文章通过学习掘金的《react进阶实践指南》作为笔记产出，文中图片部分来自《react进阶实践指南》</p> </li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/92d97536b79c91bfae94122bbc6d899b/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MFC更改窗口/对话框的背景颜色</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/5eb2a5198d2059d3bf7ed0cdcea68bc2/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android小项目集合100多个</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>