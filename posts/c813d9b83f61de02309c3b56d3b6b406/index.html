<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>手把手教你如何玩转消息中间件（ActiveMQ） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="手把手教你如何玩转消息中间件（ActiveMQ）" />
<meta property="og:description" content="情景引入 小白：起床起床起床起床。。。。快起床~
我：怎么了又，大惊小怪，吓到我了。
小白：我有事有事想找你，十万火急呢~~
我：你能有什么事？反正我不信。。那你说说看~~
小白：就是我有两个小表弟，叫大白和二白，他们现在每天睡觉之前都要分别和我聊天，让我给他们讲故事，如果不讲他们就不睡觉。但是，如果一个个的跟他们轮流来说的话，我就需要每天说两遍，而且我还要找准他们的时间点，这个有时候我有事情都无法实现这个问题，他们就会很生气。。。
我：这不是挺好的嘛，小孩子就是爱听故事的呀。。。
小白：我也愿意讲，但是时间这个不是很好控制，有没有类似，比如我可以之前就描述好了，然后定点给他们两个一起发消息，而可以抛开时间和其他因素的影响呢？
我：这个嘛，很简单呀，你可以让他们关注你的一个公众号，这样你再定时的推送给他们故事不就可以了嘛。。或者，你可以拉他们进你的一个群这样，就方便了呀~
小白：这样是可以，但是如果以后还有小表妹要听我讲，我就要如此反复的做。。感谢好麻烦好麻烦。。。
我：emmm，我理解你的意思，你就想实现一种很多人都能够进行类似一种消息推送的方式嘛。。。
小白：对的对的。。就是这样一种，，，我记得我们在技术方面好像也有一种类似的技术，这个叫做什么去了呢？
我：这就是消息中间件，一种生产者和消费者的关系。
小白：我也想学我也想学，，你快给我讲讲，给我讲讲呗。。
我：真拿你没办法，好吧。。。下面我就给你讲一下这方面的知识。
#情景分析
其实，小白的这个问题，是一种比较普遍的问题。既然我们作为技术人员，当然我们就要从技术成分去分析如何解决了。这里面其实就是包含着一种消息中间件的技术。它也是最近技术层面用得非常非常多的，这也是非常值得我们进行学习。。这在如今的秒杀系统，推荐系统等等，都有广泛的应用。。所以，这章我就主要来跟大家说说这方面的知识。
#基本概念的引导
本模块主要讲解关于消息中间件的相关基础知识，也是方便我们后面的学习。 ###什么是中间件？
非操作系统软件，非业务应用软件，不是直接给最终用户使用，不能直接给用户带来价值的软件，我们就可以称为中间件（比如Dubbo，Tomcat，Jetty，Jboss都是属于的）。
什么是消息中间件？ 百度百科解释：消息中间件利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。
关键点：关注于数据的发送和接受，利用高效可靠的异步消息机制传递机制集成分布式系统。
先简单的用下面这个图说明：
为什么要使用消息中间件 举几个例子，我想你就会明白了。（其实使用消息中间件主要就是为了解耦合和异步两个作用）
1：微博，都用过吧。那么，当我们新关注一个用户，那么系统会相应的推送消息给我们，并且还做了很多关于我们关注的处理。这就是消息中间件的异步。
2：秒杀系统。100件商品，几十万个人在抢，那这个怎么弄呢？总不能就把服务器给宕机了吧。那么就可以把用户的请求进行缓存，然后再异步处理。
3：系统A给系统B进行通信，而系统B需要对A的消息进行相应处理之后才能给A反馈，这时候，总不能让A就傻傻等着吧。那么，这就是异步的功能。
###什么是JMS？
Java消息服务（Java Message Service）应用程序接口是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。
总结起来说就是：Java对于应用程序之间进行信息交互的API（而且是异步）。
里面有下面的概念需要理解，对后续有帮助：
提供者：实现JMS的消息服务中间件服务器。客户端：发送或接受消息的应用。生产者/发布者：创建并发送消息的客户端。消费者/订阅者：接受并处理消息的客户端。消息：应用程序之间传递的数据。消息模式：在客户端之间传递消息的模式，JMS主要是队列模式和主体模式。队列模式特点：
（1）客户端包括生产者和消费者。
（2）队列中的一个消息只能被一个消费者使用。
（3）消费者可以随时取消息。主体模式特点：
（1）客户端包括发布者和订阅者。
（2）主题中的消息可以被所有订阅者消费。
（3）消费者不能消费订阅之前发送的消息。 什么是AMQP？ AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。
简单点说：就是对于消息中间件所接受的消息传输层的协议（不懂传输层，那么就需要多看看计算机网络相关知识了，OSI的层次划分），只有这样才能保证客户端和消息中间件能够进行交互（换位思考：HTTP和HTTPS甚至说是TCP/IP与UDP协议都要的道理）。
emmm，比较一下JMS和AMQP的不同吧。。
JMS是定义与Java，而AMQP是一种传输层协议。JMS是属于Java的API，而AMQP是跨语言的。JMS消息类型只有两种（主题和队列，后续会说），而AMQP是有五种。JMS主要就是针对Java的开发的Client，而AMQP是面向消息，队列，路由。 什么是ActiveMQ呢？ ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。
简单点说：不就是为了实现我上述所想要的需求嘛。然后它就是一种实现的方式。就比如，Tomcat是什么？不就是为了实现一种client与服务器之间的交互的一种产品嘛。。所以，不需要死记概念，自己理解就好。
ActiveMQ的安装 环境：Windows 步骤：
（1）登录到ActiveMQ的官网，下载安装包。http://activemq.apache.org/activemq-5154-release.html
（2）下载Zip文件
（3）解压Zip文件，目录如下
（4）启动ActiveMQ服务（注意：要右键以管理员身份进行运行）
注意：有两种方式，第一种就是类似tomcat启动，那么启动图会一直显示。
而第二种的话，就是把这个ActiveMQ注册到服务列表中，这样更方便我们进行操作。（推荐使用这种）
（5）登录，验证是否启动成功" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c813d9b83f61de02309c3b56d3b6b406/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-07-15T18:07:39+08:00" />
<meta property="article:modified_time" content="2018-07-15T18:07:39+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">手把手教你如何玩转消息中间件（ActiveMQ）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h2><a id="_0"></a>情景引入</h2> 
<p>小白：起床起床起床起床。。。。快起床~<br> 我：怎么了又，大惊小怪，吓到我了。<br> 小白：我有事有事想找你，十万火急呢~~<br> 我：你能有什么事？反正我不信。。那你说说看~~<br> 小白：就是我有两个小表弟，叫大白和二白，他们现在每天睡觉之前都要分别和我聊天，让我给他们讲故事，如果不讲他们就不睡觉。但是，如果一个个的跟他们轮流来说的话，我就需要每天说两遍，而且我还要找准他们的时间点，这个有时候我有事情都无法实现这个问题，他们就会很生气。。。<br> 我：这不是挺好的嘛，小孩子就是爱听故事的呀。。。<br> 小白：我也愿意讲，但是时间这个不是很好控制，有没有类似，比如我可以之前就描述好了，然后定点给他们两个一起发消息，而可以抛开时间和其他因素的影响呢？<br> 我：这个嘛，很简单呀，你可以让他们关注你的一个公众号，这样你再定时的推送给他们故事不就可以了嘛。。或者，你可以拉他们进你的一个群这样，就方便了呀~<br> 小白：这样是可以，但是如果以后还有小表妹要听我讲，我就要如此反复的做。。感谢好麻烦好麻烦。。。<br> 我：emmm，我理解你的意思，你就想实现一种很多人都能够进行类似一种消息推送的方式嘛。。。<br> 小白：对的对的。。就是这样一种，，，我记得我们在技术方面好像也有一种类似的技术，这个叫做什么去了呢？<br> 我：这就是消息中间件，一种生产者和消费者的关系。<br> 小白：我也想学我也想学，，你快给我讲讲，给我讲讲呗。。<br> 我：真拿你没办法，好吧。。。下面我就给你讲一下这方面的知识。<br> #情景分析<br> 其实，小白的这个问题，是一种比较普遍的问题。既然我们作为技术人员，当然我们就要从技术成分去分析如何解决了。这里面其实就是包含着一种消息中间件的技术。它也是最近技术层面用得非常非常多的，这也是非常值得我们进行学习。。这在如今的秒杀系统，推荐系统等等，都有广泛的应用。。所以，这章我就主要来跟大家说说这方面的知识。<br> #基本概念的引导<br> 本模块主要讲解关于消息中间件的相关基础知识，也是方便我们后面的学习。 <br> ###什么是中间件？<br> 非操作系统软件，非业务应用软件，不是直接给最终用户使用，不能直接给用户带来价值的软件，我们就可以称为中间件（比如Dubbo，Tomcat，Jetty，Jboss都是属于的）。</p> 
<h4><a id="_21"></a>什么是消息中间件？</h4> 
<p>百度百科解释：消息中间件利用高效可靠的消息传递机制进行平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息排队模型，它可以在分布式环境下扩展进程间的通信。<br> <font color="##dd00000">关键点：关注于数据的发送和接受，利用高效可靠的异步消息机制传递机制集成分布式系统。</font><br> 先简单的用下面这个图说明：<br> <img src="https://images2.imgbox.com/0e/d5/9ScKICPD_o.png" alt="这里写图片描述"></p> 
<h4><a id="_26"></a>为什么要使用消息中间件</h4> 
<p>举几个例子，我想你就会明白了。（其实使用消息中间件主要就是为了解耦合和异步两个作用）<br> 1：微博，都用过吧。那么，当我们新关注一个用户，那么系统会相应的推送消息给我们，并且还做了很多关于我们关注的处理。这就是消息中间件的异步。<br> 2：秒杀系统。100件商品，几十万个人在抢，那这个怎么弄呢？总不能就把服务器给宕机了吧。那么就可以把用户的请求进行缓存，然后再异步处理。<br> 3：系统A给系统B进行通信，而系统B需要对A的消息进行相应处理之后才能给A反馈，这时候，总不能让A就傻傻等着吧。那么，这就是异步的功能。<br> ###什么是JMS？<br> Java消息服务（Java Message Service）应用程序接口是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。<br> 总结起来说就是：Java对于应用程序之间进行信息交互的API（而且是异步）。<br> 里面有下面的概念需要理解，对后续有帮助：</p> 
<ul><li>提供者：实现JMS的消息服务中间件服务器。</li><li>客户端：发送或接受消息的应用。</li><li>生产者/发布者：创建并发送消息的客户端。</li><li>消费者/订阅者：接受并处理消息的客户端。</li><li>消息：应用程序之间传递的数据。</li><li>消息模式：在客户端之间传递消息的模式，JMS主要是队列模式和主体模式。</li><li>队列模式特点：<br> （1）客户端包括生产者和消费者。<br> （2）队列中的一个消息只能被一个消费者使用。<br> （3）消费者可以随时取消息。</li><li>主体模式特点：<br> （1）客户端包括发布者和订阅者。<br> （2）主题中的消息可以被所有订阅者消费。<br> （3）消费者不能消费订阅之前发送的消息。</li></ul> 
<h4><a id="AMQP_50"></a>什么是AMQP？</h4> 
<p>AMQP，即Advanced Message Queuing Protocol,一个提供统一消息服务的应用层标准高级消息队列协议,是应用层协议的一个开放标准,为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同的开发语言等条件的限制。<br> 简单点说：就是对于消息中间件所接受的消息传输层的协议（不懂传输层，那么就需要多看看计算机网络相关知识了，OSI的层次划分），只有这样才能保证客户端和消息中间件能够进行交互（换位思考：HTTP和HTTPS甚至说是TCP/IP与UDP协议都要的道理）。<br> <font color="#dd0000">emmm，比较一下JMS和AMQP的不同吧。。</font></p> 
<ul><li>JMS是定义与Java，而AMQP是一种传输层协议。</li><li>JMS是属于Java的API，而AMQP是跨语言的。</li><li>JMS消息类型只有两种（主题和队列，后续会说），而AMQP是有五种。</li><li>JMS主要就是针对Java的开发的Client，而AMQP是面向消息，队列，路由。</li></ul> 
<h4><a id="ActiveMQ_59"></a>什么是ActiveMQ呢？</h4> 
<p>ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线。ActiveMQ 是一个完全支持JMS1.1和J2EE 1.4规范的 JMS Provider实现，尽管JMS规范出台已经是很久的事情了，但是JMS在当今的J2EE应用中间仍然扮演着特殊的地位。<br> 简单点说：不就是为了实现我上述所想要的需求嘛。然后它就是一种实现的方式。就比如，Tomcat是什么？不就是为了实现一种client与服务器之间的交互的一种产品嘛。。所以，不需要死记概念，自己理解就好。</p> 
<h2><a id="ActiveMQ_62"></a>ActiveMQ的安装</h2> 
<h3><a id="Windows_63"></a>环境：Windows</h3> 
<p>步骤：<br> （1）登录到ActiveMQ的官网，下载安装包。<a href="http://activemq.apache.org/activemq-5154-release.html" rel="nofollow">http://activemq.apache.org/activemq-5154-release.html</a><br> （2）下载Zip文件<br> <img src="https://images2.imgbox.com/04/1c/QHpJaBHS_o.png" alt="这里写图片描述"><br> （3）解压Zip文件，目录如下<br> <img src="https://images2.imgbox.com/5e/62/fE0SjnD4_o.png" alt="这里写图片描述"><br> （4）启动ActiveMQ服务（<font color="#dd0000">注意：要右键以管理员身份进行运行）</font><br> <img src="https://images2.imgbox.com/e9/8a/Ds1zl5es_o.png" alt="这里写图片描述"><br> 注意：有两种方式，第一种就是类似tomcat启动，那么启动图会一直显示。<br> 而第二种的话，就是把这个ActiveMQ注册到服务列表中，这样更方便我们进行操作。（推荐使用这种）<br> （5）登录，验证是否启动成功<br> <img src="https://images2.imgbox.com/d0/64/mAvVoUqb_o.png" alt="这里写图片描述"><br> （6）进入管理页面<br> <img src="https://images2.imgbox.com/98/f8/1EC4G7CD_o.png" alt="这里写图片描述"><br> OK，进入之后就可以看我们的管理页面啦。。。是不是很简单呢？</p> 
<h3><a id="Linux_79"></a>环境：Linux</h3> 
<p>步骤：（多余的我就不多说了。。。请看windows的步骤）<br> （1）同样需要下载对应的文件。后缀为tar.gz的这样的。其实可以直接通过下面的这个命令下载，快速一点，免得要移动到Linux（注意：如果是通过ssh连接的方式的话）。</p> 
<pre><code>wget https://mirrors.tuna.tsinghua.edu.cn/apache//activemq/5.15.4/apache-activemq-5.15.4-bin.tar.gz
</code></pre> 
<p>（2）然后解压下载的文件<br> （3）同样进入相对应的目录，运行</p> 
<pre><code>./activemq start
</code></pre> 
<p>（4）然后再访问相同的地址就可以看到啦。（具体看windows安装步骤）<br> #ActiveMQ的使用（基于Maven）<br> 首先要再回头看看JMS中的一些关键接口。</p> 
<ul><li>ConnectionFactory：用于创建连接到消息中间件的连接工厂。</li><li>Connection：代表了应用程序和服务之间的连接通路。</li><li>Destination：指消息发布的地点，包括队列模式和主体模式。</li><li>Session：表示一个单线程的上下文，用于发送和接受消息。</li><li>MessageConsumer：由会话创建，用于接受发送到目的的消息。</li><li>MessageProducer：由会话创建，用于发送消息。</li><li>Message：是在消费者和生产者之间传递的对象，消息头，一组消息属性，和一个消息体。<br> <img src="https://images2.imgbox.com/c1/3d/ZaQ0DBNV_o.png" alt="这里写图片描述"><br> 环境：IDEA<br> 步骤：</li></ul> 
<ol><li>使用IDEA创建一个Maven项目，最简单的骨架即可（quick）</li><li>导入ActiveMq的依赖</li></ol> 
<pre><code>&lt;!--添加activemq的依赖--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
      &lt;artifactId&gt;activemq-all&lt;/artifactId&gt;
      &lt;version&gt;5.9.0&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre> 
<h4><a id="_117"></a>情形一：队列模型的消息</h4> 
<ol start="3"><li>编写生产者代码（使用队列模型的消息）</li></ol> 
<pre><code>package com.hnu.scw.queue;
import org.apache.activemq.ActiveMQConnectionFactory;
import javax.jms.*;
/**
 * @ Author     ：scw
 * @ Date       ：Created in 上午 11:06 2018/7/14 0014
 * @ Description：用于消息的创建类
 * @ Modified By：
 * @Version: $version$
 */
public class MessageProducer {
    //定义ActivMQ的连接地址
    private static final String ACTIVEMQ_URL = "tcp://127.0.0.1:61616";
    //定义发送消息的队列名称
    private static final String QUEUE_NAME = "MyMessage";

    public static void main(String[] args) throws JMSException {
        //创建连接工厂
        ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL);
       //创建连接
        Connection connection = activeMQConnectionFactory.createConnection();
        //打开连接
        connection.start();
        //创建会话
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        //创建队列目标
        Destination destination = session.createQueue(QUEUE_NAME);
        //创建一个生产者
        javax.jms.MessageProducer producer = session.createProducer(destination);
        //创建模拟100个消息
        for (int i = 1 ; i &lt;= 100 ; i++){
            TextMessage message = session.createTextMessage("我发送message:" + i);
            //发送消息
            producer.send(message);
            //在本地打印消息
            System.out.println("我现在发的消息是：" + message.getText());
        }
        //关闭连接
        connection.close();
    }
}
</code></pre> 
<ol start="4"><li>查看是否消息产生成功<br> <img src="https://images2.imgbox.com/31/68/4FEpyjJc_o.png" alt="这里写图片描述"></li><li>编写消费者代码（消费队列模型的消息）</li></ol> 
<pre><code>package com.hnu.scw.queue;
import org.apache.activemq.ActiveMQConnectionFactory;
import javax.jms.*;
/**
 * @ Author     ：scw
 * @ Date       ：Created in 上午 11:30 2018/7/14 0014
 * @ Description：消息消费者
 * @ Modified By：
 * @Version: $version$
 */
public class MessageConsumer {
    //定义ActivMQ的连接地址
    private static final String ACTIVEMQ_URL = "tcp://127.0.0.1:61616";
    //定义发送消息的队列名称
    private static final String QUEUE_NAME = "MyMessage";
    public static void main(String[] args) throws JMSException {
        //创建连接工厂
        ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL);
        //创建连接
        Connection connection = activeMQConnectionFactory.createConnection();
        //打开连接
        connection.start();
        //创建会话
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        //创建队列目标
        Destination destination = session.createQueue(QUEUE_NAME);
        //创建消费者
        javax.jms.MessageConsumer consumer = session.createConsumer(destination);
        //创建消费的监听
        consumer.setMessageListener(new MessageListener() {
            @Override
            public void onMessage(Message message) {
                TextMessage textMessage = (TextMessage) message;
                try {
                    System.out.println("获取消息：" + textMessage.getText());
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
        });
    }
}
</code></pre> 
<ol start="6"><li> <p>查看是否进行了消费<br> <img src="https://images2.imgbox.com/0e/71/218ZXPhA_o.png" alt="这里写图片描述"><br> **备注：**我上面进行的是<font color="##dd0000"><strong>队列模式的消息</strong></font>，而且进行的都是单个消费者，那如果我换成同时有两个消费者消费生产者的消息会怎么样呢？（我们只需要运行两个消费者就可以啦。当然，要保证生产者是产生了消息的哦~~~~否则，拿什么消费呢~）<br> <font color="##dd0000">一个生产者，两个消费者的情况如下：</font><br> 切记：先运行两个消费者，然后再运行生产者代码：<br> 结果如下：<br> <img src="https://images2.imgbox.com/c5/e6/YNAbNapC_o.png" alt="这里写图片描述"><br> <img src="https://images2.imgbox.com/3c/e0/RbAwDZol_o.png" alt="这里写图片描述"></p> <p>其实，这就是解释了，我之前说的，队列模式的消息，是只会被一个消费者所使用的，而不会被共享，这也就是和主题模型的差别哦~~~<s>哈哈</s></p> </li></ol> 
<h4><a id="_219"></a>情形二：主题模型的消息</h4> 
<p>前面的步骤都一样，只是生产者和消费者的代码有点区别：<br> 3. 编写生产者（这个和队列模型其实很像，稍微修改就可以）</p> 
<pre><code>package com.hnu.scw.topic;

import org.apache.activemq.ActiveMQConnectionFactory;

import javax.jms.*;

/**
 * @ Author     ：scw
 * @ Date       ：Created in 上午 11:48 2018/7/14 0014
 * @ Description：${description}
 * @ Modified By：
 * @Version: $version$
 */
public class MessageTopicProducer {

    //定义ActivMQ的连接地址
    private static final String ACTIVEMQ_URL = "tcp://127.0.0.1:61616";
    //定义发送消息的主题名称
    private static final String TOPIC_NAME = "MyTopicMessage";

    public static void main(String[] args) throws JMSException {
        //创建连接工厂
        ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL);
        //创建连接
        Connection connection = activeMQConnectionFactory.createConnection();
        //打开连接
        connection.start();
        //创建会话
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        //创建队列目标
        Destination destination = session.createTopic(TOPIC_NAME);
        //创建一个生产者
        javax.jms.MessageProducer producer = session.createProducer(destination);
        //创建模拟100个消息
        for (int i = 1; i &lt;= 100; i++) {
            TextMessage message = session.createTextMessage("当前message是(主题模型):" + i);
            //发送消息
            producer.send(message);
            //在本地打印消息
            System.out.println("我现在发的消息是：" + message.getText());
        }
        //关闭连接
        connection.close();
    }
}
</code></pre> 
<ol start="4"><li>查看生产者的消息<br> <img src="https://images2.imgbox.com/07/5f/3IgRD2ur_o.png" alt="这里写图片描述"></li><li>编写消费者</li></ol> 
<pre><code>package com.hnu.scw.topic;

import org.apache.activemq.ActiveMQConnectionFactory;

import javax.jms.*;

/**
 * @ Author     ：scw
 * @ Date       ：Created in 上午 11:50 2018/7/14 0014
 * @ Description：${description}
 * @ Modified By：
 * @Version: $version$
 */
public class MessageTopicConsumer {
    //定义ActivMQ的连接地址
    private static final String ACTIVEMQ_URL = "tcp://127.0.0.1:61616";
    //定义发送消息的队列名称
    private static final String TOPIC_NAME = "MyTopicMessage";
    public static void main(String[] args) throws JMSException {
        //创建连接工厂
        ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL);
        //创建连接
        Connection connection = activeMQConnectionFactory.createConnection();
        //打开连接
        connection.start();
        //创建会话
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        //创建队列目标
        Destination destination = session.createTopic(TOPIC_NAME);
        //创建消费者
        javax.jms.MessageConsumer consumer = session.createConsumer(destination);
        //创建消费的监听
        consumer.setMessageListener(new MessageListener() {
            @Override
            public void onMessage(Message message) {
                TextMessage textMessage = (TextMessage) message;
                try {
                    System.out.println("获取消息：" + textMessage.getText());
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
        });
    }
}

</code></pre> 
<ol start="6"><li>查看是否消费成功<br> 然而，我们运行消费者代码，发现怎么没有消息消费呢？？？？？？？？？<br> <font color="##dd00000">其实，这就是主题模型的一个特点，如果消费者是在生产者产生消息之后来的，那么是不会对之前的消息进行消费的哦。。。现在知道它们的区别在哪了吧。</font><br> <font color="##dd00000">如果，现在是两个消费者和一个生产者的主题模型又是怎么的结果呢？</font><br> <img src="https://images2.imgbox.com/88/8b/QpKrR42D_o.png" alt="这里写图片描述"><br> <img src="https://images2.imgbox.com/13/dc/NGRy0yGC_o.png" alt="这里写图片描述"><br> <font color="##dd00000">哎哟。。。。这种情况消费者都各自消费了所有的生产者的消息耶。。。。。这就是共享性消息的主题模式，这就是和队列模型的区别，，，大家好好的对比哦~~</font></li></ol> 
<h2><a id="ActiveMQSpring_329"></a>ActiveMQ使用（基于Spring）</h2> 
<p>步骤：</p> 
<ol><li>创建一个Maven项目（基于最简单的quick骨架即可）</li><li>导入Spring和ActiveMQ的相关依赖</li></ol> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

  &lt;groupId&gt;com.hnu.scw&lt;/groupId&gt;
  &lt;artifactId&gt;activemq&lt;/artifactId&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

  &lt;name&gt;activemq&lt;/name&gt;
  &lt;!-- FIXME change it to the project's website --&gt;
  &lt;url&gt;http://www.example.com&lt;/url&gt;

  &lt;properties&gt;
    &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;
    &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt;
    &lt;spring.version&gt;4.2.5.RELEASE&lt;/spring.version&gt;
  &lt;/properties&gt;

  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;junit&lt;/groupId&gt;
      &lt;artifactId&gt;junit&lt;/artifactId&gt;
      &lt;version&gt;4.11&lt;/version&gt;
      &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!--添加activemq的依赖--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
      &lt;artifactId&gt;activemq-all&lt;/artifactId&gt;
      &lt;version&gt;5.9.0&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;!--spring整合activemq所需要的依赖--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
      &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-jms&lt;/artifactId&gt;
      &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.springframework&lt;/groupId&gt;
      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
      &lt;version&gt;${spring.version}&lt;/version&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
      &lt;artifactId&gt;activemq-core&lt;/artifactId&gt;
      &lt;version&gt;5.7.0&lt;/version&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;artifactId&gt;spring-context&lt;/artifactId&gt;
          &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;

  &lt;build&gt;
    &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt;
      &lt;plugins&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.0.0&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_jar_packaging --&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.0.2&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.7.0&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.20.1&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
          &lt;version&gt;3.0.2&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.5.2&lt;/version&gt;
        &lt;/plugin&gt;
        &lt;plugin&gt;
          &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt;
          &lt;version&gt;2.8.2&lt;/version&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
  &lt;/build&gt;
&lt;/project&gt;

</code></pre> 
<ol start="3"><li>编写生产者的配置文件.xml，取名为producer.xml</li></ol> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;

&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd "&gt;

    &lt;context:annotation-config /&gt;

    &lt;!--Activemq的连接工厂--&gt;
    &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt;
        &lt;property name="brokerURL" value="tcp://127.0.0.1:61616" /&gt;
    &lt;/bean&gt;
   &lt;!--spring jms为我们提供的连接池 获取一个连接工厂--&gt;
    &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt;
        &lt;property name="targetConnectionFactory" ref="targetConnectionFactory" /&gt;
    &lt;/bean&gt;

    &lt;!-- 消息目的地  点对点的模式--&gt;
    &lt;bean id="queueDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt;
        &lt;constructor-arg value="SpringActiveMQMsg"/&gt;
    &lt;/bean&gt;
    &lt;!-- jms模板  用于进行消息发送--&gt;
    &lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt;
        &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;

</code></pre> 
<ol start="4"><li>编写生产者的接口</li></ol> 
<pre><code>package com.hnu.scw.spring;

/**
 * @ Author     ：scw
 * @ Date       ：Created in 下午 12:19 2018/7/14 0014
 * @ Description：生产者的接口
 * @ Modified By：
 * @Version: $version$
 */
public interface ProduceService {
    void sendMessage(String msg);
}

</code></pre> 
<ol start="5"><li>编写生产者的实现</li></ol> 
<pre><code>package com.hnu.scw.spring;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jms.core.JmsTemplate;
import org.springframework.jms.core.MessageCreator;
import javax.annotation.Resource;
import javax.jms.*;

/**
 * @ Author     ：scw
 * @ Date       ：Created in 下午 2:21 2018/7/15 0015
 * @ Description：生产者的实现类
 * @ Modified By：
 * @Version: $version$
 */

public class ProduceServiceImpl implements ProduceService {
    @Autowired
    private JmsTemplate jmsTemplate;
    @Resource(name = "queueDestination")
    private Destination destination;

    /**
     * 发送消息
     * @param msg
     */
    @Override
    public void sendMessage(final String msg) {
        jmsTemplate.send(destination , new MessageCreator() {
            @Override
            public Message createMessage(Session session) throws JMSException {
                TextMessage textMessage = session.createTextMessage(msg);
                return textMessage;
            }
        });
        System.out.println("现在发送的消息为： " + msg);
    }
}

</code></pre> 
<ol start="6"><li>将生产者的类添加到上述的配置文件中</li></ol> 
<pre><code>&lt;!--注入我们的生产者--&gt;
    &lt;bean class="com.hnu.scw.spring.ProduceServiceImpl"/&gt;
</code></pre> 
<ol start="7"><li>编写生产者的测试类</li></ol> 
<pre><code>package com.hnu.scw.spring;
import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * @ Author     ：scw
 * @ Date       ：Created in 下午 2:27 2018/7/15 0015
 * @ Description：生产者的测试
 * @ Modified By：
 * @Version: $version$
 */
public class ProducerTest {
    public static void main(String[] args){
        ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext("producer.xml");
        ProduceService bean = classPathXmlApplicationContext.getBean(ProduceService.class);
        //进行发送消息
        for (int i = 0; i &lt; 100 ; i++) {
            bean.sendMessage("test" + i);
        }
        //当消息发送完后，关闭容器
        classPathXmlApplicationContext.close();
    }
}

</code></pre> 
<ol start="8"><li>运行测试类，查看生产者是否产生消息成功<br> <img src="https://images2.imgbox.com/3e/8b/Ls3U6EpB_o.png" alt="这里写图片描述"><br> 通过上述的界面，就可以看到自己配置的队列模式的消息产生成功。</li><li>编写消费者的消息监听类</li><li>编写消费者的配置文件，命名为consumer.xml</li></ol> 
<pre><code>&lt;?xml version="1.0" encoding="UTF-8" ?&gt;

&lt;beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd "&gt;

    &lt;context:annotation-config /&gt;

    &lt;!--Activemq的连接工厂--&gt;
    &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt;
        &lt;property name="brokerURL" value="tcp://127.0.0.1:61616" /&gt;
    &lt;/bean&gt;
    &lt;!--spring jms为我们提供的连接池 获取一个连接工厂--&gt;
    &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt;
        &lt;property name="targetConnectionFactory" ref="targetConnectionFactory" /&gt;
    &lt;/bean&gt;

    &lt;!-- 消息目的地  点对点的模式--&gt;
    &lt;bean id="queueDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt;
        &lt;constructor-arg value="SpringActiveMQMsg"/&gt;
    &lt;/bean&gt;

    &lt;!-- 配置消息监听器--&gt;
    &lt;bean id="consumerMessageListener" class="com.hnu.scw.spring.ComsumerMessageListener"/&gt;
    &lt;!--配置消息容器--&gt;
    &lt;bean id ="jmsContainer" class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt;
        &lt;!--配置连接工厂--&gt;
        &lt;property name="connectionFactory" ref="connectionFactory"/&gt;
        &lt;!--配置监听的队列--&gt;
        &lt;property name="destination" ref="queueDestination"/&gt;
        &lt;!--配置消息监听器--&gt;
        &lt;property name="messageListener" ref="consumerMessageListener"/&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre> 
<ol start="11"><li>消息消费者ComsumerMessageListener类代码</li></ol> 
<pre><code>package com.hnu.scw.spring;

import javax.jms.JMSException;
import javax.jms.Message;
import javax.jms.MessageListener;
import javax.jms.TextMessage;

/**
 * @ Author     ：scw
 * @ Date       ：Created in 下午 3:06 2018/7/15 0015
 * @ Description：消息的监听者，用于处理消息
 * @ Modified By：
 * @Version: $version$
 */
public class ComsumerMessageListener implements MessageListener {
    @Override
    public void onMessage(Message message) {
        TextMessage textMessage = (TextMessage) message;
        try {
            System.out.println("接受到消息：" + textMessage.getText());
        } catch (JMSException e) {
            e.printStackTrace();
        }
    }
}

</code></pre> 
<ol start="12"><li>编写测试文件，测试消费者消费消息是否成功</li></ol> 
<pre><code>package com.hnu.scw.spring;

import org.springframework.context.support.ClassPathXmlApplicationContext;

/**
 * @ Author     ：scw
 * @ Date       ：Created in 下午 3:13 2018/7/15 0015
 * @ Description：消费者的测试
 * @ Modified By：
 * @Version: $version$
 */
public class ConsumerTest {
    public static void main(String[] args){
        //启动消费者
        ClassPathXmlApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext("consumer.xml");
    }
}

</code></pre> 
<ol start="12"><li>查看ActiveMQ网站具体消息情况<br> <img src="https://images2.imgbox.com/e7/89/IzmwJLCL_o.png" alt="这里写图片描述"><br> <img src="https://images2.imgbox.com/df/14/GwLwooXw_o.png" alt="这里写图片描述"></li><li>ActiveMQ的队列模型就大功告成啦。。。。。。so easy！！！<br> <font color="##dd00000">备注：上面都是进行的ActiveMQ的队列模型的配置，那么我们如果想进行主题模型的又是如何进行操作呢？其实也很简单，只需要修改生产者的xml文件里面的队列即可。比如如下代码：</font></li></ol> 
<pre><code>&lt;!-- 消息目的地  (主题模式)--&gt;
    &lt;!--&lt;bean id="queueDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt;
        &amp;lt;!&amp;ndash;配置队列模型的消息名称&amp;ndash;&amp;gt;
        &lt;constructor-arg value="SpringActiveMQMsgTopic"/&gt;
    &lt;/bean&gt;--&gt;
</code></pre> 
<p>将上面的代码替换之前的就可以了。。。<br> 总结：总的来说，基于Spring来使用消息队列还是非常方便的，这比我们正常进行JMS规范操作要简单很多，毕竟很多对象都是通过Spring的IOC进行容器管理了，所以，值得推荐使用哦~~~</p> 
<h2><a id="ActiveMQ_684"></a>ActiveMQ的集群</h2> 
<h4><a id="_685"></a>为什么要进行集群呢？</h4> 
<p>原因一：实现高可用：以排除单点故障所引起的服务终端。<br> 原因二：实现负载均衡：以提升效率为更多的客户进行服务。<br> ###集群的方式有哪些？<br> 方式一：客户端集群：多个客户端消费同一个队列。<br> 方式二：Broker clusters：多个Broker之间同步消息。(实现负载均衡)<br> <img src="https://images2.imgbox.com/cf/6b/y2ldjYOu_o.png" alt="这里写图片描述"><br> 这个的实现原理主要是通过网络连接器来进行。<br> 网络连接器：用于配置ActiveMQ服务器与服务器之间的网络通讯方式，用于服务器透析消息。主要分为静态连接和动态连接。<br> 方式三：Master Slave ：实现高可用。<br> 这种方式的话，可以联想到Mysql的主从配置和Zookeeper的负载均衡的主竞争关系master。<br> <font color="#dd00000">我们在实际的开发中，一般都是将方式二和方式三进行集成，从而实现高可用和负载均衡。下面的话，我也就这样的配置思想来进行讲解：（通过三台服务器来模拟消息集群的实现）</font><br> <img src="https://images2.imgbox.com/9e/df/F72v7dQR_o.png" alt="这里写图片描述"><br> 其中的NodeB和NodeC就是一张Master/slave的关系。都可以成为主服务器。（只要它们某一个宕机，那么就会其余的一台就进行继续服务）</p> 
<h4><a id="WindowsLinux_699"></a>搭建步骤(基于Windows环境，而Linux环境也是一样的操作)</h4> 
<p>三台服务器的大体功能和描述：<br> <img src="https://images2.imgbox.com/f4/17/bcnjhq4l_o.png" alt="这里写图片描述"><br> 由于自己没有三台服务器，所以就用自己的一台电脑来模拟三台消息服务器，其实这个就是假设有三个不同ActiveMQ消息服务器了。</p> 
<ol><li>复制三个ActiveMQ的服务配置到一个公共目录<br> <img src="https://images2.imgbox.com/10/95/bhQUXhbn_o.png" alt="这里写图片描述"></li><li>修改activeMQA的配置文件<br> <img src="https://images2.imgbox.com/ab/19/XaCj63rk_o.png" alt="这里写图片描述"><br> 只需要在activemq.xml添加如下内容：</li></ol> 
<pre><code>&lt;networkConnectors&gt;
		&lt;networkConnector name="local_network" uri ="static:(tcp://127.0.0.1:61617,tcp://127.0.0.1:61618)" /&gt;
	&lt;/networkConnectors&gt;
</code></pre> 
<ol start="3"><li>修改ActiveMQB的配置文件<br> （1）首先在activemq,xml中添加如下内容：</li></ol> 
<pre><code>&lt;!--修改服务端口--&gt;
&lt;transportConnector name="openwire" uri="tcp://0.0.0.0:61617?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600"/&gt;
&lt;networkConnectors&gt;
	   &lt;networkConnector name="networktoA" uri="static:(tcp://127.0.0.1:61616)" /&gt;
	&lt;/networkConnectors&gt;
&lt;!--并修改下面这个标签的内容 ， 作为B和C的共享文件，目录就是自己之前创建的一个文件（可以回看上面的整个结构）--&gt;
&lt;persistenceAdapter&gt;
            &lt;kahaDB directory="D:\Download\MQJiQun\shareDB"/&gt;
        &lt;/persistenceAdapter&gt;
</code></pre> 
<p>（2）修改jetty.xml内容，修改服务器的服务端口</p> 
<pre><code>&lt;bean id="jettyPort" class="org.apache.activemq.web.WebConsolePort" init-method="start"&gt;
             &lt;!-- the default port number for the web console --&gt;
        &lt;property name="host" value="0.0.0.0"/&gt;
        &lt;property name="port" value="8162"/&gt;
    &lt;/bean&gt;
</code></pre> 
<ol start="4"><li>修改ActiveMQC的配置文件（其实类似和B一样，只是服务端口不一样）<br> （1）修改activemq.xml中的内容</li></ol> 
<pre><code>&lt;!--修改服务端口--&gt;
&lt;transportConnector name="openwire" uri="tcp://0.0.0.0:61618?maximumConnections=1000&amp;amp;wireFormat.maxFrameSize=104857600"/&gt;
&lt;networkConnectors&gt;
	   &lt;networkConnector name="networktoA" uri="static:(tcp://127.0.0.1:61616)" /&gt;
	&lt;/networkConnectors&gt;
&lt;!--并修改下面这个标签的内容 ， 作为B和C的共享文件，目录就是自己之前创建的一个文件（可以回看上面的整个结构）--&gt;
&lt;persistenceAdapter&gt;
            &lt;kahaDB directory="D:\Download\MQJiQun\shareDB"/&gt;
        &lt;/persistenceAdapter&gt;
</code></pre> 
<p>（2）修改jetty.xml中的内容</p> 
<pre><code>&lt;bean id="jettyPort" class="org.apache.activemq.web.WebConsolePort" init-method="start"&gt;
             &lt;!-- the default port number for the web console --&gt;
        &lt;property name="host" value="0.0.0.0"/&gt;
        &lt;property name="port" value="8163"/&gt;
    &lt;/bean&gt;
</code></pre> 
<ol start="5"><li>集群搭建完成~~~~</li></ol> 
<h4><a id="IDEAMaven_764"></a>集群测试（基于IDEA编辑器+Maven）</h4> 
<p>步骤：<br> （1）创建Maven项目<br> （2）导入依赖</p> 
<pre><code>&lt;!--添加activemq的依赖--&gt;
    &lt;dependency&gt;
      &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt;
      &lt;artifactId&gt;activemq-all&lt;/artifactId&gt;
      &lt;version&gt;5.9.0&lt;/version&gt;
    &lt;/dependency&gt;
</code></pre> 
<p>（3）编写生产者代码</p> 
<pre><code>package com.hnu.scw.queue;
import org.apache.activemq.ActiveMQConnectionFactory;
import javax.jms.*;
/**
 * @ Author     ：scw
 * @ Date       ：Created in 上午 11:06 2018/7/14 0014
 * @ Description：用于消息的创建类
 * @ Modified By：
 * @Version: $version$
 */
public class MessageProducer {
    //通过集群的方式进行消息服务器的管理（failover就是进行动态转移，当某个服务器宕机，
    // 那么就进行其他的服务器选择,randomize表示随机选择）
    private static final String ACTIVEMQ_URL = "failover:(tcp://127.0.0.1:61617,tcp://127.0.0.1:61618)?randomize=true";
    //定义发送消息的队列名称
    private static final String QUEUE_NAME = "MyMessage";

    public static void main(String[] args) throws JMSException {
        //创建连接工厂
        ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL);
       //创建连接
        Connection connection = activeMQConnectionFactory.createConnection();
        //打开连接
        connection.start();
        //创建会话
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        //创建队列目标
        Destination destination = session.createQueue(QUEUE_NAME);
        //创建一个生产者
        javax.jms.MessageProducer producer = session.createProducer(destination);
        //创建模拟100个消息
        for (int i = 1 ; i &lt;= 100 ; i++){
            TextMessage message = session.createTextMessage("当前message是:" + i);
            //发送消息
            producer.send(message);
            //在本地打印消息
            System.out.println("我现在发的消息是：" + message.getText());
        }
        //关闭连接
        connection.close();
    }

}

</code></pre> 
<p>（4）编写消费者代码</p> 
<pre><code>package com.hnu.scw.queue;

import org.apache.activemq.ActiveMQConnectionFactory;

import javax.jms.*;

/**
 * @ Author     ：scw
 * @ Date       ：Created in 上午 11:30 2018/7/14 0014
 * @ Description：消息消费者
 * @ Modified By：
 * @Version: $version$
 */
public class MessageConsumer {
    //通过集群的方式进行消息服务器的管理（failover就是进行动态转移，当某个服务器宕机，
    // 那么就进行其他的服务器选择,randomize表示随机选择）
    private static final String ACTIVEMQ_URL = "failover:(tcp://127.0.0.1:61616,tcp://127.0.0.1:61617,tcp://127.0.0.1:61618)?randomize=true";
    //定义发送消息的队列名称
    private static final String QUEUE_NAME = "MyMessage";

    public static void main(String[] args) throws JMSException {
        //创建连接工厂
        ActiveMQConnectionFactory activeMQConnectionFactory = new ActiveMQConnectionFactory(ACTIVEMQ_URL);
        //创建连接
        Connection connection = activeMQConnectionFactory.createConnection();
        //打开连接
        connection.start();
        //创建会话
        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);
        //创建队列目标
        Destination destination = session.createQueue(QUEUE_NAME);
        //创建消费者
        javax.jms.MessageConsumer consumer = session.createConsumer(destination);
        //创建消费的监听
        consumer.setMessageListener(new MessageListener() {
            @Override
            public void onMessage(Message message) {
                TextMessage textMessage = (TextMessage) message;
                try {
                    System.out.println("获取消息：" + textMessage.getText());
                } catch (JMSException e) {
                    e.printStackTrace();
                }
            }
        });
    }

}

</code></pre> 
<p>（5）进行查看各自的服务器的消息队列的情况。</p> 
<ol><li><font color="##dd0000">首先，是要确保三个ActiveMQ服务器都进行打开。分析：当三个都服务都运行之后，我们从浏览器运行各自的地址，会发现：<br> 比如：我这里的三个服务的地址分别如下：</font></li></ol> 
<ul><li>http://127.0.0.1:8161/</li><li>http://127.0.0.1:8162/</li><li>http://127.0.0.1:8163/</li></ul> 
<h4><a id="_888"></a>重点</h4> 
<p>为什么前面两个都可以访问，而第三个不可以呢？（同样也是按照我的这样的服务器打开方式哦。先打开的服务器A，接着B，最后C）但是，运行的时候，提示都成功了呀。。为什么为什么？？？<br> <font color="##dd0000"><strong>分析：</strong></font>其实很简单，我说过B和C是一种master/slave的方式，当B运行之后就获得了master的权限，那么C服务是可以看到是一种监听的状态，只有当B宕机之后，才有可能获取master的资源权限，所以，这时候C的地址当然就无法访问啦。这就是负载均衡的一种主/从服务的结构。当然，你可以试着先打开C，再打开B，这时候效果就反过来了。欢迎尝试哦~~~<br> <br> 2. 再运行MessageProducer的类，用于产生消息。这时候，大家可以去查看每个服务器的地址，来观察消息的产生情况。我的如下：<br> <img src="https://images2.imgbox.com/f1/90/RkUCEvSP_o.png" alt="这里写图片描述"><br> 我的消息是产生在服务器B的里面啦。。。。。。<br> 3. 再运行MessageConsumer的类，用于消费消息。这时候，同样可以去查看每个服务器的地址中的消息队列的情况，来观察消息的消费情况。我的如下：<br> <img src="https://images2.imgbox.com/f8/31/tG1Qtot5_o.png" alt="这里写图片描述"><br> 4. 如果，我们在生产者产生了消息之后，服务器B突然宕机了怎么办怎么办？？<br> 分析：其实，这时候服务器C就一样有消息保存进行同步了。。是不是这样就是一种高可用的架构了呢？？？？大家，可以试试哦。。把B服务器关掉，再去访问服务器C的地址，就发现如下的结果。<br> <img src="https://images2.imgbox.com/1e/bf/daePZQwS_o.png" alt="这里写图片描述"><br> 这时候服务器C就作为了master，所以，类似zookeeper就是这样的一种方式的哦。~<br> ###总结<br> 好了，对于集群方面的简单使用就到这里了。其实已经可以根据这个进行扩展了，所以，小伙伴要好好理解这里面的过程和作用，这样才能够学以致用。。。</p> 
<h2><a id="_904"></a>其他的消息中间件</h2> 
<p>其实，类似ActiveMQ这样的消息中间件，用得比较多的还有就是RabbitMQ和Kafka。它们三者各自有各自的优势。大家可以百度进行了解，我就不进行多说了。后面我会同样把这两种消息中间件的使用进行详细的讲解，欢迎大家的关注哦~<s>总的来说，只有适合的场景对应的消息中间件才能发挥最大的作用，没有一种是只有好处而没有坏处的</s>~<br> #总结</p> 
<ul><li>主要是对消息中间件的基础知识进行讲解。</li><li>主要讲解ActiveMQ的使用</li><li>主要讲解了关于ActiveMQ的集群的搭建</li><li>稍微提到了类似ActiveMQ消息中间件的其他中间件</li><li>我所讲述的内容，够大家进行入门了，如果要进行深入的了解还是需要慢慢的去熟悉和学习的，而且消息中间件是非常重要的一个技术，希望大家去好好的了解。</li><li>最后，感谢各位的阅读哦~~~~</li></ul>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/a1e3553f60c442f28aedcc493f564e52/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">使用有道云笔记的三个技巧</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/946218c2ba875d84380dde1f4a6514a7/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">MySQL表不能修改、删除等操作，卡死、锁死情况的处理办法。</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>