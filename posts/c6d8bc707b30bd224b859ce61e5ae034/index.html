<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>《格蠹汇编》读书笔记—windbg的使用（中） - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="《格蠹汇编》读书笔记—windbg的使用（中）" />
<meta property="og:description" content="笔记本唤醒失败的原因探究（16章） 1)如何产生dmp文件 方法在前一章说过《格蠹汇编》读书笔记—windbg的使用_u012138730的专栏-CSDN博客_windbg怎么用
当唤醒失败了以后，按ctrll&#43;scrolllock 强制蓝屏（需要注册表的设置） 然后就有dmp文件可以分析了。
2)一些常规的命令 分析dmp文件的时候的一些常规操作，之前也介绍过。
设置调试符号路径 .symfix c:\symbols
自动分析 !analyze -v
3)进一步分析dmp文件 当自动分析没有什么价值的时候，尝试用两种方法
第一种：!pcr 了解CPU的当前状态 !pcr是查看处理器控制区，从而了解cpu的当前的状态
!cpuinfo————怎么看当前有几个cpu。
!pcr 0 和 !pcr 1————看0号cpu和1号cpu的具体的状态，看看有什么猫腻。
上图中1 号cpu的当前线程和空闲线程不一样 ，看看是啥。（如果当前线程就是空闲线程那没什么好看的。）
所以查看查看的当前线程
!thread 8688e568——— 通过这个命令可以查看寄存器的上下文等等。。然后程序指针寄存器ip指向用户态空间，说明1号正在用户态执行。因为系统挂死通常是在内核态，所以先不往这个方向探究。
第二种：!locks 查看锁 这个命令查看存在的内核对象锁
显示了系统所持有的资源对象。上图显示了3个。
对于每一个对象，都显示了这个对象的持有线程，等待线程，持有方式。
以上图显示有一个线程特别可疑，以上三个对象都是被87474da8这个线程拥有，且第一个和第三个资源都是独占方式持有
!thread 87474da8——发现这个线程属于 WinLogon 进程 并且 整个线程正在处于等待状态 疑点1：执行过 serenum 和ser2pl 这两个驱动程序的函数 (怎么知道是驱动程序的函数呢)
疑点2：ser2pl这个没有符号文件，所以没有显示出来函数名字，但是看到是这个函数导致的线程进行了等待状态，调用了一个wait函数 。 后面要研究一下 ser2pl是个什么东西
继续研究这个线程，关注跟驱动相关的信息。
执行 .thread /p 87474da8 ——设置为当前线程 (跟 !thread 87474da8 有什么不同吗 栈回溯 更加底层了 显示的内容更多了 )
执行 kvn 查看栈回溯 然后看图" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c6d8bc707b30bd224b859ce61e5ae034/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-09-09T13:02:20+08:00" />
<meta property="article:modified_time" content="2021-09-09T13:02:20+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">《格蠹汇编》读书笔记—windbg的使用（中）</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <hr> 
<h2>笔记本唤醒失败的原因探究（16章）</h2> 
<h3>1)如何产生dmp文件</h3> 
<p>方法在前一章说过<a href="https://blog.csdn.net/u012138730/article/details/90547384" title="《格蠹汇编》读书笔记—windbg的使用_u012138730的专栏-CSDN博客_windbg怎么用">《格蠹汇编》读书笔记—windbg的使用_u012138730的专栏-CSDN博客_windbg怎么用</a></p> 
<p>当唤醒失败了以后，<strong>按ctrll+scrolllock </strong>强制蓝屏（需要注册表的设置） 然后就有dmp文件可以分析了。</p> 
<h3><br> 2)一些常规的命令</h3> 
<p>分析dmp文件的时候的一些常规操作，之前也介绍过。</p> 
<ul><li><strong>设置调试符号路径</strong></li></ul> 
<blockquote> 
 <p>.symfix c:\symbols</p> 
</blockquote> 
<ul><li><strong>自动分析</strong></li></ul> 
<blockquote> 
 <p>!analyze -v</p> 
</blockquote> 
<p></p> 
<h3>3)进一步分析dmp文件</h3> 
<p>当<strong>自动分析</strong>没有什么价值的时候，尝试用<strong>两种方法</strong></p> 
<ul><li> <h4>第一种：!pcr 了解CPU的当前状态</h4> </li></ul> 
<p>!pcr是查看<strong>处理器控制区</strong>，从而了解cpu的当前的状态</p> 
<blockquote> 
 <p>!cpuinfo————怎么看当前有几个cpu。</p> 
 <p>!pcr 0 和 !pcr 1————看0号cpu和1号cpu的具体的状态，看看有什么猫腻。</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/9e/b8/QNn1cKcq_o.png"></p> 
<p></p> 
<p>上图中<strong>1 号cpu的当前线程和空闲线程</strong>不一样 ，看看是啥。（如果当前线程就是空闲线程那没什么好看的。）</p> 
<p>所以查看查看的当前线程</p> 
<blockquote> 
 <p>!thread <strong>8688e568</strong>——— 通过这个命令可以查看<strong>寄存器的上下文等等</strong>。。然后<strong>程序指针寄存器ip</strong>指向用户态空间，说明1号正在用户态执行。因为系统挂死通常是在内核态，所以先不往这个方向探究。</p> 
</blockquote> 
<ul><li> <h4><strong>第二种：!locks 查看锁</strong></h4> </li></ul> 
<p>这个命令查看存在的<strong>内核对象锁</strong></p> 
<p style="text-align:center;"><img alt="" height="440" src="https://images2.imgbox.com/3f/7a/82HTn1oU_o.png" width="693"></p> 
<p></p> 
<p>显示了系统所持有的资源对象。上图显示了3个。</p> 
<p>对于每一个对象，都显示了这个对象的持有线程，等待线程，持有方式。</p> 
<p></p> 
<p>以上图显示<strong>有一个线程特别可疑</strong>，以上三个对象都是被<strong>87474da8</strong>这个线程拥有，且<strong>第一个和第三个</strong>资源都是独占方式持有</p> 
<blockquote> 
 <p>!thread <strong>87474da8——</strong>发现这个线程属于 WinLogon 进程 并且 整个线程正在处于等待状态 </p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/18/7f/4MtULrbA_o.png"></p> 
<blockquote> 
 <p>疑点1：执行过 <strong>serenum </strong>和<strong>ser2pl </strong>这两个驱动程序的函数 (怎么知道是驱动程序的函数呢)</p> 
 <p>疑点2：<strong>ser2pl</strong>这个没有符号文件，所以没有显示出来函数名字，但是看到是这个函数导致的线程进行了等待状态，调用了一个wait函数 。 后面要研究一下<strong> ser2pl</strong>是个什么东西</p> 
</blockquote> 
<p>继续研究这个线程，关注跟驱动相关的信息。</p> 
<blockquote> 
 <p>执行 <strong>.thread /p 87474da8</strong> ——设置为当前线程 (跟 <strong>!thread 87474da8</strong> 有什么不同吗 栈回溯 更加底层了 显示的内容更多了 )</p> 
 <p>执行<strong> kvn </strong>查看栈回溯 然后看图</p> 
</blockquote> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/87/72/IDKj7git_o.png"></p> 
<blockquote> 
 <p> 线索1：可以看到 执行<strong>ser2pl </strong>之前的一些操作系统执行<strong>睡眠和唤醒任务的关键线程</strong> (标注出</p> 
 <p>知识点：系统的唤醒阶段：</p> 
 <p>1）通知执行体，唤醒设备</p> 
 <p>2）通知windows子系统，点亮显示器<br> 从栈回溯中看到，在第一个阶段就停止了，所以没到点亮显示器的状态。那在唤醒设备的过程中执行到了 <strong>ser2pl 。</strong></p> 
</blockquote> 
<p><strong>看</strong>ser2pl的信息</p> 
<p>之前说过是<strong>ser2pl</strong>导致了线程进入了等待状态，所以看看ser2pl是个什么东西</p> 
<blockquote> 
 <p><strong>!drvobj ser2pl</strong>———查看 ser2pl驱动信息</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/e2/84/7YnIDH3u_o.png"></p> 
<p><img alt="" src="https://images2.imgbox.com/63/ad/gvLgFw0z_o.png">（85163500）</p> 
<p></p> 
<blockquote> 
 <p><strong>驱动对象的</strong>地址（地址A）。</p> 
 <p><strong>驱动对象</strong>的<strong>设备实例</strong>的<strong>设备对象</strong>的地址（地址B） 85163500，</p> 
 <p>(<strong>地址B</strong>的类型是<strong> Device_objec</strong>t ，可以用dt _<strong>Device_object</strong> 85163500: 看结构详情)</p> 
 <p>（而且还发现这个<strong>地址B</strong>在栈回溯中参数列出现了很多次。【图16.5 比如11号栈帧】）</p> 
</blockquote> 
<p>对<strong>设备对象地址 85163500</strong>的分析</p> 
<blockquote> 
 <p><strong>!devstack 85163500</strong>——查看设备栈中该设备对象的位置（左边的小箭头指着呢）</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/dc/d5/drmSOSzS_o.png"></p> 
<p></p> 
<blockquote> 
 <p>其中每一行 ：</p> 
 <p>1) 设备对象的地址 2) 驱动名字 3)设备扩展结构的地址   <br> 最后还会给出 设备对象地址 所对应的设备节点的信息 。</p> 
 <p></p> 
 <p>对于上面图中的设备栈，</p> 
 <p>具体：<br>                 设备栈的最底部 <strong>USB集线器HUB驱动</strong><br>                 上面一层<strong>ACPI脚本的请求</strong><br>                 上面一层<strong>ser2pl这个功能驱动</strong><br>                 最上面一层<strong>serenm驱动：</strong>串行口枚举 是与串行口设备有关的一个驱动程序<br> 汇总： 设备实例 &amp; ServiceName is “<strong>Ser2pl”</strong></p> 
</blockquote> 
<p>查找    <strong>ser2pl（</strong>ServiceName is “<strong>Ser2pl”） </strong>位于<strong>设备树</strong>的哪里 ：</p> 
<blockquote> 
 <p>!devnode 0 1----显示出包含系统中所有设备的设备树。然后可以看到<strong>ser2pl（</strong>ServiceName is “<strong>Ser2pl”） </strong>是位于什么之下。</p> 
 <p>即查找<strong>ser2pl</strong>这个设备的<strong>接入方式。</strong></p> 
</blockquote> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/8d/3a/Wfh5mQsB_o.png"></p> 
<blockquote> 
 <p> 结论：插在<strong>usbhub下的某个端口</strong>（<strong>而usbhub位</strong>于负责管理低速设备的usb控制器<strong>usbuhci</strong>之下）<br> 所以作者就推断出 <strong>ser2pl </strong>是<strong> usb 转 串行口 设备的</strong>驱动程序<br> (作者确实用了<strong>一个usb转串行口</strong>的<strong>转接头，那笔记本是串行口 还是 usb口呢</strong>)<br>  </p> 
</blockquote> 
<h3>4)从栈回溯的熟悉的函数的入手</h3> 
<ul><li>找栈回溯的规律</li></ul> 
<p>【从上面的图16.5】 <strong>ser2pl </strong>和 <strong>serenum </strong> 函数来回跳转<br> #3#4 <strong>ser2pl </strong>驱动的函数<br> #8#9 <strong>serenum </strong>驱动的函数<br> #e <strong>ser2pl </strong>驱动的函数<br> #12#13 <strong>serenum </strong>驱动的函数</p> 
<p></p> 
<ul><li>熟悉的函数1—— <strong>PoCallDriver </strong>函数原型</li></ul> 
<p style="text-align:center;">（以#11栈帧为例子）<br><strong>第一个参数:</strong>——<strong>设备对象</strong> 间接指定了要<strong>调用的驱动 </strong>（也就是说<strong>设备对象和设备的驱动</strong>是一一对应的？对驱动其实不是很熟悉</p> 
<p></p> 
<blockquote> 
 <p><strong>!devobj</strong> <strong>第一个参数值（设备对象</strong>地址<strong>）</strong>————可以发现这个是个 <strong>ser2pl驱动</strong></p> 
</blockquote> 
<p><strong>第二个参数</strong>——<strong>IO请求包</strong> IRP</p> 
<blockquote> 
 <p><strong>!IRP 第二个参数</strong>—— <strong>请求的什么 IRP 包呢。但是这个命令出错了。因为这个参数被改写了。（原因是</strong>这个函数执行过程中，把参数所在的位置的值给重写了，有的函数就会这么做）</p> 
</blockquote> 
<p>【16.5图的两个irp地址 <strong>8761f600（2号irp） </strong>和 <strong>85879c60（1号irp） </strong>】</p> 
<p></p> 
<ul><li>熟悉的函数2——<strong>PopPresentIrp</strong>函数原型</li></ul> 
<p>找到PopPresentIrp函数的<strong>第二个参数</strong>，然后调用<strong>&gt;!IRP 8761f600 和 &gt;!IRP 8761f60</strong></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/37/b6/aBSNfPBj_o.png"></p> 
<p><img alt="" height="461" src="https://images2.imgbox.com/63/3b/JIm3hxlz_o.png" width="678"></p> 
<p> 显示出来的是 对应于 设备栈的 <strong>IRP栈位 [A，B]</strong>里面的值的含义（到<strong>wdm.h</strong>中可以查到 16 和 2 是什么意思）</p> 
<p>也就是说对每一个设备的一个IP请求包，<strong>IO请求包</strong>先<strong>传给栈顶</strong>，然后<strong>一级一级往下传。</strong><br> 都是[16,2]，跟电源状态有关系，那他们有区别吗 ？有的，下面说。</p> 
<ul><li>对于<strong>IRP</strong>的介绍</li></ul> 
<p> IRP 的 结构 就是具有一个串 <strong>IO_STACK_LOCATION </strong>子结构，其中有一个子结构的内容就是获得<strong>当前驱动使用的子结构。通过下面这个命令获取</strong></p> 
<blockquote> 
 <p>通过 <strong>!IRP 8761f60 1（比前面多一个1）</strong></p> 
 <p><strong>多了</strong>更加详细的内容 其中的 <strong>currentstackloaction</strong></p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/ac/0d/X3AuL664_o.png"></p> 
<p>（85879d60）</p> 
<p>ps：驱动程序中 经常通过 irpstack = IoGetCurrentIrpStackLoaction(Irp)来获得 当前驱动使用的iostack位置</p> 
<blockquote> 
 <p>通过这个结构的地址 <strong>85879d60 来</strong>查看他的内容（也就是结构是<strong>IO_STACK_LOCATION </strong>），其中有个Parameters参数，分析出 这个 IRP 是<strong>用来设置电源状态的（2号IRP）</strong>。</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/d4/16/szinMWG2_o.png"></p> 
<p>也就是说要根据当前驱动的子结构的具体含义。</p> 
<p>用同样的方法可以分析出，另外一个IRP是用来<strong>通知系统的电源状态发生了变化（1号IRP）</strong><br>                 <br> 【栈回溯图的参数 #11 #10 第一第二个参数】</p> 
<p>所以分析出来，这是一个是设置电源，一个是通知电源。</p> 
<p></p> 
<p>至此，我们分析出，</p> 
<blockquote> 
 <p>1. 系统被要求唤醒  系统函数 <strong>PopwakeDeviceLst </strong>向 <strong>Usb转串口设备</strong>发送唤醒通知。</p> 
 <p>==》 向这个设备栈的最上端设备对象<strong>8610d2b0(serenum)</strong>发送<strong>2号IRP</strong></p> 
 <p><br> 2.<strong>serenum驱动</strong>将<strong>2号IRP</strong>向下传递给<strong>ser2pl驱动</strong></p> 
 <p></p> 
 <p>3.<strong>ser2pl驱动</strong> 作为负责设备<strong>电源状态的 FDO</strong> 发现新的电源状态<strong>D0</strong> 和 自己的当前状态 <strong>D3 </strong>不一样， 于是调用 <strong>PoRequestPowerIrp</strong> 发起设备电源变化 <strong>1号IRP</strong>，企图改变设备的电源状态<br>  </p> 
</blockquote> 
<p>那执行到第三步的时候 为什么回停滞不前了呢</p> 
<p>所以要查看<strong>#3号栈帧</strong>为什么会调用到<strong>#2号栈帧</strong>的<strong>wait函数</strong>呢<br> 看一份跟<strong>ser2pl</strong>驱动源代码很相似的代码<strong> DDK中的 Power.c</strong>的 <strong>serialsetPowerDO函数</strong><br>  </p> 
<p><img alt="" src="https://images2.imgbox.com/76/37/tSsqz9Rf_o.png"></p> 
<p> <br> （ps：很有一个很不常规的操作把 返回值返回一个 设置到第二个参数的位置上了，</p> 
<p><strong>#3号栈帧第二个参数</strong> ，<strong>EBP+C是第二个参数的位置（记住））</strong> </p> 
<p></p> 
<p><strong>发现就是PoCallDriver 返回值为103那个状态。</strong>导致了调用<strong>Wait</strong>函数。</p> 
<p>要有人来设置<strong>PowerD0Event</strong>这个事件才能让这个函数<strong>继续进行，否则将继续等待。</strong>不太理解为啥会出现这个问题。</p> 
<p>    </p> 
<hr> 
<h2>解救陷入死循环的MSN（17章）</h2> 
<h3>1）电脑风扇突然提速的原因</h3> 
<p>电脑的风扇突然提速并且保持高速运行一定是系统内温度升高，触发<strong>散热系统</strong>开始工作，系统持续<strong>高负荷</strong>运行而导致的，一般有如下情况：</p> 
<ul><li>需要处理大量重复事物的软件开始工作，比如病毒扫描程序和索引服务等</li><li>某些程序运行故障，进入死循环</li></ul> 
<p></p> 
<h3>2）查看cpu占用率</h3> 
<p>解决提速的问题一般首先使用 看任务管理器（<strong>ctrl+shift+delete</strong>）</p> 
<p><strong>看 cpu占用率</strong></p> 
<p>（<strong>占用率</strong>指的是在多任务系统中<strong>cpu在某个进程上的运行时间</strong>与<strong>cpu运行总时间</strong>的比率）</p> 
<p>和 <strong>cpu时间</strong></p> 
<p>（<strong>时间</strong>指的是<strong>在每个进程上所停留的累积时间</strong>）</p> 
<p><br> 看看我自己的电脑：</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f5/80/9yKK3taX_o.png"></p> 
<p>第一个<strong>系统空闲进程，</strong>空闲进程占用率最高说明这个<strong>系统健康</strong>，说明大部分时间都在空闲进程状态待着，cpu游刃有余。（空闲进程之前也多次提到过。）</p> 
<p>还有一个<strong>cpu使用率，</strong>是整个电脑的，就是100%减去空闲进程的。</p> 
<p><br> 一台电脑如果双核cpu，如果<strong>某个进程占用50% </strong>说明这个进程就对于一个核的cpu占用可能就是靠近100%了，乃就是陷入了死循环无疑了。</p> 
<p></p> 
<p>因为文中出现的是 <strong>msn进程</strong>卡住了<br> 启动windbg，<strong>挂到msn</strong>，cpu利用率马上下来了，按<strong>g</strong>继续执行，就又飙上去了<br> 说明就是这个进程的问题了</p> 
<p></p> 
<h3>3）查看进程的哪个线程卡住了（一直在占用cpu）</h3> 
<p>要查看msn<strong>这个进程</strong>发生死循环的位置，首先推断哪个线程：<br> 首先就要看具体是<strong>哪个线程</strong>作妖，有以下几点经验，之前也会有提到过：<br> 1）如果是gui程序，而且<strong>界面不刷新无响应，首先就要看ui线程</strong>，而<strong>ui线程一般都是0号线程</strong><br> 2）如果线程不多，使用<strong>~*kv</strong> 看每个线程的<strong>栈回溯</strong>来判断<br> 3）可以使用命令<strong> &gt;~*e .ttime</strong> 看每个线程的<strong>运行时间长度</strong>，推断可疑线程<br> 4）上工具<strong> process explorer</strong> 看每个线程的cpu占用率（双击<strong>进程</strong>，选择<strong>线程页</strong>属性页），推断可疑线程</p> 
<p><br> 文中符合1），所以先看ui线程，先切换到 ~0s 切换 然后看栈回溯 kn 100</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/1c/31/VPao3Gyu_o.png"><br><span style="color:#fe2c24;">注意<strong>第二行的那句warning 比</strong>如1#栈帧，并不是说他执行到过SetZoneLevel函数，只是以这个函数为参照物来表示其位置关系。</span><br> 虽然最后面的栈帧符号显示不全，但是万幸，#0号栈帧有符号信息，是准确的</p> 
<p>即<strong>msvcr80!_vsnwprintf_s </strong>就是 vs2005的运行时模块的用来格式化字符串的<strong>vsnprintf的安全版本</strong><br> 下一个断点在<strong> bp msvcr80!_vsnwprintf_s </strong>断在这里 <strong>g </strong>继续执行 又断 说明这个就是<strong>在死循环当中</strong>呢，但是并不能说明这里是源头，只能说明是这个线程这个函数在被反复执行(有可能是这个函数执行的时间比较长，所以挂到windbg以及中断的时候停在这里的概率比较大)</p> 
<p style="text-align:center;"><br> 沿着<strong>打印函数</strong>继续追查，看看打印的是什么，首先看这个函数的原型，其中第一个参数是内存缓冲区(<strong>记住第一个参数是ebp+8</strong>，其中ebp是0006fb04，从下图可以看到缓冲区的地址是<strong>0x01939ff5</strong>)，用来存放<strong>格式化的结果</strong> </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/c5/9f/gbZAVVr5_o.png"></p> 
<p>肯定是要执行完，缓冲区才会有结果，所以断在那个函数<strong>msvcr80!_vsnwprintf_s </strong>以后，按 <strong>gu </strong>让其执行完，然后<strong>dU</strong>看缓冲区的内容</p> 
<p><img alt="" src="https://images2.imgbox.com/0f/12/9YvXKQv5_o.png"><br> 猜测是打印调试信息 </p> 
<p>看看是不是每次都在打印调试信息呢？</p> 
<blockquote> 
 <p><strong>执行 &gt;bp msvcr80!_vsnwprintf_s+0x19</strong> "dU poi(@ebp+8);kv 3;gc"<br> 含义 <br> 运行_vsnwprintf_s+0x19到这里 执行""中的命令 <br> dU poi(@ebp+8):打印缓冲区的内容<br> kv 3:打印3帧栈回溯<br> gc:自动恢复执行</p> 
</blockquote> 
<p>然后就是继续执行了，看看能打印出什么东西 <br> 标红的是栈回溯，每次执行路径都是一样的，至少我们推断了这个 _vsnwprintf_s 这个函数不是死循环的始作俑者，因为他会返回到上一层，他只是一个螺丝钉。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/d3/c3/nTLwXkfZ_o.png"></p> 
<p></p> 
<p></p> 
<h3>4）死循环的源头函数在哪里</h3> 
<p>那么怎么推断<strong>死循环发生的头</strong>呢</p> 
<p>依然是把断点下在<strong>msvcr80!_vsnwprintf_s+0x19</strong>，然后看更多的栈回溯，<br> 1）选取<strong>两次栈回溯</strong>，从<strong>下到上看最后一个相同的地址</strong> 这里<strong> CreateObjectStoreService+0x14969</strong><br> 2）把断点指令bp 下在这里(<strong>CreateObjectStoreService+0x14969</strong>)，再把断点下在下一个相同的 <strong> CreateObjectStoreService+0x14c24</strong></p> 
<p><strong><img alt="" src="https://images2.imgbox.com/26/67/ofb09dLk_o.png"></strong></p> 
<p> 发现在 <strong>CreateObjectStoreService+0x14969</strong> 每次都会命中，也就是每次都会走到这里。<br> 但是<strong>  CreateObjectStoreService+0x14c24</strong> 不会</p> 
<p>说明死循环就发生在 <strong>CreateObjectStoreService+0x14969</strong> <strong>所在的函数中 <span style="color:#fe2c24;">（注意前面说过，</span></strong><span style="color:#fe2c24;">栈回溯中说明了 函数名是不准确的 只是一个位置关系，并不是说这个函数就是<strong>CreateObjectStoreService</strong>）</span></p> 
<p><br> 那么就从这个<strong>当前函数的返回地址</strong>开始逆向反汇编</p> 
<p><strong>当前函数的返回地址返回地址也</strong>就是 <strong>CreateObjectStoreService+0x14c24</strong></p> 
<p>得到<strong>调用这个函数的 call </strong> <img alt="" src="https://images2.imgbox.com/cd/1e/PwOSK2Rb_o.png"></p> 
<p>也就是进入到<strong>5f342ff1</strong>这个函数去执行，执行完了返回到<strong>5f343368（5f343368就是CreateObjectStoreService+0x14c24）</strong></p> 
<p>好好理解这句话，结合图。</p> 
<p>所以我们找到了死循环函数的入口地址就是 <strong>5f342ff1</strong></p> 
<p>就是一直都在<strong>5f342ff1这个函数里面在执行呢，一直都没有返回。</strong></p> 
<p></p> 
<p><strong>而这个CreateObjectStoreService+0x14969正是5f342ff1这个函数里面的某一个位置的一个函数调用。</strong></p> 
<p></p> 
<h3>5）.大概看看源头函数的细节</h3> 
<p>（（最后发现这个函数是一个遍历链表的函数，可这个链表头尾相连接了，导致函数无休无止的遍历下去了））</p> 
<p>执行uf 正向反汇编</p> 
<blockquote> 
 <p><strong>uf 5f342ff1 </strong></p> 
</blockquote> 
<p><strong>显示结果的图略，总之</strong>这个反汇编 一共100多条指令 也就是20 30 行源代码 。因为目的不是破译函数，而是看基本框架，猜测存在的问题，从下面几方面入手</p> 
<p>初步看：</p> 
<p>1） 没有使用FPO（看到过是啥 忘了 以后记起来再补充）<br> 2） 可以看到call 指令特别多</p> 
<p></p> 
<p>具体来看：<br> 1） 看<strong>局部变量</strong><br><strong>sub esp,2Ch</strong><br> 说明局部变量区长度0x2C 看到有 ebp-4 、ebp-14 、epb-2C</p> 
<p>猜测第一个可能是4字节的整数或者指针 后面 16字节 24字节 可能是结构体</p> 
<p></p> 
<p>2） 看<strong>函数使用的参数</strong> ebp+<br> 有 <strong>ebp+8 </strong>第一个参数。看开头有一个 ecx 赋值给 edi 。ecx 其实就是用来传递this 指针 猜测这个是C++类的方法</p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/0e/40/yfGfQoJP_o.png"></strong></p> 
<p> 图中大概意思：<strong>先保存edi，再把ecx赋值给edi，再把edi压入栈，作为参数调用另外一个函数，类函数吧</strong></p> 
<p style="text-align:center;"></p> 
<p style="text-align:center;"></p> 
<h3>6）.单步跟踪源头函数，找到可疑点，或者说死循环发生的地方</h3> 
<p>单步跟踪<strong>5f342ff1</strong>这个函数的执行过程 看看在那里发生的死循环，几次以后发现就在下面三个函数中： 【<strong>执行call 比较值</strong> 然后决定是<strong>向下执行（继续往下执行）</strong> 还<strong>是 向上跳 （ebp-4 不等于 0 不相等）</strong>】</p> 
<p><img alt="" src="https://images2.imgbox.com/04/95/3AXxFDCW_o.png"><br> （中间那行）但是这里奇怪的是 并没有<strong>比较函数 （5f361555） 返回值，</strong>比较的是局部变量上的值 <strong>ebp-4</strong> 难道是这里有问题？其实也有可能是下面的函数 操作了这个局部变量 也是有可能的。所以进行验证</p> 
<p>所以我们验证一下，设置一个数据断点（我记得我在哪里记录过 怎么设置数据断点）<br> 先找到<strong>ebp = 0006fc78</strong> 然后减掉4 <br><strong>&gt; ba w4 0006fc74 </strong><br> 设置好上面断点，使用 <strong>&gt;bd</strong> 暂时 禁止其他断点。</p> 
<p>然后<strong>继续执行  看看有没有命中断点</strong>，果然命中了，还是修改了这个值的 ，停留在划红线的哪个地方，就是<strong>那里的上面一行</strong>改动了<strong>ebp-4</strong>吧，所以就是<strong>ecx</strong>那里了。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f9/d3/ZH3BtXbs_o.png"></p> 
<p>作者大神把图 17.11 的翻译了一下 变成源代码，意思是遍历一个链表 使其指向下一个 然后重复执行。</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/f6/26/SfDEWTiz_o.png"></p> 
<p></p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/e8/fa/yhjgFe1p_o.png"></p> 
<p></p> 
<p></p> 
<p>这就是 <strong>5f361555</strong>这个函数大概就是遍历一个链表的节点，做一些事情，然后过程会改变<strong>ebp-4</strong>的值，然后外层会判断这个是不是到达终点了<strong>（我们说的ebp-4是不是等于0了</strong>），如果没有达到说明有下一个节点，继续做事情。</p> 
<p></p> 
<h3>7）.使用windbg的循环命令看死循环过程 </h3> 
<blockquote> 
 <p><br> &gt;<strong>recx=poi(ecx);r ecx ; z(ecx!=0)</strong><br> 把ecx值所对应的地址的值 复制给 ECX<br> 然后先试一下ECX的值<br> 反复操作<br> 知道ECX为0<br> z(n) 是循环的条件 </p> 
 <p>其实就是ecx存的是一个地址，地址中存的的是一个值，这个值又是一个地址，最后看看那个地址里面存的值是0，就不循环了。</p> 
</blockquote> 
<p>使用这个循环命令 手动遍历链表 (<strong>大概就是ecx是下一个链表节点的指针</strong>?,所以就是直接打这条命令然后他就会打印出来如下的一直在打印了。<br><strong>redo 后面的是记录循环的次数</strong></p> 
<p style="text-align:center;"><strong><img alt="" src="https://images2.imgbox.com/d6/ea/5KhM3stC_o.png"></strong></p> 
<p>然后搜索某一个出现过的地址 发现出现了好几次了 每次出现都是<strong>间隔86 说明链表节点86个</strong>，然后又循环回去了</p> 
<h3>8）.那么如何跳出循环</h3> 
<p>从上面的手动循环链表可以发现是是链表首尾相连接了呀，一直都循环不完。所以图17.10中，第二行不可能等于0的，所以就一直往上执行了，一直循环了。</p> 
<p>如何跳出循环方法：<br> 1.修正链表数据 比较难<br> 2.修改程序指针寄存器 —————— 使用be命令恢复本章前面设置的断点 <strong>CreateObjectStoreService+0x14969</strong>  ，然后单步执行到 jne那里 【图中画红线 】然后修改寄存器的值<strong> &gt;R eip=5f3430c4</strong> 让跳到下面执行 。因为就是在同一个函数中的执行的 不涉及栈平衡问题<br> （<strong>p指令单步执行指令</strong>）</p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/26/8a/Nzw8O3M8_o.png"></p> 
<p></p> 
<hr> 
<h2>寻找系统中的耗电大王（18章）</h2> 
<h3>前情提要：</h3> 
<p><br> 硬件<strong>耗电</strong>排名: cpu 显示屏 独立显卡 硬盘</p> 
<p>cpu在<strong>硬件方面</strong>做了很多优化，<strong>耗电</strong>往往<strong>是软件上</strong>出现了类似于死循环的事件 </p> 
<p>作者又出现了风扇疯狂转的现象，同样调出<strong>任务管理器</strong>，找<strong>到cpu占用率最高和占用时间最高的</strong>，发现是o<strong>ne-note</strong></p> 
<p>使用windbg挂上这个进程，风扇停下来了，继续执行，又开始了，说明就是这个进程。</p> 
<p></p> 
<p></p> 
<h3>确定线程：</h3> 
<p><br>     因为onenote界面还是可以操作的，所以大概率不是UI线程的问题，<br>     使用命令</p> 
<blockquote> 
 <p>&gt;~*e?@$tid;.ttime<br>     分号是命令分隔符 查看每个线程的运行时间以及打印tid线程号<br>     找到了可疑线程，运行时间惊人。</p> 
</blockquote> 
<p><img alt="" src="https://images2.imgbox.com/87/e7/popVMR0b_o.png"></p> 
<p></p> 
<p></p> 
<h3>确定模块:</h3> 
<p>切换到可疑线程<strong> </strong></p> 
<blockquote> 
 <p><strong>~~[18e4]s</strong><br> 查看栈回溯</p> 
</blockquote> 
<p style="text-align:center;"><img alt="" height="189" src="https://images2.imgbox.com/37/94/b5xwsxlX_o.png" width="530"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p>通过这个图可以发现，线程的启动函数是 <strong>msxml3 </strong>模块中的 <strong>MimeDownloadThread</strong></p> 
<p>(<strong>MIME</strong> 是多用途互联网邮件扩展，著名的互联网协议之一，推断本线程的目标是通过MIME协议下载信息)</p> 
<p>然后单步跟踪这个线程发现：</p> 
<blockquote> 
 <p>p 单步执行命令</p> 
</blockquote> 
<p>发现这个线程大部分都是在 <strong>msxml3 </strong>这个模块中运行 而且<strong>调用CRT</strong>或者<strong>系统函数</strong>都能顺利返回 说明不是陷入了内核<br><br> 看看这个模块 lm vm msxml3 使用版本3.0 补丁版本sp11 （ 我的电脑上也有） </p> 
<p style="text-align:center;"><img alt="" src="https://images2.imgbox.com/b1/7e/KWkv05ND_o.png"></p> 
<p></p> 
<h2></h2> 
<h2></h2> 
<h2></h2> 
<h2></h2> 
<h2></h2> 
<h2></h2> 
<h3>确定循环范围，确定死循环原因</h3> 
<p><br> 同样了，确定了线程和模块以后，就需要深入到代码逻辑了，但为什么会出现死循环，一般需要确定:<br> 1）从哪里开始执行，即最上层是在哪个函数中执行的 <br> 2）过程中调用了什么函数导致的一直在死循环，哪里跳不出来<br> 3）接受了什么外部数据</p> 
<p></p> 
<p>是否好查上面这些信息，取决于现有条件属于哪一种：<br> 1）有源代码<br> 2）没有源代码 有调试符号<br> 3）没有调试符号 只有汇编</p> 
<p></p> 
<p>如何确定死循环的循环范围：<br> 1）对于函数调用层次少，又有调试符号协助的，可以直接跟踪，本例使用。<br>     跟踪发现是 MimeDwnParserAction【图18.6】 函数 遇到了 0x8000000a 的错误 <br>     其实是尝试把一个url送给浏览器下载，得到一个tcp错误， 这个0x8000000a很有可能是oneonte无法下载导致的错误。<br> 2）对于调用层次多，可以用上一章中的比较两次中栈回溯的方法找到原始函数 然后继续分析。</p> 
<h3><br> 延伸：如果你遇到了无法下载应该怎么办</h3> 
<p><br> 最好是加一个最大重试次数 不要无限的尝试去下载</p> 
<p></p> 
<hr> 
<p>.symfix c:\symbols ———— 设置调试符号路径<br> !analyze -v ————自动分析<br> !cpuinfo————怎么看当前有几个cpu<br> !pcr 0 和 !pcr 1————看0号cpu和1号cpu的具体的状态<br> !thread 8688e568 ———— 切换到 8688e568 这个地址<br> .thread /p 8688e568 ———— 设置 8688e568 为当前线程<br> !locks ———— 查看内核对象锁<br> !drvobj ser2pl ———— 查看 ser2pl这个驱动信息，会显示出来设备对象的地址 85163500<br> !devstack 85163500 ———— 查看设备对象的设备栈 <br> !devobj 85163500 ———— 查看设备对象的信息<br> !devnode 0 1 ———— 显示出包含系统中所有设备的设备树。<br> !IRP 8761f60(IO请求包IRP地址) ———— 显示设备栈的 IRP栈位，看有什么栈位 <br> !IRP 8761f60 1（比前面多一个1） ———— 可以就是获得当前驱动使用的子结构 </p> 
<p>~0s ———— 切换到0号线程，进程内的序号<br> ~~[18e4]s ———— 切换到18e4号线程，系统编号</p> 
<p>dd 地址 长度 ———— 看地址内容<br> dU 地址 长度 ———— 看地址内容<br> gu ———— 执行完这个函数<br> ub 地址 ———— 反汇编这个地址 之前的汇编指令<br> uf 地址 ———— 正向反汇编 从这个地址开始后面的<br> ba w4 0006fc74  ———— 设置一个数据断点<br> bd  ———— 暂时 禁止其他断点。<br> be ———— 恢复 暂时 禁止其他断点。<br> recx=poi(ecx);r ecx ; z(ecx!=0) ———— 把ecx值所对应的地址的值 复制给 ECX，然后先试一下ECX的值，反复操作，知道ECX为0。<br>  ———— 其实就是ecx存的是一个地址，地址中存的的是一个值，这个值又是一个地址，最后看看那个地址里面存的值是0，就不循环了<br> r ecx ———— 看寄存器的值<br> R eip=5f3430c4 ———— 设置寄存器的值<br> p ———— 指令单步执行指令<br> bp msvcr80!_vsnwprintf_s+0x19 "dU poi(@ebp+8);kv 3;gc" ————— 运行_vsnwprintf_s+0x19到这里 执行""中的命令 dU poi(@ebp+8):打印缓冲区的内容kv 3:打印3帧栈回溯gc:自动恢复执行</p> 
<p>~*e?@$tid;.ttime ———— 查看每个线程的运行时间以及打印tid线程号</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/123326568179f5311c1be9165ec8a270/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Windows聚焦图片不更新解决方法</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/c90fcdfa8b2a3158091f22a1ef01760b/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">go语言——slice切片</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>