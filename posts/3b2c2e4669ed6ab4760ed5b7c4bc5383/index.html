<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Redis7分布式缓存之高阶 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Redis7分布式缓存之高阶" />
<meta property="og:description" content="Redis7分布式缓存之高阶 一. Redis单线程 VS 多线程(入门篇)1.Redis为什么选择单线程？① 是什么② ``厘清一个事实我们通常说Redis是单线程究竟何意?``③ Redis3.x单线程时代但性能依旧很快的主要原因④`Redis 4.0`之前一直采用单线程的主要原因有以下三个 2. `既然单线程这么好，为什么逐渐又加入了多线程特性?`① 单线程也有单线程的苦恼② 如何解决案例 3. redis6/7的多线程特性和IO多路复用`入门篇`① 对于Redis`主要的性能瓶颈是内存或者网络带宽而并非 CPU。`② 最后Redis的瓶颈可以初步定为: 网络IOⅠ `redis6/7，真正多线程登场`Ⅱ `主线程和IO线程是怎么协作完成请求处理的-精讲版` 4. Jnix网终编程中的五种IO模型① `lO multiplexing - lO多路复用`Ⅰ FileDescriptorⅡ 首次浅谈I0多路复用l0多路复用是什么Ⅲ `场景体验，说人话引出epoll`场景解析IO多路复用模型，简单明了版理解 Ⅳ 小总结Ⅴ redis为什么这么快 5. 简单说明：`Redis工作线程是单线程的；但是，整个Redis来说，是多线程的`① 主线程和IO线程是怎么协作完成请求处理的-精简版② 结论 6. Redis7默认是否开启了多线程? 二. Bigkey1. Morekey案例① 大批量往redis里面插入2000W测试数据key② 某快递巨头真实生产案例新闻keys* 你试试100W花费多少秒遍历查询`生产上限制keys */flushdb/flushall等危险命令以防止误删误用？` ③ `不用keys *避免卡顿，那该用什么`Scan 命令用于迭代数据库中的数据库键 2. BigKey案例① 多大算big参考《阿里云Redis开发规范》string和二级结构 ② 有那些危害③ 如何产生④ 如何发现redis-cli --bigkeysMEMORY USAGE 键 ⑤ 如何删除Ⅰ StringⅡ hashⅢ listⅣ setⅤ zset 3. Bigkey生产调优 三、缓存双写一致性之更新策略探讨1." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/3b2c2e4669ed6ab4760ed5b7c4bc5383/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-17T13:29:16+08:00" />
<meta property="article:modified_time" content="2023-07-17T13:29:16+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Redis7分布式缓存之高阶</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>Redis7分布式缓存之高阶</h4> 
 <ul><li><a href="#__Redis_VS__1" rel="nofollow">一. Redis单线程 VS 多线程(入门篇)</a></li><li><ul><li><a href="#1Redis_2" rel="nofollow">1.Redis为什么选择单线程？</a></li><li><ul><li><a href="#__3" rel="nofollow">① 是什么</a></li><li><a href="#_Redis_5" rel="nofollow">② ``厘清一个事实我们通常说Redis是单线程究竟何意?``</a></li><li><a href="#_Redis3x_7" rel="nofollow">③ Redis3.x单线程时代但性能依旧很快的主要原因</a></li><li><a href="#Redis_40_9" rel="nofollow">④`Redis 4.0`之前一直采用单线程的主要原因有以下三个</a></li></ul> 
   </li><li><a href="#2__11" rel="nofollow">2. `既然单线程这么好，为什么逐渐又加入了多线程特性?`</a></li><li><ul><li><a href="#__12" rel="nofollow">① 单线程也有单线程的苦恼</a></li><li><a href="#__14" rel="nofollow">② 如何解决</a></li><li><ul><li><a href="#_16" rel="nofollow">案例</a></li></ul> 
   </li></ul> 
   </li><li><a href="#3_redis67IO_18" rel="nofollow">3. redis6/7的多线程特性和IO多路复用`入门篇`</a></li><li><ul><li><a href="#_Redis_CPU_21" rel="nofollow">① 对于Redis`主要的性能瓶颈是内存或者网络带宽而并非 CPU。`</a></li><li><a href="#_Redis_IO_22" rel="nofollow">② 最后Redis的瓶颈可以初步定为: 网络IO</a></li><li><ul><li><a href="#_redis67_23" rel="nofollow">Ⅰ `redis6/7，真正多线程登场`</a></li><li><a href="#_IO_25" rel="nofollow">Ⅱ `主线程和IO线程是怎么协作完成请求处理的-精讲版`</a></li></ul> 
   </li></ul> 
   </li><li><a href="#4_JnixIO_27" rel="nofollow">4. Jnix网终编程中的五种IO模型</a></li><li><ul><li><a href="#_lO_multiplexing__lO_29" rel="nofollow">① `lO multiplexing - lO多路复用`</a></li><li><ul><li><a href="#_FileDescriptor_31" rel="nofollow">Ⅰ FileDescriptor</a></li><li><a href="#_I0l0_33" rel="nofollow">Ⅱ 首次浅谈I0多路复用l0多路复用是什么</a></li><li><a href="#_epoll_35" rel="nofollow">Ⅲ `场景体验，说人话引出epoll`</a></li><li><ul><li><a href="#_37" rel="nofollow">场景解析</a></li><li><a href="#IO_39" rel="nofollow">IO多路复用模型，简单明了版理解</a></li></ul> 
     </li><li><a href="#__41" rel="nofollow">Ⅳ 小总结</a></li><li><a href="#_redis_44" rel="nofollow">Ⅴ redis为什么这么快</a></li></ul> 
   </li></ul> 
   </li><li><a href="#5_RedisRedis_46" rel="nofollow">5. 简单说明：`Redis工作线程是单线程的；但是，整个Redis来说，是多线程的`</a></li><li><ul><li><a href="#_IO_48" rel="nofollow">① 主线程和IO线程是怎么协作完成请求处理的-精简版</a></li><li><a href="#__50" rel="nofollow">② 结论</a></li></ul> 
   </li><li><a href="#6_Redis7_52" rel="nofollow">6. Redis7默认是否开启了多线程?</a></li></ul> 
  </li><li><a href="#_Bigkey_58" rel="nofollow">二. Bigkey</a></li><li><ul><li><a href="#1_Morekey_60" rel="nofollow">1. Morekey案例</a></li><li><ul><li><a href="#_redis2000Wkey_61" rel="nofollow">① 大批量往redis里面插入2000W测试数据key</a></li><li><a href="#__67" rel="nofollow">② 某快递巨头真实生产案例新闻</a></li><li><ul><li><a href="#keys_100W_69" rel="nofollow">keys* 你试试100W花费多少秒遍历查询</a></li><li><a href="#keys_flushdbflushall_71" rel="nofollow">`生产上限制keys */flushdb/flushall等危险命令以防止误删误用？`</a></li></ul> 
    </li><li><a href="#_keys__73" rel="nofollow">③ `不用keys *避免卡顿，那该用什么`</a></li><li><ul><li><a href="#Scan__74" rel="nofollow">Scan 命令用于迭代数据库中的数据库键</a></li></ul> 
   </li></ul> 
   </li><li><a href="#2_BigKey_79" rel="nofollow">2. BigKey案例</a></li><li><ul><li><a href="#_big_80" rel="nofollow">① 多大算big</a></li><li><ul><li><a href="#Redis_81" rel="nofollow">参考《阿里云Redis开发规范》</a></li><li><a href="#string_83" rel="nofollow">string和二级结构</a></li></ul> 
    </li><li><a href="#__86" rel="nofollow">② 有那些危害</a></li><li><a href="#__88" rel="nofollow">③ 如何产生</a></li><li><a href="#__90" rel="nofollow">④ 如何发现</a></li><li><ul><li><a href="#rediscli_bigkeys_92" rel="nofollow">redis-cli --bigkeys</a></li><li><a href="#MEMORY_USAGE__98" rel="nofollow">MEMORY USAGE 键</a></li></ul> 
    </li><li><a href="#__101" rel="nofollow">⑤ 如何删除</a></li><li><ul><li><a href="#_String_105" rel="nofollow">Ⅰ String</a></li><li><a href="#_hash_107" rel="nofollow">Ⅱ hash</a></li><li><a href="#_list_110" rel="nofollow">Ⅲ list</a></li><li><a href="#_set_114" rel="nofollow">Ⅳ set</a></li><li><a href="#_zset_119" rel="nofollow">Ⅴ zset</a></li></ul> 
   </li></ul> 
   </li><li><a href="#3_Bigkey_124" rel="nofollow">3. Bigkey生产调优</a></li></ul> 
  </li><li><a href="#_129" rel="nofollow">三、缓存双写一致性之更新策略探讨</a></li><li><ul><li><a href="#1__131" rel="nofollow">1. `缓存双写一致性，谈谈你的理解`</a></li><li><ul><li><a href="#_133" rel="nofollow">读写缓存</a></li><li><a href="#_135" rel="nofollow">`采用双检加锁策略`</a></li></ul> 
   </li><li><a href="#2__217" rel="nofollow">2. 数据库和缓存一致性的几种更新策略</a></li><li><ul><li><a href="#_221" rel="nofollow">先更新数据库，再更新缓存</a></li><li><a href="#_224" rel="nofollow">先更新缓存，再更新数据库</a></li><li><a href="#_227" rel="nofollow">先删除缓存，再更新数据库</a></li><li><ul><li><a href="#_234" rel="nofollow">解决方法</a></li></ul> 
    </li><li><a href="#__241" rel="nofollow">`更新策略之 先更新数据库，再删除缓存`</a></li></ul> 
   </li><li><a href="#3_246" rel="nofollow">3.小总结</a></li></ul> 
  </li><li><a href="#_RedisMySQL_251" rel="nofollow">四. Redis与MySQL数据双写一致性工程落地案例</a></li><li><ul><li><a href="#1__253" rel="nofollow">1. 复习+面试题</a></li><li><a href="#2_canal_256" rel="nofollow">2. canal</a></li><li><ul><li><a href="#__260" rel="nofollow">① 是什么</a></li></ul> 
   </li><li><a href="#3___262" rel="nofollow">3. 工作原理</a></li><li><a href="#4_mysqlcanalredisCoding_266" rel="nofollow">4. `mysql-canal-redis双写一致性Coding`</a></li></ul> 
  </li><li><a href="#_bitmaphyperloglogGEO_270" rel="nofollow">五. 案例落地实战bitmap/hyperloglog/GEO</a></li><li><ul><li><a href="#1_271" rel="nofollow">1.</a></li></ul> 
 </li></ul> 
</div> 
<p></p> 
<h2><a id="__Redis_VS__1"></a>一. Redis单线程 VS 多线程(入门篇)</h2> 
<h3><a id="1Redis_2"></a>1.Redis为什么选择单线程？</h3> 
<h4><a id="__3"></a>① 是什么</h4> 
<p><img src="https://images2.imgbox.com/41/bb/KzD4pjgF_o.png" alt=""></p> 
<h4><a id="_Redis_5"></a>② <code>厘清一个事实我们通常说Redis是单线程究竟何意?</code></h4> 
<p><img src="https://images2.imgbox.com/f8/05/pcwBAFpt_o.png" alt=""></p> 
<h4><a id="_Redis3x_7"></a>③ Redis3.x单线程时代但性能依旧很快的主要原因</h4> 
<p><img src="https://images2.imgbox.com/bd/06/ujZY6UBr_o.png" alt=""></p> 
<h4><a id="Redis_40_9"></a>④<code>Redis 4.0</code>之前一直采用单线程的主要原因有以下三个</h4> 
<p><img src="https://images2.imgbox.com/c3/e3/isxzlTfa_o.png" alt=""></p> 
<h3><a id="2__11"></a>2. <code>既然单线程这么好，为什么逐渐又加入了多线程特性?</code></h3> 
<h4><a id="__12"></a>① 单线程也有单线程的苦恼</h4> 
<p><img src="https://images2.imgbox.com/c7/da/j7M2lVJ4_o.png" alt=""></p> 
<h4><a id="__14"></a>② 如何解决</h4> 
<p><img src="https://images2.imgbox.com/8b/d8/HrFmy0e0_o.png" alt=""></p> 
<h5><a id="_16"></a>案例</h5> 
<p><img src="https://images2.imgbox.com/12/c3/HKPWM9rm_o.png" alt=""></p> 
<h3><a id="3_redis67IO_18"></a>3. redis6/7的多线程特性和IO多路复用<code>入门篇</code></h3> 
<p><img src="https://images2.imgbox.com/09/bb/jnJOlaj9_o.png" alt=""></p> 
<h4><a id="_Redis_CPU_21"></a>① 对于Redis<code>主要的性能瓶颈是内存或者网络带宽而并非 CPU。</code></h4> 
<h4><a id="_Redis_IO_22"></a>② 最后Redis的瓶颈可以初步定为: 网络IO</h4> 
<h5><a id="_redis67_23"></a>Ⅰ <code>redis6/7，真正多线程登场</code></h5> 
<p><img src="https://images2.imgbox.com/9f/20/p1TBBHSq_o.png" alt=""></p> 
<h5><a id="_IO_25"></a>Ⅱ <code>主线程和IO线程是怎么协作完成请求处理的-精讲版</code></h5> 
<p><img src="https://images2.imgbox.com/56/76/bbsIwWcl_o.png" alt=""></p> 
<h3><a id="4_JnixIO_27"></a>4. Jnix网终编程中的五种IO模型</h3> 
<p><img src="https://images2.imgbox.com/e0/b0/8zrDUruF_o.png" alt=""></p> 
<h4><a id="_lO_multiplexing__lO_29"></a>① <code>lO multiplexing - lO多路复用</code></h4> 
<p><img src="https://images2.imgbox.com/3e/f7/QNxooAhW_o.png" alt=""></p> 
<h5><a id="_FileDescriptor_31"></a>Ⅰ FileDescriptor</h5> 
<p><img src="https://images2.imgbox.com/8c/8e/VzRinann_o.png" alt=""></p> 
<h5><a id="_I0l0_33"></a>Ⅱ 首次浅谈I0多路复用l0多路复用是什么</h5> 
<p><img src="https://images2.imgbox.com/36/7d/qkqPMM2l_o.png" alt=""></p> 
<h5><a id="_epoll_35"></a>Ⅲ <code>场景体验，说人话引出epoll</code></h5> 
<p><img src="https://images2.imgbox.com/e5/1c/ZVc6xYaX_o.png" alt=""></p> 
<h6><a id="_37"></a>场景解析</h6> 
<p><img src="https://images2.imgbox.com/9c/71/jZKHdTqs_o.png" alt=""></p> 
<h6><a id="IO_39"></a>IO多路复用模型，简单明了版理解</h6> 
<p><img src="https://images2.imgbox.com/3a/2e/S2udsFkG_o.png" alt=""></p> 
<h5><a id="__41"></a>Ⅳ 小总结</h5> 
<p><img src="https://images2.imgbox.com/0e/10/hja2ViSQ_o.png" alt=""><br> <img src="https://images2.imgbox.com/04/6d/X0if1dTm_o.png" alt=""></p> 
<h5><a id="_redis_44"></a>Ⅴ redis为什么这么快</h5> 
<p><img src="https://images2.imgbox.com/cb/54/wsaB6NR0_o.png" alt=""></p> 
<h3><a id="5_RedisRedis_46"></a>5. 简单说明：<code>Redis工作线程是单线程的；但是，整个Redis来说，是多线程的</code></h3> 
<p><img src="https://images2.imgbox.com/a9/2c/awGmCDak_o.png" alt=""></p> 
<h4><a id="_IO_48"></a>① 主线程和IO线程是怎么协作完成请求处理的-精简版</h4> 
<p><img src="https://images2.imgbox.com/4c/f7/AA4u0a0w_o.png" alt=""></p> 
<h4><a id="__50"></a>② 结论</h4> 
<p><img src="https://images2.imgbox.com/29/24/aa6Sksfz_o.png" alt=""></p> 
<h3><a id="6_Redis7_52"></a>6. Redis7默认是否开启了多线程?</h3> 
<p><img src="https://images2.imgbox.com/f5/5f/XRrBJ1Cc_o.png" alt=""><br> <img src="https://images2.imgbox.com/62/8a/MT3Dya2V_o.png" alt=""><br> <img src="https://images2.imgbox.com/13/ed/GYn2fd73_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/62/8c/70tzB73k_o.png" alt=""></p> 
<h2><a id="_Bigkey_58"></a>二. Bigkey</h2> 
<p><img src="https://images2.imgbox.com/77/ad/kYwVPOVO_o.png" alt=""></p> 
<h3><a id="1_Morekey_60"></a>1. Morekey案例</h3> 
<h4><a id="_redis2000Wkey_61"></a>① 大批量往redis里面插入2000W测试数据key</h4> 
<p><img src="https://images2.imgbox.com/c5/fa/a4b2r4g2_o.png" alt=""><br> <img src="https://images2.imgbox.com/6b/6c/6S1yUwxF_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/93/02/i1DzDM03_o.png" alt=""><br> <img src="https://images2.imgbox.com/de/6d/6CsXZq8x_o.png" alt=""></p> 
<h4><a id="__67"></a>② 某快递巨头真实生产案例新闻</h4> 
<p><img src="https://images2.imgbox.com/39/ed/d35sZiHK_o.png" alt=""></p> 
<h5><a id="keys_100W_69"></a>keys* 你试试100W花费多少秒遍历查询</h5> 
<p><img src="https://images2.imgbox.com/f1/cf/mWBmQYhx_o.png" alt=""></p> 
<h5><a id="keys_flushdbflushall_71"></a><code>生产上限制keys */flushdb/flushall等危险命令以防止误删误用？</code></h5> 
<p><img src="https://images2.imgbox.com/80/ba/Ttb89V3f_o.png" alt=""></p> 
<h4><a id="_keys__73"></a>③ <code>不用keys *避免卡顿，那该用什么</code></h4> 
<h5><a id="Scan__74"></a>Scan 命令用于迭代数据库中的数据库键</h5> 
<p><img src="https://images2.imgbox.com/64/6c/R5tBLe6K_o.png" alt=""><br> <img src="https://images2.imgbox.com/ec/49/iUaIvmV1_o.png" alt=""><br> <img src="https://images2.imgbox.com/32/80/2eAENkJ7_o.png" alt=""></p> 
<h3><a id="2_BigKey_79"></a>2. BigKey案例</h3> 
<h4><a id="_big_80"></a>① 多大算big</h4> 
<h5><a id="Redis_81"></a>参考《阿里云Redis开发规范》</h5> 
<p><img src="https://images2.imgbox.com/e0/9e/20aJWWaY_o.png" alt=""></p> 
<h5><a id="string_83"></a>string和二级结构</h5> 
<p><img src="https://images2.imgbox.com/b5/c4/pyhZLxeH_o.png" alt=""><br> <img src="https://images2.imgbox.com/6a/4c/AZwuCdzw_o.png" alt=""></p> 
<h4><a id="__86"></a>② 有那些危害</h4> 
<p><img src="https://images2.imgbox.com/e1/5c/dcyvXUHX_o.png" alt=""></p> 
<h4><a id="__88"></a>③ 如何产生</h4> 
<p><img src="https://images2.imgbox.com/92/0f/8kukuweC_o.png" alt=""></p> 
<h4><a id="__90"></a>④ 如何发现</h4> 
<p><img src="https://images2.imgbox.com/e9/f4/5tI0x7qa_o.png" alt=""></p> 
<h5><a id="rediscli_bigkeys_92"></a>redis-cli --bigkeys</h5> 
<p><img src="https://images2.imgbox.com/eb/cc/vs7t4uw5_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/ed/88/pkzCbbo2_o.png" alt=""></p> 
<h5><a id="MEMORY_USAGE__98"></a>MEMORY USAGE 键</h5> 
<p><img src="https://images2.imgbox.com/20/fe/92Pvounu_o.png" alt=""><br> <img src="https://images2.imgbox.com/59/dd/Q894FSc6_o.png" alt=""></p> 
<h4><a id="__101"></a>⑤ 如何删除</h4> 
<p><img src="https://images2.imgbox.com/36/66/RwtXlBlz_o.png" alt=""><br> <img src="https://images2.imgbox.com/0f/04/HGl6Z2vV_o.png" alt=""></p> 
<h5><a id="_String_105"></a>Ⅰ String</h5> 
<blockquote> 
 <p>一般用del，如果过于庞大unlink</p> 
</blockquote> 
<h5><a id="_hash_107"></a>Ⅱ hash</h5> 
<p><img src="https://images2.imgbox.com/bc/4e/ZEvcGBoz_o.png" alt=""><br> <img src="https://images2.imgbox.com/44/d2/AnuY3S6R_o.png" alt=""></p> 
<h5><a id="_list_110"></a>Ⅲ list</h5> 
<p><img src="https://images2.imgbox.com/a6/f0/banWYtD9_o.png" alt=""><br> <img src="https://images2.imgbox.com/1d/5f/ubVVLxuL_o.png" alt=""><br> <img src="https://images2.imgbox.com/25/b9/ubG9iRgS_o.png" alt=""></p> 
<h5><a id="_set_114"></a>Ⅳ set</h5> 
<p><img src="https://images2.imgbox.com/86/cd/pPnxRAhs_o.png" alt=""><br> <img src="https://images2.imgbox.com/90/80/vGrIjgPW_o.png" alt=""></p> 
<h5><a id="_zset_119"></a>Ⅴ zset</h5> 
<p><img src="https://images2.imgbox.com/12/44/8R6mNSbR_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/64/fb/oMmj1SrU_o.png" alt=""></p> 
<h3><a id="3_Bigkey_124"></a>3. Bigkey生产调优</h3> 
<p><img src="https://images2.imgbox.com/b9/b6/EvvpCBIe_o.png" alt=""><br> <img src="https://images2.imgbox.com/8c/bd/Y61g5zLO_o.png" alt=""><br> <img src="https://images2.imgbox.com/21/28/GoWCHa9U_o.png" alt=""></p> 
<h2><a id="_129"></a>三、缓存双写一致性之更新策略探讨</h2> 
<p><img src="https://images2.imgbox.com/0f/0a/4IdZ9kad_o.png" alt=""></p> 
<h3><a id="1__131"></a>1. <code>缓存双写一致性，谈谈你的理解</code></h3> 
<p><img src="https://images2.imgbox.com/64/39/xA25UIu6_o.png" alt=""></p> 
<h4><a id="_133"></a>读写缓存</h4> 
<p><img src="https://images2.imgbox.com/63/ce/c9kCe0nm_o.png" alt=""></p> 
<h4><a id="_135"></a><code>采用双检加锁策略</code></h4> 
<p><img src="https://images2.imgbox.com/0a/9b/MJD3jPA3_o.png" alt=""><br> <img src="https://images2.imgbox.com/ca/20/ZJEjjiUX_o.png" alt=""><br> <img src="https://images2.imgbox.com/ad/b8/WZXNDu2w_o.png" alt=""></p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@Service</span>
<span class="token annotation punctuation">@Slf4j</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserService</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">CACHE_KEY_USER</span> <span class="token operator">=</span> <span class="token string">"user:"</span><span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">UserMapper</span> userMapper<span class="token punctuation">;</span>
    <span class="token annotation punctuation">@Resource</span>
    <span class="token keyword">private</span> <span class="token class-name">RedisTemplate</span> redisTemplate<span class="token punctuation">;</span>

    <span class="token comment">/**
     * 业务逻辑没有写错，对于小厂中厂(QPS《=1000)可以使用，但是大厂不行
     * @param id
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">findUserById</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token constant">CACHE_KEY_USER</span><span class="token operator">+</span>id<span class="token punctuation">;</span>

        <span class="token comment">//1 先从redis里面查询，如果有直接返回结果，如果没有再去查询mysql</span>
        user <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span><span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
        <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//2 redis里面无，继续查询mysql</span>
            user <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectByPrimaryKey</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
            <span class="token punctuation">{<!-- --></span>
                <span class="token comment">//3.1 redis+mysql 都无数据</span>
                <span class="token comment">//你具体细化，防止多次穿透，我们业务规定，记录下导致穿透的这个key回写redis</span>
                <span class="token keyword">return</span> user<span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                <span class="token comment">//3.2 mysql有，需要将数据写回redis，保证下一次的缓存命中率</span>
                redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> user<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>


    <span class="token comment">/**
     * 加强补充，避免突然key失效了，打爆mysql，做一下预防，尽量不出现击穿的情况。
     * @param id
     * @return
     */</span>
    <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">findUserById2</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span>
    <span class="token punctuation">{<!-- --></span>
        <span class="token class-name">User</span> user <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token class-name">String</span> key <span class="token operator">=</span> <span class="token constant">CACHE_KEY_USER</span><span class="token operator">+</span>id<span class="token punctuation">;</span>

        <span class="token comment">//1 先从redis里面查询，如果有直接返回结果，如果没有再去查询mysql，</span>
        <span class="token comment">// 第1次查询redis，加锁前</span>
        user <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
            <span class="token comment">//2 大厂用，对于高QPS的优化，进来就先加锁，保证一个请求操作，让外面的redis等待一下，避免击穿mysql</span>
            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">UserService</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{<!-- --></span>
                <span class="token comment">//第2次查询redis，加锁后</span>
                user <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">User</span><span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">//3 二次查redis还是null，可以去查mysql了(mysql默认有数据)</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                    <span class="token comment">//4 查询mysql拿数据(mysql默认有数据)</span>
                    user <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectByPrimaryKey</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
                        <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{<!-- --></span>
                        <span class="token comment">//5 mysql里面有数据的，需要回写redis，完成数据一致性的同步工作</span>
                        redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setIfAbsent</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>user<span class="token punctuation">,</span><span class="token number">7L</span><span class="token punctuation">,</span><span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">DAYS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> user<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre> 
<h3><a id="2__217"></a>2. 数据库和缓存一致性的几种更新策略</h3> 
<p><img src="https://images2.imgbox.com/35/b2/Lmd9vc1b_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/f7/64/VBuyZfII_o.png" alt=""></p> 
<h4><a id="_221"></a>先更新数据库，再更新缓存</h4> 
<p><img src="https://images2.imgbox.com/22/bd/g0Fygwu9_o.png" alt=""><br> <img src="https://images2.imgbox.com/89/26/8JxLSRQA_o.png" alt=""></p> 
<h4><a id="_224"></a>先更新缓存，再更新数据库</h4> 
<p><img src="https://images2.imgbox.com/0e/00/1T7LZok2_o.png" alt=""><br> <img src="https://images2.imgbox.com/49/2f/W3gP47ch_o.png" alt=""></p> 
<h4><a id="_227"></a>先删除缓存，再更新数据库</h4> 
<p><img src="https://images2.imgbox.com/2d/c7/DrB90Qqb_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/8f/5a/f2MNpFBQ_o.png" alt=""><br> <img src="https://images2.imgbox.com/60/cc/haY0ZUic_o.png" alt=""><br> <img src="https://images2.imgbox.com/f1/72/aJQ5VH5I_o.png" alt=""><br> <img src="https://images2.imgbox.com/63/8a/1q7xZQp9_o.png" alt=""></p> 
<h5><a id="_234"></a>解决方法</h5> 
<p><img src="https://images2.imgbox.com/21/38/JsrkIxQM_o.png" alt=""><br> <img src="https://images2.imgbox.com/3c/e5/W7S17WPB_o.png" alt=""><br> <img src="https://images2.imgbox.com/57/ac/dSbA0ErS_o.png" alt=""></p> 
<h4><a id="__241"></a><code>更新策略之 先更新数据库，再删除缓存</code></h4> 
<p><img src="https://images2.imgbox.com/bd/de/IwX8yxWA_o.png" alt=""><br> <img src="https://images2.imgbox.com/cc/d1/sN4MIWwf_o.png" alt=""><br> <img src="https://images2.imgbox.com/d6/60/1jm6FMY7_o.png" alt=""></p> 
<h3><a id="3_246"></a>3.小总结</h3> 
<p><img src="https://images2.imgbox.com/31/70/Ki5JSGjb_o.png" alt=""><br> <img src="https://images2.imgbox.com/39/68/GhzzEcQf_o.png" alt=""><br> <img src="https://images2.imgbox.com/1c/74/YA83LjTi_o.png" alt=""></p> 
<hr> 
<h2><a id="_RedisMySQL_251"></a>四. Redis与MySQL数据双写一致性工程落地案例</h2> 
<p><img src="https://images2.imgbox.com/0a/1f/dfUE0APj_o.png" alt=""></p> 
<h3><a id="1__253"></a>1. 复习+面试题</h3> 
<p><img src="https://images2.imgbox.com/89/2d/rSvdAmVi_o.png" alt=""><br> <img src="https://images2.imgbox.com/3f/85/PP3LurPF_o.png" alt=""></p> 
<h3><a id="2_canal_256"></a>2. canal</h3> 
<p><img src="https://images2.imgbox.com/b2/c1/JALdW7VJ_o.png" alt=""></p> 
<h4><a id="__260"></a>① 是什么</h4> 
<p><img src="https://images2.imgbox.com/fb/50/74rZxpMS_o.png" alt=""></p> 
<h3><a id="3___262"></a>3. 工作原理</h3> 
<p><img src="https://images2.imgbox.com/20/fb/Vub73C2k_o.png" alt="在这里插入图片描述"><br> <img src="https://images2.imgbox.com/b3/af/njgeFLmq_o.png" alt=""><br> <img src="https://images2.imgbox.com/63/15/O2g6vGvX_o.png" alt=""></p> 
<h3><a id="4_mysqlcanalredisCoding_266"></a>4. <code>mysql-canal-redis双写一致性Coding</code></h3> 
<p><img src="https://images2.imgbox.com/3f/4e/3yvUhi2v_o.png" alt=""></p> 
<p><img src="https://images2.imgbox.com/42/7d/D94fJFZ2_o.png" alt=" "></p> 
<h2><a id="_bitmaphyperloglogGEO_270"></a>五. 案例落地实战bitmap/hyperloglog/GEO</h2> 
<h3><a id="1_271"></a>1.</h3>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/df1bc7a0aeb62ce831972336970f1662/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">基于的python的文件判断、处理，地址存表的模块</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/26d3d62870153921f4b2308069b997ee/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">吸烟(抽烟)检测和识别1：吸烟(抽烟)数据集说明(含下载链接)</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>