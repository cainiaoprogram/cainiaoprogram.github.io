<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>MyBatis笔记 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="MyBatis笔记" />
<meta property="og:description" content="目录
常见bug：
常见注意事项：
1.关于日志
2.编写一个获取SqlSession对象的工具类
3.CRUD
3.1 MyBatis中完成Map集合传参完成insert
3.2 MyBatis中通过POJO类完成传参
3.3 实现Delete删除
3.4 实现update修改
3.5实现查询
查询所有数据表所有数据
3.6 Mapper映射文件的namespace
四.Mybatis核心配置文件详解
4.1、mybatis-config.xml
手写mybatis框架：
javassist的使用
使用动态代理完成CRUD
Mybatis小技巧
1.#{}和${}的区别
2.什么时候需要使用${}
3.小技巧之别名机制
4.小技巧之sql映射文件在mybatis-config.xml配置路径
5.小技巧之在idea配置mybatis核心文档和Sql映射文档
6.小技巧之插入数据时返回自增主键
Mybatis的参数处理(mybatis核心)
单个简单参数类型
参数为Map
单个参数总结
多参数
多参数之注解Param
再一次理解动态代理
查询专列
模糊查询
返回Map集合
返回List
返回Map&lt; String , Map&lt; String,Object &gt; &gt;大Map集
查询之结果映射(重要)
查询所有记录条数
动态SQL
if标签
where标签
trim标签
set标签
choose when otherwise
foreach标签
批量删除
批量插入
sql与include标签
高级映射
高级映射多对一
方案一：一条SQL语句，级联属性映射
方案二：一条sql语句，association
方案三：两条SQL语句，分步查询。（这种方式常用：优点一是可复用。优点二是支持懒加载。
高级映射之一对多
十四、MyBatis的缓存" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/b80e3fd7f7d01752c4c6e097595a0e13/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-30T23:56:22+08:00" />
<meta property="article:modified_time" content="2023-03-30T23:56:22+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">MyBatis笔记</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:0px;"></p> 
<p id="%E5%B8%B8%E8%A7%81bug%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%B8%B8%E8%A7%81bug%EF%BC%9A" rel="nofollow">常见bug：</a></p> 
<p id="%E5%B8%B8%E8%A7%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E5%B8%B8%E8%A7%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A" rel="nofollow">常见注意事项：</a></p> 
<p id="1.%E5%85%B3%E4%BA%8E%E6%97%A5%E5%BF%97-toc" style="margin-left:0px;"><a href="#1.%E5%85%B3%E4%BA%8E%E6%97%A5%E5%BF%97" rel="nofollow">1.关于日志</a></p> 
<p id="2.%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%8E%B7%E5%8F%96SqlSession%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB-toc" style="margin-left:0px;"><a href="#2.%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%8E%B7%E5%8F%96SqlSession%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB" rel="nofollow">2.编写一个获取SqlSession对象的工具类</a></p> 
<p id="3.CRUD-toc" style="margin-left:0px;"><a href="#3.CRUD" rel="nofollow">3.CRUD</a></p> 
<p id="3.1%20MyBatis%E4%B8%AD%E5%AE%8C%E6%88%90Map%E9%9B%86%E5%90%88%E4%BC%A0%E5%8F%82%E5%AE%8C%E6%88%90insert-toc" style="margin-left:40px;"><a href="#3.1%20MyBatis%E4%B8%AD%E5%AE%8C%E6%88%90Map%E9%9B%86%E5%90%88%E4%BC%A0%E5%8F%82%E5%AE%8C%E6%88%90insert" rel="nofollow">3.1 MyBatis中完成Map集合传参完成insert</a></p> 
<p id="3.2%20MyBatis%E4%B8%AD%E9%80%9A%E8%BF%87POJO%E7%B1%BB%E5%AE%8C%E6%88%90%E4%BC%A0%E5%8F%82-toc" style="margin-left:40px;"><a href="#3.2%20MyBatis%E4%B8%AD%E9%80%9A%E8%BF%87POJO%E7%B1%BB%E5%AE%8C%E6%88%90%E4%BC%A0%E5%8F%82" rel="nofollow">3.2 MyBatis中通过POJO类完成传参</a></p> 
<p id="3.3%20%E5%AE%9E%E7%8E%B0Delete%E5%88%A0%E9%99%A4-toc" style="margin-left:40px;"><a href="#3.3%20%E5%AE%9E%E7%8E%B0Delete%E5%88%A0%E9%99%A4" rel="nofollow">3.3 实现Delete删除</a></p> 
<p id="3.4%20%E5%AE%9E%E7%8E%B0update%E4%BF%AE%E6%94%B9-toc" style="margin-left:40px;"><a href="#3.4%20%E5%AE%9E%E7%8E%B0update%E4%BF%AE%E6%94%B9" rel="nofollow">3.4 实现update修改</a></p> 
<p id="3.5%E5%AE%9E%E7%8E%B0%E6%9F%A5%E8%AF%A2-toc" style="margin-left:40px;"><a href="#3.5%E5%AE%9E%E7%8E%B0%E6%9F%A5%E8%AF%A2" rel="nofollow">3.5实现查询</a></p> 
<p id="%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE-toc" style="margin-left:80px;"><a href="#%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE" rel="nofollow">查询所有数据表所有数据</a></p> 
<p id="3.6%20Mapper%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E7%9A%84namespace-toc" style="margin-left:40px;"><a href="#3.6%20Mapper%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E7%9A%84namespace" rel="nofollow">3.6 Mapper映射文件的namespace</a></p> 
<p id="%E5%9B%9B.Mybatis%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3-toc" style="margin-left:0px;"><a href="#%E5%9B%9B.Mybatis%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3" rel="nofollow">四.Mybatis核心配置文件详解</a></p> 
<p id="4.1%E3%80%81mybatis-config.xml-toc" style="margin-left:40px;"><a href="#4.1%E3%80%81mybatis-config.xml" rel="nofollow">4.1、mybatis-config.xml</a></p> 
<p id="%E6%89%8B%E5%86%99mybatis%E6%A1%86%E6%9E%B6%EF%BC%9A-toc" style="margin-left:0px;"><a href="#%E6%89%8B%E5%86%99mybatis%E6%A1%86%E6%9E%B6%EF%BC%9A" rel="nofollow">手写mybatis框架：</a></p> 
<p id="javassist%E7%9A%84%E4%BD%BF%E7%94%A8-toc" style="margin-left:0px;"><a href="#javassist%E7%9A%84%E4%BD%BF%E7%94%A8" rel="nofollow">javassist的使用</a></p> 
<p id="%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%8C%E6%88%90CRUD-toc" style="margin-left:0px;"><a href="#%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%8C%E6%88%90CRUD" rel="nofollow">使用动态代理完成CRUD</a></p> 
<p id="Mybatis%E5%B0%8F%E6%8A%80%E5%B7%A7-toc" style="margin-left:0px;"><a href="#Mybatis%E5%B0%8F%E6%8A%80%E5%B7%A7" rel="nofollow">Mybatis小技巧</a></p> 
<p id="1.%23%7B%7D%E5%92%8C%24%7B%7D%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:40px;"><a href="#1.%23%7B%7D%E5%92%8C%24%7B%7D%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">1.#{}和${}的区别</a></p> 
<p id="2.%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%24%7B%7D-toc" style="margin-left:40px;"><a href="#2.%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%24%7B%7D" rel="nofollow">2.什么时候需要使用${}</a></p> 
<p id="3.%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B9%8B%E5%88%AB%E5%90%8D%E6%9C%BA%E5%88%B6%3CtypeAliases%3E-toc" style="margin-left:40px;"><a href="#3.%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B9%8B%E5%88%AB%E5%90%8D%E6%9C%BA%E5%88%B6%3CtypeAliases%3E" rel="nofollow">3.小技巧之别名机制</a></p> 
<p id="4.%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B9%8Bsql%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E5%9C%A8mybatis-config.xml%E9%85%8D%E7%BD%AE%E8%B7%AF%E5%BE%84-toc" style="margin-left:40px;"><a href="#4.%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B9%8Bsql%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E5%9C%A8mybatis-config.xml%E9%85%8D%E7%BD%AE%E8%B7%AF%E5%BE%84" rel="nofollow">4.小技巧之sql映射文件在mybatis-config.xml配置路径</a></p> 
<p id="5.%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B9%8B%E5%9C%A8idea%E9%85%8D%E7%BD%AEmybatis%E6%A0%B8%E5%BF%83%E6%96%87%E6%A1%A3%E5%92%8CSql%E6%98%A0%E5%B0%84%E6%96%87%E6%A1%A3-toc" style="margin-left:40px;"><a href="#5.%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B9%8B%E5%9C%A8idea%E9%85%8D%E7%BD%AEmybatis%E6%A0%B8%E5%BF%83%E6%96%87%E6%A1%A3%E5%92%8CSql%E6%98%A0%E5%B0%84%E6%96%87%E6%A1%A3" rel="nofollow">5.小技巧之在idea配置mybatis核心文档和Sql映射文档</a></p> 
<p id="6.%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E6%97%B6%E8%BF%94%E5%9B%9E%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE-toc" style="margin-left:40px;"><a href="#6.%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E6%97%B6%E8%BF%94%E5%9B%9E%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE" rel="nofollow">6.小技巧之插入数据时返回自增主键</a></p> 
<p id="Mybatis%E7%9A%84%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86(mybatis%E6%A0%B8%E5%BF%83)-toc" style="margin-left:0px;"><a href="#Mybatis%E7%9A%84%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86%28mybatis%E6%A0%B8%E5%BF%83%29" rel="nofollow">Mybatis的参数处理(mybatis核心)</a></p> 
<p id="%E5%8D%95%E4%B8%AA%E7%AE%80%E5%8D%95%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B-toc" style="margin-left:40px;"><a href="#%E5%8D%95%E4%B8%AA%E7%AE%80%E5%8D%95%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B" rel="nofollow">单个简单参数类型</a></p> 
<p id="%E5%8F%82%E6%95%B0%E4%B8%BAMap-toc" style="margin-left:40px;"><a href="#%E5%8F%82%E6%95%B0%E4%B8%BAMap" rel="nofollow">参数为Map</a></p> 
<p id="%E5%8D%95%E4%B8%AA%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93-toc" style="margin-left:40px;"><a href="#%E5%8D%95%E4%B8%AA%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93" rel="nofollow">单个参数总结</a></p> 
<p id="%E5%A4%9A%E5%8F%82%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E5%A4%9A%E5%8F%82%E6%95%B0" rel="nofollow">多参数</a></p> 
<p id="%E5%A4%9A%E5%8F%82%E6%95%B0%E4%B9%8B%E6%B3%A8%E8%A7%A3Param-toc" style="margin-left:40px;"><a href="#%E5%A4%9A%E5%8F%82%E6%95%B0%E4%B9%8B%E6%B3%A8%E8%A7%A3Param" rel="nofollow">多参数之注解Param</a></p> 
<p id="%C2%A0%E5%86%8D%E4%B8%80%E6%AC%A1%E7%90%86%E8%A7%A3%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-toc" style="margin-left:40px;"><a href="#%C2%A0%E5%86%8D%E4%B8%80%E6%AC%A1%E7%90%86%E8%A7%A3%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86" rel="nofollow"> 再一次理解动态代理</a></p> 
<p id="%E6%9F%A5%E8%AF%A2%E4%B8%93%E5%88%97-toc" style="margin-left:0px;"><a href="#%E6%9F%A5%E8%AF%A2%E4%B8%93%E5%88%97" rel="nofollow">查询专列</a></p> 
<p id="%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2-toc" style="margin-left:40px;"><a href="#%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2" rel="nofollow">模糊查询</a></p> 
<p id="%E8%BF%94%E5%9B%9EMap%E9%9B%86%E5%90%88-toc" style="margin-left:40px;"><a href="#%E8%BF%94%E5%9B%9EMap%E9%9B%86%E5%90%88" rel="nofollow">返回Map集合</a></p> 
<p id="%E8%BF%94%E5%9B%9EList%3CMap%3E-toc" style="margin-left:40px;"><a href="#%E8%BF%94%E5%9B%9EList%3CMap%3E" rel="nofollow">返回List</a></p> 
<p id="%E8%BF%94%E5%9B%9EMap%3C%20String%20%2C%20Map%3C%20String%2CObject%20%3E%20%3E%E5%A4%A7Map%E9%9B%86-toc" style="margin-left:40px;"><a href="#%E8%BF%94%E5%9B%9EMap%3C%20String%20%2C%20Map%3C%20String%2CObject%20%3E%20%3E%E5%A4%A7Map%E9%9B%86" rel="nofollow">返回Map&lt; String , Map&lt; String,Object &gt; &gt;大Map集</a></p> 
<p id="%E6%9F%A5%E8%AF%A2%E4%B9%8B%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84(%E9%87%8D%E8%A6%81)-toc" style="margin-left:40px;"><a href="#%E6%9F%A5%E8%AF%A2%E4%B9%8B%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84%28%E9%87%8D%E8%A6%81%29" rel="nofollow">查询之结果映射(重要)</a></p> 
<p id="%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E8%AE%B0%E5%BD%95%E6%9D%A1%E6%95%B0-toc" style="margin-left:40px;"><a href="#%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E8%AE%B0%E5%BD%95%E6%9D%A1%E6%95%B0" rel="nofollow">查询所有记录条数</a></p> 
<p id="%E5%8A%A8%E6%80%81SQL-toc" style="margin-left:0px;"><a href="#%E5%8A%A8%E6%80%81SQL" rel="nofollow">动态SQL</a></p> 
<p id="if%E6%A0%87%E7%AD%BE-toc" style="margin-left:40px;"><a href="#if%E6%A0%87%E7%AD%BE" rel="nofollow">if标签</a></p> 
<p id="where%E6%A0%87%E7%AD%BE-toc" style="margin-left:40px;"><a href="#where%E6%A0%87%E7%AD%BE" rel="nofollow">where标签</a></p> 
<p id="trim%E6%A0%87%E7%AD%BE-toc" style="margin-left:40px;"><a href="#trim%E6%A0%87%E7%AD%BE" rel="nofollow">trim标签</a></p> 
<p id="set%E6%A0%87%E7%AD%BE-toc" style="margin-left:40px;"><a href="#set%E6%A0%87%E7%AD%BE" rel="nofollow">set标签</a></p> 
<p id="choose%20when%20otherwise-toc" style="margin-left:40px;"><a href="#choose%20when%20otherwise" rel="nofollow">choose when otherwise</a></p> 
<p id="foreach%E6%A0%87%E7%AD%BE-toc" style="margin-left:40px;"><a href="#foreach%E6%A0%87%E7%AD%BE" rel="nofollow">foreach标签</a></p> 
<p id="%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4-toc" style="margin-left:80px;"><a href="#%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4" rel="nofollow">批量删除</a></p> 
<p id="%C2%A0%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5-toc" style="margin-left:80px;"><a href="#%C2%A0%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5" rel="nofollow"> 批量插入</a></p> 
<p id="sql%E4%B8%8Einclude%E6%A0%87%E7%AD%BE-toc" style="margin-left:40px;"><a href="#sql%E4%B8%8Einclude%E6%A0%87%E7%AD%BE" rel="nofollow">sql与include标签</a></p> 
<p id="%E9%AB%98%E7%BA%A7%E6%98%A0%E5%B0%84-toc" style="margin-left:0px;"><a href="#%E9%AB%98%E7%BA%A7%E6%98%A0%E5%B0%84" rel="nofollow">高级映射</a></p> 
<p id="%E9%AB%98%E7%BA%A7%E6%98%A0%E5%B0%84%E5%A4%9A%E5%AF%B9%E4%B8%80-toc" style="margin-left:40px;"><a href="#%E9%AB%98%E7%BA%A7%E6%98%A0%E5%B0%84%E5%A4%9A%E5%AF%B9%E4%B8%80" rel="nofollow">高级映射多对一</a></p> 
<p id="%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%EF%BC%8C%E7%BA%A7%E8%81%94%E5%B1%9E%E6%80%A7%E6%98%A0%E5%B0%84-toc" style="margin-left:80px;"><a href="#%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%EF%BC%8C%E7%BA%A7%E8%81%94%E5%B1%9E%E6%80%A7%E6%98%A0%E5%B0%84" rel="nofollow">方案一：一条SQL语句，级联属性映射</a></p> 
<p id="%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9A%E4%B8%80%E6%9D%A1sql%E8%AF%AD%E5%8F%A5%EF%BC%8Cassociation-toc" style="margin-left:80px;"><a href="#%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9A%E4%B8%80%E6%9D%A1sql%E8%AF%AD%E5%8F%A5%EF%BC%8Cassociation" rel="nofollow">方案二：一条sql语句，association</a></p> 
<p id="%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9A%E4%B8%A4%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%EF%BC%8C%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2%E3%80%82%EF%BC%88%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%B8%B8%E7%94%A8%EF%BC%9A%E4%BC%98%E7%82%B9%E4%B8%80%E6%98%AF%E5%8F%AF%E5%A4%8D%E7%94%A8%E3%80%82%E4%BC%98%E7%82%B9%E4%BA%8C%E6%98%AF%E6%94%AF%E6%8C%81%E6%87%92%E5%8A%A0%E8%BD%BD%E3%80%82-toc" style="margin-left:80px;"><a href="#%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9A%E4%B8%A4%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%EF%BC%8C%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2%E3%80%82%EF%BC%88%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%B8%B8%E7%94%A8%EF%BC%9A%E4%BC%98%E7%82%B9%E4%B8%80%E6%98%AF%E5%8F%AF%E5%A4%8D%E7%94%A8%E3%80%82%E4%BC%98%E7%82%B9%E4%BA%8C%E6%98%AF%E6%94%AF%E6%8C%81%E6%87%92%E5%8A%A0%E8%BD%BD%E3%80%82" rel="nofollow">方案三：两条SQL语句，分步查询。（这种方式常用：优点一是可复用。优点二是支持懒加载。</a></p> 
<p id="%E9%AB%98%E7%BA%A7%E6%98%A0%E5%B0%84%E4%B9%8B%E4%B8%80%E5%AF%B9%E5%A4%9A-toc" style="margin-left:40px;"><a href="#%E9%AB%98%E7%BA%A7%E6%98%A0%E5%B0%84%E4%B9%8B%E4%B8%80%E5%AF%B9%E5%A4%9A" rel="nofollow">高级映射之一对多</a></p> 
<p id="kVguw-toc" style="margin-left:0px;"><a href="#kVguw" rel="nofollow">十四、MyBatis的缓存</a></p> 
<p id="GKwAH-toc" style="margin-left:40px;"><a href="#GKwAH" rel="nofollow">14.1 一级缓存</a></p> 
<p id="eWTHI-toc" style="margin-left:40px;"><a href="#eWTHI" rel="nofollow">14.2 二级缓存</a></p> 
<p id="mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B-toc" style="margin-left:0px;"><a href="#mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B" rel="nofollow">mybatis逆向工程</a></p> 
<hr id="hr-toc"> 
<p></p> 
<h2 id="%E5%B8%B8%E8%A7%81bug%EF%BC%9A">常见bug：</h2> 
<p>1.注解不生效原因：若注解不生效，但是在web.xml文件中又可以用则很有可能是在web.xml中</p> 
<pre><code>metadata-complete="true"
把这个true改为false，若为true则代表只支持web.xml文件配置，
改为false则代表都支持</code></pre> 
<p></p> 
<h2 id="%E5%B8%B8%E8%A7%81%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A">常见注意事项：</h2> 
<p>关于mapper.xml</p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;
&lt;!--(id,car_num,brand,guide_price,produce_time,car_type)--&gt;
&lt;!--下面这个namespace名字必须是接口的全类名--&gt;
&lt;mapper namespace="com.yzh.mybatis.mapper.CarMapper"&gt;
    &lt;!--下面这些id的值必须要填接口中的方法名--&gt;
    &lt;insert id="insert"&gt;
    &lt;!--insert语句中的#{}里面必须要填的是属性名字 --&gt;
        insert into t_car values(null,#{},#{},#{},#{},#{})
    &lt;/insert&gt;
    &lt;!--查询语句中的查询字段必须为数据库中的字段
    若数据库的字段与封装类的属性名不一致需要修改别名
    否则无法给你封装到那个pojo类对象中，封装过后的属性值为null--&gt;
    &lt;select id="selectById" resultType="com.yzh.mybatis.pojo.Car"&gt;&lt;/select&gt;
&lt;/mapper&gt;</code></pre> 
<p><span style="color:#fe2c24;"><strong>类的根路径下：</strong></span></p> 
<p><span style="color:#fe2c24;"><strong>类指的是全类名，全类名的上一级目录就是类的根路径，那他的上一级目录就是那个蓝色的java文件</strong></span></p> 
<p>比如说com.yzh.mybatis.mapper.CarMapper.javar</p> 
<p><img alt="" height="112" src="https://images2.imgbox.com/97/84/s1xB7vVa_o.png" width="261"></p> 
<p>还有一个细节：在mybatis中，resources文件就是从类的全路径下开始找，也就是从蓝色的java文件下开始找。一般情况下若属性名出现resources="";这样的那么你都可以放在resources这个文件下，因为这个文件就相当于是类的根路径。</p> 
<p></p> 
<p></p> 
<h2 id="1.%E5%85%B3%E4%BA%8E%E6%97%A5%E5%BF%97">1.关于日志</h2> 
<p><strong>mybatis有以下几种实现方式：</strong></p> 
<p>    SLF4J（沙拉疯）：一种日志标准，logback就是继承沙拉疯实现的<br>     LOG4J：<br>     LOG4J2：<br>     STDOUT_LOGGING：MyBatis内部实现的日志组件，<br> logback、log4j、log4j2是同一个作者编写的。</p> 
<p>其中STDOUT_LOGGING已经被mybatis实现了只需要在mybatis核心文档中开启以下即可：</p> 
<pre><code class="language-XML">&lt;configuration&gt;
    &lt;settings&gt;
        &lt;setting name="logImpl " value="STDOUT_LOGGING"/&gt;
    &lt;/settings&gt;
&lt;/configuration&gt;

//翻译为设置s
//logImpl指的是Log implementation翻译为日志缩写，
注意：settings标签必须添加在configuration下面
</code></pre> 
<p>但是这个自带的日志我们一把不用，我们使用最常用的logback组件(就是SLF4J（沙拉疯）)。</p> 
<p><strong>配置logback日志框架：</strong></p> 
<p>第一步：在Maven(pom.xml)中引入logback依赖</p> 
<pre><code class="language-XML">        &lt;dependency&gt;
            &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt;
            &lt;artifactId&gt;logback-classic&lt;/artifactId&gt;
            &lt;version&gt;1.2.11&lt;/version&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
</code></pre> 
<p><img alt="" height="309" src="https://images2.imgbox.com/63/e9/mdTa40lG_o.png" width="1105"></p> 
<p>第三步:编写logback所必须的xml配置文件(主要配置日志输出相关的级别以及日志具体的格式。)。<br> 这个配置文件的名字必须叫做: logback.xml或者logback-test.xml，不能是其它的名字。<br> 这个配置文件必须放到类的根路径下。不能是其他位置。那放到resources文件下即可，因为resources默认就是在类的根路径下，直接创建logback.xml把下面的复制过去即可。</p> 
<p>问：为什么引入了logback的依赖还要配置这个东西？因为下面这个是对logback日志文件信息的格式设置，虽然引入了依赖但是没有制定日志信息格式。</p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;configuration debug="false"&gt;
    &lt;!-- 设置控制台输出 --&gt;
    &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
        &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
    &lt;/appender&gt;

    &lt;!--mybatis log configure--&gt;
    &lt;logger name="com.apache.ibatis" level="TRACE"/&gt;
    &lt;logger name="java.sql.Connection" level="DEBUG"/&gt;
    &lt;logger name="java.sql.Statement" level="DEBUG"/&gt;
    &lt;logger name="java.sql.PreparedStatement" level="DEBUG"/&gt;

    &lt;!-- 日志输出级别,logback日志级别包括五个：TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR --&gt;
    &lt;root level="DEBUG"&gt;
        &lt;appender-ref ref="STDOUT"/&gt;
        &lt;appender-ref ref="FILE"/&gt;
    &lt;/root&gt;



&lt;!-- 按照每天生成日志文件，设置日志保留的天数，可以删掉 
    &lt;appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt;
        &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt;
            &lt;!--日志文件输出的文件名--&gt;
            &lt;FileNamePattern&gt;${LOG_HOME}/TestWeb.log.%d{yyyy-MM-dd}.log&lt;/FileNamePattern&gt;
            &lt;!--日志文件保留天数--&gt;
            &lt;MaxHistory&gt;30&lt;/MaxHistory&gt;
        &lt;/rollingPolicy&gt;
        &lt;encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder"&gt;
            &lt;!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符--&gt;
            &lt;pattern&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n&lt;/pattern&gt;
        &lt;/encoder&gt;
        &lt;!--日志文件最大的大小--&gt;
        &lt;triggeringPolicy class="ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy"&gt;
            &lt;MaxFileSize&gt;100MB&lt;/MaxFileSize&gt;
        &lt;/triggeringPolicy&gt;
    &lt;/appender&gt;
--&gt;

&lt;/configuration&gt;</code></pre> 
<p></p> 
<h2 id="2.%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E8%8E%B7%E5%8F%96SqlSession%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B7%A5%E5%85%B7%E7%B1%BB">2.编写一个获取SqlSession对象的工具类</h2> 
<p>编写原因：每次获取SqlSession对象都很麻烦需要经过以下步骤才能拿到</p> 
<pre><code class="language-java">SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);
SqlSession sqlSession = sqlSessionFactory.openSession();</code></pre> 
<p>所以编写一个类似于JDBCUtil的工具类。我们先来解读一下以上代码：</p> 
<p><span style="color:#fe2c24;">SqlSessionFactory翻译为Sql会话工厂，用来获取一个操作数据库的会话对象，</span></p> 
<p><span style="color:#fe2c24;">一个SqlSessionFactory对应一个环境，也就是一个数据库:</span></p> 
<pre><code class="language-XML">&lt;environment id="development"&gt;里面配置链接数据库的信息&lt;/environment&gt;</code></pre> 
<p>一个environment对应一个数据库(例如：db01、db02....)，所以：以下三行代码</p> 
<pre><code class="language-java">SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
InputStream is = Resources.getResourceAsStream("mybatis-config.xml");
SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is);</code></pre> 
<p>理应在类加载时加载，不需要在每次获取SqlSession对象时重复创建。</p> 
<pre><code class="language-java">public class SqlSessionUtil {
    private static SqlSessionFactory sqlSessionFactory;
    private SqlSessionUtil(){}
    static {
        SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
        try {
            sqlSessionFactory = sqlSessionFactoryBuilder.build(Resources.getResourceAsReader("mybatis-config.xml"));
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    public static SqlSession getSession(){
        return sqlSessionFactory.openSession();
    }
}</code></pre> 
<p></p> 
<p></p> 
<h2 id="3.CRUD"><span style="color:#0d0016;">3.CRUD</span></h2> 
<h3 id="3.1%20MyBatis%E4%B8%AD%E5%AE%8C%E6%88%90Map%E9%9B%86%E5%90%88%E4%BC%A0%E5%8F%82%E5%AE%8C%E6%88%90insert">3.1 MyBatis中完成Map集合传参完成insert</h3> 
<p>第一个入门程序已完成，现在我们来做MyBatis的CRUD操作<br> 入门程序有个问题：实战的时候新增数据表行数据不可能是固定值<br> 回顾：</p> 
<blockquote> 
 <p>&lt;mapper namespace="org.mybatis.example.BlogMapper"&gt;<br>     &lt;insert id="insertCar"&gt;<br>         insert into t_car(id,car_num,brand,guide_price,produce_time,car_type)<br>         values (null,1003,"面包车",13.00,"2020-10-13","飞行汽车")<br>     &lt;/insert&gt;<br> &lt;/mapper&gt;</p> 
</blockquote> 
<p>继续完善这个程序，新建一个模块叫CRUD，如图，把模块1的一些文件拷贝过来，maven依赖引用</p> 
<p><img alt="" height="412" src="https://images2.imgbox.com/a3/91/2gGNHUOJ_o.png" width="403"></p> 
<p>修改CarMapper.xml文件，加上占位符<br> 在MyBatis中占位符为#{}，对应JDBC的?</p> 
<pre><code class="language-XML">    &lt;insert id="insertCar"&gt;
        insert into t_car(id,car_num,brand,guide_price,produce_time,car_type)
        values (null,#{},#{},#{},#{},#{})
    &lt;/insert&gt;
</code></pre> 
<p> 编写测试代码</p> 
<pre><code class="language-java">public class CarMapperTest {
    @Test
    public void insertCar(){
        SqlSession session = SqlSessionUtil.openSession();
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        map.put("carNum","1004");
        map.put("brand","比亚迪汉");
        map.put("guidePrice",160.00);
        map.put("produceTime","2022-06-08");
        map.put("carType","新能源汽车");

        int count= session.insert("insertCar", map);
        System.out.println("新增的条目："+count);
        session.commit();

        session.close();
    }
}
</code></pre> 
<p> 修改mapper文件中的占位符#{}（大括号中间填入map.get(key)里面的key）</p> 
<pre><code class="language-XML">&lt;mapper namespace="org.mybatis.example.BlogMapper"&gt;
    &lt;insert id="insertCar"&gt;
        insert into t_car(id,car_num,brand,guide_price,produce_time,car_type)
        values (null,#{carNum},#{brand},#{guidePrice},#{produceTime},#{carType})
    &lt;/insert&gt;
&lt;/mapper&gt;
</code></pre> 
<h3 id="3.2%20MyBatis%E4%B8%AD%E9%80%9A%E8%BF%87POJO%E7%B1%BB%E5%AE%8C%E6%88%90%E4%BC%A0%E5%8F%82">3.2 MyBatis中通过POJO类完成传参</h3> 
<p>    新建POJO包、类（pojo.Car）</p> 
<pre><code class="language-java">public class Car {
//注意这里为什么要写包装类？因为这个id是主键自增，你需要传null，
//但是使用int和long不传值或者传null会报错，包括下面的Double(有时候需要传null)
    private Long id;
    private String carNum;
    private String brand;
    private Double guidePrice;
    private String produceTime;
    private String carType;
    //此处省略构造方法、gett、set、toString方法
    .....
}</code></pre> 
<p>    编写测试代码</p> 
<pre><code class="language-java">    @Test
    public void testInsertCarByPOJO(){
       SqlSession session =  SqlSessionUtil.getSession();
        Car car = new Car(null,"10001","宝马",78.5,"2013","宝马X5");
        session.insert("insertCar",car);
       session.commit();
       session.close();
    }</code></pre> 
<p>    编辑mapper文件</p> 
<pre><code class="language-XML">&lt;mapper namespace="car"&gt;
    &lt;insert id="insertCar"&gt;
        insert into t_car
            (id,car_num,brand,guide_price,produce_time,car_type)
            values
            (null,#{carNum},#{brand},#{guidePrice},#{produceTime},#{carType});
    &lt;/insert&gt;
&lt;/mapper&gt;

</code></pre> 
<p><strong><span style="color:#fe2c24;">注意注意：#{这里面填的是Car类这个javabean中的getXxx的xxx} ，比如：#{carNum}找到他的get方法，为这样：getCarNum，那你就得在括号里面填入carNum，首字母改为小写后面的照着抄即可，不要纠结后面的大小写，你只要注意首字母的变化规则然后后面的照着抄即可。</span></strong></p> 
<p><img alt="" height="578" src="https://images2.imgbox.com/22/f5/88l69ybl_o.png" width="1047"></p> 
<p>就是说若#{xyz}，mybatis底层不是按照你在括号面填入的名字去找属性名的，它首先把xyz拿出来，把首字母改成大写"Xyz",然后在前面加上get变为"getXyz",通过这个"getXyz"去找到对应属性值。若你吧carNum的get方法改为这样：</p> 
<p><img alt="" height="95" src="https://images2.imgbox.com/6e/c0/CzkOr0o5_o.png" width="310"></p> 
<p>这样子，他是不会报错的，一样可以拿到carNum。</p> 
<p>mapper文件中填写的#{carType})，MyBatis会通过反射机制查找getCarType()方法得到值</p> 
<p></p> 
<h3 id="3.3%20%E5%AE%9E%E7%8E%B0Delete%E5%88%A0%E9%99%A4">3.3 实现Delete删除</h3> 
<p>    新增Mapper删除</p> 
<pre><code class="language-XML">    &lt;delete id="deleteById"&gt;
        delete from t_car where id = #{id}
    &lt;/delete&gt;</code></pre> 
<p>    编写测试方法</p> 
<pre><code class="language-java">    @Test
    public void deleteById(){
        SqlSession session = SqlSessionUtil.openSession();
        session.delete("deleteById",17);
        session.commit();
        session.close();
    }</code></pre> 
<p>    注意事项<br>     当参数只有一个时，#{这里随便填，参数名可以随意}，但是尽量做到见名知意</p> 
<h3 id="3.4%20%E5%AE%9E%E7%8E%B0update%E4%BF%AE%E6%94%B9">3.4 实现update修改</h3> 
<p>    编写mapper</p> 
<pre><code class="language-XML">    &lt;update id="updateById"&gt;
        update t_car
            set car_num = #{carNum},
                brand = #{brand},
                guide_price = #{guidePrice},
                produce_time = #{produceTime},
                car_type = #{carType}
            where id = #{id};
    &lt;/update&gt;</code></pre> 
<p>    编写测试类</p> 
<pre><code class="language-java">    @Test
    public void testUpdateCarById(){
        SqlSession session = SqlSessionUtil.getSession();
        Car car = new Car(14L,"1002","凯美瑞",23.3,"2018-7-12","燃油车");
        session.update("updateById",car);
        session.commit();
        session.close();
    }</code></pre> 
<p></p> 
<h3 id="3.5%E5%AE%9E%E7%8E%B0%E6%9F%A5%E8%AF%A2">3.5实现查询</h3> 
<p>    编写mapper</p> 
<pre><code class="language-XML">    &lt;select id="selectById" resultType="com.yzh.mybatis.pojo.Car"&gt;
        select id,
               car_num as carNum,
               brand,
               guide_price as guidePrice,
               produce_time as produceTime,
               car_type as carType
               from t_car
        where id = #{id};
    &lt;/select&gt;

//这里为什么要取别名是因为我定义的javabean：Car中取的属性名与数据库的字段名不一致
//比如：car_num as carNum 若不取别名，因为返回的结果集会封装到Car对象，则carNum
//为null
</code></pre> 
<p>编写测试方法</p> 
<pre><code class="language-java">    @Test
    public void testSelectCarById(){
        SqlSession session = SqlSessionUtil.getSession();
        Object car = session.selectOne("selectById", 13);
        System.out.println(car);
        session.commit();
        session.close();
    }</code></pre> 
<blockquote> 
 <p>注意事项：</p> 
 <p>在Mapper映射文件中的&lt;select&gt;标签要增加一个<span style="color:#fe2c24;">resultType="全类名" </span> 属性用来指定mybatis返回结果集后封装成什么样的对象。否则会报错，并且有时候<br>  </p> 
</blockquote> 
<p></p> 
<h4 id="%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE%E8%A1%A8%E6%89%80%E6%9C%89%E6%95%B0%E6%8D%AE">查询所有数据表所有数据</h4> 
<p>编写Mapper</p> 
<pre><code class="language-XML">    &lt;select id="selectAll" resultType="com.yzh.mybatis.pojo.Car"&gt;
        select id,
               car_num as carNum,
               brand,
               guide_price as guidePrice,
               produce_time as produceTime,
               car_type as carType
        from t_car;
    &lt;/select&gt;</code></pre> 
<p>编写测试方法</p> 
<pre><code class="language-java">    @Test
    public void testSelectAllCar(){
        SqlSession session = SqlSessionUtil.getSession();
        List&lt;Car&gt; cars = session.selectList("selectAll");
        cars.forEach(car -&gt; System.out.println(car));
        session.commit();
        session.close();
    }
</code></pre> 
<h3 id="3.6%20Mapper%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E7%9A%84namespace">3.6 Mapper映射文件的namespace</h3> 
<p><img alt="" height="159" src="https://images2.imgbox.com/75/d8/G0Ss1vYs_o.png" width="935"></p> 
<p>Mapper映射文件指的就是比如CarMapper.xml，一个映射文件一般对应一个数据表。创建完一个Mapper映射文件应该在mybatis核心文件：mybatis-config.xml中配置一下：</p> 
<pre><code class="language-XML">&lt;configuration&gt;
    &lt;mappers&gt;
        &lt;mapper resource="CarMapper.xml"/&gt;
    &lt;/mappers&gt;
&lt;configuration/&gt;</code></pre> 
<p> 说回这个namespace,假如说我现在有两个Mapper映射文件(CarMapper1.xml,CarMapper2.xml)</p> 
<p>在这两个文件里面都写上：</p> 
<pre><code class="language-XML">CarMapper1.xml
&lt;mapper namespace="car"&gt;
    &lt;select id="selectAll" resultType="com.yzh.mybatis.pojo.Car"&gt;
        select id,
               car_num as carNum,
               brand,
               guide_price as guidePrice,
               produce_time as produceTime,
               car_type as carType
        from t_car;
    &lt;/select&gt;
&lt;mapper/&gt;

--------------------------------------------------------------------------

CarMapper2.xml
&lt;mapper namespace="aaaaa"&gt;
    &lt;select id="selectAll" resultType="com.yzh.mybatis.pojo.Car"&gt;
        select id,
               car_num as carNum,
               brand,
               guide_price as guidePrice,
               produce_time as produceTime,
               car_type as carType
        from t_car;
    &lt;/select&gt;
&lt;mapper/&gt;</code></pre> 
<p>很明显可以看到两个文件中有一个查询语句的id重名了，若你在还是以：</p> 
<pre><code class="language-java">List&lt;Car&gt; cars = session.selectList("selectAll");</code></pre> 
<p>这样的方式去填写id号，那么他就会报错说你这个不明确，应该这样写：</p> 
<pre><code class="language-java">List&lt;Car&gt; cars = session.selectList("car.selectAll");
-------------------------------------------------
List&lt;Car&gt; cars = session.selectList("aaaaa.selectAll");</code></pre> 
<p>就是根据namespace的名字来精准定位。</p> 
<blockquote> 
 <p>补充：mybatis中有两个主要的配置文件:其中一个是: mybatis-config.ml，这是核心配置文件，主要配置连接数据库的信息等。 (只有一个)另一个是: XxxxMapper.xml，这个文件是专门用来编写SQL语句的配置文件。 (一个表一个)t_user表，一般会对应一个UserMapper.xml</p> 
 <p>      t_student表，一般会对应一个StudentMapper.xml</p> 
</blockquote> 
<p></p> 
<p></p> 
<h2 id="%E5%9B%9B.Mybatis%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3">四.Mybatis核心配置文件详解</h2> 
<h3 id="4.1%E3%80%81mybatis-config.xml">4.1、mybatis-config.xml</h3> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
//上面这一部分没啥好说的，任何一个xml文档都是这样写的

&lt;!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;
//这一段重点看两个：
1.一般DOCTYPE后面这个名字就是我们XML根标签的名字，比如这里的
configuration，一个XML文档只有一个根标签。
2.最后这一行："http://mybatis.org/dtd/mybatis-3-config.dtd"
这是一个dtd规范约束，就是说我们这个文档根标签下的约束规范。


&lt;configuration&gt;
    &lt;environments default="powernodeDB"&gt;
        &lt;!--一个环境对应一个数据库--&gt;
        &lt;environment id="powernodeDB"&gt;
            &lt;transactionManager type="JDBC"/&gt;
            &lt;dataSource type="POOLED"&gt;
                &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt;
                &lt;property name="url" value="jdbc:mysql://localhost:3306/powernode"/&gt;
                &lt;property name="username" value="root"/&gt;
                &lt;property name="password" value=""/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource="XxxMapper.xml"/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
//根标签下的这一部分我们现在暂时只需要知道两个标签：environments、mappers、properties。

environments代表环境的意思，加了一个s代表可以配置多个环境(&lt;environment&gt;)。
比如我现在上面只配置了一个环境，这个环境的id是powernodeDB(取名随意)，
然后你在看在environments中有一个default属性指的是默认环境的意思，
value值为某个environment的id，就是某个环境的id，表示默认使用某个环境。
(一个环境对应一个数据库)。

默认环境什么意思? 
当你使用mybatis创建SqlSessionFactory对象的时候，没有指定环境的话，默认使用哪个环境
比如说我现在在增加一个环境：
-------------------------------------------------------------------------------------
 &lt;environments default="powernodeDB"&gt;
        &lt;!--这个环境对应powenode数据库--&gt;
        &lt;environment id="powernodeDB"&gt;
            &lt;transactionManager type="JDBC"/&gt;
            &lt;dataSource type="POOLED"&gt;
                &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt;
                &lt;property name="url" value="jdbc:mysql://localhost:3306/powernode"/&gt;
                &lt;property name="username" value="root"/&gt;
                &lt;property name="password" value=""/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
        
         &lt;!--这个环境对应yzhDB数据库--&gt;
         &lt;environment id="yzhDB"&gt;
            &lt;transactionManager type="JDBC"/&gt;
            &lt;dataSource type="POOLED"&gt;
                &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt;
                &lt;property name="url" value="jdbc:mysql://localhost:3306/yzhDB"/&gt;
                &lt;property name="username" value="root"/&gt;
                &lt;property name="password" value=""/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
----------------------------------------------------------------------------------
在java代码中我这样创建两个SqlSessionFactory对象是不一样的：
SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder(); 
SqlSessionFactory ssf1 = ssfb.builder("mybatis-config.xml");
SqlSessionFactory ssf2 = ssfb.builder("mybatis-config.xml","yzhDB");
ssf1对应的是默认环境powernodeDB，ssf2对应的是yzhDB这个环境。
那么他们创键出来的SqlSession对象自然而然是用来操作不同的数据库。

---------------------------------------------------------------------------




transactionManager标签
每一个环境下还有一叫transactionManager标签，翻译为事务管理器
用于设置MyBatis的事务管理器，mybatis有两种管理事务的方式
    JDBC：交给原生JDBC管理setAutoComit(false);需要手动comit()提交
    MANAGED：交给JEE处理，一般由JEE框架处理，如Spring



理解：
1.一个环境对应一个数据库;(environment ---&gt;  database)
2.一般一个数据库会对应一个SqlSessionFactory对象。（注意是一个不是一种）
3.那也就是说一个environment 对应一个SqlSessionFactory对象</code></pre> 
<pre><code class="language-XML"> &lt;environments default="powernodeDB"&gt;
        &lt;!--一个环境对应一个数据库--&gt;
        &lt;environment id="powernodeDB"&gt;
            &lt;transactionManager type="JDBC"/&gt;
            &lt;dataSource type="POOLED"&gt;
                &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt;
                &lt;property name="url" value="jdbc:mysql://localhost:3306/powernode"/&gt;
                &lt;property name="username" value="root"/&gt;
                &lt;property name="password" value=""/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
 &lt;/environments&gt;

--------------------------------------------------------

&lt;dataSource type="POOLED"&gt;
	.......
&lt;/dataSource&gt;
问：这个标签有啥用
答：dataSource表示数据源，用来获取Connection对象

它的type属性可以填写三个值：

    UNPOOLED：不使用数据库连接池，每次获取Connection都要创建一个新对象
    POOLED：使用MyBatis自带的连接池
    JNDI：连接第三方的数据源如druid、c3p0...（如果自己手写框架也可以用这个）
那么你需要知道的是：

&lt;dataSource type="POOLED"&gt;type的值不一样会，那么你
&lt;dataSource type="POOLED"&gt;
    这里里面放的标签也会有所不同，具体能放什么标签请参考mybatis配置文档
    https://mybatis.net.cn/
&lt;dataSource/&gt;

----------------------------------------------------------------------------------
这种再重点说一下type="POOLED"的时候，它的属性有哪些？
&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;
&lt;configuration&gt;
    &lt;environments default="dev"&gt;
        &lt;environment id="dev"&gt;
            &lt;transactionManager type="JDBC"/&gt;
            &lt;dataSource type="POOLED"&gt;
                &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt;
                &lt;property name="url" value="jdbc:mysql://localhost:3306/powernode"/&gt;
                &lt;property name="username" value="root"/&gt;
                &lt;property name="password" value="root"/&gt;
                &lt;!--最大连接数--&gt;
                &lt;property name="poolMaximumActiveConnections" value="3"/&gt;
                &lt;!--这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直失败且不打印日志），默认值：20000 毫秒（即 20 秒）。--&gt;
                &lt;property name="poolTimeToWait" value="20000"/&gt;
                &lt;!--强行回归池的时间--&gt;
                &lt;property name="poolMaximumCheckoutTime" value="20000"/&gt;
                &lt;!--最多空闲数量--&gt;
                &lt;property name="poolMaximumIdleConnections" value="1"/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
        &lt;mapper resource="CarMapper.xml"/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
-----------------------------------------------------------
poolMaximumActiveConnections：最大的活动的连接数量。默认值10
poolMaximumIdleConnections：最大的空闲连接数量。默认值5
poolMaximumCheckoutTime：强行回归池的时间。默认值20秒。
poolTimeToWait：当无法获取到空闲连接时，每隔20秒打印一次日志，避免因代码配置有误，导致傻等。（时长是可以配置的）
当然，还有其他属性。对于连接池来说，以上几个属性比较重要。

</code></pre> 
<pre><code class="language-XML">properties标签
这个标签想必你已经很熟悉了，就是用来引入properties配置文件的
修改一下代码：
-----------------------------------------------------------------------------
修改前：
&lt;dataSource type="POOLED"&gt;
                &lt;property name="driver" value="com.mysql.cj.jdbc.Driver"/&gt;
                &lt;property name="url" value="jdbc:mysql://localhost:3306/powernode"/&gt;
                &lt;property name="username" value="root"/&gt;
                &lt;property name="password" value=""/&gt;
 &lt;/dataSource&gt;
-----------------------------------------------------------------------------
修改后：
&lt;dataSource type="POOLED"&gt;
                &lt;property name="driver" value="${driver}"/&gt;
                &lt;property name="url" value="${url}"/&gt;
                &lt;property name="username" value="${root}"/&gt;
                &lt;property name="password" value="${password}"/&gt;
 &lt;/dataSource&gt;
-----------------------------------------------------------------------
在resources下创建一个mysqlConnection.properties文件，
并在里面写好连接数据库的配置信息
---------------------------------------------------------------
driver=com.mysql.cj.jdbc.Driver
url=jdbc:mysql://localhost:3306/powernode
username=root
password=""
--------------------------------------------------
回到mybatis核心文档(mybatis-config.xml)，在根标签&lt;configuration&gt;下

引入：配置文件即可
&lt;configuration&gt;
    &lt;properties resource="mysqlConnection.properties"&gt;&lt;/properties&gt;
&lt;/configuration&gt;

-------------------------------------------------------------
注意：在这个properties配置文件不是一定要放在resources文件下的，
你放在哪里都可以比如说我放在D:/mysqlConnection.properties
那么你在根标签的引入的方式就改为：
------------------------------------------------------------
&lt;configuration&gt;
    &lt;properties url="file:///d:/mysqlConnection.properties"&gt;&lt;/properties&gt;
&lt;/configuration&gt;
这种方式不推荐！！！
------------------------------------------------------------------
properties两个属性：
resource：这个属性从类（resources文件就是默认从类的根路径下找）
的根路径下开始加载。【常用的。】
url：从指定的url加载，假设文件放在d:/jdbc.properties，

url="file:///d:/mysqlConnection.properties"注意是三个斜杠哦。
注意：如果不知道mybatis-config.xml文件中标签的编写顺序的话，
可以有两种方式知道它的顺序：
● 第一种方式：查看dtd约束文件。
● 第二种方式：通过idea的报错提示信息。【一般采用这种方式】</code></pre> 
<p><img alt="" height="709" src="https://images2.imgbox.com/6d/7e/rI6jiToE_o.png" width="1200"></p> 
<p> <img alt="" height="244" src="https://images2.imgbox.com/75/af/X7PbwrVq_o.png" width="1200"></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="%E6%89%8B%E5%86%99mybatis%E6%A1%86%E6%9E%B6%EF%BC%9A">手写mybatis框架：</h2> 
<p><strong>前奏：解析mybatis核心XML文档、SqlMapper(Sql映射文档)</strong></p> 
<p>大概流程：引入相关需要解析XML文档的依赖。解析相关的XML文档的标签，把标签的属性，属性value、元素内容(标签内部元素，如sql语句)获取到。</p> 
<p>解析前：</p> 
<p><img alt="" height="778" src="https://images2.imgbox.com/07/28/1UjgO92i_o.png" width="993"></p> 
<p> 解析后：</p> 
<p><img alt="" height="222" src="https://images2.imgbox.com/f9/8e/BWpDaoxo_o.png" width="451"></p> 
<p> 思考：接下来我们干啥？</p> 
<p>明显从使用mybatis的角度出发任何操作都需要先获取会话对象是不是？那么获取会话对象需要三步：</p> 
<pre><code class="language-java">SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder();
        SqlSessionFactory sqlSessionFactory = 
            sqlSessionFactoryBuilder.build(Resources.getResourceAsStream("mybatis-config.xml"));
        SqlSession session = sqlSessionFactory.openSession();</code></pre> 
<p>1.创建Resources对象</p> 
<p><img alt="" height="572" src="https://images2.imgbox.com/a5/ed/kcMVEb69_o.png" width="946"></p> 
<p>2.</p> 
<p><img alt="" height="680" src="https://images2.imgbox.com/de/5d/kJpS6f3R_o.png" width="922"></p> 
<p>3.</p> 
<p><img alt="" height="596" src="https://images2.imgbox.com/38/0f/N2lZ5aKQ_o.png" width="890"></p> 
<p> 至此,由SqlSessionFactory和SqlSessionFactoryBuilder引出了一些列的封装类，因为这两个类需要解析mybatis核心文档，解析完后的数据需要封装到不同的类中，然后提供给这两个类去服务。</p> 
<p><img alt="" height="568" src="https://images2.imgbox.com/85/a6/MUsi74qs_o.png" width="832"></p> 
<p><img alt="" height="254" src="https://images2.imgbox.com/df/17/M4tvka8x_o.png" width="229"></p> 
<p> 定义了一个事务接口，用于灵活切换<img alt="" height="45" src="https://images2.imgbox.com/db/bf/G5xUx5l1_o.png" width="431"></p> 
<p> 中的Type，然后定义了三个不同的事务管理器实现类。</p> 
<p>定义了三个数据源实现类，用于灵活切换</p> 
<p><img alt="" height="29" src="https://images2.imgbox.com/11/15/OQ3ejOAM_o.png" width="353"></p> 
<p>中的type ，这里不需要在定义数据源的接口，因为不管你啥数据源必须得实现JDK的DataSource接口。</p> 
<p>定义了一个MapperStatement类，封装XxxMapper.XML中的SQL映射实体类，比如：</p> 
<pre><code class="language-XML">    &lt;select id="selectAll" resultType="com.yzh.mybatis.pojo.Car"&gt;
            sql语句
    &lt;/select&gt;</code></pre> 
<p>那么现在来看：一个SqlSessionFactory对象里面包含：</p> 
<pre><code class="language-XML">&lt;environment id="development"&gt;
            &lt;transactionManager type="JDBC"/&gt;
            &lt;dataSource type="POOLED"&gt;
                &lt;property name="driver" value="${driver}"/&gt;
                &lt;property name="url" value="${url}"/&gt;
                &lt;property name="username" value="${root}"/&gt;
                &lt;property name="password" value="${password}"/&gt;
            &lt;/dataSource&gt;
&lt;/environment&gt;


environment&gt;transactionManager&gt;dataSource&gt;

Map&lt;sql的id, MapperStatement对象&gt;;

MapperStatement对象封装了XxxMapper.XML中的一个sql执行语句标签的内容：
比如：
    &lt;select id="selectAll" resultType="com.yzh.mybatis.pojo.Car"&gt;
            sql语句
    &lt;/select&gt;
封装了有：
    private String sqlId;
    private String resultType;
    private String sql;
    private String parameterType;

</code></pre> 
<p>相关知识点：</p> 
<pre><code class="language-XML">ClassLoader.getSystemClassLoader().getResourceAsStream("从类路径开始找");
这个方法是java.long包下面的一个方法，返回一个输入流InputStream，
mybatis底层在解读resources目录下的文档,比如：
sqlSessionFactoryBuilder.build(Resources.getResourceAsReader("mybatis-config.xml"));
中的Resources.getResourceAsReader("mybatis-config.xml")，底层也是用的这个方法。

所以其实：Resources.getResourceAsReader("mybatis-config.xml")换成

 ClassLoader.getSystemClassLoader().getResourceAsStream("mybatis-config.xml");   
是一样的</code></pre> 
<pre>编不下去了...............自己回去看吧
</pre> 
<p></p> 
<p></p> 
<h2 id="javassist%E7%9A%84%E4%BD%BF%E7%94%A8">javassist的使用</h2> 
<p>它的作用是动态生成类</p> 
<pre><code class="language-XML">       &lt;!--引入javassist依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.javassist&lt;/groupId&gt;
            &lt;artifactId&gt;javassist&lt;/artifactId&gt;
            &lt;version&gt;3.29.1-GA&lt;/version&gt;
        &lt;/dependency&gt;</code></pre> 
<pre><code class="language-java">/**
 * 使用javassist动态生成一个类
 */
public class JavassistTest {
    @Test
    public void testGenerateFirstClass() throws CannotCompileException, ClassNotFoundException, InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException {
        //获取类池(get类池返回一个类池)
        ClassPool classPool = ClassPool.getDefault();
        //制造类(需要告诉javassist，类名是啥)
        CtClass ctClass = classPool.makeClass("com.yzh.bank.dao.impl.AccountDaoImpl");
        //至此在若代码执行到这里：会动态的在com.yzh.bank.dao.impl下创建AccountDaoImpl类

        //为AccountDaoImpl类动态创建一个方法
        //制造方法  methodCode：翻译为方法代码
        //要制造得先创造
        String methodCode = "public void insert(){System.out.print(123);}";
        //然后再把创造的方法指定给ctClass
        CtMethod ctMethod = CtMethod.make(methodCode,ctClass);
        //把这个方法添加到ctClass
        ctClass.addMethod(ctMethod);
        //在内存中生成这个类
        ctClass.toClass();
        //上面这一步可以直接返回Class&lt;?&gt; clazz，就可以省去下面这一步了

        //把这个类加载到JVM中，返回AccountImpl类的字节码文件
        Class&lt;?&gt; clazz = Class.forName("com.yzh.bank.dao.impl.AccountDaoImpl");
        //创建AccountDaoImpl对象
        Object object = clazz.newInstance();
        //获取AccountDaoImpl对象的insert方法
        Method insert = clazz.getDeclaredMethod("insert");
        //调用方法insert
        insert.invoke(object);
    }
}</code></pre> 
<p></p> 
<pre><code class="language-java">/**
 * 使用javassist动态生成一个类,并且这个类要去实现一个接口
 * 以AccountDaoImpl类和AccountDao接口为例
 */

//首先在com.yzh.javassist下创建好一个接口
public interface AccountDao {
    void update();
}





public class JavassistTest2 {
    @Test
    public void TestJavassist() throws CannotCompileException, InstantiationException, IllegalAccessException {
        //获取类池
        ClassPool pool = ClassPool.getDefault();
        //制造接口(注意这个接口不是真正的在jvm中去实现,你可以想象成他javassist中实现)，
        //其目的是为了在javassist中提供给它的实现类去实现用的，最后在JVM中生成实现类
        //的时候在com.yzh.javassist路径下是必须要真正存在一个AccountDao接口
        //接口的。也就是说这个接口得你自己提前准备好
        CtClass ctInterface = pool.makeInterface("com.yzh.javassist.AccountDao");
        //制造类
        CtClass ctClass = pool.makeClass("com.yzh.javassist.AccountDaoImpl");
        //类实现接口
        ctClass.addInterface(ctInterface);//相当于AccountDaoImpl implement AccountDao
        //在实现类中重写接口的方法
        //制造方法(注意实现接口后你得往这个类中添加一个重写接口的方法，比如这个delete()就是
        // 重写接口中的delete())
        String method = "public void update(){System.out.print(\"Hello Javassist\");}";
        CtMethod ctMethod = CtMethod.make(method,ctClass);
        //将方法添加到这个类中
        ctClass.addMethod(ctMethod);

        //在内存中生成这个类，并在加载JVM中
        Class&lt;?&gt; aClass = ctClass.toClass();
        //通过反射创建对象并且强转，因为我已经知道他实现了AccountDao接口
        AccountDao accountDao = (AccountDao)aClass.newInstance();
        accountDao.update();
    }
}</code></pre> 
<p></p> 
<p></p> 
<pre><code class="language-java">/**
 * 使用javassist动态生成一个类,并且这个类要去实现一个接口
 * 以AccountDaoImpl类和AccountDao接口为例
 */

//首先在com.yzh.javassist下创建好一个接口
public interface AccountDao {
    void update();
}





public class JavassistTest2 {
    @Test
    public void TestJavassist() throws CannotCompileException, InstantiationException, IllegalAccessException {
        //获取类池
        ClassPool pool = ClassPool.getDefault();
        //制造接口(注意这个接口不是真正的在jvm中去实现,你可以想象成他javassist中实现)，
        //其目的是为了在javassist中提供给它的实现类去实现用的，最后在JVM中生成实现类
        //的时候在com.yzh.javassist路径下是必须要真正存在一个AccountDao接口
        //接口的。也就是说这个接口得你自己提前准备好
        CtClass ctInterface = pool.makeInterface("com.yzh.javassist.AccountDao");
        //制造类
        CtClass ctClass = pool.makeClass("com.yzh.javassist.AccountDaoImpl");
        //类实现接口
        ctClass.addInterface(ctInterface);//相当于AccountDaoImpl implement AccountDao
        //在实现类中重写接口的方法
        //制造方法(注意实现接口后你得往这个类中添加一个重写接口的方法，比如这个delete()就是
        // 重写接口中的delete())
        String method = "public void update(){System.out.print(\"Hello Javassist\");}";
        CtMethod ctMethod = CtMethod.make(method,ctClass);
        //将方法添加到这个类中
        ctClass.addMethod(ctMethod);

        //在内存中生成这个类，并在加载JVM中
        Class&lt;?&gt; aClass = ctClass.toClass();
        //通过反射创建对象并且强转，因为我已经知道他实现了AccountDao接口
        AccountDao accountDao = (AccountDao)aClass.newInstance();
        accountDao.update();
    }
}</code></pre> 
<pre><code class="language-java">package com.powernode.bank.utils;

import org.apache.ibatis.javassist.CannotCompileException;
import org.apache.ibatis.javassist.ClassPool;
import org.apache.ibatis.javassist.CtClass;
import org.apache.ibatis.javassist.CtMethod;
import org.apache.ibatis.session.SqlSession;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;

/**
 * 使用javassist库动态生成dao接口的实现类
动态实现创建AccountDao接口的实现类，并且返回这个实现类的实例化对象
 */
public class GenerateDaoByJavassist {

    /**
     * 根据dao接口生成dao接口的代理对象
     *
     * @param sqlSession   sql会话
     * @param daoInterface dao接口
     * @return dao接口代理对象
     */
    public static Object getMapper(SqlSession sqlSession, Class daoInterface) {
        ClassPool pool = ClassPool.getDefault();
        // 生成代理类
        CtClass ctClass = pool.makeClass(daoInterface.getPackageName() + ".impl." + daoInterface.getSimpleName() + "Impl");
        // 接口
        CtClass ctInterface = pool.makeClass(daoInterface.getName());
        // 代理类实现接口
        ctClass.addInterface(ctInterface);
        // 获取所有的方法
        Method[] methods = daoInterface.getDeclaredMethods();
        Arrays.stream(methods).forEach(method -&gt; {
            // 拼接方法的签名
            StringBuilder methodStr = new StringBuilder();
            String returnTypeName = method.getReturnType().getName();
            methodStr.append(returnTypeName);
            methodStr.append(" ");
            String methodName = method.getName();
            methodStr.append(methodName);
            methodStr.append("(");
            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();
            for (int i = 0; i &lt; parameterTypes.length; i++) {
                methodStr.append(parameterTypes[i].getName());
                methodStr.append(" arg");
                methodStr.append(i);
                if (i != parameterTypes.length - 1) {
                    methodStr.append(",");
                }
            }
            methodStr.append("){");
            // 方法体当中的代码怎么写？
            // 获取sqlId（这里非常重要：因为这行代码导致以后namespace必须是接口的全限定接口名，sqlId必须是接口中方法的方法名。）
            String sqlId = daoInterface.getName() + "." + methodName;
            // 获取SqlCommondType
            String sqlCommondTypeName = sqlSession.getConfiguration().getMappedStatement(sqlId).getSqlCommandType().name();
            if ("SELECT".equals(sqlCommondTypeName)) {
                methodStr.append("org.apache.ibatis.session.SqlSession sqlSession = com.powernode.bank.utils.SqlSessionUtil.openSession();");
                methodStr.append("Object obj = sqlSession.selectOne(\"" + sqlId + "\", arg0);");
                methodStr.append("return (" + returnTypeName + ")obj;");
            } else if ("UPDATE".equals(sqlCommondTypeName)) {
                methodStr.append("org.apache.ibatis.session.SqlSession sqlSession = com.powernode.bank.utils.SqlSessionUtil.openSession();");
                methodStr.append("int count = sqlSession.update(\"" + sqlId + "\", arg0);");
                methodStr.append("return count;");
            }
            methodStr.append("}");
            System.out.println(methodStr);
            try {
                // 创建CtMethod对象
                CtMethod ctMethod = CtMethod.make(methodStr.toString(), ctClass);
                ctMethod.setModifiers(Modifier.PUBLIC);
                // 将方法添加到类
                ctClass.addMethod(ctMethod);
            } catch (CannotCompileException e) {
                throw new RuntimeException(e);
            }
        });
        try {
            // 创建代理对象
            Class&lt;?&gt; aClass = ctClass.toClass();
            Constructor&lt;?&gt; defaultCon = aClass.getDeclaredConstructor();
            Object o = defaultCon.newInstance();
            return o;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}</code></pre> 
<p></p> 
<p></p> 
<h2 id="%E4%BD%BF%E7%94%A8%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%8C%E6%88%90CRUD">使用动态代理完成CRUD</h2> 
<pre><code class="language-java">定义接口
public interface CarMapper {//CarDao
    /**
     * 新增car
     * @param car
     * @return
     */
    int insert(Car car);

    /**
     * 根据id删除car
     * @param id
     * @return
     */
    int deleteById(Long id);

    /**
     * 改
     * @param car
     * @return
     */
    int update(Car car);

    /**
     * 根据id查询一条car
     * @param id
     * @return
     */
    Car selectById(Long id);

    /**
     * 获取所有car
     * @return
     */
    List&lt;Car&gt; selectAll();



}
</code></pre> 
<pre><code class="language-XML">定义CarMapper.XML映射文档
&lt;!--(id,car_num,brand,guide_price,produce_time,car_type)--&gt;
&lt;!--下面这个namespace名字必须是接口的全类名--&gt;
&lt;mapper namespace="com.yzh.mybatis.mapper.CarMapper"&gt;
    &lt;!--下面这些id的值必须要填接口中的方法名--&gt;
    &lt;insert id="insert"&gt;
    &lt;!--insert语句中的大括号里面必须要填的是属性名字 --&gt;
        insert into t_car values(null,#{carNum},#{brand},#{guidePrice},#{produceTime},#{carType})
    &lt;/insert&gt;
    &lt;delete id="deleteById"&gt;
        delete from t_car where id=#{id}
    &lt;/delete&gt;
    &lt;update id="update"&gt;
        update t_car set
        car_num=#{carNum},brand=#{brand},guide_price=#{guidePrice},produce_time=#{produceTime},car_type=#{carType}
        where id=#{id}
    &lt;/update&gt;
    &lt;!--查询语句中的查询字段必须为数据库中的字段
    若数据库的字段与封装类的属性名不一致需要修改别名
    否则无法给你封装到那个pojo类对象中，封装过后的属性值为null--&gt;
    &lt;select id="selectById" resultType="com.yzh.mybatis.pojo.Car"&gt;
        select
                id,
                car_num as carNum,
                brand,
                guide_price as guidePrice,
                produce_time as produceTime,
                car_type as carType
        from t_car where id=#{id}
    &lt;/select&gt;


    &lt;select id="selectAll" resultType="com.yzh.mybatis.pojo.Car"&gt;
        select
            id,
            car_num as carNum,
            brand,
            guide_price as guidePrice,
            produce_time as produceTime,
            car_type as carType
        from t_car
    &lt;/select&gt;
&lt;/mapper&gt;</code></pre> 
<pre><code class="language-java">定义测试类
public class CarMapperTest {
    @Test
    public void testInsert(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        //面向接口获取动态代理，他底层其实会生成一个CarMapper的实现类
        CarMapper mapper = sqlSession.getMapper(CarMapper.class);
        Car car = new Car(null,"1002","86",23.3,"2018-7-12","燃油车");
        int count = mapper.insert(car);
        sqlSession.commit();
        System.out.println(count);
    }
    @Test
    public void testDelete(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        CarMapper mapper = sqlSession.getMapper(CarMapper.class);
        int count = mapper.deleteById(15L);
        sqlSession.commit();
        System.out.println(count);
    }
    @Test
    public void testUpdate(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        CarMapper mapper = sqlSession.getMapper(CarMapper.class);
        Car car = new Car(14L,"1002","丰田凯美瑞",23.3,"2018-7-12","燃油车");
        int count = mapper.update(car);
        sqlSession.commit();
        System.out.println(count);
    }
    @Test
    public void testSelectById(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        CarMapper mapper = sqlSession.getMapper(CarMapper.class);
        Car car = mapper.selectById(6L);
        System.out.println(car);
    }
    @Test
    public void testSelectAll(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        CarMapper mapper = sqlSession.getMapper(CarMapper.class);
        List&lt;Car&gt; cars = mapper.selectAll();
        cars.forEach(car -&gt; System.out.println(car));
    }
}</code></pre> 
<p></p> 
<p>重点：</p> 
<p>1.要想使用动态代理机制创建接口对象——GeneratDaoProxy</p> 
<p>CarMapper.XML文档中的namespace和每条映射语句的id必须必须必须要按照mybatis的规范来指定，否则他无法为你生成动态代理对象(接口对象)。</p> 
<blockquote> 
 <p>规范：</p> 
 <p>namespace名字必须是接口的全类名。</p> 
 <p>id的值必须要对应接口中的方法名。</p> 
</blockquote> 
<p>第二：</p> 
<pre><code class="language-XML">CarMapper mapper = sqlSession.getMapper(CarMapper.class);
底层做了两件事：
1.生成CarMapper.class字节码文件
2.根据CarMapper.class字节码文件实例化了一个对象并且返回
也就是现在这个mapper变量在引用。
说白了其实就是因为你在编写mysql映射文档的时候遵循了mybatis提供的
GeneratDaoProxy动态代理机制。然后你就可以拿sqlsession对象去直接获取
CarMapper这个接口的实现类对象，你调用这个sqlSession.getMapper他就给你生成
并且返回这个对象
前提是：遵循mybatis规定的mysql映射文件编写：(namespace、id)</code></pre> 
<p></p> 
<p></p> 
<h2 id="Mybatis%E5%B0%8F%E6%8A%80%E5%B7%A7">Mybatis小技巧</h2> 
<h3 id="1.%23%7B%7D%E5%92%8C%24%7B%7D%E7%9A%84%E5%8C%BA%E5%88%AB">1.#{}和${}的区别</h3> 
<p>#{}:底层使用Preparedstatement。特点: 先进行SQL语句的编译，然后给SQL语句的占位符问号?传值。可以避免SOL注入的风险<br> ${}: 底层使用Statement。特点: 先进行SQL语句的拼接，然后再对SQL语句进行编译。存在SQL注入的风险。</p> 
<p></p> 
<h3 id="2.%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8%24%7B%7D">2.什么时候需要使用${}</h3> 
<p>注：优先使用#{}，这是原则，可以避免sql注入风险。如果需要SQL语句的关键字放到SQL语句中，只能使用${}，因为#{} 是以值的形式放到SQL语句当中的,比如我要给一个占位符赋值，这个占位符需要和sql进行拼接，比如select * from table order by ?;</p> 
<p>我要对上面这个占位符进行传值(asc 或者 desc) ，这个占位符后面赋值后会作为sql语句的与部分来使用而不是单纯的参数。因为你传过来的肯定是以字符串的形式传asc或者desc。若此时再使用</p> 
<p>#{}最后拼成的德行长这样：select * from table order by 'asc';</p> 
<p>${}拼成：select * from table order by asc;</p> 
<p>很明显下面这个才对。</p> 
<p><img alt="" height="464" src="https://images2.imgbox.com/3a/95/qHXaRX72_o.png" width="1200"></p> 
<p>总结：这个#{}虽说可以解决sql注入问题但是无法进行sql拼接，所以这个${}还有有用的而且很有用可以解决很多sql优化问题，自己私底下用到在研究吧。总之你现在要知道的就是。</p> 
<p><strong><span style="color:#fe2c24;">以下应用场景你需要考虑使用${}</span></strong></p> 
<p><strong>拼接表名、批量删除、模糊查询。这里不详细展示咋用了，自己去看视频吧</strong></p> 
<p></p> 
<h3 id="3.%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B9%8B%E5%88%AB%E5%90%8D%E6%9C%BA%E5%88%B6%3CtypeAliases%3E">3.小技巧之别名机制&lt;typeAliases&gt;</h3> 
<p>这个别名机制是关于mysql映射文件中对e于select标签中的resultType来说的，比如说：</p> 
<pre><code class="language-XML">    &lt;select id="selectAll" resultType="com.yzh.mybatis.pojo.Car"&gt;
    &lt;/select&gt;</code></pre> 
<p>你不觉得这个resultType每次都要写这么长的全类名很麻烦吗，于是mybatis就有了这种别名机制，</p> 
<p>在mybatis核心配置文件中mybatis-config.xml里面配置别名，</p> 
<pre><code>别名方式1：通过包取默认别名
&lt;typeAliases&gt;
            &lt;package name="com.yzh.mybatis.pojo"/&gt;
&lt;/typeAliases&gt;
//直接把resultType="com.yzh.mybatis.pojo.Car"中的包名放进package
//那么他会自动把这个包下面的全部类都取一个默认的别名，这个别名就是
//简名，比如com.yzh.mybatis.pojo.Car取别名为Car
细节：这个默认别名是不区分大小写的，Car、car、CaR...都可以只要是这三个字母即可

配置完后回到CarMapper.xml
 &lt;select id="selectAll" resultType="Car"&gt;
 &lt;/select&gt;
修改即可


------------------------------------------------------------------------------
别名方式2：指定别名
&lt;typeAliases&gt;
          &lt;typeAlias type="com.yzh.mybatis.pojo.Car" alias="hhh"/&gt;
&lt;/typeAliases&gt;
配置完后回到CarMapper.xml
 &lt;select id="selectAll" resultType="hhh"&gt;
 &lt;/select&gt;
修改即可
细节：hhh不区分大小写，在这里也可以把 alias="hhh"省略，他会自动取简名Car(不区分大小写)
为默认名
--------------------------------------------------------------------------
</code></pre> 
<p>总结：无论哪种方式对resultType取别名都不区分大小写。另外在sql映射文档中的namespace不可以去别名：&lt;mapper namespace="com.yzh.mybatis.mapper.CarMapper"&gt; 不可取别名</p> 
<p></p> 
<h3 id="4.%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B9%8Bsql%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6%E5%9C%A8mybatis-config.xml%E9%85%8D%E7%BD%AE%E8%B7%AF%E5%BE%84">4.小技巧之sql映射文件在mybatis-config.xml配置路径</h3> 
<pre><code class="language-XML">//方式一:
&lt;configuration&gt; 
    &lt;mappers&gt;
        &lt;mapper resource="SqlMapper.xml"/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;

这种方式mybatis会直接在类的根路径下开始查找SqlMapper.xml，
类：这个类指的是你在SqlMapper.xml中配置的
           &lt;mapper namespace="com.yzh.mybatis.mapper.SqlMapper"&gt;
           中的com.yzh.mybatis.mapper.SqlMapper这个类。
类的根路径下：指的就是全类名com.yzh.mybatis.mapper.CarMapper的上级目录

你可以直接把SqlMapper.xml放在com的上级目录下，注意是目录下，
也就是放在那个蓝色的java文件夹下。
也可以放在resources包下(一般放在这里)，
因为在mybatis框架中规定了直接放在resources包下就相当于放
在类的根路径下也就是那个蓝色的java文件夹。
</code></pre> 
<pre><code class="language-XML">//方式二：
&lt;mappers&gt;
  &lt;mapper url="file:///d:/mappers/SqlMapper.xml"/&gt;
&lt;/mappers&gt;
这种方式就是单纯的绝对路径，爱放哪放哪。
不推荐这种方式太死板，移植性差，比如换了mac操作系统后是没有D盘</code></pre> 
<pre><code class="language-XML">//方式三：
    &lt;mappers&gt;
       &lt;mapper class="com.yzh.mybatis.mapper.CarMapper"/&gt;
    &lt;/mappers&gt;

这种方式你的SqlMapper.XML需要和com.yzh.mybatis.mapper.CarMapper这个类放在
同一个目录下也就是必须放在com.yzh.mybatis.mapper下，但是resources文件夹匹配的是
类的根路径也就是那个java文件夹。所以此时你需要在resources文件夹中添加
com/yzh/mybatis/mapper这样一层文件夹并把SqlMapper.XML这个文件夹放到
com/yzh/mybatis/mapper中</code></pre> 
<p> 如何在resources文件下创建文件夹？</p> 
<p>右击resource文件选择</p> 
<p><img alt="" height="178" src="https://images2.imgbox.com/02/42/gduYD8ya_o.png" width="730"></p> 
<p> 然后注意里面填的是：com/yzh/mybatis/mapper。不要填com.yzh.mybatis.mapper</p> 
<p><img alt="" height="67" src="https://images2.imgbox.com/66/c5/2cfaUWim_o.png" width="415"></p> 
<p>然后把映射文档放进去</p> 
<p><img alt="" height="55" src="https://images2.imgbox.com/41/af/8ZRrQAWt_o.png" width="291"></p> 
<p>此时你会发现你在target文件中是这样的，你这个CarMapper接口(类)是和CarMapper.XML放在一起的，这个才是放在计算机中的样子。</p> 
<p><img alt="" height="429" src="https://images2.imgbox.com/d5/68/y5H0ZfEs_o.png" width="424"></p> 
<p></p> 
<pre><code class="language-XML">方式四：最推荐写法
</code></pre> 
<p>需要搭配第三种方式的配置：如下图</p> 
<p><img alt="" height="613" src="https://images2.imgbox.com/69/ee/XEbHk8AF_o.png" width="893"></p> 
<pre><code class="language-XML">    &lt;mappers&gt;
        &lt;package name="com.yzh.mybatis.mapper"/&gt;
    &lt;/mappers&gt;
直接把Sql映射文件中的&lt;mapper namespace="com.yzh.mybatis.mapper.CarMapper"&gt;
com.yzh.mybatis.mapper.CarMapper去掉CarMapper只留下包名
他会匹配这个包下的所有SqlMapper.XML
这是开发中最常用的方式</code></pre> 
<p><img alt="" height="167" src="https://images2.imgbox.com/76/ff/80WTkzZu_o.png" width="605"></p> 
<p> 因为在这个resources文件下不存在创建包的说法，只能创建文件夹，如果你com.yzh.zz.aaa.bb这样创建文件那么他com.yzh.zz.aaa.bb都属于同一级目录。还有一种方式就是你一层一层文件夹建立那保准没问题。</p> 
<p>建立好的文件夹可以右击resources&gt;Open In&gt;Explorer查看在计算机打开resources文件夹这样就一清二楚看到你是否创建正确了</p> 
<p><img alt="" height="695" src="https://images2.imgbox.com/08/4a/CcGyAv2J_o.png" width="876"></p> 
<p>SqlMapper.xml需要放到</p> 
<p><img alt="" height="59" src="https://images2.imgbox.com/f9/11/p0OluVp0_o.png" width="282"></p> 
<p></p> 
<p></p> 
<h3 id="5.%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B9%8B%E5%9C%A8idea%E9%85%8D%E7%BD%AEmybatis%E6%A0%B8%E5%BF%83%E6%96%87%E6%A1%A3%E5%92%8CSql%E6%98%A0%E5%B0%84%E6%96%87%E6%A1%A3">5.小技巧之在idea配置mybatis核心文档和Sql映射文档</h3> 
<p>File &gt;Settings &gt; Editor &gt; File and Code Templates</p> 
<p><img alt="" height="977" src="https://images2.imgbox.com/06/1a/TBuqz4Yl_o.png" width="1200"></p> 
<p><span style="color:#fe2c24;"><strong> 核心配置文档</strong></span><img alt="" height="929" src="https://images2.imgbox.com/35/fa/lPQj1xJy_o.png" width="1200"></p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;
&lt;configuration&gt;
     &lt;!--jdbc连接配置--&gt;
    &lt;properties resource=""&gt;&lt;/properties&gt;
    &lt;!--响应类型的别名--&gt;
    &lt;typeAliases&gt;
        &lt;!--通过包设定默认别名--&gt;
        &lt;package name=""/&gt;
    &lt;/typeAliases&gt;

    &lt;environments default="dev"&gt;
        &lt;environment id="dev"&gt;
            &lt;transactionManager type="JDBC"/&gt;
            &lt;dataSource type="POOLED"&gt;
            &lt;!--下面的value要自己写上--&gt;
                &lt;property name="driver" value="${driver}"/&gt;
                &lt;property name="url" value="${url}"/&gt;
                &lt;property name="username" value="${root}"/&gt;
                &lt;property name="password" value="${password}"/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;
    &lt;mappers&gt;
    &lt;!--通过包名绑定sqlMapper映射文档--&gt;
        &lt;package name=""/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;</code></pre> 
<p><span style="color:#fe2c24;"><strong> sql映射文档</strong></span></p> 
<p><img alt="" height="928" src="https://images2.imgbox.com/bb/0a/XNyN8kMM_o.png" width="1200"></p> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;
&lt;mapper namespace=""&gt;
&lt;/mapper&gt;</code></pre> 
<p></p> 
<h3 id="6.%E5%B0%8F%E6%8A%80%E5%B7%A7%E4%B9%8B%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE%E6%97%B6%E8%BF%94%E5%9B%9E%E8%87%AA%E5%A2%9E%E4%B8%BB%E9%94%AE">6.小技巧之插入数据时返回自增主键</h3> 
<p>我们在设计数据表的时候很多时候是会把设计一个自增不为空的主键的，它与业务逻辑无关，所以一般在插入数据时这个id我们会传一个null。那么怎么才能让我们在插入数据的可以拿到自增主键呢？</p> 
<pre><code class="language-java">//接口中编写方法
public interface CarMapper {//CarDao

    /**
     * 新增一条car并使用自动生成的自增主键
     */
    int insertCarUseGeneratedKeys(Car car);
    
}</code></pre> 
<pre><code class="language-XML">//sql映射文件编写
//useGeneratedKeys="true"表示需要使用自动生成的主键
//keyProperty="id"表示用pojo类Car这个类的id属性去接收
//因为你在调用insertCarUseGeneratedKey方法时会传入一个Car对象
//所以这个id会存到你穿的那个Car对象的id属性中
    &lt;insert id="insertCarUseGeneratedKeys" useGeneratedKeys="true" keyProperty="id"&gt;
        insert into t_car values
        (null,#{carNum},#{brand},#{guidePrice},#{produceTime},#{carType})
    &lt;/insert&gt;</code></pre> 
<pre><code class="language-java">    @Test
    public void testInsertCarUseGeneratedKeys(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        CarMapper mapper = sqlSession.getMapper(CarMapper.class);
        Car car = new Car(null,"1002","86",23.3,"2018-7-12","燃油车");
        mapper.insertCarUseGeneratedKeys(car);
        System.out.println(car.getId());//可以拿到自增主键id
        sqlSession.commit();
        sqlSession.close();
    }</code></pre> 
<p></p> 
<p></p> 
<h2 id="Mybatis%E7%9A%84%E5%8F%82%E6%95%B0%E5%A4%84%E7%90%86(mybatis%E6%A0%B8%E5%BF%83)">Mybatis的参数处理(mybatis核心)</h2> 
<p>参数指的是Mapper接口中的方法参数，如下图：</p> 
<p><img alt="" height="568" src="https://images2.imgbox.com/d1/df/19blFwQC_o.png" width="630"></p> 
<p>这里面的方法形参可以设置不同的形参，有简单类型参数(基本数据类型+包装类+字符串+...)、Map集合、实体类、多参数....</p> 
<h3 id="%E5%8D%95%E4%B8%AA%E7%AE%80%E5%8D%95%E5%8F%82%E6%95%B0%E7%B1%BB%E5%9E%8B">单个简单参数类型</h3> 
<p><img alt="" height="348" src="https://images2.imgbox.com/be/02/L8VTCfLd_o.png" width="703"></p> 
<p></p> 
<pre><code class="language-XML">   &lt;select id="selectById" resultType="student" parameterType="java.lang.Long"&gt;
        select * from t_student where id = #{id}
    &lt;/select&gt;

//parameterType="java.lang.Long"用来指定参数的类型

//底层会翻译成：select * from t_student where id = ?
然后通过ps.setXxxx(第几个问号，实参)这样去赋值，那么
他怎么判断这个setXxx到底是set什么类型的？
mysbatis框架会根据你的传的实参即#{id}去判断set什么类型。
所以大部分情况下这个parameterType=""是不用写的，他会自动推断
但是如果写了效率会更高。
其次mybatis框架内置了很多常用的别名，可以参考手册
比如这里的java.lang.Long可以写成_long、long、Long
基本数据类、包装类都内置了别名，这写别名都是就是简名和者_简名(都不区分大小写)
_简名这个是用来区别基本数据类型的</code></pre> 
<p>在看下面这段代码</p> 
<p><img alt="" height="111" src="https://images2.imgbox.com/6e/92/6FD2ntUr_o.png" width="943"></p> 
<p>很明显多了两个参数在#{}，javaType和jdbcType都是用来做指定类型的。但是我们可以省略不写</p> 
<p>因为mybatis可以自动推断，只不过写了效率会更高。</p> 
<p>总结：单个简单参数这一小节说这些就是要你知道：其中sql语句中的javaType，jdbcType，以及select标签中的parameterType属性，都是用来帮助mybatis进行类型确定的。不过这些配置多数是可以省略的。因为mybatis它有强大的自动类型推断机制。</p> 
<p id="uf7177a5c"><span style="color:#fe2c24;"><strong>如果参数只有一个的话，#{} 里面的内容就随便写了。对于 ${} 来说，注意加单引号。</strong></span></p> 
<p></p> 
<h3 id="%E5%8F%82%E6%95%B0%E4%B8%BAMap">参数为Map</h3> 
<pre><code class="language-java">    /**StudentMapper接口编写
     * 使用map集合完成insert
     */
    int insertStudentByMap(Map&lt;String,Object&gt; map);</code></pre> 
<pre><code class="language-java">&lt;!--SqlMapper.xml编写--&gt;
&lt;mapper namespace="com.yzh.mybatis.mapper.StudentMapper"&gt;

   &lt;!--参数为map的insert--&gt;
    &lt;insert id="insertStudentByMap" &gt;
        insert into
            t_student(id,name,age,height,birth,sex)
            values(null,#{姓名},#{年龄},#{身高},#{生日},#{性别})
    &lt;/insert&gt;
&lt;/mapper&gt;

//注意点：
1.#{这里面填的是map集合的key}
2.如果要使用${},记得加双引号——"${姓名}"
3.上面省略了parameterType="java.util.Map"</code></pre> 
<pre><code class="language-java">    @Test
    public void testInsertStudentByMap(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();
        map.put("姓名","Kobe");
        map.put("年龄",20);
        map.put("身高",181);
        map.put("生日",new Date());
        map.put("性别","男");
        mapper.insertStudentByMap(map);
        sqlSession.commit();
        sqlSession.close();

    }</code></pre> 
<p>总结：你可能会觉得这个map很别扭，不应该key对应一个pojo对象吗？</p> 
<p>对的，确实有点别扭。但是如果你要用map你就必须得这样写，因为若果你要是用map作为参数，那么在sqlMapper的sql语句中#{}或${}占位符的大括号里面就必须得传map的key。</p> 
<p>还有一个实体类的我就不演示了。</p> 
<p></p> 
<h3 id="%E5%8D%95%E4%B8%AA%E5%8F%82%E6%95%B0%E6%80%BB%E7%BB%93">单个参数总结</h3> 
<p>单个参数无非就是单个简单参数、单个Map集合、单个实体类。</p> 
<p>单个简单参数：#{} 或 ${}  大括号里面填啥随意。</p> 
<p>单个Map集合参数：#{} 或 ${}  大括号里面必须填map的key。</p> 
<p>单个实体类参数：#{} 或 ${}  大括号里面必须填实体类的属性名。</p> 
<p></p> 
<p></p> 
<h3 id="%E5%A4%9A%E5%8F%82%E6%95%B0">多参数</h3> 
<pre><code class="language-java">    /**编写Mapper接口
     * 根据name和age查询student
     */
    List&lt;Student&gt; selectStudentByNameAndAge(String name,Integer age);</code></pre> 
<p> 思考：在单个参数的时候，他可以直接根据你的参数来去判断ps.setXxxx的Xxx类型然后去给？占位符赋值，那多个参数mybatis的底层是怎么做的？</p> 
<blockquote> 
 <p><span style="color:#fe2c24;">如果是多个参数的情况下mybatis底层是这样做的：</span></p> 
 <p><span style="color:#0d0016;">创建一个Map集合，这个Map集合长这样</span></p> 
 <p><span style="color:#0d0016;">Map.put(arg0，name);</span></p> 
 <p><span style="color:#0d0016;">Map.put(arg1，age);</span></p> 
 <p><span style="color:#0d0016;">Map.put(arg2，参数名);</span></p> 
 <p>...</p> 
 <p><span style="color:#0d0016;">Map.put(param1,name);</span></p> 
 <p><span style="color:#0d0016;">Map.put(param2,age);</span></p> 
 <p><span style="color:#0d0016;">Map.put(param3,参数名);</span></p> 
 <p><span style="color:#0d0016;">.......</span></p> 
 <p><span style="color:#fe2c24;"><strong>注意：</strong></span><span style="color:#0d0016;">以上不是两个集合，以上内容都是在同一个Map下的。别搞错了</span>，说白了就是他在一个Map集合中key存了以0开始的参数下标，也存了以1开始的参数下表，他们的对应的value</p> 
 <p>都是参数名。</p> 只不过这个下标前面会带arg和param开头。 
</blockquote> 
<pre><code class="language-XML"> &lt;!--编写SqlMapper.xml--&gt;   
&lt;select id="selectStudentByNameAndAge" resultType="student"&gt;
        select * from t_student
            where name=#{arg0} and age=#{arg1}
 &lt;/select&gt;

或者
&lt;select id="selectStudentByNameAndAge" resultType="student"&gt;
        select * from t_student
            where name=#{param1} and age=#{param2}
 &lt;/select&gt;

或者
&lt;select id="selectStudentByNameAndAge" resultType="student"&gt;
        select * from t_student
            where name=#{arg0} and age=#{param2}
&lt;/select&gt;</code></pre> 
<blockquote> 
 <p><span style="color:#fe2c24;">提一点：这是高版本的mybatis才会带，<strong>使用mybatis</strong><strong>3.4.2之前的版本时：要用#{0}和#{1}这种形式。</strong></span></p> 
</blockquote> 
<p></p> 
<pre><code class="language-java">    @Test
    public void testsSelectStudentByNameAndAge(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
        List&lt;Student&gt; students = mapper.selectStudentByNameAndAge("Kobe", 20);
        students.forEach(student -&gt; System.out.println(student));
        sqlSession.close();
    }</code></pre> 
<p></p> 
<h3 id="%E5%A4%9A%E5%8F%82%E6%95%B0%E4%B9%8B%E6%B3%A8%E8%A7%A3Param">多参数之注解Param</h3> 
<p>在上面我们提到的多参数使用arg0或者param1可读性太差了。于是引入了Param注解。</p> 
<p>说白了不管是arg0还是param1都只是存了一个地址罢了，只是一个引用，最后在执行sql语句时还是用具体的实参值去crud的，那么我们可以通过注解Param指定参数对应的这个引用名。</p> 
<pre><code class="language-java">/**接口
     * 根据name和age查询student,版本二使用Param注解
     * (@Param(value = "_name") value可以省略
     * 直接写(@Param("_name")
     */
    List&lt;Student&gt; selectStudentByNameAndAge2
    (@Param("_name") String name,@Param("_age")Integer age);

看清楚了就是在形参前面加@Param("指定名字")即可</code></pre> 
<pre><code class="language-XML">//SqlMapper.XML    
&lt;!--根据name和age查询student,
    版本二使用Param注解--&gt;
    &lt;select id="selectStudentByNameAndAge2" resultType="student"&gt;
        select * from t_student
            where name=#{_name} and age=#{_age}
    &lt;/select&gt;</code></pre> 
<pre><code class="language-java">    @Test
    public void testsSelectStudentByNameAndAge2(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
        List&lt;Student&gt; students = mapper.selectStudentByNameAndAge2("Kobe", 20);
        students.forEach(student -&gt; System.out.println(student));
        sqlSession.close();
    }</code></pre> 
<blockquote> 
 <p>注意：Param注解只是修改了Map集合中的arg，后面的param还是可以用的。使用Param注解后底层Map长这样：</p> 
 <p><span style="color:#0d0016;">Map.put(_name，name);</span></p> 
 <p><span style="color:#0d0016;">Map.put(_age，age);</span></p> 
 <p><span style="color:#0d0016;">Map.put(指定的名字，参数名);</span></p> 
 <p>...</p> 
 <p><span style="color:#0d0016;">Map.put(param1,name);</span></p> 
 <p><span style="color:#0d0016;">Map.put(param2,age);</span></p> 
 <p><span style="color:#0d0016;">Map.put(param3,参数名);</span></p> 
 <p><span style="color:#0d0016;">.......</span></p> 
</blockquote> 
<h3 id="%C2%A0%E5%86%8D%E4%B8%80%E6%AC%A1%E7%90%86%E8%A7%A3%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"> 再一次理解动态代理</h3> 
<blockquote> 
 <pre>* 代理对象：mapper
* 代理方法：目标方法的所有方法以及代理对象私有的方法
* 目标对象：接口对应的Class文件
* 目标方法：接口中的方法
*
* 再一次深入理解动态代理对象：
* 一开始提到动态代理对象是为了解决每次都需手动创建实现接口类。
* 然后使用到了这个动态代理后我们就只需要写接口即可。
*由这个方法为入口：sqlSession.getMapper(StudentMapper.class);
* mybatis在底层做了两件事
* 1.生成CarMapper.class字节码文件
* 2.根据CarMapper.class字节码文件实例化了一个对象并且返回,
*   也就是现在mapper这个引用所指向的那个对象
*
* 你需要理解的是：现在你通过这个mapper变量去调用的所有方法其实看似
* 是在调用XxxMapper接口中的方法，其实不是，他是在调用动态代理对象中的方法
* 这些方法叫动态方法，其次动态代理对象不只是只有接口中的那些方法，他还有属于
* 自己的方法，这些方法是接口中没有的。属于动态代理对象的方法。那说到这里你心里应该
* 有个底，这个动态代理对象只是copy了接口中的所有方法，他和你自己去创造一个接口实现类
* 是不一样的,其实你自己想一下，你在创建一个接口实现类的时候首先你肯定是要实现了接口中的
* 所有方法，那我这个实现类难道不能有别的方法吗?显然是可以的，那这个动态实现类还有别的方法
* 就很好理解了。其次你还要知道一点是，这个动态代理底层用的还是JBoss中的Javassist去实现的，
* 只不过mybatis把它给封装在自己的框架里面了。
* 那他动态代理对象具有哪些独有的方法？
* 目前我就知道解析Param注解，当然里面的内容远不止于此哦
*
* 什么是Javassist?
* Javassist是一个开源的分析、编辑和创建Java字节码的类库。是由东京工业大学的数学和计算机科
* 学系的Shigeru Chiba （千叶 滋）所创建的。它已加入了开放源代码JBoss 应用服务器项目，
* 通过使用Javassist对字节码操作为JBoss实现动态"AOP"框架。</pre> 
</blockquote> 
<p>、</p> 
<h2 id="%E6%9F%A5%E8%AF%A2%E4%B8%93%E5%88%97">查询专列</h2> 
<blockquote> 
 <p>注意点：</p> 
 <ol><li>查询的结果若为多个，但是返回值却只有一个时报错：TooManyResultsException。</li><li></ol> 
</blockquote> 
<p></p> 
<h3 id="%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2">模糊查询</h3> 
<pre><code class="language-XML">    &lt;select id="selectByLikeBrand" resultType="car"&gt;
        select id,
               car_num as carNum,
               brand,
               guide_price as guidePrice,
               produce_time as produceTime,
               car_type as carType
               from t_car
            where brand like "%"#{brand}"%"
    &lt;/select&gt;

//注意点：
"%"#{brand}"%"
</code></pre> 
<p></p> 
<h3 id="%E8%BF%94%E5%9B%9EMap%E9%9B%86%E5%90%88">返回Map集合</h3> 
<p>应用场景：</p> 
<p id="u433ed4c9">1.当返回的数据，没有合适的实体类对应的话，可以采用Map集合接收。字段名做key，字段值做value。但是前提条件是查询结果可以保证只有一条数据。</p> 
<p><img alt="" height="267" src="https://images2.imgbox.com/37/ef/PaiYQkDz_o.png" width="286"></p> 
<pre><code class="language-java">/**接口
 * 通过id查询一条记录，返回Map集合
 */
Map&lt;String,Object&gt; selectById(Integer id);</code></pre> 
<pre><code class="language-XML">   
//SqlMapper.xml编写 
    &lt;select id="selectById" resultType="map"&gt;
        select * from t_car where id=#{id}
    &lt;/select&gt;

//注意点：resultType="map"，这个map很明显是mybatis内置的别名
//原名是map的全类名</code></pre> 
<pre><code class="language-java">    @Test
    public void TestSelectById(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        CarMapper mapper = sqlSession.getMapper(CarMapper.class);
        Map&lt;String, Object&gt; map = mapper.selectById(1);
        System.out.println(map);
        sqlSession.close();
    }</code></pre> 
<p></p> 
<p></p> 
<h3 id="%E8%BF%94%E5%9B%9EList%3CMap%3E">返回List&lt;Map&gt;</h3> 
<p>使用场景：</p> 
<p>1.当返回的数据，没有合适的实体类对应。</p> 
<p>2.查询结果可能返回多条语句。</p> 
<p>3.只适合展示，若想得到里面的map集合操作会比较困难</p> 
<pre><code class="language-java">//接口
List&lt;Map&lt;String,Object&gt;&gt; selectByCarType(String car_type);</code></pre> 
<pre><code class="language-XML">    &lt;select id="selectByCarType" resultType="map"&gt;
        select * from t_car where car_type=#{car_type}
    &lt;/select&gt;

注意点：
虽然返回值是List&lt;Map&lt;String,Object&gt;&gt;两层集合嵌套，但是很明显
实际直接封装记录的是里面那个Map集合，所以你的这个resultType要写map
不可以写list。
</code></pre> 
<pre><code class="language-java">    @Test
    public void TestSelectByCarType(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        CarMapper mapper = sqlSession.getMapper(CarMapper.class);
        List&lt;Map&lt;String,Object&gt;&gt; cars = mapper.selectByCarType("燃油车");
        cars.forEach(map -&gt; System.out.println(map));
    }</code></pre> 
<p></p> 
<h3 id="%E8%BF%94%E5%9B%9EMap%3C%20String%20%2C%20Map%3C%20String%2CObject%20%3E%20%3E%E5%A4%A7Map%E9%9B%86">返回Map&lt; String , Map&lt; String,Object &gt; &gt;大Map集</h3> 
<p>说明：Map&lt;id主键，Map&lt;字段名,值&gt;&gt;</p> 
<p>外层Map的key存的是单条记录的主键，value存的是单条记录。</p> 
<p>使用场景：</p> 
<p>1.当返回的数据，没有合适的实体类对应。</p> 
<p>2.查询结果可能返回多条语句。</p> 
<p>3.这种方式可以解决List&lt;Map&gt;难以操作的弊端。</p> 
<p><span style="color:#fe2c24;">注意：这种方式一定要在接口方法前加一个@MapKey(字段名)的注解，并且你这和字段在数据表中必须是唯一的，因为Map集合中key是唯一的。</span></p> 
<pre><code class="language-java">//SqlMapper接口
@MapKey("id")
Map&lt;Long,Map&lt;String,Object&gt;&gt; selectByBrand(String brand);

//注意点：
一点要加一个@MapKey("id")注解，表名你要以id字段作为外层map的key</code></pre> 
<pre><code class="language-XML"> //SqlMapper.XML
&lt;!--返回结果Map&lt;String,Map&lt;String,Object&gt;&gt;--&gt;
    &lt;select id="selectByBrand" resultType="map"&gt;
        select * from t_car
        where brand like "%"#{brand}"%"
    &lt;/select&gt;</code></pre> 
<pre><code class="language-java">    @Test
    public void TestSelectByBrand(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        CarMapper mapper = sqlSession.getMapper(CarMapper.class);
        Map&lt;Long,Map&lt;String,Object&gt;&gt; map = mapper.selectByBrand("丰田");
        System.out.println(map);
    }</code></pre> 
<p></p> 
<p></p> 
<h3 id="%E6%9F%A5%E8%AF%A2%E4%B9%8B%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84(%E9%87%8D%E8%A6%81)">查询之结果映射(重要)</h3> 
<p>问：数据表中的字段名与java对应的封装的类的属性名不一致导致查询结果无法封装到java类对象中，怎么办？</p> 
<p>方案一：as 取别名，前面已经用过很多次了，很麻烦很鸡肋显然开发中不会有这种方式。</p> 
<p>方案二：在SqlMapper.xml映射文件中配置。</p> 
<p>比如：</p> 
<pre><code class="language-java">//原来
-------------------------------------------------------------    
&lt;!--返回结果List&lt;Car&gt;--&gt;
    &lt;select id="selectByLikeType" resultType="Car"&gt;
        select id,
               car_num as carNum,
               brand,
               guide_price as guidePrice,
               produce_time as produceTime,
               car_type as carType
               from t_car
            where brand like "%"#{brand}"%"
    &lt;/select&gt;
</code></pre> 
<pre><code class="language-XML">//修改后
-----------------------------------------------------
    &lt;!--
            resultMap:
                id：这个结果映射的标识，作为select标签的resultMap属性的值。
                type：结果集要映射的类(一般为pojo类)。这里的car明显是用了别名。
    --&gt;
    &lt;resultMap id="CarResultType" type="car"&gt;
        &lt;!--对象的唯一标识，官方解释是：为了提高mybatis的性能。建议写上。--&gt;
        &lt;id property="id" column="id"/&gt;
        &lt;result property="carNum" column="car_num"/&gt;
        &lt;!--当属性名和数据库列名一致时，可以省略。但建议都写上。--&gt;
        &lt;!--javaType用来指定属性类型。jdbcType用来指定列类型。一般可以省略。--&gt;
        &lt;result property="brand" column="brand" javaType="string" jdbcType="VARCHAR"/&gt;
        &lt;result property="guidePrice" column="guide_price"/&gt;
        &lt;result property="produceTime" column="produce_time"/&gt;
        &lt;result property="carType" column="car_type"/&gt;
    &lt;/resultMap&gt;

    &lt;!--返回结果List&lt;Car&gt;--&gt;
    &lt;select id="selectByLikeType" resultMap="CarResultType" &gt;
        select *
               from t_car
            where brand like "%"#{brand}"%"
    &lt;/select&gt;</code></pre> 
<p>方案三：开启驼峰命名自动映射</p> 
<p id="u38f10397">使用这种方式的前提是：属性名遵循Java的命名规范，数据库表的列名遵循SQL的命名规范。</p> 
<p id="u40992bcf">Java命名规范：首字母小写，后面每个单词首字母大写，遵循驼峰命名方式。</p> 
<p id="ue140fa3e">SQL命名规范：全部小写，单词之间采用下划线分割。</p> 
<p id="ue5063b75">比如以下的对应关系：</p> 
<table id="H6WFE"><tbody><tr><td> <p id="uaaf61840"><strong>实体类中的属性名</strong></p> </td><td> <p id="udf883d7b"><strong>数据库表的列名</strong></p> </td></tr><tr><td> <p id="u3df21a5b">carNum</p> </td><td> <p id="u3a25dda7">car_num</p> </td></tr><tr><td> <p id="u6307a928">carType</p> </td><td> <p id="u2e7e4744">car_type</p> </td></tr><tr><td> <p id="uc34b58aa">produceTime</p> </td><td> <p id="u6fc916f6">produce_time</p> </td></tr></tbody></table> 
<p id="uc0b4a6a2">如何启用该功能，在mybatis-config.xml文件中进行配置：</p> 
<pre><code class="language-XML">&lt;!--放在properties标签后面--&gt;
&lt;settings&gt;
  &lt;setting name="mapUnderscoreToCamelCase" value="true"/&gt;
&lt;/settings&gt;</code></pre> 
<p></p> 
<h3 id="%E6%9F%A5%E8%AF%A2%E6%89%80%E6%9C%89%E8%AE%B0%E5%BD%95%E6%9D%A1%E6%95%B0">查询所有记录条数</h3> 
<pre><code class="language-java">//SqlMappeer接口 
Long selectTotal();</code></pre> 
<pre><code class="language-java">//SqlMapper.xml映射文档
    &lt;!--返回总记录条数--&gt;
    &lt;select id="selectTotal" resultType="Long"&gt;
        select count(*) from t_car
    &lt;/select&gt;

注意点：resultType="Long"
显然这也是mybatis的一个内置的别名，原名就是全类名
其次count(*)或者count(1)都可以</code></pre> 
<pre><code class="language-java">    @Test
    public void TestSelectTotal(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        CarMapper mapper = sqlSession.getMapper(CarMapper.class);
        Long count = mapper.selectTotal();
        System.out.println(count);
    }</code></pre> 
<p></p> 
<p></p> 
<h2 id="%E5%8A%A8%E6%80%81SQL">动态SQL</h2> 
<h3 id="if%E6%A0%87%E7%AD%BE">if标签</h3> 
<p>使用场景：多条件查询</p> 
<pre><code class="language-java">SqlMapper接口
public interface CarMapper {
    //根据brand、guidePrice、carType
    List&lt;Car&gt; selectByMultCondition(@Param("brand") String brand,@Param("guidePrice")  Double guidePrice,@Param("carType")  String carType);
}</code></pre> 
<pre><code class="language-XML">&lt;!--SqlMapper.xml--&gt;    
&lt;select id="selectByMultCondition" resultType="car"&gt;
        select * from t_car where 1=1
            &lt;if test="brand != null and brand != ''"&gt;
                 and  brand like "%"#{brand}"%"
            &lt;/if&gt;
             &lt;if test="guidePrice != null and guidePrice != '' "&gt;
                and guide_price &gt; #{guidePrice}
            &lt;/if&gt;
             &lt;if test="carType != null and carType != '' "&gt;
                 and car_type=#{carType}
            &lt;/if&gt;
&lt;/select&gt;

//注意点：
1. if标签中test属性是必须的。
2. if标签中test属性的值是false或者true。
3.如果test是true，则if标签中的sql语句就会拼接。反之，则不会拼接
4.test属性中可以使用的是:
4.1在接口中对参数使用了@Param注解，那么test中要出现的是@Param注解指定的参数名。
比如：@Param("brand")，那么这里只能使用brand
4.2当没有使用@Param注解，那么test中要出现的是: param1 param2 param3 arg arg1 arg2...
4.3接口方法中传入的参数为pojo，那么test中出现的是POJO类的属性名。
4.4在mybatis的动态SOL当中，不能使用&amp;&amp;，只能使用and。

5.在where后面加1=1的原因是如果在一下三个if都不满足拼接条件那么最终的sql
语句就会变成：select * from t_car where
显然这肯定是会报错的。
6.每一个拼接条件记得加and!!!!!</code></pre> 
<pre><code class="language-java">    @Test
    public void testSelectByMultCondition(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        CarMapper mapper = sqlSession.getMapper(CarMapper.class);
        List&lt;Car&gt; cars = mapper.selectByMultCondition("丰田",23.30,"燃油车");
        cars.forEach(car -&gt; System.out.println(car));
    }


-------------------------------------------------------------
最后执行查询的语句是：
Preparing: select * from t_car 
            where 1=1 and 
            brand like "%"?"%" and 
            guide_price &gt; ? and 
            car_type=?

Parameters: 丰田(String), 23.3(Double), 燃油车(String)</code></pre> 
<p></p> 
<p></p> 
<h3 id="where%E6%A0%87%E7%AD%BE">where标签</h3> 
<p><img alt="" height="155" src="https://images2.imgbox.com/aa/1a/TmC5NbnD_o.png" width="647"></p> 
<p>注意：里面的子句不止有if，可以放别的子句。他最主要的功能就是动态生成子句，其次才是去除前面多余的and和or</p> 
<p> 我们来改良一下上面这个if标签的案例</p> 
<pre><code class="language-java">SqlMapper接口
public interface CarMapper {
    //根据brand、guidePrice、carType
    List&lt;Car&gt; selectByMultCondition(@Param("brand") String brand,@Param("guidePrice")  Double guidePrice,@Param("carType")  String carType);
}</code></pre> 
<pre><code class="language-XML">&lt;!--SqlMapper.xml--&gt;    
&lt;select&gt;
    select * from t_car
        &lt;where&gt;
            &lt;if test="brand != null and brand != ''"&gt;
                and brand like "%"#{brand}"%"
            &lt;/if&gt;
            &lt;if test="guidePrice != null and guidePrice != '' "&gt;
                and guide_price &gt; #{guidePrice}
            &lt;/if&gt;
            &lt;if test="carType != null and carType != '' "&gt;
                and car_type=#{carType}
            &lt;/if&gt;
        &lt;/where&gt;
&lt;/select&gt;

--------------------------------------------------------------------
最后执行的语句：
select * from t_car WHERE brand like "%"?"%" and guide_price &gt; ? and car_type=?
--------------------------------------------------------------------------------


很明显 &lt;if test="brand != null and brand != ''"&gt;
                and brand like "%"#{brand}"%"
       &lt;/if&gt;
这个and是多余的，然后他帮我们去除了。


//注意点：
1.where标签只能帮助去掉前面多余的and或者or，不能去掉后面多余的and或者or
比如说：
    &lt;where&gt;
            &lt;if test="brand != null and brand != ''"&gt;
                and brand like "%"#{brand}"%" and
            &lt;/if&gt;
    &lt;/where&gt;
很明显这两个都是多余的，但是他能帮你去掉前面那个。
2.他只能帮你智能去除前面的and或or，不能帮你自动增加and或or，
    因为他咋知道你要添加and还是or
3.使用了where标签后在原来的语句中就不要再写where了比如：
错误写法：select * from t_car  where &lt;where&gt; &lt;/where&gt;
正确写法：select * from t_car &lt;where&gt; &lt;/where&gt;


-------------------------------------------------------
如果你这样写也是不行的
&lt;select&gt;
    select * from t_car
        &lt;where&gt;
            &lt;if test="brand != null and brand != ''"&gt;
                and brand like "%"#{brand}"%" and
            &lt;/if&gt;
            &lt;if test="guidePrice != null and guidePrice != '' "&gt;
                and guide_price &gt; #{guidePrice}
            &lt;/if&gt;
        &lt;/where&gt;
&lt;/select&gt;
//你可能会觉得在第一个if后面加了and，那他就会帮我去掉第二个if中前面的and
不，他不会，因为他压根就不会去检测你的第一条语句后面有没有and。所有就会造成
两个and 重复了</code></pre> 
<p></p> 
<h3 id="trim%E6%A0%87%E7%AD%BE">trim标签</h3> 
<p><img alt="" height="301" src="https://images2.imgbox.com/f7/5c/qVeOOau9_o.png" width="885"></p> 
<p><img alt="" height="710" src="https://images2.imgbox.com/bf/a5/vs4ZiTso_o.png" width="733"></p> 
<p> <a class="link-info" href="https://blog.csdn.net/m0_48333563/article/details/125470309?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167800021516782428670324%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=167800021516782428670324&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-125470309-null-null.142%5Ev73%5Einsert_down1,201%5Ev4%5Eadd_ask,239%5Ev2%5Einsert_chatgpt&amp;utm_term=trim%E6%A0%87%E7%AD%BE&amp;spm=1018.2226.3001.4187" title="详细看这里">详细看这里</a></p> 
<p></p> 
<h3 id="set%E6%A0%87%E7%AD%BE">set标签</h3> 
<p>先看一个案例：</p> 
<pre><code class="language-XML">接口
int updateById(Car car);</code></pre> 
<pre><code class="language-XML">    &lt;!--动态修改
    //SqlMapper.xml
    --&gt;
    &lt;update id="updateById"&gt;
        update t_car
            set car_num = #{carNum},
                brand = #{brand},
                guide_price = #{guidePrice},
                produce_time = #{produceTime},
                car_type = #{carType}
        where id = #{id}
    &lt;/update&gt;</code></pre> 
<pre><code class="language-java">    @Test
    public void testUpdateById(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        CarMapper mapper = sqlSession.getMapper(CarMapper.class);
        Car car = new Car(1L, null, null, null, null, null);
        sqlSession.commit();
        sqlSession.close();
        mapper.updateById(car);
    }</code></pre> 
<p>很明显会把数据库里面的字段变为空了。</p> 
<p id="u93be7bc8">set标签主要使用在update语句当中，用来生成set关键字，同时去掉最后多余的“,”</p> 
<p id="ud3c5d366">比如我们只更新提交的不为空的字段，如果提交的数据是空或者""，那么这个字段我们将不更新。</p> 
<pre><code class="language-XML">int updateById(Car car);</code></pre> 
<pre><code class="language-XML"> &lt;update id="updateById"&gt;
        update t_car
        &lt;set&gt;
            &lt;if test="carNum != null and carNum != ''"&gt;
                car_num = #{carNum},
            &lt;/if&gt;
            &lt;if test="brand != null and brand != ''"&gt;
                brand = #{brand},
            &lt;/if&gt;
            &lt;if test="guidePrice != null and guidePrice != ''"&gt;
                guide_price = #{guidePrice},
            &lt;/if&gt;
            &lt;if test="produceTime != null and produceTime != ''"&gt;
                produce_time = #{produceTime},
            &lt;/if&gt;
            &lt;if test="carType != null and carType != ''"&gt;
                car_type = #{carType},
            &lt;/if&gt;
        &lt;/set&gt;
        where id = #{id}
    &lt;/update&gt;</code></pre> 
<pre><code class="language-XML">    @Test
    public void testUpdateById(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        CarMapper mapper = sqlSession.getMapper(CarMapper.class);
//        (id,car_num,brand,guide_price,produce_time,car_type)
        Car car = new Car(1L, "1003", "凯迪拉克", null, null, "燃油车");
        mapper.updateById(car);
        sqlSession.commit();
        sqlSession.close();
    }</code></pre> 
<pre><code class="language-XML">最后执行的sql：
update t_car SET car_num = ?, brand = ?, car_type = ? where id = ?
很明显这个SET是大写的代表是动态的修改。
而且他没有对参数为null或""进行修改。

注意：如果你的参数全为null，则最后执行sql是这样的：

update t_car where id = ?

全为null或者""的话，set关键字都没有了，此时肯定报sql语法错误了，
报错的话你要么避免这种情况，要么在java业务层去捕获异常处理
</code></pre> 
<h3 id="choose%20when%20otherwise">choose when otherwise</h3> 
<p>MyBatis 中动态语句 choose-when-otherwise 类似于 Java 中的 switch-case-default 语句。由于 MyBatis 并没有为 if 提供对应的 else 标签，如果想要达到&lt;if&gt;...&lt;else&gt;...&lt;/else&gt; &lt;/if&gt; 的效果，可以借助 &lt;choose&gt;、&lt;when&gt;、&lt;otherwise&gt; 来实现。</p> 
<p>动态语句 choose-when-otherwise 语法如下。        </p> 
<pre><code class="language-XML">    &lt;choose&gt;
        &lt;when test="判断条件1"&gt;
            SQL语句1
        &lt;/when &gt;
        &lt;when test="判断条件2"&gt;
            SQL语句2
        &lt;/when &gt;
        &lt;when test="判断条件3"&gt;
            SQL语句3
        &lt;/when &gt;
        &lt;otherwise&gt;
            SQL语句4
        &lt;/otherwise&gt;
    &lt;/choose&gt;</code></pre> 
<p> choose 标签按顺序判断其内部 when 标签中的判断条件是否成立，如果有一个成立，则执行相应的 SQL 语句，choose 执行结束；如果都不成立，则执行 otherwise 中的 SQL 语句。这类似于 Java 的 switch 语句，choose 为 switch，when 为 case，otherwise 则为 default。</p> 
<p>以下示例要求：</p> 
<p>下面使用 choose-when-otherwise 标签实现</p> 
<p id="u4bcb827d">需求：先根据品牌查询，如果没有提供品牌，再根据指导价格查询，如果没有提供指导价格，就根据生产日期查询。</p> 
<pre><code class="language-java">接口

/**
* 使用choose when otherwise标签查询
* @param brand
* @param guidePrice
* @param produceTime
* @return
*/
List&lt;Car&gt; selectWithChoose(@Param("brand") String brand, @Param("guidePrice") Double guidePrice, @Param("produceTime") String produceTime);</code></pre> 
<pre><code class="language-XML">&lt;select id="selectWithChoose" resultType="car"&gt;
  select * from t_car
  &lt;where&gt;
    &lt;choose&gt;
      &lt;when test="brand != null and brand != ''"&gt;
        brand like #{brand}"%"
      &lt;/when&gt;
      &lt;when test="guidePrice != null and guidePrice != ''"&gt;
        guide_price &gt;= #{guidePrice}
      &lt;/when&gt;
      &lt;otherwise&gt;
        produce_time &gt;= #{produceTime}
      &lt;/otherwise&gt;
    &lt;/choose&gt;
  &lt;/where&gt;
&lt;/select&gt;</code></pre> 
<pre><code class="language-java">@Test
public void testSelectWithChoose(){
    CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class);
    //List&lt;Car&gt; cars = mapper.selectWithChoose("丰田霸道", 20.0, "2000-10-10");
    //List&lt;Car&gt; cars = mapper.selectWithChoose("", 20.0, "2000-10-10");
    //List&lt;Car&gt; cars = mapper.selectWithChoose("", null, "2000-10-10");
    List&lt;Car&gt; cars = mapper.selectWithChoose("", null, "");
    System.out.println(cars);
}</code></pre> 
<p><img alt="" height="155" src="https://images2.imgbox.com/f4/ad/UtgHS9Xs_o.png" width="701"></p> 
<p></p> 
<h3 id="foreach%E6%A0%87%E7%AD%BE">foreach标签</h3> 
<p>看一个场景：</p> 
<p><img alt="" height="198" src="https://images2.imgbox.com/be/e8/4XZMl5Y1_o.png" width="854"></p> 
<p> 那这个sql的语句在mybatis中怎么去做？</p> 
<h4 id="%E6%89%B9%E9%87%8F%E5%88%A0%E9%99%A4">批量删除</h4> 
<pre><code class="language-XML">/**CarMapper接口
* 通过foreach完成批量删除
* @param ids
* @return
*/
int deleteBatchByForeach(@Param("ids") Long[] ids);</code></pre> 
<pre><code class="language-XML">&lt;!--CarMapper.xml
collection：集合或数组
item：集合或数组中的元素(这个值是随意的，只是用于遍历时对元素的引用罢了)
separator：分隔符
open：foreach标签中所有内容的开始
close：foreach标签中所有内容的结束
--&gt;
&lt;delete id="deleteBatchByForeach"&gt;
  delete from t_car where id in
  &lt;foreach collection="ids" item="id" separator="," open="(" close=")"&gt;
    #{id}
  &lt;/foreach&gt;
&lt;/delete&gt;
----------------------------------------------------------
&lt;delete id="deleteBatchByForeach"&gt;
  delete from t_car where id in(
  &lt;foreach collection="ids" item="id" separator=","&gt;
    #{id}
  &lt;/foreach&gt;
)
&lt;/delete&gt;
---------------------------------------------------
</code></pre> 
<pre><code class="language-XML">@Test
public void testDeleteBatchByForeach(){
    CarMapper mapper = SqlSessionUtil.openSession().getMapper(CarMapper.class);
    int count = mapper.deleteBatchByForeach(new Long[]{40L, 41L, 42L});
    System.out.println("删除了几条记录：" + count);
    SqlSessionUtil.openSession().commit();
}</code></pre> 
<h4 id="%C2%A0%E6%89%B9%E9%87%8F%E6%8F%92%E5%85%A5"> 批量插入</h4> 
<pre><code class="language-java">//接口
int insertByBatch(@Param("cars") List&lt;Car&gt; cars);</code></pre> 
<pre><code class="language-XML">//sqlMapper.xml 
&lt;insert id="insertByBatch"&gt;
        insert into t_car values
            &lt;foreach collection="cars" separator="," item="car"&gt;
                (
                    null,
                    #{car.carNum},
                    #{car.brand},
                    #{car.guidePrice},
                    #{car.produceTime},
                    #{car.carType}
                )
            &lt;/foreach&gt;
&lt;/insert&gt;

</code></pre> 
<pre><code class="language-java">    @Test
    public void testInsertByBatch(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        CarMapper mapper = sqlSession.getMapper(CarMapper.class);
        Car car1 = new Car(null, "1004", "凯迪拉克", null, null, "燃油车");
        Car car2 = new Car(null, "1005", "凯迪拉克2", null, null, "燃油车");
        Car car3 = new Car(null, "1006", "凯迪拉克3", null, null, "燃油车");
        List&lt;Car&gt; cars = new ArrayList&lt;&gt;();
        cars.add(car1);
        cars.add(car2);
        cars.add(car3);
        mapper.insertByBatch(cars);
        sqlSession.commit();
        sqlSession.close();
    }</code></pre> 
<p></p> 
<h3 id="sql%E4%B8%8Einclude%E6%A0%87%E7%AD%BE">sql与include标签</h3> 
<pre><code class="language-XML">//sql代码片段    
&lt;sql id="hhh"&gt;
        &lt;where&gt;
            &lt;if test="brand != null and brand != ''"&gt;
                and brand like "%"#{brand}"%"
            &lt;/if&gt;
            &lt;if test="guidePrice != null and guidePrice != '' "&gt;
                and guide_price &gt; #{guidePrice}
            &lt;/if&gt;
            &lt;if test="carType != null and carType != '' "&gt;
                and car_type=#{carType}
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/sql&gt;

    &lt;select id="selectByMultCondition" resultType="car"&gt;
        select * from t_car
    //把代码拼接进来
        &lt;include refid="hhh"/&gt;
    &lt;/select&gt;
-----------------------------------------------------------------------
相当于：
---------------------------------------------------------
    &lt;select id="selectByMultCondition" resultType="car"&gt;
        select * from t_car
         &lt;where&gt;
            &lt;if test="brand != null and brand != ''"&gt;
                and brand like "%"#{brand}"%"
            &lt;/if&gt;
            &lt;if test="guidePrice != null and guidePrice != '' "&gt;
                and guide_price &gt; #{guidePrice}
            &lt;/if&gt;
            &lt;if test="carType != null and carType != '' "&gt;
                and car_type=#{carType}
            &lt;/if&gt;
        &lt;/where&gt;
    &lt;/select&gt;</code></pre> 
<p></p> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="%E9%AB%98%E7%BA%A7%E6%98%A0%E5%B0%84">高级映射</h2> 
<p>总结：</p> 
<p>学生、班级</p> 
<p>一对多和多对一的区别？</p> 
<p>首先这两张表肯定是相关联的。宏观来看，学生为多，班级为一。一对多和多对一取决于你的第一出发点，比如我通过学生id去查看它对应的班级id，然后在通过班级id去查询对应的班级信息表。那么我的第一出发点就是学生，那就是多对一。</p> 
<p>若通过班级id去学生表中查询班级id对应的学生，那么出发点就是从班级到学生，那么就是一对多。</p> 
<p>多对多：比如说一个班级有很多学生，他们有语文课、数学课、英语课等很多课。一门课有很多人上，一个人上很多门课。这里学生和课程的关系就是多对多。</p> 
<p></p> 
<p><img alt="" height="695" src="https://images2.imgbox.com/ee/30/5WUkap1L_o.png" width="1200"></p> 
<p> 分析，原来时一个对象映射一条记录，要是一个对象需要用到多张表才能去映射，那怎么去映射呢？</p> 
<p></p> 
<h3 id="%E9%AB%98%E7%BA%A7%E6%98%A0%E5%B0%84%E5%A4%9A%E5%AF%B9%E4%B8%80">高级映射多对一</h3> 
<p><img alt="" height="764" src="https://images2.imgbox.com/08/12/fzjN2Vcl_o.png" width="1200"></p> 
<p></p> 
<p>需求：输入一个学生的id查询到学生的学号、姓名、班级信息。</p> 
<p>为什么是多对一？</p> 
<p>我的需是根据学生信息里面的班级id去查询班级信息，宏观来看待学生和班级，明显班级是一，然后学生是多，那么我现在以学生的角度为出发点去查询所以就是多对一</p> 
<p></p> 
<p>分析：主表为学生表，附表为班级表，那么就是说主要查询的对象是学生信息，其中学生信息当中带有了一个班级信息对象，先查出主要的学生信息，若该学生没有班级信息则返回班级信息为空。</p> 
<p>到这里请先跳到左外连接去回顾知识点。<a class="link-info" href="https://blog.csdn.net/boilll/article/details/127833598?spm=1001.2014.3001.5501" title="左外连接">左外连接</a></p> 
<p><img alt="" height="204" src="https://images2.imgbox.com/1e/5c/IBkZk1pp_o.png" width="1076"></p> 
<p></p> 
<p>学生表</p> 
<p><img alt="" height="292" src="https://images2.imgbox.com/16/14/L3lDBW4s_o.png" width="387"></p> 
<p>班级表</p> 
<p><img alt="" height="215" src="https://images2.imgbox.com/9e/eb/owug4HO0_o.png" width="337"></p> 
<p>这两张表通过cid相关联</p> 
<p></p> 
<p>我们先定义两个pojo类，Student和Clazz</p> 
<pre><code class="language-java">public class Student {//Student对象是多的一方
    private Long sid;
    private String sname;
    private Clazz clazz ;//Clazz对象是一的一方

... ...



public class Clazz {
    private Long cid;
    private String cname;
... ...</code></pre> 
<h4 id="%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%EF%BC%8C%E7%BA%A7%E8%81%94%E5%B1%9E%E6%80%A7%E6%98%A0%E5%B0%84">方案一：一条SQL语句，级联属性映射</h4> 
<pre><code class="language-XML">/**接口
     * 根据id获取学生信息，同时获取学生关联的学生信息(学生对象中包含了班级对象)
     * @param id
     * @return
     */
    Student selectById(Integer sid);</code></pre> 
<pre><code class="language-XML">
SqlMapper.XML
 &lt;resultMap id="studentResultMap" type="student"&gt;
        &lt;id property="sid" column="sid"/&gt;
        &lt;result property="sname" column="sname"/&gt;
        &lt;result property="clazz.cid" column="cid"/&gt;
        &lt;result property="clazz.cname" column="cname"/&gt;
    &lt;/resultMap&gt;

    &lt;select id="selectById" resultMap="studentResultMap"&gt;
        select
            s.sid,s.sname,c.cid,c.cname
        from
            t_stu as s left join t_clazz as c
        on s.cid = c.cid
        where s.sid = #{sid}
    &lt;/select&gt;

---------------------------------------------------------------------
分两步来看：
先看下面的，
&lt;select id="selectById" resultMap="studentResultMap"&gt;
        select
            s.sid,s.sname,c.cid,c.cname
        from
            t_stu as s left join t_clazz as c
        on s.cid = c.cid
        where s.sid = #{sid}
&lt;/select&gt;
这里面查询用到的全都是数据库里面的字段名，除了最后那个#{id}也就是说
你看下面这一段你要把自己代入到数据库当中的查询那里去做，但这样在java代码中
肯定是查询不了的，因为属性名和映射对象不一致，在学生类中没有班级id和班级名的
他只有一个班级对象，所以我们需要通过上面这一段来修改映射的值
&lt;resultMap id="studentResultMap" type="student"&gt;
        &lt;id property="sid" column="sid"/&gt;
        &lt;result property="sname" column="sname"/&gt;
        &lt;result property="clazz.cid" column="cid"/&gt;
        &lt;result property="clazz.cname" column="cname"/&gt;
&lt;/resultMap&gt;
---------------------------------------------------
&lt;resultMap id="studentResultMap" type="student"&gt;
这一句中id是用来定位当前resultMap标签的，type表示映射的对象，这里的student明显是一个别名
&lt;id property="sid" column="sid"/&gt; id是student这个类的id，column是对应数据库的字段
.......</code></pre> 
<pre><code class="language-java">    @Test
    public void testSelectByIdAssociation(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
        Student student = mapper.selectById(1);
        System.out.println(student);
    }</code></pre> 
<p></p> 
<h4 id="%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9A%E4%B8%80%E6%9D%A1sql%E8%AF%AD%E5%8F%A5%EF%BC%8Cassociation">方案二：一条sql语句，association</h4> 
<p>在方案一的基础上嵌套一个内置的关联映射类即可。只需要修改SqmMapper.XML即可。</p> 
<pre><code class="language-XML">&lt;resultMap id="studentResultMapAssociation" type="student"&gt;
        &lt;id property="sid" column="sid"/&gt;
        &lt;result property="sname" column="sname"/&gt;
        &lt;association property="clazz" javaType="Clazz"&gt;
            &lt;id property="cid" column="cid"/&gt;
            &lt;result property="cname" column="cname"/&gt;
        &lt;/association&gt;
&lt;/resultMap&gt;

    &lt;select id="selectByIdAssociation" resultMap="studentResultMapAssociation"&gt;
        select s.*,c.*
            from t_stu as s left join t_clazz as c
            on s.cid = c.cid
            where s.sid = #{sid}
    &lt;/select&gt;

-------------------------------------------------------
其他的都不用改，只需要修改的就是&lt;resultMap&gt;在这里面嵌套了一个
    &lt;association property="clazz" javaType="Clazz"&gt;
            
    &lt;/association&gt;
&lt;/resultMap&gt;
映射类，其实作用就相当于&lt;resultMap&gt;内部又嵌套了一个&lt;resultMap&gt;,因为
我是两张表的关联查询，所以这里的association就相当于把被关联的那张表单独去映射
property的clazz值是student这个类的属性变量，javaType指定这个变量映射的那个pojo
</code></pre> 
<h4 id="%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9A%E4%B8%A4%E6%9D%A1SQL%E8%AF%AD%E5%8F%A5%EF%BC%8C%E5%88%86%E6%AD%A5%E6%9F%A5%E8%AF%A2%E3%80%82%EF%BC%88%E8%BF%99%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%B8%B8%E7%94%A8%EF%BC%9A%E4%BC%98%E7%82%B9%E4%B8%80%E6%98%AF%E5%8F%AF%E5%A4%8D%E7%94%A8%E3%80%82%E4%BC%98%E7%82%B9%E4%BA%8C%E6%98%AF%E6%94%AF%E6%8C%81%E6%87%92%E5%8A%A0%E8%BD%BD%E3%80%82">方案三：两条SQL语句，分步查询。（这种方式常用：优点一是可复用。优点二是支持懒加载。</h4> 
<pre><code class="language-java"> /**
     * 根据学生id查询学生信息，班级信息
     * 分步查询
     * 第一步：创建接口方法
     * @param sid
     * @return
     */
    Student selectByIdStep(Integer sid);</code></pre> 
<pre><code class="language-XML">    &lt;!--第三步，对selectByIdStep这条查询语句的查询结果进行结果映射
     当对cid这个查询结果进行映射时关联另外一句select语句，并且把
     selectByIdStep这条查询语句查询的cid值传递给被关联的那条查询语句
   --&gt;
    &lt;resultMap id="studentResultMapStep" type="student"&gt;
        &lt;id property="sid" column="sid"/&gt;
        &lt;result property="sname" column="sname"/&gt;
        &lt;!--关联一个对象，这个对象的信息从另外一条select返回--&gt;
        &lt;association property="clazz"
          &lt;!--插入一条查询语句，并且把cid传递过去，
                跳到第四步编写这条查询语句--&gt;
                   select="com.yzh.mybatis.mapper.ClazzMapper.selectClazzByCid"
                   column="cid"
                &lt;!--我得说一下这里上面这个column的值是听过你先面那条select语句查出来的
                    你下面查的是cid你就填cid，因为你要把这个cid传递给另外一条select语句
                    若你下面对这个cid去了别名那么你就得写这个别名在这上面--&gt;

        /&gt;
    &lt;/resultMap&gt;

    &lt;!--第二步,先把主表信息查出来，共三个字段：
    sid、sname、cid 注意：这三个字段是t_stu表中所有的
    字段。并不是Student这个pojo类的所有属性。
    这里就只是一条平平无奇的根据id查询学生信息
    --&gt;
    &lt;select id="selectByIdStep" resultMap="studentResultMapStep"&gt;
        select sid,sname,cid from t_stu where sid=#{sid}
    &lt;/select&gt;</code></pre> 
<pre><code class="language-java">//第四步：编写被关联查询语句的查询方法
public interface ClazzMapper {
    //在ClazzMapper接口编写查询方法
 Clazz selectClazzByCid(Integer cid);
}</code></pre> 
<pre><code class="language-XML">    &lt;!--第五步：编写被关联的语句，这条语句就是通过cid查询t_clzz这张表的班级信息--&gt;
    &lt;select id="selectClazzByCid" resultType="Clazz"&gt;
        select  cid,cname from t_clazz where cid = #{cid}
           &lt;!-- #{cid} 这个值是在第一条select语句中查询的结果--&gt;
    &lt;/select&gt;</code></pre> 
<pre><code class="language-java">    @Test
    public void testSelectByIdStep(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        StudentMapper mapper = sqlSession.getMapper(StudentMapper.class);
        Student student = mapper.selectByIdStep(2);
        System.out.println(student);
    }</code></pre> 
<p>这个分步查询指的是分两步查询，先根据学生id：sid把主表对应的那个学生信息全部查询出来，因为主表和副表之间肯定是相关联的，这里的主表副表是通过cid相关联的，通过主表查询我得到了这位学生的cid，通过&lt;association column="cid"&gt; 把cid传递给另外一条查询语句，新建一个查询语句，该查询语句通过cid对副表进行进行查询。</p> 
<p></p> 
<p><img alt="" height="506" src="https://images2.imgbox.com/63/e3/JvybrDOx_o.png" width="1200"></p> 
<p><img alt="" height="94" src="https://images2.imgbox.com/5f/d6/hSVHBzfK_o.png" width="897"></p> 
<pre><code class="language-XML">&lt;resultMap id="studentResultMap" type="Student"&gt;
  &lt;id property="sid" column="sid"/&gt;
  &lt;result property="sname" column="sname"/&gt;
  &lt;association property="clazz"
               select="com.powernode.mybatis.mapper.ClazzMapper.selectByCid"
               column="cid"
               fetchType="lazy"/&gt;
&lt;/resultMap&gt;</code></pre> 
<p id="u3e880902">我们现在只查询学生名字，修改测试程序：</p> 
<pre><code class="language-XML">public class StudentMapperTest {
    @Test
    public void testSelectBySid(){
        StudentMapper mapper = SqlSessionUtil.openSession().getMapper(StudentMapper.class);
        Student student = mapper.selectBySid(1);
        //System.out.println(student);
        // 只获取学生姓名
        String sname = student.getSname();
        System.out.println("学生姓名：" + sname);
    }
}</code></pre> 
<p><img alt="" height="227" src="https://images2.imgbox.com/c9/98/W2cx0sMz_o.png" width="1200"></p> 
<p>如果后续需要使用到学生所在班级的名称，这个时候才会执行关联的sql语句，修改测试程序：</p> 
<pre><code class="language-XML">public class StudentMapperTest {
    @Test
    public void testSelectBySid(){
        StudentMapper mapper = SqlSessionUtil.openSession().getMapper(StudentMapper.class);
        Student student = mapper.selectBySid(1);
        //System.out.println(student);
        // 只获取学生姓名
        String sname = student.getSname();
        System.out.println("学生姓名：" + sname);
        // 到这里之后，想获取班级名字了
        String cname = student.getClazz().getCname();
        System.out.println("学生的班级名称：" + cname);
    }
}</code></pre> 
<p><img alt="" height="472" src="https://images2.imgbox.com/0e/c6/ZWVHvj2Y_o.png" width="1171"></p> 
<p><img alt="" height="314" src="https://images2.imgbox.com/a6/24/GPvmffTj_o.png" width="1200"></p> 
<p><img alt="" height="178" src="https://images2.imgbox.com/ed/31/FnNMtEDa_o.png" width="1200"></p> 
<p> <img alt="" height="635" src="https://images2.imgbox.com/93/b9/jm1JlqZQ_o.png" width="1200"></p> 
<p><img alt="" height="241" src="https://images2.imgbox.com/2b/e5/6WyfN2pf_o.png" width="778"></p> 
<p id="uec0d32d1">通过以上的测试可以看出，我们已经开启了全局延迟加载策略。</p> 
<p id="ucc4b49da">开启全局延迟加载之后，所有的sql都会支持延迟加载，如果某个sql你不希望它支持延迟加载怎么办呢？将fetchType设置为eager：</p> 
<pre><code class="language-XML">&lt;resultMap id="studentResultMap" type="Student"&gt;
  &lt;id property="sid" column="sid"/&gt;
  &lt;result property="sname" column="sname"/&gt;
  &lt;association property="clazz"
               select="com.powernode.mybatis.mapper.ClazzMapper.selectByCid"
               column="cid"
               fetchType="eager"/&gt;
&lt;/resultMap&gt;</code></pre> 
<p><img alt="" height="242" src="https://images2.imgbox.com/b3/53/F9vIRWDx_o.png" width="767"></p> 
<p id="u717a2ad6">这样的话，针对某个特定的sql，你就关闭了延迟加载机制。</p> 
<p id="ueda7c5c7">后期我们要不要开启延迟加载机制，主要看实际的业务需求是怎样的。</p> 
<p></p> 
<h3 id="%E9%AB%98%E7%BA%A7%E6%98%A0%E5%B0%84%E4%B9%8B%E4%B8%80%E5%AF%B9%E5%A4%9A">高级映射之一对多</h3> 
<p>从班级的角度去查询学生信息。班级只有一个，而一个班级有N个学生，所以是一对多</p> 
<p>需求：查询一个班级信息，包括cid、cname、sid、sname。</p> 
<p><img alt="" height="605" src="https://images2.imgbox.com/a6/67/Prh17UkZ_o.png" width="1132"></p> 
<p></p> 
<p>前期工作：</p> 
<p>在原来的Clazz.java 这个pojo类中添加一个集合private List&lt;Student&gt; students;并且重写toString、以及为他设置get、set方法。</p> 
<pre><code class="language-java">//接口编写
//根据班级id查询班级信息{班级编号、班级名称、班级学生信息}
Clazz selectClazzByCid2(Integer cid);</code></pre> 
<pre><code class="language-XML">//sqlMapper.xml编写
&lt;resultMap id="clazzResultMapByCid" type="Clazz"&gt;
        &lt;id property="cid" column="cid"/&gt;
        &lt;result property="cname" column="cname"/&gt;
        &lt;collection property="students" ofType="Student"&gt;
            &lt;id property="sid" column="sid"/&gt;
            &lt;result property="sname" column="sname"/&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;
    &lt;select id="selectClazzByCid2" resultMap="clazzResultMapByCid"&gt;
        select c.cid,c.cname,s.sid,s.sname from t_clazz as c
        left join t_stu as s
        on c.cid = s.cid
        where c.cid = #{cid}
    &lt;/select&gt;


//先写查询语句在写映射标签resultMap 
在这里resultMap 不同于多对一里面的association，
在多对一的时候我这里面关联的是一个班级信息只包含cid、cname那也就是一个对象。
但是在这里多对一的情况下是一个班级对象关联多个学生，
那这个collection也是集合的意思，这很明显是关联一个集合的意思。
property指定Clzzz对象中的属性，ofType代表的是集合中元素对应的pojo类</code></pre> 
<pre><code class="language-java">    @Test
    public void testSelectClazzByCid(){
        SqlSession sqlSession = SqlSessionUtil.getSession();
        ClazzMapper mapper = sqlSession.getMapper(ClazzMapper.class);
        Clazz clazz = mapper.selectClazzByCid2(1001);
        System.out.println(clazz);
        sqlSession.close();
    }</code></pre> 
<blockquote> 
 <p>//查询结果</p> 
 <p>Clazz{cid=1001, cname='高三一班', students=[Student{sid=2, sname='李四', clazz=null}, Student{sid=3, sname='王五', clazz=null}, Student{sid=5, sname='钱七', clazz=null}]}</p> 
</blockquote> 
<p>注意看，这里面的clazz为null，为什么？</p> 
<blockquote> 
 <p>因为我再 </p> 
 <p>&lt;collection property="students" ofType="Student"&gt;<br>             &lt;id property="sid" column="sid"/&gt;<br>             &lt;result property="sname" column="sname"/&gt;<br> &lt;/collection&gt;</p> 
 <p>这里面没有对Student这个关联的映射类做映射，</p> 
 <p>为什么映射？</p> 
 <p>因为这里必须得让他为null，在Studen类中包含一个Clazz，而Clazz类中又包含一个Student类，那这里要是进行映射的话他底层会不断的重复创建这两个类对象。</p> 
 <p></p> 
</blockquote> 
<p></p> 
<p></p> 
<p></p> 
<h2 id="kVguw">十四、MyBatis的缓存</h2> 
<p id="ude32e015">缓存：cache</p> 
<p id="ud2db54b0">缓存的作用：通过减少IO的方式，来提高程序的执行效率。</p> 
<p id="ua7a1cc73">mybatis的缓存：将select语句的查询结果放到缓存（内存）当中，下一次还是这条select语句的话，直接从缓存中取，不再查数据库。一方面是减少了IO。另一方面不再执行繁琐的查找算法。效率大大提升。</p> 
<p id="ud15d6d76">mybatis缓存包括：</p> 
<blockquote> 
 <ul><li id="uf1a1d592">一级缓存：将查询到的数据存储到SqlSession中。</li><li id="uc6066353">二级缓存：将查询到的数据存储到SqlSessionFactory中。</li><li id="ub5666e38">或者集成其它第三方的缓存：比如EhCache【Java语言开发的】、Memcache【C语言开发的】等。</li></ul> 
</blockquote> 
<p id="u16ce404a"><strong>缓存只针对于DQL语句，也就是说缓存机制只对应select语句。</strong></p> 
<h3 id="GKwAH">14.1 一级缓存</h3> 
<p id="ubc2d70a4">一级缓存默认是开启的。不需要做任何配置。</p> 
<p id="u3af97be2">原理：只要使用同一个SqlSession对象执行同一条SQL语句，就会走缓存。</p> 
<p id="u5486b092">模块名：mybatis-010-cache</p> 
<pre><code class="language-XML">package com.powernode.mybatis.mapper;

import com.powernode.mybatis.pojo.Car;

public interface CarMapper {

    /**
     * 根据id获取Car信息。
     * @param id
     * @return
     */
    Car selectById(Long id);
}
</code></pre> 
<pre><code class="language-XML">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;

&lt;mapper namespace="com.powernode.mybatis.mapper.CarMapper"&gt;

  &lt;select id="selectById" resultType="Car"&gt;
    select * from t_car where id = #{id}
  &lt;/select&gt;

&lt;/mapper&gt;</code></pre> 
<p></p> 
<pre><code class="language-XML">package com.powernode.mybatis.test;

import com.powernode.mybatis.mapper.CarMapper;
import com.powernode.mybatis.pojo.Car;
import com.powernode.mybatis.utils.SqlSessionUtil;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.Test;

public class CarMapperTest {

    @Test
    public void testSelectById() throws Exception{
        // 注意：不能使用我们封装的SqlSessionUtil工具类。
        SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();
        SqlSessionFactory sqlSessionFactory = builder.build(Resources.getResourceAsStream("mybatis-config.xml"));

        SqlSession sqlSession1 = sqlSessionFactory.openSession();

        CarMapper mapper1 = sqlSession1.getMapper(CarMapper.class);
        Car car1 = mapper1.selectById(83L);
        System.out.println(car1);

        CarMapper mapper2 = sqlSession1.getMapper(CarMapper.class);
        Car car2 = mapper2.selectById(83L);
        System.out.println(car2);

        SqlSession sqlSession2 = sqlSessionFactory.openSession();

        CarMapper mapper3 = sqlSession2.getMapper(CarMapper.class);
        Car car3 = mapper3.selectById(83L);
        System.out.println(car3);

        CarMapper mapper4 = sqlSession2.getMapper(CarMapper.class);
        Car car4 = mapper4.selectById(83L);
        System.out.println(car4);

    }
}
</code></pre> 
<p id="ubd4056a5">执行结果：</p> 
<p id="u98c93cea"><img alt="" height="391" src="https://images2.imgbox.com/cb/27/6sBHM2gm_o.png" width="1092"></p> 
<p></p> 
<p id="u29b98e56">什么情况下不走缓存？</p> 
<blockquote> 
 <ul><li id="u2f964c3f">第一种：不同的SqlSession对象。</li><li id="u8c7444e7">第二种：查询条件变化了。</li></ul> 
</blockquote> 
<p id="uf63897ed">一级缓存失效情况包括两种：</p> 
<blockquote> 
 <ul><li id="u23162626">第一种：第一次查询和第二次查询之间，手动清空了一级缓存。</li><li>手动清空一级缓存：sqlSession.clearCache();</li><li>第二种：第一次查询和第二次查询之间，执行了增删改操作。【这个增删改和哪张表没有关系，只要有insert delete update操作，一级缓存就失效。】</li></ul> 
</blockquote> 
<pre id="AxR1A"></pre> 
<p> <img alt="" height="852" src="https://images2.imgbox.com/59/a8/gMpNc1L8_o.png" width="1133"></p> 
<p id="ufb7ec8ed">执行结果：</p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/c7/17/jVfw7Lnu_o.png"></p> 
<h3 id="eWTHI">14.2 二级缓存</h3> 
<p id="u9bf5be84">二级缓存的范围是SqlSessionFactory。</p> 
<p id="u0e758169">使用二级缓存需要具备以下几个条件：</p> 
<blockquote> 
 <ol><li id="ufa15a54d">&lt;setting name="cacheEnabled" value="true"&gt; 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。默认就是true，无需设置。</li><li id="u061caa7d">在需要使用二级缓存的SqlMapper.xml文件中添加配置：&lt;cache /&gt;</li><li id="u6741b8c2">使用二级缓存的实体类对象必须是可序列化的，也就是必须实现java.io.Serializable接口</li><li id="ua715a36e">SqlSession对象关闭或提交之后，一级缓存中的数据才会被写入到二级缓存当中。此时二级缓存才可用。</li></ol> 
</blockquote> 
<p id="ufb8f98e3">测试二级缓存：</p> 
<p><img alt="" height="333" src="https://images2.imgbox.com/ef/08/1NqRhUAc_o.png" width="691"></p> 
<p><img alt="" height="598" src="https://images2.imgbox.com/9b/a8/j5WfVGsC_o.png" width="1200"></p> 
<p></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/8a/96/aXq5Ztgr_o.png"></p> 
<p id="u8bba2260"><strong>二级缓存的失效：只要两次查询之间出现了增删改操作。二级缓存就会失效。【一级缓存也会失效】</strong></p> 
<p id="ub7b12ddb"><strong>二级缓存的相关配置：</strong></p> 
<p class="img-center"><img alt="" src="https://images2.imgbox.com/20/e6/TxySQ4cl_o.png"></p> 
<p><img alt="" height="665" src="https://images2.imgbox.com/bd/dd/snpGnURV_o.png" width="1200"></p> 
<p><img alt="" height="282" src="https://images2.imgbox.com/67/2c/2GG7x3pS_o.png" width="1200"></p> 
<p></p> 
<pre><code class="language-XML">//pom.xml
&lt;!--mybatis集成ehcache的组件--&gt;
&lt;dependency&gt;
  &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt;
  &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt;
  &lt;version&gt;1.2.2&lt;/version&gt;
&lt;/dependency&gt;</code></pre> 
<pre><code class="language-XML">
//ehcache.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd"
         updateCheck="false"&gt;
    &lt;!--磁盘存储:将缓存中暂时不使用的对象,转移到硬盘,类似于Windows系统的虚拟内存--&gt;
    &lt;diskStore path="e:/ehcache"/&gt;
  
    &lt;!--defaultCache：默认的管理策略--&gt;
    &lt;!--eternal：设定缓存的elements是否永远不过期。如果为true，则缓存的数据始终有效，如果为false那么还要根据timeToIdleSeconds，timeToLiveSeconds判断--&gt;
    &lt;!--maxElementsInMemory：在内存中缓存的element的最大数目--&gt;
    &lt;!--overflowToDisk：如果内存中数据超过内存限制，是否要缓存到磁盘上--&gt;
    &lt;!--diskPersistent：是否在磁盘上持久化。指重启jvm后，数据是否有效。默认为false--&gt;
    &lt;!--timeToIdleSeconds：对象空闲时间(单位：秒)，指对象在多长时间没有被访问就会失效。只对eternal为false的有效。默认值0，表示一直可以访问--&gt;
    &lt;!--timeToLiveSeconds：对象存活时间(单位：秒)，指对象从创建到失效所需要的时间。只对eternal为false的有效。默认值0，表示一直可以访问--&gt;
    &lt;!--memoryStoreEvictionPolicy：缓存的3 种清空策略--&gt;
    &lt;!--FIFO：first in first out (先进先出)--&gt;
    &lt;!--LFU：Less Frequently Used (最少使用).意思是一直以来最少被使用的。缓存的元素有一个hit 属性，hit 值最小的将会被清出缓存--&gt;
    &lt;!--LRU：Least Recently Used(最近最少使用). (ehcache 默认值).缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存--&gt;
    &lt;defaultCache eternal="false" maxElementsInMemory="1000" overflowToDisk="false" diskPersistent="false"
                  timeToIdleSeconds="0" timeToLiveSeconds="600" memoryStoreEvictionPolicy="LRU"/&gt;

&lt;/ehcache&gt;</code></pre> 
<p id="ufe1ae437">第三步：修改SqlMapper.xml文件中的&lt;cache/&gt;标签，添加type属性。</p> 
<pre><code class="language-XML">//CarMapper.xml
&lt;cache type="org.mybatis.caches.ehcache.EhcacheCache"/&gt;</code></pre> 
<p>第四步：编写测试程序使用。</p> 
<pre><code class="language-XML">@Test
public void testSelectById2() throws Exception{
    SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream("mybatis-config.xml"));
    
    SqlSession sqlSession1 = sqlSessionFactory.openSession();
    CarMapper mapper1 = sqlSession1.getMapper(CarMapper.class);
    Car car1 = mapper1.selectById(83L);
    System.out.println(car1);
    
    sqlSession1.close();
    
    SqlSession sqlSession2 = sqlSessionFactory.openSession();
    CarMapper mapper2 = sqlSession2.getMapper(CarMapper.class);
    Car car2 = mapper2.selectById(83L);
    System.out.println(car2);
}</code></pre> 
<p> <img alt="" height="400" src="https://images2.imgbox.com/36/76/Q4xdGG1D_o.png" width="1129"></p> 
<p></p> 
<h2 id="mybatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B">mybatis逆向工程</h2> 
<p id="ua21f659a">所谓的逆向工程是：根据数据库表逆向生成Java的pojo类，SqlMapper.xml文件，以及Mapper接口类等。</p> 
<p id="uab3ee079">要完成这个工作，需要借助别人写好的逆向工程插件。</p> 
<p id="ub584f53d">思考：使用这个插件的话，需要给这个插件配置哪些信息？</p> 
<blockquote> 
 <ul><li id="u870cc71c">pojo类名、包名以及生成位置。</li><li id="u5b9584ec">SqlMapper.xml文件名以及生成位置。</li><li id="u2435fea5">Mapper接口名以及生成位置。</li><li id="u04a0b625">连接数据库的信息。</li><li id="u8a594199">指定哪些表参与逆向工程。</li><li id="ud650ca4e">......</li></ul> 
</blockquote> 
<p>这个逆向工程用到再说吧，下面还有一个注解式开发，这个很简单的，一般来说他只能用于简单的增删改查操作，对复杂的增删改查用注解式开发就显得很累赘了，有兴趣自己去了解吧</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/5fe5e70ed73c8b459c2976675a234377/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">MySQL2——基本操作</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/16df5b98d4459462386a106f37f22ca9/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">【ESP8266 快速入门】硬件：ESP12S/ESP12F最小系统设计及typeC自动下载电路设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>