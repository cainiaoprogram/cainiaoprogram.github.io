<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>毕业设计--2020.02.18 奇耘4.2寸墨水屏的程序设计思路分享 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="毕业设计--2020.02.18 奇耘4.2寸墨水屏的程序设计思路分享" />
<meta property="og:description" content="毕设中我使用了奇耘的4.2寸墨水屏，官方的范例代码给出了一些局部刷新的例子，但是我认为官方给的代码太过于简单实现的功能也不是我想要的，所以对先有的官方的代码进行了一些改进，让这一套代码更适合于我自己的毕业设计。
以下的只有程序思路， 程序还没有完全的完善，就不放出来 误导别人了（代码太烂了）。而且作为毕业设计的一部分 至少要等我毕业了再开源 首先先分享一下这块屏幕的特性
这款屏幕的分辨率是400*300 的 DPI是120 看起来颗粒感还行不是那么的强烈。
屏幕的刷新方式定义成这样， 我用的是侧方向用的屏幕 屏幕的方向设置貌似比较麻烦，我也没太过深入的了解，参数都是一个个实验找到的、、、、、
这是我的屏幕的方位定义，我的程序的逻辑是这样的
第一 整个显示得数据都是在内存中保存的，我在内存中开辟了一个15000（300*400/8）byte的数组，这个数组用于保存各个点的bit信息，在进行 字符显示的时候我就向指定的内存地址写入新的数据，然后执行全屏刷新操作（这里是针对全屏刷新）
当进行局部刷新的时候，我们的墨水屏驱动器需要我们输入以前的数据然后再输入最新的数据以此来达到局部刷新的目的。
（我猜测是需要前后的数据去进行对比，决定翻转哪一些墨水颗粒）
在这种背景下，我设计了两个函数 这两个函数的作用很简单，就是设置一个点的 bit值到指定的位置或者是获取一个点的bit值（这里提一嘴，这个算法肯定有更优化的办法，比如一次操作8个bit 但是我为了减少逻辑复杂度就直接采用了这个笨的办法，一次只读或者写一个bit ），这两个函数就是整个系统的一个对外的接口，我们可以很轻易的把以前的 OLED显示函数迁移过来（其实我就是这么干的），一次只设置一个点的值
通过这样的操作 我可以很简单的写出我自己的墨水屏相关的显示函数，毕竟各种字符 图片本质都是一个个点阵。
相比较于OLED的程序而言，墨水屏的程序上面添加了一个全局刷新和局部刷新的概念， 而又因为局部刷新我需要向墨水屏的驱动芯片提供先前的显示内容所以操作有有了一点点的不同
这一部分我的操作是这样的 ： 第一步： 声明一个数组 然后将你要修改的区域 的数据读到一个数组（p_Before[xxx]）里面去（数据其实是保存在内部的内存 数组中， 就是数据从数组搬到另一个数组） 这里用到get point 函数 而且为了程序尽可能简单 我还对 Y坐标进行了 对8取整 ,
然后修改显示内容，这一步还是set point函数， 使用Set_point（） 函数 我们直接对内部的显存进行修改， 然后再次调用 EPD_COPY_AREA() 这个函数，将最新的数据数组提取出来
；然后 设置好参数 主要是刷新的区域的起始点坐标 然后就是 两次提取出来的数组的信息
void EPD_partial_display(u16 x_start,u16 x_end,u16 y_start,u16 y_end ,const unsigned char *old_data,const unsigned char *new_data,unsigned char mode)" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/1a5e147ca3e74d22ac369cbb9c0e76b6/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-26T20:36:49+08:00" />
<meta property="article:modified_time" content="2020-06-26T20:36:49+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">毕业设计--2020.02.18 奇耘4.2寸墨水屏的程序设计思路分享</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p>毕设中我使用了奇耘的4.2寸墨水屏，官方的范例代码给出了一些局部刷新的例子，但是我认为官方给的代码太过于简单实现的功能也不是我想要的，所以对先有的官方的代码进行了一些改进，让这一套代码更适合于我自己的毕业设计。</p> 
<p><span style="color:#f33b45;">以下的只有程序思路， 程序还没有完全的完善，就不放出来 误导别人了（代码太烂了）。而且作为毕业设计的一部分 至少要等我毕业了再开源 </span></p> 
<p>首先先分享一下这块屏幕的特性</p> 
<p><img alt="" height="289" src="https://images2.imgbox.com/61/18/hOMjBJjc_o.png" width="921">这款屏幕的分辨率是400*300 的 DPI是120  看起来颗粒感还行不是那么的强烈。</p> 
<p><img alt="" height="302" src="https://images2.imgbox.com/84/8c/5vlXyosr_o.png" width="825"></p> 
<p>屏幕的刷新方式定义成这样，  我用的是侧方向用的屏幕  屏幕的方向设置貌似比较麻烦，我也没太过深入的了解，参数都是一个个实验找到的、、、、、</p> 
<p><img alt="" height="663" src="https://images2.imgbox.com/fb/cc/t5NLHa1U_o.png" width="572"></p> 
<p>这是我的屏幕的方位定义，我的程序的逻辑是这样的</p> 
<p>第一 整个显示得数据都是在内存中保存的，我在内存中开辟了一个15000（300*400/8）byte的数组，这个数组用于保存各个点的bit信息，在进行 字符显示的时候我就向指定的内存地址写入新的数据，然后执行全屏刷新操作（这里是针对全屏刷新）</p> 
<p>当进行局部刷新的时候，我们的墨水屏驱动器需要我们输入以前的数据然后再输入最新的数据以此来达到局部刷新的目的。</p> 
<p>（我猜测是需要前后的数据去进行对比，决定翻转哪一些墨水颗粒）</p> 
<p>在这种背景下，我设计了两个函数  <img alt="" height="294" src="https://images2.imgbox.com/c5/ff/FOknOWzL_o.png" width="591"></p> 
<p>这两个函数的作用很简单，就是设置一个点的 bit值到指定的位置或者是获取一个点的bit值（这里提一嘴，这个算法肯定有更优化的办法，比如一次操作8个bit  但是我为了减少逻辑复杂度就直接采用了这个笨的办法，一次只读或者写一个bit ），这两个函数就是整个系统的一个对外的接口，我们可以很轻易的把以前的 OLED显示函数迁移过来（其实我就是这么干的），一次只设置一个点的值</p> 
<p><img alt="" height="641" src="https://images2.imgbox.com/5f/93/bgwoRfbf_o.png" width="1200"></p> 
<p>通过这样的操作  我可以很简单的写出我自己的墨水屏相关的显示函数，毕竟各种字符 图片本质都是一个个点阵。</p> 
<p> </p> 
<p>相比较于OLED的程序而言，墨水屏的程序上面添加了一个全局刷新和局部刷新的概念， 而又因为局部刷新我需要向墨水屏的驱动芯片提供先前的显示内容所以操作有有了一点点的不同</p> 
<p>这一部分我的操作是这样的  ： 第一步： 声明一个数组     然后将你要修改的区域 的数据读到一个数组（p_Before[xxx]）里面去（数据其实是保存在内部的内存 数组中， 就是数据从数组搬到另一个数组）  这里用到get point 函数  而且为了程序尽可能简单 我还对 Y坐标进行了 对8取整  ,</p> 
<p><img alt="" height="374" src="https://images2.imgbox.com/74/e1/GgL1enMf_o.png" width="520"></p> 
<p>然后修改显示内容，这一步还是set point函数， 使用Set_point（） 函数 我们直接对内部的显存进行修改，  然后再次调用 EPD_COPY_AREA() 这个函数，将最新的数据数组提取出来</p> 
<p>；然后 设置好参数  主要是刷新的区域的起始点坐标  然后就是 两次提取出来的数组的信息</p> 
<p>void EPD_partial_display(u16 x_start,u16 x_end,u16 y_start,u16 y_end ,const unsigned char *old_data,const unsigned char *new_data,unsigned char mode)</p> 
<p><img alt="" height="188" src="https://images2.imgbox.com/9f/54/xwKRSPho_o.png" width="726"></p> 
<p>这样就可以完成局部的刷新了。</p> 
<p>我们现在可以实现以上的两个功能之后就可以进行 应用层的代码的开发了。比如我们需要显示 字符，那么就是将以前的 OLED的画点的操作转移到 EPD上面来实现，至于是全局刷新还是局部刷新就是上面哪两个函数来负责的全局刷新就直接等所有的数据更新完  在向 EPD 发送一次数据， 如果是局部刷新就先提取刷新区域的数据，在更新显存，再次提取，然后就将两次的数据发送给EPD。 有了字符显示函数  那么数字显示也就不是问题了</p> 
<p><img alt="" height="498" src="https://images2.imgbox.com/96/7c/m1CHT5pq_o.png" width="691"></p> 
<p>这是OLED的数字显示，本质就是 将数字转化成字符串，然后调用字符串显示函数。</p> 
<p>显示中文的话需要有中文的字库支持，方法也是大同小异  判断文字是什么，找字库数据，对应数据去进行画点</p> 
<p><img alt="" height="559" src="https://images2.imgbox.com/93/6e/WZS4kWdm_o.png" width="744"></p> 
<p><img alt="" height="483" src="https://images2.imgbox.com/09/0d/E49hnvpn_o.png" width="646"></p> 
<p>代码我就暂时不分享了，写的太烂了，而且对很多的原理也做不到真正的理解  望见谅。  如果您刚好也在开发这款屏幕可以留言交流一下 </p> 
<p> </p> 
<p> </p> 
<p> </p> 
<p> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/f08d57555c8945974980641b7eb01850/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">以高通camera 申请ion内存看dma-buf</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/8c6204e7cd2650960bc8c1a5775d4c0a/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">用cookie保存并读取用户登录信息（简易）</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>