<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>深入理解LINUX下动态库链接器/加载器ld-linux.so.2 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="深入理解LINUX下动态库链接器/加载器ld-linux.so.2" />
<meta property="og:description" content="最近在Linux 环境下开发，搞了好几天 Compiler 和 linker，觉得有必要来写一篇关于Linux环境下 ld.so的文章了，google上搜索了很多相关介绍性的文档，发现国内百度上却很少有相关类文档，觉得有必要来梳理一下：
ld-linux.so.2 是linux下的动态库加载器/链接器，这篇文章主要来讲一下 ld-linux.so.2 是如何和Linux 以及相关应用打交道的。
1. 什么是 ld.linux.so ? 很多现代应用都是通过动态编译链接的，当一个 需要动态链接 的应用被操作系统加载时，系统必须要 定位 然后 加载它所需要的所有动态库文件。 在Linux环境下，这项工作是由ld-linux.so.2来负责完成的，我们可以通过 ldd 命令来查看一个 应用需要哪些依赖的动态库:
$ ldd `which ls` linux-gate.so.1 =&gt; (0xb7fff000) librt.so.1 =&gt; /lib/librt.so.1 (0x00b98000) libacl.so.1 =&gt; /lib/libacl.so.1 (0x00769000) libselinux.so.1 =&gt; /lib/libselinux.so.1 (0x00642000) libc.so.6 =&gt; /lib/libc.so.6 (0x007b2000) libpthread.so.0 =&gt; /lib/libpthread.so.0 (0x00920000) /lib/ld-linux.so.2 (0x00795000) libattr.so.1 =&gt; /lib/libattr.so.1 (0x00762000) libdl.so.2 =&gt; /lib/libdl.so.2 (0x0091a000) libsepol.so.1 =&gt; /lib/libsepol.so.1 (0x0065b000) 当最常见的ls小程序加载时，操作系统会将 控制权 交给 ld-linux." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/49a5ec2717c6d7fc2a7fb6aac1aa00c0/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2016-06-17T17:18:07+08:00" />
<meta property="article:modified_time" content="2016-06-17T17:18:07+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">深入理解LINUX下动态库链接器/加载器ld-linux.so.2</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p><br> </p> 
<p>最近在Linux 环境下开发，搞了好几天 Compiler 和 linker，觉得有必要来写一篇关于Linux环境下 ld.so的文章了，google上搜索了很多相关介绍性的文档，发现国内百度上却很少有相关类文档，觉得有必要来梳理一下：</p> 
<p><br> </p> 
<p><br> </p> 
<p>ld-linux.so.2 是linux下的动态库加载器/链接器，这篇文章主要来讲一下 ld-linux.so.2 是如何和Linux 以及相关应用打交道的。</p> 
<p><br> </p> 
<h2>1. 什么是 ld.linux.so ? </h2> 
<p>很多现代应用都是通过动态编译链接的，当一个 需要动态链接 的应用被操作系统加载时，系统必须要 定位 然后 加载它所需要的所有动态库文件。 在Linux环境下，这项工作是由ld-linux.so.2来负责完成的，我们可以通过 ldd 命令来查看一个 应用需要哪些依赖的动态库:</p> 
<p></p> 
<pre class="literal-block" style="line-height:16.25px; border:thin solid black; padding:5px; margin-left:20px; color:rgb(0,0,60); background-color:rgb(208,208,208)">$ ldd `which ls`
      linux-gate.so.1 =&gt;  (0xb7fff000)
      librt.so.1 =&gt; /lib/librt.so.1 (0x00b98000)
      libacl.so.1 =&gt; /lib/libacl.so.1 (0x00769000)
      libselinux.so.1 =&gt; /lib/libselinux.so.1 (0x00642000)
      libc.so.6 =&gt; /lib/libc.so.6 (0x007b2000)
      libpthread.so.0 =&gt; /lib/libpthread.so.0 (0x00920000)
      /lib/ld-linux.so.2 (0x00795000)
      libattr.so.1 =&gt; /lib/libattr.so.1 (0x00762000)
      libdl.so.2 =&gt; /lib/libdl.so.2 (0x0091a000)
      libsepol.so.1 =&gt; /lib/libsepol.so.1 (0x0065b000)</pre> 
<br> 
<p></p> 
<p>当最常见的ls小程序加载时，操作系统会将 控制权 交给 ld-linux.so 而不是 交给程序正常的进入地址。 ld-linux.so.2 会寻找然后加载所有需要的库文件，然后再将控制权交给应用的起始入口。</p> 
<p><strong>上面的ls在启动时，就需要ld-linux.so加载器将所有的动态库加载后然后再将控制权移交给ls程序的入口。</strong></p> 
<p><br> </p> 
<p>ld-linux.so.2 man page给我们更高一层的全局介绍， 它是在 链接器（通常是ld）在运行状态下的部件，用来定位和加载动态库到应用的运行地址（或者是运行内存）当中去。通常，动态链接是 在连接阶段当中 隐式指定的。 gcc -W1 options -L/path/included -lxxx 会将 options 传递到ld 然后指定相应的动态库加载。 ELF 文件提供了相应的加载信息， GCC包含了一个特殊的 ELF 头： INTERP， 这个 INTERP指定了 加载器的路径，我们可以用readelf 来查看相应的程序</p> 
<p><br> </p> 
<p></p> 
<pre class="literal-block" style="line-height:16.25px; border:thin solid black; padding:5px; margin-left:20px; background-color:rgb(208,208,208)"><span style="color:rgb(0,0,60)">$ readelf -l a.out

Elf file type is EXEC (Executable file)
Entry point 0x8048310
There are 9 program headers, starting at offset 52

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  PHDR           0x000034 0x08048034 0x08048034 0x00120 0x00120 R E 0x4
  INTERP         0x000154 0x08048154 0x08048154 0x00013 0x00013 R   0x1
      </span><span style="color:#ff0000">[Requesting program interpreter: /lib/ld-linux.so.2]</span><span style="color:#00003c">
  LOAD           0x000000 0x08048000 0x08048000 0x004cc 0x004cc R E 0x1000
  LOAD           0x000f0c 0x08049f0c 0x08049f0c 0x0010c 0x00110 RW  0x1000
. . .</span></pre> 
<br> 
<p></p> 
<p>ELF 规格要求，假如 PT_INTERP 存在的话，操作系统必须创建这个 interpreter文件的运行映射，而不是这个程序本身， 控制权会交给这个interpreter，用来定位和加载所有的动态库，</p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p> 
<p><br> </p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/24e32764d37acb49ea31ec07d6e69d37/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">指代消解系列（1）-综述</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/409e86d39e36d997008358e19272298e/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">iOS开发之第三方登录QQ -- 史上最全最新第三方登录QQ方式实现</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>