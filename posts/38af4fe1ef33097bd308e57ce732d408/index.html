<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>Android RIL介绍 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="Android RIL介绍" />
<meta property="og:description" content="文章目录 一、需求二、相关概念2.1 IMS2.2 Volte2.3 CS域与PS域2.3.1 CS域2.3.2 PS域 2.4 VOIP2.5 URC消息2.6 HIDL 三、环境四、设计思路4.1 RIL结构图4.2 RIL相关模块介绍4.2.1 Dialer模块4.2.2 TeleService模块4.2.2.1 TeleService启动 4.2.3 TelecomService模块4.2.3.1 TelecomService启动4.2.3.2 TeleComService消息处理模型 4.2.4 telephony-common模块4.2.5 Telecom_Framewrok模块4.2.6 Telephony_Framewrok模块4.2.7 RIL模块4.2.7.1 RILD守护进程4.2.7.1.1 RILD启动 4.2.7.2 libril共享库4.2.7.3 librefrence共享库 4.3 RIL相关模块通讯4.3.1 通讯架构图 五、详细设计5.1 Dialer拨号5.1.1 Dialer应用拨号时序图5.1.2 Dialer拨号界面显示5.1.3 Dialer权限检查5.1.4 与TelecomService通信 5.2 TelecomService处理拨号流程5.2.1 TelecomService处理拨号时序图5.2.2 往InCallService发送请求5.2.3 广播下发消息5.2.4 往TeleService下发请求 5.3 TeleService下发拨号请求5.3.1 TeleService下发拨号请求时序图5.3.2 TeleService类图5.3.3 TelephonyConnectionService启动5.3.4 TeleService拨号请求下发（GsmCdmaPhone）5.3.5 TeleService拨号请求下发（ImsPhone）5.3.5.1 时序图5.3.5.2 IMS与CDMA、GSM时序切换 5.4 RILD处理拨号请求5.4.1 RILD拨号请求消息下发时序图5.4.2 RILJ往RILD发送指令5.4.3 RILD接收到RILJ指令5.4.4 RILD和reference侧消息传递5.4.5 reference侧接收到消息5.4.6 reference侧将消息发送至modem侧5.4.7 modem侧发送消息至reference侧5.4.8 reference侧轮询modem指令 六、RIL指令6.1 RILJ主动发送指令6.2 RILJ被动接收指令 七、参考资料 一、需求 1、了解IMS相关知识体系" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/38af4fe1ef33097bd308e57ce732d408/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-09-21T10:36:17+08:00" />
<meta property="article:modified_time" content="2023-09-21T10:36:17+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">Android RIL介绍</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-light">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <p></p> 
<div class="toc"> 
 <h4>文章目录</h4> 
 <ul><li><a href="#_1" rel="nofollow">一、需求</a></li><li><a href="#_8" rel="nofollow">二、相关概念</a></li><li><ul><li><a href="#21_IMS_10" rel="nofollow">2.1 IMS</a></li><li><a href="#22_Volte_17" rel="nofollow">2.2 Volte</a></li><li><a href="#23_CSPS_21" rel="nofollow">2.3 CS域与PS域</a></li><li><ul><li><a href="#231_CS_24" rel="nofollow">2.3.1 CS域</a></li><li><a href="#232_PS_27" rel="nofollow">2.3.2 PS域</a></li></ul> 
   </li><li><a href="#24_VOIP_30" rel="nofollow">2.4 VOIP</a></li><li><a href="#25_URC_33" rel="nofollow">2.5 URC消息</a></li><li><a href="#26_HIDL_36" rel="nofollow">2.6 HIDL</a></li></ul> 
  </li><li><a href="#_39" rel="nofollow">三、环境</a></li><li><a href="#_43" rel="nofollow">四、设计思路</a></li><li><ul><li><a href="#41_RIL_44" rel="nofollow">4.1 RIL结构图</a></li><li><a href="#42_RIL_47" rel="nofollow">4.2 RIL相关模块介绍</a></li><li><ul><li><a href="#421_Dialer_56" rel="nofollow">4.2.1 Dialer模块</a></li><li><a href="#422_TeleService_58" rel="nofollow">4.2.2 TeleService模块</a></li><li><ul><li><a href="#4221_TeleService_60" rel="nofollow">4.2.2.1 TeleService启动</a></li></ul> 
    </li><li><a href="#423_TelecomService_89" rel="nofollow">4.2.3 TelecomService模块</a></li><li><ul><li><a href="#4231_TelecomService_91" rel="nofollow">4.2.3.1 TelecomService启动</a></li><li><a href="#4232_TeleComService_173" rel="nofollow">4.2.3.2 TeleComService消息处理模型</a></li></ul> 
    </li><li><a href="#424_telephonycommon_179" rel="nofollow">4.2.4 telephony-common模块</a></li><li><a href="#425_Telecom_Framewrok_190" rel="nofollow">4.2.5 Telecom_Framewrok模块</a></li><li><a href="#426_Telephony_Framewrok_206" rel="nofollow">4.2.6 Telephony_Framewrok模块</a></li><li><a href="#427_RIL_223" rel="nofollow">4.2.7 RIL模块</a></li><li><ul><li><a href="#4271_RILD_226" rel="nofollow">4.2.7.1 RILD守护进程</a></li><li><ul><li><a href="#42711_RILD_229" rel="nofollow">4.2.7.1.1 RILD启动</a></li></ul> 
     </li><li><a href="#4272_libril_258" rel="nofollow">4.2.7.2 libril共享库</a></li><li><a href="#4273_librefrence_261" rel="nofollow">4.2.7.3 librefrence共享库</a></li></ul> 
   </li></ul> 
   </li><li><a href="#43_RIL_265" rel="nofollow">4.3 RIL相关模块通讯</a></li><li><ul><li><a href="#431__267" rel="nofollow">4.3.1 通讯架构图</a></li></ul> 
  </li></ul> 
  </li><li><a href="#_270" rel="nofollow">五、详细设计</a></li><li><ul><li><a href="#51_Dialer_271" rel="nofollow">5.1 Dialer拨号</a></li><li><ul><li><a href="#511_Dialer_272" rel="nofollow">5.1.1 Dialer应用拨号时序图</a></li><li><a href="#512_Dialer_274" rel="nofollow">5.1.2 Dialer拨号界面显示</a></li><li><a href="#513_Dialer_295" rel="nofollow">5.1.3 Dialer权限检查</a></li><li><a href="#514_TelecomService_311" rel="nofollow">5.1.4 与TelecomService通信</a></li></ul> 
   </li><li><a href="#52_TelecomService_333" rel="nofollow">5.2 TelecomService处理拨号流程</a></li><li><ul><li><a href="#521_TelecomService_334" rel="nofollow">5.2.1 TelecomService处理拨号时序图</a></li><li><a href="#522_InCallService_337" rel="nofollow">5.2.2 往InCallService发送请求</a></li><li><a href="#523__412" rel="nofollow">5.2.3 广播下发消息</a></li><li><a href="#524_TeleService_455" rel="nofollow">5.2.4 往TeleService下发请求</a></li></ul> 
   </li><li><a href="#53_TeleService_503" rel="nofollow">5.3 TeleService下发拨号请求</a></li><li><ul><li><a href="#531_TeleService_504" rel="nofollow">5.3.1 TeleService下发拨号请求时序图</a></li><li><a href="#532_TeleService_506" rel="nofollow">5.3.2 TeleService类图</a></li><li><a href="#533_TelephonyConnectionService_508" rel="nofollow">5.3.3 TelephonyConnectionService启动</a></li><li><a href="#534_TeleServiceGsmCdmaPhone_521" rel="nofollow">5.3.4 TeleService拨号请求下发（GsmCdmaPhone）</a></li><li><a href="#535_TeleServiceImsPhone_544" rel="nofollow">5.3.5 TeleService拨号请求下发（ImsPhone）</a></li><li><ul><li><a href="#5351__546" rel="nofollow">5.3.5.1 时序图</a></li><li><a href="#5352_IMSCDMAGSM_548" rel="nofollow">5.3.5.2 IMS与CDMA、GSM时序切换</a></li></ul> 
   </li></ul> 
   </li><li><a href="#54_RILD_577" rel="nofollow">5.4 RILD处理拨号请求</a></li><li><ul><li><a href="#541_RILD_578" rel="nofollow">5.4.1 RILD拨号请求消息下发时序图</a></li><li><a href="#542_RILJRILD_580" rel="nofollow">5.4.2 RILJ往RILD发送指令</a></li><li><a href="#543_RILDRILJ_602" rel="nofollow">5.4.3 RILD接收到RILJ指令</a></li><li><a href="#544_RILDreference_616" rel="nofollow">5.4.4 RILD和reference侧消息传递</a></li><li><a href="#545_reference_637" rel="nofollow">5.4.5 reference侧接收到消息</a></li><li><a href="#546_referencemodem_666" rel="nofollow">5.4.6 reference侧将消息发送至modem侧</a></li><li><a href="#547_modemreference_690" rel="nofollow">5.4.7 modem侧发送消息至reference侧</a></li><li><a href="#548_referencemodem_729" rel="nofollow">5.4.8 reference侧轮询modem指令</a></li></ul> 
  </li></ul> 
  </li><li><a href="#RIL_759" rel="nofollow">六、RIL指令</a></li><li><ul><li><a href="#61_RILJ_760" rel="nofollow">6.1 RILJ主动发送指令</a></li><li><a href="#62_RILJ_911" rel="nofollow">6.2 RILJ被动接收指令</a></li></ul> 
  </li><li><a href="#_966" rel="nofollow">七、参考资料</a></li></ul> 
</div> 
<p></p> 
<h2><a id="_1"></a>一、需求</h2> 
<p>1、了解IMS相关知识体系<br> 2、Volte<br> 3、拨号相关流程<br> 4、android电话发展背景<br> 5、RILD 与 RILJ、IMS回调消息的机制</p> 
<h2><a id="_8"></a>二、相关概念</h2> 
<h3><a id="21_IMS_10"></a>2.1 IMS</h3> 
<p>        IMS全称是IP Multimedia Subsystem，中文意义为IP多媒体子系统。IMS是一种基于IP基础结构，能够融合数据、话音和移动等网络技术的系统。<br>          <strong>IP</strong> = 基于IP 的传输，基于IP的会话控制，基于IP的业务实现<br>         <strong>Multimedia</strong> = 语音、视频、图片、文本等多种媒体组合，在多种接入基础之上具有不同能力的终端组合<br>         <strong>Subsvstem</strong> = 依赖于现有网络技术和网络设备发展的网络，最大程度重用现有网络系统<br> （我个人理解IMS是一个很大的概念，它不单单特指:IMS服务、IMS PDN等。它类似GSM，WCDMA，LTE一样，是一种体系结构，包含了好多内容）</p> 
<h3><a id="22_Volte_17"></a>2.2 Volte</h3> 
<p>        VoLTE是Voice over LTE的缩写，是基于 IMS 的语音业务。VoLTE基于IP多媒体子系统（IMS）网络，在LTE上使用为控制层面和语音服务的媒体层面特制的配置文件，使语音服务作为数据流在LTE数据承载网络中进行传输，而不再需要维护和依赖传统的电路交换语音网络。通俗的来讲，就是语音通话建立在4G流量之上，无需再依托于2G/3G网，全部承载于4G网络中，最终实现数据与语音业务在同一网络下的统一，使4G网络不再仅仅提供流量数据业务支撑，还提供语音及视频通话支持，让4G网络利用最大化。<br>         移动用户肯定都遇到过这个问题，在玩网络游戏时一则电话打进来，游戏就断网了，这并非手机硬件问题，而是移动4G手机是通过2G信号进行语音通讯，所以通话过程中系统会自动将网络从4G切换到2G。</p> 
<h3><a id="23_CSPS_21"></a>2.3 CS域与PS域</h3> 
<p>        我们了解到的数据传输有两个域，分别是CS域和PS域。我们常说的CS域就是电路交换域，通常用于语音通话，在2G和3G中都有应用到；我们常说的PS域就是分组交换域，通常用于数据业务，在3G、4G和5G中都有应用到。而还有一个IMS（IP多媒体子系统），相当于是PS域上的一个子系统，IMS的存在可以让用户在PS域上同时使用语音通话和数据业务</p> 
<h4><a id="231_CS_24"></a>2.3.1 CS域</h4> 
<p>        CS（Circuit Switched）域，即电路交换域。首先需要建立一条传输数据的连接，建立完成之后开始数据的传输，此连接不会断开，直到数据传输完毕，才可以释放掉连接。所以一条链路只电路交换的特点是独占一条链路，一直用于数据传输。可靠性很高，但不高效。这就相当于是小时候玩的听筒游戏，两个纸杯子之间连着一条线，两个人通话过程中，这条链路是不能断开的，直到通话结束。</p> 
<h4><a id="232_PS_27"></a>2.3.2 PS域</h4> 
<p>        PS域（Packet Switch）表面意思就是分组交换。PS 域不能直接进行语音业务，PS业务就是常见的数据业务，也包括流媒体业务、VOIP等等。具有高效的传输效率，但可靠性没有CS域那么高。</p> 
<h3><a id="24_VOIP_30"></a>2.4 VOIP</h3> 
<p>        VOIP是一个很宽泛的概念，VOIP（Voice over IP）的缩写，只要是通过IP传输的语音电话，都可以称为VOIP。如互联网提供商提供（Skype、微信、teams等）、运营商提供的IMS（LTE时代公认的语音解决方案（VoLTE）。因为VoLTE是运营商在LTE层上附着IMS-PDN进行传输的，相对于纯IP网络的skype、微信网络电话，通话质量会好很多。</p> 
<h3><a id="25_URC_33"></a>2.5 URC消息</h3> 
<p>        URC 是Unsolicited Result Code，即"非请求结果码"。 一般的 AT命令 流程都是控制端发出 命令 ，被控端响应结果码。 但当被控端有事件需要通知控制端时，就会主动发出 URC ，例如有呼叫打入、收到新短信息、自动关机等。</p> 
<h3><a id="26_HIDL_36"></a>2.6 HIDL</h3> 
<p>        HIDL的全称是HAL interface definition language(硬件抽象层接口定义语言) ，是AndroidFramework 与Android HAL之间的接口。HIDL 旨在用于进程间通信(IPC)。Android O(8.0) 之前系统的升级牵扯多方协作，极为麻烦，HIDL机制的推出就是将 framework 与 hal 层分开，使得框架部分可以直接被覆盖、更新，而不需要重新对 HAL 进行编译，这样在系统升级时，OEM 厂商 跳过 SoC厂商，先对 framework 进行升级。</p> 
<h2><a id="_39"></a>三、环境</h2> 
<ol><li>芯片：高通Qcm2290</li><li>版本：Android 11</li></ol> 
<h2><a id="_43"></a>四、设计思路</h2> 
<h3><a id="41_RIL_44"></a>4.1 RIL结构图</h3> 
<p><img src="https://images2.imgbox.com/e0/cd/aWIoPbGu_o.png" alt="在这里插入图片描述"></p> 
<h3><a id="42_RIL_47"></a>4.2 RIL相关模块介绍</h3> 
<table><thead><tr><th>模块</th><th>进程</th><th>介绍</th></tr></thead><tbody><tr><td>Dialer</td><td>com.android.dialer</td><td>负责拨号、呼叫界面显示</td></tr><tr><td>TeleService</td><td>com.android.phone</td><td>负责通话逻辑，如实际向RIL拨号、挂电话，及电话状态如拨号、振铃、接通等的变更。</td></tr><tr><td>TelecomService</td><td>system_server</td><td>负责逻辑控制，是沟通各个进程交互的桥梁。</td></tr><tr><td>telephony-common（RILJ）</td><td>jar，看哪个进程引用，主要是com.android.phone</td><td>主要是phone模块，hal层对应的java层客户端的代码，这个模块的代码就是跟hal下面的C/C++服务进行通信的</td></tr><tr><td>RILD</td><td>RILD</td><td>主要负责接发RILJ指令、Modem指令</td></tr><tr><td>MODEM</td><td>Modem</td><td>Modem是调制解调器的缩写，它是一种用于数字信号和模拟信号之间转换的设备。在手机中，Modem是一个硬件模块，它负责处理与无线网络通信相关的任务，包括数据传输、语音通信和短信等。</td></tr></tbody></table> 
<h4><a id="421_Dialer_56"></a>4.2.1 Dialer模块</h4> 
<p><strong>源码：</strong> LINUX\android\packages\apps\Dialer</p> 
<h4><a id="422_TeleService_58"></a>4.2.2 TeleService模块</h4> 
<p><strong>源码：</strong> LINUX\android\packages\services\Telephony</p> 
<h5><a id="4221_TeleService_60"></a>4.2.2.1 TeleService启动</h5> 
<p>（1）设置persistent标记，此标记AMS会持续保证进程(com.android.phone)存活，意外挂掉也会自动重启。<br> LINUX\android\packages\services\Telephony/AndroidManifest.xml</p> 
<pre><code class="prism language-JAVA">    &lt;application android:name="PhoneApp"
            android:persistent="true"
            ...
            android:directBootAware="true"&gt;
</code></pre> 
<p>（2）SystemServer启动后，ActivityManqgerService服务初始化完成后，启动persistent进程，即Phone模块被启动。<br> LINUX\android\frameworks\base\services\core\java\com\android\server\am\ActivityManagerService.java</p> 
<pre><code class="prism language-JAVA"> void startPersistentApps(int matchFlags) {
        ...
        synchronized (this) {
            try {
                final List&lt;ApplicationInfo&gt; apps = AppGlobals.getPackageManager()
                        .getPersistentApplications(STOCK_PM_FLAGS | matchFlags).getList();
                for (ApplicationInfo app : apps) {
                    if (!"android".equals(app.packageName)) {
                        addAppLocked(app, null, false, null /* ABI override */,
                                ZYGOTE_POLICY_FLAG_BATCH_LAUNCH);
                    }
                }
            } catch (RemoteException ex) {
            }
        }
    }
</code></pre> 
<h4><a id="423_TelecomService_89"></a>4.2.3 TelecomService模块</h4> 
<p><strong>源码：</strong> LINUX\android\packages\services\Telecomm</p> 
<h5><a id="4231_TelecomService_91"></a>4.2.3.1 TelecomService启动</h5> 
<p>Android设备刚开机，SystemServer进程初始化完成启动完系统的核心服务如AMS、PMS后，就会加载系统其它服务，这其中就包含了一个与Telecom服务启动相关的系统服务专门用于加载Telecom：<br> LINUX\android\frameworks\base\services\java\com\android\server\SystemServer.java</p> 
<pre><code class="prism language-JAVA">private void run() {
    ...
    startBootstrapServices(t);
    startCoreServices(t);
    startOtherServices(t);
    ...
}

private void startOtherServices(@NonNull TimingsTraceAndSlog t)
    ...
        //启动Telecom服务的加载类
        t.traceBegin("StartTelecomLoaderService");
        mSystemServiceManager.startService(TelecomLoaderService.class);=
        t.traceEnd();

        //启动telephony注册服务，用于注册监听telephony状态的接口
        t.traceBegin("StartTelephonyRegistry");
        telephonyRegistry = new TelephonyRegistry(context, new TelephonyRegistry.ConfigurationProvider());
        ServiceManager.addService("telephony.registry", telephonyRegistry);
        t.traceEnd();
        ...
        //AMS初始化完成，启动Telecom服务
        mActivityManagerService.systemReady(() -&gt; {
            ...
            mSystemServiceManager.startBootPhase(t, SystemService.PHASE_ACTIVITY_MANAGER_READY);
            ...
        }, t);
    ...
}
</code></pre> 
<p>在TelecomLoaderService类实现Telecom服务的bind工作，完成Telecom的启动<br> LINUX\android\frameworks\base\services\core\java\com\android\server\telecom\TelecomLoaderService.java</p> 
<pre><code class="prism language-JAVA">    private static final ComponentName SERVICE_COMPONENT = new ComponentName(
            "com.android.server.telecom",
            "com.android.server.telecom.components.TelecomService");

    private static final String SERVICE_ACTION = "com.android.ITelecomService";

    @Override
    public void onBootPhase(int phase) {
        if (phase == PHASE_ACTIVITY_MANAGER_READY) {
            ...
            connectToTelecom();
        }
    }

    //连接Telecom服务
    private void connectToTelecom() {
        synchronized (mLock) {
            ...
            TelecomServiceConnection serviceConnection = new TelecomServiceConnection();
            Intent intent = new Intent(SERVICE_ACTION);
            intent.setComponent(SERVICE_COMPONENT);
            int flags = Context.BIND_IMPORTANT | Context.BIND_FOREGROUND_SERVICE
                    | Context.BIND_AUTO_CREATE;

            // Bind to Telecom and register the service
            if (mContext.bindServiceAsUser(intent, serviceConnection, flags, UserHandle.SYSTEM)) {
                mServiceConnection = serviceConnection;
            }
        }
    }

     private class TelecomServiceConnection implements ServiceConnection {
        @Override
        public void onServiceConnected(ComponentName name, IBinder service) {
            try {
                ITelecomLoader telecomLoader = ITelecomLoader.Stub.asInterface(service);//返回TelecomService代理对象
                ITelecomService telecomService = telecomLoader.createTelecomService(mServiceRepo);//返回TelecomService实现类

                SmsApplication.getDefaultMmsApplication(mContext, false);
                ServiceManager.addService(Context.TELECOM_SERVICE, telecomService.asBinder());//将TelecomService实现类注册到serviceManager，以便后续方便引用
            ...
            }
        ...
    }
</code></pre> 
<h5><a id="4232_TeleComService_173"></a>4.2.3.2 TeleComService消息处理模型</h5> 
<p>Telecom是Android的一个系统服务，其主要作用是管理Android系统当前的通话,如来电显示，接听电话，挂断电话等功能，在Telephony模块与上层UI之间起到了一个桥梁的作用。比如，Telephony有接收到新的来电时，首先会告知Telecom,然后由Telecom服务通知上层应用来电信息，并显示来电界面。</p> 
<p><img src="https://images2.imgbox.com/f0/10/4DVHL8sa_o.png" alt="在这里插入图片描述"></p> 
<h4><a id="424_telephonycommon_179"></a>4.2.4 telephony-common模块</h4> 
<p><strong>源码：</strong> LINUX\android\frameworks\opt\telephony<br> telephony-common模块最终编译会生成一个java library，主要是phone模块在引用，hal层对应的java层客户端的代码RILJ，这个模块的代码就是跟hal下面的C/C++服务进行通信的。<br> LINUX\android\frameworks\opt\telephony\Android.bp</p> 
<pre><code class="prism language-JAVA">java_library {
    name: "telephony-common",
    installable: true,
    ...
}
</code></pre> 
<h4><a id="425_Telecom_Framewrok_190"></a>4.2.5 Telecom_Framewrok模块</h4> 
<p>源码：LINUX\android\frameworks\base\telecomm<br> android提供的phone的一些sdk的代码，最终编译完成打包进framework.jar<br> LINUX\android\frameworks\base\Android.bp</p> 
<pre><code class="prism language-JAVA">filegroup {
    name: "framework-telecomm-sources",
    srcs: [
        "telecomm/java/**/*.java",
        "telecomm/java/**/*.aidl",
    ],
    path: "telecomm/java",
}

framework-telecomm-sources =&gt; framework-non-updatable-sources =&gt; framework-non-updatable-sources =&gt; framework-minus-apex =&gt; framework
</code></pre> 
<h4><a id="426_Telephony_Framewrok_206"></a>4.2.6 Telephony_Framewrok模块</h4> 
<p><strong>源码：</strong> LINUX\android\frameworks\base\telephony<br> android提供的phone的一些sdk的代码，最终编译完成打包进framework.jar<br> LINUX\android\frameworks\base\Android.bp</p> 
<pre><code class="prism language-JAVA">filegroup {
    name: "framework-telephony-sources",
    srcs: [
        "telephony/java/**/*.java",
        "telephony/java/**/*.aidl",
    ],
    path: "telephony/java",
}

framework-telephony-sources =&gt; framework-non-updatable-sources =&gt; framework-non-updatable-sources =&gt; framework-minus-apex =&gt; framework
</code></pre> 
<h4><a id="427_RIL_223"></a>4.2.7 RIL模块</h4> 
<p><strong>源码：</strong> LINUX\android\hardware\ril<br> RIL模块由rild守护进程、libril.so、librefrence.so三部分组成：</p> 
<h5><a id="4271_RILD_226"></a>4.2.7.1 RILD守护进程</h5> 
<p><strong>源码：</strong> LINUX\android\hardware\ril\rild<br> RILD主要起到承上启下的作用，作为modem和RILJ的通信的中转站。RILD可分为两部分，一是负责与RILJ通讯的部分，主要通过HIDL通信；另一个是负责与modem交互，主要通过AT指令。</p> 
<h6><a id="42711_RILD_229"></a>4.2.7.1.1 RILD启动</h6> 
<p>（1）开机时，通过RC文件启动RILD进程</p> 
<pre><code class="prism language-JAVA">@LINUX\android\hardware\ril\rild\rild.rc
service vendor.ril-daemon /vendor/bin/hw/rild
    class main
    user radio
    disabled
    group radio cache inet misc audio log readproc wakelock
    capabilities BLOCK_SUSPEND NET_ADMIN NET_RAW
</code></pre> 
<p>（2）RILD启动后，会执行main啊方法，初始化RILD相关操作</p> 
<pre><code class="prism language-c">@LINUX\android\hardware\ril\rild\rild<span class="token punctuation">.</span>c
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    rilInit <span class="token operator">=</span>
        <span class="token punctuation">(</span><span class="token keyword">const</span> RIL_RadioFunctions <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">RIL_Env</span> <span class="token operator">*</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token function">dlsym</span><span class="token punctuation">(</span>dlHandle<span class="token punctuation">,</span> <span class="token string">"RIL_Init"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">//初始化reference，轮询modem指令</span>
    funcs <span class="token operator">=</span> <span class="token function">rilInit</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s_rilEnv<span class="token punctuation">,</span> argc<span class="token punctuation">,</span> rilArgv<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">RLOGD</span><span class="token punctuation">(</span><span class="token string">"RIL_Init rilInit completed"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//在rild注册reference的回调函数</span>
    <span class="token function">RIL_register</span><span class="token punctuation">(</span>funcs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> 
<h5><a id="4272_libril_258"></a>4.2.7.2 libril共享库</h5> 
<p><strong>源码：</strong> LINUX\android\hardware\ril\libril<br> libril.so是共享库，主要负责同上层的通信工作，接收ril的请求，并传递给librefrence_ril.so，同时将librefrence_ril.so返回的消息送给调用进程</p> 
<h5><a id="4273_librefrence_261"></a>4.2.7.3 librefrence共享库</h5> 
<p><strong>源码：</strong> LINUX\android\hardware\ril\reference-ril<br> librefrence_ril.so是共享库，是由各手机厂商自己实现，在rild进程运行中通过dlopen方式加载，主要负责跟modem硬件通信，转换来自libril的请求为AT命令，同时监听Modem的反馈信息给libril</p> 
<h3><a id="43_RIL_265"></a>4.3 RIL相关模块通讯</h3> 
<h4><a id="431__267"></a>4.3.1 通讯架构图</h4> 
<p><img src="https://images2.imgbox.com/39/66/jEO5bDti_o.png" alt="在这里插入图片描述"></p> 
<h2><a id="_270"></a>五、详细设计</h2> 
<h3><a id="51_Dialer_271"></a>5.1 Dialer拨号</h3> 
<h4><a id="511_Dialer_272"></a>5.1.1 Dialer应用拨号时序图</h4> 
<p><img src="https://images2.imgbox.com/21/e8/WjnKA93p_o.jpg" alt="在这里插入图片描述"></p> 
<h4><a id="512_Dialer_274"></a>5.1.2 Dialer拨号界面显示</h4> 
<p>Dialer应用为拨号提供了界面显示，同时也是拨号请求的触发点</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@LINUX</span>\android\packages\apps\<span class="token class-name">Dialer</span>\java\com\android\dialer\dialpadview\<span class="token class-name">DialpadFragment</span><span class="token punctuation">.</span>java
  <span class="token keyword">public</span> <span class="token class-name">View</span> <span class="token function">onCreateView</span><span class="token punctuation">(</span><span class="token class-name">LayoutInflater</span> inflater<span class="token punctuation">,</span> <span class="token class-name">ViewGroup</span> container<span class="token punctuation">,</span> <span class="token class-name">Bundle</span> savedState<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token class-name">View</span> fragmentView <span class="token operator">=</span> inflater<span class="token punctuation">.</span><span class="token function">inflate</span><span class="token punctuation">(</span><span class="token class-name">R</span><span class="token punctuation">.</span>layout<span class="token punctuation">.</span>dialpad_fragment<span class="token punctuation">,</span> container<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拨号界面布局加载</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> fragmentView<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onClick</span><span class="token punctuation">(</span><span class="token class-name">View</span> view<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token keyword">int</span> resId <span class="token operator">=</span> view<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>resId <span class="token operator">==</span> <span class="token class-name">R</span><span class="token punctuation">.</span>id<span class="token punctuation">.</span>dialpad_floating_action_button<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
      view<span class="token punctuation">.</span><span class="token function">performHapticFeedback</span><span class="token punctuation">(</span><span class="token class-name">HapticFeedbackConstants</span><span class="token punctuation">.</span><span class="token constant">VIRTUAL_KEY</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">handleDialButtonPressed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拨号按钮点击事件</span>
    <span class="token punctuation">}</span> 
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="513_Dialer_295"></a>5.1.3 Dialer权限检查</h4> 
<p>Dialer应用会进行权限检查，判断当前是否为默认拨号盘，且当前应用是否声明CALL_PHONE权限。</p> 
<pre><code class="prism language-JAVA">  public static boolean placeCall(Context context, Intent intent) {
    if (hasCallPhonePermission(context)) {//权限检查
      getTelecomManager(context).placeCall(intent.getData(), intent.getExtras());
      return true;
    }
    return false;
  }

  @Deprecated
  public static boolean hasCallPhonePermission(Context context) {
    return isDefaultDialer(context) || hasPermission(context, Manifest.permission.CALL_PHONE);//判断当前是否为默认拨号盘，且当前应用是否声明CALL_PHONE权限
  }
</code></pre> 
<h4><a id="514_TelecomService_311"></a>5.1.4 与TelecomService通信</h4> 
<p>Dialer应用通过TelecomManager对象，将拨号请求消息，通过binder的方式，通知TelecomService进程。</p> 
<pre><code class="prism language-JAVA">@LINUX\android\frameworks\base\telecomm\java\android\telecom\TelecomManager.java
    @RequiresPermission(anyOf = {android.Manifest.permission.CALL_PHONE,
            android.Manifest.permission.MANAGE_OWN_CALLS})
    public void placeCall(Uri address, Bundle extras) {
        ITelecomService service = getTelecomService();//获取服务端代理对象
        if (service != null) {
            if (address == null) {
                Log.w(TAG, "Cannot place call to empty address.");
            }
            try {
                service.placeCall(address, extras == null ? new Bundle() : extras,
                        mContext.getOpPackageName(), mContext.getAttributionTag());//通过binder实现跨进程通信，将拨号请求发给TelecomService进程
            } catch (RemoteException e) {
                Log.e(TAG, "Error calling ITelecomService#placeCall", e);
            }
        }
    }
</code></pre> 
<h3><a id="52_TelecomService_333"></a>5.2 TelecomService处理拨号流程</h3> 
<h4><a id="521_TelecomService_334"></a>5.2.1 TelecomService处理拨号时序图</h4> 
<p><img src="https://images2.imgbox.com/84/ec/bNxWvOYb_o.jpg" alt="在这里插入图片描述"></p> 
<h4><a id="522_InCallService_337"></a>5.2.2 往InCallService发送请求</h4> 
<p>（1）startOutgoingCall开始呼叫请求<br> Dialer进程的拨号请求传递到TelecomService进程后，通过startOutgoingCall方法开始请求打开呼叫界面</p> 
<pre><code class="prism language-JAVA">@LINUX\android\packages\services\Telecomm\src\com\android\server\telecom\CallIntentProcessor.java
static void processOutgoingCallIntent(
            Context context,
            CallsManager callsManager,
            Intent intent,
            String callingPackage,
            DefaultDialerCache defaultDialerCache) {
        ...
        // Send to CallsManager to ensure the InCallUI gets kicked off before the broadcast returns
        CompletableFuture&lt;Call&gt; callFuture = callsManager
                .startOutgoingCall(handle, phoneAccountHandle, clientExtras, initiatingUser,
                        intent, callingPackage);//开始呼叫请求

        final Session logSubsession = Log.createSubsession();
        callFuture.thenAccept((call) -&gt; {
            if (call != null) {
                Log.continueSession(logSubsession, "CIP.sNOCI");
                try {
                    broadcaster.processCall(call, disposition);//发送广播，切换成异步请求
                } finally {
                    Log.endSession();
                }
            }
        });
    }
</code></pre> 
<p>（2）绑定InCallService<br> InCallServiceImpl是InCallService的子类，在Dialer进程，而TelecomService进程与InCallServiceImpl也是通过bind实现跨进程通信。</p> 
<pre><code class="prism language-JAVA">@LINUX\android\packages\services\Telecomm\src\com\android\server\telecom\InCallController.java
public static final String SERVICE_INTERFACE = "android.telecom.InCallService";
public int connect(Call call) {
            ...
            Intent intent = new Intent(InCallService.SERVICE_INTERFACE);
            intent.setComponent(mInCallServiceInfo.getComponentName());
            ...
            //绑定InCallService类型服务，最终绑定InCallServiceImpl
            if (!mContext.bindServiceAsUser(intent, mServiceConnection,
                        Context.BIND_AUTO_CREATE | Context.BIND_FOREGROUND_SERVICE |
                        Context.BIND_ALLOW_BACKGROUND_ACTIVITY_STARTS |
                        Context.BIND_ABOVE_CLIENT,
                        UserHandle.CURRENT)) {
                Log.w(this, "Failed to connect.");
                mIsConnected = false;
            }
            ...
        }
</code></pre> 
<p>（3）启动InCallActivity呼叫界面<br> 当InCallServiceImpl被TelecomService进程绑定后，会调用onBind函数，接着启动InCallActivity呼叫界面</p> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@LINUX</span>\android\packages\apps\<span class="token class-name">Dialer</span>\java\com\android\incallui\<span class="token class-name">InCallServiceImpl</span><span class="token punctuation">.</span>java
  <span class="token keyword">public</span> <span class="token class-name">IBinder</span> <span class="token function">onBind</span><span class="token punctuation">(</span><span class="token class-name">Intent</span> intent<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token class-name">InCallPresenter</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">onServiceBind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">InCallPresenter</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">maybeStartRevealAnimation</span><span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//开启显示动画</span>
    <span class="token class-name">TelecomAdapter</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setInCallService</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> iBinder<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

<span class="token annotation punctuation">@LINUX</span>\android\packages\apps\<span class="token class-name">Dialer</span>\java\com\android\incallui\<span class="token class-name">InCallPresenter</span><span class="token punctuation">.</span>java
   <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">maybeStartRevealAnimation</span><span class="token punctuation">(</span><span class="token class-name">Intent</span> intent<span class="token punctuation">)</span> <span class="token punctuation">{<!-- --></span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">//启动InCallActivity呼叫界面</span>
    <span class="token keyword">final</span> <span class="token class-name">Intent</span> activityIntent <span class="token operator">=</span>
        <span class="token class-name">InCallActivity</span><span class="token punctuation">.</span><span class="token function">getIntent</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span> <span class="token comment">/* forFullScreen */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    activityIntent<span class="token punctuation">.</span><span class="token function">putExtra</span><span class="token punctuation">(</span><span class="token class-name">TouchPointManager</span><span class="token punctuation">.</span><span class="token constant">TOUCH_POINT</span><span class="token punctuation">,</span> touchPoint<span class="token punctuation">)</span><span class="token punctuation">;</span>
    context<span class="token punctuation">.</span><span class="token function">startActivity</span><span class="token punctuation">(</span>activityIntent<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre> 
<h4><a id="523__412"></a>5.2.3 广播下发消息</h4> 
<p>TelecomService进程发出一个定向广播，由TelecomService进程中的NewOutgoingCallBroadcastIntentReceiver对象接收。<br> （1）TelecomService进程发送广播</p> 
<pre><code class="prism language-JAVA">@LINUX\android\packages\services\Telecomm\src\com\android\server\telecom\NewOutgoingCallIntentBroadcaster.java
    private void broadcastIntent(
            Intent originalCallIntent,
            String number,
            boolean receiverRequired,
            UserHandle targetUser) {
        Intent broadcastIntent = new Intent(Intent.ACTION_NEW_OUTGOING_CALL);
        ...
        //发送广播
        mContext.sendOrderedBroadcastAsUser(
                broadcastIntent,
                targetUser,
                android.Manifest.permission.PROCESS_OUTGOING_CALLS,
                AppOpsManager.OP_PROCESS_OUTGOING_CALLS,
                options.toBundle(),
                receiverRequired ? new NewOutgoingCallBroadcastIntentReceiver() : null,
                null,  // scheduler
                Activity.RESULT_OK,  // initialCode
                number,  // initialData: initial value for the result data (number to be modified)
                null);  // initialExtras
    }
</code></pre> 
<p>（2）TelecomService进程接收广播</p> 
<pre><code class="prism language-JAVA">@LINUX\android\packages\services\Telecomm\src\com\android\server\telecom\NewOutgoingCallIntentBroadcaster.java
public class NewOutgoingCallBroadcastIntentReceiver extends BroadcastReceiver {
        @Override
        public void onReceive(Context context, Intent intent) {
            ...
                    placeOutgoingCallImmediately(mCall, resultHandleUri, gatewayInfo,
                            mIntent.getBooleanExtra(
                                    TelecomManager.EXTRA_START_CALL_WITH_SPEAKERPHONE, false),
                            mIntent.getIntExtra(TelecomManager.EXTRA_START_CALL_WITH_VIDEO_STATE,
                                    VideoProfile.STATE_AUDIO_ONLY));//继续下发呼叫请求
            ...
        }
    }
</code></pre> 
<p>同一个应用中为什么要使用广播来传递消息呢？因为Dialer进程发起拨号请求后，会将消息发给TelecomService进程，通过该进程的placeCall方法层层调用，此时方法是同步调用。直到调用了broadcastIntent，通过广播方式将同步方法转换成异步处理，即当前的呼叫请求下发给TelecomService进程处理，同Dialer进程的呼叫请求结束。</p> 
<h4><a id="524_TeleService_455"></a>5.2.4 往TeleService下发请求</h4> 
<p>（1）placeOutgoingCall 下发呼叫请求<br> 接收广播后，通过placeOutgoingCall方法继续下发拨号请求</p> 
<pre><code class="prism language-JAVA">    private void placeOutgoingCallImmediately(Call call, Uri handle, GatewayInfo gatewayInfo,
            boolean speakerphoneOn, int videoState) {
        ...
        mCall.setNewOutgoingCallIntentBroadcastIsDone();
        mCallsManager.placeOutgoingCall(call, handle, gatewayInfo, speakerphoneOn, videoState);
    }
</code></pre> 
<p>（2）绑定TeleService<br> binder绑定TeleService服务，实现跨进程通信，同时将将拨号请求分发给TeleService进程，由TeleService进程继续处理</p> 
<pre><code class="prism language-JAVA">@LINUX\android\packages\services\Telecomm\src\com\android\server\telecom\ConnectionServiceWrapper.java
public void createConnection(final Call call, final CreateConnectionResponse response) {
        BindCallback callback = new BindCallback() {
            @Override
            public void onSuccess() {
                ...
                    mServiceInterface.createConnection(...);//与TeleService绑定成功后，发起创建通话连接请求
                ...
            }

            @Override
            public void onFailure() {
                ...
            }
        };
        mBinder.bind(callback, call);//绑定TeleService
    }
}

@LINUX\android\packages\services\Telecomm\src\com\android\server\telecom\ServiceBinder.java
public static final String SERVICE_INTERFACE = "android.telecom.ConnectionService";
void bind(BindCallback callback, Call call) {
            ...
            if (mServiceConnection == null) {
                Intent serviceIntent = new Intent(mServiceAction).setComponent(mComponentName);//该对象为SERVICE_INTERFACE
                ...
                if (mUserHandle != null) {
                    isBound = mContext.bindServiceAsUser(serviceIntent, connection, bindingFlags,
                            mUserHandle);//绑定TeleService
                }
                ... 
            } 
        }
</code></pre> 
<h3><a id="53_TeleService_503"></a>5.3 TeleService下发拨号请求</h3> 
<h4><a id="531_TeleService_504"></a>5.3.1 TeleService下发拨号请求时序图</h4> 
<p><img src="https://images2.imgbox.com/19/07/nReG2ZE6_o.jpg" alt="在这里插入图片描述"></p> 
<h4><a id="532_TeleService_506"></a>5.3.2 TeleService类图</h4> 
<p><img src="https://images2.imgbox.com/84/7e/3o51gds6_o.jpg" alt="在这里插入图片描述"></p> 
<h4><a id="533_TelephonyConnectionService_508"></a>5.3.3 TelephonyConnectionService启动</h4> 
<pre><code class="prism language-java"><span class="token annotation punctuation">@LINUX</span>\android\packages\services\<span class="token class-name">Telephony</span>\<span class="token class-name">AndroidManifest</span><span class="token punctuation">.</span>xml
        <span class="token operator">&lt;</span>service
                android<span class="token operator">:</span>singleUser<span class="token operator">=</span><span class="token string">"true"</span>
                android<span class="token operator">:</span>name<span class="token operator">=</span><span class="token string">"com.android.services.telephony.TelephonyConnectionService"</span>
                android<span class="token operator">:</span>label<span class="token operator">=</span><span class="token string">"@string/pstn_connection_service_label"</span>
                android<span class="token operator">:</span>permission<span class="token operator">=</span><span class="token string">"android.permission.BIND_TELECOM_CONNECTION_SERVICE"</span> <span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span>intent<span class="token operator">-</span>filter<span class="token operator">&gt;</span>
                <span class="token operator">&lt;</span>action android<span class="token operator">:</span>name<span class="token operator">=</span><span class="token string">"android.telecom.ConnectionService"</span> <span class="token operator">/</span><span class="token operator">&gt;</span>
            <span class="token operator">&lt;</span><span class="token operator">/</span>intent<span class="token operator">-</span>filter<span class="token operator">&gt;</span>
        <span class="token operator">&lt;</span><span class="token operator">/</span>service<span class="token operator">&gt;</span>
</code></pre> 
<h4><a id="534_TeleServiceGsmCdmaPhone_521"></a>5.3.4 TeleService拨号请求下发（GsmCdmaPhone）</h4> 
<p>在teleService会获取当前呼叫的phone对象，如GsmCdmaPhone、ImsPhone、SipPhone，来决定要从用哪一种通讯方式进行呼叫。</p> 
<pre><code class="prism language-JAVA">@LINUX\android\packages\services\Telephony\src\com\android\services\telephony\TelephonyConnectionService.java
    public Connection onCreateOutgoingConnection(
            PhoneAccountHandle connectionManagerPhoneAccount,
            final ConnectionRequest request) {
        ...
        if (PhoneAccount.SCHEME_VOICEMAIL.equals(scheme)) {
            // TODO: We don't check for SecurityException here (requires
            // CALL_PRIVILEGED permission).
            final Phone phone = getPhoneForAccount(request.getAccountHandle(),
                    false /* isEmergencyCall */, null /* not an emergency call */);//获取Phone对象，决定采用的通讯方式
            ...
        } 
        ...
        if (!isEmergencyNumber) {
            ...
                return placeOutgoingConnection(request, resultConnection, phone);//往RILD继续下发消息
        } 
         ...
    }
</code></pre> 
<h4><a id="535_TeleServiceImsPhone_544"></a>5.3.5 TeleService拨号请求下发（ImsPhone）</h4> 
<p>Android 9 引入了一个名为 ImsService 的新 SystemApi 接口，可以帮助实现IP多媒体子系统。ImsService API 是在 Android 平台与供应商或运营商提供的 IMS 实现之间明确定义的接口。即IMS的具体实现是由供应商或运营商实现。 android提供了相关的系统SystemApi接口。</p> 
<h5><a id="5351__546"></a>5.3.5.1 时序图</h5> 
<p><img src="https://images2.imgbox.com/7a/78/IWrxq17s_o.jpg" alt="在这里插入图片描述"></p> 
<h5><a id="5352_IMSCDMAGSM_548"></a>5.3.5.2 IMS与CDMA、GSM时序切换</h5> 
<p>与普通的CS通话一致,由Dialer拨号应用,到Telecom,TeleService。区别在于,在GsmCdmaPhone#diale()中，判断是否支持ims通话。</p> 
<pre><code class="prism language-JAVA">    public Connection dial(String dialString, @NonNull DialArgs dialArgs)
            throws CallStateException {
        ...
        boolean useImsForCall = useImsForCall(dialArgs)
                &amp;&amp; !shallDialOnCircuitSwitch(dialArgs.intentExtras)
                &amp;&amp; (isWpsCall ? allowWpsOverIms : true);//是否使用IMS通讯方式
        ...
        if ((useImsForCall &amp;&amp; (!isMmiCode || isPotentialUssdCode))
                || (isMmiCode &amp;&amp; useImsForUt)
                || useImsForEmergency) {
            try {
                if (DBG) logd("Trying IMS PS call");
                return imsPhone.dial(dialString, dialArgs);//使用IMS通话
            } ...
        }
        ...
        if (isPhoneTypeGsm()) {
            return dialInternal(dialString, new DialArgs.Builder&lt;&gt;()
                    .setIntentExtras(dialArgs.intentExtras)
                    .build());//使用GSM通话
        } else {
            return dialInternal(dialString, dialArgs);//其他通话方式
        }
    }
</code></pre> 
<h3><a id="54_RILD_577"></a>5.4 RILD处理拨号请求</h3> 
<h4><a id="541_RILD_578"></a>5.4.1 RILD拨号请求消息下发时序图</h4> 
<p><img src="https://images2.imgbox.com/5a/27/lFQdAjBL_o.jpg" alt="在这里插入图片描述"></p> 
<h4><a id="542_RILJRILD_580"></a>5.4.2 RILJ往RILD发送指令</h4> 
<p>RILJ往RILD发送指令,请求拨号的消息下发如下：</p> 
<pre><code class="prism language-JAVA">@LINUX\android\frameworks\opt\telephony\src\java\com\android\internal\telephony\RIL.java
    @Override
    public void dial(String address, boolean isEmergencyCall, EmergencyNumber emergencyNumberInfo,
                     boolean hasKnownUserIntentEmergency, int clirMode, UUSInfo uusInfo,
                     Message result) {
        ...
        IRadio radioProxy = getRadioProxy(result);
        if (radioProxy != null) {
            RILRequest rr = obtainRequest(RIL_REQUEST_DIAL, result,
                    mRILDefaultWorkSource);
            ...
            try {
                radioProxy.dial(rr.mSerial, dialInfo);//请求拨号
            } catch (RemoteException | RuntimeException e) {
                handleRadioProxyExceptionForRR(rr, "dial", e);
            }
        }
    }
</code></pre> 
<h4><a id="543_RILDRILJ_602"></a>5.4.3 RILD接收到RILJ指令</h4> 
<p>RILD接收到RILJ指令，JAVA层与HAL层通过HIDL方式绑定，即HAL也会有对应的dial映射方法。</p> 
<pre><code class="prism language-c++">@LINUX\android\hardware\ril\libril\ril_service.cpp
#define CALL_ONREQUEST(a, b, c, d, e) \
        s_vendorFunctions-&gt;onRequest((a), (b), (c), (d), ((RIL_SOCKET_ID)(e)))

Return&lt;void&gt; RadioImpl::dial(int32_t serial, const Dial&amp; dialInfo) {
    ...
    CALL_ONREQUEST(RIL_REQUEST_DIAL, &amp;dial, sizeOfDial, pRI, mSlotId);
    memsetAndFreeStrings(2, dial.address, uusInfo.uusData);
    return Void();
}
</code></pre> 
<h4><a id="544_RILDreference_616"></a>5.4.4 RILD和reference侧消息传递</h4> 
<p>onRequest方法是在哪里被实现的？我们需要关注下s_vendorFunctions是在哪个地方赋值的。关于s_vendorFunctions全局变量，当我们调用reference中的RIL_Init完成初始化时，就会得到reference返回当前链接库提供的接口函数，通过该接口函数我们便可实现rild侧与reference侧的通讯(reference侧也是跑在rild进程，但是考虑到reference一般由modem厂商客制化，不清楚其内部实现，故以下将其称为reference侧，以便更好地区分该模块)。</p> 
<pre><code class="prism language-c++">@LINUX\android\hardware\ril\libril\ril.cpp
extern "C" void
RIL_register (const RIL_RadioFunctions *callbacks) {
    ...
    memcpy(&amp;s_callbacks, callbacks, sizeof (RIL_RadioFunctions));//对象拷贝
    ...
    radio::registerService(&amp;s_callbacks, s_commands);//注册回调函数
    ...
}

@LINUX\android\hardware\ril\libril\ril_service.cpp
void radio::registerService(RIL_RadioFunctions *callbacks, CommandInfo *commands) {
    ...
    s_vendorFunctions = callbacks;//将回调函数对象赋值，以实现rild侧与reference侧的引用
    s_commands = commands;
    ...
}
</code></pre> 
<h4><a id="545_reference_637"></a>5.4.5 reference侧接收到消息</h4> 
<p>reference层接收到消息， 从onRequest可以看出，reference中对所有的命令请求进行判别，然后选择不同的处理方式。</p> 
<pre><code class="prism language-c++">@LINUX\android\hardware\ril\reference-ril\reference-ril.c
static void onRequest (int request, void *data, size_t datalen, RIL_Token t)
{
    ...
    switch (request) {
        ...
        case RIL_REQUEST_DIAL:
            requestDial(data, datalen, t);//拨号请求
            break;
        case RIL_REQUEST_HANGUP://挂断电话请求
            requestHangup(data, datalen, t);
            break;
        ...       
    }
}

static void requestDial(void *data, size_t datalen __unused, RIL_Token t)
{
    ...
    ret = at_send_command(cmd, NULL);//往modem层发送指令
    ...
    /* success or failure is ignored by the upper layer here.
       it will call GET_CURRENT_CALLS and determine success that way */
    RIL_onRequestComplete(t, RIL_E_SUCCESS, NULL, 0);
}
</code></pre> 
<h4><a id="546_referencemodem_666"></a>5.4.6 reference侧将消息发送至modem侧</h4> 
<p>reference侧将消息发送至modem侧，at_send_command() -&gt; at_send_command_full() -&gt; at_send_command_full_nolock()，经过上面的操作，就将一条命令通过串口方式传输到了Modem侧。其间，完成了两个重要动作：1、通过writeline发送数据到Modem；2、阻塞当前线程，等待Modem回应。</p> 
<pre><code class="prism language-c++">@LINUX\android\hardware\ril\reference-ril\atchannel.c
static int at_send_command_full_nolock (const char *command, ATCommandType type,
                    const char *responsePrefix, const char *smspdu,
                    long long timeoutMsec, ATResponse **pp_outResponse)
{
    ...
    err = writeline (command);//将命令通过AT指令方式写入modem侧
    if (err &lt; 0) {
        goto error;
    }
    ...
    while (sp_response-&gt;finalResponse == NULL &amp;&amp; s_readerClosed == 0) {
        if (timeoutMsec != 0) {
            err = pthread_cond_timedwait(&amp;s_commandcond, &amp;s_commandmutex, &amp;ts);//阻塞线程，直到modem侧消息返回
        } 
        ...
    }
    ...
    return err;
}
</code></pre> 
<h4><a id="547_modemreference_690"></a>5.4.7 modem侧发送消息至reference侧</h4> 
<p>modem侧发送消息至reference侧，我们需要如何唤醒阻塞的线程呢？当我们发送数据或命令给Modem的时候，阻塞了当前的线程，阻塞的目的就是等待Modem的回应，而如果Modem有数据上来，那么肯定是先被reference的ReaderLoop检测到并处理，因此，也应该是在ReaderLoop的消息处理中去唤醒当前阻塞的线程，而且应该把Modem的反馈传输给阻塞线程。</p> 
<pre><code class="prism language-c++">@LINUX\android\hardware\ril\reference-ril\atchannel.c
static void *readerLoop(void *arg __unused)
{
    for (;;) {
        ...
        line = readline();//读取modem返回数据
        ...
        if(isSMSUnsolicited(line)) {
            ...
        } else {
            processLine(line);//解析消息
        }
    }
    ...
    return NULL;
}

static void processLine(const char *line)
{
    ...
    if (sp_response == NULL) {
        /* no command pending */
        handleUnsolicited(line);//处理URC消息
    } else if (isFinalResponseSuccess(line)) {
        sp_response-&gt;success = 1;
        handleFinalResponse(line);//发送回应消息
    }
    ...
}

static void handleFinalResponse(const char *line)
{
    sp_response-&gt;finalResponse = strdup(line);
    pthread_cond_signal(&amp;s_commandcond);//发送一个信号给另外一个正在处于阻塞等待状态的线程,使其脱离阻塞状态
}
</code></pre> 
<h4><a id="548_referencemodem_729"></a>5.4.8 reference侧轮询modem指令</h4> 
<p>reference侧轮询modem指令，ReaderLoop轮询modem消息又是在哪里实现的呢？RILD进程被创建后，会通过RIL_Init初始化相关的reference相关准备工作，其中涉及到打开与modem侧的AT通道，监听modem上报消息。</p> 
<pre><code class="prism language-C++">@LINUX\android\hardware\ril\reference-ril\atchannel.c
const RIL_RadioFunctions *RIL_Init(const struct RIL_Env *env, int argc, char **argv)
{
    ...
    ret = pthread_create(&amp;s_tid_mainloop, &amp;attr, mainLoop, NULL);//创建mainLoop线程
    ...
}

static void *
mainLoop(void *param __unused)
{
    ...
    for (;;) {
        ...
        ret = at_open(fd, onUnsolicited);//打开AT通道并把处理URC消息的方法onUnsolicited传进去 
        ...
    }
}

@LINUX\android\hardware\ril\reference-ril\atchannel.c
int at_open(int fd, ATUnsolHandler h)
{
    ...
    ret = pthread_create(&amp;s_tid_reader, &amp;attr, readerLoop, &amp;attr);//创建readerLooper线程，读取AT指令并处理modem侧消息
    ...
}
</code></pre> 
<h2><a id="RIL_759"></a>六、RIL指令</h2> 
<h3><a id="61_RILJ_760"></a>6.1 RILJ主动发送指令</h3> 
<p><strong>源码：</strong> android\hardware\ril\libril\ril_commands.h</p> 
<table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td>RIL_REQUEST_GET_SIM_STATUS</td><td>获取SIM卡状态</td></tr><tr><td>RIL_REQUEST_ENTER_SIM_PIN</td><td>请求输入SIM的PIN码（PIN码是用来保护SIM卡安全的密码。PIN码的初始值一般是1234,可以进行更改）</td></tr><tr><td>RIL_REQUEST_ENTER_SIM_PUK</td><td>请求PUK码和新的PIN码的输入（PUK码是用来解PIN码的解锁码，共8位长）</td></tr><tr><td>RIL_REQUEST_ENTER_SIM_PIN2</td><td>请求输入SIM的PIN2码（进入某种特殊功能时，如设置固定号码、设置通话计费等，所要输入的个人识别码）</td></tr><tr><td>RIL_REQUEST_ENTER_SIM_PUK2</td><td>请求PUK2码和新的PIN2码的输入（PUK2码就是专门用来为被锁上的PIN2码解锁的）</td></tr><tr><td>RIL_REQUEST_CHANGE_SIM_PIN</td><td>请求更改PIN码</td></tr><tr><td>RIL_REQUEST_CHANGE_SIM_PIN2</td><td>请求更改PIN2码</td></tr><tr><td>RIL_REQUEST_ENTER_NETWORK_DEPERSONALIZATION</td><td>请求输入网络个人码以便去激活</td></tr><tr><td>RIL_REQUEST_GET_CURRENT_CALLS</td><td>请求获取当前呼叫列表</td></tr><tr><td>RIL_REQUEST_DIAL</td><td>初始化一个语音呼叫</td></tr><tr><td>RIL_REQUEST_GET_IMSI</td><td>取SIM卡中的国际移动用户识别码IMSI(区别移动用户的标志，储存在SIM卡中，可用于区别移动用户的有效信息)</td></tr><tr><td>RIL_REQUEST_HANGUP</td><td>挂断某一激活的通话</td></tr><tr><td>RIL_REQUEST_HANGUP_WAITING_OR_BACKGROUND</td><td>挂断所有等待的或者保持的通话</td></tr><tr><td>RIL_REQUEST_HANGUP_FOREGROUND_RESUME_BACKGROUND</td><td>释放所有激活的通话并激活保持的或者等待的通话</td></tr><tr><td>RIL_REQUEST_SWITCH_WAITING_OR_HOLDING_AND_ACTIVE</td><td>话连接状态的转换，将所有激活的通话转为保持或等待状态（通话状态：IDLE、ACTIVE、HOLDING、WAITING等）</td></tr><tr><td>RIL__CONFERENCE</td><td>请求加入电话会议</td></tr><tr><td>RIL_REQUEST_UDUB</td><td>发送用户确定用户忙UDUB（user determined user busy）信号</td></tr><tr><td>RIL_REQUEST_LAST_CALL_FAIL_CAUSE</td><td>请求最近一次通话中断的错误码</td></tr><tr><td>RIL_REQUEST_SIGNAL_STRENGTH</td><td>请求当前的信号强度等相关信息</td></tr><tr><td>RIL_REQUEST_VOICE_REGISTRATION_STATE</td><td>请求当前注册状态（描述的是信号柱的显示）</td></tr><tr><td>RIL_REQUEST_DATA_REGISTRATION_STATE</td><td>请求当前注册状态（描述的是3G、4G的显示）</td></tr><tr><td>RIL_REQUEST_OPERATOR</td><td>请求运营商名称</td></tr><tr><td>RIL_REQUEST_RADIO_POWER</td><td>请求打开无线电通讯</td></tr><tr><td>RIL_REQUEST_DTMF</td><td>发起DTMF请求（在手机中，常用的DTMF场景是使用手机拨打一些服务台电话，比如客服热线10086、10000之类；电话接入之后，有对应的语音提示输入不同的数字进入不同的菜单，或者要修改资料，对方要验证我们的账号和密码，这时打开手机拨号盘，输入数字信息，对方就知道我们输入的内容是什么。）</td></tr><tr><td>RIL_REQUEST_SEND_SMS</td><td>发送短信</td></tr><tr><td>RIL_REQUEST_SEND_SMS_EXPECT_MORE</td><td>发送短信，且支持串联短信</td></tr><tr><td>RIL_REQUEST_SETUP_DATA_CALL</td><td>请求打开数据流量</td></tr><tr><td>RIL_REQUEST_SIM_IO</td><td>获取SIM卡号</td></tr><tr><td>RIL_REQUEST_SEND_USSD</td><td>请求一个USSD业务（ussd即非结构化补充数据业务，是一种全球移动通信系统 (GSM) 协议，用于发送消息和文本文件。USSD代码一般以*开头，以#结尾，可用于执行一些隐藏功能。）</td></tr><tr><td>RIL_REQUEST_CANCEL_USSD</td><td>撤销一个USSD业务</td></tr><tr><td>RIL_REQUEST_GET_CLIR</td><td>查询当前呼叫号码是否隐藏请求</td></tr><tr><td>RIL_REQUEST_SET_CLIR</td><td>设置呼叫号码是否隐藏</td></tr><tr><td>RIL_REQUEST_QUERY_CALL_FORWARD_STATUS</td><td>查询呼叫转移的状态</td></tr><tr><td>RIL_REQUEST_SET_CALL_FORWARD</td><td>设置呼叫转移</td></tr><tr><td>RIL_REQUEST_QUERY_CALL_WAITING</td><td>查询呼叫等待信息</td></tr><tr><td>RIL_REQUEST_SET_CALL_WAITING</td><td>设置呼叫等待状态（当移动电话用户正在进行通话时，又有呼叫向您发来。这时发起新呼叫的一方被置于等待，待原通话结束后再将新呼叫接入。）</td></tr><tr><td>RIL_REQUEST_SMS_ACKNOWLEDGE</td><td>用于短信消息的传送应答</td></tr><tr><td>RIL_REQUEST_GET_IMEI</td><td>获取IMEI号</td></tr><tr><td>RIL_REQUEST_GET_IMEISV</td><td>获取IMEISV号（MEI有15位，最后一位是Check digit，即检验位；IMEISV有16位，是去掉了Check digit，加上了两位SVN，即software version number。）</td></tr><tr><td>RIL_REQUEST_ANSWER</td><td>接听电话请求</td></tr><tr><td>RIL_REQUEST_DEACTIVATE_DATA_CALL</td><td>断开数据流量业务</td></tr><tr><td>RIL_REQUEST_QUERY_FACILITY_LOCK</td><td>查询设备锁定状态</td></tr><tr><td>RIL_REQUEST_SET_FACILITY_LOCK</td><td>设置设备锁定状态</td></tr><tr><td>RIL_REQUEST_CHANGE_BARRING_PASSWORD</td><td>修改呼叫限制密码</td></tr><tr><td>RIL_REQUEST_QUERY_NETWORK_SELECTION_MODE</td><td>查询网络选择</td></tr><tr><td>RIL_REQUEST_SET_NETWORK_SELECTION_AUTOMATIC</td><td>设置网络选择为自动</td></tr><tr><td>RIL_REQUEST_SET_NETWORK_SELECTION_MANUAL</td><td>设置网络选择为手动</td></tr><tr><td>RIL_REQUEST_QUERY_AVAILABLE_NETWORKS</td><td>查询可用网络列表</td></tr><tr><td>RIL_REQUEST_DTMF_START</td><td>启动DTMF功能</td></tr><tr><td>RIL_REQUEST_DTMF_STOP</td><td>关闭DTMF功能</td></tr><tr><td>RIL_REQUEST_BASEBAND_VERSION</td><td>获取基带版本</td></tr><tr><td>RIL_REQUEST_SEPARATE_CONNECTION</td><td>将所有激活的呼叫挂起</td></tr><tr><td>RIL_REQUEST_SET_MUTE</td><td>设置静音</td></tr><tr><td>RIL_REQUEST_ALLOW_DATA</td><td>设置双卡数据切换</td></tr><tr><td>RIL_REQUEST_GET_MUTE</td><td>获取静音状态</td></tr><tr><td>RIL_REQUEST_QUERY_CLIP</td><td>查询主叫号码（主叫号码识别显示补充业务。CLIP是指被叫移动用户的补充业务,移动用户接收呼叫时,网络向用户提示主叫用户的号码。）</td></tr><tr><td>RIL_REQUEST_LAST_DATA_CALL_FAIL_CAUSE</td><td>查询上一次数据连接失败原因</td></tr><tr><td>RIL_REQUEST_DATA_CALL_LIST</td><td>查询数据连接信息</td></tr><tr><td>RIL_REQUEST_RESET_RADIO</td><td>复位模块</td></tr><tr><td>RIL_REQUEST_OEM_HOOK_RAW</td><td>？？？</td></tr><tr><td>RIL_REQUEST_OEM_HOOK_STRINGS</td><td>？？？</td></tr><tr><td>RIL_REQUEST_SCREEN_STATE</td><td>查询屏幕状态</td></tr><tr><td>RIL_REQUEST_SET_SUPP_SVC_NOTIFICATION</td><td>启用/禁用来自网络的补充服务相关通知</td></tr><tr><td>RIL_REQUEST_WRITE_SMS_TO_SIM</td><td>复制短信到SIM卡中</td></tr><tr><td>RIL_REQUEST_DELETE_SMS_ON_SIM</td><td>删除SIM卡短信</td></tr><tr><td>RIL_REQUEST_SET_BAND_MODE</td><td>设置频段模式</td></tr><tr><td>RIL_REQUEST_QUERY_AVAILABLE_BAND_MODE</td><td>查询可用频段模式</td></tr><tr><td>RIL_REQUEST_STK_GET_PROFILE</td><td>查询STK的配置信息</td></tr><tr><td>RIL_REQUEST_STK_SEND_ENVELOPE_COMMAND</td><td>请求打开STK子菜单</td></tr><tr><td>RIL_REQUEST_STK_SEND_TERMINAL_RESPONSE</td><td>获取STK子菜单信息</td></tr><tr><td>RIL_REQUEST_STK_HANDLE_CALL_SETUP_REQUESTED_FROM_SIM</td><td>接受或拒绝来自SIM卡的呼叫设置请求。</td></tr><tr><td>RIL_REQUEST_EXPLICIT_CALL_TRANSFER</td><td>请求呼叫转接业务</td></tr><tr><td>RIL_REQUEST_SET_PREFERRED_NETWORK_TYPE</td><td>设置偏好的网络类型</td></tr><tr><td>RIL_REQUEST_GET_PREFERRED_NETWORK_TYPE</td><td>获取偏好的网络类型</td></tr><tr><td>RIL_REQUEST_GET_NEIGHBORING_CELL_IDS</td><td>获取此设备上的相邻单元列表</td></tr><tr><td>RIL_REQUEST_SET_LOCATION_UPDATES</td><td>位置更新</td></tr><tr><td>RIL_REQUEST_CDMA_SET_SUBSCRIPTION_SOURCE</td><td>请求设置CDMA订阅模式</td></tr><tr><td>RIL_REQUEST_CDMA_SET_ROAMING_PREFERENCE</td><td>设置偏好漫游类型</td></tr><tr><td>RIL_REQUEST_CDMA_QUERY_ROAMING_PREFERENCE</td><td>查询偏好漫游类型</td></tr><tr><td>RIL_REQUEST_SET_TTY_MODE</td><td>设置为聋哑模式</td></tr><tr><td>RIL_REQUEST_QUERY_TTY_MODE</td><td>查询聋哑模式状态</td></tr><tr><td>RIL_REQUEST_CDMA_SET_PREFERRED_VOICE_PRIVACY_MODE</td><td>设置首选语音隐私(VP)</td></tr><tr><td>RIL_REQUEST_CDMA_QUERY_PREFERRED_VOICE_PRIVACY_MODE</td><td>获取当前设置的首选语音隐私(VP)模式。</td></tr><tr><td>RIL_REQUEST_CDMA_FLASH</td><td>？？？</td></tr><tr><td>RIL_REQUEST_CDMA_BURST_DTMF</td><td>发起DTMS请求</td></tr><tr><td>RIL_REQUEST_CDMA_VALIDATE_AND_WRITE_AKEY</td><td>？？？</td></tr><tr><td>RIL_REQUEST_CDMA_SEND_SMS</td><td>CDMA发送短信</td></tr><tr><td>RIL_REQUEST_CDMA_SMS_ACKNOWLEDGE</td><td>CDMA短信消息的传送应答</td></tr><tr><td>RIL_REQUEST_GSM_GET_BROADCAST_SMS_CONFIG</td><td>获取小区广播配置，通过小区广播信道（CBCH）将信息（如地理位置、天气状况等信息）传到手机，再由用户选择接收的一种功能，通过此功能可向用户提供位置信息，天气预报等服务；是向中国移动的手机客户按区域、按频道发送各种实时、动态的分类信息的业务。</td></tr><tr><td>RIL_REQUEST_GSM_SET_BROADCAST_SMS_CONFIG</td><td>设置小区广播配置</td></tr><tr><td>RIL_REQUEST_GSM_SMS_BROADCAST_ACTIVATION</td><td>小区广播功能开关</td></tr><tr><td>RIL_REQUEST_CDMA_GET_BROADCAST_SMS_CONFIG</td><td>CDMA获取小区广播配置</td></tr><tr><td>RIL_REQUEST_CDMA_SET_BROADCAST_SMS_CONFIG</td><td>CDMA设置小区广播配置</td></tr><tr><td>RIL_REQUEST_CDMA_SMS_BROADCAST_ACTIVATION</td><td>CDMA小区广播开关</td></tr><tr><td>RIL_REQUEST_CDMA_SUBSCRIPTION</td><td>查询CDMA的实现模式（CDMA手机两实现模式：<br>机卡分离式：用户信息写在单独的UIM<br>卡机卡一体式：用户信息写在手机中的）</td></tr><tr><td>RIL_REQUEST_CDMA_WRITE_SMS_TO_RUIM</td><td>CDMA复制短息到uim卡,RUIM是应用在CDMA2000手机的一种智能卡</td></tr><tr><td>RIL_REQUEST_CDMA_DELETE_SMS_ON_RUIM</td><td>CDMA删除RUIM卡上短信</td></tr><tr><td>RIL_REQUEST_DEVICE_IDENTITY</td><td>请求设备标识</td></tr><tr><td>RIL_REQUEST_EXIT_EMERGENCY_CALLBACK_MODE</td><td>离开紧急回拨模式</td></tr><tr><td>RIL_REQUEST_GET_SMSC_ADDRESS</td><td>获取SMSC地址，网络短信息服务中心地址</td></tr><tr><td>RIL_REQUEST_SET_SMSC_ADDRESS</td><td>设置SMSC地址</td></tr><tr><td>RIL_REQUEST_REPORT_SMS_MEMORY_STATUS</td><td>通知modem，SMS的存储情况</td></tr><tr><td>RIL_REQUEST_REPORT_STK_SERVICE_IS_RUNNING</td><td>通知modem，StkService已经启动</td></tr><tr><td>RIL_REQUEST_CDMA_GET_SUBSCRIPTION_SOURCE</td><td>设置CDMA的实现模式</td></tr><tr><td>RIL_REQUEST_ISIM_AUTHENTICATION</td><td>ISIM认证</td></tr><tr><td>RIL_REQUEST_ACKNOWLEDGE_INCOMING_GSM_SMS_WITH_PDU</td><td>确认收到成功或失败的最后一条传入短信，包括确认TPDU作为RP-ACK或RP-ERROR PDU的RP-User-Data元素发送。</td></tr><tr><td>RIL_REQUEST_STK_SEND_ENVELOPE_WITH_STATUS</td><td>？？？</td></tr><tr><td>RIL_REQUEST_VOICE_RADIO_TECH</td><td>获取当前的语音无线电技术。</td></tr><tr><td>RIL_REQUEST_GET_CELL_INFO_LIST</td><td>获取当前的信元信息</td></tr><tr><td>RIL_REQUEST_SET_UNSOL_CELL_INFO_LIST_RATE</td><td>设置信元信息的调用时间，即onCellInfoChanged的响应时间</td></tr><tr><td>RIL_REQUEST_SET_INITIAL_ATTACH_APN</td><td>初始化APN</td></tr><tr><td>RIL_REQUEST_IMS_REGISTRATION_STATE</td><td>查询IMS的注册状态</td></tr><tr><td>RIL_REQUEST_IMS_SEND_SMS</td><td>请求IMS发送短信</td></tr><tr><td>RIL_REQUEST_SIM_TRANSMIT_APDU_BASIC</td><td>在基本频道上与SIM交换apdu</td></tr><tr><td>RIL_REQUEST_SIM_OPEN_CHANNEL</td><td>打开SIM无线信道</td></tr><tr><td>RIL_REQUEST_SIM_CLOSE_CHANNEL</td><td>关闭SIM无线信道</td></tr><tr><td>RIL_REQUEST_SIM_TRANSMIT_APDU_CHANNEL</td><td>在逻辑信道上与SIM交换APDU。</td></tr><tr><td>RIL_REQUEST_NV_READ_ITEM</td><td>读取{@link RadioNVItems} / {@code ril_nv_items.h}中定义的NV项之一，用于部分CDMA运营商的设备配置。</td></tr><tr><td>RIL_REQUEST_NV_WRITE_ITEM</td><td>写一个定义在{@link RadioNVItems} / {@code ril_nv_items.h}的NV项，用于部分CDMA运营商的设备配置。</td></tr><tr><td>RIL_REQUEST_NV_WRITE_CDMA_PRL</td><td>更新无线电NV存储中的CDMA首选漫游列表(PRL)。用于部分CDMA运营商的设备配置。</td></tr><tr><td>RIL_REQUEST_NV_RESET_CONFIG</td><td>执行modem配置复位。用于部分CDMA运营商的设备配置。</td></tr><tr><td>RIL_REQUEST_SET_UICC_SUBSCRIPTION</td><td>？？？</td></tr><tr><td>RIL_REQUEST_ALLOW_DATA</td><td>双卡数据切换</td></tr><tr><td>RIL_REQUEST_GET_HARDWARE_CONFIG</td><td>获取RIL的硬件配置</td></tr><tr><td>RIL_REQUEST_SIM_AUTHENTICATION</td><td>SIM卡身份认证</td></tr><tr><td>RIL_REQUEST_GET_DC_RT_INFO</td><td>？？？</td></tr><tr><td>RIL_REQUEST_SET_DC_RT_INFO_RATE</td><td>？？？</td></tr><tr><td>RIL_REQUEST_SET_DATA_PROFILE</td><td>发送当前运营商的数据配置文件到数据服务进行数据呼叫设置。这是仅适用于CDMA运营商，可通过OTA更改配置文件。数据服务应该总是使用最新的数据配置文件发送的框架。</td></tr><tr><td>RIL_REQUEST_SHUTDOWN</td><td>关机</td></tr><tr><td>RIL_REQUEST_GET_RADIO_CAPABILITY</td><td>获取电话无线电功能</td></tr><tr><td>RIL_REQUEST_SET_RADIO_CAPABILITY</td><td>设置电话无线电类型和接入技术。</td></tr><tr><td>RIL_REQUEST_START_LCE</td><td>启动LCE(链路容量估计)服务，并设置所需的报告间隔。</td></tr><tr><td>RIL_REQUEST_STOP_LCE</td><td>停止LCE服务。</td></tr><tr><td>RIL_REQUEST_PULL_LCEDATA</td><td>获取LCE服务获取容量数据。</td></tr><tr><td>RIL_REQUEST_GET_ACTIVITY_INFO</td><td>请求modem的活动信息</td></tr><tr><td>RIL_REQUEST_SET_CARRIER_RESTRICTIONS</td><td>？？？</td></tr><tr><td>RIL_REQUEST_GET_CARRIER_RESTRICTIONS</td><td>？？？</td></tr><tr><td>RIL_REQUEST_SEND_DEVICE_STATE</td><td>发送设备状态到Modem</td></tr><tr><td>RIL_REQUEST_SET_UNSOLICITED_RESPONSE_FILTER</td><td>打开/关闭调制解调器的主动响应</td></tr><tr><td>RIL_REQUEST_SET_SIM_CARD_POWER</td><td>设置SIM卡上电状态。 @param state SIM卡状态(断电、上电、通过)</td></tr><tr><td>RIL_REQUEST_SET_CARRIER_INFO_IMSI_ENCRYPTION</td><td>设置加密IMSI和IMPI所需的运营商信息。</td></tr><tr><td>RIL_REQUEST_START_NETWORK_SCAN</td><td>扫描网络</td></tr><tr><td>RIL_REQUEST_STOP_NETWORK_SCAN</td><td>停止扫描网络</td></tr><tr><td>RIL_REQUEST_START_KEEPALIVE</td><td>启动长连接</td></tr><tr><td>RIL_REQUEST_STOP_KEEPALIVE</td><td>停止长连接</td></tr></tbody></table> 
<h3><a id="62_RILJ_911"></a>6.2 RILJ被动接收指令</h3> 
<p><strong>源码：</strong> android\hardware\ril\libril\ril_unsol_commands.h</p> 
<table><thead><tr><th>指令</th><th>功能</th></tr></thead><tbody><tr><td>RIL_UNSOL_RESPONSE_RADIO_STATE_CHANGED</td><td>无线通信模块状态改变</td></tr><tr><td>RIL_UNSOL_RESPONSE_CALL_STATE_CHANGED</td><td>来电状态改变</td></tr><tr><td>RIL_UNSOL_RESPONSE_VOICE_NETWORK_STATE_CHANGED</td><td>信号状态改变</td></tr><tr><td>RIL_UNSOL_RESPONSE_NEW_SMS</td><td>收到短信</td></tr><tr><td>RIL_UNSOL_RESPONSE_NEW_SMS_STATUS_REPORT</td><td>短信发送状态报告</td></tr><tr><td>RIL_UNSOL_RESPONSE_NEW_SMS_ON_SIM</td><td>？？？</td></tr><tr><td>RIL_UNSOL_ON_USSD</td><td>？？？</td></tr><tr><td>RIL_UNSOL_ON_USSD_REQUEST</td><td>？？？</td></tr><tr><td>RIL_UNSOL_NITZ_TIME_RECEIVED</td><td>通知更新终端系统的时间及时区</td></tr><tr><td>RIL_UNSOL_DATA_CALL_LIST_CHANGED</td><td>数据连接状态改变</td></tr><tr><td>RIL_UNSOL_SUPP_SVC_NOTIFICATION</td><td>？？？</td></tr><tr><td>RIL_UNSOL_STK_SESSION_END</td><td>通知会话结束</td></tr><tr><td>RIL_UNSOL_STK_PROACTIVE_COMMAND</td><td>插卡开机，Modem检测到有卡插入，这时候Modem会读取SIM中的相关信息，并把消息上报给RIL层，显示STK主菜单</td></tr><tr><td>RIL_UNSOL_STK_EVENT_NOTIFY</td><td>用于STK事件分发</td></tr><tr><td>RIL_UNSOL_STK_CALL_SETUP</td><td>发送来自modem的拨打电话的主动上报消息</td></tr><tr><td>RIL_UNSOL_SIM_SMS_STORAGE_FULL</td><td>通知空间满了</td></tr><tr><td>RIL_UNSOL_SIM_REFRESH</td><td>modem请求更新卡对应的文件信息</td></tr><tr><td>RIL_UNSOL_CALL_RING</td><td>有来电时上报</td></tr><tr><td>RIL_UNSOL_RESPONSE_SIM_STATUS_CHANGED</td><td>SIM卡状态改变</td></tr><tr><td>RIL_UNSOL_RESPONSE_CDMA_NEW_SMS</td><td>接收到CDMA短信</td></tr><tr><td>RIL_UNSOL_RESPONSE_NEW_BROADCAST_SMS</td><td>？？？</td></tr><tr><td>RIL_UNSOL_CDMA_RUIM_SMS_STORAGE_FULL</td><td>？？？</td></tr><tr><td>RIL_UNSOL_RESTRICTED_STATE_CHANGED</td><td>受限策略改变通知</td></tr><tr><td>RIL_UNSOL_ENTER_EMERGENCY_CALLBACK_MODE</td><td>进入紧急回拨模式通知</td></tr><tr><td>RIL_UNSOL_CDMA_CALL_WAITING</td><td>呼叫等待通知</td></tr><tr><td>RIL_UNSOL_CDMA_OTA_PROVISION_STATUS</td><td>？？？</td></tr><tr><td>RIL_UNSOL_CDMA_INFO_REC</td><td>？？？</td></tr><tr><td>RIL_UNSOL_OEM_HOOK_RAW</td><td>？？？</td></tr><tr><td>RIL_UNSOL_RINGBACK_TONE</td><td>电话铃声</td></tr><tr><td>RIL_UNSOL_RESEND_INCALL_MUTE</td><td>？？？</td></tr><tr><td>RIL_UNSOL_CDMA_SUBSCRIPTION_SOURCE_CHANGED</td><td>管理 机卡分离 Or 机卡一体的消息</td></tr><tr><td>RIL_UNSOL_CDMA_PRL_CHANGED</td><td>优选漫游列表更新通知</td></tr><tr><td>RIL_UNSOL_EXIT_EMERGENCY_CALLBACK_MODE</td><td>离开紧急回拨模式通知</td></tr><tr><td>RIL_UNSOL_RIL_CONNECTED</td><td>RIL连接成功通知</td></tr><tr><td>RIL_UNSOL_VOICE_RADIO_TECH_CHANGED</td><td>？？？</td></tr><tr><td>RIL_UNSOL_CELL_INFO_LIST</td><td>？？？</td></tr><tr><td>RIL_UNSOL_RESPONSE_IMS_NETWORK_STATE_CHANGED</td><td>？？?</td></tr><tr><td>RIL_UNSOL_UICC_SUBSCRIPTION_STATUS_CHANGED</td><td>？？？</td></tr><tr><td>RIL_UNSOL_SRVCC_STATE_NOTIFY</td><td>？？？</td></tr><tr><td>RIL_UNSOL_HARDWARE_CONFIG_CHANGED</td><td>？？？</td></tr><tr><td>RIL_UNSOL_DC_RT_INFO_CHANGED</td><td>？？？</td></tr><tr><td>RIL_UNSOL_RADIO_CAPABILITY</td><td>？？？</td></tr><tr><td>RIL_UNSOL_ON_SS</td><td>？？？</td></tr><tr><td>RIL_UNSOL_STK_CC_ALPHA_NOTIFY</td><td>？？？</td></tr><tr><td>RIL_UNSOL_LCEDATA_RECV</td><td>？？？</td></tr><tr><td>RIL_UNSOL_PCO_DATA</td><td>？？？</td></tr><tr><td>RIL_UNSOL_MODEM_RESTART</td><td>modem重启通知</td></tr><tr><td>RIL_UNSOL_CARRIER_INFO_IMSI_ENCRYPTION</td><td>？？？</td></tr><tr><td>RIL_UNSOL_NETWORK_SCAN_RESULT</td><td>通知网络扫描结果</td></tr><tr><td>RIL_UNSOL_KEEPALIVE_STATUS</td><td>通知心跳状态</td></tr></tbody></table> 
<h2><a id="_966"></a>七、参考资料</h2> 
<p>https://source.android.google.cn/docs/core/connect/ims?hl=zh-cn<br> http://www.taodudu.cc/news/show-3144813.html?action=onClick<br> http://baike.jld5.cn/news/51009.html<br> https://wiki.mbalib.com/wiki/IMS<br> https://blog.csdn.net/guyuewangyue/article/details/122866358<br> 电路交换和分组交换区别：<br> https://www.elecfans.com/d/1308634.html<br> TeleComService介绍：<br> https://blog.csdn.net/qq_40587575/article/details/113753895<br> TeleService介绍：<br> https://www.jianshu.com/p/ff51295b84a1<br> Rild介绍：<br> https://www.freesion.com/article/21011164222/<br> https://blog.csdn.net/u014386544/article/details/52594400<br> RIL指令:<br> https://www.mianshigee.com/note/detail/23890yjg/<br> https://blog.csdn.net/iteye_6233/article/details/82230745<br> https://blog.csdn.net/u010961631/article/details/9446377/<br> https://blog.csdn.net/sjz4860402/article/details/51182078<br> http://www.2sim.cn/article/13<br> https://zhuanlan.zhihu.com/p/117218424<br> https://blog.csdn.net/u014386544/article/details/56851616</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/6750e0b6ef8fb90ffa4afe4ffa21a2b2/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Flowable 之事件和网关</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/4cd62baa186d00f7c4ada99f639da093/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">成集云 | 金蝶EAS集成聚水潭ERP（金蝶EAS主管供应链）| 解决方案</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>