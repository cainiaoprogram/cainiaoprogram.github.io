<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>常用注解（Annotation）整理 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="常用注解（Annotation）整理" />
<meta property="og:description" content="1.Java中@Autowired或@Resource这两个注解功能都是相同的，这两个注解的区别：@Autowired默认按类型装配，@Resource默认按名称装配，当找不到与名称匹配的bean时才会按类型装配。 2.@Autowired、@Qualifier、@Resource三者的区别： 简单理解： @Autowired 默认根据类型注入； @Resource 默认根据名字注入，其次按照类型注入； @Autowired @Qualifier(“userService”) 两个结合起来默认按类型注入，其次按名字注入。
3.spring/springMVC中常用注解对比： @Configuration — spring配置文件中的&lt;beans&gt;&lt;/beans&gt;
@Bean — spring配置文件中的&lt;bean&gt;&lt;/bean&gt;
@Autowired 、@Named 两个注解可以互换使用 @Component 、@Inject两个注解可以互换使用
@ContextConfiguration — spring整个配置文件(applicationContext.xml)
@componentScan — spring配置文件中的&lt;context：component-scan base-package=“xxx”/&gt;
@Service(“name”) — spring配置文件中的&lt;bean class=&#34;xxx&#34; id=&#34;name&#34;&gt; id=name
@Scope 代表spring容器的生命周期，取值有singleton、prototype 、request 、session 、global session五种。 注意：request、session和global session类型只实用于web程序，通常是和XmlWebApplicationContext共同使用。
@EnableScheduling:开启对定时任务的支持; @Scheduled：声明一个定时任务;
@Conditional:满足一定条件来创建一个特定的bean;
@RequestHeader ： 可以把Request请求header部分的值绑定到方法的参数上。
Request的Header部分： Host localhost:8080 Accept text/html,application/xhtml&#43;xml,application/xml;q=0.9 Accept-Language fr,en-gb;q=0.7,en;q=0.3 Accept-Encoding gzip,deflate Accept-Charset ISO-8859-1,utf-8;q=0.7,*;q=0.7 Keep-Alive 300 @RequestMapping(&#34;/displayHeaderInfo.do&#34;) public void displayHeaderInfo( @RequestHeader(&#34;Accept-Encoding&#34;) String encoding, @RequestHeader(&#34;" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/453888ff18067537923798165513aa20/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2017-12-29T15:37:38+08:00" />
<meta property="article:modified_time" content="2017-12-29T15:37:38+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">常用注解（Annotation）整理</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-atom-one-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h6 id="1java中autowired或resource这两个注解功能都是相同的这两个注解的区别autowired默认按类型装配resource默认按名称装配当找不到与名称匹配的bean时才会按类型装配">1.Java中@Autowired或@Resource这两个注解功能都是相同的，这两个注解的区别：@Autowired默认按类型装配，@Resource默认按名称装配，当找不到与名称匹配的bean时才会按类型装配。</h6> 
<h6 id="2autowiredqualifierresource三者的区别">2.@Autowired、@Qualifier、@Resource三者的区别：</h6> 
<p>简单理解： <br> @Autowired 默认根据类型注入； <br> @Resource 默认根据名字注入，其次按照类型注入； <br> @Autowired @Qualifier(“userService”) 两个结合起来默认按类型注入，其次按名字注入。</p> 
<h6 id="3springspringmvc中常用注解对比">3.spring/springMVC中常用注解对比：</h6> 
<p>@Configuration — spring配置文件中的<code>&lt;beans&gt;&lt;/beans&gt;</code></p> 
<p>@Bean — spring配置文件中的<code>&lt;bean&gt;&lt;/bean&gt;</code></p> 
<p>@Autowired 、@Named 两个注解可以互换使用 </p> 
<p>@Component 、@Inject两个注解可以互换使用</p> 
<p>@ContextConfiguration — spring整个配置文件(applicationContext.xml)</p> 
<p>@componentScan — spring配置文件中的<code>&lt;context：component-scan base-package=“xxx”/&gt;</code></p> 
<p>@Service(“name”) — spring配置文件中的<code>&lt;bean class="xxx" id="name"&gt;</code> id=name</p> 
<p>@Scope 代表spring容器的生命周期，取值有singleton、prototype 、request 、session 、global session五种。 <br> 注意：request、session和global session类型只实用于web程序，通常是和XmlWebApplicationContext共同使用。</p> 
<p>@EnableScheduling:开启对定时任务的支持; <br> @Scheduled：声明一个定时任务;</p> 
<p>@Conditional:满足一定条件来创建一个特定的bean;</p> 
<p>@RequestHeader ： 可以把Request请求header部分的值绑定到方法的参数上。</p> 
<pre class="prettyprint"><code class=" hljs lasso">Request的<span class="hljs-keyword">Header</span>部分：
Host                    localhost:<span class="hljs-number">8080</span> 
Accept                  text/html,application/xhtml<span class="hljs-subst">+</span><span class="hljs-built_in">xml</span>,application/<span class="hljs-built_in">xml</span>;q<span class="hljs-subst">=</span><span class="hljs-number">0.9</span> 
Accept<span class="hljs-attribute">-Language</span>         fr,en<span class="hljs-attribute">-gb</span>;q<span class="hljs-subst">=</span><span class="hljs-number">0.7</span>,en;q<span class="hljs-subst">=</span><span class="hljs-number">0.3</span> 
Accept<span class="hljs-attribute">-Encoding</span>         gzip,deflate 
Accept<span class="hljs-attribute">-Charset</span>          ISO<span class="hljs-subst">-</span><span class="hljs-number">8859</span><span class="hljs-subst">-</span><span class="hljs-number">1</span>,utf<span class="hljs-subst">-</span><span class="hljs-number">8</span>;q<span class="hljs-subst">=</span><span class="hljs-number">0.7</span>,<span class="hljs-subst">*</span>;q<span class="hljs-subst">=</span><span class="hljs-number">0.7</span> 
Keep<span class="hljs-attribute">-Alive</span>              <span class="hljs-number">300</span> 

@RequestMapping(<span class="hljs-string">"/displayHeaderInfo.do"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> displayHeaderInfo(
          @RequestHeader(<span class="hljs-string">"Accept-Encoding"</span>) <span class="hljs-built_in">String</span> encoding,
          @RequestHeader(<span class="hljs-string">"Keep-Alive"</span>) long keepAlive) {
     <span class="hljs-comment">// ...</span>
}
上面的代码，把request <span class="hljs-keyword">header</span>部分的 Accept<span class="hljs-attribute">-Encoding</span>的值，绑定到参数encoding上了， Keep<span class="hljs-attribute">-Alive</span> <span class="hljs-keyword">header</span>的值绑定到参数keepAlive上。</code></pre> 
<p>@CookieValue ： 可以把Request header中关于cookie的值绑定到方法的参数上。 </p> 
<pre class="prettyprint"><code class="language-如下Cookie值： hljs r">JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84  

@RequestMapping(<span class="hljs-string">"/displayHeaderInfo.do"</span>) 
public void displayHeaderInfo(@CookieValue(<span class="hljs-string">"JSESSIONID"</span>) String cookie)  { 
  //<span class="hljs-keyword">...</span> 
}
即把JSESSIONID的值绑定到参数cookie上。</code></pre> 
<p>@RequestParam ：获取参数;SpringMVC获取后台控制层参数有两种： <br> 1.request.getParameter(“属性名”); 2.@requestParam。</p> 
<pre class="prettyprint"><code class=" hljs r"><span class="hljs-number">1.</span>常用来处理简单类型的绑定，通过Request.getParameter() 获取的String可直接转换为简单类型的情况（ String--&gt; 简单类型的转换操作由ConversionService配置的转换器来完成）;因为使用request.getParameter()方式获取参数，所以可以处理get 方式中queryString的值，也可以处理post方式中 body data的值;
<span class="hljs-number">2.</span>用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容，提交方式GET、POST;
<span class="hljs-number">3.</span>该注解有两个属性： value、required； value用来指定要传入值的id名称，required用来指示参数是否必须绑定;
@Controller 
@RequestMapping(<span class="hljs-string">"/pets"</span>) 
@SessionAttributes(<span class="hljs-string">"pet"</span>) 
public class EditPetForm { 
    // <span class="hljs-keyword">...</span> 
    @RequestMapping(method = RequestMethod.GET) 
    public String setupForm(@RequestParam(<span class="hljs-string">"petId"</span>) int petId, ModelMap model) { 
        Pet pet = this.clinic.loadPet(petId); 
        model.addAttribute(<span class="hljs-string">"pet"</span>, pet); 
        <span class="hljs-keyword">return</span> <span class="hljs-string">"petForm"</span>; 
    } 
    // <span class="hljs-keyword">...</span></code></pre> 
<p>@RequestBody ： 将HTTP请求正文转换为适合的HttpMessageConverter对象。[SpringMVC] <br> @ResponseBody ：将内容或对象作为 HTTP 响应正文返回，并调用适合HttpMessageConverter的Adapter转换对象，写入输出流。[SpringMVC]</p> 
<pre class="prettyprint"><code class=" hljs xml">HttpMessageConverter接口，需要开启<span class="hljs-tag">&lt;<span class="hljs-title">mvc:annotation-driven</span>  /&gt;</span>。
AnnotationMethodHandlerAdapter将会初始化7个转换器，可以通过调用AnnotationMethodHandlerAdapter的getMessageConverts()方法来获取转换器的一个集合 List<span class="hljs-tag">&lt;<span class="hljs-title">HttpMessageConverter</span>&gt;</span>

引用：
ByteArrayHttpMessageConverter
StringHttpMessageConverter
ResourceHttpMessageConverter
SourceHttpMessageConverter
XmlAwareFormHttpMessageConverter
Jaxb2RootElementHttpMessageConverter
MappingJacksonHttpMessageConverter</code></pre> 
<p>@SessionAttributes:用来绑定HttpSession中的attribute对象的值，便于在方法中的参数里使用。该注解有value、types两个属性，可以通过名字和类型指定要使用的attribute 对象;</p> 
<pre class="prettyprint"><code class=" hljs r">@Controller 
@RequestMapping(<span class="hljs-string">"/editPet.do"</span>) 
@SessionAttributes(<span class="hljs-string">"pet"</span>) 
public class EditPetForm { 
    // <span class="hljs-keyword">...</span> 
}</code></pre> 
<p>@ModelAttribute: <br> 该注解有两个用法，一个是用于方法上，一个是用于参数上； <br> 用于方法上时： 通常用来在处理@RequestMapping之前，为请求绑定需要从后台查询的model； <br> 用于参数上时： 用来通过名称对应，把相应名称的值绑定到注解的参数bean上；要绑定的值来源于： <br> 1. @SessionAttributes 启用的attribute 对象上； <br> 2.@ModelAttribute 用于方法上时指定的model对象； <br> 3.上述两种情况都没有时，new一个需要绑定的bean对象，然后把request中按名称对应的方式把值绑定到bean中。</p> 
<pre class="prettyprint"><code class=" hljs java">用到方法上<span class="hljs-annotation">@ModelAttribute</span>的示例代码：
<span class="hljs-comment">// Add one attribute </span>
<span class="hljs-comment">// The return value of the method is added to the model under the name "account" </span>
<span class="hljs-comment">// You can customize the name via @ModelAttribute("myAccount") </span>
<span class="hljs-annotation">@ModelAttribute</span> 
<span class="hljs-keyword">public</span> Account <span class="hljs-title">addAccount</span>(@RequestParam String number) { 
    <span class="hljs-keyword">return</span> accountManager.findAccount(number); 
}
这种方式实际的效果就是在调用<span class="hljs-annotation">@RequestMapping</span>的方法之前，为request对象的model里put(“account”， Account)；

用在参数上的<span class="hljs-annotation">@ModelAttribute</span>示例代码：
<span class="hljs-annotation">@RequestMapping</span>(value=<span class="hljs-string">"/owners/{ownerId}/pets/{petId}/edit"</span>, method = RequestMethod.POST) 
<span class="hljs-keyword">public</span> String <span class="hljs-title">processSubmit</span>(@ModelAttribute Pet pet) { 
    <span class="hljs-comment">//......</span>
}  
首先查询 <span class="hljs-annotation">@SessionAttributes</span>有无绑定的Pet对象，若没有则查询<span class="hljs-annotation">@ModelAttribute</span>方法层面上是否绑定了Pet对象，若没有则将URI template中的值按对应的名称绑定到Pet对象的各属性上。

问题：在不给定注解的情况下，参数是怎样绑定的？
通过分析AnnotationMethodHandlerAdapter和RequestMappingHandlerAdapter的源代码发现，方法的参数在不给定参数的情况下：
    若要绑定的对象时简单类型： 调用<span class="hljs-annotation">@RequestParam</span>来处理的。 
    若要绑定的对象时复杂类型： 调用<span class="hljs-annotation">@ModelAttribute</span>来处理的。
    这里的简单类型指java的原始类型(<span class="hljs-keyword">boolean</span>, <span class="hljs-keyword">int</span> 等)、原始类型对象（Boolean, Int等）、String、Date等ConversionService里可以直接String转换成目标对象的类型；</code></pre> 
<p>@PathVariable : 当使用@RequestMapping URI template 样式映射时, 即someUrl/{paramId}, 这时的paramId可通过@Pathvariable注解绑定它传过来的值到方法的参数上。[SpringMVC] <br> 例如：</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-annotation">@Controller</span>
<span class="hljs-annotation">@RequestMapping</span>(<span class="hljs-string">"/owners/{ownerId}"</span>)
<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RelativePathUriTemplateController</span> {<!-- --></span>
     <span class="hljs-annotation">@RequestMapping</span>(<span class="hljs-string">"/pets/{petId}"</span>)
     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findPet</span>(@PathVariable String ownerId,@PathVariable String petId, Model model) {
          <span class="hljs-comment">// implementation omitted</span>
     }
}</code></pre> 
<p>@SuppressWarnings(value=”unchecked”):用于抑制编译器产生警告信息。value默认为checked。</p> 
<p>@PropertySource:注入配置文件;</p> 
<p>@Value():读取参数;详细原理如下讲解：</p> 
<pre class="prettyprint"><code class=" hljs applescript">@Value()需要的参数有两种形式：@Value(<span class="hljs-string">"#{configProperties['t1.msgname']}"</span>)或者@Value(<span class="hljs-string">"${t1.msgname}"</span>)

配置上的区别：
<span class="hljs-number">1.</span>@Value(<span class="hljs-string">"#{configProperties['t1.msgname']}"</span>)这种形式的配置中有“configProperties”，其实它指定的是配置文件的加载对象：配置如下：
&lt;bean <span class="hljs-property">id</span>=<span class="hljs-string">"configProperties"</span>
     <span class="hljs-type">class</span>=<span class="hljs-string">"org.springframework.beans.factory.config.PropertiesFactoryBean"</span>&gt;
     &lt;<span class="hljs-keyword">property</span> <span class="hljs-property">name</span>=<span class="hljs-string">"locations"</span>&gt;
          &lt;<span class="hljs-type">list</span>&gt;
               &lt;value&gt;classpath:/config/t1.properties&lt;/value&gt;
          &lt;/<span class="hljs-type">list</span>&gt;
     &lt;/<span class="hljs-keyword">property</span>&gt;
&lt;/bean&gt;
这样配置就可完成对属性的具体注入了
<span class="hljs-number">2.</span>@Value(<span class="hljs-string">"${t1.msgname}"</span>)这种形式不需要指定具体加载对象，这时候需要一个关键的对象来完成PreferencesPlaceholderConfigurer，这个对象的配置可以利用上面配置<span class="hljs-number">1</span>中的配置，也可以自己直接自定配置文件路径。
    如果使用配置<span class="hljs-number">1</span>中的配置，可以写成如下情况：
&lt;bean <span class="hljs-property">id</span>=<span class="hljs-string">"propertyConfigurer"</span>
     <span class="hljs-type">class</span>=<span class="hljs-string">"org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer"</span>&gt;
     &lt;<span class="hljs-keyword">property</span> <span class="hljs-property">name</span>=<span class="hljs-string">"properties"</span> <span class="hljs-keyword">ref</span>=<span class="hljs-string">"configProperties"</span> /&gt;
&lt;/bean&gt;
如果直接指定配置文件的话，可以写成如下情况：
&lt;bean <span class="hljs-property">id</span>=<span class="hljs-string">"propertyConfigurer"</span>
     <span class="hljs-type">class</span>=<span class="hljs-string">"org.springframework.beans.factory.config.PreferencesPlaceholderConfigurer"</span>&gt;
     &lt;<span class="hljs-keyword">property</span> <span class="hljs-property">name</span>=<span class="hljs-string">"location"</span>&gt;
          &lt;value&gt;config/t1.properties&lt;/value&gt;
     &lt;/<span class="hljs-keyword">property</span>&gt;
&lt;/bean&gt;
</code></pre> 
<p>@JmsListener：监听消费，实现了异步消费。 <br> 在官方文档中已经说明需要支持@JmsListener注解，则需要在任意@Configuration类添加@EnableJms注解，同时还需要配置DefaultJmsListenerContainerFactory的Bean实例：</p> 
<pre class="prettyprint"><code class=" hljs scala">Bean方式配置：
<span class="hljs-annotation">@Configuration</span>
<span class="hljs-annotation">@EnableJms</span>
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GatewayActiveMQFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractActiveMQFactory</span> {<!-- --></span>
     <span class="hljs-comment">//……</span>
}

XML方式配置：
&lt;jms:annotation-driven/&gt;
&lt;bean id=<span class="hljs-string">"jmsListenerContainerFactory"</span> <span class="hljs-keyword">class</span>=<span class="hljs-string">"org.springframework.jms.config.DefaultJmsListenerContainerFactory"</span>&gt;
     &lt;property name=<span class="hljs-string">"connectionFactory"</span> ref=<span class="hljs-string">"connectionFactory"</span>/&gt;
     &lt;property name=<span class="hljs-string">"destinationResolver"</span> ref=<span class="hljs-string">"destinationResolver"</span>/&gt;
     &lt;property name=<span class="hljs-string">"concurrency"</span> ref=<span class="hljs-string">"3-10"</span>/&gt;
&lt;/bean&gt;</code></pre> 
<p>@EnableWs: 启动webservice。 <br> Spring Boot整合spring-ws开发web service</p> 
<pre class="prettyprint"><code class=" hljs scala"><span class="hljs-number">1.</span>添加依赖
   spring boot的工程，除了spring boot外还需要添加spring-ws和wsdl4j的依赖，当然后面生成代码还需要添加maven的jaxb2插件。
&lt;dependency&gt;
     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
     &lt;artifactId&gt;spring-boot-starter-web-services&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
     &lt;groupId&gt;wsdl4j&lt;/groupId&gt;
     &lt;artifactId&gt;wsdl4j&lt;/artifactId&gt;
     &lt;version&gt;<span class="hljs-number">1.6</span><span class="hljs-number">.3</span>&lt;/version&gt;
&lt;/dependency&gt;
<span class="hljs-number">2.</span>编写schema文件
spring-ws的发布，都是以一个schema文件(xsd)定义开始的，它描述了web service的参数以及返回的数据。
下面是官方示例给出的countries.xsd，这里我们也以它为例，当然命名空间改掉了，因为等会jaxb2插件生成代码是以它来确定包名的：
&lt;xs:schema xmlns:xs=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema"</span>;
xmlns:tns=<span class="hljs-string">"UpdateAppAcctSoap"</span>;<span class="hljs-comment">//由程序员自己定义 </span>
targetNamespace=<span class="hljs-string">"UpdateAppAcctSoap"</span>; <span class="hljs-comment">//由程序员自己定义</span>
elementFormDefault=<span class="hljs-string">"qualified"</span>&gt;
     &lt;xs:element name=<span class="hljs-string">"RequestInfo"</span>&gt;
        &lt;xs:complexType&gt;
            &lt;xs:simpleContent&gt;
                &lt;xs:extension  base=<span class="hljs-string">"xs:string"</span> /&gt;
            &lt;/xs:simpleContent&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
    &lt;xs:element name=<span class="hljs-string">"ResponseInfo"</span>&gt;
        &lt;xs:complexType&gt;
            &lt;xs:simpleContent&gt;
                &lt;xs:extension  base=<span class="hljs-string">"xs:string"</span> /&gt;
            &lt;/xs:simpleContent&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;

    &lt;!--
     &lt;xs:element name=<span class="hljs-string">"getCountryRequest"</span>&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element name=<span class="hljs-string">"name"</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"xs:string"</span>/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
    &lt;xs:element name=<span class="hljs-string">"getCountryResponse"</span>&gt;
        &lt;xs:complexType&gt;
            &lt;xs:sequence&gt;
                &lt;xs:element name=<span class="hljs-string">"country"</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"tns:country"</span>/&gt;
            &lt;/xs:sequence&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;
    &lt;xs:complexType name=<span class="hljs-string">"country"</span>&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element name=<span class="hljs-string">"name"</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"xs:string"</span>/&gt;
            &lt;xs:element name=<span class="hljs-string">"population"</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"xs:int"</span>/&gt;
            &lt;xs:element name=<span class="hljs-string">"capital"</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"xs:string"</span>/&gt;
            &lt;xs:element name=<span class="hljs-string">"currency"</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">"tns:currency"</span>/&gt;
        &lt;/xs:sequence&gt;
    &lt;/xs:complexType&gt;
    &lt;xs:simpleType name=<span class="hljs-string">"currency"</span>&gt;
        &lt;xs:restriction base=<span class="hljs-string">"xs:string"</span>&gt;
            &lt;xs:enumeration value=<span class="hljs-string">"GBP"</span>/&gt;
            &lt;xs:enumeration value=<span class="hljs-string">"EUR"</span>/&gt;
            &lt;xs:enumeration value=<span class="hljs-string">"PLN"</span>/&gt;
        &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
    --&gt;
&lt;/xs:schema&gt;
<span class="hljs-number">3.</span>添加maven的jaxb2插件来生成代码
jaxb2插件可以根据描述的xsd文件来帮我们生成相应的ws代码，具体配置如下：
&lt;plugin&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
&lt;/plugin&gt;
&lt;plugin&gt;
    &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;
    &lt;artifactId&gt;jaxb2-maven-plugin&lt;/artifactId&gt;
    &lt;version&gt;<span class="hljs-number">1.6</span>&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;xjc&lt;/id&gt;
            &lt;goals&gt;
                &lt;goal&gt;xjc&lt;/goal&gt;
            &lt;/goals&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;configuration&gt;
        &lt;schemaDirectory&gt;${project.basedir}/src/main/resources<span class="hljs-comment">//schema&lt;/schemaDirectory&gt;</span>
        &lt;outputDirectory&gt;${project.basedir}/src/main/java&lt;/outputDirectory&gt;
        &lt;clearOutputDir&gt;<span class="hljs-keyword">false</span>&lt;/clearOutputDir&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
配置好插件然后install一下，这样web service需要的服务端代码就已经帮我们生成好了，根据上面的xsd，生成的代码在相应的包下。
<span class="hljs-number">4.</span>编写Endpoint
我们就不再像spring-ws官方那样再建一个Repository了，这里直接返回。需要注意PayloadRoot注解当中的namespace和localPart需要和xsd中对应。
<span class="hljs-annotation">@Endpoint</span>
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UpdateAppAcctSoap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RestBase</span> {<!-- --></span>
    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> String NAMESPACE_URI = <span class="hljs-string">"UpdateAppAcctSoap"</span>;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(UpdateAppAcctSoap.<span class="hljs-keyword">class</span>);
    <span class="hljs-annotation">@Autowired</span>
    HttpServletRequest request;
    <span class="hljs-annotation">@Autowired</span>
    ILog iLog;
    <span class="hljs-annotation">@Autowired</span>
    IUpdateAppAcctService appAcctService;

    <span class="hljs-annotation">@PayloadRoot</span>(namespace = NAMESPACE_URI, localPart = <span class="hljs-string">"RequestInfo"</span>)
    <span class="hljs-annotation">@ResponsePayload</span>
    public ResponseInfo doService(<span class="hljs-annotation">@RequestPayload</span> RequestInfo requestInfo) {
        iLog.info(logger, getTransNo(request), <span class="hljs-keyword">null</span>, <span class="hljs-string">""</span>, requestInfo);
        String res = appAcctService.doService(requestInfo.getValue(), getTransNo(request));
        ResponseInfo responseInfo = <span class="hljs-keyword">new</span> ResponseInfo();
        responseInfo.setValue(res);
        <span class="hljs-keyword">return</span> responseInfo;
    }
}
【RequestInfo类的写法：】
<span class="hljs-annotation">@XmlAccessorType</span>(XmlAccessType.FIELD)
<span class="hljs-annotation">@XmlType</span>(name = <span class="hljs-string">""</span>, propOrder = {
    <span class="hljs-string">"value"</span>
})
<span class="hljs-annotation">@XmlRootElement</span>(name = <span class="hljs-string">"RequestInfo"</span>, namespace = <span class="hljs-string">"UpdateAppAcctSoap"</span>)
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestInfo</span> {<!-- --></span>
    <span class="hljs-annotation">@XmlValue</span>
    <span class="hljs-keyword">protected</span> String value;
    <span class="hljs-javadoc">/**
     * 获取value属性的值。
     * <span class="hljs-javadoctag">@return</span>
     *     possible object is
     *     {<!-- --><span class="hljs-javadoctag">@link</span> String }  
     */</span>
    public String getValue() {
        <span class="hljs-keyword">return</span> value;
    }
    <span class="hljs-javadoc">/**
     * 设置value属性的值。
     * <span class="hljs-javadoctag">@param</span> value
     *     allowed object is
     *     {<!-- --><span class="hljs-javadoctag">@link</span> String }  
     */</span>
    public void setValue(String value) {
        <span class="hljs-keyword">this</span>.value = value;
    }
}   
【ResponseInfo类的写法：】
<span class="hljs-annotation">@XmlAccessorType</span>(XmlAccessType.FIELD)
<span class="hljs-annotation">@XmlType</span>(name = <span class="hljs-string">""</span>, propOrder = {
    <span class="hljs-string">"value"</span>
})
<span class="hljs-annotation">@XmlRootElement</span>(name = <span class="hljs-string">"ResponseInfo"</span>, namespace = <span class="hljs-string">"UpdateAppAcctSoap"</span>)
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResponseInfo</span> {<!-- --></span>
    <span class="hljs-annotation">@XmlValue</span>
    <span class="hljs-keyword">protected</span> String value;
    <span class="hljs-javadoc">/**
     * 获取value属性的值。
     *
     * <span class="hljs-javadoctag">@return</span>
     *     possible object is
     *     {<!-- --><span class="hljs-javadoctag">@link</span> String }
     *    
     */</span>
    public String getValue() {
        <span class="hljs-keyword">return</span> value;
    }
    <span class="hljs-javadoc">/**
     * 设置value属性的值。
     *
     * <span class="hljs-javadoctag">@param</span> value
     *     allowed object is
     *     {<!-- --><span class="hljs-javadoctag">@link</span> String }
     *    
     */</span>
    public void setValue(String value) {
        <span class="hljs-keyword">this</span>.value = value;
    }
}
<span class="hljs-number">5.</span>在spring boot中配置web service
<span class="hljs-annotation">@EnableWs</span>
<span class="hljs-annotation">@Configuration</span>
public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebServiceConfig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WsConfigurerAdapter</span> {<!-- --></span>
    <span class="hljs-annotation">@Bean</span>
    public ServletRegistrationBean messageDispatcherServlet(ApplicationContext applicationContext) {
        MessageDispatcherServlet servlet = <span class="hljs-keyword">new</span> MessageDispatcherServlet();
        servlet.setApplicationContext(applicationContext);
        servlet.setTransformWsdlLocations(<span class="hljs-keyword">true</span>);
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServletRegistrationBean(servlet, <span class="hljs-string">"/webservice/*"</span>);
    }
    <span class="hljs-annotation">@Bean</span>(name = <span class="hljs-string">"UpdateAppAcctSoap"</span>)
    public DefaultWsdl11Definition defaultWsdl11Definition(XsdSchema countriesSchema) {
        DefaultWsdl11Definition wsdl11Definition = <span class="hljs-keyword">new</span> DefaultWsdl11Definition();
        wsdl11Definition.setPortTypeName(<span class="hljs-string">"UpdateAppAcctSoap"</span>);
        wsdl11Definition.setLocationUri(<span class="hljs-string">"/webservice"</span>);
        wsdl11Definition.setTargetNamespace(Access4aConstants.NAMESPACE);
        wsdl11Definition.setSchema(countriesSchema);
        <span class="hljs-keyword">return</span> wsdl11Definition;
    }
    <span class="hljs-annotation">@Bean</span>
    public XsdSchema countriesSchema() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SimpleXsdSchema(<span class="hljs-keyword">new</span> ClassPathResource(<span class="hljs-string">"UpdateAppAcctSoap.xsd"</span>));
    }
}
到这里spring-ws的所有配置和工作都已经完成了，上面的DefaultWsdl11Definition 中的name默认就是发布的ws的访问路径。 
</code></pre> 
<p>4.Spirng中@PostConstruce和@PreDestroy详解： <br> 这两个注解作用于Servlet生命周期的注解，实现Bean初始化之前和销毁之前的自定义操作。</p> 
<p>API文档说明：</p> 
<pre class="prettyprint"><code class=" hljs java"><span class="hljs-annotation">@PostConstruct</span> 注释用于在依赖关系注入完成之后需要执行的方法上，以执行任何初始化。此方法必须在将类放入服务之前调用。支持依赖关系注入的所有类都必须支持此注释。即使类没有请求注入任何资源，用 PostConstruct 注释的方法也必须被调用。只有一个方法可以用此注释进行注释。应用 PostConstruct 注释的方法必须遵守以下所有标准：该方法不得有任何参数，除非是在 EJB 拦截器 (interceptor) 的情况下，根据 EJB 规范的定义，在这种情况下它将带有一个 InvocationContext 对象 ；该方法的返回类型必须为 <span class="hljs-keyword">void</span>；该方法不得抛出已检查异常；应用 PostConstruct 的方法可以是 <span class="hljs-keyword">public</span>、<span class="hljs-keyword">protected</span>、<span class="hljs-keyword">package</span> <span class="hljs-keyword">private</span> 或 <span class="hljs-keyword">private</span>；除了应用程序客户端之外，该方法不能是 <span class="hljs-keyword">static</span>；该方法可以是 <span class="hljs-keyword">final</span>；如果该方法抛出未检查异常，那么不得将类放入服务中，除非是能够处理异常并可从中恢复的 EJB。</code></pre> 
<p><strong>使用@PostConstruce和@PreDestroy注解应注意：</strong></p> 
<ul><li>只有一个方法可以使用此注释进行注解；</li><li>被注解方法不得有任何参数；</li><li>被注解方法返回值为void；</li><li>被注解方法不得抛出已检查异常；</li><li>被注解方法需是非静态方法；</li><li><p>此方法只会被执行一次； <br> <strong>Servlet执行流程图：</strong> <br> <img src="https://images2.imgbox.com/44/b6/KmEzGJ6x_o.png" alt="TUPIAN" title=""> <br> <font color="red">在具体Bean的实例化过程中，@PostConstruce注释的方法，会在构造方法之后，init()方法之前调用。</font> <br> @PostConstruce主要应用在初始化Servlet时加载一些缓存数据。 <br> 注意：此注解会影响服务的启动时间；在启动时会扫描WEB-INF/classes的所有文件和WEB-INF/lib下的所有jar包。 <br> 5.@Controller和@RestContoller[SpringMVC] 区别： <br> 官方文档： <br> @RestController is a stereotype annotation that combines @ResponseBody and @Controller. <br> 意思是： <br> @RestController注解相当于@ResponseBody + @Controller合在一起的作用。 </p></li><li><p>如果只是使用@RestController注解Controller，则Controller中的方法无法返回jsp页面，配置的视图解析器InternalResourceViewResolver不起作用，返回的内容就是Return 里的内容。 <br> 例如：本来应该到success.jsp页面的，则其显示success.</p></li><li><p>如果需要返回到指定页面，则需要用 @Controller配合视图解析器InternalResourceViewResolver才行。</p></li><li><p>如果需要返回JSON，XML或自定义mediaType内容到页面，则需要在对应的方法上加上@ResponseBody注解。 </p></li></ul> 
<p>@WiselyConfiguration注解相当于@Configuration + @ComponentScan</p> 
<p>6.Enable*注解： <br> @EnableAspectJAutoProxy:开启对AspectJ自动代理的支持; <br> @EnableAsync:开启异步方法的支持; <br> @EnableScheduling：开启定时任务的支持; <br> @EnableWebMvc：开启Web MVC配置的支持; <br> @EnableConfigurationProperties:开启对@ConfigurationProperties注解配置Bean的支持; <br> @EnableJpaRespositories:开启对Spring Data JPA Repository的支持; <br> @EnableTransactionManagement：开启注解式事务的支持; <br> @EnableCaching:开启注解式的缓存支持;</p> 
<p>@ActiveProfiles：声明活动的profile; <br> @Profile(“dev”):指定环境;</p> 
<p>7.SpringMVC常用注解： <br> @ControllerAdvice：声明一个控制器建言(全局);l <br> @ExceptionHandler:全局处理控制器里的异常; <br> @InitBinder：定制WebDataBinder;</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/ceac4379865ec3382c17b032b8997962/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">spring data jpa 学习整理</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/897dd95f27ea7793ed652175192bff7c/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">Android 5分钟实现ShareSDK分享各平台</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>