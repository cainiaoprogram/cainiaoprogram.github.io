<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>数据库汇总 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="数据库汇总" />
<meta property="og:description" content="目录
1. 什么是MySQL?
2.MySQL存储引擎MyISAM与InnoDB
3.事务四大特性
4.MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景
5. 索引
6. InnoDB索引和MyISAM索引的区别
7. Sql的优化
8. 数据库的主从复制
9.varchar和char的使用场景
10.数据库连接池的作用
11. 数据库三范式
12. 关系型数据库和非关系型数据库区别
13. 数据库中join的left join , inner join, cross join
14.有哪些锁,select时怎么加排它锁
15. 死锁怎么解决
16. 事务
17. 视图
18. 游标
19. 存储过程
20. 触发器
21. drop、delete与truncate的区别
22. UNION与UNION ALL的区别
23. Mysql分页
24. 数据库优化
1. 什么是MySQL? MySQL是一个关系型数据库管理系统
2.MySQL存储引擎MyISAM与InnoDB 常用的存储引擎有以下： Innodb引擎：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。
MyISAM引擎(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。
MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。
MyISAM与InnoDB区别： MyISAM：
每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件；存储空间较小数据和索引是分别存储的，数据.MYD，索引.MYI按记录插入顺序保存不支持外键和事务；不支持哈希索引，支持全文索引；表级锁定B&#43;树索引，myisam 是堆表 Innodb：
所有的表都保存在同一个数据文件中数据和索引是集中存储的，.ibd按主键大小有序插入支持外键和事务行级锁定、表级锁定，锁定力度小并发能力高支持哈希索引，不支持全文索引B&#43;树索引，Innodb 是索引组织表 select count(*)，myisam更快，因为myisam内部维护了一个计数器，可以直接调取。INSERT、UPDATE、DELETEInnoDB更优，SELECTMyISAM更优。
3.事务四大特性 原子性，要么执行，要么不执行 隔离性，所有操作全部执行完以前其它会话不能看到过程一致性，事务前后，数据总额一致持久性，一旦事务提交，对数据的改变就是永久的 4." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/589e9530503ddaeea8f1ce5bae2a894b/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-08-05T17:19:43+08:00" />
<meta property="article:modified_time" content="2022-08-05T17:19:43+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">数据库汇总</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="htmledit_views">
                    <p id="main-toc"><strong>目录</strong></p> 
<p id="-toc" style="margin-left:80px;"></p> 
<p id="1.%20%E4%BB%80%E4%B9%88%E6%98%AFMySQL%3F-toc" style="margin-left:80px;"><a href="#1.%20%E4%BB%80%E4%B9%88%E6%98%AFMySQL%3F" rel="nofollow">1. 什么是MySQL?</a></p> 
<p id="MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EMyISAM%E4%B8%8EInnoDB-toc" style="margin-left:80px;"><a href="#MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EMyISAM%E4%B8%8EInnoDB" rel="nofollow">2.MySQL存储引擎MyISAM与InnoDB</a></p> 
<p id="3.%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7-toc" style="margin-left:80px;"><a href="#3.%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7" rel="nofollow">3.事务四大特性</a></p> 
<p id="4.%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8BMYSQL%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BA%8B%E5%8A%A1%E3%80%81%E9%94%81%E7%BA%A7%E5%88%AB%E7%AD%89%E7%AD%89%EF%BC%89%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:80px;"><a href="#4.%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8BMYSQL%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BA%8B%E5%8A%A1%E3%80%81%E9%94%81%E7%BA%A7%E5%88%AB%E7%AD%89%E7%AD%89%EF%BC%89%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">4.MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景</a></p> 
<p id="5.%20%E7%B4%A2%E5%BC%95-toc" style="margin-left:80px;"><a href="#5.%20%E7%B4%A2%E5%BC%95" rel="nofollow">5. 索引</a></p> 
<p id="6.%20InnoDB%E7%B4%A2%E5%BC%95%E5%92%8CMyISAM%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#6.%20InnoDB%E7%B4%A2%E5%BC%95%E5%92%8CMyISAM%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">6. InnoDB索引和MyISAM索引的区别</a></p> 
<p id="7.%20Sql%E7%9A%84%E4%BC%98%E5%8C%96-toc" style="margin-left:80px;"><a href="#7.%20Sql%E7%9A%84%E4%BC%98%E5%8C%96" rel="nofollow">7. Sql的优化</a></p> 
<p id="8.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6-toc" style="margin-left:80px;"><a href="#8.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6" rel="nofollow">8. 数据库的主从复制</a></p> 
<p id="9.varchar%E5%92%8Cchar%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-toc" style="margin-left:80px;"><a href="#9.varchar%E5%92%8Cchar%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" rel="nofollow">9.varchar和char的使用场景</a></p> 
<p id="10.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8-toc" style="margin-left:80px;"><a href="#10.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8" rel="nofollow">10.数据库连接池的作用</a></p> 
<p id="11.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F-toc" style="margin-left:80px;"><a href="#11.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F" rel="nofollow">11. 数据库三范式</a></p> 
<p id="12.%20%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#12.%20%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%BA%E5%88%AB" rel="nofollow">12. 关系型数据库和非关系型数据库区别</a></p> 
<p id="13.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%ADjoin%E7%9A%84left%20join%20%2C%20inner%20join%2C%20cross%20join-toc" style="margin-left:80px;"><a href="#13.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%ADjoin%E7%9A%84left%20join%20%2C%20inner%20join%2C%20cross%20join" rel="nofollow">13. 数据库中join的left join , inner join, cross join</a></p> 
<p id="14.%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81%2Cselect%E6%97%B6%E6%80%8E%E4%B9%88%E5%8A%A0%E6%8E%92%E5%AE%83%E9%94%81-toc" style="margin-left:80px;"><a href="#14.%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81%2Cselect%E6%97%B6%E6%80%8E%E4%B9%88%E5%8A%A0%E6%8E%92%E5%AE%83%E9%94%81" rel="nofollow">14.有哪些锁,select时怎么加排它锁</a></p> 
<p id="15.%20%E6%AD%BB%E9%94%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3-toc" style="margin-left:80px;"><a href="#15.%20%E6%AD%BB%E9%94%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3" rel="nofollow">15. 死锁怎么解决</a></p> 
<p id="16.%20%E4%BA%8B%E5%8A%A1-toc" style="margin-left:80px;"><a href="#16.%20%E4%BA%8B%E5%8A%A1" rel="nofollow">16. 事务</a></p> 
<p id="17.%20%E8%A7%86%E5%9B%BE-toc" style="margin-left:80px;"><a href="#17.%20%E8%A7%86%E5%9B%BE" rel="nofollow">17. 视图</a></p> 
<p id="18.%20%E6%B8%B8%E6%A0%87-toc" style="margin-left:80px;"><a href="#18.%20%E6%B8%B8%E6%A0%87" rel="nofollow">18. 游标</a></p> 
<p id="19.%20%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B-toc" style="margin-left:80px;"><a href="#19.%20%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B" rel="nofollow">19. 存储过程</a></p> 
<p id="20.%20%E8%A7%A6%E5%8F%91%E5%99%A8-toc" style="margin-left:80px;"><a href="#20.%20%E8%A7%A6%E5%8F%91%E5%99%A8" rel="nofollow">20. 触发器</a></p> 
<p id="21.%20drop%E3%80%81delete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#21.%20drop%E3%80%81delete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">21. drop、delete与truncate的区别</a></p> 
<p id="22.%20UNION%E4%B8%8EUNION%20ALL%E7%9A%84%E5%8C%BA%E5%88%AB-toc" style="margin-left:80px;"><a href="#22.%20UNION%E4%B8%8EUNION%20ALL%E7%9A%84%E5%8C%BA%E5%88%AB" rel="nofollow">22. UNION与UNION ALL的区别</a></p> 
<p id="23.%20Mysql%E5%88%86%E9%A1%B5-toc" style="margin-left:80px;"><a href="#23.%20Mysql%E5%88%86%E9%A1%B5" rel="nofollow">23. Mysql分页</a></p> 
<p id="24.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96-toc" style="margin-left:80px;"><a href="#24.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96" rel="nofollow">24. 数据库优化</a></p> 
<hr id="hr-toc"> 
<h4 id="1.%20%E4%BB%80%E4%B9%88%E6%98%AFMySQL%3F"><strong><strong><strong>1. 什么是MySQL?</strong></strong></strong></h4> 
<p>MySQL是一个关系型数据库管理系统</p> 
<h4 id="MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8EMyISAM%E4%B8%8EInnoDB"><strong><strong><strong>2.MySQL存储引擎MyISAM与InnoDB</strong></strong></strong></h4> 
<ul><li>常用的存储引擎有以下：</li></ul> 
<p style="margin-left:0pt;"><span style="color:#c00000;">Innodb引擎</span>：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</p> 
<p style="margin-left:0pt;">MyISAM引擎(原本Mysql的默认引擎)：<span style="color:#c00000;">不提供事务的支持</span>，也不支持行级锁和外键。</p> 
<p style="margin-left:0pt;">MEMORY引擎：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</p> 
<ul><li>MyISAM与InnoDB区别：</li></ul> 
<p style="margin-left:0pt;">MyISAM：</p> 
<ol><li>每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件；</li><li>存储空间较小</li><li>数据和索引是分别存储的，数据.MYD，索引.MYI</li><li>按记录插入顺序保存</li><li>不支持外键和事务；不支持哈希索引，支持全文索引；</li><li>表级锁定</li><li>B+树索引，myisam 是堆表</li></ol> 
<p style="margin-left:0pt;">Innodb：</p> 
<ol><li>所有的表都保存在同一个数据文件中</li><li>数据和索引是集中存储的，.ibd</li><li>按主键大小有序插入</li><li>支持外键和事务</li><li>行级锁定、表级锁定，锁定力度小并发能力高</li><li>支持哈希索引，不支持全文索引</li><li>B+树索引，Innodb 是索引组织表</li></ol> 
<p style="margin-left:0pt;">select count(*)，myisam更快，因为myisam内部维护了一个计数器，可以直接调取。INSERT、UPDATE、DELETEInnoDB更优，SELECTMyISAM更优。</p> 
<h4 id="3.%E4%BA%8B%E5%8A%A1%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><strong><strong><strong>3.事务四大特性</strong></strong></strong></h4> 
<ul><li>原子性，要么执行，要么不执行</li></ul> 
<ul><li>隔离性，所有操作全部执行完以前其它会话不能看到过程</li><li>一致性，事务前后，数据总额一致</li><li>持久性，一旦事务提交，对数据的改变就是永久的</li></ul> 
<h4 id="4.%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8B%E2%80%8BMYSQL%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%8C%BA%E5%88%AB%EF%BC%88%E4%BA%8B%E5%8A%A1%E3%80%81%E9%94%81%E7%BA%A7%E5%88%AB%E7%AD%89%E7%AD%89%EF%BC%89%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">4.<strong><strong><strong>MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景</strong></strong></strong></h4> 
<p style="margin-left:0pt;">MYISAM：不支持外键，表锁，插入数据时，锁定整个表，查表总行数时，不需要全表扫描；</p> 
<p style="margin-left:0pt;">INNODB：支持外键，行锁，查表总行数时，全表扫描</p> 
<h4 id="5.%20%E7%B4%A2%E5%BC%95"><strong><strong><strong>5. 索引</strong></strong></strong></h4> 
<p style="margin-left:0pt;">索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p> 
<p style="margin-left:0pt;">索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p> 
<p style="margin-left:0pt;">更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</p> 
<p style="margin-left:0pt;">mysql的索引是在存储引擎层实现，而不是在服务器层。</p> 
<ul><li>索引的优点：</li></ul> 
<p style="margin-left:0pt;">可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p> 
<p style="margin-left:0pt;">通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p> 
<ul><li>索引的缺点：</li></ul> 
<p style="margin-left:0pt;">时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</p> 
<p style="margin-left:0pt;">空间方面：索引需要占物理空间。</p> 
<p style="margin-left:0pt;">对数据进行频繁查询建立索引，如果要频繁更改数据不建议使用索引。</p> 
<ul><li>显示索引：</li></ul> 
<p style="margin-left:0pt;">SHOW INDEX FROM student</p> 
<p style="margin-left:0pt;"></p> 
<p style="margin-left:0pt;">EXPLAIN select * from student --查看SQL是否使用索引，前面加上explain即可</p> 
<p style="margin-left:0pt;"></p> 
<ul><li>添加索引：</li></ul> 
<p style="margin-left:0pt;"><span style="color:#c00000;">alter table </span>表名 add index(字段名)</p> 
<p style="margin-left:0pt;">ALTER TABLE table_name ADD <span style="color:#c00000;">UNIQUE</span> (column); --建立唯一索引</p> 
<p style="margin-left:0pt;">ALTER TABLE table_name ADD UNIQUE (column1,column2); --建立唯一索引列</p> 
<p style="margin-left:0pt;">ALTER TABLE table_name ADD FULLTEXT (column);--创建全文索引</p> 
<p style="margin-left:0pt;"><span style="color:#c00000;">CREATE INDEX</span> index_name ON table_name (column_list);--只能创建普通索引，唯一索引，不能创建主键索引。</p> 
<ul><li>删除索引：</li></ul> 
<p style="margin-left:0pt;">根据索引名删除普通索引、唯一索引、全文索引：alter table 表名 <span style="color:#c00000;">drop KEY</span> 索引名</p> 
<p style="margin-left:0pt;">删除主键索引：alter table 表名 drop primary key</p> 
<ul><li>索引分类：</li></ul> 
<p style="margin-left:0pt;">索引按照实现方式不同可以分为 <span style="color:#c00000;">B-Tree索引</span>、<span style="color:#c00000;">hash索引</span>、<span style="color:#c00000;">空间数据索</span>引以及<span style="color:#c00000;">全文索引</span>等。如果没有特别指明，多半用的是B-Tree索引，B-Tree 对索引列是顺序存储的，因此很适合查找范围数据。它能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据。</p> 
<p style="margin-left:0pt;">我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p> 
<p style="margin-left:0pt;">hash索引，等值查询效率高，不能排序,不能进行范围查询；</p> 
<p style="margin-left:0pt;">B+树 数据有序,范围查询。</p> 
<p style="margin-left:0pt;">B+tree性质：</p> 
<p style="margin-left:0pt;">1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</p> 
<p style="margin-left:0pt;">2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p> 
<p style="margin-left:0pt;">3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</p> 
<p style="margin-left:0pt;">4.）B+ 树中，数据对象的插入和删除仅在叶节点上进行。</p> 
<p style="margin-left:0pt;">5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p> 
<p style="margin-left:0pt;">当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。</p> 
<p style="margin-left:0pt;">Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</p> 
<p style="margin-left:0pt;">BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量。</p> 
<p style="margin-left:0pt;">-- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如：</p> 
<p style="margin-left:0pt;">select * from user where name like '%jack';</p> 
<ul><li>创建索引的原则：</li></ul> 
<p style="margin-left:0pt;">1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p> 
<p style="margin-left:0pt;">2）较频繁作为查询条件的字段才去创建索引</p> 
<p style="margin-left:0pt;">3）更新频繁字段不适合创建索引</p> 
<p style="margin-left:0pt;">4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</p> 
<p style="margin-left:0pt;">5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p> 
<p style="margin-left:0pt;">6）定义有外键的数据列一定要建立索引。</p> 
<p style="margin-left:0pt;">7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p> 
<p style="margin-left:0pt;">8）对于定义为text、image和bit的数据类型的列不要建立索引。</p> 
<ul><li>失效条件</li></ul> 
<p style="margin-left:0pt;">条件是or,如果还想让or条件生效，给or每个字段加个索引</p> 
<p style="margin-left:0pt;">like查询，以%开发</p> 
<p style="margin-left:0pt;">内部函数</p> 
<p style="margin-left:0pt;">对索引列进行计算</p> 
<p style="margin-left:0pt;">is null不会用，is not null 会用</p> 
<p style="margin-left:0pt;"></p> 
<ul><li>什么是聚簇索引：</li></ul> 
<p style="margin-left:0pt;">聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据。</p> 
<p style="margin-left:0pt;">非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行。</p> 
<ul><li>联合索引：</li></ul> 
<p style="margin-left:0pt;">MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p> 
<p style="margin-left:0pt;"></p> 
<h4 id="6.%20InnoDB%E7%B4%A2%E5%BC%95%E5%92%8CMyISAM%E7%B4%A2%E5%BC%95%E7%9A%84%E5%8C%BA%E5%88%AB"><strong><strong><strong>6. InnoDB索引和MyISAM索引的区别</strong></strong></strong></h4> 
<p style="margin-left:0pt;">InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</p> 
<p style="margin-left:0pt;">InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</p> 
<p style="margin-left:0pt;">MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</p> 
<p style="margin-left:0pt;">InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</p> 
<h4 id="7.%20Sql%E7%9A%84%E4%BC%98%E5%8C%96"><strong><strong><strong>7. Sql的优化</strong></strong></strong></h4> 
<ol><li>sql尽量使用索引,而且查询要走索引；</li><li>对sql语句优化</li></ol> 
<p style="margin-left:0pt;">大表数据查询，怎么优化</p> 
<p style="margin-left:0pt;">优化shema、sql语句+索引；</p> 
<p style="margin-left:0pt;">第二加缓存，memcached, redis；</p> 
<p style="margin-left:0pt;">主从复制，读写分离；</p> 
<p style="margin-left:0pt;">垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</p> 
<p style="margin-left:0pt;">水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</p> 
<h4 id="8.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><strong><strong><strong>8. 数据库的主从复制</strong></strong></strong></h4> 
<p style="margin-left:0pt;">将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p> 
<p style="margin-left:0pt;">异步复制--默认异步复制，容易造成主库数据和从库不一致,一个数据库为Master,一个数据库为slave,通过Binlog日志,slave两个线程，一个线程去读master binlog日志，写到自己的中继日志一个线程解析日志，执行sql,master启动一个线程,给slave传递binlog日志；</p> 
<p style="margin-left:0pt;">半同步复制--只有把master发送的binlog日志写到slave的中继日志，这时主库,才返回操作完成的反馈，性能有一定降低；</p> 
<p style="margin-left:0pt;">并行操作--slave 多个线程去请求binlog日志。</p> 
<ol><li>基本原理流程，3个线程以及之间的关联</li></ol> 
<p style="margin-left:0pt;">主：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</p> 
<p style="margin-left:0pt;">从：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；</p> 
<p style="margin-left:0pt;">从：sql执行线程——执行relay log中的语句；</p> 
<ol><li>主从复制的作用</li></ol> 
<p style="margin-left:0pt;">主数据库出现问题，可以切换到从数据库。</p> 
<p style="margin-left:0pt;">可以进行数据库层面的读写分离。</p> 
<p style="margin-left:0pt;">可以在从数据库上进行日常备份。</p> 
<ol><li>MySQL主从复制解决的问题</li></ol> 
<p style="margin-left:0pt;">数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</p> 
<p style="margin-left:0pt;">负载均衡：降低单个服务器的压力</p> 
<p style="margin-left:0pt;">高可用和故障切换：帮助应用程序避免单点失败</p> 
<p style="margin-left:0pt;">升级测试：可以用更高版本的MySQL作为从库</p> 
<h4 id="9.varchar%E5%92%8Cchar%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" style="margin-left:0pt;"><strong><strong><strong>9.varchar和char的使用场景</strong></strong></strong></h4> 
<p style="margin-left:0pt;">int(10)的10表示显示的数据的长度，不是存储数据的大小；chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。</p> 
<p style="margin-left:0pt;">Varchar：字符长度经常变的</p> 
<p style="margin-left:0pt;">Char：用字符长度固定的</p> 
<h4 id="10.%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E4%BD%9C%E7%94%A8"><strong><strong><strong>10.数据库连接池的作用</strong></strong></strong></h4> 
<p style="margin-left:0pt;">维护一定数量的连接，减少创建连接的时间</p> 
<p style="margin-left:0pt;">更快的响应时间</p> 
<p style="margin-left:0pt;">统一的管理</p> 
<h4 id="11.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F"><strong><strong><strong>11. 数据库三范式</strong></strong></strong></h4> 
<p style="margin-left:0pt;">第一范式：每个列都不可以再拆分。例如表中有电话，可以拆成家庭和工作，就不是第一范式。</p> 
<p style="margin-left:0pt;">第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p> 
<p style="margin-left:0pt;">第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。例如存在学生--&gt;学校--&gt;学校地址，则不行。把他们分成两个表。</p> 
<p style="margin-left:0pt;">在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p> 
<h4 id="12.%20%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E9%9D%9E%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%BA%E5%88%AB"><strong><strong><strong>12. 关系型数据库和非关系型数据库区别</strong></strong></strong></h4> 
<ul><li>什么是关系型数据库：</li></ul> 
<p style="margin-left:0pt;">关系型数据库是依据关系模型来创建的数据库。所谓关系模型就是“一对一、一对多、多对多”等关系模型，关系模型就是指二维表格模型,因而一个关系型数据库就是由二维表及其之间的联系组成的一个数据组织。</p> 
<ul><li>特点：</li></ul> 
<p style="margin-left:0pt;">安全（因为存储在磁盘中，不会说突然断电数据就没有了）、</p> 
<p style="margin-left:0pt;">容易理解（建立在关系模型上）、</p> 
<p style="margin-left:0pt;">但不节省空间（因为建立在关系模型上，就要遵循某些规则，好比数据中某字段值即使为空仍要分配空间）</p> 
<ul><li>优点</li></ul> 
<p style="margin-left:0pt;">1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；</p> 
<p style="margin-left:0pt;">2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；</p> 
<p style="margin-left:0pt;">3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；</p> 
<p style="margin-left:0pt;">4、支持SQL，可用于复杂的查询。</p> 
<p style="margin-left:0pt;">5.支持事务</p> 
<ul><li>缺点</li></ul> 
<p style="margin-left:0pt;">1、为了维护一致性所付出的巨大代价就是其读写性能比较差；</p> 
<p style="margin-left:0pt;">2、固定的表结构；</p> 
<p style="margin-left:0pt;">3、不支持高并发读写需求；</p> 
<p style="margin-left:0pt;">4、不支持海量数据的高效率读写</p> 
<ul><li>什么是非关系型数据库：</li></ul> 
<p style="margin-left:0pt;">非关系型数据库主要是基于“非关系模型”的数据库（由于关系型太大，所以一般用“非关系型”来表示其他类型的数据库）Hbase</p> 
<p style="margin-left:0pt;">非关系型模型比如有：</p> 
<p style="margin-left:0pt;">列模型：存储的数据是一列列的。关系型数据库以一行作为一个记录，列模型数据库以一列为一个记录。（这种模型，数据即索引，IO很快，主要是一些分布式数据库）</p> 
<p style="margin-left:0pt;">键值对模型：存储的数据是一个个“键值对”，比如name:liming,那么name这个键里面存的值就是liming</p> 
<p style="margin-left:0pt;">文档类模型：以一个个文档来存储数据，有点类似“键值对”。</p> 
<ul><li>特点：</li></ul> 
<p style="margin-left:0pt;">效率高（因为存储在内存中）、</p> 
<p style="margin-left:0pt;">但不安全（断电丢失数据，但其中redis可以同步数据到磁盘中），现在很多非关系型数据库都开始支持转存到磁盘中。</p> 
<p style="margin-left:0pt;">1、使用键值对存储数据；</p> 
<p style="margin-left:0pt;">2、分布式；</p> 
<ul><li>优点</li></ul> 
<p style="margin-left:0pt;">无需经过sql层的解析，读写性能很高</p> 
<p style="margin-left:0pt;">基于键值对，数据没有耦合性，容易扩展</p> 
<p style="margin-left:0pt;">存储数据的格式：nosql的存储格式是key,value形式</p> 
<ul><li>缺点</li></ul> 
<p style="margin-left:0pt;">不提供sql支持</p> 
<h4 id="13.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%ADjoin%E7%9A%84left%20join%20%2C%20inner%20join%2C%20cross%20join"><strong><strong><strong>13. 数据库中join的left join , inner join, cross join</strong></strong></strong></h4> 
<p style="margin-left:0pt;">以A，B两张表为例</p> 
<p style="margin-left:0pt;">A表：</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:142pt;"> <p style="margin-left:0pt;">A</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:0pt;">B</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:0pt;">C</p> </td></tr><tr><td style="vertical-align:top;width:142pt;"> <p style="margin-left:0pt;">a1</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:0pt;">b1</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:0pt;">c1</p> </td></tr><tr><td style="vertical-align:top;width:142pt;"> <p style="margin-left:0pt;">a2</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:0pt;">b2</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:0pt;">c2</p> </td></tr><tr><td style="vertical-align:top;width:142pt;"> <p style="margin-left:0pt;">a3</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:0pt;">b3</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:0pt;">c3</p> </td></tr></tbody></table> 
<p style="margin-left:0pt;">B表：</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:0pt;">C</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:0pt;">D</p> </td></tr><tr><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:0pt;">c1</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:0pt;">d1</p> </td></tr><tr><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:0pt;">c2</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:0pt;">d2</p> </td></tr><tr><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:0pt;">C4</p> </td><td style="vertical-align:top;width:142.05pt;"> <p style="margin-left:0pt;">d3</p> </td></tr></tbody></table> 
<p style="margin-left:0pt;"></p> 
<ol><li>A left join B (select A.*,B.* from A left join B on A.c=B.c）</li></ol> 
<p style="margin-left:0pt;">选出A的所有记录，B表中没有的以null 代替</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">A</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">B</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">C1</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">C2</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">D</p> </td></tr><tr><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">a1</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">b1</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">c1</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">c1</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">d1</p> </td></tr><tr><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">a2</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">b2</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">c2</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">c2</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">d2</p> </td></tr><tr><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">a3</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">b3</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">c3</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;"></p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;"></p> </td></tr></tbody></table> 
<p>      2、right join 同理</p> 
<p>      3、inner join(select r.*,s.* from r inner join s on r.c=s.c)</p> 
<p style="margin-left:0pt;">A,B有交集的记录</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">A</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">B</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">C1</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">C2</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">D</p> </td></tr><tr><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">a1</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">b1</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">c1</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">c1</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">d1</p> </td></tr><tr><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">a2</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">b2</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">c2</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">c2</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">d2</p> </td></tr></tbody></table> 
<p style="margin-left:0pt;">3.cross join (笛卡尔积)</p> 
<p style="margin-left:0pt;">A中的每一条记录和B中的每一条记录生成一条记录</p> 
<p style="margin-left:0pt;">例如A中有4条，B中有4条，cross join 就有16条记录</p> 
<table border="1" cellspacing="0"><tbody><tr><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">A</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">B</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">C1</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">C2</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">D</p> </td></tr><tr><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">a1</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">b1</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">c1</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">c1</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">d1</p> </td></tr><tr><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">a2</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">b2</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">c2</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">c1</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">d1</p> </td></tr><tr><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">a3</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">b3</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">c3</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">c1</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">d1</p> </td></tr><tr><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">a1</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">b1</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">c1</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">c2</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">d2</p> </td></tr><tr><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">a2</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">b2</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">c2</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">c2</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">d2</p> </td></tr><tr><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">a3</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">b3</p> </td><td style="vertical-align:top;width:85.2pt;"> <p style="margin-left:0pt;">c3</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">c2</p> </td><td style="vertical-align:top;width:85.25pt;"> <p style="margin-left:0pt;">d2</p> </td></tr></tbody></table> 
<h4 id="14.%E6%9C%89%E5%93%AA%E4%BA%9B%E9%94%81%2Cselect%E6%97%B6%E6%80%8E%E4%B9%88%E5%8A%A0%E6%8E%92%E5%AE%83%E9%94%81"><strong><strong><strong>14.有哪些锁,select时怎么加排它锁</strong></strong></strong></h4> 
<ol><li>按照锁的粒度分数据库锁:</li></ol> 
<p style="margin-left:0pt;">行级锁(INNODB引擎):行级锁是Mysql中锁定粒度最细的一种锁，表示<span style="color:#c00000;">只针对当前操作的行进行加锁</span>。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁和排他锁。</p> 
<p style="margin-left:0pt;">特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p> 
<p style="margin-left:0pt;">表级锁(MYISAM引擎):表级锁是MySQL中锁定粒度最大的一种锁，<span style="color:#c00000;">表示对当前操作的整张表加锁</span>，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p> 
<p style="margin-left:0pt;">特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p> 
<p style="margin-left:0pt;">页级锁(BDB引擎 ):页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p> 
<p style="margin-left:0pt;">特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p> 
<ol><li>从锁的类别上分：</li></ol> 
<p style="margin-left:0pt;">共享锁（S锁）：又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p> 
<p style="margin-left:0pt;">排他锁（x锁）：又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。<span style="color:#c00000;">排他锁只可以加一个</span>，他和其他的排他锁，共享锁都相斥。</p> 
<p style="margin-left:0pt;">锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。</p> 
<ol><li>MySQL中InnoDB引擎的行锁是怎么实现的：</li></ol> 
<p style="margin-left:0pt;">InnoDB是基于索引来完成行锁，select * from tab_with_index where id = 1 for update;</p> 
<p style="margin-left:0pt;">for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起。</p> 
<ol><li>数据库的乐观锁和悲观锁：</li></ol> 
<p style="margin-left:0pt;">数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p> 
<p style="margin-left:0pt;">悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制。</p> 
<p style="margin-left:0pt;">共享锁，多个事务，只能读不能写，加 lock in share mode</p> 
<p style="margin-left:0pt;">乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p> 
<h4 id="15.%20%E6%AD%BB%E9%94%81%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><strong><strong><strong>15. 死锁怎么解决</strong></strong></strong></h4> 
<p style="margin-left:0pt;">死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p> 
<p style="margin-left:0pt;">常见的解决死锁的方法</p> 
<p style="margin-left:0pt;">1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p> 
<p style="margin-left:0pt;">2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p> 
<p style="margin-left:0pt;">3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p> 
<p style="margin-left:0pt;">如果业务处理不好可以用分布式事务锁或者使用乐观锁</p> 
<h4 id="16.%20%E4%BA%8B%E5%8A%A1"><strong><strong><strong>16. 事务</strong></strong></strong></h4> 
<p style="margin-left:0pt;">事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p> 
<ol><li>事务四大特性</li></ol> 
<p style="margin-left:0pt;">原子性，要么执行，要么不执行</p> 
<p style="margin-left:0pt;">隔离性，所有操作全部执行完以前其它会话不能看到过程</p> 
<p style="margin-left:0pt;">一致性，事务前后，数据总额一致</p> 
<p style="margin-left:0pt;">持久性，一旦事务提交，对数据的改变就是永久的</p> 
<ol><li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li><li>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li><li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间修改了一列数据。</li><li>SQL 标准定义了四个隔离级别：</li></ol> 
<p style="margin-left:0pt;">READ-UNCOMMITTED(<span style="color:#c00000;">读取未提交</span>)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p> 
<p style="margin-left:0pt;">READ-COMMITTED(<span style="color:#c00000;">读取已提交</span>)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p> 
<p style="margin-left:0pt;">REPEATABLE-READ(<span style="color:#c00000;">可重复读</span>)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p> 
<p style="margin-left:0pt;">SERIALIZABLE(<span style="color:#c00000;">可串行化</span>)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p> 
<h4 id="17.%20%E8%A7%86%E5%9B%BE"><strong><strong><strong>17. 视图</strong></strong></strong></h4> 
<p style="margin-left:0pt;">视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</p> 
<ol><li>视图的特点如下:</li></ol> 
<p style="margin-left:0pt;">视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</p> 
<p style="margin-left:0pt;">视图是由基本表(实表)产生的表(虚表)。</p> 
<p style="margin-left:0pt;">视图的建立和删除不影响基本表。</p> 
<p style="margin-left:0pt;">对视图内容的更新(添加，删除和修改)直接影响基本表。</p> 
<p style="margin-left:0pt;">当视图来自多个基本表时，不允许添加和删除数据。</p> 
<p style="margin-left:0pt;">视图的操作包括创建视图，查看视图，删除视图和修改视图。</p> 
<ol><li>视图的优点：</li></ol> 
<p style="margin-left:0pt;">查询简单化。视图能简化用户的操作；</p> 
<p style="margin-left:0pt;">数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护；</p> 
<p style="margin-left:0pt;">逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性；</p> 
<ol><li>视图的缺点</li></ol> 
<p style="margin-left:0pt;">性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要<span style="color:#c00000;">花费一定的时间</span>。</p> 
<p style="margin-left:0pt;">修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的</p> 
<p style="margin-left:0pt;">这些视图有如下特征：</p> 
<ol><li>有UNIQUE等集合操作符的视图。</li><li>有GROUP BY子句的视图。</li><li>有诸如AVG\SUM\MAX等聚合函数的视图。</li><li>使用DISTINCT关键字的视图。</li><li>连接表的视图（其中有些例外）</li></ol> 
<h4 id="18.%20%E6%B8%B8%E6%A0%87"><strong><strong><strong>18. 游标</strong></strong></strong></h4> 
<p style="margin-left:0pt;">游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</p> 
<h4 id="19.%20%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B"><strong><strong><strong>19. 存储过程</strong></strong></strong></h4> 
<p style="margin-left:0pt;">存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p> 
<p style="margin-left:0pt;">优点：</p> 
<p style="margin-left:0pt;">1）存储过程是预编译过的，执行效率高。</p> 
<p style="margin-left:0pt;">2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p> 
<p style="margin-left:0pt;">3）安全性高，执行存储过程需要有一定权限的用户。</p> 
<p style="margin-left:0pt;">4）存储过程可以重复使用，减少数据库开发人员的工作量。</p> 
<p style="margin-left:0pt;">缺点：</p> 
<p style="margin-left:0pt;">1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</p> 
<p style="margin-left:0pt;">2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p> 
<p style="margin-left:0pt;">3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p> 
<p style="margin-left:0pt;">4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p> 
<h4 id="20.%20%E8%A7%A6%E5%8F%91%E5%99%A8"><strong><strong><strong>20. 触发器</strong></strong></strong></h4> 
<p style="margin-left:0pt;">触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</p> 
<p style="margin-left:0pt;">在MySQL数据库中有如下六种触发器：</p> 
<p style="margin-left:0pt;">Before Insert</p> 
<p style="margin-left:0pt;">After Insert</p> 
<p style="margin-left:0pt;">Before Update</p> 
<p style="margin-left:0pt;">After Update</p> 
<p style="margin-left:0pt;">Before Delete</p> 
<p style="margin-left:0pt;">After Delete</p> 
<h4 id="21.%20drop%E3%80%81delete%E4%B8%8Etruncate%E7%9A%84%E5%8C%BA%E5%88%AB"><strong><strong><strong>21. drop、delete与truncate的区别</strong></strong></strong></h4> 
<p style="margin-left:0pt;">Drop：可回滚；表结构还在，<span style="color:#c00000;">删除表的全部或者一部分数据行</span>；删除速度慢，需要逐行删除；</p> 
<p style="margin-left:0pt;">truncate：不可回滚；表结构还在，<span style="color:#c00000;">删除表中的所有数据</span>；删除速度快；</p> 
<p style="margin-left:0pt;">Delete：不可回滚；<span style="color:#c00000;">从数据库中删除表</span>，所有的数据行，索引和权限也会被删除；删除速度最快；</p> 
<h4 id="22.%20UNION%E4%B8%8EUNION%20ALL%E7%9A%84%E5%8C%BA%E5%88%AB"><strong><strong><strong>22. UNION与UNION ALL的区别</strong></strong></strong></h4> 
<p style="margin-left:0pt;">UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p> 
<p style="margin-left:0pt;">如果使用UNION ALL，不会合并重复的记录行</p> 
<p style="margin-left:0pt;">效率 UNION 高于 UNION ALL</p> 
<h4 id="23.%20Mysql%E5%88%86%E9%A1%B5"><strong><strong><strong>23. Mysql分页</strong></strong></strong></h4> 
<p style="margin-left:0pt;">LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)。</p> 
<p style="margin-left:0pt;">mysql&gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15</p> 
<p style="margin-left:0pt;">为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</p> 
<p style="margin-left:0pt;">mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.</p> 
<p style="margin-left:0pt;">如果只给定一个参数，它表示返回最大的记录行数目：</p> 
<p style="margin-left:0pt;">mysql&gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行</p> 
<h4 id="24.%20%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96"><strong><strong><span style="color:#c00000;"><strong>24. 数据库优化</strong></span></strong></strong></h4> 
<ul><li>结构优化：</li></ul> 
<p style="margin-left:0pt;">将字段很多的表分解成多个表；</p> 
<p style="margin-left:0pt;">增加中间表：对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p> 
<p style="margin-left:0pt;">增加冗余字段：设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/40a2678adba4c3bde503c8d520fee11e/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">redis高可用集群搭建</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/6f63cd8328cbf17c21c1e825d878af45/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">uniapp开发的h5网页如何去掉网址里的#号</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>