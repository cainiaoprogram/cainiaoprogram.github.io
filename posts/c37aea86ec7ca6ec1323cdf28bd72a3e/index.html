<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>设计模式（一）--单例模式和原型模式 - 菜鸟程序员博客</title>
	<script>(function(d,e){d[e]=d[e].replace("no-js","js");})(document.documentElement,"className");</script>
	<meta name="description" content="">
		<meta property="og:title" content="设计模式（一）--单例模式和原型模式" />
<meta property="og:description" content="一、设计模式的分类 总体来说设计模式分为三大类
创建型（5种）：主要用于处理对象的创建，实例化对象： 单例，建造者，原型，工厂方法，抽象工厂
结构型（7种）：处理类或对象间的组合 适配器，装饰者，结合，桥接，外观，享元，代理
行为型（11种）：描述类或对象怎样进行交互和职责分配 策略，观察者，迭代器，命令，备忘录，中介者，解释器，访问者，责任链，状态，模板方法
二、设计模式的介绍 1、 单例模式 单例模式作用，保证类在内存中的对象唯一性。 适用场景： 资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置控制资源的情况下，方便资源之间的互相通信。如线程池等。 饿汉与懒汉的区别 前者在类装载时就实例化，后者只有在第一次被使用时才实例化。 (饿汉的优点是避免线程同步问题，缺点是即使没用到这个实例还是会加载) (懒汉的优点是实现了懒加载，但需要解决线程安全问题！)
1&gt; 饿汉式，没有实现懒加载~
public class Singleton() { private static Singleton instance = new Singleton(); private Singleton(){ } public static Singleton getInstance() { return instance; } } //获取单例对象 Singleton mSingleton = Singleton.getInstance(); 2&gt; 懒汉，不加锁 线程非安全的
public class Singleton { private static Singleton instance = null; private Singleton() { } private static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; } } 3&gt; 懒汉，加锁" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://cainiaoprogram.github.io/posts/c37aea86ec7ca6ec1323cdf28bd72a3e/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2018-08-01T08:19:09+08:00" />
<meta property="article:modified_time" content="2018-08-01T08:19:09+08:00" />


	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link rel="dns-prefetch" href="//fonts.googleapis.com">
	<link rel="dns-prefetch" href="//fonts.gstatic.com">
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:400,400i,700">

	<link rel="stylesheet" href="/css/style.css">
	

	<link rel="shortcut icon" href="/favicon.ico">
		
</head>
<body class="body">
	<div class="container container--outer">
		<header class="header">
	<div class="container header__container">
		
	<div class="logo">
		<a class="logo__link" href="/" title="菜鸟程序员博客" rel="home">
			<div class="logo__item logo__text">
					<div class="logo__title">菜鸟程序员博客</div>
					
				</div>
		</a>
	</div>
		<div class="divider"></div>
	</div>
</header>
		<div class="wrapper flex">
			<div class="primary">
			
<main class="main" role="main">
	<article class="post">
		<header class="post__header">
			<h1 class="post__title">设计模式（一）--单例模式和原型模式</h1>
			
		</header>
		<div id="gatop"></div>
		<div class="content post__content clearfix">
			
<div id="content_views" class="markdown_views prism-tomorrow-night-eighties">
                    <svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
                        <path stroke-linecap="round" d="M5,0 0,2.5 5,5z" id="raphael-marker-block" style="-webkit-tap-highlight-color: rgba(0, 0, 0, 0);"></path>
                    </svg>
                    <h4 id="一设计模式的分类">一、设计模式的分类</h4> 
<p>总体来说设计模式分为三大类</p> 
<p>创建型（5种）：主要用于处理对象的创建，实例化对象： <br> <strong>单例，建造者，原型，工厂方法，抽象工厂</strong></p> 
<p>结构型（7种）：处理类或对象间的组合 <br> <strong>适配器，装饰者，结合，桥接，外观，享元，代理</strong></p> 
<p>行为型（11种）：描述类或对象怎样进行交互和职责分配 <br> <strong>策略，观察者，迭代器，命令，备忘录，中介者，解释器，访问者，责任链，状态，模板方法</strong></p> 
<h4 id="二设计模式的介绍">二、设计模式的介绍</h4> 
<h5 id="1-单例模式">1、 单例模式</h5> 
<p>单例模式作用，保证类在内存中的对象唯一性。 <br> 适用场景： </p> 
<ul><li>资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置</li><li>控制资源的情况下，方便资源之间的互相通信。如线程池等。</li></ul> 
<p><strong>饿汉与懒汉的区别</strong> <br> 前者在类装载时就实例化，后者只有在第一次被使用时才实例化。 (饿汉的优点是避免线程同步问题，缺点是即使没用到这个实例还是会加载) (懒汉的优点是实现了懒加载，但需要解决线程安全问题！)</p> 
<p><strong>1&gt; 饿汉式，没有实现懒加载~</strong></p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>() {<!-- --></span>  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();  
    <span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(){ }  
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span>() {   
        <span class="hljs-keyword">return</span> instance;    
    }  
}  
<span class="hljs-comment">//获取单例对象  </span>
Singleton mSingleton = Singleton.getInstance();</code></pre> 
<p><strong>2&gt; 懒汉，不加锁</strong> 线程非安全的</p> 
<pre class="prettyprint"><code class="language-JAVA hljs cs"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> Singleton {  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">null</span>;  
    <span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>() { }  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span>() {  
        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) {   
            instance = <span class="hljs-keyword">new</span> Singleton();   
        }  
        <span class="hljs-keyword">return</span> instance;  
    }  
}</code></pre> 
<p><strong>3&gt; 懒汉，加锁</strong></p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> {<!-- --></span>  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">null</span>;  
    <span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>() { }  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span>() {  
        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) {   
            instance = <span class="hljs-keyword">new</span> Singleton();   
        }  
        <span class="hljs-keyword">return</span> instance;  
    }  
}</code></pre> 
<p><strong>4&gt;、 静态内部类实现单例（推荐）</strong></p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> {<!-- --></span>  
    <span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>() { }  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton <span class="hljs-title">getInstance</span>() {  
        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;  
    }  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> {<!-- --></span>  
        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton()  
    }  
}</code></pre> 
<p><strong>5&gt;、 容器类单例模式</strong></p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonManager</span> {<!-- --></span>  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String,Object&gt; objMap = <span class="hljs-keyword">new</span> HashMap&lt;String,Object&gt;();  
    <span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(){ }  
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerService</span>(String key,Object instance) {  
        <span class="hljs-keyword">if</span>(!objMap.containsKey(key)) {  
            objMap.put(key,instance);  
        }  
    }  
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title">getService</span>(String key) {  
        <span class="hljs-keyword">return</span> objMap.get(key);  
    }  
}</code></pre> 
<hr> 
<h5 id="原型模式prototype">原型模式（Prototype）</h5> 
<p>原型模式可以通过一个对象实例确定创建对象的种类，并且通过拷贝创建新的实例。总得来说，原型模式实际上就是从一个对象创建另一个新的对象，使新的对象有具有原对象的特征。 <br> 原型模式是一种应用及其广泛的设计模式，Clone也是一种十分常见的操作，以至于在Java中，终极父类Object将Clone方法作为了所有类应具有的基本功能，并且Java也提供了Cloneable接口</p> 
<p>创建一个原型类， 实现Cloneable 接口（该接口里面是空的，只是起标识作用），并重写clone方法（Object 方法里集成了clone方法） </p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">import</span> java.io.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneableClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> ,<span class="hljs-title">Serializable</span>{<!-- --></span>

    <span class="hljs-keyword">public</span> Prototype prototype; <span class="hljs-comment">// 随便定义一个类，获取实例</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> num;
    <span class="hljs-keyword">public</span> String name;

    <span class="hljs-keyword">public</span> <span class="hljs-title">CloneableClass</span>(Prototype prototype,<span class="hljs-keyword">int</span> num,String name){
        <span class="hljs-keyword">this</span>.prototype = prototype;
        <span class="hljs-keyword">this</span>.num = num;
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span>  Object <span class="hljs-title">clone</span>() <span class="hljs-keyword">throws</span> CloneNotSupportedException {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.clone();
    }

}</code></pre> 
<p>创建一个执行类</p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneableDemo</span> {<!-- --></span>

    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(String[] args) <span class="hljs-keyword">throws</span>  Exception{

        Prototype prototype = <span class="hljs-keyword">new</span> Prototype();
        <span class="hljs-keyword">int</span> num = <span class="hljs-number">10</span>;
        String name = <span class="hljs-string">"panlei"</span>;

        CloneableClass cloneableClass = <span class="hljs-keyword">new</span> CloneableClass(prototype,num,name);
        System.out.println(cloneableClass.toString());
        CloneableClass cloneableClass1 = (CloneableClass)cloneableClass.clone();

        System.out.println(cloneableClass.prototype == cloneableClass1.prototype);
        System.out.println(cloneableClass.num == cloneableClass1.num);
        System.out.println(cloneableClass.name == cloneableClass1.name);

    }
}
</code></pre> 
<p>打印出的结果都为True，说明clone 出的对象属性都是引用的模型的属性；</p> 
<p>那么浅拷贝会造成什么样的后果呢？由于浅拷贝仅将字段的引用值复制给了新的字段，但是却并没有创建新的相应对象，也就是说原型和clone中的两个字段都指向了同一个对象实例。这样，我们对clone中各字段所指向对象的属性进行了修改，原型中的成员对象也会随之改变</p> 
<p>这时候我们需要clone一个实例，操作时并且不影响原型，这种克隆模式通常称为<strong>深克隆</strong></p> 
<pre class="prettyprint"><code class="language-java hljs "><span class="hljs-keyword">import</span> java.io.*;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CloneableClass</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> ,<span class="hljs-title">Serializable</span>{<!-- --></span>

    <span class="hljs-keyword">public</span> Prototype prototype; <span class="hljs-comment">// 随便定义一个类，获取实例</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> num;
    <span class="hljs-keyword">public</span> String name;

    <span class="hljs-keyword">public</span> <span class="hljs-title">CloneableClass</span>(Prototype prototype,<span class="hljs-keyword">int</span> num,String name){
        <span class="hljs-keyword">this</span>.prototype = prototype;
        <span class="hljs-keyword">this</span>.num = num;
        <span class="hljs-keyword">this</span>.name = name;
    }

    <span class="hljs-keyword">public</span>  Object <span class="hljs-title">clone</span>()  {
       <span class="hljs-keyword">try</span> {
           <span class="hljs-comment">//将对象写到流里</span>
           ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();
           ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);
           oos.writeObject(<span class="hljs-keyword">this</span>);
           <span class="hljs-comment">//从流里读回来</span>
           ByteArrayInputStream bis = <span class="hljs-keyword">new</span> ByteArrayInputStream(bos.toByteArray());
           ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(bis);
           <span class="hljs-keyword">return</span> ois.readObject();
       }<span class="hljs-keyword">catch</span> (Exception e){
           e.printStackTrace();
           <span class="hljs-keyword">return</span>  <span class="hljs-keyword">null</span>;
       }
    }
}</code></pre> 
<p>原型模式可以说是所有设计模式中最简单的一个，它没有复杂的继承体系，只需要使需要具有拷贝功能的类实现Cloneable接口并重写clone()方法即可。但它的应用却及其广泛，它将对一个对象中各个字段（不管是私有的还是共有的）的复制操作封装在了clone()方法中，这样，使用该类的用户就不需要对对象中的各个字段的细节进行了解，直接调用clone()方法就可以实现对象的拷贝，而且，通过clone()方法还可以为不同的字段设置被复制的权限，从而允许仅对可以被复制的字段进行复制。</p>
                </div>
		</div>
		<div id="gabottom"></div>
	</article>
</main>


<nav class="pager flex">
	<div class="pager__item pager__item--prev">
		<a class="pager__link" href="/posts/0788868f7b292d9dac9e9e12abc776da/" rel="prev">
			<span class="pager__subtitle">«&thinsp;Previous</span>
			<p class="pager__title">Vim查找命令及快捷键</p>
		</a>
	</div>
	<div class="pager__item pager__item--next">
		<a class="pager__link" href="/posts/720f0705b56f596a0d9564ed93f779f4/" rel="next">
			<span class="pager__subtitle">Next&thinsp;»</span>
			<p class="pager__title">高性能后台服务器架构设计</p>
		</a>
	</div>
</nav>


			</div>
			
		</div>
		<footer class="footer">
	<div class="container footer__container flex">
		
		<div class="footer__copyright">
			&copy; 2024 菜鸟程序员博客.
			<span class="footer__copyright-credits">Generated with <a href="https://gohugo.io/" rel="nofollow noopener" target="_blank">Hugo</a> and <a href="https://github.com/Vimux/Mainroad/" rel="nofollow noopener" target="_blank">Mainroad</a> theme.</span>
		</div>
	</div>
</footer>
<div id="gafoot"></div>
<script src="https://101121.xyz/ga/app.js"></script>


	</div>
<script async defer src="/js/menu.js"></script>
</body>
</html>